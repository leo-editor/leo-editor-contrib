<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20240306055458.1"><vh>@button backup</vh></v>
<v t="ekr.20240306055659.1"><vh>Notes</vh></v>
<v t="ekr.20240131003855.1"><vh>@path C:\Python\Python3.12/Lib/site-packages</vh>
<v t="ekr.20240131003855.2"><vh>pyflakes/__init__.py</vh></v>
<v t="ekr.20240131003855.3"><vh>pyflakes/__main__.py</vh></v>
<v t="ekr.20240131003855.4"><vh>@clean pyflakes/api.py</vh>
<v t="ekr.20240131003855.5"><vh>function: check</vh></v>
<v t="ekr.20240131003855.6"><vh>function: checkPath</vh></v>
<v t="ekr.20240131003855.7"><vh>function: isPythonFile</vh></v>
<v t="ekr.20240131003855.8"><vh>function: iterSourceCode</vh></v>
<v t="ekr.20240131003855.9"><vh>function: checkRecursive</vh></v>
<v t="ekr.20240131003855.10"><vh>function: _exitOnSignal</vh></v>
<v t="ekr.20240131003855.11"><vh>function: _get_version</vh></v>
<v t="ekr.20240131003855.12"><vh>function: main</vh></v>
</v>
<v t="ekr.20240131003855.240"><vh>@clean pyflakes/reporter.py</vh>
<v t="ekr.20240131003855.241"><vh>class Reporter</vh>
<v t="ekr.20240131003855.242"><vh>Reporter.__init__</vh></v>
<v t="ekr.20240131003855.243"><vh>Reporter.unexpectedError</vh></v>
<v t="ekr.20240131003855.244"><vh>Reporter.syntaxError</vh></v>
<v t="ekr.20240131003855.245"><vh>Reporter.flake</vh></v>
</v>
<v t="ekr.20240131003855.246"><vh>function: _makeDefaultReporter</vh></v>
</v>
<v t="ekr.20240131003855.165"><vh>@clean pyflakes/messages.py</vh>
<v t="ekr.20240131003855.166"><vh>class Message</vh>
<v t="ekr.20240131003855.167"><vh>Message.__init__</vh></v>
<v t="ekr.20240131003855.168"><vh>Message.__str__</vh></v>
</v>
<v t="ekr.20240131003855.169"><vh>class UnusedImport</vh>
<v t="ekr.20240131003855.170"><vh>UnusedImport.__init__</vh></v>
</v>
<v t="ekr.20240131003855.171"><vh>class RedefinedWhileUnused</vh>
<v t="ekr.20240131003855.172"><vh>RedefinedWhileUnused.__init__</vh></v>
</v>
<v t="ekr.20240131003855.173"><vh>class ImportShadowedByLoopVar</vh>
<v t="ekr.20240131003855.174"><vh>ImportShadowedByLoopVar.__init__</vh></v>
</v>
<v t="ekr.20240131003855.175"><vh>class ImportStarNotPermitted</vh>
<v t="ekr.20240131003855.176"><vh>ImportStarNotPermitted.__init__</vh></v>
</v>
<v t="ekr.20240131003855.177"><vh>class ImportStarUsed</vh>
<v t="ekr.20240131003855.178"><vh>ImportStarUsed.__init__</vh></v>
</v>
<v t="ekr.20240131003855.179"><vh>class ImportStarUsage</vh>
<v t="ekr.20240131003855.180"><vh>ImportStarUsage.__init__</vh></v>
</v>
<v t="ekr.20240131003855.181"><vh>class UndefinedName</vh>
<v t="ekr.20240131003855.182"><vh>UndefinedName.__init__</vh></v>
</v>
<v t="ekr.20240131003855.183"><vh>class DoctestSyntaxError</vh>
<v t="ekr.20240131003855.184"><vh>DoctestSyntaxError.__init__</vh></v>
</v>
<v t="ekr.20240131003855.185"><vh>class UndefinedExport</vh>
<v t="ekr.20240131003855.186"><vh>UndefinedExport.__init__</vh></v>
</v>
<v t="ekr.20240131003855.187"><vh>class UndefinedLocal</vh>
<v t="ekr.20240131003855.188"><vh>UndefinedLocal.__init__</vh></v>
</v>
<v t="ekr.20240131003855.189"><vh>class DuplicateArgument</vh>
<v t="ekr.20240131003855.190"><vh>DuplicateArgument.__init__</vh></v>
</v>
<v t="ekr.20240131003855.191"><vh>class MultiValueRepeatedKeyLiteral</vh>
<v t="ekr.20240131003855.192"><vh>MultiValueRepeatedKeyLiteral.__init__</vh></v>
</v>
<v t="ekr.20240131003855.193"><vh>class MultiValueRepeatedKeyVariable</vh>
<v t="ekr.20240131003855.194"><vh>MultiValueRepeatedKeyVariable.__init__</vh></v>
</v>
<v t="ekr.20240131003855.195"><vh>class LateFutureImport</vh></v>
<v t="ekr.20240131003855.196"><vh>class FutureFeatureNotDefined</vh>
<v t="ekr.20240131003855.197"><vh>FutureFeatureNotDefined.__init__</vh></v>
</v>
<v t="ekr.20240131003855.198"><vh>class UnusedVariable</vh>
<v t="ekr.20240131003855.199"><vh>UnusedVariable.__init__</vh></v>
</v>
<v t="ekr.20240131003855.200"><vh>class UnusedAnnotation</vh>
<v t="ekr.20240131003855.201"><vh>UnusedAnnotation.__init__</vh></v>
</v>
<v t="ekr.20240131003855.202"><vh>class ReturnOutsideFunction</vh></v>
<v t="ekr.20240131003855.203"><vh>class YieldOutsideFunction</vh></v>
<v t="ekr.20240131003855.204"><vh>class ContinueOutsideLoop</vh></v>
<v t="ekr.20240131003855.205"><vh>class BreakOutsideLoop</vh></v>
<v t="ekr.20240131003855.206"><vh>class DefaultExceptNotLast</vh></v>
<v t="ekr.20240131003855.207"><vh>class TwoStarredExpressions</vh></v>
<v t="ekr.20240131003855.208"><vh>class TooManyExpressionsInStarredAssignment</vh></v>
<v t="ekr.20240131003855.209"><vh>class IfTuple</vh></v>
<v t="ekr.20240131003855.210"><vh>class AssertTuple</vh></v>
<v t="ekr.20240131003855.211"><vh>class ForwardAnnotationSyntaxError</vh>
<v t="ekr.20240131003855.212"><vh>ForwardAnnotationSyntaxError.__init__</vh></v>
</v>
<v t="ekr.20240131003855.213"><vh>class RaiseNotImplemented</vh></v>
<v t="ekr.20240131003855.214"><vh>class InvalidPrintSyntax</vh></v>
<v t="ekr.20240131003855.215"><vh>class IsLiteral</vh></v>
<v t="ekr.20240131003855.216"><vh>class FStringMissingPlaceholders</vh></v>
<v t="ekr.20240131003855.217"><vh>class StringDotFormatExtraPositionalArguments</vh>
<v t="ekr.20240131003855.218"><vh>StringDotFormatExtraPositionalArguments.__init__</vh></v>
</v>
<v t="ekr.20240131003855.219"><vh>class StringDotFormatExtraNamedArguments</vh>
<v t="ekr.20240131003855.220"><vh>StringDotFormatExtraNamedArguments.__init__</vh></v>
</v>
<v t="ekr.20240131003855.221"><vh>class StringDotFormatMissingArgument</vh>
<v t="ekr.20240131003855.222"><vh>StringDotFormatMissingArgument.__init__</vh></v>
</v>
<v t="ekr.20240131003855.223"><vh>class StringDotFormatMixingAutomatic</vh></v>
<v t="ekr.20240131003855.224"><vh>class StringDotFormatInvalidFormat</vh>
<v t="ekr.20240131003855.225"><vh>StringDotFormatInvalidFormat.__init__</vh></v>
</v>
<v t="ekr.20240131003855.226"><vh>class PercentFormatInvalidFormat</vh>
<v t="ekr.20240131003855.227"><vh>PercentFormatInvalidFormat.__init__</vh></v>
</v>
<v t="ekr.20240131003855.228"><vh>class PercentFormatMixedPositionalAndNamed</vh></v>
<v t="ekr.20240131003855.229"><vh>class PercentFormatUnsupportedFormatCharacter</vh>
<v t="ekr.20240131003855.230"><vh>PercentFormatUnsupportedFormatCharacter.__init__</vh></v>
</v>
<v t="ekr.20240131003855.231"><vh>class PercentFormatPositionalCountMismatch</vh>
<v t="ekr.20240131003855.232"><vh>PercentFormatPositionalCountMismatch.__init__</vh></v>
</v>
<v t="ekr.20240131003855.233"><vh>class PercentFormatExtraNamedArguments</vh>
<v t="ekr.20240131003855.234"><vh>PercentFormatExtraNamedArguments.__init__</vh></v>
</v>
<v t="ekr.20240131003855.235"><vh>class PercentFormatMissingArgument</vh>
<v t="ekr.20240131003855.236"><vh>PercentFormatMissingArgument.__init__</vh></v>
</v>
<v t="ekr.20240131003855.237"><vh>class PercentFormatExpectedMapping</vh></v>
<v t="ekr.20240131003855.238"><vh>class PercentFormatExpectedSequence</vh></v>
<v t="ekr.20240131003855.239"><vh>class PercentFormatStarRequiresSequence</vh></v>
</v>
</v>
<v t="ekr.20240131003855.13"><vh>@clean C:\Python\Python3.12\Lib\site-packages\pyflakes\checker.py</vh>
<v t="ekr.20240131004408.1"><vh>&lt;&lt; imports: checker.py &gt;&gt;</vh></v>
<v t="ekr.20240131005639.1"><vh>predicate functions</vh>
<v t="ekr.20240131003855.14"><vh>function: getAlternatives</vh></v>
<v t="ekr.20240131003855.15"><vh>function: _is_singleton</vh></v>
<v t="ekr.20240131003855.16"><vh>function: _is_tuple_constant</vh></v>
<v t="ekr.20240131003855.17"><vh>function: _is_constant</vh></v>
<v t="ekr.20240131003855.18"><vh>function: _is_const_non_singleton</vh></v>
<v t="ekr.20240131003855.19"><vh>function: _is_name_or_attr</vh></v>
<v t="ekr.20240131003855.20"><vh>function: _must_match</vh></v>
<v t="ekr.20240131003855.21"><vh>function: parse_percent_format</vh></v>
</v>
<v t="ekr.20240131005858.1"><vh>Fields</vh>
<v t="ekr.20240131003855.22"><vh>class _FieldsOrder</vh>
<v t="ekr.20240131003855.23"><vh>_FieldsOrder._get_fields</vh></v>
<v t="ekr.20240131003855.24"><vh>_FieldsOrder.__missing__</vh></v>
</v>
<v t="ekr.20240131003855.25"><vh>function: counter</vh></v>
<v t="ekr.20240131003855.26"><vh>function: iter_child_nodes</vh></v>
<v t="ekr.20240131003855.27"><vh>function: convert_to_value</vh></v>
<v t="ekr.20240131003855.28"><vh>function: is_notimplemented_name_node</vh></v>
</v>
<v t="ekr.20240131003855.29"><vh>class Binding</vh>
<v t="ekr.20240131003855.30"><vh>Binding.__init__</vh></v>
<v t="ekr.20240131003855.31"><vh>Binding.__str__</vh></v>
<v t="ekr.20240131003855.32"><vh>Binding.__repr__</vh></v>
<v t="ekr.20240131003855.33"><vh>Binding.redefines</vh></v>
</v>
<v t="ekr.20240131003855.34"><vh>class Definition(Binding)</vh>
<v t="ekr.20240131003855.35"><vh>Definition.redefines</vh></v>
</v>
<v t="ekr.20240131003855.36"><vh>class Builtin(Definition)</vh>
<v t="ekr.20240131003855.37"><vh>Builtin.__init__</vh></v>
<v t="ekr.20240131003855.38"><vh>Builtin.__repr__</vh></v>
</v>
<v t="ekr.20240131003855.39"><vh>class UnhandledKeyType</vh></v>
<v t="ekr.20240131003855.40"><vh>class VariableKey</vh>
<v t="ekr.20240131003855.41"><vh>VariableKey.__init__</vh></v>
<v t="ekr.20240131003855.42"><vh>VariableKey.__eq__</vh></v>
<v t="ekr.20240131003855.43"><vh>VariableKey.__hash__</vh></v>
</v>
<v t="ekr.20240131003855.44"><vh>class Importation(Definition)</vh>
<v t="ekr.20240131003855.45"><vh>Importation.__init__</vh></v>
<v t="ekr.20240131003855.46"><vh>Importation.redefines</vh></v>
<v t="ekr.20240131003855.47"><vh>Importation._has_alias</vh></v>
<v t="ekr.20240131003855.48"><vh>Importation.source_statement</vh></v>
<v t="ekr.20240131003855.49"><vh>Importation.__str__</vh></v>
</v>
<v t="ekr.20240131003855.50"><vh>class SubmoduleImportation(Importation)</vh>
<v t="ekr.20240131003855.51"><vh>SubmoduleImportation.__init__</vh></v>
<v t="ekr.20240131003855.52"><vh>SubmoduleImportation.redefines</vh></v>
<v t="ekr.20240131003855.53"><vh>SubmoduleImportation.__str__</vh></v>
<v t="ekr.20240131003855.54"><vh>SubmoduleImportation.source_statement</vh></v>
</v>
<v t="ekr.20240131003855.55"><vh>class ImportationFrom(Importation)</vh>
<v t="ekr.20240131003855.56"><vh>ImportationFrom.__init__</vh></v>
<v t="ekr.20240131003855.57"><vh>ImportationFrom.__str__</vh></v>
<v t="ekr.20240131003855.58"><vh>ImportationFrom.source_statement</vh></v>
</v>
<v t="ekr.20240131003855.59"><vh>class StarImportation(Importation)</vh>
<v t="ekr.20240131003855.60"><vh>StarImportation.__init__</vh></v>
<v t="ekr.20240131003855.61"><vh>StarImportation.source_statement</vh></v>
<v t="ekr.20240131003855.62"><vh>StarImportation.__str__</vh></v>
</v>
<v t="ekr.20240131003855.63"><vh>class FutureImportation(Importation)</vh>
<v t="ekr.20240131003855.64"><vh>FutureImportation.__init__</vh></v>
</v>
<v t="ekr.20240131003855.65"><vh>class Argument(Binding)</vh></v>
<v t="ekr.20240131003855.66"><vh>class Assignment(Binding)</vh></v>
<v t="ekr.20240131003855.67"><vh>class NamedExprAssignment(Assignment)</vh></v>
<v t="ekr.20240131003855.68"><vh>class Annotation(Binding)</vh>
<v t="ekr.20240131003855.69"><vh>Annotation.redefines</vh></v>
</v>
<v t="ekr.20240131003855.70"><vh>class FunctionDefinition(Definition)</vh></v>
<v t="ekr.20240131003855.71"><vh>class ClassDefinition(Definition)</vh></v>
<v t="ekr.20240131003855.72"><vh>class ExportBinding(Binding)</vh>
<v t="ekr.20240131003855.73"><vh>ExportBinding.__init__</vh></v>
</v>
<v t="ekr.20240131003855.74"><vh>class Scope(dict)</vh>
<v t="ekr.20240131003855.75"><vh>Scope.__repr__</vh></v>
</v>
<v t="ekr.20240131003855.76"><vh>class ClassScope(Scope)</vh></v>
<v t="ekr.20240131003855.77"><vh>class FunctionScope(Scope)</vh>
<v t="ekr.20240131003855.78"><vh>FunctionScope.__init__</vh></v>
<v t="ekr.20240131003855.79"><vh>FunctionScope.unused_assignments</vh></v>
<v t="ekr.20240131003855.80"><vh>FunctionScope.unused_annotations</vh></v>
</v>
<v t="ekr.20240131003855.81"><vh>class TypeScope(Scope)</vh></v>
<v t="ekr.20240131003855.82"><vh>class GeneratorScope(Scope)</vh></v>
<v t="ekr.20240131003855.83"><vh>class ModuleScope(Scope)</vh></v>
<v t="ekr.20240131003855.84"><vh>class DoctestScope(Scope)</vh></v>
<v t="ekr.20240131003855.85"><vh>class DetectClassScopedMagic</vh></v>
<v t="ekr.20240131003855.86"><vh>function: getNodeName</vh></v>
<v t="ekr.20240131010054.1"><vh>typing functions</vh>
<v t="ekr.20240131003855.87"><vh>function: _is_typing_helper</vh></v>
<v t="ekr.20240131003855.88"><vh>function: _is_typing</vh></v>
<v t="ekr.20240131003855.89"><vh>function: _is_any_typing_member</vh></v>
<v t="ekr.20240131003855.90"><vh>function: is_typing_overload</vh></v>
</v>
<v t="ekr.20240131005837.1"><vh>Annotations</vh>
<v t="ekr.20240131003855.91"><vh>class AnnotationState</vh></v>
<v t="ekr.20240131003855.92"><vh>function: in_annotation</vh></v>
<v t="ekr.20240131003855.93"><vh>function: in_string_annotation</vh></v>
</v>
<v t="ekr.20240131003855.94"><vh>class Checker</vh>
<v t="ekr.20240131003855.95"><vh>Checker.__init__</vh></v>
<v t="ekr.20240131003855.96"><vh>Checker.deferFunction</vh></v>
<v t="ekr.20240131003855.97"><vh>Checker._run_deferred</vh></v>
<v t="ekr.20240131003855.98"><vh>Checker._in_doctest</vh></v>
<v t="ekr.20240131003855.99"><vh>Checker.@property futuresAllowed</vh></v>
<v t="ekr.20240131003855.101"><vh>Checker.@property annotationsFutureEnabled</vh></v>
<v t="ekr.20240131003855.103"><vh>Checker.@property scope</vh></v>
<v t="ekr.20240131003855.104"><vh>Checker.in_scope</vh></v>
<v t="ekr.20240131003855.105"><vh>Checker.checkDeadScopes</vh></v>
<v t="ekr.20240131003855.106"><vh>Checker.report</vh></v>
<v t="ekr.20240131010350.1"><vh>Checker: getters</vh>
<v t="ekr.20240131003855.107"><vh>Checker.getParent</vh></v>
<v t="ekr.20240131003855.108"><vh>Checker.getCommonAncestor</vh></v>
<v t="ekr.20240131003855.109"><vh>Checker.descendantOf</vh></v>
<v t="ekr.20240131003855.110"><vh>Checker._getAncestor</vh></v>
<v t="ekr.20240131003855.111"><vh>Checker.getScopeNode</vh></v>
<v t="ekr.20240131003855.112"><vh>Checker.differentForks</vh></v>
</v>
<v t="ekr.20240131003855.113"><vh>Checker.addBinding</vh></v>
<v t="ekr.20240131003855.114"><vh>Checker._unknown_handler</vh></v>
<v t="ekr.20240131003855.115"><vh>Checker.getNodeHandler (returns uppercased)</vh></v>
<v t="ekr.20240131003855.116"><vh>Checker.handleNodeLoad</vh></v>
<v t="ekr.20240131003855.117"><vh>Checker.handleNodeStore</vh></v>
<v t="ekr.20240131003855.118"><vh>Checker.handleNodeDelete</vh></v>
<v t="ekr.20240131003855.119"><vh>Checker.@contextlib.contextmanager _enter_annotation</vh></v>
<v t="ekr.20240131003855.120"><vh>Checker.@property _in_postponed_annotation</vh></v>
<v t="ekr.20240131003855.121"><vh>Checker.handleChildren</vh></v>
<v t="ekr.20240131003855.122"><vh>Checker.isLiteralTupleUnpacking</vh></v>
<v t="ekr.20240131011732.1"><vh>Checker: Docstrings</vh>
<v t="ekr.20240131003855.123"><vh>Checker.isDocstring</vh></v>
<v t="ekr.20240131003855.124"><vh>Checker.getDocstring</vh></v>
</v>
<v t="ekr.20240131003855.125"><vh>Checker.handleNode (main visitor)</vh></v>
<v t="ekr.20240131003855.126"><vh>Checker.handleDoctests</vh></v>
<v t="ekr.20240131011753.1"><vh>Checker: Annotations</vh>
<v t="ekr.20240131003855.127"><vh>Checker.handleStringAnnotation</vh></v>
<v t="ekr.20240131003855.128"><vh>Checker.handle_annotation_always_deferred</vh></v>
<v t="ekr.20240131003855.129"><vh>Checker.handleAnnotation</vh></v>
</v>
<v t="ekr.20240131003855.130"><vh>Checker.ignore</vh></v>
<v t="ekr.20240131011429.1"><vh>Checker: uppercase handlers</vh>
<v t="ekr.20240131003855.131"><vh>Checker.SUBSCRIPT</vh></v>
<v t="ekr.20240131003855.132"><vh>Checker._handle_string_dot_format</vh></v>
<v t="ekr.20240131003855.133"><vh>Checker.CALL</vh></v>
<v t="ekr.20240131003855.134"><vh>Checker._handle_percent_format</vh></v>
<v t="ekr.20240131003855.135"><vh>Checker.BINOP</vh></v>
<v t="ekr.20240131003855.136"><vh>Checker.CONSTANT</vh></v>
<v t="ekr.20240131003855.137"><vh>Checker.RAISE</vh></v>
<v t="ekr.20240131003855.138"><vh>Checker.JOINEDSTR</vh></v>
<v t="ekr.20240131003855.139"><vh>Checker.DICT</vh></v>
<v t="ekr.20240131003855.140"><vh>Checker.IF</vh></v>
<v t="ekr.20240131003855.141"><vh>Checker.ASSERT</vh></v>
<v t="ekr.20240131003855.142"><vh>Checker.GLOBAL</vh></v>
<v t="ekr.20240131003855.143"><vh>Checker.GENERATOREXP</vh></v>
<v t="ekr.20240131003855.144"><vh>Checker.NAME</vh></v>
<v t="ekr.20240131003855.145"><vh>Checker.CONTINUE</vh></v>
<v t="ekr.20240131003855.146"><vh>Checker.RETURN</vh></v>
<v t="ekr.20240131003855.147"><vh>Checker.YIELD</vh></v>
<v t="ekr.20240131003855.148"><vh>Checker.FUNCTIONDEF</vh></v>
<v t="ekr.20240131003855.149"><vh>Checker.LAMBDA</vh></v>
<v t="ekr.20240131003855.150"><vh>Checker.ARGUMENTS</vh></v>
<v t="ekr.20240131003855.151"><vh>Checker.ARG</vh></v>
<v t="ekr.20240131003855.152"><vh>Checker.CLASSDEF</vh></v>
<v t="ekr.20240131003855.153"><vh>Checker.AUGASSIGN</vh></v>
<v t="ekr.20240131003855.154"><vh>Checker.TUPLE</vh></v>
<v t="ekr.20240131003855.155"><vh>Checker.IMPORT</vh></v>
<v t="ekr.20240131003855.156"><vh>Checker.IMPORTFROM</vh></v>
<v t="ekr.20240131003855.157"><vh>Checker.TRY</vh></v>
<v t="ekr.20240131003855.158"><vh>Checker.EXCEPTHANDLER</vh></v>
<v t="ekr.20240131003855.159"><vh>Checker.ANNASSIGN</vh></v>
<v t="ekr.20240131003855.160"><vh>Checker.COMPARE</vh></v>
<v t="ekr.20240131003855.161"><vh>Checker._match_target</vh></v>
<v t="ekr.20240131003855.162"><vh>Checker._type_param_scope</vh></v>
<v t="ekr.20240131003855.163"><vh>Checker.TYPEVAR</vh></v>
<v t="ekr.20240131003855.164"><vh>Checker.TYPEALIAS</vh></v>
</v>
</v>
</v>
<v t="ekr.20240131003855.94"></v>
<v t="ekr.20240709171100.1"><vh>An improved Checker class</vh>
<v t="ekr.20240709170956.1"><vh>class Checker</vh>
<v t="ekr.20240709170956.2"><vh>&lt;&lt; Checker: class data &gt;&gt;</vh></v>
<v t="ekr.20240709170956.3"><vh>Checker.__init__</vh></v>
<v t="ekr.20240709170956.4"><vh>Checker: Deferred functions</vh>
<v t="ekr.20240709170956.5"><vh>Checker.deferFunction</vh></v>
<v t="ekr.20240709170956.6"><vh>Checker._run_deferred</vh></v>
</v>
<v t="ekr.20240709170956.7"><vh>Checker._in_doctest</vh></v>
<v t="ekr.20240709170956.8"><vh>Checker: Properties</vh>
<v t="ekr.20240709170956.9"><vh>Checker.futuresAllowed</vh></v>
<v t="ekr.20240709170956.10"><vh>Checker.annotationsFutureEnabled</vh></v>
<v t="ekr.20240709170956.11"><vh>Checker.scope &amp; in_scope (@contextlib.contextmanager)</vh></v>
</v>
<v t="ekr.20240709170956.12"><vh>Checker: Utils</vh>
<v t="ekr.20240709170956.13"><vh>Checker.checkDeadScopes</vh></v>
<v t="ekr.20240709170956.14"><vh>Checker.report</vh></v>
<v t="ekr.20240709170956.15"><vh>Checker: Tree utils</vh>
<v t="ekr.20240709170956.16"><vh>Checker.getParent</vh></v>
<v t="ekr.20240709170956.17"><vh>Checker.getCommonAncestor</vh></v>
<v t="ekr.20240709170956.18"><vh>Checker.descendantOf</vh></v>
<v t="ekr.20240709170956.19"><vh>Checker._getAncestor</vh></v>
<v t="ekr.20240709170956.20"><vh>Checker.getScopeNode</vh></v>
<v t="ekr.20240709170956.21"><vh>Checker.differentForks</vh></v>
</v>
<v t="ekr.20240709170956.22"><vh>Checker.addBinding</vh></v>
<v t="ekr.20240709170956.23"><vh>Checker: is*</vh>
<v t="ekr.20240709170956.24"><vh>Checker.isLiteralTupleUnpacking</vh></v>
<v t="ekr.20240709170956.25"><vh>Checker.isDocstring</vh></v>
</v>
<v t="ekr.20240709170956.26"><vh>Checker.getDocstring</vh></v>
</v>
<v t="ekr.20240709170956.27"><vh>Checker: Utils for visitors</vh>
<v t="ekr.20240709170956.28"><vh>Checker._enter_annotation</vh></v>
<v t="ekr.20240709170956.29"><vh>Checker._in_postponed_annotation</vh></v>
<v t="ekr.20240709170956.30"><vh>Checker._type_param_scope (@contextlib.contextmanager)</vh></v>
<v t="ekr.20240709170956.31"><vh>Checker.handle_annotation_always_deferred</vh></v>
<v t="ekr.20240709170956.32"><vh>Checker.handleAnnotation</vh></v>
<v t="ekr.20240709170956.33"><vh>Checker.visit</vh></v>
<v t="ekr.20240709170956.34"><vh>Checker.handleDoctests</vh></v>
<v t="ekr.20240709170956.35"><vh>Checker.handleFields</vh></v>
<v t="ekr.20240709170956.36"><vh>Checker.handleNode &amp; synonyms</vh></v>
<v t="ekr.20240709170956.37"><vh>Checker.handleStringAnnotation</vh></v>
<v t="ekr.20240709170956.38"><vh>Checker: handleNodeLoad/Store/Delete</vh>
<v t="ekr.20240709170956.39"><vh>Checker.handleNodeLoad</vh></v>
<v t="ekr.20240709170956.40"><vh>Checker.handleNodeStore</vh></v>
<v t="ekr.20240709170956.41"><vh>Checker.handleNodeDelete</vh></v>
</v>
</v>
<v t="ekr.20240709170956.42"><vh>Checker: Visitors</vh>
<v t="ekr.20240709170956.43"><vh>Checker: traversal helpers</vh>
<v t="ekr.20240709170956.44"><vh>Checker.Arguments (only calls handleFields)</vh></v>
<v t="ekr.20240709170956.45"><vh>Checker.Assign (only calls handleFields)</vh></v>
<v t="ekr.20240709170956.46"><vh>Checker.Comprehension (only calls handleFields)</vh></v>
<v t="ekr.20240709170956.47"><vh>Checker.DictComp  (calls handleFields in scope)</vh></v>
<v t="ekr.20240709170956.48"><vh>Checker.For &amp; AsyncFor (only calls handleFields)</vh></v>
<v t="ekr.20240709170956.49"><vh>Checker.GeneratorExpr, ListComp, SetComp</vh></v>
<v t="ekr.20240709170956.50"><vh>Checker.NamedExpr (only calls handleFields)</vh></v>
</v>
<v t="ekr.20240709170956.51"><vh>Checker: Semantic methods</vh>
<v t="ekr.20240709170956.52"><vh>Checker.AnnAssign</vh></v>
<v t="ekr.20240709170956.53"><vh>Checker.Arg</vh></v>
<v t="ekr.20240709170956.54"><vh>Checker.Assert</vh></v>
<v t="ekr.20240709170956.55"><vh>Checker.AugAssign</vh></v>
<v t="ekr.20240709170956.56"><vh>Checker.BinOp &amp; helper</vh>
<v t="ekr.20240709170956.57"><vh>Checker._handle_percent_format</vh></v>
</v>
<v t="ekr.20240709170956.58"><vh>Checker.Call &amp; helper</vh>
<v t="ekr.20240709170956.59"><vh>Checker._handle_string_dot_format</vh></v>
</v>
<v t="ekr.20240709170956.60"><vh>Checker.ClassDef</vh></v>
<v t="ekr.20240709170956.61"><vh>Checker.Compare</vh></v>
<v t="ekr.20240709170956.62"><vh>Checker.Constant</vh></v>
<v t="ekr.20240709170956.63"><vh>Checker.Continue &amp; Break</vh></v>
<v t="ekr.20240709170956.64"><vh>Checker.Dict</vh></v>
<v t="ekr.20240709170956.65"><vh>Checker.ExceptHandler</vh></v>
<v t="ekr.20240709170956.66"><vh>Checker.FunctionDef &amp; AsyncFunctionDef</vh></v>
<v t="ekr.20240709170956.67"><vh>Checker.Global &amp; NonLocal</vh></v>
<v t="ekr.20240709170956.68"><vh>Checker.IF &amp; IfExpr</vh></v>
<v t="ekr.20240709170956.69"><vh>Checker.ignore &amp; synonyms</vh></v>
<v t="ekr.20240709170956.70"><vh>Checker.Import</vh></v>
<v t="ekr.20240709170956.71"><vh>Checker.ImportFrom</vh></v>
<v t="ekr.20240709170956.72"><vh>Checker.JoinedStr</vh></v>
<v t="ekr.20240709170956.73"><vh>Checker.Lambda &amp; runFunction</vh></v>
<v t="ekr.20240709170956.74"><vh>Checker.Match* &amp; _match_target</vh></v>
<v t="ekr.20240709170956.75"><vh>Checker.Name</vh></v>
<v t="ekr.20240709170956.76"><vh>Checker.Raise</vh></v>
<v t="ekr.20240709170956.77"><vh>Checker.Return</vh></v>
<v t="ekr.20240709170956.78"><vh>Checker.Subscript</vh></v>
<v t="ekr.20240709170956.79"><vh>Checker.Try &amp; TryStar</vh></v>
<v t="ekr.20240709170956.80"><vh>Checker.Tuple &amp; List</vh></v>
<v t="ekr.20240709170956.81"><vh>Checker.TypeAlias</vh></v>
<v t="ekr.20240709170956.82"><vh>Checker.TypeVar, ParamSpec &amp; TypeVarTuple</vh></v>
<v t="ekr.20240709170956.83"><vh>Checker.Yield</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20240131003855.1"></t>
<t tx="ekr.20240131003855.10">def _exitOnSignal(sigName, message):
    """Handles a signal with sys.exit.

    Some of these signals (SIGPIPE, for example) don't exist or are invalid on
    Windows. So, ignore errors that might arise.
    """
    import signal

    try:
        sigNumber = getattr(signal, sigName)
    except AttributeError:
        # the signal constants defined in the signal module are defined by
        # whether the C library supports them or not. So, SIGPIPE might not
        # even be defined.
        return

    def handler(sig, f):
        sys.exit(message)

    try:
        signal.signal(sigNumber, handler)
    except ValueError:
        # It's also possible the signal is defined, but then it's invalid. In
        # this case, signal.signal raises ValueError.
        pass


</t>
<t tx="ekr.20240131003855.101">@property
def annotationsFutureEnabled(self):
    scope = self.scopeStack[0]
    if not isinstance(scope, ModuleScope):
        return False
    return scope._annotations_future_enabled

@annotationsFutureEnabled.setter
def annotationsFutureEnabled(self, value):
    assert value is True
    assert isinstance(self.scope, ModuleScope)
    self.scope._annotations_future_enabled = True

</t>
<t tx="ekr.20240131003855.103">@property
def scope(self):
    return self.scopeStack[-1]

</t>
<t tx="ekr.20240131003855.104">@contextlib.contextmanager
def in_scope(self, cls):
    self.scopeStack.append(cls())
    try:
        yield
    finally:
        self.deadScopes.append(self.scopeStack.pop())

</t>
<t tx="ekr.20240131003855.105">def checkDeadScopes(self):
    """
    Look at scopes which have been fully examined and report names in them
    which were imported but unused.
    """
    for scope in self.deadScopes:
        # imports in classes are public members
        if isinstance(scope, ClassScope):
            continue

        if isinstance(scope, FunctionScope):
            for name, binding in scope.unused_assignments():
                self.report(messages.UnusedVariable, binding.source, name)
            for name, binding in scope.unused_annotations():
                self.report(messages.UnusedAnnotation, binding.source, name)

        all_binding = scope.get('__all__')
        if all_binding and not isinstance(all_binding, ExportBinding):
            all_binding = None

        if all_binding:
            all_names = set(all_binding.names)
            undefined = [
                name for name in all_binding.names
                if name not in scope
            ]
        else:
            all_names = undefined = []

        if undefined:
            if not scope.importStarred and \
               os.path.basename(self.filename) != '__init__.py':
                # Look for possible mistakes in the export list
                for name in undefined:
                    self.report(messages.UndefinedExport,
                                scope['__all__'].source, name)

            # mark all import '*' as used by the undefined in __all__
            if scope.importStarred:
                from_list = []
                for binding in scope.values():
                    if isinstance(binding, StarImportation):
                        binding.used = all_binding
                        from_list.append(binding.fullName)
                # report * usage, with a list of possible sources
                from_list = ', '.join(sorted(from_list))
                for name in undefined:
                    self.report(messages.ImportStarUsage,
                                scope['__all__'].source, name, from_list)

        # Look for imported names that aren't used.
        for value in scope.values():
            if isinstance(value, Importation):
                used = value.used or value.name in all_names
                if not used:
                    messg = messages.UnusedImport
                    self.report(messg, value.source, str(value))
                for node in value.redefined:
                    if isinstance(self.getParent(node), FOR_TYPES):
                        messg = messages.ImportShadowedByLoopVar
                    elif used:
                        continue
                    else:
                        messg = messages.RedefinedWhileUnused
                    self.report(messg, node, value.name, value.source)

</t>
<t tx="ekr.20240131003855.106">def report(self, messageClass, *args, **kwargs):
    self.messages.append(messageClass(self.filename, *args, **kwargs))

</t>
<t tx="ekr.20240131003855.107">def getParent(self, node):
    # Lookup the first parent which is not Tuple, List or Starred
    while True:
        node = node._pyflakes_parent
        if not hasattr(node, 'elts') and not hasattr(node, 'ctx'):
            return node

</t>
<t tx="ekr.20240131003855.108">def getCommonAncestor(self, lnode, rnode, stop):
    if (
            stop in (lnode, rnode) or
            not (
                hasattr(lnode, '_pyflakes_parent') and
                hasattr(rnode, '_pyflakes_parent')
            )
    ):
        return None
    if lnode is rnode:
        return lnode

    if (lnode._pyflakes_depth &gt; rnode._pyflakes_depth):
        return self.getCommonAncestor(lnode._pyflakes_parent, rnode, stop)
    if (lnode._pyflakes_depth &lt; rnode._pyflakes_depth):
        return self.getCommonAncestor(lnode, rnode._pyflakes_parent, stop)
    return self.getCommonAncestor(
        lnode._pyflakes_parent,
        rnode._pyflakes_parent,
        stop,
    )

</t>
<t tx="ekr.20240131003855.109">def descendantOf(self, node, ancestors, stop):
    for a in ancestors:
        if self.getCommonAncestor(node, a, stop):
            return True
    return False

</t>
<t tx="ekr.20240131003855.11">def _get_version():
    """
    Retrieve and format package version along with python version &amp; OS used
    """
    return ('%s Python %s on %s' %
            (__version__, platform.python_version(), platform.system()))


</t>
<t tx="ekr.20240131003855.110">def _getAncestor(self, node, ancestor_type):
    parent = node
    while True:
        if parent is self.root:
            return None
        parent = self.getParent(parent)
        if isinstance(parent, ancestor_type):
            return parent

</t>
<t tx="ekr.20240131003855.111">def getScopeNode(self, node):
    return self._getAncestor(node, tuple(Checker._ast_node_scope.keys()))

</t>
<t tx="ekr.20240131003855.112">def differentForks(self, lnode, rnode):
    """True, if lnode and rnode are located on different forks of IF/TRY"""
    ancestor = self.getCommonAncestor(lnode, rnode, self.root)
    parts = getAlternatives(ancestor)
    if parts:
        for items in parts:
            if self.descendantOf(lnode, items, ancestor) ^ \
               self.descendantOf(rnode, items, ancestor):
                return True
    return False

</t>
<t tx="ekr.20240131003855.113">def addBinding(self, node, value):
    """
    Called when a binding is altered.

    - `node` is the statement responsible for the change
    - `value` is the new value, a Binding instance
    """
    # assert value.source in (node, node._pyflakes_parent):
    for scope in self.scopeStack[::-1]:
        if value.name in scope:
            break
    existing = scope.get(value.name)

    if (existing and not isinstance(existing, Builtin) and
            not self.differentForks(node, existing.source)):

        parent_stmt = self.getParent(value.source)
        if isinstance(existing, Importation) and isinstance(parent_stmt, FOR_TYPES):
            self.report(messages.ImportShadowedByLoopVar,
                        node, value.name, existing.source)

        elif scope is self.scope:
            if (
                    (not existing.used and value.redefines(existing)) and
                    (value.name != '_' or isinstance(existing, Importation)) and
                    not is_typing_overload(existing, self.scopeStack)
            ):
                self.report(messages.RedefinedWhileUnused,
                            node, value.name, existing.source)

        elif isinstance(existing, Importation) and value.redefines(existing):
            existing.redefined.append(node)

    if value.name in self.scope:
        # then assume the rebound name is used as a global or within a loop
        value.used = self.scope[value.name].used

    # don't treat annotations as assignments if there is an existing value
    # in scope
    if value.name not in self.scope or not isinstance(value, Annotation):
        cur_scope_pos = -1
        # As per PEP 572, use scope in which outermost generator is defined
        while (
            isinstance(value, NamedExprAssignment) and
            isinstance(self.scopeStack[cur_scope_pos], GeneratorScope)
        ):
            cur_scope_pos -= 1
        self.scopeStack[cur_scope_pos][value.name] = value

</t>
<t tx="ekr.20240131003855.114">def _unknown_handler(self, node):
    # this environment variable configures whether to error on unknown
    # ast types.
    #
    # this is silent by default but the error is enabled for the pyflakes
    # testsuite.
    #
    # this allows new syntax to be added to python without *requiring*
    # changes from the pyflakes side.  but will still produce an error
    # in the pyflakes testsuite (so more specific handling can be added if
    # needed).
    if os.environ.get('PYFLAKES_ERROR_UNKNOWN'):
        raise NotImplementedError(f'Unexpected type: {type(node)}')
    else:
        self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.115">def getNodeHandler(self, node_class):
    try:
        return self._nodeHandlers[node_class]
    except KeyError:
        nodeType = node_class.__name__.upper()
    self._nodeHandlers[node_class] = handler = getattr(
        self, nodeType, self._unknown_handler,
    )
    return handler

</t>
<t tx="ekr.20240131003855.116">def handleNodeLoad(self, node, parent):
    name = getNodeName(node)
    if not name:
        return

    # only the following can access class scoped variables (since classes
    # aren't really a scope)
    # - direct accesses (not within a nested scope)
    # - generators
    # - type annotations (for generics, etc.)
    can_access_class_vars = None
    importStarred = None

    # try enclosing function scopes and global scope
    for scope in self.scopeStack[-1::-1]:
        if isinstance(scope, ClassScope):
            if name == '__class__':
                return
            elif can_access_class_vars is False:
                # only generators used in a class scope can access the
                # names of the class. this is skipped during the first
                # iteration
                continue

        binding = scope.get(name, None)
        if isinstance(binding, Annotation) and not self._in_postponed_annotation:
            scope[name].used = (self.scope, node)
            continue

        if name == 'print' and isinstance(binding, Builtin):
            if (isinstance(parent, ast.BinOp) and
                    isinstance(parent.op, ast.RShift)):
                self.report(messages.InvalidPrintSyntax, node)

        try:
            scope[name].used = (self.scope, node)

            # if the name of SubImportation is same as
            # alias of other Importation and the alias
            # is used, SubImportation also should be marked as used.
            n = scope[name]
            if isinstance(n, Importation) and n._has_alias():
                try:
                    scope[n.fullName].used = (self.scope, node)
                except KeyError:
                    pass
        except KeyError:
            pass
        else:
            return

        importStarred = importStarred or scope.importStarred

        if can_access_class_vars is not False:
            can_access_class_vars = isinstance(
                scope, (TypeScope, GeneratorScope),
            )

    if importStarred:
        from_list = []

        for scope in self.scopeStack[-1::-1]:
            for binding in scope.values():
                if isinstance(binding, StarImportation):
                    # mark '*' imports as used for each scope
                    binding.used = (self.scope, node)
                    from_list.append(binding.fullName)

        # report * usage, with a list of possible sources
        from_list = ', '.join(sorted(from_list))
        self.report(messages.ImportStarUsage, node, name, from_list)
        return

    if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
        # the special name __path__ is valid only in packages
        return

    if name in DetectClassScopedMagic.names and isinstance(self.scope, ClassScope):
        return

    # protected with a NameError handler?
    if 'NameError' not in self.exceptHandlers[-1]:
        self.report(messages.UndefinedName, node, name)

</t>
<t tx="ekr.20240131003855.117">def handleNodeStore(self, node):
    name = getNodeName(node)
    if not name:
        return
    # if the name hasn't already been defined in the current scope
    if isinstance(self.scope, FunctionScope) and name not in self.scope:
        # for each function or module scope above us
        for scope in self.scopeStack[:-1]:
            if not isinstance(scope, (FunctionScope, ModuleScope)):
                continue
            # if the name was defined in that scope, and the name has
            # been accessed already in the current scope, and hasn't
            # been declared global
            used = name in scope and scope[name].used
            if used and used[0] is self.scope and name not in self.scope.globals:
                # then it's probably a mistake
                self.report(messages.UndefinedLocal,
                            scope[name].used[1], name, scope[name].source)
                break

    parent_stmt = self.getParent(node)
    if isinstance(parent_stmt, ast.AnnAssign) and parent_stmt.value is None:
        binding = Annotation(name, node)
    elif isinstance(parent_stmt, (FOR_TYPES, ast.comprehension)) or (
            parent_stmt != node._pyflakes_parent and
            not self.isLiteralTupleUnpacking(parent_stmt)):
        binding = Binding(name, node)
    elif (
            name == '__all__' and
            isinstance(self.scope, ModuleScope) and
            isinstance(
                node._pyflakes_parent,
                (ast.Assign, ast.AugAssign, ast.AnnAssign)
            )
    ):
        binding = ExportBinding(name, node._pyflakes_parent, self.scope)
    elif isinstance(parent_stmt, ast.NamedExpr):
        binding = NamedExprAssignment(name, node)
    else:
        binding = Assignment(name, node)
    self.addBinding(node, binding)

</t>
<t tx="ekr.20240131003855.118">def handleNodeDelete(self, node):

    def on_conditional_branch():
        """
        Return `True` if node is part of a conditional body.
        """
        current = getattr(node, '_pyflakes_parent', None)
        while current:
            if isinstance(current, (ast.If, ast.While, ast.IfExp)):
                return True
            current = getattr(current, '_pyflakes_parent', None)
        return False

    name = getNodeName(node)
    if not name:
        return

    if on_conditional_branch():
        # We cannot predict if this conditional branch is going to
        # be executed.
        return

    if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
        self.scope.globals.remove(name)
    else:
        try:
            del self.scope[name]
        except KeyError:
            self.report(messages.UndefinedName, node, name)

</t>
<t tx="ekr.20240131003855.119">@contextlib.contextmanager
def _enter_annotation(self, ann_type=AnnotationState.BARE):
    orig, self._in_annotation = self._in_annotation, ann_type
    try:
        yield
    finally:
        self._in_annotation = orig

</t>
<t tx="ekr.20240131003855.12">def main(prog=None, args=None):
    """Entry point for the script "pyflakes"."""
    import argparse

    # Handle "Keyboard Interrupt" and "Broken pipe" gracefully
    _exitOnSignal('SIGINT', '... stopped')
    _exitOnSignal('SIGPIPE', 1)

    parser = argparse.ArgumentParser(prog=prog,
                                     description='Check Python source files for errors')
    parser.add_argument('-V', '--version', action='version', version=_get_version())
    parser.add_argument('path', nargs='*',
                        help='Path(s) of Python file(s) to check. STDIN if not given.')
    args = parser.parse_args(args=args).path
    reporter = modReporter._makeDefaultReporter()
    if args:
        warnings = checkRecursive(args, reporter)
    else:
        warnings = check(sys.stdin.read(), '&lt;stdin&gt;', reporter)
    raise SystemExit(warnings &gt; 0)
</t>
<t tx="ekr.20240131003855.120">@property
def _in_postponed_annotation(self):
    return (
        self._in_annotation == AnnotationState.STRING or
        self.annotationsFutureEnabled
    )

</t>
<t tx="ekr.20240131003855.121">def handleChildren(self, tree, omit=None):
    for node in iter_child_nodes(tree, omit=omit):
        self.handleNode(node, tree)

</t>
<t tx="ekr.20240131003855.122">def isLiteralTupleUnpacking(self, node):
    if isinstance(node, ast.Assign):
        for child in node.targets + [node.value]:
            if not hasattr(child, 'elts'):
                return False
        return True

</t>
<t tx="ekr.20240131003855.123">def isDocstring(self, node):
    """
    Determine if the given node is a docstring, as long as it is at the
    correct place in the node tree.
    """
    return (
        isinstance(node, ast.Expr) and
        isinstance(node.value, ast.Constant) and
        isinstance(node.value.value, str)
    )

</t>
<t tx="ekr.20240131003855.124">def getDocstring(self, node):
    if (
            isinstance(node, ast.Expr) and
            isinstance(node.value, ast.Constant) and
            isinstance(node.value.value, str)
    ):
        return node.value.value, node.lineno - 1
    else:
        return None, None

</t>
<t tx="ekr.20240131003855.125">def handleNode(self, node, parent):
    if node is None:
        return
    if self.offset and getattr(node, 'lineno', None) is not None:
        node.lineno += self.offset[0]
        node.col_offset += self.offset[1]
    if (
            self.futuresAllowed and
            self.nodeDepth == 0 and
            not isinstance(node, ast.ImportFrom) and
            not self.isDocstring(node)
    ):
        self.futuresAllowed = False
    self.nodeDepth += 1
    node._pyflakes_depth = self.nodeDepth
    node._pyflakes_parent = parent
    try:
        handler = self.getNodeHandler(node.__class__)
        handler(node)
    finally:
        self.nodeDepth -= 1

</t>
<t tx="ekr.20240131003855.126">_getDoctestExamples = doctest.DocTestParser().get_examples

def handleDoctests(self, node):
    try:
        (docstring, node_lineno) = self.getDocstring(node.body[0])
        examples = docstring and self._getDoctestExamples(docstring)
    except (ValueError, IndexError):
        # e.g. line 6 of the docstring for &lt;string&gt; has inconsistent
        # leading whitespace: ...
        return
    if not examples:
        return

    # Place doctest in module scope
    saved_stack = self.scopeStack
    self.scopeStack = [self.scopeStack[0]]
    node_offset = self.offset or (0, 0)
    with self.in_scope(DoctestScope):
        if '_' not in self.scopeStack[0]:
            self.addBinding(None, Builtin('_'))
        for example in examples:
            try:
                tree = ast.parse(example.source, "&lt;doctest&gt;")
            except SyntaxError as e:
                position = (node_lineno + example.lineno + e.lineno,
                            example.indent + 4 + (e.offset or 0))
                self.report(messages.DoctestSyntaxError, node, position)
            else:
                self.offset = (node_offset[0] + node_lineno + example.lineno,
                               node_offset[1] + example.indent + 4)
                self.handleChildren(tree)
                self.offset = node_offset
    self.scopeStack = saved_stack

</t>
<t tx="ekr.20240131003855.127">@in_string_annotation
def handleStringAnnotation(self, s, node, ref_lineno, ref_col_offset, err):
    try:
        tree = ast.parse(s)
    except SyntaxError:
        self.report(err, node, s)
        return

    body = tree.body
    if len(body) != 1 or not isinstance(body[0], ast.Expr):
        self.report(err, node, s)
        return

    parsed_annotation = tree.body[0].value
    for descendant in ast.walk(parsed_annotation):
        if (
                'lineno' in descendant._attributes and
                'col_offset' in descendant._attributes
        ):
            descendant.lineno = ref_lineno
            descendant.col_offset = ref_col_offset

    self.handleNode(parsed_annotation, node)

</t>
<t tx="ekr.20240131003855.128">def handle_annotation_always_deferred(self, annotation, parent):
    fn = in_annotation(Checker.handleNode)
    self.deferFunction(lambda: fn(self, annotation, parent))

</t>
<t tx="ekr.20240131003855.129">@in_annotation
def handleAnnotation(self, annotation, node):
    if (
            isinstance(annotation, ast.Constant) and
            isinstance(annotation.value, str)
    ):
        # Defer handling forward annotation.
        self.deferFunction(functools.partial(
            self.handleStringAnnotation,
            annotation.value,
            node,
            annotation.lineno,
            annotation.col_offset,
            messages.ForwardAnnotationSyntaxError,
        ))
    elif self.annotationsFutureEnabled:
        self.handle_annotation_always_deferred(annotation, node)
    else:
        self.handleNode(annotation, node)

</t>
<t tx="ekr.20240131003855.13">"""
Main module.

Implement the central Checker class.
Also, it models the Bindings and Scopes.
"""
&lt;&lt; imports: checker.py &gt;&gt;

PYPY = hasattr(sys, 'pypy_version_info')

builtin_vars = dir(builtins)

parse_format_string = string.Formatter().parse


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.130">def ignore(self, node):
    pass

</t>
<t tx="ekr.20240131003855.131"># "stmt" type nodes
DELETE = FOR = ASYNCFOR = WHILE = WITH = WITHITEM = ASYNCWITH = \
    EXPR = ASSIGN = handleChildren

PASS = ignore

# "expr" type nodes
BOOLOP = UNARYOP = SET = ATTRIBUTE = STARRED = NAMECONSTANT = \
    NAMEDEXPR = handleChildren

def SUBSCRIPT(self, node):
    if _is_name_or_attr(node.value, 'Literal'):
        with self._enter_annotation(AnnotationState.NONE):
            self.handleChildren(node)
    elif _is_name_or_attr(node.value, 'Annotated'):
        self.handleNode(node.value, node)

        # py39+
        if isinstance(node.slice, ast.Tuple):
            slice_tuple = node.slice
        # &lt;py39
        elif (
                isinstance(node.slice, ast.Index) and
                isinstance(node.slice.value, ast.Tuple)
        ):
            slice_tuple = node.slice.value
        else:
            slice_tuple = None

        # not a multi-arg `Annotated`
        if slice_tuple is None or len(slice_tuple.elts) &lt; 2:
            self.handleNode(node.slice, node)
        else:
            # the first argument is the type
            self.handleNode(slice_tuple.elts[0], node)
            # the rest of the arguments are not
            with self._enter_annotation(AnnotationState.NONE):
                for arg in slice_tuple.elts[1:]:
                    self.handleNode(arg, node)

        self.handleNode(node.ctx, node)
    else:
        if _is_any_typing_member(node.value, self.scopeStack):
            with self._enter_annotation():
                self.handleChildren(node)
        else:
            self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.132">def _handle_string_dot_format(self, node):
    try:
        placeholders = tuple(parse_format_string(node.func.value.value))
    except ValueError as e:
        self.report(messages.StringDotFormatInvalidFormat, node, e)
        return

    auto = None
    next_auto = 0

    placeholder_positional = set()
    placeholder_named = set()

    def _add_key(fmtkey):
        """Returns True if there is an error which should early-exit"""
        nonlocal auto, next_auto

        if fmtkey is None:  # end of string or `{` / `}` escapes
            return False

        # attributes / indices are allowed in `.format(...)`
        fmtkey, _, _ = fmtkey.partition('.')
        fmtkey, _, _ = fmtkey.partition('[')

        try:
            fmtkey = int(fmtkey)
        except ValueError:
            pass
        else:  # fmtkey was an integer
            if auto is True:
                self.report(messages.StringDotFormatMixingAutomatic, node)
                return True
            else:
                auto = False

        if fmtkey == '':
            if auto is False:
                self.report(messages.StringDotFormatMixingAutomatic, node)
                return True
            else:
                auto = True

            fmtkey = next_auto
            next_auto += 1

        if isinstance(fmtkey, int):
            placeholder_positional.add(fmtkey)
        else:
            placeholder_named.add(fmtkey)

        return False

    for _, fmtkey, spec, _ in placeholders:
        if _add_key(fmtkey):
            return

        # spec can also contain format specifiers
        if spec is not None:
            try:
                spec_placeholders = tuple(parse_format_string(spec))
            except ValueError as e:
                self.report(messages.StringDotFormatInvalidFormat, node, e)
                return

            for _, spec_fmtkey, spec_spec, _ in spec_placeholders:
                # can't recurse again
                if spec_spec is not None and '{' in spec_spec:
                    self.report(
                        messages.StringDotFormatInvalidFormat,
                        node,
                        'Max string recursion exceeded',
                    )
                    return
                if _add_key(spec_fmtkey):
                    return

    # bail early if there is *args or **kwargs
    if (
            # *args
            any(isinstance(arg, ast.Starred) for arg in node.args) or
            # **kwargs
            any(kwd.arg is None for kwd in node.keywords)
    ):
        return

    substitution_positional = set(range(len(node.args)))
    substitution_named = {kwd.arg for kwd in node.keywords}

    extra_positional = substitution_positional - placeholder_positional
    extra_named = substitution_named - placeholder_named

    missing_arguments = (
        (placeholder_positional | placeholder_named) -
        (substitution_positional | substitution_named)
    )

    if extra_positional:
        self.report(
            messages.StringDotFormatExtraPositionalArguments,
            node,
            ', '.join(sorted(str(x) for x in extra_positional)),
        )
    if extra_named:
        self.report(
            messages.StringDotFormatExtraNamedArguments,
            node,
            ', '.join(sorted(extra_named)),
        )
    if missing_arguments:
        self.report(
            messages.StringDotFormatMissingArgument,
            node,
            ', '.join(sorted(str(x) for x in missing_arguments)),
        )

</t>
<t tx="ekr.20240131003855.133">def CALL(self, node):
    if (
            isinstance(node.func, ast.Attribute) and
            isinstance(node.func.value, ast.Constant) and
            isinstance(node.func.value.value, str) and
            node.func.attr == 'format'
    ):
        self._handle_string_dot_format(node)

    omit = []
    annotated = []
    not_annotated = []

    if (
        _is_typing(node.func, 'cast', self.scopeStack) and
        len(node.args) &gt;= 1
    ):
        with self._enter_annotation():
            self.handleNode(node.args[0], node)

    elif _is_typing(node.func, 'TypeVar', self.scopeStack):

        # TypeVar("T", "int", "str")
        omit += ["args"]
        annotated += [arg for arg in node.args[1:]]

        # TypeVar("T", bound="str")
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords if k.arg == "bound"]
        not_annotated += [
            (k, ["value"] if k.arg == "bound" else None)
            for k in node.keywords
        ]

    elif _is_typing(node.func, "TypedDict", self.scopeStack):
        # TypedDict("a", {"a": int})
        if len(node.args) &gt; 1 and isinstance(node.args[1], ast.Dict):
            omit += ["args"]
            annotated += node.args[1].values
            not_annotated += [
                (arg, ["values"] if i == 1 else None)
                for i, arg in enumerate(node.args)
            ]

        # TypedDict("a", a=int)
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords]
        not_annotated += [(k, ["value"]) for k in node.keywords]

    elif _is_typing(node.func, "NamedTuple", self.scopeStack):
        # NamedTuple("a", [("a", int)])
        if (
            len(node.args) &gt; 1 and
            isinstance(node.args[1], (ast.Tuple, ast.List)) and
            all(isinstance(x, (ast.Tuple, ast.List)) and
                len(x.elts) == 2 for x in node.args[1].elts)
        ):
            omit += ["args"]
            annotated += [elt.elts[1] for elt in node.args[1].elts]
            not_annotated += [(elt.elts[0], None) for elt in node.args[1].elts]
            not_annotated += [
                (arg, ["elts"] if i == 1 else None)
                for i, arg in enumerate(node.args)
            ]
            not_annotated += [(elt, "elts") for elt in node.args[1].elts]

        # NamedTuple("a", a=int)
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords]
        not_annotated += [(k, ["value"]) for k in node.keywords]

    if omit:
        with self._enter_annotation(AnnotationState.NONE):
            for na_node, na_omit in not_annotated:
                self.handleChildren(na_node, omit=na_omit)
            self.handleChildren(node, omit=omit)

        with self._enter_annotation():
            for annotated_node in annotated:
                self.handleNode(annotated_node, node)
    else:
        self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.134">def _handle_percent_format(self, node):
    try:
        placeholders = parse_percent_format(node.left.value)
    except ValueError:
        self.report(
            messages.PercentFormatInvalidFormat,
            node,
            'incomplete format',
        )
        return

    named = set()
    positional_count = 0
    positional = None
    for _, placeholder in placeholders:
        if placeholder is None:
            continue
        name, _, width, precision, conversion = placeholder

        if conversion == '%':
            continue

        if conversion not in VALID_CONVERSIONS:
            self.report(
                messages.PercentFormatUnsupportedFormatCharacter,
                node,
                conversion,
            )

        if positional is None and conversion:
            positional = name is None

        for part in (width, precision):
            if part is not None and '*' in part:
                if not positional:
                    self.report(
                        messages.PercentFormatStarRequiresSequence,
                        node,
                    )
                else:
                    positional_count += 1

        if positional and name is not None:
            self.report(
                messages.PercentFormatMixedPositionalAndNamed,
                node,
            )
            return
        elif not positional and name is None:
            self.report(
                messages.PercentFormatMixedPositionalAndNamed,
                node,
            )
            return

        if positional:
            positional_count += 1
        else:
            named.add(name)

    if (
            isinstance(node.right, (ast.List, ast.Tuple)) and
            # does not have any *splats (py35+ feature)
            not any(
                isinstance(elt, ast.Starred)
                for elt in node.right.elts
            )
    ):
        substitution_count = len(node.right.elts)
        if positional and positional_count != substitution_count:
            self.report(
                messages.PercentFormatPositionalCountMismatch,
                node,
                positional_count,
                substitution_count,
            )
        elif not positional:
            self.report(messages.PercentFormatExpectedMapping, node)

    if (
            isinstance(node.right, ast.Dict) and
            all(
                isinstance(k, ast.Constant) and isinstance(k.value, str)
                for k in node.right.keys
            )
    ):
        if positional and positional_count &gt; 1:
            self.report(messages.PercentFormatExpectedSequence, node)
            return

        substitution_keys = {k.value for k in node.right.keys}
        extra_keys = substitution_keys - named
        missing_keys = named - substitution_keys
        if not positional and extra_keys:
            self.report(
                messages.PercentFormatExtraNamedArguments,
                node,
                ', '.join(sorted(extra_keys)),
            )
        if not positional and missing_keys:
            self.report(
                messages.PercentFormatMissingArgument,
                node,
                ', '.join(sorted(missing_keys)),
            )

</t>
<t tx="ekr.20240131003855.135">def BINOP(self, node):
    if (
            isinstance(node.op, ast.Mod) and
            isinstance(node.left, ast.Constant) and
            isinstance(node.left.value, str)
    ):
        self._handle_percent_format(node)
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.136">def CONSTANT(self, node):
    if isinstance(node.value, str) and self._in_annotation:
        fn = functools.partial(
            self.handleStringAnnotation,
            node.value,
            node,
            node.lineno,
            node.col_offset,
            messages.ForwardAnnotationSyntaxError,
        )
        self.deferFunction(fn)

</t>
<t tx="ekr.20240131003855.137"># "slice" type nodes
SLICE = EXTSLICE = INDEX = handleChildren

# expression contexts are node instances too, though being constants
LOAD = STORE = DEL = AUGLOAD = AUGSTORE = PARAM = ignore

# same for operators
AND = OR = ADD = SUB = MULT = DIV = MOD = POW = LSHIFT = RSHIFT = \
    BITOR = BITXOR = BITAND = FLOORDIV = INVERT = NOT = UADD = USUB = \
    EQ = NOTEQ = LT = LTE = GT = GTE = IS = ISNOT = IN = NOTIN = \
    MATMULT = ignore

def RAISE(self, node):
    self.handleChildren(node)

    arg = node.exc

    if isinstance(arg, ast.Call):
        if is_notimplemented_name_node(arg.func):
            # Handle "raise NotImplemented(...)"
            self.report(messages.RaiseNotImplemented, node)
    elif is_notimplemented_name_node(arg):
        # Handle "raise NotImplemented"
        self.report(messages.RaiseNotImplemented, node)

</t>
<t tx="ekr.20240131003855.138"># additional node types
COMPREHENSION = KEYWORD = FORMATTEDVALUE = handleChildren

_in_fstring = False

def JOINEDSTR(self, node):
    if (
            # the conversion / etc. flags are parsed as f-strings without
            # placeholders
            not self._in_fstring and
            not any(isinstance(x, ast.FormattedValue) for x in node.values)
    ):
        self.report(messages.FStringMissingPlaceholders, node)

    self._in_fstring, orig = True, self._in_fstring
    try:
        self.handleChildren(node)
    finally:
        self._in_fstring = orig

</t>
<t tx="ekr.20240131003855.139">def DICT(self, node):
    # Complain if there are duplicate keys with different values
    # If they have the same value it's not going to cause potentially
    # unexpected behaviour so we'll not complain.
    keys = [
        convert_to_value(key) for key in node.keys
    ]

    key_counts = counter(keys)
    duplicate_keys = [
        key for key, count in key_counts.items()
        if count &gt; 1
    ]

    for key in duplicate_keys:
        key_indices = [i for i, i_key in enumerate(keys) if i_key == key]

        values = counter(
            convert_to_value(node.values[index])
            for index in key_indices
        )
        if any(count == 1 for value, count in values.items()):
            for key_index in key_indices:
                key_node = node.keys[key_index]
                if isinstance(key, VariableKey):
                    self.report(messages.MultiValueRepeatedKeyVariable,
                                key_node,
                                key.name)
                else:
                    self.report(
                        messages.MultiValueRepeatedKeyLiteral,
                        key_node,
                        key,
                    )
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.14">def getAlternatives(n):
    if isinstance(n, ast.If):
        return [n.body]
    elif isinstance(n, ast.Try):
        return [n.body + n.orelse] + [[hdl] for hdl in n.handlers]
    elif sys.version_info &gt;= (3, 10) and isinstance(n, ast.Match):
        return [mc.body for mc in n.cases]


</t>
<t tx="ekr.20240131003855.140">def IF(self, node):
    if isinstance(node.test, ast.Tuple) and node.test.elts != []:
        self.report(messages.IfTuple, node)
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.141">IFEXP = IF

def ASSERT(self, node):
    if isinstance(node.test, ast.Tuple) and node.test.elts != []:
        self.report(messages.AssertTuple, node)
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.142">def GLOBAL(self, node):
    """
    Keep track of globals declarations.
    """
    global_scope_index = 1 if self._in_doctest() else 0
    global_scope = self.scopeStack[global_scope_index]

    # Ignore 'global' statement in global scope.
    if self.scope is not global_scope:

        # One 'global' statement can bind multiple (comma-delimited) names.
        for node_name in node.names:
            node_value = Assignment(node_name, node)

            # Remove UndefinedName messages already reported for this name.
            # TODO: if the global is not used in this scope, it does not
            # become a globally defined name.  See test_unused_global.
            self.messages = [
                m for m in self.messages if not
                isinstance(m, messages.UndefinedName) or
                m.message_args[0] != node_name]

            # Bind name to global scope if it doesn't exist already.
            global_scope.setdefault(node_name, node_value)

            # Bind name to non-global scopes, but as already "used".
            node_value.used = (global_scope, node)
            for scope in self.scopeStack[global_scope_index + 1:]:
                scope[node_name] = node_value

</t>
<t tx="ekr.20240131003855.143">NONLOCAL = GLOBAL

def GENERATOREXP(self, node):
    with self.in_scope(GeneratorScope):
        self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.144">LISTCOMP = DICTCOMP = SETCOMP = GENERATOREXP

def NAME(self, node):
    """
    Handle occurrence of Name (which can be a load/store/delete access.)
    """
    # Locate the name in locals / function / globals scopes.
    if isinstance(node.ctx, ast.Load):
        self.handleNodeLoad(node, self.getParent(node))
        if (node.id == 'locals' and isinstance(self.scope, FunctionScope) and
                isinstance(node._pyflakes_parent, ast.Call)):
            # we are doing locals() call in current scope
            self.scope.usesLocals = True
    elif isinstance(node.ctx, ast.Store):
        self.handleNodeStore(node)
    elif isinstance(node.ctx, ast.Del):
        self.handleNodeDelete(node)
    else:
        # Unknown context
        raise RuntimeError(f"Got impossible expression context: {node.ctx!r}")

</t>
<t tx="ekr.20240131003855.145">def CONTINUE(self, node):
    # Walk the tree up until we see a loop (OK), a function or class
    # definition (not OK), for 'continue', a finally block (not OK), or
    # the top module scope (not OK)
    n = node
    while hasattr(n, '_pyflakes_parent'):
        n, n_child = n._pyflakes_parent, n
        if isinstance(n, (ast.While, ast.For, ast.AsyncFor)):
            # Doesn't apply unless it's in the loop itself
            if n_child not in n.orelse:
                return
        if isinstance(n, (ast.FunctionDef, ast.ClassDef)):
            break
    if isinstance(node, ast.Continue):
        self.report(messages.ContinueOutsideLoop, node)
    else:  # ast.Break
        self.report(messages.BreakOutsideLoop, node)

</t>
<t tx="ekr.20240131003855.146">BREAK = CONTINUE

def RETURN(self, node):
    if isinstance(self.scope, (ClassScope, ModuleScope)):
        self.report(messages.ReturnOutsideFunction, node)
        return

    if (
        node.value and
        hasattr(self.scope, 'returnValue') and
        not self.scope.returnValue
    ):
        self.scope.returnValue = node.value
    self.handleNode(node.value, node)

</t>
<t tx="ekr.20240131003855.147">def YIELD(self, node):
    if isinstance(self.scope, (ClassScope, ModuleScope)):
        self.report(messages.YieldOutsideFunction, node)
        return

    self.handleNode(node.value, node)

</t>
<t tx="ekr.20240131003855.148">AWAIT = YIELDFROM = YIELD

def FUNCTIONDEF(self, node):
    for deco in node.decorator_list:
        self.handleNode(deco, node)

    with self._type_param_scope(node):
        self.LAMBDA(node)

    self.addBinding(node, FunctionDefinition(node.name, node))
    # doctest does not process doctest within a doctest,
    # or in nested functions.
    if (self.withDoctest and
            not self._in_doctest() and
            not isinstance(self.scope, FunctionScope)):
        self.deferFunction(lambda: self.handleDoctests(node))

</t>
<t tx="ekr.20240131003855.149">ASYNCFUNCTIONDEF = FUNCTIONDEF

def LAMBDA(self, node):
    args = []
    annotations = []

    for arg in node.args.posonlyargs:
        args.append(arg.arg)
        annotations.append(arg.annotation)
    for arg in node.args.args + node.args.kwonlyargs:
        args.append(arg.arg)
        annotations.append(arg.annotation)
    defaults = node.args.defaults + node.args.kw_defaults

    has_annotations = not isinstance(node, ast.Lambda)

    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        args.append(wildcard.arg)
        if has_annotations:
            annotations.append(wildcard.annotation)

    if has_annotations:
        annotations.append(node.returns)

    if len(set(args)) &lt; len(args):
        for (idx, arg) in enumerate(args):
            if arg in args[:idx]:
                self.report(messages.DuplicateArgument, node, arg)

    for annotation in annotations:
        self.handleAnnotation(annotation, node)

    for default in defaults:
        self.handleNode(default, node)

    def runFunction():
        with self.in_scope(FunctionScope):
            self.handleChildren(
                node,
                omit=('decorator_list', 'returns', 'type_params'),
            )

    self.deferFunction(runFunction)

</t>
<t tx="ekr.20240131003855.15">FOR_TYPES = (ast.For, ast.AsyncFor)


def _is_singleton(node):  # type: (ast.AST) -&gt; bool
    return (
        isinstance(node, ast.Constant) and
        isinstance(node.value, (bool, type(Ellipsis), type(None)))
    )


</t>
<t tx="ekr.20240131003855.150">def ARGUMENTS(self, node):
    self.handleChildren(node, omit=('defaults', 'kw_defaults'))

</t>
<t tx="ekr.20240131003855.151">def ARG(self, node):
    self.addBinding(node, Argument(node.arg, self.getScopeNode(node)))

</t>
<t tx="ekr.20240131003855.152">def CLASSDEF(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)

    with self._type_param_scope(node):
        for baseNode in node.bases:
            self.handleNode(baseNode, node)
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
        with self.in_scope(ClassScope):
            # doctest does not process doctest within a doctest
            # classes within classes are processed.
            if (self.withDoctest and
                    not self._in_doctest() and
                    not isinstance(self.scope, FunctionScope)):
                self.deferFunction(lambda: self.handleDoctests(node))
            for stmt in node.body:
                self.handleNode(stmt, node)

    self.addBinding(node, ClassDefinition(node.name, node))

</t>
<t tx="ekr.20240131003855.153">def AUGASSIGN(self, node):
    self.handleNodeLoad(node.target, node)
    self.handleNode(node.value, node)
    self.handleNode(node.target, node)

</t>
<t tx="ekr.20240131003855.154">def TUPLE(self, node):
    if isinstance(node.ctx, ast.Store):
        # Python 3 advanced tuple unpacking: a, *b, c = d.
        # Only one starred expression is allowed, and no more than 1&lt;&lt;8
        # assignments are allowed before a stared expression. There is
        # also a limit of 1&lt;&lt;24 expressions after the starred expression,
        # which is impossible to test due to memory restrictions, but we
        # add it here anyway
        has_starred = False
        star_loc = -1
        for i, n in enumerate(node.elts):
            if isinstance(n, ast.Starred):
                if has_starred:
                    self.report(messages.TwoStarredExpressions, node)
                    # The SyntaxError doesn't distinguish two from more
                    # than two.
                    break
                has_starred = True
                star_loc = i
        if star_loc &gt;= 1 &lt;&lt; 8 or len(node.elts) - star_loc - 1 &gt;= 1 &lt;&lt; 24:
            self.report(messages.TooManyExpressionsInStarredAssignment, node)
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.155">LIST = TUPLE

def IMPORT(self, node):
    for alias in node.names:
        if '.' in alias.name and not alias.asname:
            importation = SubmoduleImportation(alias.name, node)
        else:
            name = alias.asname or alias.name
            importation = Importation(name, node, alias.name)
        self.addBinding(node, importation)

</t>
<t tx="ekr.20240131003855.156">def IMPORTFROM(self, node):
    if node.module == '__future__':
        if not self.futuresAllowed:
            self.report(messages.LateFutureImport, node)
    else:
        self.futuresAllowed = False

    module = ('.' * node.level) + (node.module or '')

    for alias in node.names:
        name = alias.asname or alias.name
        if node.module == '__future__':
            importation = FutureImportation(name, node, self.scope)
            if alias.name not in __future__.all_feature_names:
                self.report(messages.FutureFeatureNotDefined,
                            node, alias.name)
            if alias.name == 'annotations':
                self.annotationsFutureEnabled = True
        elif alias.name == '*':
            if not isinstance(self.scope, ModuleScope):
                self.report(messages.ImportStarNotPermitted,
                            node, module)
                continue

            self.scope.importStarred = True
            self.report(messages.ImportStarUsed, node, module)
            importation = StarImportation(module, node)
        else:
            importation = ImportationFrom(name, node,
                                          module, alias.name)
        self.addBinding(node, importation)

</t>
<t tx="ekr.20240131003855.157">def TRY(self, node):
    handler_names = []
    # List the exception handlers
    for i, handler in enumerate(node.handlers):
        if isinstance(handler.type, ast.Tuple):
            for exc_type in handler.type.elts:
                handler_names.append(getNodeName(exc_type))
        elif handler.type:
            handler_names.append(getNodeName(handler.type))

        if handler.type is None and i &lt; len(node.handlers) - 1:
            self.report(messages.DefaultExceptNotLast, handler)
    # Memorize the except handlers and process the body
    self.exceptHandlers.append(handler_names)
    for child in node.body:
        self.handleNode(child, node)
    self.exceptHandlers.pop()
    # Process the other nodes: "except:", "else:", "finally:"
    self.handleChildren(node, omit='body')

</t>
<t tx="ekr.20240131003855.158">TRYSTAR = TRY

def EXCEPTHANDLER(self, node):
    if node.name is None:
        self.handleChildren(node)
        return

    # If the name already exists in the scope, modify state of existing
    # binding.
    if node.name in self.scope:
        self.handleNodeStore(node)

    # 3.x: the name of the exception, which is not a Name node, but a
    # simple string, creates a local that is only bound within the scope of
    # the except: block. As such, temporarily remove the existing binding
    # to more accurately determine if the name is used in the except:
    # block.

    try:
        prev_definition = self.scope.pop(node.name)
    except KeyError:
        prev_definition = None

    self.handleNodeStore(node)
    self.handleChildren(node)

    # See discussion on https://github.com/PyCQA/pyflakes/pull/59

    # We're removing the local name since it's being unbound after leaving
    # the except: block and it's always unbound if the except: block is
    # never entered. This will cause an "undefined name" error raised if
    # the checked code tries to use the name afterwards.
    #
    # Unless it's been removed already. Then do nothing.

    try:
        binding = self.scope.pop(node.name)
    except KeyError:
        pass
    else:
        if not binding.used:
            self.report(messages.UnusedVariable, node, node.name)

    # Restore.
    if prev_definition:
        self.scope[node.name] = prev_definition

</t>
<t tx="ekr.20240131003855.159">def ANNASSIGN(self, node):
    self.handleAnnotation(node.annotation, node)
    # If the assignment has value, handle the *value* now.
    if node.value:
        # If the annotation is `TypeAlias`, handle the *value* as an annotation.
        if _is_typing(node.annotation, 'TypeAlias', self.scopeStack):
            self.handleAnnotation(node.value, node)
        else:
            self.handleNode(node.value, node)
    self.handleNode(node.target, node)

</t>
<t tx="ekr.20240131003855.16">def _is_tuple_constant(node):  # type: (ast.AST) -&gt; bool
    return (
        isinstance(node, ast.Tuple) and
        all(_is_constant(elt) for elt in node.elts)
    )


</t>
<t tx="ekr.20240131003855.160">def COMPARE(self, node):
    left = node.left
    for op, right in zip(node.ops, node.comparators):
        if (
                isinstance(op, (ast.Is, ast.IsNot)) and (
                    _is_const_non_singleton(left) or
                    _is_const_non_singleton(right)
                )
        ):
            self.report(messages.IsLiteral, node)
        left = right

    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.161">MATCH = MATCH_CASE = MATCHCLASS = MATCHOR = MATCHSEQUENCE = handleChildren
MATCHSINGLETON = MATCHVALUE = handleChildren

def _match_target(self, node):
    self.handleNodeStore(node)
    self.handleChildren(node)

</t>
<t tx="ekr.20240131003855.162">MATCHAS = MATCHMAPPING = MATCHSTAR = _match_target

@contextlib.contextmanager
def _type_param_scope(self, node):
    with contextlib.ExitStack() as ctx:
        if sys.version_info &gt;= (3, 12):
            ctx.enter_context(self.in_scope(TypeScope))
            for param in node.type_params:
                self.handleNode(param, node)
        yield

</t>
<t tx="ekr.20240131003855.163">def TYPEVAR(self, node):
    self.handleNodeStore(node)
    self.handle_annotation_always_deferred(node.bound, node)

PARAMSPEC = TYPEVARTUPLE = handleNodeStore

</t>
<t tx="ekr.20240131003855.164">def TYPEALIAS(self, node):
    self.handleNode(node.name, node)
    with self._type_param_scope(node):
        self.handle_annotation_always_deferred(node.value, node)
</t>
<t tx="ekr.20240131003855.165">"""
Provide the class Message and its subclasses.
"""


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.166">class Message:
    @others
</t>
<t tx="ekr.20240131003855.167">message = ''
message_args = ()

def __init__(self, filename, loc):
    self.filename = filename
    self.lineno = loc.lineno
    self.col = loc.col_offset

</t>
<t tx="ekr.20240131003855.168">def __str__(self):
    return '{}:{}:{}: {}'.format(self.filename, self.lineno, self.col+1,
                                 self.message % self.message_args)


</t>
<t tx="ekr.20240131003855.169">class UnusedImport(Message):
    @others
</t>
<t tx="ekr.20240131003855.17">def _is_constant(node):
    return isinstance(node, ast.Constant) or _is_tuple_constant(node)


</t>
<t tx="ekr.20240131003855.170">message = '%r imported but unused'

def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)


</t>
<t tx="ekr.20240131003855.171">class RedefinedWhileUnused(Message):
    @others
</t>
<t tx="ekr.20240131003855.172">message = 'redefinition of unused %r from line %r'

def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)


</t>
<t tx="ekr.20240131003855.173">class ImportShadowedByLoopVar(Message):
    @others
</t>
<t tx="ekr.20240131003855.174">message = 'import %r from line %r shadowed by loop variable'

def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    self.message_args = (name, orig_loc.lineno)


</t>
<t tx="ekr.20240131003855.175">class ImportStarNotPermitted(Message):
    @others
</t>
<t tx="ekr.20240131003855.176">message = "'from %s import *' only allowed at module level"

def __init__(self, filename, loc, modname):
    Message.__init__(self, filename, loc)
    self.message_args = (modname,)


</t>
<t tx="ekr.20240131003855.177">class ImportStarUsed(Message):
    @others
</t>
<t tx="ekr.20240131003855.178">message = "'from %s import *' used; unable to detect undefined names"

def __init__(self, filename, loc, modname):
    Message.__init__(self, filename, loc)
    self.message_args = (modname,)


</t>
<t tx="ekr.20240131003855.179">class ImportStarUsage(Message):
    @others
</t>
<t tx="ekr.20240131003855.18">def _is_const_non_singleton(node):  # type: (ast.AST) -&gt; bool
    return _is_constant(node) and not _is_singleton(node)


</t>
<t tx="ekr.20240131003855.180">message = "%r may be undefined, or defined from star imports: %s"

def __init__(self, filename, loc, name, from_list):
    Message.__init__(self, filename, loc)
    self.message_args = (name, from_list)


</t>
<t tx="ekr.20240131003855.181">class UndefinedName(Message):
    @others
</t>
<t tx="ekr.20240131003855.182">message = 'undefined name %r'

def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)


</t>
<t tx="ekr.20240131003855.183">class DoctestSyntaxError(Message):
    @others
</t>
<t tx="ekr.20240131003855.184">message = 'syntax error in doctest'

def __init__(self, filename, loc, position=None):
    Message.__init__(self, filename, loc)
    if position:
        (self.lineno, self.col) = position
    self.message_args = ()


</t>
<t tx="ekr.20240131003855.185">class UndefinedExport(Message):
    @others
</t>
<t tx="ekr.20240131003855.186">message = 'undefined name %r in __all__'

def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)


</t>
<t tx="ekr.20240131003855.187">class UndefinedLocal(Message):
    @others
</t>
<t tx="ekr.20240131003855.188">message = 'local variable %r {0} referenced before assignment'

default = 'defined in enclosing scope on line %r'
builtin = 'defined as a builtin'

def __init__(self, filename, loc, name, orig_loc):
    Message.__init__(self, filename, loc)
    if orig_loc is None:
        self.message = self.message.format(self.builtin)
        self.message_args = name
    else:
        self.message = self.message.format(self.default)
        self.message_args = (name, orig_loc.lineno)


</t>
<t tx="ekr.20240131003855.189">class DuplicateArgument(Message):
    @others
</t>
<t tx="ekr.20240131003855.19">def _is_name_or_attr(node, name):  # type: (ast.AST, str) -&gt; bool
    return (
        (isinstance(node, ast.Name) and node.id == name) or
        (isinstance(node, ast.Attribute) and node.attr == name)
    )


</t>
<t tx="ekr.20240131003855.190">message = 'duplicate argument %r in function definition'

def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)


</t>
<t tx="ekr.20240131003855.191">class MultiValueRepeatedKeyLiteral(Message):
    @others
</t>
<t tx="ekr.20240131003855.192">message = 'dictionary key %r repeated with different values'

def __init__(self, filename, loc, key):
    Message.__init__(self, filename, loc)
    self.message_args = (key,)


</t>
<t tx="ekr.20240131003855.193">class MultiValueRepeatedKeyVariable(Message):
    @others
</t>
<t tx="ekr.20240131003855.194">message = 'dictionary key variable %s repeated with different values'

def __init__(self, filename, loc, key):
    Message.__init__(self, filename, loc)
    self.message_args = (key,)


</t>
<t tx="ekr.20240131003855.195">class LateFutureImport(Message):
    message = 'from __future__ imports must occur at the beginning of the file'


</t>
<t tx="ekr.20240131003855.196">class FutureFeatureNotDefined(Message):
    """An undefined __future__ feature name was imported."""
    @others
</t>
<t tx="ekr.20240131003855.197">message = 'future feature %s is not defined'

def __init__(self, filename, loc, name):
    Message.__init__(self, filename, loc)
    self.message_args = (name,)


</t>
<t tx="ekr.20240131003855.198">class UnusedVariable(Message):
    """
    Indicates that a variable has been explicitly assigned to but not actually
    used.
    """
    @others
</t>
<t tx="ekr.20240131003855.199">message = 'local variable %r is assigned to but never used'

def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)


</t>
<t tx="ekr.20240131003855.2">__version__ = '3.1.0'
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.20">MAPPING_KEY_RE = re.compile(r'\(([^()]*)\)')
CONVERSION_FLAG_RE = re.compile('[#0+ -]*')
WIDTH_RE = re.compile(r'(?:\*|\d*)')
PRECISION_RE = re.compile(r'(?:\.(?:\*|\d*))?')
LENGTH_RE = re.compile('[hlL]?')
# https://docs.python.org/3/library/stdtypes.html#old-string-formatting
VALID_CONVERSIONS = frozenset('diouxXeEfFgGcrsa%')


def _must_match(regex, string, pos):
    match = regex.match(string, pos)
    assert match is not None
    return match


</t>
<t tx="ekr.20240131003855.200">class UnusedAnnotation(Message):
    """
    Indicates that a variable has been explicitly annotated to but not actually
    used.
    """
    @others
</t>
<t tx="ekr.20240131003855.201">message = 'local variable %r is annotated but never used'

def __init__(self, filename, loc, names):
    Message.__init__(self, filename, loc)
    self.message_args = (names,)


</t>
<t tx="ekr.20240131003855.202">class ReturnOutsideFunction(Message):
    """
    Indicates a return statement outside of a function/method.
    """
    message = '\'return\' outside function'


</t>
<t tx="ekr.20240131003855.203">class YieldOutsideFunction(Message):
    """
    Indicates a yield or yield from statement outside of a function/method.
    """
    message = '\'yield\' outside function'


</t>
<t tx="ekr.20240131003855.204"># For whatever reason, Python gives different error messages for these two. We
# match the Python error message exactly.
class ContinueOutsideLoop(Message):
    """
    Indicates a continue statement outside of a while or for loop.
    """
    message = '\'continue\' not properly in loop'


</t>
<t tx="ekr.20240131003855.205">class BreakOutsideLoop(Message):
    """
    Indicates a break statement outside of a while or for loop.
    """
    message = '\'break\' outside loop'


</t>
<t tx="ekr.20240131003855.206">class DefaultExceptNotLast(Message):
    """
    Indicates an except: block as not the last exception handler.
    """
    message = 'default \'except:\' must be last'


</t>
<t tx="ekr.20240131003855.207">class TwoStarredExpressions(Message):
    """
    Two or more starred expressions in an assignment (a, *b, *c = d).
    """
    message = 'two starred expressions in assignment'


</t>
<t tx="ekr.20240131003855.208">class TooManyExpressionsInStarredAssignment(Message):
    """
    Too many expressions in an assignment with star-unpacking
    """
    message = 'too many expressions in star-unpacking assignment'


</t>
<t tx="ekr.20240131003855.209">class IfTuple(Message):
    """
    Conditional test is a non-empty tuple literal, which are always True.
    """
    message = '\'if tuple literal\' is always true, perhaps remove accidental comma?'


</t>
<t tx="ekr.20240131003855.21">def parse_percent_format(s):
    """Parses the string component of a `'...' % ...` format call

    Copied from https://github.com/asottile/pyupgrade at v1.20.1
    """

    def _parse_inner():
        string_start = 0
        string_end = 0
        in_fmt = False

        i = 0
        while i &lt; len(s):
            if not in_fmt:
                try:
                    i = s.index('%', i)
                except ValueError:  # no more % fields!
                    yield s[string_start:], None
                    return
                else:
                    string_end = i
                    i += 1
                    in_fmt = True
            else:
                key_match = MAPPING_KEY_RE.match(s, i)
                if key_match:
                    key = key_match.group(1)
                    i = key_match.end()
                else:
                    key = None

                conversion_flag_match = _must_match(CONVERSION_FLAG_RE, s, i)
                conversion_flag = conversion_flag_match.group() or None
                i = conversion_flag_match.end()

                width_match = _must_match(WIDTH_RE, s, i)
                width = width_match.group() or None
                i = width_match.end()

                precision_match = _must_match(PRECISION_RE, s, i)
                precision = precision_match.group() or None
                i = precision_match.end()

                # length modifier is ignored
                i = _must_match(LENGTH_RE, s, i).end()

                try:
                    conversion = s[i]
                except IndexError:
                    raise ValueError('end-of-string while parsing format')
                i += 1

                fmt = (key, conversion_flag, width, precision, conversion)
                yield s[string_start:string_end], fmt

                in_fmt = False
                string_start = i

        if in_fmt:
            raise ValueError('end-of-string while parsing format')

    return tuple(_parse_inner())


</t>
<t tx="ekr.20240131003855.210">class AssertTuple(Message):
    """
    Assertion test is a non-empty tuple literal, which are always True.
    """
    message = 'assertion is always true, perhaps remove parentheses?'


</t>
<t tx="ekr.20240131003855.211">class ForwardAnnotationSyntaxError(Message):
    @others
</t>
<t tx="ekr.20240131003855.212">message = 'syntax error in forward annotation %r'

def __init__(self, filename, loc, annotation):
    Message.__init__(self, filename, loc)
    self.message_args = (annotation,)


</t>
<t tx="ekr.20240131003855.213">class RaiseNotImplemented(Message):
    message = "'raise NotImplemented' should be 'raise NotImplementedError'"


</t>
<t tx="ekr.20240131003855.214">class InvalidPrintSyntax(Message):
    message = 'use of &gt;&gt; is invalid with print function'


</t>
<t tx="ekr.20240131003855.215">class IsLiteral(Message):
    message = 'use ==/!= to compare constant literals (str, bytes, int, float, tuple)'


</t>
<t tx="ekr.20240131003855.216">class FStringMissingPlaceholders(Message):
    message = 'f-string is missing placeholders'


</t>
<t tx="ekr.20240131003855.217">class StringDotFormatExtraPositionalArguments(Message):
    @others
</t>
<t tx="ekr.20240131003855.218">message = "'...'.format(...) has unused arguments at position(s): %s"

def __init__(self, filename, loc, extra_positions):
    Message.__init__(self, filename, loc)
    self.message_args = (extra_positions,)


</t>
<t tx="ekr.20240131003855.219">class StringDotFormatExtraNamedArguments(Message):
    @others
</t>
<t tx="ekr.20240131003855.22">class _FieldsOrder(dict):
    """Fix order of AST node fields."""

    @others
</t>
<t tx="ekr.20240131003855.220">message = "'...'.format(...) has unused named argument(s): %s"

def __init__(self, filename, loc, extra_keywords):
    Message.__init__(self, filename, loc)
    self.message_args = (extra_keywords,)


</t>
<t tx="ekr.20240131003855.221">class StringDotFormatMissingArgument(Message):
    @others
</t>
<t tx="ekr.20240131003855.222">message = "'...'.format(...) is missing argument(s) for placeholder(s): %s"

def __init__(self, filename, loc, missing_arguments):
    Message.__init__(self, filename, loc)
    self.message_args = (missing_arguments,)


</t>
<t tx="ekr.20240131003855.223">class StringDotFormatMixingAutomatic(Message):
    message = "'...'.format(...) mixes automatic and manual numbering"


</t>
<t tx="ekr.20240131003855.224">class StringDotFormatInvalidFormat(Message):
    @others
</t>
<t tx="ekr.20240131003855.225">message = "'...'.format(...) has invalid format string: %s"

def __init__(self, filename, loc, error):
    Message.__init__(self, filename, loc)
    self.message_args = (error,)


</t>
<t tx="ekr.20240131003855.226">class PercentFormatInvalidFormat(Message):
    @others
</t>
<t tx="ekr.20240131003855.227">message = "'...' %% ... has invalid format string: %s"

def __init__(self, filename, loc, error):
    Message.__init__(self, filename, loc)
    self.message_args = (error,)


</t>
<t tx="ekr.20240131003855.228">class PercentFormatMixedPositionalAndNamed(Message):
    message = "'...' %% ... has mixed positional and named placeholders"


</t>
<t tx="ekr.20240131003855.229">class PercentFormatUnsupportedFormatCharacter(Message):
    @others
</t>
<t tx="ekr.20240131003855.23">def _get_fields(self, node_class):
    # handle iter before target, and generators before element
    fields = node_class._fields
    if 'iter' in fields:
        key_first = 'iter'.find
    elif 'generators' in fields:
        key_first = 'generators'.find
    else:
        key_first = 'value'.find
    return tuple(sorted(fields, key=key_first, reverse=True))

</t>
<t tx="ekr.20240131003855.230">message = "'...' %% ... has unsupported format character %r"

def __init__(self, filename, loc, c):
    Message.__init__(self, filename, loc)
    self.message_args = (c,)


</t>
<t tx="ekr.20240131003855.231">class PercentFormatPositionalCountMismatch(Message):
    @others
</t>
<t tx="ekr.20240131003855.232">message = "'...' %% ... has %d placeholder(s) but %d substitution(s)"

def __init__(self, filename, loc, n_placeholders, n_substitutions):
    Message.__init__(self, filename, loc)
    self.message_args = (n_placeholders, n_substitutions)


</t>
<t tx="ekr.20240131003855.233">class PercentFormatExtraNamedArguments(Message):
    @others
</t>
<t tx="ekr.20240131003855.234">message = "'...' %% ... has unused named argument(s): %s"

def __init__(self, filename, loc, extra_keywords):
    Message.__init__(self, filename, loc)
    self.message_args = (extra_keywords,)


</t>
<t tx="ekr.20240131003855.235">class PercentFormatMissingArgument(Message):
    @others
</t>
<t tx="ekr.20240131003855.236">message = "'...' %% ... is missing argument(s) for placeholder(s): %s"

def __init__(self, filename, loc, missing_arguments):
    Message.__init__(self, filename, loc)
    self.message_args = (missing_arguments,)


</t>
<t tx="ekr.20240131003855.237">class PercentFormatExpectedMapping(Message):
    message = "'...' %% ... expected mapping but got sequence"


</t>
<t tx="ekr.20240131003855.238">class PercentFormatExpectedSequence(Message):
    message = "'...' %% ... expected sequence but got mapping"


</t>
<t tx="ekr.20240131003855.239">class PercentFormatStarRequiresSequence(Message):
    message = "'...' %% ... `*` specifier requires sequence"
</t>
<t tx="ekr.20240131003855.24">def __missing__(self, node_class):
    self[node_class] = fields = self._get_fields(node_class)
    return fields


</t>
<t tx="ekr.20240131003855.240">"""
Provide the Reporter class.
"""

import re
import sys


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.241">class Reporter:
    """
    Formats the results of pyflakes checks to users.
    """

    @others
</t>
<t tx="ekr.20240131003855.242">def __init__(self, warningStream, errorStream):
    """
    Construct a L{Reporter}.

    @param warningStream: A file-like object where warnings will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stdout} is a good value.
    @param errorStream: A file-like object where error output will be
        written to.  The stream's C{write} method must accept unicode.
        C{sys.stderr} is a good value.
    """
    self._stdout = warningStream
    self._stderr = errorStream

</t>
<t tx="ekr.20240131003855.243">def unexpectedError(self, filename, msg):
    """
    An unexpected error occurred trying to process C{filename}.

    @param filename: The path to a file that we could not process.
    @ptype filename: C{unicode}
    @param msg: A message explaining the problem.
    @ptype msg: C{unicode}
    """
    self._stderr.write(f"{filename}: {msg}\n")

</t>
<t tx="ekr.20240131003855.244">def syntaxError(self, filename, msg, lineno, offset, text):
    """
    There was a syntax error in C{filename}.

    @param filename: The path to the file with the syntax error.
    @ptype filename: C{unicode}
    @param msg: An explanation of the syntax error.
    @ptype msg: C{unicode}
    @param lineno: The line number where the syntax error occurred.
    @ptype lineno: C{int}
    @param offset: The column on which the syntax error occurred, or None.
    @ptype offset: C{int}
    @param text: The source code containing the syntax error.
    @ptype text: C{unicode}
    """
    if text is None:
        line = None
    else:
        line = text.splitlines()[-1]

    # lineno might be None if the error was during tokenization
    # lineno might be 0 if the error came from stdin
    lineno = max(lineno or 0, 1)

    if offset is not None:
        # some versions of python emit an offset of -1 for certain encoding errors
        offset = max(offset, 1)
        self._stderr.write('%s:%d:%d: %s\n' %
                           (filename, lineno, offset, msg))
    else:
        self._stderr.write('%s:%d: %s\n' % (filename, lineno, msg))

    if line is not None:
        self._stderr.write(line)
        self._stderr.write('\n')
        if offset is not None:
            self._stderr.write(re.sub(r'\S', ' ', line[:offset - 1]) +
                               "^\n")

</t>
<t tx="ekr.20240131003855.245">def flake(self, message):
    """
    pyflakes found something wrong with the code.

    @param: A L{pyflakes.messages.Message}.
    """
    self._stdout.write(str(message))
    self._stdout.write('\n')


</t>
<t tx="ekr.20240131003855.246">def _makeDefaultReporter():
    """
    Make a reporter that can be used when no reporter is specified.
    """
    return Reporter(sys.stdout, sys.stderr)
</t>
<t tx="ekr.20240131003855.25">def counter(items):
    """
    Simplest required implementation of collections.Counter. Required as 2.6
    does not have Counter in collections.
    """
    results = {}
    for item in items:
        results[item] = results.get(item, 0) + 1
    return results


</t>
<t tx="ekr.20240131003855.26">def iter_child_nodes(node, omit=None, _fields_order=_FieldsOrder()):
    """
    Yield all direct child nodes of *node*, that is, all fields that
    are nodes and all items of fields that are lists of nodes.

    :param node:          AST node to be iterated upon
    :param omit:          String or tuple of strings denoting the
                          attributes of the node to be omitted from
                          further parsing
    :param _fields_order: Order of AST node fields
    """
    for name in _fields_order[node.__class__]:
        if omit and name in omit:
            continue
        field = getattr(node, name, None)
        if isinstance(field, ast.AST):
            yield field
        elif isinstance(field, list):
            for item in field:
                if isinstance(item, ast.AST):
                    yield item


</t>
<t tx="ekr.20240131003855.27">def convert_to_value(item):
    if isinstance(item, ast.Constant):
        return item.value
    elif isinstance(item, ast.Tuple):
        return tuple(convert_to_value(i) for i in item.elts)
    elif isinstance(item, ast.Name):
        return VariableKey(item=item)
    else:
        return UnhandledKeyType()


</t>
<t tx="ekr.20240131003855.28">def is_notimplemented_name_node(node):
    return isinstance(node, ast.Name) and getNodeName(node) == 'NotImplemented'


</t>
<t tx="ekr.20240131003855.29">class Binding:
    """
    Represents the binding of a value to a name.

    The checker uses this to keep track of which names have been bound and
    which names have not. See L{Assignment} for a special type of binding that
    is checked with stricter rules.

    @ivar used: pair of (L{Scope}, node) indicating the scope and
                the node that this binding was last used.
    """

    @others
</t>
<t tx="ekr.20240131003855.3">from pyflakes.api import main

# python -m pyflakes
if __name__ == '__main__':
    main(prog='pyflakes')
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.30">def __init__(self, name, source):
    self.name = name
    self.source = source
    self.used = False

</t>
<t tx="ekr.20240131003855.31">def __str__(self):
    return self.name

</t>
<t tx="ekr.20240131003855.32">def __repr__(self):
    return '&lt;{} object {!r} from line {!r} at 0x{:x}&gt;'.format(
        self.__class__.__name__,
        self.name,
        self.source.lineno,
        id(self),
    )

</t>
<t tx="ekr.20240131003855.33">def redefines(self, other):
    return isinstance(other, Definition) and self.name == other.name


</t>
<t tx="ekr.20240131003855.34">class Definition(Binding):
    """
    A binding that defines a function or a class.
    """
    @others
</t>
<t tx="ekr.20240131003855.35">def redefines(self, other):
    return (
        super().redefines(other) or
        (isinstance(other, Assignment) and self.name == other.name)
    )


</t>
<t tx="ekr.20240131003855.36">class Builtin(Definition):
    """A definition created for all Python builtins."""

    @others
</t>
<t tx="ekr.20240131003855.37">def __init__(self, name):
    super().__init__(name, None)

</t>
<t tx="ekr.20240131003855.38">def __repr__(self):
    return '&lt;{} object {!r} at 0x{:x}&gt;'.format(
        self.__class__.__name__,
        self.name,
        id(self)
    )


</t>
<t tx="ekr.20240131003855.39">class UnhandledKeyType:
    """
    A dictionary key of a type that we cannot or do not check for duplicates.
    """


</t>
<t tx="ekr.20240131003855.4">"""
API for the command-line I{pyflakes} tool.
"""
import ast
import os
import platform
import re
import sys

from pyflakes import checker, __version__
from pyflakes import reporter as modReporter

__all__ = ['check', 'checkPath', 'checkRecursive', 'iterSourceCode', 'main']

PYTHON_SHEBANG_REGEX = re.compile(br'^#!.*\bpython(3(\.\d+)?|w)?[dmu]?\s')


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240131003855.40">class VariableKey:
    """
    A dictionary key which is a variable.

    @ivar item: The variable AST object.
    """
    @others
</t>
<t tx="ekr.20240131003855.41">def __init__(self, item):
    self.name = item.id

</t>
<t tx="ekr.20240131003855.42">def __eq__(self, compare):
    return (
        compare.__class__ == self.__class__ and
        compare.name == self.name
    )

</t>
<t tx="ekr.20240131003855.43">def __hash__(self):
    return hash(self.name)


</t>
<t tx="ekr.20240131003855.44">class Importation(Definition):
    """
    A binding created by an import statement.

    @ivar fullName: The complete name given to the import statement,
        possibly including multiple dotted components.
    @type fullName: C{str}
    """

    @others
</t>
<t tx="ekr.20240131003855.45">def __init__(self, name, source, full_name=None):
    self.fullName = full_name or name
    self.redefined = []
    super().__init__(name, source)

</t>
<t tx="ekr.20240131003855.46">def redefines(self, other):
    if isinstance(other, SubmoduleImportation):
        # See note in SubmoduleImportation about RedefinedWhileUnused
        return self.fullName == other.fullName
    return isinstance(other, Definition) and self.name == other.name

</t>
<t tx="ekr.20240131003855.47">def _has_alias(self):
    """Return whether importation needs an as clause."""
    return not self.fullName.split('.')[-1] == self.name

</t>
<t tx="ekr.20240131003855.48">@property
def source_statement(self):
    """Generate a source statement equivalent to the import."""
    if self._has_alias():
        return f'import {self.fullName} as {self.name}'
    else:
        return 'import %s' % self.fullName

</t>
<t tx="ekr.20240131003855.49">def __str__(self):
    """Return import full name with alias."""
    if self._has_alias():
        return self.fullName + ' as ' + self.name
    else:
        return self.fullName


</t>
<t tx="ekr.20240131003855.5">def check(codeString, filename, reporter=None):
    """
    Check the Python source given by C{codeString} for flakes.

    @param codeString: The Python source to check.
    @type codeString: C{str}

    @param filename: The name of the file the source came from, used to report
        errors.
    @type filename: C{str}

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: The number of warnings emitted.
    @rtype: C{int}
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    # First, compile into an AST and handle syntax errors.
    try:
        tree = ast.parse(codeString, filename=filename)
    except SyntaxError as e:
        reporter.syntaxError(filename, e.args[0], e.lineno, e.offset, e.text)
        return 1
    except Exception:
        reporter.unexpectedError(filename, 'problem decoding source')
        return 1
    # Okay, it's syntactically valid.  Now check it.
    w = checker.Checker(tree, filename=filename)
    w.messages.sort(key=lambda m: m.lineno)
    for warning in w.messages:
        reporter.flake(warning)
    return len(w.messages)


</t>
<t tx="ekr.20240131003855.50">class SubmoduleImportation(Importation):
    """
    A binding created by a submodule import statement.

    A submodule import is a special case where the root module is implicitly
    imported, without an 'as' clause, and the submodule is also imported.
    Python does not restrict which attributes of the root module may be used.

    This class is only used when the submodule import is without an 'as' clause.

    pyflakes handles this case by registering the root module name in the scope,
    allowing any attribute of the root module to be accessed.

    RedefinedWhileUnused is suppressed in `redefines` unless the submodule
    name is also the same, to avoid false positives.
    """

    @others
</t>
<t tx="ekr.20240131003855.51">def __init__(self, name, source):
    # A dot should only appear in the name when it is a submodule import
    assert '.' in name and (not source or isinstance(source, ast.Import))
    package_name = name.split('.')[0]
    super().__init__(package_name, source)
    self.fullName = name

</t>
<t tx="ekr.20240131003855.52">def redefines(self, other):
    if isinstance(other, Importation):
        return self.fullName == other.fullName
    return super().redefines(other)

</t>
<t tx="ekr.20240131003855.53">def __str__(self):
    return self.fullName

</t>
<t tx="ekr.20240131003855.54">@property
def source_statement(self):
    return 'import ' + self.fullName


</t>
<t tx="ekr.20240131003855.55">class ImportationFrom(Importation):

    @others
</t>
<t tx="ekr.20240131003855.56">def __init__(self, name, source, module, real_name=None):
    self.module = module
    self.real_name = real_name or name

    if module.endswith('.'):
        full_name = module + self.real_name
    else:
        full_name = module + '.' + self.real_name

    super().__init__(name, source, full_name)

</t>
<t tx="ekr.20240131003855.57">def __str__(self):
    """Return import full name with alias."""
    if self.real_name != self.name:
        return self.fullName + ' as ' + self.name
    else:
        return self.fullName

</t>
<t tx="ekr.20240131003855.58">@property
def source_statement(self):
    if self.real_name != self.name:
        return f'from {self.module} import {self.real_name} as {self.name}'
    else:
        return f'from {self.module} import {self.name}'


</t>
<t tx="ekr.20240131003855.59">class StarImportation(Importation):
    """A binding created by a 'from x import *' statement."""

    @others
</t>
<t tx="ekr.20240131003855.6">def checkPath(filename, reporter=None):
    """
    Check the given path, printing out any warnings detected.

    @param reporter: A L{Reporter} instance, where errors and warnings will be
        reported.

    @return: the number of warnings printed
    """
    if reporter is None:
        reporter = modReporter._makeDefaultReporter()
    try:
        with open(filename, 'rb') as f:
            codestr = f.read()
    except OSError as e:
        reporter.unexpectedError(filename, e.args[1])
        return 1
    return check(codestr, filename, reporter)


</t>
<t tx="ekr.20240131003855.60">def __init__(self, name, source):
    super().__init__('*', source)
    # Each star importation needs a unique name, and
    # may not be the module name otherwise it will be deemed imported
    self.name = name + '.*'
    self.fullName = name

</t>
<t tx="ekr.20240131003855.61">@property
def source_statement(self):
    return 'from ' + self.fullName + ' import *'

</t>
<t tx="ekr.20240131003855.62">def __str__(self):
    # When the module ends with a ., avoid the ambiguous '..*'
    if self.fullName.endswith('.'):
        return self.source_statement
    else:
        return self.name


</t>
<t tx="ekr.20240131003855.63">class FutureImportation(ImportationFrom):
    """
    A binding created by a from `__future__` import statement.

    `__future__` imports are implicitly used.
    """

    @others
</t>
<t tx="ekr.20240131003855.64">def __init__(self, name, source, scope):
    super().__init__(name, source, '__future__')
    self.used = (scope, source)


</t>
<t tx="ekr.20240131003855.65">class Argument(Binding):
    """
    Represents binding a name as an argument.
    """


</t>
<t tx="ekr.20240131003855.66">class Assignment(Binding):
    """
    Represents binding a name with an explicit assignment.

    The checker will raise warnings for any Assignment that isn't used. Also,
    the checker does not consider assignments in tuple/list unpacking to be
    Assignments, rather it treats them as simple Bindings.
    """


</t>
<t tx="ekr.20240131003855.67">class NamedExprAssignment(Assignment):
    """
    Represents binding a name with an assignment expression.
    """


</t>
<t tx="ekr.20240131003855.68">class Annotation(Binding):
    """
    Represents binding a name to a type without an associated value.

    As long as this name is not assigned a value in another binding, it is considered
    undefined for most purposes. One notable exception is using the name as a type
    annotation.
    """

    @others
</t>
<t tx="ekr.20240131003855.69">def redefines(self, other):
    """An Annotation doesn't define any name, so it cannot redefine one."""
    return False


</t>
<t tx="ekr.20240131003855.7">def isPythonFile(filename):
    """Return True if filename points to a Python file."""
    if filename.endswith('.py'):
        return True

    # Avoid obvious Emacs backup files
    if filename.endswith("~"):
        return False

    max_bytes = 128

    try:
        with open(filename, 'rb') as f:
            text = f.read(max_bytes)
            if not text:
                return False
    except OSError:
        return False

    return PYTHON_SHEBANG_REGEX.match(text)


</t>
<t tx="ekr.20240131003855.70">class FunctionDefinition(Definition):
    pass


</t>
<t tx="ekr.20240131003855.71">class ClassDefinition(Definition):
    pass


</t>
<t tx="ekr.20240131003855.72">class ExportBinding(Binding):
    """
    A binding created by an C{__all__} assignment.  If the names in the list
    can be determined statically, they will be treated as names for export and
    additional checking applied to them.

    The only recognized C{__all__} assignment via list/tuple concatenation is in the
    following format:

        __all__ = ['a'] + ['b'] + ['c']

    Names which are imported and not otherwise used but appear in the value of
    C{__all__} will not have an unused import warning reported for them.
    """

    @others
</t>
<t tx="ekr.20240131003855.73">def __init__(self, name, source, scope):
    if '__all__' in scope and isinstance(source, ast.AugAssign):
        self.names = list(scope['__all__'].names)
    else:
        self.names = []

    def _add_to_names(container):
        for node in container.elts:
            if isinstance(node, ast.Constant) and isinstance(node.value, str):
                self.names.append(node.value)

    if isinstance(source.value, (ast.List, ast.Tuple)):
        _add_to_names(source.value)
    # If concatenating lists or tuples
    elif isinstance(source.value, ast.BinOp):
        currentValue = source.value
        while isinstance(currentValue.right, (ast.List, ast.Tuple)):
            left = currentValue.left
            right = currentValue.right
            _add_to_names(right)
            # If more lists are being added
            if isinstance(left, ast.BinOp):
                currentValue = left
            # If just two lists are being added
            elif isinstance(left, (ast.List, ast.Tuple)):
                _add_to_names(left)
                # All lists accounted for - done
                break
            # If not list concatenation
            else:
                break
    super().__init__(name, source)


</t>
<t tx="ekr.20240131003855.74">class Scope(dict):
    @others
</t>
<t tx="ekr.20240131003855.75">importStarred = False       # set to True when import * is found

def __repr__(self):
    scope_cls = self.__class__.__name__
    return f'&lt;{scope_cls} at 0x{id(self):x} {dict.__repr__(self)}&gt;'


</t>
<t tx="ekr.20240131003855.76">class ClassScope(Scope):
    pass


</t>
<t tx="ekr.20240131003855.77">class FunctionScope(Scope):
    """
    I represent a name scope for a function.

    @ivar globals: Names declared 'global' in this function.
    """
    @others
</t>
<t tx="ekr.20240131003855.78">usesLocals = False
alwaysUsed = {'__tracebackhide__', '__traceback_info__',
              '__traceback_supplement__'}

def __init__(self):
    super().__init__()
    # Simplify: manage the special locals as globals
    self.globals = self.alwaysUsed.copy()
    self.returnValue = None     # First non-empty return

</t>
<t tx="ekr.20240131003855.79">def unused_assignments(self):
    """
    Return a generator for the assignments which have not been used.
    """
    for name, binding in self.items():
        if (not binding.used and
                name != '_' and  # see issue #202
                name not in self.globals and
                not self.usesLocals and
                isinstance(binding, Assignment)):
            yield name, binding

</t>
<t tx="ekr.20240131003855.8">def iterSourceCode(paths):
    """
    Iterate over all Python source files in C{paths}.

    @param paths: A list of paths.  Directories will be recursed into and
        any .py files found will be yielded.  Any non-directories will be
        yielded as-is.
    """
    for path in paths:
        if os.path.isdir(path):
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    full_path = os.path.join(dirpath, filename)
                    if isPythonFile(full_path):
                        yield full_path
        else:
            yield path


</t>
<t tx="ekr.20240131003855.80">def unused_annotations(self):
    """
    Return a generator for the annotations which have not been used.
    """
    for name, binding in self.items():
        if not binding.used and isinstance(binding, Annotation):
            yield name, binding


</t>
<t tx="ekr.20240131003855.81">class TypeScope(Scope):
    pass


</t>
<t tx="ekr.20240131003855.82">class GeneratorScope(Scope):
    pass


</t>
<t tx="ekr.20240131003855.83">class ModuleScope(Scope):
    """Scope for a module."""
    _futures_allowed = True
    _annotations_future_enabled = False


</t>
<t tx="ekr.20240131003855.84">class DoctestScope(ModuleScope):
    """Scope for a doctest."""


</t>
<t tx="ekr.20240131003855.85">class DetectClassScopedMagic:
    names = dir()


</t>
<t tx="ekr.20240131003855.86"># Globally defined names which are not attributes of the builtins module, or
# are only present on some platforms.
_MAGIC_GLOBALS = ['__file__', '__builtins__', '__annotations__', 'WindowsError']


def getNodeName(node):
    # Returns node.id, or node.name, or None
    if hasattr(node, 'id'):     # One of the many nodes with an id
        return node.id
    if hasattr(node, 'name'):   # an ExceptHandler node
        return node.name
    if hasattr(node, 'rest'):   # a MatchMapping node
        return node.rest


</t>
<t tx="ekr.20240131003855.87">TYPING_MODULES = frozenset(('typing', 'typing_extensions'))


def _is_typing_helper(node, is_name_match_fn, scope_stack):
    """
    Internal helper to determine whether or not something is a member of a
    typing module. This is used as part of working out whether we are within a
    type annotation context.

    Note: you probably don't want to use this function directly. Instead see the
    utils below which wrap it (`_is_typing` and `_is_any_typing_member`).
    """

    def _bare_name_is_attr(name):
        for scope in reversed(scope_stack):
            if name in scope:
                return (
                    isinstance(scope[name], ImportationFrom) and
                    scope[name].module in TYPING_MODULES and
                    is_name_match_fn(scope[name].real_name)
                )

        return False

    def _module_scope_is_typing(name):
        for scope in reversed(scope_stack):
            if name in scope:
                return (
                    isinstance(scope[name], Importation) and
                    scope[name].fullName in TYPING_MODULES
                )

        return False

    return (
        (
            isinstance(node, ast.Name) and
            _bare_name_is_attr(node.id)
        ) or (
            isinstance(node, ast.Attribute) and
            isinstance(node.value, ast.Name) and
            _module_scope_is_typing(node.value.id) and
            is_name_match_fn(node.attr)
        )
    )


</t>
<t tx="ekr.20240131003855.88">def _is_typing(node, typing_attr, scope_stack):
    """
    Determine whether `node` represents the member of a typing module specified
    by `typing_attr`.

    This is used as part of working out whether we are within a type annotation
    context.
    """
    return _is_typing_helper(node, lambda x: x == typing_attr, scope_stack)


</t>
<t tx="ekr.20240131003855.89">def _is_any_typing_member(node, scope_stack):
    """
    Determine whether `node` represents any member of a typing module.

    This is used as part of working out whether we are within a type annotation
    context.
    """
    return _is_typing_helper(node, lambda x: True, scope_stack)


</t>
<t tx="ekr.20240131003855.9">def checkRecursive(paths, reporter):
    """
    Recursively check all source files in C{paths}.

    @param paths: A list of paths to Python source files and directories
        containing Python source files.
    @param reporter: A L{Reporter} where all of the warnings and errors
        will be reported to.
    @return: The number of warnings found.
    """
    warnings = 0
    for sourcePath in iterSourceCode(paths):
        warnings += checkPath(sourcePath, reporter)
    return warnings


</t>
<t tx="ekr.20240131003855.90">def is_typing_overload(value, scope_stack):
    return (
        isinstance(value.source, (ast.FunctionDef, ast.AsyncFunctionDef)) and
        any(
            _is_typing(dec, 'overload', scope_stack)
            for dec in value.source.decorator_list
        )
    )


</t>
<t tx="ekr.20240131003855.91">class AnnotationState:
    NONE = 0
    STRING = 1
    BARE = 2


</t>
<t tx="ekr.20240131003855.92">def in_annotation(func):
    @functools.wraps(func)
    def in_annotation_func(self, *args, **kwargs):
        with self._enter_annotation():
            return func(self, *args, **kwargs)
    return in_annotation_func


</t>
<t tx="ekr.20240131003855.93">def in_string_annotation(func):
    @functools.wraps(func)
    def in_annotation_func(self, *args, **kwargs):
        with self._enter_annotation(AnnotationState.STRING):
            return func(self, *args, **kwargs)
    return in_annotation_func


</t>
<t tx="ekr.20240131003855.94">class Checker:
    """I check the cleanliness and sanity of Python code."""

    @others
</t>
<t tx="ekr.20240131003855.95">_ast_node_scope = {
    ast.Module: ModuleScope,
    ast.ClassDef: ClassScope,
    ast.FunctionDef: FunctionScope,
    ast.AsyncFunctionDef: FunctionScope,
    ast.Lambda: FunctionScope,
    ast.ListComp: GeneratorScope,
    ast.SetComp: GeneratorScope,
    ast.GeneratorExp: GeneratorScope,
    ast.DictComp: GeneratorScope,
}

nodeDepth = 0
offset = None
_in_annotation = AnnotationState.NONE

builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
_customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
if _customBuiltIns:
    builtIns.update(_customBuiltIns.split(','))
del _customBuiltIns

def __init__(self, tree, filename='(none)', builtins=None,
             withDoctest='PYFLAKES_DOCTEST' in os.environ, file_tokens=()):
    self._nodeHandlers = {}
    self._deferred = collections.deque()
    self.deadScopes = []
    self.messages = []
    self.filename = filename
    if builtins:
        self.builtIns = self.builtIns.union(builtins)
    self.withDoctest = withDoctest
    self.exceptHandlers = [()]
    self.root = tree

    self.scopeStack = []
    try:
        scope_tp = Checker._ast_node_scope[type(tree)]
    except KeyError:
        raise RuntimeError('No scope implemented for the node %r' % tree)

    with self.in_scope(scope_tp):
        for builtin in self.builtIns:
            self.addBinding(None, Builtin(builtin))
        self.handleChildren(tree)
        self._run_deferred()

    self.checkDeadScopes()

    if file_tokens:
        warnings.warn(
            '`file_tokens` will be removed in a future version',
            stacklevel=2,
        )

</t>
<t tx="ekr.20240131003855.96">def deferFunction(self, callable):
    """
    Schedule a function handler to be called just before completion.

    This is used for handling function bodies, which must be deferred
    because code later in the file might modify the global scope. When
    `callable` is called, the scope at the time this is called will be
    restored, however it will contain any new bindings added to it.
    """
    self._deferred.append((callable, self.scopeStack[:], self.offset))

</t>
<t tx="ekr.20240131003855.97">def _run_deferred(self):
    orig = (self.scopeStack, self.offset)

    while self._deferred:
        handler, scope, offset = self._deferred.popleft()
        self.scopeStack, self.offset = scope, offset
        handler()

    self.scopeStack, self.offset = orig

</t>
<t tx="ekr.20240131003855.98">def _in_doctest(self):
    return (len(self.scopeStack) &gt;= 2 and
            isinstance(self.scopeStack[1], DoctestScope))

</t>
<t tx="ekr.20240131003855.99">@property
def futuresAllowed(self):
    if not all(isinstance(scope, ModuleScope)
               for scope in self.scopeStack):
        return False

    return self.scope._futures_allowed

@futuresAllowed.setter
def futuresAllowed(self, value):
    assert value is False
    if isinstance(self.scope, ModuleScope):
        self.scope._futures_allowed = False

</t>
<t tx="ekr.20240131004408.1">import __future__
import builtins
import ast
import collections
import contextlib
import doctest
import functools
import os
import re
import string
import sys
import warnings

from pyflakes import messages
</t>
<t tx="ekr.20240131005639.1"></t>
<t tx="ekr.20240131005837.1"></t>
<t tx="ekr.20240131005858.1"></t>
<t tx="ekr.20240131010054.1"></t>
<t tx="ekr.20240131010350.1"></t>
<t tx="ekr.20240131011429.1"></t>
<t tx="ekr.20240131011732.1"></t>
<t tx="ekr.20240131011753.1"></t>
<t tx="ekr.20240306055458.1">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='pyflakes')
</t>
<t tx="ekr.20240306055659.1">cd-pyflakes</t>
<t tx="ekr.20240709170956.1">class Checker:
    """I check the cleanliness and sanity of Python code."""

    &lt;&lt; Checker: class data &gt;&gt;

    @others
</t>
<t tx="ekr.20240709170956.10">@property
def annotationsFutureEnabled(self):
    scope = self.scopeStack[0]
    if not isinstance(scope, ModuleScope):
        return False
    return scope._annotations_future_enabled

@annotationsFutureEnabled.setter
def annotationsFutureEnabled(self, value):
    assert value is True
    assert isinstance(self.scope, ModuleScope)
    self.scope._annotations_future_enabled = True

</t>
<t tx="ekr.20240709170956.11">@property
def scope(self):
    return self.scopeStack[-1]

@contextlib.contextmanager
def in_scope(self, cls):
    self.scopeStack.append(cls())
    try:
        yield
    finally:
        self.deadScopes.append(self.scopeStack.pop())

</t>
<t tx="ekr.20240709170956.12"></t>
<t tx="ekr.20240709170956.13">def checkDeadScopes(self):
    """
    Look at scopes which have been fully examined and report names in them
    which were imported but unused.
    """
    for scope in self.deadScopes:
        # imports in classes are public members
        if isinstance(scope, ClassScope):
            continue

        if isinstance(scope, FunctionScope):
            for name, binding in scope.unused_assignments():
                self.report(messages.UnusedVariable, binding.source, name)
            for name, binding in scope.unused_annotations():
                self.report(messages.UnusedAnnotation, binding.source, name)

        all_binding = scope.get('__all__')
        if all_binding and not isinstance(all_binding, ExportBinding):
            all_binding = None

        if all_binding:
            all_names = set(all_binding.names)
            undefined = [
                name for name in all_binding.names
                if name not in scope
            ]
        else:
            all_names = undefined = []

        if undefined:
            if not scope.importStarred and \
               os.path.basename(self.filename) != '__init__.py':
                # Look for possible mistakes in the export list
                for name in undefined:
                    self.report(messages.UndefinedExport,
                                scope['__all__'].source, name)

            # mark all import '*' as used by the undefined in __all__
            if scope.importStarred:
                from_list = []
                for binding in scope.values():
                    if isinstance(binding, StarImportation):
                        binding.used = all_binding
                        from_list.append(binding.fullName)
                # report * usage, with a list of possible sources
                from_list = ', '.join(sorted(from_list))
                for name in undefined:
                    self.report(messages.ImportStarUsage,
                                scope['__all__'].source, name, from_list)

        # Look for imported names that aren't used.
        for value in scope.values():
            if isinstance(value, Importation):
                used = value.used or value.name in all_names
                if not used:
                    messg = messages.UnusedImport
                    self.report(messg, value.source, str(value))
                for node in value.redefined:
                    if isinstance(self.getParent(node), FOR_TYPES):
                        messg = messages.ImportShadowedByLoopVar
                    elif used:
                        continue
                    else:
                        messg = messages.RedefinedWhileUnused
                    self.report(messg, node, value.name, value.source)

</t>
<t tx="ekr.20240709170956.14">def report(self, messageClass, *args, **kwargs):
    self.messages.append(messageClass(self.filename, *args, **kwargs))

</t>
<t tx="ekr.20240709170956.15"></t>
<t tx="ekr.20240709170956.16">def getParent(self, node):
    # Lookup the first parent which is not Tuple, List or Starred
    while True:
        node = node._pyflakes_parent
        if not hasattr(node, 'elts') and not hasattr(node, 'ctx'):
            return node

</t>
<t tx="ekr.20240709170956.17">def getCommonAncestor(self, lnode, rnode, stop):
    if (
            stop in (lnode, rnode) or
            not (
                hasattr(lnode, '_pyflakes_parent') and
                hasattr(rnode, '_pyflakes_parent')
            )
    ):
        return None
    if lnode is rnode:
        return lnode

    if (lnode._pyflakes_depth &gt; rnode._pyflakes_depth):
        return self.getCommonAncestor(lnode._pyflakes_parent, rnode, stop)
    if (lnode._pyflakes_depth &lt; rnode._pyflakes_depth):
        return self.getCommonAncestor(lnode, rnode._pyflakes_parent, stop)
    return self.getCommonAncestor(
        lnode._pyflakes_parent,
        rnode._pyflakes_parent,
        stop,
    )

</t>
<t tx="ekr.20240709170956.18">def descendantOf(self, node, ancestors, stop):
    for a in ancestors:
        if self.getCommonAncestor(node, a, stop):
            return True
    return False

</t>
<t tx="ekr.20240709170956.19">def _getAncestor(self, node, ancestor_type):
    parent = node
    while True:
        if parent is self.root:
            return None
        parent = self.getParent(parent)
        if isinstance(parent, ancestor_type):
            return parent

</t>
<t tx="ekr.20240709170956.2">_ast_node_scope = {
    ast.Module: ModuleScope,
    ast.ClassDef: ClassScope,
    ast.FunctionDef: FunctionScope,
    ast.AsyncFunctionDef: FunctionScope,
    ast.Lambda: FunctionScope,
    ast.ListComp: GeneratorScope,
    ast.SetComp: GeneratorScope,
    ast.GeneratorExp: GeneratorScope,
    ast.DictComp: GeneratorScope,
}

nodeDepth = 0
offset = None
_in_annotation = AnnotationState.NONE

builtIns = set(builtin_vars).union(_MAGIC_GLOBALS)
_customBuiltIns = os.environ.get('PYFLAKES_BUILTINS')
if _customBuiltIns:
    builtIns.update(_customBuiltIns.split(','))
del _customBuiltIns
</t>
<t tx="ekr.20240709170956.20">def getScopeNode(self, node):
    return self._getAncestor(node, tuple(Checker._ast_node_scope.keys()))

</t>
<t tx="ekr.20240709170956.21">def differentForks(self, lnode, rnode):
    """True, if lnode and rnode are located on different forks of IF/TRY"""
    ancestor = self.getCommonAncestor(lnode, rnode, self.root)
    parts = getAlternatives(ancestor)
    if parts:
        for items in parts:
            if self.descendantOf(lnode, items, ancestor) ^ \
               self.descendantOf(rnode, items, ancestor):
                return True
    return False

</t>
<t tx="ekr.20240709170956.22">def addBinding(self, node, value):
    """
    Called when a binding is altered.

    - `node` is the statement responsible for the change
    - `value` is the new value, a Binding instance
    """
    # assert value.source in (node, node._pyflakes_parent):
    for scope in self.scopeStack[::-1]:
        if value.name in scope:
            break
    existing = scope.get(value.name)

    if (existing and not isinstance(existing, Builtin) and
            not self.differentForks(node, existing.source)):

        parent_stmt = self.getParent(value.source)
        if isinstance(existing, Importation) and isinstance(parent_stmt, FOR_TYPES):
            self.report(messages.ImportShadowedByLoopVar,
                        node, value.name, existing.source)

        elif scope is self.scope:
            if (
                    (not existing.used and value.redefines(existing)) and
                    (value.name != '_' or isinstance(existing, Importation)) and
                    not is_typing_overload(existing, self.scopeStack)
            ):
                self.report(messages.RedefinedWhileUnused,
                            node, value.name, existing.source)

        elif isinstance(existing, Importation) and value.redefines(existing):
            existing.redefined.append(node)

    if value.name in self.scope:
        # then assume the rebound name is used as a global or within a loop
        value.used = self.scope[value.name].used

    # don't treat annotations as assignments if there is an existing value
    # in scope
    if value.name not in self.scope or not isinstance(value, Annotation):
        if isinstance(value, NamedExprAssignment):
            # PEP 572: use scope in which outermost generator is defined
            scope = next(
                scope
                for scope in reversed(self.scopeStack)
                if not isinstance(scope, GeneratorScope)
            )
            # it may be a re-assignment to an already existing name
            scope.setdefault(value.name, value)
        else:
            self.scope[value.name] = value

</t>
<t tx="ekr.20240709170956.23"></t>
<t tx="ekr.20240709170956.24">def isLiteralTupleUnpacking(self, node):
    if not isinstance(node, ast.Assign):
        return False
    for child in node.targets + [node.value]:
        if not hasattr(child, 'elts'):
            return False
    return True

</t>
<t tx="ekr.20240709170956.25">def isDocstring(self, node):
    """
    Determine if the given node is a docstring, as long as it is at the
    correct place in the node tree.
    """
    return (
        isinstance(node, ast.Expr) and
        isinstance(node.value, ast.Constant) and
        isinstance(node.value.value, str)
    )

</t>
<t tx="ekr.20240709170956.26">def getDocstring(self, node):
    if (
            isinstance(node, ast.Expr) and
            isinstance(node.value, ast.Constant) and
            isinstance(node.value.value, str)
    ):
        return node.value.value, node.lineno - 1
    else:
        return None, None

</t>
<t tx="ekr.20240709170956.27"></t>
<t tx="ekr.20240709170956.28">@contextlib.contextmanager
def _enter_annotation(self, ann_type=AnnotationState.BARE):
    orig, self._in_annotation = self._in_annotation, ann_type
    try:
        yield
    finally:
        self._in_annotation = orig

</t>
<t tx="ekr.20240709170956.29">@property
def _in_postponed_annotation(self):
    return (
        self._in_annotation == AnnotationState.STRING or
        self.annotationsFutureEnabled
    )

</t>
<t tx="ekr.20240709170956.3">def __init__(self, tree,
    filename='(none)',
    builtins=None,
    withDoctest='PYFLAKES_DOCTEST' in os.environ,
):
    self._deferred = collections.deque()
    self.deadScopes = []
    self.messages = []
    self.filename = filename
    if builtins:
        self.builtIns = self.builtIns.union(builtins)
    self.withDoctest = withDoctest
    self.exceptHandlers = [()]
    self.root = tree

    self.scopeStack = []
    try:
        scope_tp = Checker._ast_node_scope[type(tree)]
    except KeyError:
        raise RuntimeError('No scope implemented for the node %r' % tree)

    with self.in_scope(scope_tp):
        for builtin in self.builtIns:
            self.addBinding(None, Builtin(builtin))
        self.visit(tree)
        self._run_deferred()

    self.checkDeadScopes()
</t>
<t tx="ekr.20240709170956.30">@contextlib.contextmanager
def _type_param_scope(self, node):
    with contextlib.ExitStack() as ctx:
        if sys.version_info &gt;= (3, 12):
            ctx.enter_context(self.in_scope(TypeScope))
            for param in node.type_params:
                self.handleNode(param, node)
        yield

</t>
<t tx="ekr.20240709170956.31">def handle_annotation_always_deferred(self, annotation, parent):
    fn = in_annotation(Checker.handleNode)
    self.deferFunction(lambda: fn(self, annotation, parent))

</t>
<t tx="ekr.20240709170956.32">@in_annotation
def handleAnnotation(self, annotation, node):
    if (
            isinstance(annotation, ast.Constant) and
            isinstance(annotation.value, str)
    ):
        # Defer handling forward annotation.
        self.deferFunction(functools.partial(
            self.handleStringAnnotation,
            annotation.value,
            node,
            annotation.lineno,
            annotation.col_offset,
            messages.ForwardAnnotationSyntaxError,
        ))
    elif self.annotationsFutureEnabled:
        self.handle_annotation_always_deferred(annotation, node)
    else:
        self.handleNode(annotation, node)

</t>
<t tx="ekr.20240709170956.33">def visit(self, node):
    """
    Visit all of node's children in no particular order.

    Use Checker.visitFields if the order matters.
    """
    for field in node._fields:
        child = getattr(node, field, None)
        if isinstance(child, list):
            for item in child:
                if isinstance(item, ast.AST):
                    self.handleNode(item, node)
        elif isinstance(child, ast.AST):
            self.handleNode(child, node)
</t>
<t tx="ekr.20240709170956.34">_getDoctestExamples = doctest.DocTestParser().get_examples

def handleDoctests(self, node):
    try:
        (docstring, node_lineno) = self.getDocstring(node.body[0])
        examples = docstring and self._getDoctestExamples(docstring)
    except (ValueError, IndexError):
        # e.g. line 6 of the docstring for &lt;string&gt; has inconsistent
        # leading whitespace: ...
        return
    if not examples:
        return

    # Place doctest in module scope
    saved_stack = self.scopeStack
    self.scopeStack = [self.scopeStack[0]]
    node_offset = self.offset or (0, 0)
    with self.in_scope(DoctestScope):
        if '_' not in self.scopeStack[0]:
            self.addBinding(None, Builtin('_'))
        for example in examples:
            try:
                tree = ast.parse(example.source, "&lt;doctest&gt;")
            except SyntaxError as e:
                position = (node_lineno + example.lineno + e.lineno,
                            example.indent + 4 + (e.offset or 0))
                self.report(messages.DoctestSyntaxError, node, position)
            else:
                self.offset = (node_offset[0] + node_lineno + example.lineno,
                               node_offset[1] + example.indent + 4)
                self.visit(tree)
                self.offset = node_offset
    self.scopeStack = saved_stack

</t>
<t tx="ekr.20240709170956.35">def handleFields(self, node, fields):
    """Visit only the *given* children of node in the given order."""
    ### g.trace(node.__class__.__name__)
    for field in fields:
        child = getattr(node, field, None)
        if isinstance(child, list):
            for item in child:
                if isinstance(item, ast.AST):
                    self.handleNode(item, node)
        elif isinstance(child, ast.AST):
            self.handleNode(child, node)
</t>
<t tx="ekr.20240709170956.36">def handleNode(self, node, parent):
    if node is None:
        return
    if self.offset and getattr(node, 'lineno', None) is not None:
        node.lineno += self.offset[0]
        node.col_offset += self.offset[1]
    if (
            self.futuresAllowed and
            self.nodeDepth == 0 and
            not isinstance(node, ast.ImportFrom) and
            not self.isDocstring(node)
    ):
        self.futuresAllowed = False
    self.nodeDepth += 1
    node._pyflakes_depth = self.nodeDepth
    node._pyflakes_parent = parent
    try:
        # Was getNodeHandler().
        handler = getattr(self, node.__class__.__name__, self.visit)
        handler(node)
    finally:
        self.nodeDepth -= 1

</t>
<t tx="ekr.20240709170956.37">@in_string_annotation
def handleStringAnnotation(self, s, node, ref_lineno, ref_col_offset, err):
    try:
        tree = ast.parse(s)
    except SyntaxError:
        self.report(err, node, s)
        return

    body = tree.body
    if len(body) != 1 or not isinstance(body[0], ast.Expr):
        self.report(err, node, s)
        return

    parsed_annotation = tree.body[0].value
    for descendant in ast.walk(parsed_annotation):
        if (
                'lineno' in descendant._attributes and
                'col_offset' in descendant._attributes
        ):
            descendant.lineno = ref_lineno
            descendant.col_offset = ref_col_offset

    self.handleNode(parsed_annotation, node)

</t>
<t tx="ekr.20240709170956.38"></t>
<t tx="ekr.20240709170956.39">def handleNodeLoad(self, node, parent):
    name = getNodeName(node)
    if not name:
        return

    # only the following can access class scoped variables (since classes
    # aren't really a scope)
    # - direct accesses (not within a nested scope)
    # - generators
    # - type annotations (for generics, etc.)
    can_access_class_vars = None
    importStarred = None

    # try enclosing function scopes and global scope
    for scope in self.scopeStack[-1::-1]:
        if isinstance(scope, ClassScope):
            if name == '__class__':
                return
            if can_access_class_vars is False:
                # only generators used in a class scope can access the
                # names of the class. this is skipped during the first
                # iteration
                continue

        binding = scope.get(name, None)
        if isinstance(binding, Annotation) and not self._in_postponed_annotation:
            scope[name].used = (self.scope, node)
            continue

        if name == 'print' and isinstance(binding, Builtin):
            if (isinstance(parent, ast.BinOp) and
                    isinstance(parent.op, ast.RShift)):
                self.report(messages.InvalidPrintSyntax, node)

        try:
            scope[name].used = (self.scope, node)

            # if the name of SubImportation is same as
            # alias of other Importation and the alias
            # is used, SubImportation also should be marked as used.
            n = scope[name]
            if isinstance(n, Importation) and n._has_alias():
                try:
                    scope[n.fullName].used = (self.scope, node)
                except KeyError:
                    pass
        except KeyError:
            pass
        else:
            return

        importStarred = importStarred or scope.importStarred

        if can_access_class_vars is not False:
            can_access_class_vars = isinstance(
                scope, (TypeScope, GeneratorScope),
            )

    if importStarred:
        from_list = []

        for scope in self.scopeStack[-1::-1]:
            for binding in scope.values():
                if isinstance(binding, StarImportation):
                    # mark '*' imports as used for each scope
                    binding.used = (self.scope, node)
                    from_list.append(binding.fullName)

        # report * usage, with a list of possible sources
        from_list = ', '.join(sorted(from_list))
        self.report(messages.ImportStarUsage, node, name, from_list)
        return

    if name == '__path__' and os.path.basename(self.filename) == '__init__.py':
        # the special name __path__ is valid only in packages
        return

    if name in DetectClassScopedMagic.names and isinstance(self.scope, ClassScope):
        return

    # protected with a NameError handler?
    if 'NameError' not in self.exceptHandlers[-1]:
        self.report(messages.UndefinedName, node, name)

</t>
<t tx="ekr.20240709170956.4"></t>
<t tx="ekr.20240709170956.40">def handleNodeStore(self, node):
    name = getNodeName(node)
    if not name:
        return
    # if the name hasn't already been defined in the current scope
    if isinstance(self.scope, FunctionScope) and name not in self.scope:
        # for each function or module scope above us
        for scope in self.scopeStack[:-1]:
            if not isinstance(scope, (FunctionScope, ModuleScope)):
                continue
            # if the name was defined in that scope, and the name has
            # been accessed already in the current scope, and hasn't
            # been declared global
            used = name in scope and scope[name].used
            if used and used[0] is self.scope and name not in self.scope.globals:
                # then it's probably a mistake
                self.report(messages.UndefinedLocal,
                            scope[name].used[1], name, scope[name].source)
                break

    parent_stmt = self.getParent(node)
    if isinstance(parent_stmt, ast.AnnAssign) and parent_stmt.value is None:
        binding = Annotation(name, node)
    elif (
        isinstance(parent_stmt, (FOR_TYPES, ast.comprehension))
        or (
            parent_stmt != node._pyflakes_parent
            and not self.isLiteralTupleUnpacking(parent_stmt)
        )
    ):
        binding = Binding(name, node)
    elif (
        name == '__all__'
        and isinstance(self.scope, ModuleScope)
        and isinstance(node._pyflakes_parent, (ast.Assign, ast.AugAssign, ast.AnnAssign))
    ):
        binding = ExportBinding(name, node._pyflakes_parent, self.scope)
    elif isinstance(parent_stmt, ast.NamedExpr):
        binding = NamedExprAssignment(name, node)
    else:
        binding = Assignment(name, node)
    self.addBinding(node, binding)

</t>
<t tx="ekr.20240709170956.41">def handleNodeDelete(self, node):

    def on_conditional_branch():
        """
        Return `True` if node is part of a conditional body.
        """
        current = getattr(node, '_pyflakes_parent', None)
        while current:
            if isinstance(current, (ast.If, ast.While, ast.IfExp)):
                return True
            current = getattr(current, '_pyflakes_parent', None)
        return False

    name = getNodeName(node)
    if not name:
        return

    if on_conditional_branch():
        # We cannot predict if this conditional branch is going to
        # be executed.
        return

    if isinstance(self.scope, FunctionScope) and name in self.scope.globals:
        self.scope.globals.remove(name)
    else:
        try:
            del self.scope[name]
        except KeyError:
            self.report(messages.UndefinedName, node, name)

</t>
<t tx="ekr.20240709170956.42"></t>
<t tx="ekr.20240709170956.43"></t>
<t tx="ekr.20240709170956.44">def arguments(self, node):

    # Visit all fields except 'defaults' and 'kw_defaults'.
    fields = ('posonlyargs', 'args', 'vararg', 'kwonlyargs', 'kwarg')
    self.handleFields(node, fields)

</t>
<t tx="ekr.20240709170956.45">def Assign(self, node):

    # Order matters.
    self.handleFields(node, ('value', 'targets'))
</t>
<t tx="ekr.20240709170956.46">def comprehension(self, node):

    # Order matters.
    self.handleFields(node, ('iter', 'target', 'ifs'))
</t>
<t tx="ekr.20240709170956.47">def DictComp(self, node):

    with self.in_scope(GeneratorScope):
        # Order matters.
        self.handleFields(node, ('generators', 'key', 'value'))
</t>
<t tx="ekr.20240709170956.48">def For(self, node):

    # Order matters.
    self.handleFields(node, ('iter', 'target', 'type_comment', 'body', 'orelse'))

AsyncFor = For
</t>
<t tx="ekr.20240709170956.49">def GeneratorExp(self, node):

    with self.in_scope(GeneratorScope):
        # Order matters.
        self.handleFields(node, ('generators', 'elt'))

ListComp = SetComp = GeneratorExp
</t>
<t tx="ekr.20240709170956.5">def deferFunction(self, callable):
    """
    Schedule a function handler to be called just before completion.

    This is used for handling function bodies, which must be deferred
    because code later in the file might modify the global scope. When
    `callable` is called, the scope at the time this is called will be
    restored, however it will contain any new bindings added to it.
    """
    self._deferred.append((callable, self.scopeStack[:], self.offset))

</t>
<t tx="ekr.20240709170956.50">def NamedExpr(self, node):

    # Order matters.
    self.handleFields(node, ('value', 'target'))
</t>
<t tx="ekr.20240709170956.51"></t>
<t tx="ekr.20240709170956.52">def AnnAssign(self, node):
    self.handleAnnotation(node.annotation, node)
    # If the assignment has value, handle the *value* now.
    if node.value:
        # If the annotation is `TypeAlias`, handle the *value* as an annotation.
        if _is_typing(node.annotation, 'TypeAlias', self.scopeStack):
            self.handleAnnotation(node.value, node)
        else:
            self.handleNode(node.value, node)
    self.handleNode(node.target, node)

</t>
<t tx="ekr.20240709170956.53">def arg(self, node):
    self.addBinding(node, Argument(node.arg, self.getScopeNode(node)))

</t>
<t tx="ekr.20240709170956.54">def Assert(self, node):
    if isinstance(node.test, ast.Tuple) and node.test.elts != []:
        self.report(messages.AssertTuple, node)
    self.visit(node)

</t>
<t tx="ekr.20240709170956.55">def AugAssign(self, node):
    self.handleNodeLoad(node.target, node)
    self.handleNode(node.value, node)
    self.handleNode(node.target, node)

</t>
<t tx="ekr.20240709170956.56">def BinOp(self, node):
    if (
        isinstance(node.op, ast.Mod) and
        isinstance(node.left, ast.Constant) and
        isinstance(node.left.value, str)
    ):
        self._handle_percent_format(node)
    self.visit(node)

</t>
<t tx="ekr.20240709170956.57">def _handle_percent_format(self, node):
    try:
        placeholders = parse_percent_format(node.left.value)
    except ValueError:
        self.report(
            messages.PercentFormatInvalidFormat,
            node,
            'incomplete format',
        )
        return

    named = set()
    positional_count = 0
    positional = None
    for _, placeholder in placeholders:
        if placeholder is None:
            continue
        name, _, width, precision, conversion = placeholder

        if conversion == '%':
            continue

        if conversion not in VALID_CONVERSIONS:
            self.report(
                messages.PercentFormatUnsupportedFormatCharacter,
                node,
                conversion,
            )

        if positional is None and conversion:
            positional = name is None

        for part in (width, precision):
            if part is not None and '*' in part:
                if not positional:
                    self.report(
                        messages.PercentFormatStarRequiresSequence,
                        node,
                    )
                else:
                    positional_count += 1

        if positional and name is not None:
            self.report(
                messages.PercentFormatMixedPositionalAndNamed,
                node,
            )
            return
        
        if not positional and name is None:
            self.report(
                messages.PercentFormatMixedPositionalAndNamed,
                node,
            )
            return

        if positional:
            positional_count += 1
        else:
            named.add(name)

    if (
            isinstance(node.right, (ast.List, ast.Tuple)) and
            # does not have any *splats (py35+ feature)
            not any(
                isinstance(elt, ast.Starred)
                for elt in node.right.elts
            )
    ):
        substitution_count = len(node.right.elts)
        if positional and positional_count != substitution_count:
            self.report(
                messages.PercentFormatPositionalCountMismatch,
                node,
                positional_count,
                substitution_count,
            )
        elif not positional:
            self.report(messages.PercentFormatExpectedMapping, node)

    if (
            isinstance(node.right, ast.Dict) and
            all(
                isinstance(k, ast.Constant) and isinstance(k.value, str)
                for k in node.right.keys
            )
    ):
        if positional and positional_count &gt; 1:
            self.report(messages.PercentFormatExpectedSequence, node)
            return

        substitution_keys = {k.value for k in node.right.keys}
        extra_keys = substitution_keys - named
        missing_keys = named - substitution_keys
        if not positional and extra_keys:
            self.report(
                messages.PercentFormatExtraNamedArguments,
                node,
                ', '.join(sorted(extra_keys)),
            )
        if not positional and missing_keys:
            self.report(
                messages.PercentFormatMissingArgument,
                node,
                ', '.join(sorted(missing_keys)),
            )

</t>
<t tx="ekr.20240709170956.58">def Call(self, node):
    if (
        isinstance(node.func, ast.Attribute)
        and isinstance(node.func.value, ast.Constant)
        and isinstance(node.func.value.value, str)
        and node.func.attr == 'format'
    ):
        self._handle_string_dot_format(node)

    def _call_children(node2, omit):
        omit = omit or []
        fields = [z for z in node2._fields if z not in omit]
        self.handleFields(node2, fields)

    omit = []
    annotated = []
    not_annotated = []

    if len(node.args) &gt;= 1 and _is_typing(node.func, 'cast', self.scopeStack):
        with self._enter_annotation():
            self.handleNode(node.args[0], node)

    elif _is_typing(node.func, 'TypeVar', self.scopeStack):

        # TypeVar("T", "int", "str")
        omit += ["args"]
        annotated += [arg for arg in node.args[1:]]

        # TypeVar("T", bound="str")
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords if k.arg == "bound"]
        not_annotated += [
            (k, ["value"] if k.arg == "bound" else None)
            for k in node.keywords
        ]

    elif _is_typing(node.func, "TypedDict", self.scopeStack):
        # TypedDict("a", {"a": int})
        if len(node.args) &gt; 1 and isinstance(node.args[1], ast.Dict):
            omit += ["args"]
            annotated += node.args[1].values
            not_annotated += [
                (arg, ["values"] if i == 1 else None)
                for i, arg in enumerate(node.args)
            ]

        # TypedDict("a", a=int)
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords]
        not_annotated += [(k, ["value"]) for k in node.keywords]

    elif _is_typing(node.func, "NamedTuple", self.scopeStack):
        # NamedTuple("a", [("a", int)])
        if (
            len(node.args) &gt; 1 and
            isinstance(node.args[1], (ast.Tuple, ast.List)) and
            all(isinstance(x, (ast.Tuple, ast.List)) and
                len(x.elts) == 2 for x in node.args[1].elts)
        ):
            omit += ["args"]
            annotated += [elt.elts[1] for elt in node.args[1].elts]
            not_annotated += [(elt.elts[0], None) for elt in node.args[1].elts]
            not_annotated += [
                (arg, ["elts"] if i == 1 else None)
                for i, arg in enumerate(node.args)
            ]
            not_annotated += [(elt, "elts") for elt in node.args[1].elts]

        # NamedTuple("a", a=int)
        omit += ["keywords"]
        annotated += [k.value for k in node.keywords]
        not_annotated += [(k, ["value"]) for k in node.keywords]

    if omit:
        with self._enter_annotation(AnnotationState.NONE):
            for na_node, na_omit in not_annotated:
                _call_children(na_node, omit=na_omit)
            _call_children(node, omit)

        with self._enter_annotation():
            for annotated_node in annotated:
                self.handleNode(annotated_node, node)
    else:
        self.visit(node)
</t>
<t tx="ekr.20240709170956.59">def _handle_string_dot_format(self, node):
    try:
        placeholders = tuple(parse_format_string(node.func.value.value))
    except ValueError as e:
        self.report(messages.StringDotFormatInvalidFormat, node, e)
        return

    auto = None
    next_auto = 0

    placeholder_positional = set()
    placeholder_named = set()

    def _add_key(fmtkey):
        """Returns True if there is an error which should early-exit"""
        nonlocal auto, next_auto

        if fmtkey is None:  # end of string or `{` / `}` escapes
            return False

        # attributes / indices are allowed in `.format(...)`
        fmtkey, _, _ = fmtkey.partition('.')
        fmtkey, _, _ = fmtkey.partition('[')

        try:
            fmtkey = int(fmtkey)
        except ValueError:
            pass
        else:  # fmtkey was an integer
            if auto is True:
                self.report(messages.StringDotFormatMixingAutomatic, node)
                return True
            auto = False

        if fmtkey == '':
            if auto is False:
                self.report(messages.StringDotFormatMixingAutomatic, node)
                return True

            auto = True
            fmtkey = next_auto
            next_auto += 1

        if isinstance(fmtkey, int):
            placeholder_positional.add(fmtkey)
        else:
            placeholder_named.add(fmtkey)

        return False

    for _, fmtkey, spec, _ in placeholders:
        if _add_key(fmtkey):
            return

        # spec can also contain format specifiers
        if spec is not None:
            try:
                spec_placeholders = tuple(parse_format_string(spec))
            except ValueError as e:
                self.report(messages.StringDotFormatInvalidFormat, node, e)
                return

            for _, spec_fmtkey, spec_spec, _ in spec_placeholders:
                # can't recurse again
                if spec_spec is not None and '{' in spec_spec:
                    self.report(
                        messages.StringDotFormatInvalidFormat,
                        node,
                        'Max string recursion exceeded',
                    )
                    return
                if _add_key(spec_fmtkey):
                    return

    # bail early if there is *args or **kwargs
    if (
            # *args
            any(isinstance(arg, ast.Starred) for arg in node.args) or
            # **kwargs
            any(kwd.arg is None for kwd in node.keywords)
    ):
        return

    substitution_positional = set(range(len(node.args)))
    substitution_named = {kwd.arg for kwd in node.keywords}

    extra_positional = substitution_positional - placeholder_positional
    extra_named = substitution_named - placeholder_named

    missing_arguments = (
        (placeholder_positional | placeholder_named) -
        (substitution_positional | substitution_named)
    )

    if extra_positional:
        self.report(
            messages.StringDotFormatExtraPositionalArguments,
            node,
            ', '.join(sorted(str(x) for x in extra_positional)),
        )
    if extra_named:
        self.report(
            messages.StringDotFormatExtraNamedArguments,
            node,
            ', '.join(sorted(extra_named)),
        )
    if missing_arguments:
        self.report(
            messages.StringDotFormatMissingArgument,
            node,
            ', '.join(sorted(str(x) for x in missing_arguments)),
        )

</t>
<t tx="ekr.20240709170956.6">def _run_deferred(self):
    orig = (self.scopeStack, self.offset)

    while self._deferred:
        handler, scope, offset = self._deferred.popleft()
        self.scopeStack, self.offset = scope, offset
        handler()

    self.scopeStack, self.offset = orig

</t>
<t tx="ekr.20240709170956.60">def ClassDef(self, node):
    """
    Check names used in a class definition, including its decorators, base
    classes, and the body of its definition.  Additionally, add its name to
    the current scope.
    """
    for deco in node.decorator_list:
        self.handleNode(deco, node)

    with self._type_param_scope(node):
        for baseNode in node.bases:
            self.handleNode(baseNode, node)
        for keywordNode in node.keywords:
            self.handleNode(keywordNode, node)
        with self.in_scope(ClassScope):
            # doctest does not process doctest within a doctest
            # classes within classes are processed.
            if (self.withDoctest and
                    not self._in_doctest() and
                    not isinstance(self.scope, FunctionScope)):
                self.deferFunction(lambda: self.handleDoctests(node))
            for stmt in node.body:
                self.handleNode(stmt, node)

    self.addBinding(node, ClassDefinition(node.name, node))

</t>
<t tx="ekr.20240709170956.61">def Compare(self, node):
    left = node.left
    for op, right in zip(node.ops, node.comparators):
        if (
            isinstance(op, (ast.Is, ast.IsNot))
            and (
                _is_const_non_singleton(left) or
                _is_const_non_singleton(right)
            )
        ):
            self.report(messages.IsLiteral, node)
        left = right

    self.visit(node)
</t>
<t tx="ekr.20240709170956.62">def Constant(self, node):
    if isinstance(node.value, str) and self._in_annotation:
        fn = functools.partial(
            self.handleStringAnnotation,
            node.value,
            node,
            node.lineno,
            node.col_offset,
            messages.ForwardAnnotationSyntaxError,
        )
        self.deferFunction(fn)

</t>
<t tx="ekr.20240709170956.63">def Continue(self, node):
    # Walk the tree up until we see a loop (OK), a function or class
    # definition (not OK), for 'continue', a finally block (not OK), or
    # the top module scope (not OK)
    n = node
    while hasattr(n, '_pyflakes_parent'):
        n, n_child = n._pyflakes_parent, n
        if isinstance(n, (ast.While, ast.For, ast.AsyncFor)):
            # Doesn't apply unless it's in the loop itself
            if n_child not in n.orelse:
                return
        if isinstance(n, (ast.FunctionDef, ast.ClassDef)):
            break
    if isinstance(node, ast.Continue):
        self.report(messages.ContinueOutsideLoop, node)
    else:  # ast.Break
        self.report(messages.BreakOutsideLoop, node)

Break = Continue

</t>
<t tx="ekr.20240709170956.64">def Dict(self, node):
    # Complain if there are duplicate keys with different values
    # If they have the same value it's not going to cause potentially
    # unexpected behaviour so we'll not complain.
    keys = [convert_to_value(key) for key in node.keys]
    key_counts = collections.Counter(keys)
    duplicate_keys = [
        key for key, count in key_counts.items() if count &gt; 1
    ]

    for key in duplicate_keys:
        key_indices = [i for i, i_key in enumerate(keys) if i_key == key]

        values = collections.Counter(
            convert_to_value(node.values[index])
            for index in key_indices
        )
        if any(count == 1 for value, count in values.items()):
            for key_index in key_indices:
                key_node = node.keys[key_index]
                if isinstance(key, VariableKey):
                    self.report(messages.MultiValueRepeatedKeyVariable,
                                key_node,
                                key.name)
                else:
                    self.report(
                        messages.MultiValueRepeatedKeyLiteral,
                        key_node,
                        key,
                    )
    self.visit(node)

</t>
<t tx="ekr.20240709170956.65">def ExceptHandler(self, node):
    if node.name is None:
        self.visit(node)
        return

    # If the name already exists in the scope, modify state of existing
    # binding.
    if node.name in self.scope:
        self.handleNodeStore(node)

    # 3.x: the name of the exception, which is not a Name node, but a
    # simple string, creates a local that is only bound within the scope of
    # the except: block. As such, temporarily remove the existing binding
    # to more accurately determine if the name is used in the except:
    # block.

    try:
        prev_definition = self.scope.pop(node.name)
    except KeyError:
        prev_definition = None

    self.handleNodeStore(node)
    self.visit(node)

    # See discussion on https://github.com/PyCQA/pyflakes/pull/59

    # We're removing the local name since it's being unbound after leaving
    # the except: block and it's always unbound if the except: block is
    # never entered. This will cause an "undefined name" error raised if
    # the checked code tries to use the name afterwards.
    #
    # Unless it's been removed already. Then do nothing.

    try:
        binding = self.scope.pop(node.name)
    except KeyError:
        pass
    else:
        if not binding.used:
            self.report(messages.UnusedVariable, node, node.name)

    # Restore.
    if prev_definition:
        self.scope[node.name] = prev_definition

</t>
<t tx="ekr.20240709170956.66">def FunctionDef(self, node):
    for deco in node.decorator_list:
        self.handleNode(deco, node)

    with self._type_param_scope(node):
        self.Lambda(node)

    self.addBinding(node, FunctionDefinition(node.name, node))
    # doctest does not process doctest within a doctest,
    # or in nested functions.
    if (self.withDoctest
        and not self._in_doctest()
        and not isinstance(self.scope, FunctionScope)
    ):
        self.deferFunction(lambda: self.handleDoctests(node))

AsyncFunctionDef = FunctionDef

</t>
<t tx="ekr.20240709170956.67">def Global(self, node):
    """
    Keep track of globals declarations.
    """
    global_scope_index = 1 if self._in_doctest() else 0
    global_scope = self.scopeStack[global_scope_index]

    # Ignore 'global' statement in global scope.
    if self.scope is not global_scope:

        # One 'global' statement can bind multiple (comma-delimited) names.
        for node_name in node.names:
            node_value = Assignment(node_name, node)

            # Remove UndefinedName messages already reported for this name.
            # TODO: if the global is not used in this scope, it does not
            # become a globally defined name.  See test_unused_global.
            self.messages = [
                m for m in self.messages if not
                isinstance(m, messages.UndefinedName) or
                m.message_args[0] != node_name]

            # Bind name to global scope if it doesn't exist already.
            global_scope.setdefault(node_name, node_value)

            # Bind name to non-global scopes, but as already "used".
            node_value.used = (global_scope, node)
            for scope in self.scopeStack[global_scope_index + 1:]:
                scope[node_name] = node_value

Nonlocal = Global

</t>
<t tx="ekr.20240709170956.68">def If(self, node):
    if isinstance(node.test, ast.Tuple) and node.test.elts != []:
        self.report(messages.IfTuple, node)
    self.visit(node)

IfExp = If

</t>
<t tx="ekr.20240709170956.69">def ignore(self, node):
    pass

Pass = ignore

# expression contexts are node instances too, though being constants
Load = Store = Del = AugLoad = AugStore = Param = ignore

# same for operators
And = Or = Add = Sub = Mult = Div = Mod = Pow = LShift = RShift = \
    BitOr = BitXor = BitAnd = FloorDiv = Invert = Not = UAdd = USub = \
    Eq = NotEq = Lt = LtE = Gt = GtE = Is = IsNot = In = NotIn = \
    MatMult = ignore
</t>
<t tx="ekr.20240709170956.7">def _in_doctest(self):
    return (len(self.scopeStack) &gt;= 2 and
            isinstance(self.scopeStack[1], DoctestScope))

</t>
<t tx="ekr.20240709170956.70">def Import(self, node):
    for alias in node.names:
        if '.' in alias.name and not alias.asname:
            importation = SubmoduleImportation(alias.name, node)
        else:
            name = alias.asname or alias.name
            importation = Importation(name, node, alias.name)
        self.addBinding(node, importation)

</t>
<t tx="ekr.20240709170956.71">def ImportFrom(self, node):
    if node.module == '__future__':
        if not self.futuresAllowed:
            self.report(messages.LateFutureImport, node)
    else:
        self.futuresAllowed = False

    module = ('.' * node.level) + (node.module or '')

    for alias in node.names:
        name = alias.asname or alias.name
        if node.module == '__future__':
            importation = FutureImportation(name, node, self.scope)
            if alias.name not in __future__.all_feature_names:
                self.report(messages.FutureFeatureNotDefined,
                            node, alias.name)
            if alias.name == 'annotations':
                self.annotationsFutureEnabled = True
        elif alias.name == '*':
            if not isinstance(self.scope, ModuleScope):
                self.report(messages.ImportStarNotPermitted,
                            node, module)
                continue

            self.scope.importStarred = True
            self.report(messages.ImportStarUsed, node, module)
            importation = StarImportation(module, node)
        else:
            importation = ImportationFrom(name, node,
                                          module, alias.name)
        self.addBinding(node, importation)

</t>
<t tx="ekr.20240709170956.72">_in_fstring = False

def JoinedStr(self, node):
    if (
            # the conversion / etc. flags are parsed as f-strings without
            # placeholders
            not self._in_fstring and
            not any(isinstance(x, ast.FormattedValue) for x in node.values)
    ):
        self.report(messages.FStringMissingPlaceholders, node)

    self._in_fstring, orig = True, self._in_fstring
    try:
        self.visit(node)
    finally:
        self._in_fstring = orig

</t>
<t tx="ekr.20240709170956.73">def Lambda(self, node):
    args = []
    annotations = []

    for arg in node.args.posonlyargs:
        args.append(arg.arg)
        annotations.append(arg.annotation)
    for arg in node.args.args + node.args.kwonlyargs:
        args.append(arg.arg)
        annotations.append(arg.annotation)
    defaults = node.args.defaults + node.args.kw_defaults

    has_annotations = not isinstance(node, ast.Lambda)

    for arg_name in ('vararg', 'kwarg'):
        wildcard = getattr(node.args, arg_name)
        if not wildcard:
            continue
        args.append(wildcard.arg)
        if has_annotations:
            annotations.append(wildcard.annotation)

    if has_annotations:
        annotations.append(node.returns)

    if len(set(args)) &lt; len(args):
        for (idx, arg) in enumerate(args):
            if arg in args[:idx]:
                self.report(messages.DuplicateArgument, node, arg)

    for annotation in annotations:
        self.handleAnnotation(annotation, node)

    for default in defaults:
        self.handleNode(default, node)

    def runFunction():
        with self.in_scope(FunctionScope):
            omit = ('decorator_list', 'returns', 'type_params')
            fields = [z for z in node._fields if z not in omit]
            self.handleFields(node, fields)

    self.deferFunction(runFunction)

</t>
<t tx="ekr.20240709170956.74">def _match_target(self, node):
    self.handleNodeStore(node)
    self.visit(node)

MatchAs = MatchMapping = MatchStar = _match_target

</t>
<t tx="ekr.20240709170956.75">def Name(self, node):
    """
    Handle occurrence of Name (which can be a load/store/delete access.)
    """
    # Locate the name in locals / function / globals scopes.
    if isinstance(node.ctx, ast.Load):
        self.handleNodeLoad(node, self.getParent(node))
        if (
            node.id == 'locals'
            and isinstance(self.scope, FunctionScope)
            and isinstance(node._pyflakes_parent, ast.Call)
        ):
            # we are doing locals() call in current scope
            self.scope.usesLocals = True
    elif isinstance(node.ctx, ast.Store):
        self.handleNodeStore(node)
    elif isinstance(node.ctx, ast.Del):
        self.handleNodeDelete(node)
    else:
        # Unknown context
        raise RuntimeError(f"Got impossible expression context: {node.ctx!r}")

</t>
<t tx="ekr.20240709170956.76">def Raise(self, node):
    self.visit(node)

    arg = node.exc

    if isinstance(arg, ast.Call):
        if is_notimplemented_name_node(arg.func):
            # Handle "raise NotImplemented(...)"
            self.report(messages.RaiseNotImplemented, node)
    elif is_notimplemented_name_node(arg):
        # Handle "raise NotImplemented"
        self.report(messages.RaiseNotImplemented, node)

</t>
<t tx="ekr.20240709170956.77">def Return(self, node):
    if isinstance(self.scope, (ClassScope, ModuleScope)):
        self.report(messages.ReturnOutsideFunction, node)
        return

    if (
        node.value and
        hasattr(self.scope, 'returnValue') and
        not self.scope.returnValue
    ):
        self.scope.returnValue = node.value
    self.handleNode(node.value, node)

</t>
<t tx="ekr.20240709170956.78">def Subscript(self, node):

    def _do_subscript():
        self.handleFields(node, ('value', 'slice'))

    if _is_name_or_attr(node.value, 'Literal'):
        with self._enter_annotation(AnnotationState.NONE):
            _do_subscript()

    elif _is_name_or_attr(node.value, 'Annotated'):
        self.handleNode(node.value, node)

        # py39+
        if isinstance(node.slice, ast.Tuple):
            slice_tuple = node.slice
        # &lt;py39
        elif (
            isinstance(node.slice, ast.Index) and
            isinstance(node.slice.value, ast.Tuple)
        ):
            slice_tuple = node.slice.value
        else:
            slice_tuple = None

        # not a multi-arg `Annotated`
        if slice_tuple is None or len(slice_tuple.elts) &lt; 2:
            self.handleNode(node.slice, node)
        else:
            # the first argument is the type
            self.handleNode(slice_tuple.elts[0], node)
            # the rest of the arguments are not
            with self._enter_annotation(AnnotationState.NONE):
                for arg in slice_tuple.elts[1:]:
                    self.handleNode(arg, node)

        self.handleNode(node.ctx, node)
    else:
        if _is_any_typing_member(node.value, self.scopeStack):
            with self._enter_annotation():
                _do_subscript()
        else:
            _do_subscript()
</t>
<t tx="ekr.20240709170956.79">def Try(self, node):
    handler_names = []
    # List the exception handlers
    for i, handler in enumerate(node.handlers):
        if isinstance(handler.type, ast.Tuple):
            for exc_type in handler.type.elts:
                handler_names.append(getNodeName(exc_type))
        elif handler.type:
            handler_names.append(getNodeName(handler.type))

        if handler.type is None and i &lt; len(node.handlers) - 1:
            self.report(messages.DefaultExceptNotLast, handler)
    # Memorize the except handlers and process the body
    self.exceptHandlers.append(handler_names)
    for child in node.body:
        self.handleNode(child, node)
    self.exceptHandlers.pop()
    # Process the other children.
    self.handleFields(node, ('handlers', 'orelse', 'finalbody'))

TryStar = Try
</t>
<t tx="ekr.20240709170956.8"></t>
<t tx="ekr.20240709170956.80">def Tuple(self, node):
    if isinstance(node.ctx, ast.Store):
        # Python 3 advanced tuple unpacking: a, *b, c = d.
        # Only one starred expression is allowed, and no more than 1&lt;&lt;8
        # assignments are allowed before a stared expression. There is
        # also a limit of 1&lt;&lt;24 expressions after the starred expression,
        # which is impossible to test due to memory restrictions, but we
        # add it here anyway
        has_starred = False
        star_loc = -1
        for i, n in enumerate(node.elts):
            if isinstance(n, ast.Starred):
                if has_starred:
                    self.report(messages.TwoStarredExpressions, node)
                    # The SyntaxError doesn't distinguish two from more
                    # than two.
                    break
                has_starred = True
                star_loc = i
        if star_loc &gt;= 1 &lt;&lt; 8 or len(node.elts) - star_loc - 1 &gt;= 1 &lt;&lt; 24:
            self.report(messages.TooManyExpressionsInStarredAssignment, node)
    self.visit(node)

List = Tuple
</t>
<t tx="ekr.20240709170956.81">def TypeAlias(self, node):
    self.handleNode(node.name, node)
    with self._type_param_scope(node):
        self.handle_annotation_always_deferred(node.value, node)
</t>
<t tx="ekr.20240709170956.82">def TypeVar(self, node):
    self.handleNodeStore(node)
    self.handle_annotation_always_deferred(node.bound, node)

ParamSpec = TypeVarTuple = handleNodeStore

</t>
<t tx="ekr.20240709170956.83">def Yield(self, node):
    if isinstance(self.scope, (ClassScope, ModuleScope)):
        self.report(messages.YieldOutsideFunction, node)
        return

    self.handleNode(node.value, node)

Await = YieldFrom = Yield

</t>
<t tx="ekr.20240709170956.9">@property
def futuresAllowed(self):
    if not all(isinstance(scope, ModuleScope)
               for scope in self.scopeStack):
        return False

    return self.scope._futures_allowed

@futuresAllowed.setter
def futuresAllowed(self, value):
    assert value is False
    if isinstance(self.scope, ModuleScope):
        self.scope._futures_allowed = False

</t>
<t tx="ekr.20240709171100.1">See Pychecker issue #816: https://github.com/PyCQA/pyflakes/issues/816

- Remove `_FieldsOrder` class and `Checker.iter_child_nodes`.
- Remove `omit` kwarg everywhere.
- Add `Checker.handleFields`.
- Define `Checker.handleChildren` in terms of `Checker.handleFields`.
- Retire `Checker.getNodeHandler` and related cache: `Checker._nodeHandlers`.
</t>
</tnodes>
</leo_file>
