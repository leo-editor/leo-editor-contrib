<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20181029161420.1"><vh>site-packages/websockets</vh>
<v t="ekr.20181029161420.2"><vh>@@clean client.py</vh>
<v t="ekr.20181029161420.3"><vh>Declarations (client.py)</vh></v>
<v t="ekr.20181029161420.4"><vh>class WebSocketClientProtocol(WebSocketCommonProtocol)</vh>
<v t="ekr.20181029161420.5"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).__init__</vh></v>
<v t="ekr.20181029161420.6"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).write_http_request</vh></v>
<v t="ekr.20181029161420.7"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).read_http_response</vh></v>
<v t="ekr.20181029161420.8"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).process_extensions</vh></v>
<v t="ekr.20181029161420.9"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).process_subprotocol</vh></v>
<v t="ekr.20181029161420.10"><vh>WebSocketClientProtocol(WebSocketCommonProtocol).handshake</vh></v>
</v>
<v t="ekr.20181029161420.11"><vh>class Connect</vh>
<v t="ekr.20181029161420.12"><vh>Connect.__init__</vh></v>
<v t="ekr.20181029161420.13"><vh>Connect.__iter__</vh></v>
</v>
</v>
<v t="ekr.20181029161420.14"><vh>@@clean compatibility.py</vh>
<v t="ekr.20181029161420.15"><vh>Declarations (compatibility.py)</vh></v>
</v>
<v t="ekr.20181029161420.16"><vh>@@clean exceptions.py</vh>
<v t="ekr.20181029161420.18"><vh>class InvalidHandshake(Exception)</vh></v>
<v t="ekr.20181029161420.19"><vh>class AbortHandshake(InvalidHandshake)</vh>
<v t="ekr.20181029161420.20"><vh>AbortHandshake(InvalidHandshake).__init__</vh></v>
</v>
<v t="ekr.20181029161420.21"><vh>class InvalidMessage(InvalidHandshake)</vh></v>
<v t="ekr.20181029161420.22"><vh>class InvalidHeader(InvalidHandshake)</vh>
<v t="ekr.20181029161420.23"><vh>InvalidHeader(InvalidHandshake).__init__</vh></v>
</v>
<v t="ekr.20181029161420.24"><vh>class InvalidHeaderFormat(InvalidHeader)</vh>
<v t="ekr.20181029161420.25"><vh>InvalidHeaderFormat(InvalidHeader).__init__</vh></v>
</v>
<v t="ekr.20181029161420.26"><vh>class InvalidHeaderValue(InvalidHeader)</vh></v>
<v t="ekr.20181029161420.27"><vh>class InvalidUpgrade(InvalidHeader)</vh></v>
<v t="ekr.20181029161420.28"><vh>class InvalidOrigin(InvalidHeader)</vh>
<v t="ekr.20181029161420.29"><vh>InvalidOrigin(InvalidHeader).__init__</vh></v>
</v>
<v t="ekr.20181029161420.30"><vh>class InvalidStatusCode(InvalidHandshake)</vh>
<v t="ekr.20181029161420.31"><vh>InvalidStatusCode(InvalidHandshake).__init__</vh></v>
</v>
<v t="ekr.20181029161420.32"><vh>class NegotiationError(InvalidHandshake)</vh></v>
<v t="ekr.20181029161420.33"><vh>class InvalidParameterName(NegotiationError)</vh>
<v t="ekr.20181029161420.34"><vh>InvalidParameterName(NegotiationError).__init__</vh></v>
</v>
<v t="ekr.20181029161420.35"><vh>class InvalidParameterValue(NegotiationError)</vh>
<v t="ekr.20181029161420.36"><vh>InvalidParameterValue(NegotiationError).__init__</vh></v>
</v>
<v t="ekr.20181029161420.37"><vh>class DuplicateParameter(NegotiationError)</vh>
<v t="ekr.20181029161420.38"><vh>DuplicateParameter(NegotiationError).__init__</vh></v>
</v>
<v t="ekr.20181029161420.39"><vh>class InvalidState(Exception)</vh></v>
<v t="ekr.20181029161420.40"><vh>class ConnectionClosed(InvalidState)</vh>
<v t="ekr.20181029161420.41"><vh>ConnectionClosed(InvalidState).__init__</vh></v>
</v>
<v t="ekr.20181029161420.42"><vh>class InvalidURI(Exception)</vh></v>
<v t="ekr.20181029161420.43"><vh>class PayloadTooBig(Exception)</vh></v>
<v t="ekr.20181029161420.44"><vh>class WebSocketProtocolError(Exception)</vh></v>
</v>
<v t="ekr.20181029161420.45"><vh>@@clean framing.py</vh>
<v t="ekr.20181029161420.46"><vh>Declarations (framing.py)</vh></v>
<v t="ekr.20181029161420.47"><vh>class Frame(FrameData)</vh>
<v t="ekr.20181029161420.48"><vh>Frame(FrameData).__new__</vh></v>
<v t="ekr.20181029161420.49"><vh>Frame(FrameData).read</vh></v>
<v t="ekr.20181029161420.50"><vh>Frame(FrameData).write</vh></v>
<v t="ekr.20181029161420.51"><vh>Frame(FrameData).check</vh></v>
</v>
<v t="ekr.20181029161420.52"><vh>encode_data (framing.py)</vh></v>
<v t="ekr.20181029161420.53"><vh>parse_close (framing.py)</vh></v>
<v t="ekr.20181029161420.54"><vh>serialize_close (framing.py)</vh></v>
<v t="ekr.20181029161420.55"><vh>check_close (framing.py)</vh></v>
</v>
<v t="ekr.20181029161420.56"><vh>@@clean handshake.py</vh>
<v t="ekr.20181029161420.57"><vh>Declarations (handshake.py)</vh></v>
<v t="ekr.20181029161420.58"><vh>build_request (handshake.py)</vh></v>
<v t="ekr.20181029161420.59"><vh>check_request (handshake.py)</vh></v>
<v t="ekr.20181029161420.60"><vh>build_response (handshake.py)</vh></v>
<v t="ekr.20181029161420.61"><vh>check_response (handshake.py)</vh></v>
<v t="ekr.20181029161420.62"><vh>accept (handshake.py)</vh></v>
</v>
<v t="ekr.20181029161420.63"><vh>@@clean headers.py</vh>
<v t="ekr.20181029161420.64"><vh>Declarations (headers.py)</vh></v>
<v t="ekr.20181029161420.65"><vh>peek_ahead (headers.py)</vh></v>
<v t="ekr.20181029161420.66"><vh>parse_OWS (headers.py)</vh></v>
<v t="ekr.20181029161420.67"><vh>parse_token (headers.py)</vh></v>
<v t="ekr.20181029161420.68"><vh>parse_quoted_string (headers.py)</vh></v>
<v t="ekr.20181029161420.69"><vh>parse_list (headers.py)</vh></v>
<v t="ekr.20181029161420.70"><vh>parse_connection (headers.py)</vh></v>
<v t="ekr.20181029161420.71"><vh>parse_protocol (headers.py)</vh></v>
<v t="ekr.20181029161420.72"><vh>parse_upgrade (headers.py)</vh></v>
<v t="ekr.20181029161420.73"><vh>parse_extension_param (headers.py)</vh></v>
<v t="ekr.20181029161420.74"><vh>parse_extension (headers.py)</vh></v>
<v t="ekr.20181029161420.75"><vh>parse_extension_list (headers.py)</vh></v>
<v t="ekr.20181029161420.76"><vh>build_extension (headers.py)</vh></v>
<v t="ekr.20181029161420.77"><vh>build_extension_list (headers.py)</vh></v>
<v t="ekr.20181029161420.78"><vh>parse_subprotocol_list (headers.py)</vh></v>
<v t="ekr.20181029161420.79"><vh>build_subprotocol_list (headers.py)</vh></v>
<v t="ekr.20181029161420.80"><vh>build_basic_auth (headers.py)</vh></v>
</v>
<v t="ekr.20181029161420.81"><vh>@@clean http.py</vh>
<v t="ekr.20181029161420.82"><vh>Declarations (http.py)</vh></v>
<v t="ekr.20181029161420.83"><vh>read_request (http.py)</vh></v>
<v t="ekr.20181029161420.84"><vh>read_response (http.py)</vh></v>
<v t="ekr.20181029161420.85"><vh>read_headers (http.py)</vh></v>
<v t="ekr.20181029161420.86"><vh>read_line (http.py)</vh></v>
<v t="ekr.20181029161420.87"><vh>class MultipleValuesError(LookupError)</vh>
<v t="ekr.20181029161420.88"><vh>MultipleValuesError(LookupError).__str__</vh></v>
</v>
<v t="ekr.20181029161420.89"><vh>class Headers(collections.abc.MutableMapping)</vh>
<v t="ekr.20181029161420.90"><vh>Headers(collections.abc.MutableMapping).__init__</vh></v>
<v t="ekr.20181029161420.91"><vh>Headers(collections.abc.MutableMapping).__str__</vh></v>
<v t="ekr.20181029161420.92"><vh>Headers(collections.abc.MutableMapping).__repr__</vh></v>
<v t="ekr.20181029161420.93"><vh>Headers(collections.abc.MutableMapping).copy</vh></v>
<v t="ekr.20181029161420.94"><vh>Headers(collections.abc.MutableMapping).__contains__</vh></v>
<v t="ekr.20181029161420.95"><vh>Headers(collections.abc.MutableMapping).__iter__</vh></v>
<v t="ekr.20181029161420.96"><vh>Headers(collections.abc.MutableMapping).__len__</vh></v>
<v t="ekr.20181029161420.97"><vh>Headers(collections.abc.MutableMapping).__getitem__</vh></v>
<v t="ekr.20181029161420.98"><vh>Headers(collections.abc.MutableMapping).__setitem__</vh></v>
<v t="ekr.20181029161420.99"><vh>Headers(collections.abc.MutableMapping).__delitem__</vh></v>
<v t="ekr.20181029161420.100"><vh>Headers(collections.abc.MutableMapping).__eq__</vh></v>
<v t="ekr.20181029161420.101"><vh>Headers(collections.abc.MutableMapping).clear</vh></v>
<v t="ekr.20181029161420.102"><vh>Headers(collections.abc.MutableMapping).get_all</vh></v>
<v t="ekr.20181029161420.103"><vh>Headers(collections.abc.MutableMapping).raw_items</vh></v>
</v>
</v>
<v t="ekr.20181029161420.104"><vh>@@clean protocol.py</vh>
<v t="ekr.20181029161420.105"><vh>Declarations (protocol.py)</vh></v>
<v t="ekr.20181029161420.106"><vh>class State(enum.IntEnum)</vh></v>
<v t="ekr.20181029161420.107"><vh>class WebSocketCommonProtocol(asyncio.StreamReaderProtocol)</vh>
<v t="ekr.20181029161420.108"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).__init__</vh></v>
<v t="ekr.20181029161420.109"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).client_connected</vh></v>
<v t="ekr.20181029161420.110"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).connection_open</vh></v>
<v t="ekr.20181029161420.111"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).local_address</vh></v>
<v t="ekr.20181029161420.112"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).remote_address</vh></v>
<v t="ekr.20181029161420.113"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).open</vh></v>
<v t="ekr.20181029161420.114"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).closed</vh></v>
<v t="ekr.20181029161420.115"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).recv</vh></v>
<v t="ekr.20181029161420.116"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).send</vh></v>
<v t="ekr.20181029161420.117"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).close</vh></v>
<v t="ekr.20181029161420.118"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).ping</vh></v>
<v t="ekr.20181029161420.119"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).pong</vh></v>
<v t="ekr.20181029161420.120"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).ensure_open</vh></v>
<v t="ekr.20181029161420.121"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).transfer_data</vh></v>
<v t="ekr.20181029161420.122"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).read_message</vh></v>
<v t="ekr.20181029161420.123"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).read_data_frame</vh></v>
<v t="ekr.20181029161420.124"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).read_frame</vh></v>
<v t="ekr.20181029161420.125"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).write_frame</vh></v>
<v t="ekr.20181029161420.126"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).writer_is_closing</vh></v>
<v t="ekr.20181029161420.127"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).write_close_frame</vh></v>
<v t="ekr.20181029161420.128"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).close_connection</vh></v>
<v t="ekr.20181029161420.129"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).wait_for_connection_lost</vh></v>
<v t="ekr.20181029161420.130"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).fail_connection</vh></v>
<v t="ekr.20181029161420.131"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).connection_made</vh></v>
<v t="ekr.20181029161420.132"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).eof_received</vh></v>
<v t="ekr.20181029161420.133"><vh>WebSocketCommonProtocol(asyncio.StreamReaderProtocol).connection_lost</vh></v>
</v>
</v>
<v t="ekr.20181029161420.134"><vh>@@clean server.py</vh>
<v t="ekr.20181029161420.135"><vh>Declarations (server.py)</vh></v>
<v t="ekr.20181029161420.136"><vh>class WebSocketServerProtocol(WebSocketCommonProtocol)</vh>
<v t="ekr.20181029161420.137"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).__init__</vh></v>
<v t="ekr.20181029161420.138"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).connection_made</vh></v>
<v t="ekr.20181029161420.139"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).handler</vh></v>
<v t="ekr.20181029161420.140"><vh>WebSocketServerProtocol(WebSocketCommonProtocol)._is_server_shutting_down</vh></v>
<v t="ekr.20181029161420.141"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).read_http_request</vh></v>
<v t="ekr.20181029161420.142"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).write_http_response</vh></v>
<v t="ekr.20181029161420.143"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).process_request</vh></v>
<v t="ekr.20181029161420.144"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).process_origin</vh></v>
<v t="ekr.20181029161420.145"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).process_extensions</vh></v>
<v t="ekr.20181029161420.146"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).process_subprotocol</vh></v>
<v t="ekr.20181029161420.147"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).select_subprotocol</vh></v>
<v t="ekr.20181029161420.148"><vh>WebSocketServerProtocol(WebSocketCommonProtocol).handshake</vh></v>
</v>
<v t="ekr.20181029161420.149"><vh>class WebSocketServer</vh>
<v t="ekr.20181029161420.150"><vh>WebSocketServer.__init__</vh></v>
<v t="ekr.20181029161420.151"><vh>WebSocketServer.wrap</vh></v>
<v t="ekr.20181029161420.152"><vh>WebSocketServer.register</vh></v>
<v t="ekr.20181029161420.153"><vh>WebSocketServer.unregister</vh></v>
<v t="ekr.20181029161420.154"><vh>WebSocketServer.close</vh></v>
<v t="ekr.20181029161420.155"><vh>WebSocketServer.wait_closed</vh></v>
<v t="ekr.20181029161420.156"><vh>WebSocketServer.sockets</vh></v>
</v>
<v t="ekr.20181029161420.157"><vh>class Serve</vh>
<v t="ekr.20181029161420.158"><vh>Serve.__init__</vh></v>
<v t="ekr.20181029161420.159"><vh>Serve.__iter__</vh></v>
</v>
<v t="ekr.20181029161420.160"><vh>unix_serve (server.py)</vh></v>
</v>
<v t="ekr.20181029161420.161"><vh>test_*.py</vh>
<v t="ekr.20181029161420.162"><vh>@@clean test_client_server.py</vh>
<v t="ekr.20181029161420.163"><vh>Declarations (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.164"><vh>handler (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.165"><vh>temp_test_server (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.166"><vh>temp_test_client (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.167"><vh>with_manager (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.168"><vh>with_server (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.169"><vh>with_client (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.170"><vh>get_server_uri (test_client_server.py)</vh></v>
<v t="ekr.20181029161420.171"><vh>class UnauthorizedServerProtocol(WebSocketServerProtocol)</vh>
<v t="ekr.20181029161420.172"><vh>UnauthorizedServerProtocol(WebSocketServerProtocol).process_request</vh></v>
</v>
<v t="ekr.20181029161420.173"><vh>class ForbiddenServerProtocol(WebSocketServerProtocol)</vh>
<v t="ekr.20181029161420.174"><vh>ForbiddenServerProtocol(WebSocketServerProtocol).process_request</vh></v>
</v>
<v t="ekr.20181029161420.175"><vh>class HealthCheckServerProtocol(WebSocketServerProtocol)</vh>
<v t="ekr.20181029161420.176"><vh>HealthCheckServerProtocol(WebSocketServerProtocol).process_request</vh></v>
</v>
<v t="ekr.20181029161420.177"><vh>class FooClientProtocol(WebSocketClientProtocol)</vh></v>
<v t="ekr.20181029161420.178"><vh>class BarClientProtocol(WebSocketClientProtocol)</vh></v>
<v t="ekr.20181029161420.179"><vh>class ClientNoOpExtensionFactory</vh>
<v t="ekr.20181029161420.180"><vh>ClientNoOpExtensionFactory.get_request_params</vh></v>
<v t="ekr.20181029161420.181"><vh>ClientNoOpExtensionFactory.process_response_params</vh></v>
</v>
<v t="ekr.20181029161420.182"><vh>class ServerNoOpExtensionFactory</vh>
<v t="ekr.20181029161420.183"><vh>ServerNoOpExtensionFactory.__init__</vh></v>
<v t="ekr.20181029161420.184"><vh>ServerNoOpExtensionFactory.process_request_params</vh></v>
</v>
<v t="ekr.20181029161420.185"><vh>class NoOpExtension</vh>
<v t="ekr.20181029161420.186"><vh>NoOpExtension.__repr__</vh></v>
<v t="ekr.20181029161420.187"><vh>NoOpExtension.decode</vh></v>
<v t="ekr.20181029161420.188"><vh>NoOpExtension.encode</vh></v>
</v>
<v t="ekr.20181029161420.189"><vh>class ClientServerTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.190"><vh>ClientServerTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.191"><vh>ClientServerTests(unittest.TestCase).tearDown</vh></v>
<v t="ekr.20181029161420.192"><vh>ClientServerTests(unittest.TestCase).run_loop_once</vh></v>
<v t="ekr.20181029161420.193"><vh>ClientServerTests(unittest.TestCase).start_server</vh></v>
<v t="ekr.20181029161420.194"><vh>ClientServerTests(unittest.TestCase).start_client</vh></v>
<v t="ekr.20181029161420.195"><vh>ClientServerTests(unittest.TestCase).stop_client</vh></v>
<v t="ekr.20181029161420.196"><vh>ClientServerTests(unittest.TestCase).stop_server</vh></v>
<v t="ekr.20181029161420.197"><vh>ClientServerTests(unittest.TestCase).temp_server</vh></v>
<v t="ekr.20181029161420.198"><vh>ClientServerTests(unittest.TestCase).temp_client</vh></v>
<v t="ekr.20181029161420.199"><vh>ClientServerTests(unittest.TestCase).test_basic</vh></v>
<v t="ekr.20181029161420.200"><vh>ClientServerTests(unittest.TestCase).test_server_close_while_client_connected</vh></v>
<v t="ekr.20181029161420.201"><vh>ClientServerTests(unittest.TestCase).test_explicit_event_loop</vh></v>
<v t="ekr.20181029161420.202"><vh>ClientServerTests(unittest.TestCase).test_explicit_socket</vh></v>
<v t="ekr.20181029161420.203"><vh>ClientServerTests(unittest.TestCase).test_unix_socket</vh></v>
<v t="ekr.20181029161420.204"><vh>ClientServerTests(unittest.TestCase).test_protocol_attributes</vh></v>
<v t="ekr.20181029161420.205"><vh>ClientServerTests(unittest.TestCase).test_protocol_path</vh></v>
<v t="ekr.20181029161420.206"><vh>ClientServerTests(unittest.TestCase).test_protocol_basic_auth</vh></v>
<v t="ekr.20181029161420.207"><vh>ClientServerTests(unittest.TestCase).test_protocol_headers</vh></v>
<v t="ekr.20181029161420.208"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_request_headers</vh></v>
<v t="ekr.20181029161420.209"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_request_headers_dict</vh></v>
<v t="ekr.20181029161420.210"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_request_headers_list</vh></v>
<v t="ekr.20181029161420.211"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_request_user_agent</vh></v>
<v t="ekr.20181029161420.212"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers_callable</vh></v>
<v t="ekr.20181029161420.213"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers_callable_dict</vh></v>
<v t="ekr.20181029161420.214"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers_callable_list</vh></v>
<v t="ekr.20181029161420.215"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers</vh></v>
<v t="ekr.20181029161420.216"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers_dict</vh></v>
<v t="ekr.20181029161420.217"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_headers_list</vh></v>
<v t="ekr.20181029161420.218"><vh>ClientServerTests(unittest.TestCase).test_protocol_custom_response_user_agent</vh></v>
<v t="ekr.20181029161420.219"><vh>ClientServerTests(unittest.TestCase).make_http_request</vh></v>
<v t="ekr.20181029161420.220"><vh>ClientServerTests(unittest.TestCase).test_http_request_http_endpoint</vh></v>
<v t="ekr.20181029161420.221"><vh>ClientServerTests(unittest.TestCase).test_http_request_ws_endpoint</vh></v>
<v t="ekr.20181029161420.222"><vh>ClientServerTests(unittest.TestCase).test_ws_connection_http_endpoint</vh></v>
<v t="ekr.20181029161420.223"><vh>ClientServerTests(unittest.TestCase).test_ws_connection_ws_endpoint</vh></v>
<v t="ekr.20181029161420.224"><vh>ClientServerTests(unittest.TestCase).assert_client_raises_code</vh></v>
<v t="ekr.20181029161420.225"><vh>ClientServerTests(unittest.TestCase).test_server_create_protocol</vh></v>
<v t="ekr.20181029161420.226"><vh>ClientServerTests(unittest.TestCase).test_server_create_protocol_function</vh></v>
<v t="ekr.20181029161420.227"><vh>ClientServerTests(unittest.TestCase).test_server_klass</vh></v>
<v t="ekr.20181029161420.228"><vh>ClientServerTests(unittest.TestCase).test_server_create_protocol_over_klass</vh></v>
<v t="ekr.20181029161420.229"><vh>ClientServerTests(unittest.TestCase).test_client_create_protocol</vh></v>
<v t="ekr.20181029161420.230"><vh>ClientServerTests(unittest.TestCase).test_client_create_protocol_function</vh></v>
<v t="ekr.20181029161420.231"><vh>ClientServerTests(unittest.TestCase).test_client_klass</vh></v>
<v t="ekr.20181029161420.232"><vh>ClientServerTests(unittest.TestCase).test_client_create_protocol_over_klass</vh></v>
<v t="ekr.20181029161420.233"><vh>ClientServerTests(unittest.TestCase).test_no_extension</vh></v>
<v t="ekr.20181029161420.234"><vh>ClientServerTests(unittest.TestCase).test_extension</vh></v>
<v t="ekr.20181029161420.235"><vh>ClientServerTests(unittest.TestCase).test_extension_not_accepted</vh></v>
<v t="ekr.20181029161420.236"><vh>ClientServerTests(unittest.TestCase).test_extension_not_requested</vh></v>
<v t="ekr.20181029161420.237"><vh>ClientServerTests(unittest.TestCase).test_extension_client_rejection</vh></v>
<v t="ekr.20181029161420.238"><vh>ClientServerTests(unittest.TestCase).test_extension_no_match_then_match</vh></v>
<v t="ekr.20181029161420.239"><vh>ClientServerTests(unittest.TestCase).test_extension_mismatch</vh></v>
<v t="ekr.20181029161420.240"><vh>ClientServerTests(unittest.TestCase).test_extension_order</vh></v>
<v t="ekr.20181029161420.241"><vh>ClientServerTests(unittest.TestCase).test_extensions_error</vh></v>
<v t="ekr.20181029161420.242"><vh>ClientServerTests(unittest.TestCase).test_extensions_error_no_extensions</vh></v>
<v t="ekr.20181029161420.243"><vh>ClientServerTests(unittest.TestCase).test_compression_deflate</vh></v>
<v t="ekr.20181029161420.244"><vh>ClientServerTests(unittest.TestCase).test_compression_deflate_and_explicit_config</vh></v>
<v t="ekr.20181029161420.245"><vh>ClientServerTests(unittest.TestCase).test_compression_unsupported_server</vh></v>
<v t="ekr.20181029161420.246"><vh>ClientServerTests(unittest.TestCase).test_compression_unsupported_client</vh></v>
<v t="ekr.20181029161420.247"><vh>ClientServerTests(unittest.TestCase).test_no_subprotocol</vh></v>
<v t="ekr.20181029161420.248"><vh>ClientServerTests(unittest.TestCase).test_subprotocol</vh></v>
<v t="ekr.20181029161420.249"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_not_accepted</vh></v>
<v t="ekr.20181029161420.250"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_not_offered</vh></v>
<v t="ekr.20181029161420.251"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_not_requested</vh></v>
<v t="ekr.20181029161420.252"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_error</vh></v>
<v t="ekr.20181029161420.253"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_error_no_subprotocols</vh></v>
<v t="ekr.20181029161420.254"><vh>ClientServerTests(unittest.TestCase).test_subprotocol_error_two_subprotocols</vh></v>
<v t="ekr.20181029161420.255"><vh>ClientServerTests(unittest.TestCase).test_server_receives_malformed_request</vh></v>
<v t="ekr.20181029161420.256"><vh>ClientServerTests(unittest.TestCase).test_client_receives_malformed_response</vh></v>
<v t="ekr.20181029161420.257"><vh>ClientServerTests(unittest.TestCase).test_client_sends_invalid_handshake_request</vh></v>
<v t="ekr.20181029161420.258"><vh>ClientServerTests(unittest.TestCase).test_server_sends_invalid_handshake_response</vh></v>
<v t="ekr.20181029161420.259"><vh>ClientServerTests(unittest.TestCase).test_server_does_not_switch_protocols</vh></v>
<v t="ekr.20181029161420.260"><vh>ClientServerTests(unittest.TestCase).test_server_error_in_handshake</vh></v>
<v t="ekr.20181029161420.261"><vh>ClientServerTests(unittest.TestCase).test_server_handler_crashes</vh></v>
<v t="ekr.20181029161420.262"><vh>ClientServerTests(unittest.TestCase).test_server_close_crashes</vh></v>
<v t="ekr.20181029161420.263"><vh>ClientServerTests(unittest.TestCase).test_client_closes_connection_before_handshake</vh></v>
<v t="ekr.20181029161420.264"><vh>ClientServerTests(unittest.TestCase).test_server_shuts_down_during_opening_handshake</vh></v>
<v t="ekr.20181029161420.265"><vh>ClientServerTests(unittest.TestCase).test_server_shuts_down_during_connection_handling</vh></v>
<v t="ekr.20181029161420.266"><vh>ClientServerTests(unittest.TestCase).test_server_shuts_down_during_connection_close</vh></v>
<v t="ekr.20181029161420.267"><vh>ClientServerTests(unittest.TestCase).test_invalid_status_error_during_client_connect</vh></v>
<v t="ekr.20181029161420.268"><vh>ClientServerTests(unittest.TestCase).test_connection_error_during_opening_handshake</vh></v>
<v t="ekr.20181029161420.269"><vh>ClientServerTests(unittest.TestCase).test_connection_error_during_closing_handshake</vh></v>
</v>
<v t="ekr.20181029161420.270"><vh>class SSLClientServerTests(ClientServerTests)</vh>
<v t="ekr.20181029161420.271"><vh>SSLClientServerTests(ClientServerTests).server_context</vh></v>
<v t="ekr.20181029161420.272"><vh>SSLClientServerTests(ClientServerTests).client_context</vh></v>
<v t="ekr.20181029161420.273"><vh>SSLClientServerTests(ClientServerTests).start_server</vh></v>
<v t="ekr.20181029161420.274"><vh>SSLClientServerTests(ClientServerTests).start_client</vh></v>
<v t="ekr.20181029161420.275"><vh>SSLClientServerTests(ClientServerTests).test_ws_uri_is_rejected</vh></v>
</v>
<v t="ekr.20181029161420.276"><vh>class ClientServerOriginTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.277"><vh>ClientServerOriginTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.278"><vh>ClientServerOriginTests(unittest.TestCase).tearDown</vh></v>
<v t="ekr.20181029161420.279"><vh>ClientServerOriginTests(unittest.TestCase).test_checking_origin_succeeds</vh></v>
<v t="ekr.20181029161420.280"><vh>ClientServerOriginTests(unittest.TestCase).test_checking_origin_fails</vh></v>
<v t="ekr.20181029161420.281"><vh>ClientServerOriginTests(unittest.TestCase).test_checking_lack_of_origin_succeeds</vh></v>
</v>
<v t="ekr.20181029161420.282"><vh>class YieldFromTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.283"><vh>YieldFromTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.284"><vh>YieldFromTests(unittest.TestCase).tearDown</vh></v>
<v t="ekr.20181029161420.285"><vh>YieldFromTests(unittest.TestCase).test_client</vh></v>
<v t="ekr.20181029161420.286"><vh>YieldFromTests(unittest.TestCase).test_server</vh></v>
</v>
</v>
<v t="ekr.20181029161420.287"><vh>@@clean test_exceptions.py</vh>
<v t="ekr.20181029161420.288"><vh>Declarations (test_exceptions.py)</vh></v>
<v t="ekr.20181029161420.289"><vh>class ExceptionsTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.290"><vh>ExceptionsTests(unittest.TestCase).test_str</vh></v>
</v>
</v>
<v t="ekr.20181029161420.291"><vh>@@clean test_framing.py</vh>
<v t="ekr.20181029161420.292"><vh>Declarations (test_framing.py)</vh></v>
<v t="ekr.20181029161420.293"><vh>class FramingTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.294"><vh>FramingTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.295"><vh>FramingTests(unittest.TestCase).tearDown</vh></v>
<v t="ekr.20181029161420.296"><vh>FramingTests(unittest.TestCase).decode</vh></v>
<v t="ekr.20181029161420.297"><vh>FramingTests(unittest.TestCase).encode</vh></v>
<v t="ekr.20181029161420.298"><vh>FramingTests(unittest.TestCase).round_trip</vh></v>
<v t="ekr.20181029161420.299"><vh>FramingTests(unittest.TestCase).round_trip_close</vh></v>
<v t="ekr.20181029161420.300"><vh>FramingTests(unittest.TestCase).test_text</vh></v>
<v t="ekr.20181029161420.301"><vh>FramingTests(unittest.TestCase).test_text_masked</vh></v>
<v t="ekr.20181029161420.302"><vh>FramingTests(unittest.TestCase).test_binary</vh></v>
<v t="ekr.20181029161420.303"><vh>FramingTests(unittest.TestCase).test_binary_masked</vh></v>
<v t="ekr.20181029161420.304"><vh>FramingTests(unittest.TestCase).test_non_ascii_text</vh></v>
<v t="ekr.20181029161420.305"><vh>FramingTests(unittest.TestCase).test_non_ascii_text_masked</vh></v>
<v t="ekr.20181029161420.306"><vh>FramingTests(unittest.TestCase).test_close</vh></v>
<v t="ekr.20181029161420.307"><vh>FramingTests(unittest.TestCase).test_ping</vh></v>
<v t="ekr.20181029161420.308"><vh>FramingTests(unittest.TestCase).test_pong</vh></v>
<v t="ekr.20181029161420.309"><vh>FramingTests(unittest.TestCase).test_long</vh></v>
<v t="ekr.20181029161420.310"><vh>FramingTests(unittest.TestCase).test_very_long</vh></v>
<v t="ekr.20181029161420.311"><vh>FramingTests(unittest.TestCase).test_payload_too_big</vh></v>
<v t="ekr.20181029161420.312"><vh>FramingTests(unittest.TestCase).test_bad_reserved_bits</vh></v>
<v t="ekr.20181029161420.313"><vh>FramingTests(unittest.TestCase).test_good_opcode</vh></v>
<v t="ekr.20181029161420.314"><vh>FramingTests(unittest.TestCase).test_bad_opcode</vh></v>
<v t="ekr.20181029161420.315"><vh>FramingTests(unittest.TestCase).test_mask_flag</vh></v>
<v t="ekr.20181029161420.316"><vh>FramingTests(unittest.TestCase).test_control_frame_max_length</vh></v>
<v t="ekr.20181029161420.317"><vh>FramingTests(unittest.TestCase).test_encode_data_str</vh></v>
<v t="ekr.20181029161420.318"><vh>FramingTests(unittest.TestCase).test_encode_data_bytes</vh></v>
<v t="ekr.20181029161420.319"><vh>FramingTests(unittest.TestCase).test_encode_data_other</vh></v>
<v t="ekr.20181029161420.320"><vh>FramingTests(unittest.TestCase).test_fragmented_control_frame</vh></v>
<v t="ekr.20181029161420.321"><vh>FramingTests(unittest.TestCase).test_parse_close_and_serialize_close</vh></v>
<v t="ekr.20181029161420.322"><vh>FramingTests(unittest.TestCase).test_parse_close_empty</vh></v>
<v t="ekr.20181029161420.323"><vh>FramingTests(unittest.TestCase).test_parse_close_errors</vh></v>
<v t="ekr.20181029161420.324"><vh>FramingTests(unittest.TestCase).test_serialize_close_errors</vh></v>
<v t="ekr.20181029161420.325"><vh>FramingTests(unittest.TestCase).test_extensions</vh></v>
</v>
</v>
<v t="ekr.20181029161420.326"><vh>@@clean test_handshake.py</vh>
<v t="ekr.20181029161420.327"><vh>Declarations (test_handshake.py)</vh></v>
<v t="ekr.20181029161420.328"><vh>class HandshakeTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.329"><vh>HandshakeTests(unittest.TestCase).test_accept</vh></v>
<v t="ekr.20181029161420.330"><vh>HandshakeTests(unittest.TestCase).test_round_trip</vh></v>
<v t="ekr.20181029161420.331"><vh>HandshakeTests(unittest.TestCase).assertInvalidRequestHeaders</vh></v>
<v t="ekr.20181029161420.332"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_upgrade</vh></v>
<v t="ekr.20181029161420.333"><vh>HandshakeTests(unittest.TestCase).test_request_missing_upgrade</vh></v>
<v t="ekr.20181029161420.334"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_connection</vh></v>
<v t="ekr.20181029161420.335"><vh>HandshakeTests(unittest.TestCase).test_request_missing_connection</vh></v>
<v t="ekr.20181029161420.336"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_key_not_base64</vh></v>
<v t="ekr.20181029161420.337"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_key_not_well_padded</vh></v>
<v t="ekr.20181029161420.338"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_key_not_16_bytes_long</vh></v>
<v t="ekr.20181029161420.339"><vh>HandshakeTests(unittest.TestCase).test_request_missing_key</vh></v>
<v t="ekr.20181029161420.340"><vh>HandshakeTests(unittest.TestCase).test_request_invalid_version</vh></v>
<v t="ekr.20181029161420.341"><vh>HandshakeTests(unittest.TestCase).test_request_missing_version</vh></v>
<v t="ekr.20181029161420.342"><vh>HandshakeTests(unittest.TestCase).assertInvalidResponseHeaders</vh></v>
<v t="ekr.20181029161420.343"><vh>HandshakeTests(unittest.TestCase).test_response_invalid_upgrade</vh></v>
<v t="ekr.20181029161420.344"><vh>HandshakeTests(unittest.TestCase).test_response_missing_upgrade</vh></v>
<v t="ekr.20181029161420.345"><vh>HandshakeTests(unittest.TestCase).test_response_invalid_connection</vh></v>
<v t="ekr.20181029161420.346"><vh>HandshakeTests(unittest.TestCase).test_response_missing_connection</vh></v>
<v t="ekr.20181029161420.347"><vh>HandshakeTests(unittest.TestCase).test_response_invalid_accept</vh></v>
<v t="ekr.20181029161420.348"><vh>HandshakeTests(unittest.TestCase).test_response_missing_accept</vh></v>
</v>
</v>
<v t="ekr.20181029161420.349"><vh>@@clean test_headers.py</vh>
<v t="ekr.20181029161420.350"><vh>Declarations (test_headers.py)</vh></v>
<v t="ekr.20181029161420.351"><vh>class HeadersTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.352"><vh>HeadersTests(unittest.TestCase).test_parse_connection</vh></v>
<v t="ekr.20181029161420.353"><vh>HeadersTests(unittest.TestCase).test_parse_connection_invalid_header</vh></v>
<v t="ekr.20181029161420.354"><vh>HeadersTests(unittest.TestCase).test_parse_upgrade</vh></v>
<v t="ekr.20181029161420.355"><vh>HeadersTests(unittest.TestCase).test_parse_upgrade_invalid_header</vh></v>
<v t="ekr.20181029161420.356"><vh>HeadersTests(unittest.TestCase).test_parse_extension_list</vh></v>
<v t="ekr.20181029161420.357"><vh>HeadersTests(unittest.TestCase).test_parse_extension_list_invalid_header</vh></v>
<v t="ekr.20181029161420.358"><vh>HeadersTests(unittest.TestCase).test_parse_subprotocol_list</vh></v>
<v t="ekr.20181029161420.359"><vh>HeadersTests(unittest.TestCase).test_parse_subprotocol_list_invalid_header</vh></v>
<v t="ekr.20181029161420.360"><vh>HeadersTests(unittest.TestCase).test_build_basic_auth</vh></v>
</v>
</v>
<v t="ekr.20181029161420.361"><vh>@@clean test_http.py</vh>
<v t="ekr.20181029161420.362"><vh>Declarations (test_http.py)</vh></v>
<v t="ekr.20181029161420.363"><vh>class HTTPAsyncTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.364"><vh>HTTPAsyncTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.365"><vh>HTTPAsyncTests(unittest.TestCase).tearDown</vh></v>
<v t="ekr.20181029161420.366"><vh>HTTPAsyncTests(unittest.TestCase).test_read_request</vh></v>
<v t="ekr.20181029161420.367"><vh>HTTPAsyncTests(unittest.TestCase).test_read_response</vh></v>
<v t="ekr.20181029161420.368"><vh>HTTPAsyncTests(unittest.TestCase).test_request_method</vh></v>
<v t="ekr.20181029161420.369"><vh>HTTPAsyncTests(unittest.TestCase).test_request_version</vh></v>
<v t="ekr.20181029161420.370"><vh>HTTPAsyncTests(unittest.TestCase).test_response_version</vh></v>
<v t="ekr.20181029161420.371"><vh>HTTPAsyncTests(unittest.TestCase).test_response_status</vh></v>
<v t="ekr.20181029161420.372"><vh>HTTPAsyncTests(unittest.TestCase).test_response_reason</vh></v>
<v t="ekr.20181029161420.373"><vh>HTTPAsyncTests(unittest.TestCase).test_header_name</vh></v>
<v t="ekr.20181029161420.374"><vh>HTTPAsyncTests(unittest.TestCase).test_header_value</vh></v>
<v t="ekr.20181029161420.375"><vh>HTTPAsyncTests(unittest.TestCase).test_headers_limit</vh></v>
<v t="ekr.20181029161420.376"><vh>HTTPAsyncTests(unittest.TestCase).test_line_limit</vh></v>
<v t="ekr.20181029161420.377"><vh>HTTPAsyncTests(unittest.TestCase).test_line_ending</vh></v>
</v>
<v t="ekr.20181029161420.378"><vh>class HeadersTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.379"><vh>HeadersTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.380"><vh>HeadersTests(unittest.TestCase).test_str</vh></v>
<v t="ekr.20181029161420.381"><vh>HeadersTests(unittest.TestCase).test_repr</vh></v>
<v t="ekr.20181029161420.382"><vh>HeadersTests(unittest.TestCase).test_multiple_values_error_str</vh></v>
<v t="ekr.20181029161420.383"><vh>HeadersTests(unittest.TestCase).test_contains</vh></v>
<v t="ekr.20181029161420.384"><vh>HeadersTests(unittest.TestCase).test_contains_case_insensitive</vh></v>
<v t="ekr.20181029161420.385"><vh>HeadersTests(unittest.TestCase).test_contains_not_found</vh></v>
<v t="ekr.20181029161420.386"><vh>HeadersTests(unittest.TestCase).test_iter</vh></v>
<v t="ekr.20181029161420.387"><vh>HeadersTests(unittest.TestCase).test_len</vh></v>
<v t="ekr.20181029161420.388"><vh>HeadersTests(unittest.TestCase).test_getitem</vh></v>
<v t="ekr.20181029161420.389"><vh>HeadersTests(unittest.TestCase).test_getitem_case_insensitive</vh></v>
<v t="ekr.20181029161420.390"><vh>HeadersTests(unittest.TestCase).test_getitem_key_error</vh></v>
<v t="ekr.20181029161420.391"><vh>HeadersTests(unittest.TestCase).test_getitem_multiple_values_error</vh></v>
<v t="ekr.20181029161420.392"><vh>HeadersTests(unittest.TestCase).test_setitem</vh></v>
<v t="ekr.20181029161420.393"><vh>HeadersTests(unittest.TestCase).test_setitem_case_insensitive</vh></v>
<v t="ekr.20181029161420.394"><vh>HeadersTests(unittest.TestCase).test_setitem_multiple_values</vh></v>
<v t="ekr.20181029161420.395"><vh>HeadersTests(unittest.TestCase).test_delitem</vh></v>
<v t="ekr.20181029161420.396"><vh>HeadersTests(unittest.TestCase).test_delitem_case_insensitive</vh></v>
<v t="ekr.20181029161420.397"><vh>HeadersTests(unittest.TestCase).test_delitem_multiple_values</vh></v>
<v t="ekr.20181029161420.398"><vh>HeadersTests(unittest.TestCase).test_eq</vh></v>
<v t="ekr.20181029161420.399"><vh>HeadersTests(unittest.TestCase).test_eq_not_equal</vh></v>
<v t="ekr.20181029161420.400"><vh>HeadersTests(unittest.TestCase).test_clear</vh></v>
<v t="ekr.20181029161420.401"><vh>HeadersTests(unittest.TestCase).test_get_all</vh></v>
<v t="ekr.20181029161420.402"><vh>HeadersTests(unittest.TestCase).test_get_all_case_insensitive</vh></v>
<v t="ekr.20181029161420.403"><vh>HeadersTests(unittest.TestCase).test_get_all_no_values</vh></v>
<v t="ekr.20181029161420.404"><vh>HeadersTests(unittest.TestCase).test_get_all_multiple_values</vh></v>
<v t="ekr.20181029161420.405"><vh>HeadersTests(unittest.TestCase).test_raw_items</vh></v>
</v>
</v>
<v t="ekr.20181029161420.406"><vh>@@clean test_protocol.py</vh>
<v t="ekr.20181029161420.407"><vh>Declarations (test_protocol.py)</vh></v>
<v t="ekr.20181029161420.408"><vh>class TransportMock(unittest.mock.Mock)</vh>
<v t="ekr.20181029161420.409"><vh>TransportMock(unittest.mock.Mock).setup_mock</vh></v>
<v t="ekr.20181029161420.410"><vh>TransportMock(unittest.mock.Mock).can_write_eof</vh></v>
<v t="ekr.20181029161420.411"><vh>TransportMock(unittest.mock.Mock).write_eof</vh></v>
<v t="ekr.20181029161420.412"><vh>TransportMock(unittest.mock.Mock).is_closing</vh></v>
<v t="ekr.20181029161420.413"><vh>TransportMock(unittest.mock.Mock).close</vh></v>
<v t="ekr.20181029161420.414"><vh>TransportMock(unittest.mock.Mock).abort</vh></v>
</v>
<v t="ekr.20181029161420.415"><vh>class CommonTests</vh>
<v t="ekr.20181029161420.416"><vh>CommonTests.setUp</vh></v>
<v t="ekr.20181029161420.417"><vh>CommonTests.tearDown</vh></v>
<v t="ekr.20181029161420.418"><vh>CommonTests.run_loop_once</vh></v>
<v t="ekr.20181029161420.419"><vh>CommonTests.make_drain_slow</vh></v>
<v t="ekr.20181029161420.420"><vh>CommonTests.ensure_future</vh></v>
<v t="ekr.20181029161420.421"><vh>CommonTests.receive_frame</vh></v>
<v t="ekr.20181029161420.422"><vh>CommonTests.receive_eof</vh></v>
<v t="ekr.20181029161420.423"><vh>CommonTests.receive_eof_if_client</vh></v>
<v t="ekr.20181029161420.424"><vh>CommonTests.close_connection</vh></v>
<v t="ekr.20181029161420.425"><vh>CommonTests.half_close_connection_local</vh></v>
<v t="ekr.20181029161420.426"><vh>CommonTests.half_close_connection_remote</vh></v>
<v t="ekr.20181029161420.427"><vh>CommonTests.process_invalid_frames</vh></v>
<v t="ekr.20181029161420.428"><vh>CommonTests.last_sent_frame</vh></v>
<v t="ekr.20181029161420.429"><vh>CommonTests.assertOneFrameSent</vh></v>
<v t="ekr.20181029161420.430"><vh>CommonTests.assertNoFrameSent</vh></v>
<v t="ekr.20181029161420.431"><vh>CommonTests.assertConnectionClosed</vh></v>
<v t="ekr.20181029161420.432"><vh>CommonTests.assertConnectionFailed</vh></v>
<v t="ekr.20181029161420.433"><vh>CommonTests.assertCompletesWithin</vh></v>
<v t="ekr.20181029161420.434"><vh>CommonTests.test_local_address</vh></v>
<v t="ekr.20181029161420.435"><vh>CommonTests.test_local_address_before_connection</vh></v>
<v t="ekr.20181029161420.436"><vh>CommonTests.test_remote_address</vh></v>
<v t="ekr.20181029161420.437"><vh>CommonTests.test_remote_address_before_connection</vh></v>
<v t="ekr.20181029161420.438"><vh>CommonTests.test_open</vh></v>
<v t="ekr.20181029161420.439"><vh>CommonTests.test_closed</vh></v>
<v t="ekr.20181029161420.440"><vh>CommonTests.test_recv_text</vh></v>
<v t="ekr.20181029161420.441"><vh>CommonTests.test_recv_binary</vh></v>
<v t="ekr.20181029161420.442"><vh>CommonTests.test_recv_on_closing_connection_local</vh></v>
<v t="ekr.20181029161420.443"><vh>CommonTests.test_recv_on_closing_connection_remote</vh></v>
<v t="ekr.20181029161420.444"><vh>CommonTests.test_recv_on_closed_connection</vh></v>
<v t="ekr.20181029161420.445"><vh>CommonTests.test_recv_protocol_error</vh></v>
<v t="ekr.20181029161420.446"><vh>CommonTests.test_recv_unicode_error</vh></v>
<v t="ekr.20181029161420.447"><vh>CommonTests.test_recv_text_payload_too_big</vh></v>
<v t="ekr.20181029161420.448"><vh>CommonTests.test_recv_binary_payload_too_big</vh></v>
<v t="ekr.20181029161420.449"><vh>CommonTests.test_recv_text_no_max_size</vh></v>
<v t="ekr.20181029161420.450"><vh>CommonTests.test_recv_binary_no_max_size</vh></v>
<v t="ekr.20181029161420.451"><vh>CommonTests.test_recv_other_error</vh></v>
<v t="ekr.20181029161420.452"><vh>CommonTests.test_recv_cancelled</vh></v>
<v t="ekr.20181029161420.453"><vh>CommonTests.test_send_text</vh></v>
<v t="ekr.20181029161420.454"><vh>CommonTests.test_send_binary</vh></v>
<v t="ekr.20181029161420.455"><vh>CommonTests.test_send_type_error</vh></v>
<v t="ekr.20181029161420.456"><vh>CommonTests.test_send_on_closing_connection_local</vh></v>
<v t="ekr.20181029161420.457"><vh>CommonTests.test_send_on_closing_connection_remote</vh></v>
<v t="ekr.20181029161420.458"><vh>CommonTests.test_send_on_closed_connection</vh></v>
<v t="ekr.20181029161420.459"><vh>CommonTests.test_ping_default</vh></v>
<v t="ekr.20181029161420.460"><vh>CommonTests.test_ping_text</vh></v>
<v t="ekr.20181029161420.461"><vh>CommonTests.test_ping_binary</vh></v>
<v t="ekr.20181029161420.462"><vh>CommonTests.test_ping_type_error</vh></v>
<v t="ekr.20181029161420.463"><vh>CommonTests.test_ping_on_closing_connection_local</vh></v>
<v t="ekr.20181029161420.464"><vh>CommonTests.test_ping_on_closing_connection_remote</vh></v>
<v t="ekr.20181029161420.465"><vh>CommonTests.test_ping_on_closed_connection</vh></v>
<v t="ekr.20181029161420.466"><vh>CommonTests.test_pong_default</vh></v>
<v t="ekr.20181029161420.467"><vh>CommonTests.test_pong_text</vh></v>
<v t="ekr.20181029161420.468"><vh>CommonTests.test_pong_binary</vh></v>
<v t="ekr.20181029161420.469"><vh>CommonTests.test_pong_type_error</vh></v>
<v t="ekr.20181029161420.470"><vh>CommonTests.test_pong_on_closing_connection_local</vh></v>
<v t="ekr.20181029161420.471"><vh>CommonTests.test_pong_on_closing_connection_remote</vh></v>
<v t="ekr.20181029161420.472"><vh>CommonTests.test_pong_on_closed_connection</vh></v>
<v t="ekr.20181029161420.473"><vh>CommonTests.test_answer_ping</vh></v>
<v t="ekr.20181029161420.474"><vh>CommonTests.test_ignore_pong</vh></v>
<v t="ekr.20181029161420.475"><vh>CommonTests.test_acknowledge_ping</vh></v>
<v t="ekr.20181029161420.476"><vh>CommonTests.test_cancel_ping</vh></v>
<v t="ekr.20181029161420.477"><vh>CommonTests.test_acknowledge_previous_pings</vh></v>
<v t="ekr.20181029161420.478"><vh>CommonTests.test_cancelled_ping</vh></v>
<v t="ekr.20181029161420.479"><vh>CommonTests.test_duplicate_ping</vh></v>
<v t="ekr.20181029161420.480"><vh>CommonTests.test_fragmented_text</vh></v>
<v t="ekr.20181029161420.481"><vh>CommonTests.test_fragmented_binary</vh></v>
<v t="ekr.20181029161420.482"><vh>CommonTests.test_fragmented_text_payload_too_big</vh></v>
<v t="ekr.20181029161420.483"><vh>CommonTests.test_fragmented_binary_payload_too_big</vh></v>
<v t="ekr.20181029161420.484"><vh>CommonTests.test_fragmented_text_no_max_size</vh></v>
<v t="ekr.20181029161420.485"><vh>CommonTests.test_fragmented_binary_no_max_size</vh></v>
<v t="ekr.20181029161420.486"><vh>CommonTests.test_control_frame_within_fragmented_text</vh></v>
<v t="ekr.20181029161420.487"><vh>CommonTests.test_unterminated_fragmented_text</vh></v>
<v t="ekr.20181029161420.488"><vh>CommonTests.test_close_handshake_in_fragmented_text</vh></v>
<v t="ekr.20181029161420.489"><vh>CommonTests.test_connection_close_in_fragmented_text</vh></v>
<v t="ekr.20181029161420.490"><vh>CommonTests.test_connection_lost</vh></v>
<v t="ekr.20181029161420.491"><vh>CommonTests.test_ensure_open_before_opening_handshake</vh></v>
<v t="ekr.20181029161420.492"><vh>CommonTests.test_ensure_open_during_unclean_close</vh></v>
<v t="ekr.20181029161420.493"><vh>CommonTests.test_legacy_recv</vh></v>
<v t="ekr.20181029161420.494"><vh>CommonTests.test_connection_closed_attributes</vh></v>
<v t="ekr.20181029161420.495"><vh>CommonTests.test_local_close</vh></v>
<v t="ekr.20181029161420.496"><vh>CommonTests.test_remote_close</vh></v>
<v t="ekr.20181029161420.497"><vh>CommonTests.test_simultaneous_close</vh></v>
<v t="ekr.20181029161420.498"><vh>CommonTests.test_close_preserves_incoming_frames</vh></v>
<v t="ekr.20181029161420.499"><vh>CommonTests.test_close_protocol_error</vh></v>
<v t="ekr.20181029161420.500"><vh>CommonTests.test_close_connection_lost</vh></v>
<v t="ekr.20181029161420.501"><vh>CommonTests.test_local_close_during_recv</vh></v>
<v t="ekr.20181029161420.502"><vh>CommonTests.test_remote_close_during_send</vh></v>
</v>
<v t="ekr.20181029161420.503"><vh>class ServerTests</vh>
<v t="ekr.20181029161420.504"><vh>ServerTests.setUp</vh></v>
<v t="ekr.20181029161420.505"><vh>ServerTests.test_local_close_send_close_frame_timeout</vh></v>
<v t="ekr.20181029161420.506"><vh>ServerTests.test_local_close_receive_close_frame_timeout</vh></v>
<v t="ekr.20181029161420.507"><vh>ServerTests.test_local_close_connection_lost_timeout_after_write_eof</vh></v>
<v t="ekr.20181029161420.508"><vh>ServerTests.test_local_close_connection_lost_timeout_after_close</vh></v>
</v>
<v t="ekr.20181029161420.509"><vh>class ClientTests</vh>
<v t="ekr.20181029161420.510"><vh>ClientTests.setUp</vh></v>
<v t="ekr.20181029161420.511"><vh>ClientTests.test_local_close_send_close_frame_timeout</vh></v>
<v t="ekr.20181029161420.512"><vh>ClientTests.test_local_close_receive_close_frame_timeout</vh></v>
<v t="ekr.20181029161420.513"><vh>ClientTests.test_local_close_connection_lost_timeout_after_write_eof</vh></v>
<v t="ekr.20181029161420.514"><vh>ClientTests.test_local_close_connection_lost_timeout_after_close</vh></v>
</v>
</v>
<v t="ekr.20181029161420.515"><vh>@@clean test_speedups.py</vh></v>
<v t="ekr.20181029161420.516"><vh>@@clean test_uri.py</vh>
<v t="ekr.20181029161420.517"><vh>Declarations (test_uri.py)</vh></v>
<v t="ekr.20181029161420.518"><vh>class URITests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.519"><vh>URITests(unittest.TestCase).test_success</vh></v>
<v t="ekr.20181029161420.520"><vh>URITests(unittest.TestCase).test_error</vh></v>
</v>
</v>
<v t="ekr.20181029161420.521"><vh>@@clean test_utils.py</vh>
<v t="ekr.20181029161420.522"><vh>Declarations (test_utils.py)</vh></v>
<v t="ekr.20181029161420.523"><vh>class UtilsTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.524"><vh>UtilsTests(unittest.TestCase).apply_mask</vh></v>
<v t="ekr.20181029161420.525"><vh>UtilsTests(unittest.TestCase).test_apply_mask</vh></v>
<v t="ekr.20181029161420.526"><vh>UtilsTests(unittest.TestCase).test_apply_mask_check_input_types</vh></v>
<v t="ekr.20181029161420.527"><vh>UtilsTests(unittest.TestCase).test_apply_mask_check_mask_length</vh></v>
</v>
</v>
<v t="ekr.20181029161420.528"><vh>@@clean uri.py</vh>
<v t="ekr.20181029161420.529"><vh>Declarations (uri.py)</vh></v>
<v t="ekr.20181029161420.530"><vh>parse_uri (uri.py)</vh></v>
</v>
<v t="ekr.20181029161420.531"><vh>@@clean utils.py</vh>
<v t="ekr.20181029161420.532"><vh>Declarations (utils.py)</vh></v>
<v t="ekr.20181029161420.533"><vh>apply_mask (utils.py)</vh></v>
</v>
</v>
<v t="ekr.20181029161420.534"><vh>others...</vh>
<v t="ekr.20181029161420.535"><vh>@@clean version.py</vh></v>
<v t="ekr.20181029161420.536"><vh>@@clean __init__.py</vh>
<v t="ekr.20181029161420.537"><vh>Declarations (__init__.py)</vh></v>
</v>
<v t="ekr.20181029161420.538"><vh>@path extensions</vh>
<v t="ekr.20181029161420.539"><vh>@@clean base.py</vh>
<v t="ekr.20181029161420.540"><vh>Declarations (base.py)</vh></v>
<v t="ekr.20181029161420.541"><vh>class ClientExtensionFactory</vh>
<v t="ekr.20181029161420.542"><vh>ClientExtensionFactory.get_request_params</vh></v>
<v t="ekr.20181029161420.543"><vh>ClientExtensionFactory.process_response_params</vh></v>
</v>
<v t="ekr.20181029161420.544"><vh>class ServerExtensionFactory</vh>
<v t="ekr.20181029161420.545"><vh>ServerExtensionFactory.process_request_params</vh></v>
</v>
<v t="ekr.20181029161420.546"><vh>class Extension</vh>
<v t="ekr.20181029161420.547"><vh>Extension.decode</vh></v>
<v t="ekr.20181029161420.548"><vh>Extension.encode</vh></v>
</v>
</v>
<v t="ekr.20181029161420.549"><vh>@@clean permessage_deflate.py</vh>
<v t="ekr.20181029161420.550"><vh>Declarations (permessage_deflate.py)</vh></v>
<v t="ekr.20181029161420.551"><vh>_build_parameters (permessage_deflate.py)</vh></v>
<v t="ekr.20181029161420.552"><vh>_extract_parameters (permessage_deflate.py)</vh></v>
<v t="ekr.20181029161420.553"><vh>class ClientPerMessageDeflateFactory</vh>
<v t="ekr.20181029161420.554"><vh>ClientPerMessageDeflateFactory.__init__</vh></v>
<v t="ekr.20181029161420.555"><vh>ClientPerMessageDeflateFactory.get_request_params</vh></v>
<v t="ekr.20181029161420.556"><vh>ClientPerMessageDeflateFactory.process_response_params</vh></v>
</v>
<v t="ekr.20181029161420.557"><vh>class ServerPerMessageDeflateFactory</vh>
<v t="ekr.20181029161420.558"><vh>ServerPerMessageDeflateFactory.__init__</vh></v>
<v t="ekr.20181029161420.559"><vh>ServerPerMessageDeflateFactory.process_request_params</vh></v>
</v>
<v t="ekr.20181029161420.560"><vh>class PerMessageDeflate</vh>
<v t="ekr.20181029161420.561"><vh>PerMessageDeflate.__init__</vh></v>
<v t="ekr.20181029161420.562"><vh>PerMessageDeflate.__repr__</vh></v>
<v t="ekr.20181029161420.563"><vh>PerMessageDeflate.decode</vh></v>
<v t="ekr.20181029161420.564"><vh>PerMessageDeflate.encode</vh></v>
</v>
</v>
<v t="ekr.20181029161420.565"><vh>@@clean test_base.py</vh>
<v t="ekr.20181029161420.566"><vh>Declarations (test_base.py)</vh></v>
</v>
<v t="ekr.20181029161420.567"><vh>@@clean test_permessage_deflate.py</vh>
<v t="ekr.20181029161420.568"><vh>Declarations (test_permessage_deflate.py)</vh></v>
<v t="ekr.20181029161420.569"><vh>class ExtensionTestsMixin</vh>
<v t="ekr.20181029161420.570"><vh>ExtensionTestsMixin.assertExtensionEqual</vh></v>
</v>
<v t="ekr.20181029161420.571"><vh>class ClientPerMessageDeflateFactoryTests</vh>
<v t="ekr.20181029161420.572"><vh>ClientPerMessageDeflateFactoryTests.test_name</vh></v>
<v t="ekr.20181029161420.573"><vh>ClientPerMessageDeflateFactoryTests.test_init</vh></v>
<v t="ekr.20181029161420.574"><vh>ClientPerMessageDeflateFactoryTests.test_init_error</vh></v>
<v t="ekr.20181029161420.575"><vh>ClientPerMessageDeflateFactoryTests.test_get_request_params</vh></v>
<v t="ekr.20181029161420.576"><vh>ClientPerMessageDeflateFactoryTests.test_process_response_params</vh></v>
<v t="ekr.20181029161420.577"><vh>ClientPerMessageDeflateFactoryTests.test_process_response_params_deduplication</vh></v>
</v>
<v t="ekr.20181029161420.578"><vh>class ServerPerMessageDeflateFactoryTests</vh>
<v t="ekr.20181029161420.579"><vh>ServerPerMessageDeflateFactoryTests.test_name</vh></v>
<v t="ekr.20181029161420.580"><vh>ServerPerMessageDeflateFactoryTests.test_init</vh></v>
<v t="ekr.20181029161420.581"><vh>ServerPerMessageDeflateFactoryTests.test_init_error</vh></v>
<v t="ekr.20181029161420.582"><vh>ServerPerMessageDeflateFactoryTests.test_process_request_params</vh></v>
<v t="ekr.20181029161420.583"><vh>ServerPerMessageDeflateFactoryTests.test_process_response_params_deduplication</vh></v>
</v>
<v t="ekr.20181029161420.584"><vh>class PerMessageDeflateTests(unittest.TestCase)</vh>
<v t="ekr.20181029161420.585"><vh>PerMessageDeflateTests(unittest.TestCase).setUp</vh></v>
<v t="ekr.20181029161420.586"><vh>PerMessageDeflateTests(unittest.TestCase).test_name</vh></v>
<v t="ekr.20181029161420.587"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_encode_decode_ping_frame</vh></v>
<v t="ekr.20181029161420.588"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_encode_decode_pong_frame</vh></v>
<v t="ekr.20181029161420.589"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_encode_decode_close_frame</vh></v>
<v t="ekr.20181029161420.590"><vh>PerMessageDeflateTests(unittest.TestCase).test_encode_decode_text_frame</vh></v>
<v t="ekr.20181029161420.591"><vh>PerMessageDeflateTests(unittest.TestCase).test_encode_decode_binary_frame</vh></v>
<v t="ekr.20181029161420.592"><vh>PerMessageDeflateTests(unittest.TestCase).test_encode_decode_fragmented_text_frame</vh></v>
<v t="ekr.20181029161420.593"><vh>PerMessageDeflateTests(unittest.TestCase).test_encode_decode_fragmented_binary_frame</vh></v>
<v t="ekr.20181029161420.594"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_decode_text_frame</vh></v>
<v t="ekr.20181029161420.595"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_decode_binary_frame</vh></v>
<v t="ekr.20181029161420.596"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_decode_fragmented_text_frame</vh></v>
<v t="ekr.20181029161420.597"><vh>PerMessageDeflateTests(unittest.TestCase).test_no_decode_fragmented_binary_frame</vh></v>
<v t="ekr.20181029161420.598"><vh>PerMessageDeflateTests(unittest.TestCase).test_context_takeover</vh></v>
<v t="ekr.20181029161420.599"><vh>PerMessageDeflateTests(unittest.TestCase).test_remote_no_context_takeover</vh></v>
<v t="ekr.20181029161420.600"><vh>PerMessageDeflateTests(unittest.TestCase).test_local_no_context_takeover</vh></v>
<v t="ekr.20181029161420.601"><vh>PerMessageDeflateTests(unittest.TestCase).test_compress_settings</vh></v>
<v t="ekr.20181029161420.602"><vh>PerMessageDeflateTests(unittest.TestCase).test_decompress_max_size</vh></v>
</v>
</v>
<v t="ekr.20181029161420.603"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20181029161420.604"><vh>@@clean py36/protocol.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20181029161420.1"></t>
<t tx="ekr.20181029161420.10">@asyncio.coroutine
def handshake(self, wsuri, origin=None, available_extensions=None,
              available_subprotocols=None, extra_headers=None):
    """
    Perform the client side of the opening handshake.

    If provided, ``origin`` sets the Origin HTTP header.

    If provided, ``available_extensions`` is a list of supported
    extensions in the order in which they should be used.

    If provided, ``available_subprotocols`` is a list of supported
    subprotocols in order of decreasing preference.

    If provided, ``extra_headers`` sets additional HTTP request headers.
    It must be a :class:`~websockets.http.Headers` instance, a
    :class:`~collections.abc.Mapping`, or an iterable of ``(name, value)``
    pairs.

    Raise :exc:`~websockets.exceptions.InvalidHandshake` if the handshake
    fails.

    """
    request_headers = Headers()

    if wsuri.port == (443 if wsuri.secure else 80):     # pragma: no cover
        request_headers['Host'] = wsuri.host
    else:
        request_headers['Host'] = '{}:{}'.format(wsuri.host, wsuri.port)

    if wsuri.user_info:
        request_headers['Authorization'] = build_basic_auth(
            *wsuri.user_info)

    if origin is not None:
        request_headers['Origin'] = origin

    key = build_request(request_headers)

    if available_extensions is not None:
        extensions_header = build_extension_list([
            (
                extension_factory.name,
                extension_factory.get_request_params(),
            )
            for extension_factory in available_extensions
        ])
        request_headers['Sec-WebSocket-Extensions'] = extensions_header

    if available_subprotocols is not None:
        protocol_header = build_subprotocol_list(available_subprotocols)
        request_headers['Sec-WebSocket-Protocol'] = protocol_header

    if extra_headers is not None:
        if isinstance(extra_headers, Headers):
            extra_headers = extra_headers.raw_items()
        elif isinstance(extra_headers, collections.abc.Mapping):
            extra_headers = extra_headers.items()
        for name, value in extra_headers:
            request_headers[name] = value

    request_headers.setdefault('User-Agent', USER_AGENT)

    yield from self.write_http_request(
        wsuri.resource_name, request_headers)

    status_code, response_headers = yield from self.read_http_response()

    if status_code != 101:
        raise InvalidStatusCode(status_code)

    check_response(response_headers, key)

    self.extensions = self.process_extensions(
        response_headers, available_extensions)

    self.subprotocol = self.process_subprotocol(
        response_headers, available_subprotocols)

    self.connection_open()


</t>
<t tx="ekr.20181029161420.100">def __eq__(self, other):
    if not isinstance(other, Headers):
        return NotImplemented
    return self._list == other._list

</t>
<t tx="ekr.20181029161420.101">def clear(self):
    """
    Remove all headers.

    """
    self._dict = {}
    self._list = []

# Methods for handling multiple values

</t>
<t tx="ekr.20181029161420.102">def get_all(self, key):
    """
    Return the (possibly empty) list of all values for a header.

    """
    return self._dict.get(key.lower(), [])

</t>
<t tx="ekr.20181029161420.103">def raw_items(self):
    """
    Return an iterator of (header name, header value).

    """
    return iter(self._list)
</t>
<t tx="ekr.20181029161420.104">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.protocol` module handles WebSocket control and data
frames as specified in `sections 4 to 8 of RFC 6455`_.

.. _sections 4 to 8 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-4

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.105">import asyncio
import asyncio.queues
import binascii
import codecs
import collections
import enum
import logging
import random
import struct
import sys
import warnings

from .compatibility import asyncio_ensure_future
from .exceptions import (
    ConnectionClosed, InvalidState, PayloadTooBig, WebSocketProtocolError
)
from .framing import *
from .handshake import *


__all__ = ['WebSocketCommonProtocol']

logger = logging.getLogger(__name__)


# On Python  3.7, silence a deprecation warning that we can't address before
# dropping support for Python &lt; 3.5.
warnings.filterwarnings(
    action='ignore',
    message=r"'with \(yield from lock\)' is deprecated "
            r"use 'async with lock' instead",
    category=DeprecationWarning,
)


# A WebSocket connection goes through the following four states, in order:

</t>
<t tx="ekr.20181029161420.106">class State(enum.IntEnum):
    CONNECTING, OPEN, CLOSING, CLOSED = range(4)

# In order to ensure consistency, the code always checks the current value of
# WebSocketCommonProtocol.state before assigning a new value and never yields
# between the check and the assignment.


</t>
<t tx="ekr.20181029161420.107">class WebSocketCommonProtocol(asyncio.StreamReaderProtocol):
    """
    This class implements common parts of the WebSocket protocol.

    It assumes that the WebSocket connection is established. The handshake is
    managed in subclasses such as
    :class:`~websockets.server.WebSocketServerProtocol` and
    :class:`~websockets.client.WebSocketClientProtocol`.

    It runs a task that stores incoming data frames in a queue and deals with
    control frames automatically. It sends outgoing data frames and performs
    the closing handshake.

    On Python  3.6, :class:`WebSocketCommonProtocol` instances support
    asynchronous iteration::

        async for message in websocket:
            await process(message)

    The iterator yields incoming messages. It exits normally when the
    connection is closed with the status code 1000 (OK) or 1001 (going away).
    It raises a :exc:`~websockets.exceptions.ConnectionClosed` exception when
    the connection is closed with any other status code.

    The ``host``, ``port`` and ``secure`` parameters are simply stored as
    attributes for handlers that need them.

    The ``timeout`` parameter defines the maximum wait time in seconds for
    completing the closing handshake and, only on the client side, for
    terminating the TCP connection. :meth:`close()` will complete in at most
    ``4 * timeout`` on the server side and ``5 * timeout`` on the client side.

    The ``max_size`` parameter enforces the maximum size for incoming messages
    in bytes. The default value is 1MB. ``None`` disables the limit. If a
    message larger than the maximum size is received, :meth:`recv()` will
    raise :exc:`~websockets.exceptions.ConnectionClosed` and the connection
    will be closed with status code 1009.

    The ``max_queue`` parameter sets the maximum length of the queue that holds
    incoming messages. The default value is 32. 0 disables the limit. Messages
    are added to an in-memory queue when they're received; then :meth:`recv()`
    pops from that queue. In order to prevent excessive memory consumption when
    messages are received faster than they can be processed, the queue must be
    bounded. If the queue fills up, the protocol stops processing incoming data
    until :meth:`recv()` is called. In this situation, various receive buffers
    (at least in ``asyncio`` and in the OS) will fill up, then the TCP receive
    window will shrink, slowing down transmission to avoid packet loss.

    Since Python can use up to 4 bytes of memory to represent a single
    character, each websocket connection may use up to ``4 * max_size *
    max_queue`` bytes of memory to store incoming messages. By default,
    this is 128MB. You may want to lower the limits, depending on your
    application's requirements.

    The ``read_limit`` argument sets the high-water limit of the buffer for
    incoming bytes. The low-water limit is half the high-water limit. The
    default value is 64kB, half of asyncio's default (based on the current
    implementation of :class:`~asyncio.StreamReader`).

    The ``write_limit`` argument sets the high-water limit of the buffer for
    outgoing bytes. The low-water limit is a quarter of the high-water limit.
    The default value is 64kB, equal to asyncio's default (based on the
    current implementation of ``FlowControlMixin``).

    As soon as the HTTP request and response in the opening handshake are
    processed:

    * the request path is available in the :attr:`path` attribute;
    * the request and response HTTP headers are available in the
      :attr:`request_headers` and :attr:`response_headers` attributes,
      which are :class:`~websockets.http.Headers` instances.

    These attributes must be treated as immutable.

    If a subprotocol was negotiated, it's available in the :attr:`subprotocol`
    attribute.

    Once the connection is closed, the status code is available in the
    :attr:`close_code` attribute and the reason in :attr:`close_reason`.

    """
    # There are only two differences between the client-side and the server-
    # side behavior: masking the payload and closing the underlying TCP
    # connection. Set is_client and side to pick a side.
    is_client = None
    side = 'undefined'

    @others
if sys.version_info[:2] &gt;= (3, 6):                          # pragma: no cover
    from .py36.protocol import __aiter__
    WebSocketCommonProtocol.__aiter__ = __aiter__
</t>
<t tx="ekr.20181029161420.108">def __init__(self, *,
             host=None, port=None, secure=None,
             timeout=10, max_size=2 ** 20, max_queue=2 ** 5,
             read_limit=2 ** 16, write_limit=2 ** 16,
             loop=None, legacy_recv=False):
    self.host = host
    self.port = port
    self.secure = secure
    self.timeout = timeout
    self.max_size = max_size
    self.max_queue = max_queue
    self.read_limit = read_limit
    self.write_limit = write_limit

    # Store a reference to loop to avoid relying on self._loop, a private
    # attribute of StreamReaderProtocol, inherited from FlowControlMixin.
    if loop is None:
        loop = asyncio.get_event_loop()
    self.loop = loop

    self.legacy_recv = legacy_recv

    # Configure read buffer limits. The high-water limit is defined by
    # ``self.read_limit``. The ``limit`` argument controls the line length
    # limit and half the buffer limit of :class:`~asyncio.StreamReader`.
    # That's why it must be set to half of ``self.read_limit``.
    stream_reader = asyncio.StreamReader(limit=read_limit // 2, loop=loop)
    super().__init__(stream_reader, self.client_connected, loop)

    self.reader = None
    self.writer = None
    self._drain_lock = asyncio.Lock(loop=loop)

    # This class implements the data transfer and closing handshake, which
    # are shared between the client-side and the server-side.
    # Subclasses implement the opening handshake and, on success, execute
    # :meth:`connection_open()` to change the state to OPEN.
    self.state = State.CONNECTING
    logger.debug("%s - state = CONNECTING", self.side)

    # HTTP protocol parameters.
    self.path = None
    self.request_headers = None
    self.response_headers = None

    # WebSocket protocol parameters.
    self.extensions = []
    self.subprotocol = None

    # The close code and reason are set when receiving a close frame or
    # losing the TCP connection.
    self.close_code = None
    self.close_reason = ''

    # Completed when the connection state becomes CLOSED. Translates the
    # :meth:`connection_lost()` callback to a :class:`~asyncio.Future`
    # that can be awaited. (Other :class:`~asyncio.Protocol` callbacks are
    # translated by ``self.stream_reader``).
    self.connection_lost_waiter = asyncio.Future(loop=loop)

    # Queue of received messages.
    self.messages = asyncio.queues.Queue(max_queue, loop=loop)

    # Mapping of ping IDs to waiters, in chronological order.
    self.pings = collections.OrderedDict()

    # Task running the data transfer.
    self.transfer_data_task = None

    # Exception that occurred during data transfer, if any.
    self.transfer_data_exc = None

    # Task closing the TCP connection.
    self.close_connection_task = None

</t>
<t tx="ekr.20181029161420.109">def client_connected(self, reader, writer):
    """
    Callback when the TCP connection is established.

    Record references to the stream reader and the stream writer to avoid
    using private attributes ``_stream_reader`` and ``_stream_writer`` of
    :class:`~asyncio.StreamReaderProtocol`.

    """
    self.reader = reader
    self.writer = writer

</t>
<t tx="ekr.20181029161420.11">class Connect:
    """
    Connect to the WebSocket server at the given ``uri``.

    :func:`connect` returns an awaitable. Awaiting it yields an instance of
    :class:`WebSocketClientProtocol` which can then be used to send and
    receive messages.

    On Python  3.5.1, :func:`connect` can be used as a asynchronous context
    manager. In that case, the connection is closed when exiting the context.

    :func:`connect` is a wrapper around the event loop's
    :meth:`~asyncio.BaseEventLoop.create_connection` method. Unknown keyword
    arguments are passed to :meth:`~asyncio.BaseEventLoop.create_connection`.

    For example, you can set the ``ssl`` keyword argument to a
    :class:`~ssl.SSLContext` to enforce some TLS settings. When connecting to
    a ``wss://`` URI, if this argument isn't provided explicitly, it's set to
    ``True``, which means Python's default :class:`~ssl.SSLContext` is used.

    The behavior of the ``timeout``, ``max_size``, and ``max_queue``,
    ``read_limit``, and ``write_limit`` optional arguments is described in the
    documentation of :class:`~websockets.protocol.WebSocketCommonProtocol`.

    The ``create_protocol`` parameter allows customizing the asyncio protocol
    that manages the connection. It should be a callable or class accepting
    the same arguments as :class:`WebSocketClientProtocol` and returning a
    :class:`WebSocketClientProtocol` instance. It defaults to
    :class:`WebSocketClientProtocol`.

    :func:`connect` also accepts the following optional arguments:

    * ``origin`` sets the Origin HTTP header
    * ``extensions`` is a list of supported extensions in order of
      decreasing preference
    * ``subprotocols`` is a list of supported subprotocols in order of
      decreasing preference
    * ``extra_headers`` sets additional HTTP request headers  it can be a
      :class:`~websockets.http.Headers` instance, a
      :class:`~collections.abc.Mapping`, or an iterable of ``(name, value)``
      pairs
    * ``compression`` is a shortcut to configure compression extensions;
      by default it enables the "permessage-deflate" extension; set it to
      ``None`` to disable compression

    :func:`connect` raises :exc:`~websockets.uri.InvalidURI` if ``uri`` is
    invalid and :exc:`~websockets.handshake.InvalidHandshake` if the opening
    handshake fails.

    """

    @others
if sys.version_info[:3] &lt;= (3, 5, 0):                       # pragma: no cover
    @asyncio.coroutine
    def connect(*args, **kwds):
        return Connect(*args, **kwds).__iter__()
    connect.__doc__ = Connect.__doc__

else:
    from .py35.client import __aenter__, __aexit__, __await__
    Connect.__aenter__ = __aenter__
    Connect.__aexit__ = __aexit__
    Connect.__await__ = __await__
    connect = Connect
</t>
<t tx="ekr.20181029161420.110">def connection_open(self):
    """
    Callback when the WebSocket opening handshake completes.

    Enter the OPEN state and start the data transfer phase.

    """
    # 4.1. The WebSocket Connection is Established.
    assert self.state is State.CONNECTING
    self.state = State.OPEN
    logger.debug("%s - state = OPEN", self.side)
    # Start the task that receives incoming WebSocket messages.
    self.transfer_data_task = asyncio_ensure_future(
        self.transfer_data(), loop=self.loop)
    # Start the task that eventually closes the TCP connection.
    self.close_connection_task = asyncio_ensure_future(
        self.close_connection(), loop=self.loop)

# Public API

</t>
<t tx="ekr.20181029161420.111">@property
def local_address(self):
    """
    Local address of the connection.

    This is a ``(host, port)`` tuple or ``None`` if the connection hasn't
    been established yet.

    """
    if self.writer is None:
        return None
    return self.writer.get_extra_info('sockname')

</t>
<t tx="ekr.20181029161420.112">@property
def remote_address(self):
    """
    Remote address of the connection.

    This is a ``(host, port)`` tuple or ``None`` if the connection hasn't
    been established yet.

    """
    if self.writer is None:
        return None
    return self.writer.get_extra_info('peername')

</t>
<t tx="ekr.20181029161420.113">@property
def open(self):
    """
    This property is ``True`` when the connection is usable.

    It may be used to detect disconnections but this is discouraged per
    the EAFP_ principle. When ``open`` is ``False``, using the connection
    raises a :exc:`~websockets.exceptions.ConnectionClosed` exception.

    .. _EAFP: https://docs.python.org/3/glossary.html#term-eafp

    """
    return self.state is State.OPEN and not self.transfer_data_task.done()

</t>
<t tx="ekr.20181029161420.114">@property
def closed(self):
    """
    This property is ``True`` once the connection is closed.

    Be aware that both :attr:`open` and :attr`closed` are ``False`` during
    the opening and closing sequences.

    """
    return self.state is State.CLOSED

</t>
<t tx="ekr.20181029161420.115">@asyncio.coroutine
def recv(self):
    """
    This coroutine receives the next message.

    It returns a :class:`str` for a text frame and :class:`bytes` for a
    binary frame.

    When the end of the message stream is reached, :meth:`recv` raises
    :exc:`~websockets.exceptions.ConnectionClosed`. This can happen after
    a normal connection closure, a protocol error or a network failure.

    .. versionchanged:: 3.0

        :meth:`recv` used to return ``None`` instead. Refer to the
        changelog for details.

    """
    # Don't yield from self.ensure_open() here because messages could be
    # available in the queue even if the connection is closed.

    # Return any available message
    try:
        return self.messages.get_nowait()
    except asyncio.queues.QueueEmpty:
        pass

    # Don't yield from self.ensure_open() here because messages could be
    # received before the closing frame even if the connection is closing.

    # Wait for a message until the connection is closed.
    next_message = asyncio_ensure_future(
        self.messages.get(), loop=self.loop)
    # See https://bugs.python.org/issue23859 for cancellation handling.
    try:
        done, pending = yield from asyncio.wait(
            [next_message, self.transfer_data_task],
            loop=self.loop, return_when=asyncio.FIRST_COMPLETED)
    except asyncio.CancelledError:
        # Propagate cancellation to avoid leaking the next_message Task.
        next_message.cancel()
        raise

    if next_message in done:
        return next_message.result()
    else:
        next_message.cancel()
        if not self.legacy_recv:
            assert self.state in [State.CLOSING, State.CLOSED]
            # Wait until the connection is closed to raise
            # ConnectionClosed with the correct code and reason.
            yield from self.ensure_open()

</t>
<t tx="ekr.20181029161420.116">@asyncio.coroutine
def send(self, data):
    """
    This coroutine sends a message.

    It sends :class:`str` as a text frame and :class:`bytes` as a binary
    frame. It raises a :exc:`TypeError` for other inputs.

    """
    yield from self.ensure_open()

    if isinstance(data, str):
        opcode = 1
        data = data.encode('utf-8')
    elif isinstance(data, bytes):
        opcode = 2
    else:
        raise TypeError("data must be bytes or str")

    yield from self.write_frame(opcode, data)

</t>
<t tx="ekr.20181029161420.117">@asyncio.coroutine
def close(self, code=1000, reason=''):
    """
    This coroutine performs the closing handshake.

    It waits for the other end to complete the handshake and for the TCP
    connection to terminate.

    It doesn't do anything once the connection is closed. In other words
    it's idemptotent.

    It's safe to wrap this coroutine in :func:`~asyncio.ensure_future`
    since errors during connection termination aren't particularly useful.

    ``code`` must be an :class:`int` and ``reason`` a :class:`str`.

    """
    try:
        yield from asyncio.wait_for(
            self.write_close_frame(serialize_close(code, reason)),
            self.timeout, loop=self.loop)
    except asyncio.TimeoutError:
        # If the close frame cannot be sent because the send buffers
        # are full, the closing handshake won't complete anyway.
        # Fail the connection to shut down faster.
        self.fail_connection()

    # If no close frame is received within the timeout, wait_for() cancels
    # the data transfer task and raises TimeoutError. Then transfer_data()
    # catches CancelledError and exits without an exception.

    # If close() is called multiple times concurrently and one of these
    # calls hits the timeout, other calls will resume executing without an
    # exception, so there's no need to catch CancelledError here.

    try:
        # If close() is cancelled during the wait, self.transfer_data_task
        # is cancelled before the timeout elapses (on Python  3.4.3).
        # This helps closing connections when shutting down a server.
        yield from asyncio.wait_for(
            self.transfer_data_task,
            self.timeout, loop=self.loop)
    except (asyncio.TimeoutError, asyncio.CancelledError):
        pass

    # Wait for the close connection task to close the TCP connection.
    yield from asyncio.shield(self.close_connection_task)

</t>
<t tx="ekr.20181029161420.118">@asyncio.coroutine
def ping(self, data=None):
    """
    This coroutine sends a ping.

    It returns a :class:`~asyncio.Future` which will be completed when the
    corresponding pong is received and which you may ignore if you don't
    want to wait.

    A ping may serve as a keepalive or as a check that the remote endpoint
    received all messages up to this point::

        pong_waiter = await ws.ping()
        await pong_waiter   # only if you want to wait for the pong

    By default, the ping contains four random bytes. The content may be
    overridden with the optional ``data`` argument which must be of type
    :class:`str` (which will be encoded to UTF-8) or :class:`bytes`.

    """
    yield from self.ensure_open()

    if data is not None:
        data = encode_data(data)

    # Protect against duplicates if a payload is explicitly set.
    if data in self.pings:
        raise ValueError("Already waiting for a pong with the same data")

    # Generate a unique random payload otherwise.
    while data is None or data in self.pings:
        data = struct.pack('!I', random.getrandbits(32))

    self.pings[data] = asyncio.Future(loop=self.loop)

    yield from self.write_frame(OP_PING, data)

    return asyncio.shield(self.pings[data])

</t>
<t tx="ekr.20181029161420.119">@asyncio.coroutine
def pong(self, data=b''):
    """
    This coroutine sends a pong.

    An unsolicited pong may serve as a unidirectional heartbeat.

    The content may be overridden with the optional ``data`` argument
    which must be of type :class:`str` (which will be encoded to UTF-8) or
    :class:`bytes`.

    """
    yield from self.ensure_open()

    data = encode_data(data)

    yield from self.write_frame(OP_PONG, data)

# Private methods - no guarantees.

</t>
<t tx="ekr.20181029161420.12">def __init__(self, uri, *,
             create_protocol=None,
             timeout=10, max_size=2 ** 20, max_queue=2 ** 5,
             read_limit=2 ** 16, write_limit=2 ** 16,
             loop=None, legacy_recv=False, klass=None,
             origin=None, extensions=None, subprotocols=None,
             extra_headers=None, compression='deflate', **kwds):
    if loop is None:
        loop = asyncio.get_event_loop()

    # Backwards-compatibility: create_protocol used to be called klass.
    # In the unlikely event that both are specified, klass is ignored.
    if create_protocol is None:
        create_protocol = klass

    if create_protocol is None:
        create_protocol = WebSocketClientProtocol

    wsuri = parse_uri(uri)
    if wsuri.secure:
        kwds.setdefault('ssl', True)
    elif kwds.get('ssl') is not None:
        raise ValueError("connect() received a SSL context for a ws:// "
                         "URI, use a wss:// URI to enable TLS")

    if compression == 'deflate':
        if extensions is None:
            extensions = []
        if not any(
            extension_factory.name == ClientPerMessageDeflateFactory.name
            for extension_factory in extensions
        ):
            extensions.append(ClientPerMessageDeflateFactory(
                client_max_window_bits=True,
            ))
    elif compression is not None:
        raise ValueError("Unsupported compression: {}".format(compression))

    factory = lambda: create_protocol(
        host=wsuri.host, port=wsuri.port, secure=wsuri.secure,
        timeout=timeout, max_size=max_size, max_queue=max_queue,
        read_limit=read_limit, write_limit=write_limit,
        loop=loop, legacy_recv=legacy_recv,
        origin=origin, extensions=extensions, subprotocols=subprotocols,
        extra_headers=extra_headers,
    )

    if kwds.get('sock') is None:
        host, port = wsuri.host, wsuri.port
    else:
        # If sock is given, host and port mustn't be specified.
        host, port = None, None

    self._wsuri = wsuri
    self._origin = origin

    # This is a coroutine object.
    self._creating_connection = loop.create_connection(
        factory, host, port, **kwds)

</t>
<t tx="ekr.20181029161420.120">@asyncio.coroutine
def ensure_open(self):
    """
    Check that the WebSocket connection is open.

    Raise :exc:`~websockets.exceptions.ConnectionClosed` if it isn't.

    """
    # Handle cases from most common to least common for performance.
    if self.state is State.OPEN:
        # If self.transfer_data_task exited without a closing handshake,
        # self.close_connection_task may be closing it, going straight
        # from OPEN to CLOSED.
        if self.transfer_data_task.done():
            yield from asyncio.shield(self.close_connection_task)
            raise ConnectionClosed(self.close_code, self.close_reason)
        else:
            return

    if self.state is State.CLOSED:
        raise ConnectionClosed(
            self.close_code, self.close_reason) from self.transfer_data_exc

    if self.state is State.CLOSING:
        # If we started the closing handshake, wait for its completion to
        # get the proper close code and status. self.close_connection_task
        # will complete within 4 or 5 * timeout after calling close().
        # The CLOSING state also occurs when failing the connection. In
        # that case self.close_connection_task will complete even faster.
        if self.close_code is None:
            yield from asyncio.shield(self.close_connection_task)
        raise ConnectionClosed(
            self.close_code, self.close_reason) from self.transfer_data_exc

    # Control may only reach this point in buggy third-party subclasses.
    assert self.state is State.CONNECTING
    raise InvalidState("WebSocket connection isn't established yet")

</t>
<t tx="ekr.20181029161420.121">@asyncio.coroutine
def transfer_data(self):
    """
    Read incoming messages and put them in a queue.

    This coroutine runs in a task until the closing handshake is started.

    """
    try:
        while True:
            msg = yield from self.read_message()
            # Exit the loop when receiving a close frame.
            if msg is None:
                break
            yield from self.messages.put(msg)

    except asyncio.CancelledError as exc:
        self.transfer_data_exc = exc
        # If fail_connection() cancels this task, avoid logging the error
        # twice and failing the connection again.
        raise

    except WebSocketProtocolError as exc:
        self.transfer_data_exc = exc
        self.fail_connection(1002)

    except (ConnectionError, EOFError) as exc:
        # Reading data with self.reader.readexactly may raise:
        # - most subclasses of ConnectionError if the TCP connection
        #   breaks, is reset, or is aborted;
        # - IncompleteReadError, a subclass of EOFError, if fewer
        #   bytes are available than requested.
        self.transfer_data_exc = exc
        self.fail_connection(1006)

    except UnicodeDecodeError as exc:
        self.transfer_data_exc = exc
        self.fail_connection(1007)

    except PayloadTooBig as exc:
        self.transfer_data_exc = exc
        self.fail_connection(1009)

    except Exception as exc:
        # This shouldn't happen often because exceptions expected under
        # regular circumstances are handled above. If it does, consider
        # catching and handling more exceptions.
        logger.error("Error in data transfer", exc_info=True)

        self.transfer_data_exc = exc
        self.fail_connection(1011)

</t>
<t tx="ekr.20181029161420.122">@asyncio.coroutine
def read_message(self):
    """
    Read a single message from the connection.

    Re-assemble data frames if the message is fragmented.

    Return ``None`` when the closing handshake is started.

    """
    frame = yield from self.read_data_frame(max_size=self.max_size)

    # A close frame was received.
    if frame is None:
        return

    if frame.opcode == OP_TEXT:
        text = True
    elif frame.opcode == OP_BINARY:
        text = False
    else:   # frame.opcode == OP_CONT
        raise WebSocketProtocolError("Unexpected opcode")

    # Shortcut for the common case - no fragmentation
    if frame.fin:
        return frame.data.decode('utf-8') if text else frame.data

    # 5.4. Fragmentation
    chunks = []
    max_size = self.max_size
    if text:
        decoder = codecs.getincrementaldecoder('utf-8')(errors='strict')
        if max_size is None:
            def append(frame):
                nonlocal chunks
                chunks.append(decoder.decode(frame.data, frame.fin))
        else:
            def append(frame):
                nonlocal chunks, max_size
                chunks.append(decoder.decode(frame.data, frame.fin))
                max_size -= len(frame.data)
    else:
        if max_size is None:
            def append(frame):
                nonlocal chunks
                chunks.append(frame.data)
        else:
            def append(frame):
                nonlocal chunks, max_size
                chunks.append(frame.data)
                max_size -= len(frame.data)
    append(frame)

    while not frame.fin:
        frame = yield from self.read_data_frame(max_size=max_size)
        if frame is None:
            raise WebSocketProtocolError("Incomplete fragmented message")
        if frame.opcode != OP_CONT:
            raise WebSocketProtocolError("Unexpected opcode")
        append(frame)

    return ('' if text else b'').join(chunks)

</t>
<t tx="ekr.20181029161420.123">@asyncio.coroutine
def read_data_frame(self, max_size):
    """
    Read a single data frame from the connection.

    Process control frames received before the next data frame.

    Return ``None`` if a close frame is encountered before any data frame.

    """
    # 6.2. Receiving Data
    while True:
        frame = yield from self.read_frame(max_size)

        # 5.5. Control Frames
        if frame.opcode == OP_CLOSE:
            # 7.1.5.  The WebSocket Connection Close Code
            # 7.1.6.  The WebSocket Connection Close Reason
            self.close_code, self.close_reason = parse_close(frame.data)
            # Echo the original data instead of re-serializing it with
            # serialize_close() because that fails when the close frame is
            # empty and parse_close() synthetizes a 1005 close code.
            yield from self.write_close_frame(frame.data)
            return

        elif frame.opcode == OP_PING:
            # Answer pings.
            # Replace by frame.data.hex() when dropping Python &lt; 3.5.
            ping_hex = binascii.hexlify(frame.data).decode() or '[empty]'
            logger.debug("%s - received ping, sending pong: %s",
                         self.side, ping_hex)
            yield from self.pong(frame.data)

        elif frame.opcode == OP_PONG:
            # Acknowledge pings on solicited pongs.
            if frame.data in self.pings:
                # Acknowledge all pings up to the one matching this pong.
                ping_id = None
                ping_ids = []
                while ping_id != frame.data:
                    ping_id, pong_waiter = self.pings.popitem(0)
                    ping_ids.append(ping_id)
                    pong_waiter.set_result(None)
                pong_hex = (
                    binascii.hexlify(frame.data).decode() or '[empty]')
                logger.debug("%s - received solicited pong: %s",
                             self.side, pong_hex)
                ping_ids = ping_ids[:-1]
                if ping_ids:
                    pings_hex = ', '.join(
                        binascii.hexlify(ping_id).decode() or '[empty]'
                        for ping_id in ping_ids
                    )
                    plural = 's' if len(ping_ids) &gt; 1 else ''
                    logger.debug(
                        "%s - acknowledged previous ping%s: %s",
                        self.side, plural, pings_hex)
            else:
                pong_hex = (
                    binascii.hexlify(frame.data).decode() or '[empty]')
                logger.debug("%s - received unsolicited pong: %s",
                             self.side, pong_hex)

        # 5.6. Data Frames
        else:
            return frame

</t>
<t tx="ekr.20181029161420.124">@asyncio.coroutine
def read_frame(self, max_size):
    """
    Read a single frame from the connection.

    """
    frame = yield from Frame.read(
        self.reader.readexactly,
        mask=not self.is_client,
        max_size=max_size,
        extensions=self.extensions,
    )
    logger.debug("%s &lt; %s", self.side, frame)
    return frame

</t>
<t tx="ekr.20181029161420.125">@asyncio.coroutine
def write_frame(self, opcode, data=b'', _expected_state=State.OPEN):
    # Defensive assertion for protocol compliance.
    if self.state is not _expected_state:               # pragma: no cover
        raise InvalidState("Cannot write to a WebSocket "
                           "in the {} state".format(self.state.name))

    frame = Frame(True, opcode, data)
    logger.debug("%s &gt; %s", self.side, frame)
    frame.write(
        self.writer.write,
        mask=self.is_client,
        extensions=self.extensions,
    )

    # Backport of https://github.com/python/asyncio/pull/280.
    # Remove when dropping support for Python &lt; 3.6.
    if self.writer.transport is not None:               # pragma: no cover
        if self.writer_is_closing():
                yield

    try:
        # drain() cannot be called concurrently by multiple coroutines:
        # http://bugs.python.org/issue29930. Remove this lock when no
        # version of Python where this bugs exists is supported anymore.
        with (yield from self._drain_lock):
            # Handle flow control automatically.
            yield from self.writer.drain()
    except ConnectionError:
        # Terminate the connection if the socket died.
        self.fail_connection()
        # Wait until the connection is closed to raise ConnectionClosed
        # with the correct code and reason.
        yield from self.ensure_open()

</t>
<t tx="ekr.20181029161420.126">def writer_is_closing(self):
    """
    Backport of https://github.com/python/asyncio/pull/291.

    Replace with ``self.writer.transport.is_closing()`` when dropping
    support for Python &lt; 3.6 and with ``self.writer.is_closing()`` when
    https://bugs.python.org/issue31491 is fixed.

    """
    transport = self.writer.transport
    try:
        return transport.is_closing()
    except AttributeError:                              # pragma: no cover
        # This emulates what is_closing would return if it existed.
        try:
            return transport._closing
        except AttributeError:
            return transport._closed

</t>
<t tx="ekr.20181029161420.127">@asyncio.coroutine
def write_close_frame(self, data=b''):
    """
    Write a close frame if and only if the connection state is OPEN.

    This dedicated coroutine must be used for writing close frames to
    ensure that at most one close frame is sent on a given connection.

    """
    # Test and set the connection state before sending the close frame to
    # avoid sending two frames in case of concurrent calls.
    if self.state is State.OPEN:
        # 7.1.3. The WebSocket Closing Handshake is Started
        self.state = State.CLOSING
        logger.debug("%s - state = CLOSING", self.side)

        # 7.1.2. Start the WebSocket Closing Handshake
        yield from self.write_frame(OP_CLOSE, data, State.CLOSING)

</t>
<t tx="ekr.20181029161420.128">@asyncio.coroutine
def close_connection(self):
    """
    7.1.1. Close the WebSocket Connection

    When the opening handshake succeeds, :meth:`connection_open` starts
    this coroutine in a task. It waits for the data transfer phase to
    complete then it closes the TCP connection cleanly.

    When the opening handshake fails, :meth:`fail_connection` does the
    same. There's no data transfer phase in that case.

    """
    try:
        # Wait for the data transfer phase to complete.
        if self.transfer_data_task is not None:
            try:
                yield from self.transfer_data_task
            except asyncio.CancelledError:
                pass

        # Cancel all pending pings because they'll never receive a pong.
        for ping in self.pings.values():
            ping.cancel()
        if self.pings:
            pings_hex = ', '.join(
                binascii.hexlify(ping_id).decode() or '[empty]'
                for ping_id in self.pings
            )
            plural = 's' if len(self.pings) &gt; 1 else ''
            logger.debug(
                "%s - cancelled pending ping%s: %s",
                self.side, plural, pings_hex)

        # A client should wait for a TCP close from the server.
        if self.is_client and self.transfer_data_task is not None:
            if (yield from self.wait_for_connection_lost()):
                return
            logger.debug(
                "%s ! timed out waiting for TCP close", self.side)

        # Half-close the TCP connection if possible (when there's no TLS).
        if self.writer.can_write_eof():
            logger.debug(
                "%s x half-closing TCP connection", self.side)
            self.writer.write_eof()

            if (yield from self.wait_for_connection_lost()):
                return
            logger.debug(
                "%s ! timed out waiting for TCP close", self.side)

    finally:
        # The try/finally ensures that the transport never remains open,
        # even if this coroutine is cancelled (for example).

        # If connection_lost() was called, the TCP connection is closed.
        # However, if TLS is enabled, the transport still needs closing.
        # Else asyncio complains: ResourceWarning: unclosed transport.
        if self.connection_lost_waiter.done() and not self.secure:
            return

        # Close the TCP connection. Buffers are flushed asynchronously.
        logger.debug(
            "%s x closing TCP connection", self.side)
        self.writer.close()

        if (yield from self.wait_for_connection_lost()):
            return
        logger.debug(
            "%s ! timed out waiting for TCP close", self.side)

        # Abort the TCP connection. Buffers are discarded.
        logger.debug(
            "%s x aborting TCP connection", self.side)
        self.writer.transport.abort()

        # connection_lost() is called quickly after aborting.
        yield from self.wait_for_connection_lost()

</t>
<t tx="ekr.20181029161420.129">@asyncio.coroutine
def wait_for_connection_lost(self):
    """
    Wait until the TCP connection is closed or ``self.timeout`` elapses.

    Return ``True`` if the connection is closed and ``False`` otherwise.

    """
    if not self.connection_lost_waiter.done():
        try:
            yield from asyncio.wait_for(
                asyncio.shield(self.connection_lost_waiter),
                self.timeout, loop=self.loop)
        except asyncio.TimeoutError:
            pass
    # Re-check self.connection_lost_waiter.done() synchronously because
    # connection_lost() could run between the moment the timeout occurs
    # and the moment this coroutine resumes running.
    return self.connection_lost_waiter.done()

</t>
<t tx="ekr.20181029161420.13">@asyncio.coroutine
def __iter__(self):                                     # pragma: no cover
    transport, protocol = yield from self._creating_connection

    try:
        yield from protocol.handshake(
            self._wsuri, origin=self._origin,
            available_extensions=protocol.available_extensions,
            available_subprotocols=protocol.available_subprotocols,
            extra_headers=protocol.extra_headers,
        )
    except Exception:
        yield from protocol.fail_connection()
        raise

    self.ws_client = protocol
    return protocol


# We can't define __await__ on Python &lt; 3.5.1 because asyncio.ensure_future
# didn't accept arbitrary awaitables until Python 3.5.1. We don't define
# __aenter__ and __aexit__ either on Python &lt; 3.5.1 to keep things simple.
</t>
<t tx="ekr.20181029161420.130">def fail_connection(self, code=1006, reason=''):
    """
    7.1.7. Fail the WebSocket Connection

    This requires:

    1. Stopping all processing of incoming data, which means cancelling
       :attr:`transfer_data_task`. The close code will be 1006 unless a
       close frame was received earlier.

    2. Sending a close frame with an appropriate code if the opening
       handshake succeeded and the other side is likely to process it.

    3. Closing the connection. :meth:`close_connection` takes care of
       this once :attr:`transfer_data_task` exits after being cancelled.

    (The specification describes these steps in the opposite order.)

    Return a :class:`~asyncio.Task` that completes when the TCP connection
    is closed.

    """
    logger.debug(
        "%s ! failing WebSocket connection: %d %s",
        self.side, code, reason,
    )

    # Cancel transfer_data_task if the opening handshake succeeded.
    # cancel() is idempotent and ignored if the task is done already.
    if self.transfer_data_task is not None:
        self.transfer_data_task.cancel()

    # Send a close frame when the state is OPEN (a close frame was already
    # sent if it's CLOSING), except when failing the connection because of
    # an error reading from or writing to the network.
    # Don't send a close frame if the connection is broken.
    if code != 1006 and self.state is State.OPEN:

        frame_data = serialize_close(code, reason)

        # Write the close frame without draining the write buffer.

        # Keeping fail_connection() synchronous guarantees it can't
        # get stuck and simplifies the implementation of the callers.
        # Not drainig the write buffer is acceptable in this context.

        # This duplicates a few lines of code from write_close_frame()
        # and write_frame().

        self.state = State.CLOSING
        logger.debug("%s - state = CLOSING", self.side)

        frame = Frame(True, OP_CLOSE, frame_data)
        logger.debug("%s &gt; %s", self.side, frame)
        frame.write(
            self.writer.write,
            mask=self.is_client,
            extensions=self.extensions,
        )

    # Start close_connection_task if the opening handshake didn't succeed.
    if self.close_connection_task is None:
        self.close_connection_task = asyncio_ensure_future(
            self.close_connection(), loop=self.loop)

    return self.close_connection_task

# asyncio.StreamReaderProtocol methods

</t>
<t tx="ekr.20181029161420.131">def connection_made(self, transport):
    """
    Configure write buffer limits.

    The high-water limit is defined by ``self.write_limit``.

    The low-water limit currently defaults to ``self.write_limit // 4`` in
    :meth:`~asyncio.WriteTransport.set_write_buffer_limits`, which should
    be all right for reasonable use cases of this library.

    This is the earliest point where we can get hold of the transport,
    which means it's the best point for configuring it.

    """
    logger.debug("%s - event = connection_made(%s)", self.side, transport)
    transport.set_write_buffer_limits(self.write_limit)
    super().connection_made(transport)

</t>
<t tx="ekr.20181029161420.132">def eof_received(self):
    """
    Close the transport after receiving EOF.

    Since Python 3.5, `:meth:~StreamReaderProtocol.eof_received` returns
    ``True`` on non-TLS connections.

    See http://bugs.python.org/issue24539 for more information.

    This is inappropriate for websockets for at least three reasons:

    1. The use case is to read data until EOF with self.reader.read(-1).
       Since websockets is a TLV protocol, this never happens.

    2. It doesn't work on TLS connections. A falsy value must be
       returned to have the same behavior on TLS and plain connections.

    3. The websockets protocol has its own closing handshake. Endpoints
       close the TCP connection after sending a close frame.

    As a consequence we revert to the previous, more useful behavior.

    """
    logger.debug("%s - event = eof_received()", self.side)
    super().eof_received()
    return

</t>
<t tx="ekr.20181029161420.133">def connection_lost(self, exc):
    """
    7.1.4. The WebSocket Connection is Closed.

    """
    logger.debug("%s - event = connection_lost(%s)", self.side, exc)
    self.state = State.CLOSED
    logger.debug("%s - state = CLOSED", self.side)
    if self.close_code is None:
        self.close_code = 1006
    logger.debug("%s x code = %d, reason = %s", self.side,
                 self.close_code, self.close_reason or '[empty]')
    # If self.connection_lost_waiter isn't pending, that's a bug, because:
    # - it's set only here in connection_lost() which is called only once;
    # - it must never be cancelled.
    self.connection_lost_waiter.set_result(None)
    super().connection_lost(exc)


</t>
<t tx="ekr.20181029161420.134">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.server` module defines a simple WebSocket server API.

"""

@others
# We can't define __await__ on Python &lt; 3.5.1 because asyncio.ensure_future
# didn't accept arbitrary awaitables until Python 3.5.1. We don't define
# __aenter__ and __aexit__ either on Python &lt; 3.5.1 to keep things simple.
if sys.version_info[:3] &lt;= (3, 5, 0):                       # pragma: no cover
    @asyncio.coroutine
    def serve(*args, **kwds):
        return Serve(*args, **kwds).__iter__()
    serve.__doc__ = Serve.__doc__

else:
    from .py35.server import __aenter__, __aexit__, __await__
    Serve.__aenter__ = __aenter__
    Serve.__aexit__ = __aexit__
    Serve.__await__ = __await__
    serve = Serve
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.135">import asyncio
import collections.abc
import email.utils
import logging
import sys

from .compatibility import (
    BAD_REQUEST, FORBIDDEN, INTERNAL_SERVER_ERROR, SERVICE_UNAVAILABLE,
    SWITCHING_PROTOCOLS, UPGRADE_REQUIRED, asyncio_ensure_future
)
from .exceptions import (
    AbortHandshake, InvalidHandshake, InvalidMessage, InvalidOrigin,
    InvalidUpgrade, NegotiationError
)
from .extensions.permessage_deflate import ServerPerMessageDeflateFactory
from .handshake import build_response, check_request
from .headers import (
    build_extension_list, parse_extension_list, parse_subprotocol_list
)
from .http import USER_AGENT, Headers, read_request
from .protocol import WebSocketCommonProtocol


__all__ = ['serve', 'unix_serve', 'WebSocketServerProtocol']

logger = logging.getLogger(__name__)


</t>
<t tx="ekr.20181029161420.136">class WebSocketServerProtocol(WebSocketCommonProtocol):
    """
    Complete WebSocket server implementation as an :class:`asyncio.Protocol`.

    This class inherits most of its methods from
    :class:`~websockets.protocol.WebSocketCommonProtocol`.

    For the sake of simplicity, it doesn't rely on a full HTTP implementation.
    Its support for HTTP responses is very limited.

    """
    is_client = False
    side = 'server'

    @others
</t>
<t tx="ekr.20181029161420.137">def __init__(self, ws_handler, ws_server, *,
             origins=None, extensions=None, subprotocols=None,
             extra_headers=None, **kwds):
    self.ws_handler = ws_handler
    self.ws_server = ws_server
    self.origins = origins
    self.available_extensions = extensions
    self.available_subprotocols = subprotocols
    self.extra_headers = extra_headers
    super().__init__(**kwds)

</t>
<t tx="ekr.20181029161420.138">def connection_made(self, transport):
    """
    Register connection and initialize a task to handle it.

    """
    super().connection_made(transport)
    # Register the connection with the server before creating the handler
    # task. Registering at the beginning of the handler coroutine would
    # create a race condition between the creation of the task, which
    # schedules its execution, and the moment the handler starts running.
    self.ws_server.register(self)
    self.handler_task = asyncio_ensure_future(
        self.handler(), loop=self.loop)

</t>
<t tx="ekr.20181029161420.139">@asyncio.coroutine
def handler(self):
    """
    Handle the lifecycle of a WebSocket connection.

    Since this method doesn't have a caller able to handle exceptions, it
    attemps to log relevant ones and close the connection properly.

    """
    try:

        try:
            path = yield from self.handshake(
                origins=self.origins,
                available_extensions=self.available_extensions,
                available_subprotocols=self.available_subprotocols,
                extra_headers=self.extra_headers,
            )
        except ConnectionError as exc:
            logger.debug(
                "Connection error in opening handshake", exc_info=True)
            raise
        except Exception as exc:
            if self._is_server_shutting_down(exc):
                status, headers, body = (
                    SERVICE_UNAVAILABLE,
                    [],
                    b"Server is shutting down.\n",
                )
            elif isinstance(exc, AbortHandshake):
                status, headers, body = (
                    exc.status,
                    exc.headers,
                    exc.body,
                )
            elif isinstance(exc, InvalidOrigin):
                logger.debug("Invalid origin", exc_info=True)
                status, headers, body = (
                    FORBIDDEN,
                    [],
                    (str(exc) + "\n").encode(),
                )
            elif isinstance(exc, InvalidUpgrade):
                logger.debug("Invalid upgrade", exc_info=True)
                status, headers, body = (
                    UPGRADE_REQUIRED,
                    [('Upgrade', 'websocket')],
                    (str(exc) + "\n").encode(),
                )
            elif isinstance(exc, InvalidHandshake):
                logger.debug("Invalid handshake", exc_info=True)
                status, headers, body = (
                    BAD_REQUEST,
                    [],
                    (str(exc) + "\n").encode(),
                )
            else:
                logger.warning("Error in opening handshake", exc_info=True)
                status, headers, body = (
                    INTERNAL_SERVER_ERROR,
                    [],
                    b"See server log for more information.\n",
                )

            if not isinstance(headers, Headers):
                headers = Headers(headers)

            headers.setdefault('Date', email.utils.formatdate(usegmt=True))
            headers.setdefault('Server', USER_AGENT)
            headers.setdefault('Content-Length', str(len(body)))
            headers.setdefault('Content-Type', 'text/plain')
            headers.setdefault('Connection', 'close')

            yield from self.write_http_response(status, headers, body)
            yield from self.fail_connection()

            return

        try:
            yield from self.ws_handler(self, path)
        except Exception as exc:
            if self._is_server_shutting_down(exc):
                if not self.closed:
                    self.fail_connection(1001)
            else:
                logger.error("Error in connection handler", exc_info=True)
                if not self.closed:
                    self.fail_connection(1011)
            raise

        try:
            yield from self.close()
        except ConnectionError as exc:
            logger.debug(
                "Connection error in closing handshake", exc_info=True)
            raise
        except Exception as exc:
            if not self._is_server_shutting_down(exc):
                logger.warning("Error in closing handshake", exc_info=True)
            raise

    except Exception:
        # Last-ditch attempt to avoid leaking connections on errors.
        try:
            self.writer.close()
        except Exception:                               # pragma: no cover
            pass

    finally:
        # Unregister the connection with the server when the handler task
        # terminates. Registration is tied to the lifecycle of the handler
        # task because the server waits for tasks attached to registered
        # connections before terminating.
        self.ws_server.unregister(self)

</t>
<t tx="ekr.20181029161420.14">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.compatibility` module provides helpers for bridging
compatibility issues across Python versions.

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.140">def _is_server_shutting_down(self, exc):
    """
    Decide whether an exception means that the server is shutting down.

    """
    return (
        isinstance(exc, asyncio.CancelledError) and
        self.ws_server.closing
    )

</t>
<t tx="ekr.20181029161420.141">@asyncio.coroutine
def read_http_request(self):
    """
    Read request line and headers from the HTTP request.

    Raise :exc:`~websockets.exceptions.InvalidMessage` if the HTTP message
    is malformed or isn't an HTTP/1.1 GET request.

    Don't attempt to read the request body because WebSocket handshake
    requests don't have one. If the request contains a body, it may be
    read from ``self.reader`` after this coroutine returns.

    """
    try:
        path, headers = yield from read_request(self.reader)
    except ValueError as exc:
        raise InvalidMessage("Malformed HTTP message") from exc

    self.path = path
    self.request_headers = headers

    return path, self.request_headers

</t>
<t tx="ekr.20181029161420.142">@asyncio.coroutine
def write_http_response(self, status, headers, body=None):
    """
    Write status line and headers to the HTTP response.

    This coroutine is also able to write a response body.

    """
    self.response_headers = headers

    # Since the status line and headers only contain ASCII characters,
    # we can keep this simple.
    response = 'HTTP/1.1 {status.value} {status.phrase}\r\n'.format(
        status=status)
    response += str(headers)

    self.writer.write(response.encode())

    if body is not None:
        self.writer.write(body)

</t>
<t tx="ekr.20181029161420.143">@asyncio.coroutine
def process_request(self, path, request_headers):
    """
    Intercept the HTTP request and return an HTTP response if needed.

    ``request_headers`` is a :class:`~websockets.http.Headers` instance.

    If this coroutine returns ``None``, the WebSocket handshake continues.
    If it returns a status code, headers and a response body, that HTTP
    response is sent and the connection is closed.

    The HTTP status must be a :class:`~http.HTTPStatus`.
    (:class:`~http.HTTPStatus` was added in Python 3.5. Use a compatible
    object on earlier versions. Look at ``SWITCHING_PROTOCOLS`` in
    ``websockets.compatibility`` for an example.)

    HTTP headers must be a :class:`~websockets.http.Headers` instance, a
    :class:`~collections.abc.Mapping`, or an iterable of ``(name, value)``
    pairs.

    The HTTP response body must be :class:`bytes`. It may be empty.

    This method may be overridden to check the request headers and set a
    different status, for example to authenticate the request and return
    ``HTTPStatus.UNAUTHORIZED`` or ``HTTPStatus.FORBIDDEN``.

    It is declared as a coroutine because such authentication checks are
    likely to require network requests.

    """

</t>
<t tx="ekr.20181029161420.144">@staticmethod
def process_origin(headers, origins=None):
    """
    Handle the Origin HTTP request header.

    Raise :exc:`~websockets.exceptions.InvalidOrigin` if the origin isn't
    acceptable.

    """
    origin = headers.get('Origin', '')
    if origins is not None:
        if origin not in origins:
            raise InvalidOrigin(origin)
    return origin

</t>
<t tx="ekr.20181029161420.145">@staticmethod
def process_extensions(headers, available_extensions):
    """
    Handle the Sec-WebSocket-Extensions HTTP request header.

    Accept or reject each extension proposed in the client request.
    Negotiate parameters for accepted extensions.

    Return the Sec-WebSocket-Extensions HTTP response header and the list
    of accepted extensions.

    Raise :exc:`~websockets.exceptions.InvalidHandshake` to abort the
    handshake with an HTTP 400 error code. (The default implementation
    never does this.)

    :rfc:`6455` leaves the rules up to the specification of each
    :extension.

    To provide this level of flexibility, for each extension proposed by
    the client, we check for a match with each extension available in the
    server configuration. If no match is found, the extension is ignored.

    If several variants of the same extension are proposed by the client,
    it may be accepted severel times, which won't make sense in general.
    Extensions must implement their own requirements. For this purpose,
    the list of previously accepted extensions is provided.

    This process doesn't allow the server to reorder extensions. It can
    only select a subset of the extensions proposed by the client.

    Other requirements, for example related to mandatory extensions or the
    order of extensions, may be implemented by overriding this method.

    """
    response_header = []
    accepted_extensions = []

    header_values = headers.get_all('Sec-WebSocket-Extensions')

    if header_values and available_extensions:

        parsed_header_values = sum([
            parse_extension_list(header_value)
            for header_value in header_values
        ], [])

        for name, request_params in parsed_header_values:

            for extension_factory in available_extensions:

                # Skip non-matching extensions based on their name.
                if extension_factory.name != name:
                    continue

                # Skip non-matching extensions based on their params.
                try:
                    response_params, extension = (
                        extension_factory.process_request_params(
                            request_params, accepted_extensions))
                except NegotiationError:
                    continue

                # Add matching extension to the final list.
                response_header.append((name, response_params))
                accepted_extensions.append(extension)

                # Break out of the loop once we have a match.
                break

            # If we didn't break from the loop, no extension in our list
            # matched what the client sent. The extension is declined.

    # Serialize extension header.
    if response_header:
        response_header = build_extension_list(response_header)
    else:
        response_header = None

    return response_header, accepted_extensions

# Not @staticmethod because it calls self.select_subprotocol()
</t>
<t tx="ekr.20181029161420.146">def process_subprotocol(self, headers, available_subprotocols):
    """
    Handle the Sec-WebSocket-Protocol HTTP request header.

    Return Sec-WebSocket-Protocol HTTP response header, which is the same
    as the selected subprotocol.

    """
    subprotocol = None

    header_values = headers.get_all('Sec-WebSocket-Protocol')

    if header_values and available_subprotocols:

        parsed_header_values = sum([
            parse_subprotocol_list(header_value)
            for header_value in header_values
        ], [])

        subprotocol = self.select_subprotocol(
            parsed_header_values,
            available_subprotocols,
        )

    return subprotocol

</t>
<t tx="ekr.20181029161420.147">@staticmethod
def select_subprotocol(client_subprotocols, server_subprotocols):
    """
    Pick a subprotocol among those offered by the client.

    If several subprotocols are supported by the client and the server,
    the default implementation selects the preferred subprotocols by
    giving equal value to the priorities of the client and the server.

    If no subprotocols are supported by the client and the server, it
    proceeds without a subprotocol.

    This is unlikely to be the most useful implementation in practice, as
    many servers providing a subprotocol will require that the client uses
    that subprotocol. Such rules can be implemented in a subclass.

    """
    subprotocols = set(client_subprotocols) &amp; set(server_subprotocols)
    if not subprotocols:
        return None
    priority = lambda p: (
        client_subprotocols.index(p) + server_subprotocols.index(p))
    return sorted(subprotocols, key=priority)[0]

</t>
<t tx="ekr.20181029161420.148">@asyncio.coroutine
def handshake(self, origins=None, available_extensions=None,
              available_subprotocols=None, extra_headers=None):
    """
    Perform the server side of the opening handshake.

    If provided, ``origins`` is a list of acceptable HTTP Origin values.
    Include ``''`` if the lack of an origin is acceptable.

    If provided, ``available_extensions`` is a list of supported
    extensions in the order in which they should be used.

    If provided, ``available_subprotocols`` is a list of supported
    subprotocols in order of decreasing preference.

    If provided, ``extra_headers`` sets additional HTTP response headers.
    It can be a :class:`~websockets.http.Headers` instance, a
    :class:`~collections.abc.Mapping`, an iterable of ``(name, value)``
    pairs, or a callable taking the request path and headers in arguments
    and returning one of the above.

    Raise :exc:`~websockets.exceptions.InvalidHandshake` if the handshake
    fails.

    Return the path of the URI of the request.

    """
    path, request_headers = yield from self.read_http_request()

    # Hook for customizing request handling, for example checking
    # authentication or treating some paths as plain HTTP endpoints.

    early_response = yield from self.process_request(path, request_headers)
    if early_response is not None:
        raise AbortHandshake(*early_response)

    key = check_request(request_headers)

    self.origin = self.process_origin(request_headers, origins)

    extensions_header, self.extensions = self.process_extensions(
        request_headers, available_extensions)

    protocol_header = self.subprotocol = self.process_subprotocol(
        request_headers, available_subprotocols)

    response_headers = Headers()
    response_headers['Date'] = email.utils.formatdate(usegmt=True)

    build_response(response_headers, key)

    if extensions_header is not None:
        response_headers['Sec-WebSocket-Extensions'] = extensions_header

    if self.subprotocol is not None:
        response_headers['Sec-WebSocket-Protocol'] = protocol_header

    if extra_headers is not None:
        if callable(extra_headers):
            extra_headers = extra_headers(path, self.request_headers)
        if isinstance(extra_headers, Headers):
            extra_headers = extra_headers.raw_items()
        elif isinstance(extra_headers, collections.abc.Mapping):
            extra_headers = extra_headers.items()
        for name, value in extra_headers:
            response_headers[name] = value

    response_headers.setdefault('Server', USER_AGENT)

    yield from self.write_http_response(
        SWITCHING_PROTOCOLS, response_headers)

    self.connection_open()

    return path


</t>
<t tx="ekr.20181029161420.149">class WebSocketServer:
    """
    Wrapper for :class:`~asyncio.Server` that closes connections on exit.

    This class provides the return type of :func:`~websockets.server.serve`.

    It mimics the interface of :class:`~asyncio.AbstractServer`, namely its
    :meth:`~asyncio.AbstractServer.close()` and
    :meth:`~asyncio.AbstractServer.wait_closed()` methods, to close WebSocket
    connections properly on exit, in addition to closing the underlying
    :class:`~asyncio.Server`.

    Instances of this class store a reference to the :class:`~asyncio.Server`
    object returned by :meth:`~asyncio.AbstractEventLoop.create_server` rather
    than inherit from :class:`~asyncio.Server` in part because
    :meth:`~asyncio.AbstractEventLoop.create_server` doesn't support passing a
    custom :class:`~asyncio.Server` class.

    """
    @others
</t>
<t tx="ekr.20181029161420.15">import asyncio
import http


# Replace with BaseEventLoop.create_task when dropping Python &lt; 3.4.2.
try:                                                     # pragma: no cover
    asyncio_ensure_future = asyncio.ensure_future        # Python  3.5
except AttributeError:                                   # pragma: no cover
    asyncio_ensure_future = getattr(asyncio, 'async')    # Python &lt; 3.5

try:                                                # pragma: no cover
                                                    # Python  3.5
    SWITCHING_PROTOCOLS = http.HTTPStatus.SWITCHING_PROTOCOLS
    OK = http.HTTPStatus.OK
    BAD_REQUEST = http.HTTPStatus.BAD_REQUEST
    UNAUTHORIZED = http.HTTPStatus.UNAUTHORIZED
    FORBIDDEN = http.HTTPStatus.FORBIDDEN
    UPGRADE_REQUIRED = http.HTTPStatus.UPGRADE_REQUIRED
    INTERNAL_SERVER_ERROR = http.HTTPStatus.INTERNAL_SERVER_ERROR
    SERVICE_UNAVAILABLE = http.HTTPStatus.SERVICE_UNAVAILABLE
except AttributeError:                              # pragma: no cover
                                                    # Python &lt; 3.5
    class SWITCHING_PROTOCOLS:
        value = 101
        phrase = "Switching Protocols"

    class OK:
        value = 200
        phrase = "OK"

    class BAD_REQUEST:
        value = 400
        phrase = "Bad Request"

    class UNAUTHORIZED:
        value = 401
        phrase = "Unauthorized"

    class FORBIDDEN:
        value = 403
        phrase = "Forbidden"

    class UPGRADE_REQUIRED:
        value = 426
        phrase = "Upgrade Required"

    class INTERNAL_SERVER_ERROR:
        value = 500
        phrase = "Internal Server Error"

    class SERVICE_UNAVAILABLE:
        value = 503
        phrase = "Service Unavailable"
</t>
<t tx="ekr.20181029161420.150">def __init__(self, loop):
    # Store a reference to loop to avoid relying on self.server._loop.
    self.loop = loop

    self.closing = False
    self.websockets = set()

</t>
<t tx="ekr.20181029161420.151">def wrap(self, server):
    """
    Attach to a given :class:`~asyncio.Server`.

    Since :meth:`~asyncio.AbstractEventLoop.create_server` doesn't support
    injecting a custom ``Server`` class, the easiest solution that doesn't
    rely on private :mod:`asyncio` APIs is to:

    - instantiate a :class:`WebSocketServer`
    - give the protocol factory a reference to that instance
    - call :meth:`~asyncio.AbstractEventLoop.create_server` with the
      factory
    - attach the resulting :class:`~asyncio.Server` with this method

    """
    self.server = server

</t>
<t tx="ekr.20181029161420.152">def register(self, protocol):
    """
    Register a connection with this server.

    """
    self.websockets.add(protocol)

</t>
<t tx="ekr.20181029161420.153">def unregister(self, protocol):
    """
    Unregister a connection with this server.

    """
    self.websockets.remove(protocol)

</t>
<t tx="ekr.20181029161420.154">def close(self):
    """
    Close the underlying server, and clean up connections.

    This calls :meth:`~asyncio.Server.close` on the underlying
    :class:`~asyncio.Server` object, closes open connections with
    status code 1001, and stops accepting new connections.

    """
    # Make a note that the server is shutting down. Websocket connections
    # check this attribute to decide to send a "going away" close code.
    self.closing = True

    # Stop accepting new connections.
    self.server.close()

    # Close open connections. For each connection, two tasks are running:
    # 1. self.transfer_data_task receives incoming WebSocket messages
    # 2. self.handler_task runs the opening handshake, the handler provided
    #    by the user and the closing handshake
    # In the general case, cancelling the handler task will cause the
    # handler provided by the user to exit with a CancelledError, which
    # will then cause the transfer data task to terminate.
    for websocket in self.websockets:
        websocket.handler_task.cancel()

</t>
<t tx="ekr.20181029161420.155">@asyncio.coroutine
def wait_closed(self):
    """
    Wait until the underlying server and all connections are closed.

    This calls :meth:`~asyncio.Server.wait_closed` on the underlying
    :class:`~asyncio.Server` object and waits until closing handshakes
    are complete and all connections are closed.

    This method must be called after :meth:`close()`.

    """
    # asyncio.wait doesn't accept an empty first argument.
    if self.websockets:
        # Either the handler or the connection can terminate first,
        # depending on how the client behaves and the server is
        # implemented.
        yield from asyncio.wait(
            [websocket.handler_task for websocket in self.websockets] +
            [websocket.close_connection_task
                for websocket in self.websockets],
            loop=self.loop)
    yield from self.server.wait_closed()

</t>
<t tx="ekr.20181029161420.156">@property
def sockets(self):
    """
    List of :class:`~socket.socket` objects the server is listening to.

    ``None`` if the server is closed.

    """
    return self.server.sockets


</t>
<t tx="ekr.20181029161420.157">class Serve:
    """
    Create, start, and return a :class:`WebSocketServer`.

    :func:`serve` returns an awaitable. Awaiting it yields an instance of
    :class:`WebSocketServer` which provides
    :meth:`~websockets.server.WebSocketServer.close` and
    :meth:`~websockets.server.WebSocketServer.wait_closed` methods for
    terminating the server and cleaning up its resources.

    On Python  3.5, :func:`serve` can also be used as an asynchronous context
    manager. In this case, the server is shut down when exiting the context.

    :func:`serve` is a wrapper around the event loop's
    :meth:`~asyncio.AbstractEventLoop.create_server` method. Internally, it
    creates and starts a :class:`~asyncio.Server` object by calling
    :meth:`~asyncio.AbstractEventLoop.create_server`. The
    :class:`WebSocketServer` it returns keeps a reference to this object.

    The ``ws_handler`` argument is the WebSocket handler. It must be a
    coroutine accepting two arguments: a :class:`WebSocketServerProtocol` and
    the request URI.

    The ``host`` and ``port`` arguments, as well as unrecognized keyword
    arguments, are passed along to
    :meth:`~asyncio.AbstractEventLoop.create_server`. For example, you can set
    the ``ssl`` keyword argument to a :class:`~ssl.SSLContext` to enable TLS.

    The ``create_protocol`` parameter allows customizing the asyncio protocol
    that manages the connection. It should be a callable or class accepting
    the same arguments as :class:`WebSocketServerProtocol` and returning a
    :class:`WebSocketServerProtocol` instance. It defaults to
    :class:`WebSocketServerProtocol`.

    The behavior of the ``timeout``, ``max_size``, and ``max_queue``,
    ``read_limit``, and ``write_limit`` optional arguments is described in the
    documentation of :class:`~websockets.protocol.WebSocketCommonProtocol`.

    :func:`serve` also accepts the following optional arguments:

    * ``origins`` defines acceptable Origin HTTP headers  include ``''`` if
      the lack of an origin is acceptable
    * ``extensions`` is a list of supported extensions in order of
      decreasing preference
    * ``subprotocols`` is a list of supported subprotocols in order of
      decreasing preference
    * ``extra_headers`` sets additional HTTP response headers  it can be a
      :class:`~websockets.http.Headers` instance, a
      :class:`~collections.abc.Mapping`, an iterable of ``(name, value)``
      pairs, or a callable taking the request path and headers in arguments
      and returning one of the above.
    * ``compression`` is a shortcut to configure compression extensions;
      by default it enables the "permessage-deflate" extension; set it to
      ``None`` to disable compression

    Whenever a client connects, the server accepts the connection, creates a
    :class:`WebSocketServerProtocol`, performs the opening handshake, and
    delegates to the WebSocket handler. Once the handler completes, the server
    performs the closing handshake and closes the connection.

    When a server is closed with
    :meth:`~websockets.server.WebSocketServer.close`, all running WebSocket
    handlers are cancelled. They may intercept :exc:`~asyncio.CancelledError`
    and perform cleanup actions before re-raising that exception. If a handler
    started new tasks, it should cancel them as well in that case.

    Since there's no useful way to propagate exceptions triggered in handlers,
    they're sent to the ``'websockets.server'`` logger instead. Debugging is
    much easier if you configure logging to print them::

        import logging
        logger = logging.getLogger('websockets.server')
        logger.setLevel(logging.ERROR)
        logger.addHandler(logging.StreamHandler())

    """

    @others
</t>
<t tx="ekr.20181029161420.158">def __init__(self, ws_handler, host=None, port=None, *,
             path=None, create_protocol=None,
             timeout=10, max_size=2 ** 20, max_queue=2 ** 5,
             read_limit=2 ** 16, write_limit=2 ** 16,
             loop=None, legacy_recv=False, klass=None,
             origins=None, extensions=None, subprotocols=None,
             extra_headers=None, compression='deflate', **kwds):
    # Backwards-compatibility: create_protocol used to be called klass.
    # In the unlikely event that both are specified, klass is ignored.
    if create_protocol is None:
        create_protocol = klass

    if create_protocol is None:
        create_protocol = WebSocketServerProtocol

    if loop is None:
        loop = asyncio.get_event_loop()

    ws_server = WebSocketServer(loop)

    secure = kwds.get('ssl') is not None

    if compression == 'deflate':
        if extensions is None:
            extensions = []
        if not any(
            extension_factory.name == ServerPerMessageDeflateFactory.name
            for extension_factory in extensions
        ):
            extensions.append(ServerPerMessageDeflateFactory())
    elif compression is not None:
        raise ValueError("Unsupported compression: {}".format(compression))

    factory = lambda: create_protocol(
        ws_handler, ws_server,
        host=host, port=port, secure=secure,
        timeout=timeout, max_size=max_size, max_queue=max_queue,
        read_limit=read_limit, write_limit=write_limit,
        loop=loop, legacy_recv=legacy_recv,
        origins=origins, extensions=extensions, subprotocols=subprotocols,
        extra_headers=extra_headers,
    )

    if path is None:
        creating_server = loop.create_server(factory, host, port, **kwds)
    else:
        creating_server = loop.create_unix_server(factory, path, **kwds)

    # This is a coroutine object.
    self._creating_server = creating_server
    self.ws_server = ws_server

</t>
<t tx="ekr.20181029161420.159">@asyncio.coroutine
def __iter__(self):                                     # pragma: no cover
    server = yield from self._creating_server
    self.ws_server.wrap(server)
    return self.ws_server


</t>
<t tx="ekr.20181029161420.16">@path C:/Anaconda3/Lib/site-packages/websockets/
__all__ = [
    'AbortHandshake', 'ConnectionClosed', 'DuplicateParameter',
    'InvalidHandshake', 'InvalidHeader', 'InvalidHeaderFormat',
    'InvalidHeaderValue', 'InvalidMessage', 'InvalidOrigin',
    'InvalidParameterName', 'InvalidParameterValue', 'InvalidState',
    'InvalidStatusCode', 'InvalidUpgrade', 'InvalidURI', 'NegotiationError',
    'PayloadTooBig', 'WebSocketProtocolError',
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.160">def unix_serve(ws_handler, path, **kwargs):
    """
    Similar to :func:`serve()`, but for listening on Unix sockets.

    This function calls the event loop's
    :meth:`~asyncio.AbstractEventLoop.create_unix_server` method.

    It is only available on Unix.

    It's useful for deploying a server behind a reverse proxy such as nginx.

    """
    return serve(ws_handler, path=path, **kwargs)


</t>
<t tx="ekr.20181029161420.161"></t>
<t tx="ekr.20181029161420.162">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20181029161420.163">import asyncio
import contextlib
import functools
import logging
import pathlib
import random
import socket
import ssl
import sys
import tempfile
import unittest
import unittest.mock
import urllib.error
import urllib.request

from .client import *
from .compatibility import FORBIDDEN, OK, UNAUTHORIZED
from .exceptions import (
    ConnectionClosed, InvalidHandshake, InvalidStatusCode, NegotiationError
)
from .extensions.permessage_deflate import (
    ClientPerMessageDeflateFactory, PerMessageDeflate,
    ServerPerMessageDeflateFactory
)
from .handshake import build_response
from .http import USER_AGENT, Headers, read_response
from .protocol import State
from .server import *
from .test_protocol import MS


# Avoid displaying stack traces at the ERROR logging level.
logging.basicConfig(level=logging.CRITICAL)


# Generate TLS certificate with:
# $ openssl req -x509 -config test_localhost.cnf -days 15340 -newkey rsa:2048 \
#       -out test_localhost.crt -keyout test_localhost.key
# $ cat test_localhost.key test_localhost.crt &gt; test_localhost.pem
# $ rm test_localhost.key test_localhost.crt

testcert = bytes(pathlib.Path(__file__).with_name('test_localhost.pem'))


</t>
<t tx="ekr.20181029161420.164">@asyncio.coroutine
def handler(ws, path):
    if path == '/attributes':
        yield from ws.send(repr((ws.host, ws.port, ws.secure)))
    elif path == '/path':
        yield from ws.send(str(ws.path))
    elif path == '/headers':
        yield from ws.send(repr(ws.request_headers))
        yield from ws.send(repr(ws.response_headers))
    elif path == '/extensions':
        yield from ws.send(repr(ws.extensions))
    elif path == '/subprotocol':
        yield from ws.send(repr(ws.subprotocol))
    elif path == '/slow_stop':
        try:
            yield from asyncio.sleep(1000 * MS)
        except asyncio.CancelledError:
            yield from asyncio.sleep(MS)
            raise
    else:
        yield from ws.send((yield from ws.recv()))


</t>
<t tx="ekr.20181029161420.165">@contextlib.contextmanager
def temp_test_server(test, **kwds):
    test.start_server(**kwds)
    try:
        yield
    finally:
        test.stop_server()


</t>
<t tx="ekr.20181029161420.166">@contextlib.contextmanager
def temp_test_client(test, *args, **kwds):
    test.start_client(*args, **kwds)
    try:
        yield
    finally:
        test.stop_client()


</t>
<t tx="ekr.20181029161420.167">def with_manager(manager, *args, **kwds):
    """
    Return a decorator that wraps a function with a context manager.

    """
    def decorate(func):
        def _decorate(self, *_args, **_kwds):
            with manager(self, *args, **kwds):
                return func(self, *_args, **_kwds)

        return _decorate

    return decorate


</t>
<t tx="ekr.20181029161420.168">@functools.wraps(func)
\\-8.def with_server(**kwds):
\\-8."""
\\-8.Return a decorator for TestCase methods that starts and stops a server.

\\-8."""
\\-8.return with_manager(temp_test_server, **kwds)


</t>
<t tx="ekr.20181029161420.169">def with_client(*args, **kwds):
    """
    Return a decorator for TestCase methods that starts and stops a client.

    """
    return with_manager(temp_test_client, *args, **kwds)


</t>
<t tx="ekr.20181029161420.170">def get_server_uri(server, secure=False, resource_name='/', user_info=None):
    """
    Return a WebSocket URI for connecting to the given server.

    """
    proto = 'wss' if secure else 'ws'

    user_info = ':'.join(user_info) + '@' if user_info else ''

    # Pick a random socket in order to test both IPv4 and IPv6 on systems
    # where both are available. Randomizing tests is usually a bad idea. If
    # needed, either use the first socket, or test separately IPv4 and IPv6.
    server_socket = random.choice(server.sockets)

    if server_socket.family == socket.AF_INET6:             # pragma: no cover
        host, port = server_socket.getsockname()[:2]        # (no IPv6 on CI)
        host = '[{}]'.format(host)
    elif server_socket.family == socket.AF_INET:
        host, port = server_socket.getsockname()
    elif server_socket.family == socket.AF_UNIX:
        # The host and port are ignored when connecting to a Unix socket.
        host, port = 'localhost', 0
    else:                                                   # pragma: no cover
        raise ValueError("Expected an IPv6, IPv4, or Unix socket")

    return '{}://{}{}:{}{}'.format(proto, user_info, host, port, resource_name)


</t>
<t tx="ekr.20181029161420.171">class UnauthorizedServerProtocol(WebSocketServerProtocol):

    @others
</t>
<t tx="ekr.20181029161420.172">@asyncio.coroutine
def process_request(self, path, request_headers):
    # Test returning headers as a Headers instance (1/3)
    return UNAUTHORIZED, Headers([('X-Access', 'denied')]), b''


</t>
<t tx="ekr.20181029161420.173">class ForbiddenServerProtocol(WebSocketServerProtocol):

    @others
</t>
<t tx="ekr.20181029161420.174">@asyncio.coroutine
def process_request(self, path, request_headers):
    # Test returning headers as a dict (2/3)
    return FORBIDDEN, {'X-Access': 'denied'}, b''


</t>
<t tx="ekr.20181029161420.175">class HealthCheckServerProtocol(WebSocketServerProtocol):

    @others
</t>
<t tx="ekr.20181029161420.176">@asyncio.coroutine
def process_request(self, path, request_headers):
    # Test returning headers as a list of pairs (3/3)
    if path == '/__health__/':
        return OK, [('X-Access', 'OK')], b'status = green\n'


</t>
<t tx="ekr.20181029161420.177">class FooClientProtocol(WebSocketClientProtocol):
    pass


</t>
<t tx="ekr.20181029161420.178">class BarClientProtocol(WebSocketClientProtocol):
    pass


</t>
<t tx="ekr.20181029161420.179">class ClientNoOpExtensionFactory:
    name = 'x-no-op'

    @others
</t>
<t tx="ekr.20181029161420.18">class InvalidHandshake(Exception):
    """
    Exception raised when a handshake request or response is invalid.

    """


</t>
<t tx="ekr.20181029161420.180">def get_request_params(self):
    return []

</t>
<t tx="ekr.20181029161420.181">def process_response_params(self, params, accepted_extensions):
    if params:
        raise NegotiationError()
    return NoOpExtension()


</t>
<t tx="ekr.20181029161420.182">class ServerNoOpExtensionFactory:
    name = 'x-no-op'

    @others
</t>
<t tx="ekr.20181029161420.183">def __init__(self, params=None):
    self.params = params or []

</t>
<t tx="ekr.20181029161420.184">def process_request_params(self, params, accepted_extensions):
    return self.params, NoOpExtension()


</t>
<t tx="ekr.20181029161420.185">class NoOpExtension:
    name = 'x-no-op'

    @others
</t>
<t tx="ekr.20181029161420.186">def __repr__(self):
    return 'NoOpExtension()'

</t>
<t tx="ekr.20181029161420.187">def decode(self, frame, *, max_size=None):
    return frame

</t>
<t tx="ekr.20181029161420.188">def encode(self, frame):
    return frame


</t>
<t tx="ekr.20181029161420.189">class ClientServerTests(unittest.TestCase):

    secure = False

    @others
</t>
<t tx="ekr.20181029161420.19">class AbortHandshake(InvalidHandshake):
    """
    Exception raised to abort a handshake and return a HTTP response.

    """
    @others
</t>
<t tx="ekr.20181029161420.190">def setUp(self):
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)

</t>
<t tx="ekr.20181029161420.191">def tearDown(self):
    self.loop.close()

</t>
<t tx="ekr.20181029161420.192">def run_loop_once(self):
    # Process callbacks scheduled with call_soon by appending a callback
    # to stop the event loop then running it until it hits that callback.
    self.loop.call_soon(self.loop.stop)
    self.loop.run_forever()

</t>
<t tx="ekr.20181029161420.193">def start_server(self, **kwds):
    # Don't enable compression by default in tests.
    kwds.setdefault('compression', None)
    start_server = serve(handler, 'localhost', 0, **kwds)
    self.server = self.loop.run_until_complete(start_server)

</t>
<t tx="ekr.20181029161420.194">def start_client(self, resource_name='/', user_info=None, **kwds):
    # Don't enable compression by default in tests.
    kwds.setdefault('compression', None)
    secure = kwds.get('ssl') is not None
    server_uri = get_server_uri(
        self.server, secure, resource_name, user_info)
    start_client = connect(server_uri, **kwds)
    self.client = self.loop.run_until_complete(start_client)

</t>
<t tx="ekr.20181029161420.195">def stop_client(self):
    try:
        self.loop.run_until_complete(
            asyncio.wait_for(self.client.close_connection_task, timeout=1))
    except asyncio.TimeoutError:                # pragma: no cover
        self.fail("Client failed to stop")

</t>
<t tx="ekr.20181029161420.196">def stop_server(self):
    self.server.close()
    try:
        self.loop.run_until_complete(
            asyncio.wait_for(self.server.wait_closed(), timeout=1))
    except asyncio.TimeoutError:                # pragma: no cover
        self.fail("Server failed to stop")

</t>
<t tx="ekr.20181029161420.197">@contextlib.contextmanager
def temp_server(self, **kwds):
    with temp_test_server(self, **kwds):
        yield

</t>
<t tx="ekr.20181029161420.198">@contextlib.contextmanager
def temp_client(self, *args, **kwds):
    with temp_test_client(self, *args, **kwds):
        yield

</t>
<t tx="ekr.20181029161420.199">@with_server()
@with_client()
def test_basic(self):
    self.loop.run_until_complete(self.client.send("Hello!"))
    reply = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(reply, "Hello!")

</t>
<t tx="ekr.20181029161420.2">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.client` module defines a simple WebSocket client API.

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.20">def __init__(self, status, headers, body=b''):
    self.status = status
    self.headers = headers
    self.body = body
    message = "HTTP {}, {} headers, {} bytes".format(
        status, len(headers), len(body))
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.200">def test_server_close_while_client_connected(self):
    with self.temp_server(loop=self.loop):
        # This endpoint waits just a bit when the connection is cancelled
        # in order to test that wait_closed() really waits for completion.
        self.start_client('/slow_stop')
    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.client.recv())
    # Connection ends with 1001 going away.
    self.assertEqual(self.client.close_code, 1001)

</t>
<t tx="ekr.20181029161420.201">def test_explicit_event_loop(self):
    with self.temp_server(loop=self.loop):
        with self.temp_client(loop=self.loop):
            self.loop.run_until_complete(self.client.send("Hello!"))
            reply = self.loop.run_until_complete(self.client.recv())
            self.assertEqual(reply, "Hello!")

# The way the legacy SSL implementation wraps sockets makes it extremely
# hard to write a test for Python 3.4.
</t>
<t tx="ekr.20181029161420.202">@unittest.skipIf(
    sys.version_info[:2] &lt;= (3, 4), 'this test requires Python 3.5+')
@with_server()
def test_explicit_socket(self):

    class TrackedSocket(socket.socket):
        def __init__(self, *args, **kwargs):
            self.used_for_read = False
            self.used_for_write = False
            super().__init__(*args, **kwargs)

        def recv(self, *args, **kwargs):
            self.used_for_read = True
            return super().recv(*args, **kwargs)

        def send(self, *args, **kwargs):
            self.used_for_write = True
            return super().send(*args, **kwargs)

    server_socket = [
        s for s in self.server.sockets if s.family == socket.AF_INET][0]
    client_socket = TrackedSocket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect(server_socket.getsockname())

    try:
        self.assertFalse(client_socket.used_for_read)
        self.assertFalse(client_socket.used_for_write)

        with self.temp_client(
            sock=client_socket,
            # "You must set server_hostname when using ssl without a host"
            server_hostname='localhost' if self.secure else None,
        ):
            self.loop.run_until_complete(self.client.send("Hello!"))
            reply = self.loop.run_until_complete(self.client.recv())
            self.assertEqual(reply, "Hello!")

        self.assertTrue(client_socket.used_for_read)
        self.assertTrue(client_socket.used_for_write)

    finally:
        client_socket.close()

</t>
<t tx="ekr.20181029161420.203">@unittest.skipUnless(
    hasattr(socket, 'AF_UNIX'), 'this test requires Unix sockets')
def test_unix_socket(self):
    with tempfile.TemporaryDirectory() as temp_dir:
        path = bytes(pathlib.Path(temp_dir) / 'websockets')

        # Like self.start_server() but with unix_serve().
        unix_server = unix_serve(handler, path)
        self.server = self.loop.run_until_complete(unix_server)

        client_socket = socket.socket(socket.AF_UNIX)
        client_socket.connect(path)

        try:
            with self.temp_client(sock=client_socket):
                self.loop.run_until_complete(self.client.send("Hello!"))
                reply = self.loop.run_until_complete(self.client.recv())
                self.assertEqual(reply, "Hello!")

        finally:
            client_socket.close()
            self.stop_server()

</t>
<t tx="ekr.20181029161420.204">@with_server()
@with_client('/attributes')
def test_protocol_attributes(self):
    # The test could be connecting with IPv6 or IPv4.
    expected_client_attrs = [
        server_socket.getsockname()[:2] + (self.secure,)
        for server_socket in self.server.sockets
    ]
    client_attrs = (self.client.host, self.client.port, self.client.secure)
    self.assertIn(client_attrs, expected_client_attrs)

    expected_server_attrs = ('localhost', 0, self.secure)
    server_attrs = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_attrs, repr(expected_server_attrs))

</t>
<t tx="ekr.20181029161420.205">@with_server()
@with_client('/path')
def test_protocol_path(self):
    client_path = self.client.path
    self.assertEqual(client_path, '/path')
    server_path = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_path, '/path')

</t>
<t tx="ekr.20181029161420.206">@with_server()
@with_client('/headers', user_info=('user', 'pass'))
def test_protocol_basic_auth(self):
    self.assertEqual(
        self.client.request_headers['Authorization'],
        'Basic dXNlcjpwYXNz',
    )

</t>
<t tx="ekr.20181029161420.207">@with_server()
@with_client('/headers')
def test_protocol_headers(self):
    client_req = self.client.request_headers
    client_resp = self.client.response_headers
    self.assertEqual(client_req['User-Agent'], USER_AGENT)
    self.assertEqual(client_resp['Server'], USER_AGENT)
    server_req = self.loop.run_until_complete(self.client.recv())
    server_resp = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_req, repr(client_req))
    self.assertEqual(server_resp, repr(client_resp))

</t>
<t tx="ekr.20181029161420.208">@with_server()
@with_client('/headers', extra_headers=Headers({'X-Spam': 'Eggs'}))
def test_protocol_custom_request_headers(self):
    req_headers = self.loop.run_until_complete(self.client.recv())
    self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", req_headers)

</t>
<t tx="ekr.20181029161420.209">@with_server()
@with_client('/headers', extra_headers={'X-Spam': 'Eggs'})
def test_protocol_custom_request_headers_dict(self):
    req_headers = self.loop.run_until_complete(self.client.recv())
    self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", req_headers)

</t>
<t tx="ekr.20181029161420.21">class InvalidMessage(InvalidHandshake):
    """
    Exception raised when the HTTP message in a handshake request is malformed.

    """


</t>
<t tx="ekr.20181029161420.210">@with_server()
@with_client('/headers', extra_headers=[('X-Spam', 'Eggs')])
def test_protocol_custom_request_headers_list(self):
    req_headers = self.loop.run_until_complete(self.client.recv())
    self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", req_headers)

</t>
<t tx="ekr.20181029161420.211">@with_server()
@with_client('/headers', extra_headers=[('User-Agent', 'Eggs')])
def test_protocol_custom_request_user_agent(self):
    req_headers = self.loop.run_until_complete(self.client.recv())
    self.loop.run_until_complete(self.client.recv())
    self.assertEqual(req_headers.count("User-Agent"), 1)
    self.assertIn("('User-Agent', 'Eggs')", req_headers)

</t>
<t tx="ekr.20181029161420.212">@with_server(extra_headers=lambda p, r: Headers({'X-Spam': 'Eggs'}))
@with_client('/headers')
def test_protocol_custom_response_headers_callable(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.213">@with_server(extra_headers=lambda p, r: {'X-Spam': 'Eggs'})
@with_client('/headers')
def test_protocol_custom_response_headers_callable_dict(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.214">@with_server(extra_headers=lambda p, r: [('X-Spam', 'Eggs')])
@with_client('/headers')
def test_protocol_custom_response_headers_callable_list(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.215">@with_server(extra_headers=Headers({'X-Spam': 'Eggs'}))
@with_client('/headers')
def test_protocol_custom_response_headers(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.216">@with_server(extra_headers={'X-Spam': 'Eggs'})
@with_client('/headers')
def test_protocol_custom_response_headers_dict(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.217">@with_server(extra_headers=[('X-Spam', 'Eggs')])
@with_client('/headers')
def test_protocol_custom_response_headers_list(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertIn("('X-Spam', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.218">@with_server(extra_headers=[('Server', 'Eggs')])
@with_client('/headers')
def test_protocol_custom_response_user_agent(self):
    self.loop.run_until_complete(self.client.recv())
    resp_headers = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(resp_headers.count("Server"), 1)
    self.assertIn("('Server', 'Eggs')", resp_headers)

</t>
<t tx="ekr.20181029161420.219">def make_http_request(self, path='/'):
    # Set url to 'https?://&lt;host&gt;:&lt;port&gt;&lt;path&gt;'.
    url = get_server_uri(
        self.server, resource_name=path, secure=self.secure)
    url = url.replace('ws', 'http')

    if self.secure:
        open_health_check = functools.partial(
            urllib.request.urlopen, url, context=self.client_context)
    else:
        open_health_check = functools.partial(
            urllib.request.urlopen, url)

    return self.loop.run_in_executor(None, open_health_check)

</t>
<t tx="ekr.20181029161420.22">class InvalidHeader(InvalidHandshake):
    """
    Exception raised when a HTTP header doesn't have a valid format or value.

    """
    @others
</t>
<t tx="ekr.20181029161420.220">@with_server(create_protocol=HealthCheckServerProtocol)
def test_http_request_http_endpoint(self):
    # Making a HTTP request to a HTTP endpoint succeeds.
    response = self.loop.run_until_complete(
        self.make_http_request('/__health__/'))

    with contextlib.closing(response):
        self.assertEqual(response.code, 200)
        self.assertEqual(response.read(), b'status = green\n')

</t>
<t tx="ekr.20181029161420.221">@with_server(create_protocol=HealthCheckServerProtocol)
def test_http_request_ws_endpoint(self):
    # Making a HTTP request to a WS endpoint fails.
    with self.assertRaises(urllib.error.HTTPError) as raised:
        self.loop.run_until_complete(self.make_http_request())

    self.assertEqual(raised.exception.code, 426)
    self.assertEqual(raised.exception.headers['Upgrade'], 'websocket')

</t>
<t tx="ekr.20181029161420.222">@with_server(create_protocol=HealthCheckServerProtocol)
def test_ws_connection_http_endpoint(self):
    # Making a WS connection to a HTTP endpoint fails.
    with self.assertRaises(InvalidStatusCode) as raised:
        self.start_client('/__health__/')

    self.assertEqual(raised.exception.status_code, 200)

</t>
<t tx="ekr.20181029161420.223">@with_server(create_protocol=HealthCheckServerProtocol)
def test_ws_connection_ws_endpoint(self):
    # Making a WS connection to a WS endpoint succeeds.
    self.start_client()
    self.loop.run_until_complete(self.client.send("Hello!"))
    self.loop.run_until_complete(self.client.recv())
    self.stop_client()

</t>
<t tx="ekr.20181029161420.224">def assert_client_raises_code(self, status_code):
    with self.assertRaises(InvalidStatusCode) as raised:
        self.start_client()
    self.assertEqual(raised.exception.status_code, status_code)

</t>
<t tx="ekr.20181029161420.225">@with_server(create_protocol=UnauthorizedServerProtocol)
def test_server_create_protocol(self):
    self.assert_client_raises_code(401)

</t>
<t tx="ekr.20181029161420.226">@with_server(create_protocol=(lambda *args, **kwargs:
             UnauthorizedServerProtocol(*args, **kwargs)))
def test_server_create_protocol_function(self):
    self.assert_client_raises_code(401)

</t>
<t tx="ekr.20181029161420.227">@with_server(klass=UnauthorizedServerProtocol)
def test_server_klass(self):
    self.assert_client_raises_code(401)

</t>
<t tx="ekr.20181029161420.228">@with_server(create_protocol=ForbiddenServerProtocol,
             klass=UnauthorizedServerProtocol)
def test_server_create_protocol_over_klass(self):
    self.assert_client_raises_code(403)

</t>
<t tx="ekr.20181029161420.229">@with_server()
@with_client('/path', create_protocol=FooClientProtocol)
def test_client_create_protocol(self):
    self.assertIsInstance(self.client, FooClientProtocol)

</t>
<t tx="ekr.20181029161420.23">def __init__(self, name, value):
    if value:
        message = "Invalid {} header: {}".format(name, value)
    else:
        message = "Missing or empty {} header".format(name)
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.230">@with_server()
@with_client('/path', create_protocol=(
             lambda *args, **kwargs: FooClientProtocol(*args, **kwargs)))
def test_client_create_protocol_function(self):
    self.assertIsInstance(self.client, FooClientProtocol)

</t>
<t tx="ekr.20181029161420.231">@with_server()
@with_client('/path', klass=FooClientProtocol)
def test_client_klass(self):
    self.assertIsInstance(self.client, FooClientProtocol)

</t>
<t tx="ekr.20181029161420.232">@with_server()
@with_client('/path', create_protocol=BarClientProtocol,
             klass=FooClientProtocol)
def test_client_create_protocol_over_klass(self):
    self.assertIsInstance(self.client, BarClientProtocol)

</t>
<t tx="ekr.20181029161420.233">@with_server()
@with_client('/extensions')
def test_no_extension(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([]))
    self.assertEqual(repr(self.client.extensions), repr([]))

</t>
<t tx="ekr.20181029161420.234">@with_server(extensions=[ServerNoOpExtensionFactory()])
@with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])
def test_extension(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([NoOpExtension()]))
    self.assertEqual(repr(self.client.extensions), repr([NoOpExtension()]))

</t>
<t tx="ekr.20181029161420.235">@with_server()
@with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])
def test_extension_not_accepted(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([]))
    self.assertEqual(repr(self.client.extensions), repr([]))

</t>
<t tx="ekr.20181029161420.236">@with_server(extensions=[ServerNoOpExtensionFactory()])
@with_client('/extensions')
def test_extension_not_requested(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([]))
    self.assertEqual(repr(self.client.extensions), repr([]))

</t>
<t tx="ekr.20181029161420.237">@with_server(extensions=[ServerNoOpExtensionFactory([('foo', None)])])
def test_extension_client_rejection(self):
    with self.assertRaises(NegotiationError):
        self.start_client(
            '/extensions',
            extensions=[ClientNoOpExtensionFactory()],
        )

</t>
<t tx="ekr.20181029161420.238">@with_server(
    extensions=[
        # No match because the client doesn't send client_max_window_bits.
        ServerPerMessageDeflateFactory(client_max_window_bits=10),
        ServerPerMessageDeflateFactory(),
    ],
)
@with_client(
    '/extensions',
    extensions=[
        ClientPerMessageDeflateFactory(),
    ],
)
def test_extension_no_match_then_match(self):
    # The order requested by the client has priority.
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([
        PerMessageDeflate(False, False, 15, 15),
    ]))
    self.assertEqual(repr(self.client.extensions), repr([
        PerMessageDeflate(False, False, 15, 15),
    ]))

</t>
<t tx="ekr.20181029161420.239">@with_server(extensions=[ServerPerMessageDeflateFactory()])
@with_client('/extensions', extensions=[ClientNoOpExtensionFactory()])
def test_extension_mismatch(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([]))
    self.assertEqual(repr(self.client.extensions), repr([]))

</t>
<t tx="ekr.20181029161420.24">class InvalidHeaderFormat(InvalidHeader):
    """
    Exception raised when a Sec-WebSocket-* HTTP header cannot be parsed.

    """
    @others
</t>
<t tx="ekr.20181029161420.240">@with_server(
    extensions=[
        ServerNoOpExtensionFactory(),
        ServerPerMessageDeflateFactory(),
    ],
)
@with_client(
    '/extensions',
    extensions=[
        ClientPerMessageDeflateFactory(),
        ClientNoOpExtensionFactory(),
    ],
)
def test_extension_order(self):
    # The order requested by the client has priority.
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([
        PerMessageDeflate(False, False, 15, 15),
        NoOpExtension(),
    ]))
    self.assertEqual(repr(self.client.extensions), repr([
        PerMessageDeflate(False, False, 15, 15),
        NoOpExtension(),
    ]))

</t>
<t tx="ekr.20181029161420.241">@with_server(extensions=[ServerNoOpExtensionFactory()])
@unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')
def test_extensions_error(self, _process_extensions):
    _process_extensions.return_value = 'x-no-op', [NoOpExtension()]

    with self.assertRaises(NegotiationError):
        self.start_client(
            '/extensions',
            extensions=[ClientPerMessageDeflateFactory()],
        )

</t>
<t tx="ekr.20181029161420.242">@with_server(extensions=[ServerNoOpExtensionFactory()])
@unittest.mock.patch.object(WebSocketServerProtocol, 'process_extensions')
def test_extensions_error_no_extensions(self, _process_extensions):
    _process_extensions.return_value = 'x-no-op', [NoOpExtension()]

    with self.assertRaises(InvalidHandshake):
        self.start_client('/extensions')

</t>
<t tx="ekr.20181029161420.243">@with_server(compression='deflate')
@with_client('/extensions', compression='deflate')
def test_compression_deflate(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([
        PerMessageDeflate(False, False, 15, 15),
    ]))
    self.assertEqual(repr(self.client.extensions), repr([
        PerMessageDeflate(False, False, 15, 15),
    ]))

</t>
<t tx="ekr.20181029161420.244">@with_server(
    extensions=[
        ServerPerMessageDeflateFactory(
            client_no_context_takeover=True,
            server_max_window_bits=10,
        ),
    ],
    compression='deflate',  # overridden by explicit config
)
@with_client(
    '/extensions',
    extensions=[
        ClientPerMessageDeflateFactory(
            server_no_context_takeover=True,
            client_max_window_bits=12,
        ),
    ],
    compression='deflate',  # overridden by explicit config
)
def test_compression_deflate_and_explicit_config(self):
    server_extensions = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_extensions, repr([
        PerMessageDeflate(True, True, 12, 10),
    ]))
    self.assertEqual(repr(self.client.extensions), repr([
        PerMessageDeflate(True, True, 10, 12),
    ]))

</t>
<t tx="ekr.20181029161420.245">def test_compression_unsupported_server(self):
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(self.start_server(compression='xz'))

</t>
<t tx="ekr.20181029161420.246">@with_server()
def test_compression_unsupported_client(self):
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(self.start_client(compression='xz'))

</t>
<t tx="ekr.20181029161420.247">@with_server()
@with_client('/subprotocol')
def test_no_subprotocol(self):
    server_subprotocol = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_subprotocol, repr(None))
    self.assertEqual(self.client.subprotocol, None)

</t>
<t tx="ekr.20181029161420.248">@with_server(subprotocols=['superchat', 'chat'])
@with_client('/subprotocol', subprotocols=['otherchat', 'chat'])
def test_subprotocol(self):
    server_subprotocol = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_subprotocol, repr('chat'))
    self.assertEqual(self.client.subprotocol, 'chat')

</t>
<t tx="ekr.20181029161420.249">@with_server(subprotocols=['superchat'])
@with_client('/subprotocol', subprotocols=['otherchat'])
def test_subprotocol_not_accepted(self):
    server_subprotocol = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_subprotocol, repr(None))
    self.assertEqual(self.client.subprotocol, None)

</t>
<t tx="ekr.20181029161420.25">def __init__(self, name, error, string, pos):
    error = "{} at {} in {}".format(error, pos, string)
    super().__init__(name, error)


</t>
<t tx="ekr.20181029161420.250">@with_server()
@with_client('/subprotocol', subprotocols=['otherchat', 'chat'])
def test_subprotocol_not_offered(self):
    server_subprotocol = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_subprotocol, repr(None))
    self.assertEqual(self.client.subprotocol, None)

</t>
<t tx="ekr.20181029161420.251">@with_server(subprotocols=['superchat', 'chat'])
@with_client('/subprotocol')
def test_subprotocol_not_requested(self):
    server_subprotocol = self.loop.run_until_complete(self.client.recv())
    self.assertEqual(server_subprotocol, repr(None))
    self.assertEqual(self.client.subprotocol, None)

</t>
<t tx="ekr.20181029161420.252">@with_server(subprotocols=['superchat'])
@unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')
def test_subprotocol_error(self, _process_subprotocol):
    _process_subprotocol.return_value = 'superchat'

    with self.assertRaises(NegotiationError):
        self.start_client('/subprotocol', subprotocols=['otherchat'])
    self.run_loop_once()

</t>
<t tx="ekr.20181029161420.253">@with_server(subprotocols=['superchat'])
@unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')
def test_subprotocol_error_no_subprotocols(self, _process_subprotocol):
    _process_subprotocol.return_value = 'superchat'

    with self.assertRaises(InvalidHandshake):
        self.start_client('/subprotocol')
    self.run_loop_once()

</t>
<t tx="ekr.20181029161420.254">@with_server(subprotocols=['superchat', 'chat'])
@unittest.mock.patch.object(WebSocketServerProtocol, 'process_subprotocol')
def test_subprotocol_error_two_subprotocols(self, _process_subprotocol):
    _process_subprotocol.return_value = 'superchat, chat'

    with self.assertRaises(InvalidHandshake):
        self.start_client(
            '/subprotocol', subprotocols=['superchat', 'chat'])
    self.run_loop_once()

</t>
<t tx="ekr.20181029161420.255">@with_server()
@unittest.mock.patch('websockets.server.read_request')
def test_server_receives_malformed_request(self, _read_request):
    _read_request.side_effect = ValueError("read_request failed")

    with self.assertRaises(InvalidHandshake):
        self.start_client()

</t>
<t tx="ekr.20181029161420.256">@with_server()
@unittest.mock.patch('websockets.client.read_response')
def test_client_receives_malformed_response(self, _read_response):
    _read_response.side_effect = ValueError("read_response failed")

    with self.assertRaises(InvalidHandshake):
        self.start_client()
    self.run_loop_once()

</t>
<t tx="ekr.20181029161420.257">@with_server()
@unittest.mock.patch('websockets.client.build_request')
def test_client_sends_invalid_handshake_request(self, _build_request):
    def wrong_build_request(headers):
        return '42'
    _build_request.side_effect = wrong_build_request

    with self.assertRaises(InvalidHandshake):
        self.start_client()

</t>
<t tx="ekr.20181029161420.258">@with_server()
@unittest.mock.patch('websockets.server.build_response')
def test_server_sends_invalid_handshake_response(self, _build_response):
    def wrong_build_response(headers, key):
        return build_response(headers, '42')
    _build_response.side_effect = wrong_build_response

    with self.assertRaises(InvalidHandshake):
        self.start_client()

</t>
<t tx="ekr.20181029161420.259">@with_server()
@unittest.mock.patch('websockets.client.read_response')
def test_server_does_not_switch_protocols(self, _read_response):
    def wrong_read_response(stream):
        status_code, headers = yield from read_response(stream)
        return 400, headers
    _read_response.side_effect = wrong_read_response

    with self.assertRaises(InvalidStatusCode):
        self.start_client()
    self.run_loop_once()

</t>
<t tx="ekr.20181029161420.26">class InvalidHeaderValue(InvalidHeader):
    """
    Exception raised when a Sec-WebSocket-* HTTP header has a wrong value.

    """


</t>
<t tx="ekr.20181029161420.260">@with_server()
@unittest.mock.patch(
    'websockets.server.WebSocketServerProtocol.process_request')
def test_server_error_in_handshake(self, _process_request):
    _process_request.side_effect = Exception("process_request crashed")

    with self.assertRaises(InvalidHandshake):
        self.start_client()

</t>
<t tx="ekr.20181029161420.261">@with_server()
@unittest.mock.patch('websockets.server.WebSocketServerProtocol.send')
def test_server_handler_crashes(self, send):
    send.side_effect = ValueError("send failed")

    with self.temp_client():
        self.loop.run_until_complete(self.client.send("Hello!"))
        with self.assertRaises(ConnectionClosed):
            self.loop.run_until_complete(self.client.recv())

    # Connection ends with an unexpected error.
    self.assertEqual(self.client.close_code, 1011)

</t>
<t tx="ekr.20181029161420.262">@with_server()
@unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')
def test_server_close_crashes(self, close):
    close.side_effect = ValueError("close failed")

    with self.temp_client():
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, "Hello!")

    # Connection ends with an abnormal closure.
    self.assertEqual(self.client.close_code, 1006)

</t>
<t tx="ekr.20181029161420.263">@with_server()
@with_client()
@unittest.mock.patch.object(WebSocketClientProtocol, 'handshake')
def test_client_closes_connection_before_handshake(self, handshake):
    # We have mocked the handshake() method to prevent the client from
    # performing the opening handshake. Force it to close the connection.
    self.client.writer.close()
    # The server should stop properly anyway. It used to hang because the
    # task handling the connection was waiting for the opening handshake.

</t>
<t tx="ekr.20181029161420.264">@with_server()
@unittest.mock.patch('websockets.server.read_request')
def test_server_shuts_down_during_opening_handshake(self, _read_request):
    _read_request.side_effect = asyncio.CancelledError

    self.server.closing = True
    with self.assertRaises(InvalidHandshake) as raised:
        self.start_client()

    # Opening handshake fails with 503 Service Unavailable
    self.assertEqual(str(raised.exception), "Status code not 101: 503")

</t>
<t tx="ekr.20181029161420.265">@with_server()
def test_server_shuts_down_during_connection_handling(self):
    with self.temp_client():
        self.server.close()
        with self.assertRaises(ConnectionClosed):
            self.loop.run_until_complete(self.client.recv())

    # Websocket connection terminates with 1001 Going Away.
    self.assertEqual(self.client.close_code, 1001)

</t>
<t tx="ekr.20181029161420.266">@with_server()
@unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')
def test_server_shuts_down_during_connection_close(self, _close):
    _close.side_effect = asyncio.CancelledError

    self.server.closing = True
    with self.temp_client():
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, "Hello!")

    # Websocket connection terminates abnormally.
    self.assertEqual(self.client.close_code, 1006)

</t>
<t tx="ekr.20181029161420.267">@with_server(create_protocol=ForbiddenServerProtocol)
def test_invalid_status_error_during_client_connect(self):
    with self.assertRaises(InvalidStatusCode) as raised:
        self.start_client()
    exception = raised.exception
    self.assertEqual(str(exception), "Status code not 101: 403")
    self.assertEqual(exception.status_code, 403)

</t>
<t tx="ekr.20181029161420.268">@with_server()
@unittest.mock.patch(
    'websockets.server.WebSocketServerProtocol.write_http_response')
@unittest.mock.patch(
    'websockets.server.WebSocketServerProtocol.read_http_request')
def test_connection_error_during_opening_handshake(
        self, _read_http_request, _write_http_response):
    _read_http_request.side_effect = ConnectionError

    # This exception is currently platform-dependent. It was observed to
    # be ConnectionResetError on Linux in the non-SSL case, and
    # InvalidMessage otherwise (including both Linux and macOS). This
    # doesn't matter though since this test is primarily for testing a
    # code path on the server side.
    with self.assertRaises(Exception):
        self.start_client()

    # No response must not be written if the network connection is broken.
    _write_http_response.assert_not_called()

</t>
<t tx="ekr.20181029161420.269">@with_server()
@unittest.mock.patch('websockets.server.WebSocketServerProtocol.close')
def test_connection_error_during_closing_handshake(self, close):
    close.side_effect = ConnectionError

    with self.temp_client():
        self.loop.run_until_complete(self.client.send("Hello!"))
        reply = self.loop.run_until_complete(self.client.recv())
        self.assertEqual(reply, "Hello!")

    # Connection ends with an abnormal closure.
    self.assertEqual(self.client.close_code, 1006)


</t>
<t tx="ekr.20181029161420.27">class InvalidUpgrade(InvalidHeader):
    """
    Exception raised when a Upgrade or Connection header isn't correct.

    """


</t>
<t tx="ekr.20181029161420.270">class SSLClientServerTests(ClientServerTests):

    secure = True

    @others
</t>
<t tx="ekr.20181029161420.271">@property
def server_context(self):
    # Change to ssl.PROTOCOL_TLS_SERVER when dropping Python &lt; 3.6.
    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
    ssl_context.load_cert_chain(testcert)
    return ssl_context

</t>
<t tx="ekr.20181029161420.272">@property
def client_context(self):
    # Change to ssl.PROTOCOL_TLS_CLIENT when dropping Python &lt; 3.6.
    # Then remove verify_mode and check_hostname below.
    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
    ssl_context.load_verify_locations(testcert)
    ssl_context.verify_mode = ssl.CERT_REQUIRED
    # ssl.match_hostname can't match IP addresses on Python &lt; 3.5.
    # We're using IP addresses to enforce testing of IPv4 and IPv6.
    if sys.version_info[:2] &gt;= (3, 5):                  # pragma: no cover
        ssl_context.check_hostname = True
    return ssl_context

</t>
<t tx="ekr.20181029161420.273">def start_server(self, **kwds):
    kwds.setdefault('ssl', self.server_context)
    super().start_server(**kwds)

</t>
<t tx="ekr.20181029161420.274">def start_client(self, path='/', **kwds):
    kwds.setdefault('ssl', self.client_context)
    super().start_client(path, **kwds)

# TLS over Unix sockets doesn't make sense.
test_unix_socket = None

</t>
<t tx="ekr.20181029161420.275">@with_server()
def test_ws_uri_is_rejected(self):
    with self.assertRaises(ValueError):
        client = connect(
            get_server_uri(self.server, secure=False),
            ssl=self.client_context,
        )
        # With Python  3.5, the exception is raised by connect() even
        # before awaiting.  However, with Python 3.4 the exception is
        # raised only when awaiting.
        self.loop.run_until_complete(client)          # pragma: no cover


</t>
<t tx="ekr.20181029161420.276">class ClientServerOriginTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.277">def setUp(self):
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)

</t>
<t tx="ekr.20181029161420.278">def tearDown(self):
    self.loop.close()

</t>
<t tx="ekr.20181029161420.279">def test_checking_origin_succeeds(self):
    server = self.loop.run_until_complete(
        serve(handler, 'localhost', 0, origins=['http://localhost']))
    client = self.loop.run_until_complete(
        connect(get_server_uri(server), origin='http://localhost'))

    self.loop.run_until_complete(client.send("Hello!"))
    self.assertEqual(self.loop.run_until_complete(client.recv()), "Hello!")

    self.loop.run_until_complete(client.close())
    server.close()
    self.loop.run_until_complete(server.wait_closed())

</t>
<t tx="ekr.20181029161420.28">class InvalidOrigin(InvalidHeader):
    """
    Exception raised when the Origin header in a request isn't allowed.

    """
    @others
</t>
<t tx="ekr.20181029161420.280">def test_checking_origin_fails(self):
    server = self.loop.run_until_complete(
        serve(handler, 'localhost', 0, origins=['http://localhost']))
    with self.assertRaisesRegex(InvalidHandshake,
                                "Status code not 101: 403"):
        self.loop.run_until_complete(
            connect(get_server_uri(server), origin='http://otherhost'))

    server.close()
    self.loop.run_until_complete(server.wait_closed())

</t>
<t tx="ekr.20181029161420.281">def test_checking_lack_of_origin_succeeds(self):
    server = self.loop.run_until_complete(
        serve(handler, 'localhost', 0, origins=['']))
    client = self.loop.run_until_complete(connect(get_server_uri(server)))

    self.loop.run_until_complete(client.send("Hello!"))
    self.assertEqual(self.loop.run_until_complete(client.recv()), "Hello!")

    self.loop.run_until_complete(client.close())
    server.close()
    self.loop.run_until_complete(server.wait_closed())


</t>
<t tx="ekr.20181029161420.282">class YieldFromTests(unittest.TestCase):

    @others
if sys.version_info[:2] &gt;= (3, 5):                          # pragma: no cover
    from .py35._test_client_server import AsyncAwaitTests               # noqa
    from .py35._test_client_server import ContextManagerTests           # noqa


if sys.version_info[:2] &gt;= (3, 6):                          # pragma: no cover
    from .py36._test_client_server import AsyncIteratorTests            # noqa
</t>
<t tx="ekr.20181029161420.283">def setUp(self):
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)

</t>
<t tx="ekr.20181029161420.284">def tearDown(self):
    self.loop.close()

</t>
<t tx="ekr.20181029161420.285">def test_client(self):
    start_server = serve(handler, 'localhost', 0)
    server = self.loop.run_until_complete(start_server)

    def run_client():
        # Yield from connect.
        client = yield from connect(get_server_uri(server))
        self.assertEqual(client.state, State.OPEN)
        yield from client.close()
        self.assertEqual(client.state, State.CLOSED)

    self.loop.run_until_complete(run_client())

    server.close()
    self.loop.run_until_complete(server.wait_closed())

</t>
<t tx="ekr.20181029161420.286">@asyncio.coroutine
\\-8.def test_server(self):

def run_server():
    # Yield from serve.
    server = yield from serve(handler, 'localhost', 0)
    self.assertTrue(server.sockets)
    server.close()
    yield from server.wait_closed()
    self.assertFalse(server.sockets)

self.loop.run_until_complete(run_server())


</t>
<t tx="ekr.20181029161420.287">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.288">import unittest

from .exceptions import *
from .http import Headers


</t>
<t tx="ekr.20181029161420.289">class ExceptionsTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.29">def __init__(self, origin):
    super().__init__('Origin', origin)


</t>
<t tx="ekr.20181029161420.290">def test_str(self):
    for exception, exception_str in [
        (
            InvalidHandshake("Invalid request"),
            "Invalid request",
        ),
        (
            AbortHandshake(200, Headers(), b'OK\n'),
            "HTTP 200, 0 headers, 3 bytes",
        ),
        (
            InvalidMessage("Malformed HTTP message"),
            "Malformed HTTP message",
        ),
        (
            InvalidHeader('Name', ''),
            "Missing or empty Name header",
        ),
        (
            InvalidHeader('Name', 'Value'),
            "Invalid Name header: Value",
        ),
        (
            InvalidHeaderFormat(
                'Sec-WebSocket-Protocol', "expected token", 'a=|', 3),
            "Invalid Sec-WebSocket-Protocol header: "
            "expected token at 3 in a=|",
        ),
        (
            InvalidHeaderValue('Sec-WebSocket-Version', '42'),
            "Invalid Sec-WebSocket-Version header: 42",
        ),

        (
            InvalidUpgrade('Upgrade', ''),
            "Missing or empty Upgrade header",
        ),
        (
            InvalidUpgrade('Connection', 'websocket'),
            "Invalid Connection header: websocket",
        ),
        (
            InvalidOrigin('http://bad.origin'),
            'Invalid Origin header: http://bad.origin',
        ),
        (
            InvalidStatusCode(403),
            "Status code not 101: 403",
        ),
        (
            NegotiationError("Unsupported subprotocol: spam"),
            "Unsupported subprotocol: spam",
        ),
        (
            InvalidParameterName('|'),
            "Invalid parameter name: |",
        ),
        (
            InvalidParameterValue('a', '|'),
            "Invalid value for parameter a: |",
        ),
        (
            DuplicateParameter('a'),
            "Duplicate parameter: a",
        ),
        (
            InvalidState("WebSocket connection isn't established yet"),
            "WebSocket connection isn't established yet",
        ),
        (
            ConnectionClosed(1000, ''),
            "WebSocket connection is closed: code = 1000 "
            "(OK), no reason",
        ),
        (
            ConnectionClosed(1001, 'bye'),
            "WebSocket connection is closed: code = 1001 "
            "(going away), reason = bye",
        ),
        (
            ConnectionClosed(1006, None),
            "WebSocket connection is closed: code = 1006 "
            "(connection closed abnormally [internal]), no reason"
        ),
        (
            ConnectionClosed(1016, None),
            "WebSocket connection is closed: code = 1016 "
            "(unknown), no reason"
        ),
        (
            ConnectionClosed(3000, None),
            "WebSocket connection is closed: code = 3000 "
            "(registered), no reason"
        ),
        (
            ConnectionClosed(4000, None),
            "WebSocket connection is closed: code = 4000 "
            "(private use), no reason"
        ),
        (
            InvalidURI("| isn't a valid URI"),
            "| isn't a valid URI",
        ),
        (
            PayloadTooBig("Payload length exceeds limit: 2 &gt; 1 bytes"),
            "Payload length exceeds limit: 2 &gt; 1 bytes",
        ),
        (
            WebSocketProtocolError("Invalid opcode: 7"),
            "Invalid opcode: 7",
        ),
    ]:
        with self.subTest(exception=exception):
            self.assertEqual(str(exception), exception_str)
</t>
<t tx="ekr.20181029161420.291">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20181029161420.292">import asyncio
import codecs
import unittest
import unittest.mock

from .exceptions import PayloadTooBig, WebSocketProtocolError
from .framing import *


</t>
<t tx="ekr.20181029161420.293">class FramingTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.294">def setUp(self):
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)

</t>
<t tx="ekr.20181029161420.295">def tearDown(self):
    self.loop.close()

</t>
<t tx="ekr.20181029161420.296">def decode(self, message, mask=False, max_size=None, extensions=None):
    self.stream = asyncio.StreamReader(loop=self.loop)
    self.stream.feed_data(message)
    self.stream.feed_eof()
    frame = self.loop.run_until_complete(Frame.read(
        self.stream.readexactly, mask=mask,
        max_size=max_size, extensions=extensions,
    ))
    # Make sure all the data was consumed.
    self.assertTrue(self.stream.at_eof())
    return frame

</t>
<t tx="ekr.20181029161420.297">def encode(self, frame, mask=False, extensions=None):
    writer = unittest.mock.Mock()
    frame.write(writer, mask=mask, extensions=extensions)
    # Ensure the entire frame is sent with a single call to writer().
    # Multiple calls cause TCP fragmentation and degrade performance.
    self.assertEqual(writer.call_count, 1)
    # The frame data is the single positional argument of that call.
    self.assertEqual(len(writer.call_args[0]), 1)
    self.assertEqual(len(writer.call_args[1]), 0)
    return writer.call_args[0][0]

</t>
<t tx="ekr.20181029161420.298">def round_trip(self, message, expected, mask=False, extensions=None):
    decoded = self.decode(message, mask, extensions=extensions)
    self.assertEqual(decoded, expected)
    encoded = self.encode(decoded, mask, extensions=extensions)
    if mask:    # non-deterministic encoding
        decoded = self.decode(encoded, mask, extensions=extensions)
        self.assertEqual(decoded, expected)
    else:       # deterministic encoding
        self.assertEqual(encoded, message)

</t>
<t tx="ekr.20181029161420.299">def round_trip_close(self, data, code, reason):
    parsed = parse_close(data)
    self.assertEqual(parsed, (code, reason))
    serialized = serialize_close(code, reason)
    self.assertEqual(serialized, data)

</t>
<t tx="ekr.20181029161420.3">import asyncio
import collections.abc
import sys

from .exceptions import (
    InvalidHandshake, InvalidMessage, InvalidStatusCode, NegotiationError
)
from .extensions.permessage_deflate import ClientPerMessageDeflateFactory
from .handshake import build_request, check_response
from .headers import (
    build_basic_auth, build_extension_list, build_subprotocol_list,
    parse_extension_list, parse_subprotocol_list
)
from .http import USER_AGENT, Headers, read_response
from .protocol import WebSocketCommonProtocol
from .uri import parse_uri


__all__ = ['connect', 'WebSocketClientProtocol']


</t>
<t tx="ekr.20181029161420.30">class InvalidStatusCode(InvalidHandshake):
    """
    Exception raised when a handshake response status code is invalid.

    Provides the integer status code in its ``status_code`` attribute.

    """
    @others
</t>
<t tx="ekr.20181029161420.300">def test_text(self):
    self.round_trip(
        b'\x81\x04Spam',
        Frame(True, OP_TEXT, b'Spam'),
    )

</t>
<t tx="ekr.20181029161420.301">def test_text_masked(self):
    self.round_trip(
        b'\x81\x84\x5b\xfb\xe1\xa8\x08\x8b\x80\xc5',
        Frame(True, OP_TEXT, b'Spam'),
        mask=True,
    )

</t>
<t tx="ekr.20181029161420.302">def test_binary(self):
    self.round_trip(
        b'\x82\x04Eggs',
        Frame(True, OP_BINARY, b'Eggs'),
    )

</t>
<t tx="ekr.20181029161420.303">def test_binary_masked(self):
    self.round_trip(
        b'\x82\x84\x53\xcd\xe2\x89\x16\xaa\x85\xfa',
        Frame(True, OP_BINARY, b'Eggs'),
        mask=True,
    )

</t>
<t tx="ekr.20181029161420.304">def test_non_ascii_text(self):
    self.round_trip(
        b'\x81\x05caf\xc3\xa9',
        Frame(True, OP_TEXT, 'caf'.encode('utf-8')),
    )

</t>
<t tx="ekr.20181029161420.305">def test_non_ascii_text_masked(self):
    self.round_trip(
        b'\x81\x85\x64\xbe\xee\x7e\x07\xdf\x88\xbd\xcd',
        Frame(True, OP_TEXT, 'caf'.encode('utf-8')),
        mask=True,
    )

</t>
<t tx="ekr.20181029161420.306">def test_close(self):
    self.round_trip(
        b'\x88\x00',
        Frame(True, OP_CLOSE, b''),
    )

</t>
<t tx="ekr.20181029161420.307">def test_ping(self):
    self.round_trip(
        b'\x89\x04ping',
        Frame(True, OP_PING, b'ping'),
    )

</t>
<t tx="ekr.20181029161420.308">def test_pong(self):
    self.round_trip(
        b'\x8a\x04pong',
        Frame(True, OP_PONG, b'pong'),
    )

</t>
<t tx="ekr.20181029161420.309">def test_long(self):
    self.round_trip(
        b'\x82\x7e\x00\x7e' + 126 * b'a',
        Frame(True, OP_BINARY, 126 * b'a'),
    )

</t>
<t tx="ekr.20181029161420.31">def __init__(self, status_code):
    self.status_code = status_code
    message = "Status code not 101: {}".format(status_code)
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.310">def test_very_long(self):
    self.round_trip(
        b'\x82\x7f\x00\x00\x00\x00\x00\x01\x00\x00' + 65536 * b'a',
        Frame(True, OP_BINARY, 65536 * b'a'),
    )

</t>
<t tx="ekr.20181029161420.311">def test_payload_too_big(self):
    with self.assertRaises(PayloadTooBig):
        self.decode(
            b'\x82\x7e\x04\x01' + 1025 * b'a',
            max_size=1024,
        )

</t>
<t tx="ekr.20181029161420.312">def test_bad_reserved_bits(self):
    for encoded in [b'\xc0\x00', b'\xa0\x00', b'\x90\x00']:
        with self.subTest(encoded=encoded):
            with self.assertRaises(WebSocketProtocolError):
                self.decode(encoded)

</t>
<t tx="ekr.20181029161420.313">def test_good_opcode(self):
    for opcode in list(range(0x00, 0x03)) + list(range(0x08, 0x0b)):
        encoded = bytes([0x80 | opcode, 0])
        with self.subTest(encoded=encoded):
            self.decode(encoded)            # does not raise an exception

</t>
<t tx="ekr.20181029161420.314">def test_bad_opcode(self):
    for opcode in list(range(0x03, 0x08)) + list(range(0x0b, 0x10)):
        encoded = bytes([0x80 | opcode, 0])
        with self.subTest(encoded=encoded):
            with self.assertRaises(WebSocketProtocolError):
                self.decode(encoded)

</t>
<t tx="ekr.20181029161420.315">def test_mask_flag(self):
    # Mask flag correctly set.
    self.decode(b'\x80\x80\x00\x00\x00\x00', mask=True)
    # Mask flag incorrectly unset.
    with self.assertRaises(WebSocketProtocolError):
        self.decode(b'\x80\x80\x00\x00\x00\x00')
    # Mask flag correctly unset.
    self.decode(b'\x80\x00')
    # Mask flag incorrectly set.
    with self.assertRaises(WebSocketProtocolError):
        self.decode(b'\x80\x00', mask=True)

</t>
<t tx="ekr.20181029161420.316">def test_control_frame_max_length(self):
    # At maximum allowed length.
    self.decode(b'\x88\x7e\x00\x7d' + 125 * b'a')
    # Above maximum allowed length.
    with self.assertRaises(WebSocketProtocolError):
        self.decode(b'\x88\x7e\x00\x7e' + 126 * b'a')

</t>
<t tx="ekr.20181029161420.317">def test_encode_data_str(self):
    self.assertEqual(encode_data('caf'), b'caf\xc3\xa9')

</t>
<t tx="ekr.20181029161420.318">def test_encode_data_bytes(self):
    self.assertEqual(encode_data(b'tea'), b'tea')

</t>
<t tx="ekr.20181029161420.319">def test_encode_data_other(self):
    with self.assertRaises(TypeError):
        encode_data(None)

</t>
<t tx="ekr.20181029161420.32">class NegotiationError(InvalidHandshake):
    """
    Exception raised when negociating an extension fails.

    """


</t>
<t tx="ekr.20181029161420.320">def test_fragmented_control_frame(self):
    # Fin bit correctly set.
    self.decode(b'\x88\x00')
    # Fin bit incorrectly unset.
    with self.assertRaises(WebSocketProtocolError):
        self.decode(b'\x08\x00')

</t>
<t tx="ekr.20181029161420.321">def test_parse_close_and_serialize_close(self):
    self.round_trip_close(b'\x03\xe8', 1000, '')
    self.round_trip_close(b'\x03\xe8OK', 1000, 'OK')

</t>
<t tx="ekr.20181029161420.322">def test_parse_close_empty(self):
    self.assertEqual(parse_close(b''), (1005, ''))

</t>
<t tx="ekr.20181029161420.323">def test_parse_close_errors(self):
    with self.assertRaises(WebSocketProtocolError):
        parse_close(b'\x03')
    with self.assertRaises(WebSocketProtocolError):
        parse_close(b'\x03\xe7')
    with self.assertRaises(UnicodeDecodeError):
        parse_close(b'\x03\xe8\xff\xff')

</t>
<t tx="ekr.20181029161420.324">def test_serialize_close_errors(self):
    with self.assertRaises(WebSocketProtocolError):
        serialize_close(999, '')

</t>
<t tx="ekr.20181029161420.325">def test_extensions(self):

    class Rot13:

        def encode(frame):
            assert frame.opcode == OP_TEXT
            text = frame.data.decode()
            data = codecs.encode(text, 'rot13').encode()
            return frame._replace(data=data)

        # This extensions is symmetrical.
        def decode(frame, *, max_size=None):
            return Rot13.encode(frame)

    self.round_trip(
        b'\x81\x05uryyb',
        Frame(True, OP_TEXT, b'hello'),
        extensions=[Rot13()],
    )
</t>
<t tx="ekr.20181029161420.326">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.327">import contextlib
import unittest

from .exceptions import InvalidHandshake
from .handshake import *
from .handshake import accept  # private API


</t>
<t tx="ekr.20181029161420.328">class HandshakeTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.329">def test_accept(self):
    # Test vector from RFC 6455
    key = "dGhlIHNhbXBsZSBub25jZQ=="
    acc = "s3pPLMBiTxaQ9kYGzzhZRbK+xOo="
    self.assertEqual(accept(key), acc)

</t>
<t tx="ekr.20181029161420.33">class InvalidParameterName(NegotiationError):
    """
    Exception raised when a parameter name in an extension header is invalid.

    """
    @others
</t>
<t tx="ekr.20181029161420.330">def test_round_trip(self):
    request_headers = {}
    request_key = build_request(request_headers)
    response_key = check_request(request_headers)
    self.assertEqual(request_key, response_key)
    response_headers = {}
    build_response(response_headers, response_key)
    check_response(response_headers, request_key)

</t>
<t tx="ekr.20181029161420.331">@contextlib.contextmanager
def assertInvalidRequestHeaders(self):
    """
    Provide request headers for corruption.

    Assert that the transformation made them invalid.

    """
    headers = {}
    build_request(headers)
    yield headers
    with self.assertRaises(InvalidHandshake):
        check_request(headers)

</t>
<t tx="ekr.20181029161420.332">def test_request_invalid_upgrade(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Upgrade'] = 'socketweb'

</t>
<t tx="ekr.20181029161420.333">def test_request_missing_upgrade(self):
    with self.assertInvalidRequestHeaders() as headers:
        del headers['Upgrade']

</t>
<t tx="ekr.20181029161420.334">def test_request_invalid_connection(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Connection'] = 'Downgrade'

</t>
<t tx="ekr.20181029161420.335">def test_request_missing_connection(self):
    with self.assertInvalidRequestHeaders() as headers:
        del headers['Connection']

</t>
<t tx="ekr.20181029161420.336">def test_request_invalid_key_not_base64(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Sec-WebSocket-Key'] = "!@#$%^&amp;*()"

</t>
<t tx="ekr.20181029161420.337">def test_request_invalid_key_not_well_padded(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Sec-WebSocket-Key'] = "CSIRmL8dWYxeAdr/XpEHRw"

</t>
<t tx="ekr.20181029161420.338">def test_request_invalid_key_not_16_bytes_long(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Sec-WebSocket-Key'] = "ZLpprpvK4PE="

</t>
<t tx="ekr.20181029161420.339">def test_request_missing_key(self):
    with self.assertInvalidRequestHeaders() as headers:
        del headers['Sec-WebSocket-Key']

</t>
<t tx="ekr.20181029161420.34">def __init__(self, name):
    self.name = name
    message = "Invalid parameter name: {}".format(name)
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.340">def test_request_invalid_version(self):
    with self.assertInvalidRequestHeaders() as headers:
        headers['Sec-WebSocket-Version'] = '42'

</t>
<t tx="ekr.20181029161420.341">def test_request_missing_version(self):
    with self.assertInvalidRequestHeaders() as headers:
        del headers['Sec-WebSocket-Version']

</t>
<t tx="ekr.20181029161420.342">@contextlib.contextmanager
def assertInvalidResponseHeaders(self, key='CSIRmL8dWYxeAdr/XpEHRw=='):
    """
    Provide response headers for corruption.

    Assert that the transformation made them invalid.

    """
    headers = {}
    build_response(headers, key)
    yield headers
    with self.assertRaises(InvalidHandshake):
        check_response(headers, key)

</t>
<t tx="ekr.20181029161420.343">def test_response_invalid_upgrade(self):
    with self.assertInvalidResponseHeaders() as headers:
        headers['Upgrade'] = 'socketweb'

</t>
<t tx="ekr.20181029161420.344">def test_response_missing_upgrade(self):
    with self.assertInvalidResponseHeaders() as headers:
        del headers['Upgrade']

</t>
<t tx="ekr.20181029161420.345">def test_response_invalid_connection(self):
    with self.assertInvalidResponseHeaders() as headers:
        headers['Connection'] = 'Downgrade'

</t>
<t tx="ekr.20181029161420.346">def test_response_missing_connection(self):
    with self.assertInvalidResponseHeaders() as headers:
        del headers['Connection']

</t>
<t tx="ekr.20181029161420.347">def test_response_invalid_accept(self):
    with self.assertInvalidResponseHeaders() as headers:
        other_key = "1Eq4UDEFQYg3YspNgqxv5g=="
        headers['Sec-WebSocket-Accept'] = accept(other_key)

</t>
<t tx="ekr.20181029161420.348">def test_response_missing_accept(self):
    with self.assertInvalidResponseHeaders() as headers:
        del headers['Sec-WebSocket-Accept']
</t>
<t tx="ekr.20181029161420.349">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.35">class InvalidParameterValue(NegotiationError):
    """
    Exception raised when a parameter value in an extension header is invalid.

    """
    @others
</t>
<t tx="ekr.20181029161420.350">import unittest

from .exceptions import InvalidHeaderFormat
from .headers import *
from .headers import build_basic_auth


</t>
<t tx="ekr.20181029161420.351">class HeadersTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.352">def test_parse_connection(self):
    for header, parsed in [
        # Realistic use cases
        (
            'Upgrade',                  # Safari, Chrome
            ['Upgrade'],
        ),
        (
            'keep-alive, Upgrade',      # Firefox
            ['keep-alive', 'Upgrade'],
        ),
        # Pathological example
        (
            ',,\t,  , ,Upgrade  ,,',
            ['Upgrade'],
        ),
    ]:
        with self.subTest(header=header):
            self.assertEqual(parse_connection(header), parsed)

</t>
<t tx="ekr.20181029161420.353">def test_parse_connection_invalid_header(self):
    for header in [
        '???',
        'keep-alive; Upgrade',
    ]:
        with self.subTest(header=header):
            with self.assertRaises(InvalidHeaderFormat):
                parse_connection(header)

</t>
<t tx="ekr.20181029161420.354">def test_parse_upgrade(self):
    for header, parsed in [
        # Realistic use case
        (
            'websocket',
            ['websocket'],
        ),
        # Synthetic example
        (
            'http/3.0, websocket',
            ['http/3.0', 'websocket']
        ),
        # Pathological example
        (
            ',,  WebSocket,  \t,,',
            ['WebSocket'],
        ),
    ]:
        with self.subTest(header=header):
            self.assertEqual(parse_upgrade(header), parsed)

</t>
<t tx="ekr.20181029161420.355">def test_parse_upgrade_invalid_header(self):
    for header in [
        '???',
        'websocket 2',
        'http/3.0; websocket',
    ]:
        with self.subTest(header=header):
            with self.assertRaises(InvalidHeaderFormat):
                parse_upgrade(header)

</t>
<t tx="ekr.20181029161420.356">def test_parse_extension_list(self):
    for header, parsed in [
        # Synthetic examples
        (
            'foo',
            [('foo', [])],
        ),
        (
            'foo, bar',
            [('foo', []), ('bar', [])],
        ),
        (
            'foo; name; token=token; quoted-string="quoted-string", '
            'bar; quux; quuux',
            [
                ('foo', [('name', None), ('token', 'token'),
                         ('quoted-string', 'quoted-string')]),
                ('bar', [('quux', None), ('quuux', None)]),
            ],
        ),
        # Pathological example
        (
            ',\t, ,  ,foo  ;bar = 42,,   baz,,',
            [('foo', [('bar', '42')]), ('baz', [])],
        ),
        # Realistic use cases for permessage-deflate
        (
            'permessage-deflate',
            [('permessage-deflate', [])],
        ),
        (
            'permessage-deflate; client_max_window_bits',
            [('permessage-deflate', [('client_max_window_bits', None)])],
        ),
        (
            'permessage-deflate; server_max_window_bits=10',
            [('permessage-deflate', [('server_max_window_bits', '10')])],
        ),
    ]:
        with self.subTest(header=header):
            self.assertEqual(parse_extension_list(header), parsed)
            # Also ensure that build_extension_list round-trips cleanly.
            unparsed = build_extension_list(parsed)
            self.assertEqual(parse_extension_list(unparsed), parsed)

</t>
<t tx="ekr.20181029161420.357">def test_parse_extension_list_invalid_header(self):
    for header in [
        # Truncated examples
        '',
        ',\t,'
        'foo;',
        'foo; bar;',
        'foo; bar=',
        'foo; bar="baz',
        # Wrong delimiter
        'foo, bar, baz=quux; quuux',
        # Value in quoted string parameter that isn't a token
        'foo; bar=" "',
    ]:
        with self.subTest(header=header):
            with self.assertRaises(InvalidHeaderFormat):
                parse_extension_list(header)

</t>
<t tx="ekr.20181029161420.358">def test_parse_subprotocol_list(self):
    for header, parsed in [
        # Synthetic examples
        (
            'foo',
            ['foo'],
        ),
        (
            'foo, bar',
            ['foo', 'bar'],
        ),
        # Pathological example
        (
            ',\t, ,  ,foo  ,,   bar,baz,,',
            ['foo', 'bar', 'baz'],
        ),
    ]:
        with self.subTest(header=header):
            self.assertEqual(parse_subprotocol_list(header), parsed)
            # Also ensure that build_subprotocol_list round-trips cleanly.
            unparsed = build_subprotocol_list(parsed)
            self.assertEqual(parse_subprotocol_list(unparsed), parsed)

</t>
<t tx="ekr.20181029161420.359">def test_parse_subprotocol_list_invalid_header(self):
    for header in [
        # Truncated examples
        '',
        ',\t,'
        # Wrong delimiter
        'foo; bar',
    ]:
        with self.subTest(header=header):
            with self.assertRaises(InvalidHeaderFormat):
                parse_subprotocol_list(header)

</t>
<t tx="ekr.20181029161420.36">def __init__(self, name, value):
    self.name = name
    self.value = value
    message = "Invalid value for parameter {}: {}".format(name, value)
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.360">def test_build_basic_auth(self):
    # Test vector from RFC 7617.
    self.assertEqual(
        build_basic_auth("Aladdin", "open sesame"),
        'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==',
    )
</t>
<t tx="ekr.20181029161420.361">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.362">import asyncio
import unittest

from .http import *
from .http import read_headers


</t>
<t tx="ekr.20181029161420.363">class HTTPAsyncTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.364">def setUp(self):
    super().setUp()
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)
    self.stream = asyncio.StreamReader(loop=self.loop)

</t>
<t tx="ekr.20181029161420.365">def tearDown(self):
    self.loop.close()
    super().tearDown()

</t>
<t tx="ekr.20181029161420.366">def test_read_request(self):
    # Example from the protocol overview in RFC 6455
    self.stream.feed_data(
        b'GET /chat HTTP/1.1\r\n'
        b'Host: server.example.com\r\n'
        b'Upgrade: websocket\r\n'
        b'Connection: Upgrade\r\n'
        b'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r\n'
        b'Origin: http://example.com\r\n'
        b'Sec-WebSocket-Protocol: chat, superchat\r\n'
        b'Sec-WebSocket-Version: 13\r\n'
        b'\r\n'
    )
    path, headers = self.loop.run_until_complete(
        read_request(self.stream))
    self.assertEqual(path, '/chat')
    self.assertEqual(headers['Upgrade'], 'websocket')

</t>
<t tx="ekr.20181029161420.367">def test_read_response(self):
    # Example from the protocol overview in RFC 6455
    self.stream.feed_data(
        b'HTTP/1.1 101 Switching Protocols\r\n'
        b'Upgrade: websocket\r\n'
        b'Connection: Upgrade\r\n'
        b'Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\n'
        b'Sec-WebSocket-Protocol: chat\r\n'
        b'\r\n'
    )
    status_code, headers = self.loop.run_until_complete(
        read_response(self.stream))
    self.assertEqual(status_code, 101)
    self.assertEqual(headers['Upgrade'], 'websocket')

</t>
<t tx="ekr.20181029161420.368">def test_request_method(self):
    self.stream.feed_data(b'OPTIONS * HTTP/1.1\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_request(self.stream))

</t>
<t tx="ekr.20181029161420.369">def test_request_version(self):
    self.stream.feed_data(b'GET /chat HTTP/1.0\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_request(self.stream))

</t>
<t tx="ekr.20181029161420.37">class DuplicateParameter(NegotiationError):
    """
    Exception raised when a parameter name is repeated in an extension header.

    """
    @others
</t>
<t tx="ekr.20181029161420.370">def test_response_version(self):
    self.stream.feed_data(b'HTTP/1.0 400 Bad Request\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_response(self.stream))

</t>
<t tx="ekr.20181029161420.371">def test_response_status(self):
    self.stream.feed_data(b'HTTP/1.1 007 My name is Bond\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_response(self.stream))

</t>
<t tx="ekr.20181029161420.372">def test_response_reason(self):
    self.stream.feed_data(b'HTTP/1.1 200 \x7f\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_response(self.stream))

</t>
<t tx="ekr.20181029161420.373">def test_header_name(self):
    self.stream.feed_data(b'foo bar: baz qux\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_headers(self.stream))

</t>
<t tx="ekr.20181029161420.374">def test_header_value(self):
    self.stream.feed_data(b'foo: \x00\x00\x0f\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_headers(self.stream))

</t>
<t tx="ekr.20181029161420.375">def test_headers_limit(self):
    self.stream.feed_data(b'foo: bar\r\n' * 257 + b'\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_headers(self.stream))

</t>
<t tx="ekr.20181029161420.376">def test_line_limit(self):
    # Header line contains 5 + 4090 + 2 = 4097 bytes.
    self.stream.feed_data(b'foo: ' + b'a' * 4090 + b'\r\n\r\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_headers(self.stream))

</t>
<t tx="ekr.20181029161420.377">def test_line_ending(self):
    self.stream.feed_data(b'foo: bar\n\n')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(read_headers(self.stream))


</t>
<t tx="ekr.20181029161420.378">class HeadersTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.379">def setUp(self):
    self.headers = Headers([
        ('Connection', 'Upgrade'),
        ('Server', USER_AGENT),
    ])

</t>
<t tx="ekr.20181029161420.38">def __init__(self, name):
    self.name = name
    message = "Duplicate parameter: {}".format(name)
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.380">def test_str(self):
    self.assertEqual(
        str(self.headers),
        "Connection: Upgrade\r\nServer: {}\r\n\r\n".format(USER_AGENT),
    )

</t>
<t tx="ekr.20181029161420.381">def test_repr(self):
    self.assertEqual(
        repr(self.headers),
        "Headers([('Connection', 'Upgrade'), "
        "('Server', '{}')])".format(USER_AGENT),
    )

</t>
<t tx="ekr.20181029161420.382">def test_multiple_values_error_str(self):
    self.assertEqual(
        str(MultipleValuesError('Connection')),
        "'Connection'",
    )
    self.assertEqual(
        str(MultipleValuesError()),
        "",
    )

</t>
<t tx="ekr.20181029161420.383">def test_contains(self):
    self.assertIn('Server', self.headers)

</t>
<t tx="ekr.20181029161420.384">def test_contains_case_insensitive(self):
    self.assertIn('server', self.headers)

</t>
<t tx="ekr.20181029161420.385">def test_contains_not_found(self):
    self.assertNotIn('Date', self.headers)

</t>
<t tx="ekr.20181029161420.386">def test_iter(self):
    self.assertEqual(set(iter(self.headers)), {'connection', 'server'})

</t>
<t tx="ekr.20181029161420.387">def test_len(self):
    self.assertEqual(len(self.headers), 2)

</t>
<t tx="ekr.20181029161420.388">def test_getitem(self):
    self.assertEqual(self.headers['Server'], USER_AGENT)

</t>
<t tx="ekr.20181029161420.389">def test_getitem_case_insensitive(self):
    self.assertEqual(self.headers['server'], USER_AGENT)

</t>
<t tx="ekr.20181029161420.39">class InvalidState(Exception):
    """
    Exception raised when an operation is forbidden in the current state.

    """


CLOSE_CODES = {
    1000: "OK",
    1001: "going away",
    1002: "protocol error",
    1003: "unsupported type",
    # 1004 is reserved
    1005: "no status code [internal]",
    1006: "connection closed abnormally [internal]",
    1007: "invalid data",
    1008: "policy violation",
    1009: "message too big",
    1010: "extension required",
    1011: "unexpected error",
    1015: "TLS failure [internal]",
}


</t>
<t tx="ekr.20181029161420.390">def test_getitem_key_error(self):
    with self.assertRaises(KeyError):
        self.headers['Upgrade']

</t>
<t tx="ekr.20181029161420.391">def test_getitem_multiple_values_error(self):
    self.headers['Server'] = '2'
    with self.assertRaises(MultipleValuesError):
        self.headers['Server']

</t>
<t tx="ekr.20181029161420.392">def test_setitem(self):
    self.headers['Upgrade'] = 'websocket'
    self.assertEqual(self.headers['Upgrade'], 'websocket')

</t>
<t tx="ekr.20181029161420.393">def test_setitem_case_insensitive(self):
    self.headers['upgrade'] = 'websocket'
    self.assertEqual(self.headers['Upgrade'], 'websocket')

</t>
<t tx="ekr.20181029161420.394">def test_setitem_multiple_values(self):
    self.headers['Connection'] = 'close'
    with self.assertRaises(MultipleValuesError):
        self.headers['Connection']

</t>
<t tx="ekr.20181029161420.395">def test_delitem(self):
    del self.headers['Connection']
    with self.assertRaises(KeyError):
        self.headers['Connection']

</t>
<t tx="ekr.20181029161420.396">def test_delitem_case_insensitive(self):
    del self.headers['connection']
    with self.assertRaises(KeyError):
        self.headers['Connection']

</t>
<t tx="ekr.20181029161420.397">def test_delitem_multiple_values(self):
    self.headers['Connection'] = 'close'
    del self.headers['Connection']
    with self.assertRaises(KeyError):
        self.headers['Connection']

</t>
<t tx="ekr.20181029161420.398">def test_eq(self):
    other_headers = self.headers.copy()
    self.assertEqual(self.headers, other_headers)

</t>
<t tx="ekr.20181029161420.399">def test_eq_not_equal(self):
    self.assertNotEqual(self.headers, [])

</t>
<t tx="ekr.20181029161420.4">class WebSocketClientProtocol(WebSocketCommonProtocol):
    """
    Complete WebSocket client implementation as an :class:`asyncio.Protocol`.

    This class inherits most of its methods from
    :class:`~websockets.protocol.WebSocketCommonProtocol`.

    """
    is_client = True
    side = 'client'

    @others
</t>
<t tx="ekr.20181029161420.40">class ConnectionClosed(InvalidState):
    """
    Exception raised when trying to read or write on a closed connection.

    Provides the connection close code and reason in its ``code`` and
    ``reason`` attributes respectively.

    """
    @others
</t>
<t tx="ekr.20181029161420.400">def test_clear(self):
    self.headers.clear()
    self.assertFalse(self.headers)
    self.assertEqual(self.headers, Headers())

</t>
<t tx="ekr.20181029161420.401">def test_get_all(self):
    self.assertEqual(self.headers.get_all('Connection'), ['Upgrade'])

</t>
<t tx="ekr.20181029161420.402">def test_get_all_case_insensitive(self):
    self.assertEqual(self.headers.get_all('connection'), ['Upgrade'])

</t>
<t tx="ekr.20181029161420.403">def test_get_all_no_values(self):
    self.assertEqual(self.headers.get_all('Upgrade'), [])

</t>
<t tx="ekr.20181029161420.404">def test_get_all_multiple_values(self):
    self.headers['Connection'] = 'close'
    self.assertEqual(
        self.headers.get_all('Connection'), ['Upgrade', 'close'])

</t>
<t tx="ekr.20181029161420.405">def test_raw_items(self):
    self.assertEqual(
        list(self.headers.raw_items()),
        [
            ('Connection', 'Upgrade'),
            ('Server', USER_AGENT),
        ],
    )
</t>
<t tx="ekr.20181029161420.406">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20181029161420.407">import asyncio
import contextlib
import functools
import logging
import os
import time
import unittest
import unittest.mock

from .compatibility import asyncio_ensure_future
from .exceptions import ConnectionClosed, InvalidState
from .framing import *
from .protocol import State, WebSocketCommonProtocol


# Avoid displaying stack traces at the ERROR logging level.
logging.basicConfig(level=logging.CRITICAL)


# Unit for timeouts. May be increased on slow machines by setting the
# WEBSOCKETS_TESTS_TIMEOUT_FACTOR environment variable.
MS = 0.001 * int(os.environ.get('WEBSOCKETS_TESTS_TIMEOUT_FACTOR', 1))

# asyncio's debug mode has a 10x performance penalty for this test suite.
if os.environ.get('PYTHONASYNCIODEBUG'):                    # pragma: no cover
    MS *= 10

# Ensure that timeouts are larger than the clock's resolution (for Windows).
MS = max(MS, 2.5 * time.get_clock_info('monotonic').resolution)


</t>
<t tx="ekr.20181029161420.408">class TransportMock(unittest.mock.Mock):
    """
    Transport mock to control the protocol's inputs and outputs in tests.

    It calls the protocol's connection_made and connection_lost methods like
    actual transports.

    It also calls the protocol's connection_open method to bypass the
    WebSocket handshake.

    To simulate incoming data, tests call the protocol's data_received and
    eof_received methods directly.

    They could also pause_writing and resume_writing to test flow control.

    """
    # This should happen in __init__ but overriding Mock.__init__ is hard.
    @others
</t>
<t tx="ekr.20181029161420.409">def setup_mock(self, loop, protocol):
    self.loop = loop
    self.protocol = protocol
    self._eof = False
    self._closing = False
    # Simulate a successful TCP handshake.
    self.protocol.connection_made(self)
    # Simulate a successful WebSocket handshake.
    self.protocol.connection_open()

</t>
<t tx="ekr.20181029161420.41">def __init__(self, code, reason):
    self.code = code
    self.reason = reason
    message = "WebSocket connection is closed: "
    if 3000 &lt;= code &lt; 4000:
        explanation = "registered"
    elif 4000 &lt;= code &lt; 5000:
        explanation = "private use"
    else:
        explanation = CLOSE_CODES.get(code, "unknown")
    message += "code = {} ({}), ".format(code, explanation)
    if reason:
        message += "reason = {}".format(reason)
    else:
        message += "no reason"
    super().__init__(message)


</t>
<t tx="ekr.20181029161420.410">def can_write_eof(self):
    return True

</t>
<t tx="ekr.20181029161420.411">def write_eof(self):
    # When the protocol half-closes the TCP connection, it expects the
    # other end to close it. Simulate that.
    if not self._eof:
        self.loop.call_soon(self.close)
    self._eof = True

</t>
<t tx="ekr.20181029161420.412">def is_closing(self):
    return self._closing

</t>
<t tx="ekr.20181029161420.413">def close(self):
    # Simulate how actual transports drop the connection.
    if not self._closing:
        self.loop.call_soon(self.protocol.connection_lost, None)
    self._closing = True

</t>
<t tx="ekr.20181029161420.414">def abort(self):
    # Change this to an `if` if tests call abort() multiple times.
    assert self.protocol.state is not State.CLOSED
    self.loop.call_soon(self.protocol.connection_lost, None)


</t>
<t tx="ekr.20181029161420.415">class CommonTests:
    """
    Mixin that defines most tests but doesn't inherit unittest.TestCase.

    Tests are run by the ServerTests and ClientTests subclasses.

    """
    @others
</t>
<t tx="ekr.20181029161420.416">def setUp(self):
    super().setUp()
    self.loop = asyncio.new_event_loop()
    asyncio.set_event_loop(self.loop)
    self.protocol = WebSocketCommonProtocol()
    self.transport = TransportMock()
    self.transport.setup_mock(self.loop, self.protocol)

</t>
<t tx="ekr.20181029161420.417">def tearDown(self):
    self.transport.close()
    self.loop.run_until_complete(self.protocol.close())
    self.loop.close()
    super().tearDown()

# Utilities for writing tests.

</t>
<t tx="ekr.20181029161420.418">def run_loop_once(self):
    # Process callbacks scheduled with call_soon by appending a callback
    # to stop the event loop then running it until it hits that callback.
    self.loop.call_soon(self.loop.stop)
    self.loop.run_forever()

</t>
<t tx="ekr.20181029161420.419">def make_drain_slow(self, delay=MS):
    # Process connection_made in order to initialize self.protocol.writer.
    self.run_loop_once()

    original_drain = self.protocol.writer.drain

    def delayed_drain():
        yield from asyncio.sleep(delay, loop=self.loop)
        yield from original_drain()

    self.protocol.writer.drain = delayed_drain

close_frame = Frame(True, OP_CLOSE, serialize_close(1000, 'close'))
local_close = Frame(True, OP_CLOSE, serialize_close(1000, 'local'))
remote_close = Frame(True, OP_CLOSE, serialize_close(1000, 'remote'))

</t>
<t tx="ekr.20181029161420.42">class InvalidURI(Exception):
    """
    Exception raised when an URI isn't a valid websocket URI.

    """


</t>
<t tx="ekr.20181029161420.420">@property
def ensure_future(self):
    return functools.partial(asyncio_ensure_future, loop=self.loop)

</t>
<t tx="ekr.20181029161420.421">def receive_frame(self, frame):
    """
    Make the protocol receive a frame.

    """
    writer = self.protocol.data_received
    mask = not self.protocol.is_client
    frame.write(writer, mask=mask)

</t>
<t tx="ekr.20181029161420.422">def receive_eof(self):
    """
    Make the protocol receive the end of the data stream.

    Since ``WebSocketCommonProtocol.eof_received`` returns ``None``, an
    actual transport would close itself after calling it. This function
    emulates that behavior.

    """
    self.protocol.eof_received()
    self.loop.call_soon(self.transport.close)

</t>
<t tx="ekr.20181029161420.423">def receive_eof_if_client(self):
    """
    Like receive_eof, but only if this is the client side.

    Since the server is supposed to initiate the termination of the TCP
    connection, this method helps making tests work for both sides.

    """
    if self.protocol.is_client:
        self.receive_eof()

</t>
<t tx="ekr.20181029161420.424">def close_connection(self, code=1000, reason='close'):
    """
    Execute a closing handshake.

    This puts the connection in the CLOSED state.

    """
    close_frame_data = serialize_close(code, reason)
    # Prepare the response to the closing handshake from the remote side.
    self.receive_frame(Frame(True, OP_CLOSE, close_frame_data))
    self.receive_eof_if_client()
    # Trigger the closing handshake from the local side and complete it.
    self.loop.run_until_complete(self.protocol.close(code, reason))
    # Empty the outgoing data stream so we can make assertions later on.
    self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)

    assert self.protocol.state is State.CLOSED

</t>
<t tx="ekr.20181029161420.425">def half_close_connection_local(self, code=1000, reason='close'):
    """
    Start a closing handshake but do not complete it.

    The main difference with `close_connection` is that the connection is
    left in the CLOSING state until the event loop runs again.

    The current implementation returns a task that must be awaited or
    cancelled, else asyncio complains about destroying a pending task.

    """
    close_frame_data = serialize_close(code, reason)
    # Trigger the closing handshake from the local endpoint.
    close_task = self.ensure_future(self.protocol.close(code, reason))
    self.run_loop_once()    # wait_for executes
    self.run_loop_once()    # write_frame executes
    # Empty the outgoing data stream so we can make assertions later on.
    self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)

    assert self.protocol.state is State.CLOSING

    # Complete the closing sequence at 1ms intervals so the test can run
    # at each point even it goes back to the event loop several times.
    self.loop.call_later(
        MS, self.receive_frame, Frame(True, OP_CLOSE, close_frame_data))
    self.loop.call_later(2 * MS, self.receive_eof_if_client)

    # This task must be awaited or cancelled by the caller.
    return close_task

</t>
<t tx="ekr.20181029161420.426">def half_close_connection_remote(self, code=1000, reason='close'):
    """
    Receive a closing handshake but do not complete it.

    The main difference with `close_connection` is that the connection is
    left in the CLOSING state until the event loop runs again.

    """
    # On the server side, websockets completes the closing handshake and
    # closes the TCP connection immediately. Yield to the event loop after
    # sending the close frame to run the test while the connection is in
    # the CLOSING state.
    if not self.protocol.is_client:
        self.make_drain_slow()

    close_frame_data = serialize_close(code, reason)
    # Trigger the closing handshake from the remote endpoint.
    self.receive_frame(Frame(True, OP_CLOSE, close_frame_data))
    self.run_loop_once()    # read_frame executes
    # Empty the outgoing data stream so we can make assertions later on.
    self.assertOneFrameSent(True, OP_CLOSE, close_frame_data)

    assert self.protocol.state is State.CLOSING

    # Complete the closing sequence at 1ms intervals so the test can run
    # at each point even it goes back to the event loop several times.
    self.loop.call_later(2 * MS, self.receive_eof_if_client)

</t>
<t tx="ekr.20181029161420.427">def process_invalid_frames(self):
    """
    Make the protocol fail quickly after simulating invalid data.

    To achieve this, this function triggers the protocol's eof_received,
    which interrupts pending reads waiting for more data.

    """
    self.run_loop_once()
    self.receive_eof()
    self.loop.run_until_complete(self.protocol.close_connection_task)

</t>
<t tx="ekr.20181029161420.428">def last_sent_frame(self):
    """
    Read the last frame sent to the transport.

    This method assumes that at most one frame was sent. It raises an
    AssertionError otherwise.

    """
    stream = asyncio.StreamReader(loop=self.loop)

    for (data,), kw in self.transport.write.call_args_list:
        stream.feed_data(data)
    self.transport.write.call_args_list = []
    stream.feed_eof()

    if stream.at_eof():
        frame = None
    else:
        frame = self.loop.run_until_complete(Frame.read(
            stream.readexactly, mask=self.protocol.is_client))

    if not stream.at_eof():                             # pragma: no cover
        data = self.loop.run_until_complete(stream.read())
        raise AssertionError("Trailing data found: {!r}".format(data))

    return frame

</t>
<t tx="ekr.20181029161420.429">def assertOneFrameSent(self, *args):
    self.assertEqual(self.last_sent_frame(), Frame(*args))

</t>
<t tx="ekr.20181029161420.43">class PayloadTooBig(Exception):
    """
    Exception raised when a frame's payload exceeds the maximum size.

    """


</t>
<t tx="ekr.20181029161420.430">def assertNoFrameSent(self):
    self.assertIsNone(self.last_sent_frame())

</t>
<t tx="ekr.20181029161420.431">def assertConnectionClosed(self, code, message):
    # The following line guarantees that connection_lost was called.
    self.assertEqual(self.protocol.state, State.CLOSED)
    # A close frame was received.
    self.assertEqual(self.protocol.close_code, code)
    self.assertEqual(self.protocol.close_reason, message)

</t>
<t tx="ekr.20181029161420.432">def assertConnectionFailed(self, code, message):
    # The following line guarantees that connection_lost was called.
    self.assertEqual(self.protocol.state, State.CLOSED)
    # No close frame was received.
    self.assertEqual(self.protocol.close_code, 1006)
    self.assertEqual(self.protocol.close_reason, '')
    # A close frame was sent -- unless the connection was already lost.
    if code == 1006:
        self.assertNoFrameSent()
    else:
        self.assertOneFrameSent(
            True, OP_CLOSE, serialize_close(code, message))

</t>
<t tx="ekr.20181029161420.433">@contextlib.contextmanager
def assertCompletesWithin(self, min_time, max_time):
    t0 = self.loop.time()
    yield
    t1 = self.loop.time()
    dt = t1 - t0
    self.assertGreaterEqual(
        dt, min_time, "Too fast: {} &lt; {}".format(dt, min_time))
    self.assertLess(
        dt, max_time, "Too slow: {} &gt;= {}".format(dt, max_time))

# Test public attributes.

</t>
<t tx="ekr.20181029161420.434">def test_local_address(self):
    get_extra_info = unittest.mock.Mock(return_value=('host', 4312))
    self.transport.get_extra_info = get_extra_info

    self.assertEqual(self.protocol.local_address, ('host', 4312))
    get_extra_info.assert_called_with('sockname', None)

</t>
<t tx="ekr.20181029161420.435">def test_local_address_before_connection(self):
    # Emulate the situation before connection_open() runs.
    self.protocol.writer, _writer = None, self.protocol.writer

    try:
        self.assertEqual(self.protocol.local_address, None)
    finally:
        self.protocol.writer = _writer

</t>
<t tx="ekr.20181029161420.436">def test_remote_address(self):
    get_extra_info = unittest.mock.Mock(return_value=('host', 4312))
    self.transport.get_extra_info = get_extra_info

    self.assertEqual(self.protocol.remote_address, ('host', 4312))
    get_extra_info.assert_called_with('peername', None)

</t>
<t tx="ekr.20181029161420.437">def test_remote_address_before_connection(self):
    # Emulate the situation before connection_open() runs.
    self.protocol.writer, _writer = None, self.protocol.writer

    try:
        self.assertEqual(self.protocol.remote_address, None)
    finally:
        self.protocol.writer = _writer

</t>
<t tx="ekr.20181029161420.438">def test_open(self):
    self.assertTrue(self.protocol.open)
    self.close_connection()
    self.assertFalse(self.protocol.open)

</t>
<t tx="ekr.20181029161420.439">def test_closed(self):
    self.assertFalse(self.protocol.closed)
    self.close_connection()
    self.assertTrue(self.protocol.closed)

# Test the recv coroutine.

</t>
<t tx="ekr.20181029161420.44">class WebSocketProtocolError(Exception):
    """
    Internal exception raised when the remote side breaks the protocol.

    """
</t>
<t tx="ekr.20181029161420.440">def test_recv_text(self):
    self.receive_frame(Frame(True, OP_TEXT, 'caf'.encode('utf-8')))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, 'caf')

</t>
<t tx="ekr.20181029161420.441">def test_recv_binary(self):
    self.receive_frame(Frame(True, OP_BINARY, b'tea'))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, b'tea')

</t>
<t tx="ekr.20181029161420.442">def test_recv_on_closing_connection_local(self):
    close_task = self.half_close_connection_local()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.recv())

    self.loop.run_until_complete(close_task)    # cleanup

</t>
<t tx="ekr.20181029161420.443">def test_recv_on_closing_connection_remote(self):
    self.half_close_connection_remote()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.recv())

</t>
<t tx="ekr.20181029161420.444">def test_recv_on_closed_connection(self):
    self.close_connection()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.recv())

</t>
<t tx="ekr.20181029161420.445">def test_recv_protocol_error(self):
    self.receive_frame(Frame(True, OP_CONT, 'caf'.encode('utf-8')))
    self.process_invalid_frames()
    self.assertConnectionFailed(1002, '')

</t>
<t tx="ekr.20181029161420.446">def test_recv_unicode_error(self):
    self.receive_frame(Frame(True, OP_TEXT, 'caf'.encode('latin-1')))
    self.process_invalid_frames()
    self.assertConnectionFailed(1007, '')

</t>
<t tx="ekr.20181029161420.447">def test_recv_text_payload_too_big(self):
    self.protocol.max_size = 1024
    self.receive_frame(Frame(True, OP_TEXT, 'caf'.encode('utf-8') * 205))
    self.process_invalid_frames()
    self.assertConnectionFailed(1009, '')

</t>
<t tx="ekr.20181029161420.448">def test_recv_binary_payload_too_big(self):
    self.protocol.max_size = 1024
    self.receive_frame(Frame(True, OP_BINARY, b'tea' * 342))
    self.process_invalid_frames()
    self.assertConnectionFailed(1009, '')

</t>
<t tx="ekr.20181029161420.449">def test_recv_text_no_max_size(self):
    self.protocol.max_size = None       # for test coverage
    self.receive_frame(Frame(True, OP_TEXT, 'caf'.encode('utf-8') * 205))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, 'caf' * 205)

</t>
<t tx="ekr.20181029161420.45">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.framing` module implements data framing as specified in
`section 5 of RFC 6455`_.

It deals with a single frame at a time. Anything that depends on the sequence
of frames is implemented in :mod:`websockets.protocol`.

.. _section 5 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-5

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.450">def test_recv_binary_no_max_size(self):
    self.protocol.max_size = None       # for test coverage
    self.receive_frame(Frame(True, OP_BINARY, b'tea' * 342))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, b'tea' * 342)

</t>
<t tx="ekr.20181029161420.451">def test_recv_other_error(self):
    def read_message():
        raise Exception("BOOM")
    self.protocol.read_message = read_message
    self.process_invalid_frames()
    self.assertConnectionFailed(1011, '')

</t>
<t tx="ekr.20181029161420.452">@asyncio.coroutine
\\-8.def test_recv_cancelled(self):
recv = self.ensure_future(self.protocol.recv())
self.loop.call_soon(recv.cancel)
with self.assertRaises(asyncio.CancelledError):
    self.loop.run_until_complete(recv)

# The next frame doesn't disappear in a vacuum (it used to).
self.receive_frame(Frame(True, OP_TEXT, 'caf'.encode('utf-8')))
data = self.loop.run_until_complete(self.protocol.recv())
self.assertEqual(data, 'caf')

\\-8.# Test the send coroutine.

</t>
<t tx="ekr.20181029161420.453">def test_send_text(self):
    self.loop.run_until_complete(self.protocol.send('caf'))
    self.assertOneFrameSent(True, OP_TEXT, 'caf'.encode('utf-8'))

</t>
<t tx="ekr.20181029161420.454">def test_send_binary(self):
    self.loop.run_until_complete(self.protocol.send(b'tea'))
    self.assertOneFrameSent(True, OP_BINARY, b'tea')

</t>
<t tx="ekr.20181029161420.455">def test_send_type_error(self):
    with self.assertRaises(TypeError):
        self.loop.run_until_complete(self.protocol.send(42))
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.456">def test_send_on_closing_connection_local(self):
    close_task = self.half_close_connection_local()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.send('foobar'))

    self.assertNoFrameSent()

    self.loop.run_until_complete(close_task)    # cleanup

</t>
<t tx="ekr.20181029161420.457">def test_send_on_closing_connection_remote(self):
    self.half_close_connection_remote()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.send('foobar'))

    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.458">def test_send_on_closed_connection(self):
    self.close_connection()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.send('foobar'))

    self.assertNoFrameSent()

# Test the ping coroutine.

</t>
<t tx="ekr.20181029161420.459">def test_ping_default(self):
    self.loop.run_until_complete(self.protocol.ping())
    # With our testing tools, it's more convenient to extract the expected
    # ping data from the library's internals than from the frame sent.
    ping_data = next(iter(self.protocol.pings))
    self.assertIsInstance(ping_data, bytes)
    self.assertEqual(len(ping_data), 4)
    self.assertOneFrameSent(True, OP_PING, ping_data)

</t>
<t tx="ekr.20181029161420.46">import asyncio
import collections
import io
import random
import struct

from .exceptions import PayloadTooBig, WebSocketProtocolError


try:
    from .speedups import apply_mask
except ImportError:                                         # pragma: no cover
    from .utils import apply_mask


__all__ = [
    'DATA_OPCODES', 'CTRL_OPCODES',
    'OP_CONT', 'OP_TEXT', 'OP_BINARY', 'OP_CLOSE', 'OP_PING', 'OP_PONG',
    'Frame', 'encode_data', 'parse_close', 'serialize_close'
]

DATA_OPCODES = OP_CONT, OP_TEXT, OP_BINARY = 0x00, 0x01, 0x02
CTRL_OPCODES = OP_CLOSE, OP_PING, OP_PONG = 0x08, 0x09, 0x0a

# Close code that are allowed in a close frame.
# Using a list optimizes `code in EXTERNAL_CLOSE_CODES`.
EXTERNAL_CLOSE_CODES = [
    1000,
    1001,
    1002,
    1003,
    1007,
    1008,
    1009,
    1010,
    1011,
]

FrameData = collections.namedtuple(
    'FrameData',
    ['fin', 'opcode', 'data', 'rsv1', 'rsv2', 'rsv3'],
)


</t>
<t tx="ekr.20181029161420.460">def test_ping_text(self):
    self.loop.run_until_complete(self.protocol.ping('caf'))
    self.assertOneFrameSent(True, OP_PING, 'caf'.encode('utf-8'))

</t>
<t tx="ekr.20181029161420.461">def test_ping_binary(self):
    self.loop.run_until_complete(self.protocol.ping(b'tea'))
    self.assertOneFrameSent(True, OP_PING, b'tea')

</t>
<t tx="ekr.20181029161420.462">def test_ping_type_error(self):
    with self.assertRaises(TypeError):
        self.loop.run_until_complete(self.protocol.ping(42))
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.463">def test_ping_on_closing_connection_local(self):
    close_task = self.half_close_connection_local()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.ping())

    self.assertNoFrameSent()

    self.loop.run_until_complete(close_task)    # cleanup

</t>
<t tx="ekr.20181029161420.464">def test_ping_on_closing_connection_remote(self):
    self.half_close_connection_remote()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.ping())

    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.465">def test_ping_on_closed_connection(self):
    self.close_connection()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.ping())

    self.assertNoFrameSent()

# Test the pong coroutine.

</t>
<t tx="ekr.20181029161420.466">def test_pong_default(self):
    self.loop.run_until_complete(self.protocol.pong())
    self.assertOneFrameSent(True, OP_PONG, b'')

</t>
<t tx="ekr.20181029161420.467">def test_pong_text(self):
    self.loop.run_until_complete(self.protocol.pong('caf'))
    self.assertOneFrameSent(True, OP_PONG, 'caf'.encode('utf-8'))

</t>
<t tx="ekr.20181029161420.468">def test_pong_binary(self):
    self.loop.run_until_complete(self.protocol.pong(b'tea'))
    self.assertOneFrameSent(True, OP_PONG, b'tea')

</t>
<t tx="ekr.20181029161420.469">def test_pong_type_error(self):
    with self.assertRaises(TypeError):
        self.loop.run_until_complete(self.protocol.pong(42))
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.47">class Frame(FrameData):
    """
    WebSocket frame.

    * ``fin`` is the FIN bit
    * ``rsv1`` is the RSV1 bit
    * ``rsv2`` is the RSV2 bit
    * ``rsv3`` is the RSV3 bit
    * ``opcode`` is the opcode
    * ``data`` is the payload data

    Only these fields are needed by higher level code. The MASK bit, payload
    length and masking-key are handled on the fly by :meth:`read` and
    :meth:`write`.

    """
    @others
</t>
<t tx="ekr.20181029161420.470">def test_pong_on_closing_connection_local(self):
    close_task = self.half_close_connection_local()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.pong())

    self.assertNoFrameSent()

    self.loop.run_until_complete(close_task)    # cleanup

</t>
<t tx="ekr.20181029161420.471">def test_pong_on_closing_connection_remote(self):
    self.half_close_connection_remote()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.pong())

    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.472">def test_pong_on_closed_connection(self):
    self.close_connection()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.pong())

    self.assertNoFrameSent()

# Test the protocol's logic for acknowledging pings with pongs.

</t>
<t tx="ekr.20181029161420.473">def test_answer_ping(self):
    self.receive_frame(Frame(True, OP_PING, b'test'))
    self.run_loop_once()
    self.assertOneFrameSent(True, OP_PONG, b'test')

</t>
<t tx="ekr.20181029161420.474">def test_ignore_pong(self):
    self.receive_frame(Frame(True, OP_PONG, b'test'))
    self.run_loop_once()
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.475">def test_acknowledge_ping(self):
    ping = self.loop.run_until_complete(self.protocol.ping())
    self.assertFalse(ping.done())
    ping_frame = self.last_sent_frame()
    pong_frame = Frame(True, OP_PONG, ping_frame.data)
    self.receive_frame(pong_frame)
    self.run_loop_once()
    self.run_loop_once()
    self.assertTrue(ping.done())

</t>
<t tx="ekr.20181029161420.476">def test_cancel_ping(self):
    ping = self.loop.run_until_complete(self.protocol.ping())
    # Remove the frame from the buffer, else close_connection() complains.
    self.last_sent_frame()
    self.assertFalse(ping.cancelled())
    self.close_connection()
    self.assertTrue(ping.cancelled())

</t>
<t tx="ekr.20181029161420.477">def test_acknowledge_previous_pings(self):
    pings = [(
        self.loop.run_until_complete(self.protocol.ping()),
        self.last_sent_frame(),
    ) for i in range(3)]
    # Unsolicited pong doesn't acknowledge pings
    self.receive_frame(Frame(True, OP_PONG, b''))
    self.run_loop_once()
    self.run_loop_once()
    self.assertFalse(pings[0][0].done())
    self.assertFalse(pings[1][0].done())
    self.assertFalse(pings[2][0].done())
    # Pong acknowledges all previous pings
    self.receive_frame(Frame(True, OP_PONG, pings[1][1].data))
    self.run_loop_once()
    self.run_loop_once()
    self.assertTrue(pings[0][0].done())
    self.assertTrue(pings[1][0].done())
    self.assertFalse(pings[2][0].done())

</t>
<t tx="ekr.20181029161420.478">def test_cancelled_ping(self):
    ping = self.loop.run_until_complete(self.protocol.ping())
    ping_frame = self.last_sent_frame()
    ping.cancel()
    pong_frame = Frame(True, OP_PONG, ping_frame.data)
    self.receive_frame(pong_frame)
    self.run_loop_once()
    self.run_loop_once()
    self.assertTrue(ping.cancelled())

</t>
<t tx="ekr.20181029161420.479">def test_duplicate_ping(self):
    self.loop.run_until_complete(self.protocol.ping(b'foobar'))
    self.assertOneFrameSent(True, OP_PING, b'foobar')
    with self.assertRaises(ValueError):
        self.loop.run_until_complete(self.protocol.ping(b'foobar'))
    self.assertNoFrameSent()

# Test the protocol's logic for rebuilding fragmented messages.

</t>
<t tx="ekr.20181029161420.48">def __new__(cls, fin, opcode, data, rsv1=False, rsv2=False, rsv3=False):
    return FrameData.__new__(cls, fin, opcode, data, rsv1, rsv2, rsv3)

</t>
<t tx="ekr.20181029161420.480">def test_fragmented_text(self):
    self.receive_frame(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
    self.receive_frame(Frame(True, OP_CONT, 'f'.encode('utf-8')))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, 'caf')

</t>
<t tx="ekr.20181029161420.481">def test_fragmented_binary(self):
    self.receive_frame(Frame(False, OP_BINARY, b't'))
    self.receive_frame(Frame(False, OP_CONT, b'e'))
    self.receive_frame(Frame(True, OP_CONT, b'a'))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, b'tea')

</t>
<t tx="ekr.20181029161420.482">def test_fragmented_text_payload_too_big(self):
    self.protocol.max_size = 1024
    self.receive_frame(Frame(False, OP_TEXT, 'caf'.encode('utf-8') * 100))
    self.receive_frame(Frame(True, OP_CONT, 'caf'.encode('utf-8') * 105))
    self.process_invalid_frames()
    self.assertConnectionFailed(1009, '')

</t>
<t tx="ekr.20181029161420.483">def test_fragmented_binary_payload_too_big(self):
    self.protocol.max_size = 1024
    self.receive_frame(Frame(False, OP_BINARY, b'tea' * 171))
    self.receive_frame(Frame(True, OP_CONT, b'tea' * 171))
    self.process_invalid_frames()
    self.assertConnectionFailed(1009, '')

</t>
<t tx="ekr.20181029161420.484">def test_fragmented_text_no_max_size(self):
    self.protocol.max_size = None       # for test coverage
    self.receive_frame(Frame(False, OP_TEXT, 'caf'.encode('utf-8') * 100))
    self.receive_frame(Frame(True, OP_CONT, 'caf'.encode('utf-8') * 105))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, 'caf' * 205)

</t>
<t tx="ekr.20181029161420.485">def test_fragmented_binary_no_max_size(self):
    self.protocol.max_size = None       # for test coverage
    self.receive_frame(Frame(False, OP_BINARY, b'tea' * 171))
    self.receive_frame(Frame(True, OP_CONT, b'tea' * 171))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, b'tea' * 342)

</t>
<t tx="ekr.20181029161420.486">def test_control_frame_within_fragmented_text(self):
    self.receive_frame(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
    self.receive_frame(Frame(True, OP_PING, b''))
    self.receive_frame(Frame(True, OP_CONT, 'f'.encode('utf-8')))
    data = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(data, 'caf')
    self.assertOneFrameSent(True, OP_PONG, b'')

</t>
<t tx="ekr.20181029161420.487">def test_unterminated_fragmented_text(self):
    self.receive_frame(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
    # Missing the second part of the fragmented frame.
    self.receive_frame(Frame(True, OP_BINARY, b'tea'))
    self.process_invalid_frames()
    self.assertConnectionFailed(1002, '')

</t>
<t tx="ekr.20181029161420.488">def test_close_handshake_in_fragmented_text(self):
    self.receive_frame(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
    self.receive_frame(Frame(True, OP_CLOSE, b''))
    self.process_invalid_frames()
    # The RFC may have overlooked this case: it says that control frames
    # can be interjected in the middle of a fragmented message and that a
    # close frame must be echoed. Even though there's an unterminated
    # message, technically, the closing handshake was successful.
    self.assertConnectionClosed(1005, '')

</t>
<t tx="ekr.20181029161420.489">def test_connection_close_in_fragmented_text(self):
    self.receive_frame(Frame(False, OP_TEXT, 'ca'.encode('utf-8')))
    self.process_invalid_frames()
    self.assertConnectionFailed(1006, '')

# Test miscellaneous code paths to ensure full coverage.

</t>
<t tx="ekr.20181029161420.49">@classmethod
@asyncio.coroutine
def read(cls, reader, *, mask, max_size=None, extensions=None):
    """
    Read a WebSocket frame and return a :class:`Frame` object.

    ``reader`` is a coroutine taking an integer argument and reading
    exactly this number of bytes, unless the end of file is reached.

    ``mask`` is a :class:`bool` telling whether the frame should be masked
    i.e. whether the read happens on the server side.

    If ``max_size`` is set and the payload exceeds this size in bytes,
    :exc:`~websockets.exceptions.PayloadTooBig` is raised.

    If ``extensions`` is provided, it's a list of classes with an
    ``decode()`` method that transform the frame and return a new frame.
    They are applied in reverse order.

    This function validates the frame before returning it and raises
    :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains
    incorrect values.

    """
    # Read the header.
    data = yield from reader(2)
    head1, head2 = struct.unpack('!BB', data)

    # While not Pythonic, this is marginally faster than calling bool().
    fin = True if head1 &amp; 0b10000000 else False
    rsv1 = True if head1 &amp; 0b01000000 else False
    rsv2 = True if head1 &amp; 0b00100000 else False
    rsv3 = True if head1 &amp; 0b00010000 else False
    opcode = head1 &amp; 0b00001111

    if (True if head2 &amp; 0b10000000 else False) != mask:
        raise WebSocketProtocolError("Incorrect masking")

    length = head2 &amp; 0b01111111
    if length == 126:
        data = yield from reader(2)
        length, = struct.unpack('!H', data)
    elif length == 127:
        data = yield from reader(8)
        length, = struct.unpack('!Q', data)
    if max_size is not None and length &gt; max_size:
        raise PayloadTooBig(
            "Payload length exceeds size limit ({} &gt; {} bytes)"
            .format(length, max_size))
    if mask:
        mask_bits = yield from reader(4)

    # Read the data.
    data = yield from reader(length)
    if mask:
        data = apply_mask(data, mask_bits)

    frame = cls(fin, opcode, data, rsv1, rsv2, rsv3)

    if extensions is None:
        extensions = []
    for extension in reversed(extensions):
        frame = extension.decode(frame, max_size=max_size)

    frame.check()

    return frame

</t>
<t tx="ekr.20181029161420.490">def test_connection_lost(self):
    # Test calling connection_lost without going through close_connection.
    self.protocol.connection_lost(None)

    self.assertConnectionFailed(1006, '')

</t>
<t tx="ekr.20181029161420.491">def test_ensure_open_before_opening_handshake(self):
    # Simulate a bug by forcibly reverting the protocol state.
    self.protocol.state = State.CONNECTING

    with self.assertRaises(InvalidState):
        self.loop.run_until_complete(self.protocol.ensure_open())

</t>
<t tx="ekr.20181029161420.492">def test_ensure_open_during_unclean_close(self):
    # Process connection_made in order to start transfer_data_task.
    self.run_loop_once()

    # Ensure the test terminates quickly.
    self.loop.call_later(MS, self.receive_eof_if_client)

    # Simulate the case when close() times out sending a close frame.
    self.protocol.fail_connection()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.ensure_open())

</t>
<t tx="ekr.20181029161420.493">def test_legacy_recv(self):
    # By default legacy_recv in disabled.
    self.assertEqual(self.protocol.legacy_recv, False)

    self.close_connection()

    # Enable legacy_recv.
    self.protocol.legacy_recv = True

    # Now recv() returns None instead of raising ConnectionClosed.
    self.assertIsNone(self.loop.run_until_complete(self.protocol.recv()))

</t>
<t tx="ekr.20181029161420.494">def test_connection_closed_attributes(self):
    self.close_connection()

    with self.assertRaises(ConnectionClosed) as context:
        self.loop.run_until_complete(self.protocol.recv())

    connection_closed_exc = context.exception
    self.assertEqual(connection_closed_exc.code, 1000)
    self.assertEqual(connection_closed_exc.reason, 'close')

# Test the protocol logic for closing the connection.

</t>
<t tx="ekr.20181029161420.495">def test_local_close(self):
    # Emulate how the remote endpoint answers the closing handshake.
    self.loop.call_later(MS, self.receive_frame, self.close_frame)
    self.loop.call_later(MS, self.receive_eof_if_client)

    # Run the closing handshake.
    self.loop.run_until_complete(self.protocol.close(reason='close'))

    self.assertConnectionClosed(1000, 'close')
    self.assertOneFrameSent(*self.close_frame)

    # Closing the connection again is a no-op.
    self.loop.run_until_complete(self.protocol.close(reason='oh noes!'))

    self.assertConnectionClosed(1000, 'close')
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.496">def test_remote_close(self):
    # Emulate how the remote endpoint initiates the closing handshake.
    self.loop.call_later(MS, self.receive_frame, self.close_frame)
    self.loop.call_later(MS, self.receive_eof_if_client)

    # Wait for some data in order to process the handshake.
    # After recv() raises ConnectionClosed, the connection is closed.
    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(self.protocol.recv())

    self.assertConnectionClosed(1000, 'close')
    self.assertOneFrameSent(*self.close_frame)

    # Closing the connection again is a no-op.
    self.loop.run_until_complete(self.protocol.close(reason='oh noes!'))

    self.assertConnectionClosed(1000, 'close')
    self.assertNoFrameSent()

</t>
<t tx="ekr.20181029161420.497">def test_simultaneous_close(self):
    # Receive the incoming close frame right after self.protocol.close()
    # starts executing. This reproduces the error described in:
    # https://github.com/aaugustin/websockets/issues/339
    self.loop.call_soon(self.receive_frame, self.remote_close)
    self.loop.call_soon(self.receive_eof_if_client)

    self.loop.run_until_complete(self.protocol.close(reason='local'))

    self.assertConnectionClosed(1000, 'remote')
    # The current implementation sends a close frame in response to the
    # close frame received from the remote end. It skips the close frame
    # that should be sent as a result of calling close().
    self.assertOneFrameSent(*self.remote_close)

</t>
<t tx="ekr.20181029161420.498">def test_close_preserves_incoming_frames(self):
    self.receive_frame(Frame(True, OP_TEXT, b'hello'))

    self.loop.call_later(MS, self.receive_frame, self.close_frame)
    self.loop.call_later(MS, self.receive_eof_if_client)
    self.loop.run_until_complete(self.protocol.close(reason='close'))

    self.assertConnectionClosed(1000, 'close')
    self.assertOneFrameSent(*self.close_frame)

    next_message = self.loop.run_until_complete(self.protocol.recv())
    self.assertEqual(next_message, 'hello')

</t>
<t tx="ekr.20181029161420.499">def test_close_protocol_error(self):
    invalid_close_frame = Frame(True, OP_CLOSE, b'\x00')
    self.receive_frame(invalid_close_frame)
    self.receive_eof_if_client()
    self.run_loop_once()
    self.loop.run_until_complete(self.protocol.close(reason='close'))

    self.assertConnectionFailed(1002, '')

</t>
<t tx="ekr.20181029161420.5">def __init__(self, *,
             origin=None, extensions=None, subprotocols=None,
             extra_headers=None, **kwds):
    self.origin = origin
    self.available_extensions = extensions
    self.available_subprotocols = subprotocols
    self.extra_headers = extra_headers
    super().__init__(**kwds)

</t>
<t tx="ekr.20181029161420.50">def write(frame, writer, *, mask, extensions=None):
    """
    Write a WebSocket frame.

    ``frame`` is the :class:`Frame` object to write.

    ``writer`` is a function accepting bytes.

    ``mask`` is a :class:`bool` telling whether the frame should be masked
    i.e. whether the write happens on the client side.

    If ``extensions`` is provided, it's a list of classes with an
    ``encode()`` method that transform the frame and return a new frame.
    They are applied in order.

    This function validates the frame before sending it and raises
    :exc:`~websockets.exceptions.WebSocketProtocolError` if it contains
    incorrect values.

    """
    # The first parameter is called `frame` rather than `self`,
    # but it's the instance of class to which this method is bound.

    frame.check()

    if extensions is None:
        extensions = []
    for extension in extensions:
        frame = extension.encode(frame)

    output = io.BytesIO()

    # Prepare the header.
    head1 = (
        (0b10000000 if frame.fin else 0) |
        (0b01000000 if frame.rsv1 else 0) |
        (0b00100000 if frame.rsv2 else 0) |
        (0b00010000 if frame.rsv3 else 0) |
        frame.opcode
    )

    head2 = 0b10000000 if mask else 0

    length = len(frame.data)
    if length &lt; 126:
        output.write(struct.pack('!BB', head1, head2 | length))
    elif length &lt; 65536:
        output.write(struct.pack('!BBH', head1, head2 | 126, length))
    else:
        output.write(struct.pack('!BBQ', head1, head2 | 127, length))

    if mask:
        mask_bits = struct.pack('!I', random.getrandbits(32))
        output.write(mask_bits)

    # Prepare the data.
    if mask:
        data = apply_mask(frame.data, mask_bits)
    else:
        data = frame.data
    output.write(data)

    # Send the frame.

    # The frame is written in a single call to writer in order to prevent
    # TCP fragmentation. See #68 for details. This also makes it safe to
    # send frames concurrently from multiple coroutines.
    writer(output.getvalue())

</t>
<t tx="ekr.20181029161420.500">def test_close_connection_lost(self):
    self.receive_eof()
    self.run_loop_once()
    self.loop.run_until_complete(self.protocol.close(reason='close'))

    self.assertConnectionFailed(1006, '')

</t>
<t tx="ekr.20181029161420.501">def test_local_close_during_recv(self):
    recv = self.ensure_future(self.protocol.recv())

    self.loop.call_later(MS, self.receive_frame, self.close_frame)
    self.loop.call_later(MS, self.receive_eof_if_client)

    self.loop.run_until_complete(self.protocol.close(reason='close'))

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(recv)

    self.assertConnectionClosed(1000, 'close')

# There is no test_remote_close_during_recv because it would be identical
# to test_remote_close.

</t>
<t tx="ekr.20181029161420.502">def test_remote_close_during_send(self):
    self.make_drain_slow()
    send = self.ensure_future(self.protocol.send('hello'))

    self.receive_frame(self.close_frame)
    self.receive_eof()

    with self.assertRaises(ConnectionClosed):
        self.loop.run_until_complete(send)

    self.assertConnectionClosed(1000, 'close')

# There is no test_local_close_during_send because this cannot really
# happen, considering that writes are serialized.


</t>
<t tx="ekr.20181029161420.503">class ServerTests(CommonTests, unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.504">def setUp(self):
    super().setUp()
    self.protocol.is_client = False
    self.protocol.side = 'server'

</t>
<t tx="ekr.20181029161420.505">def test_local_close_send_close_frame_timeout(self):
    self.protocol.timeout = 10 * MS
    self.make_drain_slow(50 * MS)
    # If we can't send a close frame, time out in 10ms.
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(9 * MS, 19 * MS):
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1006, '')

</t>
<t tx="ekr.20181029161420.506">def test_local_close_receive_close_frame_timeout(self):
    self.protocol.timeout = 10 * MS
    # If the client doesn't send a close frame, time out in 10ms.
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(9 * MS, 19 * MS):
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1006, '')

</t>
<t tx="ekr.20181029161420.507">def test_local_close_connection_lost_timeout_after_write_eof(self):
    self.protocol.timeout = 10 * MS
    # If the client doesn't close its side of the TCP connection after we
    # half-close our side with write_eof(), time out in 10ms.
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(9 * MS, 19 * MS):
        # HACK: disable write_eof =&gt; other end drops connection emulation.
        self.transport._eof = True
        self.receive_frame(self.close_frame)
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1000, 'close')

</t>
<t tx="ekr.20181029161420.508">def test_local_close_connection_lost_timeout_after_close(self):
    self.protocol.timeout = 10 * MS
    # If the client doesn't close its side of the TCP connection after we
    # half-close our side with write_eof() and close it with close(), time
    # out in 20ms.
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(19 * MS, 29 * MS):
        # HACK: disable write_eof =&gt; other end drops connection emulation.
        self.transport._eof = True
        # HACK: disable close =&gt; other end drops connection emulation.
        self.transport._closing = True
        self.receive_frame(self.close_frame)
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1000, 'close')


</t>
<t tx="ekr.20181029161420.509">class ClientTests(CommonTests, unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.51">def check(frame):
    """
    Check that this frame contains acceptable values.

    Raise :exc:`~websockets.exceptions.WebSocketProtocolError` if this
    frame contains incorrect values.

    """
    # The first parameter is called `frame` rather than `self`,
    # but it's the instance of class to which this method is bound.

    if frame.rsv1 or frame.rsv2 or frame.rsv3:
        raise WebSocketProtocolError("Reserved bits must be 0")

    if frame.opcode in DATA_OPCODES:
        return
    elif frame.opcode in CTRL_OPCODES:
        if len(frame.data) &gt; 125:
            raise WebSocketProtocolError("Control frame too long")
        if not frame.fin:
            raise WebSocketProtocolError("Fragmented control frame")
    else:
        raise WebSocketProtocolError(
            "Invalid opcode: {}".format(frame.opcode))


</t>
<t tx="ekr.20181029161420.510">def setUp(self):
    super().setUp()
    self.protocol.is_client = True
    self.protocol.side = 'client'

</t>
<t tx="ekr.20181029161420.511">def test_local_close_send_close_frame_timeout(self):
    self.protocol.timeout = 10 * MS
    self.make_drain_slow(50 * MS)
    # If we can't send a close frame, time out in 20ms.
    # - 10ms waiting for sending a close frame
    # - 10ms waiting for receiving a half-close
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(19 * MS, 29 * MS):
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1006, '')

</t>
<t tx="ekr.20181029161420.512">def test_local_close_receive_close_frame_timeout(self):
    self.protocol.timeout = 10 * MS
    # If the server doesn't send a close frame, time out in 20ms:
    # - 10ms waiting for receiving a close frame
    # - 10ms waiting for receiving a half-close
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(19 * MS, 29 * MS):
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1006, '')

</t>
<t tx="ekr.20181029161420.513">def test_local_close_connection_lost_timeout_after_write_eof(self):
    self.protocol.timeout = 10 * MS
    # If the server doesn't half-close its side of the TCP connection
    # after we send a close frame, time out in 20ms:
    # - 10ms waiting for receiving a half-close
    # - 10ms waiting for receiving a close after write_eof
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(19 * MS, 29 * MS):
        # HACK: disable write_eof =&gt; other end drops connection emulation.
        self.transport._eof = True
        self.receive_frame(self.close_frame)
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1000, 'close')

</t>
<t tx="ekr.20181029161420.514">def test_local_close_connection_lost_timeout_after_close(self):
    self.protocol.timeout = 10 * MS
    # If the client doesn't close its side of the TCP connection after we
    # half-close our side with write_eof() and close it with close(), time
    # out in 20ms.
    # - 10ms waiting for receiving a half-close
    # - 10ms waiting for receiving a close after write_eof
    # - 10ms waiting for receiving a close after close
    # Check the timing within -1/+9ms for robustness.
    with self.assertCompletesWithin(29 * MS, 39 * MS):
        # HACK: disable write_eof =&gt; other end drops connection emulation.
        self.transport._eof = True
        # HACK: disable close =&gt; other end drops connection emulation.
        self.transport._closing = True
        self.receive_frame(self.close_frame)
        self.loop.run_until_complete(self.protocol.close(reason='close'))
    self.assertConnectionClosed(1000, 'close')
</t>
<t tx="ekr.20181029161420.515">@path C:/Anaconda3/Lib/site-packages/websockets/
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.516">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.517">import unittest

from .exceptions import InvalidURI
from .uri import *


VALID_URIS = [
    (
        'ws://localhost/',
        (False, 'localhost', 80, '/', None),
    ),
    (
        'wss://localhost/',
        (True, 'localhost', 443, '/', None),
    ),
    (
        'ws://localhost/path?query',
        (False, 'localhost', 80, '/path?query', None),
    ),
    (
        'WS://LOCALHOST/PATH?QUERY',
        (False, 'localhost', 80, '/PATH?QUERY', None),
    ),
    (
        'ws://user:pass@localhost/',
        (False, 'localhost', 80, '/', ('user', 'pass')),
    ),
]

INVALID_URIS = [
    'http://localhost/',
    'https://localhost/',
    'ws://localhost/path#fragment',
]


</t>
<t tx="ekr.20181029161420.518">class URITests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.519">def test_success(self):
    for uri, parsed in VALID_URIS:
        with self.subTest(uri=uri):
            self.assertEqual(parse_uri(uri), parsed)

</t>
<t tx="ekr.20181029161420.52">def encode_data(data):
    """
    Helper that converts :class:`str` or :class:`bytes` to :class:`bytes`.

    :class:`str` are encoded with UTF-8.

    """
    # Expect str or bytes, return bytes.
    if isinstance(data, str):
        return data.encode('utf-8')
    elif isinstance(data, bytes):
        return data
    else:
        raise TypeError("data must be bytes or str")


</t>
<t tx="ekr.20181029161420.520">def test_error(self):
    for uri in INVALID_URIS:
        with self.subTest(uri=uri):
            with self.assertRaises(InvalidURI):
                parse_uri(uri)
</t>
<t tx="ekr.20181029161420.521">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
@ignore
</t>
<t tx="ekr.20181029161420.522">import unittest

from .utils import apply_mask as py_apply_mask


</t>
<t tx="ekr.20181029161420.523">class UtilsTests(unittest.TestCase):

    @others
try:
    from .speedups import apply_mask as c_apply_mask
except ImportError:                                         # pragma: no cover
    pass
else:
    class SpeedupsTests(UtilsTests):

        def apply_mask(*args, **kwargs):
            return c_apply_mask(*args, **kwargs)
</t>
<t tx="ekr.20181029161420.524">@staticmethod
def apply_mask(*args, **kwargs):
    return py_apply_mask(*args, **kwargs)

</t>
<t tx="ekr.20181029161420.525">def test_apply_mask(self):
    for data_in, mask, data_out in [
        (b'', b'1234', b''),
        (b'aBcDe', b'\x00\x00\x00\x00', b'aBcDe'),
        (b'abcdABCD', b'1234', b'PPPPpppp'),
        (b'abcdABCD' * 10, b'1234', b'PPPPpppp' * 10),
    ]:
        with self.subTest(data_in=data_in, mask=mask):
            self.assertEqual(self.apply_mask(data_in, mask), data_out)

</t>
<t tx="ekr.20181029161420.526">def test_apply_mask_check_input_types(self):
    for data_in, mask in [
        (None, None),
        (b'abcd', None),
        (None, b'abcd'),
    ]:
        with self.subTest(data_in=data_in, mask=mask):
            with self.assertRaises(TypeError):
                self.apply_mask(data_in, mask)

</t>
<t tx="ekr.20181029161420.527">def test_apply_mask_check_mask_length(self):
    for data_in, mask in [
        (b'', b''),
        (b'abcd', b'123'),
        (b'', b'aBcDe'),
        (b'12345678', b'12345678'),
    ]:
        with self.subTest(data_in=data_in, mask=mask):
            with self.assertRaises(ValueError):
                self.apply_mask(data_in, mask)


</t>
<t tx="ekr.20181029161420.528">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.529">"""
The :mod:`websockets.uri` module implements parsing of WebSocket URIs
according to `section 3 of RFC 6455`_.

.. _section 3 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-3

"""

import collections
import urllib.parse

from .exceptions import InvalidURI


__all__ = ['parse_uri', 'WebSocketURI']

WebSocketURI = collections.namedtuple(
    'WebSocketURI', ['secure', 'host', 'port', 'resource_name', 'user_info'])
WebSocketURI.__doc__ = """WebSocket URI.

* ``secure`` is the secure flag
* ``host`` is the lower-case host
* ``port`` if the integer port, it's always provided even if it's the default
* ``resource_name`` is the resource name, that is, the path and optional query
* ``user_info`` is an ``(username, password)`` tuple when the URI contains
  `User Information`_, else ``None``.

.. _User Information: https://tools.ietf.org/html/rfc3986#section-3.2.1

"""


</t>
<t tx="ekr.20181029161420.53">def parse_close(data):
    """
    Parse the data in a close frame.

    Return ``(code, reason)`` when ``code`` is an :class:`int` and ``reason``
    a :class:`str`.

    Raise :exc:`~websockets.exceptions.WebSocketProtocolError` or
    :exc:`UnicodeDecodeError` if the data is invalid.

    """
    length = len(data)
    if length &gt;= 2:
        code, = struct.unpack('!H', data[:2])
        check_close(code)
        reason = data[2:].decode('utf-8')
        return code, reason
    elif length == 0:
        return 1005, ''
    else:
        assert length == 1
        raise WebSocketProtocolError("Close frame too short")


</t>
<t tx="ekr.20181029161420.530">def parse_uri(uri):
    """
    This function parses and validates a WebSocket URI.

    If the URI is valid, it returns a :class:`WebSocketURI`.

    Otherwise it raises an :exc:`~websockets.exceptions.InvalidURI` exception.

    """
    uri = urllib.parse.urlparse(uri)
    try:
        assert uri.scheme in ['ws', 'wss']
        assert uri.params == ''
        assert uri.fragment == ''
        assert uri.hostname is not None
    except AssertionError as exc:
        raise InvalidURI("{} isn't a valid URI".format(uri)) from exc

    secure = uri.scheme == 'wss'
    host = uri.hostname
    port = uri.port or (443 if secure else 80)
    resource_name = uri.path or '/'
    if uri.query:
        resource_name += '?' + uri.query
    user_info = None
    if uri.username or uri.password:
        user_info = (uri.username, uri.password)
    return WebSocketURI(secure, host, port, resource_name, user_info)
</t>
<t tx="ekr.20181029161420.531">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.532">import itertools


__all__ = ['apply_mask']


</t>
<t tx="ekr.20181029161420.533">def apply_mask(data, mask):
    """
    Apply masking to websocket message.

    """
    if len(mask) != 4:
        raise ValueError("mask must contain 4 bytes")
    return bytes(b ^ m for b, m in zip(data, itertools.cycle(mask)))
</t>
<t tx="ekr.20181029161420.534"></t>
<t tx="ekr.20181029161420.535">@path C:/Anaconda3/Lib/site-packages/websockets/
version = '6.0'
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.536">@path C:/Anaconda3/Lib/site-packages/websockets/
# This relies on each of the submodules having an __all__ variable.

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.537">from .client import *
from .exceptions import *
from .protocol import *
from .server import *
from .uri import *
from .version import version as __version__                             # noqa


__all__ = (
    client.__all__ +
    exceptions.__all__ +
    protocol.__all__ +
    server.__all__ +
    uri.__all__
)
</t>
<t tx="ekr.20181029161420.538"></t>
<t tx="ekr.20181029161420.539">@path C:/Anaconda3/Lib/site-packages/websockets/extensions/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.54">def serialize_close(code, reason):
    """
    Serialize the data for a close frame.

    This is the reverse of :func:`parse_close`.

    """
    check_close(code)
    return struct.pack('!H', code) + reason.encode('utf-8')


</t>
<t tx="ekr.20181029161420.540">"""
The :mod:`websockets.extensions.base` defines abstract classes for extensions.

See https://tools.ietf.org/html/rfc6455#section-9.

"""


</t>
<t tx="ekr.20181029161420.541">class ClientExtensionFactory:
    """
    Abstract class for client-side extension factories.

    Extension factories handle configuration and negotiation.

    """
    name = ...

    @others
</t>
<t tx="ekr.20181029161420.542">def get_request_params(self):
    """
    Build request parameters.

    Return a list of (name, value) pairs.

    """

</t>
<t tx="ekr.20181029161420.543">def process_response_params(self, params, accepted_extensions):
    """"
    Process response parameters.

    ``params`` are a list of (name, value) pairs.

    ``accepted_extensions`` is a list of previously accepted extensions,
    represented by extension instances.

    Return an extension instance (an instance of a subclass of
    :class:`Extension`) if these parameters are acceptable.

    Raise :exc:`~websockets.exceptions.NegotiationError` if they aren't.

    """


</t>
<t tx="ekr.20181029161420.544">class ServerExtensionFactory:
    """
    Abstract class for server-side extension factories.

    Extension factories handle configuration and negotiation.

    """
    name = ...

    @others
</t>
<t tx="ekr.20181029161420.545">def process_request_params(self, params, accepted_extensions):
    """"
    Process request parameters.

    ``accepted_extensions`` is a list of previously accepted extensions,
    represented by extension instances.

    Return response params (a list of (name, value) pairs) and an
    extension instance (an instance of a subclass of :class:`Extension`)
    to accept this extension.

    Raise :exc:`~websockets.exceptions.NegotiationError` to reject it.

    """


</t>
<t tx="ekr.20181029161420.546">class Extension:
    """
    Abstract class for extensions.

    """
    name = ...

    @others
</t>
<t tx="ekr.20181029161420.547">def decode(self, frame, *, max_size=None):
    """
    Decode an incoming frame.

    Return a frame.

    """

</t>
<t tx="ekr.20181029161420.548">def encode(self, frame):
    """
    Encode an outgoing frame.

    Return a frame.

    """
</t>
<t tx="ekr.20181029161420.549">@path C:/Anaconda3/Lib/site-packages/websockets/extensions/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.55">def check_close(code):
    """
    Check the close code for a close frame.

    """
    if not (code in EXTERNAL_CLOSE_CODES or 3000 &lt;= code &lt; 5000):
        raise WebSocketProtocolError("Invalid status code")
</t>
<t tx="ekr.20181029161420.550">"""
The :mod:`websockets.extensions.permessage_deflate` module implements the
Compression Extensions for WebSocket as specified in :rfc:`7692`.

"""

import zlib

from ..exceptions import (
    DuplicateParameter, InvalidParameterName, InvalidParameterValue,
    NegotiationError, PayloadTooBig
)
from ..framing import CTRL_OPCODES, OP_CONT


__all__ = [
    'ClientPerMessageDeflateFactory',
    'ServerPerMessageDeflateFactory',
    'PerMessageDeflate',
]

_EMPTY_UNCOMPRESSED_BLOCK = b'\x00\x00\xff\xff'

_MAX_WINDOW_BITS_VALUES = [str(bits) for bits in range(8, 16)]


</t>
<t tx="ekr.20181029161420.551">def _build_parameters(
    server_no_context_takeover,
    client_no_context_takeover,
    server_max_window_bits,
    client_max_window_bits,
):
    """
    Build a list of ``(name, value)`` pairs for some compression parameters.

    """
    params = []
    if server_no_context_takeover:
        params.append(('server_no_context_takeover', None))
    if client_no_context_takeover:
        params.append(('client_no_context_takeover', None))
    if server_max_window_bits:
        params.append(('server_max_window_bits', str(server_max_window_bits)))
    if client_max_window_bits is True:          # only in handshake requests
        params.append(('client_max_window_bits', None))
    elif client_max_window_bits:
        params.append(('client_max_window_bits', str(client_max_window_bits)))
    return params


</t>
<t tx="ekr.20181029161420.552">def _extract_parameters(params, *, is_server):
    """
    Extract compression parameters from a list of ``(name, value)`` pairs.

    If ``is_server`` is ``True``, ``client_max_window_bits`` may be provided
    without a value. This is only allow in handshake requests.

    """
    server_no_context_takeover = False
    client_no_context_takeover = False
    server_max_window_bits = None
    client_max_window_bits = None

    for name, value in params:

        if name == 'server_no_context_takeover':
            if server_no_context_takeover:
                raise DuplicateParameter(name)
            if value is None:
                server_no_context_takeover = True
            else:
                raise InvalidParameterValue(name, value)

        elif name == 'client_no_context_takeover':
            if client_no_context_takeover:
                raise DuplicateParameter(name)
            if value is None:
                client_no_context_takeover = True
            else:
                raise InvalidParameterValue(name, value)

        elif name == 'server_max_window_bits':
            if server_max_window_bits is not None:
                raise DuplicateParameter(name)
            if value in _MAX_WINDOW_BITS_VALUES:
                server_max_window_bits = int(value)
            else:
                raise InvalidParameterValue(name, value)

        elif name == 'client_max_window_bits':
            if client_max_window_bits is not None:
                raise DuplicateParameter(name)
            if is_server and value is None:     # only in handshake requests
                client_max_window_bits = True
            elif value in _MAX_WINDOW_BITS_VALUES:
                client_max_window_bits = int(value)
            else:
                raise InvalidParameterValue(name, value)

        else:
            raise InvalidParameterName(name)

    return (
        server_no_context_takeover,
        client_no_context_takeover,
        server_max_window_bits,
        client_max_window_bits,
    )


</t>
<t tx="ekr.20181029161420.553">class ClientPerMessageDeflateFactory:
    """
    Client-side extension factory for permessage-deflate extension.

    """
    name = 'permessage-deflate'

    @others
</t>
<t tx="ekr.20181029161420.554">def __init__(
    self,
    server_no_context_takeover=False,
    client_no_context_takeover=False,
    server_max_window_bits=None,
    client_max_window_bits=None,
    compress_settings=None,
):
    """
    Configure permessage-deflate extension factory.

    See https://tools.ietf.org/html/rfc7692#section-7.1.

    """
    if not (server_max_window_bits is None or
            8 &lt;= server_max_window_bits &lt;= 15):
        raise ValueError("server_max_window_bits must be between 8 and 15")
    if not (client_max_window_bits is None or
            client_max_window_bits is True or
            8 &lt;= client_max_window_bits &lt;= 15):
        raise ValueError("client_max_window_bits must be between 8 and 15")
    if compress_settings is not None and 'wbits' in compress_settings:
        raise ValueError("compress_settings must not include wbits, "
                         "set client_max_window_bits instead")

    self.server_no_context_takeover = server_no_context_takeover
    self.client_no_context_takeover = client_no_context_takeover
    self.server_max_window_bits = server_max_window_bits
    self.client_max_window_bits = client_max_window_bits
    self.compress_settings = compress_settings

</t>
<t tx="ekr.20181029161420.555">def get_request_params(self):
    """
    Build request parameters.

    """
    return _build_parameters(
        self.server_no_context_takeover, self.client_no_context_takeover,
        self.server_max_window_bits, self.client_max_window_bits,
    )

</t>
<t tx="ekr.20181029161420.556">def process_response_params(self, params, accepted_extensions):
    """"
    Process response parameters.

    Return an extension instance.

    """
    if any(other.name == self.name for other in accepted_extensions):
        raise NegotiationError("Received duplicate {}".format(self.name))

    # Request parameters are available in instance variables.

    # Load response parameters in local variables.
    (
        server_no_context_takeover,
        client_no_context_takeover,
        server_max_window_bits,
        client_max_window_bits,
    ) = _extract_parameters(params, is_server=False)

    # After comparing the request and the response, the final
    # configuration must be available in the local variables.

    # server_no_context_takeover
    #
    #   Req.    Resp.   Result
    #   ------  ------  --------------------------------------------------
    #   False   False   False
    #   False   True    True
    #   True    False   Error!
    #   True    True    True

    if self.server_no_context_takeover:
        if not server_no_context_takeover:
            raise NegotiationError("Expected server_no_context_takeover")

    # client_no_context_takeover
    #
    #   Req.    Resp.   Result
    #   ------  ------  --------------------------------------------------
    #   False   False   False
    #   False   True    True
    #   True    False   True - must change value
    #   True    True    True

    if self.client_no_context_takeover:
        if not client_no_context_takeover:
            client_no_context_takeover = True

    # server_max_window_bits

    #   Req.    Resp.   Result
    #   ------  ------  --------------------------------------------------
    #   None    None    None
    #   None    8M15  M
    #   8N15  None    Error!
    #   8N15  8MN   M
    #   8N15  N&lt;M15  Error!

    if self.server_max_window_bits is None:
        pass

    else:
        if server_max_window_bits is None:
            raise NegotiationError("Expected server_max_window_bits")
        elif server_max_window_bits &gt; self.server_max_window_bits:
            raise NegotiationError("Unsupported server_max_window_bits")

    # client_max_window_bits

    #   Req.    Resp.   Result
    #   ------  ------  --------------------------------------------------
    #   None    None    None
    #   None    8M15  Error!
    #   True    None    None
    #   True    8M15  M
    #   8N15  None    N - must change value
    #   8N15  8MN   M
    #   8N15  N&lt;M15  Error!

    if self.client_max_window_bits is None:
        if client_max_window_bits is not None:
            raise NegotiationError("Unexpected client_max_window_bits")

    elif self.client_max_window_bits is True:
        pass

    else:
        if client_max_window_bits is None:
            client_max_window_bits = self.client_max_window_bits
        elif client_max_window_bits &gt; self.client_max_window_bits:
            raise NegotiationError("Unsupported client_max_window_bits")

    return PerMessageDeflate(
        server_no_context_takeover,     # remote_no_context_takeover
        client_no_context_takeover,     # local_no_context_takeover
        server_max_window_bits or 15,   # remote_max_window_bits
        client_max_window_bits or 15,   # local_max_window_bits
        self.compress_settings,
    )


</t>
<t tx="ekr.20181029161420.557">class ServerPerMessageDeflateFactory:
    """
    Server-side extension factory for permessage-deflate extension.

    """
    name = 'permessage-deflate'

    @others
</t>
<t tx="ekr.20181029161420.558">def __init__(
    self,
    server_no_context_takeover=False,
    client_no_context_takeover=False,
    server_max_window_bits=None,
    client_max_window_bits=None,
    compress_settings=None,
):
    """
    Configure permessage-deflate extension factory.

    See https://tools.ietf.org/html/rfc7692#section-7.1.

    """
    if not (server_max_window_bits is None or
            8 &lt;= server_max_window_bits &lt;= 15):
        raise ValueError("server_max_window_bits must be between 8 and 15")
    if not (client_max_window_bits is None or
            8 &lt;= client_max_window_bits &lt;= 15):
        raise ValueError("client_max_window_bits must be between 8 and 15")
    if compress_settings is not None and 'wbits' in compress_settings:
        raise ValueError("compress_settings must not include wbits, "
                         "set server_max_window_bits instead")

    self.server_no_context_takeover = server_no_context_takeover
    self.client_no_context_takeover = client_no_context_takeover
    self.server_max_window_bits = server_max_window_bits
    self.client_max_window_bits = client_max_window_bits
    self.compress_settings = compress_settings

</t>
<t tx="ekr.20181029161420.559">def process_request_params(self, params, accepted_extensions):
    """"
    Process request parameters.

    Return response params and an extension instance.

    """
    if any(other.name == self.name for other in accepted_extensions):
        raise NegotiationError("Skipped duplicate {}".format(self.name))

    # Load request parameters in local variables.
    (
        server_no_context_takeover,
        client_no_context_takeover,
        server_max_window_bits,
        client_max_window_bits,
    ) = _extract_parameters(params, is_server=True)

    # Configuration parameters are available in instance variables.

    # After comparing the request and the configuration, the response must
    # be available in the local variables.

    # server_no_context_takeover
    #
    #   Config  Req.    Resp.
    #   ------  ------  --------------------------------------------------
    #   False   False   False
    #   False   True    True
    #   True    False   True - must change value to True
    #   True    True    True

    if self.server_no_context_takeover:
        if not server_no_context_takeover:
            server_no_context_takeover = True

    # client_no_context_takeover
    #
    #   Config  Req.    Resp.
    #   ------  ------  --------------------------------------------------
    #   False   False   False
    #   False   True    True (or False)
    #   True    False   True - must change value to True
    #   True    True    True (or False)

    if self.client_no_context_takeover:
        if not client_no_context_takeover:
            client_no_context_takeover = True

    # server_max_window_bits

    #   Config  Req.    Resp.
    #   ------  ------  --------------------------------------------------
    #   None    None    None
    #   None    8M15  M
    #   8N15  None    N - must change value
    #   8N15  8MN   M
    #   8N15  N&lt;M15  N - must change value

    if self.server_max_window_bits is None:
        pass

    else:
        if server_max_window_bits is None:
            server_max_window_bits = self.server_max_window_bits
        elif server_max_window_bits &gt; self.server_max_window_bits:
            server_max_window_bits = self.server_max_window_bits

    # client_max_window_bits

    #   Config  Req.    Resp.
    #   ------  ------  --------------------------------------------------
    #   None    None    None
    #   None    True    None - must change value
    #   None    8M15  M (or None)
    #   8N15  None    Error!
    #   8N15  True    N - must change value
    #   8N15  8MN   M (or None)
    #   8N15  N&lt;M15  N

    if self.client_max_window_bits is None:
        if client_max_window_bits is True:
            client_max_window_bits = self.client_max_window_bits

    else:
        if client_max_window_bits is None:
            raise NegotiationError("Required client_max_window_bits")
        elif client_max_window_bits is True:
            client_max_window_bits = self.client_max_window_bits
        elif self.client_max_window_bits &lt; client_max_window_bits:
            client_max_window_bits = self.client_max_window_bits

    return (
        _build_parameters(
            server_no_context_takeover, client_no_context_takeover,
            server_max_window_bits, client_max_window_bits,
        ),
        PerMessageDeflate(
            client_no_context_takeover,     # remote_no_context_takeover
            server_no_context_takeover,     # local_no_context_takeover
            client_max_window_bits or 15,   # remote_max_window_bits
            server_max_window_bits or 15,   # local_max_window_bits
            self.compress_settings,
        )
    )


</t>
<t tx="ekr.20181029161420.56">@path C:/Anaconda3/Lib/site-packages/websockets/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.560">class PerMessageDeflate:
    """
    permessage-deflate extension.

    """
    name = 'permessage-deflate'

    @others
</t>
<t tx="ekr.20181029161420.561">def __init__(
    self,
    remote_no_context_takeover,
    local_no_context_takeover,
    remote_max_window_bits,
    local_max_window_bits,
    compress_settings=None,
):
    """
    Configure permessage-deflate extension.

    """
    if compress_settings is None:
        compress_settings = {}

    assert remote_no_context_takeover in [False, True]
    assert local_no_context_takeover in [False, True]
    assert 8 &lt;= remote_max_window_bits &lt;= 15
    assert 8 &lt;= local_max_window_bits &lt;= 15
    assert 'wbits' not in compress_settings

    self.remote_no_context_takeover = remote_no_context_takeover
    self.local_no_context_takeover = local_no_context_takeover
    self.remote_max_window_bits = remote_max_window_bits
    self.local_max_window_bits = local_max_window_bits
    self.compress_settings = compress_settings

    if not self.remote_no_context_takeover:
        self.decoder = zlib.decompressobj(
            wbits=-self.remote_max_window_bits)

    if not self.local_no_context_takeover:
        self.encoder = zlib.compressobj(
            wbits=-self.local_max_window_bits,
            **self.compress_settings)

    # To handle continuation frames properly, we must keep track of
    # whether that initial frame was encoded.
    self.decode_cont_data = False
    # There's no need for self.encode_cont_data because we always encode
    # outgoing frames, so it would always be True.

</t>
<t tx="ekr.20181029161420.562">def __repr__(self):
    return 'PerMessageDeflate({})'.format(', '.join([
        'remote_no_context_takeover={}'.format(
            self.remote_no_context_takeover),
        'local_no_context_takeover={}'.format(
            self.local_no_context_takeover),
        'remote_max_window_bits={}'.format(
            self.remote_max_window_bits),
        'local_max_window_bits={}'.format(
            self.local_max_window_bits),
    ]))

</t>
<t tx="ekr.20181029161420.563">def decode(self, frame, *, max_size=None):
    """
    Decode an incoming frame.

    """
    # Skip control frames.
    if frame.opcode in CTRL_OPCODES:
        return frame

    # Handle continuation data frames:
    # - skip if the initial data frame wasn't encoded
    # - reset "decode continuation data" flag if it's a final frame
    if frame.opcode == OP_CONT:
        if not self.decode_cont_data:
            return frame
        if frame.fin:
            self.decode_cont_data = False

    # Handle text and binary data frames:
    # - skip if the frame isn't encoded
    # - set "decode continuation data" flag if it's a non-final frame
    else:
        if not frame.rsv1:
            return frame
        if not frame.fin:  # frame.rsv1 is True at this point
            self.decode_cont_data = True

        # Re-initialize per-message decoder.
        if self.remote_no_context_takeover:
            self.decoder = zlib.decompressobj(
                wbits=-self.remote_max_window_bits)

    # Uncompress compressed frames. Protect against zip bombs by
    # preventing zlib from decompressing more than max_length bytes
    # (except when the limit is disabled with max_size = None).
    data = frame.data
    if frame.fin:
        data += _EMPTY_UNCOMPRESSED_BLOCK
    max_length = 0 if max_size is None else max_size
    data = self.decoder.decompress(data, max_length)
    if self.decoder.unconsumed_tail:
        raise PayloadTooBig(
            "Uncompressed payload length exceeds size limit (? &gt; {} bytes)"
            .format(max_size))

    # Allow garbage collection of the decoder if it won't be reused.
    if frame.fin and self.remote_no_context_takeover:
        self.decoder = None

    return frame._replace(data=data, rsv1=False)

</t>
<t tx="ekr.20181029161420.564">def encode(self, frame):
    """
    Encode an outgoing frame.

    """
    # Skip control frames.
    if frame.opcode in CTRL_OPCODES:
        return frame

    # Since we always encode and never fragment messages, there's no logic
    # similar to decode() here at this time.

    if frame.opcode != OP_CONT:
        # Re-initialize per-message decoder.
        if self.local_no_context_takeover:
            self.encoder = zlib.compressobj(
                wbits=-self.local_max_window_bits,
                **self.compress_settings)

    # Compress data frames.
    data = (
        self.encoder.compress(frame.data) +
        self.encoder.flush(zlib.Z_SYNC_FLUSH)
    )
    if frame.fin and data.endswith(_EMPTY_UNCOMPRESSED_BLOCK):
        data = data[:-4]

    # Allow garbage collection of the encoder if it won't be reused.
    if frame.fin and self.local_no_context_takeover:
        self.encoder = None

    return frame._replace(data=data, rsv1=True)
</t>
<t tx="ekr.20181029161420.565">@path C:/Anaconda3/Lib/site-packages/websockets/extensions/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.566">from .base import *  # noqa


# Abstract classes don't provide any behavior to test.
</t>
<t tx="ekr.20181029161420.567">@path C:/Anaconda3/Lib/site-packages/websockets/extensions/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.568">import unittest
import zlib

from ..exceptions import (
    DuplicateParameter, InvalidParameterName, InvalidParameterValue,
    NegotiationError, PayloadTooBig
)
from ..framing import (
    OP_BINARY, OP_CLOSE, OP_CONT, OP_PING, OP_PONG, OP_TEXT, Frame,
    serialize_close
)
from .permessage_deflate import *


</t>
<t tx="ekr.20181029161420.569">class ExtensionTestsMixin:

    @others
</t>
<t tx="ekr.20181029161420.57">"""
The :mod:`websockets.handshake` module deals with the WebSocket opening
handshake according to `section 4 of RFC 6455`_.

.. _section 4 of RFC 6455: http://tools.ietf.org/html/rfc6455#section-4

Functions defined in this module manipulate HTTP headers. The ``headers``
argument must implement ``get`` and ``__setitem__`` and ``get``   a small
subset of the :class:`~collections.abc.MutableMapping` abstract base class.

Headers names and values are :class:`str` objects containing only ASCII
characters.

Some checks cannot be performed because they depend too much on the
context; instead, they're documented below.

To accept a connection, a server must:

- Read the request, check that the method is GET, and check the headers with
  :func:`check_request`,
- Send a 101 response to the client with the headers created by
  :func:`build_response` if the request is valid; otherwise, send an
  appropriate HTTP error code.

To open a connection, a client must:

- Send a GET request to the server with the headers created by
  :func:`build_request`,
- Read the response, check that the status code is 101, and check the headers
  with :func:`check_response`.

"""

import base64
import binascii
import hashlib
import random

from .exceptions import InvalidHeaderValue, InvalidUpgrade
from .headers import parse_connection, parse_upgrade


__all__ = [
    'build_request', 'check_request',
    'build_response', 'check_response',
]

GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'


</t>
<t tx="ekr.20181029161420.570">def assertExtensionEqual(self, extension1, extension2):
    self.assertEqual(extension1.remote_no_context_takeover,
                     extension2.remote_no_context_takeover)
    self.assertEqual(extension1.local_no_context_takeover,
                     extension2.local_no_context_takeover)
    self.assertEqual(extension1.remote_max_window_bits,
                     extension2.remote_max_window_bits)
    self.assertEqual(extension1.local_max_window_bits,
                     extension2.local_max_window_bits)


</t>
<t tx="ekr.20181029161420.571">class ClientPerMessageDeflateFactoryTests(unittest.TestCase,
                                          ExtensionTestsMixin):

    @others
</t>
<t tx="ekr.20181029161420.572">def test_name(self):
    assert ClientPerMessageDeflateFactory.name == 'permessage-deflate'

</t>
<t tx="ekr.20181029161420.573">def test_init(self):
    for config in [
        (False, False, 8, None),        # server_max_window_bits  8
        (False, True, 15, None),        # server_max_window_bits  15
        (True, False, None, 8),         # client_max_window_bits  8
        (True, True, None, 15),         # client_max_window_bits  15
        (False, False, None, True),     # client_max_window_bits
        (False, False, None, None, {'memLevel': 4}),
    ]:
        with self.subTest(config=config):
            # This does not raise an exception.
            ClientPerMessageDeflateFactory(*config)

</t>
<t tx="ekr.20181029161420.574">def test_init_error(self):
    for config in [
        (False, False, 7, 8),           # server_max_window_bits &lt; 8
        (False, True, 8, 7),            # client_max_window_bits &lt; 8
        (True, False, 16, 15),          # server_max_window_bits &gt; 15
        (True, True, 15, 16),           # client_max_window_bits &gt; 15
        (False, False, True, None),     # server_max_window_bits
        (False, False, None, None, {'wbits': 11}),
    ]:
        with self.subTest(config=config):
            with self.assertRaises(ValueError):
                ClientPerMessageDeflateFactory(*config)

</t>
<t tx="ekr.20181029161420.575">def test_get_request_params(self):
    for config, result in [
        # Test without any parameter
        (
            (False, False, None, None),
            [],
        ),
        # Test server_no_context_takeover
        (
            (True, False, None, None),
            [('server_no_context_takeover', None)],
        ),
        # Test client_no_context_takeover
        (
            (False, True, None, None),
            [('client_no_context_takeover', None)],
        ),
        # Test server_max_window_bits
        (
            (False, False, 10, None),
            [('server_max_window_bits', '10')],
        ),
        # Test client_max_window_bits
        (
            (False, False, None, 10),
            [('client_max_window_bits', '10')],
        ),
        (
            (False, False, None, True),
            [('client_max_window_bits', None)],
        ),
        # Test all parameters together
        (
            (True, True, 12, 12),
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '12'),
                ('client_max_window_bits', '12'),
            ],
        ),
    ]:
        with self.subTest(config=config):
            factory = ClientPerMessageDeflateFactory(*config)
            self.assertEqual(factory.get_request_params(), result)

</t>
<t tx="ekr.20181029161420.576">def test_process_response_params(self):
    for config, response_params, result in [
        # Test without any parameter
        (
            (False, False, None, None),
            [],
            (False, False, 15, 15),
        ),
        (
            (False, False, None, None),
            [('unknown', None)],
            InvalidParameterName,
        ),
        # Test server_no_context_takeover
        (
            (False, False, None, None),
            [('server_no_context_takeover', None)],
            (True, False, 15, 15),
        ),
        (
            (True, False, None, None),
            [],
            NegotiationError,
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', None)],
            (True, False, 15, 15),
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', None)] * 2,
            DuplicateParameter,
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', '42')],
            InvalidParameterValue,
        ),
        # Test client_no_context_takeover
        (
            (False, False, None, None),
            [('client_no_context_takeover', None)],
            (False, True, 15, 15),
        ),
        (
            (False, True, None, None),
            [],
            (False, True, 15, 15),
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', None)],
            (False, True, 15, 15),
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', None)] * 2,
            DuplicateParameter,
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', '42')],
            InvalidParameterValue,
        ),
        # Test server_max_window_bits
        (
            (False, False, None, None),
            [('server_max_window_bits', '7')],
            NegotiationError,
        ),
        (
            (False, False, None, None),
            [('server_max_window_bits', '10')],
            (False, False, 10, 15),
        ),
        (
            (False, False, None, None),
            [('server_max_window_bits', '16')],
            NegotiationError,
        ),
        (
            (False, False, 12, None),
            [],
            NegotiationError,
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '10')],
            (False, False, 10, 15),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '12')],
            (False, False, 12, 15),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '13')],
            NegotiationError,
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '12')] * 2,
            DuplicateParameter,
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '42')],
            InvalidParameterValue,
        ),
        # Test client_max_window_bits
        (
            (False, False, None, None),
            [('client_max_window_bits', '10')],
            NegotiationError,
        ),
        (
            (False, False, None, True),
            [],
            (False, False, 15, 15),
        ),
        (
            (False, False, None, True),
            [('client_max_window_bits', '7')],
            NegotiationError,
        ),
        (
            (False, False, None, True),
            [('client_max_window_bits', '10')],
            (False, False, 15, 10),
        ),
        (
            (False, False, None, True),
            [('client_max_window_bits', '16')],
            NegotiationError,
        ),
        (
            (False, False, None, 12),
            [],
            (False, False, 15, 12),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '10')],
            (False, False, 15, 10),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '12')],
            (False, False, 15, 12),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '13')],
            NegotiationError,
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '12')] * 2,
            DuplicateParameter,
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '42')],
            InvalidParameterValue,
        ),
        # Test all parameters together
        (
            (True, True, 12, 12),
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            (True, True, 10, 10),
        ),
        (
            (False, False, None, True),
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            (True, True, 10, 10),
        ),
        (
            (True, True, 12, 12),
            [
                ('server_no_context_takeover', None),
                ('server_max_window_bits', '12'),
            ],
            (True, True, 12, 12),
        ),
    ]:
        with self.subTest(
            config=config,
            response_params=response_params,
        ):
            factory = ClientPerMessageDeflateFactory(*config)
            if isinstance(result, type) and issubclass(result, Exception):
                with self.assertRaises(result):
                    factory.process_response_params(response_params, [])
            else:
                extension = factory.process_response_params(
                    response_params, [])
                expected = PerMessageDeflate(*result)
                self.assertExtensionEqual(extension, expected)

</t>
<t tx="ekr.20181029161420.577">def test_process_response_params_deduplication(self):
    factory = ClientPerMessageDeflateFactory(False, False, None, None)
    with self.assertRaises(NegotiationError):
        factory.process_response_params(
            [], [PerMessageDeflate(False, False, 15, 15)])


</t>
<t tx="ekr.20181029161420.578">class ServerPerMessageDeflateFactoryTests(unittest.TestCase,
                                          ExtensionTestsMixin):

    @others
</t>
<t tx="ekr.20181029161420.579">def test_name(self):
    assert ServerPerMessageDeflateFactory.name == 'permessage-deflate'

</t>
<t tx="ekr.20181029161420.58">def build_request(headers):
    """
    Build a handshake request to send to the server.

    Return the ``key`` which must be passed to :func:`check_response`.

    """
    raw_key = bytes(random.getrandbits(8) for _ in range(16))
    key = base64.b64encode(raw_key).decode()
    headers['Upgrade'] = 'websocket'
    headers['Connection'] = 'Upgrade'
    headers['Sec-WebSocket-Key'] = key
    headers['Sec-WebSocket-Version'] = '13'
    return key


</t>
<t tx="ekr.20181029161420.580">def test_init(self):
    for config in [
        (False, False, 8, None),        # server_max_window_bits  8
        (False, True, 15, None),        # server_max_window_bits  15
        (True, False, None, 8),         # client_max_window_bits  8
        (True, True, None, 15),         # client_max_window_bits  15
        (False, False, None, None, {'memLevel': 4}),
    ]:
        with self.subTest(config=config):
            # This does not raise an exception.
            ServerPerMessageDeflateFactory(*config)

</t>
<t tx="ekr.20181029161420.581">def test_init_error(self):
    for config in [
        (False, False, 7, 8),           # server_max_window_bits &lt; 8
        (False, True, 8, 7),            # client_max_window_bits &lt; 8
        (True, False, 16, 15),          # server_max_window_bits &gt; 15
        (True, True, 15, 16),           # client_max_window_bits &gt; 15
        (False, False, None, True),     # client_max_window_bits
        (False, False, True, None),     # server_max_window_bits
        (False, False, None, None, {'wbits': 11}),
    ]:
        with self.subTest(config=config):
            with self.assertRaises(ValueError):
                ServerPerMessageDeflateFactory(*config)

</t>
<t tx="ekr.20181029161420.582">def test_process_request_params(self):
    # Parameters in result appear swapped vs. config because the order is
    # (remote, local) vs. (server, client).
    for config, request_params, response_params, result in [
        # Test without any parameter
        (
            (False, False, None, None),
            [],
            [],
            (False, False, 15, 15),
        ),
        (
            (False, False, None, None),
            [('unknown', None)],
            None,
            InvalidParameterName,
        ),
        # Test server_no_context_takeover
        (
            (False, False, None, None),
            [('server_no_context_takeover', None)],
            [('server_no_context_takeover', None)],
            (False, True, 15, 15),
        ),
        (
            (True, False, None, None),
            [],
            [('server_no_context_takeover', None)],
            (False, True, 15, 15),
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', None)],
            [('server_no_context_takeover', None)],
            (False, True, 15, 15),
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', None)] * 2,
            None,
            DuplicateParameter,
        ),
        (
            (True, False, None, None),
            [('server_no_context_takeover', '42')],
            None,
            InvalidParameterValue,
        ),
        # Test client_no_context_takeover
        (
            (False, False, None, None),
            [('client_no_context_takeover', None)],
            [('client_no_context_takeover', None)],     # doesn't matter
            (True, False, 15, 15),
        ),
        (
            (False, True, None, None),
            [],
            [('client_no_context_takeover', None)],
            (True, False, 15, 15),
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', None)],
            [('client_no_context_takeover', None)],     # doesn't matter
            (True, False, 15, 15),
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', None)] * 2,
            None,
            DuplicateParameter,
        ),
        (
            (False, True, None, None),
            [('client_no_context_takeover', '42')],
            None,
            InvalidParameterValue,
        ),
        # Test server_max_window_bits
        (
            (False, False, None, None),
            [('server_max_window_bits', '7')],
            None,
            NegotiationError,
        ),
        (
            (False, False, None, None),
            [('server_max_window_bits', '10')],
            [('server_max_window_bits', '10')],
            (False, False, 15, 10),
        ),
        (
            (False, False, None, None),
            [('server_max_window_bits', '16')],
            None,
            NegotiationError,
        ),
        (
            (False, False, 12, None),
            [],
            [('server_max_window_bits', '12')],
            (False, False, 15, 12),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '10')],
            [('server_max_window_bits', '10')],
            (False, False, 15, 10),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '12')],
            [('server_max_window_bits', '12')],
            (False, False, 15, 12),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '13')],
            [('server_max_window_bits', '12')],
            (False, False, 15, 12),
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '12')] * 2,
            None,
            DuplicateParameter,
        ),
        (
            (False, False, 12, None),
            [('server_max_window_bits', '42')],
            None,
            InvalidParameterValue,
        ),
        # Test client_max_window_bits
        (
            (False, False, None, None),
            [('client_max_window_bits', None)],
            [],
            (False, False, 15, 15),
        ),
        (
            (False, False, None, None),
            [('client_max_window_bits', '7')],
            None,
            InvalidParameterValue,
        ),
        (
            (False, False, None, None),
            [('client_max_window_bits', '10')],
            [('client_max_window_bits', '10')],     # doesn't matter
            (False, False, 10, 15),
        ),
        (
            (False, False, None, None),
            [('client_max_window_bits', '16')],
            None,
            InvalidParameterValue,
        ),
        (
            (False, False, None, 12),
            [],
            None,
            NegotiationError,
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', None)],
            [('client_max_window_bits', '12')],
            (False, False, 12, 15),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '10')],
            [('client_max_window_bits', '10')],
            (False, False, 10, 15),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '12')],
            [('client_max_window_bits', '12')],     # doesn't matter
            (False, False, 12, 15),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '13')],
            [('client_max_window_bits', '12')],     # doesn't matter
            (False, False, 12, 15),
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '12')] * 2,
            None,
            DuplicateParameter,
        ),
        (
            (False, False, None, 12),
            [('client_max_window_bits', '42')],
            None,
            InvalidParameterValue,
        ),
        # # Test all parameters together
        (
            (True, True, 12, 12),
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            (True, True, 10, 10),
        ),
        (
            (False, False, None, None),
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '10'),
                ('client_max_window_bits', '10'),
            ],
            (True, True, 10, 10),
        ),
        (
            (True, True, 12, 12),
            [
                ('client_max_window_bits', None),
            ],
            [
                ('server_no_context_takeover', None),
                ('client_no_context_takeover', None),
                ('server_max_window_bits', '12'),
                ('client_max_window_bits', '12'),
            ],
            (True, True, 12, 12),
        ),
    ]:
        with self.subTest(
            config=config,
            request_params=request_params,
            response_params=response_params,
        ):
            factory = ServerPerMessageDeflateFactory(*config)
            if isinstance(result, type) and issubclass(result, Exception):
                with self.assertRaises(result):
                    factory.process_request_params(request_params, [])
            else:
                params, extension = factory.process_request_params(
                    request_params, [])
                self.assertEqual(params, response_params)
                expected = PerMessageDeflate(*result)
                self.assertExtensionEqual(extension, expected)

</t>
<t tx="ekr.20181029161420.583">def test_process_response_params_deduplication(self):
    factory = ServerPerMessageDeflateFactory(False, False, None, None)
    with self.assertRaises(NegotiationError):
        factory.process_request_params(
            [], [PerMessageDeflate(False, False, 15, 15)])


</t>
<t tx="ekr.20181029161420.584">class PerMessageDeflateTests(unittest.TestCase):

    @others
</t>
<t tx="ekr.20181029161420.585">def setUp(self):
    # Set up an instance of the permessage-deflate extension with the most
    # common settings. Since the extension is symmetrical, this instance
    # may be used for testing both encoding and decoding.
    self.extension = PerMessageDeflate(False, False, 15, 15)

</t>
<t tx="ekr.20181029161420.586">def test_name(self):
    assert self.extension.name == 'permessage-deflate'

# Control frames aren't encoded or decoded.

</t>
<t tx="ekr.20181029161420.587">def test_no_encode_decode_ping_frame(self):
    frame = Frame(True, OP_PING, b'')

    self.assertEqual(self.extension.encode(frame), frame)

    self.assertEqual(self.extension.decode(frame), frame)

</t>
<t tx="ekr.20181029161420.588">def test_no_encode_decode_pong_frame(self):
    frame = Frame(True, OP_PONG, b'')

    self.assertEqual(self.extension.encode(frame), frame)

    self.assertEqual(self.extension.decode(frame), frame)

</t>
<t tx="ekr.20181029161420.589">def test_no_encode_decode_close_frame(self):
    frame = Frame(True, OP_CLOSE, serialize_close(1000, ''))

    self.assertEqual(self.extension.encode(frame), frame)

    self.assertEqual(self.extension.decode(frame), frame)

# Data frames are encoded and decoded.

</t>
<t tx="ekr.20181029161420.59">def check_request(headers):
    """
    Check a handshake request received from the client.

    If the handshake is valid, this function returns the ``key`` which must be
    passed to :func:`build_response`.

    Otherwise it raises an :exc:`~websockets.exceptions.InvalidHandshake`
    exception and the server must return an error like 400 Bad Request.

    This function doesn't verify that the request is an HTTP/1.1 or higher GET
    request and doesn't perform Host and Origin checks. These controls are
    usually performed earlier in the HTTP request handling code. They're the
    responsibility of the caller.

    """
    connection = parse_connection(headers.get('Connection', ''))
    if not any(value.lower() == 'upgrade' for value in connection):
        raise InvalidUpgrade('Connection', headers.get('Connection', ''))

    upgrade = parse_upgrade(headers.get('Upgrade', ''))
    # For compatibility with non-strict implementations, ignore case when
    # checking the Upgrade header. It's supposed to be 'WebSocket'.
    if not (len(upgrade) == 1 and upgrade[0].lower() == 'websocket'):
        raise InvalidUpgrade('Upgrade', headers.get('Upgrade', ''))

    key = headers.get('Sec-WebSocket-Key', '')
    try:
        raw_key = base64.b64decode(key.encode(), validate=True)
    except binascii.Error:
        raise InvalidHeaderValue('Sec-WebSocket-Key', key)
    if len(raw_key) != 16:
        raise InvalidHeaderValue('Sec-WebSocket-Key', key)

    version = headers.get('Sec-WebSocket-Version', '')
    if version != '13':
        raise InvalidHeaderValue('Sec-WebSocket-Version', version)

    return key


</t>
<t tx="ekr.20181029161420.590">def test_encode_decode_text_frame(self):
    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    enc_frame = self.extension.encode(frame)

    self.assertEqual(enc_frame, frame._replace(
        rsv1=True,
        data=b'JNL;\xbc\x12\x00',
    ))

    dec_frame = self.extension.decode(enc_frame)

    self.assertEqual(dec_frame, frame)

</t>
<t tx="ekr.20181029161420.591">def test_encode_decode_binary_frame(self):
    frame = Frame(True, OP_BINARY, b'tea')

    enc_frame = self.extension.encode(frame)

    self.assertEqual(enc_frame, frame._replace(
        rsv1=True,
        data=b'*IM\x04\x00',
    ))

    dec_frame = self.extension.decode(enc_frame)

    self.assertEqual(dec_frame, frame)

</t>
<t tx="ekr.20181029161420.592">def test_encode_decode_fragmented_text_frame(self):
    frame1 = Frame(False, OP_TEXT, 'caf'.encode('utf-8'))
    frame2 = Frame(False, OP_CONT, ' &amp; '.encode('utf-8'))
    frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))

    enc_frame1 = self.extension.encode(frame1)
    enc_frame2 = self.extension.encode(frame2)
    enc_frame3 = self.extension.encode(frame3)

    self.assertEqual(enc_frame1, frame1._replace(
        rsv1=True,
        data=b'JNL;\xbc\x12\x00\x00\x00\xff\xff',
    ))
    self.assertEqual(enc_frame2, frame2._replace(
        rsv1=True,
        data=b'RPS\x00\x00\x00\x00\xff\xff',
    ))
    self.assertEqual(enc_frame3, frame3._replace(
        rsv1=True,
        data=b'J.\xca\xcf,.N\xcc+)\x06\x00',
    ))

    dec_frame1 = self.extension.decode(enc_frame1)
    dec_frame2 = self.extension.decode(enc_frame2)
    dec_frame3 = self.extension.decode(enc_frame3)

    self.assertEqual(dec_frame1, frame1)
    self.assertEqual(dec_frame2, frame2)
    self.assertEqual(dec_frame3, frame3)

</t>
<t tx="ekr.20181029161420.593">def test_encode_decode_fragmented_binary_frame(self):
    frame1 = Frame(False, OP_TEXT, b'tea ')
    frame2 = Frame(True, OP_CONT, b'time')

    enc_frame1 = self.extension.encode(frame1)
    enc_frame2 = self.extension.encode(frame2)

    self.assertEqual(enc_frame1, frame1._replace(
        rsv1=True,
        data=b'*IMT\x00\x00\x00\x00\xff\xff',
    ))
    self.assertEqual(enc_frame2, frame2._replace(
        rsv1=True,
        data=b'*\xc9\xccM\x05\x00',
    ))

    dec_frame1 = self.extension.decode(enc_frame1)
    dec_frame2 = self.extension.decode(enc_frame2)

    self.assertEqual(dec_frame1, frame1)
    self.assertEqual(dec_frame2, frame2)

</t>
<t tx="ekr.20181029161420.594">def test_no_decode_text_frame(self):
    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    # Try decoding a frame that wasn't encoded.
    self.assertEqual(self.extension.decode(frame), frame)

</t>
<t tx="ekr.20181029161420.595">def test_no_decode_binary_frame(self):
    frame = Frame(True, OP_TEXT, b'tea')

    # Try decoding a frame that wasn't encoded.
    self.assertEqual(self.extension.decode(frame), frame)

</t>
<t tx="ekr.20181029161420.596">def test_no_decode_fragmented_text_frame(self):
    frame1 = Frame(False, OP_TEXT, 'caf'.encode('utf-8'))
    frame2 = Frame(False, OP_CONT, ' &amp; '.encode('utf-8'))
    frame3 = Frame(True, OP_CONT, 'croissants'.encode('utf-8'))

    dec_frame1 = self.extension.decode(frame1)
    dec_frame2 = self.extension.decode(frame2)
    dec_frame3 = self.extension.decode(frame3)

    self.assertEqual(dec_frame1, frame1)
    self.assertEqual(dec_frame2, frame2)
    self.assertEqual(dec_frame3, frame3)

</t>
<t tx="ekr.20181029161420.597">def test_no_decode_fragmented_binary_frame(self):
    frame1 = Frame(False, OP_TEXT, b'tea ')
    frame2 = Frame(True, OP_CONT, b'time')

    dec_frame1 = self.extension.decode(frame1)
    dec_frame2 = self.extension.decode(frame2)

    self.assertEqual(dec_frame1, frame1)
    self.assertEqual(dec_frame2, frame2)

</t>
<t tx="ekr.20181029161420.598">def test_context_takeover(self):
    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    enc_frame1 = self.extension.encode(frame)
    enc_frame2 = self.extension.encode(frame)

    self.assertEqual(enc_frame1.data, b'JNL;\xbc\x12\x00')
    self.assertEqual(enc_frame2.data, b'J\x06\x11\x00\x00')

</t>
<t tx="ekr.20181029161420.599">def test_remote_no_context_takeover(self):
    # No context takeover when decoding messages.
    self.extension = PerMessageDeflate(True, False, 15, 15)

    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    enc_frame1 = self.extension.encode(frame)
    enc_frame2 = self.extension.encode(frame)

    self.assertEqual(enc_frame1.data, b'JNL;\xbc\x12\x00')
    self.assertEqual(enc_frame2.data, b'J\x06\x11\x00\x00')

    dec_frame1 = self.extension.decode(enc_frame1)
    self.assertEqual(dec_frame1, frame)

    with self.assertRaises(zlib.error) as exc:
        self.extension.decode(enc_frame2)
    self.assertIn("invalid distance too far back", str(exc.exception))

</t>
<t tx="ekr.20181029161420.6">@asyncio.coroutine
def write_http_request(self, path, headers):
    """
    Write request line and headers to the HTTP request.

    """
    self.path = path
    self.request_headers = headers

    # Since the path and headers only contain ASCII characters,
    # we can keep this simple.
    request = 'GET {path} HTTP/1.1\r\n'.format(path=path)
    request += str(headers)

    self.writer.write(request.encode())

</t>
<t tx="ekr.20181029161420.60">def build_response(headers, key):
    """
    Build a handshake response to send to the client.

    ``key`` comes from :func:`check_request`.

    """
    headers['Upgrade'] = 'websocket'
    headers['Connection'] = 'Upgrade'
    headers['Sec-WebSocket-Accept'] = accept(key)


</t>
<t tx="ekr.20181029161420.600">def test_local_no_context_takeover(self):
    # No context takeover when encoding and decoding messages.
    self.extension = PerMessageDeflate(True, True, 15, 15)

    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    enc_frame1 = self.extension.encode(frame)
    enc_frame2 = self.extension.encode(frame)

    self.assertEqual(enc_frame1.data, b'JNL;\xbc\x12\x00')
    self.assertEqual(enc_frame2.data, b'JNL;\xbc\x12\x00')

    dec_frame1 = self.extension.decode(enc_frame1)
    dec_frame2 = self.extension.decode(enc_frame2)

    self.assertEqual(dec_frame1, frame)
    self.assertEqual(dec_frame2, frame)

# Compression settings can be customized.

</t>
<t tx="ekr.20181029161420.601">def test_compress_settings(self):
    # Configure an extension so that no compression actually occurs.
    extension = PerMessageDeflate(False, False, 15, 15, {'level': 0})

    frame = Frame(True, OP_TEXT, 'caf'.encode('utf-8'))

    enc_frame = extension.encode(frame)

    self.assertEqual(enc_frame, frame._replace(
        rsv1=True,
        data=b'\x00\x05\x00\xfa\xffcaf\xc3\xa9\x00',    # not compressed
    ))

# Frames aren't decoded beyond max_length.

</t>
<t tx="ekr.20181029161420.602">def test_decompress_max_size(self):
    frame = Frame(True, OP_TEXT, ('a' * 20).encode('utf-8'))

    enc_frame = self.extension.encode(frame)

    self.assertEqual(enc_frame.data, b'JL\xc4\x04\x00\x00')

    with self.assertRaises(PayloadTooBig):
        self.extension.decode(enc_frame, max_size=10)
</t>
<t tx="ekr.20181029161420.603">@path C:/Anaconda3/Lib/site-packages/websockets/extensions/
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.604">@path C:/Anaconda3/Lib/site-packages/websockets/py36/

from ..exceptions import ConnectionClosed

async def __aiter__(self):
    """
    Iterate on received messages.

    Exit normally when the connection is closed with code 1000.

    Raise an exception in other cases.

    """
    try:
        while True:
            yield await self.recv()
    except ConnectionClosed as exc:
        if exc.code == 1000 or exc.code == 1001:
            return
        else:
            raise

@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.61">def check_response(headers, key):
    """
    Check a handshake response received from the server.

    ``key`` comes from :func:`build_request`.

    If the handshake is valid, this function returns ``None``.

    Otherwise it raises an :exc:`~websockets.exceptions.InvalidHandshake`
    exception.

    This function doesn't verify that the response is an HTTP/1.1 or higher
    response with a 101 status code. These controls are the responsibility of
    the caller.

    """
    connection = parse_connection(headers.get('Connection', ''))
    if not any(value.lower() == 'upgrade' for value in connection):
        raise InvalidUpgrade('Connection', headers.get('Connection', ''))

    upgrade = parse_upgrade(headers.get('Upgrade', ''))
    # For compatibility with non-strict implementations, ignore case when
    # checking the Upgrade header. It's supposed to be 'WebSocket'.
    if not (len(upgrade) == 1 and upgrade[0].lower() == 'websocket'):
        raise InvalidUpgrade('Upgrade', headers.get('Upgrade', ''))

    if headers.get('Sec-WebSocket-Accept', '') != accept(key):
        raise InvalidHeaderValue(
            'Sec-WebSocket-Accept', headers.get('Sec-WebSocket-Accept', ''))


</t>
<t tx="ekr.20181029161420.62">def accept(key):
    sha1 = hashlib.sha1((key + GUID).encode()).digest()
    return base64.b64encode(sha1).decode()
</t>
<t tx="ekr.20181029161420.63">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.headers` module provides parsers and serializers for HTTP
headers used in WebSocket handshake messages.

Its functions cannot be imported from :mod:`websockets`. They must be imported
from :mod:`websockets.headers`.

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.64">import base64
import re

from .exceptions import InvalidHeaderFormat


__all__ = [
    'parse_connection', 'parse_upgrade',
    'parse_extension_list', 'build_extension_list',
    'parse_subprotocol_list', 'build_subprotocol_list',
]


# To avoid a dependency on a parsing library, we implement manually the ABNF
# described in https://tools.ietf.org/html/rfc6455#section-9.1 with the
# definitions from https://tools.ietf.org/html/rfc7230#appendix-B.

</t>
<t tx="ekr.20181029161420.65">def peek_ahead(string, pos):
    """
    Return the next character from ``string`` at the given position.

    Return ``None`` at the end of ``string``.

    We never need to peek more than one character ahead.

    """
    return None if pos == len(string) else string[pos]


_OWS_re = re.compile(r'[\t ]*')


</t>
<t tx="ekr.20181029161420.66">def parse_OWS(string, pos):
    """
    Parse optional whitespace from ``string`` at the given position.

    Return the new position.

    The whitespace itself isn't returned because it isn't significant.

    """
    # There's always a match, possibly empty, whose content doesn't matter.
    match = _OWS_re.match(string, pos)
    return match.end()


_token_re = re.compile(r'[-!#$%&amp;\'*+.^_`|~0-9a-zA-Z]+')


</t>
<t tx="ekr.20181029161420.67">def parse_token(string, pos, header_name):
    """
    Parse a token from ``string`` at the given position.

    Return the token value and the new position.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    match = _token_re.match(string, pos)
    if match is None:
        raise InvalidHeaderFormat(
            header_name, "expected token", string=string, pos=pos)
    return match.group(), match.end()


_quoted_string_re = re.compile(
    r'"(?:[\x09\x20-\x21\x23-\x5b\x5d-\x7e]|\\[\x09\x20-\x7e\x80-\xff])*"')


_unquote_re = re.compile(r'\\([\x09\x20-\x7e\x80-\xff])')


</t>
<t tx="ekr.20181029161420.68">def parse_quoted_string(string, pos, header_name):
    """
    Parse a quoted string from ``string`` at the given position.

    Return the unquoted value and the new position.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    match = _quoted_string_re.match(string, pos)
    if match is None:
        raise InvalidHeaderFormat(
            header_name, "expected quoted string", string=string, pos=pos)
    return _unquote_re.sub(r'\1', match.group()[1:-1]), match.end()


</t>
<t tx="ekr.20181029161420.69">def parse_list(parse_item, string, pos, header_name):
    """
    Parse a comma-separated list from ``string`` at the given position.

    This is appropriate for parsing values with the following grammar:

        1#item

    ``parse_item`` parses one item.

    ``string`` is assumed not to start or end with whitespace.

    (This function is designed for parsing an entire header value and
    :func:`~websockets.http.read_headers` strips whitespace from values.)

    Return a list of items.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    # Per https://tools.ietf.org/html/rfc7230#section-7, "a recipient MUST
    # parse and ignore a reasonable number of empty list elements"; hence
    # while loops that remove extra delimiters.

    # Remove extra delimiters before the first item.
    while peek_ahead(string, pos) == ',':
        pos = parse_OWS(string, pos + 1)

    items = []
    while True:
        # Loop invariant: a item starts at pos in string.
        item, pos = parse_item(string, pos, header_name)
        items.append(item)
        pos = parse_OWS(string, pos)

        # We may have reached the end of the string.
        if pos == len(string):
            break

        # There must be a delimiter after each element except the last one.
        if peek_ahead(string, pos) == ',':
            pos = parse_OWS(string, pos + 1)
        else:
            raise InvalidHeaderFormat(
                header_name, "expected comma", string=string, pos=pos)

        # Remove extra delimiters before the next item.
        while peek_ahead(string, pos) == ',':
            pos = parse_OWS(string, pos + 1)

        # We may have reached the end of the string.
        if pos == len(string):
            break

    # Since we only advance in the string by one character with peek_ahead()
    # or with the end position of a regex match, we can't overshoot the end.
    assert pos == len(string)

    return items


</t>
<t tx="ekr.20181029161420.7">@asyncio.coroutine
def read_http_response(self):
    """
    Read status line and headers from the HTTP response.

    Raise :exc:`~websockets.exceptions.InvalidMessage` if the HTTP message
    is malformed or isn't an HTTP/1.1 GET request.

    Don't attempt to read the response body because WebSocket handshake
    responses don't have one. If the response contains a body, it may be
    read from ``self.reader`` after this coroutine returns.

    """
    try:
        status_code, headers = yield from read_response(self.reader)
    except ValueError as exc:
        raise InvalidMessage("Malformed HTTP message") from exc

    self.response_headers = headers

    return status_code, self.response_headers

</t>
<t tx="ekr.20181029161420.70">def parse_connection(string):
    """
    Parse a ``Connection`` header.

    Return a list of connection options.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    return parse_list(parse_token, string, 0, 'Connection')


_protocol_re = re.compile(
    r'[-!#$%&amp;\'*+.^_`|~0-9a-zA-Z]+(?:/[-!#$%&amp;\'*+.^_`|~0-9a-zA-Z]+)?')


</t>
<t tx="ekr.20181029161420.71">def parse_protocol(string, pos, header_name):
    """
    Parse a protocol from ``string`` at the given position.

    Return the protocol value and the new position.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    match = _protocol_re.match(string, pos)
    if match is None:
        raise InvalidHeaderFormat(
            header_name, "expected protocol", string=string, pos=pos)
    return match.group(), match.end()


</t>
<t tx="ekr.20181029161420.72">def parse_upgrade(string):
    """
    Parse an ``Upgrade`` header.

    Return a list of connection options.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    return parse_list(parse_protocol, string, 0, 'Upgrade')


</t>
<t tx="ekr.20181029161420.73">def parse_extension_param(string, pos, header_name):
    """
    Parse a single extension parameter from ``string`` at the given position.

    Return a ``(name, value)`` pair and the new position.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    # Extract parameter name.
    name, pos = parse_token(string, pos, header_name)
    pos = parse_OWS(string, pos)
    # Extract parameter string, if there is one.
    if peek_ahead(string, pos) == '=':
        pos = parse_OWS(string, pos + 1)
        if peek_ahead(string, pos) == '"':
            pos_before = pos    # for proper error reporting below
            value, pos = parse_quoted_string(string, pos, header_name)
            # https://tools.ietf.org/html/rfc6455#section-9.1 says: the value
            # after quoted-string unescaping MUST conform to the 'token' ABNF.
            if _token_re.fullmatch(value) is None:
                raise InvalidHeaderFormat(
                    header_name, "invalid quoted string content",
                    string=string, pos=pos_before)
        else:
            value, pos = parse_token(string, pos, header_name)
        pos = parse_OWS(string, pos)
    else:
        value = None

    return (name, value), pos


</t>
<t tx="ekr.20181029161420.74">def parse_extension(string, pos, header_name):
    """
    Parse an extension definition from ``string`` at the given position.

    Return an ``(extension name, parameters)`` pair, where ``parameters`` is a
    list of ``(name, value)`` pairs, and the new position.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    # Extract extension name.
    name, pos = parse_token(string, pos, header_name)
    pos = parse_OWS(string, pos)
    # Extract all parameters.
    parameters = []
    while peek_ahead(string, pos) == ';':
        pos = parse_OWS(string, pos + 1)
        parameter, pos = parse_extension_param(string, pos, header_name)
        parameters.append(parameter)
    return (name, parameters), pos


</t>
<t tx="ekr.20181029161420.75">def parse_extension_list(string):
    """
    Parse a ``Sec-WebSocket-Extensions`` header.

    Return a value with the following format::

        [
            (
                'extension name',
                [
                    ('parameter name', 'parameter value'),
                    ....
                ]
            ),
            ...
        ]

    Parameter values are ``None`` when no value is provided.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    return parse_list(parse_extension, string, 0, 'Sec-WebSocket-Extensions')


</t>
<t tx="ekr.20181029161420.76">def build_extension(name, parameters):
    """
    Build an extension definition.

    This is the reverse of :func:`parse_extension`.

    """
    return '; '.join([name] + [
        # Quoted strings aren't necessary because values are always tokens.
        name if value is None else '{}={}'.format(name, value)
        for name, value in parameters
    ])


</t>
<t tx="ekr.20181029161420.77">def build_extension_list(extensions):
    """
    Unparse a ``Sec-WebSocket-Extensions`` header.

    This is the reverse of :func:`parse_extension_list`.

    """
    return ', '.join(
        build_extension(name, parameters)
        for name, parameters in extensions
    )


</t>
<t tx="ekr.20181029161420.78">def parse_subprotocol_list(string):
    """
    Parse a ``Sec-WebSocket-Protocol`` header.

    Raise :exc:`~websockets.exceptions.InvalidHeaderFormat` on invalid inputs.

    """
    return parse_list(parse_token, string, 0, 'Sec-WebSocket-Protocol')


</t>
<t tx="ekr.20181029161420.79">def build_subprotocol_list(protocols):
    """
    Unparse a ``Sec-WebSocket-Protocol`` header.

    This is the reverse of :func:`parse_subprotocol_list`.

    """
    return ', '.join(protocols)


</t>
<t tx="ekr.20181029161420.8">@staticmethod
def process_extensions(headers, available_extensions):
    """
    Handle the Sec-WebSocket-Extensions HTTP response header.

    Check that each extension is supported, as well as its parameters.

    Return the list of accepted extensions.

    Raise :exc:`~websockets.exceptions.InvalidHandshake` to abort the
    connection.

    :rfc:`6455` leaves the rules up to the specification of each
    :extension.

    To provide this level of flexibility, for each extension accepted by
    the server, we check for a match with each extension available in the
    client configuration. If no match is found, an exception is raised.

    If several variants of the same extension are accepted by the server,
    it may be configured severel times, which won't make sense in general.
    Extensions must implement their own requirements. For this purpose,
    the list of previously accepted extensions is provided.

    Other requirements, for example related to mandatory extensions or the
    order of extensions, may be implemented by overriding this method.

    """
    accepted_extensions = []

    header_values = headers.get_all('Sec-WebSocket-Extensions')

    if header_values:

        if available_extensions is None:
            raise InvalidHandshake("No extensions supported")

        parsed_header_values = sum([
            parse_extension_list(header_value)
            for header_value in header_values
        ], [])

        for name, response_params in parsed_header_values:

            for extension_factory in available_extensions:

                # Skip non-matching extensions based on their name.
                if extension_factory.name != name:
                    continue

                # Skip non-matching extensions based on their params.
                try:
                    extension = extension_factory.process_response_params(
                        response_params, accepted_extensions)
                except NegotiationError:
                    continue

                # Add matching extension to the final list.
                accepted_extensions.append(extension)

                # Break out of the loop once we have a match.
                break

            # If we didn't break from the loop, no extension in our list
            # matched what the server sent. Fail the connection.
            else:
                raise NegotiationError(
                    "Unsupported extension: name = {}, params = {}".format(
                        name, response_params))

    return accepted_extensions

</t>
<t tx="ekr.20181029161420.80">def build_basic_auth(username, password):
    """
    Build an Authorization header for HTTP Basic Auth.

    """
    # https://tools.ietf.org/html/rfc7617#section-2
    assert ':' not in username
    user_pass = '{}:{}'.format(username, password)
    basic_credentials = base64.b64encode(user_pass.encode()).decode()
    return 'Basic ' + basic_credentials
</t>
<t tx="ekr.20181029161420.81">@path C:/Anaconda3/Lib/site-packages/websockets/
"""
The :mod:`websockets.http` module provides basic HTTP parsing and
serialization. It is merely adequate for WebSocket handshake messages.

Its functions cannot be imported from :mod:`websockets`. They must be imported
from :mod:`websockets.http`.

"""

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20181029161420.82">import asyncio
import collections.abc
import re
import sys

from .version import version as websockets_version


__all__ = [
    'Headers', 'MultipleValuesError',
    'read_request', 'read_response',
    'USER_AGENT',
]

MAX_HEADERS = 256
MAX_LINE = 4096

USER_AGENT = ' '.join((
    'Python/{}'.format(sys.version[:3]),
    'websockets/{}'.format(websockets_version),
))


# See https://tools.ietf.org/html/rfc7230#appendix-B.

# Regex for validating header names.

_token_re = re.compile(rb'[-!#$%&amp;\'*+.^_`|~0-9a-zA-Z]+')

# Regex for validating header values.

# We don't attempt to support obsolete line folding.

# Include HTAB (\x09), SP (\x20), VCHAR (\x21-\x7e), obs-text (\x80-\xff).

# The ABNF is complicated because it attempts to express that optional
# whitespace is ignored. We strip whitespace and don't revalidate that.

# See also https://www.rfc-editor.org/errata_search.php?rfc=7230&amp;eid=4189

_value_re = re.compile(rb'[\x09\x20-\x7e\x80-\xff]*')


</t>
<t tx="ekr.20181029161420.83">@asyncio.coroutine
def read_request(stream):
    """
    Read an HTTP/1.1 GET request from ``stream``.

    ``stream`` is an :class:`~asyncio.StreamReader`.

    Return ``(path, headers)`` where ``path`` is a :class:`str` and
    ``headers`` is a :class:`Headers` instance.

    ``path`` isn't URL-decoded or validated in any way.

    Non-ASCII characters are represented with surrogate escapes.

    Raise an exception if the request isn't well formatted.

    Don't attempt to read the request body because WebSocket handshake
    requests don't have one. If the request contains a body, it may be
    read from ``stream`` after this coroutine returns.

    """
    # https://tools.ietf.org/html/rfc7230#section-3.1.1

    # Parsing is simple because fixed values are expected for method and
    # version and because path isn't checked. Since WebSocket software tends
    # to implement HTTP/1.1 strictly, there's little need for lenient parsing.

    # Given the implementation of read_line(), request_line ends with CRLF.
    request_line = yield from read_line(stream)

    # This may raise "ValueError: not enough values to unpack"
    method, path, version = request_line[:-2].split(b' ', 2)

    if method != b'GET':
        raise ValueError("Unsupported HTTP method: %r" % method)
    if version != b'HTTP/1.1':
        raise ValueError("Unsupported HTTP version: %r" % version)

    path = path.decode('ascii', 'surrogateescape')

    headers = yield from read_headers(stream)

    return path, headers


</t>
<t tx="ekr.20181029161420.84">@asyncio.coroutine
def read_response(stream):
    """
    Read an HTTP/1.1 response from ``stream``.

    ``stream`` is an :class:`~asyncio.StreamReader`.

    Return ``(status_code, headers)`` where ``status_code`` is a :class:`int`
    and ``headers`` is a :class:`Headers` instance.

    Non-ASCII characters are represented with surrogate escapes.

    Raise an exception if the response isn't well formatted.

    Don't attempt to read the response body, because WebSocket handshake
    responses don't have one. If the response contains a body, it may be
    read from ``stream`` after this coroutine returns.

    """
    # https://tools.ietf.org/html/rfc7230#section-3.1.2

    # As in read_request, parsing is simple because a fixed value is expected
    # for version, status_code is a 3-digit number, and reason can be ignored.

    # Given the implementation of read_line(), status_line ends with CRLF.
    status_line = yield from read_line(stream)

    # This may raise "ValueError: not enough values to unpack"
    version, status_code, reason = status_line[:-2].split(b' ', 2)

    if version != b'HTTP/1.1':
        raise ValueError("Unsupported HTTP version: %r" % version)
    # This may raise "ValueError: invalid literal for int() with base 10"
    status_code = int(status_code)
    if not 100 &lt;= status_code &lt; 1000:
        raise ValueError("Unsupported HTTP status code: %d" % status_code)
    if not _value_re.fullmatch(reason):
        raise ValueError("Invalid HTTP reason phrase: %r" % reason)

    headers = yield from read_headers(stream)

    return status_code, headers


</t>
<t tx="ekr.20181029161420.85">@asyncio.coroutine
def read_headers(stream):
    """
    Read HTTP headers from ``stream``.

    ``stream`` is an :class:`~asyncio.StreamReader`.

    Return a :class:`Headers` instance

    Non-ASCII characters are represented with surrogate escapes.

    """
    # https://tools.ietf.org/html/rfc7230#section-3.2

    # We don't attempt to support obsolete line folding.

    headers = Headers()
    for _ in range(MAX_HEADERS + 1):
        line = yield from read_line(stream)
        if line == b'\r\n':
            break

        # This may raise "ValueError: not enough values to unpack"
        name, value = line[:-2].split(b':', 1)
        if not _token_re.fullmatch(name):
            raise ValueError("Invalid HTTP header name: %r" % name)
        value = value.strip(b' \t')
        if not _value_re.fullmatch(value):
            raise ValueError("Invalid HTTP header value: %r" % value)

        name = name.decode('ascii')     # guaranteed to be ASCII at this point
        value = value.decode('ascii', 'surrogateescape')
        headers[name] = value

    else:
        raise ValueError("Too many HTTP headers")

    return headers


</t>
<t tx="ekr.20181029161420.86">@asyncio.coroutine
def read_line(stream):
    """
    Read a single line from ``stream``.

    ``stream`` is an :class:`~asyncio.StreamReader`.

    """
    # Security: this is bounded by the StreamReader's limit (default = 32kB).
    line = yield from stream.readline()
    # Security: this guarantees header values are small (hardcoded = 4kB)
    if len(line) &gt; MAX_LINE:
        raise ValueError("Line too long")
    # Not mandatory but safe - https://tools.ietf.org/html/rfc7230#section-3.5
    if not line.endswith(b'\r\n'):
        raise ValueError("Line without CRLF")
    return line


</t>
<t tx="ekr.20181029161420.87">class MultipleValuesError(LookupError):
    """
    Exception raised when :class:`Headers` has more than one value for a key.

    """

    @others
</t>
<t tx="ekr.20181029161420.88">def __str__(self):
    # Implement the same logic as KeyError_str in Objects/exceptions.c.
    if len(self.args) == 1:
        return repr(self.args[0])
    return super().__str__()


</t>
<t tx="ekr.20181029161420.89">class Headers(collections.abc.MutableMapping):
    """
    Data structure for working with HTTP headers efficiently.

    A :class:`list` of ``(name, values)`` is inefficient for lookups.

    A :class:`dict` doesn't suffice because header names are case-insensitive
    and multiple occurrences of headers with the same name are possible.

    :class:`Headers` stores HTTP headers in a hybrid data structure to provide
    efficient insertions and lookups while preserving the original data.

    In order to account for multiple values with minimal hassle,
    :class:`Headers` follows this logic:

    - When getting a header with ``headers[name]``:
        - if there's no value, :exc:`KeyError` is raised;
        - if there's exactly one value, it's returned;
        - if there's more than one value, :exc:`MultipleValuesError` is raised.

    - When setting a header with ``headers[name] = value``, the value is
      appended to the list of values for that header.

    - When deleting a header with ``del headers[name]``, all values for that
      header are removed (this is slow).

    Other methods for manipulating headers are consistent with this logic.

    As long as no header occurs multiple times, :class:`Headers` behaves like
    :class:`dict`, except keys are lower-cased to provide case-insensitivity.

    :meth:`get_all()` returns a list of all values for a header and
    :meth:`raw_items()` returns an iterator of ``(name, values)`` pairs,
    similar to :meth:`http.client.HTTPMessage`.

    """

    __slots__ = ['_dict', '_list']

    @others
</t>
<t tx="ekr.20181029161420.9">@staticmethod
def process_subprotocol(headers, available_subprotocols):
    """
    Handle the Sec-WebSocket-Protocol HTTP response header.

    Check that it contains exactly one supported subprotocol.

    Return the selected subprotocol.

    """
    subprotocol = None

    header_values = headers.get_all('Sec-WebSocket-Protocol')

    if header_values:

        if available_subprotocols is None:
            raise InvalidHandshake("No subprotocols supported")

        parsed_header_values = sum([
            parse_subprotocol_list(header_value)
            for header_value in header_values
        ], [])

        if len(parsed_header_values) &gt; 1:
            raise InvalidHandshake(
                "Multiple subprotocols: {}".format(
                    ', '.join(parsed_header_values)))

        subprotocol = parsed_header_values[0]

        if subprotocol not in available_subprotocols:
            raise NegotiationError(
                "Unsupported subprotocol: {}".format(subprotocol))

    return subprotocol

</t>
<t tx="ekr.20181029161420.90">def __init__(self, *args, **kwargs):
    self._dict = {}
    self._list = []
    # MutableMapping.update calls __setitem__ for each (name, value) pair.
    self.update(*args, **kwargs)

</t>
<t tx="ekr.20181029161420.91">def __str__(self):
    return ''.join(
        '{}: {}\r\n'.format(key, value)
        for key, value in self._list
    ) + '\r\n'

</t>
<t tx="ekr.20181029161420.92">def __repr__(self):
    return '{}({})'.format(self.__class__.__name__, repr(self._list))

</t>
<t tx="ekr.20181029161420.93">def copy(self):
    copy = self.__class__()
    copy._dict = self._dict.copy()
    copy._list = self._list.copy()
    return copy

# Collection methods

</t>
<t tx="ekr.20181029161420.94">def __contains__(self, key):
    return key.lower() in self._dict

</t>
<t tx="ekr.20181029161420.95">def __iter__(self):
    return iter(self._dict)

</t>
<t tx="ekr.20181029161420.96">def __len__(self):
    return len(self._dict)

# MutableMapping methods

</t>
<t tx="ekr.20181029161420.97">def __getitem__(self, key):
    value = self._dict[key.lower()]
    if len(value) == 1:
        return value[0]
    else:
        raise MultipleValuesError(key)

</t>
<t tx="ekr.20181029161420.98">def __setitem__(self, key, value):
    self._dict.setdefault(key.lower(), []).append(value)
    self._list.append((key, value))

</t>
<t tx="ekr.20181029161420.99">def __delitem__(self, key):
    key_lower = key.lower()
    self._dict.__delitem__(key_lower)
    # This is inefficent. Fortunately deleting HTTP headers is uncommon.
    self._list = [(k, v) for k, v in self._list if k.lower() != key_lower]

</t>
</tnodes>
</leo_file>
