<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20220312061835.1"><vh>python39/Lib/site-packages/pylint</vh></v>
<v t="ekr.20220312061835.2"><vh>@@clean constants.py</vh>
<v t="ekr.20220312061835.3"><vh>class WarningScope</vh></v>
</v>
<v t="ekr.20220312061835.4"><vh>@@clean epylint.py</vh>
<v t="ekr.20220312061835.5"><vh>_get_env</vh></v>
<v t="ekr.20220312061835.6"><vh>lint</vh></v>
<v t="ekr.20220312061835.7"><vh>py_run</vh></v>
<v t="ekr.20220312061835.8"><vh>Run</vh></v>
</v>
<v t="ekr.20220312061835.9"><vh>@@clean exceptions.py</vh>
<v t="ekr.20220312061835.10"><vh>class InvalidMessageError</vh></v>
<v t="ekr.20220312061835.11"><vh>class UnknownMessageError</vh></v>
<v t="ekr.20220312061835.12"><vh>class EmptyReportError</vh></v>
<v t="ekr.20220312061835.13"><vh>class InvalidReporterError</vh></v>
<v t="ekr.20220312061835.14"><vh>class InvalidArgsError</vh></v>
<v t="ekr.20220312061835.15"><vh>class NoLineSuppliedError</vh></v>
</v>
<v t="ekr.20220312061835.16"><vh>@@clean graph.py</vh>
<v t="ekr.20220312061835.17"><vh>target_info_from_filename</vh></v>
<v t="ekr.20220312061835.18"><vh>class DotBackend</vh>
<v t="ekr.20220312061835.19"><vh>DotBackend.__init__</vh></v>
<v t="ekr.20220312061835.20"><vh>DotBackend.get_source</vh></v>
<v t="ekr.20220312061835.21"><vh>DotBackend....some declarations</vh></v>
<v t="ekr.20220312061835.22"><vh>DotBackend.generate</vh></v>
<v t="ekr.20220312061835.23"><vh>DotBackend.emit</vh></v>
<v t="ekr.20220312061835.24"><vh>DotBackend.emit_edge</vh></v>
<v t="ekr.20220312061835.25"><vh>DotBackend.emit_node</vh></v>
</v>
<v t="ekr.20220312061835.26"><vh>normalize_node_id</vh></v>
<v t="ekr.20220312061835.27"><vh>get_cycles</vh></v>
<v t="ekr.20220312061835.28"><vh>_get_cycles</vh></v>
</v>
<v t="ekr.20220312061835.29"><vh>@@clean interfaces.py</vh>
<v t="ekr.20220312061835.30"><vh>class Interface</vh></v>
<v t="ekr.20220312061835.31"><vh>implements</vh></v>
<v t="ekr.20220312061835.32"><vh>class IChecker</vh>
<v t="ekr.20220312061835.33"><vh>IChecker.open</vh></v>
<v t="ekr.20220312061835.34"><vh>IChecker.close</vh></v>
</v>
<v t="ekr.20220312061835.35"><vh>class IRawChecker</vh>
<v t="ekr.20220312061835.36"><vh>IRawChecker.process_module</vh></v>
</v>
<v t="ekr.20220312061835.37"><vh>class ITokenChecker</vh>
<v t="ekr.20220312061835.38"><vh>ITokenChecker.process_tokens</vh></v>
</v>
<v t="ekr.20220312061835.39"><vh>class IAstroidChecker</vh></v>
<v t="ekr.20220312061835.40"><vh>class IReporter</vh>
<v t="ekr.20220312061835.41"><vh>IReporter.handle_message</vh></v>
<v t="ekr.20220312061835.42"><vh>IReporter.display_reports</vh></v>
</v>
</v>
<v t="ekr.20220312061835.43"><vh>@@clean typing.py</vh>
<v t="ekr.20220312061835.44"><vh>class FileItem</vh></v>
<v t="ekr.20220312061835.45"><vh>class ModuleDescriptionDict</vh></v>
<v t="ekr.20220312061835.46"><vh>class ErrorDescriptionDict</vh></v>
</v>
<v t="ekr.20220312061835.47"><vh>@@clean __init__.py</vh>
<v t="ekr.20220312061835.48"><vh>run_pylint</vh></v>
<v t="ekr.20220312061835.49"><vh>run_epylint</vh></v>
<v t="ekr.20220312061835.50"><vh>run_pyreverse</vh></v>
<v t="ekr.20220312061835.51"><vh>run_symilar</vh></v>
<v t="ekr.20220312061835.52"><vh>modify_sys_path</vh></v>
</v>
<v t="ekr.20220312061835.53"><vh>@@clean __main__.py</vh></v>
<v t="ekr.20220312061835.54"><vh>@@clean __pkginfo__.py</vh>
<v t="ekr.20220312061835.55"><vh>get_numversion_from_version</vh></v>
</v>
<v t="ekr.20220312061835.56"><vh>@path checkers</vh>
<v t="ekr.20220312061835.57"><vh>@@clean async.py</vh>
<v t="ekr.20220312061835.58"><vh>class AsyncChecker</vh>
<v t="ekr.20220312061835.59"><vh>AsyncChecker.open</vh></v>
<v t="ekr.20220312061835.60"><vh>AsyncChecker.visit_asyncfunctiondef</vh></v>
<v t="ekr.20220312061835.61"><vh>AsyncChecker.visit_asyncwith</vh></v>
</v>
<v t="ekr.20220312061835.62"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.63"><vh>@@clean base.py</vh>
<v t="ekr.20220312061835.64"><vh>class NamingStyle</vh>
<v t="ekr.20220312061835.65"><vh>NamingStyle.get_regex</vh></v>
</v>
<v t="ekr.20220312061835.66"><vh>class SnakeCaseStyle</vh></v>
<v t="ekr.20220312061835.67"><vh>class CamelCaseStyle</vh></v>
<v t="ekr.20220312061835.68"><vh>class PascalCaseStyle</vh></v>
<v t="ekr.20220312061835.69"><vh>class UpperCaseStyle</vh></v>
<v t="ekr.20220312061835.70"><vh>class AnyStyle</vh></v>
<v t="ekr.20220312061835.71"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.72"><vh>_redefines_import</vh></v>
<v t="ekr.20220312061835.73"><vh>in_loop</vh></v>
<v t="ekr.20220312061835.74"><vh>in_nested_list</vh></v>
<v t="ekr.20220312061835.75"><vh>_get_break_loop_node</vh></v>
<v t="ekr.20220312061835.76"><vh>_loop_exits_early</vh></v>
<v t="ekr.20220312061835.77"><vh>_is_multi_naming_match</vh></v>
<v t="ekr.20220312061835.78"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.79"><vh>_get_properties</vh></v>
<v t="ekr.20220312061835.80"><vh>_determine_function_name_type</vh></v>
<v t="ekr.20220312061835.81"><vh>_has_abstract_methods</vh></v>
<v t="ekr.20220312061835.82"><vh>report_by_type_stats</vh></v>
<v t="ekr.20220312061835.83"><vh>redefined_by_decorator</vh></v>
<v t="ekr.20220312061835.84"><vh>class _BasicChecker</vh></v>
<v t="ekr.20220312061835.85"><vh>class BasicErrorChecker</vh>
<v t="ekr.20220312061835.86"><vh>BasicErrorChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.87"><vh>BasicErrorChecker._too_many_starred_for_tuple</vh></v>
<v t="ekr.20220312061835.88"><vh>BasicErrorChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.89"><vh>BasicErrorChecker.visit_starred</vh></v>
<v t="ekr.20220312061835.90"><vh>BasicErrorChecker....some declarations</vh></v>
<v t="ekr.20220312061835.91"><vh>BasicErrorChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.92"><vh>BasicErrorChecker....some declarations</vh></v>
<v t="ekr.20220312061835.93"><vh>BasicErrorChecker._check_name_used_prior_global</vh></v>
<v t="ekr.20220312061835.94"><vh>BasicErrorChecker._check_nonlocal_and_global</vh></v>
<v t="ekr.20220312061835.95"><vh>BasicErrorChecker.visit_return</vh></v>
<v t="ekr.20220312061835.96"><vh>BasicErrorChecker.visit_yield</vh></v>
<v t="ekr.20220312061835.97"><vh>BasicErrorChecker.visit_yieldfrom</vh></v>
<v t="ekr.20220312061835.98"><vh>BasicErrorChecker.visit_continue</vh></v>
<v t="ekr.20220312061835.99"><vh>BasicErrorChecker.visit_break</vh></v>
<v t="ekr.20220312061835.100"><vh>BasicErrorChecker.visit_for</vh></v>
<v t="ekr.20220312061835.101"><vh>BasicErrorChecker.visit_while</vh></v>
<v t="ekr.20220312061835.102"><vh>BasicErrorChecker.visit_unaryop</vh></v>
<v t="ekr.20220312061835.103"><vh>BasicErrorChecker._check_nonlocal_without_binding</vh></v>
<v t="ekr.20220312061835.104"><vh>BasicErrorChecker.visit_nonlocal</vh></v>
<v t="ekr.20220312061835.105"><vh>BasicErrorChecker.visit_call</vh></v>
<v t="ekr.20220312061835.106"><vh>BasicErrorChecker._check_inferred_class_is_abstract</vh></v>
<v t="ekr.20220312061835.107"><vh>BasicErrorChecker._check_yield_outside_func</vh></v>
<v t="ekr.20220312061835.108"><vh>BasicErrorChecker._check_else_on_loop</vh></v>
<v t="ekr.20220312061835.109"><vh>BasicErrorChecker._check_in_loop</vh></v>
<v t="ekr.20220312061835.110"><vh>BasicErrorChecker._check_redefinition</vh></v>
</v>
<v t="ekr.20220312061835.111"><vh>class BasicChecker</vh>
<v t="ekr.20220312061835.112"><vh>BasicChecker.__init__</vh></v>
<v t="ekr.20220312061835.113"><vh>BasicChecker.open</vh></v>
<v t="ekr.20220312061835.114"><vh>BasicChecker.visit_if</vh></v>
<v t="ekr.20220312061835.115"><vh>BasicChecker.visit_ifexp</vh></v>
<v t="ekr.20220312061835.116"><vh>BasicChecker.visit_comprehension</vh></v>
<v t="ekr.20220312061835.117"><vh>BasicChecker._check_using_constant_test</vh></v>
<v t="ekr.20220312061835.118"><vh>BasicChecker.visit_module</vh></v>
<v t="ekr.20220312061835.119"><vh>BasicChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.120"><vh>BasicChecker....some declarations</vh></v>
<v t="ekr.20220312061835.121"><vh>BasicChecker.visit_expr</vh></v>
<v t="ekr.20220312061835.122"><vh>BasicChecker._filter_vararg</vh></v>
<v t="ekr.20220312061835.123"><vh>BasicChecker._has_variadic_argument</vh></v>
<v t="ekr.20220312061835.124"><vh>BasicChecker.visit_lambda</vh></v>
<v t="ekr.20220312061835.125"><vh>BasicChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.126"><vh>BasicChecker....some declarations</vh></v>
<v t="ekr.20220312061835.127"><vh>BasicChecker._check_dangerous_default</vh></v>
<v t="ekr.20220312061835.128"><vh>BasicChecker.visit_return</vh></v>
<v t="ekr.20220312061835.129"><vh>BasicChecker.visit_continue</vh></v>
<v t="ekr.20220312061835.130"><vh>BasicChecker.visit_break</vh></v>
<v t="ekr.20220312061835.131"><vh>BasicChecker.visit_raise</vh></v>
<v t="ekr.20220312061835.132"><vh>BasicChecker._check_misplaced_format_function</vh></v>
<v t="ekr.20220312061835.133"><vh>BasicChecker....some declarations</vh></v>
<v t="ekr.20220312061835.134"><vh>BasicChecker.visit_call</vh></v>
<v t="ekr.20220312061835.135"><vh>BasicChecker.visit_assert</vh></v>
<v t="ekr.20220312061835.136"><vh>BasicChecker.visit_dict</vh></v>
<v t="ekr.20220312061835.137"><vh>BasicChecker.visit_tryfinally</vh></v>
<v t="ekr.20220312061835.138"><vh>BasicChecker.leave_tryfinally</vh></v>
<v t="ekr.20220312061835.139"><vh>BasicChecker._check_unreachable</vh></v>
<v t="ekr.20220312061835.140"><vh>BasicChecker._check_not_in_finally</vh></v>
<v t="ekr.20220312061835.141"><vh>BasicChecker._check_reversed</vh></v>
<v t="ekr.20220312061835.142"><vh>BasicChecker.visit_with</vh></v>
<v t="ekr.20220312061835.143"><vh>BasicChecker._check_self_assigning_variable</vh></v>
<v t="ekr.20220312061835.144"><vh>BasicChecker._check_redeclared_assign_name</vh></v>
<v t="ekr.20220312061835.145"><vh>BasicChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.146"><vh>BasicChecker.visit_for</vh></v>
</v>
<v t="ekr.20220312061835.147"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.148"><vh>_create_naming_options</vh></v>
<v t="ekr.20220312061835.149"><vh>class NameChecker</vh>
<v t="ekr.20220312061835.150"><vh>NameChecker.__init__</vh></v>
<v t="ekr.20220312061835.151"><vh>NameChecker.open</vh></v>
<v t="ekr.20220312061835.152"><vh>NameChecker._create_naming_rules</vh></v>
<v t="ekr.20220312061835.153"><vh>NameChecker.visit_module</vh></v>
<v t="ekr.20220312061835.154"><vh>NameChecker.leave_module</vh></v>
<v t="ekr.20220312061835.155"><vh>NameChecker....some declarations</vh></v>
<v t="ekr.20220312061835.156"><vh>NameChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.157"><vh>NameChecker....some declarations</vh></v>
<v t="ekr.20220312061835.158"><vh>NameChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.159"><vh>NameChecker....some declarations</vh></v>
<v t="ekr.20220312061835.160"><vh>NameChecker.visit_global</vh></v>
<v t="ekr.20220312061835.161"><vh>NameChecker....some declarations</vh></v>
<v t="ekr.20220312061835.162"><vh>NameChecker.visit_assignname</vh></v>
<v t="ekr.20220312061835.163"><vh>NameChecker._recursive_check_names</vh></v>
<v t="ekr.20220312061835.164"><vh>NameChecker._find_name_group</vh></v>
<v t="ekr.20220312061835.165"><vh>NameChecker._raise_name_warning</vh></v>
<v t="ekr.20220312061835.166"><vh>NameChecker._name_allowed_by_regex</vh></v>
<v t="ekr.20220312061835.167"><vh>NameChecker._name_disallowed_by_regex</vh></v>
<v t="ekr.20220312061835.168"><vh>NameChecker._check_name</vh></v>
<v t="ekr.20220312061835.169"><vh>NameChecker._check_assign_to_new_keyword_violation</vh></v>
<v t="ekr.20220312061835.170"><vh>NameChecker._name_became_keyword_in_version</vh></v>
</v>
<v t="ekr.20220312061835.171"><vh>class DocStringChecker</vh>
<v t="ekr.20220312061835.172"><vh>DocStringChecker.open</vh></v>
<v t="ekr.20220312061835.173"><vh>DocStringChecker.visit_module</vh></v>
<v t="ekr.20220312061835.174"><vh>DocStringChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.175"><vh>DocStringChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.176"><vh>DocStringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.177"><vh>DocStringChecker._check_docstring</vh></v>
</v>
<v t="ekr.20220312061835.178"><vh>class PassChecker</vh>
<v t="ekr.20220312061835.179"><vh>PassChecker.visit_pass</vh></v>
</v>
<v t="ekr.20220312061835.180"><vh>_is_one_arg_pos_call</vh></v>
<v t="ekr.20220312061835.181"><vh>_infer_dunder_doc_attribute</vh></v>
<v t="ekr.20220312061835.182"><vh>class ComparisonChecker</vh>
<v t="ekr.20220312061835.183"><vh>ComparisonChecker._check_singleton_comparison</vh></v>
<v t="ekr.20220312061835.184"><vh>ComparisonChecker._check_nan_comparison</vh></v>
<v t="ekr.20220312061835.185"><vh>ComparisonChecker._check_literal_comparison</vh></v>
<v t="ekr.20220312061835.186"><vh>ComparisonChecker._check_misplaced_constant</vh></v>
<v t="ekr.20220312061835.187"><vh>ComparisonChecker._check_logical_tautology</vh></v>
<v t="ekr.20220312061835.188"><vh>ComparisonChecker._check_callable_comparison</vh></v>
<v t="ekr.20220312061835.189"><vh>ComparisonChecker....some declarations</vh></v>
<v t="ekr.20220312061835.190"><vh>ComparisonChecker.visit_compare</vh></v>
<v t="ekr.20220312061835.191"><vh>ComparisonChecker._check_unidiomatic_typecheck</vh></v>
<v t="ekr.20220312061835.192"><vh>ComparisonChecker._check_type_x_is_y</vh></v>
</v>
<v t="ekr.20220312061835.193"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.194"><vh>@@clean base_checker.py</vh>
<v t="ekr.20220312061835.195"><vh>class BaseChecker</vh>
<v t="ekr.20220312061835.196"><vh>BaseChecker.__init__</vh></v>
<v t="ekr.20220312061835.197"><vh>BaseChecker.__gt__</vh></v>
<v t="ekr.20220312061835.198"><vh>BaseChecker.__repr__</vh></v>
<v t="ekr.20220312061835.199"><vh>BaseChecker.__str__</vh></v>
<v t="ekr.20220312061835.200"><vh>BaseChecker.get_full_documentation</vh></v>
<v t="ekr.20220312061835.201"><vh>BaseChecker.add_message</vh></v>
<v t="ekr.20220312061835.202"><vh>BaseChecker.check_consistency</vh></v>
<v t="ekr.20220312061835.203"><vh>BaseChecker.create_message_definition_from_tuple</vh></v>
<v t="ekr.20220312061835.204"><vh>BaseChecker.messages</vh></v>
<v t="ekr.20220312061835.205"><vh>BaseChecker....some declarations</vh></v>
<v t="ekr.20220312061835.206"><vh>BaseChecker.get_message_definition</vh></v>
<v t="ekr.20220312061835.207"><vh>BaseChecker.open</vh></v>
<v t="ekr.20220312061835.208"><vh>BaseChecker.close</vh></v>
</v>
<v t="ekr.20220312061835.209"><vh>class BaseTokenChecker</vh></v>
</v>
<v t="ekr.20220312061835.210"><vh>@@clean classes.py</vh>
<v t="ekr.20220312061835.211"><vh>_signature_from_call</vh></v>
<v t="ekr.20220312061835.212"><vh>_signature_from_arguments</vh></v>
<v t="ekr.20220312061835.213"><vh>_definition_equivalent_to_call</vh></v>
<v t="ekr.20220312061835.214"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.215"><vh>_positional_parameters</vh></v>
<v t="ekr.20220312061835.216"><vh>_get_node_type</vh></v>
<v t="ekr.20220312061835.217"><vh>_check_arg_equality</vh></v>
<v t="ekr.20220312061835.218"><vh>_has_different_parameters_default_value</vh></v>
<v t="ekr.20220312061835.219"><vh>_has_different_parameters</vh></v>
<v t="ekr.20220312061835.220"><vh>_different_parameters</vh></v>
<v t="ekr.20220312061835.221"><vh>_is_invalid_base_class</vh></v>
<v t="ekr.20220312061835.222"><vh>_has_data_descriptor</vh></v>
<v t="ekr.20220312061835.223"><vh>_called_in_methods</vh></v>
<v t="ekr.20220312061835.224"><vh>_is_attribute_property</vh></v>
<v t="ekr.20220312061835.225"><vh>_has_bare_super_call</vh></v>
<v t="ekr.20220312061835.226"><vh>_safe_infer_call_result</vh></v>
<v t="ekr.20220312061835.227"><vh>_has_same_layout_slots</vh></v>
<v t="ekr.20220312061835.228"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.229"><vh>_scope_default</vh></v>
<v t="ekr.20220312061835.230"><vh>class ScopeAccessMap</vh>
<v t="ekr.20220312061835.231"><vh>ScopeAccessMap.__init__</vh></v>
<v t="ekr.20220312061835.232"><vh>ScopeAccessMap.set_accessed</vh></v>
<v t="ekr.20220312061835.233"><vh>ScopeAccessMap.accessed</vh></v>
</v>
<v t="ekr.20220312061835.234"><vh>class ClassChecker</vh>
<v t="ekr.20220312061835.235"><vh>ClassChecker.__init__</vh></v>
<v t="ekr.20220312061835.236"><vh>ClassChecker._dummy_rgx</vh></v>
<v t="ekr.20220312061835.237"><vh>ClassChecker._ignore_mixin</vh></v>
<v t="ekr.20220312061835.238"><vh>ClassChecker....some declarations</vh></v>
<v t="ekr.20220312061835.239"><vh>ClassChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.240"><vh>ClassChecker._check_consistent_mro</vh></v>
<v t="ekr.20220312061835.241"><vh>ClassChecker._check_proper_bases</vh></v>
<v t="ekr.20220312061835.242"><vh>ClassChecker.leave_classdef</vh></v>
<v t="ekr.20220312061835.243"><vh>ClassChecker._check_unused_private_functions</vh></v>
<v t="ekr.20220312061835.244"><vh>ClassChecker._check_unused_private_variables</vh></v>
<v t="ekr.20220312061835.245"><vh>ClassChecker._check_unused_private_attributes</vh></v>
<v t="ekr.20220312061835.246"><vh>ClassChecker._check_attribute_defined_outside_init</vh></v>
<v t="ekr.20220312061835.247"><vh>ClassChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.248"><vh>ClassChecker....some declarations</vh></v>
<v t="ekr.20220312061835.249"><vh>ClassChecker._check_useless_super_delegation</vh>
<v t="ekr.20220312061835.250"><vh>ClassChecker.form_annotations</vh></v>
</v>
<v t="ekr.20220312061835.251"><vh>ClassChecker._check_property_with_parameters</vh></v>
<v t="ekr.20220312061835.252"><vh>ClassChecker._check_invalid_overridden_method</vh></v>
<v t="ekr.20220312061835.253"><vh>ClassChecker._check_slots</vh></v>
<v t="ekr.20220312061835.254"><vh>ClassChecker._check_slots_elt</vh></v>
<v t="ekr.20220312061835.255"><vh>ClassChecker.leave_functiondef</vh></v>
<v t="ekr.20220312061835.256"><vh>ClassChecker....some declarations</vh></v>
<v t="ekr.20220312061835.257"><vh>ClassChecker.visit_attribute</vh></v>
<v t="ekr.20220312061835.258"><vh>ClassChecker.visit_assignattr</vh></v>
<v t="ekr.20220312061835.259"><vh>ClassChecker._check_invalid_class_object</vh></v>
<v t="ekr.20220312061835.260"><vh>ClassChecker._check_in_slots</vh></v>
<v t="ekr.20220312061835.261"><vh>ClassChecker....some declarations</vh></v>
<v t="ekr.20220312061835.262"><vh>ClassChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.263"><vh>ClassChecker._check_classmethod_declaration</vh></v>
<v t="ekr.20220312061835.264"><vh>ClassChecker._check_protected_attribute_access</vh></v>
<v t="ekr.20220312061835.265"><vh>ClassChecker._is_called_inside_special_method</vh></v>
<v t="ekr.20220312061835.266"><vh>ClassChecker._is_type_self_call</vh></v>
<v t="ekr.20220312061835.267"><vh>ClassChecker._is_classmethod</vh></v>
<v t="ekr.20220312061835.268"><vh>ClassChecker._is_inferred_instance</vh></v>
<v t="ekr.20220312061835.269"><vh>ClassChecker._is_class_attribute</vh></v>
<v t="ekr.20220312061835.270"><vh>ClassChecker.visit_name</vh></v>
<v t="ekr.20220312061835.271"><vh>ClassChecker._check_accessed_members</vh></v>
<v t="ekr.20220312061835.272"><vh>ClassChecker._check_first_arg_for_type</vh></v>
<v t="ekr.20220312061835.273"><vh>ClassChecker._check_first_arg_config</vh></v>
<v t="ekr.20220312061835.274"><vh>ClassChecker._check_bases_classes</vh></v>
<v t="ekr.20220312061835.275"><vh>ClassChecker._check_init</vh></v>
<v t="ekr.20220312061835.276"><vh>ClassChecker._check_signature</vh></v>
<v t="ekr.20220312061835.277"><vh>ClassChecker._uses_mandatory_method_param</vh></v>
<v t="ekr.20220312061835.278"><vh>ClassChecker._is_mandatory_method_param</vh></v>
</v>
<v t="ekr.20220312061835.279"><vh>class SpecialMethodsChecker</vh>
<v t="ekr.20220312061835.280"><vh>SpecialMethodsChecker.__init__</vh></v>
<v t="ekr.20220312061835.281"><vh>SpecialMethodsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.282"><vh>SpecialMethodsChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.283"><vh>SpecialMethodsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.284"><vh>SpecialMethodsChecker._check_unexpected_method_signature</vh></v>
<v t="ekr.20220312061835.285"><vh>SpecialMethodsChecker._is_wrapped_type</vh></v>
<v t="ekr.20220312061835.286"><vh>SpecialMethodsChecker._is_int</vh></v>
<v t="ekr.20220312061835.287"><vh>SpecialMethodsChecker._is_str</vh></v>
<v t="ekr.20220312061835.288"><vh>SpecialMethodsChecker._is_bool</vh></v>
<v t="ekr.20220312061835.289"><vh>SpecialMethodsChecker._is_bytes</vh></v>
<v t="ekr.20220312061835.290"><vh>SpecialMethodsChecker._is_tuple</vh></v>
<v t="ekr.20220312061835.291"><vh>SpecialMethodsChecker._is_dict</vh></v>
<v t="ekr.20220312061835.292"><vh>SpecialMethodsChecker._is_iterator</vh></v>
<v t="ekr.20220312061835.293"><vh>SpecialMethodsChecker._check_iter</vh></v>
<v t="ekr.20220312061835.294"><vh>SpecialMethodsChecker._check_len</vh></v>
<v t="ekr.20220312061835.295"><vh>SpecialMethodsChecker._check_bool</vh></v>
<v t="ekr.20220312061835.296"><vh>SpecialMethodsChecker._check_index</vh></v>
<v t="ekr.20220312061835.297"><vh>SpecialMethodsChecker._check_repr</vh></v>
<v t="ekr.20220312061835.298"><vh>SpecialMethodsChecker._check_str</vh></v>
<v t="ekr.20220312061835.299"><vh>SpecialMethodsChecker._check_bytes</vh></v>
<v t="ekr.20220312061835.300"><vh>SpecialMethodsChecker._check_hash</vh></v>
<v t="ekr.20220312061835.301"><vh>SpecialMethodsChecker._check_length_hint</vh></v>
<v t="ekr.20220312061835.302"><vh>SpecialMethodsChecker._check_format</vh></v>
<v t="ekr.20220312061835.303"><vh>SpecialMethodsChecker._check_getnewargs</vh></v>
<v t="ekr.20220312061835.304"><vh>SpecialMethodsChecker._check_getnewargs_ex</vh></v>
</v>
<v t="ekr.20220312061835.305"><vh>_ancestors_to_call</vh></v>
<v t="ekr.20220312061835.306"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.307"><vh>@@clean deprecated.py</vh>
<v t="ekr.20220312061835.308"><vh>class DeprecatedMixin</vh>
<v t="ekr.20220312061835.309"><vh>DeprecatedMixin.visit_call</vh></v>
<v t="ekr.20220312061835.310"><vh>DeprecatedMixin....some declarations</vh></v>
<v t="ekr.20220312061835.311"><vh>DeprecatedMixin.visit_import</vh></v>
<v t="ekr.20220312061835.312"><vh>DeprecatedMixin.deprecated_decorators</vh></v>
<v t="ekr.20220312061835.313"><vh>DeprecatedMixin.visit_decorators</vh></v>
<v t="ekr.20220312061835.314"><vh>DeprecatedMixin....some declarations</vh></v>
<v t="ekr.20220312061835.315"><vh>DeprecatedMixin.visit_importfrom</vh></v>
<v t="ekr.20220312061835.316"><vh>DeprecatedMixin.deprecated_methods</vh></v>
<v t="ekr.20220312061835.317"><vh>DeprecatedMixin.deprecated_arguments</vh></v>
<v t="ekr.20220312061835.318"><vh>DeprecatedMixin.deprecated_modules</vh></v>
<v t="ekr.20220312061835.319"><vh>DeprecatedMixin.deprecated_classes</vh></v>
<v t="ekr.20220312061835.320"><vh>DeprecatedMixin.check_deprecated_module</vh></v>
<v t="ekr.20220312061835.321"><vh>DeprecatedMixin.check_deprecated_method</vh></v>
<v t="ekr.20220312061835.322"><vh>DeprecatedMixin.check_deprecated_class</vh></v>
<v t="ekr.20220312061835.323"><vh>DeprecatedMixin.check_deprecated_class_in_call</vh></v>
</v>
</v>
<v t="ekr.20220312061835.324"><vh>@@clean design_analysis.py</vh>
<v t="ekr.20220312061835.325"><vh>_is_exempt_from_public_methods</vh></v>
<v t="ekr.20220312061835.326"><vh>_count_boolean_expressions</vh></v>
<v t="ekr.20220312061835.327"><vh>_count_methods_in_class</vh></v>
<v t="ekr.20220312061835.328"><vh>_get_parents</vh></v>
<v t="ekr.20220312061835.329"><vh>class MisdesignChecker</vh>
<v t="ekr.20220312061835.330"><vh>MisdesignChecker.__init__</vh></v>
<v t="ekr.20220312061835.331"><vh>MisdesignChecker.open</vh></v>
<v t="ekr.20220312061835.332"><vh>MisdesignChecker._inc_all_stmts</vh></v>
<v t="ekr.20220312061835.333"><vh>MisdesignChecker._ignored_argument_names</vh></v>
<v t="ekr.20220312061835.334"><vh>MisdesignChecker....some declarations</vh></v>
<v t="ekr.20220312061835.335"><vh>MisdesignChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.336"><vh>MisdesignChecker.leave_classdef</vh></v>
<v t="ekr.20220312061835.337"><vh>MisdesignChecker....some declarations</vh></v>
<v t="ekr.20220312061835.338"><vh>MisdesignChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.339"><vh>MisdesignChecker....some declarations</vh></v>
<v t="ekr.20220312061835.340"><vh>MisdesignChecker.leave_functiondef</vh></v>
<v t="ekr.20220312061835.341"><vh>MisdesignChecker....some declarations</vh></v>
<v t="ekr.20220312061835.342"><vh>MisdesignChecker.visit_return</vh></v>
<v t="ekr.20220312061835.343"><vh>MisdesignChecker.visit_default</vh></v>
<v t="ekr.20220312061835.344"><vh>MisdesignChecker.visit_tryexcept</vh></v>
<v t="ekr.20220312061835.345"><vh>MisdesignChecker.visit_tryfinally</vh></v>
<v t="ekr.20220312061835.346"><vh>MisdesignChecker.visit_if</vh></v>
<v t="ekr.20220312061835.347"><vh>MisdesignChecker._check_boolean_expressions</vh></v>
<v t="ekr.20220312061835.348"><vh>MisdesignChecker.visit_while</vh></v>
<v t="ekr.20220312061835.349"><vh>MisdesignChecker....some declarations</vh></v>
<v t="ekr.20220312061835.350"><vh>MisdesignChecker._inc_branch</vh></v>
</v>
<v t="ekr.20220312061835.351"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.352"><vh>@@clean exceptions.py</vh>
<v t="ekr.20220312061835.353"><vh>_builtin_exceptions</vh></v>
<v t="ekr.20220312061835.354"><vh>_annotated_unpack_infer</vh></v>
<v t="ekr.20220312061835.355"><vh>_is_raising</vh></v>
<v t="ekr.20220312061835.356"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.357"><vh>class BaseVisitor</vh>
<v t="ekr.20220312061835.358"><vh>BaseVisitor.__init__</vh></v>
<v t="ekr.20220312061835.359"><vh>BaseVisitor.visit</vh></v>
<v t="ekr.20220312061835.360"><vh>BaseVisitor.visit_default</vh></v>
</v>
<v t="ekr.20220312061835.361"><vh>class ExceptionRaiseRefVisitor</vh>
<v t="ekr.20220312061835.362"><vh>ExceptionRaiseRefVisitor.visit_name</vh></v>
<v t="ekr.20220312061835.363"><vh>ExceptionRaiseRefVisitor.visit_call</vh></v>
</v>
<v t="ekr.20220312061835.364"><vh>class ExceptionRaiseLeafVisitor</vh>
<v t="ekr.20220312061835.365"><vh>ExceptionRaiseLeafVisitor.visit_const</vh></v>
<v t="ekr.20220312061835.366"><vh>ExceptionRaiseLeafVisitor.visit_instance</vh></v>
<v t="ekr.20220312061835.367"><vh>ExceptionRaiseLeafVisitor....some declarations</vh></v>
<v t="ekr.20220312061835.368"><vh>ExceptionRaiseLeafVisitor.visit_classdef</vh></v>
<v t="ekr.20220312061835.369"><vh>ExceptionRaiseLeafVisitor.visit_tuple</vh></v>
<v t="ekr.20220312061835.370"><vh>ExceptionRaiseLeafVisitor.visit_default</vh></v>
</v>
<v t="ekr.20220312061835.371"><vh>class ExceptionsChecker</vh>
<v t="ekr.20220312061835.372"><vh>ExceptionsChecker.open</vh></v>
<v t="ekr.20220312061835.373"><vh>ExceptionsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.374"><vh>ExceptionsChecker.visit_raise</vh></v>
<v t="ekr.20220312061835.375"><vh>ExceptionsChecker._check_misplaced_bare_raise</vh></v>
<v t="ekr.20220312061835.376"><vh>ExceptionsChecker._check_bad_exception_context</vh></v>
<v t="ekr.20220312061835.377"><vh>ExceptionsChecker._check_raise_missing_from</vh></v>
<v t="ekr.20220312061835.378"><vh>ExceptionsChecker._check_catching_non_exception</vh></v>
<v t="ekr.20220312061835.379"><vh>ExceptionsChecker._check_try_except_raise</vh></v>
<v t="ekr.20220312061835.380"><vh>ExceptionsChecker.visit_binop</vh></v>
<v t="ekr.20220312061835.381"><vh>ExceptionsChecker.visit_compare</vh></v>
<v t="ekr.20220312061835.382"><vh>ExceptionsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.383"><vh>ExceptionsChecker.visit_tryexcept</vh></v>
</v>
<v t="ekr.20220312061835.384"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.385"><vh>@@clean format.py</vh>
<v t="ekr.20220312061835.386"><vh>_last_token_on_line_is</vh></v>
<v t="ekr.20220312061835.387"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.388"><vh>class TokenWrapper</vh>
<v t="ekr.20220312061835.389"><vh>TokenWrapper.__init__</vh></v>
<v t="ekr.20220312061835.390"><vh>TokenWrapper.token</vh></v>
<v t="ekr.20220312061835.391"><vh>TokenWrapper.type</vh></v>
<v t="ekr.20220312061835.392"><vh>TokenWrapper.start_line</vh></v>
<v t="ekr.20220312061835.393"><vh>TokenWrapper.start_col</vh></v>
<v t="ekr.20220312061835.394"><vh>TokenWrapper.line</vh></v>
</v>
<v t="ekr.20220312061835.395"><vh>class FormatChecker</vh>
<v t="ekr.20220312061835.396"><vh>FormatChecker.__init__</vh></v>
<v t="ekr.20220312061835.397"><vh>FormatChecker.new_line</vh></v>
<v t="ekr.20220312061835.398"><vh>FormatChecker.process_module</vh></v>
<v t="ekr.20220312061835.399"><vh>FormatChecker._check_keyword_parentheses</vh></v>
<v t="ekr.20220312061835.400"><vh>FormatChecker._prepare_token_dispatcher</vh></v>
<v t="ekr.20220312061835.401"><vh>FormatChecker.process_tokens</vh></v>
<v t="ekr.20220312061835.402"><vh>FormatChecker._check_line_ending</vh></v>
<v t="ekr.20220312061835.403"><vh>FormatChecker.visit_default</vh></v>
<v t="ekr.20220312061835.404"><vh>FormatChecker._check_multi_statement_line</vh></v>
<v t="ekr.20220312061835.405"><vh>FormatChecker.check_line_ending</vh></v>
<v t="ekr.20220312061835.406"><vh>FormatChecker.check_line_length</vh></v>
<v t="ekr.20220312061835.407"><vh>FormatChecker.remove_pylint_option_from_lines</vh></v>
<v t="ekr.20220312061835.408"><vh>FormatChecker.is_line_length_check_activated</vh></v>
<v t="ekr.20220312061835.409"><vh>FormatChecker.specific_splitlines</vh></v>
<v t="ekr.20220312061835.410"><vh>FormatChecker.check_lines</vh></v>
<v t="ekr.20220312061835.411"><vh>FormatChecker.check_indent_level</vh></v>
</v>
<v t="ekr.20220312061835.412"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.413"><vh>@@clean imports.py</vh>
<v t="ekr.20220312061835.414"><vh>_qualified_names</vh></v>
<v t="ekr.20220312061835.415"><vh>_get_first_import</vh></v>
<v t="ekr.20220312061835.416"><vh>_ignore_import_failure</vh></v>
<v t="ekr.20220312061835.417"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.418"><vh>_make_tree_defs</vh></v>
<v t="ekr.20220312061835.419"><vh>_repr_tree_defs</vh></v>
<v t="ekr.20220312061835.420"><vh>_dependencies_graph</vh></v>
<v t="ekr.20220312061835.421"><vh>_make_graph</vh></v>
<v t="ekr.20220312061835.422"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.423"><vh>class ImportsChecker</vh>
<v t="ekr.20220312061835.424"><vh>ImportsChecker.__init__</vh></v>
<v t="ekr.20220312061835.425"><vh>ImportsChecker._compute_site_packages</vh></v>
<v t="ekr.20220312061835.426"><vh>ImportsChecker.open</vh></v>
<v t="ekr.20220312061835.427"><vh>ImportsChecker._import_graph_without_ignored_edges</vh></v>
<v t="ekr.20220312061835.428"><vh>ImportsChecker.close</vh></v>
<v t="ekr.20220312061835.429"><vh>ImportsChecker.deprecated_modules</vh></v>
<v t="ekr.20220312061835.430"><vh>ImportsChecker.visit_import</vh></v>
<v t="ekr.20220312061835.431"><vh>ImportsChecker.visit_importfrom</vh></v>
<v t="ekr.20220312061835.432"><vh>ImportsChecker.leave_module</vh></v>
<v t="ekr.20220312061835.433"><vh>ImportsChecker.compute_first_non_import_node</vh></v>
<v t="ekr.20220312061835.434"><vh>ImportsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.435"><vh>ImportsChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.436"><vh>ImportsChecker....some declarations</vh></v>
<v t="ekr.20220312061835.437"><vh>ImportsChecker._check_misplaced_future</vh></v>
<v t="ekr.20220312061835.438"><vh>ImportsChecker._check_same_line_imports</vh></v>
<v t="ekr.20220312061835.439"><vh>ImportsChecker._check_position</vh></v>
<v t="ekr.20220312061835.440"><vh>ImportsChecker._record_import</vh></v>
<v t="ekr.20220312061835.441"><vh>ImportsChecker._is_fallback_import</vh></v>
<v t="ekr.20220312061835.442"><vh>ImportsChecker._check_imports_order</vh></v>
<v t="ekr.20220312061835.443"><vh>ImportsChecker._get_imported_module</vh></v>
<v t="ekr.20220312061835.444"><vh>ImportsChecker._add_imported_module</vh></v>
<v t="ekr.20220312061835.445"><vh>ImportsChecker._check_preferred_module</vh></v>
<v t="ekr.20220312061835.446"><vh>ImportsChecker._check_import_as_rename</vh></v>
<v t="ekr.20220312061835.447"><vh>ImportsChecker._check_reimport</vh></v>
<v t="ekr.20220312061835.448"><vh>ImportsChecker._report_external_dependencies</vh></v>
<v t="ekr.20220312061835.449"><vh>ImportsChecker._report_dependencies_graph</vh></v>
<v t="ekr.20220312061835.450"><vh>ImportsChecker._filter_dependencies_graph</vh></v>
<v t="ekr.20220312061835.451"><vh>ImportsChecker._external_dependencies_info</vh></v>
<v t="ekr.20220312061835.452"><vh>ImportsChecker._internal_dependencies_info</vh></v>
<v t="ekr.20220312061835.453"><vh>ImportsChecker._check_wildcard_imports</vh></v>
<v t="ekr.20220312061835.454"><vh>ImportsChecker._wildcard_import_is_allowed</vh></v>
<v t="ekr.20220312061835.455"><vh>ImportsChecker._check_toplevel</vh></v>
</v>
<v t="ekr.20220312061835.456"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.457"><vh>@@clean logging.py</vh>
<v t="ekr.20220312061835.458"><vh>is_method_call</vh></v>
<v t="ekr.20220312061835.459"><vh>class LoggingChecker</vh>
<v t="ekr.20220312061835.460"><vh>LoggingChecker.visit_module</vh></v>
<v t="ekr.20220312061835.461"><vh>LoggingChecker.visit_importfrom</vh></v>
<v t="ekr.20220312061835.462"><vh>LoggingChecker.visit_import</vh></v>
<v t="ekr.20220312061835.463"><vh>LoggingChecker.visit_call</vh></v>
<v t="ekr.20220312061835.464"><vh>LoggingChecker._check_log_method</vh></v>
<v t="ekr.20220312061835.465"><vh>LoggingChecker._helper_string</vh></v>
<v t="ekr.20220312061835.466"><vh>LoggingChecker._is_operand_literal_str</vh></v>
<v t="ekr.20220312061835.467"><vh>LoggingChecker._check_call_func</vh></v>
<v t="ekr.20220312061835.468"><vh>LoggingChecker._check_format_string</vh></v>
</v>
<v t="ekr.20220312061835.469"><vh>is_complex_format_str</vh></v>
<v t="ekr.20220312061835.470"><vh>_count_supplied_tokens</vh></v>
<v t="ekr.20220312061835.471"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.472"><vh>@@clean mapreduce_checker.py</vh>
<v t="ekr.20220312061835.473"><vh>class MapReduceMixin</vh>
<v t="ekr.20220312061835.474"><vh>MapReduceMixin.get_map_data</vh></v>
<v t="ekr.20220312061835.475"><vh>MapReduceMixin.reduce_map_data</vh></v>
</v>
</v>
<v t="ekr.20220312061835.476"><vh>@@clean misc.py</vh>
<v t="ekr.20220312061835.477"><vh>class ByIdManagedMessagesChecker</vh>
<v t="ekr.20220312061835.478"><vh>ByIdManagedMessagesChecker.process_module</vh></v>
</v>
<v t="ekr.20220312061835.479"><vh>class EncodingChecker</vh>
<v t="ekr.20220312061835.480"><vh>EncodingChecker.open</vh></v>
<v t="ekr.20220312061835.481"><vh>EncodingChecker._check_encoding</vh></v>
<v t="ekr.20220312061835.482"><vh>EncodingChecker.process_module</vh></v>
<v t="ekr.20220312061835.483"><vh>EncodingChecker.process_tokens</vh></v>
</v>
<v t="ekr.20220312061835.484"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.485"><vh>@@clean newstyle.py</vh>
<v t="ekr.20220312061835.486"><vh>class NewStyleConflictChecker</vh>
<v t="ekr.20220312061835.487"><vh>NewStyleConflictChecker.visit_functiondef</vh></v>
</v>
<v t="ekr.20220312061835.488"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.489"><vh>@@clean raw_metrics.py</vh>
<v t="ekr.20220312061835.490"><vh>report_raw_stats</vh></v>
<v t="ekr.20220312061835.491"><vh>class RawMetricsChecker</vh>
<v t="ekr.20220312061835.492"><vh>RawMetricsChecker.__init__</vh></v>
<v t="ekr.20220312061835.493"><vh>RawMetricsChecker.open</vh></v>
<v t="ekr.20220312061835.494"><vh>RawMetricsChecker.process_tokens</vh></v>
</v>
<v t="ekr.20220312061835.495"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.496"><vh>get_type</vh></v>
<v t="ekr.20220312061835.497"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.498"><vh>@@clean similar.py</vh>
<v t="ekr.20220312061835.499"><vh>class LineSpecifs</vh></v>
<v t="ekr.20220312061835.500"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.501"><vh>class CplSuccessiveLinesLimits</vh>
<v t="ekr.20220312061835.502"><vh>CplSuccessiveLinesLimits.__init__</vh></v>
</v>
<v t="ekr.20220312061835.503"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.504"><vh>class LinesChunk</vh>
<v t="ekr.20220312061835.505"><vh>LinesChunk.__init__</vh></v>
<v t="ekr.20220312061835.506"><vh>LinesChunk.__eq__</vh></v>
<v t="ekr.20220312061835.507"><vh>LinesChunk.__hash__</vh></v>
<v t="ekr.20220312061835.508"><vh>LinesChunk.__repr__</vh></v>
<v t="ekr.20220312061835.509"><vh>LinesChunk.__str__</vh></v>
</v>
<v t="ekr.20220312061835.510"><vh>class SuccessiveLinesLimits</vh>
<v t="ekr.20220312061835.511"><vh>SuccessiveLinesLimits.__init__</vh></v>
<v t="ekr.20220312061835.512"><vh>SuccessiveLinesLimits.start</vh></v>
<v t="ekr.20220312061835.513"><vh>SuccessiveLinesLimits.end</vh></v>
<v t="ekr.20220312061835.514"><vh>SuccessiveLinesLimits.end</vh></v>
<v t="ekr.20220312061835.515"><vh>SuccessiveLinesLimits.__repr__</vh></v>
</v>
<v t="ekr.20220312061835.516"><vh>class LineSetStartCouple</vh>
<v t="ekr.20220312061835.517"><vh>LineSetStartCouple.__repr__</vh></v>
<v t="ekr.20220312061835.518"><vh>LineSetStartCouple.__eq__</vh></v>
<v t="ekr.20220312061835.519"><vh>LineSetStartCouple.__hash__</vh></v>
<v t="ekr.20220312061835.520"><vh>LineSetStartCouple.increment</vh></v>
</v>
<v t="ekr.20220312061835.521"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.522"><vh>hash_lineset</vh></v>
<v t="ekr.20220312061835.523"><vh>remove_successives</vh></v>
<v t="ekr.20220312061835.524"><vh>filter_noncode_lines</vh></v>
<v t="ekr.20220312061835.525"><vh>class Commonality</vh></v>
<v t="ekr.20220312061835.526"><vh>class Similar</vh>
<v t="ekr.20220312061835.527"><vh>Similar.__init__</vh></v>
<v t="ekr.20220312061835.528"><vh>Similar.append_stream</vh></v>
<v t="ekr.20220312061835.529"><vh>Similar.run</vh></v>
<v t="ekr.20220312061835.530"><vh>Similar._compute_sims</vh></v>
<v t="ekr.20220312061835.531"><vh>Similar._display_sims</vh></v>
<v t="ekr.20220312061835.532"><vh>Similar._get_similarity_report</vh></v>
<v t="ekr.20220312061835.533"><vh>Similar._find_common</vh></v>
<v t="ekr.20220312061835.534"><vh>Similar._iter_sims</vh></v>
<v t="ekr.20220312061835.535"><vh>Similar.get_map_data</vh></v>
<v t="ekr.20220312061835.536"><vh>Similar.combine_mapreduce_data</vh></v>
</v>
<v t="ekr.20220312061835.537"><vh>stripped_lines</vh></v>
<v t="ekr.20220312061835.538"><vh>class LineSet</vh>
<v t="ekr.20220312061835.539"><vh>LineSet.__init__</vh></v>
<v t="ekr.20220312061835.540"><vh>LineSet.__str__</vh></v>
<v t="ekr.20220312061835.541"><vh>LineSet.__len__</vh></v>
<v t="ekr.20220312061835.542"><vh>LineSet.__getitem__</vh></v>
<v t="ekr.20220312061835.543"><vh>LineSet.__lt__</vh></v>
<v t="ekr.20220312061835.544"><vh>LineSet.__hash__</vh></v>
<v t="ekr.20220312061835.545"><vh>LineSet.__eq__</vh></v>
<v t="ekr.20220312061835.546"><vh>LineSet.stripped_lines</vh></v>
<v t="ekr.20220312061835.547"><vh>LineSet.real_lines</vh></v>
</v>
<v t="ekr.20220312061835.548"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.549"><vh>report_similarities</vh></v>
<v t="ekr.20220312061835.550"><vh>class SimilarChecker</vh>
<v t="ekr.20220312061835.551"><vh>SimilarChecker.__init__</vh></v>
<v t="ekr.20220312061835.552"><vh>SimilarChecker.set_option</vh></v>
<v t="ekr.20220312061835.553"><vh>SimilarChecker.open</vh></v>
<v t="ekr.20220312061835.554"><vh>SimilarChecker.process_module</vh></v>
<v t="ekr.20220312061835.555"><vh>SimilarChecker.close</vh></v>
<v t="ekr.20220312061835.556"><vh>SimilarChecker.get_map_data</vh></v>
<v t="ekr.20220312061835.557"><vh>SimilarChecker.reduce_map_data</vh></v>
</v>
<v t="ekr.20220312061835.558"><vh>register</vh></v>
<v t="ekr.20220312061835.559"><vh>usage</vh></v>
<v t="ekr.20220312061835.560"><vh>Run</vh></v>
</v>
<v t="ekr.20220312061835.561"><vh>@@clean spelling.py</vh>
<v t="ekr.20220312061835.562"><vh>class WordsWithDigitsFilter</vh>
<v t="ekr.20220312061835.563"><vh>WordsWithDigitsFilter._skip</vh></v>
</v>
<v t="ekr.20220312061835.564"><vh>class WordsWithUnderscores</vh>
<v t="ekr.20220312061835.565"><vh>WordsWithUnderscores._skip</vh></v>
</v>
<v t="ekr.20220312061835.566"><vh>class RegExFilter</vh>
<v t="ekr.20220312061835.567"><vh>RegExFilter._skip</vh></v>
</v>
<v t="ekr.20220312061835.568"><vh>class CamelCasedWord</vh></v>
<v t="ekr.20220312061835.569"><vh>class SphinxDirectives</vh></v>
<v t="ekr.20220312061835.570"><vh>class ForwardSlashChunker</vh>
<v t="ekr.20220312061835.571"><vh>ForwardSlashChunker.next</vh></v>
<v t="ekr.20220312061835.572"><vh>ForwardSlashChunker._next</vh></v>
</v>
<v t="ekr.20220312061835.573"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.574"><vh>_strip_code_flanked_in_backticks</vh>
<v t="ekr.20220312061835.575"><vh>replace_code_but_leave_surrounding_characters</vh></v>
</v>
<v t="ekr.20220312061835.576"><vh>class SpellingChecker</vh>
<v t="ekr.20220312061835.577"><vh>SpellingChecker.open</vh></v>
<v t="ekr.20220312061835.578"><vh>SpellingChecker.close</vh></v>
<v t="ekr.20220312061835.579"><vh>SpellingChecker._check_spelling</vh></v>
<v t="ekr.20220312061835.580"><vh>SpellingChecker.process_tokens</vh></v>
<v t="ekr.20220312061835.581"><vh>SpellingChecker.visit_module</vh></v>
<v t="ekr.20220312061835.582"><vh>SpellingChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.583"><vh>SpellingChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.584"><vh>SpellingChecker....some declarations</vh></v>
<v t="ekr.20220312061835.585"><vh>SpellingChecker._check_docstring</vh></v>
</v>
<v t="ekr.20220312061835.586"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.587"><vh>@@clean stdlib.py</vh>
<v t="ekr.20220312061835.588"><vh>_check_mode_str</vh></v>
<v t="ekr.20220312061835.589"><vh>class StdlibChecker</vh>
<v t="ekr.20220312061835.590"><vh>StdlibChecker.__init__</vh></v>
<v t="ekr.20220312061835.591"><vh>StdlibChecker._check_bad_thread_instantiation</vh></v>
<v t="ekr.20220312061835.592"><vh>StdlibChecker._check_for_preexec_fn_in_popen</vh></v>
<v t="ekr.20220312061835.593"><vh>StdlibChecker._check_for_check_kw_in_run</vh></v>
<v t="ekr.20220312061835.594"><vh>StdlibChecker._check_shallow_copy_environ</vh></v>
<v t="ekr.20220312061835.595"><vh>StdlibChecker....some declarations</vh></v>
<v t="ekr.20220312061835.596"><vh>StdlibChecker.visit_call</vh></v>
<v t="ekr.20220312061835.597"><vh>StdlibChecker.visit_unaryop</vh></v>
<v t="ekr.20220312061835.598"><vh>StdlibChecker.visit_if</vh></v>
<v t="ekr.20220312061835.599"><vh>StdlibChecker.visit_ifexp</vh></v>
<v t="ekr.20220312061835.600"><vh>StdlibChecker.visit_boolop</vh></v>
<v t="ekr.20220312061835.601"><vh>StdlibChecker._check_redundant_assert</vh></v>
<v t="ekr.20220312061835.602"><vh>StdlibChecker._check_datetime</vh></v>
<v t="ekr.20220312061835.603"><vh>StdlibChecker._check_open_mode</vh></v>
<v t="ekr.20220312061835.604"><vh>StdlibChecker._check_open_encoded</vh></v>
<v t="ekr.20220312061835.605"><vh>StdlibChecker._check_env_function</vh></v>
<v t="ekr.20220312061835.606"><vh>StdlibChecker._check_invalid_envvar_value</vh></v>
<v t="ekr.20220312061835.607"><vh>StdlibChecker.deprecated_modules</vh></v>
<v t="ekr.20220312061835.608"><vh>StdlibChecker.deprecated_methods</vh></v>
<v t="ekr.20220312061835.609"><vh>StdlibChecker.deprecated_arguments</vh></v>
<v t="ekr.20220312061835.610"><vh>StdlibChecker.deprecated_classes</vh></v>
<v t="ekr.20220312061835.611"><vh>StdlibChecker.deprecated_decorators</vh></v>
</v>
<v t="ekr.20220312061835.612"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.613"><vh>@@clean strings.py</vh>
<v t="ekr.20220312061835.614"><vh>get_access_path</vh></v>
<v t="ekr.20220312061835.615"><vh>arg_matches_format_type</vh></v>
<v t="ekr.20220312061835.616"><vh>class StringFormatChecker</vh>
<v t="ekr.20220312061835.617"><vh>StringFormatChecker.visit_binop</vh></v>
<v t="ekr.20220312061835.618"><vh>StringFormatChecker.visit_joinedstr</vh></v>
<v t="ekr.20220312061835.619"><vh>StringFormatChecker.visit_call</vh></v>
<v t="ekr.20220312061835.620"><vh>StringFormatChecker._detect_vacuous_formatting</vh></v>
<v t="ekr.20220312061835.621"><vh>StringFormatChecker._check_new_format</vh></v>
<v t="ekr.20220312061835.622"><vh>StringFormatChecker._check_new_format_specifiers</vh></v>
</v>
<v t="ekr.20220312061835.623"><vh>class StringConstantChecker</vh>
<v t="ekr.20220312061835.624"><vh>StringConstantChecker.__init__</vh></v>
<v t="ekr.20220312061835.625"><vh>StringConstantChecker.process_module</vh></v>
<v t="ekr.20220312061835.626"><vh>StringConstantChecker.process_tokens</vh></v>
<v t="ekr.20220312061835.627"><vh>StringConstantChecker.visit_list</vh></v>
<v t="ekr.20220312061835.628"><vh>StringConstantChecker.visit_set</vh></v>
<v t="ekr.20220312061835.629"><vh>StringConstantChecker.visit_tuple</vh></v>
<v t="ekr.20220312061835.630"><vh>StringConstantChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.631"><vh>StringConstantChecker.check_for_consistent_string_delimiters</vh></v>
<v t="ekr.20220312061835.632"><vh>StringConstantChecker.check_for_concatenated_strings</vh></v>
<v t="ekr.20220312061835.633"><vh>StringConstantChecker.process_string_token</vh></v>
<v t="ekr.20220312061835.634"><vh>StringConstantChecker.process_non_raw_string_token</vh></v>
<v t="ekr.20220312061835.635"><vh>StringConstantChecker.visit_const</vh></v>
<v t="ekr.20220312061835.636"><vh>StringConstantChecker._detect_u_string_prefix</vh></v>
</v>
<v t="ekr.20220312061835.637"><vh>register</vh></v>
<v t="ekr.20220312061835.638"><vh>str_eval</vh></v>
<v t="ekr.20220312061835.639"><vh>_is_long_string</vh></v>
<v t="ekr.20220312061835.640"><vh>_get_quote_delimiter</vh></v>
<v t="ekr.20220312061835.641"><vh>_is_quote_delimiter_chosen_freely</vh></v>
</v>
<v t="ekr.20220312061835.642"><vh>@@clean typecheck.py</vh>
<v t="ekr.20220312061835.643"><vh>_unflatten</vh></v>
<v t="ekr.20220312061835.644"><vh>_flatten_container</vh></v>
<v t="ekr.20220312061835.645"><vh>_is_owner_ignored</vh></v>
<v t="ekr.20220312061835.646"><vh>_node_names</vh></v>
<v t="ekr.20220312061835.647"><vh>_</vh></v>
<v t="ekr.20220312061835.648"><vh>_string_distance</vh></v>
<v t="ekr.20220312061835.649"><vh>_similar_names</vh></v>
<v t="ekr.20220312061835.650"><vh>_missing_member_hint</vh></v>
<v t="ekr.20220312061835.651"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.652"><vh>_emit_no_member</vh></v>
<v t="ekr.20220312061835.653"><vh>_determine_callable</vh></v>
<v t="ekr.20220312061835.654"><vh>_has_parent_of_type</vh></v>
<v t="ekr.20220312061835.655"><vh>_no_context_variadic_keywords</vh></v>
<v t="ekr.20220312061835.656"><vh>_no_context_variadic_positional</vh></v>
<v t="ekr.20220312061835.657"><vh>_no_context_variadic</vh></v>
<v t="ekr.20220312061835.658"><vh>_is_invalid_metaclass</vh></v>
<v t="ekr.20220312061835.659"><vh>_infer_from_metaclass_constructor</vh></v>
<v t="ekr.20220312061835.660"><vh>_is_c_extension</vh></v>
<v t="ekr.20220312061835.661"><vh>_is_invalid_isinstance_type</vh></v>
<v t="ekr.20220312061835.662"><vh>class TypeChecker</vh>
<v t="ekr.20220312061835.663"><vh>TypeChecker._suggestion_mode</vh></v>
<v t="ekr.20220312061835.664"><vh>TypeChecker._compiled_generated_members</vh></v>
<v t="ekr.20220312061835.665"><vh>TypeChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.666"><vh>TypeChecker....some declarations</vh></v>
<v t="ekr.20220312061835.667"><vh>TypeChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.668"><vh>TypeChecker.visit_assignattr</vh></v>
<v t="ekr.20220312061835.669"><vh>TypeChecker.visit_delattr</vh></v>
<v t="ekr.20220312061835.670"><vh>TypeChecker.visit_attribute</vh></v>
<v t="ekr.20220312061835.671"><vh>TypeChecker._get_nomember_msgid_hint</vh></v>
<v t="ekr.20220312061835.672"><vh>TypeChecker....some declarations</vh></v>
<v t="ekr.20220312061835.673"><vh>TypeChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.674"><vh>TypeChecker._check_assignment_from_function_call</vh></v>
<v t="ekr.20220312061835.675"><vh>TypeChecker._check_dundername_is_string</vh></v>
<v t="ekr.20220312061835.676"><vh>TypeChecker._check_uninferable_call</vh></v>
<v t="ekr.20220312061835.677"><vh>TypeChecker._check_argument_order</vh></v>
<v t="ekr.20220312061835.678"><vh>TypeChecker._check_isinstance_args</vh></v>
<v t="ekr.20220312061835.679"><vh>TypeChecker.visit_call</vh></v>
<v t="ekr.20220312061835.680"><vh>TypeChecker._check_invalid_sequence_index</vh></v>
<v t="ekr.20220312061835.681"><vh>TypeChecker.visit_extslice</vh></v>
<v t="ekr.20220312061835.682"><vh>TypeChecker._check_invalid_slice_index</vh></v>
<v t="ekr.20220312061835.683"><vh>TypeChecker.visit_with</vh></v>
<v t="ekr.20220312061835.684"><vh>TypeChecker.visit_unaryop</vh></v>
<v t="ekr.20220312061835.685"><vh>TypeChecker.visit_binop</vh></v>
<v t="ekr.20220312061835.686"><vh>TypeChecker._detect_unsupported_alternative_union_syntax</vh></v>
<v t="ekr.20220312061835.687"><vh>TypeChecker._check_unsupported_alternative_union_syntax</vh></v>
<v t="ekr.20220312061835.688"><vh>TypeChecker._visit_binop</vh></v>
<v t="ekr.20220312061835.689"><vh>TypeChecker._visit_augassign</vh></v>
<v t="ekr.20220312061835.690"><vh>TypeChecker._check_binop_errors</vh></v>
<v t="ekr.20220312061835.691"><vh>TypeChecker._check_membership_test</vh></v>
<v t="ekr.20220312061835.692"><vh>TypeChecker.visit_compare</vh></v>
<v t="ekr.20220312061835.693"><vh>TypeChecker....some declarations</vh></v>
<v t="ekr.20220312061835.694"><vh>TypeChecker.visit_subscript</vh></v>
<v t="ekr.20220312061835.695"><vh>TypeChecker.visit_for</vh></v>
</v>
<v t="ekr.20220312061835.696"><vh>class IterableChecker</vh>
<v t="ekr.20220312061835.697"><vh>IterableChecker._is_asyncio_coroutine</vh></v>
<v t="ekr.20220312061835.698"><vh>IterableChecker._check_iterable</vh></v>
<v t="ekr.20220312061835.699"><vh>IterableChecker._check_mapping</vh></v>
<v t="ekr.20220312061835.700"><vh>IterableChecker.visit_for</vh></v>
<v t="ekr.20220312061835.701"><vh>IterableChecker.visit_asyncfor</vh></v>
<v t="ekr.20220312061835.702"><vh>IterableChecker.visit_yieldfrom</vh></v>
<v t="ekr.20220312061835.703"><vh>IterableChecker.visit_call</vh></v>
<v t="ekr.20220312061835.704"><vh>IterableChecker.visit_listcomp</vh></v>
<v t="ekr.20220312061835.705"><vh>IterableChecker.visit_dictcomp</vh></v>
<v t="ekr.20220312061835.706"><vh>IterableChecker.visit_setcomp</vh></v>
<v t="ekr.20220312061835.707"><vh>IterableChecker.visit_generatorexp</vh></v>
<v t="ekr.20220312061835.708"><vh>IterableChecker.visit_await</vh></v>
<v t="ekr.20220312061835.709"><vh>IterableChecker._check_await_outside_coroutine</vh></v>
</v>
<v t="ekr.20220312061835.710"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.711"><vh>@@clean utils.py</vh>
<v t="ekr.20220312061835.712"><vh>class NoSuchArgumentError</vh></v>
<v t="ekr.20220312061835.713"><vh>class InferredTypeError</vh></v>
<v t="ekr.20220312061835.714"><vh>is_inside_lambda</vh></v>
<v t="ekr.20220312061835.715"><vh>get_all_elements</vh></v>
<v t="ekr.20220312061835.716"><vh>is_super</vh></v>
<v t="ekr.20220312061835.717"><vh>is_error</vh></v>
<v t="ekr.20220312061835.718"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.719"><vh>is_builtin_object</vh></v>
<v t="ekr.20220312061835.720"><vh>is_builtin</vh></v>
<v t="ekr.20220312061835.721"><vh>is_defined_in_scope</vh></v>
<v t="ekr.20220312061835.722"><vh>is_defined_before</vh></v>
<v t="ekr.20220312061835.723"><vh>is_default_argument</vh></v>
<v t="ekr.20220312061835.724"><vh>is_func_decorator</vh></v>
<v t="ekr.20220312061835.725"><vh>is_ancestor_name</vh></v>
<v t="ekr.20220312061835.726"><vh>is_being_called</vh></v>
<v t="ekr.20220312061835.727"><vh>assign_parent</vh></v>
<v t="ekr.20220312061835.728"><vh>overrides_a_method</vh></v>
<v t="ekr.20220312061835.729"><vh>check_messages</vh>
<v t="ekr.20220312061835.730"><vh>store_messages</vh></v>
</v>
<v t="ekr.20220312061835.731"><vh>class IncompleteFormatString</vh></v>
<v t="ekr.20220312061835.732"><vh>class UnsupportedFormatCharacter</vh></v>
<v t="ekr.20220312061835.733"><vh>parse_format_string</vh>
<v t="ekr.20220312061835.734"><vh>next_char</vh></v>
</v>
<v t="ekr.20220312061835.735"><vh>split_format_field_names</vh></v>
<v t="ekr.20220312061835.736"><vh>collect_string_fields</vh></v>
<v t="ekr.20220312061835.737"><vh>parse_format_method_string</vh></v>
<v t="ekr.20220312061835.738"><vh>is_attr_protected</vh></v>
<v t="ekr.20220312061835.739"><vh>node_frame_class</vh></v>
<v t="ekr.20220312061835.740"><vh>is_attr_private</vh></v>
<v t="ekr.20220312061835.741"><vh>get_argument_from_call</vh></v>
<v t="ekr.20220312061835.742"><vh>inherit_from_std_ex</vh></v>
<v t="ekr.20220312061835.743"><vh>error_of_type</vh>
<v t="ekr.20220312061835.744"><vh>stringify_error</vh></v>
</v>
<v t="ekr.20220312061835.745"><vh>decorated_with_property</vh></v>
<v t="ekr.20220312061835.746"><vh>_is_property_kind</vh></v>
<v t="ekr.20220312061835.747"><vh>is_property_setter</vh></v>
<v t="ekr.20220312061835.748"><vh>is_property_deleter</vh></v>
<v t="ekr.20220312061835.749"><vh>is_property_setter_or_deleter</vh></v>
<v t="ekr.20220312061835.750"><vh>_is_property_decorator</vh></v>
<v t="ekr.20220312061835.751"><vh>decorated_with</vh></v>
<v t="ekr.20220312061835.752"><vh>unimplemented_abstract_methods</vh></v>
<v t="ekr.20220312061835.753"><vh>find_try_except_wrapper_node</vh></v>
<v t="ekr.20220312061835.754"><vh>find_except_wrapper_node_in_scope</vh></v>
<v t="ekr.20220312061835.755"><vh>is_from_fallback_block</vh></v>
<v t="ekr.20220312061835.756"><vh>_except_handlers_ignores_exception</vh></v>
<v t="ekr.20220312061835.757"><vh>get_exception_handlers</vh></v>
<v t="ekr.20220312061835.758"><vh>is_node_inside_try_except</vh></v>
<v t="ekr.20220312061835.759"><vh>node_ignores_exception</vh></v>
<v t="ekr.20220312061835.760"><vh>class_is_abstract</vh></v>
<v t="ekr.20220312061835.761"><vh>_supports_protocol_method</vh></v>
<v t="ekr.20220312061835.762"><vh>is_comprehension</vh></v>
<v t="ekr.20220312061835.763"><vh>_supports_mapping_protocol</vh></v>
<v t="ekr.20220312061835.764"><vh>_supports_membership_test_protocol</vh></v>
<v t="ekr.20220312061835.765"><vh>_supports_iteration_protocol</vh></v>
<v t="ekr.20220312061835.766"><vh>_supports_async_iteration_protocol</vh></v>
<v t="ekr.20220312061835.767"><vh>_supports_getitem_protocol</vh></v>
<v t="ekr.20220312061835.768"><vh>_supports_setitem_protocol</vh></v>
<v t="ekr.20220312061835.769"><vh>_supports_delitem_protocol</vh></v>
<v t="ekr.20220312061835.770"><vh>_is_abstract_class_name</vh></v>
<v t="ekr.20220312061835.771"><vh>is_inside_abstract_class</vh></v>
<v t="ekr.20220312061835.772"><vh>_supports_protocol</vh></v>
<v t="ekr.20220312061835.773"><vh>is_iterable</vh></v>
<v t="ekr.20220312061835.774"><vh>is_mapping</vh></v>
<v t="ekr.20220312061835.775"><vh>supports_membership_test</vh></v>
<v t="ekr.20220312061835.776"><vh>supports_getitem</vh></v>
<v t="ekr.20220312061835.777"><vh>supports_setitem</vh></v>
<v t="ekr.20220312061835.778"><vh>supports_delitem</vh></v>
<v t="ekr.20220312061835.779"><vh>_get_python_type_of_node</vh></v>
<v t="ekr.20220312061835.780"><vh>safe_infer</vh></v>
<v t="ekr.20220312061835.781"><vh>infer_all</vh></v>
<v t="ekr.20220312061835.782"><vh>has_known_bases</vh></v>
<v t="ekr.20220312061835.783"><vh>is_none</vh></v>
<v t="ekr.20220312061835.784"><vh>node_type</vh></v>
<v t="ekr.20220312061835.785"><vh>is_registered_in_singledispatch_function</vh></v>
<v t="ekr.20220312061835.786"><vh>get_node_last_lineno</vh></v>
<v t="ekr.20220312061835.787"><vh>is_postponed_evaluation_enabled</vh></v>
<v t="ekr.20220312061835.788"><vh>is_class_subscriptable_pep585_with_postponed_evaluation_enabled</vh></v>
<v t="ekr.20220312061835.789"><vh>is_node_in_type_annotation_context</vh></v>
<v t="ekr.20220312061835.790"><vh>is_subclass_of</vh></v>
<v t="ekr.20220312061835.791"><vh>is_overload_stub</vh></v>
<v t="ekr.20220312061835.792"><vh>is_protocol_class</vh></v>
<v t="ekr.20220312061835.793"><vh>is_call_of_name</vh></v>
<v t="ekr.20220312061835.794"><vh>is_test_condition</vh></v>
<v t="ekr.20220312061835.795"><vh>is_classdef_type</vh></v>
<v t="ekr.20220312061835.796"><vh>is_attribute_typed_annotation</vh></v>
<v t="ekr.20220312061835.797"><vh>is_assign_name_annotated_with</vh></v>
<v t="ekr.20220312061835.798"><vh>get_iterating_dictionary_name</vh></v>
<v t="ekr.20220312061835.799"><vh>get_subscript_const_value</vh></v>
<v t="ekr.20220312061835.800"><vh>get_import_name</vh></v>
<v t="ekr.20220312061835.801"><vh>is_node_in_guarded_import_block</vh></v>
<v t="ekr.20220312061835.802"><vh>is_reassigned_after_current</vh></v>
</v>
<v t="ekr.20220312061835.803"><vh>@@clean variables.py</vh>
<v t="ekr.20220312061835.804"><vh>_is_from_future_import</vh></v>
<v t="ekr.20220312061835.805"><vh>in_for_else_branch</vh></v>
<v t="ekr.20220312061835.806"><vh>overridden_method</vh></v>
<v t="ekr.20220312061835.807"><vh>_get_unpacking_extra_info</vh></v>
<v t="ekr.20220312061835.808"><vh>_detect_global_scope</vh></v>
<v t="ekr.20220312061835.809"><vh>_infer_name_module</vh></v>
<v t="ekr.20220312061835.810"><vh>_fix_dot_imports</vh></v>
<v t="ekr.20220312061835.811"><vh>_find_frame_imports</vh></v>
<v t="ekr.20220312061835.812"><vh>_import_name_is_global</vh></v>
<v t="ekr.20220312061835.813"><vh>_flattened_scope_names</vh></v>
<v t="ekr.20220312061835.814"><vh>_assigned_locally</vh></v>
<v t="ekr.20220312061835.815"><vh>_is_type_checking_import</vh></v>
<v t="ekr.20220312061835.816"><vh>_has_locals_call_after_node</vh></v>
<v t="ekr.20220312061835.817"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.818"><vh>class NamesConsumer</vh>
<v t="ekr.20220312061835.819"><vh>NamesConsumer.__init__</vh></v>
<v t="ekr.20220312061835.820"><vh>NamesConsumer.__repr__</vh></v>
<v t="ekr.20220312061835.821"><vh>NamesConsumer.__iter__</vh></v>
<v t="ekr.20220312061835.822"><vh>NamesConsumer.to_consume</vh></v>
<v t="ekr.20220312061835.823"><vh>NamesConsumer.consumed</vh></v>
<v t="ekr.20220312061835.824"><vh>NamesConsumer.scope_type</vh></v>
<v t="ekr.20220312061835.825"><vh>NamesConsumer.mark_as_consumed</vh></v>
<v t="ekr.20220312061835.826"><vh>NamesConsumer.get_next_to_consume</vh></v>
</v>
<v t="ekr.20220312061835.827"><vh>class VariablesChecker</vh>
<v t="ekr.20220312061835.828"><vh>VariablesChecker.__init__</vh></v>
<v t="ekr.20220312061835.829"><vh>VariablesChecker.visit_for</vh></v>
<v t="ekr.20220312061835.830"><vh>VariablesChecker.leave_for</vh></v>
<v t="ekr.20220312061835.831"><vh>VariablesChecker.visit_module</vh></v>
<v t="ekr.20220312061835.832"><vh>VariablesChecker....some declarations</vh></v>
<v t="ekr.20220312061835.833"><vh>VariablesChecker.leave_module</vh></v>
<v t="ekr.20220312061835.834"><vh>VariablesChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.835"><vh>VariablesChecker.leave_classdef</vh></v>
<v t="ekr.20220312061835.836"><vh>VariablesChecker.visit_lambda</vh></v>
<v t="ekr.20220312061835.837"><vh>VariablesChecker.leave_lambda</vh></v>
<v t="ekr.20220312061835.838"><vh>VariablesChecker.visit_generatorexp</vh></v>
<v t="ekr.20220312061835.839"><vh>VariablesChecker.leave_generatorexp</vh></v>
<v t="ekr.20220312061835.840"><vh>VariablesChecker.visit_dictcomp</vh></v>
<v t="ekr.20220312061835.841"><vh>VariablesChecker.leave_dictcomp</vh></v>
<v t="ekr.20220312061835.842"><vh>VariablesChecker.visit_setcomp</vh></v>
<v t="ekr.20220312061835.843"><vh>VariablesChecker.leave_setcomp</vh></v>
<v t="ekr.20220312061835.844"><vh>VariablesChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.845"><vh>VariablesChecker.leave_functiondef</vh></v>
<v t="ekr.20220312061835.846"><vh>VariablesChecker....some declarations</vh></v>
<v t="ekr.20220312061835.847"><vh>VariablesChecker.visit_global</vh></v>
<v t="ekr.20220312061835.848"><vh>VariablesChecker.visit_assignname</vh></v>
<v t="ekr.20220312061835.849"><vh>VariablesChecker.visit_delname</vh></v>
<v t="ekr.20220312061835.850"><vh>VariablesChecker.visit_name</vh></v>
<v t="ekr.20220312061835.851"><vh>VariablesChecker.visit_import</vh></v>
<v t="ekr.20220312061835.852"><vh>VariablesChecker.visit_importfrom</vh></v>
<v t="ekr.20220312061835.853"><vh>VariablesChecker....some declarations</vh></v>
<v t="ekr.20220312061835.854"><vh>VariablesChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.855"><vh>VariablesChecker.visit_listcomp</vh></v>
<v t="ekr.20220312061835.856"><vh>VariablesChecker.leave_listcomp</vh></v>
<v t="ekr.20220312061835.857"><vh>VariablesChecker.leave_assign</vh></v>
<v t="ekr.20220312061835.858"><vh>VariablesChecker.leave_with</vh></v>
<v t="ekr.20220312061835.859"><vh>VariablesChecker.visit_arguments</vh></v>
<v t="ekr.20220312061835.860"><vh>VariablesChecker._analyse_fallback_blocks</vh></v>
<v t="ekr.20220312061835.861"><vh>VariablesChecker._ignored_modules</vh></v>
<v t="ekr.20220312061835.862"><vh>VariablesChecker._allow_global_unused_variables</vh></v>
<v t="ekr.20220312061835.863"><vh>VariablesChecker._defined_in_function_definition</vh></v>
<v t="ekr.20220312061835.864"><vh>VariablesChecker._in_lambda_or_comprehension_body</vh></v>
<v t="ekr.20220312061835.865"><vh>VariablesChecker._is_variable_violation</vh></v>
<v t="ekr.20220312061835.866"><vh>VariablesChecker._ignore_class_scope</vh></v>
<v t="ekr.20220312061835.867"><vh>VariablesChecker._loopvar_name</vh></v>
<v t="ekr.20220312061835.868"><vh>VariablesChecker._check_is_unused</vh></v>
<v t="ekr.20220312061835.869"><vh>VariablesChecker._is_name_ignored</vh></v>
<v t="ekr.20220312061835.870"><vh>VariablesChecker._check_unused_arguments</vh></v>
<v t="ekr.20220312061835.871"><vh>VariablesChecker._check_late_binding_closure</vh></v>
<v t="ekr.20220312061835.872"><vh>VariablesChecker._should_ignore_redefined_builtin</vh></v>
<v t="ekr.20220312061835.873"><vh>VariablesChecker._allowed_redefined_builtin</vh></v>
<v t="ekr.20220312061835.874"><vh>VariablesChecker._has_homonym_in_upper_function_scope</vh></v>
<v t="ekr.20220312061835.875"><vh>VariablesChecker._store_type_annotation_node</vh></v>
<v t="ekr.20220312061835.876"><vh>VariablesChecker._store_type_annotation_names</vh></v>
<v t="ekr.20220312061835.877"><vh>VariablesChecker._check_self_cls_assign</vh></v>
<v t="ekr.20220312061835.878"><vh>VariablesChecker._check_unpacking</vh></v>
<v t="ekr.20220312061835.879"><vh>VariablesChecker._check_module_attrs</vh></v>
<v t="ekr.20220312061835.880"><vh>VariablesChecker._check_all</vh></v>
<v t="ekr.20220312061835.881"><vh>VariablesChecker._check_globals</vh></v>
<v t="ekr.20220312061835.882"><vh>VariablesChecker._check_imports</vh></v>
<v t="ekr.20220312061835.883"><vh>VariablesChecker._check_metaclasses</vh></v>
<v t="ekr.20220312061835.884"><vh>VariablesChecker._check_classdef_metaclasses</vh></v>
</v>
<v t="ekr.20220312061835.885"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.886"><vh>@@clean __init__.py</vh>
<v t="ekr.20220312061835.887"><vh>table_lines_from_stats</vh></v>
<v t="ekr.20220312061835.888"><vh>initialize</vh></v>
</v>
<v t="ekr.20220312061835.889"><vh>@path refactoring</vh>
<v t="ekr.20220312061835.890"><vh>@@clean len_checker.py</vh>
<v t="ekr.20220312061835.891"><vh>class LenChecker</vh>
<v t="ekr.20220312061835.892"><vh>LenChecker.visit_call</vh></v>
<v t="ekr.20220312061835.893"><vh>LenChecker.instance_has_bool</vh></v>
<v t="ekr.20220312061835.894"><vh>LenChecker.visit_unaryop</vh></v>
<v t="ekr.20220312061835.895"><vh>LenChecker.base_classes_of_node</vh></v>
</v>
</v>
<v t="ekr.20220312061835.896"><vh>@@clean not_checker.py</vh>
<v t="ekr.20220312061835.897"><vh>class NotChecker</vh>
<v t="ekr.20220312061835.898"><vh>NotChecker.visit_unaryop</vh></v>
</v>
</v>
<v t="ekr.20220312061835.899"><vh>@@clean recommendation_checker.py</vh>
<v t="ekr.20220312061835.900"><vh>class RecommendationChecker</vh>
<v t="ekr.20220312061835.901"><vh>RecommendationChecker._is_builtin</vh></v>
<v t="ekr.20220312061835.902"><vh>RecommendationChecker.visit_call</vh></v>
<v t="ekr.20220312061835.903"><vh>RecommendationChecker._check_consider_iterating_dictionary</vh></v>
<v t="ekr.20220312061835.904"><vh>RecommendationChecker._check_use_maxsplit_arg</vh></v>
<v t="ekr.20220312061835.905"><vh>RecommendationChecker....some declarations</vh></v>
<v t="ekr.20220312061835.906"><vh>RecommendationChecker.visit_for</vh></v>
<v t="ekr.20220312061835.907"><vh>RecommendationChecker._check_consider_using_enumerate</vh></v>
<v t="ekr.20220312061835.908"><vh>RecommendationChecker._check_consider_using_dict_items</vh></v>
<v t="ekr.20220312061835.909"><vh>RecommendationChecker....some declarations</vh></v>
<v t="ekr.20220312061835.910"><vh>RecommendationChecker.visit_comprehension</vh></v>
<v t="ekr.20220312061835.911"><vh>RecommendationChecker._check_consider_using_dict_items_comprehension</vh></v>
<v t="ekr.20220312061835.912"><vh>RecommendationChecker._check_use_sequence_for_iteration</vh></v>
<v t="ekr.20220312061835.913"><vh>RecommendationChecker.visit_const</vh></v>
<v t="ekr.20220312061835.914"><vh>RecommendationChecker._detect_replacable_format_call</vh></v>
</v>
</v>
<v t="ekr.20220312061835.915"><vh>@@clean refactoring_checker.py</vh>
<v t="ekr.20220312061835.916"><vh>_if_statement_is_always_returning</vh></v>
<v t="ekr.20220312061835.917"><vh>_is_trailing_comma</vh>
<v t="ekr.20220312061835.918"><vh>same_start_token</vh></v>
<v t="ekr.20220312061835.919"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.920"><vh>get_curline_index_start</vh></v>
</v>
<v t="ekr.20220312061835.921"><vh>_is_inside_context_manager</vh></v>
<v t="ekr.20220312061835.922"><vh>_is_a_return_statement</vh></v>
<v t="ekr.20220312061835.923"><vh>_is_part_of_with_items</vh></v>
<v t="ekr.20220312061835.924"><vh>_will_be_released_automatically</vh></v>
<v t="ekr.20220312061835.925"><vh>class ConsiderUsingWithStack</vh>
<v t="ekr.20220312061835.926"><vh>ConsiderUsingWithStack.__iter__</vh></v>
<v t="ekr.20220312061835.927"><vh>ConsiderUsingWithStack.get_stack_for_frame</vh></v>
<v t="ekr.20220312061835.928"><vh>ConsiderUsingWithStack.clear_all</vh></v>
</v>
<v t="ekr.20220312061835.929"><vh>class RefactoringChecker</vh>
<v t="ekr.20220312061835.930"><vh>RefactoringChecker.__init__</vh></v>
<v t="ekr.20220312061835.931"><vh>RefactoringChecker._init</vh></v>
<v t="ekr.20220312061835.932"><vh>RefactoringChecker.open</vh></v>
<v t="ekr.20220312061835.933"><vh>RefactoringChecker._dummy_rgx</vh></v>
<v t="ekr.20220312061835.934"><vh>RefactoringChecker._is_bool_const</vh></v>
<v t="ekr.20220312061835.935"><vh>RefactoringChecker._is_actual_elif</vh></v>
<v t="ekr.20220312061835.936"><vh>RefactoringChecker._check_simplifiable_if</vh></v>
<v t="ekr.20220312061835.937"><vh>RefactoringChecker.process_tokens</vh></v>
<v t="ekr.20220312061835.938"><vh>RefactoringChecker.leave_module</vh></v>
<v t="ekr.20220312061835.939"><vh>RefactoringChecker.visit_tryexcept</vh></v>
<v t="ekr.20220312061835.940"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.941"><vh>RefactoringChecker._check_redefined_argument_from_local</vh></v>
<v t="ekr.20220312061835.942"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.943"><vh>RefactoringChecker.visit_for</vh></v>
<v t="ekr.20220312061835.944"><vh>RefactoringChecker.visit_excepthandler</vh></v>
<v t="ekr.20220312061835.945"><vh>RefactoringChecker.visit_with</vh></v>
<v t="ekr.20220312061835.946"><vh>RefactoringChecker._check_superfluous_else</vh></v>
<v t="ekr.20220312061835.947"><vh>RefactoringChecker._check_superfluous_else_return</vh></v>
<v t="ekr.20220312061835.948"><vh>RefactoringChecker._check_superfluous_else_raise</vh></v>
<v t="ekr.20220312061835.949"><vh>RefactoringChecker._check_superfluous_else_break</vh></v>
<v t="ekr.20220312061835.950"><vh>RefactoringChecker._check_superfluous_else_continue</vh></v>
<v t="ekr.20220312061835.951"><vh>RefactoringChecker._type_and_name_are_equal</vh></v>
<v t="ekr.20220312061835.952"><vh>RefactoringChecker._is_dict_get_block</vh></v>
<v t="ekr.20220312061835.953"><vh>RefactoringChecker._check_consider_get</vh></v>
<v t="ekr.20220312061835.954"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.955"><vh>RefactoringChecker.visit_if</vh></v>
<v t="ekr.20220312061835.956"><vh>RefactoringChecker._check_consider_using_min_max_builtin</vh></v>
<v t="ekr.20220312061835.957"><vh>RefactoringChecker.visit_ifexp</vh></v>
<v t="ekr.20220312061835.958"><vh>RefactoringChecker._check_simplifiable_ifexp</vh></v>
<v t="ekr.20220312061835.959"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.960"><vh>RefactoringChecker.leave_functiondef</vh></v>
<v t="ekr.20220312061835.961"><vh>RefactoringChecker.leave_classdef</vh></v>
<v t="ekr.20220312061835.962"><vh>RefactoringChecker.visit_raise</vh></v>
<v t="ekr.20220312061835.963"><vh>RefactoringChecker._check_stop_iteration_inside_generator</vh></v>
<v t="ekr.20220312061835.964"><vh>RefactoringChecker._check_exception_inherit_from_stopiteration</vh></v>
<v t="ekr.20220312061835.965"><vh>RefactoringChecker._check_consider_using_comprehension_constructor</vh></v>
<v t="ekr.20220312061835.966"><vh>RefactoringChecker._check_consider_using_generator</vh></v>
<v t="ekr.20220312061835.967"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.968"><vh>RefactoringChecker.visit_call</vh></v>
<v t="ekr.20220312061835.969"><vh>RefactoringChecker._has_exit_in_scope</vh></v>
<v t="ekr.20220312061835.970"><vh>RefactoringChecker._check_quit_exit_call</vh></v>
<v t="ekr.20220312061835.971"><vh>RefactoringChecker._check_super_with_arguments</vh></v>
<v t="ekr.20220312061835.972"><vh>RefactoringChecker._check_raising_stopiteration_in_generator_next_call</vh></v>
<v t="ekr.20220312061835.973"><vh>RefactoringChecker._check_nested_blocks</vh></v>
<v t="ekr.20220312061835.974"><vh>RefactoringChecker._emit_nested_blocks_message_if_needed</vh></v>
<v t="ekr.20220312061835.975"><vh>RefactoringChecker._emit_consider_using_with_if_needed</vh></v>
<v t="ekr.20220312061835.976"><vh>RefactoringChecker._duplicated_isinstance_types</vh></v>
<v t="ekr.20220312061835.977"><vh>RefactoringChecker._check_consider_merging_isinstance</vh></v>
<v t="ekr.20220312061835.978"><vh>RefactoringChecker._check_consider_using_in</vh></v>
<v t="ekr.20220312061835.979"><vh>RefactoringChecker._check_chained_comparison</vh></v>
<v t="ekr.20220312061835.980"><vh>RefactoringChecker._apply_boolean_simplification_rules</vh></v>
<v t="ekr.20220312061835.981"><vh>RefactoringChecker._simplify_boolean_operation</vh></v>
<v t="ekr.20220312061835.982"><vh>RefactoringChecker._check_simplifiable_condition</vh></v>
<v t="ekr.20220312061835.983"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.984"><vh>RefactoringChecker.visit_boolop</vh></v>
<v t="ekr.20220312061835.985"><vh>RefactoringChecker._is_simple_assignment</vh></v>
<v t="ekr.20220312061835.986"><vh>RefactoringChecker._check_swap_variables</vh></v>
<v t="ekr.20220312061835.987"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.988"><vh>RefactoringChecker.visit_assign</vh></v>
<v t="ekr.20220312061835.989"><vh>RefactoringChecker....some declarations</vh></v>
<v t="ekr.20220312061835.990"><vh>RefactoringChecker.visit_return</vh></v>
<v t="ekr.20220312061835.991"><vh>RefactoringChecker._append_context_managers_to_stack</vh></v>
<v t="ekr.20220312061835.992"><vh>RefactoringChecker._check_consider_using_with</vh></v>
<v t="ekr.20220312061835.993"><vh>RefactoringChecker._check_use_list_or_dict_literal</vh></v>
<v t="ekr.20220312061835.994"><vh>RefactoringChecker._check_consider_using_join</vh></v>
<v t="ekr.20220312061835.995"><vh>RefactoringChecker.visit_augassign</vh></v>
<v t="ekr.20220312061835.996"><vh>RefactoringChecker.visit_comprehension</vh></v>
<v t="ekr.20220312061835.997"><vh>RefactoringChecker._check_unnecessary_comprehension</vh></v>
<v t="ekr.20220312061835.998"><vh>RefactoringChecker._is_and_or_ternary</vh></v>
<v t="ekr.20220312061835.999"><vh>RefactoringChecker._and_or_ternary_arguments</vh></v>
<v t="ekr.20220312061835.1000"><vh>RefactoringChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.1001"><vh>RefactoringChecker._check_consistent_returns</vh></v>
<v t="ekr.20220312061835.1002"><vh>RefactoringChecker._is_if_node_return_ended</vh></v>
<v t="ekr.20220312061835.1003"><vh>RefactoringChecker._is_raise_node_return_ended</vh></v>
<v t="ekr.20220312061835.1004"><vh>RefactoringChecker._is_node_return_ended</vh></v>
<v t="ekr.20220312061835.1005"><vh>RefactoringChecker._has_return_in_siblings</vh></v>
<v t="ekr.20220312061835.1006"><vh>RefactoringChecker._is_function_def_never_returning</vh></v>
<v t="ekr.20220312061835.1007"><vh>RefactoringChecker._check_return_at_the_end</vh></v>
<v t="ekr.20220312061835.1008"><vh>RefactoringChecker._check_unnecessary_dict_index_lookup</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1009"><vh>@@clean __init__.py</vh>
<v t="ekr.20220312061835.1010"><vh>register</vh></v>
</v>
</v>
</v>
<v t="ekr.20220312061835.1011"><vh>@path config</vh>
<v t="ekr.20220312061835.1012"><vh>@@clean configuration_mixin.py</vh>
<v t="ekr.20220312061835.1013"><vh>class ConfigurationMixIn</vh>
<v t="ekr.20220312061835.1014"><vh>ConfigurationMixIn.__init__</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1015"><vh>@@clean find_default_config_files.py</vh>
<v t="ekr.20220312061835.1016"><vh>_toml_has_config</vh></v>
<v t="ekr.20220312061835.1017"><vh>_cfg_has_config</vh></v>
<v t="ekr.20220312061835.1018"><vh>find_default_config_files</vh></v>
</v>
<v t="ekr.20220312061835.1019"><vh>@@clean man_help_formatter.py</vh>
<v t="ekr.20220312061835.1020"><vh>class _ManHelpFormatter</vh>
<v t="ekr.20220312061835.1021"><vh>_ManHelpFormatter.__init__</vh></v>
<v t="ekr.20220312061835.1022"><vh>_ManHelpFormatter.format_heading</vh></v>
<v t="ekr.20220312061835.1023"><vh>_ManHelpFormatter.format_description</vh></v>
<v t="ekr.20220312061835.1024"><vh>_ManHelpFormatter.format_option</vh></v>
<v t="ekr.20220312061835.1025"><vh>_ManHelpFormatter.format_head</vh></v>
<v t="ekr.20220312061835.1026"><vh>_ManHelpFormatter.format_title</vh></v>
<v t="ekr.20220312061835.1027"><vh>_ManHelpFormatter.format_short_description</vh></v>
<v t="ekr.20220312061835.1028"><vh>_ManHelpFormatter.format_synopsis</vh></v>
<v t="ekr.20220312061835.1029"><vh>_ManHelpFormatter.format_long_description</vh></v>
<v t="ekr.20220312061835.1030"><vh>_ManHelpFormatter.format_tail</vh></v>
</v>
<v t="ekr.20220312061835.1031"><vh>_generate_manpage</vh></v>
</v>
<v t="ekr.20220312061835.1032"><vh>@@clean option.py</vh>
<v t="ekr.20220312061835.1033"><vh>_csv_validator</vh></v>
<v t="ekr.20220312061835.1034"><vh>_regexp_validator</vh></v>
<v t="ekr.20220312061835.1035"><vh>_regexp_csv_validator</vh></v>
<v t="ekr.20220312061835.1036"><vh>_choice_validator</vh></v>
<v t="ekr.20220312061835.1037"><vh>_yn_validator</vh></v>
<v t="ekr.20220312061835.1038"><vh>_multiple_choice_validator</vh></v>
<v t="ekr.20220312061835.1039"><vh>_non_empty_string_validator</vh></v>
<v t="ekr.20220312061835.1040"><vh>_multiple_choices_validating_option</vh></v>
<v t="ekr.20220312061835.1041"><vh>_py_version_validator</vh></v>
<v t="ekr.20220312061835.1042"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1043"><vh>_call_validator</vh></v>
<v t="ekr.20220312061835.1044"><vh>_validate</vh></v>
<v t="ekr.20220312061835.1045"><vh>class Option</vh>
<v t="ekr.20220312061835.1046"><vh>Option.__init__</vh></v>
<v t="ekr.20220312061835.1047"><vh>Option._check_choice</vh></v>
<v t="ekr.20220312061835.1048"><vh>Option....some declarations</vh></v>
<v t="ekr.20220312061835.1049"><vh>Option.process</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1050"><vh>@@clean options_provider_mixin.py</vh>
<v t="ekr.20220312061835.1051"><vh>class UnsupportedAction</vh></v>
<v t="ekr.20220312061835.1052"><vh>class OptionsProviderMixIn</vh>
<v t="ekr.20220312061835.1053"><vh>OptionsProviderMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1054"><vh>OptionsProviderMixIn.load_defaults</vh></v>
<v t="ekr.20220312061835.1055"><vh>OptionsProviderMixIn.option_attrname</vh></v>
<v t="ekr.20220312061835.1056"><vh>OptionsProviderMixIn.option_value</vh></v>
<v t="ekr.20220312061835.1057"><vh>OptionsProviderMixIn.set_option</vh></v>
<v t="ekr.20220312061835.1058"><vh>OptionsProviderMixIn.get_option_def</vh></v>
<v t="ekr.20220312061835.1059"><vh>OptionsProviderMixIn.options_by_section</vh></v>
<v t="ekr.20220312061835.1060"><vh>OptionsProviderMixIn.options_and_values</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1061"><vh>@@clean option_manager_mixin.py</vh>
<v t="ekr.20220312061835.1062"><vh>_expand_default</vh></v>
<v t="ekr.20220312061835.1063"><vh>_patch_optparse</vh></v>
<v t="ekr.20220312061835.1064"><vh>class OptionsManagerMixIn</vh>
<v t="ekr.20220312061835.1065"><vh>OptionsManagerMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1066"><vh>OptionsManagerMixIn.reset_parsers</vh></v>
<v t="ekr.20220312061835.1067"><vh>OptionsManagerMixIn.register_options_provider</vh></v>
<v t="ekr.20220312061835.1068"><vh>OptionsManagerMixIn.add_option_group</vh></v>
<v t="ekr.20220312061835.1069"><vh>OptionsManagerMixIn.add_optik_option</vh></v>
<v t="ekr.20220312061835.1070"><vh>OptionsManagerMixIn.optik_option</vh></v>
<v t="ekr.20220312061835.1071"><vh>OptionsManagerMixIn.cb_set_provider_option</vh></v>
<v t="ekr.20220312061835.1072"><vh>OptionsManagerMixIn.global_set_option</vh></v>
<v t="ekr.20220312061835.1073"><vh>OptionsManagerMixIn.generate_config</vh></v>
<v t="ekr.20220312061835.1074"><vh>OptionsManagerMixIn.generate_manpage</vh></v>
<v t="ekr.20220312061835.1075"><vh>OptionsManagerMixIn.load_provider_defaults</vh></v>
<v t="ekr.20220312061835.1076"><vh>OptionsManagerMixIn.read_config_file</vh></v>
<v t="ekr.20220312061835.1077"><vh>OptionsManagerMixIn.load_config_file</vh></v>
<v t="ekr.20220312061835.1078"><vh>OptionsManagerMixIn.load_configuration</vh></v>
<v t="ekr.20220312061835.1079"><vh>OptionsManagerMixIn.load_configuration_from_config</vh></v>
<v t="ekr.20220312061835.1080"><vh>OptionsManagerMixIn.load_command_line_configuration</vh></v>
<v t="ekr.20220312061835.1081"><vh>OptionsManagerMixIn.add_help_section</vh></v>
<v t="ekr.20220312061835.1082"><vh>OptionsManagerMixIn.help</vh></v>
<v t="ekr.20220312061835.1083"><vh>OptionsManagerMixIn.helpfunc</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1084"><vh>@@clean option_parser.py</vh>
<v t="ekr.20220312061835.1085"><vh>_level_options</vh></v>
<v t="ekr.20220312061835.1086"><vh>class OptionParser</vh>
<v t="ekr.20220312061835.1087"><vh>OptionParser.__init__</vh></v>
<v t="ekr.20220312061835.1088"><vh>OptionParser.format_option_help</vh></v>
<v t="ekr.20220312061835.1089"><vh>OptionParser._match_long_opt</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1090"><vh>@@clean __init__.py</vh>
<v t="ekr.20220312061835.1091"><vh>_get_pdata_path</vh></v>
<v t="ekr.20220312061835.1092"><vh>load_results</vh></v>
<v t="ekr.20220312061835.1093"><vh>save_results</vh></v>
<v t="ekr.20220312061835.1094"><vh>find_pylintrc</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1095"><vh>@path extensions</vh>
<v t="ekr.20220312061835.1096"><vh>@@clean bad_builtin.py</vh>
<v t="ekr.20220312061835.1097"><vh>class BadBuiltinChecker</vh>
<v t="ekr.20220312061835.1098"><vh>BadBuiltinChecker.visit_call</vh></v>
</v>
<v t="ekr.20220312061835.1099"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1100"><vh>@@clean broad_try_clause.py</vh>
<v t="ekr.20220312061835.1101"><vh>class BroadTryClauseChecker</vh>
<v t="ekr.20220312061835.1102"><vh>BroadTryClauseChecker._count_statements</vh></v>
<v t="ekr.20220312061835.1103"><vh>BroadTryClauseChecker.visit_tryexcept</vh></v>
<v t="ekr.20220312061835.1104"><vh>BroadTryClauseChecker.visit_tryfinally</vh></v>
</v>
<v t="ekr.20220312061835.1105"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1106"><vh>@@clean check_docs.py</vh>
<v t="ekr.20220312061835.1107"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1108"><vh>@@clean check_elif.py</vh>
<v t="ekr.20220312061835.1109"><vh>class ElseifUsedChecker</vh>
<v t="ekr.20220312061835.1110"><vh>ElseifUsedChecker.__init__</vh></v>
<v t="ekr.20220312061835.1111"><vh>ElseifUsedChecker._init</vh></v>
<v t="ekr.20220312061835.1112"><vh>ElseifUsedChecker.process_tokens</vh></v>
<v t="ekr.20220312061835.1113"><vh>ElseifUsedChecker.leave_module</vh></v>
<v t="ekr.20220312061835.1114"><vh>ElseifUsedChecker.visit_ifexp</vh></v>
<v t="ekr.20220312061835.1115"><vh>ElseifUsedChecker.visit_comprehension</vh></v>
<v t="ekr.20220312061835.1116"><vh>ElseifUsedChecker.visit_if</vh></v>
</v>
<v t="ekr.20220312061835.1117"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1118"><vh>@@clean code_style.py</vh>
<v t="ekr.20220312061835.1119"><vh>class CodeStyleChecker</vh>
<v t="ekr.20220312061835.1120"><vh>CodeStyleChecker.__init__</vh></v>
<v t="ekr.20220312061835.1121"><vh>CodeStyleChecker.open</vh></v>
<v t="ekr.20220312061835.1122"><vh>CodeStyleChecker.visit_dict</vh></v>
<v t="ekr.20220312061835.1123"><vh>CodeStyleChecker.visit_for</vh></v>
<v t="ekr.20220312061835.1124"><vh>CodeStyleChecker.visit_comprehension</vh></v>
<v t="ekr.20220312061835.1125"><vh>CodeStyleChecker.visit_if</vh></v>
<v t="ekr.20220312061835.1126"><vh>CodeStyleChecker._check_dict_consider_namedtuple_dataclass</vh></v>
<v t="ekr.20220312061835.1127"><vh>CodeStyleChecker._check_consider_using_assignment_expr</vh></v>
<v t="ekr.20220312061835.1128"><vh>CodeStyleChecker._check_prev_sibling_to_if_stmt</vh></v>
<v t="ekr.20220312061835.1129"><vh>CodeStyleChecker._check_ignore_assignment_expr_suggestion</vh></v>
</v>
<v t="ekr.20220312061835.1130"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1131"><vh>@@clean comparetozero.py</vh>
<v t="ekr.20220312061835.1132"><vh>_is_constant_zero</vh></v>
<v t="ekr.20220312061835.1133"><vh>class CompareToZeroChecker</vh>
<v t="ekr.20220312061835.1134"><vh>CompareToZeroChecker.visit_compare</vh></v>
</v>
<v t="ekr.20220312061835.1135"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1136"><vh>@@clean confusing_elif.py</vh>
<v t="ekr.20220312061835.1137"><vh>class ConfusingConsecutiveElifChecker</vh>
<v t="ekr.20220312061835.1138"><vh>ConfusingConsecutiveElifChecker.visit_if</vh></v>
<v t="ekr.20220312061835.1139"><vh>ConfusingConsecutiveElifChecker._has_no_else_clause</vh></v>
</v>
<v t="ekr.20220312061835.1140"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1141"><vh>@@clean consider_ternary_expression.py</vh>
<v t="ekr.20220312061835.1142"><vh>class ConsiderTernaryExpressionChecker</vh>
<v t="ekr.20220312061835.1143"><vh>ConsiderTernaryExpressionChecker.visit_if</vh></v>
</v>
<v t="ekr.20220312061835.1144"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1145"><vh>@@clean docparams.py</vh>
<v t="ekr.20220312061835.1146"><vh>class DocstringParameterChecker</vh>
<v t="ekr.20220312061835.1147"><vh>DocstringParameterChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.1148"><vh>DocstringParameterChecker....some declarations</vh></v>
<v t="ekr.20220312061835.1149"><vh>DocstringParameterChecker.check_functiondef_params</vh></v>
<v t="ekr.20220312061835.1150"><vh>DocstringParameterChecker.check_functiondef_returns</vh></v>
<v t="ekr.20220312061835.1151"><vh>DocstringParameterChecker.check_functiondef_yields</vh></v>
<v t="ekr.20220312061835.1152"><vh>DocstringParameterChecker.visit_raise</vh></v>
<v t="ekr.20220312061835.1153"><vh>DocstringParameterChecker.visit_return</vh></v>
<v t="ekr.20220312061835.1154"><vh>DocstringParameterChecker.visit_yield</vh></v>
<v t="ekr.20220312061835.1155"><vh>DocstringParameterChecker.visit_yieldfrom</vh></v>
<v t="ekr.20220312061835.1156"><vh>DocstringParameterChecker._compare_missing_args</vh></v>
<v t="ekr.20220312061835.1157"><vh>DocstringParameterChecker._compare_different_args</vh></v>
<v t="ekr.20220312061835.1158"><vh>DocstringParameterChecker._compare_ignored_args</vh></v>
<v t="ekr.20220312061835.1159"><vh>DocstringParameterChecker.check_arguments_in_docstring</vh></v>
<v t="ekr.20220312061835.1160"><vh>DocstringParameterChecker.check_single_constructor_params</vh></v>
<v t="ekr.20220312061835.1161"><vh>DocstringParameterChecker._handle_no_raise_doc</vh></v>
<v t="ekr.20220312061835.1162"><vh>DocstringParameterChecker._add_raise_message</vh></v>
</v>
<v t="ekr.20220312061835.1163"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1164"><vh>@@clean docstyle.py</vh>
<v t="ekr.20220312061835.1165"><vh>class DocStringStyleChecker</vh>
<v t="ekr.20220312061835.1166"><vh>DocStringStyleChecker.visit_module</vh></v>
<v t="ekr.20220312061835.1167"><vh>DocStringStyleChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.1168"><vh>DocStringStyleChecker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.1169"><vh>DocStringStyleChecker....some declarations</vh></v>
<v t="ekr.20220312061835.1170"><vh>DocStringStyleChecker._check_docstring</vh></v>
</v>
<v t="ekr.20220312061835.1171"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1172"><vh>@@clean emptystring.py</vh>
<v t="ekr.20220312061835.1173"><vh>_is_constant_empty_str</vh></v>
<v t="ekr.20220312061835.1174"><vh>class CompareToEmptyStringChecker</vh>
<v t="ekr.20220312061835.1175"><vh>CompareToEmptyStringChecker.visit_compare</vh></v>
</v>
<v t="ekr.20220312061835.1176"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1177"><vh>@@clean empty_comment.py</vh>
<v t="ekr.20220312061835.1178"><vh>is_line_commented</vh></v>
<v t="ekr.20220312061835.1179"><vh>comment_part_of_string</vh></v>
<v t="ekr.20220312061835.1180"><vh>class CommentChecker</vh>
<v t="ekr.20220312061835.1181"><vh>CommentChecker.process_module</vh></v>
</v>
<v t="ekr.20220312061835.1182"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1183"><vh>@@clean mccabe.py</vh>
<v t="ekr.20220312061835.1184"><vh>class PathGraph</vh></v>
<v t="ekr.20220312061835.1185"><vh>class PathGraphingAstVisitor</vh>
<v t="ekr.20220312061835.1186"><vh>PathGraphingAstVisitor.__init__</vh></v>
<v t="ekr.20220312061835.1187"><vh>PathGraphingAstVisitor.default</vh></v>
<v t="ekr.20220312061835.1188"><vh>PathGraphingAstVisitor.dispatch</vh></v>
<v t="ekr.20220312061835.1189"><vh>PathGraphingAstVisitor.visitFunctionDef</vh></v>
<v t="ekr.20220312061835.1190"><vh>PathGraphingAstVisitor....some declarations</vh></v>
<v t="ekr.20220312061835.1191"><vh>PathGraphingAstVisitor.visitSimpleStatement</vh></v>
<v t="ekr.20220312061835.1192"><vh>PathGraphingAstVisitor....some declarations</vh></v>
<v t="ekr.20220312061835.1193"><vh>PathGraphingAstVisitor.visitWith</vh></v>
<v t="ekr.20220312061835.1194"><vh>PathGraphingAstVisitor....some declarations</vh></v>
<v t="ekr.20220312061835.1195"><vh>PathGraphingAstVisitor._append_node</vh></v>
<v t="ekr.20220312061835.1196"><vh>PathGraphingAstVisitor._subgraph</vh></v>
<v t="ekr.20220312061835.1197"><vh>PathGraphingAstVisitor._subgraph_parse</vh></v>
</v>
<v t="ekr.20220312061835.1198"><vh>class McCabeMethodChecker</vh>
<v t="ekr.20220312061835.1199"><vh>McCabeMethodChecker.visit_module</vh></v>
</v>
<v t="ekr.20220312061835.1200"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1201"><vh>@@clean overlapping_exceptions.py</vh>
<v t="ekr.20220312061835.1202"><vh>class OverlappingExceptionsChecker</vh>
<v t="ekr.20220312061835.1203"><vh>OverlappingExceptionsChecker.visit_tryexcept</vh></v>
</v>
<v t="ekr.20220312061835.1204"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1205"><vh>@@clean redefined_variable_type.py</vh>
<v t="ekr.20220312061835.1206"><vh>class MultipleTypesChecker</vh>
<v t="ekr.20220312061835.1207"><vh>MultipleTypesChecker.visit_classdef</vh></v>
<v t="ekr.20220312061835.1208"><vh>MultipleTypesChecker.leave_classdef</vh></v>
<v t="ekr.20220312061835.1209"><vh>MultipleTypesChecker....some declarations</vh></v>
<v t="ekr.20220312061835.1210"><vh>MultipleTypesChecker.visit_module</vh></v>
<v t="ekr.20220312061835.1211"><vh>MultipleTypesChecker._check_and_add_messages</vh></v>
<v t="ekr.20220312061835.1212"><vh>MultipleTypesChecker.visit_assign</vh></v>
</v>
<v t="ekr.20220312061835.1213"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1214"><vh>@@clean set_membership.py</vh>
<v t="ekr.20220312061835.1215"><vh>class SetMembershipChecker</vh>
<v t="ekr.20220312061835.1216"><vh>SetMembershipChecker.__init__</vh></v>
<v t="ekr.20220312061835.1217"><vh>SetMembershipChecker.visit_compare</vh></v>
<v t="ekr.20220312061835.1218"><vh>SetMembershipChecker._check_in_comparison</vh></v>
</v>
<v t="ekr.20220312061835.1219"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1220"><vh>@@clean typing.py</vh>
<v t="ekr.20220312061835.1221"><vh>class TypingAlias</vh></v>
<v t="ekr.20220312061835.1222"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1223"><vh>class DeprecatedTypingAliasMsg</vh></v>
<v t="ekr.20220312061835.1224"><vh>class TypingChecker</vh>
<v t="ekr.20220312061835.1225"><vh>TypingChecker.__init__</vh></v>
<v t="ekr.20220312061835.1226"><vh>TypingChecker.open</vh></v>
<v t="ekr.20220312061835.1227"><vh>TypingChecker._msg_postponed_eval_hint</vh></v>
<v t="ekr.20220312061835.1228"><vh>TypingChecker....some declarations</vh></v>
<v t="ekr.20220312061835.1229"><vh>TypingChecker.visit_name</vh></v>
<v t="ekr.20220312061835.1230"><vh>TypingChecker....some declarations</vh></v>
<v t="ekr.20220312061835.1231"><vh>TypingChecker.visit_attribute</vh></v>
<v t="ekr.20220312061835.1232"><vh>TypingChecker._check_for_alternative_union_syntax</vh></v>
<v t="ekr.20220312061835.1233"><vh>TypingChecker._check_for_typing_alias</vh></v>
<v t="ekr.20220312061835.1234"><vh>TypingChecker.leave_module</vh></v>
</v>
<v t="ekr.20220312061835.1235"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1236"><vh>@@clean while_used.py</vh>
<v t="ekr.20220312061835.1237"><vh>class WhileChecker</vh>
<v t="ekr.20220312061835.1238"><vh>WhileChecker.visit_while</vh></v>
</v>
<v t="ekr.20220312061835.1239"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1240"><vh>@@clean _check_docs_utils.py</vh>
<v t="ekr.20220312061835.1241"><vh>space_indentation</vh></v>
<v t="ekr.20220312061835.1242"><vh>get_setters_property_name</vh></v>
<v t="ekr.20220312061835.1243"><vh>get_setters_property</vh></v>
<v t="ekr.20220312061835.1244"><vh>returns_something</vh></v>
<v t="ekr.20220312061835.1245"><vh>_get_raise_target</vh></v>
<v t="ekr.20220312061835.1246"><vh>_split_multiple_exc_types</vh></v>
<v t="ekr.20220312061835.1247"><vh>possible_exc_types</vh></v>
<v t="ekr.20220312061835.1248"><vh>docstringify</vh></v>
<v t="ekr.20220312061835.1249"><vh>class Docstring</vh>
<v t="ekr.20220312061835.1250"><vh>Docstring.__init__</vh></v>
<v t="ekr.20220312061835.1251"><vh>Docstring.__repr__</vh></v>
<v t="ekr.20220312061835.1252"><vh>Docstring.is_valid</vh></v>
<v t="ekr.20220312061835.1253"><vh>Docstring.exceptions</vh></v>
<v t="ekr.20220312061835.1254"><vh>Docstring.has_params</vh></v>
<v t="ekr.20220312061835.1255"><vh>Docstring.has_returns</vh></v>
<v t="ekr.20220312061835.1256"><vh>Docstring.has_rtype</vh></v>
<v t="ekr.20220312061835.1257"><vh>Docstring.has_property_returns</vh></v>
<v t="ekr.20220312061835.1258"><vh>Docstring.has_property_type</vh></v>
<v t="ekr.20220312061835.1259"><vh>Docstring.has_yields</vh></v>
<v t="ekr.20220312061835.1260"><vh>Docstring.has_yields_type</vh></v>
<v t="ekr.20220312061835.1261"><vh>Docstring.match_param_docs</vh></v>
<v t="ekr.20220312061835.1262"><vh>Docstring.params_documented_elsewhere</vh></v>
</v>
<v t="ekr.20220312061835.1263"><vh>class SphinxDocstring</vh>
<v t="ekr.20220312061835.1264"><vh>SphinxDocstring.is_valid</vh></v>
<v t="ekr.20220312061835.1265"><vh>SphinxDocstring.exceptions</vh></v>
<v t="ekr.20220312061835.1266"><vh>SphinxDocstring.has_params</vh></v>
<v t="ekr.20220312061835.1267"><vh>SphinxDocstring.has_returns</vh></v>
<v t="ekr.20220312061835.1268"><vh>SphinxDocstring.has_rtype</vh></v>
<v t="ekr.20220312061835.1269"><vh>SphinxDocstring.has_property_returns</vh></v>
<v t="ekr.20220312061835.1270"><vh>SphinxDocstring.has_property_type</vh></v>
<v t="ekr.20220312061835.1271"><vh>SphinxDocstring.match_param_docs</vh></v>
</v>
<v t="ekr.20220312061835.1272"><vh>class EpytextDocstring</vh>
<v t="ekr.20220312061835.1273"><vh>EpytextDocstring.has_property_returns</vh></v>
</v>
<v t="ekr.20220312061835.1274"><vh>class GoogleDocstring</vh>
<v t="ekr.20220312061835.1275"><vh>GoogleDocstring.is_valid</vh></v>
<v t="ekr.20220312061835.1276"><vh>GoogleDocstring.has_params</vh></v>
<v t="ekr.20220312061835.1277"><vh>GoogleDocstring.has_returns</vh></v>
<v t="ekr.20220312061835.1278"><vh>GoogleDocstring.has_rtype</vh></v>
<v t="ekr.20220312061835.1279"><vh>GoogleDocstring.has_property_returns</vh></v>
<v t="ekr.20220312061835.1280"><vh>GoogleDocstring.has_property_type</vh></v>
<v t="ekr.20220312061835.1281"><vh>GoogleDocstring.has_yields</vh></v>
<v t="ekr.20220312061835.1282"><vh>GoogleDocstring.has_yields_type</vh></v>
<v t="ekr.20220312061835.1283"><vh>GoogleDocstring.exceptions</vh></v>
<v t="ekr.20220312061835.1284"><vh>GoogleDocstring.match_param_docs</vh></v>
<v t="ekr.20220312061835.1285"><vh>GoogleDocstring._first_line</vh></v>
<v t="ekr.20220312061835.1286"><vh>GoogleDocstring.min_section_indent</vh></v>
<v t="ekr.20220312061835.1287"><vh>GoogleDocstring._is_section_header</vh></v>
<v t="ekr.20220312061835.1288"><vh>GoogleDocstring._parse_section</vh></v>
</v>
<v t="ekr.20220312061835.1289"><vh>class NumpyDocstring</vh>
<v t="ekr.20220312061835.1290"><vh>NumpyDocstring.min_section_indent</vh></v>
<v t="ekr.20220312061835.1291"><vh>NumpyDocstring._is_section_header</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1292"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220312061835.1293"><vh>@path lint</vh>
<v t="ekr.20220312061835.1294"><vh>@@clean expand_modules.py</vh>
<v t="ekr.20220312061835.1295"><vh>_modpath_from_file</vh></v>
<v t="ekr.20220312061835.1296"><vh>get_python_path</vh></v>
<v t="ekr.20220312061835.1297"><vh>_is_in_ignore_list_re</vh></v>
<v t="ekr.20220312061835.1298"><vh>expand_modules</vh></v>
</v>
<v t="ekr.20220312061835.1299"><vh>@@clean parallel.py</vh>
<v t="ekr.20220312061835.1300"><vh>_get_new_args</vh></v>
<v t="ekr.20220312061835.1301"><vh>_merge_stats</vh></v>
<v t="ekr.20220312061835.1302"><vh>_worker_initialize</vh></v>
<v t="ekr.20220312061835.1303"><vh>_worker_check_single_file</vh></v>
<v t="ekr.20220312061835.1304"><vh>_merge_mapreduce_data</vh></v>
<v t="ekr.20220312061835.1305"><vh>check_parallel</vh></v>
</v>
<v t="ekr.20220312061835.1306"><vh>@@clean pylinter.py</vh>
<v t="ekr.20220312061835.1307"><vh>_read_stdin</vh></v>
<v t="ekr.20220312061835.1308"><vh>_load_reporter_by_class</vh></v>
<v t="ekr.20220312061835.1309"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1310"><vh>class PyLinter</vh>
<v t="ekr.20220312061835.1311"><vh>PyLinter.make_options</vh></v>
<v t="ekr.20220312061835.1312"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1313"><vh>PyLinter.__init__</vh></v>
<v t="ekr.20220312061835.1314"><vh>PyLinter.load_default_plugins</vh></v>
<v t="ekr.20220312061835.1315"><vh>PyLinter.load_plugin_modules</vh></v>
<v t="ekr.20220312061835.1316"><vh>PyLinter.load_plugin_configuration</vh></v>
<v t="ekr.20220312061835.1317"><vh>PyLinter._load_reporters</vh></v>
<v t="ekr.20220312061835.1318"><vh>PyLinter._load_reporter_by_name</vh></v>
<v t="ekr.20220312061835.1319"><vh>PyLinter.set_reporter</vh></v>
<v t="ekr.20220312061835.1320"><vh>PyLinter.set_option</vh></v>
<v t="ekr.20220312061835.1321"><vh>PyLinter.register_reporter</vh></v>
<v t="ekr.20220312061835.1322"><vh>PyLinter.report_order</vh></v>
<v t="ekr.20220312061835.1323"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1324"><vh>PyLinter.register_checker</vh></v>
<v t="ekr.20220312061835.1325"><vh>PyLinter.enable_fail_on_messages</vh></v>
<v t="ekr.20220312061835.1326"><vh>PyLinter.any_fail_on_issues</vh></v>
<v t="ekr.20220312061835.1327"><vh>PyLinter.disable_noerror_messages</vh></v>
<v t="ekr.20220312061835.1328"><vh>PyLinter.disable_reporters</vh></v>
<v t="ekr.20220312061835.1329"><vh>PyLinter.error_mode</vh></v>
<v t="ekr.20220312061835.1330"><vh>PyLinter.list_messages_enabled</vh></v>
<v t="ekr.20220312061835.1331"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1332"><vh>PyLinter.process_tokens</vh></v>
<v t="ekr.20220312061835.1333"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1334"><vh>PyLinter.get_checkers</vh></v>
<v t="ekr.20220312061835.1335"><vh>PyLinter.get_checker_names</vh></v>
<v t="ekr.20220312061835.1336"><vh>PyLinter.prepare_checkers</vh></v>
<v t="ekr.20220312061835.1337"><vh>PyLinter.should_analyze_file</vh></v>
<v t="ekr.20220312061835.1338"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1339"><vh>PyLinter.initialize</vh></v>
<v t="ekr.20220312061835.1340"><vh>PyLinter.check</vh></v>
<v t="ekr.20220312061835.1341"><vh>PyLinter.check_single_file</vh></v>
<v t="ekr.20220312061835.1342"><vh>PyLinter.check_single_file_item</vh></v>
<v t="ekr.20220312061835.1343"><vh>PyLinter._check_files</vh></v>
<v t="ekr.20220312061835.1344"><vh>PyLinter._check_file</vh></v>
<v t="ekr.20220312061835.1345"><vh>PyLinter._get_file_descr_from_stdin</vh></v>
<v t="ekr.20220312061835.1346"><vh>PyLinter._iterate_file_descrs</vh></v>
<v t="ekr.20220312061835.1347"><vh>PyLinter._expand_files</vh></v>
<v t="ekr.20220312061835.1348"><vh>PyLinter.set_current_module</vh></v>
<v t="ekr.20220312061835.1349"><vh>PyLinter._astroid_module_checker COOL: functools.partial</vh></v>
<v t="ekr.20220312061835.1350"><vh>PyLinter.get_ast</vh></v>
<v t="ekr.20220312061835.1351"><vh>PyLinter.check_astroid_module</vh></v>
<v t="ekr.20220312061835.1352"><vh>PyLinter._check_astroid_module</vh></v>
<v t="ekr.20220312061835.1353"><vh>PyLinter....some declarations</vh></v>
<v t="ekr.20220312061835.1354"><vh>PyLinter.open</vh></v>
<v t="ekr.20220312061835.1355"><vh>PyLinter.generate_reports</vh></v>
<v t="ekr.20220312061835.1356"><vh>PyLinter._report_evaluation</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1357"><vh>@@clean report_functions.py</vh>
<v t="ekr.20220312061835.1358"><vh>report_total_messages_stats</vh></v>
<v t="ekr.20220312061835.1359"><vh>report_messages_stats</vh></v>
<v t="ekr.20220312061835.1360"><vh>report_messages_by_module_stats</vh></v>
</v>
<v t="ekr.20220312061835.1361"><vh>@@clean run.py</vh>
<v t="ekr.20220312061835.1362"><vh>_cpu_count</vh></v>
<v t="ekr.20220312061835.1363"><vh>cb_list_extensions</vh></v>
<v t="ekr.20220312061835.1364"><vh>cb_list_confidence_levels</vh></v>
<v t="ekr.20220312061835.1365"><vh>cb_init_hook</vh></v>
<v t="ekr.20220312061835.1366"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1367"><vh>class Run</vh>
<v t="ekr.20220312061835.1368"><vh>Run._return_one</vh></v>
<v t="ekr.20220312061835.1369"><vh>Run.__init__</vh></v>
<v t="ekr.20220312061835.1370"><vh>Run.version_asked</vh></v>
<v t="ekr.20220312061835.1371"><vh>Run.cb_set_rcfile</vh></v>
<v t="ekr.20220312061835.1372"><vh>Run.cb_set_output</vh></v>
<v t="ekr.20220312061835.1373"><vh>Run.cb_add_plugins</vh></v>
<v t="ekr.20220312061835.1374"><vh>Run.cb_error_mode</vh></v>
<v t="ekr.20220312061835.1375"><vh>Run.cb_generate_config</vh></v>
<v t="ekr.20220312061835.1376"><vh>Run.cb_generate_manpage</vh></v>
<v t="ekr.20220312061835.1377"><vh>Run.cb_help_message</vh></v>
<v t="ekr.20220312061835.1378"><vh>Run.cb_full_documentation</vh></v>
<v t="ekr.20220312061835.1379"><vh>Run.cb_list_messages</vh></v>
<v t="ekr.20220312061835.1380"><vh>Run.cb_list_messages_enabled</vh></v>
<v t="ekr.20220312061835.1381"><vh>Run.cb_list_groups</vh></v>
<v t="ekr.20220312061835.1382"><vh>Run.cb_verbose_mode</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1383"><vh>@@clean utils.py</vh>
<v t="ekr.20220312061835.1384"><vh>class ArgumentPreprocessingError</vh></v>
<v t="ekr.20220312061835.1385"><vh>prepare_crash_report</vh></v>
<v t="ekr.20220312061835.1386"><vh>get_fatal_error_message</vh></v>
<v t="ekr.20220312061835.1387"><vh>preprocess_options</vh></v>
<v t="ekr.20220312061835.1388"><vh>_patch_sys_path</vh></v>
<v t="ekr.20220312061835.1389"><vh>fix_import_path</vh></v>
</v>
<v t="ekr.20220312061835.1390"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220312061835.1391"><vh>@path message</vh>
<v t="ekr.20220312061835.1392"><vh>@@clean message.py</vh>
<v t="ekr.20220312061835.1393"><vh>class Message</vh>
<v t="ekr.20220312061835.1394"><vh>Message.__new__</vh></v>
<v t="ekr.20220312061835.1395"><vh>Message.format</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1396"><vh>@@clean message_definition.py</vh>
<v t="ekr.20220312061835.1397"><vh>class MessageDefinition</vh>
<v t="ekr.20220312061835.1398"><vh>MessageDefinition.__init__</vh></v>
<v t="ekr.20220312061835.1399"><vh>MessageDefinition.check_msgid</vh></v>
<v t="ekr.20220312061835.1400"><vh>MessageDefinition.__repr__</vh></v>
<v t="ekr.20220312061835.1401"><vh>MessageDefinition.__str__</vh></v>
<v t="ekr.20220312061835.1402"><vh>MessageDefinition.may_be_emitted</vh></v>
<v t="ekr.20220312061835.1403"><vh>MessageDefinition.format_help</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1404"><vh>@@clean message_definition_store.py</vh>
<v t="ekr.20220312061835.1405"><vh>class MessageDefinitionStore</vh>
<v t="ekr.20220312061835.1406"><vh>MessageDefinitionStore.__init__</vh></v>
<v t="ekr.20220312061835.1407"><vh>MessageDefinitionStore.messages</vh></v>
<v t="ekr.20220312061835.1408"><vh>MessageDefinitionStore.register_messages_from_checker</vh></v>
<v t="ekr.20220312061835.1409"><vh>MessageDefinitionStore.register_message</vh></v>
<v t="ekr.20220312061835.1410"><vh>MessageDefinitionStore.get_message_definitions</vh></v>
<v t="ekr.20220312061835.1411"><vh>MessageDefinitionStore.get_msg_display_string</vh></v>
<v t="ekr.20220312061835.1412"><vh>MessageDefinitionStore.help_message</vh></v>
<v t="ekr.20220312061835.1413"><vh>MessageDefinitionStore.list_messages</vh></v>
<v t="ekr.20220312061835.1414"><vh>MessageDefinitionStore.find_emittable_messages</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1415"><vh>@@clean message_handler_mix_in.py</vh>
<v t="ekr.20220312061835.1416"><vh>class MessagesHandlerMixIn</vh>
<v t="ekr.20220312061835.1417"><vh>MessagesHandlerMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1418"><vh>MessagesHandlerMixIn._checker_messages</vh></v>
<v t="ekr.20220312061835.1419"><vh>MessagesHandlerMixIn.clear_by_id_managed_msgs</vh></v>
<v t="ekr.20220312061835.1420"><vh>MessagesHandlerMixIn.get_by_id_managed_msgs</vh></v>
<v t="ekr.20220312061835.1421"><vh>MessagesHandlerMixIn._register_by_id_managed_msg</vh></v>
<v t="ekr.20220312061835.1422"><vh>MessagesHandlerMixIn.disable</vh></v>
<v t="ekr.20220312061835.1423"><vh>MessagesHandlerMixIn.disable_next</vh></v>
<v t="ekr.20220312061835.1424"><vh>MessagesHandlerMixIn.enable</vh></v>
<v t="ekr.20220312061835.1425"><vh>MessagesHandlerMixIn._set_msg_status</vh></v>
<v t="ekr.20220312061835.1426"><vh>MessagesHandlerMixIn._set_one_msg_status</vh></v>
<v t="ekr.20220312061835.1427"><vh>MessagesHandlerMixIn._message_symbol</vh></v>
<v t="ekr.20220312061835.1428"><vh>MessagesHandlerMixIn.get_message_state_scope</vh></v>
<v t="ekr.20220312061835.1429"><vh>MessagesHandlerMixIn.is_message_enabled</vh></v>
<v t="ekr.20220312061835.1430"><vh>MessagesHandlerMixIn.is_one_message_enabled</vh></v>
<v t="ekr.20220312061835.1431"><vh>MessagesHandlerMixIn.add_message</vh></v>
<v t="ekr.20220312061835.1432"><vh>MessagesHandlerMixIn.check_message_definition</vh></v>
<v t="ekr.20220312061835.1433"><vh>MessagesHandlerMixIn.add_one_message</vh></v>
<v t="ekr.20220312061835.1434"><vh>MessagesHandlerMixIn._get_checkers_infos</vh></v>
<v t="ekr.20220312061835.1435"><vh>MessagesHandlerMixIn.get_checkers_documentation</vh></v>
<v t="ekr.20220312061835.1436"><vh>MessagesHandlerMixIn.print_full_documentation</vh></v>
<v t="ekr.20220312061835.1437"><vh>MessagesHandlerMixIn._print_checker_doc</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1438"><vh>@@clean message_id_store.py</vh>
<v t="ekr.20220312061835.1439"><vh>class MessageIdStore</vh>
<v t="ekr.20220312061835.1440"><vh>MessageIdStore.__init__</vh></v>
<v t="ekr.20220312061835.1441"><vh>MessageIdStore.__len__</vh></v>
<v t="ekr.20220312061835.1442"><vh>MessageIdStore.__repr__</vh></v>
<v t="ekr.20220312061835.1443"><vh>MessageIdStore.get_symbol</vh></v>
<v t="ekr.20220312061835.1444"><vh>MessageIdStore.get_msgid</vh></v>
<v t="ekr.20220312061835.1445"><vh>MessageIdStore.register_message_definition</vh></v>
<v t="ekr.20220312061835.1446"><vh>MessageIdStore.add_msgid_and_symbol</vh></v>
<v t="ekr.20220312061835.1447"><vh>MessageIdStore.add_legacy_msgid_and_symbol</vh></v>
<v t="ekr.20220312061835.1448"><vh>MessageIdStore.check_msgid_and_symbol</vh></v>
<v t="ekr.20220312061835.1449"><vh>MessageIdStore._raise_duplicate_symbol</vh></v>
<v t="ekr.20220312061835.1450"><vh>MessageIdStore._raise_duplicate_msgid</vh></v>
<v t="ekr.20220312061835.1451"><vh>MessageIdStore.get_active_msgids</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1452"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220312061835.1453"><vh>@path pyreverse</vh>
<v t="ekr.20220312061835.1454"><vh>@@clean diadefslib.py</vh>
<v t="ekr.20220312061835.1455"><vh>class DiaDefGenerator</vh>
<v t="ekr.20220312061835.1456"><vh>DiaDefGenerator.__init__</vh></v>
<v t="ekr.20220312061835.1457"><vh>DiaDefGenerator.get_title</vh></v>
<v t="ekr.20220312061835.1458"><vh>DiaDefGenerator._set_option</vh></v>
<v t="ekr.20220312061835.1459"><vh>DiaDefGenerator._set_default_options</vh></v>
<v t="ekr.20220312061835.1460"><vh>DiaDefGenerator._get_levels</vh></v>
<v t="ekr.20220312061835.1461"><vh>DiaDefGenerator.show_node</vh></v>
<v t="ekr.20220312061835.1462"><vh>DiaDefGenerator.add_class</vh></v>
<v t="ekr.20220312061835.1463"><vh>DiaDefGenerator.get_ancestors</vh></v>
<v t="ekr.20220312061835.1464"><vh>DiaDefGenerator.get_associated</vh></v>
<v t="ekr.20220312061835.1465"><vh>DiaDefGenerator.extract_classes</vh></v>
</v>
<v t="ekr.20220312061835.1466"><vh>class DefaultDiadefGenerator</vh>
<v t="ekr.20220312061835.1467"><vh>DefaultDiadefGenerator.__init__</vh></v>
<v t="ekr.20220312061835.1468"><vh>DefaultDiadefGenerator.visit_project</vh></v>
<v t="ekr.20220312061835.1469"><vh>DefaultDiadefGenerator.leave_project</vh></v>
<v t="ekr.20220312061835.1470"><vh>DefaultDiadefGenerator.visit_module</vh></v>
<v t="ekr.20220312061835.1471"><vh>DefaultDiadefGenerator.visit_classdef</vh></v>
<v t="ekr.20220312061835.1472"><vh>DefaultDiadefGenerator.visit_importfrom</vh></v>
</v>
<v t="ekr.20220312061835.1473"><vh>class ClassDiadefGenerator</vh>
<v t="ekr.20220312061835.1474"><vh>ClassDiadefGenerator.__init__</vh></v>
<v t="ekr.20220312061835.1475"><vh>ClassDiadefGenerator.class_diagram</vh></v>
</v>
<v t="ekr.20220312061835.1476"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1477"><vh>class DiadefsHandler</vh>
<v t="ekr.20220312061835.1478"><vh>DiadefsHandler.__init__</vh></v>
<v t="ekr.20220312061835.1479"><vh>DiadefsHandler.get_diadefs</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1480"><vh>@@clean diagrams.py</vh>
<v t="ekr.20220312061835.1481"><vh>class Figure</vh></v>
<v t="ekr.20220312061835.1482"><vh>class Relationship</vh>
<v t="ekr.20220312061835.1483"><vh>Relationship.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1484"><vh>class DiagramEntity</vh></v>
<v t="ekr.20220312061835.1485"><vh>class PackageEntity</vh></v>
<v t="ekr.20220312061835.1486"><vh>class ClassEntity</vh></v>
<v t="ekr.20220312061835.1487"><vh>class ClassDiagram</vh>
<v t="ekr.20220312061835.1488"><vh>ClassDiagram.__init__</vh></v>
<v t="ekr.20220312061835.1489"><vh>ClassDiagram.get_relationships</vh></v>
<v t="ekr.20220312061835.1490"><vh>ClassDiagram.add_relationship</vh></v>
<v t="ekr.20220312061835.1491"><vh>ClassDiagram.get_relationship</vh></v>
<v t="ekr.20220312061835.1492"><vh>ClassDiagram.get_attrs</vh></v>
<v t="ekr.20220312061835.1493"><vh>ClassDiagram.get_methods</vh></v>
<v t="ekr.20220312061835.1494"><vh>ClassDiagram.add_object</vh></v>
<v t="ekr.20220312061835.1495"><vh>ClassDiagram.class_names</vh></v>
<v t="ekr.20220312061835.1496"><vh>ClassDiagram.nodes</vh></v>
<v t="ekr.20220312061835.1497"><vh>ClassDiagram.has_node</vh></v>
<v t="ekr.20220312061835.1498"><vh>ClassDiagram.object_from_node</vh></v>
<v t="ekr.20220312061835.1499"><vh>ClassDiagram.classes</vh></v>
<v t="ekr.20220312061835.1500"><vh>ClassDiagram.classe</vh></v>
<v t="ekr.20220312061835.1501"><vh>ClassDiagram.extract_relationships</vh></v>
</v>
<v t="ekr.20220312061835.1502"><vh>class PackageDiagram</vh>
<v t="ekr.20220312061835.1503"><vh>PackageDiagram.modules</vh></v>
<v t="ekr.20220312061835.1504"><vh>PackageDiagram.module</vh></v>
<v t="ekr.20220312061835.1505"><vh>PackageDiagram.get_module</vh></v>
<v t="ekr.20220312061835.1506"><vh>PackageDiagram.add_from_depend</vh></v>
<v t="ekr.20220312061835.1507"><vh>PackageDiagram.extract_relationships</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1508"><vh>@@clean dot_printer.py</vh>
<v t="ekr.20220312061835.1509"><vh>class DotPrinter</vh>
<v t="ekr.20220312061835.1510"><vh>DotPrinter.__init__</vh></v>
<v t="ekr.20220312061835.1511"><vh>DotPrinter._open_graph</vh></v>
<v t="ekr.20220312061835.1512"><vh>DotPrinter.emit_node</vh></v>
<v t="ekr.20220312061835.1513"><vh>DotPrinter._build_label_for_node</vh></v>
<v t="ekr.20220312061835.1514"><vh>DotPrinter.emit_edge</vh></v>
<v t="ekr.20220312061835.1515"><vh>DotPrinter.generate</vh></v>
<v t="ekr.20220312061835.1516"><vh>DotPrinter._close_graph</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1517"><vh>@@clean inspector.py</vh>
<v t="ekr.20220312061835.1518"><vh>_iface_hdlr</vh></v>
<v t="ekr.20220312061835.1519"><vh>_astroid_wrapper</vh></v>
<v t="ekr.20220312061835.1520"><vh>interfaces</vh></v>
<v t="ekr.20220312061835.1521"><vh>class IdGeneratorMixIn</vh>
<v t="ekr.20220312061835.1522"><vh>IdGeneratorMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1523"><vh>IdGeneratorMixIn.init_counter</vh></v>
<v t="ekr.20220312061835.1524"><vh>IdGeneratorMixIn.generate_id</vh></v>
</v>
<v t="ekr.20220312061835.1525"><vh>class Project</vh>
<v t="ekr.20220312061835.1526"><vh>Project.__init__</vh></v>
<v t="ekr.20220312061835.1527"><vh>Project.add_module</vh></v>
<v t="ekr.20220312061835.1528"><vh>Project.get_module</vh></v>
<v t="ekr.20220312061835.1529"><vh>Project.get_children</vh></v>
<v t="ekr.20220312061835.1530"><vh>Project.__repr__</vh></v>
</v>
<v t="ekr.20220312061835.1531"><vh>class Linker</vh>
<v t="ekr.20220312061835.1532"><vh>Linker.__init__</vh></v>
<v t="ekr.20220312061835.1533"><vh>Linker.visit_project</vh></v>
<v t="ekr.20220312061835.1534"><vh>Linker.visit_module</vh></v>
<v t="ekr.20220312061835.1535"><vh>Linker.visit_classdef</vh></v>
<v t="ekr.20220312061835.1536"><vh>Linker.visit_functiondef</vh></v>
<v t="ekr.20220312061835.1537"><vh>Linker....some declarations</vh></v>
<v t="ekr.20220312061835.1538"><vh>Linker.visit_assignname</vh></v>
<v t="ekr.20220312061835.1539"><vh>Linker.handle_assignattr_type</vh></v>
<v t="ekr.20220312061835.1540"><vh>Linker.visit_import</vh></v>
<v t="ekr.20220312061835.1541"><vh>Linker.visit_importfrom</vh></v>
<v t="ekr.20220312061835.1542"><vh>Linker.compute_module</vh></v>
<v t="ekr.20220312061835.1543"><vh>Linker._imported_module</vh></v>
</v>
<v t="ekr.20220312061835.1544"><vh>project_from_files</vh></v>
</v>
<v t="ekr.20220312061835.1545"><vh>@@clean main.py</vh>
<v t="ekr.20220312061835.1546"><vh>class Run</vh>
<v t="ekr.20220312061835.1547"><vh>Run.__init__</vh></v>
<v t="ekr.20220312061835.1548"><vh>Run.run</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1549"><vh>@@clean plantuml_printer.py</vh>
<v t="ekr.20220312061835.1550"><vh>class PlantUmlPrinter</vh>
<v t="ekr.20220312061835.1551"><vh>PlantUmlPrinter._open_graph</vh></v>
<v t="ekr.20220312061835.1552"><vh>PlantUmlPrinter.emit_node</vh></v>
<v t="ekr.20220312061835.1553"><vh>PlantUmlPrinter.emit_edge</vh></v>
<v t="ekr.20220312061835.1554"><vh>PlantUmlPrinter._close_graph</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1555"><vh>@@clean printer.py</vh>
<v t="ekr.20220312061835.1556"><vh>class NodeType</vh></v>
<v t="ekr.20220312061835.1557"><vh>class EdgeType</vh></v>
<v t="ekr.20220312061835.1558"><vh>class Layout</vh></v>
<v t="ekr.20220312061835.1559"><vh>class NodeProperties</vh></v>
<v t="ekr.20220312061835.1560"><vh>class Printer</vh>
<v t="ekr.20220312061835.1561"><vh>Printer.__init__</vh></v>
<v t="ekr.20220312061835.1562"><vh>Printer._inc_indent</vh></v>
<v t="ekr.20220312061835.1563"><vh>Printer._dec_indent</vh></v>
<v t="ekr.20220312061835.1564"><vh>Printer._open_graph</vh></v>
<v t="ekr.20220312061835.1565"><vh>Printer.emit</vh></v>
<v t="ekr.20220312061835.1566"><vh>Printer.emit_node</vh></v>
<v t="ekr.20220312061835.1567"><vh>Printer.emit_edge</vh></v>
<v t="ekr.20220312061835.1568"><vh>Printer._get_method_arguments</vh></v>
<v t="ekr.20220312061835.1569"><vh>Printer.generate</vh></v>
<v t="ekr.20220312061835.1570"><vh>Printer._close_graph</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1571"><vh>@@clean printer_factory.py</vh>
<v t="ekr.20220312061835.1572"><vh>get_printer_for_filetype</vh></v>
</v>
<v t="ekr.20220312061835.1573"><vh>@@clean utils.py</vh>
<v t="ekr.20220312061835.1574"><vh>get_default_options</vh></v>
<v t="ekr.20220312061835.1575"><vh>insert_default_options</vh></v>
<v t="ekr.20220312061835.1576"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1577"><vh>get_visibility</vh></v>
<v t="ekr.20220312061835.1578"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1579"><vh>is_abstract</vh></v>
<v t="ekr.20220312061835.1580"><vh>is_final</vh></v>
<v t="ekr.20220312061835.1581"><vh>is_interface</vh></v>
<v t="ekr.20220312061835.1582"><vh>is_exception</vh></v>
<v t="ekr.20220312061835.1583"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1584"><vh>class FilterMixIn</vh>
<v t="ekr.20220312061835.1585"><vh>FilterMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1586"><vh>FilterMixIn.show_attr</vh></v>
</v>
<v t="ekr.20220312061835.1587"><vh>class ASTWalker</vh>
<v t="ekr.20220312061835.1588"><vh>ASTWalker.__init__</vh></v>
<v t="ekr.20220312061835.1589"><vh>ASTWalker.walk</vh></v>
<v t="ekr.20220312061835.1590"><vh>ASTWalker.get_callbacks</vh></v>
<v t="ekr.20220312061835.1591"><vh>ASTWalker.visit</vh></v>
<v t="ekr.20220312061835.1592"><vh>ASTWalker.leave</vh></v>
</v>
<v t="ekr.20220312061835.1593"><vh>class LocalsVisitor</vh>
<v t="ekr.20220312061835.1594"><vh>LocalsVisitor.__init__</vh></v>
<v t="ekr.20220312061835.1595"><vh>LocalsVisitor.visit</vh></v>
</v>
<v t="ekr.20220312061835.1596"><vh>get_annotation_label</vh></v>
<v t="ekr.20220312061835.1597"><vh>get_annotation</vh></v>
<v t="ekr.20220312061835.1598"><vh>infer_node</vh></v>
<v t="ekr.20220312061835.1599"><vh>check_graphviz_availability</vh></v>
</v>
<v t="ekr.20220312061835.1600"><vh>@@clean vcg_printer.py</vh>
<v t="ekr.20220312061835.1601"><vh>class VCGPrinter</vh>
<v t="ekr.20220312061835.1602"><vh>VCGPrinter._open_graph</vh></v>
<v t="ekr.20220312061835.1603"><vh>VCGPrinter._close_graph</vh></v>
<v t="ekr.20220312061835.1604"><vh>VCGPrinter.emit_node</vh></v>
<v t="ekr.20220312061835.1605"><vh>VCGPrinter._build_label_for_node</vh></v>
<v t="ekr.20220312061835.1606"><vh>VCGPrinter.emit_edge</vh></v>
<v t="ekr.20220312061835.1607"><vh>VCGPrinter._write_attributes</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1608"><vh>@@clean writer.py</vh>
<v t="ekr.20220312061835.1609"><vh>class DiagramWriter</vh>
<v t="ekr.20220312061835.1610"><vh>DiagramWriter.__init__</vh></v>
<v t="ekr.20220312061835.1611"><vh>DiagramWriter.write</vh></v>
<v t="ekr.20220312061835.1612"><vh>DiagramWriter.write_packages</vh></v>
<v t="ekr.20220312061835.1613"><vh>DiagramWriter.write_classes</vh></v>
<v t="ekr.20220312061835.1614"><vh>DiagramWriter.set_printer</vh></v>
<v t="ekr.20220312061835.1615"><vh>DiagramWriter.get_package_properties</vh></v>
<v t="ekr.20220312061835.1616"><vh>DiagramWriter.get_class_properties</vh></v>
<v t="ekr.20220312061835.1617"><vh>DiagramWriter.get_shape_color</vh></v>
<v t="ekr.20220312061835.1618"><vh>DiagramWriter.save</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1619"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220312061835.1620"><vh>@path reporters</vh>
<v t="ekr.20220312061835.1621"><vh>@@clean base_reporter.py</vh>
<v t="ekr.20220312061835.1622"><vh>class BaseReporter</vh>
<v t="ekr.20220312061835.1623"><vh>BaseReporter.__init__</vh></v>
<v t="ekr.20220312061835.1624"><vh>BaseReporter.handle_message</vh></v>
<v t="ekr.20220312061835.1625"><vh>BaseReporter.set_output</vh></v>
<v t="ekr.20220312061835.1626"><vh>BaseReporter.writeln</vh></v>
<v t="ekr.20220312061835.1627"><vh>BaseReporter.display_reports</vh></v>
<v t="ekr.20220312061835.1628"><vh>BaseReporter._display</vh></v>
<v t="ekr.20220312061835.1629"><vh>BaseReporter.display_messages</vh></v>
<v t="ekr.20220312061835.1630"><vh>BaseReporter....some declarations</vh></v>
<v t="ekr.20220312061835.1631"><vh>BaseReporter.on_set_current_module</vh></v>
<v t="ekr.20220312061835.1632"><vh>BaseReporter.on_close</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1633"><vh>@@clean collecting_reporter.py</vh>
<v t="ekr.20220312061835.1634"><vh>class CollectingReporter</vh>
<v t="ekr.20220312061835.1635"><vh>CollectingReporter.__init__</vh></v>
<v t="ekr.20220312061835.1636"><vh>CollectingReporter.reset</vh></v>
<v t="ekr.20220312061835.1637"><vh>CollectingReporter._display</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1638"><vh>@@clean json_reporter.py</vh>
<v t="ekr.20220312061835.1639"><vh>class JSONReporter</vh>
<v t="ekr.20220312061835.1640"><vh>JSONReporter.display_messages</vh></v>
<v t="ekr.20220312061835.1641"><vh>JSONReporter.display_reports</vh></v>
<v t="ekr.20220312061835.1642"><vh>JSONReporter._display</vh></v>
</v>
<v t="ekr.20220312061835.1643"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1644"><vh>@@clean multi_reporter.py</vh>
<v t="ekr.20220312061835.1645"><vh>class MultiReporter</vh>
<v t="ekr.20220312061835.1646"><vh>MultiReporter.__init__</vh></v>
<v t="ekr.20220312061835.1647"><vh>MultiReporter.__del__</vh></v>
<v t="ekr.20220312061835.1648"><vh>MultiReporter.path_strip_prefix</vh></v>
<v t="ekr.20220312061835.1649"><vh>MultiReporter.linter</vh></v>
<v t="ekr.20220312061835.1650"><vh>MultiReporter.linter</vh></v>
<v t="ekr.20220312061835.1651"><vh>MultiReporter.handle_message</vh></v>
<v t="ekr.20220312061835.1652"><vh>MultiReporter.set_output</vh></v>
<v t="ekr.20220312061835.1653"><vh>MultiReporter.writeln</vh></v>
<v t="ekr.20220312061835.1654"><vh>MultiReporter.display_reports</vh></v>
<v t="ekr.20220312061835.1655"><vh>MultiReporter.display_messages</vh></v>
<v t="ekr.20220312061835.1656"><vh>MultiReporter.on_set_current_module</vh></v>
<v t="ekr.20220312061835.1657"><vh>MultiReporter.on_close</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1658"><vh>@@clean reports_handler_mix_in.py</vh>
<v t="ekr.20220312061835.1659"><vh>class ReportsHandlerMixIn</vh>
<v t="ekr.20220312061835.1660"><vh>ReportsHandlerMixIn.__init__</vh></v>
<v t="ekr.20220312061835.1661"><vh>ReportsHandlerMixIn.report_order</vh></v>
<v t="ekr.20220312061835.1662"><vh>ReportsHandlerMixIn.register_report</vh></v>
<v t="ekr.20220312061835.1663"><vh>ReportsHandlerMixIn.enable_report</vh></v>
<v t="ekr.20220312061835.1664"><vh>ReportsHandlerMixIn.disable_report</vh></v>
<v t="ekr.20220312061835.1665"><vh>ReportsHandlerMixIn.report_is_enabled</vh></v>
<v t="ekr.20220312061835.1666"><vh>ReportsHandlerMixIn.make_reports</vh></v>
<v t="ekr.20220312061835.1667"><vh>ReportsHandlerMixIn.add_stats</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1668"><vh>@@clean text.py</vh>
<v t="ekr.20220312061835.1669"><vh>_get_ansi_code</vh></v>
<v t="ekr.20220312061835.1670"><vh>colorize_ansi</vh></v>
<v t="ekr.20220312061835.1671"><vh>class TextReporter</vh>
<v t="ekr.20220312061835.1672"><vh>TextReporter.__init__</vh></v>
<v t="ekr.20220312061835.1673"><vh>TextReporter.on_set_current_module</vh></v>
<v t="ekr.20220312061835.1674"><vh>TextReporter.write_message</vh></v>
<v t="ekr.20220312061835.1675"><vh>TextReporter.handle_message</vh></v>
<v t="ekr.20220312061835.1676"><vh>TextReporter._display</vh></v>
</v>
<v t="ekr.20220312061835.1677"><vh>class ParseableTextReporter</vh>
<v t="ekr.20220312061835.1678"><vh>ParseableTextReporter.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1679"><vh>class VSTextReporter</vh></v>
<v t="ekr.20220312061835.1680"><vh>class ColorizedTextReporter</vh>
<v t="ekr.20220312061835.1681"><vh>ColorizedTextReporter.__init__</vh></v>
<v t="ekr.20220312061835.1682"><vh>ColorizedTextReporter._get_decoration</vh></v>
<v t="ekr.20220312061835.1683"><vh>ColorizedTextReporter.handle_message</vh></v>
</v>
<v t="ekr.20220312061835.1684"><vh>register</vh></v>
</v>
<v t="ekr.20220312061835.1685"><vh>@@clean __init__.py</vh>
<v t="ekr.20220312061835.1686"><vh>initialize</vh></v>
</v>
<v t="ekr.20220312061835.1687"><vh>@path ureports</vh>
<v t="ekr.20220312061835.1688"><vh>@@clean base_writer.py</vh>
<v t="ekr.20220312061835.1689"><vh>class BaseWriter</vh>
<v t="ekr.20220312061835.1690"><vh>BaseWriter.format</vh></v>
<v t="ekr.20220312061835.1691"><vh>BaseWriter.format_children</vh></v>
<v t="ekr.20220312061835.1692"><vh>BaseWriter.writeln</vh></v>
<v t="ekr.20220312061835.1693"><vh>BaseWriter.write</vh></v>
<v t="ekr.20220312061835.1694"><vh>BaseWriter.begin_format</vh></v>
<v t="ekr.20220312061835.1695"><vh>BaseWriter.end_format</vh></v>
<v t="ekr.20220312061835.1696"><vh>BaseWriter.get_table_content</vh></v>
<v t="ekr.20220312061835.1697"><vh>BaseWriter.compute_content</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1698"><vh>@@clean nodes.py</vh>
<v t="ekr.20220312061835.1699"><vh>class VNode</vh>
<v t="ekr.20220312061835.1700"><vh>VNode.__init__</vh></v>
<v t="ekr.20220312061835.1701"><vh>VNode.__iter__</vh></v>
<v t="ekr.20220312061835.1702"><vh>VNode.accept</vh></v>
<v t="ekr.20220312061835.1703"><vh>VNode.leave</vh></v>
</v>
<v t="ekr.20220312061835.1704"><vh>class BaseLayout</vh>
<v t="ekr.20220312061835.1705"><vh>BaseLayout.__init__</vh></v>
<v t="ekr.20220312061835.1706"><vh>BaseLayout.append</vh></v>
<v t="ekr.20220312061835.1707"><vh>BaseLayout.insert</vh></v>
<v t="ekr.20220312061835.1708"><vh>BaseLayout.parents</vh></v>
<v t="ekr.20220312061835.1709"><vh>BaseLayout.add_text</vh></v>
</v>
<v t="ekr.20220312061835.1710"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1711"><vh>class Text</vh>
<v t="ekr.20220312061835.1712"><vh>Text.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1713"><vh>class VerbatimText</vh></v>
<v t="ekr.20220312061835.1714"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1715"><vh>class Section</vh>
<v t="ekr.20220312061835.1716"><vh>Section.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1717"><vh>class EvaluationSection</vh>
<v t="ekr.20220312061835.1718"><vh>EvaluationSection.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1719"><vh>class Title</vh></v>
<v t="ekr.20220312061835.1720"><vh>class Paragraph</vh></v>
<v t="ekr.20220312061835.1721"><vh>class Table</vh>
<v t="ekr.20220312061835.1722"><vh>Table.__init__</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1723"><vh>@@clean text_writer.py</vh>
<v t="ekr.20220312061835.1724"><vh>class TextWriter</vh>
<v t="ekr.20220312061835.1725"><vh>TextWriter.__init__</vh></v>
<v t="ekr.20220312061835.1726"><vh>TextWriter.visit_section</vh></v>
<v t="ekr.20220312061835.1727"><vh>TextWriter.visit_evaluationsection</vh></v>
<v t="ekr.20220312061835.1728"><vh>TextWriter.visit_title</vh></v>
<v t="ekr.20220312061835.1729"><vh>TextWriter.visit_paragraph</vh></v>
<v t="ekr.20220312061835.1730"><vh>TextWriter.visit_table</vh></v>
<v t="ekr.20220312061835.1731"><vh>TextWriter.default_table</vh></v>
<v t="ekr.20220312061835.1732"><vh>TextWriter.visit_verbatimtext</vh></v>
<v t="ekr.20220312061835.1733"><vh>TextWriter.visit_text</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1734"><vh>@@clean __init__.py</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1735"><vh>@path testutils</vh>
<v t="ekr.20220312061835.1736"><vh>@@clean checker_test_case.py</vh>
<v t="ekr.20220312061835.1737"><vh>class CheckerTestCase</vh>
<v t="ekr.20220312061835.1738"><vh>CheckerTestCase.setup_method</vh></v>
<v t="ekr.20220312061835.1739"><vh>CheckerTestCase.assertNoMessages</vh></v>
<v t="ekr.20220312061835.1740"><vh>CheckerTestCase.assertAddsMessages</vh></v>
<v t="ekr.20220312061835.1741"><vh>CheckerTestCase.walk</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1742"><vh>@@clean constants.py</vh></v>
<v t="ekr.20220312061835.1743"><vh>@@clean decorator.py</vh>
<v t="ekr.20220312061835.1744"><vh>set_config</vh>
<v t="ekr.20220312061835.1745"><vh>_wrapper</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1746"><vh>@@clean functional_test_file.py</vh>
<v t="ekr.20220312061835.1747"><vh>parse_python_version</vh></v>
<v t="ekr.20220312061835.1748"><vh>class NoFileError</vh></v>
<v t="ekr.20220312061835.1749"><vh>class FunctionalTestFile</vh>
<v t="ekr.20220312061835.1750"><vh>FunctionalTestFile.__init__</vh></v>
<v t="ekr.20220312061835.1751"><vh>FunctionalTestFile.__repr__</vh></v>
<v t="ekr.20220312061835.1752"><vh>FunctionalTestFile._parse_options</vh></v>
<v t="ekr.20220312061835.1753"><vh>FunctionalTestFile.option_file</vh></v>
<v t="ekr.20220312061835.1754"><vh>FunctionalTestFile.module</vh></v>
<v t="ekr.20220312061835.1755"><vh>FunctionalTestFile.expected_output</vh></v>
<v t="ekr.20220312061835.1756"><vh>FunctionalTestFile.source</vh></v>
<v t="ekr.20220312061835.1757"><vh>FunctionalTestFile._file_type</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1758"><vh>@@clean get_test_info.py</vh>
<v t="ekr.20220312061835.1759"><vh>_get_tests_info</vh></v>
</v>
<v t="ekr.20220312061835.1760"><vh>@@clean global_test_linter.py</vh>
<v t="ekr.20220312061835.1761"><vh>create_test_linter</vh></v>
</v>
<v t="ekr.20220312061835.1762"><vh>@@clean lint_module_test.py</vh>
<v t="ekr.20220312061835.1763"><vh>class LintModuleTest</vh>
<v t="ekr.20220312061835.1764"><vh>LintModuleTest.__init__</vh></v>
<v t="ekr.20220312061835.1765"><vh>LintModuleTest.setUp</vh></v>
<v t="ekr.20220312061835.1766"><vh>LintModuleTest.runTest</vh></v>
<v t="ekr.20220312061835.1767"><vh>LintModuleTest._should_be_skipped_due_to_version</vh></v>
<v t="ekr.20220312061835.1768"><vh>LintModuleTest.__str__</vh></v>
<v t="ekr.20220312061835.1769"><vh>LintModuleTest.get_expected_messages</vh></v>
<v t="ekr.20220312061835.1770"><vh>LintModuleTest.multiset_difference</vh></v>
<v t="ekr.20220312061835.1771"><vh>LintModuleTest._open_expected_file</vh></v>
<v t="ekr.20220312061835.1772"><vh>LintModuleTest._open_source_file</vh></v>
<v t="ekr.20220312061835.1773"><vh>LintModuleTest._get_expected</vh></v>
<v t="ekr.20220312061835.1774"><vh>LintModuleTest._get_actual</vh></v>
<v t="ekr.20220312061835.1775"><vh>LintModuleTest._runTest</vh></v>
<v t="ekr.20220312061835.1776"><vh>LintModuleTest.error_msg_for_unequal_messages</vh></v>
<v t="ekr.20220312061835.1777"><vh>LintModuleTest.error_msg_for_unequal_output</vh></v>
<v t="ekr.20220312061835.1778"><vh>LintModuleTest._check_output_text</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1779"><vh>@@clean output_line.py</vh>
<v t="ekr.20220312061835.1780"><vh>class Message</vh>
<v t="ekr.20220312061835.1781"><vh>Message.__new__</vh></v>
<v t="ekr.20220312061835.1782"><vh>Message.__eq__</vh></v>
</v>
<v t="ekr.20220312061835.1783"><vh>class MalformedOutputLineException</vh>
<v t="ekr.20220312061835.1784"><vh>MalformedOutputLineException.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1785"><vh>class OutputLine</vh>
<v t="ekr.20220312061835.1786"><vh>OutputLine.from_msg</vh></v>
<v t="ekr.20220312061835.1787"><vh>OutputLine.get_column</vh></v>
<v t="ekr.20220312061835.1788"><vh>OutputLine.from_csv</vh></v>
<v t="ekr.20220312061835.1789"><vh>OutputLine.to_csv</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1790"><vh>@@clean pyreverse.py</vh>
<v t="ekr.20220312061835.1791"><vh>class PyreverseConfig</vh>
<v t="ekr.20220312061835.1792"><vh>PyreverseConfig.__init__</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1793"><vh>@@clean reporter_for_tests.py</vh>
<v t="ekr.20220312061835.1794"><vh>class GenericTestReporter</vh>
<v t="ekr.20220312061835.1795"><vh>GenericTestReporter.__init__</vh></v>
<v t="ekr.20220312061835.1796"><vh>GenericTestReporter.reset</vh></v>
<v t="ekr.20220312061835.1797"><vh>GenericTestReporter.handle_message</vh></v>
<v t="ekr.20220312061835.1798"><vh>GenericTestReporter.finalize</vh></v>
<v t="ekr.20220312061835.1799"><vh>GenericTestReporter.on_set_current_module</vh></v>
<v t="ekr.20220312061835.1800"><vh>GenericTestReporter....some declarations</vh></v>
<v t="ekr.20220312061835.1801"><vh>GenericTestReporter.display_reports</vh></v>
<v t="ekr.20220312061835.1802"><vh>GenericTestReporter._display</vh></v>
</v>
<v t="ekr.20220312061835.1803"><vh>class MinimalTestReporter</vh></v>
<v t="ekr.20220312061835.1804"><vh>class FunctionalTestReporter</vh></v>
</v>
<v t="ekr.20220312061835.1805"><vh>@@clean tokenize_str.py</vh></v>
<v t="ekr.20220312061835.1806"><vh>@@clean unittest_linter.py</vh>
<v t="ekr.20220312061835.1807"><vh>class UnittestLinter</vh>
<v t="ekr.20220312061835.1808"><vh>UnittestLinter.__init__</vh></v>
<v t="ekr.20220312061835.1809"><vh>UnittestLinter.release_messages</vh></v>
<v t="ekr.20220312061835.1810"><vh>UnittestLinter.add_message</vh></v>
<v t="ekr.20220312061835.1811"><vh>UnittestLinter.is_message_enabled</vh></v>
<v t="ekr.20220312061835.1812"><vh>UnittestLinter.add_stats</vh></v>
<v t="ekr.20220312061835.1813"><vh>UnittestLinter.options_providers</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1814"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220312061835.1815"><vh>@path utils</vh>
<v t="ekr.20220312061835.1816"><vh>@@clean ast_walker.py</vh>
<v t="ekr.20220312061835.1817"><vh>class ASTWalker</vh>
<v t="ekr.20220312061835.1818"><vh>ASTWalker.__init__</vh></v>
<v t="ekr.20220312061835.1819"><vh>ASTWalker._is_method_enabled</vh></v>
<v t="ekr.20220312061835.1820"><vh>ASTWalker.add_checker</vh></v>
<v t="ekr.20220312061835.1821"><vh>ASTWalker.walk</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1822"><vh>@@clean file_state.py</vh>
<v t="ekr.20220312061835.1823"><vh>class FileState</vh>
<v t="ekr.20220312061835.1824"><vh>FileState.__init__</vh></v>
<v t="ekr.20220312061835.1825"><vh>FileState.collect_block_lines</vh></v>
<v t="ekr.20220312061835.1826"><vh>FileState._collect_block_lines</vh></v>
<v t="ekr.20220312061835.1827"><vh>FileState.set_msg_status</vh></v>
<v t="ekr.20220312061835.1828"><vh>FileState.handle_ignored_message</vh></v>
<v t="ekr.20220312061835.1829"><vh>FileState.iter_spurious_suppression_messages</vh></v>
<v t="ekr.20220312061835.1830"><vh>FileState.get_effective_max_line_number</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1831"><vh>@@clean pragma_parser.py</vh>
<v t="ekr.20220312061835.1832"><vh>emit_pragma_representer</vh></v>
<v t="ekr.20220312061835.1833"><vh>class PragmaParserError</vh>
<v t="ekr.20220312061835.1834"><vh>PragmaParserError.__init__</vh></v>
</v>
<v t="ekr.20220312061835.1835"><vh>class UnRecognizedOptionError</vh></v>
<v t="ekr.20220312061835.1836"><vh>class InvalidPragmaError</vh></v>
<v t="ekr.20220312061835.1837"><vh>parse_pragma</vh></v>
</v>
<v t="ekr.20220312061835.1838"><vh>@@clean utils.py</vh>
<v t="ekr.20220312061835.1839"><vh>normalize_text</vh></v>
<v t="ekr.20220312061835.1840"><vh>...some declarations</vh></v>
<v t="ekr.20220312061835.1841"><vh>cmp</vh></v>
<v t="ekr.20220312061835.1842"><vh>diff_string</vh></v>
<v t="ekr.20220312061835.1843"><vh>get_module_and_frameid</vh></v>
<v t="ekr.20220312061835.1844"><vh>get_rst_title</vh></v>
<v t="ekr.20220312061835.1845"><vh>get_rst_section</vh></v>
<v t="ekr.20220312061835.1846"><vh>safe_decode</vh></v>
<v t="ekr.20220312061835.1847"><vh>decoding_stream</vh></v>
<v t="ekr.20220312061835.1848"><vh>tokenize_module</vh></v>
<v t="ekr.20220312061835.1849"><vh>register_plugins</vh></v>
<v t="ekr.20220312061835.1850"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1851"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1852"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1853"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1854"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1855"><vh>get_global_option</vh></v>
<v t="ekr.20220312061835.1856"><vh>deprecated_option</vh>
<v t="ekr.20220312061835.1857"><vh>_warn_deprecated</vh></v>
</v>
<v t="ekr.20220312061835.1858"><vh>_splitstrip</vh></v>
<v t="ekr.20220312061835.1859"><vh>_unquote</vh></v>
<v t="ekr.20220312061835.1860"><vh>_check_csv</vh></v>
<v t="ekr.20220312061835.1861"><vh>_comment</vh></v>
<v t="ekr.20220312061835.1862"><vh>_format_option_value</vh></v>
<v t="ekr.20220312061835.1863"><vh>format_section</vh></v>
<v t="ekr.20220312061835.1864"><vh>_ini_format</vh></v>
<v t="ekr.20220312061835.1865"><vh>class IsortDriver</vh>
<v t="ekr.20220312061835.1866"><vh>IsortDriver.__init__</vh></v>
<v t="ekr.20220312061835.1867"><vh>IsortDriver.place_module</vh></v>
</v>
</v>
<v t="ekr.20220312061835.1868"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20220404133153.1"><vh>--- Recent</vh></v>
<v t="ekr.20220312061835.1817"></v>
<v t="ekr.20220404130423.1"><vh>Found 43: yield</vh>
<v t="ekr.20220404130439.1"><vh>--- 18: not real yield statement</vh>
<v t="ekr.20220312061835.385"></v>
<v t="ekr.20220312061835.917"></v>
<v t="ekr.20220312061835.60"></v>
<v t="ekr.20220312061835.139"></v>
<v t="ekr.20220312061835.121"></v>
<v t="ekr.20220312061835.107"></v>
<v t="ekr.20220312061835.96"></v>
<v t="ekr.20220312061835.97"></v>
<v t="ekr.20220312061835.58"></v>
<v t="ekr.20220312061835.85"></v>
<v t="ekr.20220312061835.1249"></v>
<v t="ekr.20220312061835.1146"></v>
<v t="ekr.20220312061835.696"></v>
<v t="ekr.20220312061835.329"></v>
<v t="ekr.20220312061835.1154"></v>
<v t="ekr.20220312061835.399"></v>
<v t="ekr.20220312061835.880"></v>
<v t="ekr.20220312061835.867"></v>
</v>
<v t="ekr.20220404131315.1"><vh>--- 16: yields not related to type inference</vh>
<v t="ekr.20220312061835.1063"></v>
<v t="ekr.20220312061835.1697"></v>
<v t="ekr.20220312061835.1740"></v>
<v t="ekr.20220312061835.1739"></v>
<v t="ekr.20220312061835.736"></v>
<v t="ekr.20220312061835.1829"></v>
<v t="ekr.20220312061835.1018"></v>
<v t="ekr.20220312061835.1389"></v>
<v t="ekr.20220312061835.1418"></v>
<v t="ekr.20220312061835.1060"></v>
<v t="ekr.20220312061835.1059"></v>
<v t="ekr.20220312061835.1837"></v>
<v t="ekr.20220312061835.1349"></v>
<v t="ekr.20220312061835.1346"></v>
<v t="ekr.20220312061835.533"></v>
<v t="ekr.20220312061835.534"></v>
</v>
<v t="ekr.20220404130629.1"><vh>---  9: yields for type inference</vh>
<v t="ekr.20220312061835.354"></v>
<v t="ekr.20220312061835.644"></v>
<v t="ekr.20220312061835.643"></v>
<v t="ekr.20220312061835.122"></v>
<v t="ekr.20220312061835.926"></v>
<v t="ekr.20220312061835.1463"></v>
<v t="ekr.20220312061835.1464"></v>
<v t="ekr.20220312061835.715"></v>
<v t="ekr.20220312061835.1520"></v>
</v>
</v>
<v t="ekr.20220404133051.1"><vh>Found 2:_flatten_container</vh>
<v t="ekr.20220312061835.644"></v>
<v t="ekr.20220312061835.683"></v>
</v>
<v t="ekr.20220404130629.1"></v>
<v t="ekr.20220404133238.1"><vh>Found 2:get_ancestors</vh>
<v t="ekr.20220312061835.1465"></v>
<v t="ekr.20220312061835.1463"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20220312061835.1"></t>
<t tx="ekr.20220312061835.10">class InvalidMessageError(Exception):
    """raised when a message creation, registration or addition is rejected"""


</t>
<t tx="ekr.20220312061835.100">@utils.check_messages("useless-else-on-loop")
def visit_for(self, node: nodes.For) -&gt; None:
    self._check_else_on_loop(node)

</t>
<t tx="ekr.20220312061835.1000">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    self._return_nodes[node.name] = list(
        node.nodes_of_class(nodes.Return, skip_klass=nodes.FunctionDef)
    )

</t>
<t tx="ekr.20220312061835.1001">def _check_consistent_returns(self, node: nodes.FunctionDef) -&gt; None:
    """Check that all return statements inside a function are consistent.

    Return statements are consistent if:
        - all returns are explicit and if there is no implicit return;
        - all returns are empty and if there is, possibly, an implicit return.

    Args:
        node (nodes.FunctionDef): the function holding the return statements.

    """
    # explicit return statements are those with a not None value
    explicit_returns = [
        _node for _node in self._return_nodes[node.name] if _node.value is not None
    ]
    if not explicit_returns:
        return
    if len(explicit_returns) == len(
        self._return_nodes[node.name]
    ) and self._is_node_return_ended(node):
        return
    self.add_message("inconsistent-return-statements", node=node)

</t>
<t tx="ekr.20220312061835.1002">def _is_if_node_return_ended(self, node: nodes.If) -&gt; bool:
    """Check if the If node ends with an explicit return statement.

    Args:
        node (nodes.If): If node to be checked.

    Returns:
        bool: True if the node ends with an explicit statement, False otherwise.
    """
    # Do not check if inner function definition are return ended.
    is_if_returning = any(
        self._is_node_return_ended(_ifn)
        for _ifn in node.body
        if not isinstance(_ifn, nodes.FunctionDef)
    )
    if not node.orelse:
        # If there is not orelse part then the if statement is returning if :
        # - there is at least one return statement in its siblings;
        # - the if body is itself returning.
        if not self._has_return_in_siblings(node):
            return False
        return is_if_returning
    # If there is an orelse part then both if body and orelse part should return.
    is_orelse_returning = any(
        self._is_node_return_ended(_ore)
        for _ore in node.orelse
        if not isinstance(_ore, nodes.FunctionDef)
    )
    return is_if_returning and is_orelse_returning

</t>
<t tx="ekr.20220312061835.1003">def _is_raise_node_return_ended(self, node: nodes.Raise) -&gt; bool:
    """Check if the Raise node ends with an explicit return statement.

    Args:
        node (nodes.Raise): Raise node to be checked.

    Returns:
        bool: True if the node ends with an explicit statement, False otherwise.
    """
    # a Raise statement doesn't need to end with a return statement
    # but if the exception raised is handled, then the handler has to
    # ends with a return statement
    if not node.exc:
        # Ignore bare raises
        return True
    if not utils.is_node_inside_try_except(node):
        # If the raise statement is not inside a try/except statement
        # then the exception is raised and cannot be caught. No need
        # to infer it.
        return True
    exc = utils.safe_infer(node.exc)
    if exc is None or exc is astroid.Uninferable or not hasattr(exc, "pytype"):
        return False
    exc_name = exc.pytype().split(".")[-1]
    handlers = utils.get_exception_handlers(node, exc_name)
    handlers = list(handlers) if handlers is not None else []
    if handlers:
        # among all the handlers handling the exception at least one
        # must end with a return statement
        return any(self._is_node_return_ended(_handler) for _handler in handlers)
    # if no handlers handle the exception then it's ok
    return True

</t>
<t tx="ekr.20220312061835.1004">def _is_node_return_ended(self, node: nodes.NodeNG) -&gt; bool:
    """Check if the node ends with an explicit return statement.

    Args:
        node (nodes.NodeNG): node to be checked.

    Returns:
        bool: True if the node ends with an explicit statement, False otherwise.

    """
    # Recursion base case
    if isinstance(node, nodes.Return):
        return True
    if isinstance(node, nodes.Call):
        try:
            funcdef_node = node.func.inferred()[0]
            if self._is_function_def_never_returning(funcdef_node):
                return True
        except astroid.InferenceError:
            pass
    # Avoid the check inside while loop as we don't know
    # if they will be completed
    if isinstance(node, nodes.While):
        return True
    if isinstance(node, nodes.Raise):
        return self._is_raise_node_return_ended(node)
    if isinstance(node, nodes.If):
        return self._is_if_node_return_ended(node)
    if isinstance(node, nodes.TryExcept):
        handlers = {
            _child
            for _child in node.get_children()
            if isinstance(_child, nodes.ExceptHandler)
        }
        all_but_handler = set(node.get_children()) - handlers
        return any(
            self._is_node_return_ended(_child) for _child in all_but_handler
        ) and all(self._is_node_return_ended(_child) for _child in handlers)
    if (
        isinstance(node, nodes.Assert)
        and isinstance(node.test, nodes.Const)
        and not node.test.value
    ):
        # consider assert False as a return node
        return True
    # recurses on the children of the node
    return any(self._is_node_return_ended(_child) for _child in node.get_children())

</t>
<t tx="ekr.20220312061835.1005">@staticmethod
def _has_return_in_siblings(node: nodes.NodeNG) -&gt; bool:
    """
    Returns True if there is at least one return in the node's siblings
    """
    next_sibling = node.next_sibling()
    while next_sibling:
        if isinstance(next_sibling, nodes.Return):
            return True
        next_sibling = next_sibling.next_sibling()
    return False

</t>
<t tx="ekr.20220312061835.1006">def _is_function_def_never_returning(self, node: nodes.FunctionDef) -&gt; bool:
    """Return True if the function never returns. False otherwise.

    Args:
        node (nodes.FunctionDef): function definition node to be analyzed.

    Returns:
        bool: True if the function never returns, False otherwise.
    """
    if isinstance(node, nodes.FunctionDef) and node.returns:
        return (
            isinstance(node.returns, nodes.Attribute)
            and node.returns.attrname == "NoReturn"
            or isinstance(node.returns, nodes.Name)
            and node.returns.name == "NoReturn"
        )
    try:
        return node.qname() in self._never_returning_functions
    except TypeError:
        return False

</t>
<t tx="ekr.20220312061835.1007">def _check_return_at_the_end(self, node):
    """Check for presence of a *single* return statement at the end of a
    function. "return" or "return None" are useless because None is the
    default return type if they are missing.

    NOTE: produces a message only if there is a single return statement
    in the function body. Otherwise _check_consistent_returns() is called!
    Per its implementation and PEP8 we can have a "return None" at the end
    of the function body if there are other return statements before that!
    """
    if len(self._return_nodes[node.name]) &gt; 1:
        return
    if len(node.body) &lt;= 1:
        return

    last = node.body[-1]
    if isinstance(last, nodes.Return):
        # e.g. "return"
        if last.value is None:
            self.add_message("useless-return", node=node)
        # return None"
        elif isinstance(last.value, nodes.Const) and (last.value.value is None):
            self.add_message("useless-return", node=node)

</t>
<t tx="ekr.20220312061835.1008">def _check_unnecessary_dict_index_lookup(
    self, node: Union[nodes.For, nodes.Comprehension]
) -&gt; None:
    """Add message when accessing dict values by index lookup."""
    # Verify that we have a .items() call and
    # that the object which is iterated is used as a subscript in the
    # body of the for.
    # Is it a proper items call?
    if (
        isinstance(node.iter, nodes.Call)
        and isinstance(node.iter.func, nodes.Attribute)
        and node.iter.func.attrname == "items"
    ):
        inferred = utils.safe_infer(node.iter.func)
        if not isinstance(inferred, astroid.BoundMethod):
            return
        iterating_object_name = node.iter.func.expr.as_string()

        # Verify that the body of the for loop uses a subscript
        # with the object that was iterated. This uses some heuristics
        # in order to make sure that the same object is used in the
        # for body.

        children = (
            node.body if isinstance(node, nodes.For) else node.parent.get_children()
        )
        for child in children:
            for subscript in child.nodes_of_class(nodes.Subscript):
                if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):
                    continue

                value = subscript.slice

                if isinstance(node, nodes.For) and (
                    isinstance(subscript.parent, nodes.Assign)
                    and subscript in subscript.parent.targets
                    or isinstance(subscript.parent, nodes.AugAssign)
                    and subscript == subscript.parent.target
                ):
                    # Ignore this subscript if it is the target of an assignment
                    # Early termination; after reassignment dict index lookup will be necessary
                    return

                # Case where .items is assigned to k,v (i.e., for k, v in d.items())
                if isinstance(value, nodes.Name):
                    if (
                        not isinstance(node.target, nodes.Tuple)
                        or value.name != node.target.elts[0].name
                        or iterating_object_name != subscript.value.as_string()
                    ):
                        continue

                    if (
                        isinstance(node, nodes.For)
                        and value.lookup(value.name)[1][-1].lineno &gt; node.lineno
                    ):
                        # Ignore this subscript if it has been redefined after
                        # the for loop. This checks for the line number using .lookup()
                        # to get the line number where the iterating object was last
                        # defined and compare that to the for loop's line number
                        continue

                    self.add_message(
                        "unnecessary-dict-index-lookup",
                        node=subscript,
                        args=(node.target.elts[1].as_string()),
                    )

                # Case where .items is assigned to single var (i.e., for item in d.items())
                elif isinstance(value, nodes.Subscript):
                    if (
                        not isinstance(node.target, nodes.AssignName)
                        or node.target.name != value.value.name
                        or iterating_object_name != subscript.value.as_string()
                    ):
                        continue

                    if (
                        isinstance(node, nodes.For)
                        and value.value.lookup(value.value.name)[1][-1].lineno
                        &gt; node.lineno
                    ):
                        # Ignore this subscript if it has been redefined after
                        # the for loop. This checks for the line number using .lookup()
                        # to get the line number where the iterating object was last
                        # defined and compare that to the for loop's line number
                        continue

                    # check if subscripted by 0 (key)
                    inferred = utils.safe_infer(value.slice)
                    if not isinstance(inferred, nodes.Const) or inferred.value != 0:
                        continue
                    self.add_message(
                        "unnecessary-dict-index-lookup",
                        node=subscript,
                        args=("1".join(value.as_string().rsplit("0", maxsplit=1)),),
                    )
</t>
<t tx="ekr.20220312061835.1009">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/refactoring/
@language python
@tabwidth -4
# Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017-2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2017 Hugo &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2017 ukasz Sznuk &lt;ls@rdprojekt.pl&gt;
# Copyright (c) 2017 Alex Hearn &lt;alex.d.hearn@gmail.com&gt;
# Copyright (c) 2017 Antonio Ossa &lt;aaossa@uc.cl&gt;
# Copyright (c) 2018-2019 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Justin Li &lt;justinnhli@gmail.com&gt;
# Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Ben James &lt;benjames1999@hotmail.co.uk&gt;
# Copyright (c) 2018 Tomer Chachamu &lt;tomer.chachamu@gmail.com&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018 Konstantin Manna &lt;Konstantin@Manna.uno&gt;
# Copyright (c) 2018 Konstantin &lt;Github@pheanex.de&gt;
# Copyright (c) 2018 Matej Maruk &lt;marusak.matej@gmail.com&gt;
# Copyright (c) 2018 Mr. Senko &lt;atodorov@mrsenko.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Rmi Cardona &lt;remi.cardona@polyconseil.fr&gt;
# Copyright (c) 2019 Robert Schweizer &lt;robert_schweizer@gmx.de&gt;
# Copyright (c) 2019 PHeanEX &lt;github@pheanex.de&gt;
# Copyright (c) 2019 Paul Renvoise &lt;PaulRenvoise@users.noreply.github.com&gt;
# Copyright (c) 2020 ethan-leba &lt;ethanleba5@gmail.com&gt;
# Copyright (c) 2020 lrjball &lt;50599110+lrjball@users.noreply.github.com&gt;
# Copyright (c) 2020 Yang Yang &lt;y4n9squared@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Looks for code which can be refactored."""


from pylint.checkers.refactoring.len_checker import LenChecker
from pylint.checkers.refactoring.not_checker import NotChecker
from pylint.checkers.refactoring.recommendation_checker import RecommendationChecker
from pylint.checkers.refactoring.refactoring_checker import RefactoringChecker

__all__ = ["LenChecker", "NotChecker", "RecommendationChecker", "RefactoringChecker"]


@others
</t>
<t tx="ekr.20220312061835.101">@utils.check_messages("useless-else-on-loop")
def visit_while(self, node: nodes.While) -&gt; None:
    self._check_else_on_loop(node)

</t>
<t tx="ekr.20220312061835.1010">def register(linter):
    """Required method to auto register this checker."""
    linter.register_checker(RefactoringChecker(linter))
    linter.register_checker(NotChecker(linter))
    linter.register_checker(RecommendationChecker(linter))
    linter.register_checker(LenChecker(linter))
</t>
<t tx="ekr.20220312061835.1011"></t>
<t tx="ekr.20220312061835.1012">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from pylint.config.option_manager_mixin import OptionsManagerMixIn
from pylint.config.options_provider_mixin import OptionsProviderMixIn


@others
</t>
<t tx="ekr.20220312061835.1013">class ConfigurationMixIn(OptionsManagerMixIn, OptionsProviderMixIn):
    """basic mixin for simple configurations which don't need the
    manager / providers model"""

    @others
</t>
<t tx="ekr.20220312061835.1014">def __init__(self, *args, **kwargs):
    if not args:
        kwargs.setdefault("usage", "")
    OptionsManagerMixIn.__init__(self, *args, **kwargs)
    OptionsProviderMixIn.__init__(self)
    if not getattr(self, "option_groups", None):
        self.option_groups = []
        for _, optdict in self.options:
            try:
                gdef = (optdict["group"].upper(), "")
            except KeyError:
                continue
            if gdef not in self.option_groups:
                self.option_groups.append(gdef)
    self.register_options_provider(self, own_group=False)
</t>
<t tx="ekr.20220312061835.1015">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import configparser
import os

import toml
from toml.decoder import TomlDecodeError


@others
</t>
<t tx="ekr.20220312061835.1016">def _toml_has_config(path):
    with open(path, encoding="utf-8") as toml_handle:
        try:
            content = toml.load(toml_handle)
        except TomlDecodeError as error:
            print(f"Failed to load '{path}': {error}")
            return False

        try:
            content["tool"]["pylint"]
        except KeyError:
            return False

    return True


</t>
<t tx="ekr.20220312061835.1017">def _cfg_has_config(path):
    parser = configparser.ConfigParser()
    parser.read(path, encoding="utf-8")
    return any(section.startswith("pylint.") for section in parser.sections())


</t>
<t tx="ekr.20220312061835.1018">def find_default_config_files():
    """Find all possible config files."""
    rc_names = ("pylintrc", ".pylintrc")
    config_names = rc_names + ("pyproject.toml", "setup.cfg")
    for config_name in config_names:
        if os.path.isfile(config_name):
            if config_name.endswith(".toml") and not _toml_has_config(config_name):
                continue
            if config_name.endswith(".cfg") and not _cfg_has_config(config_name):
                continue

            yield os.path.abspath(config_name)

    if os.path.isfile("__init__.py"):
        curdir = os.path.abspath(os.getcwd())
        while os.path.isfile(os.path.join(curdir, "__init__.py")):
            curdir = os.path.abspath(os.path.join(curdir, ".."))
            for rc_name in rc_names:
                rc_path = os.path.join(curdir, rc_name)
                if os.path.isfile(rc_path):
                    yield rc_path

    if "PYLINTRC" in os.environ and os.path.exists(os.environ["PYLINTRC"]):
        if os.path.isfile(os.environ["PYLINTRC"]):
            yield os.environ["PYLINTRC"]
    else:
        user_home = os.path.expanduser("~")
        if user_home not in ("~", "/root"):
            home_rc = os.path.join(user_home, ".pylintrc")
            if os.path.isfile(home_rc):
                yield home_rc
            home_rc = os.path.join(user_home, ".config", "pylintrc")
            if os.path.isfile(home_rc):
                yield home_rc

    if os.path.isfile("/etc/pylintrc"):
        yield "/etc/pylintrc"
</t>
<t tx="ekr.20220312061835.1019">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import optparse  # pylint: disable=deprecated-module
import sys
import time


@others
</t>
<t tx="ekr.20220312061835.102">@utils.check_messages("nonexistent-operator")
def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:
    """check use of the non-existent ++ and -- operator operator"""
    if (
        (node.op in "+-")
        and isinstance(node.operand, nodes.UnaryOp)
        and (node.operand.op == node.op)
    ):
        self.add_message("nonexistent-operator", node=node, args=node.op * 2)

</t>
<t tx="ekr.20220312061835.1020"># pylint: disable=abstract-method; by design?
class _ManHelpFormatter(optparse.HelpFormatter):
    @others
</t>
<t tx="ekr.20220312061835.1021">def __init__(
    self, indent_increment=0, max_help_position=24, width=79, short_first=0
):
    optparse.HelpFormatter.__init__(
        self, indent_increment, max_help_position, width, short_first
    )
    self.output_level: int

</t>
<t tx="ekr.20220312061835.1022">def format_heading(self, heading):
    return f".SH {heading.upper()}\n"

</t>
<t tx="ekr.20220312061835.1023">def format_description(self, description):
    return description

</t>
<t tx="ekr.20220312061835.1024">def format_option(self, option):
    try:
        optstring = option.option_strings
    except AttributeError:
        optstring = self.format_option_strings(option)
    if option.help:
        help_text = self.expand_default(option)
        help_string = " ".join(line.strip() for line in help_text.splitlines())
        help_string = help_string.replace("\\", "\\\\")
        help_string = help_string.replace("[current:", "[default:")
    else:
        help_string = ""
    return f""".IP "{optstring}"
\\-4.{help_string}
\\-4."""

</t>
<t tx="ekr.20220312061835.1025">def format_head(self, optparser, pkginfo, section=1):
    long_desc = ""
    try:
        pgm = optparser._get_prog_name()
    except AttributeError:
        # py &gt;= 2.4.X (dunno which X exactly, at least 2)
        pgm = optparser.get_prog_name()
    short_desc = self.format_short_description(pgm, pkginfo.description)
    if hasattr(pkginfo, "long_desc"):
        long_desc = self.format_long_description(pgm, pkginfo.long_desc)
    return f"""{self.format_title(pgm, section)}
\\-4.{short_desc}
\\-4.{self.format_synopsis(pgm)}
\\-4.{long_desc}"""

</t>
<t tx="ekr.20220312061835.1026">@staticmethod
def format_title(pgm, section):
    date = (
        "%d-%02d-%02d"  # pylint: disable=consider-using-f-string
        % time.localtime()[:3]
    )
    return f'.TH {pgm} {section} "{date}" {pgm}'

</t>
<t tx="ekr.20220312061835.1027">@staticmethod
def format_short_description(pgm, short_desc):
    return f""".SH NAME
\\-4..B {pgm}
\\-4.\\- {short_desc.strip()}
\\-4."""

</t>
<t tx="ekr.20220312061835.1028">@staticmethod
def format_synopsis(pgm):
    return f""".SH SYNOPSIS
\\-4..B  {pgm}
\\-4.[
\\-4..I OPTIONS
\\-4.] [
\\-4..I &lt;arguments&gt;
\\-4.]
\\-4."""

</t>
<t tx="ekr.20220312061835.1029">@staticmethod
def format_long_description(pgm, long_desc):
    long_desc = "\n".join(line.lstrip() for line in long_desc.splitlines())
    long_desc = long_desc.replace("\n.\n", "\n\n")
    if long_desc.lower().startswith(pgm):
        long_desc = long_desc[len(pgm) :]
    return f""".SH DESCRIPTION
\\-4..B {pgm}
\\-4.{long_desc.strip()}
\\-4."""

</t>
<t tx="ekr.20220312061835.103">def _check_nonlocal_without_binding(self, node, name):
    current_scope = node.scope()
    while True:
        if current_scope.parent is None:
            break

        if not isinstance(current_scope, (nodes.ClassDef, nodes.FunctionDef)):
            self.add_message("nonlocal-without-binding", args=(name,), node=node)
            return

        if name not in current_scope.locals:
            current_scope = current_scope.parent.scope()
            continue

        # Okay, found it.
        return

    if not isinstance(current_scope, nodes.FunctionDef):
        self.add_message("nonlocal-without-binding", args=(name,), node=node)

</t>
<t tx="ekr.20220312061835.1030">@staticmethod
def format_tail(pkginfo):
    tail = f""".SH SEE ALSO
\\-4./usr/share/doc/pythonX.Y-{getattr(pkginfo, "debian_name", "pylint")}/

\\-4..SH BUGS
\\-4.Please report bugs on the project\'s mailing list:
\\-4.{pkginfo.mailinglist}

\\-4..SH AUTHOR
\\-4.{pkginfo.author} &lt;{pkginfo.author_email}&gt;
\\-4."""
    if hasattr(pkginfo, "copyright"):
        tail += f"""
\\-4..SH COPYRIGHT
\\-4.{pkginfo.copyright}
\\-4."""
    return tail


</t>
<t tx="ekr.20220312061835.1031">def _generate_manpage(optparser, pkginfo, section=1, stream=sys.stdout, level=0):
    formatter = _ManHelpFormatter()
    formatter.output_level = level
    formatter.parser = optparser
    print(formatter.format_head(optparser, pkginfo, section), file=stream)
    print(optparser.format_option_help(formatter), file=stream)
    print(formatter.format_tail(pkginfo), file=stream)
</t>
<t tx="ekr.20220312061835.1032">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import copy
import optparse  # pylint: disable=deprecated-module
import re

from pylint import utils


@others
</t>
<t tx="ekr.20220312061835.1033"># pylint: disable=unused-argument
def _csv_validator(_, name, value):
    return utils._check_csv(value)


</t>
<t tx="ekr.20220312061835.1034"># pylint: disable=unused-argument
def _regexp_validator(_, name, value):
    if hasattr(value, "pattern"):
        return value
    return re.compile(value)


</t>
<t tx="ekr.20220312061835.1035"># pylint: disable=unused-argument
def _regexp_csv_validator(_, name, value):
    return [_regexp_validator(_, name, val) for val in _csv_validator(_, name, value)]


</t>
<t tx="ekr.20220312061835.1036">def _choice_validator(choices, name, value):
    if value not in choices:
        msg = "option %s: invalid value: %r, should be in %s"
        raise optparse.OptionValueError(msg % (name, value, choices))
    return value


</t>
<t tx="ekr.20220312061835.1037">def _yn_validator(opt, _, value):
    if isinstance(value, int):
        return bool(value)
    if value in ("y", "yes", "true"):
        return True
    if value in ("n", "no", "false"):
        return False
    msg = "option %s: invalid yn value %r, should be in (y, yes, true, n, no, false)"
    raise optparse.OptionValueError(msg % (opt, value))


</t>
<t tx="ekr.20220312061835.1038">def _multiple_choice_validator(choices, name, value):
    values = utils._check_csv(value)
    for csv_value in values:
        if csv_value not in choices:
            msg = "option %s: invalid value: %r, should be in %s"
            raise optparse.OptionValueError(msg % (name, csv_value, choices))
    return values


</t>
<t tx="ekr.20220312061835.1039">def _non_empty_string_validator(opt, _, value):
    if not value:
        msg = "indent string can't be empty."
        raise optparse.OptionValueError(msg)
    return utils._unquote(value)


</t>
<t tx="ekr.20220312061835.104">@utils.check_messages("nonlocal-without-binding")
def visit_nonlocal(self, node: nodes.Nonlocal) -&gt; None:
    for name in node.names:
        self._check_nonlocal_without_binding(node, name)

</t>
<t tx="ekr.20220312061835.1040">def _multiple_choices_validating_option(opt, name, value):
    return _multiple_choice_validator(opt.choices, name, value)


</t>
<t tx="ekr.20220312061835.1041">def _py_version_validator(_, name, value):
    if not isinstance(value, tuple):
        try:
            value = tuple(int(val) for val in value.split("."))
        except (ValueError, AttributeError):
            raise optparse.OptionValueError(f"Invalid format for {name}") from None
    return value


</t>
<t tx="ekr.20220312061835.1042">VALIDATORS = {
    "string": utils._unquote,
    "int": int,
    "float": float,
    "regexp": re.compile,
    "regexp_csv": _regexp_csv_validator,
    "csv": _csv_validator,
    "yn": _yn_validator,
    "choice": lambda opt, name, value: _choice_validator(opt["choices"], name, value),
    "multiple_choice": lambda opt, name, value: _multiple_choice_validator(
        opt["choices"], name, value
    ),
    "non_empty_string": _non_empty_string_validator,
    "py_version": _py_version_validator,
}


</t>
<t tx="ekr.20220312061835.1043">def _call_validator(opttype, optdict, option, value):
    if opttype not in VALIDATORS:
        raise Exception(f'Unsupported type "{opttype}"')
    try:
        return VALIDATORS[opttype](optdict, option, value)
    except TypeError:
        try:
            return VALIDATORS[opttype](value)
        except Exception as e:
            raise optparse.OptionValueError(
                f"{option} value ({value!r}) should be of type {opttype}"
            ) from e


</t>
<t tx="ekr.20220312061835.1044">def _validate(value, optdict, name=""):
    """return a validated value for an option according to its type

    optional argument name is only used for error message formatting
    """
    try:
        _type = optdict["type"]
    except KeyError:
        return value
    return _call_validator(_type, optdict, name, value)


</t>
<t tx="ekr.20220312061835.1045"># pylint: disable=no-member
class Option(optparse.Option):
    TYPES = optparse.Option.TYPES + (
        "regexp",
        "regexp_csv",
        "csv",
        "yn",
        "multiple_choice",
        "non_empty_string",
        "py_version",
    )
    ATTRS = optparse.Option.ATTRS + ["hide", "level"]
    TYPE_CHECKER = copy.copy(optparse.Option.TYPE_CHECKER)
    TYPE_CHECKER["regexp"] = _regexp_validator
    TYPE_CHECKER["regexp_csv"] = _regexp_csv_validator
    TYPE_CHECKER["csv"] = _csv_validator
    TYPE_CHECKER["yn"] = _yn_validator
    TYPE_CHECKER["multiple_choice"] = _multiple_choices_validating_option
    TYPE_CHECKER["non_empty_string"] = _non_empty_string_validator
    TYPE_CHECKER["py_version"] = _py_version_validator

    @others
</t>
<t tx="ekr.20220312061835.1046">def __init__(self, *opts, **attrs):
    optparse.Option.__init__(self, *opts, **attrs)
    if hasattr(self, "hide") and self.hide:
        self.help = optparse.SUPPRESS_HELP

</t>
<t tx="ekr.20220312061835.1047">def _check_choice(self):
    if self.type in ("choice", "multiple_choice"):
        if self.choices is None:
            raise optparse.OptionError(
                "must supply a list of choices for type 'choice'", self
            )
        if not isinstance(self.choices, (tuple, list)):
            raise optparse.OptionError(
                # pylint: disable-next=consider-using-f-string
                "choices must be a list of strings ('%s' supplied)"
                % str(type(self.choices)).split("'")[1],
                self,
            )
    elif self.choices is not None:
        raise optparse.OptionError(
            f"must not supply choices for type {self.type!r}", self
        )

</t>
<t tx="ekr.20220312061835.1048"># pylint: disable=unsupported-assignment-operation
optparse.Option.CHECK_METHODS[2] = _check_choice  # type: ignore

</t>
<t tx="ekr.20220312061835.1049">def process(self, opt, value, values, parser):
    # First, convert the value(s) to the right type.  Howl if any
    # value(s) are bogus.
    value = self.convert_value(opt, value)
    if self.type == "named":
        existent = getattr(values, self.dest)
        if existent:
            existent.update(value)
            value = existent
    # And then take whatever action is expected of us.
    # This is a separate method to make life easier for
    # subclasses to add new actions.
    return self.take_action(self.action, self.dest, opt, value, values, parser)
</t>
<t tx="ekr.20220312061835.105">@utils.check_messages("abstract-class-instantiated")
def visit_call(self, node: nodes.Call) -&gt; None:
    """Check instantiating abstract class with
    abc.ABCMeta as metaclass.
    """
    for inferred in infer_all(node.func):
        self._check_inferred_class_is_abstract(inferred, node)

</t>
<t tx="ekr.20220312061835.1050">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import optparse  # pylint: disable=deprecated-module
from typing import Any, Dict, Tuple

from pylint.config.option import _validate


@others
</t>
<t tx="ekr.20220312061835.1051">class UnsupportedAction(Exception):
    """raised by set_option when it doesn't know what to do for an action"""


</t>
<t tx="ekr.20220312061835.1052">class OptionsProviderMixIn:
    """Mixin to provide options to an OptionsManager"""

    # those attributes should be overridden
    priority = -1
    name = "default"
    options: Tuple[Tuple[str, Dict[str, Any]], ...] = ()
    level = 0

    @others
</t>
<t tx="ekr.20220312061835.1053">def __init__(self):
    self.config = optparse.Values()
    self.load_defaults()

</t>
<t tx="ekr.20220312061835.1054">def load_defaults(self):
    """initialize the provider using default values"""
    for opt, optdict in self.options:
        action = optdict.get("action")
        if action != "callback":
            # callback action have no default
            if optdict is None:
                optdict = self.get_option_def(opt)
            default = optdict.get("default")
            self.set_option(opt, default, action, optdict)

</t>
<t tx="ekr.20220312061835.1055">def option_attrname(self, opt, optdict=None):
    """get the config attribute corresponding to opt"""
    if optdict is None:
        optdict = self.get_option_def(opt)
    return optdict.get("dest", opt.replace("-", "_"))

</t>
<t tx="ekr.20220312061835.1056">def option_value(self, opt):
    """get the current value for the given option"""
    return getattr(self.config, self.option_attrname(opt), None)

</t>
<t tx="ekr.20220312061835.1057">def set_option(self, optname, value, action=None, optdict=None):
    """method called to set an option (registered in the options list)"""
    if optdict is None:
        optdict = self.get_option_def(optname)
    if value is not None:
        value = _validate(value, optdict, optname)
    if action is None:
        action = optdict.get("action", "store")
    if action == "store":
        setattr(self.config, self.option_attrname(optname, optdict), value)
    elif action in ("store_true", "count"):
        setattr(self.config, self.option_attrname(optname, optdict), 0)
    elif action == "store_false":
        setattr(self.config, self.option_attrname(optname, optdict), 1)
    elif action == "append":
        optname = self.option_attrname(optname, optdict)
        _list = getattr(self.config, optname, None)
        if _list is None:
            if isinstance(value, (list, tuple)):
                _list = value
            elif value is not None:
                _list = []
                _list.append(value)
            setattr(self.config, optname, _list)
        elif isinstance(_list, tuple):
            setattr(self.config, optname, _list + (value,))
        else:
            _list.append(value)
    elif action == "callback":
        optdict["callback"](None, optname, value, None)
    else:
        raise UnsupportedAction(action)

</t>
<t tx="ekr.20220312061835.1058">def get_option_def(self, opt):
    """return the dictionary defining an option given its name"""
    assert self.options
    for option in self.options:
        if option[0] == opt:
            return option[1]
    raise optparse.OptionError(
        f"no such option {opt} in section {self.name!r}", opt
    )

</t>
<t tx="ekr.20220312061835.1059">def options_by_section(self):
    """return an iterator on options grouped by section

    (section, [list of (optname, optdict, optvalue)])
    """
    sections = {}
    for optname, optdict in self.options:
        sections.setdefault(optdict.get("group"), []).append(
            (optname, optdict, self.option_value(optname))
        )
    if None in sections:
        yield None, sections.pop(None)
    for section, options in sorted(sections.items()):
        yield section.upper(), options

</t>
<t tx="ekr.20220312061835.106">def _check_inferred_class_is_abstract(self, inferred, node):
    if not isinstance(inferred, nodes.ClassDef):
        return

    klass = utils.node_frame_class(node)
    if klass is inferred:
        # Don't emit the warning if the class is instantiated
        # in its own body or if the call is not an instance
        # creation. If the class is instantiated into its own
        # body, we're expecting that it knows what it is doing.
        return

    # __init__ was called
    abstract_methods = _has_abstract_methods(inferred)

    if not abstract_methods:
        return

    metaclass = inferred.metaclass()

    if metaclass is None:
        # Python 3.4 has `abc.ABC`, which won't be detected
        # by ClassNode.metaclass()
        for ancestor in inferred.ancestors():
            if ancestor.qname() == "abc.ABC":
                self.add_message(
                    "abstract-class-instantiated", args=(inferred.name,), node=node
                )
                break

        return

    if metaclass.qname() in ABC_METACLASSES:
        self.add_message(
            "abstract-class-instantiated", args=(inferred.name,), node=node
        )

</t>
<t tx="ekr.20220312061835.1060">def options_and_values(self, options=None):
    if options is None:
        options = self.options
    for optname, optdict in options:
        yield (optname, optdict, self.option_value(optname))
</t>
<t tx="ekr.20220312061835.1061">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import collections
import configparser
import contextlib
import copy
import functools
import optparse  # pylint: disable=deprecated-module
import os
import sys
from types import ModuleType
from typing import Dict, List, Optional, TextIO, Tuple

import toml

from pylint import utils
from pylint.config.man_help_formatter import _ManHelpFormatter
from pylint.config.option import Option
from pylint.config.option_parser import OptionParser


@others
</t>
<t tx="ekr.20220312061835.1062">def _expand_default(self, option):
    """Patch OptionParser.expand_default with custom behaviour

    This will handle defaults to avoid overriding values in the
    configuration file.
    """
    if self.parser is None or not self.default_tag:
        return option.help
    optname = option._long_opts[0][2:]
    try:
        provider = self.parser.options_manager._all_options[optname]
    except KeyError:
        value = None
    else:
        optdict = provider.get_option_def(optname)
        optname = provider.option_attrname(optname, optdict)
        value = getattr(provider.config, optname, optdict)
        value = utils._format_option_value(optdict, value)
    if value is optparse.NO_DEFAULT or not value:
        value = self.NO_DEFAULT_VALUE
    return option.help.replace(self.default_tag, str(value))


</t>
<t tx="ekr.20220312061835.1063">@contextlib.contextmanager
def _patch_optparse():
    # pylint: disable = redefined-variable-type
    orig_default = optparse.HelpFormatter
    try:
        optparse.HelpFormatter.expand_default = _expand_default
        yield
    finally:
        optparse.HelpFormatter.expand_default = orig_default


</t>
<t tx="ekr.20220312061835.1064">class OptionsManagerMixIn:
    """Handle configuration from both a configuration file and command line options"""

    @others
</t>
<t tx="ekr.20220312061835.1065">def __init__(self, usage, config_file=None):
    self.config_file = config_file
    self.reset_parsers(usage)
    # list of registered options providers
    self.options_providers = []
    # dictionary associating option name to checker
    self._all_options = collections.OrderedDict()
    self._short_options = {}
    self._nocallback_options = {}
    self._mygroups = {}
    # verbosity
    self._maxlevel = 0

</t>
<t tx="ekr.20220312061835.1066">def reset_parsers(self, usage=""):
    # configuration file parser
    self.cfgfile_parser = configparser.ConfigParser(
        inline_comment_prefixes=("#", ";")
    )
    # command line parser
    self.cmdline_parser = OptionParser(Option, usage=usage)
    self.cmdline_parser.options_manager = self
    self._optik_option_attrs = set(self.cmdline_parser.option_class.ATTRS)

</t>
<t tx="ekr.20220312061835.1067">def register_options_provider(self, provider, own_group=True):
    """register an options provider"""
    assert provider.priority &lt;= 0, "provider's priority can't be &gt;= 0"
    for i, options_provider in enumerate(self.options_providers):
        if provider.priority &gt; options_provider.priority:
            self.options_providers.insert(i, provider)
            break
    else:
        self.options_providers.append(provider)
    non_group_spec_options = [
        option for option in provider.options if "group" not in option[1]
    ]
    groups = getattr(provider, "option_groups", ())
    if own_group and non_group_spec_options:
        self.add_option_group(
            provider.name.upper(),
            provider.__doc__,
            non_group_spec_options,
            provider,
        )
    else:
        for opt, optdict in non_group_spec_options:
            self.add_optik_option(provider, self.cmdline_parser, opt, optdict)
    for gname, gdoc in groups:
        gname = gname.upper()
        goptions = [
            option
            for option in provider.options
            if option[1].get("group", "").upper() == gname
        ]
        self.add_option_group(gname, gdoc, goptions, provider)

</t>
<t tx="ekr.20220312061835.1068">def add_option_group(self, group_name, _, options, provider):
    # add option group to the command line parser
    if group_name in self._mygroups:
        group = self._mygroups[group_name]
    else:
        group = optparse.OptionGroup(
            self.cmdline_parser, title=group_name.capitalize()
        )
        self.cmdline_parser.add_option_group(group)
        group.level = provider.level
        self._mygroups[group_name] = group
        # add section to the config file
        if (
            group_name != "DEFAULT"
            and group_name not in self.cfgfile_parser._sections
        ):
            self.cfgfile_parser.add_section(group_name)
    # add provider's specific options
    for opt, optdict in options:
        self.add_optik_option(provider, group, opt, optdict)

</t>
<t tx="ekr.20220312061835.1069">def add_optik_option(self, provider, optikcontainer, opt, optdict):
    args, optdict = self.optik_option(provider, opt, optdict)
    option = optikcontainer.add_option(*args, **optdict)
    self._all_options[opt] = provider
    self._maxlevel = max(self._maxlevel, option.level or 0)

</t>
<t tx="ekr.20220312061835.107">def _check_yield_outside_func(self, node):
    if not isinstance(node.frame(), (nodes.FunctionDef, nodes.Lambda)):
        self.add_message("yield-outside-function", node=node)

</t>
<t tx="ekr.20220312061835.1070">def optik_option(self, provider, opt, optdict):
    """get our personal option definition and return a suitable form for
    use with optik/optparse
    """
    optdict = copy.copy(optdict)
    if "action" in optdict:
        self._nocallback_options[provider] = opt
    else:
        optdict["action"] = "callback"
        optdict["callback"] = self.cb_set_provider_option
    # default is handled here and *must not* be given to optik if you
    # want the whole machinery to work
    if "default" in optdict:
        if (
            "help" in optdict
            and optdict.get("default") is not None
            and optdict["action"] not in ("store_true", "store_false")
        ):
            optdict["help"] += " [current: %default]"
        del optdict["default"]
    args = ["--" + str(opt)]
    if "short" in optdict:
        self._short_options[optdict["short"]] = opt
        args.append("-" + optdict["short"])
        del optdict["short"]
    # cleanup option definition dict before giving it to optik
    for key in list(optdict.keys()):
        if key not in self._optik_option_attrs:
            optdict.pop(key)
    return args, optdict

</t>
<t tx="ekr.20220312061835.1071">def cb_set_provider_option(self, option, opt, value, parser):
    """optik callback for option setting"""
    if opt.startswith("--"):
        # remove -- on long option
        opt = opt[2:]
    else:
        # short option, get its long equivalent
        opt = self._short_options[opt[1:]]
    # trick since we can't set action='store_true' on options
    if value is None:
        value = 1
    self.global_set_option(opt, value)

</t>
<t tx="ekr.20220312061835.1072">def global_set_option(self, opt, value):
    """set option on the correct option provider"""
    self._all_options[opt].set_option(opt, value)

</t>
<t tx="ekr.20220312061835.1073">def generate_config(
    self, stream: Optional[TextIO] = None, skipsections: Tuple[str, ...] = ()
) -&gt; None:
    """write a configuration file according to the current configuration
    into the given stream or stdout
    """
    options_by_section: Dict[str, List[Tuple]] = {}
    sections = []
    for provider in self.options_providers:
        for section, options in provider.options_by_section():
            if section is None:
                section = provider.name
            if section in skipsections:
                continue
            options = [
                (n, d, v)
                for (n, d, v) in options
                if d.get("type") is not None and not d.get("deprecated")
            ]
            if not options:
                continue
            if section not in sections:
                sections.append(section)
            alloptions = options_by_section.setdefault(section, [])
            alloptions += options
    stream = stream or sys.stdout
    printed = False
    for section in sections:
        if printed:
            print("\n", file=stream)
        utils.format_section(
            stream, section.upper(), sorted(options_by_section[section])
        )
        printed = True

</t>
<t tx="ekr.20220312061835.1074">def generate_manpage(
    self, pkginfo: ModuleType, section: int = 1, stream: TextIO = sys.stdout
) -&gt; None:
    with _patch_optparse():
        formatter = _ManHelpFormatter()
        formatter.output_level = self._maxlevel
        formatter.parser = self.cmdline_parser
        print(
            formatter.format_head(self.cmdline_parser, pkginfo, section),
            file=stream,
        )
        print(self.cmdline_parser.format_option_help(formatter), file=stream)
        print(formatter.format_tail(pkginfo), file=stream)

</t>
<t tx="ekr.20220312061835.1075">def load_provider_defaults(self):
    """initialize configuration using default values"""
    for provider in self.options_providers:
        provider.load_defaults()

</t>
<t tx="ekr.20220312061835.1076">def read_config_file(self, config_file=None, verbose=None):
    """Read the configuration file but do not load it (i.e. dispatching
    values to each options provider)
    """
    for help_level in range(1, self._maxlevel + 1):
        opt = "-".join(["long"] * help_level) + "-help"
        if opt in self._all_options:
            break  # already processed
        help_function = functools.partial(self.helpfunc, level=help_level)
        help_msg = f"{' '.join(['more'] * help_level)} verbose help."
        optdict = {
            "action": "callback",
            "callback": help_function,
            "help": help_msg,
        }
        provider = self.options_providers[0]
        self.add_optik_option(provider, self.cmdline_parser, opt, optdict)
        provider.options += ((opt, optdict),)

    if config_file is None:
        config_file = self.config_file
    if config_file is not None:
        config_file = os.path.expandvars(os.path.expanduser(config_file))
        if not os.path.exists(config_file):
            raise OSError(f"The config file {config_file} doesn't exist!")

    use_config_file = config_file and os.path.exists(config_file)
    if use_config_file:  # pylint: disable=too-many-nested-blocks
        parser = self.cfgfile_parser

        if config_file.endswith(".toml"):
            with open(config_file, encoding="utf-8") as fp:
                content = toml.load(fp)

            try:
                sections_values = content["tool"]["pylint"]
            except KeyError:
                pass
            else:
                for section, values in sections_values.items():
                    # TOML has rich types, convert values to
                    # strings as ConfigParser expects.
                    for option, value in values.items():
                        if isinstance(value, bool):
                            values[option] = "yes" if value else "no"
                        elif isinstance(value, (int, float)):
                            values[option] = str(value)
                        elif isinstance(value, list):
                            values[option] = ",".join(value)
                    parser._sections[section.upper()] = values
        else:
            # Use this encoding in order to strip the BOM marker, if any.
            with open(config_file, encoding="utf_8_sig") as fp:
                parser.read_file(fp)

            # normalize sections'title
            for sect, values in list(parser._sections.items()):
                if sect.startswith("pylint."):
                    sect = sect[len("pylint.") :]
                if not sect.isupper() and values:
                    parser._sections[sect.upper()] = values
    if not verbose:
        return
    if use_config_file:
        msg = f"Using config file {os.path.abspath(config_file)}"
    else:
        msg = "No config file found, using default configuration"
    print(msg, file=sys.stderr)

</t>
<t tx="ekr.20220312061835.1077">def load_config_file(self):
    """Dispatch values previously read from a configuration file to each
    options provider)"""
    parser = self.cfgfile_parser
    for section in parser.sections():
        for option, value in parser.items(section):
            try:
                self.global_set_option(option, value)
            except (KeyError, optparse.OptionError):
                continue

</t>
<t tx="ekr.20220312061835.1078">def load_configuration(self, **kwargs):
    """override configuration according to given parameters"""
    return self.load_configuration_from_config(kwargs)

</t>
<t tx="ekr.20220312061835.1079">def load_configuration_from_config(self, config):
    for opt, opt_value in config.items():
        opt = opt.replace("_", "-")
        provider = self._all_options[opt]
        provider.set_option(opt, opt_value)

</t>
<t tx="ekr.20220312061835.108">def _check_else_on_loop(self, node):
    """Check that any loop with an else clause has a break statement."""
    if node.orelse and not _loop_exits_early(node):
        self.add_message(
            "useless-else-on-loop",
            node=node,
            # This is not optimal, but the line previous
            # to the first statement in the else clause
            # will usually be the one that contains the else:.
            line=node.orelse[0].lineno - 1,
        )

</t>
<t tx="ekr.20220312061835.1080">def load_command_line_configuration(self, args=None) -&gt; List[str]:
    """Override configuration according to command line parameters

    return additional arguments
    """
    with _patch_optparse():
        args = sys.argv[1:] if args is None else list(args)
        (options, args) = self.cmdline_parser.parse_args(args=args)
        for provider in self._nocallback_options:
            config = provider.config
            for attr in config.__dict__.keys():
                value = getattr(options, attr, None)
                if value is None:
                    continue
                setattr(config, attr, value)
        return args

</t>
<t tx="ekr.20220312061835.1081">def add_help_section(self, title, description, level=0):
    """add a dummy option section for help purpose"""
    group = optparse.OptionGroup(
        self.cmdline_parser, title=title.capitalize(), description=description
    )
    group.level = level
    self._maxlevel = max(self._maxlevel, level)
    self.cmdline_parser.add_option_group(group)

</t>
<t tx="ekr.20220312061835.1082">def help(self, level=0):
    """return the usage string for available options"""
    self.cmdline_parser.formatter.output_level = level
    with _patch_optparse():
        return self.cmdline_parser.format_help()

</t>
<t tx="ekr.20220312061835.1083">def helpfunc(self, option, opt, val, p, level):  # pylint: disable=unused-argument
    print(self.help(level))
    sys.exit(0)
</t>
<t tx="ekr.20220312061835.1084">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import optparse  # pylint: disable=deprecated-module

from pylint.config.option import Option


@others
</t>
<t tx="ekr.20220312061835.1085">def _level_options(group, outputlevel):
    return [
        option
        for option in group.option_list
        if (getattr(option, "level", 0) or 0) &lt;= outputlevel
        and option.help is not optparse.SUPPRESS_HELP
    ]


</t>
<t tx="ekr.20220312061835.1086">class OptionParser(optparse.OptionParser):
    @others
</t>
<t tx="ekr.20220312061835.1087">def __init__(self, option_class, *args, **kwargs):
    optparse.OptionParser.__init__(self, option_class=Option, *args, **kwargs)

</t>
<t tx="ekr.20220312061835.1088">def format_option_help(self, formatter=None):
    if formatter is None:
        formatter = self.formatter
    outputlevel = getattr(formatter, "output_level", 0)
    formatter.store_option_strings(self)
    result = []
    result.append(formatter.format_heading("Options"))
    formatter.indent()
    if self.option_list:
        result.append(optparse.OptionContainer.format_option_help(self, formatter))
        result.append("\n")
    for group in self.option_groups:
        if group.level &lt;= outputlevel and (
            group.description or _level_options(group, outputlevel)
        ):
            result.append(group.format_help(formatter))
            result.append("\n")
    formatter.dedent()
    # Drop the last "\n", or the header if no options or option groups:
    return "".join(result[:-1])

</t>
<t tx="ekr.20220312061835.1089">def _match_long_opt(self, opt):
    """Disable abbreviations."""
    if opt not in self._long_opt:
        raise optparse.BadOptionError(opt)
    return opt
</t>
<t tx="ekr.20220312061835.109">def _check_in_loop(self, node, node_name):
    """check that a node is inside a for or while loop"""
    _node = node.parent
    while _node:
        if isinstance(_node, (nodes.For, nodes.While)):
            if node not in _node.orelse:
                return

        if isinstance(_node, (nodes.ClassDef, nodes.FunctionDef)):
            break
        if (
            isinstance(_node, nodes.TryFinally)
            and node in _node.finalbody
            and isinstance(node, nodes.Continue)
        ):
            self.add_message("continue-in-finally", node=node)

        _node = _node.parent

    self.add_message("not-in-loop", node=node, args=node_name)

</t>
<t tx="ekr.20220312061835.1090">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/config/
@language python
@tabwidth -4
# Copyright (c) 2006-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2008 pyves@crater.logilab.fr &lt;pyves@crater.logilab.fr&gt;
# Copyright (c) 2013 Google, Inc.
# Copyright (c) 2013 John McGehee &lt;jmcgehee@altera.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Aru Sahni &lt;arusahni@gmail.com&gt;
# Copyright (c) 2015 John Kirkham &lt;jakirkham@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Erik &lt;erik.eriksson@yahoo.com&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017-2019 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2017 ahirnish &lt;ahirnish@gmail.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Gary Tyler McLeod &lt;mail@garytyler.com&gt;
# Copyright (c) 2018 Konstantin &lt;Github@pheanex.de&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019, 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2019 Janne Rnkk &lt;jannero@users.noreply.github.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Eisuke Kawashima &lt;e-kwsm@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import os
import pathlib
import pickle
import sys
from datetime import datetime

import platformdirs

from pylint.config.configuration_mixin import ConfigurationMixIn
from pylint.config.find_default_config_files import find_default_config_files
from pylint.config.man_help_formatter import _ManHelpFormatter
from pylint.config.option import Option
from pylint.config.option_manager_mixin import OptionsManagerMixIn
from pylint.config.option_parser import OptionParser
from pylint.config.options_provider_mixin import OptionsProviderMixIn, UnsupportedAction

__all__ = [
    "ConfigurationMixIn",
    "find_default_config_files",
    "_ManHelpFormatter",
    "Option",
    "OptionsManagerMixIn",
    "OptionParser",
    "OptionsProviderMixIn",
    "UnsupportedAction",
]

USER_HOME = os.path.expanduser("~")
if "PYLINTHOME" in os.environ:
    PYLINT_HOME = os.environ["PYLINTHOME"]
    if USER_HOME == "~":
        USER_HOME = os.path.dirname(PYLINT_HOME)
elif USER_HOME == "~":
    PYLINT_HOME = ".pylint.d"
else:
    PYLINT_HOME = platformdirs.user_cache_dir("pylint")
    # The spam prevention is due to pylint being used in parallel by
    # pre-commit, and the message being spammy in this context
    # Also if you work with old version of pylint that recreate the
    # old pylint home, you can get the old message for a long time.
    prefix_spam_prevention = "pylint_warned_about_old_cache_already"
    spam_prevention_file = os.path.join(
        PYLINT_HOME,
        datetime.now().strftime(prefix_spam_prevention + "_%Y-%m-%d.temp"),
    )
    old_home = os.path.join(USER_HOME, ".pylint.d")
    if os.path.exists(old_home) and not os.path.exists(spam_prevention_file):
        print(
            f"PYLINTHOME is now '{PYLINT_HOME}' but obsolescent '{old_home}' is found; "
            "you can safely remove the latter",
            file=sys.stderr,
        )
        # Remove old spam prevention file
        if os.path.exists(PYLINT_HOME):
            for filename in os.listdir(PYLINT_HOME):
                if prefix_spam_prevention in filename:
                    try:
                        os.remove(os.path.join(PYLINT_HOME, filename))
                    except OSError:
                        pass

        # Create spam prevention file for today
        try:
            pathlib.Path(PYLINT_HOME).mkdir(parents=True, exist_ok=True)
            with open(spam_prevention_file, "w", encoding="utf8") as f:
                f.write("")
        except Exception:  # pylint: disable=broad-except
            # Can't write in PYLINT_HOME ?
            print(
                "Can't write the file that was supposed to "
                f"prevent pylint.d deprecation spam in {PYLINT_HOME}."
            )


@others
PYLINTRC = find_pylintrc()

ENV_HELP = """
The following environment variables are used:
    * PYLINTHOME
    Path to the directory where persistent data for the run will be stored. If
not found, it defaults to ~/.pylint.d/ or .pylint.d (in the current working
directory).
    * PYLINTRC
    Path to the configuration file. See the documentation for the method used
to search for configuration file.
"""
</t>
<t tx="ekr.20220312061835.1091">def _get_pdata_path(base_name, recurs):
    base_name = base_name.replace(os.sep, "_")
    return os.path.join(PYLINT_HOME, f"{base_name}{recurs}.stats")


</t>
<t tx="ekr.20220312061835.1092">def load_results(base):
    data_file = _get_pdata_path(base, 1)
    try:
        with open(data_file, "rb") as stream:
            return pickle.load(stream)
    except Exception:  # pylint: disable=broad-except
        return {}


</t>
<t tx="ekr.20220312061835.1093">def save_results(results, base):
    if not os.path.exists(PYLINT_HOME):
        try:
            os.makedirs(PYLINT_HOME)
        except OSError:
            print(f"Unable to create directory {PYLINT_HOME}", file=sys.stderr)
    data_file = _get_pdata_path(base, 1)
    try:
        with open(data_file, "wb") as stream:
            pickle.dump(results, stream)
    except OSError as ex:
        print(f"Unable to create file {data_file}: {ex}", file=sys.stderr)


</t>
<t tx="ekr.20220312061835.1094">def find_pylintrc():
    """search the pylint rc file and return its path if it find it, else None"""
    for config_file in find_default_config_files():
        if config_file.endswith("pylintrc"):
            return config_file

    return None


</t>
<t tx="ekr.20220312061835.1095"></t>
<t tx="ekr.20220312061835.1096">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016, 2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checker for deprecated builtins."""
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker

BAD_FUNCTIONS = ["map", "filter"]
# Some hints regarding the use of bad builtins.
BUILTIN_HINTS = {"map": "Using a list comprehension can be clearer."}
BUILTIN_HINTS["filter"] = BUILTIN_HINTS["map"]


@others
</t>
<t tx="ekr.20220312061835.1097">class BadBuiltinChecker(BaseChecker):

    __implements__ = (IAstroidChecker,)
    name = "deprecated_builtins"
    msgs = {
        "W0141": (
            "Used builtin function %s",
            "bad-builtin",
            "Used when a disallowed builtin function is used (see the "
            "bad-function option). Usual disallowed functions are the ones "
            "like map, or filter , where Python offers now some cleaner "
            "alternative like list comprehension.",
        )
    }

    options = (
        (
            "bad-functions",
            {
                "default": BAD_FUNCTIONS,
                "type": "csv",
                "metavar": "&lt;builtin function names&gt;",
                "help": "List of builtins function names that should not be "
                "used, separated by a comma",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.1098">@check_messages("bad-builtin")
def visit_call(self, node: nodes.Call) -&gt; None:
    if isinstance(node.func, nodes.Name):
        name = node.func.name
        # ignore the name if it's not a builtin (i.e. not defined in the
        # locals nor globals scope)
        if not (name in node.frame() or name in node.root()):
            if name in self.config.bad_functions:
                hint = BUILTIN_HINTS.get(name)
                args = f"{name!r}. {hint}" if hint else repr(name)
                self.add_message("bad-builtin", node=node, args=args)


</t>
<t tx="ekr.20220312061835.1099">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(BadBuiltinChecker(linter))
</t>
<t tx="ekr.20220312061835.11">class UnknownMessageError(Exception):
    """raised when an unregistered message id is encountered"""


</t>
<t tx="ekr.20220312061835.110">def _check_redefinition(self, redeftype, node):
    """check for redefinition of a function / method / class name"""
    parent_frame = node.parent.frame()

    # Ignore function stubs created for type information
    redefinitions = [
        i
        for i in parent_frame.locals[node.name]
        if not (isinstance(i.parent, nodes.AnnAssign) and i.parent.simple)
    ]
    defined_self = next(
        (local for local in redefinitions if not utils.is_overload_stub(local)),
        node,
    )
    if defined_self is not node and not astroid.are_exclusive(node, defined_self):
        # Additional checks for methods which are not considered
        # redefined, since they are already part of the base API.
        if (
            isinstance(parent_frame, nodes.ClassDef)
            and node.name in REDEFINABLE_METHODS
        ):
            return

        # Skip typing.overload() functions.
        if utils.is_overload_stub(node):
            return

        # Exempt functions redefined on a condition.
        if isinstance(node.parent, nodes.If):
            # Exempt "if not &lt;func&gt;" cases
            if (
                isinstance(node.parent.test, nodes.UnaryOp)
                and node.parent.test.op == "not"
                and isinstance(node.parent.test.operand, nodes.Name)
                and node.parent.test.operand.name == node.name
            ):
                return

            # Exempt "if &lt;func&gt; is not None" cases
            # pylint: disable=too-many-boolean-expressions
            if (
                isinstance(node.parent.test, nodes.Compare)
                and isinstance(node.parent.test.left, nodes.Name)
                and node.parent.test.left.name == node.name
                and node.parent.test.ops[0][0] == "is"
                and isinstance(node.parent.test.ops[0][1], nodes.Const)
                and node.parent.test.ops[0][1].value is None
            ):
                return

        # Check if we have forward references for this node.
        try:
            redefinition_index = redefinitions.index(node)
        except ValueError:
            pass
        else:
            for redefinition in redefinitions[:redefinition_index]:
                inferred = utils.safe_infer(redefinition)
                if (
                    inferred
                    and isinstance(inferred, astroid.Instance)
                    and inferred.qname() == TYPING_FORWARD_REF_QNAME
                ):
                    return

        dummy_variables_rgx = lint_utils.get_global_option(
            self, "dummy-variables-rgx", default=None
        )
        if dummy_variables_rgx and dummy_variables_rgx.match(node.name):
            return
        self.add_message(
            "function-redefined",
            node=node,
            args=(redeftype, defined_self.fromlineno),
        )


</t>
<t tx="ekr.20220312061835.1100">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2019-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2019-2020 Tyler Thieding &lt;tyler@thieding.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Looks for try/except statements with too much code in the try clause."""

from astroid import nodes

from pylint import checkers, interfaces


@others
</t>
<t tx="ekr.20220312061835.1101">class BroadTryClauseChecker(checkers.BaseChecker):
    """Checks for try clauses with too many lines.

    According to PEP 8, ``try`` clauses shall contain the absolute minimum
    amount of code. This checker enforces a maximum number of statements within
    ``try`` clauses.

    """

    __implements__ = interfaces.IAstroidChecker

    # configuration section name
    name = "broad_try_clause"
    msgs = {
        "W0717": (
            "%s",
            "too-many-try-statements",
            "Try clause contains too many statements.",
        )
    }

    priority = -2
    options = (
        (
            "max-try-statements",
            {
                "default": 1,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of statements allowed in a try clause",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.1102">def _count_statements(self, try_node):
    statement_count = len(try_node.body)

    for body_node in try_node.body:
        if isinstance(body_node, (nodes.For, nodes.If, nodes.While, nodes.With)):
            statement_count += self._count_statements(body_node)

    return statement_count

</t>
<t tx="ekr.20220312061835.1103">def visit_tryexcept(self, node: nodes.TryExcept) -&gt; None:
    try_clause_statements = self._count_statements(node)
    if try_clause_statements &gt; self.config.max_try_statements:
        msg = f"try clause contains {try_clause_statements} statements, expected at most {self.config.max_try_statements}"
        self.add_message(
            "too-many-try-statements", node.lineno, node=node, args=msg
        )

</t>
<t tx="ekr.20220312061835.1104">def visit_tryfinally(self, node: nodes.TryFinally) -&gt; None:
    self.visit_tryexcept(node)


</t>
<t tx="ekr.20220312061835.1105">def register(linter):
    """Required method to auto register this checker."""
    linter.register_checker(BroadTryClauseChecker(linter))
</t>
<t tx="ekr.20220312061835.1106">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2014-2015 Bruno Daniel &lt;bruno.daniel@blue-yonder.com&gt;
# Copyright (c) 2015-2016, 2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import warnings

from pylint.extensions import docparams


@others
</t>
<t tx="ekr.20220312061835.1107">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    warnings.warn(
        "This plugin is deprecated, use pylint.extensions.docparams instead.",
        DeprecationWarning,
    )
    linter.register_checker(docparams.DocstringParameterChecker(linter))
</t>
<t tx="ekr.20220312061835.1108">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2015 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glmatthe@cisco.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from astroid import nodes

from pylint.checkers import BaseTokenChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker, ITokenChecker


@others
</t>
<t tx="ekr.20220312061835.1109">class ElseifUsedChecker(BaseTokenChecker):
    """Checks for use of "else if" when an "elif" could be used"""

    __implements__ = (ITokenChecker, IAstroidChecker)
    name = "else_if_used"
    msgs = {
        "R5501": (
            'Consider using "elif" instead of "else if"',
            "else-if-used",
            "Used when an else statement is immediately followed by "
            "an if statement and does not contain statements that "
            "would be unrelated to it.",
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.111">class BasicChecker(_BasicChecker):
    """checks for :
    * doc strings
    * number of arguments, local variables, branches, returns and statements in
    functions, methods
    * required module attributes
    * dangerous default values as arguments
    * redefinition of function / method / class
    * uses of the global statement
    """

    __implements__ = interfaces.IAstroidChecker

    name = "basic"
    msgs = {
        "W0101": (
            "Unreachable code",
            "unreachable",
            'Used when there is some code behind a "return" or "raise" '
            "statement, which will never be accessed.",
        ),
        "W0102": (
            "Dangerous default value %s as argument",
            "dangerous-default-value",
            "Used when a mutable value as list or dictionary is detected in "
            "a default value for an argument.",
        ),
        "W0104": (
            "Statement seems to have no effect",
            "pointless-statement",
            "Used when a statement doesn't have (or at least seems to) any effect.",
        ),
        "W0105": (
            "String statement has no effect",
            "pointless-string-statement",
            "Used when a string is used as a statement (which of course "
            "has no effect). This is a particular case of W0104 with its "
            "own message so you can easily disable it if you're using "
            "those strings as documentation, instead of comments.",
        ),
        "W0106": (
            'Expression "%s" is assigned to nothing',
            "expression-not-assigned",
            "Used when an expression that is not a function call is assigned "
            "to nothing. Probably something else was intended.",
        ),
        "W0108": (
            "Lambda may not be necessary",
            "unnecessary-lambda",
            "Used when the body of a lambda expression is a function call "
            "on the same argument list as the lambda itself; such lambda "
            "expressions are in all but a few cases replaceable with the "
            "function being called in the body of the lambda.",
        ),
        "W0109": (
            "Duplicate key %r in dictionary",
            "duplicate-key",
            "Used when a dictionary expression binds the same key multiple times.",
        ),
        "W0122": (
            "Use of exec",
            "exec-used",
            'Used when you use the "exec" statement (function for Python '
            "3), to discourage its usage. That doesn't "
            "mean you cannot use it !",
        ),
        "W0123": (
            "Use of eval",
            "eval-used",
            'Used when you use the "eval" function, to discourage its '
            "usage. Consider using `ast.literal_eval` for safely evaluating "
            "strings containing Python expressions "
            "from untrusted sources. ",
        ),
        "W0150": (
            "%s statement in finally block may swallow exception",
            "lost-exception",
            "Used when a break or a return statement is found inside the "
            "finally clause of a try...finally block: the exceptions raised "
            "in the try clause will be silently swallowed instead of being "
            "re-raised.",
        ),
        "W0199": (
            "Assert called on a 2-item-tuple. Did you mean 'assert x,y'?",
            "assert-on-tuple",
            "A call of assert on a tuple will always evaluate to true if "
            "the tuple is not empty, and will always evaluate to false if "
            "it is.",
        ),
        "W0124": (
            'Following "as" with another context manager looks like a tuple.',
            "confusing-with-statement",
            "Emitted when a `with` statement component returns multiple values "
            "and uses name binding with `as` only for a part of those values, "
            "as in with ctx() as a, b. This can be misleading, since it's not "
            "clear if the context manager returns a tuple or if the node without "
            "a name binding is another context manager.",
        ),
        "W0125": (
            "Using a conditional statement with a constant value",
            "using-constant-test",
            "Emitted when a conditional statement (If or ternary if) "
            "uses a constant value for its test. This might not be what "
            "the user intended to do.",
        ),
        "W0126": (
            "Using a conditional statement with potentially wrong function or method call due to missing parentheses",
            "missing-parentheses-for-call-in-test",
            "Emitted when a conditional statement (If or ternary if) "
            "seems to wrongly call a function due to missing parentheses",
        ),
        "W0127": (
            "Assigning the same variable %r to itself",
            "self-assigning-variable",
            "Emitted when we detect that a variable is assigned to itself",
        ),
        "W0128": (
            "Redeclared variable %r in assignment",
            "redeclared-assigned-name",
            "Emitted when we detect that a variable was redeclared in the same assignment.",
        ),
        "E0111": (
            "The first reversed() argument is not a sequence",
            "bad-reversed-sequence",
            "Used when the first argument to reversed() builtin "
            "isn't a sequence (does not implement __reversed__, "
            "nor __getitem__ and __len__",
        ),
        "E0119": (
            "format function is not called on str",
            "misplaced-format-function",
            "Emitted when format function is not called on str object. "
            'e.g doing print("value: {}").format(123) instead of '
            'print("value: {}".format(123)). This might not be what the user '
            "intended to do.",
        ),
        "W0129": (
            "Assert statement has a string literal as its first argument. The assert will %s fail.",
            "assert-on-string-literal",
            "Used when an assert statement has a string literal as its first argument, which will "
            "cause the assert to always pass.",
        ),
    }

    reports = (("RP0101", "Statistics by type", report_by_type_stats),)

    @others
</t>
<t tx="ekr.20220312061835.1110">def __init__(self, linter=None):
    BaseTokenChecker.__init__(self, linter)
    self._init()

</t>
<t tx="ekr.20220312061835.1111">def _init(self):
    self._elifs = []
    self._if_counter = 0

</t>
<t tx="ekr.20220312061835.1112">def process_tokens(self, tokens):
    # Process tokens and look for 'if' or 'elif'
    for _, token, _, _, _ in tokens:
        if token == "elif":
            self._elifs.append(True)
        elif token == "if":
            self._elifs.append(False)

</t>
<t tx="ekr.20220312061835.1113">def leave_module(self, _: nodes.Module) -&gt; None:
    self._init()

</t>
<t tx="ekr.20220312061835.1114">def visit_ifexp(self, node: nodes.IfExp) -&gt; None:
    if isinstance(node.parent, nodes.FormattedValue):
        return
    self._if_counter += 1

</t>
<t tx="ekr.20220312061835.1115">def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:
    self._if_counter += len(node.ifs)

</t>
<t tx="ekr.20220312061835.1116">@check_messages("else-if-used")
def visit_if(self, node: nodes.If) -&gt; None:
    if isinstance(node.parent, nodes.If):
        orelse = node.parent.orelse
        # current if node must directly follow an "else"
        if orelse and orelse == [node]:
            if not self._elifs[self._if_counter]:
                self.add_message("else-if-used", node=node)
    self._if_counter += 1


</t>
<t tx="ekr.20220312061835.1117">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(ElseifUsedChecker(linter))
</t>
<t tx="ekr.20220312061835.1118">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
import sys
from typing import List, Optional, Set, Tuple, Type, Union, cast

from astroid import nodes

from pylint.checkers import BaseChecker, utils
from pylint.checkers.utils import check_messages, safe_infer
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter
from pylint.utils.utils import get_global_option

if sys.version_info &gt;= (3, 10):
    from typing import TypeGuard
else:
    from typing_extensions import TypeGuard


@others
</t>
<t tx="ekr.20220312061835.1119">class CodeStyleChecker(BaseChecker):
    """Checkers that can improve code consistency.

    As such they don't necessarily provide a performance benefit and
    are often times opinionated.

    Before adding another checker here, consider this:
    1. Does the checker provide a clear benefit,
       i.e. detect a common issue or improve performance
       =&gt; it should probably be part of the core checker classes
    2. Is it something that would improve code consistency,
       maybe because it's slightly better with regards to performance
       and therefore preferred =&gt; this is the right place
    3. Everything else should go into another extension
    """

    __implements__ = (IAstroidChecker,)

    name = "code_style"
    priority = -1
    msgs = {
        "R6101": (
            "Consider using namedtuple or dataclass for dictionary values",
            "consider-using-namedtuple-or-dataclass",
            "Emitted when dictionary values can be replaced by namedtuples or dataclass instances.",
        ),
        "R6102": (
            "Consider using an in-place tuple instead of list",
            "consider-using-tuple",
            "Only for style consistency! "
            "Emitted where an in-place defined ``list`` can be replaced by a ``tuple``. "
            "Due to optimizations by CPython, there is no performance benefit from it.",
        ),
        "R6103": (
            "Use '%s' instead",
            "consider-using-assignment-expr",
            "Emitted when an if assignment is directly followed by an if statement and "
            "both can be combined by using an assignment expression ``:=``. "
            "Requires Python 3.8",
        ),
    }
    options = (
        (
            "max-line-length-suggestions",
            {
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": (
                    "Max line length for which to sill emit suggestions. "
                    "Used to prevent optional suggestions which would get split "
                    "by a code formatter (e.g., black). "
                    "Will default to the setting for ``max-line-length``."
                ),
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.112">def __init__(self, linter):
    _BasicChecker.__init__(self, linter)
    self.stats: CheckerStats = {}
    self._tryfinallys = None

</t>
<t tx="ekr.20220312061835.1120">def __init__(self, linter: PyLinter) -&gt; None:
    """Initialize checker instance."""
    super().__init__(linter=linter)

</t>
<t tx="ekr.20220312061835.1121">def open(self) -&gt; None:
    py_version = get_global_option(self, "py-version")
    self._py38_plus = py_version &gt;= (3, 8)
    self._max_length: int = (
        self.config.max_line_length_suggestions
        or get_global_option(self, "max-line-length")
    )

</t>
<t tx="ekr.20220312061835.1122">@check_messages("consider-using-namedtuple-or-dataclass")
def visit_dict(self, node: nodes.Dict) -&gt; None:
    self._check_dict_consider_namedtuple_dataclass(node)

</t>
<t tx="ekr.20220312061835.1123">@check_messages("consider-using-tuple")
def visit_for(self, node: nodes.For) -&gt; None:
    if isinstance(node.iter, nodes.List):
        self.add_message("consider-using-tuple", node=node.iter)

</t>
<t tx="ekr.20220312061835.1124">@check_messages("consider-using-tuple")
def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:
    if isinstance(node.iter, nodes.List):
        self.add_message("consider-using-tuple", node=node.iter)

</t>
<t tx="ekr.20220312061835.1125">@check_messages("consider-using-assignment-expr")
def visit_if(self, node: nodes.If) -&gt; None:
    if self._py38_plus:
        self._check_consider_using_assignment_expr(node)

</t>
<t tx="ekr.20220312061835.1126">def _check_dict_consider_namedtuple_dataclass(self, node: nodes.Dict) -&gt; None:
    """Check if dictionary values can be replaced by Namedtuple or Dataclass."""
    if not (
        isinstance(node.parent, (nodes.Assign, nodes.AnnAssign))
        and isinstance(node.parent.parent, nodes.Module)
        or isinstance(node.parent, nodes.AnnAssign)
        and isinstance(node.parent.target, nodes.AssignName)
        and utils.is_assign_name_annotated_with(node.parent.target, "Final")
    ):
        # If dict is not part of an 'Assign' or 'AnnAssign' node in
        # a module context OR 'AnnAssign' with 'Final' annotation, skip check.
        return

    # All dict_values are itself dict nodes
    if len(node.items) &gt; 1 and all(
        isinstance(dict_value, nodes.Dict) for _, dict_value in node.items
    ):
        KeyTupleT = Tuple[Type[nodes.NodeNG], str]

        # Makes sure all keys are 'Const' string nodes
        keys_checked: Set[KeyTupleT] = set()
        for _, dict_value in node.items:
            dict_value = cast(nodes.Dict, dict_value)
            for key, _ in dict_value.items:
                key_tuple = (type(key), key.as_string())
                if key_tuple in keys_checked:
                    continue
                inferred = safe_infer(key)
                if not (
                    isinstance(inferred, nodes.Const)
                    and inferred.pytype() == "builtins.str"
                ):
                    return
                keys_checked.add(key_tuple)

        # Makes sure all subdicts have at least 1 common key
        key_tuples: List[Tuple[KeyTupleT, ...]] = []
        for _, dict_value in node.items:
            dict_value = cast(nodes.Dict, dict_value)
            key_tuples.append(
                tuple((type(key), key.as_string()) for key, _ in dict_value.items)
            )
        keys_intersection: Set[KeyTupleT] = set(key_tuples[0])
        for sub_key_tuples in key_tuples[1:]:
            keys_intersection.intersection_update(sub_key_tuples)
        if not keys_intersection:
            return

        self.add_message("consider-using-namedtuple-or-dataclass", node=node)
        return

    # All dict_values are itself either list or tuple nodes
    if len(node.items) &gt; 1 and all(
        isinstance(dict_value, (nodes.List, nodes.Tuple))
        for _, dict_value in node.items
    ):
        # Make sure all sublists have the same length &gt; 0
        list_length = len(node.items[0][1].elts)
        if list_length == 0:
            return
        for _, dict_value in node.items[1:]:
            dict_value = cast(Union[nodes.List, nodes.Tuple], dict_value)
            if len(dict_value.elts) != list_length:
                return

        # Make sure at least one list entry isn't a dict
        for _, dict_value in node.items:
            dict_value = cast(Union[nodes.List, nodes.Tuple], dict_value)
            if all(isinstance(entry, nodes.Dict) for entry in dict_value.elts):
                return

        self.add_message("consider-using-namedtuple-or-dataclass", node=node)
        return

</t>
<t tx="ekr.20220312061835.1127">def _check_consider_using_assignment_expr(self, node: nodes.If) -&gt; None:
    """Check if an assignment expression (walrus operator) can be used.

    For example if an assignment is directly followed by an if statment:
    &gt;&gt;&gt; x = 2
    &gt;&gt;&gt; if x:
    &gt;&gt;&gt;     ...

    Can be replaced by:
    &gt;&gt;&gt; if (x := 2):
    &gt;&gt;&gt;     ...

    Note: Assignment expressions were added in Python 3.8
    """
    # Check if `node.test` contains a `Name` node
    node_name: Optional[nodes.Name] = None
    if isinstance(node.test, nodes.Name):
        node_name = node.test
    elif (
        isinstance(node.test, nodes.UnaryOp)
        and node.test.op == "not"
        and isinstance(node.test.operand, nodes.Name)
    ):
        node_name = node.test.operand
    elif (
        isinstance(node.test, nodes.Compare)
        and isinstance(node.test.left, nodes.Name)
        and len(node.test.ops) == 1
    ):
        node_name = node.test.left
    else:
        return

    # Make sure the previous node is an assignment to the same name
    # used in `node.test`. Furthermore, ignore if assignment spans multiple lines.
    prev_sibling = node.previous_sibling()
    if CodeStyleChecker._check_prev_sibling_to_if_stmt(
        prev_sibling, node_name.name
    ):

        # Check if match statement would be a better fit.
        # I.e. multiple ifs that test the same name.
        if CodeStyleChecker._check_ignore_assignment_expr_suggestion(
            node, node_name.name
        ):
            return

        # Build suggestion string. Check length of suggestion
        # does not exceed max-line-length-suggestions
        test_str = node.test.as_string().replace(
            node_name.name,
            f"({node_name.name} := {prev_sibling.value.as_string()})",
            1,
        )
        suggestion = f"if {test_str}:"
        if (
            node.col_offset is not None
            and len(suggestion) + node.col_offset &gt; self._max_length
            or len(suggestion) &gt; self._max_length
        ):
            return

        self.add_message(
            "consider-using-assignment-expr",
            node=node_name,
            args=(suggestion,),
        )

</t>
<t tx="ekr.20220312061835.1128">@staticmethod
def _check_prev_sibling_to_if_stmt(
    prev_sibling: Optional[nodes.NodeNG], name: Optional[str]
) -&gt; TypeGuard[Union[nodes.Assign, nodes.AnnAssign]]:
    """Check if previous sibling is an assignment with the same name.
    Ignore statements which span multiple lines.
    """
    if prev_sibling is None or prev_sibling.tolineno - prev_sibling.fromlineno != 0:
        return False

    if (
        isinstance(prev_sibling, nodes.Assign)
        and len(prev_sibling.targets) == 1
        and isinstance(prev_sibling.targets[0], nodes.AssignName)
        and prev_sibling.targets[0].name == name
    ):
        return True
    if (
        isinstance(prev_sibling, nodes.AnnAssign)
        and isinstance(prev_sibling.target, nodes.AssignName)
        and prev_sibling.target.name == name
    ):
        return True
    return False

</t>
<t tx="ekr.20220312061835.1129">@staticmethod
def _check_ignore_assignment_expr_suggestion(
    node: nodes.If, name: Optional[str]
) -&gt; bool:
    """Return True if suggestion for assignment expr should be ignore.

    E.g., in cases where a match statement would be a better fit
    (multiple conditions).
    """
    if isinstance(node.test, nodes.Compare):
        next_if_node: Optional[nodes.If] = None
        next_sibling = node.next_sibling()
        if len(node.orelse) == 1 and isinstance(node.orelse[0], nodes.If):
            # elif block
            next_if_node = node.orelse[0]
        elif isinstance(next_sibling, nodes.If):
            # separate if block
            next_if_node = next_sibling

        if (  # pylint: disable=too-many-boolean-expressions
            next_if_node is not None
            and (
                isinstance(next_if_node.test, nodes.Compare)
                and isinstance(next_if_node.test.left, nodes.Name)
                and next_if_node.test.left.name == name
                or isinstance(next_if_node.test, nodes.Name)
                and next_if_node.test.name == name
            )
        ):
            return True
    return False


</t>
<t tx="ekr.20220312061835.113">def open(self):
    """initialize visit variables and statistics"""
    self._tryfinallys = []
    self.stats = self.linter.add_stats(module=0, function=0, method=0, class_=0)

</t>
<t tx="ekr.20220312061835.1130">def register(linter: PyLinter) -&gt; None:
    linter.register_checker(CodeStyleChecker(linter))
</t>
<t tx="ekr.20220312061835.1131">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2017-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 bernie gray &lt;bfgray3@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Looks for comparisons to zero."""

import itertools
from typing import Any, Iterable

import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.1132">def _is_constant_zero(node):
    return isinstance(node, astroid.Const) and node.value == 0


</t>
<t tx="ekr.20220312061835.1133">class CompareToZeroChecker(checkers.BaseChecker):
    """Checks for comparisons to zero.
    Most of the times you should use the fact that integers with a value of 0 are false.
    An exception to this rule is when 0 is allowed in the program and has a
    different meaning than None!
    """

    __implements__ = (interfaces.IAstroidChecker,)

    # configuration section name
    name = "compare-to-zero"
    msgs = {
        "C2001": (
            "Avoid comparisons to zero",
            "compare-to-zero",
            "Used when Pylint detects comparison to a 0 constant.",
        )
    }

    priority = -2
    options = ()

    @others
</t>
<t tx="ekr.20220312061835.1134">@utils.check_messages("compare-to-zero")
def visit_compare(self, node: nodes.Compare) -&gt; None:
    _operators = ["!=", "==", "is not", "is"]
    # note: astroid.Compare has the left most operand in node.left
    # while the rest are a list of tuples in node.ops
    # the format of the tuple is ('compare operator sign', node)
    # here we squash everything into `ops` to make it easier for processing later
    ops = [("", node.left)]
    ops.extend(node.ops)
    iter_ops: Iterable[Any] = iter(ops)
    ops = list(itertools.chain(*iter_ops))

    for ops_idx in range(len(ops) - 2):
        op_1 = ops[ops_idx]
        op_2 = ops[ops_idx + 1]
        op_3 = ops[ops_idx + 2]
        error_detected = False

        # 0 ?? X
        if _is_constant_zero(op_1) and op_2 in _operators:
            error_detected = True
        # X ?? 0
        elif op_2 in _operators and _is_constant_zero(op_3):
            error_detected = True

        if error_detected:
            self.add_message("compare-to-zero", node=node)


</t>
<t tx="ekr.20220312061835.1135">def register(linter):
    """Required method to auto register this checker."""
    linter.register_checker(CompareToZeroChecker(linter))
</t>
<t tx="ekr.20220312061835.1136">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter


@others
</t>
<t tx="ekr.20220312061835.1137">class ConfusingConsecutiveElifChecker(BaseChecker):
    """Checks if "elif" is used right after an indented block that finishes with "if" or "elif" itself."""

    __implements__ = IAstroidChecker

    name = "confusing_elif"
    priority = -1
    msgs = {
        "R5601": (
            "Consecutive elif with differing indentation level, consider creating a function to separate the inner elif",
            "confusing-consecutive-elif",
            "Used when an elif statement follows right after an indented block which itself ends with if or elif. "
            "It may not be ovious if the elif statement was willingly or mistakenly unindented. "
            "Extracting the indented if statement into a separate function might avoid confusion and prevent errors.",
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.1138">@check_messages("confusing-consecutive-elif")
def visit_if(self, node: nodes.If) -&gt; None:
    body_ends_with_if = isinstance(
        node.body[-1], nodes.If
    ) and self._has_no_else_clause(node.body[-1])
    if node.has_elif_block() and body_ends_with_if:
        self.add_message("confusing-consecutive-elif", node=node.orelse[0])

</t>
<t tx="ekr.20220312061835.1139">@staticmethod
def _has_no_else_clause(node: nodes.If):
    orelse = node.orelse
    while orelse and isinstance(orelse[0], nodes.If):
        orelse = orelse[0].orelse
    if not orelse or isinstance(orelse[0], nodes.If):
        return True
    return False


</t>
<t tx="ekr.20220312061835.114">@utils.check_messages("using-constant-test", "missing-parentheses-for-call-in-test")
def visit_if(self, node: nodes.If) -&gt; None:
    self._check_using_constant_test(node, node.test)

</t>
<t tx="ekr.20220312061835.1140">def register(linter: PyLinter):
    """This required method auto registers the checker.

    :param linter: The linter to register the checker to.
    :type linter: pylint.lint.PyLinter
    """
    linter.register_checker(ConfusingConsecutiveElifChecker(linter))
</t>
<t tx="ekr.20220312061835.1141">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
"""Check for if / assign blocks that can be rewritten with if-expressions."""

from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.interfaces import IAstroidChecker


@others
</t>
<t tx="ekr.20220312061835.1142">class ConsiderTernaryExpressionChecker(BaseChecker):

    __implements__ = (IAstroidChecker,)
    name = "consider_ternary_expression"
    msgs = {
        "W0160": (
            "Consider rewriting as a ternary expression",
            "consider-ternary-expression",
            "Multiple assign statements spread across if/else blocks can be "
            "rewritten with a single assingment and ternary expression",
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.1143">def visit_if(self, node: nodes.If) -&gt; None:
    if isinstance(node.parent, nodes.If):
        return

    if len(node.body) != 1 or len(node.orelse) != 1:
        return

    bst = node.body[0]
    ost = node.orelse[0]

    if not isinstance(bst, nodes.Assign) or not isinstance(ost, nodes.Assign):
        return

    for (bname, oname) in zip(bst.targets, ost.targets):
        if not isinstance(bname, nodes.AssignName) or not isinstance(
            oname, nodes.AssignName
        ):
            return

        if bname.name != oname.name:
            return

    self.add_message("consider-ternary-expression", node=node)


</t>
<t tx="ekr.20220312061835.1144">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(ConsiderTernaryExpressionChecker(linter))
</t>
<t tx="ekr.20220312061835.1145">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2014-2015 Bruno Daniel &lt;bruno.daniel@blue-yonder.com&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glmatthe@cisco.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2017 John Paraskevopoulos &lt;io.paraskev@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Adam Dangoor &lt;adamdangoor@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Luigi &lt;luigi.cristofolini@q-ctrl.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2021 SupImDos &lt;62866982+SupImDos@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Logan Miller &lt;14319179+komodo472@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Pylint plugin for checking in Sphinx, Google, or Numpy style docstrings
"""
import re
from typing import Optional

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers import utils as checker_utils
from pylint.extensions import _check_docs_utils as utils
from pylint.extensions._check_docs_utils import Docstring
from pylint.interfaces import IAstroidChecker
from pylint.utils import get_global_option


@others
</t>
<t tx="ekr.20220312061835.1146">class DocstringParameterChecker(BaseChecker):
    """Checker for Sphinx, Google, or Numpy style docstrings

    * Check that all function, method and constructor parameters are mentioned
      in the params and types part of the docstring.  Constructor parameters
      can be documented in either the class docstring or ``__init__`` docstring,
      but not both.
    * Check that there are no naming inconsistencies between the signature and
      the documentation, i.e. also report documented parameters that are missing
      in the signature. This is important to find cases where parameters are
      renamed only in the code, not in the documentation.
    * Check that all explicitly raised exceptions in a function are documented
      in the function docstring. Caught exceptions are ignored.

    Activate this checker by adding the line::

        load-plugins=pylint.extensions.docparams

    to the ``MASTER`` section of your ``.pylintrc``.

    :param linter: linter object
    :type linter: :class:`pylint.lint.PyLinter`
    """

    __implements__ = IAstroidChecker

    name = "parameter_documentation"
    msgs = {
        "W9005": (
            '"%s" has constructor parameters documented in class and __init__',
            "multiple-constructor-doc",
            "Please remove parameter declarations in the class or constructor.",
        ),
        "W9006": (
            '"%s" not documented as being raised',
            "missing-raises-doc",
            "Please document exceptions for all raised exception types.",
        ),
        "W9008": (
            "Redundant returns documentation",
            "redundant-returns-doc",
            "Please remove the return/rtype documentation from this method.",
        ),
        "W9010": (
            "Redundant yields documentation",
            "redundant-yields-doc",
            "Please remove the yields documentation from this method.",
        ),
        "W9011": (
            "Missing return documentation",
            "missing-return-doc",
            "Please add documentation about what this method returns.",
            {"old_names": [("W9007", "old-missing-returns-doc")]},
        ),
        "W9012": (
            "Missing return type documentation",
            "missing-return-type-doc",
            "Please document the type returned by this method.",
            # we can't use the same old_name for two different warnings
            # {'old_names': [('W9007', 'missing-returns-doc')]},
        ),
        "W9013": (
            "Missing yield documentation",
            "missing-yield-doc",
            "Please add documentation about what this generator yields.",
            {"old_names": [("W9009", "old-missing-yields-doc")]},
        ),
        "W9014": (
            "Missing yield type documentation",
            "missing-yield-type-doc",
            "Please document the type yielded by this method.",
            # we can't use the same old_name for two different warnings
            # {'old_names': [('W9009', 'missing-yields-doc')]},
        ),
        "W9015": (
            '"%s" missing in parameter documentation',
            "missing-param-doc",
            "Please add parameter declarations for all parameters.",
            {"old_names": [("W9003", "old-missing-param-doc")]},
        ),
        "W9016": (
            '"%s" missing in parameter type documentation',
            "missing-type-doc",
            "Please add parameter type declarations for all parameters.",
            {"old_names": [("W9004", "old-missing-type-doc")]},
        ),
        "W9017": (
            '"%s" differing in parameter documentation',
            "differing-param-doc",
            "Please check parameter names in declarations.",
        ),
        "W9018": (
            '"%s" differing in parameter type documentation',
            "differing-type-doc",
            "Please check parameter names in type declarations.",
        ),
        "W9019": (
            '"%s" useless ignored parameter documentation',
            "useless-param-doc",
            "Please remove the ignored parameter documentation.",
        ),
        "W9020": (
            '"%s" useless ignored parameter type documentation',
            "useless-type-doc",
            "Please remove the ignored parameter type documentation.",
        ),
    }

    options = (
        (
            "accept-no-param-doc",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Whether to accept totally missing parameter "
                "documentation in the docstring of a function that has "
                "parameters.",
            },
        ),
        (
            "accept-no-raise-doc",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Whether to accept totally missing raises "
                "documentation in the docstring of a function that "
                "raises an exception.",
            },
        ),
        (
            "accept-no-return-doc",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Whether to accept totally missing return "
                "documentation in the docstring of a function that "
                "returns a statement.",
            },
        ),
        (
            "accept-no-yields-doc",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Whether to accept totally missing yields "
                "documentation in the docstring of a generator.",
            },
        ),
        (
            "default-docstring-type",
            {
                "type": "choice",
                "default": "default",
                "choices": list(utils.DOCSTRING_TYPES),
                "help": "If the docstring type cannot be guessed "
                "the specified docstring type will be used.",
            },
        ),
    )

    priority = -2

    constructor_names = {"__init__", "__new__"}
    not_needed_param_in_docstring = {"self", "cls"}

    @others
</t>
<t tx="ekr.20220312061835.1147">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """Called for function and method definitions (def).

    :param node: Node for a function or method definition in the AST
    :type node: :class:`astroid.scoped_nodes.Function`
    """
    node_doc = utils.docstringify(node.doc, self.config.default_docstring_type)

    # skip functions that match the 'no-docstring-rgx' config option
    no_docstring_rgx = get_global_option(self, "no-docstring-rgx")
    if no_docstring_rgx and re.match(no_docstring_rgx, node.name):
        return

    # skip functions smaller than 'docstring-min-length'
    lines = checker_utils.get_node_last_lineno(node) - node.lineno
    max_lines = get_global_option(self, "docstring-min-length")
    if max_lines &gt; -1 and lines &lt; max_lines:
        return

    self.check_functiondef_params(node, node_doc)
    self.check_functiondef_returns(node, node_doc)
    self.check_functiondef_yields(node, node_doc)

</t>
<t tx="ekr.20220312061835.1148">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.1149">def check_functiondef_params(self, node, node_doc):
    node_allow_no_param = None
    if node.name in self.constructor_names:
        class_node = checker_utils.node_frame_class(node)
        if class_node is not None:
            class_doc = utils.docstringify(
                class_node.doc, self.config.default_docstring_type
            )
            self.check_single_constructor_params(class_doc, node_doc, class_node)

            # __init__ or class docstrings can have no parameters documented
            # as long as the other documents them.
            node_allow_no_param = (
                class_doc.has_params()
                or class_doc.params_documented_elsewhere()
                or None
            )
            class_allow_no_param = (
                node_doc.has_params()
                or node_doc.params_documented_elsewhere()
                or None
            )

            self.check_arguments_in_docstring(
                class_doc, node.args, class_node, class_allow_no_param
            )

    self.check_arguments_in_docstring(
        node_doc, node.args, node, node_allow_no_param
    )

</t>
<t tx="ekr.20220312061835.115">@utils.check_messages("using-constant-test", "missing-parentheses-for-call-in-test")
def visit_ifexp(self, node: nodes.IfExp) -&gt; None:
    self._check_using_constant_test(node, node.test)

</t>
<t tx="ekr.20220312061835.1150">def check_functiondef_returns(self, node, node_doc):
    if (not node_doc.supports_yields and node.is_generator()) or node.is_abstract():
        return

    return_nodes = node.nodes_of_class(astroid.Return)
    if (node_doc.has_returns() or node_doc.has_rtype()) and not any(
        utils.returns_something(ret_node) for ret_node in return_nodes
    ):
        self.add_message("redundant-returns-doc", node=node)

</t>
<t tx="ekr.20220312061835.1151">def check_functiondef_yields(self, node, node_doc):
    if not node_doc.supports_yields or node.is_abstract():
        return

    if (
        node_doc.has_yields() or node_doc.has_yields_type()
    ) and not node.is_generator():
        self.add_message("redundant-yields-doc", node=node)

</t>
<t tx="ekr.20220312061835.1152">def visit_raise(self, node: nodes.Raise) -&gt; None:
    func_node = node.frame()
    if not isinstance(func_node, astroid.FunctionDef):
        return

    expected_excs = utils.possible_exc_types(node)

    if not expected_excs:
        return

    if not func_node.doc:
        # If this is a property setter,
        # the property should have the docstring instead.
        property_ = utils.get_setters_property(func_node)
        if property_:
            func_node = property_

    doc = utils.docstringify(func_node.doc, self.config.default_docstring_type)
    if not doc.is_valid():
        if doc.doc:
            self._handle_no_raise_doc(expected_excs, func_node)
        return

    found_excs_full_names = doc.exceptions()

    # Extract just the class name, e.g. "error" from "re.error"
    found_excs_class_names = {exc.split(".")[-1] for exc in found_excs_full_names}
    missing_excs = expected_excs - found_excs_class_names
    self._add_raise_message(missing_excs, func_node)

</t>
<t tx="ekr.20220312061835.1153">def visit_return(self, node: nodes.Return) -&gt; None:
    if not utils.returns_something(node):
        return

    func_node = node.frame()
    if not isinstance(func_node, astroid.FunctionDef):
        return

    doc = utils.docstringify(func_node.doc, self.config.default_docstring_type)
    if not doc.is_valid() and self.config.accept_no_return_doc:
        return

    is_property = checker_utils.decorated_with_property(func_node)

    if not (doc.has_returns() or (doc.has_property_returns() and is_property)):
        self.add_message("missing-return-doc", node=func_node)

    if func_node.returns:
        return

    if not (doc.has_rtype() or (doc.has_property_type() and is_property)):
        self.add_message("missing-return-type-doc", node=func_node)

</t>
<t tx="ekr.20220312061835.1154">def visit_yield(self, node: nodes.Yield) -&gt; None:
    func_node = node.frame()
    if not isinstance(func_node, astroid.FunctionDef):
        return

    doc = utils.docstringify(func_node.doc, self.config.default_docstring_type)
    if not doc.is_valid() and self.config.accept_no_yields_doc:
        return

    if doc.supports_yields:
        doc_has_yields = doc.has_yields()
        doc_has_yields_type = doc.has_yields_type()
    else:
        doc_has_yields = doc.has_returns()
        doc_has_yields_type = doc.has_rtype()

    if not doc_has_yields:
        self.add_message("missing-yield-doc", node=func_node)

    if not (doc_has_yields_type or func_node.returns):
        self.add_message("missing-yield-type-doc", node=func_node)

</t>
<t tx="ekr.20220312061835.1155">def visit_yieldfrom(self, node: nodes.YieldFrom) -&gt; None:
    self.visit_yield(node)

</t>
<t tx="ekr.20220312061835.1156">def _compare_missing_args(
    self,
    found_argument_names,
    message_id,
    not_needed_names,
    expected_argument_names,
    warning_node,
):
    """Compare the found argument names with the expected ones and
    generate a message if there are arguments missing.

    :param found_argument_names: argument names found in the docstring
    :type found_argument_names: set

    :param message_id: pylint message id
    :type message_id: str

    :param not_needed_names: names that may be omitted
    :type not_needed_names: set

    :param expected_argument_names: Expected argument names
    :type expected_argument_names: set

    :param warning_node: The node to be analyzed
    :type warning_node: :class:`astroid.scoped_nodes.Node`
    """
    missing_argument_names = (
        expected_argument_names - found_argument_names
    ) - not_needed_names
    if missing_argument_names:
        self.add_message(
            message_id,
            args=(", ".join(sorted(missing_argument_names)),),
            node=warning_node,
        )

</t>
<t tx="ekr.20220312061835.1157">def _compare_different_args(
    self,
    found_argument_names,
    message_id,
    not_needed_names,
    expected_argument_names,
    warning_node,
):
    """Compare the found argument names with the expected ones and
    generate a message if there are extra arguments found.

    :param found_argument_names: argument names found in the docstring
    :type found_argument_names: set

    :param message_id: pylint message id
    :type message_id: str

    :param not_needed_names: names that may be omitted
    :type not_needed_names: set

    :param expected_argument_names: Expected argument names
    :type expected_argument_names: set

    :param warning_node: The node to be analyzed
    :type warning_node: :class:`astroid.scoped_nodes.Node`
    """
    differing_argument_names = (
        (expected_argument_names ^ found_argument_names)
        - not_needed_names
        - expected_argument_names
    )

    if differing_argument_names:
        self.add_message(
            message_id,
            args=(", ".join(sorted(differing_argument_names)),),
            node=warning_node,
        )

</t>
<t tx="ekr.20220312061835.1158">def _compare_ignored_args(
    self,
    found_argument_names,
    message_id,
    ignored_argument_names,
    warning_node,
):
    """Compare the found argument names with the ignored ones and
    generate a message if there are ignored arguments found.

    :param found_argument_names: argument names found in the docstring
    :type found_argument_names: set

    :param message_id: pylint message id
    :type message_id: str

    :param ignored_argument_names: Expected argument names
    :type ignored_argument_names: set

    :param warning_node: The node to be analyzed
    :type warning_node: :class:`astroid.scoped_nodes.Node`
    """
    existing_ignored_argument_names = ignored_argument_names &amp; found_argument_names

    if existing_ignored_argument_names:
        self.add_message(
            message_id,
            args=(", ".join(sorted(existing_ignored_argument_names)),),
            node=warning_node,
        )

</t>
<t tx="ekr.20220312061835.1159">def check_arguments_in_docstring(
    self,
    doc: Docstring,
    arguments_node: astroid.Arguments,
    warning_node: astroid.NodeNG,
    accept_no_param_doc: Optional[bool] = None,
):
    """Check that all parameters in a function, method or class constructor
    on the one hand and the parameters mentioned in the parameter
    documentation (e.g. the Sphinx tags 'param' and 'type') on the other
    hand are consistent with each other.

    * Undocumented parameters except 'self' are noticed.
    * Undocumented parameter types except for 'self' and the ``*&lt;args&gt;``
      and ``**&lt;kwargs&gt;`` parameters are noticed.
    * Parameters mentioned in the parameter documentation that don't or no
      longer exist in the function parameter list are noticed.
    * If the text "For the parameters, see" or "For the other parameters,
      see" (ignoring additional whitespace) is mentioned in the docstring,
      missing parameter documentation is tolerated.
    * If there's no Sphinx style, Google style or NumPy style parameter
      documentation at all, i.e. ``:param`` is never mentioned etc., the
      checker assumes that the parameters are documented in another format
      and the absence is tolerated.

    :param doc: Docstring for the function, method or class.
    :type doc: :class:`Docstring`

    :param arguments_node: Arguments node for the function, method or
        class constructor.
    :type arguments_node: :class:`astroid.scoped_nodes.Arguments`

    :param warning_node: The node to assign the warnings to
    :type warning_node: :class:`astroid.scoped_nodes.Node`

    :param accept_no_param_doc: Whether or not to allow no parameters
        to be documented.
        If None then this value is read from the configuration.
    :type accept_no_param_doc: bool or None
    """
    # Tolerate missing param or type declarations if there is a link to
    # another method carrying the same name.
    if not doc.doc:
        return

    if accept_no_param_doc is None:
        accept_no_param_doc = self.config.accept_no_param_doc
    tolerate_missing_params = doc.params_documented_elsewhere()

    # Collect the function arguments.
    expected_argument_names = {arg.name for arg in arguments_node.args}
    expected_argument_names.update(arg.name for arg in arguments_node.kwonlyargs)
    not_needed_type_in_docstring = self.not_needed_param_in_docstring.copy()

    expected_but_ignored_argument_names = set()
    ignored_argument_names = get_global_option(self, "ignored-argument-names")
    if ignored_argument_names:
        expected_but_ignored_argument_names = {
            arg
            for arg in expected_argument_names
            if ignored_argument_names.match(arg)
        }

    if arguments_node.vararg is not None:
        expected_argument_names.add(arguments_node.vararg)
        not_needed_type_in_docstring.add(arguments_node.vararg)
    if arguments_node.kwarg is not None:
        expected_argument_names.add(arguments_node.kwarg)
        not_needed_type_in_docstring.add(arguments_node.kwarg)
    params_with_doc, params_with_type = doc.match_param_docs()
    # Tolerate no parameter documentation at all.
    if not params_with_doc and not params_with_type and accept_no_param_doc:
        tolerate_missing_params = True

    if not tolerate_missing_params:
        self._compare_missing_args(
            params_with_doc,
            "missing-param-doc",
            self.not_needed_param_in_docstring
            | expected_but_ignored_argument_names,
            expected_argument_names,
            warning_node,
        )

    # This is before the update of param_with_type because this must check only
    # the type documented in a docstring, not the one using pep484
    # See #4117 and #4593
    self._compare_ignored_args(
        params_with_type,
        "useless-type-doc",
        expected_but_ignored_argument_names,
        warning_node,
    )
    for index, arg_name in enumerate(arguments_node.args):
        if arguments_node.annotations[index]:
            params_with_type.add(arg_name.name)
    for index, arg_name in enumerate(arguments_node.kwonlyargs):
        if arguments_node.kwonlyargs_annotations[index]:
            params_with_type.add(arg_name.name)

    if not tolerate_missing_params:
        self._compare_missing_args(
            params_with_type,
            "missing-type-doc",
            not_needed_type_in_docstring | expected_but_ignored_argument_names,
            expected_argument_names,
            warning_node,
        )

    self._compare_different_args(
        params_with_doc,
        "differing-param-doc",
        self.not_needed_param_in_docstring,
        expected_argument_names,
        warning_node,
    )
    self._compare_different_args(
        params_with_type,
        "differing-type-doc",
        not_needed_type_in_docstring,
        expected_argument_names,
        warning_node,
    )
    self._compare_ignored_args(
        params_with_doc,
        "useless-param-doc",
        expected_but_ignored_argument_names,
        warning_node,
    )

</t>
<t tx="ekr.20220312061835.116">@utils.check_messages("using-constant-test", "missing-parentheses-for-call-in-test")
def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:
    if node.ifs:
        for if_test in node.ifs:
            self._check_using_constant_test(node, if_test)

</t>
<t tx="ekr.20220312061835.1160">def check_single_constructor_params(self, class_doc, init_doc, class_node):
    if class_doc.has_params() and init_doc.has_params():
        self.add_message(
            "multiple-constructor-doc", args=(class_node.name,), node=class_node
        )

</t>
<t tx="ekr.20220312061835.1161">def _handle_no_raise_doc(self, excs, node):
    if self.config.accept_no_raise_doc:
        return

    self._add_raise_message(excs, node)

</t>
<t tx="ekr.20220312061835.1162">def _add_raise_message(self, missing_excs, node):
    """
    Adds a message on :param:`node` for the missing exception type.

    :param missing_excs: A list of missing exception types.
    :type missing_excs: set(str)

    :param node: The node show the message on.
    :type node: nodes.NodeNG
    """
    if node.is_abstract():
        try:
            missing_excs.remove("NotImplementedError")
        except KeyError:
            pass

    if not missing_excs:
        return

    self.add_message(
        "missing-raises-doc", args=(", ".join(sorted(missing_excs)),), node=node
    )


</t>
<t tx="ekr.20220312061835.1163">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(DocstringParameterChecker(linter))
</t>
<t tx="ekr.20220312061835.1164">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Luis Escobar &lt;lescobar@vauxoo.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import linecache

from astroid import nodes

from pylint import checkers
from pylint.checkers.utils import check_messages
from pylint.interfaces import HIGH, IAstroidChecker


@others
</t>
<t tx="ekr.20220312061835.1165">class DocStringStyleChecker(checkers.BaseChecker):
    """Checks format of docstrings based on PEP 0257"""

    __implements__ = IAstroidChecker
    name = "docstyle"

    msgs = {
        "C0198": (
            'Bad docstring quotes in %s, expected """, given %s',
            "bad-docstring-quotes",
            "Used when a docstring does not have triple double quotes.",
        ),
        "C0199": (
            "First line empty in %s docstring",
            "docstring-first-line-empty",
            "Used when a blank line is found at the beginning of a docstring.",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.1166">@check_messages("docstring-first-line-empty", "bad-docstring-quotes")
def visit_module(self, node: nodes.Module) -&gt; None:
    self._check_docstring("module", node)

</t>
<t tx="ekr.20220312061835.1167">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    self._check_docstring("class", node)

</t>
<t tx="ekr.20220312061835.1168">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    ftype = "method" if node.is_method() else "function"
    self._check_docstring(ftype, node)

</t>
<t tx="ekr.20220312061835.1169">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.117">def _check_using_constant_test(self, node, test):
    const_nodes = (
        nodes.Module,
        nodes.GeneratorExp,
        nodes.Lambda,
        nodes.FunctionDef,
        nodes.ClassDef,
        astroid.bases.Generator,
        astroid.UnboundMethod,
        astroid.BoundMethod,
        nodes.Module,
    )
    structs = (nodes.Dict, nodes.Tuple, nodes.Set, nodes.List)

    # These nodes are excepted, since they are not constant
    # values, requiring a computation to happen.
    except_nodes = (
        nodes.Call,
        nodes.BinOp,
        nodes.BoolOp,
        nodes.UnaryOp,
        nodes.Subscript,
    )
    inferred = None
    emit = isinstance(test, (nodes.Const,) + structs + const_nodes)
    if not isinstance(test, except_nodes):
        inferred = utils.safe_infer(test)

    if emit:
        self.add_message("using-constant-test", node=node)
    elif isinstance(inferred, const_nodes):
        # If the constant node is a FunctionDef or Lambda then
        # it may be a illicit function call due to missing parentheses
        call_inferred = None
        try:
            if isinstance(inferred, nodes.FunctionDef):
                call_inferred = inferred.infer_call_result()
            elif isinstance(inferred, nodes.Lambda):
                call_inferred = inferred.infer_call_result(node)
        except astroid.InferenceError:
            call_inferred = None
        if call_inferred:
            try:
                for inf_call in call_inferred:
                    if inf_call != astroid.Uninferable:
                        self.add_message(
                            "missing-parentheses-for-call-in-test", node=node
                        )
                        break
            except astroid.InferenceError:
                pass
        self.add_message("using-constant-test", node=node)

</t>
<t tx="ekr.20220312061835.1170">def _check_docstring(self, node_type, node):
    docstring = node.doc
    if docstring and docstring[0] == "\n":
        self.add_message(
            "docstring-first-line-empty",
            node=node,
            args=(node_type,),
            confidence=HIGH,
        )

    # Use "linecache", instead of node.as_string(), because the latter
    # looses the original form of the docstrings.

    if docstring:
        lineno = node.fromlineno + 1
        line = linecache.getline(node.root().file, lineno).lstrip()
        if line and line.find('"""') == 0:
            return
        if line and "'''" in line:
            quotes = "'''"
        elif line and line[0] == '"':
            quotes = '"'
        elif line and line[0] == "'":
            quotes = "'"
        else:
            quotes = False
        if quotes:
            self.add_message(
                "bad-docstring-quotes",
                node=node,
                args=(node_type, quotes),
                confidence=HIGH,
            )


</t>
<t tx="ekr.20220312061835.1171">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(DocStringStyleChecker(linter))
</t>
<t tx="ekr.20220312061835.1172">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2017-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Looks for  comparisons to empty string."""

import itertools
from typing import Any, Iterable

from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.1173">def _is_constant_empty_str(node):
    return isinstance(node, nodes.Const) and node.value == ""


</t>
<t tx="ekr.20220312061835.1174">class CompareToEmptyStringChecker(checkers.BaseChecker):
    """Checks for comparisons to empty string.
    Most of the times you should use the fact that empty strings are false.
    An exception to this rule is when an empty string value is allowed in the program
    and has a different meaning than None!
    """

    __implements__ = (interfaces.IAstroidChecker,)

    # configuration section name
    name = "compare-to-empty-string"
    msgs = {
        "C1901": (
            "Avoid comparisons to empty string",
            "compare-to-empty-string",
            "Used when Pylint detects comparison to an empty string constant.",
        )
    }

    priority = -2
    options = ()

    @others
</t>
<t tx="ekr.20220312061835.1175">@utils.check_messages("compare-to-empty-string")
def visit_compare(self, node: nodes.Compare) -&gt; None:
    _operators = ["!=", "==", "is not", "is"]
    # note: astroid.Compare has the left most operand in node.left
    # while the rest are a list of tuples in node.ops
    # the format of the tuple is ('compare operator sign', node)
    # here we squash everything into `ops` to make it easier for processing later
    ops = [("", node.left)]
    ops.extend(node.ops)
    iter_ops: Iterable[Any] = iter(ops)
    ops = list(itertools.chain(*iter_ops))

    for ops_idx in range(len(ops) - 2):
        op_1 = ops[ops_idx]
        op_2 = ops[ops_idx + 1]
        op_3 = ops[ops_idx + 2]
        error_detected = False

        # x ?? ""
        if _is_constant_empty_str(op_1) and op_2 in _operators:
            error_detected = True
        # '' ?? X
        elif op_2 in _operators and _is_constant_empty_str(op_3):
            error_detected = True

        if error_detected:
            self.add_message("compare-to-empty-string", node=node)


</t>
<t tx="ekr.20220312061835.1176">def register(linter):
    """Required method to auto register this checker."""
    linter.register_checker(CompareToEmptyStringChecker(linter))
</t>
<t tx="ekr.20220312061835.1177">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.interfaces import IRawChecker


@others
</t>
<t tx="ekr.20220312061835.1178">def is_line_commented(line):
    """Checks if a `# symbol that is not part of a string was found in line"""

    comment_idx = line.find(b"#")
    if comment_idx == -1:
        return False
    if comment_part_of_string(line, comment_idx):
        return is_line_commented(line[:comment_idx] + line[comment_idx + 1 :])
    return True


</t>
<t tx="ekr.20220312061835.1179">def comment_part_of_string(line, comment_idx):
    """checks if the symbol at comment_idx is part of a string"""

    if (
        line[:comment_idx].count(b"'") % 2 == 1
        and line[comment_idx:].count(b"'") % 2 == 1
    ) or (
        line[:comment_idx].count(b'"') % 2 == 1
        and line[comment_idx:].count(b'"') % 2 == 1
    ):
        return True
    return False


</t>
<t tx="ekr.20220312061835.118">def visit_module(self, _: nodes.Module) -&gt; None:
    """check module name, docstring and required arguments"""
    self.stats["module"] += 1  # type: ignore

</t>
<t tx="ekr.20220312061835.1180">class CommentChecker(BaseChecker):
    __implements__ = IRawChecker

    name = "refactoring"
    msgs = {
        "R2044": (
            "Line with empty comment",
            "empty-comment",
            (
                "Used when a # symbol appears on a line not followed by an actual comment"
            ),
        )
    }
    options = ()
    priority = -1  # low priority

    @others
</t>
<t tx="ekr.20220312061835.1181">def process_module(self, node: nodes.Module) -&gt; None:
    with node.stream() as stream:
        for (line_num, line) in enumerate(stream):
            line = line.rstrip()
            if line.endswith(b"#"):
                if not is_line_commented(line[:-1]):
                    self.add_message("empty-comment", line=line_num + 1)


</t>
<t tx="ekr.20220312061835.1182">def register(linter):
    linter.register_checker(CommentChecker(linter))
</t>
<t tx="ekr.20220312061835.1183">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Module to add McCabe checker class for pylint. """

from astroid import nodes
from mccabe import PathGraph as Mccabe_PathGraph
from mccabe import PathGraphingAstVisitor as Mccabe_PathGraphingAstVisitor

from pylint import checkers
from pylint.checkers.utils import check_messages
from pylint.interfaces import HIGH, IAstroidChecker


@others
</t>
<t tx="ekr.20220312061835.1184">class PathGraph(Mccabe_PathGraph):
    def __init__(self, node):
        super().__init__(name="", entity="", lineno=1)
        self.root = node


</t>
<t tx="ekr.20220312061835.1185">class PathGraphingAstVisitor(Mccabe_PathGraphingAstVisitor):
    @others
</t>
<t tx="ekr.20220312061835.1186">def __init__(self):
    super().__init__()
    self._bottom_counter = 0

</t>
<t tx="ekr.20220312061835.1187">def default(self, node, *args):
    for child in node.get_children():
        self.dispatch(child, *args)

</t>
<t tx="ekr.20220312061835.1188">def dispatch(self, node, *args):
    self.node = node
    klass = node.__class__
    meth = self._cache.get(klass)
    if meth is None:
        class_name = klass.__name__
        meth = getattr(self.visitor, "visit" + class_name, self.default)
        self._cache[klass] = meth
    return meth(node, *args)

</t>
<t tx="ekr.20220312061835.1189">def visitFunctionDef(self, node):
    if self.graph is not None:
        # closure
        pathnode = self._append_node(node)
        self.tail = pathnode
        self.dispatch_list(node.body)
        bottom = f"{self._bottom_counter}"
        self._bottom_counter += 1
        self.graph.connect(self.tail, bottom)
        self.graph.connect(node, bottom)
        self.tail = bottom
    else:
        self.graph = PathGraph(node)
        self.tail = node
        self.dispatch_list(node.body)
        self.graphs[f"{self.classname}{node.name}"] = self.graph
        self.reset()

</t>
<t tx="ekr.20220312061835.119">def visit_classdef(self, _: nodes.ClassDef) -&gt; None:
    """check module name, docstring and redefinition
    increment branch counter
    """
    self.stats["class"] += 1  # type: ignore

</t>
<t tx="ekr.20220312061835.1190">visitAsyncFunctionDef = visitFunctionDef

</t>
<t tx="ekr.20220312061835.1191">def visitSimpleStatement(self, node):
    self._append_node(node)

</t>
<t tx="ekr.20220312061835.1192">visitAssert = (
    visitAssign
) = (
    visitAugAssign
) = (
    visitDelete
) = (
    visitPrint
) = (
    visitRaise
) = (
    visitYield
) = (
    visitImport
) = (
    visitCall
) = (
    visitSubscript
) = (
    visitPass
) = (
    visitContinue
) = (
    visitBreak
) = visitGlobal = visitReturn = visitExpr = visitAwait = visitSimpleStatement

</t>
<t tx="ekr.20220312061835.1193">def visitWith(self, node):
    self._append_node(node)
    self.dispatch_list(node.body)

</t>
<t tx="ekr.20220312061835.1194">visitAsyncWith = visitWith

</t>
<t tx="ekr.20220312061835.1195">def _append_node(self, node):
    if not self.tail:
        return None
    self.graph.connect(self.tail, node)
    self.tail = node
    return node

</t>
<t tx="ekr.20220312061835.1196">def _subgraph(self, node, name, extra_blocks=()):
    """create the subgraphs representing any `if` and `for` statements"""
    if self.graph is None:
        # global loop
        self.graph = PathGraph(node)
        self._subgraph_parse(node, node, extra_blocks)
        self.graphs[f"{self.classname}{name}"] = self.graph
        self.reset()
    else:
        self._append_node(node)
        self._subgraph_parse(node, node, extra_blocks)

</t>
<t tx="ekr.20220312061835.1197">def _subgraph_parse(self, node, pathnode, extra_blocks):
    """parse the body and any `else` block of `if` and `for` statements"""
    loose_ends = []
    self.tail = node
    self.dispatch_list(node.body)
    loose_ends.append(self.tail)
    for extra in extra_blocks:
        self.tail = node
        self.dispatch_list(extra.body)
        loose_ends.append(self.tail)
    if node.orelse:
        self.tail = node
        self.dispatch_list(node.orelse)
        loose_ends.append(self.tail)
    else:
        loose_ends.append(node)
    if node:
        bottom = f"{self._bottom_counter}"
        self._bottom_counter += 1
        for end in loose_ends:
            self.graph.connect(end, bottom)
        self.tail = bottom


</t>
<t tx="ekr.20220312061835.1198">class McCabeMethodChecker(checkers.BaseChecker):
    """Checks McCabe complexity cyclomatic threshold in methods and functions
    to validate a too complex code.
    """

    __implements__ = IAstroidChecker
    name = "design"

    msgs = {
        "R1260": (
            "%s is too complex. The McCabe rating is %d",
            "too-complex",
            "Used when a method or function is too complex based on "
            "McCabe Complexity Cyclomatic",
        )
    }
    options = (
        (
            "max-complexity",
            {
                "default": 10,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "McCabe complexity cyclomatic threshold",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.1199">@check_messages("too-complex")
def visit_module(self, node: nodes.Module) -&gt; None:
    """visit an astroid.Module node to check too complex rating and
    add message if is greather than max_complexity stored from options"""
    visitor = PathGraphingAstVisitor()
    for child in node.body:
        visitor.preorder(child, visitor)
    for graph in visitor.graphs.values():
        complexity = graph.complexity()
        node = graph.root
        if hasattr(node, "name"):
            node_name = f"'{node.name}'"
        else:
            node_name = f"This '{node.__class__.__name__.lower()}'"
        if complexity &lt;= self.config.max_complexity:
            continue
        self.add_message(
            "too-complex", node=node, confidence=HIGH, args=(node_name, complexity)
        )


</t>
<t tx="ekr.20220312061835.12">class EmptyReportError(Exception):
    """raised when a report is empty and so should not be displayed"""


</t>
<t tx="ekr.20220312061835.120">@utils.check_messages(
    "pointless-statement", "pointless-string-statement", "expression-not-assigned"
)
</t>
<t tx="ekr.20220312061835.1200">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(McCabeMethodChecker(linter))
</t>
<t tx="ekr.20220312061835.1201">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Looks for overlapping exceptions."""

from typing import Any, List, Tuple

import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils
from pylint.checkers.exceptions import _annotated_unpack_infer


@others
</t>
<t tx="ekr.20220312061835.1202">class OverlappingExceptionsChecker(checkers.BaseChecker):
    """Checks for two or more exceptions in the same exception handler
    clause that are identical or parts of the same inheritance hierarchy
    (i.e. overlapping)."""

    __implements__ = interfaces.IAstroidChecker

    name = "overlap-except"
    msgs = {
        "W0714": (
            "Overlapping exceptions (%s)",
            "overlapping-except",
            "Used when exceptions in handler overlap or are identical",
        )
    }
    priority = -2
    options = ()

    @others
</t>
<t tx="ekr.20220312061835.1203">@utils.check_messages("overlapping-except")
def visit_tryexcept(self, node: nodes.TryExcept) -&gt; None:
    """check for empty except"""
    for handler in node.handlers:
        if handler.type is None:
            continue
        if isinstance(handler.type, astroid.BoolOp):
            continue
        try:
            excs = list(_annotated_unpack_infer(handler.type))
        except astroid.InferenceError:
            continue

        handled_in_clause: List[Tuple[Any, Any]] = []
        for part, exc in excs:
            if exc is astroid.Uninferable:
                continue
            if isinstance(exc, astroid.Instance) and utils.inherit_from_std_ex(exc):
                # pylint: disable=protected-access
                exc = exc._proxied

            if not isinstance(exc, astroid.ClassDef):
                continue

            exc_ancestors = [
                anc for anc in exc.ancestors() if isinstance(anc, astroid.ClassDef)
            ]

            for prev_part, prev_exc in handled_in_clause:
                prev_exc_ancestors = [
                    anc
                    for anc in prev_exc.ancestors()
                    if isinstance(anc, astroid.ClassDef)
                ]
                if exc == prev_exc:
                    self.add_message(
                        "overlapping-except",
                        node=handler.type,
                        args=f"{prev_part.as_string()} and {part.as_string()} are the same",
                    )
                elif prev_exc in exc_ancestors or exc in prev_exc_ancestors:
                    ancestor = part if exc in prev_exc_ancestors else prev_part
                    descendant = part if prev_exc in exc_ancestors else prev_part
                    self.add_message(
                        "overlapping-except",
                        node=handler.type,
                        args=f"{ancestor.as_string()} is an ancestor class of {descendant.as_string()}",
                    )
            handled_in_clause += [(part, exc)]


</t>
<t tx="ekr.20220312061835.1204">def register(linter):
    """Required method to auto register this checker."""
    linter.register_checker(OverlappingExceptionsChecker(linter))
</t>
<t tx="ekr.20220312061835.1205">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glmatthe@cisco.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from typing import List

from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages, is_none, node_type
from pylint.interfaces import IAstroidChecker


@others
</t>
<t tx="ekr.20220312061835.1206">class MultipleTypesChecker(BaseChecker):
    """Checks for variable type redefinitions (NoneType excepted)

    At a function, method, class or module scope

    This rule could be improved:

    - Currently, if an attribute is set to different types in 2 methods of a
      same class, it won't be detected (see functional test)
    - One could improve the support for inference on assignment with tuples,
      ifexpr, etc. Also it would be great to have support for inference on
      str.split()
    """

    __implements__ = IAstroidChecker

    name = "multiple_types"
    msgs = {
        "R0204": (
            "Redefinition of %s type from %s to %s",
            "redefined-variable-type",
            "Used when the type of a variable changes inside a "
            "method or a function.",
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.1207">def visit_classdef(self, _: nodes.ClassDef) -&gt; None:
    self._assigns.append({})

</t>
<t tx="ekr.20220312061835.1208">@check_messages("redefined-variable-type")
def leave_classdef(self, _: nodes.ClassDef) -&gt; None:
    self._check_and_add_messages()

</t>
<t tx="ekr.20220312061835.1209">visit_functiondef = visit_classdef
leave_functiondef = leave_module = leave_classdef

</t>
<t tx="ekr.20220312061835.121">def visit_expr(self, node: nodes.Expr) -&gt; None:
    """Check for various kind of statements without effect"""
    expr = node.value
    if isinstance(expr, nodes.Const) and isinstance(expr.value, str):
        # treat string statement in a separated message
        # Handle PEP-257 attribute docstrings.
        # An attribute docstring is defined as being a string right after
        # an assignment at the module level, class level or __init__ level.
        scope = expr.scope()
        if isinstance(scope, (nodes.ClassDef, nodes.Module, nodes.FunctionDef)):
            if isinstance(scope, nodes.FunctionDef) and scope.name != "__init__":
                pass
            else:
                sibling = expr.previous_sibling()
                if (
                    sibling is not None
                    and sibling.scope() is scope
                    and isinstance(sibling, (nodes.Assign, nodes.AnnAssign))
                ):
                    return
        self.add_message("pointless-string-statement", node=node)
        return

    # Ignore if this is :
    # * a direct function call
    # * the unique child of a try/except body
    # * a yield statement
    # * an ellipsis (which can be used on Python 3 instead of pass)
    # warn W0106 if we have any underlying function call (we can't predict
    # side effects), else pointless-statement
    if (
        isinstance(expr, (nodes.Yield, nodes.Await, nodes.Call))
        or (isinstance(node.parent, nodes.TryExcept) and node.parent.body == [node])
        or (isinstance(expr, nodes.Const) and expr.value is Ellipsis)
    ):
        return
    if any(expr.nodes_of_class(nodes.Call)):
        self.add_message(
            "expression-not-assigned", node=node, args=expr.as_string()
        )
    else:
        self.add_message("pointless-statement", node=node)

</t>
<t tx="ekr.20220312061835.1210">def visit_module(self, _: nodes.Module) -&gt; None:
    self._assigns: List[dict] = [{}]

</t>
<t tx="ekr.20220312061835.1211">def _check_and_add_messages(self):
    assigns = self._assigns.pop()
    for name, args in assigns.items():
        if len(args) &lt;= 1:
            continue
        orig_node, orig_type = args[0]
        # Check if there is a type in the following nodes that would be
        # different from orig_type.
        for redef_node, redef_type in args[1:]:
            if redef_type == orig_type:
                continue
            # if a variable is defined to several types in an if node,
            # this is not actually redefining.
            orig_parent = orig_node.parent
            redef_parent = redef_node.parent
            if isinstance(orig_parent, nodes.If):
                if orig_parent == redef_parent:
                    if (
                        redef_node in orig_parent.orelse
                        and orig_node not in orig_parent.orelse
                    ):
                        orig_node, orig_type = redef_node, redef_type
                        continue
                elif isinstance(
                    redef_parent, nodes.If
                ) and redef_parent in orig_parent.nodes_of_class(nodes.If):
                    orig_node, orig_type = redef_node, redef_type
                    continue
            orig_type = orig_type.replace("builtins.", "")
            redef_type = redef_type.replace("builtins.", "")
            self.add_message(
                "redefined-variable-type",
                node=redef_node,
                args=(name, orig_type, redef_type),
            )
            break

</t>
<t tx="ekr.20220312061835.1212">def visit_assign(self, node: nodes.Assign) -&gt; None:
    # we don't handle multiple assignment nor slice assignment
    target = node.targets[0]
    if isinstance(target, (nodes.Tuple, nodes.Subscript)):
        return
    # ignore NoneType
    if is_none(node):
        return
    _type = node_type(node.value)
    if _type:
        self._assigns[-1].setdefault(target.as_string(), []).append(
            (node, _type.pytype())
        )


</t>
<t tx="ekr.20220312061835.1213">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(MultipleTypesChecker(linter))
</t>
<t tx="ekr.20220312061835.1214">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter


@others
</t>
<t tx="ekr.20220312061835.1215">class SetMembershipChecker(BaseChecker):

    __implements__ = (IAstroidChecker,)

    name = "set_membership"
    priority = -1
    msgs = {
        "R6201": (
            "Consider using set for membership test",
            "use-set-for-membership",
            "Membership tests are more efficient when performed on "
            "a lookup optimized datatype like ``sets``.",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.1216">def __init__(self, linter: PyLinter) -&gt; None:
    """Initialize checker instance."""
    super().__init__(linter=linter)

</t>
<t tx="ekr.20220312061835.1217">@check_messages("use-set-for-membership")
def visit_compare(self, node: nodes.Compare) -&gt; None:
    for op, comparator in node.ops:
        if op == "in":
            self._check_in_comparison(comparator)

</t>
<t tx="ekr.20220312061835.1218">def _check_in_comparison(self, comparator: nodes.NodeNG) -&gt; None:
    """Checks for membership comparisons with in-place container objects."""
    if not isinstance(comparator, nodes.BaseContainer) or isinstance(
        comparator, nodes.Set
    ):
        return

    # Heuristic - We need to be sure all items in set are hashable
    if all(isinstance(item, nodes.Const) for item in comparator.elts):
        self.add_message("use-set-for-membership", node=comparator)


</t>
<t tx="ekr.20220312061835.1219">def register(linter: PyLinter) -&gt; None:
    linter.register_checker(SetMembershipChecker(linter))
</t>
<t tx="ekr.20220312061835.122">@staticmethod
def _filter_vararg(node, call_args):
    # Return the arguments for the given call which are
    # not passed as vararg.
    for arg in call_args:
        if isinstance(arg, nodes.Starred):
            if (
                isinstance(arg.value, nodes.Name)
                and arg.value.name != node.args.vararg
            ):
                yield arg
        else:
            yield arg

</t>
<t tx="ekr.20220312061835.1220">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
from typing import Dict, List, NamedTuple, Set, Union

import astroid.bases
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import (
    check_messages,
    is_node_in_type_annotation_context,
    safe_infer,
)
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter
from pylint.utils.utils import get_global_option


@others
</t>
<t tx="ekr.20220312061835.1221">class TypingAlias(NamedTuple):
    name: str
    name_collision: bool


</t>
<t tx="ekr.20220312061835.1222">DEPRECATED_TYPING_ALIASES: Dict[str, TypingAlias] = {
    "typing.Tuple": TypingAlias("tuple", False),
    "typing.List": TypingAlias("list", False),
    "typing.Dict": TypingAlias("dict", False),
    "typing.Set": TypingAlias("set", False),
    "typing.FrozenSet": TypingAlias("frozenset", False),
    "typing.Type": TypingAlias("type", False),
    "typing.Deque": TypingAlias("collections.deque", True),
    "typing.DefaultDict": TypingAlias("collections.defaultdict", True),
    "typing.OrderedDict": TypingAlias("collections.OrderedDict", True),
    "typing.Counter": TypingAlias("collections.Counter", True),
    "typing.ChainMap": TypingAlias("collections.ChainMap", True),
    "typing.Awaitable": TypingAlias("collections.abc.Awaitable", True),
    "typing.Coroutine": TypingAlias("collections.abc.Coroutine", True),
    "typing.AsyncIterable": TypingAlias("collections.abc.AsyncIterable", True),
    "typing.AsyncIterator": TypingAlias("collections.abc.AsyncIterator", True),
    "typing.AsyncGenerator": TypingAlias("collections.abc.AsyncGenerator", True),
    "typing.Iterable": TypingAlias("collections.abc.Iterable", True),
    "typing.Iterator": TypingAlias("collections.abc.Iterator", True),
    "typing.Generator": TypingAlias("collections.abc.Generator", True),
    "typing.Reversible": TypingAlias("collections.abc.Reversible", True),
    "typing.Container": TypingAlias("collections.abc.Container", True),
    "typing.Collection": TypingAlias("collections.abc.Collection", True),
    "typing.Callable": TypingAlias("collections.abc.Callable", True),
    "typing.AbstractSet": TypingAlias("collections.abc.Set", False),
    "typing.MutableSet": TypingAlias("collections.abc.MutableSet", True),
    "typing.Mapping": TypingAlias("collections.abc.Mapping", True),
    "typing.MutableMapping": TypingAlias("collections.abc.MutableMapping", True),
    "typing.Sequence": TypingAlias("collections.abc.Sequence", True),
    "typing.MutableSequence": TypingAlias("collections.abc.MutableSequence", True),
    "typing.ByteString": TypingAlias("collections.abc.ByteString", True),
    "typing.MappingView": TypingAlias("collections.abc.MappingView", True),
    "typing.KeysView": TypingAlias("collections.abc.KeysView", True),
    "typing.ItemsView": TypingAlias("collections.abc.ItemsView", True),
    "typing.ValuesView": TypingAlias("collections.abc.ValuesView", True),
    "typing.ContextManager": TypingAlias("contextlib.AbstractContextManager", False),
    "typing.AsyncContextManager": TypingAlias(
        "contextlib.AbstractAsyncContextManager", False
    ),
    "typing.Pattern": TypingAlias("re.Pattern", True),
    "typing.Match": TypingAlias("re.Match", True),
    "typing.Hashable": TypingAlias("collections.abc.Hashable", True),
    "typing.Sized": TypingAlias("collections.abc.Sized", True),
}

ALIAS_NAMES = frozenset(key.split(".")[1] for key in DEPRECATED_TYPING_ALIASES)
UNION_NAMES = ("Optional", "Union")


</t>
<t tx="ekr.20220312061835.1223">class DeprecatedTypingAliasMsg(NamedTuple):
    node: Union[nodes.Name, nodes.Attribute]
    qname: str
    alias: str
    parent_subscript: bool


</t>
<t tx="ekr.20220312061835.1224">class TypingChecker(BaseChecker):
    """Find issue specifically related to type annotations."""

    __implements__ = (IAstroidChecker,)

    name = "typing"
    priority = -1
    msgs = {
        "W6001": (
            "'%s' is deprecated, use '%s' instead",
            "deprecated-typing-alias",
            "Emitted when a deprecated typing alias is used.",
        ),
        "R6002": (
            "'%s' will be deprecated with PY39, consider using '%s' instead%s",
            "consider-using-alias",
            "Only emitted if 'runtime-typing=no' and a deprecated "
            "typing alias is used in a type annotation context in "
            "Python 3.7 or 3.8.",
        ),
        "R6003": (
            "Consider using alternative Union syntax instead of '%s'%s",
            "consider-alternative-union-syntax",
            "Emitted when 'typing.Union' or 'typing.Optional' is used "
            "instead of the alternative Union syntax 'int | None'.",
        ),
    }
    options = (
        (
            "runtime-typing",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": (
                    "Set to ``no`` if the app / library does **NOT** need to "
                    "support runtime introspection of type annotations. "
                    "If you use type annotations **exclusively** for type checking "
                    "of an application, you're probably fine. For libraries, "
                    "evaluate if some users what to access the type hints "
                    "at runtime first, e.g., through ``typing.get_type_hints``. "
                    "Applies to Python versions 3.7 - 3.9"
                ),
            },
        ),
    )

    _should_check_typing_alias: bool
    """The use of type aliases (PEP 585) requires Python 3.9
    or Python 3.7+ with postponed evaluation.
    """

    _should_check_alternative_union_syntax: bool
    """The use of alternative union syntax (PEP 604) requires Python 3.10
    or Python 3.7+ with postponed evaluation.
    """

    @others
</t>
<t tx="ekr.20220312061835.1225">def __init__(self, linter: PyLinter) -&gt; None:
    """Initialize checker instance."""
    super().__init__(linter=linter)
    self._alias_name_collisions: Set[str] = set()
    self._consider_using_alias_msgs: List[DeprecatedTypingAliasMsg] = []

</t>
<t tx="ekr.20220312061835.1226">def open(self) -&gt; None:
    py_version = get_global_option(self, "py-version")
    self._py37_plus = py_version &gt;= (3, 7)
    self._py39_plus = py_version &gt;= (3, 9)
    self._py310_plus = py_version &gt;= (3, 10)

    self._should_check_typing_alias = self._py39_plus or (
        self._py37_plus and self.config.runtime_typing is False
    )
    self._should_check_alternative_union_syntax = self._py310_plus or (
        self._py37_plus and self.config.runtime_typing is False
    )

</t>
<t tx="ekr.20220312061835.1227">def _msg_postponed_eval_hint(self, node) -&gt; str:
    """Message hint if postponed evaluation isn't enabled."""
    if self._py310_plus or "annotations" in node.root().future_imports:
        return ""
    return ". Add 'from __future__ import annotations' as well"

</t>
<t tx="ekr.20220312061835.1228">@check_messages(
    "deprecated-typing-alias",
    "consider-using-alias",
    "consider-alternative-union-syntax",
)
</t>
<t tx="ekr.20220312061835.1229">def visit_name(self, node: nodes.Name) -&gt; None:
    if self._should_check_typing_alias and node.name in ALIAS_NAMES:
        self._check_for_typing_alias(node)
    if self._should_check_alternative_union_syntax and node.name in UNION_NAMES:
        self._check_for_alternative_union_syntax(node, node.name)

</t>
<t tx="ekr.20220312061835.123">@staticmethod
def _has_variadic_argument(args, variadic_name):
    if not args:
        return True
    for arg in args:
        if isinstance(arg.value, nodes.Name):
            if arg.value.name != variadic_name:
                return True
        else:
            return True
    return False

</t>
<t tx="ekr.20220312061835.1230">@check_messages(
    "deprecated-typing-alias",
    "consider-using-alias",
    "consider-alternative-union-syntax",
)
</t>
<t tx="ekr.20220312061835.1231">def visit_attribute(self, node: nodes.Attribute) -&gt; None:
    if self._should_check_typing_alias and node.attrname in ALIAS_NAMES:
        self._check_for_typing_alias(node)
    if self._should_check_alternative_union_syntax and node.attrname in UNION_NAMES:
        self._check_for_alternative_union_syntax(node, node.attrname)

</t>
<t tx="ekr.20220312061835.1232">def _check_for_alternative_union_syntax(
    self,
    node: Union[nodes.Name, nodes.Attribute],
    name: str,
) -&gt; None:
    """Check if alternative union syntax could be used.

    Requires
    - Python 3.10
    - OR: Python 3.7+ with postponed evaluation in
          a type annotation context
    """
    inferred = safe_infer(node)
    if not (
        isinstance(inferred, nodes.FunctionDef)
        and inferred.qname()
        in (
            "typing.Optional",
            "typing.Union",
        )
        or isinstance(inferred, astroid.bases.Instance)
        and inferred.qname() == "typing._SpecialForm"
    ):
        return
    if not (self._py310_plus or is_node_in_type_annotation_context(node)):
        return
    self.add_message(
        "consider-alternative-union-syntax",
        node=node,
        args=(name, self._msg_postponed_eval_hint(node)),
    )

</t>
<t tx="ekr.20220312061835.1233">def _check_for_typing_alias(
    self,
    node: Union[nodes.Name, nodes.Attribute],
) -&gt; None:
    """Check if typing alias is depecated or could be replaced.

    Requires
    - Python 3.9
    - OR: Python 3.7+ with postponed evaluation in
          a type annotation context

    For Python 3.7+: Only emitt message if change doesn't create
        any name collisions, only ever used in a type annotation
        context, and can safely be replaced.
    """
    inferred = safe_infer(node)
    if not isinstance(inferred, nodes.ClassDef):
        return
    alias = DEPRECATED_TYPING_ALIASES.get(inferred.qname(), None)
    if alias is None:
        return

    if self._py39_plus:
        self.add_message(
            "deprecated-typing-alias",
            node=node,
            args=(inferred.qname(), alias.name),
        )
        return

    # For PY37+, check for type annotation context first
    if not is_node_in_type_annotation_context(node) and isinstance(
        node.parent, nodes.Subscript
    ):
        if alias.name_collision is True:
            self._alias_name_collisions.add(inferred.qname())
        return
    self._consider_using_alias_msgs.append(
        DeprecatedTypingAliasMsg(
            node,
            inferred.qname(),
            alias.name,
            isinstance(node.parent, nodes.Subscript),
        )
    )

</t>
<t tx="ekr.20220312061835.1234">@check_messages("consider-using-alias")
def leave_module(self, node: nodes.Module) -&gt; None:
    """After parsing of module is complete, add messages for
    'consider-using-alias' check. Make sure results are safe
    to recommend / collision free.
    """
    if self._py37_plus and not self._py39_plus:
        msg_future_import = self._msg_postponed_eval_hint(node)
        for msg in self._consider_using_alias_msgs:
            if msg.qname in self._alias_name_collisions:
                continue
            self.add_message(
                "consider-using-alias",
                node=msg.node,
                args=(
                    msg.qname,
                    msg.alias,
                    msg_future_import if msg.parent_subscript else "",
                ),
            )
    # Clear all module cache variables
    self._alias_name_collisions.clear()
    self._consider_using_alias_msgs.clear()


</t>
<t tx="ekr.20220312061835.1235">def register(linter: PyLinter) -&gt; None:
    linter.register_checker(TypingChecker(linter))
</t>
<t tx="ekr.20220312061835.1236">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
"""Check for use of while loops."""
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker


@others
</t>
<t tx="ekr.20220312061835.1237">class WhileChecker(BaseChecker):

    __implements__ = (IAstroidChecker,)
    name = "while_used"
    msgs = {
        "W0149": (
            "Used `while` loop",
            "while-used",
            "Unbounded `while` loops can often be rewritten as bounded `for` loops.",
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.1238">@check_messages("while-used")
def visit_while(self, node: nodes.While) -&gt; None:
    self.add_message("while-used", node=node)


</t>
<t tx="ekr.20220312061835.1239">def register(linter):
    """Required method to auto register this checker.

    :param linter: Main interface object for Pylint plugins
    :type linter: Pylint object
    """
    linter.register_checker(WhileChecker(linter))
</t>
<t tx="ekr.20220312061835.124">@utils.check_messages("unnecessary-lambda")
def visit_lambda(self, node: nodes.Lambda) -&gt; None:
    """check whether or not the lambda is suspicious"""
    # if the body of the lambda is a call expression with the same
    # argument list as the lambda itself, then the lambda is
    # possibly unnecessary and at least suspicious.
    if node.args.defaults:
        # If the arguments of the lambda include defaults, then a
        # judgment cannot be made because there is no way to check
        # that the defaults defined by the lambda are the same as
        # the defaults defined by the function called in the body
        # of the lambda.
        return
    call = node.body
    if not isinstance(call, nodes.Call):
        # The body of the lambda must be a function call expression
        # for the lambda to be unnecessary.
        return
    if isinstance(node.body.func, nodes.Attribute) and isinstance(
        node.body.func.expr, nodes.Call
    ):
        # Chained call, the intermediate call might
        # return something else (but we don't check that, yet).
        return

    call_site = astroid.arguments.CallSite.from_call(call)
    ordinary_args = list(node.args.args)
    new_call_args = list(self._filter_vararg(node, call.args))
    if node.args.kwarg:
        if self._has_variadic_argument(call.kwargs, node.args.kwarg):
            return

    if node.args.vararg:
        if self._has_variadic_argument(call.starargs, node.args.vararg):
            return
    elif call.starargs:
        return

    if call.keywords:
        # Look for additional keyword arguments that are not part
        # of the lambda's signature
        lambda_kwargs = {keyword.name for keyword in node.args.defaults}
        if len(lambda_kwargs) != len(call_site.keyword_arguments):
            # Different lengths, so probably not identical
            return
        if set(call_site.keyword_arguments).difference(lambda_kwargs):
            return

    # The "ordinary" arguments must be in a correspondence such that:
    # ordinary_args[i].name == call.args[i].name.
    if len(ordinary_args) != len(new_call_args):
        return
    for arg, passed_arg in zip(ordinary_args, new_call_args):
        if not isinstance(passed_arg, nodes.Name):
            return
        if arg.name != passed_arg.name:
            return

    self.add_message("unnecessary-lambda", line=node.fromlineno, node=node)

</t>
<t tx="ekr.20220312061835.1240">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
# Copyright (c) 2016-2019, 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Yuri Bochkarev &lt;baltazar.bz@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 Mitar &lt;mitar.github@tnode.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Mitchell T.H. Young &lt;mitchelly@gmail.com&gt;
# Copyright (c) 2018 Adrian Chirieac &lt;chirieacam@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Danny Hermes &lt;daniel.j.hermes@gmail.com&gt;
# Copyright (c) 2019 Zeb Nicholls &lt;zebedee.nicholls@climate-energy-college.org&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Utility methods for docstring checking."""

import re
from typing import List

import astroid
from astroid import nodes

from pylint.checkers import utils


@others
DOCSTRING_TYPES = {
    "sphinx": SphinxDocstring,
    "epytext": EpytextDocstring,
    "google": GoogleDocstring,
    "numpy": NumpyDocstring,
    "default": Docstring,
}
"""A map of the name of the docstring type to its class.

:type: dict(str, type)
"""
</t>
<t tx="ekr.20220312061835.1241">def space_indentation(s):
    """The number of leading spaces in a string

    :param str s: input string

    :rtype: int
    :return: number of leading spaces
    """
    return len(s) - len(s.lstrip(" "))


</t>
<t tx="ekr.20220312061835.1242">def get_setters_property_name(node):
    """Get the name of the property that the given node is a setter for.

    :param node: The node to get the property name for.
    :type node: str

    :rtype: str or None
    :returns: The name of the property that the node is a setter for,
        or None if one could not be found.
    """
    decorators = node.decorators.nodes if node.decorators else []
    for decorator in decorators:
        if (
            isinstance(decorator, nodes.Attribute)
            and decorator.attrname == "setter"
            and isinstance(decorator.expr, nodes.Name)
        ):
            return decorator.expr.name
    return None


</t>
<t tx="ekr.20220312061835.1243">def get_setters_property(node):
    """Get the property node for the given setter node.

    :param node: The node to get the property for.
    :type node: nodes.FunctionDef

    :rtype: nodes.FunctionDef or None
    :returns: The node relating to the property of the given setter node,
        or None if one could not be found.
    """
    property_ = None

    property_name = get_setters_property_name(node)
    class_node = utils.node_frame_class(node)
    if property_name and class_node:
        class_attrs = class_node.getattr(node.name)
        for attr in class_attrs:
            if utils.decorated_with_property(attr):
                property_ = attr
                break

    return property_


</t>
<t tx="ekr.20220312061835.1244">def returns_something(return_node):
    """Check if a return node returns a value other than None.

    :param return_node: The return node to check.
    :type return_node: astroid.Return

    :rtype: bool
    :return: True if the return node returns a value other than None,
        False otherwise.
    """
    returns = return_node.value

    if returns is None:
        return False

    return not (isinstance(returns, nodes.Const) and returns.value is None)


</t>
<t tx="ekr.20220312061835.1245">def _get_raise_target(node):
    if isinstance(node.exc, nodes.Call):
        func = node.exc.func
        if isinstance(func, (nodes.Name, nodes.Attribute)):
            return utils.safe_infer(func)
    return None


</t>
<t tx="ekr.20220312061835.1246">def _split_multiple_exc_types(target: str) -&gt; List[str]:
    delimiters = r"(\s*,(?:\s*or\s)?\s*|\s+or\s+)"
    return re.split(delimiters, target)


</t>
<t tx="ekr.20220312061835.1247">def possible_exc_types(node):
    """
    Gets all of the possible raised exception types for the given raise node.

    .. note::

        Caught exception types are ignored.


    :param node: The raise node to find exception types for.
    :type node: nodes.NodeNG

    :returns: A list of exception types possibly raised by :param:`node`.
    :rtype: set(str)
    """
    excs = []
    if isinstance(node.exc, nodes.Name):
        inferred = utils.safe_infer(node.exc)
        if inferred:
            excs = [inferred.name]
    elif node.exc is None:
        handler = node.parent
        while handler and not isinstance(handler, nodes.ExceptHandler):
            handler = handler.parent

        if handler and handler.type:
            inferred_excs = astroid.unpack_infer(handler.type)
            excs = (exc.name for exc in inferred_excs if exc is not astroid.Uninferable)
    else:
        target = _get_raise_target(node)
        if isinstance(target, nodes.ClassDef):
            excs = [target.name]
        elif isinstance(target, nodes.FunctionDef):
            for ret in target.nodes_of_class(nodes.Return):
                if ret.frame() != target:
                    # return from inner function - ignore it
                    continue

                val = utils.safe_infer(ret.value)
                if (
                    val
                    and isinstance(val, (astroid.Instance, nodes.ClassDef))
                    and utils.inherit_from_std_ex(val)
                ):
                    excs.append(val.name)

    try:
        return {exc for exc in excs if not utils.node_ignores_exception(node, exc)}
    except astroid.InferenceError:
        return set()


</t>
<t tx="ekr.20220312061835.1248">def docstringify(docstring, default_type="default"):
    for docstring_type in (
        SphinxDocstring,
        EpytextDocstring,
        GoogleDocstring,
        NumpyDocstring,
    ):
        instance = docstring_type(docstring)
        if instance.is_valid():
            return instance

    docstring_type = DOCSTRING_TYPES.get(default_type, Docstring)
    return docstring_type(docstring)


</t>
<t tx="ekr.20220312061835.1249">class Docstring:
    re_for_parameters_see = re.compile(
        r"""
        For\s+the\s+(other)?\s*parameters\s*,\s+see
        """,
        re.X | re.S,
    )

    supports_yields: bool = False
    """True if the docstring supports a "yield" section.

    False if the docstring uses the returns section to document generators.
    """

    @others
</t>
<t tx="ekr.20220312061835.125">@utils.check_messages("dangerous-default-value")
def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """check function name, docstring, arguments, redefinition,
    variable names, max locals
    """
    self.stats["method" if node.is_method() else "function"] += 1  # type: ignore
    self._check_dangerous_default(node)

</t>
<t tx="ekr.20220312061835.1250"># These methods are designed to be overridden
# pylint: disable=no-self-use
def __init__(self, doc):
    doc = doc or ""
    self.doc = doc.expandtabs()

</t>
<t tx="ekr.20220312061835.1251">def __repr__(self) -&gt; str:
    return f"&lt;{self.__class__.__name__}:'''{self.doc}'''&gt;"

</t>
<t tx="ekr.20220312061835.1252">def is_valid(self):
    return False

</t>
<t tx="ekr.20220312061835.1253">def exceptions(self):
    return set()

</t>
<t tx="ekr.20220312061835.1254">def has_params(self):
    return False

</t>
<t tx="ekr.20220312061835.1255">def has_returns(self):
    return False

</t>
<t tx="ekr.20220312061835.1256">def has_rtype(self):
    return False

</t>
<t tx="ekr.20220312061835.1257">def has_property_returns(self):
    return False

</t>
<t tx="ekr.20220312061835.1258">def has_property_type(self):
    return False

</t>
<t tx="ekr.20220312061835.1259">def has_yields(self):
    return False

</t>
<t tx="ekr.20220312061835.126">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.1260">def has_yields_type(self):
    return False

</t>
<t tx="ekr.20220312061835.1261">def match_param_docs(self):
    return set(), set()

</t>
<t tx="ekr.20220312061835.1262">def params_documented_elsewhere(self):
    return self.re_for_parameters_see.search(self.doc) is not None


</t>
<t tx="ekr.20220312061835.1263">class SphinxDocstring(Docstring):
    re_type = r"""
        [~!.]?               # Optional link style prefix
        \w(?:\w|\.[^\.])*    # Valid python name
        """

    re_simple_container_type = fr"""
        {re_type}                     # a container type
        [\(\[] [^\n\s]+ [\)\]]        # with the contents of the container
    """

    re_multiple_simple_type = r"""
        (?:{container_type}|{type})
        (?:(?:\s+(?:of|or)\s+|\s*,\s*)(?:{container_type}|{type}))*
    """.format(
        type=re_type, container_type=re_simple_container_type
    )

    re_xref = fr"""
        (?::\w+:)?                    # optional tag
        `{re_type}`                   # what to reference
        """

    re_param_raw = fr"""
        :                       # initial colon
        (?:                     # Sphinx keywords
        param|parameter|
        arg|argument|
        key|keyword
        )
        \s+                     # whitespace

        (?:                     # optional type declaration
        ({re_type}|{re_simple_container_type})
        \s+
        )?

        (\w+)                   # Parameter name
        \s*                     # whitespace
        :                       # final colon
        """
    re_param_in_docstring = re.compile(re_param_raw, re.X | re.S)

    re_type_raw = fr"""
        :type                           # Sphinx keyword
        \s+                             # whitespace
        ({re_multiple_simple_type})     # Parameter name
        \s*                             # whitespace
        :                               # final colon
        """
    re_type_in_docstring = re.compile(re_type_raw, re.X | re.S)

    re_property_type_raw = fr"""
        :type:                      # Sphinx keyword
        \s+                         # whitespace
        {re_multiple_simple_type}   # type declaration
        """
    re_property_type_in_docstring = re.compile(re_property_type_raw, re.X | re.S)

    re_raise_raw = fr"""
        :                               # initial colon
        (?:                             # Sphinx keyword
        raises?|
        except|exception
        )
        \s+                             # whitespace
        ({re_multiple_simple_type})     # exception type
        \s*                             # whitespace
        :                               # final colon
        """
    re_raise_in_docstring = re.compile(re_raise_raw, re.X | re.S)

    re_rtype_in_docstring = re.compile(r":rtype:")

    re_returns_in_docstring = re.compile(r":returns?:")

    supports_yields = False

    @others
</t>
<t tx="ekr.20220312061835.1264">def is_valid(self):
    return bool(
        self.re_param_in_docstring.search(self.doc)
        or self.re_raise_in_docstring.search(self.doc)
        or self.re_rtype_in_docstring.search(self.doc)
        or self.re_returns_in_docstring.search(self.doc)
        or self.re_property_type_in_docstring.search(self.doc)
    )

</t>
<t tx="ekr.20220312061835.1265">def exceptions(self):
    types = set()

    for match in re.finditer(self.re_raise_in_docstring, self.doc):
        raise_type = match.group(1)
        types.update(_split_multiple_exc_types(raise_type))

    return types

</t>
<t tx="ekr.20220312061835.1266">def has_params(self):
    if not self.doc:
        return False

    return self.re_param_in_docstring.search(self.doc) is not None

</t>
<t tx="ekr.20220312061835.1267">def has_returns(self):
    if not self.doc:
        return False

    return bool(self.re_returns_in_docstring.search(self.doc))

</t>
<t tx="ekr.20220312061835.1268">def has_rtype(self):
    if not self.doc:
        return False

    return bool(self.re_rtype_in_docstring.search(self.doc))

</t>
<t tx="ekr.20220312061835.1269">def has_property_returns(self):
    if not self.doc:
        return False

    # The summary line is the return doc,
    # so the first line must not be a known directive.
    return not self.doc.lstrip().startswith(":")

</t>
<t tx="ekr.20220312061835.127">def _check_dangerous_default(self, node):
    """Check for dangerous default values as arguments."""

    def is_iterable(internal_node):
        return isinstance(internal_node, (nodes.List, nodes.Set, nodes.Dict))

    defaults = node.args.defaults or [] + node.args.kw_defaults or []
    for default in defaults:
        if not default:
            continue
        try:
            value = next(default.infer())
        except astroid.InferenceError:
            continue

        if (
            isinstance(value, astroid.Instance)
            and value.qname() in DEFAULT_ARGUMENT_SYMBOLS
        ):
            if value is default:
                msg = DEFAULT_ARGUMENT_SYMBOLS[value.qname()]
            elif isinstance(value, astroid.Instance) or is_iterable(value):
                # We are here in the following situation(s):
                #   * a dict/set/list/tuple call which wasn't inferred
                #     to a syntax node ({}, () etc.). This can happen
                #     when the arguments are invalid or unknown to
                #     the inference.
                #   * a variable from somewhere else, which turns out to be a list
                #     or a dict.
                if is_iterable(default):
                    msg = value.pytype()
                elif isinstance(default, nodes.Call):
                    msg = f"{value.name}() ({value.qname()})"
                else:
                    msg = f"{default.as_string()} ({value.qname()})"
            else:
                # this argument is a name
                msg = f"{default.as_string()} ({DEFAULT_ARGUMENT_SYMBOLS[value.qname()]})"
            self.add_message("dangerous-default-value", node=node, args=(msg,))

</t>
<t tx="ekr.20220312061835.1270">def has_property_type(self):
    if not self.doc:
        return False

    return bool(self.re_property_type_in_docstring.search(self.doc))

</t>
<t tx="ekr.20220312061835.1271">def match_param_docs(self):
    params_with_doc = set()
    params_with_type = set()

    for match in re.finditer(self.re_param_in_docstring, self.doc):
        name = match.group(2)
        params_with_doc.add(name)
        param_type = match.group(1)
        if param_type is not None:
            params_with_type.add(name)

    params_with_type.update(re.findall(self.re_type_in_docstring, self.doc))
    return params_with_doc, params_with_type


</t>
<t tx="ekr.20220312061835.1272">class EpytextDocstring(SphinxDocstring):
    """
    Epytext is similar to Sphinx. See the docs:
        http://epydoc.sourceforge.net/epytext.html
        http://epydoc.sourceforge.net/fields.html#fields

    It's used in PyCharm:
        https://www.jetbrains.com/help/pycharm/2016.1/creating-documentation-comments.html#d848203e314
        https://www.jetbrains.com/help/pycharm/2016.1/using-docstrings-to-specify-types.html
    """

    re_param_in_docstring = re.compile(
        SphinxDocstring.re_param_raw.replace(":", "@", 1), re.X | re.S
    )

    re_type_in_docstring = re.compile(
        SphinxDocstring.re_type_raw.replace(":", "@", 1), re.X | re.S
    )

    re_property_type_in_docstring = re.compile(
        SphinxDocstring.re_property_type_raw.replace(":", "@", 1), re.X | re.S
    )

    re_raise_in_docstring = re.compile(
        SphinxDocstring.re_raise_raw.replace(":", "@", 1), re.X | re.S
    )

    re_rtype_in_docstring = re.compile(
        r"""
        @                       # initial "at" symbol
        (?:                     # Epytext keyword
        rtype|returntype
        )
        :                       # final colon
        """,
        re.X | re.S,
    )

    re_returns_in_docstring = re.compile(r"@returns?:")

    @others
</t>
<t tx="ekr.20220312061835.1273">def has_property_returns(self):
    if not self.doc:
        return False

    # If this is a property docstring, the summary is the return doc.
    if self.has_property_type():
        # The summary line is the return doc,
        # so the first line must not be a known directive.
        return not self.doc.lstrip().startswith("@")

    return False


</t>
<t tx="ekr.20220312061835.1274">class GoogleDocstring(Docstring):
    re_type = SphinxDocstring.re_type

    re_xref = SphinxDocstring.re_xref

    re_container_type = fr"""
        (?:{re_type}|{re_xref})       # a container type
        [\(\[] [^\n]+ [\)\]]          # with the contents of the container
    """

    re_multiple_type = r"""
        (?:{container_type}|{type}|{xref})
        (?:(?:\s+(?:of|or)\s+|\s*,\s*)(?:{container_type}|{type}|{xref}))*
    """.format(
        type=re_type, xref=re_xref, container_type=re_container_type
    )

    _re_section_template = r"""
        ^([ ]*)   {0} \s*:   \s*$     # Google parameter header
        (  .* )                       # section
        """

    re_param_section = re.compile(
        _re_section_template.format(r"(?:Args|Arguments|Parameters)"),
        re.X | re.S | re.M,
    )

    re_keyword_param_section = re.compile(
        _re_section_template.format(r"Keyword\s(?:Args|Arguments|Parameters)"),
        re.X | re.S | re.M,
    )

    re_param_line = re.compile(
        fr"""
        \s*  \*{{0,2}}(\w+)             # identifier potentially with asterisks
        \s*  ( [(]
            {re_multiple_type}
            (?:,\s+optional)?
            [)] )? \s* :                # optional type declaration
        \s*  (.*)                       # beginning of optional description
    """,
        re.X | re.S | re.M,
    )

    re_raise_section = re.compile(
        _re_section_template.format(r"Raises"), re.X | re.S | re.M
    )

    re_raise_line = re.compile(
        fr"""
        \s*  ({re_multiple_type}) \s* :  # identifier
        \s*  (.*)                        # beginning of optional description
    """,
        re.X | re.S | re.M,
    )

    re_returns_section = re.compile(
        _re_section_template.format(r"Returns?"), re.X | re.S | re.M
    )

    re_returns_line = re.compile(
        fr"""
        \s* ({re_multiple_type}:)?        # identifier
        \s* (.*)                          # beginning of description
    """,
        re.X | re.S | re.M,
    )

    re_property_returns_line = re.compile(
        fr"""
        ^{re_multiple_type}:           # indentifier
        \s* (.*)                       # Summary line / description
    """,
        re.X | re.S | re.M,
    )

    re_yields_section = re.compile(
        _re_section_template.format(r"Yields?"), re.X | re.S | re.M
    )

    re_yields_line = re_returns_line

    supports_yields = True

    @others
</t>
<t tx="ekr.20220312061835.1275">def is_valid(self):
    return bool(
        self.re_param_section.search(self.doc)
        or self.re_raise_section.search(self.doc)
        or self.re_returns_section.search(self.doc)
        or self.re_yields_section.search(self.doc)
        or self.re_property_returns_line.search(self._first_line())
    )

</t>
<t tx="ekr.20220312061835.1276">def has_params(self):
    if not self.doc:
        return False

    return self.re_param_section.search(self.doc) is not None

</t>
<t tx="ekr.20220312061835.1277">def has_returns(self):
    if not self.doc:
        return False

    entries = self._parse_section(self.re_returns_section)
    for entry in entries:
        match = self.re_returns_line.match(entry)
        if not match:
            continue

        return_desc = match.group(2)
        if return_desc:
            return True

    return False

</t>
<t tx="ekr.20220312061835.1278">def has_rtype(self):
    if not self.doc:
        return False

    entries = self._parse_section(self.re_returns_section)
    for entry in entries:
        match = self.re_returns_line.match(entry)
        if not match:
            continue

        return_type = match.group(1)
        if return_type:
            return True

    return False

</t>
<t tx="ekr.20220312061835.1279">def has_property_returns(self):
    # The summary line is the return doc,
    # so the first line must not be a known directive.
    first_line = self._first_line()
    return not bool(
        self.re_param_section.search(first_line)
        or self.re_raise_section.search(first_line)
        or self.re_returns_section.search(first_line)
        or self.re_yields_section.search(first_line)
    )

</t>
<t tx="ekr.20220312061835.128">@utils.check_messages("unreachable", "lost-exception")
def visit_return(self, node: nodes.Return) -&gt; None:
    """1 - check is the node has a right sibling (if so, that's some
    unreachable code)
    2 - check is the node is inside the finally clause of a try...finally
    block
    """
    self._check_unreachable(node)
    # Is it inside final body of a try...finally block ?
    self._check_not_in_finally(node, "return", (nodes.FunctionDef,))

</t>
<t tx="ekr.20220312061835.1280">def has_property_type(self):
    if not self.doc:
        return False

    return bool(self.re_property_returns_line.match(self._first_line()))

</t>
<t tx="ekr.20220312061835.1281">def has_yields(self):
    if not self.doc:
        return False

    entries = self._parse_section(self.re_yields_section)
    for entry in entries:
        match = self.re_yields_line.match(entry)
        if not match:
            continue

        yield_desc = match.group(2)
        if yield_desc:
            return True

    return False

</t>
<t tx="ekr.20220312061835.1282">def has_yields_type(self):
    if not self.doc:
        return False

    entries = self._parse_section(self.re_yields_section)
    for entry in entries:
        match = self.re_yields_line.match(entry)
        if not match:
            continue

        yield_type = match.group(1)
        if yield_type:
            return True

    return False

</t>
<t tx="ekr.20220312061835.1283">def exceptions(self):
    types = set()

    entries = self._parse_section(self.re_raise_section)
    for entry in entries:
        match = self.re_raise_line.match(entry)
        if not match:
            continue

        exc_type = match.group(1)
        exc_desc = match.group(2)
        if exc_desc:
            types.update(_split_multiple_exc_types(exc_type))

    return types

</t>
<t tx="ekr.20220312061835.1284">def match_param_docs(self):
    params_with_doc = set()
    params_with_type = set()

    entries = self._parse_section(self.re_param_section)
    entries.extend(self._parse_section(self.re_keyword_param_section))
    for entry in entries:
        match = self.re_param_line.match(entry)
        if not match:
            continue

        param_name = match.group(1)
        param_type = match.group(2)
        param_desc = match.group(3)
        if param_type:
            params_with_type.add(param_name)

        if param_desc:
            params_with_doc.add(param_name)

    return params_with_doc, params_with_type

</t>
<t tx="ekr.20220312061835.1285">def _first_line(self):
    return self.doc.lstrip().split("\n", 1)[0]

</t>
<t tx="ekr.20220312061835.1286">@staticmethod
def min_section_indent(section_match):
    return len(section_match.group(1)) + 1

</t>
<t tx="ekr.20220312061835.1287">@staticmethod
def _is_section_header(_):
    # Google parsing does not need to detect section headers,
    # because it works off of indentation level only
    return False

</t>
<t tx="ekr.20220312061835.1288">def _parse_section(self, section_re):
    section_match = section_re.search(self.doc)
    if section_match is None:
        return []

    min_indentation = self.min_section_indent(section_match)

    entries = []
    entry = []
    is_first = True
    for line in section_match.group(2).splitlines():
        if not line.strip():
            continue
        indentation = space_indentation(line)
        if indentation &lt; min_indentation:
            break

        # The first line after the header defines the minimum
        # indentation.
        if is_first:
            min_indentation = indentation
            is_first = False

        if indentation == min_indentation:
            if self._is_section_header(line):
                break
            # Lines with minimum indentation must contain the beginning
            # of a new parameter documentation.
            if entry:
                entries.append("\n".join(entry))
                entry = []

        entry.append(line)

    if entry:
        entries.append("\n".join(entry))

    return entries


</t>
<t tx="ekr.20220312061835.1289">class NumpyDocstring(GoogleDocstring):
    _re_section_template = r"""
        ^([ ]*)   {0}   \s*?$          # Numpy parameters header
        \s*     [-=]+   \s*?$          # underline
        (  .* )                        # section
    """

    re_param_section = re.compile(
        _re_section_template.format(r"(?:Args|Arguments|Parameters)"),
        re.X | re.S | re.M,
    )

    re_param_line = re.compile(
        fr"""
        \s*  (\w+)                                                          # identifier
        \s*  :
        \s*  (?:({GoogleDocstring.re_multiple_type})(?:,\s+optional)?)?     # optional type declaration
        \n                                                                  # description starts on a new line
        \s* (.*)                                                            # description
    """,
        re.X | re.S,
    )

    re_raise_section = re.compile(
        _re_section_template.format(r"Raises"), re.X | re.S | re.M
    )

    re_raise_line = re.compile(
        fr"""
        \s* ({GoogleDocstring.re_type})$   # type declaration
        \s* (.*)                           # optional description
    """,
        re.X | re.S | re.M,
    )

    re_returns_section = re.compile(
        _re_section_template.format(r"Returns?"), re.X | re.S | re.M
    )

    re_returns_line = re.compile(
        fr"""
        \s* (?:\w+\s+:\s+)? # optional name
        ({GoogleDocstring.re_multiple_type})$   # type declaration
        \s* (.*)                                # optional description
    """,
        re.X | re.S | re.M,
    )

    re_yields_section = re.compile(
        _re_section_template.format(r"Yields?"), re.X | re.S | re.M
    )

    re_yields_line = re_returns_line

    supports_yields = True

    @others
</t>
<t tx="ekr.20220312061835.129">@utils.check_messages("unreachable")
def visit_continue(self, node: nodes.Continue) -&gt; None:
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    self._check_unreachable(node)

</t>
<t tx="ekr.20220312061835.1290">@staticmethod
def min_section_indent(section_match):
    return len(section_match.group(1))

</t>
<t tx="ekr.20220312061835.1291">@staticmethod
def _is_section_header(line):
    return bool(re.match(r"\s*-+$", line))


</t>
<t tx="ekr.20220312061835.1292">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/extensions/
@language python
@tabwidth -4
</t>
<t tx="ekr.20220312061835.1293"></t>
<t tx="ekr.20220312061835.1294">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
import os
import sys
from typing import List, Pattern, Tuple

from astroid import modutils

from pylint.typing import ErrorDescriptionDict, ModuleDescriptionDict


@others
</t>
<t tx="ekr.20220312061835.1295">def _modpath_from_file(filename, is_namespace, path=None):
    def _is_package_cb(path, parts):
        return modutils.check_modpath_has_init(path, parts) or is_namespace

    return modutils.modpath_from_file_with_callback(
        filename, path=path, is_package_cb=_is_package_cb
    )


</t>
<t tx="ekr.20220312061835.1296">def get_python_path(filepath: str) -&gt; str:
    """TODO This get the python path with the (bad) assumption that there is always
    an __init__.py. This is not true since python 3.3 and is causing problem."""
    dirname = os.path.realpath(os.path.expanduser(filepath))
    if not os.path.isdir(dirname):
        dirname = os.path.dirname(dirname)
    while True:
        if not os.path.exists(os.path.join(dirname, "__init__.py")):
            return dirname
        old_dirname = dirname
        dirname = os.path.dirname(dirname)
        if old_dirname == dirname:
            return os.getcwd()


</t>
<t tx="ekr.20220312061835.1297">def _is_in_ignore_list_re(element: str, ignore_list_re: List[Pattern]) -&gt; bool:
    """determines if the element is matched in a regex ignore-list"""
    for file_pattern in ignore_list_re:
        if file_pattern.match(element):
            return True
    return False


</t>
<t tx="ekr.20220312061835.1298">def expand_modules(
    files_or_modules: List[str],
    ignore_list: List[str],
    ignore_list_re: List[Pattern],
    ignore_list_paths_re: List[Pattern],
) -&gt; Tuple[List[ModuleDescriptionDict], List[ErrorDescriptionDict]]:
    """take a list of files/modules/packages and return the list of tuple
    (file, module name) which have to be actually checked
    """
    result: List[ModuleDescriptionDict] = []
    errors: List[ErrorDescriptionDict] = []
    path = sys.path.copy()

    for something in files_or_modules:
        basename = os.path.basename(something)
        if (
            basename in ignore_list
            or _is_in_ignore_list_re(os.path.basename(something), ignore_list_re)
            or _is_in_ignore_list_re(something, ignore_list_paths_re)
        ):
            continue
        module_path = get_python_path(something)
        additional_search_path = [".", module_path] + path
        if os.path.exists(something):
            # this is a file or a directory
            try:
                modname = ".".join(
                    modutils.modpath_from_file(something, path=additional_search_path)
                )
            except ImportError:
                modname = os.path.splitext(basename)[0]
            if os.path.isdir(something):
                filepath = os.path.join(something, "__init__.py")
            else:
                filepath = something
        else:
            # suppose it's a module or package
            modname = something
            try:
                filepath = modutils.file_from_modpath(
                    modname.split("."), path=additional_search_path
                )
                if filepath is None:
                    continue
            except (ImportError, SyntaxError) as ex:
                # The SyntaxError is a Python bug and should be
                # removed once we move away from imp.find_module: https://bugs.python.org/issue10588
                errors.append({"key": "fatal", "mod": modname, "ex": ex})
                continue
        filepath = os.path.normpath(filepath)
        modparts = (modname or something).split(".")
        try:
            spec = modutils.file_info_from_modpath(
                modparts, path=additional_search_path
            )
        except ImportError:
            # Might not be acceptable, don't crash.
            is_namespace = False
            is_directory = os.path.isdir(something)
        else:
            is_namespace = modutils.is_namespace(spec)
            is_directory = modutils.is_directory(spec)
        if not is_namespace:
            result.append(
                {
                    "path": filepath,
                    "name": modname,
                    "isarg": True,
                    "basepath": filepath,
                    "basename": modname,
                }
            )
        has_init = (
            not (modname.endswith(".__init__") or modname == "__init__")
            and os.path.basename(filepath) == "__init__.py"
        )
        if has_init or is_namespace or is_directory:
            for subfilepath in modutils.get_module_files(
                os.path.dirname(filepath), ignore_list, list_all=is_namespace
            ):
                if filepath == subfilepath:
                    continue
                if _is_in_ignore_list_re(
                    os.path.basename(subfilepath), ignore_list_re
                ) or _is_in_ignore_list_re(subfilepath, ignore_list_paths_re):
                    continue

                modpath = _modpath_from_file(
                    subfilepath, is_namespace, path=additional_search_path
                )
                submodname = ".".join(modpath)
                result.append(
                    {
                        "path": subfilepath,
                        "name": submodname,
                        "isarg": False,
                        "basepath": filepath,
                        "basename": modname,
                    }
                )
    return result, errors
</t>
<t tx="ekr.20220312061835.1299">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
import functools
from typing import TYPE_CHECKING, Any, DefaultDict, Dict, Iterable, List, Tuple, Union

from pylint import reporters
from pylint.lint.utils import _patch_sys_path
from pylint.message import Message
from pylint.typing import CheckerStats, FileItem

if TYPE_CHECKING:
    from typing import Counter  # typing.Counter added in Python 3.6.1

try:
    import multiprocessing
except ImportError:
    multiprocessing = None  # type: ignore

# PyLinter object used by worker processes when checking files using multiprocessing
# should only be used by the worker processes
_worker_linter = None


@others
</t>
<t tx="ekr.20220312061835.13">class InvalidReporterError(Exception):
    """raised when selected reporter is invalid (e.g. not found)"""


</t>
<t tx="ekr.20220312061835.130">@utils.check_messages("unreachable", "lost-exception")
def visit_break(self, node: nodes.Break) -&gt; None:
    """1 - check is the node has a right sibling (if so, that's some
    unreachable code)
    2 - check is the node is inside the finally clause of a try...finally
    block
    """
    # 1 - Is it right sibling ?
    self._check_unreachable(node)
    # 2 - Is it inside final body of a try...finally block ?
    self._check_not_in_finally(node, "break", (nodes.For, nodes.While))

</t>
<t tx="ekr.20220312061835.1300">def _get_new_args(message):
    location = (
        message.abspath,
        message.path,
        message.module,
        message.obj,
        message.line,
        message.column,
    )
    return (message.msg_id, message.symbol, location, message.msg, message.confidence)


</t>
<t tx="ekr.20220312061835.1301">def _merge_stats(stats: List[CheckerStats]):
    merged: CheckerStats = {}
    by_msg: "Counter[str]" = collections.Counter()
    for stat in stats:
        message_stats: Union["Counter[str]", Dict] = stat.pop("by_msg", {})  # type: ignore
        by_msg.update(message_stats)

        for key, item in stat.items():
            if key not in merged:
                merged[key] = item
            elif isinstance(item, dict):
                merged[key].update(item)  # type: ignore
            else:
                merged[key] = merged[key] + item  # type: ignore

    merged["by_msg"] = by_msg
    return merged


</t>
<t tx="ekr.20220312061835.1302">def _worker_initialize(linter, arguments=None):
    global _worker_linter  # pylint: disable=global-statement
    _worker_linter = linter

    # On the worker process side the messages are just collected and passed back to
    # parent process as _worker_check_file function's return value
    _worker_linter.set_reporter(reporters.CollectingReporter())
    _worker_linter.open()

    # Patch sys.path so that each argument is importable just like in single job mode
    _patch_sys_path(arguments or ())


</t>
<t tx="ekr.20220312061835.1303">def _worker_check_single_file(
    file_item: FileItem,
) -&gt; Tuple[int, Any, str, Any, List[Tuple[Any, ...]], Any, Any, DefaultDict[Any, List]]:
    if not _worker_linter:
        raise Exception("Worker linter not yet initialised")
    _worker_linter.open()
    _worker_linter.check_single_file_item(file_item)
    mapreduce_data = collections.defaultdict(list)
    for checker in _worker_linter.get_checkers():
        try:
            data = checker.get_map_data()
        except AttributeError:
            continue
        mapreduce_data[checker.name].append(data)
    msgs = [_get_new_args(m) for m in _worker_linter.reporter.messages]
    _worker_linter.reporter.reset()
    return (
        id(multiprocessing.current_process()),
        _worker_linter.current_name,
        file_item.filepath,
        _worker_linter.file_state.base_name,
        msgs,
        _worker_linter.stats,
        _worker_linter.msg_status,
        mapreduce_data,
    )


</t>
<t tx="ekr.20220312061835.1304">def _merge_mapreduce_data(linter, all_mapreduce_data):
    """Merges map/reduce data across workers, invoking relevant APIs on checkers"""
    # First collate the data, preparing it so we can send it to the checkers for
    # validation. The intent here is to collect all the mapreduce data for all checker-
    # runs across processes - that will then be passed to a static method on the
    # checkers to be reduced and further processed.
    collated_map_reduce_data = collections.defaultdict(list)
    for linter_data in all_mapreduce_data.values():
        for run_data in linter_data:
            for checker_name, data in run_data.items():
                collated_map_reduce_data[checker_name].extend(data)

    # Send the data to checkers that support/require consolidated data
    original_checkers = linter.get_checkers()
    for checker in original_checkers:
        if checker.name in collated_map_reduce_data:
            # Assume that if the check has returned map/reduce data that it has the
            # reducer function
            checker.reduce_map_data(linter, collated_map_reduce_data[checker.name])


</t>
<t tx="ekr.20220312061835.1305">def check_parallel(linter, jobs, files: Iterable[FileItem], arguments=None):
    """Use the given linter to lint the files with given amount of workers (jobs)
    This splits the work filestream-by-filestream. If you need to do work across
    multiple files, as in the similarity-checker, then inherit from MapReduceMixin and
    implement the map/reduce mixin functionality"""
    # The reporter does not need to be passed to worker processes, i.e. the reporter does
    original_reporter = linter.reporter
    linter.reporter = None

    # The linter is inherited by all the pool's workers, i.e. the linter
    # is identical to the linter object here. This is required so that
    # a custom PyLinter object can be used.
    initializer = functools.partial(_worker_initialize, arguments=arguments)
    pool = multiprocessing.Pool(  # pylint: disable=consider-using-with
        jobs, initializer=initializer, initargs=[linter]
    )
    # ..and now when the workers have inherited the linter, the actual reporter
    # can be set back here on the parent process so that results get stored into
    # correct reporter
    linter.set_reporter(original_reporter)
    linter.open()
    try:
        all_stats = []
        all_mapreduce_data = collections.defaultdict(list)

        # Maps each file to be worked on by a single _worker_check_single_file() call,
        # collecting any map/reduce data by checker module so that we can 'reduce' it
        # later.
        for (
            worker_idx,  # used to merge map/reduce data across workers
            module,
            file_path,
            base_name,
            messages,
            stats,
            msg_status,
            mapreduce_data,
        ) in pool.imap_unordered(_worker_check_single_file, files):
            linter.file_state.base_name = base_name
            linter.set_current_module(module, file_path)
            for msg in messages:
                msg = Message(*msg)
                linter.reporter.handle_message(msg)  # type: ignore  # linter.set_reporter() call above makes linter have a reporter attr
            all_stats.append(stats)
            all_mapreduce_data[worker_idx].append(mapreduce_data)
            linter.msg_status |= msg_status
    finally:
        pool.close()
        pool.join()

    _merge_mapreduce_data(linter, all_mapreduce_data)
    linter.stats = _merge_stats([linter.stats] + all_stats)

    # Insert stats data to local checkers.
    for checker in linter.get_checkers():
        if checker is not linter:
            checker.stats = linter.stats
</t>
<t tx="ekr.20220312061835.1306">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
import contextlib
import functools
import operator
import os
import sys
import tokenize
import traceback
import warnings
from io import TextIOWrapper
from typing import Iterable, Iterator, List, Optional, Sequence, Union

import astroid
from astroid import AstroidError, nodes

from pylint import checkers, config, exceptions, interfaces, reporters
from pylint.constants import MAIN_CHECKER_NAME, MSG_TYPES
from pylint.lint.expand_modules import expand_modules
from pylint.lint.parallel import check_parallel
from pylint.lint.report_functions import (
    report_messages_by_module_stats,
    report_messages_stats,
    report_total_messages_stats,
)
from pylint.lint.utils import (
    fix_import_path,
    get_fatal_error_message,
    prepare_crash_report,
)
from pylint.message import MessageDefinitionStore, MessagesHandlerMixIn
from pylint.reporters.ureports import nodes as report_nodes
from pylint.typing import CheckerStats, FileItem, ModuleDescriptionDict
from pylint.utils import ASTWalker, FileState, utils
from pylint.utils.pragma_parser import (
    OPTION_PO,
    InvalidPragmaError,
    UnRecognizedOptionError,
    parse_pragma,
)

MANAGER = astroid.MANAGER


@others
</t>
<t tx="ekr.20220312061835.1307">def _read_stdin():
    # https://mail.python.org/pipermail/python-list/2012-November/634424.html
    sys.stdin = TextIOWrapper(sys.stdin.detach(), encoding="utf-8")
    return sys.stdin.read()


</t>
<t tx="ekr.20220312061835.1308">def _load_reporter_by_class(reporter_class: str) -&gt; type:
    qname = reporter_class
    module_part = astroid.modutils.get_module_part(qname)
    module = astroid.modutils.load_module_from_name(module_part)
    class_name = qname.split(".")[-1]
    return getattr(module, class_name)


</t>
<t tx="ekr.20220312061835.1309"># Python Linter class #########################################################

MSGS = {
    "F0001": (
        "%s",
        "fatal",
        "Used when an error occurred preventing the analysis of a \
              module (unable to find it for instance).",
    ),
    "F0002": (
        "%s: %s",
        "astroid-error",
        "Used when an unexpected error occurred while building the "
        "Astroid  representation. This is usually accompanied by a "
        "traceback. Please report such errors !",
    ),
    "F0010": (
        "error while code parsing: %s",
        "parse-error",
        "Used when an exception occurred while building the Astroid "
        "representation which could be handled by astroid.",
    ),
    "I0001": (
        "Unable to run raw checkers on built-in module %s",
        "raw-checker-failed",
        "Used to inform that a built-in module has not been checked "
        "using the raw checkers.",
    ),
    "I0010": (
        "Unable to consider inline option %r",
        "bad-inline-option",
        "Used when an inline option is either badly formatted or can't "
        "be used inside modules.",
    ),
    "I0011": (
        "Locally disabling %s (%s)",
        "locally-disabled",
        "Used when an inline option disables a message or a messages category.",
    ),
    "I0013": (
        "Ignoring entire file",
        "file-ignored",
        "Used to inform that the file will not be checked",
    ),
    "I0020": (
        "Suppressed %s (from line %d)",
        "suppressed-message",
        "A message was triggered on a line, but suppressed explicitly "
        "by a disable= comment in the file. This message is not "
        "generated for messages that are ignored due to configuration "
        "settings.",
    ),
    "I0021": (
        "Useless suppression of %s",
        "useless-suppression",
        "Reported when a message is explicitly disabled for a line or "
        "a block of code, but never triggered.",
    ),
    "I0022": (
        'Pragma "%s" is deprecated, use "%s" instead',
        "deprecated-pragma",
        "Some inline pylint options have been renamed or reworked, "
        "only the most recent form should be used. "
        "NOTE:skip-all is only available with pylint &gt;= 0.26",
        {"old_names": [("I0014", "deprecated-disable-all")]},
    ),
    "E0001": ("%s", "syntax-error", "Used when a syntax error is raised for a module."),
    "E0011": (
        "Unrecognized file option %r",
        "unrecognized-inline-option",
        "Used when an unknown inline option is encountered.",
    ),
    "E0012": (
        "Bad option value %r",
        "bad-option-value",
        "Used when a bad value for an inline option is encountered.",
    ),
    "E0013": (
        "Plugin '%s' is impossible to load, is it installed ? ('%s')",
        "bad-plugin-value",
        "Used when a bad value is used in 'load-plugins'.",
    ),
}


</t>
<t tx="ekr.20220312061835.131">@utils.check_messages("unreachable")
def visit_raise(self, node: nodes.Raise) -&gt; None:
    """check if the node has a right sibling (if so, that's some unreachable
    code)
    """
    self._check_unreachable(node)

</t>
<t tx="ekr.20220312061835.1310"># pylint: disable=too-many-instance-attributes,too-many-public-methods
class PyLinter(
    config.OptionsManagerMixIn,
    MessagesHandlerMixIn,
    reporters.ReportsHandlerMixIn,
    checkers.BaseTokenChecker,
):
    """lint Python modules using external checkers.

    This is the main checker controlling the other ones and the reports
    generation. It is itself both a raw checker and an astroid checker in order
    to:
    * handle message activation / deactivation at the module level
    * handle some basic but necessary stats'data (number of classes, methods...)

    IDE plugin developers: you may have to call
    `astroid.builder.MANAGER.astroid_cache.clear()` across runs if you want
    to ensure the latest code version is actually checked.

    This class needs to support pickling for parallel linting to work. The exception
    is reporter member; see check_parallel function for more details.
    """

    __implements__ = (interfaces.ITokenChecker,)

    name = MAIN_CHECKER_NAME
    priority = 0
    level = 0
    msgs = MSGS
    # Will be used like this : datetime.now().strftime(crash_file_path)
    crash_file_path: str = "pylint-crash-%Y-%m-%d-%H.txt"

    @others
</t>
<t tx="ekr.20220312061835.1311">@staticmethod
def make_options():
    return (
        (
            "ignore",
            {
                "type": "csv",
                "metavar": "&lt;file&gt;[,&lt;file&gt;...]",
                "dest": "black_list",
                "default": ("CVS",),
                "help": "Files or directories to be skipped. "
                "They should be base names, not paths.",
            },
        ),
        (
            "ignore-patterns",
            {
                "type": "regexp_csv",
                "metavar": "&lt;pattern&gt;[,&lt;pattern&gt;...]",
                "dest": "black_list_re",
                "default": (),
                "help": "Files or directories matching the regex patterns are"
                " skipped. The regex matches against base names, not paths.",
            },
        ),
        (
            "ignore-paths",
            {
                "type": "regexp_csv",
                "metavar": "&lt;pattern&gt;[,&lt;pattern&gt;...]",
                "dest": "ignore_list_paths_re",
                "default": (),
                "help": "Add files or directories matching the regex patterns to the"
                " ignore-list. The regex matches against paths.",
            },
        ),
        (
            "persistent",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "level": 1,
                "help": "Pickle collected data for later comparisons.",
            },
        ),
        (
            "load-plugins",
            {
                "type": "csv",
                "metavar": "&lt;modules&gt;",
                "default": (),
                "level": 1,
                "help": "List of plugins (as comma separated values of "
                "python module names) to load, usually to register "
                "additional checkers.",
            },
        ),
        (
            "output-format",
            {
                "default": "text",
                "type": "string",
                "metavar": "&lt;format&gt;",
                "short": "f",
                "group": "Reports",
                "help": "Set the output format. Available formats are text,"
                " parseable, colorized, json and msvs (visual studio)."
                " You can also give a reporter class, e.g. mypackage.mymodule."
                "MyReporterClass.",
            },
        ),
        (
            "reports",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "short": "r",
                "group": "Reports",
                "help": "Tells whether to display a full report or only the "
                "messages.",
            },
        ),
        (
            "evaluation",
            {
                "type": "string",
                "metavar": "&lt;python_expression&gt;",
                "group": "Reports",
                "level": 1,
                "default": "10.0 - ((float(5 * error + warning + refactor + "
                "convention) / statement) * 10)",
                "help": "Python expression which should return a score less "
                "than or equal to 10. You have access to the variables "
                "'error', 'warning', 'refactor', and 'convention' which "
                "contain the number of messages in each category, as well as "
                "'statement' which is the total number of statements "
                "analyzed. This score is used by the global "
                "evaluation report (RP0004).",
            },
        ),
        (
            "score",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "short": "s",
                "group": "Reports",
                "help": "Activate the evaluation score.",
            },
        ),
        (
            "fail-under",
            {
                "default": 10,
                "type": "float",
                "metavar": "&lt;score&gt;",
                "help": "Specify a score threshold to be exceeded before program exits with error.",
            },
        ),
        (
            "fail-on",
            {
                "default": "",
                "type": "csv",
                "metavar": "&lt;msg ids&gt;",
                "help": "Return non-zero exit code if any of these messages/categories are detected,"
                " even if score is above --fail-under value. Syntax same as enable."
                " Messages specified are enabled, while categories only check already-enabled messages.",
            },
        ),
        (
            "confidence",
            {
                "type": "multiple_choice",
                "metavar": "&lt;levels&gt;",
                "default": "",
                "choices": [c.name for c in interfaces.CONFIDENCE_LEVELS],
                "group": "Messages control",
                "help": "Only show warnings with the listed confidence levels."
                f" Leave empty to show all. Valid levels: {', '.join(c.name for c in interfaces.CONFIDENCE_LEVELS)}.",
            },
        ),
        (
            "enable",
            {
                "type": "csv",
                "metavar": "&lt;msg ids&gt;",
                "short": "e",
                "group": "Messages control",
                "help": "Enable the message, report, category or checker with the "
                "given id(s). You can either give multiple identifier "
                "separated by comma (,) or put this option multiple time "
                "(only on the command line, not in the configuration file "
                "where it should appear only once). "
                'See also the "--disable" option for examples.',
            },
        ),
        (
            "disable",
            {
                "type": "csv",
                "metavar": "&lt;msg ids&gt;",
                "short": "d",
                "group": "Messages control",
                "help": "Disable the message, report, category or checker "
                "with the given id(s). You can either give multiple identifiers "
                "separated by comma (,) or put this option multiple times "
                "(only on the command line, not in the configuration file "
                "where it should appear only once). "
                'You can also use "--disable=all" to disable everything first '
                "and then reenable specific checks. For example, if you want "
                "to run only the similarities checker, you can use "
                '"--disable=all --enable=similarities". '
                "If you want to run only the classes checker, but have no "
                "Warning level messages displayed, use "
                '"--disable=all --enable=classes --disable=W".',
            },
        ),
        (
            "msg-template",
            {
                "type": "string",
                "metavar": "&lt;template&gt;",
                "group": "Reports",
                "help": (
                    "Template used to display messages. "
                    "This is a python new-style format string "
                    "used to format the message information. "
                    "See doc for all details."
                ),
            },
        ),
        (
            "jobs",
            {
                "type": "int",
                "metavar": "&lt;n-processes&gt;",
                "short": "j",
                "default": 1,
                "help": "Use multiple processes to speed up Pylint. Specifying 0 will "
                "auto-detect the number of processors available to use.",
            },
        ),
        (
            "unsafe-load-any-extension",
            {
                "type": "yn",
                "metavar": "&lt;yn&gt;",
                "default": False,
                "hide": True,
                "help": (
                    "Allow loading of arbitrary C extensions. Extensions"
                    " are imported into the active Python interpreter and"
                    " may run arbitrary code."
                ),
            },
        ),
        (
            "limit-inference-results",
            {
                "type": "int",
                "metavar": "&lt;number-of-results&gt;",
                "default": 100,
                "help": (
                    "Control the amount of potential inferred values when inferring "
                    "a single object. This can help the performance when dealing with "
                    "large functions or complex, nested conditions. "
                ),
            },
        ),
        (
            "extension-pkg-allow-list",
            {
                "type": "csv",
                "metavar": "&lt;pkg[,pkg]&gt;",
                "default": [],
                "help": (
                    "A comma-separated list of package or module names"
                    " from where C extensions may be loaded. Extensions are"
                    " loading into the active Python interpreter and may run"
                    " arbitrary code."
                ),
            },
        ),
        (
            "extension-pkg-whitelist",
            {
                "type": "csv",
                "metavar": "&lt;pkg[,pkg]&gt;",
                "default": [],
                "help": (
                    "A comma-separated list of package or module names"
                    " from where C extensions may be loaded. Extensions are"
                    " loading into the active Python interpreter and may run"
                    " arbitrary code. (This is an alternative name to"
                    " extension-pkg-allow-list for backward compatibility.)"
                ),
            },
        ),
        (
            "suggestion-mode",
            {
                "type": "yn",
                "metavar": "&lt;yn&gt;",
                "default": True,
                "help": (
                    "When enabled, pylint would attempt to guess common "
                    "misconfiguration and emit user-friendly hints instead "
                    "of false-positive error messages."
                ),
            },
        ),
        (
            "exit-zero",
            {
                "action": "store_true",
                "help": (
                    "Always return a 0 (non-error) status code, even if "
                    "lint errors are found. This is primarily useful in "
                    "continuous integration scripts."
                ),
            },
        ),
        (
            "from-stdin",
            {
                "action": "store_true",
                "help": (
                    "Interpret the stdin as a python script, whose filename "
                    "needs to be passed as the module_or_package argument."
                ),
            },
        ),
        (
            "py-version",
            {
                "default": sys.version_info[:2],
                "type": "py_version",
                "metavar": "&lt;py_version&gt;",
                "help": (
                    "Min Python version to use for version dependend checks. "
                    "Will default to the version used to run pylint."
                ),
            },
        ),
    )

</t>
<t tx="ekr.20220312061835.1312">option_groups = (
    ("Messages control", "Options controlling analysis messages"),
    ("Reports", "Options related to output formatting and reporting"),
)

</t>
<t tx="ekr.20220312061835.1313">def __init__(self, options=(), reporter=None, option_groups=(), pylintrc=None):
    """Some stuff has to be done before ancestors initialization...
    messages store / checkers / reporter / astroid manager"""
    self.msgs_store = MessageDefinitionStore()
    self.reporter = None
    self._reporter_names = None
    self._reporters = {}
    self._checkers = collections.defaultdict(list)
    self._pragma_lineno = {}
    self._ignore_file = False
    # visit variables
    self.file_state = FileState()
    self.current_name = None
    self.current_file = None
    self.stats: CheckerStats = {}
    self.fail_on_symbols = []
    # init options
    self._external_opts = options
    self.options = options + PyLinter.make_options()
    self.option_groups = option_groups + PyLinter.option_groups
    self._options_methods = {
        "enable": self.enable,
        "disable": self.disable,
        "disable-next": self.disable_next,
    }
    self._bw_options_methods = {
        "disable-msg": self._options_methods["disable"],
        "enable-msg": self._options_methods["enable"],
    }
    MessagesHandlerMixIn.__init__(self)
    reporters.ReportsHandlerMixIn.__init__(self)
    super().__init__(
        usage=__doc__,
        config_file=pylintrc or next(config.find_default_config_files(), None),
    )
    checkers.BaseTokenChecker.__init__(self)
    # provided reports
    self.reports = (
        ("RP0001", "Messages by category", report_total_messages_stats),
        (
            "RP0002",
            "% errors / warnings by module",
            report_messages_by_module_stats,
        ),
        ("RP0003", "Messages", report_messages_stats),
    )
    self.register_checker(self)
    self._dynamic_plugins = set()
    self._error_mode = False
    self.load_provider_defaults()
    if reporter:
        self.set_reporter(reporter)

</t>
<t tx="ekr.20220312061835.1314">def load_default_plugins(self):
    checkers.initialize(self)
    reporters.initialize(self)
    # Make sure to load the default reporter, because
    # the option has been set before the plugins had been loaded.
    if not self.reporter:
        self._load_reporters()

</t>
<t tx="ekr.20220312061835.1315">def load_plugin_modules(self, modnames):
    """take a list of module names which are pylint plugins and load
    and register them
    """
    for modname in modnames:
        if modname in self._dynamic_plugins:
            continue
        self._dynamic_plugins.add(modname)
        try:
            module = astroid.modutils.load_module_from_name(modname)
            module.register(self)
        except ModuleNotFoundError:
            pass

</t>
<t tx="ekr.20220312061835.1316">def load_plugin_configuration(self):
    """Call the configuration hook for plugins

    This walks through the list of plugins, grabs the "load_configuration"
    hook, if exposed, and calls it to allow plugins to configure specific
    settings.
    """
    for modname in self._dynamic_plugins:
        try:
            module = astroid.modutils.load_module_from_name(modname)
            if hasattr(module, "load_configuration"):
                module.load_configuration(self)
        except ModuleNotFoundError as e:
            self.add_message("bad-plugin-value", args=(modname, e), line=0)

</t>
<t tx="ekr.20220312061835.1317">def _load_reporters(self) -&gt; None:
    sub_reporters = []
    output_files = []
    with contextlib.ExitStack() as stack:
        for reporter_name in self._reporter_names.split(","):
            reporter_name, *reporter_output = reporter_name.split(":", 1)

            reporter = self._load_reporter_by_name(reporter_name)
            sub_reporters.append(reporter)

            if reporter_output:
                (reporter_output,) = reporter_output

                # pylint: disable=consider-using-with
                output_file = stack.enter_context(
                    open(reporter_output, "w", encoding="utf-8")
                )

                reporter.set_output(output_file)
                output_files.append(output_file)

        # Extend the lifetime of all opened output files
        close_output_files = stack.pop_all().close

    if len(sub_reporters) &gt; 1 or output_files:
        self.set_reporter(
            reporters.MultiReporter(
                sub_reporters,
                close_output_files,
            )
        )
    else:
        self.set_reporter(sub_reporters[0])

</t>
<t tx="ekr.20220312061835.1318">def _load_reporter_by_name(self, reporter_name: str) -&gt; reporters.BaseReporter:
    name = reporter_name.lower()
    if name in self._reporters:
        return self._reporters[name]()

    try:
        reporter_class = _load_reporter_by_class(reporter_name)
    except (ImportError, AttributeError) as e:
        raise exceptions.InvalidReporterError(name) from e
    else:
        return reporter_class()

</t>
<t tx="ekr.20220312061835.1319">def set_reporter(self, reporter):
    """set the reporter used to display messages and reports"""
    self.reporter = reporter
    reporter.linter = self

</t>
<t tx="ekr.20220312061835.132">def _check_misplaced_format_function(self, call_node):
    if not isinstance(call_node.func, nodes.Attribute):
        return
    if call_node.func.attrname != "format":
        return

    expr = utils.safe_infer(call_node.func.expr)
    if expr is astroid.Uninferable:
        return
    if not expr:
        # we are doubtful on inferred type of node, so here just check if format
        # was called on print()
        call_expr = call_node.func.expr
        if not isinstance(call_expr, nodes.Call):
            return
        if (
            isinstance(call_expr.func, nodes.Name)
            and call_expr.func.name == "print"
        ):
            self.add_message("misplaced-format-function", node=call_node)

</t>
<t tx="ekr.20220312061835.1320">def set_option(self, optname, value, action=None, optdict=None):
    """overridden from config.OptionsProviderMixin to handle some
    special options
    """
    if optname in self._options_methods or optname in self._bw_options_methods:
        if value:
            try:
                meth = self._options_methods[optname]
            except KeyError:
                meth = self._bw_options_methods[optname]
                warnings.warn(
                    f"{optname} is deprecated, replace it by {optname.split('-')[0]}",
                    DeprecationWarning,
                )
            value = utils._check_csv(value)
            if isinstance(value, (list, tuple)):
                for _id in value:
                    meth(_id, ignore_unknown=True)
            else:
                meth(value)
            return  # no need to call set_option, disable/enable methods do it
    elif optname == "output-format":
        self._reporter_names = value
        # If the reporters are already available, load
        # the reporter class.
        if self._reporters:
            self._load_reporters()

    try:
        checkers.BaseTokenChecker.set_option(self, optname, value, action, optdict)
    except config.UnsupportedAction:
        print(f"option {optname} can't be read from config file", file=sys.stderr)

</t>
<t tx="ekr.20220312061835.1321">def register_reporter(self, reporter_class):
    self._reporters[reporter_class.name] = reporter_class

</t>
<t tx="ekr.20220312061835.1322">def report_order(self):
    reports = sorted(self._reports, key=lambda x: getattr(x, "name", ""))
    try:
        # Remove the current reporter and add it
        # at the end of the list.
        reports.pop(reports.index(self))
    except ValueError:
        pass
    else:
        reports.append(self)
    return reports

</t>
<t tx="ekr.20220312061835.1323"># checkers manipulation methods ############################################

</t>
<t tx="ekr.20220312061835.1324">def register_checker(self, checker):
    """register a new checker

    checker is an object implementing IRawChecker or / and IAstroidChecker
    """
    assert checker.priority &lt;= 0, "checker priority can't be &gt;= 0"
    self._checkers[checker.name].append(checker)
    for r_id, r_title, r_cb in checker.reports:
        self.register_report(r_id, r_title, r_cb, checker)
    self.register_options_provider(checker)
    if hasattr(checker, "msgs"):
        self.msgs_store.register_messages_from_checker(checker)
    checker.load_defaults()

    # Register the checker, but disable all of its messages.
    if not getattr(checker, "enabled", True):
        self.disable(checker.name)

</t>
<t tx="ekr.20220312061835.1325">def enable_fail_on_messages(self):
    """enable 'fail on' msgs

    Convert values in config.fail_on (which might be msg category, msg id,
    or symbol) to specific msgs, then enable and flag them for later.
    """
    fail_on_vals = self.config.fail_on
    if not fail_on_vals:
        return

    fail_on_cats = set()
    fail_on_msgs = set()
    for val in fail_on_vals:
        # If value is a cateogry, add category, else add message
        if val in MSG_TYPES:
            fail_on_cats.add(val)
        else:
            fail_on_msgs.add(val)

    # For every message in every checker, if cat or msg flagged, enable check
    for all_checkers in self._checkers.values():
        for checker in all_checkers:
            for msg in checker.messages:
                if msg.msgid in fail_on_msgs or msg.symbol in fail_on_msgs:
                    # message id/symbol matched, enable and flag it
                    self.enable(msg.msgid)
                    self.fail_on_symbols.append(msg.symbol)
                elif msg.msgid[0] in fail_on_cats:
                    # message starts with a cateogry value, flag (but do not enable) it
                    self.fail_on_symbols.append(msg.symbol)

</t>
<t tx="ekr.20220312061835.1326">def any_fail_on_issues(self):
    return (
        self.stats
        and self.stats.get("by_msg") is not None
        and any(x in self.fail_on_symbols for x in self.stats["by_msg"])
    )

</t>
<t tx="ekr.20220312061835.1327">def disable_noerror_messages(self):
    for msgcat, msgids in self.msgs_store._msgs_by_category.items():
        # enable only messages with 'error' severity and above ('fatal')
        if msgcat in ["E", "F"]:
            for msgid in msgids:
                self.enable(msgid)
        else:
            for msgid in msgids:
                self.disable(msgid)

</t>
<t tx="ekr.20220312061835.1328">def disable_reporters(self):
    """disable all reporters"""
    for _reporters in self._reports.values():
        for report_id, _, _ in _reporters:
            self.disable_report(report_id)

</t>
<t tx="ekr.20220312061835.1329">def error_mode(self):
    """error mode: enable only errors; no reports, no persistent"""
    self._error_mode = True
    self.disable_noerror_messages()
    self.disable("miscellaneous")
    self.set_option("reports", False)
    self.set_option("persistent", False)
    self.set_option("score", False)

</t>
<t tx="ekr.20220312061835.133">@utils.check_messages(
    "eval-used", "exec-used", "bad-reversed-sequence", "misplaced-format-function"
)
</t>
<t tx="ekr.20220312061835.1330">def list_messages_enabled(self):
    emittable, non_emittable = self.msgs_store.find_emittable_messages()
    enabled = []
    disabled = []
    for message in emittable:
        if self.is_message_enabled(message.msgid):
            enabled.append(f"  {message.symbol} ({message.msgid})")
        else:
            disabled.append(f"  {message.symbol} ({message.msgid})")
    print("Enabled messages:")
    for msg in enabled:
        print(msg)
    print("\nDisabled messages:")
    for msg in disabled:
        print(msg)
    print("\nNon-emittable messages with current interpreter:")
    for msg in non_emittable:
        print(f"  {msg.symbol} ({msg.msgid})")
    print("")

</t>
<t tx="ekr.20220312061835.1331"># block level option handling #############################################
# see func_block_disable_msg.py test case for expected behaviour

</t>
<t tx="ekr.20220312061835.1332">def process_tokens(self, tokens):
    """Process tokens from the current module to search for module/block level
    options."""
    control_pragmas = {"disable", "disable-next", "enable"}
    prev_line = None
    saw_newline = True
    seen_newline = True
    for (tok_type, content, start, _, _) in tokens:
        if prev_line and prev_line != start[0]:
            saw_newline = seen_newline
            seen_newline = False

        prev_line = start[0]
        if tok_type in (tokenize.NL, tokenize.NEWLINE):
            seen_newline = True

        if tok_type != tokenize.COMMENT:
            continue
        match = OPTION_PO.search(content)
        if match is None:
            continue
        try:
            for pragma_repr in parse_pragma(match.group(2)):
                if pragma_repr.action in ("disable-all", "skip-file"):
                    if pragma_repr.action == "disable-all":
                        self.add_message(
                            "deprecated-pragma",
                            line=start[0],
                            args=("disable-all", "skip-file"),
                        )
                    self.add_message("file-ignored", line=start[0])
                    self._ignore_file = True
                    return
                try:
                    meth = self._options_methods[pragma_repr.action]
                except KeyError:
                    meth = self._bw_options_methods[pragma_repr.action]
                    # found a "(dis|en)able-msg" pragma deprecated suppression
                    self.add_message(
                        "deprecated-pragma",
                        line=start[0],
                        args=(
                            pragma_repr.action,
                            pragma_repr.action.replace("-msg", ""),
                        ),
                    )
                for msgid in pragma_repr.messages:
                    # Add the line where a control pragma was encountered.
                    if pragma_repr.action in control_pragmas:
                        self._pragma_lineno[msgid] = start[0]

                    if (pragma_repr.action, msgid) == ("disable", "all"):
                        self.add_message(
                            "deprecated-pragma",
                            line=start[0],
                            args=("disable=all", "skip-file"),
                        )
                        self.add_message("file-ignored", line=start[0])
                        self._ignore_file = True
                        return
                        # If we did not see a newline between the previous line and now,
                        # we saw a backslash so treat the two lines as one.
                    l_start = start[0]
                    if not saw_newline:
                        l_start -= 1
                    try:
                        meth(msgid, "module", l_start)
                    except exceptions.UnknownMessageError:
                        self.add_message(
                            "bad-option-value", args=msgid, line=start[0]
                        )
        except UnRecognizedOptionError as err:
            self.add_message(
                "unrecognized-inline-option", args=err.token, line=start[0]
            )
            continue
        except InvalidPragmaError as err:
            self.add_message("bad-inline-option", args=err.token, line=start[0])
            continue

</t>
<t tx="ekr.20220312061835.1333"># code checking methods ###################################################

</t>
<t tx="ekr.20220312061835.1334">def get_checkers(self):
    """return all available checkers as a list"""
    return [self] + [
        c
        for _checkers in self._checkers.values()
        for c in _checkers
        if c is not self
    ]

</t>
<t tx="ekr.20220312061835.1335">def get_checker_names(self):
    """Get all the checker names that this linter knows about."""
    current_checkers = self.get_checkers()
    return sorted(
        {
            checker.name
            for checker in current_checkers
            if checker.name != MAIN_CHECKER_NAME
        }
    )

</t>
<t tx="ekr.20220312061835.1336">def prepare_checkers(self):
    """return checkers needed for activated messages and reports"""
    if not self.config.reports:
        self.disable_reporters()
    # get needed checkers
    needed_checkers = [self]
    for checker in self.get_checkers()[1:]:
        messages = {msg for msg in checker.msgs if self.is_message_enabled(msg)}
        if messages or any(self.report_is_enabled(r[0]) for r in checker.reports):
            needed_checkers.append(checker)
    # Sort checkers by priority
    needed_checkers = sorted(
        needed_checkers, key=operator.attrgetter("priority"), reverse=True
    )
    return needed_checkers

</t>
<t tx="ekr.20220312061835.1337"># pylint: disable=unused-argument
@staticmethod
def should_analyze_file(modname, path, is_argument=False):
    """Returns whether or not a module should be checked.

    This implementation returns True for all python source file, indicating
    that all files should be linted.

    Subclasses may override this method to indicate that modules satisfying
    certain conditions should not be linted.

    :param str modname: The name of the module to be checked.
    :param str path: The full path to the source code of the module.
    :param bool is_argument: Whether the file is an argument to pylint or not.
                             Files which respect this property are always
                             checked, since the user requested it explicitly.
    :returns: True if the module should be checked.
    :rtype: bool
    """
    if is_argument:
        return True
    return path.endswith(".py")

</t>
<t tx="ekr.20220312061835.1338"># pylint: enable=unused-argument

</t>
<t tx="ekr.20220312061835.1339">def initialize(self):
    """Initialize linter for linting

    This method is called before any linting is done.
    """
    # initialize msgs_state now that all messages have been registered into
    # the store
    for msg in self.msgs_store.messages:
        if not msg.may_be_emitted():
            self._msgs_state[msg.msgid] = False

</t>
<t tx="ekr.20220312061835.134">def visit_call(self, node: nodes.Call) -&gt; None:
    """visit a Call node -&gt; check if this is not a disallowed builtin
    call and check for * or ** use
    """
    self._check_misplaced_format_function(node)
    if isinstance(node.func, nodes.Name):
        name = node.func.name
        # ignore the name if it's not a builtin (i.e. not defined in the
        # locals nor globals scope)
        if not (name in node.frame() or name in node.root()):
            if name == "exec":
                self.add_message("exec-used", node=node)
            elif name == "reversed":
                self._check_reversed(node)
            elif name == "eval":
                self.add_message("eval-used", node=node)

</t>
<t tx="ekr.20220312061835.1340">def check(self, files_or_modules: Union[Sequence[str], str]) -&gt; None:
    """main checking entry: check a list of files or modules from their name.

    files_or_modules is either a string or list of strings presenting modules to check.
    """
    self.initialize()
    if not isinstance(files_or_modules, (list, tuple)):
        # pylint: disable-next=fixme
        # TODO: Update typing and docstring for 'files_or_modules' when removing the deprecation
        warnings.warn(
            "In pylint 3.0, the checkers check function will only accept sequence of string",
            DeprecationWarning,
        )
        files_or_modules = (files_or_modules,)  # type: ignore
    if self.config.from_stdin:
        if len(files_or_modules) != 1:
            raise exceptions.InvalidArgsError(
                "Missing filename required for --from-stdin"
            )

        filepath = files_or_modules[0]
        with fix_import_path(files_or_modules):
            self._check_files(
                functools.partial(self.get_ast, data=_read_stdin()),
                [self._get_file_descr_from_stdin(filepath)],
            )
    elif self.config.jobs == 1:
        with fix_import_path(files_or_modules):
            self._check_files(
                self.get_ast, self._iterate_file_descrs(files_or_modules)
            )
    else:
        check_parallel(
            self,
            self.config.jobs,
            self._iterate_file_descrs(files_or_modules),
            files_or_modules,
        )

</t>
<t tx="ekr.20220312061835.1341">def check_single_file(self, name: str, filepath: str, modname: str) -&gt; None:
    warnings.warn(
        "In pylint 3.0, the checkers check_single_file function will be removed. "
        "Use check_single_file_item instead.",
        DeprecationWarning,
    )
    self.check_single_file_item(FileItem(name, filepath, modname))

</t>
<t tx="ekr.20220312061835.1342">def check_single_file_item(self, file: FileItem) -&gt; None:
    """Check single file item

    The arguments are the same that are documented in _check_files

    The initialize() method should be called before calling this method
    """
    with self._astroid_module_checker() as check_astroid_module:
        self._check_file(self.get_ast, check_astroid_module, file)

</t>
<t tx="ekr.20220312061835.1343">def _check_files(
    self,
    get_ast,
    file_descrs: Iterable[FileItem],
) -&gt; None:
    """Check all files from file_descrs"""
    with self._astroid_module_checker() as check_astroid_module:
        for file in file_descrs:
            try:
                self._check_file(get_ast, check_astroid_module, file)
            except Exception as ex:  # pylint: disable=broad-except
                template_path = prepare_crash_report(
                    ex, file.filepath, self.crash_file_path
                )
                msg = get_fatal_error_message(file.filepath, template_path)
                if isinstance(ex, AstroidError):
                    symbol = "astroid-error"
                    self.add_message(symbol, args=(file.filepath, msg))
                else:
                    symbol = "fatal"
                    self.add_message(symbol, args=msg)

</t>
<t tx="ekr.20220312061835.1344">def _check_file(self, get_ast, check_astroid_module, file: FileItem):
    """Check a file using the passed utility functions (get_ast and check_astroid_module)

    :param callable get_ast: callable returning AST from defined file taking the following arguments
    - filepath: path to the file to check
    - name: Python module name
    :param callable check_astroid_module: callable checking an AST taking the following arguments
    - ast: AST of the module
    :param FileItem file: data about the file
    """
    self.set_current_module(file.name, file.filepath)
    # get the module representation
    ast_node = get_ast(file.filepath, file.name)
    if ast_node is None:
        return

    self._ignore_file = False

    self.file_state = FileState(file.modpath)
    # fix the current file (if the source file was not available or
    # if it's actually a c extension)
    self.current_file = ast_node.file  # pylint: disable=maybe-no-member
    check_astroid_module(ast_node)
    # warn about spurious inline messages handling
    spurious_messages = self.file_state.iter_spurious_suppression_messages(
        self.msgs_store
    )
    for msgid, line, args in spurious_messages:
        self.add_message(msgid, line, None, args)

</t>
<t tx="ekr.20220312061835.1345">@staticmethod
def _get_file_descr_from_stdin(filepath: str) -&gt; FileItem:
    """Return file description (tuple of module name, file path, base name) from given file path

    This method is used for creating suitable file description for _check_files when the
    source is standard input.
    """
    try:
        # Note that this function does not really perform an
        # __import__ but may raise an ImportError exception, which
        # we want to catch here.
        modname = ".".join(astroid.modutils.modpath_from_file(filepath))
    except ImportError:
        modname = os.path.splitext(os.path.basename(filepath))[0]

    return FileItem(modname, filepath, filepath)

</t>
<t tx="ekr.20220312061835.1346">def _iterate_file_descrs(self, files_or_modules) -&gt; Iterator[FileItem]:
    """Return generator yielding file descriptions (tuples of module name, file path, base name)

    The returned generator yield one item for each Python module that should be linted.
    """
    for descr in self._expand_files(files_or_modules):
        name, filepath, is_arg = descr["name"], descr["path"], descr["isarg"]
        if self.should_analyze_file(name, filepath, is_argument=is_arg):
            yield FileItem(name, filepath, descr["basename"])

</t>
<t tx="ekr.20220312061835.1347">def _expand_files(self, modules) -&gt; List[ModuleDescriptionDict]:
    """get modules and errors from a list of modules and handle errors"""
    result, errors = expand_modules(
        modules,
        self.config.black_list,
        self.config.black_list_re,
        self.config.ignore_list_paths_re,
    )
    for error in errors:
        message = modname = error["mod"]
        key = error["key"]
        self.set_current_module(modname)
        if key == "fatal":
            message = str(error["ex"]).replace(os.getcwd() + os.sep, "")
        self.add_message(key, args=message)
    return result

</t>
<t tx="ekr.20220312061835.1348">def set_current_module(self, modname, filepath: Optional[str] = None):
    """set the name of the currently analyzed module and
    init statistics for it
    """
    if not modname and filepath is None:
        return
    self.reporter.on_set_current_module(modname, filepath)
    self.current_name = modname
    self.current_file = filepath or modname
    self.stats["by_module"][modname] = {}  # type: ignore # Refactor of PyLinter.stats necessary
    self.stats["by_module"][modname]["statement"] = 0  # type: ignore
    for msg_cat in MSG_TYPES.values():
        self.stats["by_module"][modname][msg_cat] = 0  # type: ignore

</t>
<t tx="ekr.20220312061835.1349">@contextlib.contextmanager
def _astroid_module_checker(self):
    """Context manager for checking ASTs

    The value in the context is callable accepting AST as its only argument.
    """
    walker = ASTWalker(self)
    _checkers = self.prepare_checkers()
    tokencheckers = [
        c
        for c in _checkers
        if interfaces.implements(c, interfaces.ITokenChecker) and c is not self
    ]
    rawcheckers = [
        c for c in _checkers if interfaces.implements(c, interfaces.IRawChecker)
    ]
    # notify global begin
    for checker in _checkers:
        checker.open()
        if interfaces.implements(checker, interfaces.IAstroidChecker):
            walker.add_checker(checker)

    yield functools.partial(
        self.check_astroid_module,
        walker=walker,
        tokencheckers=tokencheckers,
        rawcheckers=rawcheckers,
    )

    # notify global end
    self.stats["statement"] = walker.nbstatements
    for checker in reversed(_checkers):
        checker.close()

</t>
<t tx="ekr.20220312061835.135">@utils.check_messages("assert-on-tuple", "assert-on-string-literal")
def visit_assert(self, node: nodes.Assert) -&gt; None:
    """check whether assert is used on a tuple or string literal."""
    if (
        node.fail is None
        and isinstance(node.test, nodes.Tuple)
        and len(node.test.elts) == 2
    ):
        self.add_message("assert-on-tuple", node=node)

    if isinstance(node.test, nodes.Const) and isinstance(node.test.value, str):
        if node.test.value:
            when = "never"
        else:
            when = "always"
        self.add_message("assert-on-string-literal", node=node, args=(when,))

</t>
<t tx="ekr.20220312061835.1350">def get_ast(self, filepath, modname, data=None):
    """Return an ast(roid) representation of a module or a string.

    :param str filepath: path to checked file.
    :param str modname: The name of the module to be checked.
    :param str data: optional contents of the checked file.
    :returns: the AST
    :rtype: astroid.nodes.Module
    """
    try:
        if data is None:
            return MANAGER.ast_from_file(filepath, modname, source=True)
        return astroid.builder.AstroidBuilder(MANAGER).string_build(
            data, modname, filepath
        )
    except astroid.AstroidSyntaxError as ex:
        # pylint: disable=no-member
        self.add_message(
            "syntax-error",
            line=getattr(ex.error, "lineno", 0),
            col_offset=getattr(ex.error, "offset", None),
            args=str(ex.error),
        )
    except astroid.AstroidBuildingException as ex:
        self.add_message("parse-error", args=ex)
    except Exception as ex:  # pylint: disable=broad-except
        traceback.print_exc()
        self.add_message("astroid-error", args=(ex.__class__, ex))
    return None

</t>
<t tx="ekr.20220312061835.1351">def check_astroid_module(self, ast_node, walker, rawcheckers, tokencheckers):
    """Check a module from its astroid representation.

    For return value see _check_astroid_module
    """
    before_check_statements = walker.nbstatements

    retval = self._check_astroid_module(
        ast_node, walker, rawcheckers, tokencheckers
    )

    self.stats["by_module"][self.current_name]["statement"] = (
        walker.nbstatements - before_check_statements
    )

    return retval

</t>
<t tx="ekr.20220312061835.1352">def _check_astroid_module(
    self, node: nodes.Module, walker, rawcheckers, tokencheckers
):
    """Check given AST node with given walker and checkers

    :param astroid.nodes.Module node: AST node of the module to check
    :param pylint.utils.ast_walker.ASTWalker walker: AST walker
    :param list rawcheckers: List of token checkers to use
    :param list tokencheckers: List of raw checkers to use

    :returns: True if the module was checked, False if ignored,
        None if the module contents could not be parsed
    :rtype: bool
    """
    try:
        tokens = utils.tokenize_module(node)
    except tokenize.TokenError as ex:
        self.add_message("syntax-error", line=ex.args[1][0], args=ex.args[0])
        return None

    if not node.pure_python:
        self.add_message("raw-checker-failed", args=node.name)
    else:
        # assert astroid.file.endswith('.py')
        # invoke ITokenChecker interface on self to fetch module/block
        # level options
        self.process_tokens(tokens)
        if self._ignore_file:
            return False
        # walk ast to collect line numbers
        self.file_state.collect_block_lines(self.msgs_store, node)
        # run raw and tokens checkers
        for checker in rawcheckers:
            checker.process_module(node)
        for checker in tokencheckers:
            checker.process_tokens(tokens)
    # generate events to astroid checkers
    walker.walk(node)
    return True

</t>
<t tx="ekr.20220312061835.1353"># IAstroidChecker interface #################################################

</t>
<t tx="ekr.20220312061835.1354">def open(self):
    """initialize counters"""
    self.stats = {"by_module": {}, "by_msg": {}}
    MANAGER.always_load_extensions = self.config.unsafe_load_any_extension
    MANAGER.max_inferable_values = self.config.limit_inference_results
    MANAGER.extension_package_whitelist.update(self.config.extension_pkg_allow_list)
    if self.config.extension_pkg_whitelist:
        MANAGER.extension_package_whitelist.update(
            self.config.extension_pkg_whitelist
        )
    for msg_cat in MSG_TYPES.values():
        self.stats[msg_cat] = 0

</t>
<t tx="ekr.20220312061835.1355">def generate_reports(self):
    """close the whole package /module, it's time to make reports !

    if persistent run, pickle results for later comparison
    """
    # Display whatever messages are left on the reporter.
    self.reporter.display_messages(report_nodes.Section())

    if self.file_state.base_name is not None:
        # load previous results if any
        previous_stats = config.load_results(self.file_state.base_name)
        self.reporter.on_close(self.stats, previous_stats)
        if self.config.reports:
            sect = self.make_reports(self.stats, previous_stats)
        else:
            sect = report_nodes.Section()

        if self.config.reports:
            self.reporter.display_reports(sect)
        score_value = self._report_evaluation()
        # save results if persistent run
        if self.config.persistent:
            config.save_results(self.stats, self.file_state.base_name)
    else:
        self.reporter.on_close(self.stats, {})
        score_value = None
    return score_value

</t>
<t tx="ekr.20220312061835.1356">def _report_evaluation(self):
    """make the global evaluation report"""
    # check with at least check 1 statements (usually 0 when there is a
    # syntax error preventing pylint from further processing)
    note = None
    previous_stats = config.load_results(self.file_state.base_name)
    if self.stats["statement"] == 0:
        return note

    # get a global note for the code
    evaluation = self.config.evaluation
    try:
        note = eval(evaluation, {}, self.stats)  # pylint: disable=eval-used
    except Exception as ex:  # pylint: disable=broad-except
        msg = f"An exception occurred while rating: {ex}"
    else:
        self.stats["global_note"] = note
        msg = f"Your code has been rated at {note:.2f}/10"
        pnote = previous_stats.get("global_note")
        if pnote is not None:
            msg += f" (previous run: {pnote:.2f}/10, {note - pnote:+.2f})"

    if self.config.score:
        sect = report_nodes.EvaluationSection(msg)
        self.reporter.display_reports(sect)
    return note
</t>
<t tx="ekr.20220312061835.1357">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
from typing import DefaultDict, Dict, List, Tuple, Union

from pylint import checkers, exceptions
from pylint.reporters.ureports.nodes import Table
from pylint.typing import CheckerStats


@others
</t>
<t tx="ekr.20220312061835.1358">def report_total_messages_stats(
    sect,
    stats: CheckerStats,
    previous_stats: CheckerStats,
):
    """make total errors / warnings report"""
    lines = ["type", "number", "previous", "difference"]
    lines += checkers.table_lines_from_stats(
        stats, previous_stats, ("convention", "refactor", "warning", "error")
    )
    sect.append(Table(children=lines, cols=4, rheaders=1))


</t>
<t tx="ekr.20220312061835.1359">def report_messages_stats(
    sect,
    stats: CheckerStats,
    _: CheckerStats,
):
    """make messages type report"""
    if not stats["by_msg"]:
        # don't print this report when we didn't detected any errors
        raise exceptions.EmptyReportError()
    by_msg_stats: Dict[str, int] = stats["by_msg"]  # type: ignore
    in_order: List[Tuple[int, str]] = sorted(
        (value, msg_id)
        for msg_id, value in by_msg_stats.items()
        if not msg_id.startswith("I")
    )
    in_order.reverse()
    lines = ["message id", "occurrences"]
    for value, msg_id in in_order:
        lines += [msg_id, str(value)]
    sect.append(Table(children=lines, cols=2, rheaders=1))


</t>
<t tx="ekr.20220312061835.136">@utils.check_messages("duplicate-key")
def visit_dict(self, node: nodes.Dict) -&gt; None:
    """check duplicate key in dictionary"""
    keys = set()
    for k, _ in node.items:
        if isinstance(k, nodes.Const):
            key = k.value
            if key in keys:
                self.add_message("duplicate-key", node=node, args=key)
            keys.add(key)

</t>
<t tx="ekr.20220312061835.1360">def report_messages_by_module_stats(
    sect,
    stats: CheckerStats,
    _: CheckerStats,
):
    """make errors / warnings by modules report"""
    module_stats: Dict[str, Dict[str, int]] = stats["by_module"]  # type: ignore
    if len(module_stats) == 1:
        # don't print this report when we are analysing a single module
        raise exceptions.EmptyReportError()
    by_mod: DefaultDict[str, Dict[str, Union[int, float]]] = collections.defaultdict(
        dict
    )
    for m_type in ("fatal", "error", "warning", "refactor", "convention"):
        total: int = stats[m_type]  # type: ignore
        for module in module_stats.keys():
            mod_total = module_stats[module][m_type]
            percent = 0 if total == 0 else float(mod_total * 100) / total
            by_mod[module][m_type] = percent
    sorted_result = []
    for module, mod_info in by_mod.items():
        sorted_result.append(
            (
                mod_info["error"],
                mod_info["warning"],
                mod_info["refactor"],
                mod_info["convention"],
                module,
            )
        )
    sorted_result.sort()
    sorted_result.reverse()
    lines = ["module", "error", "warning", "refactor", "convention"]
    for line in sorted_result:
        # Don't report clean modules.
        if all(entry == 0 for entry in line[:-1]):
            continue
        lines.append(line[-1])
        for val in line[:-1]:
            lines.append(f"{val:.2f}")
    if len(lines) == 5:
        raise exceptions.EmptyReportError()
    sect.append(Table(children=lines, cols=5, rheaders=1))
</t>
<t tx="ekr.20220312061835.1361">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import os
import sys
import warnings

from pylint import __pkginfo__, config, extensions, interfaces
from pylint.constants import full_version
from pylint.lint.pylinter import PyLinter
from pylint.lint.utils import ArgumentPreprocessingError, preprocess_options
from pylint.utils import utils

try:
    import multiprocessing
except ImportError:
    multiprocessing = None  # type: ignore


@others
</t>
<t tx="ekr.20220312061835.1362">def _cpu_count() -&gt; int:
    """Use sched_affinity if available for virtualized or containerized environments."""
    sched_getaffinity = getattr(os, "sched_getaffinity", None)
    # pylint: disable=not-callable,using-constant-test
    if sched_getaffinity:
        return len(sched_getaffinity(0))
    if multiprocessing:
        return multiprocessing.cpu_count()
    return 1


</t>
<t tx="ekr.20220312061835.1363">def cb_list_extensions(option, optname, value, parser):
    """List all the extensions under pylint.extensions"""

    for filename in os.listdir(os.path.dirname(extensions.__file__)):
        if filename.endswith(".py") and not filename.startswith("_"):
            extension_name, _, _ = filename.partition(".")
            print(f"pylint.extensions.{extension_name}")
    sys.exit(0)


</t>
<t tx="ekr.20220312061835.1364">def cb_list_confidence_levels(option, optname, value, parser):
    for level in interfaces.CONFIDENCE_LEVELS:
        print(f"%-18s: {level}")
    sys.exit(0)


</t>
<t tx="ekr.20220312061835.1365">def cb_init_hook(optname, value):
    """exec arbitrary code to set sys.path for instance"""
    exec(value)  # pylint: disable=exec-used


</t>
<t tx="ekr.20220312061835.1366">UNUSED_PARAM_SENTINEL = object()


</t>
<t tx="ekr.20220312061835.1367">class Run:
    """helper class to use as main for pylint :

    run(*sys.argv[1:])
    """

    LinterClass = PyLinter
    option_groups = (
        (
            "Commands",
            "Options which are actually commands. Options in this \
group are mutually exclusive.",
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.1368">@staticmethod
def _return_one(*args):  # pylint: disable=unused-argument
    return 1

</t>
<t tx="ekr.20220312061835.1369">def __init__(
    self,
    args,
    reporter=None,
    exit=True,
    do_exit=UNUSED_PARAM_SENTINEL,
):  # pylint: disable=redefined-builtin
    self._rcfile = None
    self._output = None
    self._version_asked = False
    self._plugins = []
    self.verbose = None
    try:
        preprocess_options(
            args,
            {
                # option: (callback, takearg)
                "version": (self.version_asked, False),
                "init-hook": (cb_init_hook, True),
                "rcfile": (self.cb_set_rcfile, True),
                "load-plugins": (self.cb_add_plugins, True),
                "verbose": (self.cb_verbose_mode, False),
                "output": (self.cb_set_output, True),
            },
        )
    except ArgumentPreprocessingError as ex:
        print(ex, file=sys.stderr)
        sys.exit(32)

    self.linter = linter = self.LinterClass(
        (
            (
                "rcfile",
                {
                    "action": "callback",
                    "callback": Run._return_one,
                    "group": "Commands",
                    "type": "string",
                    "metavar": "&lt;file&gt;",
                    "help": "Specify a configuration file to load.",
                },
            ),
            (
                "output",
                {
                    "action": "callback",
                    "callback": Run._return_one,
                    "group": "Commands",
                    "type": "string",
                    "metavar": "&lt;file&gt;",
                    "help": "Specify an output file.",
                },
            ),
            (
                "init-hook",
                {
                    "action": "callback",
                    "callback": Run._return_one,
                    "type": "string",
                    "metavar": "&lt;code&gt;",
                    "level": 1,
                    "help": "Python code to execute, usually for sys.path "
                    "manipulation such as pygtk.require().",
                },
            ),
            (
                "help-msg",
                {
                    "action": "callback",
                    "type": "string",
                    "metavar": "&lt;msg-id&gt;",
                    "callback": self.cb_help_message,
                    "group": "Commands",
                    "help": "Display a help message for the given message id and "
                    "exit. The value may be a comma separated list of message ids.",
                },
            ),
            (
                "list-msgs",
                {
                    "action": "callback",
                    "metavar": "&lt;msg-id&gt;",
                    "callback": self.cb_list_messages,
                    "group": "Commands",
                    "level": 1,
                    "help": "Display a list of all pylint's messages divided by whether "
                    "they are emittable with the given interpreter.",
                },
            ),
            (
                "list-msgs-enabled",
                {
                    "action": "callback",
                    "metavar": "&lt;msg-id&gt;",
                    "callback": self.cb_list_messages_enabled,
                    "group": "Commands",
                    "level": 1,
                    "help": "Display a list of what messages are enabled, "
                    "disabled and non-emittable with the given configuration.",
                },
            ),
            (
                "list-groups",
                {
                    "action": "callback",
                    "metavar": "&lt;msg-id&gt;",
                    "callback": self.cb_list_groups,
                    "group": "Commands",
                    "level": 1,
                    "help": "List pylint's message groups.",
                },
            ),
            (
                "list-conf-levels",
                {
                    "action": "callback",
                    "callback": cb_list_confidence_levels,
                    "group": "Commands",
                    "level": 1,
                    "help": "Generate pylint's confidence levels.",
                },
            ),
            (
                "list-extensions",
                {
                    "action": "callback",
                    "callback": cb_list_extensions,
                    "group": "Commands",
                    "level": 1,
                    "help": "List available extensions.",
                },
            ),
            (
                "full-documentation",
                {
                    "action": "callback",
                    "metavar": "&lt;msg-id&gt;",
                    "callback": self.cb_full_documentation,
                    "group": "Commands",
                    "level": 1,
                    "help": "Generate pylint's full documentation.",
                },
            ),
            (
                "generate-rcfile",
                {
                    "action": "callback",
                    "callback": self.cb_generate_config,
                    "group": "Commands",
                    "help": "Generate a sample configuration file according to "
                    "the current configuration. You can put other options "
                    "before this one to get them in the generated "
                    "configuration.",
                },
            ),
            (
                "generate-man",
                {
                    "action": "callback",
                    "callback": self.cb_generate_manpage,
                    "group": "Commands",
                    "help": "Generate pylint's man page.",
                    "hide": True,
                },
            ),
            (
                "errors-only",
                {
                    "action": "callback",
                    "callback": self.cb_error_mode,
                    "short": "E",
                    "help": "In error mode, checkers without error messages are "
                    "disabled and for others, only the ERROR messages are "
                    "displayed, and no reports are done by default.",
                },
            ),
            (
                "verbose",
                {
                    "action": "callback",
                    "callback": self.cb_verbose_mode,
                    "short": "v",
                    "help": "In verbose mode, extra non-checker-related info "
                    "will be displayed.",
                },
            ),
        ),
        option_groups=self.option_groups,
        pylintrc=self._rcfile,
    )
    # register standard checkers
    if self._version_asked:
        print(full_version)
        sys.exit(0)
    linter.load_default_plugins()
    # load command line plugins
    linter.load_plugin_modules(self._plugins)
    # add some help section
    linter.add_help_section("Environment variables", config.ENV_HELP, level=1)
    linter.add_help_section(
        "Output",
        "Using the default text output, the message format is :                          \n"
        "                                                                                \n"
        "        MESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE                                \n"
        "                                                                                \n"
        "There are 5 kind of message types :                                             \n"
        "    * (C) convention, for programming standard violation                        \n"
        "    * (R) refactor, for bad code smell                                          \n"
        "    * (W) warning, for python specific problems                                 \n"
        "    * (E) error, for probable bugs in the code                                  \n"
        "    * (F) fatal, if an error occurred which prevented pylint from doing further\n"
        "processing.\n",
        level=1,
    )
    linter.add_help_section(
        "Output status code",
        "Pylint should leave with following status code:                                 \n"
        "    * 0 if everything went fine                                                 \n"
        "    * 1 if a fatal message was issued                                           \n"
        "    * 2 if an error message was issued                                          \n"
        "    * 4 if a warning message was issued                                         \n"
        "    * 8 if a refactor message was issued                                        \n"
        "    * 16 if a convention message was issued                                     \n"
        "    * 32 on usage error                                                         \n"
        "                                                                                \n"
        "status 1 to 16 will be bit-ORed so you can know which different categories has\n"
        "been issued by analysing pylint output status code\n",
        level=1,
    )
    # read configuration
    linter.disable("I")
    linter.enable("c-extension-no-member")
    try:
        linter.read_config_file(verbose=self.verbose)
    except OSError as ex:
        print(ex, file=sys.stderr)
        sys.exit(32)

    config_parser = linter.cfgfile_parser
    # run init hook, if present, before loading plugins
    if config_parser.has_option("MASTER", "init-hook"):
        cb_init_hook(
            "init-hook", utils._unquote(config_parser.get("MASTER", "init-hook"))
        )
    # is there some additional plugins in the file configuration, in
    if config_parser.has_option("MASTER", "load-plugins"):
        plugins = utils._splitstrip(config_parser.get("MASTER", "load-plugins"))
        linter.load_plugin_modules(plugins)
    # now we can load file config and command line, plugins (which can
    # provide options) have been registered
    linter.load_config_file()

    if reporter:
        # if a custom reporter is provided as argument, it may be overridden
        # by file parameters, so re-set it here, but before command line
        # parsing so it's still overrideable by command line option
        linter.set_reporter(reporter)
    try:
        args = linter.load_command_line_configuration(args)
    except SystemExit as exc:
        if exc.code == 2:  # bad options
            exc.code = 32
        raise
    if not args:
        print(linter.help())
        sys.exit(32)

    if linter.config.jobs &lt; 0:
        print(
            f"Jobs number ({linter.config.jobs}) should be greater than or equal to 0",
            file=sys.stderr,
        )
        sys.exit(32)
    if linter.config.jobs &gt; 1 or linter.config.jobs == 0:
        if multiprocessing is None:
            print(
                "Multiprocessing library is missing, fallback to single process",
                file=sys.stderr,
            )
            linter.set_option("jobs", 1)
        elif linter.config.jobs == 0:
            linter.config.jobs = _cpu_count()

    # We have loaded configuration from config file and command line. Now, we can
    # load plugin specific configuration.
    linter.load_plugin_configuration()

    # Now that plugins are loaded, get list of all fail_on messages, and enable them
    linter.enable_fail_on_messages()

    if self._output:
        try:
            with open(self._output, "w", encoding="utf-8") as output:
                linter.reporter.set_output(output)
                linter.check(args)
                score_value = linter.generate_reports()
        except OSError as ex:
            print(ex, file=sys.stderr)
            sys.exit(32)
    else:
        linter.check(args)
        score_value = linter.generate_reports()

    if do_exit is not UNUSED_PARAM_SENTINEL:
        warnings.warn(
            "do_exit is deprecated and it is going to be removed in a future version.",
            DeprecationWarning,
        )
        exit = do_exit

    if exit:
        if linter.config.exit_zero:
            sys.exit(0)
        elif linter.any_fail_on_issues():
            # We need to make sure we return a failing exit code in this case.
            # So we use self.linter.msg_status if that is non-zero, otherwise we just return 1.
            sys.exit(self.linter.msg_status or 1)
        elif score_value is not None and score_value &gt;= linter.config.fail_under:
            sys.exit(0)
        else:
            sys.exit(self.linter.msg_status)

</t>
<t tx="ekr.20220312061835.137">def visit_tryfinally(self, node: nodes.TryFinally) -&gt; None:
    """update try...finally flag"""
    self._tryfinallys.append(node)

</t>
<t tx="ekr.20220312061835.1370">def version_asked(self, _, __):
    """callback for version (i.e. before option parsing)"""
    self._version_asked = True

</t>
<t tx="ekr.20220312061835.1371">def cb_set_rcfile(self, name, value):
    """callback for option preprocessing (i.e. before option parsing)"""
    self._rcfile = value

</t>
<t tx="ekr.20220312061835.1372">def cb_set_output(self, name, value):
    """callback for option preprocessing (i.e. before option parsing)"""
    self._output = value

</t>
<t tx="ekr.20220312061835.1373">def cb_add_plugins(self, name, value):
    """callback for option preprocessing (i.e. before option parsing)"""
    self._plugins.extend(utils._splitstrip(value))

</t>
<t tx="ekr.20220312061835.1374">def cb_error_mode(self, *args, **kwargs):
    """error mode:
    * disable all but error messages
    * disable the 'miscellaneous' checker which can be safely deactivated in
      debug
    * disable reports
    * do not save execution information
    """
    self.linter.error_mode()

</t>
<t tx="ekr.20220312061835.1375">def cb_generate_config(self, *args, **kwargs):
    """optik callback for sample config file generation"""
    self.linter.generate_config(skipsections=("COMMANDS",))
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1376">def cb_generate_manpage(self, *args, **kwargs):
    """optik callback for sample config file generation"""
    self.linter.generate_manpage(__pkginfo__)
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1377">def cb_help_message(self, option, optname, value, parser):
    """optik callback for printing some help about a particular message"""
    self.linter.msgs_store.help_message(utils._splitstrip(value))
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1378">def cb_full_documentation(self, option, optname, value, parser):
    """optik callback for printing full documentation"""
    self.linter.print_full_documentation()
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1379">def cb_list_messages(self, option, optname, value, parser):
    """optik callback for printing available messages"""
    self.linter.msgs_store.list_messages()
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.138">def leave_tryfinally(self, _: nodes.TryFinally) -&gt; None:
    """update try...finally flag"""
    self._tryfinallys.pop()

</t>
<t tx="ekr.20220312061835.1380">def cb_list_messages_enabled(self, option, optname, value, parser):
    """optik callback for printing available messages"""
    self.linter.list_messages_enabled()
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1381">def cb_list_groups(self, *args, **kwargs):
    """List all the check groups that pylint knows about

    These should be useful to know what check groups someone can disable
    or enable.
    """
    for check in self.linter.get_checker_names():
        print(check)
    sys.exit(0)

</t>
<t tx="ekr.20220312061835.1382">def cb_verbose_mode(self, *args, **kwargs):
    self.verbose = True
</t>
<t tx="ekr.20220312061835.1383">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import contextlib
import sys
import traceback
from datetime import datetime
from pathlib import Path

from pylint.config import PYLINT_HOME
from pylint.lint.expand_modules import get_python_path


@others
</t>
<t tx="ekr.20220312061835.1384">class ArgumentPreprocessingError(Exception):
    """Raised if an error occurs during argument preprocessing."""


</t>
<t tx="ekr.20220312061835.1385">def prepare_crash_report(ex: Exception, filepath: str, crash_file_path: str) -&gt; Path:
    issue_template_path = (
        Path(PYLINT_HOME) / datetime.now().strftime(str(crash_file_path))
    ).resolve()
    with open(filepath, encoding="utf8") as f:
        file_content = f.read()
    template = ""
    if not issue_template_path.exists():
        template = """\
First, please verify that the bug is not already filled:
https://github.com/PyCQA/pylint/issues/

Then create a new crash issue:
https://github.com/PyCQA/pylint/issues/new?assignees=&amp;labels=crash%2Cneeds+triage&amp;template=BUG-REPORT.yml

"""
    template += f"""\

Issue title:
Crash ``{ex}`` (if possible, be more specific about what made pylint crash)
Content:
When parsing the following file:

&lt;!--
 If sharing the code is not an option, please state so,
 but providing only the stacktrace would still be helpful.
 --&gt;

```python
{file_content}
```

pylint crashed with a ``{ex.__class__.__name__}`` and with the following stacktrace:
```
"""
    try:
        with open(issue_template_path, "a", encoding="utf8") as f:
            f.write(template)
            traceback.print_exc(file=f)
            f.write("```\n")
    except FileNotFoundError:
        print(f"Can't write the issue template for the crash in {issue_template_path}.")
    return issue_template_path


</t>
<t tx="ekr.20220312061835.1386">def get_fatal_error_message(filepath: str, issue_template_path: Path) -&gt; str:
    return (
        f"Fatal error while checking '{filepath}'. "
        f"Please open an issue in our bug tracker so we address this. "
        f"There is a pre-filled template that you can use in '{issue_template_path}'."
    )


</t>
<t tx="ekr.20220312061835.1387">def preprocess_options(args, search_for):
    """look for some options (keys of &lt;search_for&gt;) which have to be processed
    before others

    values of &lt;search_for&gt; are callback functions to call when the option is
    found
    """
    i = 0
    while i &lt; len(args):
        arg = args[i]
        if not arg.startswith("--"):
            i += 1
        else:
            try:
                option, val = arg[2:].split("=", 1)
            except ValueError:
                option, val = arg[2:], None
            try:
                cb, takearg = search_for[option]
            except KeyError:
                i += 1
            else:
                del args[i]
                if takearg and val is None:
                    if i &gt;= len(args) or args[i].startswith("-"):
                        msg = f"Option {option} expects a value"
                        raise ArgumentPreprocessingError(msg)
                    val = args[i]
                    del args[i]
                elif not takearg and val is not None:
                    msg = f"Option {option} doesn't expects a value"
                    raise ArgumentPreprocessingError(msg)
                cb(option, val)


</t>
<t tx="ekr.20220312061835.1388">def _patch_sys_path(args):
    original = list(sys.path)
    changes = []
    seen = set()
    for arg in args:
        path = get_python_path(arg)
        if path not in seen:
            changes.append(path)
            seen.add(path)

    sys.path[:] = changes + sys.path
    return original


</t>
<t tx="ekr.20220312061835.1389">@contextlib.contextmanager
def fix_import_path(args):
    """Prepare sys.path for running the linter checks.

    Within this context, each of the given arguments is importable.
    Paths are added to sys.path in corresponding order to the arguments.
    We avoid adding duplicate directories to sys.path.
    `sys.path` is reset to its original value upon exiting this context.
    """
    original = _patch_sys_path(args)
    try:
        yield
    finally:
        sys.path[:] = original
</t>
<t tx="ekr.20220312061835.139">def _check_unreachable(self, node):
    """check unreachable code"""
    unreach_stmt = node.next_sibling()
    if unreach_stmt is not None:
        if (
            isinstance(node, nodes.Return)
            and isinstance(unreach_stmt, nodes.Expr)
            and isinstance(unreach_stmt.value, nodes.Yield)
        ):
            # Don't add 'unreachable' for empty generators.
            # Only add warning if 'yield' is followed by another node.
            unreach_stmt = unreach_stmt.next_sibling()
            if unreach_stmt is None:
                return
        self.add_message("unreachable", node=unreach_stmt)

</t>
<t tx="ekr.20220312061835.1390">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/lint/
@language python
@tabwidth -4
# Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2008 Fabrice Douchant &lt;Fabrice.Douchant@logilab.fr&gt;
# Copyright (c) 2009 Vincent
# Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;
# Copyright (c) 2011-2014 Google, Inc.
# Copyright (c) 2012 David Pursehouse &lt;david.pursehouse@sonymobile.com&gt;
# Copyright (c) 2012 Kevin Jing Qiu &lt;kevin.jing.qiu@gmail.com&gt;
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2012 JT Olds &lt;jtolds@xnet5.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014-2015 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Alexandru Coman &lt;fcoman@bitdefender.com&gt;
# Copyright (c) 2014 Daniel Harding &lt;dharding@living180.net&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2014 Dan Goldsmith &lt;djgoldsmith@googlemail.com&gt;
# Copyright (c) 2015-2016 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Aru Sahni &lt;arusahni@gmail.com&gt;
# Copyright (c) 2015 Steven Myint &lt;hg@stevenmyint.com&gt;
# Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;
# Copyright (c) 2015 Mihai Balint &lt;balint.mihai@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Alan Evangelista &lt;alanoe@linux.vnet.ibm.com&gt;
# Copyright (c) 2017-2019 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017-2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2017 Daniel Miller &lt;millerdev@gmail.com&gt;
# Copyright (c) 2017 Roman Ivanov &lt;me@roivanov.com&gt;
# Copyright (c) 2017 Ned Batchelder &lt;ned@nedbatchelder.com&gt;
# Copyright (c) 2018-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018-2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018 Matus Valo &lt;matusvalo@users.noreply.github.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Randall Leeds &lt;randall@bleeds.info&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Jason Owen &lt;jason.a.owen@gmail.com&gt;
# Copyright (c) 2018 Gary Tyler McLeod &lt;mail@garytyler.com&gt;
# Copyright (c) 2018 Yuval Langer &lt;yuvallanger@mail.tau.ac.il&gt;
# Copyright (c) 2018 kapsh &lt;kapsh@kap.sh&gt;
# Copyright (c) 2019 syutbai &lt;syutbai@gmail.com&gt;
# Copyright (c) 2019 Thomas Hisch &lt;t.hisch@gmail.com&gt;
# Copyright (c) 2019 Hugues &lt;hugues.bruant@affirm.com&gt;
# Copyright (c) 2019 Janne Rnkk &lt;jannero@users.noreply.github.com&gt;
# Copyright (c) 2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2019 Trevor Bekolay &lt;tbekolay@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Robert Schweizer &lt;robert_schweizer@gmx.de&gt;
# Copyright (c) 2019 Andres Perez Hortal &lt;andresperezcba@gmail.com&gt;
# Copyright (c) 2019 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2019 Nicolas Dickreuter &lt;dickreuter@gmail.com&gt;
# Copyright (c) 2020 Frank Harrison &lt;frank@doublethefish.com&gt;
# Copyright (c) 2020 anubh-v &lt;anubhav@u.nus.edu&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

""" pylint [options] modules_or_packages

  Check that module(s) satisfy a coding standard (and more !).

    pylint --help

  Display this help message and exit.

    pylint --help-msg &lt;msg-id&gt;[,&lt;msg-id&gt;]

  Display help messages about given message identifiers and exit.
"""
import sys

from pylint.lint.parallel import check_parallel
from pylint.lint.pylinter import PyLinter
from pylint.lint.report_functions import (
    report_messages_by_module_stats,
    report_messages_stats,
    report_total_messages_stats,
)
from pylint.lint.run import Run
from pylint.lint.utils import (
    ArgumentPreprocessingError,
    _patch_sys_path,
    fix_import_path,
    preprocess_options,
)

__all__ = [
    "check_parallel",
    "PyLinter",
    "report_messages_by_module_stats",
    "report_messages_stats",
    "report_total_messages_stats",
    "Run",
    "ArgumentPreprocessingError",
    "_patch_sys_path",
    "fix_import_path",
    "preprocess_options",
]

if __name__ == "__main__":
    Run(sys.argv[1:])
</t>
<t tx="ekr.20220312061835.1391"></t>
<t tx="ekr.20220312061835.1392">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import collections

from pylint.constants import MSG_TYPES

_MsgBase = collections.namedtuple(
    "_MsgBase",
    [
        "msg_id",
        "symbol",
        "msg",
        "C",
        "category",
        "confidence",
        "abspath",
        "path",
        "module",
        "obj",
        "line",
        "column",
    ],
)


@others
</t>
<t tx="ekr.20220312061835.1393">class Message(_MsgBase):
    """This class represent a message to be issued by the reporters"""

    @others
</t>
<t tx="ekr.20220312061835.1394">def __new__(cls, msg_id, symbol, location, msg, confidence):
    return _MsgBase.__new__(
        cls,
        msg_id,
        symbol,
        msg,
        msg_id[0],
        MSG_TYPES[msg_id[0]],
        confidence,
        *location
    )

</t>
<t tx="ekr.20220312061835.1395">def format(self, template: str) -&gt; str:
    """Format the message according to the given template.

    The template format is the one of the format method :
    cf. https://docs.python.org/2/library/string.html#formatstrings
    """
    return template.format(**self._asdict())
</t>
<t tx="ekr.20220312061835.1396">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import sys
from typing import List, Optional, Tuple

from pylint.constants import MSG_TYPES
from pylint.exceptions import InvalidMessageError
from pylint.utils import normalize_text


@others
</t>
<t tx="ekr.20220312061835.1397">class MessageDefinition:
    @others
</t>
<t tx="ekr.20220312061835.1398">def __init__(
    self,
    checker,  # BaseChecker
    msgid: str,
    msg: str,
    description: str,
    symbol: str,
    scope: str,
    minversion: Optional[Tuple[int, int]] = None,
    maxversion: Optional[Tuple[int, int]] = None,
    old_names: List[Tuple[str, str]] = None,
):
    self.checker_name = checker.name
    self.check_msgid(msgid)
    self.msgid = msgid
    self.symbol = symbol
    self.msg = msg
    self.description = description
    self.scope = scope
    self.minversion = minversion
    self.maxversion = maxversion
    self.old_names: List[Tuple[str, str]] = []
    if old_names:
        for old_msgid, old_symbol in old_names:
            self.check_msgid(old_msgid)
            self.old_names.append(
                (old_msgid, old_symbol),
            )

</t>
<t tx="ekr.20220312061835.1399">@staticmethod
def check_msgid(msgid: str) -&gt; None:
    if len(msgid) != 5:
        raise InvalidMessageError(f"Invalid message id {msgid!r}")
    if msgid[0] not in MSG_TYPES:
        raise InvalidMessageError(f"Bad message type {msgid[0]} in {msgid!r}")

</t>
<t tx="ekr.20220312061835.14">class InvalidArgsError(ValueError):
    """raised when passed arguments are invalid, e.g., have the wrong length"""


</t>
<t tx="ekr.20220312061835.140">def _check_not_in_finally(self, node, node_name, breaker_classes=()):
    """check that a node is not inside a finally clause of a
    try...finally statement.
    If we found before a try...finally block a parent which its type is
    in breaker_classes, we skip the whole check."""
    # if self._tryfinallys is empty, we're not an in try...finally block
    if not self._tryfinallys:
        return
    # the node could be a grand-grand...-children of the try...finally
    _parent = node.parent
    _node = node
    while _parent and not isinstance(_parent, breaker_classes):
        if hasattr(_parent, "finalbody") and _node in _parent.finalbody:
            self.add_message("lost-exception", node=node, args=node_name)
            return
        _node = _parent
        _parent = _node.parent

</t>
<t tx="ekr.20220312061835.1400">def __repr__(self):
    return f"MessageDefinition:{self.symbol} ({self.msgid})"

</t>
<t tx="ekr.20220312061835.1401">def __str__(self):
    return f"{repr(self)}:\n{self.msg} {self.description}"

</t>
<t tx="ekr.20220312061835.1402">def may_be_emitted(self) -&gt; bool:
    """return True if message may be emitted using the current interpreter"""
    if self.minversion is not None and self.minversion &gt; sys.version_info:
        return False
    if self.maxversion is not None and self.maxversion &lt;= sys.version_info:
        return False
    return True

</t>
<t tx="ekr.20220312061835.1403">def format_help(self, checkerref: bool = False) -&gt; str:
    """return the help string for the given message id"""
    desc = self.description
    if checkerref:
        desc += f" This message belongs to the {self.checker_name} checker."
    title = self.msg
    if self.minversion or self.maxversion:
        restr = []
        if self.minversion:
            restr.append(f"&lt; {'.'.join(str(n) for n in self.minversion)}")
        if self.maxversion:
            restr.append(f"&gt;= {'.'.join(str(n) for n in self.maxversion)}")
        restriction = " or ".join(restr)
        if checkerref:
            desc += f" It can't be emitted when using Python {restriction}."
        else:
            desc += (
                f" This message can't be emitted when using Python {restriction}."
            )
    msg_help = normalize_text(" ".join(desc.split()), indent="  ")
    message_id = f"{self.symbol} ({self.msgid})"
    if title != "%s":
        title = title.splitlines()[0]
        return f":{message_id}: *{title.rstrip(' ')}*\n{msg_help}"
    return f":{message_id}:\n{msg_help}"
</t>
<t tx="ekr.20220312061835.1404">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
from typing import Dict, List, Tuple, ValuesView

from pylint.exceptions import UnknownMessageError
from pylint.message.message_definition import MessageDefinition
from pylint.message.message_id_store import MessageIdStore


@others
</t>
<t tx="ekr.20220312061835.1405">class MessageDefinitionStore:

    """The messages store knows information about every possible message definition but has
    no particular state during analysis.
    """

    @others
</t>
<t tx="ekr.20220312061835.1406">def __init__(self):
    self.message_id_store: MessageIdStore = MessageIdStore()
    # Primary registry for all active messages definitions.
    # It contains the 1:1 mapping from msgid to MessageDefinition.
    # Keys are msgid, values are MessageDefinition
    self._messages_definitions: Dict[str, MessageDefinition] = {}
    # MessageDefinition kept by category
    self._msgs_by_category: Dict[str, List[str]] = collections.defaultdict(list)

</t>
<t tx="ekr.20220312061835.1407">@property
def messages(self) -&gt; ValuesView[MessageDefinition]:
    """The list of all active messages."""
    return self._messages_definitions.values()

</t>
<t tx="ekr.20220312061835.1408">def register_messages_from_checker(self, checker) -&gt; None:
    """Register all messages definitions from a checker."""
    checker.check_consistency()
    for message in checker.messages:
        self.register_message(message)

</t>
<t tx="ekr.20220312061835.1409">def register_message(self, message: MessageDefinition) -&gt; None:
    """Register a MessageDefinition with consistency in mind."""
    self.message_id_store.register_message_definition(
        message.msgid, message.symbol, message.old_names
    )
    self._messages_definitions[message.msgid] = message
    self._msgs_by_category[message.msgid[0]].append(message.msgid)

</t>
<t tx="ekr.20220312061835.141">def _check_reversed(self, node):
    """check that the argument to `reversed` is a sequence"""
    try:
        argument = utils.safe_infer(utils.get_argument_from_call(node, position=0))
    except utils.NoSuchArgumentError:
        pass
    else:
        if argument is astroid.Uninferable:
            return
        if argument is None:
            # Nothing was inferred.
            # Try to see if we have iter().
            if isinstance(node.args[0], nodes.Call):
                try:
                    func = next(node.args[0].func.infer())
                except astroid.InferenceError:
                    return
                if getattr(
                    func, "name", None
                ) == "iter" and utils.is_builtin_object(func):
                    self.add_message("bad-reversed-sequence", node=node)
            return

        if isinstance(argument, (nodes.List, nodes.Tuple)):
            return

        if isinstance(argument, astroid.Instance):
            if any(
                ancestor.name == "dict" and utils.is_builtin_object(ancestor)
                for ancestor in itertools.chain(
                    (argument._proxied,), argument._proxied.ancestors()
                )
            ):
                # Mappings aren't accepted by reversed(), unless
                # they provide explicitly a __reversed__ method.
                try:
                    argument.locals[REVERSED_PROTOCOL_METHOD]
                except KeyError:
                    self.add_message("bad-reversed-sequence", node=node)
                return

        if hasattr(argument, "getattr"):
            # everything else is not a proper sequence for reversed()
            for methods in REVERSED_METHODS:
                for meth in methods:
                    try:
                        argument.getattr(meth)
                    except astroid.NotFoundError:
                        break
                else:
                    break
            else:
                self.add_message("bad-reversed-sequence", node=node)
        else:
            self.add_message("bad-reversed-sequence", node=node)

</t>
<t tx="ekr.20220312061835.1410">def get_message_definitions(self, msgid_or_symbol: str) -&gt; List[MessageDefinition]:
    """Returns the Message definition for either a numeric or symbolic id."""
    return [
        self._messages_definitions[m]
        for m in self.message_id_store.get_active_msgids(msgid_or_symbol)
    ]

</t>
<t tx="ekr.20220312061835.1411">def get_msg_display_string(self, msgid_or_symbol: str) -&gt; str:
    """Generates a user-consumable representation of a message."""
    message_definitions = self.get_message_definitions(msgid_or_symbol)
    if len(message_definitions) == 1:
        return repr(message_definitions[0].symbol)
    return repr([md.symbol for md in message_definitions])

</t>
<t tx="ekr.20220312061835.1412">def help_message(self, msgids_or_symbols: List[str]) -&gt; None:
    """Display help messages for the given message identifiers"""
    for msgids_or_symbol in msgids_or_symbols:
        try:
            for message_definition in self.get_message_definitions(
                msgids_or_symbol
            ):
                print(message_definition.format_help(checkerref=True))
                print("")
        except UnknownMessageError as ex:
            print(ex)
            print("")
            continue

</t>
<t tx="ekr.20220312061835.1413">def list_messages(self) -&gt; None:
    """Output full messages list documentation in ReST format."""
    emittable, non_emittable = self.find_emittable_messages()
    print("Emittable messages with current interpreter:")
    for msg in emittable:
        print(msg.format_help(checkerref=False))
    print("\nNon-emittable messages with current interpreter:")
    for msg in non_emittable:
        print(msg.format_help(checkerref=False))
    print("")

</t>
<t tx="ekr.20220312061835.1414">def find_emittable_messages(
    self,
) -&gt; Tuple[List[MessageDefinition], List[MessageDefinition]]:
    """Finds all emittable and non-emittable messages"""
    messages = sorted(self._messages_definitions.values(), key=lambda m: m.msgid)
    emittable = []
    non_emittable = []
    for message in messages:
        if message.may_be_emitted():
            emittable.append(message)
        else:
            non_emittable.append(message)
    return emittable, non_emittable
</t>
<t tx="ekr.20220312061835.1415">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import sys
from io import TextIOWrapper
from typing import List, TextIO, Tuple, Union

from pylint.constants import (
    _SCOPE_EXEMPT,
    MAIN_CHECKER_NAME,
    MSG_STATE_CONFIDENCE,
    MSG_STATE_SCOPE_CONFIG,
    MSG_STATE_SCOPE_MODULE,
    MSG_TYPES,
    MSG_TYPES_LONG,
    MSG_TYPES_STATUS,
    WarningScope,
)
from pylint.exceptions import (
    InvalidMessageError,
    NoLineSuppliedError,
    UnknownMessageError,
)
from pylint.interfaces import UNDEFINED
from pylint.message.message import Message
from pylint.utils import get_module_and_frameid, get_rst_section, get_rst_title


@others
</t>
<t tx="ekr.20220312061835.1416">class MessagesHandlerMixIn:
    """A mix-in class containing all the messages related methods for the main lint class."""

    __by_id_managed_msgs: List[Tuple[str, str, str, int, bool]] = []

    @others
</t>
<t tx="ekr.20220312061835.1417">def __init__(self):
    self._msgs_state = {}
    self.msg_status = 0

</t>
<t tx="ekr.20220312061835.1418">def _checker_messages(self, checker):
    for known_checker in self._checkers[checker.lower()]:
        yield from known_checker.msgs

</t>
<t tx="ekr.20220312061835.1419">@classmethod
def clear_by_id_managed_msgs(cls):
    cls.__by_id_managed_msgs.clear()

</t>
<t tx="ekr.20220312061835.142">@utils.check_messages("confusing-with-statement")
def visit_with(self, node: nodes.With) -&gt; None:
    # a "with" statement with multiple managers corresponds
    # to one AST "With" node with multiple items
    pairs = node.items
    if pairs:
        for prev_pair, pair in zip(pairs, pairs[1:]):
            if isinstance(prev_pair[1], nodes.AssignName) and (
                pair[1] is None and not isinstance(pair[0], nodes.Call)
            ):
                # Don't emit a message if the second is a function call
                # there's no way that can be mistaken for a name assignment.
                # If the line number doesn't match
                # we assume it's a nested "with".
                self.add_message("confusing-with-statement", node=node)

</t>
<t tx="ekr.20220312061835.1420">@classmethod
def get_by_id_managed_msgs(cls):
    return cls.__by_id_managed_msgs

</t>
<t tx="ekr.20220312061835.1421">def _register_by_id_managed_msg(self, msgid_or_symbol: str, line, is_disabled=True):
    """If the msgid is a numeric one, then register it to inform the user
    it could furnish instead a symbolic msgid."""
    if msgid_or_symbol[1:].isdigit():
        try:
            symbol = self.msgs_store.message_id_store.get_symbol(msgid=msgid_or_symbol)  # type: ignore
        except UnknownMessageError:
            return
        managed = (self.current_name, msgid_or_symbol, symbol, line, is_disabled)  # type: ignore
        MessagesHandlerMixIn.__by_id_managed_msgs.append(managed)

</t>
<t tx="ekr.20220312061835.1422">def disable(self, msgid, scope="package", line=None, ignore_unknown=False):
    self._set_msg_status(
        msgid, enable=False, scope=scope, line=line, ignore_unknown=ignore_unknown
    )
    self._register_by_id_managed_msg(msgid, line)

</t>
<t tx="ekr.20220312061835.1423">def disable_next(
    self,
    msgid: str,
    scope: str = "package",
    line: Union[bool, int] = None,
    ignore_unknown: bool = False,
):
    if not line:
        raise NoLineSuppliedError
    self._set_msg_status(
        msgid,
        enable=False,
        scope=scope,
        line=line + 1,
        ignore_unknown=ignore_unknown,
    )
    self._register_by_id_managed_msg(msgid, line + 1)

</t>
<t tx="ekr.20220312061835.1424">def enable(self, msgid, scope="package", line=None, ignore_unknown=False):
    self._set_msg_status(
        msgid, enable=True, scope=scope, line=line, ignore_unknown=ignore_unknown
    )
    self._register_by_id_managed_msg(msgid, line, is_disabled=False)

</t>
<t tx="ekr.20220312061835.1425">def _set_msg_status(
    self, msgid, enable, scope="package", line=None, ignore_unknown=False
):
    assert scope in ("package", "module")
    if msgid == "all":
        for _msgid in MSG_TYPES:
            self._set_msg_status(_msgid, enable, scope, line, ignore_unknown)
        return

    # msgid is a category?
    category_id = msgid.upper()
    if category_id not in MSG_TYPES:
        category_id = MSG_TYPES_LONG.get(category_id)
    if category_id is not None:
        for _msgid in self.msgs_store._msgs_by_category.get(category_id):
            self._set_msg_status(_msgid, enable, scope, line)
        return

    # msgid is a checker name?
    if msgid.lower() in self._checkers:
        for checker in self._checkers[msgid.lower()]:
            for _msgid in checker.msgs:
                self._set_msg_status(_msgid, enable, scope, line)
        return

    # msgid is report id?
    if msgid.lower().startswith("rp"):
        if enable:
            self.enable_report(msgid)
        else:
            self.disable_report(msgid)
        return

    try:
        # msgid is a symbolic or numeric msgid.
        message_definitions = self.msgs_store.get_message_definitions(msgid)
    except UnknownMessageError:
        if ignore_unknown:
            return
        raise
    for message_definition in message_definitions:
        self._set_one_msg_status(scope, message_definition, line, enable)

</t>
<t tx="ekr.20220312061835.1426">def _set_one_msg_status(self, scope, msg, line, enable):
    if scope == "module":
        self.file_state.set_msg_status(msg, line, enable)
        if not enable and msg.symbol != "locally-disabled":
            self.add_message(
                "locally-disabled", line=line, args=(msg.symbol, msg.msgid)
            )
    else:
        msgs = self._msgs_state
        msgs[msg.msgid] = enable
        # sync configuration object
        self.config.enable = [
            self._message_symbol(mid) for mid, val in sorted(msgs.items()) if val
        ]
        self.config.disable = [
            self._message_symbol(mid)
            for mid, val in sorted(msgs.items())
            if not val
        ]

</t>
<t tx="ekr.20220312061835.1427">def _message_symbol(self, msgid):
    """Get the message symbol of the given message id

    Return the original message id if the message does not
    exist.
    """
    try:
        return [md.symbol for md in self.msgs_store.get_message_definitions(msgid)]
    except UnknownMessageError:
        return msgid

</t>
<t tx="ekr.20220312061835.1428">def get_message_state_scope(self, msgid, line=None, confidence=UNDEFINED):
    """Returns the scope at which a message was enabled/disabled."""
    if self.config.confidence and confidence.name not in self.config.confidence:
        return MSG_STATE_CONFIDENCE
    try:
        if line in self.file_state._module_msgs_state[msgid]:
            return MSG_STATE_SCOPE_MODULE
    except (KeyError, TypeError):
        return MSG_STATE_SCOPE_CONFIG
    return None

</t>
<t tx="ekr.20220312061835.1429">def is_message_enabled(self, msg_descr, line=None, confidence=None):
    """return true if the message associated to the given message id is
    enabled

    msgid may be either a numeric or symbolic message id.
    """
    if self.config.confidence and confidence:
        if confidence.name not in self.config.confidence:
            return False
    try:
        message_definitions = self.msgs_store.get_message_definitions(msg_descr)
        msgids = [md.msgid for md in message_definitions]
    except UnknownMessageError:
        # The linter checks for messages that are not registered
        # due to version mismatch, just treat them as message IDs
        # for now.
        msgids = [msg_descr]
    for msgid in msgids:
        if self.is_one_message_enabled(msgid, line):
            return True
    return False

</t>
<t tx="ekr.20220312061835.143">def _check_self_assigning_variable(self, node):
    # Detect assigning to the same variable.

    scope = node.scope()
    scope_locals = scope.locals

    rhs_names = []
    targets = node.targets
    if isinstance(targets[0], nodes.Tuple):
        if len(targets) != 1:
            # A complex assignment, so bail out early.
            return
        targets = targets[0].elts
        if len(targets) == 1:
            # Unpacking a variable into the same name.
            return

    if isinstance(node.value, nodes.Name):
        if len(targets) != 1:
            return
        rhs_names = [node.value]
    elif isinstance(node.value, nodes.Tuple):
        rhs_count = len(node.value.elts)
        if len(targets) != rhs_count or rhs_count == 1:
            return
        rhs_names = node.value.elts

    for target, lhs_name in zip(targets, rhs_names):
        if not isinstance(lhs_name, nodes.Name):
            continue
        if not isinstance(target, nodes.AssignName):
            continue
        if isinstance(scope, nodes.ClassDef) and target.name in scope_locals:
            # Check that the scope is different than a class level, which is usually
            # a pattern to expose module level attributes as class level ones.
            continue
        if target.name == lhs_name.name:
            self.add_message(
                "self-assigning-variable", args=(target.name,), node=target
            )

</t>
<t tx="ekr.20220312061835.1430">def is_one_message_enabled(self, msgid, line):
    if line is None:
        return self._msgs_state.get(msgid, True)
    try:
        return self.file_state._module_msgs_state[msgid][line]
    except KeyError:
        # Check if the message's line is after the maximum line existing in ast tree.
        # This line won't appear in the ast tree and won't be referred in
        # self.file_state._module_msgs_state
        # This happens for example with a commented line at the end of a module.
        max_line_number = self.file_state.get_effective_max_line_number()
        if max_line_number and line &gt; max_line_number:
            fallback = True
            lines = self.file_state._raw_module_msgs_state.get(msgid, {})

            # Doesn't consider scopes, as a disable can be in a different scope
            # than that of the current line.
            closest_lines = reversed(
                [
                    (message_line, enable)
                    for message_line, enable in lines.items()
                    if message_line &lt;= line
                ]
            )
            last_line, is_enabled = next(closest_lines, (None, None))
            if last_line is not None:
                fallback = is_enabled

            return self._msgs_state.get(msgid, fallback)
        return self._msgs_state.get(msgid, True)

</t>
<t tx="ekr.20220312061835.1431">def add_message(
    self, msgid, line=None, node=None, args=None, confidence=None, col_offset=None
):
    """Adds a message given by ID or name.

    If provided, the message string is expanded using args.

    AST checkers must provide the node argument (but may optionally
    provide line if the line number is different), raw and token checkers
    must provide the line argument.
    """
    if confidence is None:
        confidence = UNDEFINED
    message_definitions = self.msgs_store.get_message_definitions(msgid)
    for message_definition in message_definitions:
        self.add_one_message(
            message_definition, line, node, args, confidence, col_offset
        )

</t>
<t tx="ekr.20220312061835.1432">@staticmethod
def check_message_definition(message_definition, line, node):
    if message_definition.msgid[0] not in _SCOPE_EXEMPT:
        # Fatal messages and reports are special, the node/scope distinction
        # does not apply to them.
        if message_definition.scope == WarningScope.LINE:
            if line is None:
                raise InvalidMessageError(
                    f"Message {message_definition.msgid} must provide line, got None"
                )
            if node is not None:
                raise InvalidMessageError(
                    f"Message {message_definition.msgid} must only provide line, "
                    f"got line={line}, node={node}"
                )
        elif message_definition.scope == WarningScope.NODE:
            # Node-based warnings may provide an override line.
            if node is None:
                raise InvalidMessageError(
                    f"Message {message_definition.msgid} must provide Node, got None"
                )

</t>
<t tx="ekr.20220312061835.1433">def add_one_message(
    self, message_definition, line, node, args, confidence, col_offset
):
    self.check_message_definition(message_definition, line, node)
    if line is None and node is not None:
        line = node.fromlineno
    if col_offset is None and hasattr(node, "col_offset"):
        col_offset = node.col_offset

    # should this message be displayed
    if not self.is_message_enabled(message_definition.msgid, line, confidence):
        self.file_state.handle_ignored_message(
            self.get_message_state_scope(
                message_definition.msgid, line, confidence
            ),
            message_definition.msgid,
            line,
            node,
            args,
            confidence,
        )
        return
    # update stats
    msg_cat = MSG_TYPES[message_definition.msgid[0]]
    self.msg_status |= MSG_TYPES_STATUS[message_definition.msgid[0]]
    if self.stats is None:
        # pylint: disable=fixme
        # TODO self.stats should make sense,
        # class should make sense as soon as instantiated
        # This is not true for Linter and Reporter at least
        # pylint: enable=fixme
        self.stats = {
            msg_cat: 0,
            "by_module": {self.current_name: {msg_cat: 0}},
            "by_msg": {},
        }
    self.stats[msg_cat] += 1
    self.stats["by_module"][self.current_name][msg_cat] += 1
    try:
        self.stats["by_msg"][message_definition.symbol] += 1
    except KeyError:
        self.stats["by_msg"][message_definition.symbol] = 1
    # expand message ?
    msg = message_definition.msg
    if args:
        msg %= args
    # get module and object
    if node is None:
        module, obj = self.current_name, ""
        abspath = self.current_file
    else:
        module, obj = get_module_and_frameid(node)
        abspath = node.root().file
    if abspath is not None:
        path = abspath.replace(self.reporter.path_strip_prefix, "", 1)
    else:
        path = "configuration"
    # add the message
    self.reporter.handle_message(
        Message(
            message_definition.msgid,
            message_definition.symbol,
            (abspath, path, module, obj, line or 1, col_offset or 0),
            msg,
            confidence,
        )
    )

</t>
<t tx="ekr.20220312061835.1434">def _get_checkers_infos(self):
    by_checker = {}
    for checker in self.get_checkers():
        name = checker.name
        if name != "master":
            try:
                by_checker[name]["checker"] = checker
                by_checker[name]["options"] += checker.options_and_values()
                by_checker[name]["msgs"].update(checker.msgs)
                by_checker[name]["reports"] += checker.reports
            except KeyError:
                by_checker[name] = {
                    "checker": checker,
                    "options": list(checker.options_and_values()),
                    "msgs": dict(checker.msgs),
                    "reports": list(checker.reports),
                }
    return by_checker

</t>
<t tx="ekr.20220312061835.1435">def get_checkers_documentation(self):
    result = get_rst_title("Pylint global options and switches", "-")
    result += """
\\-4.Pylint provides global options and switches.

\\-4."""
    for checker in self.get_checkers():
        name = checker.name
        if name == MAIN_CHECKER_NAME:
            if checker.options:
                for section, options in checker.options_by_section():
                    if section is None:
                        title = "General options"
                    else:
                        title = f"{section.capitalize()} options"
                    result += get_rst_title(title, "~")
                    result += f"{get_rst_section(None, options)}\n"
    result += get_rst_title("Pylint checkers' options and switches", "-")
    result += """\

\\-4.Pylint checkers can provide three set of features:

\\-4.* options that control their execution,
\\-4.* messages that they can raise,
\\-4.* reports that they can generate.

\\-4.Below is a list of all checkers and their features.

\\-4."""
    by_checker = self._get_checkers_infos()
    for checker in sorted(by_checker):
        information = by_checker[checker]
        checker = information["checker"]
        del information["checker"]
        result += checker.get_full_documentation(**information)
    return result

</t>
<t tx="ekr.20220312061835.1436">def print_full_documentation(self, stream: TextIO = sys.stdout) -&gt; None:
    """output a full documentation in ReST format"""
    print(self.get_checkers_documentation()[:-1], file=stream)

</t>
<t tx="ekr.20220312061835.1437">@staticmethod
def _print_checker_doc(information, stream: TextIOWrapper) -&gt; None:
    """Helper method used by doc/exts/pylint_extensions.py."""
    checker = information["checker"]
    del information["checker"]
    print(checker.get_full_documentation(**information)[:-1], file=stream)
</t>
<t tx="ekr.20220312061835.1438">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import Dict, List, Optional, Tuple

from pylint.exceptions import InvalidMessageError, UnknownMessageError


@others
</t>
<t tx="ekr.20220312061835.1439">class MessageIdStore:

    """The MessageIdStore store MessageId and make sure that there is a 1-1 relation between msgid and symbol."""

    @others
</t>
<t tx="ekr.20220312061835.144">def _check_redeclared_assign_name(self, targets):
    dummy_variables_rgx = lint_utils.get_global_option(
        self, "dummy-variables-rgx", default=None
    )

    for target in targets:
        if not isinstance(target, nodes.Tuple):
            continue

        found_names = []
        for element in target.elts:
            if isinstance(element, nodes.Tuple):
                self._check_redeclared_assign_name([element])
            elif isinstance(element, nodes.AssignName) and element.name != "_":
                if dummy_variables_rgx and dummy_variables_rgx.match(element.name):
                    return
                found_names.append(element.name)

        names = collections.Counter(found_names)
        for name, count in names.most_common():
            if count &gt; 1:
                self.add_message(
                    "redeclared-assigned-name", args=(name,), node=target
                )

</t>
<t tx="ekr.20220312061835.1440">def __init__(self):
    self.__msgid_to_symbol: Dict[str, str] = {}
    self.__symbol_to_msgid: Dict[str, str] = {}
    self.__old_names: Dict[str, List[str]] = {}

</t>
<t tx="ekr.20220312061835.1441">def __len__(self):
    return len(self.__msgid_to_symbol)

</t>
<t tx="ekr.20220312061835.1442">def __repr__(self):
    result = "MessageIdStore: [\n"
    for msgid, symbol in self.__msgid_to_symbol.items():
        result += f"  - {msgid} ({symbol})\n"
    result += "]"
    return result

</t>
<t tx="ekr.20220312061835.1443">def get_symbol(self, msgid: str) -&gt; str:
    try:
        return self.__msgid_to_symbol[msgid.upper()]
    except KeyError as e:
        msg = f"'{msgid}' is not stored in the message store."
        raise UnknownMessageError(msg) from e

</t>
<t tx="ekr.20220312061835.1444">def get_msgid(self, symbol: str) -&gt; str:
    try:
        return self.__symbol_to_msgid[symbol]
    except KeyError as e:
        msg = f"'{symbol}' is not stored in the message store."
        raise UnknownMessageError(msg) from e

</t>
<t tx="ekr.20220312061835.1445">def register_message_definition(
    self, msgid: str, symbol: str, old_names: List[Tuple[str, str]]
):
    self.check_msgid_and_symbol(msgid, symbol)
    self.add_msgid_and_symbol(msgid, symbol)
    for old_msgid, old_symbol in old_names:
        self.check_msgid_and_symbol(old_msgid, old_symbol)
        self.add_legacy_msgid_and_symbol(old_msgid, old_symbol, msgid)

</t>
<t tx="ekr.20220312061835.1446">def add_msgid_and_symbol(self, msgid: str, symbol: str) -&gt; None:
    """Add valid message id.

    There is a little duplication with add_legacy_msgid_and_symbol to avoid a function call,
    this is called a lot at initialization."""
    self.__msgid_to_symbol[msgid] = symbol
    self.__symbol_to_msgid[symbol] = msgid

</t>
<t tx="ekr.20220312061835.1447">def add_legacy_msgid_and_symbol(
    self, msgid: str, symbol: str, new_msgid: str
) -&gt; None:
    """Add valid legacy message id.

    There is a little duplication with add_msgid_and_symbol to avoid a function call,
    this is called a lot at initialization."""
    self.__msgid_to_symbol[msgid] = symbol
    self.__symbol_to_msgid[symbol] = msgid
    existing_old_names = self.__old_names.get(msgid, [])
    existing_old_names.append(new_msgid)
    self.__old_names[msgid] = existing_old_names

</t>
<t tx="ekr.20220312061835.1448">def check_msgid_and_symbol(self, msgid: str, symbol: str) -&gt; None:
    existing_msgid: Optional[str] = self.__symbol_to_msgid.get(symbol)
    existing_symbol: Optional[str] = self.__msgid_to_symbol.get(msgid)
    if existing_symbol is None and existing_msgid is None:
        return  # both symbol and msgid are usable
    if existing_msgid is not None:
        if existing_msgid != msgid:
            self._raise_duplicate_msgid(symbol, msgid, existing_msgid)
    if existing_symbol and existing_symbol != symbol:
        # See https://github.com/python/mypy/issues/10559
        self._raise_duplicate_symbol(msgid, symbol, existing_symbol)

</t>
<t tx="ekr.20220312061835.1449">@staticmethod
def _raise_duplicate_symbol(msgid: str, symbol: str, other_symbol: str):
    """Raise an error when a symbol is duplicated."""
    symbols = [symbol, other_symbol]
    symbols.sort()
    error_message = f"Message id '{msgid}' cannot have both "
    error_message += f"'{symbols[0]}' and '{symbols[1]}' as symbolic name."
    raise InvalidMessageError(error_message)

</t>
<t tx="ekr.20220312061835.145">@utils.check_messages("self-assigning-variable", "redeclared-assigned-name")
def visit_assign(self, node: nodes.Assign) -&gt; None:
    self._check_self_assigning_variable(node)
    self._check_redeclared_assign_name(node.targets)

</t>
<t tx="ekr.20220312061835.1450">@staticmethod
def _raise_duplicate_msgid(symbol: str, msgid: str, other_msgid: str) -&gt; None:
    """Raise an error when a msgid is duplicated."""
    msgids = [msgid, other_msgid]
    msgids.sort()
    error_message = (
        f"Message symbol '{symbol}' cannot be used for "
        f"'{msgids[0]}' and '{msgids[1]}' at the same time."
        f" If you're creating an 'old_names' use 'old-{symbol}' as the old symbol."
    )
    raise InvalidMessageError(error_message)

</t>
<t tx="ekr.20220312061835.1451">def get_active_msgids(self, msgid_or_symbol: str) -&gt; List[str]:
    """Return msgids but the input can be a symbol."""
    # Only msgid can have a digit as second letter
    is_msgid: bool = msgid_or_symbol[1:].isdigit()
    msgid = None
    if is_msgid:
        msgid = msgid_or_symbol.upper()
        symbol = self.__msgid_to_symbol.get(msgid)
    else:
        msgid = self.__symbol_to_msgid.get(msgid_or_symbol)
        symbol = msgid_or_symbol
    if msgid is None or symbol is None or not msgid or not symbol:
        error_msg = f"No such message id or symbol '{msgid_or_symbol}'."
        raise UnknownMessageError(error_msg)
    return self.__old_names.get(msgid, [msgid])
</t>
<t tx="ekr.20220312061835.1452">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/message/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009 Vincent
# Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2014-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014-2015 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 LCD 47 &lt;lcd047@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2014 Damien Nozay &lt;damien.nozay@gmail.com&gt;
# Copyright (c) 2015 Aru Sahni &lt;arusahni@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glmatthe@cisco.com&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 xmo-odoo &lt;xmo-odoo@users.noreply.github.com&gt;
# Copyright (c) 2017-2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2017 Chris Lamb &lt;chris@chris-lamb.co.uk&gt;
# Copyright (c) 2017 Thomas Hisch &lt;t.hisch@gmail.com&gt;
# Copyright (c) 2017 Mikhail Fesenko &lt;proggga@gmail.com&gt;
# Copyright (c) 2017 Craig Citro &lt;craigcitro@gmail.com&gt;
# Copyright (c) 2017 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Reverb C &lt;reverbc@users.noreply.github.com&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""All the classes related to Message handling."""

from pylint.message.message import Message
from pylint.message.message_definition import MessageDefinition
from pylint.message.message_definition_store import MessageDefinitionStore
from pylint.message.message_handler_mix_in import MessagesHandlerMixIn
from pylint.message.message_id_store import MessageIdStore

__all__ = [
    "Message",
    "MessageDefinition",
    "MessageDefinitionStore",
    "MessagesHandlerMixIn",
    "MessageIdStore",
]
</t>
<t tx="ekr.20220312061835.1453"></t>
<t tx="ekr.20220312061835.1454">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2006, 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""handle diagram generation options for class diagram or default diagrams
"""

from typing import Any, Optional

import astroid
from astroid import nodes

from pylint.pyreverse.diagrams import ClassDiagram, PackageDiagram
from pylint.pyreverse.inspector import Project
from pylint.pyreverse.utils import LocalsVisitor

# diagram generators ##########################################################


@others
</t>
<t tx="ekr.20220312061835.1455">class DiaDefGenerator:
    """handle diagram generation options"""

    @others
</t>
<t tx="ekr.20220312061835.1456">def __init__(self, linker, handler):
    """common Diagram Handler initialization"""
    self.config = handler.config
    self._set_default_options()
    self.linker = linker
    self.classdiagram = None  # defined by subclasses

</t>
<t tx="ekr.20220312061835.1457">def get_title(self, node):
    """get title for objects"""
    title = node.name
    if self.module_names:
        title = f"{node.root().name}.{title}"
    return title

</t>
<t tx="ekr.20220312061835.1458">def _set_option(self, option):
    """activate some options if not explicitly deactivated"""
    # if we have a class diagram, we want more information by default;
    # so if the option is None, we return True
    if option is None:
        return bool(self.config.classes)
    return option

</t>
<t tx="ekr.20220312061835.1459">def _set_default_options(self):
    """set different default options with _default dictionary"""
    self.module_names = self._set_option(self.config.module_names)
    all_ancestors = self._set_option(self.config.all_ancestors)
    all_associated = self._set_option(self.config.all_associated)
    anc_level, association_level = (0, 0)
    if all_ancestors:
        anc_level = -1
    if all_associated:
        association_level = -1
    if self.config.show_ancestors is not None:
        anc_level = self.config.show_ancestors
    if self.config.show_associated is not None:
        association_level = self.config.show_associated
    self.anc_level, self.association_level = anc_level, association_level

</t>
<t tx="ekr.20220312061835.146">@utils.check_messages("redeclared-assigned-name")
def visit_for(self, node: nodes.For) -&gt; None:
    self._check_redeclared_assign_name([node.target])


</t>
<t tx="ekr.20220312061835.1460">def _get_levels(self):
    """help function for search levels"""
    return self.anc_level, self.association_level

</t>
<t tx="ekr.20220312061835.1461">def show_node(self, node):
    """true if builtins and not show_builtins"""
    if self.config.show_builtin:
        return True
    return node.root().name != "builtins"

</t>
<t tx="ekr.20220312061835.1462">def add_class(self, node):
    """visit one class and add it to diagram"""
    self.linker.visit(node)
    self.classdiagram.add_object(self.get_title(node), node)

</t>
<t tx="ekr.20220312061835.1463">def get_ancestors(self, node, level):
    """return ancestor nodes of a class node"""
    if level == 0:
        return
    for ancestor in node.ancestors(recurs=False):
        if not self.show_node(ancestor):
            continue
        yield ancestor

</t>
<t tx="ekr.20220312061835.1464">def get_associated(self, klass_node, level):
    """return associated nodes of a class node"""
    if level == 0:
        return
    for association_nodes in (
        list(klass_node.instance_attrs_type.values()) +
        list(klass_node.locals_type.values())
    ):
        for node in association_nodes:
            if isinstance(node, astroid.Instance):
                node = node._proxied
            if not (isinstance(node, nodes.ClassDef) and self.show_node(node)):
                continue
            yield node

</t>
<t tx="ekr.20220312061835.1465">def extract_classes(self, klass_node, anc_level, association_level):
    """extract recursively classes related to klass_node"""
    if self.classdiagram.has_node(klass_node) or not self.show_node(klass_node):
        return
    self.add_class(klass_node)

    for ancestor in self.get_ancestors(klass_node, anc_level):
        self.extract_classes(ancestor, anc_level - 1, association_level)

    for node in self.get_associated(klass_node, association_level):
        self.extract_classes(node, anc_level, association_level - 1)


</t>
<t tx="ekr.20220312061835.1466">class DefaultDiadefGenerator(LocalsVisitor, DiaDefGenerator):
    """generate minimum diagram definition for the project :

    * a package diagram including project's modules
    * a class diagram including project's classes
    """

    @others
</t>
<t tx="ekr.20220312061835.1467">def __init__(self, linker, handler):
    DiaDefGenerator.__init__(self, linker, handler)
    LocalsVisitor.__init__(self)

</t>
<t tx="ekr.20220312061835.1468">def visit_project(self, node: Project) -&gt; None:
    """visit a pyreverse.utils.Project node

    create a diagram definition for packages
    """
    mode = self.config.mode
    if len(node.modules) &gt; 1:
        self.pkgdiagram: Optional[PackageDiagram] = PackageDiagram(
            f"packages {node.name}", mode
        )
    else:
        self.pkgdiagram = None
    self.classdiagram = ClassDiagram(f"classes {node.name}", mode)

</t>
<t tx="ekr.20220312061835.1469">def leave_project(self, _: Project) -&gt; Any:
    """leave the pyreverse.utils.Project node

    return the generated diagram definition
    """
    if self.pkgdiagram:
        return self.pkgdiagram, self.classdiagram
    return (self.classdiagram,)

</t>
<t tx="ekr.20220312061835.147">KNOWN_NAME_TYPES = {
    "module",
    "const",
    "class",
    "function",
    "method",
    "attr",
    "argument",
    "variable",
    "class_attribute",
    "class_const",
    "inlinevar",
}

HUMAN_READABLE_TYPES = {
    "module": "module",
    "const": "constant",
    "class": "class",
    "function": "function",
    "method": "method",
    "attr": "attribute",
    "argument": "argument",
    "variable": "variable",
    "class_attribute": "class attribute",
    "class_const": "class constant",
    "inlinevar": "inline iteration",
}

DEFAULT_NAMING_STYLES = {
    "module": "snake_case",
    "const": "UPPER_CASE",
    "class": "PascalCase",
    "function": "snake_case",
    "method": "snake_case",
    "attr": "snake_case",
    "argument": "snake_case",
    "variable": "snake_case",
    "class_attribute": "any",
    "class_const": "UPPER_CASE",
    "inlinevar": "any",
}


</t>
<t tx="ekr.20220312061835.1470">def visit_module(self, node: nodes.Module) -&gt; None:
    """visit an astroid.Module node

    add this class to the package diagram definition
    """
    if self.pkgdiagram:
        self.linker.visit(node)
        self.pkgdiagram.add_object(node.name, node)

</t>
<t tx="ekr.20220312061835.1471">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    """visit an astroid.Class node

    add this class to the class diagram definition
    """
    anc_level, association_level = self._get_levels()
    self.extract_classes(node, anc_level, association_level)

</t>
<t tx="ekr.20220312061835.1472">def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """visit astroid.ImportFrom  and catch modules for package diagram"""
    if self.pkgdiagram:
        self.pkgdiagram.add_from_depend(node, node.modname)


</t>
<t tx="ekr.20220312061835.1473">class ClassDiadefGenerator(DiaDefGenerator):
    """generate a class diagram definition including all classes related to a
    given class
    """

    @others
</t>
<t tx="ekr.20220312061835.1474">def __init__(self, linker, handler):
    DiaDefGenerator.__init__(self, linker, handler)

</t>
<t tx="ekr.20220312061835.1475">def class_diagram(self, project, klass):
    """return a class diagram definition for the given klass and its
    related klasses
    """

    self.classdiagram = ClassDiagram(klass, self.config.mode)
    if len(project.modules) &gt; 1:
        module, klass = klass.rsplit(".", 1)
        module = project.get_module(module)
    else:
        module = project.modules[0]
        klass = klass.split(".")[-1]
    klass = next(module.ilookup(klass))

    anc_level, association_level = self._get_levels()
    self.extract_classes(klass, anc_level, association_level)
    return self.classdiagram


</t>
<t tx="ekr.20220312061835.1476"># diagram handler #############################################################


</t>
<t tx="ekr.20220312061835.1477">class DiadefsHandler:
    """handle diagram definitions :

    get it from user (i.e. xml files) or generate them
    """

    @others
</t>
<t tx="ekr.20220312061835.1478">def __init__(self, config):
    self.config = config

</t>
<t tx="ekr.20220312061835.1479">def get_diadefs(self, project, linker):
    """Get the diagrams configuration data

    :param project:The pyreverse project
    :type project: pyreverse.utils.Project
    :param linker: The linker
    :type linker: pyreverse.inspector.Linker(IdGeneratorMixIn, LocalsVisitor)

    :returns: The list of diagram definitions
    :rtype: list(:class:`pylint.pyreverse.diagrams.ClassDiagram`)
    """

    #  read and interpret diagram definitions (Diadefs)
    diagrams = []
    generator = ClassDiadefGenerator(linker, self)
    for klass in self.config.classes:
        diagrams.append(generator.class_diagram(project, klass))
    if not diagrams:
        diagrams = DefaultDiadefGenerator(linker, self).visit(project)
    for diagram in diagrams:
        diagram.extract_relationships()
    return diagrams
</t>
<t tx="ekr.20220312061835.148">def _create_naming_options():
    name_options = []
    for name_type in sorted(KNOWN_NAME_TYPES):
        human_readable_name = HUMAN_READABLE_TYPES[name_type]
        default_style = DEFAULT_NAMING_STYLES[name_type]
        name_type = name_type.replace("_", "-")
        name_options.append(
            (
                f"{name_type}-naming-style",
                {
                    "default": default_style,
                    "type": "choice",
                    "choices": list(NAMING_STYLES.keys()),
                    "metavar": "&lt;style&gt;",
                    "help": f"Naming style matching correct {human_readable_name} names.",
                },
            )
        )
        name_options.append(
            (
                f"{name_type}-rgx",
                {
                    "default": None,
                    "type": "regexp",
                    "metavar": "&lt;regexp&gt;",
                    "help": f"Regular expression matching correct {human_readable_name} names. Overrides {name_type}-naming-style.",
                },
            )
        )
    return tuple(name_options)


</t>
<t tx="ekr.20220312061835.1480">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2006, 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Mark Byrne &lt;31762852+mbyrnepr2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""diagram objects
"""

import astroid
from astroid import nodes

from pylint.checkers.utils import decorated_with_property
from pylint.pyreverse.utils import FilterMixIn, is_interface


@others
</t>
<t tx="ekr.20220312061835.1481">class Figure:
    """base class for counter handling"""


</t>
<t tx="ekr.20220312061835.1482">class Relationship(Figure):
    """a relation ship from an object in the diagram to another"""

    @others
</t>
<t tx="ekr.20220312061835.1483">def __init__(self, from_object, to_object, relation_type, name=None):
    Figure.__init__(self)
    self.from_object = from_object
    self.to_object = to_object
    self.type = relation_type
    self.name = name


</t>
<t tx="ekr.20220312061835.1484">class DiagramEntity(Figure):
    """a diagram object, i.e. a label associated to an astroid node"""

    def __init__(self, title="No name", node=None):
        Figure.__init__(self)
        self.title = title
        self.node = node


</t>
<t tx="ekr.20220312061835.1485">class PackageEntity(DiagramEntity):
    """A diagram object representing a package"""


</t>
<t tx="ekr.20220312061835.1486">class ClassEntity(DiagramEntity):
    """A diagram object representing a class"""

    def __init__(self, title, node):
        super().__init__(title=title, node=node)
        self.attrs = None
        self.methods = None


</t>
<t tx="ekr.20220312061835.1487">class ClassDiagram(Figure, FilterMixIn):
    """main class diagram handling"""

    TYPE = "class"

    @others
</t>
<t tx="ekr.20220312061835.1488">def __init__(self, title, mode):
    FilterMixIn.__init__(self, mode)
    Figure.__init__(self)
    self.title = title
    self.objects = []
    self.relationships = {}
    self._nodes = {}
    self.depends = []

</t>
<t tx="ekr.20220312061835.1489">def get_relationships(self, role):
    # sorted to get predictable (hence testable) results
    return sorted(
        self.relationships.get(role, ()),
        key=lambda x: (x.from_object.fig_id, x.to_object.fig_id),
    )

</t>
<t tx="ekr.20220312061835.149">class NameChecker(_BasicChecker):
    msgs = {
        "C0103": (
            '%s name "%s" doesn\'t conform to %s',
            "invalid-name",
            "Used when the name doesn't conform to naming rules "
            "associated to its type (constant, variable, class...).",
        ),
        "C0104": (
            'Disallowed name "%s"',
            "disallowed-name",
            "Used when the name matches bad-names or bad-names-rgxs- (unauthorized names).",
            {
                "old_names": [
                    ("C0102", "blacklisted-name"),
                ]
            },
        ),
        "C0144": (
            '%s name "%s" contains a non-ASCII unicode character',
            "non-ascii-name",
            "Used when the name contains at least one non-ASCII unicode character.",
        ),
        "W0111": (
            "Name %s will become a keyword in Python %s",
            "assign-to-new-keyword",
            "Used when assignment will become invalid in future "
            "Python release due to introducing new keyword.",
        ),
    }

    options = (
        (
            "good-names",
            {
                "default": ("i", "j", "k", "ex", "Run", "_"),
                "type": "csv",
                "metavar": "&lt;names&gt;",
                "help": "Good variable names which should always be accepted,"
                " separated by a comma.",
            },
        ),
        (
            "good-names-rgxs",
            {
                "default": "",
                "type": "regexp_csv",
                "metavar": "&lt;names&gt;",
                "help": "Good variable names regexes, separated by a comma. If names match any regex,"
                " they will always be accepted",
            },
        ),
        (
            "bad-names",
            {
                "default": ("foo", "bar", "baz", "toto", "tutu", "tata"),
                "type": "csv",
                "metavar": "&lt;names&gt;",
                "help": "Bad variable names which should always be refused, "
                "separated by a comma.",
            },
        ),
        (
            "bad-names-rgxs",
            {
                "default": "",
                "type": "regexp_csv",
                "metavar": "&lt;names&gt;",
                "help": "Bad variable names regexes, separated by a comma. If names match any regex,"
                " they will always be refused",
            },
        ),
        (
            "name-group",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;name1:name2&gt;",
                "help": (
                    "Colon-delimited sets of names that determine each"
                    " other's naming style when the name regexes"
                    " allow several styles."
                ),
            },
        ),
        (
            "include-naming-hint",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Include a hint for the correct naming format with invalid-name.",
            },
        ),
        (
            "property-classes",
            {
                "default": ("abc.abstractproperty",),
                "type": "csv",
                "metavar": "&lt;decorator names&gt;",
                "help": "List of decorators that produce properties, such as "
                "abc.abstractproperty. Add to this list to register "
                "other decorators that produce valid properties. "
                "These decorators are taken in consideration only for invalid-name.",
            },
        ),
    ) + _create_naming_options()

    KEYWORD_ONSET = {(3, 7): {"async", "await"}}

    @others
</t>
<t tx="ekr.20220312061835.1490">def add_relationship(self, from_object, to_object, relation_type, name=None):
    """create a relation ship"""
    rel = Relationship(from_object, to_object, relation_type, name)
    self.relationships.setdefault(relation_type, []).append(rel)

</t>
<t tx="ekr.20220312061835.1491">def get_relationship(self, from_object, relation_type):
    """return a relation ship or None"""
    for rel in self.relationships.get(relation_type, ()):
        if rel.from_object is from_object:
            return rel
    raise KeyError(relation_type)

</t>
<t tx="ekr.20220312061835.1492">def get_attrs(self, node):
    """return visible attributes, possibly with class name"""
    attrs = []
    properties = [
        (n, m)
        for n, m in node.items()
        if isinstance(m, nodes.FunctionDef) and decorated_with_property(m)
    ]
    for node_name, associated_nodes in (
        list(node.instance_attrs_type.items())
        + list(node.locals_type.items())
        + properties
    ):
        if not self.show_attr(node_name):
            continue
        names = self.class_names(associated_nodes)
        if names:
            node_name = f"{node_name} : {', '.join(names)}"
        attrs.append(node_name)
    return sorted(attrs)

</t>
<t tx="ekr.20220312061835.1493">def get_methods(self, node):
    """return visible methods"""
    methods = [
        m
        for m in node.values()
        if isinstance(m, nodes.FunctionDef)
        and not decorated_with_property(m)
        and self.show_attr(m.name)
    ]
    return sorted(methods, key=lambda n: n.name)

</t>
<t tx="ekr.20220312061835.1494">def add_object(self, title, node):
    """create a diagram object"""
    assert node not in self._nodes
    ent = DiagramEntity(title, node)
    self._nodes[node] = ent
    self.objects.append(ent)

</t>
<t tx="ekr.20220312061835.1495">def class_names(self, nodes_lst):
    """return class names if needed in diagram"""
    names = []
    for node in nodes_lst:
        if isinstance(node, astroid.Instance):
            node = node._proxied
        if (
            isinstance(node, (nodes.ClassDef, nodes.Name, nodes.Subscript))
            and hasattr(node, "name")
            and not self.has_node(node)
        ):
            if node.name not in names:
                node_name = node.name
                names.append(node_name)
    return names

</t>
<t tx="ekr.20220312061835.1496">def nodes(self):
    """return the list of underlying nodes"""
    return self._nodes.keys()

</t>
<t tx="ekr.20220312061835.1497">def has_node(self, node):
    """return true if the given node is included in the diagram"""
    return node in self._nodes

</t>
<t tx="ekr.20220312061835.1498">def object_from_node(self, node):
    """return the diagram object mapped to node"""
    return self._nodes[node]

</t>
<t tx="ekr.20220312061835.1499">def classes(self):
    """return all class nodes in the diagram"""
    return [o for o in self.objects if isinstance(o.node, nodes.ClassDef)]

</t>
<t tx="ekr.20220312061835.15">class NoLineSuppliedError(Exception):
    """raised when trying to disable a message on a next line without supplying a line number"""
</t>
<t tx="ekr.20220312061835.150">def __init__(self, linter):
    _BasicChecker.__init__(self, linter)
    self._name_category = {}
    self._name_group = {}
    self._bad_names = {}
    self._name_regexps = {}
    self._name_hints = {}
    self._good_names_rgxs_compiled = []
    self._bad_names_rgxs_compiled = []
    self._non_ascii_rgx_compiled = re.compile("[^\u0000-\u007F]")

</t>
<t tx="ekr.20220312061835.1500">def classe(self, name):
    """return a class by its name, raise KeyError if not found"""
    for klass in self.classes():
        if klass.node.name == name:
            return klass
    raise KeyError(name)

</t>
<t tx="ekr.20220312061835.1501">def extract_relationships(self):
    """extract relation ships between nodes in the diagram"""
    for obj in self.classes():
        node = obj.node
        obj.attrs = self.get_attrs(node)
        obj.methods = self.get_methods(node)
        # shape
        if is_interface(node):
            obj.shape = "interface"
        else:
            obj.shape = "class"
        # inheritance link
        for par_node in node.ancestors(recurs=False):
            try:
                par_obj = self.object_from_node(par_node)
                self.add_relationship(obj, par_obj, "specialization")
            except KeyError:
                continue
        # implements link
        for impl_node in node.implements:
            try:
                impl_obj = self.object_from_node(impl_node)
                self.add_relationship(obj, impl_obj, "implements")
            except KeyError:
                continue
        # associations link
        for name, values in list(node.instance_attrs_type.items()) + list(
            node.locals_type.items()
        ):
            for value in values:
                if value is astroid.Uninferable:
                    continue
                if isinstance(value, astroid.Instance):
                    value = value._proxied
                try:
                    associated_obj = self.object_from_node(value)
                    self.add_relationship(associated_obj, obj, "association", name)
                except KeyError:
                    continue


</t>
<t tx="ekr.20220312061835.1502">class PackageDiagram(ClassDiagram):
    """package diagram handling"""

    TYPE = "package"

    @others
</t>
<t tx="ekr.20220312061835.1503">def modules(self):
    """return all module nodes in the diagram"""
    return [o for o in self.objects if isinstance(o.node, nodes.Module)]

</t>
<t tx="ekr.20220312061835.1504">def module(self, name):
    """return a module by its name, raise KeyError if not found"""
    for mod in self.modules():
        if mod.node.name == name:
            return mod
    raise KeyError(name)

</t>
<t tx="ekr.20220312061835.1505">def get_module(self, name, node):
    """return a module by its name, looking also for relative imports;
    raise KeyError if not found
    """
    for mod in self.modules():
        mod_name = mod.node.name
        if mod_name == name:
            return mod
        # search for fullname of relative import modules
        package = node.root().name
        if mod_name == f"{package}.{name}":
            return mod
        if mod_name == f"{package.rsplit('.', 1)[0]}.{name}":
            return mod
    raise KeyError(name)

</t>
<t tx="ekr.20220312061835.1506">def add_from_depend(self, node, from_module):
    """add dependencies created by from-imports"""
    mod_name = node.root().name
    obj = self.module(mod_name)
    if from_module not in obj.node.depends:
        obj.node.depends.append(from_module)

</t>
<t tx="ekr.20220312061835.1507">def extract_relationships(self):
    """extract relation ships between nodes in the diagram"""
    ClassDiagram.extract_relationships(self)
    for obj in self.classes():
        # ownership
        try:
            mod = self.object_from_node(obj.node.root())
            self.add_relationship(obj, mod, "ownership")
        except KeyError:
            continue
    for obj in self.modules():
        obj.shape = "package"
        # dependencies
        for dep_name in obj.node.depends:
            try:
                dep = self.get_module(dep_name, obj.node)
            except KeyError:
                continue
            self.add_relationship(obj, dep, "depends")
</t>
<t tx="ekr.20220312061835.1508">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
Class to generate files in dot format and image formats supported by Graphviz.
"""
import os
import subprocess
import sys
import tempfile
from pathlib import Path
from typing import Dict, FrozenSet, List, Optional

from astroid import nodes

from pylint.pyreverse.printer import EdgeType, Layout, NodeProperties, NodeType, Printer
from pylint.pyreverse.utils import check_graphviz_availability, get_annotation_label

ALLOWED_CHARSETS: FrozenSet[str] = frozenset(("utf-8", "iso-8859-1", "latin1"))
SHAPES: Dict[NodeType, str] = {
    NodeType.PACKAGE: "box",
    NodeType.INTERFACE: "record",
    NodeType.CLASS: "record",
}
ARROWS: Dict[EdgeType, Dict] = {
    EdgeType.INHERITS: dict(arrowtail="none", arrowhead="empty"),
    EdgeType.IMPLEMENTS: dict(arrowtail="node", arrowhead="empty", style="dashed"),
    EdgeType.ASSOCIATION: dict(
        fontcolor="green", arrowtail="none", arrowhead="diamond", style="solid"
    ),
    EdgeType.USES: dict(arrowtail="none", arrowhead="open"),
}


@others
</t>
<t tx="ekr.20220312061835.1509">class DotPrinter(Printer):
    DEFAULT_COLOR = "black"

    @others
</t>
<t tx="ekr.20220312061835.151">def open(self):
    self.stats = self.linter.add_stats(
        badname_module=0,
        badname_class=0,
        badname_function=0,
        badname_method=0,
        badname_attr=0,
        badname_const=0,
        badname_variable=0,
        badname_inlinevar=0,
        badname_argument=0,
        badname_class_attribute=0,
        badname_class_const=0,
    )
    for group in self.config.name_group:
        for name_type in group.split(":"):
            self._name_group[name_type] = f"group_{group}"

    regexps, hints = self._create_naming_rules()
    self._name_regexps = regexps
    self._name_hints = hints
    self._good_names_rgxs_compiled = [
        re.compile(rgxp) for rgxp in self.config.good_names_rgxs
    ]
    self._bad_names_rgxs_compiled = [
        re.compile(rgxp) for rgxp in self.config.bad_names_rgxs
    ]

</t>
<t tx="ekr.20220312061835.1510">def __init__(
    self,
    title: str,
    layout: Optional[Layout] = None,
    use_automatic_namespace: Optional[bool] = None,
):
    layout = layout or Layout.BOTTOM_TO_TOP
    self.charset = "utf-8"
    super().__init__(title, layout, use_automatic_namespace)

</t>
<t tx="ekr.20220312061835.1511">def _open_graph(self) -&gt; None:
    """Emit the header lines"""
    self.emit(f'digraph "{self.title}" {{')
    if self.layout:
        self.emit(f"rankdir={self.layout.value}")
    if self.charset:
        assert (
            self.charset.lower() in ALLOWED_CHARSETS
        ), f"unsupported charset {self.charset}"
        self.emit(f'charset="{self.charset}"')

</t>
<t tx="ekr.20220312061835.1512">def emit_node(
    self,
    name: str,
    type_: NodeType,
    properties: Optional[NodeProperties] = None,
) -&gt; None:
    """Create a new node. Nodes can be classes, packages, participants etc."""
    if properties is None:
        properties = NodeProperties(label=name)
    shape = SHAPES[type_]
    color = properties.color if properties.color is not None else self.DEFAULT_COLOR
    style = "filled" if color != self.DEFAULT_COLOR else "solid"
    label = self._build_label_for_node(properties)
    label_part = f', label="{label}"' if label else ""
    fontcolor_part = (
        f', fontcolor="{properties.fontcolor}"' if properties.fontcolor else ""
    )
    self.emit(
        f'"{name}" [color="{color}"{fontcolor_part}{label_part}, shape="{shape}", style="{style}"];'
    )

</t>
<t tx="ekr.20220312061835.1513">def _build_label_for_node(
    self, properties: NodeProperties, is_interface: Optional[bool] = False
) -&gt; str:
    if not properties.label:
        return ""

    label: str = properties.label
    if is_interface:
        # add a stereotype
        label = "&lt;&lt;interface&gt;&gt;\\n" + label

    if properties.attrs is None and properties.methods is None:
        # return a "compact" form which only displays the class name in a box
        return label

    # Add class attributes
    attrs: List[str] = properties.attrs or []
    label = "{" + label + "|" + r"\l".join(attrs) + r"\l|"

    # Add class methods
    methods: List[nodes.FunctionDef] = properties.methods or []
    for func in methods:
        args = self._get_method_arguments(func)
        label += fr"{func.name}({', '.join(args)})"
        if func.returns:
            label += ": " + get_annotation_label(func.returns)
        label += r"\l"
    label += "}"
    return label

</t>
<t tx="ekr.20220312061835.1514">def emit_edge(
    self,
    from_node: str,
    to_node: str,
    type_: EdgeType,
    label: Optional[str] = None,
) -&gt; None:
    """Create an edge from one node to another to display relationships."""
    arrowstyle = ARROWS[type_]
    attrs = [f'{prop}="{value}"' for prop, value in arrowstyle.items()]
    if label:
        attrs.append(f'label="{label}"')
    self.emit(f'"{from_node}" -&gt; "{to_node}" [{", ".join(sorted(attrs))}];')

</t>
<t tx="ekr.20220312061835.1515">def generate(self, outputfile: str) -&gt; None:
    self._close_graph()
    graphviz_extensions = ("dot", "gv")
    name = self.title
    if outputfile is None:
        target = "png"
        pdot, dot_sourcepath = tempfile.mkstemp(".gv", name)
        ppng, outputfile = tempfile.mkstemp(".png", name)
        os.close(pdot)
        os.close(ppng)
    else:
        target = Path(outputfile).suffix.lstrip(".")
        if not target:
            target = "png"
            outputfile = outputfile + "." + target
        if target not in graphviz_extensions:
            pdot, dot_sourcepath = tempfile.mkstemp(".gv", name)
            os.close(pdot)
        else:
            dot_sourcepath = outputfile
    with open(dot_sourcepath, "w", encoding="utf8") as outfile:
        outfile.writelines(self.lines)
    if target not in graphviz_extensions:
        check_graphviz_availability()
        use_shell = sys.platform == "win32"
        subprocess.call(
            ["dot", "-T", target, dot_sourcepath, "-o", outputfile],
            shell=use_shell,
        )
        os.unlink(dot_sourcepath)

</t>
<t tx="ekr.20220312061835.1516">def _close_graph(self) -&gt; None:
    """Emit the lines needed to properly close the graph."""
    self.emit("}\n")
</t>
<t tx="ekr.20220312061835.1517">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Mark Byrne &lt;31762852+mbyrnepr2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
Visitor doing some postprocessing on the astroid tree.
Try to resolve definitions (namespace) dictionary, relationship...
"""
import collections
import os
import traceback

import astroid
from astroid import nodes

from pylint.pyreverse import utils


@others
</t>
<t tx="ekr.20220312061835.1518">def _iface_hdlr(_):
    """Handler used by interfaces to handle suspicious interface nodes."""
    return True


</t>
<t tx="ekr.20220312061835.1519">def _astroid_wrapper(func, modname):
    print(f"parsing {modname}...")
    try:
        return func(modname)
    except astroid.exceptions.AstroidBuildingException as exc:
        print(exc)
    except Exception:  # pylint: disable=broad-except
        traceback.print_exc()
    return None


</t>
<t tx="ekr.20220312061835.152">def _create_naming_rules(self):
    regexps = {}
    hints = {}

    for name_type in KNOWN_NAME_TYPES:
        naming_style_option_name = f"{name_type}_naming_style"
        naming_style_name = getattr(self.config, naming_style_option_name)

        regexps[name_type] = NAMING_STYLES[naming_style_name].get_regex(name_type)

        custom_regex_setting_name = f"{name_type}_rgx"
        custom_regex = getattr(self.config, custom_regex_setting_name, None)
        if custom_regex is not None:
            regexps[name_type] = custom_regex

        if custom_regex is not None:
            hints[name_type] = f"{custom_regex.pattern!r} pattern"
        else:
            hints[name_type] = f"{naming_style_name} naming style"

    return regexps, hints

</t>
<t tx="ekr.20220312061835.1520">def interfaces(node, herited=True, handler_func=_iface_hdlr):
    """Return an iterator on interfaces implemented by the given class node."""
    try:
        implements = astroid.bases.Instance(node).getattr("__implements__")[0]
    except astroid.exceptions.NotFoundError:
        return
    if not herited and implements.frame() is not node:
        return
    found = set()
    missing = False
    for iface in nodes.unpack_infer(implements):
        if iface is astroid.Uninferable:
            missing = True
            continue
        if iface not in found and handler_func(iface):
            found.add(iface)
            yield iface
    if missing:
        raise astroid.exceptions.InferenceError()


</t>
<t tx="ekr.20220312061835.1521">class IdGeneratorMixIn:
    """Mixin adding the ability to generate integer uid."""

    @others
</t>
<t tx="ekr.20220312061835.1522">def __init__(self, start_value=0):
    self.id_count = start_value

</t>
<t tx="ekr.20220312061835.1523">def init_counter(self, start_value=0):
    """init the id counter"""
    self.id_count = start_value

</t>
<t tx="ekr.20220312061835.1524">def generate_id(self):
    """generate a new identifier"""
    self.id_count += 1
    return self.id_count


</t>
<t tx="ekr.20220312061835.1525">class Project:
    """a project handle a set of modules / packages"""

    @others
</t>
<t tx="ekr.20220312061835.1526">def __init__(self, name=""):
    self.name = name
    self.uid = None
    self.path = None
    self.modules = []
    self.locals = {}
    self.__getitem__ = self.locals.__getitem__
    self.__iter__ = self.locals.__iter__
    self.values = self.locals.values
    self.keys = self.locals.keys
    self.items = self.locals.items

</t>
<t tx="ekr.20220312061835.1527">def add_module(self, node):
    self.locals[node.name] = node
    self.modules.append(node)

</t>
<t tx="ekr.20220312061835.1528">def get_module(self, name):
    return self.locals[name]

</t>
<t tx="ekr.20220312061835.1529">def get_children(self):
    return self.modules

</t>
<t tx="ekr.20220312061835.153">@utils.check_messages("disallowed-name", "invalid-name", "non-ascii-name")
def visit_module(self, node: nodes.Module) -&gt; None:
    self._check_name("module", node.name.split(".")[-1], node)
    self._bad_names = {}

</t>
<t tx="ekr.20220312061835.1530">def __repr__(self):
    return f"&lt;Project {self.name!r} at {id(self)} ({len(self.modules)} modules)&gt;"


</t>
<t tx="ekr.20220312061835.1531">class Linker(IdGeneratorMixIn, utils.LocalsVisitor):
    """Walk on the project tree and resolve relationships.

    According to options the following attributes may be
    added to visited nodes:

    * uid,
      a unique identifier for the node (on astroid.Project, astroid.Module,
      astroid.Class and astroid.locals_type). Only if the linker
      has been instantiated with tag=True parameter (False by default).

    * Function
      a mapping from locals names to their bounded value, which may be a
      constant like a string or an integer, or an astroid node
      (on astroid.Module, astroid.Class and astroid.Function).

    * instance_attrs_type
      as locals_type but for klass member attributes (only on astroid.Class)

    * implements,
      list of implemented interface _objects_ (only on astroid.Class nodes)
    """

    @others
</t>
<t tx="ekr.20220312061835.1532">def __init__(self, project, inherited_interfaces=0, tag=False):
    IdGeneratorMixIn.__init__(self)
    utils.LocalsVisitor.__init__(self)
    # take inherited interface in consideration or not
    self.inherited_interfaces = inherited_interfaces
    # tag nodes or not
    self.tag = tag
    # visited project
    self.project = project

</t>
<t tx="ekr.20220312061835.1533">def visit_project(self, node: Project) -&gt; None:
    """visit a pyreverse.utils.Project node

    * optionally tag the node with a unique id
    """
    if self.tag:
        node.uid = self.generate_id()
    for module in node.modules:
        self.visit(module)

</t>
<t tx="ekr.20220312061835.1534">def visit_module(self, node: nodes.Module) -&gt; None:
    """visit an astroid.Module node

    * set the locals_type mapping
    * set the depends mapping
    * optionally tag the node with a unique id
    """
    if hasattr(node, "locals_type"):
        return
    node.locals_type = collections.defaultdict(list)
    node.depends = []
    if self.tag:
        node.uid = self.generate_id()

</t>
<t tx="ekr.20220312061835.1535">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    """visit an astroid.Class node

    * set the locals_type and instance_attrs_type mappings
    * set the implements list and build it
    * optionally tag the node with a unique id
    """
    if hasattr(node, "locals_type"):
        return
    node.locals_type = collections.defaultdict(list)
    if self.tag:
        node.uid = self.generate_id()
    # resolve ancestors
    for baseobj in node.ancestors(recurs=False):
        specializations = getattr(baseobj, "specializations", [])
        specializations.append(node)
        baseobj.specializations = specializations
    # resolve instance attributes
    node.instance_attrs_type = collections.defaultdict(list)
    for assignattrs in node.instance_attrs.values():
        for assignattr in assignattrs:
            if not isinstance(assignattr, nodes.Unknown):
                self.handle_assignattr_type(assignattr, node)
    # resolve implemented interface
    try:
        node.implements = list(interfaces(node, self.inherited_interfaces))
    except astroid.InferenceError:
        node.implements = []

</t>
<t tx="ekr.20220312061835.1536">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """visit an astroid.Function node

    * set the locals_type mapping
    * optionally tag the node with a unique id
    """
    if hasattr(node, "locals_type"):
        return
    node.locals_type = collections.defaultdict(list)
    if self.tag:
        node.uid = self.generate_id()

</t>
<t tx="ekr.20220312061835.1537">link_project = visit_project
link_module = visit_module
link_class = visit_classdef
link_function = visit_functiondef

</t>
<t tx="ekr.20220312061835.1538">def visit_assignname(self, node: nodes.AssignName) -&gt; None:
    """visit an astroid.AssignName node

    handle locals_type
    """
    # avoid double parsing done by different Linkers.visit
    # running over the same project:
    if hasattr(node, "_handled"):
        return
    node._handled = True
    if node.name in node.frame():
        frame = node.frame()
    else:
        # the name has been defined as 'global' in the frame and belongs
        # there.
        frame = node.root()
    if not hasattr(frame, "locals_type"):
        # If the frame doesn't have a locals_type yet,
        # it means it wasn't yet visited. Visit it now
        # to add what's missing from it.
        if isinstance(frame, nodes.ClassDef):
            self.visit_classdef(frame)
        elif isinstance(frame, nodes.FunctionDef):
            self.visit_functiondef(frame)
        else:
            self.visit_module(frame)

    current = frame.locals_type[node.name]
    frame.locals_type[node.name] = list(set(current) | utils.infer_node(node))

</t>
<t tx="ekr.20220312061835.1539">@staticmethod
def handle_assignattr_type(node, parent):
    """handle an astroid.assignattr node

    handle instance_attrs_type
    """
    current = set(parent.instance_attrs_type[node.attrname])
    parent.instance_attrs_type[node.attrname] = list(
        current | utils.infer_node(node)
    )

</t>
<t tx="ekr.20220312061835.154">def leave_module(self, _: nodes.Module) -&gt; None:
    for all_groups in self._bad_names.values():
        if len(all_groups) &lt; 2:
            continue
        groups = collections.defaultdict(list)
        min_warnings = sys.maxsize
        prevalent_group, _ = max(all_groups.items(), key=lambda item: len(item[1]))
        for group in all_groups.values():
            groups[len(group)].append(group)
            min_warnings = min(len(group), min_warnings)
        if len(groups[min_warnings]) &gt; 1:
            by_line = sorted(
                groups[min_warnings],
                key=lambda group: min(warning[0].lineno for warning in group),
            )
            warnings = itertools.chain(*by_line[1:])
        else:
            warnings = groups[min_warnings][0]
        for args in warnings:
            self._raise_name_warning(prevalent_group, *args)

</t>
<t tx="ekr.20220312061835.1540">def visit_import(self, node: nodes.Import) -&gt; None:
    """visit an astroid.Import node

    resolve module dependencies
    """
    context_file = node.root().file
    for name in node.names:
        relative = astroid.modutils.is_relative(name[0], context_file)
        self._imported_module(node, name[0], relative)

</t>
<t tx="ekr.20220312061835.1541">def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """visit an astroid.ImportFrom node

    resolve module dependencies
    """
    basename = node.modname
    context_file = node.root().file
    if context_file is not None:
        relative = astroid.modutils.is_relative(basename, context_file)
    else:
        relative = False
    for name in node.names:
        if name[0] == "*":
            continue
        # analyze dependencies
        fullname = f"{basename}.{name[0]}"
        if fullname.find(".") &gt; -1:
            try:
                fullname = astroid.modutils.get_module_part(fullname, context_file)
            except ImportError:
                continue
        if fullname != basename:
            self._imported_module(node, fullname, relative)

</t>
<t tx="ekr.20220312061835.1542">def compute_module(self, context_name, mod_path):
    """return true if the module should be added to dependencies"""
    package_dir = os.path.dirname(self.project.path)
    if context_name == mod_path:
        return 0
    if astroid.modutils.is_standard_module(mod_path, (package_dir,)):
        return 1
    return 0

</t>
<t tx="ekr.20220312061835.1543">def _imported_module(self, node, mod_path, relative):
    """Notify an imported module, used to analyze dependencies"""
    module = node.root()
    context_name = module.name
    if relative:
        mod_path = f"{'.'.join(context_name.split('.')[:-1])}.{mod_path}"
    if self.compute_module(context_name, mod_path):
        # handle dependencies
        if not hasattr(module, "depends"):
            module.depends = []
        mod_paths = module.depends
        if mod_path not in mod_paths:
            mod_paths.append(mod_path)


</t>
<t tx="ekr.20220312061835.1544">def project_from_files(
    files, func_wrapper=_astroid_wrapper, project_name="no name", black_list=("CVS",)
):
    """return a Project from a list of files or modules"""
    # build the project representation
    astroid_manager = astroid.manager.AstroidManager()
    project = Project(project_name)
    for something in files:
        if not os.path.exists(something):
            fpath = astroid.modutils.file_from_modpath(something.split("."))
        elif os.path.isdir(something):
            fpath = os.path.join(something, "__init__.py")
        else:
            fpath = something
        ast = func_wrapper(astroid_manager.ast_from_file, fpath)
        if ast is None:
            continue
        project.path = project.path or ast.file
        project.add_module(ast)
        base_name = ast.name
        # recurse in package except if __init__ was explicitly given
        if ast.package and something.find("__init__") == -1:
            # recurse on others packages / modules if this is a package
            for fpath in astroid.modutils.get_module_files(
                os.path.dirname(ast.file), black_list
            ):
                ast = func_wrapper(astroid_manager.ast_from_file, fpath)
                if ast is None or ast.name == base_name:
                    continue
                project.add_module(ast)
    return project
</t>
<t tx="ekr.20220312061835.1545">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2008-2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Alexander Pervakov &lt;frost.nzcr4@jagmort.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Mark Byrne &lt;31762852+mbyrnepr2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
  %prog [options] &lt;packages&gt;

  create UML diagrams for classes and modules in &lt;packages&gt;
"""
import os
import sys
from typing import Iterable

from pylint.config import ConfigurationMixIn
from pylint.pyreverse import writer
from pylint.pyreverse.diadefslib import DiadefsHandler
from pylint.pyreverse.inspector import Linker, project_from_files
from pylint.pyreverse.utils import check_graphviz_availability, insert_default_options

OPTIONS = (
    (
        "filter-mode",
        dict(
            short="f",
            default="PUB_ONLY",
            dest="mode",
            type="string",
            action="store",
            metavar="&lt;mode&gt;",
            help="""filter attributes and functions according to
    &lt;mode&gt;. Correct modes are :
                            'PUB_ONLY' filter all non public attributes
                                [DEFAULT], equivalent to PRIVATE+SPECIAL_A
                            'ALL' no filter
                            'SPECIAL' filter Python special functions
                                except constructor
                            'OTHER' filter protected and private
                                attributes""",
        ),
    ),
    (
        "class",
        dict(
            short="c",
            action="append",
            metavar="&lt;class&gt;",
            dest="classes",
            default=[],
            help="create a class diagram with all classes related to &lt;class&gt;;\
 this uses by default the options -ASmy",
        ),
    ),
    (
        "show-ancestors",
        dict(
            short="a",
            action="store",
            metavar="&lt;ancestor&gt;",
            type="int",
            help="show &lt;ancestor&gt; generations of ancestor classes not in &lt;projects&gt;",
        ),
    ),
    (
        "all-ancestors",
        dict(
            short="A",
            default=None,
            help="show all ancestors off all classes in &lt;projects&gt;",
        ),
    ),
    (
        "show-associated",
        dict(
            short="s",
            action="store",
            metavar="&lt;association_level&gt;",
            type="int",
            help="show &lt;association_level&gt; levels of associated classes not in &lt;projects&gt;",
        ),
    ),
    (
        "all-associated",
        dict(
            short="S",
            default=None,
            help="show recursively all associated off all associated classes",
        ),
    ),
    (
        "show-builtin",
        dict(
            short="b",
            action="store_true",
            default=False,
            help="include builtin objects in representation of classes",
        ),
    ),
    (
        "module-names",
        dict(
            short="m",
            default=None,
            type="yn",
            metavar="[yn]",
            help="include module name in representation of classes",
        ),
    ),
    (
        "only-classnames",
        dict(
            short="k",
            action="store_true",
            default=False,
            help="don't show attributes and methods in the class boxes; this disables -f values",
        ),
    ),
    (
        "output",
        dict(
            short="o",
            dest="output_format",
            action="store",
            default="dot",
            metavar="&lt;format&gt;",
            help="create a *.&lt;format&gt; output file if format available.",
        ),
    ),
    (
        "colorized",
        dict(
            dest="colorized",
            action="store_true",
            default=False,
            help="Use colored output. Classes/modules of the same package get the same color.",
        ),
    ),
    (
        "max-color-depth",
        dict(
            dest="max_color_depth",
            action="store",
            default=2,
            metavar="&lt;depth&gt;",
            type="int",
            help="Use separate colors up to package depth of &lt;depth&gt;",
        ),
    ),
    (
        "ignore",
        dict(
            type="csv",
            metavar="&lt;file[,file...]&gt;",
            dest="ignore_list",
            default=("CVS",),
            help="Files or directories to be skipped. They should be base names, not paths.",
        ),
    ),
    (
        "project",
        dict(
            default="",
            type="string",
            short="p",
            metavar="&lt;project name&gt;",
            help="set the project name.",
        ),
    ),
    (
        "output-directory",
        dict(
            default="",
            type="string",
            short="d",
            action="store",
            metavar="&lt;output_directory&gt;",
            help="set the output directory path.",
        ),
    ),
)


@others
if __name__ == "__main__":
    Run(sys.argv[1:])
</t>
<t tx="ekr.20220312061835.1546">class Run(ConfigurationMixIn):
    """base class providing common behaviour for pyreverse commands"""

    options = OPTIONS

    @others
</t>
<t tx="ekr.20220312061835.1547">def __init__(self, args: Iterable[str]):
    ConfigurationMixIn.__init__(self, usage=__doc__)
    insert_default_options()
    args = self.load_command_line_configuration(args)
    if self.config.output_format not in ("dot", "vcg"):
        check_graphviz_availability()

    sys.exit(self.run(args))

</t>
<t tx="ekr.20220312061835.1548">def run(self, args):
    """checking arguments and run project"""
    if not args:
        print(self.help())
        return 1
    # insert current working directory to the python path to recognize
    # dependencies to local modules even if cwd is not in the PYTHONPATH
    sys.path.insert(0, os.getcwd())
    try:
        project = project_from_files(
            args,
            project_name=self.config.project,
            black_list=self.config.ignore_list,
        )
        linker = Linker(project, tag=True)
        handler = DiadefsHandler(self.config)
        diadefs = handler.get_diadefs(project, linker)
    finally:
        sys.path.pop(0)
    writer.DiagramWriter(self.config).write(diadefs)
    return 0


</t>
<t tx="ekr.20220312061835.1549">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
Class to generate files in dot format and image formats supported by Graphviz.
"""
from typing import Dict, Optional

from pylint.pyreverse.printer import EdgeType, Layout, NodeProperties, NodeType, Printer
from pylint.pyreverse.utils import get_annotation_label


@others
</t>
<t tx="ekr.20220312061835.155">@utils.check_messages(
    "disallowed-name", "invalid-name", "assign-to-new-keyword", "non-ascii-name"
)
</t>
<t tx="ekr.20220312061835.1550">class PlantUmlPrinter(Printer):
    """Printer for PlantUML diagrams"""

    DEFAULT_COLOR = "black"

    NODES: Dict[NodeType, str] = {
        NodeType.CLASS: "class",
        NodeType.INTERFACE: "class",
        NodeType.PACKAGE: "package",
    }
    ARROWS: Dict[EdgeType, str] = {
        EdgeType.INHERITS: "--|&gt;",
        EdgeType.IMPLEMENTS: "..|&gt;",
        EdgeType.ASSOCIATION: "--*",
        EdgeType.USES: "--&gt;",
    }

    @others
</t>
<t tx="ekr.20220312061835.1551">def _open_graph(self) -&gt; None:
    """Emit the header lines"""
    self.emit("@startuml " + self.title)
    if not self.use_automatic_namespace:
        self.emit("set namespaceSeparator none")
    if self.layout:
        if self.layout is Layout.LEFT_TO_RIGHT:
            self.emit("left to right direction")
        elif self.layout is Layout.TOP_TO_BOTTOM:
            self.emit("top to bottom direction")
        else:
            raise ValueError(
                f"Unsupported layout {self.layout}. PlantUmlPrinter only supports left to right and top to bottom layout."
            )

</t>
<t tx="ekr.20220312061835.1552">def emit_node(
    self,
    name: str,
    type_: NodeType,
    properties: Optional[NodeProperties] = None,
) -&gt; None:
    """Create a new node. Nodes can be classes, packages, participants etc."""
    if properties is None:
        properties = NodeProperties(label=name)
    stereotype = " &lt;&lt; interface &gt;&gt;" if type_ is NodeType.INTERFACE else ""
    nodetype = self.NODES[type_]
    if properties.color and properties.color != self.DEFAULT_COLOR:
        color = f" #{properties.color}"
    else:
        color = ""
    body = []
    if properties.attrs:
        body.extend(properties.attrs)
    if properties.methods:
        for func in properties.methods:
            args = self._get_method_arguments(func)
            line = f"{func.name}({', '.join(args)})"
            if func.returns:
                line += " -&gt; " + get_annotation_label(func.returns)
            body.append(line)
    label = properties.label if properties.label is not None else name
    if properties.fontcolor and properties.fontcolor != self.DEFAULT_COLOR:
        label = f"&lt;color:{properties.fontcolor}&gt;{label}&lt;/color&gt;"
    self.emit(f'{nodetype} "{label}" as {name}{stereotype}{color} {{')
    self._inc_indent()
    for line in body:
        self.emit(line)
    self._dec_indent()
    self.emit("}")

</t>
<t tx="ekr.20220312061835.1553">def emit_edge(
    self,
    from_node: str,
    to_node: str,
    type_: EdgeType,
    label: Optional[str] = None,
) -&gt; None:
    """Create an edge from one node to another to display relationships."""
    edge = f"{from_node} {self.ARROWS[type_]} {to_node}"
    if label:
        edge += f" : {label}"
    self.emit(edge)

</t>
<t tx="ekr.20220312061835.1554">def _close_graph(self) -&gt; None:
    """Emit the lines needed to properly close the graph."""
    self.emit("@enduml")
</t>
<t tx="ekr.20220312061835.1555">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
Base class defining the interface for a printer.
"""
from abc import ABC, abstractmethod
from enum import Enum
from typing import List, NamedTuple, Optional

from astroid import nodes

from pylint.pyreverse.utils import get_annotation_label


@others
</t>
<t tx="ekr.20220312061835.1556">class NodeType(Enum):
    CLASS = "class"
    INTERFACE = "interface"
    PACKAGE = "package"


</t>
<t tx="ekr.20220312061835.1557">class EdgeType(Enum):
    INHERITS = "inherits"
    IMPLEMENTS = "implements"
    ASSOCIATION = "association"
    USES = "uses"


</t>
<t tx="ekr.20220312061835.1558">class Layout(Enum):
    LEFT_TO_RIGHT = "LR"
    RIGHT_TO_LEFT = "RL"
    TOP_TO_BOTTOM = "TB"
    BOTTOM_TO_TOP = "BT"


</t>
<t tx="ekr.20220312061835.1559">class NodeProperties(NamedTuple):
    label: str
    attrs: Optional[List[str]] = None
    methods: Optional[List[nodes.FunctionDef]] = None
    color: Optional[str] = None
    fontcolor: Optional[str] = None


</t>
<t tx="ekr.20220312061835.156">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    self._check_assign_to_new_keyword_violation(node.name, node)
    self._check_name("class", node.name, node)
    for attr, anodes in node.instance_attrs.items():
        if not any(node.instance_attr_ancestors(attr)):
            self._check_name("attr", attr, anodes[0])

</t>
<t tx="ekr.20220312061835.1560">class Printer(ABC):
    """Base class defining the interface for a printer"""

    @others
</t>
<t tx="ekr.20220312061835.1561">def __init__(
    self,
    title: str,
    layout: Optional[Layout] = None,
    use_automatic_namespace: Optional[bool] = None,
):
    self.title: str = title
    self.layout = layout
    self.use_automatic_namespace = use_automatic_namespace
    self.lines: List[str] = []
    self._indent = ""
    self._open_graph()

</t>
<t tx="ekr.20220312061835.1562">def _inc_indent(self):
    """increment indentation"""
    self._indent += "  "

</t>
<t tx="ekr.20220312061835.1563">def _dec_indent(self):
    """decrement indentation"""
    self._indent = self._indent[:-2]

</t>
<t tx="ekr.20220312061835.1564">@abstractmethod
def _open_graph(self) -&gt; None:
    """Emit the header lines, i.e. all boilerplate code that defines things like layout etc."""

</t>
<t tx="ekr.20220312061835.1565">def emit(self, line: str, force_newline: Optional[bool] = True) -&gt; None:
    if force_newline and not line.endswith("\n"):
        line += "\n"
    self.lines.append(self._indent + line)

</t>
<t tx="ekr.20220312061835.1566">@abstractmethod
def emit_node(
    self,
    name: str,
    type_: NodeType,
    properties: Optional[NodeProperties] = None,
) -&gt; None:
    """Create a new node. Nodes can be classes, packages, participants etc."""

</t>
<t tx="ekr.20220312061835.1567">@abstractmethod
def emit_edge(
    self,
    from_node: str,
    to_node: str,
    type_: EdgeType,
    label: Optional[str] = None,
) -&gt; None:
    """Create an edge from one node to another to display relationships."""

</t>
<t tx="ekr.20220312061835.1568">@staticmethod
def _get_method_arguments(method: nodes.FunctionDef) -&gt; List[str]:
    if method.args.args:
        arguments: List[nodes.AssignName] = [
            arg for arg in method.args.args if arg.name != "self"
        ]
    else:
        arguments = []

    annotations = dict(zip(arguments, method.args.annotations[1:]))
    for arg in arguments:
        annotation_label = ""
        ann = annotations.get(arg)
        if ann:
            annotation_label = get_annotation_label(ann)
        annotations[arg] = annotation_label

    return [
        f"{arg.name}: {ann}" if ann else f"{arg.name}"
        for arg, ann in annotations.items()
    ]

</t>
<t tx="ekr.20220312061835.1569">def generate(self, outputfile: str) -&gt; None:
    """Generate and save the final outputfile."""
    self._close_graph()
    with open(outputfile, "w", encoding="utf-8") as outfile:
        outfile.writelines(self.lines)

</t>
<t tx="ekr.20220312061835.157">@utils.check_messages(
    "disallowed-name", "invalid-name", "assign-to-new-keyword", "non-ascii-name"
)
</t>
<t tx="ekr.20220312061835.1570">@abstractmethod
def _close_graph(self) -&gt; None:
    """Emit the lines needed to properly close the graph."""
</t>
<t tx="ekr.20220312061835.1571">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from typing import Type

from pylint.pyreverse.dot_printer import DotPrinter
from pylint.pyreverse.plantuml_printer import PlantUmlPrinter
from pylint.pyreverse.printer import Printer
from pylint.pyreverse.vcg_printer import VCGPrinter

filetype_to_printer = {
    "vcg": VCGPrinter,
    "plantuml": PlantUmlPrinter,
    "puml": PlantUmlPrinter,
    "dot": DotPrinter,
}


@others
</t>
<t tx="ekr.20220312061835.1572">def get_printer_for_filetype(filetype: str) -&gt; Type[Printer]:
    return filetype_to_printer.get(filetype, DotPrinter)
</t>
<t tx="ekr.20220312061835.1573">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2006, 2008, 2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 yeting li &lt;liyt@ios.ac.cn&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2020 bernie gray &lt;bfgray3@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Mark Byrne &lt;31762852+mbyrnepr2@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Generic classes/functions for pyreverse core/extensions. """
import os
import re
import shutil
import sys
from typing import Optional, Union

import astroid
from astroid import nodes

RCFILE = ".pyreverserc"


@others
</t>
<t tx="ekr.20220312061835.1574">def get_default_options():
    """Read config file and return list of options."""
    options = []
    home = os.environ.get("HOME", "")
    if home:
        rcfile = os.path.join(home, RCFILE)
        try:
            with open(rcfile, encoding="utf-8") as file_handle:
                options = file_handle.read().split()
        except OSError:
            pass  # ignore if no config file found
    return options


</t>
<t tx="ekr.20220312061835.1575">def insert_default_options():
    """insert default options to sys.argv"""
    options = get_default_options()
    options.reverse()
    for arg in options:
        sys.argv.insert(1, arg)


</t>
<t tx="ekr.20220312061835.1576"># astroid utilities ###########################################################
SPECIAL = re.compile(r"^__([^\W_]_*)+__$")
PRIVATE = re.compile(r"^__(_*[^\W_])+_?$")
PROTECTED = re.compile(r"^_\w*$")


</t>
<t tx="ekr.20220312061835.1577">def get_visibility(name):
    """return the visibility from a name: public, protected, private or special"""
    if SPECIAL.match(name):
        visibility = "special"
    elif PRIVATE.match(name):
        visibility = "private"
    elif PROTECTED.match(name):
        visibility = "protected"

    else:
        visibility = "public"
    return visibility


</t>
<t tx="ekr.20220312061835.1578">ABSTRACT = re.compile(r"^.*Abstract.*")
FINAL = re.compile(r"^[^\W\da-z]*$")


</t>
<t tx="ekr.20220312061835.1579">def is_abstract(node):
    """return true if the given class node correspond to an abstract class
    definition
    """
    return ABSTRACT.match(node.name)


</t>
<t tx="ekr.20220312061835.158">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    # Do not emit any warnings if the method is just an implementation
    # of a base class method.
    self._check_assign_to_new_keyword_violation(node.name, node)
    confidence = interfaces.HIGH
    if node.is_method():
        if utils.overrides_a_method(node.parent.frame(), node.name):
            return
        confidence = (
            interfaces.INFERENCE
            if utils.has_known_bases(node.parent.frame())
            else interfaces.INFERENCE_FAILURE
        )

    self._check_name(
        _determine_function_name_type(node, config=self.config),
        node.name,
        node,
        confidence,
    )
    # Check argument names
    args = node.args.args
    if args is not None:
        self._recursive_check_names(args, node)

</t>
<t tx="ekr.20220312061835.1580">def is_final(node):
    """return true if the given class/function node correspond to final
    definition
    """
    return FINAL.match(node.name)


</t>
<t tx="ekr.20220312061835.1581">def is_interface(node):
    # bw compat
    return node.type == "interface"


</t>
<t tx="ekr.20220312061835.1582">def is_exception(node):
    # bw compat
    return node.type == "exception"


</t>
<t tx="ekr.20220312061835.1583"># Helpers #####################################################################

_CONSTRUCTOR = 1
_SPECIAL = 2
_PROTECTED = 4
_PRIVATE = 8
MODES = {
    "ALL": 0,
    "PUB_ONLY": _SPECIAL + _PROTECTED + _PRIVATE,
    "SPECIAL": _SPECIAL,
    "OTHER": _PROTECTED + _PRIVATE,
}
VIS_MOD = {
    "special": _SPECIAL,
    "protected": _PROTECTED,
    "private": _PRIVATE,
    "public": 0,
}


</t>
<t tx="ekr.20220312061835.1584">class FilterMixIn:
    """filter nodes according to a mode and nodes' visibility"""

    @others
</t>
<t tx="ekr.20220312061835.1585">def __init__(self, mode):
    "init filter modes"
    __mode = 0
    for nummod in mode.split("+"):
        try:
            __mode += MODES[nummod]
        except KeyError as ex:
            print(f"Unknown filter mode {ex}", file=sys.stderr)
    self.__mode = __mode

</t>
<t tx="ekr.20220312061835.1586">def show_attr(self, node):
    """return true if the node should be treated"""
    visibility = get_visibility(getattr(node, "name", node))
    return not self.__mode &amp; VIS_MOD[visibility]


</t>
<t tx="ekr.20220312061835.1587">class ASTWalker:
    """a walker visiting a tree in preorder, calling on the handler:

    * visit_&lt;class name&gt; on entering a node, where class name is the class of
    the node in lower case

    * leave_&lt;class name&gt; on leaving a node, where class name is the class of
    the node in lower case
    """

    @others
</t>
<t tx="ekr.20220312061835.1588">def __init__(self, handler):
    self.handler = handler
    self._cache = {}

</t>
<t tx="ekr.20220312061835.1589">def walk(self, node, _done=None):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    if _done is None:
        _done = set()
    if node in _done:
        raise AssertionError((id(node), node, node.parent))
    _done.add(node)
    self.visit(node)
    for child_node in node.get_children():
        assert child_node is not node
        self.walk(child_node, _done)
    self.leave(node)
    assert node.parent is not node

</t>
<t tx="ekr.20220312061835.159">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.1590">def get_callbacks(self, node):
    """get callbacks from handler for the visited node"""
    klass = node.__class__
    methods = self._cache.get(klass)
    if methods is None:
        handler = self.handler
        kid = klass.__name__.lower()
        e_method = getattr(
            handler, f"visit_{kid}", getattr(handler, "visit_default", None)
        )
        l_method = getattr(
            handler, f"leave_{kid}", getattr(handler, "leave_default", None)
        )
        self._cache[klass] = (e_method, l_method)
    else:
        e_method, l_method = methods
    return e_method, l_method

</t>
<t tx="ekr.20220312061835.1591">def visit(self, node):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    method = self.get_callbacks(node)[0]
    if method is not None:
        method(node)

</t>
<t tx="ekr.20220312061835.1592">def leave(self, node):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    method = self.get_callbacks(node)[1]
    if method is not None:
        method(node)


</t>
<t tx="ekr.20220312061835.1593">class LocalsVisitor(ASTWalker):
    """visit a project by traversing the locals dictionary"""

    @others
</t>
<t tx="ekr.20220312061835.1594">def __init__(self):
    ASTWalker.__init__(self, self)
    self._visited = set()

</t>
<t tx="ekr.20220312061835.1595">def visit(self, node):
    """launch the visit starting from the given node"""
    if node in self._visited:
        return None

    self._visited.add(node)
    methods = self.get_callbacks(node)
    if methods[0] is not None:
        methods[0](node)
    if hasattr(node, "locals"):  # skip Instance and other proxy
        for local_node in node.values():
            self.visit(local_node)
    if methods[1] is not None:
        return methods[1](node)
    return None


</t>
<t tx="ekr.20220312061835.1596">def get_annotation_label(ann: Union[nodes.Name, nodes.Subscript]) -&gt; str:
    label = ""
    if isinstance(ann, nodes.Subscript):
        label = ann.as_string()
    elif isinstance(ann, nodes.Name):
        label = ann.name
    return label


</t>
<t tx="ekr.20220312061835.1597">def get_annotation(
    node: Union[nodes.AssignAttr, nodes.AssignName]
) -&gt; Optional[Union[nodes.Name, nodes.Subscript]]:
    """return the annotation for `node`"""
    ann = None
    if isinstance(node.parent, nodes.AnnAssign):
        ann = node.parent.annotation
    elif isinstance(node, nodes.AssignAttr):
        init_method = node.parent.parent
        try:
            annotations = dict(zip(init_method.locals, init_method.args.annotations))
            ann = annotations.get(node.parent.value.name)
        except AttributeError:
            pass
    else:
        return ann

    try:
        default, *_ = node.infer()
    except astroid.InferenceError:
        default = ""

    label = get_annotation_label(ann)
    if ann:
        label = (
            fr"Optional[{label}]"
            if getattr(default, "value", "value") is None
            and not label.startswith("Optional")
            else label
        )
    if label:
        ann.name = label
    return ann


</t>
<t tx="ekr.20220312061835.1598">def infer_node(node: Union[nodes.AssignAttr, nodes.AssignName]) -&gt; set:
    """Return a set containing the node annotation if it exists
    otherwise return a set of the inferred types using the NodeNG.infer method"""

    ann = get_annotation(node)
    try:
        if ann:
            if isinstance(ann, nodes.Subscript):
                return {ann}
            return set(ann.infer())
        return set(node.infer())
    except astroid.InferenceError:
        return {ann} if ann else set()


</t>
<t tx="ekr.20220312061835.1599">def check_graphviz_availability():
    """Check if the ``dot`` command is available on the machine.
    This is needed if image output is desired and ``dot`` is used to convert
    from *.dot or *.gv into the final output format."""
    if shutil.which("dot") is None:
        print(
            "The requested output format is currently not available.\n"
            "Please install 'Graphviz' to have other output formats "
            "than 'dot' or 'vcg'."
        )
        sys.exit(32)
</t>
<t tx="ekr.20220312061835.16">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2020 Benjamin Graham &lt;benwilliamgraham@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Andrew Howe &lt;howeaj@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Graph manipulation utilities.

(dot generation adapted from pypy/translator/tool/make_dot.py)
"""
import codecs
import os
import shutil
import subprocess
import sys
import tempfile


@others
</t>
<t tx="ekr.20220312061835.160">@utils.check_messages("disallowed-name", "invalid-name", "non-ascii-name")
def visit_global(self, node: nodes.Global) -&gt; None:
    for name in node.names:
        self._check_name("const", name, node)

</t>
<t tx="ekr.20220312061835.1600">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2020-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Functions to generate files readable with Georg Sander's vcg
(Visualization of Compiler Graphs).
You can download vcg at https://rw4.cs.uni-sb.de/~sander/html/gshome.html
Note that vcg exists as a debian package.
See vcg's documentation for explanation about the different values that
maybe used for the functions parameters.
"""
from typing import Any, Dict, Mapping, Optional

from pylint.pyreverse.printer import EdgeType, Layout, NodeProperties, NodeType, Printer

ATTRS_VAL = {
    "algos": (
        "dfs",
        "tree",
        "minbackward",
        "left_to_right",
        "right_to_left",
        "top_to_bottom",
        "bottom_to_top",
        "maxdepth",
        "maxdepthslow",
        "mindepth",
        "mindepthslow",
        "mindegree",
        "minindegree",
        "minoutdegree",
        "maxdegree",
        "maxindegree",
        "maxoutdegree",
    ),
    "booleans": ("yes", "no"),
    "colors": (
        "black",
        "white",
        "blue",
        "red",
        "green",
        "yellow",
        "magenta",
        "lightgrey",
        "cyan",
        "darkgrey",
        "darkblue",
        "darkred",
        "darkgreen",
        "darkyellow",
        "darkmagenta",
        "darkcyan",
        "gold",
        "lightblue",
        "lightred",
        "lightgreen",
        "lightyellow",
        "lightmagenta",
        "lightcyan",
        "lilac",
        "turquoise",
        "aquamarine",
        "khaki",
        "purple",
        "yellowgreen",
        "pink",
        "orange",
        "orchid",
    ),
    "shapes": ("box", "ellipse", "rhomb", "triangle"),
    "textmodes": ("center", "left_justify", "right_justify"),
    "arrowstyles": ("solid", "line", "none"),
    "linestyles": ("continuous", "dashed", "dotted", "invisible"),
}

# meaning of possible values:
#   O    -&gt; string
#   1    -&gt; int
#   list -&gt; value in list
GRAPH_ATTRS = {
    "title": 0,
    "label": 0,
    "color": ATTRS_VAL["colors"],
    "textcolor": ATTRS_VAL["colors"],
    "bordercolor": ATTRS_VAL["colors"],
    "width": 1,
    "height": 1,
    "borderwidth": 1,
    "textmode": ATTRS_VAL["textmodes"],
    "shape": ATTRS_VAL["shapes"],
    "shrink": 1,
    "stretch": 1,
    "orientation": ATTRS_VAL["algos"],
    "vertical_order": 1,
    "horizontal_order": 1,
    "xspace": 1,
    "yspace": 1,
    "layoutalgorithm": ATTRS_VAL["algos"],
    "late_edge_labels": ATTRS_VAL["booleans"],
    "display_edge_labels": ATTRS_VAL["booleans"],
    "dirty_edge_labels": ATTRS_VAL["booleans"],
    "finetuning": ATTRS_VAL["booleans"],
    "manhattan_edges": ATTRS_VAL["booleans"],
    "smanhattan_edges": ATTRS_VAL["booleans"],
    "port_sharing": ATTRS_VAL["booleans"],
    "edges": ATTRS_VAL["booleans"],
    "nodes": ATTRS_VAL["booleans"],
    "splines": ATTRS_VAL["booleans"],
}
NODE_ATTRS = {
    "title": 0,
    "label": 0,
    "color": ATTRS_VAL["colors"],
    "textcolor": ATTRS_VAL["colors"],
    "bordercolor": ATTRS_VAL["colors"],
    "width": 1,
    "height": 1,
    "borderwidth": 1,
    "textmode": ATTRS_VAL["textmodes"],
    "shape": ATTRS_VAL["shapes"],
    "shrink": 1,
    "stretch": 1,
    "vertical_order": 1,
    "horizontal_order": 1,
}
EDGE_ATTRS = {
    "sourcename": 0,
    "targetname": 0,
    "label": 0,
    "linestyle": ATTRS_VAL["linestyles"],
    "class": 1,
    "thickness": 0,
    "color": ATTRS_VAL["colors"],
    "textcolor": ATTRS_VAL["colors"],
    "arrowcolor": ATTRS_VAL["colors"],
    "backarrowcolor": ATTRS_VAL["colors"],
    "arrowsize": 1,
    "backarrowsize": 1,
    "arrowstyle": ATTRS_VAL["arrowstyles"],
    "backarrowstyle": ATTRS_VAL["arrowstyles"],
    "textmode": ATTRS_VAL["textmodes"],
    "priority": 1,
    "anchor": 1,
    "horizontal_order": 1,
}
SHAPES: Dict[NodeType, str] = {
    NodeType.PACKAGE: "box",
    NodeType.CLASS: "box",
    NodeType.INTERFACE: "ellipse",
}
ARROWS: Dict[EdgeType, Dict] = {
    EdgeType.USES: dict(arrowstyle="solid", backarrowstyle="none", backarrowsize=0),
    EdgeType.INHERITS: dict(
        arrowstyle="solid", backarrowstyle="none", backarrowsize=10
    ),
    EdgeType.IMPLEMENTS: dict(
        arrowstyle="solid",
        backarrowstyle="none",
        linestyle="dotted",
        backarrowsize=10,
    ),
    EdgeType.ASSOCIATION: dict(
        arrowstyle="solid", backarrowstyle="none", textcolor="green"
    ),
}
ORIENTATION: Dict[Layout, str] = {
    Layout.LEFT_TO_RIGHT: "left_to_right",
    Layout.RIGHT_TO_LEFT: "right_to_left",
    Layout.TOP_TO_BOTTOM: "top_to_bottom",
    Layout.BOTTOM_TO_TOP: "bottom_to_top",
}

# Misc utilities ###############################################################


@others
</t>
<t tx="ekr.20220312061835.1601">class VCGPrinter(Printer):
    @others
</t>
<t tx="ekr.20220312061835.1602">def _open_graph(self) -&gt; None:
    """Emit the header lines"""
    self.emit("graph:{\n")
    self._inc_indent()
    self._write_attributes(
        GRAPH_ATTRS,
        title=self.title,
        layoutalgorithm="dfs",
        late_edge_labels="yes",
        port_sharing="no",
        manhattan_edges="yes",
    )
    if self.layout:
        self._write_attributes(GRAPH_ATTRS, orientation=ORIENTATION[self.layout])

</t>
<t tx="ekr.20220312061835.1603">def _close_graph(self) -&gt; None:
    """Emit the lines needed to properly close the graph."""
    self._dec_indent()
    self.emit("}")

</t>
<t tx="ekr.20220312061835.1604">def emit_node(
    self,
    name: str,
    type_: NodeType,
    properties: Optional[NodeProperties] = None,
) -&gt; None:
    """Create a new node. Nodes can be classes, packages, participants etc."""
    if properties is None:
        properties = NodeProperties(label=name)
    elif properties.label is None:
        properties.label = name
    self.emit(f'node: {{title:"{name}"', force_newline=False)
    self._write_attributes(
        NODE_ATTRS,
        label=self._build_label_for_node(properties),
        shape=SHAPES[type_],
    )
    self.emit("}")

</t>
<t tx="ekr.20220312061835.1605">@staticmethod
def _build_label_for_node(properties: NodeProperties) -&gt; str:
    fontcolor = "\f09" if properties.fontcolor == "red" else ""
    label = fr"\fb{fontcolor}{properties.label}\fn"
    if properties.attrs is None and properties.methods is None:
        # return a compact form which only displays the classname in a box
        return label
    attrs = properties.attrs or []
    methods = properties.methods or []
    method_names = [func.name for func in methods]
    # box width for UML like diagram
    maxlen = max(len(name) for name in [properties.label] + method_names + attrs)
    line = "_" * (maxlen + 2)
    label = fr"{label}\n\f{line}"
    for attr in attrs:
        label = fr"{label}\n\f08{attr}"
    if attrs:
        label = fr"{label}\n\f{line}"
    for func in method_names:
        label = fr"{label}\n\f10{func}()"
    return label

</t>
<t tx="ekr.20220312061835.1606">def emit_edge(
    self,
    from_node: str,
    to_node: str,
    type_: EdgeType,
    label: Optional[str] = None,
) -&gt; None:
    """Create an edge from one node to another to display relationships."""
    self.emit(
        f'edge: {{sourcename:"{from_node}" targetname:"{to_node}"',
        force_newline=False,
    )
    attributes = ARROWS[type_]
    if label:
        attributes["label"] = label
    self._write_attributes(
        EDGE_ATTRS,
        **attributes,
    )
    self.emit("}")

</t>
<t tx="ekr.20220312061835.1607">def _write_attributes(self, attributes_dict: Mapping[str, Any], **args) -&gt; None:
    """write graph, node or edge attributes"""
    for key, value in args.items():
        try:
            _type = attributes_dict[key]
        except KeyError as e:
            raise Exception(
                f"no such attribute {key}\npossible attributes are {attributes_dict.keys()}"
            ) from e

        if not _type:
            self.emit(f'{key}:"{value}"\n')
        elif _type == 1:
            self.emit(f"{key}:{int(value)}\n")
        elif value in _type:
            self.emit(f"{key}:{value}\n")
        else:
            raise Exception(
                f"value {value} isn't correct for attribute {key} correct values are {type}"
            )
</t>
<t tx="ekr.20220312061835.1608">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Copyright (c) 2008-2010, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Mike Frysinger &lt;vapier@gentoo.org&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Kylian &lt;development@goudcode.nl&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Mark Byrne &lt;31762852+mbyrnepr2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Utilities for creating VCG and Dot diagrams"""

import itertools
import os

from astroid import modutils, nodes

from pylint.pyreverse.diagrams import (
    ClassDiagram,
    ClassEntity,
    DiagramEntity,
    PackageDiagram,
    PackageEntity,
)
from pylint.pyreverse.printer import EdgeType, NodeProperties, NodeType
from pylint.pyreverse.printer_factory import get_printer_for_filetype
from pylint.pyreverse.utils import is_exception


@others
</t>
<t tx="ekr.20220312061835.1609">class DiagramWriter:
    """base class for writing project diagrams"""

    @others
</t>
<t tx="ekr.20220312061835.161">@utils.check_messages(
    "disallowed-name", "invalid-name", "assign-to-new-keyword", "non-ascii-name"
)
</t>
<t tx="ekr.20220312061835.1610">def __init__(self, config):
    self.config = config
    self.printer_class = get_printer_for_filetype(self.config.output_format)
    self.printer = None  # defined in set_printer
    self.file_name = ""  # defined in set_printer
    self.depth = self.config.max_color_depth
    self.available_colors = itertools.cycle(
        [
            "aliceblue",
            "antiquewhite",
            "aquamarine",
            "burlywood",
            "cadetblue",
            "chartreuse",
            "chocolate",
            "coral",
            "cornflowerblue",
            "cyan",
            "darkgoldenrod",
            "darkseagreen",
            "dodgerblue",
            "forestgreen",
            "gold",
            "hotpink",
            "mediumspringgreen",
        ]
    )
    self.used_colors = {}

</t>
<t tx="ekr.20220312061835.1611">def write(self, diadefs):
    """write files for &lt;project&gt; according to &lt;diadefs&gt;"""
    for diagram in diadefs:
        basename = diagram.title.strip().replace(" ", "_")
        file_name = f"{basename}.{self.config.output_format}"
        if os.path.exists(self.config.output_directory):
            file_name = os.path.join(self.config.output_directory, file_name)
        self.set_printer(file_name, basename)
        if diagram.TYPE == "class":
            self.write_classes(diagram)
        else:
            self.write_packages(diagram)
        self.save()

</t>
<t tx="ekr.20220312061835.1612">def write_packages(self, diagram: PackageDiagram) -&gt; None:
    """write a package diagram"""
    # sorted to get predictable (hence testable) results
    for module in sorted(diagram.modules(), key=lambda x: x.title):
        module.fig_id = module.node.qname()
        self.printer.emit_node(
            module.fig_id,
            type_=NodeType.PACKAGE,
            properties=self.get_package_properties(module),
        )
    # package dependencies
    for rel in diagram.get_relationships("depends"):
        self.printer.emit_edge(
            rel.from_object.fig_id,
            rel.to_object.fig_id,
            type_=EdgeType.USES,
        )

</t>
<t tx="ekr.20220312061835.1613">def write_classes(self, diagram: ClassDiagram) -&gt; None:
    """write a class diagram"""
    # sorted to get predictable (hence testable) results
    for obj in sorted(diagram.objects, key=lambda x: x.title):
        obj.fig_id = obj.node.qname()
        type_ = NodeType.INTERFACE if obj.shape == "interface" else NodeType.CLASS
        self.printer.emit_node(
            obj.fig_id, type_=type_, properties=self.get_class_properties(obj)
        )
    # inheritance links
    for rel in diagram.get_relationships("specialization"):
        self.printer.emit_edge(
            rel.from_object.fig_id,
            rel.to_object.fig_id,
            type_=EdgeType.INHERITS,
        )
    # implementation links
    for rel in diagram.get_relationships("implements"):
        self.printer.emit_edge(
            rel.from_object.fig_id,
            rel.to_object.fig_id,
            type_=EdgeType.IMPLEMENTS,
        )
    # generate associations
    for rel in diagram.get_relationships("association"):
        self.printer.emit_edge(
            rel.from_object.fig_id,
            rel.to_object.fig_id,
            label=rel.name,
            type_=EdgeType.ASSOCIATION,
        )

</t>
<t tx="ekr.20220312061835.1614">def set_printer(self, file_name: str, basename: str) -&gt; None:
    """set printer"""
    self.printer = self.printer_class(basename)
    self.file_name = file_name

</t>
<t tx="ekr.20220312061835.1615">def get_package_properties(self, obj: PackageEntity) -&gt; NodeProperties:
    """get label and shape for packages."""
    return NodeProperties(
        label=obj.title,
        color=self.get_shape_color(obj) if self.config.colorized else "black",
    )

</t>
<t tx="ekr.20220312061835.1616">def get_class_properties(self, obj: ClassEntity) -&gt; NodeProperties:
    """get label and shape for classes."""
    properties = NodeProperties(
        label=obj.title,
        attrs=obj.attrs if not self.config.only_classnames else None,
        methods=obj.methods if not self.config.only_classnames else None,
        fontcolor="red" if is_exception(obj.node) else "black",
        color=self.get_shape_color(obj) if self.config.colorized else "black",
    )
    return properties

</t>
<t tx="ekr.20220312061835.1617">def get_shape_color(self, obj: DiagramEntity) -&gt; str:
    """get shape color"""
    qualified_name = obj.node.qname()
    if modutils.is_standard_module(qualified_name.split(".", maxsplit=1)[0]):
        return "grey"
    if isinstance(obj.node, nodes.ClassDef):
        package = qualified_name.rsplit(".", maxsplit=2)[0]
    elif obj.node.package:
        package = qualified_name
    else:
        package = qualified_name.rsplit(".", maxsplit=1)[0]
    base_name = ".".join(package.split(".", self.depth)[: self.depth])
    if base_name not in self.used_colors:
        self.used_colors[base_name] = next(self.available_colors)
    return self.used_colors[base_name]

</t>
<t tx="ekr.20220312061835.1618">def save(self) -&gt; None:
    """write to disk"""
    self.printer.generate(self.file_name)
</t>
<t tx="ekr.20220312061835.1619">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/pyreverse/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""
pyreverse.extensions
"""

__revision__ = "$Id $"
</t>
<t tx="ekr.20220312061835.162">def visit_assignname(self, node: nodes.AssignName) -&gt; None:
    """check module level assigned names"""
    self._check_assign_to_new_keyword_violation(node.name, node)
    frame = node.frame()
    assign_type = node.assign_type()
    if isinstance(assign_type, nodes.Comprehension):
        self._check_name("inlinevar", node.name, node)
    elif isinstance(frame, nodes.Module):
        if isinstance(assign_type, nodes.Assign):
            if isinstance(utils.safe_infer(assign_type.value), nodes.ClassDef):
                self._check_name("class", node.name, node)
            # Don't emit if the name redefines an import
            # in an ImportError except handler.
            elif not _redefines_import(node) and isinstance(
                utils.safe_infer(assign_type.value), nodes.Const
            ):
                self._check_name("const", node.name, node)
        elif isinstance(
            assign_type, nodes.AnnAssign
        ) and utils.is_assign_name_annotated_with(node, "Final"):
            self._check_name("const", node.name, node)
    elif isinstance(frame, nodes.FunctionDef):
        # global introduced variable aren't in the function locals
        if node.name in frame and node.name not in frame.argnames():
            if not _redefines_import(node):
                self._check_name("variable", node.name, node)
    elif isinstance(frame, nodes.ClassDef):
        if not list(frame.local_attr_ancestors(node.name)):
            for ancestor in frame.ancestors():
                if (
                    ancestor.name == "Enum"
                    and ancestor.root().name == "enum"
                    or utils.is_assign_name_annotated_with(node, "Final")
                ):
                    self._check_name("class_const", node.name, node)
                    break
            else:
                self._check_name("class_attribute", node.name, node)

</t>
<t tx="ekr.20220312061835.1620"></t>
<t tx="ekr.20220312061835.1621">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import os
import sys
from typing import TYPE_CHECKING, List, Optional

from pylint.message import Message
from pylint.reporters.ureports.nodes import Text
from pylint.typing import CheckerStats

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section


@others
</t>
<t tx="ekr.20220312061835.1622">class BaseReporter:
    """base class for reporters

    symbols: show short symbolic names for messages.
    """

    extension = ""

    @others
</t>
<t tx="ekr.20220312061835.1623">def __init__(self, output=None):
    self.linter = None
    self.section = 0
    self.out = None
    self.out_encoding = None
    self.set_output(output)
    self.messages: List[Message] = []
    # Build the path prefix to strip to get relative paths
    self.path_strip_prefix = os.getcwd() + os.sep

</t>
<t tx="ekr.20220312061835.1624">def handle_message(self, msg: Message) -&gt; None:
    """Handle a new message triggered on the current file."""
    self.messages.append(msg)

</t>
<t tx="ekr.20220312061835.1625">def set_output(self, output=None):
    """set output stream"""
    self.out = output or sys.stdout

</t>
<t tx="ekr.20220312061835.1626">def writeln(self, string=""):
    """write a line in the output buffer"""
    print(string, file=self.out)

</t>
<t tx="ekr.20220312061835.1627">def display_reports(self, layout: "Section") -&gt; None:
    """display results encapsulated in the layout tree"""
    self.section = 0
    if layout.report_id:
        if isinstance(layout.children[0].children[0], Text):
            layout.children[0].children[0].data += f" ({layout.report_id})"
        else:
            raise ValueError(f"Incorrect child for {layout.children[0].children}")
    self._display(layout)

</t>
<t tx="ekr.20220312061835.1628">def _display(self, layout: "Section") -&gt; None:
    """display the layout"""
    raise NotImplementedError()

</t>
<t tx="ekr.20220312061835.1629">def display_messages(self, layout: Optional["Section"]) -&gt; None:
    """Hook for displaying the messages of the reporter

    This will be called whenever the underlying messages
    needs to be displayed. For some reporters, it probably
    doesn't make sense to display messages as soon as they
    are available, so some mechanism of storing them could be used.
    This method can be implemented to display them after they've
    been aggregated.
    """

</t>
<t tx="ekr.20220312061835.163">def _recursive_check_names(self, args, node):
    """check names in a possibly recursive list &lt;arg&gt;"""
    for arg in args:
        if isinstance(arg, nodes.AssignName):
            self._check_name("argument", arg.name, node)
        else:
            self._recursive_check_names(arg.elts, node)

</t>
<t tx="ekr.20220312061835.1630"># Event callbacks

</t>
<t tx="ekr.20220312061835.1631">def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
    """Hook called when a module starts to be analysed."""

</t>
<t tx="ekr.20220312061835.1632">def on_close(
    self,
    stats: CheckerStats,
    previous_stats: CheckerStats,
) -&gt; None:
    """Hook called when a module finished analyzing."""
</t>
<t tx="ekr.20220312061835.1633">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import TYPE_CHECKING

from pylint.reporters.base_reporter import BaseReporter

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section


@others
</t>
<t tx="ekr.20220312061835.1634">class CollectingReporter(BaseReporter):
    """collects messages"""

    name = "collector"

    @others
</t>
<t tx="ekr.20220312061835.1635">def __init__(self) -&gt; None:
    BaseReporter.__init__(self)
    self.messages = []

</t>
<t tx="ekr.20220312061835.1636">def reset(self) -&gt; None:
    self.messages = []

</t>
<t tx="ekr.20220312061835.1637">def _display(self, layout: "Section") -&gt; None:
    pass
</t>
<t tx="ekr.20220312061835.1638">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Copyright (c) 2014 Vlad Temian &lt;vladtemian@gmail.com&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2017 guillaume2 &lt;guillaume.peillex@gmail.col&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Clment Pit-Claudel &lt;cpitclaudel@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""JSON reporter"""
import json
from typing import TYPE_CHECKING, Optional

from pylint.interfaces import IReporter
from pylint.reporters.base_reporter import BaseReporter

if TYPE_CHECKING:
    from pylint.lint.pylinter import PyLinter
    from pylint.reporters.ureports.nodes import Section


@others
</t>
<t tx="ekr.20220312061835.1639">class JSONReporter(BaseReporter):
    """Report messages and layouts in JSON."""

    __implements__ = IReporter
    name = "json"
    extension = "json"

    @others
</t>
<t tx="ekr.20220312061835.164">def _find_name_group(self, node_type):
    return self._name_group.get(node_type, node_type)

</t>
<t tx="ekr.20220312061835.1640">def display_messages(self, layout: Optional["Section"]) -&gt; None:
    """Launch layouts display"""
    json_dumpable = [
        {
            "type": msg.category,
            "module": msg.module,
            "obj": msg.obj,
            "line": msg.line,
            "column": msg.column,
            "path": msg.path,
            "symbol": msg.symbol,
            "message": msg.msg or "",
            "message-id": msg.msg_id,
        }
        for msg in self.messages
    ]
    print(json.dumps(json_dumpable, indent=4), file=self.out)

</t>
<t tx="ekr.20220312061835.1641">def display_reports(self, layout: "Section") -&gt; None:
    """Don't do anything in this reporter."""

</t>
<t tx="ekr.20220312061835.1642">def _display(self, layout: "Section") -&gt; None:
    """Do nothing."""


</t>
<t tx="ekr.20220312061835.1643">def register(linter: "PyLinter") -&gt; None:
    """Register the reporter classes with the linter."""
    linter.register_reporter(JSONReporter)
</t>
<t tx="ekr.20220312061835.1644">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import os
from typing import IO, TYPE_CHECKING, Any, AnyStr, Callable, List, Optional

from pylint.interfaces import IReporter
from pylint.message import Message
from pylint.reporters.base_reporter import BaseReporter
from pylint.typing import CheckerStats

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section

AnyFile = IO[AnyStr]
PyLinter = Any


@others
</t>
<t tx="ekr.20220312061835.1645">class MultiReporter:
    """Reports messages and layouts in plain text"""

    __implements__ = IReporter
    name = "_internal_multi_reporter"
    # Note: do not register this reporter with linter.register_reporter as it is
    #       not intended to be used directly like a regular reporter, but is
    #       instead used to implement the
    #       `--output-format=json:somefile.json,colorized`
    #       multiple output formats feature

    extension = ""

    @others
</t>
<t tx="ekr.20220312061835.1646">def __init__(
    self,
    sub_reporters: List[BaseReporter],
    close_output_files: Callable[[], None],
    output: Optional[AnyFile] = None,
):
    self._sub_reporters = sub_reporters
    self.close_output_files = close_output_files

    self._path_strip_prefix = os.getcwd() + os.sep
    self._linter: Optional[PyLinter] = None

    self.set_output(output)

</t>
<t tx="ekr.20220312061835.1647">def __del__(self) -&gt; None:
    self.close_output_files()

</t>
<t tx="ekr.20220312061835.1648">@property
def path_strip_prefix(self) -&gt; str:
    return self._path_strip_prefix

</t>
<t tx="ekr.20220312061835.1649">@property
def linter(self) -&gt; Optional[PyLinter]:
    return self._linter

</t>
<t tx="ekr.20220312061835.165">def _raise_name_warning(
    self,
    prevalent_group: Optional[str],
    node: nodes.NodeNG,
    node_type: str,
    name: str,
    confidence,
    warning: str = "invalid-name",
) -&gt; None:
    type_label = HUMAN_READABLE_TYPES[node_type]
    hint = self._name_hints[node_type]
    if prevalent_group:
        # This happens in the multi naming match case. The expected
        # prevalent group needs to be spelled out to make the message
        # correct.
        hint = f"the `{prevalent_group}` group in the {hint}"
    if self.config.include_naming_hint:
        hint += f" ({self._name_regexps[node_type].pattern!r} pattern)"
    args = (
        (type_label.capitalize(), name, hint)
        if warning == "invalid-name"
        else (type_label.capitalize(), name)
    )

    self.add_message(warning, node=node, args=args, confidence=confidence)
    self.stats["badname_" + node_type] += 1  # type: ignore

</t>
<t tx="ekr.20220312061835.1650">@linter.setter
def linter(self, value: PyLinter) -&gt; None:
    self._linter = value
    for rep in self._sub_reporters:
        rep.linter = value

</t>
<t tx="ekr.20220312061835.1651">def handle_message(self, msg: Message) -&gt; None:
    """Handle a new message triggered on the current file."""
    for rep in self._sub_reporters:
        rep.handle_message(msg)

</t>
<t tx="ekr.20220312061835.1652"># pylint: disable=no-self-use
def set_output(self, output: Optional[AnyFile] = None) -&gt; None:
    """set output stream"""
    # MultiReporter doesn't have it's own output. This method is only
    # provided for API parity with BaseReporter and should not be called
    # with non-None values for 'output'.
    if output is not None:
        raise NotImplementedError("MultiReporter does not support direct output.")

</t>
<t tx="ekr.20220312061835.1653">def writeln(self, string: str = "") -&gt; None:
    """write a line in the output buffer"""
    for rep in self._sub_reporters:
        rep.writeln(string)

</t>
<t tx="ekr.20220312061835.1654">def display_reports(self, layout: "Section") -&gt; None:
    """display results encapsulated in the layout tree"""
    for rep in self._sub_reporters:
        rep.display_reports(layout)

</t>
<t tx="ekr.20220312061835.1655">def display_messages(self, layout: Optional["Section"]) -&gt; None:
    """hook for displaying the messages of the reporter"""
    for rep in self._sub_reporters:
        rep.display_messages(layout)

</t>
<t tx="ekr.20220312061835.1656">def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
    """hook called when a module starts to be analysed"""
    for rep in self._sub_reporters:
        rep.on_set_current_module(module, filepath)

</t>
<t tx="ekr.20220312061835.1657">def on_close(
    self,
    stats: CheckerStats,
    previous_stats: CheckerStats,
) -&gt; None:
    """hook called when a module finished analyzing"""
    for rep in self._sub_reporters:
        rep.on_close(stats, previous_stats)
</t>
<t tx="ekr.20220312061835.1658">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
from typing import TYPE_CHECKING, Any, Callable, DefaultDict, Dict, List, Tuple

from pylint.exceptions import EmptyReportError
from pylint.interfaces import IChecker
from pylint.reporters.ureports.nodes import Section
from pylint.typing import CheckerStats

if TYPE_CHECKING:
    from pylint.lint.pylinter import PyLinter


@others
</t>
<t tx="ekr.20220312061835.1659">class ReportsHandlerMixIn:
    """a mix-in class containing all the reports and stats manipulation
    related methods for the main lint class
    """

    @others
</t>
<t tx="ekr.20220312061835.166">def _name_allowed_by_regex(self, name: str) -&gt; bool:
    return name in self.config.good_names or any(
        pattern.match(name) for pattern in self._good_names_rgxs_compiled
    )

</t>
<t tx="ekr.20220312061835.1660">def __init__(self) -&gt; None:
    self._reports: DefaultDict[
        IChecker, List[Tuple[str, str, Callable]]
    ] = collections.defaultdict(list)
    self._reports_state: Dict[str, bool] = {}

</t>
<t tx="ekr.20220312061835.1661">def report_order(self):
    """Return a list of reports, sorted in the order
    in which they must be called.
    """
    return list(self._reports)

</t>
<t tx="ekr.20220312061835.1662">def register_report(
    self, reportid: str, r_title: str, r_cb: Callable, checker: IChecker
) -&gt; None:
    """register a report

    reportid is the unique identifier for the report
    r_title the report's title
    r_cb the method to call to make the report
    checker is the checker defining the report
    """
    reportid = reportid.upper()
    self._reports[checker].append((reportid, r_title, r_cb))

</t>
<t tx="ekr.20220312061835.1663">def enable_report(self, reportid: str) -&gt; None:
    """disable the report of the given id"""
    reportid = reportid.upper()
    self._reports_state[reportid] = True

</t>
<t tx="ekr.20220312061835.1664">def disable_report(self, reportid: str) -&gt; None:
    """disable the report of the given id"""
    reportid = reportid.upper()
    self._reports_state[reportid] = False

</t>
<t tx="ekr.20220312061835.1665">def report_is_enabled(self, reportid: str) -&gt; bool:
    """return true if the report associated to the given identifier is
    enabled
    """
    return self._reports_state.get(reportid, True)

</t>
<t tx="ekr.20220312061835.1666">def make_reports(  # type: ignore # ReportsHandlerMixIn is always mixed with PyLinter
    self: "PyLinter",
    stats: CheckerStats,
    old_stats: CheckerStats,
) -&gt; Section:
    """render registered reports"""
    sect = Section("Report", f"{self.stats['statement']} statements analysed.")
    for checker in self.report_order():
        for reportid, r_title, r_cb in self._reports[checker]:
            if not self.report_is_enabled(reportid):
                continue
            report_sect = Section(r_title)
            try:
                r_cb(report_sect, stats, old_stats)
            except EmptyReportError:
                continue
            report_sect.report_id = reportid
            sect.append(report_sect)
    return sect

</t>
<t tx="ekr.20220312061835.1667">def add_stats(  # type: ignore # ReportsHandlerMixIn is always mixed with PyLinter
    self: "PyLinter", **kwargs: Any
) -&gt; CheckerStats:
    """add some stats entries to the statistic dictionary
    raise an AssertionError if there is a key conflict
    """
    for key, value in kwargs.items():
        if key[-1] == "_":
            key = key[:-1]
        assert key not in self.stats
        self.stats[key] = value
    return self.stats
</t>
<t tx="ekr.20220312061835.1668">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Copyright (c) 2006-2007, 2010-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 y2kbugger &lt;y2kbugger@users.noreply.github.com&gt;
# Copyright (c) 2018-2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Jace Browning &lt;jacebrowning@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Plain text reporters:

:text: the default one grouping messages by module
:colorized: an ANSI colorized text reporter
"""
import os
import sys
import warnings
from typing import TYPE_CHECKING, Optional

from pylint import utils
from pylint.interfaces import IReporter
from pylint.message import Message
from pylint.reporters import BaseReporter
from pylint.reporters.ureports.text_writer import TextWriter

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section

TITLE_UNDERLINES = ["", "=", "-", "."]

ANSI_PREFIX = "\033["
ANSI_END = "m"
ANSI_RESET = "\033[0m"
ANSI_STYLES = {
    "reset": "0",
    "bold": "1",
    "italic": "3",
    "underline": "4",
    "blink": "5",
    "inverse": "7",
    "strike": "9",
}
ANSI_COLORS = {
    "reset": "0",
    "black": "30",
    "red": "31",
    "green": "32",
    "yellow": "33",
    "blue": "34",
    "magenta": "35",
    "cyan": "36",
    "white": "37",
}


@others
</t>
<t tx="ekr.20220312061835.1669">def _get_ansi_code(color=None, style=None):
    """return ansi escape code corresponding to color and style

    :type color: str or None
    :param color:
      the color name (see `ANSI_COLORS` for available values)
      or the color number when 256 colors are available

    :type style: str or None
    :param style:
      style string (see `ANSI_COLORS` for available values). To get
      several style effects at the same time, use a coma as separator.

    :raise KeyError: if an unexistent color or style identifier is given

    :rtype: str
    :return: the built escape code
    """
    ansi_code = []
    if style:
        style_attrs = utils._splitstrip(style)
        for effect in style_attrs:
            ansi_code.append(ANSI_STYLES[effect])
    if color:
        if color.isdigit():
            ansi_code.extend(["38", "5"])
            ansi_code.append(color)
        else:
            ansi_code.append(ANSI_COLORS[color])
    if ansi_code:
        return ANSI_PREFIX + ";".join(ansi_code) + ANSI_END
    return ""


</t>
<t tx="ekr.20220312061835.167">def _name_disallowed_by_regex(self, name: str) -&gt; bool:
    return name in self.config.bad_names or any(
        pattern.match(name) for pattern in self._bad_names_rgxs_compiled
    )

</t>
<t tx="ekr.20220312061835.1670">def colorize_ansi(msg, color=None, style=None):
    """colorize message by wrapping it with ansi escape codes

    :type msg: str or unicode
    :param msg: the message string to colorize

    :type color: str or None
    :param color:
      the color identifier (see `ANSI_COLORS` for available values)

    :type style: str or None
    :param style:
      style string (see `ANSI_COLORS` for available values). To get
      several style effects at the same time, use a coma as separator.

    :raise KeyError: if an unexistent color or style identifier is given

    :rtype: str or unicode
    :return: the ansi escaped string
    """
    # If both color and style are not defined, then leave the text as is
    if color is None and style is None:
        return msg
    escape_code = _get_ansi_code(color, style)
    # If invalid (or unknown) color, don't wrap msg with ansi codes
    if escape_code:
        return f"{escape_code}{msg}{ANSI_RESET}"
    return msg


</t>
<t tx="ekr.20220312061835.1671">class TextReporter(BaseReporter):
    """Reports messages and layouts in plain text"""

    __implements__ = IReporter
    name = "text"
    extension = "txt"
    line_format = "{path}:{line}:{column}: {msg_id}: {msg} ({symbol})"

    @others
</t>
<t tx="ekr.20220312061835.1672">def __init__(self, output=None):
    BaseReporter.__init__(self, output)
    self._modules = set()
    self._template = self.line_format

</t>
<t tx="ekr.20220312061835.1673">def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
    self._template = str(self.linter.config.msg_template or self._template)

</t>
<t tx="ekr.20220312061835.1674">def write_message(self, msg):
    """Convenience method to write a formatted message with class default template"""
    self.writeln(msg.format(self._template))

</t>
<t tx="ekr.20220312061835.1675">def handle_message(self, msg: Message) -&gt; None:
    """manage message of different type and in the context of path"""
    if msg.module not in self._modules:
        if msg.module:
            self.writeln(f"************* Module {msg.module}")
            self._modules.add(msg.module)
        else:
            self.writeln("************* ")
    self.write_message(msg)

</t>
<t tx="ekr.20220312061835.1676">def _display(self, layout: "Section") -&gt; None:
    """launch layouts display"""
    print(file=self.out)
    TextWriter().format(layout, self.out)


</t>
<t tx="ekr.20220312061835.1677">class ParseableTextReporter(TextReporter):
    """a reporter very similar to TextReporter, but display messages in a form
    recognized by most text editors :

    &lt;filename&gt;:&lt;linenum&gt;:&lt;msg&gt;
    """

    name = "parseable"
    line_format = "{path}:{line}: [{msg_id}({symbol}), {obj}] {msg}"

    @others
</t>
<t tx="ekr.20220312061835.1678">def __init__(self, output=None):
    warnings.warn(
        f"{self.name} output format is deprecated. This is equivalent to --msg-template={self.line_format}",
        DeprecationWarning,
    )
    TextReporter.__init__(self, output)


</t>
<t tx="ekr.20220312061835.1679">class VSTextReporter(ParseableTextReporter):
    """Visual studio text reporter"""

    name = "msvs"
    line_format = "{path}({line}): [{msg_id}({symbol}){obj}] {msg}"


</t>
<t tx="ekr.20220312061835.168">def _check_name(self, node_type, name, node, confidence=interfaces.HIGH):
    """check for a name using the type's regexp"""
    non_ascii_match = self._non_ascii_rgx_compiled.match(name)
    if non_ascii_match is not None:
        self._raise_name_warning(
            None, node, node_type, name, confidence, warning="non-ascii-name"
        )

    def _should_exempt_from_invalid_name(node):
        if node_type == "variable":
            inferred = utils.safe_infer(node)
            if isinstance(inferred, nodes.ClassDef):
                return True
        return False

    if self._name_allowed_by_regex(name=name):
        return
    if self._name_disallowed_by_regex(name=name):
        self.stats["badname_" + node_type] += 1
        self.add_message("disallowed-name", node=node, args=name)
        return
    regexp = self._name_regexps[node_type]
    match = regexp.match(name)

    if _is_multi_naming_match(match, node_type, confidence):
        name_group = self._find_name_group(node_type)
        bad_name_group = self._bad_names.setdefault(name_group, {})
        warnings = bad_name_group.setdefault(match.lastgroup, [])
        warnings.append((node, node_type, name, confidence))

    if match is None and not _should_exempt_from_invalid_name(node):
        self._raise_name_warning(None, node, node_type, name, confidence)

</t>
<t tx="ekr.20220312061835.1680">class ColorizedTextReporter(TextReporter):
    """Simple TextReporter that colorizes text output"""

    name = "colorized"
    COLOR_MAPPING = {
        "I": ("green", None),
        "C": (None, "bold"),
        "R": ("magenta", "bold, italic"),
        "W": ("magenta", None),
        "E": ("red", "bold"),
        "F": ("red", "bold, underline"),
        "S": ("yellow", "inverse"),  # S stands for module Separator
    }

    @others
</t>
<t tx="ekr.20220312061835.1681">def __init__(self, output=None, color_mapping=None):
    TextReporter.__init__(self, output)
    self.color_mapping = color_mapping or dict(ColorizedTextReporter.COLOR_MAPPING)
    ansi_terms = ["xterm-16color", "xterm-256color"]
    if os.environ.get("TERM") not in ansi_terms:
        if sys.platform == "win32":
            # pylint: disable=import-error,import-outside-toplevel
            import colorama

            self.out = colorama.AnsiToWin32(self.out)

</t>
<t tx="ekr.20220312061835.1682">def _get_decoration(self, msg_id):
    """Returns the tuple color, style associated with msg_id as defined
    in self.color_mapping
    """
    try:
        return self.color_mapping[msg_id[0]]
    except KeyError:
        return None, None

</t>
<t tx="ekr.20220312061835.1683">def handle_message(self, msg: Message) -&gt; None:
    """manage message of different types, and colorize output
    using ansi escape codes
    """
    if msg.module not in self._modules:
        color, style = self._get_decoration("S")
        if msg.module:
            modsep = colorize_ansi(
                f"************* Module {msg.module}", color, style
            )
        else:
            modsep = colorize_ansi(f"************* {msg.module}", color, style)
        self.writeln(modsep)
        self._modules.add(msg.module)
    color, style = self._get_decoration(msg.C)

    msg = msg._replace(
        **{
            attr: colorize_ansi(getattr(msg, attr), color, style)
            for attr in ("msg", "symbol", "category", "C")
        }
    )
    self.write_message(msg)


</t>
<t tx="ekr.20220312061835.1684">def register(linter):
    """Register the reporter classes with the linter."""
    linter.register_reporter(TextReporter)
    linter.register_reporter(ParseableTextReporter)
    linter.register_reporter(VSTextReporter)
    linter.register_reporter(ColorizedTextReporter)
</t>
<t tx="ekr.20220312061835.1685">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/
@language python
@tabwidth -4
# Copyright (c) 2006, 2010, 2012-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Ricardo Gemignani &lt;ricardo.gemignani@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2017 Kri Tristan Helgason &lt;kthelgason@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 ruro &lt;ruro.ruro@ya.ru&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""utilities methods and classes for reporters"""
from typing import TYPE_CHECKING

from pylint import utils
from pylint.reporters.base_reporter import BaseReporter
from pylint.reporters.collecting_reporter import CollectingReporter
from pylint.reporters.json_reporter import JSONReporter
from pylint.reporters.multi_reporter import MultiReporter
from pylint.reporters.reports_handler_mix_in import ReportsHandlerMixIn

if TYPE_CHECKING:
    from pylint.lint.pylinter import PyLinter


@others
__all__ = [
    "BaseReporter",
    "ReportsHandlerMixIn",
    "JSONReporter",
    "CollectingReporter",
    "MultiReporter",
]
</t>
<t tx="ekr.20220312061835.1686">def initialize(linter: "PyLinter") -&gt; None:
    """initialize linter with reporters in this package"""
    utils.register_plugins(linter, __path__[0])  # type: ignore # Fixed in https://github.com/python/mypy/pull/9454


</t>
<t tx="ekr.20220312061835.1687"></t>
<t tx="ekr.20220312061835.1688">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/ureports/
@language python
@tabwidth -4
# Copyright (c) 2015-2016, 2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Universal report objects and some formatting drivers.

A way to create simple reports using python objects, primarily designed to be
formatted as text and html.
"""
import os
import sys
from io import StringIO
from typing import TYPE_CHECKING, Iterator, List, TextIO, Union

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import (
        EvaluationSection,
        Paragraph,
        Section,
        Table,
    )


@others
</t>
<t tx="ekr.20220312061835.1689">class BaseWriter:
    """base class for ureport writers"""

    @others
</t>
<t tx="ekr.20220312061835.169">def _check_assign_to_new_keyword_violation(self, name, node):
    keyword_first_version = self._name_became_keyword_in_version(
        name, self.KEYWORD_ONSET
    )
    if keyword_first_version is not None:
        self.add_message(
            "assign-to-new-keyword",
            node=node,
            args=(name, keyword_first_version),
            confidence=interfaces.HIGH,
        )

</t>
<t tx="ekr.20220312061835.1690">def format(self, layout, stream: TextIO = sys.stdout, encoding=None) -&gt; None:
    """format and write the given layout into the stream object

    unicode policy: unicode strings may be found in the layout;
    try to call stream.write with it, but give it back encoded using
    the given encoding if it fails
    """
    if not encoding:
        encoding = getattr(stream, "encoding", "UTF-8")
    self.encoding = encoding or "UTF-8"
    self.out = stream
    self.begin_format()
    layout.accept(self)
    self.end_format()

</t>
<t tx="ekr.20220312061835.1691">def format_children(
    self, layout: Union["EvaluationSection", "Paragraph", "Section"]
) -&gt; None:
    """recurse on the layout children and call their accept method
    (see the Visitor pattern)
    """
    for child in getattr(layout, "children", ()):
        child.accept(self)

</t>
<t tx="ekr.20220312061835.1692">def writeln(self, string: str = "") -&gt; None:
    """write a line in the output buffer"""
    self.write(string + os.linesep)

</t>
<t tx="ekr.20220312061835.1693">def write(self, string: str) -&gt; None:
    """write a string in the output buffer"""
    self.out.write(string)

</t>
<t tx="ekr.20220312061835.1694">def begin_format(self) -&gt; None:
    """begin to format a layout"""
    self.section = 0

</t>
<t tx="ekr.20220312061835.1695">def end_format(self) -&gt; None:
    """finished to format a layout"""

</t>
<t tx="ekr.20220312061835.1696">def get_table_content(self, table: "Table") -&gt; List[List[str]]:
    """trick to get table content without actually writing it

    return an aligned list of lists containing table cells values as string
    """
    result: List[List[str]] = [[]]
    cols = table.cols
    for cell in self.compute_content(table):
        if cols == 0:
            result.append([])
            cols = table.cols
        cols -= 1
        result[-1].append(cell)
    # fill missing cells
    result[-1] += [""] * (cols - len(result[-1]))
    return result

</t>
<t tx="ekr.20220312061835.1697">def compute_content(self, layout) -&gt; Iterator[str]:
    """trick to compute the formatting of children layout before actually
    writing it

    return an iterator on strings (one for each child element)
    """
    # Patch the underlying output stream with a fresh-generated stream,
    # which is used to store a temporary representation of a child
    # node.
    out = self.out
    try:
        for child in layout.children:
            stream = StringIO()
            self.out = stream
            child.accept(self)
            yield stream.getvalue()
    finally:
        self.out = out
</t>
<t tx="ekr.20220312061835.1698">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/ureports/
@language python
@tabwidth -4
# Copyright (c) 2015-2016, 2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Micro reports objects.

A micro report is a tree of layout and content objects.
"""
from typing import Any, Iterable, Iterator, List, Optional, Union

from pylint.reporters.ureports.text_writer import TextWriter


@others
</t>
<t tx="ekr.20220312061835.1699">class VNode:
    @others
</t>
<t tx="ekr.20220312061835.17">def target_info_from_filename(filename):
    """Transforms /some/path/foo.png into ('/some/path', 'foo.png', 'png')."""
    basename = os.path.basename(filename)
    storedir = os.path.dirname(os.path.abspath(filename))
    target = os.path.splitext(filename)[-1][1:]
    return storedir, basename, target


</t>
<t tx="ekr.20220312061835.170">@staticmethod
def _name_became_keyword_in_version(name, rules):
    for version, keywords in rules.items():
        if name in keywords and sys.version_info &lt; version:
            return ".".join(str(v) for v in version)
    return None


</t>
<t tx="ekr.20220312061835.1700">def __init__(self) -&gt; None:
    self.parent: Optional["BaseLayout"] = None
    self.children: List["VNode"] = []
    self.visitor_name: str = self.__class__.__name__.lower()

</t>
<t tx="ekr.20220312061835.1701">def __iter__(self) -&gt; Iterator["VNode"]:
    return iter(self.children)

</t>
<t tx="ekr.20220312061835.1702">def accept(self, visitor: TextWriter, *args: Any, **kwargs: Any) -&gt; None:
    func = getattr(visitor, f"visit_{self.visitor_name}")
    return func(self, *args, **kwargs)

</t>
<t tx="ekr.20220312061835.1703">def leave(self, visitor, *args, **kwargs):
    func = getattr(visitor, f"leave_{self.visitor_name}")
    return func(self, *args, **kwargs)


</t>
<t tx="ekr.20220312061835.1704">class BaseLayout(VNode):
    """base container node

    attributes
    * children : components in this table (i.e. the table's cells)
    """

    @others
</t>
<t tx="ekr.20220312061835.1705">def __init__(self, children: Iterable[Union["Text", str]] = ()) -&gt; None:
    super().__init__()
    for child in children:
        if isinstance(child, VNode):
            self.append(child)
        else:
            self.add_text(child)

</t>
<t tx="ekr.20220312061835.1706">def append(self, child: VNode) -&gt; None:
    """add a node to children"""
    assert child not in self.parents()
    self.children.append(child)
    child.parent = self

</t>
<t tx="ekr.20220312061835.1707">def insert(self, index: int, child: VNode) -&gt; None:
    """insert a child node"""
    self.children.insert(index, child)
    child.parent = self

</t>
<t tx="ekr.20220312061835.1708">def parents(self) -&gt; List["BaseLayout"]:
    """return the ancestor nodes"""
    assert self.parent is not self
    if self.parent is None:
        return []
    return [self.parent] + self.parent.parents()

</t>
<t tx="ekr.20220312061835.1709">def add_text(self, text: str) -&gt; None:
    """shortcut to add text data"""
    self.children.append(Text(text))


</t>
<t tx="ekr.20220312061835.171">class DocStringChecker(_BasicChecker):
    msgs = {
        "C0112": (
            "Empty %s docstring",
            "empty-docstring",
            "Used when a module, function, class or method has an empty "
            "docstring (it would be too easy ;).",
            {"old_names": [("W0132", "old-empty-docstring")]},
        ),
        "C0114": (
            "Missing module docstring",
            "missing-module-docstring",
            "Used when a module has no docstring."
            "Empty modules do not require a docstring.",
            {"old_names": [("C0111", "missing-docstring")]},
        ),
        "C0115": (
            "Missing class docstring",
            "missing-class-docstring",
            "Used when a class has no docstring."
            "Even an empty class must have a docstring.",
            {"old_names": [("C0111", "missing-docstring")]},
        ),
        "C0116": (
            "Missing function or method docstring",
            "missing-function-docstring",
            "Used when a function or method has no docstring."
            "Some special methods like __init__ do not require a "
            "docstring.",
            {"old_names": [("C0111", "missing-docstring")]},
        ),
    }
    options = (
        (
            "no-docstring-rgx",
            {
                "default": NO_REQUIRED_DOC_RGX,
                "type": "regexp",
                "metavar": "&lt;regexp&gt;",
                "help": "Regular expression which should only match "
                "function or class names that do not require a "
                "docstring.",
            },
        ),
        (
            "docstring-min-length",
            {
                "default": -1,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": (
                    "Minimum line length for functions/classes that"
                    " require docstrings, shorter ones are exempt."
                ),
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.1710"># non container nodes #########################################################


</t>
<t tx="ekr.20220312061835.1711">class Text(VNode):
    """a text portion

    attributes :
    * data : the text value as an encoded or unicode string
    """

    @others
</t>
<t tx="ekr.20220312061835.1712">def __init__(self, data: str, escaped: bool = True) -&gt; None:
    super().__init__()
    self.escaped = escaped
    self.data = data


</t>
<t tx="ekr.20220312061835.1713">class VerbatimText(Text):
    """a verbatim text, display the raw data

    attributes :
    * data : the text value as an encoded or unicode string
    """


</t>
<t tx="ekr.20220312061835.1714"># container nodes #############################################################


</t>
<t tx="ekr.20220312061835.1715">class Section(BaseLayout):
    """a section

    attributes :
    * BaseLayout attributes

    a title may also be given to the constructor, it'll be added
    as a first element
    a description may also be given to the constructor, it'll be added
    as a first paragraph
    """

    @others
</t>
<t tx="ekr.20220312061835.1716">def __init__(
    self,
    title: Optional[str] = None,
    description: Optional[str] = None,
    children: Iterable[Union["Text", str]] = (),
) -&gt; None:
    super().__init__(children=children)
    if description:
        self.insert(0, Paragraph([Text(description)]))
    if title:
        self.insert(0, Title(children=(title,)))
    self.report_id: str = ""  # Used in ReportHandlerMixin.make_reports


</t>
<t tx="ekr.20220312061835.1717">class EvaluationSection(Section):
    @others
</t>
<t tx="ekr.20220312061835.1718">def __init__(
    self, message: str, children: Iterable[Union["Text", str]] = ()
) -&gt; None:
    super().__init__(children=children)
    title = Paragraph()
    title.append(Text("-" * len(message)))
    self.append(title)
    message_body = Paragraph()
    message_body.append(Text(message))
    self.append(message_body)


</t>
<t tx="ekr.20220312061835.1719">class Title(BaseLayout):
    """a title

    attributes :
    * BaseLayout attributes

    A title must not contains a section nor a paragraph!
    """


</t>
<t tx="ekr.20220312061835.172">def open(self):
    self.stats = self.linter.add_stats(
        undocumented_module=0,
        undocumented_function=0,
        undocumented_method=0,
        undocumented_class=0,
    )

</t>
<t tx="ekr.20220312061835.1720">class Paragraph(BaseLayout):
    """a simple text paragraph

    attributes :
    * BaseLayout attributes

    A paragraph must not contains a section !
    """


</t>
<t tx="ekr.20220312061835.1721">class Table(BaseLayout):
    """some tabular data

    attributes :
    * BaseLayout attributes
    * cols : the number of columns of the table (REQUIRED)
    * rheaders : the first row's elements are table's header
    * cheaders : the first col's elements are table's header
    * title : the table's optional title
    """

    @others
</t>
<t tx="ekr.20220312061835.1722">def __init__(
    self,
    cols: int,
    title: Optional[str] = None,
    rheaders: int = 0,
    cheaders: int = 0,
    children: Iterable[Union["Text", str]] = (),
) -&gt; None:
    super().__init__(children=children)
    assert isinstance(cols, int)
    self.cols = cols
    self.title = title
    self.rheaders = rheaders
    self.cheaders = cheaders
</t>
<t tx="ekr.20220312061835.1723">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/ureports/
@language python
@tabwidth -4
# Copyright (c) 2015-2016, 2018-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 bot &lt;bot@noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Text formatting drivers for ureports"""

from typing import TYPE_CHECKING, List

from pylint.reporters.ureports.base_writer import BaseWriter

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import (
        EvaluationSection,
        Paragraph,
        Section,
        Table,
        Text,
        Title,
        VerbatimText,
    )

TITLE_UNDERLINES = ["", "=", "-", "`", ".", "~", "^"]
BULLETS = ["*", "-"]


@others
</t>
<t tx="ekr.20220312061835.1724">class TextWriter(BaseWriter):
    """format layouts as text
    (ReStructured inspiration but not totally handled yet)
    """

    @others
</t>
<t tx="ekr.20220312061835.1725">def __init__(self):
    super().__init__()
    self.list_level = 0

</t>
<t tx="ekr.20220312061835.1726">def visit_section(self, layout: "Section") -&gt; None:
    """display a section as text"""
    self.section += 1
    self.writeln()
    self.format_children(layout)
    self.section -= 1
    self.writeln()

</t>
<t tx="ekr.20220312061835.1727">def visit_evaluationsection(self, layout: "EvaluationSection") -&gt; None:
    """Display an evaluation section as a text."""
    self.section += 1
    self.format_children(layout)
    self.section -= 1
    self.writeln()

</t>
<t tx="ekr.20220312061835.1728">def visit_title(self, layout: "Title") -&gt; None:
    title = "".join(list(self.compute_content(layout)))
    self.writeln(title)
    try:
        self.writeln(TITLE_UNDERLINES[self.section] * len(title))
    except IndexError:
        print("FIXME TITLE TOO DEEP. TURNING TITLE INTO TEXT")

</t>
<t tx="ekr.20220312061835.1729">def visit_paragraph(self, layout: "Paragraph") -&gt; None:
    """enter a paragraph"""
    self.format_children(layout)
    self.writeln()

</t>
<t tx="ekr.20220312061835.173">@utils.check_messages("missing-docstring", "empty-docstring")
def visit_module(self, node: nodes.Module) -&gt; None:
    self._check_docstring("module", node)

</t>
<t tx="ekr.20220312061835.1730">def visit_table(self, layout: "Table") -&gt; None:
    """display a table as text"""
    table_content = self.get_table_content(layout)
    # get columns width
    cols_width = [0] * len(table_content[0])
    for row in table_content:
        for index, col in enumerate(row):
            cols_width[index] = max(cols_width[index], len(col))
    self.default_table(layout, table_content, cols_width)
    self.writeln()

</t>
<t tx="ekr.20220312061835.1731">def default_table(
    self, layout: "Table", table_content: List[List[str]], cols_width: List[int]
) -&gt; None:
    """format a table"""
    cols_width = [size + 1 for size in cols_width]
    format_strings = " ".join(["%%-%ss"] * len(cols_width))
    format_strings %= tuple(cols_width)

    table_linesep = "\n+" + "+".join("-" * w for w in cols_width) + "+\n"
    headsep = "\n+" + "+".join("=" * w for w in cols_width) + "+\n"

    self.write(table_linesep)
    split_strings = format_strings.split(" ")
    for index, line in enumerate(table_content):
        self.write("|")
        for line_index, at_index in enumerate(line):
            self.write(split_strings[line_index] % at_index)
            self.write("|")
        if index == 0 and layout.rheaders:
            self.write(headsep)
        else:
            self.write(table_linesep)

</t>
<t tx="ekr.20220312061835.1732">def visit_verbatimtext(self, layout: "VerbatimText") -&gt; None:
    """display a verbatim layout as text (so difficult ;)"""
    self.writeln("::\n")
    for line in layout.data.splitlines():
        self.writeln("    " + line)
    self.writeln()

</t>
<t tx="ekr.20220312061835.1733">def visit_text(self, layout: "Text") -&gt; None:
    """add some text"""
    self.write(f"{layout.data}")
</t>
<t tx="ekr.20220312061835.1734">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/reporters/ureports/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

__all__ = ("BaseWriter",)

from pylint.reporters.ureports.base_writer import BaseWriter
</t>
<t tx="ekr.20220312061835.1735"></t>
<t tx="ekr.20220312061835.1736">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import contextlib
from typing import Dict, Optional, Type

from pylint.testutils.global_test_linter import linter
from pylint.testutils.unittest_linter import UnittestLinter
from pylint.utils import ASTWalker


@others
</t>
<t tx="ekr.20220312061835.1737">class CheckerTestCase:
    """A base testcase class for unit testing individual checker classes."""

    CHECKER_CLASS: Optional[Type] = None
    CONFIG: Dict = {}

    @others
</t>
<t tx="ekr.20220312061835.1738">def setup_method(self):
    self.linter = UnittestLinter()
    self.checker = self.CHECKER_CLASS(self.linter)  # pylint: disable=not-callable
    for key, value in self.CONFIG.items():
        setattr(self.checker.config, key, value)
    self.checker.open()

</t>
<t tx="ekr.20220312061835.1739">@contextlib.contextmanager
def assertNoMessages(self):
    """Assert that no messages are added by the given method."""
    with self.assertAddsMessages():
        yield

</t>
<t tx="ekr.20220312061835.174">@utils.check_messages("missing-docstring", "empty-docstring")
def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    if self.config.no_docstring_rgx.match(node.name) is None:
        self._check_docstring("class", node)

</t>
<t tx="ekr.20220312061835.1740">@contextlib.contextmanager
def assertAddsMessages(self, *messages):
    """Assert that exactly the given method adds the given messages.

    The list of messages must exactly match *all* the messages added by the
    method. Additionally, we check to see whether the args in each message can
    actually be substituted into the message string.
    """
    yield
    got = self.linter.release_messages()
    no_msg = "No message."
    expected = "\n".join(repr(m) for m in messages) or no_msg
    got_str = "\n".join(repr(m) for m in got) or no_msg
    msg = (
        "Expected messages did not match actual.\n"
        f"\nExpected:\n{expected}\n\nGot:\n{got_str}\n"
    )
    assert got == list(messages), msg

</t>
<t tx="ekr.20220312061835.1741">def walk(self, node):
    """recursive walk on the given node"""
    walker = ASTWalker(linter)
    walker.add_checker(self.checker)
    walker.walk(node)
</t>
<t tx="ekr.20220312061835.1742">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import operator
import re
import sys
from os.path import abspath, dirname
from pathlib import Path

SYS_VERS_STR = (
    "%d%d%d" % sys.version_info[:3]  # pylint: disable=consider-using-f-string
)
TITLE_UNDERLINES = ["", "=", "-", "."]
PREFIX = abspath(dirname(__file__))
UPDATE_OPTION = "--update-functional-output"
UPDATE_FILE = Path("pylint-functional-test-update")
# Common sub-expressions.
_MESSAGE = {"msg": r"[a-z][a-z\-]+"}
# Matches a #,
#  - followed by a comparison operator and a Python version (optional),
#  - followed by a line number with a +/- (optional),
#  - followed by a list of bracketed message symbols.
# Used to extract expected messages from testdata files.
_EXPECTED_RE = re.compile(
    r"\s*#\s*(?:(?P&lt;line&gt;[+-]?[0-9]+):)?"  # pylint: disable=consider-using-f-string
    r"(?:(?P&lt;op&gt;[&gt;&lt;=]+) *(?P&lt;version&gt;[0-9.]+):)?"
    r"\s*\[(?P&lt;msgs&gt;%(msg)s(?:,\s*%(msg)s)*)]" % _MESSAGE
)

_OPERATORS = {"&gt;": operator.gt, "&lt;": operator.lt, "&gt;=": operator.ge, "&lt;=": operator.le}
</t>
<t tx="ekr.20220312061835.1743">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import functools

from pylint.testutils.checker_test_case import CheckerTestCase


@others
</t>
<t tx="ekr.20220312061835.1744">def set_config(**kwargs):
    """Decorator for setting config values on a checker.

    Passing the args and kwargs back to the test function itself
    allows this decorator to be used on parametrized test cases.
    """

    @others
    return _wrapper
</t>
<t tx="ekr.20220312061835.1745">def _wrapper(fun):
    @functools.wraps(fun)
    def _forward(self, *args, **test_function_kwargs):
        for key, value in kwargs.items():
            setattr(self.checker.config, key, value)
        if isinstance(self, CheckerTestCase):
            # reopen checker in case, it may be interested in configuration change
            self.checker.open()
        fun(self, *args, **test_function_kwargs)

    return _forward

</t>
<t tx="ekr.20220312061835.1746">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import configparser
from os.path import basename, exists, join


@others
</t>
<t tx="ekr.20220312061835.1747">def parse_python_version(ver_str):
    return tuple(int(digit) for digit in ver_str.split("."))


</t>
<t tx="ekr.20220312061835.1748">class NoFileError(Exception):
    pass


</t>
<t tx="ekr.20220312061835.1749">class FunctionalTestFile:
    """A single functional test case file with options."""

    _CONVERTERS = {
        "min_pyver": parse_python_version,
        "max_pyver": parse_python_version,
        "requires": lambda s: s.split(","),
    }

    @others
</t>
<t tx="ekr.20220312061835.175">@utils.check_messages("missing-docstring", "empty-docstring")
def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    if self.config.no_docstring_rgx.match(node.name) is None:
        ftype = "method" if node.is_method() else "function"
        if (
            is_property_setter(node)
            or is_property_deleter(node)
            or is_overload_stub(node)
        ):
            return

        if isinstance(node.parent.frame(), nodes.ClassDef):
            overridden = False
            confidence = (
                interfaces.INFERENCE
                if utils.has_known_bases(node.parent.frame())
                else interfaces.INFERENCE_FAILURE
            )
            # check if node is from a method overridden by its ancestor
            for ancestor in node.parent.frame().ancestors():
                if node.name in ancestor and isinstance(
                    ancestor[node.name], nodes.FunctionDef
                ):
                    overridden = True
                    break
            self._check_docstring(
                ftype, node, report_missing=not overridden, confidence=confidence
            )
        elif isinstance(node.parent.frame(), nodes.Module):
            self._check_docstring(ftype, node)
        else:
            return

</t>
<t tx="ekr.20220312061835.1750">def __init__(self, directory, filename):
    self._directory = directory
    self.base = filename.replace(".py", "")
    self.options = {
        "min_pyver": (2, 5),
        "max_pyver": (4, 0),
        "requires": [],
        "except_implementations": [],
        "exclude_platforms": [],
    }
    self._parse_options()

</t>
<t tx="ekr.20220312061835.1751">def __repr__(self):
    return f"FunctionalTest:{self.base}"

</t>
<t tx="ekr.20220312061835.1752">def _parse_options(self):
    cp = configparser.ConfigParser()
    cp.add_section("testoptions")
    try:
        cp.read(self.option_file)
    except NoFileError:
        pass

    for name, value in cp.items("testoptions"):
        conv = self._CONVERTERS.get(name, lambda v: v)
        self.options[name] = conv(value)

</t>
<t tx="ekr.20220312061835.1753">@property
def option_file(self):
    return self._file_type(".rc")

</t>
<t tx="ekr.20220312061835.1754">@property
def module(self):
    package = basename(self._directory)
    return ".".join([package, self.base])

</t>
<t tx="ekr.20220312061835.1755">@property
def expected_output(self):
    return self._file_type(".txt", check_exists=False)

</t>
<t tx="ekr.20220312061835.1756">@property
def source(self):
    return self._file_type(".py")

</t>
<t tx="ekr.20220312061835.1757">def _file_type(self, ext, check_exists=True):
    name = join(self._directory, self.base + ext)
    if not check_exists or exists(name):
        return name
    raise NoFileError(f"Cannot find '{name}'.")
</t>
<t tx="ekr.20220312061835.1758">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from glob import glob
from os.path import basename, join, splitext

from pylint.testutils.constants import SYS_VERS_STR


@others
</t>
<t tx="ekr.20220312061835.1759">def _get_tests_info(input_dir, msg_dir, prefix, suffix):
    """get python input examples and output messages

    We use following conventions for input files and messages:
    for different inputs:
        test for python  &gt;= x.y    -&gt;  input   =  &lt;name&gt;_pyxy.py
        test for python  &lt;  x.y    -&gt;  input   =  &lt;name&gt;_py_xy.py
    for one input and different messages:
        message for python &gt;=  x.y -&gt;  message =  &lt;name&gt;_pyxy.txt
        lower versions             -&gt;  message with highest num
    """
    result = []
    for fname in glob(join(input_dir, prefix + "*" + suffix)):
        infile = basename(fname)
        fbase = splitext(infile)[0]
        # filter input files :
        pyrestr = fbase.rsplit("_py", 1)[-1]  # like _26 or 26
        if pyrestr.isdigit():  # '24', '25'...
            if pyrestr.isdigit() and int(SYS_VERS_STR) &lt; int(pyrestr):
                continue
        if pyrestr.startswith("_") and pyrestr[1:].isdigit():
            # skip test for higher python versions
            if pyrestr[1:].isdigit() and int(SYS_VERS_STR) &gt;= int(pyrestr[1:]):
                continue
        messages = glob(join(msg_dir, fbase + "*.txt"))
        # the last one will be without ext, i.e. for all or upper versions:
        if messages:
            for outfile in sorted(messages, reverse=True):
                py_rest = outfile.rsplit("_py", 1)[-1][:-4]
                if py_rest.isdigit() and int(SYS_VERS_STR) &gt;= int(py_rest):
                    break
        else:
            # This will provide an error message indicating the missing filename.
            outfile = join(msg_dir, fbase + ".txt")
        result.append((infile, outfile))
    return result
</t>
<t tx="ekr.20220312061835.176">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.1760">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


from pylint import checkers
from pylint.lint import PyLinter
from pylint.testutils.reporter_for_tests import GenericTestReporter


@others
# Can't be renamed to a constant (easily), it breaks countless tests
linter = create_test_linter()
</t>
<t tx="ekr.20220312061835.1761">def create_test_linter():
    test_reporter = GenericTestReporter()
    linter_ = PyLinter()
    linter_.set_reporter(test_reporter)
    linter_.config.persistent = 0
    checkers.initialize(linter_)
    return linter_


</t>
<t tx="ekr.20220312061835.1762">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import csv
import operator
import platform
import sys
from collections import Counter
from io import StringIO, TextIOWrapper
from typing import TYPE_CHECKING, Dict, List, Optional, Tuple

import pytest
from _pytest.config import Config

from pylint import checkers
from pylint.lint import PyLinter
from pylint.testutils.constants import _EXPECTED_RE, _OPERATORS, UPDATE_OPTION
from pylint.testutils.functional_test_file import (
    FunctionalTestFile,
    NoFileError,
    parse_python_version,
)
from pylint.testutils.output_line import OutputLine
from pylint.testutils.reporter_for_tests import FunctionalTestReporter
from pylint.utils import utils

if TYPE_CHECKING:
    from typing import Counter as CounterType  # typing.Counter added in Python 3.6.1


@others
</t>
<t tx="ekr.20220312061835.1763">class LintModuleTest:
    maxDiff = None

    @others
</t>
<t tx="ekr.20220312061835.1764">def __init__(self, test_file: FunctionalTestFile, config: Optional[Config] = None):
    _test_reporter = FunctionalTestReporter()
    self._linter = PyLinter()
    self._linter.set_reporter(_test_reporter)
    self._linter.config.persistent = 0
    checkers.initialize(self._linter)
    self._linter.disable("suppressed-message")
    self._linter.disable("locally-disabled")
    self._linter.disable("useless-suppression")
    try:
        self._linter.read_config_file(test_file.option_file)
        if self._linter.cfgfile_parser.has_option("MASTER", "load-plugins"):
            plugins = utils._splitstrip(
                self._linter.cfgfile_parser.get("MASTER", "load-plugins")
            )
            self._linter.load_plugin_modules(plugins)
        self._linter.load_config_file()
    except NoFileError:
        pass
    self._test_file = test_file
    self._config = config

</t>
<t tx="ekr.20220312061835.1765">def setUp(self):
    if self._should_be_skipped_due_to_version():
        pytest.skip(
            f"Test cannot run with Python {sys.version.split(' ', maxsplit=1)[0]}."
        )
    missing = []
    for requirement in self._test_file.options["requires"]:
        try:
            __import__(requirement)
        except ImportError:
            missing.append(requirement)
    if missing:
        pytest.skip(f"Requires {','.join(missing)} to be present.")
    except_implementations = self._test_file.options["except_implementations"]
    if except_implementations:
        implementations = [i.strip() for i in except_implementations.split(",")]
        if platform.python_implementation() in implementations:
            msg = "Test cannot run with Python implementation %r"
            pytest.skip(msg % platform.python_implementation())
    excluded_platforms = self._test_file.options["exclude_platforms"]
    if excluded_platforms:
        platforms = [p.strip() for p in excluded_platforms.split(",")]
        if sys.platform.lower() in platforms:
            pytest.skip(f"Test cannot run on platform {sys.platform!r}")

</t>
<t tx="ekr.20220312061835.1766">def runTest(self):
    self._runTest()

</t>
<t tx="ekr.20220312061835.1767">def _should_be_skipped_due_to_version(self):
    return (
        sys.version_info &lt; self._test_file.options["min_pyver"]
        or sys.version_info &gt; self._test_file.options["max_pyver"]
    )

</t>
<t tx="ekr.20220312061835.1768">def __str__(self):
    return f"{self._test_file.base} ({self.__class__.__module__}.{self.__class__.__name__})"

</t>
<t tx="ekr.20220312061835.1769">@staticmethod
def get_expected_messages(stream: TextIOWrapper) -&gt; "CounterType[Tuple[int, str]]":
    """Parses a file and get expected messages.

    :param stream: File-like input stream.
    :type stream: enumerable
    :returns: A dict mapping line,msg-symbol tuples to the count on this line.
    :rtype: dict
    """
    messages: "CounterType[Tuple[int, str]]" = Counter()
    for i, line in enumerate(stream):
        match = _EXPECTED_RE.search(line)
        if match is None:
            continue
        line = match.group("line")
        if line is None:
            lineno = i + 1
        elif line.startswith("+") or line.startswith("-"):
            lineno = i + 1 + int(line)
        else:
            lineno = int(line)

        version = match.group("version")
        op = match.group("op")
        if version:
            required = parse_python_version(version)
            if not _OPERATORS[op](sys.version_info, required):
                continue

        for msg_id in match.group("msgs").split(","):
            messages[lineno, msg_id.strip()] += 1
    return messages

</t>
<t tx="ekr.20220312061835.177">def _check_docstring(
    self, node_type, node, report_missing=True, confidence=interfaces.HIGH
):
    """check the node has a non empty docstring"""
    docstring = node.doc
    if docstring is None:
        docstring = _infer_dunder_doc_attribute(node)

    if docstring is None:
        if not report_missing:
            return
        lines = utils.get_node_last_lineno(node) - node.lineno

        if node_type == "module" and not lines:
            # If the module has no body, there's no reason
            # to require a docstring.
            return
        max_lines = self.config.docstring_min_length

        if node_type != "module" and max_lines &gt; -1 and lines &lt; max_lines:
            return
        self.stats["undocumented_" + node_type] += 1
        if (
            node.body
            and isinstance(node.body[0], nodes.Expr)
            and isinstance(node.body[0].value, nodes.Call)
        ):
            # Most likely a string with a format call. Let's see.
            func = utils.safe_infer(node.body[0].value.func)
            if isinstance(func, astroid.BoundMethod) and isinstance(
                func.bound, astroid.Instance
            ):
                # Strings.
                if func.bound.name in ("str", "unicode", "bytes"):
                    return
        if node_type == "module":
            message = "missing-module-docstring"
        elif node_type == "class":
            message = "missing-class-docstring"
        else:
            message = "missing-function-docstring"
        self.add_message(message, node=node, confidence=confidence)
    elif not docstring.strip():
        self.stats["undocumented_" + node_type] += 1
        self.add_message(
            "empty-docstring", node=node, args=(node_type,), confidence=confidence
        )


</t>
<t tx="ekr.20220312061835.1770">@staticmethod
def multiset_difference(
    expected_entries: "CounterType", actual_entries: "CounterType"
) -&gt; Tuple["CounterType", Dict[str, int]]:
    """Takes two multisets and compares them.

    A multiset is a dict with the cardinality of the key as the value."""
    missing = expected_entries.copy()
    missing.subtract(actual_entries)
    unexpected = {}
    for key, value in list(missing.items()):
        if value &lt;= 0:
            missing.pop(key)
            if value &lt; 0:
                unexpected[key] = -value
    return missing, unexpected

</t>
<t tx="ekr.20220312061835.1771"># pylint: disable=consider-using-with
def _open_expected_file(self):
    try:
        return open(self._test_file.expected_output, encoding="utf-8")
    except FileNotFoundError:
        return StringIO("")

</t>
<t tx="ekr.20220312061835.1772"># pylint: disable=consider-using-with
def _open_source_file(self):
    if self._test_file.base == "invalid_encoded_data":
        return open(self._test_file.source, encoding="utf-8")
    if "latin1" in self._test_file.base:
        return open(self._test_file.source, encoding="latin1")
    return open(self._test_file.source, encoding="utf8")

</t>
<t tx="ekr.20220312061835.1773">def _get_expected(self):
    with self._open_source_file() as f:
        expected_msgs = self.get_expected_messages(f)
    if not expected_msgs:
        expected_msgs = Counter()
    with self._open_expected_file() as f:
        expected_output_lines = [
            OutputLine.from_csv(row) for row in csv.reader(f, "test")
        ]
    return expected_msgs, expected_output_lines

</t>
<t tx="ekr.20220312061835.1774">def _get_actual(self):
    messages = self._linter.reporter.messages
    messages.sort(key=lambda m: (m.line, m.symbol, m.msg))
    received_msgs = Counter()
    received_output_lines = []
    for msg in messages:
        assert (
            msg.symbol != "fatal"
        ), f"Pylint analysis failed because of '{msg.msg}'"
        received_msgs[msg.line, msg.symbol] += 1
        received_output_lines.append(OutputLine.from_msg(msg))
    return received_msgs, received_output_lines

</t>
<t tx="ekr.20220312061835.1775">def _runTest(self):
    __tracebackhide__ = True  # pylint: disable=unused-variable
    modules_to_check = [self._test_file.source]
    self._linter.check(modules_to_check)
    expected_messages, expected_output = self._get_expected()
    actual_messages, actual_output = self._get_actual()
    assert (
        expected_messages == actual_messages
    ), self.error_msg_for_unequal_messages(
        actual_messages, expected_messages, actual_output
    )
    self._check_output_text(expected_messages, expected_output, actual_output)

</t>
<t tx="ekr.20220312061835.1776">def error_msg_for_unequal_messages(
    self, actual_messages, expected_messages, actual_output: List[OutputLine]
):
    msg = [f'Wrong results for file "{self._test_file.base}":']
    missing, unexpected = self.multiset_difference(
        expected_messages, actual_messages
    )
    if missing:
        msg.append("\nExpected in testdata:")
        msg.extend(
            " %3d: %s" % msg  # pylint: disable=consider-using-f-string
            for msg in sorted(missing)
        )
    if unexpected:
        msg.append("\nUnexpected in testdata:")
        msg.extend(" %3d: %s" % msg for msg in sorted(unexpected))  # type: ignore #pylint: disable=consider-using-f-string
    error_msg = "\n".join(msg)
    if self._config and self._config.getoption("verbose") &gt; 0:
        error_msg += "\n\nActual pylint output for this file:\n"
        error_msg += "\n".join(str(o) for o in actual_output)
    return error_msg

</t>
<t tx="ekr.20220312061835.1777">def error_msg_for_unequal_output(self, expected_lines, received_lines) -&gt; str:
    missing = set(expected_lines) - set(received_lines)
    unexpected = set(received_lines) - set(expected_lines)
    error_msg = (
        f"Wrong output for '{self._test_file.base}.txt':\n"
        "You can update the expected output automatically with: '"
        f"python tests/test_functional.py {UPDATE_OPTION} -k "
        f'"test_functional[{self._test_file.base}]"\'\n\n'
    )
    sort_by_line_number = operator.attrgetter("lineno")
    if missing:
        error_msg += "\n- Missing lines:\n"
        for line in sorted(missing, key=sort_by_line_number):
            error_msg += f"{line}\n"
    if unexpected:
        error_msg += "\n- Unexpected lines:\n"
        for line in sorted(unexpected, key=sort_by_line_number):
            error_msg += f"{line}\n"
    return error_msg

</t>
<t tx="ekr.20220312061835.1778">def _check_output_text(self, _, expected_output, actual_output):
    """This is a function because we want to be able to update the text in LintModuleOutputUpdate"""
    assert expected_output == actual_output, self.error_msg_for_unequal_output(
        expected_output, actual_output
    )
</t>
<t tx="ekr.20220312061835.1779">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
from typing import Any, NamedTuple

from pylint import interfaces
from pylint.constants import PY38_PLUS
from pylint.testutils.constants import UPDATE_OPTION


@others
</t>
<t tx="ekr.20220312061835.178">class PassChecker(_BasicChecker):
    """check if the pass statement is really necessary"""

    msgs = {
        "W0107": (
            "Unnecessary pass statement",
            "unnecessary-pass",
            'Used when a "pass" statement that can be avoided is encountered.',
        )
    }

    @others
</t>
<t tx="ekr.20220312061835.1780">class Message(
    collections.namedtuple("Message", ["msg_id", "line", "node", "args", "confidence"])
):
    @others
</t>
<t tx="ekr.20220312061835.1781">def __new__(cls, msg_id, line=None, node=None, args=None, confidence=None):
    return tuple.__new__(cls, (msg_id, line, node, args, confidence))

</t>
<t tx="ekr.20220312061835.1782">def __eq__(self, other):
    if isinstance(other, Message):
        if self.confidence and other.confidence:
            return super().__eq__(other)
        return self[:-1] == other[:-1]
    return NotImplemented  # pragma: no cover


</t>
<t tx="ekr.20220312061835.1783">class MalformedOutputLineException(Exception):
    @others
</t>
<t tx="ekr.20220312061835.1784">def __init__(self, row, exception):
    example = "msg-symbolic-name:42:27:MyClass.my_function:The message"
    other_example = "msg-symbolic-name:7:42::The message"
    expected = [
        "symbol",
        "line",
        "column",
        "MyClass.myFunction, (or '')",
        "Message",
        "confidence",
    ]
    reconstructed_row = ""
    i = 0
    try:
        for i, column in enumerate(row):
            reconstructed_row += f"\t{expected[i]}='{column}' ?\n"
        for missing in expected[i + 1 :]:
            reconstructed_row += f"\t{missing}= Nothing provided !\n"
    except IndexError:
        pass
    raw = ":".join(row)
    msg = f"""\
\\-4.{exception}

\\-4.Expected '{example}' or '{other_example}' but we got '{raw}':
\\-4.{reconstructed_row}

\\-4.Try updating it with: 'python tests/test_functional.py {UPDATE_OPTION}'"""
    Exception.__init__(self, msg)


</t>
<t tx="ekr.20220312061835.1785">class OutputLine(NamedTuple):
    symbol: str
    lineno: int
    column: str
    object: Any
    msg: str
    confidence: interfaces.Confidence

    @others
</t>
<t tx="ekr.20220312061835.1786">@classmethod
def from_msg(cls, msg):
    column = cls.get_column(msg.column)
    return cls(
        msg.symbol,
        msg.line,
        column,
        msg.obj or "",
        msg.msg.replace("\r\n", "\n"),
        msg.confidence.name
        if msg.confidence != interfaces.UNDEFINED
        else interfaces.HIGH.name,
    )

</t>
<t tx="ekr.20220312061835.1787">@classmethod
def get_column(cls, column):
    if not PY38_PLUS:
        return ""  # pragma: no cover
    return str(column)

</t>
<t tx="ekr.20220312061835.1788">@classmethod
def from_csv(cls, row):
    try:
        confidence = row[5] if len(row) == 6 else interfaces.HIGH.name
        column = cls.get_column(row[2])
        return cls(row[0], int(row[1]), column, row[3], row[4], confidence)
    except Exception as e:
        raise MalformedOutputLineException(row, e) from e

</t>
<t tx="ekr.20220312061835.1789">def to_csv(self):
    return tuple(self)
</t>
<t tx="ekr.20220312061835.179">@utils.check_messages("unnecessary-pass")
def visit_pass(self, node: nodes.Pass) -&gt; None:
    if len(node.parent.child_sequence(node)) &gt; 1 or (
        isinstance(node.parent, (nodes.ClassDef, nodes.FunctionDef))
        and (node.parent.doc is not None)
    ):
        self.add_message("unnecessary-pass", node=node)


</t>
<t tx="ekr.20220312061835.1790">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from typing import List, Optional, Tuple


@others
</t>
<t tx="ekr.20220312061835.1791"># This class could and should be replaced with a simple dataclass when support for Python &lt; 3.7 is dropped.
# A NamedTuple is not possible as some tests need to modify attributes during the test.
class PyreverseConfig:  # pylint: disable=too-many-instance-attributes, too-many-arguments
    """Holds the configuration options for Pyreverse.
    The default values correspond to the defaults of the options parser."""

    @others
</t>
<t tx="ekr.20220312061835.1792">def __init__(
    self,
    mode: str = "PUB_ONLY",
    classes: Optional[List[str]] = None,
    show_ancestors: Optional[int] = None,
    all_ancestors: Optional[bool] = None,
    show_associated: Optional[int] = None,
    all_associated: Optional[bool] = None,
    show_builtin: bool = False,
    module_names: Optional[bool] = None,
    only_classnames: bool = False,
    output_format: str = "dot",
    colorized: bool = False,
    max_color_depth: int = 2,
    ignore_list: Tuple = tuple(),
    project: str = "",
    output_directory: str = "",
):
    self.mode = mode
    if classes:
        self.classes = classes
    else:
        self.classes = []
    self.show_ancestors = show_ancestors
    self.all_ancestors = all_ancestors
    self.show_associated = show_associated
    self.all_associated = all_associated
    self.show_builtin = show_builtin
    self.module_names = module_names
    self.only_classnames = only_classnames
    self.output_format = output_format
    self.colorized = colorized
    self.max_color_depth = max_color_depth
    self.ignore_list = ignore_list
    self.project = project
    self.output_directory = output_directory
</t>
<t tx="ekr.20220312061835.1793">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from io import StringIO
from os import getcwd, linesep, sep
from typing import TYPE_CHECKING, Dict, List, Optional

from pylint import interfaces
from pylint.message import Message
from pylint.reporters import BaseReporter

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section


@others
</t>
<t tx="ekr.20220312061835.1794">class GenericTestReporter(BaseReporter):
    """reporter storing plain text messages"""

    __implements__ = interfaces.IReporter

    @others
</t>
<t tx="ekr.20220312061835.1795">def __init__(
    self,
):  # pylint: disable=super-init-not-called # See https://github.com/PyCQA/pylint/issues/4941
    self.reset()

</t>
<t tx="ekr.20220312061835.1796">def reset(self):
    self.message_ids: Dict = {}
    self.out = StringIO()
    self.path_strip_prefix: str = getcwd() + sep
    self.messages: List[str] = []

</t>
<t tx="ekr.20220312061835.1797">def handle_message(self, msg: Message) -&gt; None:
    """manage message of different type and in the context of path"""
    obj = msg.obj
    line = msg.line
    msg_id = msg.msg_id
    str_message: str = msg.msg
    self.message_ids[msg_id] = 1
    if obj:
        obj = f":{obj}"
    sigle = msg_id[0]
    if linesep != "\n":
        # 2to3 writes os.linesep instead of using
        # the previously used line separators
        str_message = str_message.replace("\r\n", "\n")
    self.messages.append(f"{sigle}:{line:&gt;3}{obj}: {str_message}")

</t>
<t tx="ekr.20220312061835.1798">def finalize(self):
    self.messages.sort()
    for msg in self.messages:
        print(msg, file=self.out)
    result = self.out.getvalue()
    self.reset()
    return result

</t>
<t tx="ekr.20220312061835.1799"># pylint: disable=unused-argument
def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
    pass

</t>
<t tx="ekr.20220312061835.18">class DotBackend:
    """Dot File backend."""

    @others
</t>
<t tx="ekr.20220312061835.180">def _is_one_arg_pos_call(call):
    """Is this a call with exactly 1 argument,
    where that argument is positional?
    """
    return isinstance(call, nodes.Call) and len(call.args) == 1 and not call.keywords


</t>
<t tx="ekr.20220312061835.1800"># pylint: enable=unused-argument

</t>
<t tx="ekr.20220312061835.1801">def display_reports(self, layout: "Section") -&gt; None:
    """ignore layouts"""

</t>
<t tx="ekr.20220312061835.1802">def _display(self, layout: "Section") -&gt; None:
    pass


</t>
<t tx="ekr.20220312061835.1803">class MinimalTestReporter(BaseReporter):
    def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
        self.messages = []

    def _display(self, layout: "Section") -&gt; None:
        pass


</t>
<t tx="ekr.20220312061835.1804">class FunctionalTestReporter(BaseReporter):
    def on_set_current_module(self, module: str, filepath: Optional[str]) -&gt; None:
        self.messages = []

    def display_reports(self, layout: "Section") -&gt; None:
        """Ignore layouts and don't call self._display()."""

    def _display(self, layout: "Section") -&gt; None:
        pass
</t>
<t tx="ekr.20220312061835.1805">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import tokenize
from io import StringIO


def _tokenize_str(code):
    return list(tokenize.generate_tokens(StringIO(code).readline))
</t>
<t tx="ekr.20220312061835.1806">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

from pylint.testutils.global_test_linter import linter
from pylint.testutils.output_line import Message
from pylint.typing import CheckerStats


@others
</t>
<t tx="ekr.20220312061835.1807">class UnittestLinter:
    """A fake linter class to capture checker messages."""

    # pylint: disable=unused-argument, no-self-use

    @others
</t>
<t tx="ekr.20220312061835.1808">def __init__(self):
    self._messages = []
    self.stats: CheckerStats = {}

</t>
<t tx="ekr.20220312061835.1809">def release_messages(self):
    try:
        return self._messages
    finally:
        self._messages = []

</t>
<t tx="ekr.20220312061835.181">def _infer_dunder_doc_attribute(node):
    # Try to see if we have a `__doc__` attribute.
    try:
        docstring = node["__doc__"]
    except KeyError:
        return None

    docstring = utils.safe_infer(docstring)
    if not docstring:
        return None
    if not isinstance(docstring, nodes.Const):
        return None
    return docstring.value


</t>
<t tx="ekr.20220312061835.1810">def add_message(
    self, msg_id, line=None, node=None, args=None, confidence=None, col_offset=None
):
    # Do not test col_offset for now since changing Message breaks everything
    self._messages.append(Message(msg_id, line, node, args, confidence))

</t>
<t tx="ekr.20220312061835.1811">@staticmethod
def is_message_enabled(*unused_args, **unused_kwargs):
    return True

</t>
<t tx="ekr.20220312061835.1812">def add_stats(self, **kwargs):
    for name, value in kwargs.items():
        self.stats[name] = value
    return self.stats

</t>
<t tx="ekr.20220312061835.1813">@property
def options_providers(self):
    return linter.options_providers
</t>
<t tx="ekr.20220312061835.1814">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/testutils/
@language python
@tabwidth -4
# Copyright (c) 2012-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2013-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2013-2014 Google, Inc.
# Copyright (c) 2013 buck@yelp.com &lt;buck@yelp.com&gt;
# Copyright (c) 2014 LCD 47 &lt;lcd047@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Ricardo Gemignani &lt;ricardo.gemignani@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Pavel Roskin &lt;proski@gnu.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Derek Gustafson &lt;degustaf@gmail.com&gt;
# Copyright (c) 2016 Roy Williams &lt;roy.williams.iii@gmail.com&gt;
# Copyright (c) 2016 xmo-odoo &lt;xmo-odoo@users.noreply.github.com&gt;
# Copyright (c) 2017 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Mr. Senko &lt;atodorov@mrsenko.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Lefteris Karapetsas &lt;lefteris@refu.co&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Functional/non regression tests for pylint"""

__all__ = [
    "_get_tests_info",
    "_tokenize_str",
    "CheckerTestCase",
    "FunctionalTestFile",
    "linter",
    "LintModuleTest",
    "Message",
    "MinimalTestReporter",
    "set_config",
    "GenericTestReporter",
    "UPDATE_FILE",
    "UPDATE_OPTION",
    "UnittestLinter",
]

from pylint.testutils.checker_test_case import CheckerTestCase
from pylint.testutils.constants import UPDATE_FILE, UPDATE_OPTION
from pylint.testutils.decorator import set_config
from pylint.testutils.functional_test_file import FunctionalTestFile
from pylint.testutils.get_test_info import _get_tests_info
from pylint.testutils.global_test_linter import linter
from pylint.testutils.lint_module_test import LintModuleTest
from pylint.testutils.output_line import Message
from pylint.testutils.reporter_for_tests import GenericTestReporter, MinimalTestReporter
from pylint.testutils.tokenize_str import _tokenize_str
from pylint.testutils.unittest_linter import UnittestLinter
</t>
<t tx="ekr.20220312061835.1815"></t>
<t tx="ekr.20220312061835.1816">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/utils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
import traceback

from astroid import nodes


@others
</t>
<t tx="ekr.20220312061835.1817">class ASTWalker:
    @others
</t>
<t tx="ekr.20220312061835.1818">def __init__(self, linter):
    # callbacks per node types
    self.nbstatements = 0
    self.visit_events = collections.defaultdict(list)
    self.leave_events = collections.defaultdict(list)
    self.linter = linter
    self.exception_msg = False

</t>
<t tx="ekr.20220312061835.1819">def _is_method_enabled(self, method):
    if not hasattr(method, "checks_msgs"):
        return True
    for msg_desc in method.checks_msgs:
        if self.linter.is_message_enabled(msg_desc):
            return True
    return False

</t>
<t tx="ekr.20220312061835.182">class ComparisonChecker(_BasicChecker):
    """Checks for comparisons

    - singleton comparison: 'expr == True', 'expr == False' and 'expr == None'
    - yoda condition: 'const "comp" right' where comp can be '==', '!=', '&lt;',
      '&lt;=', '&gt;' or '&gt;=', and right can be a variable, an attribute, a method or
      a function
    """

    msgs = {
        "C0121": (
            "Comparison %s should be %s",
            "singleton-comparison",
            "Used when an expression is compared to singleton "
            "values like True, False or None.",
        ),
        "C0122": (
            "Comparison should be %s",
            "misplaced-comparison-constant",
            "Used when the constant is placed on the left side "
            "of a comparison. It is usually clearer in intent to "
            "place it in the right hand side of the comparison.",
        ),
        "C0123": (
            "Use isinstance() rather than type() for a typecheck.",
            "unidiomatic-typecheck",
            "The idiomatic way to perform an explicit typecheck in "
            "Python is to use isinstance(x, Y) rather than "
            "type(x) == Y, type(x) is Y. Though there are unusual "
            "situations where these give different results.",
            {"old_names": [("W0154", "old-unidiomatic-typecheck")]},
        ),
        "R0123": (
            "Comparison to literal",
            "literal-comparison",
            "Used when comparing an object to a literal, which is usually "
            "what you do not want to do, since you can compare to a different "
            "literal than what was expected altogether.",
        ),
        "R0124": (
            "Redundant comparison - %s",
            "comparison-with-itself",
            "Used when something is compared against itself.",
        ),
        "W0143": (
            "Comparing against a callable, did you omit the parenthesis?",
            "comparison-with-callable",
            "This message is emitted when pylint detects that a comparison with a "
            "callable was made, which might suggest that some parenthesis were omitted, "
            "resulting in potential unwanted behaviour.",
        ),
        "W0177": (
            "Comparison %s should be %s",
            "nan-comparison",
            "Used when an expression is compared to NaN"
            "values like numpy.NaN and float('nan')",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.1820">def add_checker(self, checker):
    """walk to the checker's dir and collect visit and leave methods"""
    vcids = set()
    lcids = set()
    visits = self.visit_events
    leaves = self.leave_events
    for member in dir(checker):
        cid = member[6:]
        if cid == "default":
            continue
        if member.startswith("visit_"):
            v_meth = getattr(checker, member)
            # don't use visit_methods with no activated message:
            if self._is_method_enabled(v_meth):
                visits[cid].append(v_meth)
                vcids.add(cid)
        elif member.startswith("leave_"):
            l_meth = getattr(checker, member)
            # don't use leave_methods with no activated message:
            if self._is_method_enabled(l_meth):
                leaves[cid].append(l_meth)
                lcids.add(cid)
    visit_default = getattr(checker, "visit_default", None)
    if visit_default:
        for cls in nodes.ALL_NODE_CLASSES:
            cid = cls.__name__.lower()
            if cid not in vcids:
                visits[cid].append(visit_default)
    # for now we have no "leave_default" method in Pylint

</t>
<t tx="ekr.20220312061835.1821">def walk(self, astroid):
    """call visit events of astroid checkers for the given node, recurse on
    its children, then leave events.
    """
    cid = astroid.__class__.__name__.lower()

    # Detect if the node is a new name for a deprecated alias.
    # In this case, favour the methods for the deprecated
    # alias if any,  in order to maintain backwards
    # compatibility.
    visit_events = self.visit_events.get(cid, ())
    leave_events = self.leave_events.get(cid, ())

    try:
        if astroid.is_statement:
            self.nbstatements += 1
        # generate events for this node on each checker
        for callback in visit_events or ():
            callback(astroid)
        # recurse on children
        for child in astroid.get_children():
            self.walk(child)
        for callback in leave_events or ():
            callback(astroid)
    except Exception:
        if self.exception_msg is False:
            file = getattr(astroid.root(), "file", None)
            print(f"Exception on node {repr(astroid)} in file '{file}'")
            traceback.print_exc()
            self.exception_msg = True
        raise
</t>
<t tx="ekr.20220312061835.1822">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/utils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections

from astroid import nodes

from pylint.constants import MSG_STATE_SCOPE_MODULE, WarningScope


@others
</t>
<t tx="ekr.20220312061835.1823">class FileState:
    """Hold internal state specific to the currently analyzed file"""

    @others
</t>
<t tx="ekr.20220312061835.1824">def __init__(self, modname=None):
    self.base_name = modname
    self._module_msgs_state = {}
    self._raw_module_msgs_state = {}
    self._ignored_msgs = collections.defaultdict(set)
    self._suppression_mapping = {}
    self._effective_max_line_number = None

</t>
<t tx="ekr.20220312061835.1825">def collect_block_lines(self, msgs_store, module_node):
    """Walk the AST to collect block level options line numbers."""
    for msg, lines in self._module_msgs_state.items():
        self._raw_module_msgs_state[msg] = lines.copy()
    orig_state = self._module_msgs_state.copy()
    self._module_msgs_state = {}
    self._suppression_mapping = {}
    self._effective_max_line_number = module_node.tolineno
    self._collect_block_lines(msgs_store, module_node, orig_state)

</t>
<t tx="ekr.20220312061835.1826">def _collect_block_lines(self, msgs_store, node, msg_state):
    """Recursively walk (depth first) AST to collect block level options
    line numbers.
    """
    for child in node.get_children():
        self._collect_block_lines(msgs_store, child, msg_state)
    first = node.fromlineno
    last = node.tolineno
    # first child line number used to distinguish between disable
    # which are the first child of scoped node with those defined later.
    # For instance in the code below:
    #
    # 1.   def meth8(self):
    # 2.        """test late disabling"""
    # 3.        pylint: disable=not-callable
    # 4.        print(self.blip)
    # 5.        pylint: disable=no-member
    # 6.        print(self.bla)
    #
    # E1102 should be disabled from line 1 to 6 while E1101 from line 5 to 6
    #
    # this is necessary to disable locally messages applying to class /
    # function using their fromlineno
    if (
        isinstance(node, (nodes.Module, nodes.ClassDef, nodes.FunctionDef))
        and node.body
    ):
        firstchildlineno = node.body[0].fromlineno
    else:
        firstchildlineno = last
    for msgid, lines in msg_state.items():
        for lineno, state in list(lines.items()):
            original_lineno = lineno
            if first &gt; lineno or last &lt; lineno:
                continue
            # Set state for all lines for this block, if the
            # warning is applied to nodes.
            message_definitions = msgs_store.get_message_definitions(msgid)
            for message_definition in message_definitions:
                if message_definition.scope == WarningScope.NODE:
                    if lineno &gt; firstchildlineno:
                        state = True
                    first_, last_ = node.block_range(lineno)
                else:
                    first_ = lineno
                    last_ = last
            for line in range(first_, last_ + 1):
                # do not override existing entries
                if line in self._module_msgs_state.get(msgid, ()):
                    continue
                if line in lines:  # state change in the same block
                    state = lines[line]
                    original_lineno = line
                if not state:
                    self._suppression_mapping[(msgid, line)] = original_lineno
                try:
                    self._module_msgs_state[msgid][line] = state
                except KeyError:
                    self._module_msgs_state[msgid] = {line: state}
            del lines[lineno]

</t>
<t tx="ekr.20220312061835.1827">def set_msg_status(self, msg, line, status):
    """Set status (enabled/disable) for a given message at a given line"""
    assert line &gt; 0
    try:
        self._module_msgs_state[msg.msgid][line] = status
    except KeyError:
        self._module_msgs_state[msg.msgid] = {line: status}

</t>
<t tx="ekr.20220312061835.1828">def handle_ignored_message(
    self, state_scope, msgid, line, node, args, confidence
):  # pylint: disable=unused-argument
    """Report an ignored message.

    state_scope is either MSG_STATE_SCOPE_MODULE or MSG_STATE_SCOPE_CONFIG,
    depending on whether the message was disabled locally in the module,
    or globally. The other arguments are the same as for add_message.
    """
    if state_scope == MSG_STATE_SCOPE_MODULE:
        try:
            orig_line = self._suppression_mapping[(msgid, line)]
            self._ignored_msgs[(msgid, orig_line)].add(line)
        except KeyError:
            pass

</t>
<t tx="ekr.20220312061835.1829">def iter_spurious_suppression_messages(self, msgs_store):
    for warning, lines in self._raw_module_msgs_state.items():
        for line, enable in lines.items():
            if not enable and (warning, line) not in self._ignored_msgs:
                # ignore cyclic-import check which can show false positives
                # here due to incomplete context
                if warning != "R0401":
                    yield "useless-suppression", line, (
                        msgs_store.get_msg_display_string(warning),
                    )
    # don't use iteritems here, _ignored_msgs may be modified by add_message
    for (warning, from_), lines in list(self._ignored_msgs.items()):
        for line in lines:
            yield "suppressed-message", line, (
                msgs_store.get_msg_display_string(warning),
                from_,
            )

</t>
<t tx="ekr.20220312061835.183">def _check_singleton_comparison(
    self, left_value, right_value, root_node, checking_for_absence: bool = False
):
    """Check if == or != is being used to compare a singleton value"""
    singleton_values = (True, False, None)

    def _is_singleton_const(node) -&gt; bool:
        return isinstance(node, nodes.Const) and any(
            node.value is value for value in singleton_values
        )

    if _is_singleton_const(left_value):
        singleton, other_value = left_value.value, right_value
    elif _is_singleton_const(right_value):
        singleton, other_value = right_value.value, left_value
    else:
        return

    singleton_comparison_example = {False: "'{} is {}'", True: "'{} is not {}'"}

    # True/False singletons have a special-cased message in case the user is
    # mistakenly using == or != to check for truthiness
    if singleton in (True, False):
        suggestion_template = (
            "{} if checking for the singleton value {}, or {} if testing for {}"
        )
        truthiness_example = {False: "not {}", True: "{}"}
        truthiness_phrase = {True: "truthiness", False: "falsiness"}

        # Looks for comparisons like x == True or x != False
        checking_truthiness = singleton is not checking_for_absence

        suggestion = suggestion_template.format(
            singleton_comparison_example[checking_for_absence].format(
                left_value.as_string(), right_value.as_string()
            ),
            singleton,
            (
                "'bool({})'"
                if not utils.is_test_condition(root_node) and checking_truthiness
                else "'{}'"
            ).format(
                truthiness_example[checking_truthiness].format(
                    other_value.as_string()
                )
            ),
            truthiness_phrase[checking_truthiness],
        )
    else:
        suggestion = singleton_comparison_example[checking_for_absence].format(
            left_value.as_string(), right_value.as_string()
        )
    self.add_message(
        "singleton-comparison",
        node=root_node,
        args=(f"'{root_node.as_string()}'", suggestion),
    )

</t>
<t tx="ekr.20220312061835.1830">def get_effective_max_line_number(self):
    return self._effective_max_line_number
</t>
<t tx="ekr.20220312061835.1831">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/utils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import re
from collections import namedtuple
from typing import Generator, List

# Allow stopping after the first semicolon/hash encountered,
# so that an option can be continued with the reasons
# why it is active or disabled.
OPTION_RGX = r"""
    \s*                #Any number of whithespace
    \#?                #One or zero hash
    .*                 #Anything (as much as possible)
    (\s*               # Beginning of first matched group and any number of whitespaces
    \#                 #Beginning of comment
    .*?                #Anything (as little as possible)
    \bpylint:          # pylint word and column
    \s*                # Any number of whitespaces
    ([^;#\n]+))        # Anything except semicolon or hash or newline (it is the second matched group)
                       # and end of the first matched group
    [;#]{0,1}"""  # From 0 to 1 repetition of semicolon or hash
OPTION_PO = re.compile(OPTION_RGX, re.VERBOSE)


PragmaRepresenter = namedtuple("PragmaRepresenter", "action messages")


ATOMIC_KEYWORDS = frozenset(("disable-all", "skip-file"))
MESSAGE_KEYWORDS = frozenset(
    ("disable-next", "disable-msg", "enable-msg", "disable", "enable")
)
# sorted is necessary because sets are unordered collections and ALL_KEYWORDS
# string should not vary between executions
# reverse is necessary in order to have the longest keywords first, so that, for example,
# 'disable' stringshould not be matched instead of 'disable-all'
ALL_KEYWORDS = "|".join(
    sorted(ATOMIC_KEYWORDS | MESSAGE_KEYWORDS, key=len, reverse=True)
)


TOKEN_SPECIFICATION = [
    ("KEYWORD", fr"\b({ALL_KEYWORDS:s})\b"),
    ("MESSAGE_STRING", r"[0-9A-Za-z\-\_]{2,}"),  # Identifiers
    ("ASSIGN", r"="),  # Assignment operator
    ("MESSAGE_NUMBER", r"[CREIWF]{1}\d*"),
]

TOK_REGEX = "|".join(
    f"(?P&lt;{token_name:s}&gt;{token_rgx:s})"
    for token_name, token_rgx in TOKEN_SPECIFICATION
)


@others
</t>
<t tx="ekr.20220312061835.1832">def emit_pragma_representer(action, messages):
    if not messages and action in MESSAGE_KEYWORDS:
        raise InvalidPragmaError(
            "The keyword is not followed by message identifier", action
        )
    return PragmaRepresenter(action, messages)


</t>
<t tx="ekr.20220312061835.1833">class PragmaParserError(Exception):
    """
    A class for exceptions thrown by pragma_parser module
    """

    @others
</t>
<t tx="ekr.20220312061835.1834">def __init__(self, message, token):
    """
    :args message: explain the reason why the exception has been thrown
    :args token: token concerned by the exception
    """
    self.message = message
    self.token = token
    super().__init__(self.message)


</t>
<t tx="ekr.20220312061835.1835">class UnRecognizedOptionError(PragmaParserError):
    """
    Thrown in case the of a valid but unrecognized option
    """


</t>
<t tx="ekr.20220312061835.1836">class InvalidPragmaError(PragmaParserError):
    """
    Thrown in case the pragma is invalid
    """


</t>
<t tx="ekr.20220312061835.1837">def parse_pragma(pylint_pragma: str) -&gt; Generator[PragmaRepresenter, None, None]:
    action = None
    messages: List[str] = []
    assignment_required = False
    previous_token = ""

    for mo in re.finditer(TOK_REGEX, pylint_pragma):
        kind = mo.lastgroup
        value = mo.group()

        if kind == "ASSIGN":
            if not assignment_required:
                if action:
                    # A keyword has been found previously but doesn't support assignement
                    raise UnRecognizedOptionError(
                        "The keyword doesn't support assignment", action
                    )
                if previous_token:
                    # Something found previously but not a known keyword
                    raise UnRecognizedOptionError(
                        "The keyword is unknown", previous_token
                    )
                # Nothing at all detected before this assignment
                raise InvalidPragmaError("Missing keyword before assignment", "")
            assignment_required = False
        elif assignment_required:
            raise InvalidPragmaError("The = sign is missing after the keyword", action)
        elif kind == "KEYWORD":
            if action:
                yield emit_pragma_representer(action, messages)
            action = value
            messages = []
            assignment_required = action in MESSAGE_KEYWORDS
        elif kind in ("MESSAGE_STRING", "MESSAGE_NUMBER"):
            messages.append(value)
            assignment_required = False
        else:
            raise RuntimeError("Token not recognized")

        previous_token = value

    if action:
        yield emit_pragma_representer(action, messages)
    else:
        raise UnRecognizedOptionError("The keyword is unknown", previous_token)
</t>
<t tx="ekr.20220312061835.1838">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/utils/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


try:
    import isort.api

    HAS_ISORT_5 = True
except ImportError:  # isort &lt; 5
    import isort

    HAS_ISORT_5 = False

import codecs
import os
import re
import sys
import textwrap
import tokenize
from io import BufferedReader, BytesIO
from typing import (
    TYPE_CHECKING,
    List,
    Optional,
    Pattern,
    TextIO,
    Tuple,
    TypeVar,
    Union,
    overload,
)

from astroid import Module, modutils, nodes

from pylint.constants import PY_EXTS

if sys.version_info &gt;= (3, 8):
    from typing import Literal
else:
    from typing_extensions import Literal

if TYPE_CHECKING:
    from pylint.checkers.base_checker import BaseChecker

DEFAULT_LINE_LENGTH = 79

# These are types used to overload get_global_option() and refer to the options type
GLOBAL_OPTION_BOOL = Literal[
    "ignore-mixin-members",
    "suggestion-mode",
    "analyse-fallback-blocks",
    "allow-global-unused-variables",
]
GLOBAL_OPTION_INT = Literal["max-line-length", "docstring-min-length"]
GLOBAL_OPTION_LIST = Literal["ignored-modules"]
GLOBAL_OPTION_PATTERN = Literal[
    "no-docstring-rgx", "dummy-variables-rgx", "ignored-argument-names"
]
GLOBAL_OPTION_TUPLE_INT = Literal["py-version"]
GLOBAL_OPTION_NAMES = Union[
    GLOBAL_OPTION_BOOL,
    GLOBAL_OPTION_INT,
    GLOBAL_OPTION_LIST,
    GLOBAL_OPTION_PATTERN,
    GLOBAL_OPTION_TUPLE_INT,
]
T_GlobalOptionReturnTypes = TypeVar(
    "T_GlobalOptionReturnTypes", bool, int, List[str], Pattern, Tuple[int, ...]
)


@others
</t>
<t tx="ekr.20220312061835.1839">def normalize_text(text, line_len=DEFAULT_LINE_LENGTH, indent=""):
    """Wrap the text on the given line length."""
    return "\n".join(
        textwrap.wrap(
            text, width=line_len, initial_indent=indent, subsequent_indent=indent
        )
    )


</t>
<t tx="ekr.20220312061835.184">def _check_nan_comparison(
    self, left_value, right_value, root_node, checking_for_absence: bool = False
):
    def _is_float_nan(node):
        try:
            if isinstance(node, nodes.Call) and len(node.args) == 1:
                if (
                    node.args[0].value.lower() == "nan"
                    and node.inferred()[0].pytype() == "builtins.float"
                ):
                    return True
            return False
        except AttributeError:
            return False

    def _is_numpy_nan(node):
        if isinstance(node, nodes.Attribute) and node.attrname == "NaN":
            if isinstance(node.expr, nodes.Name):
                return node.expr.name in ("numpy", "nmp", "np")
        return False

    def _is_nan(node) -&gt; bool:
        return _is_float_nan(node) or _is_numpy_nan(node)

    nan_left = _is_nan(left_value)
    if not nan_left and not _is_nan(right_value):
        return

    absence_text = ""
    if checking_for_absence:
        absence_text = "not "
    if nan_left:
        suggestion = f"'{absence_text}math.isnan({right_value.as_string()})'"
    else:
        suggestion = f"'{absence_text}math.isnan({left_value.as_string()})'"
    self.add_message(
        "nan-comparison",
        node=root_node,
        args=(f"'{root_node.as_string()}'", suggestion),
    )

</t>
<t tx="ekr.20220312061835.1840">CMPS = ["=", "-", "+"]


</t>
<t tx="ekr.20220312061835.1841"># py3k has no more cmp builtin
def cmp(a, b):  # pylint: disable=redefined-builtin
    return (a &gt; b) - (a &lt; b)


</t>
<t tx="ekr.20220312061835.1842">def diff_string(old, new):
    """given an old and new int value, return a string representing the
    difference
    """
    diff = abs(old - new)
    diff_str = f"{CMPS[cmp(old, new)]}{diff and f'{diff:.2f}' or ''}"
    return diff_str


</t>
<t tx="ekr.20220312061835.1843">def get_module_and_frameid(node):
    """return the module name and the frame id in the module"""
    frame = node.frame()
    module, obj = "", []
    while frame:
        if isinstance(frame, Module):
            module = frame.name
        else:
            obj.append(getattr(frame, "name", "&lt;lambda&gt;"))
        try:
            frame = frame.parent.frame()
        except AttributeError:
            break
    obj.reverse()
    return module, ".".join(obj)


</t>
<t tx="ekr.20220312061835.1844">def get_rst_title(title, character):
    """Permit to get a title formatted as ReStructuredText test (underlined with a chosen character)."""
    return f"{title}\n{character * len(title)}\n"


</t>
<t tx="ekr.20220312061835.1845">def get_rst_section(section, options, doc=None):
    """format an options section using as a ReStructuredText formatted output"""
    result = ""
    if section:
        result += get_rst_title(section, "'")
    if doc:
        formatted_doc = normalize_text(doc)
        result += f"{formatted_doc}\n\n"
    for optname, optdict, value in options:
        help_opt = optdict.get("help")
        result += f":{optname}:\n"
        if help_opt:
            formatted_help = normalize_text(help_opt, indent="  ")
            result += f"{formatted_help}\n"
        if value:
            value = str(_format_option_value(optdict, value))
            result += f"\n  Default: ``{value.replace('`` ', '```` ``')}``\n"
    return result


</t>
<t tx="ekr.20220312061835.1846">def safe_decode(line, encoding, *args, **kwargs):
    """return decoded line from encoding or decode with default encoding"""
    try:
        return line.decode(encoding or sys.getdefaultencoding(), *args, **kwargs)
    except LookupError:
        return line.decode(sys.getdefaultencoding(), *args, **kwargs)


</t>
<t tx="ekr.20220312061835.1847">def decoding_stream(
    stream: Union[BufferedReader, BytesIO],
    encoding: str,
    errors: Literal["strict"] = "strict",
) -&gt; codecs.StreamReader:
    try:
        reader_cls = codecs.getreader(encoding or sys.getdefaultencoding())
    except LookupError:
        reader_cls = codecs.getreader(sys.getdefaultencoding())
    return reader_cls(stream, errors)


</t>
<t tx="ekr.20220312061835.1848">def tokenize_module(node: nodes.Module) -&gt; List[tokenize.TokenInfo]:
    with node.stream() as stream:
        readline = stream.readline
        return list(tokenize.tokenize(readline))


</t>
<t tx="ekr.20220312061835.1849">def register_plugins(linter, directory):
    """load all module and package in the given directory, looking for a
    'register' function in each one, used to register pylint checkers
    """
    imported = {}
    for filename in os.listdir(directory):
        base, extension = os.path.splitext(filename)
        if base in imported or base == "__pycache__":
            continue
        if (
            extension in PY_EXTS
            and base != "__init__"
            or (
                not extension
                and os.path.isdir(os.path.join(directory, base))
                and not filename.startswith(".")
            )
        ):
            try:
                module = modutils.load_module_from_file(
                    os.path.join(directory, filename)
                )
            except ValueError:
                # empty module name (usually emacs auto-save files)
                continue
            except ImportError as exc:
                print(f"Problem importing module {filename}: {exc}", file=sys.stderr)
            else:
                if hasattr(module, "register"):
                    module.register(linter)
                    imported[base] = 1


</t>
<t tx="ekr.20220312061835.185">def _check_literal_comparison(self, literal, node):
    """Check if we compare to a literal, which is usually what we do not want to do."""
    is_other_literal = isinstance(
        literal, (nodes.List, nodes.Tuple, nodes.Dict, nodes.Set)
    )
    is_const = False
    if isinstance(literal, nodes.Const):
        if isinstance(literal.value, bool) or literal.value is None:
            # Not interested in this values.
            return
        is_const = isinstance(literal.value, (bytes, str, int, float))

    if is_const or is_other_literal:
        self.add_message("literal-comparison", node=node)

</t>
<t tx="ekr.20220312061835.1850">@overload
def get_global_option(
    checker: "BaseChecker", option: GLOBAL_OPTION_BOOL, default: Optional[bool] = None
) -&gt; bool:
    ...


</t>
<t tx="ekr.20220312061835.1851">@overload
def get_global_option(
    checker: "BaseChecker", option: GLOBAL_OPTION_INT, default: Optional[int] = None
) -&gt; int:
    ...


</t>
<t tx="ekr.20220312061835.1852">@overload
def get_global_option(
    checker: "BaseChecker",
    option: GLOBAL_OPTION_LIST,
    default: Optional[List[str]] = None,
) -&gt; List[str]:
    ...


</t>
<t tx="ekr.20220312061835.1853">@overload
def get_global_option(
    checker: "BaseChecker",
    option: GLOBAL_OPTION_PATTERN,
    default: Optional[Pattern] = None,
) -&gt; Pattern:
    ...


</t>
<t tx="ekr.20220312061835.1854">@overload
def get_global_option(
    checker: "BaseChecker",
    option: GLOBAL_OPTION_TUPLE_INT,
    default: Optional[Tuple[int, ...]] = None,
) -&gt; Tuple[int, ...]:
    ...


</t>
<t tx="ekr.20220312061835.1855">def get_global_option(
    checker: "BaseChecker",
    option: GLOBAL_OPTION_NAMES,
    default: Optional[T_GlobalOptionReturnTypes] = None,
) -&gt; Optional[T_GlobalOptionReturnTypes]:
    """Retrieve an option defined by the given *checker* or
    by all known option providers.

    It will look in the list of all options providers
    until the given *option* will be found.
    If the option wasn't found, the *default* value will be returned.
    """
    # First, try in the given checker's config.
    # After that, look in the options providers.

    try:
        return getattr(checker.config, option.replace("-", "_"))
    except AttributeError:
        pass
    for provider in checker.linter.options_providers:
        for options in provider.options:
            if options[0] == option:
                return getattr(provider.config, option.replace("-", "_"))
    return default


</t>
<t tx="ekr.20220312061835.1856">def deprecated_option(
    shortname=None, opt_type=None, help_msg=None, deprecation_msg=None
):
    @others
    option = {
        "help": help_msg,
        "hide": True,
        "type": opt_type,
        "action": "callback",
        "callback": _warn_deprecated,
        "deprecated": True,
    }
    if shortname:
        option["shortname"] = shortname
    return option


</t>
<t tx="ekr.20220312061835.1857">def _warn_deprecated(option, optname, *args):  # pylint: disable=unused-argument
    if deprecation_msg:
        sys.stderr.write(deprecation_msg % (optname,))

</t>
<t tx="ekr.20220312061835.1858">def _splitstrip(string, sep=","):
    """return a list of stripped string by splitting the string given as
    argument on `sep` (',' by default). Empty string are discarded.

    &gt;&gt;&gt; _splitstrip('a, b, c   ,  4,,')
    ['a', 'b', 'c', '4']
    &gt;&gt;&gt; _splitstrip('a')
    ['a']
    &gt;&gt;&gt; _splitstrip('a,\nb,\nc,')
    ['a', 'b', 'c']

    :type string: str or unicode
    :param string: a csv line

    :type sep: str or unicode
    :param sep: field separator, default to the comma (',')

    :rtype: str or unicode
    :return: the unquoted string (or the input string if it wasn't quoted)
    """
    return [word.strip() for word in string.split(sep) if word.strip()]


</t>
<t tx="ekr.20220312061835.1859">def _unquote(string):
    """remove optional quotes (simple or double) from the string

    :type string: str or unicode
    :param string: an optionally quoted string

    :rtype: str or unicode
    :return: the unquoted string (or the input string if it wasn't quoted)
    """
    if not string:
        return string
    if string[0] in "\"'":
        string = string[1:]
    if string[-1] in "\"'":
        string = string[:-1]
    return string


</t>
<t tx="ekr.20220312061835.186">def _check_misplaced_constant(self, node, left, right, operator):
    if isinstance(right, nodes.Const):
        return
    operator = REVERSED_COMPS.get(operator, operator)
    suggestion = f"{right.as_string()} {operator} {left.value!r}"
    self.add_message("misplaced-comparison-constant", node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.1860">def _check_csv(value):
    if isinstance(value, (list, tuple)):
        return value
    return _splitstrip(value)


</t>
<t tx="ekr.20220312061835.1861">def _comment(string):
    """return string as a comment"""
    lines = [line.strip() for line in string.splitlines()]
    return "# " + f"{os.linesep}# ".join(lines)


</t>
<t tx="ekr.20220312061835.1862">def _format_option_value(optdict, value):
    """return the user input's value from a 'compiled' value"""
    if optdict.get("type", None) == "py_version":
        value = ".".join(str(item) for item in value)
    elif isinstance(value, (list, tuple)):
        value = ",".join(_format_option_value(optdict, item) for item in value)
    elif isinstance(value, dict):
        value = ",".join(f"{k}:{v}" for k, v in value.items())
    elif hasattr(value, "match"):  # optdict.get('type') == 'regexp'
        # compiled regexp
        value = value.pattern
    elif optdict.get("type") == "yn":
        value = "yes" if value else "no"
    elif isinstance(value, str) and value.isspace():
        value = f"'{value}'"
    return value


</t>
<t tx="ekr.20220312061835.1863">def format_section(
    stream: TextIO, section: str, options: List[Tuple], doc: Optional[str] = None
) -&gt; None:
    """format an options section using the INI format"""
    if doc:
        print(_comment(doc), file=stream)
    print(f"[{section}]", file=stream)
    _ini_format(stream, options)


</t>
<t tx="ekr.20220312061835.1864">def _ini_format(stream: TextIO, options: List[Tuple]) -&gt; None:
    """format options using the INI format"""
    for optname, optdict, value in options:
        value = _format_option_value(optdict, value)
        help_opt = optdict.get("help")
        if help_opt:
            help_opt = normalize_text(help_opt, indent="# ")
            print(file=stream)
            print(help_opt, file=stream)
        else:
            print(file=stream)
        if value is None:
            print(f"#{optname}=", file=stream)
        else:
            value = str(value).strip()
            if re.match(r"^([\w-]+,)+[\w-]+$", str(value)):
                separator = "\n " + " " * len(optname)
                value = separator.join(x + "," for x in str(value).split(","))
                # remove trailing ',' from last element of the list
                value = value[:-1]
            print(f"{optname}={value}", file=stream)


</t>
<t tx="ekr.20220312061835.1865">class IsortDriver:
    """A wrapper around isort API that changed between versions 4 and 5."""

    @others
</t>
<t tx="ekr.20220312061835.1866">def __init__(self, config):
    if HAS_ISORT_5:
        self.isort5_config = isort.api.Config(
            # There is not typo here. EXTRA_standard_library is
            # what most users want. The option has been named
            # KNOWN_standard_library for ages in pylint and we
            # don't want to break compatibility.
            extra_standard_library=config.known_standard_library,
            known_third_party=config.known_third_party,
        )
    else:
        self.isort4_obj = isort.SortImports(  # pylint: disable=no-member
            file_contents="",
            known_standard_library=config.known_standard_library,
            known_third_party=config.known_third_party,
        )

</t>
<t tx="ekr.20220312061835.1867">def place_module(self, package):
    if HAS_ISORT_5:
        return isort.api.place_module(package, self.isort5_config)
    return self.isort4_obj.place_module(package)
</t>
<t tx="ekr.20220312061835.1868">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/utils/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009 Vincent
# Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2014-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014-2015 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 LCD 47 &lt;lcd047@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2014 Damien Nozay &lt;damien.nozay@gmail.com&gt;
# Copyright (c) 2015 Aru Sahni &lt;arusahni@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glmatthe@cisco.com&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 xmo-odoo &lt;xmo-odoo@users.noreply.github.com&gt;
# Copyright (c) 2017-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2017-2018, 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2017 Chris Lamb &lt;chris@chris-lamb.co.uk&gt;
# Copyright (c) 2017 Thomas Hisch &lt;t.hisch@gmail.com&gt;
# Copyright (c) 2017 Mikhail Fesenko &lt;proggga@gmail.com&gt;
# Copyright (c) 2017 Craig Citro &lt;craigcitro@gmail.com&gt;
# Copyright (c) 2017 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Reverb C &lt;reverbc@users.noreply.github.com&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""some various utilities and helper classes, most of them used in the
main pylint class
"""

from pylint.utils.ast_walker import ASTWalker
from pylint.utils.file_state import FileState
from pylint.utils.utils import (
    HAS_ISORT_5,
    IsortDriver,
    _check_csv,
    _format_option_value,
    _splitstrip,
    _unquote,
    decoding_stream,
    deprecated_option,
    diff_string,
    format_section,
    get_global_option,
    get_module_and_frameid,
    get_rst_section,
    get_rst_title,
    normalize_text,
    register_plugins,
    safe_decode,
    tokenize_module,
)

__all__ = [
    "ASTWalker",
    "HAS_ISORT_5",
    "IsortDriver",
    "_check_csv",
    "_format_option_value",
    "_splitstrip",
    "_unquote",
    "decoding_stream",
    "deprecated_option",
    "diff_string",
    "FileState",
    "format_section",
    "get_global_option",
    "get_module_and_frameid",
    "get_rst_section",
    "get_rst_title",
    "normalize_text",
    "register_plugins",
    "safe_decode",
    "tokenize_module",
]
</t>
<t tx="ekr.20220312061835.187">def _check_logical_tautology(self, node: nodes.Compare):
    """Check if identifier is compared against itself.
    :param node: Compare node
    :Example:
    val = 786
    if val == val:  # [comparison-with-itself]
        pass
    """
    left_operand = node.left
    right_operand = node.ops[0][1]
    operator = node.ops[0][0]
    if isinstance(left_operand, nodes.Const) and isinstance(
        right_operand, nodes.Const
    ):
        left_operand = left_operand.value
        right_operand = right_operand.value
    elif isinstance(left_operand, nodes.Name) and isinstance(
        right_operand, nodes.Name
    ):
        left_operand = left_operand.name
        right_operand = right_operand.name

    if left_operand == right_operand:
        suggestion = f"{left_operand} {operator} {right_operand}"
        self.add_message("comparison-with-itself", node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.188">def _check_callable_comparison(self, node):
    operator = node.ops[0][0]
    if operator not in COMPARISON_OPERATORS:
        return

    bare_callables = (nodes.FunctionDef, astroid.BoundMethod)
    left_operand, right_operand = node.left, node.ops[0][1]
    # this message should be emitted only when there is comparison of bare callable
    # with non bare callable.
    if (
        sum(
            1
            for operand in (left_operand, right_operand)
            if isinstance(utils.safe_infer(operand), bare_callables)
        )
        == 1
    ):
        self.add_message("comparison-with-callable", node=node)

</t>
<t tx="ekr.20220312061835.189">@utils.check_messages(
    "singleton-comparison",
    "misplaced-comparison-constant",
    "unidiomatic-typecheck",
    "literal-comparison",
    "comparison-with-itself",
    "comparison-with-callable",
)
</t>
<t tx="ekr.20220312061835.19">def __init__(
    self,
    graphname,
    rankdir=None,
    size=None,
    ratio=None,
    charset="utf-8",
    renderer="dot",
    additional_param=None,
):
    if additional_param is None:
        additional_param = {}
    self.graphname = graphname
    self.renderer = renderer
    self.lines = []
    self._source = None
    self.emit(f"digraph {normalize_node_id(graphname)} {{")
    if rankdir:
        self.emit(f"rankdir={rankdir}")
    if ratio:
        self.emit(f"ratio={ratio}")
    if size:
        self.emit(f'size="{size}"')
    if charset:
        assert charset.lower() in (
            "utf-8",
            "iso-8859-1",
            "latin1",
        ), f"unsupported charset {charset}"
        self.emit(f'charset="{charset}"')
    for param in additional_param.items():
        self.emit("=".join(param))

</t>
<t tx="ekr.20220312061835.190">def visit_compare(self, node: nodes.Compare) -&gt; None:
    self._check_callable_comparison(node)
    self._check_logical_tautology(node)
    self._check_unidiomatic_typecheck(node)
    # NOTE: this checker only works with binary comparisons like 'x == 42'
    # but not 'x == y == 42'
    if len(node.ops) != 1:
        return

    left = node.left
    operator, right = node.ops[0]
    if operator in COMPARISON_OPERATORS and isinstance(left, nodes.Const):
        self._check_misplaced_constant(node, left, right, operator)

    if operator in ("==", "!="):
        self._check_singleton_comparison(
            left, right, node, checking_for_absence=operator == "!="
        )

    if operator in ("==", "!=", "is", "is not"):
        self._check_nan_comparison(
            left, right, node, checking_for_absence=operator in ("!=", "is not")
        )
    if operator in ("is", "is not"):
        self._check_literal_comparison(right, node)

</t>
<t tx="ekr.20220312061835.191">def _check_unidiomatic_typecheck(self, node):
    operator, right = node.ops[0]
    if operator in TYPECHECK_COMPARISON_OPERATORS:
        left = node.left
        if _is_one_arg_pos_call(left):
            self._check_type_x_is_y(node, left, operator, right)

</t>
<t tx="ekr.20220312061835.192">def _check_type_x_is_y(self, node, left, operator, right):
    """Check for expressions like type(x) == Y."""
    left_func = utils.safe_infer(left.func)
    if not (
        isinstance(left_func, nodes.ClassDef) and left_func.qname() == TYPE_QNAME
    ):
        return

    if operator in ("is", "is not") and _is_one_arg_pos_call(right):
        right_func = utils.safe_infer(right.func)
        if (
            isinstance(right_func, nodes.ClassDef)
            and right_func.qname() == TYPE_QNAME
        ):
            # type(x) == type(a)
            right_arg = utils.safe_infer(right.args[0])
            if not isinstance(right_arg, LITERAL_NODE_TYPES):
                # not e.g. type(x) == type([])
                return
    self.add_message("unidiomatic-typecheck", node=node)


</t>
<t tx="ekr.20220312061835.193">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(BasicErrorChecker(linter))
    linter.register_checker(BasicChecker(linter))
    linter.register_checker(NameChecker(linter))
    linter.register_checker(DocStringChecker(linter))
    linter.register_checker(PassChecker(linter))
    linter.register_checker(ComparisonChecker(linter))
</t>
<t tx="ekr.20220312061835.194">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2013-2014 Google, Inc.
# Copyright (c) 2013 buck@yelp.com &lt;buck@yelp.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019 Bruno P. Kinoshita &lt;kinow@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
import functools
from inspect import cleandoc
from typing import Any

from pylint.config import OptionsProviderMixIn
from pylint.constants import _MSG_ORDER, WarningScope
from pylint.exceptions import InvalidMessageError
from pylint.interfaces import UNDEFINED, IRawChecker, ITokenChecker, implements
from pylint.message.message_definition import MessageDefinition
from pylint.typing import CheckerStats
from pylint.utils import get_rst_section, get_rst_title


@others
</t>
<t tx="ekr.20220312061835.195">@functools.total_ordering
class BaseChecker(OptionsProviderMixIn):

    # checker name (you may reuse an existing one)
    name: str = ""
    # options level (0 will be displaying in --help, 1 in --long-help)
    level = 1
    # ordered list of options to control the checker behaviour
    options: Any = ()
    # messages issued by this checker
    msgs: Any = {}
    # reports issued by this checker
    reports: Any = ()
    # mark this checker as enabled or not.
    enabled: bool = True

    @others
</t>
<t tx="ekr.20220312061835.196">def __init__(self, linter=None):
    """checker instances should have the linter as argument

    :param ILinter linter: is an object implementing ILinter."""
    if self.name is not None:
        self.name = self.name.lower()
    OptionsProviderMixIn.__init__(self)
    self.linter = linter
    self.stats: CheckerStats = {}

</t>
<t tx="ekr.20220312061835.197">def __gt__(self, other):
    """Permit to sort a list of Checker by name."""
    return f"{self.name}{self.msgs}".__gt__(f"{other.name}{other.msgs}")

</t>
<t tx="ekr.20220312061835.198">def __repr__(self):
    status = "Checker" if self.enabled else "Disabled checker"
    msgs = "', '".join(self.msgs.keys())
    return f"{status} '{self.name}' (responsible for '{msgs}')"

</t>
<t tx="ekr.20220312061835.199">def __str__(self):
    """This might be incomplete because multiple class inheriting BaseChecker
    can have the same name. Cf MessageHandlerMixIn.get_full_documentation()"""
    return self.get_full_documentation(
        msgs=self.msgs, options=self.options_and_values(), reports=self.reports
    )

</t>
<t tx="ekr.20220312061835.2">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
import platform
import sys

import astroid

from pylint.__pkginfo__ import __version__

PY38_PLUS = sys.version_info[:2] &gt;= (3, 8)
PY39_PLUS = sys.version_info[:2] &gt;= (3, 9)
PY310_PLUS = sys.version_info[:2] &gt;= (3, 10)

IS_PYPY = platform.python_implementation() == "PyPy"

PY_EXTS = (".py", ".pyc", ".pyo", ".pyw", ".so", ".dll")

MSG_STATE_CONFIDENCE = 2
_MSG_ORDER = "EWRCIF"
MSG_STATE_SCOPE_CONFIG = 0
MSG_STATE_SCOPE_MODULE = 1

# The line/node distinction does not apply to fatal errors and reports.
_SCOPE_EXEMPT = "FR"

MSG_TYPES = {
    "I": "info",
    "C": "convention",
    "R": "refactor",
    "W": "warning",
    "E": "error",
    "F": "fatal",
}
MSG_TYPES_LONG = {v: k for k, v in MSG_TYPES.items()}

MSG_TYPES_STATUS = {"I": 0, "C": 16, "R": 8, "W": 4, "E": 2, "F": 1}

# You probably don't want to change the MAIN_CHECKER_NAME
# This would affect rcfile generation and retro-compatibility
# on all project using [MASTER] in their rcfile.
MAIN_CHECKER_NAME = "master"


@others
full_version = f"""pylint {__version__}
astroid {astroid.__version__}
Python {sys.version}"""
</t>
<t tx="ekr.20220312061835.20">def get_source(self):
    """returns self._source"""
    if self._source is None:
        self.emit("}\n")
        self._source = "\n".join(self.lines)
        del self.lines
    return self._source

</t>
<t tx="ekr.20220312061835.200">def get_full_documentation(self, msgs, options, reports, doc=None, module=None):
    result = ""
    checker_title = f"{self.name.replace('_', ' ').title()} checker"
    if module:
        # Provide anchor to link against
        result += f".. _{module}:\n\n"
    result += f"{get_rst_title(checker_title, '~')}\n"
    if module:
        result += f"This checker is provided by ``{module}``.\n"
    result += f"Verbatim name of the checker is ``{self.name}``.\n\n"
    if doc:
        # Provide anchor to link against
        result += get_rst_title(f"{checker_title} Documentation", "^")
        result += f"{cleandoc(doc)}\n\n"
    # options might be an empty generator and not be False when casted to boolean
    options = list(options)
    if options:
        result += get_rst_title(f"{checker_title} Options", "^")
        result += f"{get_rst_section(None, options)}\n"
    if msgs:
        result += get_rst_title(f"{checker_title} Messages", "^")
        for msgid, msg in sorted(
            msgs.items(), key=lambda kv: (_MSG_ORDER.index(kv[0][0]), kv[1])
        ):
            msg = self.create_message_definition_from_tuple(msgid, msg)
            result += f"{msg.format_help(checkerref=False)}\n"
        result += "\n"
    if reports:
        result += get_rst_title(f"{checker_title} Reports", "^")
        for report in reports:
            result += (
                ":%s: %s\n" % report[:2]  # pylint: disable=consider-using-f-string
            )
        result += "\n"
    result += "\n"
    return result

</t>
<t tx="ekr.20220312061835.201">def add_message(
    self, msgid, line=None, node=None, args=None, confidence=None, col_offset=None
):
    if not confidence:
        confidence = UNDEFINED
    self.linter.add_message(msgid, line, node, args, confidence, col_offset)

</t>
<t tx="ekr.20220312061835.202">def check_consistency(self):
    """Check the consistency of msgid.

    msg ids for a checker should be a string of len 4, where the two first
    characters are the checker id and the two last the msg id in this
    checker.

    :raises InvalidMessageError: If the checker id in the messages are not
    always the same."""
    checker_id = None
    existing_ids = []
    for message in self.messages:
        if checker_id is not None and checker_id != message.msgid[1:3]:
            error_msg = "Inconsistent checker part in message id "
            error_msg += f"'{message.msgid}' (expected 'x{checker_id}xx' "
            error_msg += f"because we already had {existing_ids})."
            raise InvalidMessageError(error_msg)
        checker_id = message.msgid[1:3]
        existing_ids.append(message.msgid)

</t>
<t tx="ekr.20220312061835.203">def create_message_definition_from_tuple(self, msgid, msg_tuple):
    if implements(self, (IRawChecker, ITokenChecker)):
        default_scope = WarningScope.LINE
    else:
        default_scope = WarningScope.NODE
    options = {}
    if len(msg_tuple) &gt; 3:
        (msg, symbol, descr, options) = msg_tuple
    elif len(msg_tuple) &gt; 2:
        (msg, symbol, descr) = msg_tuple
    else:
        error_msg = """Messages should have a msgid and a symbol. Something like this :

\\-4."W1234": (
"message",
"message-symbol",
"Message description with detail.",
...
\\-4.),
\\-4."""
        raise InvalidMessageError(error_msg)
    options.setdefault("scope", default_scope)
    return MessageDefinition(self, msgid, msg, descr, symbol, **options)

</t>
<t tx="ekr.20220312061835.204">@property
def messages(self) -&gt; list:
    return [
        self.create_message_definition_from_tuple(msgid, msg_tuple)
        for msgid, msg_tuple in sorted(self.msgs.items())
    ]

</t>
<t tx="ekr.20220312061835.205"># dummy methods implementing the IChecker interface

</t>
<t tx="ekr.20220312061835.206">def get_message_definition(self, msgid):
    for message_definition in self.messages:
        if message_definition.msgid == msgid:
            return message_definition
    error_msg = f"MessageDefinition for '{msgid}' does not exists. "
    error_msg += f"Choose from {[m.msgid for m in self.messages]}."
    raise InvalidMessageError(error_msg)

</t>
<t tx="ekr.20220312061835.207">def open(self):
    """called before visiting project (i.e set of modules)"""

</t>
<t tx="ekr.20220312061835.208">def close(self):
    """called after visiting project (i.e set of modules)"""


</t>
<t tx="ekr.20220312061835.209">class BaseTokenChecker(BaseChecker):
    """Base class for checkers that want to have access to the token stream."""

    def process_tokens(self, tokens):
        """Should be overridden by subclasses."""
        raise NotImplementedError()
</t>
<t tx="ekr.20220312061835.21">source = property(get_source)

</t>
<t tx="ekr.20220312061835.210">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2016 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2010 Maarten ter Huurne &lt;maarten@treewalker.org&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2014 David Pursehouse &lt;david.pursehouse@gmail.com&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2016 Anthony Foglia &lt;afoglia@users.noreply.github.com&gt;
# Copyright (c) 2016 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2017, 2019-2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018-2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Ben Green &lt;benhgreen@icloud.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 mattlbeck &lt;17108752+mattlbeck@users.noreply.github.com&gt;
# Copyright (c) 2019-2020 craig-sh &lt;craig-sh@users.noreply.github.com&gt;
# Copyright (c) 2019 Janne Rnkk &lt;jannero@users.noreply.github.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Grygorii Iermolenko &lt;gyermolenko@gmail.com&gt;
# Copyright (c) 2019 Andrzej Klajnert &lt;github@aklajnert.pl&gt;
# Copyright (c) 2019 Pascal Corpet &lt;pcorpet@users.noreply.github.com&gt;
# Copyright (c) 2020 GergelyKalmar &lt;gergely.kalmar@logikal.jp&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 yushao2 &lt;36848472+yushao2@users.noreply.github.com&gt;
# Copyright (c) 2021 SupImDos &lt;62866982+SupImDos@users.noreply.github.com&gt;
# Copyright (c) 2021 Kayran Schmidt &lt;59456929+yumasheta@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Yu Shao, Pang &lt;p.yushao2@gmail.com&gt;
# Copyright (c) 2021 Konstantina Saketou &lt;56515303+ksaketou@users.noreply.github.com&gt;
# Copyright (c) 2021 James Sinclair &lt;james@nurfherder.com&gt;
# Copyright (c) 2021 tiagohonorato &lt;61059243+tiagohonorato@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""classes checker for Python code
"""
import collections
from itertools import chain, zip_longest
from typing import List, Pattern

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, utils
from pylint.checkers.utils import (
    PYMETHODS,
    SPECIAL_METHODS_PARAMS,
    check_messages,
    class_is_abstract,
    decorated_with,
    decorated_with_property,
    has_known_bases,
    is_attr_private,
    is_attr_protected,
    is_builtin_object,
    is_comprehension,
    is_iterable,
    is_overload_stub,
    is_property_setter,
    is_property_setter_or_deleter,
    is_protocol_class,
    node_frame_class,
    overrides_a_method,
    safe_infer,
    unimplemented_abstract_methods,
)
from pylint.interfaces import IAstroidChecker
from pylint.utils import get_global_option

NEXT_METHOD = "__next__"
INVALID_BASE_CLASSES = {"bool", "range", "slice", "memoryview"}
BUILTIN_DECORATORS = {"builtins.property", "builtins.classmethod"}

# Dealing with useless override detection, with regard
# to parameters vs arguments

_CallSignature = collections.namedtuple(
    "_CallSignature", "args kws starred_args starred_kws"
)
_ParameterSignature = collections.namedtuple(
    "_ParameterSignature", "args kwonlyargs varargs kwargs"
)


@others
</t>
<t tx="ekr.20220312061835.211">def _signature_from_call(call):
    kws = {}
    args = []
    starred_kws = []
    starred_args = []
    for keyword in call.keywords or []:
        arg, value = keyword.arg, keyword.value
        if arg is None and isinstance(value, nodes.Name):
            # Starred node and we are interested only in names,
            # otherwise some transformation might occur for the parameter.
            starred_kws.append(value.name)
        elif isinstance(value, nodes.Name):
            kws[arg] = value.name
        else:
            kws[arg] = None

    for arg in call.args:
        if isinstance(arg, nodes.Starred) and isinstance(arg.value, nodes.Name):
            # Positional variadic and a name, otherwise some transformation
            # might have occurred.
            starred_args.append(arg.value.name)
        elif isinstance(arg, nodes.Name):
            args.append(arg.name)
        else:
            args.append(None)

    return _CallSignature(args, kws, starred_args, starred_kws)


</t>
<t tx="ekr.20220312061835.212">def _signature_from_arguments(arguments):
    kwarg = arguments.kwarg
    vararg = arguments.vararg
    args = [
        arg.name
        for arg in chain(arguments.posonlyargs, arguments.args)
        if arg.name != "self"
    ]
    kwonlyargs = [arg.name for arg in arguments.kwonlyargs]
    return _ParameterSignature(args, kwonlyargs, vararg, kwarg)


</t>
<t tx="ekr.20220312061835.213">def _definition_equivalent_to_call(definition, call):
    """Check if a definition signature is equivalent to a call."""
    if definition.kwargs:
        same_kw_variadics = definition.kwargs in call.starred_kws
    else:
        same_kw_variadics = not call.starred_kws
    if definition.varargs:
        same_args_variadics = definition.varargs in call.starred_args
    else:
        same_args_variadics = not call.starred_args
    same_kwonlyargs = all(kw in call.kws for kw in definition.kwonlyargs)
    same_args = definition.args == call.args

    no_additional_kwarg_arguments = True
    if call.kws:
        for keyword in call.kws:
            is_arg = keyword in call.args
            is_kwonly = keyword in definition.kwonlyargs
            if not is_arg and not is_kwonly:
                # Maybe this argument goes into **kwargs,
                # or it is an extraneous argument.
                # In any case, the signature is different than
                # the call site, which stops our search.
                no_additional_kwarg_arguments = False
                break

    return all(
        (
            same_args,
            same_kwonlyargs,
            same_args_variadics,
            same_kw_variadics,
            no_additional_kwarg_arguments,
        )
    )


</t>
<t tx="ekr.20220312061835.214"># Deal with parameters overridding in two methods.


</t>
<t tx="ekr.20220312061835.215">def _positional_parameters(method):
    positional = method.args.args
    if method.type in ("classmethod", "method"):
        positional = positional[1:]
    return positional


</t>
<t tx="ekr.20220312061835.216">def _get_node_type(node, potential_types):
    """
    Return the type of the node if it exists in potential_types.

    Args:
        node (astroid.node): node to get the type of.
        potential_types (tuple): potential types of the node.

    Returns:
        type: type of the node or None.
    """
    for potential_type in potential_types:
        if isinstance(node, potential_type):
            return potential_type
    return None


</t>
<t tx="ekr.20220312061835.217">def _check_arg_equality(node_a, node_b, attr_name):
    """
    Check equality of nodes based on the comparison of their attributes named attr_name.

    Args:
        node_a (astroid.node): first node to compare.
        node_b (astroid.node): second node to compare.
        attr_name (str): name of the nodes attribute to use for comparison.

    Returns:
        bool: True if node_a.attr_name == node_b.attr_name, False otherwise.
    """
    return getattr(node_a, attr_name) == getattr(node_b, attr_name)


</t>
<t tx="ekr.20220312061835.218">def _has_different_parameters_default_value(original, overridden):
    """
    Check if original and overridden methods arguments have different default values

    Return True if one of the overridden arguments has a default
    value different from the default value of the original argument
    If one of the method doesn't have argument (.args is None)
    return False
    """
    if original.args is None or overridden.args is None:
        return False

    all_args = chain(original.args, original.kwonlyargs)
    original_param_names = [param.name for param in all_args]
    default_missing = object()
    for param_name in original_param_names:
        try:
            original_default = original.default_value(param_name)
        except astroid.exceptions.NoDefault:
            original_default = default_missing
        try:
            overridden_default = overridden.default_value(param_name)
        except astroid.exceptions.NoDefault:
            overridden_default = default_missing

        default_list = [
            arg == default_missing for arg in (original_default, overridden_default)
        ]
        if any(default_list) and not all(default_list):
            # Only one arg has no default value
            return True

        astroid_type_compared_attr = {
            nodes.Const: "value",
            nodes.ClassDef: "name",
            nodes.Tuple: "elts",
            nodes.List: "elts",
            nodes.Dict: "items",
        }
        handled_types = tuple(
            astroid_type for astroid_type in astroid_type_compared_attr
        )
        original_type = _get_node_type(original_default, handled_types)
        if original_type:
            # We handle only astroid types that are inside the dict astroid_type_compared_attr
            if not isinstance(overridden_default, original_type):
                # Two args with same name but different types
                return True
            if not _check_arg_equality(
                original_default,
                overridden_default,
                astroid_type_compared_attr[original_type],
            ):
                # Two args with same type but different values
                return True
    return False


</t>
<t tx="ekr.20220312061835.219">def _has_different_parameters(
    original: List[nodes.AssignName],
    overridden: List[nodes.AssignName],
    dummy_parameter_regex: Pattern,
) -&gt; List[str]:
    result = []
    zipped = zip_longest(original, overridden)
    for original_param, overridden_param in zipped:
        params = (original_param, overridden_param)
        if not all(params):
            return ["Number of parameters "]

        # check for the arguments' name
        names = [param.name for param in params]
        if any(dummy_parameter_regex.match(name) for name in names):
            continue
        if original_param.name != overridden_param.name:
            result.append(
                f"Parameter '{original_param.name}' has been renamed "
                f"to '{overridden_param.name}' in"
            )

    return result


</t>
<t tx="ekr.20220312061835.22">def generate(self, outputfile: str = None, mapfile: str = None) -&gt; str:
    """Generates a graph file.

    :param str outputfile: filename and path [defaults to graphname.png]
    :param str mapfile: filename and path

    :rtype: str
    :return: a path to the generated file
    :raises RuntimeError: if the executable for rendering was not found
    """
    graphviz_extensions = ("dot", "gv")
    name = self.graphname
    if outputfile is None:
        target = "png"
        pdot, dot_sourcepath = tempfile.mkstemp(".gv", name)
        ppng, outputfile = tempfile.mkstemp(".png", name)
        os.close(pdot)
        os.close(ppng)
    else:
        _, _, target = target_info_from_filename(outputfile)
        if not target:
            target = "png"
            outputfile = outputfile + "." + target
        if target not in graphviz_extensions:
            pdot, dot_sourcepath = tempfile.mkstemp(".gv", name)
            os.close(pdot)
        else:
            dot_sourcepath = outputfile
    with codecs.open(dot_sourcepath, "w", encoding="utf8") as file:
        file.write(self.source)
    if target not in graphviz_extensions:
        if shutil.which(self.renderer) is None:
            raise RuntimeError(
                f"Cannot generate `{outputfile}` because '{self.renderer}' "
                "executable not found. Install graphviz, or specify a `.gv` "
                "outputfile to produce the DOT source code."
            )
        use_shell = sys.platform == "win32"
        if mapfile:
            subprocess.call(
                [
                    self.renderer,
                    "-Tcmapx",
                    "-o",
                    mapfile,
                    "-T",
                    target,
                    dot_sourcepath,
                    "-o",
                    outputfile,
                ],
                shell=use_shell,
            )
        else:
            subprocess.call(
                [self.renderer, "-T", target, dot_sourcepath, "-o", outputfile],
                shell=use_shell,
            )
        os.unlink(dot_sourcepath)
    return outputfile

</t>
<t tx="ekr.20220312061835.220">def _different_parameters(
    original: nodes.FunctionDef,
    overridden: nodes.FunctionDef,
    dummy_parameter_regex: Pattern,
) -&gt; List[str]:
    """Determine if the two methods have different parameters

    They are considered to have different parameters if:

       * they have different positional parameters, including different names

       * one of the methods is having variadics, while the other is not

       * they have different keyword only parameters.

    """
    output_messages = []
    original_parameters = _positional_parameters(original)
    overridden_parameters = _positional_parameters(overridden)

    # Copy kwonlyargs list so that we don't affect later function linting
    original_kwonlyargs = original.args.kwonlyargs

    # Allow positional/keyword variadic in overridden to match against any
    # positional/keyword argument in original.
    # Keep any arguments that are found seperately in overridden to satisfy
    # later tests
    if overridden.args.vararg:
        overidden_names = [v.name for v in overridden_parameters]
        original_parameters = [
            v for v in original_parameters if v.name in overidden_names
        ]

    if overridden.args.kwarg:
        overidden_names = [v.name for v in overridden.args.kwonlyargs]
        original_kwonlyargs = [
            v for v in original.args.kwonlyargs if v.name in overidden_names
        ]

    different_positional = _has_different_parameters(
        original_parameters, overridden_parameters, dummy_parameter_regex
    )
    different_kwonly = _has_different_parameters(
        original_kwonlyargs, overridden.args.kwonlyargs, dummy_parameter_regex
    )
    if different_kwonly and different_positional:
        if "Number " in different_positional[0] and "Number " in different_kwonly[0]:
            output_messages.append("Number of parameters ")
            output_messages += different_positional[1:]
            output_messages += different_kwonly[1:]
        else:
            output_messages += different_positional
            output_messages += different_kwonly
    else:
        if different_positional:
            output_messages += different_positional
        if different_kwonly:
            output_messages += different_kwonly

    if original.name in PYMETHODS:
        # Ignore the difference for special methods. If the parameter
        # numbers are different, then that is going to be caught by
        # unexpected-special-method-signature.
        # If the names are different, it doesn't matter, since they can't
        # be used as keyword arguments anyway.
        output_messages.clear()

    # Arguments will only violate LSP if there are variadics in the original
    # that are then removed from the overridden
    kwarg_lost = original.args.kwarg and not overridden.args.kwarg
    vararg_lost = original.args.vararg and not overridden.args.vararg

    if kwarg_lost or vararg_lost:
        output_messages += ["Variadics removed in"]

    return output_messages


</t>
<t tx="ekr.20220312061835.221">def _is_invalid_base_class(cls):
    return cls.name in INVALID_BASE_CLASSES and is_builtin_object(cls)


</t>
<t tx="ekr.20220312061835.222">def _has_data_descriptor(cls, attr):
    attributes = cls.getattr(attr)
    for attribute in attributes:
        try:
            for inferred in attribute.infer():
                if isinstance(inferred, astroid.Instance):
                    try:
                        inferred.getattr("__get__")
                        inferred.getattr("__set__")
                    except astroid.NotFoundError:
                        continue
                    else:
                        return True
        except astroid.InferenceError:
            # Can't infer, avoid emitting a false positive in this case.
            return True
    return False


</t>
<t tx="ekr.20220312061835.223">def _called_in_methods(func, klass, methods):
    """Check if the func was called in any of the given methods,
    belonging to the *klass*. Returns True if so, False otherwise.
    """
    if not isinstance(func, nodes.FunctionDef):
        return False
    for method in methods:
        try:
            inferred = klass.getattr(method)
        except astroid.NotFoundError:
            continue
        for infer_method in inferred:
            for call in infer_method.nodes_of_class(nodes.Call):
                try:
                    bound = next(call.func.infer())
                except (astroid.InferenceError, StopIteration):
                    continue
                if not isinstance(bound, astroid.BoundMethod):
                    continue
                func_obj = bound._proxied
                if isinstance(func_obj, astroid.UnboundMethod):
                    func_obj = func_obj._proxied
                if func_obj.name == func.name:
                    return True
    return False


</t>
<t tx="ekr.20220312061835.224">def _is_attribute_property(name, klass):
    """Check if the given attribute *name* is a property in the given *klass*.

    It will look for `property` calls or for functions
    with the given name, decorated by `property` or `property`
    subclasses.
    Returns ``True`` if the name is a property in the given klass,
    ``False`` otherwise.
    """

    try:
        attributes = klass.getattr(name)
    except astroid.NotFoundError:
        return False
    property_name = "builtins.property"
    for attr in attributes:
        if attr is astroid.Uninferable:
            continue
        try:
            inferred = next(attr.infer())
        except astroid.InferenceError:
            continue
        if isinstance(inferred, nodes.FunctionDef) and decorated_with_property(
            inferred
        ):
            return True
        if inferred.pytype() != property_name:
            continue

        cls = node_frame_class(inferred)
        if cls == klass.declared_metaclass():
            continue
        return True
    return False


</t>
<t tx="ekr.20220312061835.225">def _has_bare_super_call(fundef_node):
    for call in fundef_node.nodes_of_class(nodes.Call):
        func = call.func
        if isinstance(func, nodes.Name) and func.name == "super" and not call.args:
            return True
    return False


</t>
<t tx="ekr.20220312061835.226">def _safe_infer_call_result(node, caller, context=None):
    """
    Safely infer the return value of a function.

    Returns None if inference failed or if there is some ambiguity (more than
    one node has been inferred). Otherwise returns inferred value.
    """
    try:
        inferit = node.infer_call_result(caller, context=context)
        value = next(inferit)
    except astroid.InferenceError:
        return None  # inference failed
    except StopIteration:
        return None  # no values inferred
    try:
        next(inferit)
        return None  # there is ambiguity on the inferred node
    except astroid.InferenceError:
        return None  # there is some kind of ambiguity
    except StopIteration:
        return value


</t>
<t tx="ekr.20220312061835.227">def _has_same_layout_slots(slots, assigned_value):
    inferred = next(assigned_value.infer())
    if isinstance(inferred, nodes.ClassDef):
        other_slots = inferred.slots()
        if all(
            first_slot and second_slot and first_slot.value == second_slot.value
            for (first_slot, second_slot) in zip_longest(slots, other_slots)
        ):
            return True
    return False


</t>
<t tx="ekr.20220312061835.228">MSGS = {  # pylint: disable=consider-using-namedtuple-or-dataclass
    "F0202": (
        "Unable to check methods signature (%s / %s)",
        "method-check-failed",
        "Used when Pylint has been unable to check methods signature "
        "compatibility for an unexpected reason. Please report this kind "
        "if you don't make sense of it.",
    ),
    "E0202": (
        "An attribute defined in %s line %s hides this method",
        "method-hidden",
        "Used when a class defines a method which is hidden by an "
        "instance attribute from an ancestor class or set by some "
        "client code.",
    ),
    "E0203": (
        "Access to member %r before its definition line %s",
        "access-member-before-definition",
        "Used when an instance member is accessed before it's actually assigned.",
    ),
    "W0201": (
        "Attribute %r defined outside __init__",
        "attribute-defined-outside-init",
        "Used when an instance attribute is defined outside the __init__ method.",
    ),
    "W0212": (
        "Access to a protected member %s of a client class",  # E0214
        "protected-access",
        "Used when a protected member (i.e. class member with a name "
        "beginning with an underscore) is access outside the class or a "
        "descendant of the class where it's defined.",
    ),
    "E0211": (
        "Method has no argument",
        "no-method-argument",
        "Used when a method which should have the bound instance as "
        "first argument has no argument defined.",
    ),
    "E0213": (
        'Method should have "self" as first argument',
        "no-self-argument",
        'Used when a method has an attribute different the "self" as '
        "first argument. This is considered as an error since this is "
        "a so common convention that you shouldn't break it!",
    ),
    "C0202": (
        "Class method %s should have %s as first argument",
        "bad-classmethod-argument",
        "Used when a class method has a first argument named differently "
        "than the value specified in valid-classmethod-first-arg option "
        '(default to "cls"), recommended to easily differentiate them '
        "from regular instance methods.",
    ),
    "C0203": (
        "Metaclass method %s should have %s as first argument",
        "bad-mcs-method-argument",
        "Used when a metaclass method has a first argument named "
        "differently than the value specified in valid-classmethod-first"
        '-arg option (default to "cls"), recommended to easily '
        "differentiate them from regular instance methods.",
    ),
    "C0204": (
        "Metaclass class method %s should have %s as first argument",
        "bad-mcs-classmethod-argument",
        "Used when a metaclass class method has a first argument named "
        "differently than the value specified in valid-metaclass-"
        'classmethod-first-arg option (default to "mcs"), recommended to '
        "easily differentiate them from regular instance methods.",
    ),
    "W0211": (
        "Static method with %r as first argument",
        "bad-staticmethod-argument",
        'Used when a static method has "self" or a value specified in '
        "valid-classmethod-first-arg option or "
        "valid-metaclass-classmethod-first-arg option as first argument.",
    ),
    "R0201": (
        "Method could be a function",
        "no-self-use",
        "Used when a method doesn't use its bound instance, and so could "
        "be written as a function.",
    ),
    "W0221": (
        "%s %s %r method",
        "arguments-differ",
        "Used when a method has a different number of arguments than in "
        "the implemented interface or in an overridden method.",
    ),
    "W0222": (
        "Signature differs from %s %r method",
        "signature-differs",
        "Used when a method signature is different than in the "
        "implemented interface or in an overridden method.",
    ),
    "W0223": (
        "Method %r is abstract in class %r but is not overridden",
        "abstract-method",
        "Used when an abstract method (i.e. raise NotImplementedError) is "
        "not overridden in concrete class.",
    ),
    "W0231": (
        "__init__ method from base class %r is not called",
        "super-init-not-called",
        "Used when an ancestor class method has an __init__ method "
        "which is not called by a derived class.",
    ),
    "W0232": (
        "Class has no __init__ method",
        "no-init",
        "Used when a class has no __init__ method, neither its parent classes.",
    ),
    "W0233": (
        "__init__ method from a non direct base class %r is called",
        "non-parent-init-called",
        "Used when an __init__ method is called on a class which is not "
        "in the direct ancestors for the analysed class.",
    ),
    "W0235": (
        "Useless super delegation in method %r",
        "useless-super-delegation",
        "Used whenever we can detect that an overridden method is useless, "
        "relying on super() delegation to do the same thing as another method "
        "from the MRO.",
    ),
    "W0236": (
        "Method %r was expected to be %r, found it instead as %r",
        "invalid-overridden-method",
        "Used when we detect that a method was overridden in a way "
        "that does not match its base class "
        "which could result in potential bugs at runtime.",
    ),
    "W0237": (
        "%s %s %r method",
        "arguments-renamed",
        "Used when a method parameter has a different name than in "
        "the implemented interface or in an overridden method.",
    ),
    "W0238": (
        "Unused private member `%s.%s`",
        "unused-private-member",
        "Emitted when a private member of a class is defined but not used.",
    ),
    "E0236": (
        "Invalid object %r in __slots__, must contain only non empty strings",
        "invalid-slots-object",
        "Used when an invalid (non-string) object occurs in __slots__.",
    ),
    "E0237": (
        "Assigning to attribute %r not defined in class slots",
        "assigning-non-slot",
        "Used when assigning to an attribute not defined in the class slots.",
    ),
    "E0238": (
        "Invalid __slots__ object",
        "invalid-slots",
        "Used when an invalid __slots__ is found in class. "
        "Only a string, an iterable or a sequence is permitted.",
    ),
    "E0239": (
        "Inheriting %r, which is not a class.",
        "inherit-non-class",
        "Used when a class inherits from something which is not a class.",
    ),
    "E0240": (
        "Inconsistent method resolution order for class %r",
        "inconsistent-mro",
        "Used when a class has an inconsistent method resolution order.",
    ),
    "E0241": (
        "Duplicate bases for class %r",
        "duplicate-bases",
        "Used when a class has duplicate bases.",
    ),
    "E0242": (
        "Value %r in slots conflicts with class variable",
        "class-variable-slots-conflict",
        "Used when a value in __slots__ conflicts with a class variable, property or method.",
    ),
    "E0243": (
        "Invalid __class__ object",
        "invalid-class-object",
        "Used when an invalid object is assigned to a __class__ property. "
        "Only a class is permitted.",
    ),
    "R0202": (
        "Consider using a decorator instead of calling classmethod",
        "no-classmethod-decorator",
        "Used when a class method is defined without using the decorator syntax.",
    ),
    "R0203": (
        "Consider using a decorator instead of calling staticmethod",
        "no-staticmethod-decorator",
        "Used when a static method is defined without using the decorator syntax.",
    ),
    "C0205": (
        "Class __slots__ should be a non-string iterable",
        "single-string-used-for-slots",
        "Used when a class __slots__ is a simple string, rather than an iterable.",
    ),
    "R0205": (
        "Class %r inherits from object, can be safely removed from bases in python3",
        "useless-object-inheritance",
        "Used when a class inherit from object, which under python3 is implicit, "
        "hence can be safely removed from bases.",
    ),
    "R0206": (
        "Cannot have defined parameters for properties",
        "property-with-parameters",
        "Used when we detect that a property also has parameters, which are useless, "
        "given that properties cannot be called with additional arguments.",
    ),
}


</t>
<t tx="ekr.20220312061835.229">def _scope_default():
    return collections.defaultdict(list)


</t>
<t tx="ekr.20220312061835.23">def emit(self, line):
    """Adds &lt;line&gt; to final output."""
    self.lines.append(line)

</t>
<t tx="ekr.20220312061835.230">class ScopeAccessMap:
    """Store the accessed variables per scope."""

    @others
</t>
<t tx="ekr.20220312061835.231">def __init__(self):
    self._scopes = collections.defaultdict(_scope_default)

</t>
<t tx="ekr.20220312061835.232">def set_accessed(self, node):
    """Set the given node as accessed."""

    frame = node_frame_class(node)
    if frame is None:
        # The node does not live in a class.
        return
    self._scopes[frame][node.attrname].append(node)

</t>
<t tx="ekr.20220312061835.233">def accessed(self, scope):
    """Get the accessed variables for the given scope."""
    return self._scopes.get(scope, {})


</t>
<t tx="ekr.20220312061835.234">class ClassChecker(BaseChecker):
    """checks for :
    * methods without self as first argument
    * overridden methods signature
    * access only to existent members via self
    * attributes not defined in the __init__ method
    * unreachable code
    """

    __implements__ = (IAstroidChecker,)

    # configuration section name
    name = "classes"
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = (
        (
            "defining-attr-methods",
            {
                "default": ("__init__", "__new__", "setUp", "__post_init__"),
                "type": "csv",
                "metavar": "&lt;method names&gt;",
                "help": "List of method names used to declare (i.e. assign) \
instance attributes.",
            },
        ),
        (
            "valid-classmethod-first-arg",
            {
                "default": ("cls",),
                "type": "csv",
                "metavar": "&lt;argument names&gt;",
                "help": "List of valid names for the first argument in \
a class method.",
            },
        ),
        (
            "valid-metaclass-classmethod-first-arg",
            {
                "default": ("cls",),
                "type": "csv",
                "metavar": "&lt;argument names&gt;",
                "help": "List of valid names for the first argument in \
a metaclass class method.",
            },
        ),
        (
            "exclude-protected",
            {
                "default": (
                    # namedtuple public API.
                    "_asdict",
                    "_fields",
                    "_replace",
                    "_source",
                    "_make",
                ),
                "type": "csv",
                "metavar": "&lt;protected access exclusions&gt;",
                "help": (
                    "List of member names, which should be excluded "
                    "from the protected access warning."
                ),
            },
        ),
        (
            "check-protected-access-in-special-methods",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Warn about protected attribute access inside special methods",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.235">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self._accessed = ScopeAccessMap()
    self._first_attrs = []
    self._meth_could_be_func = None

</t>
<t tx="ekr.20220312061835.236">@astroid.decorators.cachedproperty
def _dummy_rgx(self):
    return get_global_option(self, "dummy-variables-rgx", default=None)

</t>
<t tx="ekr.20220312061835.237">@astroid.decorators.cachedproperty
def _ignore_mixin(self):
    return get_global_option(self, "ignore-mixin-members", default=True)

</t>
<t tx="ekr.20220312061835.238">@check_messages(
    "abstract-method",
    "no-init",
    "invalid-slots",
    "single-string-used-for-slots",
    "invalid-slots-object",
    "class-variable-slots-conflict",
    "inherit-non-class",
    "useless-object-inheritance",
    "inconsistent-mro",
    "duplicate-bases",
)
</t>
<t tx="ekr.20220312061835.239">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    """init visit variable _accessed"""
    self._check_bases_classes(node)
    # if not an exception or a metaclass
    if node.type == "class" and has_known_bases(node):
        try:
            node.local_attr("__init__")
        except astroid.NotFoundError:
            self.add_message("no-init", args=node, node=node)
    self._check_slots(node)
    self._check_proper_bases(node)
    self._check_consistent_mro(node)

</t>
<t tx="ekr.20220312061835.24">def emit_edge(self, name1, name2, **props):
    """emit an edge from &lt;name1&gt; to &lt;name2&gt;.
    edge properties: see https://www.graphviz.org/doc/info/attrs.html
    """
    attrs = [f'{prop}="{value}"' for prop, value in props.items()]
    n_from, n_to = normalize_node_id(name1), normalize_node_id(name2)
    self.emit(f"{n_from} -&gt; {n_to} [{', '.join(sorted(attrs))}];")

</t>
<t tx="ekr.20220312061835.240">def _check_consistent_mro(self, node):
    """Detect that a class has a consistent mro or duplicate bases."""
    try:
        node.mro()
    except astroid.InconsistentMroError:
        self.add_message("inconsistent-mro", args=node.name, node=node)
    except astroid.DuplicateBasesError:
        self.add_message("duplicate-bases", args=node.name, node=node)
    except NotImplementedError:
        # Old style class, there's no mro so don't do anything.
        pass

</t>
<t tx="ekr.20220312061835.241">def _check_proper_bases(self, node):
    """
    Detect that a class inherits something which is not
    a class or a type.
    """
    for base in node.bases:
        ancestor = safe_infer(base)
        if not ancestor:
            continue
        if isinstance(ancestor, astroid.Instance) and ancestor.is_subtype_of(
            "builtins.type"
        ):
            continue

        if not isinstance(ancestor, nodes.ClassDef) or _is_invalid_base_class(
            ancestor
        ):
            self.add_message("inherit-non-class", args=base.as_string(), node=node)

        if ancestor.name == object.__name__:
            self.add_message(
                "useless-object-inheritance", args=node.name, node=node
            )

</t>
<t tx="ekr.20220312061835.242">@check_messages("unused-private-member", "attribute-defined-outside-init")
def leave_classdef(self, node: nodes.ClassDef) -&gt; None:
    """close a class node:
    check that instance attributes are defined in __init__ and check
    access to existent members
    """
    self._check_unused_private_functions(node)
    self._check_unused_private_variables(node)
    self._check_unused_private_attributes(node)
    self._check_attribute_defined_outside_init(node)

</t>
<t tx="ekr.20220312061835.243">def _check_unused_private_functions(self, node: nodes.ClassDef) -&gt; None:
    for function_def in node.nodes_of_class(nodes.FunctionDef):
        if not is_attr_private(function_def.name):
            continue
        parent_scope = function_def.parent.scope()
        if isinstance(parent_scope, nodes.FunctionDef):
            # Handle nested functions
            if function_def.name in (
                n.name for n in parent_scope.nodes_of_class(nodes.Name)
            ):
                continue
        for attribute in node.nodes_of_class(nodes.Attribute):
            if (
                attribute.attrname != function_def.name
                or attribute.scope() == function_def  # We ignore recursive calls
            ):
                continue
            if isinstance(attribute.expr, nodes.Name) and attribute.expr.name in (
                "self",
                "cls",
                node.name,
            ):
                # self.__attrname
                # cls.__attrname
                # node_name.__attrname
                break
            if isinstance(attribute.expr, nodes.Call):
                # type(self).__attrname
                inferred = safe_infer(attribute.expr)
                if (
                    isinstance(inferred, nodes.ClassDef)
                    and inferred.name == node.name
                ):
                    break
        else:
            name_stack = []
            curr = parent_scope
            # Generate proper names for nested functions
            while curr != node:
                name_stack.append(curr.name)
                curr = curr.parent.scope()

            outer_level_names = f"{'.'.join(reversed(name_stack))}"
            function_repr = f"{outer_level_names}.{function_def.name}({function_def.args.as_string()})"
            self.add_message(
                "unused-private-member",
                node=function_def,
                args=(node.name, function_repr.lstrip(".")),
            )

</t>
<t tx="ekr.20220312061835.244">def _check_unused_private_variables(self, node: nodes.ClassDef) -&gt; None:
    for assign_name in node.nodes_of_class(nodes.AssignName):
        if isinstance(assign_name.parent, nodes.Arguments):
            continue  # Ignore function arguments
        if not is_attr_private(assign_name.name):
            continue
        for child in node.nodes_of_class((nodes.Name, nodes.Attribute)):
            if isinstance(child, nodes.Name) and child.name == assign_name.name:
                break
            if (
                isinstance(child, nodes.Attribute)
                and child.attrname == assign_name.name
                and child.expr.name in ("self", "cls", node.name)
            ):
                break
        else:
            args = (node.name, assign_name.name)
            self.add_message("unused-private-member", node=assign_name, args=args)

</t>
<t tx="ekr.20220312061835.245">def _check_unused_private_attributes(self, node: nodes.ClassDef) -&gt; None:
    for assign_attr in node.nodes_of_class(nodes.AssignAttr):
        if not is_attr_private(assign_attr.attrname) or not isinstance(
            assign_attr.expr, nodes.Name
        ):
            continue

        # Logic for checking false positive when using __new__,
        # Get the returned object names of the __new__ magic function
        # Then check if the attribute was consumed in other instance methods
        acceptable_obj_names: List[str] = ["self"]
        scope = assign_attr.scope()
        if isinstance(scope, nodes.FunctionDef) and scope.name == "__new__":
            acceptable_obj_names.extend(
                [
                    return_node.value.name
                    for return_node in scope.nodes_of_class(nodes.Return)
                    if isinstance(return_node.value, nodes.Name)
                ]
            )

        for attribute in node.nodes_of_class(nodes.Attribute):
            if attribute.attrname != assign_attr.attrname:
                continue

            if (
                assign_attr.expr.name
                in [
                    "cls",
                    node.name,
                ]
                and attribute.expr.name in ["cls", "self", node.name]
            ):
                # If assigned to cls or class name, can be accessed by cls/self/class name
                break

            if (
                assign_attr.expr.name in acceptable_obj_names
                and attribute.expr.name == "self"
            ):
                # If assigned to self.attrib, can only be accessed by self
                # Or if __new__ was used, the returned object names are acceptable
                break

            if assign_attr.expr.name == attribute.expr.name == node.name:
                # Recognise attributes which are accessed via the class name
                break

        else:
            args = (node.name, assign_attr.attrname)
            self.add_message("unused-private-member", node=assign_attr, args=args)

</t>
<t tx="ekr.20220312061835.246">def _check_attribute_defined_outside_init(self, cnode: nodes.ClassDef) -&gt; None:
    # check access to existent members on non metaclass classes
    if self._ignore_mixin and cnode.name[-5:].lower() == "mixin":
        # We are in a mixin class. No need to try to figure out if
        # something is missing, since it is most likely that it will
        # miss.
        return

    accessed = self._accessed.accessed(cnode)
    if cnode.type != "metaclass":
        self._check_accessed_members(cnode, accessed)
    # checks attributes are defined in an allowed method such as __init__
    if not self.linter.is_message_enabled("attribute-defined-outside-init"):
        return
    defining_methods = self.config.defining_attr_methods
    current_module = cnode.root()
    for attr, nodes_lst in cnode.instance_attrs.items():
        # Exclude `__dict__` as it is already defined.
        if attr == "__dict__":
            continue

        # Skip nodes which are not in the current module and it may screw up
        # the output, while it's not worth it
        nodes_lst = [
            n
            for n in nodes_lst
            if not isinstance(n.statement(), (nodes.Delete, nodes.AugAssign))
            and n.root() is current_module
        ]
        if not nodes_lst:
            continue  # error detected by typechecking

        # Check if any method attr is defined in is a defining method
        # or if we have the attribute defined in a setter.
        frames = (node.frame() for node in nodes_lst)
        if any(
            frame.name in defining_methods or is_property_setter(frame)
            for frame in frames
        ):
            continue

        # check attribute is defined in a parent's __init__
        for parent in cnode.instance_attr_ancestors(attr):
            attr_defined = False
            # check if any parent method attr is defined in is a defining method
            for node in parent.instance_attrs[attr]:
                if node.frame().name in defining_methods:
                    attr_defined = True
            if attr_defined:
                # we're done :)
                break
        else:
            # check attribute is defined as a class attribute
            try:
                cnode.local_attr(attr)
            except astroid.NotFoundError:
                for node in nodes_lst:
                    if node.frame().name not in defining_methods:
                        # If the attribute was set by a call in any
                        # of the defining methods, then don't emit
                        # the warning.
                        if _called_in_methods(
                            node.frame(), cnode, defining_methods
                        ):
                            continue
                        self.add_message(
                            "attribute-defined-outside-init", args=attr, node=node
                        )

</t>
<t tx="ekr.20220312061835.247">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """check method arguments, overriding"""
    # ignore actual functions
    if not node.is_method():
        return

    self._check_useless_super_delegation(node)
    self._check_property_with_parameters(node)

    klass = node.parent.frame()
    self._meth_could_be_func = True
    # check first argument is self if this is actually a method
    self._check_first_arg_for_type(node, klass.type == "metaclass")
    if node.name == "__init__":
        self._check_init(node)
        return
    # check signature if the method overloads inherited method
    for overridden in klass.local_attr_ancestors(node.name):
        # get astroid for the searched method
        try:
            parent_function = overridden[node.name]
        except KeyError:
            # we have found the method but it's not in the local
            # dictionary.
            # This may happen with astroid build from living objects
            continue
        if not isinstance(parent_function, nodes.FunctionDef):
            continue
        self._check_signature(node, parent_function, "overridden", klass)
        self._check_invalid_overridden_method(node, parent_function)
        break

    if node.decorators:
        for decorator in node.decorators.nodes:
            if isinstance(decorator, nodes.Attribute) and decorator.attrname in (
                "getter",
                "setter",
                "deleter",
            ):
                # attribute affectation will call this method, not hiding it
                return
            if isinstance(decorator, nodes.Name):
                if decorator.name == "property":
                    # attribute affectation will either call a setter or raise
                    # an attribute error, anyway not hiding the function
                    return

            # Infer the decorator and see if it returns something useful
            inferred = safe_infer(decorator)
            if not inferred:
                return
            if isinstance(inferred, nodes.FunctionDef):
                # Okay, it's a decorator, let's see what it can infer.
                try:
                    inferred = next(inferred.infer_call_result(inferred))
                except astroid.InferenceError:
                    return
            try:
                if (
                    isinstance(inferred, (astroid.Instance, nodes.ClassDef))
                    and inferred.getattr("__get__")
                    and inferred.getattr("__set__")
                ):
                    return
            except astroid.AttributeInferenceError:
                pass

    # check if the method is hidden by an attribute
    try:
        overridden = klass.instance_attr(node.name)[0]
        overridden_frame = overridden.frame()
        if (
            isinstance(overridden_frame, nodes.FunctionDef)
            and overridden_frame.type == "method"
        ):
            overridden_frame = overridden_frame.parent.frame()
        if not (
            isinstance(overridden_frame, nodes.ClassDef)
            and klass.is_subtype_of(overridden_frame.qname())
        ):
            return

        # If a subclass defined the method then it's not our fault.
        for ancestor in klass.ancestors():
            if node.name in ancestor.instance_attrs and is_attr_private(node.name):
                return
            for obj in ancestor.lookup(node.name)[1]:
                if isinstance(obj, nodes.FunctionDef):
                    return
        args = (overridden.root().name, overridden.fromlineno)
        self.add_message("method-hidden", args=args, node=node)
    except astroid.NotFoundError:
        pass

</t>
<t tx="ekr.20220312061835.248">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.249">def _check_useless_super_delegation(self, function):
    """Check if the given function node is an useless method override

    We consider it *useless* if it uses the super() builtin, but having
    nothing additional whatsoever than not implementing the method at all.
    If the method uses super() to delegate an operation to the rest of the MRO,
    and if the method called is the same as the current one, the arguments
    passed to super() are the same as the parameters that were passed to
    this method, then the method could be removed altogether, by letting
    other implementation to take precedence.
    """

    if (
        not function.is_method()
        # With decorators is a change of use
        or function.decorators
    ):
        return

    body = function.body
    if len(body) != 1:
        # Multiple statements, which means this overridden method
        # could do multiple things we are not aware of.
        return

    statement = body[0]
    if not isinstance(statement, (nodes.Expr, nodes.Return)):
        # Doing something else than what we are interested into.
        return

    call = statement.value
    if (
        not isinstance(call, nodes.Call)
        # Not a super() attribute access.
        or not isinstance(call.func, nodes.Attribute)
    ):
        return

    # Should be a super call.
    try:
        super_call = next(call.func.expr.infer())
    except astroid.InferenceError:
        return
    else:
        if not isinstance(super_call, astroid.objects.Super):
            return

    # The name should be the same.
    if call.func.attrname != function.name:
        return

    # Should be a super call with the MRO pointer being the
    # current class and the type being the current instance.
    current_scope = function.parent.scope()
    if (
        super_call.mro_pointer != current_scope
        or not isinstance(super_call.type, astroid.Instance)
        or super_call.type.name != current_scope.name
    ):
        return

    # Check values of default args
    klass = function.parent.frame()
    meth_node = None
    for overridden in klass.local_attr_ancestors(function.name):
        # get astroid for the searched method
        try:
            meth_node = overridden[function.name]
        except KeyError:
            # we have found the method but it's not in the local
            # dictionary.
            # This may happen with astroid build from living objects
            continue
        if (
            not isinstance(meth_node, nodes.FunctionDef)
            # If the method have an ancestor which is not a
            # function then it is legitimate to redefine it
            or _has_different_parameters_default_value(
                meth_node.args, function.args
            )
        ):
            return
        break

    # Detect if the parameters are the same as the call's arguments.
    params = _signature_from_arguments(function.args)
    args = _signature_from_call(call)

    if meth_node is not None:

        @others
        called_annotations = form_annotations(function.args)
        overridden_annotations = form_annotations(meth_node.args)
        if called_annotations and overridden_annotations:
            if called_annotations != overridden_annotations:
                return

    if _definition_equivalent_to_call(params, args):
        self.add_message(
            "useless-super-delegation", node=function, args=(function.name,)
        )

</t>
<t tx="ekr.20220312061835.25">def emit_node(self, name, **props):
    """emit a node with given properties.
    node properties: see https://www.graphviz.org/doc/info/attrs.html
    """
    attrs = [f'{prop}="{value}"' for prop, value in props.items()]
    self.emit(f"{normalize_node_id(name)} [{', '.join(sorted(attrs))}];")


</t>
<t tx="ekr.20220312061835.250">def form_annotations(arguments):
    annotations = chain(
        (arguments.posonlyargs_annotations or []), arguments.annotations
    )
    return [ann.as_string() for ann in annotations if ann is not None]

</t>
<t tx="ekr.20220312061835.251">def _check_property_with_parameters(self, node):
    if (
        node.args.args
        and len(node.args.args) &gt; 1
        and decorated_with_property(node)
        and not is_property_setter(node)
    ):
        self.add_message("property-with-parameters", node=node)

</t>
<t tx="ekr.20220312061835.252">def _check_invalid_overridden_method(self, function_node, parent_function_node):
    parent_is_property = decorated_with_property(
        parent_function_node
    ) or is_property_setter_or_deleter(parent_function_node)
    current_is_property = decorated_with_property(
        function_node
    ) or is_property_setter_or_deleter(function_node)
    if parent_is_property and not current_is_property:
        self.add_message(
            "invalid-overridden-method",
            args=(function_node.name, "property", function_node.type),
            node=function_node,
        )
    elif not parent_is_property and current_is_property:
        self.add_message(
            "invalid-overridden-method",
            args=(function_node.name, "method", "property"),
            node=function_node,
        )

    parent_is_async = isinstance(parent_function_node, nodes.AsyncFunctionDef)
    current_is_async = isinstance(function_node, nodes.AsyncFunctionDef)

    if parent_is_async and not current_is_async:
        self.add_message(
            "invalid-overridden-method",
            args=(function_node.name, "async", "non-async"),
            node=function_node,
        )

    elif not parent_is_async and current_is_async:
        self.add_message(
            "invalid-overridden-method",
            args=(function_node.name, "non-async", "async"),
            node=function_node,
        )

</t>
<t tx="ekr.20220312061835.253">def _check_slots(self, node):
    if "__slots__" not in node.locals:
        return
    for slots in node.igetattr("__slots__"):
        # check if __slots__ is a valid type
        if slots is astroid.Uninferable:
            continue
        if not is_iterable(slots) and not is_comprehension(slots):
            self.add_message("invalid-slots", node=node)
            continue

        if isinstance(slots, nodes.Const):
            # a string, ignore the following checks
            self.add_message("single-string-used-for-slots", node=node)
            continue
        if not hasattr(slots, "itered"):
            # we can't obtain the values, maybe a .deque?
            continue

        if isinstance(slots, nodes.Dict):
            values = [item[0] for item in slots.items]
        else:
            values = slots.itered()
        if values is astroid.Uninferable:
            return
        for elt in values:
            try:
                self._check_slots_elt(elt, node)
            except astroid.InferenceError:
                continue

</t>
<t tx="ekr.20220312061835.254">def _check_slots_elt(self, elt, node):
    for inferred in elt.infer():
        if inferred is astroid.Uninferable:
            continue
        if not isinstance(inferred, nodes.Const) or not isinstance(
            inferred.value, str
        ):
            self.add_message(
                "invalid-slots-object", args=inferred.as_string(), node=elt
            )
            continue
        if not inferred.value:
            self.add_message(
                "invalid-slots-object", args=inferred.as_string(), node=elt
            )

        # Check if we have a conflict with a class variable.
        class_variable = node.locals.get(inferred.value)
        if class_variable:
            # Skip annotated assignments which don't conflict at all with slots.
            if len(class_variable) == 1:
                parent = class_variable[0].parent
                if isinstance(parent, nodes.AnnAssign) and parent.value is None:
                    return
            self.add_message(
                "class-variable-slots-conflict", args=(inferred.value,), node=elt
            )

</t>
<t tx="ekr.20220312061835.255">def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """on method node, check if this method couldn't be a function

    ignore class, static and abstract methods, initializer,
    methods overridden from a parent class.
    """
    if node.is_method():
        if node.args.args is not None:
            self._first_attrs.pop()
        if not self.linter.is_message_enabled("no-self-use"):
            return
        class_node = node.parent.frame()
        if (
            self._meth_could_be_func
            and node.type == "method"
            and node.name not in PYMETHODS
            and not (
                node.is_abstract()
                or overrides_a_method(class_node, node.name)
                or decorated_with_property(node)
                or _has_bare_super_call(node)
                or is_protocol_class(class_node)
                or is_overload_stub(node)
            )
        ):
            self.add_message("no-self-use", node=node)

</t>
<t tx="ekr.20220312061835.256">leave_asyncfunctiondef = leave_functiondef

</t>
<t tx="ekr.20220312061835.257">def visit_attribute(self, node: nodes.Attribute) -&gt; None:
    """check if the getattr is an access to a class member
    if so, register it. Also check for access to protected
    class member from outside its class (but ignore __special__
    methods)
    """
    # Check self
    if self._uses_mandatory_method_param(node):
        self._accessed.set_accessed(node)
        return
    if not self.linter.is_message_enabled("protected-access"):
        return

    self._check_protected_attribute_access(node)

</t>
<t tx="ekr.20220312061835.258">@check_messages("assigning-non-slot", "invalid-class-object")
def visit_assignattr(self, node: nodes.AssignAttr) -&gt; None:
    if isinstance(
        node.assign_type(), nodes.AugAssign
    ) and self._uses_mandatory_method_param(node):
        self._accessed.set_accessed(node)
    self._check_in_slots(node)
    self._check_invalid_class_object(node)

</t>
<t tx="ekr.20220312061835.259">def _check_invalid_class_object(self, node: nodes.AssignAttr) -&gt; None:
    if not node.attrname == "__class__":
        return
    inferred = safe_infer(node.parent.value)
    if isinstance(inferred, nodes.ClassDef) or inferred is astroid.Uninferable:
        # If is uninferrable, we allow it to prevent false positives
        return
    self.add_message("invalid-class-object", node=node)

</t>
<t tx="ekr.20220312061835.26">def normalize_node_id(nid):
    """Returns a suitable DOT node id for `nid`."""
    return f'"{nid}"'


</t>
<t tx="ekr.20220312061835.260">def _check_in_slots(self, node):
    """Check that the given AssignAttr node
    is defined in the class slots.
    """
    inferred = safe_infer(node.expr)
    if not isinstance(inferred, astroid.Instance):
        return

    klass = inferred._proxied
    if not has_known_bases(klass):
        return
    if "__slots__" not in klass.locals or not klass.newstyle:
        return

    # If 'typing.Generic' is a base of bases of klass, the cached version
    # of 'slots()' might have been evaluated incorrectly, thus deleted cache entry.
    if any(base.qname() == "typing.Generic" for base in klass.mro()):
        cache = getattr(klass, "__cache", None)
        if cache and cache.get(klass.slots) is not None:
            del cache[klass.slots]

    slots = klass.slots()
    if slots is None:
        return
    # If any ancestor doesn't use slots, the slots
    # defined for this class are superfluous.
    if any(
        "__slots__" not in ancestor.locals and ancestor.name != "object"
        for ancestor in klass.ancestors()
    ):
        return

    if not any(slot.value == node.attrname for slot in slots):
        # If we have a '__dict__' in slots, then
        # assigning any name is valid.
        if not any(slot.value == "__dict__" for slot in slots):
            if _is_attribute_property(node.attrname, klass):
                # Properties circumvent the slots mechanism,
                # so we should not emit a warning for them.
                return
            if node.attrname in klass.locals and _has_data_descriptor(
                klass, node.attrname
            ):
                # Descriptors circumvent the slots mechanism as well.
                return
            if node.attrname == "__class__" and _has_same_layout_slots(
                slots, node.parent.value
            ):
                return
            self.add_message("assigning-non-slot", args=(node.attrname,), node=node)

</t>
<t tx="ekr.20220312061835.261">@check_messages(
    "protected-access", "no-classmethod-decorator", "no-staticmethod-decorator"
)
</t>
<t tx="ekr.20220312061835.262">def visit_assign(self, assign_node: nodes.Assign) -&gt; None:
    self._check_classmethod_declaration(assign_node)
    node = assign_node.targets[0]
    if not isinstance(node, nodes.AssignAttr):
        return

    if self._uses_mandatory_method_param(node):
        return
    self._check_protected_attribute_access(node)

</t>
<t tx="ekr.20220312061835.263">def _check_classmethod_declaration(self, node):
    """Checks for uses of classmethod() or staticmethod()

    When a @classmethod or @staticmethod decorator should be used instead.
    A message will be emitted only if the assignment is at a class scope
    and only if the classmethod's argument belongs to the class where it
    is defined.
    `node` is an assign node.
    """
    if not isinstance(node.value, nodes.Call):
        return

    # check the function called is "classmethod" or "staticmethod"
    func = node.value.func
    if not isinstance(func, nodes.Name) or func.name not in (
        "classmethod",
        "staticmethod",
    ):
        return

    msg = (
        "no-classmethod-decorator"
        if func.name == "classmethod"
        else "no-staticmethod-decorator"
    )
    # assignment must be at a class scope
    parent_class = node.scope()
    if not isinstance(parent_class, nodes.ClassDef):
        return

    # Check if the arg passed to classmethod is a class member
    classmeth_arg = node.value.args[0]
    if not isinstance(classmeth_arg, nodes.Name):
        return

    method_name = classmeth_arg.name
    if any(method_name == member.name for member in parent_class.mymethods()):
        self.add_message(msg, node=node.targets[0])

</t>
<t tx="ekr.20220312061835.264">def _check_protected_attribute_access(self, node: nodes.Attribute):
    """Given an attribute access node (set or get), check if attribute
    access is legitimate. Call _check_first_attr with node before calling
    this method. Valid cases are:
    * self._attr in a method or cls._attr in a classmethod. Checked by
    _check_first_attr.
    * Klass._attr inside "Klass" class.
    * Klass2._attr inside "Klass" class when Klass2 is a base class of
        Klass.
    """
    attrname = node.attrname

    if (
        is_attr_protected(attrname)
        and attrname not in self.config.exclude_protected
    ):

        klass = node_frame_class(node)

        # In classes, check we are not getting a parent method
        # through the class object or through super
        callee = node.expr.as_string()

        # Typing annotations in funciton definitions can include protected members
        if utils.is_node_in_type_annotation_context(node):
            return

        # We are not in a class, no remaining valid case
        if klass is None:
            self.add_message("protected-access", node=node, args=attrname)
            return

        # If the expression begins with a call to super, that's ok.
        if (
            isinstance(node.expr, nodes.Call)
            and isinstance(node.expr.func, nodes.Name)
            and node.expr.func.name == "super"
        ):
            return

        # If the expression begins with a call to type(self), that's ok.
        if self._is_type_self_call(node.expr):
            return

        # We are in a class, one remaining valid cases, Klass._attr inside
        # Klass
        if not (callee == klass.name or callee in klass.basenames):
            # Detect property assignments in the body of the class.
            # This is acceptable:
            #
            # class A:
            #     b = property(lambda: self._b)

            stmt = node.parent.statement()
            if (
                isinstance(stmt, nodes.Assign)
                and len(stmt.targets) == 1
                and isinstance(stmt.targets[0], nodes.AssignName)
            ):
                name = stmt.targets[0].name
                if _is_attribute_property(name, klass):
                    return

            if (
                self._is_classmethod(node.frame())
                and self._is_inferred_instance(node.expr, klass)
                and self._is_class_attribute(attrname, klass)
            ):
                return

            licit_protected_member = not attrname.startswith("__")
            if (
                not self.config.check_protected_access_in_special_methods
                and licit_protected_member
                and self._is_called_inside_special_method(node)
            ):
                return

            self.add_message("protected-access", node=node, args=attrname)

</t>
<t tx="ekr.20220312061835.265">@staticmethod
def _is_called_inside_special_method(node: nodes.NodeNG) -&gt; bool:
    """
    Returns true if the node is located inside a special (aka dunder) method
    """
    try:
        frame_name = node.frame().name
    except AttributeError:
        return False
    return frame_name and frame_name in PYMETHODS

</t>
<t tx="ekr.20220312061835.266">def _is_type_self_call(self, expr):
    return (
        isinstance(expr, nodes.Call)
        and isinstance(expr.func, nodes.Name)
        and expr.func.name == "type"
        and len(expr.args) == 1
        and self._is_mandatory_method_param(expr.args[0])
    )

</t>
<t tx="ekr.20220312061835.267">@staticmethod
def _is_classmethod(func):
    """Check if the given *func* node is a class method."""

    return isinstance(func, nodes.FunctionDef) and (
        func.type == "classmethod" or func.name == "__class_getitem__"
    )

</t>
<t tx="ekr.20220312061835.268">@staticmethod
def _is_inferred_instance(expr, klass):
    """Check if the inferred value of the given *expr* is an instance of *klass*."""

    inferred = safe_infer(expr)
    if not isinstance(inferred, astroid.Instance):
        return False

    return inferred._proxied is klass

</t>
<t tx="ekr.20220312061835.269">@staticmethod
def _is_class_attribute(name, klass):
    """Check if the given attribute *name* is a class or instance member of the given *klass*.

    Returns ``True`` if the name is a property in the given klass,
    ``False`` otherwise.
    """

    try:
        klass.getattr(name)
        return True
    except astroid.NotFoundError:
        pass

    try:
        klass.instance_attr(name)
        return True
    except astroid.NotFoundError:
        return False

</t>
<t tx="ekr.20220312061835.27">def get_cycles(graph_dict, vertices=None):
    """given a dictionary representing an ordered graph (i.e. key are vertices
    and values is a list of destination vertices representing edges), return a
    list of detected cycles
    """
    if not graph_dict:
        return ()
    result = []
    if vertices is None:
        vertices = graph_dict.keys()
    for vertice in vertices:
        _get_cycles(graph_dict, [], set(), result, vertice)
    return result


</t>
<t tx="ekr.20220312061835.270">def visit_name(self, node: nodes.Name) -&gt; None:
    """check if the name handle an access to a class member
    if so, register it
    """
    if self._first_attrs and (
        node.name == self._first_attrs[-1] or not self._first_attrs[-1]
    ):
        self._meth_could_be_func = False

</t>
<t tx="ekr.20220312061835.271">def _check_accessed_members(self, node, accessed):
    """check that accessed members are defined"""
    excs = ("AttributeError", "Exception", "BaseException")
    for attr, nodes_lst in accessed.items():
        try:
            # is it a class attribute ?
            node.local_attr(attr)
            # yes, stop here
            continue
        except astroid.NotFoundError:
            pass
        # is it an instance attribute of a parent class ?
        try:
            next(node.instance_attr_ancestors(attr))
            # yes, stop here
            continue
        except StopIteration:
            pass
        # is it an instance attribute ?
        try:
            defstmts = node.instance_attr(attr)
        except astroid.NotFoundError:
            pass
        else:
            # filter out augment assignment nodes
            defstmts = [stmt for stmt in defstmts if stmt not in nodes_lst]
            if not defstmts:
                # only augment assignment for this node, no-member should be
                # triggered by the typecheck checker
                continue
            # filter defstmts to only pick the first one when there are
            # several assignments in the same scope
            scope = defstmts[0].scope()
            defstmts = [
                stmt
                for i, stmt in enumerate(defstmts)
                if i == 0 or stmt.scope() is not scope
            ]
            # if there are still more than one, don't attempt to be smarter
            # than we can be
            if len(defstmts) == 1:
                defstmt = defstmts[0]
                # check that if the node is accessed in the same method as
                # it's defined, it's accessed after the initial assignment
                frame = defstmt.frame()
                lno = defstmt.fromlineno
                for _node in nodes_lst:
                    if (
                        _node.frame() is frame
                        and _node.fromlineno &lt; lno
                        and not astroid.are_exclusive(
                            _node.statement(), defstmt, excs
                        )
                    ):
                        self.add_message(
                            "access-member-before-definition",
                            node=_node,
                            args=(attr, lno),
                        )

</t>
<t tx="ekr.20220312061835.272">def _check_first_arg_for_type(self, node, metaclass=0):
    """check the name of first argument, expect:

    * 'self' for a regular method
    * 'cls' for a class method or a metaclass regular method (actually
      valid-classmethod-first-arg value)
    * 'mcs' for a metaclass class method (actually
      valid-metaclass-classmethod-first-arg)
    * not one of the above for a static method
    """
    # don't care about functions with unknown argument (builtins)
    if node.args.args is None:
        return
    if node.args.posonlyargs:
        first_arg = node.args.posonlyargs[0].name
    elif node.args.args:
        first_arg = node.argnames()[0]
    else:
        first_arg = None
    self._first_attrs.append(first_arg)
    first = self._first_attrs[-1]
    # static method
    if node.type == "staticmethod":
        if (
            first_arg == "self"
            or first_arg in self.config.valid_classmethod_first_arg
            or first_arg in self.config.valid_metaclass_classmethod_first_arg
        ):
            self.add_message("bad-staticmethod-argument", args=first, node=node)
            return
        self._first_attrs[-1] = None
    # class / regular method with no args
    elif not node.args.args and not node.args.posonlyargs:
        self.add_message("no-method-argument", node=node)
    # metaclass
    elif metaclass:
        # metaclass __new__ or classmethod
        if node.type == "classmethod":
            self._check_first_arg_config(
                first,
                self.config.valid_metaclass_classmethod_first_arg,
                node,
                "bad-mcs-classmethod-argument",
                node.name,
            )
        # metaclass regular method
        else:
            self._check_first_arg_config(
                first,
                self.config.valid_classmethod_first_arg,
                node,
                "bad-mcs-method-argument",
                node.name,
            )
    # regular class
    else:  # pylint: disable=else-if-used
        # class method
        if node.type == "classmethod" or node.name == "__class_getitem__":
            self._check_first_arg_config(
                first,
                self.config.valid_classmethod_first_arg,
                node,
                "bad-classmethod-argument",
                node.name,
            )
        # regular method without self as argument
        elif first != "self":
            self.add_message("no-self-argument", node=node)

</t>
<t tx="ekr.20220312061835.273">def _check_first_arg_config(self, first, config, node, message, method_name):
    if first not in config:
        if len(config) == 1:
            valid = repr(config[0])
        else:
            valid = ", ".join(repr(v) for v in config[:-1])
            valid = f"{valid} or {config[-1]!r}"
        self.add_message(message, args=(method_name, valid), node=node)

</t>
<t tx="ekr.20220312061835.274">def _check_bases_classes(self, node):
    """check that the given class node implements abstract methods from
    base classes
    """

    def is_abstract(method):
        return method.is_abstract(pass_is_abstract=False)

    # check if this class abstract
    if class_is_abstract(node):
        return

    methods = sorted(
        unimplemented_abstract_methods(node, is_abstract).items(),
        key=lambda item: item[0],
    )
    for name, method in methods:
        owner = method.parent.frame()
        if owner is node:
            continue
        # owner is not this class, it must be a parent class
        # check that the ancestor's method is not abstract
        if name in node.locals:
            # it is redefined as an attribute or with a descriptor
            continue
        self.add_message("abstract-method", node=node, args=(name, owner.name))

</t>
<t tx="ekr.20220312061835.275">def _check_init(self, node):
    """check that the __init__ method call super or ancestors'__init__
    method (unless it is used for type hinting with `typing.overload`)
    """
    if not self.linter.is_message_enabled(
        "super-init-not-called"
    ) and not self.linter.is_message_enabled("non-parent-init-called"):
        return
    klass_node = node.parent.frame()
    to_call = _ancestors_to_call(klass_node)
    not_called_yet = dict(to_call)
    for stmt in node.nodes_of_class(nodes.Call):
        expr = stmt.func
        if not isinstance(expr, nodes.Attribute) or expr.attrname != "__init__":
            continue
        # skip the test if using super
        if (
            isinstance(expr.expr, nodes.Call)
            and isinstance(expr.expr.func, nodes.Name)
            and expr.expr.func.name == "super"
        ):
            return
        try:
            for klass in expr.expr.infer():
                if klass is astroid.Uninferable:
                    continue
                # The inferred klass can be super(), which was
                # assigned to a variable and the `__init__`
                # was called later.
                #
                # base = super()
                # base.__init__(...)

                if (
                    isinstance(klass, astroid.Instance)
                    and isinstance(klass._proxied, nodes.ClassDef)
                    and is_builtin_object(klass._proxied)
                    and klass._proxied.name == "super"
                ):
                    return
                if isinstance(klass, astroid.objects.Super):
                    return
                try:
                    del not_called_yet[klass]
                except KeyError:
                    if klass not in to_call:
                        self.add_message(
                            "non-parent-init-called", node=expr, args=klass.name
                        )
        except astroid.InferenceError:
            continue
    for klass, method in not_called_yet.items():
        if decorated_with(node, ["typing.overload"]):
            continue
        cls = node_frame_class(method)
        if klass.name == "object" or (cls and cls.name == "object"):
            continue
        self.add_message("super-init-not-called", args=klass.name, node=node)

</t>
<t tx="ekr.20220312061835.276">def _check_signature(self, method1, refmethod, class_type, cls):
    """check that the signature of the two given methods match"""
    if not (
        isinstance(method1, nodes.FunctionDef)
        and isinstance(refmethod, nodes.FunctionDef)
    ):
        self.add_message(
            "method-check-failed", args=(method1, refmethod), node=method1
        )
        return

    instance = cls.instantiate_class()
    method1 = astroid.scoped_nodes.function_to_method(method1, instance)
    refmethod = astroid.scoped_nodes.function_to_method(refmethod, instance)

    # Don't care about functions with unknown argument (builtins).
    if method1.args.args is None or refmethod.args.args is None:
        return

    # Ignore private to class methods.
    if is_attr_private(method1.name):
        return
    # Ignore setters, they have an implicit extra argument,
    # which shouldn't be taken in consideration.
    if is_property_setter(method1):
        return

    arg_differ_output = _different_parameters(
        refmethod, method1, dummy_parameter_regex=self._dummy_rgx
    )
    if len(arg_differ_output) &gt; 0:
        for msg in arg_differ_output:
            if "Number" in msg:
                total_args_method1 = len(method1.args.args)
                if method1.args.vararg:
                    total_args_method1 += 1
                if method1.args.kwarg:
                    total_args_method1 += 1
                if method1.args.kwonlyargs:
                    total_args_method1 += len(method1.args.kwonlyargs)
                total_args_refmethod = len(refmethod.args.args)
                if refmethod.args.vararg:
                    total_args_refmethod += 1
                if refmethod.args.kwarg:
                    total_args_refmethod += 1
                if refmethod.args.kwonlyargs:
                    total_args_refmethod += len(refmethod.args.kwonlyargs)
                error_type = "arguments-differ"
                msg_args = (
                    msg
                    + f"was {total_args_refmethod} in '{refmethod.parent.name}.{refmethod.name}' and "
                    f"is now {total_args_method1} in",
                    class_type,
                    f"{method1.parent.name}.{method1.name}",
                )
            elif "renamed" in msg:
                error_type = "arguments-renamed"
                msg_args = (
                    msg,
                    class_type,
                    f"{method1.parent.name}.{method1.name}",
                )
            else:
                error_type = "arguments-differ"
                msg_args = (
                    msg,
                    class_type,
                    f"{method1.parent.name}.{method1.name}",
                )
            self.add_message(error_type, args=msg_args, node=method1)
    elif (
        len(method1.args.defaults) &lt; len(refmethod.args.defaults)
        and not method1.args.vararg
    ):
        self.add_message(
            "signature-differs", args=(class_type, method1.name), node=method1
        )

</t>
<t tx="ekr.20220312061835.277">def _uses_mandatory_method_param(self, node):
    """Check that attribute lookup name use first attribute variable name

    Name is `self` for method, `cls` for classmethod and `mcs` for metaclass.
    """
    return self._is_mandatory_method_param(node.expr)

</t>
<t tx="ekr.20220312061835.278">def _is_mandatory_method_param(self, node):
    """Check if nodes.Name corresponds to first attribute variable name

    Name is `self` for method, `cls` for classmethod and `mcs` for metaclass.
    """
    return (
        self._first_attrs
        and isinstance(node, nodes.Name)
        and node.name == self._first_attrs[-1]
    )


</t>
<t tx="ekr.20220312061835.279">class SpecialMethodsChecker(BaseChecker):
    """Checker which verifies that special methods
    are implemented correctly.
    """

    __implements__ = (IAstroidChecker,)
    name = "classes"
    msgs = {
        "E0301": (
            "__iter__ returns non-iterator",
            "non-iterator-returned",
            "Used when an __iter__ method returns something which is not an "
            f"iterable (i.e. has no `{NEXT_METHOD}` method)",
            {
                "old_names": [
                    ("W0234", "old-non-iterator-returned-1"),
                    ("E0234", "old-non-iterator-returned-2"),
                ]
            },
        ),
        "E0302": (
            "The special method %r expects %s param(s), %d %s given",
            "unexpected-special-method-signature",
            "Emitted when a special method was defined with an "
            "invalid number of parameters. If it has too few or "
            "too many, it might not work at all.",
            {"old_names": [("E0235", "bad-context-manager")]},
        ),
        "E0303": (
            "__len__ does not return non-negative integer",
            "invalid-length-returned",
            "Used when a __len__ method returns something which is not a "
            "non-negative integer",
        ),
        "E0304": (
            "__bool__ does not return bool",
            "invalid-bool-returned",
            "Used when a __bool__ method returns something which is not a bool",
        ),
        "E0305": (
            "__index__ does not return int",
            "invalid-index-returned",
            "Used when an __index__ method returns something which is not "
            "an integer",
        ),
        "E0306": (
            "__repr__ does not return str",
            "invalid-repr-returned",
            "Used when a __repr__ method returns something which is not a string",
        ),
        "E0307": (
            "__str__ does not return str",
            "invalid-str-returned",
            "Used when a __str__ method returns something which is not a string",
        ),
        "E0308": (
            "__bytes__ does not return bytes",
            "invalid-bytes-returned",
            "Used when a __bytes__ method returns something which is not bytes",
        ),
        "E0309": (
            "__hash__ does not return int",
            "invalid-hash-returned",
            "Used when a __hash__ method returns something which is not an integer",
        ),
        "E0310": (
            "__length_hint__ does not return non-negative integer",
            "invalid-length-hint-returned",
            "Used when a __length_hint__ method returns something which is not a "
            "non-negative integer",
        ),
        "E0311": (
            "__format__ does not return str",
            "invalid-format-returned",
            "Used when a __format__ method returns something which is not a string",
        ),
        "E0312": (
            "__getnewargs__ does not return a tuple",
            "invalid-getnewargs-returned",
            "Used when a __getnewargs__ method returns something which is not "
            "a tuple",
        ),
        "E0313": (
            "__getnewargs_ex__ does not return a tuple containing (tuple, dict)",
            "invalid-getnewargs-ex-returned",
            "Used when a __getnewargs_ex__ method returns something which is not "
            "of the form tuple(tuple, dict)",
        ),
    }
    priority = -2

    @others
</t>
<t tx="ekr.20220312061835.28">def _get_cycles(graph_dict, path, visited, result, vertice):
    """recursive function doing the real work for get_cycles"""
    if vertice in path:
        cycle = [vertice]
        for node in path[::-1]:
            if node == vertice:
                break
            cycle.insert(0, node)
        # make a canonical representation
        start_from = min(cycle)
        index = cycle.index(start_from)
        cycle = cycle[index:] + cycle[0:index]
        # append it to result if not already in
        if cycle not in result:
            result.append(cycle)
        return
    path.append(vertice)
    try:
        for node in graph_dict[vertice]:
            # don't check already visited nodes again
            if node not in visited:
                _get_cycles(graph_dict, path, visited, result, node)
                visited.add(node)
    except KeyError:
        pass
    path.pop()
</t>
<t tx="ekr.20220312061835.280">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self._protocol_map = {
        "__iter__": self._check_iter,
        "__len__": self._check_len,
        "__bool__": self._check_bool,
        "__index__": self._check_index,
        "__repr__": self._check_repr,
        "__str__": self._check_str,
        "__bytes__": self._check_bytes,
        "__hash__": self._check_hash,
        "__length_hint__": self._check_length_hint,
        "__format__": self._check_format,
        "__getnewargs__": self._check_getnewargs,
        "__getnewargs_ex__": self._check_getnewargs_ex,
    }

</t>
<t tx="ekr.20220312061835.281">@check_messages(
    "unexpected-special-method-signature",
    "non-iterator-returned",
    "invalid-length-returned",
    "invalid-bool-returned",
    "invalid-index-returned",
    "invalid-repr-returned",
    "invalid-str-returned",
    "invalid-bytes-returned",
    "invalid-hash-returned",
    "invalid-length-hint-returned",
    "invalid-format-returned",
    "invalid-getnewargs-returned",
    "invalid-getnewargs-ex-returned",
)
</t>
<t tx="ekr.20220312061835.282">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    if not node.is_method():
        return

    inferred = _safe_infer_call_result(node, node)
    # Only want to check types that we are able to infer
    if inferred and node.name in self._protocol_map:
        self._protocol_map[node.name](node, inferred)

    if node.name in PYMETHODS:
        self._check_unexpected_method_signature(node)

</t>
<t tx="ekr.20220312061835.283">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.284">def _check_unexpected_method_signature(self, node):
    expected_params = SPECIAL_METHODS_PARAMS[node.name]

    if expected_params is None:
        # This can support a variable number of parameters.
        return
    if not node.args.args and not node.args.vararg:
        # Method has no parameter, will be caught
        # by no-method-argument.
        return

    if decorated_with(node, ["builtins.staticmethod"]):
        # We expect to not take in consideration self.
        all_args = node.args.args
    else:
        all_args = node.args.args[1:]
    mandatory = len(all_args) - len(node.args.defaults)
    optional = len(node.args.defaults)
    current_params = mandatory + optional

    if isinstance(expected_params, tuple):
        # The expected number of parameters can be any value from this
        # tuple, although the user should implement the method
        # to take all of them in consideration.
        emit = mandatory not in expected_params
        # pylint: disable-next=consider-using-f-string
        expected_params = "between %d or %d" % expected_params
    else:
        # If the number of mandatory parameters doesn't
        # suffice, the expected parameters for this
        # function will be deduced from the optional
        # parameters.
        rest = expected_params - mandatory
        if rest == 0:
            emit = False
        elif rest &lt; 0:
            emit = True
        elif rest &gt; 0:
            emit = not ((optional - rest) &gt;= 0 or node.args.vararg)

    if emit:
        verb = "was" if current_params &lt;= 1 else "were"
        self.add_message(
            "unexpected-special-method-signature",
            args=(node.name, expected_params, current_params, verb),
            node=node,
        )

</t>
<t tx="ekr.20220312061835.285">@staticmethod
def _is_wrapped_type(node, type_):
    return (
        isinstance(node, astroid.Instance)
        and node.name == type_
        and not isinstance(node, nodes.Const)
    )

</t>
<t tx="ekr.20220312061835.286">@staticmethod
def _is_int(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "int"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, int)

</t>
<t tx="ekr.20220312061835.287">@staticmethod
def _is_str(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "str"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, str)

</t>
<t tx="ekr.20220312061835.288">@staticmethod
def _is_bool(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "bool"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, bool)

</t>
<t tx="ekr.20220312061835.289">@staticmethod
def _is_bytes(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "bytes"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, bytes)

</t>
<t tx="ekr.20220312061835.29">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Copyright (c) 2009-2010, 2012-2013 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2013-2014 Google, Inc.
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2020-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Interfaces for Pylint objects"""
from collections import namedtuple
from typing import TYPE_CHECKING, Tuple

from astroid import nodes

if TYPE_CHECKING:
    from pylint.reporters.ureports.nodes import Section

Confidence = namedtuple("Confidence", ["name", "description"])
# Warning Certainties
HIGH = Confidence("HIGH", "No false positive possible.")
INFERENCE = Confidence("INFERENCE", "Warning based on inference result.")
INFERENCE_FAILURE = Confidence(
    "INFERENCE_FAILURE", "Warning based on inference with failures."
)
UNDEFINED = Confidence("UNDEFINED", "Warning without any associated confidence level.")

CONFIDENCE_LEVELS = [HIGH, INFERENCE, INFERENCE_FAILURE, UNDEFINED]


@others
__all__ = ("IRawChecker", "IAstroidChecker", "ITokenChecker", "IReporter", "IChecker")
</t>
<t tx="ekr.20220312061835.290">@staticmethod
def _is_tuple(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "tuple"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, tuple)

</t>
<t tx="ekr.20220312061835.291">@staticmethod
def _is_dict(node):
    if SpecialMethodsChecker._is_wrapped_type(node, "dict"):
        return True

    return isinstance(node, nodes.Const) and isinstance(node.value, dict)

</t>
<t tx="ekr.20220312061835.292">@staticmethod
def _is_iterator(node):
    if node is astroid.Uninferable:
        # Just ignore Uninferable objects.
        return True
    if isinstance(node, astroid.bases.Generator):
        # Generators can be iterated.
        return True

    if isinstance(node, astroid.Instance):
        try:
            node.local_attr(NEXT_METHOD)
            return True
        except astroid.NotFoundError:
            pass
    elif isinstance(node, nodes.ClassDef):
        metaclass = node.metaclass()
        if metaclass and isinstance(metaclass, nodes.ClassDef):
            try:
                metaclass.local_attr(NEXT_METHOD)
                return True
            except astroid.NotFoundError:
                pass
    return False

</t>
<t tx="ekr.20220312061835.293">def _check_iter(self, node, inferred):
    if not self._is_iterator(inferred):
        self.add_message("non-iterator-returned", node=node)

</t>
<t tx="ekr.20220312061835.294">def _check_len(self, node, inferred):
    if not self._is_int(inferred):
        self.add_message("invalid-length-returned", node=node)
    elif isinstance(inferred, nodes.Const) and inferred.value &lt; 0:
        self.add_message("invalid-length-returned", node=node)

</t>
<t tx="ekr.20220312061835.295">def _check_bool(self, node, inferred):
    if not self._is_bool(inferred):
        self.add_message("invalid-bool-returned", node=node)

</t>
<t tx="ekr.20220312061835.296">def _check_index(self, node, inferred):
    if not self._is_int(inferred):
        self.add_message("invalid-index-returned", node=node)

</t>
<t tx="ekr.20220312061835.297">def _check_repr(self, node, inferred):
    if not self._is_str(inferred):
        self.add_message("invalid-repr-returned", node=node)

</t>
<t tx="ekr.20220312061835.298">def _check_str(self, node, inferred):
    if not self._is_str(inferred):
        self.add_message("invalid-str-returned", node=node)

</t>
<t tx="ekr.20220312061835.299">def _check_bytes(self, node, inferred):
    if not self._is_bytes(inferred):
        self.add_message("invalid-bytes-returned", node=node)

</t>
<t tx="ekr.20220312061835.3">class WarningScope:
    LINE = "line-based-msg"
    NODE = "node-based-msg"


</t>
<t tx="ekr.20220312061835.30">class Interface:
    """Base class for interfaces."""

    @classmethod
    def is_implemented_by(cls, instance):
        return implements(instance, cls)


</t>
<t tx="ekr.20220312061835.300">def _check_hash(self, node, inferred):
    if not self._is_int(inferred):
        self.add_message("invalid-hash-returned", node=node)

</t>
<t tx="ekr.20220312061835.301">def _check_length_hint(self, node, inferred):
    if not self._is_int(inferred):
        self.add_message("invalid-length-hint-returned", node=node)
    elif isinstance(inferred, nodes.Const) and inferred.value &lt; 0:
        self.add_message("invalid-length-hint-returned", node=node)

</t>
<t tx="ekr.20220312061835.302">def _check_format(self, node, inferred):
    if not self._is_str(inferred):
        self.add_message("invalid-format-returned", node=node)

</t>
<t tx="ekr.20220312061835.303">def _check_getnewargs(self, node, inferred):
    if not self._is_tuple(inferred):
        self.add_message("invalid-getnewargs-returned", node=node)

</t>
<t tx="ekr.20220312061835.304">def _check_getnewargs_ex(self, node, inferred):
    if not self._is_tuple(inferred):
        self.add_message("invalid-getnewargs-ex-returned", node=node)
        return

    if not isinstance(inferred, nodes.Tuple):
        # If it's not an astroid.Tuple we can't analyze it further
        return

    found_error = False

    if len(inferred.elts) != 2:
        found_error = True
    else:
        for arg, check in (
            (inferred.elts[0], self._is_tuple),
            (inferred.elts[1], self._is_dict),
        ):

            if isinstance(arg, nodes.Call):
                arg = safe_infer(arg)

            if arg and arg is not astroid.Uninferable:
                if not check(arg):
                    found_error = True
                    break

    if found_error:
        self.add_message("invalid-getnewargs-ex-returned", node=node)


</t>
<t tx="ekr.20220312061835.305">def _ancestors_to_call(klass_node, method="__init__"):
    """return a dictionary where keys are the list of base classes providing
    the queried method, and so that should/may be called from the method node
    """
    to_call = {}
    for base_node in klass_node.ancestors(recurs=False):
        try:
            to_call[base_node] = next(base_node.igetattr(method))
        except astroid.InferenceError:
            continue
    return to_call


</t>
<t tx="ekr.20220312061835.306">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(ClassChecker(linter))
    linter.register_checker(SpecialMethodsChecker(linter))
</t>
<t tx="ekr.20220312061835.307">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checker mixin for deprecated functionality."""
from itertools import chain
from typing import Any, Container, Iterable, Tuple, Union

import astroid
from astroid import nodes

from pylint.checkers import utils
from pylint.checkers.base_checker import BaseChecker
from pylint.checkers.utils import get_import_name, infer_all, safe_infer

ACCEPTABLE_NODES = (
    astroid.BoundMethod,
    astroid.UnboundMethod,
    nodes.FunctionDef,
    nodes.ClassDef,
)


@others
</t>
<t tx="ekr.20220312061835.308">class DeprecatedMixin(BaseChecker):
    """A mixin implementing logic for checking deprecated symbols.
    A class implementing mixin must define "deprecated-method" Message.
    """

    msgs: Any = {
        "W1505": (
            "Using deprecated method %s()",
            "deprecated-method",
            "The method is marked as deprecated and will be removed in the future.",
        ),
        "W1511": (
            "Using deprecated argument %s of method %s()",
            "deprecated-argument",
            "The argument is marked as deprecated and will be removed in the future.",
        ),
        "W0402": (
            "Uses of a deprecated module %r",
            "deprecated-module",
            "A module marked as deprecated is imported.",
        ),
        "W1512": (
            "Using deprecated class %s of module %s",
            "deprecated-class",
            "The class is marked as deprecated and will be removed in the future.",
        ),
        "W1513": (
            "Using deprecated decorator %s()",
            "deprecated-decorator",
            "The decorator is marked as deprecated and will be removed in the future.",
        ),
    }

    @utils.check_messages(
        "deprecated-method",
        "deprecated-argument",
        "deprecated-class",
    )
    @others
</t>
<t tx="ekr.20220312061835.309">def visit_call(self, node: nodes.Call) -&gt; None:
    """Called when a :class:`nodes.Call` node is visited."""
    self.check_deprecated_class_in_call(node)
    for inferred in infer_all(node.func):
        # Calling entry point for deprecation check logic.
        self.check_deprecated_method(node, inferred)

</t>
<t tx="ekr.20220312061835.31">def implements(obj: "Interface", interface: Tuple[type, type]) -&gt; bool:
    """Return true if the give object (maybe an instance or class) implements
    the interface.
    """
    kimplements = getattr(obj, "__implements__", ())
    if not isinstance(kimplements, (list, tuple)):
        kimplements = (kimplements,)
    for implementedinterface in kimplements:
        if issubclass(implementedinterface, interface):
            return True
    return False


</t>
<t tx="ekr.20220312061835.310">@utils.check_messages(
    "deprecated-module",
    "deprecated-class",
)
</t>
<t tx="ekr.20220312061835.311">def visit_import(self, node: nodes.Import) -&gt; None:
    """triggered when an import statement is seen"""
    for name in (name for name, _ in node.names):
        self.check_deprecated_module(node, name)
        if "." in name:
            # Checking deprecation for import module with class
            mod_name, class_name = name.split(".", 1)
            self.check_deprecated_class(node, mod_name, (class_name,))

</t>
<t tx="ekr.20220312061835.312">def deprecated_decorators(self) -&gt; Iterable:
    """Callback returning the deprecated decorators.

    Returns:
        collections.abc.Container of deprecated decorator names.
    """
    # pylint: disable=no-self-use
    return ()

</t>
<t tx="ekr.20220312061835.313">@utils.check_messages("deprecated-decorator")
def visit_decorators(self, node: nodes.Decorators) -&gt; None:
    """Triggered when a decorator statement is seen"""
    children = list(node.get_children())
    if not children:
        return
    if isinstance(children[0], nodes.Call):
        inf = safe_infer(children[0].func)
    else:
        inf = safe_infer(children[0])
    qname = inf.qname() if inf else None
    if qname in self.deprecated_decorators():
        self.add_message("deprecated-decorator", node=node, args=qname)

</t>
<t tx="ekr.20220312061835.314">@utils.check_messages(
    "deprecated-module",
    "deprecated-class",
)
</t>
<t tx="ekr.20220312061835.315">def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """triggered when a from statement is seen"""
    basename = node.modname
    basename = get_import_name(node, basename)
    self.check_deprecated_module(node, basename)
    class_names = (name for name, _ in node.names)
    self.check_deprecated_class(node, basename, class_names)

</t>
<t tx="ekr.20220312061835.316">def deprecated_methods(self) -&gt; Container[str]:
    """Callback returning the deprecated methods/functions.

    Returns:
        collections.abc.Container of deprecated function/method names.
    """
    # pylint: disable=no-self-use
    return ()

</t>
<t tx="ekr.20220312061835.317">def deprecated_arguments(
    self, method: str
) -&gt; Iterable[Tuple[Union[int, None], str]]:
    """Callback returning the deprecated arguments of method/function.

    Args:
        method (str): name of function/method checked for deprecated arguments

    Returns:
        collections.abc.Iterable in form:
            ((POSITION1, PARAM1), (POSITION2: PARAM2) ...)
        where
            * POSITIONX - position of deprecated argument PARAMX in function definition.
              If argument is keyword-only, POSITIONX should be None.
            * PARAMX - name of the deprecated argument.
        E.g. suppose function:

        .. code-block:: python
            def bar(arg1, arg2, arg3, arg4, arg5='spam')

        with deprecated arguments `arg2` and `arg4`. `deprecated_arguments` should return:

        .. code-block:: python
            ((1, 'arg2'), (3, 'arg4'))
    """
    # pylint: disable=no-self-use
    # pylint: disable=unused-argument
    return ()

</t>
<t tx="ekr.20220312061835.318">def deprecated_modules(self) -&gt; Iterable:
    """Callback returning the deprecated modules.

    Returns:
        collections.abc.Container of deprecated module names.
    """
    # pylint: disable=no-self-use
    return ()

</t>
<t tx="ekr.20220312061835.319">def deprecated_classes(self, module: str) -&gt; Iterable:
    """Callback returning the deprecated classes of module.

    Args:
        module (str): name of module checked for deprecated classes

    Returns:
        collections.abc.Container of deprecated class names.
    """
    # pylint: disable=no-self-use
    # pylint: disable=unused-argument
    return ()

</t>
<t tx="ekr.20220312061835.32">class IChecker(Interface):
    """This is a base interface, not designed to be used elsewhere than for
    sub interfaces definition.
    """

    @others
</t>
<t tx="ekr.20220312061835.320">def check_deprecated_module(self, node, mod_path):
    """Checks if the module is deprecated"""
    for mod_name in self.deprecated_modules():
        if mod_path == mod_name or mod_path.startswith(mod_name + "."):
            self.add_message("deprecated-module", node=node, args=mod_path)

</t>
<t tx="ekr.20220312061835.321">def check_deprecated_method(self, node, inferred):
    """Executes the checker for the given node. This method should
    be called from the checker implementing this mixin.
    """

    # Reject nodes which aren't of interest to us.
    if not isinstance(inferred, ACCEPTABLE_NODES):
        return

    if isinstance(node.func, nodes.Attribute):
        func_name = node.func.attrname
    elif isinstance(node.func, nodes.Name):
        func_name = node.func.name
    else:
        # Not interested in other nodes.
        return

    if hasattr(inferred.parent, "qname") and inferred.parent.qname():
        # Handling the situation when deprecated function is
        # alias to existing function.
        qnames = {
            inferred.qname(),
            f"{inferred.parent.qname()}.{func_name}",
            func_name,
        }
    else:
        qnames = {inferred.qname(), func_name}
    if any(name in self.deprecated_methods() for name in qnames):
        self.add_message("deprecated-method", node=node, args=(func_name,))
        return
    num_of_args = len(node.args)
    kwargs = {kw.arg for kw in node.keywords} if node.keywords else {}
    deprecated_arguments = (self.deprecated_arguments(qn) for qn in qnames)
    for position, arg_name in chain(*deprecated_arguments):
        if arg_name in kwargs:
            # function was called with deprecated argument as keyword argument
            self.add_message(
                "deprecated-argument", node=node, args=(arg_name, func_name)
            )
        elif position is not None and position &lt; num_of_args:
            # function was called with deprecated argument as positional argument
            self.add_message(
                "deprecated-argument", node=node, args=(arg_name, func_name)
            )

</t>
<t tx="ekr.20220312061835.322">def check_deprecated_class(self, node, mod_name, class_names):
    """Checks if the class is deprecated"""

    for class_name in class_names:
        if class_name in self.deprecated_classes(mod_name):
            self.add_message(
                "deprecated-class", node=node, args=(class_name, mod_name)
            )

</t>
<t tx="ekr.20220312061835.323">def check_deprecated_class_in_call(self, node):
    """Checks if call the deprecated class"""

    if isinstance(node.func, nodes.Attribute) and isinstance(
        node.func.expr, nodes.Name
    ):
        mod_name = node.func.expr.name
        class_name = node.func.attrname
        self.check_deprecated_class(node, mod_name, (class_name,))
</t>
<t tx="ekr.20220312061835.324">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006, 2009-2010, 2012-2015 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012, 2014 Google, Inc.
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 ahirnish &lt;ahirnish@gmail.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Mark Miller &lt;725mrm@gmail.com&gt;
# Copyright (c) 2018 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Michael Scott Cuthbert &lt;cuthbert@mit.edu&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Melvin &lt;31448155+melvio@users.noreply.github.com&gt;
# Copyright (c) 2021 Rebecca Turner &lt;rbt@sent.as&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 yushao2 &lt;36848472+yushao2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""check for signs of poor design"""

import re
from collections import defaultdict
from typing import FrozenSet, List, Set, cast

import astroid
from astroid import nodes

from pylint import utils
from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker
from pylint.typing import CheckerStats

MSGS = {  # pylint: disable=consider-using-namedtuple-or-dataclass
    "R0901": (
        "Too many ancestors (%s/%s)",
        "too-many-ancestors",
        "Used when class has too many parent classes, try to reduce "
        "this to get a simpler (and so easier to use) class.",
    ),
    "R0902": (
        "Too many instance attributes (%s/%s)",
        "too-many-instance-attributes",
        "Used when class has too many instance attributes, try to reduce "
        "this to get a simpler (and so easier to use) class.",
    ),
    "R0903": (
        "Too few public methods (%s/%s)",
        "too-few-public-methods",
        "Used when class has too few public methods, so be sure it's "
        "really worth it.",
    ),
    "R0904": (
        "Too many public methods (%s/%s)",
        "too-many-public-methods",
        "Used when class has too many public methods, try to reduce "
        "this to get a simpler (and so easier to use) class.",
    ),
    "R0911": (
        "Too many return statements (%s/%s)",
        "too-many-return-statements",
        "Used when a function or method has too many return statement, "
        "making it hard to follow.",
    ),
    "R0912": (
        "Too many branches (%s/%s)",
        "too-many-branches",
        "Used when a function or method has too many branches, "
        "making it hard to follow.",
    ),
    "R0913": (
        "Too many arguments (%s/%s)",
        "too-many-arguments",
        "Used when a function or method takes too many arguments.",
    ),
    "R0914": (
        "Too many local variables (%s/%s)",
        "too-many-locals",
        "Used when a function or method has too many local variables.",
    ),
    "R0915": (
        "Too many statements (%s/%s)",
        "too-many-statements",
        "Used when a function or method has too many statements. You "
        "should then split it in smaller functions / methods.",
    ),
    "R0916": (
        "Too many boolean expressions in if statement (%s/%s)",
        "too-many-boolean-expressions",
        "Used when an if statement contains too many boolean expressions.",
    ),
}
SPECIAL_OBJ = re.compile("^_{2}[a-z]+_{2}$")
DATACLASSES_DECORATORS = frozenset({"dataclass", "attrs"})
DATACLASS_IMPORT = "dataclasses"
TYPING_NAMEDTUPLE = "typing.NamedTuple"
TYPING_TYPEDDICT = "typing.TypedDict"

# Set of stdlib classes to ignore when calculating number of ancestors
STDLIB_CLASSES_IGNORE_ANCESTOR = frozenset(
    (
        "builtins.object",
        "builtins.tuple",
        "builtins.dict",
        "builtins.list",
        "builtins.set",
        "bulitins.frozenset",
        "collections.ChainMap",
        "collections.Counter",
        "collections.OrderedDict",
        "collections.UserDict",
        "collections.UserList",
        "collections.UserString",
        "collections.defaultdict",
        "collections.deque",
        "collections.namedtuple",
        "_collections_abc.Awaitable",
        "_collections_abc.Coroutine",
        "_collections_abc.AsyncIterable",
        "_collections_abc.AsyncIterator",
        "_collections_abc.AsyncGenerator",
        "_collections_abc.Hashable",
        "_collections_abc.Iterable",
        "_collections_abc.Iterator",
        "_collections_abc.Generator",
        "_collections_abc.Reversible",
        "_collections_abc.Sized",
        "_collections_abc.Container",
        "_collections_abc.Collection",
        "_collections_abc.Set",
        "_collections_abc.MutableSet",
        "_collections_abc.Mapping",
        "_collections_abc.MutableMapping",
        "_collections_abc.MappingView",
        "_collections_abc.KeysView",
        "_collections_abc.ItemsView",
        "_collections_abc.ValuesView",
        "_collections_abc.Sequence",
        "_collections_abc.MutableSequence",
        "_collections_abc.ByteString",
        "typing.Tuple",
        "typing.List",
        "typing.Dict",
        "typing.Set",
        "typing.FrozenSet",
        "typing.Deque",
        "typing.DefaultDict",
        "typing.OrderedDict",
        "typing.Counter",
        "typing.ChainMap",
        "typing.Awaitable",
        "typing.Coroutine",
        "typing.AsyncIterable",
        "typing.AsyncIterator",
        "typing.AsyncGenerator",
        "typing.Iterable",
        "typing.Iterator",
        "typing.Generator",
        "typing.Reversible",
        "typing.Container",
        "typing.Collection",
        "typing.AbstractSet",
        "typing.MutableSet",
        "typing.Mapping",
        "typing.MutableMapping",
        "typing.Sequence",
        "typing.MutableSequence",
        "typing.ByteString",
        "typing.MappingView",
        "typing.KeysView",
        "typing.ItemsView",
        "typing.ValuesView",
        "typing.ContextManager",
        "typing.AsyncContextManger",
        "typing.Hashable",
        "typing.Sized",
    )
)


@others
</t>
<t tx="ekr.20220312061835.325">def _is_exempt_from_public_methods(node: astroid.ClassDef) -&gt; bool:
    """Check if a class is exempt from too-few-public-methods"""

    # If it's a typing.Namedtuple, typing.TypedDict or an Enum
    for ancestor in node.ancestors():
        if ancestor.name == "Enum" and ancestor.root().name == "enum":
            return True
        if ancestor.qname() in (TYPING_NAMEDTUPLE, TYPING_TYPEDDICT):
            return True

    # Or if it's a dataclass
    if not node.decorators:
        return False

    root_locals = set(node.root().locals)
    for decorator in node.decorators.nodes:
        if isinstance(decorator, astroid.Call):
            decorator = decorator.func
        if not isinstance(decorator, (astroid.Name, astroid.Attribute)):
            continue
        if isinstance(decorator, astroid.Name):
            name = decorator.name
        else:
            name = decorator.attrname
        if name in DATACLASSES_DECORATORS and (
            root_locals.intersection(DATACLASSES_DECORATORS)
            or DATACLASS_IMPORT in root_locals
        ):
            return True
    return False


</t>
<t tx="ekr.20220312061835.326">def _count_boolean_expressions(bool_op):
    """Counts the number of boolean expressions in BoolOp `bool_op` (recursive)

    example: a and (b or c or (d and e)) ==&gt; 5 boolean expressions
    """
    nb_bool_expr = 0
    for bool_expr in bool_op.get_children():
        if isinstance(bool_expr, astroid.BoolOp):
            nb_bool_expr += _count_boolean_expressions(bool_expr)
        else:
            nb_bool_expr += 1
    return nb_bool_expr


</t>
<t tx="ekr.20220312061835.327">def _count_methods_in_class(node):
    all_methods = sum(1 for method in node.methods() if not method.name.startswith("_"))
    # Special methods count towards the number of public methods,
    # but don't count towards there being too many methods.
    for method in node.mymethods():
        if SPECIAL_OBJ.search(method.name) and method.name != "__init__":
            all_methods += 1
    return all_methods


</t>
<t tx="ekr.20220312061835.328">def _get_parents(
    node: nodes.ClassDef, ignored_parents: FrozenSet[str]
) -&gt; Set[nodes.ClassDef]:
    r"""Get parents of ``node``, excluding ancestors of ``ignored_parents``.

    If we have the following inheritance diagram:

             F
            /
        D  E
         \/
          B  C
           \/
            A      # class A(B, C): ...

    And ``ignored_parents`` is ``{"E"}``, then this function will return
    ``{A, B, C, D}`` -- both ``E`` and its ancestors are excluded.
    """
    parents: Set[nodes.ClassDef] = set()
    to_explore = cast(List[nodes.ClassDef], list(node.ancestors(recurs=False)))
    while to_explore:
        parent = to_explore.pop()
        if parent.qname() in ignored_parents:
            continue
        parents.add(parent)
        to_explore.extend(parent.ancestors(recurs=False))
    return parents


</t>
<t tx="ekr.20220312061835.329">class MisdesignChecker(BaseChecker):
    """checks for sign of poor/misdesign:
    * number of methods, attributes, local variables...
    * size, complexity of functions, methods
    """

    __implements__ = (IAstroidChecker,)

    # configuration section name
    name = "design"
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = (
        (
            "max-args",
            {
                "default": 5,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of arguments for function / method.",
            },
        ),
        (
            "max-locals",
            {
                "default": 15,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of locals for function / method body.",
            },
        ),
        (
            "max-returns",
            {
                "default": 6,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of return / yield for function / "
                "method body.",
            },
        ),
        (
            "max-branches",
            {
                "default": 12,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of branch for function / method body.",
            },
        ),
        (
            "max-statements",
            {
                "default": 50,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of statements in function / method body.",
            },
        ),
        (
            "max-parents",
            {
                "default": 7,
                "type": "int",
                "metavar": "&lt;num&gt;",
                "help": "Maximum number of parents for a class (see R0901).",
            },
        ),
        (
            "ignored-parents",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;comma separated list of class names&gt;",
                "help": "List of qualified class names to ignore when counting class parents (see R0901)",
            },
        ),
        (
            "max-attributes",
            {
                "default": 7,
                "type": "int",
                "metavar": "&lt;num&gt;",
                "help": "Maximum number of attributes for a class \
(see R0902).",
            },
        ),
        (
            "min-public-methods",
            {
                "default": 2,
                "type": "int",
                "metavar": "&lt;num&gt;",
                "help": "Minimum number of public methods for a class \
(see R0903).",
            },
        ),
        (
            "max-public-methods",
            {
                "default": 20,
                "type": "int",
                "metavar": "&lt;num&gt;",
                "help": "Maximum number of public methods for a class \
(see R0904).",
            },
        ),
        (
            "max-bool-expr",
            {
                "default": 5,
                "type": "int",
                "metavar": "&lt;num&gt;",
                "help": "Maximum number of boolean expressions in an if "
                "statement (see R0916).",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.33">def open(self):
    """called before visiting project (i.e set of modules)"""

</t>
<t tx="ekr.20220312061835.330">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self.stats: CheckerStats = {}
    self._returns = None
    self._branches = None
    self._stmts = None

</t>
<t tx="ekr.20220312061835.331">def open(self):
    """initialize visit variables"""
    self.stats = self.linter.add_stats()
    self._returns = []
    self._branches = defaultdict(int)
    self._stmts = []

</t>
<t tx="ekr.20220312061835.332">def _inc_all_stmts(self, amount):
    for i, _ in enumerate(self._stmts):
        self._stmts[i] += amount

</t>
<t tx="ekr.20220312061835.333">@astroid.decorators.cachedproperty
def _ignored_argument_names(self):
    return utils.get_global_option(self, "ignored-argument-names", default=None)

</t>
<t tx="ekr.20220312061835.334">@check_messages(
    "too-many-ancestors",
    "too-many-instance-attributes",
    "too-few-public-methods",
    "too-many-public-methods",
)
</t>
<t tx="ekr.20220312061835.335">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    """check size of inheritance hierarchy and number of instance attributes"""
    parents = _get_parents(
        node, STDLIB_CLASSES_IGNORE_ANCESTOR.union(self.config.ignored_parents)
    )
    nb_parents = len(parents)
    if nb_parents &gt; self.config.max_parents:
        self.add_message(
            "too-many-ancestors",
            node=node,
            args=(nb_parents, self.config.max_parents),
        )

    if len(node.instance_attrs) &gt; self.config.max_attributes:
        self.add_message(
            "too-many-instance-attributes",
            node=node,
            args=(len(node.instance_attrs), self.config.max_attributes),
        )

</t>
<t tx="ekr.20220312061835.336">@check_messages("too-few-public-methods", "too-many-public-methods")
def leave_classdef(self, node: nodes.ClassDef) -&gt; None:
    """check number of public methods"""
    my_methods = sum(
        1 for method in node.mymethods() if not method.name.startswith("_")
    )

    # Does the class contain less than n public methods ?
    # This checks only the methods defined in the current class,
    # since the user might not have control over the classes
    # from the ancestors. It avoids some false positives
    # for classes such as unittest.TestCase, which provides
    # a lot of assert methods. It doesn't make sense to warn
    # when the user subclasses TestCase to add his own tests.
    if my_methods &gt; self.config.max_public_methods:
        self.add_message(
            "too-many-public-methods",
            node=node,
            args=(my_methods, self.config.max_public_methods),
        )

    # Stop here for exception, metaclass, interface classes and other
    # classes for which we don't need to count the methods.
    if node.type != "class" or _is_exempt_from_public_methods(node):
        return

    # Does the class contain more than n public methods ?
    # This checks all the methods defined by ancestors and
    # by the current class.
    all_methods = _count_methods_in_class(node)
    if all_methods &lt; self.config.min_public_methods:
        self.add_message(
            "too-few-public-methods",
            node=node,
            args=(all_methods, self.config.min_public_methods),
        )

</t>
<t tx="ekr.20220312061835.337">@check_messages(
    "too-many-return-statements",
    "too-many-branches",
    "too-many-arguments",
    "too-many-locals",
    "too-many-statements",
    "keyword-arg-before-vararg",
)
</t>
<t tx="ekr.20220312061835.338">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """check function name, docstring, arguments, redefinition,
    variable names, max locals
    """
    # init branch and returns counters
    self._returns.append(0)
    # check number of arguments
    args = node.args.args
    ignored_argument_names = self._ignored_argument_names
    if args is not None:
        ignored_args_num = 0
        if ignored_argument_names:
            ignored_args_num = sum(
                1 for arg in args if ignored_argument_names.match(arg.name)
            )

        argnum = len(args) - ignored_args_num
        if argnum &gt; self.config.max_args:
            self.add_message(
                "too-many-arguments",
                node=node,
                args=(len(args), self.config.max_args),
            )
    else:
        ignored_args_num = 0
    # check number of local variables
    locnum = len(node.locals) - ignored_args_num
    if locnum &gt; self.config.max_locals:
        self.add_message(
            "too-many-locals", node=node, args=(locnum, self.config.max_locals)
        )
    # init new statements counter
    self._stmts.append(1)

</t>
<t tx="ekr.20220312061835.339">visit_asyncfunctiondef = visit_functiondef

@check_messages(
    "too-many-return-statements",
    "too-many-branches",
    "too-many-arguments",
    "too-many-locals",
    "too-many-statements",
)
</t>
<t tx="ekr.20220312061835.34">def close(self):
    """called after visiting project (i.e set of modules)"""


</t>
<t tx="ekr.20220312061835.340">def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """most of the work is done here on close:
    checks for max returns, branch, return in __init__
    """
    returns = self._returns.pop()
    if returns &gt; self.config.max_returns:
        self.add_message(
            "too-many-return-statements",
            node=node,
            args=(returns, self.config.max_returns),
        )
    branches = self._branches[node]
    if branches &gt; self.config.max_branches:
        self.add_message(
            "too-many-branches",
            node=node,
            args=(branches, self.config.max_branches),
        )
    # check number of statements
    stmts = self._stmts.pop()
    if stmts &gt; self.config.max_statements:
        self.add_message(
            "too-many-statements",
            node=node,
            args=(stmts, self.config.max_statements),
        )

</t>
<t tx="ekr.20220312061835.341">leave_asyncfunctiondef = leave_functiondef

</t>
<t tx="ekr.20220312061835.342">def visit_return(self, _: nodes.Return) -&gt; None:
    """count number of returns"""
    if not self._returns:
        return  # return outside function, reported by the base checker
    self._returns[-1] += 1

</t>
<t tx="ekr.20220312061835.343">def visit_default(self, node: nodes.NodeNG) -&gt; None:
    """default visit method -&gt; increments the statements counter if
    necessary
    """
    if node.is_statement:
        self._inc_all_stmts(1)

</t>
<t tx="ekr.20220312061835.344">def visit_tryexcept(self, node: nodes.TryExcept) -&gt; None:
    """increments the branches counter"""
    branches = len(node.handlers)
    if node.orelse:
        branches += 1
    self._inc_branch(node, branches)
    self._inc_all_stmts(branches)

</t>
<t tx="ekr.20220312061835.345">def visit_tryfinally(self, node: nodes.TryFinally) -&gt; None:
    """increments the branches counter"""
    self._inc_branch(node, 2)
    self._inc_all_stmts(2)

</t>
<t tx="ekr.20220312061835.346">@check_messages("too-many-boolean-expressions")
def visit_if(self, node: nodes.If) -&gt; None:
    """increments the branches counter and checks boolean expressions"""
    self._check_boolean_expressions(node)
    branches = 1
    # don't double count If nodes coming from some 'elif'
    if node.orelse and (
        len(node.orelse) &gt; 1 or not isinstance(node.orelse[0], astroid.If)
    ):
        branches += 1
    self._inc_branch(node, branches)
    self._inc_all_stmts(branches)

</t>
<t tx="ekr.20220312061835.347">def _check_boolean_expressions(self, node):
    """Go through "if" node `node` and counts its boolean expressions

    if the "if" node test is a BoolOp node
    """
    condition = node.test
    if not isinstance(condition, astroid.BoolOp):
        return
    nb_bool_expr = _count_boolean_expressions(condition)
    if nb_bool_expr &gt; self.config.max_bool_expr:
        self.add_message(
            "too-many-boolean-expressions",
            node=condition,
            args=(nb_bool_expr, self.config.max_bool_expr),
        )

</t>
<t tx="ekr.20220312061835.348">def visit_while(self, node: nodes.While) -&gt; None:
    """increments the branches counter"""
    branches = 1
    if node.orelse:
        branches += 1
    self._inc_branch(node, branches)

</t>
<t tx="ekr.20220312061835.349">visit_for = visit_while

</t>
<t tx="ekr.20220312061835.35">class IRawChecker(IChecker):
    """interface for checker which need to parse the raw file"""

    @others
</t>
<t tx="ekr.20220312061835.350">def _inc_branch(self, node, branchesnum=1):
    """increments the branches counter"""
    self._branches[node.scope()] += branchesnum


</t>
<t tx="ekr.20220312061835.351">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(MisdesignChecker(linter))
</t>
<t tx="ekr.20220312061835.352">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2011-2014 Google, Inc.
# Copyright (c) 2012 Tim Hatch &lt;tim@timhatch.com&gt;
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Rene Zhang &lt;rz99@cornell.edu&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Steven Myint &lt;hg@stevenmyint.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Erik &lt;erik.eriksson@yahoo.com&gt;
# Copyright (c) 2016 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 Martin von Gagern &lt;gagern@google.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Natalie Serebryakova &lt;natalie.serebryakova@Natalies-MacBook-Pro.local&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Carey Metcalfe &lt;carey@cmetcalfe.ca&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checks for various exception related errors."""
import builtins
import inspect
from typing import Any, List, Optional

import astroid
from astroid import nodes, objects

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.353">def _builtin_exceptions():
    def predicate(obj):
        return isinstance(obj, type) and issubclass(obj, BaseException)

    members = inspect.getmembers(builtins, predicate)
    return {exc.__name__ for (_, exc) in members}


</t>
<t tx="ekr.20220312061835.354">def _annotated_unpack_infer(stmt, context=None):
    """
    Recursively generate nodes inferred by the given statement.
    If the inferred value is a list or a tuple, recurse on the elements.
    Returns an iterator which yields tuples in the format
    ('original node', 'inferred node').
    """
    if isinstance(stmt, (nodes.List, nodes.Tuple)):
        for elt in stmt.elts:
            inferred = utils.safe_infer(elt)
            if inferred and inferred is not astroid.Uninferable:
                yield elt, inferred
        return
    for inferred in stmt.infer(context):
        if inferred is astroid.Uninferable:
            continue
        yield stmt, inferred


</t>
<t tx="ekr.20220312061835.355">def _is_raising(body: List) -&gt; bool:
    """Return true if the given statement node raise an exception"""
    for node in body:
        if isinstance(node, nodes.Raise):
            return True
    return False


</t>
<t tx="ekr.20220312061835.356">OVERGENERAL_EXCEPTIONS = ("BaseException", "Exception")

MSGS = {  # pylint: disable=consider-using-namedtuple-or-dataclass
    "E0701": (
        "Bad except clauses order (%s)",
        "bad-except-order",
        "Used when except clauses are not in the correct order (from the "
        "more specific to the more generic). If you don't fix the order, "
        "some exceptions may not be caught by the most specific handler.",
    ),
    "E0702": (
        "Raising %s while only classes or instances are allowed",
        "raising-bad-type",
        "Used when something which is neither a class, an instance or a "
        "string is raised (i.e. a `TypeError` will be raised).",
    ),
    "E0703": (
        "Exception context set to something which is not an exception, nor None",
        "bad-exception-context",
        'Used when using the syntax "raise ... from ...", '
        "where the exception context is not an exception, "
        "nor None.",
    ),
    "E0704": (
        "The raise statement is not inside an except clause",
        "misplaced-bare-raise",
        "Used when a bare raise is not used inside an except clause. "
        "This generates an error, since there are no active exceptions "
        "to be reraised. An exception to this rule is represented by "
        "a bare raise inside a finally clause, which might work, as long "
        "as an exception is raised inside the try block, but it is "
        "nevertheless a code smell that must not be relied upon.",
    ),
    "E0710": (
        "Raising a new style class which doesn't inherit from BaseException",
        "raising-non-exception",
        "Used when a new style class which doesn't inherit from "
        "BaseException is raised.",
    ),
    "E0711": (
        "NotImplemented raised - should raise NotImplementedError",
        "notimplemented-raised",
        "Used when NotImplemented is raised instead of NotImplementedError",
    ),
    "E0712": (
        "Catching an exception which doesn't inherit from Exception: %s",
        "catching-non-exception",
        "Used when a class which doesn't inherit from "
        "Exception is used as an exception in an except clause.",
    ),
    "W0702": (
        "No exception type(s) specified",
        "bare-except",
        "Used when an except clause doesn't specify exceptions type to catch.",
    ),
    "W0703": (
        "Catching too general exception %s",
        "broad-except",
        "Used when an except catches a too general exception, "
        "possibly burying unrelated errors.",
    ),
    "W0705": (
        "Catching previously caught exception type %s",
        "duplicate-except",
        "Used when an except catches a type that was already caught by "
        "a previous handler.",
    ),
    "W0706": (
        "The except handler raises immediately",
        "try-except-raise",
        "Used when an except handler uses raise as its first or only "
        "operator. This is useless because it raises back the exception "
        "immediately. Remove the raise operator or the entire "
        "try-except-raise block!",
    ),
    "W0707": (
        "Consider explicitly re-raising using the 'from' keyword",
        "raise-missing-from",
        "Python 3's exception chaining means it shows the traceback of the "
        "current exception, but also the original exception. Not using `raise "
        "from` makes the traceback inaccurate, because the message implies "
        "there is a bug in the exception-handling code itself, which is a "
        "separate situation than wrapping an exception.",
    ),
    "W0711": (
        'Exception to catch is the result of a binary "%s" operation',
        "binary-op-exception",
        "Used when the exception to catch is of the form "
        '"except A or B:".  If intending to catch multiple, '
        'rewrite as "except (A, B):"',
    ),
    "W0715": (
        "Exception arguments suggest string formatting might be intended",
        "raising-format-tuple",
        "Used when passing multiple arguments to an exception "
        "constructor, the first of them a string literal containing what "
        "appears to be placeholders intended for formatting",
    ),
    "W0716": (
        "Invalid exception operation. %s",
        "wrong-exception-operation",
        "Used when an operation is done against an exception, but the operation "
        "is not valid for the exception in question. Usually emitted when having "
        "binary operations between exceptions in except handlers.",
    ),
}


</t>
<t tx="ekr.20220312061835.357">class BaseVisitor:
    """Base class for visitors defined in this module."""

    @others
</t>
<t tx="ekr.20220312061835.358">def __init__(self, checker, node):
    self._checker = checker
    self._node = node

</t>
<t tx="ekr.20220312061835.359">def visit(self, node):
    name = node.__class__.__name__.lower()
    dispatch_meth = getattr(self, "visit_" + name, None)
    if dispatch_meth:
        dispatch_meth(node)
    else:
        self.visit_default(node)

</t>
<t tx="ekr.20220312061835.36">def process_module(self, node: nodes.Module) -&gt; None:
    """process a module

    the module's content is accessible via astroid.stream
    """


</t>
<t tx="ekr.20220312061835.360">def visit_default(self, _: nodes.NodeNG) -&gt; None:
    """Default implementation for all the nodes."""


</t>
<t tx="ekr.20220312061835.361">class ExceptionRaiseRefVisitor(BaseVisitor):
    """Visit references (anything that is not an AST leaf)."""

    @others
</t>
<t tx="ekr.20220312061835.362">def visit_name(self, node: nodes.Name) -&gt; None:
    if node.name == "NotImplemented":
        self._checker.add_message("notimplemented-raised", node=self._node)

</t>
<t tx="ekr.20220312061835.363">def visit_call(self, node: nodes.Call) -&gt; None:
    if isinstance(node.func, nodes.Name):
        self.visit_name(node.func)
    if (
        len(node.args) &gt; 1
        and isinstance(node.args[0], nodes.Const)
        and isinstance(node.args[0].value, str)
    ):
        msg = node.args[0].value
        if "%" in msg or ("{" in msg and "}" in msg):
            self._checker.add_message("raising-format-tuple", node=self._node)


</t>
<t tx="ekr.20220312061835.364">class ExceptionRaiseLeafVisitor(BaseVisitor):
    """Visitor for handling leaf kinds of a raise value."""

    @others
</t>
<t tx="ekr.20220312061835.365">def visit_const(self, node: nodes.Const) -&gt; None:
    self._checker.add_message(
        "raising-bad-type", node=self._node, args=node.value.__class__.__name__
    )

</t>
<t tx="ekr.20220312061835.366">def visit_instance(self, instance: objects.ExceptionInstance) -&gt; None:
    # pylint: disable=protected-access
    cls = instance._proxied
    self.visit_classdef(cls)

</t>
<t tx="ekr.20220312061835.367"># Exception instances have a particular class type
visit_exceptioninstance = visit_instance

</t>
<t tx="ekr.20220312061835.368">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    if not utils.inherit_from_std_ex(node) and utils.has_known_bases(node):
        if node.newstyle:
            self._checker.add_message("raising-non-exception", node=self._node)

</t>
<t tx="ekr.20220312061835.369">def visit_tuple(self, _: nodes.Tuple) -&gt; None:
    self._checker.add_message("raising-bad-type", node=self._node, args="tuple")

</t>
<t tx="ekr.20220312061835.37">class ITokenChecker(IChecker):
    """Interface for checkers that need access to the token list."""

    @others
</t>
<t tx="ekr.20220312061835.370">def visit_default(self, node: nodes.NodeNG) -&gt; None:
    name = getattr(node, "name", node.__class__.__name__)
    self._checker.add_message("raising-bad-type", node=self._node, args=name)


</t>
<t tx="ekr.20220312061835.371">class ExceptionsChecker(checkers.BaseChecker):
    """Exception related checks."""

    __implements__ = interfaces.IAstroidChecker

    name = "exceptions"
    msgs = MSGS
    priority = -4
    options = (
        (
            "overgeneral-exceptions",
            {
                "default": OVERGENERAL_EXCEPTIONS,
                "type": "csv",
                "metavar": "&lt;comma-separated class names&gt;",
                "help": "Exceptions that will emit a warning "  # pylint: disable=consider-using-f-string
                'when being caught. Defaults to "%s".'
                % (", ".join(OVERGENERAL_EXCEPTIONS),),
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.372">def open(self):
    self._builtin_exceptions = _builtin_exceptions()
    super().open()

</t>
<t tx="ekr.20220312061835.373">@utils.check_messages(
    "misplaced-bare-raise",
    "raising-bad-type",
    "raising-non-exception",
    "notimplemented-raised",
    "bad-exception-context",
    "raising-format-tuple",
    "raise-missing-from",
)
</t>
<t tx="ekr.20220312061835.374">def visit_raise(self, node: nodes.Raise) -&gt; None:
    if node.exc is None:
        self._check_misplaced_bare_raise(node)
        return

    if node.cause is None:
        self._check_raise_missing_from(node)
    else:
        self._check_bad_exception_context(node)

    expr = node.exc
    ExceptionRaiseRefVisitor(self, node).visit(expr)

    try:
        inferred_value = expr.inferred()[-1]
    except astroid.InferenceError:
        pass
    else:
        if inferred_value:
            ExceptionRaiseLeafVisitor(self, node).visit(inferred_value)

</t>
<t tx="ekr.20220312061835.375">def _check_misplaced_bare_raise(self, node):
    # Filter out if it's present in __exit__.
    scope = node.scope()
    if (
        isinstance(scope, nodes.FunctionDef)
        and scope.is_method()
        and scope.name == "__exit__"
    ):
        return

    current = node
    # Stop when a new scope is generated or when the raise
    # statement is found inside a TryFinally.
    ignores = (nodes.ExceptHandler, nodes.FunctionDef)
    while current and not isinstance(current.parent, ignores):
        current = current.parent

    expected = (nodes.ExceptHandler,)
    if not current or not isinstance(current.parent, expected):
        self.add_message("misplaced-bare-raise", node=node)

</t>
<t tx="ekr.20220312061835.376">def _check_bad_exception_context(self, node: nodes.Raise) -&gt; None:
    """Verify that the exception context is properly set.

    An exception context can be only `None` or an exception.
    """
    cause = utils.safe_infer(node.cause)
    if cause in (astroid.Uninferable, None):
        return

    if isinstance(cause, nodes.Const):
        if cause.value is not None:
            self.add_message("bad-exception-context", node=node)
    elif not isinstance(cause, nodes.ClassDef) and not utils.inherit_from_std_ex(
        cause
    ):
        self.add_message("bad-exception-context", node=node)

</t>
<t tx="ekr.20220312061835.377">def _check_raise_missing_from(self, node: nodes.Raise) -&gt; None:
    if node.exc is None:
        # This is a plain `raise`, raising the previously-caught exception. No need for a
        # cause.
        return
    # We'd like to check whether we're inside an `except` clause:
    containing_except_node = utils.find_except_wrapper_node_in_scope(node)
    if not containing_except_node:
        return
    # We found a surrounding `except`! We're almost done proving there's a
    # `raise-missing-from` here. The only thing we need to protect against is that maybe
    # the `raise` is raising the exception that was caught, possibly with some shenanigans
    # like `exc.with_traceback(whatever)`. We won't analyze these, we'll just assume
    # there's a violation on two simple cases: `raise SomeException(whatever)` and `raise
    # SomeException`.
    if containing_except_node.name is None:
        # The `except` doesn't have an `as exception:` part, meaning there's no way that
        # the `raise` is raising the same exception.
        self.add_message("raise-missing-from", node=node)
    elif isinstance(node.exc, nodes.Call) and isinstance(node.exc.func, nodes.Name):
        # We have a `raise SomeException(whatever)`.
        self.add_message("raise-missing-from", node=node)
    elif (
        isinstance(node.exc, nodes.Name)
        and node.exc.name != containing_except_node.name.name
    ):
        # We have a `raise SomeException`.
        self.add_message("raise-missing-from", node=node)

</t>
<t tx="ekr.20220312061835.378">def _check_catching_non_exception(self, handler, exc, part):
    if isinstance(exc, nodes.Tuple):
        # Check if it is a tuple of exceptions.
        inferred = [utils.safe_infer(elt) for elt in exc.elts]
        if any(node is astroid.Uninferable for node in inferred):
            # Don't emit if we don't know every component.
            return
        if all(
            node
            and (utils.inherit_from_std_ex(node) or not utils.has_known_bases(node))
            for node in inferred
        ):
            return

    if not isinstance(exc, nodes.ClassDef):
        # Don't emit the warning if the inferred stmt
        # is None, but the exception handler is something else,
        # maybe it was redefined.
        if isinstance(exc, nodes.Const) and exc.value is None:
            if (
                isinstance(handler.type, nodes.Const) and handler.type.value is None
            ) or handler.type.parent_of(exc):
                # If the exception handler catches None or
                # the exception component, which is None, is
                # defined by the entire exception handler, then
                # emit a warning.
                self.add_message(
                    "catching-non-exception",
                    node=handler.type,
                    args=(part.as_string(),),
                )
        else:
            self.add_message(
                "catching-non-exception",
                node=handler.type,
                args=(part.as_string(),),
            )
        return

    if (
        not utils.inherit_from_std_ex(exc)
        and exc.name not in self._builtin_exceptions
    ):
        if utils.has_known_bases(exc):
            self.add_message(
                "catching-non-exception", node=handler.type, args=(exc.name,)
            )

</t>
<t tx="ekr.20220312061835.379">def _check_try_except_raise(self, node):
    def gather_exceptions_from_handler(
        handler,
    ) -&gt; Optional[List[nodes.NodeNG]]:
        exceptions: List[nodes.NodeNG] = []
        if handler.type:
            exceptions_in_handler = utils.safe_infer(handler.type)
            if isinstance(exceptions_in_handler, nodes.Tuple):
                exceptions = list(
                    {
                        exception
                        for exception in exceptions_in_handler.elts
                        if isinstance(exception, nodes.Name)
                    }
                )
            elif exceptions_in_handler:
                exceptions = [exceptions_in_handler]
            else:
                # Break when we cannot infer anything reliably.
                return None
        return exceptions

    bare_raise = False
    handler_having_bare_raise = None
    excs_in_bare_handler = []
    for handler in node.handlers:
        if bare_raise:
            # check that subsequent handler is not parent of handler which had bare raise.
            # since utils.safe_infer can fail for bare except, check it before.
            # also break early if bare except is followed by bare except.

            excs_in_current_handler = gather_exceptions_from_handler(handler)
            if not excs_in_current_handler:
                break
            if excs_in_bare_handler is None:
                # It can be `None` when the inference failed
                break
            for exc_in_current_handler in excs_in_current_handler:
                inferred_current = utils.safe_infer(exc_in_current_handler)
                if any(
                    utils.is_subclass_of(utils.safe_infer(e), inferred_current)
                    for e in excs_in_bare_handler
                ):
                    bare_raise = False
                    break

        # `raise` as the first operator inside the except handler
        if _is_raising([handler.body[0]]):
            # flags when there is a bare raise
            if handler.body[0].exc is None:
                bare_raise = True
                handler_having_bare_raise = handler
                excs_in_bare_handler = gather_exceptions_from_handler(handler)
    else:
        if bare_raise:
            self.add_message("try-except-raise", node=handler_having_bare_raise)

</t>
<t tx="ekr.20220312061835.38">def process_tokens(self, tokens):
    """Process a module.

    tokens is a list of all source code tokens in the file.
    """


</t>
<t tx="ekr.20220312061835.380">@utils.check_messages("wrong-exception-operation")
def visit_binop(self, node: nodes.BinOp) -&gt; None:
    if isinstance(node.parent, nodes.ExceptHandler):
        # except (V | A)
        suggestion = f"Did you mean '({node.left.as_string()}, {node.right.as_string()})' instead?"
        self.add_message("wrong-exception-operation", node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.381">@utils.check_messages("wrong-exception-operation")
def visit_compare(self, node: nodes.Compare) -&gt; None:
    if isinstance(node.parent, nodes.ExceptHandler):
        # except (V &lt; A)
        suggestion = f"Did you mean '({node.left.as_string()}, {', '.join(operand.as_string() for _, operand in node.ops)})' instead?"
        self.add_message("wrong-exception-operation", node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.382">@utils.check_messages(
    "bare-except",
    "broad-except",
    "try-except-raise",
    "binary-op-exception",
    "bad-except-order",
    "catching-non-exception",
    "duplicate-except",
)
</t>
<t tx="ekr.20220312061835.383">def visit_tryexcept(self, node: nodes.TryExcept) -&gt; None:
    """check for empty except"""
    self._check_try_except_raise(node)
    exceptions_classes: List[Any] = []
    nb_handlers = len(node.handlers)
    for index, handler in enumerate(node.handlers):
        if handler.type is None:
            if not _is_raising(handler.body):
                self.add_message("bare-except", node=handler)

            # check if an "except:" is followed by some other
            # except
            if index &lt; (nb_handlers - 1):
                msg = "empty except clause should always appear last"
                self.add_message("bad-except-order", node=node, args=msg)

        elif isinstance(handler.type, nodes.BoolOp):
            self.add_message(
                "binary-op-exception", node=handler, args=handler.type.op
            )
        else:
            try:
                excs = list(_annotated_unpack_infer(handler.type))
            except astroid.InferenceError:
                continue

            for part, exc in excs:
                if exc is astroid.Uninferable:
                    continue
                if isinstance(exc, astroid.Instance) and utils.inherit_from_std_ex(
                    exc
                ):
                    # pylint: disable=protected-access
                    exc = exc._proxied

                self._check_catching_non_exception(handler, exc, part)

                if not isinstance(exc, nodes.ClassDef):
                    continue

                exc_ancestors = [
                    anc
                    for anc in exc.ancestors()
                    if isinstance(anc, nodes.ClassDef)
                ]

                for previous_exc in exceptions_classes:
                    if previous_exc in exc_ancestors:
                        msg = f"{previous_exc.name} is an ancestor class of {exc.name}"
                        self.add_message(
                            "bad-except-order", node=handler.type, args=msg
                        )
                if (
                    exc.name in self.config.overgeneral_exceptions
                    and exc.root().name == utils.EXCEPTIONS_MODULE
                    and not _is_raising(handler.body)
                ):
                    self.add_message(
                        "broad-except", args=exc.name, node=handler.type
                    )

                if exc in exceptions_classes:
                    self.add_message(
                        "duplicate-except", args=exc.name, node=handler.type
                    )

            exceptions_classes += [exc for _, exc in excs]


</t>
<t tx="ekr.20220312061835.384">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(ExceptionsChecker(linter))
</t>
<t tx="ekr.20220312061835.385">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2015 Google, Inc.
# Copyright (c) 2013 moxian &lt;aleftmail@inbox.ru&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 frost-nzcr4 &lt;frost.nzcr4@jagmort.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Mike Frysinger &lt;vapier@gentoo.org&gt;
# Copyright (c) 2015 Fabio Natali &lt;me@fabionatali.com&gt;
# Copyright (c) 2015 Harut &lt;yes@harutune.name&gt;
# Copyright (c) 2015 Mihai Balint &lt;balint.mihai@gmail.com&gt;
# Copyright (c) 2015 Pavel Roskin &lt;proski@gnu.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Petr Pulc &lt;petrpulc@gmail.com&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2017, 2019-2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2017 Krzysztof Czapla &lt;k.czapla68@gmail.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 James M. Allen &lt;james.m.allen@gmail.com&gt;
# Copyright (c) 2017 vinnyrose &lt;vinnyrose@users.noreply.github.com&gt;
# Copyright (c) 2018-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2018, 2020 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Michael Hudson-Doyle &lt;michael.hudson@canonical.com&gt;
# Copyright (c) 2018 Natalie Serebryakova &lt;natalie.serebryakova@Natalies-MacBook-Pro.local&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Marcus Nslund &lt;naslundx@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Fureigh &lt;rhys.fureigh@gsa.gov&gt;
# Copyright (c) 2018 Andreas Freimuth &lt;andreas.freimuth@united-bits.de&gt;
# Copyright (c) 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Raphael Gaschignard &lt;raphael@rtpg.co&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Python code format's checker.

By default try to follow Guido's style guide :

https://www.python.org/doc/essays/styleguide/

Some parts of the process_token method is based from The Tab Nanny std module.
"""

import tokenize
from functools import reduce  # pylint: disable=redefined-builtin
from typing import List

from astroid import nodes

from pylint.checkers import BaseTokenChecker
from pylint.checkers.utils import (
    check_messages,
    is_overload_stub,
    is_protocol_class,
    node_frame_class,
)
from pylint.constants import WarningScope
from pylint.interfaces import IAstroidChecker, IRawChecker, ITokenChecker
from pylint.utils.pragma_parser import OPTION_PO, PragmaParserError, parse_pragma

_ASYNC_TOKEN = "async"
_KEYWORD_TOKENS = [
    "assert",
    "del",
    "elif",
    "except",
    "for",
    "if",
    "in",
    "not",
    "raise",
    "return",
    "while",
    "yield",
    "with",
]

_SPACED_OPERATORS = [
    "==",
    "&lt;",
    "&gt;",
    "!=",
    "&lt;&gt;",
    "&lt;=",
    "&gt;=",
    "+=",
    "-=",
    "*=",
    "**=",
    "/=",
    "//=",
    "&amp;=",
    "|=",
    "^=",
    "%=",
    "&gt;&gt;=",
    "&lt;&lt;=",
]
_OPENING_BRACKETS = ["(", "[", "{"]
_CLOSING_BRACKETS = [")", "]", "}"]
_TAB_LENGTH = 8

_EOL = frozenset([tokenize.NEWLINE, tokenize.NL, tokenize.COMMENT])
_JUNK_TOKENS = (tokenize.COMMENT, tokenize.NL)

# Whitespace checking policy constants
_MUST = 0
_MUST_NOT = 1
_IGNORE = 2

MSGS = {
    "C0301": (
        "Line too long (%s/%s)",
        "line-too-long",
        "Used when a line is longer than a given number of characters.",
    ),
    "C0302": (
        "Too many lines in module (%s/%s)",  # was W0302
        "too-many-lines",
        "Used when a module has too many lines, reducing its readability.",
    ),
    "C0303": (
        "Trailing whitespace",
        "trailing-whitespace",
        "Used when there is whitespace between the end of a line and the newline.",
    ),
    "C0304": (
        "Final newline missing",
        "missing-final-newline",
        "Used when the last line in a file is missing a newline.",
    ),
    "C0305": (
        "Trailing newlines",
        "trailing-newlines",
        "Used when there are trailing blank lines in a file.",
    ),
    "W0311": (
        "Bad indentation. Found %s %s, expected %s",
        "bad-indentation",
        "Used when an unexpected number of indentation's tabulations or "
        "spaces has been found.",
    ),
    "W0301": (
        "Unnecessary semicolon",  # was W0106
        "unnecessary-semicolon",
        'Used when a statement is ended by a semi-colon (";"), which '
        "isn't necessary (that's python, not C ;).",
    ),
    "C0321": (
        "More than one statement on a single line",
        "multiple-statements",
        "Used when more than on statement are found on the same line.",
        {"scope": WarningScope.NODE},
    ),
    "C0325": (
        "Unnecessary parens after %r keyword",
        "superfluous-parens",
        "Used when a single item in parentheses follows an if, for, or "
        "other keyword.",
    ),
    "C0327": (
        "Mixed line endings LF and CRLF",
        "mixed-line-endings",
        "Used when there are mixed (LF and CRLF) newline signs in a file.",
    ),
    "C0328": (
        "Unexpected line ending format. There is '%s' while it should be '%s'.",
        "unexpected-line-ending-format",
        "Used when there is different newline than expected.",
    ),
}


@others
</t>
<t tx="ekr.20220312061835.386">def _last_token_on_line_is(tokens, line_end, token):
    return (
        line_end &gt; 0
        and tokens.token(line_end - 1) == token
        or line_end &gt; 1
        and tokens.token(line_end - 2) == token
        and tokens.type(line_end - 1) == tokenize.COMMENT
    )


</t>
<t tx="ekr.20220312061835.387"># The contexts for hanging indents.
# A hanging indented dictionary value after :
HANGING_DICT_VALUE = "dict-value"
# Hanging indentation in an expression.
HANGING = "hanging"
# Hanging indentation in a block header.
HANGING_BLOCK = "hanging-block"
# Continued indentation inside an expression.
CONTINUED = "continued"
# Continued indentation in a block header.
CONTINUED_BLOCK = "continued-block"

SINGLE_LINE = "single"
WITH_BODY = "multi"


</t>
<t tx="ekr.20220312061835.388">class TokenWrapper:
    """A wrapper for readable access to token information."""

    @others
</t>
<t tx="ekr.20220312061835.389">def __init__(self, tokens):
    self._tokens = tokens

</t>
<t tx="ekr.20220312061835.39">class IAstroidChecker(IChecker):
    """interface for checker which prefers receive events according to
    statement type
    """


</t>
<t tx="ekr.20220312061835.390">def token(self, idx):
    return self._tokens[idx][1]

</t>
<t tx="ekr.20220312061835.391">def type(self, idx):
    return self._tokens[idx][0]

</t>
<t tx="ekr.20220312061835.392">def start_line(self, idx):
    return self._tokens[idx][2][0]

</t>
<t tx="ekr.20220312061835.393">def start_col(self, idx):
    return self._tokens[idx][2][1]

</t>
<t tx="ekr.20220312061835.394">def line(self, idx):
    return self._tokens[idx][4]


</t>
<t tx="ekr.20220312061835.395">class FormatChecker(BaseTokenChecker):
    """checks for :
    * unauthorized constructions
    * strict indentation
    * line length
    """

    __implements__ = (ITokenChecker, IAstroidChecker, IRawChecker)

    # configuration section name
    name = "format"
    # messages
    msgs = MSGS
    # configuration options
    # for available dict keys/values see the optik parser 'add_option' method
    options = (
        (
            "max-line-length",
            {
                "default": 100,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of characters on a single line.",
            },
        ),
        (
            "ignore-long-lines",
            {
                "type": "regexp",
                "metavar": "&lt;regexp&gt;",
                "default": r"^\s*(# )?&lt;?https?://\S+&gt;?$",
                "help": (
                    "Regexp for a line that is allowed to be longer than the limit."
                ),
            },
        ),
        (
            "single-line-if-stmt",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": (
                    "Allow the body of an if to be on the same "
                    "line as the test if there is no else."
                ),
            },
        ),
        (
            "single-line-class-stmt",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": (
                    "Allow the body of a class to be on the same "
                    "line as the declaration if body contains "
                    "single statement."
                ),
            },
        ),
        (
            "max-module-lines",
            {
                "default": 1000,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of lines in a module.",
            },
        ),
        (
            "indent-string",
            {
                "default": "    ",
                "type": "non_empty_string",
                "metavar": "&lt;string&gt;",
                "help": "String used as indentation unit. This is usually "
                '"    " (4 spaces) or "\\t" (1 tab).',
            },
        ),
        (
            "indent-after-paren",
            {
                "type": "int",
                "metavar": "&lt;int&gt;",
                "default": 4,
                "help": "Number of spaces of indent required inside a hanging "
                "or continued line.",
            },
        ),
        (
            "expected-line-ending-format",
            {
                "type": "choice",
                "metavar": "&lt;empty or LF or CRLF&gt;",
                "default": "",
                "choices": ["", "LF", "CRLF"],
                "help": (
                    "Expected format of line ending, "
                    "e.g. empty (any line ending), LF or CRLF."
                ),
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.396">def __init__(self, linter=None):
    BaseTokenChecker.__init__(self, linter)
    self._lines = None
    self._visited_lines = None
    self._bracket_stack = [None]

</t>
<t tx="ekr.20220312061835.397">def new_line(self, tokens, line_end, line_start):
    """a new line has been encountered, process it if necessary"""
    if _last_token_on_line_is(tokens, line_end, ";"):
        self.add_message("unnecessary-semicolon", line=tokens.start_line(line_end))

    line_num = tokens.start_line(line_start)
    line = tokens.line(line_start)
    if tokens.type(line_start) not in _JUNK_TOKENS:
        self._lines[line_num] = line.split("\n")[0]
    self.check_lines(line, line_num)

</t>
<t tx="ekr.20220312061835.398">def process_module(self, _node: nodes.Module) -&gt; None:
    pass

</t>
<t tx="ekr.20220312061835.399">def _check_keyword_parentheses(
    self, tokens: List[tokenize.TokenInfo], start: int
) -&gt; None:
    """Check that there are not unnecessary parentheses after a keyword.

    Parens are unnecessary if there is exactly one balanced outer pair on a
    line, and it is followed by a colon, and contains no commas (i.e. is not a
    tuple).

    Args:
    tokens: list of Tokens; the entire list of Tokens.
    start: int; the position of the keyword in the token list.
    """
    # If the next token is not a paren, we're fine.
    if self._bracket_stack[-1] == ":" and tokens[start].string == "for":
        self._bracket_stack.pop()
    if tokens[start + 1].string != "(":
        return
    found_and_or = False
    contains_walrus_operator = False
    walrus_operator_depth = 0
    contains_double_parens = 0
    depth = 0
    keyword_token = str(tokens[start].string)
    line_num = tokens[start].start[0]
    for i in range(start, len(tokens) - 1):
        token = tokens[i]

        # If we hit a newline, then assume any parens were for continuation.
        if token.type == tokenize.NL:
            return
        # Since the walrus operator doesn't exist below python3.8, the tokenizer
        # generates independent tokens
        if (
            token.string == ":="  # &lt;-- python3.8+ path
            or token.string + tokens[i + 1].string == ":="
        ):
            contains_walrus_operator = True
            walrus_operator_depth = depth
        if token.string == "(":
            depth += 1
            if tokens[i + 1].string == "(":
                contains_double_parens = 1
        elif token.string == ")":
            depth -= 1
            if depth:
                if contains_double_parens and tokens[i + 1].string == ")":
                    # For walrus operators in `if (not)` conditions and comprehensions
                    if keyword_token in {"in", "if", "not"}:
                        continue
                    return
                contains_double_parens -= 1
                continue
            # ')' can't happen after if (foo), since it would be a syntax error.
            if tokens[i + 1].string in (":", ")", "]", "}", "in") or tokens[
                i + 1
            ].type in (tokenize.NEWLINE, tokenize.ENDMARKER, tokenize.COMMENT):
                if contains_walrus_operator and walrus_operator_depth - 1 == depth:
                    return
                # The empty tuple () is always accepted.
                if i == start + 2:
                    return
                if keyword_token == "not":
                    if not found_and_or:
                        self.add_message(
                            "superfluous-parens", line=line_num, args=keyword_token
                        )
                elif keyword_token in ("return", "yield"):
                    self.add_message(
                        "superfluous-parens", line=line_num, args=keyword_token
                    )
                elif not found_and_or and keyword_token != "in":
                    self.add_message(
                        "superfluous-parens", line=line_num, args=keyword_token
                    )
            return
        elif depth == 1:
            # This is a tuple, which is always acceptable.
            if token[1] == ",":
                return
            # 'and' and 'or' are the only boolean operators with lower precedence
            # than 'not', so parens are only required when they are found.
            if token[1] in ("and", "or"):
                found_and_or = True
            # A yield inside an expression must always be in parentheses,
            # quit early without error.
            elif token[1] == "yield":
                return
            # A generator expression always has a 'for' token in it, and
            # the 'for' token is only legal inside parens when it is in a
            # generator expression.  The parens are necessary here, so bail
            # without an error.
            elif token[1] == "for":
                return
            # A generator expression can have a 'else' token in it.
            # We check the rest of the tokens to see if any problems incure after
            # the 'else'.
            elif token[1] == "else":
                if "(" in (i.string for i in tokens[i:]):
                    self._check_keyword_parentheses(tokens[i:], 0)
                return

</t>
<t tx="ekr.20220312061835.4">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# mode: python; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4
# -*- vim:fenc=utf-8:ft=python:et:sw=4:ts=4:sts=4

# Copyright (c) 2008-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014 Jakob Normark &lt;jakobnormark@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Manuel Vzquez Acosta &lt;mva.led@gmail.com&gt;
# Copyright (c) 2014 Derek Harland &lt;derek.harland@finq.co.nz&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Mihai Balint &lt;balint.mihai@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 Daniela Plascencia &lt;daplascen@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Ryan McGuire &lt;ryan@enigmacurry.com&gt;
# Copyright (c) 2018 thernstig &lt;30827238+thernstig@users.noreply.github.com&gt;
# Copyright (c) 2018 Radostin Stoyanov &lt;rst0git@users.noreply.github.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Emacs and Flymake compatible Pylint.

This script is for integration with emacs and is compatible with flymake mode.

epylint walks out of python packages before invoking pylint. This avoids
reporting import errors that occur when a module within a package uses the
absolute import path to get another module within this package.

For example:
    - Suppose a package is structured as

        a/__init__.py
        a/b/x.py
        a/c/y.py

   - Then if y.py imports x as "from a.b import x" the following produces pylint
     errors

       cd a/c; pylint y.py

   - The following obviously doesn't

       pylint a/c/y.py

   - As this script will be invoked by emacs within the directory of the file
     we are checking we need to go out of it to avoid these false positives.


You may also use py_run to run pylint with desired options and get back (or not)
its output.
"""
import os
import shlex
import sys
from io import StringIO
from subprocess import PIPE, Popen


@others
if __name__ == "__main__":
    Run()
</t>
<t tx="ekr.20220312061835.40">class IReporter(Interface):
    """reporter collect messages and display results encapsulated in a layout"""

    @others
</t>
<t tx="ekr.20220312061835.400">def _prepare_token_dispatcher(self):
    dispatch = {}
    for tokens, handler in ((_KEYWORD_TOKENS, self._check_keyword_parentheses),):
        for token in tokens:
            dispatch[token] = handler
    return dispatch

</t>
<t tx="ekr.20220312061835.401">def process_tokens(self, tokens):
    """process tokens and search for :

    _ too long lines (i.e. longer than &lt;max_chars&gt;)
    _ optionally bad construct (if given, bad_construct must be a compiled
      regular expression).
    """
    self._bracket_stack = [None]
    indents = [0]
    check_equal = False
    line_num = 0
    self._lines = {}
    self._visited_lines = {}
    token_handlers = self._prepare_token_dispatcher()
    self._last_line_ending = None
    last_blank_line_num = 0
    for idx, (tok_type, token, start, _, line) in enumerate(tokens):
        if start[0] != line_num:
            line_num = start[0]
            # A tokenizer oddity: if an indented line contains a multi-line
            # docstring, the line member of the INDENT token does not contain
            # the full line; therefore we check the next token on the line.
            if tok_type == tokenize.INDENT:
                self.new_line(TokenWrapper(tokens), idx - 1, idx + 1)
            else:
                self.new_line(TokenWrapper(tokens), idx - 1, idx)

        if tok_type == tokenize.NEWLINE:
            # a program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            # If an INDENT appears, setting check_equal is wrong, and will
            # be undone when we see the INDENT.
            check_equal = True
            self._check_line_ending(token, line_num)
        elif tok_type == tokenize.INDENT:
            check_equal = False
            self.check_indent_level(token, indents[-1] + 1, line_num)
            indents.append(indents[-1] + 1)
        elif tok_type == tokenize.DEDENT:
            # there's nothing we need to check here!  what's important is
            # that when the run of DEDENTs ends, the indentation of the
            # program statement (or ENDMARKER) that triggered the run is
            # equal to what's left at the top of the indents stack
            check_equal = True
            if len(indents) &gt; 1:
                del indents[-1]
        elif tok_type == tokenize.NL:
            if not line.strip("\r\n"):
                last_blank_line_num = line_num
        elif tok_type not in (tokenize.COMMENT, tokenize.ENCODING):
            # This is the first concrete token following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER; the "line" argument exposes the leading whitespace
            # for this statement; in the case of ENDMARKER, line is an empty
            # string, so will properly match the empty string with which the
            # "indents" stack was seeded
            if check_equal:
                check_equal = False
                self.check_indent_level(line, indents[-1], line_num)

        if tok_type == tokenize.NUMBER and token.endswith("l"):
            self.add_message("lowercase-l-suffix", line=line_num)

        try:
            handler = token_handlers[token]
        except KeyError:
            pass
        else:
            handler(tokens, idx)

    line_num -= 1  # to be ok with "wc -l"
    if line_num &gt; self.config.max_module_lines:
        # Get the line where the too-many-lines (or its message id)
        # was disabled or default to 1.
        message_definition = self.linter.msgs_store.get_message_definitions(
            "too-many-lines"
        )[0]
        names = (message_definition.msgid, "too-many-lines")
        line = next(
            filter(None, (self.linter._pragma_lineno.get(name) for name in names)),
            1,
        )
        self.add_message(
            "too-many-lines",
            args=(line_num, self.config.max_module_lines),
            line=line,
        )

    # See if there are any trailing lines.  Do not complain about empty
    # files like __init__.py markers.
    if line_num == last_blank_line_num and line_num &gt; 0:
        self.add_message("trailing-newlines", line=line_num)

</t>
<t tx="ekr.20220312061835.402">def _check_line_ending(self, line_ending, line_num):
    # check if line endings are mixed
    if self._last_line_ending is not None:
        # line_ending == "" indicates a synthetic newline added at
        # the end of a file that does not, in fact, end with a
        # newline.
        if line_ending and line_ending != self._last_line_ending:
            self.add_message("mixed-line-endings", line=line_num)

    self._last_line_ending = line_ending

    # check if line ending is as expected
    expected = self.config.expected_line_ending_format
    if expected:
        # reduce multiple \n\n\n\n to one \n
        line_ending = reduce(lambda x, y: x + y if x != y else x, line_ending, "")
        line_ending = "LF" if line_ending == "\n" else "CRLF"
        if line_ending != expected:
            self.add_message(
                "unexpected-line-ending-format",
                args=(line_ending, expected),
                line=line_num,
            )

</t>
<t tx="ekr.20220312061835.403">@check_messages("multiple-statements")
def visit_default(self, node: nodes.NodeNG) -&gt; None:
    """check the node line number and check it if not yet done"""
    if not node.is_statement:
        return
    if not node.root().pure_python:
        return
    prev_sibl = node.previous_sibling()
    if prev_sibl is not None:
        prev_line = prev_sibl.fromlineno
    # The line on which a finally: occurs in a try/finally
    # is not directly represented in the AST. We infer it
    # by taking the last line of the body and adding 1, which
    # should be the line of finally:
    elif (
        isinstance(node.parent, nodes.TryFinally) and node in node.parent.finalbody
    ):
        prev_line = node.parent.body[0].tolineno + 1
    else:
        prev_line = node.parent.statement().fromlineno
    line = node.fromlineno
    assert line, node
    if prev_line == line and self._visited_lines.get(line) != 2:
        self._check_multi_statement_line(node, line)
        return
    if line in self._visited_lines:
        return
    try:
        tolineno = node.blockstart_tolineno
    except AttributeError:
        tolineno = node.tolineno
    assert tolineno, node
    lines = []
    for line in range(line, tolineno + 1):
        self._visited_lines[line] = 1
        try:
            lines.append(self._lines[line].rstrip())
        except KeyError:
            lines.append("")

</t>
<t tx="ekr.20220312061835.404">def _check_multi_statement_line(self, node, line):
    """Check for lines containing multiple statements."""
    # Do not warn about multiple nested context managers
    # in with statements.
    if isinstance(node, nodes.With):
        return
    # For try... except... finally..., the two nodes
    # appear to be on the same line due to how the AST is built.
    if isinstance(node, nodes.TryExcept) and isinstance(
        node.parent, nodes.TryFinally
    ):
        return
    if (
        isinstance(node.parent, nodes.If)
        and not node.parent.orelse
        and self.config.single_line_if_stmt
    ):
        return
    if (
        isinstance(node.parent, nodes.ClassDef)
        and len(node.parent.body) == 1
        and self.config.single_line_class_stmt
    ):
        return

    # Function overloads that use ``Ellipsis`` are exempted.
    if (
        isinstance(node, nodes.Expr)
        and isinstance(node.value, nodes.Const)
        and node.value.value is Ellipsis
    ):
        frame = node.frame()
        if is_overload_stub(frame) or is_protocol_class(node_frame_class(frame)):
            return

    self.add_message("multiple-statements", node=node)
    self._visited_lines[line] = 2

</t>
<t tx="ekr.20220312061835.405">def check_line_ending(self, line: str, i: int) -&gt; None:
    """
    Check that the final newline is not missing and that there is no trailing whitespace.
    """
    if not line.endswith("\n"):
        self.add_message("missing-final-newline", line=i)
        return
    # exclude \f (formfeed) from the rstrip
    stripped_line = line.rstrip("\t\n\r\v ")
    if line[len(stripped_line) :] not in ("\n", "\r\n"):
        self.add_message(
            "trailing-whitespace", line=i, col_offset=len(stripped_line)
        )

</t>
<t tx="ekr.20220312061835.406">def check_line_length(self, line: str, i: int) -&gt; None:
    """
    Check that the line length is less than the authorized value
    """
    max_chars = self.config.max_line_length
    ignore_long_line = self.config.ignore_long_lines
    line = line.rstrip()
    if len(line) &gt; max_chars and not ignore_long_line.search(line):
        self.add_message("line-too-long", line=i, args=(len(line), max_chars))

</t>
<t tx="ekr.20220312061835.407">@staticmethod
def remove_pylint_option_from_lines(options_pattern_obj) -&gt; str:
    """
    Remove the `# pylint ...` pattern from lines
    """
    lines = options_pattern_obj.string
    purged_lines = (
        lines[: options_pattern_obj.start(1)].rstrip()
        + lines[options_pattern_obj.end(1) :]
    )
    return purged_lines

</t>
<t tx="ekr.20220312061835.408">@staticmethod
def is_line_length_check_activated(pylint_pattern_match_object) -&gt; bool:
    """
    Return true if the line length check is activated
    """
    try:
        for pragma in parse_pragma(pylint_pattern_match_object.group(2)):
            if pragma.action == "disable" and "line-too-long" in pragma.messages:
                return False
    except PragmaParserError:
        # Printing useful information dealing with this error is done in the lint package
        pass
    return True

</t>
<t tx="ekr.20220312061835.409">@staticmethod
def specific_splitlines(lines: str) -&gt; List[str]:
    """
    Split lines according to universal newlines except those in a specific sets
    """
    unsplit_ends = {
        "\v",
        "\x0b",
        "\f",
        "\x0c",
        "\x1c",
        "\x1d",
        "\x1e",
        "\x85",
        "\u2028",
        "\u2029",
    }
    res = []
    buffer = ""
    for atomic_line in lines.splitlines(True):
        if atomic_line[-1] not in unsplit_ends:
            res.append(buffer + atomic_line)
            buffer = ""
        else:
            buffer += atomic_line
    return res

</t>
<t tx="ekr.20220312061835.41">def handle_message(self, msg) -&gt; None:
    """Handle the given message object."""

</t>
<t tx="ekr.20220312061835.410">def check_lines(self, lines: str, lineno: int) -&gt; None:
    """
    Check lines have :
        - a final newline
        - no trailing whitespace
        - less than a maximum number of characters
    """
    # we're first going to do a rough check whether any lines in this set
    # go over the line limit. If none of them do, then we don't need to
    # parse out the pylint options later on and can just assume that these
    # lines are clean

    # we'll also handle the line ending check here to avoid double-iteration
    # unless the line lengths are suspect

    max_chars = self.config.max_line_length

    split_lines = self.specific_splitlines(lines)

    for offset, line in enumerate(split_lines):
        self.check_line_ending(line, lineno + offset)

    # hold onto the initial lineno for later
    potential_line_length_warning = False
    for offset, line in enumerate(split_lines):
        # this check is purposefully simple and doesn't rstrip
        # since this is running on every line you're checking it's
        # advantageous to avoid doing a lot of work
        if len(line) &gt; max_chars:
            potential_line_length_warning = True
            break

    # if there were no lines passing the max_chars config, we don't bother
    # running the full line check (as we've met an even more strict condition)
    if not potential_line_length_warning:
        return

    # Line length check may be deactivated through `pylint: disable` comment
    mobj = OPTION_PO.search(lines)
    if mobj:
        if not self.is_line_length_check_activated(mobj):
            # the line length check is deactivated, we can stop here
            return
        # The 'pylint: disable whatever' should not be taken into account for line length count
        lines = self.remove_pylint_option_from_lines(mobj)

    # here we re-run specific_splitlines since we have filtered out pylint options above
    for offset, line in enumerate(self.specific_splitlines(lines)):
        self.check_line_length(line, lineno + offset)

</t>
<t tx="ekr.20220312061835.411">def check_indent_level(self, string, expected, line_num):
    """return the indent level of the string"""
    indent = self.config.indent_string
    if indent == "\\t":  # \t is not interpreted in the configuration file
        indent = "\t"
    level = 0
    unit_size = len(indent)
    while string[:unit_size] == indent:
        string = string[unit_size:]
        level += 1
    suppl = ""
    while string and string[0] in " \t":
        suppl += string[0]
        string = string[1:]
    if level != expected or suppl:
        i_type = "spaces"
        if indent[0] == "\t":
            i_type = "tabs"
        self.add_message(
            "bad-indentation",
            line=line_num,
            args=(level * unit_size + len(suppl), i_type, expected * unit_size),
        )


</t>
<t tx="ekr.20220312061835.412">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(FormatChecker(linter))
</t>
<t tx="ekr.20220312061835.413">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2015 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2013 buck@yelp.com &lt;buck@yelp.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Cezar &lt;celnazli@bitdefender.com&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Noam Yorav-Raphael &lt;noamraph@gmail.com&gt;
# Copyright (c) 2015 James Morgensen &lt;james.morgensen@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 Jared Garst &lt;cultofjared@gmail.com&gt;
# Copyright (c) 2016 Maik Rder &lt;maikroeder@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2017, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 Michka Popoff &lt;michkapopoff@gmail.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 Erik Wright &lt;erik.wright@shopify.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Hornwitser &lt;github@hornwitser.no&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Natalie Serebryakova &lt;natalie.serebryakova@Natalies-MacBook-Pro.local&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Marianna Polatoglou &lt;mpolatoglou@bloomberg.net&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019, 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Nick Smith &lt;clickthisnick@users.noreply.github.com&gt;
# Copyright (c) 2019 Paul Renvois &lt;renvoisepaul@gmail.com&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Will Shanks &lt;wsha@posteo.net&gt;
# Copyright (c) 2021 Matus Valo &lt;matusvalo@users.noreply.github.com&gt;
# Copyright (c) 2021 yushao2 &lt;36848472+yushao2@users.noreply.github.com&gt;
# Copyright (c) 2021 Andrew Howe &lt;howeaj@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""imports checkers for Python code"""

import collections
import copy
import os
import sys
from distutils import sysconfig
from typing import Any, Dict, List, Set, Tuple, Union

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, DeprecatedMixin
from pylint.checkers.utils import (
    check_messages,
    get_import_name,
    is_from_fallback_block,
    is_node_in_guarded_import_block,
    node_ignores_exception,
)
from pylint.exceptions import EmptyReportError
from pylint.graph import DotBackend, get_cycles
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter
from pylint.reporters.ureports.nodes import Paragraph, Section, VerbatimText
from pylint.typing import CheckerStats
from pylint.utils import IsortDriver, get_global_option


@others
</t>
<t tx="ekr.20220312061835.414">def _qualified_names(modname):
    """Split the names of the given module into subparts

    For example,
        _qualified_names('pylint.checkers.ImportsChecker')
    returns
        ['pylint', 'pylint.checkers', 'pylint.checkers.ImportsChecker']
    """
    names = modname.split(".")
    return [".".join(names[0 : i + 1]) for i in range(len(names))]


</t>
<t tx="ekr.20220312061835.415">def _get_first_import(node, context, name, base, level, alias):
    """return the node where [base.]&lt;name&gt; is imported or None if not found"""
    fullname = f"{base}.{name}" if base else name

    first = None
    found = False
    for first in context.body:
        if first is node:
            continue
        if first.scope() is node.scope() and first.fromlineno &gt; node.fromlineno:
            continue
        if isinstance(first, nodes.Import):
            if any(fullname == iname[0] for iname in first.names):
                found = True
                break
        elif isinstance(first, nodes.ImportFrom):
            if level == first.level:
                for imported_name, imported_alias in first.names:
                    if fullname == f"{first.modname}.{imported_name}":
                        found = True
                        break
                    if (
                        name != "*"
                        and name == imported_name
                        and not (alias or imported_alias)
                    ):
                        found = True
                        break
                if found:
                    break
    if found and not astroid.are_exclusive(first, node):
        return first
    return None


</t>
<t tx="ekr.20220312061835.416">def _ignore_import_failure(node, modname, ignored_modules):
    for submodule in _qualified_names(modname):
        if submodule in ignored_modules:
            return True

    if is_node_in_guarded_import_block(node):
        # Ignore import failure if part of guarded import block
        # I.e. `sys.version_info` or `typing.TYPE_CHECKING`
        return True

    return node_ignores_exception(node, ImportError)


</t>
<t tx="ekr.20220312061835.417"># utilities to represents import dependencies as tree and dot graph ###########


</t>
<t tx="ekr.20220312061835.418">def _make_tree_defs(mod_files_list):
    """get a list of 2-uple (module, list_of_files_which_import_this_module),
    it will return a dictionary to represent this as a tree
    """
    tree_defs = {}
    for mod, files in mod_files_list:
        node = (tree_defs, ())
        for prefix in mod.split("."):
            node = node[0].setdefault(prefix, [{}, []])
        node[1] += files
    return tree_defs


</t>
<t tx="ekr.20220312061835.419">def _repr_tree_defs(data, indent_str=None):
    """return a string which represents imports as a tree"""
    lines = []
    nodes_items = data.items()
    for i, (mod, (sub, files)) in enumerate(sorted(nodes_items, key=lambda x: x[0])):
        files = "" if not files else f"({','.join(sorted(files))})"
        if indent_str is None:
            lines.append(f"{mod} {files}")
            sub_indent_str = "  "
        else:
            lines.append(fr"{indent_str}\-{mod} {files}")
            if i == len(nodes_items) - 1:
                sub_indent_str = f"{indent_str}  "
            else:
                sub_indent_str = f"{indent_str}| "
        if sub:
            lines.append(_repr_tree_defs(sub, sub_indent_str))
    return "\n".join(lines)


</t>
<t tx="ekr.20220312061835.42">def display_reports(self, layout: "Section") -&gt; None:
    """display results encapsulated in the layout tree"""


</t>
<t tx="ekr.20220312061835.420">def _dependencies_graph(filename: str, dep_info: Dict[str, List[str]]) -&gt; str:
    """write dependencies as a dot (graphviz) file"""
    done = {}
    printer = DotBackend(os.path.splitext(os.path.basename(filename))[0], rankdir="LR")
    printer.emit('URL="." node[shape="box"]')
    for modname, dependencies in sorted(dep_info.items()):
        done[modname] = 1
        printer.emit_node(modname)
        for depmodname in dependencies:
            if depmodname not in done:
                done[depmodname] = 1
                printer.emit_node(depmodname)
    for depmodname, dependencies in sorted(dep_info.items()):
        for modname in dependencies:
            printer.emit_edge(modname, depmodname)
    return printer.generate(filename)


</t>
<t tx="ekr.20220312061835.421">def _make_graph(
    filename: str, dep_info: Dict[str, List[str]], sect: Section, gtype: str
):
    """generate a dependencies graph and add some information about it in the
    report's section
    """
    outputfile = _dependencies_graph(filename, dep_info)
    sect.append(Paragraph((f"{gtype}imports graph has been written to {outputfile}",)))


</t>
<t tx="ekr.20220312061835.422"># the import checker itself ###################################################

MSGS = {
    "E0401": (
        "Unable to import %s",
        "import-error",
        "Used when pylint has been unable to import a module.",
        {"old_names": [("F0401", "old-import-error")]},
    ),
    "E0402": (
        "Attempted relative import beyond top-level package",
        "relative-beyond-top-level",
        "Used when a relative import tries to access too many levels "
        "in the current package.",
    ),
    "R0401": (
        "Cyclic import (%s)",
        "cyclic-import",
        "Used when a cyclic import between two or more modules is detected.",
    ),
    "R0402": (
        "Use 'from %s import %s' instead",
        "consider-using-from-import",
        "Emitted when a submodule of a package is imported and "
        "aliased with the same name. "
        "E.g., instead of ``import concurrent.futures as futures`` use "
        "``from concurrent import futures``",
    ),
    "W0401": (
        "Wildcard import %s",
        "wildcard-import",
        "Used when `from module import *` is detected.",
    ),
    "W0402": (
        "Uses of a deprecated module %r",
        "deprecated-module",
        "Used a module marked as deprecated is imported.",
    ),
    "W0404": (
        "Reimport %r (imported line %s)",
        "reimported",
        "Used when a module is reimported multiple times.",
    ),
    "W0406": (
        "Module import itself",
        "import-self",
        "Used when a module is importing itself.",
    ),
    "W0407": (
        "Prefer importing %r instead of %r",
        "preferred-module",
        "Used when a module imported has a preferred replacement module.",
    ),
    "W0410": (
        "__future__ import is not the first non docstring statement",
        "misplaced-future",
        "Python 2.5 and greater require __future__ import to be the "
        "first non docstring statement in the module.",
    ),
    "C0410": (
        "Multiple imports on one line (%s)",
        "multiple-imports",
        "Used when import statement importing multiple modules is detected.",
    ),
    "C0411": (
        "%s should be placed before %s",
        "wrong-import-order",
        "Used when PEP8 import order is not respected (standard imports "
        "first, then third-party libraries, then local imports)",
    ),
    "C0412": (
        "Imports from package %s are not grouped",
        "ungrouped-imports",
        "Used when imports are not grouped by packages",
    ),
    "C0413": (
        'Import "%s" should be placed at the top of the module',
        "wrong-import-position",
        "Used when code and imports are mixed",
    ),
    "C0414": (
        "Import alias does not rename original package",
        "useless-import-alias",
        "Used when an import alias is same as original package."
        "e.g using import numpy as numpy instead of import numpy as np",
    ),
    "C0415": (
        "Import outside toplevel (%s)",
        "import-outside-toplevel",
        "Used when an import statement is used anywhere other than the module "
        "toplevel. Move this import to the top of the file.",
    ),
}


DEFAULT_STANDARD_LIBRARY = ()
DEFAULT_KNOWN_THIRD_PARTY = ("enchant",)
DEFAULT_PREFERRED_MODULES = ()


</t>
<t tx="ekr.20220312061835.423">class ImportsChecker(DeprecatedMixin, BaseChecker):
    """checks for
    * external modules dependencies
    * relative / wildcard imports
    * cyclic imports
    * uses of deprecated modules
    * uses of modules instead of preferred modules
    """

    __implements__ = IAstroidChecker

    name = "imports"
    msgs = MSGS
    priority = -2
    default_deprecated_modules = ()

    options = (
        (
            "deprecated-modules",
            {
                "default": default_deprecated_modules,
                "type": "csv",
                "metavar": "&lt;modules&gt;",
                "help": "Deprecated modules which should not be used,"
                " separated by a comma.",
            },
        ),
        (
            "preferred-modules",
            {
                "default": DEFAULT_PREFERRED_MODULES,
                "type": "csv",
                "metavar": "&lt;module:preferred-module&gt;",
                "help": "Couples of modules and preferred modules,"
                " separated by a comma.",
            },
        ),
        (
            "import-graph",
            {
                "default": "",
                "type": "string",
                "metavar": "&lt;file.gv&gt;",
                "help": "Output a graph (.gv or any supported image format) of"
                " all (i.e. internal and external) dependencies to the given file"
                " (report RP0402 must not be disabled).",
            },
        ),
        (
            "ext-import-graph",
            {
                "default": "",
                "type": "string",
                "metavar": "&lt;file.gv&gt;",
                "help": "Output a graph (.gv or any supported image format)"
                " of external dependencies to the given file"
                " (report RP0402 must not be disabled).",
            },
        ),
        (
            "int-import-graph",
            {
                "default": "",
                "type": "string",
                "metavar": "&lt;file.gv&gt;",
                "help": "Output a graph (.gv or any supported image format)"
                " of internal dependencies to the given file"
                " (report RP0402 must not be disabled).",
            },
        ),
        (
            "known-standard-library",
            {
                "default": DEFAULT_STANDARD_LIBRARY,
                "type": "csv",
                "metavar": "&lt;modules&gt;",
                "help": "Force import order to recognize a module as part of "
                "the standard compatibility libraries.",
            },
        ),
        (
            "known-third-party",
            {
                "default": DEFAULT_KNOWN_THIRD_PARTY,
                "type": "csv",
                "metavar": "&lt;modules&gt;",
                "help": "Force import order to recognize a module as part of "
                "a third party library.",
            },
        ),
        (
            "allow-any-import-level",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;modules&gt;",
                "help": (
                    "List of modules that can be imported at any level, not just "
                    "the top level one."
                ),
            },
        ),
        (
            "analyse-fallback-blocks",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Analyse import fallback blocks. This can be used to "
                "support both Python 2 and 3 compatible code, which "
                "means that the block might have code that exists "
                "only in one or another interpreter, leading to false "
                "positives when analysed.",
            },
        ),
        (
            "allow-wildcard-with-all",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Allow wildcard imports from modules that define __all__.",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.424">def __init__(
    self, linter: PyLinter = None
):  # pylint: disable=super-init-not-called # See https://github.com/PyCQA/pylint/issues/4941
    BaseChecker.__init__(self, linter)
    self.stats: CheckerStats = {}
    self.import_graph: collections.defaultdict = collections.defaultdict(set)
    self._imports_stack: List[Tuple[Any, Any]] = []
    self._first_non_import_node = None
    self._module_pkg: Dict[
        Any, Any
    ] = {}  # mapping of modules to the pkg they belong in
    self._allow_any_import_level: Set[Any] = set()
    self.reports = (
        ("RP0401", "External dependencies", self._report_external_dependencies),
        ("RP0402", "Modules dependencies graph", self._report_dependencies_graph),
    )

    self._site_packages = self._compute_site_packages()

</t>
<t tx="ekr.20220312061835.425">@staticmethod
def _compute_site_packages():
    def _normalized_path(path):
        return os.path.normcase(os.path.abspath(path))

    paths = set()
    real_prefix = getattr(sys, "real_prefix", None)
    for prefix in filter(None, (real_prefix, sys.prefix)):
        path = sysconfig.get_python_lib(prefix=prefix)
        path = _normalized_path(path)
        paths.add(path)

    # Handle Debian's derivatives /usr/local.
    if os.path.isfile("/etc/debian_version"):
        for prefix in filter(None, (real_prefix, sys.prefix)):
            libpython = os.path.join(
                prefix,
                "local",
                "lib",
                "python" + sysconfig.get_python_version(),
                "dist-packages",
            )
            paths.add(libpython)
    return paths

</t>
<t tx="ekr.20220312061835.426">def open(self):
    """called before visiting project (i.e set of modules)"""
    self.linter.add_stats(dependencies={})
    self.linter.add_stats(cycles=[])
    self.stats = self.linter.stats
    self.import_graph = collections.defaultdict(set)
    self._module_pkg = {}  # mapping of modules to the pkg they belong in
    self._excluded_edges = collections.defaultdict(set)
    self._ignored_modules = get_global_option(self, "ignored-modules", default=[])
    # Build a mapping {'module': 'preferred-module'}
    self.preferred_modules = dict(
        module.split(":")
        for module in self.config.preferred_modules
        if ":" in module
    )
    self._allow_any_import_level = set(self.config.allow_any_import_level)

</t>
<t tx="ekr.20220312061835.427">def _import_graph_without_ignored_edges(self):
    filtered_graph = copy.deepcopy(self.import_graph)
    for node in filtered_graph:
        filtered_graph[node].difference_update(self._excluded_edges[node])
    return filtered_graph

</t>
<t tx="ekr.20220312061835.428">def close(self):
    """called before visiting project (i.e set of modules)"""
    if self.linter.is_message_enabled("cyclic-import"):
        graph = self._import_graph_without_ignored_edges()
        vertices = list(graph)
        for cycle in get_cycles(graph, vertices=vertices):
            self.add_message("cyclic-import", args=" -&gt; ".join(cycle))

</t>
<t tx="ekr.20220312061835.429">def deprecated_modules(self):
    """Callback returning the deprecated modules."""
    return self.config.deprecated_modules

</t>
<t tx="ekr.20220312061835.43">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""A collection of typing utilities."""
import sys
from typing import TYPE_CHECKING, Dict, List, NamedTuple, Union

if TYPE_CHECKING:
    from typing import Counter  # typing.Counter added in Python 3.6.1

if sys.version_info &gt;= (3, 8):
    from typing import Literal, TypedDict
else:
    from typing_extensions import Literal, TypedDict


@others
# The base type of the "stats" attribute of a checker
CheckerStats = Dict[
    str, Union[int, "Counter[str]", List, Dict[str, Union[int, str, Dict[str, int]]]]
]
</t>
<t tx="ekr.20220312061835.430">@check_messages(*MSGS)
def visit_import(self, node: nodes.Import) -&gt; None:
    """triggered when an import statement is seen"""
    self._check_reimport(node)
    self._check_import_as_rename(node)
    self._check_toplevel(node)

    names = [name for name, _ in node.names]
    if len(names) &gt;= 2:
        self.add_message("multiple-imports", args=", ".join(names), node=node)

    for name in names:
        self.check_deprecated_module(node, name)
        self._check_preferred_module(node, name)
        imported_module = self._get_imported_module(node, name)
        if isinstance(node.parent, nodes.Module):
            # Allow imports nested
            self._check_position(node)
        if isinstance(node.scope(), nodes.Module):
            self._record_import(node, imported_module)

        if imported_module is None:
            continue

        self._add_imported_module(node, imported_module.name)

</t>
<t tx="ekr.20220312061835.431">@check_messages(*MSGS)
def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """triggered when a from statement is seen"""
    basename = node.modname
    imported_module = self._get_imported_module(node, basename)

    self._check_import_as_rename(node)
    self._check_misplaced_future(node)
    self.check_deprecated_module(node, basename)
    self._check_preferred_module(node, basename)
    self._check_wildcard_imports(node, imported_module)
    self._check_same_line_imports(node)
    self._check_reimport(node, basename=basename, level=node.level)
    self._check_toplevel(node)

    if isinstance(node.parent, nodes.Module):
        # Allow imports nested
        self._check_position(node)
    if isinstance(node.scope(), nodes.Module):
        self._record_import(node, imported_module)
    if imported_module is None:
        return
    for name, _ in node.names:
        if name != "*":
            self._add_imported_module(node, f"{imported_module.name}.{name}")
        else:
            self._add_imported_module(node, imported_module.name)

</t>
<t tx="ekr.20220312061835.432">@check_messages(*MSGS)
def leave_module(self, node: nodes.Module) -&gt; None:
    # Check imports are grouped by category (standard, 3rd party, local)
    std_imports, ext_imports, loc_imports = self._check_imports_order(node)

    # Check that imports are grouped by package within a given category
    met_import: Set[str] = set()  # set for 'import x' style
    met_from: Set[str] = set()  # set for 'from x import y' style
    current_package = None
    for import_node, import_name in std_imports + ext_imports + loc_imports:
        if not self.linter.is_message_enabled(
            "ungrouped-imports", import_node.fromlineno
        ):
            continue
        met = met_from if isinstance(import_node, nodes.ImportFrom) else met_import
        package, _, _ = import_name.partition(".")
        if (
            current_package
            and current_package != package
            and package in met
            and is_node_in_guarded_import_block(import_node) is False
        ):
            self.add_message("ungrouped-imports", node=import_node, args=package)
        current_package = package
        met.add(package)

    self._imports_stack = []
    self._first_non_import_node = None

</t>
<t tx="ekr.20220312061835.433">def compute_first_non_import_node(self, node):
    if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
        return
    # if the node does not contain an import instruction, and if it is the
    # first node of the module, keep a track of it (all the import positions
    # of the module will be compared to the position of this first
    # instruction)
    if self._first_non_import_node:
        return
    if not isinstance(node.parent, nodes.Module):
        return
    nested_allowed = [nodes.TryExcept, nodes.TryFinally]
    is_nested_allowed = [
        allowed for allowed in nested_allowed if isinstance(node, allowed)
    ]
    if is_nested_allowed and any(
        node.nodes_of_class((nodes.Import, nodes.ImportFrom))
    ):
        return
    if isinstance(node, nodes.Assign):
        # Add compatibility for module level dunder names
        # https://www.python.org/dev/peps/pep-0008/#module-level-dunder-names
        valid_targets = [
            isinstance(target, nodes.AssignName)
            and target.name.startswith("__")
            and target.name.endswith("__")
            for target in node.targets
        ]
        if all(valid_targets):
            return
    self._first_non_import_node = node

</t>
<t tx="ekr.20220312061835.434">visit_tryfinally = (
    visit_tryexcept
) = (
    visit_assignattr
) = (
    visit_assign
) = (
    visit_ifexp
) = visit_comprehension = visit_expr = visit_if = compute_first_non_import_node

</t>
<t tx="ekr.20220312061835.435">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    if not self.linter.is_message_enabled("wrong-import-position", node.fromlineno):
        return
    # If it is the first non import instruction of the module, record it.
    if self._first_non_import_node:
        return

    # Check if the node belongs to an `If` or a `Try` block. If they
    # contain imports, skip recording this node.
    if not isinstance(node.parent.scope(), nodes.Module):
        return

    root = node
    while not isinstance(root.parent, nodes.Module):
        root = root.parent

    if isinstance(root, (nodes.If, nodes.TryFinally, nodes.TryExcept)):
        if any(root.nodes_of_class((nodes.Import, nodes.ImportFrom))):
            return

    self._first_non_import_node = node

</t>
<t tx="ekr.20220312061835.436">visit_classdef = visit_for = visit_while = visit_functiondef

</t>
<t tx="ekr.20220312061835.437">def _check_misplaced_future(self, node):
    basename = node.modname
    if basename == "__future__":
        # check if this is the first non-docstring statement in the module
        prev = node.previous_sibling()
        if prev:
            # consecutive future statements are possible
            if not (
                isinstance(prev, nodes.ImportFrom) and prev.modname == "__future__"
            ):
                self.add_message("misplaced-future", node=node)
        return

</t>
<t tx="ekr.20220312061835.438">def _check_same_line_imports(self, node):
    # Detect duplicate imports on the same line.
    names = (name for name, _ in node.names)
    counter = collections.Counter(names)
    for name, count in counter.items():
        if count &gt; 1:
            self.add_message("reimported", node=node, args=(name, node.fromlineno))

</t>
<t tx="ekr.20220312061835.439">def _check_position(self, node):
    """Check `node` import or importfrom node position is correct

    Send a message  if `node` comes before another instruction
    """
    # if a first non-import instruction has already been encountered,
    # it means the import comes after it and therefore is not well placed
    if self._first_non_import_node:
        self.add_message("wrong-import-position", node=node, args=node.as_string())

</t>
<t tx="ekr.20220312061835.44">class FileItem(NamedTuple):
    """Represents data about a file handled by pylint

    Each file item has:
    - name: full name of the module
    - filepath: path of the file
    - modname: module name
    """

    name: str
    filepath: str
    modpath: str


</t>
<t tx="ekr.20220312061835.440">def _record_import(self, node, importedmodnode):
    """Record the package `node` imports from"""
    if isinstance(node, nodes.ImportFrom):
        importedname = node.modname
    else:
        importedname = importedmodnode.name if importedmodnode else None
    if not importedname:
        importedname = node.names[0][0].split(".")[0]

    if isinstance(node, nodes.ImportFrom) and (node.level or 0) &gt;= 1:
        # We need the importedname with first point to detect local package
        # Example of node:
        #  'from .my_package1 import MyClass1'
        #  the output should be '.my_package1' instead of 'my_package1'
        # Example of node:
        #  'from . import my_package2'
        #  the output should be '.my_package2' instead of '{pyfile}'
        importedname = "." + importedname

    self._imports_stack.append((node, importedname))

</t>
<t tx="ekr.20220312061835.441">@staticmethod
def _is_fallback_import(node, imports):
    imports = [import_node for (import_node, _) in imports]
    return any(astroid.are_exclusive(import_node, node) for import_node in imports)

</t>
<t tx="ekr.20220312061835.442">def _check_imports_order(self, _module_node):
    """Checks imports of module `node` are grouped by category

    Imports must follow this order: standard, 3rd party, local
    """
    std_imports = []
    third_party_imports = []
    first_party_imports = []
    # need of a list that holds third or first party ordered import
    external_imports = []
    local_imports = []
    third_party_not_ignored = []
    first_party_not_ignored = []
    local_not_ignored = []
    isort_driver = IsortDriver(self.config)
    for node, modname in self._imports_stack:
        if modname.startswith("."):
            package = "." + modname.split(".")[1]
        else:
            package = modname.split(".")[0]
        nested = not isinstance(node.parent, nodes.Module)
        ignore_for_import_order = not self.linter.is_message_enabled(
            "wrong-import-order", node.fromlineno
        )
        import_category = isort_driver.place_module(package)
        node_and_package_import = (node, package)
        if import_category in ("FUTURE", "STDLIB"):
            std_imports.append(node_and_package_import)
            wrong_import = (
                third_party_not_ignored
                or first_party_not_ignored
                or local_not_ignored
            )
            if self._is_fallback_import(node, wrong_import):
                continue
            if wrong_import and not nested:
                self.add_message(
                    "wrong-import-order",
                    node=node,
                    args=(
                        f'standard import "{node.as_string()}"',
                        f'"{wrong_import[0][0].as_string()}"',
                    ),
                )
        elif import_category == "THIRDPARTY":
            third_party_imports.append(node_and_package_import)
            external_imports.append(node_and_package_import)
            if not nested and not ignore_for_import_order:
                third_party_not_ignored.append(node_and_package_import)
            wrong_import = first_party_not_ignored or local_not_ignored
            if wrong_import and not nested:
                self.add_message(
                    "wrong-import-order",
                    node=node,
                    args=(
                        f'third party import "{node.as_string()}"',
                        f'"{wrong_import[0][0].as_string()}"',
                    ),
                )
        elif import_category == "FIRSTPARTY":
            first_party_imports.append(node_and_package_import)
            external_imports.append(node_and_package_import)
            if not nested and not ignore_for_import_order:
                first_party_not_ignored.append(node_and_package_import)
            wrong_import = local_not_ignored
            if wrong_import and not nested:
                self.add_message(
                    "wrong-import-order",
                    node=node,
                    args=(
                        f'first party import "{node.as_string()}"',
                        f'"{wrong_import[0][0].as_string()}"',
                    ),
                )
        elif import_category == "LOCALFOLDER":
            local_imports.append((node, package))
            if not nested and not ignore_for_import_order:
                local_not_ignored.append((node, package))
    return std_imports, external_imports, local_imports

</t>
<t tx="ekr.20220312061835.443">def _get_imported_module(self, importnode, modname):
    try:
        return importnode.do_import_module(modname)
    except astroid.TooManyLevelsError:
        if _ignore_import_failure(importnode, modname, self._ignored_modules):
            return None
        self.add_message("relative-beyond-top-level", node=importnode)
    except astroid.AstroidSyntaxError as exc:
        message = f"Cannot import {modname!r} due to syntax error {str(exc.error)!r}"  # pylint: disable=no-member; false positive
        self.add_message("syntax-error", line=importnode.lineno, args=message)

    except astroid.AstroidBuildingException:
        if not self.linter.is_message_enabled("import-error"):
            return None
        if _ignore_import_failure(importnode, modname, self._ignored_modules):
            return None
        if not self.config.analyse_fallback_blocks and is_from_fallback_block(
            importnode
        ):
            return None

        dotted_modname = get_import_name(importnode, modname)
        self.add_message("import-error", args=repr(dotted_modname), node=importnode)
    return None

</t>
<t tx="ekr.20220312061835.444">def _add_imported_module(
    self, node: Union[nodes.Import, nodes.ImportFrom], importedmodname: str
) -&gt; None:
    """notify an imported module, used to analyze dependencies"""
    module_file = node.root().file
    context_name = node.root().name
    base = os.path.splitext(os.path.basename(module_file))[0]

    try:
        importedmodname = astroid.modutils.get_module_part(
            importedmodname, module_file
        )
    except ImportError:
        pass

    in_type_checking_block = (
        isinstance(node.parent, nodes.If) and node.parent.is_typing_guard()
    )

    if context_name == importedmodname:
        self.add_message("import-self", node=node)

    elif not astroid.modutils.is_standard_module(importedmodname):
        # if this is not a package __init__ module
        if base != "__init__" and context_name not in self._module_pkg:
            # record the module's parent, or the module itself if this is
            # a top level module, as the package it belongs to
            self._module_pkg[context_name] = context_name.rsplit(".", 1)[0]

        # handle dependencies
        dependencies_stat: Dict[str, Union[Set]] = self.stats["dependencies"]  # type: ignore
        importedmodnames = dependencies_stat.setdefault(importedmodname, set())
        if context_name not in importedmodnames:
            importedmodnames.add(context_name)

        # update import graph
        self.import_graph[context_name].add(importedmodname)
        if (
            not self.linter.is_message_enabled("cyclic-import", line=node.lineno)
            or in_type_checking_block
        ):
            self._excluded_edges[context_name].add(importedmodname)

</t>
<t tx="ekr.20220312061835.445">def _check_preferred_module(self, node, mod_path):
    """check if the module has a preferred replacement"""
    if mod_path in self.preferred_modules:
        self.add_message(
            "preferred-module",
            node=node,
            args=(self.preferred_modules[mod_path], mod_path),
        )

</t>
<t tx="ekr.20220312061835.446">def _check_import_as_rename(
    self, node: Union[nodes.Import, nodes.ImportFrom]
) -&gt; None:
    names = node.names
    for name in names:
        if not all(name):
            return

        splitted_packages = name[0].rsplit(".", maxsplit=1)
        import_name = splitted_packages[-1]
        aliased_name = name[1]
        if import_name != aliased_name:
            continue

        if len(splitted_packages) == 1:
            self.add_message("useless-import-alias", node=node)
        elif len(splitted_packages) == 2:
            self.add_message(
                "consider-using-from-import",
                node=node,
                args=(splitted_packages[0], import_name),
            )

</t>
<t tx="ekr.20220312061835.447">def _check_reimport(self, node, basename=None, level=None):
    """check if the import is necessary (i.e. not already done)"""
    if not self.linter.is_message_enabled("reimported"):
        return

    frame = node.frame()
    root = node.root()
    contexts = [(frame, level)]
    if root is not frame:
        contexts.append((root, None))

    for known_context, known_level in contexts:
        for name, alias in node.names:
            first = _get_first_import(
                node, known_context, name, basename, known_level, alias
            )
            if first is not None:
                self.add_message(
                    "reimported", node=node, args=(name, first.fromlineno)
                )

</t>
<t tx="ekr.20220312061835.448">def _report_external_dependencies(self, sect, _, _dummy):
    """return a verbatim layout for displaying dependencies"""
    dep_info = _make_tree_defs(self._external_dependencies_info().items())
    if not dep_info:
        raise EmptyReportError()
    tree_str = _repr_tree_defs(dep_info)
    sect.append(VerbatimText(tree_str))

</t>
<t tx="ekr.20220312061835.449">def _report_dependencies_graph(self, sect, _, _dummy):
    """write dependencies as a dot (graphviz) file"""
    dep_info = self.stats["dependencies"]
    if not dep_info or not (
        self.config.import_graph
        or self.config.ext_import_graph
        or self.config.int_import_graph
    ):
        raise EmptyReportError()
    filename = self.config.import_graph
    if filename:
        _make_graph(filename, dep_info, sect, "")
    filename = self.config.ext_import_graph
    if filename:
        _make_graph(filename, self._external_dependencies_info(), sect, "external ")
    filename = self.config.int_import_graph
    if filename:
        _make_graph(filename, self._internal_dependencies_info(), sect, "internal ")

</t>
<t tx="ekr.20220312061835.45">class ModuleDescriptionDict(TypedDict):
    """Represents data about a checked module"""

    path: str
    name: str
    isarg: bool
    basepath: str
    basename: str


</t>
<t tx="ekr.20220312061835.450">def _filter_dependencies_graph(self, internal):
    """build the internal or the external dependency graph"""
    graph = collections.defaultdict(set)
    for importee, importers in self.stats["dependencies"].items():
        for importer in importers:
            package = self._module_pkg.get(importer, importer)
            is_inside = importee.startswith(package)
            if is_inside and internal or not is_inside and not internal:
                graph[importee].add(importer)
    return graph

</t>
<t tx="ekr.20220312061835.451">@astroid.decorators.cached
def _external_dependencies_info(self):
    """return cached external dependencies information or build and
    cache them
    """
    return self._filter_dependencies_graph(internal=False)

</t>
<t tx="ekr.20220312061835.452">@astroid.decorators.cached
def _internal_dependencies_info(self):
    """return cached internal dependencies information or build and
    cache them
    """
    return self._filter_dependencies_graph(internal=True)

</t>
<t tx="ekr.20220312061835.453">def _check_wildcard_imports(self, node, imported_module):
    if node.root().package:
        # Skip the check if in __init__.py issue #2026
        return

    wildcard_import_is_allowed = self._wildcard_import_is_allowed(imported_module)
    for name, _ in node.names:
        if name == "*" and not wildcard_import_is_allowed:
            self.add_message("wildcard-import", args=node.modname, node=node)

</t>
<t tx="ekr.20220312061835.454">def _wildcard_import_is_allowed(self, imported_module):
    return (
        self.config.allow_wildcard_with_all
        and imported_module is not None
        and "__all__" in imported_module.locals
    )

</t>
<t tx="ekr.20220312061835.455">def _check_toplevel(self, node):
    """Check whether the import is made outside the module toplevel."""
    # If the scope of the import is a module, then obviously it is
    # not outside the module toplevel.
    if isinstance(node.scope(), nodes.Module):
        return

    module_names = [
        f"{node.modname}.{name[0]}"
        if isinstance(node, nodes.ImportFrom)
        else name[0]
        for name in node.names
    ]

    # Get the full names of all the imports that are only allowed at the module level
    scoped_imports = [
        name for name in module_names if name not in self._allow_any_import_level
    ]

    if scoped_imports:
        self.add_message(
            "import-outside-toplevel", args=", ".join(scoped_imports), node=node
        )


</t>
<t tx="ekr.20220312061835.456">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(ImportsChecker(linter))
</t>
<t tx="ekr.20220312061835.457">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2009-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009, 2012, 2014 Google, Inc.
# Copyright (c) 2012 Mike Bryant &lt;leachim@leachim.info&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2019-2020 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 Chris Murray &lt;chris@chrismurray.scot&gt;
# Copyright (c) 2017 guillaume2 &lt;guillaume.peillex@gmail.col&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018 Alan Chan &lt;achan961117@gmail.com&gt;
# Copyright (c) 2018 Yury Gribov &lt;tetra2005@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Mariatta Wijaya &lt;mariatta@python.org&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;
# Copyright (c) 2019 Svet &lt;svet@hyperscience.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""checker for use of Python logging
"""
import string
from typing import Set

import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils
from pylint.checkers.utils import check_messages, infer_all

MSGS = {  # pylint: disable=consider-using-namedtuple-or-dataclass
    "W1201": (
        "Use %s formatting in logging functions",
        "logging-not-lazy",
        "Used when a logging statement has a call form of "
        '"logging.&lt;logging method&gt;(format_string % (format_args...))". '
        "Use another type of string formatting instead. "
        "You can use % formatting but leave interpolation to "
        "the logging function by passing the parameters as arguments. "
        "If logging-fstring-interpolation is disabled then "
        "you can use fstring formatting. "
        "If logging-format-interpolation is disabled then "
        "you can use str.format.",
    ),
    "W1202": (
        "Use %s formatting in logging functions",
        "logging-format-interpolation",
        "Used when a logging statement has a call form of "
        '"logging.&lt;logging method&gt;(format_string.format(format_args...))". '
        "Use another type of string formatting instead. "
        "You can use % formatting but leave interpolation to "
        "the logging function by passing the parameters as arguments. "
        "If logging-fstring-interpolation is disabled then "
        "you can use fstring formatting. "
        "If logging-not-lazy is disabled then "
        "you can use % formatting as normal.",
    ),
    "W1203": (
        "Use %s formatting in logging functions",
        "logging-fstring-interpolation",
        "Used when a logging statement has a call form of "
        '"logging.&lt;logging method&gt;(f"...")".'
        "Use another type of string formatting instead. "
        "You can use % formatting but leave interpolation to "
        "the logging function by passing the parameters as arguments. "
        "If logging-format-interpolation is disabled then "
        "you can use str.format. "
        "If logging-not-lazy is disabled then "
        "you can use % formatting as normal.",
    ),
    "E1200": (
        "Unsupported logging format character %r (%#02x) at index %d",
        "logging-unsupported-format",
        "Used when an unsupported format character is used in a logging "
        "statement format string.",
    ),
    "E1201": (
        "Logging format string ends in middle of conversion specifier",
        "logging-format-truncated",
        "Used when a logging statement format string terminates before "
        "the end of a conversion specifier.",
    ),
    "E1205": (
        "Too many arguments for logging format string",
        "logging-too-many-args",
        "Used when a logging format string is given too many arguments.",
    ),
    "E1206": (
        "Not enough arguments for logging format string",
        "logging-too-few-args",
        "Used when a logging format string is given too few arguments.",
    ),
}


CHECKED_CONVENIENCE_FUNCTIONS = {
    "critical",
    "debug",
    "error",
    "exception",
    "fatal",
    "info",
    "warn",
    "warning",
}


@others
</t>
<t tx="ekr.20220312061835.458">def is_method_call(func, types=(), methods=()):
    """Determines if a BoundMethod node represents a method call.

    Args:
      func (astroid.BoundMethod): The BoundMethod AST node to check.
      types (Optional[String]): Optional sequence of caller type names to restrict check.
      methods (Optional[String]): Optional sequence of method names to restrict check.

    Returns:
      bool: true if the node represents a method call for the given type and
      method names, False otherwise.
    """
    return (
        isinstance(func, astroid.BoundMethod)
        and isinstance(func.bound, astroid.Instance)
        and (func.bound.name in types if types else True)
        and (func.name in methods if methods else True)
    )


</t>
<t tx="ekr.20220312061835.459">class LoggingChecker(checkers.BaseChecker):
    """Checks use of the logging module."""

    __implements__ = interfaces.IAstroidChecker
    name = "logging"
    msgs = MSGS

    options = (
        (
            "logging-modules",
            {
                "default": ("logging",),
                "type": "csv",
                "metavar": "&lt;comma separated list&gt;",
                "help": "Logging modules to check that the string format "
                "arguments are in logging function parameter format.",
            },
        ),
        (
            "logging-format-style",
            {
                "default": "old",
                "type": "choice",
                "metavar": "&lt;old (%) or new ({)&gt;",
                "choices": ["old", "new"],
                "help": "The type of string formatting that logging methods do. "
                "`old` means using % formatting, `new` is for `{}` formatting.",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.46">class ErrorDescriptionDict(TypedDict):
    """Represents data about errors collected during checking of a module"""

    key: Literal["fatal"]
    mod: str
    ex: Union[ImportError, SyntaxError]


</t>
<t tx="ekr.20220312061835.460">def visit_module(self, _: nodes.Module) -&gt; None:
    """Clears any state left in this checker from last module checked."""
    # The code being checked can just as easily "import logging as foo",
    # so it is necessary to process the imports and store in this field
    # what name the logging module is actually given.
    self._logging_names: Set[str] = set()
    logging_mods = self.config.logging_modules

    self._format_style = self.config.logging_format_style

    self._logging_modules = set(logging_mods)
    self._from_imports = {}
    for logging_mod in logging_mods:
        parts = logging_mod.rsplit(".", 1)
        if len(parts) &gt; 1:
            self._from_imports[parts[0]] = parts[1]

</t>
<t tx="ekr.20220312061835.461">def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """Checks to see if a module uses a non-Python logging module."""
    try:
        logging_name = self._from_imports[node.modname]
        for module, as_name in node.names:
            if module == logging_name:
                self._logging_names.add(as_name or module)
    except KeyError:
        pass

</t>
<t tx="ekr.20220312061835.462">def visit_import(self, node: nodes.Import) -&gt; None:
    """Checks to see if this module uses Python's built-in logging."""
    for module, as_name in node.names:
        if module in self._logging_modules:
            self._logging_names.add(as_name or module)

</t>
<t tx="ekr.20220312061835.463">@check_messages(*MSGS)
def visit_call(self, node: nodes.Call) -&gt; None:
    """Checks calls to logging methods."""

    def is_logging_name():
        return (
            isinstance(node.func, nodes.Attribute)
            and isinstance(node.func.expr, nodes.Name)
            and node.func.expr.name in self._logging_names
        )

    def is_logger_class():
        for inferred in infer_all(node.func):
            if isinstance(inferred, astroid.BoundMethod):
                parent = inferred._proxied.parent
                if isinstance(parent, nodes.ClassDef) and (
                    parent.qname() == "logging.Logger"
                    or any(
                        ancestor.qname() == "logging.Logger"
                        for ancestor in parent.ancestors()
                    )
                ):
                    return True, inferred._proxied.name
        return False, None

    if is_logging_name():
        name = node.func.attrname
    else:
        result, name = is_logger_class()
        if not result:
            return
    self._check_log_method(node, name)

</t>
<t tx="ekr.20220312061835.464">def _check_log_method(self, node, name):
    """Checks calls to logging.log(level, format, *format_args)."""
    if name == "log":
        if node.starargs or node.kwargs or len(node.args) &lt; 2:
            # Either a malformed call, star args, or double-star args. Beyond
            # the scope of this checker.
            return
        format_pos = 1
    elif name in CHECKED_CONVENIENCE_FUNCTIONS:
        if node.starargs or node.kwargs or not node.args:
            # Either no args, star args, or double-star args. Beyond the
            # scope of this checker.
            return
        format_pos = 0
    else:
        return

    if isinstance(node.args[format_pos], nodes.BinOp):
        binop = node.args[format_pos]
        emit = binop.op == "%"
        if binop.op == "+":
            total_number_of_strings = sum(
                1
                for operand in (binop.left, binop.right)
                if self._is_operand_literal_str(utils.safe_infer(operand))
            )
            emit = total_number_of_strings &gt; 0
        if emit:
            self.add_message(
                "logging-not-lazy",
                node=node,
                args=(self._helper_string(node),),
            )
    elif isinstance(node.args[format_pos], nodes.Call):
        self._check_call_func(node.args[format_pos])
    elif isinstance(node.args[format_pos], nodes.Const):
        self._check_format_string(node, format_pos)
    elif isinstance(node.args[format_pos], nodes.JoinedStr):
        self.add_message(
            "logging-fstring-interpolation",
            node=node,
            args=(self._helper_string(node),),
        )

</t>
<t tx="ekr.20220312061835.465">def _helper_string(self, node):
    """Create a string that lists the valid types of formatting for this node."""
    valid_types = ["lazy %"]

    if not self.linter.is_message_enabled(
        "logging-fstring-formatting", node.fromlineno
    ):
        valid_types.append("fstring")
    if not self.linter.is_message_enabled(
        "logging-format-interpolation", node.fromlineno
    ):
        valid_types.append(".format()")
    if not self.linter.is_message_enabled("logging-not-lazy", node.fromlineno):
        valid_types.append("%")

    return " or ".join(valid_types)

</t>
<t tx="ekr.20220312061835.466">@staticmethod
def _is_operand_literal_str(operand):
    """
    Return True if the operand in argument is a literal string
    """
    return isinstance(operand, nodes.Const) and operand.name == "str"

</t>
<t tx="ekr.20220312061835.467">def _check_call_func(self, node: nodes.Call):
    """Checks that function call is not format_string.format()."""
    func = utils.safe_infer(node.func)
    types = ("str", "unicode")
    methods = ("format",)
    if (
        isinstance(func, astroid.BoundMethod)
        and is_method_call(func, types, methods)
        and not is_complex_format_str(func.bound)
    ):
        self.add_message(
            "logging-format-interpolation",
            node=node,
            args=(self._helper_string(node),),
        )

</t>
<t tx="ekr.20220312061835.468">def _check_format_string(self, node, format_arg):
    """Checks that format string tokens match the supplied arguments.

    Args:
      node (nodes.NodeNG): AST node to be checked.
      format_arg (int): Index of the format string in the node arguments.
    """
    num_args = _count_supplied_tokens(node.args[format_arg + 1 :])
    if not num_args:
        # If no args were supplied the string is not interpolated and can contain
        # formatting characters - it's used verbatim. Don't check any further.
        return

    format_string = node.args[format_arg].value
    required_num_args = 0
    if isinstance(format_string, bytes):
        format_string = format_string.decode()
    if isinstance(format_string, str):
        try:
            if self._format_style == "old":
                keyword_args, required_num_args, _, _ = utils.parse_format_string(
                    format_string
                )
                if keyword_args:
                    # Keyword checking on logging strings is complicated by
                    # special keywords - out of scope.
                    return
            elif self._format_style == "new":
                (
                    keyword_arguments,
                    implicit_pos_args,
                    explicit_pos_args,
                ) = utils.parse_format_method_string(format_string)

                keyword_args_cnt = len(
                    {k for k, l in keyword_arguments if not isinstance(k, int)}
                )
                required_num_args = (
                    keyword_args_cnt + implicit_pos_args + explicit_pos_args
                )
        except utils.UnsupportedFormatCharacter as ex:
            char = format_string[ex.index]
            self.add_message(
                "logging-unsupported-format",
                node=node,
                args=(char, ord(char), ex.index),
            )
            return
        except utils.IncompleteFormatString:
            self.add_message("logging-format-truncated", node=node)
            return
    if num_args &gt; required_num_args:
        self.add_message("logging-too-many-args", node=node)
    elif num_args &lt; required_num_args:
        self.add_message("logging-too-few-args", node=node)


</t>
<t tx="ekr.20220312061835.469">def is_complex_format_str(node):
    """Checks if node represents a string with complex formatting specs.

    Args:
        node (nodes.NodeNG): AST node to check
    Returns:
        bool: True if inferred string uses complex formatting, False otherwise
    """
    inferred = utils.safe_infer(node)
    if inferred is None or not (
        isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)
    ):
        return True
    try:
        parsed = list(string.Formatter().parse(inferred.value))
    except ValueError:
        # This format string is invalid
        return False
    for _, _, format_spec, _ in parsed:
        if format_spec:
            return True
    return False


</t>
<t tx="ekr.20220312061835.47">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Copyright (c) 2008, 2012 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2014, 2016-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2020-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import os
import sys

from pylint.__pkginfo__ import __version__

# pylint: disable=import-outside-toplevel


@others
version = __version__
__all__ = ["__version__", "version", "modify_sys_path"]
</t>
<t tx="ekr.20220312061835.470">def _count_supplied_tokens(args):
    """Counts the number of tokens in an args list.

    The Python log functions allow for special keyword arguments: func,
    exc_info and extra. To handle these cases correctly, we only count
    arguments that aren't keywords.

    Args:
      args (list): AST nodes that are arguments for a log format string.

    Returns:
      int: Number of AST nodes that aren't keywords.
    """
    return sum(1 for arg in args if not isinstance(arg, nodes.Keyword))


</t>
<t tx="ekr.20220312061835.471">def register(linter):
    """Required method to auto-register this checker."""
    linter.register_checker(LoggingChecker(linter))
</t>
<t tx="ekr.20220312061835.472">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2020 Frank Harrison &lt;frank@doublethefish.com&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
import abc


@others
</t>
<t tx="ekr.20220312061835.473">class MapReduceMixin(metaclass=abc.ABCMeta):
    """A mixin design to allow multiprocess/threaded runs of a Checker"""

    @others
</t>
<t tx="ekr.20220312061835.474">@abc.abstractmethod
def get_map_data(self):
    """Returns mergable/reducible data that will be examined"""

</t>
<t tx="ekr.20220312061835.475">@classmethod
@abc.abstractmethod
def reduce_map_data(cls, linter, data):
    """For a given Checker, receives data for all mapped runs"""
</t>
<t tx="ekr.20220312061835.476">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006, 2009-2013 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Alexandru Coman &lt;fcoman@bitdefender.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 glegoux &lt;gilles.legoux@gmail.com&gt;
# Copyright (c) 2017-2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 Mikhail Fesenko &lt;proggga@gmail.com&gt;
# Copyright (c) 2018 Rogalski, Lukasz &lt;lukasz.rogalski@intel.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 wtracy &lt;afishionado@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2020 Benny &lt;benny.mueller91@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Konstantina Saketou &lt;56515303+ksaketou@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


"""Check source code is ascii only or has an encoding declaration (PEP 263)"""

import re
import tokenize
from typing import Optional

from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.interfaces import IRawChecker, ITokenChecker
from pylint.message import MessagesHandlerMixIn
from pylint.utils.pragma_parser import OPTION_PO, PragmaParserError, parse_pragma


@others
</t>
<t tx="ekr.20220312061835.477">class ByIdManagedMessagesChecker(BaseChecker):

    """Checks for messages that are enabled or disabled by id instead of symbol."""

    __implements__ = IRawChecker
    name = "miscellaneous"
    msgs = {
        "I0023": (
            "%s",
            "use-symbolic-message-instead",
            "Used when a message is enabled or disabled by id.",
        )
    }
    options = ()

    @others
</t>
<t tx="ekr.20220312061835.478">def process_module(self, node: nodes.Module) -&gt; None:
    """Inspect the source file to find messages activated or deactivated by id."""
    managed_msgs = MessagesHandlerMixIn.get_by_id_managed_msgs()
    for (mod_name, msgid, symbol, lineno, is_disabled) in managed_msgs:
        if mod_name == node.name:
            verb = "disable" if is_disabled else "enable"
            txt = f"'{msgid}' is cryptic: use '# pylint: {verb}={symbol}' instead"
            self.add_message("use-symbolic-message-instead", line=lineno, args=txt)
    MessagesHandlerMixIn.clear_by_id_managed_msgs()


</t>
<t tx="ekr.20220312061835.479">class EncodingChecker(BaseChecker):

    """checks for:
    * warning notes in the code like FIXME, XXX
    * encoding issues.
    """

    __implements__ = (IRawChecker, ITokenChecker)

    # configuration section name
    name = "miscellaneous"
    msgs = {
        "W0511": (
            "%s",
            "fixme",
            "Used when a warning note as FIXME or XXX is detected.",
        )
    }

    options = (
        (
            "notes",
            {
                "type": "csv",
                "metavar": "&lt;comma separated values&gt;",
                "default": ("FIXME", "XXX", "TODO"),
                "help": (
                    "List of note tags to take in consideration, "
                    "separated by a comma."
                ),
            },
        ),
        (
            "notes-rgx",
            {
                "type": "string",
                "metavar": "&lt;regexp&gt;",
                "help": "Regular expression of note tags to take in consideration.",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.48">def run_pylint():
    from pylint.lint import Run as PylintRun

    try:
        PylintRun(sys.argv[1:])
    except KeyboardInterrupt:
        sys.exit(1)


</t>
<t tx="ekr.20220312061835.480">def open(self):
    super().open()

    notes = "|".join(re.escape(note) for note in self.config.notes)
    if self.config.notes_rgx:
        regex_string = fr"#\s*({notes}|{self.config.notes_rgx})\b"
    else:
        regex_string = fr"#\s*({notes})\b"

    self._fixme_pattern = re.compile(regex_string, re.I)

</t>
<t tx="ekr.20220312061835.481">def _check_encoding(
    self, lineno: int, line: bytes, file_encoding: str
) -&gt; Optional[str]:
    try:
        return line.decode(file_encoding)
    except UnicodeDecodeError:
        pass
    except LookupError:
        if (
            line.startswith(b"#")
            and "coding" in str(line)
            and file_encoding in str(line)
        ):
            msg = f"Cannot decode using encoding '{file_encoding}', bad encoding"
            self.add_message("syntax-error", line=lineno, args=msg)
    return None

</t>
<t tx="ekr.20220312061835.482">def process_module(self, node: nodes.Module) -&gt; None:
    """inspect the source file to find encoding problem"""
    encoding = node.file_encoding if node.file_encoding else "ascii"

    with node.stream() as stream:
        for lineno, line in enumerate(stream):
            self._check_encoding(lineno + 1, line, encoding)

</t>
<t tx="ekr.20220312061835.483">def process_tokens(self, tokens):
    """inspect the source to find fixme problems"""
    if not self.config.notes:
        return
    comments = (
        token_info for token_info in tokens if token_info.type == tokenize.COMMENT
    )
    for comment in comments:
        comment_text = comment.string[1:].lstrip()  # trim '#' and whitespaces

        # handle pylint disable clauses
        disable_option_match = OPTION_PO.search(comment_text)
        if disable_option_match:
            try:
                values = []
                try:
                    for pragma_repr in (
                        p_rep
                        for p_rep in parse_pragma(disable_option_match.group(2))
                        if p_rep.action == "disable"
                    ):
                        values.extend(pragma_repr.messages)
                except PragmaParserError:
                    # Printing useful information dealing with this error is done in the lint package
                    pass
                if set(values) &amp; set(self.config.notes):
                    continue
            except ValueError:
                self.add_message(
                    "bad-inline-option",
                    args=disable_option_match.group(1).strip(),
                    line=comment.start[0],
                )
                continue

        # emit warnings if necessary
        match = self._fixme_pattern.search("#" + comment_text.lower())
        if match:
            self.add_message(
                "fixme",
                col_offset=comment.start[1] + 1,
                args=comment_text,
                line=comment.start[0],
            )


</t>
<t tx="ekr.20220312061835.484">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(EncodingChecker(linter))
    linter.register_checker(ByIdManagedMessagesChecker(linter))
</t>
<t tx="ekr.20220312061835.485">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006, 2008-2011, 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2016 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Natalie Serebryakova &lt;natalie.serebryakova@Natalies-MacBook-Pro.local&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Robert Schweizer &lt;robert_schweizer@gmx.de&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""check for new / old style related problems
"""
import astroid
from astroid import nodes

from pylint.checkers import BaseChecker
from pylint.checkers.utils import check_messages, has_known_bases, node_frame_class
from pylint.interfaces import IAstroidChecker

MSGS = {
    "E1003": (
        "Bad first argument %r given to super()",
        "bad-super-call",
        "Used when another argument than the current class is given as "
        "first argument of the super builtin.",
    )
}


@others
</t>
<t tx="ekr.20220312061835.486">class NewStyleConflictChecker(BaseChecker):
    """checks for usage of new style capabilities on old style classes and
    other new/old styles conflicts problems
    * use of property, __slots__, super
    * "super" usage
    """

    __implements__ = (IAstroidChecker,)

    # configuration section name
    name = "newstyle"
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = ()

    @others
    visit_asyncfunctiondef = visit_functiondef


</t>
<t tx="ekr.20220312061835.487">@check_messages("bad-super-call")
def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """check use of super"""
    # ignore actual functions or method within a new style class
    if not node.is_method():
        return
    klass = node.parent.frame()
    for stmt in node.nodes_of_class(nodes.Call):
        if node_frame_class(stmt) != node_frame_class(node):
            # Don't look down in other scopes.
            continue

        expr = stmt.func
        if not isinstance(expr, nodes.Attribute):
            continue

        call = expr.expr
        # skip the test if using super
        if not (
            isinstance(call, nodes.Call)
            and isinstance(call.func, nodes.Name)
            and call.func.name == "super"
        ):
            continue

        # super should not be used on an old style class
        if klass.newstyle or not has_known_bases(klass):
            # super first arg should not be the class
            if not call.args:
                continue

            # calling super(type(self), self) can lead to recursion loop
            # in derived classes
            arg0 = call.args[0]
            if (
                isinstance(arg0, nodes.Call)
                and isinstance(arg0.func, nodes.Name)
                and arg0.func.name == "type"
            ):
                self.add_message("bad-super-call", node=call, args=("type",))
                continue

            # calling super(self.__class__, self) can lead to recursion loop
            # in derived classes
            if (
                len(call.args) &gt;= 2
                and isinstance(call.args[1], nodes.Name)
                and call.args[1].name == "self"
                and isinstance(arg0, nodes.Attribute)
                and arg0.attrname == "__class__"
            ):
                self.add_message(
                    "bad-super-call", node=call, args=("self.__class__",)
                )
                continue

            try:
                supcls = call.args and next(call.args[0].infer(), None)
            except astroid.InferenceError:
                continue

            if klass is not supcls:
                name = None
                # if supcls is not Uninferable, then supcls was inferred
                # and use its name. Otherwise, try to look
                # for call.args[0].name
                if supcls:
                    name = supcls.name
                elif call.args and hasattr(call.args[0], "name"):
                    name = call.args[0].name
                if name:
                    self.add_message("bad-super-call", node=call, args=(name,))

</t>
<t tx="ekr.20220312061835.488">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(NewStyleConflictChecker(linter))
</t>
<t tx="ekr.20220312061835.489">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2007, 2010, 2013, 2015 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2013 Google, Inc.
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2015 Mike Frysinger &lt;vapier@gentoo.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import tokenize
from typing import Any, Optional, Union

from pylint.checkers import BaseTokenChecker
from pylint.exceptions import EmptyReportError
from pylint.interfaces import ITokenChecker
from pylint.reporters.ureports.nodes import Table
from pylint.typing import CheckerStats
from pylint.utils import diff_string


@others
</t>
<t tx="ekr.20220312061835.49">def run_epylint():
    from pylint.epylint import Run as EpylintRun

    EpylintRun()


</t>
<t tx="ekr.20220312061835.490">def report_raw_stats(
    sect,
    stats: CheckerStats,
    old_stats: CheckerStats,
):
    """calculate percentage of code / doc / comment / empty"""
    total_lines: int = stats["total_lines"]  # type: ignore
    if not total_lines:
        raise EmptyReportError()
    sect.description = f"{total_lines} lines have been analyzed"
    lines = ["type", "number", "%", "previous", "difference"]
    for node_type in ("code", "docstring", "comment", "empty"):
        key = node_type + "_lines"
        total: int = stats[key]  # type: ignore
        percent = float(total * 100) / total_lines
        old: Optional[Union[int, str]] = old_stats.get(key, None)  # type: ignore
        if old is not None:
            diff_str = diff_string(old, total)
        else:
            old, diff_str = "NC", "NC"
        lines += [node_type, str(total), f"{percent:.2f}", str(old), diff_str]
    sect.append(Table(children=lines, cols=5, rheaders=1))


</t>
<t tx="ekr.20220312061835.491">class RawMetricsChecker(BaseTokenChecker):
    """does not check anything but gives some raw metrics :
    * total number of lines
    * total number of code lines
    * total number of docstring lines
    * total number of comments lines
    * total number of empty lines
    """

    __implements__ = (ITokenChecker,)

    # configuration section name
    name = "metrics"
    # configuration options
    options = ()
    # messages
    msgs: Any = {}
    # reports
    reports = (("RP0701", "Raw metrics", report_raw_stats),)

    @others
</t>
<t tx="ekr.20220312061835.492">def __init__(self, linter):
    BaseTokenChecker.__init__(self, linter)
    self.stats: CheckerStats = {}

</t>
<t tx="ekr.20220312061835.493">def open(self):
    """init statistics"""
    self.stats = self.linter.add_stats(
        total_lines=0,
        code_lines=0,
        empty_lines=0,
        docstring_lines=0,
        comment_lines=0,
    )

</t>
<t tx="ekr.20220312061835.494">def process_tokens(self, tokens):
    """update stats"""
    i = 0
    tokens = list(tokens)
    while i &lt; len(tokens):
        i, lines_number, line_type = get_type(tokens, i)
        self.stats["total_lines"] += lines_number
        self.stats[line_type] += lines_number


</t>
<t tx="ekr.20220312061835.495">JUNK = (tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER)


</t>
<t tx="ekr.20220312061835.496">def get_type(tokens, start_index):
    """return the line type : docstring, comment, code, empty"""
    i = start_index
    start = tokens[i][2]
    pos = start
    line_type = None
    while i &lt; len(tokens) and tokens[i][2][0] == start[0]:
        tok_type = tokens[i][0]
        pos = tokens[i][3]
        if line_type is None:
            if tok_type == tokenize.STRING:
                line_type = "docstring_lines"
            elif tok_type == tokenize.COMMENT:
                line_type = "comment_lines"
            elif tok_type in JUNK:
                pass
            else:
                line_type = "code_lines"
        i += 1
    if line_type is None:
        line_type = "empty_lines"
    elif i &lt; len(tokens) and tokens[i][0] == tokenize.NEWLINE:
        i += 1
    return i, pos[0] - start[0] + 1, line_type


</t>
<t tx="ekr.20220312061835.497">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(RawMetricsChecker(linter))
</t>
<t tx="ekr.20220312061835.498">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006, 2008-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2012 Ry4an Brase &lt;ry4an-hg@ry4an.org&gt;
# Copyright (c) 2012 Google, Inc.
# Copyright (c) 2012 Anthony VEREZ &lt;anthony.verez.external@cassidian.com&gt;
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2017, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2017 Mikhail Fesenko &lt;proggga@gmail.com&gt;
# Copyright (c) 2018 Scott Worley &lt;scottworley@scottworley.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Taewon D. Kim &lt;kimt33@mcmaster.ca&gt;
# Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Frank Harrison &lt;frank@doublethefish.com&gt;
# Copyright (c) 2020 Eli Fine &lt;ejfine@gmail.com&gt;
# Copyright (c) 2020 Shiv Venkatasubrahmanyam &lt;shvenkat@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Maksym Humetskyi &lt;Humetsky@gmail.com&gt;
# Copyright (c) 2021 bot &lt;bot@noreply.github.com&gt;
# Copyright (c) 2021 Aditya Gupta &lt;adityagupta1089@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

# pylint: disable=redefined-builtin
"""a similarities / code duplication command line tool and pylint checker

The algorithm is based on comparing the hash value of n successive lines of a file.
First the files are read and any line that doesn't fullfill requirement are removed (comments, docstrings...)
Those stripped lines are stored in the LineSet class which gives access to them.
Then each index of the stripped lines collection is associated with the hash of n successive entries of the stripped lines starting at the current index
(n is the minimum common lines option).
The common hashes between both linesets are then looked for. If there are matches, then the match indices in both linesets are stored and associated
with the corresponding couples (start line number/end line number) in both files.
This association is then postprocessed to handle the case of successive matches. For example if the minimum common lines setting is set to four, then
the hashes are computed with four lines. If one of match indices couple (12, 34) is the successor of another one (11, 33) then it means that there are
in fact five lines wich are common.
Once postprocessed the values of association table are the result looked for, i.e start and end lines numbers of common lines in both files.
"""
import copy
import functools
import itertools
import operator
import re
import sys
from collections import defaultdict
from getopt import getopt
from io import BufferedIOBase, BufferedReader, BytesIO
from itertools import chain, groupby
from typing import (
    Any,
    Dict,
    FrozenSet,
    Generator,
    Iterable,
    List,
    NamedTuple,
    NewType,
    Optional,
    Set,
    TextIO,
    Tuple,
    Union,
)

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, MapReduceMixin, table_lines_from_stats
from pylint.interfaces import IRawChecker
from pylint.reporters.ureports.nodes import Table
from pylint.typing import CheckerStats
from pylint.utils import decoding_stream

DEFAULT_MIN_SIMILARITY_LINE = 4

REGEX_FOR_LINES_WITH_CONTENT = re.compile(r".*\w+")

# Index defines a location in a LineSet stripped lines collection
Index = NewType("Index", int)

# LineNumber defines a location in a LinesSet real lines collection (the whole file lines)
LineNumber = NewType("LineNumber", int)


@others
if __name__ == "__main__":
    Run()
</t>
<t tx="ekr.20220312061835.499"># LineSpecifs holds characteristics of a line in a file
class LineSpecifs(NamedTuple):
    line_number: LineNumber
    text: str


</t>
<t tx="ekr.20220312061835.5">def _get_env():
    """Extracts the environment PYTHONPATH and appends the current sys.path to
    those."""
    env = dict(os.environ)
    env["PYTHONPATH"] = os.pathsep.join(sys.path)
    return env


</t>
<t tx="ekr.20220312061835.50">def run_pyreverse():
    """run pyreverse"""
    from pylint.pyreverse.main import Run as PyreverseRun

    PyreverseRun(sys.argv[1:])


</t>
<t tx="ekr.20220312061835.500"># Links LinesChunk object to the starting indices (in lineset's stripped lines)
# of the different chunk of linesthat are used to compute the hash
HashToIndex_T = Dict["LinesChunk", List[Index]]

# Links index in the lineset's stripped lines to the real lines in the file
IndexToLines_T = Dict[Index, "SuccessiveLinesLimits"]

# The types the streams read by pylint can take. Originating from astroid.nodes.Module.stream() and open()
STREAM_TYPES = Union[TextIO, BufferedReader, BytesIO]


</t>
<t tx="ekr.20220312061835.501">class CplSuccessiveLinesLimits:
    """
    This class holds a couple of SuccessiveLinesLimits objects, one for each file compared,
    and a counter on the number of common lines between both stripped lines collections extracted
    from both files
    """

    __slots__ = ("first_file", "second_file", "effective_cmn_lines_nb")

    @others
</t>
<t tx="ekr.20220312061835.502">def __init__(
    self,
    first_file: "SuccessiveLinesLimits",
    second_file: "SuccessiveLinesLimits",
    effective_cmn_lines_nb: int,
) -&gt; None:
    self.first_file = first_file
    self.second_file = second_file
    self.effective_cmn_lines_nb = effective_cmn_lines_nb


</t>
<t tx="ekr.20220312061835.503"># Links the indices ot the starting line in both lineset's stripped lines to
# the start and end lines in both files
CplIndexToCplLines_T = Dict["LineSetStartCouple", CplSuccessiveLinesLimits]


</t>
<t tx="ekr.20220312061835.504">class LinesChunk:
    """
    The LinesChunk object computes and stores the hash of some consecutive stripped lines of a lineset.
    """

    __slots__ = ("_fileid", "_index", "_hash")

    @others
</t>
<t tx="ekr.20220312061835.505">def __init__(self, fileid: str, num_line: int, *lines: Iterable[str]) -&gt; None:
    self._fileid: str = fileid
    """The name of the file from which the LinesChunk object is generated """

    self._index: Index = Index(num_line)
    """The index in the stripped lines that is the starting of consecutive lines"""

    self._hash: int = sum(hash(lin) for lin in lines)
    """The hash of some consecutive lines"""

</t>
<t tx="ekr.20220312061835.506">def __eq__(self, o: Any) -&gt; bool:
    if not isinstance(o, LinesChunk):
        return NotImplemented
    return self._hash == o._hash

</t>
<t tx="ekr.20220312061835.507">def __hash__(self) -&gt; int:
    return self._hash

</t>
<t tx="ekr.20220312061835.508">def __repr__(self) -&gt; str:
    return (
        f"&lt;LinesChunk object for file {self._fileid} ({self._index}, {self._hash})&gt;"
    )

</t>
<t tx="ekr.20220312061835.509">def __str__(self) -&gt; str:
    return (
        f"LinesChunk object for file {self._fileid}, starting at line {self._index} \n"
        f"Hash is {self._hash}"
    )


</t>
<t tx="ekr.20220312061835.51">def run_symilar():
    """run symilar"""
    from pylint.checkers.similar import Run as SimilarRun

    SimilarRun(sys.argv[1:])


</t>
<t tx="ekr.20220312061835.510">class SuccessiveLinesLimits:
    """
    A class to handle the numbering of begin and end of successive lines.

    :note: Only the end line number can be updated.
    """

    __slots__ = ("_start", "_end")

    @others
</t>
<t tx="ekr.20220312061835.511">def __init__(self, start: LineNumber, end: LineNumber) -&gt; None:
    self._start: LineNumber = start
    self._end: LineNumber = end

</t>
<t tx="ekr.20220312061835.512">@property
def start(self) -&gt; LineNumber:
    return self._start

</t>
<t tx="ekr.20220312061835.513">@property
def end(self) -&gt; LineNumber:
    return self._end

</t>
<t tx="ekr.20220312061835.514">@end.setter
def end(self, value: LineNumber) -&gt; None:
    self._end = value

</t>
<t tx="ekr.20220312061835.515">def __repr__(self) -&gt; str:
    return f"&lt;SuccessiveLinesLimits &lt;{self._start};{self._end}&gt;&gt;"


</t>
<t tx="ekr.20220312061835.516">class LineSetStartCouple(NamedTuple):
    """
    Indices in both linesets that mark the beginning of successive lines
    """

    fst_lineset_index: Index
    snd_lineset_index: Index

    @others
</t>
<t tx="ekr.20220312061835.517">def __repr__(self) -&gt; str:
    return (
        f"&lt;LineSetStartCouple &lt;{self.fst_lineset_index};{self.snd_lineset_index}&gt;&gt;"
    )

</t>
<t tx="ekr.20220312061835.518">def __eq__(self, other) -&gt; bool:
    if not isinstance(other, LineSetStartCouple):
        return NotImplemented
    return (
        self.fst_lineset_index == other.fst_lineset_index
        and self.snd_lineset_index == other.snd_lineset_index
    )

</t>
<t tx="ekr.20220312061835.519">def __hash__(self) -&gt; int:
    return hash(self.fst_lineset_index) + hash(self.snd_lineset_index)

</t>
<t tx="ekr.20220312061835.52">def modify_sys_path() -&gt; None:
    """Modify sys path for execution as Python module.

    Strip out the current working directory from sys.path.
    Having the working directory in `sys.path` means that `pylint` might
    inadvertently import user code from modules having the same name as
    stdlib or pylint's own modules.
    CPython issue: https://bugs.python.org/issue33053

    - Remove the first entry. This will always be either "" or the working directory
    - Remove the working directory from the second and third entries
      if PYTHONPATH includes a ":" at the beginning or the end.
      https://github.com/PyCQA/pylint/issues/3636
      Don't remove it if PYTHONPATH contains the cwd or '.' as the entry will
      only be added once.
    - Don't remove the working directory from the rest. It will be included
      if pylint is installed in an editable configuration (as the last item).
      https://github.com/PyCQA/pylint/issues/4161
    """
    sys.path.pop(0)
    env_pythonpath = os.environ.get("PYTHONPATH", "")
    cwd = os.getcwd()
    if env_pythonpath.startswith(":") and env_pythonpath not in (f":{cwd}", ":."):
        sys.path.pop(0)
    elif env_pythonpath.endswith(":") and env_pythonpath not in (f"{cwd}:", ".:"):
        sys.path.pop(1)


</t>
<t tx="ekr.20220312061835.520">def increment(self, value: Index) -&gt; "LineSetStartCouple":
    return LineSetStartCouple(
        Index(self.fst_lineset_index + value),
        Index(self.snd_lineset_index + value),
    )


</t>
<t tx="ekr.20220312061835.521">LinesChunkLimits_T = Tuple["LineSet", LineNumber, LineNumber]


</t>
<t tx="ekr.20220312061835.522">def hash_lineset(
    lineset: "LineSet", min_common_lines: int = DEFAULT_MIN_SIMILARITY_LINE
) -&gt; Tuple[HashToIndex_T, IndexToLines_T]:
    """
    Return two dicts. The first associates the hash of successive stripped lines of a lineset
    to the indices of the starting lines.
    The second dict, associates the index of the starting line in the lineset's stripped lines to the
    couple [start, end] lines number in the corresponding file.

    :param lineset: lineset object (i.e the lines in a file)
    :param min_common_lines: number of successive lines that are used to compute the hash
    :return: a dict linking hashes to corresponding start index and a dict that links this
             index to the start and end lines in the file
    """
    hash2index = defaultdict(list)
    index2lines = {}
    # Comments, docstring and other specific patterns maybe excluded -&gt; call to stripped_lines
    # to get only what is desired
    lines = tuple(x.text for x in lineset.stripped_lines)
    # Need different iterators on same lines but each one is shifted 1 from the precedent
    shifted_lines = [iter(lines[i:]) for i in range(min_common_lines)]

    for index_i, *succ_lines in enumerate(zip(*shifted_lines)):
        start_linenumber = lineset.stripped_lines[index_i].line_number
        try:
            end_linenumber = lineset.stripped_lines[
                index_i + min_common_lines
            ].line_number
        except IndexError:
            end_linenumber = lineset.stripped_lines[-1].line_number + 1

        index = Index(index_i)
        index2lines[index] = SuccessiveLinesLimits(
            start=LineNumber(start_linenumber), end=LineNumber(end_linenumber)
        )

        l_c = LinesChunk(lineset.name, index, *succ_lines)
        hash2index[l_c].append(index)

    return hash2index, index2lines


</t>
<t tx="ekr.20220312061835.523">def remove_successives(all_couples: CplIndexToCplLines_T) -&gt; None:
    """
    Removes all successive entries in the dictionary in argument

    :param all_couples: collection that has to be cleaned up from successives entries.
                        The keys are couples of indices that mark the beginning of common entries
                        in both linesets. The values have two parts. The first one is the couple
                        of starting and ending line numbers of common successives lines in the first file.
                        The second part is the same for the second file.

    For example consider the following dict:

    &gt;&gt;&gt; all_couples
    {(11, 34): ([5, 9], [27, 31]),
     (23, 79): ([15, 19], [45, 49]),
     (12, 35): ([6, 10], [28, 32])}

    There are two successives keys (11, 34) and (12, 35).
    It means there are two consecutive similar chunks of lines in both files.
    Thus remove last entry and update the last line numbers in the first entry

    &gt;&gt;&gt; remove_successives(all_couples)
    &gt;&gt;&gt; all_couples
    {(11, 34): ([5, 10], [27, 32]),
     (23, 79): ([15, 19], [45, 49])}
    """
    couple: LineSetStartCouple
    for couple in tuple(all_couples.keys()):
        to_remove = []
        test = couple.increment(Index(1))
        while test in all_couples:
            all_couples[couple].first_file.end = all_couples[test].first_file.end
            all_couples[couple].second_file.end = all_couples[test].second_file.end
            all_couples[couple].effective_cmn_lines_nb += 1
            to_remove.append(test)
            test = test.increment(Index(1))

        for target in to_remove:
            try:
                all_couples.pop(target)
            except KeyError:
                pass


</t>
<t tx="ekr.20220312061835.524">def filter_noncode_lines(
    ls_1: "LineSet",
    stindex_1: Index,
    ls_2: "LineSet",
    stindex_2: Index,
    common_lines_nb: int,
) -&gt; int:
    """
    Return the effective number of common lines between lineset1 and lineset2 filtered from non code lines, that is to say the number of
    common successive stripped lines except those that do not contain code (for example a ligne with only an
    ending parathensis)

    :param ls_1: first lineset
    :param stindex_1: first lineset starting index
    :param ls_2: second lineset
    :param stindex_2: second lineset starting index
    :param common_lines_nb: number of common successive stripped lines before being filtered from non code lines
    :return: the number of common successives stripped lines that contain code
    """
    stripped_l1 = [
        lspecif.text
        for lspecif in ls_1.stripped_lines[stindex_1 : stindex_1 + common_lines_nb]
        if REGEX_FOR_LINES_WITH_CONTENT.match(lspecif.text)
    ]
    stripped_l2 = [
        lspecif.text
        for lspecif in ls_2.stripped_lines[stindex_2 : stindex_2 + common_lines_nb]
        if REGEX_FOR_LINES_WITH_CONTENT.match(lspecif.text)
    ]
    return sum(sline_1 == sline_2 for sline_1, sline_2 in zip(stripped_l1, stripped_l2))


</t>
<t tx="ekr.20220312061835.525">class Commonality(NamedTuple):
    cmn_lines_nb: int
    fst_lset: "LineSet"
    fst_file_start: LineNumber
    fst_file_end: LineNumber
    snd_lset: "LineSet"
    snd_file_start: LineNumber
    snd_file_end: LineNumber


</t>
<t tx="ekr.20220312061835.526">class Similar:
    """finds copy-pasted lines of code in a project"""

    @others
</t>
<t tx="ekr.20220312061835.527">def __init__(
    self,
    min_lines: int = DEFAULT_MIN_SIMILARITY_LINE,
    ignore_comments: bool = False,
    ignore_docstrings: bool = False,
    ignore_imports: bool = False,
    ignore_signatures: bool = False,
) -&gt; None:
    self.min_lines = min_lines
    self.ignore_comments = ignore_comments
    self.ignore_docstrings = ignore_docstrings
    self.ignore_imports = ignore_imports
    self.ignore_signatures = ignore_signatures
    self.linesets: List["LineSet"] = []

</t>
<t tx="ekr.20220312061835.528">def append_stream(
    self, streamid: str, stream: STREAM_TYPES, encoding: Optional[str] = None
) -&gt; None:
    """append a file to search for similarities"""
    if isinstance(stream, BufferedIOBase):
        if encoding is None:
            raise ValueError
        readlines = decoding_stream(stream, encoding).readlines
    else:
        readlines = stream.readlines  # type: ignore # hint parameter is incorrectly typed as non-optional
    try:
        self.linesets.append(
            LineSet(
                streamid,
                readlines(),
                self.ignore_comments,
                self.ignore_docstrings,
                self.ignore_imports,
                self.ignore_signatures,
            )
        )
    except UnicodeDecodeError:
        pass

</t>
<t tx="ekr.20220312061835.529">def run(self) -&gt; None:
    """start looking for similarities and display results on stdout"""
    if self.min_lines == 0:
        return
    self._display_sims(self._compute_sims())

</t>
<t tx="ekr.20220312061835.53">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
#!/usr/bin/env python

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import pylint

pylint.modify_sys_path()
pylint.run_pylint()
</t>
<t tx="ekr.20220312061835.530">def _compute_sims(self) -&gt; List[Tuple[int, Set[LinesChunkLimits_T]]]:
    """compute similarities in appended files"""
    no_duplicates: Dict[int, List[Set[LinesChunkLimits_T]]] = defaultdict(list)

    for commonality in self._iter_sims():
        num = commonality.cmn_lines_nb
        lineset1 = commonality.fst_lset
        start_line_1 = commonality.fst_file_start
        end_line_1 = commonality.fst_file_end
        lineset2 = commonality.snd_lset
        start_line_2 = commonality.snd_file_start
        end_line_2 = commonality.snd_file_end

        duplicate = no_duplicates[num]
        couples: Set[LinesChunkLimits_T]
        for couples in duplicate:
            if (lineset1, start_line_1, end_line_1) in couples or (
                lineset2,
                start_line_2,
                end_line_2,
            ) in couples:
                break
        else:
            duplicate.append(
                {
                    (lineset1, start_line_1, end_line_1),
                    (lineset2, start_line_2, end_line_2),
                }
            )
    sims: List[Tuple[int, Set[LinesChunkLimits_T]]] = []
    ensembles: List[Set[LinesChunkLimits_T]]
    for num, ensembles in no_duplicates.items():
        cpls: Set[LinesChunkLimits_T]
        for cpls in ensembles:
            sims.append((num, cpls))
    sims.sort()
    sims.reverse()
    return sims

</t>
<t tx="ekr.20220312061835.531">def _display_sims(
    self, similarities: List[Tuple[int, Set[LinesChunkLimits_T]]]
) -&gt; None:
    """Display computed similarities on stdout"""
    report = self._get_similarity_report(similarities)
    print(report)

</t>
<t tx="ekr.20220312061835.532">def _get_similarity_report(
    self, similarities: List[Tuple[int, Set[LinesChunkLimits_T]]]
) -&gt; str:
    """Create a report from similarities"""
    report: str = ""
    duplicated_line_number: int = 0
    for number, couples in similarities:
        report += f"\n{number} similar lines in {len(couples)} files\n"
        couples_l = sorted(couples)
        line_set = start_line = end_line = None
        for line_set, start_line, end_line in couples_l:
            report += f"=={line_set.name}:[{start_line}:{end_line}]\n"
        if line_set:
            for line in line_set._real_lines[start_line:end_line]:
                report += f"   {line.rstrip()}\n" if line.rstrip() else "\n"
        duplicated_line_number += number * (len(couples_l) - 1)
    total_line_number: int = sum(len(lineset) for lineset in self.linesets)
    report += f"TOTAL lines={total_line_number} duplicates={duplicated_line_number} percent={duplicated_line_number * 100.0 / total_line_number:.2f}\n"
    return report

</t>
<t tx="ekr.20220312061835.533">def _find_common(
    self, lineset1: "LineSet", lineset2: "LineSet"
) -&gt; Generator[Commonality, None, None]:
    """
    Find similarities in the two given linesets.

    This the core of the algorithm.
    
    The idea is to compute the hashes of a minimal number of successive
    lines of each lineset and then compare the hashes. Every match of such
    comparison is stored in a dict that links the couple of starting
    indices in both linesets to the couple of corresponding starting and
    ending lines in both files. Last regroups all successive couples in a
    bigger one. It allows to take into account common chunk of lines that
    have more than the minimal number of successive lines required.
    """
    hash_to_index_1: HashToIndex_T
    hash_to_index_2: HashToIndex_T
    index_to_lines_1: IndexToLines_T
    index_to_lines_2: IndexToLines_T
    hash_to_index_1, index_to_lines_1 = hash_lineset(lineset1, self.min_lines)
    hash_to_index_2, index_to_lines_2 = hash_lineset(lineset2, self.min_lines)

    hash_1: FrozenSet[LinesChunk] = frozenset(hash_to_index_1.keys())
    hash_2: FrozenSet[LinesChunk] = frozenset(hash_to_index_2.keys())

    common_hashes: Iterable[LinesChunk] = sorted(
        hash_1 &amp; hash_2, key=lambda m: hash_to_index_1[m][0]
    )

    # all_couples is a dict that links the couple of indices in both linesets that mark the beginning of
    # successive common lines, to the corresponding starting and ending number lines in both files
    all_couples: CplIndexToCplLines_T = {}

    for c_hash in sorted(common_hashes, key=operator.attrgetter("_index")):
        for indices_in_linesets in itertools.product(
            hash_to_index_1[c_hash], hash_to_index_2[c_hash]
        ):
            index_1 = indices_in_linesets[0]
            index_2 = indices_in_linesets[1]
            all_couples[
                LineSetStartCouple(index_1, index_2)
            ] = CplSuccessiveLinesLimits(
                copy.copy(index_to_lines_1[index_1]),
                copy.copy(index_to_lines_2[index_2]),
                effective_cmn_lines_nb=self.min_lines,
            )

    remove_successives(all_couples)

    for cml_stripped_l, cmn_l in all_couples.items():
        start_index_1 = cml_stripped_l.fst_lineset_index
        start_index_2 = cml_stripped_l.snd_lineset_index
        nb_common_lines = cmn_l.effective_cmn_lines_nb

        com = Commonality(
            cmn_lines_nb=nb_common_lines,
            fst_lset=lineset1,
            fst_file_start=cmn_l.first_file.start,
            fst_file_end=cmn_l.first_file.end,
            snd_lset=lineset2,
            snd_file_start=cmn_l.second_file.start,
            snd_file_end=cmn_l.second_file.end,
        )

        eff_cmn_nb = filter_noncode_lines(
            lineset1, start_index_1, lineset2, start_index_2, nb_common_lines
        )

        if eff_cmn_nb &gt; self.min_lines:
            yield com

</t>
<t tx="ekr.20220312061835.534">def _iter_sims(self) -&gt; Generator[Commonality, None, None]:
    """iterate on similarities among all files, by making a cartesian
    product
    """
    for idx, lineset in enumerate(self.linesets[:-1]):
        for lineset2 in self.linesets[idx + 1 :]:
            yield from self._find_common(lineset, lineset2)

</t>
<t tx="ekr.20220312061835.535">def get_map_data(self):
    """Returns the data we can use for a map/reduce process

    In this case we are returning this instance's Linesets, that is all file
    information that will later be used for vectorisation.
    """
    return self.linesets

</t>
<t tx="ekr.20220312061835.536">def combine_mapreduce_data(self, linesets_collection):
    """Reduces and recombines data into a format that we can report on

    The partner function of get_map_data()"""
    self.linesets = [line for lineset in linesets_collection for line in lineset]


</t>
<t tx="ekr.20220312061835.537">def stripped_lines(
    lines: Iterable[str],
    ignore_comments: bool,
    ignore_docstrings: bool,
    ignore_imports: bool,
    ignore_signatures: bool,
) -&gt; List[LineSpecifs]:
    """
    Return tuples of line/line number/line type with leading/trailing whitespace and any ignored code features removed

    :param lines: a collection of lines
    :param ignore_comments: if true, any comment in the lines collection is removed from the result
    :param ignore_docstrings: if true, any line that is a docstring is removed from the result
    :param ignore_imports: if true, any line that is an import is removed from the result
    :param ignore_signatures: if true, any line that is part of a function signature is removed from the result
    :return: the collection of line/line number/line type tuples
    """
    if ignore_imports or ignore_signatures:
        tree = astroid.parse("".join(lines))
    if ignore_imports:
        node_is_import_by_lineno = (
            (node.lineno, isinstance(node, (nodes.Import, nodes.ImportFrom)))
            for node in tree.body
        )
        line_begins_import = {
            lineno: all(is_import for _, is_import in node_is_import_group)
            for lineno, node_is_import_group in groupby(
                node_is_import_by_lineno, key=lambda x: x[0]
            )
        }
        current_line_is_import = False
    if ignore_signatures:

        def _get_functions(
            functions: List[nodes.NodeNG], tree: nodes.NodeNG
        ) -&gt; List[nodes.NodeNG]:
            """Recursively get all functions including nested in the classes from the tree."""

            for node in tree.body:
                if isinstance(node, (nodes.FunctionDef, nodes.AsyncFunctionDef)):
                    functions.append(node)

                if isinstance(
                    node,
                    (nodes.ClassDef, nodes.FunctionDef, nodes.AsyncFunctionDef),
                ):
                    _get_functions(functions, node)

            return functions

        functions = _get_functions([], tree)
        signature_lines = set(
            chain(
                *(
                    range(
                        func.lineno,
                        func.body[0].lineno if func.body else func.tolineno + 1,
                    )
                    for func in functions
                )
            )
        )

    strippedlines = []
    docstring = None
    for lineno, line in enumerate(lines, start=1):
        line = line.strip()
        if ignore_docstrings:
            if not docstring:
                if line.startswith('"""') or line.startswith("'''"):
                    docstring = line[:3]
                    line = line[3:]
                elif line.startswith('r"""') or line.startswith("r'''"):
                    docstring = line[1:4]
                    line = line[4:]
            if docstring:
                if line.endswith(docstring):
                    docstring = None
                line = ""
        if ignore_imports:
            current_line_is_import = line_begins_import.get(
                lineno, current_line_is_import
            )
            if current_line_is_import:
                line = ""
        if ignore_comments:
            line = line.split("#", 1)[0].strip()
        if ignore_signatures and lineno in signature_lines:
            line = ""
        if line:
            strippedlines.append(
                LineSpecifs(text=line, line_number=LineNumber(lineno - 1))
            )
    return strippedlines


</t>
<t tx="ekr.20220312061835.538">@functools.total_ordering
class LineSet:
    """
    Holds and indexes all the lines of a single source file.
    Allows for correspondance between real lines of the source file and stripped ones, which
    are the real ones from which undesired patterns have been removed.
    """

    @others
</t>
<t tx="ekr.20220312061835.539">def __init__(
    self,
    name: str,
    lines: List[str],
    ignore_comments: bool = False,
    ignore_docstrings: bool = False,
    ignore_imports: bool = False,
    ignore_signatures: bool = False,
) -&gt; None:
    self.name = name
    self._real_lines = lines
    self._stripped_lines = stripped_lines(
        lines, ignore_comments, ignore_docstrings, ignore_imports, ignore_signatures
    )

</t>
<t tx="ekr.20220312061835.54">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import Tuple

__version__ = "2.11.1"


@others
numversion = get_numversion_from_version(__version__)
</t>
<t tx="ekr.20220312061835.540">def __str__(self):
    return f"&lt;Lineset for {self.name}&gt;"

</t>
<t tx="ekr.20220312061835.541">def __len__(self):
    return len(self._real_lines)

</t>
<t tx="ekr.20220312061835.542">def __getitem__(self, index):
    return self._stripped_lines[index]

</t>
<t tx="ekr.20220312061835.543">def __lt__(self, other):
    return self.name &lt; other.name

</t>
<t tx="ekr.20220312061835.544">def __hash__(self):
    return id(self)

</t>
<t tx="ekr.20220312061835.545">def __eq__(self, other):
    if not isinstance(other, LineSet):
        return False
    return self.__dict__ == other.__dict__

</t>
<t tx="ekr.20220312061835.546">@property
def stripped_lines(self):
    return self._stripped_lines

</t>
<t tx="ekr.20220312061835.547">@property
def real_lines(self):
    return self._real_lines


</t>
<t tx="ekr.20220312061835.548">MSGS = {
    "R0801": (
        "Similar lines in %s files\n%s",
        "duplicate-code",
        "Indicates that a set of similar lines has been detected "
        "among multiple file. This usually means that the code should "
        "be refactored to avoid this duplication.",
    )
}


</t>
<t tx="ekr.20220312061835.549">def report_similarities(
    sect,
    stats: CheckerStats,
    old_stats: CheckerStats,
):
    """make a layout with some stats about duplication"""
    lines = ["", "now", "previous", "difference"]
    lines += table_lines_from_stats(
        stats, old_stats, ("nb_duplicated_lines", "percent_duplicated_lines")
    )
    sect.append(Table(children=lines, cols=4, rheaders=1, cheaders=1))


</t>
<t tx="ekr.20220312061835.55">def get_numversion_from_version(v: str) -&gt; Tuple:
    """Kept for compatibility reason

    See https://github.com/PyCQA/pylint/issues/4399
    https://github.com/PyCQA/pylint/issues/4420,
    """
    v = v.replace("pylint-", "")
    version = []
    for n in v.split(".")[0:3]:
        try:
            version.append(int(n))
        except ValueError:
            num = ""
            for c in n:
                if c.isdigit():
                    num += c
                else:
                    break
            try:
                version.append(int(num))
            except ValueError:
                version.append(0)
    while len(version) != 3:
        version.append(0)
    return tuple(version)


</t>
<t tx="ekr.20220312061835.550"># wrapper to get a pylint checker from the similar class
class SimilarChecker(BaseChecker, Similar, MapReduceMixin):
    """checks for similarities and duplicated code. This computation may be
    memory / CPU intensive, so you should disable it if you experiment some
    problems.
    """

    __implements__ = (IRawChecker,)
    # configuration section name
    name = "similarities"
    # messages
    msgs = MSGS
    # configuration options
    # for available dict keys/values see the optik parser 'add_option' method
    options = (
        (
            "min-similarity-lines",
            {
                "default": DEFAULT_MIN_SIMILARITY_LINE,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Minimum lines number of a similarity.",
            },
        ),
        (
            "ignore-comments",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Comments are removed from the similarity computation",
            },
        ),
        (
            "ignore-docstrings",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Docstrings are removed from the similarity computation",
            },
        ),
        (
            "ignore-imports",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Imports are removed from the similarity computation",
            },
        ),
        (
            "ignore-signatures",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y or n&gt;",
                "help": "Signatures are removed from the similarity computation",
            },
        ),
    )
    # reports
    reports = (("RP0801", "Duplication", report_similarities),)

    @others
</t>
<t tx="ekr.20220312061835.551">def __init__(self, linter=None) -&gt; None:
    BaseChecker.__init__(self, linter)
    Similar.__init__(
        self,
        min_lines=self.config.min_similarity_lines,
        ignore_comments=self.config.ignore_comments,
        ignore_docstrings=self.config.ignore_docstrings,
        ignore_imports=self.config.ignore_imports,
        ignore_signatures=self.config.ignore_signatures,
    )
    self.stats: CheckerStats = {}

</t>
<t tx="ekr.20220312061835.552">def set_option(self, optname, value, action=None, optdict=None):
    """method called to set an option (registered in the options list)

    Overridden to report options setting to Similar
    """
    BaseChecker.set_option(self, optname, value, action, optdict)
    if optname == "min-similarity-lines":
        self.min_lines = self.config.min_similarity_lines
    elif optname == "ignore-comments":
        self.ignore_comments = self.config.ignore_comments
    elif optname == "ignore-docstrings":
        self.ignore_docstrings = self.config.ignore_docstrings
    elif optname == "ignore-imports":
        self.ignore_imports = self.config.ignore_imports
    elif optname == "ignore-signatures":
        self.ignore_signatures = self.config.ignore_signatures

</t>
<t tx="ekr.20220312061835.553">def open(self):
    """init the checkers: reset linesets and statistics information"""
    self.linesets = []
    self.stats = self.linter.add_stats(
        nb_duplicated_lines=0, percent_duplicated_lines=0
    )

</t>
<t tx="ekr.20220312061835.554">def process_module(self, node: nodes.Module) -&gt; None:
    """process a module

    the module's content is accessible via the stream object

    stream must implement the readlines method
    """
    with node.stream() as stream:
        self.append_stream(self.linter.current_name, stream, node.file_encoding)

</t>
<t tx="ekr.20220312061835.555">def close(self):
    """compute and display similarities on closing (i.e. end of parsing)"""
    total = sum(len(lineset) for lineset in self.linesets)
    duplicated = 0
    stats = self.stats
    for num, couples in self._compute_sims():
        msg = []
        lineset = start_line = end_line = None
        for lineset, start_line, end_line in couples:
            msg.append(f"=={lineset.name}:[{start_line}:{end_line}]")
        msg.sort()

        if lineset:
            for line in lineset.real_lines[start_line:end_line]:
                msg.append(line.rstrip())

        self.add_message("R0801", args=(len(couples), "\n".join(msg)))
        duplicated += num * (len(couples) - 1)
    stats["nb_duplicated_lines"] = duplicated
    stats["percent_duplicated_lines"] = total and duplicated * 100.0 / total

</t>
<t tx="ekr.20220312061835.556">def get_map_data(self):
    """Passthru override"""
    return Similar.get_map_data(self)

</t>
<t tx="ekr.20220312061835.557">def reduce_map_data(self, linter, data):
    """Reduces and recombines data into a format that we can report on

    The partner function of get_map_data()"""
    recombined = SimilarChecker(linter)
    recombined.min_lines = self.min_lines
    recombined.ignore_comments = self.ignore_comments
    recombined.ignore_docstrings = self.ignore_docstrings
    recombined.ignore_imports = self.ignore_imports
    recombined.ignore_signatures = self.ignore_signatures
    recombined.open()
    Similar.combine_mapreduce_data(recombined, linesets_collection=data)
    recombined.close()


</t>
<t tx="ekr.20220312061835.558">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(SimilarChecker(linter))


</t>
<t tx="ekr.20220312061835.559">def usage(status=0):
    """display command line usage information"""
    print("finds copy pasted blocks in a set of files")
    print()
    print(
        "Usage: symilar [-d|--duplicates min_duplicated_lines] \
[-i|--ignore-comments] [--ignore-docstrings] [--ignore-imports] [--ignore-signatures] file1..."
    )
    sys.exit(status)


</t>
<t tx="ekr.20220312061835.56"></t>
<t tx="ekr.20220312061835.560">def Run(argv=None):
    """standalone command line access point"""
    if argv is None:
        argv = sys.argv[1:]

    s_opts = "hdi"
    l_opts = (
        "help",
        "duplicates=",
        "ignore-comments",
        "ignore-imports",
        "ignore-docstrings",
        "ignore-signatures",
    )
    min_lines = DEFAULT_MIN_SIMILARITY_LINE
    ignore_comments = False
    ignore_docstrings = False
    ignore_imports = False
    ignore_signatures = False
    opts, args = getopt(argv, s_opts, l_opts)
    for opt, val in opts:
        if opt in ("-d", "--duplicates"):
            min_lines = int(val)
        elif opt in ("-h", "--help"):
            usage()
        elif opt in ("-i", "--ignore-comments"):
            ignore_comments = True
        elif opt in ("--ignore-docstrings",):
            ignore_docstrings = True
        elif opt in ("--ignore-imports",):
            ignore_imports = True
        elif opt in ("--ignore-signatures",):
            ignore_signatures = True
    if not args:
        usage(1)
    sim = Similar(
        min_lines, ignore_comments, ignore_docstrings, ignore_imports, ignore_signatures
    )
    for filename in args:
        with open(filename, encoding="utf-8") as stream:
            sim.append_stream(filename, stream)
    sim.run()
    sys.exit(0)


</t>
<t tx="ekr.20220312061835.561">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2015 Pavel Roskin &lt;proski@gnu.org&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016-2017, 2020 Pedro Algarvio &lt;pedro@algarvio.me&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 Mikhail Fesenko &lt;proggga@gmail.com&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2019 agutole &lt;toldo_carp@hotmail.com&gt;
# Copyright (c) 2020 Ganden Schaffner &lt;gschaffner@pm.me&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 bot &lt;bot@noreply.github.com&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Eli Fine &lt;ejfine@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checker for spelling errors in comments and docstrings.
"""
import os
import re
import tokenize
from typing import Pattern

from astroid import nodes

from pylint.checkers import BaseTokenChecker
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker, ITokenChecker

try:
    import enchant
    from enchant.tokenize import (
        Chunker,
        EmailFilter,
        Filter,
        URLFilter,
        WikiWordFilter,
        get_tokenizer,
    )
except ImportError:
    enchant = None

    class EmailFilter:  # type: ignore
        ...

    class URLFilter:  # type: ignore
        ...

    class WikiWordFilter:  # type: ignore
        ...

    class Filter:  # type: ignore
        def _skip(self, word):
            raise NotImplementedError

    class Chunker:  # type: ignore
        pass

    def get_tokenizer(
        tag=None, chunkers=None, filters=None
    ):  # pylint: disable=unused-argument
        return Filter()


if enchant is not None:
    br = enchant.Broker()
    dicts = br.list_dicts()
    dict_choices = [""] + [d[0] for d in dicts]
    dicts = [f"{d[0]} ({d[1].name})" for d in dicts]
    dicts = ", ".join(dicts)
    instr = ""
else:
    dicts = "none"
    dict_choices = [""]
    instr = " To make it work, install the 'python-enchant' package."


@others
</t>
<t tx="ekr.20220312061835.562">class WordsWithDigitsFilter(Filter):
    """Skips words with digits."""

    @others
</t>
<t tx="ekr.20220312061835.563">def _skip(self, word):
    for char in word:
        if char.isdigit():
            return True
    return False


</t>
<t tx="ekr.20220312061835.564">class WordsWithUnderscores(Filter):
    """Skips words with underscores.

    They are probably function parameter names.
    """

    @others
</t>
<t tx="ekr.20220312061835.565">def _skip(self, word):
    return "_" in word


</t>
<t tx="ekr.20220312061835.566">class RegExFilter(Filter):
    """Parent class for filters using regular expressions.

    This filter skips any words the match the expression
    assigned to the class attribute ``_pattern``.

    """

    _pattern: Pattern[str]

    @others
</t>
<t tx="ekr.20220312061835.567">def _skip(self, word) -&gt; bool:
    return bool(self._pattern.match(word))


</t>
<t tx="ekr.20220312061835.568">class CamelCasedWord(RegExFilter):
    r"""Filter skipping over camelCasedWords.
    This filter skips any words matching the following regular expression:

           ^([a-z]\w+[A-Z]+\w+)

    That is, any words that are camelCasedWords.
    """
    _pattern = re.compile(r"^([a-z]+([\d]|[A-Z])(?:\w+)?)")


</t>
<t tx="ekr.20220312061835.569">class SphinxDirectives(RegExFilter):
    r"""Filter skipping over Sphinx Directives.
    This filter skips any words matching the following regular expression:

           ^(:([a-z]+)){1,2}:`([^`]+)(`)?

    That is, for example, :class:`BaseQuery`
    """
    # The final ` in the pattern is optional because enchant strips it out
    _pattern = re.compile(r"^(:([a-z]+)){1,2}:`([^`]+)(`)?")


</t>
<t tx="ekr.20220312061835.57">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2015-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2017 Derek Gustafson &lt;degustaf@gmail.com&gt;
# Copyright (c) 2019, 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checker for anything related to the async protocol (PEP 492)."""

import sys

import astroid
from astroid import nodes

from pylint import checkers, interfaces, utils
from pylint.checkers import utils as checker_utils
from pylint.checkers.utils import decorated_with


@others
</t>
<t tx="ekr.20220312061835.570">class ForwardSlashChunker(Chunker):
    """
    This chunker allows splitting words like 'before/after' into 'before' and 'after'
    """

    @others
</t>
<t tx="ekr.20220312061835.571">def next(self):
    while True:
        if not self._text:
            raise StopIteration()
        if "/" not in self._text:
            text = self._text
            self._offset = 0
            self._text = ""
            return (text, 0)
        pre_text, post_text = self._text.split("/", 1)
        self._text = post_text
        self._offset = 0
        if (
            not pre_text
            or not post_text
            or not pre_text[-1].isalpha()
            or not post_text[0].isalpha()
        ):
            self._text = ""
            self._offset = 0
            return (pre_text + "/" + post_text, 0)
        return (pre_text, 0)

</t>
<t tx="ekr.20220312061835.572">def _next(self):
    while True:
        if "/" not in self._text:
            return (self._text, 0)
        pre_text, post_text = self._text.split("/", 1)
        if not pre_text or not post_text:
            break
        if not pre_text[-1].isalpha() or not post_text[0].isalpha():
            raise StopIteration()
        self._text = pre_text + " " + post_text
    raise StopIteration()


</t>
<t tx="ekr.20220312061835.573">CODE_FLANKED_IN_BACKTICK_REGEX = re.compile(r"(\s|^)(`{1,2})([^`]+)(\2)([^`]|$)")


</t>
<t tx="ekr.20220312061835.574">def _strip_code_flanked_in_backticks(line: str) -&gt; str:
    """Alter line so code flanked in backticks is ignored.

    Pyenchant automatically strips backticks when parsing tokens,
    so this cannot be done at the individual filter level."""

    @others
    return CODE_FLANKED_IN_BACKTICK_REGEX.sub(
        replace_code_but_leave_surrounding_characters, line
    )


</t>
<t tx="ekr.20220312061835.575">def replace_code_but_leave_surrounding_characters(match_obj) -&gt; str:
    return match_obj.group(1) + match_obj.group(5)

</t>
<t tx="ekr.20220312061835.576">class SpellingChecker(BaseTokenChecker):
    """Check spelling in comments and docstrings"""

    __implements__ = (ITokenChecker, IAstroidChecker)
    name = "spelling"
    msgs = {
        "C0401": (
            "Wrong spelling of a word '%s' in a comment:\n%s\n"
            "%s\nDid you mean: '%s'?",
            "wrong-spelling-in-comment",
            "Used when a word in comment is not spelled correctly.",
        ),
        "C0402": (
            "Wrong spelling of a word '%s' in a docstring:\n%s\n"
            "%s\nDid you mean: '%s'?",
            "wrong-spelling-in-docstring",
            "Used when a word in docstring is not spelled correctly.",
        ),
        "C0403": (
            "Invalid characters %r in a docstring",
            "invalid-characters-in-docstring",
            "Used when a word in docstring cannot be checked by enchant.",
        ),
    }
    options = (
        (
            "spelling-dict",
            {
                "default": "",
                "type": "choice",
                "metavar": "&lt;dict name&gt;",
                "choices": dict_choices,
                "help": "Spelling dictionary name. "
                f"Available dictionaries: {dicts}.{instr}",
            },
        ),
        (
            "spelling-ignore-words",
            {
                "default": "",
                "type": "string",
                "metavar": "&lt;comma separated words&gt;",
                "help": "List of comma separated words that should not be checked.",
            },
        ),
        (
            "spelling-private-dict-file",
            {
                "default": "",
                "type": "string",
                "metavar": "&lt;path to file&gt;",
                "help": "A path to a file that contains the private "
                "dictionary; one word per line.",
            },
        ),
        (
            "spelling-store-unknown-words",
            {
                "default": "n",
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Tells whether to store unknown words to the "
                "private dictionary (see the "
                "--spelling-private-dict-file option) instead of "
                "raising a message.",
            },
        ),
        (
            "max-spelling-suggestions",
            {
                "default": 4,
                "type": "int",
                "metavar": "N",
                "help": "Limits count of emitted suggestions for spelling mistakes.",
            },
        ),
        (
            "spelling-ignore-comment-directives",
            {
                "default": "fmt: on,fmt: off,noqa:,noqa,nosec,isort:skip,mypy:",
                "type": "string",
                "metavar": "&lt;comma separated words&gt;",
                "help": "List of comma separated words that should be considered directives if they appear and the beginning of a comment and should not be checked.",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.577">def open(self):
    self.initialized = False
    self.private_dict_file = None

    if enchant is None:
        return
    dict_name = self.config.spelling_dict
    if not dict_name:
        return

    self.ignore_list = [
        w.strip() for w in self.config.spelling_ignore_words.split(",")
    ]
    # "param" appears in docstring in param description and
    # "pylint" appears in comments in pylint pragmas.
    self.ignore_list.extend(["param", "pylint"])

    self.ignore_comment_directive_list = [
        w.strip() for w in self.config.spelling_ignore_comment_directives.split(",")
    ]

    # Expand tilde to allow e.g. spelling-private-dict-file = ~/.pylintdict
    if self.config.spelling_private_dict_file:
        self.config.spelling_private_dict_file = os.path.expanduser(
            self.config.spelling_private_dict_file
        )

    if self.config.spelling_private_dict_file:
        self.spelling_dict = enchant.DictWithPWL(
            dict_name, self.config.spelling_private_dict_file
        )
        self.private_dict_file = open(  # pylint: disable=consider-using-with
            self.config.spelling_private_dict_file, "a", encoding="utf-8"
        )
    else:
        self.spelling_dict = enchant.Dict(dict_name)

    if self.config.spelling_store_unknown_words:
        self.unknown_words = set()

    self.tokenizer = get_tokenizer(
        dict_name,
        chunkers=[ForwardSlashChunker],
        filters=[
            EmailFilter,
            URLFilter,
            WikiWordFilter,
            WordsWithDigitsFilter,
            WordsWithUnderscores,
            CamelCasedWord,
            SphinxDirectives,
        ],
    )
    self.initialized = True

</t>
<t tx="ekr.20220312061835.578">def close(self):
    if self.private_dict_file:
        self.private_dict_file.close()

</t>
<t tx="ekr.20220312061835.579">def _check_spelling(self, msgid, line, line_num):
    original_line = line
    try:
        initial_space = re.search(r"^[^\S]\s*", line).regs[0][1]
    except (IndexError, AttributeError):
        initial_space = 0
    if line.strip().startswith("#") and "docstring" not in msgid:
        line = line.strip()[1:]
        # A ``Filter`` cannot determine if the directive is at the beginning of a line,
        #   nor determine if a colon is present or not (``pyenchant`` strips trailing colons).
        #   So implementing this here.
        for iter_directive in self.ignore_comment_directive_list:
            if line.startswith(" " + iter_directive):
                line = line[(len(iter_directive) + 1) :]
                break
        starts_with_comment = True
    else:
        starts_with_comment = False

    line = _strip_code_flanked_in_backticks(line)

    for word, word_start_at in self.tokenizer(line.strip()):
        word_start_at += initial_space
        lower_cased_word = word.casefold()

        # Skip words from ignore list.
        if word in self.ignore_list or lower_cased_word in self.ignore_list:
            continue

        # Strip starting u' from unicode literals and r' from raw strings.
        if word.startswith(("u'", 'u"', "r'", 'r"')) and len(word) &gt; 2:
            word = word[2:]
            lower_cased_word = lower_cased_word[2:]

        # If it is a known word, then continue.
        try:
            if self.spelling_dict.check(lower_cased_word):
                # The lower cased version of word passed spell checking
                continue

            # If we reached this far, it means there was a spelling mistake.
            # Let's retry with the original work because 'unicode' is a
            # spelling mistake but 'Unicode' is not
            if self.spelling_dict.check(word):
                continue
        except enchant.errors.Error:
            self.add_message(
                "invalid-characters-in-docstring", line=line_num, args=(word,)
            )
            continue

        # Store word to private dict or raise a message.
        if self.config.spelling_store_unknown_words:
            if lower_cased_word not in self.unknown_words:
                self.private_dict_file.write(f"{lower_cased_word}\n")
                self.unknown_words.add(lower_cased_word)
        else:
            # Present up to N suggestions.
            suggestions = self.spelling_dict.suggest(word)
            del suggestions[self.config.max_spelling_suggestions :]
            line_segment = line[word_start_at:]
            match = re.search(fr"(\W|^)({word})(\W|$)", line_segment)
            if match:
                # Start position of second group in regex.
                col = match.regs[2][0]
            else:
                col = line_segment.index(word)
            col += word_start_at
            if starts_with_comment:
                col += 1
            indicator = (" " * col) + ("^" * len(word))
            all_suggestion = "' or '".join(suggestions)
            args = (word, original_line, indicator, f"'{all_suggestion}'")
            self.add_message(msgid, line=line_num, args=args)

</t>
<t tx="ekr.20220312061835.58">class AsyncChecker(checkers.BaseChecker):
    __implements__ = interfaces.IAstroidChecker
    name = "async"
    msgs = {
        "E1700": (
            "Yield inside async function",
            "yield-inside-async-function",
            "Used when an `yield` or `yield from` statement is "
            "found inside an async function.",
            {"minversion": (3, 5)},
        ),
        "E1701": (
            "Async context manager '%s' doesn't implement __aenter__ and __aexit__.",
            "not-async-context-manager",
            "Used when an async context manager is used with an object "
            "that does not implement the async context management protocol.",
            {"minversion": (3, 5)},
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.580">def process_tokens(self, tokens):
    if not self.initialized:
        return

    # Process tokens and look for comments.
    for (tok_type, token, (start_row, _), _, _) in tokens:
        if tok_type == tokenize.COMMENT:
            if start_row == 1 and token.startswith("#!/"):
                # Skip shebang lines
                continue
            if token.startswith("# pylint:"):
                # Skip pylint enable/disable comments
                continue
            self._check_spelling("wrong-spelling-in-comment", token, start_row)

</t>
<t tx="ekr.20220312061835.581">@check_messages("wrong-spelling-in-docstring")
def visit_module(self, node: nodes.Module) -&gt; None:
    if not self.initialized:
        return
    self._check_docstring(node)

</t>
<t tx="ekr.20220312061835.582">@check_messages("wrong-spelling-in-docstring")
def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    if not self.initialized:
        return
    self._check_docstring(node)

</t>
<t tx="ekr.20220312061835.583">@check_messages("wrong-spelling-in-docstring")
def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    if not self.initialized:
        return
    self._check_docstring(node)

</t>
<t tx="ekr.20220312061835.584">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.585">def _check_docstring(self, node):
    """check the node has any spelling errors"""
    docstring = node.doc
    if not docstring:
        return

    start_line = node.lineno + 1

    # Go through lines of docstring
    for idx, line in enumerate(docstring.splitlines()):
        self._check_spelling("wrong-spelling-in-docstring", line, start_line + idx)


</t>
<t tx="ekr.20220312061835.586">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(SpellingChecker(linter))
</t>
<t tx="ekr.20220312061835.587">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2013-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2013-2014 Google, Inc.
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Cosmin Poieana &lt;cmin@ropython.org&gt;
# Copyright (c) 2014 Vlad Temian &lt;vladtemian@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Cezar &lt;celnazli@bitdefender.com&gt;
# Copyright (c) 2015 Chris Rebert &lt;code@rebertia.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Jared Garst &lt;cultofjared@gmail.com&gt;
# Copyright (c) 2017 Renat Galimov &lt;renat2017@gmail.com&gt;
# Copyright (c) 2017 Martin &lt;MartinBasti@users.noreply.github.com&gt;
# Copyright (c) 2017 Christopher Zurcher &lt;zurcher@users.noreply.github.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Banjamin Freeman &lt;befreeman@users.noreply.github.com&gt;
# Copyright (c) 2018 Ioana Tagirta &lt;ioana.tagirta@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Julien Palard &lt;julien@palard.fr&gt;
# Copyright (c) 2019 laike9m &lt;laike9m@users.noreply.github.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Robert Schweizer &lt;robert_schweizer@gmx.de&gt;
# Copyright (c) 2019 fadedDexofan &lt;fadedDexofan@gmail.com&gt;
# Copyright (c) 2020 Sorin Sbarnea &lt;ssbarnea@redhat.com&gt;
# Copyright (c) 2020 Federico Bond &lt;federicobond@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Yilei "Dolee" Yang &lt;yileiyang@google.com&gt;
# Copyright (c) 2021 Matus Valo &lt;matusvalo@users.noreply.github.com&gt;
# Copyright (c) 2021 victor &lt;16359131+jiajunsu@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checkers for various standard library functions."""

import sys
from collections.abc import Iterable
from typing import Any, Dict, Set

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, DeprecatedMixin, utils
from pylint.interfaces import IAstroidChecker
from pylint.lint import PyLinter

OPEN_FILES_MODE = ("open", "file")
OPEN_FILES_ENCODING = ("open", "read_text", "write_text")
UNITTEST_CASE = "unittest.case"
THREADING_THREAD = "threading.Thread"
COPY_COPY = "copy.copy"
OS_ENVIRON = "os._Environ"
ENV_GETTERS = ("os.getenv",)
SUBPROCESS_POPEN = "subprocess.Popen"
SUBPROCESS_RUN = "subprocess.run"
OPEN_MODULE = {"_io", "pathlib"}
DEBUG_BREAKPOINTS = ("builtins.breakpoint", "sys.breakpointhook", "pdb.set_trace")


DEPRECATED_MODULES = {
    (0, 0, 0): {"tkinter.tix", "fpectl"},
    (3, 2, 0): {"optparse"},
    (3, 4, 0): {"imp"},
    (3, 5, 0): {"formatter"},
    (3, 6, 0): {"asynchat", "asyncore"},
    (3, 7, 0): {"macpath"},
    (3, 9, 0): {"lib2to3", "parser", "symbol", "binhex"},
}

DEPRECATED_ARGUMENTS = {
    (0, 0, 0): {
        "int": ((None, "x"),),
        "bool": ((None, "x"),),
        "float": ((None, "x"),),
    },
    (3, 8, 0): {
        "asyncio.tasks.sleep": ((None, "loop"),),
        "asyncio.tasks.gather": ((None, "loop"),),
        "asyncio.tasks.shield": ((None, "loop"),),
        "asyncio.tasks.wait_for": ((None, "loop"),),
        "asyncio.tasks.wait": ((None, "loop"),),
        "asyncio.tasks.as_completed": ((None, "loop"),),
        "asyncio.subprocess.create_subprocess_exec": ((None, "loop"),),
        "asyncio.subprocess.create_subprocess_shell": ((4, "loop"),),
        "gettext.translation": ((5, "codeset"),),
        "gettext.install": ((2, "codeset"),),
        "functools.partialmethod": ((None, "func"),),
        "weakref.finalize": ((None, "func"), (None, "obj")),
        "profile.Profile.runcall": ((None, "func"),),
        "cProfile.Profile.runcall": ((None, "func"),),
        "bdb.Bdb.runcall": ((None, "func"),),
        "trace.Trace.runfunc": ((None, "func"),),
        "curses.wrapper": ((None, "func"),),
        "unittest.case.TestCase.addCleanup": ((None, "function"),),
        "concurrent.futures.thread.ThreadPoolExecutor.submit": ((None, "fn"),),
        "concurrent.futures.process.ProcessPoolExecutor.submit": ((None, "fn"),),
        "contextlib._BaseExitStack.callback": ((None, "callback"),),
        "contextlib.AsyncExitStack.push_async_callback": ((None, "callback"),),
        "multiprocessing.managers.Server.create": ((None, "c"), (None, "typeid")),
        "multiprocessing.managers.SharedMemoryServer.create": (
            (None, "c"),
            (None, "typeid"),
        ),
    },
    (3, 9, 0): {"random.Random.shuffle": ((1, "random"),)},
}

DEPRECATED_DECORATORS = {
    (3, 8, 0): {"asyncio.coroutine"},
    (3, 3, 0): {
        "abc.abstractclassmethod",
        "abc.abstractstaticmethod",
        "abc.abstractproperty",
    },
}


DEPRECATED_METHODS: Dict = {
    0: {
        "cgi.parse_qs",
        "cgi.parse_qsl",
        "ctypes.c_buffer",
        "distutils.command.register.register.check_metadata",
        "distutils.command.sdist.sdist.check_metadata",
        "tkinter.Misc.tk_menuBar",
        "tkinter.Menu.tk_bindForTraversal",
    },
    2: {
        (2, 6, 0): {
            "commands.getstatus",
            "os.popen2",
            "os.popen3",
            "os.popen4",
            "macostools.touched",
        },
        (2, 7, 0): {
            "unittest.case.TestCase.assertEquals",
            "unittest.case.TestCase.assertNotEquals",
            "unittest.case.TestCase.assertAlmostEquals",
            "unittest.case.TestCase.assertNotAlmostEquals",
            "unittest.case.TestCase.assert_",
            "xml.etree.ElementTree.Element.getchildren",
            "xml.etree.ElementTree.Element.getiterator",
            "xml.etree.ElementTree.XMLParser.getiterator",
            "xml.etree.ElementTree.XMLParser.doctype",
        },
    },
    3: {
        (3, 0, 0): {
            "inspect.getargspec",
            "failUnlessEqual",
            "assertEquals",
            "failIfEqual",
            "assertNotEquals",
            "failUnlessAlmostEqual",
            "assertAlmostEquals",
            "failIfAlmostEqual",
            "assertNotAlmostEquals",
            "failUnless",
            "assert_",
            "failUnlessRaises",
            "failIf",
            "assertRaisesRegexp",
            "assertRegexpMatches",
            "assertNotRegexpMatches",
        },
        (3, 1, 0): {
            "base64.encodestring",
            "base64.decodestring",
            "ntpath.splitunc",
            "os.path.splitunc",
            "os.stat_float_times",
        },
        (3, 2, 0): {
            "cgi.escape",
            "configparser.RawConfigParser.readfp",
            "xml.etree.ElementTree.Element.getchildren",
            "xml.etree.ElementTree.Element.getiterator",
            "xml.etree.ElementTree.XMLParser.getiterator",
            "xml.etree.ElementTree.XMLParser.doctype",
        },
        (3, 3, 0): {
            "inspect.getmoduleinfo",
            "logging.warn",
            "logging.Logger.warn",
            "logging.LoggerAdapter.warn",
            "nntplib._NNTPBase.xpath",
            "platform.popen",
            "sqlite3.OptimizedUnicode",
            "time.clock",
        },
        (3, 4, 0): {
            "importlib.find_loader",
            "plistlib.readPlist",
            "plistlib.writePlist",
            "plistlib.readPlistFromBytes",
            "plistlib.writePlistToBytes",
        },
        (3, 4, 4): {"asyncio.tasks.async"},
        (3, 5, 0): {
            "fractions.gcd",
            "inspect.formatargspec",
            "inspect.getcallargs",
            "platform.linux_distribution",
            "platform.dist",
        },
        (3, 6, 0): {
            "importlib._bootstrap_external.FileLoader.load_module",
            "_ssl.RAND_pseudo_bytes",
        },
        (3, 7, 0): {
            "sys.set_coroutine_wrapper",
            "sys.get_coroutine_wrapper",
            "aifc.openfp",
            "threading.Thread.isAlive",
            "asyncio.Task.current_task",
            "asyncio.Task.all_task",
            "locale.format",
            "ssl.wrap_socket",
            "ssl.match_hostname",
            "sunau.openfp",
            "wave.openfp",
        },
        (3, 8, 0): {
            "gettext.lgettext",
            "gettext.ldgettext",
            "gettext.lngettext",
            "gettext.ldngettext",
            "gettext.bind_textdomain_codeset",
            "gettext.NullTranslations.output_charset",
            "gettext.NullTranslations.set_output_charset",
            "threading.Thread.isAlive",
        },
        (3, 9, 0): {
            "binascii.b2a_hqx",
            "binascii.a2b_hqx",
            "binascii.rlecode_hqx",
            "binascii.rledecode_hqx",
        },
        (3, 10, 0): {
            "_sqlite3.enable_shared_cache",
            "pathlib.Path.link_to",
            "zipimport.zipimporter.load_module",
            "zipimport.zipimporter.find_module",
            "zipimport.zipimporter.find_loader",
            "threading.currentThread",
            "threading.activeCount",
            "threading.Condition.notifyAll",
            "threading.Event.isSet",
            "threading.Thread.setName",
            "threading.Thread.getName",
            "threading.Thread.isDaemon",
            "threading.Thread.setDaemon",
            "cgi.log",
        },
    },
}


DEPRECATED_CLASSES = {
    (3, 3, 0): {
        "importlib.abc": {
            "Finder",
        },
        "pkgutil": {
            "ImpImporter",
            "ImpLoader",
        },
        "collections": {
            "Awaitable",
            "Coroutine",
            "AsyncIterable",
            "AsyncIterator",
            "AsyncGenerator",
            "Hashable",
            "Iterable",
            "Iterator",
            "Generator",
            "Reversible",
            "Sized",
            "Container",
            "Callable",
            "Collection",
            "Set",
            "MutableSet",
            "Mapping",
            "MutableMapping",
            "MappingView",
            "KeysView",
            "ItemsView",
            "ValuesView",
            "Sequence",
            "MutableSequence",
            "ByteString",
        },
    },
    (3, 9, 0): {
        "smtpd": {
            "MailmanProxy",
        }
    },
}


@others
</t>
<t tx="ekr.20220312061835.588">def _check_mode_str(mode):
    # check type
    if not isinstance(mode, str):
        return False
    # check syntax
    modes = set(mode)
    _mode = "rwatb+Ux"
    creating = "x" in modes
    if modes - set(_mode) or len(mode) &gt; len(modes):
        return False
    # check logic
    reading = "r" in modes
    writing = "w" in modes
    appending = "a" in modes
    text = "t" in modes
    binary = "b" in modes
    if "U" in modes:
        if writing or appending or creating:
            return False
        reading = True
    if text and binary:
        return False
    total = reading + writing + appending + creating
    if total &gt; 1:
        return False
    if not (reading or writing or appending or creating):
        return False
    return True


</t>
<t tx="ekr.20220312061835.589">class StdlibChecker(DeprecatedMixin, BaseChecker):
    __implements__ = (IAstroidChecker,)
    name = "stdlib"

    msgs = {
        "W1501": (
            '"%s" is not a valid mode for open.',
            "bad-open-mode",
            "Python supports: r, w, a[, x] modes with b, +, "
            "and U (only with r) options. "
            "See https://docs.python.org/2/library/functions.html#open",
        ),
        "W1502": (
            "Using datetime.time in a boolean context.",
            "boolean-datetime",
            "Using datetime.time in a boolean context can hide "
            "subtle bugs when the time they represent matches "
            "midnight UTC. This behaviour was fixed in Python 3.5. "
            "See https://bugs.python.org/issue13936 for reference.",
            {"maxversion": (3, 5)},
        ),
        "W1503": (
            "Redundant use of %s with constant value %r",
            "redundant-unittest-assert",
            "The first argument of assertTrue and assertFalse is "
            "a condition. If a constant is passed as parameter, that "
            "condition will be always true. In this case a warning "
            "should be emitted.",
        ),
        "W1505": (
            "Using deprecated method %s()",
            "deprecated-method",
            "The method is marked as deprecated and will be removed in "
            "a future version of Python. Consider looking for an "
            "alternative in the documentation.",
        ),
        "W1506": (
            "threading.Thread needs the target function",
            "bad-thread-instantiation",
            "The warning is emitted when a threading.Thread class "
            "is instantiated without the target function being passed. "
            "By default, the first parameter is the group param, not the target param. ",
        ),
        "W1507": (
            "Using copy.copy(os.environ). Use os.environ.copy() instead. ",
            "shallow-copy-environ",
            "os.environ is not a dict object but proxy object, so "
            "shallow copy has still effects on original object. "
            "See https://bugs.python.org/issue15373 for reference. ",
        ),
        "E1507": (
            "%s does not support %s type argument",
            "invalid-envvar-value",
            "Env manipulation functions support only string type arguments. "
            "See https://docs.python.org/3/library/os.html#os.getenv. ",
        ),
        "W1508": (
            "%s default type is %s. Expected str or None.",
            "invalid-envvar-default",
            "Env manipulation functions return None or str values. "
            "Supplying anything different as a default may cause bugs. "
            "See https://docs.python.org/3/library/os.html#os.getenv. ",
        ),
        "W1509": (
            "Using preexec_fn keyword which may be unsafe in the presence "
            "of threads",
            "subprocess-popen-preexec-fn",
            "The preexec_fn parameter is not safe to use in the presence "
            "of threads in your application. The child process could "
            "deadlock before exec is called. If you must use it, keep it "
            "trivial! Minimize the number of libraries you call into."
            "https://docs.python.org/3/library/subprocess.html#popen-constructor",
        ),
        "W1510": (
            "Using subprocess.run without explicitly set `check` is not recommended.",
            "subprocess-run-check",
            "The check parameter should always be used with explicitly set "
            "`check` keyword to make clear what the error-handling behavior is."
            "https://docs.python.org/3/library/subprocess.html#subprocess.run",
        ),
        "W1511": (
            "Using deprecated argument %s of method %s()",
            "deprecated-argument",
            "The argument is marked as deprecated and will be removed in the future.",
        ),
        "W1512": (
            "Using deprecated class %s of module %s",
            "deprecated-class",
            "The class is marked as deprecated and will be removed in the future.",
        ),
        "W1513": (
            "Using deprecated decorator %s()",
            "deprecated-decorator",
            "The decorator is marked as deprecated and will be removed in the future.",
        ),
        "W1514": (
            "Using open without explicitly specifying an encoding",
            "unspecified-encoding",
            "It is better to specify an encoding when opening documents. "
            "Using the system default implicitly can create problems on other operating systems. "
            "See https://www.python.org/dev/peps/pep-0597/",
        ),
        "W1515": (
            "Leaving functions creating breakpoints in production code is not recommended",
            "forgotten-debug-statement",
            "Calls to breakpoint(), sys.breakpointhook() and pdb.set_trace() should be removed "
            "from code that is not actively being debugged.",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.59">def open(self):
    self._ignore_mixin_members = utils.get_global_option(
        self, "ignore-mixin-members"
    )
    self._async_generators = ["contextlib.asynccontextmanager"]

</t>
<t tx="ekr.20220312061835.590">def __init__(
    self, linter: PyLinter = None
):  # pylint: disable=super-init-not-called # See https://github.com/PyCQA/pylint/issues/4941
    BaseChecker.__init__(self, linter)
    self._deprecated_methods: Set[Any] = set()
    self._deprecated_methods.update(DEPRECATED_METHODS[0])
    for since_vers, func_list in DEPRECATED_METHODS[sys.version_info[0]].items():
        if since_vers &lt;= sys.version_info:
            self._deprecated_methods.update(func_list)
    self._deprecated_attributes = {}
    for since_vers, func_list in DEPRECATED_ARGUMENTS.items():
        if since_vers &lt;= sys.version_info:
            self._deprecated_attributes.update(func_list)
    self._deprecated_classes = {}
    for since_vers, class_list in DEPRECATED_CLASSES.items():
        if since_vers &lt;= sys.version_info:
            self._deprecated_classes.update(class_list)
    self._deprecated_modules = set()
    for since_vers, mod_list in DEPRECATED_MODULES.items():
        if since_vers &lt;= sys.version_info:
            self._deprecated_modules.update(mod_list)
    self._deprecated_decorators = set()
    for since_vers, decorator_list in DEPRECATED_DECORATORS.items():
        if since_vers &lt;= sys.version_info:
            self._deprecated_decorators.update(decorator_list)

</t>
<t tx="ekr.20220312061835.591">def _check_bad_thread_instantiation(self, node):
    if not node.kwargs and not node.keywords and len(node.args) &lt;= 1:
        self.add_message("bad-thread-instantiation", node=node)

</t>
<t tx="ekr.20220312061835.592">def _check_for_preexec_fn_in_popen(self, node):
    if node.keywords:
        for keyword in node.keywords:
            if keyword.arg == "preexec_fn":
                self.add_message("subprocess-popen-preexec-fn", node=node)

</t>
<t tx="ekr.20220312061835.593">def _check_for_check_kw_in_run(self, node):
    kwargs = {keyword.arg for keyword in (node.keywords or ())}
    if "check" not in kwargs:
        self.add_message("subprocess-run-check", node=node)

</t>
<t tx="ekr.20220312061835.594">def _check_shallow_copy_environ(self, node: nodes.Call) -&gt; None:
    arg = utils.get_argument_from_call(node, position=0)
    try:
        inferred_args = arg.inferred()
    except astroid.InferenceError:
        return
    for inferred in inferred_args:
        if inferred.qname() == OS_ENVIRON:
            self.add_message("shallow-copy-environ", node=node)
            break

</t>
<t tx="ekr.20220312061835.595">@utils.check_messages(
    "bad-open-mode",
    "redundant-unittest-assert",
    "deprecated-method",
    "deprecated-argument",
    "bad-thread-instantiation",
    "shallow-copy-environ",
    "invalid-envvar-value",
    "invalid-envvar-default",
    "subprocess-popen-preexec-fn",
    "subprocess-run-check",
    "deprecated-class",
    "unspecified-encoding",
    "forgotten-debug-statement",
)
</t>
<t tx="ekr.20220312061835.596">def visit_call(self, node: nodes.Call) -&gt; None:
    """Visit a Call node."""
    self.check_deprecated_class_in_call(node)
    for inferred in utils.infer_all(node.func):
        if inferred is astroid.Uninferable:
            continue
        if inferred.root().name in OPEN_MODULE:
            if (
                isinstance(node.func, nodes.Name)
                and node.func.name in OPEN_FILES_MODE
            ):
                self._check_open_mode(node)
            if (
                isinstance(node.func, nodes.Name)
                and node.func.name in OPEN_FILES_ENCODING
                or isinstance(node.func, nodes.Attribute)
                and node.func.attrname in OPEN_FILES_ENCODING
            ):
                self._check_open_encoded(node, inferred.root().name)
        elif inferred.root().name == UNITTEST_CASE:
            self._check_redundant_assert(node, inferred)
        elif isinstance(inferred, nodes.ClassDef):
            if inferred.qname() == THREADING_THREAD:
                self._check_bad_thread_instantiation(node)
            elif inferred.qname() == SUBPROCESS_POPEN:
                self._check_for_preexec_fn_in_popen(node)
        elif isinstance(inferred, nodes.FunctionDef):
            name = inferred.qname()
            if name == COPY_COPY:
                self._check_shallow_copy_environ(node)
            elif name in ENV_GETTERS:
                self._check_env_function(node, inferred)
            elif name == SUBPROCESS_RUN:
                self._check_for_check_kw_in_run(node)
            elif name in DEBUG_BREAKPOINTS:
                self.add_message("forgotten-debug-statement", node=node)
        self.check_deprecated_method(node, inferred)

</t>
<t tx="ekr.20220312061835.597">@utils.check_messages("boolean-datetime")
def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:
    if node.op == "not":
        self._check_datetime(node.operand)

</t>
<t tx="ekr.20220312061835.598">@utils.check_messages("boolean-datetime")
def visit_if(self, node: nodes.If) -&gt; None:
    self._check_datetime(node.test)

</t>
<t tx="ekr.20220312061835.599">@utils.check_messages("boolean-datetime")
def visit_ifexp(self, node: nodes.IfExp) -&gt; None:
    self._check_datetime(node.test)

</t>
<t tx="ekr.20220312061835.6">def lint(filename, options=()):
    """Pylint the given file.

    When run from emacs we will be in the directory of a file, and passed its
    filename.  If this file is part of a package and is trying to import other
    modules from within its own package or another package rooted in a directory
    below it, pylint will classify it as a failed import.

    To get around this, we traverse down the directory tree to find the root of
    the package this module is in.  We then invoke pylint from this directory.

    Finally, we must correct the filenames in the output generated by pylint so
    Emacs doesn't become confused (it will expect just the original filename,
    while pylint may extend it with extra directories if we've traversed down
    the tree)
    """
    # traverse downwards until we are out of a python package
    full_path = os.path.abspath(filename)
    parent_path = os.path.dirname(full_path)
    child_path = os.path.basename(full_path)

    while parent_path != "/" and os.path.exists(
        os.path.join(parent_path, "__init__.py")
    ):
        child_path = os.path.join(os.path.basename(parent_path), child_path)
        parent_path = os.path.dirname(parent_path)

    # Start pylint
    # Ensure we use the python and pylint associated with the running epylint
    run_cmd = "import sys; from pylint.lint import Run; Run(sys.argv[1:])"
    cmd = (
        [sys.executable, "-c", run_cmd]
        + [
            "--msg-template",
            "{path}:{line}: {category} ({msg_id}, {symbol}, {obj}) {msg}",
            "-r",
            "n",
            child_path,
        ]
        + list(options)
    )

    with Popen(
        cmd, stdout=PIPE, cwd=parent_path, env=_get_env(), universal_newlines=True
    ) as process:

        for line in process.stdout:
            # remove pylintrc warning
            if line.startswith("No config file found"):
                continue

            # modify the file name thats output to reverse the path traversal we made
            parts = line.split(":")
            if parts and parts[0] == child_path:
                line = ":".join([filename] + parts[1:])
            print(line, end=" ")

        process.wait()
        return process.returncode


</t>
<t tx="ekr.20220312061835.60">@checker_utils.check_messages("yield-inside-async-function")
def visit_asyncfunctiondef(self, node: nodes.AsyncFunctionDef) -&gt; None:
    for child in node.nodes_of_class(nodes.Yield):
        if child.scope() is node and (
            sys.version_info[:2] == (3, 5) or isinstance(child, nodes.YieldFrom)
        ):
            self.add_message("yield-inside-async-function", node=child)

</t>
<t tx="ekr.20220312061835.600">@utils.check_messages("boolean-datetime")
def visit_boolop(self, node: nodes.BoolOp) -&gt; None:
    for value in node.values:
        self._check_datetime(value)

</t>
<t tx="ekr.20220312061835.601">def _check_redundant_assert(self, node, infer):
    if (
        isinstance(infer, astroid.BoundMethod)
        and node.args
        and isinstance(node.args[0], nodes.Const)
        and infer.name in ["assertTrue", "assertFalse"]
    ):
        self.add_message(
            "redundant-unittest-assert",
            args=(infer.name, node.args[0].value),
            node=node,
        )

</t>
<t tx="ekr.20220312061835.602">def _check_datetime(self, node):
    """Check that a datetime was inferred.
    If so, emit boolean-datetime warning.
    """
    try:
        inferred = next(node.infer())
    except astroid.InferenceError:
        return
    if (
        isinstance(inferred, astroid.Instance)
        and inferred.qname() == "datetime.time"
    ):
        self.add_message("boolean-datetime", node=node)

</t>
<t tx="ekr.20220312061835.603">def _check_open_mode(self, node):
    """Check that the mode argument of an open or file call is valid."""
    try:
        mode_arg = utils.get_argument_from_call(node, position=1, keyword="mode")
    except utils.NoSuchArgumentError:
        return
    if mode_arg:
        mode_arg = utils.safe_infer(mode_arg)
        if isinstance(mode_arg, nodes.Const) and not _check_mode_str(
            mode_arg.value
        ):
            self.add_message("bad-open-mode", node=node, args=mode_arg.value)

</t>
<t tx="ekr.20220312061835.604">def _check_open_encoded(self, node: nodes.Call, open_module: str) -&gt; None:
    """Check that the encoded argument of an open call is valid."""
    mode_arg = None
    try:
        if open_module == "_io":
            mode_arg = utils.get_argument_from_call(
                node, position=1, keyword="mode"
            )
        elif open_module == "pathlib":
            mode_arg = utils.get_argument_from_call(
                node, position=0, keyword="mode"
            )
    except utils.NoSuchArgumentError:
        pass

    if mode_arg:
        mode_arg = utils.safe_infer(mode_arg)
    if not mode_arg or "b" not in mode_arg.value:
        encoding_arg = None
        try:
            encoding_arg = utils.get_argument_from_call(
                node, position=None, keyword="encoding"
            )
        except utils.NoSuchArgumentError:
            self.add_message("unspecified-encoding", node=node)

        if encoding_arg:
            encoding_arg = utils.safe_infer(encoding_arg)

            if isinstance(encoding_arg, nodes.Const) and encoding_arg.value is None:
                self.add_message("unspecified-encoding", node=node)

</t>
<t tx="ekr.20220312061835.605">def _check_env_function(self, node, infer):
    env_name_kwarg = "key"
    env_value_kwarg = "default"
    if node.keywords:
        kwargs = {keyword.arg: keyword.value for keyword in node.keywords}
    else:
        kwargs = None
    if node.args:
        env_name_arg = node.args[0]
    elif kwargs and env_name_kwarg in kwargs:
        env_name_arg = kwargs[env_name_kwarg]
    else:
        env_name_arg = None

    if env_name_arg:
        self._check_invalid_envvar_value(
            node=node,
            message="invalid-envvar-value",
            call_arg=utils.safe_infer(env_name_arg),
            infer=infer,
            allow_none=False,
        )

    if len(node.args) == 2:
        env_value_arg = node.args[1]
    elif kwargs and env_value_kwarg in kwargs:
        env_value_arg = kwargs[env_value_kwarg]
    else:
        env_value_arg = None

    if env_value_arg:
        self._check_invalid_envvar_value(
            node=node,
            infer=infer,
            message="invalid-envvar-default",
            call_arg=utils.safe_infer(env_value_arg),
            allow_none=True,
        )

</t>
<t tx="ekr.20220312061835.606">def _check_invalid_envvar_value(self, node, infer, message, call_arg, allow_none):
    if call_arg in (astroid.Uninferable, None):
        return

    name = infer.qname()
    if isinstance(call_arg, nodes.Const):
        emit = False
        if call_arg.value is None:
            emit = not allow_none
        elif not isinstance(call_arg.value, str):
            emit = True
        if emit:
            self.add_message(message, node=node, args=(name, call_arg.pytype()))
    else:
        self.add_message(message, node=node, args=(name, call_arg.pytype()))

</t>
<t tx="ekr.20220312061835.607">def deprecated_modules(self):
    """Callback returning the deprecated modules."""
    return self._deprecated_modules

</t>
<t tx="ekr.20220312061835.608">def deprecated_methods(self):
    return self._deprecated_methods

</t>
<t tx="ekr.20220312061835.609">def deprecated_arguments(self, method: str):
    return self._deprecated_attributes.get(method, ())

</t>
<t tx="ekr.20220312061835.61">@checker_utils.check_messages("not-async-context-manager")
def visit_asyncwith(self, node: nodes.AsyncWith) -&gt; None:
    for ctx_mgr, _ in node.items:
        inferred = checker_utils.safe_infer(ctx_mgr)
        if inferred is None or inferred is astroid.Uninferable:
            continue

        if isinstance(inferred, nodes.AsyncFunctionDef):
            # Check if we are dealing with a function decorated
            # with contextlib.asynccontextmanager.
            if decorated_with(inferred, self._async_generators):
                continue
        elif isinstance(inferred, astroid.bases.AsyncGenerator):
            # Check if we are dealing with a function decorated
            # with contextlib.asynccontextmanager.
            if decorated_with(inferred.parent, self._async_generators):
                continue
        else:
            try:
                inferred.getattr("__aenter__")
                inferred.getattr("__aexit__")
            except astroid.exceptions.NotFoundError:
                if isinstance(inferred, astroid.Instance):
                    # If we do not know the bases of this class,
                    # just skip it.
                    if not checker_utils.has_known_bases(inferred):
                        continue
                    # Just ignore mixin classes.
                    if self._ignore_mixin_members:
                        if inferred.name[-5:].lower() == "mixin":
                            continue
            else:
                continue
        self.add_message(
            "not-async-context-manager", node=node, args=(inferred.name,)
        )


</t>
<t tx="ekr.20220312061835.610">def deprecated_classes(self, module: str):
    return self._deprecated_classes.get(module, ())

</t>
<t tx="ekr.20220312061835.611">def deprecated_decorators(self) -&gt; Iterable:
    return self._deprecated_decorators


</t>
<t tx="ekr.20220312061835.612">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(StdlibChecker(linter))
</t>
<t tx="ekr.20220312061835.613">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2009-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Rene Zhang &lt;rz99@cornell.edu&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2016 Peter Dawyndt &lt;Peter.Dawyndt@UGent.be&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018, 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2018-2019 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Alan Chan &lt;achan961117@gmail.com&gt;
# Copyright (c) 2018 Yury Gribov &lt;tetra2005@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Wes Turner &lt;westurner@google.com&gt;
# Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Matthew Suozzo &lt;msuozzo@google.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020  &lt;109224573@qq.com&gt;
# Copyright (c) 2020 Anthony &lt;tanant@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Peter Kolbus &lt;peter.kolbus@garmin.com&gt;


# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Checker for string formatting operations.
"""

import collections
import numbers
import re
import tokenize
from typing import TYPE_CHECKING, Iterable

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, BaseTokenChecker, utils
from pylint.checkers.utils import check_messages
from pylint.interfaces import IAstroidChecker, IRawChecker, ITokenChecker

if TYPE_CHECKING:
    from typing import Counter  # typing.Counter added in Python 3.6.1

_AST_NODE_STR_TYPES = ("__builtin__.unicode", "__builtin__.str", "builtins.str")
# Prefixes for both strings and bytes literals per
# https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
_PREFIXES = {
    "r",
    "u",
    "R",
    "U",
    "f",
    "F",
    "fr",
    "Fr",
    "fR",
    "FR",
    "rf",
    "rF",
    "Rf",
    "RF",
    "b",
    "B",
    "br",
    "Br",
    "bR",
    "BR",
    "rb",
    "rB",
    "Rb",
    "RB",
}
SINGLE_QUOTED_REGEX = re.compile(f"({'|'.join(_PREFIXES)})?'''")
DOUBLE_QUOTED_REGEX = re.compile(f"({'|'.join(_PREFIXES)})?\"\"\"")
QUOTE_DELIMITER_REGEX = re.compile(f"({'|'.join(_PREFIXES)})?(\"|')", re.DOTALL)

MSGS = {  # pylint: disable=consider-using-namedtuple-or-dataclass
    "E1300": (
        "Unsupported format character %r (%#02x) at index %d",
        "bad-format-character",
        "Used when an unsupported format character is used in a format string.",
    ),
    "E1301": (
        "Format string ends in middle of conversion specifier",
        "truncated-format-string",
        "Used when a format string terminates before the end of a "
        "conversion specifier.",
    ),
    "E1302": (
        "Mixing named and unnamed conversion specifiers in format string",
        "mixed-format-string",
        "Used when a format string contains both named (e.g. '%(foo)d') "
        "and unnamed (e.g. '%d') conversion specifiers.  This is also "
        "used when a named conversion specifier contains * for the "
        "minimum field width and/or precision.",
    ),
    "E1303": (
        "Expected mapping for format string, not %s",
        "format-needs-mapping",
        "Used when a format string that uses named conversion specifiers "
        "is used with an argument that is not a mapping.",
    ),
    "W1300": (
        "Format string dictionary key should be a string, not %s",
        "bad-format-string-key",
        "Used when a format string that uses named conversion specifiers "
        "is used with a dictionary whose keys are not all strings.",
    ),
    "W1301": (
        "Unused key %r in format string dictionary",
        "unused-format-string-key",
        "Used when a format string that uses named conversion specifiers "
        "is used with a dictionary that contains keys not required by the "
        "format string.",
    ),
    "E1304": (
        "Missing key %r in format string dictionary",
        "missing-format-string-key",
        "Used when a format string that uses named conversion specifiers "
        "is used with a dictionary that doesn't contain all the keys "
        "required by the format string.",
    ),
    "E1305": (
        "Too many arguments for format string",
        "too-many-format-args",
        "Used when a format string that uses unnamed conversion "
        "specifiers is given too many arguments.",
    ),
    "E1306": (
        "Not enough arguments for format string",
        "too-few-format-args",
        "Used when a format string that uses unnamed conversion "
        "specifiers is given too few arguments",
    ),
    "E1307": (
        "Argument %r does not match format type %r",
        "bad-string-format-type",
        "Used when a type required by format string "
        "is not suitable for actual argument type",
    ),
    "E1310": (
        "Suspicious argument in %s.%s call",
        "bad-str-strip-call",
        "The argument to a str.{l,r,}strip call contains a duplicate character, ",
    ),
    "W1302": (
        "Invalid format string",
        "bad-format-string",
        "Used when a PEP 3101 format string is invalid.",
    ),
    "W1303": (
        "Missing keyword argument %r for format string",
        "missing-format-argument-key",
        "Used when a PEP 3101 format string that uses named fields "
        "doesn't receive one or more required keywords.",
    ),
    "W1304": (
        "Unused format argument %r",
        "unused-format-string-argument",
        "Used when a PEP 3101 format string that uses named "
        "fields is used with an argument that "
        "is not required by the format string.",
    ),
    "W1305": (
        "Format string contains both automatic field numbering "
        "and manual field specification",
        "format-combined-specification",
        "Used when a PEP 3101 format string contains both automatic "
        "field numbering (e.g. '{}') and manual field "
        "specification (e.g. '{0}').",
    ),
    "W1306": (
        "Missing format attribute %r in format specifier %r",
        "missing-format-attribute",
        "Used when a PEP 3101 format string uses an "
        "attribute specifier ({0.length}), but the argument "
        "passed for formatting doesn't have that attribute.",
    ),
    "W1307": (
        "Using invalid lookup key %r in format specifier %r",
        "invalid-format-index",
        "Used when a PEP 3101 format string uses a lookup specifier "
        "({a[1]}), but the argument passed for formatting "
        "doesn't contain or doesn't have that key as an attribute.",
    ),
    "W1308": (
        "Duplicate string formatting argument %r, consider passing as named argument",
        "duplicate-string-formatting-argument",
        "Used when we detect that a string formatting is "
        "repeating an argument instead of using named string arguments",
    ),
    "W1309": (
        "Using an f-string that does not have any interpolated variables",
        "f-string-without-interpolation",
        "Used when we detect an f-string that does not use any interpolation variables, "
        "in which case it can be either a normal string or a bug in the code.",
    ),
    "W1310": (
        "Using formatting for a string that does not have any interpolated variables",
        "format-string-without-interpolation",
        "Used when we detect a string that does not have any interpolation variables, "
        "in which case it can be either a normal string without formatting or a bug in the code.",
    ),
}

OTHER_NODES = (
    nodes.Const,
    nodes.List,
    nodes.Lambda,
    nodes.FunctionDef,
    nodes.ListComp,
    nodes.SetComp,
    nodes.GeneratorExp,
)


@others
</t>
<t tx="ekr.20220312061835.614">def get_access_path(key, parts):
    """Given a list of format specifiers, returns
    the final access path (e.g. a.b.c[0][1]).
    """
    path = []
    for is_attribute, specifier in parts:
        if is_attribute:
            path.append(f".{specifier}")
        else:
            path.append(f"[{specifier!r}]")
    return str(key) + "".join(path)


</t>
<t tx="ekr.20220312061835.615">def arg_matches_format_type(arg_type, format_type):
    if format_type in "sr":
        # All types can be printed with %s and %r
        return True
    if isinstance(arg_type, astroid.Instance):
        arg_type = arg_type.pytype()
        if arg_type == "builtins.str":
            return format_type == "c"
        if arg_type == "builtins.float":
            return format_type in "deEfFgGn%"
        if arg_type == "builtins.int":
            # Integers allow all types
            return True
        return False
    return True


</t>
<t tx="ekr.20220312061835.616">class StringFormatChecker(BaseChecker):
    """Checks string formatting operations to ensure that the format string
    is valid and the arguments match the format string.
    """

    __implements__ = (IAstroidChecker,)
    name = "string"
    msgs = MSGS

    # pylint: disable=too-many-branches
    @check_messages(
        "bad-format-character",
        "truncated-format-string",
        "mixed-format-string",
        "bad-format-string-key",
        "missing-format-string-key",
        "unused-format-string-key",
        "bad-string-format-type",
        "format-needs-mapping",
        "too-many-format-args",
        "too-few-format-args",
        "bad-string-format-type",
        "format-string-without-interpolation",
    )
    @others
</t>
<t tx="ekr.20220312061835.617">def visit_binop(self, node: nodes.BinOp) -&gt; None:
    if node.op != "%":
        return
    left = node.left
    args = node.right

    if not (isinstance(left, nodes.Const) and isinstance(left.value, str)):
        return
    format_string = left.value
    try:
        (
            required_keys,
            required_num_args,
            required_key_types,
            required_arg_types,
        ) = utils.parse_format_string(format_string)
    except utils.UnsupportedFormatCharacter as exc:
        formatted = format_string[exc.index]
        self.add_message(
            "bad-format-character",
            node=node,
            args=(formatted, ord(formatted), exc.index),
        )
        return
    except utils.IncompleteFormatString:
        self.add_message("truncated-format-string", node=node)
        return
    if not required_keys and not required_num_args:
        self.add_message("format-string-without-interpolation", node=node)
        return
    if required_keys and required_num_args:
        # The format string uses both named and unnamed format
        # specifiers.
        self.add_message("mixed-format-string", node=node)
    elif required_keys:
        # The format string uses only named format specifiers.
        # Check that the RHS of the % operator is a mapping object
        # that contains precisely the set of keys required by the
        # format string.
        if isinstance(args, nodes.Dict):
            keys = set()
            unknown_keys = False
            for k, _ in args.items:
                if isinstance(k, nodes.Const):
                    key = k.value
                    if isinstance(key, str):
                        keys.add(key)
                    else:
                        self.add_message(
                            "bad-format-string-key", node=node, args=key
                        )
                else:
                    # One of the keys was something other than a
                    # constant.  Since we can't tell what it is,
                    # suppress checks for missing keys in the
                    # dictionary.
                    unknown_keys = True
            if not unknown_keys:
                for key in required_keys:
                    if key not in keys:
                        self.add_message(
                            "missing-format-string-key", node=node, args=key
                        )
            for key in keys:
                if key not in required_keys:
                    self.add_message(
                        "unused-format-string-key", node=node, args=key
                    )
            for key, arg in args.items:
                if not isinstance(key, nodes.Const):
                    continue
                format_type = required_key_types.get(key.value, None)
                arg_type = utils.safe_infer(arg)
                if (
                    format_type is not None
                    and arg_type
                    and arg_type != astroid.Uninferable
                    and not arg_matches_format_type(arg_type, format_type)
                ):
                    self.add_message(
                        "bad-string-format-type",
                        node=node,
                        args=(arg_type.pytype(), format_type),
                    )
        elif isinstance(args, (OTHER_NODES, nodes.Tuple)):
            type_name = type(args).__name__
            self.add_message("format-needs-mapping", node=node, args=type_name)
        # else:
        # The RHS of the format specifier is a name or
        # expression.  It may be a mapping object, so
        # there's nothing we can check.
    else:
        # The format string uses only unnamed format specifiers.
        # Check that the number of arguments passed to the RHS of
        # the % operator matches the number required by the format
        # string.
        args_elts = []
        if isinstance(args, nodes.Tuple):
            rhs_tuple = utils.safe_infer(args)
            num_args = None
            if isinstance(rhs_tuple, nodes.BaseContainer):
                args_elts = rhs_tuple.elts
                num_args = len(args_elts)
        elif isinstance(args, (OTHER_NODES, (nodes.Dict, nodes.DictComp))):
            args_elts = [args]
            num_args = 1
        else:
            # The RHS of the format specifier is a name or
            # expression.  It could be a tuple of unknown size, so
            # there's nothing we can check.
            num_args = None
        if num_args is not None:
            if num_args &gt; required_num_args:
                self.add_message("too-many-format-args", node=node)
            elif num_args &lt; required_num_args:
                self.add_message("too-few-format-args", node=node)
            for arg, format_type in zip(args_elts, required_arg_types):
                if not arg:
                    continue
                arg_type = utils.safe_infer(arg)
                if (
                    arg_type
                    and arg_type != astroid.Uninferable
                    and not arg_matches_format_type(arg_type, format_type)
                ):
                    self.add_message(
                        "bad-string-format-type",
                        node=node,
                        args=(arg_type.pytype(), format_type),
                    )

</t>
<t tx="ekr.20220312061835.618">@check_messages("f-string-without-interpolation")
def visit_joinedstr(self, node: nodes.JoinedStr) -&gt; None:
    if isinstance(node.parent, nodes.FormattedValue):
        return
    for value in node.values:
        if isinstance(value, nodes.FormattedValue):
            return
    self.add_message("f-string-without-interpolation", node=node)

</t>
<t tx="ekr.20220312061835.619">@check_messages(*MSGS)
def visit_call(self, node: nodes.Call) -&gt; None:
    func = utils.safe_infer(node.func)
    if (
        isinstance(func, astroid.BoundMethod)
        and isinstance(func.bound, astroid.Instance)
        and func.bound.name in ("str", "unicode", "bytes")
    ):
        if func.name in ("strip", "lstrip", "rstrip") and node.args:
            arg = utils.safe_infer(node.args[0])
            if not isinstance(arg, nodes.Const) or not isinstance(arg.value, str):
                return
            if len(arg.value) != len(set(arg.value)):
                self.add_message(
                    "bad-str-strip-call",
                    node=node,
                    args=(func.bound.name, func.name),
                )
        elif func.name == "format":
            self._check_new_format(node, func)

</t>
<t tx="ekr.20220312061835.62">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(AsyncChecker(linter))
</t>
<t tx="ekr.20220312061835.620">def _detect_vacuous_formatting(self, node, positional_arguments):
    counter = collections.Counter(
        arg.name for arg in positional_arguments if isinstance(arg, nodes.Name)
    )
    for name, count in counter.items():
        if count == 1:
            continue
        self.add_message(
            "duplicate-string-formatting-argument", node=node, args=(name,)
        )

</t>
<t tx="ekr.20220312061835.621">def _check_new_format(self, node, func):
    """Check the new string formatting."""
    # Skip format nodes which don't have an explicit string on the
    # left side of the format operation.
    # We do this because our inference engine can't properly handle
    # redefinitions of the original string.
    # Note that there may not be any left side at all, if the format method
    # has been assigned to another variable. See issue 351. For example:
    #
    #    fmt = 'some string {}'.format
    #    fmt('arg')
    if isinstance(node.func, nodes.Attribute) and not isinstance(
        node.func.expr, nodes.Const
    ):
        return
    if node.starargs or node.kwargs:
        return
    try:
        strnode = next(func.bound.infer())
    except astroid.InferenceError:
        return
    if not (isinstance(strnode, nodes.Const) and isinstance(strnode.value, str)):
        return
    try:
        call_site = astroid.arguments.CallSite.from_call(node)
    except astroid.InferenceError:
        return

    try:
        fields, num_args, manual_pos = utils.parse_format_method_string(
            strnode.value
        )
    except utils.IncompleteFormatString:
        self.add_message("bad-format-string", node=node)
        return

    positional_arguments = call_site.positional_arguments
    named_arguments = call_site.keyword_arguments
    named_fields = {field[0] for field in fields if isinstance(field[0], str)}
    if num_args and manual_pos:
        self.add_message("format-combined-specification", node=node)
        return

    check_args = False
    # Consider "{[0]} {[1]}" as num_args.
    num_args += sum(1 for field in named_fields if field == "")
    if named_fields:
        for field in named_fields:
            if field and field not in named_arguments:
                self.add_message(
                    "missing-format-argument-key", node=node, args=(field,)
                )
        for field in named_arguments:
            if field not in named_fields:
                self.add_message(
                    "unused-format-string-argument", node=node, args=(field,)
                )
        # num_args can be 0 if manual_pos is not.
        num_args = num_args or manual_pos
        if positional_arguments or num_args:
            empty = any(True for field in named_fields if field == "")
            if named_arguments or empty:
                # Verify the required number of positional arguments
                # only if the .format got at least one keyword argument.
                # This means that the format strings accepts both
                # positional and named fields and we should warn
                # when one of the them is missing or is extra.
                check_args = True
    else:
        check_args = True
    if check_args:
        # num_args can be 0 if manual_pos is not.
        num_args = num_args or manual_pos
        if not num_args:
            self.add_message("format-string-without-interpolation", node=node)
            return
        if len(positional_arguments) &gt; num_args:
            self.add_message("too-many-format-args", node=node)
        elif len(positional_arguments) &lt; num_args:
            self.add_message("too-few-format-args", node=node)

    self._detect_vacuous_formatting(node, positional_arguments)
    self._check_new_format_specifiers(node, fields, named_arguments)

</t>
<t tx="ekr.20220312061835.622">def _check_new_format_specifiers(self, node, fields, named):
    """
    Check attribute and index access in the format
    string ("{0.a}" and "{0[a]}").
    """
    for key, specifiers in fields:
        # Obtain the argument. If it can't be obtained
        # or inferred, skip this check.
        if key == "":
            # {[0]} will have an unnamed argument, defaulting
            # to 0. It will not be present in `named`, so use the value
            # 0 for it.
            key = 0
        if isinstance(key, numbers.Number):
            try:
                argname = utils.get_argument_from_call(node, key)
            except utils.NoSuchArgumentError:
                continue
        else:
            if key not in named:
                continue
            argname = named[key]
        if argname in (astroid.Uninferable, None):
            continue
        try:
            argument = utils.safe_infer(argname)
        except astroid.InferenceError:
            continue
        if not specifiers or not argument:
            # No need to check this key if it doesn't
            # use attribute / item access
            continue
        if argument.parent and isinstance(argument.parent, nodes.Arguments):
            # Ignore any object coming from an argument,
            # because we can't infer its value properly.
            continue
        previous = argument
        parsed = []
        for is_attribute, specifier in specifiers:
            if previous is astroid.Uninferable:
                break
            parsed.append((is_attribute, specifier))
            if is_attribute:
                try:
                    previous = previous.getattr(specifier)[0]
                except astroid.NotFoundError:
                    if (
                        hasattr(previous, "has_dynamic_getattr")
                        and previous.has_dynamic_getattr()
                    ):
                        # Don't warn if the object has a custom __getattr__
                        break
                    path = get_access_path(key, parsed)
                    self.add_message(
                        "missing-format-attribute",
                        args=(specifier, path),
                        node=node,
                    )
                    break
            else:
                warn_error = False
                if hasattr(previous, "getitem"):
                    try:
                        previous = previous.getitem(nodes.Const(specifier))
                    except (
                        astroid.AstroidIndexError,
                        astroid.AstroidTypeError,
                        astroid.AttributeInferenceError,
                    ):
                        warn_error = True
                    except astroid.InferenceError:
                        break
                    if previous is astroid.Uninferable:
                        break
                else:
                    try:
                        # Lookup __getitem__ in the current node,
                        # but skip further checks, because we can't
                        # retrieve the looked object
                        previous.getattr("__getitem__")
                        break
                    except astroid.NotFoundError:
                        warn_error = True
                if warn_error:
                    path = get_access_path(key, parsed)
                    self.add_message(
                        "invalid-format-index", args=(specifier, path), node=node
                    )
                    break

            try:
                previous = next(previous.infer())
            except astroid.InferenceError:
                # can't check further if we can't infer it
                break


</t>
<t tx="ekr.20220312061835.623">class StringConstantChecker(BaseTokenChecker):
    """Check string literals"""

    __implements__ = (IAstroidChecker, ITokenChecker, IRawChecker)
    name = "string"
    msgs = {
        "W1401": (
            "Anomalous backslash in string: '%s'. "
            "String constant might be missing an r prefix.",
            "anomalous-backslash-in-string",
            "Used when a backslash is in a literal string but not as an escape.",
        ),
        "W1402": (
            "Anomalous Unicode escape in byte string: '%s'. "
            "String constant might be missing an r or u prefix.",
            "anomalous-unicode-escape-in-string",
            "Used when an escape like \\u is encountered in a byte "
            "string where it has no effect.",
        ),
        "W1404": (
            "Implicit string concatenation found in %s",
            "implicit-str-concat",
            "String literals are implicitly concatenated in a "
            "literal iterable definition : "
            "maybe a comma is missing ?",
            {"old_names": [("W1403", "implicit-str-concat-in-sequence")]},
        ),
        "W1405": (
            "Quote delimiter %s is inconsistent with the rest of the file",
            "inconsistent-quotes",
            "Quote delimiters are not used consistently throughout a module "
            "(with allowances made for avoiding unnecessary escaping).",
        ),
        "W1406": (
            "The u prefix for strings is no longer necessary in Python &gt;=3.0",
            "redundant-u-string-prefix",
            "Used when we detect a string with a u prefix. These prefixes were necessary "
            "in Python 2 to indicate a string was Unicode, but since Python 3.0 strings "
            "are Unicode by default.",
        ),
    }
    options = (
        (
            "check-str-concat-over-line-jumps",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "This flag controls whether the "
                "implicit-str-concat should generate a warning "
                "on implicit string concatenation in sequences defined over "
                "several lines.",
            },
        ),
        (
            "check-quote-consistency",
            {
                "default": False,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "This flag controls whether inconsistent-quotes generates a "
                "warning when the character used as a quote delimiter is used "
                "inconsistently within a module.",
            },
        ),
    )

    # Characters that have a special meaning after a backslash in either
    # Unicode or byte strings.
    ESCAPE_CHARACTERS = "abfnrtvx\n\r\t\\'\"01234567"

    # Characters that have a special meaning after a backslash but only in
    # Unicode strings.
    UNICODE_ESCAPE_CHARACTERS = "uUN"

    @others
</t>
<t tx="ekr.20220312061835.624">def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.string_tokens = {}  # token position -&gt; (token value, next token)

</t>
<t tx="ekr.20220312061835.625">def process_module(self, node: nodes.Module) -&gt; None:
    self._unicode_literals = "unicode_literals" in node.future_imports

</t>
<t tx="ekr.20220312061835.626">def process_tokens(self, tokens):
    encoding = "ascii"
    for i, (tok_type, token, start, _, line) in enumerate(tokens):
        if tok_type == tokenize.ENCODING:
            # this is always the first token processed
            encoding = token
        elif tok_type == tokenize.STRING:
            # 'token' is the whole un-parsed token; we can look at the start
            # of it to see whether it's a raw or unicode string etc.
            self.process_string_token(token, start[0], start[1])
            # We figure the next token, ignoring comments &amp; newlines:
            j = i + 1
            while j &lt; len(tokens) and tokens[j].type in (
                tokenize.NEWLINE,
                tokenize.NL,
                tokenize.COMMENT,
            ):
                j += 1
            next_token = tokens[j] if j &lt; len(tokens) else None
            if encoding != "ascii":
                # We convert `tokenize` character count into a byte count,
                # to match with astroid `.col_offset`
                start = (start[0], len(line[: start[1]].encode(encoding)))
            self.string_tokens[start] = (str_eval(token), next_token)

    if self.config.check_quote_consistency:
        self.check_for_consistent_string_delimiters(tokens)

</t>
<t tx="ekr.20220312061835.627">@check_messages("implicit-str-concat")
def visit_list(self, node: nodes.List) -&gt; None:
    self.check_for_concatenated_strings(node.elts, "list")

</t>
<t tx="ekr.20220312061835.628">@check_messages("implicit-str-concat")
def visit_set(self, node: nodes.Set) -&gt; None:
    self.check_for_concatenated_strings(node.elts, "set")

</t>
<t tx="ekr.20220312061835.629">@check_messages("implicit-str-concat")
def visit_tuple(self, node: nodes.Tuple) -&gt; None:
    self.check_for_concatenated_strings(node.elts, "tuple")

</t>
<t tx="ekr.20220312061835.63">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2016 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Nick Bastin &lt;nick.bastin@gmail.com&gt;
# Copyright (c) 2015 Michael Kefeder &lt;oss@multiwave.ch&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Stephane Wirtel &lt;stephane@wirtel.be&gt;
# Copyright (c) 2015 Cosmin Poieana &lt;cmin@ropython.org&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Radu Ciorba &lt;radu@devrandom.ro&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016, 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2016 Elias Dorneles &lt;eliasdorneles@gmail.com&gt;
# Copyright (c) 2016 Yannack &lt;yannack@users.noreply.github.com&gt;
# Copyright (c) 2016 Alex Jurkiewicz &lt;alex@jurkiewi.cz&gt;
# Copyright (c) 2017, 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2017, 2019-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 danields &lt;danields761@gmail.com&gt;
# Copyright (c) 2017 Jacques Kvam &lt;jwkvam@gmail.com&gt;
# Copyright (c) 2017 ttenhoeve-aa &lt;ttenhoeve@appannie.com&gt;
# Copyright (c) 2018-2019, 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018-2019 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018 Sergei Lebedev &lt;185856+superbobry@users.noreply.github.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Natalie Serebryakova &lt;natalie.serebryakova@Natalies-MacBook-Pro.local&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 SergeyKosarchuk &lt;sergeykosarchuk@gmail.com&gt;
# Copyright (c) 2018 Steven M. Vascellaro &lt;svascellaro@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Chris Lamb &lt;chris@chris-lamb.co.uk&gt;
# Copyright (c) 2018 glmdgrielson &lt;32415403+glmdgrielson@users.noreply.github.com&gt;
# Copyright (c) 2019 Daniel Draper &lt;Germandrummer92@users.noreply.github.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Niko Wenselowski &lt;niko@nerdno.de&gt;
# Copyright (c) 2019 Nikita Sobolev &lt;mail@sobolevn.me&gt;
# Copyright (c) 2019 Oisn Moran &lt;OisinMoran@users.noreply.github.com&gt;
# Copyright (c) 2019 Fantix King &lt;fantix@uchicago.edu&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 ethan-leba &lt;ethanleba5@gmail.com&gt;
# Copyright (c) 2020  &lt;hira9603859504@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2020 bernie gray &lt;bfgray3@users.noreply.github.com&gt;
# Copyright (c) 2020 Gabriel R Sezefredo &lt;g@briel.dev&gt;
# Copyright (c) 2020 Benny &lt;benny.mueller91@gmail.com&gt;
# Copyright (c) 2020 Anubhav &lt;35621759+anubh-v@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Yilei "Dolee" Yang &lt;yileiyang@google.com&gt;
# Copyright (c) 2021 Lorena B &lt;46202743+lorena-b@users.noreply.github.com&gt;
# Copyright (c) 2021 David Liu &lt;david@cs.toronto.edu&gt;
# Copyright (c) 2021 Andreas Finkler &lt;andi.finkler@gmail.com&gt;
# Copyright (c) 2021 Or Bahari &lt;orbahari@mail.tau.ac.il&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""basic checker for Python code"""
import collections
import itertools
import re
import sys
from typing import Any, Dict, Iterator, Optional, Pattern, Union

import astroid
from astroid import nodes

from pylint import checkers, exceptions, interfaces
from pylint import utils as lint_utils
from pylint.checkers import utils
from pylint.checkers.utils import (
    infer_all,
    is_overload_stub,
    is_property_deleter,
    is_property_setter,
)
from pylint.reporters.ureports import nodes as reporter_nodes
from pylint.typing import CheckerStats


@others
</t>
<t tx="ekr.20220312061835.630">def visit_assign(self, node: nodes.Assign) -&gt; None:
    if isinstance(node.value, nodes.Const) and isinstance(node.value.value, str):
        self.check_for_concatenated_strings([node.value], "assignment")

</t>
<t tx="ekr.20220312061835.631">def check_for_consistent_string_delimiters(
    self, tokens: Iterable[tokenize.TokenInfo]
) -&gt; None:
    """Adds a message for each string using inconsistent quote delimiters.

    Quote delimiters are used inconsistently if " and ' are mixed in a module's
    shortstrings without having done so to avoid escaping an internal quote
    character.

    Args:
      tokens: The tokens to be checked against for consistent usage.
    """
    # typing.Counter added in Python 3.6.1 so this type hint must be a comment
    string_delimiters = collections.Counter()  # type: Counter[str]

    # First, figure out which quote character predominates in the module
    for tok_type, token, _, _, _ in tokens:
        if tok_type == tokenize.STRING and _is_quote_delimiter_chosen_freely(token):
            string_delimiters[_get_quote_delimiter(token)] += 1

    if len(string_delimiters) &gt; 1:
        # Ties are broken arbitrarily
        most_common_delimiter = string_delimiters.most_common(1)[0][0]
        for tok_type, token, start, _, _ in tokens:
            if tok_type != tokenize.STRING:
                continue
            quote_delimiter = _get_quote_delimiter(token)
            if (
                _is_quote_delimiter_chosen_freely(token)
                and quote_delimiter != most_common_delimiter
            ):
                self.add_message(
                    "inconsistent-quotes", line=start[0], args=(quote_delimiter,)
                )

</t>
<t tx="ekr.20220312061835.632">def check_for_concatenated_strings(self, elements, iterable_type):
    for elt in elements:
        if not (
            isinstance(elt, nodes.Const) and elt.pytype() in _AST_NODE_STR_TYPES
        ):
            continue
        if elt.col_offset &lt; 0:
            # This can happen in case of escaped newlines
            continue
        if (elt.lineno, elt.col_offset) not in self.string_tokens:
            # This may happen with Latin1 encoding
            # cf. https://github.com/PyCQA/pylint/issues/2610
            continue
        matching_token, next_token = self.string_tokens[
            (elt.lineno, elt.col_offset)
        ]
        # We detect string concatenation: the AST Const is the
        # combination of 2 string tokens
        if matching_token != elt.value and next_token is not None:
            if next_token.type == tokenize.STRING and (
                next_token.start[0] == elt.lineno
                or self.config.check_str_concat_over_line_jumps
            ):
                self.add_message(
                    "implicit-str-concat", line=elt.lineno, args=(iterable_type,)
                )

</t>
<t tx="ekr.20220312061835.633">def process_string_token(self, token, start_row, start_col):
    quote_char = None
    index = None
    for index, char in enumerate(token):
        if char in "'\"":
            quote_char = char
            break
    if quote_char is None:
        return

    prefix = token[:index].lower()  # markers like u, b, r.
    after_prefix = token[index:]
    # Chop off quotes
    quote_length = (
        3 if after_prefix[:3] == after_prefix[-3:] == 3 * quote_char else 1
    )
    string_body = after_prefix[quote_length:-quote_length]
    # No special checks on raw strings at the moment.
    if "r" not in prefix:
        self.process_non_raw_string_token(
            prefix,
            string_body,
            start_row,
            start_col + len(prefix) + quote_length,
        )

</t>
<t tx="ekr.20220312061835.634">def process_non_raw_string_token(
    self, prefix, string_body, start_row, string_start_col
):
    """check for bad escapes in a non-raw string.

    prefix: lowercase string of eg 'ur' string prefix markers.
    string_body: the un-parsed body of the string, not including the quote
    marks.
    start_row: integer line number in the source.
    string_start_col: integer col number of the string start in the source.
    """
    # Walk through the string; if we see a backslash then escape the next
    # character, and skip over it.  If we see a non-escaped character,
    # alert, and continue.
    #
    # Accept a backslash when it escapes a backslash, or a quote, or
    # end-of-line, or one of the letters that introduce a special escape
    # sequence &lt;https://docs.python.org/reference/lexical_analysis.html&gt;
    #
    index = 0
    while True:
        index = string_body.find("\\", index)
        if index == -1:
            break
        # There must be a next character; having a backslash at the end
        # of the string would be a SyntaxError.
        next_char = string_body[index + 1]
        match = string_body[index : index + 2]
        # The column offset will vary depending on whether the string token
        # is broken across lines. Calculate relative to the nearest line
        # break or relative to the start of the token's line.
        last_newline = string_body.rfind("\n", 0, index)
        if last_newline == -1:
            line = start_row
            col_offset = index + string_start_col
        else:
            line = start_row + string_body.count("\n", 0, index)
            col_offset = index - last_newline - 1
        if next_char in self.UNICODE_ESCAPE_CHARACTERS:
            if "u" in prefix:
                pass
            elif "b" not in prefix:
                pass  # unicode by default
            else:
                self.add_message(
                    "anomalous-unicode-escape-in-string",
                    line=line,
                    args=(match,),
                    col_offset=col_offset,
                )
        elif next_char not in self.ESCAPE_CHARACTERS:
            self.add_message(
                "anomalous-backslash-in-string",
                line=line,
                args=(match,),
                col_offset=col_offset,
            )
        # Whether it was a valid escape or not, backslash followed by
        # another character can always be consumed whole: the second
        # character can never be the start of a new backslash escape.
        index += 2

</t>
<t tx="ekr.20220312061835.635">@check_messages("redundant-u-string-prefix")
def visit_const(self, node: nodes.Const) -&gt; None:
    if node.pytype() == "builtins.str" and not isinstance(
        node.parent, nodes.JoinedStr
    ):
        self._detect_u_string_prefix(node)

</t>
<t tx="ekr.20220312061835.636">def _detect_u_string_prefix(self, node: nodes.Const):
    """Check whether strings include a 'u' prefix like u'String'"""
    if node.kind == "u":
        self.add_message(
            "redundant-u-string-prefix",
            line=node.lineno,
            col_offset=node.col_offset,
        )


</t>
<t tx="ekr.20220312061835.637">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(StringFormatChecker(linter))
    linter.register_checker(StringConstantChecker(linter))


</t>
<t tx="ekr.20220312061835.638">def str_eval(token):
    """
    Mostly replicate `ast.literal_eval(token)` manually to avoid any performance hit.
    This supports f-strings, contrary to `ast.literal_eval`.
    We have to support all string literal notations:
    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
    """
    if token[0:2].lower() in ("fr", "rf"):
        token = token[2:]
    elif token[0].lower() in ("r", "u", "f"):
        token = token[1:]
    if token[0:3] in ('"""', "'''"):
        return token[3:-3]
    return token[1:-1]


</t>
<t tx="ekr.20220312061835.639">def _is_long_string(string_token: str) -&gt; bool:
    """Is this string token a "longstring" (is it triple-quoted)?

    Long strings are triple-quoted as defined in
    https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals

    This function only checks characters up through the open quotes.  Because it's meant
    to be applied only to tokens that represent string literals, it doesn't bother to
    check for close-quotes (demonstrating that the literal is a well-formed string).

    Args:
        string_token: The string token to be parsed.

    Returns:
        A boolean representing whether or not this token matches a longstring
        regex.
    """
    return bool(
        SINGLE_QUOTED_REGEX.match(string_token)
        or DOUBLE_QUOTED_REGEX.match(string_token)
    )


</t>
<t tx="ekr.20220312061835.64">class NamingStyle:
    """It may seem counterintuitive that single naming style has multiple "accepted"
    forms of regular expressions, but we need to special-case stuff like dunder names
    in method names."""

    ANY: Pattern[str] = re.compile(".*")
    CLASS_NAME_RGX: Pattern[str] = ANY
    MOD_NAME_RGX: Pattern[str] = ANY
    CONST_NAME_RGX: Pattern[str] = ANY
    COMP_VAR_RGX: Pattern[str] = ANY
    DEFAULT_NAME_RGX: Pattern[str] = ANY
    CLASS_ATTRIBUTE_RGX: Pattern[str] = ANY

    @others
</t>
<t tx="ekr.20220312061835.640">def _get_quote_delimiter(string_token: str) -&gt; str:
    """Returns the quote character used to delimit this token string.

    This function does little checking for whether the token is a well-formed
    string.

    Args:
        string_token: The token to be parsed.

    Returns:
        A string containing solely the first quote delimiter character in the passed
        string.

    Raises:
      ValueError: No quote delimiter characters are present.
    """
    match = QUOTE_DELIMITER_REGEX.match(string_token)
    if not match:
        raise ValueError(f"string token {string_token} is not a well-formed string")
    return match.group(2)


</t>
<t tx="ekr.20220312061835.641">def _is_quote_delimiter_chosen_freely(string_token: str) -&gt; bool:
    """Was there a non-awkward option for the quote delimiter?

    Args:
        string_token: The quoted string whose delimiters are to be checked.

    Returns:
        Whether there was a choice in this token's quote character that would
        not have involved backslash-escaping an interior quote character.  Long
        strings are excepted from this analysis under the assumption that their
        quote characters are set by policy.
    """
    quote_delimiter = _get_quote_delimiter(string_token)
    unchosen_delimiter = '"' if quote_delimiter == "'" else "'"
    return bool(
        quote_delimiter
        and not _is_long_string(string_token)
        and unchosen_delimiter not in str_eval(string_token)
    )
</t>
<t tx="ekr.20220312061835.642">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009 James Lingard &lt;jchl@aristanetworks.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2014-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 David Shea &lt;dshea@redhat.com&gt;
# Copyright (c) 2014 Steven Myint &lt;hg@stevenmyint.com&gt;
# Copyright (c) 2014 Holger Peters &lt;email@holger-peters.de&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Anentropic &lt;ego@anentropic.com&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Rene Zhang &lt;rz99@cornell.edu&gt;
# Copyright (c) 2015 Radu Ciorba &lt;radu@devrandom.ro&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016 Alexander Todorov &lt;atodorov@otb.bg&gt;
# Copyright (c) 2016 Jrgen Hermann &lt;jh@web.de&gt;
# Copyright (c) 2016 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2016 Filipe Brandenburger &lt;filbranden@google.com&gt;
# Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2017 Derek Gustafson &lt;degustaf@gmail.com&gt;
# Copyright (c) 2017 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018-2019, 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2018 Pablo Galindo &lt;Pablogsal@gmail.com&gt;
# Copyright (c) 2018 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Ben Green &lt;benhgreen@icloud.com&gt;
# Copyright (c) 2018 Konstantin &lt;Github@pheanex.de&gt;
# Copyright (c) 2018 Justin Li &lt;justinnhli@users.noreply.github.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Andy Palmer &lt;25123779+ninezerozeronine@users.noreply.github.com&gt;
# Copyright (c) 2019 mattlbeck &lt;17108752+mattlbeck@users.noreply.github.com&gt;
# Copyright (c) 2019 Martin Vielsmaier &lt;martin.vielsmaier@gmail.com&gt;
# Copyright (c) 2019 Santiago Castro &lt;bryant@montevideo.com.uy&gt;
# Copyright (c) 2019 yory8 &lt;39745367+yory8@users.noreply.github.com&gt;
# Copyright (c) 2019 Federico Bond &lt;federicobond@gmail.com&gt;
# Copyright (c) 2019 Pascal Corpet &lt;pcorpet@users.noreply.github.com&gt;
# Copyright (c) 2020 Peter Kolbus &lt;peter.kolbus@gmail.com&gt;
# Copyright (c) 2020 Julien Palard &lt;julien@palard.fr&gt;
# Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2020 Anubhav &lt;35621759+anubh-v@users.noreply.github.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 David Liu &lt;david@cs.toronto.edu&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 doranid &lt;ddandd@gmail.com&gt;
# Copyright (c) 2021 yushao2 &lt;36848472+yushao2@users.noreply.github.com&gt;
# Copyright (c) 2021 Andrew Haigh &lt;nelfin@gmail.com&gt;
# Copyright (c) 2021 Jens H. Nielsen &lt;Jens.Nielsen@microsoft.com&gt;
# Copyright (c) 2021 Ikraduya Edian &lt;ikraduya@gmail.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""try to find more bugs in the code using astroid inference capabilities
"""

import fnmatch
import heapq
import itertools
import operator
import re
import shlex
import sys
import types
from collections import deque
from collections.abc import Sequence
from functools import singledispatch
from typing import Any, Callable, Iterator, List, Optional, Pattern, Tuple

import astroid
from astroid import bases, nodes

from pylint.checkers import BaseChecker, utils
from pylint.checkers.utils import (
    check_messages,
    decorated_with,
    decorated_with_property,
    has_known_bases,
    is_builtin_object,
    is_classdef_type,
    is_comprehension,
    is_inside_abstract_class,
    is_iterable,
    is_mapping,
    is_overload_stub,
    is_postponed_evaluation_enabled,
    is_super,
    node_ignores_exception,
    safe_infer,
    supports_delitem,
    supports_getitem,
    supports_membership_test,
    supports_setitem,
)
from pylint.constants import PY310_PLUS
from pylint.interfaces import INFERENCE, IAstroidChecker
from pylint.utils import get_global_option

STR_FORMAT = {"builtins.str.format"}
ASYNCIO_COROUTINE = "asyncio.coroutines.coroutine"
BUILTIN_TUPLE = "builtins.tuple"
TYPE_ANNOTATION_NODES_TYPES = (
    nodes.AnnAssign,
    nodes.Arguments,
    nodes.FunctionDef,
)


@others
</t>
<t tx="ekr.20220312061835.643">def _unflatten(iterable):
    for index, elem in enumerate(iterable):
        if isinstance(elem, Sequence) and not isinstance(elem, str):
            yield from _unflatten(elem)
        elif elem and not index:
            # We're interested only in the first element.
            yield elem


</t>
<t tx="ekr.20220312061835.644">def _flatten_container(iterable):
    # Flatten nested containers into a single iterable
    for item in iterable:
        if isinstance(item, (list, tuple, types.GeneratorType)):
            yield from _flatten_container(item)
        else:
            yield item


</t>
<t tx="ekr.20220312061835.645">def _is_owner_ignored(owner, attrname, ignored_classes, ignored_modules):
    """Check if the given owner should be ignored

    This will verify if the owner's module is in *ignored_modules*
    or the owner's module fully qualified name is in *ignored_modules*
    or if the *ignored_modules* contains a pattern which catches
    the fully qualified name of the module.

    Also, similar checks are done for the owner itself, if its name
    matches any name from the *ignored_classes* or if its qualified
    name can be found in *ignored_classes*.
    """
    ignored_modules = set(ignored_modules)
    module_name = owner.root().name
    module_qname = owner.root().qname()

    for ignore in ignored_modules:
        # Try to match the module name / fully qualified name directly
        if module_qname in ignored_modules or module_name in ignored_modules:
            return True

        # Try to see if the ignores pattern match against the module name.
        if fnmatch.fnmatch(module_qname, ignore):
            return True

        # Otherwise we might have a root module name being ignored,
        # and the qualified owner has more levels of depth.
        parts = deque(module_name.split("."))
        current_module = ""

        while parts:
            part = parts.popleft()
            if not current_module:
                current_module = part
            else:
                current_module += f".{part}"
            if current_module in ignored_modules:
                return True

    # Match against ignored classes.
    ignored_classes = set(ignored_classes)
    qname = owner.qname() if hasattr(owner, "qname") else ""
    return any(ignore in (attrname, qname) for ignore in ignored_classes)


</t>
<t tx="ekr.20220312061835.646">@singledispatch
def _node_names(node):
    if not hasattr(node, "locals"):
        return []
    return node.locals.keys()


</t>
<t tx="ekr.20220312061835.647">@_node_names.register(nodes.ClassDef)
@_node_names.register(astroid.Instance)
def _(node):
    values = itertools.chain(node.instance_attrs.keys(), node.locals.keys())

    try:
        mro = node.mro()[1:]
    except (NotImplementedError, TypeError, astroid.MroError):
        mro = node.ancestors()

    other_values = [value for cls in mro for value in _node_names(cls)]
    return itertools.chain(values, other_values)


</t>
<t tx="ekr.20220312061835.648">def _string_distance(seq1, seq2):
    seq2_length = len(seq2)

    row = list(range(1, seq2_length + 1)) + [0]
    for seq1_index, seq1_char in enumerate(seq1):
        last_row = row
        row = [0] * seq2_length + [seq1_index + 1]

        for seq2_index, seq2_char in enumerate(seq2):
            row[seq2_index] = min(
                last_row[seq2_index] + 1,
                row[seq2_index - 1] + 1,
                last_row[seq2_index - 1] + (seq1_char != seq2_char),
            )

    return row[seq2_length - 1]


</t>
<t tx="ekr.20220312061835.649">def _similar_names(owner, attrname, distance_threshold, max_choices):
    """Given an owner and a name, try to find similar names

    The similar names are searched given a distance metric and only
    a given number of choices will be returned.
    """
    possible_names = []
    names = _node_names(owner)

    for name in names:
        if name == attrname:
            continue

        distance = _string_distance(attrname, name)
        if distance &lt;= distance_threshold:
            possible_names.append((name, distance))

    # Now get back the values with a minimum, up to the given
    # limit or choices.
    picked = [
        name
        for (name, _) in heapq.nsmallest(
            max_choices, possible_names, key=operator.itemgetter(1)
        )
    ]
    return sorted(picked)


</t>
<t tx="ekr.20220312061835.65">@classmethod
def get_regex(cls, name_type):
    return {
        "module": cls.MOD_NAME_RGX,
        "const": cls.CONST_NAME_RGX,
        "class": cls.CLASS_NAME_RGX,
        "function": cls.DEFAULT_NAME_RGX,
        "method": cls.DEFAULT_NAME_RGX,
        "attr": cls.DEFAULT_NAME_RGX,
        "argument": cls.DEFAULT_NAME_RGX,
        "variable": cls.DEFAULT_NAME_RGX,
        "class_attribute": cls.CLASS_ATTRIBUTE_RGX,
        "class_const": cls.CONST_NAME_RGX,
        "inlinevar": cls.COMP_VAR_RGX,
    }[name_type]


</t>
<t tx="ekr.20220312061835.650">def _missing_member_hint(owner, attrname, distance_threshold, max_choices):
    names = _similar_names(owner, attrname, distance_threshold, max_choices)
    if not names:
        # No similar name.
        return ""

    names = [repr(name) for name in names]
    if len(names) == 1:
        names = ", ".join(names)
    else:
        names = f"one of {', '.join(names[:-1])} or {names[-1]}"

    return f"; maybe {names}?"


</t>
<t tx="ekr.20220312061835.651">MSGS = {
    "E1101": (
        "%s %r has no %r member%s",
        "no-member",
        "Used when a variable is accessed for an unexistent member.",
        {"old_names": [("E1103", "maybe-no-member")]},
    ),
    "I1101": (
        "%s %r has no %r member%s, but source is unavailable. Consider "
        "adding this module to extension-pkg-allow-list if you want "
        "to perform analysis based on run-time introspection of living objects.",
        "c-extension-no-member",
        "Used when a variable is accessed for non-existent member of C "
        "extension. Due to unavailability of source static analysis is impossible, "
        "but it may be performed by introspecting living objects in run-time.",
    ),
    "E1102": (
        "%s is not callable",
        "not-callable",
        "Used when an object being called has been inferred to a non "
        "callable object.",
    ),
    "E1111": (
        "Assigning result of a function call, where the function has no return",
        "assignment-from-no-return",
        "Used when an assignment is done on a function call but the "
        "inferred function doesn't return anything.",
    ),
    "E1120": (
        "No value for argument %s in %s call",
        "no-value-for-parameter",
        "Used when a function call passes too few arguments.",
    ),
    "E1121": (
        "Too many positional arguments for %s call",
        "too-many-function-args",
        "Used when a function call passes too many positional arguments.",
    ),
    "E1123": (
        "Unexpected keyword argument %r in %s call",
        "unexpected-keyword-arg",
        "Used when a function call passes a keyword argument that "
        "doesn't correspond to one of the function's parameter names.",
    ),
    "E1124": (
        "Argument %r passed by position and keyword in %s call",
        "redundant-keyword-arg",
        "Used when a function call would result in assigning multiple "
        "values to a function parameter, one value from a positional "
        "argument and one from a keyword argument.",
    ),
    "E1125": (
        "Missing mandatory keyword argument %r in %s call",
        "missing-kwoa",
        (
            "Used when a function call does not pass a mandatory"
            " keyword-only argument."
        ),
    ),
    "E1126": (
        "Sequence index is not an int, slice, or instance with __index__",
        "invalid-sequence-index",
        "Used when a sequence type is indexed with an invalid type. "
        "Valid types are ints, slices, and objects with an __index__ "
        "method.",
    ),
    "E1127": (
        "Slice index is not an int, None, or instance with __index__",
        "invalid-slice-index",
        "Used when a slice index is not an integer, None, or an object "
        "with an __index__ method.",
    ),
    "E1128": (
        "Assigning result of a function call, where the function returns None",
        "assignment-from-none",
        "Used when an assignment is done on a function call but the "
        "inferred function returns nothing but None.",
        {"old_names": [("W1111", "old-assignment-from-none")]},
    ),
    "E1129": (
        "Context manager '%s' doesn't implement __enter__ and __exit__.",
        "not-context-manager",
        "Used when an instance in a with statement doesn't implement "
        "the context manager protocol(__enter__/__exit__).",
    ),
    "E1130": (
        "%s",
        "invalid-unary-operand-type",
        "Emitted when a unary operand is used on an object which does not "
        "support this type of operation.",
    ),
    "E1131": (
        "%s",
        "unsupported-binary-operation",
        "Emitted when a binary arithmetic operation between two "
        "operands is not supported.",
    ),
    "E1132": (
        "Got multiple values for keyword argument %r in function call",
        "repeated-keyword",
        "Emitted when a function call got multiple values for a keyword.",
    ),
    "E1135": (
        "Value '%s' doesn't support membership test",
        "unsupported-membership-test",
        "Emitted when an instance in membership test expression doesn't "
        "implement membership protocol (__contains__/__iter__/__getitem__).",
    ),
    "E1136": (
        "Value '%s' is unsubscriptable",
        "unsubscriptable-object",
        "Emitted when a subscripted value doesn't support subscription "
        "(i.e. doesn't define __getitem__ method or __class_getitem__ for a class).",
    ),
    "E1137": (
        "%r does not support item assignment",
        "unsupported-assignment-operation",
        "Emitted when an object does not support item assignment "
        "(i.e. doesn't define __setitem__ method).",
    ),
    "E1138": (
        "%r does not support item deletion",
        "unsupported-delete-operation",
        "Emitted when an object does not support item deletion "
        "(i.e. doesn't define __delitem__ method).",
    ),
    "E1139": (
        "Invalid metaclass %r used",
        "invalid-metaclass",
        "Emitted whenever we can detect that a class is using, "
        "as a metaclass, something which might be invalid for using as "
        "a metaclass.",
    ),
    "E1140": (
        "Dict key is unhashable",
        "unhashable-dict-key",
        "Emitted when a dict key is not hashable "
        "(i.e. doesn't define __hash__ method).",
    ),
    "E1141": (
        "Unpacking a dictionary in iteration without calling .items()",
        "dict-iter-missing-items",
        "Emitted when trying to iterate through a dict without calling .items()",
    ),
    "E1142": (
        "'await' should be used within an async function",
        "await-outside-async",
        "Emitted when await is used outside an async function.",
    ),
    "W1113": (
        "Keyword argument before variable positional arguments list "
        "in the definition of %s function",
        "keyword-arg-before-vararg",
        "When defining a keyword argument before variable positional arguments, one can "
        "end up in having multiple values passed for the aforementioned parameter in "
        "case the method is called with keyword arguments.",
    ),
    "W1114": (
        "Positional arguments appear to be out of order",
        "arguments-out-of-order",
        "Emitted  when the caller's argument names fully match the parameter "
        "names in the function signature but do not have the same order.",
    ),
    "W1115": (
        "Non-string value assigned to __name__",
        "non-str-assignment-to-dunder-name",
        "Emitted when a non-string vaue is assigned to __name__",
    ),
    "W1116": (
        "Second argument of isinstance is not a type",
        "isinstance-second-argument-not-valid-type",
        "Emitted when the second argument of an isinstance call is not a type.",
    ),
}

# builtin sequence types in Python 2 and 3.
SEQUENCE_TYPES = {
    "str",
    "unicode",
    "list",
    "tuple",
    "bytearray",
    "xrange",
    "range",
    "bytes",
    "memoryview",
}


</t>
<t tx="ekr.20220312061835.652">def _emit_no_member(node, owner, owner_name, ignored_mixins=True, ignored_none=True):
    """Try to see if no-member should be emitted for the given owner.

    The following cases are ignored:

        * the owner is a function and it has decorators.
        * the owner is an instance and it has __getattr__, __getattribute__ implemented
        * the module is explicitly ignored from no-member checks
        * the owner is a class and the name can be found in its metaclass.
        * The access node is protected by an except handler, which handles
          AttributeError, Exception or bare except.
        * The node is guarded behind and `IF` or `IFExp` node
    """
    # pylint: disable=too-many-return-statements
    if node_ignores_exception(node, AttributeError):
        return False
    if ignored_none and isinstance(owner, nodes.Const) and owner.value is None:
        return False
    if is_super(owner) or getattr(owner, "type", None) == "metaclass":
        return False
    if owner_name and ignored_mixins and owner_name[-5:].lower() == "mixin":
        return False
    if isinstance(owner, nodes.FunctionDef) and (
        owner.decorators or owner.is_abstract()
    ):
        return False
    if isinstance(owner, (astroid.Instance, nodes.ClassDef)):
        if owner.has_dynamic_getattr():
            # Issue #2565: Don't ignore enums, as they have a `__getattr__` but it's not
            # invoked at this point.
            try:
                metaclass = owner.metaclass()
            except astroid.MroError:
                return False
            if metaclass:
                # Renamed in Python 3.10 to `EnumType`
                return metaclass.qname() in ("enum.EnumMeta", "enum.EnumType")
            return False
        if not has_known_bases(owner):
            return False

        # Exclude typed annotations, since these might actually exist
        # at some point during the runtime of the program.
        if utils.is_attribute_typed_annotation(owner, node.attrname):
            return False
    if isinstance(owner, astroid.objects.Super):
        # Verify if we are dealing with an invalid Super object.
        # If it is invalid, then there's no point in checking that
        # it has the required attribute. Also, don't fail if the
        # MRO is invalid.
        try:
            owner.super_mro()
        except (astroid.MroError, astroid.SuperError):
            return False
        if not all(has_known_bases(base) for base in owner.type.mro()):
            return False
    if isinstance(owner, nodes.Module):
        try:
            owner.getattr("__getattr__")
            return False
        except astroid.NotFoundError:
            pass
    if owner_name and node.attrname.startswith("_" + owner_name):
        # Test if an attribute has been mangled ('private' attribute)
        unmangled_name = node.attrname.split("_" + owner_name)[-1]
        try:
            if owner.getattr(unmangled_name, context=None) is not None:
                return False
        except astroid.NotFoundError:
            return True
    if (
        owner.parent
        and isinstance(owner.parent, nodes.ClassDef)
        and owner.parent.name == "EnumMeta"
        and owner_name == "__members__"
        and node.attrname in ["items", "values", "keys"]
    ):
        # Avoid false positive on Enum.__members__.{items(), values, keys}
        # See https://github.com/PyCQA/pylint/issues/4123
        return False
    # Don't emit no-member if guarded behind `IF` or `IFExp`
    #   * Walk up recursively until if statement is found.
    #   * Check if condition can be inferred as `Const`,
    #       would evaluate as `False`,
    #       and wheater the node is part of the `body`.
    #   * Continue checking until scope of node is reached.
    scope: nodes.NodeNG = node.scope()
    node_origin: nodes.NodeNG = node
    parent: nodes.NodeNG = node.parent
    while parent != scope:
        if isinstance(parent, (nodes.If, nodes.IfExp)):
            inferred = safe_infer(parent.test)
            if (  # pylint: disable=too-many-boolean-expressions
                isinstance(inferred, nodes.Const)
                and inferred.bool_value() is False
                and (
                    isinstance(parent, nodes.If)
                    and node_origin in parent.body
                    or isinstance(parent, nodes.IfExp)
                    and node_origin == parent.body
                )
            ):
                return False
        node_origin, parent = parent, parent.parent

    return True


</t>
<t tx="ekr.20220312061835.653">def _determine_callable(callable_obj):
    # Ordering is important, since BoundMethod is a subclass of UnboundMethod,
    # and Function inherits Lambda.
    parameters = 0
    if hasattr(callable_obj, "implicit_parameters"):
        parameters = callable_obj.implicit_parameters()
    if isinstance(callable_obj, astroid.BoundMethod):
        # Bound methods have an extra implicit 'self' argument.
        return callable_obj, parameters, callable_obj.type
    if isinstance(callable_obj, astroid.UnboundMethod):
        return callable_obj, parameters, "unbound method"
    if isinstance(callable_obj, nodes.FunctionDef):
        return callable_obj, parameters, callable_obj.type
    if isinstance(callable_obj, nodes.Lambda):
        return callable_obj, parameters, "lambda"
    if isinstance(callable_obj, nodes.ClassDef):
        # Class instantiation, lookup __new__ instead.
        # If we only find object.__new__, we can safely check __init__
        # instead. If __new__ belongs to builtins, then we look
        # again for __init__ in the locals, since we won't have
        # argument information for the builtin __new__ function.
        try:
            # Use the last definition of __new__.
            new = callable_obj.local_attr("__new__")[-1]
        except astroid.NotFoundError:
            new = None

        from_object = new and new.parent.scope().name == "object"
        from_builtins = new and new.root().name in sys.builtin_module_names

        if not new or from_object or from_builtins:
            try:
                # Use the last definition of __init__.
                callable_obj = callable_obj.local_attr("__init__")[-1]
            except astroid.NotFoundError as e:
                # do nothing, covered by no-init.
                raise ValueError from e
        else:
            callable_obj = new

        if not isinstance(callable_obj, nodes.FunctionDef):
            raise ValueError
        # both have an extra implicit 'cls'/'self' argument.
        return callable_obj, parameters, "constructor"

    raise ValueError


</t>
<t tx="ekr.20220312061835.654">def _has_parent_of_type(node, node_type, statement):
    """Check if the given node has a parent of the given type."""
    parent = node.parent
    while not isinstance(parent, node_type) and statement.parent_of(parent):
        parent = parent.parent
    return isinstance(parent, node_type)


</t>
<t tx="ekr.20220312061835.655">def _no_context_variadic_keywords(node, scope):
    statement = node.statement()
    variadics = ()

    if isinstance(scope, nodes.Lambda) and not isinstance(scope, nodes.FunctionDef):
        variadics = list(node.keywords or []) + node.kwargs
    elif isinstance(statement, (nodes.Return, nodes.Expr, nodes.Assign)) and isinstance(
        statement.value, nodes.Call
    ):
        call = statement.value
        variadics = list(call.keywords or []) + call.kwargs

    return _no_context_variadic(node, scope.args.kwarg, nodes.Keyword, variadics)


</t>
<t tx="ekr.20220312061835.656">def _no_context_variadic_positional(node, scope):
    variadics = ()
    if isinstance(scope, nodes.Lambda) and not isinstance(scope, nodes.FunctionDef):
        variadics = node.starargs + node.kwargs
    else:
        statement = node.statement()
        if isinstance(
            statement, (nodes.Expr, nodes.Return, nodes.Assign)
        ) and isinstance(statement.value, nodes.Call):
            call = statement.value
            variadics = call.starargs + call.kwargs

    return _no_context_variadic(node, scope.args.vararg, nodes.Starred, variadics)


</t>
<t tx="ekr.20220312061835.657">def _no_context_variadic(node, variadic_name, variadic_type, variadics):
    """Verify if the given call node has variadic nodes without context

    This is a workaround for handling cases of nested call functions
    which don't have the specific call context at hand.
    Variadic arguments (variable positional arguments and variable
    keyword arguments) are inferred, inherently wrong, by astroid
    as a Tuple, respectively a Dict with empty elements.
    This can lead pylint to believe that a function call receives
    too few arguments.
    """
    scope = node.scope()
    is_in_lambda_scope = not isinstance(scope, nodes.FunctionDef) and isinstance(
        scope, nodes.Lambda
    )
    statement = node.statement()
    for name in statement.nodes_of_class(nodes.Name):
        if name.name != variadic_name:
            continue

        inferred = safe_infer(name)
        if isinstance(inferred, (nodes.List, nodes.Tuple)):
            length = len(inferred.elts)
        elif isinstance(inferred, nodes.Dict):
            length = len(inferred.items)
        else:
            continue

        if is_in_lambda_scope and isinstance(inferred.parent, nodes.Arguments):
            # The statement of the variadic will be the assignment itself,
            # so we need to go the lambda instead
            inferred_statement = inferred.parent.parent
        else:
            inferred_statement = inferred.statement()

        if not length and isinstance(inferred_statement, nodes.Lambda):
            is_in_starred_context = _has_parent_of_type(node, variadic_type, statement)
            used_as_starred_argument = any(
                variadic.value == name or variadic.value.parent_of(name)
                for variadic in variadics
            )
            if is_in_starred_context or used_as_starred_argument:
                return True
    return False


</t>
<t tx="ekr.20220312061835.658">def _is_invalid_metaclass(metaclass):
    try:
        mro = metaclass.mro()
    except NotImplementedError:
        # Cannot have a metaclass which is not a newstyle class.
        return True
    else:
        if not any(is_builtin_object(cls) and cls.name == "type" for cls in mro):
            return True
    return False


</t>
<t tx="ekr.20220312061835.659">def _infer_from_metaclass_constructor(cls, func: nodes.FunctionDef):
    """Try to infer what the given *func* constructor is building

    :param astroid.FunctionDef func:
        A metaclass constructor. Metaclass definitions can be
        functions, which should accept three arguments, the name of
        the class, the bases of the class and the attributes.
        The function could return anything, but usually it should
        be a proper metaclass.
    :param astroid.ClassDef cls:
        The class for which the *func* parameter should generate
        a metaclass.
    :returns:
        The class generated by the function or None,
        if we couldn't infer it.
    :rtype: astroid.ClassDef
    """
    context = astroid.context.InferenceContext()

    class_bases = nodes.List()
    class_bases.postinit(elts=cls.bases)

    attrs = nodes.Dict()
    local_names = [(name, values[-1]) for name, values in cls.locals.items()]
    attrs.postinit(local_names)

    builder_args = nodes.Tuple()
    builder_args.postinit([cls.name, class_bases, attrs])

    context.callcontext = astroid.context.CallContext(builder_args)
    try:
        inferred = next(func.infer_call_result(func, context), None)
    except astroid.InferenceError:
        return None
    return inferred or None


</t>
<t tx="ekr.20220312061835.66">class SnakeCaseStyle(NamingStyle):
    """Regex rules for snake_case naming style."""

    CLASS_NAME_RGX = re.compile(r"[^\W\dA-Z][^\WA-Z]+$")
    MOD_NAME_RGX = re.compile(r"[^\W\dA-Z][^\WA-Z]*$")
    CONST_NAME_RGX = re.compile(r"([^\W\dA-Z][^\WA-Z]*|__.*__)$")
    COMP_VAR_RGX = re.compile(r"[^\W\dA-Z][^\WA-Z]*$")
    DEFAULT_NAME_RGX = re.compile(
        r"([^\W\dA-Z][^\WA-Z]{2,}|_[^\WA-Z]*|__[^\WA-Z\d_][^\WA-Z]+__)$"
    )
    CLASS_ATTRIBUTE_RGX = re.compile(r"([^\W\dA-Z][^\WA-Z]{2,}|__.*__)$")


</t>
<t tx="ekr.20220312061835.660">def _is_c_extension(module_node):
    return (
        not astroid.modutils.is_standard_module(module_node.name)
        and not module_node.fully_defined()
    )


</t>
<t tx="ekr.20220312061835.661">def _is_invalid_isinstance_type(arg):
    # Return True if we are sure that arg is not a type
    inferred = utils.safe_infer(arg)
    if not inferred:
        # Cannot infer it so skip it.
        return False
    if isinstance(inferred, nodes.Tuple):
        return any(_is_invalid_isinstance_type(elt) for elt in inferred.elts)
    if isinstance(inferred, nodes.ClassDef):
        return False
    if isinstance(inferred, astroid.Instance) and inferred.qname() == BUILTIN_TUPLE:
        return False
    return True


</t>
<t tx="ekr.20220312061835.662">class TypeChecker(BaseChecker):
    """try to find bugs in the code using type inference"""

    __implements__ = (IAstroidChecker,)

    # configuration section name
    name = "typecheck"
    # messages
    msgs = MSGS
    priority = -1
    # configuration options
    options = (
        (
            "ignore-on-opaque-inference",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "This flag controls whether pylint should warn about "
                "no-member and similar checks whenever an opaque object "
                "is returned when inferring. The inference can return "
                "multiple potential results while evaluating a Python object, "
                "but some branches might not be evaluated, which results in "
                "partial inference. In that case, it might be useful to still emit "
                "no-member and other checks for the rest of the inferred objects.",
            },
        ),
        (
            "ignore-mixin-members",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": 'Tells whether missing members accessed in mixin \
class should be ignored. A mixin class is detected if its name ends with \
"mixin" (case insensitive).',
            },
        ),
        (
            "ignore-none",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Tells whether to warn about missing members when the owner "
                "of the attribute is inferred to be None.",
            },
        ),
        (
            "ignored-modules",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;module names&gt;",
                "help": "List of module names for which member attributes "
                "should not be checked (useful for modules/projects "
                "where namespaces are manipulated during runtime and "
                "thus existing member attributes cannot be "
                "deduced by static analysis). It supports qualified "
                "module names, as well as Unix pattern matching.",
            },
        ),
        # the defaults here are *stdlib* names that (almost) always
        # lead to false positives, since their idiomatic use is
        # 'too dynamic' for pylint to grok.
        (
            "ignored-classes",
            {
                "default": ("optparse.Values", "thread._local", "_thread._local"),
                "type": "csv",
                "metavar": "&lt;members names&gt;",
                "help": "List of class names for which member attributes "
                "should not be checked (useful for classes with "
                "dynamically set attributes). This supports "
                "the use of qualified names.",
            },
        ),
        (
            "generated-members",
            {
                "default": (),
                "type": "string",
                "metavar": "&lt;members names&gt;",
                "help": "List of members which are set dynamically and \
missed by pylint inference system, and so shouldn't trigger E1101 when \
accessed. Python regular expressions are accepted.",
            },
        ),
        (
            "contextmanager-decorators",
            {
                "default": ["contextlib.contextmanager"],
                "type": "csv",
                "metavar": "&lt;decorator names&gt;",
                "help": "List of decorators that produce context managers, "
                "such as contextlib.contextmanager. Add to this list "
                "to register other decorators that produce valid "
                "context managers.",
            },
        ),
        (
            "missing-member-hint-distance",
            {
                "default": 1,
                "type": "int",
                "metavar": "&lt;member hint edit distance&gt;",
                "help": "The minimum edit distance a name should have in order "
                "to be considered a similar match for a missing member name.",
            },
        ),
        (
            "missing-member-max-choices",
            {
                "default": 1,
                "type": "int",
                "metavar": "&lt;member hint max choices&gt;",
                "help": "The total number of similar names that should be taken in "
                "consideration when showing a hint for a missing member.",
            },
        ),
        (
            "missing-member-hint",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;missing member hint&gt;",
                "help": "Show a hint with possible names when a member name was not "
                "found. The aspect of finding the hint is based on edit distance.",
            },
        ),
        (
            "signature-mutators",
            {
                "default": [],
                "type": "csv",
                "metavar": "&lt;decorator names&gt;",
                "help": "List of decorators that change the signature of "
                "a decorated function.",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.663">@astroid.decorators.cachedproperty
def _suggestion_mode(self):
    return get_global_option(self, "suggestion-mode", default=True)

</t>
<t tx="ekr.20220312061835.664">@astroid.decorators.cachedproperty
def _compiled_generated_members(self) -&gt; Tuple[Pattern, ...]:
    # do this lazily since config not fully initialized in __init__
    # generated_members may contain regular expressions
    # (surrounded by quote `"` and followed by a comma `,`)
    # REQUEST,aq_parent,"[a-zA-Z]+_set{1,2}"' =&gt;
    # ('REQUEST', 'aq_parent', '[a-zA-Z]+_set{1,2}')
    generated_members = self.config.generated_members
    if isinstance(generated_members, str):
        gen = shlex.shlex(generated_members)
        gen.whitespace += ","
        gen.wordchars += r"[]-+\.*?()|"
        generated_members = tuple(tok.strip('"') for tok in gen)
    return tuple(re.compile(exp) for exp in generated_members)

</t>
<t tx="ekr.20220312061835.665">@check_messages("keyword-arg-before-vararg")
def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    # check for keyword arg before varargs
    if node.args.vararg and node.args.defaults:
        self.add_message("keyword-arg-before-vararg", node=node, args=(node.name))

</t>
<t tx="ekr.20220312061835.666">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.667">@check_messages("invalid-metaclass")
def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    def _metaclass_name(metaclass):
        # pylint: disable=unidiomatic-typecheck
        if isinstance(metaclass, (nodes.ClassDef, nodes.FunctionDef)):
            return metaclass.name
        if type(metaclass) is bases.Instance:
            # Really do mean type, not isinstance, since subclasses of bases.Instance
            # like Const or Dict should use metaclass.as_string below.
            return str(metaclass)
        return metaclass.as_string()

    metaclass = node.declared_metaclass()
    if not metaclass:
        return

    if isinstance(metaclass, nodes.FunctionDef):
        # Try to infer the result.
        metaclass = _infer_from_metaclass_constructor(node, metaclass)
        if not metaclass:
            # Don't do anything if we cannot infer the result.
            return

    if isinstance(metaclass, nodes.ClassDef):
        if _is_invalid_metaclass(metaclass):
            self.add_message(
                "invalid-metaclass", node=node, args=(_metaclass_name(metaclass),)
            )
    else:
        self.add_message(
            "invalid-metaclass", node=node, args=(_metaclass_name(metaclass),)
        )

</t>
<t tx="ekr.20220312061835.668">def visit_assignattr(self, node: nodes.AssignAttr) -&gt; None:
    if isinstance(node.assign_type(), nodes.AugAssign):
        self.visit_attribute(node)

</t>
<t tx="ekr.20220312061835.669">def visit_delattr(self, node: nodes.DelAttr) -&gt; None:
    self.visit_attribute(node)

</t>
<t tx="ekr.20220312061835.67">class CamelCaseStyle(NamingStyle):
    """Regex rules for camelCase naming style."""

    CLASS_NAME_RGX = re.compile(r"[^\W\dA-Z][^\W_]+$")
    MOD_NAME_RGX = re.compile(r"[^\W\dA-Z][^\W_]*$")
    CONST_NAME_RGX = re.compile(r"([^\W\dA-Z][^\W_]*|__.*__)$")
    COMP_VAR_RGX = re.compile(r"[^\W\dA-Z][^\W_]*$")
    DEFAULT_NAME_RGX = re.compile(r"([^\W\dA-Z][^\W_]{2,}|__[^\W\dA-Z_]\w+__)$")
    CLASS_ATTRIBUTE_RGX = re.compile(r"([^\W\dA-Z][^\W_]{2,}|__.*__)$")


</t>
<t tx="ekr.20220312061835.670">@check_messages("no-member", "c-extension-no-member")
def visit_attribute(self, node: nodes.Attribute) -&gt; None:
    """check that the accessed attribute exists

    to avoid too much false positives for now, we'll consider the code as
    correct if a single of the inferred nodes has the accessed attribute.

    function/method, super call and metaclasses are ignored
    """
    if any(
        pattern.match(name)
        for name in (node.attrname, node.as_string())
        for pattern in self._compiled_generated_members
    ):
        return

    try:
        inferred = list(node.expr.infer())
    except astroid.InferenceError:
        return

    # list of (node, nodename) which are missing the attribute
    missingattr = set()

    non_opaque_inference_results = [
        owner
        for owner in inferred
        if owner is not astroid.Uninferable and not isinstance(owner, nodes.Unknown)
    ]
    if (
        len(non_opaque_inference_results) != len(inferred)
        and self.config.ignore_on_opaque_inference
    ):
        # There is an ambiguity in the inference. Since we can't
        # make sure that we won't emit a false positive, we just stop
        # whenever the inference returns an opaque inference object.
        return
    for owner in non_opaque_inference_results:
        name = getattr(owner, "name", None)
        if _is_owner_ignored(
            owner, name, self.config.ignored_classes, self.config.ignored_modules
        ):
            continue

        qualname = f"{owner.pytype()}.{node.attrname}"
        if any(
            pattern.match(qualname) for pattern in self._compiled_generated_members
        ):
            return

        try:
            if not [
                n
                for n in owner.getattr(node.attrname)
                if not isinstance(n.statement(), nodes.AugAssign)
            ]:
                missingattr.add((owner, name))
                continue
        except AttributeError:
            continue
        except astroid.DuplicateBasesError:
            continue
        except astroid.NotFoundError:
            # This can't be moved before the actual .getattr call,
            # because there can be more values inferred and we are
            # stopping after the first one which has the attribute in question.
            # The problem is that if the first one has the attribute,
            # but we continue to the next values which doesn't have the
            # attribute, then we'll have a false positive.
            # So call this only after the call has been made.
            if not _emit_no_member(
                node,
                owner,
                name,
                ignored_mixins=self.config.ignore_mixin_members,
                ignored_none=self.config.ignore_none,
            ):
                continue
            missingattr.add((owner, name))
            continue
        # stop on the first found
        break
    else:
        # we have not found any node with the attributes, display the
        # message for inferred nodes
        done = set()
        for owner, name in missingattr:
            if isinstance(owner, astroid.Instance):
                actual = owner._proxied
            else:
                actual = owner
            if actual in done:
                continue
            done.add(actual)

            msg, hint = self._get_nomember_msgid_hint(node, owner)
            self.add_message(
                msg,
                node=node,
                args=(owner.display_type(), name, node.attrname, hint),
                confidence=INFERENCE,
            )

</t>
<t tx="ekr.20220312061835.671">def _get_nomember_msgid_hint(self, node, owner):
    suggestions_are_possible = self._suggestion_mode and isinstance(
        owner, nodes.Module
    )
    if suggestions_are_possible and _is_c_extension(owner):
        msg = "c-extension-no-member"
        hint = ""
    else:
        msg = "no-member"
        if self.config.missing_member_hint:
            hint = _missing_member_hint(
                owner,
                node.attrname,
                self.config.missing_member_hint_distance,
                self.config.missing_member_max_choices,
            )
        else:
            hint = ""
    return msg, hint

</t>
<t tx="ekr.20220312061835.672">@check_messages(
    "assignment-from-no-return",
    "assignment-from-none",
    "non-str-assignment-to-dunder-name",
)
</t>
<t tx="ekr.20220312061835.673">def visit_assign(self, node: nodes.Assign) -&gt; None:
    """
    Process assignments in the AST.
    """

    self._check_assignment_from_function_call(node)
    self._check_dundername_is_string(node)

</t>
<t tx="ekr.20220312061835.674">def _check_assignment_from_function_call(self, node):
    """check that if assigning to a function call, the function is
    possibly returning something valuable
    """
    if not isinstance(node.value, nodes.Call):
        return

    function_node = safe_infer(node.value.func)
    funcs = (nodes.FunctionDef, astroid.UnboundMethod, astroid.BoundMethod)
    if not isinstance(function_node, funcs):
        return

    # Unwrap to get the actual function object
    if isinstance(function_node, astroid.BoundMethod) and isinstance(
        function_node._proxied, astroid.UnboundMethod
    ):
        function_node = function_node._proxied._proxied

    # Make sure that it's a valid function that we can analyze.
    # Ordered from less expensive to more expensive checks.
    # pylint: disable=too-many-boolean-expressions
    if (
        not function_node.is_function
        or isinstance(function_node, nodes.AsyncFunctionDef)
        or function_node.decorators
        or function_node.is_generator()
        or function_node.is_abstract(pass_is_abstract=False)
        or utils.is_error(function_node)
        or not function_node.root().fully_defined()
    ):
        return

    returns = list(
        function_node.nodes_of_class(nodes.Return, skip_klass=nodes.FunctionDef)
    )
    if not returns:
        self.add_message("assignment-from-no-return", node=node)
    else:
        for rnode in returns:
            if not (
                isinstance(rnode.value, nodes.Const)
                and rnode.value.value is None
                or rnode.value is None
            ):
                break
        else:
            self.add_message("assignment-from-none", node=node)

</t>
<t tx="ekr.20220312061835.675">def _check_dundername_is_string(self, node):
    """
    Check a string is assigned to self.__name__
    """

    # Check the left hand side of the assignment is &lt;something&gt;.__name__
    lhs = node.targets[0]
    if not isinstance(lhs, nodes.AssignAttr):
        return
    if not lhs.attrname == "__name__":
        return

    # If the right hand side is not a string
    rhs = node.value
    if isinstance(rhs, nodes.Const) and isinstance(rhs.value, str):
        return
    inferred = utils.safe_infer(rhs)
    if not inferred:
        return
    if not (isinstance(inferred, nodes.Const) and isinstance(inferred.value, str)):
        # Add the message
        self.add_message("non-str-assignment-to-dunder-name", node=node)

</t>
<t tx="ekr.20220312061835.676">def _check_uninferable_call(self, node):
    """
    Check that the given uninferable Call node does not
    call an actual function.
    """
    if not isinstance(node.func, nodes.Attribute):
        return

    # Look for properties. First, obtain
    # the lhs of the Attribute node and search the attribute
    # there. If that attribute is a property or a subclass of properties,
    # then most likely it's not callable.

    expr = node.func.expr
    klass = safe_infer(expr)
    if (
        klass is None
        or klass is astroid.Uninferable
        or not isinstance(klass, astroid.Instance)
    ):
        return

    try:
        attrs = klass._proxied.getattr(node.func.attrname)
    except astroid.NotFoundError:
        return

    for attr in attrs:
        if attr is astroid.Uninferable:
            continue
        if not isinstance(attr, nodes.FunctionDef):
            continue

        # Decorated, see if it is decorated with a property.
        # Also, check the returns and see if they are callable.
        if decorated_with_property(attr):

            try:
                all_returns_are_callable = all(
                    return_node.callable() or return_node is astroid.Uninferable
                    for return_node in attr.infer_call_result(node)
                )
            except astroid.InferenceError:
                continue

            if not all_returns_are_callable:
                self.add_message(
                    "not-callable", node=node, args=node.func.as_string()
                )
                break

</t>
<t tx="ekr.20220312061835.677">def _check_argument_order(self, node, call_site, called, called_param_names):
    """Match the supplied argument names against the function parameters.
    Warn if some argument names are not in the same order as they are in
    the function signature.
    """
    # Check for called function being an object instance function
    # If so, ignore the initial 'self' argument in the signature
    try:
        is_classdef = isinstance(called.parent, nodes.ClassDef)
        if is_classdef and called_param_names[0] == "self":
            called_param_names = called_param_names[1:]
    except IndexError:
        return

    try:
        # extract argument names, if they have names
        calling_parg_names = [p.name for p in call_site.positional_arguments]

        # Additionally get names of keyword arguments to use in a full match
        # against parameters
        calling_kwarg_names = [
            arg.name for arg in call_site.keyword_arguments.values()
        ]
    except AttributeError:
        # the type of arg does not provide a `.name`. In this case we
        # stop checking for out-of-order arguments because it is only relevant
        # for named variables.
        return

    # Don't check for ordering if there is an unmatched arg or param
    arg_set = set(calling_parg_names) | set(calling_kwarg_names)
    param_set = set(called_param_names)
    if arg_set != param_set:
        return

    # Warn based on the equality of argument ordering
    if calling_parg_names != called_param_names[: len(calling_parg_names)]:
        self.add_message("arguments-out-of-order", node=node, args=())

</t>
<t tx="ekr.20220312061835.678">def _check_isinstance_args(self, node):
    if len(node.args) != 2:
        # isinstance called with wrong number of args
        return

    second_arg = node.args[1]
    if _is_invalid_isinstance_type(second_arg):
        self.add_message("isinstance-second-argument-not-valid-type", node=node)

</t>
<t tx="ekr.20220312061835.679"># pylint: disable=too-many-branches,too-many-locals
@check_messages(*(list(MSGS.keys())))
def visit_call(self, node: nodes.Call) -&gt; None:
    """check that called functions/methods are inferred to callable objects,
    and that the arguments passed to the function match the parameters in
    the inferred function's definition
    """
    called = safe_infer(node.func)
    # only function, generator and object defining __call__ are allowed
    # Ignore instances of descriptors since astroid cannot properly handle them
    # yet
    if called and not called.callable():
        if isinstance(called, astroid.Instance) and (
            not has_known_bases(called)
            or (
                called.parent is not None
                and isinstance(called.scope(), nodes.ClassDef)
                and "__get__" in called.locals
            )
        ):
            # Don't emit if we can't make sure this object is callable.
            pass
        else:
            self.add_message("not-callable", node=node, args=node.func.as_string())

    self._check_uninferable_call(node)
    try:
        called, implicit_args, callable_name = _determine_callable(called)
    except ValueError:
        # Any error occurred during determining the function type, most of
        # those errors are handled by different warnings.
        return

    if called.args.args is None:
        if called.name == "isinstance":
            # Verify whether second argument of isinstance is a valid type
            self._check_isinstance_args(node)
        # Built-in functions have no argument information.
        return

    if len(called.argnames()) != len(set(called.argnames())):
        # Duplicate parameter name (see duplicate-argument).  We can't really
        # make sense of the function call in this case, so just return.
        return

    # Build the set of keyword arguments, checking for duplicate keywords,
    # and count the positional arguments.
    call_site = astroid.arguments.CallSite.from_call(node)

    # Warn about duplicated keyword arguments, such as `f=24, **{'f': 24}`
    for keyword in call_site.duplicated_keywords:
        self.add_message("repeated-keyword", node=node, args=(keyword,))

    if call_site.has_invalid_arguments() or call_site.has_invalid_keywords():
        # Can't make sense of this.
        return

    # Has the function signature changed in ways we cannot reliably detect?
    if hasattr(called, "decorators") and decorated_with(
        called, self.config.signature_mutators
    ):
        return

    num_positional_args = len(call_site.positional_arguments)
    keyword_args = list(call_site.keyword_arguments.keys())
    overload_function = is_overload_stub(called)

    # Determine if we don't have a context for our call and we use variadics.
    node_scope = node.scope()
    if isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef)):
        has_no_context_positional_variadic = _no_context_variadic_positional(
            node, node_scope
        )
        has_no_context_keywords_variadic = _no_context_variadic_keywords(
            node, node_scope
        )
    else:
        has_no_context_positional_variadic = (
            has_no_context_keywords_variadic
        ) = False

    # These are coming from the functools.partial implementation in astroid
    already_filled_positionals = getattr(called, "filled_positionals", 0)
    already_filled_keywords = getattr(called, "filled_keywords", {})

    keyword_args += list(already_filled_keywords)
    num_positional_args += implicit_args + already_filled_positionals

    # Analyze the list of formal parameters.
    args = list(itertools.chain(called.args.posonlyargs or (), called.args.args))
    num_mandatory_parameters = len(args) - len(called.args.defaults)
    parameters: List[List[Any]] = []
    parameter_name_to_index = {}
    for i, arg in enumerate(args):
        if isinstance(arg, nodes.Tuple):
            name = None
            # Don't store any parameter names within the tuple, since those
            # are not assignable from keyword arguments.
        else:
            assert isinstance(arg, nodes.AssignName)
            # This occurs with:
            #    def f( (a), (b) ): pass
            name = arg.name
            parameter_name_to_index[name] = i
        if i &gt;= num_mandatory_parameters:
            defval = called.args.defaults[i - num_mandatory_parameters]
        else:
            defval = None
        parameters.append([(name, defval), False])

    kwparams = {}
    for i, arg in enumerate(called.args.kwonlyargs):
        if isinstance(arg, nodes.Keyword):
            name = arg.arg
        else:
            assert isinstance(arg, nodes.AssignName)
            name = arg.name
        kwparams[name] = [called.args.kw_defaults[i], False]

    self._check_argument_order(
        node, call_site, called, [p[0][0] for p in parameters]
    )

    # 1. Match the positional arguments.
    for i in range(num_positional_args):
        if i &lt; len(parameters):
            parameters[i][1] = True
        elif called.args.vararg is not None:
            # The remaining positional arguments get assigned to the *args
            # parameter.
            break
        elif not overload_function:
            # Too many positional arguments.
            self.add_message(
                "too-many-function-args", node=node, args=(callable_name,)
            )
            break

    # 2. Match the keyword arguments.
    for keyword in keyword_args:
        if keyword in parameter_name_to_index:
            i = parameter_name_to_index[keyword]
            if parameters[i][1]:
                # Duplicate definition of function parameter.

                # Might be too hardcoded, but this can actually
                # happen when using str.format and `self` is passed
                # by keyword argument, as in `.format(self=self)`.
                # It's perfectly valid to so, so we're just skipping
                # it if that's the case.
                if not (keyword == "self" and called.qname() in STR_FORMAT):
                    self.add_message(
                        "redundant-keyword-arg",
                        node=node,
                        args=(keyword, callable_name),
                    )
            else:
                parameters[i][1] = True
        elif keyword in kwparams:
            if kwparams[keyword][1]:
                # Duplicate definition of function parameter.
                self.add_message(
                    "redundant-keyword-arg",
                    node=node,
                    args=(keyword, callable_name),
                )
            else:
                kwparams[keyword][1] = True
        elif called.args.kwarg is not None:
            # The keyword argument gets assigned to the **kwargs parameter.
            pass
        elif not overload_function:
            # Unexpected keyword argument.
            self.add_message(
                "unexpected-keyword-arg", node=node, args=(keyword, callable_name)
            )

    # 3. Match the **kwargs, if any.
    if node.kwargs:
        for i, [(name, defval), assigned] in enumerate(parameters):
            # Assume that *kwargs provides values for all remaining
            # unassigned named parameters.
            if name is not None:
                parameters[i][1] = True
            else:
                # **kwargs can't assign to tuples.
                pass

    # Check that any parameters without a default have been assigned
    # values.
    for [(name, defval), assigned] in parameters:
        if (defval is None) and not assigned:
            display_name = "&lt;tuple&gt;" if name is None else repr(name)
            if not has_no_context_positional_variadic and not overload_function:
                self.add_message(
                    "no-value-for-parameter",
                    node=node,
                    args=(display_name, callable_name),
                )

    for name, val in kwparams.items():
        defval, assigned = val
        if (
            defval is None
            and not assigned
            and not has_no_context_keywords_variadic
            and not overload_function
        ):
            self.add_message("missing-kwoa", node=node, args=(name, callable_name))

</t>
<t tx="ekr.20220312061835.68">class PascalCaseStyle(NamingStyle):
    """Regex rules for PascalCase naming style."""

    CLASS_NAME_RGX = re.compile(r"[^\W\da-z][^\W_]+$")
    MOD_NAME_RGX = re.compile(r"[^\W\da-z][^\W_]+$")
    CONST_NAME_RGX = re.compile(r"([^\W\da-z][^\W_]*|__.*__)$")
    COMP_VAR_RGX = re.compile(r"[^\W\da-z][^\W_]+$")
    DEFAULT_NAME_RGX = re.compile(r"([^\W\da-z][^\W_]{2,}|__[^\W\dA-Z_]\w+__)$")
    CLASS_ATTRIBUTE_RGX = re.compile(r"[^\W\da-z][^\W_]{2,}$")


</t>
<t tx="ekr.20220312061835.680">def _check_invalid_sequence_index(self, subscript: nodes.Subscript):
    # Look for index operations where the parent is a sequence type.
    # If the types can be determined, only allow indices to be int,
    # slice or instances with __index__.
    parent_type = safe_infer(subscript.value)
    if not isinstance(
        parent_type, (nodes.ClassDef, astroid.Instance)
    ) or not has_known_bases(parent_type):
        return None

    # Determine what method on the parent this index will use
    # The parent of this node will be a Subscript, and the parent of that
    # node determines if the Subscript is a get, set, or delete operation.
    if subscript.ctx is astroid.Store:
        methodname = "__setitem__"
    elif subscript.ctx is astroid.Del:
        methodname = "__delitem__"
    else:
        methodname = "__getitem__"

    # Check if this instance's __getitem__, __setitem__, or __delitem__, as
    # appropriate to the statement, is implemented in a builtin sequence
    # type. This way we catch subclasses of sequence types but skip classes
    # that override __getitem__ and which may allow non-integer indices.
    try:
        methods = astroid.interpreter.dunder_lookup.lookup(parent_type, methodname)
        if methods is astroid.Uninferable:
            return None
        itemmethod = methods[0]
    except (
        astroid.AttributeInferenceError,
        IndexError,
    ):
        return None
    if (
        not isinstance(itemmethod, nodes.FunctionDef)
        or itemmethod.root().name != "builtins"
        or not itemmethod.parent
        or itemmethod.parent.name not in SEQUENCE_TYPES
    ):
        return None

    # For ExtSlice objects coming from visit_extslice, no further
    # inference is necessary, since if we got this far the ExtSlice
    # is an error.
    if isinstance(subscript.value, nodes.ExtSlice):
        index_type = subscript.value
    else:
        index_type = safe_infer(subscript.slice)
    if index_type is None or index_type is astroid.Uninferable:
        return None
    # Constants must be of type int
    if isinstance(index_type, nodes.Const):
        if isinstance(index_type.value, int):
            return None
    # Instance values must be int, slice, or have an __index__ method
    elif isinstance(index_type, astroid.Instance):
        if index_type.pytype() in ("builtins.int", "builtins.slice"):
            return None
        try:
            index_type.getattr("__index__")
            return None
        except astroid.NotFoundError:
            pass
    elif isinstance(index_type, nodes.Slice):
        # A slice can be present
        # here after inferring the index node, which could
        # be a `slice(...)` call for instance.
        return self._check_invalid_slice_index(index_type)

    # Anything else is an error
    self.add_message("invalid-sequence-index", node=subscript)
    return None

</t>
<t tx="ekr.20220312061835.681">@check_messages("invalid-sequence-index")
def visit_extslice(self, node: nodes.ExtSlice) -&gt; None:
    if not node.parent or not hasattr(node.parent, "value"):
        return None
    # Check extended slice objects as if they were used as a sequence
    # index to check if the object being sliced can support them
    return self._check_invalid_sequence_index(node.parent)

</t>
<t tx="ekr.20220312061835.682">def _check_invalid_slice_index(self, node):
    # Check the type of each part of the slice
    invalid_slices = 0
    for index in (node.lower, node.upper, node.step):
        if index is None:
            continue

        index_type = safe_infer(index)
        if index_type is None or index_type is astroid.Uninferable:
            continue

        # Constants must of type int or None
        if isinstance(index_type, nodes.Const):
            if isinstance(index_type.value, (int, type(None))):
                continue
        # Instance values must be of type int, None or an object
        # with __index__
        elif isinstance(index_type, astroid.Instance):
            if index_type.pytype() in ("builtins.int", "builtins.NoneType"):
                continue

            try:
                index_type.getattr("__index__")
                return
            except astroid.NotFoundError:
                pass
        invalid_slices += 1

    if not invalid_slices:
        return

    # Anything else is an error, unless the object that is indexed
    # is a custom object, which knows how to handle this kind of slices
    parent = node.parent
    if isinstance(parent, nodes.ExtSlice):
        parent = parent.parent
    if isinstance(parent, nodes.Subscript):
        inferred = safe_infer(parent.value)
        if inferred is None or inferred is astroid.Uninferable:
            # Don't know what this is
            return
        known_objects = (
            nodes.List,
            nodes.Dict,
            nodes.Tuple,
            astroid.objects.FrozenSet,
            nodes.Set,
        )
        if not isinstance(inferred, known_objects):
            # Might be an instance that knows how to handle this slice object
            return
    for _ in range(invalid_slices):
        self.add_message("invalid-slice-index", node=node)

</t>
<t tx="ekr.20220312061835.683">@check_messages("not-context-manager")
def visit_with(self, node: nodes.With) -&gt; None:
    for ctx_mgr, _ in node.items:
        context = astroid.context.InferenceContext()
        inferred = safe_infer(ctx_mgr, context=context)
        if inferred is None or inferred is astroid.Uninferable:
            continue

        if isinstance(inferred, astroid.bases.Generator):
            # Check if we are dealing with a function decorated
            # with contextlib.contextmanager.
            if decorated_with(
                inferred.parent, self.config.contextmanager_decorators
            ):
                continue
            # If the parent of the generator is not the context manager itself,
            # that means that it could have been returned from another
            # function which was the real context manager.
            # The following approach is more of a hack rather than a real
            # solution: walk all the inferred statements for the
            # given *ctx_mgr* and if you find one function scope
            # which is decorated, consider it to be the real
            # manager and give up, otherwise emit not-context-manager.
            # See the test file for not_context_manager for a couple
            # of self explaining tests.

            # Retrieve node from all previusly visited nodes in the the inference history
            context_path_names: Iterator[Any] = filter(
                None, _unflatten(context.path)
            )
            inferred_paths = _flatten_container(
                safe_infer(path) for path in context_path_names
            )
            for inferred_path in inferred_paths:
                if not inferred_path:
                    continue
                scope = inferred_path.scope()
                if not isinstance(scope, nodes.FunctionDef):
                    continue
                if decorated_with(scope, self.config.contextmanager_decorators):
                    break
            else:
                self.add_message(
                    "not-context-manager", node=node, args=(inferred.name,)
                )
        else:
            try:
                inferred.getattr("__enter__")
                inferred.getattr("__exit__")
            except astroid.NotFoundError:
                if isinstance(inferred, astroid.Instance):
                    # If we do not know the bases of this class,
                    # just skip it.
                    if not has_known_bases(inferred):
                        continue
                    # Just ignore mixin classes.
                    if self.config.ignore_mixin_members:
                        if inferred.name[-5:].lower() == "mixin":
                            continue

                self.add_message(
                    "not-context-manager", node=node, args=(inferred.name,)
                )

</t>
<t tx="ekr.20220312061835.684">@check_messages("invalid-unary-operand-type")
def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:
    """Detect TypeErrors for unary operands."""

    for error in node.type_errors():
        # Let the error customize its output.
        self.add_message("invalid-unary-operand-type", args=str(error), node=node)

</t>
<t tx="ekr.20220312061835.685">@check_messages("unsupported-binary-operation")
def visit_binop(self, node: nodes.BinOp) -&gt; None:
    if node.op == "|":
        self._detect_unsupported_alternative_union_syntax(node)

</t>
<t tx="ekr.20220312061835.686">def _detect_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -&gt; None:
    """Detect if unsupported alternative Union syntax (PEP 604) was used."""
    if PY310_PLUS:  # 310+ supports the new syntax
        return

    if isinstance(
        node.parent, TYPE_ANNOTATION_NODES_TYPES
    ) and not is_postponed_evaluation_enabled(node):
        # Use in type annotations only allowed if
        # postponed evaluation is enabled.
        self._check_unsupported_alternative_union_syntax(node)

    if isinstance(
        node.parent,
        (
            nodes.Assign,
            nodes.Call,
            nodes.Keyword,
            nodes.Dict,
            nodes.Tuple,
            nodes.Set,
            nodes.List,
            nodes.BinOp,
        ),
    ):
        # Check other contexts the syntax might appear, but are invalid.
        # Make sure to filter context if postponed evaluation is enabled
        # and parent is allowed node type.
        allowed_nested_syntax = False
        if is_postponed_evaluation_enabled(node):
            parent_node = node.parent
            while True:
                if isinstance(parent_node, TYPE_ANNOTATION_NODES_TYPES):
                    allowed_nested_syntax = True
                    break
                parent_node = parent_node.parent
                if isinstance(parent_node, nodes.Module):
                    break
        if not allowed_nested_syntax:
            self._check_unsupported_alternative_union_syntax(node)

</t>
<t tx="ekr.20220312061835.687">def _check_unsupported_alternative_union_syntax(self, node: nodes.BinOp) -&gt; None:
    """Check if left or right node is of type `type`."""
    msg = "unsupported operand type(s) for |"
    for n in (node.left, node.right):
        n = astroid.helpers.object_type(n)
        if isinstance(n, nodes.ClassDef) and is_classdef_type(n):
            self.add_message("unsupported-binary-operation", args=msg, node=node)
            break

</t>
<t tx="ekr.20220312061835.688">@check_messages("unsupported-binary-operation")
def _visit_binop(self, node: nodes.BinOp) -&gt; None:
    """Detect TypeErrors for binary arithmetic operands."""
    self._check_binop_errors(node)

</t>
<t tx="ekr.20220312061835.689">@check_messages("unsupported-binary-operation")
def _visit_augassign(self, node: nodes.AugAssign) -&gt; None:
    """Detect TypeErrors for augmented binary arithmetic operands."""
    self._check_binop_errors(node)

</t>
<t tx="ekr.20220312061835.69">class UpperCaseStyle(NamingStyle):
    """Regex rules for UPPER_CASE naming style."""

    CLASS_NAME_RGX = re.compile(r"[^\W\da-z][^\Wa-z]+$")
    MOD_NAME_RGX = re.compile(r"[^\W\da-z][^\Wa-z]+$")
    CONST_NAME_RGX = re.compile(r"([^\W\da-z][^\Wa-z]*|__.*__)$")
    COMP_VAR_RGX = re.compile(r"[^\W\da-z][^\Wa-z]+$")
    DEFAULT_NAME_RGX = re.compile(r"([^\W\da-z][^\Wa-z]{2,}|__[^\W\dA-Z_]\w+__)$")
    CLASS_ATTRIBUTE_RGX = re.compile(r"[^\W\da-z][^\Wa-z]{2,}$")


</t>
<t tx="ekr.20220312061835.690">def _check_binop_errors(self, node):
    for error in node.type_errors():
        # Let the error customize its output.
        if any(
            isinstance(obj, nodes.ClassDef) and not has_known_bases(obj)
            for obj in (error.left_type, error.right_type)
        ):
            continue
        self.add_message("unsupported-binary-operation", args=str(error), node=node)

</t>
<t tx="ekr.20220312061835.691">def _check_membership_test(self, node):
    if is_inside_abstract_class(node):
        return
    if is_comprehension(node):
        return
    inferred = safe_infer(node)
    if inferred is None or inferred is astroid.Uninferable:
        return
    if not supports_membership_test(inferred):
        self.add_message(
            "unsupported-membership-test", args=node.as_string(), node=node
        )

</t>
<t tx="ekr.20220312061835.692">@check_messages("unsupported-membership-test")
def visit_compare(self, node: nodes.Compare) -&gt; None:
    if len(node.ops) != 1:
        return

    op, right = node.ops[0]
    if op in ["in", "not in"]:
        self._check_membership_test(right)

</t>
<t tx="ekr.20220312061835.693">@check_messages(
    "unsubscriptable-object",
    "unsupported-assignment-operation",
    "unsupported-delete-operation",
    "unhashable-dict-key",
    "invalid-sequence-index",
    "invalid-slice-index",
)
</t>
<t tx="ekr.20220312061835.694">def visit_subscript(self, node: nodes.Subscript) -&gt; None:
    self._check_invalid_sequence_index(node)

    supported_protocol: Optional[Callable[[Any, Any], bool]] = None
    if isinstance(node.value, (nodes.ListComp, nodes.DictComp)):
        return

    if isinstance(node.value, nodes.Dict):
        # Assert dict key is hashable
        inferred = safe_infer(node.slice)
        if inferred and inferred != astroid.Uninferable:
            try:
                hash_fn = next(inferred.igetattr("__hash__"))
            except astroid.InferenceError:
                pass
            else:
                if getattr(hash_fn, "value", True) is None:
                    self.add_message("unhashable-dict-key", node=node.value)

    if node.ctx == astroid.Load:
        supported_protocol = supports_getitem
        msg = "unsubscriptable-object"
    elif node.ctx == astroid.Store:
        supported_protocol = supports_setitem
        msg = "unsupported-assignment-operation"
    elif node.ctx == astroid.Del:
        supported_protocol = supports_delitem
        msg = "unsupported-delete-operation"

    if isinstance(node.value, nodes.SetComp):
        self.add_message(msg, args=node.value.as_string(), node=node.value)
        return

    if is_inside_abstract_class(node):
        return

    inferred = safe_infer(node.value)

    if inferred is None or inferred is astroid.Uninferable:
        return

    if getattr(inferred, "decorators", None):
        first_decorator = astroid.helpers.safe_infer(inferred.decorators.nodes[0])
        if isinstance(first_decorator, nodes.ClassDef):
            inferred = first_decorator.instantiate_class()
        else:
            return  # It would be better to handle function
            # decorators, but let's start slow.

    if supported_protocol and not supported_protocol(inferred, node):
        self.add_message(msg, args=node.value.as_string(), node=node.value)

</t>
<t tx="ekr.20220312061835.695">@check_messages("dict-items-missing-iter")
def visit_for(self, node: nodes.For) -&gt; None:
    if not isinstance(node.target, nodes.Tuple):
        # target is not a tuple
        return
    if not len(node.target.elts) == 2:
        # target is not a tuple of two elements
        return

    iterable = node.iter
    if not isinstance(iterable, nodes.Name):
        # it's not a bare variable
        return

    inferred = safe_infer(iterable)
    if not inferred:
        return
    if not isinstance(inferred, nodes.Dict):
        # the iterable is not a dict
        return

    if all(isinstance(i[0], nodes.Tuple) for i in inferred.items):
        # if all keys are tuples
        return

    self.add_message("dict-iter-missing-items", node=node)


</t>
<t tx="ekr.20220312061835.696">class IterableChecker(BaseChecker):
    """
    Checks for non-iterables used in an iterable context.
    Contexts include:
    - for-statement
    - starargs in function call
    - `yield from`-statement
    - list, dict and set comprehensions
    - generator expressions
    Also checks for non-mappings in function call kwargs.
    """

    __implements__ = (IAstroidChecker,)
    name = "typecheck"

    msgs = {
        "E1133": (
            "Non-iterable value %s is used in an iterating context",
            "not-an-iterable",
            "Used when a non-iterable value is used in place where "
            "iterable is expected",
        ),
        "E1134": (
            "Non-mapping value %s is used in a mapping context",
            "not-a-mapping",
            "Used when a non-mapping value is used in place where "
            "mapping is expected",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.697">@staticmethod
def _is_asyncio_coroutine(node):
    if not isinstance(node, nodes.Call):
        return False

    inferred_func = safe_infer(node.func)
    if not isinstance(inferred_func, nodes.FunctionDef):
        return False
    if not inferred_func.decorators:
        return False
    for decorator in inferred_func.decorators.nodes:
        inferred_decorator = safe_infer(decorator)
        if not isinstance(inferred_decorator, nodes.FunctionDef):
            continue
        if inferred_decorator.qname() != ASYNCIO_COROUTINE:
            continue
        return True
    return False

</t>
<t tx="ekr.20220312061835.698">def _check_iterable(self, node, check_async=False):
    if is_inside_abstract_class(node) or is_comprehension(node):
        return
    inferred = safe_infer(node)
    if not inferred:
        return
    if not is_iterable(inferred, check_async=check_async):
        self.add_message("not-an-iterable", args=node.as_string(), node=node)

</t>
<t tx="ekr.20220312061835.699">def _check_mapping(self, node):
    if is_inside_abstract_class(node):
        return
    if isinstance(node, nodes.DictComp):
        return
    inferred = safe_infer(node)
    if inferred is None or inferred is astroid.Uninferable:
        return
    if not is_mapping(inferred):
        self.add_message("not-a-mapping", args=node.as_string(), node=node)

</t>
<t tx="ekr.20220312061835.7">def py_run(command_options="", return_std=False, stdout=None, stderr=None):
    """Run pylint from python

    ``command_options`` is a string containing ``pylint`` command line options;
    ``return_std`` (boolean) indicates return of created standard output
    and error (see below);
    ``stdout`` and ``stderr`` are 'file-like' objects in which standard output
    could be written.

    Calling agent is responsible for stdout/err management (creation, close).
    Default standard output and error are those from sys,
    or standalone ones (``subprocess.PIPE``) are used
    if they are not set and ``return_std``.

    If ``return_std`` is set to ``True``, this function returns a 2-uple
    containing standard output and error related to created process,
    as follows: ``(stdout, stderr)``.

    To silently run Pylint on a module, and get its standard output and error:
        &gt;&gt;&gt; (pylint_stdout, pylint_stderr) = py_run( 'module_name.py', True)
    """
    # Detect if we use Python as executable or not, else default to `python`
    executable = sys.executable if "python" in sys.executable else "python"

    # Create command line to call pylint
    epylint_part = [executable, "-c", "from pylint import epylint;epylint.Run()"]
    options = shlex.split(command_options, posix=not sys.platform.startswith("win"))
    cli = epylint_part + options

    # Providing standard output and/or error if not set
    if stdout is None:
        stdout = PIPE if return_std else sys.stdout
    if stderr is None:
        stderr = PIPE if return_std else sys.stderr
    # Call pylint in a subprocess
    with Popen(
        cli,
        shell=False,
        stdout=stdout,
        stderr=stderr,
        env=_get_env(),
        universal_newlines=True,
    ) as process:
        proc_stdout, proc_stderr = process.communicate()
        # Return standard output and error
        if return_std:
            return StringIO(proc_stdout), StringIO(proc_stderr)
        return None


</t>
<t tx="ekr.20220312061835.70">class AnyStyle(NamingStyle):
    pass


</t>
<t tx="ekr.20220312061835.700">@check_messages("not-an-iterable")
def visit_for(self, node: nodes.For) -&gt; None:
    self._check_iterable(node.iter)

</t>
<t tx="ekr.20220312061835.701">@check_messages("not-an-iterable")
def visit_asyncfor(self, node: nodes.AsyncFor) -&gt; None:
    self._check_iterable(node.iter, check_async=True)

</t>
<t tx="ekr.20220312061835.702">@check_messages("not-an-iterable")
def visit_yieldfrom(self, node: nodes.YieldFrom) -&gt; None:
    if self._is_asyncio_coroutine(node.value):
        return
    self._check_iterable(node.value)

</t>
<t tx="ekr.20220312061835.703">@check_messages("not-an-iterable", "not-a-mapping")
def visit_call(self, node: nodes.Call) -&gt; None:
    for stararg in node.starargs:
        self._check_iterable(stararg.value)
    for kwarg in node.kwargs:
        self._check_mapping(kwarg.value)

</t>
<t tx="ekr.20220312061835.704">@check_messages("not-an-iterable")
def visit_listcomp(self, node: nodes.ListComp) -&gt; None:
    for gen in node.generators:
        self._check_iterable(gen.iter, check_async=gen.is_async)

</t>
<t tx="ekr.20220312061835.705">@check_messages("not-an-iterable")
def visit_dictcomp(self, node: nodes.DictComp) -&gt; None:
    for gen in node.generators:
        self._check_iterable(gen.iter, check_async=gen.is_async)

</t>
<t tx="ekr.20220312061835.706">@check_messages("not-an-iterable")
def visit_setcomp(self, node: nodes.SetComp) -&gt; None:
    for gen in node.generators:
        self._check_iterable(gen.iter, check_async=gen.is_async)

</t>
<t tx="ekr.20220312061835.707">@check_messages("not-an-iterable")
def visit_generatorexp(self, node: nodes.GeneratorExp) -&gt; None:
    for gen in node.generators:
        self._check_iterable(gen.iter, check_async=gen.is_async)

</t>
<t tx="ekr.20220312061835.708">@check_messages("await-outside-async")
def visit_await(self, node: nodes.Await) -&gt; None:
    self._check_await_outside_coroutine(node)

</t>
<t tx="ekr.20220312061835.709">def _check_await_outside_coroutine(self, node: nodes.Await) -&gt; None:
    node_scope = node.scope()
    while not isinstance(node_scope, nodes.Module):
        if isinstance(node_scope, nodes.AsyncFunctionDef):
            return
        if isinstance(node_scope, nodes.FunctionDef):
            break
        node_scope = node_scope.parent.scope()
    self.add_message("await-outside-async", node=node)


</t>
<t tx="ekr.20220312061835.71">NAMING_STYLES = {
    "snake_case": SnakeCaseStyle,
    "camelCase": CamelCaseStyle,
    "PascalCase": PascalCaseStyle,
    "UPPER_CASE": UpperCaseStyle,
    "any": AnyStyle,
}

# do not require a doc string on private/system methods
NO_REQUIRED_DOC_RGX = re.compile("^_")
REVERSED_PROTOCOL_METHOD = "__reversed__"
SEQUENCE_PROTOCOL_METHODS = ("__getitem__", "__len__")
REVERSED_METHODS = (SEQUENCE_PROTOCOL_METHODS, (REVERSED_PROTOCOL_METHOD,))
TYPECHECK_COMPARISON_OPERATORS = frozenset(("is", "is not", "==", "!="))
LITERAL_NODE_TYPES = (nodes.Const, nodes.Dict, nodes.List, nodes.Set)
UNITTEST_CASE = "unittest.case"
TYPE_QNAME = "builtins.type"
ABC_METACLASSES = {"_py_abc.ABCMeta", "abc.ABCMeta"}  # Python 3.7+,

# Name categories that are always consistent with all naming conventions.
EXEMPT_NAME_CATEGORIES = {"exempt", "ignore"}

# A mapping from qname -&gt; symbol, to be used when generating messages
# about dangerous default values as arguments
DEFAULT_ARGUMENT_SYMBOLS = dict(
    zip(
        [".".join(["builtins", x]) for x in ("set", "dict", "list")],
        ["set()", "{}", "[]"],
    ),
    **{
        x: f"{x}()"
        for x in (
            "collections.deque",
            "collections.ChainMap",
            "collections.Counter",
            "collections.OrderedDict",
            "collections.defaultdict",
            "collections.UserDict",
            "collections.UserList",
        )
    },
)
REVERSED_COMPS = {"&lt;": "&gt;", "&lt;=": "&gt;=", "&gt;": "&lt;", "&gt;=": "&lt;="}
COMPARISON_OPERATORS = frozenset(("==", "!=", "&lt;", "&gt;", "&lt;=", "&gt;="))
# List of methods which can be redefined
REDEFINABLE_METHODS = frozenset(("__module__",))
TYPING_FORWARD_REF_QNAME = "typing.ForwardRef"


</t>
<t tx="ekr.20220312061835.710">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(TypeChecker(linter))
    linter.register_checker(IterableChecker(linter))
</t>
<t tx="ekr.20220312061835.711">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2007, 2009-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;
# Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;
# Copyright (c) 2012-2014 Google, Inc.
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Ricardo Gemignani &lt;ricardo.gemignani@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Florian Bruhin &lt;me@the-compiler.org&gt;
# Copyright (c) 2015 Radu Ciorba &lt;radu@devrandom.ro&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2018-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016-2017 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2016 Brian C. Lane &lt;bcl@redhat.com&gt;
# Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017 ttenhoeve-aa &lt;ttenhoeve@appannie.com&gt;
# Copyright (c) 2018 Alan Chan &lt;achan961117@gmail.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 Yury Gribov &lt;tetra2005@gmail.com&gt;
# Copyright (c) 2018 Caio Carrara &lt;ccarrara@redhat.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2018 Brian Shaginaw &lt;brian.shaginaw@warbyparker.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Matthijs Blom &lt;19817960+MatthijsBlom@users.noreply.github.com&gt;
# Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2019 Nathan Marrow &lt;nmarrow@google.com&gt;
# Copyright (c) 2019 Svet &lt;svet@hyperscience.com&gt;
# Copyright (c) 2019 Pascal Corpet &lt;pcorpet@users.noreply.github.com&gt;
# Copyright (c) 2020 Batuhan Taskaya &lt;batuhanosmantaskaya@gmail.com&gt;
# Copyright (c) 2020 Luigi &lt;luigi.cristofolini@q-ctrl.com&gt;
# Copyright (c) 2020 ethan-leba &lt;ethanleba5@gmail.com&gt;
# Copyright (c) 2020 Damien Baty &lt;damien.baty@polyconseil.fr&gt;
# Copyright (c) 2020 Andrew Simmons &lt;anjsimmo@gmail.com&gt;
# Copyright (c) 2020 Ram Rachum &lt;ram@rachum.com&gt;
# Copyright (c) 2020 Slavfox &lt;slavfoxman@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2021 David Liu &lt;david@cs.toronto.edu&gt;
# Copyright (c) 2021 Matus Valo &lt;matusvalo@users.noreply.github.com&gt;
# Copyright (c) 2021 Lorena B &lt;46202743+lorena-b@users.noreply.github.com&gt;
# Copyright (c) 2021 yushao2 &lt;36848472+yushao2@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""some functions that may be useful for various checkers
"""
import builtins
import itertools
import numbers
import re
import string
from functools import lru_cache, partial
from typing import Callable, Dict, Iterable, List, Match, Optional, Set, Tuple, Union

import _string
import astroid
import astroid.objects
from astroid import TooManyLevelsError, nodes
from astroid.context import InferenceContext

COMP_NODE_TYPES = (
    nodes.ListComp,
    nodes.SetComp,
    nodes.DictComp,
    nodes.GeneratorExp,
)
EXCEPTIONS_MODULE = "builtins"
ABC_MODULES = {"abc", "_py_abc"}
ABC_METHODS = {
    "abc.abstractproperty",
    "abc.abstractmethod",
    "abc.abstractclassmethod",
    "abc.abstractstaticmethod",
}
TYPING_PROTOCOLS = frozenset(
    {"typing.Protocol", "typing_extensions.Protocol", ".Protocol"}
)
ITER_METHOD = "__iter__"
AITER_METHOD = "__aiter__"
NEXT_METHOD = "__next__"
GETITEM_METHOD = "__getitem__"
CLASS_GETITEM_METHOD = "__class_getitem__"
SETITEM_METHOD = "__setitem__"
DELITEM_METHOD = "__delitem__"
CONTAINS_METHOD = "__contains__"
KEYS_METHOD = "keys"

# Dictionary which maps the number of expected parameters a
# special method can have to a set of special methods.
# The following keys are used to denote the parameters restrictions:
#
# * None: variable number of parameters
# * number: exactly that number of parameters
# * tuple: this are the odd ones. Basically it means that the function
#          can work with any number of arguments from that tuple,
#          although it's best to implement it in order to accept
#          all of them.
_SPECIAL_METHODS_PARAMS = {
    None: ("__new__", "__init__", "__call__"),
    0: (
        "__del__",
        "__repr__",
        "__str__",
        "__bytes__",
        "__hash__",
        "__bool__",
        "__dir__",
        "__len__",
        "__length_hint__",
        "__iter__",
        "__reversed__",
        "__neg__",
        "__pos__",
        "__abs__",
        "__invert__",
        "__complex__",
        "__int__",
        "__float__",
        "__index__",
        "__trunc__",
        "__floor__",
        "__ceil__",
        "__enter__",
        "__aenter__",
        "__getnewargs_ex__",
        "__getnewargs__",
        "__getstate__",
        "__reduce__",
        "__copy__",
        "__unicode__",
        "__nonzero__",
        "__await__",
        "__aiter__",
        "__anext__",
        "__fspath__",
    ),
    1: (
        "__format__",
        "__lt__",
        "__le__",
        "__eq__",
        "__ne__",
        "__gt__",
        "__ge__",
        "__getattr__",
        "__getattribute__",
        "__delattr__",
        "__delete__",
        "__instancecheck__",
        "__subclasscheck__",
        "__getitem__",
        "__missing__",
        "__delitem__",
        "__contains__",
        "__add__",
        "__sub__",
        "__mul__",
        "__truediv__",
        "__floordiv__",
        "__rfloordiv__",
        "__mod__",
        "__divmod__",
        "__lshift__",
        "__rshift__",
        "__and__",
        "__xor__",
        "__or__",
        "__radd__",
        "__rsub__",
        "__rmul__",
        "__rtruediv__",
        "__rmod__",
        "__rdivmod__",
        "__rpow__",
        "__rlshift__",
        "__rrshift__",
        "__rand__",
        "__rxor__",
        "__ror__",
        "__iadd__",
        "__isub__",
        "__imul__",
        "__itruediv__",
        "__ifloordiv__",
        "__imod__",
        "__ilshift__",
        "__irshift__",
        "__iand__",
        "__ixor__",
        "__ior__",
        "__ipow__",
        "__setstate__",
        "__reduce_ex__",
        "__deepcopy__",
        "__cmp__",
        "__matmul__",
        "__rmatmul__",
        "__imatmul__",
        "__div__",
    ),
    2: ("__setattr__", "__get__", "__set__", "__setitem__", "__set_name__"),
    3: ("__exit__", "__aexit__"),
    (0, 1): ("__round__",),
    (1, 2): ("__pow__",),
}

SPECIAL_METHODS_PARAMS = {
    name: params
    for params, methods in _SPECIAL_METHODS_PARAMS.items()
    for name in methods
}
PYMETHODS = set(SPECIAL_METHODS_PARAMS)

SUBSCRIPTABLE_CLASSES_PEP585 = frozenset(
    (
        "builtins.tuple",
        "builtins.list",
        "builtins.dict",
        "builtins.set",
        "builtins.frozenset",
        "builtins.type",
        "collections.deque",
        "collections.defaultdict",
        "collections.OrderedDict",
        "collections.Counter",
        "collections.ChainMap",
        "_collections_abc.Awaitable",
        "_collections_abc.Coroutine",
        "_collections_abc.AsyncIterable",
        "_collections_abc.AsyncIterator",
        "_collections_abc.AsyncGenerator",
        "_collections_abc.Iterable",
        "_collections_abc.Iterator",
        "_collections_abc.Generator",
        "_collections_abc.Reversible",
        "_collections_abc.Container",
        "_collections_abc.Collection",
        "_collections_abc.Callable",
        "_collections_abc.Set",
        "_collections_abc.MutableSet",
        "_collections_abc.Mapping",
        "_collections_abc.MutableMapping",
        "_collections_abc.Sequence",
        "_collections_abc.MutableSequence",
        "_collections_abc.ByteString",
        "_collections_abc.MappingView",
        "_collections_abc.KeysView",
        "_collections_abc.ItemsView",
        "_collections_abc.ValuesView",
        "contextlib.AbstractContextManager",
        "contextlib.AbstractAsyncContextManager",
        "re.Pattern",
        "re.Match",
    )
)


@others
</t>
<t tx="ekr.20220312061835.712">class NoSuchArgumentError(Exception):
    pass


</t>
<t tx="ekr.20220312061835.713">class InferredTypeError(Exception):
    pass


</t>
<t tx="ekr.20220312061835.714">def is_inside_lambda(node: nodes.NodeNG) -&gt; bool:
    """Return true if given node is inside lambda"""
    parent = node.parent
    while parent is not None:
        if isinstance(parent, nodes.Lambda):
            return True
        parent = parent.parent
    return False


</t>
<t tx="ekr.20220312061835.715">def get_all_elements(
    node: nodes.NodeNG,
) -&gt; Iterable[nodes.NodeNG]:
    """Recursively returns all atoms in nested lists and tuples."""
    if isinstance(node, (nodes.Tuple, nodes.List)):
        for child in node.elts:
            yield from get_all_elements(child)
    else:
        yield node


</t>
<t tx="ekr.20220312061835.716">def is_super(node: nodes.NodeNG) -&gt; bool:
    """return True if the node is referencing the "super" builtin function"""
    if getattr(node, "name", None) == "super" and node.root().name == "builtins":
        return True
    return False


</t>
<t tx="ekr.20220312061835.717">def is_error(node: nodes.FunctionDef) -&gt; bool:
    """Return true if the given function node only raises an exception"""
    return len(node.body) == 1 and isinstance(node.body[0], nodes.Raise)


</t>
<t tx="ekr.20220312061835.718">builtins = builtins.__dict__.copy()  # type: ignore
SPECIAL_BUILTINS = ("__builtins__",)  # '__path__', '__file__')


</t>
<t tx="ekr.20220312061835.719">def is_builtin_object(node: nodes.NodeNG) -&gt; bool:
    """Returns True if the given node is an object from the __builtin__ module."""
    return node and node.root().name == "builtins"


</t>
<t tx="ekr.20220312061835.72">def _redefines_import(node):
    """Detect that the given node (AssignName) is inside an
    exception handler and redefines an import from the tryexcept body.
    Returns True if the node redefines an import, False otherwise.
    """
    current = node
    while current and not isinstance(current.parent, nodes.ExceptHandler):
        current = current.parent
    if not current or not utils.error_of_type(current.parent, ImportError):
        return False
    try_block = current.parent.parent
    for import_node in try_block.nodes_of_class((nodes.ImportFrom, nodes.Import)):
        for name, alias in import_node.names:
            if alias:
                if alias == node.name:
                    return True
            elif name == node.name:
                return True
    return False


</t>
<t tx="ekr.20220312061835.720">def is_builtin(name: str) -&gt; bool:
    """return true if &lt;name&gt; could be considered as a builtin defined by python"""
    return name in builtins or name in SPECIAL_BUILTINS  # type: ignore


</t>
<t tx="ekr.20220312061835.721">def is_defined_in_scope(
    var_node: nodes.NodeNG,
    varname: str,
    scope: nodes.NodeNG,
) -&gt; bool:
    if isinstance(scope, nodes.If):
        for node in scope.body:
            if (
                isinstance(node, nodes.Assign)
                and any(
                    isinstance(target, nodes.AssignName) and target.name == varname
                    for target in node.targets
                )
            ) or (isinstance(node, nodes.Nonlocal) and varname in node.names):
                return True
    elif isinstance(scope, (COMP_NODE_TYPES, nodes.For)):
        for ass_node in scope.nodes_of_class(nodes.AssignName):
            if ass_node.name == varname:
                return True
    elif isinstance(scope, nodes.With):
        for expr, ids in scope.items:
            if expr.parent_of(var_node):
                break
            if ids and isinstance(ids, nodes.AssignName) and ids.name == varname:
                return True
    elif isinstance(scope, (nodes.Lambda, nodes.FunctionDef)):
        if scope.args.is_argument(varname):
            # If the name is found inside a default value
            # of a function, then let the search continue
            # in the parent's tree.
            if scope.args.parent_of(var_node):
                try:
                    scope.args.default_value(varname)
                    scope = scope.parent
                    is_defined_in_scope(var_node, varname, scope)
                except astroid.NoDefault:
                    pass
            return True
        if getattr(scope, "name", None) == varname:
            return True
    elif isinstance(scope, nodes.ExceptHandler):
        if isinstance(scope.name, nodes.AssignName):
            ass_node = scope.name
            if ass_node.name == varname:
                return True
    return False


</t>
<t tx="ekr.20220312061835.722">def is_defined_before(var_node: nodes.Name) -&gt; bool:
    """Check if the given variable node is defined before

    Verify that the variable node is defined by a parent node
    (list, set, dict, or generator comprehension, lambda)
    or in a previous sibling node on the same line
    (statement_defining ; statement_using).
    """
    varname = var_node.name
    _node = var_node.parent
    while _node:
        if is_defined_in_scope(var_node, varname, _node):
            return True
        _node = _node.parent
    # possibly multiple statements on the same line using semi colon separator
    stmt = var_node.statement()
    _node = stmt.previous_sibling()
    lineno = stmt.fromlineno
    while _node and _node.fromlineno == lineno:
        for assign_node in _node.nodes_of_class(nodes.AssignName):
            if assign_node.name == varname:
                return True
        for imp_node in _node.nodes_of_class((nodes.ImportFrom, nodes.Import)):
            if varname in [name[1] or name[0] for name in imp_node.names]:
                return True
        _node = _node.previous_sibling()
    return False


</t>
<t tx="ekr.20220312061835.723">def is_default_argument(
    node: nodes.NodeNG, scope: Optional[nodes.NodeNG] = None
) -&gt; bool:
    """return true if the given Name node is used in function or lambda
    default argument's value
    """
    if not scope:
        scope = node.scope()
    if isinstance(scope, (nodes.FunctionDef, nodes.Lambda)):
        for default_node in scope.args.defaults:
            for default_name_node in default_node.nodes_of_class(nodes.Name):
                if default_name_node is node:
                    return True
    return False


</t>
<t tx="ekr.20220312061835.724">def is_func_decorator(node: nodes.NodeNG) -&gt; bool:
    """return true if the name is used in function decorator"""
    parent = node.parent
    while parent is not None:
        if isinstance(parent, nodes.Decorators):
            return True
        if parent.is_statement or isinstance(
            parent,
            (
                nodes.Lambda,
                nodes.ComprehensionScope,
                nodes.ListComp,
            ),
        ):
            break
        parent = parent.parent
    return False


</t>
<t tx="ekr.20220312061835.725">def is_ancestor_name(frame: nodes.ClassDef, node: nodes.NodeNG) -&gt; bool:
    """return True if `frame` is an astroid.Class node with `node` in the
    subtree of its bases attribute
    """
    if not isinstance(frame, nodes.ClassDef):
        return False
    for base in frame.bases:
        if node in base.nodes_of_class(nodes.Name):
            return True
    return False


</t>
<t tx="ekr.20220312061835.726">def is_being_called(node: nodes.NodeNG) -&gt; bool:
    """return True if node is the function being called in a Call node"""
    return isinstance(node.parent, nodes.Call) and node.parent.func is node


</t>
<t tx="ekr.20220312061835.727">def assign_parent(node: nodes.NodeNG) -&gt; nodes.NodeNG:
    """return the higher parent which is not an AssignName, Tuple or List node"""
    while node and isinstance(node, (nodes.AssignName, nodes.Tuple, nodes.List)):
        node = node.parent
    return node


</t>
<t tx="ekr.20220312061835.728">def overrides_a_method(class_node: nodes.ClassDef, name: str) -&gt; bool:
    """return True if &lt;name&gt; is a method overridden from an ancestor"""
    for ancestor in class_node.ancestors():
        if name in ancestor and isinstance(ancestor[name], nodes.FunctionDef):
            return True
    return False


</t>
<t tx="ekr.20220312061835.729">def check_messages(*messages: str) -&gt; Callable:
    """decorator to store messages that are handled by a checker method"""

    @others
    return store_messages


</t>
<t tx="ekr.20220312061835.73">def in_loop(node):
    """return True if the node is inside a kind of for loop"""
    parent = node.parent
    while parent is not None:
        if isinstance(
            parent,
            (
                nodes.For,
                nodes.ListComp,
                nodes.SetComp,
                nodes.DictComp,
                nodes.GeneratorExp,
            ),
        ):
            return True
        parent = parent.parent
    return False


</t>
<t tx="ekr.20220312061835.730">def store_messages(func):
    func.checks_msgs = messages
    return func

</t>
<t tx="ekr.20220312061835.731">class IncompleteFormatString(Exception):
    """A format string ended in the middle of a format specifier."""


</t>
<t tx="ekr.20220312061835.732">class UnsupportedFormatCharacter(Exception):
    """A format character in a format string is not one of the supported
    format characters."""

    def __init__(self, index):
        Exception.__init__(self, index)
        self.index = index


</t>
<t tx="ekr.20220312061835.733">def parse_format_string(
    format_string: str,
) -&gt; Tuple[Set[str], int, Dict[str, str], List[str]]:
    """Parses a format string, returning a tuple of (keys, num_args), where keys
    is the set of mapping keys in the format string, and num_args is the number
    of arguments required by the format string.  Raises
    IncompleteFormatString or UnsupportedFormatCharacter if a
    parse error occurs."""
    keys = set()
    key_types = {}
    pos_types = []
    num_args = 0

    @others
    i = 0
    while i &lt; len(format_string):
        char = format_string[i]
        if char == "%":
            i, char = next_char(i)
            # Parse the mapping key (optional).
            key = None
            if char == "(":
                depth = 1
                i, char = next_char(i)
                key_start = i
                while depth != 0:
                    if char == "(":
                        depth += 1
                    elif char == ")":
                        depth -= 1
                    i, char = next_char(i)
                key_end = i - 1
                key = format_string[key_start:key_end]

            # Parse the conversion flags (optional).
            while char in "#0- +":
                i, char = next_char(i)
            # Parse the minimum field width (optional).
            if char == "*":
                num_args += 1
                i, char = next_char(i)
            else:
                while char in string.digits:
                    i, char = next_char(i)
            # Parse the precision (optional).
            if char == ".":
                i, char = next_char(i)
                if char == "*":
                    num_args += 1
                    i, char = next_char(i)
                else:
                    while char in string.digits:
                        i, char = next_char(i)
            # Parse the length modifier (optional).
            if char in "hlL":
                i, char = next_char(i)
            # Parse the conversion type (mandatory).
            flags = "diouxXeEfFgGcrs%a"
            if char not in flags:
                raise UnsupportedFormatCharacter(i)
            if key:
                keys.add(key)
                key_types[key] = char
            elif char != "%":
                num_args += 1
                pos_types.append(char)
        i += 1
    return keys, num_args, key_types, pos_types


</t>
<t tx="ekr.20220312061835.734">def next_char(i):
    i += 1
    if i == len(format_string):
        raise IncompleteFormatString
    return (i, format_string[i])

</t>
<t tx="ekr.20220312061835.735">def split_format_field_names(format_string) -&gt; Tuple[str, Iterable[Tuple[bool, str]]]:
    try:
        return _string.formatter_field_name_split(format_string)
    except ValueError as e:
        raise IncompleteFormatString() from e


</t>
<t tx="ekr.20220312061835.736">def collect_string_fields(format_string) -&gt; Iterable[Optional[str]]:
    """Given a format string, return an iterator
    of all the valid format fields. It handles nested fields
    as well.
    """
    formatter = string.Formatter()
    try:
        parseiterator = formatter.parse(format_string)
        for result in parseiterator:
            if all(item is None for item in result[1:]):
                # not a replacement format
                continue
            name = result[1]
            nested = result[2]
            yield name
            if nested:
                yield from collect_string_fields(nested)
    except ValueError as exc:
        # Probably the format string is invalid.
        if exc.args[0].startswith("cannot switch from manual"):
            # On Jython, parsing a string with both manual
            # and automatic positions will fail with a ValueError,
            # while on CPython it will simply return the fields,
            # the validation being done in the interpreter (?).
            # We're just returning two mixed fields in order
            # to trigger the format-combined-specification check.
            yield ""
            yield "1"
            return
        raise IncompleteFormatString(format_string) from exc


</t>
<t tx="ekr.20220312061835.737">def parse_format_method_string(
    format_string: str,
) -&gt; Tuple[List[Tuple[str, List[Tuple[bool, str]]]], int, int]:
    """
    Parses a PEP 3101 format string, returning a tuple of
    (keyword_arguments, implicit_pos_args_cnt, explicit_pos_args),
    where keyword_arguments is the set of mapping keys in the format string, implicit_pos_args_cnt
    is the number of arguments required by the format string and
    explicit_pos_args is the number of arguments passed with the position.
    """
    keyword_arguments = []
    implicit_pos_args_cnt = 0
    explicit_pos_args = set()
    for name in collect_string_fields(format_string):
        if name and str(name).isdigit():
            explicit_pos_args.add(str(name))
        elif name:
            keyname, fielditerator = split_format_field_names(name)
            if isinstance(keyname, numbers.Number):
                explicit_pos_args.add(str(keyname))
            try:
                keyword_arguments.append((keyname, list(fielditerator)))
            except ValueError as e:
                raise IncompleteFormatString() from e
        else:
            implicit_pos_args_cnt += 1
    return keyword_arguments, implicit_pos_args_cnt, len(explicit_pos_args)


</t>
<t tx="ekr.20220312061835.738">def is_attr_protected(attrname: str) -&gt; bool:
    """return True if attribute name is protected (start with _ and some other
    details), False otherwise.
    """
    return (
        attrname[0] == "_"
        and attrname != "_"
        and not (attrname.startswith("__") and attrname.endswith("__"))
    )


</t>
<t tx="ekr.20220312061835.739">def node_frame_class(node: nodes.NodeNG) -&gt; Optional[nodes.ClassDef]:
    """Return the class that is wrapping the given node

    The function returns a class for a method node (or a staticmethod or a
    classmethod), otherwise it returns `None`.
    """
    klass = node.frame()
    nodes_to_check = (
        nodes.NodeNG,
        astroid.UnboundMethod,
        astroid.BaseInstance,
    )
    while (
        klass
        and isinstance(klass, nodes_to_check)
        and not isinstance(klass, nodes.ClassDef)
    ):
        if klass.parent is None:
            return None

        klass = klass.parent.frame()

    return klass


</t>
<t tx="ekr.20220312061835.74">def in_nested_list(nested_list, obj):
    """return true if the object is an element of &lt;nested_list&gt; or of a nested
    list
    """
    for elmt in nested_list:
        if isinstance(elmt, (list, tuple)):
            if in_nested_list(elmt, obj):
                return True
        elif elmt == obj:
            return True
    return False


</t>
<t tx="ekr.20220312061835.740">def is_attr_private(attrname: str) -&gt; Optional[Match[str]]:
    """Check that attribute name is private (at least two leading underscores,
    at most one trailing underscore)
    """
    regex = re.compile("^_{2,}.*[^_]+_?$")
    return regex.match(attrname)


</t>
<t tx="ekr.20220312061835.741">def get_argument_from_call(
    call_node: nodes.Call, position: int = None, keyword: str = None
) -&gt; nodes.Name:
    """Returns the specified argument from a function call.

    :param nodes.Call call_node: Node representing a function call to check.
    :param int position: position of the argument.
    :param str keyword: the keyword of the argument.

    :returns: The node representing the argument, None if the argument is not found.
    :rtype: nodes.Name
    :raises ValueError: if both position and keyword are None.
    :raises NoSuchArgumentError: if no argument at the provided position or with
    the provided keyword.
    """
    if position is None and keyword is None:
        raise ValueError("Must specify at least one of: position or keyword.")
    if position is not None:
        try:
            return call_node.args[position]
        except IndexError:
            pass
    if keyword and call_node.keywords:
        for arg in call_node.keywords:
            if arg.arg == keyword:
                return arg.value

    raise NoSuchArgumentError


</t>
<t tx="ekr.20220312061835.742">def inherit_from_std_ex(node: nodes.NodeNG) -&gt; bool:
    """
    Return true if the given class node is subclass of
    exceptions.Exception.
    """
    ancestors = node.ancestors() if hasattr(node, "ancestors") else []
    for ancestor in itertools.chain([node], ancestors):
        if (
            ancestor.name in ("Exception", "BaseException")
            and ancestor.root().name == EXCEPTIONS_MODULE
        ):
            return True
    return False


</t>
<t tx="ekr.20220312061835.743">def error_of_type(handler: nodes.ExceptHandler, error_type) -&gt; bool:
    """
    Check if the given exception handler catches
    the given error_type.

    The *handler* parameter is a node, representing an ExceptHandler node.
    The *error_type* can be an exception, such as AttributeError,
    the name of an exception, or it can be a tuple of errors.
    The function will return True if the handler catches any of the
    given errors.
    """

    @others
    if not isinstance(error_type, tuple):
        error_type = (error_type,)
    expected_errors = {stringify_error(error) for error in error_type}
    if not handler.type:
        return False
    return handler.catch(expected_errors)


</t>
<t tx="ekr.20220312061835.744">def stringify_error(error):
    if not isinstance(error, str):
        return error.__name__
    return error

</t>
<t tx="ekr.20220312061835.745">def decorated_with_property(node: nodes.FunctionDef) -&gt; bool:
    """Detect if the given function node is decorated with a property."""
    if not node.decorators:
        return False
    for decorator in node.decorators.nodes:
        try:
            if _is_property_decorator(decorator):
                return True
        except astroid.InferenceError:
            pass
    return False


</t>
<t tx="ekr.20220312061835.746">def _is_property_kind(node, *kinds):
    if not isinstance(node, (astroid.UnboundMethod, nodes.FunctionDef)):
        return False
    if node.decorators:
        for decorator in node.decorators.nodes:
            if isinstance(decorator, nodes.Attribute) and decorator.attrname in kinds:
                return True
    return False


</t>
<t tx="ekr.20220312061835.747">def is_property_setter(node: nodes.FunctionDef) -&gt; bool:
    """Check if the given node is a property setter"""
    return _is_property_kind(node, "setter")


</t>
<t tx="ekr.20220312061835.748">def is_property_deleter(node: nodes.FunctionDef) -&gt; bool:
    """Check if the given node is a property deleter"""
    return _is_property_kind(node, "deleter")


</t>
<t tx="ekr.20220312061835.749">def is_property_setter_or_deleter(node: nodes.FunctionDef) -&gt; bool:
    """Check if the given node is either a property setter or a deleter"""
    return _is_property_kind(node, "setter", "deleter")


</t>
<t tx="ekr.20220312061835.75">def _get_break_loop_node(break_node):
    """
    Returns the loop node that holds the break node in arguments.

    Args:
        break_node (astroid.Break): the break node of interest.

    Returns:
        astroid.For or astroid.While: the loop node holding the break node.
    """
    loop_nodes = (nodes.For, nodes.While)
    parent = break_node.parent
    while not isinstance(parent, loop_nodes) or break_node in getattr(
        parent, "orelse", []
    ):
        break_node = parent
        parent = parent.parent
        if parent is None:
            break
    return parent


</t>
<t tx="ekr.20220312061835.750">def _is_property_decorator(decorator: nodes.Name) -&gt; bool:
    for inferred in decorator.infer():
        if isinstance(inferred, nodes.ClassDef):
            if inferred.qname() in ("builtins.property", "functools.cached_property"):
                return True
            for ancestor in inferred.ancestors():
                if ancestor.name == "property" and ancestor.root().name == "builtins":
                    return True
        elif isinstance(inferred, nodes.FunctionDef):
            # If decorator is function, check if it has exactly one return
            # and the return is itself a function decorated with property
            returns: List[nodes.Return] = list(
                inferred._get_return_nodes_skip_functions()
            )
            if len(returns) == 1 and isinstance(
                returns[0].value, (nodes.Name, nodes.Attribute)
            ):
                inferred = safe_infer(returns[0].value)
                if (
                    inferred
                    and isinstance(inferred, astroid.objects.Property)
                    and isinstance(inferred.function, nodes.FunctionDef)
                ):
                    return decorated_with_property(inferred.function)
    return False


</t>
<t tx="ekr.20220312061835.751">def decorated_with(
    func: Union[nodes.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod],
    qnames: Iterable[str],
) -&gt; bool:
    """Determine if the `func` node has a decorator with the qualified name `qname`."""
    decorators = func.decorators.nodes if func.decorators else []
    for decorator_node in decorators:
        if isinstance(decorator_node, nodes.Call):
            # We only want to infer the function name
            decorator_node = decorator_node.func
        try:
            if any(
                i.name in qnames or i.qname() in qnames
                for i in decorator_node.infer()
                if i is not None and i != astroid.Uninferable
            ):
                return True
        except astroid.InferenceError:
            continue
    return False


</t>
<t tx="ekr.20220312061835.752">@lru_cache(maxsize=1024)
def unimplemented_abstract_methods(
    node: nodes.ClassDef, is_abstract_cb: nodes.FunctionDef = None
) -&gt; Dict[str, nodes.NodeNG]:
    """
    Get the unimplemented abstract methods for the given *node*.

    A method can be considered abstract if the callback *is_abstract_cb*
    returns a ``True`` value. The check defaults to verifying that
    a method is decorated with abstract methods.
    The function will work only for new-style classes. For old-style
    classes, it will simply return an empty dictionary.
    For the rest of them, it will return a dictionary of abstract method
    names and their inferred objects.
    """
    if is_abstract_cb is None:
        is_abstract_cb = partial(decorated_with, qnames=ABC_METHODS)
    visited: Dict[str, nodes.NodeNG] = {}
    try:
        mro = reversed(node.mro())
    except NotImplementedError:
        # Old style class, it will not have a mro.
        return {}
    except astroid.ResolveError:
        # Probably inconsistent hierarchy, don'try
        # to figure this out here.
        return {}
    for ancestor in mro:
        for obj in ancestor.values():
            inferred = obj
            if isinstance(obj, nodes.AssignName):
                inferred = safe_infer(obj)
                if not inferred:
                    # Might be an abstract function,
                    # but since we don't have enough information
                    # in order to take this decision, we're taking
                    # the *safe* decision instead.
                    if obj.name in visited:
                        del visited[obj.name]
                    continue
                if not isinstance(inferred, nodes.FunctionDef):
                    if obj.name in visited:
                        del visited[obj.name]
            if isinstance(inferred, nodes.FunctionDef):
                # It's critical to use the original name,
                # since after inferring, an object can be something
                # else than expected, as in the case of the
                # following assignment.
                #
                # class A:
                #     def keys(self): pass
                #     __iter__ = keys
                abstract = is_abstract_cb(inferred)
                if abstract:
                    visited[obj.name] = inferred
                elif not abstract and obj.name in visited:
                    del visited[obj.name]
    return visited


</t>
<t tx="ekr.20220312061835.753">def find_try_except_wrapper_node(
    node: nodes.NodeNG,
) -&gt; Optional[Union[nodes.ExceptHandler, nodes.TryExcept]]:
    """Return the ExceptHandler or the TryExcept node in which the node is."""
    current = node
    ignores = (nodes.ExceptHandler, nodes.TryExcept)
    while current and not isinstance(current.parent, ignores):
        current = current.parent

    if current and isinstance(current.parent, ignores):
        return current.parent
    return None


</t>
<t tx="ekr.20220312061835.754">def find_except_wrapper_node_in_scope(
    node: nodes.NodeNG,
) -&gt; Optional[Union[nodes.ExceptHandler, nodes.TryExcept]]:
    """Return the ExceptHandler in which the node is, without going out of scope."""
    current = node
    while current.parent is not None:
        current = current.parent
        if isinstance(current, astroid.scoped_nodes.LocalsDictNodeNG):
            # If we're inside a function/class definition, we don't want to keep checking
            # higher ancestors for `except` clauses, because if these exist, it means our
            # function/class was defined in an `except` clause, rather than the current code
            # actually running in an `except` clause.
            return None
        if isinstance(current, nodes.ExceptHandler):
            return current
    return None


</t>
<t tx="ekr.20220312061835.755">def is_from_fallback_block(node: nodes.NodeNG) -&gt; bool:
    """Check if the given node is from a fallback import block."""
    context = find_try_except_wrapper_node(node)
    if not context:
        return False

    if isinstance(context, nodes.ExceptHandler):
        other_body = context.parent.body
        handlers = context.parent.handlers
    else:
        other_body = itertools.chain.from_iterable(
            handler.body for handler in context.handlers
        )
        handlers = context.handlers

    has_fallback_imports = any(
        isinstance(import_node, (nodes.ImportFrom, nodes.Import))
        for import_node in other_body
    )
    ignores_import_error = _except_handlers_ignores_exception(handlers, ImportError)
    return ignores_import_error or has_fallback_imports


</t>
<t tx="ekr.20220312061835.756">def _except_handlers_ignores_exception(
    handlers: nodes.ExceptHandler, exception
) -&gt; bool:
    func = partial(error_of_type, error_type=(exception,))
    return any(func(handler) for handler in handlers)


</t>
<t tx="ekr.20220312061835.757">def get_exception_handlers(
    node: nodes.NodeNG, exception=Exception
) -&gt; Optional[List[nodes.ExceptHandler]]:
    """Return the collections of handlers handling the exception in arguments.

    Args:
        node (nodes.NodeNG): A node that is potentially wrapped in a try except.
        exception (builtin.Exception or str): exception or name of the exception.

    Returns:
        list: the collection of handlers that are handling the exception or None.

    """
    context = find_try_except_wrapper_node(node)
    if isinstance(context, nodes.TryExcept):
        return [
            handler for handler in context.handlers if error_of_type(handler, exception)
        ]
    return []


</t>
<t tx="ekr.20220312061835.758">def is_node_inside_try_except(node: nodes.Raise) -&gt; bool:
    """Check if the node is directly under a Try/Except statement.
    (but not under an ExceptHandler!)

    Args:
        node (nodes.Raise): the node raising the exception.

    Returns:
        bool: True if the node is inside a try/except statement, False otherwise.
    """
    context = find_try_except_wrapper_node(node)
    return isinstance(context, nodes.TryExcept)


</t>
<t tx="ekr.20220312061835.759">def node_ignores_exception(node: nodes.NodeNG, exception=Exception) -&gt; bool:
    """Check if the node is in a TryExcept which handles the given exception.

    If the exception is not given, the function is going to look for bare
    excepts.
    """
    managing_handlers = get_exception_handlers(node, exception)
    if not managing_handlers:
        return False
    return any(managing_handlers)


</t>
<t tx="ekr.20220312061835.76">def _loop_exits_early(loop):
    """
    Returns true if a loop may ends up in a break statement.

    Args:
        loop (astroid.For, astroid.While): the loop node inspected.

    Returns:
        bool: True if the loop may ends up in a break statement, False otherwise.
    """
    loop_nodes = (nodes.For, nodes.While)
    definition_nodes = (nodes.FunctionDef, nodes.ClassDef)
    inner_loop_nodes = [
        _node
        for _node in loop.nodes_of_class(loop_nodes, skip_klass=definition_nodes)
        if _node != loop
    ]
    return any(
        _node
        for _node in loop.nodes_of_class(nodes.Break, skip_klass=definition_nodes)
        if _get_break_loop_node(_node) not in inner_loop_nodes
    )


</t>
<t tx="ekr.20220312061835.760">def class_is_abstract(node: nodes.ClassDef) -&gt; bool:
    """return true if the given class node should be considered as an abstract
    class
    """
    # Only check for explicit metaclass=ABCMeta on this specific class
    meta = node.declared_metaclass()
    if meta is not None:
        if meta.name == "ABCMeta" and meta.root().name in ABC_MODULES:
            return True

    for ancestor in node.ancestors():
        if ancestor.name == "ABC" and ancestor.root().name in ABC_MODULES:
            # abc.ABC inheritance
            return True

    for method in node.methods():
        if method.parent.frame() is node:
            if method.is_abstract(pass_is_abstract=False):
                return True
    return False


</t>
<t tx="ekr.20220312061835.761">def _supports_protocol_method(value: nodes.NodeNG, attr: str) -&gt; bool:
    try:
        attributes = value.getattr(attr)
    except astroid.NotFoundError:
        return False

    first = attributes[0]
    if isinstance(first, nodes.AssignName):
        if isinstance(first.parent.value, nodes.Const):
            return False
    return True


</t>
<t tx="ekr.20220312061835.762">def is_comprehension(node: nodes.NodeNG) -&gt; bool:
    comprehensions = (
        nodes.ListComp,
        nodes.SetComp,
        nodes.DictComp,
        nodes.GeneratorExp,
    )
    return isinstance(node, comprehensions)


</t>
<t tx="ekr.20220312061835.763">def _supports_mapping_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(
        value, GETITEM_METHOD
    ) and _supports_protocol_method(value, KEYS_METHOD)


</t>
<t tx="ekr.20220312061835.764">def _supports_membership_test_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, CONTAINS_METHOD)


</t>
<t tx="ekr.20220312061835.765">def _supports_iteration_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, ITER_METHOD) or _supports_protocol_method(
        value, GETITEM_METHOD
    )


</t>
<t tx="ekr.20220312061835.766">def _supports_async_iteration_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, AITER_METHOD)


</t>
<t tx="ekr.20220312061835.767">def _supports_getitem_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, GETITEM_METHOD)


</t>
<t tx="ekr.20220312061835.768">def _supports_setitem_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, SETITEM_METHOD)


</t>
<t tx="ekr.20220312061835.769">def _supports_delitem_protocol(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol_method(value, DELITEM_METHOD)


</t>
<t tx="ekr.20220312061835.77">def _is_multi_naming_match(match, node_type, confidence):
    return (
        match is not None
        and match.lastgroup is not None
        and match.lastgroup not in EXEMPT_NAME_CATEGORIES
        and (node_type != "method" or confidence != interfaces.INFERENCE_FAILURE)
    )


</t>
<t tx="ekr.20220312061835.770">def _is_abstract_class_name(name: str) -&gt; bool:
    lname = name.lower()
    is_mixin = lname.endswith("mixin")
    is_abstract = lname.startswith("abstract")
    is_base = lname.startswith("base") or lname.endswith("base")
    return is_mixin or is_abstract or is_base


</t>
<t tx="ekr.20220312061835.771">def is_inside_abstract_class(node: nodes.NodeNG) -&gt; bool:
    while node is not None:
        if isinstance(node, nodes.ClassDef):
            if class_is_abstract(node):
                return True
            name = getattr(node, "name", None)
            if name is not None and _is_abstract_class_name(name):
                return True
        node = node.parent
    return False


</t>
<t tx="ekr.20220312061835.772">def _supports_protocol(
    value: nodes.NodeNG, protocol_callback: nodes.FunctionDef
) -&gt; bool:
    if isinstance(value, nodes.ClassDef):
        if not has_known_bases(value):
            return True
        # classobj can only be iterable if it has an iterable metaclass
        meta = value.metaclass()
        if meta is not None:
            if protocol_callback(meta):
                return True
    if isinstance(value, astroid.BaseInstance):
        if not has_known_bases(value):
            return True
        if value.has_dynamic_getattr():
            return True
        if protocol_callback(value):
            return True

    if (
        isinstance(value, astroid.bases.Proxy)
        and isinstance(value._proxied, astroid.BaseInstance)
        and has_known_bases(value._proxied)
    ):
        value = value._proxied
        return protocol_callback(value)

    return False


</t>
<t tx="ekr.20220312061835.773">def is_iterable(value: nodes.NodeNG, check_async: bool = False) -&gt; bool:
    if check_async:
        protocol_check = _supports_async_iteration_protocol
    else:
        protocol_check = _supports_iteration_protocol
    return _supports_protocol(value, protocol_check)


</t>
<t tx="ekr.20220312061835.774">def is_mapping(value: nodes.NodeNG) -&gt; bool:
    return _supports_protocol(value, _supports_mapping_protocol)


</t>
<t tx="ekr.20220312061835.775">def supports_membership_test(value: nodes.NodeNG) -&gt; bool:
    supported = _supports_protocol(value, _supports_membership_test_protocol)
    return supported or is_iterable(value)


</t>
<t tx="ekr.20220312061835.776">def supports_getitem(value: nodes.NodeNG, node: nodes.NodeNG) -&gt; bool:
    if isinstance(value, nodes.ClassDef):
        if _supports_protocol_method(value, CLASS_GETITEM_METHOD):
            return True
        if is_class_subscriptable_pep585_with_postponed_evaluation_enabled(value, node):
            return True
    return _supports_protocol(value, _supports_getitem_protocol)


</t>
<t tx="ekr.20220312061835.777">def supports_setitem(value: nodes.NodeNG, _: nodes.NodeNG) -&gt; bool:
    return _supports_protocol(value, _supports_setitem_protocol)


</t>
<t tx="ekr.20220312061835.778">def supports_delitem(value: nodes.NodeNG, _: nodes.NodeNG) -&gt; bool:
    return _supports_protocol(value, _supports_delitem_protocol)


</t>
<t tx="ekr.20220312061835.779">def _get_python_type_of_node(node):
    pytype = getattr(node, "pytype", None)
    if callable(pytype):
        return pytype()
    return None


</t>
<t tx="ekr.20220312061835.78">BUILTIN_PROPERTY = "builtins.property"


</t>
<t tx="ekr.20220312061835.780">@lru_cache(maxsize=1024)
def safe_infer(node: nodes.NodeNG, context=None) -&gt; Optional[nodes.NodeNG]:
    """Return the inferred value for the given node.

    Return None if inference failed or if there is some ambiguity (more than
    one node has been inferred of different types).
    """
    inferred_types = set()
    try:
        infer_gen = node.infer(context=context)
        value = next(infer_gen)
    except astroid.InferenceError:
        return None

    if value is not astroid.Uninferable:
        inferred_types.add(_get_python_type_of_node(value))

    try:
        for inferred in infer_gen:
            inferred_type = _get_python_type_of_node(inferred)
            if inferred_type not in inferred_types:
                return None  # If there is ambiguity on the inferred node.
    except astroid.InferenceError:
        return None  # There is some kind of ambiguity
    except StopIteration:
        return value
    return value if len(inferred_types) &lt;= 1 else None


</t>
<t tx="ekr.20220312061835.781">@lru_cache(maxsize=512)
def infer_all(
    node: nodes.NodeNG, context: InferenceContext = None
) -&gt; List[nodes.NodeNG]:
    try:
        return list(node.infer(context=context))
    except astroid.InferenceError:
        return []


</t>
<t tx="ekr.20220312061835.782">def has_known_bases(klass: nodes.ClassDef, context=None) -&gt; bool:
    """Return true if all base classes of a class could be inferred."""
    try:
        return klass._all_bases_known
    except AttributeError:
        pass
    for base in klass.bases:
        result = safe_infer(base, context=context)
        if (
            not isinstance(result, nodes.ClassDef)
            or result is klass
            or not has_known_bases(result, context=context)
        ):
            klass._all_bases_known = False
            return False
    klass._all_bases_known = True
    return True


</t>
<t tx="ekr.20220312061835.783">def is_none(node: nodes.NodeNG) -&gt; bool:
    return (
        node is None
        or (isinstance(node, nodes.Const) and node.value is None)
        or (isinstance(node, nodes.Name) and node.name == "None")
    )


</t>
<t tx="ekr.20220312061835.784">def node_type(node: nodes.NodeNG) -&gt; Optional[nodes.NodeNG]:
    """Return the inferred type for `node`

    If there is more than one possible type, or if inferred type is Uninferable or None,
    return None
    """
    # check there is only one possible type for the assign node. Else we
    # don't handle it for now
    types: Set[nodes.NodeNG] = set()
    try:
        for var_type in node.infer():
            if var_type == astroid.Uninferable or is_none(var_type):
                continue
            types.add(var_type)
            if len(types) &gt; 1:
                return None
    except astroid.InferenceError:
        return None
    return types.pop() if types else None


</t>
<t tx="ekr.20220312061835.785">def is_registered_in_singledispatch_function(node: nodes.FunctionDef) -&gt; bool:
    """Check if the given function node is a singledispatch function."""

    singledispatch_qnames = (
        "functools.singledispatch",
        "singledispatch.singledispatch",
    )

    if not isinstance(node, nodes.FunctionDef):
        return False

    decorators = node.decorators.nodes if node.decorators else []
    for decorator in decorators:
        # func.register are function calls
        if not isinstance(decorator, nodes.Call):
            continue

        func = decorator.func
        if not isinstance(func, nodes.Attribute) or func.attrname != "register":
            continue

        try:
            func_def = next(func.expr.infer())
        except astroid.InferenceError:
            continue

        if isinstance(func_def, nodes.FunctionDef):
            # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here
            return decorated_with(func_def, singledispatch_qnames)

    return False


</t>
<t tx="ekr.20220312061835.786">def get_node_last_lineno(node: nodes.NodeNG) -&gt; int:
    """
    Get the last lineno of the given node. For a simple statement this will just be node.lineno,
    but for a node that has child statements (e.g. a method) this will be the lineno of the last
    child statement recursively.
    """
    # 'finalbody' is always the last clause in a try statement, if present
    if getattr(node, "finalbody", False):
        return get_node_last_lineno(node.finalbody[-1])
    # For if, while, and for statements 'orelse' is always the last clause.
    # For try statements 'orelse' is the last in the absence of a 'finalbody'
    if getattr(node, "orelse", False):
        return get_node_last_lineno(node.orelse[-1])
    # try statements have the 'handlers' last if there is no 'orelse' or 'finalbody'
    if getattr(node, "handlers", False):
        return get_node_last_lineno(node.handlers[-1])
    # All compound statements have a 'body'
    if getattr(node, "body", False):
        return get_node_last_lineno(node.body[-1])
    # Not a compound statement
    return node.lineno


</t>
<t tx="ekr.20220312061835.787">def is_postponed_evaluation_enabled(node: nodes.NodeNG) -&gt; bool:
    """Check if the postponed evaluation of annotations is enabled"""
    module = node.root()
    return "annotations" in module.future_imports


</t>
<t tx="ekr.20220312061835.788">def is_class_subscriptable_pep585_with_postponed_evaluation_enabled(
    value: nodes.ClassDef, node: nodes.NodeNG
) -&gt; bool:
    """Check if class is subscriptable with PEP 585 and
    postponed evaluation enabled.
    """
    return (
        is_postponed_evaluation_enabled(node)
        and value.qname() in SUBSCRIPTABLE_CLASSES_PEP585
        and is_node_in_type_annotation_context(node)
    )


</t>
<t tx="ekr.20220312061835.789">def is_node_in_type_annotation_context(node: nodes.NodeNG) -&gt; bool:
    """Check if node is in type annotation context.

    Check for 'AnnAssign', function 'Arguments',
    or part of function return type anntation.
    """
    # pylint: disable=too-many-boolean-expressions
    current_node, parent_node = node, node.parent
    while True:
        if (
            isinstance(parent_node, nodes.AnnAssign)
            and parent_node.annotation == current_node
            or isinstance(parent_node, nodes.Arguments)
            and current_node
            in (
                *parent_node.annotations,
                *parent_node.posonlyargs_annotations,
                *parent_node.kwonlyargs_annotations,
                parent_node.varargannotation,
                parent_node.kwargannotation,
            )
            or isinstance(parent_node, nodes.FunctionDef)
            and parent_node.returns == current_node
        ):
            return True
        current_node, parent_node = parent_node, parent_node.parent
        if isinstance(parent_node, nodes.Module):
            return False


</t>
<t tx="ekr.20220312061835.79">def _get_properties(config):
    """Returns a tuple of property classes and names.

    Property classes are fully qualified, such as 'abc.abstractproperty' and
    property names are the actual names, such as 'abstract_property'.
    """
    property_classes = {BUILTIN_PROPERTY}
    property_names = set()  # Not returning 'property', it has its own check.
    if config is not None:
        property_classes.update(config.property_classes)
        property_names.update(
            prop.rsplit(".", 1)[-1] for prop in config.property_classes
        )
    return property_classes, property_names


</t>
<t tx="ekr.20220312061835.790">def is_subclass_of(child: nodes.ClassDef, parent: nodes.ClassDef) -&gt; bool:
    """
    Check if first node is a subclass of second node.
    :param child: Node to check for subclass.
    :param parent: Node to check for superclass.
    :returns: True if child is derived from parent. False otherwise.
    """
    if not all(isinstance(node, nodes.ClassDef) for node in (child, parent)):
        return False

    for ancestor in child.ancestors():
        try:
            if astroid.helpers.is_subtype(ancestor, parent):
                return True
        except astroid.exceptions._NonDeducibleTypeHierarchy:
            continue
    return False


</t>
<t tx="ekr.20220312061835.791">@lru_cache(maxsize=1024)
def is_overload_stub(node: nodes.NodeNG) -&gt; bool:
    """Check if a node if is a function stub decorated with typing.overload.

    :param node: Node to check.
    :returns: True if node is an overload function stub. False otherwise.
    """
    decorators = getattr(node, "decorators", None)
    return bool(decorators and decorated_with(node, ["typing.overload", "overload"]))


</t>
<t tx="ekr.20220312061835.792">def is_protocol_class(cls: nodes.NodeNG) -&gt; bool:
    """Check if the given node represents a protocol class

    :param cls: The node to check
    :returns: True if the node is a typing protocol class, false otherwise.
    """
    if not isinstance(cls, nodes.ClassDef):
        return False

    # Use .ancestors() since not all protocol classes can have
    # their mro deduced.
    return any(parent.qname() in TYPING_PROTOCOLS for parent in cls.ancestors())


</t>
<t tx="ekr.20220312061835.793">def is_call_of_name(node: nodes.NodeNG, name: str) -&gt; bool:
    """Checks if node is a function call with the given name"""
    return (
        isinstance(node, nodes.Call)
        and isinstance(node.func, nodes.Name)
        and node.func.name == name
    )


</t>
<t tx="ekr.20220312061835.794">def is_test_condition(
    node: nodes.NodeNG,
    parent: Optional[nodes.NodeNG] = None,
) -&gt; bool:
    """Returns true if the given node is being tested for truthiness"""
    parent = parent or node.parent
    if isinstance(parent, (nodes.While, nodes.If, nodes.IfExp, nodes.Assert)):
        return node is parent.test or parent.test.parent_of(node)
    if isinstance(parent, nodes.Comprehension):
        return node in parent.ifs
    return is_call_of_name(parent, "bool") and parent.parent_of(node)


</t>
<t tx="ekr.20220312061835.795">def is_classdef_type(node: nodes.ClassDef) -&gt; bool:
    """Test if ClassDef node is Type."""
    if node.name == "type":
        return True
    for base in node.bases:
        if isinstance(base, nodes.Name) and base.name == "type":
            return True
    return False


</t>
<t tx="ekr.20220312061835.796">def is_attribute_typed_annotation(
    node: Union[nodes.ClassDef, astroid.Instance], attr_name: str
) -&gt; bool:
    """Test if attribute is typed annotation in current node
    or any base nodes.
    """
    attribute = node.locals.get(attr_name, [None])[0]
    if (
        attribute
        and isinstance(attribute, nodes.AssignName)
        and isinstance(attribute.parent, nodes.AnnAssign)
    ):
        return True
    for base in node.bases:
        inferred = safe_infer(base)
        if (
            inferred
            and isinstance(inferred, nodes.ClassDef)
            and is_attribute_typed_annotation(inferred, attr_name)
        ):
            return True
    return False


</t>
<t tx="ekr.20220312061835.797">def is_assign_name_annotated_with(node: nodes.AssignName, typing_name: str) -&gt; bool:
    """Test if AssignName node has `typing_name` annotation.

    Especially useful to check for `typing._SpecialForm` instances
    like: `Union`, `Optional`, `Literal`, `ClassVar`, `Final`.
    """
    if not isinstance(node.parent, nodes.AnnAssign):
        return False
    annotation = node.parent.annotation
    if isinstance(annotation, nodes.Subscript):
        annotation = annotation.value
    if (
        isinstance(annotation, nodes.Name)
        and annotation.name == typing_name
        or isinstance(annotation, nodes.Attribute)
        and annotation.attrname == typing_name
    ):
        return True
    return False


</t>
<t tx="ekr.20220312061835.798">def get_iterating_dictionary_name(
    node: Union[nodes.For, nodes.Comprehension]
) -&gt; Optional[str]:
    """Get the name of the dictionary which keys are being iterated over on
    a ``nodes.For`` or ``nodes.Comprehension`` node.

    If the iterating object is not either the keys method of a dictionary
    or a dictionary itself, this returns None.
    """
    # Is it a proper keys call?
    if (
        isinstance(node.iter, nodes.Call)
        and isinstance(node.iter.func, nodes.Attribute)
        and node.iter.func.attrname == "keys"
    ):
        inferred = safe_infer(node.iter.func)
        if not isinstance(inferred, astroid.BoundMethod):
            return None
        return node.iter.as_string().rpartition(".keys")[0]

    # Is it a dictionary?
    if isinstance(node.iter, (nodes.Name, nodes.Attribute)):
        inferred = safe_infer(node.iter)
        if not isinstance(inferred, nodes.Dict):
            return None
        return node.iter.as_string()

    return None


</t>
<t tx="ekr.20220312061835.799">def get_subscript_const_value(node: nodes.Subscript) -&gt; nodes.Const:
    """
    Returns the value 'subscript.slice' of a Subscript node.

    :param node: Subscript Node to extract value from
    :returns: Const Node containing subscript value
    :raises InferredTypeError: if the subscript node cannot be inferred as a Const
    """
    inferred = safe_infer(node.slice)
    if not isinstance(inferred, nodes.Const):
        raise InferredTypeError("Subscript.slice cannot be inferred as a nodes.Const")

    return inferred


</t>
<t tx="ekr.20220312061835.8">def Run():
    if len(sys.argv) == 1:
        print(f"Usage: {sys.argv[0]} &lt;filename&gt; [options]")
        sys.exit(1)
    elif not os.path.exists(sys.argv[1]):
        print(f"{sys.argv[1]} does not exist")
        sys.exit(1)
    else:
        sys.exit(lint(sys.argv[1], sys.argv[2:]))


</t>
<t tx="ekr.20220312061835.80">def _determine_function_name_type(node: nodes.FunctionDef, config=None):
    """Determine the name type whose regex the a function's name should match.

    :param node: A function node.
    :param config: Configuration from which to pull additional property classes.
    :type config: :class:`optparse.Values`

    :returns: One of ('function', 'method', 'attr')
    :rtype: str
    """
    property_classes, property_names = _get_properties(config)
    if not node.is_method():
        return "function"

    if is_property_setter(node) or is_property_deleter(node):
        # If the function is decorated using the prop_method.{setter,getter}
        # form, treat it like an attribute as well.
        return "attr"

    decorators = node.decorators.nodes if node.decorators else []
    for decorator in decorators:
        # If the function is a property (decorated with @property
        # or @abc.abstractproperty), the name type is 'attr'.
        if isinstance(decorator, nodes.Name) or (
            isinstance(decorator, nodes.Attribute)
            and decorator.attrname in property_names
        ):
            inferred = utils.safe_infer(decorator)
            if (
                inferred
                and hasattr(inferred, "qname")
                and inferred.qname() in property_classes
            ):
                return "attr"
    return "method"


</t>
<t tx="ekr.20220312061835.800">def get_import_name(
    importnode: Union[nodes.Import, nodes.ImportFrom], modname: str
) -&gt; str:
    """Get a prepared module name from the given import node

    In the case of relative imports, this will return the
    absolute qualified module name, which might be useful
    for debugging. Otherwise, the initial module name
    is returned unchanged.

    :param importnode: node representing import statement.
    :param modname: module name from import statement.
    :returns: absolute qualified module name of the module
        used in import.
    """
    if isinstance(importnode, nodes.ImportFrom) and importnode.level:
        root = importnode.root()
        if isinstance(root, nodes.Module):
            try:
                return root.relative_to_absolute_name(modname, level=importnode.level)
            except TooManyLevelsError:
                return modname
    return modname


</t>
<t tx="ekr.20220312061835.801">def is_node_in_guarded_import_block(node: nodes.NodeNG) -&gt; bool:
    """Return True if node is part for guarded if block.
    I.e. `sys.version_info` or `typing.TYPE_CHECKING`
    """
    return isinstance(node.parent, nodes.If) and (
        node.parent.is_sys_guard() or node.parent.is_typing_guard()
    )


</t>
<t tx="ekr.20220312061835.802">def is_reassigned_after_current(node: nodes.NodeNG, varname: str) -&gt; bool:
    """Check if the given variable name is reassigned in the same scope after the current node"""
    return any(
        a.name == varname and a.lineno &gt; node.lineno
        for a in node.scope().nodes_of_class((nodes.AssignName, nodes.FunctionDef))
    )
</t>
<t tx="ekr.20220312061835.803">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2009 Mads Kiilerich &lt;mads@kiilerich.com&gt;
# Copyright (c) 2010 Daniel Harding &lt;dharding@gmail.com&gt;
# Copyright (c) 2011-2014, 2017 Google, Inc.
# Copyright (c) 2012 FELD Boris &lt;lothiraldan@gmail.com&gt;
# Copyright (c) 2013-2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Michal Nowikowski &lt;godfryd@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Ricardo Gemignani &lt;ricardo.gemignani@gmail.com&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Dmitry Pribysh &lt;dmand@yandex.ru&gt;
# Copyright (c) 2015 Radu Ciorba &lt;radu@devrandom.ro&gt;
# Copyright (c) 2015 Simu Toni &lt;simutoni@gmail.com&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016, 2018-2019 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2016, 2018 Jakub Wilk &lt;jwilk@jwilk.net&gt;
# Copyright (c) 2016-2017 Derek Gustafson &lt;degustaf@gmail.com&gt;
# Copyright (c) 2016-2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2016 Grant Welch &lt;gwelch925+github@gmail.com&gt;
# Copyright (c) 2017-2018, 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2017-2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2017 Dan Garrette &lt;dhgarrette@gmail.com&gt;
# Copyright (c) 2018-2019 Jim Robertson &lt;jrobertson98atx@gmail.com&gt;
# Copyright (c) 2018 Mike Miller &lt;mtmiller@users.noreply.github.com&gt;
# Copyright (c) 2018 Lucas Cimon &lt;lucas.cimon@gmail.com&gt;
# Copyright (c) 2018 Drew &lt;drewrisinger@users.noreply.github.com&gt;
# Copyright (c) 2018 Sushobhit &lt;31987769+sushobhit27@users.noreply.github.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.guinta@protonmail.com&gt;
# Copyright (c) 2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018 Mike Frysinger &lt;vapier@gmail.com&gt;
# Copyright (c) 2018 Marianna Polatoglou &lt;mpolatoglou@bloomberg.net&gt;
# Copyright (c) 2018 mar-chi-pan &lt;mar.polatoglou@gmail.com&gt;
# Copyright (c) 2019-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2019 Nick Drozd &lt;nicholasdrozd@gmail.com&gt;
# Copyright (c) 2019 Djailla &lt;bastien.vallet@gmail.com&gt;
# Copyright (c) 2019 Hugo van Kemenade &lt;hugovk@users.noreply.github.com&gt;
# Copyright (c) 2020 Andrew Simmons &lt;anjsimmo@gmail.com&gt;
# Copyright (c) 2020 Andrew Simmons &lt;a.simmons@deakin.edu.au&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2020 Ashley Whetter &lt;ashleyw@activestate.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 David Liu &lt;david@cs.toronto.edu&gt;
# Copyright (c) 2021 kasium &lt;15907922+kasium@users.noreply.github.com&gt;
# Copyright (c) 2021 Marcin Kurczewski &lt;rr-@sakuya.pl&gt;
# Copyright (c) 2021 Sergei Lebedev &lt;185856+superbobry@users.noreply.github.com&gt;
# Copyright (c) 2021 Lorena B &lt;46202743+lorena-b@users.noreply.github.com&gt;
# Copyright (c) 2021 haasea &lt;44787650+haasea@users.noreply.github.com&gt;
# Copyright (c) 2021 Alexander Kapshuna &lt;kapsh@kap.sh&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""variables checkers for Python code
"""
import collections
import copy
import itertools
import os
import re
from functools import lru_cache

import astroid
from astroid import nodes

from pylint.checkers import BaseChecker, utils
from pylint.checkers.utils import is_postponed_evaluation_enabled
from pylint.constants import PY39_PLUS
from pylint.interfaces import HIGH, INFERENCE, INFERENCE_FAILURE, IAstroidChecker
from pylint.utils import get_global_option

SPECIAL_OBJ = re.compile("^_{2}[a-z]+_{2}$")
FUTURE = "__future__"
# regexp for ignored argument name
IGNORED_ARGUMENT_NAMES = re.compile("_.*|^ignored_|^unused_")
# In Python 3.7 abc has a Python implementation which is preferred
# by astroid. Unfortunately this also messes up our explicit checks
# for `abc`
METACLASS_NAME_TRANSFORMS = {"_py_abc": "abc"}
TYPING_TYPE_CHECKS_GUARDS = frozenset({"typing.TYPE_CHECKING", "TYPE_CHECKING"})
BUILTIN_RANGE = "builtins.range"
TYPING_MODULE = "typing"
TYPING_NAMES = frozenset(
    {
        "Any",
        "Callable",
        "ClassVar",
        "Generic",
        "Optional",
        "Tuple",
        "Type",
        "TypeVar",
        "Union",
        "AbstractSet",
        "ByteString",
        "Container",
        "ContextManager",
        "Hashable",
        "ItemsView",
        "Iterable",
        "Iterator",
        "KeysView",
        "Mapping",
        "MappingView",
        "MutableMapping",
        "MutableSequence",
        "MutableSet",
        "Sequence",
        "Sized",
        "ValuesView",
        "Awaitable",
        "AsyncIterator",
        "AsyncIterable",
        "Coroutine",
        "Collection",
        "AsyncGenerator",
        "AsyncContextManager",
        "Reversible",
        "SupportsAbs",
        "SupportsBytes",
        "SupportsComplex",
        "SupportsFloat",
        "SupportsInt",
        "SupportsRound",
        "Counter",
        "Deque",
        "Dict",
        "DefaultDict",
        "List",
        "Set",
        "FrozenSet",
        "NamedTuple",
        "Generator",
        "AnyStr",
        "Text",
        "Pattern",
        "BinaryIO",
    }
)


@others
</t>
<t tx="ekr.20220312061835.804">def _is_from_future_import(stmt, name):
    """Check if the name is a future import from another module."""
    try:
        module = stmt.do_import_module(stmt.modname)
    except astroid.AstroidBuildingException:
        return None

    for local_node in module.locals.get(name, []):
        if isinstance(local_node, nodes.ImportFrom) and local_node.modname == FUTURE:
            return True
    return None


</t>
<t tx="ekr.20220312061835.805">def in_for_else_branch(parent, stmt):
    """Returns True if stmt in inside the else branch for a parent For stmt."""
    return isinstance(parent, nodes.For) and any(
        else_stmt.parent_of(stmt) or else_stmt == stmt for else_stmt in parent.orelse
    )


</t>
<t tx="ekr.20220312061835.806">@lru_cache(maxsize=1000)
def overridden_method(klass, name):
    """get overridden method if any"""
    try:
        parent = next(klass.local_attr_ancestors(name))
    except (StopIteration, KeyError):
        return None
    try:
        meth_node = parent[name]
    except KeyError:
        # We have found an ancestor defining &lt;name&gt; but it's not in the local
        # dictionary. This may happen with astroid built from living objects.
        return None
    if isinstance(meth_node, nodes.FunctionDef):
        return meth_node
    return None


</t>
<t tx="ekr.20220312061835.807">def _get_unpacking_extra_info(node, inferred):
    """return extra information to add to the message for unpacking-non-sequence
    and unbalanced-tuple-unpacking errors
    """
    more = ""
    inferred_module = inferred.root().name
    if node.root().name == inferred_module:
        if node.lineno == inferred.lineno:
            more = f" {inferred.as_string()}"
        elif inferred.lineno:
            more = f" defined at line {inferred.lineno}"
    elif inferred.lineno:
        more = f" defined at line {inferred.lineno} of {inferred_module}"
    return more


</t>
<t tx="ekr.20220312061835.808">def _detect_global_scope(node, frame, defframe):
    """Detect that the given frames shares a global
    scope.

    Two frames shares a global scope when neither
    of them are hidden under a function scope, as well
    as any of parent scope of them, until the root scope.
    In this case, depending from something defined later on
    will not work, because it is still undefined.

    Example:
        class A:
            # B has the same global scope as `C`, leading to a NameError.
            class B(C): ...
        class C: ...

    """
    def_scope = scope = None
    if frame and frame.parent:
        scope = frame.parent.scope()
    if defframe and defframe.parent:
        def_scope = defframe.parent.scope()
    if isinstance(frame, nodes.FunctionDef):
        # If the parent of the current node is a
        # function, then it can be under its scope
        # (defined in, which doesn't concern us) or
        # the `-&gt;` part of annotations. The same goes
        # for annotations of function arguments, they'll have
        # their parent the Arguments node.
        if not isinstance(node.parent, (nodes.FunctionDef, nodes.Arguments)):
            return False
    elif any(
        not isinstance(f, (nodes.ClassDef, nodes.Module)) for f in (frame, defframe)
    ):
        # Not interested in other frames, since they are already
        # not in a global scope.
        return False

    break_scopes = []
    for current_scope in (scope, def_scope):
        # Look for parent scopes. If there is anything different
        # than a module or a class scope, then they frames don't
        # share a global scope.
        parent_scope = current_scope
        while parent_scope:
            if not isinstance(parent_scope, (nodes.ClassDef, nodes.Module)):
                break_scopes.append(parent_scope)
                break
            if parent_scope.parent:
                parent_scope = parent_scope.parent.scope()
            else:
                break
    if break_scopes and len(set(break_scopes)) != 1:
        # Store different scopes than expected.
        # If the stored scopes are, in fact, the very same, then it means
        # that the two frames (frame and defframe) shares the same scope,
        # and we could apply our lineno analysis over them.
        # For instance, this works when they are inside a function, the node
        # that uses a definition and the definition itself.
        return False
    # At this point, we are certain that frame and defframe shares a scope
    # and the definition of the first depends on the second.
    return frame.lineno &lt; defframe.lineno


</t>
<t tx="ekr.20220312061835.809">def _infer_name_module(node, name):
    context = astroid.context.InferenceContext()
    context.lookupname = name
    return node.infer(context, asname=False)


</t>
<t tx="ekr.20220312061835.81">def _has_abstract_methods(node):
    """
    Determine if the given `node` has abstract methods.

    The methods should be made abstract by decorating them
    with `abc` decorators.
    """
    return len(utils.unimplemented_abstract_methods(node)) &gt; 0


</t>
<t tx="ekr.20220312061835.810">def _fix_dot_imports(not_consumed):
    """Try to fix imports with multiple dots, by returning a dictionary
    with the import names expanded. The function unflattens root imports,
    like 'xml' (when we have both 'xml.etree' and 'xml.sax'), to 'xml.etree'
    and 'xml.sax' respectively.
    """
    names = {}
    for name, stmts in not_consumed.items():
        if any(
            isinstance(stmt, nodes.AssignName)
            and isinstance(stmt.assign_type(), nodes.AugAssign)
            for stmt in stmts
        ):
            continue
        for stmt in stmts:
            if not isinstance(stmt, (nodes.ImportFrom, nodes.Import)):
                continue
            for imports in stmt.names:
                second_name = None
                import_module_name = imports[0]
                if import_module_name == "*":
                    # In case of wildcard imports,
                    # pick the name from inside the imported module.
                    second_name = name
                else:
                    name_matches_dotted_import = False
                    if (
                        import_module_name.startswith(name)
                        and import_module_name.find(".") &gt; -1
                    ):
                        name_matches_dotted_import = True

                    if name_matches_dotted_import or name in imports:
                        # Most likely something like 'xml.etree',
                        # which will appear in the .locals as 'xml'.
                        # Only pick the name if it wasn't consumed.
                        second_name = import_module_name
                if second_name and second_name not in names:
                    names[second_name] = stmt
    return sorted(names.items(), key=lambda a: a[1].fromlineno)


</t>
<t tx="ekr.20220312061835.811">def _find_frame_imports(name, frame):
    """
    Detect imports in the frame, with the required
    *name*. Such imports can be considered assignments.
    Returns True if an import for the given name was found.
    """
    imports = frame.nodes_of_class((nodes.Import, nodes.ImportFrom))
    for import_node in imports:
        for import_name, import_alias in import_node.names:
            # If the import uses an alias, check only that.
            # Otherwise, check only the import name.
            if import_alias:
                if import_alias == name:
                    return True
            elif import_name and import_name == name:
                return True
    return None


</t>
<t tx="ekr.20220312061835.812">def _import_name_is_global(stmt, global_names):
    for import_name, import_alias in stmt.names:
        # If the import uses an alias, check only that.
        # Otherwise, check only the import name.
        if import_alias:
            if import_alias in global_names:
                return True
        elif import_name in global_names:
            return True
    return False


</t>
<t tx="ekr.20220312061835.813">def _flattened_scope_names(iterator):
    values = (set(stmt.names) for stmt in iterator)
    return set(itertools.chain.from_iterable(values))


</t>
<t tx="ekr.20220312061835.814">def _assigned_locally(name_node):
    """
    Checks if name_node has corresponding assign statement in same scope
    """
    assign_stmts = name_node.scope().nodes_of_class(nodes.AssignName)
    return any(a.name == name_node.name for a in assign_stmts)


</t>
<t tx="ekr.20220312061835.815">def _is_type_checking_import(node):
    parent = node.parent
    if not isinstance(parent, nodes.If):
        return False
    test = parent.test
    return test.as_string() in TYPING_TYPE_CHECKS_GUARDS


</t>
<t tx="ekr.20220312061835.816">def _has_locals_call_after_node(stmt, scope):
    skip_nodes = (
        nodes.FunctionDef,
        nodes.ClassDef,
        nodes.Import,
        nodes.ImportFrom,
    )
    for call in scope.nodes_of_class(nodes.Call, skip_klass=skip_nodes):
        inferred = utils.safe_infer(call.func)
        if (
            utils.is_builtin_object(inferred)
            and getattr(inferred, "name", None) == "locals"
        ):
            if stmt.lineno &lt; call.lineno:
                return True
    return False


</t>
<t tx="ekr.20220312061835.817">MSGS = {
    "E0601": (
        "Using variable %r before assignment",
        "used-before-assignment",
        "Used when a local variable is accessed before its assignment.",
    ),
    "E0602": (
        "Undefined variable %r",
        "undefined-variable",
        "Used when an undefined variable is accessed.",
    ),
    "E0603": (
        "Undefined variable name %r in __all__",
        "undefined-all-variable",
        "Used when an undefined variable name is referenced in __all__.",
    ),
    "E0604": (
        "Invalid object %r in __all__, must contain only strings",
        "invalid-all-object",
        "Used when an invalid (non-string) object occurs in __all__.",
    ),
    "E0605": (
        "Invalid format for __all__, must be tuple or list",
        "invalid-all-format",
        "Used when __all__ has an invalid format.",
    ),
    "E0611": (
        "No name %r in module %r",
        "no-name-in-module",
        "Used when a name cannot be found in a module.",
    ),
    "W0601": (
        "Global variable %r undefined at the module level",
        "global-variable-undefined",
        'Used when a variable is defined through the "global" statement '
        "but the variable is not defined in the module scope.",
    ),
    "W0602": (
        "Using global for %r but no assignment is done",
        "global-variable-not-assigned",
        'Used when a variable is defined through the "global" statement '
        "but no assignment to this variable is done.",
    ),
    "W0603": (
        "Using the global statement",  # W0121
        "global-statement",
        'Used when you use the "global" statement to update a global '
        "variable. Pylint just try to discourage this "
        "usage. That doesn't mean you cannot use it !",
    ),
    "W0604": (
        "Using the global statement at the module level",  # W0103
        "global-at-module-level",
        'Used when you use the "global" statement at the module level '
        "since it has no effect",
    ),
    "W0611": (
        "Unused %s",
        "unused-import",
        "Used when an imported module or variable is not used.",
    ),
    "W0612": (
        "Unused variable %r",
        "unused-variable",
        "Used when a variable is defined but not used.",
    ),
    "W0613": (
        "Unused argument %r",
        "unused-argument",
        "Used when a function or method argument is not used.",
    ),
    "W0614": (
        "Unused import %s from wildcard import",
        "unused-wildcard-import",
        "Used when an imported module or variable is not used from a "
        "`'from X import *'` style import.",
    ),
    "W0621": (
        "Redefining name %r from outer scope (line %s)",
        "redefined-outer-name",
        "Used when a variable's name hides a name defined in the outer scope.",
    ),
    "W0622": (
        "Redefining built-in %r",
        "redefined-builtin",
        "Used when a variable or function override a built-in.",
    ),
    "W0631": (
        "Using possibly undefined loop variable %r",
        "undefined-loop-variable",
        "Used when a loop variable (i.e. defined by a for loop or "
        "a list comprehension or a generator expression) is used outside "
        "the loop.",
    ),
    "W0632": (
        "Possible unbalanced tuple unpacking with "
        "sequence%s: "
        "left side has %d label(s), right side has %d value(s)",
        "unbalanced-tuple-unpacking",
        "Used when there is an unbalanced tuple unpacking in assignment",
        {"old_names": [("E0632", "old-unbalanced-tuple-unpacking")]},
    ),
    "E0633": (
        "Attempting to unpack a non-sequence%s",
        "unpacking-non-sequence",
        "Used when something which is not "
        "a sequence is used in an unpack assignment",
        {"old_names": [("W0633", "old-unpacking-non-sequence")]},
    ),
    "W0640": (
        "Cell variable %s defined in loop",
        "cell-var-from-loop",
        "A variable used in a closure is defined in a loop. "
        "This will result in all closures using the same value for "
        "the closed-over variable.",
    ),
    "W0641": (
        "Possibly unused variable %r",
        "possibly-unused-variable",
        "Used when a variable is defined but might not be used. "
        "The possibility comes from the fact that locals() might be used, "
        "which could consume or not the said variable",
    ),
    "W0642": (
        "Invalid assignment to %s in method",
        "self-cls-assignment",
        "Invalid assignment to self or cls in instance or class method "
        "respectively.",
    ),
}


ScopeConsumer = collections.namedtuple(
    "ScopeConsumer", "to_consume consumed scope_type"
)


</t>
<t tx="ekr.20220312061835.818">class NamesConsumer:
    """
    A simple class to handle consumed, to consume and scope type info of node locals
    """

    @others
</t>
<t tx="ekr.20220312061835.819">def __init__(self, node, scope_type):
    self._atomic = ScopeConsumer(copy.copy(node.locals), {}, scope_type)
    self.node = node

</t>
<t tx="ekr.20220312061835.82">def report_by_type_stats(
    sect,
    stats: CheckerStats,
    old_stats: CheckerStats,
):
    """make a report of

    * percentage of different types documented
    * percentage of different types with a bad name
    """
    # percentage of different types documented and/or with a bad name
    nice_stats: Dict[str, Dict[str, str]] = {}
    for node_type in ("module", "class", "method", "function"):
        try:
            total: int = stats[node_type]  # type: ignore
        except KeyError as e:
            raise exceptions.EmptyReportError() from e
        nice_stats[node_type] = {}
        if total != 0:
            try:
                undocumented_node: int = stats["undocumented_" + node_type]  # type: ignore
                documented = total - undocumented_node
                percent = (documented * 100.0) / total
                nice_stats[node_type]["percent_documented"] = f"{percent:.2f}"
            except KeyError:
                nice_stats[node_type]["percent_documented"] = "NC"
            try:
                badname_node: int = stats["badname_" + node_type]  # type: ignore
                percent = (badname_node * 100.0) / total
                nice_stats[node_type]["percent_badname"] = f"{percent:.2f}"
            except KeyError:
                nice_stats[node_type]["percent_badname"] = "NC"
    lines = ["type", "number", "old number", "difference", "%documented", "%badname"]
    for node_type in ("module", "class", "method", "function"):
        new = stats[node_type]
        old: Optional[Union[str, int]] = old_stats.get(node_type, None)  # type: ignore
        if old is not None:
            diff_str = lint_utils.diff_string(old, new)
        else:
            old, diff_str = "NC", "NC"
        lines += [
            node_type,
            str(new),
            str(old),
            diff_str,
            nice_stats[node_type].get("percent_documented", "0"),
            nice_stats[node_type].get("percent_badname", "0"),
        ]
    sect.append(reporter_nodes.Table(children=lines, cols=6, rheaders=1))


</t>
<t tx="ekr.20220312061835.820">def __repr__(self):
    to_consumes = [f"{k}-&gt;{v}" for k, v in self._atomic.to_consume.items()]
    consumed = [f"{k}-&gt;{v}" for k, v in self._atomic.consumed.items()]
    to_consumes = ", ".join(to_consumes)
    consumed = ", ".join(consumed)
    return f"""
\\-4.to_consume : {to_consumes}
\\-4.consumed : {consumed}
\\-4.scope_type : {self._atomic.scope_type}
\\-4."""

</t>
<t tx="ekr.20220312061835.821">def __iter__(self):
    return iter(self._atomic)

</t>
<t tx="ekr.20220312061835.822">@property
def to_consume(self):
    return self._atomic.to_consume

</t>
<t tx="ekr.20220312061835.823">@property
def consumed(self):
    return self._atomic.consumed

</t>
<t tx="ekr.20220312061835.824">@property
def scope_type(self):
    return self._atomic.scope_type

</t>
<t tx="ekr.20220312061835.825">def mark_as_consumed(self, name, consumed_nodes):
    """
    Mark the given nodes as consumed for the name.
    If all of the nodes for the name were consumed, delete the name from
    the to_consume dictionary
    """
    unconsumed = [n for n in self.to_consume[name] if n not in set(consumed_nodes)]
    self.consumed[name] = consumed_nodes

    if unconsumed:
        self.to_consume[name] = unconsumed
    else:
        del self.to_consume[name]

</t>
<t tx="ekr.20220312061835.826">def get_next_to_consume(self, node):
    """
    Return a list of the nodes that define `node` from this scope.
    Return None to indicate a special case that needs to be handled by the caller.
    """
    name = node.name
    parent_node = node.parent
    found_nodes = self.to_consume.get(name)
    if (
        found_nodes
        and isinstance(parent_node, nodes.Assign)
        and parent_node == found_nodes[0].parent
    ):
        lhs = found_nodes[0].parent.targets[0]
        if lhs.name == name:  # this name is defined in this very statement
            found_nodes = None

    if (
        found_nodes
        and isinstance(parent_node, nodes.For)
        and parent_node.iter == node
        and parent_node.target in found_nodes
    ):
        found_nodes = None

    # Filter out assignments in ExceptHandlers that node is not contained in
    if found_nodes:
        found_nodes = [
            n
            for n in found_nodes
            if not isinstance(n.statement(), nodes.ExceptHandler)
            or n.statement().parent_of(node)
        ]

    return found_nodes


</t>
<t tx="ekr.20220312061835.827"># pylint: disable=too-many-public-methods
class VariablesChecker(BaseChecker):
    """checks for
    * unused variables / imports
    * undefined variables
    * redefinition of variable from builtins or from an outer scope
    * use of variable before assignment
    * __all__ consistency
    * self/cls assignment
    """

    __implements__ = IAstroidChecker

    name = "variables"
    msgs = MSGS
    priority = -1
    options = (
        (
            "init-import",
            {
                "default": 0,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Tells whether we should check for unused import in "
                "__init__ files.",
            },
        ),
        (
            "dummy-variables-rgx",
            {
                "default": "_+$|(_[a-zA-Z0-9_]*[a-zA-Z0-9]+?$)|dummy|^ignored_|^unused_",
                "type": "regexp",
                "metavar": "&lt;regexp&gt;",
                "help": "A regular expression matching the name of dummy "
                "variables (i.e. expected to not be used).",
            },
        ),
        (
            "additional-builtins",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;comma separated list&gt;",
                "help": "List of additional names supposed to be defined in "
                "builtins. Remember that you should avoid defining new builtins "
                "when possible.",
            },
        ),
        (
            "callbacks",
            {
                "default": ("cb_", "_cb"),
                "type": "csv",
                "metavar": "&lt;callbacks&gt;",
                "help": "List of strings which can identify a callback "
                "function by name. A callback name must start or "
                "end with one of those strings.",
            },
        ),
        (
            "redefining-builtins-modules",
            {
                "default": (
                    "six.moves",
                    "past.builtins",
                    "future.builtins",
                    "builtins",
                    "io",
                ),
                "type": "csv",
                "metavar": "&lt;comma separated list&gt;",
                "help": "List of qualified module names which can have objects "
                "that can redefine builtins.",
            },
        ),
        (
            "ignored-argument-names",
            {
                "default": IGNORED_ARGUMENT_NAMES,
                "type": "regexp",
                "metavar": "&lt;regexp&gt;",
                "help": "Argument names that match this expression will be "
                "ignored. Default to name with leading underscore.",
            },
        ),
        (
            "allow-global-unused-variables",
            {
                "default": True,
                "type": "yn",
                "metavar": "&lt;y_or_n&gt;",
                "help": "Tells whether unused global variables should be treated as a violation.",
            },
        ),
        (
            "allowed-redefined-builtins",
            {
                "default": (),
                "type": "csv",
                "metavar": "&lt;comma separated list&gt;",
                "help": "List of names allowed to shadow builtins",
            },
        ),
    )

    @others
</t>
<t tx="ekr.20220312061835.828">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self._to_consume = (
        None  # list of tuples: (to_consume:dict, consumed:dict, scope_type:str)
    )
    self._checking_mod_attr = None
    self._loop_variables = []
    self._type_annotation_names = []
    self._postponed_evaluation_enabled = False

</t>
<t tx="ekr.20220312061835.829">@utils.check_messages("redefined-outer-name")
def visit_for(self, node: nodes.For) -&gt; None:
    assigned_to = [a.name for a in node.target.nodes_of_class(nodes.AssignName)]

    # Only check variables that are used
    dummy_rgx = self.config.dummy_variables_rgx
    assigned_to = [var for var in assigned_to if not dummy_rgx.match(var)]

    for variable in assigned_to:
        for outer_for, outer_variables in self._loop_variables:
            if variable in outer_variables and not in_for_else_branch(
                outer_for, node
            ):
                self.add_message(
                    "redefined-outer-name",
                    args=(variable, outer_for.fromlineno),
                    node=node,
                )
                break

    self._loop_variables.append((node, assigned_to))

</t>
<t tx="ekr.20220312061835.83">def redefined_by_decorator(node):
    """return True if the object is a method redefined via decorator.

    For example:
        @property
        def x(self): return self._x
        @x.setter
        def x(self, value): self._x = value
    """
    if node.decorators:
        for decorator in node.decorators.nodes:
            if (
                isinstance(decorator, nodes.Attribute)
                and getattr(decorator.expr, "name", None) == node.name
            ):
                return True
    return False


</t>
<t tx="ekr.20220312061835.830">@utils.check_messages("redefined-outer-name")
def leave_for(self, node: nodes.For) -&gt; None:
    self._loop_variables.pop()
    self._store_type_annotation_names(node)

</t>
<t tx="ekr.20220312061835.831">def visit_module(self, node: nodes.Module) -&gt; None:
    """visit module : update consumption analysis variable
    checks globals doesn't overrides builtins
    """
    self._to_consume = [NamesConsumer(node, "module")]
    self._postponed_evaluation_enabled = is_postponed_evaluation_enabled(node)

    for name, stmts in node.locals.items():
        if utils.is_builtin(name):
            if self._should_ignore_redefined_builtin(stmts[0]) or name == "__doc__":
                continue
            self.add_message("redefined-builtin", args=name, node=stmts[0])

</t>
<t tx="ekr.20220312061835.832">@utils.check_messages(
    "unused-import",
    "unused-wildcard-import",
    "redefined-builtin",
    "undefined-all-variable",
    "invalid-all-object",
    "invalid-all-format",
    "unused-variable",
)
</t>
<t tx="ekr.20220312061835.833">def leave_module(self, node: nodes.Module) -&gt; None:
    """leave module: check globals"""
    assert len(self._to_consume) == 1

    self._check_metaclasses(node)
    not_consumed = self._to_consume.pop().to_consume
    # attempt to check for __all__ if defined
    if "__all__" in node.locals:
        self._check_all(node, not_consumed)

    # check for unused globals
    self._check_globals(not_consumed)

    # don't check unused imports in __init__ files
    if not self.config.init_import and node.package:
        return

    self._check_imports(not_consumed)

</t>
<t tx="ekr.20220312061835.834">def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    """visit class: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "class"))

</t>
<t tx="ekr.20220312061835.835">def leave_classdef(self, _: nodes.ClassDef) -&gt; None:
    """leave class: update consumption analysis variable"""
    # do not check for not used locals here (no sense)
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.836">def visit_lambda(self, node: nodes.Lambda) -&gt; None:
    """visit lambda: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "lambda"))

</t>
<t tx="ekr.20220312061835.837">def leave_lambda(self, _: nodes.Lambda) -&gt; None:
    """leave lambda: update consumption analysis variable"""
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.838">def visit_generatorexp(self, node: nodes.GeneratorExp) -&gt; None:
    """visit genexpr: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "comprehension"))

</t>
<t tx="ekr.20220312061835.839">def leave_generatorexp(self, _: nodes.GeneratorExp) -&gt; None:
    """leave genexpr: update consumption analysis variable"""
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.84">class _BasicChecker(checkers.BaseChecker):
    __implements__ = interfaces.IAstroidChecker
    name = "basic"


</t>
<t tx="ekr.20220312061835.840">def visit_dictcomp(self, node: nodes.DictComp) -&gt; None:
    """visit dictcomp: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "comprehension"))

</t>
<t tx="ekr.20220312061835.841">def leave_dictcomp(self, _: nodes.DictComp) -&gt; None:
    """leave dictcomp: update consumption analysis variable"""
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.842">def visit_setcomp(self, node: nodes.SetComp) -&gt; None:
    """visit setcomp: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "comprehension"))

</t>
<t tx="ekr.20220312061835.843">def leave_setcomp(self, _: nodes.SetComp) -&gt; None:
    """leave setcomp: update consumption analysis variable"""
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.844">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """visit function: update consumption analysis variable and check locals"""
    self._to_consume.append(NamesConsumer(node, "function"))
    if not (
        self.linter.is_message_enabled("redefined-outer-name")
        or self.linter.is_message_enabled("redefined-builtin")
    ):
        return
    globs = node.root().globals
    for name, stmt in node.items():
        if name in globs and not isinstance(stmt, nodes.Global):
            definition = globs[name][0]
            if (
                isinstance(definition, nodes.ImportFrom)
                and definition.modname == FUTURE
            ):
                # It is a __future__ directive, not a symbol.
                continue

            # Do not take in account redefined names for the purpose
            # of type checking.:
            if any(
                isinstance(definition.parent, nodes.If)
                and definition.parent.test.as_string() in TYPING_TYPE_CHECKS_GUARDS
                for definition in globs[name]
            ):
                continue

            line = definition.fromlineno
            if not self._is_name_ignored(stmt, name):
                self.add_message(
                    "redefined-outer-name", args=(name, line), node=stmt
                )

        elif (
            utils.is_builtin(name)
            and not self._allowed_redefined_builtin(name)
            and not self._should_ignore_redefined_builtin(stmt)
        ):
            # do not print Redefining builtin for additional builtins
            self.add_message("redefined-builtin", args=name, node=stmt)

</t>
<t tx="ekr.20220312061835.845">def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    """leave function: check function's locals are consumed"""
    self._check_metaclasses(node)

    if node.type_comment_returns:
        self._store_type_annotation_node(node.type_comment_returns)
    if node.type_comment_args:
        for argument_annotation in node.type_comment_args:
            self._store_type_annotation_node(argument_annotation)

    not_consumed = self._to_consume.pop().to_consume
    if not (
        self.linter.is_message_enabled("unused-variable")
        or self.linter.is_message_enabled("possibly-unused-variable")
        or self.linter.is_message_enabled("unused-argument")
    ):
        return

    # Don't check arguments of function which are only raising an exception.
    if utils.is_error(node):
        return

    # Don't check arguments of abstract methods or within an interface.
    is_method = node.is_method()
    if is_method and node.is_abstract():
        return

    global_names = _flattened_scope_names(node.nodes_of_class(nodes.Global))
    nonlocal_names = _flattened_scope_names(node.nodes_of_class(nodes.Nonlocal))
    for name, stmts in not_consumed.items():
        self._check_is_unused(name, node, stmts[0], global_names, nonlocal_names)

</t>
<t tx="ekr.20220312061835.846">visit_asyncfunctiondef = visit_functiondef
leave_asyncfunctiondef = leave_functiondef

@utils.check_messages(
    "global-variable-undefined",
    "global-variable-not-assigned",
    "global-statement",
    "global-at-module-level",
    "redefined-builtin",
)
</t>
<t tx="ekr.20220312061835.847">def visit_global(self, node: nodes.Global) -&gt; None:
    """check names imported exists in the global scope"""
    frame = node.frame()
    if isinstance(frame, nodes.Module):
        self.add_message("global-at-module-level", node=node)
        return

    module = frame.root()
    default_message = True
    locals_ = node.scope().locals
    for name in node.names:
        try:
            assign_nodes = module.getattr(name)
        except astroid.NotFoundError:
            # unassigned global, skip
            assign_nodes = []

        not_defined_locally_by_import = not any(
            isinstance(local, nodes.Import) for local in locals_.get(name, ())
        )
        if (
            not utils.is_reassigned_after_current(node, name)
            and not_defined_locally_by_import
        ):
            self.add_message("global-variable-not-assigned", args=name, node=node)
            default_message = False
            continue

        for anode in assign_nodes:
            if (
                isinstance(anode, nodes.AssignName)
                and anode.name in module.special_attributes
            ):
                self.add_message("redefined-builtin", args=name, node=node)
                break
            if anode.frame() is module:
                # module level assignment
                break
            if isinstance(anode, nodes.FunctionDef) and anode.parent is module:
                # module level function assignment
                break
        else:
            if not_defined_locally_by_import:
                # global undefined at the module scope
                self.add_message("global-variable-undefined", args=name, node=node)
                default_message = False

    if default_message:
        self.add_message("global-statement", node=node)

</t>
<t tx="ekr.20220312061835.848">def visit_assignname(self, node: nodes.AssignName) -&gt; None:
    if isinstance(node.assign_type(), nodes.AugAssign):
        self.visit_name(node)

</t>
<t tx="ekr.20220312061835.849">def visit_delname(self, node: nodes.DelName) -&gt; None:
    self.visit_name(node)

</t>
<t tx="ekr.20220312061835.85">class BasicErrorChecker(_BasicChecker):
    msgs = {
        "E0100": (
            "__init__ method is a generator",
            "init-is-generator",
            "Used when the special class method __init__ is turned into a "
            "generator by a yield in its body.",
        ),
        "E0101": (
            "Explicit return in __init__",
            "return-in-init",
            "Used when the special class method __init__ has an explicit "
            "return value.",
        ),
        "E0102": (
            "%s already defined line %s",
            "function-redefined",
            "Used when a function / class / method is redefined.",
        ),
        "E0103": (
            "%r not properly in loop",
            "not-in-loop",
            "Used when break or continue keywords are used outside a loop.",
        ),
        "E0104": (
            "Return outside function",
            "return-outside-function",
            'Used when a "return" statement is found outside a function or method.',
        ),
        "E0105": (
            "Yield outside function",
            "yield-outside-function",
            'Used when a "yield" statement is found outside a function or method.',
        ),
        "E0106": (
            "Return with argument inside generator",
            "return-arg-in-generator",
            'Used when a "return" statement with an argument is found '
            "outside in a generator function or method (e.g. with some "
            '"yield" statements).',
            {"maxversion": (3, 3)},
        ),
        "E0107": (
            "Use of the non-existent %s operator",
            "nonexistent-operator",
            "Used when you attempt to use the C-style pre-increment or "
            "pre-decrement operator -- and ++, which doesn't exist in Python.",
        ),
        "E0108": (
            "Duplicate argument name %s in function definition",
            "duplicate-argument-name",
            "Duplicate argument names in function definitions are syntax errors.",
        ),
        "E0110": (
            "Abstract class %r with abstract methods instantiated",
            "abstract-class-instantiated",
            "Used when an abstract class with `abc.ABCMeta` as metaclass "
            "has abstract methods and is instantiated.",
        ),
        "W0120": (
            "Else clause on loop without a break statement",
            "useless-else-on-loop",
            "Loops should only have an else clause if they can exit early "
            "with a break statement, otherwise the statements under else "
            "should be on the same scope as the loop itself.",
        ),
        "E0112": (
            "More than one starred expression in assignment",
            "too-many-star-expressions",
            "Emitted when there are more than one starred "
            "expressions (`*x`) in an assignment. This is a SyntaxError.",
        ),
        "E0113": (
            "Starred assignment target must be in a list or tuple",
            "invalid-star-assignment-target",
            "Emitted when a star expression is used as a starred assignment target.",
        ),
        "E0114": (
            "Can use starred expression only in assignment target",
            "star-needs-assignment-target",
            "Emitted when a star expression is not used in an assignment target.",
        ),
        "E0115": (
            "Name %r is nonlocal and global",
            "nonlocal-and-global",
            "Emitted when a name is both nonlocal and global.",
        ),
        "E0116": (
            "'continue' not supported inside 'finally' clause",
            "continue-in-finally",
            "Emitted when the `continue` keyword is found "
            "inside a finally clause, which is a SyntaxError.",
            {"maxversion": (3, 8)},
        ),
        "E0117": (
            "nonlocal name %s found without binding",
            "nonlocal-without-binding",
            "Emitted when a nonlocal variable does not have an attached "
            "name somewhere in the parent scopes",
        ),
        "E0118": (
            "Name %r is used prior to global declaration",
            "used-prior-global-declaration",
            "Emitted when a name is used prior a global declaration, "
            "which results in an error since Python 3.6.",
            {"minversion": (3, 6)},
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.850"># pylint: disable=too-many-branches
def visit_name(self, node: nodes.Name) -&gt; None:
    """Check that a name is defined in the current scope"""
    stmt = node.statement()
    if stmt.fromlineno is None:
        # name node from an astroid built from live code, skip
        assert not stmt.root().file.endswith(".py")
        return

    name = node.name
    frame = stmt.scope()
    start_index = len(self._to_consume) - 1

    undefined_variable_is_enabled = self.linter.is_message_enabled(
        "undefined-variable"
    )
    used_before_assignment_is_enabled = self.linter.is_message_enabled(
        "used-before-assignment"
    )

    # iterates through parent scopes, from the inner to the outer
    base_scope_type = self._to_consume[start_index].scope_type
    # pylint: disable=too-many-nested-blocks; refactoring this block is a pain.
    for i in range(start_index, -1, -1):
        current_consumer = self._to_consume[i]

        # The list of base classes in the class definition is not part
        # of the class body.
        # If the current scope is a class scope but it's not the inner
        # scope, ignore it. This prevents to access this scope instead of
        # the globals one in function members when there are some common
        # names.
        if current_consumer.scope_type == "class" and (
            utils.is_ancestor_name(current_consumer.node, node)
            or (i != start_index and self._ignore_class_scope(node))
        ):
            continue

        # Ignore inner class scope for keywords in class definition
        if (
            current_consumer.scope_type == "class"
            and isinstance(node.parent, nodes.Keyword)
            and isinstance(node.parent.parent, nodes.ClassDef)
        ):
            continue

        # if the name node is used as a function default argument's value or as
        # a decorator, then start from the parent frame of the function instead
        # of the function frame - and thus open an inner class scope
        if (
            current_consumer.scope_type == "function"
            and self._defined_in_function_definition(node, current_consumer.node)
        ):
            # ignore function scope if is an annotation/default/decorator, as not in the body
            continue

        if current_consumer.scope_type == "lambda" and utils.is_default_argument(
            node, current_consumer.node
        ):
            continue

        # the name has already been consumed, only check it's not a loop
        # variable used outside the loop
        # avoid the case where there are homonyms inside function scope and
        # comprehension current scope (avoid bug #1731)
        if name in current_consumer.consumed and (
            utils.is_func_decorator(current_consumer.node)
            or not (
                current_consumer.scope_type == "comprehension"
                and self._has_homonym_in_upper_function_scope(node, i)
            )
        ):
            self._check_late_binding_closure(node)
            self._loopvar_name(node, name)
            break

        found_nodes = current_consumer.get_next_to_consume(node)
        if found_nodes is None:
            continue

        # checks for use before assignment
        if found_nodes:
            defnode = utils.assign_parent(found_nodes[0])
        else:
            defnode = None
            if used_before_assignment_is_enabled:
                self.add_message("used-before-assignment", args=name, node=node)

        self._check_late_binding_closure(node)

        if (
            undefined_variable_is_enabled or used_before_assignment_is_enabled
        ) and defnode is not None:
            defstmt = defnode.statement()
            defframe = defstmt.frame()
            # The class reuses itself in the class scope.
            recursive_klass = (
                frame is defframe
                and defframe.parent_of(node)
                and isinstance(defframe, nodes.ClassDef)
                and node.name == defframe.name
            )

            if (
                recursive_klass
                and utils.is_inside_lambda(node)
                and (
                    not utils.is_default_argument(node)
                    or node.scope().parent.scope() is not defframe
                )
            ):
                # Self-referential class references are fine in lambda's --
                # As long as they are not part of the default argument directly
                # under the scope of the parent self-referring class.
                # Example of valid default argument:
                # class MyName3:
                #     myattr = 1
                #     mylambda3 = lambda: lambda a=MyName3: a
                # Example of invalid default argument:
                # class MyName4:
                #     myattr = 1
                #     mylambda4 = lambda a=MyName4: lambda: a

                # If the above conditional is True,
                # there is no possibility of undefined-variable
                # Also do not consume class name
                # (since consuming blocks subsequent checks)
                # -- quit
                break

            (
                maybee0601,
                annotation_return,
                use_outer_definition,
            ) = self._is_variable_violation(
                node,
                name,
                defnode,
                stmt,
                defstmt,
                frame,
                defframe,
                base_scope_type,
                recursive_klass,
            )

            if use_outer_definition:
                continue

            if (
                maybee0601
                and not utils.is_defined_before(node)
                and not astroid.are_exclusive(stmt, defstmt, ("NameError",))
            ):

                # Used and defined in the same place, e.g `x += 1` and `del x`
                defined_by_stmt = defstmt is stmt and isinstance(
                    node, (nodes.DelName, nodes.AssignName)
                )
                if (
                    recursive_klass
                    or defined_by_stmt
                    or annotation_return
                    or isinstance(defstmt, nodes.Delete)
                ):
                    if not utils.node_ignores_exception(node, NameError):

                        # Handle postponed evaluation of annotations
                        if not (
                            self._postponed_evaluation_enabled
                            and isinstance(
                                stmt,
                                (
                                    nodes.AnnAssign,
                                    nodes.FunctionDef,
                                    nodes.Arguments,
                                ),
                            )
                            and name in node.root().locals
                        ):
                            self.add_message(
                                "undefined-variable", args=name, node=node
                            )
                elif base_scope_type != "lambda":
                    # E0601 may *not* occurs in lambda scope.

                    # Handle postponed evaluation of annotations
                    if not (
                        self._postponed_evaluation_enabled
                        and isinstance(stmt, (nodes.AnnAssign, nodes.FunctionDef))
                    ):
                        self.add_message(
                            "used-before-assignment", args=name, node=node
                        )
                elif base_scope_type == "lambda":
                    # E0601 can occur in class-level scope in lambdas, as in
                    # the following example:
                    #   class A:
                    #      x = lambda attr: f + attr
                    #      f = 42
                    if isinstance(frame, nodes.ClassDef) and name in frame.locals:
                        if isinstance(node.parent, nodes.Arguments):
                            if stmt.fromlineno &lt;= defstmt.fromlineno:
                                # Doing the following is fine:
                                #   class A:
                                #      x = 42
                                #      y = lambda attr=x: attr
                                self.add_message(
                                    "used-before-assignment", args=name, node=node
                                )
                        else:
                            self.add_message(
                                "undefined-variable", args=name, node=node
                            )
                    elif current_consumer.scope_type == "lambda":
                        self.add_message("undefined-variable", node=node, args=name)

        current_consumer.mark_as_consumed(name, found_nodes)
        # check it's not a loop variable used outside the loop
        self._loopvar_name(node, name)
        break
    else:
        # we have not found the name, if it isn't a builtin, that's an
        # undefined name !
        if undefined_variable_is_enabled and not (
            name in nodes.Module.scope_attrs
            or utils.is_builtin(name)
            or name in self.config.additional_builtins
            or (
                name == "__class__"
                and isinstance(frame, nodes.FunctionDef)
                and frame.is_method()
            )
        ):
            if not utils.node_ignores_exception(node, NameError):
                self.add_message("undefined-variable", args=name, node=node)

</t>
<t tx="ekr.20220312061835.851">@utils.check_messages("no-name-in-module")
def visit_import(self, node: nodes.Import) -&gt; None:
    """check modules attribute accesses"""
    if not self._analyse_fallback_blocks and utils.is_from_fallback_block(node):
        # No need to verify this, since ImportError is already
        # handled by the client code.
        return
    if utils.is_node_in_guarded_import_block(node) is True:
        # Don't verify import if part of guarded import block
        # I.e. `sys.version_info` or `typing.TYPE_CHECKING`
        return

    for name, _ in node.names:
        parts = name.split(".")
        try:
            module = next(_infer_name_module(node, parts[0]))
        except astroid.ResolveError:
            continue
        if not isinstance(module, nodes.Module):
            continue
        self._check_module_attrs(node, module, parts[1:])

</t>
<t tx="ekr.20220312061835.852">@utils.check_messages("no-name-in-module")
def visit_importfrom(self, node: nodes.ImportFrom) -&gt; None:
    """check modules attribute accesses"""
    if not self._analyse_fallback_blocks and utils.is_from_fallback_block(node):
        # No need to verify this, since ImportError is already
        # handled by the client code.
        return
    if utils.is_node_in_guarded_import_block(node) is True:
        # Don't verify import if part of guarded import block
        # I.e. `sys.version_info` or `typing.TYPE_CHECKING`
        return

    name_parts = node.modname.split(".")
    try:
        module = node.do_import_module(name_parts[0])
    except astroid.AstroidBuildingException:
        return
    module = self._check_module_attrs(node, module, name_parts[1:])
    if not module:
        return
    for name, _ in node.names:
        if name == "*":
            continue
        self._check_module_attrs(node, module, name.split("."))

</t>
<t tx="ekr.20220312061835.853">@utils.check_messages(
    "unbalanced-tuple-unpacking", "unpacking-non-sequence", "self-cls-assignment"
)
</t>
<t tx="ekr.20220312061835.854">def visit_assign(self, node: nodes.Assign) -&gt; None:
    """Check unbalanced tuple unpacking for assignments
    and unpacking non-sequences as well as in case self/cls
    get assigned.
    """
    self._check_self_cls_assign(node)
    if not isinstance(node.targets[0], (nodes.Tuple, nodes.List)):
        return

    targets = node.targets[0].itered()
    try:
        inferred = utils.safe_infer(node.value)
        if inferred is not None:
            self._check_unpacking(inferred, node, targets)
    except astroid.InferenceError:
        return

</t>
<t tx="ekr.20220312061835.855"># listcomp have now also their scope
def visit_listcomp(self, node: nodes.ListComp) -&gt; None:
    """visit dictcomp: update consumption analysis variable"""
    self._to_consume.append(NamesConsumer(node, "comprehension"))

</t>
<t tx="ekr.20220312061835.856">def leave_listcomp(self, _: nodes.ListComp) -&gt; None:
    """leave dictcomp: update consumption analysis variable"""
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20220312061835.857">def leave_assign(self, node: nodes.Assign) -&gt; None:
    self._store_type_annotation_names(node)

</t>
<t tx="ekr.20220312061835.858">def leave_with(self, node: nodes.With) -&gt; None:
    self._store_type_annotation_names(node)

</t>
<t tx="ekr.20220312061835.859">def visit_arguments(self, node: nodes.Arguments) -&gt; None:
    for annotation in node.type_comment_args:
        self._store_type_annotation_node(annotation)

</t>
<t tx="ekr.20220312061835.86">@utils.check_messages("function-redefined")
def visit_classdef(self, node: nodes.ClassDef) -&gt; None:
    self._check_redefinition("class", node)

</t>
<t tx="ekr.20220312061835.860"># Relying on other checker's options, which might not have been initialized yet.
@astroid.decorators.cachedproperty
def _analyse_fallback_blocks(self):
    return get_global_option(self, "analyse-fallback-blocks", default=False)

</t>
<t tx="ekr.20220312061835.861">@astroid.decorators.cachedproperty
def _ignored_modules(self):
    return get_global_option(self, "ignored-modules", default=[])

</t>
<t tx="ekr.20220312061835.862">@astroid.decorators.cachedproperty
def _allow_global_unused_variables(self):
    return get_global_option(self, "allow-global-unused-variables", default=True)

</t>
<t tx="ekr.20220312061835.863">@staticmethod
def _defined_in_function_definition(node, frame):
    in_annotation_or_default_or_decorator = False
    if isinstance(frame, nodes.FunctionDef) and node.statement() is frame:
        in_annotation_or_default_or_decorator = (
            (
                node in frame.args.annotations
                or node in frame.args.posonlyargs_annotations
                or node in frame.args.kwonlyargs_annotations
                or node is frame.args.varargannotation
                or node is frame.args.kwargannotation
            )
            or frame.args.parent_of(node)
            or (frame.decorators and frame.decorators.parent_of(node))
            or (
                frame.returns
                and (node is frame.returns or frame.returns.parent_of(node))
            )
        )
    return in_annotation_or_default_or_decorator

</t>
<t tx="ekr.20220312061835.864">@staticmethod
def _in_lambda_or_comprehension_body(
    node: nodes.NodeNG, frame: nodes.NodeNG
) -&gt; bool:
    """return True if node within a lambda/comprehension body (or similar) and thus should not have access to class attributes in frame"""
    child = node
    parent = node.parent
    while parent is not None:
        if parent is frame:
            return False
        if isinstance(parent, nodes.Lambda) and child is not parent.args:
            # Body of lambda should not have access to class attributes.
            return True
        if isinstance(parent, nodes.Comprehension) and child is not parent.iter:
            # Only iter of list/set/dict/generator comprehension should have access.
            return True
        if isinstance(parent, nodes.ComprehensionScope) and not (
            parent.generators and child is parent.generators[0]
        ):
            # Body of list/set/dict/generator comprehension should not have access to class attributes.
            # Furthermore, only the first generator (if multiple) in comprehension should have access.
            return True
        child = parent
        parent = parent.parent
    return False

</t>
<t tx="ekr.20220312061835.865">@staticmethod
def _is_variable_violation(
    node,
    name,
    defnode,
    stmt,
    defstmt,
    frame,
    defframe,
    base_scope_type,
    recursive_klass,
):
    # pylint: disable=too-many-nested-blocks
    # node: Node to check for violation
    # name: name of node to check violation for
    # frame: Scope of statement of node
    # base_scope_type: local scope type
    maybee0601 = True
    annotation_return = False
    use_outer_definition = False
    if frame is not defframe:
        maybee0601 = _detect_global_scope(node, frame, defframe)
    elif defframe.parent is None:
        # we are at the module level, check the name is not
        # defined in builtins
        if name in defframe.scope_attrs or astroid.builtin_lookup(name)[1]:
            maybee0601 = False
    else:
        # we are in a local scope, check the name is not
        # defined in global or builtin scope
        # skip this lookup if name is assigned later in function scope/lambda
        # Note: the node.frame() is not the same as the `frame` argument which is
        # equivalent to frame.statement().scope()
        forbid_lookup = (
            isinstance(frame, nodes.FunctionDef)
            or isinstance(node.frame(), nodes.Lambda)
        ) and _assigned_locally(node)
        if not forbid_lookup and defframe.root().lookup(name)[1]:
            maybee0601 = False
            use_outer_definition = stmt == defstmt and not isinstance(
                defnode, nodes.Comprehension
            )
        # check if we have a nonlocal
        elif name in defframe.locals:
            maybee0601 = not any(
                isinstance(child, nodes.Nonlocal) and name in child.names
                for child in defframe.get_children()
            )

    if (
        base_scope_type == "lambda"
        and isinstance(frame, nodes.ClassDef)
        and name in frame.locals
    ):

        # This rule verifies that if the definition node of the
        # checked name is an Arguments node and if the name
        # is used a default value in the arguments defaults
        # and the actual definition of the variable label
        # is happening before the Arguments definition.
        #
        # bar = None
        # foo = lambda bar=bar: bar
        #
        # In this case, maybee0601 should be False, otherwise
        # it should be True.
        maybee0601 = not (
            isinstance(defnode, nodes.Arguments)
            and node in defnode.defaults
            and frame.locals[name][0].fromlineno &lt; defstmt.fromlineno
        )
    elif isinstance(defframe, nodes.ClassDef) and isinstance(
        frame, nodes.FunctionDef
    ):
        # Special rule for function return annotations,
        # which uses the same name as the class where
        # the function lives.
        if node is frame.returns and defframe.parent_of(frame.returns):
            maybee0601 = annotation_return = True

        if (
            maybee0601
            and defframe.name in defframe.locals
            and defframe.locals[name][0].lineno &lt; frame.lineno
        ):
            # Detect class assignments with the same
            # name as the class. In this case, no warning
            # should be raised.
            maybee0601 = False
        if isinstance(node.parent, nodes.Arguments):
            maybee0601 = stmt.fromlineno &lt;= defstmt.fromlineno
    elif recursive_klass:
        maybee0601 = True
    else:
        maybee0601 = maybee0601 and stmt.fromlineno &lt;= defstmt.fromlineno
        if maybee0601 and stmt.fromlineno == defstmt.fromlineno:
            if (
                isinstance(defframe, nodes.FunctionDef)
                and frame is defframe
                and defframe.parent_of(node)
                and stmt is not defstmt
            ):
                # Single statement function, with the statement on the
                # same line as the function definition
                maybee0601 = False
            elif (
                isinstance(
                    defstmt,
                    (
                        nodes.Assign,
                        nodes.AnnAssign,
                        nodes.AugAssign,
                        nodes.Expr,
                        nodes.Return,
                    ),
                )
                and isinstance(defstmt.value, nodes.IfExp)
                and frame is defframe
                and defframe.parent_of(node)
                and stmt is defstmt
            ):
                # Single statement if, with assingment expression on same
                # line as assigment
                # x = b if (b := True) else False
                maybee0601 = False
            elif (
                isinstance(  # pylint: disable=too-many-boolean-expressions
                    defnode, nodes.NamedExpr
                )
                and frame is defframe
                and defframe.parent_of(stmt)
                and stmt is defstmt
                and (
                    (
                        defnode.lineno == node.lineno
                        and defnode.col_offset &lt; node.col_offset
                    )
                    or (defnode.lineno &lt; node.lineno)
                    or (
                        # Issue in the `ast` module until py39
                        # Nodes in a multiline string have the same lineno
                        # Could be false-positive without check
                        not PY39_PLUS
                        and defnode.lineno == node.lineno
                        and isinstance(
                            defstmt,
                            (
                                nodes.Assign,
                                nodes.AnnAssign,
                                nodes.AugAssign,
                                nodes.Return,
                            ),
                        )
                        and isinstance(defstmt.value, nodes.JoinedStr)
                    )
                )
            ):
                # Expressions, with assignment expressions
                # Use only after assignment
                # b = (c := 2) and c
                maybee0601 = False

        # Look for type checking definitions inside a type checking guard.
        if isinstance(defstmt, (nodes.Import, nodes.ImportFrom)):
            defstmt_parent = defstmt.parent

            if (
                isinstance(defstmt_parent, nodes.If)
                and defstmt_parent.test.as_string() in TYPING_TYPE_CHECKS_GUARDS
            ):
                # Exempt those definitions that are used inside the type checking
                # guard or that are defined in both type checking guard branches.
                used_in_branch = defstmt_parent.parent_of(node)
                defined_in_or_else = False

                for definition in defstmt_parent.orelse:
                    if isinstance(definition, nodes.Assign):
                        defined_in_or_else = any(
                            target.name == name for target in definition.targets
                        )
                        if defined_in_or_else:
                            break

                if not used_in_branch and not defined_in_or_else:
                    maybee0601 = True

    return maybee0601, annotation_return, use_outer_definition

</t>
<t tx="ekr.20220312061835.866">def _ignore_class_scope(self, node):
    """
    Return True if the node is in a local class scope, as an assignment.

    :param node: Node considered
    :type node: astroid.Node
    :return: True if the node is in a local class scope, as an assignment. False otherwise.
    :rtype: bool
    """
    # Detect if we are in a local class scope, as an assignment.
    # For example, the following is fair game.
    #
    # class A:
    #    b = 1
    #    c = lambda b=b: b * b
    #
    # class B:
    #    tp = 1
    #    def func(self, arg: tp):
    #        ...
    # class C:
    #    tp = 2
    #    def func(self, arg=tp):
    #        ...
    # class C:
    #    class Tp:
    #        pass
    #    class D(Tp):
    #        ...

    name = node.name
    frame = node.statement().scope()
    in_annotation_or_default_or_decorator = self._defined_in_function_definition(
        node, frame
    )
    in_ancestor_list = utils.is_ancestor_name(frame, node)
    if in_annotation_or_default_or_decorator or in_ancestor_list:
        frame_locals = frame.parent.scope().locals
    else:
        frame_locals = frame.locals
    return not (
        (isinstance(frame, nodes.ClassDef) or in_annotation_or_default_or_decorator)
        and not self._in_lambda_or_comprehension_body(node, frame)
        and name in frame_locals
    )

</t>
<t tx="ekr.20220312061835.867">def _loopvar_name(self, node, name):
    # filter variables according to node's scope
    if not self.linter.is_message_enabled("undefined-loop-variable"):
        return
    astmts = [stmt for stmt in node.lookup(name)[1] if hasattr(stmt, "assign_type")]
    # If this variable usage exists inside a function definition
    # that exists in the same loop,
    # the usage is safe because the function will not be defined either if
    # the variable is not defined.
    scope = node.scope()
    if isinstance(scope, nodes.FunctionDef) and any(
        asmt.statement().parent_of(scope) for asmt in astmts
    ):
        return

    # filter variables according their respective scope test is_statement
    # and parent to avoid #74747. This is not a total fix, which would
    # introduce a mechanism similar to special attribute lookup in
    # modules. Also, in order to get correct inference in this case, the
    # scope lookup rules would need to be changed to return the initial
    # assignment (which does not exist in code per se) as well as any later
    # modifications.
    if (
        not astmts
        or (astmts[0].is_statement or astmts[0].parent)
        and astmts[0].statement().parent_of(node)
    ):
        _astmts = []
    else:
        _astmts = astmts[:1]
    for i, stmt in enumerate(astmts[1:]):
        if astmts[i].statement().parent_of(stmt) and not in_for_else_branch(
            astmts[i].statement(), stmt
        ):
            continue
        _astmts.append(stmt)
    astmts = _astmts
    if len(astmts) != 1:
        return

    assign = astmts[0].assign_type()
    if not (
        isinstance(assign, (nodes.For, nodes.Comprehension, nodes.GeneratorExp))
        and assign.statement() is not node.statement()
    ):
        return

    # For functions we can do more by inferring the length of the itered object
    if not isinstance(assign, nodes.For):
        self.add_message("undefined-loop-variable", args=name, node=node)
        return

    try:
        inferred = next(assign.iter.infer())
    except astroid.InferenceError:
        self.add_message("undefined-loop-variable", args=name, node=node)
    else:
        if (
            isinstance(inferred, astroid.Instance)
            and inferred.qname() == BUILTIN_RANGE
        ):
            # Consider range() objects safe, even if they might not yield any results.
            return

        # Consider sequences.
        sequences = (
            nodes.List,
            nodes.Tuple,
            nodes.Dict,
            nodes.Set,
            astroid.objects.FrozenSet,
        )
        if not isinstance(inferred, sequences):
            self.add_message("undefined-loop-variable", args=name, node=node)
            return

        elements = getattr(inferred, "elts", getattr(inferred, "items", []))
        if not elements:
            self.add_message("undefined-loop-variable", args=name, node=node)

</t>
<t tx="ekr.20220312061835.868">def _check_is_unused(self, name, node, stmt, global_names, nonlocal_names):
    # pylint: disable=too-many-branches
    # Ignore some special names specified by user configuration.
    if self._is_name_ignored(stmt, name):
        return
    # Ignore names that were added dynamically to the Function scope
    if (
        isinstance(node, nodes.FunctionDef)
        and name == "__class__"
        and len(node.locals["__class__"]) == 1
        and isinstance(node.locals["__class__"][0], nodes.ClassDef)
    ):
        return

    # Ignore names imported by the global statement.
    if isinstance(stmt, (nodes.Global, nodes.Import, nodes.ImportFrom)):
        # Detect imports, assigned to global statements.
        if global_names and _import_name_is_global(stmt, global_names):
            return

    argnames = list(
        itertools.chain(node.argnames(), [arg.name for arg in node.args.kwonlyargs])
    )
    # Care about functions with unknown argument (builtins)
    if name in argnames:
        self._check_unused_arguments(name, node, stmt, argnames)
    else:
        if stmt.parent and isinstance(stmt.parent, (nodes.Assign, nodes.AnnAssign)):
            if name in nonlocal_names:
                return

        qname = asname = None
        if isinstance(stmt, (nodes.Import, nodes.ImportFrom)):
            # Need the complete name, which we don't have in .locals.
            if len(stmt.names) &gt; 1:
                import_names = next(
                    (names for names in stmt.names if name in names), None
                )
            else:
                import_names = stmt.names[0]
            if import_names:
                qname, asname = import_names
                name = asname or qname

        if _has_locals_call_after_node(stmt, node.scope()):
            message_name = "possibly-unused-variable"
        else:
            if isinstance(stmt, nodes.Import):
                if asname is not None:
                    msg = f"{qname} imported as {asname}"
                else:
                    msg = f"import {name}"
                self.add_message("unused-import", args=msg, node=stmt)
                return
            if isinstance(stmt, nodes.ImportFrom):
                if asname is not None:
                    msg = f"{qname} imported from {stmt.modname} as {asname}"
                else:
                    msg = f"{name} imported from {stmt.modname}"
                self.add_message("unused-import", args=msg, node=stmt)
                return
            message_name = "unused-variable"

        if isinstance(stmt, nodes.FunctionDef) and stmt.decorators:
            return

        # Don't check function stubs created only for type information
        if utils.is_overload_stub(node):
            return

        # Special case for exception variable
        if isinstance(stmt.parent, nodes.ExceptHandler) and any(
            n.name == name for n in stmt.parent.nodes_of_class(nodes.Name)
        ):
            return

        self.add_message(message_name, args=name, node=stmt)

</t>
<t tx="ekr.20220312061835.869">def _is_name_ignored(self, stmt, name):
    authorized_rgx = self.config.dummy_variables_rgx
    if (
        isinstance(stmt, nodes.AssignName)
        and isinstance(stmt.parent, nodes.Arguments)
        or isinstance(stmt, nodes.Arguments)
    ):
        regex = self.config.ignored_argument_names
    else:
        regex = authorized_rgx
    return regex and regex.match(name)

</t>
<t tx="ekr.20220312061835.87">def _too_many_starred_for_tuple(self, assign_tuple):
    starred_count = 0
    for elem in assign_tuple.itered():
        if isinstance(elem, nodes.Tuple):
            return self._too_many_starred_for_tuple(elem)
        if isinstance(elem, nodes.Starred):
            starred_count += 1
    return starred_count &gt; 1

</t>
<t tx="ekr.20220312061835.870">def _check_unused_arguments(self, name, node, stmt, argnames):
    is_method = node.is_method()
    klass = node.parent.frame()
    if is_method and isinstance(klass, nodes.ClassDef):
        confidence = (
            INFERENCE if utils.has_known_bases(klass) else INFERENCE_FAILURE
        )
    else:
        confidence = HIGH

    if is_method:
        # Don't warn for the first argument of a (non static) method
        if node.type != "staticmethod" and name == argnames[0]:
            return
        # Don't warn for argument of an overridden method
        overridden = overridden_method(klass, node.name)
        if overridden is not None and name in overridden.argnames():
            return
        if node.name in utils.PYMETHODS and node.name not in (
            "__init__",
            "__new__",
        ):
            return
    # Don't check callback arguments
    if any(
        node.name.startswith(cb) or node.name.endswith(cb)
        for cb in self.config.callbacks
    ):
        return
    # Don't check arguments of singledispatch.register function.
    if utils.is_registered_in_singledispatch_function(node):
        return

    # Don't check function stubs created only for type information
    if utils.is_overload_stub(node):
        return

    # Don't check protocol classes
    if utils.is_protocol_class(klass):
        return

    self.add_message("unused-argument", args=name, node=stmt, confidence=confidence)

</t>
<t tx="ekr.20220312061835.871">def _check_late_binding_closure(self, node: nodes.Name) -&gt; None:
    """Check whether node is a cell var that is assigned within a containing loop.

    Special cases where we don't care about the error:
    1. When the node's function is immediately called, e.g. (lambda: i)()
    2. When the node's function is returned from within the loop, e.g. return lambda: i
    """
    if not self.linter.is_message_enabled("cell-var-from-loop"):
        return

    node_scope = node.frame()

    # If node appears in a default argument expression,
    # look at the next enclosing frame instead
    if utils.is_default_argument(node, node_scope):
        node_scope = node_scope.parent.frame()

    # Check if node is a cell var
    if (
        not isinstance(node_scope, (nodes.Lambda, nodes.FunctionDef))
        or node.name in node_scope.locals
    ):
        return

    assign_scope, stmts = node.lookup(node.name)
    if not stmts or not assign_scope.parent_of(node_scope):
        return

    if utils.is_comprehension(assign_scope):
        self.add_message("cell-var-from-loop", node=node, args=node.name)
    else:
        # Look for an enclosing For loop.
        # Currently, we only consider the first assignment
        assignment_node = stmts[0]

        maybe_for = assignment_node
        while maybe_for and not isinstance(maybe_for, nodes.For):
            if maybe_for is assign_scope:
                break
            maybe_for = maybe_for.parent
        else:
            if (
                maybe_for
                and maybe_for.parent_of(node_scope)
                and not utils.is_being_called(node_scope)
                and not isinstance(node_scope.statement(), nodes.Return)
            ):
                self.add_message("cell-var-from-loop", node=node, args=node.name)

</t>
<t tx="ekr.20220312061835.872">def _should_ignore_redefined_builtin(self, stmt):
    if not isinstance(stmt, nodes.ImportFrom):
        return False
    return stmt.modname in self.config.redefining_builtins_modules

</t>
<t tx="ekr.20220312061835.873">def _allowed_redefined_builtin(self, name):
    return name in self.config.allowed_redefined_builtins

</t>
<t tx="ekr.20220312061835.874">def _has_homonym_in_upper_function_scope(self, node, index):
    """
    Return True if there is a node with the same name in the to_consume dict of an upper scope
    and if that scope is a function

    :param node: node to check for
    :type node: astroid.Node
    :param index: index of the current consumer inside self._to_consume
    :type index: int
    :return: True if there is a node with the same name in the to_consume dict of an upper scope
             and if that scope is a function
    :rtype: bool
    """
    for _consumer in self._to_consume[index - 1 :: -1]:
        if _consumer.scope_type == "function" and node.name in _consumer.to_consume:
            return True
    return False

</t>
<t tx="ekr.20220312061835.875">def _store_type_annotation_node(self, type_annotation):
    """Given a type annotation, store all the name nodes it refers to"""
    if isinstance(type_annotation, nodes.Name):
        self._type_annotation_names.append(type_annotation.name)
        return

    if isinstance(type_annotation, nodes.Attribute):
        self._store_type_annotation_node(type_annotation.expr)
        return

    if not isinstance(type_annotation, nodes.Subscript):
        return

    if (
        isinstance(type_annotation.value, nodes.Attribute)
        and isinstance(type_annotation.value.expr, nodes.Name)
        and type_annotation.value.expr.name == TYPING_MODULE
    ):
        self._type_annotation_names.append(TYPING_MODULE)
        return

    self._type_annotation_names.extend(
        annotation.name for annotation in type_annotation.nodes_of_class(nodes.Name)
    )

</t>
<t tx="ekr.20220312061835.876">def _store_type_annotation_names(self, node):
    type_annotation = node.type_annotation
    if not type_annotation:
        return
    self._store_type_annotation_node(node.type_annotation)

</t>
<t tx="ekr.20220312061835.877">def _check_self_cls_assign(self, node):
    """Check that self/cls don't get assigned"""
    assign_names = {
        target.name
        for target in node.targets
        if isinstance(target, nodes.AssignName)
    }
    scope = node.scope()
    nonlocals_with_same_name = any(
        child
        for child in scope.body
        if isinstance(child, nodes.Nonlocal) and assign_names &amp; set(child.names)
    )
    if nonlocals_with_same_name:
        scope = node.scope().parent.scope()

    if not (
        isinstance(scope, nodes.FunctionDef)
        and scope.is_method()
        and "builtins.staticmethod" not in scope.decoratornames()
    ):
        return
    argument_names = scope.argnames()
    if not argument_names:
        return
    self_cls_name = argument_names[0]
    target_assign_names = (
        target.name
        for target in node.targets
        if isinstance(target, nodes.AssignName)
    )
    if self_cls_name in target_assign_names:
        self.add_message("self-cls-assignment", node=node, args=(self_cls_name,))

</t>
<t tx="ekr.20220312061835.878">def _check_unpacking(self, inferred, node, targets):
    """Check for unbalanced tuple unpacking
    and unpacking non sequences.
    """
    if utils.is_inside_abstract_class(node):
        return
    if utils.is_comprehension(node):
        return
    if inferred is astroid.Uninferable:
        return
    if (
        isinstance(inferred.parent, nodes.Arguments)
        and isinstance(node.value, nodes.Name)
        and node.value.name == inferred.parent.vararg
    ):
        # Variable-length argument, we can't determine the length.
        return
    if isinstance(inferred, (nodes.Tuple, nodes.List)):
        # attempt to check unpacking is properly balanced
        values = inferred.itered()
        if len(targets) != len(values):
            # Check if we have starred nodes.
            if any(isinstance(target, nodes.Starred) for target in targets):
                return
            self.add_message(
                "unbalanced-tuple-unpacking",
                node=node,
                args=(
                    _get_unpacking_extra_info(node, inferred),
                    len(targets),
                    len(values),
                ),
            )
    # attempt to check unpacking may be possible (ie RHS is iterable)
    elif not utils.is_iterable(inferred):
        self.add_message(
            "unpacking-non-sequence",
            node=node,
            args=(_get_unpacking_extra_info(node, inferred),),
        )

</t>
<t tx="ekr.20220312061835.879">def _check_module_attrs(self, node, module, module_names):
    """check that module_names (list of string) are accessible through the
    given module
    if the latest access name corresponds to a module, return it
    """
    while module_names:
        name = module_names.pop(0)
        if name == "__dict__":
            module = None
            break
        try:
            module = next(module.getattr(name)[0].infer())
            if module is astroid.Uninferable:
                return None
        except astroid.NotFoundError:
            if module.name in self._ignored_modules:
                return None
            self.add_message(
                "no-name-in-module", args=(name, module.name), node=node
            )
            return None
        except astroid.InferenceError:
            return None
    if module_names:
        modname = module.name if module else "__dict__"
        self.add_message(
            "no-name-in-module", node=node, args=(".".join(module_names), modname)
        )
        return None
    if isinstance(module, nodes.Module):
        return module
    return None

</t>
<t tx="ekr.20220312061835.88">@utils.check_messages("too-many-star-expressions", "invalid-star-assignment-target")
def visit_assign(self, node: nodes.Assign) -&gt; None:
    # Check *a, *b = ...
    assign_target = node.targets[0]
    # Check *a = b
    if isinstance(node.targets[0], nodes.Starred):
        self.add_message("invalid-star-assignment-target", node=node)

    if not isinstance(assign_target, nodes.Tuple):
        return
    if self._too_many_starred_for_tuple(assign_target):
        self.add_message("too-many-star-expressions", node=node)

</t>
<t tx="ekr.20220312061835.880">def _check_all(self, node: nodes.Module, not_consumed):
    assigned = next(node.igetattr("__all__"))
    if assigned is astroid.Uninferable:
        return
    if not assigned.pytype() in ["builtins.list", "builtins.tuple"]:
        line, col = assigned.tolineno, assigned.col_offset
        self.add_message("invalid-all-format", line=line, col_offset=col, node=node)
        return
    for elt in getattr(assigned, "elts", ()):
        try:
            elt_name = next(elt.infer())
        except astroid.InferenceError:
            continue
        if elt_name is astroid.Uninferable:
            continue
        if not elt_name.parent:
            continue

        if not isinstance(elt_name, nodes.Const) or not isinstance(
            elt_name.value, str
        ):
            self.add_message("invalid-all-object", args=elt.as_string(), node=elt)
            continue

        elt_name = elt_name.value
        # If elt is in not_consumed, remove it from not_consumed
        if elt_name in not_consumed:
            del not_consumed[elt_name]
            continue

        if elt_name not in node.locals:
            if not node.package:
                self.add_message(
                    "undefined-all-variable", args=(elt_name,), node=elt
                )
            else:
                basename = os.path.splitext(node.file)[0]
                if os.path.basename(basename) == "__init__":
                    name = node.name + "." + elt_name
                    try:
                        astroid.modutils.file_from_modpath(name.split("."))
                    except ImportError:
                        self.add_message(
                            "undefined-all-variable", args=(elt_name,), node=elt
                        )
                    except SyntaxError:
                        # don't yield a syntax-error warning,
                        # because it will be later yielded
                        # when the file will be checked
                        pass

</t>
<t tx="ekr.20220312061835.881">def _check_globals(self, not_consumed):
    if self._allow_global_unused_variables:
        return
    for name, node_lst in not_consumed.items():
        for node in node_lst:
            self.add_message("unused-variable", args=(name,), node=node)

</t>
<t tx="ekr.20220312061835.882">def _check_imports(self, not_consumed):
    local_names = _fix_dot_imports(not_consumed)
    checked = set()
    for name, stmt in local_names:
        for imports in stmt.names:
            real_name = imported_name = imports[0]
            if imported_name == "*":
                real_name = name
            as_name = imports[1]
            if real_name in checked:
                continue
            if name not in (real_name, as_name):
                continue
            checked.add(real_name)

            is_type_annotation_import = (
                imported_name in self._type_annotation_names
                or as_name in self._type_annotation_names
            )
            if isinstance(stmt, nodes.Import) or (
                isinstance(stmt, nodes.ImportFrom) and not stmt.modname
            ):
                if isinstance(stmt, nodes.ImportFrom) and SPECIAL_OBJ.search(
                    imported_name
                ):
                    # Filter special objects (__doc__, __all__) etc.,
                    # because they can be imported for exporting.
                    continue

                if is_type_annotation_import:
                    # Most likely a typing import if it wasn't used so far.
                    continue

                if as_name == "_":
                    continue
                if as_name is None:
                    msg = f"import {imported_name}"
                else:
                    msg = f"{imported_name} imported as {as_name}"
                if not _is_type_checking_import(stmt):
                    self.add_message("unused-import", args=msg, node=stmt)
            elif isinstance(stmt, nodes.ImportFrom) and stmt.modname != FUTURE:
                if SPECIAL_OBJ.search(imported_name):
                    # Filter special objects (__doc__, __all__) etc.,
                    # because they can be imported for exporting.
                    continue

                if _is_from_future_import(stmt, name):
                    # Check if the name is in fact loaded from a
                    # __future__ import in another module.
                    continue

                if is_type_annotation_import:
                    # Most likely a typing import if it wasn't used so far.
                    continue

                if imported_name == "*":
                    self.add_message("unused-wildcard-import", args=name, node=stmt)
                else:
                    if as_name is None:
                        msg = f"{imported_name} imported from {stmt.modname}"
                    else:
                        msg = f"{imported_name} imported from {stmt.modname} as {as_name}"
                    if not _is_type_checking_import(stmt):
                        self.add_message("unused-import", args=msg, node=stmt)
    del self._to_consume

</t>
<t tx="ekr.20220312061835.883">def _check_metaclasses(self, node):
    """Update consumption analysis for metaclasses."""
    consumed = []  # [(scope_locals, consumed_key)]

    for child_node in node.get_children():
        if isinstance(child_node, nodes.ClassDef):
            consumed.extend(self._check_classdef_metaclasses(child_node, node))

    # Pop the consumed items, in order to avoid having
    # unused-import and unused-variable false positives
    for scope_locals, name in consumed:
        scope_locals.pop(name, None)

</t>
<t tx="ekr.20220312061835.884">def _check_classdef_metaclasses(self, klass, parent_node):
    if not klass._metaclass:
        # Skip if this class doesn't use explicitly a metaclass, but inherits it from ancestors
        return []

    consumed = []  # [(scope_locals, consumed_key)]
    metaclass = klass.metaclass()
    name = None
    if isinstance(klass._metaclass, nodes.Name):
        name = klass._metaclass.name
    elif isinstance(klass._metaclass, nodes.Attribute) and klass._metaclass.expr:
        attr = klass._metaclass.expr
        while not isinstance(attr, nodes.Name):
            attr = attr.expr
        name = attr.name
    elif metaclass:
        name = metaclass.root().name

    found = None
    name = METACLASS_NAME_TRANSFORMS.get(name, name)
    if name:
        # check enclosing scopes starting from most local
        for scope_locals, _, _ in self._to_consume[::-1]:
            found = scope_locals.get(name)
            if found:
                consumed.append((scope_locals, name))
                break
    if (
        found is None
        and not metaclass
        and not (
            name in nodes.Module.scope_attrs
            or utils.is_builtin(name)
            or name in self.config.additional_builtins
            or name in parent_node.locals
        )
    ):
        self.add_message("undefined-variable", node=klass, args=(name,))

    return consumed


</t>
<t tx="ekr.20220312061835.885">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(VariablesChecker(linter))
</t>
<t tx="ekr.20220312061835.886">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/
@language python
@tabwidth -4
# Copyright (c) 2006-2014 LOGILAB S.A. (Paris, FRANCE) &lt;contact@logilab.fr&gt;
# Copyright (c) 2013-2014 Google, Inc.
# Copyright (c) 2013 buck@yelp.com &lt;buck@yelp.com&gt;
# Copyright (c) 2014-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2014 Brett Cannon &lt;brett@python.org&gt;
# Copyright (c) 2014 Arun Persaud &lt;arun@nubati.net&gt;
# Copyright (c) 2015 Ionel Cristian Maries &lt;contact@ionelmc.ro&gt;
# Copyright (c) 2016 Moises Lopez &lt;moylop260@vauxoo.com&gt;
# Copyright (c) 2017-2018 Bryce Guinta &lt;bryce.paul.guinta@gmail.com&gt;
# Copyright (c) 2018-2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2018 ssolanki &lt;sushobhitsolanki@gmail.com&gt;
# Copyright (c) 2019 Bruno P. Kinoshita &lt;kinow@users.noreply.github.com&gt;
# Copyright (c) 2020-2021 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Frank Harrison &lt;frank@doublethefish.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Copyright (c) 2021 Matus Valo &lt;matusvalo@users.noreply.github.com&gt;

# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""utilities methods and classes for checkers

Base id of standard checkers (used in msg and report ids):
01: base
02: classes
03: format
04: import
05: misc
06: variables
07: exceptions
08: similar
09: design_analysis
10: newstyle
11: typecheck
12: logging
13: string_format
14: string_constant
15: stdlib
16: python3
17: refactoring
18-50: not yet used: reserved for future internal checkers.
51-99: perhaps used: reserved for external checkers

The raw_metrics checker has no number associated since it doesn't emit any
messages nor reports. XXX not true, emit a 07 report !

"""

from typing import Iterable, List, Union

from pylint.checkers.base_checker import BaseChecker, BaseTokenChecker
from pylint.checkers.deprecated import DeprecatedMixin
from pylint.checkers.mapreduce_checker import MapReduceMixin
from pylint.typing import CheckerStats
from pylint.utils import diff_string, register_plugins


@others
__all__ = [
    "BaseChecker",
    "BaseTokenChecker",
    "initialize",
    "MapReduceMixin",
    "DeprecatedMixin",
    "register_plugins",
]
</t>
<t tx="ekr.20220312061835.887">def table_lines_from_stats(
    stats: CheckerStats,
    old_stats: CheckerStats,
    columns: Iterable[str],
) -&gt; List[str]:
    """get values listed in &lt;columns&gt; from &lt;stats&gt; and &lt;old_stats&gt;,
    and return a formatted list of values, designed to be given to a
    ureport.Table object
    """
    lines: List[str] = []
    for m_type in columns:
        new: Union[int, str] = stats[m_type]  # type: ignore
        old: Union[int, str, None] = old_stats.get(m_type)  # type: ignore
        if old is not None:
            diff_str = diff_string(old, new)
        else:
            old, diff_str = "NC", "NC"
        new = f"{new:.3f}" if isinstance(new, float) else str(new)
        old = f"{old:.3f}" if isinstance(old, float) else str(old)
        lines.extend((m_type.replace("_", " "), new, old, diff_str))
    return lines


</t>
<t tx="ekr.20220312061835.888">def initialize(linter):
    """initialize linter with checkers in this package"""
    register_plugins(linter, __path__[0])


</t>
<t tx="ekr.20220312061835.889"></t>
<t tx="ekr.20220312061835.89">@utils.check_messages("star-needs-assignment-target")
def visit_starred(self, node: nodes.Starred) -&gt; None:
    """Check that a Starred expression is used in an assignment target."""
    if isinstance(node.parent, nodes.Call):
        # f(*args) is converted to Call(args=[Starred]), so ignore
        # them for this check.
        return
    if isinstance(node.parent, (nodes.List, nodes.Tuple, nodes.Set, nodes.Dict)):
        # PEP 448 unpacking.
        return

    stmt = node.statement()
    if not isinstance(stmt, nodes.Assign):
        return

    if stmt.value is node or stmt.value.parent_of(node):
        self.add_message("star-needs-assignment-target", node=node)

</t>
<t tx="ekr.20220312061835.890">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/refactoring/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import List

import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.891">class LenChecker(checkers.BaseChecker):
    """Checks for incorrect usage of len() inside conditions.
    Pep8 states:
    For sequences, (strings, lists, tuples), use the fact that empty sequences are false.

        Yes: if not seq:
             if seq:

        No: if len(seq):
            if not len(seq):

    Problems detected:
    * if len(sequence):
    * if not len(sequence):
    * elif len(sequence):
    * elif not len(sequence):
    * while len(sequence):
    * while not len(sequence):
    * assert len(sequence):
    * assert not len(sequence):
    * bool(len(sequence))
    """

    __implements__ = (interfaces.IAstroidChecker,)

    # configuration section name
    name = "refactoring"
    msgs = {
        "C1801": (
            "Do not use `len(SEQUENCE)` without comparison to determine if a sequence is empty",
            "len-as-condition",
            "Used when Pylint detects that len(sequence) is being used "
            "without explicit comparison inside a condition to determine if a sequence is empty. "
            "Instead of coercing the length to a boolean, either "
            "rely on the fact that empty sequences are false or "
            "compare the length against a scalar.",
        )
    }

    priority = -2
    options = ()

    @others
</t>
<t tx="ekr.20220312061835.892">@utils.check_messages("len-as-condition")
def visit_call(self, node: nodes.Call) -&gt; None:
    # a len(S) call is used inside a test condition
    # could be if, while, assert or if expression statement
    # e.g. `if len(S):`
    if not utils.is_call_of_name(node, "len"):
        return
    # the len() call could also be nested together with other
    # boolean operations, e.g. `if z or len(x):`
    parent = node.parent
    while isinstance(parent, nodes.BoolOp):
        parent = parent.parent
    # we're finally out of any nested boolean operations so check if
    # this len() call is part of a test condition
    if not utils.is_test_condition(node, parent):
        return
    len_arg = node.args[0]
    generator_or_comprehension = (
        nodes.ListComp,
        nodes.SetComp,
        nodes.DictComp,
        nodes.GeneratorExp,
    )
    if isinstance(len_arg, generator_or_comprehension):
        # The node is a generator or comprehension as in len([x for x in ...])
        self.add_message("len-as-condition", node=node)
        return
    try:
        instance = next(len_arg.infer())
    except astroid.InferenceError:
        # Probably undefined-variable, abort check
        return
    mother_classes = self.base_classes_of_node(instance)
    affected_by_pep8 = any(
        t in mother_classes for t in ("str", "tuple", "list", "set")
    )
    if "range" in mother_classes or (
        affected_by_pep8 and not self.instance_has_bool(instance)
    ):
        self.add_message("len-as-condition", node=node)

</t>
<t tx="ekr.20220312061835.893">@staticmethod
def instance_has_bool(class_def: nodes.ClassDef) -&gt; bool:
    try:
        class_def.getattr("__bool__")
        return True
    except astroid.AttributeInferenceError:
        ...
    return False

</t>
<t tx="ekr.20220312061835.894">@utils.check_messages("len-as-condition")
def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:
    """`not len(S)` must become `not S` regardless if the parent block
    is a test condition or something else (boolean expression)
    e.g. `if not len(S):`"""
    if (
        isinstance(node, nodes.UnaryOp)
        and node.op == "not"
        and utils.is_call_of_name(node.operand, "len")
    ):
        self.add_message("len-as-condition", node=node)

</t>
<t tx="ekr.20220312061835.895">@staticmethod
def base_classes_of_node(instance: nodes.ClassDef) -&gt; List[nodes.Name]:
    """Return all the classes names that a ClassDef inherit from including 'object'."""
    try:
        return [instance.name] + [x.name for x in instance.ancestors()]
    except TypeError:
        return [instance.name]
</t>
<t tx="ekr.20220312061835.896">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/refactoring/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE


import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.897">class NotChecker(checkers.BaseChecker):
    """checks for too many not in comparison expressions

    - "not not" should trigger a warning
    - "not" followed by a comparison should trigger a warning
    """

    __implements__ = (interfaces.IAstroidChecker,)
    msgs = {
        "C0113": (
            'Consider changing "%s" to "%s"',
            "unneeded-not",
            "Used when a boolean expression contains an unneeded negation.",
        )
    }
    name = "refactoring"
    reverse_op = {
        "&lt;": "&gt;=",
        "&lt;=": "&gt;",
        "&gt;": "&lt;=",
        "&gt;=": "&lt;",
        "==": "!=",
        "!=": "==",
        "in": "not in",
        "is": "is not",
    }
    # sets are not ordered, so for example "not set(LEFT_VALS) &lt;= set(RIGHT_VALS)" is
    # not equivalent to "set(LEFT_VALS) &gt; set(RIGHT_VALS)"
    skipped_nodes = (nodes.Set,)
    # 'builtins' py3, '__builtin__' py2
    skipped_classnames = [f"builtins.{qname}" for qname in ("set", "frozenset")]

    @others
</t>
<t tx="ekr.20220312061835.898">@utils.check_messages("unneeded-not")
def visit_unaryop(self, node: nodes.UnaryOp) -&gt; None:
    if node.op != "not":
        return
    operand = node.operand

    if isinstance(operand, nodes.UnaryOp) and operand.op == "not":
        self.add_message(
            "unneeded-not",
            node=node,
            args=(node.as_string(), operand.operand.as_string()),
        )
    elif isinstance(operand, nodes.Compare):
        left = operand.left
        # ignore multiple comparisons
        if len(operand.ops) &gt; 1:
            return
        operator, right = operand.ops[0]
        if operator not in self.reverse_op:
            return
        # Ignore __ne__ as function of __eq__
        frame = node.frame()
        if frame.name == "__ne__" and operator == "==":
            return
        for _type in (utils.node_type(left), utils.node_type(right)):
            if not _type:
                return
            if isinstance(_type, self.skipped_nodes):
                return
            if (
                isinstance(_type, astroid.Instance)
                and _type.qname() in self.skipped_classnames
            ):
                return
        suggestion = (
            f"{left.as_string()} {self.reverse_op[operator]} {right.as_string()}"
        )
        self.add_message(
            "unneeded-not", node=node, args=(node.as_string(), suggestion)
        )
</t>
<t tx="ekr.20220312061835.899">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/refactoring/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE
from typing import Union

import astroid
from astroid import nodes

from pylint import checkers, interfaces
from pylint.checkers import utils


@others
</t>
<t tx="ekr.20220312061835.9">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/
@language python
@tabwidth -4
# Copyright (c) 2016-2018, 2020 Claudiu Popa &lt;pcmanticore@gmail.com&gt;
# Copyright (c) 2016 Glenn Matthews &lt;glenn@e-dad.net&gt;
# Copyright (c) 2017 ukasz Rogalski &lt;rogalski.91@gmail.com&gt;
# Copyright (c) 2018 Ville Skytt &lt;ville.skytta@iki.fi&gt;
# Copyright (c) 2019 Thomas Hisch &lt;t.hisch@gmail.com&gt;
# Copyright (c) 2020 hippo91 &lt;guillaume.peillex@gmail.com&gt;
# Copyright (c) 2020 Anthony Sottile &lt;asottile@umich.edu&gt;
# Copyright (c) 2021 Ashley Whetter &lt;ashley@awhetter.co.uk&gt;
# Copyright (c) 2021 Pierre Sassoulas &lt;pierre.sassoulas@gmail.com&gt;
# Copyright (c) 2021 Danil van Noord &lt;13665637+DanielNoord@users.noreply.github.com&gt;
# Copyright (c) 2021 Marc Mueller &lt;30130371+cdce8p@users.noreply.github.com&gt;
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

"""Exception classes raised by various operations within pylint."""


@others
</t>
<t tx="ekr.20220312061835.90">@utils.check_messages(
    "init-is-generator",
    "return-in-init",
    "function-redefined",
    "return-arg-in-generator",
    "duplicate-argument-name",
    "nonlocal-and-global",
    "used-prior-global-declaration",
)
</t>
<t tx="ekr.20220312061835.900">class RecommendationChecker(checkers.BaseChecker):

    __implements__ = (interfaces.IAstroidChecker,)
    name = "refactoring"
    msgs = {
        "C0200": (
            "Consider using enumerate instead of iterating with range and len",
            "consider-using-enumerate",
            "Emitted when code that iterates with range and len is "
            "encountered. Such code can be simplified by using the "
            "enumerate builtin.",
        ),
        "C0201": (
            "Consider iterating the dictionary directly instead of calling .keys()",
            "consider-iterating-dictionary",
            "Emitted when the keys of a dictionary are iterated through the ``.keys()`` "
            "method or when ``.keys()`` is used for a membership check. "
            "It is enough to iterate through the dictionary itself, "
            "``for key in dictionary``. For membership checks, "
            "``if key in dictionary`` is faster.",
        ),
        "C0206": (
            "Consider iterating with .items()",
            "consider-using-dict-items",
            "Emitted when iterating over the keys of a dictionary and accessing the "
            "value by index lookup. "
            "Both the key and value can be accessed by iterating using the .items() "
            "method of the dictionary instead.",
        ),
        "C0207": (
            "Use %s instead",
            "use-maxsplit-arg",
            "Emitted when accessing only the first or last element of str.split(). "
            "The first and last element can be accessed by using "
            "str.split(sep, maxsplit=1)[0] or str.rsplit(sep, maxsplit=1)[-1] "
            "instead.",
        ),
        "C0208": (
            "Use a sequence type when iterating over values",
            "use-sequence-for-iteration",
            "When iterating over values, sequence types (e.g., ``lists``, ``tuples``, ``ranges``) "
            "are more efficient than ``sets``.",
        ),
        "C0209": (
            "Formatting a regular string which could be a f-string",
            "consider-using-f-string",
            "Used when we detect a string that is being formatted with format() or % "
            "which could potentially be a f-string. The use of f-strings is preferred.",
        ),
    }

    @others
</t>
<t tx="ekr.20220312061835.901">@staticmethod
def _is_builtin(node, function):
    inferred = utils.safe_infer(node)
    if not inferred:
        return False
    return utils.is_builtin_object(inferred) and inferred.name == function

</t>
<t tx="ekr.20220312061835.902">@utils.check_messages("consider-iterating-dictionary", "use-maxsplit-arg")
def visit_call(self, node: nodes.Call) -&gt; None:
    self._check_consider_iterating_dictionary(node)
    self._check_use_maxsplit_arg(node)

</t>
<t tx="ekr.20220312061835.903">def _check_consider_iterating_dictionary(self, node: nodes.Call) -&gt; None:
    if not isinstance(node.func, nodes.Attribute):
        return
    if node.func.attrname != "keys":
        return
    if (
        isinstance(node.parent, (nodes.For, nodes.Comprehension))
        or isinstance(node.parent, nodes.Compare)
        and any(
            op
            for op, comparator in node.parent.ops
            if op == "in" and comparator is node
        )
    ):
        inferred = utils.safe_infer(node.func)
        if not isinstance(inferred, astroid.BoundMethod) or not isinstance(
            inferred.bound, nodes.Dict
        ):
            return

        self.add_message("consider-iterating-dictionary", node=node)

</t>
<t tx="ekr.20220312061835.904">def _check_use_maxsplit_arg(self, node: nodes.Call) -&gt; None:
    """Add message when accessing first or last elements of a str.split() or str.rsplit()."""

    # Check if call is split() or rsplit()
    if not (
        isinstance(node.func, nodes.Attribute)
        and node.func.attrname in ("split", "rsplit")
        and isinstance(utils.safe_infer(node.func), astroid.BoundMethod)
    ):
        return

    try:
        utils.get_argument_from_call(node, 0, "sep")
    except utils.NoSuchArgumentError:
        return

    try:
        # Ignore if maxsplit arg has been set
        utils.get_argument_from_call(node, 1, "maxsplit")
        return
    except utils.NoSuchArgumentError:
        pass

    if isinstance(node.parent, nodes.Subscript):
        try:
            subscript_value = utils.get_subscript_const_value(node.parent).value
        except utils.InferredTypeError:
            return

        # Check for cases where variable (Name) subscripts may be mutated within a loop
        if isinstance(node.parent.slice, nodes.Name):
            # Check if loop present within the scope of the node
            scope = node.scope()
            for loop_node in scope.nodes_of_class((nodes.For, nodes.While)):
                if not loop_node.parent_of(node):
                    continue

                # Check if var is mutated within loop (Assign/AugAssign)
                for assignment_node in loop_node.nodes_of_class(nodes.AugAssign):
                    if node.parent.slice.name == assignment_node.target.name:
                        return
                for assignment_node in loop_node.nodes_of_class(nodes.Assign):
                    if node.parent.slice.name in [
                        n.name for n in assignment_node.targets
                    ]:
                        return

        if subscript_value in (-1, 0):
            fn_name = node.func.attrname
            new_fn = "rsplit" if subscript_value == -1 else "split"
            new_name = (
                node.func.as_string().rsplit(fn_name, maxsplit=1)[0]
                + new_fn
                + f"({node.args[0].as_string()}, maxsplit=1)[{subscript_value}]"
            )
            self.add_message("use-maxsplit-arg", node=node, args=(new_name,))

</t>
<t tx="ekr.20220312061835.905">@utils.check_messages(
    "consider-using-enumerate",
    "consider-using-dict-items",
    "use-sequence-for-iteration",
)
</t>
<t tx="ekr.20220312061835.906">def visit_for(self, node: nodes.For) -&gt; None:
    self._check_consider_using_enumerate(node)
    self._check_consider_using_dict_items(node)
    self._check_use_sequence_for_iteration(node)

</t>
<t tx="ekr.20220312061835.907">def _check_consider_using_enumerate(self, node: nodes.For) -&gt; None:
    """Emit a convention whenever range and len are used for indexing."""
    # Verify that we have a `range([start], len(...), [stop])` call and
    # that the object which is iterated is used as a subscript in the
    # body of the for.

    # Is it a proper range call?
    if not isinstance(node.iter, nodes.Call):
        return
    if not self._is_builtin(node.iter.func, "range"):
        return
    if not node.iter.args:
        return
    is_constant_zero = (
        isinstance(node.iter.args[0], nodes.Const) and node.iter.args[0].value == 0
    )
    if len(node.iter.args) == 2 and not is_constant_zero:
        return
    if len(node.iter.args) &gt; 2:
        return

    # Is it a proper len call?
    if not isinstance(node.iter.args[-1], nodes.Call):
        return
    second_func = node.iter.args[-1].func
    if not self._is_builtin(second_func, "len"):
        return
    len_args = node.iter.args[-1].args
    if not len_args or len(len_args) != 1:
        return
    iterating_object = len_args[0]
    if isinstance(iterating_object, nodes.Name):
        expected_subscript_val_type = nodes.Name
    elif isinstance(iterating_object, nodes.Attribute):
        expected_subscript_val_type = nodes.Attribute
    else:
        return
    # If we're defining __iter__ on self, enumerate won't work
    scope = node.scope()
    if (
        isinstance(iterating_object, nodes.Name)
        and iterating_object.name == "self"
        and scope.name == "__iter__"
    ):
        return

    # Verify that the body of the for loop uses a subscript
    # with the object that was iterated. This uses some heuristics
    # in order to make sure that the same object is used in the
    # for body.
    for child in node.body:
        for subscript in child.nodes_of_class(nodes.Subscript):
            if not isinstance(subscript.value, expected_subscript_val_type):
                continue

            value = subscript.slice
            if not isinstance(value, nodes.Name):
                continue
            if subscript.value.scope() != node.scope():
                # Ignore this subscript if it's not in the same
                # scope. This means that in the body of the for
                # loop, another scope was created, where the same
                # name for the iterating object was used.
                continue
            if value.name == node.target.name and (
                isinstance(subscript.value, nodes.Name)
                and iterating_object.name == subscript.value.name
                or isinstance(subscript.value, nodes.Attribute)
                and iterating_object.attrname == subscript.value.attrname
            ):
                self.add_message("consider-using-enumerate", node=node)
                return

</t>
<t tx="ekr.20220312061835.908">def _check_consider_using_dict_items(self, node: nodes.For) -&gt; None:
    """Add message when accessing dict values by index lookup."""
    # Verify that we have a .keys() call and
    # that the object which is iterated is used as a subscript in the
    # body of the for.

    iterating_object_name = utils.get_iterating_dictionary_name(node)
    if iterating_object_name is None:
        return

    # Verify that the body of the for loop uses a subscript
    # with the object that was iterated. This uses some heuristics
    # in order to make sure that the same object is used in the
    # for body.
    for child in node.body:
        for subscript in child.nodes_of_class(nodes.Subscript):
            if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):
                continue

            value = subscript.slice
            if (
                not isinstance(value, nodes.Name)
                or value.name != node.target.name
                or iterating_object_name != subscript.value.as_string()
            ):
                continue
            last_definition_lineno = value.lookup(value.name)[1][-1].lineno
            if last_definition_lineno &gt; node.lineno:
                # Ignore this subscript if it has been redefined after
                # the for loop. This checks for the line number using .lookup()
                # to get the line number where the iterating object was last
                # defined and compare that to the for loop's line number
                continue
            if (
                isinstance(subscript.parent, nodes.Assign)
                and subscript in subscript.parent.targets
                or isinstance(subscript.parent, nodes.AugAssign)
                and subscript == subscript.parent.target
            ):
                # Ignore this subscript if it is the target of an assignment
                # Early termination as dict index lookup is necessary
                return

            self.add_message("consider-using-dict-items", node=node)
            return

</t>
<t tx="ekr.20220312061835.909">@utils.check_messages(
    "consider-using-dict-items",
    "use-sequence-for-iteration",
)
</t>
<t tx="ekr.20220312061835.91">def visit_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    self._check_nonlocal_and_global(node)
    self._check_name_used_prior_global(node)
    if not redefined_by_decorator(
        node
    ) and not utils.is_registered_in_singledispatch_function(node):
        self._check_redefinition(node.is_method() and "method" or "function", node)
    # checks for max returns, branch, return in __init__
    returns = node.nodes_of_class(
        nodes.Return, skip_klass=(nodes.FunctionDef, nodes.ClassDef)
    )
    if node.is_method() and node.name == "__init__":
        if node.is_generator():
            self.add_message("init-is-generator", node=node)
        else:
            values = [r.value for r in returns]
            # Are we returning anything but None from constructors
            if any(v for v in values if not utils.is_none(v)):
                self.add_message("return-in-init", node=node)
    # Check for duplicate names by clustering args with same name for detailed report
    arg_clusters = collections.defaultdict(list)
    arguments: Iterator[Any] = filter(None, [node.args.args, node.args.kwonlyargs])

    for arg in itertools.chain.from_iterable(arguments):
        arg_clusters[arg.name].append(arg)

    # provide detailed report about each repeated argument
    for argument_duplicates in arg_clusters.values():
        if len(argument_duplicates) != 1:
            for argument in argument_duplicates:
                self.add_message(
                    "duplicate-argument-name",
                    line=argument.lineno,
                    node=argument,
                    args=(argument.name,),
                )

</t>
<t tx="ekr.20220312061835.910">def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:
    self._check_consider_using_dict_items_comprehension(node)
    self._check_use_sequence_for_iteration(node)

</t>
<t tx="ekr.20220312061835.911">def _check_consider_using_dict_items_comprehension(
    self, node: nodes.Comprehension
) -&gt; None:
    """Add message when accessing dict values by index lookup."""
    iterating_object_name = utils.get_iterating_dictionary_name(node)
    if iterating_object_name is None:
        return

    for child in node.parent.get_children():
        for subscript in child.nodes_of_class(nodes.Subscript):
            if not isinstance(subscript.value, (nodes.Name, nodes.Attribute)):
                continue

            value = subscript.slice
            if (
                not isinstance(value, nodes.Name)
                or value.name != node.target.name
                or iterating_object_name != subscript.value.as_string()
            ):
                continue

            self.add_message("consider-using-dict-items", node=node)
            return

</t>
<t tx="ekr.20220312061835.912">def _check_use_sequence_for_iteration(
    self, node: Union[nodes.For, nodes.Comprehension]
) -&gt; None:
    """Check if code iterates over an in-place defined set."""
    if isinstance(node.iter, nodes.Set):
        self.add_message("use-sequence-for-iteration", node=node.iter)

</t>
<t tx="ekr.20220312061835.913">@utils.check_messages("consider-using-f-string")
def visit_const(self, node: nodes.Const) -&gt; None:
    if node.pytype() == "builtins.str" and not isinstance(
        node.parent, nodes.JoinedStr
    ):
        self._detect_replacable_format_call(node)

</t>
<t tx="ekr.20220312061835.914">def _detect_replacable_format_call(self, node: nodes.Const) -&gt; None:
    """Check whether a string is used in a call to format() or '%' and whether it
    can be replaced by a f-string"""
    if (
        isinstance(node.parent, nodes.Attribute)
        and node.parent.attrname == "format"
    ):
        # Allow assigning .format to a variable
        if isinstance(node.parent.parent, nodes.Assign):
            return

        if node.parent.parent.args:
            for arg in node.parent.parent.args:
                # If star expressions with more than 1 element are being used
                if isinstance(arg, nodes.Starred):
                    inferred = utils.safe_infer(arg.value)
                    if (
                        isinstance(inferred, astroid.List)
                        and len(inferred.elts) &gt; 1
                    ):
                        return

        elif node.parent.parent.keywords:
            keyword_args = [
                i[0] for i in utils.parse_format_method_string(node.value)[0]
            ]
            for keyword in node.parent.parent.keywords:
                # If keyword is used multiple times
                if keyword_args.count(keyword.arg) &gt; 1:
                    return

                keyword = utils.safe_infer(keyword.value)

                # If lists of more than one element are being unpacked
                if isinstance(keyword, nodes.Dict):
                    if len(keyword.items) &gt; 1 and len(keyword_args) &gt; 1:
                        return

        # If all tests pass, then raise message
        self.add_message(
            "consider-using-f-string",
            node=node,
            line=node.lineno,
            col_offset=node.col_offset,
        )

    elif isinstance(node.parent, nodes.BinOp) and node.parent.op == "%":
        inferred_right = utils.safe_infer(node.parent.right)

        # If dicts or lists of length &gt; 1 are used
        if isinstance(inferred_right, nodes.Dict):
            if len(inferred_right.items) &gt; 1:
                return
        elif isinstance(inferred_right, nodes.List):
            if len(inferred_right.elts) &gt; 1:
                return

        # If all tests pass, then raise message
        self.add_message(
            "consider-using-f-string",
            node=node,
            line=node.lineno,
            col_offset=node.col_offset,
        )
</t>
<t tx="ekr.20220312061835.915">@path C:/Users/Edward Ream/Python/python39/Lib/site-packages/pylint/checkers/refactoring/
@language python
@tabwidth -4
# Licensed under the GPL: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
# For details: https://github.com/PyCQA/pylint/blob/main/LICENSE

import collections
import copy
import itertools
import tokenize
from functools import reduce
from typing import Dict, Iterator, List, NamedTuple, Optional, Tuple, Union

import astroid
from astroid import nodes
from astroid.util import Uninferable

from pylint import checkers, interfaces
from pylint import utils as lint_utils
from pylint.checkers import utils
from pylint.checkers.utils import node_frame_class

KNOWN_INFINITE_ITERATORS = {"itertools.count"}
BUILTIN_EXIT_FUNCS = frozenset(("quit", "exit"))
CALLS_THAT_COULD_BE_REPLACED_BY_WITH = frozenset(
    (
        "threading.lock.acquire",
        "threading._RLock.acquire",
        "threading.Semaphore.acquire",
        "multiprocessing.managers.BaseManager.start",
        "multiprocessing.managers.SyncManager.start",
    )
)
CALLS_RETURNING_CONTEXT_MANAGERS = frozenset(
    (
        "_io.open",  # regular 'open()' call
        "codecs.open",
        "urllib.request.urlopen",
        "tempfile.NamedTemporaryFile",
        "tempfile.SpooledTemporaryFile",
        "tempfile.TemporaryDirectory",
        "zipfile.ZipFile",
        "zipfile.PyZipFile",
        "zipfile.ZipFile.open",
        "zipfile.PyZipFile.open",
        "tarfile.TarFile",
        "tarfile.TarFile.open",
        "multiprocessing.context.BaseContext.Pool",
        "subprocess.Popen",
    )
)


@others
</t>
<t tx="ekr.20220312061835.916">def _if_statement_is_always_returning(if_node, returning_node_class) -&gt; bool:
    for node in if_node.body:
        if isinstance(node, returning_node_class):
            return True
    return False


</t>
<t tx="ekr.20220312061835.917">def _is_trailing_comma(tokens: List[tokenize.TokenInfo], index: int) -&gt; bool:
    """Check if the given token is a trailing comma

    :param tokens: Sequence of modules tokens
    :type tokens: list[tokenize.TokenInfo]
    :param int index: Index of token under check in tokens
    :returns: True if the token is a comma which trails an expression
    :rtype: bool
    """
    token = tokens[index]
    if token.exact_type != tokenize.COMMA:
        return False
    # Must have remaining tokens on the same line such as NEWLINE
    left_tokens = itertools.islice(tokens, index + 1, None)

    @others
    curline_start = get_curline_index_start()
    expected_tokens = {"return", "yield"}
    for prevtoken in tokens[curline_start:index]:
        if "=" in prevtoken.string or prevtoken.string in expected_tokens:
            return True
    return False


</t>
<t tx="ekr.20220312061835.918">def same_start_token(
    other_token: tokenize.TokenInfo, _token: tokenize.TokenInfo = token
) -&gt; bool:
    return other_token.start[0] == _token.start[0]

</t>
<t tx="ekr.20220312061835.919">same_line_remaining_tokens = list(
    itertools.takewhile(same_start_token, left_tokens)
)
# Note: If the newline is tokenize.NEWLINE and not tokenize.NL
# then the newline denotes the end of expression
is_last_element = all(
    other_token.type in (tokenize.NEWLINE, tokenize.COMMENT)
    for other_token in same_line_remaining_tokens
)
if not same_line_remaining_tokens or not is_last_element:
    return False

</t>
<t tx="ekr.20220312061835.92">visit_asyncfunctiondef = visit_functiondef

</t>
<t tx="ekr.20220312061835.920">def get_curline_index_start():
    """Get the index denoting the start of the current line"""
    for subindex, token in enumerate(reversed(tokens[:index])):
        # See Lib/tokenize.py and Lib/token.py in cpython for more info
        if token.type == tokenize.NEWLINE:
            return index - subindex
    return 0

</t>
<t tx="ekr.20220312061835.921">def _is_inside_context_manager(node: nodes.Call) -&gt; bool:
    frame = node.frame()
    if not isinstance(
        frame, (nodes.FunctionDef, astroid.BoundMethod, astroid.UnboundMethod)
    ):
        return False
    return frame.name == "__enter__" or utils.decorated_with(
        frame, "contextlib.contextmanager"
    )


</t>
<t tx="ekr.20220312061835.922">def _is_a_return_statement(node: nodes.Call) -&gt; bool:
    frame = node.frame()
    parent = node.parent
    while parent is not frame:
        if isinstance(parent, nodes.Return):
            return True
        parent = parent.parent
    return False


</t>
<t tx="ekr.20220312061835.923">def _is_part_of_with_items(node: nodes.Call) -&gt; bool:
    """
    Checks if one of the node's parents is a ``nodes.With`` node and that the node itself is located
    somewhere under its ``items``.
    """
    frame = node.frame()
    current = node
    while current != frame:
        if isinstance(current, nodes.With):
            items_start = current.items[0][0].lineno
            items_end = current.items[-1][0].tolineno
            return items_start &lt;= node.lineno &lt;= items_end
        current = current.parent
    return False


</t>
<t tx="ekr.20220312061835.924">def _will_be_released_automatically(node: nodes.Call) -&gt; bool:
    """Checks if a call that could be used in a ``with`` statement is used in an alternative
    construct which would ensure that its __exit__ method is called."""
    callables_taking_care_of_exit = frozenset(
        (
            "contextlib._BaseExitStack.enter_context",
            "contextlib.ExitStack.enter_context",  # necessary for Python 3.6 compatibility
        )
    )
    if not isinstance(node.parent, nodes.Call):
        return False
    func = utils.safe_infer(node.parent.func)
    if not func:
        return False
    return func.qname() in callables_taking_care_of_exit


</t>
<t tx="ekr.20220312061835.925">class ConsiderUsingWithStack(NamedTuple):
    """Stack for objects that may potentially trigger a R1732 message
    if they are not used in a ``with`` block later on."""

    module_scope: Dict[str, nodes.NodeNG] = {}
    class_scope: Dict[str, nodes.NodeNG] = {}
    function_scope: Dict[str, nodes.NodeNG] = {}

    @others
</t>
<t tx="ekr.20220312061835.926">def __iter__(self) -&gt; Iterator[Dict[str, nodes.NodeNG]]:
    yield from (self.function_scope, self.class_scope, self.module_scope)

</t>
<t tx="ekr.20220312061835.927">def get_stack_for_frame(
    self, frame: Union[nodes.FunctionDef, nodes.ClassDef, nodes.Module]
):
    """Get the stack corresponding to the scope of the given frame."""
    if isinstance(frame, nodes.FunctionDef):
        return self.function_scope
    if isinstance(frame, nodes.ClassDef):
        return self.class_scope
    return self.module_scope

</t>
<t tx="ekr.20220312061835.928">def clear_all(self) -&gt; None:
    """Convenience method to clear all stacks"""
    for stack in self:
        stack.clear()


</t>
<t tx="ekr.20220312061835.929">class RefactoringChecker(checkers.BaseTokenChecker):
    """Looks for code which can be refactored

    This checker also mixes the astroid and the token approaches
    in order to create knowledge about whether an "else if" node
    is a true "else if" node, or an "elif" node.
    """

    __implements__ = (interfaces.ITokenChecker, interfaces.IAstroidChecker)

    name = "refactoring"

    msgs = {
        "R1701": (
            "Consider merging these isinstance calls to isinstance(%s, (%s))",
            "consider-merging-isinstance",
            "Used when multiple consecutive isinstance calls can be merged into one.",
        ),
        "R1706": (
            "Consider using ternary (%s)",
            "consider-using-ternary",
            "Used when one of known pre-python 2.5 ternary syntax is used.",
        ),
        "R1709": (
            "Boolean expression may be simplified to %s",
            "simplify-boolean-expression",
            "Emitted when redundant pre-python 2.5 ternary syntax is used.",
        ),
        "R1726": (
            "Boolean condition '%s' may be simplified to '%s'",
            "simplifiable-condition",
            "Emitted when a boolean condition is able to be simplified.",
        ),
        "R1727": (
            "Boolean condition '%s' will always evaluate to '%s'",
            "condition-evals-to-constant",
            "Emitted when a boolean condition can be simplified to a constant value.",
        ),
        "R1702": (
            "Too many nested blocks (%s/%s)",
            "too-many-nested-blocks",
            "Used when a function or a method has too many nested "
            "blocks. This makes the code less understandable and "
            "maintainable.",
            {"old_names": [("R0101", "old-too-many-nested-blocks")]},
        ),
        "R1703": (
            "The if statement can be replaced with %s",
            "simplifiable-if-statement",
            "Used when an if statement can be replaced with 'bool(test)'. ",
            {"old_names": [("R0102", "old-simplifiable-if-statement")]},
        ),
        "R1704": (
            "Redefining argument with the local name %r",
            "redefined-argument-from-local",
            "Used when a local name is redefining an argument, which might "
            "suggest a potential error. This is taken in account only for "
            "a handful of name binding operations, such as for iteration, "
            "with statement assignment and exception handler assignment.",
        ),
        "R1705": (
            'Unnecessary "%s" after "return"',
            "no-else-return",
            "Used in order to highlight an unnecessary block of "
            "code following an if containing a return statement. "
            "As such, it will warn when it encounters an else "
            "following a chain of ifs, all of them containing a "
            "return statement.",
        ),
        "R1707": (
            "Disallow trailing comma tuple",
            "trailing-comma-tuple",
            "In Python, a tuple is actually created by the comma symbol, "
            "not by the parentheses. Unfortunately, one can actually create a "
            "tuple by misplacing a trailing comma, which can lead to potential "
            "weird bugs in your code. You should always use parentheses "
            "explicitly for creating a tuple.",
        ),
        "R1708": (
            "Do not raise StopIteration in generator, use return statement instead",
            "stop-iteration-return",
            "According to PEP479, the raise of StopIteration to end the loop of "
            "a generator may lead to hard to find bugs. This PEP specify that "
            "raise StopIteration has to be replaced by a simple return statement",
        ),
        "R1710": (
            "Either all return statements in a function should return an expression, "
            "or none of them should.",
            "inconsistent-return-statements",
            "According to PEP8, if any return statement returns an expression, "
            "any return statements where no value is returned should explicitly "
            "state this as return None, and an explicit return statement "
            "should be present at the end of the function (if reachable)",
        ),
        "R1711": (
            "Useless return at end of function or method",
            "useless-return",
            'Emitted when a single "return" or "return None" statement is found '
            "at the end of function or method definition. This statement can safely be "
            "removed because Python will implicitly return None",
        ),
        "R1712": (
            "Consider using tuple unpacking for swapping variables",
            "consider-swap-variables",
            "You do not have to use a temporary variable in order to "
            'swap variables. Using "tuple unpacking" to directly swap '
            "variables makes the intention more clear.",
        ),
        "R1713": (
            "Consider using str.join(sequence) for concatenating "
            "strings from an iterable",
            "consider-using-join",
            "Using str.join(sequence) is faster, uses less memory "
            "and increases readability compared to for-loop iteration.",
        ),
        "R1714": (
            'Consider merging these comparisons with "in" to %r',
            "consider-using-in",
            "To check if a variable is equal to one of many values,"
            'combine the values into a tuple and check if the variable is contained "in" it '
            "instead of checking for equality against each of the values."
            "This is faster and less verbose.",
        ),
        "R1715": (
            "Consider using dict.get for getting values from a dict "
            "if a key is present or a default if not",
            "consider-using-get",
            "Using the builtin dict.get for getting a value from a dictionary "
            "if a key is present or a default if not, is simpler and considered "
            "more idiomatic, although sometimes a bit slower",
        ),
        "R1716": (
            "Simplify chained comparison between the operands",
            "chained-comparison",
            "This message is emitted when pylint encounters boolean operation like"
            '"a &lt; b and b &lt; c", suggesting instead to refactor it to "a &lt; b &lt; c"',
        ),
        "R1717": (
            "Consider using a dictionary comprehension",
            "consider-using-dict-comprehension",
            "Emitted when we detect the creation of a dictionary "
            "using the dict() callable and a transient list. "
            "Although there is nothing syntactically wrong with this code, "
            "it is hard to read and can be simplified to a dict comprehension."
            "Also it is faster since you don't need to create another "
            "transient list",
        ),
        "R1718": (
            "Consider using a set comprehension",
            "consider-using-set-comprehension",
            "Although there is nothing syntactically wrong with this code, "
            "it is hard to read and can be simplified to a set comprehension."
            "Also it is faster since you don't need to create another "
            "transient list",
        ),
        "R1719": (
            "The if expression can be replaced with %s",
            "simplifiable-if-expression",
            "Used when an if expression can be replaced with 'bool(test)'. ",
        ),
        "R1720": (
            'Unnecessary "%s" after "raise"',
            "no-else-raise",
            "Used in order to highlight an unnecessary block of "
            "code following an if containing a raise statement. "
            "As such, it will warn when it encounters an else "
            "following a chain of ifs, all of them containing a "
            "raise statement.",
        ),
        "R1721": (
            "Unnecessary use of a comprehension, use %s instead.",
            "unnecessary-comprehension",
            "Instead of using an identity comprehension, "
            "consider using the list, dict or set constructor. "
            "It is faster and simpler.",
        ),
        "R1722": (
            "Consider using sys.exit()",
            "consider-using-sys-exit",
            "Instead of using exit() or quit(), consider using the sys.exit().",
        ),
        "R1723": (
            'Unnecessary "%s" after "break"',
            "no-else-break",
            "Used in order to highlight an unnecessary block of "
            "code following an if containing a break statement. "
            "As such, it will warn when it encounters an else "
            "following a chain of ifs, all of them containing a "
            "break statement.",
        ),
        "R1724": (
            'Unnecessary "%s" after "continue"',
            "no-else-continue",
            "Used in order to highlight an unnecessary block of "
            "code following an if containing a continue statement. "
            "As such, it will warn when it encounters an else "
            "following a chain of ifs, all of them containing a "
            "continue statement.",
        ),
        "R1725": (
            "Consider using Python 3 style super() without arguments",
            "super-with-arguments",
            "Emitted when calling the super() builtin with the current class "
            "and instance. On Python 3 these arguments are the default and they can be omitted.",
        ),
        "R1728": (
            "Consider using a generator instead '%s(%s)'",
            "consider-using-generator",
            "If your container can be large using "
            "a generator will bring better performance.",
        ),
        "R1729": (
            "Use a generator instead '%s(%s)'",
            "use-a-generator",
            "Comprehension inside of 'any' or 'all' is unnecessary. "
            "A generator would be sufficient and faster.",
        ),
        "R1730": (
            "Consider using '%s' instead of unnecessary if block",
            "consider-using-min-builtin",
            "Using the min builtin instead of a conditional improves readability and conciseness.",
        ),
        "R1731": (
            "Consider using '%s' instead of unnecessary if block",
            "consider-using-max-builtin",
            "Using the max builtin instead of a conditional improves readability and conciseness.",
        ),
        "R1732": (
            "Consider using 'with' for resource-allocating operations",
            "consider-using-with",
            "Emitted if a resource-allocating assignment or call may be replaced by a 'with' block. "
            "By using 'with' the release of the allocated resources is ensured even in the case of an exception.",
        ),
        "R1733": (
            "Unnecessary dictionary index lookup, use '%s' instead",
            "unnecessary-dict-index-lookup",
            "Emitted when iterating over the dictionary items (key-item pairs) and accessing the "
            "value by index lookup. "
            "The value can be accessed directly instead.",
        ),
        "R1734": (
            "Consider using [] instead of list()",
            "use-list-literal",
            "Emitted when using list() to create an empty list instead of the literal []. "
            "The literal is faster as it avoids an additional function call.",
        ),
        "R1735": (
            "Consider using {} instead of dict()",
            "use-dict-literal",
            "Emitted when using dict() to create an empty dictionary instead of the literal {}. "
            "The literal is faster as it avoids an additional function call.",
        ),
    }
    options = (
        (
            "max-nested-blocks",
            {
                "default": 5,
                "type": "int",
                "metavar": "&lt;int&gt;",
                "help": "Maximum number of nested blocks for function / method body",
            },
        ),
        (
            "never-returning-functions",
            {
                "default": ("sys.exit", "argparse.parse_error"),
                "type": "csv",
                "help": "Complete name of functions that never returns. When checking "
                "for inconsistent-return-statements if a never returning function is "
                "called then it will be considered as an explicit return statement "
                "and no message will be printed.",
            },
        ),
    )

    priority = 0

    @others
</t>
<t tx="ekr.20220312061835.93">def _check_name_used_prior_global(self, node):

    scope_globals = {
        name: child
        for child in node.nodes_of_class(nodes.Global)
        for name in child.names
        if child.scope() is node
    }

    if not scope_globals:
        return

    for node_name in node.nodes_of_class(nodes.Name):
        if node_name.scope() is not node:
            continue

        name = node_name.name
        corresponding_global = scope_globals.get(name)
        if not corresponding_global:
            continue

        global_lineno = corresponding_global.fromlineno
        if global_lineno and global_lineno &gt; node_name.fromlineno:
            self.add_message(
                "used-prior-global-declaration", node=node_name, args=(name,)
            )

</t>
<t tx="ekr.20220312061835.930">def __init__(self, linter=None):
    checkers.BaseTokenChecker.__init__(self, linter)
    self._return_nodes = {}
    self._consider_using_with_stack = ConsiderUsingWithStack()
    self._init()
    self._never_returning_functions = None

</t>
<t tx="ekr.20220312061835.931">def _init(self):
    self._nested_blocks = []
    self._elifs = []
    self._nested_blocks_msg = None
    self._reported_swap_nodes = set()
    self._can_simplify_bool_op = False
    self._consider_using_with_stack.clear_all()

</t>
<t tx="ekr.20220312061835.932">def open(self):
    # do this in open since config not fully initialized in __init__
    self._never_returning_functions = set(self.config.never_returning_functions)

</t>
<t tx="ekr.20220312061835.933">@astroid.decorators.cachedproperty
def _dummy_rgx(self):
    return lint_utils.get_global_option(self, "dummy-variables-rgx", default=None)

</t>
<t tx="ekr.20220312061835.934">@staticmethod
def _is_bool_const(node):
    return isinstance(node.value, nodes.Const) and isinstance(
        node.value.value, bool
    )

</t>
<t tx="ekr.20220312061835.935">def _is_actual_elif(self, node):
    """Check if the given node is an actual elif

    This is a problem we're having with the builtin ast module,
    which splits `elif` branches into a separate if statement.
    Unfortunately we need to know the exact type in certain
    cases.
    """
    if isinstance(node.parent, nodes.If):
        orelse = node.parent.orelse
        # current if node must directly follow an "else"
        if orelse and orelse == [node]:
            if (node.lineno, node.col_offset) in self._elifs:
                return True
    return False

</t>
<t tx="ekr.20220312061835.936">def _check_simplifiable_if(self, node):
    """Check if the given if node can be simplified.

    The if statement can be reduced to a boolean expression
    in some cases. For instance, if there are two branches
    and both of them return a boolean value that depends on
    the result of the statement's test, then this can be reduced
    to `bool(test)` without losing any functionality.
    """

    if self._is_actual_elif(node):
        # Not interested in if statements with multiple branches.
        return
    if len(node.orelse) != 1 or len(node.body) != 1:
        return

    # Check if both branches can be reduced.
    first_branch = node.body[0]
    else_branch = node.orelse[0]
    if isinstance(first_branch, nodes.Return):
        if not isinstance(else_branch, nodes.Return):
            return
        first_branch_is_bool = self._is_bool_const(first_branch)
        else_branch_is_bool = self._is_bool_const(else_branch)
        reduced_to = "'return bool(test)'"
    elif isinstance(first_branch, nodes.Assign):
        if not isinstance(else_branch, nodes.Assign):
            return

        # Check if we assign to the same value
        first_branch_targets = [
            target.name
            for target in first_branch.targets
            if isinstance(target, nodes.AssignName)
        ]
        else_branch_targets = [
            target.name
            for target in else_branch.targets
            if isinstance(target, nodes.AssignName)
        ]
        if not first_branch_targets or not else_branch_targets:
            return
        if sorted(first_branch_targets) != sorted(else_branch_targets):
            return

        first_branch_is_bool = self._is_bool_const(first_branch)
        else_branch_is_bool = self._is_bool_const(else_branch)
        reduced_to = "'var = bool(test)'"
    else:
        return

    if not first_branch_is_bool or not else_branch_is_bool:
        return
    if not first_branch.value.value:
        # This is a case that can't be easily simplified and
        # if it can be simplified, it will usually result in a
        # code that's harder to understand and comprehend.
        # Let's take for instance `arg and arg &lt;= 3`. This could theoretically be
        # reduced to `not arg or arg &gt; 3`, but the net result is that now the
        # condition is harder to understand, because it requires understanding of
        # an extra clause:
        #   * first, there is the negation of truthness with `not arg`
        #   * the second clause is `arg &gt; 3`, which occurs when arg has a
        #     a truth value, but it implies that `arg &gt; 3` is equivalent
        #     with `arg and arg &gt; 3`, which means that the user must
        #     think about this assumption when evaluating `arg &gt; 3`.
        #     The original form is easier to grasp.
        return

    self.add_message("simplifiable-if-statement", node=node, args=(reduced_to,))

</t>
<t tx="ekr.20220312061835.937">def process_tokens(self, tokens):
    # Process tokens and look for 'if' or 'elif'
    for index, token in enumerate(tokens):
        token_string = token[1]
        if token_string == "elif":
            # AST exists by the time process_tokens is called, so
            # it's safe to assume tokens[index+1]
            # exists. tokens[index+1][2] is the elif's position as
            # reported by CPython and PyPy,
            # tokens[index][2] is the actual position and also is
            # reported by IronPython.
            self._elifs.extend([tokens[index][2], tokens[index + 1][2]])
        elif _is_trailing_comma(tokens, index):
            if self.linter.is_message_enabled("trailing-comma-tuple"):
                self.add_message("trailing-comma-tuple", line=token.start[0])

</t>
<t tx="ekr.20220312061835.938">@utils.check_messages("consider-using-with")
def leave_module(self, _: nodes.Module) -&gt; None:
    # check for context managers that have been created but not used
    self._emit_consider_using_with_if_needed(
        self._consider_using_with_stack.module_scope
    )
    self._init()

</t>
<t tx="ekr.20220312061835.939">@utils.check_messages("too-many-nested-blocks")
def visit_tryexcept(self, node: nodes.TryExcept) -&gt; None:
    self._check_nested_blocks(node)

</t>
<t tx="ekr.20220312061835.94">def _check_nonlocal_and_global(self, node):
    """Check that a name is both nonlocal and global."""

    def same_scope(current):
        return current.scope() is node

    from_iter = itertools.chain.from_iterable
    nonlocals = set(
        from_iter(
            child.names
            for child in node.nodes_of_class(nodes.Nonlocal)
            if same_scope(child)
        )
    )

    if not nonlocals:
        return

    global_vars = set(
        from_iter(
            child.names
            for child in node.nodes_of_class(nodes.Global)
            if same_scope(child)
        )
    )
    for name in nonlocals.intersection(global_vars):
        self.add_message("nonlocal-and-global", args=(name,), node=node)

</t>
<t tx="ekr.20220312061835.940">visit_tryfinally = visit_tryexcept
visit_while = visit_tryexcept

</t>
<t tx="ekr.20220312061835.941">def _check_redefined_argument_from_local(self, name_node):
    if self._dummy_rgx and self._dummy_rgx.match(name_node.name):
        return
    if not name_node.lineno:
        # Unknown position, maybe it is a manually built AST?
        return

    scope = name_node.scope()
    if not isinstance(scope, nodes.FunctionDef):
        return

    for defined_argument in scope.args.nodes_of_class(
        nodes.AssignName, skip_klass=(nodes.Lambda,)
    ):
        if defined_argument.name == name_node.name:
            self.add_message(
                "redefined-argument-from-local",
                node=name_node,
                args=(name_node.name,),
            )

</t>
<t tx="ekr.20220312061835.942">@utils.check_messages(
    "redefined-argument-from-local",
    "too-many-nested-blocks",
    "unnecessary-dict-index-lookup",
)
</t>
<t tx="ekr.20220312061835.943">def visit_for(self, node: nodes.For) -&gt; None:
    self._check_nested_blocks(node)
    self._check_unnecessary_dict_index_lookup(node)

    for name in node.target.nodes_of_class(nodes.AssignName):
        self._check_redefined_argument_from_local(name)

</t>
<t tx="ekr.20220312061835.944">@utils.check_messages("redefined-argument-from-local")
def visit_excepthandler(self, node: nodes.ExceptHandler) -&gt; None:
    if node.name and isinstance(node.name, nodes.AssignName):
        self._check_redefined_argument_from_local(node.name)

</t>
<t tx="ekr.20220312061835.945">@utils.check_messages("redefined-argument-from-local")
def visit_with(self, node: nodes.With) -&gt; None:
    for var, names in node.items:
        if isinstance(var, nodes.Name):
            for stack in self._consider_using_with_stack:
                # We don't need to restrict the stacks we search to the current scope and outer scopes,
                # as e.g. the function_scope stack will be empty when we check a ``with`` on the class level.
                if var.name in stack:
                    del stack[var.name]
                    break
        if not names:
            continue
        for name in names.nodes_of_class(nodes.AssignName):
            self._check_redefined_argument_from_local(name)

</t>
<t tx="ekr.20220312061835.946">def _check_superfluous_else(self, node, msg_id, returning_node_class):
    if not node.orelse:
        # Not interested in if statements without else.
        return

    if self._is_actual_elif(node):
        # Not interested in elif nodes; only if
        return

    if _if_statement_is_always_returning(node, returning_node_class):
        orelse = node.orelse[0]
        followed_by_elif = (orelse.lineno, orelse.col_offset) in self._elifs
        self.add_message(
            msg_id, node=node, args="elif" if followed_by_elif else "else"
        )

</t>
<t tx="ekr.20220312061835.947">def _check_superfluous_else_return(self, node):
    return self._check_superfluous_else(
        node, msg_id="no-else-return", returning_node_class=nodes.Return
    )

</t>
<t tx="ekr.20220312061835.948">def _check_superfluous_else_raise(self, node):
    return self._check_superfluous_else(
        node, msg_id="no-else-raise", returning_node_class=nodes.Raise
    )

</t>
<t tx="ekr.20220312061835.949">def _check_superfluous_else_break(self, node):
    return self._check_superfluous_else(
        node, msg_id="no-else-break", returning_node_class=nodes.Break
    )

</t>
<t tx="ekr.20220312061835.95">@utils.check_messages("return-outside-function")
def visit_return(self, node: nodes.Return) -&gt; None:
    if not isinstance(node.frame(), nodes.FunctionDef):
        self.add_message("return-outside-function", node=node)

</t>
<t tx="ekr.20220312061835.950">def _check_superfluous_else_continue(self, node):
    return self._check_superfluous_else(
        node, msg_id="no-else-continue", returning_node_class=nodes.Continue
    )

</t>
<t tx="ekr.20220312061835.951">@staticmethod
def _type_and_name_are_equal(node_a, node_b):
    for _type in (nodes.Name, nodes.AssignName):
        if all(isinstance(_node, _type) for _node in (node_a, node_b)):
            return node_a.name == node_b.name
    if all(isinstance(_node, nodes.Const) for _node in (node_a, node_b)):
        return node_a.value == node_b.value
    return False

</t>
<t tx="ekr.20220312061835.952">def _is_dict_get_block(self, node):

    # "if &lt;compare node&gt;"
    if not isinstance(node.test, nodes.Compare):
        return False

    # Does not have a single statement in the guard's body
    if len(node.body) != 1:
        return False

    # Look for a single variable assignment on the LHS and a subscript on RHS
    stmt = node.body[0]
    if not (
        isinstance(stmt, nodes.Assign)
        and len(node.body[0].targets) == 1
        and isinstance(node.body[0].targets[0], nodes.AssignName)
        and isinstance(stmt.value, nodes.Subscript)
    ):
        return False

    # The subscript's slice needs to be the same as the test variable.
    slice_value = stmt.value.slice
    if not (
        self._type_and_name_are_equal(stmt.value.value, node.test.ops[0][1])
        and self._type_and_name_are_equal(slice_value, node.test.left)
    ):
        return False

    # The object needs to be a dictionary instance
    return isinstance(utils.safe_infer(node.test.ops[0][1]), nodes.Dict)

</t>
<t tx="ekr.20220312061835.953">def _check_consider_get(self, node):
    if_block_ok = self._is_dict_get_block(node)
    if if_block_ok and not node.orelse:
        self.add_message("consider-using-get", node=node)
    elif (
        if_block_ok
        and len(node.orelse) == 1
        and isinstance(node.orelse[0], nodes.Assign)
        and self._type_and_name_are_equal(
            node.orelse[0].targets[0], node.body[0].targets[0]
        )
        and len(node.orelse[0].targets) == 1
    ):
        self.add_message("consider-using-get", node=node)

</t>
<t tx="ekr.20220312061835.954">@utils.check_messages(
    "too-many-nested-blocks",
    "simplifiable-if-statement",
    "no-else-return",
    "no-else-raise",
    "no-else-break",
    "no-else-continue",
    "consider-using-get",
)
</t>
<t tx="ekr.20220312061835.955">def visit_if(self, node: nodes.If) -&gt; None:
    self._check_simplifiable_if(node)
    self._check_nested_blocks(node)
    self._check_superfluous_else_return(node)
    self._check_superfluous_else_raise(node)
    self._check_superfluous_else_break(node)
    self._check_superfluous_else_continue(node)
    self._check_consider_get(node)
    self._check_consider_using_min_max_builtin(node)

</t>
<t tx="ekr.20220312061835.956">def _check_consider_using_min_max_builtin(self, node: nodes.If):
    """Check if the given if node can be refactored as an min/max python builtin."""
    if self._is_actual_elif(node) or node.orelse:
        # Not interested in if statements with multiple branches.
        return

    if len(node.body) != 1:
        return

    body = node.body[0]
    # Check if condition can be reduced.
    if not hasattr(body, "targets") or len(body.targets) != 1:
        return

    target = body.targets[0]
    if not (
        isinstance(node.test, nodes.Compare)
        and not isinstance(target, nodes.Subscript)
        and not isinstance(node.test.left, nodes.Subscript)
        and isinstance(body, nodes.Assign)
    ):
        return

    # Check that the assignation is on the same variable.
    if hasattr(node.test.left, "name"):
        left_operand = node.test.left.name
    elif hasattr(node.test.left, "attrname"):
        left_operand = node.test.left.attrname
    else:
        return

    if hasattr(target, "name"):
        target_assignation = target.name
    elif hasattr(target, "attrname"):
        target_assignation = target.attrname
    else:
        return

    if not (left_operand == target_assignation):
        return

    if len(node.test.ops) &gt; 1:
        return

    if not isinstance(body.value, (nodes.Name, nodes.Const)):
        return

    operator, right_statement = node.test.ops[0]
    if isinstance(body.value, nodes.Name):
        body_value = body.value.name
    else:
        body_value = body.value.value

    if isinstance(right_statement, nodes.Name):
        right_statement_value = right_statement.name
    elif isinstance(right_statement, nodes.Const):
        right_statement_value = right_statement.value
    else:
        return

    # Verify the right part of the statement is the same.
    if right_statement_value != body_value:
        return

    if operator in ("&lt;", "&lt;="):
        reduced_to = "{target} = max({target}, {item})".format(
            target=target_assignation, item=body_value
        )
        self.add_message(
            "consider-using-max-builtin", node=node, args=(reduced_to,)
        )
    elif operator in ("&gt;", "&gt;="):
        reduced_to = "{target} = min({target}, {item})".format(
            target=target_assignation, item=body_value
        )
        self.add_message(
            "consider-using-min-builtin", node=node, args=(reduced_to,)
        )

</t>
<t tx="ekr.20220312061835.957">@utils.check_messages("simplifiable-if-expression")
def visit_ifexp(self, node: nodes.IfExp) -&gt; None:
    self._check_simplifiable_ifexp(node)

</t>
<t tx="ekr.20220312061835.958">def _check_simplifiable_ifexp(self, node):
    if not isinstance(node.body, nodes.Const) or not isinstance(
        node.orelse, nodes.Const
    ):
        return

    if not isinstance(node.body.value, bool) or not isinstance(
        node.orelse.value, bool
    ):
        return

    if isinstance(node.test, nodes.Compare):
        test_reduced_to = "test"
    else:
        test_reduced_to = "bool(test)"

    if (node.body.value, node.orelse.value) == (True, False):
        reduced_to = f"'{test_reduced_to}'"
    elif (node.body.value, node.orelse.value) == (False, True):
        reduced_to = "'not test'"
    else:
        return

    self.add_message("simplifiable-if-expression", node=node, args=(reduced_to,))

</t>
<t tx="ekr.20220312061835.959">@utils.check_messages(
    "too-many-nested-blocks",
    "inconsistent-return-statements",
    "useless-return",
    "consider-using-with",
)
</t>
<t tx="ekr.20220312061835.96">@utils.check_messages("yield-outside-function")
def visit_yield(self, node: nodes.Yield) -&gt; None:
    self._check_yield_outside_func(node)

</t>
<t tx="ekr.20220312061835.960">def leave_functiondef(self, node: nodes.FunctionDef) -&gt; None:
    # check left-over nested blocks stack
    self._emit_nested_blocks_message_if_needed(self._nested_blocks)
    # new scope = reinitialize the stack of nested blocks
    self._nested_blocks = []
    # check consistent return statements
    self._check_consistent_returns(node)
    # check for single return or return None at the end
    self._check_return_at_the_end(node)
    self._return_nodes[node.name] = []
    # check for context managers that have been created but not used
    self._emit_consider_using_with_if_needed(
        self._consider_using_with_stack.function_scope
    )
    self._consider_using_with_stack.function_scope.clear()

</t>
<t tx="ekr.20220312061835.961">@utils.check_messages("consider-using-with")
def leave_classdef(self, _: nodes.ClassDef) -&gt; None:
    # check for context managers that have been created but not used
    self._emit_consider_using_with_if_needed(
        self._consider_using_with_stack.class_scope
    )
    self._consider_using_with_stack.class_scope.clear()

</t>
<t tx="ekr.20220312061835.962">@utils.check_messages("stop-iteration-return")
def visit_raise(self, node: nodes.Raise) -&gt; None:
    self._check_stop_iteration_inside_generator(node)

</t>
<t tx="ekr.20220312061835.963">def _check_stop_iteration_inside_generator(self, node):
    """Check if an exception of type StopIteration is raised inside a generator"""
    frame = node.frame()
    if not isinstance(frame, nodes.FunctionDef) or not frame.is_generator():
        return
    if utils.node_ignores_exception(node, StopIteration):
        return
    if not node.exc:
        return
    exc = utils.safe_infer(node.exc)
    if not exc or not isinstance(exc, (astroid.Instance, nodes.ClassDef)):
        return
    if self._check_exception_inherit_from_stopiteration(exc):
        self.add_message("stop-iteration-return", node=node)

</t>
<t tx="ekr.20220312061835.964">@staticmethod
def _check_exception_inherit_from_stopiteration(exc):
    """Return True if the exception node in argument inherit from StopIteration"""
    stopiteration_qname = f"{utils.EXCEPTIONS_MODULE}.StopIteration"
    return any(_class.qname() == stopiteration_qname for _class in exc.mro())

</t>
<t tx="ekr.20220312061835.965">def _check_consider_using_comprehension_constructor(self, node):
    if (
        isinstance(node.func, nodes.Name)
        and node.args
        and isinstance(node.args[0], nodes.ListComp)
    ):
        if node.func.name == "dict" and not isinstance(
            node.args[0].elt, nodes.Call
        ):
            message_name = "consider-using-dict-comprehension"
            self.add_message(message_name, node=node)
        elif node.func.name == "set":
            message_name = "consider-using-set-comprehension"
            self.add_message(message_name, node=node)

</t>
<t tx="ekr.20220312061835.966">def _check_consider_using_generator(self, node):
    # 'any' and 'all' definitely should use generator, while 'list' and 'tuple' need to be considered first
    # See https://github.com/PyCQA/pylint/pull/3309#discussion_r576683109
    checked_call = ["any", "all", "list", "tuple"]
    if (
        isinstance(node, nodes.Call)
        and node.func
        and isinstance(node.func, nodes.Name)
        and node.func.name in checked_call
    ):
        # functions in checked_calls take exactly one argument
        # check whether the argument is list comprehension
        if len(node.args) == 1 and isinstance(node.args[0], nodes.ListComp):
            # remove square brackets '[]'
            inside_comp = node.args[0].as_string()[1:-1]
            call_name = node.func.name
            if call_name in ["any", "all"]:
                self.add_message(
                    "use-a-generator",
                    node=node,
                    args=(call_name, inside_comp),
                )
            else:
                self.add_message(
                    "consider-using-generator",
                    node=node,
                    args=(call_name, inside_comp),
                )

</t>
<t tx="ekr.20220312061835.967">@utils.check_messages(
    "stop-iteration-return",
    "consider-using-dict-comprehension",
    "consider-using-set-comprehension",
    "consider-using-sys-exit",
    "super-with-arguments",
    "consider-using-generator",
    "consider-using-with",
    "use-list-literal",
    "use-dict-literal",
)
</t>
<t tx="ekr.20220312061835.968">def visit_call(self, node: nodes.Call) -&gt; None:
    self._check_raising_stopiteration_in_generator_next_call(node)
    self._check_consider_using_comprehension_constructor(node)
    self._check_quit_exit_call(node)
    self._check_super_with_arguments(node)
    self._check_consider_using_generator(node)
    self._check_consider_using_with(node)
    self._check_use_list_or_dict_literal(node)

</t>
<t tx="ekr.20220312061835.969">@staticmethod
def _has_exit_in_scope(scope):
    exit_func = scope.locals.get("exit")
    return bool(
        exit_func and isinstance(exit_func[0], (nodes.ImportFrom, nodes.Import))
    )

</t>
<t tx="ekr.20220312061835.97">@utils.check_messages("yield-outside-function")
def visit_yieldfrom(self, node: nodes.YieldFrom) -&gt; None:
    self._check_yield_outside_func(node)

</t>
<t tx="ekr.20220312061835.970">def _check_quit_exit_call(self, node):

    if isinstance(node.func, nodes.Name) and node.func.name in BUILTIN_EXIT_FUNCS:
        # If we have `exit` imported from `sys` in the current or global scope, exempt this instance.
        local_scope = node.scope()
        if self._has_exit_in_scope(local_scope) or self._has_exit_in_scope(
            node.root()
        ):
            return
        self.add_message("consider-using-sys-exit", node=node)

</t>
<t tx="ekr.20220312061835.971">def _check_super_with_arguments(self, node):
    if not isinstance(node.func, nodes.Name) or node.func.name != "super":
        return

    # pylint: disable=too-many-boolean-expressions
    if (
        len(node.args) != 2
        or not isinstance(node.args[1], nodes.Name)
        or node.args[1].name != "self"
        or not isinstance(node.args[0], nodes.Name)
        or not isinstance(node.args[1], nodes.Name)
        or node_frame_class(node) is None
        or node.args[0].name != node_frame_class(node).name
    ):
        return

    self.add_message("super-with-arguments", node=node)

</t>
<t tx="ekr.20220312061835.972">def _check_raising_stopiteration_in_generator_next_call(self, node):
    """Check if a StopIteration exception is raised by the call to next function

    If the next value has a default value, then do not add message.

    :param node: Check to see if this Call node is a next function
    :type node: :class:`nodes.Call`
    """

    def _looks_like_infinite_iterator(param):
        inferred = utils.safe_infer(param)
        if inferred:
            return inferred.qname() in KNOWN_INFINITE_ITERATORS
        return False

    if isinstance(node.func, nodes.Attribute):
        # A next() method, which is now what we want.
        return

    inferred = utils.safe_infer(node.func)
    if getattr(inferred, "name", "") == "next":
        frame = node.frame()
        # The next builtin can only have up to two
        # positional arguments and no keyword arguments
        has_sentinel_value = len(node.args) &gt; 1
        if (
            isinstance(frame, nodes.FunctionDef)
            and frame.is_generator()
            and not has_sentinel_value
            and not utils.node_ignores_exception(node, StopIteration)
            and not _looks_like_infinite_iterator(node.args[0])
        ):
            self.add_message("stop-iteration-return", node=node)

</t>
<t tx="ekr.20220312061835.973">def _check_nested_blocks(self, node):
    """Update and check the number of nested blocks"""
    # only check block levels inside functions or methods
    if not isinstance(node.scope(), nodes.FunctionDef):
        return
    # messages are triggered on leaving the nested block. Here we save the
    # stack in case the current node isn't nested in the previous one
    nested_blocks = self._nested_blocks[:]
    if node.parent == node.scope():
        self._nested_blocks = [node]
    else:
        # go through ancestors from the most nested to the less
        for ancestor_node in reversed(self._nested_blocks):
            if ancestor_node == node.parent:
                break
            self._nested_blocks.pop()
        # if the node is an elif, this should not be another nesting level
        if isinstance(node, nodes.If) and self._is_actual_elif(node):
            if self._nested_blocks:
                self._nested_blocks.pop()
        self._nested_blocks.append(node)

    # send message only once per group of nested blocks
    if len(nested_blocks) &gt; len(self._nested_blocks):
        self._emit_nested_blocks_message_if_needed(nested_blocks)

</t>
<t tx="ekr.20220312061835.974">def _emit_nested_blocks_message_if_needed(self, nested_blocks):
    if len(nested_blocks) &gt; self.config.max_nested_blocks:
        self.add_message(
            "too-many-nested-blocks",
            node=nested_blocks[0],
            args=(len(nested_blocks), self.config.max_nested_blocks),
        )

</t>
<t tx="ekr.20220312061835.975">def _emit_consider_using_with_if_needed(self, stack: Dict[str, nodes.NodeNG]):
    for node in stack.values():
        self.add_message("consider-using-with", node=node)

</t>
<t tx="ekr.20220312061835.976">@staticmethod
def _duplicated_isinstance_types(node):
    """Get the duplicated types from the underlying isinstance calls.

    :param nodes.BoolOp node: Node which should contain a bunch of isinstance calls.
    :returns: Dictionary of the comparison objects from the isinstance calls,
              to duplicate values from consecutive calls.
    :rtype: dict
    """
    duplicated_objects = set()
    all_types = collections.defaultdict(set)

    for call in node.values:
        if not isinstance(call, nodes.Call) or len(call.args) != 2:
            continue

        inferred = utils.safe_infer(call.func)
        if not inferred or not utils.is_builtin_object(inferred):
            continue

        if inferred.name != "isinstance":
            continue

        isinstance_object = call.args[0].as_string()
        isinstance_types = call.args[1]

        if isinstance_object in all_types:
            duplicated_objects.add(isinstance_object)

        if isinstance(isinstance_types, nodes.Tuple):
            elems = [
                class_type.as_string() for class_type in isinstance_types.itered()
            ]
        else:
            elems = [isinstance_types.as_string()]
        all_types[isinstance_object].update(elems)

    # Remove all keys which not duplicated
    return {
        key: value for key, value in all_types.items() if key in duplicated_objects
    }

</t>
<t tx="ekr.20220312061835.977">def _check_consider_merging_isinstance(self, node):
    """Check isinstance calls which can be merged together."""
    if node.op != "or":
        return

    first_args = self._duplicated_isinstance_types(node)
    for duplicated_name, class_names in first_args.items():
        names = sorted(name for name in class_names)
        self.add_message(
            "consider-merging-isinstance",
            node=node,
            args=(duplicated_name, ", ".join(names)),
        )

</t>
<t tx="ekr.20220312061835.978">def _check_consider_using_in(self, node):
    allowed_ops = {"or": "==", "and": "!="}

    if node.op not in allowed_ops or len(node.values) &lt; 2:
        return

    for value in node.values:
        if (
            not isinstance(value, nodes.Compare)
            or len(value.ops) != 1
            or value.ops[0][0] not in allowed_ops[node.op]
        ):
            return
        for comparable in value.left, value.ops[0][1]:
            if isinstance(comparable, nodes.Call):
                return

    # Gather variables and values from comparisons
    variables, values = [], []
    for value in node.values:
        variable_set = set()
        for comparable in value.left, value.ops[0][1]:
            if isinstance(comparable, (nodes.Name, nodes.Attribute)):
                variable_set.add(comparable.as_string())
            values.append(comparable.as_string())
        variables.append(variable_set)

    # Look for (common-)variables that occur in all comparisons
    common_variables = reduce(lambda a, b: a.intersection(b), variables)

    if not common_variables:
        return

    # Gather information for the suggestion
    common_variable = sorted(list(common_variables))[0]
    comprehension = "in" if node.op == "or" else "not in"
    values = list(collections.OrderedDict.fromkeys(values))
    values.remove(common_variable)
    values_string = ", ".join(values) if len(values) != 1 else values[0] + ","
    suggestion = f"{common_variable} {comprehension} ({values_string})"

    self.add_message("consider-using-in", node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.979">def _check_chained_comparison(self, node):
    """Check if there is any chained comparison in the expression.

    Add a refactoring message if a boolOp contains comparison like a &lt; b and b &lt; c,
    which can be chained as a &lt; b &lt; c.

    Care is taken to avoid simplifying a &lt; b &lt; c and b &lt; d.
    """
    if node.op != "and" or len(node.values) &lt; 2:
        return

    def _find_lower_upper_bounds(comparison_node, uses):
        left_operand = comparison_node.left
        for operator, right_operand in comparison_node.ops:
            for operand in (left_operand, right_operand):
                value = None
                if isinstance(operand, nodes.Name):
                    value = operand.name
                elif isinstance(operand, nodes.Const):
                    value = operand.value

                if value is None:
                    continue

                if operator in ("&lt;", "&lt;="):
                    if operand is left_operand:
                        uses[value]["lower_bound"].add(comparison_node)
                    elif operand is right_operand:
                        uses[value]["upper_bound"].add(comparison_node)
                elif operator in ("&gt;", "&gt;="):
                    if operand is left_operand:
                        uses[value]["upper_bound"].add(comparison_node)
                    elif operand is right_operand:
                        uses[value]["lower_bound"].add(comparison_node)
            left_operand = right_operand

    uses = collections.defaultdict(
        lambda: {"lower_bound": set(), "upper_bound": set()}
    )
    for comparison_node in node.values:
        if isinstance(comparison_node, nodes.Compare):
            _find_lower_upper_bounds(comparison_node, uses)

    for _, bounds in uses.items():
        num_shared = len(bounds["lower_bound"].intersection(bounds["upper_bound"]))
        num_lower_bounds = len(bounds["lower_bound"])
        num_upper_bounds = len(bounds["upper_bound"])
        if num_shared &lt; num_lower_bounds and num_shared &lt; num_upper_bounds:
            self.add_message("chained-comparison", node=node)
            break

</t>
<t tx="ekr.20220312061835.98">@utils.check_messages("not-in-loop", "continue-in-finally")
def visit_continue(self, node: nodes.Continue) -&gt; None:
    self._check_in_loop(node, "continue")

</t>
<t tx="ekr.20220312061835.980">@staticmethod
def _apply_boolean_simplification_rules(operator, values):
    """Removes irrelevant values or returns shortcircuiting values

    This function applies the following two rules:
    1) an OR expression with True in it will always be true, and the
       reverse for AND

    2) False values in OR expressions are only relevant if all values are
       false, and the reverse for AND"""
    simplified_values = []

    for subnode in values:
        inferred_bool = None
        if not next(subnode.nodes_of_class(nodes.Name), False):
            inferred = utils.safe_infer(subnode)
            if inferred:
                inferred_bool = inferred.bool_value()

        if not isinstance(inferred_bool, bool):
            simplified_values.append(subnode)
        elif (operator == "or") == inferred_bool:
            return [subnode]

    return simplified_values or [nodes.Const(operator == "and")]

</t>
<t tx="ekr.20220312061835.981">def _simplify_boolean_operation(self, bool_op):
    """Attempts to simplify a boolean operation

    Recursively applies simplification on the operator terms,
    and keeps track of whether reductions have been made."""
    children = list(bool_op.get_children())
    intermediate = [
        self._simplify_boolean_operation(child)
        if isinstance(child, nodes.BoolOp)
        else child
        for child in children
    ]
    result = self._apply_boolean_simplification_rules(bool_op.op, intermediate)
    if len(result) &lt; len(children):
        self._can_simplify_bool_op = True
    if len(result) == 1:
        return result[0]
    simplified_bool_op = copy.copy(bool_op)
    simplified_bool_op.postinit(result)
    return simplified_bool_op

</t>
<t tx="ekr.20220312061835.982">def _check_simplifiable_condition(self, node):
    """Check if a boolean condition can be simplified.

    Variables will not be simplified, even in the value can be inferred,
    and expressions like '3 + 4' will remain expanded."""
    if not utils.is_test_condition(node):
        return

    self._can_simplify_bool_op = False
    simplified_expr = self._simplify_boolean_operation(node)

    if not self._can_simplify_bool_op:
        return

    if not next(simplified_expr.nodes_of_class(nodes.Name), False):
        self.add_message(
            "condition-evals-to-constant",
            node=node,
            args=(node.as_string(), simplified_expr.as_string()),
        )
    else:
        self.add_message(
            "simplifiable-condition",
            node=node,
            args=(node.as_string(), simplified_expr.as_string()),
        )

</t>
<t tx="ekr.20220312061835.983">@utils.check_messages(
    "consider-merging-isinstance",
    "consider-using-in",
    "chained-comparison",
    "simplifiable-condition",
    "condition-evals-to-constant",
)
</t>
<t tx="ekr.20220312061835.984">def visit_boolop(self, node: nodes.BoolOp) -&gt; None:
    self._check_consider_merging_isinstance(node)
    self._check_consider_using_in(node)
    self._check_chained_comparison(node)
    self._check_simplifiable_condition(node)

</t>
<t tx="ekr.20220312061835.985">@staticmethod
def _is_simple_assignment(node):
    return (
        isinstance(node, nodes.Assign)
        and len(node.targets) == 1
        and isinstance(node.targets[0], nodes.AssignName)
        and isinstance(node.value, nodes.Name)
    )

</t>
<t tx="ekr.20220312061835.986">def _check_swap_variables(self, node):
    if not node.next_sibling() or not node.next_sibling().next_sibling():
        return
    assignments = [node, node.next_sibling(), node.next_sibling().next_sibling()]
    if not all(self._is_simple_assignment(node) for node in assignments):
        return
    if any(node in self._reported_swap_nodes for node in assignments):
        return
    left = [node.targets[0].name for node in assignments]
    right = [node.value.name for node in assignments]
    if left[0] == right[-1] and left[1:] == right[:-1]:
        self._reported_swap_nodes.update(assignments)
        message = "consider-swap-variables"
        self.add_message(message, node=node)

</t>
<t tx="ekr.20220312061835.987">@utils.check_messages(
    "simplify-boolean-expression",
    "consider-using-ternary",
    "consider-swap-variables",
    "consider-using-with",
)
</t>
<t tx="ekr.20220312061835.988">def visit_assign(self, node: nodes.Assign) -&gt; None:
    self._append_context_managers_to_stack(node)
    self.visit_return(node)  # remaining checks are identical as for return nodes

</t>
<t tx="ekr.20220312061835.989">@utils.check_messages(
    "simplify-boolean-expression",
    "consider-using-ternary",
    "consider-swap-variables",
)
</t>
<t tx="ekr.20220312061835.99">@utils.check_messages("not-in-loop")
def visit_break(self, node: nodes.Break) -&gt; None:
    self._check_in_loop(node, "break")

</t>
<t tx="ekr.20220312061835.990">def visit_return(self, node: nodes.Return) -&gt; None:
    self._check_swap_variables(node)
    if self._is_and_or_ternary(node.value):
        cond, truth_value, false_value = self._and_or_ternary_arguments(node.value)
    else:
        return

    if all(
        isinstance(value, nodes.Compare) for value in (truth_value, false_value)
    ):
        return

    inferred_truth_value = utils.safe_infer(truth_value)
    if inferred_truth_value in (None, astroid.Uninferable):
        truth_boolean_value = True
    else:
        truth_boolean_value = truth_value.bool_value()

    if truth_boolean_value is False:
        message = "simplify-boolean-expression"
        suggestion = false_value.as_string()
    else:
        message = "consider-using-ternary"
        suggestion = f"{truth_value.as_string()} if {cond.as_string()} else {false_value.as_string()}"
    self.add_message(message, node=node, args=(suggestion,))

</t>
<t tx="ekr.20220312061835.991">def _append_context_managers_to_stack(self, node: nodes.Assign) -&gt; None:
    if _is_inside_context_manager(node):
        # if we are inside a context manager itself, we assume that it will handle the resource management itself.
        return
    if isinstance(node.targets[0], (nodes.Tuple, nodes.List, nodes.Set)):
        assignees = node.targets[0].elts
        value = utils.safe_infer(node.value)
        if value is None or not hasattr(value, "elts"):
            # We cannot deduce what values are assigned, so we have to skip this
            return
        values = value.elts
    else:
        assignees = [node.targets[0]]
        values = [node.value]
    if Uninferable in (assignees, values):
        return
    for assignee, value in zip(assignees, values):
        if not isinstance(value, nodes.Call):
            continue
        inferred = utils.safe_infer(value.func)
        if (
            not inferred
            or inferred.qname() not in CALLS_RETURNING_CONTEXT_MANAGERS
            or not isinstance(assignee, (nodes.AssignName, nodes.AssignAttr))
        ):
            continue
        stack = self._consider_using_with_stack.get_stack_for_frame(node.frame())
        varname = (
            assignee.name
            if isinstance(assignee, nodes.AssignName)
            else assignee.attrname
        )
        if varname in stack:
            existing_node = stack[varname]
            if astroid.are_exclusive(node, existing_node):
                # only one of the two assignments can be executed at runtime, thus it is fine
                stack[varname] = value
                continue
            # variable was redefined before it was used in a ``with`` block
            self.add_message(
                "consider-using-with",
                node=existing_node,
            )
        stack[varname] = value

</t>
<t tx="ekr.20220312061835.992">def _check_consider_using_with(self, node: nodes.Call):
    if _is_inside_context_manager(node) or _is_a_return_statement(node):
        # If we are inside a context manager itself, we assume that it will handle the resource management itself.
        # If the node is a child of a return, we assume that the caller knows he is getting a context manager
        # he should use properly (i.e. in a ``with``).
        return
    if (
        node
        in self._consider_using_with_stack.get_stack_for_frame(
            node.frame()
        ).values()
    ):
        # the result of this call was already assigned to a variable and will be checked when leaving the scope.
        return
    inferred = utils.safe_infer(node.func)
    if not inferred:
        return
    could_be_used_in_with = (
        # things like ``lock.acquire()``
        inferred.qname() in CALLS_THAT_COULD_BE_REPLACED_BY_WITH
        or (
            # things like ``open("foo")`` which are not already inside a ``with`` statement
            inferred.qname() in CALLS_RETURNING_CONTEXT_MANAGERS
            and not _is_part_of_with_items(node)
        )
    )
    if could_be_used_in_with and not _will_be_released_automatically(node):
        self.add_message("consider-using-with", node=node)

</t>
<t tx="ekr.20220312061835.993">def _check_use_list_or_dict_literal(self, node: nodes.Call) -&gt; None:
    """Check if empty list or dict is created by using the literal [] or {}"""
    if node.as_string() in ("list()", "dict()"):
        inferred = utils.safe_infer(node.func)
        if isinstance(inferred, nodes.ClassDef) and not node.args:
            if inferred.qname() == "builtins.list":
                self.add_message("use-list-literal", node=node)
            elif inferred.qname() == "builtins.dict" and not node.keywords:
                self.add_message("use-dict-literal", node=node)

</t>
<t tx="ekr.20220312061835.994">def _check_consider_using_join(self, aug_assign):
    """
    We start with the augmented assignment and work our way upwards.
    Names of variables for nodes if match successful:
    result = ''  # assign
    for number in ['1', '2', '3']  # for_loop
        result += number  # aug_assign
    """
    for_loop = aug_assign.parent
    if not isinstance(for_loop, nodes.For) or len(for_loop.body) &gt; 1:
        return
    assign = for_loop.previous_sibling()
    if not isinstance(assign, nodes.Assign):
        return
    result_assign_names = {
        target.name
        for target in assign.targets
        if isinstance(target, nodes.AssignName)
    }

    is_concat_loop = (
        aug_assign.op == "+="
        and isinstance(aug_assign.target, nodes.AssignName)
        and len(for_loop.body) == 1
        and aug_assign.target.name in result_assign_names
        and isinstance(assign.value, nodes.Const)
        and isinstance(assign.value.value, str)
        and isinstance(aug_assign.value, nodes.Name)
        and aug_assign.value.name == for_loop.target.name
    )
    if is_concat_loop:
        self.add_message("consider-using-join", node=aug_assign)

</t>
<t tx="ekr.20220312061835.995">@utils.check_messages("consider-using-join")
def visit_augassign(self, node: nodes.AugAssign) -&gt; None:
    self._check_consider_using_join(node)

</t>
<t tx="ekr.20220312061835.996">@utils.check_messages("unnecessary-comprehension", "unnecessary-dict-index-lookup")
def visit_comprehension(self, node: nodes.Comprehension) -&gt; None:
    self._check_unnecessary_comprehension(node)
    self._check_unnecessary_dict_index_lookup(node)

</t>
<t tx="ekr.20220312061835.997">def _check_unnecessary_comprehension(self, node: nodes.Comprehension) -&gt; None:
    if (
        isinstance(node.parent, nodes.GeneratorExp)
        or len(node.ifs) != 0
        or len(node.parent.generators) != 1
        or node.is_async
    ):
        return

    if (
        isinstance(node.parent, nodes.DictComp)
        and isinstance(node.parent.key, nodes.Name)
        and isinstance(node.parent.value, nodes.Name)
        and isinstance(node.target, nodes.Tuple)
        and all(isinstance(elt, nodes.AssignName) for elt in node.target.elts)
    ):
        expr_list = [node.parent.key.name, node.parent.value.name]
        target_list = [elt.name for elt in node.target.elts]

    elif isinstance(node.parent, (nodes.ListComp, nodes.SetComp)):
        expr = node.parent.elt
        if isinstance(expr, nodes.Name):
            expr_list = expr.name
        elif isinstance(expr, nodes.Tuple):
            if any(not isinstance(elt, nodes.Name) for elt in expr.elts):
                return
            expr_list = [elt.name for elt in expr.elts]
        else:
            expr_list = []
        target = node.parent.generators[0].target
        target_list = (
            target.name
            if isinstance(target, nodes.AssignName)
            else (
                [
                    elt.name
                    for elt in target.elts
                    if isinstance(elt, nodes.AssignName)
                ]
                if isinstance(target, nodes.Tuple)
                else []
            )
        )
    else:
        return
    if expr_list == target_list != []:
        args: Optional[Tuple[str]] = None
        inferred = utils.safe_infer(node.iter)
        if isinstance(node.parent, nodes.DictComp) and isinstance(
            inferred, astroid.objects.DictItems
        ):
            args = (f"{node.iter.func.expr.as_string()}",)
        elif (
            isinstance(node.parent, nodes.ListComp)
            and isinstance(inferred, nodes.List)
        ) or (
            isinstance(node.parent, nodes.SetComp)
            and isinstance(inferred, nodes.Set)
        ):
            args = (f"{node.iter.as_string()}",)
        if args:
            self.add_message("unnecessary-comprehension", node=node, args=args)
            return

        if isinstance(node.parent, nodes.DictComp):
            func = "dict"
        elif isinstance(node.parent, nodes.ListComp):
            func = "list"
        elif isinstance(node.parent, nodes.SetComp):
            func = "set"
        else:
            return

        self.add_message(
            "unnecessary-comprehension",
            node=node,
            args=(f"{func}({node.iter.as_string()})",),
        )

</t>
<t tx="ekr.20220312061835.998">@staticmethod
def _is_and_or_ternary(node):
    """
    Returns true if node is 'condition and true_value or false_value' form.

    All of: condition, true_value and false_value should not be a complex boolean expression
    """
    return (
        isinstance(node, nodes.BoolOp)
        and node.op == "or"
        and len(node.values) == 2
        and isinstance(node.values[0], nodes.BoolOp)
        and not isinstance(node.values[1], nodes.BoolOp)
        and node.values[0].op == "and"
        and not isinstance(node.values[0].values[1], nodes.BoolOp)
        and len(node.values[0].values) == 2
    )

</t>
<t tx="ekr.20220312061835.999">@staticmethod
def _and_or_ternary_arguments(node):
    false_value = node.values[1]
    condition, true_value = node.values[0].values
    return condition, true_value, false_value

</t>
<t tx="ekr.20220404130423.1">@nosearch

# Word, Ignore Case, Head, Body

# found 43 nodes</t>
<t tx="ekr.20220404130439.1"></t>
<t tx="ekr.20220404130629.1"></t>
<t tx="ekr.20220404131315.1"></t>
<t tx="ekr.20220404133051.1">@nosearch

# Word, Ignore Case, Head, Body

# found 2 nodes</t>
<t tx="ekr.20220404133153.1"></t>
<t tx="ekr.20220404133238.1">@nosearch

# Word, Ignore Case, Head, Body

# found 2 nodes</t>
</tnodes>
</leo_file>
