<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20100212224846.10606"><vh>Startup</vh>
<v t="ekr.20100212224846.4235"><vh>@chapters</vh></v>
</v>
<v t="ekr.20100213083546.5119"><vh>Debugger code and notes</vh>
<v t="ekr.20100213083546.5120"><vh>C:\Python26\Lib\bdb.py</vh>
<v t="ekr.20100213083546.5121"><vh>bdb declarations</vh></v>
<v t="ekr.20100213083546.5122"><vh>class BdbQuit</vh></v>
<v t="ekr.20100213083546.5163"><vh>class Bdb</vh>
<v t="ekr.20100213083546.5164"><vh>__init__</vh></v>
<v t="ekr.20100213083546.5165"><vh>canonic</vh></v>
<v t="ekr.20100213083546.5166"><vh>reset</vh></v>
<v t="ekr.20100213083546.5167"><vh>trace_dispatch</vh></v>
<v t="ekr.20100213083546.5168"><vh>dispatch_line</vh></v>
<v t="ekr.20100213083546.5169"><vh>dispatch_call</vh></v>
<v t="ekr.20100213083546.5170"><vh>dispatch_return</vh></v>
<v t="ekr.20100213083546.5171"><vh>dispatch_exception</vh></v>
<v t="ekr.20100213083546.5172"><vh>stop_here</vh></v>
<v t="ekr.20100213083546.5173"><vh>break_here</vh></v>
<v t="ekr.20100213083546.5174"><vh>do_clear</vh></v>
<v t="ekr.20100213083546.5175"><vh>break_anywhere</vh></v>
<v t="ekr.20100213083546.5176"><vh>user_call</vh></v>
<v t="ekr.20100213083546.5177"><vh>user_line</vh></v>
<v t="ekr.20100213083546.5178"><vh>user_return</vh></v>
<v t="ekr.20100213083546.5179"><vh>user_exception</vh></v>
<v t="ekr.20100213083546.5180"><vh>_set_stopinfo</vh></v>
<v t="ekr.20100213083546.5181"><vh>set_until</vh></v>
<v t="ekr.20100213083546.5182"><vh>set_step</vh></v>
<v t="ekr.20100213083546.5183"><vh>set_next</vh></v>
<v t="ekr.20100213083546.5184"><vh>set_return</vh></v>
<v t="ekr.20100213083546.5185"><vh>set_trace</vh></v>
<v t="ekr.20100213083546.5186"><vh>set_continue</vh></v>
<v t="ekr.20100213083546.5187"><vh>set_quit</vh></v>
<v t="ekr.20100213083546.5188"><vh>set_break</vh></v>
<v t="ekr.20100213083546.5189"><vh>clear_break</vh></v>
<v t="ekr.20100213083546.5190"><vh>clear_bpbynumber</vh></v>
<v t="ekr.20100213083546.5191"><vh>clear_all_file_breaks</vh></v>
<v t="ekr.20100213083546.5192"><vh>clear_all_breaks</vh></v>
<v t="ekr.20100213083546.5193"><vh>get_break</vh></v>
<v t="ekr.20100213083546.5194"><vh>get_breaks</vh></v>
<v t="ekr.20100213083546.5195"><vh>get_file_breaks</vh></v>
<v t="ekr.20100213083546.5196"><vh>get_all_breaks</vh></v>
<v t="ekr.20100213083546.5197"><vh>get_stack</vh></v>
<v t="ekr.20100213083546.5198"><vh>format_stack_entry</vh></v>
<v t="ekr.20100213083546.5199"><vh>run</vh></v>
<v t="ekr.20100213083546.5200"><vh>runeval</vh></v>
<v t="ekr.20100213083546.5201"><vh>runctx</vh></v>
<v t="ekr.20100213083546.5202"><vh>runcall</vh></v>
</v>
<v t="ekr.20100213083546.5204"><vh>class Breakpoint</vh>
<v t="ekr.20100213083546.5205"><vh>__init__</vh></v>
<v t="ekr.20100213083546.5206"><vh>deleteMe</vh></v>
<v t="ekr.20100213083546.5207"><vh>enable</vh></v>
<v t="ekr.20100213083546.5208"><vh>disable</vh></v>
<v t="ekr.20100213083546.5209"><vh>bpprint</vh></v>
</v>
<v t="ekr.20100213083546.5335"><vh>Functions</vh>
<v t="ekr.20100213083546.5203"><vh>set_trace</vh></v>
<v t="ekr.20100213083546.5210"><vh>checkfuncname</vh></v>
<v t="ekr.20100213083546.5211"><vh>effective</vh></v>
</v>
<v t="ekr.20100213083546.5336"><vh>Testing</vh>
<v t="ekr.20100213083546.5212"><vh>class Tdb</vh>
<v t="ekr.20100213083546.5213"><vh>user_call</vh></v>
<v t="ekr.20100213083546.5214"><vh>user_line</vh></v>
<v t="ekr.20100213083546.5215"><vh>user_return</vh></v>
<v t="ekr.20100213083546.5216"><vh>user_exception</vh></v>
</v>
<v t="ekr.20100213083546.5217"><vh>foo</vh></v>
<v t="ekr.20100213083546.5218"><vh>bar</vh></v>
<v t="ekr.20100213083546.5219"><vh>test</vh></v>
</v>
</v>
<v t="ekr.20100213083546.5220"><vh>C:\Python26\Lib\pdb.py</vh>
<v t="ekr.20100213083546.5221"><vh>pdb declarations</vh></v>
<v t="ekr.20100213083546.5222"><vh>class Restart(Exception)</vh></v>
<v t="ekr.20100213083546.5223"><vh>find_function</vh></v>
<v t="ekr.20100213083546.5224"><vh>class Pdb</vh>
<v t="ekr.20100213083546.5225"><vh>__init__</vh></v>
<v t="ekr.20100213083546.5226"><vh>reset</vh></v>
<v t="ekr.20100213083546.5227"><vh>forget</vh></v>
<v t="ekr.20100213083546.5228"><vh>setup</vh></v>
<v t="ekr.20100213083546.5229"><vh>execRcLines</vh></v>
<v t="ekr.20100213083546.5337"><vh>Overrides of bdb methods</vh>
<v t="ekr.20100213083546.5230"><vh>user_call</vh></v>
<v t="ekr.20100213083546.5231"><vh>user_line</vh></v>
<v t="ekr.20100213083546.5232"><vh>bp_commands</vh></v>
<v t="ekr.20100213083546.5233"><vh>user_return</vh></v>
<v t="ekr.20100213083546.5234"><vh>user_exception</vh></v>
</v>
<v t="ekr.20100213083546.5235"><vh>interaction</vh></v>
<v t="ekr.20100213083546.5236"><vh>displayhook</vh></v>
<v t="ekr.20100213083546.5237"><vh>default</vh></v>
<v t="ekr.20100213083546.5238"><vh>precmd</vh></v>
<v t="ekr.20100213083546.5239"><vh>onecmd</vh></v>
<v t="ekr.20100213083546.5240"><vh>handle_command_def</vh></v>
<v t="ekr.20100213083546.5241"><vh>do_commands</vh></v>
<v t="ekr.20100213083546.5242"><vh>do_break</vh></v>
<v t="ekr.20100213083546.5243"><vh>defaultFile</vh></v>
<v t="ekr.20100213083546.5244"><vh>do_tbreak</vh></v>
<v t="ekr.20100213083546.5245"><vh>lineinfo</vh></v>
<v t="ekr.20100213083546.5246"><vh>checkline</vh></v>
<v t="ekr.20100213083546.5247"><vh>do_enable</vh></v>
<v t="ekr.20100213083546.5248"><vh>do_disable</vh></v>
<v t="ekr.20100213083546.5249"><vh>do_condition</vh></v>
<v t="ekr.20100213083546.5250"><vh>do_ignore</vh></v>
<v t="ekr.20100213083546.5251"><vh>do_clear</vh></v>
<v t="ekr.20100213083546.5252"><vh>do_where</vh></v>
<v t="ekr.20100213083546.5253"><vh>do_up</vh></v>
<v t="ekr.20100213083546.5254"><vh>do_down</vh></v>
<v t="ekr.20100213083546.5255"><vh>do_until</vh></v>
<v t="ekr.20100213083546.5256"><vh>do_step</vh></v>
<v t="ekr.20100213083546.5257"><vh>do_next</vh></v>
<v t="ekr.20100213083546.5258"><vh>do_run</vh></v>
<v t="ekr.20100213083546.5259"><vh>do_return</vh></v>
<v t="ekr.20100213083546.5260"><vh>do_continue</vh></v>
<v t="ekr.20100213083546.5261"><vh>do_jump</vh></v>
<v t="ekr.20100213083546.5262"><vh>do_debug</vh></v>
<v t="ekr.20100213083546.5263"><vh>do_quit</vh></v>
<v t="ekr.20100213083546.5264"><vh>do_EOF</vh></v>
<v t="ekr.20100213083546.5265"><vh>do_args</vh></v>
<v t="ekr.20100213083546.5266"><vh>do_retval</vh></v>
<v t="ekr.20100213083546.5267"><vh>_getval</vh></v>
<v t="ekr.20100213083546.5268"><vh>do_p</vh></v>
<v t="ekr.20100213083546.5269"><vh>do_pp</vh></v>
<v t="ekr.20100213083546.5270"><vh>do_list</vh></v>
<v t="ekr.20100213083546.5271"><vh>do_whatis</vh></v>
<v t="ekr.20100213083546.5272"><vh>do_alias</vh></v>
<v t="ekr.20100213083546.5273"><vh>do_unalias</vh></v>
<v t="ekr.20100213083546.5274"><vh>print_stack_trace</vh></v>
<v t="ekr.20100213083546.5275"><vh>print_stack_entry</vh></v>
<v t="ekr.20100213083546.5276"><vh>help_help</vh></v>
<v t="ekr.20100213083546.5277"><vh>help_h</vh></v>
<v t="ekr.20100213083546.5278"><vh>help_where</vh></v>
<v t="ekr.20100213083546.5279"><vh>help_w</vh></v>
<v t="ekr.20100213083546.5280"><vh>help_down</vh></v>
<v t="ekr.20100213083546.5281"><vh>help_d</vh></v>
<v t="ekr.20100213083546.5282"><vh>help_up</vh></v>
<v t="ekr.20100213083546.5283"><vh>help_u</vh></v>
<v t="ekr.20100213083546.5284"><vh>help_break</vh></v>
<v t="ekr.20100213083546.5285"><vh>help_b</vh></v>
<v t="ekr.20100213083546.5286"><vh>help_clear</vh></v>
<v t="ekr.20100213083546.5287"><vh>help_cl</vh></v>
<v t="ekr.20100213083546.5288"><vh>help_tbreak</vh></v>
<v t="ekr.20100213083546.5289"><vh>help_enable</vh></v>
<v t="ekr.20100213083546.5290"><vh>help_disable</vh></v>
<v t="ekr.20100213083546.5291"><vh>help_ignore</vh></v>
<v t="ekr.20100213083546.5292"><vh>help_condition</vh></v>
<v t="ekr.20100213083546.5293"><vh>help_step</vh></v>
<v t="ekr.20100213083546.5294"><vh>help_s</vh></v>
<v t="ekr.20100213083546.5295"><vh>help_until</vh></v>
<v t="ekr.20100213083546.5296"><vh>help_unt</vh></v>
<v t="ekr.20100213083546.5297"><vh>help_next</vh></v>
<v t="ekr.20100213083546.5298"><vh>help_n</vh></v>
<v t="ekr.20100213083546.5299"><vh>help_return</vh></v>
<v t="ekr.20100213083546.5300"><vh>help_r</vh></v>
<v t="ekr.20100213083546.5301"><vh>help_continue</vh></v>
<v t="ekr.20100213083546.5302"><vh>help_cont</vh></v>
<v t="ekr.20100213083546.5303"><vh>help_c</vh></v>
<v t="ekr.20100213083546.5304"><vh>help_jump</vh></v>
<v t="ekr.20100213083546.5305"><vh>help_j</vh></v>
<v t="ekr.20100213083546.5306"><vh>help_debug</vh></v>
<v t="ekr.20100213083546.5307"><vh>help_list</vh></v>
<v t="ekr.20100213083546.5308"><vh>help_l</vh></v>
<v t="ekr.20100213083546.5309"><vh>help_args</vh></v>
<v t="ekr.20100213083546.5310"><vh>help_a</vh></v>
<v t="ekr.20100213083546.5311"><vh>help_p</vh></v>
<v t="ekr.20100213083546.5312"><vh>help_pp</vh></v>
<v t="ekr.20100213083546.5313"><vh>help_exec</vh></v>
<v t="ekr.20100213083546.5314"><vh>help_run</vh></v>
<v t="ekr.20100213083546.5315"><vh>help_quit</vh></v>
<v t="ekr.20100213083546.5316"><vh>help_q</vh></v>
<v t="ekr.20100213083546.5317"><vh>help_whatis</vh></v>
<v t="ekr.20100213083546.5318"><vh>help_EOF</vh></v>
<v t="ekr.20100213083546.5319"><vh>help_alias</vh></v>
<v t="ekr.20100213083546.5320"><vh>help_unalias</vh></v>
<v t="ekr.20100213083546.5321"><vh>help_commands</vh></v>
<v t="ekr.20100213083546.5322"><vh>help_pdb</vh></v>
<v t="ekr.20100213083546.5323"><vh>lookupmodule</vh></v>
<v t="ekr.20100213083546.5324"><vh>_runscript</vh></v>
</v>
<v t="ekr.20100213083546.5325"><vh>run</vh></v>
<v t="ekr.20100213083546.5326"><vh>runeval</vh></v>
<v t="ekr.20100213083546.5327"><vh>runctx</vh></v>
<v t="ekr.20100213083546.5328"><vh>runcall</vh></v>
<v t="ekr.20100213083546.5329"><vh>set_trace</vh></v>
<v t="ekr.20100213083546.5330"><vh>post_mortem</vh></v>
<v t="ekr.20100213083546.5331"><vh>pm</vh></v>
<v t="ekr.20100213083546.5332"><vh>test</vh></v>
<v t="ekr.20100213083546.5333"><vh>help</vh></v>
<v t="ekr.20100213083546.5334"><vh>main</vh></v>
</v>
<v t="ekr.20100213083546.5339"><vh>.pdbrc</vh></v>
<v t="ekr.20100213083546.5340"><vh>Breakpoints</vh></v>
</v>
<v t="ekr.20100214212449.8246"><vh>The bug fix</vh>
<v t="ekr.20100212224846.9551"><vh>_set_proxied</vh></v>
</v>
<v t="ekr.20100212224846.9536"><vh>astng</vh>
<v t="ekr.20100212224846.10607"><vh>Copyright</vh></v>
<v t="ekr.20100212224846.9537"><vh>builder.py</vh>
<v t="ekr.20100212224846.9538"><vh>builder declarations</vh></v>
<v t="ekr.20100212224846.9539"><vh>class ASTNGBuilder</vh>
<v t="ekr.20100212224846.9540"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9541"><vh>module_build</vh></v>
<v t="ekr.20100212224846.9542"><vh>inspect_build</vh></v>
<v t="ekr.20100212224846.9543"><vh>file_build</vh></v>
<v t="ekr.20100212224846.9544"><vh>string_build</vh></v>
<v t="ekr.20100212224846.9545"><vh>ast_build</vh></v>
<v t="ekr.20100212224846.9546"><vh>object_build</vh></v>
<v t="ekr.20100212224846.9547"><vh>_member_module</vh></v>
</v>
<v t="ekr.20100212224846.9548"><vh>imported_member</vh></v>
</v>
<v t="ekr.20100212224846.9549"><vh>inference.py</vh>
<v t="ekr.20100212224846.9550"><vh>inference declarations</vh></v>
<v t="ekr.20100212224846.9551"></v>
<v t="ekr.20100212224846.9552"><vh>Const_pytype</vh></v>
<v t="ekr.20100212224846.9553"><vh>class CallContext</vh>
<v t="ekr.20100212224846.9554"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9555"><vh>infer_argument</vh></v>
</v>
<v t="ekr.20100214233301.4659"><vh>infer methods</vh>
<v t="ekr.20100212224846.9556"><vh>infer_default</vh></v>
<v t="ekr.20100212224846.9557"><vh>infer_end</vh></v>
<v t="ekr.20100212224846.9558"><vh>infer_name</vh></v>
<v t="ekr.20100212224846.9559"><vh>infer_callfunc</vh></v>
<v t="ekr.20100212224846.9560"><vh>infer_import</vh></v>
<v t="ekr.20100212224846.9561"><vh>infer_name_module</vh></v>
<v t="ekr.20100212224846.9562"><vh>infer_from</vh></v>
<v t="ekr.20100212224846.9563"><vh>infer_getattr</vh></v>
<v t="ekr.20100212224846.9564"><vh>infer_global</vh></v>
<v t="ekr.20100212224846.9565"><vh>infer_subscript</vh></v>
<v t="ekr.20100212224846.9566"><vh>infer_unaryop</vh></v>
<v t="ekr.20100212224846.9568"><vh>infer_binop &amp; helper</vh>
<v t="ekr.20100212224846.10608"><vh>_infer_binop</vh></v>
</v>
<v t="ekr.20100212224846.9569"><vh>infer_arguments</vh></v>
<v t="ekr.20100212224846.9570"><vh>infer_ass</vh></v>
<v t="ekr.20100212224846.9571"><vh>infer_augassign</vh></v>
<v t="ekr.20100212224846.9572"><vh>infer_empty_node</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9573"><vh>infutils.py</vh>
<v t="ekr.20100212224846.9574"><vh>infutils declarations</vh></v>
<v t="ekr.20100212224846.9575"><vh>class Proxy</vh>
<v t="ekr.20100212224846.9576"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9577"><vh>__getattr__</vh></v>
<v t="ekr.20100212224846.9578"><vh>infer</vh></v>
</v>
<v t="ekr.20100212224846.9579"><vh>class InferenceContext</vh>
<v t="ekr.20100212224846.9580"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9581"><vh>push</vh></v>
<v t="ekr.20100212224846.9582"><vh>pop</vh></v>
<v t="ekr.20100212224846.9583"><vh>clone</vh></v>
</v>
<v t="ekr.20100212224846.9584"><vh>are_exclusive</vh></v>
<v t="ekr.20100212224846.9585"><vh>unpack_infer</vh></v>
<v t="ekr.20100212224846.9586"><vh>copy_context</vh></v>
<v t="ekr.20100212224846.9587"><vh>_infer_stmts</vh></v>
<v t="ekr.20100212224846.9588"><vh>class _Yes</vh>
<v t="ekr.20100212224846.9589"><vh>__repr__</vh></v>
<v t="ekr.20100212224846.9590"><vh>__getattribute__</vh></v>
<v t="ekr.20100212224846.9591"><vh>__call__</vh></v>
</v>
<v t="ekr.20100212224846.9592"><vh>path_wrapper</vh></v>
<v t="ekr.20100212224846.9593"><vh>yes_if_nothing_infered</vh></v>
<v t="ekr.20100212224846.9594"><vh>raise_if_nothing_infered</vh></v>
<v t="ekr.20100212224846.9595"><vh>class Instance</vh>
<v t="ekr.20100212224846.9596"><vh>getattr</vh></v>
<v t="ekr.20100212224846.9597"><vh>igetattr</vh></v>
<v t="ekr.20100212224846.9598"><vh>_wrap_attr</vh></v>
<v t="ekr.20100212224846.9599"><vh>infer_call_result</vh></v>
<v t="ekr.20100212224846.9600"><vh>__repr__</vh></v>
<v t="ekr.20100212224846.9601"><vh>__str__</vh></v>
<v t="ekr.20100212224846.9602"><vh>callable</vh></v>
<v t="ekr.20100212224846.9603"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9604"><vh>display_type</vh></v>
</v>
<v t="ekr.20100212224846.9605"><vh>class UnboundMethod</vh>
<v t="ekr.20100212224846.9606"><vh>__repr__</vh></v>
<v t="ekr.20100212224846.9607"><vh>is_bound</vh></v>
<v t="ekr.20100212224846.9608"><vh>getattr</vh></v>
<v t="ekr.20100212224846.9609"><vh>igetattr</vh></v>
</v>
<v t="ekr.20100212224846.9610"><vh>class BoundMethod</vh>
<v t="ekr.20100212224846.9611"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9612"><vh>is_bound</vh></v>
<v t="ekr.20100212224846.9613"><vh>infer_call_result</vh></v>
</v>
<v t="ekr.20100212224846.9614"><vh>class Generator</vh>
<v t="ekr.20100212224846.9615"><vh>callable</vh></v>
<v t="ekr.20100212224846.9616"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9617"><vh>display_type</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9618"><vh>inspector.py</vh>
<v t="ekr.20100212224846.9619"><vh>inspector declarations</vh></v>
<v t="ekr.20100212224846.9620"><vh>class IdGeneratorMixIn</vh>
<v t="ekr.20100212224846.9621"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9622"><vh>init_counter</vh></v>
<v t="ekr.20100212224846.9623"><vh>generate_id</vh></v>
</v>
<v t="ekr.20100212224846.9624"><vh>class Linker</vh>
<v t="ekr.20100212224846.9625"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9626"><vh>visit_project</vh></v>
<v t="ekr.20100212224846.9627"><vh>visit_package</vh></v>
<v t="ekr.20100212224846.9628"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.9629"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.9630"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.9631"><vh>visit_assname</vh></v>
<v t="ekr.20100212224846.9632"><vh>handle_assattr_type</vh></v>
<v t="ekr.20100212224846.9633"><vh>visit_import</vh></v>
<v t="ekr.20100212224846.9634"><vh>visit_from</vh></v>
<v t="ekr.20100212224846.9635"><vh>compute_module</vh></v>
<v t="ekr.20100212224846.9636"><vh>_imported_module</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9637"><vh>lookup.py</vh>
<v t="ekr.20100212224846.9638"><vh>lookup declarations</vh></v>
<v t="ekr.20100212224846.9639"><vh>class LookupMixIn</vh>
<v t="ekr.20100212224846.9640"><vh>lookup</vh></v>
<v t="ekr.20100212224846.9641"><vh>ilookup</vh></v>
<v t="ekr.20100212224846.9642"><vh>_filter_stmts</vh></v>
</v>
<v t="ekr.20100212224846.9643"><vh>builtin_lookup</vh></v>
<v t="ekr.20100212224846.9644"><vh>class LocalsDictMixIn</vh>
<v t="ekr.20100212224846.9645"><vh>qname</vh></v>
<v t="ekr.20100212224846.9646"><vh>frame</vh></v>
<v t="ekr.20100212224846.9647"><vh>scope</vh></v>
<v t="ekr.20100212224846.9648"><vh>_scope_lookup</vh></v>
<v t="ekr.20100212224846.9649"><vh>set_local</vh></v>
<v t="ekr.20100212224846.9650"><vh>_append_node</vh></v>
<v t="ekr.20100212224846.9651"><vh>add_local_node</vh></v>
<v t="ekr.20100212224846.9652"><vh>__getitem__</vh></v>
<v t="ekr.20100212224846.9653"><vh>__iter__</vh></v>
<v t="ekr.20100212224846.9654"><vh>keys</vh></v>
<v t="ekr.20100212224846.9655"><vh>values</vh></v>
<v t="ekr.20100212224846.9656"><vh>items</vh></v>
<v t="ekr.20100212224846.9657"><vh>has_key</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9658"><vh>manager.py</vh>
<v t="ekr.20100212224846.9659"><vh>manager declarations</vh></v>
<v t="ekr.20100212224846.9660"><vh>astng_wrapper</vh></v>
<v t="ekr.20100212224846.9661"><vh>safe_repr</vh></v>
<v t="ekr.20100212224846.9662"><vh>zip_import_data</vh></v>
<v t="ekr.20100212224846.9663"><vh>class ASTNGManager</vh>
<v t="ekr.20100212224846.9664"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9665"><vh>set_cache_size</vh></v>
<v t="ekr.20100212224846.9666"><vh>from_directory</vh></v>
<v t="ekr.20100212224846.9667"><vh>astng_from_file</vh></v>
<v t="ekr.20100212224846.9668"><vh>astng_from_module_name</vh></v>
<v t="ekr.20100212224846.9669"><vh>file_from_module_name</vh></v>
<v t="ekr.20100212224846.9670"><vh>astng_from_module</vh></v>
<v t="ekr.20100212224846.9671"><vh>astng_from_class</vh></v>
<v t="ekr.20100212224846.9672"><vh>infer_astng_from_something</vh></v>
<v t="ekr.20100212224846.9673"><vh>project_from_files</vh></v>
</v>
<v t="ekr.20100212224846.9674"><vh>class Package</vh>
<v t="ekr.20100212224846.9675"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9676"><vh>fullname</vh></v>
<v t="ekr.20100212224846.9677"><vh>get_subobject</vh></v>
<v t="ekr.20100212224846.9678"><vh>get_module</vh></v>
<v t="ekr.20100212224846.9679"><vh>keys</vh></v>
<v t="ekr.20100212224846.9680"><vh>values</vh></v>
<v t="ekr.20100212224846.9681"><vh>items</vh></v>
<v t="ekr.20100212224846.9682"><vh>has_key</vh></v>
<v t="ekr.20100212224846.9683"><vh>get</vh></v>
<v t="ekr.20100212224846.9684"><vh>__getitem__</vh></v>
<v t="ekr.20100212224846.9685"><vh>__contains__</vh></v>
<v t="ekr.20100212224846.9686"><vh>__iter__</vh></v>
</v>
<v t="ekr.20100212224846.9687"><vh>class Project</vh>
<v t="ekr.20100212224846.9688"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9689"><vh>add_module</vh></v>
<v t="ekr.20100212224846.9690"><vh>get_module</vh></v>
<v t="ekr.20100212224846.9691"><vh>get_children</vh></v>
<v t="ekr.20100212224846.9692"><vh>__repr__</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9693"><vh>nodes.py</vh>
<v t="ekr.20100212224846.9694"><vh>nodes declarations</vh></v>
</v>
<v t="ekr.20100212224846.9695"><vh>nodes_as_string.py</vh>
<v t="ekr.20100212224846.9696"><vh>nodes_as_string declarations</vh></v>
<v t="ekr.20100212224846.9697"><vh>_import_string</vh></v>
<v t="ekr.20100212224846.9698"><vh>class AsStringVisitor</vh>
<v t="ekr.20100212224846.9699"><vh>__call__</vh></v>
<v t="ekr.20100212224846.9700"><vh>_stmt_list</vh></v>
<v t="ekr.20100212224846.9701"><vh>visit_arguments</vh></v>
<v t="ekr.20100212224846.9702"><vh>visit_assattr</vh></v>
<v t="ekr.20100212224846.9703"><vh>visit_assert</vh></v>
<v t="ekr.20100212224846.9704"><vh>visit_assname</vh></v>
<v t="ekr.20100212224846.9705"><vh>visit_assign</vh></v>
<v t="ekr.20100212224846.9706"><vh>visit_augassign</vh></v>
<v t="ekr.20100212224846.9707"><vh>visit_backquote</vh></v>
<v t="ekr.20100212224846.9708"><vh>visit_binop</vh></v>
<v t="ekr.20100212224846.9709"><vh>visit_boolop</vh></v>
<v t="ekr.20100212224846.9710"><vh>visit_break</vh></v>
<v t="ekr.20100212224846.9711"><vh>visit_callfunc</vh></v>
<v t="ekr.20100212224846.9712"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.9713"><vh>visit_compare</vh></v>
<v t="ekr.20100212224846.9714"><vh>visit_comprehension</vh></v>
<v t="ekr.20100212224846.9715"><vh>visit_const</vh></v>
<v t="ekr.20100212224846.9716"><vh>visit_continue</vh></v>
<v t="ekr.20100212224846.9717"><vh>visit_delete</vh></v>
<v t="ekr.20100212224846.9718"><vh>visit_delattr</vh></v>
<v t="ekr.20100212224846.9719"><vh>visit_delname</vh></v>
<v t="ekr.20100212224846.9720"><vh>visit_decorators</vh></v>
<v t="ekr.20100212224846.9721"><vh>visit_dict</vh></v>
<v t="ekr.20100212224846.9722"><vh>visit_discard</vh></v>
<v t="ekr.20100212224846.9723"><vh>visit_excepthandler</vh></v>
<v t="ekr.20100212224846.9724"><vh>visit_ellipsis</vh></v>
<v t="ekr.20100212224846.9725"><vh>visit_empty</vh></v>
<v t="ekr.20100212224846.9726"><vh>visit_exec</vh></v>
<v t="ekr.20100212224846.9727"><vh>visit_extslice</vh></v>
<v t="ekr.20100212224846.9728"><vh>visit_for</vh></v>
<v t="ekr.20100212224846.9729"><vh>visit_from</vh></v>
<v t="ekr.20100212224846.9730"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.9731"><vh>visit_genexpr</vh></v>
<v t="ekr.20100212224846.9732"><vh>visit_getattr</vh></v>
<v t="ekr.20100212224846.9733"><vh>visit_global</vh></v>
<v t="ekr.20100212224846.9734"><vh>visit_if</vh></v>
<v t="ekr.20100212224846.9735"><vh>visit_ifexp</vh></v>
<v t="ekr.20100212224846.9736"><vh>visit_import</vh></v>
<v t="ekr.20100212224846.9737"><vh>visit_keyword</vh></v>
<v t="ekr.20100212224846.9738"><vh>visit_lambda</vh></v>
<v t="ekr.20100212224846.9739"><vh>visit_list</vh></v>
<v t="ekr.20100212224846.9740"><vh>visit_listcomp</vh></v>
<v t="ekr.20100212224846.9741"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.9742"><vh>visit_name</vh></v>
<v t="ekr.20100212224846.9743"><vh>visit_pass</vh></v>
<v t="ekr.20100212224846.9744"><vh>visit_print</vh></v>
<v t="ekr.20100212224846.9745"><vh>visit_raise</vh></v>
<v t="ekr.20100212224846.9746"><vh>visit_return</vh></v>
<v t="ekr.20100212224846.9747"><vh>visit_index</vh></v>
<v t="ekr.20100212224846.9748"><vh>visit_slice</vh></v>
<v t="ekr.20100212224846.9749"><vh>visit_subscript</vh></v>
<v t="ekr.20100212224846.9750"><vh>visit_tryexcept</vh></v>
<v t="ekr.20100212224846.9751"><vh>visit_tryfinally</vh></v>
<v t="ekr.20100212224846.9752"><vh>visit_tuple</vh></v>
<v t="ekr.20100212224846.9753"><vh>visit_unaryop</vh></v>
<v t="ekr.20100212224846.9754"><vh>visit_while</vh></v>
<v t="ekr.20100212224846.9755"><vh>visit_with</vh></v>
<v t="ekr.20100212224846.9756"><vh>visit_yield</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9757"><vh>node_classes.py</vh>
<v t="ekr.20100212224846.9758"><vh>node_classes declarations</vh></v>
<v t="ekr.20100212224846.9759"><vh>class ArgumentsNG</vh>
<v t="ekr.20100212224846.9760"><vh>format_args</vh></v>
<v t="ekr.20100212224846.9761"><vh>default_value</vh></v>
<v t="ekr.20100212224846.9762"><vh>is_argument</vh></v>
<v t="ekr.20100212224846.9763"><vh>find_argname</vh></v>
</v>
<v t="ekr.20100212224846.9764"><vh>_find_arg</vh></v>
<v t="ekr.20100212224846.9765"><vh>_format_args</vh></v>
<v t="ekr.20100212224846.9766"><vh>class AssAttrNG</vh></v>
<v t="ekr.20100212224846.9767"><vh>class AssNameNG</vh></v>
<v t="ekr.20100212224846.9768"><vh>class AssertNG</vh></v>
<v t="ekr.20100212224846.9769"><vh>class AssignNG</vh></v>
<v t="ekr.20100212224846.9770"><vh>class AugAssignNG</vh></v>
<v t="ekr.20100212224846.9771"><vh>class BackquoteNG</vh></v>
<v t="ekr.20100212224846.9772"><vh>class BinOpNG</vh></v>
<v t="ekr.20100212224846.9773"><vh>class BoolOpNG</vh></v>
<v t="ekr.20100212224846.9774"><vh>class BreakNG</vh></v>
<v t="ekr.20100212224846.9775"><vh>class CallFuncNG</vh></v>
<v t="ekr.20100212224846.9776"><vh>class CompareNG</vh>
<v t="ekr.20100212224846.9777"><vh>get_children</vh></v>
</v>
<v t="ekr.20100212224846.9778"><vh>class ComprehensionNG</vh></v>
<v t="ekr.20100212224846.9779"><vh>class ConstNG</vh>
<v t="ekr.20100212224846.9780"><vh>getitem</vh></v>
<v t="ekr.20100212224846.9781"><vh>has_dynamic_getattr</vh></v>
<v t="ekr.20100212224846.9782"><vh>itered</vh></v>
</v>
<v t="ekr.20100212224846.9783"><vh>class ContinueNG</vh></v>
<v t="ekr.20100212224846.9784"><vh>class DecoratorsNG</vh>
<v t="ekr.20100212224846.9785"><vh>scope</vh></v>
</v>
<v t="ekr.20100212224846.9786"><vh>class DelAttrNG</vh></v>
<v t="ekr.20100212224846.9787"><vh>class DelNameNG</vh></v>
<v t="ekr.20100212224846.9788"><vh>class DeleteNG</vh></v>
<v t="ekr.20100212224846.9789"><vh>class DictNG</vh>
<v t="ekr.20100212224846.9790"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9791"><vh>get_children</vh></v>
<v t="ekr.20100212224846.9792"><vh>itered</vh></v>
<v t="ekr.20100212224846.9793"><vh>getitem</vh></v>
</v>
<v t="ekr.20100212224846.9794"><vh>class DiscardNG</vh></v>
<v t="ekr.20100212224846.9795"><vh>class EllipsisNG</vh></v>
<v t="ekr.20100212224846.9796"><vh>class EmptyNodeNG</vh></v>
<v t="ekr.20100212224846.9797"><vh>class ExceptHandlerNG</vh>
<v t="ekr.20100212224846.9798"><vh>_blockstart_toline</vh></v>
<v t="ekr.20100212224846.9799"><vh>set_line_info</vh></v>
<v t="ekr.20100212224846.9800"><vh>catch</vh></v>
</v>
<v t="ekr.20100212224846.9801"><vh>class ExecNG</vh></v>
<v t="ekr.20100212224846.9802"><vh>class ExtSliceNG</vh></v>
<v t="ekr.20100212224846.9803"><vh>class ForNG</vh>
<v t="ekr.20100212224846.9804"><vh>_blockstart_toline</vh></v>
</v>
<v t="ekr.20100212224846.9805"><vh>class FromImportMixIn</vh>
<v t="ekr.20100212224846.9806"><vh>do_import_module</vh></v>
<v t="ekr.20100212224846.9807"><vh>real_name</vh></v>
</v>
<v t="ekr.20100212224846.9808"><vh>class FromNG</vh></v>
<v t="ekr.20100212224846.9809"><vh>class GenExprNG</vh></v>
<v t="ekr.20100212224846.9810"><vh>class GetattrNG</vh></v>
<v t="ekr.20100212224846.9811"><vh>class GlobalNG</vh></v>
<v t="ekr.20100212224846.9812"><vh>class IfNG</vh>
<v t="ekr.20100212224846.9813"><vh>_blockstart_toline</vh></v>
<v t="ekr.20100212224846.9814"><vh>block_range</vh></v>
</v>
<v t="ekr.20100212224846.9815"><vh>class IfExpNG</vh></v>
<v t="ekr.20100212224846.9816"><vh>class ImportNG</vh></v>
<v t="ekr.20100212224846.9817"><vh>class IndexNG</vh></v>
<v t="ekr.20100212224846.9818"><vh>class KeywordNG</vh></v>
<v t="ekr.20100212224846.9819"><vh>class ListNG</vh>
<v t="ekr.20100212224846.9820"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9821"><vh>getitem</vh></v>
<v t="ekr.20100212224846.9822"><vh>itered</vh></v>
</v>
<v t="ekr.20100212224846.9823"><vh>class ListCompNG</vh></v>
<v t="ekr.20100212224846.9824"><vh>class NameNG</vh></v>
<v t="ekr.20100212224846.9825"><vh>class PassNG</vh></v>
<v t="ekr.20100212224846.9826"><vh>class PrintNG</vh></v>
<v t="ekr.20100212224846.9827"><vh>class RaiseNG</vh></v>
<v t="ekr.20100212224846.9828"><vh>class ReturnNG</vh></v>
<v t="ekr.20100212224846.9829"><vh>class SliceNG</vh></v>
<v t="ekr.20100212224846.9830"><vh>class SubscriptNG</vh></v>
<v t="ekr.20100212224846.9831"><vh>class TryExceptNG</vh>
<v t="ekr.20100212224846.9832"><vh>_blockstart_toline</vh></v>
<v t="ekr.20100212224846.9833"><vh>block_range</vh></v>
</v>
<v t="ekr.20100212224846.9834"><vh>class TryFinallyNG</vh>
<v t="ekr.20100212224846.9835"><vh>_blockstart_toline</vh></v>
<v t="ekr.20100212224846.9836"><vh>block_range</vh></v>
</v>
<v t="ekr.20100212224846.9837"><vh>class TupleNG</vh>
<v t="ekr.20100212224846.9838"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9839"><vh>getitem</vh></v>
<v t="ekr.20100212224846.9840"><vh>itered</vh></v>
</v>
<v t="ekr.20100212224846.9841"><vh>class UnaryOpNG</vh></v>
<v t="ekr.20100212224846.9842"><vh>class WhileNG</vh>
<v t="ekr.20100212224846.9843"><vh>_blockstart_toline</vh></v>
<v t="ekr.20100212224846.9844"><vh>block_range</vh></v>
</v>
<v t="ekr.20100212224846.9845"><vh>class WithNG</vh>
<v t="ekr.20100212224846.9846"><vh>_blockstart_toline</vh></v>
</v>
<v t="ekr.20100212224846.9847"><vh>class YieldNG</vh></v>
</v>
<v t="ekr.20100212224846.9848"><vh>patchcomptransformer.py</vh>
<v t="ekr.20100212224846.9849"><vh>patchcomptransformer declarations</vh></v>
<v t="ekr.20100212224846.9850"><vh>fromto_lineno</vh></v>
<v t="ekr.20100212224846.9851"><vh>from_lineno</vh></v>
<v t="ekr.20100212224846.9852"><vh>to_lineno</vh></v>
<v t="ekr.20100212224846.9853"><vh>fix_lineno</vh></v>
<v t="ekr.20100212224846.9854"><vh>fixlineno_wrap</vh></v>
<v t="ekr.20100212224846.9855"><vh>class ASTNGTransformer</vh>
<v t="ekr.20100212224846.9856"><vh>com_NEWLINE</vh></v>
<v t="ekr.20100212224846.9857"><vh>com_node</vh></v>
<v t="ekr.20100212224846.9858"><vh>com_assign</vh></v>
<v t="ekr.20100212224846.9859"><vh>com_apply_trailer</vh></v>
<v t="ekr.20100212224846.9860"><vh>funcdef</vh></v>
<v t="ekr.20100212224846.9861"><vh>lambdef</vh></v>
<v t="ekr.20100212224846.9862"><vh>classdef</vh></v>
<v t="ekr.20100212224846.9863"><vh>file_input</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9864"><vh>protocols.py</vh>
<v t="ekr.20100212224846.9865"><vh>protocols declarations</vh></v>
<v t="ekr.20100212224846.10611"><vh>Unary operations</vh>
<v t="ekr.20100212224846.9866"><vh>tl_infer_unary_op</vh></v>
<v t="ekr.20100212224846.9867"><vh>dict_infer_unary_op</vh></v>
<v t="ekr.20100212224846.9868"><vh>const_infer_unary_op</vh></v>
</v>
<v t="ekr.20100212224846.10610"><vh>Binary operations</vh>
<v t="ekr.20100212224846.9869"><vh>const_infer_binary_op</vh></v>
<v t="ekr.20100212224846.9870"><vh>tl_infer_binary_op</vh></v>
<v t="ekr.20100212224846.9871"><vh>dict_infer_binary_op</vh></v>
</v>
<v t="ekr.20100212224846.10612"><vh>Assignments</vh>
<v t="ekr.20100212224846.9872"><vh>_resolve_looppart</vh></v>
<v t="ekr.20100212224846.9873"><vh>for_assigned_stmts</vh></v>
<v t="ekr.20100212224846.9874"><vh>mulass_assigned_stmts</vh></v>
<v t="ekr.20100212224846.9875"><vh>assend_assigned_stmts</vh></v>
<v t="ekr.20100212224846.9877"><vh>arguments_assigned_stmts &amp; helper</vh>
<v t="ekr.20100212224846.9876"><vh>_arguments_infer_argname</vh></v>
</v>
<v t="ekr.20100212224846.9878"><vh>assign_assigned_stmts &amp; helper</vh>
<v t="ekr.20100212224846.9879"><vh>_resolve_asspart</vh></v>
</v>
<v t="ekr.20100212224846.9880"><vh>excepthandler_assigned_stmts</vh></v>
<v t="ekr.20100212224846.9881"><vh>with_assigned_stmts</vh></v>
<v t="ekr.20100212224846.9882"><vh>parent_ass_type</vh></v>
<v t="ekr.20100212224846.9883"><vh>end_ass_type</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9884"><vh>raw_building.py</vh>
<v t="ekr.20100212224846.9885"><vh>raw_building declarations</vh></v>
<v t="ekr.20100212224846.9886"><vh>_attach_local_node</vh></v>
<v t="ekr.20100212224846.9887"><vh>attach_dummy_node</vh></v>
<v t="ekr.20100212224846.9888"><vh>attach_const_node</vh></v>
<v t="ekr.20100212224846.9889"><vh>attach_import_node</vh></v>
<v t="ekr.20100212224846.9890"><vh>build_module</vh></v>
<v t="ekr.20100212224846.9891"><vh>build_class</vh></v>
<v t="ekr.20100212224846.9892"><vh>build_function</vh></v>
<v t="ekr.20100212224846.9893"><vh>register_arguments</vh></v>
<v t="ekr.20100212224846.9894"><vh>object_build_class</vh></v>
<v t="ekr.20100212224846.9895"><vh>object_build_function</vh></v>
<v t="ekr.20100212224846.9896"><vh>object_build_datadescriptor</vh></v>
<v t="ekr.20100212224846.9897"><vh>object_build_methoddescriptor</vh></v>
<v t="ekr.20100212224846.9898"><vh>_base_class_object_build</vh></v>
</v>
<v t="ekr.20100212224846.9899"><vh>rebuilder.py</vh>
<v t="ekr.20100212224846.9900"><vh>rebuilder declarations</vh></v>
<v t="ekr.20100212224846.9901"><vh>class RebuildVisitor</vh>
<v t="ekr.20100212224846.9902"><vh>__init__</vh></v>
<v t="ekr.20100212224846.9903"><vh>_push</vh></v>
<v t="ekr.20100212224846.9904"><vh>set_asscontext</vh></v>
<v t="ekr.20100212224846.9905"><vh>push_asscontext</vh></v>
<v t="ekr.20100212224846.9906"><vh>pop_asscontext</vh></v>
<v t="ekr.20100212224846.9907"><vh>walk</vh></v>
<v t="ekr.20100212224846.9908"><vh>_walk</vh></v>
<v t="ekr.20100212224846.9909"><vh>visit_arguments</vh></v>
<v t="ekr.20100212224846.9910"><vh>visit_assign</vh></v>
<v t="ekr.20100212224846.9911"><vh>leave_assign</vh></v>
<v t="ekr.20100212224846.9912"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.9913"><vh>leave_class</vh></v>
<v t="ekr.20100212224846.9914"><vh>visit_decorators</vh></v>
<v t="ekr.20100212224846.9915"><vh>leave_decorators</vh></v>
<v t="ekr.20100212224846.9916"><vh>visit_from</vh></v>
<v t="ekr.20100212224846.9917"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.9918"><vh>leave_function</vh></v>
<v t="ekr.20100212224846.9919"><vh>visit_genexpr</vh></v>
<v t="ekr.20100212224846.9920"><vh>visit_assattr</vh></v>
<v t="ekr.20100212224846.9921"><vh>leave_assattr</vh></v>
<v t="ekr.20100212224846.9922"><vh>visit_global</vh></v>
<v t="ekr.20100212224846.9923"><vh>visit_import</vh></v>
<v t="ekr.20100212224846.9924"><vh>visit_lambda</vh></v>
<v t="ekr.20100212224846.9925"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.9926"><vh>visit_name</vh></v>
<v t="ekr.20100212224846.9927"><vh>visit_assname</vh></v>
<v t="ekr.20100212224846.9928"><vh>delayed_visit_assattr</vh></v>
</v>
</v>
<v t="ekr.20100212224846.9929"><vh>scoped_nodes.py</vh>
<v t="ekr.20100212224846.9930"><vh>scoped_nodes declarations</vh></v>
<v t="ekr.20100212224846.9931"><vh>remove_nodes</vh></v>
<v t="ekr.20100212224846.9932"><vh>function_to_method</vh></v>
<v t="ekr.20100212224846.9933"><vh>std_special_attributes</vh></v>
<v t="ekr.20100212224846.10613"><vh>Module</vh>
<v t="ekr.20100212224846.9934"><vh>class ModuleNG</vh>
<v t="ekr.20100212224846.9935"><vh>replace</vh></v>
<v t="ekr.20100212224846.9936"><vh>block_range</vh></v>
<v t="ekr.20100212224846.9937"><vh>scope_lookup</vh></v>
<v t="ekr.20100212224846.9938"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9939"><vh>display_type</vh></v>
<v t="ekr.20100212224846.9940"><vh>getattr</vh></v>
<v t="ekr.20100212224846.9941"><vh>igetattr</vh></v>
<v t="ekr.20100212224846.9942"><vh>fully_defined</vh></v>
<v t="ekr.20100212224846.9943"><vh>statement</vh></v>
<v t="ekr.20100212224846.9944"><vh>previous_sibling</vh></v>
<v t="ekr.20100212224846.9945"><vh>next_sibling</vh></v>
<v t="ekr.20100212224846.9946"><vh>absolute_import_activated</vh></v>
<v t="ekr.20100212224846.9947"><vh>import_module</vh></v>
<v t="ekr.20100212224846.9948"><vh>absolute_modname</vh></v>
<v t="ekr.20100212224846.9949"><vh>wildcard_import_names</vh></v>
</v>
<v t="ekr.20100212224846.9950"><vh>class GenExprNG</vh>
<v t="ekr.20100212224846.9951"><vh>frame</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10614"><vh>Function</vh>
<v t="ekr.20100212224846.9952"><vh>class LambdaNG</vh>
<v t="ekr.20100212224846.9953"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9954"><vh>display_type</vh></v>
<v t="ekr.20100212224846.9955"><vh>callable</vh></v>
<v t="ekr.20100212224846.9956"><vh>argnames</vh></v>
<v t="ekr.20100212224846.9957"><vh>infer_call_result</vh></v>
<v t="ekr.20100212224846.9958"><vh>scope_lookup</vh></v>
</v>
<v t="ekr.20100212224846.9959"><vh>class FunctionNG</vh>
<v t="ekr.20100212224846.9960"><vh>set_line_info</vh></v>
<v t="ekr.20100212224846.9961"><vh>block_range</vh></v>
<v t="ekr.20100212224846.9962"><vh>getattr</vh></v>
<v t="ekr.20100212224846.9963"><vh>is_method</vh></v>
<v t="ekr.20100212224846.9964"><vh>decoratornames</vh></v>
<v t="ekr.20100212224846.9965"><vh>is_bound</vh></v>
<v t="ekr.20100212224846.9966"><vh>is_abstract</vh></v>
<v t="ekr.20100212224846.9967"><vh>is_generator</vh></v>
<v t="ekr.20100212224846.9968"><vh>infer_call_result</vh></v>
</v>
<v t="ekr.20100212224846.9969"><vh>_rec_get_names</vh></v>
<v t="ekr.20100212224846.9970"><vh>_format_args</vh></v>
</v>
<v t="ekr.20100212224846.10615"><vh>Class</vh>
<v t="ekr.20100212224846.9971"><vh>_class_type</vh></v>
<v t="ekr.20100212224846.9972"><vh>_iface_hdlr</vh></v>
<v t="ekr.20100212224846.9973"><vh>class ClassNG</vh>
<v t="ekr.20100212224846.9974"><vh>_newstyle_impl</vh></v>
<v t="ekr.20100212224846.9975"><vh>set_line_info</vh></v>
<v t="ekr.20100212224846.9976"><vh>block_range</vh></v>
<v t="ekr.20100212224846.9977"><vh>pytype</vh></v>
<v t="ekr.20100212224846.9978"><vh>display_type</vh></v>
<v t="ekr.20100212224846.9979"><vh>callable</vh></v>
<v t="ekr.20100212224846.9980"><vh>infer_call_result</vh></v>
<v t="ekr.20100212224846.9981"><vh>scope_lookup</vh></v>
<v t="ekr.20100212224846.9982"><vh>basenames</vh></v>
<v t="ekr.20100212224846.9983"><vh>ancestors</vh></v>
<v t="ekr.20100212224846.9984"><vh>local_attr_ancestors</vh></v>
<v t="ekr.20100212224846.9985"><vh>instance_attr_ancestors</vh></v>
<v t="ekr.20100212224846.9986"><vh>local_attr</vh></v>
<v t="ekr.20100212224846.9987"><vh>instance_attr</vh></v>
<v t="ekr.20100212224846.9988"><vh>getattr</vh></v>
<v t="ekr.20100212224846.9989"><vh>igetattr</vh></v>
<v t="ekr.20100212224846.9990"><vh>has_dynamic_getattr</vh></v>
<v t="ekr.20100212224846.9991"><vh>methods</vh></v>
<v t="ekr.20100212224846.9992"><vh>mymethods</vh></v>
<v t="ekr.20100212224846.9993"><vh>interfaces</vh></v>
</v>
</v>
</v>
<v t="ekr.20100212224846.9994"><vh>utils.py</vh>
<v t="ekr.20100212224846.9995"><vh>utils declarations</vh></v>
<v t="ekr.20100212224846.9996"><vh>extend_class</vh></v>
<v t="ekr.20100212224846.9997"><vh>class ASTVisitor</vh>
<v t="ekr.20100212224846.9998"><vh>visit_arguments</vh></v>
<v t="ekr.20100212224846.9999"><vh>visit_assattr</vh></v>
<v t="ekr.20100212224846.10000"><vh>visit_assert</vh></v>
<v t="ekr.20100212224846.10001"><vh>visit_assign</vh></v>
<v t="ekr.20100212224846.10002"><vh>visit_assname</vh></v>
<v t="ekr.20100212224846.10003"><vh>visit_augassign</vh></v>
<v t="ekr.20100212224846.10004"><vh>visit_backquote</vh></v>
<v t="ekr.20100212224846.10005"><vh>visit_binop</vh></v>
<v t="ekr.20100212224846.10006"><vh>visit_boolop</vh></v>
<v t="ekr.20100212224846.10007"><vh>visit_break</vh></v>
<v t="ekr.20100212224846.10008"><vh>visit_callfunc</vh></v>
<v t="ekr.20100212224846.10009"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.10010"><vh>visit_compare</vh></v>
<v t="ekr.20100212224846.10011"><vh>visit_comprehension</vh></v>
<v t="ekr.20100212224846.10012"><vh>visit_const</vh></v>
<v t="ekr.20100212224846.10013"><vh>visit_continue</vh></v>
<v t="ekr.20100212224846.10014"><vh>visit_decorators</vh></v>
<v t="ekr.20100212224846.10015"><vh>visit_delattr</vh></v>
<v t="ekr.20100212224846.10016"><vh>visit_delete</vh></v>
<v t="ekr.20100212224846.10017"><vh>visit_delname</vh></v>
<v t="ekr.20100212224846.10018"><vh>visit_dict</vh></v>
<v t="ekr.20100212224846.10019"><vh>visit_discard</vh></v>
<v t="ekr.20100212224846.10020"><vh>visit_emptynode</vh></v>
<v t="ekr.20100212224846.10021"><vh>visit_excepthandler</vh></v>
<v t="ekr.20100212224846.10022"><vh>visit_ellipsis</vh></v>
<v t="ekr.20100212224846.10023"><vh>visit_empty</vh></v>
<v t="ekr.20100212224846.10024"><vh>visit_exec</vh></v>
<v t="ekr.20100212224846.10025"><vh>visit_extslice</vh></v>
<v t="ekr.20100212224846.10026"><vh>visit_for</vh></v>
<v t="ekr.20100212224846.10027"><vh>visit_from</vh></v>
<v t="ekr.20100212224846.10028"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.10029"><vh>visit_genexpr</vh></v>
<v t="ekr.20100212224846.10030"><vh>visit_getattr</vh></v>
<v t="ekr.20100212224846.10031"><vh>visit_global</vh></v>
<v t="ekr.20100212224846.10032"><vh>visit_if</vh></v>
<v t="ekr.20100212224846.10033"><vh>visit_ifexp</vh></v>
<v t="ekr.20100212224846.10034"><vh>visit_import</vh></v>
<v t="ekr.20100212224846.10035"><vh>visit_index</vh></v>
<v t="ekr.20100212224846.10036"><vh>visit_keyword</vh></v>
<v t="ekr.20100212224846.10037"><vh>visit_lambda</vh></v>
<v t="ekr.20100212224846.10038"><vh>visit_list</vh></v>
<v t="ekr.20100212224846.10039"><vh>visit_listcomp</vh></v>
<v t="ekr.20100212224846.10040"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.10041"><vh>visit_name</vh></v>
<v t="ekr.20100212224846.10042"><vh>visit_pass</vh></v>
<v t="ekr.20100212224846.10043"><vh>visit_print</vh></v>
<v t="ekr.20100212224846.10044"><vh>visit_raise</vh></v>
<v t="ekr.20100212224846.10045"><vh>visit_return</vh></v>
<v t="ekr.20100212224846.10046"><vh>visit_slice</vh></v>
<v t="ekr.20100212224846.10047"><vh>visit_subscript</vh></v>
<v t="ekr.20100212224846.10048"><vh>visit_tryexcept</vh></v>
<v t="ekr.20100212224846.10049"><vh>visit_tryfinally</vh></v>
<v t="ekr.20100212224846.10050"><vh>visit_tuple</vh></v>
<v t="ekr.20100212224846.10051"><vh>visit_unaryop</vh></v>
<v t="ekr.20100212224846.10052"><vh>visit_while</vh></v>
<v t="ekr.20100212224846.10053"><vh>visit_with</vh></v>
<v t="ekr.20100212224846.10054"><vh>visit_yield</vh></v>
</v>
<v t="ekr.20100212224846.10055"><vh>class ASTWalker</vh>
<v t="ekr.20100212224846.10056"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10057"><vh>walk</vh></v>
<v t="ekr.20100212224846.10058"><vh>get_callbacks</vh></v>
<v t="ekr.20100212224846.10059"><vh>visit</vh></v>
<v t="ekr.20100212224846.10060"><vh>leave</vh></v>
</v>
<v t="ekr.20100212224846.10061"><vh>class LocalsVisitor</vh>
<v t="ekr.20100212224846.10062"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10063"><vh>visit</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10064"><vh>_exceptions.py</vh>
<v t="ekr.20100212224846.10065"><vh>_exceptions declarations</vh></v>
<v t="ekr.20100212224846.10066"><vh>class ASTNGError</vh></v>
<v t="ekr.20100212224846.10067"><vh>class ASTNGBuildingException</vh></v>
<v t="ekr.20100212224846.10068"><vh>class ResolveError</vh></v>
<v t="ekr.20100212224846.10069"><vh>class NotFoundError</vh></v>
<v t="ekr.20100212224846.10070"><vh>class InferenceError</vh></v>
<v t="ekr.20100212224846.10071"><vh>class UnresolvableName</vh></v>
<v t="ekr.20100212224846.10072"><vh>class NoDefault</vh></v>
<v t="ekr.20100212224846.10073"><vh>class IgnoreChild</vh></v>
<v t="ekr.20100212224846.10074"><vh>class NodeRemoved</vh></v>
</v>
<v t="ekr.20100212224846.10075"><vh>_nodes.py</vh>
<v t="ekr.20100212224846.10076"><vh>_nodes declarations</vh></v>
<v t="ekr.20100212224846.10077"><vh>class NodeNG</vh>
<v t="ekr.20100212224846.10078"><vh>__str__</vh></v>
<v t="ekr.20100212224846.10079"><vh>accept</vh></v>
<v t="ekr.20100212224846.10080"><vh>get_children</vh></v>
<v t="ekr.20100212224846.10081"><vh>parent_of</vh></v>
<v t="ekr.20100212224846.10082"><vh>statement</vh></v>
<v t="ekr.20100212224846.10083"><vh>frame</vh></v>
<v t="ekr.20100212224846.10084"><vh>scope</vh></v>
<v t="ekr.20100212224846.10085"><vh>root</vh></v>
<v t="ekr.20100212224846.10086"><vh>child_sequence</vh></v>
<v t="ekr.20100212224846.10087"><vh>locate_child</vh></v>
<v t="ekr.20100212224846.10088"><vh>next_sibling</vh></v>
<v t="ekr.20100212224846.10089"><vh>previous_sibling</vh></v>
<v t="ekr.20100212224846.10090"><vh>nearest</vh></v>
<v t="ekr.20100212224846.10091"><vh>set_line_info</vh></v>
<v t="ekr.20100212224846.10092"><vh>_fixed_source_line</vh></v>
<v t="ekr.20100212224846.10093"><vh>block_range</vh></v>
<v t="ekr.20100212224846.10094"><vh>set_local</vh></v>
<v t="ekr.20100212224846.10095"><vh>nodes_of_class</vh></v>
<v t="ekr.20100212224846.10096"><vh>_infer_name</vh></v>
<v t="ekr.20100212224846.10097"><vh>callable</vh></v>
<v t="ekr.20100212224846.10098"><vh>eq</vh></v>
<v t="ekr.20100212224846.10099"><vh>as_string</vh></v>
<v t="ekr.20100212224846.10100"><vh>repr_tree</vh></v>
</v>
<v t="ekr.20100212224846.10101"><vh>_repr_tree</vh></v>
<v t="ekr.20100212224846.10102"><vh>class StmtMixIn</vh>
<v t="ekr.20100212224846.10103"><vh>replace</vh></v>
<v t="ekr.20100212224846.10104"><vh>next_sibling</vh></v>
<v t="ekr.20100212224846.10105"><vh>previous_sibling</vh></v>
</v>
<v t="ekr.20100212224846.10106"><vh>class BlockRangeMixIn</vh>
<v t="ekr.20100212224846.10107"><vh>set_line_info</vh></v>
<v t="ekr.20100212224846.10108"><vh>_elsed_block_range</vh></v>
</v>
<v t="ekr.20100212224846.10109"><vh>const_factory</vh></v>
</v>
<v t="ekr.20100212224846.10110"><vh>_nodes_ast.py</vh>
<v t="ekr.20100212224846.10111"><vh>_nodes_ast declarations</vh></v>
<v t="ekr.20100212224846.10112"><vh>_init_set_doc</vh></v>
<v t="ekr.20100212224846.10113"><vh>native_repr_tree</vh></v>
<v t="ekr.20100212224846.10114"><vh>class AssAttr</vh></v>
<v t="ekr.20100212224846.10115"><vh>class AssName</vh></v>
<v t="ekr.20100212224846.10116"><vh>class Const</vh>
<v t="ekr.20100212224846.10117"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10118"><vh>class DelAttr</vh></v>
<v t="ekr.20100212224846.10119"><vh>class DelName</vh></v>
<v t="ekr.20100212224846.10120"><vh>class EmptyNode</vh></v>
<v t="ekr.20100212224846.10121"><vh>class Decorators</vh>
<v t="ekr.20100212224846.10122"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10123"><vh>class TreeRebuilder</vh>
<v t="ekr.20100212224846.10124"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10125"><vh>visit_assert</vh></v>
<v t="ekr.20100212224846.10126"><vh>visit_augassign</vh></v>
<v t="ekr.20100212224846.10127"><vh>visit_binop</vh></v>
<v t="ekr.20100212224846.10128"><vh>visit_boolop</vh></v>
<v t="ekr.20100212224846.10129"><vh>visit_callfunc</vh></v>
<v t="ekr.20100212224846.10130"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.10131"><vh>visit_compare</vh></v>
<v t="ekr.20100212224846.10132"><vh>visit_dict</vh></v>
<v t="ekr.20100212224846.10133"><vh>visit_exec</vh></v>
<v t="ekr.20100212224846.10134"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.10135"><vh>visit_getattr</vh></v>
<v t="ekr.20100212224846.10136"><vh>visit_import</vh></v>
<v t="ekr.20100212224846.10137"><vh>visit_from</vh></v>
<v t="ekr.20100212224846.10138"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.10139"><vh>visit_name</vh></v>
<v t="ekr.20100212224846.10140"><vh>visit_num</vh></v>
<v t="ekr.20100212224846.10141"><vh>visit_str</vh></v>
<v t="ekr.20100212224846.10142"><vh>visit_unaryop</vh></v>
<v t="ekr.20100212224846.10143"><vh>visit_with</vh></v>
</v>
<v t="ekr.20100212224846.10144"><vh>module_factory</vh></v>
<v t="ekr.20100212224846.10145"><vh>import_from_factory</vh></v>
<v t="ekr.20100212224846.10146"><vh>_const_factory</vh></v>
<v t="ekr.20100212224846.10147"><vh>function_factory</vh></v>
<v t="ekr.20100212224846.10148"><vh>class_factory</vh></v>
</v>
<v t="ekr.20100212224846.10149"><vh>_nodes_compiler.py</vh>
<v t="ekr.20100212224846.10150"><vh>_nodes_compiler declarations</vh></v>
<v t="ekr.20100212224846.10151"><vh>class With</vh></v>
<v t="ekr.20100212224846.10152"><vh>class IfExp</vh></v>
<v t="ekr.20100212224846.10153"><vh>class Proxy_</vh></v>
<v t="ekr.20100212224846.10154"><vh>native_repr_tree</vh></v>
<v t="ekr.20100212224846.10155"><vh>class ExceptHandler</vh>
<v t="ekr.20100212224846.10156"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10157"><vh>class BinOp</vh></v>
<v t="ekr.20100212224846.10158"><vh>class BoolOp</vh></v>
<v t="ekr.20100212224846.10159"><vh>class UnaryOp</vh></v>
<v t="ekr.20100212224846.10160"><vh>class Delete</vh></v>
<v t="ekr.20100212224846.10161"><vh>class DelAttr</vh></v>
<v t="ekr.20100212224846.10162"><vh>class DelName</vh></v>
<v t="ekr.20100212224846.10163"><vh>class Arguments</vh>
<v t="ekr.20100212224846.10164"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10165"><vh>class Index</vh>
<v t="ekr.20100212224846.10166"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10167"><vh>class Slice</vh>
<v t="ekr.20100212224846.10168"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10169"><vh>_extslice</vh></v>
<v t="ekr.20100212224846.10170"><vh>class ExtSlice</vh>
<v t="ekr.20100212224846.10171"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10172"><vh>generic__repr__</vh></v>
<v t="ekr.20100212224846.10173"><vh>init_noargs</vh></v>
<v t="ekr.20100212224846.10174"><vh>_init_else_node</vh></v>
<v t="ekr.20100212224846.10175"><vh>_nodify_args</vh></v>
<v t="ekr.20100212224846.10176"><vh>args_compiler_to_ast</vh></v>
<v t="ekr.20100212224846.10177"><vh>_filter_none</vh></v>
<v t="ekr.20100212224846.10178"><vh>class TreeRebuilder</vh>
<v t="ekr.20100212224846.10179"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10180"><vh>insert_delstmt_if_necessary</vh></v>
<v t="ekr.20100212224846.10181"><vh>visit_function</vh></v>
<v t="ekr.20100212224846.10182"><vh>visit_lambda</vh></v>
<v t="ekr.20100212224846.10183"><vh>visit_class</vh></v>
<v t="ekr.20100212224846.10184"><vh>visit_module</vh></v>
<v t="ekr.20100212224846.10185"><vh>visit_assattr</vh></v>
<v t="ekr.20100212224846.10186"><vh>visit_assign</vh></v>
<v t="ekr.20100212224846.10187"><vh>visit_asslist</vh></v>
<v t="ekr.20100212224846.10188"><vh>visit_asstuple</vh></v>
<v t="ekr.20100212224846.10189"><vh>visit_assname</vh></v>
<v t="ekr.20100212224846.10190"><vh>visit_augassign</vh></v>
<v t="ekr.20100212224846.10191"><vh>visit_backquote</vh></v>
<v t="ekr.20100212224846.10192"><vh>visit_binop</vh></v>
<v t="ekr.20100212224846.10193"><vh>visit_boolop</vh></v>
<v t="ekr.20100212224846.10194"><vh>visit_callfunc</vh></v>
<v t="ekr.20100212224846.10195"><vh>visit_compare</vh></v>
<v t="ekr.20100212224846.10196"><vh>visit_discard</vh></v>
<v t="ekr.20100212224846.10197"><vh>visit_exec</vh></v>
<v t="ekr.20100212224846.10198"><vh>visit_for</vh></v>
<v t="ekr.20100212224846.10199"><vh>visit_genexpr</vh></v>
<v t="ekr.20100212224846.10200"><vh>visit_getattr</vh></v>
<v t="ekr.20100212224846.10201"><vh>visit_if</vh></v>
<v t="ekr.20100212224846.10202"><vh>visit_list</vh></v>
<v t="ekr.20100212224846.10203"><vh>visit_keyword</vh></v>
<v t="ekr.20100212224846.10204"><vh>visit_listcomp</vh></v>
<v t="ekr.20100212224846.10205"><vh>visit_name</vh></v>
<v t="ekr.20100212224846.10206"><vh>visit_comprehension</vh></v>
<v t="ekr.20100212224846.10207"><vh>visit_print</vh></v>
<v t="ekr.20100212224846.10208"><vh>visit_printnl</vh></v>
<v t="ekr.20100212224846.10209"><vh>visit_raise</vh></v>
<v t="ekr.20100212224846.10210"><vh>visit_return</vh></v>
<v t="ekr.20100212224846.10211"><vh>visit_slice</vh></v>
<v t="ekr.20100212224846.10212"><vh>visit_subscript</vh></v>
<v t="ekr.20100212224846.10213"><vh>visit_tryexcept</vh></v>
<v t="ekr.20100212224846.10214"><vh>visit_tryfinally</vh></v>
<v t="ekr.20100212224846.10215"><vh>visit_unaryop</vh></v>
<v t="ekr.20100212224846.10216"><vh>visit_while</vh></v>
<v t="ekr.20100212224846.10217"><vh>visit_yield</vh></v>
</v>
<v t="ekr.20100212224846.10218"><vh>module_factory</vh></v>
<v t="ekr.20100212224846.10219"><vh>_const_factory</vh></v>
<v t="ekr.20100212224846.10220"><vh>class_factory</vh></v>
</v>
<v t="ekr.20100212224846.10221"><vh>__init__.py</vh>
<v t="ekr.20100212224846.10222"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20100212224846.10223"><vh>__pkginfo__.py</vh>
<v t="ekr.20100212224846.10224"><vh>__pkginfo__ declarations</vh></v>
</v>
<v t="ekr.20100212224846.10225"><vh>test</vh>
<v t="ekr.20100212224846.10226"><vh>test\regrtest.py</vh>
<v t="ekr.20100212224846.10227"><vh>regrtest declarations</vh></v>
<v t="ekr.20100212224846.10228"><vh>class NonRegressionTC</vh>
<v t="ekr.20100212224846.10229"><vh>test_module_path</vh></v>
<v t="ekr.20100212224846.10230"><vh>test_living_property</vh></v>
<v t="ekr.20100212224846.10231"><vh>test_new_style_class_detection</vh></v>
<v t="ekr.20100212224846.10232"><vh>test_pylint_config_attr</vh></v>
<v t="ekr.20100212224846.10233"><vh>test_numpy_crash</vh></v>
</v>
<v t="ekr.20100212224846.10234"><vh>class Whatever</vh></v>
</v>
<v t="ekr.20100212224846.10235"><vh>test\unittest_builder.py</vh>
<v t="ekr.20100212224846.10236"><vh>unittest_builder declarations</vh></v>
<v t="ekr.20100212224846.10237"><vh>class FromToLineNoTC</vh>
<v t="ekr.20100212224846.10238"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10239"><vh>test_callfunc_lineno</vh></v>
<v t="ekr.20100212224846.10240"><vh>test_function_lineno</vh></v>
<v t="ekr.20100212224846.10241"><vh>test_decorated_function_lineno</vh></v>
<v t="ekr.20100212224846.10242"><vh>test_class_lineno</vh></v>
<v t="ekr.20100212224846.10243"><vh>test_if_lineno</vh></v>
<v t="ekr.20100212224846.10244"><vh>test_for_while_lineno</vh></v>
<v t="ekr.20100212224846.10245"><vh>test_try_except_lineno</vh></v>
<v t="ekr.20100212224846.10246"><vh>test_try_finally_lineno</vh></v>
<v t="ekr.20100212224846.10247"><vh>test_try_finally_25_lineno</vh></v>
<v t="ekr.20100212224846.10248"><vh>test_with_lineno</vh></v>
</v>
<v t="ekr.20100212224846.10249"><vh>class BuilderTC</vh>
<v t="ekr.20100212224846.10250"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10251"><vh>test_border_cases</vh></v>
<v t="ekr.20100212224846.10252"><vh>test_inspect_build0</vh></v>
<v t="ekr.20100212224846.10253"><vh>test_inspect_build1</vh></v>
<v t="ekr.20100212224846.10254"><vh>test_inspect_build2</vh></v>
<v t="ekr.20100212224846.10255"><vh>test_inspect_build3</vh></v>
<v t="ekr.20100212224846.10256"><vh>test_inspect_build_instance</vh></v>
<v t="ekr.20100212224846.10257"><vh>test_inspect_build_type_object</vh></v>
<v t="ekr.20100212224846.10258"><vh>test_package_name</vh></v>
<v t="ekr.20100212224846.10259"><vh>test_yield_parent</vh></v>
<v t="ekr.20100212224846.10260"><vh>test_object</vh></v>
<v t="ekr.20100212224846.10261"><vh>test_newstyle_detection</vh></v>
<v t="ekr.20100212224846.10262"><vh>test_globals</vh></v>
<v t="ekr.20100212224846.10263"><vh>test_socket_build</vh></v>
</v>
<v t="ekr.20100212224846.10264"><vh>class FileBuildTC</vh>
<v t="ekr.20100212224846.10265"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10266"><vh>test_module_base_props</vh></v>
<v t="ekr.20100212224846.10267"><vh>test_module_locals</vh></v>
<v t="ekr.20100212224846.10268"><vh>test_function_base_props</vh></v>
<v t="ekr.20100212224846.10269"><vh>test_function_locals</vh></v>
<v t="ekr.20100212224846.10270"><vh>test_class_base_props</vh></v>
<v t="ekr.20100212224846.10271"><vh>test_class_locals</vh></v>
<v t="ekr.20100212224846.10272"><vh>test_class_instance_attrs</vh></v>
<v t="ekr.20100212224846.10273"><vh>test_class_basenames</vh></v>
<v t="ekr.20100212224846.10274"><vh>test_method_base_props</vh></v>
<v t="ekr.20100212224846.10275"><vh>test_method_locals</vh></v>
</v>
<v t="ekr.20100212224846.10276"><vh>class ModuleBuildTC</vh>
<v t="ekr.20100212224846.10277"><vh>setUp</vh></v>
</v>
<v t="ekr.20100212224846.10278"><vh>class MoreTC</vh>
<v t="ekr.20100212224846.10279"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10280"><vh>test_infered_build</vh></v>
<v t="ekr.20100212224846.10281"><vh>test_augassign_attr</vh></v>
<v t="ekr.20100212224846.10282"><vh>test_dumb_module</vh></v>
<v t="ekr.20100212224846.10283"><vh>test_infered_dont_pollute</vh></v>
<v t="ekr.20100212224846.10284"><vh>test_asstuple</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10285"><vh>test\unittest_inference.py</vh>
<v t="ekr.20100212224846.10286"><vh>unittest_inference declarations</vh></v>
<v t="ekr.20100212224846.10287"><vh>get_name_node</vh></v>
<v t="ekr.20100212224846.10288"><vh>get_node_of_class</vh></v>
<v t="ekr.20100212224846.10289"><vh>class InferenceUtilsTC</vh>
<v t="ekr.20100212224846.10290"><vh>test_path_wrapper</vh></v>
</v>
<v t="ekr.20100212224846.10291"><vh>class InferenceTC</vh>
<v t="ekr.20100212224846.10292"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10293"><vh>test_module_inference</vh></v>
<v t="ekr.20100212224846.10294"><vh>test_class_inference</vh></v>
<v t="ekr.20100212224846.10295"><vh>test_function_inference</vh></v>
<v t="ekr.20100212224846.10296"><vh>test_builtin_name_inference</vh></v>
<v t="ekr.20100212224846.10297"><vh>test_tupleassign_name_inference</vh></v>
<v t="ekr.20100212224846.10298"><vh>test_listassign_name_inference</vh></v>
<v t="ekr.20100212224846.10299"><vh>test_advanced_tupleassign_name_inference1</vh></v>
<v t="ekr.20100212224846.10300"><vh>test_advanced_tupleassign_name_inference2</vh></v>
<v t="ekr.20100212224846.10301"><vh>test_swap_assign_inference</vh></v>
<v t="ekr.20100212224846.10302"><vh>test_getattr_inference1</vh></v>
<v t="ekr.20100212224846.10303"><vh>test_getattr_inference2</vh></v>
<v t="ekr.20100212224846.10304"><vh>test_getattr_inference3</vh></v>
<v t="ekr.20100212224846.10305"><vh>test_getattr_inference4</vh></v>
<v t="ekr.20100212224846.10306"><vh>test_callfunc_inference</vh></v>
<v t="ekr.20100212224846.10307"><vh>test_unbound_method_inference</vh></v>
<v t="ekr.20100212224846.10308"><vh>test_bound_method_inference</vh></v>
<v t="ekr.20100212224846.10309"><vh>test_args_default_inference1</vh></v>
<v t="ekr.20100212224846.10310"><vh>test_args_default_inference2</vh></v>
<v t="ekr.20100212224846.10311"><vh>test_inference_restrictions</vh></v>
<v t="ekr.20100212224846.10312"><vh>test_ancestors_inference</vh></v>
<v t="ekr.20100212224846.10313"><vh>test_ancestors_inference2</vh></v>
<v t="ekr.20100212224846.10314"><vh>test_f_arg_f</vh></v>
<v t="ekr.20100212224846.10315"><vh>test_exc_ancestors</vh></v>
<v t="ekr.20100212224846.10316"><vh>test_except_inference</vh></v>
<v t="ekr.20100212224846.10317"><vh>test_del1</vh></v>
<v t="ekr.20100212224846.10318"><vh>test_del2</vh></v>
<v t="ekr.20100212224846.10319"><vh>test_builtin_types</vh></v>
<v t="ekr.20100212224846.10320"><vh>test_descriptor_are_callable</vh></v>
<v t="ekr.20100212224846.10321"><vh>test_bt_ancestor_crash</vh></v>
<v t="ekr.20100212224846.10322"><vh>test_qqch</vh></v>
<v t="ekr.20100212224846.10323"><vh>test_method_argument</vh></v>
<v t="ekr.20100212224846.10324"><vh>test_tuple_then_list</vh></v>
<v t="ekr.20100212224846.10325"><vh>test_mulassign_inference</vh></v>
<v t="ekr.20100212224846.10326"><vh>test_float_complex_ambiguity</vh></v>
<v t="ekr.20100212224846.10327"><vh>test_lookup_cond_branches</vh></v>
<v t="ekr.20100212224846.10328"><vh>test_simple_subscript</vh></v>
<v t="ekr.20100212224846.10329"><vh>test_simple_for</vh></v>
<v t="ekr.20100212224846.10330"><vh>test_simple_for_genexpr</vh></v>
<v t="ekr.20100212224846.10331"><vh>test_builtin_help</vh></v>
<v t="ekr.20100212224846.10332"><vh>test_builtin_open</vh></v>
<v t="ekr.20100212224846.10333"><vh>test_callfunc_context_func</vh></v>
<v t="ekr.20100212224846.10334"><vh>test_callfunc_context_lambda</vh></v>
<v t="ekr.20100212224846.10335"><vh>test_factory_method</vh></v>
<v t="ekr.20100212224846.10336"><vh>test_import_as</vh></v>
<v t="ekr.20100212224846.10337"><vh>_test_const_infered</vh></v>
<v t="ekr.20100212224846.10338"><vh>test_unary_not</vh></v>
<v t="ekr.20100212224846.10339"><vh>test_binary_op_int_add</vh></v>
<v t="ekr.20100212224846.10340"><vh>test_binary_op_int_sub</vh></v>
<v t="ekr.20100212224846.10341"><vh>test_binary_op_float_div</vh></v>
<v t="ekr.20100212224846.10342"><vh>test_binary_op_str_mul</vh></v>
<v t="ekr.20100212224846.10343"><vh>test_binary_op_bitand</vh></v>
<v t="ekr.20100212224846.10344"><vh>test_binary_op_bitor</vh></v>
<v t="ekr.20100212224846.10345"><vh>test_binary_op_bitxor</vh></v>
<v t="ekr.20100212224846.10346"><vh>test_binary_op_shiftright</vh></v>
<v t="ekr.20100212224846.10347"><vh>test_binary_op_shiftleft</vh></v>
<v t="ekr.20100212224846.10348"><vh>test_binary_op_list_mul</vh></v>
<v t="ekr.20100212224846.10349"><vh>test_binary_op_tuple_add</vh></v>
<v t="ekr.20100212224846.10350"><vh>test_binary_op_custom_class</vh></v>
<v t="ekr.20100212224846.10351"><vh>test_nonregr_lambda_arg</vh></v>
<v t="ekr.20100212224846.10352"><vh>test_nonregr_getitem_empty_tuple</vh></v>
<v t="ekr.20100212224846.10353"><vh>test_python25_generator_exit</vh></v>
<v t="ekr.20100212224846.10354"><vh>test_python25_relative_import</vh></v>
<v t="ekr.20100212224846.10355"><vh>test_python25_no_relative_import</vh></v>
<v t="ekr.20100212224846.10356"><vh>test_property</vh></v>
<v t="ekr.20100212224846.10357"><vh>test_im_func_unwrap</vh></v>
<v t="ekr.20100212224846.10358"><vh>test_augassign</vh></v>
<v t="ekr.20100212224846.10359"><vh>test_nonregr_func_arg</vh></v>
<v t="ekr.20100212224846.10360"><vh>test_nonregr_func_global</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10361"><vh>test\unittest_inspector.py</vh>
<v t="ekr.20100212224846.10362"><vh>unittest_inspector declarations</vh></v>
<v t="ekr.20100212224846.10363"><vh>astng_wrapper</vh></v>
<v t="ekr.20100212224846.10364"><vh>class LinkerTC</vh>
<v t="ekr.20100212224846.10365"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10366"><vh>test_class_implements</vh></v>
<v t="ekr.20100212224846.10367"><vh>test_locals_assignment_resolution</vh></v>
<v t="ekr.20100212224846.10368"><vh>test_instance_attrs_resolution</vh></v>
</v>
<v t="ekr.20100212224846.10369"><vh>class LinkerTC2</vh>
<v t="ekr.20100212224846.10370"><vh>setUp</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10371"><vh>test\unittest_lookup.py</vh>
<v t="ekr.20100212224846.10372"><vh>unittest_lookup declarations</vh></v>
<v t="ekr.20100212224846.10373"><vh>class LookupTC</vh>
<v t="ekr.20100212224846.10374"><vh>test_limit</vh></v>
<v t="ekr.20100212224846.10375"><vh>test_module</vh></v>
<v t="ekr.20100212224846.10376"><vh>test_class_ancestor_name</vh></v>
<v t="ekr.20100212224846.10377"><vh>test_method</vh></v>
<v t="ekr.20100212224846.10378"><vh>test_function_argument_with_default</vh></v>
<v t="ekr.20100212224846.10379"><vh>test_class</vh></v>
<v t="ekr.20100212224846.10380"><vh>test_inner_classes</vh></v>
<v t="ekr.20100212224846.10381"><vh>test_loopvar_hiding</vh></v>
<v t="ekr.20100212224846.10382"><vh>test_list_comps</vh></v>
<v t="ekr.20100212224846.10383"><vh>test_explicit___name__</vh></v>
<v t="ekr.20100212224846.10384"><vh>test_function_module_special</vh></v>
<v t="ekr.20100212224846.10385"><vh>test_builtin_lookup</vh></v>
<v t="ekr.20100212224846.10386"><vh>test_decorator_arguments_lookup</vh></v>
<v t="ekr.20100212224846.10387"><vh>test_inner_decorator_member_lookup</vh></v>
<v t="ekr.20100212224846.10388"><vh>test_static_method_lookup</vh></v>
<v t="ekr.20100212224846.10389"><vh>test_global_delete</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10390"><vh>test\unittest_manager.py</vh>
<v t="ekr.20100212224846.10391"><vh>unittest_manager declarations</vh></v>
<v t="ekr.20100212224846.10392"><vh>class ASTNGManagerTC</vh>
<v t="ekr.20100212224846.10393"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10394"><vh>test_astng_from_module</vh></v>
<v t="ekr.20100212224846.10395"><vh>test_astng_from_class</vh></v>
<v t="ekr.20100212224846.10396"><vh>_test_astng_from_zip</vh></v>
<v t="ekr.20100212224846.10397"><vh>test_astng_from_module_name_egg</vh></v>
<v t="ekr.20100212224846.10398"><vh>test_astng_from_module_name_zip</vh></v>
<v t="ekr.20100212224846.10399"><vh>test_from_directory</vh></v>
<v t="ekr.20100212224846.10400"><vh>test_package_node</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10401"><vh>test\unittest_nodes.py</vh>
<v t="ekr.20100212224846.10402"><vh>unittest_nodes declarations</vh></v>
<v t="ekr.20100212224846.10403"><vh>class _NodeTC</vh>
<v t="ekr.20100212224846.10404"><vh>astng</vh></v>
</v>
<v t="ekr.20100212224846.10405"><vh>class IfNodeTC</vh>
<v t="ekr.20100212224846.10406"><vh>test_if_elif_else_node</vh></v>
<v t="ekr.20100212224846.10407"><vh>test_block_range</vh></v>
</v>
<v t="ekr.20100212224846.10408"><vh>class TryExceptNodeTC</vh>
<v t="ekr.20100212224846.10409"><vh>test_block_range</vh></v>
</v>
<v t="ekr.20100212224846.10410"><vh>class TryFinallyNodeTC</vh>
<v t="ekr.20100212224846.10411"><vh>test_block_range</vh></v>
</v>
<v t="ekr.20100212224846.10412"><vh>class TryFinally25NodeTC</vh>
<v t="ekr.20100212224846.10413"><vh>test_block_range</vh></v>
</v>
<v t="ekr.20100212224846.10414"><vh>class ImportNodeTC</vh>
<v t="ekr.20100212224846.10415"><vh>test_import_self_resolve</vh></v>
<v t="ekr.20100212224846.10416"><vh>test_from_self_resolve</vh></v>
<v t="ekr.20100212224846.10417"><vh>test_real_name</vh></v>
<v t="ekr.20100212224846.10418"><vh>test_as_string</vh></v>
<v t="ekr.20100212224846.10419"><vh>test_module_as_string</vh></v>
</v>
<v t="ekr.20100212224846.10420"><vh>class CmpNodeTC</vh>
<v t="ekr.20100212224846.10421"><vh>test_as_string</vh></v>
</v>
<v t="ekr.20100212224846.10422"><vh>class ConstNodeTC</vh>
<v t="ekr.20100212224846.10423"><vh>_test</vh></v>
<v t="ekr.20100212224846.10424"><vh>test_none</vh></v>
<v t="ekr.20100212224846.10425"><vh>test_bool</vh></v>
<v t="ekr.20100212224846.10426"><vh>test_int</vh></v>
<v t="ekr.20100212224846.10427"><vh>test_float</vh></v>
<v t="ekr.20100212224846.10428"><vh>test_complex</vh></v>
<v t="ekr.20100212224846.10429"><vh>test_str</vh></v>
<v t="ekr.20100212224846.10430"><vh>test_unicode</vh></v>
</v>
<v t="ekr.20100212224846.10431"><vh>class ArgumentsNodeTC</vh>
<v t="ekr.20100212224846.10432"><vh>test_linenumbering</vh></v>
</v>
<v t="ekr.20100212224846.10433"><vh>class SliceNodeTC</vh>
<v t="ekr.20100212224846.10434"><vh>test</vh></v>
</v>
<v t="ekr.20100212224846.10435"><vh>class EllipsisNodeTC</vh>
<v t="ekr.20100212224846.10436"><vh>test</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10437"><vh>test\unittest_scoped_nodes.py</vh>
<v t="ekr.20100212224846.10438"><vh>unittest_scoped_nodes declarations</vh></v>
<v t="ekr.20100212224846.10439"><vh>_test_dict_interface</vh></v>
<v t="ekr.20100212224846.10440"><vh>class ModuleNodeTC</vh>
<v t="ekr.20100212224846.10441"><vh>test_special_attributes</vh></v>
<v t="ekr.20100212224846.10442"><vh>test_dict_interface</vh></v>
<v t="ekr.20100212224846.10443"><vh>test_getattr</vh></v>
<v t="ekr.20100212224846.10444"><vh>test_wildard_import_names</vh></v>
<v t="ekr.20100212224846.10445"><vh>test_module_getattr</vh></v>
</v>
<v t="ekr.20100212224846.10446"><vh>class FunctionNodeTC</vh>
<v t="ekr.20100212224846.10447"><vh>test_special_attributes</vh></v>
<v t="ekr.20100212224846.10448"><vh>test_dict_interface</vh></v>
<v t="ekr.20100212224846.10449"><vh>test_default_value</vh></v>
<v t="ekr.20100212224846.10450"><vh>test_navigation</vh></v>
<v t="ekr.20100212224846.10451"><vh>test_nested_args</vh></v>
<v t="ekr.20100212224846.10452"><vh>test_format_args</vh></v>
<v t="ekr.20100212224846.10453"><vh>test_is_abstract</vh></v>
<v t="ekr.20100212224846.10454"><vh>test_lambda_pytype</vh></v>
<v t="ekr.20100212224846.10455"><vh>test_is_method</vh></v>
<v t="ekr.20100212224846.10456"><vh>test_argnames</vh></v>
</v>
<v t="ekr.20100212224846.10457"><vh>class ClassNodeTC</vh>
<v t="ekr.20100212224846.10458"><vh>test_dict_interface</vh></v>
<v t="ekr.20100212224846.10459"><vh>test_cls_special_attributes_1</vh></v>
<v t="ekr.20100212224846.10460"><vh>test_cls_special_attributes_2</vh></v>
<v t="ekr.20100212224846.10461"><vh>test_instance_special_attributes</vh></v>
<v t="ekr.20100212224846.10462"><vh>test_navigation</vh></v>
<v t="ekr.20100212224846.10463"><vh>test_local_attr_ancestors</vh></v>
<v t="ekr.20100212224846.10464"><vh>test_instance_attr_ancestors</vh></v>
<v t="ekr.20100212224846.10465"><vh>test_methods</vh></v>
<v t="ekr.20100212224846.10466"><vh>test_ancestors</vh></v>
<v t="ekr.20100212224846.10467"><vh>test_type</vh></v>
<v t="ekr.20100212224846.10468"><vh>test_interfaces</vh></v>
<v t="ekr.20100212224846.10469"><vh>test_concat_interfaces</vh></v>
<v t="ekr.20100212224846.10470"><vh>test_inner_classes</vh></v>
<v t="ekr.20100212224846.10471"><vh>test_classmethod_attributes</vh></v>
<v t="ekr.20100212224846.10472"><vh>test_class_getattr</vh></v>
<v t="ekr.20100212224846.10473"><vh>test_instance_getattr</vh></v>
<v t="ekr.20100212224846.10474"><vh>test_instance_getattr_with_class_attr</vh></v>
<v t="ekr.20100212224846.10475"><vh>test_getattr_method_transform</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10476"><vh>test\unittest_utils.py</vh>
<v t="ekr.20100212224846.10477"><vh>unittest_utils declarations</vh></v>
<v t="ekr.20100212224846.10478"><vh>class AreExclusiveTC</vh>
<v t="ekr.20100212224846.10479"><vh>test_not_exclusive</vh></v>
<v t="ekr.20100212224846.10480"><vh>test_if</vh></v>
<v t="ekr.20100212224846.10481"><vh>test_try_except</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10482"><vh>test\__init__.py</vh></v>
<v t="ekr.20100212224846.10483"><vh>test\data</vh>
<v t="ekr.20100212224846.10484"><vh>all.py</vh>
<v t="ekr.20100212224846.10485"><vh>all declarations</vh></v>
<v t="ekr.20100212224846.10486"><vh>class Aaa</vh></v>
<v t="ekr.20100212224846.10487"><vh>func</vh></v>
</v>
<v t="ekr.20100212224846.10488"><vh>format.py</vh>
<v t="ekr.20100212224846.10489"><vh>format declarations</vh></v>
<v t="ekr.20100212224846.10490"><vh>definition</vh></v>
<v t="ekr.20100212224846.10491"><vh>class debile</vh></v>
</v>
<v t="ekr.20100212224846.10492"><vh>module.py</vh>
<v t="ekr.20100212224846.10493"><vh>module declarations</vh></v>
<v t="ekr.20100212224846.10494"><vh>global_access</vh></v>
<v t="ekr.20100212224846.10495"><vh>class YO</vh>
<v t="ekr.20100212224846.10496"><vh>__init__</vh></v>
</v>
<v t="ekr.20100212224846.10497"><vh>class YOUPI</vh>
<v t="ekr.20100212224846.10498"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10499"><vh>method</vh></v>
<v t="ekr.20100212224846.10500"><vh>static_method</vh></v>
<v t="ekr.20100212224846.10501"><vh>class_method</vh></v>
</v>
<v t="ekr.20100212224846.10502"><vh>nested_args</vh></v>
</v>
<v t="ekr.20100212224846.10503"><vh>module2.py</vh>
<v t="ekr.20100212224846.10504"><vh>module2 declarations</vh></v>
<v t="ekr.20100212224846.10505"><vh>class Specialization</vh></v>
<v t="ekr.20100212224846.10506"><vh>class Metaclass</vh></v>
<v t="ekr.20100212224846.10507"><vh>class Interface</vh></v>
<v t="ekr.20100212224846.10508"><vh>class MyIFace</vh></v>
<v t="ekr.20100212224846.10509"><vh>class AnotherIFace</vh></v>
<v t="ekr.20100212224846.10510"><vh>class MyException</vh></v>
<v t="ekr.20100212224846.10511"><vh>class MyError</vh></v>
<v t="ekr.20100212224846.10512"><vh>class AbstractClass</vh>
<v t="ekr.20100212224846.10513"><vh>to_override</vh></v>
<v t="ekr.20100212224846.10514"><vh>return_something</vh></v>
</v>
<v t="ekr.20100212224846.10515"><vh>class Concrete0</vh></v>
<v t="ekr.20100212224846.10516"><vh>class Concrete1</vh></v>
<v t="ekr.20100212224846.10517"><vh>class Concrete2</vh></v>
<v t="ekr.20100212224846.10518"><vh>class Concrete23</vh></v>
<v t="ekr.20100212224846.10519"><vh>raise_string</vh></v>
<v t="ekr.20100212224846.10520"><vh>make_class</vh></v>
<v t="ekr.20100212224846.10521"><vh>class A</vh></v>
<v t="ekr.20100212224846.10522"><vh>class A</vh></v>
</v>
<v t="ekr.20100212224846.10523"><vh>noendingnewline.py</vh>
<v t="ekr.20100212224846.10524"><vh>noendingnewline declarations</vh></v>
<v t="ekr.20100212224846.10525"><vh>class TestCase</vh>
<v t="ekr.20100212224846.10526"><vh>setUp</vh></v>
<v t="ekr.20100212224846.10527"><vh>tearDown</vh></v>
<v t="ekr.20100212224846.10528"><vh>testIt</vh></v>
<v t="ekr.20100212224846.10529"><vh>xxx</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10530"><vh>nonregr.py</vh>
<v t="ekr.20100212224846.10531"><vh>nonregr declarations</vh></v>
<v t="ekr.20100212224846.10532"><vh>toto</vh></v>
<v t="ekr.20100212224846.10533"><vh>class OptionParser</vh>
<v t="ekr.20100212224846.10534"><vh>parse_args</vh></v>
</v>
<v t="ekr.20100212224846.10535"><vh>class Aaa</vh>
<v t="ekr.20100212224846.10536"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10537"><vh>one_public</vh></v>
<v t="ekr.20100212224846.10538"><vh>another_public</vh></v>
</v>
<v t="ekr.20100212224846.10539"><vh>class Ccc</vh>
<v t="ekr.20100212224846.10540"><vh>class Ddd</vh></v>
<v t="ekr.20100212224846.10541"><vh>class Eee</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10542"><vh>notall.py</vh>
<v t="ekr.20100212224846.10543"><vh>notall declarations</vh></v>
<v t="ekr.20100212224846.10544"><vh>class Aaa</vh></v>
<v t="ekr.20100212224846.10545"><vh>func</vh></v>
</v>
<v t="ekr.20100212224846.10546"><vh>__init__.py</vh>
<v t="ekr.20100212224846.10547"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20100212224846.10548"><vh>SSL1</vh>
<v t="ekr.20100212224846.10549"><vh>SSL1\Connection1.py</vh>
<v t="ekr.20100212224846.10550"><vh>Connection1 declarations</vh></v>
<v t="ekr.20100212224846.10551"><vh>class Connection</vh>
<v t="ekr.20100212224846.10552"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10553"><vh>SSL1\__init__.py</vh>
<v t="ekr.20100212224846.10554"><vh>__init__ declarations</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10555"><vh>appl</vh>
<v t="ekr.20100212224846.10556"><vh>appl\myConnection.py</vh>
<v t="ekr.20100212224846.10557"><vh>class MyConnection</vh>
<v t="ekr.20100212224846.10558"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10559"><vh>appl\__init__.py</vh>
<v t="ekr.20100212224846.10560"><vh>__init__ declarations</vh></v>
</v>
</v>
</v>
<v t="ekr.20100212224846.10561"><vh>test\data2</vh>
<v t="ekr.20100212224846.10562"><vh>clientmodule_test.py</vh>
<v t="ekr.20100212224846.10563"><vh>clientmodule_test declarations</vh></v>
<v t="ekr.20100212224846.10564"><vh>class Toto</vh></v>
<v t="ekr.20100212224846.10565"><vh>class Ancestor</vh>
<v t="ekr.20100212224846.10566"><vh>__init__</vh></v>
<v t="ekr.20100212224846.10567"><vh>get_value</vh></v>
<v t="ekr.20100212224846.10568"><vh>set_value</vh></v>
</v>
<v t="ekr.20100212224846.10569"><vh>class Specialization</vh>
<v t="ekr.20100212224846.10570"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10571"><vh>suppliermodule_test.py</vh>
<v t="ekr.20100212224846.10572"><vh>suppliermodule_test declarations</vh></v>
<v t="ekr.20100212224846.10573"><vh>class NotImplemented</vh></v>
<v t="ekr.20100212224846.10574"><vh>class Interface</vh>
<v t="ekr.20100212224846.10575"><vh>get_value</vh></v>
<v t="ekr.20100212224846.10576"><vh>set_value</vh></v>
</v>
<v t="ekr.20100212224846.10577"><vh>class DoNothing</vh></v>
</v>
<v t="ekr.20100212224846.10578"><vh>__init__.py</vh></v>
</v>
<v t="ekr.20100212224846.10579"><vh>test\regrtest_data</vh>
<v t="ekr.20100212224846.10580"><vh>absimport.py</vh>
<v t="ekr.20100212224846.10581"><vh>absimport declarations</vh></v>
</v>
<v t="ekr.20100212224846.10582"><vh>descriptor_crash.py</vh>
<v t="ekr.20100212224846.10583"><vh>descriptor_crash declarations</vh></v>
<v t="ekr.20100212224846.10584"><vh>class Page</vh>
<v t="ekr.20100212224846.10585"><vh>getPage</vh></v>
</v>
</v>
<v t="ekr.20100212224846.10586"><vh>import_package_subpackage_module.py</vh>
<v t="ekr.20100212224846.10587"><vh>import_package_subpackage_module declarations</vh></v>
</v>
<v t="ekr.20100212224846.10588"><vh>package</vh>
<v t="ekr.20100212224846.10589"><vh>package\__init__.py</vh>
<v t="ekr.20100212224846.10590"><vh>__init__ declarations</vh></v>
</v>
<v t="ekr.20100212224846.10591"><vh>package\subpackage</vh>
<v t="ekr.20100212224846.10592"><vh>package\subpackage\module.py</vh>
<v t="ekr.20100212224846.10593"><vh>module declarations</vh></v>
</v>
<v t="ekr.20100212224846.10594"><vh>package\subpackage\__init__.py</vh>
<v t="ekr.20100212224846.10595"><vh>__init__ declarations</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20100212224846.9587"></v>
<v t="ekr.20100212224846.9549"></v>
<v t="ekr.20100212224846.10601"><vh>Recursive import script</vh>
<v t="ekr.20100212224846.10602"><vh>importFiles</vh></v>
<v t="ekr.20100213083546.4253"><vh>importOneFile</vh></v>
<v t="ekr.20100212224846.10603"><vh>importDir</vh></v>
<v t="ekr.20100212224846.10604"><vh>createLastChildOf</vh></v>
</v>
<v t="ekr.20100215090114.8251"><vh>pylint-0.19.0/checkers</vh>
<v t="ekr.20100215090114.8509"><vh>Copyright</vh></v>
<v t="ekr.20100215090114.8493"><vh>__init__.py</vh>
<v t="ekr.20100215090114.8494"><vh>__init__ declarations</vh></v>
<v t="ekr.20100215090114.8495"><vh>table_lines_from_stats</vh></v>
<v t="ekr.20100215090114.8496"><vh>class BaseChecker</vh>
<v t="ekr.20100215090114.8497"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8498"><vh>add_message</vh></v>
<v t="ekr.20100215090114.8499"><vh>is_enabled</vh></v>
<v t="ekr.20100215090114.8500"><vh>enable</vh></v>
<v t="ekr.20100215090114.8501"><vh>package_dir</vh></v>
<v t="ekr.20100215090114.8502"><vh>open</vh></v>
<v t="ekr.20100215090114.8503"><vh>close</vh></v>
</v>
<v t="ekr.20100215090114.8504"><vh>class BaseRawChecker</vh>
<v t="ekr.20100215090114.8505"><vh>process_module</vh></v>
<v t="ekr.20100215090114.8506"><vh>process_tokens</vh></v>
</v>
<v t="ekr.20100215090114.8507"><vh>initialize</vh></v>
<v t="ekr.20100215090114.8508"><vh>package_load</vh></v>
</v>
<v t="ekr.20100215090114.8252"><vh>base.py</vh>
<v t="ekr.20100215090114.8253"><vh>base declarations</vh></v>
<v t="ekr.20100215090114.8254"><vh>in_loop</vh></v>
<v t="ekr.20100215090114.8255"><vh>in_nested_list</vh></v>
<v t="ekr.20100215090114.8256"><vh>report_by_type_stats</vh></v>
<v t="ekr.20100215090114.8257"><vh>class BasicChecker (BaseChecker)</vh>
<v t="ekr.20100215090114.8258"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8259"><vh>open</vh></v>
<v t="ekr.20100215090114.8260"><vh>visit_module</vh></v>
<v t="ekr.20100215090114.8261"><vh>visit_class</vh></v>
<v t="ekr.20100215090114.8262"><vh>visit_discard</vh></v>
<v t="ekr.20100215090114.8263"><vh>visit_pass</vh></v>
<v t="ekr.20100215090114.8264"><vh>visit_lambda</vh></v>
<v t="ekr.20100215090114.8265"><vh>visit_function</vh></v>
<v t="ekr.20100215090114.8266"><vh>leave_function</vh></v>
<v t="ekr.20100215090114.8267"><vh>visit_assname</vh></v>
<v t="ekr.20100215090114.8268"><vh>visit_return</vh></v>
<v t="ekr.20100215090114.8269"><vh>visit_yield</vh></v>
<v t="ekr.20100215090114.8270"><vh>visit_continue</vh></v>
<v t="ekr.20100215090114.8271"><vh>visit_break</vh></v>
<v t="ekr.20100215090114.8272"><vh>visit_raise</vh></v>
<v t="ekr.20100215090114.8273"><vh>visit_exec</vh></v>
<v t="ekr.20100215090114.8274"><vh>visit_callfunc (*) BasicChecker</vh></v>
<v t="ekr.20100215090114.8275"><vh>visit_unaryop</vh></v>
<v t="ekr.20100215090114.8276"><vh>visit_dict</vh></v>
<v t="ekr.20100215090114.8277"><vh>_check_unreachable</vh></v>
<v t="ekr.20100215090114.8278"><vh>_check_in_loop</vh></v>
<v t="ekr.20100215090114.8279"><vh>_check_redefinition</vh></v>
<v t="ekr.20100215090114.8280"><vh>_check_docstring</vh></v>
<v t="ekr.20100215090114.8281"><vh>_recursive_check_names</vh></v>
<v t="ekr.20100215090114.8282"><vh>_check_name</vh></v>
<v t="ekr.20100215090114.8283"><vh>_check_defaults</vh></v>
<v t="ekr.20100215090114.8284"><vh>_check_required_attributes</vh></v>
</v>
<v t="ekr.20100215090114.8285"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8286"><vh>classes.py **</vh>
<v t="ekr.20100215090114.8287"><vh>classes declarations</vh></v>
<v t="ekr.20100215090114.8288"><vh>class ClassChecker</vh>
<v t="ekr.20100215090114.8289"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8290"><vh>visit_class</vh></v>
<v t="ekr.20100215090114.8291"><vh>leave_class</vh></v>
<v t="ekr.20100215090114.8292"><vh>visit_function</vh></v>
<v t="ekr.20100215090114.8293"><vh>leave_function</vh></v>
<v t="ekr.20100215090114.8294"><vh>visit_getattr</vh></v>
<v t="ekr.20100215090114.8295"><vh>visit_name</vh></v>
<v t="ekr.20100215090114.8296"><vh>_check_accessed_members</vh></v>
<v t="ekr.20100215090114.8297"><vh>_check_first_arg_for_type</vh></v>
<v t="ekr.20100215090114.8298"><vh>_check_bases_classes</vh></v>
<v t="ekr.20100215090114.8299"><vh>_check_interfaces</vh></v>
<v t="ekr.20100215090114.8300"><vh>_check_init</vh></v>
<v t="ekr.20100215090114.8301"><vh>_check_signature</vh></v>
</v>
<v t="ekr.20100215090114.8302"><vh>_ancestors_to_call</vh></v>
<v t="ekr.20100215090114.8303"><vh>node_method</vh></v>
<v t="ekr.20100215090114.8304"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8305"><vh>design_analysis.py</vh>
<v t="ekr.20100215090114.8306"><vh>design_analysis declarations</vh></v>
<v t="ekr.20100215090114.8307"><vh>class_is_abstract</vh></v>
<v t="ekr.20100215090114.8308"><vh>class MisdesignChecker</vh>
<v t="ekr.20100215090114.8309"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8310"><vh>open</vh></v>
<v t="ekr.20100215090114.8311"><vh>close</vh></v>
<v t="ekr.20100215090114.8312"><vh>visit_class</vh></v>
<v t="ekr.20100215090114.8313"><vh>leave_class</vh></v>
<v t="ekr.20100215090114.8314"><vh>visit_function</vh></v>
<v t="ekr.20100215090114.8315"><vh>leave_function</vh></v>
<v t="ekr.20100215090114.8316"><vh>visit_return</vh></v>
<v t="ekr.20100215090114.8317"><vh>visit_yield</vh></v>
<v t="ekr.20100215090114.8318"><vh>visit_default</vh></v>
<v t="ekr.20100215090114.8319"><vh>visit_tryexcept</vh></v>
<v t="ekr.20100215090114.8320"><vh>visit_tryfinally</vh></v>
<v t="ekr.20100215090114.8321"><vh>visit_if</vh></v>
<v t="ekr.20100215090114.8322"><vh>visit_while</vh></v>
<v t="ekr.20100215090114.8323"><vh>_inc_branch</vh></v>
</v>
<v t="ekr.20100215090114.8324"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8325"><vh>exceptions.py</vh>
<v t="ekr.20100215090114.8326"><vh>exceptions declarations</vh></v>
<v t="ekr.20100215090114.8327"><vh>class ExceptionsChecker</vh>
<v t="ekr.20100215090114.8328"><vh>visit_raise</vh></v>
<v t="ekr.20100215090114.8329"><vh>_check_raise_value</vh></v>
<v t="ekr.20100215090114.8330"><vh>visit_tryexcept</vh></v>
</v>
<v t="ekr.20100215090114.8331"><vh>inherit_from_std_ex</vh></v>
<v t="ekr.20100215090114.8332"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8333"><vh>format.py</vh>
<v t="ekr.20100215090114.8334"><vh>format declarations</vh></v>
<v t="ekr.20100215090114.8335"><vh>get_string_coords</vh></v>
<v t="ekr.20100215090114.8336"><vh>in_coords</vh></v>
<v t="ekr.20100215090114.8337"><vh>check_line</vh></v>
<v t="ekr.20100215090114.8338"><vh>class FormatChecker</vh>
<v t="ekr.20100215090114.8339"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8340"><vh>new_line</vh></v>
<v t="ekr.20100215090114.8341"><vh>process_tokens</vh></v>
<v t="ekr.20100215090114.8342"><vh>visit_default</vh></v>
<v t="ekr.20100215090114.8343"><vh>visit_backquote</vh></v>
<v t="ekr.20100215090114.8344"><vh>check_lines</vh></v>
<v t="ekr.20100215090114.8345"><vh>check_indent_level</vh></v>
</v>
<v t="ekr.20100215090114.8346"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8347"><vh>imports.py</vh>
<v t="ekr.20100215090114.8348"><vh>imports declarations</vh></v>
<v t="ekr.20100215090114.8349"><vh>get_first_import</vh></v>
<v t="ekr.20100215090114.8350"><vh>filter_dependencies_info</vh></v>
<v t="ekr.20100215090114.8351"><vh>make_tree_defs</vh></v>
<v t="ekr.20100215090114.8352"><vh>repr_tree_defs</vh></v>
<v t="ekr.20100215090114.8353"><vh>dependencies_graph</vh></v>
<v t="ekr.20100215090114.8354"><vh>make_graph</vh></v>
<v t="ekr.20100215090114.8355"><vh>class ImportsChecker</vh>
<v t="ekr.20100215090114.8356"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8357"><vh>open</vh></v>
<v t="ekr.20100215090114.8358"><vh>close</vh></v>
<v t="ekr.20100215090114.8359"><vh>visit_import</vh></v>
<v t="ekr.20100215090114.8360"><vh>visit_from</vh></v>
<v t="ekr.20100215090114.8361"><vh>get_imported_module</vh></v>
<v t="ekr.20100215090114.8362"><vh>_check_relative_import</vh></v>
<v t="ekr.20100215090114.8363"><vh>_add_imported_module</vh></v>
<v t="ekr.20100215090114.8364"><vh>_check_deprecated_module</vh></v>
<v t="ekr.20100215090114.8365"><vh>_check_reimport</vh></v>
<v t="ekr.20100215090114.8366"><vh>report_external_dependencies</vh></v>
<v t="ekr.20100215090114.8367"><vh>report_dependencies_graph &amp; helpers</vh>
<v t="ekr.20100215090114.8368"><vh>_external_dependencies_info</vh></v>
<v t="ekr.20100215090114.8369"><vh>_internal_dependencies_info</vh></v>
</v>
</v>
<v t="ekr.20100215090114.8370"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8371"><vh>logging.py</vh>
<v t="ekr.20100215090114.8372"><vh>logging declarations</vh></v>
<v t="ekr.20100215090114.8373"><vh>class LoggingChecker</vh>
<v t="ekr.20100215090114.8374"><vh>visit_module</vh></v>
<v t="ekr.20100215090114.8375"><vh>visit_import</vh></v>
<v t="ekr.20100215090114.8376"><vh>visit_callfunc &amp; helpers</vh>
<v t="ekr.20100215090114.8377"><vh>_CheckConvenienceMethods</vh></v>
<v t="ekr.20100215090114.8378"><vh>_CheckLogMethod</vh></v>
</v>
</v>
<v t="ekr.20100215090114.8379"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8380"><vh>misc.py</vh>
<v t="ekr.20100215090114.8381"><vh>misc declarations</vh></v>
<v t="ekr.20100215090114.8382"><vh>is_ascii</vh></v>
<v t="ekr.20100215090114.8383"><vh>guess_encoding</vh></v>
<v t="ekr.20100215090114.8384"><vh>class EncodingChecker</vh>
<v t="ekr.20100215090114.8385"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8386"><vh>process_module</vh></v>
</v>
<v t="ekr.20100215090114.8387"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8388"><vh>newstyle.py</vh>
<v t="ekr.20100215090114.8389"><vh>newstyle declarations</vh></v>
<v t="ekr.20100215090114.8390"><vh>class NewStyleConflictChecker</vh>
<v t="ekr.20100215090114.8391"><vh>visit_class</vh></v>
<v t="ekr.20100215090114.8392"><vh>visit_callfunc</vh></v>
<v t="ekr.20100215090114.8393"><vh>visit_function</vh></v>
</v>
<v t="ekr.20100215090114.8394"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8395"><vh>raw_metrics.py</vh>
<v t="ekr.20100215090114.8396"><vh>raw_metrics declarations</vh></v>
<v t="ekr.20100215090114.8397"><vh>report_raw_stats</vh></v>
<v t="ekr.20100215090114.8398"><vh>class RawMetricsChecker</vh>
<v t="ekr.20100215090114.8399"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8400"><vh>open</vh></v>
<v t="ekr.20100215090114.8401"><vh>process_tokens</vh></v>
</v>
<v t="ekr.20100215090114.8402"><vh>get_type</vh></v>
<v t="ekr.20100215090114.8403"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8404"><vh>similar.py</vh>
<v t="ekr.20100215090114.8405"><vh>similar declarations</vh></v>
<v t="ekr.20100215090114.8406"><vh>class Similar</vh>
<v t="ekr.20100215090114.8407"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8408"><vh>append_stream</vh></v>
<v t="ekr.20100215090114.8409"><vh>run</vh></v>
<v t="ekr.20100215090114.8410"><vh>_compute_sims</vh></v>
<v t="ekr.20100215090114.8411"><vh>_display_sims</vh></v>
<v t="ekr.20100215090114.8412"><vh>_find_common</vh></v>
<v t="ekr.20100215090114.8413"><vh>_iter_sims</vh></v>
</v>
<v t="ekr.20100215090114.8414"><vh>stripped_lines</vh></v>
<v t="ekr.20100215090114.8415"><vh>class LineSet</vh>
<v t="ekr.20100215090114.8416"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8417"><vh>__str__</vh></v>
<v t="ekr.20100215090114.8418"><vh>__len__</vh></v>
<v t="ekr.20100215090114.8419"><vh>__getitem__</vh></v>
<v t="ekr.20100215090114.8420"><vh>__cmp__</vh></v>
<v t="ekr.20100215090114.8421"><vh>__hash__</vh></v>
<v t="ekr.20100215090114.8422"><vh>enumerate_stripped</vh></v>
<v t="ekr.20100215090114.8423"><vh>find</vh></v>
<v t="ekr.20100215090114.8424"><vh>_mk_index</vh></v>
</v>
<v t="ekr.20100215090114.8425"><vh>report_similarities</vh></v>
<v t="ekr.20100215090114.8426"><vh>class SimilarChecker</vh>
<v t="ekr.20100215090114.8427"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8428"><vh>set_option</vh></v>
<v t="ekr.20100215090114.8429"><vh>open</vh></v>
<v t="ekr.20100215090114.8430"><vh>process_module</vh></v>
<v t="ekr.20100215090114.8431"><vh>close</vh></v>
</v>
<v t="ekr.20100215090114.8432"><vh>register</vh></v>
<v t="ekr.20100215090114.8433"><vh>usage</vh></v>
<v t="ekr.20100215090114.8434"><vh>run</vh></v>
</v>
<v t="ekr.20100215090114.8435"><vh>string_format.py</vh>
<v t="ekr.20100215090114.8436"><vh>string_format declarations</vh></v>
<v t="ekr.20100215090114.8437"><vh>class IncompleteFormatStringException</vh></v>
<v t="ekr.20100215090114.8438"><vh>class UnsupportedFormatCharacterException</vh>
<v t="ekr.20100215090114.8439"><vh>__init__</vh></v>
</v>
<v t="ekr.20100215090114.8440"><vh>parse_format_string</vh></v>
<v t="ekr.20100215090114.8441"><vh>class StringFormatChecker</vh>
<v t="ekr.20100215090114.8442"><vh>visit_binop</vh></v>
</v>
<v t="ekr.20100215090114.8443"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8444"><vh>typecheck.py **</vh>
<v t="ekr.20100215090114.8445"><vh>typecheck declarations</vh></v>
<v t="ekr.20100215090114.8446"><vh>class TypeChecker</vh>
<v t="ekr.20100215090114.8447"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8448"><vh>visit_assattr</vh></v>
<v t="ekr.20100215090114.8449"><vh>visit_delattr</vh></v>
<v t="ekr.20100215090114.8450"><vh>visit_getattr</vh></v>
<v t="ekr.20100215090114.8451"><vh>visit_assign</vh></v>
<v t="ekr.20100215090114.8452"><vh>visit_callfunc (****) TypeChecker</vh></v>
</v>
<v t="ekr.20100215090114.8453"><vh>register</vh></v>
</v>
<v t="ekr.20100215090114.8454"><vh>utils.py</vh>
<v t="ekr.20100215090114.8455"><vh>utils declarations</vh></v>
<v t="ekr.20100215090114.8456"><vh>safe_infer</vh></v>
<v t="ekr.20100215090114.8457"><vh>is_super</vh></v>
<v t="ekr.20100215090114.8458"><vh>is_error</vh></v>
<v t="ekr.20100215090114.8459"><vh>is_raising</vh></v>
<v t="ekr.20100215090114.8460"><vh>is_empty</vh></v>
<v t="ekr.20100215090114.8461"><vh>is_builtin</vh></v>
<v t="ekr.20100215090114.8462"><vh>is_defined_before</vh></v>
<v t="ekr.20100215090114.8463"><vh>is_func_default</vh></v>
<v t="ekr.20100215090114.8464"><vh>is_func_decorator</vh></v>
<v t="ekr.20100215090114.8465"><vh>is_ancestor_name</vh></v>
<v t="ekr.20100215090114.8466"><vh>assign_parent</vh></v>
<v t="ekr.20100215090114.8467"><vh>overrides_an_abstract_method</vh></v>
<v t="ekr.20100215090114.8468"><vh>overrides_a_method</vh></v>
</v>
<v t="ekr.20100215090114.8469"><vh>variables.py ****</vh>
<v t="ekr.20100215090114.8470"><vh>variables declarations</vh></v>
<v t="ekr.20100215090114.8471"><vh>overridden_method</vh></v>
<v t="ekr.20100215090114.8472"><vh>class VariablesChecker (BaseChecker)</vh>
<v t="ekr.20100215090114.8473"><vh>__init__</vh></v>
<v t="ekr.20100215090114.8474"><vh>visit_module</vh></v>
<v t="ekr.20100215090114.8475"><vh>leave_module</vh></v>
<v t="ekr.20100215090114.8476"><vh>visit_class</vh></v>
<v t="ekr.20100215090114.8477"><vh>leave_class</vh></v>
<v t="ekr.20100215090114.8478"><vh>visit_lambda</vh></v>
<v t="ekr.20100215090114.8479"><vh>leave_lambda</vh></v>
<v t="ekr.20100215090114.8480"><vh>visit_genexpr</vh></v>
<v t="ekr.20100215090114.8481"><vh>leave_genexpr</vh></v>
<v t="ekr.20100215090114.8482"><vh>visit_function</vh></v>
<v t="ekr.20100215090114.8483"><vh>leave_function</vh></v>
<v t="ekr.20100215090114.8484"><vh>visit_global</vh></v>
<v t="ekr.20100215090114.8485"><vh>_loopvar_name</vh></v>
<v t="ekr.20100215090114.8486"><vh>visit_assname</vh></v>
<v t="ekr.20100215090114.8487"><vh>visit_delname</vh></v>
<v t="ekr.20100215090114.8488"><vh>visit_name (****) (VariablesChecker)</vh></v>
<v t="ekr.20100215090114.8489"><vh>visit_import</vh></v>
<v t="ekr.20100215090114.8490"><vh>visit_from</vh></v>
<v t="ekr.20100215090114.8491"><vh>_check_module_attrs</vh></v>
</v>
<v t="ekr.20100215090114.8492"><vh>register</vh></v>
</v>
</v>
<v t="ekr.20100215140704.5180"><vh>Important checkers</vh>
<v t="ekr.20100215090114.8286"></v>
<v t="ekr.20100215090114.8444"></v>
<v t="ekr.20100215090114.8469"></v>
<v t="ekr.20100215090114.8274"></v>
<v t="ekr.20100215090114.8488"></v>
<v t="ekr.20100215090114.8452"></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20100212224846.10000">def visit_assert(self, node):
    """dummy method for visiting an Assert node"""

</t>
<t tx="ekr.20100212224846.10001">def visit_assign(self, node):
    """dummy method for visiting an Assign node"""

</t>
<t tx="ekr.20100212224846.10002">def visit_assname(self, node):
    """dummy method for visiting an AssName node"""

</t>
<t tx="ekr.20100212224846.10003">def visit_augassign(self, node):
    """dummy method for visiting an AugAssign node"""

</t>
<t tx="ekr.20100212224846.10004">def visit_backquote(self, node):
    """dummy method for visiting an Backquote node"""

</t>
<t tx="ekr.20100212224846.10005">def visit_binop(self, node):
    """dummy method for visiting an BinOp node"""

</t>
<t tx="ekr.20100212224846.10006">def visit_boolop(self, node):
    """dummy method for visiting an BoolOp node"""

</t>
<t tx="ekr.20100212224846.10007">def visit_break(self, node):
    """dummy method for visiting an Break node"""

</t>
<t tx="ekr.20100212224846.10008">def visit_callfunc(self, node):
    """dummy method for visiting an CallFunc node"""

</t>
<t tx="ekr.20100212224846.10009">def visit_class(self, node):
    """dummy method for visiting an Class node"""

</t>
<t tx="ekr.20100212224846.10010">def visit_compare(self, node):
    """dummy method for visiting an Compare node"""

</t>
<t tx="ekr.20100212224846.10011">def visit_comprehension(self, node):
    """dummy method for visiting an Comprehension node"""

</t>
<t tx="ekr.20100212224846.10012">def visit_const(self, node):
    """dummy method for visiting an Const node"""

</t>
<t tx="ekr.20100212224846.10013">def visit_continue(self, node):
    """dummy method for visiting an Continue node"""

</t>
<t tx="ekr.20100212224846.10014">def visit_decorators(self, node):
    """dummy method for visiting an Decorators node"""

</t>
<t tx="ekr.20100212224846.10015">def visit_delattr(self, node):
    """dummy method for visiting an DelAttr node"""

</t>
<t tx="ekr.20100212224846.10016">def visit_delete(self, node):
    """dummy method for visiting an Delete node"""

</t>
<t tx="ekr.20100212224846.10017">def visit_delname(self, node):
    """dummy method for visiting an DelName node"""

</t>
<t tx="ekr.20100212224846.10018">def visit_dict(self, node):
    """dummy method for visiting an Dict node"""

</t>
<t tx="ekr.20100212224846.10019">def visit_discard(self, node):
    """dummy method for visiting an Discard node"""

</t>
<t tx="ekr.20100212224846.10020">def visit_emptynode(self, node):
    """dummy method for visiting an EmptyNode node"""

</t>
<t tx="ekr.20100212224846.10021">def visit_excepthandler(self, node):
    """dummy method for visiting an ExceptHandler node"""

</t>
<t tx="ekr.20100212224846.10022">def visit_ellipsis(self, node):
    """dummy method for visiting an Ellipsis node"""

</t>
<t tx="ekr.20100212224846.10023">def visit_empty(self, node):
    """dummy method for visiting an Empty node"""

</t>
<t tx="ekr.20100212224846.10024">def visit_exec(self, node):
    """dummy method for visiting an Exec node"""

</t>
<t tx="ekr.20100212224846.10025">def visit_extslice(self, node):
    """dummy method for visiting an ExtSlice node"""

</t>
<t tx="ekr.20100212224846.10026">def visit_for(self, node):
    """dummy method for visiting an For node"""

</t>
<t tx="ekr.20100212224846.10027">def visit_from(self, node):
    """dummy method for visiting an From node"""

</t>
<t tx="ekr.20100212224846.10028">def visit_function(self, node):
    """dummy method for visiting an Function node"""

</t>
<t tx="ekr.20100212224846.10029">def visit_genexpr(self, node):
    """dummy method for visiting an ListComp node"""

</t>
<t tx="ekr.20100212224846.10030">def visit_getattr(self, node):
    """dummy method for visiting an Getattr node"""

</t>
<t tx="ekr.20100212224846.10031">def visit_global(self, node):
    """dummy method for visiting an Global node"""

</t>
<t tx="ekr.20100212224846.10032">def visit_if(self, node):
    """dummy method for visiting an If node"""

</t>
<t tx="ekr.20100212224846.10033">def visit_ifexp(self, node):
    """dummy method for visiting an IfExp node"""

</t>
<t tx="ekr.20100212224846.10034">def visit_import(self, node):
    """dummy method for visiting an Import node"""

</t>
<t tx="ekr.20100212224846.10035">def visit_index(self, node):
    """dummy method for visiting an Index node"""

</t>
<t tx="ekr.20100212224846.10036">def visit_keyword(self, node):
    """dummy method for visiting an Keyword node"""

</t>
<t tx="ekr.20100212224846.10037">def visit_lambda(self, node):
    """dummy method for visiting an Lambda node"""

</t>
<t tx="ekr.20100212224846.10038">def visit_list(self, node):
    """dummy method for visiting an List node"""

</t>
<t tx="ekr.20100212224846.10039">def visit_listcomp(self, node):
    """dummy method for visiting an ListComp node"""

</t>
<t tx="ekr.20100212224846.10040">def visit_module(self, node):
    """dummy method for visiting an Module node"""

</t>
<t tx="ekr.20100212224846.10041">def visit_name(self, node):
    """dummy method for visiting an Name node"""

</t>
<t tx="ekr.20100212224846.10042">def visit_pass(self, node):
    """dummy method for visiting an Pass node"""

</t>
<t tx="ekr.20100212224846.10043">def visit_print(self, node):
    """dummy method for visiting an Print node"""

</t>
<t tx="ekr.20100212224846.10044">def visit_raise(self, node):
    """dummy method for visiting an Raise node"""

</t>
<t tx="ekr.20100212224846.10045">def visit_return(self, node):
    """dummy method for visiting an Return node"""

</t>
<t tx="ekr.20100212224846.10046">def visit_slice(self, node):
    """dummy method for visiting an Slice node"""

</t>
<t tx="ekr.20100212224846.10047">def visit_subscript(self, node):
    """dummy method for visiting an Subscript node"""

</t>
<t tx="ekr.20100212224846.10048">def visit_tryexcept(self, node):
    """dummy method for visiting an TryExcept node"""

</t>
<t tx="ekr.20100212224846.10049">def visit_tryfinally(self, node):
    """dummy method for visiting an TryFinally node"""

</t>
<t tx="ekr.20100212224846.10050">def visit_tuple(self, node):
    """dummy method for visiting an Tuple node"""

</t>
<t tx="ekr.20100212224846.10051">def visit_unaryop(self, node):
    """dummy method for visiting an UnaryOp node"""

</t>
<t tx="ekr.20100212224846.10052">def visit_while(self, node):
    """dummy method for visiting an While node"""

</t>
<t tx="ekr.20100212224846.10053">def visit_with(self, node):
    """dummy method for visiting an With node"""

</t>
<t tx="ekr.20100212224846.10054">def visit_yield(self, node):
    """dummy method for visiting an Yield node"""


</t>
<t tx="ekr.20100212224846.10055">REDIRECT = {'arguments': 'Arguments',
            'Attribute': 'Getattr',
            'comprehension': 'Comprehension',
            'Call': 'CallFunc',
            'ClassDef': 'Class',
            "ListCompFor": 'Comprehension',
            "GenExprFor": 'Comprehension',
            'excepthandler': 'ExceptHandler',
            'Expr': 'Discard',
            'FunctionDef': 'Function',
            'GeneratorExp': 'GenExpr',
            'ImportFrom': 'From',
            'keyword': 'Keyword',
            'Repr': 'Backquote',

            'Add': 'BinOp',
            'Bitand': 'BinOp',
            'Bitor': 'BinOp',
            'Bitxor': 'BinOp',
            'Div': 'BinOp',
            'FloorDiv': 'BinOp',
            'LeftShift': 'BinOp',
            'Mod': 'BinOp',
            'Mul': 'BinOp',
            'Power': 'BinOp',
            'RightShift': 'BinOp',
            'Sub': 'BinOp',

            'And': 'BoolOp',
            'Or': 'BoolOp',

            'UnaryAdd': 'UnaryOp',
            'UnarySub': 'UnaryOp',
            'Not': 'UnaryOp',
            'Invert': 'UnaryOp'
            }

class ASTWalker:
    """a walker visiting a tree in preorder, calling on the handler:

    * visit_&lt;class name&gt; on entering a node, where class name is the class of
    the node in lower case

    * leave_&lt;class name&gt; on leaving a node, where class name is the class of
    the node in lower case
    """
    REDIRECTION = REDIRECT

    @others
</t>
<t tx="ekr.20100212224846.10056">def __init__(self, handler):
    self.handler = handler
    self._cache = {}

</t>
<t tx="ekr.20100212224846.10057">def walk(self, node, _done=None):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    if _done is None:
        _done = set()
    if node in _done:
        raise AssertionError((id(node), node, node.parent))
    _done.add(node)
    try:
        self.visit(node)
    except IgnoreChild:
        pass
    else:
        try:
            for child_node in node.get_children():
                self.handler.set_context(node, child_node)
                assert child_node is not node
                self.walk(child_node, _done)
        except AttributeError:
            print node.__class__, id(node.__class__)
            raise
    self.leave(node)
    assert node.parent is not node

</t>
<t tx="ekr.20100212224846.10058">def get_callbacks(self, node):
    """get callbacks from handler for the visited node"""
    klass = node.__class__
    methods = self._cache.get(klass)
    if methods is None:
        handler = self.handler
        kid = self.REDIRECTION.get(klass.__name__, klass.__name__).lower()
        e_method = getattr(handler, 'visit_%s' % kid,
                           getattr(handler, 'visit_default', None))
        l_method = getattr(handler, 'leave_%s' % kid,
                           getattr(handler, 'leave_default', None))
        self._cache[klass] = (e_method, l_method)
    else:
        e_method, l_method = methods
    return e_method, l_method

</t>
<t tx="ekr.20100212224846.10059">def visit(self, node):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    method = self.get_callbacks(node)[0]
    if method is not None:
        method(node)

</t>
<t tx="ekr.20100212224846.10060">def leave(self, node):
    """walk on the tree from &lt;node&gt;, getting callbacks from handler"""
    method = self.get_callbacks(node)[1]
    if method is not None:
        method(node)


</t>
<t tx="ekr.20100212224846.10061">class LocalsVisitor(ASTWalker):
    """visit a project by traversing the locals dictionary"""
    @others
</t>
<t tx="ekr.20100212224846.10062">def __init__(self):
    ASTWalker.__init__(self, self)
    self._visited = {}

</t>
<t tx="ekr.20100212224846.10063">def visit(self, node):
    """launch the visit starting from the given node"""
    if self._visited.has_key(node):
        return
    self._visited[node] = 1 # FIXME: use set ?
    methods = self.get_callbacks(node)
    recurse = 1
    if methods[0] is not None:
        try:
            methods[0](node)
        except IgnoreChild:
            recurse = 0
    if recurse:
        if 'locals' in node.__dict__: # skip Instance and other proxy
            for name, local_node in node.items():
                self.visit(local_node)
    if methods[1] is not None:
        return methods[1](node)

</t>
<t tx="ekr.20100212224846.10064">@language python
@tabwidth -4

"""this module contains exceptions used in the astng library
"""

@others
</t>
<t tx="ekr.20100212224846.10065">__doctype__ = "restructuredtext en"

</t>
<t tx="ekr.20100212224846.10066">class ASTNGError(Exception):
    """base exception class for all astng related exceptions"""

</t>
<t tx="ekr.20100212224846.10067">class ASTNGBuildingException(ASTNGError):
    """exception class when we are unable to build an astng representation"""

</t>
<t tx="ekr.20100212224846.10068">class ResolveError(ASTNGError):
    """base class of astng resolution/inference error"""

</t>
<t tx="ekr.20100212224846.10069">class NotFoundError(ResolveError):
    """raised when we are unable to resolve a name"""

</t>
<t tx="ekr.20100212224846.10070">class InferenceError(ResolveError):
    """raised when we are unable to infer a node"""

</t>
<t tx="ekr.20100212224846.10071">class UnresolvableName(InferenceError):
    """raised when we are unable to resolve a name"""

</t>
<t tx="ekr.20100212224846.10072">class NoDefault(ASTNGError):
    """raised by function's `default_value` method when an argument has
    no default value
    """

</t>
<t tx="ekr.20100212224846.10073">class IgnoreChild(Exception):
    """exception that maybe raised by visit methods to avoid children traversal
    """

</t>
<t tx="ekr.20100212224846.10074">class NodeRemoved(Exception):
    """exception raised to interrupt the walk when a node is removed"""
</t>
<t tx="ekr.20100212224846.10075">@first # -*- coding: utf-8 -*-

@language python
@tabwidth -4

"""
Module containing the node classes; it is only used for avoiding circular imports
"""

@others
</t>
<t tx="ekr.20100212224846.10076">from __future__ import generators

__docformat__ = "restructuredtext en"

from itertools import imap

try:
    from logilab.astng._nodes_ast import *
    from logilab.astng._nodes_ast import _const_factory
    AST_MODE = '_ast'
except ImportError:
    from logilab.astng._nodes_compiler import *
    from logilab.astng._nodes_compiler import _const_factory
    AST_MODE = 'compiler'
from logilab.astng.utils import REDIRECT

INFER_NEED_NAME_STMTS = (From, Import, Global, TryExcept)
LOOP_SCOPES = (Comprehension, For,)


STMT_NODES = (
    Assert, Assign, AugAssign, Break, Class, Continue, Delete, Discard,
    ExceptHandler, Exec, For, From, Function, Global, If, Import, Pass, Print,
    Raise, Return, TryExcept, TryFinally, While, With
    )

ALL_NODES = STMT_NODES + (
    Arguments, AssAttr, AssName, BinOp, BoolOp, Backquote,  CallFunc, Compare,
    Comprehension, Const, Decorators, DelAttr, DelName, Dict, Ellipsis,
    EmptyNode,  ExtSlice, Getattr,  GenExpr, IfExp, Index, Keyword, Lambda,
    List,  ListComp, Module, Name, Slice, Subscript, UnaryOp, Tuple, Yield
    )


</t>
<t tx="ekr.20100212224846.10077"># Node  ######################################################################

class NodeNG:
    """/!\ this class should not be used directly /!\
    It is used as method and attribute container, and updates the
    original class from the compiler.ast / _ast module using its dictionary
    (see below the class definition)
    """
    is_statement = False
    # attributes below are set by the builder module or by raw factories
    lineno = None
    fromlineno = None
    tolineno = None
    # parent node in the tree
    parent = None

    @others
</t>
<t tx="ekr.20100212224846.10078">def __str__(self):
    return '%s(%s)' % (self.__class__.__name__, getattr(self, 'name', ''))

</t>
<t tx="ekr.20100212224846.10079">def accept(self, visitor):
    klass = self.__class__.__name__
    func = getattr(visitor, "visit_" + REDIRECT.get(klass, klass).lower())
    return func(self)

</t>
<t tx="ekr.20100212224846.10080">def get_children(self):
    d = self.__dict__
    for f in self._astng_fields:
        attr = d[f]
        if attr is None:
            continue
        if isinstance(attr, (list, tuple)):
            for elt in attr:
                yield elt
        else:
            yield attr

</t>
<t tx="ekr.20100212224846.10081">def parent_of(self, node):
    """return true if i'm a parent of the given node"""
    parent = node.parent
    while parent is not None:
        if self is parent:
            return True
        parent = parent.parent
    return False

</t>
<t tx="ekr.20100212224846.10082">def statement(self):
    """return the first parent node marked as statement node"""
    if self.is_statement:
        return self
    return self.parent.statement()

</t>
<t tx="ekr.20100212224846.10083">def frame(self):
    """return the first parent frame node (i.e. Module, Function or Class)
    """
    return self.parent.frame()

</t>
<t tx="ekr.20100212224846.10084">def scope(self):
    """return the first node defining a new scope (i.e. Module, Function,
    Class, Lambda but also GenExpr)
    """
    return self.parent.scope()

</t>
<t tx="ekr.20100212224846.10085">def root(self):
    """return the root node of the tree, (i.e. a Module)"""
    if self.parent:
        return self.parent.root()
    return self

</t>
<t tx="ekr.20100212224846.10086">def child_sequence(self, child):
    """search for the right sequence where the child lies in"""
    for field in self._astng_fields:
        node_or_sequence = getattr(self, field)
        if node_or_sequence is child:
            return [node_or_sequence]
        # /!\ compiler.ast Nodes have an __iter__ walking over child nodes
        if isinstance(node_or_sequence, (tuple, list)) and child in node_or_sequence:
            return node_or_sequence
    else:
        msg = 'Could not found %s in %s\'s children'
        raise ASTNGError(msg % (repr(child), repr(self)))

</t>
<t tx="ekr.20100212224846.10087">def locate_child(self, child):
    """return a 2-uple (child attribute name, sequence or node)"""
    for field in self._astng_fields:
        node_or_sequence = getattr(self, field)
        # /!\ compiler.ast Nodes have an __iter__ walking over child nodes
        if child is node_or_sequence:
            return field, child
        if isinstance(node_or_sequence, (tuple, list)) and child in node_or_sequence:
            return field, node_or_sequence
    msg = 'Could not found %s in %s\'s children'
    raise ASTNGError(msg % (repr(child), repr(self)))

</t>
<t tx="ekr.20100212224846.10088">def next_sibling(self):
    """return the next sibling statement"""
    return self.parent.next_sibling()

</t>
<t tx="ekr.20100212224846.10089">def previous_sibling(self):
    """return the previous sibling statement"""
    return self.parent.previous_sibling()

</t>
<t tx="ekr.20100212224846.10090">def nearest(self, nodes):
    """return the node which is the nearest before this one in the
    given list of nodes
    """
    myroot = self.root()
    mylineno = self.fromlineno
    nearest = None, 0
    for node in nodes:
        assert node.root() is myroot, \
               'not from the same module %s' % (self, node)
        lineno = node.fromlineno
        if node.fromlineno &gt; mylineno:
            break
        if lineno &gt; nearest[1]:
            nearest = node, lineno
    # FIXME: raise an exception if nearest is None ?
    return nearest[0]

</t>
<t tx="ekr.20100212224846.10091">def set_line_info(self, lastchild):
    if self.lineno is None:
        self.fromlineno = self._fixed_source_line()
    else:
        self.fromlineno = self.lineno
    if lastchild is None:
        self.tolineno = self.fromlineno
    else:
        self.tolineno = lastchild.tolineno
    assert self.fromlineno is not None, self
    assert self.tolineno is not None, self

</t>
<t tx="ekr.20100212224846.10092">def _fixed_source_line(self):
    """return the line number where the given node appears

    we need this method since not all nodes have the lineno attribute
    correctly set...
    """
    line = self.lineno
    _node = self
    try:
        while line is None:
            _node = _node.get_children().next()
            line = _node.lineno
    except StopIteration:
        _node = self.parent
        while _node and line is None:
            line = _node.lineno
            _node = _node.parent
    return line

</t>
<t tx="ekr.20100212224846.10093">def block_range(self, lineno):
    """handle block line numbers range for non block opening statements
    """
    return lineno, self.tolineno

</t>
<t tx="ekr.20100212224846.10094">def set_local(self, name, stmt):
    """delegate to a scoped parent handling a locals dictionary"""
    self.parent.set_local(name, stmt)

</t>
<t tx="ekr.20100212224846.10095">def nodes_of_class(self, klass, skip_klass=None):
    """return an iterator on nodes which are instance of the given class(es)

    klass may be a class object or a tuple of class objects
    """
    if isinstance(self, klass):
        yield self
    for child_node in self.get_children():
        if skip_klass is not None and isinstance(child_node, skip_klass):
            continue
        for matching in child_node.nodes_of_class(klass, skip_klass):
            yield matching

</t>
<t tx="ekr.20100212224846.10096">def _infer_name(self, frame, name):
    if isinstance(self, INFER_NEED_NAME_STMTS) or (
             isinstance(self, Arguments) and self.parent is frame):
        return name
    return None

</t>
<t tx="ekr.20100212224846.10097">def callable(self):
    return False

</t>
<t tx="ekr.20100212224846.10098">def eq(self, value):
    return False

</t>
<t tx="ekr.20100212224846.10099">def as_string(self):
    from logilab.astng.nodes_as_string import as_string
    return as_string(self)

</t>
<t tx="ekr.20100212224846.10100">def repr_tree(self):
    """print a nice astng tree representation"""
    result = []
    _repr_tree(self, result)
    print "\n".join(result)


</t>
<t tx="ekr.20100212224846.10101">INDENT = "    "

def _repr_tree(node, result, indent='', _done=None):
    """built a tree representation of a node as a list of lines"""
    if _done is None:
        _done = set()
    if not hasattr(node, '_astng_fields'): # not a astng node
        return
    if node in _done:
        result.append( indent + 'loop in tree: %s' % node )
        return
    _done.add(node)
    result.append( indent + str(node))
    indent += INDENT
    for field in node._astng_fields:
        value = getattr(node, field)
        if isinstance(value, (list, tuple) ):
            result.append(  indent + field + " = [" )
            for child in value:
                if isinstance(child, (list, tuple) ):
                    # special case for Dict # FIXME
                     _repr_tree(child[0], result, indent, _done)
                     _repr_tree(child[1], result, indent, _done)
                     result.append(indent + ',')
                else:
                    _repr_tree(child, result, indent, _done)
            result.append(  indent + "]" )
        else:
            result.append(  indent + field + " = " )
            _repr_tree(value, result, indent, _done)




</t>
<t tx="ekr.20100212224846.10102"># some small MixIns for extending the node classes #######################

class StmtMixIn(object):
    """StmtMixIn used only for a adding a few attributes"""
    is_statement = True

    @others
</t>
<t tx="ekr.20100212224846.10103">def replace(self, child, newchild):
    sequence = self.child_sequence(child)
    newchild.parent = self
    child.parent = None
    sequence[sequence.index(child)] = newchild

</t>
<t tx="ekr.20100212224846.10104">def next_sibling(self):
    """return the next sibling statement"""
    stmts = self.parent.child_sequence(self)
    index = stmts.index(self)
    try:
        return stmts[index +1]
    except IndexError:
        pass

</t>
<t tx="ekr.20100212224846.10105">def previous_sibling(self):
    """return the previous sibling statement"""
    stmts = self.parent.child_sequence(self)
    index = stmts.index(self)
    if index &gt;= 1:
        return stmts[index -1]


</t>
<t tx="ekr.20100212224846.10106">class BlockRangeMixIn(object):
    """override block range """
    @others
</t>
<t tx="ekr.20100212224846.10107">def set_line_info(self, lastchild):
    self.fromlineno = self.lineno
    self.tolineno = lastchild.tolineno
    self.blockstart_tolineno = self._blockstart_toline()

</t>
<t tx="ekr.20100212224846.10108">def _elsed_block_range(self, lineno, orelse, last=None):
    """handle block line numbers range for try/finally, for, if and while
    statements
    """
    if lineno == self.fromlineno:
        return lineno, lineno
    if orelse:
        if lineno &gt;= orelse[0].fromlineno:
            return lineno, orelse[-1].tolineno
        return lineno, orelse[0].fromlineno - 1
    return lineno, last or self.tolineno


</t>
<t tx="ekr.20100212224846.10109">#constants ... ##############################################################

CONST_CLS = {
    list: List,
    tuple: Tuple,
    dict: Dict,
    }

def const_factory(value):
    """return an astng node for a python value"""
    try:
        # if value is of class list, tuple, dict use specific class, not Const
        cls = CONST_CLS[value.__class__]
        node = cls()
        if isinstance(node, Dict):
            node.items = ()
        else:
            node.elts = ()
    except KeyError:
        try:
            node = Const(value)
        except KeyError:
            node = _const_factory(value)
    return node

</t>
<t tx="ekr.20100212224846.10110">@language python
@tabwidth -4

"""python 2.5 builtin _ast compatibility module
"""

@others
</t>
<t tx="ekr.20100212224846.10111">__docformat__ = "restructuredtext en"

#  "as is" nodes
from _ast import (Assert, Assign, AugAssign,
                  BinOp, BoolOp, Break,
                  Compare, Continue,
                  Delete, Dict,
                  Ellipsis, Exec, ExtSlice,
                  For,
                  Global,
                  If, IfExp, Import, Index,
                  Lambda, List, ListComp,
                  Module,
                  Name,
                  Pass, Print,
                  Raise, Return,
                  Slice, Subscript,
                  TryExcept, TryFinally, Tuple,
                  UnaryOp,
                  While, With,
                  Yield,
                  )
#  aliased nodes
from _ast import (AST as Node,
                  Attribute as Getattr,
                  Call as CallFunc,
                  ClassDef as Class,
                  Expr as Discard,
                  FunctionDef as Function,
                  GeneratorExp as GenExpr,
                  ImportFrom as From,
                  Repr as Backquote,
                  arguments as Arguments,
                  comprehension as Comprehension,
                  keyword as Keyword,
                  excepthandler as ExceptHandler,
                  )
# nodes which are not part of astng
from _ast import (
    # binary operators
    Add as _Add, Div as _Div, FloorDiv as _FloorDiv,
    Mod as _Mod, Mult as _Mult, Pow as _Pow, Sub as _Sub,
    BitAnd as _BitAnd, BitOr as _BitOr, BitXor as _BitXor,
    LShift as _LShift, RShift as _RShift,
    # logical operators
    And as _And, Or as _Or,
    # unary operators
    UAdd as _UAdd, USub as _USub, Not as _Not, Invert as _Invert,
    # comparison operators
    Eq as _Eq, Gt as _Gt, GtE as _GtE, In as _In, Is as _Is,
    IsNot as _IsNot, Lt as _Lt, LtE as _LtE, NotEq as _NotEq,
    NotIn as _NotIn,
    # other nodes which are not part of astng
    Num as _Num, Str as _Str, Load as _Load, Store as _Store, Del as _Del,
    )

from logilab.astng.utils import ASTVisitor

Proxy_ = object

_BIN_OP_CLASSES = {_Add: '+',
                   _BitAnd: '&amp;',
                   _BitOr: '|',
                   _BitXor: '^',
                   _Div: '/',
                   _FloorDiv: '//',
                   _Mod: '%',
                   _Mult: '*',
                   _Pow: '**',
                   _Sub: '-',
                   _LShift: '&lt;&lt;',
                   _RShift: '&gt;&gt;'}

_BOOL_OP_CLASSES = {_And: 'and',
                    _Or: 'or'}

_UNARY_OP_CLASSES = {_UAdd: '+',
                     _USub: '-',
                     _Not: 'not',
                     _Invert: '~'}

_CMP_OP_CLASSES = {_Eq: '==',
                   _Gt: '&gt;',
                   _GtE: '&gt;=',
                   _In: 'in',
                   _Is: 'is',
                   _IsNot: 'is not',
                   _Lt: '&lt;',
                   _LtE: '&lt;=',
                   _NotEq: '!=',
                   _NotIn: 'not in'}


</t>
<t tx="ekr.20100212224846.10112">def _init_set_doc(node):
    node.doc = None
    try:
        if isinstance(node.body[0], Discard) and isinstance(node.body[0].value, _Str):
            node.tolineno = node.body[0].lineno
            node.doc = node.body[0].value.s
            node.body = node.body[1:]
    except IndexError:
        pass # ast built from scratch


</t>
<t tx="ekr.20100212224846.10113">def native_repr_tree(node, indent='', _done=None):
    if _done is None:
        _done = set()
    if node in _done:
        print ('loop in tree: %r (%s)' % (node, getattr(node, 'lineno', None)))
        return
    _done.add(node)
    print indent + str(node)
    if type(node) is str: # XXX crash on Globals
        return
    indent += '    '
    d = node.__dict__
    if hasattr(node, '_attributes'):
        for a in node._attributes:
            attr = d[a]
            if attr is None:
                continue
            print indent + a, repr(attr)
    for f in node._fields or ():
        attr = d[f]
        if attr is None:
            continue
        if type(attr) is list:
            if not attr: continue
            print indent + f + ' ['
            for elt in attr:
                native_repr_tree(elt, indent, _done)
            print indent + ']'
            continue
        if isinstance(attr, (_Load, _Store, _Del)):
            continue
        if isinstance(attr, Node):
            print indent + f
            native_repr_tree(attr, indent, _done)
        else:
            print indent + f, repr(attr)


</t>
<t tx="ekr.20100212224846.10114">from _ast import Str as _Str, Num as _Num
_Num.accept = lambda self, visitor: visitor.visit_num(self)
_Str.accept = lambda self, visitor: visitor.visit_str(self)

# some astng nodes unexistant in _ast #########################################

class AssAttr(Node):
    """represent Attribute Assignment statements"""

</t>
<t tx="ekr.20100212224846.10115">class AssName(Node):
    """represent AssName statements"""

</t>
<t tx="ekr.20100212224846.10116">class Const(Node):
    """represent a Str or Num node"""
    @others
</t>
<t tx="ekr.20100212224846.10117">def __init__(self, value=None):
    super(Const, self).__init__()
    self.value = value

</t>
<t tx="ekr.20100212224846.10118">class DelAttr(Node):
    """represent del attribute statements"""

</t>
<t tx="ekr.20100212224846.10119">class DelName(Node):
    """represent del statements"""

</t>
<t tx="ekr.20100212224846.10120">class EmptyNode(Node):
    """represent a Empty node for compatibility"""

</t>
<t tx="ekr.20100212224846.10121">class Decorators(Node):
    """represent a Decorator node"""
    @others
</t>
<t tx="ekr.20100212224846.10122">def __init__(self, nodes):
    self.nodes = nodes

</t>
<t tx="ekr.20100212224846.10123"># _ast rebuilder ##############################################################

class TreeRebuilder(ASTVisitor):
    """REbuilds the _ast tree to become an ASTNG tree"""
    @others
</t>
<t tx="ekr.20100212224846.10124">
def __init__(self, rebuild_visitor):
    self.visitor = rebuild_visitor

</t>
<t tx="ekr.20100212224846.10125">def visit_assert(self, node):
    node.fail = node.msg
    del node.msg

</t>
<t tx="ekr.20100212224846.10126">def visit_augassign(self, node):
    node.op = _BIN_OP_CLASSES[node.op.__class__]

</t>
<t tx="ekr.20100212224846.10127">def visit_binop(self, node):
    node.op = _BIN_OP_CLASSES[node.op.__class__]

</t>
<t tx="ekr.20100212224846.10128">def visit_boolop(self, node):
    node.op = _BOOL_OP_CLASSES[node.op.__class__]

</t>
<t tx="ekr.20100212224846.10129">def visit_callfunc(self, node):
    node.args.extend(node.keywords)
    del node.keywords

</t>
<t tx="ekr.20100212224846.10130">def visit_class(self, node):
    _init_set_doc(node)

</t>
<t tx="ekr.20100212224846.10131">def visit_compare(self, node):
    node.ops = [(_CMP_OP_CLASSES[op.__class__], expr)
                for op, expr in zip(node.ops, node.comparators)]
    del node.comparators

</t>
<t tx="ekr.20100212224846.10132">def visit_dict(self, node):
    node.items = zip(node.keys, node.values)
    del node.keys, node.values

</t>
<t tx="ekr.20100212224846.10133">def visit_exec(self, node):
    node.expr = node.body
    del node.body

</t>
<t tx="ekr.20100212224846.10134">def visit_function(self, node):
    _init_set_doc(node)
    if 'decorators' in node._fields: # py &lt; 2.6
        attr = 'decorators'
    else:
        attr = 'decorator_list'
    decorators = getattr(node, attr)
    delattr(node, attr)
    if decorators:
        node.decorators = Decorators(decorators)
    else:
        node.decorators = None

</t>
<t tx="ekr.20100212224846.10135">def visit_getattr(self, node):
    node.attrname = node.attr
    node.expr = node.value
    del node.attr, node.value
    if isinstance(self.visitor.asscontext, Delete):
        node.__class__ = DelAttr
    elif self.visitor.asscontext is not None:
        node.__class__ = AssAttr

</t>
<t tx="ekr.20100212224846.10136">def visit_import(self, node):
    node.names = [(alias.name, alias.asname) for alias in node.names]

</t>
<t tx="ekr.20100212224846.10137">def visit_from(self, node):
    node.names = [(alias.name, alias.asname) for alias in node.names]
    node.modname = node.module
    del node.module

</t>
<t tx="ekr.20100212224846.10138">def visit_module(self, node):
    _init_set_doc(node)

</t>
<t tx="ekr.20100212224846.10139">def visit_name(self, node):
    node.name = node.id
    del node.id
    if isinstance(self.visitor.asscontext, Delete):
        node.__class__ = DelName
    elif self.visitor.asscontext is not None:
        node.__class__ = AssName

</t>
<t tx="ekr.20100212224846.10140">def visit_num(self, node):
    node.__class__ = Const
    node.value = node.n
    del node.n

</t>
<t tx="ekr.20100212224846.10141">def visit_str(self, node):
    node.__class__ = Const
    node.value = node.s
    del node.s

</t>
<t tx="ekr.20100212224846.10142">def visit_unaryop(self, node):
    node.op = _UNARY_OP_CLASSES[node.op.__class__]

</t>
<t tx="ekr.20100212224846.10143">def visit_with(self, node):
    """build compiler like node """
    node.vars = node.optional_vars
    node.expr = node.context_expr
    del node.optional_vars, node.context_expr


</t>
<t tx="ekr.20100212224846.10144"># raw building ################################################################

def module_factory(doc):
    node = Module()
    node.body = []
    node.doc = doc
    return node


</t>
<t tx="ekr.20100212224846.10145">def import_from_factory(modname, membername):
    node = From()
    node.level = 0
    node.modname = modname
    node.names = [(membername, None)]
    return node


</t>
<t tx="ekr.20100212224846.10146">def _const_factory(value):
    if isinstance(value, (int, long, complex, float, basestring)):
        node = Const()
    else:
        raise Exception(type(value))
    node.value = value
    return node


</t>
<t tx="ekr.20100212224846.10147">def function_factory(name, args, defaults, flag=0, doc=None):
    """create and initialize a astng Function node"""
    # XXX local import necessary due to cyclic deps
    from logilab.astng.nodes import const_factory
    node = Function()
    node.decorators = None
    node.body = []
    node.name = name
    # XXX ensure we get a compatible representation
    node.args = argsnode = Arguments()
    argsnode.args = []
    for arg in args:
        argsnode.args.append(Name())
        argsnode.args[-1].name = arg
        argsnode.args[-1].parent = argsnode
    argsnode.defaults = []
    for default in defaults:
        argsnode.defaults.append(const_factory(default))
        argsnode.defaults[-1].parent = argsnode
    argsnode.kwarg = None
    argsnode.vararg = None
    argsnode.parent = node
    node.doc = doc
    return node


</t>
<t tx="ekr.20100212224846.10148">def class_factory(name, basenames=(), doc=None):
    """create and initialize a astng Class node"""
    node = Class()
    node.body = []
    node.name = name
    # XXX to check
    node.bases = []
    for base in basenames:
        basenode = Name()
        basenode.name = base
        node.bases.append(basenode)
        basenode.parent = node
    node.doc = doc
    return node
</t>
<t tx="ekr.20100212224846.10149">@language python
@tabwidth -4

"""python &lt; 2.5 compiler package compatibility module [1]

 [1] http://docs.python.org/lib/module-compiler.ast.html

"""

@others
</t>
<t tx="ekr.20100212224846.10150">


__docformat__ = "restructuredtext en"

import sys
from compiler import ast
from compiler.ast import AssAttr, AssList, AssName, \
     AssTuple, Assert, Assign, AugAssign, \
     Backquote, Break, CallFunc, Class, \
     Compare, Const, Continue, Dict, Discard, \
     Ellipsis, EmptyNode, Exec, \
     For, From, Function, Getattr, Global, \
     If, Import, Keyword, Lambda, \
     List, ListComp, ListCompFor as Comprehension, ListCompIf, Module, Name, Node, \
     Pass, Print, Raise, Return, \
     Sliceobj, Stmt, Subscript, TryExcept, TryFinally, Tuple, \
     While, Yield

# nodes which are not part of astng
from compiler.ast import AssList as _AssList, AssTuple as _AssTuple,\
     Printnl as _Printnl, And as _And, Or as _Or,\
     UnaryAdd as _UnaryAdd, UnarySub as _UnarySub, Not as _Not,\
     Invert as _Invert, Add as _Add, Div as _Div, FloorDiv as _FloorDiv,\
     Mod as _Mod, Mul as _Mul, Power as _Power, Sub as _Sub, Bitand as _Bitand,\
     Bitor as _Bitor, Bitxor as _Bitxor, LeftShift as _LeftShift,\
     RightShift as _RightShift, \
     Slice as _Slice, GenExprFor as _GenExprFor

# set missing accept methods
_AssList.accept = lambda self, visitor: visitor.visit_asslist(self)
_AssTuple.accept = lambda self, visitor: visitor.visit_asstuple(self)
_Printnl.accept = lambda self, visitor: visitor.visit_printnl(self)
_Slice.accept = lambda self, visitor: visitor.visit_slice(self)
_GenExprFor.accept = lambda self, visitor: visitor.visit_comprehension(self)
for boolopcls in (_And, _Or):
    boolopcls.accept = lambda self, visitor: visitor.visit_boolop(self)
for unaryopcls in (_UnaryAdd, _UnarySub, _Not,_Invert):
    unaryopcls.accept = lambda self, visitor: visitor.visit_unaryop(self)
for binopcls in (_Add, _Div, _FloorDiv, _Mod, _Mul, _Power, _Sub, _Bitand,
                 _Bitor, _Bitxor, _LeftShift, _RightShift):
    binopcls.accept = lambda self, visitor: visitor.visit_binop(self)

try:
    # introduced in python 2.4
    from compiler.ast import GenExpr, GenExprIf, GenExprInner
except:
    class GenExpr:
        """dummy GenExpr node, shouldn't be used with py &lt; 2.4"""
    class GenExprIf:
        """dummy GenExprIf node, shouldn't be used with py &lt; 2.4"""
    class GenExprInner:
        """dummy GenExprInner node, shouldn't be used with py &lt; 2.4"""
try:
    # introduced in python 2.4
    from compiler.ast import Decorators
except ImportError:
    class Decorators:
        """dummy Decorators node, shouldn't be used with py &lt; 2.4"""
        def __init__(self, nodes=None):
            self.nodes = nodes

</t>
<t tx="ekr.20100212224846.10151"># dummy python &gt;= 2.5 nodes: if we are using py &gt;= 2.5 we will use _ast;
# but we need it for the other astng modules
class With: pass
</t>
<t tx="ekr.20100212224846.10152">class IfExp: pass

</t>
<t tx="ekr.20100212224846.10153"># introduced in python 2.5
From.level = 0 # will be overiden by instance attribute with py&gt;=2.5


from logilab.astng.utils import ASTVisitor
from logilab.astng._exceptions import NodeRemoved, ASTNGError

class Proxy_: pass


</t>
<t tx="ekr.20100212224846.10154">def native_repr_tree(node, indent='', _done=None):
    """enhanced compiler.ast tree representation"""
    if _done is None:
        _done = set()
    if node in _done:
        print ('loop in tree: %r (%s)' % (node, getattr(node, 'lineno', None)))
        return
    _done.add(node)
    print indent + "&lt;%s&gt;" % node.__class__
    indent += '    '
    if not hasattr(node, "__dict__"): # XXX
        return
    for field, attr in node.__dict__.items():
        if attr is None or field == "_proxied":
            continue
        if type(attr) is list:
            if not attr: continue
            print indent + field + ' ['
            for elt in attr:
                if type(elt) is tuple:
                    for val in elt:
                        native_repr_tree(val, indent, _done)
                else:
                    native_repr_tree(elt, indent, _done)
            print indent + ']'
            continue
        if isinstance(attr, Node):
            print indent + field
            native_repr_tree(attr, indent, _done)
        else:
            print indent + field,  repr(attr)


</t>
<t tx="ekr.20100212224846.10155"># some astng nodes unexistant in compiler #####################################

class ExceptHandler(Node):
    @others
</t>
<t tx="ekr.20100212224846.10156">def __init__(self, exc_type, name, body, parent):
    self.type = exc_type
    self.name = name
    self.body = body.nodes
    # XXX parent.lineno is wrong, cant't catch the right line ...
    if exc_type and exc_type.lineno:
        self.fromlineno =  exc_type.lineno
    else:
        self.fromlineno =  self.body[0].fromlineno - 1
    self.tolineno = self.body[-1].tolineno
    if name:
        self.blockstart_tolineno = name.tolineno
    elif exc_type:
        self.blockstart_tolineno = exc_type.tolineno
    else:
        self.blockstart_tolineno = self.fromlineno

</t>
<t tx="ekr.20100212224846.10157">class BinOp(Node):
    """replace Add, Div, FloorDiv, Mod, Mul, Power, Sub nodes"""
    OP_CLASSES = {_Add: '+',
                  _Div: '/',
                  _FloorDiv: '//',
                  _Mod: '%',
                  _Mul: '*',
                  _Power: '**',
                  _Sub: '-',
                  _Bitand: '&amp;',
                  _Bitor: '|',
                  _Bitxor: '^',
                  _LeftShift: '&lt;&lt;',
                  _RightShift: '&gt;&gt;'
                  }
    BIT_CLASSES = {'&amp;': _Bitand,
                   '|': _Bitor,
                   '^': _Bitxor
                   }


</t>
<t tx="ekr.20100212224846.10158">class BoolOp(Node):
    """replace And, Or"""
    OP_CLASSES = {_And: 'and',
                  _Or: 'or'
                  }


</t>
<t tx="ekr.20100212224846.10159">class UnaryOp(Node):
    """replace UnaryAdd, UnarySub, Not"""
    OP_CLASSES = {_UnaryAdd: '+',
                  _UnarySub: '-',
                  _Not: 'not',
                  _Invert: '~'
                  }


</t>
<t tx="ekr.20100212224846.10160">class Delete(Node):
    """represent a Delete statement"""

</t>
<t tx="ekr.20100212224846.10161">class DelAttr(Node):
    """represent a deleted Attribute"""

</t>
<t tx="ekr.20100212224846.10162">class DelName(Node):
    """represent a deleted Name"""

</t>
<t tx="ekr.20100212224846.10163">class Arguments(Node):
    """represent the arguments of a function"""
    @others
</t>
<t tx="ekr.20100212224846.10164">def __init__(self, args=None, defaults=None, vararg=None, kwarg=None):
    self.args = args
    self.defaults = defaults
    self.vararg = vararg
    self.kwarg = kwarg

</t>
<t tx="ekr.20100212224846.10165">class Index(Node):
    """represent an Index of a Subscript"""
    @others
</t>
<t tx="ekr.20100212224846.10166">def __init__(self, values):
    if len(values) == 1:
        self.value = values[0]
    else:
        self.value = Tuple(values)

</t>
<t tx="ekr.20100212224846.10167">class Slice(Node):
    """represent an ExtSlice of a Subscript; these comes from numeric slices"""
    @others
</t>
<t tx="ekr.20100212224846.10168">def __init__(self, lower, upper, step, lineno):
    self.lower = _filter_none(lower)
    self.upper = _filter_none(upper)
    self.step = _filter_none(step)
    self.lineno = lineno

</t>
<t tx="ekr.20100212224846.10169">def _extslice(dim):
    """introduce Index or Slice nodes depending on situation"""
    if dim.__class__ == Sliceobj:
        if len(dim.nodes) == 2:
            dim.nodes.append(None)
        return Slice(dim.nodes[0], dim.nodes[1], dim.nodes[2], dim.lineno)
    else:
        return Index([dim])

</t>
<t tx="ekr.20100212224846.10170">class ExtSlice(Node):
    """represent an ExtSlice of a Subscript; these comes from numeric slices"""
    @others
</t>
<t tx="ekr.20100212224846.10171">def __init__(self, dims):
    self.dims = [_extslice(dim) for dim in dims]

</t>
<t tx="ekr.20100212224846.10172"># modify __repr__ of all Nodes as they are not compatible with ASTNG ##########

def generic__repr__(self):
    """simple representation method to override compiler.ast's methods"""
    return "&lt;%s at 0x%x&gt;" % (self.__class__.__name__, id(self))

</t>
<t tx="ekr.20100212224846.10173">for value in ast.__dict__.values():
    try:
        if issubclass(value, ast.Node):
            value.__repr__ = generic__repr__
    except:
        pass
del ast

# we have to be able to instantiate Tuple, Dict and List without any argument #

def init_noargs(self, *args, **kwargs):
    if not (args or kwargs):
        self._orig_init([])
    else:
        self._orig_init(*args, **kwargs)

</t>
<t tx="ekr.20100212224846.10174">Tuple._orig_init = Tuple.__init__
Tuple.__init__ = init_noargs
List._orig_init = List.__init__
List.__init__ = init_noargs
Dict._orig_init = Dict.__init__
Dict.__init__ = init_noargs


# compiler rebuilder ##########################################################

def _init_else_node(node):
    """remove Stmt node if exists"""
    if node.else_:
        node.orelse = node.else_.nodes
    else:
        node.orelse = []
    del node.else_

</t>
<t tx="ekr.20100212224846.10175">def _nodify_args(parent, values):
    res = []
    for arg in values:
        if isinstance(arg, (tuple, list)):
            n = Tuple()
            # set .nodes, not .elts since this will be visited as a node coming
            # from compiler tree
            n.nodes = _nodify_args(n, arg)
        else:
            n = AssName(None, None)
            n.name = arg
        n.parent = parent
        n.fromlineno = parent.fromlineno
        n.tolineno = parent.fromlineno
        res.append(n)
    return res

</t>
<t tx="ekr.20100212224846.10176">def args_compiler_to_ast(node):
    # insert Arguments node
    if node.flags &amp; 8:
        kwarg = node.argnames.pop()
    else:
        kwarg = None
    if node.flags &amp; 4:
        vararg = node.argnames.pop()
    else:
        vararg = None
    del node.flags
    args = _nodify_args(node, node.argnames)
    del node.argnames
    node.args = Arguments(args, node.defaults, vararg, kwarg)
    node.args.fromlineno = node.fromlineno
    try:
        node.args.tolineno = node.blockstart_tolineno
    except AttributeError: # lambda
        node.args.tolineno = node.tolineno
    del node.defaults


</t>
<t tx="ekr.20100212224846.10177">def _filter_none(node):
    """transform Const(None) to None"""
    if isinstance(node, Const) and node.value is None:
        return None
    else:
        return node

</t>
<t tx="ekr.20100212224846.10178">class TreeRebuilder(ASTVisitor):
    """Rebuilds the compiler tree to become an ASTNG tree"""
    @others
</t>
<t tx="ekr.20100212224846.10179">
def __init__(self, rebuild_visitor):
    self.visitor = rebuild_visitor


</t>
<t tx="ekr.20100212224846.10180">def insert_delstmt_if_necessary(self, node):
    """insert a Delete statement node if necessary

    return True if we have mutated a AssTuple into a Delete
    """
    assign_nodes = (Assign, With, For, ExceptHandler, Delete, AugAssign)
    if isinstance(node.parent, assign_nodes) or not (
        node.parent.is_statement or isinstance(node.parent, Module)):
        return False
    if isinstance(node, AssTuple): # replace node by Delete
        node.__class__ = Delete
        node.targets = node.nodes
        del node.nodes
        stmt = node
    else: # introduce new Stmt node
        stmt = Delete()
        node.parent.replace(node, stmt)
        stmt.fromlineno = node.fromlineno
        stmt.tolineno = node.tolineno
        node.parent = stmt
        stmt.targets = [node]
    self.visitor.asscontext = stmt
    return stmt is node

</t>
<t tx="ekr.20100212224846.10181"># scoped nodes #######################################################

def visit_function(self, node):
    # remove Stmt node
    node.body = node.code.nodes
    del node.code
    args_compiler_to_ast(node)

</t>
<t tx="ekr.20100212224846.10182">def visit_lambda(self, node):
    node.body = node.code
    del node.code
    args_compiler_to_ast(node)

</t>
<t tx="ekr.20100212224846.10183">def visit_class(self, node):
    # remove Stmt node
    node.body = node.code.nodes
    del node.code

</t>
<t tx="ekr.20100212224846.10184">def visit_module(self, node):
    # remove Stmt node
    node.body = node.node.nodes
    del node.node
    return True

</t>
<t tx="ekr.20100212224846.10185">#  other visit_&lt;node&gt; #####################################################

def visit_assattr(self, node):
    if node.flags == 'OP_DELETE':
        self.insert_delstmt_if_necessary(node)
        node.__class__ = DelAttr
    del node.flags

</t>
<t tx="ekr.20100212224846.10186">def visit_assign(self, node):
    node.value = node.expr
    node.targets = node.nodes
    del node.nodes, node.expr

</t>
<t tx="ekr.20100212224846.10187">def visit_asslist(self, node):
    self.insert_delstmt_if_necessary(node)
    node.__class__ = List
    self.visit_list(node)

</t>
<t tx="ekr.20100212224846.10188">def visit_asstuple(self, node):
    if not self.insert_delstmt_if_necessary(node):
        node.__class__ = Tuple
        self.visit_tuple(node)

</t>
<t tx="ekr.20100212224846.10189">def visit_assname(self, node):
    if node.flags == 'OP_DELETE':
        self.insert_delstmt_if_necessary(node)
        node.__class__ = DelName
    del node.flags

</t>
<t tx="ekr.20100212224846.10190">def visit_augassign(self, node):
    node.value = node.expr
    del node.expr
    node.target = node.node
    del node.node

</t>
<t tx="ekr.20100212224846.10191">def visit_backquote(self, node):
    node.value = node.expr
    del node.expr

</t>
<t tx="ekr.20100212224846.10192">def visit_binop(self, node):
    node.op = BinOp.OP_CLASSES[node.__class__]
    node.__class__ = BinOp
    if node.op in ('&amp;', '|', '^'):
        node.right = node.nodes[-1]
        bitop = BinOp.BIT_CLASSES[node.op]
        if len(node.nodes) &gt; 2:
            node.left = bitop(node.nodes[:-1])
        else:
            node.left = node.nodes[0]
        del node.nodes

</t>
<t tx="ekr.20100212224846.10193">def visit_boolop(self, node):
    node.op = BoolOp.OP_CLASSES[node.__class__]
    node.__class__ = BoolOp
    node.values = node.nodes
    del node.nodes

</t>
<t tx="ekr.20100212224846.10194">def visit_callfunc(self, node):
    node.func = node.node
    node.starargs = node.star_args
    node.kwargs = node.dstar_args
    del node.node, node.star_args, node.dstar_args

</t>
<t tx="ekr.20100212224846.10195">def visit_compare(self, node):
    node.left = node.expr
    del node.expr

</t>
<t tx="ekr.20100212224846.10196">def visit_discard(self, node):
    node.value = node.expr
    del node.expr
    if node.lineno is None:
        # remove dummy Discard introduced when a statement
        # is ended by a semi-colon
        node.parent.child_sequence(node).remove(node)
        raise NodeRemoved

</t>
<t tx="ekr.20100212224846.10197">def visit_exec(self, node):
    node.locals, node.globals = node.globals, node.locals

</t>
<t tx="ekr.20100212224846.10198">def visit_for(self, node):
    node.target = node.assign
    del node.assign
    node.iter = node.list
    del node.list
    node.body = node.body.nodes
    _init_else_node(node)

</t>
<t tx="ekr.20100212224846.10199">def visit_genexpr(self, node):
    # remove GenExprInner node
    node.elt = node.code.expr
    node.generators = node.code.quals
    del node.code

</t>
<t tx="ekr.20100212224846.10200">def visit_getattr(self, node):
    if isinstance(self.visitor.asscontext, AugAssign):
        node.__class__ = AssAttr

</t>
<t tx="ekr.20100212224846.10201">def visit_if(self, node):
    node.test, body = node.tests[0]
    node.body = body.nodes
    if node.tests[1:]:
        # create If node and put it in orelse
        # rely on the fact that the new If node will be visited
        # as well until no more tests remains
        subnode = If(node.tests[1:], node.else_ )
        subnode.fromlineno = node.tests[1][0].fromlineno
        subnode.tolineno = node.tests[1][1].nodes[-1].tolineno
        subnode.blockstart_tolineno = node.tests[1][0].tolineno
        del node.else_
        node.orelse = [subnode]
    else: # handle orelse
        _init_else_node(node)
    del node.tests

</t>
<t tx="ekr.20100212224846.10202">def visit_list(self, node):
    node.elts = node.nodes
    del node.nodes

</t>
<t tx="ekr.20100212224846.10203">def visit_keyword(self, node):
    node.value = node.expr
    node.arg = node.name
    del node.expr, node.name

</t>
<t tx="ekr.20100212224846.10204">def visit_listcomp(self, node):
    node.elt = node.expr
    node.generators = node.quals
    del node.expr, node.quals

</t>
<t tx="ekr.20100212224846.10205">def visit_name(self, node):
    if isinstance(self.visitor.asscontext, AugAssign):
        node.__class__ = AssName

</t>
<t tx="ekr.20100212224846.10206">def visit_comprehension(self, node):
    if hasattr(node, "list"):
        # ListCompFor
        node.iter = node.list
        del node.list
    else: # GenExprFor
        node.__class__ = Comprehension
    node.target = node.assign
    if node.ifs:
        node.ifs = [iff.test for iff in node.ifs ]
    del node.assign

</t>
<t tx="ekr.20100212224846.10207">def visit_print(self, node):
    node.values = node.nodes
    del node.nodes
    node.nl = False

</t>
<t tx="ekr.20100212224846.10208">def visit_printnl(self, node):
    node.__class__ = Print
    node.values = node.nodes
    del node.nodes
    node.nl = True

</t>
<t tx="ekr.20100212224846.10209">def visit_raise(self, node):
    node.type = node.expr1
    node.inst = node.expr2
    node.tback = node.expr3
    del node.expr1, node.expr2, node.expr3

</t>
<t tx="ekr.20100212224846.10210">def visit_return(self, node):
    """visit Return: filter None Const"""
    node.value = _filter_none( node.value )

</t>
<t tx="ekr.20100212224846.10211">def visit_slice(self, node):
    """visit slice"""
    # /!\ Careful :
    # if the node comes from compiler, it is actually an astng.Subscript
    # with only 'lower' and 'upper' attributes; no 'step'.
    # However we want its attribute 'slice' to be a astng.Slice;
    # hence node.slice will be visited here as a node's child
    # furthermore, some child nodes of Subscript are also Slice objects
    #
    # logilab.astng._nodes_compiler.Slice introduced before :
    if node.__class__ is Slice:
        return
    # compiler.ast.Slice :
    if node.flags == 'OP_DELETE':
        self.insert_delstmt_if_necessary(node)
    else:
        assert node.flags in ('OP_APPLY', 'OP_ASSIGN')
    node.__class__ = Subscript
    node.value = node.expr
    node.slice = Slice(node.lower, node.upper, None,
                       node.lineno)
    del node.expr, node.lower, node.upper, node.flags

</t>
<t tx="ekr.20100212224846.10212">def visit_subscript(self, node):
    if node.flags == 'OP_DELETE':
        self.insert_delstmt_if_necessary(node)
    node.value = node.expr
    if [n for n in node.subs if isinstance(n, Sliceobj)]:
        subs = node.subs
        if len(node.subs) == 1:# Slice
            subs = node.subs[0].nodes
            node.slice = Slice(subs[0], subs[1], subs[2], node.lineno)
        else: # ExtSlice
            node.slice = ExtSlice(node.subs)
    else: # Index
        node.slice = Index(node.subs)
    del node.expr, node.subs, node.flags

</t>
<t tx="ekr.20100212224846.10213">def visit_tryexcept(self, node):
    # remove Stmt node
    node.body = node.body.nodes
    # remove Stmt node
    node.handlers = [ExceptHandler(exctype, excobj, body, node)
                    for exctype, excobj, body in node.handlers]
    _init_else_node(node)

</t>
<t tx="ekr.20100212224846.10214">def visit_tryfinally(self, node):
    # remove Stmt nodes
    node.body = node.body.nodes
    node.finalbody = node.final.nodes
    del node.final

</t>
<t tx="ekr.20100212224846.10215">visit_tuple = visit_list

def visit_unaryop(self, node):
    node.op = UnaryOp.OP_CLASSES[node.__class__]
    node.__class__ = UnaryOp
    node.operand = node.expr
    del node.expr

</t>
<t tx="ekr.20100212224846.10216">def visit_while(self, node):
    node.body = node.body.nodes
    _init_else_node(node)

</t>
<t tx="ekr.20100212224846.10217">def visit_yield(self, node):
    """visit yield : add parent Discard node"""
    if not isinstance(node.parent, Discard):
        stmt = Discard(None)
        del stmt.expr
        stmt.value = node
        stmt.fromlineno = node.fromlineno
        stmt.tolineno = node.tolineno
        node.parent.replace(node, stmt)
        node.parent = stmt


</t>
<t tx="ekr.20100212224846.10218"># raw building ################################################################

def module_factory(doc):
    node = Module(doc, None)
    del node.node
    node.body = []
    return node


</t>
<t tx="ekr.20100212224846.10219">if sys.version_info &lt; (2, 5):
    def import_from_factory(modname, membername):
        return From(modname, ( (membername, None), ) )
else:
    def import_from_factory(modname, membername):
        return From(modname, ( (membername, None), ), 0)


def _const_factory(value):
    return Const(value)


</t>
<t tx="ekr.20100212224846.10220"># introduction of decorators has changed the Function initializer arguments
if sys.version_info &gt;= (2, 4):
    def function_factory(name, args, defaults, flag=0, doc=None):
        """create and initialize a astng Function node"""
        # first argument is now a list of decorators
        func = Function(Decorators([]), name, args, defaults, flag, doc, None)
        del func.code
        func.body = []
        args_compiler_to_ast(func)
        return func

else:
    def function_factory(name, args, defaults, flag=0, doc=None):
        """create and initialize a astng Function node"""
        func = Function(name, args, defaults, flag, doc, None)
        del func.code
        func.body = []
        args_compiler_to_ast(func)
        return func


def class_factory(name, basenames=(), doc=None):
    """create and initialize a astng Class node"""
    node = Class(name, [], doc, None)
    del node.code
    node.body = []
    bases = [Name(base) for base in basenames]
    for base in bases:
        base.parent = node
    node.bases = bases
    return node
</t>
<t tx="ekr.20100212224846.10221">@language python
@tabwidth -4

"""Python Abstract Syntax Tree New Generation

The aim of this module is to provide a common base representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module with some
additional methods and attributes. Instance attributes are added by a
builder object, which can either generate extended ast (let's call
them astng ;) by visiting an existant ast tree or by inspecting living
object. Methods are added by monkey patching ast classes.

Main modules are:

* nodes and scoped_nodes for more information about methods and
  attributes added to different node classes

* the manager contains a high level object to get astng trees from
  source files and living objects. It maintains a cache of previously
  constructed tree for quick access

* builder contains the class responsible to build astng trees
"""

@others
</t>
<t tx="ekr.20100212224846.10222">__doctype__ = "restructuredtext en"

# WARNING: internal imports order matters !

# make all exception classes accessible from astng package
from logilab.astng._exceptions import *

# make a manager singleton as well as Project and Package classes accessible
# from astng package
from logilab.astng.manager import ASTNGManager, Project, Package
MANAGER = ASTNGManager()
del ASTNGManager

# make all node classes accessible from astng package
from logilab.astng.nodes import *

# trigger extra monkey-patching
from logilab.astng import inference

# more stuff available
from logilab.astng import raw_building
from logilab.astng.infutils import YES, Instance, BoundMethod, UnboundMethod
</t>
<t tx="ekr.20100212224846.10223">@language python
@tabwidth -4

# Copyright (c) 2003-2009 LOGILAB S.A. (Paris, FRANCE).
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#

"""
logilab.astng packaging information
"""

@others
</t>
<t tx="ekr.20100212224846.10224">distname = 'logilab-astng'

modname = 'astng'
subpackage_of = 'logilab'

numversion = (0, 19, 3)
version = '.'.join([str(num) for num in numversion])

install_requires = ['logilab-common &gt;= 0.39.0']

pyversions = ["2.3", "2.4", "2.5", '2.6']

license = 'GPL'

author = 'Logilab'
author_email = 'python-projects@lists.logilab.org'
mailinglist = "mailto://%s" % author_email
web = "http://www.logilab.org/project/%s" % distname
ftp = "ftp://ftp.logilab.org/pub/%s" % modname

short_desc = "extend python's abstract syntax tree"

long_desc = """The aim of this module is to provide a common base \
representation of
python source code for projects such as pychecker, pyreverse,
pylint... Well, actually the development of this library is essentialy
governed by pylint's needs.

It extends class defined in the compiler.ast [1] module (python &lt;= 2.4) or in
the builtin _ast module (python &gt;= 2.5) with some additional methods and
attributes. Instance attributes are added by a builder object, which can either
generate extended ast (let's call them astng ;) by visiting an existant ast
tree or by inspecting living object. Methods are added by monkey patching ast
classes."""


from os.path import join
include_dirs = [join('test', 'regrtest_data'),
                join('test', 'data'), join('test', 'data2')]
</t>
<t tx="ekr.20100212224846.10225"></t>
<t tx="ekr.20100212224846.10226">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest_main()
</t>
<t tx="ekr.20100212224846.10227">
from logilab.common.testlib import unittest_main, TestCase

from logilab.astng import ResolveError, MANAGER as m, Instance, YES, InferenceError
from logilab.astng.builder import ASTNGBuilder, build_module

import sys
from os.path import abspath
sys.path.insert(1, abspath('regrtest_data'))

</t>
<t tx="ekr.20100212224846.10228">class NonRegressionTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10229">
##     def test_resolve1(self):
##         mod = m.astng_from_module_name('data.nonregr')
##         cls = mod['OptionParser']
##         self.assertRaises(ResolveError, cls.resolve_dotted, cls.basenames[0])
##         #self.assert_(cls is not cls.resolve_dotted(cls.basenames[0]))

def test_module_path(self):
    mod = m.astng_from_module_name('import_package_subpackage_module')
    package = mod.igetattr('package').next()
    self.failUnlessEqual(package.name, 'package')
    subpackage = package.igetattr('subpackage').next()
    self.failUnlessEqual(subpackage.name, 'package.subpackage')
    module = subpackage.igetattr('module').next()
    self.failUnlessEqual(module.name, 'package.subpackage.module')


</t>
<t tx="ekr.20100212224846.10230">def test_living_property(self):
    builder = ASTNGBuilder()
    builder._done = {}
    builder._module = sys.modules[__name__]
    builder.object_build(build_module('module_name', ''), Whatever)

</t>
<t tx="ekr.20100212224846.10231">def test_new_style_class_detection(self):
    try:
        import pygtk
    except ImportError:
        self.skip('test skipped: pygtk is not available')
    else:
        # XXX may fail on some pygtk version, because objects in
        # gobject._gobject have __module__ set to gobject :(
        builder = ASTNGBuilder()
        data = """
\\-4import pygtk
\\-4pygtk.require("2.6")
\\-4import gobject

\\-4class A(gobject.GObject):
def __init__(self, val):
    gobject.GObject.__init__(self)
    self._val = val
def _get_val(self):
    print "get"
    return self._val
def _set_val(self, val):
    print "set"
    self._val = val
val = property(_get_val, _set_val)


\\-4if __name__ == "__main__":
print gobject.GObject.__bases__
a = A(7)
print a.val
a.val = 6
print a.val
\\-4"""
        astng = builder.string_build(data, __name__, __file__)
        a = astng['A']
        self.failUnless(a.newstyle)


</t>
<t tx="ekr.20100212224846.10232">def test_pylint_config_attr(self):
    try:
        from pylint import lint
    except ImportError:
        self.skip('pylint not available')
    mod = m.astng_from_module_name('pylint.lint')
    pylinter = mod['PyLinter']
    self.assertEquals([c.name for c in pylinter.ancestors()],
                      ['OptionsManagerMixIn', 'object', 'MessagesHandlerMixIn',
                       'ReportsHandlerMixIn', 'BaseRawChecker', 'BaseChecker',
                       'OptionsProviderMixIn', 'ASTWalker'])

    self.assert_(list(Instance(pylinter).getattr('config')))
    infered = list(Instance(pylinter).igetattr('config'))
    self.assertEquals(len(infered), 2)
    infered = [c for c in infered if not c is YES]
    self.assertEquals(len(infered), 1)
    self.assertEquals(infered[0].root().name, 'optparse')
    self.assertEquals(infered[0].name, 'Values')

</t>
<t tx="ekr.20100212224846.10233">def test_numpy_crash(self):
    try:
        import numpy
    except ImportError:
        self.skip('test skipped: numpy is not available')
    else:
        builder = ASTNGBuilder()
        data = """
\\-4from numpy import multiply

\\-4multiply(1, 2, 3)
\\-4"""
        astng = builder.string_build(data, __name__, __file__)
        callfunc = astng.node.nodes[1].expr
        # well, InferenceError instead of a crash is better
        self.assertRaises(InferenceError, list, callfunc.infer())


</t>
<t tx="ekr.20100212224846.10234">class Whatever(object):
    a = property(lambda x: x, lambda x: x)

</t>
<t tx="ekr.20100212224846.10235">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest_main()
</t>
<t tx="ekr.20100212224846.10236"># This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""tests for the astng builder and rebuilder module"""

import unittest
import sys
from os.path import join, abspath, dirname

from logilab.common.testlib import TestCase, unittest_main
from pprint import pprint

from logilab.astng import builder, nodes, patchcomptransformer, MANAGER, InferenceError
from logilab.astng.nodes import Module
from logilab.astng.infutils import YES
from logilab.astng.nodes_as_string import as_string

from unittest_inference import get_name_node

import data
from data import module as test_module

</t>
<t tx="ekr.20100212224846.10237">class FromToLineNoTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10238">
def setUp(self):
    self.astng = builder.ASTNGBuilder().file_build('data/format.py')

</t>
<t tx="ekr.20100212224846.10239">def test_callfunc_lineno(self):
    stmts = self.astng.body
    # on line 4:
    #    function('aeozrijz\
    #    earzer', hop)
    discard = stmts[0]
    self.assertIsInstance(discard, nodes.Discard)
    self.assertEquals(discard.fromlineno, 4)
    self.assertEquals(discard.tolineno, 5)
    callfunc = discard.value
    self.assertIsInstance(callfunc, nodes.CallFunc)
    self.assertEquals(callfunc.fromlineno, 4)
    self.assertEquals(callfunc.tolineno, 5)
    name = callfunc.func
    self.assertIsInstance(name, nodes.Name)
    self.assertEquals(name.fromlineno, 4)
    self.assertEquals(name.tolineno, 4)
    strarg = callfunc.args[0]
    self.assertIsInstance(strarg, nodes.Const)
    self.assertEquals(strarg.fromlineno, 5) # no way for this one (is 4 actually)
    self.assertEquals(strarg.tolineno, 5)
    namearg = callfunc.args[1]
    self.assertIsInstance(namearg, nodes.Name)
    self.assertEquals(namearg.fromlineno, 5)
    self.assertEquals(namearg.tolineno, 5)
    # on line 10:
    #    fonction(1,
    #             2,
    #             3,
    #             4)
    discard = stmts[2]
    self.assertIsInstance(discard, nodes.Discard)
    self.assertEquals(discard.fromlineno, 10)
    self.assertEquals(discard.tolineno, 13)
    callfunc = discard.value
    self.assertIsInstance(callfunc, nodes.CallFunc)
    self.assertEquals(callfunc.fromlineno, 10)
    self.assertEquals(callfunc.tolineno, 13)
    name = callfunc.func
    self.assertIsInstance(name, nodes.Name)
    self.assertEquals(name.fromlineno, 10)
    self.assertEquals(name.tolineno, 10)
    for i, arg in enumerate(callfunc.args):
        self.assertIsInstance(arg, nodes.Const)
        self.assertEquals(arg.fromlineno, 10+i)
        self.assertEquals(arg.tolineno, 10+i)

</t>
<t tx="ekr.20100212224846.10240">def test_function_lineno(self):
    stmts = self.astng.body
    # on line 15:
    #    def definition(a,
    #                   b,
    #                   c):
    #        return a + b + c
    function = stmts[3]
    self.assertIsInstance(function, nodes.Function)
    self.assertEquals(function.fromlineno, 15)
    self.assertEquals(function.tolineno, 18)
    self.assertEquals(function.blockstart_tolineno, 17)
    return_ = function.body[0]
    self.assertIsInstance(return_, nodes.Return)
    self.assertEquals(return_.fromlineno, 18)
    self.assertEquals(return_.tolineno, 18)

</t>
<t tx="ekr.20100212224846.10241">def test_decorated_function_lineno(self):
    if sys.version_info &lt; (2, 4):
        self.skip('require python &gt;=2.4')
    astng = builder.ASTNGBuilder().string_build('''
\\-4@decorator
\\-4def function(
arg):
print arg
\\-4''', __name__, __file__)
    function = astng['function']
    self.assertEquals(function.fromlineno, 3) # XXX discussable, but that's what is expected by pylint right now
    self.assertEquals(function.tolineno, 5)
    self.assertEquals(function.blockstart_tolineno, 4)
    self.assertEquals(function.decorators.fromlineno, 2)
    self.assertEquals(function.decorators.tolineno, 2)


</t>
<t tx="ekr.20100212224846.10242">def test_class_lineno(self):
    stmts = self.astng.body
    # on line 20:
    #    class debile(dict,
    #                 object):
    #       pass
    class_ = stmts[4]
    self.assertIsInstance(class_, nodes.Class)
    self.assertEquals(class_.fromlineno, 20)
    self.assertEquals(class_.tolineno, 22)
    self.assertEquals(class_.blockstart_tolineno, 21)
    pass_ = class_.body[0]
    self.assertIsInstance(pass_, nodes.Pass)
    self.assertEquals(pass_.fromlineno, 22)
    self.assertEquals(pass_.tolineno, 22)

</t>
<t tx="ekr.20100212224846.10243">def test_if_lineno(self):
    stmts = self.astng.body
    # on line 20:
    #    if aaaa: pass
    #    else:
    #        aaaa,bbbb = 1,2
    #        aaaa,bbbb = bbbb,aaaa
    if_ = stmts[5]
    self.assertIsInstance(if_, nodes.If)
    self.assertEquals(if_.fromlineno, 24)
    self.assertEquals(if_.tolineno, 27)
    self.assertEquals(if_.blockstart_tolineno, 24)
    self.assertEquals(if_.orelse[0].fromlineno, 26)
    self.assertEquals(if_.orelse[1].tolineno, 27)

</t>
<t tx="ekr.20100212224846.10244">def test_for_while_lineno(self):
    for code in ('''
\\-4for a in range(4):
\\-2print a
\\-2break
\\-4else:
\\-2print "bouh"
\\-4''', '''
\\-4while a:
\\-2print a
\\-2break
\\-4else:
\\-2print "bouh"
\\-4''',
                 ):
        astng = builder.ASTNGBuilder().string_build(code, __name__, __file__)
        stmt = astng.body[0]
        self.assertEquals(stmt.fromlineno, 2)
        self.assertEquals(stmt.tolineno, 6)
        self.assertEquals(stmt.blockstart_tolineno, 2)
        self.assertEquals(stmt.orelse[0].fromlineno, 6) # XXX
        self.assertEquals(stmt.orelse[0].tolineno, 6)


</t>
<t tx="ekr.20100212224846.10245">def test_try_except_lineno(self):
    astng = builder.ASTNGBuilder().string_build('''
\\-4try:
\\-2print a
\\-4except:
\\-2pass
\\-4else:
\\-2print "bouh"
\\-4''', __name__, __file__)
    try_ = astng.body[0]
    self.assertEquals(try_.fromlineno, 2)
    self.assertEquals(try_.tolineno, 7)
    self.assertEquals(try_.blockstart_tolineno, 2)
    self.assertEquals(try_.orelse[0].fromlineno, 7) # XXX
    self.assertEquals(try_.orelse[0].tolineno, 7)
    hdlr = try_.handlers[0]
    self.assertEquals(hdlr.fromlineno, 4)
    self.assertEquals(hdlr.tolineno, 5)
    self.assertEquals(hdlr.blockstart_tolineno, 4)


</t>
<t tx="ekr.20100212224846.10246">def test_try_finally_lineno(self):
    astng = builder.ASTNGBuilder().string_build('''
\\-4try:
\\-2print a
\\-4finally:
\\-2print "bouh"
\\-4''', __name__, __file__)
    try_ = astng.body[0]
    self.assertEquals(try_.fromlineno, 2)
    self.assertEquals(try_.tolineno, 5)
    self.assertEquals(try_.blockstart_tolineno, 2)
    self.assertEquals(try_.finalbody[0].fromlineno, 5) # XXX
    self.assertEquals(try_.finalbody[0].tolineno, 5)


</t>
<t tx="ekr.20100212224846.10247">def test_try_finally_25_lineno(self):
    if sys.version_info &lt; (2, 5):
        self.skip('require python &gt;= 2.5')
    astng = builder.ASTNGBuilder().string_build('''
\\-4try:
\\-2print a
\\-4except:
\\-2pass
\\-4finally:
\\-2print "bouh"
\\-4''', __name__, __file__)
    try_ = astng.body[0]
    self.assertEquals(try_.fromlineno, 2)
    self.assertEquals(try_.tolineno, 7)
    self.assertEquals(try_.blockstart_tolineno, 2)
    self.assertEquals(try_.finalbody[0].fromlineno, 7) # XXX
    self.assertEquals(try_.finalbody[0].tolineno, 7)


</t>
<t tx="ekr.20100212224846.10248">def test_with_lineno(self):
    if sys.version_info &lt; (2, 5):
        self.skip('require python &gt;=2.5')
    astng = builder.ASTNGBuilder().string_build('''
\\-4from __future__ import with_statement
\\-4with file("/tmp/pouet") as f:
\\-2print f
\\-4''', __name__, __file__)
    with_ = astng.body[1]
    self.assertEquals(with_.fromlineno, 3)
    self.assertEquals(with_.tolineno, 4)
    self.assertEquals(with_.blockstart_tolineno, 3)



</t>
<t tx="ekr.20100212224846.10249">class BuilderTC(TestCase):
    @others
    if sys.version_info &gt;= (2, 4):
        def test_gen_expr_var_scope(self):
            data = 'l = list(n for n in range(10))\n'
            astng = self.builder.string_build(data, __name__, __file__)
            # n unvailable touside gen expr scope
            self.failIf('n' in astng)
            # test n is inferable anyway
            n = get_name_node(astng, 'n')
            self.failIf(n.scope() is astng)
            self.failUnlessEqual([i.__class__ for i in n.infer()],
                                 [YES.__class__])

</t>
<t tx="ekr.20100212224846.10250">
def setUp(self):
    self.builder = builder.ASTNGBuilder()

</t>
<t tx="ekr.20100212224846.10251">def test_border_cases(self):
    """check that a file with no trailing new line is parseable"""
    self.builder.file_build('data/noendingnewline.py', 'data.noendingnewline')
    self.assertRaises(builder.ASTNGBuildingException,
                      self.builder.file_build, 'data/inexistant.py', 'whatever')

</t>
<t tx="ekr.20100212224846.10252">def test_inspect_build0(self):
    """test astng tree build from a living object"""
    builtin_astng = MANAGER.astng_from_module_name('__builtin__')
    fclass = builtin_astng['file']
    self.assert_('name' in fclass)
    self.assert_('mode' in fclass)
    self.assert_('read' in fclass)
    self.assert_(fclass.newstyle)
    self.assert_(fclass.pytype(), '__builtin__.type')
    self.assertIsInstance(fclass['read'], nodes.Function)
    # check builtin function has args.args == None
    dclass = builtin_astng['dict']
    self.assertEquals(dclass['has_key'].args.args, None)
    # just check type and object are there
    builtin_astng.getattr('type')
    builtin_astng.getattr('object')
    # check open file alias
    builtin_astng.getattr('open')
    # check 'help' is there (defined dynamically by site.py)
    builtin_astng.getattr('help')
    # check property has __init__
    pclass = builtin_astng['property']
    self.assert_('__init__' in pclass)
    self.assertIsInstance(builtin_astng['None'], nodes.Const)
    self.assertIsInstance(builtin_astng['True'], nodes.Const)
    self.assertIsInstance(builtin_astng['False'], nodes.Const)
    self.assertIsInstance(builtin_astng['Exception'], nodes.From)
    self.assertIsInstance(builtin_astng['NotImplementedError'], nodes.From)

</t>
<t tx="ekr.20100212224846.10253">def test_inspect_build1(self):
    time_astng = MANAGER.astng_from_module_name('time')
    self.assert_(time_astng)
    self.assertEquals(time_astng['time'].args.defaults, [])

</t>
<t tx="ekr.20100212224846.10254">def test_inspect_build2(self):
    """test astng tree build from a living object"""
    try:
        from mx import DateTime
    except ImportError:
        self.skip('test skipped: mxDateTime is not available')
    else:
        dt_astng = self.builder.inspect_build(DateTime)
        dt_astng.getattr('DateTime')
        # this one is failing since DateTimeType.__module__ = 'builtins' !
        #dt_astng.getattr('DateTimeType')

</t>
<t tx="ekr.20100212224846.10255">def test_inspect_build3(self):
    unittest_astng = self.builder.inspect_build(unittest)

</t>
<t tx="ekr.20100212224846.10256">def test_inspect_build_instance(self):
    """test astng tree build from a living object"""
    import exceptions
    builtin_astng = self.builder.inspect_build(exceptions)
    fclass = builtin_astng['OSError']
    # things like OSError.strerror are now (2.5) data descriptors on the
    # class instead of entries in the __dict__ of an instance
    if sys.version_info &lt; (2, 5):
        container = fclass.instance_attrs
    else:
        container = fclass
    self.assert_('errno' in container)
    self.assert_('strerror' in container)
    self.assert_('filename' in container)

</t>
<t tx="ekr.20100212224846.10257">def test_inspect_build_type_object(self):
    builtin_astng = MANAGER.astng_from_module_name('__builtin__')

    infered = list(builtin_astng.igetattr('object'))
    self.assertEquals(len(infered), 1)
    infered = infered[0]
    self.assertEquals(infered.name, 'object')
    as_string(infered)

    infered = list(builtin_astng.igetattr('type'))
    self.assertEquals(len(infered), 1)
    infered = infered[0]
    self.assertEquals(infered.name, 'type')
    as_string(infered)

</t>
<t tx="ekr.20100212224846.10258">def test_package_name(self):
    """test base properties and method of a astng module"""
    datap = self.builder.file_build('data/__init__.py', 'data')
    self.assertEquals(datap.name, 'data')
    self.assertEquals(datap.package, 1)
    datap = self.builder.file_build('data/__init__.py', 'data.__init__')
    self.assertEquals(datap.name, 'data')
    self.assertEquals(datap.package, 1)

</t>
<t tx="ekr.20100212224846.10259">def test_yield_parent(self):
    """check if we added discard nodes as yield parent (w/ compiler)"""
    data = """
\\-4def yiell():
yield 0
if noe:
    yield more
\\-4"""
    func = self.builder.string_build(data).body[0]
    self.assertIsInstance(func, nodes.Function)
    stmt = func.body[0]
    self.assertIsInstance(stmt, nodes.Discard)
    self.assertIsInstance(stmt.value, nodes.Yield)
    self.assertIsInstance(func.body[1].body[0], nodes.Discard)
    self.assertIsInstance(func.body[1].body[0].value, nodes.Yield)

</t>
<t tx="ekr.20100212224846.10260">def test_object(self):
    obj_astng = self.builder.inspect_build(object)
    self.failUnless('__setattr__' in obj_astng)

</t>
<t tx="ekr.20100212224846.10261">def test_newstyle_detection(self):
    data = '''
\\-4class A:
"old style"

\\-4class B(A):
"old style"

\\-4class C(object):
"new style"

\\-4class D(C):
"new style"

\\-4__metaclass__ = type

\\-4class E(A):
"old style"

\\-4class F:
"new style"
\\-4'''
    mod_astng = self.builder.string_build(data, __name__, __file__)
    self.failIf(mod_astng['A'].newstyle)
    self.failIf(mod_astng['B'].newstyle)
    self.failUnless(mod_astng['C'].newstyle)
    self.failUnless(mod_astng['D'].newstyle)
    self.failIf(mod_astng['E'].newstyle)
    self.failUnless(mod_astng['F'].newstyle)

</t>
<t tx="ekr.20100212224846.10262">def test_globals(self):
    data = '''
\\-4CSTE = 1

\\-4def update_global():
global CSTE
CSTE += 1

\\-4def global_no_effect():
global CSTE2
print CSTE
\\-4'''
    astng = self.builder.string_build(data, __name__, __file__)
    self.failUnlessEqual(len(astng.getattr('CSTE')), 2)
    self.assertIsInstance(astng.getattr('CSTE')[0], nodes.AssName)
    self.failUnlessEqual(astng.getattr('CSTE')[0].fromlineno, 2)
    self.failUnlessEqual(astng.getattr('CSTE')[1].fromlineno, 6)
    self.assertRaises(nodes.NotFoundError,
                      astng.getattr, 'CSTE2')
    self.assertRaises(InferenceError,
                      astng['global_no_effect'].ilookup('CSTE2').next)

</t>
<t tx="ekr.20100212224846.10263">def test_socket_build(self):
    import socket
    astng = self.builder.module_build(socket)
    # XXX just check the first one. Actually 3 objects are infered (look at
    # the socket module) but the last one as those attributes dynamically
    # set and astng is missing this.
    for fclass in astng.igetattr('socket'):
        #print fclass.root().name, fclass.name, fclass.lineno
        self.assert_('connect' in fclass)
        self.assert_('send' in fclass)
        self.assert_('close' in fclass)
        break

</t>
<t tx="ekr.20100212224846.10264">class FileBuildTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10265">
def setUp(self):
    abuilder = builder.ASTNGBuilder()
    self.module = abuilder.file_build('data/module.py', 'data.module')

</t>
<t tx="ekr.20100212224846.10266">def test_module_base_props(self):
    """test base properties and method of a astng module"""
    module = self.module
    self.assertEquals(module.name, 'data.module')
    self.assertEquals(module.doc, "test module for astng\n")
    self.assertEquals(module.fromlineno, 0)
    self.assertEquals(module.parent, None)
    self.assertEquals(module.frame(), module)
    self.assertEquals(module.root(), module)
    self.assertEquals(module.file, join(abspath(data.__path__[0]), 'module.py'))
    self.assertEquals(module.pure_python, 1)
    self.assertEquals(module.package, 0)
    self.assert_(not module.is_statement)
    self.assertEquals(module.statement(), module)
    self.assertEquals(module.statement(), module)

</t>
<t tx="ekr.20100212224846.10267">def test_module_locals(self):
    """test the 'locals' dictionary of a astng module"""
    module = self.module
    _locals = module.locals
    self.assert_(_locals is module.globals)
    keys = _locals.keys()
    keys.sort()
    should = ['MY_DICT', 'YO', 'YOUPI',
            '__revision__',  'global_access','modutils', 'nested_args',
             'os', 'redirect', 'spawn', 'REDIRECT', 'LocalsVisitor',
            'ASTWalker', 'ASTVisitor',  'extend_class']
    should.sort()
    self.assertEquals(keys, should)

</t>
<t tx="ekr.20100212224846.10268">def test_function_base_props(self):
    """test base properties and method of a astng function"""
    module = self.module
    function = module['global_access']
    self.assertEquals(function.name, 'global_access')
    self.assertEquals(function.doc, 'function test')
    self.assertEquals(function.fromlineno, 15)
    self.assert_(function.parent)
    self.assertEquals(function.frame(), function)
    self.assertEquals(function.parent.frame(), module)
    self.assertEquals(function.root(), module)
    self.assertEquals([n.name for n in function.args.args], ['key', 'val'])
    self.assertEquals(function.type, 'function')

</t>
<t tx="ekr.20100212224846.10269">def test_function_locals(self):
    """test the 'locals' dictionary of a astng function"""
    _locals = self.module['global_access'].locals
    self.assertEquals(len(_locals), 4)
    keys = _locals.keys()
    keys.sort()
    self.assertEquals(keys, ['i', 'key', 'local', 'val'])

</t>
<t tx="ekr.20100212224846.10270">def test_class_base_props(self):
    """test base properties and method of a astng class"""
    module = self.module
    klass = module['YO']
    self.assertEquals(klass.name, 'YO')
    self.assertEquals(klass.doc, 'hehe')
    self.assertEquals(klass.fromlineno, 28)
    self.assert_(klass.parent)
    self.assertEquals(klass.frame(), klass)
    self.assertEquals(klass.parent.frame(), module)
    self.assertEquals(klass.root(), module)
    self.assertEquals(klass.basenames, [])
    self.assertEquals(klass.newstyle, False)

</t>
<t tx="ekr.20100212224846.10271">def test_class_locals(self):
    """test the 'locals' dictionary of a astng class"""
    module = self.module
    klass1 = module['YO']
    locals1 = klass1.locals
    keys = locals1.keys()
    keys.sort()
    self.assertEquals(keys, ['__init__', 'a'])
    klass2 = module['YOUPI']
    locals2 = klass2.locals
    keys = locals2.keys()
    keys.sort()
    self.assertEquals(keys, ['__init__', 'class_attr', 'class_method', 'method', 'static_method'])

</t>
<t tx="ekr.20100212224846.10272">def test_class_instance_attrs(self):
    module = self.module
    klass1 = module['YO']
    klass2 = module['YOUPI']
    self.assertEquals(klass1.instance_attrs.keys(), ['yo'])
    self.assertEquals(klass2.instance_attrs.keys(), ['member'])

</t>
<t tx="ekr.20100212224846.10273">def test_class_basenames(self):
    module = self.module
    klass1 = module['YO']
    klass2 = module['YOUPI']
    self.assertEquals(klass1.basenames, [])
    self.assertEquals(klass2.basenames, ['YO'])

</t>
<t tx="ekr.20100212224846.10274">def test_method_base_props(self):
    """test base properties and method of a astng method"""
    klass2 = self.module['YOUPI']
    # "normal" method
    method = klass2['method']
    self.assertEquals(method.name, 'method')
    self.assertEquals([n.name for n in method.args.args], ['self'])
    self.assertEquals(method.doc, 'method test')
    self.assertEquals(method.fromlineno, 48)
    self.assertEquals(method.type, 'method')
    # class method
    method = klass2['class_method']
    self.assertEquals([n.name for n in method.args.args], ['cls'])
    self.assertEquals(method.type, 'classmethod')
    # static method
    method = klass2['static_method']
    self.assertEquals(method.args.args, [])
    self.assertEquals(method.type, 'staticmethod')

</t>
<t tx="ekr.20100212224846.10275">def test_method_locals(self):
    """test the 'locals' dictionary of a astng method"""
    klass2 = self.module['YOUPI']
    method = klass2['method']
    _locals = method.locals
    self.assertEquals(len(_locals), 5)
    keys = _locals.keys()
    keys.sort()
    self.assertEquals(keys, ['a', 'autre', 'b', 'local', 'self'])


</t>
<t tx="ekr.20100212224846.10276">class ModuleBuildTC(FileBuildTC):
    @others
</t>
<t tx="ekr.20100212224846.10277">
def setUp(self):
    abuilder = builder.ASTNGBuilder()
    self.module = abuilder.module_build(test_module)


</t>
<t tx="ekr.20100212224846.10278">class MoreTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10279">
def setUp(self):
    self.builder = builder.ASTNGBuilder()

</t>
<t tx="ekr.20100212224846.10280">def test_infered_build(self):
    code = '''class A: pass
\\-4A.type = "class"

\\-4def A_ass_type(self):
print self
\\-4A.ass_type = A_ass_type
'''
    astng = self.builder.string_build(code)
    lclass = list(astng.igetattr('A'))
    self.assertEquals(len(lclass), 1)
    lclass = lclass[0]
    self.assert_('ass_type' in lclass.locals, lclass.locals.keys())
    self.assert_('type' in lclass.locals.keys())

</t>
<t tx="ekr.20100212224846.10281">#     def test_1(self):
#         from logilab import astng
#         import compiler
#         sn = astng.MANAGER.astng_from_file(join(astng.__path__[0], 'inference.py'))
#         astastng = astng.MANAGER.astng_from_file(join(compiler.__path__[0], 'ast.py'))
#         # check monkey patching of the compiler module has been infered
#         lclass = list(astastng.igetattr('Function'))
#         self.assertEquals(len(lclass), 1)
#         lclass = lclass[0]
#         self.assert_('ass_type' in lclass.locals, lclass.locals.keys())

def test_augassign_attr(self):
    astng = self.builder.string_build("""class Counter:
v = 0
def inc(self):
    self.v += 1
    """, __name__, __file__)
    # Check self.v += 1 generate AugAssign(AssAttr(...)), not AugAssign(GetAttr(AssName...))

</t>
<t tx="ekr.20100212224846.10282">def test_dumb_module(self):
    astng = self.builder.string_build("pouet")

</t>
<t tx="ekr.20100212224846.10283">def test_infered_dont_pollute(self):
    code = '''
\\-4def func(a=None):
a.custom_attr = 0
\\-4def func2(a={}):
a.custom_attr = 0
'''
    astng = self.builder.string_build(code)
    nonetype = nodes.const_factory(None)
    self.failIf('custom_attr' in nonetype.locals)
    self.failIf('custom_attr' in nonetype.instance_attrs)
    nonetype = nodes.const_factory({})
    self.failIf('custom_attr' in nonetype.locals)
    self.failIf('custom_attr' in nonetype.instance_attrs)


</t>
<t tx="ekr.20100212224846.10284">def test_asstuple(self):
    code = 'a, b = range(2)'
    astng = self.builder.string_build(code)
    self.failUnless('b' in astng.locals)
    code = '''
\\-4def visit_if(self, node):
node.test, body = node.tests[0]
\\-4'''
    astng = self.builder.string_build(code)
    self.failUnless('body' in astng['visit_if'].locals)

</t>
<t tx="ekr.20100212224846.10285">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest_main()
</t>
<t tx="ekr.20100212224846.10286"># This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""tests for the astng inference capabilities
"""
from os.path import join
import sys
from StringIO import StringIO
from logilab.common.testlib import TestCase, unittest_main

from logilab.astng import InferenceError, builder, nodes, inference
from logilab.astng.infutils import YES, Instance, BoundMethod, UnboundMethod, path_wrapper

</t>
<t tx="ekr.20100212224846.10287">def get_name_node(start_from, name, index=0):
    return [n for n in start_from.nodes_of_class(nodes.Name) if n.name == name][index]

</t>
<t tx="ekr.20100212224846.10288">def get_node_of_class(start_from, klass):
    return start_from.nodes_of_class(klass).next()

</t>
<t tx="ekr.20100212224846.10289">builder = builder.ASTNGBuilder()

class InferenceUtilsTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10290">
def test_path_wrapper(self):
    infer_default = path_wrapper(inference.infer_default)
    infer_end = path_wrapper(inference.infer_end)
    self.failUnlessRaises(InferenceError,
                          infer_default(1).next)
    self.failUnlessEqual(infer_end(1).next(), 1)

</t>
<t tx="ekr.20100212224846.10291">class InferenceTC(TestCase):

    CODE = '''
import exceptions

class C(object):
    "new style"
    attr = 4

    def meth1(self, arg1, optarg=0):
        var = object()
        print "yo", arg1, optarg
        self.iattr = "hop"
        return var

    def meth2(self):
        self.meth1(*self.meth3)

    def meth3(self, d=attr):
        b = self.attr
        c = self.iattr
        return b, c

ex = exceptions.Exception("msg")
v = C().meth1(1)
m_unbound = C.meth1
m_bound = C().meth1
a, b, c = ex, 1, "bonjour"
[d, e, f] = [ex, 1.0, ("bonjour", v)]
g, h = f
i, (j, k) = u"glup", f

a, b= b, a # Gasp !
'''

    @others
</t>
<t tx="ekr.20100212224846.10292">def setUp(self):
    self.astng = builder.string_build(self.CODE, __name__, __file__)

</t>
<t tx="ekr.20100212224846.10293">def test_module_inference(self):
    infered = self.astng.infer()
    obj = infered.next()
    self.failUnlessEqual(obj.name, __name__)
    self.failUnlessEqual(obj.root().name, __name__)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10294">def test_class_inference(self):
    infered = self.astng['C'].infer()
    obj = infered.next()
    self.failUnlessEqual(obj.name, 'C')
    self.failUnlessEqual(obj.root().name, __name__)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10295">def test_function_inference(self):
    infered = self.astng['C']['meth1'].infer()
    obj = infered.next()
    self.failUnlessEqual(obj.name, 'meth1')
    self.failUnlessEqual(obj.root().name, __name__)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10296">def test_builtin_name_inference(self):
    infered = self.astng['C']['meth1']['var'].infer()
    var = infered.next()
    self.failUnlessEqual(var.name, 'object')
    self.failUnlessEqual(var.root().name, '__builtin__')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10297">def test_tupleassign_name_inference(self):
    infered = self.astng['a'].infer()
    exc = infered.next()
    self.assertIsInstance(exc, Instance)
    self.failUnlessEqual(exc.name, 'Exception')
    self.failUnlessEqual(exc.root().name, 'exceptions')
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['b'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, 1)
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['c'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, "bonjour")
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10298">def test_listassign_name_inference(self):
    infered = self.astng['d'].infer()
    exc = infered.next()
    self.assertIsInstance(exc, Instance)
    self.failUnlessEqual(exc.name, 'Exception')
    self.failUnlessEqual(exc.root().name, 'exceptions')
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['e'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, 1.0)
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['f'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Tuple)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10299">def test_advanced_tupleassign_name_inference1(self):
    infered = self.astng['g'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, "bonjour")
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['h'].infer()
    var = infered.next()
    self.failUnlessEqual(var.name, 'object')
    self.failUnlessEqual(var.root().name, '__builtin__')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10300">def test_advanced_tupleassign_name_inference2(self):
    infered = self.astng['i'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, u"glup")
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['j'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, "bonjour")
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng['k'].infer()
    var = infered.next()
    self.failUnlessEqual(var.name, 'object')
    self.failUnlessEqual(var.root().name, '__builtin__')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10301">def test_swap_assign_inference(self):
    infered = self.astng.locals['a'][1].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, 1)
    self.failUnlessRaises(StopIteration, infered.next)
    infered = self.astng.locals['b'][1].infer()
    exc = infered.next()
    self.assertIsInstance(exc, Instance)
    self.failUnlessEqual(exc.name, 'Exception')
    self.failUnlessEqual(exc.root().name, 'exceptions')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10302">def test_getattr_inference1(self):
    infered = self.astng['ex'].infer()
    exc = infered.next()
    self.assertIsInstance(exc, Instance)
    self.failUnlessEqual(exc.name, 'Exception')
    self.failUnlessEqual(exc.root().name, 'exceptions')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10303">def test_getattr_inference2(self):
    infered = get_node_of_class(self.astng['C']['meth2'], nodes.Getattr).infer()
    meth1 = infered.next()
    self.failUnlessEqual(meth1.name, 'meth1')
    self.failUnlessEqual(meth1.root().name, __name__)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10304">def test_getattr_inference3(self):
    infered = self.astng['C']['meth3']['b'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, 4)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10305">def test_getattr_inference4(self):
    infered = self.astng['C']['meth3']['c'].infer()
    const = infered.next()
    self.assertIsInstance(const, nodes.Const)
    self.failUnlessEqual(const.value, "hop")
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10306">def test_callfunc_inference(self):
    infered = self.astng['v'].infer()
    meth1 = infered.next()
    self.assertIsInstance(meth1, Instance)
    self.failUnlessEqual(meth1.name, 'object')
    self.failUnlessEqual(meth1.root().name, '__builtin__')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10307">def test_unbound_method_inference(self):
    infered = self.astng['m_unbound'].infer()
    meth1 = infered.next()
    self.assertIsInstance(meth1, UnboundMethod)
    self.failUnlessEqual(meth1.name, 'meth1')
    self.failUnlessEqual(meth1.parent.frame().name, 'C')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10308">def test_bound_method_inference(self):
    infered = self.astng['m_bound'].infer()
    meth1 = infered.next()
    self.assertIsInstance(meth1, BoundMethod)
    self.failUnlessEqual(meth1.name, 'meth1')
    self.failUnlessEqual(meth1.parent.frame().name, 'C')
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10309">def test_args_default_inference1(self):
    optarg = get_name_node(self.astng['C']['meth1'], 'optarg')
    infered = optarg.infer()
    obj1 = infered.next()
    self.assertIsInstance(obj1, nodes.Const)
    self.failUnlessEqual(obj1.value, 0)
    obj1 = infered.next()
    self.assertIs(obj1, YES, obj1)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10310">def test_args_default_inference2(self):
    infered = self.astng['C']['meth3'].ilookup('d')
    obj1 = infered.next()
    self.assertIsInstance(obj1, nodes.Const)
    self.failUnlessEqual(obj1.value, 4)
    obj1 = infered.next()
    self.assertIs(obj1, YES, obj1)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10311">def test_inference_restrictions(self):
    infered = get_name_node(self.astng['C']['meth1'], 'arg1').infer()
    obj1 = infered.next()
    self.assertIs(obj1, YES, obj1)
    self.failUnlessRaises(StopIteration, infered.next)

</t>
<t tx="ekr.20100212224846.10312">def test_ancestors_inference(self):
    code = '''
\\-4class A:
pass

\\-4class A(A):
pass
    '''
    astng = builder.string_build(code, __name__, __file__)
    a1 = astng.locals['A'][0]
    a2 = astng.locals['A'][1]
    a2_ancestors = list(a2.ancestors())
    self.failUnlessEqual(len(a2_ancestors), 1)
    self.failUnless(a2_ancestors[0] is a1)

</t>
<t tx="ekr.20100212224846.10313">def test_ancestors_inference2(self):
    code = '''
\\-4class A:
pass

\\-4class B(A): pass

\\-4class A(B):
pass
    '''
    astng = builder.string_build(code, __name__, __file__)
    a1 = astng.locals['A'][0]
    a2 = astng.locals['A'][1]
    a2_ancestors = list(a2.ancestors())
    self.failUnlessEqual(len(a2_ancestors), 2)
    self.failUnless(a2_ancestors[0] is astng.locals['B'][0])
    self.failUnless(a2_ancestors[1] is a1, a2_ancestors[1])


</t>
<t tx="ekr.20100212224846.10314">def test_f_arg_f(self):
    code = '''
\\-4def f(f=1):
return f

\\-4a = f()
    '''
    astng = builder.string_build(code, __name__, __file__)
    a = astng['a']
    a_infer = a.infer()
    self.failUnlessEqual(a_infer.next().value, 1)
    self.failUnlessRaises(StopIteration, a_infer.next)

</t>
<t tx="ekr.20100212224846.10315">def test_exc_ancestors(self):
    code = '''
\\-4def f():
raise NotImplementedError
    '''
    astng = builder.string_build(code, __name__, __file__)
    names = astng.nodes_of_class(nodes.Name)
    nie = names.next().infer().next()
    self.assertIsInstance(nie, nodes.Class)
    nie_ancestors = [c.name for c in nie.ancestors()]
    if sys.version_info &lt; (2, 5):
        self.failUnlessEqual(nie_ancestors, ['RuntimeError', 'StandardError', 'Exception'])
    else:
        self.failUnlessEqual(nie_ancestors, ['RuntimeError', 'StandardError', 'Exception', 'BaseException', 'object'])

</t>
<t tx="ekr.20100212224846.10316">def test_except_inference(self):
    code = '''
\\-4try:
print hop
\\-4except NameError, ex:
ex1 = ex
\\-4except Exception, ex:
ex2 = ex
raise
    '''
    astng = builder.string_build(code, __name__, __file__)
    ex1 = astng['ex1']
    ex1_infer = ex1.infer()
    ex1 = ex1_infer.next()
    self.assertIsInstance(ex1, Instance)
    self.failUnlessEqual(ex1.name, 'NameError')
    self.failUnlessRaises(StopIteration, ex1_infer.next)
    ex2 = astng['ex2']
    ex2_infer = ex2.infer()
    ex2 = ex2_infer.next()
    self.assertIsInstance(ex2, Instance)
    self.failUnlessEqual(ex2.name, 'Exception')
    self.failUnlessRaises(StopIteration, ex2_infer.next)

</t>
<t tx="ekr.20100212224846.10317">def test_del1(self):
    code = '''
\\-4del undefined_attr
    '''
    delete = builder.string_build(code, __name__, __file__).body[0]
    self.failUnlessRaises(InferenceError, delete.infer)

</t>
<t tx="ekr.20100212224846.10318">def test_del2(self):
    code = '''
\\-4a = 1
\\-4b = a
\\-4del a
\\-4c = a
\\-4a = 2
\\-4d = a
    '''
    astng = builder.string_build(code, __name__, __file__)
    n = astng['b']
    n_infer = n.infer()
    infered = n_infer.next()
    self.assertIsInstance(infered, nodes.Const)
    self.failUnlessEqual(infered.value, 1)
    self.failUnlessRaises(StopIteration, n_infer.next)
    n = astng['c']
    n_infer = n.infer()
    self.failUnlessRaises(InferenceError, n_infer.next)
    n = astng['d']
    n_infer = n.infer()
    infered = n_infer.next()
    self.assertIsInstance(infered, nodes.Const)
    self.failUnlessEqual(infered.value, 2)
    self.failUnlessRaises(StopIteration, n_infer.next)

</t>
<t tx="ekr.20100212224846.10319">def test_builtin_types(self):
    code = '''
\\-4l = [1]
\\-4t = (2,)
\\-4d = {}
\\-4s = ''
\\-4u = u''
    '''
    astng = builder.string_build(code, __name__, __file__)
    n = astng['l']
    infered = n.infer().next()
    self.assertIsInstance(infered, nodes.List)
    self.assertIsInstance(infered, Instance)
    self.failUnlessEqual(infered.getitem(0).value, 1)
    self.assertIsInstance(infered._proxied, nodes.Class)
    self.failUnlessEqual(infered._proxied.name, 'list')
    self.failUnless('append' in infered._proxied.locals)
    n = astng['t']
    infered = n.infer().next()
    self.assertIsInstance(infered, nodes.Tuple)
    self.assertIsInstance(infered, Instance)
    self.failUnlessEqual(infered.getitem(0).value, 2)
    self.assertIsInstance(infered._proxied, nodes.Class)
    self.failUnlessEqual(infered._proxied.name, 'tuple')
    n = astng['d']
    infered = n.infer().next()
    self.assertIsInstance(infered, nodes.Dict)
    self.assertIsInstance(infered, Instance)
    self.assertIsInstance(infered._proxied, nodes.Class)
    self.failUnlessEqual(infered._proxied.name, 'dict')
    self.failUnless('get' in infered._proxied.locals)
    n = astng['s']
    infered = n.infer().next()
    self.assertIsInstance(infered, nodes.Const)
    self.assertIsInstance(infered, Instance)
    self.failUnlessEqual(infered.name, 'str')
    self.failUnless('lower' in infered._proxied.locals)
    n = astng['u']
    infered = n.infer().next()
    self.assertIsInstance(infered, nodes.Const)
    self.assertIsInstance(infered, Instance)
    self.failUnlessEqual(infered.name, 'unicode')
    self.failUnless('lower' in infered._proxied.locals)

</t>
<t tx="ekr.20100212224846.10320">def test_descriptor_are_callable(self):
    code = '''
\\-4class A:
statm = staticmethod(open)
clsm = classmethod('whatever')
    '''
    astng = builder.string_build(code, __name__, __file__)
    statm = astng['A'].igetattr('statm').next()
    self.failUnless(statm.callable())
    clsm = astng['A'].igetattr('clsm').next()
    self.failUnless(clsm.callable())

</t>
<t tx="ekr.20100212224846.10321">def test_bt_ancestor_crash(self):
    code = '''
\\-4class Warning(Warning):
pass
    '''
    astng = builder.string_build(code, __name__, __file__)
    w = astng['Warning']
    ancestors = w.ancestors()
    ancestor = ancestors.next()
    self.failUnlessEqual(ancestor.name, 'Warning')
    self.failUnlessEqual(ancestor.root().name, 'exceptions')
    ancestor = ancestors.next()
    self.failUnlessEqual(ancestor.name, 'Exception')
    self.failUnlessEqual(ancestor.root().name, 'exceptions')
    if sys.version_info &gt;= (2, 5):
        ancestor = ancestors.next()
        self.failUnlessEqual(ancestor.name, 'BaseException')
        self.failUnlessEqual(ancestor.root().name, 'exceptions')
        ancestor = ancestors.next()
        self.failUnlessEqual(ancestor.name, 'object')
        self.failUnlessEqual(ancestor.root().name, '__builtin__')
    self.failUnlessRaises(StopIteration, ancestors.next)

</t>
<t tx="ekr.20100212224846.10322">def test_qqch(self):
    code = '''
\\-4from logilab.common.modutils import load_module_from_name
\\-4xxx = load_module_from_name('__pkginfo__')
    '''
    astng = builder.string_build(code, __name__, __file__)
    xxx = astng['xxx']
    infered = list(xxx.infer())
    self.failUnlessEqual(sorted([n.__class__ for n in infered]),
                         sorted([nodes.Const, YES.__class__]))

</t>
<t tx="ekr.20100212224846.10323">def test_method_argument(self):
    code = '''
\\-4class ErudiEntitySchema:
"""a entity has a type, a set of subject and or object relations"""
def __init__(self, e_type, **kwargs):
    kwargs['e_type'] = e_type.capitalize().encode()

def meth(self, e_type, *args, **kwargs):
    kwargs['e_type'] = e_type.capitalize().encode()
    print args
    '''
    astng = builder.string_build(code, __name__, __file__)
    arg = get_name_node(astng['ErudiEntitySchema']['__init__'], 'e_type')
    self.failUnlessEqual([n.__class__ for n in arg.infer()],
                         [YES.__class__])
    arg = get_name_node(astng['ErudiEntitySchema']['__init__'], 'kwargs')
    self.failUnlessEqual([n.__class__ for n in arg.infer()],
                         [nodes.Dict])
    arg = get_name_node(astng['ErudiEntitySchema']['meth'], 'e_type')
    self.failUnlessEqual([n.__class__ for n in arg.infer()],
                         [YES.__class__])
    arg = get_name_node(astng['ErudiEntitySchema']['meth'], 'args')
    self.failUnlessEqual([n.__class__ for n in arg.infer()],
                         [nodes.Tuple])
    arg = get_name_node(astng['ErudiEntitySchema']['meth'], 'kwargs')
    self.failUnlessEqual([n.__class__ for n in arg.infer()],
                         [nodes.Dict])


</t>
<t tx="ekr.20100212224846.10324">def test_tuple_then_list(self):
    code = '''
\\-4def test_view(rql, vid, tags=()):
tags = list(tags)
tags.append(vid)
    '''
    astng = builder.string_build(code, __name__, __file__)
    name = get_name_node(astng['test_view'], 'tags', -1)
    it = name.infer()
    tags = it.next()
    self.failUnlessEqual(tags.__class__, Instance)
    self.failUnlessEqual(tags._proxied.name, 'list')
    self.failUnlessRaises(StopIteration, it.next)



</t>
<t tx="ekr.20100212224846.10325">def test_mulassign_inference(self):
    code = '''

\\-4def first_word(line):
"""Return the first word of a line"""

return line.split()[0]

\\-4def last_word(line):
"""Return last word of a line"""

return line.split()[-1]

\\-4def process_line(word_pos):
"""Silly function: returns (ok, callable) based on argument.

   For test purpose only.
"""

if word_pos &gt; 0:
    return (True, first_word)
elif word_pos &lt; 0:
    return  (True, last_word)
else:
    return (False, None)

\\-4if __name__ == '__main__':

line_number = 0
for a_line in file('test_callable.py'):
    tupletest  = process_line(line_number)
    (ok, fct)  = process_line(line_number)
    if ok:
        fct(a_line)
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual(len(list(astng['process_line'].infer_call_result(
                                                            None))), 3)
    self.failUnlessEqual(len(list(astng['tupletest'].infer())), 3)
    values = ['Function(first_word)', 'Function(last_word)', 'Const(None)']
    self.failUnlessEqual([str(infered).replace('FunctionDef', 'Function')
                          for infered in astng['fct'].infer()], values)

</t>
<t tx="ekr.20100212224846.10326">def test_float_complex_ambiguity(self):
    code = '''
\\-4def no_conjugate_member(magic_flag):
"""should not raise E1101 on something.conjugate"""
if magic_flag:
    something = 1.0
else:
    something = 1.0j
if isinstance(something, float):
    return something
return something.conjugate()
    '''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual([i.value for i in
        astng['no_conjugate_member'].ilookup('something')], [1.0, 1.0j])
    self.failUnlessEqual([i.value for i in
            get_name_node(astng, 'something', -1).infer()], [1.0, 1.0j])

</t>
<t tx="ekr.20100212224846.10327">def test_lookup_cond_branches(self):
    code = '''
\\-4def no_conjugate_member(magic_flag):
"""should not raise E1101 on something.conjugate"""
something = 1.0
if magic_flag:
    something = 1.0j
return something.conjugate()
    '''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual([i.value for i in
            get_name_node(astng, 'something', -1).infer()], [1.0, 1.0j])


</t>
<t tx="ekr.20100212224846.10328">def test_simple_subscript(self):
    code = '''
\\-4a = [1, 2, 3][0]
\\-4b = (1, 2, 3)[1]
\\-4c = (1, 2, 3)[-1]
\\-4d = a + b + c
\\-4print d
    '''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual([i.value for i in
                            get_name_node(astng, 'a', -1).infer()], [1])
    self.failUnlessEqual([i.value for i in
                            get_name_node(astng, 'b', -1).infer()], [2])
    self.failUnlessEqual([i.value for i in
                            get_name_node(astng, 'c', -1).infer()], [3])
    self.failUnlessEqual([i.value for i in
                            get_name_node(astng, 'd', -1).infer()], [6])

</t>
<t tx="ekr.20100212224846.10329">#def test_simple_tuple(self):
    #"""test case for a simple tuple value"""
    ## XXX tuple inference is not implemented ...
    #code = """
\\-4#a = (1,)
\\-4#b = (22,)
\\-4#some = a + b
\\-4#"""
    #astng = builder.string_build(code, __name__, __file__)
    #self.failUnlessEqual(astng['some'].infer.next().as_string(), "(1, 22)")

def test_simple_for(self):
    code = '''
\\-4for a in [1, 2, 3]:
print a
\\-4for b,c in [(1,2), (3,4)]:
print b
print c

\\-4print [(d,e) for e,d in ([1,2], [3,4])]
    '''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'a', -1).infer()], [1, 2, 3])
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'b', -1).infer()], [1, 3])
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'c', -1).infer()], [2, 4])
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'd', -1).infer()], [2, 4])
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'e', -1).infer()], [1, 3])


</t>
<t tx="ekr.20100212224846.10330">def test_simple_for_genexpr(self):
    if sys.version_info &lt; (2, 4):
        return
    code = '''
\\-4print ((d,e) for e,d in ([1,2], [3,4]))
    '''
    astng = builder.string_build(code, __name__, __file__)
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'd', -1).infer()], [2, 4])
    self.failUnlessEqual([i.value for i in
                        get_name_node(astng, 'e', -1).infer()], [1, 3])


</t>
<t tx="ekr.20100212224846.10331">def test_builtin_help(self):
    code = '''
\\-4help()
    '''
    # XXX failing with python &gt; 2.3 since __builtin__.help assigment has
    #     been moved into a function...
    astng = builder.string_build(code, __name__, __file__)
    node = get_name_node(astng, 'help', -1)
    infered = list(node.infer())
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], Instance)
    self.failUnlessEqual(str(infered[0]),
                         'Instance of site._Helper')

</t>
<t tx="ekr.20100212224846.10332">def test_builtin_open(self):
    code = '''
\\-4open("toto.txt")
    '''
    astng = builder.string_build(code, __name__, __file__)
    node = get_name_node(astng, 'open', -1)
    infered = list(node.infer())
    self.failUnlessEqual(len(infered), 1)
    if open is file:
        # On python &lt; 2.5 open and file are the same thing.
        self.assertIsInstance(infered[0], nodes.Class)
        self.failUnlessEqual(infered[0].name, 'file')
    else:
        # On python &gt;= 2.5 open is a builtin function.
        self.assertIsInstance(infered[0], nodes.Function)
        self.failUnlessEqual(infered[0].name, 'open')

</t>
<t tx="ekr.20100212224846.10333">def test_callfunc_context_func(self):
    code = '''
\\-4def mirror(arg=None):
return arg

\\-4un = mirror(1)
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng.igetattr('un'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Const)
    self.failUnlessEqual(infered[0].value, 1)

</t>
<t tx="ekr.20100212224846.10334">def test_callfunc_context_lambda(self):
    code = '''
\\-4mirror = lambda x=None: x

\\-4un = mirror(1)
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng.igetattr('mirror'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Lambda)
    infered = list(astng.igetattr('un'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Const)
    self.failUnlessEqual(infered[0].value, 1)

</t>
<t tx="ekr.20100212224846.10335">def test_factory_method(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    code = '''
\\-4class Super(object):
  @classmethod
  def instance(cls):
          return cls()

\\-4class Sub(Super):
  def method(self):
          print 'method called'

\\-4sub = Sub.instance()
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng.igetattr('sub'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], Instance)
    self.failUnlessEqual(infered[0]._proxied.name, 'Sub')


</t>
<t tx="ekr.20100212224846.10336">def test_import_as(self):
    code = '''
\\-4import os.path as osp
\\-4print osp.dirname(__file__)

\\-4from os.path import exists as e
\\-4assert e(__file__)

\\-4from new import code as make_code
\\-4print make_code
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng.igetattr('osp'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Module)
    self.failUnlessEqual(infered[0].name, 'os.path')
    infered = list(astng.igetattr('e'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Function)
    self.failUnlessEqual(infered[0].name, 'exists')
    infered = list(astng.igetattr('make_code'))
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], Instance)
    self.failUnlessEqual(str(infered[0]), 'Instance of __builtin__.type')

</t>
<t tx="ekr.20100212224846.10337">def _test_const_infered(self, node, value):
    infered = list(node.infer())
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Const)
    self.failUnlessEqual(infered[0].value, value)

</t>
<t tx="ekr.20100212224846.10338">def test_unary_not(self):
    for code in ('a = not (1,); b = not ()',
                 'a = not {1:2}; b = not {}'):
        astng = builder.string_build(code, __name__, __file__)
        self._test_const_infered(astng['a'], False)
        self._test_const_infered(astng['b'], True)

</t>
<t tx="ekr.20100212224846.10339">def test_binary_op_int_add(self):
    astng = builder.string_build('a = 1 + 2', __name__, __file__)
    self._test_const_infered(astng['a'], 3)

</t>
<t tx="ekr.20100212224846.10340">def test_binary_op_int_sub(self):
    astng = builder.string_build('a = 1 - 2', __name__, __file__)
    self._test_const_infered(astng['a'], -1)

</t>
<t tx="ekr.20100212224846.10341">def test_binary_op_float_div(self):
    astng = builder.string_build('a = 1 / 2.', __name__, __file__)
    self._test_const_infered(astng['a'], 1 / 2.)

</t>
<t tx="ekr.20100212224846.10342">def test_binary_op_str_mul(self):
    astng = builder.string_build('a = "*" * 40', __name__, __file__)
    self._test_const_infered(astng['a'], "*" * 40)

</t>
<t tx="ekr.20100212224846.10343">def test_binary_op_bitand(self):
    astng = builder.string_build('a = 23&amp;20', __name__, __file__)
    self._test_const_infered(astng['a'], 23&amp;20)

</t>
<t tx="ekr.20100212224846.10344">def test_binary_op_bitor(self):
    astng = builder.string_build('a = 23|8', __name__, __file__)
    self._test_const_infered(astng['a'], 23|8)

</t>
<t tx="ekr.20100212224846.10345">def test_binary_op_bitxor(self):
    astng = builder.string_build('a = 23^9', __name__, __file__)
    self._test_const_infered(astng['a'], 23^9)

</t>
<t tx="ekr.20100212224846.10346">def test_binary_op_shiftright(self):
    astng = builder.string_build('a = 23 &gt;&gt;1', __name__, __file__)
    self._test_const_infered(astng['a'], 23&gt;&gt;1)

</t>
<t tx="ekr.20100212224846.10347">def test_binary_op_shiftleft(self):
    astng = builder.string_build('a = 23 &lt;&lt;1', __name__, __file__)
    self._test_const_infered(astng['a'], 23&lt;&lt;1)


</t>
<t tx="ekr.20100212224846.10348">def test_binary_op_list_mul(self):
    for code in ('a = [[]] * 2', 'a = 2 * [[]]'):
        astng = builder.string_build(code, __name__, __file__)
        infered = list(astng['a'].infer())
        self.failUnlessEqual(len(infered), 1)
        self.assertIsInstance(infered[0], nodes.List)
        self.failUnlessEqual(len(infered[0].elts), 2)
        self.assertIsInstance(infered[0].elts[0], nodes.List)
        self.assertIsInstance(infered[0].elts[1], nodes.List)

</t>
<t tx="ekr.20100212224846.10349">def test_binary_op_tuple_add(self):
    astng = builder.string_build('a = (1,) + (2,)', __name__, __file__)
    infered = list(astng['a'].infer())
    self.failUnlessEqual(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Tuple)
    self.failUnlessEqual(len(infered[0].elts), 2)
    self.failUnlessEqual(infered[0].elts[0].value, 1)
    self.failUnlessEqual(infered[0].elts[1].value, 2)

</t>
<t tx="ekr.20100212224846.10350">def test_binary_op_custom_class(self):
    code = '''
\\-4class myarray:
def __init__(self, array):
    self.array = array
def __mul__(self, x):
    return myarray([2,4,6])
def astype(self):
    return "ASTYPE"

\\-4def randint(maximum):
if maximum is not None:
    return myarray([1,2,3]) * 2
else:
    return int(5)

\\-4x = randint(1)
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng.igetattr('x'))
    self.failUnlessEqual(len(infered), 2)
    value = [str(v) for v in infered]
    # The __name__ trick here makes it work when invoked directly
    # (__name__ == '__main__') and through pytest (__name__ ==
    # 'unittest_inference')
    self.assertEquals(value, ['Instance of %s.myarray' % (__name__,),
                              'Instance of __builtin__.int'])

</t>
<t tx="ekr.20100212224846.10351">def test_nonregr_lambda_arg(self):
    code = '''
\\-4def f(g = lambda: None):
    g().x
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    callfuncnode = astng['f'].body[0].value.expr
    infered = list(callfuncnode.infer())
    self.failUnlessEqual(len(infered), 2, infered)
    infered.remove(YES)
    self.assertIsInstance(infered[0], nodes.Const)
    self.failUnlessEqual(infered[0].value, None)

</t>
<t tx="ekr.20100212224846.10352">def test_nonregr_getitem_empty_tuple(self):
    code = '''
\\-4def f(x):
    a = ()[x]
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(astng['f'].ilookup('a'))
    self.failUnlessEqual(len(infered), 1)
    self.failUnlessEqual(infered[0], YES)

</t>
<t tx="ekr.20100212224846.10353">def test_python25_generator_exit(self):
    sys.stderr = StringIO()
    data = "b = {}[str(0)+''].a"
    astng = builder.string_build(data, __name__, __file__)
    list(astng['b'].infer())
    output = sys.stderr.getvalue()
    # I have no idea how to test for this in another way...
    self.failIf("RuntimeError" in output, "Exception exceptions.RuntimeError: 'generator ignored GeneratorExit' in &lt;generator object&gt; ignored")
    sys.stderr = sys.__stderr__

</t>
<t tx="ekr.20100212224846.10354">def test_python25_relative_import(self):
    if sys.version_info &lt; (2, 5):
        self.skip('require py &gt;= 2.5')
    data = "from ...common import date; print date"
    astng = builder.string_build(data, 'logilab.astng.test.unittest_inference', __file__)
    infered = get_name_node(astng, 'date').infer().next()
    self.assertIsInstance(infered, nodes.Module)
    self.assertEquals(infered.name, 'logilab.common.date')

</t>
<t tx="ekr.20100212224846.10355">def test_python25_no_relative_import(self):
    if sys.version_info &lt; (2, 5):
        self.skip('require py &gt;= 2.5')
    # data = 'import unittest_lookup; print unittest_lookup'
    # astng = builder.string_build(data, 'logilab.astng.test.unittest_inference', __file__)
    # self.failIf(astng.absolute_import_activated())
    # infered = get_name_node(astng, 'unittest_lookup').infer().next()
    # self.assertIsInstance(infered, nodes.Module)
    data = 'from __future__ import absolute_import; import unittest_lookup; print unittest_lookup'
    astng = builder.file_build(join('regrtest_data', 'absimport.py'), 'absimport')
    self.failUnless(astng.absolute_import_activated(), True)
    infered = get_name_node(astng, 'import_package_subpackage_module').infer().next()
    # failed to import since absolute_import is activated
    self.failUnless(infered is YES)

</t>
<t tx="ekr.20100212224846.10356">#     def test_mechanize_open(self):
#         try:
#             import mechanize
#         except ImportError:
#             self.skip('require mechanize installed')
#         data = '''from mechanize import Browser
# print Browser
# b = Browser()
# print b
# '''
#         astng = builder.string_build(data, __name__, __file__)
#         browser = get_name_node(astng, 'Browser').infer().next()
#         self.assertIsInstance(browser, nodes.Class)
#         print '*'*80
#         bopen = list(browser.igetattr('open'))
#         self.assertEquals(len(bopen), 1)
#         self.assertIsInstance(bopen[0], nodes.Function)
#         self.failUnless(bopen[0].callable())
#         print '*'*80
#         b = get_name_node(astng, 'b').infer().next()
#         self.assertIsInstance(b, Instance)
#         bopen = list(b.igetattr('open'))
#         self.assertEquals(len(bopen), 1)
#         self.assertIsInstance(bopen[0], BoundMethod)
#         self.failUnless(bopen[0].callable())

def test_property(self):
    code = '''
\\-4from smtplib import SMTP
\\-4class SendMailController(object):

@property
def smtp(self):
    return SMTP(mailhost, port)

@property
def me(self):
    return self

\\-4print SendMailController().smtp
\\-4print SendMailController().me
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    self.assertEquals(astng['SendMailController']['smtp'].decoratornames(),
                      set(('__builtin__.property',)))
    propinfered = list(astng.body[2].values[0].infer())
    self.assertEquals(len(propinfered), 1)
    propinfered = propinfered[0]
    self.assertIsInstance(propinfered, Instance)
    self.assertEquals(propinfered.name, 'SMTP')
    self.assertEquals(propinfered.root().name, 'smtplib')
    self.assertEquals(astng['SendMailController']['me'].decoratornames(),
                      set(('__builtin__.property',)))
    propinfered = list(astng.body[3].values[0].infer())
    self.assertEquals(len(propinfered), 1)
    propinfered = propinfered[0]
    self.assertIsInstance(propinfered, Instance)
    self.assertEquals(propinfered.name, 'SendMailController')
    self.assertEquals(propinfered.root().name, __name__)


</t>
<t tx="ekr.20100212224846.10357">def test_im_func_unwrap(self):
    code = '''
\\-4class EnvBasedTC:
def pactions(self):
    print "hop"
\\-4pactions = EnvBasedTC.pactions.im_func
\\-4print pactions

\\-4class EnvBasedTC2:
pactions = EnvBasedTC.pactions.im_func
print pactions

\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    pactions = get_name_node(astng, 'pactions')
    infered = list(pactions.infer())
    self.assertEquals(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Function)
    pactions = get_name_node(astng['EnvBasedTC2'], 'pactions')
    infered = list(pactions.infer())
    self.assertEquals(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Function)

</t>
<t tx="ekr.20100212224846.10358">def test_augassign(self):
    code = '''
\\-4a = 1
\\-4a += 2
\\-4print a
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(get_name_node(astng, 'a').infer())
    self.assertEquals(len(infered), 1)
    self.assertIsInstance(infered[0], nodes.Const)
    self.assertEquals(infered[0].value, 3)

</t>
<t tx="ekr.20100212224846.10359">def test_nonregr_func_arg(self):
    code = '''
\\-4def foo(self, bar):
def baz():
    pass
def qux():
    return baz
spam = bar(None, qux)
print spam
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(get_name_node(astng['foo'], 'spam').infer())
    self.assertEquals(len(infered), 1)
    self.assertIs(infered[0], YES)

</t>
<t tx="ekr.20100212224846.10360">def test_nonregr_func_global(self):
    code = '''
\\-4active_application = None

\\-4def get_active_application():
\\-2global active_application
\\-2return active_application

\\-4class Application(object):
\\-2def __init__(self):
 global active_application
 active_application = self

\\-4class DataManager(object):
\\-2def __init__(self, app=None):
 self.app = get_active_application()
\\-2def test(self):
 p = self.app
 print p
    '''
    astng = builder.string_build(code, __name__, __file__)
    infered = list(Instance(astng['DataManager']).igetattr('app'))
    self.assertEquals(len(infered), 2, infered) # None / Instance(Application)
    infered = list(get_name_node(astng['DataManager']['test'], 'p').infer())
    self.assertEquals(len(infered), 2, infered)
    for node in infered:
        if isinstance(node, Instance) and node.name == 'Application':
            break
    else:
        self.fail('expected to find an instance of Application in %s' % infered)
</t>
<t tx="ekr.20100212224846.10361">@language python
@tabwidth -4
@others
__all__ = ('LinkerTC', 'LinkerTC2')


if __name__ == '__main__':
    unittest.main()
</t>
<t tx="ekr.20100212224846.10362"># Copyright (c) 2003-2006 LOGILAB S.A. (Paris, FRANCE).
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#

"""
unittest for the visitors.diadefs module
"""

import unittest
import sys

from logilab.astng import MANAGER, nodes, inspector
from logilab.astng.infutils import Instance, YES

</t>
<t tx="ekr.20100212224846.10363">def astng_wrapper(func, modname):
    return func(modname)


</t>
<t tx="ekr.20100212224846.10364">class LinkerTC(unittest.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10365">
def setUp(self):
    self.project = MANAGER.project_from_files(['data2'], astng_wrapper) 
    self.linker = inspector.Linker(self.project)
    self.linker.visit(self.project)

</t>
<t tx="ekr.20100212224846.10366">def test_class_implements(self):
    klass = self.project.get_module('data2.clientmodule_test')['Ancestor']
    self.assert_(hasattr(klass, 'implements'))
    self.assertEqual(len(klass.implements), 1)
    self.assert_(isinstance(klass.implements[0], nodes.Class))
    self.assertEqual(klass.implements[0].name, "Interface")
    klass = self.project.get_module('data2.clientmodule_test')['Specialization']
    self.assert_(hasattr(klass, 'implements'))
    self.assertEqual(len(klass.implements), 0)

</t>
<t tx="ekr.20100212224846.10367">def test_locals_assignment_resolution(self):
    klass = self.project.get_module('data2.clientmodule_test')['Specialization']
    self.assert_(hasattr(klass, 'locals_type'))
    type_dict = klass.locals_type
    self.assertEqual(len(type_dict), 2)
    keys = type_dict.keys()
    keys.sort()
    self.assertEqual(keys, ['TYPE', 'top'])
    self.assertEqual(len(type_dict['TYPE']), 1)
    self.assertEqual(type_dict['TYPE'][0].value, 'final class')
    self.assertEqual(len(type_dict['top']), 1)
    self.assertEqual(type_dict['top'][0].value, 'class')

</t>
<t tx="ekr.20100212224846.10368">def test_instance_attrs_resolution(self):
    klass = self.project.get_module('data2.clientmodule_test')['Specialization']
    self.assert_(hasattr(klass, 'instance_attrs_type'))
    type_dict = klass.instance_attrs_type
    self.assertEqual(len(type_dict), 3)
    keys = type_dict.keys()
    keys.sort()
    self.assertEqual(keys, ['_id', 'relation', 'toto'])
    self.assert_(isinstance(type_dict['relation'][0], Instance), type_dict['relation'])
    self.assertEqual(type_dict['relation'][0].name, 'DoNothing')
    self.assert_(isinstance(type_dict['toto'][0], Instance), type_dict['toto'])
    self.assertEqual(type_dict['toto'][0].name, 'Toto')
    self.assert_(type_dict['_id'][0] is YES, type_dict['_id'])


</t>
<t tx="ekr.20100212224846.10369">class LinkerTC2(LinkerTC):
    @others
</t>
<t tx="ekr.20100212224846.10370">
def setUp(self):
    self.project = MANAGER.from_directory('data2') 
    self.linker = inspector.Linker(self.project)
    self.linker.visit(self.project)

</t>
<t tx="ekr.20100212224846.10371">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest_main()
</t>
<t tx="ekr.20100212224846.10372"># This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""tests for the astng variable lookup capabilities
"""
import sys
from os.path import join, abspath
from logilab.common.testlib import TestCase, unittest_main

from logilab.astng import builder, nodes, scoped_nodes, lookup, \
     InferenceError, NotFoundError

from unittest_inference import get_name_node

builder = builder.ASTNGBuilder()
MODULE = builder.file_build('data/module.py', 'data.module')
MODULE2 = builder.file_build('data/module2.py', 'data.module2')
NONREGR = builder.file_build('data/nonregr.py', 'data.nonregr')

</t>
<t tx="ekr.20100212224846.10373">class LookupTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10374">
def test_limit(self):
    code = '''
\\-4l = [a
 for a,b in list]

\\-4a = 1
\\-4b = a
\\-4a = None

\\-4def func():
c = 1
    '''
    astng = builder.string_build(code, __name__, __file__)
    names = astng.nodes_of_class(nodes.Name)
    a = names.next()
    stmts = a.lookup('a')[1]
    self.failUnlessEqual(len(stmts), 1)
    b = astng.locals['b'][1]
    #self.failUnlessEqual(len(b.lookup('b')[1]), 1)
    self.failUnlessEqual(len(astng.lookup('b')[1]), 2)
    b_infer = b.infer()
    b_value = b_infer.next()
    self.failUnlessEqual(b_value.value, 1)
    self.failUnlessRaises(StopIteration, b_infer.next)
    func = astng.locals['func'][0]
    self.failUnlessEqual(len(func.lookup('c')[1]), 1)

</t>
<t tx="ekr.20100212224846.10375">def test_module(self):
    astng = builder.string_build('pass', __name__, __file__)
    # built-in objects
    none = astng.ilookup('None').next()
    self.assertEquals(none.value, None)
    obj = astng.ilookup('object').next()
    self.assertIsInstance(obj, nodes.Class)
    self.assertEquals(obj.name, 'object')
    self.assertRaises(InferenceError, astng.ilookup('YOAA').next)

    # XXX
    self.assertEquals(len(list(NONREGR.ilookup('enumerate'))), 2)

</t>
<t tx="ekr.20100212224846.10376">def test_class_ancestor_name(self):
    code = '''
\\-4class A:
pass

\\-4class A(A):
pass
    '''
    astng = builder.string_build(code, __name__, __file__)
    cls1 = astng.locals['A'][0]
    cls2 = astng.locals['A'][1]
    name = cls2.nodes_of_class(nodes.Name).next()
    self.assertEquals(name.infer().next(), cls1)

</t>
<t tx="ekr.20100212224846.10377">### backport those test to inline code
def test_method(self):
    method = MODULE['YOUPI']['method']
    my_dict = method.ilookup('MY_DICT').next()
    self.assert_(isinstance(my_dict, nodes.Dict), my_dict)
    none = method.ilookup('None').next()
    self.assertEquals(none.value, None)
    self.assertRaises(InferenceError, method.ilookup('YOAA').next)


</t>
<t tx="ekr.20100212224846.10378">def test_function_argument_with_default(self):
    make_class = MODULE2['make_class']
    base = make_class.ilookup('base').next()
    self.assert_(isinstance(base, nodes.Class), base.__class__)
    self.assertEquals(base.name, 'YO')
    self.assertEquals(base.root().name, 'data.module')


</t>
<t tx="ekr.20100212224846.10379">def test_class(self):
    klass = MODULE['YOUPI']
    my_dict = klass.ilookup('MY_DICT').next()
    self.assertIsInstance(my_dict, nodes.Dict)
    none = klass.ilookup('None').next()
    self.assertEquals(none.value, None)
    obj = klass.ilookup('object').next()
    self.assertIsInstance(obj, nodes.Class)
    self.assertEquals(obj.name, 'object')
    self.assertRaises(InferenceError, klass.ilookup('YOAA').next)


</t>
<t tx="ekr.20100212224846.10380">def test_inner_classes(self):
    ccc = NONREGR['Ccc']
    self.assertEquals(ccc.ilookup('Ddd').next().name, 'Ddd')


</t>
<t tx="ekr.20100212224846.10381">def test_loopvar_hiding(self):
    astng = builder.string_build("""
\\-4x = 10
\\-4for x in range(5):
print x

\\-4if x &gt; 0:
print '#' * x        
    """, __name__, __file__)
    xnames = [n for n in astng.nodes_of_class(nodes.Name) if n.name == 'x']
    # inside the loop, only one possible assigment
    self.assertEquals(len(xnames[0].lookup('x')[1]), 1)
    # outside the loop, two possible assigments
    self.assertEquals(len(xnames[1].lookup('x')[1]), 2)
    self.assertEquals(len(xnames[2].lookup('x')[1]), 2)

</t>
<t tx="ekr.20100212224846.10382">def test_list_comps(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    astng = builder.string_build("""
\\-4print [ i for i in range(10) ]
\\-4print [ i for i in range(10) ]
\\-4print list( i for i in range(10) )
    """, __name__, __file__)
    xnames = [n for n in astng.nodes_of_class(nodes.Name) if n.name == 'i']
    self.assertEquals(len(xnames[0].lookup('i')[1]), 1)
    self.assertEquals(xnames[0].lookup('i')[1][0].lineno, 2)
    self.assertEquals(len(xnames[1].lookup('i')[1]), 1)
    self.assertEquals(xnames[1].lookup('i')[1][0].lineno, 3)
    self.assertEquals(len(xnames[2].lookup('i')[1]), 1)
    self.assertEquals(xnames[2].lookup('i')[1][0].lineno, 4)


</t>
<t tx="ekr.20100212224846.10383">def test_explicit___name__(self):
    code = '''
\\-4class Pouet:
__name__ = "pouet"
\\-4p1 = Pouet()

\\-4class PouetPouet(Pouet): pass
\\-4p2 = Pouet()

\\-4class NoName: pass
\\-4p3 = NoName()
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    p1 = astng['p1'].infer().next()
    self.failUnless(p1.getattr('__name__'))
    p2 = astng['p2'].infer().next()
    self.failUnless(p2.getattr('__name__'))
    self.failUnless(astng['NoName'].getattr('__name__'))
    p3 = astng['p3'].infer().next()
    self.assertRaises(NotFoundError, p3.getattr, '__name__')


</t>
<t tx="ekr.20100212224846.10384">def test_function_module_special(self):
    astng = builder.string_build('''
\\-4def initialize(linter):
"""initialize linter with checkers in this package """
package_load(linter, __path__[0])
    ''', 'data.__init__', 'data/__init__.py')
    path = [n for n in astng.nodes_of_class(nodes.Name) if n.name == '__path__'][0]
    self.assertEquals(len(path.lookup('__path__')[1]), 1)


</t>
<t tx="ekr.20100212224846.10385">def test_builtin_lookup(self):
    self.assertEquals(lookup.builtin_lookup('__dict__')[1], ())
    intstmts = lookup.builtin_lookup('int')[1]
    self.assertEquals(len(intstmts), 1)
    self.assertIsInstance(intstmts[0], nodes.Class)
    self.assertEquals(intstmts[0].name, 'int')
    self.assertIs(intstmts[0], nodes.const_factory(1)._proxied)


</t>
<t tx="ekr.20100212224846.10386">def test_decorator_arguments_lookup(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    code = '''
\\-4def decorator(value):
\\-1def wrapper(function):
    return function
\\-1return wrapper

\\-4class foo:
\\-2member = 10

\\-2@decorator(member) #This will cause pylint to complain
\\-2def test(self):
   pass
    ''' 
    astng = builder.string_build(code, __name__, __file__)
    member = get_name_node(astng['foo'], 'member')
    it = member.infer()
    obj = it.next()
    self.assertIsInstance(obj, nodes.Const)
    self.assertEquals(obj.value, 10)
    self.assertRaises(StopIteration, it.next)


</t>
<t tx="ekr.20100212224846.10387">def test_inner_decorator_member_lookup(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    code = '''
\\-4class FileA:
def decorator(bla):
    return bla

@decorator
def funcA():
    return 4
    '''
    astng = builder.string_build(code, __name__, __file__)
    decname = get_name_node(astng['FileA'], 'decorator')
    it = decname.infer()
    obj = it.next()
    self.assertIsInstance(obj, nodes.Function)
    self.assertRaises(StopIteration, it.next)


</t>
<t tx="ekr.20100212224846.10388">def test_static_method_lookup(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    code = '''
\\-4class FileA:
@staticmethod
def funcA():
    return 4


\\-4class Test:
FileA = [1,2,3]

def __init__(self):
    print FileA.funcA()
    '''
    astng = builder.string_build(code, __name__, __file__)
    it = astng['Test']['__init__'].ilookup('FileA')
    obj = it.next()
    self.assertIsInstance(obj, nodes.Class)
    self.assertRaises(StopIteration, it.next)


</t>
<t tx="ekr.20100212224846.10389">def test_global_delete(self):
    code = '''
\\-4def run2():
f = Frobble()

\\-4class Frobble:
 pass
\\-4Frobble.mumble = True

\\-4del Frobble

\\-4def run1():
f = Frobble()
\\-4'''
    astng = builder.string_build(code, __name__, __file__)
    stmts = astng['run2'].lookup('Frobbel')[1]
    self.failUnlessEqual(len(stmts), 0)
    stmts = astng['run1'].lookup('Frobbel')[1]
    self.failUnlessEqual(len(stmts), 0)

</t>
<t tx="ekr.20100212224846.10390">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest.main()


</t>
<t tx="ekr.20100212224846.10391">import unittest
import os
import sys
from os.path import join, dirname
from logilab.astng.manager import ASTNGManager


</t>
<t tx="ekr.20100212224846.10392">class ASTNGManagerTC(unittest.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10393">def setUp(self):
    self.manager = ASTNGManager(borg=False)

</t>
<t tx="ekr.20100212224846.10394">def test_astng_from_module(self):
    astng = self.manager.astng_from_module(unittest)
    self.assertEquals(astng.pure_python, True)
    import time
    astng = self.manager.astng_from_module(time)
    self.assertEquals(astng.pure_python, False)

</t>
<t tx="ekr.20100212224846.10395">def test_astng_from_class(self):
    astng = self.manager.astng_from_class(file)
    self.assertEquals(astng.name, 'file')
    self.assertEquals(astng.parent.frame().name, '__builtin__')

    astng = self.manager.astng_from_class(object)
    self.assertEquals(astng.name, 'object')
    self.assertEquals(astng.parent.frame().name, '__builtin__')
    self.failUnless('__setattr__' in astng)

</t>
<t tx="ekr.20100212224846.10396">def _test_astng_from_zip(self, archive):
    origpath = sys.path[:]
    sys.modules.pop('mypypa', None)
    sys.path.insert(0, join(dirname(__file__), 'data', archive))
    try:
        module = self.manager.astng_from_module_name('mypypa')
        self.assertEquals(module.name, 'mypypa')
        self.failUnless(module.file.endswith('%s/mypypa' % archive),
                        module.file)
    finally:
        sys.path = origpath

</t>
<t tx="ekr.20100212224846.10397">def test_astng_from_module_name_egg(self):
    self._test_astng_from_zip('MyPyPa-0.1.0-py2.5.egg')

</t>
<t tx="ekr.20100212224846.10398">def test_astng_from_module_name_zip(self):
    self._test_astng_from_zip('MyPyPa-0.1.0-py2.5.zip')            

</t>
<t tx="ekr.20100212224846.10399">def test_from_directory(self):
    obj = self.manager.from_directory('data')
    self.assertEquals(obj.name, 'data')
    self.assertEquals(obj.path, join(os.getcwd(), 'data'))

</t>
<t tx="ekr.20100212224846.10400">def test_package_node(self):
    obj = self.manager.from_directory('data')
    expected_short = ['SSL1', '__init__', 'all', 'appl', 'format', 'module', 'module2',
                      'noendingnewline', 'nonregr', 'notall']
    expected_long = ['SSL1', 'data', 'data.all', 'appl', 'data.format', 'data.module',
                     'data.module2', 'data.noendingnewline', 'data.nonregr',
                     'data.notall']
    self.assertEquals(obj.keys(), expected_short)
    self.assertEquals([m.name for m in obj.values()], expected_long)
    self.assertEquals([m for m in list(obj)], expected_short)
    self.assertEquals([(name, m.name) for name, m in obj.items()],
                      zip(expected_short, expected_long))
    self.assertEquals([(name, m.name) for name, m in obj.items()],
                      zip(expected_short, expected_long))

    self.assertEquals('module' in obj, True)
    self.assertEquals(obj.has_key('module'), True)
    self.assertEquals(obj.get('module').name, 'data.module')
    self.assertEquals(obj['module'].name, 'data.module')
    self.assertEquals(obj.get('whatever'), None)
    self.assertEquals(obj.fullname(), 'data')
    # FIXME: test fullname on a subpackage


</t>
<t tx="ekr.20100212224846.10401">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    testlib.unittest_main()
</t>
<t tx="ekr.20100212224846.10402"># This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.

# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
"""tests for specific behaviour of astng nodes
"""
import sys

from logilab.common import testlib
from logilab.astng import builder, nodes, NotFoundError
from logilab.astng.nodes_as_string import as_string

from data import module as test_module

abuilder = builder.ASTNGBuilder()

</t>
<t tx="ekr.20100212224846.10403">class _NodeTC(testlib.TestCase):
    """test transformation of If Node"""
    CODE = None
    @others
</t>
<t tx="ekr.20100212224846.10404">@property
def astng(self):
    try:
        return self.__class__.__dict__['CODE_ASTNG']
    except KeyError:
        astng = abuilder.string_build(self.CODE)
        self.__class__.CODE_ASTNG = astng
        return astng


</t>
<t tx="ekr.20100212224846.10405">class IfNodeTC(_NodeTC):
    """test transformation of If Node"""
    CODE = """
if 0:
    print

if True:
    print
else:
    pass

if "":
    print
elif []:
    raise

if 1:
    print
elif True:
    print
elif func():
    pass
else:
    raise
    """

    @others
</t>
<t tx="ekr.20100212224846.10406">def test_if_elif_else_node(self):
    """test transformation for If node"""
    self.assertEquals(len(self.astng.body), 4)
    for stmt in self.astng.body:
        self.assertIsInstance( stmt, nodes.If)
    self.failIf(self.astng.body[0].orelse) # simple If
    self.assertIsInstance(self.astng.body[1].orelse[0], nodes.Pass) # If / else
    self.assertIsInstance(self.astng.body[2].orelse[0], nodes.If) # If / elif
    self.assertIsInstance(self.astng.body[3].orelse[0].orelse[0], nodes.If)

</t>
<t tx="ekr.20100212224846.10407">def test_block_range(self):
    # XXX ensure expected values
    self.assertEquals(self.astng.block_range(1), (0, 22))
    self.assertEquals(self.astng.block_range(10), (0, 22)) # XXX (10, 22) ?
    self.assertEquals(self.astng.body[1].block_range(5), (5, 6))
    self.assertEquals(self.astng.body[1].block_range(6), (6, 6))
    self.assertEquals(self.astng.body[1].orelse[0].block_range(7), (7, 8))
    self.assertEquals(self.astng.body[1].orelse[0].block_range(8), (8, 8))


</t>
<t tx="ekr.20100212224846.10408">class TryExceptNodeTC(_NodeTC):
    CODE = """
try:
    print 'pouet'
except IOError:
    pass
except UnicodeError:
    print
else:
    print
    """
    @others
</t>
<t tx="ekr.20100212224846.10409">def test_block_range(self):
    # XXX ensure expected values
    self.assertEquals(self.astng.body[0].block_range(1), (1, 8))
    self.assertEquals(self.astng.body[0].block_range(2), (2, 2))
    self.assertEquals(self.astng.body[0].block_range(3), (3, 8))
    self.assertEquals(self.astng.body[0].block_range(4), (4, 4))
    self.assertEquals(self.astng.body[0].block_range(5), (5, 5))
    self.assertEquals(self.astng.body[0].block_range(6), (6, 6))
    self.assertEquals(self.astng.body[0].block_range(7), (7, 7))
    self.assertEquals(self.astng.body[0].block_range(8), (8, 8))


</t>
<t tx="ekr.20100212224846.10410">class TryFinallyNodeTC(_NodeTC):
    CODE = """
try:
    print 'pouet'
finally:
    print 'pouet'
    """
    @others
</t>
<t tx="ekr.20100212224846.10411">def test_block_range(self):
    # XXX ensure expected values
    self.assertEquals(self.astng.body[0].block_range(1), (1, 4))
    self.assertEquals(self.astng.body[0].block_range(2), (2, 2))
    self.assertEquals(self.astng.body[0].block_range(3), (3, 4))
    self.assertEquals(self.astng.body[0].block_range(4), (4, 4))


</t>
<t tx="ekr.20100212224846.10412">class TryFinally25NodeTC(_NodeTC):
    CODE = """
try:
    print 'pouet'
except Exception:
    print 'oops'
finally:
    print 'pouet'
    """
    @others
</t>
<t tx="ekr.20100212224846.10413">def test_block_range(self):
    if sys.version_info &lt; (2, 5):
        self.skip('require python &gt;= 2.5')
    # XXX ensure expected values
    self.assertEquals(self.astng.body[0].block_range(1), (1, 6))
    self.assertEquals(self.astng.body[0].block_range(2), (2, 2))
    self.assertEquals(self.astng.body[0].block_range(3), (3, 4))
    self.assertEquals(self.astng.body[0].block_range(4), (4, 4))
    self.assertEquals(self.astng.body[0].block_range(5), (5, 5))
    self.assertEquals(self.astng.body[0].block_range(6), (6, 6))


</t>
<t tx="ekr.20100212224846.10414">MODULE = abuilder.module_build(test_module)
MODULE2 = abuilder.file_build('data/module2.py', 'data.module2')


class ImportNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10415">
def test_import_self_resolve(self):
    myos = MODULE2.igetattr('myos').next()
    self.failUnless(isinstance(myos, nodes.Module), myos)
    self.failUnlessEqual(myos.name, 'os')
    self.failUnlessEqual(myos.qname(), 'os')
    self.failUnlessEqual(myos.pytype(), '__builtin__.module')

</t>
<t tx="ekr.20100212224846.10416">def test_from_self_resolve(self):
    spawn = MODULE.igetattr('spawn').next()
    self.failUnless(isinstance(spawn, nodes.Class), spawn)
    self.failUnlessEqual(spawn.root().name, 'logilab.common.shellutils')
    self.failUnlessEqual(spawn.qname(), 'logilab.common.shellutils.Execute')
    self.failUnlessEqual(spawn.pytype(), '__builtin__.classobj')
    abspath = MODULE2.igetattr('abspath').next()
    self.failUnless(isinstance(abspath, nodes.Function), abspath)
    self.failUnlessEqual(abspath.root().name, 'os.path')
    self.failUnlessEqual(abspath.qname(), 'os.path.abspath')
    self.failUnlessEqual(abspath.pytype(), '__builtin__.function')

</t>
<t tx="ekr.20100212224846.10417">def test_real_name(self):
    from_ = MODULE['spawn']
    self.assertEquals(from_.real_name('spawn'), 'Execute')
    imp_ = MODULE['os']
    self.assertEquals(imp_.real_name('os'), 'os')
    self.assertRaises(NotFoundError, imp_.real_name, 'os.path')
    imp_ = MODULE['spawn']
    self.assertEquals(imp_.real_name('spawn'), 'Execute')
    self.assertRaises(NotFoundError, imp_.real_name, 'Execute')
    imp_ = MODULE2['YO']
    self.assertEquals(imp_.real_name('YO'), 'YO')
    self.assertRaises(NotFoundError, imp_.real_name, 'data')

</t>
<t tx="ekr.20100212224846.10418">def test_as_string(self):

    ast = MODULE['modutils']
    self.assertEquals(as_string(ast), "from logilab.common import modutils")
    ast = MODULE['spawn']
    self.assertEquals(as_string(ast), "from logilab.common.shellutils import Execute as spawn")
    ast = MODULE['os']
    self.assertEquals(as_string(ast), "import os.path")

</t>
<t tx="ekr.20100212224846.10419">def test_module_as_string(self):
    """just check as_string on a whole module doesn't raise an exception
    """
    self.assert_(as_string(MODULE))
    self.assert_(as_string(MODULE2))


</t>
<t tx="ekr.20100212224846.10420">class CmpNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10421">def test_as_string(self):
    ast = abuilder.string_build("a == 2")
    self.assertEquals(as_string(ast), "a == 2")


</t>
<t tx="ekr.20100212224846.10422">class ConstNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10423">
def _test(self, value):
    node = nodes.const_factory(value)
    self.assertIsInstance(node._proxied, nodes.Class)
    self.assertEquals(node._proxied.name, value.__class__.__name__)
    self.assertIs(node.value, value)
    self.failUnless(node._proxied.parent)
    self.assertEquals(node._proxied.root().name, value.__class__.__module__)

</t>
<t tx="ekr.20100212224846.10424">def test_none(self):
    self._test(None)

</t>
<t tx="ekr.20100212224846.10425">def test_bool(self):
    self._test(True)

</t>
<t tx="ekr.20100212224846.10426">def test_int(self):
    self._test(1)

</t>
<t tx="ekr.20100212224846.10427">def test_float(self):
    self._test(1.0)

</t>
<t tx="ekr.20100212224846.10428">def test_complex(self):
    self._test(1.0j)

</t>
<t tx="ekr.20100212224846.10429">def test_str(self):
    self._test('a')

</t>
<t tx="ekr.20100212224846.10430">def test_unicode(self):
    self._test(u'a')


</t>
<t tx="ekr.20100212224846.10431">class ArgumentsNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10432">def test_linenumbering(self):
    ast = abuilder.string_build('''
\\-4def func(a,
b): pass
\\-4x = lambda x: None
    ''')
    self.assertEquals(ast['func'].args.fromlineno, 2)
    self.assertEquals(ast['func'].args.tolineno, 3)
    self.failIf(ast['func'].args.is_statement)
    xlambda = ast['x'].infer().next()
    self.assertEquals(xlambda.args.fromlineno, 4)
    self.assertEquals(xlambda.args.tolineno, 4)
    self.failIf(xlambda.args.is_statement)


</t>
<t tx="ekr.20100212224846.10433">class SliceNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10434">def test(self):
    for code in ('a[0]', 'a[1:3]', 'a[:-1:step]', 'a[:,newaxis]',
                 'a[newaxis,:]', 'del L[::2]', 'del A[1]', 'del Br[:]'):
        ast = abuilder.string_build(code)
        self.assertEquals(ast.as_string(), code)

</t>
<t tx="ekr.20100212224846.10435">class EllipsisNodeTC(testlib.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10436">def test(self):
    ast = abuilder.string_build('a[...]')
    self.assertEquals(ast.as_string(), 'a[...]')

</t>
<t tx="ekr.20100212224846.10437">@language python
@tabwidth -4
@others
__all__ = ('ModuleNodeTC', 'ImportNodeTC', 'FunctionNodeTC', 'ClassNodeTC')

if __name__ == '__main__':
    unittest_main()
</t>
<t tx="ekr.20100212224846.10438">"""tests for specific behaviour of astng scoped nodes (ie module, class and
function)
"""

import sys
from os.path import join, abspath

from logilab.common.testlib import TestCase, unittest_main
from logilab.common.compat import sorted

from logilab.astng import builder, nodes, scoped_nodes, \
     InferenceError, NotFoundError
from logilab.astng.infutils import Instance, BoundMethod, UnboundMethod

abuilder = builder.ASTNGBuilder()
MODULE = abuilder.file_build('data/module.py', 'data.module')
MODULE2 = abuilder.file_build('data/module2.py', 'data.module2')
NONREGR = abuilder.file_build('data/nonregr.py', 'data.nonregr')
PACK = abuilder.file_build('data/__init__.py', 'data')

</t>
<t tx="ekr.20100212224846.10439">def _test_dict_interface(self, node, test_attr):
    self.assert_(node[test_attr] is node[test_attr])
    self.assert_(test_attr in node)
    node.keys()
    node.values()
    node.items()
    iter(node)


</t>
<t tx="ekr.20100212224846.10440">class ModuleNodeTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10441">
def test_special_attributes(self):
    self.assertEquals(len(MODULE.getattr('__name__')), 1)
    self.assertIsInstance(MODULE.getattr('__name__')[0], nodes.Const)
    self.assertEquals(MODULE.getattr('__name__')[0].value, 'data.module')
    self.assertEquals(len(MODULE.getattr('__doc__')), 1)
    self.assertIsInstance(MODULE.getattr('__doc__')[0], nodes.Const)
    self.assertEquals(MODULE.getattr('__doc__')[0].value, 'test module for astng\n')
    self.assertEquals(len(MODULE.getattr('__file__')), 1)
    self.assertIsInstance(MODULE.getattr('__file__')[0], nodes.Const)
    self.assertEquals(MODULE.getattr('__file__')[0].value, abspath(join('data', 'module.py')))
    self.assertEquals(len(MODULE.getattr('__dict__')), 1)
    self.assertIsInstance(MODULE.getattr('__dict__')[0], nodes.Dict)
    self.assertRaises(NotFoundError, MODULE.getattr, '__path__')
    self.assertEquals(len(PACK.getattr('__path__')), 1)
    self.assertIsInstance(PACK.getattr('__path__')[0], nodes.List)

</t>
<t tx="ekr.20100212224846.10442">def test_dict_interface(self):
    _test_dict_interface(self, MODULE, 'YO')

</t>
<t tx="ekr.20100212224846.10443">def test_getattr(self):
    yo = MODULE.getattr('YO')[0]
    self.assertIsInstance(yo, nodes.Class)
    self.assertEquals(yo.name, 'YO')
    red = MODULE.igetattr('redirect').next()
    self.assertIsInstance(red, nodes.Function)
    self.assertEquals(red.name, 'nested_args')
    spawn = MODULE.igetattr('spawn').next()
    self.assertIsInstance(spawn, nodes.Class)
    self.assertEquals(spawn.name, 'Execute')
    # resolve packageredirection
    sys.path.insert(1, 'data')
    try:
        m = abuilder.file_build('data/appl/myConnection.py', 'appl.myConnection')
        cnx = m.igetattr('SSL1').next().igetattr('Connection').next()
        self.assertEquals(cnx.__class__, nodes.Class)
        self.assertEquals(cnx.name, 'Connection')
        self.assertEquals(cnx.root().name, 'SSL1.Connection1')
    finally:
        del sys.path[1]
    self.assertEquals(len(NONREGR.getattr('enumerate')), 2)
    # raise ResolveError
    self.assertRaises(InferenceError, MODULE.igetattr, 'YOAA')

</t>
<t tx="ekr.20100212224846.10444">def test_wildard_import_names(self):
    m = abuilder.file_build('data/all.py', 'all')
    self.assertEquals(m.wildcard_import_names(), ['Aaa', '_bla', 'name'])
    m = abuilder.file_build('data/notall.py', 'notall')
    res = m.wildcard_import_names()
    res.sort()
    self.assertEquals(res, ['Aaa', 'func', 'name', 'other'])

</t>
<t tx="ekr.20100212224846.10445">def test_module_getattr(self):
    data = '''
\\-4appli = application
\\-4appli += 2
\\-4del appli
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    # test del statement not returned by getattr
    self.assertEquals(len(astng.getattr('appli')), 2,
                      astng.getattr('appli'))


</t>
<t tx="ekr.20100212224846.10446">class FunctionNodeTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10447">
def test_special_attributes(self):
    func = MODULE2['make_class']
    self.assertEquals(len(func.getattr('__name__')), 1)
    self.assertIsInstance(func.getattr('__name__')[0], nodes.Const)
    self.assertEquals(func.getattr('__name__')[0].value, 'make_class')
    self.assertEquals(len(func.getattr('__doc__')), 1)
    self.assertIsInstance(func.getattr('__doc__')[0], nodes.Const)
    self.assertEquals(func.getattr('__doc__')[0].value, 'check base is correctly resolved to Concrete0')
    self.assertEquals(len(MODULE.getattr('__dict__')), 1)
    self.assertIsInstance(MODULE.getattr('__dict__')[0], nodes.Dict)

</t>
<t tx="ekr.20100212224846.10448">def test_dict_interface(self):
    _test_dict_interface(self, MODULE['global_access'], 'local')

</t>
<t tx="ekr.20100212224846.10449">def test_default_value(self):
    func = MODULE2['make_class']
    self.assertIsInstance(func.args.default_value('base'), nodes.Getattr)
    self.assertRaises(scoped_nodes.NoDefault, func.args.default_value, 'args')
    self.assertRaises(scoped_nodes.NoDefault, func.args.default_value, 'kwargs')
    self.assertRaises(scoped_nodes.NoDefault, func.args.default_value, 'any')
    #self.assertIsInstance(func.mularg_class('args'), nodes.Tuple)
    #self.assertIsInstance(func.mularg_class('kwargs'), nodes.Dict)
    #self.assertEquals(func.mularg_class('base'), None)

</t>
<t tx="ekr.20100212224846.10450">def test_navigation(self):
    function = MODULE['global_access']
    self.assertEquals(function.statement(), function)
    l_sibling = function.previous_sibling()
    # check taking parent if child is not a stmt
    self.assertIsInstance(l_sibling, nodes.Assign)
    child = function.args.args[0]
    self.assert_(l_sibling is child.previous_sibling())
    r_sibling = function.next_sibling()
    self.assertIsInstance(r_sibling, nodes.Class)
    self.assertEquals(r_sibling.name, 'YO')
    self.assert_(r_sibling is child.next_sibling())
    last = r_sibling.next_sibling().next_sibling().next_sibling()
    self.assertIsInstance(last, nodes.Assign)
    self.assertEquals(last.next_sibling(), None)
    first = l_sibling.previous_sibling().previous_sibling().previous_sibling().previous_sibling().previous_sibling()
    self.assertEquals(first.previous_sibling(), None)

</t>
<t tx="ekr.20100212224846.10451">def test_nested_args(self):
    func = MODULE['nested_args']
    #self.assertEquals(func.args.args, ['a', ('b', 'c', 'd')])
    local = func.keys()
    local.sort()
    self.assertEquals(local, ['a', 'b', 'c', 'd'])
    self.assertEquals(func.type, 'function')

</t>
<t tx="ekr.20100212224846.10452">def test_format_args(self):
    func = MODULE2['make_class']
    self.assertEquals(func.args.format_args(), 'any, base=data.module.YO, *args, **kwargs')
    func = MODULE['nested_args']
    self.assertEquals(func.args.format_args(), 'a, (b, c, d)')

</t>
<t tx="ekr.20100212224846.10453">def test_is_abstract(self):
    method = MODULE2['AbstractClass']['to_override']
    self.assert_(method.is_abstract(pass_is_abstract=False))
    self.failUnlessEqual(method.qname(), 'data.module2.AbstractClass.to_override')
    self.failUnlessEqual(method.pytype(), '__builtin__.instancemethod')
    method = MODULE2['AbstractClass']['return_something']
    self.assert_(not method.is_abstract(pass_is_abstract=False))
    # non regression : test raise "string" doesn't cause an exception in is_abstract
    func = MODULE2['raise_string']
    self.assert_(not func.is_abstract(pass_is_abstract=False))

</t>
<t tx="ekr.20100212224846.10454">##     def test_raises(self):
##         method = MODULE2['AbstractClass']['to_override']
##         self.assertEquals([str(term) for term in method.raises()],
##                           ["CallFunc(Name('NotImplementedError'), [], None, None)"] )

##     def test_returns(self):
##         method = MODULE2['AbstractClass']['return_something']
##         # use string comp since Node doesn't handle __cmp__
##         self.assertEquals([str(term) for term in method.returns()],
##                           ["Const('toto')", "Const(None)"])

def test_lambda_pytype(self):
    data = '''
\\-4def f():
    g = lambda: None
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    g = list(astng['f'].ilookup('g'))[0]
    self.failUnlessEqual(g.pytype(), '__builtin__.function')

</t>
<t tx="ekr.20100212224846.10455">def test_is_method(self):
    if sys.version_info &lt; (2, 4):
        self.skip('this test require python &gt;= 2.4')
    data = '''
\\-4class A:
def meth1(self):
    return 1
@classmethod
def meth2(cls):
    return 2
@staticmethod
def meth3():
    return 3

\\-4def function():
return 0

\\-4@staticmethod
\\-4def sfunction():
return -1
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    self.failUnless(astng['A']['meth1'].is_method())
    self.failUnless(astng['A']['meth2'].is_method())
    self.failUnless(astng['A']['meth3'].is_method())
    self.failIf(astng['function'].is_method())
    self.failIf(astng['sfunction'].is_method())

</t>
<t tx="ekr.20100212224846.10456">def test_argnames(self):
    code = 'def f(a, (b, c), *args, **kwargs): pass'
    astng = abuilder.string_build(code, __name__, __file__)
    self.assertEquals(astng['f'].argnames(), ['a', 'b', 'c', 'args', 'kwargs'])


</t>
<t tx="ekr.20100212224846.10457">class ClassNodeTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10458">
def test_dict_interface(self):
    _test_dict_interface(self, MODULE['YOUPI'], 'method')

</t>
<t tx="ekr.20100212224846.10459">def test_cls_special_attributes_1(self):
    cls = MODULE['YO']
    self.assertEquals(len(cls.getattr('__bases__')), 1)
    self.assertEquals(len(cls.getattr('__name__')), 1)
    self.assertIsInstance(cls.getattr('__name__')[0], nodes.Const)
    self.assertEquals(cls.getattr('__name__')[0].value, 'YO')
    self.assertEquals(len(cls.getattr('__doc__')), 1)
    self.assertIsInstance(cls.getattr('__doc__')[0], nodes.Const)
    self.assertEquals(cls.getattr('__doc__')[0].value, 'hehe')
    self.assertEquals(len(cls.getattr('__module__')), 1)
    self.assertIsInstance(cls.getattr('__module__')[0], nodes.Const)
    self.assertEquals(cls.getattr('__module__')[0].value, 'data.module')
    self.assertEquals(len(cls.getattr('__dict__')), 1)
    self.assertRaises(NotFoundError, cls.getattr, '__mro__')
    for cls in (nodes.List._proxied, nodes.Const(1)._proxied):
        self.assertEquals(len(cls.getattr('__bases__')), 1)
        self.assertEquals(len(cls.getattr('__name__')), 1)
        self.assertEquals(len(cls.getattr('__doc__')), 1, (cls, cls.getattr('__doc__')))
        self.assertEquals(cls.getattr('__doc__')[0].value, cls.doc)
        self.assertEquals(len(cls.getattr('__module__')), 1)
        self.assertEquals(len(cls.getattr('__dict__')), 1)
        self.assertEquals(len(cls.getattr('__mro__')), 1)

</t>
<t tx="ekr.20100212224846.10460">def test_cls_special_attributes_2(self):
    astng = abuilder.string_build('''
\\-4class A: pass
\\-4class B: pass

\\-4A.__bases__ += (B,)
\\-4''', __name__, __file__)
    self.assertEquals(len(astng['A'].getattr('__bases__')), 2)
    self.assertIsInstance(astng['A'].getattr('__bases__')[0], nodes.Tuple)
    self.assertIsInstance(astng['A'].getattr('__bases__')[1], nodes.AssAttr)

</t>
<t tx="ekr.20100212224846.10461">def test_instance_special_attributes(self):
    for inst in (Instance(MODULE['YO']), nodes.List(), nodes.Const(1)):
        self.assertRaises(NotFoundError, inst.getattr, '__mro__')
        self.assertRaises(NotFoundError, inst.getattr, '__bases__')
        self.assertRaises(NotFoundError, inst.getattr, '__name__')
        self.assertEquals(len(inst.getattr('__dict__')), 1)
        self.assertEquals(len(inst.getattr('__doc__')), 1)

</t>
<t tx="ekr.20100212224846.10462">def test_navigation(self):
    klass = MODULE['YO']
    self.assertEquals(klass.statement(), klass)
    l_sibling = klass.previous_sibling()
    self.assert_(isinstance(l_sibling, nodes.Function), l_sibling)
    self.assertEquals(l_sibling.name, 'global_access')
    r_sibling = klass.next_sibling()
    self.assertIsInstance(r_sibling, nodes.Class)
    self.assertEquals(r_sibling.name, 'YOUPI')

</t>
<t tx="ekr.20100212224846.10463">def test_local_attr_ancestors(self):
    klass2 = MODULE['YOUPI']
    it = klass2.local_attr_ancestors('__init__')
    anc_klass = it.next()
    self.assertIsInstance(anc_klass, nodes.Class)
    self.assertEquals(anc_klass.name, 'YO')
    self.assertRaises(StopIteration, it.next)
    it = klass2.local_attr_ancestors('method')
    self.assertRaises(StopIteration, it.next)

</t>
<t tx="ekr.20100212224846.10464">def test_instance_attr_ancestors(self):
    klass2 = MODULE['YOUPI']
    it = klass2.instance_attr_ancestors('yo')
    anc_klass = it.next()
    self.assertIsInstance(anc_klass, nodes.Class)
    self.assertEquals(anc_klass.name, 'YO')
    self.assertRaises(StopIteration, it.next)
    klass2 = MODULE['YOUPI']
    it = klass2.instance_attr_ancestors('member')
    self.assertRaises(StopIteration, it.next)

</t>
<t tx="ekr.20100212224846.10465">def test_methods(self):
    klass2 = MODULE['YOUPI']
    methods = [m.name for m in klass2.methods()]
    methods.sort()
    self.assertEquals(methods, ['__init__', 'class_method',
                               'method', 'static_method'])
    methods = [m.name for m in klass2.mymethods()]
    methods.sort()
    self.assertEquals(methods, ['__init__', 'class_method',
                               'method', 'static_method'])
    klass2 = MODULE2['Specialization']
    methods = [m.name for m in klass2.mymethods()]
    methods.sort()
    self.assertEquals(methods, [])
    method_locals = klass2.local_attr('method')
    self.assertEquals(len(method_locals), 1)
    self.assertEquals(method_locals[0].name, 'method')
    self.assertRaises(NotFoundError, klass2.local_attr, 'nonexistant')
    methods = [m.name for m in klass2.methods()]
    methods.sort()
    self.assertEquals(methods, ['__init__', 'class_method',
                               'method', 'static_method'])

</t>
<t tx="ekr.20100212224846.10466">#def test_rhs(self):
#    my_dict = MODULE['MY_DICT']
#    self.assertIsInstance(my_dict.rhs(), nodes.Dict)
#    a = MODULE['YO']['a']
#    value = a.rhs()
#    self.assertIsInstance(value, nodes.Const)
#    self.assertEquals(value.value, 1)

def test_ancestors(self):
    klass = MODULE['YOUPI']
    ancs = [a.name for a in klass.ancestors()]
    self.assertEquals(ancs, ['YO'])
    klass = MODULE2['Specialization']
    ancs = [a.name for a in klass.ancestors()]
    self.assertEquals(ancs, ['YOUPI', 'YO', 'YO'])

</t>
<t tx="ekr.20100212224846.10467">def test_type(self):
    klass = MODULE['YOUPI']
    self.assertEquals(klass.type, 'class')
    klass = MODULE2['Metaclass']
    self.assertEquals(klass.type, 'metaclass')
    klass = MODULE2['MyException']
    self.assertEquals(klass.type, 'exception')
    klass = MODULE2['MyIFace']
    self.assertEquals(klass.type, 'interface')
    klass = MODULE2['MyError']
    self.assertEquals(klass.type, 'exception')

</t>
<t tx="ekr.20100212224846.10468">def test_interfaces(self):
    for klass, interfaces in (('Concrete0', ['MyIFace']),
                              ('Concrete1', ['MyIFace', 'AnotherIFace']),
                              ('Concrete2', ['MyIFace', 'AnotherIFace']),
                              ('Concrete23', ['MyIFace', 'AnotherIFace'])):
        klass = MODULE2[klass]
        self.assertEquals([i.name for i in klass.interfaces()],
                          interfaces)

</t>
<t tx="ekr.20100212224846.10469">def test_concat_interfaces(self):
    astng = abuilder.string_build('''
\\-4class IMachin: pass

\\-4class Correct2:
"""docstring"""
__implements__ = (IMachin,)

\\-4class BadArgument:
"""docstring"""
__implements__ = (IMachin,)

\\-4class InterfaceCanNowBeFound:
"""docstring"""
__implements__ = BadArgument.__implements__ + Correct2.__implements__

    ''')
    self.assertEquals([i.name for i in astng['InterfaceCanNowBeFound'].interfaces()],
                      ['IMachin'])

</t>
<t tx="ekr.20100212224846.10470">def test_inner_classes(self):
    eee = NONREGR['Ccc']['Eee']
    self.assertEquals([n.name for n in eee.ancestors()], ['Ddd', 'Aaa', 'object'])


</t>
<t tx="ekr.20100212224846.10471">def test_classmethod_attributes(self):
    data = '''
\\-4class WebAppObject(object):
def registered(cls, application):
    cls.appli = application
    cls.schema = application.schema
    cls.config = application.config
    return cls
registered = classmethod(registered)
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    cls = astng['WebAppObject']
    self.assertEquals(sorted(cls.locals.keys()),
                      ['appli', 'config', 'registered', 'schema'])


</t>
<t tx="ekr.20100212224846.10472">def test_class_getattr(self):
    data =         '''
\\-4class WebAppObject(object):
appli = application
appli += 2
del self.appli
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    cls = astng['WebAppObject']
    # test del statement not returned by getattr
    self.assertEquals(len(cls.getattr('appli')), 2)


</t>
<t tx="ekr.20100212224846.10473">def test_instance_getattr(self):
    data =         '''
\\-4class WebAppObject(object):
def __init__(self, application):
    self.appli = application
    self.appli += 2
    del self.appli
     '''
    astng = abuilder.string_build(data, __name__, __file__)
    inst = Instance(astng['WebAppObject'])
    # test del statement not returned by getattr
    self.assertEquals(len(inst.getattr('appli')), 2)


</t>
<t tx="ekr.20100212224846.10474">def test_instance_getattr_with_class_attr(self):
    data = '''
\\-4class Parent:
aa = 1
cc = 1

\\-4class Klass(Parent):
aa = 0
bb = 0

def incr(self, val):
    self.cc = self.aa
    if val &gt; self.aa:
        val = self.aa
    if val &lt; self.bb:
        val = self.bb
    self.aa += val
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    inst = Instance(astng['Klass'])
    self.assertEquals(len(inst.getattr('aa')), 3, inst.getattr('aa'))
    self.assertEquals(len(inst.getattr('bb')), 1, inst.getattr('bb'))
    self.assertEquals(len(inst.getattr('cc')), 2, inst.getattr('cc'))


</t>
<t tx="ekr.20100212224846.10475">def test_getattr_method_transform(self):
    data = '''
\\-4class Clazz(object):

def m1(self, value):
    self.value = value
m2 = m1

\\-4def func(arg1, arg2):
"function that will be used as a method"
return arg1.value + arg2

\\-4Clazz.m3 = func
\\-4inst = Clazz()
\\-4inst.m4 = func
    '''
    astng = abuilder.string_build(data, __name__, __file__)
    cls = astng['Clazz']
    # test del statement not returned by getattr
    for method in ('m1', 'm2', 'm3'):
        inferred = list(cls.igetattr(method))
        self.assertEquals(len(inferred), 1)
        self.assertIsInstance(inferred[0], UnboundMethod)
        inferred = list(Instance(cls).igetattr(method))
        self.assertEquals(len(inferred), 1)
        self.assertIsInstance(inferred[0], BoundMethod)
    inferred = list(Instance(cls).igetattr('m4'))
    self.assertEquals(len(inferred), 1)
    self.assertIsInstance(inferred[0], nodes.Function)

</t>
<t tx="ekr.20100212224846.10476">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    unittest_main()

</t>
<t tx="ekr.20100212224846.10477">from logilab.common.testlib import TestCase, unittest_main

from logilab.astng import builder, nodes
from logilab.astng.infutils import are_exclusive

builder = builder.ASTNGBuilder()

</t>
<t tx="ekr.20100212224846.10478">class AreExclusiveTC(TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10479">def test_not_exclusive(self):
    astng = builder.string_build("""
\\-4x = 10
\\-4for x in range(5):
print x

\\-4if x &gt; 0:
print '#' * x        
    """, __name__, __file__)
    xass1 = astng.locals['x'][0]
    assert xass1.lineno == 2
    xnames = [n for n in astng.nodes_of_class(nodes.Name) if n.name == 'x']
    assert len(xnames) == 3
    assert xnames[1].lineno == 6
    self.assertEquals(are_exclusive(xass1, xnames[1]), False)
    self.assertEquals(are_exclusive(xass1, xnames[2]), False)

</t>
<t tx="ekr.20100212224846.10480">def test_if(self):
    astng = builder.string_build('''

\\-4if 1:
a = 1
a = 2
\\-4elif 2:
a = 12
a = 13
\\-4else:
a = 3
a = 4
    ''')
    a1 = astng.locals['a'][0]
    a2 = astng.locals['a'][1]
    a3 = astng.locals['a'][2]
    a4 = astng.locals['a'][3]
    a5 = astng.locals['a'][4]
    a6 = astng.locals['a'][5]
    self.assertEquals(are_exclusive(a1, a2), False)
    self.assertEquals(are_exclusive(a1, a3), True)
    self.assertEquals(are_exclusive(a1, a5), True)
    self.assertEquals(are_exclusive(a3, a5), True)
    self.assertEquals(are_exclusive(a3, a4), False)
    self.assertEquals(are_exclusive(a5, a6), False)

</t>
<t tx="ekr.20100212224846.10481">def test_try_except(self):
    astng = builder.string_build('''
\\-4try:
def exclusive_func2():
    "docstring"
\\-4except TypeError:
def exclusive_func2():
    "docstring"
\\-4except:
def exclusive_func2():
    "docstring"
\\-4else:
def exclusive_func2():
    "this one redefine the one defined line 42"

    ''')
    f1 = astng.locals['exclusive_func2'][0]
    f2 = astng.locals['exclusive_func2'][1]
    f3 = astng.locals['exclusive_func2'][2]
    f4 = astng.locals['exclusive_func2'][3]
    self.assertEquals(are_exclusive(f1, f2), True)
    self.assertEquals(are_exclusive(f1, f3), True)
    self.assertEquals(are_exclusive(f1, f4), False)
    self.assertEquals(are_exclusive(f2, f4), True)
    self.assertEquals(are_exclusive(f3, f4), True)
    self.assertEquals(are_exclusive(f3, f2), True)

    self.assertEquals(are_exclusive(f2, f1), True)
    self.assertEquals(are_exclusive(f4, f1), False)
    self.assertEquals(are_exclusive(f4, f2), True)

</t>
<t tx="ekr.20100212224846.10482">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10483"></t>
<t tx="ekr.20100212224846.10484">@language python
@tabwidth -4
@others
__all__ = 'Aaa', '_bla', 'name'
</t>
<t tx="ekr.20100212224846.10485">

name = 'a'
_bla = 2
other = 'o'
</t>
<t tx="ekr.20100212224846.10486">class Aaa: pass

</t>
<t tx="ekr.20100212224846.10487">def func(): print 'yo'

</t>
<t tx="ekr.20100212224846.10488">@language python
@tabwidth -4
@others
if aaaa: pass
else:
    aaaa,bbbb = 1,2
    aaaa,bbbb = bbbb,aaaa
# XXX write test
hop = \
    aaaa


__revision__.lower();

</t>
<t tx="ekr.20100212224846.10489">"""A multiline string
"""

function('aeozrijz\
earzer', hop)
# XXX write test
x = [i for i in range(5)
     if i % 4]

fonction(1,
         2,
         3,
         4)

</t>
<t tx="ekr.20100212224846.10490">def definition(a,
               b,
               c):
    return a + b + c

</t>
<t tx="ekr.20100212224846.10491">class debile(dict,
             object):
    pass

</t>
<t tx="ekr.20100212224846.10492">@language python
@tabwidth -4
@others
redirect = nested_args

</t>
<t tx="ekr.20100212224846.10493"># -*- coding: Latin-1 -*-
"""test module for astng
"""

__revision__ = '$Id: module.py,v 1.2 2005-11-02 11:56:54 syt Exp $'

from logilab.common import modutils
from logilab.common.shellutils import Execute as spawn
from logilab.astng.utils import *
import os.path

MY_DICT = {}


</t>
<t tx="ekr.20100212224846.10494">def global_access(key, val):
    """function test"""
    local = 1
    MY_DICT[key] = val
    for i in val:
        if i:
            del MY_DICT[i]
            continue
        else:
            break
    else:
        print '!!!'

</t>
<t tx="ekr.20100212224846.10495">class YO:
    """hehe"""
    a=1
    @others
</t>
<t tx="ekr.20100212224846.10496">def __init__(self):
    try:
        self.yo = 1
    except ValueError, ex:
        pass
    except (NameError, TypeError):
        raise XXXError()
    except:
        raise

</t>
<t tx="ekr.20100212224846.10497">#print '*****&gt;',YO.__dict__    
class YOUPI(YO):
    class_attr = None

    @others
    class_method = classmethod(class_method)


</t>
<t tx="ekr.20100212224846.10498">def __init__(self):
    self.member = None

</t>
<t tx="ekr.20100212224846.10499">def method(self):
    """method test"""
    global MY_DICT
    try:
        MY_DICT = {}
        local = None
        autre = [a for a, b in MY_DICT if b]
        if b in autre:
            print 'yo',
        elif a in autre:
            print 'hehe'
        global_access(local, val=autre)
    finally:
        return local

</t>
<t tx="ekr.20100212224846.10500">def static_method():
    """static method test"""
    assert MY_DICT, '???'
</t>
<t tx="ekr.20100212224846.10501">static_method = staticmethod(static_method)

def class_method(cls):
    """class method test"""
    exec a in b
</t>
<t tx="ekr.20100212224846.10502">def nested_args(a, (b, c, d)):
    """nested arguments test"""
    print a, b, c, d
    while 1:
        if a:
            break
        a += +1
    else:
        b += -2
    if c:
        d = a and b or c
    else:
        c = a and b or d
    map(lambda x, y: (y, x), a)

</t>
<t tx="ekr.20100212224846.10503">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10504">from __future__ import generators

from data.module import YO, YOUPI
import data

</t>
<t tx="ekr.20100212224846.10505">class Specialization(YOUPI, YO): pass

</t>
<t tx="ekr.20100212224846.10506">class Metaclass(type): pass

</t>
<t tx="ekr.20100212224846.10507">class Interface: pass

</t>
<t tx="ekr.20100212224846.10508">class MyIFace(Interface): pass

</t>
<t tx="ekr.20100212224846.10509">class AnotherIFace(Interface): pass

</t>
<t tx="ekr.20100212224846.10510">class MyException(Exception): pass
</t>
<t tx="ekr.20100212224846.10511">class MyError(MyException): pass

</t>
<t tx="ekr.20100212224846.10512">class AbstractClass(object):
    @others
</t>
<t tx="ekr.20100212224846.10513">
def to_override(self, whatever):
    raise NotImplementedError()

</t>
<t tx="ekr.20100212224846.10514">def return_something(self, param):
    if param:
        return 'toto'
    return

</t>
<t tx="ekr.20100212224846.10515">class Concrete0:
    __implements__ = MyIFace
</t>
<t tx="ekr.20100212224846.10516">class Concrete1:
    __implements__ = MyIFace, AnotherIFace
</t>
<t tx="ekr.20100212224846.10517">class Concrete2:
    __implements__ = (MyIFace,
                      AnotherIFace)
</t>
<t tx="ekr.20100212224846.10518">class Concrete23(Concrete1): pass

</t>
<t tx="ekr.20100212224846.10519">del YO.member

del YO
[SYN1, SYN2] = Concrete0, Concrete1
assert `1`
b = 1 | 2 &amp; 3 ^ 8
bb = 1 | two | 6
ccc = one &amp; two &amp; three
dddd = x ^ o ^ r
exec 'c = 3'
exec 'c = 3' in {}, {}

def raise_string(a=2, *args, **kwargs):
    raise 'pas glop'
    raise Exception, 'yo'
    yield 'coucou'

</t>
<t tx="ekr.20100212224846.10520">a = b + 2
c = b * 2
c = b / 2
c = b // 2
c = b - 2
c = b % 2
c = b ** 2
c = b &lt;&lt; 2
c = b &gt;&gt; 2
c = ~b

c = not b

d = [c]
e = d[:]
e = d[a:b:c]

raise_string(*args, **kwargs)

print &gt;&gt; stream, 'bonjour'
print &gt;&gt; stream, 'salut',


def make_class(any, base=data.module.YO, *args, **kwargs):
    """check base is correctly resolved to Concrete0"""
    class Aaaa(base):
        """dynamic class"""
    return Aaaa

</t>
<t tx="ekr.20100212224846.10521">from os.path import abspath

import os as myos


class A:
    pass

</t>
<t tx="ekr.20100212224846.10522">class A(A):
    pass
</t>
<t tx="ekr.20100212224846.10523">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    print 'test2'
    unittest.main() 


</t>
<t tx="ekr.20100212224846.10524">

import unittest 


</t>
<t tx="ekr.20100212224846.10525">class TestCase(unittest.TestCase):
    @others
</t>
<t tx="ekr.20100212224846.10526">
def setUp(self):
    unittest.TestCase.setUp(self)


</t>
<t tx="ekr.20100212224846.10527">def tearDown(self):
    unittest.TestCase.tearDown(self)

</t>
<t tx="ekr.20100212224846.10528">def testIt(self):
    self.a = 10
    self.xxx()


</t>
<t tx="ekr.20100212224846.10529">def xxx(self):
    if False:
        pass
        print 'a'

    if False:
        pass
        pass

    if False:
        pass
        print 'rara'


</t>
<t tx="ekr.20100212224846.10530">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10531">from __future__ import generators

try:
    enumerate = enumerate
except NameError:

    def enumerate(iterable):
        """emulates the python2.3 enumerate() function"""
        i = 0
        for val in iterable:
            yield i, val
            i += 1

</t>
<t tx="ekr.20100212224846.10532">def toto(value):
    for k, v in value:
        print v.get('yo')


</t>
<t tx="ekr.20100212224846.10533">import imp
fp, mpath, desc = imp.find_module('optparse',a)
s_opt = imp.load_module('std_optparse', fp, mpath, desc)

class OptionParser(s_opt.OptionParser):
    @others
</t>
<t tx="ekr.20100212224846.10534">
def parse_args(self, args=None, values=None, real_optparse=False):
    if real_optparse:
        pass
\\-4##          return super(OptionParser, self).parse_args()
    else:
        import optcomp
        optcomp.completion(self)


</t>
<t tx="ekr.20100212224846.10535">class Aaa(object):
    """docstring"""
    @others
</t>
<t tx="ekr.20100212224846.10536">def __init__(self):
    self.__setattr__('a','b')
    pass

</t>
<t tx="ekr.20100212224846.10537">def one_public(self):
    """docstring"""
    pass

</t>
<t tx="ekr.20100212224846.10538">def another_public(self):
    """docstring"""
    pass

</t>
<t tx="ekr.20100212224846.10539">class Ccc(Aaa):
    """docstring"""
    @others
</t>
<t tx="ekr.20100212224846.10540">
class Ddd(Aaa):
    """docstring"""
    pass

</t>
<t tx="ekr.20100212224846.10541">class Eee(Ddd):
    """docstring"""
    pass
</t>
<t tx="ekr.20100212224846.10542">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10543">

name = 'a'
_bla = 2
other = 'o'
</t>
<t tx="ekr.20100212224846.10544">class Aaa: pass

</t>
<t tx="ekr.20100212224846.10545">def func(): print 'yo'

</t>
<t tx="ekr.20100212224846.10546">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10547">__revision__="$Id: __init__.py,v 1.1 2005-06-13 20:55:20 syt Exp $"
</t>
<t tx="ekr.20100212224846.10548"></t>
<t tx="ekr.20100212224846.10549">@language python
@tabwidth -4
@others
@ignore</t>
<t tx="ekr.20100212224846.10550">"""M2Crypto.SSL.Connection

Copyright (c) 1999-2004 Ng Pheng Siong. All rights reserved."""

RCS_id='$Id: Connection1.py,v 1.1 2005-06-13 20:55:22 syt Exp $'

</t>
<t tx="ekr.20100212224846.10551">#Some code deleted here

class Connection:

    """An SSL connection."""
@others
</t>
<t tx="ekr.20100212224846.10552">

def __init__(self, ctx, sock=None):
    print 'init Connection'
</t>
<t tx="ekr.20100212224846.10553">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10554">from Connection1 import Connection
</t>
<t tx="ekr.20100212224846.10555"></t>
<t tx="ekr.20100212224846.10556">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    myConnection = MyConnection(' ')
    raw_input('Press Enter to continue...')
@ignore</t>
<t tx="ekr.20100212224846.10557">import SSL1
class MyConnection(SSL1.Connection):

    """An SSL connection."""
@others
</t>
<t tx="ekr.20100212224846.10558">

def __init__(self, dummy):
    print 'MyConnection init'

</t>
<t tx="ekr.20100212224846.10559">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10560">#
"""
Init
"""
</t>
<t tx="ekr.20100212224846.10561"></t>
<t tx="ekr.20100212224846.10562">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10563">""" docstring for file clientmodule.py """
from data2.suppliermodule_test import Interface as IFace, DoNothing

</t>
<t tx="ekr.20100212224846.10564">class Toto: pass

</t>
<t tx="ekr.20100212224846.10565">class Ancestor:
    """ Ancestor method """
    __implements__ = (IFace,)

    @others
</t>
<t tx="ekr.20100212224846.10566">def __init__(self, value):
    local_variable = 0
    self.attr = 'this method shouldn\'t have a docstring'
    self.__value = value

</t>
<t tx="ekr.20100212224846.10567">def get_value(self):
    """ nice docstring ;-) """
    return self.__value

</t>
<t tx="ekr.20100212224846.10568">def set_value(self, value):
    self.__value = value
    return 'this method shouldn\'t have a docstring'    

</t>
<t tx="ekr.20100212224846.10569">class Specialization(Ancestor):
    TYPE = 'final class'
    top = 'class'

    @others
</t>
<t tx="ekr.20100212224846.10570">def __init__(self, value, _id):
    Ancestor.__init__(self, value)
    self._id = _id
    self.relation = DoNothing()
    self.toto = Toto()

</t>
<t tx="ekr.20100212224846.10571">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10572">""" file suppliermodule.py """

</t>
<t tx="ekr.20100212224846.10573">class NotImplemented(Exception):
    pass

</t>
<t tx="ekr.20100212224846.10574">class Interface:
    @others
</t>
<t tx="ekr.20100212224846.10575">def get_value(self):
    raise NotImplemented()

</t>
<t tx="ekr.20100212224846.10576">def set_value(self, value):
    raise NotImplemented()

</t>
<t tx="ekr.20100212224846.10577">class DoNothing : pass
</t>
<t tx="ekr.20100212224846.10578">@language python
@tabwidth -4
@others
#
</t>
<t tx="ekr.20100212224846.10579"></t>
<t tx="ekr.20100212224846.10580">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10581">from __future__ import absolute_import
import import_package_subpackage_module # fail
print import_package_subpackage_module
</t>
<t tx="ekr.20100212224846.10582">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10583"># -*- coding: iso-8859-1 -*-

import urllib

</t>
<t tx="ekr.20100212224846.10584">class Page(object):
    _urlOpen = staticmethod(urllib.urlopen)

    @others
</t>
<t tx="ekr.20100212224846.10585">def getPage(self, url):
    handle = self._urlOpen(url)
    data = handle.read()
    handle.close()
    return data
</t>
<t tx="ekr.20100212224846.10586">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10587"># pylint: disable-msg=I0011,C0301,W0611
"""I found some of my scripts trigger off an AttributeError in pylint
0.8.1 (with common 0.12.0 and astng 0.13.1).

Traceback (most recent call last):
  File "/usr/bin/pylint", line 4, in ?
    lint.Run(sys.argv[1:])
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 729, in __init__
    linter.check(args)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 412, in check
    self.check_file(filepath, modname, checkers)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 426, in check_file
    astng = self._check_file(filepath, modname, checkers)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 450, in _check_file
    self.check_astng_module(astng, checkers)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 494, in check_astng_module
    self.astng_events(astng, [checker for checker in checkers
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 511, in astng_events
    self.astng_events(child, checkers, _reversed_checkers)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 511, in astng_events
    self.astng_events(child, checkers, _reversed_checkers)
  File "/usr/lib/python2.4/site-packages/pylint/lint.py", line 508, in astng_events
    checker.visit(astng)
  File "/usr/lib/python2.4/site-packages/logilab/astng/utils.py", line 84, in visit
    method(node)
  File "/usr/lib/python2.4/site-packages/pylint/checkers/variables.py", line 295, in visit_import
    self._check_module_attrs(node, module, name_parts[1:])
  File "/usr/lib/python2.4/site-packages/pylint/checkers/variables.py", line 357, in _check_module_attrs
    self.add_message('E0611', args=(name, module.name),
AttributeError: Import instance has no attribute 'name'


You can reproduce it by:
(1) create package structure like the following:

package/
        __init__.py
        subpackage/
                   __init__.py
                   module.py

(2) in package/__init__.py write:

import subpackage

(3) run pylint with a script importing package.subpackage.module.
"""
__revision__ = '$Id: import_package_subpackage_module.py,v 1.1 2005-11-10 15:59:32 syt Exp $'
import package.subpackage.module
</t>
<t tx="ekr.20100212224846.10588"></t>
<t tx="ekr.20100212224846.10589">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10590"># pylint: disable-msg=R0903
"""package's __init__ file"""


import subpackage
</t>
<t tx="ekr.20100212224846.10591"></t>
<t tx="ekr.20100212224846.10592">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10593">"""package.subpackage.module"""
</t>
<t tx="ekr.20100212224846.10594">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.10595">"""package.subpackage"""
</t>
<t tx="ekr.20100212224846.10601"># An example of running this script:

import os

@others

# theDir = r"C:\Python26\Lib\site-packages\logilab_astng-0.19.3-py2.6.egg\logilab\astng"
theDir = r"C:\prog\pylint-0.19.0\checkers"

root = c.p.insertAfter()
root.setHeadString('imported files')
c.selectPosition(root)

try:
    if 0: # import a list of files.
        table = (
            r"C:\Python26\Lib\bdb.py",
            r"C:\Python26\Lib\pdb.py",
        )
        for fn in table:
            importOneFile(fn)
    else:
        # import an entire directory.
        types = (".py",)
        importFiles(theDir,types,recursive=True)
finally:
    c.redraw()

g.es("done",color="blue")
</t>
<t tx="ekr.20100212224846.10602">def importFiles (theDir,theType=None,recursive=False):

    p = c.p

    if not g.os_path_exists(theDir):
        return g.es("directory does not exist: " + theDir)

    kind = '@file' # '@thin' does not work well.
    importDir(theDir,theType,kind,recursive,c.p)
</t>
<t tx="ekr.20100212224846.10603">def importDir (dir,types,kind,recursive,root):

    g.es("dir: " + dir,color="blue")

    try:
        files = os.listdir(dir)
        files2 = [] ; dirs =[]
        for f in files:
            path = g.os_path_join(dir,f)
            if g.os_path_isfile(path):
                name, ext = g.os_path_splitext(f)
                if not types or ext in types:
                    files2.append(path)
            elif recursive:
                dirs.append(path)
        if len(files2) &gt; 0 or len(dirs) &gt; 0:
            child = createLastChildOf(root,dir)
            c.selectVnode(child)
        if len(files2) &gt; 0:
            c.importCommands.importFilesCommand(files2,kind)
        if len(dirs) &gt; 0:
            dirs.sort()
            for dir in dirs:
                importDir(dir,types,kind,recursive,child)
    except:
        g.es("exception in importFiles script")
        g.es_exception()
</t>
<t tx="ekr.20100212224846.10604">def createLastChildOf (p,headline):

    child = p.insertAsLastChild()
    child.initHeadString(headline)
    return child
</t>
<t tx="ekr.20100212224846.10606"></t>
<t tx="ekr.20100212224846.10607"># This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

"""
:author:    Sylvain Thenault
:copyright: 2003-2009 LOGILAB S.A. (Paris, FRANCE)
:contact:   http://www.logilab.fr/ -- mailto:python-projects@logilab.org
:copyright: 2003-2009 Sylvain Thenault
:contact:   mailto:thenault@gmail.com</t>
<t tx="ekr.20100212224846.10608">def _infer_binop(operator, operand1, operand2, context, failures=None):
    if operand1 is YES:
        yield operand1
        return
    try:
        for valnode in operand1.infer_binary_op(operator, operand2, context):
            yield valnode
    except AttributeError:
        try:
            # XXX just suppose if the type implement meth, returned type
            # will be the same
            operand1.getattr(BIN_OP_METHOD[operator])
            yield operand1
        except:
            if failures is None:
                yield YES
            else:
                failures.append(operand1)</t>
<t tx="ekr.20100212224846.10610">BIN_OP_IMPL = {
    '+':  lambda a, b: a + b,
    '-':  lambda a, b: a - b,
    '/':  lambda a, b: a / b,
    '//': lambda a, b: a // b,
    '*':  lambda a, b: a * b,
    '**': lambda a, b: a ** b,
    '%':  lambda a, b: a % b,
    '&amp;':  lambda a, b: a &amp; b,
    '|':  lambda a, b: a | b,
    '^':  lambda a, b: a ^ b,
    '&lt;&lt;': lambda a, b: a &lt;&lt; b,
    '&gt;&gt;': lambda a, b: a &gt;&gt; b,
}
</t>
<t tx="ekr.20100212224846.10611"># unary operations ############################################################

</t>
<t tx="ekr.20100212224846.10612"># assignment ##################################################################

</t>
<t tx="ekr.20100212224846.10613"></t>
<t tx="ekr.20100212224846.10614"></t>
<t tx="ekr.20100212224846.10615"></t>
<t tx="ekr.20100212224846.4235"></t>
<t tx="ekr.20100212224846.9536">@path C:\Python26\Lib\site-packages\logilab_astng-0.19.3-py2.6.egg\logilab\astng
</t>
<t tx="ekr.20100212224846.9537">@language python
@tabwidth -4

"""The ASTNGBuilder makes astng from living object and / or from compiler.ast

With python &gt;= 2.5, the internal _ast module is used instead

The builder is not thread safe and can't be used to parse different sources
at the same time.
"""

@others</t>
<t tx="ekr.20100212224846.9538">__docformat__ = "restructuredtext en"

import sys
from os.path import splitext, basename, dirname, exists, abspath
from inspect import isfunction, ismethod, ismethoddescriptor, isclass, \
     isbuiltin
from inspect import isdatadescriptor

from logilab.common.fileutils import norm_read
from logilab.common.modutils import modpath_from_file

from logilab.astng._exceptions import ASTNGBuildingException
from logilab.astng.rebuilder import RebuildVisitor
from logilab.astng.raw_building import *

try:
    from _ast import PyCF_ONLY_AST
    def parse(string):
        return compile(string, "&lt;string&gt;", 'exec', PyCF_ONLY_AST)
except:
    from compiler import parse
    from logilab.astng import patchcomptransformer

</t>
<t tx="ekr.20100212224846.9539"># ast NG builder

class ASTNGBuilder:
    """provide astng building methods
    """
    @others
</t>
<t tx="ekr.20100212224846.9540">
def __init__(self, manager=None):
    if manager is None:
        from logilab.astng import MANAGER as manager
    self._manager = manager
    self._module = None
    self._file = None
    self._done = None
    self.rebuilder = RebuildVisitor()
    self._dyn_modname_map = {'gtk': 'gtk._gtk'}

</t>
<t tx="ekr.20100212224846.9541">def module_build(self, module, modname=None):
    """build an astng from a living module instance
    """
    node = None
    self._module = module
    path = getattr(module, '__file__', None)
    if path is not None:
        path_, ext = splitext(module.__file__)
        if ext in ('.py', '.pyc', '.pyo') and exists(path_ + '.py'):
            node = self.file_build(path_ + '.py', modname)
    if node is None:
        # this is a built-in module
        # get a partial representation by introspection
        node = self.inspect_build(module, modname=modname, path=path)
    return node

</t>
<t tx="ekr.20100212224846.9542">def inspect_build(self, module, modname=None, path=None):
    """build astng from a living module (i.e. using inspect)
    this is used when there is no python source code available (either
    because it's a built-in module or because the .py is not available)
    """
    self._module = module
    node = build_module(modname or module.__name__, module.__doc__)
    node.file = node.path = path and abspath(path) or path
    if self._manager is not None:
        self._manager._cache[node.file] = self._manager._cache[node.name] = node
    node.package = hasattr(module, '__path__')
    self._done = {}
    self.object_build(node, module)
    return node

</t>
<t tx="ekr.20100212224846.9543">def file_build(self, path, modname=None):
    """build astng from a source code file (i.e. from an ast)

    path is expected to be a python source file
    """
    try:
        data = norm_read(path)
    except IOError, ex:
        msg = 'Unable to load file %r (%s)' % (path, ex)
        raise ASTNGBuildingException(msg)
    self._file = path
    # get module name if necessary, *before modifying sys.path*
    if modname is None:
        try:
            modname = '.'.join(modpath_from_file(path))
        except ImportError:
            modname = splitext(basename(path))[0]
    # build astng representation
    try:
        sys.path.insert(0, dirname(path))
        node = self.string_build(data, modname, path)
        node.file = abspath(path)
    finally:
        self._file = None
        sys.path.pop(0)

    return node

</t>
<t tx="ekr.20100212224846.9544">def string_build(self, data, modname='', path=None):
    """build astng from a source code stream (i.e. from an ast)"""
    return self.ast_build(parse(data + '\n'), modname, path)

</t>
<t tx="ekr.20100212224846.9545">def ast_build(self, node, modname='', path=None):
    """recurse on the ast (soon ng) to add some arguments et method"""
    if path is not None:
        node.file = node.path = abspath(path)
    else:
        node.file = node.path = '&lt;?&gt;'
    if modname.endswith('.__init__'):
        modname = modname[:-9]
        node.package = True
    else:
        node.package = path and path.find('__init__.py') &gt; -1 or False
    node.name = modname
    node.pure_python = True
    if self._manager is not None:
        self._manager._cache[node.file] = node
        if self._file:
            self._manager._cache[abspath(self._file)] = node
    self.rebuilder.walk(node)
    return node

</t>
<t tx="ekr.20100212224846.9546"># astng from living objects
#
# this is actually a really minimal representation, including only Module,
# Function and Class nodes and some others as guessed

def object_build(self, node, obj):
    """recursive method which create a partial ast from real objects
     (only function, class, and method are handled)
    """
    if self._done.has_key(obj):
        return self._done[obj]
    self._done[obj] = node
    for name in dir(obj):
        try:
            member = getattr(obj, name)
        except AttributeError:
            # damned ExtensionClass.Base, I know you're there !
            attach_dummy_node(node, name)
            continue
        if ismethod(member):
            member = member.im_func
        if isfunction(member):
            # verify this is not an imported function
            if member.func_code.co_filename != getattr(self._module, '__file__', None):
                attach_dummy_node(node, name, member)
                continue
            object_build_function(node, member, name)
        elif isbuiltin(member):
            # verify this is not an imported member
            if self._member_module(member) != self._module.__name__:
                imported_member(node, member, name)
                continue
            object_build_methoddescriptor(node, member, name)
        elif isclass(member):
            # verify this is not an imported class
            if self._member_module(member) != self._module.__name__:
                imported_member(node, member, name)
                continue
            if member in self._done:
                class_node = self._done[member]
                if not class_node in node.locals.get(name, ()):
                    node.add_local_node(class_node, name)
            else:
                class_node = object_build_class(node, member, name)
                # recursion
                self.object_build(class_node, member)
        elif ismethoddescriptor(member):
            assert isinstance(member, object)
            object_build_methoddescriptor(node, member, name)
        elif isdatadescriptor(member):
            assert isinstance(member, object)
            object_build_datadescriptor(node, member, name)
        elif isinstance(member, (int, long, float, str, unicode)) or member is None:
            attach_const_node(node, name, member)
        else:
            # create an empty node so that the name is actually defined
            attach_dummy_node(node, name, member)
</t>
<t tx="ekr.20100212224846.9547">def _member_module(self, member):
    modname = getattr(member, '__module__', None)
    return self._dyn_modname_map.get(modname, modname)


</t>
<t tx="ekr.20100212224846.9548">def imported_member(node, member, name):
    """consider a class/builtin member where __module__ != current module name

    check if it's sound valid and then add an import node, else use a dummy node
    """
    # /!\ some classes like ExtensionClass doesn't have a
    # __module__ attribute !
    member_module = getattr(member, '__module__', '__builtin__')
    try:
        getattr(sys.modules[member_module], name)
    except (KeyError, AttributeError):
        attach_dummy_node(node, name, member)
    else:
        attach_import_node(node, member_module, name)

</t>
<t tx="ekr.20100212224846.9549">@language python
@tabwidth -4

"""this module contains a set of functions to handle inference on astng trees
"""

@others</t>
<t tx="ekr.20100212224846.9550">from __future__ import generators

__doctype__ = "restructuredtext en"

from logilab.common.compat import chain

try:
    GeneratorExit # introduced in py2.5
except NameError:
    class GeneratorExit(Exception): pass

from logilab.astng import MANAGER, _nodes as nodes, raw_building
from logilab.astng import ASTNGError, InferenceError, UnresolvableName, \
     NoDefault, NotFoundError, ASTNGBuildingException
from logilab.astng.infutils import YES, Instance, InferenceContext, \
     _infer_stmts, copy_context, path_wrapper, raise_if_nothing_infered
from logilab.astng.protocols import _arguments_infer_argname

_CONST_PROXY = {
    type(None): raw_building.build_class('NoneType'),
    bool: MANAGER.astng_from_class(bool),
    int: MANAGER.astng_from_class(int),
    long: MANAGER.astng_from_class(long),
    float: MANAGER.astng_from_class(float),
    complex: MANAGER.astng_from_class(complex),
    str: MANAGER.astng_from_class(str),
    unicode: MANAGER.astng_from_class(unicode),
    }
_CONST_PROXY[type(None)].parent = _CONST_PROXY[bool].parent
</t>
<t tx="ekr.20100212224846.9551"># Bug fix 1: Set const._proxied instead of const.__proxied.
# Bug fix 2: Don't call getattr implicitly!
#            This is part of getattr logic.
    
def _set_proxied(const):
    const._proxied = _CONST_PROXY[const.value.__class__]
    return const._proxied
    
# Old code:
    
# def _set_proxied(const):
    # if not hasattr(const, '__proxied'):
        # const.__proxied = _CONST_PROXY[const.value.__class__]
    # return const.__proxied


nodes.Const._proxied = property(_set_proxied)

nodes.Const.__bases__ += (Instance,)
</t>
<t tx="ekr.20100212224846.9552">def Const_pytype(self):
    return self._proxied.qname()

nodes.Const.pytype = Const_pytype

nodes.List._proxied = MANAGER.astng_from_class(list)
nodes.List.__bases__ += (Instance,)

nodes.Tuple._proxied = MANAGER.astng_from_class(tuple)
nodes.Tuple.__bases__ += (Instance,)

nodes.Dict.__bases__ += (Instance,)
nodes.Dict._proxied = MANAGER.astng_from_class(dict)
</t>
<t tx="ekr.20100212224846.9553">class CallContext:
    """when infering a function call, this class is used to remember values
    given as argument
    """
    @others
</t>
<t tx="ekr.20100212224846.9554">def __init__(self, args, starargs, dstarargs):
    self.args = []
    self.nargs = {}
    for arg in args:
        if isinstance(arg, nodes.Keyword):
            self.nargs[arg.arg] = arg.value
        else:
            self.args.append(arg)
    self.starargs = starargs
    self.dstarargs = dstarargs

</t>
<t tx="ekr.20100212224846.9555">def infer_argument(self, funcnode, name, context):
    """infer a function argument value according the the call context"""
    # 1. search in named keywords
    try:
        return self.nargs[name].infer(context)
    except KeyError:
        # Function.args.args can be None in astng (means that we don't have
        # information on argnames)
        argindex = funcnode.args.find_argname(name)[0]
        if argindex is not None:
            # 2. first argument of instance/class method
            if argindex == 0 and funcnode.type in ('method', 'classmethod'):
                if context.boundnode is not None:
                    boundnode = context.boundnode
                else:
                    # XXX can do better ?
                    boundnode = funcnode.parent.frame()
                if funcnode.type == 'method':
                    if not isinstance(boundnode, Instance):
                        boundnode = Instance(boundnode)
                    return iter((boundnode,))
                if funcnode.type == 'classmethod':
                    return iter((boundnode,))
            # 2. search arg index
            try:
                return self.args[argindex].infer(context)
            except IndexError:
                pass
            # 3. search in *args (.starargs)
            if self.starargs is not None:
                its = []
                for infered in self.starargs.infer(context):
                    if infered is YES:
                        its.append((YES,))
                        continue
                    try:
                        its.append(infered.getitem(argindex, context).infer(context))
                    except (InferenceError, AttributeError):
                        its.append((YES,))
                    except (IndexError, TypeError):
                        continue
                if its:
                    return chain(*its)
    # 4. XXX search in **kwargs (.dstarargs)
    if self.dstarargs is not None:
        its = []
        for infered in self.dstarargs.infer(context):
            if infered is YES:
                its.append((YES,))
                continue
            try:
                its.append(infered.getitem(name, context).infer(context))
            except (InferenceError, AttributeError):
                its.append((YES,))
            except (IndexError, TypeError):
                continue
        if its:
            return chain(*its)
    # 5. */** argument, (Tuple or Dict)
    if name == funcnode.args.vararg:
        return iter((nodes.const_factory(())))
    if name == funcnode.args.kwarg:
        return iter((nodes.const_factory({})))
    # 6. return default value if any
    try:
        return funcnode.args.default_value(name).infer(context)
    except NoDefault:
        raise InferenceError(name)
</t>
<t tx="ekr.20100212224846.9556">def infer_default(self, context=None):
    """we don't know how to resolve a statement by default"""
    raise InferenceError(self.__class__.__name__)

for cls in nodes.ALL_NODES:
    cls.infer = infer_default
</t>
<t tx="ekr.20100212224846.9557">def infer_end(self, context=None):
    """inference's end for node such as Module, Class, Function, Const...
    """
    yield self

nodes.Module.infer = infer_end
nodes.Class.infer = infer_end
nodes.Function.infer = infer_end
nodes.Lambda.infer = infer_end
nodes.Const.infer = infer_end
nodes.List.infer = infer_end
nodes.Tuple.infer = infer_end
nodes.Dict.infer = infer_end
</t>
<t tx="ekr.20100212224846.9558">def infer_name(self, context=None):
    """infer a Name: use name lookup rules"""
    frame, stmts = self.lookup(self.name)
    if not stmts:
        raise UnresolvableName(self.name)
    context = context.clone()
    context.lookupname = self.name
    #context.boundnode = None
    return _infer_stmts(stmts, context, frame)
    
nodes.Name.infer = path_wrapper(infer_name)
nodes.AssName.infer_lhs = infer_name # won't work with a path wrapper

</t>
<t tx="ekr.20100212224846.9559">def infer_callfunc(self, context=None):
    """infer a CallFunc node by trying to guess what the function returns"""
    callcontext = context.clone()
    callcontext.callcontext = CallContext(self.args, self.starargs, self.kwargs)
    callcontext.boundnode = None
    for callee in self.func.infer(context):
        if callee is YES:
            yield callee
            continue
        try:
            if hasattr(callee, 'infer_call_result'):
                for infered in callee.infer_call_result(self, callcontext):
                    yield infered
        except InferenceError:
            ## XXX log error ?
            continue
            
nodes.CallFunc.infer = path_wrapper(raise_if_nothing_infered(infer_callfunc))
</t>
<t tx="ekr.20100212224846.9560">def infer_import(self, context=None, asname=True):
    """infer an Import node: return the imported module/object"""
    name = context.lookupname
    if name is None:
        raise InferenceError()
    if asname:
        yield self.do_import_module(self.real_name(name))
    else:
        yield self.do_import_module(name)

nodes.Import.infer = path_wrapper(infer_import)
</t>
<t tx="ekr.20100212224846.9561">def infer_name_module(self, name):
    context = InferenceContext(self)
    context.lookupname = name
    return self.infer(context, asname=False)

nodes.Import.infer_name_module = infer_name_module
</t>
<t tx="ekr.20100212224846.9562">def infer_from(self, context=None, asname=True):
    """infer a From nodes: return the imported module/object"""
    name = context.lookupname
    if name is None:
        raise InferenceError()
    if asname:
        name = self.real_name(name)
    module = self.do_import_module(self.modname)
    try:
        context = copy_context(context)
        context.lookupname = name
        return _infer_stmts(module.getattr(name), context)
    except NotFoundError:
        raise InferenceError(name)

nodes.From.infer = path_wrapper(infer_from)


</t>
<t tx="ekr.20100212224846.9563">def infer_getattr(self, context=None):
    """infer a Getattr node by using getattr on the associated object"""
    #context = context.clone()
    for owner in self.expr.infer(context):
        if owner is YES:
            yield owner
            continue
        try:
            context.boundnode = owner
            for obj in owner.igetattr(self.attrname, context):
                yield obj
            context.boundnode = None
        except (NotFoundError, InferenceError):
            context.boundnode = None
        except AttributeError:
            # XXX method / function
            context.boundnode = None
            
nodes.Getattr.infer = path_wrapper(raise_if_nothing_infered(infer_getattr))
nodes.AssAttr.infer_lhs = raise_if_nothing_infered(infer_getattr) # # won't work with a path wrapper
</t>
<t tx="ekr.20100212224846.9564">def infer_global(self, context=None):
    if context.lookupname is None:
        raise InferenceError()
    try:
        return _infer_stmts(self.root().getattr(context.lookupname), context)
    except NotFoundError:
        raise InferenceError()

nodes.Global.infer = path_wrapper(infer_global)
</t>
<t tx="ekr.20100212224846.9565">def infer_subscript(self, context=None):
    """infer simple subscription such as [1,2,3][0] or (1,2,3)[-1]"""
    if isinstance(self.slice, nodes.Index):
        index = self.slice.value.infer(context).next()
        if index is YES:
            yield YES
            return
        try:
            # suppose it's a Tuple/List node (attribute error else)
            assigned = self.value.getitem(index.value, context)
        except AttributeError:
            raise InferenceError()
        except (IndexError, TypeError):
            yield YES
            return
        for infered in assigned.infer(context):
            yield infered
    else:
        raise InferenceError()
        
nodes.Subscript.infer = path_wrapper(infer_subscript)
</t>
<t tx="ekr.20100212224846.9566">UNARY_OP_METHOD = {'+':  '__pos__',
                 '-':  '__neg__',
                 'not': None, # XXX not '__nonzero__'
                 }

def infer_unaryop(self, context=None):
    for operand in self.operand.infer(context):
        try:
            yield operand.infer_unary_op(self.op)
        except TypeError:
            continue
        except AttributeError:
            meth = UNARY_OP_METHOD[self.op]
            if meth is None:
                yield YES
            else:
                try:
                    # XXX just suppose if the type implement meth, returned type
                    # will be the same
                    operand.getattr(meth)
                    yield operand
                except GeneratorExit:
                    raise
                except:
                    yield YES

nodes.UnaryOp.infer = path_wrapper(infer_unaryop)
</t>
<t tx="ekr.20100212224846.9568">BIN_OP_METHOD = {'+':  '__add__',
                 '-':  '__sub__',
                 '/':  '__div__',
                 '//': '__floordiv__',
                 '*':  '__mul__',
                 '**': '__power__',
                 '%':  '__mod__',
                 '&amp;':  '__and__',
                 '|':  '__or__',
                 '^':  '__xor__',
                 '&lt;&lt;': '__lshift__',
                 '&gt;&gt;': '__rshift__',
                 }

def infer_binop(self, context=None):
    failures = []
    for lhs in self.left.infer(context):
        for val in _infer_binop(self.op, lhs, self.right, context, failures):
            yield val
    for lhs in failures:
        for rhs in self.right.infer(context):
            for val in _infer_binop(self.op, rhs, lhs, context):
                yield val

nodes.BinOp.infer = path_wrapper(infer_binop)
</t>
<t tx="ekr.20100212224846.9569">def infer_arguments(self, context=None):
    name = context.lookupname
    if name is None:
        raise InferenceError()
    return _arguments_infer_argname(self, name, context)

nodes.Arguments.infer = infer_arguments
</t>
<t tx="ekr.20100212224846.9570">def infer_ass(self, context=None):
    """infer a AssName/AssAttr: need to inspect the RHS part of the
    assign node
    """
    stmt = self.statement()
    if isinstance(stmt, nodes.AugAssign):
        return stmt.infer(context)
    stmts = list(self.assigned_stmts(context=context))
    return _infer_stmts(stmts, context)

nodes.AssName.infer = path_wrapper(infer_ass)
nodes.AssAttr.infer = path_wrapper(infer_ass)
</t>
<t tx="ekr.20100212224846.9571">def infer_augassign(self, context=None):
    failures = []
    for lhs in self.target.infer_lhs(context):
        for val in _infer_binop(self.op, lhs, self.value, context, failures):
            yield val
    for lhs in failures:
        for rhs in self.value.infer(context):
            for val in _infer_binop(self.op, rhs, lhs, context):
                yield val

nodes.AugAssign.infer = path_wrapper(infer_augassign)
</t>
<t tx="ekr.20100212224846.9572">

# no infer method on DelName and DelAttr (expected InferenceError)


def infer_empty_node(self, context=None):
    if not self.has_underlying_object():
        yield YES
    else:
        try:
            for infered in MANAGER.infer_astng_from_something(self.object,
                                                              context=context):
                yield infered
        except ASTNGError:
            yield YES

nodes.EmptyNode.infer = path_wrapper(infer_empty_node)
</t>
<t tx="ekr.20100212224846.9573">@language python
@tabwidth -4

"""Inference utilities
"""

@others</t>
<t tx="ekr.20100212224846.9574">from __future__ import generators

__doctype__ = "restructuredtext en"

from logilab.common.compat import chain, imap

from logilab.astng._exceptions import InferenceError, NotFoundError, UnresolvableName
from logilab.astng._nodes import Proxy_, List, Tuple, Function, If, TryExcept


</t>
<t tx="ekr.20100212224846.9575">class Proxy(Proxy_):
    """a simple proxy object"""
    _proxied = None

    @others
</t>
<t tx="ekr.20100212224846.9576">def __init__(self, proxied=None):
    if proxied is not None:
        self._proxied = proxied

</t>
<t tx="ekr.20100212224846.9577">def __getattr__(self, name):
    if name == '_proxied':
        return getattr(self.__class__, '_proxied')
    if name in self.__dict__:
        return self.__dict__[name]
    return getattr(self._proxied, name)

</t>
<t tx="ekr.20100212224846.9578">def infer(self, context=None):
    yield self


</t>
<t tx="ekr.20100212224846.9579">class InferenceContext(object):

    __slots__ = ('startingfrom', 'path', 'lookupname', 'callcontext', 'boundnode')

    @others
</t>
<t tx="ekr.20100212224846.9580">def __init__(self, node=None, path=None):
    self.startingfrom = node # XXX useful ?
    if path is None:
        self.path = []
    else:
        self.path = path
    self.lookupname = None
    self.callcontext = None
    self.boundnode = None

</t>
<t tx="ekr.20100212224846.9581">def push(self, node):
    name = self.lookupname
    if (node, name) in self.path:
        raise StopIteration()
    self.path.append( (node, name) )

</t>
<t tx="ekr.20100212224846.9582">def pop(self):
    return self.path.pop()

</t>
<t tx="ekr.20100212224846.9583">def clone(self):
    # XXX copy lookupname/callcontext ?
    clone = InferenceContext(self.startingfrom, self.path)
    clone.callcontext = self.callcontext
    clone.boundnode = self.boundnode
    return clone


</t>
<t tx="ekr.20100212224846.9584">def are_exclusive(stmt1, stmt2, exceptions=None):
    """return true if the two given statements are mutually exclusive

    `exceptions` may be a list of exception names. If specified, discard If
    branches and check one of the statement is in an exception handler catching
    one of the given exceptions.

    algorithm :
     1) index stmt1's parents
     2) climb among stmt2's parents until we find a common parent
     3) if the common parent is a If or TryExcept statement, look if nodes are
        in exclusive branchs
    """
    # index stmt1's parents
    stmt1_parents = {}
    children = {}
    node = stmt1.parent
    previous = stmt1
    while node:
        stmt1_parents[node] = 1
        children[node] = previous
        previous = node
        node = node.parent
    # climb among stmt2's parents until we find a common parent
    node = stmt2.parent
    previous = stmt2
    while node:
        if stmt1_parents.has_key(node):
            # if the common parent is a If or TryExcept statement, look if
            # nodes are in exclusive branchs
            if isinstance(node, If) and exceptions is None:
                if (node.locate_child(previous)[1]
                    is not node.locate_child(children[node])[1]):
                    return True
            elif isinstance(node, TryExcept):
                c2attr, c2node = node.locate_child(previous)
                c1attr, c1node = node.locate_child(children[node])
                if c1node is not c2node:
                    if ((c2attr == 'body' and c1attr == 'handlers' and children[node].catch(exceptions)) or
                        (c2attr == 'handlers' and c1attr == 'body' and previous.catch(exceptions)) or
                        (c2attr == 'handlers' and c1attr == 'orelse') or
                        (c2attr == 'orelse' and c1attr == 'handlers')):
                        return True
                elif c2attr == 'handlers' and c1attr == 'handlers':
                    return previous is not children[node]
            return False
        previous = node
        node = node.parent
    return False


</t>
<t tx="ekr.20100212224846.9585">def unpack_infer(stmt, context=None):
    """return an iterator on nodes infered by the given statement if the infered
    value is a list or a tuple, recurse on it to get values infered by its
    content
    """
    if isinstance(stmt, (List, Tuple)):
        # XXX loosing context
        return chain(*imap(unpack_infer, stmt.elts))
    infered = stmt.infer(context).next()
    if infered is stmt:
        return iter( (stmt,) )
    return chain(*imap(unpack_infer, stmt.infer(context)))

</t>
<t tx="ekr.20100212224846.9586">def copy_context(context):
    if context is not None:
        return context.clone()
    else:
        return InferenceContext()

</t>
<t tx="ekr.20100212224846.9587">def _infer_stmts(stmts, context, frame=None):
    """return an iterator on statements infered by each statement in &lt;stmts&gt;
    """
    stmt = None
    infered = False
    if context is not None:
        name = context.lookupname
        context = context.clone()
    else:
        name = None
        context = InferenceContext()
    for stmt in stmts:
        if stmt is YES:
            yield stmt
            infered = True
            continue
        context.lookupname = stmt._infer_name(frame, name)
        try:
            for infered in stmt.infer(context):
                yield infered
                infered = True
        except UnresolvableName:
            continue
        except InferenceError:
            yield YES
            infered = True
    if not infered:
        raise InferenceError(str(stmt))
</t>
<t tx="ekr.20100212224846.9588">class _Yes(object):
    """a yes object"""
    @others
</t>
<t tx="ekr.20100212224846.9589">def __repr__(self):
    return 'YES'
</t>
<t tx="ekr.20100212224846.9590">def __getattribute__(self, name):
    if name.startswith('__') and name.endswith('__'):
        # to avoid inspection pb
        return super(_Yes, self).__getattribute__(name)
    return self
</t>
<t tx="ekr.20100212224846.9591">def __call__(self, *args, **kwargs):
    return self


</t>
<t tx="ekr.20100212224846.9592"># decorators ##################################################################

def path_wrapper(func):
    """return the given infer function wrapped to handle the path"""
    def wrapped(node, context=None, _func=func, **kwargs):
        """wrapper function handling context"""
        if context is None:
            context = InferenceContext(node)
        context.push(node)
        yielded = []
        try:
            for res in _func(node, context, **kwargs):
                # unproxy only true instance, not const, tuple, dict...
                if res.__class__ is Instance:
                    ares = res._proxied
                else:
                    ares = res
                if not ares in yielded:
                    yield res
                    yielded.append(ares)
            context.pop()
        except:
            context.pop()
            raise
    return wrapped

</t>
<t tx="ekr.20100212224846.9593">def yes_if_nothing_infered(func):
    def wrapper(*args, **kwargs):
        infered = False
        for node in func(*args, **kwargs):
            infered = True
            yield node
        if not infered:
            yield YES
    return wrapper

</t>
<t tx="ekr.20100212224846.9594">def raise_if_nothing_infered(func):
    def wrapper(*args, **kwargs):
        infered = False
        for node in func(*args, **kwargs):
            infered = True
            yield node
        if not infered:
            raise InferenceError()
    return wrapper


</t>
<t tx="ekr.20100212224846.9595"># special inference objects (e.g. may be returned as nodes by .infer()) #######

YES = _Yes()


class Instance(Proxy):
    """a special node representing a class instance"""
    @others
</t>
<t tx="ekr.20100212224846.9596">def getattr(self, name, context=None, lookupclass=True):
    try:
        values = self._proxied.instance_attr(name, context)
    except NotFoundError:
        if name == '__class__':
            return [self._proxied]
        if lookupclass:
            # class attributes not available through the instance
            # unless they are explicitly defined
            if name in ('__name__', '__bases__', '__mro__'):
                return self._proxied.local_attr(name)
            return self._proxied.getattr(name, context)
        raise NotFoundError(name)
    # since we've no context information, return matching class members as
    # well
    if lookupclass:
        try:
            return values + self._proxied.getattr(name, context)
        except NotFoundError:
            pass
    return values

</t>
<t tx="ekr.20100212224846.9597">def igetattr(self, name, context=None):
    """infered getattr"""
    try:
        # XXX frame should be self._proxied, or not ?
        return _infer_stmts(
            self._wrap_attr(self.getattr(name, context, lookupclass=False), context),
                            context, frame=self)
    except NotFoundError:
        try:
            # fallback to class'igetattr since it has some logic to handle
            # descriptors
            return self._wrap_attr(self._proxied.igetattr(name, context), context)
        except NotFoundError:
            raise InferenceError(name)

</t>
<t tx="ekr.20100212224846.9598">def _wrap_attr(self, attrs, context=None):
    """wrap bound methods of attrs in a InstanceMethod proxies"""
    for attr in attrs:
        if isinstance(attr, UnboundMethod):
            if '__builtin__.property' in attr.decoratornames():
                for infered in attr.infer_call_result(self, context):
                    yield infered
            else:
                yield BoundMethod(attr, self)
        else:
            yield attr

</t>
<t tx="ekr.20100212224846.9599">def infer_call_result(self, caller, context=None):
    """infer what's a class instance is returning when called"""
    infered = False
    for node in self._proxied.igetattr('__call__', context):
        for res in node.infer_call_result(caller, context):
            infered = True
            yield res
    if not infered:
        raise InferenceError()

</t>
<t tx="ekr.20100212224846.9600">def __repr__(self):
    return '&lt;Instance of %s.%s at 0x%s&gt;' % (self._proxied.root().name,
                                            self._proxied.name,
                                            id(self))
</t>
<t tx="ekr.20100212224846.9601">def __str__(self):
    return 'Instance of %s.%s' % (self._proxied.root().name,
                                  self._proxied.name)

</t>
<t tx="ekr.20100212224846.9602">def callable(self):
    try:
        self._proxied.getattr('__call__')
        return True
    except NotFoundError:
        return False

</t>
<t tx="ekr.20100212224846.9603">def pytype(self):
    return self._proxied.qname()

</t>
<t tx="ekr.20100212224846.9604">def display_type(self):
    return 'Instance of'


</t>
<t tx="ekr.20100212224846.9605">class UnboundMethod(Proxy):
    """a special node representing a method not bound to an instance"""
    @others
</t>
<t tx="ekr.20100212224846.9606">def __repr__(self):
    frame = self._proxied.parent.frame()
    return '&lt;%s %s of %s at 0x%s' % (self.__class__.__name__,
                                     self._proxied.name,
                                     frame.qname(), id(self))

</t>
<t tx="ekr.20100212224846.9607">def is_bound(self):
    return False

</t>
<t tx="ekr.20100212224846.9608">def getattr(self, name, context=None):
    if name == 'im_func':
        return [self._proxied]
    return super(UnboundMethod, self).getattr(name, context)

</t>
<t tx="ekr.20100212224846.9609">def igetattr(self, name, context=None):
    if name == 'im_func':
        return iter((self._proxied,))
    return super(UnboundMethod, self).igetattr(name, context)


</t>
<t tx="ekr.20100212224846.9610">class BoundMethod(UnboundMethod):
    """a special node representing a method bound to an instance"""
    @others
</t>
<t tx="ekr.20100212224846.9611">def __init__(self,  proxy, bound):
    UnboundMethod.__init__(self, proxy)
    self.bound = bound

</t>
<t tx="ekr.20100212224846.9612">def is_bound(self):
    return True

</t>
<t tx="ekr.20100212224846.9613">def infer_call_result(self, caller, context):
    context = context.clone()
    context.boundnode = self.bound
    return self._proxied.infer_call_result(caller, context)


</t>
<t tx="ekr.20100212224846.9614">class Generator(Proxy):
    """a special node representing a generator"""
    @others
</t>
<t tx="ekr.20100212224846.9615">def callable(self):
    return True

</t>
<t tx="ekr.20100212224846.9616">def pytype(self):
    return '__builtin__.generator'

</t>
<t tx="ekr.20100212224846.9617">def display_type(self):
    return 'Generator'

</t>
<t tx="ekr.20100212224846.9618">@language python
@tabwidth -4

"""visitor doing some postprocessing on the astng tree.
Try to resolve definitions (namespace) dictionary, relationship...

This module has been imported from pyreverse
"""

@others</t>
<t tx="ekr.20100212224846.9619">

__docformat__ = "restructuredtext en"

from os.path import dirname

from logilab.common.modutils import get_module_part, is_relative, \
     is_standard_module

from logilab import astng
from logilab.astng import InferenceError
from logilab.astng.utils import LocalsVisitor

</t>
<t tx="ekr.20100212224846.9620">class IdGeneratorMixIn:
    """
    Mixin adding the ability to generate integer uid
    """
    @others
</t>
<t tx="ekr.20100212224846.9621">def __init__(self, start_value=0):
    self.id_count = start_value

</t>
<t tx="ekr.20100212224846.9622">def init_counter(self, start_value=0):
    """init the id counter
    """
    self.id_count = start_value

</t>
<t tx="ekr.20100212224846.9623">def generate_id(self):
    """generate a new identifer
    """
    self.id_count += 1
    return self.id_count


</t>
<t tx="ekr.20100212224846.9624">class Linker(IdGeneratorMixIn, LocalsVisitor):
    """
    walk on the project tree and resolve relationships.

    According to options the following attributes may be added to visited nodes:

    * uid,
      a unique identifier for the node (on astng.Project, astng.Module,
      astng.Class and astng.locals_type). Only if the linker has been instantiated
      with tag=True parameter (False by default).

    * Function
      a mapping from locals names to their bounded value, which may be a
      constant like a string or an integer, or an astng node (on astng.Module,
      astng.Class and astng.Function).

    * instance_attrs_type
      as locals_type but for klass member attributes (only on astng.Class)

    * implements,
      list of implemented interface _objects_ (only on astng.Class nodes)
    """
    @others
</t>
<t tx="ekr.20100212224846.9625">
def __init__(self, project, inherited_interfaces=0, tag=False):
    IdGeneratorMixIn.__init__(self)
    LocalsVisitor.__init__(self)
    # take inherited interface in consideration or not
    self.inherited_interfaces = inherited_interfaces
    # tag nodes or not
    self.tag = tag
    # visited project
    self.project = project


</t>
<t tx="ekr.20100212224846.9626">def visit_project(self, node):
    """visit an astng.Project node

     * optionaly tag the node wth a unique id
    """
    if self.tag:
        node.uid = self.generate_id()
    for module in node.modules:
        self.visit(module)

</t>
<t tx="ekr.20100212224846.9627">def visit_package(self, node):
    """visit an astng.Package node

     * optionaly tag the node wth a unique id
    """
    if self.tag:
        node.uid = self.generate_id()
    for subelmt in node.values():
        self.visit(subelmt)

</t>
<t tx="ekr.20100212224846.9628">def visit_module(self, node):
    """visit an astng.Module node

     * set the locals_type mapping
     * set the depends mapping
     * optionaly tag the node wth a unique id
    """
    if hasattr(node, 'locals_type'):
        return
    node.locals_type = {}
    node.depends = []
    if self.tag:
        node.uid = self.generate_id()

</t>
<t tx="ekr.20100212224846.9629">def visit_class(self, node):
    """visit an astng.Class node

     * set the locals_type and instance_attrs_type mappings
     * set the implements list and build it
     * optionaly tag the node wth a unique id
    """
    if hasattr(node, 'locals_type'):
        return
    node.locals_type = {}
    if self.tag:
        node.uid = self.generate_id()
    # resolve ancestors
    for baseobj in node.ancestors(recurs=False):
        specializations = getattr(baseobj, 'specializations', [])
        specializations.append(node)
        baseobj.specializations = specializations
    # resolve instance attributes
    node.instance_attrs_type = {}
    for assattrs in node.instance_attrs.values():
        for assattr in assattrs:
            self.handle_assattr_type(assattr, node)
    # resolve implemented interface
    try:
        node.implements = list(node.interfaces(self.inherited_interfaces))
    except InferenceError:
        node.implements = ()

</t>
<t tx="ekr.20100212224846.9630">def visit_function(self, node):
    """visit an astng.Function node

     * set the locals_type mapping
     * optionaly tag the node wth a unique id
    """
    if hasattr(node, 'locals_type'):
        return
    node.locals_type = {}
    if self.tag:
        node.uid = self.generate_id()

</t>
<t tx="ekr.20100212224846.9631">link_project = visit_project
link_module = visit_module
link_class = visit_class
link_function = visit_function

def visit_assname(self, node):
    """visit an astng.AssName node

    handle locals_type
    """
    frame = node.frame()
    try:
        values = list(node.infer())
        try:
            already_infered = frame.locals_type[node.name]
            for valnode in values:
                if not valnode in already_infered:
                    already_infered.append(valnode)
        except KeyError:
            frame.locals_type[node.name] = values
    except astng.InferenceError:
        pass

</t>
<t tx="ekr.20100212224846.9632">def handle_assattr_type(self, node, parent):
    """handle an astng.AssAttr node

    handle instance_attrs_type
    """
    try:
        values = list(node.infer())
        try:
            already_infered = parent.instance_attrs_type[node.attrname]
            for valnode in values:
                if not valnode in already_infered:
                    already_infered.append(valnode)
        except KeyError:
            parent.instance_attrs_type[node.attrname] = values
    except astng.InferenceError:
        pass

</t>
<t tx="ekr.20100212224846.9633">def visit_import(self, node):
    """visit an astng.Import node

    resolve module dependencies
    """
    context_file = node.root().file
    for name in node.names:
        relative = is_relative(name[0], context_file)
        self._imported_module(node, name[0], relative)


</t>
<t tx="ekr.20100212224846.9634">def visit_from(self, node):
    """visit an astng.From node

    resolve module dependencies
    """
    basename = node.modname
    context_file = node.root().file
    if context_file is not None:
        relative = is_relative(basename, context_file)
    else:
        relative = False
    for name in node.names:
        if name[0] == '*':
            continue
        # analyze dependencies
        fullname = '%s.%s' % (basename, name[0])
        if fullname.find('.') &gt; -1:
            try:
                # XXX: don't use get_module_part, missing package precedence
                fullname = get_module_part(fullname)
            except ImportError:
                continue
        if fullname != basename:
            self._imported_module(node, fullname, relative)


</t>
<t tx="ekr.20100212224846.9635">def compute_module(self, context_name, mod_path):
    """return true if the module should be added to dependencies"""
    package_dir = dirname(self.project.path)
    if context_name == mod_path:
        return 0
    elif is_standard_module(mod_path, (package_dir,)):
        return 1
    return 0

</t>
<t tx="ekr.20100212224846.9636"># protected methods ########################################################

def _imported_module(self, node, mod_path, relative):
    """notify an imported module, used to analyze dependencies
    """
    module = node.root()
    context_name = module.name
    if relative:
        mod_path = '%s.%s' % ('.'.join(context_name.split('.')[:-1]),
                              mod_path)
    if self.compute_module(context_name, mod_path):
        # handle dependencies
        if not hasattr(module, 'depends'):
            module.depends = []
        mod_paths = module.depends
        if not mod_path in mod_paths:
            mod_paths.append(mod_path)
</t>
<t tx="ekr.20100212224846.9637">@language python
@tabwidth -4

"""name lookup methods, available on Name and scoped nodes (Module, Class,
Function, Lambda, GenExpr...):

* .lookup(name)
* .ilookup(name)

Be careful, lookup is internal and returns a tuple (scope, [stmts]), while
ilookup returns an iterator on infered values.
"""

@others</t>
<t tx="ekr.20100212224846.9638">

__docformat__ = "restructuredtext en"

import __builtin__

from logilab.astng import MANAGER, NotFoundError
from logilab.astng import _nodes as nodes
from logilab.astng.infutils import are_exclusive, copy_context, _infer_stmts


</t>
<t tx="ekr.20100212224846.9639">class LookupMixIn(object):
    """Mixin looking up a name in the right scope
    """
    @others
</t>
<t tx="ekr.20100212224846.9640">
def lookup(self, name):
    """lookup a variable name

    return the scope node and the list of assignments associated to the given
    name according to the scope where it has been found (locals, globals or
    builtin)

    The lookup is starting from self's scope. If self is not a frame itself and
    the name is found in the inner frame locals, statements will be filtered
    to remove ignorable statements according to self's location
    """
    return self.scope().scope_lookup(self, name)

</t>
<t tx="ekr.20100212224846.9641">def ilookup(self, name, context=None):
    """infered lookup

    return an iterator on infered values of the statements returned by
    the lookup method
    """
    frame, stmts = self.lookup(name)
    context = copy_context(context)
    context.lookupname = name
    return _infer_stmts(stmts, context, frame)


</t>
<t tx="ekr.20100212224846.9642">def _filter_stmts(self, stmts, frame, offset):
    """filter statements to remove ignorable statements.

    If self is not a frame itself and the name is found in the inner
    frame locals, statements will be filtered to remove ignorable
    statements according to self's location
    """
    # if offset == -1, my actual frame is not the inner frame but its parent
    #
    # class A(B): pass
    #
    # we need this to resolve B correctly
    if offset == -1:
        myframe = self.frame().parent.frame()
    else:
        myframe = self.frame()
    if not myframe is frame or self is frame:
        return stmts
    mystmt = self.statement()
    # line filtering if we are in the same frame
    #
    # take care node may be missing lineno information (this is the case for
    # nodes inserted for living objects)
    if myframe is frame and mystmt.fromlineno is not None:
        assert mystmt.fromlineno is not None, mystmt
        mylineno = mystmt.fromlineno + offset
    else:
        # disabling lineno filtering
        mylineno = 0
    _stmts = []
    _stmt_parents = []
    for node in stmts:
        stmt = node.statement()
        # line filtering is on and we have reached our location, break
        if mylineno &gt; 0 and stmt.fromlineno &gt; mylineno:
            break
        if isinstance(node, nodes.Class) and self in node.bases:
            break
        assert hasattr(node, 'ass_type'), (node, node.scope(),
                                           node.scope().locals)
        ass_type = node.ass_type()
        if ass_type is mystmt and not isinstance(ass_type, (nodes.Class,
                nodes.Function, nodes.Import, nodes.From, nodes.Lambda)):
            if not isinstance(ass_type, nodes.Comprehension):
                break
            if isinstance(self, (nodes.Const, nodes.Name)):
                _stmts = [self]
                break
        elif ass_type.statement() is mystmt:
            # original node's statement is the assignment, only keeps
            # current node (gen exp, list comp)
            _stmts = [node]
            break        
        optional_assign = isinstance(ass_type, nodes.LOOP_SCOPES)
        if optional_assign and ass_type.parent_of(self):
            # we are inside a loop, loop var assigment is hidding previous
            # assigment
            _stmts = [node]
            _stmt_parents = [stmt.parent]
            continue
        # XXX comment various branches below!!!
        try:
            pindex = _stmt_parents.index(stmt.parent)
        except ValueError:
            pass
        else:
            # we got a parent index, this means the currently visited node
            # is at the same block level as a previously visited node
            if _stmts[pindex].ass_type().parent_of(ass_type):
                # both statements are not at the same block level
                continue
            # if currently visited node is following previously considered
            # assignement and both are not exclusive, we can drop the
            # previous one. For instance in the following code ::
            #
            #   if a:
            #     x = 1
            #   else:
            #     x = 2
            #   print x
            #
            # we can't remove neither x = 1 nor x = 2 when looking for 'x'
            # of 'print x'; while in the following ::
            #
            #   x = 1
            #   x = 2
            #   print x
            #
            # we can remove x = 1 when we see x = 2
            #
            # moreover, on loop assignment types, assignment won't
            # necessarily be done if the loop has no iteration, so we don't
            # want to clear previous assigments if any (hence the test on
            # optional_assign)
            if not (optional_assign or are_exclusive(_stmts[pindex], node)):
                del _stmt_parents[pindex]
                del _stmts[pindex]
        if isinstance(node, nodes.AssName):
            if not optional_assign and stmt.parent is mystmt.parent:
                _stmts = []
                _stmt_parents = []
        elif isinstance(node, nodes.DelName):
            _stmts = []
            _stmt_parents = []
            continue
        if not are_exclusive(self, node):
            _stmts.append(node)
            _stmt_parents.append(stmt.parent)
    return _stmts


</t>
<t tx="ekr.20100212224846.9643">def builtin_lookup(name):
    """lookup a name into the builtin module
    return the list of matching statements and the astng for the builtin
    module
    """
    builtinastng = MANAGER.astng_from_module(__builtin__)
    if name == '__dict__':
        return builtinastng, ()
    try:
        stmts = builtinastng.locals[name]
    except KeyError:
        stmts = ()
    return builtinastng, stmts


</t>
<t tx="ekr.20100212224846.9644">class LocalsDictMixIn(object):
    """ this class provides locals handling common to Module, Function
    and Class nodes, including a dict like interface for direct access
    to locals information

    /!\ this class should not be used directly /!\ it's
    only used as a methods and attribute container, and update the
    original class from the compiler.ast module using its dictionary
    (see below the class definition)
    """

    # attributes below are set by the builder module or by raw factories

    # dictionary of locals with name as key and node defining the local as
    # value
    locals = None

    @others
    __contains__ = has_key


</t>
<t tx="ekr.20100212224846.9645">def qname(self):
    """return the 'qualified' name of the node, eg module.name,
    module.class.name ...
    """
    if self.parent is None:
        return self.name
    return '%s.%s' % (self.parent.frame().qname(), self.name)

</t>
<t tx="ekr.20100212224846.9646">def frame(self):
    """return the first parent frame node (i.e. Module, Function or Class)
    """
    return self

</t>
<t tx="ekr.20100212224846.9647">def scope(self):
    """return the first node defining a new scope (i.e. Module,
    Function, Class, Lambda but also GenExpr)
    """
    return self


</t>
<t tx="ekr.20100212224846.9648">def _scope_lookup(self, node, name, offset=0):
    """XXX method for interfacing the scope lookup"""
    try:
        stmts = node._filter_stmts(self.locals[name], self, offset)
    except KeyError:
        stmts = ()
    if stmts:
        return self, stmts
    if self.parent: # i.e. not Module
        # nested scope: if parent scope is a function, that's fine
        # else jump to the module
        pscope = self.parent.scope()
        if not isinstance(pscope, nodes.Function):
            pscope = pscope.root()
        return pscope.scope_lookup(node, name)
    return builtin_lookup(name) # Module



</t>
<t tx="ekr.20100212224846.9649">def set_local(self, name, stmt):
    """define &lt;name&gt; in locals (&lt;stmt&gt; is the node defining the name)
    if the node is a Module node (i.e. has globals), add the name to
    globals

    if the name is already defined, ignore it
    """
    assert self.locals is not None, (self, id(self))
    #assert not stmt in self.locals.get(name, ()), (self, stmt)
    self.locals.setdefault(name, []).append(stmt)

</t>
<t tx="ekr.20100212224846.9650">__setitem__ = set_local

def _append_node(self, child):
    """append a child, linking it in the tree"""
    self.body.append(child)
    child.parent = self

</t>
<t tx="ekr.20100212224846.9651">def add_local_node(self, child_node, name=None):
    """append a child which should alter locals to the given node"""
    if name != '__class__':
        # add __class__ node as a child will cause infinite recursion later!
        self._append_node(child_node)
    self.set_local(name or child_node.name, child_node)


</t>
<t tx="ekr.20100212224846.9652">def __getitem__(self, item):
    """method from the `dict` interface returning the first node
    associated with the given name in the locals dictionary

    :type item: str
    :param item: the name of the locally defined object
    :raises KeyError: if the name is not defined
    """
    return self.locals[item][0]

</t>
<t tx="ekr.20100212224846.9653">def __iter__(self):
    """method from the `dict` interface returning an iterator on
    `self.keys()`
    """
    return iter(self.keys())

</t>
<t tx="ekr.20100212224846.9654">def keys(self):
    """method from the `dict` interface returning a tuple containing
    locally defined names
    """
    return self.locals.keys()

</t>
<t tx="ekr.20100212224846.9655">def values(self):
    """method from the `dict` interface returning a tuple containing
    locally defined nodes which are instance of `Function` or `Class`
    """
    return [self[key] for key in self.keys()]

</t>
<t tx="ekr.20100212224846.9656">def items(self):
    """method from the `dict` interface returning a list of tuple
    containing each locally defined name with its associated node,
    which is an instance of `Function` or `Class`
    """
    return zip(self.keys(), self.values())

</t>
<t tx="ekr.20100212224846.9657">def has_key(self, name):
    """method from the `dict` interface returning True if the given
    name is defined in the locals dictionary
    """
    return self.locals.has_key(name)

</t>
<t tx="ekr.20100212224846.9658">@language python
@tabwidth -4


"""astng manager: avoid multible astng build of a same module when
possible by providing a class responsible to get astng representation
from various source and using a cache of built modules)
"""

@others</t>
<t tx="ekr.20100212224846.9659">__docformat__ = "restructuredtext en"

import leo.core.leoGlobals as g # ekr
import pdb # ekr
import sys
import os
from os.path import dirname, basename, abspath, join, isdir, exists

from logilab.common.modutils import NoSourceFile, is_python_source, \
     file_from_modpath, load_module_from_name, \
     get_module_files, get_source_file, zipimport
from logilab.common.configuration import OptionsProviderMixIn

from logilab.astng import ASTNGBuildingException, _nodes as nodes, infutils

</t>
<t tx="ekr.20100212224846.9660">def astng_wrapper(func, modname):
    """wrapper to give to ASTNGManager.project_from_files"""
    print 'parsing %s...' % modname
    try:
        return func(modname)
    except ASTNGBuildingException, ex:
        print ex
    except KeyboardInterrupt:
        raise
    except Exception, ex:
        import traceback
        traceback.print_exc()

</t>
<t tx="ekr.20100212224846.9661">def safe_repr(obj):
    try:
        return repr(obj)
    except:
        return '???'

</t>
<t tx="ekr.20100212224846.9662">def zip_import_data(filepath):
    if zipimport is None:
        return None, None
    for ext in ('.zip', '.egg'):
        try:
            eggpath, resource = filepath.split(ext + '/', 1)
        except ValueError:
            continue
        try:
            importer = zipimport.zipimporter(eggpath + ext)
            return importer.get_source(resource), resource.replace('/', '.')
        except:
            continue
    return None, None


</t>
<t tx="ekr.20100212224846.9663">class ASTNGManager(OptionsProviderMixIn):
    """the astng manager, responsible to build astng from files
     or modules.

    Use the Borg pattern.
    """

    name = 'astng loader'
    options = (("ignore",
                {'type' : "csv", 'metavar' : "&lt;file&gt;",
                 'dest' : "black_list", "default" : ('CVS',),
                 'help' : "add &lt;file&gt; (may be a directory) to the black list\
. It should be a base name, not a path. You may set this option multiple times\
."}),
               ("project",
                {'default': "No Name", 'type' : 'string', 'short': 'p',
                 'metavar' : '&lt;project name&gt;',
                 'help' : 'set the project name.'}),
               )
    brain = {}
    @others
</t>
<t tx="ekr.20100212224846.9664">def __init__(self, borg=True):
    if borg:
        self.__dict__ = ASTNGManager.brain
    if not self.__dict__:
        OptionsProviderMixIn.__init__(self)
        self._cache = None
        self._mod_file_cache = None
        self.set_cache_size(200)
        self.load_defaults()

</t>
<t tx="ekr.20100212224846.9665">def set_cache_size(self, cache_size):
    """set the cache size (flush it as a side effect!)"""
    self._cache = {} #Cache(cache_size)
    self._mod_file_cache = {}

</t>
<t tx="ekr.20100212224846.9666">def from_directory(self, directory, modname=None):
    """given a module name, return the astng object"""
    modname = modname or basename(directory)
    directory = abspath(directory)
    return Package(directory, modname, self)

</t>
<t tx="ekr.20100212224846.9667">def astng_from_file(self, filepath, modname=None, fallback=True):
    """given a module name, return the astng object"""
    try:
        filepath = get_source_file(filepath, include_no_ext=True)
        source = True
    except NoSourceFile:
        source = False
    try:
        val = self._cache[filepath]
        return val
    except KeyError:
        # EKR
        # print('manager.py: astng_from_file: not in cache: %s' % filepath)
        self._cache[filepath] = None # EKR
        astng = None # EKR
        if source:
            try:
                from logilab.astng.builder import ASTNGBuilder
                print('manager.py: astng_from_file: calling file_build(%s)' % modname)
                if modname.endswith('leoKeys'): pdb.set_trace()
                astng = ASTNGBuilder(self).file_build(filepath, modname)
            except (SyntaxError, KeyboardInterrupt, SystemExit):
                raise
            except Exception, ex:
                if __debug__:
                    print 'error while building astng for', filepath
                    import traceback
                    traceback.print_exc()
                msg = 'Unable to load module %s (%s)' % (modname, ex)
                raise ASTNGBuildingException(msg), None, sys.exc_info()[-1]
        elif fallback and modname:
            # print('manager.py: astng_from_file: calling astng_from_module_name(%s)' % modname)
            return self.astng_from_module_name(modname)
        else:
            raise ASTNGBuildingException('unable to get astng for file %s' %
                                         filepath)
    self._cache[filepath] = astng
    return astng

</t>
<t tx="ekr.20100212224846.9668">from_file = astng_from_file # backward compat

def astng_from_module_name(self, modname, context_file=None):
    """given a module name, return the astng object"""
    old_cwd = os.getcwd()
    if context_file:
        os.chdir(dirname(context_file))
    try:
        filepath = self.file_from_module_name(modname, context_file)
        if filepath is not None and not is_python_source(filepath):
            try:
                return self._cache[filepath]
            except KeyError:
                data, zmodname = zip_import_data(filepath)
                if data is not None:
                    from logilab.astng.builder import ASTNGBuilder
                    try:
                        astng = ASTNGBuilder(self).string_build(data, zmodname, filepath)
                    except (SyntaxError, KeyboardInterrupt, SystemExit):
                        raise
                    self._cache[filepath] = astng
                    return astng
        if filepath is None or not is_python_source(filepath):
            try:
                module = load_module_from_name(modname)
            except ImportError, ex:
                msg = 'Unable to load module %s (%s)' % (modname, ex)
                raise ASTNGBuildingException(msg)
            return self.astng_from_module(module, modname)
        return self.astng_from_file(filepath, modname, fallback=False)
    finally:
        os.chdir(old_cwd)

</t>
<t tx="ekr.20100212224846.9669">def file_from_module_name(self, modname, contextfile):
    try:
        value = self._mod_file_cache[(modname, contextfile)]
    except KeyError:
        try:
            value = file_from_modpath(modname.split('.'),
                                      context_file=contextfile)
        except ImportError, ex:
            msg = 'Unable to load module %s (%s)' % (modname, ex)
            value = ASTNGBuildingException(msg)
        self._mod_file_cache[(modname, contextfile)] = value
    if isinstance(value, ASTNGBuildingException):
        raise value
    return value

</t>
<t tx="ekr.20100212224846.9670">def astng_from_module(self, module, modname=None):
    """given an imported module, return the astng object"""
    modname = modname or module.__name__
    filepath = modname
    try:
        # some builtin modules don't have __file__ attribute
        filepath = module.__file__
        if is_python_source(filepath):
            return self.astng_from_file(filepath, modname)
    except AttributeError:
        pass
    try:
        return self._cache[filepath]
    except KeyError:
        from logilab.astng.builder import ASTNGBuilder
        astng = ASTNGBuilder(self).module_build(module, modname)
        # update caches (filepath and astng.file are not necessarily  the
        # same (.pyc pb))
        self._cache[filepath] = self._cache[astng.file] = astng
        return astng

</t>
<t tx="ekr.20100212224846.9671">def astng_from_class(self, klass, modname=None):
    """get astng for the given class"""
    if modname is None:
        try:
            modname = klass.__module__
        except AttributeError:
            raise ASTNGBuildingException(
                'Unable to get module for class %s' % safe_repr(klass))
    modastng = self.astng_from_module_name(modname)
    return modastng.getattr(klass.__name__)[0] # XXX
</t>
<t tx="ekr.20100212224846.9672">def infer_astng_from_something(self, obj, modname=None, context=None):
    """infer astng for the given class"""
    if hasattr(obj, '__class__') and not isinstance(obj, type):
        klass = obj.__class__
    else:
        klass = obj
    if modname is None:
        try:
            modname = klass.__module__
        except AttributeError:
            raise ASTNGBuildingException(
                'Unable to get module for %s' % safe_repr(klass))
        except Exception, ex:
            raise ASTNGBuildingException(
                'Unexpected error while retreiving module for %s: %s'
                % (safe_repr(klass), ex))
    try:
        name = klass.__name__
    except AttributeError:
        raise ASTNGBuildingException(
            'Unable to get name for %s' % safe_repr(klass))
    except Exception, ex:
        raise ASTNGBuildingException(
            'Unexpected error while retreiving name for %s: %s'
            % (safe_repr(klass), ex))
    # take care, on living object __module__ is regularly wrong :(
    modastng = self.astng_from_module_name(modname)
    for infered in modastng.igetattr(name, context):
        if klass is not obj and isinstance(infered, nodes.Class):
            infered = infutils.Instance(infered)
        yield infered
</t>
<t tx="ekr.20100212224846.9673">def project_from_files(self, files, func_wrapper=astng_wrapper,
                       project_name=None, black_list=None):
    """return a Project from a list of files or modules"""
    # insert current working directory to the python path to have a correct
    # behaviour
    sys.path.insert(0, os.getcwd())
    try:
        # build the project representation
        project_name = project_name or self.config.project
        black_list = black_list or self.config.black_list
        project = Project(project_name)
        for something in files:
            if not exists(something):
                fpath = file_from_modpath(something.split('.'))
            elif isdir(something):
                fpath = join(something, '__init__.py')
            else:
                fpath = something
            astng = func_wrapper(self.astng_from_file, fpath)
            if astng is None:
                continue
            project.path = project.path or astng.file
            project.add_module(astng)
            base_name = astng.name
            # recurse in package except if __init__ was explicitly given
            if astng.package and something.find('__init__') == -1:
                # recurse on others packages / modules if this is a package
                for fpath in get_module_files(dirname(astng.file),
                                              black_list):
                    astng = func_wrapper(self.astng_from_file, fpath)
                    if astng is None or astng.name == base_name:
                        continue
                    project.add_module(astng)
        return project
    finally:
        sys.path.pop(0)



</t>
<t tx="ekr.20100212224846.9674">class Package:
    """a package using a dictionary like interface

    load submodules lazily, as they are needed
    """
    @others
</t>
<t tx="ekr.20100212224846.9675">
def __init__(self, path, name, manager):
    self.name = name
    self.path = abspath(path)
    self.manager = manager
    self.parent = None
    self.lineno = 0
    self.__keys = None
    self.__subobjects = None

</t>
<t tx="ekr.20100212224846.9676">def fullname(self):
    """return the full name of the package (i.e. prefix by the full name
    of the parent package if any
    """
    if self.parent is None:
        return self.name
    return '%s.%s' % (self.parent.fullname(), self.name)

</t>
<t tx="ekr.20100212224846.9677">def get_subobject(self, name):
    """method used to get sub-objects lazily : sub package or module are
    only build once they are requested
    """
    if self.__subobjects is None:
        try:
            self.__subobjects = dict.fromkeys(self.keys())
        except AttributeError:
            # python &lt;= 2.3
            self.__subobjects = dict([(k, None) for k in self.keys()])
    obj = self.__subobjects[name]
    if obj is None:
        objpath = join(self.path, name)
        if isdir(objpath):
            obj = Package(objpath, name, self.manager)
            obj.parent = self
        else:
            modname = '%s.%s' % (self.fullname(), name)
            obj = self.manager.astng_from_file(objpath + '.py', modname)
        self.__subobjects[name] = obj
    return obj

</t>
<t tx="ekr.20100212224846.9678">def get_module(self, modname):
    """return the Module or Package object with the given name if any
    """
    path = modname.split('.')
    if path[0] != self.name:
        raise KeyError(modname)
    obj = self
    for part in path[1:]:
        obj = obj.get_subobject(part)
    return obj

</t>
<t tx="ekr.20100212224846.9679">def keys(self):
    if self.__keys is None:
        self.__keys = []
        for fname in os.listdir(self.path):
            if fname.endswith('.py'):
                self.__keys.append(fname[:-3])
                continue
            fpath = join(self.path, fname)
            if isdir(fpath) and exists(join(fpath, '__init__.py')):
                self.__keys.append(fname)
        self.__keys.sort()
    return self.__keys[:]

</t>
<t tx="ekr.20100212224846.9680">def values(self):
    return [self.get_subobject(name) for name in self.keys()]

</t>
<t tx="ekr.20100212224846.9681">def items(self):
    return zip(self.keys(), self.values())

</t>
<t tx="ekr.20100212224846.9682">def has_key(self, name):
    return bool(self.get(name))

</t>
<t tx="ekr.20100212224846.9683">def get(self, name, default=None):
    try:
        return self.get_subobject(name)
    except KeyError:
        return default

</t>
<t tx="ekr.20100212224846.9684">def __getitem__(self, name):
    return self.get_subobject(name)
</t>
<t tx="ekr.20100212224846.9685">def __contains__(self, name):
    return self.has_key(name)
</t>
<t tx="ekr.20100212224846.9686">def __iter__(self):
    return iter(self.keys())


</t>
<t tx="ekr.20100212224846.9687">class Project:
    """a project handle a set of modules / packages"""
    @others
</t>
<t tx="ekr.20100212224846.9688">def __init__(self, name=''):
    self.name = name
    self.path = None
    self.modules = []
    self.locals = {}
    self.__getitem__ = self.locals.__getitem__
    self.__iter__ = self.locals.__iter__
    self.values = self.locals.values
    self.keys = self.locals.keys
    self.items = self.locals.items
    self.has_key = self.locals.has_key

</t>
<t tx="ekr.20100212224846.9689">def add_module(self, node):
    self.locals[node.name] = node
    self.modules.append(node)

</t>
<t tx="ekr.20100212224846.9690">def get_module(self, name):
    return self.locals[name]

</t>
<t tx="ekr.20100212224846.9691">def get_children(self):
    return self.modules

</t>
<t tx="ekr.20100212224846.9692">def __repr__(self):
    return '&lt;Project %r at %s (%s modules)&gt;' % (self.name, id(self),
                                                len(self.modules))
</t>
<t tx="ekr.20100212224846.9693">@language python
@tabwidth -4

"""
on all nodes :
 .is_statement, returning true if the node should be considered as a
  statement node
 .root(), returning the root node of the tree (i.e. a Module)
 .previous_sibling(), returning previous sibling statement node
 .next_sibling(), returning next sibling statement node
 .statement(), returning the first parent node marked as statement node
 .frame(), returning the first node defining a new local scope (i.e.
  Module, Function or Class)
 .set_local(name, node), define an identifier &lt;name&gt; on the first parent frame,
  with the node defining it. This is used by the astng builder and should not
  be used from out there.

on From and Import :
 .real_name(name),
"""

@others</t>
<t tx="ekr.20100212224846.9694">from __future__ import generators

__docformat__ = "restructuredtext en"

from itertools import imap

from logilab.astng._nodes import *
from logilab.astng._nodes import _const_factory

from logilab.astng._exceptions import UnresolvableName, NotFoundError, \
                                        InferenceError, ASTNGError
from logilab.astng.utils import extend_class, REDIRECT
from logilab.astng import node_classes
from logilab.astng.lookup import LookupMixIn
from logilab.astng import scoped_nodes
from logilab.astng.scoped_nodes import LocalsDictMixIn

INFER_NEED_NAME_STMTS = (From, Import, Global, TryExcept)
LOOP_SCOPES = (Comprehension, For,)

# astng fields definition ####################################################
Arguments._astng_fields = ('args', 'defaults')
AssAttr._astng_fields = ('expr',)
Assert._astng_fields = ('test', 'fail',)
Assign._astng_fields = ('targets', 'value',)
AssName._astng_fields = ()

AugAssign._astng_fields = ('target', 'value',)
BinOp._astng_fields = ('left', 'right',)
BoolOp._astng_fields = ('values',)
UnaryOp._astng_fields = ('operand',)

Backquote._astng_fields = ('value',)
Break._astng_fields = ()
CallFunc._astng_fields = ('func', 'args', 'starargs', 'kwargs')
Class._astng_fields = ('bases', 'body',) # name
Compare._astng_fields = ('left', 'ops',)
Comprehension._astng_fields = ('target', 'iter' ,'ifs')
Const._astng_fields = ()
Continue._astng_fields = ()
Decorators._astng_fields = ('nodes',)
Delete._astng_fields = ('targets', )
DelAttr._astng_fields = ('expr',)
DelName._astng_fields = ()
Dict._astng_fields = ('items',)
Discard._astng_fields = ('value',)
From._astng_fields = ()
Ellipsis._astng_fields = ()
EmptyNode._astng_fields = ()
ExceptHandler._astng_fields = ('type', 'name', 'body',)
Exec._astng_fields = ('expr', 'globals', 'locals',)
ExtSlice._astng_fields =('dims',)
Function._astng_fields = ('decorators', 'args', 'body')
For._astng_fields = ('target', 'iter', 'body', 'orelse',)
Getattr._astng_fields = ('expr',) # (former value), attr (now attrname), ctx
GenExpr._astng_fields = ('elt', 'generators')
Global._astng_fields = ()
If._astng_fields = ('test', 'body', 'orelse')
IfExp._astng_fields = ('test', 'body', 'orelse')
Import._astng_fields = ()
Index._astng_fields = ('value',)
Keyword._astng_fields = ('value',)
Lambda._astng_fields = ('args', 'body',)
List._astng_fields = ('elts',)  # ctx
ListComp._astng_fields = ('elt', 'generators')
Module._astng_fields = ('body',)
Name._astng_fields = () # id, ctx
Pass._astng_fields = ()
Print._astng_fields = ('dest', 'values',) # nl
Raise._astng_fields = ('type', 'inst', 'tback')
Return._astng_fields = ('value',)
Slice._astng_fields = ('lower', 'upper', 'step')
Subscript._astng_fields = ('value', 'slice')
TryExcept._astng_fields = ('body', 'handlers', 'orelse',)
TryFinally._astng_fields = ('body', 'finalbody',)
Tuple._astng_fields = ('elts',)  # ctx
With._astng_fields = ('expr', 'vars', 'body')
While._astng_fields = ('test', 'body', 'orelse',)
Yield._astng_fields = ('value',)

# extend all classes
# TODO : use __bases__ instead of extend_class

LOCALS_NODES = (Class, Function, GenExpr, Lambda, Module)

for cls in ALL_NODES:
    if cls in LOCALS_NODES:
        cls_module = scoped_nodes
    else:
        cls_module = node_classes
    ng_class = getattr(cls_module, REDIRECT.get(cls.__name__, cls.__name__) + "NG")
    addons = list((ng_class,) + ng_class.__bases__)
    addons.reverse()
    extend_class(cls,  addons)
    # cls.__bases__ += (ng_class,) + ng_class.__bases__

# _scope_lookup only available with LookupMixIn extention
GenExpr.scope_lookup = GenExpr._scope_lookup</t>
<t tx="ekr.20100212224846.9695">@language python
@tabwidth -4

# this visitor is stateless, thus it can be reused
as_string = AsStringVisitor()

"""this module contains exceptions used in the astng library

This module renders ASTNG nodes to string representation.
It will problably not work on compiler.ast or _ast trees.
"""

@others</t>
<t tx="ekr.20100212224846.9696">from logilab.astng.utils import ASTVisitor

INDENT = '    ' # 4 spaces ; keep indentation variable


</t>
<t tx="ekr.20100212224846.9697">def _import_string(names):
    """return a list of (name, asname) formatted as a string"""
    _names = []
    for name, asname in names:
        if asname is not None:
            _names.append('%s as %s' % (name, asname))
        else:
            _names.append(name)
    return  ', '.join(_names)


</t>
<t tx="ekr.20100212224846.9698">class AsStringVisitor(ASTVisitor):
    """Visitor to render an ASTNG node as string """
    @others
</t>
<t tx="ekr.20100212224846.9699">
def __call__(self, node):
    """Makes this visitor behave as a simple function"""
    return node.accept(self)

</t>
<t tx="ekr.20100212224846.9700">def _stmt_list(self, stmts):
    """return a list of nodes to string"""
    stmts = '\n'.join([nstr for nstr in (n.accept(self) for n in stmts) if nstr])
    return INDENT + stmts.replace('\n', '\n'+INDENT)


</t>
<t tx="ekr.20100212224846.9701">## visit_&lt;node&gt; methods ###########################################

def visit_arguments(self, node):
    """return an astng.Function node as string"""
    return node.format_args()

</t>
<t tx="ekr.20100212224846.9702">def visit_assattr(self, node):
    """return an astng.AssAttr node as string"""
    return self.visit_getattr(node)

</t>
<t tx="ekr.20100212224846.9703">def visit_assert(self, node):
    """return an astng.Assert node as string"""
    if node.fail:
        return 'assert %s, %s' % (node.test.accept(self),
                                    node.fail.accept(self))
    return 'assert %s' % node.test.accept(self)

</t>
<t tx="ekr.20100212224846.9704">def visit_assname(self, node):
    """return an astng.AssName node as string"""
    return node.name

</t>
<t tx="ekr.20100212224846.9705">def visit_assign(self, node):
    """return an astng.Assign node as string"""
    lhs = ' = '.join([n.accept(self) for n in node.targets])
    return '%s = %s' % (lhs, node.value.accept(self))

</t>
<t tx="ekr.20100212224846.9706">def visit_augassign(self, node):
    """return an astng.AugAssign node as string"""
    return '%s %s %s' % (node.target.accept(self), node.op, node.value.accept(self))

</t>
<t tx="ekr.20100212224846.9707">def visit_backquote(self, node):
    """return an astng.Backquote node as string"""
    return '`%s`' % node.value.accept(self)

</t>
<t tx="ekr.20100212224846.9708">def visit_binop(self, node):
    """return an astng.BinOp node as string"""
    return '(%s) %s (%s)' % (node.left.accept(self), node.op, node.right.accept(self))

</t>
<t tx="ekr.20100212224846.9709">def visit_boolop(self, node):
    """return an astng.BoolOp node as string"""
    return (' %s ' % node.op).join(['(%s)' % n.accept(self)
                                        for n in node.values])

</t>
<t tx="ekr.20100212224846.9710">def visit_break(self, node):
    """return an astng.Break node as string"""
    return 'break'

</t>
<t tx="ekr.20100212224846.9711">def visit_callfunc(self, node):
    """return an astng.CallFunc node as string"""
    expr_str = node.func.accept(self)
    args = ', '.join([arg.accept(self) for arg in node.args])
    if node.starargs:
        args += ', *%s' % node.starargs.accept(self)
    if node.kwargs:
        args += ', **%s' % node.kwargs.accept(self)
    return '%s(%s)' % (expr_str, args)

</t>
<t tx="ekr.20100212224846.9712">def visit_class(self, node):
    """return an astng.Class node as string"""
    bases =  ', '.join([n.accept(self) for n in node.bases])
    bases = bases and '(%s)' % bases or ''
    docs = node.doc and '\n%s"""%s"""' % (INDENT, node.doc) or ''
    return 'class %s%s:%s\n%s\n' % (node.name, bases, docs,
                                        self._stmt_list( node.body))

</t>
<t tx="ekr.20100212224846.9713">def visit_compare(self, node):
    """return an astng.Compare node as string"""
    rhs_str = ' '.join(['%s %s' % (op, expr.accept(self))
                        for op, expr in node.ops])
    return '%s %s' % (node.left.accept(self), rhs_str)

</t>
<t tx="ekr.20100212224846.9714">def visit_comprehension(self, node):
    """return an astng.Comprehension node as string"""
    ifs = ''.join([ ' if %s' % n.accept(self) for n in node.ifs])
    return 'for %s in %s%s' % (node.target.accept(self),
                                node.iter.accept(self), ifs )

</t>
<t tx="ekr.20100212224846.9715">def visit_const(self, node):
    """return an astng.Const node as string"""
    return repr(node.value)

</t>
<t tx="ekr.20100212224846.9716">def visit_continue(self, node):
    """return an astng.Continue node as string"""
    return 'continue'

</t>
<t tx="ekr.20100212224846.9717">def visit_delete(self, node): # XXX check if correct
    """return an astng.Delete node as string"""
    return 'del %s' % ', '.join([child.accept(self) 
                            for child in node.targets])

</t>
<t tx="ekr.20100212224846.9718">def visit_delattr(self, node):
    """return an astng.DelAttr node as string"""
    return self.visit_getattr(node)

</t>
<t tx="ekr.20100212224846.9719">def visit_delname(self, node):
    """return an astng.DelName node as string"""
    return node.name

</t>
<t tx="ekr.20100212224846.9720">def visit_decorators(self, node):
    """return an astng.Decorators node as string"""
    return '@%s\n' % '\n@'.join(item.accept(self) for item in node.nodes)

</t>
<t tx="ekr.20100212224846.9721">def visit_dict(self, node):
    """return an astng.Dict node as string"""
    return '{%s}' % ', '.join(['%s: %s' % (key.accept(self), 
                        value.accept(self)) for key, value in node.items])

</t>
<t tx="ekr.20100212224846.9722">def visit_discard(self, node):
    """return an astng.Discard node as string"""
    return node.value.accept(self)

</t>
<t tx="ekr.20100212224846.9723">def visit_excepthandler(self, node):
    if node.type:
        if node.name:
            excs = 'except %s, %s' % (node.type.accept(self),
                                    node.name.accept(self))
        else:
            excs = 'except %s' % node.type.accept(self)
    else:
        excs = 'except'
    return '%s:\n%s' % (excs, self._stmt_list(node.body))

</t>
<t tx="ekr.20100212224846.9724">def visit_ellipsis(self, node):
    """return an astng.Ellipsis node as string"""
    return '...'

</t>
<t tx="ekr.20100212224846.9725">def visit_empty(self, node):
    """return an Empty node as string"""
    return ''

</t>
<t tx="ekr.20100212224846.9726">def visit_exec(self, node):
    """return an astng.Exec node as string"""
    if node.locals:
        return 'exec %s in %s, %s' % (node.expr.accept(self),
                                      node.locals.accept(self),
                                      node.globals.accept(self))
    if node.globals:
        return 'exec %s in %s' % (node.expr.accept(self),
                                  node.globals.accept(self))
    return 'exec %s' % node.expr.accept(self)

</t>
<t tx="ekr.20100212224846.9727">def visit_extslice(self, node):
    """return an astng.ExtSlice node as string"""
    return ','.join( dim.accept(self) for dim in node.dims )
</t>
<t tx="ekr.20100212224846.9728">def visit_for(self, node):
    """return an astng.For node as string"""
    fors = 'for %s in %s:\n%s' % (node.target.accept(self),
                                node.iter.accept(self),
                                self._stmt_list( node.body))
    if node.orelse:
        fors = '%s\nelse:\n%s' % (fors, self._stmt_list(node.orelse))
    return fors

</t>
<t tx="ekr.20100212224846.9729">def visit_from(self, node):
    """return an astng.From node as string"""
    # XXX level
    return 'from %s import %s' % (node.modname, _import_string(node.names))

</t>
<t tx="ekr.20100212224846.9730">def visit_function(self, node):
    """return an astng.Function node as string"""
    decorate = node.decorators and node.decorators.accept(self)  or ''
    docs = node.doc and '\n%s"""%s"""' % (INDENT, node.doc) or ''
    return '%sdef %s(%s):%s\n%s' % (decorate, node.name, node.args.accept(self),
                                    docs, self._stmt_list(node.body))

</t>
<t tx="ekr.20100212224846.9731">def visit_genexpr(self, node):
    """return an astng.ListComp node as string"""
    return '(%s %s)' % (node.elt.accept(self), ' '.join([n.accept(self)
                                                for n in node.generators]))

</t>
<t tx="ekr.20100212224846.9732">def visit_getattr(self, node):
    """return an astng.Getattr node as string"""
    return '%s.%s' % (node.expr.accept(self), node.attrname)

</t>
<t tx="ekr.20100212224846.9733">def visit_global(self, node):
    """return an astng.Global node as string"""
    return 'global %s' % ', '.join(node.names)

</t>
<t tx="ekr.20100212224846.9734">def visit_if(self, node):
    """return an astng.If node as string"""
    ifs = ['if %s:\n%s' % (node.test.accept(self), self._stmt_list(node.body))]
    if node.orelse:
        ifs.append('else:\n%s' % self._stmt_list(node.orelse))
    return '\n'.join(ifs)

</t>
<t tx="ekr.20100212224846.9735">def visit_ifexp(self, node):
    """return an astng.IfExp node as string"""
    ifs = ['%s if %s' % (self._stmt_list(node.body), node.test.accept(self))]
    if node.orelse:
        ifs.append('else %s' % self._stmt_list(node.orelse))
    return ' '.join(ifs)

</t>
<t tx="ekr.20100212224846.9736">def visit_import(self, node):
    """return an astng.Import node as string"""
    return 'import %s' % _import_string(node.names)

</t>
<t tx="ekr.20100212224846.9737">def visit_keyword(self, node):
    """return an astng.Keyword node as string"""
    return '%s=%s' % (node.arg, node.value.accept(self))

</t>
<t tx="ekr.20100212224846.9738">def visit_lambda(self, node):
    """return an astng.Lambda node as string"""
    return 'lambda %s: %s' % (node.args.accept(self), node.body.accept(self))

</t>
<t tx="ekr.20100212224846.9739">def visit_list(self, node):
    """return an astng.List node as string"""
    return '[%s]' % ', '.join([child.accept(self) for child in node.elts])

</t>
<t tx="ekr.20100212224846.9740">def visit_listcomp(self, node):
    """return an astng.ListComp node as string"""
    return '[%s %s]' % (node.elt.accept(self), ' '.join([n.accept(self)
                                            for n in node.generators]))

</t>
<t tx="ekr.20100212224846.9741">def visit_module(self, node):
    """return an astng.Module node as string"""
    docs = node.doc and '"""%s"""\n' % node.doc or ''
    stmts = '\n'.join([n.accept(self) for n in node.body])
    return docs + '\n'.join([n.accept(self) for n in node.body])

</t>
<t tx="ekr.20100212224846.9742">def visit_name(self, node):
    """return an astng.Name node as string"""
    return node.name

</t>
<t tx="ekr.20100212224846.9743">def visit_pass(self, node):
    """return an astng.Pass node as string"""
    return 'pass'

</t>
<t tx="ekr.20100212224846.9744">def visit_print(self, node):
    """return an astng.Print node as string"""
    nodes = ', '.join([n.accept(self) for n in node.values])
    if not node.nl:
        nodes = '%s,' % nodes
    if node.dest:
        return 'print &gt;&gt; %s, %s' % (node.dest.accept(self), nodes)
    return 'print %s' % nodes

</t>
<t tx="ekr.20100212224846.9745">def visit_raise(self, node):
    """return an astng.Raise node as string"""
    if node.type:
        if node.inst:
            if node.tback:
                return 'raise %s, %s, %s' % (node.type.accept(self),
                                            node.inst.accept(self),
                                            node.tback.accept(self))
            return 'raise %s, %s' % (node.type.accept(self),
                                    node.inst.accept(self))
        return 'raise %s' % node.type.accept(self)
    return 'raise'

</t>
<t tx="ekr.20100212224846.9746">def visit_return(self, node):
    """return an astng.Return node as string"""
    if node.value:
        return 'return %s' % node.value.accept(self)
    else:
        return 'return'

</t>
<t tx="ekr.20100212224846.9747">def visit_index(self, node):
    """return a astng.Index node as string"""
    return node.value.accept(self)

</t>
<t tx="ekr.20100212224846.9748">def visit_slice(self, node):
    """return a astng.Slice node as string"""
    lower = node.lower and node.lower.accept(self) or ''
    upper = node.upper and node.upper.accept(self) or ''
    step = node.step and node.step.accept(self) or ''
    if step:
        return '%s:%s:%s' % (lower, upper, step)
    return  '%s:%s' % (lower, upper)

</t>
<t tx="ekr.20100212224846.9749">def visit_subscript(self, node):
    """return an astng.Subscript node as string"""
    return '%s[%s]' % (node.value.accept(self), node.slice.accept(self))

</t>
<t tx="ekr.20100212224846.9750">def visit_tryexcept(self, node):
    """return an astng.TryExcept node as string"""
    trys = ['try:\n%s' % self._stmt_list( node.body)]
    for handler in node.handlers:
        trys.append(handler.accept(self))
    if node.orelse:
        trys.append('else:\n%s' % self._stmt_list(node.orelse))
    return '\n'.join(trys)

</t>
<t tx="ekr.20100212224846.9751">def visit_tryfinally(self, node):
    """return an astng.TryFinally node as string"""
    return 'try:\n%s\nfinally:\n%s' % (self._stmt_list( node.body),
                                    self._stmt_list(node.finalbody))

</t>
<t tx="ekr.20100212224846.9752">def visit_tuple(self, node):
    """return an astng.Tuple node as string"""
    return '(%s)' % ', '.join([child.accept(self) for child in node.elts])

</t>
<t tx="ekr.20100212224846.9753">def visit_unaryop(self, node):
    """return an astng.UnaryOp node as string"""
    return '%s%s' % (node.op, node.operand.accept(self))

</t>
<t tx="ekr.20100212224846.9754">def visit_while(self, node):
    """return an astng.While node as string"""
    whiles = 'while %s:\n%s' % (node.test.accept(self),
                                self._stmt_list(node.body))
    if node.orelse:
        whiles = '%s\nelse:\n%s' % (whiles, self._stmt_list(node.orelse))
    return whiles

</t>
<t tx="ekr.20100212224846.9755">def visit_with(self, node): # 'with' without 'as' is possible
    """return an astng.With node as string"""
    as_var = node.vars and " as (%s)" % (node.vars.accept(self)) or ""
    withs = 'with (%s)%s:\n%s' % (node.expr.accept(self), as_var,
                                    self._stmt_list( node.body))
    return withs

</t>
<t tx="ekr.20100212224846.9756">def visit_yield(self, node):
    """yield an ast.Yield node as string"""
    return 'yield %s' % node.value.accept(self)


</t>
<t tx="ekr.20100212224846.9757">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100212224846.9758">#
from logilab.astng import (ASTNGBuildingException, InferenceError,
                           NotFoundError, NoDefault)
from logilab.astng._nodes import *
from logilab.astng.lookup import LookupMixIn, LocalsDictMixIn

</t>
<t tx="ekr.20100212224846.9759"># import leo.core.leoGlobals as g

class ArgumentsNG(NodeNG):
    """class representing an Arguments node"""
    @others
</t>
<t tx="ekr.20100212224846.9760">
def format_args(self):
    """return arguments formatted as string"""
    result = [_format_args(self.args, self.defaults)]
    if self.vararg:
        result.append('*%s' % self.vararg)
    if self.kwarg:
        result.append('**%s' % self.kwarg)
    return ', '.join(result)

</t>
<t tx="ekr.20100212224846.9761">def default_value(self, argname):
    """return the default value for an argument

    :raise `NoDefault`: if there is no default value defined
    """
    i = _find_arg(argname, self.args)[0]
    if i is not None:
        idx = i - (len(self.args) - len(self.defaults))
        if idx &gt;= 0:
            return self.defaults[idx]
    raise NoDefault()

</t>
<t tx="ekr.20100212224846.9762">def is_argument(self, name):
    """return True if the name is defined in arguments"""
    if name == self.vararg:
        return True
    if name == self.kwarg:
        return True
    return self.find_argname(name, True)[1] is not None

</t>
<t tx="ekr.20100212224846.9763">def find_argname(self, argname, rec=False):
    """return index and Name node with given name"""
    if self.args: # self.args may be None in some cases (builtin function)
        return _find_arg(argname, self.args, rec)
    return None, None

</t>
<t tx="ekr.20100212224846.9764">def _find_arg(argname, args, rec=False):
    for i, arg in enumerate(args):
        if isinstance(arg, Tuple):
            if rec:
                found = _find_arg(argname, arg.elts)
                if found[0] is not None:
                    return found
        elif arg.name == argname:
            return i, arg
    return None, None


</t>
<t tx="ekr.20100212224846.9765">def _format_args(args, defaults=None):
    values = []
    if args is None:
        return ''
    if defaults is not None:
        default_offset = len(args) - len(defaults)
    for i, arg in enumerate(args):
        if isinstance(arg, Tuple):
            values.append('(%s)' % _format_args(arg.elts))
        else:
            values.append(arg.name)
            if defaults is not None and i &gt;= default_offset:
                values[-1] += '=' + defaults[i-default_offset].as_string()
    return ', '.join(values)


</t>
<t tx="ekr.20100212224846.9766">class AssAttrNG(NodeNG):
    """class representing an AssAttr node"""


</t>
<t tx="ekr.20100212224846.9767">class AssNameNG(LookupMixIn, NodeNG):
    """class representing an AssName node"""


</t>
<t tx="ekr.20100212224846.9768">class AssertNG(StmtMixIn, NodeNG):
    """class representing an Assert node"""


</t>
<t tx="ekr.20100212224846.9769">class AssignNG(StmtMixIn, NodeNG):
    """class representing an Assign node"""


</t>
<t tx="ekr.20100212224846.9770">class AugAssignNG(StmtMixIn, NodeNG):
    """class representing an AugAssign node"""


</t>
<t tx="ekr.20100212224846.9771">class BackquoteNG(NodeNG):
    """class representing a Backquote node"""


</t>
<t tx="ekr.20100212224846.9772">class BinOpNG(NodeNG):
    """class representing a BinOp node"""


</t>
<t tx="ekr.20100212224846.9773">class BoolOpNG(NodeNG):
    """class representing a BoolOp node"""


</t>
<t tx="ekr.20100212224846.9774">class BreakNG(StmtMixIn, NodeNG):
    """class representing a Break node"""


</t>
<t tx="ekr.20100212224846.9775">class CallFuncNG(NodeNG):
    """class representing a CallFunc node"""


</t>
<t tx="ekr.20100212224846.9776">class CompareNG(NodeNG):
    """class representing a Compare node"""
    @others
</t>
<t tx="ekr.20100212224846.9777">
def get_children(self):
    """override get_children for tuple fields"""
    yield self.left
    for _, comparator in self.ops:
        yield comparator # we don't want the 'op'

</t>
<t tx="ekr.20100212224846.9778">class ComprehensionNG(NodeNG):
    """class representing a Comprehension node"""


</t>
<t tx="ekr.20100212224846.9779">class ConstNG(NodeNG):
    """class representing a Const node"""
    @others
</t>
<t tx="ekr.20100212224846.9780">
def getitem(self, index, context=None):
    if isinstance(self.value, basestring):
        return self.value[index]
    raise TypeError()

</t>
<t tx="ekr.20100212224846.9781">def has_dynamic_getattr(self):
    return False

</t>
<t tx="ekr.20100212224846.9782">def itered(self):
    if isinstance(self.value, basestring):
        return self.value
    raise TypeError()

</t>
<t tx="ekr.20100212224846.9783">class ContinueNG(StmtMixIn, NodeNG):
    """class representing a Continue node"""


</t>
<t tx="ekr.20100212224846.9784">class DecoratorsNG(NodeNG):
    """class representing a Decorators node"""
    @others
</t>
<t tx="ekr.20100212224846.9785">
def scope(self):
    # skip the function node to go directly to the upper level scope
    return self.parent.parent.scope()

</t>
<t tx="ekr.20100212224846.9786">class DelAttrNG(NodeNG):
    """class representing a DelAttr node"""


</t>
<t tx="ekr.20100212224846.9787">class DelNameNG(LookupMixIn, NodeNG):
    """class representing a DelName node"""


</t>
<t tx="ekr.20100212224846.9788">class DeleteNG(StmtMixIn, NodeNG):
    """class representing a Delete node"""


</t>
<t tx="ekr.20100212224846.9789">class DictNG(NodeNG):
    """class representing a Dict node"""
    @others
</t>
<t tx="ekr.20100212224846.9790">
def pytype(self):
    return '__builtin__.dict'

</t>
<t tx="ekr.20100212224846.9791">def get_children(self):
    """get children of a Dict node"""
    # overrides get_children
    for key, value in self.items:
        yield key
        yield value

</t>
<t tx="ekr.20100212224846.9792">def itered(self):
    return self.items[::2]

</t>
<t tx="ekr.20100212224846.9793">def getitem(self, key, context=None):
    for i in xrange(0, len(self.items), 2):
        for inferedkey in self.items[i].infer(context):
            if inferedkey is YES:
                continue
            if isinstance(inferedkey, Const) and inferedkey.value == key:
                return self.items[i+1]
    raise IndexError(key)


</t>
<t tx="ekr.20100212224846.9794">class DiscardNG(StmtMixIn, NodeNG):
    """class representing a Discard node"""


</t>
<t tx="ekr.20100212224846.9795">class EllipsisNG(NodeNG):
    """class representing an Ellipsis node"""


</t>
<t tx="ekr.20100212224846.9796">class EmptyNodeNG(NodeNG):
    """class representing an EmptyNode node"""


</t>
<t tx="ekr.20100212224846.9797">class ExceptHandlerNG(StmtMixIn, NodeNG):
    """class representing an ExceptHandler node"""
    @others
</t>
<t tx="ekr.20100212224846.9798">
def _blockstart_toline(self):
    if self.name:
        return self.name.tolineno
    elif self.type:
        return self.type.tolineno
    else:
        return self.lineno

</t>
<t tx="ekr.20100212224846.9799">def set_line_info(self, lastchild):
    self.fromlineno = self.lineno
    self.tolineno = lastchild.tolineno
    self.blockstart_tolineno = self._blockstart_toline()

</t>
<t tx="ekr.20100212224846.9800">def catch(self, exceptions):
    if self.type is None or exceptions is None:
        return True
    for node in self.type.nodes_of_class(Name):
        if node.name in exceptions:
            return True


</t>
<t tx="ekr.20100212224846.9801">class ExecNG(StmtMixIn, NodeNG):
    """class representing an Exec node"""


</t>
<t tx="ekr.20100212224846.9802">class ExtSliceNG(NodeNG):
    """class representing an ExtSlice node"""


</t>
<t tx="ekr.20100212224846.9803">class ForNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing a For node"""
    @others
</t>
<t tx="ekr.20100212224846.9804">
def _blockstart_toline(self):
    return self.iter.tolineno


</t>
<t tx="ekr.20100212224846.9805">class FromImportMixIn(object):
    """MixIn for From and Import Nodes"""
    @others
</t>
<t tx="ekr.20100212224846.9806">def do_import_module(node, modname):
    """return the ast for a module whose name is &lt;modname&gt; imported by &lt;node&gt;
    """
    # handle special case where we are on a package node importing a module
    # using the same name as the package, which may end in an infinite loop
    # on relative imports
    # XXX: no more needed ?
    mymodule = node.root()
    level = getattr(node, 'level', None) # Import as no level
    if mymodule.absolute_modname(modname, level) == mymodule.name:
        # FIXME: I don't know what to do here...
        raise InferenceError('module importing itself: %s' % modname)
    try:
        # print('ekr: node_classes.py: do_import_module: %s' % (modname))
        return mymodule.import_module(modname, level=level)
    except (ASTNGBuildingException, SyntaxError):
        raise InferenceError(modname)

</t>
<t tx="ekr.20100212224846.9807">def real_name(self, asname):
    """get name from 'as' name"""
    for index in range(len(self.names)):
        name, _asname = self.names[index]
        if name == '*':
            return asname
        if not _asname:
            name = name.split('.', 1)[0]
            _asname = name
        if asname == _asname:
            return name
    raise NotFoundError(asname)


</t>
<t tx="ekr.20100212224846.9808">class FromNG(FromImportMixIn, StmtMixIn, NodeNG):
    """class representing a From node"""


</t>
<t tx="ekr.20100212224846.9809">class GenExprNG(LocalsDictMixIn, NodeNG):
    """class representing a GenExpr node"""


</t>
<t tx="ekr.20100212224846.9810">class GetattrNG(NodeNG):
    """class representing a Getattr node"""


</t>
<t tx="ekr.20100212224846.9811">class GlobalNG(StmtMixIn, NodeNG):
    """class representing a Global node"""


</t>
<t tx="ekr.20100212224846.9812">class IfNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing an If node"""
    @others
</t>
<t tx="ekr.20100212224846.9813">
def _blockstart_toline(self):
    return self.test.tolineno

</t>
<t tx="ekr.20100212224846.9814">def block_range(self, lineno):
    """handle block line numbers range for if statements"""
    if lineno == self.body[0].fromlineno:
        return lineno, lineno
    if lineno &lt;= self.body[-1].tolineno:
        return lineno, self.body[-1].tolineno
    return self._elsed_block_range(lineno, self.orelse,
                                   self.body[0].fromlineno - 1)


</t>
<t tx="ekr.20100212224846.9815">class IfExpNG(NodeNG):
    """class representing an IfExp node"""


</t>
<t tx="ekr.20100212224846.9816">class ImportNG(FromImportMixIn, StmtMixIn, NodeNG):
    """class representing an Import node"""


</t>
<t tx="ekr.20100212224846.9817">class IndexNG(NodeNG):
    """class representing an Index node"""


</t>
<t tx="ekr.20100212224846.9818">class KeywordNG(NodeNG):
    """class representing a Keyword node"""


</t>
<t tx="ekr.20100212224846.9819">class ListNG(NodeNG):
    """class representing a List node"""
    @others
</t>
<t tx="ekr.20100212224846.9820">
def pytype(self):
    return '__builtin__.list'

</t>
<t tx="ekr.20100212224846.9821">def getitem(self, index, context=None):
    return self.elts[index]

</t>
<t tx="ekr.20100212224846.9822">def itered(self):
    return self.elts


</t>
<t tx="ekr.20100212224846.9823">class ListCompNG(NodeNG):
    """class representing a ListComp node"""


</t>
<t tx="ekr.20100212224846.9824">class NameNG(LookupMixIn, NodeNG):
    """class representing a Name node"""


</t>
<t tx="ekr.20100212224846.9825">class PassNG(StmtMixIn, NodeNG):
    """class representing a Pass node"""


</t>
<t tx="ekr.20100212224846.9826">class PrintNG(StmtMixIn, NodeNG):
    """class representing a Print node"""


</t>
<t tx="ekr.20100212224846.9827">class RaiseNG(StmtMixIn, NodeNG):
    """class representing a Raise node"""


</t>
<t tx="ekr.20100212224846.9828">class ReturnNG(StmtMixIn, NodeNG):
    """class representing a Return node"""


</t>
<t tx="ekr.20100212224846.9829">class SliceNG(NodeNG):
    """class representing a Slice node"""


</t>
<t tx="ekr.20100212224846.9830">class SubscriptNG(NodeNG):
    """class representing a Subscript node"""


</t>
<t tx="ekr.20100212224846.9831">class TryExceptNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing a TryExcept node"""
    @others
</t>
<t tx="ekr.20100212224846.9832">
def _blockstart_toline(self):
    return self.lineno

</t>
<t tx="ekr.20100212224846.9833">def block_range(self, lineno):
    """handle block line numbers range for try/except statements"""
    last = None
    for exhandler in self.handlers:
        if exhandler.type and lineno == exhandler.type.fromlineno:
            return lineno, lineno
        if exhandler.body[0].fromlineno &lt;= lineno &lt;= exhandler.body[-1].tolineno:
            return lineno, exhandler.body[-1].tolineno
        if last is None:
            last = exhandler.body[0].fromlineno - 1
    return self._elsed_block_range(lineno, self.orelse, last)


</t>
<t tx="ekr.20100212224846.9834">class TryFinallyNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing a TryFinally node"""
    @others
</t>
<t tx="ekr.20100212224846.9835">
def _blockstart_toline(self):
    return self.lineno

</t>
<t tx="ekr.20100212224846.9836">def block_range(self, lineno):
    """handle block line numbers range for try/finally statements"""
    child = self.body[0]
    # py2.5 try: except: finally:
    if (isinstance(child, TryExcept) and child.fromlineno == self.fromlineno
        and lineno &gt; self.fromlineno and lineno &lt;= child.tolineno):
        return child.block_range(lineno)
    return self._elsed_block_range(lineno, self.finalbody)


</t>
<t tx="ekr.20100212224846.9837">class TupleNG(NodeNG):
    """class representing a Tuple node"""
    @others
</t>
<t tx="ekr.20100212224846.9838">
def pytype(self):
    return '__builtin__.tuple'

</t>
<t tx="ekr.20100212224846.9839">def getitem(self, index, context=None):
    return self.elts[index]

</t>
<t tx="ekr.20100212224846.9840">def itered(self):
    return self.elts


</t>
<t tx="ekr.20100212224846.9841">class UnaryOpNG(NodeNG):
    """class representing an UnaryOp node"""


</t>
<t tx="ekr.20100212224846.9842">class WhileNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing a While node"""
    @others
</t>
<t tx="ekr.20100212224846.9843">
def _blockstart_toline(self):
    return self.test.tolineno

</t>
<t tx="ekr.20100212224846.9844">def block_range(self, lineno):
    """handle block line numbers range for for and while statements"""
    return self. _elsed_block_range(lineno, self.orelse)

</t>
<t tx="ekr.20100212224846.9845">class WithNG(BlockRangeMixIn, StmtMixIn, NodeNG):
    """class representing a With node"""
    @others
</t>
<t tx="ekr.20100212224846.9846">
def _blockstart_toline(self):
    if self.vars:
        return self.vars.tolineno
    else:
        return self.expr.tolineno


</t>
<t tx="ekr.20100212224846.9847">class YieldNG(NodeNG):
    """class representing a Yield node"""

</t>
<t tx="ekr.20100212224846.9848">@language python
@tabwidth -4

"""Monkey patch compiler.transformer to fix line numbering bugs
"""

@others

# wrap *_stmt methods
for name in dir(BaseTransformer):
    if name.endswith('_stmt') and not (name in ('com_stmt',
                                                'com_append_stmt')
                                       or name in ASTNGTransformer.__dict__):
        setattr(BaseTransformer, name,
                fixlineno_wrap(getattr(BaseTransformer, name), name[:-5]))

transformer.Transformer = ASTNGTransformer
</t>
<t tx="ekr.20100212224846.9849">from types import TupleType
from token import DEDENT
from compiler import transformer

from logilab.astng import nodes

</t>
<t tx="ekr.20100212224846.9850">def fromto_lineno(asttuple):
    """return the minimum and maximum line number of the given ast tuple"""
    return from_lineno(asttuple), to_lineno(asttuple)

</t>
<t tx="ekr.20100212224846.9851">def from_lineno(asttuple):
    """return the minimum line number of the given ast tuple"""
    while type(asttuple[1]) is TupleType:
        asttuple = asttuple[1]
    return asttuple[2]

</t>
<t tx="ekr.20100212224846.9852">def to_lineno(asttuple):
    """return the maximum line number of the given ast tuple"""
    while type(asttuple[1]) is TupleType:
        for i in xrange(len(asttuple) - 1, 0, -1):
            if asttuple[i][0] != DEDENT:
                asttuple = asttuple[i]
                break
        else:
            raise Exception()
    return asttuple[2]

</t>
<t tx="ekr.20100212224846.9853">def fix_lineno(node, fromast, toast=None, blockast=None):
    if getattr(node, 'fromlineno', None) is not None:
        return node
    if isinstance(node, nodes.Stmt):
        return node
    if toast is None or toast is fromast:
        node.fromlineno, node.tolineno = fromto_lineno(fromast)
    else:
        node.fromlineno, node.tolineno = from_lineno(fromast), to_lineno(toast)
    if blockast:
        node.blockstart_tolineno = to_lineno(blockast)
    return node

</t>
<t tx="ekr.20100212224846.9854">BaseTransformer = transformer.Transformer

COORD_MAP = {
    # if: test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
    'if': 0,
    # 'while' test ':' suite ['else' ':' suite]
    'while': 1,
    # 'for' exprlist 'in' exprlist ':' suite ['else' ':' suite]
    'for': 3,
    # 'try' ':' suite (except_clause ':' suite)+ ['else' ':' suite]
    'try': 0,
    # | 'try' ':' suite 'finally' ':' suite
    # XXX with
    }

def fixlineno_wrap(function, stype):
    def fixlineno_wrapper(self, nodelist):
        node = function(self, nodelist)
        try:
            blockstart_idx = COORD_MAP[stype]
        except KeyError:
            return fix_lineno(node, nodelist[0], nodelist[-1])
        else:
            return fix_lineno(node, nodelist[0], nodelist[-1], nodelist[blockstart_idx])
    return fixlineno_wrapper

</t>
<t tx="ekr.20100212224846.9855">class ASTNGTransformer(BaseTransformer):
    """ovverides transformer for a better source line number handling"""
    @others
</t>
<t tx="ekr.20100212224846.9856">def com_NEWLINE(self, *args):
    # A ';' at the end of a line can make a NEWLINE token appear
    # here, Render it harmless. (genc discards ('discard',
    # ('const', xxxx)) Nodes)
    lineno = args[0][1]
    # don't put fromlineno/tolineno on Const None to mark it as dynamically
    # added, without "physical" reference in the source
    n = nodes.Discard(nodes.Const(None))
    n.fromlineno = n.tolineno = lineno
    return n

</t>
<t tx="ekr.20100212224846.9857">def com_node(self, node):
    res = self._dispatch[node[0]](node[1:])
    return fix_lineno(res, node)

</t>
<t tx="ekr.20100212224846.9858">def com_assign(self, node, assigning):
    res = BaseTransformer.com_assign(self, node, assigning)
    return fix_lineno(res, node)

</t>
<t tx="ekr.20100212224846.9859">def com_apply_trailer(self, primaryNode, nodelist):
    node = BaseTransformer.com_apply_trailer(self, primaryNode, nodelist)
    return fix_lineno(node, nodelist)

</t>
<t tx="ekr.20100212224846.9860">def funcdef(self, nodelist):
    node = BaseTransformer.funcdef(self, nodelist)
    if node.decorators is not None:
        fix_lineno(node.decorators, nodelist[0])
    return fix_lineno(node, nodelist[-5], nodelist[-1], nodelist[-3])

</t>
<t tx="ekr.20100212224846.9861">def lambdef(self, nodelist):
    node = BaseTransformer.lambdef(self, nodelist)
    return fix_lineno(node, nodelist[1], nodelist[-1])

</t>
<t tx="ekr.20100212224846.9862">def classdef(self, nodelist):
    node = BaseTransformer.classdef(self, nodelist)
    return fix_lineno(node, nodelist[0], nodelist[-1], nodelist[-2])

</t>
<t tx="ekr.20100212224846.9863">def file_input(self, nodelist):
    node = BaseTransformer.file_input(self, nodelist)
    if node.node.nodes:
        node.tolineno = node.node.nodes[-1].tolineno
    else:
        node.tolineno = 0
    return node

</t>
<t tx="ekr.20100212224846.9864">@language python
@tabwidth -4

"""this module contains a set of functions to handle python protocols for nodes
where it makes sense.
"""

@others
</t>
<t tx="ekr.20100212224846.9865">from __future__ import generators

__doctype__ = "restructuredtext en"

from logilab.astng import InferenceError, NoDefault, _nodes as nodes
from logilab.astng.infutils import copy_context, unpack_infer, \
     raise_if_nothing_infered, yes_if_nothing_infered, Instance, Generator, YES
from logilab.astng._nodes import Const, Class, Function, Tuple, List, \
     const_factory
</t>
<t tx="ekr.20100212224846.9866">def tl_infer_unary_op(self, operator):
    if operator == 'not':
        return const_factory(not bool(self.elts))
    raise TypeError() # XXX log unsupported operation

nodes.Tuple.infer_unary_op = tl_infer_unary_op
nodes.List.infer_unary_op = tl_infer_unary_op


</t>
<t tx="ekr.20100212224846.9867">def dict_infer_unary_op(self, operator):
    if operator == 'not':
        return const_factory(not bool(self.items))
    raise TypeError() # XXX log unsupported operation

nodes.Dict.infer_unary_op = dict_infer_unary_op
</t>
<t tx="ekr.20100212224846.9868">def const_infer_unary_op(self, operator):
    if operator == 'not':
        return const_factory(not self.value)
    # XXX log potentialy raised TypeError
    elif operator == '+':
        return const_factory(+self.value)
    else: # operator == '-':
        return const_factory(-self.value)        

nodes.Const.infer_unary_op = const_infer_unary_op
</t>
<t tx="ekr.20100212224846.9869">def const_infer_binary_op(self, operator, other, context):
    for other in other.infer(context):
        if isinstance(other, Const):
            try:
                impl = BIN_OP_IMPL[operator]
                yield const_factory(impl(self.value, other.value))
            except TypeError:
                # XXX log TypeError
                continue
        elif other is YES:
            yield other
        else:
            try:
                for val in other.infer_binary_op(operator, self, context):
                    yield val
            except AttributeError:
                yield YES
                
nodes.Const.infer_binary_op = yes_if_nothing_infered(const_infer_binary_op)
</t>
<t tx="ekr.20100212224846.9870">def tl_infer_binary_op(self, operator, other, context):
    for other in other.infer(context):
        if isinstance(other, self.__class__) and operator == '+':
            node = self.__class__()
            elts = [n for elt in self.elts for n in elt.infer(context)]
            elts += [n for elt in other.elts for n in elt.infer(context)]
            node.elts = elts
            yield node
        elif isinstance(other, Const) and operator == '*':
            node = self.__class__()
            elts = [n for elt in self.elts for n in elt.infer(context)] * other.value
            node.elts = elts
            yield node
        elif isinstance(other, Instance) and not isinstance(other, Const):
            yield YES
    # XXX else log TypeError

nodes.Tuple.infer_binary_op = yes_if_nothing_infered(tl_infer_binary_op)
nodes.List.infer_binary_op = yes_if_nothing_infered(tl_infer_binary_op)
</t>
<t tx="ekr.20100212224846.9871">def dict_infer_binary_op(self, operator, other, context):
    for other in other.infer(context):
        if isinstance(other, Instance) and isinstance(other._proxied, Class):
            yield YES
        # XXX else log TypeError

nodes.Dict.infer_binary_op = yes_if_nothing_infered(dict_infer_binary_op)
</t>
<t tx="ekr.20100212224846.9872">"""the assigned_stmts method is responsible to return the assigned statement
(eg not infered) according to the assignment type.

The `asspath` argument is used to record the lhs path of the original node.
For instance if we want assigned statements for 'c' in 'a, (b,c)', asspath
will be [1, 1] once arrived to the Assign node.

The `context` argument is the current inference context which should be given
to any intermediary inference necessary.
"""

def _resolve_looppart(parts, asspath, context):
    """recursive function to resolve multiple assignments on loops"""
    asspath = asspath[:]
    index = asspath.pop(0)
    for part in parts:
        if part is YES:
            continue
        # XXX handle __iter__ and log potentially detected errors
        if not hasattr(part, 'itered'):
            continue
        try:
            itered = part.itered()
        except TypeError:
            continue # XXX log error
        for stmt in itered:
            try:
                assigned = stmt.getitem(index, context)
            except (AttributeError, IndexError):
                continue
            if not asspath:
                # we acheived to resolved the assigment path,
                # don't infer the last part
                yield assigned
            elif assigned is YES:
                break
            else:
                # we are not yet on the last part of the path
                # search on each possibly infered value
                try:
                    for infered in _resolve_looppart(assigned.infer(context), asspath, context):
                        yield infered
                except InferenceError:
                    break
</t>
<t tx="ekr.20100212224846.9873">def for_assigned_stmts(self, node, context=None, asspath=None):
    if asspath is None:
        for lst in self.iter.infer(context):
            if isinstance(lst, (Tuple, List)):
                for item in lst.elts:
                    yield item
    else:
        for infered in _resolve_looppart(self.iter.infer(context), asspath, context):
            yield infered

nodes.For.assigned_stmts = raise_if_nothing_infered(for_assigned_stmts)
nodes.Comprehension.assigned_stmts = raise_if_nothing_infered(for_assigned_stmts)
</t>
<t tx="ekr.20100212224846.9874">def mulass_assigned_stmts(self, node, context=None, asspath=None):
    if asspath is None:
        asspath = []
    asspath.insert(0, self.elts.index(node))
    return self.parent.assigned_stmts(self, context, asspath)

nodes.Tuple.assigned_stmts = mulass_assigned_stmts
nodes.List.assigned_stmts = mulass_assigned_stmts
</t>
<t tx="ekr.20100212224846.9875">def assend_assigned_stmts(self, context=None):
    return self.parent.assigned_stmts(self, context=context)    

nodes.AssName.assigned_stmts = assend_assigned_stmts
nodes.AssAttr.assigned_stmts = assend_assigned_stmts
</t>
<t tx="ekr.20100212224846.9876">def _arguments_infer_argname(self, name, context):
    # arguments informmtion may be missing, in which case we can't do anything
    # more
    if not (self.args or self.vararg or self.kwarg):
        yield YES
        return
    # first argument of instance/class method
    if self.args and getattr(self.args[0], 'name', None) == name:
        functype = self.parent.type
        if functype == 'method':
            yield Instance(self.parent.parent.frame())
            return
        if functype == 'classmethod':
            yield self.parent.parent.frame()
            return
    if name == self.vararg:
        yield const_factory(())
        return
    if name == self.kwarg:
        yield const_factory({})
        return
    # if there is a default value, yield it. And then yield YES to reflect
    # we can't guess given argument value
    try:
        context = copy_context(context)
        for infered in self.default_value(name).infer(context):
            yield infered
        yield YES
    except NoDefault:
        yield YES
</t>
<t tx="ekr.20100212224846.9877">def arguments_assigned_stmts(self, node, context, asspath=None):
    if context.callcontext:
        # reset call context/name
        callcontext = context.callcontext
        context = copy_context(context)
        context.callcontext = None
        for infered in callcontext.infer_argument(self.parent, node.name, context):
            yield infered
        return
    for infered in _arguments_infer_argname(self, node.name, context):
        yield infered

nodes.Arguments.assigned_stmts = arguments_assigned_stmts
</t>
<t tx="ekr.20100212224846.9878">def assign_assigned_stmts(self, node, context=None, asspath=None):
    if not asspath:
        yield self.value
        return
    for infered in _resolve_asspart(self.value.infer(context), asspath, context):
        yield infered

nodes.Assign.assigned_stmts = raise_if_nothing_infered(assign_assigned_stmts)
nodes.AugAssign.assigned_stmts = raise_if_nothing_infered(assign_assigned_stmts)
</t>
<t tx="ekr.20100212224846.9879">def _resolve_asspart(parts, asspath, context):
    """recursive function to resolve multiple assignments"""
    asspath = asspath[:]
    index = asspath.pop(0)
    for part in parts:
        if hasattr(part, 'getitem'):
            try:
                assigned = part.getitem(index, context)
            # XXX raise a specific exception to avoid potential hiding of
            # unexpected exception ?
            except (TypeError, IndexError):
                return
            if not asspath:
                # we acheived to resolved the assigment path, don't infer the
                # last part
                yield assigned
            elif assigned is YES:
                return
            else:
                # we are not yet on the last part of the path search on each
                # possibly infered value
                try:
                    for infered in _resolve_asspart(assigned.infer(context), 
                                                    asspath, context):
                        yield infered
                except InferenceError:
                    return
</t>
<t tx="ekr.20100212224846.9880">def excepthandler_assigned_stmts(self, node, context=None, asspath=None):
    for assigned in unpack_infer(self.type):
        if isinstance(assigned, Class):
            assigned = Instance(assigned)
        yield assigned

nodes.ExceptHandler.assigned_stmts = raise_if_nothing_infered(excepthandler_assigned_stmts)
</t>
<t tx="ekr.20100212224846.9881">def with_assigned_stmts(self, node, context=None, asspath=None):
    if asspath is None:
        for lst in self.vars.infer(context):
            if isinstance(lst, (Tuple, List)):
                for item in lst.nodes:
                    yield item

nodes.With.assigned_stmts = raise_if_nothing_infered(with_assigned_stmts)
</t>
<t tx="ekr.20100212224846.9882">def parent_ass_type(self, context=None):
    return self.parent.ass_type()

nodes.Tuple.ass_type   = parent_ass_type
nodes.List.ass_type    = parent_ass_type
nodes.AssName.ass_type = parent_ass_type
nodes.AssAttr.ass_type = parent_ass_type
nodes.DelName.ass_type = parent_ass_type
nodes.DelAttr.ass_type = parent_ass_type
</t>
<t tx="ekr.20100212224846.9883">def end_ass_type(self):
    return self

# XXX if you add ass_type to a class, you should probably modify
#     lookup.LookupMixIn.filter_stmts around line ::
#
#       if ass_type is mystmt and not isinstance(ass_type, (nodes.Class, ...)):
nodes.Arguments.ass_type        = end_ass_type
nodes.Assign.ass_type           = end_ass_type
nodes.AugAssign.ass_type        = end_ass_type
nodes.Class.ass_type            = end_ass_type
nodes.Comprehension.ass_type    = end_ass_type
nodes.Delete.ass_type           = end_ass_type
nodes.ExceptHandler.ass_type    = end_ass_type
nodes.For.ass_type              = end_ass_type
nodes.From.ass_type             = end_ass_type
nodes.Function.ass_type         = end_ass_type
nodes.Import.ass_type           = end_ass_type
nodes.With.ass_type             = end_ass_type


</t>
<t tx="ekr.20100212224846.9884">@language python
@tabwidth -4

"""this module contains a set of functions to create astng trees from scratch
(build_* functions) or from living object (object_build_* functions)
"""

@others

__all__ = (
    'register_arguments',  'build_module',
    'object_build_class', 'object_build_function',
    'object_build_datadescriptor', 'object_build_methoddescriptor',
    'attach_dummy_node',
    'attach_const_node', 'attach_import_node',
)
</t>
<t tx="ekr.20100212224846.9885">__docformat__ = "restructuredtext en"

import sys
from inspect import getargspec

from logilab.astng import nodes


</t>
<t tx="ekr.20100212224846.9886">def _attach_local_node(parent, node, name):
    node.name = name # needed by add_local_node
    parent.add_local_node(node)

</t>
<t tx="ekr.20100212224846.9887">_marker = object()

def attach_dummy_node(node, name, object=_marker):
    """create a dummy node and register it in the locals of the given
    node with the specified name
    """
    enode = nodes.EmptyNode()
    enode.object = object
    _attach_local_node(node, enode, name)

nodes.EmptyNode.has_underlying_object = lambda self: self.object is not _marker
</t>
<t tx="ekr.20100212224846.9888">def attach_const_node(node, name, value):
    """create a Const node and register it in the locals of the given
    node with the specified name
    """
    if not name in node.special_attributes:
        _attach_local_node(node, nodes.const_factory(value), name)

</t>
<t tx="ekr.20100212224846.9889">def attach_import_node(node, modname, membername):
    """create a From node and register it in the locals of the given
    node with the specified name
    """
    _attach_local_node(node, nodes.import_from_factory(modname, membername),
                       membername)


</t>
<t tx="ekr.20100212224846.9890">def build_module(name, doc=None):
    """create and initialize a astng Module node"""
    node = nodes.module_factory(doc)
    node.name = name
    node.pure_python = False
    node.package = False
    node.parent = None
    node.globals = node.locals = {}
    return node

</t>
<t tx="ekr.20100212224846.9891">def build_class(name, basenames=(), doc=None):
    """create and initialize a astng Class node"""
    node = nodes.class_factory(name, basenames, doc)
    node.locals = {}
    node.instance_attrs = {}
    return node

</t>
<t tx="ekr.20100212224846.9892">def build_function(name, args=None, defaults=None, flag=0, doc=None):
    """create and initialize a astng Function node"""
    args, defaults = args or [], defaults or []
    # first argument is now a list of decorators
    func = nodes.function_factory(name, args, defaults, flag, doc)
    func.locals = {}
    if args:
        register_arguments(func)
    return func


</t>
<t tx="ekr.20100212224846.9893"># def build_name_assign(name, value):
#     """create and initialize an astng Assign for a name assignment"""
#     return nodes.Assign([nodes.AssName(name, 'OP_ASSIGN')], nodes.Const(value))

# def build_attr_assign(name, value, attr='self'):
#     """create and initialize an astng Assign for an attribute assignment"""
#     return nodes.Assign([nodes.AssAttr(nodes.Name(attr), name, 'OP_ASSIGN')],
#                         nodes.Const(value))

if sys.version_info &lt; (2, 5):
    def build_from_import(fromname, names):
        """create and intialize an astng From import statement"""
        return nodes.From(fromname, [(name, None) for name in names])
else:
    def build_from_import(fromname, names):
        """create and intialize an astng From import statement"""
        return nodes.From(fromname, [(name, None) for name in names], 0)

def register_arguments(func, args=None):
    """add given arguments to local

    args is a list that may contains nested lists
    (i.e. def func(a, (b, c, d)): ...)
    """
    if args is None:
        args = func.args.args
        if func.args.vararg:
            func.set_local(func.args.vararg, func.args)
        if func.args.kwarg:
            func.set_local(func.args.kwarg, func.args)
    for arg in args:
        if isinstance(arg, nodes.Name):
            func.set_local(arg.id, arg)
        else:
            register_arguments(func, arg.elts)

</t>
<t tx="ekr.20100212224846.9894">def object_build_class(node, member, localname):
    """create astng for a living class object"""
    basenames = [base.__name__ for base in member.__bases__]
    return _base_class_object_build(node, member, basenames,
                                    localname=localname)

</t>
<t tx="ekr.20100212224846.9895">def object_build_function(node, member, localname):
    """create astng for a living function object"""
    args, varargs, varkw, defaults = getargspec(member)
    if varargs is not None:
        args.append(varargs)
    if varkw is not None:
        args.append(varkw)
    func = build_function(getattr(member, '__name__', None) or localname, args,
                          defaults, member.func_code.co_flags, member.__doc__)
    node.add_local_node(func, localname)

</t>
<t tx="ekr.20100212224846.9896">def object_build_datadescriptor(node, member, name):
    """create astng for a living data descriptor object"""
    return _base_class_object_build(node, member, [], name)

</t>
<t tx="ekr.20100212224846.9897">def object_build_methoddescriptor(node, member, localname):
    """create astng for a living method descriptor object"""
    # FIXME get arguments ?
    func = build_function(getattr(member, '__name__', None) or localname,
                          doc=member.__doc__)
    # set node's arguments to None to notice that we have no information, not
    # and empty argument list
    func.args.args = None
    node.add_local_node(func, localname)

</t>
<t tx="ekr.20100212224846.9898">def _base_class_object_build(node, member, basenames, name=None, localname=None):
    """create astng for a living class object, with a given set of base names
    (e.g. ancestors)
    """
    klass = build_class(name or getattr(member, '__name__', None) or localname,
                        basenames, member.__doc__)
    klass._newstyle = isinstance(member, type)
    node.add_local_node(klass, localname)
    try:
        # limit the instantiation trick since it's too dangerous
        # (such as infinite test execution...)
        # this at least resolves common case such as Exception.args,
        # OSError.errno
        if issubclass(member, Exception):
            instdict = member().__dict__
        else:
            raise TypeError
    except:
        pass
    else:
        for name, obj in instdict.items():
            valnode = nodes.EmptyNode()
            valnode.object = obj
            valnode.parent = klass
            valnode.lineno = 1
            klass.instance_attrs[name] = [valnode]
    return klass
</t>
<t tx="ekr.20100212224846.9899">@language python
@tabwidth -4


"""this module contains utilities for rebuilding a compiler.ast or _ast tree in
order to get a single ASTNG representation
"""

@others
</t>
<t tx="ekr.20100212224846.9900">from logilab.astng import ASTNGBuildingException, InferenceError, NodeRemoved
from logilab.astng import nodes
from logilab.astng.utils import ASTVisitor
from logilab.astng.infutils import YES, Instance


CONST_NAME_TRANSFORMS = {'None':  (nodes.Const, None),
                         'True':  (nodes.Const, True),
                         'False': (nodes.Const, False)}

</t>
<t tx="ekr.20100212224846.9901">class RebuildVisitor(ASTVisitor):
    """Visitor to transform an AST to an ASTNG
    """
    @others
</t>
<t tx="ekr.20100212224846.9902">def __init__(self):
    self.asscontext = None
    self._metaclass = None
    self._global_names = None
    self._delayed = []
    self.rebuilder = nodes.TreeRebuilder(self)
    self.set_line_info = nodes.AST_MODE == '_ast'

</t>
<t tx="ekr.20100212224846.9903">def _push(self, node):
    """update the stack and init some parts of the Function or Class node
    """
    node.locals = {}
    node.parent.frame().set_local(node.name, node)

</t>
<t tx="ekr.20100212224846.9904">def set_asscontext(self, node, childnode):
    """set assignment /delete context needed later on by the childnode"""
    # XXX refactor this method at least, but killing .asscontext  would be better
    if isinstance(node, (nodes.Delete, nodes.Assign)):
        if childnode in node.targets:
            self.asscontext = node
        else:
            self.asscontext = None
    elif isinstance(node, (nodes.AugAssign, nodes.Comprehension, nodes.For)):
        if childnode is node.target:
            self.asscontext = node
        else:
            self.asscontext = None
    elif isinstance(node, nodes.Arguments):
        if childnode in node.args:
            self.asscontext = node
        else:
            self.asscontext = None
    elif isinstance(node, nodes.With):
        if childnode is node.vars:
            self.asscontext = node
        else:
            self.asscontext = None
    elif isinstance(node, nodes.ExceptHandler):
        if childnode is node.name:
            self.asscontext = node
        else:
            self.asscontext = None

</t>
<t tx="ekr.20100212224846.9905"># take node arguments to be usable as visit/leave methods
def push_asscontext(self, node=None):
    self.__asscontext = self.asscontext
    self.asscontext = None
    return True
</t>
<t tx="ekr.20100212224846.9906">def pop_asscontext(self, node=None):
    self.asscontext = self.__asscontext
    self.__asscontext = None

</t>
<t tx="ekr.20100212224846.9907">def walk(self, node):
    self._walk(node)
    delayed = self._delayed
    while delayed:
        dnode = delayed.pop(0)
        node_name = dnode.__class__.__name__.lower()
        self.delayed_visit_assattr(dnode)

</t>
<t tx="ekr.20100212224846.9908">def _walk(self, node, parent=None):
    """default visit method, handle the parent attribute"""
    node.parent = parent
    try:
        node.accept(self.rebuilder)
    except NodeRemoved:
        return
    handle_leave = node.accept(self)
    child = None
    # XXX tuple necessary since node removal may modify children
    #     find a trick to avoid tuple() or make get_children() returning a list)
    for child in tuple(node.get_children()):
        self.set_asscontext(node, child)
        self._walk(child, node)
        if self.asscontext is child:
            self.asscontext = None
    if self.set_line_info:
        node.set_line_info(child)
    if handle_leave:
        leave = getattr(self, "leave_" + node.__class__.__name__.lower())
        leave(node)


</t>
<t tx="ekr.20100212224846.9909"># general visit_&lt;node&gt; methods ############################################

def visit_arguments(self, node):
    if node.vararg:
        node.parent.set_local(node.vararg, node)
    if node.kwarg:
        node.parent.set_local(node.kwarg, node)

</t>
<t tx="ekr.20100212224846.9910">def visit_assign(self, node):
    return True

</t>
<t tx="ekr.20100212224846.9911">def leave_assign(self, node):
    """leave an Assign node to become astng"""
    klass = node.parent.frame()
    if (isinstance(klass, nodes.Class)
        and isinstance(node.value, nodes.CallFunc)
        and isinstance(node.value.func, nodes.Name)):
        func_name = node.value.func.name
        for ass_node in node.targets:
            try:
                meth = klass[ass_node.name]
                if isinstance(meth, nodes.Function):
                    if func_name in ('classmethod', 'staticmethod'):
                        meth.type = func_name
                    try:
                        meth.extra_decorators.append(node.value)
                    except AttributeError:
                        meth.extra_decorators = [node.value]
            except (AttributeError, KeyError):
                continue
    elif getattr(node.targets[0], 'name', None) == '__metaclass__': # XXX check more...
        self._metaclass[-1] = 'type' # XXX get the actual metaclass

</t>
<t tx="ekr.20100212224846.9912">def visit_class(self, node):
    """visit an Class node to become astng"""
    node.instance_attrs = {}
    self._push(node)
    self._metaclass.append(self._metaclass[-1])
    return True

</t>
<t tx="ekr.20100212224846.9913">def leave_class(self, node):
    """leave a Class node -&gt; pop the last item on the stack"""
    metaclass = self._metaclass.pop()
    if not node.bases:
        # no base classes, detect new / style old style according to
        # current scope
        node._newstyle = metaclass == 'type'

</t>
<t tx="ekr.20100212224846.9914">leave_classdef = leave_class

def visit_decorators(self, node):
    """visiting an Decorators node: return True for leaving"""
    return True

</t>
<t tx="ekr.20100212224846.9915">def leave_decorators(self, node):
    """python &gt;= 2.4
    visit a Decorator node -&gt; check for classmethod and staticmethod
    """
    for decorator_expr in node.nodes:
        if isinstance(decorator_expr, nodes.Name) and \
               decorator_expr.name in ('classmethod', 'staticmethod'):
            node.parent.type = decorator_expr.name

</t>
<t tx="ekr.20100212224846.9916">def visit_from(self, node):
    """visit an From node to become astng"""
    # add names imported by the import to locals
    for (name, asname) in node.names:
        if name == '*':
            try:
                imported = node.root().import_module(node.modname)
            except ASTNGBuildingException:
                continue
            for name in imported.wildcard_import_names():
                node.parent.set_local(name, node)
        else:
            node.parent.set_local(asname or name, node)

</t>
<t tx="ekr.20100212224846.9917">def visit_function(self, node):
    """visit an Function node to become astng"""
    self._global_names.append({})
    if isinstance(node.parent.frame(), nodes.Class):
        if node.name == '__new__':
            node.type = 'classmethod'
        else:
            node.type = 'method'
    self._push(node)
    return True

</t>
<t tx="ekr.20100212224846.9918">def leave_function(self, node):
    """leave a Function node -&gt; pop the last item on the stack"""
    self._global_names.pop()
</t>
<t tx="ekr.20100212224846.9919">leave_functiondef = leave_function

def visit_genexpr(self, node):
    """visit an ListComp node to become astng"""
    node.locals = {}

</t>
<t tx="ekr.20100212224846.9920">def visit_assattr(self, node):
    """visit an Getattr node to become astng"""
    self._delayed.append(node) # FIXME
    self.push_asscontext()
    return True        
</t>
<t tx="ekr.20100212224846.9921">visit_delattr = visit_assattr

def leave_assattr(self, node):
    """visit an Getattr node to become astng"""
    self._delayed.append(node) # FIXME
    self.pop_asscontext()
</t>
<t tx="ekr.20100212224846.9922">leave_delattr = leave_assattr

def visit_global(self, node):
    """visit an Global node to become astng"""
    if not self._global_names: # global at the module level, no effect
        return
    for name in node.names:
        self._global_names[-1].setdefault(name, []).append(node)

</t>
<t tx="ekr.20100212224846.9923">def visit_import(self, node):
    """visit an Import node to become astng"""
    for (name, asname) in node.names:
        name = asname or name
        node.parent.set_local(name.split('.')[0], node)

</t>
<t tx="ekr.20100212224846.9924">def visit_lambda(self, node):
    """visit an Keyword node to become astng"""
    node.locals = {}

</t>
<t tx="ekr.20100212224846.9925">def visit_module(self, node):
    """visit an Module node to become astng"""
    self._metaclass = ['']
    self._global_names = []
    node.globals = node.locals = {}

</t>
<t tx="ekr.20100212224846.9926">def visit_name(self, node):
    """visit an Name node to become astng"""
    try:
        cls, value = CONST_NAME_TRANSFORMS[node.name]
        node.__class__ = cls
        node.value = value
    except KeyError:
        pass

</t>
<t tx="ekr.20100212224846.9927">def visit_assname(self, node):
    if self.asscontext is not None:
        if self._global_names and node.name in self._global_names[-1]:
            node.root().set_local(node.name, node)
        else:
            node.parent.set_local(node.name, node)
</t>
<t tx="ekr.20100212224846.9928">visit_delname = visit_assname

visit_subscript = push_asscontext
leave_subscript = pop_asscontext

def delayed_visit_assattr(self, node):
    """visit a AssAttr node -&gt; add name to locals, handle members
    definition
    """
    try:
        frame = node.frame()
        for infered in node.expr.infer():
            if infered is YES:
                continue
            try:
                if infered.__class__ is Instance:
                    infered = infered._proxied
                    iattrs = infered.instance_attrs
                elif isinstance(infered, Instance):
                    # Const, Tuple, ... we may be wrong, may be not, but
                    # anyway we don't want to pollute builtin's namespace
                    continue
                else:
                    iattrs = infered.locals
            except AttributeError:
                # XXX log error
                #import traceback
                #traceback.print_exc()
                continue
            values = iattrs.setdefault(node.attrname, [])
            if node in values:
                continue
            # get assign in __init__ first XXX useful ?
            if frame.name == '__init__' and values and not \
                   values[0].frame().name == '__init__':
                values.insert(0, node)
            else:
                values.append(node)
    except InferenceError:
        pass
</t>
<t tx="ekr.20100212224846.9929">@language python
@tabwidth -4

"""This module extends ast "scoped" node, i.e. which are opening a new
local scope in the language definition : Module, Class, Function (and
Lambda to some extends).

All new methods and attributes added on each class are documented
below.
"""

@others
</t>
<t tx="ekr.20100212224846.9930">from __future__ import generators

__doctype__ = "restructuredtext en"

import __builtin__
import sys

from logilab.common.compat import chain, set
from logilab.common.decorators import cached

from logilab.astng import MANAGER, NotFoundError, NoDefault, \
     ASTNGBuildingException, InferenceError
from logilab.astng._nodes import (Arguments, Class, Const, Dict, From, Function,
     GenExpr, Lambda, List, Module, Name, Pass, Raise, Return, Tuple, Yield,
     AssName, DelAttr, DelName, const_factory as cf, NodeNG, StmtMixIn)

from logilab.astng.infutils import YES, InferenceContext, Instance, Generator, \
     UnboundMethod, BoundMethod, copy_context, unpack_infer, _infer_stmts
from logilab.astng.nodes_as_string import as_string
from logilab.astng.lookup import LookupMixIn, LocalsDictMixIn

</t>
<t tx="ekr.20100212224846.9931">def remove_nodes(func, cls):
    def wrapper(*args, **kwargs):
        nodes = [n for n in func(*args, **kwargs) if not isinstance(n, cls)]
        if not nodes:
            raise NotFoundError()
        return nodes
    return wrapper


</t>
<t tx="ekr.20100212224846.9932">def function_to_method(n, klass):
    if isinstance(n, Function):
        if n.type == 'classmethod':
            return BoundMethod(n, klass)
        if n.type != 'staticmethod':
            return UnboundMethod(n)
    return n

</t>
<t tx="ekr.20100212224846.9933">def std_special_attributes(self, name, add_locals=True):
    if add_locals:
        locals = self.locals
    else:
        locals = {}
    if name == '__name__':
        return [cf(self.name)] + locals.get(name, [])
    if name == '__doc__':
        return [cf(self.doc)] + locals.get(name, [])
    if name == '__dict__':
        return [Dict()] + locals.get(name, [])
    raise NotFoundError(name)


</t>
<t tx="ekr.20100212224846.9934"># Module  #####################################################################

class ModuleNG(LookupMixIn, LocalsDictMixIn, NodeNG):
    """/!\ this class should not be used directly /!\ it's
    only used as a methods and attribute container, and update the
    original class from the compiler.ast module using its dictionary
    (see below the class definition)
    """
    fromlineno = 0
    lineno = 0

    # attributes below are set by the builder module or by raw factories

    # the file from which as been extracted the astng representation. It may
    # be None if the representation has been built from a built-in module
    file = None
    # the module name
    name = None
    # boolean for astng built from source (i.e. ast)
    pure_python = None
    # boolean for package module
    package = None
    # dictionary of globals with name as key and node defining the global
    # as value
    globals = None

    # names of python special attributes (handled by getattr impl.)
    special_attributes = set(('__name__', '__doc__', '__file__', '__path__',
                              '__dict__'))
    # names of module attributes available through the global scope
    scope_attrs = set(('__name__', '__doc__', '__file__', '__path__'))

    @others
</t>
<t tx="ekr.20100212224846.9935"># Module is not a Statement node but needs the replace method (see StmtMixIn)
def replace(self, child, newchild):
    sequence = self.child_sequence(child)
    newchild.parent = self
    child.parent = None
    sequence[sequence.index(child)] = newchild

</t>
<t tx="ekr.20100212224846.9936">def block_range(self, lineno):
    """return block line numbers.

    start from the "class" position whatever the given lineno
    """
    return self.fromlineno, self.tolineno

</t>
<t tx="ekr.20100212224846.9937">def scope_lookup(self, node, name, offset=0):
    if name in self.scope_attrs and not name in self.locals:
        try:
            return self, self.getattr(name)
        except NotFoundError:
            return self, ()
    return self._scope_lookup(node, name, offset)

</t>
<t tx="ekr.20100212224846.9938">def pytype(self):
    return '__builtin__.module'

</t>
<t tx="ekr.20100212224846.9939">def display_type(self):
    return 'Module'

</t>
<t tx="ekr.20100212224846.9940">def getattr(self, name, context=None):
    if not name in self.special_attributes:
        try:
            return self.locals[name]
        except KeyError:
            pass
    else:
        if name == '__file__':
            return [cf(self.file)] + self.locals.get(name, [])
        if name == '__path__':
            if self.package:
                return [List()] + self.locals.get(name, [])
        return std_special_attributes(self, name)
    if self.package:
        try:
            return [self.import_module(name, relative_only=True)]
        except (KeyboardInterrupt, SystemExit):
            raise
        except:
            pass
    raise NotFoundError(name)
</t>
<t tx="ekr.20100212224846.9941">getattr = remove_nodes(getattr, DelName)

def igetattr(self, name, context=None):
    """infered getattr"""
    # set lookup name since this is necessary to infer on import nodes for
    # instance
    context = copy_context(context)
    context.lookupname = name
    try:
        return _infer_stmts(self.getattr(name, context), context, frame=self)
    except NotFoundError:
        raise InferenceError(name)

</t>
<t tx="ekr.20100212224846.9942">def fully_defined(self):
    """return True if this module has been built from a .py file
    and so contains a complete representation including the code
    """
    return self.file is not None and self.file.endswith('.py')

</t>
<t tx="ekr.20100212224846.9943">def statement(self):
    """return the first parent node marked as statement node
    consider a module as a statement...
    """
    return self

</t>
<t tx="ekr.20100212224846.9944">def previous_sibling(self):
    """module has no sibling"""
    return

</t>
<t tx="ekr.20100212224846.9945">def next_sibling(self):
    """module has no sibling"""
    return

</t>
<t tx="ekr.20100212224846.9946">def absolute_import_activated(self):
    for stmt in self.locals.get('absolute_import', ()):
        if isinstance(stmt, From) and stmt.modname == '__future__':
            return True
    return False

</t>
<t tx="ekr.20100212224846.9947">def import_module(self, modname, relative_only=False, level=None):
    """import the given module considering self as context"""
    try:
        absmodname = self.absolute_modname(modname, level)
        return MANAGER.astng_from_module_name(absmodname)
    except ASTNGBuildingException:
        # we only want to import a sub module or package of this module,
        # skip here
        if relative_only:
            raise
    module = MANAGER.astng_from_module_name(modname)
    return module

</t>
<t tx="ekr.20100212224846.9948">def absolute_modname(self, modname, level):
    if self.absolute_import_activated() and not level:
        return modname
    if level:
        parts = self.name.split('.')
        if self.package:
            parts.append('__init__')
        package_name = '.'.join(parts[:-level])
    elif self.package:
        package_name = self.name
    else:
        package_name = '.'.join(self.name.split('.')[:-1])
    if package_name:
        return '%s.%s' % (package_name, modname)
    return modname

</t>
<t tx="ekr.20100212224846.9949">def wildcard_import_names(self):
    """return the list of imported names when this module is 'wildard
    imported'

    It doesn't include the '__builtins__' name which is added by the
    current CPython implementation of wildcard imports.
    """
    # take advantage of a living module if it exists
    try:
        living = sys.modules[self.name]
    except KeyError:
        pass
    else:
        try:
            return living.__all__
        except AttributeError:
            return [name for name in living.__dict__.keys()
                    if not name.startswith('_')]
    # else lookup the astng
    #
    # We separate the different steps of lookup in try/excepts
    # to avoid catching too many Exceptions
    # However, we can not analyse dynamically constructed __all__
    try:
        all = self['__all__']
    except KeyError:
        return [name for name in self.keys() if not name.startswith('_')]
    try:
        explicit = all.assigned_stmts().next()
    except InferenceError:
        return [name for name in self.keys() if not name.startswith('_')]
    try:
        # should be a Tuple/List of constant string / 1 string not allowed
        return [const.value for const in explicit.elts]
    except AttributeError:
        return [name for name in self.keys() if not name.startswith('_')]


</t>
<t tx="ekr.20100212224846.9950">class GenExprNG(LookupMixIn, LocalsDictMixIn, NodeNG):
    """class representing a GenExpr node"""
    @others
</t>
<t tx="ekr.20100212224846.9951">
def frame(self):
    return self.parent.frame()


</t>
<t tx="ekr.20100212224846.9952"># Function  ###################################################################

class LambdaNG(LookupMixIn, LocalsDictMixIn, NodeNG):
    """/!\ this class should not be used directly /!\ it's
    only used as a methods and attribute container, and update the
    original class from the compiler.ast module using its dictionary
    (see below the class definition)
    """

    # function's type, 'function' | 'method' | 'staticmethod' | 'classmethod'
    type = 'function'

    @others
</t>
<t tx="ekr.20100212224846.9953">def pytype(self):
    if 'method' in self.type:
        return '__builtin__.instancemethod'
    return '__builtin__.function'

</t>
<t tx="ekr.20100212224846.9954">def display_type(self):
    if 'method' in self.type:
        return 'Method'
    return 'Function'

</t>
<t tx="ekr.20100212224846.9955">def callable(self):
    return True

</t>
<t tx="ekr.20100212224846.9956">def argnames(self):
    """return a list of argument names"""
    if self.args.args: # maybe None with builtin functions
        names = _rec_get_names(self.args.args)
    else:
        names = []
    if self.args.vararg:
        names.append(self.args.vararg)
    if self.args.kwarg:
        names.append(self.args.kwarg)
    return names

</t>
<t tx="ekr.20100212224846.9957">def infer_call_result(self, caller, context=None):
    """infer what a function is returning when called"""
    return self.body.infer(context)

</t>
<t tx="ekr.20100212224846.9958">def scope_lookup(self, node, name, offset=0):
    if node in self.args.defaults:
        frame = self.parent.frame()
        # line offset to avoid that def func(f=func) resolve the default
        # value to the defined function
        offset = -1
    else:
        # check this is not used in function decorators
        frame = self
    return frame._scope_lookup(node, name, offset)


</t>
<t tx="ekr.20100212224846.9959">class FunctionNG(LambdaNG, LookupMixIn, LocalsDictMixIn, StmtMixIn, NodeNG):
    """/!\ this class should not be used directly /!\ it's
    only used as a methods and attribute container, and update the
    original class from the compiler.ast module using its dictionary
    (see below the class definition)
    """


    special_attributes = set(('__name__', '__doc__', '__dict__'))
    # attributes below are set by the builder module or by raw factories

    blockstart_tolineno = None


    @others
</t>
<t tx="ekr.20100212224846.9960">def set_line_info(self, lastchild):
    self.fromlineno = self.lineno
    # lineno is the line number of the first decorator, we want the def statement lineno
    if self.decorators is not None:
        self.fromlineno += len(self.decorators.nodes)
    self.tolineno = lastchild.tolineno
    self.blockstart_tolineno = self.args.tolineno

</t>
<t tx="ekr.20100212224846.9961">def block_range(self, lineno):
    """return block line numbers.

    start from the "class" position whatever the given lineno
    """
    return self.fromlineno, self.tolineno

</t>
<t tx="ekr.20100212224846.9962">def getattr(self, name, context=None):
    """this method doesn't look in the instance_attrs dictionary since it's
    done by an Instance proxy at inference time.
    """
    if name == '__module__':
        return [cf(self.root().qname())]
    return std_special_attributes(self, name, False)

</t>
<t tx="ekr.20100212224846.9963">def is_method(self):
    """return true if the function node should be considered as a method"""
    # check we are defined in a Class, because this is usually expected
    # (eg pylint...) when is_method() return True
    return self.type != 'function' and isinstance(self.parent.frame(), Class)

</t>
<t tx="ekr.20100212224846.9964">@cached
def decoratornames(self):
    """return a list of decorator qualified names"""
    result = set()
    decoratornodes = []
    if self.decorators is not None:
        decoratornodes += self.decorators.nodes
    decoratornodes += getattr(self, 'extra_decorators', [])
    for decnode in decoratornodes:
        for infnode in decnode.infer():
            result.add(infnode.qname())
    return result


</t>
<t tx="ekr.20100212224846.9965">def is_bound(self):
    """return true if the function is bound to an Instance or a class"""
    return self.type == 'classmethod'

</t>
<t tx="ekr.20100212224846.9966">def is_abstract(self, pass_is_abstract=True):
    """return true if the method is abstract
    It's considered as abstract if the only statement is a raise of
    NotImplementError, or, if pass_is_abstract, a pass statement
    """
    for child_node in self.body:
        if isinstance(child_node, Raise) and child_node.type:
            try:
                name = child_node.type.nodes_of_class(Name).next()
                if name.name == 'NotImplementedError':
                    return True
            except StopIteration:
                pass
        if pass_is_abstract and isinstance(child_node, Pass):
            return True
        return False
    # empty function is the same as function with a single "pass" statement
    if pass_is_abstract:
        return True

</t>
<t tx="ekr.20100212224846.9967">def is_generator(self):
    """return true if this is a generator function"""
    # XXX should be flagged, not computed
    try:
        return self.nodes_of_class(Yield, skip_klass=Function).next()
    except StopIteration:
        return False

</t>
<t tx="ekr.20100212224846.9968">def infer_call_result(self, caller, context=None):
    """infer what a function is returning when called"""
    if self.is_generator():
        yield Generator(self)
        return
    returns = self.nodes_of_class(Return, skip_klass=Function)
    for returnnode in returns:
        if returnnode.value is None:
            yield None
        else:
            try:
                for infered in returnnode.value.infer(context):
                    yield infered
            except InferenceError:
                yield YES



</t>
<t tx="ekr.20100212224846.9969">def _rec_get_names(args, names=None):
    """return a list of all argument names"""
    if names is None:
        names = []
    for arg in args:
        if isinstance(arg, Tuple):
            _rec_get_names(arg.elts, names)
        else:
            names.append(arg.name)
    return names


</t>
<t tx="ekr.20100212224846.9970">def _format_args(args, defaults=None):
    values = []
    if args is None:
        return ''
    if defaults is not None:
        default_offset = len(args) - len(defaults)
    for i, arg in enumerate(args):
        if isinstance(arg, Tuple):
            values.append('(%s)' % _format_args(arg.elts))
        else:
            values.append(arg.name)
            if defaults is not None and i &gt;= default_offset:
                values[-1] += '=' + defaults[i-default_offset].as_string()
    return ', '.join(values)


</t>
<t tx="ekr.20100212224846.9971"># Class ######################################################################

def _class_type(klass):
    """return a Class node type to differ metaclass, interface and exception
    from 'regular' classes
    """
    if klass._type is not None:
        return klass._type
    if klass.name == 'type':
        klass._type = 'metaclass'
    elif klass.name.endswith('Interface'):
        klass._type = 'interface'
    elif klass.name.endswith('Exception'):
        klass._type = 'exception'
    else:
        for base in klass.ancestors(recurs=False):
            if base.type != 'class':
                klass._type = base.type
                break
    if klass._type is None:
        klass._type = 'class'
    return klass._type

</t>
<t tx="ekr.20100212224846.9972">def _iface_hdlr(iface_node):
    """a handler function used by interfaces to handle suspicious
    interface nodes
    """
    return True


</t>
<t tx="ekr.20100212224846.9973">class ClassNG(LookupMixIn, LocalsDictMixIn,  StmtMixIn, NodeNG):
    """/!\ this class should not be used directly /!\ it's
    only used as a methods and attribute container, and update the
    original class from the compiler.ast module using its dictionary
    (see below the class definition)
    """
    special_attributes = set(('__name__', '__doc__', '__dict__', '__module__',
                              '__bases__', '__mro__'))

    blockstart_tolineno = None

    _type = None
    type = property(_class_type,
                    doc="class'type, possible values are 'class' | "
                    "'metaclass' | 'interface' | 'exception'")

    @others
</t>
<t tx="ekr.20100212224846.9974">def _newstyle_impl(self, context=None):
    if context is None:
        context = InferenceContext()
    if self._newstyle is not None:
        return self._newstyle
    for base in self.ancestors(recurs=False, context=context):
        if base._newstyle_impl(context):
            self._newstyle = True
            break
    if self._newstyle is None:
        self._newstyle = False
    return self._newstyle

</t>
<t tx="ekr.20100212224846.9975">_newstyle = None
newstyle = property(_newstyle_impl,
                    doc="boolean indicating if it's a new style class"
                    "or not")

def set_line_info(self, lastchild):
    self.fromlineno = self.lineno
    self.blockstart_tolineno = self.bases and self.bases[-1].tolineno or self.fromlineno
    if lastchild is not None:
        self.tolineno = lastchild.tolineno
    # else this is a class with only a docstring, then tolineno is (should be) already ok

</t>
<t tx="ekr.20100212224846.9976">def block_range(self, lineno):
    """return block line numbers.

    start from the "class" position whatever the given lineno
    """
    return self.fromlineno, self.tolineno

</t>
<t tx="ekr.20100212224846.9977">def pytype(self):
    if self.newstyle:
        return '__builtin__.type'
    return '__builtin__.classobj'

</t>
<t tx="ekr.20100212224846.9978">def display_type(self):
    return 'Class'

</t>
<t tx="ekr.20100212224846.9979">def callable(self):
    return True

</t>
<t tx="ekr.20100212224846.9980">def infer_call_result(self, caller, context=None):
    """infer what a class is returning when called"""
    yield Instance(self)

</t>
<t tx="ekr.20100212224846.9981">def scope_lookup(self, node, name, offset=0):
    if node in self.bases:
        frame = self.parent.frame()
        # line offset to avoid that class A(A) resolve the ancestor to
        # the defined class
        offset = -1
    else:
        frame = self
    return frame._scope_lookup(node, name, offset)

</t>
<t tx="ekr.20100212224846.9982"># attributes below are set by the builder module or by raw factories

# a dictionary of class instances attributes
instance_attrs = None

# list of parent class as a list of string (ie names as they appears
# in the class definition) XXX bw compat
def basenames(self):
    return [as_string(bnode) for bnode in self.bases]
</t>
<t tx="ekr.20100212224846.9983">basenames = property(basenames)

def ancestors(self, recurs=True, context=None):
    """return an iterator on the node base classes in a prefixed
    depth first order

    :param recurs:
      boolean indicating if it should recurse or return direct
      ancestors only
    """
    # FIXME: should be possible to choose the resolution order
    # XXX inference make infinite loops possible here (see BaseTransformer
    # manipulation in the builder module for instance !)
    if context is None:
        context = InferenceContext()
    for stmt in self.bases:
        try:
            for baseobj in stmt.infer(context):
                if not isinstance(baseobj, Class):
                    # duh ?
                    continue
                if baseobj is self:
                    continue # cf xxx above
                yield baseobj
                if recurs:
                    for grandpa in baseobj.ancestors(True, context):
                        if grandpa is self:
                            continue # cf xxx above
                        yield grandpa
        except InferenceError:
            # XXX log error ?
            continue

</t>
<t tx="ekr.20100212224846.9984">def local_attr_ancestors(self, name, context=None):
    """return an iterator on astng representation of parent classes
    which have &lt;name&gt; defined in their locals
    """
    for astng in self.ancestors(context=context):
        if astng.locals.has_key(name):
            yield astng

</t>
<t tx="ekr.20100212224846.9985">def instance_attr_ancestors(self, name, context=None):
    """return an iterator on astng representation of parent classes
    which have &lt;name&gt; defined in their instance attribute dictionary
    """
    for astng in self.ancestors(context=context):
        if astng.instance_attrs.has_key(name):
            yield astng

</t>
<t tx="ekr.20100212224846.9986">def local_attr(self, name, context=None):
    """return the list of assign node associated to name in this class
    locals or in its parents

    :raises `NotFoundError`:
      if no attribute with this name has been find in this class or
      its parent classes
    """
    try:
        return self.locals[name]
    except KeyError:
        # get if from the first parent implementing it if any
        for class_node in self.local_attr_ancestors(name, context):
            return class_node.locals[name]
    raise NotFoundError(name)
</t>
<t tx="ekr.20100212224846.9987">local_attr = remove_nodes(local_attr, DelAttr)

def instance_attr(self, name, context=None):
    """return the astng nodes associated to name in this class instance
    attributes dictionary and in its parents

    :raises `NotFoundError`:
      if no attribute with this name has been find in this class or
      its parent classes
    """
    values = self.instance_attrs.get(name, [])
    # get if from the first parent implementing it if any
    for class_node in self.instance_attr_ancestors(name, context):
        values += class_node.instance_attrs[name]
    if not values:
        raise NotFoundError(name)
    return values
</t>
<t tx="ekr.20100212224846.9988">instance_attr = remove_nodes(instance_attr, DelAttr)

def getattr(self, name, context=None):
    """this method doesn't look in the instance_attrs dictionary since it's
    done by an Instance proxy at inference time.

    It may return a YES object if the attribute has not been actually
    found but a __getattr__ or __getattribute__ method is defined
    """
    values = self.locals.get(name, [])
    if name in self.special_attributes:
        if name == '__module__':
            return [cf(self.root().qname())] + values
        if name == '__bases__':
            return [cf(tuple(self.ancestors(recurs=False, context=context)))] + values
        # XXX need proper meta class handling + MRO implementation
        if name == '__mro__' and self.newstyle:
            # XXX mro is read-only but that's not our job to detect that
            return [cf(tuple(self.ancestors(recurs=True, context=context)))] + values
        return std_special_attributes(self, name)
    # don't modify the list in self.locals!
    values = list(values)
    for classnode in self.ancestors(recurs=False, context=context):
        try:
            values += classnode.getattr(name, context)
        except NotFoundError:
            continue
    if not values:
        raise NotFoundError(name)
    return values

</t>
<t tx="ekr.20100212224846.9989">def igetattr(self, name, context=None):
    """infered getattr, need special treatment in class to handle
    descriptors
    """
    # set lookoup name since this is necessary to infer on import nodes for
    # instance
    context = copy_context(context)
    context.lookupname = name
    try:
        for infered in _infer_stmts(self.getattr(name, context), context,
                                    frame=self):
            # yield YES object instead of descriptors when necessary
            if not isinstance(infered, Const) and isinstance(infered, Instance):
                try:
                    infered._proxied.getattr('__get__', context)
                except NotFoundError:
                    yield infered
                else:
                    yield YES
            else:
                yield function_to_method(infered, self)
    except NotFoundError:
        if not name.startswith('__') and self.has_dynamic_getattr(context):
            # class handle some dynamic attributes, return a YES object
            yield YES
        else:
            raise InferenceError(name)

</t>
<t tx="ekr.20100212224846.9990">def has_dynamic_getattr(self, context=None):
    """return True if the class has a custom __getattr__ or
    __getattribute__ method
    """
    # need to explicitly handle optparse.Values (setattr is not detected)
    if self.name == 'Values' and self.root().name == 'optparse':
        return True
    try:
        self.getattr('__getattr__', context)
        return True
    except NotFoundError:
        #if self.newstyle: XXX cause an infinite recursion error
        try:
            getattribute = self.getattr('__getattribute__', context)[0]
            if getattribute.root().name != '__builtin__':
                # class has a custom __getattribute__ defined
                return True
        except NotFoundError:
            pass
    return False

</t>
<t tx="ekr.20100212224846.9991">def methods(self):
    """return an iterator on all methods defined in the class and
    its ancestors
    """
    done = {}
    for astng in chain(iter((self,)), self.ancestors()):
        for meth in astng.mymethods():
            if done.has_key(meth.name):
                continue
            done[meth.name] = None
            yield meth

</t>
<t tx="ekr.20100212224846.9992">def mymethods(self):
    """return an iterator on all methods defined in the class"""
    for member in self.values():
        if isinstance(member, Function):
            yield member

</t>
<t tx="ekr.20100212224846.9993">def interfaces(self, herited=True, handler_func=_iface_hdlr):
    """return an iterator on interfaces implemented by the given
    class node
    """
    # FIXME: what if __implements__ = (MyIFace, MyParent.__implements__)...
    try:
        implements = Instance(self).getattr('__implements__')[0]
    except NotFoundError:
        return
    if not herited and not implements.frame() is self:
        return
    found = set()
    for iface in unpack_infer(implements):
        if iface is YES:
            continue
        if not iface in found and handler_func(iface):
            found.add(iface)
            yield iface
    if not found:
        raise InferenceError()


</t>
<t tx="ekr.20100212224846.9994">@language python
@tabwidth -4

"""this module contains some utilities to navigate in the tree or to
extract information from it
"""

@others

__all__ = (
    'REDIRECT', 'LocalsVisitor', 'ASTWalker', 'ASTVisitor', 
    'extend_class')

</t>
<t tx="ekr.20100212224846.9995">__docformat__ = "restructuredtext en"

from logilab.astng._exceptions import IgnoreChild

</t>
<t tx="ekr.20100212224846.9996">def extend_class(original, class_addons):
    """add methods and attribute defined in the addon classes to the original
    class
    """
    for addons in class_addons:
        brain = addons.__dict__.copy()
        for special_key in ('__doc__', '__module__', '__dict__'):
            if special_key in addons.__dict__:
                del brain[special_key]
        try:
            original.__dict__.update(brain)
        except AttributeError:
            # dictproxy object
            for k, v in brain.iteritems():
                setattr(original, k, v)


</t>
<t tx="ekr.20100212224846.9997">class ASTVisitor(object):
    """Abstract Base Class for Python AST Visitors.

    Visitors inheritating from ASTVisitors could visit
    compiler.ast, _ast or astng trees.

    Not all methods will have to be implemented;
    so some methods are just empty interfaces for catching
    cases where we don't want to do anything on the
    concerned node.
    """
    @others
</t>
<t tx="ekr.20100212224846.9998">
def visit_arguments(self, node):
    """dummy method for visiting an Arguments node"""

</t>
<t tx="ekr.20100212224846.9999">def visit_assattr(self, node):
    """dummy method for visiting an AssAttr node"""

</t>
<t tx="ekr.20100213083546.4253">def importOneFile (fn):

    theDir,basename = g.os_path_split(fn)

    if g.os_path_exists(theDir):
        c.importCommands.importFilesCommand([fn],'@file')
            # '@thin' does not work well.
    else:
        g.es("directory does not exist: " + theDir)
</t>
<t tx="ekr.20100213083546.5119"></t>
<t tx="ekr.20100213083546.5120">@language python
@tabwidth -4

"""Debugger basics"""

@others
</t>
<t tx="ekr.20100213083546.5121">import sys
import os
import types

__all__ = ["BdbQuit","Bdb","Breakpoint"]


</t>
<t tx="ekr.20100213083546.5122">class BdbQuit(Exception):
    
    """Exception to give up completely"""
</t>
<t tx="ekr.20100213083546.5163">class Bdb:

    """Generic Python debugger base class.

    This class takes care of details of the trace facility;
    a derived class should implement user interaction.
    The standard debugger class (pdb.Pdb) is an example.
    """

    @others
</t>
<t tx="ekr.20100213083546.5164">def __init__(self):
    self.breaks = {}
    self.fncache = {}

</t>
<t tx="ekr.20100213083546.5165">def canonic(self, filename):
    
    # EKR: create canonical key for filename.

    if filename == "&lt;" + filename[1:-1] + "&gt;":
        return filename
    canonic = self.fncache.get(filename)
    if not canonic:
        canonic = os.path.abspath(filename)
        canonic = os.path.normcase(canonic)
        self.fncache[filename] = canonic
    return canonic

</t>
<t tx="ekr.20100213083546.5166">def reset(self):
    import linecache
    linecache.checkcache()
    self.botframe = None
    self._set_stopinfo(None, None)

</t>
<t tx="ekr.20100213083546.5167">def trace_dispatch(self, frame, event, arg):
    if self.quitting:
        return # None
    if event == 'line':
        return self.dispatch_line(frame)
    if event == 'call':
        return self.dispatch_call(frame, arg)
    if event == 'return':
        return self.dispatch_return(frame, arg)
    if event == 'exception':
        return self.dispatch_exception(frame, arg)
    if event == 'c_call':
        return self.trace_dispatch
    if event == 'c_exception':
        return self.trace_dispatch
    if event == 'c_return':
        return self.trace_dispatch
    print('bdb.Bdb.dispatch: unknown debugging event:', repr(event))
    return self.trace_dispatch
</t>
<t tx="ekr.20100213083546.5168">def dispatch_line(self, frame):
    if self.stop_here(frame) or self.break_here(frame):
        self.user_line(frame)
        if self.quitting: raise BdbQuit
    return self.trace_dispatch

</t>
<t tx="ekr.20100213083546.5169">def dispatch_call(self, frame, arg):
    # XXX 'arg' is no longer used
    if self.botframe is None:
        # First call of dispatch since reset()
        self.botframe = frame.f_back # (CT) Note that this may also be None!
        return self.trace_dispatch
    if not (self.stop_here(frame) or self.break_anywhere(frame)):
        # No need to trace this function
        return # None
    self.user_call(frame, arg)
    if self.quitting: raise BdbQuit
    return self.trace_dispatch

</t>
<t tx="ekr.20100213083546.5170">def dispatch_return(self, frame, arg):
    if self.stop_here(frame) or frame == self.returnframe:
        self.user_return(frame, arg)
        if self.quitting: raise BdbQuit
    return self.trace_dispatch

</t>
<t tx="ekr.20100213083546.5171">def dispatch_exception(self, frame, arg):
    if self.stop_here(frame):
        self.user_exception(frame, arg)
        if self.quitting: raise BdbQuit
    return self.trace_dispatch

</t>
<t tx="ekr.20100213083546.5172"># Normally derived classes don't override the following
# methods, but they may if they want to redefine the
# definition of stopping and breakpoints.

def stop_here(self, frame):
    # (CT) stopframe may now also be None, see dispatch_call.
    # (CT) the former test for None is therefore removed from here.
    if frame is self.stopframe:
        return frame.f_lineno &gt;= self.stoplineno
    while frame is not None and frame is not self.stopframe:
        if frame is self.botframe:
            return True
        frame = frame.f_back
    return False

</t>
<t tx="ekr.20100213083546.5173">def break_here(self, frame):
    filename = self.canonic(frame.f_code.co_filename)
    if not filename in self.breaks:
        return False
    lineno = frame.f_lineno
    if not lineno in self.breaks[filename]:
        # The line itself has no breakpoint, but maybe the line is the
        # first line of a function with breakpoint set by function name.
        lineno = frame.f_code.co_firstlineno
        if not lineno in self.breaks[filename]:
            return False

    # flag says ok to delete temp. bp
    (bp, flag) = effective(filename, lineno, frame)
    if bp:
        self.currentbp = bp.number
        if (flag and bp.temporary):
            self.do_clear(str(bp.number))
        return True
    else:
        return False
</t>
<t tx="ekr.20100213083546.5174">def do_clear(self, arg):
    raise NotImplementedError, "subclass of bdb must implement do_clear()"

</t>
<t tx="ekr.20100213083546.5175">def break_anywhere(self, frame):
    return self.canonic(frame.f_code.co_filename) in self.breaks

</t>
<t tx="ekr.20100213083546.5176"># Derived classes should override the user_* methods
# to gain control.

def user_call(self, frame, argument_list):
    """This method is called when there is the remote possibility
    that we ever need to stop in this function."""
    pass

</t>
<t tx="ekr.20100213083546.5177">def user_line(self, frame):
    """This method is called when we stop or break at this line."""
    pass

</t>
<t tx="ekr.20100213083546.5178">def user_return(self, frame, return_value):
    """This method is called when a return trap is set here."""
    pass

</t>
<t tx="ekr.20100213083546.5179">def user_exception(self, frame, exc_info):
    exc_type, exc_value, exc_traceback = exc_info
    """This method is called if an exception occurs,
    but only if we are to stop at or just below this level."""
    pass

</t>
<t tx="ekr.20100213083546.5180">def _set_stopinfo(self, stopframe, returnframe, stoplineno=-1):
    self.stopframe = stopframe
    self.returnframe = returnframe
    self.quitting = 0
    self.stoplineno = stoplineno

</t>
<t tx="ekr.20100213083546.5181"># Derived classes and clients can call the following methods
# to affect the stepping state.

def set_until(self, frame): #the name "until" is borrowed from gdb
    """Stop when the line with the line no greater than the current one is
    reached or when returning from current frame"""
    self._set_stopinfo(frame, frame, frame.f_lineno+1)

</t>
<t tx="ekr.20100213083546.5182">def set_step(self):
    """Stop after one line of code."""
    self._set_stopinfo(None,None)

</t>
<t tx="ekr.20100213083546.5183">def set_next(self, frame):
    """Stop on the next line in or below the given frame."""
    self._set_stopinfo(frame, None)

</t>
<t tx="ekr.20100213083546.5184">def set_return(self, frame):
    """Stop when returning from the given frame."""
    self._set_stopinfo(frame.f_back, frame)

</t>
<t tx="ekr.20100213083546.5185">def set_trace(self, frame=None):
    """Start debugging from `frame`.

    If frame is not specified, debugging starts from caller's frame.
    """
    if frame is None:
        frame = sys._getframe().f_back
    self.reset()
    while frame:
        frame.f_trace = self.trace_dispatch
        self.botframe = frame
        frame = frame.f_back
    self.set_step()
    sys.settrace(self.trace_dispatch)

</t>
<t tx="ekr.20100213083546.5186">def set_continue(self):
    # Don't stop except at breakpoints or when finished
    self._set_stopinfo(self.botframe, None)
    if not self.breaks:
        # no breakpoints; run without debugger overhead
        sys.settrace(None)
        frame = sys._getframe().f_back
        while frame and frame is not self.botframe:
            del frame.f_trace
            frame = frame.f_back

</t>
<t tx="ekr.20100213083546.5187">def set_quit(self):
    self.stopframe = self.botframe
    self.returnframe = None
    self.quitting = 1
    sys.settrace(None)

</t>
<t tx="ekr.20100213083546.5188"># Derived classes and clients can call the following methods
# to manipulate breakpoints.  These methods return an
# error message is something went wrong, None if all is well.
# Set_break prints out the breakpoint line and file:lineno.
# Call self.get_*break*() to see the breakpoints or better
# for bp in Breakpoint.bpbynumber: if bp: bp.bpprint().

def set_break(self, filename, lineno, temporary=0, cond = None,
              funcname=None):
    filename = self.canonic(filename)
    import linecache # Import as late as possible
    line = linecache.getline(filename, lineno)
    if not line:
        return 'Line %s:%d does not exist' % (filename,
                               lineno)
    if not filename in self.breaks:
        self.breaks[filename] = []
    list = self.breaks[filename]
    if not lineno in list:
        list.append(lineno)
    bp = Breakpoint(filename, lineno, temporary, cond, funcname)

</t>
<t tx="ekr.20100213083546.5189">def clear_break(self, filename, lineno):
    filename = self.canonic(filename)
    if not filename in self.breaks:
        return 'There are no breakpoints in %s' % filename
    if lineno not in self.breaks[filename]:
        return 'There is no breakpoint at %s:%d' % (filename,
                                lineno)
    # If there's only one bp in the list for that file,line
    # pair, then remove the breaks entry
    for bp in Breakpoint.bplist[filename, lineno][:]:
        bp.deleteMe()
    if not Breakpoint.bplist.has_key((filename, lineno)):
        self.breaks[filename].remove(lineno)
    if not self.breaks[filename]:
        del self.breaks[filename]

</t>
<t tx="ekr.20100213083546.5190">def clear_bpbynumber(self, arg):
    try:
        number = int(arg)
    except:
        return 'Non-numeric breakpoint number (%s)' % arg
    try:
        bp = Breakpoint.bpbynumber[number]
    except IndexError:
        return 'Breakpoint number (%d) out of range' % number
    if not bp:
        return 'Breakpoint (%d) already deleted' % number
    self.clear_break(bp.file, bp.line)

</t>
<t tx="ekr.20100213083546.5191">def clear_all_file_breaks(self, filename):
    filename = self.canonic(filename)
    if not filename in self.breaks:
        return 'There are no breakpoints in %s' % filename
    for line in self.breaks[filename]:
        blist = Breakpoint.bplist[filename, line]
        for bp in blist:
            bp.deleteMe()
    del self.breaks[filename]

</t>
<t tx="ekr.20100213083546.5192">def clear_all_breaks(self):
    if not self.breaks:
        return 'There are no breakpoints'
    for bp in Breakpoint.bpbynumber:
        if bp:
            bp.deleteMe()
    self.breaks = {}

</t>
<t tx="ekr.20100213083546.5193">def get_break(self, filename, lineno):
    filename = self.canonic(filename)
    return filename in self.breaks and \
        lineno in self.breaks[filename]

</t>
<t tx="ekr.20100213083546.5194">def get_breaks(self, filename, lineno):
    filename = self.canonic(filename)
    return filename in self.breaks and \
        lineno in self.breaks[filename] and \
        Breakpoint.bplist[filename, lineno] or []

</t>
<t tx="ekr.20100213083546.5195">def get_file_breaks(self, filename):
    filename = self.canonic(filename)
    if filename in self.breaks:
        return self.breaks[filename]
    else:
        return []

</t>
<t tx="ekr.20100213083546.5196">def get_all_breaks(self):
    return self.breaks

</t>
<t tx="ekr.20100213083546.5197"># Derived classes and clients can call the following method
# to get a data structure representing a stack trace.

def get_stack(self, f, t):
    stack = []
    if t and t.tb_frame is f:
        t = t.tb_next
    while f is not None:
        stack.append((f, f.f_lineno))
        if f is self.botframe:
            break
        f = f.f_back
    stack.reverse()
    i = max(0, len(stack) - 1)
    while t is not None:
        stack.append((t.tb_frame, t.tb_lineno))
        t = t.tb_next
    if f is None:
        i = max(0, len(stack) - 1)
    return stack, i

</t>
<t tx="ekr.20100213083546.5198">#

def format_stack_entry(self, frame_lineno, lprefix=': '):
    import linecache, repr
    frame, lineno = frame_lineno
    filename = self.canonic(frame.f_code.co_filename)
    s = '%s(%r)' % (filename, lineno)
    if frame.f_code.co_name:
        s = s + frame.f_code.co_name
    else:
        s = s + "&lt;lambda&gt;"
    if '__args__' in frame.f_locals:
        args = frame.f_locals['__args__']
    else:
        args = None
    if args:
        s = s + repr.repr(args)
    else:
        s = s + '()'
    if '__return__' in frame.f_locals:
        rv = frame.f_locals['__return__']
        s = s + '-&gt;'
        s = s + repr.repr(rv)
    line = linecache.getline(filename, lineno, frame.f_globals)
    if line: s = s + lprefix + line.strip()
    return s

</t>
<t tx="ekr.20100213083546.5199"># The following two methods can be called by clients to use
# a debugger to debug a statement, given as a string.

def run(self, cmd, globals=None, locals=None):
    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(cmd, types.CodeType):
        cmd = cmd+'\n'
    try:
        exec cmd in globals, locals
    except BdbQuit:
        pass
    finally:
        self.quitting = 1
        sys.settrace(None)

</t>
<t tx="ekr.20100213083546.5200">def runeval(self, expr, globals=None, locals=None):
    if globals is None:
        import __main__
        globals = __main__.__dict__
    if locals is None:
        locals = globals
    self.reset()
    sys.settrace(self.trace_dispatch)
    if not isinstance(expr, types.CodeType):
        expr = expr+'\n'
    try:
        return eval(expr, globals, locals)
    except BdbQuit:
        pass
    finally:
        self.quitting = 1
        sys.settrace(None)

</t>
<t tx="ekr.20100213083546.5201">def runctx(self, cmd, globals, locals):
    # B/W compatibility
    self.run(cmd, globals, locals)

</t>
<t tx="ekr.20100213083546.5202"># This method is more useful to debug a single function call.

def runcall(self, func, *args, **kwds):
    self.reset()
    sys.settrace(self.trace_dispatch)
    res = None
    try:
        res = func(*args, **kwds)
    except BdbQuit:
        pass
    finally:
        self.quitting = 1
        sys.settrace(None)
    return res


</t>
<t tx="ekr.20100213083546.5203">def set_trace():
    Bdb().set_trace()


</t>
<t tx="ekr.20100213083546.5204">class Breakpoint:

    """Breakpoint class

    Implements temporary breakpoints, ignore counts, disabling and
    (re)-enabling, and conditionals.

    Breakpoints are indexed by number through bpbynumber and by
    the file,line tuple using bplist.  The former points to a
    single instance of class Breakpoint.  The latter points to a
    list of such instances since there may be more than one
    breakpoint per line.

    """

    # XXX Keeping state in the class is a mistake -- this means
    # you cannot have more than one active Bdb instance.

    next = 1        # Next bp to be assigned
    bplist = {}     # indexed by (file, lineno) tuple
    bpbynumber = [None] # Each entry is None or an instance of Bpt
    
    @others
</t>
<t tx="ekr.20100213083546.5205"># index 0 is unused, except for marking an
# effective break .... see effective()

def __init__(self, file, line, temporary=0, cond=None, funcname=None):
    self.funcname = funcname
    # Needed if funcname is not None.
    self.func_first_executable_line = None
    self.file = file    # This better be in canonical form!
    self.line = line
    self.temporary = temporary
    self.cond = cond
    self.enabled = 1
    self.ignore = 0
    self.hits = 0
    self.number = Breakpoint.next
    Breakpoint.next = Breakpoint.next + 1
    # Build the two lists
    self.bpbynumber.append(self)
    if self.bplist.has_key((file, line)):
        self.bplist[file, line].append(self)
    else:
        self.bplist[file, line] = [self]


</t>
<t tx="ekr.20100213083546.5206">def deleteMe(self):
    index = (self.file, self.line)
    self.bpbynumber[self.number] = None   # No longer in list
    self.bplist[index].remove(self)
    if not self.bplist[index]:
        # No more bp for this f:l combo
        del self.bplist[index]

</t>
<t tx="ekr.20100213083546.5207">def enable(self):
    self.enabled = 1

</t>
<t tx="ekr.20100213083546.5208">def disable(self):
    self.enabled = 0

</t>
<t tx="ekr.20100213083546.5209">def bpprint(self, out=None):
    if out is None:
        out = sys.stdout
    if self.temporary:
        disp = 'del  '
    else:
        disp = 'keep '
    if self.enabled:
        disp = disp + 'yes  '
    else:
        disp = disp + 'no   '
    print &gt;&gt;out, '%-4dbreakpoint   %s at %s:%d' % (self.number, disp,
                                                   self.file, self.line)
    if self.cond:
        print &gt;&gt;out, '\tstop only if %s' % (self.cond,)
    if self.ignore:
        print &gt;&gt;out, '\tignore next %d hits' % (self.ignore)
    if (self.hits):
        if (self.hits &gt; 1): ss = 's'
        else: ss = ''
        print &gt;&gt;out, ('\tbreakpoint already hit %d time%s' %
                      (self.hits, ss))

</t>
<t tx="ekr.20100213083546.5210">def checkfuncname(b, frame):
    """Check whether we should break here because of `b.funcname`."""
    if not b.funcname:
        # Breakpoint was set via line number.
        if b.line != frame.f_lineno:
            # Breakpoint was set at a line with a def statement and the function
            # defined is called: don't break.
            return False
        return True

    # Breakpoint set via function name.

    if frame.f_code.co_name != b.funcname:
        # It's not a function call, but rather execution of def statement.
        return False

    # We are in the right frame.
    if not b.func_first_executable_line:
        # The function is entered for the 1st time.
        b.func_first_executable_line = frame.f_lineno

    if  b.func_first_executable_line != frame.f_lineno:
        # But we are not at the first line number: don't break.
        return False
    return True

</t>
<t tx="ekr.20100213083546.5211"># Determines if there is an effective (active) breakpoint at this
# line of code.  Returns breakpoint number or 0 if none
def effective(file, line, frame):
    """Determine which breakpoint for this file:line is to be acted upon.

    Called only if we know there is a bpt at this
    location.  Returns breakpoint that was triggered and a flag
    that indicates if it is ok to delete a temporary bp.

    """
    possibles = Breakpoint.bplist[file,line]
    for i in range(0, len(possibles)):
        b = possibles[i]
        if b.enabled == 0:
            continue
        if not checkfuncname(b, frame):
            continue
        # Count every hit when bp is enabled
        b.hits = b.hits + 1
        if not b.cond:
            # If unconditional, and ignoring,
            # go on to next, else break
            if b.ignore &gt; 0:
                b.ignore = b.ignore -1
                continue
            else:
                # breakpoint and marker that's ok
                # to delete if temporary
                return (b,1)
        else:
            # Conditional bp.
            # Ignore count applies only to those bpt hits where the
            # condition evaluates to true.
            try:
                val = eval(b.cond, frame.f_globals,
                       frame.f_locals)
                if val:
                    if b.ignore &gt; 0:
                        b.ignore = b.ignore -1
                        # continue
                    else:
                        return (b,1)
                # else:
                #   continue
            except:
                # if eval fails, most conservative
                # thing is to stop on breakpoint
                # regardless of ignore count.
                # Don't delete temporary,
                # as another hint to user.
                return (b,0)
    return (None, None)

</t>
<t tx="ekr.20100213083546.5212">class Tdb(Bdb):
    @others
</t>
<t tx="ekr.20100213083546.5213">def user_call(self, frame, args):
    name = frame.f_code.co_name
    if not name: name = '???'
    print '+++ call', name, args
</t>
<t tx="ekr.20100213083546.5214">def user_line(self, frame):
    import linecache
    name = frame.f_code.co_name
    if not name: name = '???'
    fn = self.canonic(frame.f_code.co_filename)
    line = linecache.getline(fn, frame.f_lineno, frame.f_globals)
    print '+++', fn, frame.f_lineno, name, ':', line.strip()
</t>
<t tx="ekr.20100213083546.5215">def user_return(self, frame, retval):
    print '+++ return', retval
</t>
<t tx="ekr.20100213083546.5216">def user_exception(self, frame, exc_stuff):
    print '+++ exception', exc_stuff
    self.set_continue()

</t>
<t tx="ekr.20100213083546.5217">def foo(n):
    print 'foo(', n, ')'
    x = bar(n*10)
    print 'bar returned', x

</t>
<t tx="ekr.20100213083546.5218">def bar(a):
    print 'bar(', a, ')'
    return a/2

</t>
<t tx="ekr.20100213083546.5219">def test():
    t = Tdb()
    t.run('import bdb; bdb.foo(10)')
</t>
<t tx="ekr.20100213083546.5220">@first #! /usr/bin/env python
@language python
@tabwidth -4

"""A Python debugger."""

# (See pdb.doc for documentation.)

@others

# When invoked as main program, invoke the debugger on a script
if __name__ == '__main__':
    import pdb
    pdb.main()
</t>
<t tx="ekr.20100213083546.5221">import sys
import linecache
import cmd
import bdb
from repr import Repr
import os
import re
import pprint
import traceback

# Create a custom safe Repr instance and increase its maxstring.
# The default of 30 truncates error messages too easily.
_repr = Repr()
_repr.maxstring = 200
_saferepr = _repr.repr

__all__ = [
    "run", "pm", "Pdb", "runeval", "runctx", "runcall", "set_trace",
    "post_mortem", "help",
]

</t>
<t tx="ekr.20100213083546.5222">class Restart(Exception):
    """Causes a debugger to be restarted for the debugged python program."""
    pass

</t>
<t tx="ekr.20100213083546.5223">
def find_function(funcname, filename):
    cre = re.compile(r'def\s+%s\s*[(]' % re.escape(funcname))
    try:
        fp = open(filename)
    except IOError:
        return None
    # consumer of this info expects the first line to be 1
    lineno = 1
    answer = None
    while 1:
        line = fp.readline()
        if line == '':
            break
        if cre.match(line):
            answer = funcname, filename, lineno
            break
        lineno = lineno + 1
    fp.close()
    return answer
</t>
<t tx="ekr.20100213083546.5224"># Interaction prompt line will separate file and call info from code
# text using value of line_prefix string.  A newline and arrow may
# be to your liking.  You can set it once pdb is imported using the
# command "pdb.line_prefix = '\n% '".
# line_prefix = ': '    # Use this to get the old situation back
line_prefix = '\n-&gt; '   # Probably a better default

class Pdb(bdb.Bdb, cmd.Cmd):
    @others
</t>
<t tx="ekr.20100213083546.5225">def __init__(self, completekey='tab', stdin=None, stdout=None):
    bdb.Bdb.__init__(self)
    cmd.Cmd.__init__(self, completekey, stdin, stdout)
    if stdout:
        self.use_rawinput = 0
    self.prompt = '(Pdb) '
    self.aliases = {}
    self.mainpyfile = ''
    self._wait_for_mainpyfile = 0
    # Try to load readline if it exists
    try:
        import readline
    except ImportError:
        pass

    # Read $HOME/.pdbrc and ./.pdbrc
    self.rcLines = []
    if 'HOME' in os.environ:
        envHome = os.environ['HOME']
        try:
            rcFile = open(os.path.join(envHome, ".pdbrc"))
        except IOError:
            pass
        else:
            for line in rcFile.readlines():
                self.rcLines.append(line)
            rcFile.close()
    try:
        rcFile = open(".pdbrc")
    except IOError:
        pass
    else:
        for line in rcFile.readlines():
            self.rcLines.append(line)
        rcFile.close()

    self.commands = {} # associates a command list to breakpoint numbers
    self.commands_doprompt = {} # for each bp num, tells if the prompt must be disp. after execing the cmd list
    self.commands_silent = {} # for each bp num, tells if the stack trace must be disp. after execing the cmd list
    self.commands_defining = False # True while in the process of defining a command list
    self.commands_bnum = None # The breakpoint number for which we are defining a list
</t>
<t tx="ekr.20100213083546.5226">def reset(self):
    bdb.Bdb.reset(self)
    self.forget()

</t>
<t tx="ekr.20100213083546.5227">def forget(self):
    self.lineno = None
    self.stack = []
    self.curindex = 0
    self.curframe = None

</t>
<t tx="ekr.20100213083546.5228">def setup(self, f, t):
    self.forget()
    self.stack, self.curindex = self.get_stack(f, t)
    self.curframe = self.stack[self.curindex][0]
    self.execRcLines()

</t>
<t tx="ekr.20100213083546.5229"># Can be executed earlier than 'setup' if desired
def execRcLines(self):
    if self.rcLines:
        # Make local copy because of recursion
        rcLines = self.rcLines
        # executed only once
        self.rcLines = []
        for line in rcLines:
            line = line[:-1]
            if len(line) &gt; 0 and line[0] != '#':
                self.onecmd(line)

</t>
<t tx="ekr.20100213083546.5230"># Override Bdb methods

def user_call(self, frame, argument_list):
    """This method is called when there is the remote possibility
    that we ever need to stop in this function."""
    if self._wait_for_mainpyfile:
        return
    if self.stop_here(frame):
        print &gt;&gt;self.stdout, '--Call--'
        self.interaction(frame, None)

</t>
<t tx="ekr.20100213083546.5231">def user_line(self, frame):
    """This function is called when we stop or break at this line."""
    if self._wait_for_mainpyfile:
        if (self.mainpyfile != self.canonic(frame.f_code.co_filename)
            or frame.f_lineno&lt;= 0):
            return
        self._wait_for_mainpyfile = 0
    if self.bp_commands(frame):
        self.interaction(frame, None)

</t>
<t tx="ekr.20100213083546.5232">def bp_commands(self,frame):
    """ Call every command that was set for the current active breakpoint (if there is one)
    Returns True if the normal interaction function must be called, False otherwise """
    #self.currentbp is set in bdb.py in bdb.break_here if a breakpoint was hit
    if getattr(self,"currentbp",False) and self.currentbp in self.commands:
        currentbp = self.currentbp
        self.currentbp = 0
        lastcmd_back = self.lastcmd
        self.setup(frame, None)
        for line in self.commands[currentbp]:
            self.onecmd(line)
        self.lastcmd = lastcmd_back
        if not self.commands_silent[currentbp]:
            self.print_stack_entry(self.stack[self.curindex])
        if self.commands_doprompt[currentbp]:
            self.cmdloop()
        self.forget()
        return
    return 1

</t>
<t tx="ekr.20100213083546.5233">def user_return(self, frame, return_value):
    """This function is called when a return trap is set here."""
    frame.f_locals['__return__'] = return_value
    print &gt;&gt;self.stdout, '--Return--'
    self.interaction(frame, None)

</t>
<t tx="ekr.20100213083546.5234">def user_exception(self, frame, exc_info):
    exc_type, exc_value, exc_traceback = exc_info
    """This function is called if an exception occurs,
    but only if we are to stop at or just below this level."""
    frame.f_locals['__exception__'] = exc_type, exc_value
    if type(exc_type) == type(''):
        exc_type_name = exc_type
    else: exc_type_name = exc_type.__name__
    print &gt;&gt;self.stdout, exc_type_name + ':', _saferepr(exc_value)
    self.interaction(frame, exc_traceback)

</t>
<t tx="ekr.20100213083546.5235"># General interaction function

def interaction(self, frame, traceback):
    self.setup(frame, traceback)
    self.print_stack_entry(self.stack[self.curindex])
    self.cmdloop()
    self.forget()

</t>
<t tx="ekr.20100213083546.5236">def displayhook(self, obj):
    """Custom displayhook for the exec in default(), which prevents
    assignment of the _ variable in the builtins.
    """
    print repr(obj)

</t>
<t tx="ekr.20100213083546.5237">def default(self, line):
    if line[:1] == '!': line = line[1:]
    locals = self.curframe.f_locals
    globals = self.curframe.f_globals
    try:
        code = compile(line + '\n', '&lt;stdin&gt;', 'single')
        save_stdout = sys.stdout
        save_stdin = sys.stdin
        save_displayhook = sys.displayhook
        try:
            sys.stdin = self.stdin
            sys.stdout = self.stdout
            sys.displayhook = self.displayhook
            exec code in globals, locals
        finally:
            sys.stdout = save_stdout
            sys.stdin = save_stdin
            sys.displayhook = save_displayhook
    except:
        t, v = sys.exc_info()[:2]
        if type(t) == type(''):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print &gt;&gt;self.stdout, '***', exc_type_name + ':', v

</t>
<t tx="ekr.20100213083546.5238">def precmd(self, line):
    """Handle alias expansion and ';;' separator."""
    if not line.strip():
        return line
    args = line.split()
    while args[0] in self.aliases:
        line = self.aliases[args[0]]
        ii = 1
        for tmpArg in args[1:]:
            line = line.replace("%" + str(ii),
                                  tmpArg)
            ii = ii + 1
        line = line.replace("%*", ' '.join(args[1:]))
        args = line.split()
    # split into ';;' separated commands
    # unless it's an alias command
    if args[0] != 'alias':
        marker = line.find(';;')
        if marker &gt;= 0:
            # queue up everything after marker
            next = line[marker+2:].lstrip()
            self.cmdqueue.append(next)
            line = line[:marker].rstrip()
    return line

</t>
<t tx="ekr.20100213083546.5239">def onecmd(self, line):
    """Interpret the argument as though it had been typed in response
    to the prompt.

    Checks whether this line is typed at the normal prompt or in
    a breakpoint command list definition.
    """
    if not self.commands_defining:
        return cmd.Cmd.onecmd(self, line)
    else:
        return self.handle_command_def(line)

</t>
<t tx="ekr.20100213083546.5240">def handle_command_def(self,line):
    """ Handles one command line during command list definition. """
    cmd, arg, line = self.parseline(line)
    if cmd == 'silent':
        self.commands_silent[self.commands_bnum] = True
        return # continue to handle other cmd def in the cmd list
    elif cmd == 'end':
        self.cmdqueue = []
        return 1 # end of cmd list
    cmdlist = self.commands[self.commands_bnum]
    if (arg):
        cmdlist.append(cmd+' '+arg)
    else:
        cmdlist.append(cmd)
    # Determine if we must stop
    try:
        func = getattr(self, 'do_' + cmd)
    except AttributeError:
        func = self.default
    if func.func_name in self.commands_resuming : # one of the resuming commands.
        self.commands_doprompt[self.commands_bnum] = False
        self.cmdqueue = []
        return 1
    return

</t>
<t tx="ekr.20100213083546.5241"># Command definitions, called by cmdloop()
# The argument is the remaining string on the command line
# Return true to exit from the command loop

do_h = cmd.Cmd.do_help

def do_commands(self, arg):
    """Defines a list of commands associated to a breakpoint
    Those commands will be executed whenever the breakpoint causes the program to stop execution."""
    if not arg:
        bnum = len(bdb.Breakpoint.bpbynumber)-1
    else:
        try:
            bnum = int(arg)
        except:
            print &gt;&gt;self.stdout, "Usage : commands [bnum]\n        ...\n        end"
            return
    self.commands_bnum = bnum
    self.commands[bnum] = []
    self.commands_doprompt[bnum] = True
    self.commands_silent[bnum] = False
    prompt_back = self.prompt
    self.prompt = '(com) '
    self.commands_defining = True
    self.cmdloop()
    self.commands_defining = False
    self.prompt = prompt_back

</t>
<t tx="ekr.20100213083546.5242">def do_break(self, arg, temporary = 0):
    # break [ ([filename:]lineno | function) [, "condition"] ]
    if not arg:
        if self.breaks:  # There's at least one
            print &gt;&gt;self.stdout, "Num Type         Disp Enb   Where"
            for bp in bdb.Breakpoint.bpbynumber:
                if bp:
                    bp.bpprint(self.stdout)
        return
    # parse arguments; comma has lowest precedence
    # and cannot occur in filename
    filename = None
    lineno = None
    cond = None
    comma = arg.find(',')
    if comma &gt; 0:
        # parse stuff after comma: "condition"
        cond = arg[comma+1:].lstrip()
        arg = arg[:comma].rstrip()
    # parse stuff before comma: [filename:]lineno | function
    colon = arg.rfind(':')
    funcname = None
    if colon &gt;= 0:
        filename = arg[:colon].rstrip()
        f = self.lookupmodule(filename)
        if not f:
            print &gt;&gt;self.stdout, '*** ', repr(filename),
            print &gt;&gt;self.stdout, 'not found from sys.path'
            return
        else:
            filename = f
        arg = arg[colon+1:].lstrip()
        try:
            lineno = int(arg)
        except ValueError, msg:
            print &gt;&gt;self.stdout, '*** Bad lineno:', arg
            return
    else:
        # no colon; can be lineno or function
        try:
            lineno = int(arg)
        except ValueError:
            try:
                func = eval(arg,
                            self.curframe.f_globals,
                            self.curframe.f_locals)
            except:
                func = arg
            try:
                if hasattr(func, 'im_func'):
                    func = func.im_func
                code = func.func_code
                #use co_name to identify the bkpt (function names
                #could be aliased, but co_name is invariant)
                funcname = code.co_name
                lineno = code.co_firstlineno
                filename = code.co_filename
            except:
                # last thing to try
                (ok, filename, ln) = self.lineinfo(arg)
                if not ok:
                    print &gt;&gt;self.stdout, '*** The specified object',
                    print &gt;&gt;self.stdout, repr(arg),
                    print &gt;&gt;self.stdout, 'is not a function'
                    print &gt;&gt;self.stdout, 'or was not found along sys.path.'
                    return
                funcname = ok # ok contains a function name
                lineno = int(ln)
    if not filename:
        filename = self.defaultFile()
    # Check for reasonable breakpoint
    line = self.checkline(filename, lineno)
    if line:
        # now set the break point
        err = self.set_break(filename, line, temporary, cond, funcname)
        if err: print &gt;&gt;self.stdout, '***', err
        else:
            bp = self.get_breaks(filename, line)[-1]
            print &gt;&gt;self.stdout, "Breakpoint %d at %s:%d" % (bp.number,
                                                             bp.file,
                                                             bp.line)

</t>
<t tx="ekr.20100213083546.5243"># To be overridden in derived debuggers
def defaultFile(self):
    """Produce a reasonable default."""
    filename = self.curframe.f_code.co_filename
    if filename == '&lt;string&gt;' and self.mainpyfile:
        filename = self.mainpyfile
    return filename

</t>
<t tx="ekr.20100213083546.5244">do_b = do_break

def do_tbreak(self, arg):
    self.do_break(arg, 1)

</t>
<t tx="ekr.20100213083546.5245">def lineinfo(self, identifier):
    failed = (None, None, None)
    # Input is identifier, may be in single quotes
    idstring = identifier.split("'")
    if len(idstring) == 1:
        # not in single quotes
        id = idstring[0].strip()
    elif len(idstring) == 3:
        # quoted
        id = idstring[1].strip()
    else:
        return failed
    if id == '': return failed
    parts = id.split('.')
    # Protection for derived debuggers
    if parts[0] == 'self':
        del parts[0]
        if len(parts) == 0:
            return failed
    # Best first guess at file to look at
    fname = self.defaultFile()
    if len(parts) == 1:
        item = parts[0]
    else:
        # More than one part.
        # First is module, second is method/class
        f = self.lookupmodule(parts[0])
        if f:
            fname = f
        item = parts[1]
    answer = find_function(item, fname)
    return answer or failed

</t>
<t tx="ekr.20100213083546.5246">def checkline(self, filename, lineno):
    """Check whether specified line seems to be executable.

    Return `lineno` if it is, 0 if not (e.g. a docstring, comment, blank
    line or EOF). Warning: testing is not comprehensive.
    """
    line = linecache.getline(filename, lineno, self.curframe.f_globals)
    if not line:
        print &gt;&gt;self.stdout, 'End of file'
        return 0
    line = line.strip()
    # Don't allow setting breakpoint at a blank line
    if (not line or (line[0] == '#') or
         (line[:3] == '"""') or line[:3] == "'''"):
        print &gt;&gt;self.stdout, '*** Blank or comment'
        return 0
    return lineno

</t>
<t tx="ekr.20100213083546.5247">def do_enable(self, arg):
    args = arg.split()
    for i in args:
        try:
            i = int(i)
        except ValueError:
            print &gt;&gt;self.stdout, 'Breakpoint index %r is not a number' % i
            continue

        if not (0 &lt;= i &lt; len(bdb.Breakpoint.bpbynumber)):
            print &gt;&gt;self.stdout, 'No breakpoint numbered', i
            continue

        bp = bdb.Breakpoint.bpbynumber[i]
        if bp:
            bp.enable()

</t>
<t tx="ekr.20100213083546.5248">def do_disable(self, arg):
    args = arg.split()
    for i in args:
        try:
            i = int(i)
        except ValueError:
            print &gt;&gt;self.stdout, 'Breakpoint index %r is not a number' % i
            continue

        if not (0 &lt;= i &lt; len(bdb.Breakpoint.bpbynumber)):
            print &gt;&gt;self.stdout, 'No breakpoint numbered', i
            continue

        bp = bdb.Breakpoint.bpbynumber[i]
        if bp:
            bp.disable()

</t>
<t tx="ekr.20100213083546.5249">def do_condition(self, arg):
    # arg is breakpoint number and condition
    args = arg.split(' ', 1)
    try:
        bpnum = int(args[0].strip())
    except ValueError:
        # something went wrong
        print &gt;&gt;self.stdout, \
            'Breakpoint index %r is not a number' % args[0]
        return
    try:
        cond = args[1]
    except:
        cond = None
    try:
        bp = bdb.Breakpoint.bpbynumber[bpnum]
    except IndexError:
        print &gt;&gt;self.stdout, 'Breakpoint index %r is not valid' % args[0]
        return
    if bp:
        bp.cond = cond
        if not cond:
            print &gt;&gt;self.stdout, 'Breakpoint', bpnum,
            print &gt;&gt;self.stdout, 'is now unconditional.'

</t>
<t tx="ekr.20100213083546.5250">def do_ignore(self,arg):
    """arg is bp number followed by ignore count."""
    args = arg.split()
    try:
        bpnum = int(args[0].strip())
    except ValueError:
        # something went wrong
        print &gt;&gt;self.stdout, \
            'Breakpoint index %r is not a number' % args[0]
        return
    try:
        count = int(args[1].strip())
    except:
        count = 0
    try:
        bp = bdb.Breakpoint.bpbynumber[bpnum]
    except IndexError:
        print &gt;&gt;self.stdout, 'Breakpoint index %r is not valid' % args[0]
        return
    if bp:
        bp.ignore = count
        if count &gt; 0:
            reply = 'Will ignore next '
            if count &gt; 1:
                reply = reply + '%d crossings' % count
            else:
                reply = reply + '1 crossing'
            print &gt;&gt;self.stdout, reply + ' of breakpoint %d.' % bpnum
        else:
            print &gt;&gt;self.stdout, 'Will stop next time breakpoint',
            print &gt;&gt;self.stdout, bpnum, 'is reached.'

</t>
<t tx="ekr.20100213083546.5251">def do_clear(self, arg):
    """Three possibilities, tried in this order:
    clear -&gt; clear all breaks, ask for confirmation
    clear file:lineno -&gt; clear all breaks at file:lineno
    clear bpno bpno ... -&gt; clear breakpoints by number"""
    if not arg:
        try:
            reply = raw_input('Clear all breaks? ')
        except EOFError:
            reply = 'no'
        reply = reply.strip().lower()
        if reply in ('y', 'yes'):
            self.clear_all_breaks()
        return
    if ':' in arg:
        # Make sure it works for "clear C:\foo\bar.py:12"
        i = arg.rfind(':')
        filename = arg[:i]
        arg = arg[i+1:]
        try:
            lineno = int(arg)
        except ValueError:
            err = "Invalid line number (%s)" % arg
        else:
            err = self.clear_break(filename, lineno)
        if err: print &gt;&gt;self.stdout, '***', err
        return
    numberlist = arg.split()
    for i in numberlist:
        try:
            i = int(i)
        except ValueError:
            print &gt;&gt;self.stdout, 'Breakpoint index %r is not a number' % i
            continue

        if not (0 &lt;= i &lt; len(bdb.Breakpoint.bpbynumber)):
            print &gt;&gt;self.stdout, 'No breakpoint numbered', i
            continue
        err = self.clear_bpbynumber(i)
        if err:
            print &gt;&gt;self.stdout, '***', err
        else:
            print &gt;&gt;self.stdout, 'Deleted breakpoint', i
            
do_cl = do_clear # 'c' is already an abbreviation for 'continue'


</t>
<t tx="ekr.20100213083546.5252">def do_where(self, arg):
    self.print_stack_trace()

do_w = do_where
do_bt = do_where

</t>
<t tx="ekr.20100213083546.5253">def do_up(self, arg):
    if self.curindex == 0:
        print &gt;&gt;self.stdout, '*** Oldest frame'
    else:
        self.curindex = self.curindex - 1
        self.curframe = self.stack[self.curindex][0]
        self.print_stack_entry(self.stack[self.curindex])
        self.lineno = None

do_u = do_up

</t>
<t tx="ekr.20100213083546.5254">def do_down(self, arg):
    if self.curindex + 1 == len(self.stack):
        print &gt;&gt;self.stdout, '*** Newest frame'
    else:
        self.curindex = self.curindex + 1
        self.curframe = self.stack[self.curindex][0]
        self.print_stack_entry(self.stack[self.curindex])
        self.lineno = None
do_d = do_down

</t>
<t tx="ekr.20100213083546.5255">def do_until(self, arg):
    self.set_until(self.curframe)
    return 1

do_unt = do_until

</t>
<t tx="ekr.20100213083546.5256">def do_step(self, arg):
    self.set_step()
    return 1

do_s = do_step

</t>
<t tx="ekr.20100213083546.5257">def do_next(self, arg):
    self.set_next(self.curframe)
    return 1

do_n = do_next

</t>
<t tx="ekr.20100213083546.5258">def do_run(self, arg):
    """Restart program by raising an exception to be caught in the main debugger
    loop. If arguments were given, set them in sys.argv."""
    if arg:
        import shlex
        argv0 = sys.argv[0:1]
        sys.argv = shlex.split(arg)
        sys.argv[:0] = argv0
    raise Restart

do_restart = do_run
</t>
<t tx="ekr.20100213083546.5259">def do_return(self, arg):
    self.set_return(self.curframe)
    return 1

do_r = do_return

</t>
<t tx="ekr.20100213083546.5260">def do_continue(self, arg):
    self.set_continue()
    return 1

do_c = do_cont = do_continue

</t>
<t tx="ekr.20100213083546.5261">def do_jump(self, arg):
    if self.curindex + 1 != len(self.stack):
        print &gt;&gt;self.stdout, "*** You can only jump within the bottom frame"
        return
    try:
        arg = int(arg)
    except ValueError:
        print &gt;&gt;self.stdout, "*** The 'jump' command requires a line number."
    else:
        try:
            # Do the jump, fix up our copy of the stack, and display the
            # new position
            self.curframe.f_lineno = arg
            self.stack[self.curindex] = self.stack[self.curindex][0], arg
            self.print_stack_entry(self.stack[self.curindex])
        except ValueError, e:
            print &gt;&gt;self.stdout, '*** Jump failed:', e
            
do_j = do_jump


</t>
<t tx="ekr.20100213083546.5262">def do_debug(self, arg):
    sys.settrace(None)
    globals = self.curframe.f_globals
    locals = self.curframe.f_locals
    p = Pdb(self.completekey, self.stdin, self.stdout)
    p.prompt = "(%s) " % self.prompt.strip()
    print &gt;&gt;self.stdout, "ENTERING RECURSIVE DEBUGGER"
    sys.call_tracing(p.run, (arg, globals, locals))
    print &gt;&gt;self.stdout, "LEAVING RECURSIVE DEBUGGER"
    sys.settrace(self.trace_dispatch)
    self.lastcmd = p.lastcmd

</t>
<t tx="ekr.20100213083546.5263">def do_quit(self, arg):
    self._user_requested_quit = 1
    self.set_quit()
    return 1

do_q = do_quit
do_exit = do_quit
</t>
<t tx="ekr.20100213083546.5264">def do_EOF(self, arg):
    print &gt;&gt;self.stdout
    self._user_requested_quit = 1
    self.set_quit()
    return 1

</t>
<t tx="ekr.20100213083546.5265">def do_args(self, arg):
    f = self.curframe
    co = f.f_code
    dict = f.f_locals
    n = co.co_argcount
    if co.co_flags &amp; 4: n = n+1
    if co.co_flags &amp; 8: n = n+1
    for i in range(n):
        name = co.co_varnames[i]
        print &gt;&gt;self.stdout, name, '=',
        if name in dict: print &gt;&gt;self.stdout, dict[name]
        else: print &gt;&gt;self.stdout, "*** undefined ***"
        
do_a = do_args
</t>
<t tx="ekr.20100213083546.5266">

def do_retval(self, arg):
    if '__return__' in self.curframe.f_locals:
        print &gt;&gt;self.stdout, self.curframe.f_locals['__return__']
    else:
        print &gt;&gt;self.stdout, '*** Not yet returned!'

do_rv = do_retval
</t>
<t tx="ekr.20100213083546.5267">def _getval(self, arg):
    try:
        return eval(arg, self.curframe.f_globals,
                    self.curframe.f_locals)
    except:
        t, v = sys.exc_info()[:2]
        if isinstance(t, str):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print &gt;&gt;self.stdout, '***', exc_type_name + ':', repr(v)
        raise

</t>
<t tx="ekr.20100213083546.5268">def do_p(self, arg):
    try:
        print &gt;&gt;self.stdout, repr(self._getval(arg))
    except:
        pass

</t>
<t tx="ekr.20100213083546.5269">def do_pp(self, arg):
    try:
        pprint.pprint(self._getval(arg), self.stdout)
    except:
        pass

</t>
<t tx="ekr.20100213083546.5270">def do_list(self, arg):
    self.lastcmd = 'list'
    last = None
    if arg:
        try:
            x = eval(arg, {}, {})
            if type(x) == type(()):
                first, last = x
                first = int(first)
                last = int(last)
                if last &lt; first:
                    # Assume it's a count
                    last = first + last
            else:
                first = max(1, int(x) - 5)
        except:
            print &gt;&gt;self.stdout, '*** Error in argument:', repr(arg)
            return
    elif self.lineno is None:
        first = max(1, self.curframe.f_lineno - 5)
    else:
        first = self.lineno + 1
    if last is None:
        last = first + 10
    filename = self.curframe.f_code.co_filename
    breaklist = self.get_file_breaks(filename)
    try:
        for lineno in range(first, last+1):
            line = linecache.getline(filename, lineno, self.curframe.f_globals)
            if not line:
                print &gt;&gt;self.stdout, '[EOF]'
                break
            else:
                s = repr(lineno).rjust(3)
                if len(s) &lt; 4: s = s + ' '
                if lineno in breaklist: s = s + 'B'
                else: s = s + ' '
                if lineno == self.curframe.f_lineno:
                    s = s + '-&gt;'
                print &gt;&gt;self.stdout, s + '\t' + line,
                self.lineno = lineno
    except KeyboardInterrupt:
        pass
</t>
<t tx="ekr.20100213083546.5271">do_l = do_list

def do_whatis(self, arg):
    try:
        value = eval(arg, self.curframe.f_globals,
                        self.curframe.f_locals)
    except:
        t, v = sys.exc_info()[:2]
        if type(t) == type(''):
            exc_type_name = t
        else: exc_type_name = t.__name__
        print &gt;&gt;self.stdout, '***', exc_type_name + ':', repr(v)
        return
    code = None
    # Is it a function?
    try: code = value.func_code
    except: pass
    if code:
        print &gt;&gt;self.stdout, 'Function', code.co_name
        return
    # Is it an instance method?
    try: code = value.im_func.func_code
    except: pass
    if code:
        print &gt;&gt;self.stdout, 'Method', code.co_name
        return
    # None of the above...
    print &gt;&gt;self.stdout, type(value)

</t>
<t tx="ekr.20100213083546.5272">def do_alias(self, arg):
    args = arg.split()
    if len(args) == 0:
        keys = self.aliases.keys()
        keys.sort()
        for alias in keys:
            print &gt;&gt;self.stdout, "%s = %s" % (alias, self.aliases[alias])
        return
    if args[0] in self.aliases and len(args) == 1:
        print &gt;&gt;self.stdout, "%s = %s" % (args[0], self.aliases[args[0]])
    else:
        self.aliases[args[0]] = ' '.join(args[1:])

</t>
<t tx="ekr.20100213083546.5273">def do_unalias(self, arg):
    args = arg.split()
    if len(args) == 0: return
    if args[0] in self.aliases:
        del self.aliases[args[0]]

</t>
<t tx="ekr.20100213083546.5274">#list of all the commands making the program resume execution.
commands_resuming = ['do_continue', 'do_step', 'do_next', 'do_return',
                     'do_quit', 'do_jump']

# Print a traceback starting at the top stack frame.
# The most recently entered frame is printed last;
# this is different from dbx and gdb, but consistent with
# the Python interpreter's stack trace.
# It is also consistent with the up/down commands (which are
# compatible with dbx and gdb: up moves towards 'main()'
# and down moves towards the most recent stack frame).

def print_stack_trace(self):
    try:
        for frame_lineno in self.stack:
            self.print_stack_entry(frame_lineno)
    except KeyboardInterrupt:
        pass

</t>
<t tx="ekr.20100213083546.5275">def print_stack_entry(self, frame_lineno, prompt_prefix=line_prefix):
    frame, lineno = frame_lineno
    if frame is self.curframe:
        print &gt;&gt;self.stdout, '&gt;',
    else:
        print &gt;&gt;self.stdout, ' ',
    print &gt;&gt;self.stdout, self.format_stack_entry(frame_lineno,
                                                 prompt_prefix)


</t>
<t tx="ekr.20100213083546.5276"># Help methods (derived from pdb.doc)

def help_help(self):
    self.help_h()

</t>
<t tx="ekr.20100213083546.5277">def help_h(self):
    print &gt;&gt;self.stdout, """h(elp)
\\-4Without argument, print the list of available commands.
\\-4With a command name as argument, print help about that command
\\-4"help pdb" pipes the full documentation file to the $PAGER
\\-4"help exec" gives help on the ! command"""

</t>
<t tx="ekr.20100213083546.5278">def help_where(self):
    self.help_w()

</t>
<t tx="ekr.20100213083546.5279">def help_w(self):
    print &gt;&gt;self.stdout, """w(here)
\\-4Print a stack trace, with the most recent frame at the bottom.
\\-4An arrow indicates the "current frame", which determines the
\\-4context of most commands.  'bt' is an alias for this command."""

</t>
<t tx="ekr.20100213083546.5280">help_bt = help_w

def help_down(self):
    self.help_d()

</t>
<t tx="ekr.20100213083546.5281">def help_d(self):
    print &gt;&gt;self.stdout, """d(own)
\\-4Move the current frame one level down in the stack trace
\\-4(to a newer frame)."""

</t>
<t tx="ekr.20100213083546.5282">def help_up(self):
    self.help_u()

</t>
<t tx="ekr.20100213083546.5283">def help_u(self):
    print &gt;&gt;self.stdout, """u(p)
\\-4Move the current frame one level up in the stack trace
\\-4(to an older frame)."""

</t>
<t tx="ekr.20100213083546.5284">def help_break(self):
    self.help_b()

</t>
<t tx="ekr.20100213083546.5285">def help_b(self):
    print &gt;&gt;self.stdout, """b(reak) ([file:]lineno | function) [, condition]
\\-4With a line number argument, set a break there in the current
\\-4file.  With a function name, set a break at first executable line
\\-4of that function.  Without argument, list all breaks.  If a second
\\-4argument is present, it is a string specifying an expression
\\-4which must evaluate to true before the breakpoint is honored.

\\-4The line number may be prefixed with a filename and a colon,
\\-4to specify a breakpoint in another file (probably one that
\\-4hasn't been loaded yet).  The file is searched for on sys.path;
\\-4the .py suffix may be omitted."""

</t>
<t tx="ekr.20100213083546.5286">def help_clear(self):
    self.help_cl()

</t>
<t tx="ekr.20100213083546.5287">def help_cl(self):
    print &gt;&gt;self.stdout, "cl(ear) filename:lineno"
    print &gt;&gt;self.stdout, """cl(ear) [bpnumber [bpnumber...]]
\\-4With a space separated list of breakpoint numbers, clear
\\-4those breakpoints.  Without argument, clear all breaks (but
\\-4first ask confirmation).  With a filename:lineno argument,
\\-4clear all breaks at that line in that file.

\\-4Note that the argument is different from previous versions of
\\-4the debugger (in python distributions 1.5.1 and before) where
\\-4a linenumber was used instead of either filename:lineno or
\\-4breakpoint numbers."""

</t>
<t tx="ekr.20100213083546.5288">def help_tbreak(self):
    print &gt;&gt;self.stdout, """tbreak  same arguments as break, but breakpoint is
\\-4removed when first hit."""

</t>
<t tx="ekr.20100213083546.5289">def help_enable(self):
    print &gt;&gt;self.stdout, """enable bpnumber [bpnumber ...]
\\-4Enables the breakpoints given as a space separated list of
\\-4bp numbers."""

</t>
<t tx="ekr.20100213083546.5290">def help_disable(self):
    print &gt;&gt;self.stdout, """disable bpnumber [bpnumber ...]
\\-4Disables the breakpoints given as a space separated list of
\\-4bp numbers."""

</t>
<t tx="ekr.20100213083546.5291">def help_ignore(self):
    print &gt;&gt;self.stdout, """ignore bpnumber count
\\-4Sets the ignore count for the given breakpoint number.  A breakpoint
\\-4becomes active when the ignore count is zero.  When non-zero, the
\\-4count is decremented each time the breakpoint is reached and the
\\-4breakpoint is not disabled and any associated condition evaluates
\\-4to true."""

</t>
<t tx="ekr.20100213083546.5292">def help_condition(self):
    print &gt;&gt;self.stdout, """condition bpnumber str_condition
\\-4str_condition is a string specifying an expression which
\\-4must evaluate to true before the breakpoint is honored.
\\-4If str_condition is absent, any existing condition is removed;
\\-4i.e., the breakpoint is made unconditional."""

</t>
<t tx="ekr.20100213083546.5293">def help_step(self):
    self.help_s()

</t>
<t tx="ekr.20100213083546.5294">def help_s(self):
    print &gt;&gt;self.stdout, """s(tep)
\\-4Execute the current line, stop at the first possible occasion
\\-4(either in a function that is called or in the current function)."""

</t>
<t tx="ekr.20100213083546.5295">def help_until(self):
    self.help_unt()

</t>
<t tx="ekr.20100213083546.5296">def help_unt(self):
    print """unt(il)
\\-4Continue execution until the line with a number greater than the current
\\-4one is reached or until the current frame returns"""

</t>
<t tx="ekr.20100213083546.5297">def help_next(self):
    self.help_n()

</t>
<t tx="ekr.20100213083546.5298">def help_n(self):
    print &gt;&gt;self.stdout, """n(ext)
\\-4Continue execution until the next line in the current function
\\-4is reached or it returns."""

</t>
<t tx="ekr.20100213083546.5299">def help_return(self):
    self.help_r()

</t>
<t tx="ekr.20100213083546.5300">def help_r(self):
    print &gt;&gt;self.stdout, """r(eturn)
\\-4Continue execution until the current function returns."""

</t>
<t tx="ekr.20100213083546.5301">def help_continue(self):
    self.help_c()

</t>
<t tx="ekr.20100213083546.5302">def help_cont(self):
    self.help_c()

</t>
<t tx="ekr.20100213083546.5303">def help_c(self):
    print &gt;&gt;self.stdout, """c(ont(inue))
\\-4Continue execution, only stop when a breakpoint is encountered."""

</t>
<t tx="ekr.20100213083546.5304">def help_jump(self):
    self.help_j()

</t>
<t tx="ekr.20100213083546.5305">def help_j(self):
    print &gt;&gt;self.stdout, """j(ump) lineno
\\-4Set the next line that will be executed."""

</t>
<t tx="ekr.20100213083546.5306">def help_debug(self):
    print &gt;&gt;self.stdout, """debug code
\\-4Enter a recursive debugger that steps through the code argument
\\-4(which is an arbitrary expression or statement to be executed
\\-4in the current environment)."""

</t>
<t tx="ekr.20100213083546.5307">def help_list(self):
    self.help_l()

</t>
<t tx="ekr.20100213083546.5308">def help_l(self):
    print &gt;&gt;self.stdout, """l(ist) [first [,last]]
\\-4List source code for the current file.
\\-4Without arguments, list 11 lines around the current line
\\-4or continue the previous listing.
\\-4With one argument, list 11 lines starting at that line.
\\-4With two arguments, list the given range;
\\-4if the second argument is less than the first, it is a count."""

</t>
<t tx="ekr.20100213083546.5309">def help_args(self):
    self.help_a()

</t>
<t tx="ekr.20100213083546.5310">def help_a(self):
    print &gt;&gt;self.stdout, """a(rgs)
\\-4Print the arguments of the current function."""

</t>
<t tx="ekr.20100213083546.5311">def help_p(self):
    print &gt;&gt;self.stdout, """p expression
\\-4Print the value of the expression."""

</t>
<t tx="ekr.20100213083546.5312">def help_pp(self):
    print &gt;&gt;self.stdout, """pp expression
\\-4Pretty-print the value of the expression."""

</t>
<t tx="ekr.20100213083546.5313">def help_exec(self):
    print &gt;&gt;self.stdout, """(!) statement
\\-4Execute the (one-line) statement in the context of
\\-4the current stack frame.
\\-4The exclamation point can be omitted unless the first word
\\-4of the statement resembles a debugger command.
\\-4To assign to a global variable you must always prefix the
\\-4command with a 'global' command, e.g.:
\\-4(Pdb) global list_options; list_options = ['-l']
\\-4(Pdb)"""

</t>
<t tx="ekr.20100213083546.5314">def help_run(self):
    print """run [args...]
\\-4Restart the debugged python program. If a string is supplied, it is
\\-4splitted with "shlex" and the result is used as the new sys.argv.
\\-4History, breakpoints, actions and debugger options are preserved.
\\-4"restart" is an alias for "run"."""

</t>
<t tx="ekr.20100213083546.5315">help_restart = help_run

def help_quit(self):
    self.help_q()

</t>
<t tx="ekr.20100213083546.5316">def help_q(self):
    print &gt;&gt;self.stdout, """q(uit) or exit - Quit from the debugger.
\\-4The program being executed is aborted."""

</t>
<t tx="ekr.20100213083546.5317">help_exit = help_q

def help_whatis(self):
    print &gt;&gt;self.stdout, """whatis arg
\\-4Prints the type of the argument."""

</t>
<t tx="ekr.20100213083546.5318">def help_EOF(self):
    print &gt;&gt;self.stdout, """EOF
\\-4Handles the receipt of EOF as a command."""

</t>
<t tx="ekr.20100213083546.5319">def help_alias(self):
    print &gt;&gt;self.stdout, """alias [name [command [parameter parameter ...] ]]
\\-4Creates an alias called 'name' the executes 'command'.  The command
\\-4must *not* be enclosed in quotes.  Replaceable parameters are
\\-4indicated by %1, %2, and so on, while %* is replaced by all the
\\-4parameters.  If no command is given, the current alias for name
\\-4is shown. If no name is given, all aliases are listed.

\\-4Aliases may be nested and can contain anything that can be
\\-4legally typed at the pdb prompt.  Note!  You *can* override
\\-4internal pdb commands with aliases!  Those internal commands
\\-4are then hidden until the alias is removed.  Aliasing is recursively
\\-4applied to the first word of the command line; all other words
\\-4in the line are left alone.

\\-4Some useful aliases (especially when placed in the .pdbrc file) are:

\\-4#Print instance variables (usage "pi classInst")
\\-4alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]

\\-4#Print instance variables in self
\\-4alias ps pi self
\\-4"""

</t>
<t tx="ekr.20100213083546.5320">def help_unalias(self):
    print &gt;&gt;self.stdout, """unalias name
\\-4Deletes the specified alias."""

</t>
<t tx="ekr.20100213083546.5321">def help_commands(self):
    print &gt;&gt;self.stdout, """commands [bpnumber]
\\-4(com) ...
\\-4(com) end
\\-4(Pdb)

\\-4Specify a list of commands for breakpoint number bpnumber.  The
\\-4commands themselves appear on the following lines.  Type a line
\\-4containing just 'end' to terminate the commands.

\\-4To remove all commands from a breakpoint, type commands and
\\-4follow it immediately with  end; that is, give no commands.

\\-4With no bpnumber argument, commands refers to the last
\\-4breakpoint set.

\\-4You can use breakpoint commands to start your program up again.
\\-4Simply use the continue command, or step, or any other
\\-4command that resumes execution.

\\-4Specifying any command resuming execution (currently continue,
\\-4step, next, return, jump, quit and their abbreviations) terminates
\\-4the command list (as if that command was immediately followed by end).
\\-4This is because any time you resume execution
\\-4(even with a simple next or step), you may encounter
\\-4another breakpoint--which could have its own command list, leading to
\\-4ambiguities about which list to execute.

\\-1If you use the 'silent' command in the command list, the
\\-4usual message about stopping at a breakpoint is not printed.  This may
\\-4be desirable for breakpoints that are to print a specific message and
\\-4then continue.  If none of the other commands print anything, you
\\-4see no sign that the breakpoint was reached.
\\-4"""

</t>
<t tx="ekr.20100213083546.5322">def help_pdb(self):
    help()

</t>
<t tx="ekr.20100213083546.5323">def lookupmodule(self, filename):
    """Helper function for break/clear parsing -- may be overridden.

    lookupmodule() translates (possibly incomplete) file or module name
    into an absolute file name.
    """
    if os.path.isabs(filename) and  os.path.exists(filename):
        return filename
    f = os.path.join(sys.path[0], filename)
    if  os.path.exists(f) and self.canonic(f) == self.mainpyfile:
        return f
    root, ext = os.path.splitext(filename)
    if ext == '':
        filename = filename + '.py'
    if os.path.isabs(filename):
        return filename
    for dirname in sys.path:
        while os.path.islink(dirname):
            dirname = os.readlink(dirname)
        fullname = os.path.join(dirname, filename)
        if os.path.exists(fullname):
            return fullname
    return None

</t>
<t tx="ekr.20100213083546.5324">def _runscript(self, filename):
    # The script has to run in __main__ namespace (or imports from
    # __main__ will break).
    #
    # So we clear up the __main__ and set several special variables
    # (this gets rid of pdb's globals and cleans old variables on restarts).
    import __main__
    __main__.__dict__.clear()
    __main__.__dict__.update({"__name__"    : "__main__",
                              "__file__"    : filename,
                              "__builtins__": __builtins__,
                             })

    # When bdb sets tracing, a number of call and line events happens
    # BEFORE debugger even reaches user's code (and the exact sequence of
    # events depends on python version). So we take special measures to
    # avoid stopping before we reach the main script (see user_line and
    # user_call for details).
    self._wait_for_mainpyfile = 1
    self.mainpyfile = self.canonic(filename)
    self._user_requested_quit = 0
    statement = 'execfile( "%s")' % filename
    self.run(statement)

</t>
<t tx="ekr.20100213083546.5325"># Simplified interface

def run(statement, globals=None, locals=None):
    Pdb().run(statement, globals, locals)

</t>
<t tx="ekr.20100213083546.5326">def runeval(expression, globals=None, locals=None):
    return Pdb().runeval(expression, globals, locals)

</t>
<t tx="ekr.20100213083546.5327">def runctx(statement, globals, locals):
    # B/W compatibility
    run(statement, globals, locals)

</t>
<t tx="ekr.20100213083546.5328">def runcall(*args, **kwds):
    return Pdb().runcall(*args, **kwds)

</t>
<t tx="ekr.20100213083546.5329">def set_trace():
    Pdb().set_trace(sys._getframe().f_back)

</t>
<t tx="ekr.20100213083546.5330"># Post-Mortem interface

def post_mortem(t=None):
    # handling the default
    if t is None:
        # sys.exc_info() returns (type, value, traceback) if an exception is
        # being handled, otherwise it returns None
        t = sys.exc_info()[2]
        if t is None:
            raise ValueError("A valid traceback must be passed if no "
                                               "exception is being handled")

    p = Pdb()
    p.reset()
    p.interaction(None, t)

</t>
<t tx="ekr.20100213083546.5331">def pm():
    post_mortem(sys.last_traceback)


</t>
<t tx="ekr.20100213083546.5332"># Main program for testing

TESTCMD = 'import x; x.main()'

def test():
    run(TESTCMD)

</t>
<t tx="ekr.20100213083546.5333"># print help
def help():
    for dirname in sys.path:
        fullname = os.path.join(dirname, 'pdb.doc')
        if os.path.exists(fullname):
            sts = os.system('${PAGER-more} '+fullname)
            if sts: print '*** Pager exit status:', sts
            break
    else:
        print 'Sorry, can\'t find the help file "pdb.doc"',
        print 'along the Python search path'

</t>
<t tx="ekr.20100213083546.5334">def main():
    if not sys.argv[1:] or sys.argv[1] in ("--help", "-h"):
        print "usage: pdb.py scriptfile [arg] ..."
        sys.exit(2)

    mainpyfile =  sys.argv[1]     # Get script filename
    if not os.path.exists(mainpyfile):
        print 'Error:', mainpyfile, 'does not exist'
        sys.exit(1)

    del sys.argv[0]         # Hide "pdb.py" from argument list

    # Replace pdb's dir with script's dir in front of module search path.
    sys.path[0] = os.path.dirname(mainpyfile)

    # Note on saving/restoring sys.argv: it's a good idea when sys.argv was
    # modified by the script being debugged. It's a bad idea when it was
    # changed by the user from the command line. There is a "restart" command which
    # allows explicit specification of command line arguments.
    pdb = Pdb()
    while 1:
        try:
            pdb._runscript(mainpyfile)
            if pdb._user_requested_quit:
                break
            print "The program finished and will be restarted"
        except Restart:
            print "Restarting", mainpyfile, "with arguments:"
            print "\t" + " ".join(sys.argv[1:])
        except SystemExit:
            # In most cases SystemExit does not warrant a post-mortem session.
            print "The program exited via sys.exit(). Exit status: ",
            print sys.exc_info()[1]
        except:
            traceback.print_exc()
            print "Uncaught exception. Entering post mortem debugging"
            print "Running 'cont' or 'step' will restart the program"
            t = sys.exc_info()[2]
            pdb.interaction(None, t)
            print "Post mortem debugger finished. The "+mainpyfile+" will be restarted"


</t>
<t tx="ekr.20100213083546.5335"></t>
<t tx="ekr.20100213083546.5336"># -------------------- testing --------------------

</t>
<t tx="ekr.20100213083546.5337"></t>
<t tx="ekr.20100213083546.5339">@nocolor-node

If a file .pdbrc exists in the users home directory or in the current
directory, it is read in and executed as if it had been typed at the debugger
prompt. This is particularly useful for aliases. If both files exist, the one in
the home directory is read first and aliases defined there can be overridden by
the local file.

</t>
<t tx="ekr.20100213083546.5340">@nocolor-node

b(reak) [[filename:]lineno | function[, condition]]

    With a lineno argument, set a break there in the current file.
    
    With a function argument, set a break at the first executable statement
    within that function. The line number may be prefixed with a filename and a
    colon, to specify a breakpoint in another file (probably one that hasnt
    been loaded yet). The file is searched on sys.path.
    
    Note that each breakpoint is assigned a number to which all the other
    breakpoint commands refer.

    If a second argument is present, it is an expression which must evaluate to
    true before the breakpoint is honored.

    Without argument, list all breaks, including for each breakpoint, the number
    of times that breakpoint has been hit, the current ignore count, and the
    associated condition if any.

tbreak [[filename:]lineno | function[, condition]]

    Temporary breakpoint, which is removed automatically when it is first hit.
    The arguments are the same as break.

cl(ear) [bpnumber [bpnumber ...]]

    With a space separated list of breakpoint numbers, clear those breakpoints.
    Without argument, clear all breaks (but first ask confirmation).

disable [bpnumber [bpnumber ...]]

    Disables the breakpoints given as a space separated list of breakpoint
    numbers. Disabling a breakpoint means it cannot cause the program to stop
    execution, but unlike clearing a breakpoint, it remains in the list of
    breakpoints and can be (re-)enabled.

enable [bpnumber [bpnumber ...]]

    Enables the breakpoints specified.

ignore bpnumber [count]

    Sets the ignore count for the given breakpoint number. If count is omitted,
    the ignore count is set to 0. A breakpoint becomes active when the ignore
    count is zero. When non-zero, the count is decremented each time the
    breakpoint is reached and the breakpoint is not disabled and any associated
    condition evaluates to true.

condition bpnumber [condition]

    Condition is an expression which must evaluate to true before the breakpoint
    is honored. If condition is absent, any existing condition is removed; i.e.,
    the breakpoint is made unconditional.

commands [bpnumber]

    Specify a list of commands for breakpoint number bpnumber. The commands
    themselves appear on the following lines. Type a line containing just end
    to terminate the commands. An example:

    (Pdb) commands 1
    (com) print some_variable
    (com) end

    To remove all commands from a breakpoint, type commands and follow it
    immediately with end; that is, give no commands.

    With no bpnumber argument, commands refers to the last breakpoint set.

    You can use breakpoint commands to start your program up again. Simply use
    the continue command, or step, or any other command that resumes execution.

    Specifying any command resuming execution (currently continue, step, next,
    return, jump, quit and their abbreviations) terminates the command list (as
    if that command was immediately followed by end). This is because any time
    you resume execution (even with a simple next or step), you may encounter
    another breakpointwhich could have its own command list, leading to
    ambiguities about which list to execute.

    If you use the silent command in the command list, the usual message about
    stopping at a breakpoint is not printed. This may be desirable for
    breakpoints that are to print a specific message and then continue. If none
    of the other commands print anything, you see no sign that the breakpoint
    was reached.
</t>
<t tx="ekr.20100214212449.8246"></t>
<t tx="ekr.20100214233301.4659"># .infer method ###############################################################

# extend all classes instead of base Node class which is an unextendable type
# in 2.6
</t>
<t tx="ekr.20100215090114.8251">@path C:\prog\pylint-0.19.0\checkers</t>
<t tx="ekr.20100215090114.8252">@language python
@tabwidth -4

"""basic checker for Python code
"""

@others
</t>
<t tx="ekr.20100215090114.8253">from logilab import astng
from logilab.common.compat import any
from logilab.common.ureports import Table
from logilab.astng.infutils import are_exclusive

from pylint.interfaces import IASTNGChecker
from pylint.reporters import diff_string
from pylint.checkers import BaseChecker

import re

# regex for class/function/variable/constant name
CLASS_NAME_RGX = re.compile('[A-Z_][a-zA-Z0-9]+$')
MOD_NAME_RGX = re.compile('(([a-z_][a-z0-9_]*)|([A-Z][a-zA-Z0-9]+))$')
CONST_NAME_RGX = re.compile('(([A-Z_][A-Z0-9_]*)|(__.*__))$')
COMP_VAR_RGX = re.compile('[A-Za-z_][A-Za-z0-9_]*$')
DEFAULT_NAME_RGX = re.compile('[a-z_][a-z0-9_]{2,30}$')
# do not require a doc string on system methods
NO_REQUIRED_DOC_RGX = re.compile('__.*__')

del re
</t>
<t tx="ekr.20100215090114.8254">def in_loop(node):
    """return True if the node is inside a kind of for loop"""
    parent = node.parent
    while parent is not None:
        if isinstance(parent, (astng.For, astng.ListComp, astng.GenExpr)):
            return True
        parent = parent.parent
    return False

</t>
<t tx="ekr.20100215090114.8255">def in_nested_list(nested_list, obj):
    """return true if the object is an element of &lt;nested_list&gt; or of a nested
    list
    """
    for elmt in nested_list:
        if isinstance(elmt, (list, tuple)):
            if in_nested_list(elmt, obj):
                return True
        elif elmt == obj:
            return True
    return False

</t>
<t tx="ekr.20100215090114.8256">def report_by_type_stats(sect, stats, old_stats):
    """make a report of

    * percentage of different types documented
    * percentage of different types with a bad name
    """
    # percentage of different types documented and/or with a bad name
    nice_stats = {}
    for node_type in ('module', 'class', 'method', 'function'):
        nice_stats[node_type] = {}
        total = stats[node_type]
        if total == 0:
            doc_percent = 0
            badname_percent = 0
        else:
            documented = total - stats['undocumented_'+node_type]
            doc_percent = float((documented)*100) / total
            badname_percent = (float((stats['badname_'+node_type])*100)
                               / total)
        nice_stats[node_type]['percent_documented'] = doc_percent
        nice_stats[node_type]['percent_badname'] = badname_percent
    lines = ('type', 'number', 'old number', 'difference',
             '%documented', '%badname')
    for node_type in ('module', 'class', 'method', 'function'):
        new = stats[node_type]
        old = old_stats.get(node_type, None)
        if old is not None:
            diff_str = diff_string(old, new)
        else:
            old, diff_str = 'NC', 'NC'
        lines += (node_type, str(new), str(old), diff_str,
                  '%.2f' % nice_stats[node_type]['percent_documented'],
                  '%.2f' % nice_stats[node_type]['percent_badname'])
    sect.append(Table(children=lines, cols=6, rheaders=1))


</t>
<t tx="ekr.20100215090114.8257">MSGS = {
    'E0100': ('__init__ method is a generator',
              'Used when the special class method __init__ is turned into a '
              'generator by a yield in its body.'),
    'E0101': ('Explicit return in __init__',
              'Used when the special class method __init__ has an explicit \
              return value.'),
    'E0102': ('%s already defined line %s',
              'Used when a function / class / method is redefined.'),
    'E0103': ('%r not properly in loop',
              'Used when break or continue keywords are used outside a loop.'),

    'E0104': ('Return outside function',
              'Used when a "return" statement is found outside a function or '
              'method.'),
    'E0105': ('Yield outside function',
              'Used when a "yield" statement is found outside a function or '
              'method.'),
    'E0106': ('Return with argument inside generator',
              'Used when a "return" statement with an argument is found '
              'outside in a generator function or method (e.g. with some '
              '"yield" statements).'),
    'E0107': ("Use of the non-existent %s operator",
              "Used when you attempt to use the C-style pre-increment or"
              "pre-decrement operator -- and ++, which doesn't exist in Python."),
    'W0101': ('Unreachable code',
              'Used when there is some code behind a "return" or "raise" \
              statement, which will never be accessed.'),
    'W0102': ('Dangerous default value %s as argument',
              'Used when a mutable value as list or dictionary is detected in \
              a default value for an argument.'),
    'W0104': ('Statement seems to have no effect',
              'Used when a statement doesn\'t have (or at least seems to) \
              any effect.'),
    'W0105': ('String statement has no effect',
              'Used when a string is used as a statement (which of course \
              has no effect). This is a particular case of W0104 with its \
              own message so you can easily disable it if you\'re using \
              those strings as documentation, instead of comments.'),
    'W0107': ('Unnecessary pass statement',
              'Used when a "pass" statement that can be avoided is '
              'encountered.)'),
    'W0108': ('Lambda may not be necessary',
              'Used when the body of a lambda expression is a function call \
              on the same argument list as the lambda itself; such lambda \
              expressions are in all but a few cases replaceable with the \
              function being called in the body of the lambda.'),
    'W0109': ("Duplicate key %r in dictionary",
              "Used when a dictionary expression binds the same key multiple \
              times."),
    'W0122': ('Use of the exec statement',
              'Used when you use the "exec" statement, to discourage its \
              usage. That doesn\'t mean you can not use it !'),

    'W0141': ('Used builtin function %r',
              'Used when a black listed builtin function is used (see the '
              'bad-function option). Usual black listed functions are the ones '
              'like map, or filter , where Python offers now some cleaner '
              'alternative like list comprehension.'),
    'W0142': ('Used * or ** magic',
              'Used when a function or method is called using `*args` or '
              '`**kwargs` to dispatch arguments. This doesn\'t improve '
              'readability and should be used with care.'),

    'C0102': ('Black listed name "%s"',
              'Used when the name is listed in the black list (unauthorized \
              names).'),
    'C0103': ('Invalid name "%s" (should match %s)',
              'Used when the name doesn\'t match the regular expression \
              associated to its type (constant, variable, class...).'),

    'C0111': ('Missing docstring', # W0131
              'Used when a module, function, class or method has no docstring.\
              Some special methods like __init__ doesn\'t necessary require a \
              docstring.'),
    'C0112': ('Empty docstring', # W0132
              'Used when a module, function, class or method has an empty \
              docstring (it would be too easy ;).'),

    'C0121': ('Missing required attribute "%s"', # W0103
              'Used when an attribute required for modules is missing.'),

    }

class BasicChecker(BaseChecker):
    """checks for :
    * doc strings
    * modules / classes / functions / methods / arguments / variables name
    * number of arguments, local variables, branches, returns and statements in
functions, methods
    * required module attributes
    * dangerous default values as arguments
    * redefinition of function / method / class
    * uses of the global statement
    """

    __implements__ = IASTNGChecker

    name = 'basic'
    msgs = MSGS
    priority = -1
    options = (('required-attributes',
                {'default' : (), 'type' : 'csv',
                 'metavar' : '&lt;attributes&gt;',
                 'help' : 'Required attributes for module, separated by a '
                          'comma'}
                ),
               ('no-docstring-rgx',
                {'default' : NO_REQUIRED_DOC_RGX,
                 'type' : 'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match '
                          'functions or classes name which do not require a '
                          'docstring'}
                ),
##                ('min-name-length',
##                 {'default' : 3, 'type' : 'int', 'metavar' : '&lt;int&gt;',
##                  'help': 'Minimal length for module / class / function / '
##                          'method / argument / variable names'}
##                 ),
               ('module-rgx',
                {'default' : MOD_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'module names'}
                ),
               ('const-rgx',
                {'default' : CONST_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'module level names'}
                ),
               ('class-rgx',
                {'default' : CLASS_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'class names'}
                ),
               ('function-rgx',
                {'default' : DEFAULT_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'function names'}
                ),
               ('method-rgx',
                {'default' : DEFAULT_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'method names'}
                ),
               ('attr-rgx',
                {'default' : DEFAULT_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'instance attribute names'}
                ),
               ('argument-rgx',
                {'default' : DEFAULT_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'argument names'}),
               ('variable-rgx',
                {'default' : DEFAULT_NAME_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'variable names'}
                ),
               ('inlinevar-rgx',
                {'default' : COMP_VAR_RGX,
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'Regular expression which should only match correct '
                          'list comprehension / generator expression variable \
                          names'}
                ),
               ('good-names',
                {'default' : ('i', 'j', 'k', 'ex', 'Run', '_'),
                 'type' :'csv', 'metavar' : '&lt;names&gt;',
                 'help' : 'Good variable names which should always be accepted,'
                          ' separated by a comma'}
                ),
               ('bad-names',
                {'default' : ('foo', 'bar', 'baz', 'toto', 'tutu', 'tata'),
                 'type' :'csv', 'metavar' : '&lt;names&gt;',
                 'help' : 'Bad variable names which should always be refused, '
                          'separated by a comma'}
                ),

               ('bad-functions',
                {'default' : ('map', 'filter', 'apply', 'input'),
                 'type' :'csv', 'metavar' : '&lt;builtin function names&gt;',
                 'help' : 'List of builtins function names that should not be '
                          'used, separated by a comma'}
                ),
               )
    reports = ( ('R0101', 'Statistics by type', report_by_type_stats), )

    @others
</t>
<t tx="ekr.20100215090114.8258">def __init__(self, linter):
    BaseChecker.__init__(self, linter)
    self.stats = None
    self._returns = None
</t>
<t tx="ekr.20100215090114.8259">def open(self):
    """initialize visit variables and statistics
    """
    self._returns = []
    self.stats = self.linter.add_stats(
        module=0, function=0,
        method=0, class_=0,
        badname_module=0,
        badname_class=0, badname_function=0,
        badname_method=0, badname_attr=0,
        badname_const=0,
        badname_variable=0,
        badname_inlinevar=0,
        badname_argument=0,
        undocumented_module=0,
        undocumented_function=0,
        undocumented_method=0,
        undocumented_class=0)
</t>
<t tx="ekr.20100215090114.8260">def visit_module(self, node):
    """check module name, docstring and required arguments
    """
    self.stats['module'] += 1
    self._check_name('module', node.name.split('.')[-1], node)
    self._check_docstring('module', node)
    self._check_required_attributes(node, self.config.required_attributes)
</t>
<t tx="ekr.20100215090114.8261">def visit_class(self, node):
    """check module name, docstring and redefinition
    increment branch counter
    """
    self.stats['class'] += 1
    self._check_name('class', node.name, node)
    if self.config.no_docstring_rgx.match(node.name) is None:
        self._check_docstring('class', node)
    self._check_redefinition('class', node)
    for attr, anodes in node.instance_attrs.items():
        self._check_name('attr', attr, anodes[0])

</t>
<t tx="ekr.20100215090114.8262">def visit_discard(self, node):
    """check for various kind of statements without effect"""
    expr = node.value
    if isinstance(expr, astng.Const) and isinstance(expr.value, basestring):
        # treat string statement in a separated message
        self.add_message('W0105', node=node)
        return
    # ignore if this is :
    # * a function call (can't predicate side effects)
    # * the unique children of a try/except body
    # * a yield (which are wrapped by a discard node in _ast XXX)
    if not (any(expr.nodes_of_class((astng.CallFunc, astng.Yield)))
            or isinstance(node.parent, astng.TryExcept) and node.parent.body == [node]):
        self.add_message('W0104', node=node)

</t>
<t tx="ekr.20100215090114.8263">def visit_pass(self, node):
    """check is the pass statement is really necessary
    """
    # if self._returns is empty, we're outside a function !
    if len(node.parent.child_sequence(node)) &gt; 1:
        self.add_message('W0107', node=node)

</t>
<t tx="ekr.20100215090114.8264">def visit_lambda(self, node):
    """check whether or not the lambda is suspicious
    """
    # if the body of the lambda is a call expression with the same
    # argument list as the lambda itself, then the lambda is
    # possibly unnecessary and at least suspicious.
    if node.args.defaults:
        # If the arguments of the lambda include defaults, then a
        # judgment cannot be made because there is no way to check
        # that the defaults defined by the lambda are the same as
        # the defaults defined by the function called in the body
        # of the lambda.
        return
    call = node.body
    if not isinstance(call, astng.CallFunc):
        # The body of the lambda must be a function call expression
        # for the lambda to be unnecessary.
        return
    # XXX are lambda still different with astng &gt;= 0.18 ?
    # *args and **kwargs need to be treated specially, since they
    # are structured differently between the lambda and the function
    # call (in the lambda they appear in the args.args list and are
    # indicated as * and ** by two bits in the lambda's flags, but
    # in the function call they are omitted from the args list and
    # are indicated by separate attributes on the function call node).
    ordinary_args = list(node.args.args)
    if node.args.kwarg:
        if (not call.kwargs
            or not isinstance(call.kwargs, astng.Name)
            or node.args.kwarg != call.kwargs.name):
            return
    elif call.kwargs:
        return
    if node.args.vararg:
        if (not call.starargs
            or not isinstance(call.starargs, astng.Name)
            or node.args.vararg != call.starargs.name):
            return
    elif call.starargs:
        return

    # The "ordinary" arguments must be in a correspondence such that:
    # ordinary_args[i].name == call.args[i].name.
    if len(ordinary_args) != len(call.args):
        return
    for i in xrange(len(ordinary_args)):
        if not isinstance(call.args[i], astng.Name):
            return
        if node.args.args[i].name != call.args[i].name:
            return
    self.add_message('W0108', line=node.fromlineno, node=node)
</t>
<t tx="ekr.20100215090114.8265">def visit_function(self, node):
    """check function name, docstring, arguments, redefinition,
    variable names, max locals
    """
    is_method = node.is_method()
    self._returns.append([])
    f_type = is_method and 'method' or 'function'
    self.stats[f_type] += 1
    # function name
    self._check_name(f_type, node.name, node)
    # docstring
    if self.config.no_docstring_rgx.match(node.name) is None:
        self._check_docstring(f_type, node)
    # check default arguments'value
    self._check_defaults(node)
    # check arguments name
    args = node.args.args
    if args is not None:
        self._recursive_check_names(args, node)
    # check for redefinition
    self._check_redefinition(is_method and 'method' or 'function', node)

</t>
<t tx="ekr.20100215090114.8266">def leave_function(self, node):
    """most of the work is done here on close:
    checks for max returns, branch, return in __init__
    """
    returns = self._returns.pop()
    if node.is_method() and node.name == '__init__':
        if node.is_generator():
            self.add_message('E0100', node=node)
        else:
            values = [r.value for r in returns]
            if  [v for v in values if not (v is None or
                (isinstance(v, astng.Const) and v.value is None)
                or  (isinstance(v, astng.Name) and v.name == 'None'))]:
                self.add_message('E0101', node=node)
    elif node.is_generator():
        # make sure we don't mix non-None returns and yields
        for retnode in returns:
            if isinstance(retnode, astng.Return) and \
                   isinstance(retnode.value, astng.Const) and \
                   retnode.value.value is not None:
                self.add_message('E0106', node=node,
                                 line=retnode.fromlineno)

</t>
<t tx="ekr.20100215090114.8267">def visit_assname(self, node):
    """check module level assigned names"""
    frame = node.frame()
    ass_type = node.ass_type()
    if isinstance(ass_type, (astng.Comprehension, astng.Comprehension)):
        self._check_name('inlinevar', node.name, node)
    elif isinstance(frame, astng.Module):
        if isinstance(ass_type, astng.Assign) and not in_loop(ass_type):
            self._check_name('const', node.name, node)
    elif isinstance(frame, astng.Function):
        # global introduced variable aren't in the function locals
        if node.name in frame:
            self._check_name('variable', node.name, node)
            
    

</t>
<t tx="ekr.20100215090114.8268">def visit_return(self, node):
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    # if self._returns is empty, we're outside a function !
    if not self._returns:
        self.add_message('E0104', node=node)
        return
    self._returns[-1].append(node)
    self._check_unreachable(node)

</t>
<t tx="ekr.20100215090114.8269">def visit_yield(self, node):
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    # if self._returns is empty, we're outside a function !
    if not self._returns:
        self.add_message('E0105', node=node)
        return
    self._returns[-1].append(node)

</t>
<t tx="ekr.20100215090114.8270">def visit_continue(self, node):
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    self._check_unreachable(node)
    self._check_in_loop(node, 'continue')

</t>
<t tx="ekr.20100215090114.8271">def visit_break(self, node):
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    self._check_unreachable(node)
    self._check_in_loop(node, 'break')

</t>
<t tx="ekr.20100215090114.8272">def visit_raise(self, node):
    """check is the node has a right sibling (if so, that's some unreachable
    code)
    """
    self._check_unreachable(node)

</t>
<t tx="ekr.20100215090114.8273">def visit_exec(self, node):
    """just print a warning on exec statements"""
    self.add_message('W0122', node=node)

</t>
<t tx="ekr.20100215090114.8274">def visit_callfunc(self, node):
    """visit a CallFunc node -&gt; check if this is not a blacklisted builtin
    call and check for * or ** use
    """
    if isinstance(node.func, astng.Name):
        name = node.func.name
        # ignore the name if it's not a builtin (i.e. not defined in the
        # locals nor globals scope)
        if not (
            node.frame().has_key(name) or node.root().has_key(name)
        ):
            if name in self.config.bad_functions:
                self.add_message('W0141', node=node, args=name)

    if node.starargs or node.kwargs:
        scope = node.scope()
        if isinstance(scope, astng.Function):
            toprocess = [(n, vn) for (n, vn) in (
                (node.starargs, scope.args.vararg),
                (node.kwargs, scope.args.kwarg)) if n]
            if toprocess:
                for cfnode, fargname in toprocess[:]:
                    if getattr(cfnode, 'name', None) == fargname:
                        toprocess.remove((cfnode, fargname))
                if not toprocess:
                    return # W0142 can be skipped
        self.add_message('W0142', node=node.func)
</t>
<t tx="ekr.20100215090114.8275">def visit_unaryop(self, node):
    """check use of the non-existent ++ and -- operator operator"""
    if ((node.op in '+-') and
        isinstance(node.operand, astng.UnaryOp) and
        (node.operand.op == node.op)):
        self.add_message('E0107', node=node, args=node.op*2)

</t>
<t tx="ekr.20100215090114.8276">def visit_dict(self, node):
    """check duplicate key in dictionary"""
    keys = set()
    for k, v in node.items:
        if isinstance(k, astng.Const):
            key = k.value
            if key in keys:
                self.add_message('W0109', node=node, args=key)
            keys.add(key)


</t>
<t tx="ekr.20100215090114.8277">def _check_unreachable(self, node):
    """check unreachable code"""
    unreach_stmt = node.next_sibling()
    if unreach_stmt is not None:
        self.add_message('W0101', node=unreach_stmt)

</t>
<t tx="ekr.20100215090114.8278">def _check_in_loop(self, node, node_name):
    """check that a node is inside a for or while loop"""
    _node = node.parent
    while _node:
        if isinstance(_node, (astng.For, astng.While)):
            break
        _node = _node.parent
    else:
        self.add_message('E0103', node=node, args=node_name)

</t>
<t tx="ekr.20100215090114.8279">def _check_redefinition(self, redef_type, node):
    """check for redefinition of a function / method / class name"""
    defined_self = node.parent.frame()[node.name]
    if defined_self is not node and not are_exclusive(node, defined_self):
        self.add_message('E0102', node=node,
                         args=(redef_type, defined_self.fromlineno))

</t>
<t tx="ekr.20100215090114.8280">def _check_docstring(self, node_type, node):
    """check the node has a non empty docstring"""
    docstring = node.doc
    if docstring is None:
        self.stats['undocumented_'+node_type] += 1
        self.add_message('C0111', node=node)
    elif not docstring.strip():
        self.stats['undocumented_'+node_type] += 1
        self.add_message('C0112', node=node)

</t>
<t tx="ekr.20100215090114.8281">def _recursive_check_names(self, args, node):
    """check names in a possibly recursive list &lt;arg&gt;"""
    for arg in args:
        #if type(arg) is type(''):
        if isinstance(arg, astng.AssName):
            self._check_name('argument', arg.name, node)
        else:
            self._recursive_check_names(arg.elts, node)

</t>
<t tx="ekr.20100215090114.8282">def _check_name(self, node_type, name, node):
    """check for a name using the type's regexp"""
    if name in self.config.good_names:
        return
    if name in self.config.bad_names:
        self.stats['badname_' + node_type] += 1
        self.add_message('C0102', node=node, args=name)
        return
    regexp = getattr(self.config, node_type + '_rgx')
    if regexp.match(name) is None:
        self.add_message('C0103', node=node, args=(name, regexp.pattern))
        self.stats['badname_' + node_type] += 1


</t>
<t tx="ekr.20100215090114.8283">def _check_defaults(self, node):
    """check for dangerous default values as arguments"""
    for default in node.args.defaults:
        try:
            value = default.infer().next()
        except astng.InferenceError:
            continue
        if isinstance(value, (astng.Dict, astng.List)):
            if value is default:
                msg = default.as_string()
            else:
                msg = '%s (%s)' % (default.as_string(), value.as_string())
            self.add_message('W0102', node=node, args=(msg,))
</t>
<t tx="ekr.20100215090114.8284">def _check_required_attributes(self, node, attributes):
    """check for required attributes"""
    for attr in attributes:
        if not node.has_key(attr):
            self.add_message('C0121', node=node, args=attr)


</t>
<t tx="ekr.20100215090114.8285">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(BasicChecker(linter))
</t>
<t tx="ekr.20100215090114.8286">@language python
@tabwidth -4

"""classes checker for Python code
"""

@others
</t>
<t tx="ekr.20100215090114.8287">from __future__ import generators

from logilab import astng
from logilab.astng.infutils import YES, Instance, are_exclusive

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker
from pylint.checkers.utils import PYMETHODS, overrides_a_method

MSGS = {
    'F0202': ('Unable to check methods signature (%s / %s)',
              'Used when PyLint has been unable to check methods signature \
              compatibility for an unexpected reason. Please report this kind \
              if you don\'t make sense of it.'),

    'E0202': ('An attribute inherited from %s hide this method',
              'Used when a class defines a method which is hidden by an \
              instance attribute from an ancestor class.'),
    'E0203': ('Access to member %r before its definition line %s',
              'Used when an instance member is accessed before it\'s actually\
              assigned.'),
    'W0201': ('Attribute %r defined outside __init__',
              'Used when an instance attribute is defined outside the __init__\
              method.'),

    'W0212': ('Access to a protected member %s of a client class', # E0214
              'Used when a protected member (i.e. class member with a name \
              beginning with an underscore) is access outside the class or a \
              descendant of the class where it\'s defined.'),

    'E0211': ('Method has no argument',
              'Used when a method which should have the bound instance as \
              first argument has no argument defined.'),
    'E0213': ('Method should have "self" as first argument',
              'Used when a method has an attribute different the "self" as\
              first argument. This is considered as an error since this is\
              a so common convention that you shouldn\'t break it!'),
    'C0202': ('Class method should have "cls" as first argument', # E0212
              'Used when a class method has an attribute different than "cls"\
              as first argument, to easily differentiate them from regular \
              instance methods.'),
    'C0203': ('Metaclass method should have "mcs" as first argument', # E0214
              'Used when a metaclass method has an attribute different the \
              "mcs" as first argument.'),

    'W0211': ('Static method with %r as first argument',
              'Used when a static method has "self" or "cls" as first argument.'
              ),
    'R0201': ('Method could be a function',
              'Used when a method doesn\'t use its bound instance, and so could\
              be written as a function.'
              ),

    'E0221': ('Interface resolved to %s is not a class',
              'Used when a class claims to implement an interface which is not \
              a class.'),
    'E0222': ('Missing method %r from %s interface' ,
              'Used when a method declared in an interface is missing from a \
              class implementing this interface'),
    'W0221': ('Arguments number differs from %s method',
              'Used when a method has a different number of arguments than in \
              the implemented interface or in an overridden method.'),
    'W0222': ('Signature differs from %s method',
              'Used when a method signature is different than in the \
              implemented interface or in an overridden method.'),
    'W0223': ('Method %r is abstract in class %r but is not overridden',
              'Used when an abstract method (i.e. raise NotImplementedError) is \
              not overridden in concrete class.'
              ),
    'F0220': ('failed to resolve interfaces implemented by %s (%s)', # W0224
              'Used when a PyLint as failed to find interfaces implemented by \
               a class'),


    'W0231': ('__init__ method from base class %r is not called',
              'Used when an ancestor class method has an __init__ method \
              which is not called by a derived class.'),
    'W0232': ('Class has no __init__ method',
              'Used when a class has no __init__ method, neither its parent \
              classes.'),
    'W0233': ('__init__ method from a non direct base class %r is called',
              'Used when an __init__ method is called on a class which is not \
              in the direct ancestors for the analysed class.'),

    }


</t>
<t tx="ekr.20100215090114.8288">class ClassChecker(BaseChecker):
    """checks for :
    * methods without self as first argument
    * overridden methods signature
    * access only to existent members via self
    * attributes not defined in the __init__ method
    * supported interfaces implementation
    * unreachable code
    """

    __implements__ = (IASTNGChecker,)

    # configuration section name
    name = 'classes'
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = (('ignore-iface-methods',
                {'default' : (#zope interface
        'isImplementedBy', 'deferred', 'extends', 'names',
        'namesAndDescriptions', 'queryDescriptionFor',  'getBases',
        'getDescriptionFor', 'getDoc', 'getName', 'getTaggedValue',
        'getTaggedValueTags', 'isEqualOrExtendedBy', 'setTaggedValue',
        'isImplementedByInstancesOf',
        # twisted
        'adaptWith',
        # logilab.common interface
        'is_implemented_by'),
                 'type' : 'csv',
                 'metavar' : '&lt;method names&gt;',
                 'help' : 'List of interface methods to ignore, \
separated by a comma. This is used for instance to not check methods defines \
in Zope\'s Interface base class.'}
                ),

               ('defining-attr-methods',
                {'default' : ('__init__', '__new__', 'setUp'),
                 'type' : 'csv',
                 'metavar' : '&lt;method names&gt;',
                 'help' : 'List of method names used to declare (i.e. assign) \
instance attributes.'}
                ),

               )

    @others
</t>
<t tx="ekr.20100215090114.8289">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self._accessed = []
    self._first_attrs = []
    self._meth_could_be_func = None

</t>
<t tx="ekr.20100215090114.8290">def visit_class(self, node):
    """init visit variable _accessed and check interfaces
    """
    self._accessed.append({})
    self._check_bases_classes(node)
    self._check_interfaces(node)
    # if not an interface, exception, metaclass
    if node.type == 'class':
        try:
            node.local_attr('__init__')
        except astng.NotFoundError:
            self.add_message('W0232', args=node, node=node)

</t>
<t tx="ekr.20100215090114.8291">def leave_class(self, cnode):
    """close a class node:
    check that instance attributes are defined in __init__ and check
    access to existent members
    """
    # checks attributes are defined in an allowed method such as __init__
    defining_methods = self.config.defining_attr_methods
    for attr, nodes in cnode.instance_attrs.items():
        nodes = [n for n in nodes if not
                isinstance(n.statement(), (astng.Delete, astng.AugAssign))]
        if not nodes:
            continue # error detected by typechecking
        node = nodes[0] # XXX
        frame = node.frame()
        if frame.name not in defining_methods:
            # check attribute is defined in a parent's __init__
            for parent in cnode.instance_attr_ancestors(attr):
                frame = parent.instance_attrs[attr][0].frame() # XXX
                if frame.name in defining_methods:
                    # we're done :)
                    break
            else:
                # check attribute is defined as a class attribute
                try:
                    cnode.local_attr(attr)
                except astng.NotFoundError:
                    self.add_message('W0201', args=attr, node=node)
    # check access to existent members on non metaclass classes
    accessed = self._accessed.pop()
    if cnode.type != 'metaclass':
        self._check_accessed_members(cnode, accessed)

</t>
<t tx="ekr.20100215090114.8292">def visit_function(self, node):
    """check method arguments, overriding"""
    # ignore actual functions
    if not node.is_method():
        return
    klass = node.parent.frame()
    self._meth_could_be_func = True
    # check first argument is self if this is actually a method
    self._check_first_arg_for_type(node, klass.type == 'metaclass')
    if node.name == '__init__':
        self._check_init(node)
        return
    # check signature if the method overloads inherited method
    for overridden in klass.local_attr_ancestors(node.name):
        # get astng for the searched method
        try:
            meth_node = overridden[node.name]
        except KeyError:
            # we have found the method but it's not in the local
            # dictionary.
            # This may happen with astng build from living objects
            continue
        if not isinstance(meth_node, astng.Function):
            continue
        self._check_signature(node, meth_node, 'overridden')
        break
    # check if the method overload an attribute
    try:
        overridden = klass.instance_attr(node.name)[0] # XXX
        # we may be unable to get owner class if this is a monkey
        # patched method
        while overridden.parent and not isinstance(overridden, astng.Class):
            overridden = overridden.parent.frame()
        self.add_message('E0202', args=overridden.name, node=node)
    except astng.NotFoundError:
        pass

</t>
<t tx="ekr.20100215090114.8293">def leave_function(self, node):
    """on method node, check if this method couldn't be a function

    ignore class, static and abstract methods, initializer,
    methods overridden from a parent class and any
    kind of method defined in an interface for this warning
    """
    if node.is_method():
        if node.args.args is not None:
            self._first_attrs.pop()
        class_node = node.parent.frame()
        if (self._meth_could_be_func and node.type == 'method'
            and not node.name in PYMETHODS
            and not (node.is_abstract() or
                     overrides_a_method(class_node, node.name))
            and class_node.type != 'interface'):
            self.add_message('R0201', node=node)

</t>
<t tx="ekr.20100215090114.8294">def visit_getattr(self, node):
    """check if the getattr is an access to a class member
    if so, register it. Also check for access to protected
    class member from outside its class (but ignore __special__
    methods)
    """
    attrname = node.attrname
    if self._first_attrs and isinstance(node.expr, astng.Name) and \
           node.expr.name == self._first_attrs[-1]:
        self._accessed[-1].setdefault(attrname, []).append(node)
    elif attrname[0] == '_' and not attrname == '_' and not (
         attrname.startswith('__') and attrname.endswith('__')):
        # XXX move this in a reusable function
        klass = node.frame()
        while klass is not None and not isinstance(klass, astng.Class):
            if klass.parent is None:
                klass = None
            else:
                klass = klass.parent.frame()
        # XXX infer to be more safe and less dirty ??
        # in classes, check we are not getting a parent method
        # through the class object or through super
        callee = node.expr.as_string()
        if klass is None or not (callee == klass.name or
            callee in klass.basenames
            or (isinstance(node.expr, astng.CallFunc)
                and isinstance(node.expr.func, astng.Name)
                and node.expr.func.name == 'super')):
            self.add_message('W0212', node=node, args=attrname)
</t>
<t tx="ekr.20100215090114.8295">def visit_name(self, node):
    """check if the name handle an access to a class member
    if so, register it
    """
    if self._first_attrs and (node.name == self._first_attrs[-1] or
                              not self._first_attrs[-1]):
        self._meth_could_be_func = False

</t>
<t tx="ekr.20100215090114.8296">def _check_accessed_members(self, node, accessed):
    """check that accessed members are defined"""
    # XXX refactor, probably much simpler now that E0201 is in type checker
    for attr, nodes in accessed.items():
        # deactivate "except doesn't do anything", that's expected
        # pylint: disable-msg=W0704
        # is it a class attribute ?
        try:
            node.local_attr(attr)
            # yes, stop here
            continue
        except astng.NotFoundError:
            pass
        # is it an instance attribute of a parent class ?
        try:
            node.instance_attr_ancestors(attr).next()
            # yes, stop here
            continue
        except StopIteration:
            pass
        # is it an instance attribute ?
        try:
            defstmts = node.instance_attr(attr)
        except astng.NotFoundError:
            pass
        else:
            if len(defstmts) == 1:
                defstmt = defstmts[0]
                # check that if the node is accessed in the same method as
                # it's defined, it's accessed after the initial assignment
                frame = defstmt.frame()
                lno = defstmt.fromlineno
                for _node in nodes:
                    if _node.frame() is frame and _node.fromlineno &lt; lno \
                       and not are_exclusive(_node.statement(), defstmt, ('AttributeError', 'Exception', 'BaseException')):
                        self.add_message('E0203', node=_node,
                                         args=(attr, lno))

</t>
<t tx="ekr.20100215090114.8297">def _check_first_arg_for_type(self, node, metaclass=0):
    """check the name of first argument, expect:

    * 'self' for a regular method
    * 'cls' for a class method
    * 'mcs' for a metaclass
    * not one of the above for a static method
    """
    # don't care about functions with unknown argument (builtins)
    if node.args.args is None:
        return
    first_arg = node.args.args and node.argnames()[0]
    self._first_attrs.append(first_arg)
    first = self._first_attrs[-1]
    # static method
    if node.type == 'staticmethod':
        if first_arg in ('self', 'cls', 'mcs'):
            self.add_message('W0211', args=first, node=node)
        self._first_attrs[-1] = None
    # class / regular method with no args
    elif not node.args.args:
        self.add_message('E0211', node=node)
    # metaclass method
    elif metaclass:
        if first != 'mcs':
            self.add_message('C0203', node=node)
    # class method
    elif node.type == 'classmethod':
        if first != 'cls':
            self.add_message('C0202', node=node)
    # regular method without self as argument
    elif first != 'self':
        self.add_message('E0213', node=node)

</t>
<t tx="ekr.20100215090114.8298">def _check_bases_classes(self, node):
    """check that the given class node implements abstract methods from
    base classes
    """
    for method in node.methods():
        owner = method.parent.frame()
        if owner is node:
            continue
        # owner is not this class, it must be a parent class
        # check that the ancestor's method is not abstract
        if method.is_abstract(pass_is_abstract=False):
            self.add_message('W0223', node=node,
                             args=(method.name, owner.name))

</t>
<t tx="ekr.20100215090114.8299">def _check_interfaces(self, node):
    """check that the given class node really implements declared
    interfaces
    """
    e0221_hack = [False]
    def iface_handler(obj):
        """filter interface objects, it should be classes"""
        if not isinstance(obj, astng.Class):
            e0221_hack[0] = True
            self.add_message('E0221', node=node,
                             args=(obj.as_string(),))
            return False
        return True
    ignore_iface_methods = self.config.ignore_iface_methods
    try:
        for iface in node.interfaces(handler_func=iface_handler):
            for imethod in iface.methods():
                name = imethod.name
                if name.startswith('_') or name in ignore_iface_methods:
                    # don't check method beginning with an underscore,
                    # usually belonging to the interface implementation
                    continue
                # get class method astng
                try:
                    method = node_method(node, name)
                except astng.NotFoundError:
                    self.add_message('E0222', args=(name, iface.name),
                                     node=node)
                    continue
                # ignore inherited methods
                if method.parent.frame() is not node:
                    continue
                # check signature
                self._check_signature(method, imethod,
                                     '%s interface' % iface.name)
    except astng.InferenceError:
        if e0221_hack[0]:
            return
        implements = Instance(node).getattr('__implements__')[0]
        assignment = implements.parent
        assert isinstance(assignment, astng.Assign)
        # assignment.expr can be a Name or a Tuple or whatever.
        # Use as_string() for the message
        # FIXME: in case of multiple interfaces, find which one could not
        #        be resolved
        self.add_message('F0220', node=implements,
            args=(node.name, assignment.value.as_string()))
</t>
<t tx="ekr.20100215090114.8300">def _check_init(self, node):
    """check that the __init__ method call super or ancestors'__init__
    method
    """
    klass_node = node.parent.frame()
    to_call = _ancestors_to_call(klass_node)
    for stmt in node.nodes_of_class(astng.CallFunc):
        expr = stmt.func
        if not isinstance(expr, astng.Getattr) \
               or expr.attrname != '__init__':
            continue
        # skip the test if using super
        if isinstance(expr.expr, astng.CallFunc) and \
           isinstance(expr.expr.func, astng.Name) and \
           expr.expr.func.name == 'super':
            return
        try:
            klass = expr.expr.infer().next()
            if klass is YES:
                continue
            try:
                del to_call[klass]
            except KeyError:
                self.add_message('W0233', node=expr, args=klass.name)
        except astng.InferenceError:
            continue
    for klass in to_call.keys():
        if klass.name == 'object':
            continue
        self.add_message('W0231', args=klass.name, node=node)

</t>
<t tx="ekr.20100215090114.8301">def _check_signature(self, method1, refmethod, class_type):
    """check that the signature of the two given methods match

    class_type is in 'class', 'interface'
    """
    if not (
        isinstance(method1, astng.Function)
        and isinstance(refmethod, astng.Function)
    ):
        self.add_message('F0202', args=(method1, refmethod), node=method1)
        return

    # don't care about functions with unknown argument (builtins)
    if method1.args.args is None or refmethod.args.args is None:
        return

    if len(method1.args.args) != len(refmethod.args.args):
        self.add_message('W0221', args=class_type, node=method1)

    elif len(method1.args.defaults) &lt; len(refmethod.args.defaults):
        self.add_message('W0222', args=class_type, node=method1)


</t>
<t tx="ekr.20100215090114.8302">def _ancestors_to_call(klass_node, method='__init__'):
    """return a dictionary where keys are the list of base classes providing
    the queried method, and so that should/may be called from the method node
    """
    to_call = {}
    for base_node in klass_node.ancestors(recurs=False):
        try:
            base_node.local_attr(method)
            to_call[base_node] = 1
        except astng.NotFoundError:
            continue
    return to_call


</t>
<t tx="ekr.20100215090114.8303">def node_method(node, method_name):
    """get astng for &lt;method_name&gt; on the given class node, ensuring it
    is a Function node
    """
    for n in node.local_attr(method_name):
        if isinstance(n, astng.Function):
            return n
    raise astng.NotFoundError(method_name)

</t>
<t tx="ekr.20100215090114.8304">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(ClassChecker(linter))
</t>
<t tx="ekr.20100215090114.8305">@language python
@tabwidth -4

"""check for signs of poor design

 see http://intranet.logilab.fr/jpl/view?rql=Any%20X%20where%20X%20eid%201243
 FIXME: missing 13, 15, 16
"""

@others
</t>
<t tx="ekr.20100215090114.8306">from logilab.astng import Function, If, InferenceError

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker

</t>
<t tx="ekr.20100215090114.8307">def class_is_abstract(klass):
    """return true if the given class node should be considered as an abstract
    class
    """
    for attr in klass.values():
        if isinstance(attr, Function):
            if attr.is_abstract(pass_is_abstract=False):
                return True
    return False


</t>
<t tx="ekr.20100215090114.8308">MSGS = {
    'R0901': ('Too many ancestors (%s/%s)',
              'Used when class has too many parent classes, try to reduce \
              this to get a more simple (and so easier to use) class.'),
    'R0902': ('Too many instance attributes (%s/%s)',
              'Used when class has too many instance attributes, try to reduce \
              this to get a more simple (and so easier to use) class.'),
    'R0903': ('Too few public methods (%s/%s)',
              'Used when class has too few public methods, so be sure it\'s \
              really worth it.'),
    'R0904': ('Too many public methods (%s/%s)',
              'Used when class has too many public methods, try to reduce \
              this to get a more simple (and so easier to use) class.'),

    'R0911': ('Too many return statements (%s/%s)',
              'Used when a function or method has too many return statement, \
              making it hard to follow.'),
    'R0912': ('Too many branches (%s/%s)',
              'Used when a function or method has too many branches, \
              making it hard to follow.'),
    'R0913': ('Too many arguments (%s/%s)',
              'Used when a function or method takes too many arguments.'),
    'R0914': ('Too many local variables (%s/%s)',
              'Used when a function or method has too many local variables.'),
    'R0915': ('Too many statements (%s/%s)',
              'Used when a function or method has too many statements. You \
              should then split it in smaller functions / methods.'),

    'R0921': ('Abstract class not referenced',
              'Used when an abstract class is not used as ancestor anywhere.'),
    'R0922': ('Abstract class is only referenced %s times',
              'Used when an abstract class is used less than X times as \
              ancestor.'),
    'R0923': ('Interface not implemented',
              'Used when an interface class is not implemented anywhere.'),
    }


class MisdesignChecker(BaseChecker):
    """checks for sign of poor/misdesign:                                      
    * number of methods, attributes, local variables...                        
    * size, complexity of functions, methods                                   
    """

    __implements__ = (IASTNGChecker,)

    # configuration section name
    name = 'design'
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = (('max-args',
                {'default' : 5, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of arguments for function / method'}
                ),
               ('max-locals',
                {'default' : 15, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of locals for function / method body'}
                ),
               ('max-returns',
                {'default' : 6, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of return / yield for function / '
                         'method body'}
                ),
               ('max-branchs',
                {'default' : 12, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of branch for function / method body'}
                ),
               ('max-statements',
                {'default' : 50, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of statements in function / method '
                         'body'}
                ),
               ('max-parents',
                {'default' : 7,
                 'type' : 'int',
                 'metavar' : '&lt;num&gt;',
                 'help' : 'Maximum number of parents for a class (see R0901).'}
                ),
               ('max-attributes',
                {'default' : 7,
                 'type' : 'int',
                 'metavar' : '&lt;num&gt;',
                 'help' : 'Maximum number of attributes for a class \
(see R0902).'}
                ),
               ('min-public-methods',
                {'default' : 2,
                 'type' : 'int',
                 'metavar' : '&lt;num&gt;',
                 'help' : 'Minimum number of public methods for a class \
(see R0903).'}
                ),
               ('max-public-methods',
                {'default' : 20,
                 'type' : 'int',
                 'metavar' : '&lt;num&gt;',
                 'help' : 'Maximum number of public methods for a class \
(see R0904).'}
                ),
               )

    @others
    # FIXME: make a nice report...

</t>
<t tx="ekr.20100215090114.8309">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self.stats = None
    self._returns = None
    self._branchs = None
    self._used_abstracts = None
    self._used_ifaces = None
    self._abstracts = None
    self._ifaces = None
    self._stmts = 0

</t>
<t tx="ekr.20100215090114.8310">def open(self):
    """initialize visit variables"""
    self.stats = self.linter.add_stats()
    self._returns = []
    self._branchs = []
    self._used_abstracts = {}
    self._used_ifaces = {}
    self._abstracts = []
    self._ifaces = []

</t>
<t tx="ekr.20100215090114.8311">def close(self):
    """check that abstract/interface classes are used"""
    for abstract in self._abstracts:
        if not abstract in self._used_abstracts:
            self.add_message('R0921', node=abstract)
        elif self._used_abstracts[abstract] &lt; 2:
            self.add_message('R0922', node=abstract,
                             args=self._used_abstracts[abstract])
    for iface in self._ifaces:
        if not iface in self._used_ifaces:
            self.add_message('R0923', node=iface)

</t>
<t tx="ekr.20100215090114.8312">def visit_class(self, node):
    """check size of inheritance hierarchy and number of instance attributes
    """
    self._inc_branch()
    # Is the total inheritance hierarchy is 7 or less?
    nb_parents = len(list(node.ancestors()))
    if nb_parents &gt; self.config.max_parents:
        self.add_message('R0901', node=node,
                         args=(nb_parents, self.config.max_parents))
    # Does the class contain less than 20 attributes for
    # non-GUI classes (40 for GUI)?
    # FIXME detect gui classes
    if len(node.instance_attrs) &gt; self.config.max_attributes:
        self.add_message('R0902', node=node,
                         args=(len(node.instance_attrs),
                               self.config.max_attributes))
    # update abstract / interface classes structures
    if class_is_abstract(node):
        self._abstracts.append(node)
    elif node.type == 'interface' and node.name != 'Interface':
        self._ifaces.append(node)
        for parent in node.ancestors(False):
            if parent.name == 'Interface':
                continue
            self._used_ifaces[parent] = 1
    try:
        for iface in node.interfaces():
            self._used_ifaces[iface] = 1
    except InferenceError:
        # XXX log ? 
        pass
    for parent in node.ancestors():
        try:
            self._used_abstracts[parent] += 1
        except KeyError:
            self._used_abstracts[parent] = 1

</t>
<t tx="ekr.20100215090114.8313">def leave_class(self, node):
    """check number of public methods"""
    nb_public_methods = 0
    for method in node.methods():
        if not method.name.startswith('_'):
            nb_public_methods += 1
    # Does the class contain less than 20 public methods ?
    if nb_public_methods &gt; self.config.max_public_methods:
        self.add_message('R0904', node=node,
                         args=(nb_public_methods,
                               self.config.max_public_methods))
    # stop here for exception, metaclass and interface classes
    if node.type != 'class':
        return
    # Does the class contain more than 5 public methods ?
    if nb_public_methods &lt; self.config.min_public_methods:
        self.add_message('R0903', node=node,
                         args=(nb_public_methods,
                               self.config.min_public_methods))


</t>
<t tx="ekr.20100215090114.8314">def visit_function(self, node):
    """check function name, docstring, arguments, redefinition,
    variable names, max locals
    """
    self._inc_branch()
    # init branch and returns counters
    self._returns.append(0)
    self._branchs.append(0)
    # check number of arguments
    args = node.args.args
    if args is not None and len(args) &gt; self.config.max_args:
        self.add_message('R0913', node=node,
                         args=(len(args), self.config.max_args))
    # check number of local variables
    locnum = len(node.locals)
    if locnum &gt; self.config.max_locals:
        self.add_message('R0914', node=node,
                         args=(locnum, self.config.max_locals))
    # init statements counter
    self._stmts = 1

</t>
<t tx="ekr.20100215090114.8315">def leave_function(self, node):
    """most of the work is done here on close:
    checks for max returns, branch, return in __init__
    """
    returns = self._returns.pop()
    if returns &gt; self.config.max_returns:
        self.add_message('R0911', node=node,
                         args=(returns, self.config.max_returns))
    branchs = self._branchs.pop()
    if branchs &gt; self.config.max_branchs:
        self.add_message('R0912', node=node,
                         args=(branchs, self.config.max_branchs))
    # check number of statements
    if self._stmts &gt; self.config.max_statements:
        self.add_message('R0915', node=node,
                         args=(self._stmts, self.config.max_statements))

</t>
<t tx="ekr.20100215090114.8316">def visit_return(self, _):
    """count number of returns/yields"""
    if not self._returns:
        return # return outside function, reported by the base checker
    self._returns[-1] += 1

</t>
<t tx="ekr.20100215090114.8317">def visit_yield(self, _):
    """count number of returns/yields"""
    if not self._returns:
        return # yield outside function, reported by the base checker
    self._returns[-1] += 1

</t>
<t tx="ekr.20100215090114.8318">def visit_default(self, node):
    """default visit method -&gt; increments the statements counter if
    necessary
    """
    if node.is_statement:
        self._stmts += 1

</t>
<t tx="ekr.20100215090114.8319">def visit_tryexcept(self, node):
    """increments the branchs counter"""
    branchs = len(node.handlers)
    if node.orelse:
        branchs += 1
    self._inc_branch(branchs)
    self._stmts += branchs

</t>
<t tx="ekr.20100215090114.8320">def visit_tryfinally(self, _):
    """increments the branchs counter"""
    self._inc_branch(2)
    self._stmts += 2

</t>
<t tx="ekr.20100215090114.8321">def visit_if(self, node):
    """increments the branchs counter"""
    branchs = 1
    # don't double count If nodes coming from some 'elif'
    if node.orelse and (len(node.orelse)&gt;1 or
                        not isinstance(node.orelse[0], If)):
        branchs += 1
    self._inc_branch(branchs)
    self._stmts += branchs

</t>
<t tx="ekr.20100215090114.8322">def visit_while(self, node):
    """increments the branchs counter"""
    branchs = 1
    if node.orelse:
        branchs += 1
    self._inc_branch(branchs)

</t>
<t tx="ekr.20100215090114.8323">visit_for = visit_while

def _inc_branch(self, branchsnum=1):
    """increments the branchs counter"""
    branchs = self._branchs
    for i in xrange(len(branchs)):
        branchs[i] += branchsnum

</t>
<t tx="ekr.20100215090114.8324">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(MisdesignChecker(linter))
</t>
<t tx="ekr.20100215090114.8325">@language python
@tabwidth -4

"""exceptions handling (raising, catching, exceptions classes) checker
"""

@others
</t>
<t tx="ekr.20100215090114.8326">import sys

from logilab.common.compat import enumerate
from logilab import astng
from logilab.astng.infutils import YES, Instance, unpack_infer

from pylint.checkers import BaseChecker
from pylint.checkers.utils import is_empty, is_raising
from pylint.interfaces import IASTNGChecker

MSGS = {
    'E0701': (
    'Bad except clauses order (%s)',
    'Used when except clauses are not in the correct order (from the \
    more specific to the more generic). If you don\'t fix the order, \
    some exceptions may not be catched by the most specific handler.'),
    'E0702': ('Raising %s while only classes, instances or string are allowed',
              'Used when something which is neither a class, an instance or a \
              string is raised (i.e. a `TypeError` will be raised).'),

    'W0701': ('Raising a string exception',
              'Used when a string exception is raised.'),
    'W0702': ('No exception type(s) specified',
              'Used when an except clause doesn\'t specify exceptions type to \
              catch.'),
    'W0703': ('Catch "Exception"',
              'Used when an except catches Exception instances.'),
    'W0704': ('Except doesn\'t do anything',
              'Used when an except clause does nothing but "pass" and there is\
              no "else" clause.'),
    'W0710': ('Exception doesn\'t inherit from standard "Exception" class',
              'Used when a custom exception class is raised but doesn\'t \
              inherit from the builtin "Exception" class.'),
    }
if sys.version_info &lt; (2, 5):
    MSGS['E0710'] = ('Raising a new style class',
                     'Used when a new style class is raised since it\'s not \
                      possible with python &lt; 2.5.')
else:
    MSGS['E0710'] = ('Raising a new style class which doesn\'t inherit from \
BaseException',
                     'Used when a new style class which doesn\'t inherit from \
                      BaseException raised since it\'s not possible with \
                      python &lt; 2.5.')


</t>
<t tx="ekr.20100215090114.8327">class ExceptionsChecker(BaseChecker):
    """checks for                                                              
    * excepts without exception filter                                         
    * type of raise argument : string, Exceptions, other values
    """

    __implements__ = IASTNGChecker

    name = 'exceptions'
    msgs = MSGS
    priority = -4
    options = ()

    @others
</t>
<t tx="ekr.20100215090114.8328">def visit_raise(self, node):
    """visit raise possibly inferring value"""
    # ignore empty raise
    if node.type is None:
        return
    expr = node.type
    if self._check_raise_value(node, expr):
        return
    else:
        try:
            value = unpack_infer(expr).next()
        except astng.InferenceError:
            return
        self._check_raise_value(node, value)
</t>
<t tx="ekr.20100215090114.8329">def _check_raise_value(self,node,expr):
    """check for bad values, string exception and class inheritance
    """
    value_found = True
    if isinstance(expr,astng.Const):
        value = expr.value
        if isinstance(value, str):
            self.add_message('W0701', node=node)
        else:
            self.add_message('E0702', node=node,
                             args=value.__class__.__name__)
    elif (
        isinstance(expr,astng.Name) and 
        expr.name in ('None', 'True', 'False') or
        isinstance(expr,(
            astng.List, astng.Dict, astng.Tuple, 
            astng.Module, astng.Function))
    ):
        self.add_message('E0702', node=node, args=expr.name)
    elif isinstance(expr, astng.BinOp) and expr.op == '%':
        self.add_message('W0701', node=node)
    elif isinstance(expr, (Instance, astng.Class)):
        if isinstance(expr, Instance):
            expr = expr._proxied
        if (isinstance(expr, astng.Class) and
            not inherit_from_std_ex(expr) and
            expr.root().name != '__builtin__'
        ):
            if expr.newstyle:
                self.add_message('E0710', node=node)
            else:
                self.add_message('W0710', node=node)
        else:
            value_found = False
    else:
        value_found = False
    return value_found
</t>
<t tx="ekr.20100215090114.8330">def visit_tryexcept(self, node):
    """check for empty except"""
    exceptions_classes = []
    nb_handlers = len(node.handlers)
    for index, handler  in enumerate(node.handlers):
        # single except doing nothing but "pass" without else clause
        if nb_handlers == 1 and is_empty(handler.body) and not node.orelse:
            self.add_message('W0704', node=handler.type or handler.body[0])
        if handler.type is None:
            if nb_handlers == 1 and not is_raising(handler.body):
                self.add_message('W0702', node=handler.body[0])
            # check if a "except:" is followed by some other
            # except
            elif index &lt; (nb_handlers - 1):
                msg = 'empty except clause should always appears last'
                self.add_message('E0701', node=node, args=msg)
        else:
            try:
                excs = list(unpack_infer(handler.type))
            except astng.InferenceError:
                continue
            for exc in excs:
                # XXX skip other non class nodes 
                if exc is YES or not isinstance(exc, astng.Class):
                    continue
                exc_ancestors = [anc for anc in exc.ancestors()
                                 if isinstance(anc, astng.Class)]
                for previous_exc in exceptions_classes:
                    if previous_exc in exc_ancestors:
                        msg = '%s is an ancestor class of %s' % (
                            previous_exc.name, exc.name)
                        self.add_message('E0701', node=handler.type, args=msg)
                if (exc.name == 'Exception'
                    and exc.root().name == 'exceptions'
                    and nb_handlers == 1 and not is_raising(handler.body)):
                    self.add_message('W0703', node=handler.type)
            exceptions_classes += excs
</t>
<t tx="ekr.20100215090114.8331">def inherit_from_std_ex(node):
    """return true if the given class node is subclass of
    exceptions.Exception
    """
    if node.name in ('Exception', 'BaseException') \
            and node.root().name == 'exceptions':
        return True
    for parent in node.ancestors(recurs=False):
        if inherit_from_std_ex(parent):
            return True
    return False

</t>
<t tx="ekr.20100215090114.8332">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(ExceptionsChecker(linter))
</t>
<t tx="ekr.20100215090114.8333">@language python
@tabwidth -4

"""Python code format's checker.

By default try to follow Guido's style guide :

http://www.python.org/doc/essays/styleguide.html

Some parts of the process_token method is based from The Tab Nanny std module.
"""

@others
</t>
<t tx="ekr.20100215090114.8334">import re
import tokenize
if not hasattr(tokenize, 'NL'):
    raise ValueError("tokenize.NL doesn't exist -- tokenize module too old")

from logilab.common.textutils import pretty_match
from logilab.astng import nodes

from pylint.interfaces import IRawChecker, IASTNGChecker
from pylint.checkers import BaseRawChecker

MSGS = {
    'C0301': ('Line too long (%s/%s)',
              'Used when a line is longer than a given number of characters.'),
    'C0302': ('Too many lines in module (%s)', # was W0302
              'Used when a module has too much lines, reducing its readability.'
              ),

    'W0311': ('Bad indentation. Found %s %s, expected %s',
              'Used when an unexpected number of indentation\'s tabulations or '
              'spaces has been found.'),
    'W0312': ('Found indentation with %ss instead of %ss',
              'Used when there are some mixed tabs and spaces in a module.'),
    'W0301': ('Unnecessary semicolon', # was W0106
              'Used when a statement is ended by a semi-colon (";"), which \
              isn\'t necessary (that\'s python, not C ;).'),

    'F0321': ('Format detection error in %r',
              'Used when an unexpected error occurred in bad format detection.'
              'Please report the error if it occurs.'),
    'C0321': ('More than one statement on a single line',
              'Used when more than on statement are found on the same line.'),
    'C0322': ('Operator not preceded by a space\n%s',
              'Used when one of the following operator (!= | &lt;= | == | &gt;= | &lt; '
              '| &gt; | = | \+= | -= | \*= | /= | %) is not preceded by a space.'),
    'C0323': ('Operator not followed by a space\n%s',
              'Used when one of the following operator (!= | &lt;= | == | &gt;= | &lt; '
              '| &gt; | = | \+= | -= | \*= | /= | %) is not followed by a space.'),
    'C0324': ('Comma not followed by a space\n%s',
              'Used when a comma (",") is not followed by a space.'),

    'W0331': ('Use of the &lt;&gt; operator',
              'Used when the deprecated "&lt;&gt;" operator is used instead \
              of "!=".'),
    'W0332': ('Use l as long integer identifier',
              'Used when a lower case "l" is used to mark a long integer. You '
              'should use a upper case "L" since the letter "l" looks too much '
              'like the digit "1"'),
    'W0333': ('Use of the `` operator',
              'Used when the deprecated "``" (backtick) operator is used '
              'instead  of the str() function.'),
    }

# simple quoted string rgx
SQSTRING_RGX = r'"([^"\\]|\\.)*?"'
# simple apostrophed rgx
SASTRING_RGX = r"'([^'\\]|\\.)*?'"
# triple quoted string rgx
TQSTRING_RGX = r'"""([^"]|("(?!"")))*?(""")'
# triple apostrophed string rgx # FIXME english please
TASTRING_RGX = r"'''([^']|('(?!'')))*?(''')"

# finally, the string regular expression
STRING_RGX = re.compile('(%s)|(%s)|(%s)|(%s)' % (TQSTRING_RGX, TASTRING_RGX,
                                                 SQSTRING_RGX, SASTRING_RGX),
                        re.MULTILINE|re.DOTALL)

COMMENT_RGX = re.compile("#.*$", re.M)

OPERATORS = r'!=|&lt;=|==|&gt;=|&lt;|&gt;|=|\+=|-=|\*=|/=|%'

OP_RGX_MATCH_1 = r'[^(]*(?&lt;!\s|\^|&lt;|&gt;|=|\+|-|\*|/|!|%%|&amp;|\|)(%s).*' % OPERATORS
OP_RGX_SEARCH_1 = r'(?&lt;!\s|\^|&lt;|&gt;|=|\+|-|\*|/|!|%%|&amp;|\|)(%s)' % OPERATORS

OP_RGX_MATCH_2 = r'[^(]*(%s)(?!\s|=|&gt;|&lt;).*' % OPERATORS
OP_RGX_SEARCH_2 = r'(%s)(?!\s|=|&gt;)' % OPERATORS

BAD_CONSTRUCT_RGXS = (

    (re.compile(OP_RGX_MATCH_1, re.M),
     re.compile(OP_RGX_SEARCH_1, re.M),
     'C0322'),

    (re.compile(OP_RGX_MATCH_2, re.M),
     re.compile(OP_RGX_SEARCH_2, re.M),
     'C0323'),

    (re.compile(r'.*,[^\s)].*', re.M),
     re.compile(r',[^\s)]', re.M),
     'C0324'),
    )


</t>
<t tx="ekr.20100215090114.8335">def get_string_coords(line):
    """return a list of string positions (tuple (start, end)) in the line
    """
    result = []
    for match in re.finditer(STRING_RGX, line):
        result.append( (match.start(), match.end()) )
    return result

</t>
<t tx="ekr.20100215090114.8336">def in_coords(match, string_coords):
    """return true if the match is in the string coord"""
    mstart = match.start()
    for start, end in string_coords:
        if mstart &gt;= start and mstart &lt; end:
            return True
    return False

</t>
<t tx="ekr.20100215090114.8337">def check_line(line, writer):
    """check a line for a bad construction
    if it founds one, return a message describing the problem
    else return None
    """
    cleanstr = COMMENT_RGX.sub('', STRING_RGX.sub('', line))
    for rgx_match, rgx_search, msg_id in BAD_CONSTRUCT_RGXS:
        if rgx_match.match(cleanstr):
            string_positions = get_string_coords(line)
            for match in re.finditer(rgx_search, line):
                if not in_coords(match, string_positions):
                    return msg_id, pretty_match(match, line.rstrip())
            #writer.add_message('F0321', line=line, args=line)
</t>
<t tx="ekr.20100215090114.8338">class FormatChecker(BaseRawChecker):
    """checks for :
    * unauthorized constructions
    * strict indentation
    * line length
    * use of &lt;&gt; instead of !=
    """

    __implements__ = (IRawChecker, IASTNGChecker)

    # configuration section name
    name = 'format'
    # messages
    msgs = MSGS
    # configuration options
    # for available dict keys/values see the optik parser 'add_option' method
    options = (('max-line-length',
                {'default' : 80, 'type' : "int", 'metavar' : '&lt;int&gt;',
                 'help' : 'Maximum number of characters on a single line.'}),
               ('max-module-lines',
                {'default' : 1000, 'type' : 'int', 'metavar' : '&lt;int&gt;',
                 'help': 'Maximum number of lines in a module'}
                ),
               ('indent-string',
                {'default' : '    ', 'type' : "string", 'metavar' : '&lt;string&gt;',
                 'help' : 'String used as indentation unit. This is usually \
"    " (4 spaces) or "\\t" (1 tab).'}),
               )
    @others
</t>
<t tx="ekr.20100215090114.8339">def __init__(self, linter=None):
    BaseRawChecker.__init__(self, linter)
    self._lines = None
    self._visited_lines = None

</t>
<t tx="ekr.20100215090114.8340">def new_line(self, tok_type, line, line_num, junk):
    """a new line has been encountered, process it if necessary"""
    if not tok_type in junk:
        self._lines[line_num] = line.split('\n')[0]
    self.check_lines(line, line_num)

</t>
<t tx="ekr.20100215090114.8341">def process_tokens(self, tokens):
    """process tokens and search for :

     _ non strict indentation (i.e. not always using the &lt;indent&gt; parameter as
       indent unit)
     _ too long lines (i.e. longer than &lt;max_chars&gt;)
     _ optionally bad construct (if given, bad_construct must be a compiled
       regular expression).
    """
    indent = tokenize.INDENT
    dedent = tokenize.DEDENT
    newline = tokenize.NEWLINE
    junk = (tokenize.COMMENT, tokenize.NL)
    indents = [0]
    check_equal = 0
    line_num = 0
    previous = None
    self._lines = {}
    self._visited_lines = {}
    for (tok_type, token, start, _, line) in tokens:
        if start[0] != line_num:
            if previous is not None and previous[0] == tokenize.OP and previous[1] == ';':
                self.add_message('W0301', line=previous[2])
            previous = None
            line_num = start[0]
            self.new_line(tok_type, line, line_num, junk)
        if tok_type not in (indent, dedent, newline) + junk:
            previous = tok_type, token, start[0]

        if tok_type == tokenize.OP:
            if token == '&lt;&gt;':
                self.add_message('W0331', line=line_num)
        elif tok_type == tokenize.NUMBER:
            if token.endswith('l'):
                self.add_message('W0332', line=line_num)

        elif tok_type == newline:
            # a program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            # If an INDENT appears, setting check_equal is wrong, and will
            # be undone when we see the INDENT.
            check_equal = 1

        elif tok_type == indent:
            check_equal = 0
            self.check_indent_level(token, indents[-1]+1, line_num)
            indents.append(indents[-1]+1)

        elif tok_type == dedent:
            # there's nothing we need to check here!  what's important is
            # that when the run of DEDENTs ends, the indentation of the
            # program statement (or ENDMARKER) that triggered the run is
            # equal to what's left at the top of the indents stack
            check_equal = 1
            if len(indents) &gt; 1:
                del indents[-1]

        elif check_equal and tok_type not in junk:
            # this is the first "real token" following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER; the "line" argument exposes the leading whitespace
            # for this statement; in the case of ENDMARKER, line is an empty
            # string, so will properly match the empty string with which the
            # "indents" stack was seeded
            check_equal = 0
            self.check_indent_level(line, indents[-1], line_num)

    line_num -= 1 # to be ok with "wc -l"
    if line_num &gt; self.config.max_module_lines:
        self.add_message('C0302', args=line_num, line=1)
</t>
<t tx="ekr.20100215090114.8342">def visit_default(self, node):
    """check the node line number and check it if not yet done"""
    if not node.is_statement:
        return
    if not node.root().pure_python:
        return # XXX block visit of child nodes
    prev_sibl = node.previous_sibling()
    if prev_sibl is not None:
        prev_line = prev_sibl.fromlineno
    else:
        prev_line = node.parent.statement().fromlineno
    line = node.fromlineno
    assert line, node
    if prev_line == line and self._visited_lines.get(line) != 2:
        # py2.5 try: except: finally:
        if not (isinstance(node, nodes.TryExcept)
                and isinstance(node.parent, nodes.TryFinally)
                and node.fromlineno == node.parent.fromlineno):
            self.add_message('C0321', node=node)
            self._visited_lines[line] = 2
        return
    if self._visited_lines.has_key(line):
        return
    try:
        tolineno = node.blockstart_tolineno
    except AttributeError:
        tolineno = node.tolineno
    assert tolineno, node
    lines = []
    for line in xrange(line, tolineno + 1):
        self._visited_lines[line] = 1
        try:
            lines.append(self._lines[line].rstrip())
        except KeyError:
            lines.append('')
    try:
        msg_def = check_line('\n'.join(lines), self)
        if msg_def:
            self.add_message(msg_def[0], node=node, args=msg_def[1])
    except KeyError:
        # FIXME: internal error !
        pass

</t>
<t tx="ekr.20100215090114.8343">def visit_backquote(self, node):
    self.add_message('W0333', node=node)

</t>
<t tx="ekr.20100215090114.8344">def check_lines(self, lines, i):
    """check lines have less than a maximum number of characters
    """
    max_chars = self.config.max_line_length
    for line in lines.splitlines():
        if len(line) &gt; max_chars:
            self.add_message('C0301', line=i, args=(len(line), max_chars))
        i += 1

</t>
<t tx="ekr.20100215090114.8345">def check_indent_level(self, string, expected, line_num):
    """return the indent level of the string
    """
    indent = self.config.indent_string
    if indent == '\\t': # \t is not interpreted in the configuration file
        indent = '\t'
    level = 0
    unit_size = len(indent)
    while string[:unit_size] == indent:
        string = string[unit_size:]
        level += 1
    suppl = ''
    while string and string[0] in ' \t':
        if string[0] != indent[0]:
            if string[0] == '\t':
                args = ('tab', 'space')
            else:
                args = ('space', 'tab')
            self.add_message('W0312', args=args, line=line_num)
            return level
        suppl += string[0]
        string = string [1:]
    if level != expected or suppl:
        i_type = 'spaces'
        if indent[0] == '\t':
            i_type = 'tabs'
        self.add_message('W0311', line=line_num,
                         args=(level * unit_size + len(suppl), i_type,
                               expected * unit_size))


</t>
<t tx="ekr.20100215090114.8346">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(FormatChecker(linter))
</t>
<t tx="ekr.20100215090114.8347">@language python
@tabwidth -4

"""imports checkers for Python code"""

@others
</t>
<t tx="ekr.20100215090114.8348">from logilab.common.graph import get_cycles, DotBackend
from logilab.common.modutils import is_standard_module
from logilab.common.ureports import VerbatimText, Paragraph
from logilab.common.compat import sorted, enumerate

from logilab import astng
from logilab.astng.infutils import are_exclusive

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker, EmptyReport
</t>
<t tx="ekr.20100215090114.8349">def get_first_import(context, name, base, level=0):
    """return the node where [base.]&lt;name&gt; is imported or None if not found
    """
    for node in context.values():
        if isinstance(node, astng.Import):
            if name in [iname[0] for iname in node.names]:
                return node
        if isinstance(node, astng.From):
            if base == node.modname and level == node.level and \
                   name in [iname[0] for iname in node.names]:
                return node


</t>
<t tx="ekr.20100215090114.8350"># utilities to represents import dependencies as tree and dot graph ###########

def filter_dependencies_info(dep_info, package_dir, mode='external'):
    """filter external or internal dependencies from dep_info (return a
    new dictionary containing the filtered modules only)
    """
    if mode == 'external':
        filter_func = lambda x: not is_standard_module(x, (package_dir,))
    else:
        assert mode == 'internal'
        filter_func = lambda x: is_standard_module(x, (package_dir,))
    result = {}
    for importee, importers in dep_info.items():
        if filter_func(importee):
            result[importee] = importers
    return result

</t>
<t tx="ekr.20100215090114.8351">def make_tree_defs(mod_files_list):
    """get a list of 2-uple (module, list_of_files_which_import_this_module),
    it will return a dictionary to represent this as a tree
    """
    tree_defs = {}
    for mod, files in mod_files_list:
        node = (tree_defs, ())
        for prefix in mod.split('.'):
            node = node[0].setdefault(prefix, [{}, []])
        node[1] += files
    return tree_defs

</t>
<t tx="ekr.20100215090114.8352">def repr_tree_defs(data, indent_str=None):
    """return a string which represents imports as a tree"""
    lines = []
    nodes = data.items()
    for i, (mod, (sub, files)) in enumerate(sorted(nodes, key=lambda x: x[0])):
        if not files:
            files = ''
        else:
            files = '(%s)' % ','.join(files)
        if indent_str is None:
            lines.append('%s %s' % (mod, files))
            sub_indent_str = '  '
        else:
            lines.append('%s\-%s %s' % (indent_str, mod, files))
            if i == len(nodes)-1:
                sub_indent_str = '%s  ' % indent_str
            else:
                sub_indent_str = '%s| ' % indent_str
        if sub:
            lines.append(repr_tree_defs(sub, sub_indent_str))
    return '\n'.join(lines)


</t>
<t tx="ekr.20100215090114.8353">def dependencies_graph(filename, dep_info):
    """write dependencies as a dot (graphviz) file
    """
    done = {}
    printer = DotBackend(filename[:-4], rankdir = "LR")
    printer.emit('URL="." node[shape="box"]')
    for modname, dependencies in dep_info.items():
        done[modname] = 1
        printer.emit_node(modname)
        for modname in dependencies:
            if not done.has_key(modname):
                done[modname] = 1
                printer.emit_node(modname)
    for depmodname, dependencies in dep_info.items():
        for modname in dependencies:
            printer.emit_edge(modname, depmodname)
    printer.generate(filename)
</t>
<t tx="ekr.20100215090114.8354">def make_graph(filename, dep_info, sect, gtype):
    """generate a dependencies graph and add some information about it in the
    report's section
    """
    dependencies_graph(filename, dep_info)
    sect.append(Paragraph('%simports graph has been written to %s'
                          % (gtype, filename)))


</t>
<t tx="ekr.20100215090114.8355"># the import checker itself ###################################################

MSGS = {
    'F0401': ('Unable to import %r' ,
              'Used when pylint has been unable to import a module.'),
    'R0401': ('Cyclic import (%s)',
              'Used when a cyclic import between two or more modules is \
              detected.'),

    'W0401': ('Wildcard import %s',
              'Used when `from module import *` is detected.'),
    'W0402': ('Uses of a deprecated module %r',
              'Used a module marked as deprecated is imported.'),
    'W0403': ('Relative import %r, should be %r',
              'Used when an import relative to the package directory is \
              detected.'),
    'W0404': ('Reimport %r (imported line %s)',
              'Used when a module is reimported multiple times.'),
    'W0406': ('Module import itself',
              'Used when a module is importing itself.'),

    'W0410': ('__future__ import is not the first non docstring statement',
              'Python 2.5 and greater require __future__ import to be the \
              first non docstring statement in the module.'),
    }

class ImportsChecker(BaseChecker):
    """checks for
    * external modules dependencies
    * relative / wildcard imports
    * cyclic imports
    * uses of deprecated modules
    """

    __implements__ = IASTNGChecker

    name = 'imports'
    msgs = MSGS
    priority = -2

    options = (('deprecated-modules',
                {'default' : ('regsub','string', 'TERMIOS',
                              'Bastion', 'rexec'),
                 'type' : 'csv',
                 'metavar' : '&lt;modules&gt;',
                 'help' : 'Deprecated modules which should not be used, \
separated by a comma'}
                ),
               ('import-graph',
                {'default' : '',
                 'type' : 'string',
                 'metavar' : '&lt;file.dot&gt;',
                 'help' : 'Create a graph of every (i.e. internal and \
external) dependencies in the given file (report R0402 must not be disabled)'}
                ),
               ('ext-import-graph',
                {'default' : '',
                 'type' : 'string',
                 'metavar' : '&lt;file.dot&gt;',
                 'help' : 'Create a graph of external dependencies in the \
given file (report R0402 must not be disabled)'}
                ),
               ('int-import-graph',
                {'default' : '',
                 'type' : 'string',
                 'metavar' : '&lt;file.dot&gt;',
                 'help' : 'Create a graph of internal dependencies in the \
given file (report R0402 must not be disabled)'}
                ),

               )

    @others
</t>
<t tx="ekr.20100215090114.8356">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self.stats = None
    self.import_graph = None
    self.__int_dep_info = self.__ext_dep_info = None
    self.reports = (('R0401', 'External dependencies',
                     self.report_external_dependencies),
                    ('R0402', 'Modules dependencies graph',
                     self.report_dependencies_graph),
                    )

</t>
<t tx="ekr.20100215090114.8357">def open(self):
    """called before visiting project (i.e set of modules)"""
    self.linter.add_stats(dependencies={})
    self.linter.add_stats(cycles=[])
    self.stats = self.linter.stats
    self.import_graph = {}

</t>
<t tx="ekr.20100215090114.8358">def close(self):
    """called before visiting project (i.e set of modules)"""
    # don't try to compute cycles if the associated message is disabled
    if self.linter.is_message_enabled('R0401'):
        for cycle in get_cycles(self.import_graph):
            self.add_message('R0401', args=' -&gt; '.join(cycle))

</t>
<t tx="ekr.20100215090114.8359">def visit_import(self, node):
    """triggered when an import statement is seen"""
    modnode = node.root()
    for name, _ in node.names:
        importedmodnode = self.get_imported_module(modnode, node, name)
        if importedmodnode is None:
            continue
        self._check_relative_import(modnode, node, importedmodnode, name)
        self._add_imported_module(node, importedmodnode.name)
        self._check_deprecated_module(node, name)
        self._check_reimport(node, name)


</t>
<t tx="ekr.20100215090114.8360">def visit_from(self, node):
    """triggered when a from statement is seen"""
    basename = node.modname
    if basename == '__future__':
        # check if this is the first non-docstring statement in the module
        prev = node.previous_sibling()
        if prev:
            # consecutive future statements are possible
            if not (isinstance(prev, astng.From)
                   and prev.modname == '__future__'):
                self.add_message('W0410', node=node)
        return
    modnode = node.root()
    importedmodnode = self.get_imported_module(modnode, node, basename)
    if importedmodnode is None:
        return
    self._check_relative_import(modnode, node, importedmodnode, basename)
    self._check_deprecated_module(node, basename)
    for name, _ in node.names:
        if name == '*':
            self.add_message('W0401', args=basename, node=node)
            continue
        self._add_imported_module(node, '%s.%s' % (importedmodnode.name, name))
        self._check_reimport(node, name, basename, node.level)
</t>
<t tx="ekr.20100215090114.8361">def get_imported_module(self, modnode, importnode, modname):
    try:
        return importnode.do_import_module(modname)
    except astng.InferenceError, ex:
        if str(ex).startswith('module importing itself'): # XXX
            return modnode
        else:
            self.add_message("F0401", args=modname, node=importnode)
            return

</t>
<t tx="ekr.20100215090114.8362">def _check_relative_import(self, modnode, importnode, importedmodnode,
                           importedasname):
    """check relative import. node is either an Import or From node, modname
    the imported module name.
    """
    if importedmodnode.file is None:
        return False # built-in module
    if modnode is importedmodnode:
        return False # module importing itself
    if modnode.absolute_import_activated() or getattr(importnode, 'level', None):
        return False
    if importedmodnode.name != importedasname:
        # this must be a relative import...
        self.add_message('W0403', args=(importedasname, importedmodnode.name),
                         node=importnode)

</t>
<t tx="ekr.20100215090114.8363">def _add_imported_module(self, node, importedmodname):
    """notify an imported module, used to analyze dependencies"""
    context_name = node.root().name
    if context_name == importedmodname:
        # module importing itself !
        self.add_message('W0406', node=node)
    elif not is_standard_module(importedmodname):
        # handle dependencies
        importedmodnames = self.stats['dependencies'].setdefault(
            importedmodname, set())
        if not context_name in importedmodnames:
            importedmodnames.add(context_name)
        if is_standard_module( importedmodname, (self.package_dir(),) ):
            # update import graph
            mgraph = self.import_graph.setdefault(context_name, set())
            if not importedmodname in mgraph:
                mgraph.add(importedmodname)

</t>
<t tx="ekr.20100215090114.8364">def _check_deprecated_module(self, node, mod_path):
    """check if the module is deprecated"""
    # XXX rewrite
    for mod_name in self.config.deprecated_modules:
        if mod_path.startswith(mod_name) and \
               (len(mod_path) == len(mod_name)
                or mod_path[len(mod_name)] == '.'):
            self.add_message('W0402', node=node, args=mod_path)

</t>
<t tx="ekr.20100215090114.8365">def _check_reimport(self, node, name, basename=None, level=0):
    """check if the import is necessary (i.e. not already done)"""
    # XXX rewrite
    frame = node.frame()
    first = get_first_import(frame, name, basename, level)
    if isinstance(first, (astng.Import, astng.From)) and first is not node \
           and not are_exclusive(first, node):
        self.add_message('W0404', node=node, args=(name, first.fromlineno))
    else:
        root = node.root()
        if root is frame:
            return
        first = get_first_import(root, name, basename)
        if not isinstance(first, (astng.Import, astng.From)):
            return
        if first is not node and not are_exclusive(first, node):
            self.add_message('W0404', node=node,
                             args=(name, first.fromlineno))


</t>
<t tx="ekr.20100215090114.8366">def report_external_dependencies(self, sect, _, dummy):
    """return a verbatim layout for displaying dependencies"""
    dep_info = make_tree_defs(self._external_dependencies_info().items())
    if not dep_info:
        raise EmptyReport()
    tree_str = repr_tree_defs(dep_info)
    sect.append(VerbatimText(tree_str))

</t>
<t tx="ekr.20100215090114.8367">def report_dependencies_graph(self, sect, _, dummy):
    """write dependencies as a dot (graphviz) file"""
    dep_info = self.stats['dependencies']
    if not dep_info or not (self.config.import_graph
                            or self.config.ext_import_graph
                            or self.config.int_import_graph):
        raise EmptyReport()
    filename = self.config.import_graph
    if filename:
        make_graph(filename, dep_info, sect, '')
    filename = self.config.ext_import_graph
    if filename:
        make_graph(filename, self._external_dependencies_info(),
                   sect, 'external ')
    filename = self.config.int_import_graph
    if filename:
        make_graph(filename, self._internal_dependencies_info(),
                   sect, 'internal ')
</t>
<t tx="ekr.20100215090114.8368">def _external_dependencies_info(self):
    """return cached external dependencies information or build and
    cache them
    """
    if self.__ext_dep_info is None:
        self.__ext_dep_info = filter_dependencies_info(
            self.stats['dependencies'], self.package_dir(), 'external')
    return self.__ext_dep_info

</t>
<t tx="ekr.20100215090114.8369">def _internal_dependencies_info(self):
    """return cached internal dependencies information or build and
    cache them
    """
    if self.__int_dep_info is None:
        self.__int_dep_info = filter_dependencies_info(
            self.stats['dependencies'], self.package_dir(), 'internal')
    return self.__int_dep_info


</t>
<t tx="ekr.20100215090114.8370">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(ImportsChecker(linter))
</t>
<t tx="ekr.20100215090114.8371">@language python
@tabwidth -4

"""checker for use of Python logging
"""

@others
</t>
<t tx="ekr.20100215090114.8372">from logilab import astng
from pylint import checkers
from pylint import interfaces

EAGER_STRING_INTERPOLATION = 'W6501'

CHECKED_CONVENIENCE_FUNCTIONS = set([
    'critical', 'debug', 'error', 'exception', 'fatal', 'info', 'warn',
    'warning'])


</t>
<t tx="ekr.20100215090114.8373">class LoggingChecker(checkers.BaseChecker):
    """Checks use of the logging module."""

    __implements__ = interfaces.IASTNGChecker

    name = 'logging'

    msgs = {EAGER_STRING_INTERPOLATION:
            ('Specify string format arguments as logging function parameters',
             'Used when a logging statement has a call form of '
             '"logging.&lt;logging method&gt;(format_string % (format_args...))". '
             'Such calls should leave string interpolation to the logging '
             'method itself and be written '
             '"logging.&lt;logging method&gt;(format_string, format_args...)" '
             'so that the program may avoid incurring the cost of the '
             'interpolation in those cases in which no message will be '
             'logged. For more, see '
             'http://www.python.org/dev/peps/pep-0282/.')
            }

    @others
</t>
<t tx="ekr.20100215090114.8374">def visit_module(self, unused_node):
    """Clears any state left in this checker from last module checked."""
    # The code being checked can just as easily "import logging as foo",
    # so it is necessary to process the imports and store in this field
    # what name the logging module is actually given.
    self._logging_name = None

</t>
<t tx="ekr.20100215090114.8375">def visit_import(self, node):
    """Checks to see if this module uses Python's built-in logging."""
    for module, as_name in node.names:
        if module == 'logging':
            if as_name:
                self._logging_name = as_name
            else:
                self._logging_name = 'logging'

</t>
<t tx="ekr.20100215090114.8376">def visit_callfunc(self, node):
    """Checks calls to (simple forms of) logging methods."""
    if (not isinstance(node.func, astng.Getattr)
        or not isinstance(node.func.expr, astng.Name)
        or node.func.expr.name != self._logging_name
    ):
        return
    self._CheckConvenienceMethods(node)
    self._CheckLogMethod(node)

</t>
<t tx="ekr.20100215090114.8377">def _CheckConvenienceMethods(self, node):
    """Checks calls to logging convenience methods (like logging.warn)."""
    if node.func.attrname not in CHECKED_CONVENIENCE_FUNCTIONS:
        return
    if not node.args:
        # Either no args, or star args, or double-star args. Beyond the
        # scope of this checker in any case.
        return
    if isinstance(node.args[0], astng.BinOp) and node.args[0].op == '%':
        self.add_message(EAGER_STRING_INTERPOLATION, node=node)

</t>
<t tx="ekr.20100215090114.8378">def _CheckLogMethod(self, node):
    """Checks calls to logging.log(level, format, *format_args)."""
    if node.func.attrname != 'log':
        return
    if len(node.args) &lt; 2:
        # Either a malformed call or something with crazy star args or
        # double-star args magic. Beyond the scope of this checker.
        return
    if isinstance(node.args[1], astng.BinOp) and node.args[1].op == '%':
        self.add_message(EAGER_STRING_INTERPOLATION, node=node)

</t>
<t tx="ekr.20100215090114.8379">def register(linter):
  """Required method to auto-register this checker."""
  linter.register_checker(LoggingChecker(linter))
</t>
<t tx="ekr.20100215090114.8380">@language python
@tabwidth -4

"""
Check source code is ascii only or has an encoding declaration (PEP 263)
"""

@others
</t>
<t tx="ekr.20100215090114.8381">import re

from pylint.interfaces import IRawChecker
from pylint.checkers import BaseChecker
</t>
<t tx="ekr.20100215090114.8382">def is_ascii(string):
    """return true if non ascii characters are detected in the given string
    and line number where non-ascii has been encountered.
    """
    for i, line in enumerate(string.splitlines()):
        if line and max([ord(char) for char in line]) &gt;= 128:
            return False, i + 1
    return True, 0
</t>
<t tx="ekr.20100215090114.8383"># regexp matching both emacs and vim declaration
ENCODING_RGX = re.compile("[^#]*#*.*coding[:=]\s*([^\s]+)")

def guess_encoding(string):
    """try to guess encoding from a python file as string
    return None if not found
    """
    assert type(string) is type(''), type(string)
    # check for UTF-8 byte-order mark
    if string.startswith('\xef\xbb\xbf'):
        return 'UTF-8'
    first_lines = string.split('\n', 2)[:2]
    for line in first_lines:
        # check for emacs / vim encoding declaration
        match = ENCODING_RGX.match(line)
        if match is not None:
            return match.group(1)
</t>
<t tx="ekr.20100215090114.8384">MSGS = {
    'E0501': ('Non ascii characters found but no encoding specified (PEP 263)',
              'Used when some non ascii characters are detected but now \
              encoding is specified, as explicited in the PEP 263.'),
    'E0502': ('Wrong encoding specified (%s)',
              'Used when a known encoding is specified but the file doesn\'t \
              seem to be actually in this encoding.'),
    'E0503': ('Unknown encoding specified (%s)',
              'Used when an encoding is specified, but it\'s unknown to Python.'
              ),

    'W0511': ('%s',
              'Used when a warning note as FIXME or XXX is detected.'),
    }

class EncodingChecker(BaseChecker):
    """checks for:                                                             
    * warning notes in the code like FIXME, XXX                                
    * PEP 263: source code with non ascii character but no encoding declaration
    """
    __implements__ = IRawChecker

    # configuration section name
    name = 'miscellaneous'
    msgs = MSGS

    options = (('notes',
                {'type' : 'csv', 'metavar' : '&lt;comma separated values&gt;',
                 'default' : ('FIXME', 'XXX', 'TODO'),
                 'help' : 'List of note tags to take in consideration, \
separated by a comma.'
                 }),               
               )

    @others
</t>
<t tx="ekr.20100215090114.8385">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)

</t>
<t tx="ekr.20100215090114.8386">def process_module(self, stream):
    """inspect the source file to found encoding problem or fixmes like
    notes
    """
    # source encoding
    data = stream.read()
    ascii, lineno = is_ascii(data)
    if not ascii:
        encoding = guess_encoding(data)
        if encoding is None:
            self.add_message('E0501', line=lineno)
        else:
            try:
                unicode(data, encoding)
            except UnicodeError:
                self.add_message('E0502', args=encoding, line=1)
            except LookupError:
                self.add_message('E0503', args=encoding, line=1)
    del data
    # warning notes in the code
    stream.seek(0)
    notes = []
    for note in self.config.notes:
        notes.append(re.compile(note))
    linenum = 1
    for line in stream.readlines():
        for note in notes:
            match = note.search(line)
            if match:
                self.add_message('W0511', args=line[match.start():-1],
                                 line=linenum)
                break
        linenum += 1
</t>
<t tx="ekr.20100215090114.8387">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(EncodingChecker(linter))
</t>
<t tx="ekr.20100215090114.8388">@language python
@tabwidth -4

"""check for new / old style related problems
"""

@others
</t>
<t tx="ekr.20100215090114.8389">from logilab import astng

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker

MSGS = {
    'E1001': ('Use __slots__ on an old style class',
              'Used when an old style class use the __slots__ attribute.'),
    'E1002': ('Use super on an old style class',
              'Used when an old style class use the super builtin.'),
    'E1003': ('Bad first argument %r given to super class',
              'Used when another argument than the current class is given as \
              first argument of the super builtin.'),
    'W1001': ('Use of "property" on an old style class',
              'Used when PyLint detect the use of the builtin "property" \
              on an old style class while this is relying on new style \
              classes features'),
    }


</t>
<t tx="ekr.20100215090114.8390">class NewStyleConflictChecker(BaseChecker):
    """checks for usage of new style capabilities on old style classes and
    other new/old styles conflicts problems                                    
    * use of property, __slots__, super                                        
    * "super" usage                                                            
    """

    __implements__ = (IASTNGChecker,)

    # configuration section name
    name = 'newstyle'
    # messages
    msgs = MSGS
    priority = -2
    # configuration options
    options = ()

    @others
</t>
<t tx="ekr.20100215090114.8391">#    def __init__(self, linter=None):
#        BaseChecker.__init__(self, linter)

def visit_class(self, node):
    """check __slots__ usage
    """        
    if '__slots__' in node and not node.newstyle:
        self.add_message('E1001', node=node)

</t>
<t tx="ekr.20100215090114.8392">def visit_callfunc(self, node):
    """check property usage"""
    parent = node.parent.frame()
    if (isinstance(parent, astng.Class) and
        not parent.newstyle and
        isinstance(node.func, astng.Name)
    ):
        name = node.func.name
        if name == 'property':
            self.add_message('W1001', node=node)

</t>
<t tx="ekr.20100215090114.8393">def visit_function(self, node):
    """check use of super"""
    # ignore actual functions or method within a new style class
    if not node.is_method():
        return
    klass = node.parent.frame()
    for stmt in node.nodes_of_class(astng.CallFunc):
        expr = stmt.func
        if not isinstance(expr, astng.Getattr):
            continue
        call = expr.expr
        # skip the test if using super
        if (isinstance(call, astng.CallFunc) and
           isinstance(call.func, astng.Name) and
           call.func.name == 'super'
        ):
            if not klass.newstyle:
                # super should not be used on an old style class
                self.add_message('E1002', node=node)
            else:
                # super first arg should be the class
                try:
                    supcls = (call.args and call.args[0].infer().next()
                              or None)
                except astng.InferenceError:
                    continue
                if klass is not supcls:
                    supcls = getattr(supcls, 'name', supcls)
                    self.add_message('E1003', node=node, args=supcls)
</t>
<t tx="ekr.20100215090114.8394">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(NewStyleConflictChecker(linter))
</t>
<t tx="ekr.20100215090114.8395">@language python
@tabwidth -4

"""
Raw metrics checker
"""

@others
</t>
<t tx="ekr.20100215090114.8396">import tokenize

# pylint now requires pylint &gt;= 2.2, so this is no longer necessary
#if not hasattr(tokenize, 'NL'):
#    raise ValueError("tokenize.NL doesn't exist -- tokenize module too old")

from logilab.common.ureports import Table

from pylint.interfaces import IRawChecker
from pylint.checkers import BaseRawChecker, EmptyReport
from pylint.reporters import diff_string


</t>
<t tx="ekr.20100215090114.8397">def report_raw_stats(sect, stats, old_stats):
    """calculate percentage of code / doc / comment / empty
    """
    total_lines = stats['total_lines']
    if not total_lines:
        raise EmptyReport()
    sect.description = '%s lines have been analyzed' % total_lines
    lines = ('type', 'number', '%', 'previous', 'difference')
    for node_type in ('code', 'docstring', 'comment', 'empty'):
        key = node_type + '_lines'
        total = stats[key]
        percent = float(total * 100) / total_lines
        old = old_stats.get(key, None)
        if old is not None:
            diff_str = diff_string(old, total)
        else:
            old, diff_str = 'NC', 'NC'
        lines += (node_type, str(total), '%.2f' % percent,
                  str(old), diff_str)
    sect.append(Table(children=lines, cols=5, rheaders=1))


</t>
<t tx="ekr.20100215090114.8398">class RawMetricsChecker(BaseRawChecker):
    """does not check anything but gives some raw metrics :                    
    * total number of lines                                                    
    * total number of code lines                                               
    * total number of docstring lines                                          
    * total number of comments lines                                           
    * total number of empty lines                                              
    """

    __implements__ = (IRawChecker,)

    # configuration section name
    name = 'metrics'
    # configuration options
    options = ( )
    # messages
    msgs = {}
    # reports
    reports = ( ('R0701', 'Raw metrics', report_raw_stats), )

    @others
</t>
<t tx="ekr.20100215090114.8399">def __init__(self, linter):
    BaseRawChecker.__init__(self, linter)
    self.stats = None

</t>
<t tx="ekr.20100215090114.8400">def open(self):
    """init statistics"""
    self.stats = self.linter.add_stats(total_lines=0, code_lines=0,
                                       empty_lines=0, docstring_lines=0,
                                       comment_lines=0)

</t>
<t tx="ekr.20100215090114.8401">def process_tokens(self, tokens):
    """update stats"""
    i = 0
    tokens = list(tokens)
    while i &lt; len(tokens):
        i, lines_number, line_type = get_type(tokens, i)
        self.stats['total_lines'] += lines_number
        self.stats[line_type] += lines_number


</t>
<t tx="ekr.20100215090114.8402">JUNK = (tokenize.NL, tokenize.INDENT, tokenize.NEWLINE, tokenize.ENDMARKER)

def get_type(tokens, start_index):
    """return the line type : docstring, comment, code, empty
    """
    i = start_index
    tok_type = tokens[i][0]
    start = tokens[i][2]
    pos = start
    line_type = None
    while i &lt; len(tokens) and tokens[i][2][0] == start[0]:
        tok_type = tokens[i][0]
        pos = tokens[i][3]
        if line_type is None:
            if tok_type == tokenize.STRING:
                line_type = 'docstring_lines'
            elif tok_type == tokenize.COMMENT:
                line_type = 'comment_lines'
            elif tok_type in JUNK:
                pass
            else:
                line_type = 'code_lines'
        i += 1

    if line_type is None:
        line_type = 'empty_lines'
    elif i &lt; len(tokens) and tok_type == tokenize.NEWLINE:
        i += 1
    return i, pos[0] - start[0] + 1, line_type


</t>
<t tx="ekr.20100215090114.8403">def register(linter):
    """ required method to auto register this checker """
    linter.register_checker(RawMetricsChecker(linter))

</t>
<t tx="ekr.20100215090114.8404">@language python
@tabwidth -4
@others
if __name__ == '__main__':
    run()
</t>
<t tx="ekr.20100215090114.8405">"""a similarities / code duplication command line tool and pylint checker
"""
from __future__ import generators

__revision__ = '$Id: similar.py,v 1.14 2006-03-29 08:24:32 syt Exp $'

import sys

from logilab.common.compat import set, izip, sum, enumerate
from logilab.common.ureports import Table

from pylint.interfaces import IRawChecker
from pylint.checkers import BaseChecker, table_lines_from_stats
</t>
<t tx="ekr.20100215090114.8406">class Similar:
    """finds copy-pasted lines of code in a project"""
    @others
</t>
<t tx="ekr.20100215090114.8407">
def __init__(self, min_lines=4, ignore_comments=False,
             ignore_docstrings=False):
    self.min_lines = min_lines
    self.ignore_comments = ignore_comments
    self.ignore_docstrings = ignore_docstrings
    self.linesets = []

</t>
<t tx="ekr.20100215090114.8408">def append_stream(self, streamid, stream):
    """append a file to search for similarities"""
    self.linesets.append(LineSet(streamid,
                                 stream.readlines(),
                                 self.ignore_comments,
                                 self.ignore_docstrings))

</t>
<t tx="ekr.20100215090114.8409">def run(self):
    """start looking for similarities and display results on stdout"""
    self._display_sims(self._compute_sims())

</t>
<t tx="ekr.20100215090114.8410">def _compute_sims(self):
    """compute similarities in appended files"""
    no_duplicates = {}
    for num, lineset1, idx1, lineset2, idx2 in self._iter_sims():
        duplicate = no_duplicates.setdefault(num, [])
        for couples in duplicate:
            if (lineset1, idx1) in couples or (lineset2, idx2) in couples:
                couples.add( (lineset1, idx1) )
                couples.add( (lineset2, idx2) )
                break
        else:
            duplicate.append( set([(lineset1, idx1), (lineset2, idx2)]) )
    sims = []
    for num, ensembles in no_duplicates.iteritems():
        for couples in ensembles:
            sims.append( (num, couples) )
    sims.sort()
    sims.reverse()
    return sims

</t>
<t tx="ekr.20100215090114.8411">def _display_sims(self, sims):
    """display computed similarities on stdout"""
    nb_lignes_dupliquees = 0
    for num, couples in sims:
        print 
        print num, "similar lines in", len(couples), "files"
        couples = list(couples)
        couples.sort()
        for lineset, idx in couples:
            print "==%s:%s" % (lineset.name, idx)
        # pylint: disable-msg=W0631
        for line in lineset._real_lines[idx:idx+num]:
            print "  ", line,
        nb_lignes_dupliquees += num * (len(couples)-1)
    nb_total_lignes = sum([len(lineset) for lineset in self.linesets])
    print "TOTAL lines=%s duplicates=%s percent=%s" \
        % (nb_total_lignes, nb_lignes_dupliquees,
           nb_lignes_dupliquees*1. / nb_total_lignes)

</t>
<t tx="ekr.20100215090114.8412">def _find_common(self, lineset1, lineset2):
    """find similarities in the two given linesets"""
    lines1 = lineset1.enumerate_stripped
    lines2 = lineset2.enumerate_stripped
    find = lineset2.find
    index1 = 0
    min_lines = self.min_lines
    while index1 &lt; len(lineset1):
        skip = 1
        num = 0
        for index2 in find( lineset1[index1] ):
            non_blank = 0
            for num, ((_, line1), (_, line2)) in enumerate(
                izip(lines1(index1), lines2(index2))):
                if line1 != line2:
                    if non_blank &gt; min_lines:
                        yield num, lineset1, index1, lineset2, index2
                    skip = max(skip, num)
                    break
                if line1:
                    non_blank += 1
            else:
                # we may have reach the end
                num += 1
                if non_blank &gt; min_lines:
                    yield num, lineset1, index1, lineset2, index2
                skip = max(skip, num)
        index1 += skip

</t>
<t tx="ekr.20100215090114.8413">def _iter_sims(self):
    """iterate on similarities among all files, by making a cartesian
    product
    """
    for idx, lineset in enumerate(self.linesets[:-1]):
        for lineset2 in self.linesets[idx+1:]:
            for sim in self._find_common(lineset, lineset2):
                yield sim

</t>
<t tx="ekr.20100215090114.8414">def stripped_lines(lines, ignore_comments, ignore_docstrings):
    strippedlines = []
    docstring = None
    for line in lines:
        line = line.strip()
        if ignore_docstrings:
            if not docstring and \
                   (line.startswith('"""') or line.startswith("'''")):
                docstring = line[:3]
                line = line[3:]
            if docstring:
                if line.endswith(docstring):
                    docstring = None
                line = ''
        # XXX cut when a line begins with code but end with a comment
        if ignore_comments and line.startswith('#'):
            line = ''
        strippedlines.append(line)
    return strippedlines
</t>
<t tx="ekr.20100215090114.8415">class LineSet:
    """Holds and indexes all the lines of a single source file"""
    @others
</t>
<t tx="ekr.20100215090114.8416">def __init__(self, name, lines, ignore_comments=False,
             ignore_docstrings=False):
    self.name = name
    self._real_lines = lines
    self._stripped_lines = stripped_lines(lines, ignore_comments,
                                          ignore_docstrings)
    self._index = self._mk_index()

</t>
<t tx="ekr.20100215090114.8417">def __str__(self):
    return '&lt;Lineset for %s&gt;' % self.name

</t>
<t tx="ekr.20100215090114.8418">def __len__(self):
    return len(self._real_lines)

</t>
<t tx="ekr.20100215090114.8419">def __getitem__(self, index):
    return self._stripped_lines[index]

</t>
<t tx="ekr.20100215090114.8420">def __cmp__(self, other):
    return cmp(self.name, other.name)

</t>
<t tx="ekr.20100215090114.8421">def __hash__(self):
    return id(self)

</t>
<t tx="ekr.20100215090114.8422">def enumerate_stripped(self, start_at=0):
    """return an iterator on stripped lines, starting from a given index
    if specified, else 0
    """
    idx = start_at
    if start_at:
        lines = self._stripped_lines[start_at:]
    else:
        lines = self._stripped_lines
    for line in lines:
        #if line:
        yield idx, line
        idx += 1

</t>
<t tx="ekr.20100215090114.8423">def find(self, stripped_line):
    """return positions of the given stripped line in this set"""
    return self._index.get(stripped_line, ())

</t>
<t tx="ekr.20100215090114.8424">def _mk_index(self):
    """create the index for this set"""
    index = {}
    for line_no, line in enumerate(self._stripped_lines):
        if line:
            index.setdefault(line, []).append( line_no )
    return index


</t>
<t tx="ekr.20100215090114.8425">MSGS = {'R0801': ('Similar lines in %s files\n%s',
                  'Indicates that a set of similar lines has been detected \
                  among multiple file. This usually means that the code should \
                  be refactored to avoid this duplication.')}

def report_similarities(sect, stats, old_stats):
    """make a layout with some stats about duplication"""
    lines = ['', 'now', 'previous', 'difference']
    lines += table_lines_from_stats(stats, old_stats,
                                    ('nb_duplicated_lines',
                                     'percent_duplicated_lines'))
    sect.append(Table(children=lines, cols=4, rheaders=1, cheaders=1))


</t>
<t tx="ekr.20100215090114.8426"># wrapper to get a pylint checker from the similar class
class SimilarChecker(BaseChecker, Similar):
    """checks for similarities and duplicated code. This computation may be
    memory / CPU intensive, so you should disable it if you experiments some
    problems.
    """

    __implements__ = (IRawChecker,)
    # configuration section name
    name = 'similarities'
    # messages
    msgs = MSGS
    # configuration options
    # for available dict keys/values see the optik parser 'add_option' method
    options = (('min-similarity-lines',
                {'default' : 4, 'type' : "int", 'metavar' : '&lt;int&gt;',
                 'help' : 'Minimum lines number of a similarity.'}),
               ('ignore-comments',
                {'default' : True, 'type' : 'yn', 'metavar' : '&lt;y or n&gt;',
                 'help': 'Ignore comments when computing similarities.'}
                ),
               ('ignore-docstrings',
                {'default' : True, 'type' : 'yn', 'metavar' : '&lt;y or n&gt;',
                 'help': 'Ignore docstrings when computing similarities.'}
                ),
               )
    # reports
    reports = ( ('R0801', 'Duplication', report_similarities), )

    @others
</t>
<t tx="ekr.20100215090114.8427">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    Similar.__init__(self, min_lines=4,
                     ignore_comments=True, ignore_docstrings=True)
    self.stats = None

</t>
<t tx="ekr.20100215090114.8428">def set_option(self, opt_name, value, action=None, opt_dict=None):
    """method called to set an option (registered in the options list)

    overridden to report options setting to Similar
    """
    BaseChecker.set_option(self, opt_name, value, action, opt_dict)
    if opt_name == 'min-similarity-lines':
        self.min_lines = self.config.min_similarity_lines
    elif opt_name == 'ignore-comments':
        self.ignore_comments = self.config.ignore_comments
    elif opt_name == 'ignore-docstrings':
        self.ignore_docstrings = self.config.ignore_docstrings

</t>
<t tx="ekr.20100215090114.8429">def open(self):
    """init the checkers: reset linesets and statistics information"""
    self.linesets = []
    self.stats = self.linter.add_stats(nb_duplicated_lines=0,
                                       percent_duplicated_lines=0)

</t>
<t tx="ekr.20100215090114.8430">def process_module(self, stream):
    """process a module

    the module's content is accessible via the stream object

    stream must implements the readlines method
    """
    self.append_stream(self.linter.current_name, stream)

</t>
<t tx="ekr.20100215090114.8431">def close(self):
    """compute and display similarities on closing (i.e. end of parsing)"""
    total = sum([len(lineset) for lineset in self.linesets])
    duplicated = 0
    stats = self.stats
    for num, couples in self._compute_sims():
        msg = []
        for lineset, idx in couples:
            msg.append("==%s:%s" % (lineset.name, idx))
        msg.sort()
        # pylint: disable-msg=W0631
        for line in lineset._real_lines[idx:idx+num]:
            msg.append(line.rstrip())
        self.add_message('R0801', args=(len(couples), '\n'.join(msg)))
        duplicated += num * (len(couples) - 1)
    stats['nb_duplicated_lines'] = duplicated
    stats['percent_duplicated_lines'] = total and duplicated * 100. / total


</t>
<t tx="ekr.20100215090114.8432">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(SimilarChecker(linter))

</t>
<t tx="ekr.20100215090114.8433">def usage(status=0):
    """display command line usage information"""
    print "finds copy pasted blocks in a set of files"
    print
    print 'Usage: similar [-d|--duplicates min_duplicated_lines] \
[--ignore-comments] file1...'
    sys.exit(status)

</t>
<t tx="ekr.20100215090114.8434">def run(argv=None):
    """standalone command line access point"""
    if argv is None:
        argv = sys.argv[1:]
    from getopt import getopt
    s_opts = 'hd:'
    l_opts = ('help', 'duplicates=', 'ignore-comments')
    min_lines = 4
    ignore_comments = False
    opts, args = getopt(argv, s_opts, l_opts)
    for opt, val in opts:
        if opt in ('-d', '--duplicates'):
            min_lines = int(val)
        elif opt in ('-h', '--help'):
            usage()
        elif opt == '--ignore-comments':
            ignore_comments = True
    if not args:
        usage(1)
    sim = Similar(min_lines, ignore_comments)
    for filename in args:
        sim.append_stream(filename, open(filename))
    sim.run()

</t>
<t tx="ekr.20100215090114.8435">@language python
@tabwidth -4
@others
</t>
<t tx="ekr.20100215090114.8436">"""Checker for string formatting operations.
"""

import string
from logilab import astng
from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker

MSGS = {
    'E9900': ("Unsupported format character %r (%#02x) at index %d",
              "Used when a unsupported format character is used in a format\
              string."),
    'E9901': ("Format string ends in middle of conversion specifier",
              "Used when a format string terminates before the end of a \
              conversion specifier."),
    'E9902': ("Mixing named and unnamed conversion specifiers in format string",
              "Used when a format string contains both named (e.g. '%(foo)d') \
              and unnamed (e.g. '%d') conversion specifiers.  This is also \
              used when a named conversion specifier contains * for the \
              minimum field width and/or precision."),
    'E9903': ("Expected mapping for format string, not %s",
              "Used when a format string that uses named conversion specifiers \
              is used with an argument that is not a mapping."),
    'W9900': ("Format string dictionary key should be a string, not %s",
              "Used when a format string that uses named conversion specifiers \
              is used with a dictionary whose keys are not all strings."),
    'W9901': ("Unused key %r in format string dictionary",
              "Used when a format string that uses named conversion specifiers \
              is used with a dictionary that conWtains keys not required by the \
              format string."),
    'E9904': ("Missing key %r in format string dictionary",
              "Used when a format string that uses named conversion specifiers \
              is used with a dictionary that doesn't contain all the keys \
              required by the format string."),
    'E9905': ("Too many arguments for format string",
              "Used when a format string that uses unnamed conversion \
              specifiers is given too few arguments."),
    'E9906': ("Not enough arguments for format string",
              "Used when a format string that uses unnamed conversion \
              specifiers is given too many arguments"),
    }

</t>
<t tx="ekr.20100215090114.8437">class IncompleteFormatStringException(Exception):
    """A format string ended in the middle of a format specifier."""
    pass

</t>
<t tx="ekr.20100215090114.8438">class UnsupportedFormatCharacterException(Exception):
    """A format character in a format string is not one of the supported
    format characters."""
    @others
</t>
<t tx="ekr.20100215090114.8439">def __init__(self, index):
    Exception.__init__(self, index)
    self.index = index

</t>
<t tx="ekr.20100215090114.8440">def parse_format_string(format_string):
    """Parses a format string, returning a tuple of (keys, num_args), where keys
    is the set of mapping keys in the format string, and num_args is the number
    of arguments required by the format string.  Raises
    IncompleteFormatStringException or UnsupportedFormatCharacterException if a
    parse error occurs."""
    keys = set()
    num_args = 0
    def next_char(i):
        i += 1
        if i == len(format_string):
            raise IncompleteFormatStringException
        return (i, format_string[i])
    i = 0
    while i &lt; len(format_string):
        c = format_string[i]
        if c == '%':
            i, c = next_char(i)
            # Parse the mapping key (optional).
            key = None
            if c == '(':
                depth = 1
                i, c = next_char(i)
                key_start = i
                while depth != 0:
                    if c == '(':
                       depth += 1
                    elif c == ')':
                       depth -= 1
                    i, c = next_char(i)
                key_end = i - 1
                key = format_string[key_start:key_end]

            # Parse the conversion flags (optional).
            while c in '#0- +':
                i, c = next_char(i)
            # Parse the minimum field width (optional).
            if c == '*':
                num_args += 1
                i, c = next_char(i)
            else:
                while c in string.digits:
                    i, c = next_char(i)
            # Parse the precision (optional).
            if c == '.':
                i, c = next_char(i)
                if c == '*':
                    num_args += 1
                    i, c = next_char(i)
                else:
                    while c in string.digits:
                        i, c = next_char(i)
            # Parse the length modifier (optional).
            if c in 'hlL':
                i, c = next_char(i)
            # Parse the conversion type (mandatory).
            if c not in 'diouxXeEfFgGcrs%':
                raise UnsupportedFormatCharacterException(i)
            if key:
                keys.add(key)
            elif c != '%':
                num_args += 1
        i += 1
    return keys, num_args

</t>
<t tx="ekr.20100215090114.8441">class StringFormatChecker(BaseChecker):
    """Checks string formatting operations to ensure that the format string
    is valid and the arguments match the format string.
    """
    __implements__ = (IASTNGChecker,)
    name = 'string_format'
    msgs = MSGS
    @others
</t>
<t tx="ekr.20100215090114.8442">def visit_binop(self, node):
    if node.op != '%':
        return
    f = node.left
    args = node.right
    if isinstance(f, astng.Const) and isinstance(f.value, basestring):
        format_string = f.value
        try:
            required_keys, required_num_args = \
                parse_format_string(format_string)
        except UnsupportedFormatCharacterException, e:
            c = format_string[e.index]
            self.add_message('E9900', node=node, args=(c, ord(c), e.index))
        except IncompleteFormatStringException:
            self.add_message('E9901', node=node)
        else:
            if required_keys and required_num_args:
                # The format string uses both named and unnamed format
                # specifiers.
                self.add_message('E9902', node=node)
            elif required_keys:
                # The format string uses only named format specifiers.
                # Check that the RHS of the % operator is a mapping object
                # that contains precisely the set of keys required by the
                # format string.
                if isinstance(args, astng.Dict):
                    keys = set()
                    unknown_keys = False
                    for k, v in args.items:
                        if isinstance(k, astng.Const):
                            key = k.value
                            if isinstance(key, basestring):
                                keys.add(key)
                            else:
                                self.add_message('W9900',
                                                 node=node,
                                                 args=key)
                        else:
                            # One of the keys was something other than a
                            # constant.  Since we can't tell what it is,
                            # supress checks for missing keys in the
                            # dictionary.
                            unknown_keys = True
                    if not unknown_keys:
                        for key in required_keys:
                            if key not in keys:
                                self.add_message('E9904',
                                                 node=node,
                                                 args=key)
                    for key in keys:
                        if key not in required_keys:
                            self.add_message('W9901', node=node, args=key)
                elif (isinstance(args, astng.Const) or
                      isinstance(args, astng.Tuple) or
                      isinstance(args, astng.List) or
                      isinstance(args, astng.ListComp) or
                      isinstance(args, astng.GenExpr) or
                      isinstance(args, astng.Backquote) or
                      isinstance(args, astng.Lambda)):
                    type_name = type(args).__name__
                    self.add_message('E9903', node=node, args=type_name)
                else:
                    # The RHS of the format specifier is a name or
                    # expression.  It may be a mapping object, so
                    # there's nothing we can check.
                    pass
            else:
                # The format string uses only unnamed format specifiers.
                # Check that the number of arguments passed to the RHS of
                # the % operator matches the number required by the format
                # string.
                if isinstance(args, astng.Tuple):
                    num_args = len(args.elts)
                elif (isinstance(args, astng.Const) or
                      isinstance(args, astng.Dict) or
                      isinstance(args, astng.List) or
                      isinstance(args, astng.ListComp) or
                      isinstance(args, astng.GenExpr) or
                      isinstance(args, astng.Backquote) or
                      isinstance(args, astng.Lambda) or
                      isinstance(args, astng.Function)):
                    num_args = 1
                else:
                    # The RHS of the format specifier is a name or
                    # expression.  It could be a tuple of unknown size, so
                    # there's nothing we can check.
                    num_args = None
                if num_args is not None:
                    if num_args &gt; required_num_args:
                        self.add_message('E9905', node=node)
                    elif num_args &lt; required_num_args:
                        self.add_message('E9906', node=node)


</t>
<t tx="ekr.20100215090114.8443">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(StringFormatChecker(linter))
</t>
<t tx="ekr.20100215090114.8444">@language python
@tabwidth -4

"""try to find more bugs in the code using astng inference capabilities
"""

@others
</t>
<t tx="ekr.20100215090114.8445">from logilab.common.compat import set


from logilab import astng
from logilab.astng import InferenceError, NotFoundError
from logilab.astng.infutils import YES, Instance

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker
from pylint.checkers.utils import safe_infer, is_super

MSGS = {
    'E1101': ('%s %r has no %r member',
              'Used when a variable is accessed for an unexistent member.'),
    'E1102': ('%s is not callable',
              'Used when an object being called has been inferred to a non \
              callable object'),
    'E1103': ('%s %r has no %r member (but some types could not be inferred)',
              'Used when a variable is accessed for an unexistent member, but \
              astng was not able to interpret all possible types of this \
              variable.'),
    'E1111': ('Assigning to function call which doesn\'t return',
              'Used when an assignment is done on a function call but the \
              inferred function doesn\'t return anything.'),
    'W1111': ('Assigning to function call which only returns None',
              'Used when an assignment is done on a function call but the \
              inferred function returns nothing but None.'),

    'E1120': ('No value passed for parameter %s in function call',
              'Used when a function call passes too few arguments.'),
    'E1121': ('Too many positional arguments for function call',
              'Used when a function call passes too many positional \
              arguments.'),
    'E1122': ('Duplicate keyword argument %r in function call',
              'Used when a function call passes the same keyword argument \
              multiple times.'),
    'E1123': ('Passing unexpected keyword argument %r in function call',
              'Used when a function call passes a keyword argument that \
              doesn\'t correspond to one of the function\'s parameter names.'),
    'E1124': ('Multiple values passed for parameter %r in function call',
              'Used when a function call would result in assigning multiple \
              values to a function parameter, one value from a positional \
              argument and one from a keyword argument.'),
    }

</t>
<t tx="ekr.20100215090114.8446">class TypeChecker(BaseChecker):
    """try to find bugs in the code using type inference
    """

    __implements__ = (IASTNGChecker,)

    # configuration section name
    name = 'typecheck'
    # messages
    msgs = MSGS
    priority = -1
    # configuration options
    options = (('ignore-mixin-members',
                {'default' : True, 'type' : 'yn', 'metavar': '&lt;y_or_n&gt;',
                 'help' : 'Tells whether missing members accessed in mixin \
class should be ignored. A mixin class is detected if its name ends with \
"mixin" (case insensitive).'}
                ),

               ('ignored-classes',
                {'default' : ('SQLObject',),
                 'type' : 'csv',
                 'metavar' : '&lt;members names&gt;',
                 'help' : 'List of classes names for which member attributes \
should not be checked (useful for classes with attributes dynamically set).'}
                 ),

               ('zope',
                {'default' : False, 'type' : 'yn', 'metavar': '&lt;y_or_n&gt;',
                 'help' : 'When zope mode is activated, add a predefined set \
of Zope acquired attributes to generated-members.'}
                ),
               ('generated-members',
                {'default' : (
        'REQUEST', 'acl_users', 'aq_parent'),
                 'type' : 'csv',
                 'metavar' : '&lt;members names&gt;',
                 'help' : 'List of members which are set dynamically and \
missed by pylint inference system, and so shouldn\'t trigger E0201 when \
accessed.'}
                ),
        )
    @others
</t>
<t tx="ekr.20100215090114.8447">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self.generated_members = list(self.config.generated_members)
    if self.config.zope:
        self.generated_members.extend(('REQUEST', 'acl_users', 'aq_parent'))

</t>
<t tx="ekr.20100215090114.8448">def visit_assattr(self, node):
    if isinstance(node.ass_type(), astng.AugAssign):
        self.visit_getattr(node)

</t>
<t tx="ekr.20100215090114.8449">def visit_delattr(self, node):
    self.visit_getattr(node)

</t>
<t tx="ekr.20100215090114.8450">def visit_getattr(self, node):
    """check that the accessed attribute exists

    to avoid to much false positives for now, we'll consider the code as
    correct if a single of the inferred nodes has the accessed attribute.

    function/method, super call and metaclasses are ignored
    """
    if node.attrname in self.config.generated_members:
        # attribute is marked as generated, stop here
        return

    try:
        infered = list(node.expr.infer())
    except InferenceError:
        return

    # list of (node, nodename) which are missing the attribute
    missingattr = set()
    ignoremim = self.config.ignore_mixin_members
    inference_failure = False
    for owner in infered:
        # skip yes object
        if owner is YES:
            inference_failure = True
            continue
        # skip None anyway
        if isinstance(owner, astng.Const) and owner.value is None:
            continue
        # XXX "super" / metaclass call
        if is_super(owner) or getattr(owner, 'type', None) == 'metaclass':
            continue
        name = getattr(owner, 'name', 'None')
        if name in self.config.ignored_classes:
            continue
        if ignoremim and name[-5:].lower() == 'mixin':
            continue
        try:
            if not [n for n in owner.getattr(node.attrname)
                    if not isinstance(n.statement(), astng.AugAssign)]:
                missingattr.add((owner, name))
                continue
        except AttributeError:
            # XXX method / function
            continue
        except NotFoundError:
            if isinstance(owner, Instance) and owner.has_dynamic_getattr():
                continue
            # explicit skipping of optparse'Values class
            if owner.name == 'Values' and \
                   owner.root().name in ('optik', 'optparse'):
                continue
            missingattr.add((owner, name))
            continue
        # stop on the first found
        break
    else:
        # we have not found any node with the attributes, display the
        # message for infered nodes
        done = set()
        for owner, name in missingattr:
            if isinstance(owner, Instance):
                actual = owner._proxied
            else:
                actual = owner
            if actual in done:
                continue
            done.add(actual)
            if inference_failure:
                msgid = 'E1103'
            else:
                msgid = 'E1101'
            self.add_message(msgid,
                node=node,
                args=(owner.display_type(), name,node.attrname))
</t>
<t tx="ekr.20100215090114.8451">def visit_assign(self, node):
    """check that if assigning to a function call, the function is
    possibly returning something valuable
    """
    if not isinstance(node.value, astng.CallFunc):
        return
    function_node = safe_infer(node.value.func)
    # skip class, generator and incomplete function definition
    if not (isinstance(function_node, astng.Function) and
            function_node.root().fully_defined()):
        return
    if function_node.is_generator() \
           or function_node.is_abstract(pass_is_abstract=False):
        return
    returns = list(function_node.nodes_of_class(astng.Return,
                                                skip_klass=astng.Function))
    if len(returns) == 0:
        self.add_message('E1111', node=node)
    else:
        for rnode in returns:
            if not (isinstance(rnode.value, astng.Const)
                    and rnode.value.value is None):
                break
        else:
            self.add_message('W1111', node=node)

</t>
<t tx="ekr.20100215090114.8452">def visit_callfunc(self, node):
    """check that called functions/methods are inferred to callable objects,
    and that the arguments passed to the function match the parameters in
    the inferred function's definition
    """

    # Build the set of keyword arguments, checking for duplicate keywords,
    # and count the positional arguments.
    keyword_args = set()
    num_positional_args = 0
    for arg in node.args:
        if isinstance(arg, astng.Keyword):
            keyword = arg.arg
            if keyword in keyword_args:
                self.add_message('E1122', node=node, args=keyword)
            keyword_args.add(keyword)
        else:
            num_positional_args += 1

    called = safe_infer(node.func)
    # only function, generator and object defining __call__ are allowed
    if called is not None and not called.callable():
        self.add_message('E1102', node=node, args=node.func.as_string())

    # Note that BoundMethod is a subclass of UnboundMethod (huh?), so must
    # come first in this 'if..else'.
    if isinstance(called, astng.BoundMethod):
        # Bound methods have an extra implicit 'self' argument.
        num_positional_args += 1
    elif isinstance(called, astng.UnboundMethod):
        if called.decorators is not None:
            for d in called.decorators.nodes:
                if isinstance(d, astng.Name) and (d.name == 'classmethod'):
                    # Class methods have an extra implicit 'cls' argument.
                    num_positional_args += 1
                    break
    elif (isinstance(called, astng.Function) or
          isinstance(called, astng.Lambda)):
        pass
    else:
        return

    if called.args.args is None:
        # Built-in functions have no argument information.
        return

    if len( called.argnames() ) != len( set( called.argnames() ) ):
        # Duplicate parameter name (see E9801).  We can't really make sense
        # of the function call in this case, so just return.
        return

    # Analyze the list of formal parameters.
    num_mandatory_parameters = len(called.args.args) - len(called.args.defaults)
    parameters = []
    parameter_name_to_index = {}
    for i, arg in enumerate(called.args.args):
        if isinstance(arg, astng.Tuple):
            name = None
            # Don't store any parameter names within the tuple, since those
            # are not assignable from keyword arguments.
        else:
            if isinstance(arg, astng.Keyword):
                name = arg.arg
            else:
                assert isinstance(arg, astng.AssName)
                # This occurs with:
                #    def f( (a), (b) ): pass
                name = arg.name
            parameter_name_to_index[name] = i
        if i &gt;= num_mandatory_parameters:
            defval = called.args.defaults[i - num_mandatory_parameters]
        else:
            defval = None
        parameters.append([(name, defval), False])

    # Match the supplied arguments against the function parameters.

    # 1. Match the positional arguments.
    for i in range(num_positional_args):
        if i &lt; len(parameters):
            parameters[i][1] = True
        elif called.args.vararg is not None:
            # The remaining positional arguments get assigned to the *args
            # parameter.
            break
        else:
            # Too many positional arguments.
            self.add_message('E1121', node=node)
            break

    # 2. Match the keyword arguments.
    for keyword in keyword_args:
        if keyword in parameter_name_to_index:
            i = parameter_name_to_index[keyword]
            if parameters[i][1]:
                # Duplicate definition of function parameter.
                self.add_message('E1124', node=node, args=keyword)
            else:
                parameters[i][1] = True
        elif called.args.kwarg is not None:
            # The keyword argument gets assigned to the **kwargs parameter.
            pass
        else:
            # Unexpected keyword argument.
            self.add_message('E1123', node=node, args=keyword)

    # 3. Match the *args, if any.  Note that Python actually processes
    #    *args _before_ any keyword arguments, but we wait until after
    #    looking at the keyword arguments so as to make a more conservative
    #    guess at how many values are in the *args sequence.
    if node.starargs is not None:
        for i in range(num_positional_args, len(parameters)):
            [(name, defval), assigned] = parameters[i]
            # Assume that *args provides just enough values for all
            # non-default parameters after the last parameter assigned by
            # the positional arguments but before the first parameter
            # assigned by the keyword arguments.  This is the best we can
            # get without generating any false positives.
            if (defval is not None) or assigned:
                break
            parameters[i][1] = True

    # 4. Match the **kwargs, if any.
    if node.kwargs is not None:
        for i, [(name, defval), assigned] in enumerate(parameters):
            # Assume that *kwargs provides values for all remaining
            # unassigned named parameters.
            if name is not None:
                parameters[i][1] = True
            else:
                # **kwargs can't assign to tuples.
                pass

    # Check that any parameters without a default have been assigned
    # values.
    for [(name, defval), assigned] in parameters:
        if (defval is None) and not assigned:
            if name is None:
                display = '&lt;tuple&gt;'
            else:
                display_name = repr(name)
            self.add_message('E1120', node=node, args=display_name)
</t>
<t tx="ekr.20100215090114.8453">def register(linter):
    """required method to auto register this checker """
    linter.register_checker(TypeChecker(linter))
</t>
<t tx="ekr.20100215090114.8454">@language python
@tabwidth -4


"""some functions that may be useful for various checkers
"""

@others
PYMETHODS = set((
    '__new__', '__init__', '__del__', '__hash__',
    '__str__', '__repr__',
    '__len__', '__iter__',
    '__delete__', '__get__', '__set__',
    '__getitem__', '__setitem__', '__delitem__', '__contains__',
    '__getattribute__', '__getattr__', '__setattr__', '__delattr__',
    '__call__',
    '__enter__', '__exit__',
    '__cmp__', '__ge__', '__gt__', '__le__', '__lt__', '__eq__',
    '__nonzero__', '__neg__', '__invert__',
    '__mul__', '__imul__', '__rmul__',
    '__div__', '__idiv__', '__rdiv__',
    '__add__', '__iadd__', '__radd__',
    '__sub__', '__isub__', '__rsub__',
    '__pow__', '__ipow__', '__rpow__',
    '__mod__', '__imod__', '__rmod__',
    '__and__', '__iand__', '__rand__',
    '__or__', '__ior__', '__ror__',
    '__xor__', '__ixor__', '__rxor__',
    # XXX To be continued
))
</t>
<t tx="ekr.20100215090114.8455"># pylint: disable-msg=W0611
#
from logilab import astng

try:
    # python &gt;= 2.4
    COMP_NODE_TYPES = (astng.ListComp, astng.GenExpr)
    FOR_NODE_TYPES = (astng.For, astng.Comprehension, astng.Comprehension)
except AttributeError:
    COMP_NODE_TYPES = astng.ListComp
    FOR_NODE_TYPES = (astng.For, astng.Comprehension)

</t>
<t tx="ekr.20100215090114.8456">def safe_infer(node):
    """return the inferred value for the given node.
    Return None if inference failed or if there is some ambiguity (more than
    one node has been inferred)
    """
    try:
        inferit = node.infer()
        value = inferit.next()
    except astng.InferenceError:
        return

    try:
        inferit.next()
        return # None if there is ambiguity on the inferred node
    except StopIteration:
        return value

</t>
<t tx="ekr.20100215090114.8457">def is_super(node):
    """return True if the node is referencing the "super" builtin function
    """
    if (
        getattr(node, 'name', None) == 'super' and
        node.root().name == '__builtin__'
    ):
        return True
    return False

</t>
<t tx="ekr.20100215090114.8458">def is_error(node):
    """return true if the function does nothing but raising an exception"""
    for child_node in node.get_children():
        if isinstance(child_node, astng.Raise):
            return True
        return False

</t>
<t tx="ekr.20100215090114.8459">def is_raising(body):
    """return true if the given statement node raise an exception"""
    for node in body:
        if isinstance(node,astng.Raise):
            return True
    return False
</t>
<t tx="ekr.20100215090114.8460">def is_empty(body):
    """return true if the given node does nothing but 'pass'"""
    return len(body) == 1 and isinstance(body[0], astng.Pass)
</t>
<t tx="ekr.20100215090114.8461">builtins = __builtins__.copy()
SPECIAL_BUILTINS = ('__builtins__',) # '__path__', '__file__')

def is_builtin(name): # was is_native_builtin
    """return true if &lt;name&gt; could be considered as a builtin defined by python
    """
    if builtins.has_key(name):
        return True
    if name in SPECIAL_BUILTINS:
        return True
    return False

</t>
<t tx="ekr.20100215090114.8462">def is_defined_before(var_node, comp_node_types=COMP_NODE_TYPES):
    """return True if the variable node is defined by a parent node (list
    or generator comprehension, lambda) or in a previous sibling node
    on the same line (statement_defining ; statement_using)
    """
    varname = var_node.name
    _node = var_node.parent
    while _node:
        if isinstance(_node, comp_node_types):
            for ass_node in _node.nodes_of_class(astng.AssName):
                if ass_node.name == varname:
                    return True
        elif isinstance(_node, astng.For):
            for ass_node in _node.target.nodes_of_class(astng.AssName):
                if ass_node.name == varname:
                    return True
        elif isinstance(_node, astng.With):
            if _node.vars.name == varname:
                return True
        elif isinstance(_node, (astng.Lambda, astng.Function)):
            if _node.args.is_argument(varname):
                return True
            if getattr(_node, 'name', None) == varname:
                return True
            break
        _node = _node.parent
    # possibly multiple statements on the same line using semi colon separator
    stmt = var_node.statement()
    _node = stmt.previous_sibling()
    lineno = stmt.fromlineno
    while _node and _node.fromlineno == lineno:
        for ass_node in _node.nodes_of_class(astng.AssName):
            if ass_node.name == varname:
                return True
        for imp_node in _node.nodes_of_class( (astng.From, astng.Import)):
            if varname in [name[1] or name[0] for name in imp_node.names]:
                return True
        _node = _node.previous_sibling()
    return False
</t>
<t tx="ekr.20100215090114.8463">def is_func_default(node):
    """return true if the given Name node is used in function default argument's
    value
    """
    parent = node.scope()
    if isinstance(parent, astng.Function):
        for default_node in parent.args.defaults:
            for default_name_node in default_node.nodes_of_class(astng.Name):
                if default_name_node is node:
                    return True
    return False
</t>
<t tx="ekr.20100215090114.8464">def is_func_decorator(node):
    """return true if the name is used in function decorator"""
    parent = node.parent
    while parent is not None:
        if isinstance(parent, astng.Decorators):
            return True
        if parent.is_statement or isinstance(parent, astng.Lambda):
            break
        parent = parent.parent
    return False

</t>
<t tx="ekr.20100215090114.8465">def is_ancestor_name(frame, node):
    """return True if `frame` is a astng.Class node with `node` in the
    subtree of its bases attribute
    """
    try:
        bases = frame.bases
    except AttributeError:
        return False
    for base in bases:
        if node in base.nodes_of_class(astng.Name):
            return True
    return False
</t>
<t tx="ekr.20100215090114.8466">def assign_parent(node):
    """return the higher parent which is not an AssName, Tuple or List node
    """
    while node and isinstance(node,
        (astng.AssName,astng.Tuple,astng.List)
    ):
        node = node.parent
    return node

</t>
<t tx="ekr.20100215090114.8467">def overrides_an_abstract_method(class_node, name):
    """return True if pnode is a parent of node"""
    for ancestor in class_node.ancestors():
        if name in ancestor and isinstance(ancestor[name], astng.Function) and \
               ancestor[name].is_abstract(pass_is_abstract=False):
            return True
    return False
</t>
<t tx="ekr.20100215090114.8468">def overrides_a_method(class_node, name):
    """return True if &lt;name&gt; is a method overridden from an ancestor"""
    for ancestor in class_node.ancestors():
        if name in ancestor and isinstance(ancestor[name], astng.Function):
            return True
    return False
</t>
<t tx="ekr.20100215090114.8469">@language python
@tabwidth -4

"""variables checkers for Python code
"""

@others
</t>
<t tx="ekr.20100215090114.8470">from copy import copy

from logilab.common.compat import enumerate
from logilab import astng
from logilab.astng.lookup import builtin_lookup
from logilab.astng.infutils import are_exclusive

from pylint.interfaces import IASTNGChecker
from pylint.checkers import BaseChecker
from pylint.checkers.utils import PYMETHODS, is_ancestor_name, is_builtin, \
     is_defined_before, is_error, is_func_default, is_func_decorator, assign_parent

</t>
<t tx="ekr.20100215090114.8471">def overridden_method(klass, name):
    """get overridden method if any"""
    try:
        parent = klass.local_attr_ancestors(name).next()
    except (StopIteration, KeyError):
        return None
    try:
        meth_node = parent[name]
    except KeyError:
        # We have found an ancestor defining &lt;name&gt; but it's not in the local
        # dictionary. This may happen with astng built from living objects.
        return None
    if isinstance(meth_node, astng.Function):
        return meth_node
    return None


</t>
<t tx="ekr.20100215090114.8472">MSGS = {
    'E0601': ('Using variable %r before assignment',
              'Used when a local variable is accessed before it\'s \
              assignment.'),
    'E0602': ('Undefined variable %r',
              'Used when an undefined variable is accessed.'),

    'E0611': ('No name %r in module %r',
              'Used when a name cannot be found in a module.'),

    'W0601': ('Global variable %r undefined at the module level',
              'Used when a variable is defined through the "global" statement \
              but the variable is not defined in the module scope.'),
    'W0602': ('Using global for %r but no assignment is done',
              'Used when a variable is defined through the "global" statement \
              but no assignment to this variable is done.'),
    'W0603': ('Using the global statement', # W0121
              'Used when you use the "global" statement to update a global \
              variable. PyLint just try to discourage this \
              usage. That doesn\'t mean you can not use it !'),
    'W0604': ('Using the global statement at the module level', # W0103
              'Used when you use the "global" statement at the module level \
              since it has no effect'),
    'W0611': ('Unused import %s',
              'Used when an imported module or variable is not used.'),
    'W0612': ('Unused variable %r',
              'Used when a variable is defined but not used.'),
    'W0613': ('Unused argument %r',
              'Used when a function or method argument is not used.'),
    'W0614': ('Unused import %s from wildcard import',
              'Used when an imported module or variable is not used from a \
              \'from X import *\' style import.'),

    'W0621': ('Redefining name %r from outer scope (line %s)',
              'Used when a variable\'s name hide a name defined in the outer \
              scope.'),
    'W0622': ('Redefining built-in %r',
              'Used when a variable or function override a built-in.'),

    'W0631': ('Using possibly undefined loop variable %r',
              'Used when an loop variable (i.e. defined by a for loop or \
              a list comprehension or a generator expression) is used outside \
              the loop.'),
    }

class VariablesChecker(BaseChecker):
    """checks for
    * unused variables / imports
    * undefined variables
    * redefinition of variable from builtins or from an outer scope
    * use of variable before assignment
    """

    __implements__ = IASTNGChecker

    name = 'variables'
    msgs = MSGS
    priority = -1
    options = (
               ("init-import",
                {'default': 0, 'type' : 'yn', 'metavar' : '&lt;y_or_n&gt;',
                 'help' : 'Tells whether we should check for unused import in \
__init__ files.'}),
               ("dummy-variables-rgx",
                {'default': ('_|dummy'),
                 'type' :'regexp', 'metavar' : '&lt;regexp&gt;',
                 'help' : 'A regular expression matching names used \
                 for dummy variables (i.e. not used).'}),
               ("additional-builtins",
                {'default': (), 'type' : 'csv',
                 'metavar' : '&lt;comma separated list&gt;',
                 'help' : 'List of additional names supposed to be defined in \
builtins. Remember that you should avoid to define new builtins when possible.'
                 }),
               )
    @others
</t>
<t tx="ekr.20100215090114.8473">def __init__(self, linter=None):
    BaseChecker.__init__(self, linter)
    self._to_consume = None
    self._checking_mod_attr = None
    self._vars = None
</t>
<t tx="ekr.20100215090114.8474">def visit_module(self, node):
    """visit module : update consumption analysis variable
    checks globals doesn't overrides builtins
    """
    self._to_consume = [(copy(node.locals), {}, 'module')]
    self._vars = []
    for name, stmts in node.locals.items():
        if is_builtin(name):
            # do not print Redefining builtin for additional builtins
            self.add_message('W0622', args=name, node=stmts[0])
</t>
<t tx="ekr.20100215090114.8475">def leave_module(self, node):
    """leave module: check globals
    """
    assert len(self._to_consume) == 1
    not_consumed = self._to_consume.pop()[0]
    # don't check unused imports in __init__ files
    if not self.config.init_import and node.package:
        return
    for name, stmts in not_consumed.items():
        stmt = stmts[0]
        if isinstance(stmt, astng.Import):
            self.add_message('W0611', args=name, node=stmt)
        elif isinstance(stmt, astng.From) and stmt.modname != '__future__':
            if stmt.names[0][0] == '*':
                self.add_message('W0614', args=name, node=stmt)
            else:
                self.add_message('W0611', args=name, node=stmt)
    del self._to_consume
    del self._vars
</t>
<t tx="ekr.20100215090114.8476">def visit_class(self, node):
    """visit class: update consumption analysis variable
    """
    self._to_consume.append((copy(node.locals), {}, 'class'))

</t>
<t tx="ekr.20100215090114.8477">def leave_class(self, _):
    """leave class: update consumption analysis variable
    """
    # do not check for not used locals here (no sense)
    self._to_consume.pop()

</t>
<t tx="ekr.20100215090114.8478">def visit_lambda(self, node):
    """visit lambda: update consumption analysis variable
    """
    self._to_consume.append((copy(node.locals), {}, 'lambda'))

</t>
<t tx="ekr.20100215090114.8479">def leave_lambda(self, _):
    """leave lambda: update consumption analysis variable
    """
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20100215090114.8480">def visit_genexpr(self, node):
    """visit genexpr: update consumption analysis variable
    """
    self._to_consume.append((copy(node.locals), {}, 'genexpr'))

</t>
<t tx="ekr.20100215090114.8481">def leave_genexpr(self, _):
    """leave genexpr: update consumption analysis variable
    """
    # do not check for not used locals here
    self._to_consume.pop()

</t>
<t tx="ekr.20100215090114.8482">def visit_function(self, node):
    """visit function: update consumption analysis variable and check locals
    """
    globs = node.root().globals
    for name, stmt in node.items():
        if globs.has_key(name) and not isinstance(stmt, astng.Global):
            line = globs[name][0].lineno
            self.add_message('W0621', args=(name, line), node=stmt)
        elif is_builtin(name):
            # do not print Redefining builtin for additional builtins
            self.add_message('W0622', args=name, node=stmt)
    self._to_consume.append((copy(node.locals), {}, 'function'))
    self._vars.append({})

</t>
<t tx="ekr.20100215090114.8483">def leave_function(self, node):
    """leave function: check function's locals are consumed"""
    not_consumed = self._to_consume.pop()[0]
    self._vars.pop(0)
    # don't check arguments of function which are only raising an exception
    if is_error(node):
        return
    # don't check arguments of abstract methods or within an interface
    is_method = node.is_method()
    klass = node.parent.frame()
    if is_method and (klass.type == 'interface' or node.is_abstract()):
        return
    authorized_rgx = self.config.dummy_variables_rgx
    overridden = marker = []
    argnames = node.argnames()
    for name, stmts in not_consumed.iteritems():
        # ignore some special names specified by user configuration
        if authorized_rgx.match(name):
            continue
        # ignore names imported by the global statement
        # FIXME: should only ignore them if it's assigned latter
        stmt = stmts[0]
        if isinstance(stmt, astng.Global):
            continue
        # care about functions with unknown argument (builtins)
        if name in argnames:
            if is_method:
                # don't warn for the first argument of a (non static) method
                if node.type != 'staticmethod' and name == argnames[0]:
                    continue
                # don't warn for argument of an overridden method
                if overridden is marker:
                    overridden = overridden_method(klass, node.name)
                if overridden is not None and name in overridden.argnames():
                    continue
                if node.name in PYMETHODS:
                    continue
            # don't check callback arguments XXX should be configurable
            if node.name.startswith('cb_') or node.name.endswith('_cb'):
                continue
            self.add_message('W0613', args=name, node=stmt)
        else:
            self.add_message('W0612', args=name, node=stmt)

</t>
<t tx="ekr.20100215090114.8484">def visit_global(self, node):
    """check names imported exists in the global scope"""
    frame = node.frame()
    if isinstance(frame, astng.Module):
        self.add_message('W0604', node=node)
        return
    module = frame.root()
    default_message = True
    for name in node.names:
        try:
            assign_nodes = module.getattr(name)
        except astng.NotFoundError:
            # unassigned global, skip
            assign_nodes = []
        for anode in assign_nodes:
            if anode.frame() is frame:
                # same scope level assignment
                break
        else:
            # global but no assignment
            self.add_message('W0602', args=name, node=node)
            default_message = False
        if not assign_nodes:
            continue
        for anode in assign_nodes:
            if anode.frame() is module:
                # module level assignment
                break
        else:
            # global undefined at the module scope
            self.add_message('W0601', args=name, node=node)
            default_message = False
    if default_message:
        self.add_message('W0603', node=node)

</t>
<t tx="ekr.20100215090114.8485">def _loopvar_name(self, node, name):
    # filter variables according to node's scope
    # XXX used to filter parents but don't remember why, and removing this
    # fixes a W0631 false positive reported by Paul Hachmann on 2008/12 on
    # python-projects (added to func_use_for_or_listcomp_var test)
    #astmts = [stmt for stmt in node.lookup(name)[1]
    #          if hasattr(stmt, 'ass_type')] and
    #          not stmt.statement().parent_of(node)]
    astmts = [stmt for stmt in node.lookup(name)[1]
              if hasattr(stmt, 'ass_type')]
    # filter variables according their respective scope
    if not astmts or astmts[0].statement().parent_of(node):
        _astmts = []
    else:
        _astmts = astmts[:1]
    for i, stmt in enumerate(astmts[1:]):
        if astmts[i].statement().parent_of(stmt):
            continue
        _astmts.append(stmt)
    astmts = _astmts
    if len(astmts) == 1:
        ass = astmts[0].ass_type()
        if isinstance(ass, (astng.For, astng.Comprehension, astng.GenExpr)) \
               and not ass.statement() is node.statement():
            self.add_message('W0631', args=name, node=node)

</t>
<t tx="ekr.20100215090114.8486">def visit_assname(self, node):
    if isinstance(node.ass_type(), astng.AugAssign):
        self.visit_name(node)

</t>
<t tx="ekr.20100215090114.8487">def visit_delname(self, node):
    self.visit_name(node)

</t>
<t tx="ekr.20100215090114.8488">def visit_name(self, node):
    """check that a name is defined in the current scope and doesn't
    redefine a built-in
    """
    name = node.name
    stmt = node.statement()
    # probably "is_statement == True" missing somewhere in astng
    assert stmt.fromlineno, (stmt, node, node.fromlineno)
    frame = stmt.scope()
    # if the name node is used as a function default argument's value or as
    # a decorator, then start from the parent frame of the function instead
    # of the function frame - and thus open an inner class scope
    if (is_func_default(node) or is_func_decorator(node)
        or is_ancestor_name(frame, node)):
        start_index = len(self._to_consume) - 2
    else:
        start_index = len(self._to_consume) - 1
    # iterates through parent scopes, from the inner to the outer
    for i in range(start_index, -1, -1):
        to_consume, consumed, scope_type = self._to_consume[i]
        # if the current scope is a class scope but it's not the inner
        # scope, ignore it. This prevents to access this scope instead of
        # the globals one in function members when there are some common
        # names
        if scope_type == 'class' and i != start_index:
            continue
        # the name has already been consumed, only check it's not a loop
        # variable used outside the loop
        if consumed.has_key(name):
            self._loopvar_name(node, name)
            break
        # mark the name as consumed if it's defined in this scope
        # (i.e. no KeyError is raised by "to_consume[name]")
        try:
            consumed[name] = to_consume[name]
        except KeyError:
            continue
        else:
            # checks for use before assignment
            defnode = assign_parent(to_consume[name][0])
            if defnode is not None:
                defstmt = defnode.statement()
                defframe = defstmt.frame()
                maybee0601 = True
                if not frame is defframe:
                    maybee0601 = False
                elif defframe.parent is None:
                    # we are at the module level, check the name is not
                    # defined in builtins
                    if name in defframe.scope_attrs or builtin_lookup(name)[1]:
                        maybee0601 = False
                else:
                    # we are in a local scope, check the name is not
                    # defined in global or builtin scope
                    if defframe.root().lookup(name)[1]:
                        maybee0601 = False
                if (maybee0601
                    and stmt.fromlineno &lt;= defstmt.fromlineno
                    and not is_defined_before(node)
                    and not are_exclusive(stmt, defstmt, ('NameError', 'Exception', 'BaseException'))):
                    if defstmt is stmt and isinstance(node, (astng.DelName,
                                                             astng.AssName)):
                        self.add_message('E0602', args=name, node=node)
                    elif self._to_consume[-1][-1] != 'lambda':
                        # E0601 may *not* occurs in lambda scope
                        self.add_message('E0601', args=name, node=node)
            if not isinstance(node, astng.AssName): # Aug AssName
                del to_consume[name]
            else:
                del consumed[name]
            # check it's not a loop variable used outside the loop
            self._loopvar_name(node, name)
            break
    else:
        # we have not found the name, if it isn't a builtin, that's an
        # undefined name !
        if not (name in astng.Module.scope_attrs or is_builtin(name)
                or name in self.config.additional_builtins):
            self.add_message('E0602', args=name, node=node)
</t>
<t tx="ekr.20100215090114.8489">def visit_import(self, node):
    """check modules attribute accesses"""
    for name, _ in node.names:
        parts = name.split('.')
        try:
            module = node.infer_name_module(parts[0]).next()
        except astng.ResolveError:
            continue
        self._check_module_attrs(node, module, parts[1:])

</t>
<t tx="ekr.20100215090114.8490">def visit_from(self, node):
    """check modules attribute accesses"""
    name_parts = node.modname.split('.')
    try:
        module = node.root().import_module(name_parts[0])
    except KeyboardInterrupt:
        raise
    except:
        return
    module = self._check_module_attrs(node, module, name_parts[1:])
    if not module:
        return
    for name, _ in node.names:
        if name == '*':
            continue
        self._check_module_attrs(node, module, name.split('.'))

</t>
<t tx="ekr.20100215090114.8491">##     def leave_getattr(self, node):
##         """check modules attribute accesses

##         this function is a "leave_" because when parsing 'a.b.c'
##         we want to check the innermost expression first.
##         """
##         if isinstance(node.expr, astng.Name):
##             try:
##                 module = node.expr.infer().next()
##             except astng.InferenceError:
##                 return
##             if not isinstance(module, astng.Module):
##                 # Not a module, don't check
##                 return
##         elif self._checking_mod_attr is not None:
##             module = self._checking_mod_attr
##         else:
##             return
##         self._checking_mod_attr = self._check_module_attrs(node, module,
##                                                            [node.attrname])

##     def leave_default(self, node):
##         """by default, reset the _checking_mod_attr attribute"""
##         self._checking_mod_attr = None

def _check_module_attrs(self, node, module, module_names):
    """check that module_names (list of string) are accessible through the
    given module
    if the latest access name corresponds to a module, return it
    """
    assert isinstance(module, astng.Module), module
    while module_names:
        name = module_names.pop(0)
        if name == '__dict__':
            module = None
            break
        try:
            module = module.getattr(name)[0].infer().next()
        except astng.NotFoundError:
            self.add_message('E0611', args=(name, module.name), node=node)
            return None
        except astng.InferenceError:
            return None
    if module_names:
        # FIXME: other message if name is not the latest part of
        # module_names ?
        modname = module and module.name or '__dict__'
        self.add_message('E0611', node=node,
                         args=('.'.join(module_names), modname))
        return None
    if isinstance(module, astng.Module):
        return module
    return None




</t>
<t tx="ekr.20100215090114.8492">def register(linter):
    """required method to auto register this checker"""
    linter.register_checker(VariablesChecker(linter))
</t>
<t tx="ekr.20100215090114.8493">@language python
@tabwidth -4

"""utilities methods and classes for checkers

Base id of standard checkers (used in msg and report ids):
01: base
02: classes
03: format
04: import
05: misc
06: variables
07: exceptions
08: similar
09: design_analysis
10: newstyle
11: typecheck

The raw_metrics checker has no number associated since it doesn't emit any
messages nor reports. XXX not true, emit a 07 report !
"""

@others

__all__ = ('CheckerHandler', 'BaseChecker', 'initialize', 'package_load')
</t>
<t tx="ekr.20100215090114.8494">
import tokenize
from os import listdir
from os.path import dirname, join, isdir, splitext

from logilab.astng.utils import ASTWalker
from logilab.common.configuration import OptionsProviderMixIn

from pylint.reporters import diff_string, EmptyReport

</t>
<t tx="ekr.20100215090114.8495">def table_lines_from_stats(stats, old_stats, columns):
    """get values listed in &lt;columns&gt; from &lt;stats&gt; and &lt;old_stats&gt;,
    and return a formated list of values, designed to be given to a
    ureport.Table object
    """
    lines = []
    for m_type in columns:
        new = stats[m_type]
        format = str
        if isinstance(new, float):
            format = lambda num: '%.3f' % num
        old = old_stats.get(m_type)
        if old is not None:
            diff_str = diff_string(old, new)
            old = format(old)
        else:
            old, diff_str = 'NC', 'NC'
        lines += (m_type.replace('_', ' '), format(new), old, diff_str)
    return lines
</t>
<t tx="ekr.20100215090114.8496">class BaseChecker(OptionsProviderMixIn, ASTWalker):
    """base class for checkers"""

    options = ()
    priority = -9
    enabled = True
    may_be_disabled = True
    name = None

    @others
</t>
<t tx="ekr.20100215090114.8497">def __init__(self, linter=None):
    """checker instances should have the linter as argument

    linter is an object implementing ILinter
    """
    ASTWalker.__init__(self, self)
    self.name = self.name.lower()
    OptionsProviderMixIn.__init__(self)
    self.linter = linter

</t>
<t tx="ekr.20100215090114.8498">def add_message(self, msg_id, line=None, node=None, args=None):
    """add a message of a given type"""
    self.linter.add_message(msg_id, line, node, args)

</t>
<t tx="ekr.20100215090114.8499">def is_enabled(self):
    """return true if the checker is enabled"""
    return self.enabled

</t>
<t tx="ekr.20100215090114.8500">def enable(self, enabled):
    """enable / disable this checker if true / false is given

    it false values has no effect if the checker can't be disabled
    """
    if not enabled and not self.may_be_disabled:
        raise Exception("can't disable %s checker" % self.name)
    if enabled or self.may_be_disabled:
        self.enabled = enabled

</t>
<t tx="ekr.20100215090114.8501">def package_dir(self):
    """return the base directory for the analysed package"""
    return dirname(self.linter.base_file)


</t>
<t tx="ekr.20100215090114.8502"># dummy methods implementing the IChecker interface

def open(self):
    """called before visiting project (i.e set of modules)"""

</t>
<t tx="ekr.20100215090114.8503">def close(self):
    """called after visiting project (i.e set of modules)"""

</t>
<t tx="ekr.20100215090114.8504">class BaseRawChecker(BaseChecker):
    """base class for raw checkers"""
    @others
</t>
<t tx="ekr.20100215090114.8505">
def process_module(self, stream):
    """process a module

    the module's content is accessible via the stream object

    stream must implement the readline method
    """
    self.process_tokens(tokenize.generate_tokens(stream.readline))

</t>
<t tx="ekr.20100215090114.8506">def process_tokens(self, tokens):
    """should be overridden by subclasses"""
    raise NotImplementedError()


</t>
<t tx="ekr.20100215090114.8507">PY_EXTS = ('.py', '.pyc', '.pyo', '.pyw', '.so', '.dll')

def initialize(linter):
    """initialize linter with checkers in this package """
    package_load(linter, __path__[0])

</t>
<t tx="ekr.20100215090114.8508">def package_load(linter, directory):
    """load all module and package in the given directory, looking for a
    'register' function in each one, used to register pylint checkers
    """
    globs = globals()
    imported = {}
    for filename in listdir(directory):
        basename, extension = splitext(filename)
        if not imported.has_key(basename) and (
            (extension in PY_EXTS and basename != '__init__') or (
             not extension and not basename == 'CVS' and
             isdir(join(directory, basename)))):
            try:
                module = __import__(basename, globs, globs, None)
            except ValueError:
                # empty module name (usually emacs auto-save files)
                continue
            except ImportError:
                import sys
                print &gt;&gt; sys.stderr, "Problem importing module: %s" % filename
            else:
                if hasattr(module, 'register'):
                    module.register(linter)
                    imported[basename] = 1

</t>
<t tx="ekr.20100215090114.8509"># Copyright (c) 2003-2009 LOGILAB S.A. (Paris, FRANCE).
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
</t>
<t tx="ekr.20100215140704.5180"></t>
</tnodes>
</leo_file>
