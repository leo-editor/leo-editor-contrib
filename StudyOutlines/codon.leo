<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20230509052845.1"><vh>codon</vh></v>
<v t="ekr.20230509052845.2"><vh>@path bench</vh>
<v t="ekr.20230509052845.3"><vh>@path binary_trees</vh>
<v t="ekr.20230509052845.4"><vh>@@clean binary_trees.codon</vh>
<v t="ekr.20230509052845.5"><vh>class Node</vh></v>
<v t="ekr.20230509052845.6"><vh>make_tree</vh></v>
<v t="ekr.20230509052845.7"><vh>check_tree</vh></v>
<v t="ekr.20230509052845.8"><vh>make_check</vh></v>
<v t="ekr.20230509052845.9"><vh>get_argchunks</vh></v>
<v t="ekr.20230509052845.10"><vh>main</vh></v>
</v>
<v t="ekr.20230509052845.11"><vh>@@clean binary_trees.py</vh>
<v t="ekr.20230509052845.12"><vh>class Node</vh></v>
<v t="ekr.20230509052845.13"><vh>make_tree</vh></v>
<v t="ekr.20230509052845.14"><vh>check_tree</vh></v>
<v t="ekr.20230509052845.15"><vh>make_check</vh></v>
<v t="ekr.20230509052845.16"><vh>get_argchunks</vh></v>
<v t="ekr.20230509052845.17"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509052845.18"><vh>@path chaos</vh>
<v t="ekr.20230509052845.19"><vh>@@clean chaos.codon</vh>
<v t="ekr.20230509052845.20"><vh>class GVector</vh>
<v t="ekr.20230509052845.21"><vh>GVector.__init__</vh></v>
<v t="ekr.20230509052845.22"><vh>GVector.Mag</vh></v>
<v t="ekr.20230509052845.23"><vh>GVector.dist</vh></v>
<v t="ekr.20230509052845.24"><vh>GVector.__add__</vh></v>
<v t="ekr.20230509052845.25"><vh>GVector.__sub__</vh></v>
<v t="ekr.20230509052845.26"><vh>GVector.__mul__</vh></v>
<v t="ekr.20230509052845.27"><vh>GVector.__rmul__ = __mul__</vh></v>
<v t="ekr.20230509052845.28"><vh>GVector.linear_combination</vh></v>
</v>
<v t="ekr.20230509052845.29"><vh>class Spline</vh>
<v t="ekr.20230509052845.30"><vh>Spline.__init__</vh></v>
<v t="ekr.20230509052845.31"><vh>Spline.GetDomain</vh></v>
<v t="ekr.20230509052845.32"><vh>Spline.__call__</vh></v>
<v t="ekr.20230509052845.33"><vh>Spline.GetIndex</vh></v>
<v t="ekr.20230509052845.34"><vh>Spline.__len__</vh></v>
</v>
<v t="ekr.20230509052845.35"><vh>write_ppm</vh></v>
<v t="ekr.20230509052845.36"><vh>class Chaosgame</vh>
<v t="ekr.20230509052845.37"><vh>Chaosgame.__init__</vh></v>
<v t="ekr.20230509052845.38"><vh>Chaosgame.get_random_trafo</vh></v>
<v t="ekr.20230509052845.39"><vh>Chaosgame.transform_point</vh></v>
<v t="ekr.20230509052845.40"><vh>Chaosgame.truncate</vh></v>
<v t="ekr.20230509052845.41"><vh>Chaosgame.create_image_chaos</vh></v>
</v>
<v t="ekr.20230509052845.42"><vh>main</vh></v>
</v>
<v t="ekr.20230509052845.43"><vh>@@clean chaos.py</vh>
<v t="ekr.20230509052845.44"><vh>class GVector</vh>
<v t="ekr.20230509052845.45"><vh>GVector.__init__</vh></v>
<v t="ekr.20230509052845.46"><vh>GVector.Mag</vh></v>
<v t="ekr.20230509052845.47"><vh>GVector.dist</vh></v>
<v t="ekr.20230509052845.48"><vh>GVector.__add__</vh></v>
<v t="ekr.20230509052845.49"><vh>GVector.__sub__</vh></v>
<v t="ekr.20230509052845.50"><vh>GVector.__mul__</vh></v>
<v t="ekr.20230509052845.51"><vh>GVector.__rmul__ = __mul__</vh></v>
<v t="ekr.20230509052845.52"><vh>GVector.linear_combination</vh></v>
<v t="ekr.20230509052845.53"><vh>GVector.__str__</vh></v>
<v t="ekr.20230509052845.54"><vh>GVector.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.55"><vh>class Spline</vh>
<v t="ekr.20230509052845.56"><vh>Spline.__init__</vh></v>
<v t="ekr.20230509052845.57"><vh>Spline.GetDomain</vh></v>
<v t="ekr.20230509052845.58"><vh>Spline.__call__</vh></v>
<v t="ekr.20230509052845.59"><vh>Spline.GetIndex</vh></v>
<v t="ekr.20230509052845.60"><vh>Spline.__len__</vh></v>
<v t="ekr.20230509052845.61"><vh>Spline.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.62"><vh>write_ppm</vh></v>
<v t="ekr.20230509052845.63"><vh>class Chaosgame</vh>
<v t="ekr.20230509052845.64"><vh>Chaosgame.__init__</vh></v>
<v t="ekr.20230509052845.65"><vh>Chaosgame.get_random_trafo</vh></v>
<v t="ekr.20230509052845.66"><vh>Chaosgame.transform_point</vh></v>
<v t="ekr.20230509052845.67"><vh>Chaosgame.truncate</vh></v>
<v t="ekr.20230509052845.68"><vh>Chaosgame.create_image_chaos</vh></v>
</v>
<v t="ekr.20230509052845.69"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509052845.70"><vh>@path fannkuch</vh>
<v t="ekr.20230509052845.71"><vh>@@clean fannkuch.codon</vh>
<v t="ekr.20230509052845.72"><vh>perm</vh></v>
</v>
<v t="ekr.20230509052845.73"><vh>@@clean fannkuch.py</vh>
<v t="ekr.20230509052845.74"><vh>perm</vh></v>
</v>
</v>
<v t="ekr.20230509052845.75"><vh>@path float</vh>
<v t="ekr.20230509052845.76"><vh>@@clean float.py</vh>
<v t="ekr.20230509052845.77"><vh>class Point</vh>
<v t="ekr.20230509052845.78"><vh>Point.__init__</vh></v>
<v t="ekr.20230509052845.79"><vh>Point.__repr__</vh></v>
<v t="ekr.20230509052845.80"><vh>Point.normalize</vh></v>
<v t="ekr.20230509052845.81"><vh>Point.maximize</vh></v>
</v>
<v t="ekr.20230509052845.82"><vh>maximize</vh></v>
<v t="ekr.20230509052845.83"><vh>benchmark</vh></v>
</v>
</v>
<v t="ekr.20230509052845.84"><vh>@path go</vh>
<v t="ekr.20230509052845.85"><vh>@@clean go.codon</vh>
<v t="ekr.20230509052845.86"><vh>to_pos</vh></v>
<v t="ekr.20230509052845.87"><vh>to_xy</vh></v>
<v t="ekr.20230509052845.88"><vh>class Square</vh>
<v t="ekr.20230509052845.89"><vh>Square.__init__</vh></v>
<v t="ekr.20230509052845.90"><vh>Square.set_neighbours</vh></v>
<v t="ekr.20230509052845.91"><vh>Square.move</vh></v>
<v t="ekr.20230509052845.92"><vh>Square.remove</vh></v>
</v>
<v t="ekr.20230509052845.93"><vh>if color == BLACK:</vh></v>
<v t="ekr.20230509052845.94"><vh>class EmptySet</vh>
<v t="ekr.20230509052845.95"><vh>EmptySet.__init__</vh></v>
<v t="ekr.20230509052845.96"><vh>EmptySet.random_choice</vh></v>
<v t="ekr.20230509052845.97"><vh>EmptySet.add</vh></v>
<v t="ekr.20230509052845.98"><vh>EmptySet.remove</vh></v>
<v t="ekr.20230509052845.99"><vh>EmptySet.set</vh></v>
</v>
<v t="ekr.20230509052845.100"><vh>class ZobristHash</vh>
<v t="ekr.20230509052845.101"><vh>ZobristHash.__init__</vh></v>
<v t="ekr.20230509052845.102"><vh>ZobristHash.update</vh></v>
<v t="ekr.20230509052845.103"><vh>ZobristHash.add</vh></v>
<v t="ekr.20230509052845.104"><vh>ZobristHash.dupe</vh></v>
</v>
<v t="ekr.20230509052845.105"><vh>class Board</vh>
<v t="ekr.20230509052845.106"><vh>Board.__init__</vh></v>
<v t="ekr.20230509052845.107"><vh>Board.reset</vh></v>
<v t="ekr.20230509052845.108"><vh>Board.move</vh></v>
<v t="ekr.20230509052845.109"><vh>Board.random_move</vh></v>
<v t="ekr.20230509052845.110"><vh>Board.useful_fast</vh></v>
<v t="ekr.20230509052845.111"><vh>Board.useful</vh></v>
<v t="ekr.20230509052845.112"><vh>Board.useful_moves</vh></v>
<v t="ekr.20230509052845.113"><vh>Board.replay</vh></v>
<v t="ekr.20230509052845.114"><vh>Board.score</vh></v>
<v t="ekr.20230509052845.115"><vh>Board.check</vh></v>
<v t="ekr.20230509052845.116"><vh>Board.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.117"><vh>class UCTNode</vh>
<v t="ekr.20230509052845.118"><vh>UCTNode.__init__</vh></v>
<v t="ekr.20230509052845.119"><vh>UCTNode.play</vh></v>
<v t="ekr.20230509052845.120"><vh>UCTNode.select</vh></v>
<v t="ekr.20230509052845.121"><vh>UCTNode.random_playout</vh></v>
<v t="ekr.20230509052845.122"><vh>UCTNode.update_path</vh></v>
<v t="ekr.20230509052845.123"><vh>UCTNode.score</vh></v>
<v t="ekr.20230509052845.124"><vh>UCTNode.best_child</vh></v>
<v t="ekr.20230509052845.125"><vh>UCTNode.best_visited</vh></v>
</v>
<v t="ekr.20230509052845.126"><vh>def user_move(board):</vh></v>
<v t="ekr.20230509052845.127"><vh>computer_move</vh></v>
<v t="ekr.20230509052845.128"><vh>versus_cpu</vh></v>
</v>
<v t="ekr.20230509052845.129"><vh>@@clean go.py</vh>
<v t="ekr.20230509052845.130"><vh>to_pos</vh></v>
<v t="ekr.20230509052845.131"><vh>to_xy</vh></v>
<v t="ekr.20230509052845.132"><vh>class Square</vh>
<v t="ekr.20230509052845.133"><vh>Square.__init__</vh></v>
<v t="ekr.20230509052845.134"><vh>Square.set_neighbours</vh></v>
<v t="ekr.20230509052845.135"><vh>Square.move</vh></v>
<v t="ekr.20230509052845.136"><vh>Square.remove</vh></v>
</v>
<v t="ekr.20230509052845.137"><vh>if color == BLACK:</vh></v>
<v t="ekr.20230509052845.138"><vh>class EmptySet</vh>
<v t="ekr.20230509052845.139"><vh>EmptySet.__init__</vh></v>
<v t="ekr.20230509052845.140"><vh>EmptySet.random_choice</vh></v>
<v t="ekr.20230509052845.141"><vh>EmptySet.add</vh></v>
<v t="ekr.20230509052845.142"><vh>EmptySet.remove</vh></v>
<v t="ekr.20230509052845.143"><vh>EmptySet.set</vh></v>
</v>
<v t="ekr.20230509052845.144"><vh>class ZobristHash</vh>
<v t="ekr.20230509052845.145"><vh>ZobristHash.__init__</vh></v>
<v t="ekr.20230509052845.146"><vh>ZobristHash.update</vh></v>
<v t="ekr.20230509052845.147"><vh>ZobristHash.add</vh></v>
<v t="ekr.20230509052845.148"><vh>ZobristHash.dupe</vh></v>
</v>
<v t="ekr.20230509052845.149"><vh>class Board</vh>
<v t="ekr.20230509052845.150"><vh>Board.__init__</vh></v>
<v t="ekr.20230509052845.151"><vh>Board.reset</vh></v>
<v t="ekr.20230509052845.152"><vh>Board.move</vh></v>
<v t="ekr.20230509052845.153"><vh>Board.random_move</vh></v>
<v t="ekr.20230509052845.154"><vh>Board.useful_fast</vh></v>
<v t="ekr.20230509052845.155"><vh>Board.useful</vh></v>
<v t="ekr.20230509052845.156"><vh>Board.useful_moves</vh></v>
<v t="ekr.20230509052845.157"><vh>Board.replay</vh></v>
<v t="ekr.20230509052845.158"><vh>Board.score</vh></v>
<v t="ekr.20230509052845.159"><vh>Board.check</vh></v>
<v t="ekr.20230509052845.160"><vh>Board.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.161"><vh>class UCTNode</vh>
<v t="ekr.20230509052845.162"><vh>UCTNode.__init__</vh></v>
<v t="ekr.20230509052845.163"><vh>UCTNode.play</vh></v>
<v t="ekr.20230509052845.164"><vh>UCTNode.select</vh></v>
<v t="ekr.20230509052845.165"><vh>UCTNode.random_playout</vh></v>
<v t="ekr.20230509052845.166"><vh>UCTNode.update_path</vh></v>
<v t="ekr.20230509052845.167"><vh>UCTNode.score</vh></v>
<v t="ekr.20230509052845.168"><vh>UCTNode.best_child</vh></v>
<v t="ekr.20230509052845.169"><vh>UCTNode.best_visited</vh></v>
</v>
<v t="ekr.20230509052845.170"><vh>def user_move(board):</vh></v>
<v t="ekr.20230509052845.171"><vh>computer_move</vh></v>
<v t="ekr.20230509052845.172"><vh>versus_cpu</vh></v>
</v>
</v>
<v t="ekr.20230509052845.173"><vh>@path mandelbrot</vh>
<v t="ekr.20230509052845.174"><vh>@@clean mandelbrot.codon</vh>
<v t="ekr.20230509052845.175"><vh>scale</vh></v>
</v>
<v t="ekr.20230509052845.176"><vh>@@clean mandelbrot.py</vh>
<v t="ekr.20230509052845.177"><vh>scale</vh></v>
</v>
</v>
<v t="ekr.20230509052845.178"><vh>@path nbody</vh>
<v t="ekr.20230509052845.179"><vh>@@clean nbody.py</vh>
<v t="ekr.20230509052845.180"><vh>combinations</vh></v>
<v t="ekr.20230509052845.181"><vh>PI = 3.14159265358979323</vh></v>
<v t="ekr.20230509052845.182"><vh>advance</vh></v>
<v t="ekr.20230509052845.183"><vh>report_energy</vh></v>
<v t="ekr.20230509052845.184"><vh>offset_momentum</vh></v>
<v t="ekr.20230509052845.185"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509052845.186"><vh>@path primes</vh>
<v t="ekr.20230509052845.187"><vh>@@clean primes.codon</vh>
<v t="ekr.20230509052845.188"><vh>is_prime</vh></v>
</v>
<v t="ekr.20230509052845.189"><vh>@@clean primes.py</vh>
<v t="ekr.20230509052845.190"><vh>is_prime</vh></v>
</v>
</v>
<v t="ekr.20230509052845.191"><vh>@path set_partition</vh>
<v t="ekr.20230509052845.192"><vh>@@clean set_partition.py</vh>
<v t="ekr.20230509052845.193"><vh>conforms</vh></v>
<v t="ekr.20230509052845.194"><vh>partition_filtered</vh></v>
</v>
</v>
<v t="ekr.20230509052845.195"><vh>@path spectral_norm</vh>
<v t="ekr.20230509052845.196"><vh>@@clean spectral_norm.py</vh>
<v t="ekr.20230509052845.197"><vh>eval_A</vh></v>
<v t="ekr.20230509052845.198"><vh>eval_times_u</vh></v>
<v t="ekr.20230509052845.199"><vh>part_At_times_u</vh></v>
<v t="ekr.20230509052845.200"><vh>part_A_times_u</vh></v>
<v t="ekr.20230509052845.201"><vh>eval_AtA_times_u</vh></v>
<v t="ekr.20230509052845.202"><vh>bench_spectral_norm</vh></v>
</v>
</v>
<v t="ekr.20230509052845.203"><vh>@path sum</vh>
<v t="ekr.20230509052845.204"><vh>@@clean sum.py</vh></v>
</v>
<v t="ekr.20230509052845.205"><vh>@path taq</vh>
<v t="ekr.20230509052845.206"><vh>@@clean taq.py</vh>
<v t="ekr.20230509052845.207"><vh>find_peaks</vh></v>
<v t="ekr.20230509052845.208"><vh>process_data</vh></v>
</v>
</v>
<v t="ekr.20230509052845.209"><vh>@path word_count</vh>
<v t="ekr.20230509052845.210"><vh>@@clean word_count.py</vh></v>
</v>
</v>
<v t="ekr.20230509052845.211"><vh>@path codon</vh>
<v t="ekr.20230509052845.212"><vh>@path cir</vh>
<v t="ekr.20230509052845.213"><vh>@@clean attribute.h</vh></v>
<v t="ekr.20230509052845.214"><vh>@@clean base.h</vh>
<v t="ekr.20230509052845.215"><vh>class IdMixin</vh></v>
<v t="ekr.20230509052845.216"><vh>class Node</vh>
<v t="ekr.20230509052845.217"><vh>Node.void setAttribute</vh></v>
<v t="ekr.20230509052845.218"><vh>Node.template &lt;typename AttributeType&gt;</vh></v>
<v t="ekr.20230509052845.219"><vh>Node.bool hasAttribute</vh></v>
<v t="ekr.20230509052845.220"><vh>Node./// @return true if the attribute is in the store</vh></v>
<v t="ekr.20230509052845.221"><vh>Node.const Attribute</vh></v>
<v t="ekr.20230509052845.222"><vh>Node./// Gets the appropriate attribute.</vh></v>
<v t="ekr.20230509052845.223"><vh>Node.auto attributes_begin</vh></v>
<v t="ekr.20230509052845.224"><vh>Node./// @return iterator beyond the last attribute</vh></v>
<v t="ekr.20230509052845.225"><vh>Node.auto attributes_begin</vh></v>
<v t="ekr.20230509052845.226"><vh>Node.auto attributes_end</vh></v>
<v t="ekr.20230509052845.227"><vh>Node.void setSrcInfo</vh></v>
<v t="ekr.20230509052845.228"><vh>Node./// @return the src info</vh></v>
<v t="ekr.20230509052845.229"><vh>Node.const Node</vh></v>
</v>
<v t="ekr.20230509052845.230"><vh>template &lt;typename Derived, typename Parent&gt; class AcceptorExtend : public Parent</vh></v>
<v t="ekr.20230509052845.231"><vh>void accept</vh></v>
<v t="ekr.20230509052845.232"><vh>void accept</vh></v>
<v t="ekr.20230509052845.233"><vh>}</vh></v>
<v t="ekr.20230509052845.234"><vh>template &lt;typename Derived&gt;</vh>
<v t="ekr.20230509052845.235"><vh>class ReplaceableNodeBase</vh>
<v t="ekr.20230509052845.236"><vh>ReplaceableNodeBase.const Derived</vh></v>
<v t="ekr.20230509052845.237"><vh>ReplaceableNodeBase.void replaceAll</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.238"><vh>@@clean cir.h</vh></v>
<v t="ekr.20230509052845.239"><vh>@@clean const.h</vh>
<v t="ekr.20230509052845.240"><vh>class Const</vh></v>
<v t="ekr.20230509052845.241"><vh>template &lt;typename ValueType&gt;</vh>
<v t="ekr.20230509052845.242"><vh>class TemplatedConst</vh></v>
</v>
<v t="ekr.20230509052845.243"><vh>using IntConst</vh></v>
<v t="ekr.20230509052845.244"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509052845.245"><vh>class TemplatedConst</vh></v>
</v>
</v>
<v t="ekr.20230509052845.246"><vh>@@clean flow.h</vh>
<v t="ekr.20230509052845.247"><vh>class Flow</vh></v>
<v t="ekr.20230509052845.248"><vh>class SeriesFlow</vh></v>
<v t="ekr.20230509052845.249"><vh>class WhileFlow</vh></v>
<v t="ekr.20230509052845.250"><vh>class ForFlow</vh>
<v t="ekr.20230509052845.251"><vh>ForFlow.void setParallel</vh></v>
<v t="ekr.20230509052845.252"><vh>ForFlow./// @return the parallel loop schedule, or null if none</vh></v>
<v t="ekr.20230509052845.253"><vh>ForFlow.void setSchedule</vh></v>
</v>
<v t="ekr.20230509052845.254"><vh>class ImperativeForFlow</vh>
<v t="ekr.20230509052845.255"><vh>ImperativeForFlow.void setParallel</vh></v>
<v t="ekr.20230509052845.256"><vh>ImperativeForFlow./// @return the parallel loop schedule, or null if none</vh></v>
<v t="ekr.20230509052845.257"><vh>ImperativeForFlow.void setSchedule</vh></v>
</v>
<v t="ekr.20230509052845.258"><vh>class IfFlow</vh></v>
<v t="ekr.20230509052845.259"><vh>class TryCatchFlow</vh>
<v t="ekr.20230509052845.260"><vh>class Catch</vh></v>
</v>
<v t="ekr.20230509052845.261"><vh>class PipelineFlow</vh>
<v t="ekr.20230509052845.262"><vh>class Stage</vh></v>
</v>
</v>
<v t="ekr.20230509052845.263"><vh>@@clean func.h</vh>
<v t="ekr.20230509052845.264"><vh>class Func</vh></v>
<v t="ekr.20230509052845.265"><vh>class BodiedFunc</vh></v>
<v t="ekr.20230509052845.266"><vh>class ExternalFunc</vh></v>
<v t="ekr.20230509052845.267"><vh>class InternalFunc</vh></v>
<v t="ekr.20230509052845.268"><vh>class LLVMFunc</vh></v>
</v>
<v t="ekr.20230509052845.269"><vh>@@clean instr.h</vh>
<v t="ekr.20230509052845.270"><vh>class Instr</vh></v>
<v t="ekr.20230509052845.271"><vh>class AssignInstr</vh></v>
<v t="ekr.20230509052845.272"><vh>class ExtractInstr</vh></v>
<v t="ekr.20230509052845.273"><vh>class InsertInstr</vh></v>
<v t="ekr.20230509052845.274"><vh>class CallInstr</vh></v>
<v t="ekr.20230509052845.275"><vh>class StackAllocInstr</vh></v>
<v t="ekr.20230509052845.276"><vh>class TypePropertyInstr</vh></v>
<v t="ekr.20230509052845.277"><vh>class YieldInInstr</vh></v>
<v t="ekr.20230509052845.278"><vh>class TernaryInstr</vh></v>
<v t="ekr.20230509052845.279"><vh>class ControlFlowInstr</vh></v>
<v t="ekr.20230509052845.280"><vh>class BreakInstr</vh></v>
<v t="ekr.20230509052845.281"><vh>class ContinueInstr</vh></v>
<v t="ekr.20230509052845.282"><vh>class ReturnInstr</vh></v>
<v t="ekr.20230509052845.283"><vh>class YieldInstr</vh></v>
<v t="ekr.20230509052845.284"><vh>class ThrowInstr</vh></v>
<v t="ekr.20230509052845.285"><vh>class FlowInstr</vh></v>
</v>
<v t="ekr.20230509052845.286"><vh>@@clean module.h</vh>
<v t="ekr.20230509052845.287"><vh>class Module</vh>
<v t="ekr.20230509052845.288"><vh>Module.const Var</vh></v>
<v t="ekr.20230509052845.289"><vh>Module.void remove</vh></v>
<v t="ekr.20230509052845.290"><vh>Module./// @return iterator to the first value</vh></v>
<v t="ekr.20230509052845.291"><vh>Module.const Value</vh></v>
<v t="ekr.20230509052845.292"><vh>Module.void remove</vh></v>
<v t="ekr.20230509052845.293"><vh>Module./// @return iterator to the first type</vh></v>
<v t="ekr.20230509052845.294"><vh>Module.void remove</vh></v>
<v t="ekr.20230509052845.295"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509052845.296"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509052845.297"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509052845.298"><vh>Module./// Constructs and registers an IR node with no source information.</vh></v>
<v t="ekr.20230509052845.299"><vh>Module.void store</vh></v>
<v t="ekr.20230509052845.300"><vh>Module.void store</vh></v>
<v t="ekr.20230509052845.301"><vh>Module.void store</vh></v>
</v>
</v>
<v t="ekr.20230509052845.302"><vh>@@clean pyextension.h</vh></v>
<v t="ekr.20230509052845.303"><vh>@@clean value.h</vh>
<v t="ekr.20230509052845.304"><vh>class Value</vh>
<v t="ekr.20230509052845.305"><vh>Value.int replaceUsedValue</vh></v>
<v t="ekr.20230509052845.306"><vh>Value.using Node::replaceUsedValue</vh></v>
<v t="ekr.20230509052845.307"><vh>Value.int replaceUsedType</vh></v>
<v t="ekr.20230509052845.308"><vh>Value.using Node::replaceUsedType</vh></v>
<v t="ekr.20230509052845.309"><vh>Value.int replaceUsedVariable</vh></v>
</v>
</v>
<v t="ekr.20230509052845.310"><vh>@@clean var.h</vh>
<v t="ekr.20230509052845.311"><vh>class Var</vh>
<v t="ekr.20230509052845.312"><vh>Var.extern al</vh></v>
<v t="ekr.20230509052845.313"><vh>Var.int replaceUsedValue</vh></v>
<v t="ekr.20230509052845.314"><vh>Var.using Node::replaceUsedValue</vh></v>
<v t="ekr.20230509052845.315"><vh>Var.int replaceUsedType</vh></v>
<v t="ekr.20230509052845.316"><vh>Var.using Node::replaceUsedType</vh></v>
<v t="ekr.20230509052845.317"><vh>Var.int replaceUsedVariable</vh></v>
</v>
<v t="ekr.20230509052845.318"><vh>class VarValue</vh></v>
<v t="ekr.20230509052845.319"><vh>class PointerValue</vh></v>
</v>
<v t="ekr.20230509052845.320"><vh>@path analyze</vh>
<v t="ekr.20230509052845.321"><vh>@@clean analysis.h</vh>
<v t="ekr.20230509052845.322"><vh>class Analysis</vh>
<v t="ekr.20230509052845.323"><vh>Analysis.template &lt;typename AnalysisType&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.324"><vh>@path dataflow</vh>
<v t="ekr.20230509052845.325"><vh>@@clean capture.h</vh>
<v t="ekr.20230509052845.326"><vh>class CaptureAnalysis</vh></v>
</v>
<v t="ekr.20230509052845.327"><vh>@@clean cfg.h</vh>
<v t="ekr.20230509052845.328"><vh>class CFBlock</vh>
<v t="ekr.20230509052845.329"><vh>CFBlock.void push_back</vh></v>
<v t="ekr.20230509052845.330"><vh>CFBlock./// Erases a value at the given position.</vh></v>
<v t="ekr.20230509052845.331"><vh>CFBlock.auto successors_insert</vh></v>
<v t="ekr.20230509052845.332"><vh>CFBlock.auto successors_erase</vh></v>
</v>
<v t="ekr.20230509052845.333"><vh>class SyntheticAssignInstr</vh></v>
<v t="ekr.20230509052845.334"><vh>class SyntheticPhiInstr</vh>
<v t="ekr.20230509052845.335"><vh>class Predecessor</vh></v>
</v>
<v t="ekr.20230509052845.336"><vh>class CFGraph</vh>
<v t="ekr.20230509052845.337"><vh>CFGraph.const CFBlock</vh></v>
<v t="ekr.20230509052845.338"><vh>CFGraph./// Creates and inserts a new block</vh></v>
<v t="ekr.20230509052845.339"><vh>CFGraph.void remapValue</vh></v>
<v t="ekr.20230509052845.340"><vh>CFGraph./// Gets a value by id.</vh></v>
<v t="ekr.20230509052845.341"><vh>CFGraph.void reg</vh></v>
</v>
<v t="ekr.20230509052845.342"><vh>/// Builds a control-flow graph from a given function.</vh></v>
<v t="ekr.20230509052845.343"><vh>class CFAnalysis</vh></v>
<v t="ekr.20230509052845.344"><vh>class CFVisitor</vh></v>
<v t="ekr.20230509052845.345"><vh>} // namespace dataflow</vh></v>
<v t="ekr.20230509052845.346"><vh>template &lt;&gt;</vh></v>
</v>
<v t="ekr.20230509052845.347"><vh>@@clean dominator.h</vh>
<v t="ekr.20230509052845.348"><vh>class DominatorInspector</vh></v>
<v t="ekr.20230509052845.349"><vh>/// Result of a dominator analysis.</vh></v>
<v t="ekr.20230509052845.350"><vh>class DominatorAnalysis</vh></v>
</v>
<v t="ekr.20230509052845.351"><vh>@@clean reaching.h</vh>
<v t="ekr.20230509052845.352"><vh>class RDInspector</vh></v>
<v t="ekr.20230509052845.353"><vh>/// Result of a reaching definition analysis.</vh></v>
<v t="ekr.20230509052845.354"><vh>class RDAnalysis</vh></v>
</v>
</v>
<v t="ekr.20230509052845.355"><vh>@path module</vh>
<v t="ekr.20230509052845.356"><vh>@@clean global_vars.h</vh>
<v t="ekr.20230509052845.357"><vh>class GlobalVarsAnalyses</vh></v>
</v>
<v t="ekr.20230509052845.358"><vh>@@clean side_effect.h</vh>
<v t="ekr.20230509052845.359"><vh>class SideEffectAnalysis</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.360"><vh>@path dsl</vh>
<v t="ekr.20230509052845.361"><vh>@@clean codegen.h</vh></v>
<v t="ekr.20230509052845.362"><vh>@@clean nodes.h</vh>
<v t="ekr.20230509052845.363"><vh>class CustomType</vh></v>
<v t="ekr.20230509052845.364"><vh>} // namespace types</vh></v>
<v t="ekr.20230509052845.365"><vh>class CustomConst</vh></v>
<v t="ekr.20230509052845.366"><vh>class CustomFlow</vh></v>
<v t="ekr.20230509052845.367"><vh>class CustomInstr</vh></v>
</v>
</v>
<v t="ekr.20230509052845.368"><vh>@path llvm</vh>
<v t="ekr.20230509052845.369"><vh>@@clean gpu.h</vh></v>
<v t="ekr.20230509052845.370"><vh>@@clean llvisitor.h</vh>
<v t="ekr.20230509052845.371"><vh>class LLVMVisitor</vh>
<v t="ekr.20230509052845.372"><vh>LLVMVisitor.void reset</vh></v>
<v t="ekr.20230509052845.373"><vh>LLVMVisitor.}</vh></v>
<v t="ekr.20230509052845.374"><vh>LLVMVisitor.void reset</vh></v>
<v t="ekr.20230509052845.375"><vh>LLVMVisitor.}</vh></v>
<v t="ekr.20230509052845.376"><vh>LLVMVisitor.void insertFunc</vh></v>
<v t="ekr.20230509052845.377"><vh>LLVMVisitor.llvm::Value *getDummyVoidValue</vh></v>
<v t="ekr.20230509052845.378"><vh>LLVMVisitor.static std::string</vh></v>
<v t="ekr.20230509052845.379"><vh>LLVMVisitor.const SrcInfo</vh></v>
<v t="ekr.20230509052845.380"><vh>LLVMVisitor.const SrcInfo</vh></v>
</v>
</v>
<v t="ekr.20230509052845.381"><vh>@@clean llvm.h</vh></v>
<v t="ekr.20230509052845.382"><vh>@@clean optimize.h</vh></v>
</v>
<v t="ekr.20230509052845.383"><vh>@path transform</vh>
<v t="ekr.20230509052845.384"><vh>@@clean manager.h</vh>
<v t="ekr.20230509052845.385"><vh>class PassManager</vh>
<v t="ekr.20230509052845.386"><vh>class KeyManager</vh></v>
<v t="ekr.20230509052845.387"><vh>/// Container for pass metadata.</vh></v>
<v t="ekr.20230509052845.388"><vh>bool pyNumerics</vh></v>
<v t="ekr.20230509052845.389"><vh>explicit PassManager</vh></v>
<v t="ekr.20230509052845.390"><vh>bool pyNumerics</vh>
<v t="ekr.20230509052845.391"><vh>bool hasPass</vh></v>
</v>
<v t="ekr.20230509052845.392"><vh>bool hasAnalysis</vh></v>
<v t="ekr.20230509052845.393"><vh>/// Registers a pass and appends it to the execution order.</vh></v>
<v t="ekr.20230509052845.394"><vh>bool isDisabled</vh></v>
</v>
</v>
<v t="ekr.20230509052845.395"><vh>@@clean pass.h</vh>
<v t="ekr.20230509052845.396"><vh>class Pass</vh>
<v t="ekr.20230509052845.397"><vh>Pass.template &lt;typename AnalysisType&gt;</vh></v>
</v>
<v t="ekr.20230509052845.398"><vh>class PassGroup</vh></v>
<v t="ekr.20230509052845.399"><vh>class OperatorPass</vh>
<v t="ekr.20230509052845.400"><vh>OperatorPass.void run</vh></v>
</v>
</v>
<v t="ekr.20230509052845.401"><vh>@@clean rewrite.h</vh>
<v t="ekr.20230509052845.402"><vh>class RewriteRule</vh></v>
<v t="ekr.20230509052845.403"><vh>class Rewriter</vh>
<v t="ekr.20230509052845.404"><vh>Rewriter.register Rule</vh></v>
<v t="ekr.20230509052845.405"><vh>Rewriter.void rewrite</vh></v>
</v>
</v>
<v t="ekr.20230509052845.406"><vh>@path cleanup</vh>
<v t="ekr.20230509052845.407"><vh>@@clean canonical.h</vh>
<v t="ekr.20230509052845.408"><vh>class CanonicalizationPass</vh></v>
</v>
<v t="ekr.20230509052845.409"><vh>@@clean dead_code.h</vh>
<v t="ekr.20230509052845.410"><vh>class DeadCodeCleanupPass</vh></v>
</v>
<v t="ekr.20230509052845.411"><vh>@@clean global_demote.h</vh>
<v t="ekr.20230509052845.412"><vh>class GlobalDemotionPass</vh></v>
</v>
<v t="ekr.20230509052845.413"><vh>@@clean replacer.h</vh>
<v t="ekr.20230509052845.414"><vh>class ReplaceCleanupPass</vh></v>
</v>
</v>
<v t="ekr.20230509052845.415"><vh>@path folding</vh>
<v t="ekr.20230509052845.416"><vh>@@clean const_fold.h</vh>
<v t="ekr.20230509052845.417"><vh>class FoldingPass</vh></v>
</v>
<v t="ekr.20230509052845.418"><vh>@@clean const_prop.h</vh>
<v t="ekr.20230509052845.419"><vh>class ConstPropPass</vh></v>
</v>
<v t="ekr.20230509052845.420"><vh>@@clean folding.h</vh>
<v t="ekr.20230509052845.421"><vh>class FoldingPassGroup</vh></v>
</v>
<v t="ekr.20230509052845.422"><vh>@@clean rule.h</vh>
<v t="ekr.20230509052845.423"><vh>template &lt;typename ConstantType&gt;</vh>
<v t="ekr.20230509052845.424"><vh>class SingleConstantCommutativeRule</vh>
<v t="ekr.20230509052845.425"><vh>SingleConstantCommutativeRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509052845.426"><vh>template &lt;typename ConstantType, typename Func, typename OutputType</vh>
<v t="ekr.20230509052845.427"><vh>class DoubleConstantBinaryRule</vh>
<v t="ekr.20230509052845.428"><vh>DoubleConstantBinaryRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509052845.429"><vh>template &lt;typename ConstantType, typename Func&gt;</vh>
<v t="ekr.20230509052845.430"><vh>class SingleConstantUnaryRule</vh>
<v t="ekr.20230509052845.431"><vh>SingleConstantUnaryRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509052845.432"><vh>/// Unary rule that requires no constant.</vh></v>
<v t="ekr.20230509052845.433"><vh>void visit</vh></v>
<v t="ekr.20230509052845.434"><vh>}</vh></v>
<v t="ekr.20230509052845.435"><vh>class NoOpRule</vh>
<v t="ekr.20230509052845.436"><vh>NoOpRule.void visit</vh></v>
</v>
<v t="ekr.20230509052845.437"><vh>class DoubleApplicationNoOpRule</vh>
<v t="ekr.20230509052845.438"><vh>DoubleApplicationNoOpRule.void visit</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.439"><vh>@path lowering</vh>
<v t="ekr.20230509052845.440"><vh>@@clean imperative.h</vh>
<v t="ekr.20230509052845.441"><vh>class ImperativeForFlowLowering</vh></v>
</v>
<v t="ekr.20230509052845.442"><vh>@@clean pipeline.h</vh>
<v t="ekr.20230509052845.443"><vh>class PipelineLowering</vh></v>
</v>
</v>
<v t="ekr.20230509052845.444"><vh>@path parallel</vh>
<v t="ekr.20230509052845.445"><vh>@@clean openmp.h</vh>
<v t="ekr.20230509052845.446"><vh>class OpenMPPass</vh></v>
</v>
<v t="ekr.20230509052845.447"><vh>@@clean schedule.h</vh></v>
</v>
<v t="ekr.20230509052845.448"><vh>@path pythonic</vh>
<v t="ekr.20230509052845.449"><vh>@@clean dict.h</vh>
<v t="ekr.20230509052845.450"><vh>class DictArithmeticOptimization</vh></v>
</v>
<v t="ekr.20230509052845.451"><vh>@@clean generator.h</vh>
<v t="ekr.20230509052845.452"><vh>class GeneratorArgumentOptimization</vh></v>
</v>
<v t="ekr.20230509052845.453"><vh>@@clean io.h</vh>
<v t="ekr.20230509052845.454"><vh>class IOCatOptimization</vh></v>
</v>
<v t="ekr.20230509052845.455"><vh>@@clean list.h</vh>
<v t="ekr.20230509052845.456"><vh>class ListAdditionOptimization</vh></v>
</v>
<v t="ekr.20230509052845.457"><vh>@@clean str.h</vh>
<v t="ekr.20230509052845.458"><vh>class StrAdditionOptimization</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.459"><vh>@path types</vh>
<v t="ekr.20230509052845.460"><vh>@@clean types.h</vh>
<v t="ekr.20230509052845.461"><vh>class Generic</vh></v>
<v t="ekr.20230509052845.462"><vh>class Type</vh>
<v t="ekr.20230509052845.463"><vh>Type.int replaceUsedType</vh></v>
</v>
<v t="ekr.20230509052845.464"><vh>class PrimitiveType</vh></v>
<v t="ekr.20230509052845.465"><vh>class IntType</vh></v>
<v t="ekr.20230509052845.466"><vh>class FloatType</vh></v>
<v t="ekr.20230509052845.467"><vh>class Float32Type</vh></v>
<v t="ekr.20230509052845.468"><vh>class BoolType</vh></v>
<v t="ekr.20230509052845.469"><vh>class ByteType</vh></v>
<v t="ekr.20230509052845.470"><vh>class VoidType</vh></v>
<v t="ekr.20230509052845.471"><vh>class MemberedType</vh>
<v t="ekr.20230509052845.472"><vh>class Field</vh></v>
</v>
<v t="ekr.20230509052845.473"><vh>class RecordType</vh>
<v t="ekr.20230509052845.474"><vh>RecordType.bool doIsAtomic</vh></v>
</v>
<v t="ekr.20230509052845.475"><vh>class RefType</vh>
<v t="ekr.20230509052845.476"><vh>RefType.int getMemberIndex</vh></v>
<v t="ekr.20230509052845.477"><vh>RefType.const_iterator begin</vh></v>
<v t="ekr.20230509052845.478"><vh>RefType.void realize</vh></v>
</v>
<v t="ekr.20230509052845.479"><vh>class FuncType</vh></v>
<v t="ekr.20230509052845.480"><vh>class DerivedType</vh></v>
<v t="ekr.20230509052845.481"><vh>class PointerType</vh></v>
<v t="ekr.20230509052845.482"><vh>class OptionalType</vh></v>
<v t="ekr.20230509052845.483"><vh>class GeneratorType</vh></v>
<v t="ekr.20230509052845.484"><vh>class IntNType</vh></v>
<v t="ekr.20230509052845.485"><vh>class VectorType</vh></v>
<v t="ekr.20230509052845.486"><vh>class UnionType</vh>
<v t="ekr.20230509052845.487"><vh>UnionType.bool doIsAtomic</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.488"><vh>@path util</vh>
<v t="ekr.20230509052845.489"><vh>@@clean cloning.h</vh>
<v t="ekr.20230509052845.490"><vh>class CloneVisitor</vh>
<v t="ekr.20230509052845.491"><vh>CloneVisitor.template &lt;typename NodeType&gt;</vh></v>
<v t="ekr.20230509052845.492"><vh>CloneVisitor.PipelineFlow::Stage clone</vh></v>
<v t="ekr.20230509052845.493"><vh>CloneVisitor.template &lt;typename NodeType, typename... Args&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.494"><vh>@@clean context.h</vh>
<v t="ekr.20230509052845.495"><vh>void replaceFrame</vh></v>
</v>
<v t="ekr.20230509052845.496"><vh>@@clean format.h</vh></v>
<v t="ekr.20230509052845.497"><vh>@@clean inlining.h</vh></v>
<v t="ekr.20230509052845.498"><vh>@@clean irtools.h</vh></v>
<v t="ekr.20230509052845.499"><vh>@@clean iterators.h</vh>
<v t="ekr.20230509052845.500"><vh>template &lt;typename It, typename DereferenceFunc, typename MemberFunc&gt;</vh>
<v t="ekr.20230509052845.501"><vh>template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;</vh></v>
<v t="ekr.20230509052845.502"><vh>template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.503"><vh>@@clean matching.h</vh>
<v t="ekr.20230509052845.504"><vh>class AnyValue</vh></v>
<v t="ekr.20230509052845.505"><vh>class AnyFlow</vh></v>
<v t="ekr.20230509052845.506"><vh>class AnyVar</vh></v>
<v t="ekr.20230509052845.507"><vh>class AnyFunc</vh></v>
</v>
<v t="ekr.20230509052845.508"><vh>@@clean operator.h</vh>
<v t="ekr.20230509052845.509"><vh>void visit</vh></v>
<v t="ekr.20230509052845.510"><vh>namespace codon</vh></v>
<v t="ekr.20230509052845.511"><vh>class Operator</vh>
<v t="ekr.20230509052845.512"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509052845.513"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509052845.514"><vh>Operator.LAMBDA_VISIT</vh></v>
<v t="ekr.20230509052845.515"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509052845.516"><vh>Operator.virtual void handle</vh></v>
<v t="ekr.20230509052845.517"><vh>Operator.auto insertBefore</vh></v>
<v t="ekr.20230509052845.518"><vh>Operator.auto insertAfter</vh></v>
<v t="ekr.20230509052845.519"><vh>Operator.void reset</vh></v>
<v t="ekr.20230509052845.520"><vh>Operator.private:</vh></v>
<v t="ekr.20230509052845.521"><vh>Operator.void processChildren</vh></v>
<v t="ekr.20230509052845.522"><vh>Operator.void processSeriesFlowChildren</vh></v>
</v>
</v>
<v t="ekr.20230509052845.523"><vh>@@clean outlining.h</vh></v>
<v t="ekr.20230509052845.524"><vh>@@clean packs.h</vh>
<v t="ekr.20230509052845.525"><vh>template &lt;typename Desired&gt;</vh></v>
<v t="ekr.20230509052845.526"><vh>/// Utility function to strip parameter packs.</vh></v>
<v t="ekr.20230509052845.527"><vh>template &lt;typename Desired, typename... Args&gt;</vh>
<v t="ekr.20230509052845.528"><vh>void stripPack</vh></v>
</v>
</v>
<v t="ekr.20230509052845.529"><vh>@@clean side_effect.h</vh></v>
<v t="ekr.20230509052845.530"><vh>@@clean visitor.h</vh>
<v t="ekr.20230509052845.531"><vh>class Visitor</vh></v>
<v t="ekr.20230509052845.532"><vh>class ConstVisitor</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.533"><vh>@path compiler</vh>
<v t="ekr.20230509052845.534"><vh>@@clean compiler.h</vh>
<v t="ekr.20230509052845.535"><vh>class Compiler</vh></v>
</v>
<v t="ekr.20230509052845.536"><vh>@@clean debug_listener.h</vh>
<v t="ekr.20230509052845.537"><vh>class DebugListener</vh>
<v t="ekr.20230509052845.538"><vh>class ObjectInfo</vh></v>
</v>
<v t="ekr.20230509052845.539"><vh>class DebugPlugin</vh></v>
</v>
<v t="ekr.20230509052845.540"><vh>@@clean engine.h</vh>
<v t="ekr.20230509052845.541"><vh>class Engine</vh></v>
</v>
<v t="ekr.20230509052845.542"><vh>@@clean error.h</vh>
<v t="ekr.20230509052845.543"><vh>class Message</vh>
<v t="ekr.20230509052845.544"><vh>Message.int col</vh>
<v t="ekr.20230509052845.545"><vh>Message.void log</vh></v>
</v>
</v>
<v t="ekr.20230509052845.546"><vh>class ParserErrorInfo</vh>
<v t="ekr.20230509052845.547"><vh>ParserErrorInfo.void log</vh></v>
</v>
<v t="ekr.20230509052845.548"><vh>class RuntimeErrorInfo</vh>
<v t="ekr.20230509052845.549"><vh>RuntimeErrorInfo.void log</vh></v>
</v>
<v t="ekr.20230509052845.550"><vh>class PluginErrorInfo</vh></v>
<v t="ekr.20230509052845.551"><vh>class IOErrorInfo</vh></v>
<v t="ekr.20230509052845.552"><vh>enum Error</vh></v>
<v t="ekr.20230509052845.553"><vh>template &lt;class... TA&gt;</vh></v>
</v>
<v t="ekr.20230509052845.554"><vh>@@clean jit.h</vh>
<v t="ekr.20230509052845.555"><vh>class JIT</vh></v>
</v>
<v t="ekr.20230509052845.556"><vh>@@clean jit_extern.h</vh></v>
<v t="ekr.20230509052845.557"><vh>@@clean memory_manager.h</vh>
<v t="ekr.20230509052845.558"><vh>class BoehmGCMemoryManager</vh></v>
<v t="ekr.20230509052845.559"><vh>class BoehmGCJITLinkMemoryManager</vh>
<v t="ekr.20230509052845.560"><vh>BoehmGCJITLinkMemoryManager.void deallocate</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.561"><vh>@path dsl</vh>
<v t="ekr.20230509052845.562"><vh>@@clean dsl.h</vh>
<v t="ekr.20230509052845.563"><vh>class DSL</vh></v>
</v>
<v t="ekr.20230509052845.564"><vh>@@clean plugins.h</vh>
<v t="ekr.20230509052845.565"><vh>class PluginManager</vh></v>
</v>
</v>
<v t="ekr.20230509052845.566"><vh>@path parser</vh>
<v t="ekr.20230509052845.567"><vh>@@clean ast.h</vh></v>
<v t="ekr.20230509052845.568"><vh>@@clean cache.h</vh></v>
<v t="ekr.20230509052845.569"><vh>@@clean common.h</vh>
<v t="ekr.20230509052845.570"><vh>template &lt;typename T&gt;</vh></v>
<v t="ekr.20230509052845.571"><vh>template &lt;typename T&gt;</vh></v>
<v t="ekr.20230509052845.572"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.573"><vh>int start</vh></v>
</v>
<v t="ekr.20230509052845.574"><vh>template &lt;typename T, typename U&gt;</vh></v>
<v t="ekr.20230509052845.575"><vh>/// @return True if an item is found in a set s.</vh></v>
<v t="ekr.20230509052845.576"><vh>template &lt;typename T, typename U&gt;</vh></v>
<v t="ekr.20230509052845.577"><vh>template &lt;typename K, typename V, typename U&gt;</vh></v>
<v t="ekr.20230509052845.578"><vh>template &lt;typename K, typename V, typename U&gt;</vh></v>
</v>
<v t="ekr.20230509052845.579"><vh>@@clean ctx.h</vh>
<v t="ekr.20230509052845.580"><vh>void remove</vh></v>
<v t="ekr.20230509052845.581"><vh>/// Return a top-most object with a given identifier or nullptr if it does not exist.</vh></v>
<v t="ekr.20230509052845.582"><vh>void removeFromMap</vh></v>
</v>
<v t="ekr.20230509052845.583"><vh>@path ast</vh>
<v t="ekr.20230509052845.584"><vh>@@clean error.h</vh>
<v t="ekr.20230509052845.585"><vh>class ParserException</vh>
<v t="ekr.20230509052845.586"><vh>ParserException.void trackRealize</vh></v>
<v t="ekr.20230509052845.587"><vh>ParserException.void track</vh></v>
</v>
</v>
<v t="ekr.20230509052845.588"><vh>@@clean expr.h</vh>
<v t="ekr.20230509052845.589"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.590"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509052845.591"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.592"><vh>template &lt;&gt;</vh></v>
<v t="ekr.20230509052845.593"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.594"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.595"><vh>@@clean stmt.h</vh>
<v t="ekr.20230509052845.596"><vh>template &lt;typename... Ts&gt;</vh></v>
<v t="ekr.20230509052845.597"><vh>StmtPtr *lastInBlock</vh></v>
<v t="ekr.20230509052845.598"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.599"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.600"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.601"><vh>@@clean types.h</vh></v>
<v t="ekr.20230509052845.602"><vh>@path types</vh>
<v t="ekr.20230509052845.603"><vh>@@clean class.h</vh>
<v t="ekr.20230509052845.604"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509052845.605"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509052845.606"><vh>@@clean function.h</vh></v>
<v t="ekr.20230509052845.607"><vh>@@clean link.h</vh></v>
<v t="ekr.20230509052845.608"><vh>@@clean static.h</vh></v>
<v t="ekr.20230509052845.609"><vh>@@clean traits.h</vh></v>
<v t="ekr.20230509052845.610"><vh>@@clean type.h</vh>
<v t="ekr.20230509052845.611"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.612"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509052845.613"><vh>const expr</vh></v>
<v t="ekr.20230509052845.614"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.615"><vh>@@clean union.h</vh></v>
</v>
</v>
<v t="ekr.20230509052845.616"><vh>@path peg</vh>
<v t="ekr.20230509052845.617"><vh>@@clean peg.h</vh></v>
<v t="ekr.20230509052845.618"><vh>@@clean rules.h</vh>
<v t="ekr.20230509052845.619"><vh>bool hasCustomStmtKeyword</vh></v>
<v t="ekr.20230509052845.620"><vh>bool hasCustomExprStmt</vh></v>
</v>
</v>
<v t="ekr.20230509052845.621"><vh>@path visitors</vh>
<v t="ekr.20230509052845.622"><vh>@@clean visitor.h</vh>
<v t="ekr.20230509052845.623"><vh>template &lt;typename TE, typename TS&gt;</vh>
<v t="ekr.20230509052845.624"><vh>template &lt;typename T, typename... TArgs&gt;</vh></v>
<v t="ekr.20230509052845.625"><vh>template &lt;typename T, typename... TArgs&gt;</vh></v>
<v t="ekr.20230509052845.626"><vh>public:</vh></v>
<v t="ekr.20230509052845.627"><vh>void visit</vh>
<v t="ekr.20230509052845.628"><vh>void visit</vh>
<v t="ekr.20230509052845.629"><vh>void visit</vh>
<v t="ekr.20230509052845.630"><vh>void visit</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.631"><vh>void visit</vh></v>
<v t="ekr.20230509052845.632"><vh>void visit</vh></v>
<v t="ekr.20230509052845.633"><vh>void visit</vh></v>
<v t="ekr.20230509052845.634"><vh>void visit</vh></v>
<v t="ekr.20230509052845.635"><vh>void visit</vh></v>
<v t="ekr.20230509052845.636"><vh>void visit</vh></v>
<v t="ekr.20230509052845.637"><vh>void visit</vh></v>
<v t="ekr.20230509052845.638"><vh>void visit</vh></v>
<v t="ekr.20230509052845.639"><vh>void visit</vh></v>
<v t="ekr.20230509052845.640"><vh>void visit</vh></v>
<v t="ekr.20230509052845.641"><vh>void visit</vh></v>
<v t="ekr.20230509052845.642"><vh>void visit</vh></v>
<v t="ekr.20230509052845.643"><vh>void visit</vh></v>
<v t="ekr.20230509052845.644"><vh>void visit</vh></v>
<v t="ekr.20230509052845.645"><vh>void visit</vh></v>
<v t="ekr.20230509052845.646"><vh>void visit</vh></v>
<v t="ekr.20230509052845.647"><vh>void visit</vh></v>
<v t="ekr.20230509052845.648"><vh>void visit</vh></v>
<v t="ekr.20230509052845.649"><vh>void visit</vh></v>
<v t="ekr.20230509052845.650"><vh>void visit</vh></v>
<v t="ekr.20230509052845.651"><vh>void visit</vh></v>
<v t="ekr.20230509052845.652"><vh>void visit</vh></v>
<v t="ekr.20230509052845.653"><vh>void visit</vh></v>
<v t="ekr.20230509052845.654"><vh>void visit</vh></v>
<v t="ekr.20230509052845.655"><vh>void visit</vh></v>
<v t="ekr.20230509052845.656"><vh>void visit</vh></v>
<v t="ekr.20230509052845.657"><vh>void visit</vh></v>
<v t="ekr.20230509052845.658"><vh>void visit</vh></v>
<v t="ekr.20230509052845.659"><vh>void visit</vh></v>
<v t="ekr.20230509052845.660"><vh>void visit</vh></v>
<v t="ekr.20230509052845.661"><vh>void visit</vh></v>
<v t="ekr.20230509052845.662"><vh>void visit</vh>
<v t="ekr.20230509052845.663"><vh>void visit</vh></v>
</v>
<v t="ekr.20230509052845.664"><vh>void visit</vh></v>
<v t="ekr.20230509052845.665"><vh>void visit</vh></v>
<v t="ekr.20230509052845.666"><vh>void visit</vh></v>
<v t="ekr.20230509052845.667"><vh>void visit</vh></v>
</v>
</v>
<v t="ekr.20230509052845.668"><vh>@path doc</vh>
<v t="ekr.20230509052845.669"><vh>@@clean doc.h</vh></v>
</v>
<v t="ekr.20230509052845.670"><vh>@path format</vh>
<v t="ekr.20230509052845.671"><vh>@@clean format.h</vh>
<v t="ekr.20230509052845.672"><vh>class FormatVisitor</vh>
<v t="ekr.20230509052845.673"><vh>FormatVisitor.template &lt;typename T&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.674"><vh>@path simplify</vh>
<v t="ekr.20230509052845.675"><vh>@@clean ctx.h</vh></v>
<v t="ekr.20230509052845.676"><vh>@@clean simplify.h</vh>
<v t="ekr.20230509052845.677"><vh>class SimplifyVisitor</vh></v>
</v>
</v>
<v t="ekr.20230509052845.678"><vh>@path translate</vh>
<v t="ekr.20230509052845.679"><vh>@@clean translate.h</vh>
<v t="ekr.20230509052845.680"><vh>class TranslateVisitor</vh>
<v t="ekr.20230509052845.681"><vh>TranslateVisitor.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509052845.682"><vh>@@clean translate_ctx.h</vh></v>
</v>
<v t="ekr.20230509052845.683"><vh>@path typecheck</vh>
<v t="ekr.20230509052845.684"><vh>@@clean ctx.h</vh>
<v t="ekr.20230509052845.685"><vh>const types::ClassTypePtr</vh></v>
<v t="ekr.20230509052845.686"><vh>/// Instantiate the generic type root with the provided generics.</vh></v>
<v t="ekr.20230509052845.687"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509052845.688"><vh>@@clean typecheck.h</vh>
<v t="ekr.20230509052845.689"><vh>class TypecheckVisitor</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509052845.690"><vh>@path runtime</vh>
<v t="ekr.20230509052845.691"><vh>@@clean lib.h</vh>
<v t="ekr.20230509052845.692"><vh>class JITError</vh></v>
</v>
</v>
<v t="ekr.20230509052845.693"><vh>@path util</vh>
<v t="ekr.20230509052845.694"><vh>@@clean common.h</vh>
<v t="ekr.20230509052845.695"><vh>void assertionFailure</vh></v>
<v t="ekr.20230509052845.696"><vh>Logger &amp;getLogger</vh></v>
<v t="ekr.20230509052845.697"><vh>class Timer</vh>
<v t="ekr.20230509052845.698"><vh>Timer.void log</vh></v>
<v t="ekr.20230509052845.699"><vh>Timer.double elapsed</vh></v>
</v>
<v t="ekr.20230509052845.700"><vh>std::ostream &amp;operator&lt;&lt;</vh></v>
<v t="ekr.20230509052845.701"><vh>template &lt;class... TA&gt;</vh></v>
<v t="ekr.20230509052845.702"><vh>template &lt;class... TA&gt;</vh></v>
</v>
<v t="ekr.20230509052845.703"><vh>@@clean jupyter.h</vh></v>
</v>
</v>
<v t="ekr.20230509052845.704"><vh>@path docs</vh>
<v t="ekr.20230509052845.705"><vh>@@clean docgen.py</vh>
<v t="ekr.20230509052845.706"><vh>load_json</vh></v>
<v t="ekr.20230509052845.707"><vh>j=load_json(root)</vh></v>
<v t="ekr.20230509052845.708"><vh>parse_docstr</vh></v>
<v t="ekr.20230509052845.709"><vh>parse_type</vh></v>
<v t="ekr.20230509052845.710"><vh>parse_fn</vh></v>
</v>
</v>
<v t="ekr.20230509052845.711"><vh>@path extra</vh>
<v t="ekr.20230509052845.712"><vh>@path python</vh>
<v t="ekr.20230509052845.713"><vh>@@clean setup.py</vh></v>
<v t="ekr.20230509052845.714"><vh>@path codon</vh>
<v t="ekr.20230509052845.715"><vh>@@clean decorator.py</vh>
<v t="ekr.20230509052845.716"><vh>_common_type</vh></v>
<v t="ekr.20230509052845.717"><vh>_codon_type</vh></v>
<v t="ekr.20230509052845.718"><vh>_codon_types</vh></v>
<v t="ekr.20230509052845.719"><vh>_reset_jit</vh></v>
<v t="ekr.20230509052845.720"><vh>_jit = _reset_jit()</vh></v>
<v t="ekr.20230509052845.721"><vh>class RewriteFunctionArgs</vh>
<v t="ekr.20230509052845.722"><vh>RewriteFunctionArgs.__init__</vh></v>
<v t="ekr.20230509052845.723"><vh>RewriteFunctionArgs.visit_FunctionDef</vh></v>
</v>
<v t="ekr.20230509052845.724"><vh>_obj_to_str</vh></v>
<v t="ekr.20230509052845.725"><vh>_obj_name</vh></v>
<v t="ekr.20230509052845.726"><vh>_parse_decorated</vh></v>
<v t="ekr.20230509052845.727"><vh>convert</vh></v>
<v t="ekr.20230509052845.728"><vh>jit</vh>
<v t="ekr.20230509052845.729"><vh>_decorate</vh></v>
</v>
</v>
<v t="ekr.20230509052845.730"><vh>@@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.731"><vh>@path jupyter</vh>
<v t="ekr.20230509052845.732"><vh>@@clean jupyter.h</vh>
<v t="ekr.20230509052845.733"><vh>class CodonJupyter</vh></v>
</v>
<v t="ekr.20230509052845.734"><vh>@path share</vh>
<v t="ekr.20230509052845.735"><vh>@path jupyter</vh>
<v t="ekr.20230509052845.736"><vh>@path kernels</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.737"><vh>@path stdlib</vh>
<v t="ekr.20230509052845.738"><vh>@@clean bisect.codon</vh>
<v t="ekr.20230509052845.739"><vh>bisect_left</vh></v>
<v t="ekr.20230509052845.740"><vh>bisect_right</vh></v>
<v t="ekr.20230509052845.741"><vh>insort_left</vh></v>
<v t="ekr.20230509052845.742"><vh>insort_right</vh></v>
</v>
<v t="ekr.20230509052845.743"><vh>@@clean cmath.codon</vh>
<v t="ekr.20230509052845.744"><vh>_max_float</vh></v>
<v t="ekr.20230509052845.745"><vh>_min_float</vh></v>
<v t="ekr.20230509052845.746"><vh>_DBL_MAX = _max_float()</vh></v>
<v t="ekr.20230509052845.747"><vh>_special_type</vh></v>
<v t="ekr.20230509052845.748"><vh>_acos_special</vh>
<v t="ekr.20230509052845.749"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.750"><vh>_acosh_special</vh>
<v t="ekr.20230509052845.751"><vh>C</vh></v>
<v t="ekr.20230509052845.752"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.753"><vh>_asinh_special</vh>
<v t="ekr.20230509052845.754"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.755"><vh>_atanh_special</vh>
<v t="ekr.20230509052845.756"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.757"><vh>_cosh_special</vh>
<v t="ekr.20230509052845.758"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.759"><vh>_exp_special</vh>
<v t="ekr.20230509052845.760"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.761"><vh>_log_special</vh>
<v t="ekr.20230509052845.762"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.763"><vh>_sinh_special</vh>
<v t="ekr.20230509052845.764"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.765"><vh>_sqrt_special</vh>
<v t="ekr.20230509052845.766"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.767"><vh>_tanh_special</vh>
<v t="ekr.20230509052845.768"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.769"><vh>_rect_special</vh>
<v t="ekr.20230509052845.770"><vh>C</vh></v>
</v>
<v t="ekr.20230509052845.771"><vh>_is_special</vh></v>
<v t="ekr.20230509052845.772"><vh>_special_get</vh></v>
<v t="ekr.20230509052845.773"><vh>_sqrt_impl</vh></v>
<v t="ekr.20230509052845.774"><vh>_acos_impl</vh></v>
<v t="ekr.20230509052845.775"><vh>_acosh_impl</vh></v>
<v t="ekr.20230509052845.776"><vh>_asinh_impl</vh></v>
<v t="ekr.20230509052845.777"><vh>_asin_impl</vh></v>
<v t="ekr.20230509052845.778"><vh>_atanh_impl</vh></v>
<v t="ekr.20230509052845.779"><vh>_atan_impl</vh></v>
<v t="ekr.20230509052845.780"><vh>_cosh_impl</vh></v>
<v t="ekr.20230509052845.781"><vh>_cos_impl</vh></v>
<v t="ekr.20230509052845.782"><vh>_exp_impl</vh></v>
<v t="ekr.20230509052845.783"><vh>_c_log</vh></v>
<v t="ekr.20230509052845.784"><vh>_log10_impl</vh></v>
<v t="ekr.20230509052845.785"><vh>_sinh_impl</vh></v>
<v t="ekr.20230509052845.786"><vh>_sin_impl</vh></v>
<v t="ekr.20230509052845.787"><vh>_tanh_impl</vh></v>
<v t="ekr.20230509052845.788"><vh>_tan_impl</vh></v>
<v t="ekr.20230509052845.789"><vh>phase</vh></v>
<v t="ekr.20230509052845.790"><vh>polar</vh></v>
<v t="ekr.20230509052845.791"><vh>rect</vh></v>
<v t="ekr.20230509052845.792"><vh>exp</vh></v>
<v t="ekr.20230509052845.793"><vh>log</vh></v>
<v t="ekr.20230509052845.794"><vh>log10</vh></v>
<v t="ekr.20230509052845.795"><vh>sqrt</vh></v>
<v t="ekr.20230509052845.796"><vh>asin</vh></v>
<v t="ekr.20230509052845.797"><vh>acos</vh></v>
<v t="ekr.20230509052845.798"><vh>atan</vh></v>
<v t="ekr.20230509052845.799"><vh>sin</vh></v>
<v t="ekr.20230509052845.800"><vh>cos</vh></v>
<v t="ekr.20230509052845.801"><vh>tan</vh></v>
<v t="ekr.20230509052845.802"><vh>asinh</vh></v>
<v t="ekr.20230509052845.803"><vh>acosh</vh></v>
<v t="ekr.20230509052845.804"><vh>atanh</vh></v>
<v t="ekr.20230509052845.805"><vh>sinh</vh></v>
<v t="ekr.20230509052845.806"><vh>cosh</vh></v>
<v t="ekr.20230509052845.807"><vh>tanh</vh></v>
<v t="ekr.20230509052845.808"><vh>isfinite</vh></v>
<v t="ekr.20230509052845.809"><vh>isinf</vh></v>
<v t="ekr.20230509052845.810"><vh>isnan</vh></v>
<v t="ekr.20230509052845.811"><vh>isclose</vh></v>
</v>
<v t="ekr.20230509052845.812"><vh>@@clean collections.codon</vh>
<v t="ekr.20230509052845.813"><vh>class deque</vh>
<v t="ekr.20230509052845.814"><vh>deque.__init__</vh></v>
<v t="ekr.20230509052845.815"><vh>deque.__init__</vh></v>
<v t="ekr.20230509052845.816"><vh>deque.__init__</vh></v>
<v t="ekr.20230509052845.817"><vh>deque.__init__</vh></v>
<v t="ekr.20230509052845.818"><vh>deque.maxlen</vh></v>
<v t="ekr.20230509052845.819"><vh>deque._double_cap</vh></v>
<v t="ekr.20230509052845.820"><vh>deque._check_not_empty</vh></v>
<v t="ekr.20230509052845.821"><vh>deque.__bool__</vh></v>
<v t="ekr.20230509052845.822"><vh>deque.__len__</vh></v>
<v t="ekr.20230509052845.823"><vh>deque.appendleft</vh></v>
<v t="ekr.20230509052845.824"><vh>deque.append</vh></v>
<v t="ekr.20230509052845.825"><vh>deque.popleft</vh></v>
<v t="ekr.20230509052845.826"><vh>deque.pop</vh></v>
<v t="ekr.20230509052845.827"><vh>deque.clear</vh></v>
<v t="ekr.20230509052845.828"><vh>deque.__iter__</vh></v>
<v t="ekr.20230509052845.829"><vh>deque.__contains__</vh></v>
<v t="ekr.20230509052845.830"><vh>deque.__deepcopy__</vh></v>
<v t="ekr.20230509052845.831"><vh>deque.__copy__</vh></v>
<v t="ekr.20230509052845.832"><vh>deque.copy</vh></v>
<v t="ekr.20230509052845.833"><vh>deque.__repr__</vh></v>
<v t="ekr.20230509052845.834"><vh>deque._idx_check</vh></v>
<v t="ekr.20230509052845.835"><vh>deque.left</vh></v>
<v t="ekr.20230509052845.836"><vh>deque.__getitem__</vh></v>
</v>
<v t="ekr.20230509052845.837"><vh>class _CounterItem</vh>
<v t="ekr.20230509052845.838"><vh>_CounterItem.__eq__</vh></v>
<v t="ekr.20230509052845.839"><vh>_CounterItem.__ne__</vh></v>
<v t="ekr.20230509052845.840"><vh>_CounterItem.__lt__</vh></v>
<v t="ekr.20230509052845.841"><vh>_CounterItem.__gt__</vh></v>
<v t="ekr.20230509052845.842"><vh>_CounterItem.__le__</vh></v>
<v t="ekr.20230509052845.843"><vh>_CounterItem.__ge__</vh></v>
</v>
<v t="ekr.20230509052845.844"><vh>class Counter</vh>
<v t="ekr.20230509052845.845"><vh>Counter.__init__</vh></v>
<v t="ekr.20230509052845.846"><vh>Counter.__init__</vh></v>
<v t="ekr.20230509052845.847"><vh>Counter.__init__</vh></v>
<v t="ekr.20230509052845.848"><vh>Counter.elements</vh></v>
<v t="ekr.20230509052845.849"><vh>Counter.most_common</vh></v>
<v t="ekr.20230509052845.850"><vh>Counter.subtract</vh></v>
<v t="ekr.20230509052845.851"><vh>Counter.subtract</vh></v>
<v t="ekr.20230509052845.852"><vh>Counter.subtract</vh></v>
<v t="ekr.20230509052845.853"><vh>Counter.update</vh></v>
<v t="ekr.20230509052845.854"><vh>Counter.update</vh></v>
<v t="ekr.20230509052845.855"><vh>Counter.update</vh></v>
<v t="ekr.20230509052845.856"><vh>Counter.update</vh></v>
<v t="ekr.20230509052845.857"><vh>Counter.total</vh></v>
<v t="ekr.20230509052845.858"><vh>Counter.__getitem__</vh></v>
<v t="ekr.20230509052845.859"><vh>Counter.__delitem__</vh></v>
<v t="ekr.20230509052845.860"><vh>Counter.__eq__</vh></v>
<v t="ekr.20230509052845.861"><vh>Counter.__ne__</vh></v>
<v t="ekr.20230509052845.862"><vh>Counter.__copy__</vh></v>
<v t="ekr.20230509052845.863"><vh>Counter.__iadd__</vh></v>
<v t="ekr.20230509052845.864"><vh>Counter.__isub__</vh></v>
<v t="ekr.20230509052845.865"><vh>Counter.__iand__</vh></v>
<v t="ekr.20230509052845.866"><vh>Counter.__ior__</vh></v>
<v t="ekr.20230509052845.867"><vh>Counter.__pos__</vh></v>
<v t="ekr.20230509052845.868"><vh>Counter.__neg__</vh></v>
<v t="ekr.20230509052845.869"><vh>Counter.__add__</vh></v>
<v t="ekr.20230509052845.870"><vh>Counter.__sub__</vh></v>
<v t="ekr.20230509052845.871"><vh>Counter.__and__</vh></v>
<v t="ekr.20230509052845.872"><vh>Counter.__or__</vh></v>
<v t="ekr.20230509052845.873"><vh>Counter.__repr__</vh></v>
<v t="ekr.20230509052845.874"><vh>Counter.__dict_do_op_throws__</vh></v>
<v t="ekr.20230509052845.875"><vh>Counter._del_non_positives</vh></v>
</v>
<v t="ekr.20230509052845.876"><vh>class Dict</vh></v>
<v t="ekr.20230509052845.877"><vh>class defaultdict</vh>
<v t="ekr.20230509052845.878"><vh>defaultdict.__init__</vh></v>
<v t="ekr.20230509052845.879"><vh>defaultdict.__init__</vh></v>
<v t="ekr.20230509052845.880"><vh>defaultdict.__init__</vh></v>
<v t="ekr.20230509052845.881"><vh>defaultdict.__init__</vh></v>
<v t="ekr.20230509052845.882"><vh>defaultdict.__missing__</vh></v>
<v t="ekr.20230509052845.883"><vh>defaultdict.__getitem__</vh></v>
<v t="ekr.20230509052845.884"><vh>defaultdict.__dict_do_op_throws__</vh></v>
<v t="ekr.20230509052845.885"><vh>defaultdict.copy</vh></v>
<v t="ekr.20230509052845.886"><vh>defaultdict.__copy__</vh></v>
<v t="ekr.20230509052845.887"><vh>defaultdict.__deepcopy__</vh></v>
<v t="ekr.20230509052845.888"><vh>defaultdict.__eq__</vh></v>
<v t="ekr.20230509052845.889"><vh>defaultdict.__ne__</vh></v>
<v t="ekr.20230509052845.890"><vh>defaultdict.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.891"><vh>class Dict</vh></v>
<v t="ekr.20230509052845.892"><vh>namedtuple</vh></v>
</v>
<v t="ekr.20230509052845.893"><vh>@@clean copy.codon</vh>
<v t="ekr.20230509052845.894"><vh>class Error</vh></v>
<v t="ekr.20230509052845.895"><vh>copy</vh></v>
<v t="ekr.20230509052845.896"><vh>deepcopy</vh></v>
</v>
<v t="ekr.20230509052845.897"><vh>@@clean datetime.codon</vh>
<v t="ekr.20230509052845.898"><vh>_signed_add_overflowed</vh></v>
<v t="ekr.20230509052845.899"><vh>_divmod</vh></v>
<v t="ekr.20230509052845.900"><vh>_divide_nearest</vh></v>
<v t="ekr.20230509052845.901"><vh>_days_in_monthx</vh></v>
<v t="ekr.20230509052845.902"><vh>_days_before_monthx</vh></v>
<v t="ekr.20230509052845.903"><vh>_is_leap</vh></v>
<v t="ekr.20230509052845.904"><vh>_days_in_month</vh></v>
<v t="ekr.20230509052845.905"><vh>_days_before_month</vh></v>
<v t="ekr.20230509052845.906"><vh>_days_before_year</vh></v>
<v t="ekr.20230509052845.907"><vh>_ord_to_ymd</vh></v>
<v t="ekr.20230509052845.908"><vh>_ymd_to_ord</vh></v>
<v t="ekr.20230509052845.909"><vh>_weekday</vh></v>
<v t="ekr.20230509052845.910"><vh>_iso_week1_monday</vh></v>
<v t="ekr.20230509052845.911"><vh>_check_delta_day_range</vh></v>
<v t="ekr.20230509052845.912"><vh>_check_date_args</vh></v>
<v t="ekr.20230509052845.913"><vh>_check_time_args</vh></v>
<v t="ekr.20230509052845.914"><vh>_normalize_pair</vh></v>
<v t="ekr.20230509052845.915"><vh>_normalize_d_s_us</vh></v>
<v t="ekr.20230509052845.916"><vh>_normalize_y_m_d</vh>
<v t="ekr.20230509052845.917"><vh>error</vh></v>
</v>
<v t="ekr.20230509052845.918"><vh>_normalize_date</vh></v>
<v t="ekr.20230509052845.919"><vh>_normalize_datetime</vh></v>
<v t="ekr.20230509052845.920"><vh>_parse_digits</vh></v>
<v t="ekr.20230509052845.921"><vh>_isoformat_error</vh></v>
<v t="ekr.20230509052845.922"><vh>_parse_isoformat_date</vh></v>
<v t="ekr.20230509052845.923"><vh>_parse_hh_mm_ss_ff</vh></v>
<v t="ekr.20230509052845.924"><vh>_parse_isoformat_time</vh></v>
<v t="ekr.20230509052845.925"><vh>_format_ctime</vh></v>
<v t="ekr.20230509052845.926"><vh>_utc_to_seconds</vh></v>
<v t="ekr.20230509052845.927"><vh>_round_half_even</vh></v>
<v t="ekr.20230509052845.928"><vh>core classes #</vh></v>
<v t="ekr.20230509052845.929"><vh>class timedelta</vh>
<v t="ekr.20230509052845.930"><vh>timedelta._new</vh></v>
<v t="ekr.20230509052845.931"><vh>timedelta._accum</vh></v>
<v t="ekr.20230509052845.932"><vh>timedelta._accum</vh></v>
<v t="ekr.20230509052845.933"><vh>timedelta.__new__</vh></v>
<v t="ekr.20230509052845.934"><vh>timedelta.__new__</vh></v>
<v t="ekr.20230509052845.935"><vh>timedelta.days</vh></v>
<v t="ekr.20230509052845.936"><vh>timedelta.seconds</vh></v>
<v t="ekr.20230509052845.937"><vh>timedelta.microseconds</vh></v>
<v t="ekr.20230509052845.938"><vh>timedelta.__repr__</vh></v>
<v t="ekr.20230509052845.939"><vh>timedelta.__str__</vh></v>
<v t="ekr.20230509052845.940"><vh>timedelta.__add__</vh></v>
<v t="ekr.20230509052845.941"><vh>timedelta.__sub__</vh></v>
<v t="ekr.20230509052845.942"><vh>timedelta.__mul__</vh></v>
<v t="ekr.20230509052845.943"><vh>timedelta.__rmul__</vh></v>
<v t="ekr.20230509052845.944"><vh>timedelta.__mul__</vh></v>
<v t="ekr.20230509052845.945"><vh>timedelta.__rmul__</vh></v>
<v t="ekr.20230509052845.946"><vh>timedelta.__truediv__</vh></v>
<v t="ekr.20230509052845.947"><vh>timedelta.__truediv__</vh></v>
<v t="ekr.20230509052845.948"><vh>timedelta.__truediv__</vh></v>
<v t="ekr.20230509052845.949"><vh>timedelta.__floordiv__</vh></v>
<v t="ekr.20230509052845.950"><vh>timedelta.__floordiv__</vh></v>
<v t="ekr.20230509052845.951"><vh>timedelta.__mod__</vh></v>
<v t="ekr.20230509052845.952"><vh>timedelta.__divmod__</vh></v>
<v t="ekr.20230509052845.953"><vh>timedelta.__pos__</vh></v>
<v t="ekr.20230509052845.954"><vh>timedelta.__neg__</vh></v>
<v t="ekr.20230509052845.955"><vh>timedelta.__abs__</vh></v>
<v t="ekr.20230509052845.956"><vh>timedelta.__eq__</vh></v>
<v t="ekr.20230509052845.957"><vh>timedelta.__ne__</vh></v>
<v t="ekr.20230509052845.958"><vh>timedelta.__lt__</vh></v>
<v t="ekr.20230509052845.959"><vh>timedelta.__le__</vh></v>
<v t="ekr.20230509052845.960"><vh>timedelta.__gt__</vh></v>
<v t="ekr.20230509052845.961"><vh>timedelta.__ge__</vh></v>
<v t="ekr.20230509052845.962"><vh>timedelta.__bool__</vh></v>
<v t="ekr.20230509052845.963"><vh>timedelta.total_seconds</vh></v>
</v>
<v t="ekr.20230509052845.964"><vh>class IsoCalendarDate</vh></v>
<v t="ekr.20230509052845.965"><vh>class date</vh>
<v t="ekr.20230509052845.966"><vh>date.__new__</vh></v>
<v t="ekr.20230509052845.967"><vh>date.year</vh></v>
<v t="ekr.20230509052845.968"><vh>date.month</vh></v>
<v t="ekr.20230509052845.969"><vh>date.day</vh></v>
<v t="ekr.20230509052845.970"><vh>date.__repr__</vh></v>
<v t="ekr.20230509052845.971"><vh>date.today</vh></v>
<v t="ekr.20230509052845.972"><vh>date.fromtimestamp</vh></v>
<v t="ekr.20230509052845.973"><vh>date.fromordinal</vh></v>
<v t="ekr.20230509052845.974"><vh>date.fromisoformat</vh></v>
<v t="ekr.20230509052845.975"><vh>date.fromisocalendar</vh></v>
<v t="ekr.20230509052845.976"><vh>date.__add__</vh></v>
<v t="ekr.20230509052845.977"><vh>date.__sub__</vh></v>
<v t="ekr.20230509052845.978"><vh>date.__sub__</vh></v>
<v t="ekr.20230509052845.979"><vh>date.__eq__</vh></v>
<v t="ekr.20230509052845.980"><vh>date.__ne__</vh></v>
<v t="ekr.20230509052845.981"><vh>date.__lt__</vh></v>
<v t="ekr.20230509052845.982"><vh>date.__le__</vh></v>
<v t="ekr.20230509052845.983"><vh>date.__gt__</vh></v>
<v t="ekr.20230509052845.984"><vh>date.__ge__</vh></v>
<v t="ekr.20230509052845.985"><vh>date.__bool__</vh></v>
<v t="ekr.20230509052845.986"><vh>date.replace</vh></v>
<v t="ekr.20230509052845.987"><vh>date.timetuple</vh></v>
<v t="ekr.20230509052845.988"><vh>date.toordinal</vh></v>
<v t="ekr.20230509052845.989"><vh>date.weekday</vh></v>
<v t="ekr.20230509052845.990"><vh>date.isoweekday</vh></v>
<v t="ekr.20230509052845.991"><vh>date.isocalendar</vh></v>
<v t="ekr.20230509052845.992"><vh>date.isoformat</vh></v>
<v t="ekr.20230509052845.993"><vh>date.__str__</vh></v>
<v t="ekr.20230509052845.994"><vh>date.ctime</vh></v>
</v>
<v t="ekr.20230509052845.995"><vh>class time</vh>
<v t="ekr.20230509052845.996"><vh>time.__new__</vh></v>
<v t="ekr.20230509052845.997"><vh>time.hour</vh></v>
<v t="ekr.20230509052845.998"><vh>time.minute</vh></v>
<v t="ekr.20230509052845.999"><vh>time.second</vh></v>
<v t="ekr.20230509052845.1000"><vh>time.microsecond</vh></v>
<v t="ekr.20230509052845.1001"><vh>time.__repr__</vh></v>
<v t="ekr.20230509052845.1002"><vh>time.__str__</vh></v>
<v t="ekr.20230509052845.1003"><vh>time.__bool__</vh></v>
<v t="ekr.20230509052845.1004"><vh>time.fromisoformat</vh></v>
<v t="ekr.20230509052845.1005"><vh>time.replace</vh></v>
<v t="ekr.20230509052845.1006"><vh>time.isoformat</vh></v>
</v>
<v t="ekr.20230509052845.1007"><vh>class datetime</vh>
<v t="ekr.20230509052845.1008"><vh>datetime.__new__</vh></v>
<v t="ekr.20230509052845.1009"><vh>datetime.date</vh></v>
<v t="ekr.20230509052845.1010"><vh>datetime.time</vh></v>
<v t="ekr.20230509052845.1011"><vh>datetime.year</vh></v>
<v t="ekr.20230509052845.1012"><vh>datetime.month</vh></v>
<v t="ekr.20230509052845.1013"><vh>datetime.day</vh></v>
<v t="ekr.20230509052845.1014"><vh>datetime.hour</vh></v>
<v t="ekr.20230509052845.1015"><vh>datetime.minute</vh></v>
<v t="ekr.20230509052845.1016"><vh>datetime.second</vh></v>
<v t="ekr.20230509052845.1017"><vh>datetime.microsecond</vh></v>
<v t="ekr.20230509052845.1018"><vh>datetime.__repr__</vh></v>
<v t="ekr.20230509052845.1019"><vh>datetime.__str__</vh></v>
<v t="ekr.20230509052845.1020"><vh>datetime._from_timet_and_us</vh></v>
<v t="ekr.20230509052845.1021"><vh>datetime.today</vh></v>
<v t="ekr.20230509052845.1022"><vh>datetime.now</vh></v>
<v t="ekr.20230509052845.1023"><vh>datetime.utcnow</vh></v>
<v t="ekr.20230509052845.1024"><vh>datetime.fromtimestamp</vh></v>
<v t="ekr.20230509052845.1025"><vh>datetime.utcfromtimestamp</vh></v>
<v t="ekr.20230509052845.1026"><vh>datetime.fromordinal</vh></v>
<v t="ekr.20230509052845.1027"><vh>datetime.combine</vh></v>
<v t="ekr.20230509052845.1028"><vh>datetime.fromisoformat</vh></v>
<v t="ekr.20230509052845.1029"><vh>datetime.fromisocalendar</vh></v>
<v t="ekr.20230509052845.1030"><vh>datetime.__add__</vh></v>
<v t="ekr.20230509052845.1031"><vh>datetime.__sub__</vh></v>
<v t="ekr.20230509052845.1032"><vh>datetime.__sub__</vh></v>
<v t="ekr.20230509052845.1033"><vh>datetime.__eq__</vh></v>
<v t="ekr.20230509052845.1034"><vh>datetime.__ne__</vh></v>
<v t="ekr.20230509052845.1035"><vh>datetime.__lt__</vh></v>
<v t="ekr.20230509052845.1036"><vh>datetime.__le__</vh></v>
<v t="ekr.20230509052845.1037"><vh>datetime.__gt__</vh></v>
<v t="ekr.20230509052845.1038"><vh>datetime.__ge__</vh></v>
<v t="ekr.20230509052845.1039"><vh>datetime.__bool__</vh></v>
<v t="ekr.20230509052845.1040"><vh>datetime.replace</vh></v>
<v t="ekr.20230509052845.1041"><vh>datetime.timetuple</vh></v>
<v t="ekr.20230509052845.1042"><vh>datetime.utctimetuple</vh></v>
<v t="ekr.20230509052845.1043"><vh>datetime.toordinal</vh></v>
<v t="ekr.20230509052845.1044"><vh>datetime.timestamp</vh></v>
<v t="ekr.20230509052845.1045"><vh>datetime.weekday</vh></v>
<v t="ekr.20230509052845.1046"><vh>datetime.isoweekday</vh></v>
<v t="ekr.20230509052845.1047"><vh>datetime.isocalendar</vh></v>
<v t="ekr.20230509052845.1048"><vh>datetime.isoformat</vh></v>
<v t="ekr.20230509052845.1049"><vh>datetime.ctime</vh></v>
</v>
<v t="ekr.20230509052845.1050"><vh>class timedelta</vh></v>
</v>
<v t="ekr.20230509052845.1051"><vh>@@clean functools.codon</vh></v>
<v t="ekr.20230509052845.1052"><vh>@@clean getopt.codon</vh>
<v t="ekr.20230509052845.1053"><vh>class GetoptError</vh></v>
<v t="ekr.20230509052845.1054"><vh>long_has_args</vh></v>
<v t="ekr.20230509052845.1055"><vh>do_longs</vh></v>
<v t="ekr.20230509052845.1056"><vh>short_has_arg</vh></v>
<v t="ekr.20230509052845.1057"><vh>do_shorts</vh></v>
<v t="ekr.20230509052845.1058"><vh>getopt</vh></v>
</v>
<v t="ekr.20230509052845.1059"><vh>@@clean gpu.codon</vh>
<v t="ekr.20230509052845.1060"><vh>class Device</vh>
<v t="ekr.20230509052845.1061"><vh>Device.__new__</vh></v>
<v t="ekr.20230509052845.1062"><vh>Device.count</vh></v>
<v t="ekr.20230509052845.1063"><vh>Device.__str__</vh></v>
<v t="ekr.20230509052845.1064"><vh>Device.__index__</vh></v>
<v t="ekr.20230509052845.1065"><vh>Device.__bool__</vh></v>
<v t="ekr.20230509052845.1066"><vh>Device.compute_capability</vh></v>
</v>
<v t="ekr.20230509052845.1067"><vh>class Memory</vh>
<v t="ekr.20230509052845.1068"><vh>Memory._alloc</vh></v>
<v t="ekr.20230509052845.1069"><vh>Memory._read</vh></v>
<v t="ekr.20230509052845.1070"><vh>Memory._write</vh></v>
<v t="ekr.20230509052845.1071"><vh>Memory._free</vh></v>
</v>
<v t="ekr.20230509052845.1072"><vh>syncthreads</vh></v>
<v t="ekr.20230509052845.1073"><vh>class Dim3</vh>
<v t="ekr.20230509052845.1074"><vh>Dim3.__new__</vh></v>
<v t="ekr.20230509052845.1075"><vh>Dim3.x</vh></v>
<v t="ekr.20230509052845.1076"><vh>Dim3.y</vh></v>
<v t="ekr.20230509052845.1077"><vh>Dim3.z</vh></v>
</v>
<v t="ekr.20230509052845.1078"><vh>class Thread</vh>
<v t="ekr.20230509052845.1079"><vh>Thread.x</vh></v>
<v t="ekr.20230509052845.1080"><vh>Thread.y</vh></v>
<v t="ekr.20230509052845.1081"><vh>Thread.z</vh></v>
</v>
<v t="ekr.20230509052845.1082"><vh>class Block</vh>
<v t="ekr.20230509052845.1083"><vh>Block.x</vh></v>
<v t="ekr.20230509052845.1084"><vh>Block.y</vh></v>
<v t="ekr.20230509052845.1085"><vh>Block.z</vh></v>
<v t="ekr.20230509052845.1086"><vh>Block.dim</vh></v>
</v>
<v t="ekr.20230509052845.1087"><vh>class Grid</vh>
<v t="ekr.20230509052845.1088"><vh>Grid.dim</vh></v>
</v>
<v t="ekr.20230509052845.1089"><vh>class Warp</vh>
<v t="ekr.20230509052845.1090"><vh>Warp.__len__</vh></v>
</v>
<v t="ekr.20230509052845.1091"><vh>thread = Thread()</vh></v>
<v t="ekr.20230509052845.1092"><vh>_catch</vh></v>
<v t="ekr.20230509052845.1093"><vh>_catch()</vh></v>
<v t="ekr.20230509052845.1094"><vh>class AllocCache</vh>
<v t="ekr.20230509052845.1095"><vh>AllocCache.add</vh></v>
<v t="ekr.20230509052845.1096"><vh>AllocCache.free</vh></v>
</v>
<v t="ekr.20230509052845.1097"><vh>_tuple_from_gpu</vh></v>
<v t="ekr.20230509052845.1098"><vh>kernel</vh>
<v t="ekr.20230509052845.1099"><vh>canonical_dim</vh></v>
<v t="ekr.20230509052845.1100"><vh>offsets</vh></v>
<v t="ekr.20230509052845.1101"><vh>wrapper</vh></v>
</v>
<v t="ekr.20230509052845.1102"><vh>_ptr_to_gpu</vh></v>
<v t="ekr.20230509052845.1103"><vh>_ptr_from_gpu</vh></v>
<v t="ekr.20230509052845.1104"><vh>_ptr_to_type</vh></v>
<v t="ekr.20230509052845.1105"><vh>_object_to_gpu</vh></v>
<v t="ekr.20230509052845.1106"><vh>_object_from_gpu</vh></v>
<v t="ekr.20230509052845.1107"><vh>class Pointer</vh>
<v t="ekr.20230509052845.1108"><vh>Pointer.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1109"><vh>Pointer.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1110"><vh>Pointer.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1111"><vh>raw</vh></v>
<v t="ekr.20230509052845.1112"><vh>class Ptr</vh>
<v t="ekr.20230509052845.1113"><vh>Ptr.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1114"><vh>Ptr.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1115"><vh>Ptr.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1116"><vh>class NoneType</vh>
<v t="ekr.20230509052845.1117"><vh>NoneType.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1118"><vh>NoneType.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1119"><vh>NoneType.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1120"><vh>class int</vh>
<v t="ekr.20230509052845.1121"><vh>int.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1122"><vh>int.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1123"><vh>int.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1124"><vh>class float</vh>
<v t="ekr.20230509052845.1125"><vh>float.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1126"><vh>float.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1127"><vh>float.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1128"><vh>class float32</vh>
<v t="ekr.20230509052845.1129"><vh>float32.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1130"><vh>float32.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1131"><vh>float32.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1132"><vh>class bool</vh>
<v t="ekr.20230509052845.1133"><vh>bool.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1134"><vh>bool.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1135"><vh>bool.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1136"><vh>class byte</vh>
<v t="ekr.20230509052845.1137"><vh>byte.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1138"><vh>byte.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1139"><vh>byte.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1140"><vh>class Int</vh>
<v t="ekr.20230509052845.1141"><vh>Int.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1142"><vh>Int.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1143"><vh>Int.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1144"><vh>class UInt</vh>
<v t="ekr.20230509052845.1145"><vh>UInt.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1146"><vh>UInt.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1147"><vh>UInt.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1148"><vh>class str</vh>
<v t="ekr.20230509052845.1149"><vh>str.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1150"><vh>str.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1151"><vh>str.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1152"><vh>class List</vh>
<v t="ekr.20230509052845.1153"><vh>List.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1154"><vh>List.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1155"><vh>List.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1156"><vh>class DynamicTuple</vh>
<v t="ekr.20230509052845.1157"><vh>DynamicTuple.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1158"><vh>DynamicTuple.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1159"><vh>DynamicTuple.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1160"><vh>class Dict</vh>
<v t="ekr.20230509052845.1161"><vh>Dict.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1162"><vh>Dict.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1163"><vh>Dict.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1164"><vh>class Set</vh>
<v t="ekr.20230509052845.1165"><vh>Set.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1166"><vh>Set.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1167"><vh>Set.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1168"><vh>class Optional</vh>
<v t="ekr.20230509052845.1169"><vh>Optional.__to_gpu__</vh></v>
<v t="ekr.20230509052845.1170"><vh>Optional.__from_gpu__</vh></v>
<v t="ekr.20230509052845.1171"><vh>Optional.__from_gpu_new__</vh></v>
</v>
<v t="ekr.20230509052845.1172"><vh>class __internal__</vh>
<v t="ekr.20230509052845.1173"><vh>__internal__.class_to_gpu</vh></v>
<v t="ekr.20230509052845.1174"><vh>__internal__.class_from_gpu</vh></v>
<v t="ekr.20230509052845.1175"><vh>__internal__.class_from_gpu_new</vh></v>
</v>
<v t="ekr.20230509052845.1176"><vh>@par(gpu=True) support</vh></v>
<v t="ekr.20230509052845.1177"><vh>_gpu_thread_x</vh></v>
<v t="ekr.20230509052845.1178"><vh>_gpu_block_x</vh></v>
<v t="ekr.20230509052845.1179"><vh>_gpu_block_dim_x</vh></v>
<v t="ekr.20230509052845.1180"><vh>_gpu_loop_outline_template</vh>
<v t="ekr.20230509052845.1181"><vh>_loop_step</vh></v>
<v t="ekr.20230509052845.1182"><vh>_kernel_stub</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1183"><vh>@@clean gzip.codon</vh></v>
<v t="ekr.20230509052845.1184"><vh>@@clean heapq.codon</vh>
<v t="ekr.20230509052845.1185"><vh>_siftdown</vh></v>
<v t="ekr.20230509052845.1186"><vh>_siftup</vh></v>
<v t="ekr.20230509052845.1187"><vh>_siftdown_max</vh></v>
<v t="ekr.20230509052845.1188"><vh>_siftup_max</vh></v>
<v t="ekr.20230509052845.1189"><vh>heappush</vh></v>
<v t="ekr.20230509052845.1190"><vh>heappop</vh></v>
<v t="ekr.20230509052845.1191"><vh>heapreplace</vh></v>
<v t="ekr.20230509052845.1192"><vh>heappushpop</vh></v>
<v t="ekr.20230509052845.1193"><vh>heapify</vh></v>
<v t="ekr.20230509052845.1194"><vh>_heappop_max</vh></v>
<v t="ekr.20230509052845.1195"><vh>_heapreplace_max</vh></v>
<v t="ekr.20230509052845.1196"><vh>_heapify_max</vh></v>
<v t="ekr.20230509052845.1197"><vh>nsmallest</vh></v>
<v t="ekr.20230509052845.1198"><vh>nlargest</vh></v>
<v t="ekr.20230509052845.1199"><vh>class _MergeItem</vh>
<v t="ekr.20230509052845.1200"><vh>_MergeItem.__lt__</vh></v>
</v>
<v t="ekr.20230509052845.1201"><vh>merge</vh>
<v t="ekr.20230509052845.1202"><vh>_heapify</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1203"><vh>@@clean itertools.codon</vh>
<v t="ekr.20230509052845.1204"><vh>count</vh></v>
<v t="ekr.20230509052845.1205"><vh>cycle</vh></v>
<v t="ekr.20230509052845.1206"><vh>repeat</vh></v>
<v t="ekr.20230509052845.1207"><vh>Iterators terminating on the shortest input sequence</vh></v>
<v t="ekr.20230509052845.1208"><vh>accumulate</vh></v>
<v t="ekr.20230509052845.1209"><vh>accumulate</vh></v>
<v t="ekr.20230509052845.1210"><vh>class chain</vh>
<v t="ekr.20230509052845.1211"><vh>chain.__new__</vh></v>
<v t="ekr.20230509052845.1212"><vh>chain.from_iterable</vh></v>
</v>
<v t="ekr.20230509052845.1213"><vh>compress</vh></v>
<v t="ekr.20230509052845.1214"><vh>dropwhile</vh></v>
<v t="ekr.20230509052845.1215"><vh>filterfalse</vh></v>
<v t="ekr.20230509052845.1216"><vh>groupby</vh></v>
<v t="ekr.20230509052845.1217"><vh>islice</vh></v>
<v t="ekr.20230509052845.1218"><vh>islice</vh></v>
<v t="ekr.20230509052845.1219"><vh>starmap</vh></v>
<v t="ekr.20230509052845.1220"><vh>takewhile</vh></v>
<v t="ekr.20230509052845.1221"><vh>tee</vh>
<v t="ekr.20230509052845.1222"><vh>gen</vh></v>
</v>
<v t="ekr.20230509052845.1223"><vh>zip_longest</vh></v>
<v t="ekr.20230509052845.1224"><vh>zip_longest</vh>
<v t="ekr.20230509052845.1225"><vh>get_next</vh></v>
</v>
<v t="ekr.20230509052845.1226"><vh>Combinatoric iterators</vh></v>
<v t="ekr.20230509052845.1227"><vh>combinations</vh>
<v t="ekr.20230509052845.1228"><vh>combinations_helper</vh></v>
</v>
<v t="ekr.20230509052845.1229"><vh>combinations_with_replacement</vh>
<v t="ekr.20230509052845.1230"><vh>combinations_with_replacement_helper</vh></v>
</v>
<v t="ekr.20230509052845.1231"><vh>permutations</vh>
<v t="ekr.20230509052845.1232"><vh>permutations_helper</vh></v>
</v>
<v t="ekr.20230509052845.1233"><vh>product</vh></v>
<v t="ekr.20230509052845.1234"><vh>product</vh></v>
</v>
<v t="ekr.20230509052845.1235"><vh>@@clean math.codon</vh>
<v t="ekr.20230509052845.1236"><vh>_inf</vh></v>
<v t="ekr.20230509052845.1237"><vh>_nan</vh></v>
<v t="ekr.20230509052845.1238"><vh>e = 2.7182818284590452354</vh></v>
<v t="ekr.20230509052845.1239"><vh>factorial</vh></v>
<v t="ekr.20230509052845.1240"><vh>isnan</vh>
<v t="ekr.20230509052845.1241"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1242"><vh>isinf</vh>
<v t="ekr.20230509052845.1243"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1244"><vh>isfinite</vh></v>
<v t="ekr.20230509052845.1245"><vh>_check1</vh></v>
<v t="ekr.20230509052845.1246"><vh>_check2</vh></v>
<v t="ekr.20230509052845.1247"><vh>ceil</vh>
<v t="ekr.20230509052845.1248"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1249"><vh>floor</vh>
<v t="ekr.20230509052845.1250"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1251"><vh>fabs</vh>
<v t="ekr.20230509052845.1252"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1253"><vh>fmod</vh>
<v t="ekr.20230509052845.1254"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1255"><vh>exp</vh>
<v t="ekr.20230509052845.1256"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1257"><vh>expm1</vh></v>
<v t="ekr.20230509052845.1258"><vh>ldexp</vh></v>
<v t="ekr.20230509052845.1259"><vh>log</vh>
<v t="ekr.20230509052845.1260"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1261"><vh>log2</vh>
<v t="ekr.20230509052845.1262"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1263"><vh>log10</vh>
<v t="ekr.20230509052845.1264"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1265"><vh>degrees</vh></v>
<v t="ekr.20230509052845.1266"><vh>radians</vh></v>
<v t="ekr.20230509052845.1267"><vh>sqrt</vh>
<v t="ekr.20230509052845.1268"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1269"><vh>pow</vh>
<v t="ekr.20230509052845.1270"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1271"><vh>acos</vh></v>
<v t="ekr.20230509052845.1272"><vh>asin</vh></v>
<v t="ekr.20230509052845.1273"><vh>atan</vh></v>
<v t="ekr.20230509052845.1274"><vh>atan2</vh></v>
<v t="ekr.20230509052845.1275"><vh>cos</vh>
<v t="ekr.20230509052845.1276"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1277"><vh>sin</vh>
<v t="ekr.20230509052845.1278"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1279"><vh>hypot</vh></v>
<v t="ekr.20230509052845.1280"><vh>tan</vh></v>
<v t="ekr.20230509052845.1281"><vh>cosh</vh></v>
<v t="ekr.20230509052845.1282"><vh>sinh</vh></v>
<v t="ekr.20230509052845.1283"><vh>tanh</vh></v>
<v t="ekr.20230509052845.1284"><vh>acosh</vh></v>
<v t="ekr.20230509052845.1285"><vh>asinh</vh></v>
<v t="ekr.20230509052845.1286"><vh>atanh</vh></v>
<v t="ekr.20230509052845.1287"><vh>copysign</vh>
<v t="ekr.20230509052845.1288"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1289"><vh>log1p</vh></v>
<v t="ekr.20230509052845.1290"><vh>trunc</vh>
<v t="ekr.20230509052845.1291"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1292"><vh>erf</vh></v>
<v t="ekr.20230509052845.1293"><vh>erfc</vh></v>
<v t="ekr.20230509052845.1294"><vh>gamma</vh></v>
<v t="ekr.20230509052845.1295"><vh>lgamma</vh></v>
<v t="ekr.20230509052845.1296"><vh>remainder</vh></v>
<v t="ekr.20230509052845.1297"><vh>gcd</vh></v>
<v t="ekr.20230509052845.1298"><vh>frexp</vh></v>
<v t="ekr.20230509052845.1299"><vh>modf</vh></v>
<v t="ekr.20230509052845.1300"><vh>isclose</vh></v>
<v t="ekr.20230509052845.1301"><vh>fsum</vh>
<v t="ekr.20230509052845.1302"><vh>_fsum_realloc</vh></v>
</v>
<v t="ekr.20230509052845.1303"><vh>32-bit float ops</vh></v>
<v t="ekr.20230509052845.1304"><vh>isnan</vh>
<v t="ekr.20230509052845.1305"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1306"><vh>isinf</vh>
<v t="ekr.20230509052845.1307"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1308"><vh>isfinite</vh></v>
<v t="ekr.20230509052845.1309"><vh>ceil</vh>
<v t="ekr.20230509052845.1310"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1311"><vh>floor</vh>
<v t="ekr.20230509052845.1312"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1313"><vh>fabs</vh>
<v t="ekr.20230509052845.1314"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1315"><vh>fmod</vh>
<v t="ekr.20230509052845.1316"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1317"><vh>exp</vh>
<v t="ekr.20230509052845.1318"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1319"><vh>expm1</vh></v>
<v t="ekr.20230509052845.1320"><vh>ldexp</vh></v>
<v t="ekr.20230509052845.1321"><vh>log</vh>
<v t="ekr.20230509052845.1322"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1323"><vh>log2</vh>
<v t="ekr.20230509052845.1324"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1325"><vh>log10</vh>
<v t="ekr.20230509052845.1326"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1327"><vh>degrees</vh></v>
<v t="ekr.20230509052845.1328"><vh>radians</vh></v>
<v t="ekr.20230509052845.1329"><vh>sqrt</vh>
<v t="ekr.20230509052845.1330"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1331"><vh>pow</vh>
<v t="ekr.20230509052845.1332"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1333"><vh>acos</vh></v>
<v t="ekr.20230509052845.1334"><vh>asin</vh></v>
<v t="ekr.20230509052845.1335"><vh>atan</vh></v>
<v t="ekr.20230509052845.1336"><vh>atan2</vh></v>
<v t="ekr.20230509052845.1337"><vh>cos</vh>
<v t="ekr.20230509052845.1338"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1339"><vh>sin</vh>
<v t="ekr.20230509052845.1340"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1341"><vh>hypot</vh></v>
<v t="ekr.20230509052845.1342"><vh>tan</vh></v>
<v t="ekr.20230509052845.1343"><vh>cosh</vh></v>
<v t="ekr.20230509052845.1344"><vh>sinh</vh></v>
<v t="ekr.20230509052845.1345"><vh>tanh</vh></v>
<v t="ekr.20230509052845.1346"><vh>acosh</vh></v>
<v t="ekr.20230509052845.1347"><vh>asinh</vh></v>
<v t="ekr.20230509052845.1348"><vh>atanh</vh></v>
<v t="ekr.20230509052845.1349"><vh>copysign</vh>
<v t="ekr.20230509052845.1350"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1351"><vh>log1p</vh></v>
<v t="ekr.20230509052845.1352"><vh>trunc</vh>
<v t="ekr.20230509052845.1353"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.1354"><vh>erf</vh></v>
<v t="ekr.20230509052845.1355"><vh>erfc</vh></v>
<v t="ekr.20230509052845.1356"><vh>gamma</vh></v>
<v t="ekr.20230509052845.1357"><vh>lgamma</vh></v>
<v t="ekr.20230509052845.1358"><vh>remainder</vh></v>
<v t="ekr.20230509052845.1359"><vh>gcd</vh></v>
<v t="ekr.20230509052845.1360"><vh>frexp</vh></v>
<v t="ekr.20230509052845.1361"><vh>modf</vh></v>
<v t="ekr.20230509052845.1362"><vh>isclose</vh></v>
</v>
<v t="ekr.20230509052845.1363"><vh>@@clean openmp.codon</vh>
<v t="ekr.20230509052845.1364"><vh>class Lock</vh>
<v t="ekr.20230509052845.1365"><vh>Lock.__new__</vh></v>
</v>
<v t="ekr.20230509052845.1366"><vh>class Ident</vh>
<v t="ekr.20230509052845.1367"><vh>Ident.__new__</vh></v>
</v>
<v t="ekr.20230509052845.1368"><vh>class LRData</vh></v>
<v t="ekr.20230509052845.1369"><vh>class Task</vh></v>
<v t="ekr.20230509052845.1370"><vh>class TaskWithPrivates</vh></v>
<v t="ekr.20230509052845.1371"><vh>class TaskReductionInput</vh>
<v t="ekr.20230509052845.1372"><vh>TaskReductionInput.__new__</vh></v>
</v>
<v t="ekr.20230509052845.1373"><vh>class TaskReductionInputArray</vh></v>
<v t="ekr.20230509052845.1374"><vh>_DEFAULT_IDENT = Ident()</vh></v>
<v t="ekr.20230509052845.1375"><vh>_default_loc</vh></v>
<v t="ekr.20230509052845.1376"><vh>_default_loc()</vh></v>
<v t="ekr.20230509052845.1377"><vh>_static_loop_loc</vh></v>
<v t="ekr.20230509052845.1378"><vh>_static_loop_loc()</vh></v>
<v t="ekr.20230509052845.1379"><vh>_reduction_loc</vh></v>
<v t="ekr.20230509052845.1380"><vh>_reduction_loc()</vh></v>
<v t="ekr.20230509052845.1381"><vh>_critical_begin</vh></v>
<v t="ekr.20230509052845.1382"><vh>_critical_end</vh></v>
<v t="ekr.20230509052845.1383"><vh>_single_begin</vh></v>
<v t="ekr.20230509052845.1384"><vh>_single_end</vh></v>
<v t="ekr.20230509052845.1385"><vh>_master_begin</vh></v>
<v t="ekr.20230509052845.1386"><vh>_master_end</vh></v>
<v t="ekr.20230509052845.1387"><vh>_ordered_begin</vh></v>
<v t="ekr.20230509052845.1388"><vh>_ordered_end</vh></v>
<v t="ekr.20230509052845.1389"><vh>_taskwait</vh></v>
<v t="ekr.20230509052845.1390"><vh>_taskgroup_begin</vh></v>
<v t="ekr.20230509052845.1391"><vh>_taskgroup_end</vh></v>
<v t="ekr.20230509052845.1392"><vh>_task_alloc_size</vh></v>
<v t="ekr.20230509052845.1393"><vh>_task_alloc</vh></v>
<v t="ekr.20230509052845.1394"><vh>_task_run</vh></v>
<v t="ekr.20230509052845.1395"><vh>_barrier</vh></v>
<v t="ekr.20230509052845.1396"><vh>_flush</vh></v>
<v t="ekr.20230509052845.1397"><vh>flush</vh></v>
<v t="ekr.20230509052845.1398"><vh>_static_init</vh></v>
<v t="ekr.20230509052845.1399"><vh>_static_fini</vh></v>
<v t="ekr.20230509052845.1400"><vh>_dynamic_init</vh></v>
<v t="ekr.20230509052845.1401"><vh>_dynamic_next</vh></v>
<v t="ekr.20230509052845.1402"><vh>_dynamic_fini</vh></v>
<v t="ekr.20230509052845.1403"><vh>_reduce</vh></v>
<v t="ekr.20230509052845.1404"><vh>_end_reduce</vh></v>
<v t="ekr.20230509052845.1405"><vh>_reduce_nowait</vh></v>
<v t="ekr.20230509052845.1406"><vh>_end_reduce_nowait</vh></v>
<v t="ekr.20230509052845.1407"><vh>_taskred_init</vh></v>
<v t="ekr.20230509052845.1408"><vh>_taskred_fini</vh></v>
<v t="ekr.20230509052845.1409"><vh>_taskred_data</vh></v>
<v t="ekr.20230509052845.1410"><vh>_fork_call</vh></v>
<v t="ekr.20230509052845.1411"><vh>_static_loop_outline_template</vh>
<v t="ekr.20230509052845.1412"><vh>_loop_step</vh></v>
<v t="ekr.20230509052845.1413"><vh>_loop_loc_and_gtid</vh></v>
<v t="ekr.20230509052845.1414"><vh>_loop_body_stub</vh></v>
<v t="ekr.20230509052845.1415"><vh>_loop_schedule</vh></v>
<v t="ekr.20230509052845.1416"><vh>_loop_shared_updates</vh></v>
<v t="ekr.20230509052845.1417"><vh>_loop_reductions</vh></v>
</v>
<v t="ekr.20230509052845.1418"><vh>_static_chunked_loop_outline_template</vh>
<v t="ekr.20230509052845.1419"><vh>_loop_step</vh></v>
<v t="ekr.20230509052845.1420"><vh>_loop_loc_and_gtid</vh></v>
<v t="ekr.20230509052845.1421"><vh>_loop_body_stub</vh></v>
<v t="ekr.20230509052845.1422"><vh>_loop_schedule</vh></v>
<v t="ekr.20230509052845.1423"><vh>_loop_shared_updates</vh></v>
<v t="ekr.20230509052845.1424"><vh>_loop_reductions</vh></v>
</v>
<v t="ekr.20230509052845.1425"><vh>_dynamic_loop_outline_template</vh>
<v t="ekr.20230509052845.1426"><vh>_loop_step</vh></v>
<v t="ekr.20230509052845.1427"><vh>_loop_loc_and_gtid</vh></v>
<v t="ekr.20230509052845.1428"><vh>_loop_body_stub</vh></v>
<v t="ekr.20230509052845.1429"><vh>_loop_schedule</vh></v>
<v t="ekr.20230509052845.1430"><vh>_loop_shared_updates</vh></v>
<v t="ekr.20230509052845.1431"><vh>_loop_reductions</vh></v>
<v t="ekr.20230509052845.1432"><vh>_loop_ordered</vh></v>
</v>
<v t="ekr.20230509052845.1433"><vh>_spawn_and_run_task</vh></v>
<v t="ekr.20230509052845.1434"><vh>_task_loop_outline_template</vh>
<v t="ekr.20230509052845.1435"><vh>_routine_stub</vh></v>
<v t="ekr.20230509052845.1436"><vh>_loop_loc_and_gtid</vh></v>
<v t="ekr.20230509052845.1437"><vh>_fix_privates_and_shareds</vh></v>
<v t="ekr.20230509052845.1438"><vh>_taskred_setup</vh></v>
<v t="ekr.20230509052845.1439"><vh>_taskred_finish</vh></v>
<v t="ekr.20230509052845.1440"><vh>_loop_reductions</vh></v>
</v>
<v t="ekr.20230509052845.1441"><vh>get_num_threads</vh></v>
<v t="ekr.20230509052845.1442"><vh>get_thread_num</vh></v>
<v t="ekr.20230509052845.1443"><vh>get_max_threads</vh></v>
<v t="ekr.20230509052845.1444"><vh>get_num_procs</vh></v>
<v t="ekr.20230509052845.1445"><vh>set_num_threads</vh></v>
<v t="ekr.20230509052845.1446"><vh>in_parallel</vh></v>
<v t="ekr.20230509052845.1447"><vh>set_dynamic</vh></v>
<v t="ekr.20230509052845.1448"><vh>get_dynamic</vh></v>
<v t="ekr.20230509052845.1449"><vh>get_cancellation</vh></v>
<v t="ekr.20230509052845.1450"><vh>set_schedule</vh></v>
<v t="ekr.20230509052845.1451"><vh>get_schedule</vh></v>
<v t="ekr.20230509052845.1452"><vh>get_thread_limit</vh></v>
<v t="ekr.20230509052845.1453"><vh>set_max_active_levels</vh></v>
<v t="ekr.20230509052845.1454"><vh>get_max_active_levels</vh></v>
<v t="ekr.20230509052845.1455"><vh>get_level</vh></v>
<v t="ekr.20230509052845.1456"><vh>get_ancestor_thread_num</vh></v>
<v t="ekr.20230509052845.1457"><vh>get_team_size</vh></v>
<v t="ekr.20230509052845.1458"><vh>get_active_level</vh></v>
<v t="ekr.20230509052845.1459"><vh>in_final</vh></v>
<v t="ekr.20230509052845.1460"><vh>get_proc_bind</vh></v>
<v t="ekr.20230509052845.1461"><vh>set_default_device</vh></v>
<v t="ekr.20230509052845.1462"><vh>get_default_device</vh></v>
<v t="ekr.20230509052845.1463"><vh>get_num_devices</vh></v>
<v t="ekr.20230509052845.1464"><vh>get_num_teams</vh></v>
<v t="ekr.20230509052845.1465"><vh>get_team_num</vh></v>
<v t="ekr.20230509052845.1466"><vh>is_initial_device</vh></v>
<v t="ekr.20230509052845.1467"><vh>get_wtime</vh></v>
<v t="ekr.20230509052845.1468"><vh>get_wtick</vh></v>
<v t="ekr.20230509052845.1469"><vh>single</vh>
<v t="ekr.20230509052845.1470"><vh>_wrapper</vh></v>
</v>
<v t="ekr.20230509052845.1471"><vh>master</vh>
<v t="ekr.20230509052845.1472"><vh>_wrapper</vh></v>
</v>
<v t="ekr.20230509052845.1473"><vh>ordered</vh>
<v t="ekr.20230509052845.1474"><vh>_wrapper</vh></v>
</v>
<v t="ekr.20230509052845.1475"><vh>_default_lock = Lock()</vh></v>
<v t="ekr.20230509052845.1476"><vh>critical</vh>
<v t="ekr.20230509052845.1477"><vh>_wrapper</vh></v>
</v>
<v t="ekr.20230509052845.1478"><vh>_push_num_threads</vh></v>
<v t="ekr.20230509052845.1479"><vh>_atomic_int_add</vh></v>
<v t="ekr.20230509052845.1480"><vh>_atomic_int_mul</vh></v>
<v t="ekr.20230509052845.1481"><vh>_atomic_int_and</vh></v>
<v t="ekr.20230509052845.1482"><vh>_atomic_int_or</vh></v>
<v t="ekr.20230509052845.1483"><vh>_atomic_int_xor</vh></v>
<v t="ekr.20230509052845.1484"><vh>_atomic_int_min</vh></v>
<v t="ekr.20230509052845.1485"><vh>_atomic_int_max</vh></v>
<v t="ekr.20230509052845.1486"><vh>_atomic_float_add</vh></v>
<v t="ekr.20230509052845.1487"><vh>_atomic_float_mul</vh></v>
<v t="ekr.20230509052845.1488"><vh>_atomic_float_min</vh></v>
<v t="ekr.20230509052845.1489"><vh>_atomic_float_max</vh></v>
<v t="ekr.20230509052845.1490"><vh>_atomic_float32_add</vh></v>
<v t="ekr.20230509052845.1491"><vh>_atomic_float32_mul</vh></v>
<v t="ekr.20230509052845.1492"><vh>_atomic_float32_min</vh></v>
<v t="ekr.20230509052845.1493"><vh>_atomic_float32_max</vh></v>
<v t="ekr.20230509052845.1494"><vh>_range_len</vh></v>
<v t="ekr.20230509052845.1495"><vh>for_par</vh></v>
</v>
<v t="ekr.20230509052845.1496"><vh>@@clean operator.codon</vh>
<v t="ekr.20230509052845.1497"><vh>not_</vh></v>
<v t="ekr.20230509052845.1498"><vh>truth</vh></v>
<v t="ekr.20230509052845.1499"><vh>is_</vh></v>
<v t="ekr.20230509052845.1500"><vh>is_not</vh></v>
<v t="ekr.20230509052845.1501"><vh>abs</vh></v>
<v t="ekr.20230509052845.1502"><vh>__abs__ = abs</vh></v>
<v t="ekr.20230509052845.1503"><vh>add</vh></v>
<v t="ekr.20230509052845.1504"><vh>__add__ = add</vh></v>
<v t="ekr.20230509052845.1505"><vh>and_</vh></v>
<v t="ekr.20230509052845.1506"><vh>__and__ = and_</vh></v>
<v t="ekr.20230509052845.1507"><vh>floordiv</vh></v>
<v t="ekr.20230509052845.1508"><vh>__floordiv__ = floordiv</vh></v>
<v t="ekr.20230509052845.1509"><vh>index</vh></v>
<v t="ekr.20230509052845.1510"><vh>__index__ = index</vh></v>
<v t="ekr.20230509052845.1511"><vh>inv</vh></v>
<v t="ekr.20230509052845.1512"><vh>invert = inv</vh></v>
<v t="ekr.20230509052845.1513"><vh>lshift</vh></v>
<v t="ekr.20230509052845.1514"><vh>__lshift__ = lshift</vh></v>
<v t="ekr.20230509052845.1515"><vh>mod</vh></v>
<v t="ekr.20230509052845.1516"><vh>__mod__ = mod</vh></v>
<v t="ekr.20230509052845.1517"><vh>mul</vh></v>
<v t="ekr.20230509052845.1518"><vh>__mul__ = mul</vh></v>
<v t="ekr.20230509052845.1519"><vh>matmul</vh></v>
<v t="ekr.20230509052845.1520"><vh>__matmul__ = matmul</vh></v>
<v t="ekr.20230509052845.1521"><vh>neg</vh></v>
<v t="ekr.20230509052845.1522"><vh>__neg__ = neg</vh></v>
<v t="ekr.20230509052845.1523"><vh>or_</vh></v>
<v t="ekr.20230509052845.1524"><vh>__or__ = or_</vh></v>
<v t="ekr.20230509052845.1525"><vh>pos</vh></v>
<v t="ekr.20230509052845.1526"><vh>__pos__ = pos</vh></v>
<v t="ekr.20230509052845.1527"><vh>pow</vh></v>
<v t="ekr.20230509052845.1528"><vh>__pow__ = pow</vh></v>
<v t="ekr.20230509052845.1529"><vh>rshift</vh></v>
<v t="ekr.20230509052845.1530"><vh>__rshift__ = rshift</vh></v>
<v t="ekr.20230509052845.1531"><vh>sub</vh></v>
<v t="ekr.20230509052845.1532"><vh>__sub__ = sub</vh></v>
<v t="ekr.20230509052845.1533"><vh>truediv</vh></v>
<v t="ekr.20230509052845.1534"><vh>__truediv__ = truediv</vh></v>
<v t="ekr.20230509052845.1535"><vh>xor</vh></v>
<v t="ekr.20230509052845.1536"><vh>__xor__ = xor</vh></v>
<v t="ekr.20230509052845.1537"><vh>concat</vh></v>
<v t="ekr.20230509052845.1538"><vh>__concat__ = concat</vh></v>
<v t="ekr.20230509052845.1539"><vh>contains</vh></v>
<v t="ekr.20230509052845.1540"><vh>__contains__ = contains</vh></v>
<v t="ekr.20230509052845.1541"><vh>countOf</vh></v>
<v t="ekr.20230509052845.1542"><vh>delitem</vh></v>
<v t="ekr.20230509052845.1543"><vh>__delitem__ = delitem</vh></v>
<v t="ekr.20230509052845.1544"><vh>getitem</vh></v>
<v t="ekr.20230509052845.1545"><vh>__getitem__ = getitem</vh></v>
<v t="ekr.20230509052845.1546"><vh>indexOf</vh></v>
<v t="ekr.20230509052845.1547"><vh>setitem</vh></v>
<v t="ekr.20230509052845.1548"><vh>__setitem__ = setitem</vh></v>
<v t="ekr.20230509052845.1549"><vh>length_hint</vh></v>
<v t="ekr.20230509052845.1550"><vh>attrgetter</vh></v>
<v t="ekr.20230509052845.1551"><vh>itemgetter</vh></v>
<v t="ekr.20230509052845.1552"><vh>methodcaller</vh></v>
<v t="ekr.20230509052845.1553"><vh>iadd</vh></v>
<v t="ekr.20230509052845.1554"><vh>__iadd__ = iadd</vh></v>
<v t="ekr.20230509052845.1555"><vh>iand</vh></v>
<v t="ekr.20230509052845.1556"><vh>__iand__ = iand</vh></v>
<v t="ekr.20230509052845.1557"><vh>iconcat</vh></v>
<v t="ekr.20230509052845.1558"><vh>__iconcat__ = iconcat</vh></v>
<v t="ekr.20230509052845.1559"><vh>ifloordiv</vh></v>
<v t="ekr.20230509052845.1560"><vh>__ifloordiv__ = ifloordiv</vh></v>
<v t="ekr.20230509052845.1561"><vh>ilshift</vh></v>
<v t="ekr.20230509052845.1562"><vh>__ilshift__ = ilshift</vh></v>
<v t="ekr.20230509052845.1563"><vh>imod</vh></v>
<v t="ekr.20230509052845.1564"><vh>__imod__ = imod</vh></v>
<v t="ekr.20230509052845.1565"><vh>imul</vh></v>
<v t="ekr.20230509052845.1566"><vh>__imul__ = imul</vh></v>
<v t="ekr.20230509052845.1567"><vh>imatmul</vh></v>
<v t="ekr.20230509052845.1568"><vh>__imatmul__ = imatmul</vh></v>
<v t="ekr.20230509052845.1569"><vh>ior</vh></v>
<v t="ekr.20230509052845.1570"><vh>__ior__ = ior</vh></v>
<v t="ekr.20230509052845.1571"><vh>ipow</vh></v>
<v t="ekr.20230509052845.1572"><vh>__ipow__ = ipow</vh></v>
<v t="ekr.20230509052845.1573"><vh>irshift</vh></v>
<v t="ekr.20230509052845.1574"><vh>__irshift__ = irshift</vh></v>
<v t="ekr.20230509052845.1575"><vh>isub</vh></v>
<v t="ekr.20230509052845.1576"><vh>__isub__ = isub</vh></v>
<v t="ekr.20230509052845.1577"><vh>itruediv</vh></v>
<v t="ekr.20230509052845.1578"><vh>__itruediv__ = itruediv</vh></v>
<v t="ekr.20230509052845.1579"><vh>ixor</vh></v>
</v>
<v t="ekr.20230509052845.1580"><vh>@@clean pickle.codon</vh>
<v t="ekr.20230509052845.1581"><vh>pickle</vh></v>
<v t="ekr.20230509052845.1582"><vh>unpickle</vh></v>
<v t="ekr.20230509052845.1583"><vh>dump</vh></v>
<v t="ekr.20230509052845.1584"><vh>load</vh></v>
<v t="ekr.20230509052845.1585"><vh>_write_raw</vh></v>
<v t="ekr.20230509052845.1586"><vh>_read_raw</vh></v>
<v t="ekr.20230509052845.1587"><vh>_write</vh></v>
<v t="ekr.20230509052845.1588"><vh>_read</vh></v>
<v t="ekr.20230509052845.1589"><vh>Extend core types to allow pickling</vh></v>
<v t="ekr.20230509052845.1590"><vh>class int</vh></v>
<v t="ekr.20230509052845.1591"><vh>class Int</vh></v>
<v t="ekr.20230509052845.1592"><vh>class UInt</vh></v>
<v t="ekr.20230509052845.1593"><vh>class float</vh></v>
<v t="ekr.20230509052845.1594"><vh>class float32</vh></v>
<v t="ekr.20230509052845.1595"><vh>class bool</vh></v>
<v t="ekr.20230509052845.1596"><vh>class byte</vh></v>
<v t="ekr.20230509052845.1597"><vh>class str</vh>
<v t="ekr.20230509052845.1598"><vh>str.__pickle__</vh></v>
<v t="ekr.20230509052845.1599"><vh>str.__unpickle__</vh></v>
</v>
<v t="ekr.20230509052845.1600"><vh>class List</vh>
<v t="ekr.20230509052845.1601"><vh>List.__pickle__</vh></v>
<v t="ekr.20230509052845.1602"><vh>List.__unpickle__</vh></v>
</v>
<v t="ekr.20230509052845.1603"><vh>class DynamicTuple</vh>
<v t="ekr.20230509052845.1604"><vh>DynamicTuple.__pickle__</vh></v>
<v t="ekr.20230509052845.1605"><vh>DynamicTuple.__unpickle__</vh></v>
</v>
<v t="ekr.20230509052845.1606"><vh>class Dict</vh>
<v t="ekr.20230509052845.1607"><vh>Dict.__pickle__</vh></v>
<v t="ekr.20230509052845.1608"><vh>Dict.__unpickle__</vh></v>
</v>
<v t="ekr.20230509052845.1609"><vh>class Set</vh>
<v t="ekr.20230509052845.1610"><vh>Set.__pickle__</vh></v>
<v t="ekr.20230509052845.1611"><vh>Set.__unpickle__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1612"><vh>@@clean python.codon</vh></v>
<v t="ekr.20230509052845.1613"><vh>@@clean random.codon</vh>
<v t="ekr.20230509052845.1614"><vh>class RandomGenerator</vh>
<v t="ekr.20230509052845.1615"><vh>RandomGenerator.__new__</vh></v>
<v t="ekr.20230509052845.1616"><vh>RandomGenerator.index</vh></v>
<v t="ekr.20230509052845.1617"><vh>RandomGenerator.state</vh></v>
<v t="ekr.20230509052845.1618"><vh>RandomGenerator.getstate</vh></v>
<v t="ekr.20230509052845.1619"><vh>RandomGenerator.setstate</vh></v>
<v t="ekr.20230509052845.1620"><vh>RandomGenerator.genrand_int32</vh></v>
<v t="ekr.20230509052845.1621"><vh>RandomGenerator.genrand_res53</vh></v>
<v t="ekr.20230509052845.1622"><vh>RandomGenerator.random</vh></v>
<v t="ekr.20230509052845.1623"><vh>RandomGenerator.init_u32</vh></v>
<v t="ekr.20230509052845.1624"><vh>RandomGenerator.init_array</vh></v>
<v t="ekr.20230509052845.1625"><vh>RandomGenerator.init_int</vh></v>
<v t="ekr.20230509052845.1626"><vh>RandomGenerator.random_seed_time_pid</vh></v>
<v t="ekr.20230509052845.1627"><vh>RandomGenerator.seed</vh></v>
<v t="ekr.20230509052845.1628"><vh>RandomGenerator.seed</vh></v>
</v>
<v t="ekr.20230509052845.1629"><vh>class Random</vh>
<v t="ekr.20230509052845.1630"><vh>Random.__init__</vh></v>
<v t="ekr.20230509052845.1631"><vh>Random.seed</vh></v>
<v t="ekr.20230509052845.1632"><vh>Random.getstate</vh></v>
<v t="ekr.20230509052845.1633"><vh>Random.setstate</vh></v>
<v t="ekr.20230509052845.1634"><vh>Random.getrandbits</vh></v>
<v t="ekr.20230509052845.1635"><vh>Random.bit_length</vh></v>
<v t="ekr.20230509052845.1636"><vh>Random._randbelow_with_getrandbits</vh></v>
<v t="ekr.20230509052845.1637"><vh>Random.randrange</vh></v>
<v t="ekr.20230509052845.1638"><vh>Random.randint</vh></v>
<v t="ekr.20230509052845.1639"><vh>Random.random</vh></v>
<v t="ekr.20230509052845.1640"><vh>Random.choice</vh></v>
<v t="ekr.20230509052845.1641"><vh>Random.shuffle</vh></v>
<v t="ekr.20230509052845.1642"><vh>Random.uniform</vh></v>
<v t="ekr.20230509052845.1643"><vh>Random.triangular</vh></v>
<v t="ekr.20230509052845.1644"><vh>Random.gammavariate</vh></v>
<v t="ekr.20230509052845.1645"><vh>Random.betavariate</vh></v>
<v t="ekr.20230509052845.1646"><vh>Random.expovariate</vh></v>
<v t="ekr.20230509052845.1647"><vh>Random.gauss</vh></v>
<v t="ekr.20230509052845.1648"><vh>Random.paretovariate</vh></v>
<v t="ekr.20230509052845.1649"><vh>Random.weibullvariate</vh></v>
<v t="ekr.20230509052845.1650"><vh>Random.normalvariate</vh></v>
<v t="ekr.20230509052845.1651"><vh>Random.lognormvariate</vh></v>
<v t="ekr.20230509052845.1652"><vh>Random.vonmisesvariate</vh>
<v t="ekr.20230509052845.1653"><vh>Random._truediv_float_float</vh></v>
<v t="ekr.20230509052845.1654"><vh>Random._mod_float_float</vh></v>
</v>
<v t="ekr.20230509052845.1655"><vh>Random.sample</vh></v>
<v t="ekr.20230509052845.1656"><vh>Random.choices</vh></v>
</v>
<v t="ekr.20230509052845.1657"><vh>_rnd = Random()</vh></v>
<v t="ekr.20230509052845.1658"><vh>seed</vh></v>
<v t="ekr.20230509052845.1659"><vh>getrandbits</vh></v>
<v t="ekr.20230509052845.1660"><vh>randrange</vh></v>
<v t="ekr.20230509052845.1661"><vh>randint</vh></v>
<v t="ekr.20230509052845.1662"><vh>choice</vh></v>
<v t="ekr.20230509052845.1663"><vh>choices</vh></v>
<v t="ekr.20230509052845.1664"><vh>shuffle</vh></v>
<v t="ekr.20230509052845.1665"><vh>sample</vh></v>
<v t="ekr.20230509052845.1666"><vh>random</vh></v>
<v t="ekr.20230509052845.1667"><vh>uniform</vh></v>
<v t="ekr.20230509052845.1668"><vh>triangular</vh></v>
<v t="ekr.20230509052845.1669"><vh>betavariate</vh></v>
<v t="ekr.20230509052845.1670"><vh>expovariate</vh></v>
<v t="ekr.20230509052845.1671"><vh>gammavariate</vh></v>
<v t="ekr.20230509052845.1672"><vh>gauss</vh></v>
<v t="ekr.20230509052845.1673"><vh>lognormvariate</vh></v>
<v t="ekr.20230509052845.1674"><vh>normalvariate</vh></v>
<v t="ekr.20230509052845.1675"><vh>vonmisesvariate</vh></v>
<v t="ekr.20230509052845.1676"><vh>paretovariate</vh></v>
<v t="ekr.20230509052845.1677"><vh>weibullvariate</vh></v>
</v>
<v t="ekr.20230509052845.1678"><vh>@@clean re.codon</vh>
<v t="ekr.20230509052845.1679"><vh>class Span</vh></v>
<v t="ekr.20230509052845.1680"><vh>seq_re_match</vh></v>
<v t="ekr.20230509052845.1681"><vh>seq_re_match_one</vh></v>
<v t="ekr.20230509052845.1682"><vh>seq_re_pattern_groups</vh></v>
<v t="ekr.20230509052845.1683"><vh>seq_re_group_name_to_index</vh></v>
<v t="ekr.20230509052845.1684"><vh>seq_re_group_index_to_name</vh></v>
<v t="ekr.20230509052845.1685"><vh>seq_re_pattern_error</vh></v>
<v t="ekr.20230509052845.1686"><vh>seq_re_escape</vh></v>
<v t="ekr.20230509052845.1687"><vh>seq_re_purge</vh></v>
<v t="ekr.20230509052845.1688"><vh>seq_re_compile</vh></v>
<v t="ekr.20230509052845.1689"><vh>class error</vh>
<v t="ekr.20230509052845.1690"><vh>error.__init__</vh></v>
<v t="ekr.20230509052845.1691"><vh>error.msg</vh></v>
</v>
<v t="ekr.20230509052845.1692"><vh>class Pattern</vh></v>
<v t="ekr.20230509052845.1693"><vh>compile</vh></v>
<v t="ekr.20230509052845.1694"><vh>search</vh></v>
<v t="ekr.20230509052845.1695"><vh>match</vh></v>
<v t="ekr.20230509052845.1696"><vh>fullmatch</vh></v>
<v t="ekr.20230509052845.1697"><vh>finditer</vh></v>
<v t="ekr.20230509052845.1698"><vh>findall</vh></v>
<v t="ekr.20230509052845.1699"><vh>split</vh></v>
<v t="ekr.20230509052845.1700"><vh>sub</vh></v>
<v t="ekr.20230509052845.1701"><vh>subn</vh></v>
<v t="ekr.20230509052845.1702"><vh>escape</vh></v>
<v t="ekr.20230509052845.1703"><vh>purge</vh></v>
<v t="ekr.20230509052845.1704"><vh>class Match</vh>
<v t="ekr.20230509052845.1705"><vh>Match._get_group_int</vh></v>
<v t="ekr.20230509052845.1706"><vh>Match._get_group_str</vh></v>
<v t="ekr.20230509052845.1707"><vh>Match._get_group</vh></v>
<v t="ekr.20230509052845.1708"><vh>Match._span_match</vh></v>
<v t="ekr.20230509052845.1709"><vh>Match._get_match</vh></v>
<v t="ekr.20230509052845.1710"><vh>Match._group_multi</vh></v>
<v t="ekr.20230509052845.1711"><vh>Match.group</vh></v>
<v t="ekr.20230509052845.1712"><vh>Match.__getitem__</vh></v>
<v t="ekr.20230509052845.1713"><vh>Match.start</vh></v>
<v t="ekr.20230509052845.1714"><vh>Match.end</vh></v>
<v t="ekr.20230509052845.1715"><vh>Match.span</vh></v>
<v t="ekr.20230509052845.1716"><vh>Match._split</vh></v>
<v t="ekr.20230509052845.1717"><vh>Match._unescape</vh></v>
<v t="ekr.20230509052845.1718"><vh>Match.expand</vh></v>
<v t="ekr.20230509052845.1719"><vh>Match.lastindex</vh></v>
<v t="ekr.20230509052845.1720"><vh>Match.lastgroup</vh></v>
<v t="ekr.20230509052845.1721"><vh>Match.groups</vh></v>
<v t="ekr.20230509052845.1722"><vh>Match.groupdict</vh></v>
<v t="ekr.20230509052845.1723"><vh>Match.__copy__</vh></v>
<v t="ekr.20230509052845.1724"><vh>Match.__deepcopy__</vh></v>
<v t="ekr.20230509052845.1725"><vh>Match.__bool__</vh></v>
</v>
<v t="ekr.20230509052845.1726"><vh>class Pattern</vh>
<v t="ekr.20230509052845.1727"><vh>Pattern.groups</vh></v>
<v t="ekr.20230509052845.1728"><vh>Pattern.groupindex</vh></v>
<v t="ekr.20230509052845.1729"><vh>Pattern._match_one</vh></v>
<v t="ekr.20230509052845.1730"><vh>Pattern._match</vh></v>
<v t="ekr.20230509052845.1731"><vh>Pattern.search</vh></v>
<v t="ekr.20230509052845.1732"><vh>Pattern.match</vh></v>
<v t="ekr.20230509052845.1733"><vh>Pattern.fullmatch</vh></v>
<v t="ekr.20230509052845.1734"><vh>Pattern.finditer</vh></v>
<v t="ekr.20230509052845.1735"><vh>Pattern.findall</vh></v>
<v t="ekr.20230509052845.1736"><vh>Pattern._split</vh></v>
<v t="ekr.20230509052845.1737"><vh>Pattern.split</vh></v>
<v t="ekr.20230509052845.1738"><vh>Pattern._repl</vh></v>
<v t="ekr.20230509052845.1739"><vh>Pattern.subn</vh></v>
<v t="ekr.20230509052845.1740"><vh>Pattern.sub</vh></v>
<v t="ekr.20230509052845.1741"><vh>Pattern.__bool__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1742"><vh>@@clean sortedlist.codon</vh>
<v t="ekr.20230509052845.1743"><vh>class SortedList</vh>
<v t="ekr.20230509052845.1744"><vh>SortedList.__init__</vh></v>
<v t="ekr.20230509052845.1745"><vh>SortedList.clear</vh></v>
<v t="ekr.20230509052845.1746"><vh>SortedList.left</vh></v>
<v t="ekr.20230509052845.1747"><vh>SortedList.add</vh></v>
<v t="ekr.20230509052845.1748"><vh>SortedList._expand</vh></v>
<v t="ekr.20230509052845.1749"><vh>SortedList._delete</vh></v>
<v t="ekr.20230509052845.1750"><vh>SortedList.__iter__</vh></v>
<v t="ekr.20230509052845.1751"><vh>SortedList.__len__</vh></v>
<v t="ekr.20230509052845.1752"><vh>SortedList.__bool__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1753"><vh>@@clean statistics.codon</vh>
<v t="ekr.20230509052845.1754"><vh>class StatisticsError</vh></v>
<v t="ekr.20230509052845.1755"><vh>median</vh></v>
<v t="ekr.20230509052845.1756"><vh>median_low</vh></v>
<v t="ekr.20230509052845.1757"><vh>median_high</vh></v>
<v t="ekr.20230509052845.1758"><vh>_find_lteq</vh></v>
<v t="ekr.20230509052845.1759"><vh>_find_rteq</vh></v>
<v t="ekr.20230509052845.1760"><vh>median_grouped</vh></v>
<v t="ekr.20230509052845.1761"><vh>mode</vh></v>
<v t="ekr.20230509052845.1762"><vh>multimode</vh></v>
<v t="ekr.20230509052845.1763"><vh>quantiles</vh></v>
<v t="ekr.20230509052845.1764"><vh>_lcm</vh></v>
<v t="ekr.20230509052845.1765"><vh>_sum</vh></v>
<v t="ekr.20230509052845.1766"><vh>mean</vh></v>
<v t="ekr.20230509052845.1767"><vh>'''</vh></v>
<v t="ekr.20230509052845.1768"><vh>geometric_mean</vh></v>
<v t="ekr.20230509052845.1769"><vh>_fail_neg</vh></v>
<v t="ekr.20230509052845.1770"><vh>harmonic_mean</vh></v>
<v t="ekr.20230509052845.1771"><vh>_ss</vh></v>
<v t="ekr.20230509052845.1772"><vh>pvariance</vh></v>
<v t="ekr.20230509052845.1773"><vh>pstdev</vh></v>
<v t="ekr.20230509052845.1774"><vh>variance</vh></v>
<v t="ekr.20230509052845.1775"><vh>stdev</vh></v>
<v t="ekr.20230509052845.1776"><vh>class NormalDist</vh>
<v t="ekr.20230509052845.1777"><vh>NormalDist.__eq__</vh></v>
<v t="ekr.20230509052845.1778"><vh>NormalDist._init</vh></v>
<v t="ekr.20230509052845.1779"><vh>NormalDist.__init__</vh></v>
<v t="ekr.20230509052845.1780"><vh>NormalDist.__init__</vh></v>
<v t="ekr.20230509052845.1781"><vh>NormalDist.__init__</vh></v>
<v t="ekr.20230509052845.1782"><vh>NormalDist.mean</vh></v>
<v t="ekr.20230509052845.1783"><vh>NormalDist.median</vh></v>
<v t="ekr.20230509052845.1784"><vh>NormalDist.mode</vh></v>
<v t="ekr.20230509052845.1785"><vh>NormalDist.stdev</vh></v>
<v t="ekr.20230509052845.1786"><vh>NormalDist.variance</vh></v>
<v t="ekr.20230509052845.1787"><vh>NormalDist.pdf</vh></v>
<v t="ekr.20230509052845.1788"><vh>NormalDist.cdf</vh></v>
<v t="ekr.20230509052845.1789"><vh>NormalDist._normal_dist_inv_cdf</vh></v>
<v t="ekr.20230509052845.1790"><vh>NormalDist.inv_cdf</vh></v>
<v t="ekr.20230509052845.1791"><vh>NormalDist.quantiles</vh></v>
<v t="ekr.20230509052845.1792"><vh>NormalDist.overlap</vh></v>
<v t="ekr.20230509052845.1793"><vh>NormalDist.samples</vh></v>
<v t="ekr.20230509052845.1794"><vh>NormalDist.from_samples</vh></v>
<v t="ekr.20230509052845.1795"><vh>NormalDist.__add__</vh></v>
<v t="ekr.20230509052845.1796"><vh>NormalDist.__add__</vh></v>
<v t="ekr.20230509052845.1797"><vh>NormalDist.__sub__</vh></v>
<v t="ekr.20230509052845.1798"><vh>NormalDist.__sub__</vh></v>
<v t="ekr.20230509052845.1799"><vh>NormalDist.__mul__</vh></v>
<v t="ekr.20230509052845.1800"><vh>NormalDist.__truediv__</vh></v>
<v t="ekr.20230509052845.1801"><vh>NormalDist.__pos__</vh></v>
<v t="ekr.20230509052845.1802"><vh>NormalDist.__neg__</vh></v>
<v t="ekr.20230509052845.1803"><vh>NormalDist.__radd__</vh></v>
<v t="ekr.20230509052845.1804"><vh>NormalDist.__rsub__</vh></v>
<v t="ekr.20230509052845.1805"><vh>NormalDist.__rmul__</vh></v>
<v t="ekr.20230509052845.1806"><vh>NormalDist.__eq__</vh></v>
<v t="ekr.20230509052845.1807"><vh>NormalDist.__hash__</vh></v>
<v t="ekr.20230509052845.1808"><vh>NormalDist.__repr__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1809"><vh>@@clean string.codon</vh></v>
<v t="ekr.20230509052845.1810"><vh>@@clean sys.codon</vh>
<v t="ekr.20230509052845.1811"><vh>exit</vh></v>
</v>
<v t="ekr.20230509052845.1812"><vh>@@clean threading.codon</vh>
<v t="ekr.20230509052845.1813"><vh>class Lock</vh>
<v t="ekr.20230509052845.1814"><vh>Lock.__new__</vh></v>
<v t="ekr.20230509052845.1815"><vh>Lock.acquire</vh></v>
<v t="ekr.20230509052845.1816"><vh>Lock.release</vh></v>
<v t="ekr.20230509052845.1817"><vh>Lock.__enter__</vh></v>
<v t="ekr.20230509052845.1818"><vh>Lock.__exit__</vh></v>
</v>
<v t="ekr.20230509052845.1819"><vh>class RLock</vh>
<v t="ekr.20230509052845.1820"><vh>RLock.__new__</vh></v>
<v t="ekr.20230509052845.1821"><vh>RLock.acquire</vh></v>
<v t="ekr.20230509052845.1822"><vh>RLock.release</vh></v>
<v t="ekr.20230509052845.1823"><vh>RLock.__enter__</vh></v>
<v t="ekr.20230509052845.1824"><vh>RLock.__exit__</vh></v>
</v>
<v t="ekr.20230509052845.1825"><vh>active_count</vh></v>
<v t="ekr.20230509052845.1826"><vh>get_native_id</vh></v>
<v t="ekr.20230509052845.1827"><vh>get_ident</vh></v>
</v>
<v t="ekr.20230509052845.1828"><vh>@@clean time.codon</vh>
<v t="ekr.20230509052845.1829"><vh>time</vh></v>
<v t="ekr.20230509052845.1830"><vh>time_ns</vh></v>
<v t="ekr.20230509052845.1831"><vh>monotonic</vh></v>
<v t="ekr.20230509052845.1832"><vh>monotonic_ns</vh></v>
<v t="ekr.20230509052845.1833"><vh>perf_counter</vh></v>
<v t="ekr.20230509052845.1834"><vh>perf_counter_ns</vh></v>
<v t="ekr.20230509052845.1835"><vh>sleep</vh></v>
<v t="ekr.20230509052845.1836"><vh>class TimeInterval</vh>
<v t="ekr.20230509052845.1837"><vh>TimeInterval.__init__</vh></v>
<v t="ekr.20230509052845.1838"><vh>TimeInterval.__enter__</vh></v>
<v t="ekr.20230509052845.1839"><vh>TimeInterval.__exit__</vh></v>
<v t="ekr.20230509052845.1840"><vh>TimeInterval.report</vh></v>
<v t="ekr.20230509052845.1841"><vh>TimeInterval.elapsed</vh></v>
<v t="ekr.20230509052845.1842"><vh>TimeInterval.tick</vh></v>
</v>
<v t="ekr.20230509052845.1843"><vh>timing</vh></v>
<v t="ekr.20230509052845.1844"><vh>class struct_time</vh>
<v t="ekr.20230509052845.1845"><vh>struct_time._wday_adjust_monday_start</vh></v>
<v t="ekr.20230509052845.1846"><vh>struct_time._wday_adjust_sunday_start</vh></v>
<v t="ekr.20230509052845.1847"><vh>struct_time.__new__</vh></v>
<v t="ekr.20230509052845.1848"><vh>struct_time.tm_year</vh></v>
<v t="ekr.20230509052845.1849"><vh>struct_time.tm_yday</vh></v>
<v t="ekr.20230509052845.1850"><vh>struct_time.tm_sec</vh></v>
<v t="ekr.20230509052845.1851"><vh>struct_time.tm_min</vh></v>
<v t="ekr.20230509052845.1852"><vh>struct_time.tm_hour</vh></v>
<v t="ekr.20230509052845.1853"><vh>struct_time.tm_mday</vh></v>
<v t="ekr.20230509052845.1854"><vh>struct_time.tm_mon</vh></v>
<v t="ekr.20230509052845.1855"><vh>struct_time.tm_wday</vh></v>
<v t="ekr.20230509052845.1856"><vh>struct_time.tm_isdst</vh></v>
</v>
<v t="ekr.20230509052845.1857"><vh>localtime</vh></v>
<v t="ekr.20230509052845.1858"><vh>gmtime</vh></v>
<v t="ekr.20230509052845.1859"><vh>mktime</vh></v>
<v t="ekr.20230509052845.1860"><vh>pytime.h funcs</vh></v>
<v t="ekr.20230509052845.1861"><vh>_overflow</vh></v>
<v t="ekr.20230509052845.1862"><vh>_add</vh></v>
<v t="ekr.20230509052845.1863"><vh>_mul_check_overflow</vh></v>
<v t="ekr.20230509052845.1864"><vh>_mul</vh></v>
<v t="ekr.20230509052845.1865"><vh>_muldiv</vh></v>
<v t="ekr.20230509052845.1866"><vh>_round_half_even</vh></v>
<v t="ekr.20230509052845.1867"><vh>_round</vh></v>
<v t="ekr.20230509052845.1868"><vh>_double_to_denominator</vh></v>
<v t="ekr.20230509052845.1869"><vh>_time_to_timespec</vh></v>
<v t="ekr.20230509052845.1870"><vh>_time_to_timeval</vh></v>
</v>
<v t="ekr.20230509052845.1871"><vh>@@clean typing.codon</vh></v>
<v t="ekr.20230509052845.1872"><vh>@@clean unittest.codon</vh>
<v t="ekr.20230509052845.1873"><vh>class TestCase</vh>
<v t="ekr.20230509052845.1874"><vh>TestCase.fail</vh></v>
<v t="ekr.20230509052845.1875"><vh>TestCase.assertTrue</vh></v>
<v t="ekr.20230509052845.1876"><vh>TestCase.assertFalse</vh></v>
<v t="ekr.20230509052845.1877"><vh>TestCase.assertEqual</vh></v>
<v t="ekr.20230509052845.1878"><vh>TestCase.assertNotEqual</vh></v>
<v t="ekr.20230509052845.1879"><vh>TestCase.assertSequenceEqual</vh></v>
<v t="ekr.20230509052845.1880"><vh>TestCase.assertIn</vh></v>
<v t="ekr.20230509052845.1881"><vh>TestCase.assertNotIn</vh></v>
<v t="ekr.20230509052845.1882"><vh>TestCase.assertIs</vh></v>
<v t="ekr.20230509052845.1883"><vh>TestCase.assertIsNot</vh></v>
<v t="ekr.20230509052845.1884"><vh>TestCase.assertIsNot</vh></v>
<v t="ekr.20230509052845.1885"><vh>TestCase.assertCountEqual</vh></v>
<v t="ekr.20230509052845.1886"><vh>TestCase.assertLess</vh></v>
<v t="ekr.20230509052845.1887"><vh>TestCase.assertLessEqual</vh></v>
<v t="ekr.20230509052845.1888"><vh>TestCase.assertGreater</vh></v>
<v t="ekr.20230509052845.1889"><vh>TestCase.assertGreaterEqual</vh></v>
<v t="ekr.20230509052845.1890"><vh>TestCase.assertIsNone</vh></v>
<v t="ekr.20230509052845.1891"><vh>TestCase.assertIsNotNone</vh></v>
<v t="ekr.20230509052845.1892"><vh>TestCase.assertRaises</vh></v>
<v t="ekr.20230509052845.1893"><vh>TestCase.assertAlmostEqual</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1894"><vh>@path algorithms</vh>
<v t="ekr.20230509052845.1895"><vh>@@clean heapsort.codon</vh>
<v t="ekr.20230509052845.1896"><vh>_heapify</vh></v>
<v t="ekr.20230509052845.1897"><vh>_heap_sort</vh></v>
<v t="ekr.20230509052845.1898"><vh>heap_sort_array</vh></v>
<v t="ekr.20230509052845.1899"><vh>heap_sort_inplace</vh></v>
<v t="ekr.20230509052845.1900"><vh>heap_sort</vh></v>
</v>
<v t="ekr.20230509052845.1901"><vh>@@clean insertionsort.codon</vh>
<v t="ekr.20230509052845.1902"><vh>_insertion_sort</vh></v>
<v t="ekr.20230509052845.1903"><vh>insertion_sort_array</vh></v>
<v t="ekr.20230509052845.1904"><vh>insertion_sort_inplace</vh></v>
<v t="ekr.20230509052845.1905"><vh>insertion_sort</vh></v>
</v>
<v t="ekr.20230509052845.1906"><vh>@@clean pdqsort.codon</vh>
<v t="ekr.20230509052845.1907"><vh>_floor_log2</vh></v>
<v t="ekr.20230509052845.1908"><vh>_partial_insertion_sort</vh></v>
<v t="ekr.20230509052845.1909"><vh>_partition_left</vh></v>
<v t="ekr.20230509052845.1910"><vh>_partition_right</vh></v>
<v t="ekr.20230509052845.1911"><vh>_sort2</vh></v>
<v t="ekr.20230509052845.1912"><vh>_sort3</vh></v>
<v t="ekr.20230509052845.1913"><vh>_pdq_sort</vh></v>
<v t="ekr.20230509052845.1914"><vh>pdq_sort_array</vh></v>
<v t="ekr.20230509052845.1915"><vh>pdq_sort_inplace</vh></v>
<v t="ekr.20230509052845.1916"><vh>pdq_sort</vh></v>
</v>
<v t="ekr.20230509052845.1917"><vh>@@clean qsort.codon</vh>
<v t="ekr.20230509052845.1918"><vh>_med3</vh></v>
<v t="ekr.20230509052845.1919"><vh>_swap</vh></v>
<v t="ekr.20230509052845.1920"><vh>_vecswap</vh></v>
<v t="ekr.20230509052845.1921"><vh>_qsort</vh></v>
<v t="ekr.20230509052845.1922"><vh>qsort_array</vh></v>
<v t="ekr.20230509052845.1923"><vh>qsort_inplace</vh></v>
<v t="ekr.20230509052845.1924"><vh>qsort</vh></v>
</v>
<v t="ekr.20230509052845.1925"><vh>@@clean strings.codon</vh>
<v t="ekr.20230509052845.1926"><vh>cttz</vh></v>
<v t="ekr.20230509052845.1927"><vh>ctlz</vh></v>
<v t="ekr.20230509052845.1928"><vh>forward_mask</vh></v>
<v t="ekr.20230509052845.1929"><vh>backward_mask</vh></v>
<v t="ekr.20230509052845.1930"><vh>forward_find</vh></v>
<v t="ekr.20230509052845.1931"><vh>backward_find</vh></v>
<v t="ekr.20230509052845.1932"><vh>find</vh></v>
<v t="ekr.20230509052845.1933"><vh>rfind</vh></v>
<v t="ekr.20230509052845.1934"><vh>count</vh></v>
<v t="ekr.20230509052845.1935"><vh>count_with_max</vh></v>
</v>
<v t="ekr.20230509052845.1936"><vh>@@clean timsort.codon</vh>
<v t="ekr.20230509052845.1937"><vh>_count_run</vh></v>
<v t="ekr.20230509052845.1938"><vh>_merge_compute_minrun</vh></v>
<v t="ekr.20230509052845.1939"><vh>_reverse_sortslice</vh></v>
<v t="ekr.20230509052845.1940"><vh>_modified_comp</vh></v>
<v t="ekr.20230509052845.1941"><vh>_gallop</vh></v>
<v t="ekr.20230509052845.1942"><vh>_merge_with_gallop</vh></v>
<v t="ekr.20230509052845.1943"><vh>_merge_at</vh></v>
<v t="ekr.20230509052845.1944"><vh>_merge_collapse</vh></v>
<v t="ekr.20230509052845.1945"><vh>_final_merge</vh></v>
<v t="ekr.20230509052845.1946"><vh>_tim_sort</vh></v>
<v t="ekr.20230509052845.1947"><vh>tim_sort_array</vh></v>
<v t="ekr.20230509052845.1948"><vh>tim_sort_inplace</vh></v>
<v t="ekr.20230509052845.1949"><vh>tim_sort</vh></v>
</v>
</v>
<v t="ekr.20230509052845.1950"><vh>@path experimental</vh>
<v t="ekr.20230509052845.1951"><vh>@@clean simd.codon</vh>
<v t="ekr.20230509052845.1952"><vh>class Vec</vh>
<v t="ekr.20230509052845.1953"><vh>Vec._mm_set1_epi8</vh></v>
<v t="ekr.20230509052845.1954"><vh>Vec._mm256_set1_epi8</vh></v>
<v t="ekr.20230509052845.1955"><vh>Vec._mm_loadu_si128</vh></v>
<v t="ekr.20230509052845.1956"><vh>Vec._mm256_loadu_si256</vh></v>
<v t="ekr.20230509052845.1957"><vh>Vec._mm256_set1_ps</vh></v>
<v t="ekr.20230509052845.1958"><vh>Vec._mm512_set1_ps</vh></v>
<v t="ekr.20230509052845.1959"><vh>Vec._mm256_loadu_ps</vh></v>
<v t="ekr.20230509052845.1960"><vh>Vec._mm512_loadu_ps</vh></v>
<v t="ekr.20230509052845.1961"><vh>Vec._mm256_cvtepi8_epi32</vh></v>
<v t="ekr.20230509052845.1962"><vh>Vec._mm512_cvtepi8_epi64</vh></v>
<v t="ekr.20230509052845.1963"><vh>Vec._mm256_castsi256_ps</vh></v>
<v t="ekr.20230509052845.1964"><vh>Vec._mm512_castsi512_ps</vh></v>
<v t="ekr.20230509052845.1965"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.1966"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.1967"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.1968"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.1969"><vh>Vec._mm_cmpeq_epi8</vh></v>
<v t="ekr.20230509052845.1970"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.1971"><vh>Vec._mm256_cmpeq_epi8</vh></v>
<v t="ekr.20230509052845.1972"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.1973"><vh>Vec._mm_andnot_si128</vh></v>
<v t="ekr.20230509052845.1974"><vh>Vec.__ne__</vh></v>
<v t="ekr.20230509052845.1975"><vh>Vec._mm256_andnot_si256</vh></v>
<v t="ekr.20230509052845.1976"><vh>Vec.__ne__</vh></v>
<v t="ekr.20230509052845.1977"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.1978"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.1979"><vh>Vec._mm_and_si128</vh></v>
<v t="ekr.20230509052845.1980"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.1981"><vh>Vec._mm_and_si256</vh></v>
<v t="ekr.20230509052845.1982"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.1983"><vh>Vec._mm256_and_ps</vh></v>
<v t="ekr.20230509052845.1984"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.1985"><vh>Vec._mm512_and_ps</vh></v>
<v t="ekr.20230509052845.1986"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.1987"><vh>Vec._mm_or_si128</vh></v>
<v t="ekr.20230509052845.1988"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.1989"><vh>Vec._mm_or_si256</vh></v>
<v t="ekr.20230509052845.1990"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.1991"><vh>Vec._mm256_or_ps</vh></v>
<v t="ekr.20230509052845.1992"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.1993"><vh>Vec._mm512_or_ps</vh></v>
<v t="ekr.20230509052845.1994"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.1995"><vh>Vec._mm_bsrli_si128_8</vh></v>
<v t="ekr.20230509052845.1996"><vh>Vec._mm256_add_ps</vh></v>
<v t="ekr.20230509052845.1997"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.1998"><vh>Vec.__rshift__</vh></v>
<v t="ekr.20230509052845.1999"><vh>Vec._mm_bsrli_256</vh></v>
<v t="ekr.20230509052845.2000"><vh>Vec.__rshift__</vh></v>
<v t="ekr.20230509052845.2001"><vh>Vec.@llvm  # https://stackoverflow.com/questions/6996764/fastest-way-to-do-horizontal-sse-vector-sum-or-other-reduction</vh></v>
<v t="ekr.20230509052845.2002"><vh>Vec.sum</vh></v>
<v t="ekr.20230509052845.2003"><vh>Vec.__getitem__</vh></v>
<v t="ekr.20230509052845.2004"><vh>Vec.__repr__</vh></v>
<v t="ekr.20230509052845.2005"><vh>Vec.scatter</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.2006"><vh>@path internal</vh>
<v t="ekr.20230509052845.2007"><vh>@@clean attributes.codon</vh>
<v t="ekr.20230509052845.2008"><vh>test</vh></v>
<v t="ekr.20230509052845.2009"><vh>export</vh></v>
<v t="ekr.20230509052845.2010"><vh>inline</vh></v>
<v t="ekr.20230509052845.2011"><vh>noinline</vh></v>
<v t="ekr.20230509052845.2012"><vh>pure</vh></v>
<v t="ekr.20230509052845.2013"><vh>nonpure</vh></v>
<v t="ekr.20230509052845.2014"><vh>no_side_effect</vh></v>
<v t="ekr.20230509052845.2015"><vh>nocapture</vh></v>
<v t="ekr.20230509052845.2016"><vh>pycapture</vh></v>
<v t="ekr.20230509052845.2017"><vh>derives</vh></v>
<v t="ekr.20230509052845.2018"><vh>self_captures</vh></v>
<v t="ekr.20230509052845.2019"><vh>commutative</vh></v>
<v t="ekr.20230509052845.2020"><vh>associative</vh></v>
<v t="ekr.20230509052845.2021"><vh>distributive</vh></v>
<v t="ekr.20230509052845.2022"><vh>realize_without_self</vh></v>
<v t="ekr.20230509052845.2023"><vh>virtual</vh></v>
<v t="ekr.20230509052845.2024"><vh>no_argument_wrap</vh></v>
<v t="ekr.20230509052845.2025"><vh>no_type_wrap</vh></v>
</v>
<v t="ekr.20230509052845.2026"><vh>@@clean builtin.codon</vh>
<v t="ekr.20230509052845.2027"><vh>class object</vh></v>
<v t="ekr.20230509052845.2028"><vh>id</vh></v>
<v t="ekr.20230509052845.2029"><vh>_stdout = _C.seq_stdout()</vh></v>
<v t="ekr.20230509052845.2030"><vh>print</vh></v>
<v t="ekr.20230509052845.2031"><vh>class __internal__</vh></v>
<v t="ekr.20230509052845.2032"><vh>min</vh></v>
<v t="ekr.20230509052845.2033"><vh>max</vh></v>
<v t="ekr.20230509052845.2034"><vh>len</vh></v>
<v t="ekr.20230509052845.2035"><vh>iter</vh></v>
<v t="ekr.20230509052845.2036"><vh>abs</vh></v>
<v t="ekr.20230509052845.2037"><vh>hash</vh></v>
<v t="ekr.20230509052845.2038"><vh>ord</vh></v>
<v t="ekr.20230509052845.2039"><vh>divmod</vh></v>
<v t="ekr.20230509052845.2040"><vh>chr</vh></v>
<v t="ekr.20230509052845.2041"><vh>next</vh></v>
<v t="ekr.20230509052845.2042"><vh>any</vh></v>
<v t="ekr.20230509052845.2043"><vh>all</vh></v>
<v t="ekr.20230509052845.2044"><vh>zip</vh></v>
<v t="ekr.20230509052845.2045"><vh>filter</vh></v>
<v t="ekr.20230509052845.2046"><vh>map</vh></v>
<v t="ekr.20230509052845.2047"><vh>enumerate</vh></v>
<v t="ekr.20230509052845.2048"><vh>staticenumerate</vh></v>
<v t="ekr.20230509052845.2049"><vh>echo</vh></v>
<v t="ekr.20230509052845.2050"><vh>reversed</vh></v>
<v t="ekr.20230509052845.2051"><vh>round</vh></v>
<v t="ekr.20230509052845.2052"><vh>_sum_start</vh></v>
<v t="ekr.20230509052845.2053"><vh>sum</vh></v>
<v t="ekr.20230509052845.2054"><vh>repr</vh></v>
<v t="ekr.20230509052845.2055"><vh>_int_format</vh></v>
<v t="ekr.20230509052845.2056"><vh>bin</vh></v>
<v t="ekr.20230509052845.2057"><vh>oct</vh></v>
<v t="ekr.20230509052845.2058"><vh>hex</vh></v>
<v t="ekr.20230509052845.2059"><vh>pow</vh></v>
<v t="ekr.20230509052845.2060"><vh>pow</vh></v>
<v t="ekr.20230509052845.2061"><vh>class int</vh>
<v t="ekr.20230509052845.2062"><vh>int._from_str</vh></v>
</v>
<v t="ekr.20230509052845.2063"><vh>class float</vh>
<v t="ekr.20230509052845.2064"><vh>float._from_str</vh></v>
</v>
<v t="ekr.20230509052845.2065"><vh>_jit_display</vh></v>
</v>
<v t="ekr.20230509052845.2066"><vh>@@clean core.codon</vh>
<v t="ekr.20230509052845.2067"><vh>class __internal__</vh></v>
<v t="ekr.20230509052845.2068"><vh>class bool</vh></v>
<v t="ekr.20230509052845.2069"><vh>class byte</vh></v>
<v t="ekr.20230509052845.2070"><vh>class int</vh></v>
<v t="ekr.20230509052845.2071"><vh>class float</vh></v>
<v t="ekr.20230509052845.2072"><vh>class float32</vh></v>
<v t="ekr.20230509052845.2073"><vh>class NoneType</vh></v>
<v t="ekr.20230509052845.2074"><vh>class type</vh></v>
<v t="ekr.20230509052845.2075"><vh>class Function</vh></v>
<v t="ekr.20230509052845.2076"><vh>class Callable</vh></v>
<v t="ekr.20230509052845.2077"><vh>class Ptr</vh></v>
<v t="ekr.20230509052845.2078"><vh>cobj = Ptr[byte]</vh></v>
<v t="ekr.20230509052845.2079"><vh>class Generator</vh></v>
<v t="ekr.20230509052845.2080"><vh>class Optional</vh></v>
<v t="ekr.20230509052845.2081"><vh>class Int</vh></v>
<v t="ekr.20230509052845.2082"><vh>class UInt</vh></v>
<v t="ekr.20230509052845.2083"><vh>class pyobj</vh></v>
<v t="ekr.20230509052845.2084"><vh>class str</vh></v>
<v t="ekr.20230509052845.2085"><vh>class Array</vh></v>
<v t="ekr.20230509052845.2086"><vh>class type</vh></v>
<v t="ekr.20230509052845.2087"><vh>function = Function</vh></v>
<v t="ekr.20230509052845.2088"><vh>class Ref</vh></v>
<v t="ekr.20230509052845.2089"><vh>class Union</vh></v>
<v t="ekr.20230509052845.2090"><vh>class TypeVar</vh></v>
<v t="ekr.20230509052845.2091"><vh>class ByVal</vh></v>
<v t="ekr.20230509052845.2092"><vh>class ByRef</vh></v>
<v t="ekr.20230509052845.2093"><vh>class Tuple</vh></v>
<v t="ekr.20230509052845.2094"><vh>class ClassVar</vh></v>
<v t="ekr.20230509052845.2095"><vh>class CVar</vh></v>
<v t="ekr.20230509052845.2096"><vh>class __array__</vh></v>
<v t="ekr.20230509052845.2097"><vh>__ptr__</vh></v>
<v t="ekr.20230509052845.2098"><vh>staticlen</vh></v>
<v t="ekr.20230509052845.2099"><vh>compile_error</vh></v>
<v t="ekr.20230509052845.2100"><vh>isinstance</vh></v>
<v t="ekr.20230509052845.2101"><vh>overload</vh></v>
<v t="ekr.20230509052845.2102"><vh>hasattr</vh></v>
<v t="ekr.20230509052845.2103"><vh>hasattr</vh></v>
<v t="ekr.20230509052845.2104"><vh>getattr</vh></v>
<v t="ekr.20230509052845.2105"><vh>setattr</vh></v>
<v t="ekr.20230509052845.2106"><vh>tuple</vh></v>
<v t="ekr.20230509052845.2107"><vh>super</vh></v>
<v t="ekr.20230509052845.2108"><vh>superf</vh></v>
<v t="ekr.20230509052845.2109"><vh>__realized__</vh></v>
<v t="ekr.20230509052845.2110"><vh>statictuple</vh></v>
</v>
<v t="ekr.20230509052845.2111"><vh>@@clean c_stubs.codon</vh>
<v t="ekr.20230509052845.2112"><vh>seq_str_int</vh></v>
<v t="ekr.20230509052845.2113"><vh>seq_str_uint</vh></v>
<v t="ekr.20230509052845.2114"><vh>seq_str_float</vh></v>
<v t="ekr.20230509052845.2115"><vh>seq_str_str</vh></v>
<v t="ekr.20230509052845.2116"><vh>seq_str_ptr</vh></v>
<v t="ekr.20230509052845.2117"><vh>seq_strdup</vh></v>
<v t="ekr.20230509052845.2118"><vh>seq_stdin</vh></v>
<v t="ekr.20230509052845.2119"><vh>seq_stdout</vh></v>
<v t="ekr.20230509052845.2120"><vh>seq_stderr</vh></v>
<v t="ekr.20230509052845.2121"><vh>seq_env</vh></v>
<v t="ekr.20230509052845.2122"><vh>seq_time</vh></v>
<v t="ekr.20230509052845.2123"><vh>seq_time_monotonic</vh></v>
<v t="ekr.20230509052845.2124"><vh>seq_time_highres</vh></v>
<v t="ekr.20230509052845.2125"><vh>seq_localtime</vh></v>
<v t="ekr.20230509052845.2126"><vh>seq_gmtime</vh></v>
<v t="ekr.20230509052845.2127"><vh>seq_mktime</vh></v>
<v t="ekr.20230509052845.2128"><vh>from C import seq_sleep(float)</vh></v>
<v t="ekr.20230509052845.2129"><vh>seq_pid</vh></v>
<v t="ekr.20230509052845.2130"><vh>seq_lock_new</vh></v>
<v t="ekr.20230509052845.2131"><vh>seq_lock_acquire</vh></v>
<v t="ekr.20230509052845.2132"><vh>seq_lock_release</vh></v>
<v t="ekr.20230509052845.2133"><vh>seq_rlock_new</vh></v>
<v t="ekr.20230509052845.2134"><vh>seq_rlock_acquire</vh></v>
<v t="ekr.20230509052845.2135"><vh>seq_rlock_release</vh></v>
<v t="ekr.20230509052845.2136"><vh>seq_i32_to_float</vh></v>
<v t="ekr.20230509052845.2137"><vh>isdigit</vh></v>
<v t="ekr.20230509052845.2138"><vh>isspace</vh></v>
<v t="ekr.20230509052845.2139"><vh>isupper</vh></v>
<v t="ekr.20230509052845.2140"><vh>islower</vh></v>
<v t="ekr.20230509052845.2141"><vh>toupper</vh></v>
<v t="ekr.20230509052845.2142"><vh>tolower</vh></v>
<v t="ekr.20230509052845.2143"><vh>isalnum</vh></v>
<v t="ekr.20230509052845.2144"><vh>isalpha</vh></v>
<v t="ekr.20230509052845.2145"><vh>ceil</vh></v>
<v t="ekr.20230509052845.2146"><vh>floor</vh></v>
<v t="ekr.20230509052845.2147"><vh>fabs</vh></v>
<v t="ekr.20230509052845.2148"><vh>fmod</vh></v>
<v t="ekr.20230509052845.2149"><vh>exp</vh></v>
<v t="ekr.20230509052845.2150"><vh>expm1</vh></v>
<v t="ekr.20230509052845.2151"><vh>ldexp</vh></v>
<v t="ekr.20230509052845.2152"><vh>log</vh></v>
<v t="ekr.20230509052845.2153"><vh>log2</vh></v>
<v t="ekr.20230509052845.2154"><vh>log10</vh></v>
<v t="ekr.20230509052845.2155"><vh>sqrt</vh></v>
<v t="ekr.20230509052845.2156"><vh>pow</vh></v>
<v t="ekr.20230509052845.2157"><vh>round</vh></v>
<v t="ekr.20230509052845.2158"><vh>acos</vh></v>
<v t="ekr.20230509052845.2159"><vh>asin</vh></v>
<v t="ekr.20230509052845.2160"><vh>atan</vh></v>
<v t="ekr.20230509052845.2161"><vh>atan2</vh></v>
<v t="ekr.20230509052845.2162"><vh>cos</vh></v>
<v t="ekr.20230509052845.2163"><vh>sin</vh></v>
<v t="ekr.20230509052845.2164"><vh>tan</vh></v>
<v t="ekr.20230509052845.2165"><vh>cosh</vh></v>
<v t="ekr.20230509052845.2166"><vh>sinh</vh></v>
<v t="ekr.20230509052845.2167"><vh>tanh</vh></v>
<v t="ekr.20230509052845.2168"><vh>acosh</vh></v>
<v t="ekr.20230509052845.2169"><vh>asinh</vh></v>
<v t="ekr.20230509052845.2170"><vh>atanh</vh></v>
<v t="ekr.20230509052845.2171"><vh>copysign</vh></v>
<v t="ekr.20230509052845.2172"><vh>log1p</vh></v>
<v t="ekr.20230509052845.2173"><vh>trunc</vh></v>
<v t="ekr.20230509052845.2174"><vh>log2</vh></v>
<v t="ekr.20230509052845.2175"><vh>erf</vh></v>
<v t="ekr.20230509052845.2176"><vh>erfc</vh></v>
<v t="ekr.20230509052845.2177"><vh>tgamma</vh></v>
<v t="ekr.20230509052845.2178"><vh>lgamma</vh></v>
<v t="ekr.20230509052845.2179"><vh>remainder</vh></v>
<v t="ekr.20230509052845.2180"><vh>hypot</vh></v>
<v t="ekr.20230509052845.2181"><vh>frexp</vh></v>
<v t="ekr.20230509052845.2182"><vh>modf</vh></v>
<v t="ekr.20230509052845.2183"><vh>ceilf</vh></v>
<v t="ekr.20230509052845.2184"><vh>floorf</vh></v>
<v t="ekr.20230509052845.2185"><vh>fabsf</vh></v>
<v t="ekr.20230509052845.2186"><vh>fmodf</vh></v>
<v t="ekr.20230509052845.2187"><vh>expf</vh></v>
<v t="ekr.20230509052845.2188"><vh>expm1f</vh></v>
<v t="ekr.20230509052845.2189"><vh>ldexpf</vh></v>
<v t="ekr.20230509052845.2190"><vh>logf</vh></v>
<v t="ekr.20230509052845.2191"><vh>log2f</vh></v>
<v t="ekr.20230509052845.2192"><vh>log10f</vh></v>
<v t="ekr.20230509052845.2193"><vh>sqrtf</vh></v>
<v t="ekr.20230509052845.2194"><vh>powf</vh></v>
<v t="ekr.20230509052845.2195"><vh>roundf</vh></v>
<v t="ekr.20230509052845.2196"><vh>acosf</vh></v>
<v t="ekr.20230509052845.2197"><vh>asinf</vh></v>
<v t="ekr.20230509052845.2198"><vh>atanf</vh></v>
<v t="ekr.20230509052845.2199"><vh>atan2f</vh></v>
<v t="ekr.20230509052845.2200"><vh>cosf</vh></v>
<v t="ekr.20230509052845.2201"><vh>sinf</vh></v>
<v t="ekr.20230509052845.2202"><vh>tanf</vh></v>
<v t="ekr.20230509052845.2203"><vh>coshf</vh></v>
<v t="ekr.20230509052845.2204"><vh>sinhf</vh></v>
<v t="ekr.20230509052845.2205"><vh>tanhf</vh></v>
<v t="ekr.20230509052845.2206"><vh>acoshf</vh></v>
<v t="ekr.20230509052845.2207"><vh>asinhf</vh></v>
<v t="ekr.20230509052845.2208"><vh>atanhf</vh></v>
<v t="ekr.20230509052845.2209"><vh>copysignf</vh></v>
<v t="ekr.20230509052845.2210"><vh>log1pf</vh></v>
<v t="ekr.20230509052845.2211"><vh>truncf</vh></v>
<v t="ekr.20230509052845.2212"><vh>log2f</vh></v>
<v t="ekr.20230509052845.2213"><vh>erff</vh></v>
<v t="ekr.20230509052845.2214"><vh>erfcf</vh></v>
<v t="ekr.20230509052845.2215"><vh>tgammaf</vh></v>
<v t="ekr.20230509052845.2216"><vh>lgammaf</vh></v>
<v t="ekr.20230509052845.2217"><vh>remainderf</vh></v>
<v t="ekr.20230509052845.2218"><vh>hypotf</vh></v>
<v t="ekr.20230509052845.2219"><vh>frexpf</vh></v>
<v t="ekr.20230509052845.2220"><vh>modff</vh></v>
<v t="ekr.20230509052845.2221"><vh>ferror</vh></v>
<v t="ekr.20230509052845.2222"><vh>fgetc</vh></v>
<v t="ekr.20230509052845.2223"><vh>fopen</vh></v>
<v t="ekr.20230509052845.2224"><vh>fdopen</vh></v>
<v t="ekr.20230509052845.2225"><vh>fclose</vh></v>
<v t="ekr.20230509052845.2226"><vh>fread</vh></v>
<v t="ekr.20230509052845.2227"><vh>fwrite</vh></v>
<v t="ekr.20230509052845.2228"><vh>ftell</vh></v>
<v t="ekr.20230509052845.2229"><vh>fseek</vh></v>
<v t="ekr.20230509052845.2230"><vh>fgets</vh></v>
<v t="ekr.20230509052845.2231"><vh>fflush</vh></v>
<v t="ekr.20230509052845.2232"><vh>getline</vh></v>
<v t="ekr.20230509052845.2233"><vh>&lt;stdlib.h&gt;</vh></v>
<v t="ekr.20230509052845.2234"><vh>system</vh></v>
<v t="ekr.20230509052845.2235"><vh>free</vh></v>
<v t="ekr.20230509052845.2236"><vh>atoi</vh></v>
<v t="ekr.20230509052845.2237"><vh>strtoll</vh></v>
<v t="ekr.20230509052845.2238"><vh>strtod</vh></v>
<v t="ekr.20230509052845.2239"><vh>gzopen</vh></v>
<v t="ekr.20230509052845.2240"><vh>gzerror</vh></v>
<v t="ekr.20230509052845.2241"><vh>gzgetc</vh></v>
<v t="ekr.20230509052845.2242"><vh>gzgets</vh></v>
<v t="ekr.20230509052845.2243"><vh>gzclose</vh></v>
<v t="ekr.20230509052845.2244"><vh>gzread</vh></v>
<v t="ekr.20230509052845.2245"><vh>gzwrite</vh></v>
<v t="ekr.20230509052845.2246"><vh>gztell</vh></v>
<v t="ekr.20230509052845.2247"><vh>gzseek</vh></v>
<v t="ekr.20230509052845.2248"><vh>gzflush</vh></v>
<v t="ekr.20230509052845.2249"><vh>memcmp</vh></v>
<v t="ekr.20230509052845.2250"><vh>memchr</vh></v>
</v>
<v t="ekr.20230509052845.2251"><vh>@@clean dlopen.codon</vh>
<v t="ekr.20230509052845.2252"><vh>seq_is_macos</vh></v>
<v t="ekr.20230509052845.2253"><vh>&lt;dlfcn.h&gt;</vh></v>
<v t="ekr.20230509052845.2254"><vh>dlext</vh></v>
<v t="ekr.20230509052845.2255"><vh>dlerror</vh></v>
<v t="ekr.20230509052845.2256"><vh>dlopen</vh></v>
<v t="ekr.20230509052845.2257"><vh>dlsym</vh></v>
<v t="ekr.20230509052845.2258"><vh>dlclose</vh></v>
</v>
<v t="ekr.20230509052845.2259"><vh>@@clean file.codon</vh>
<v t="ekr.20230509052845.2260"><vh>class File</vh>
<v t="ekr.20230509052845.2261"><vh>File.__init__</vh></v>
<v t="ekr.20230509052845.2262"><vh>File.__init__</vh></v>
<v t="ekr.20230509052845.2263"><vh>File._errcheck</vh></v>
<v t="ekr.20230509052845.2264"><vh>File.__enter__</vh></v>
<v t="ekr.20230509052845.2265"><vh>File.__exit__</vh></v>
<v t="ekr.20230509052845.2266"><vh>File.__iter__</vh></v>
<v t="ekr.20230509052845.2267"><vh>File.readlines</vh></v>
<v t="ekr.20230509052845.2268"><vh>File.write</vh></v>
<v t="ekr.20230509052845.2269"><vh>File.__file_write_gen__</vh></v>
<v t="ekr.20230509052845.2270"><vh>File.read</vh></v>
<v t="ekr.20230509052845.2271"><vh>File.tell</vh></v>
<v t="ekr.20230509052845.2272"><vh>File.seek</vh></v>
<v t="ekr.20230509052845.2273"><vh>File.flush</vh></v>
<v t="ekr.20230509052845.2274"><vh>File.close</vh></v>
<v t="ekr.20230509052845.2275"><vh>File._ensure_open</vh></v>
<v t="ekr.20230509052845.2276"><vh>File._reset</vh></v>
<v t="ekr.20230509052845.2277"><vh>File._iter</vh></v>
<v t="ekr.20230509052845.2278"><vh>File._iter_trim_newline</vh></v>
</v>
<v t="ekr.20230509052845.2279"><vh>_gz_errcheck</vh></v>
<v t="ekr.20230509052845.2280"><vh>class gzFile</vh>
<v t="ekr.20230509052845.2281"><vh>gzFile.__init__</vh></v>
<v t="ekr.20230509052845.2282"><vh>gzFile.__init__</vh></v>
<v t="ekr.20230509052845.2283"><vh>gzFile._getline</vh></v>
<v t="ekr.20230509052845.2284"><vh>gzFile.__iter__</vh></v>
<v t="ekr.20230509052845.2285"><vh>gzFile.__enter__</vh></v>
<v t="ekr.20230509052845.2286"><vh>gzFile.__exit__</vh></v>
<v t="ekr.20230509052845.2287"><vh>gzFile.close</vh></v>
<v t="ekr.20230509052845.2288"><vh>gzFile.readlines</vh></v>
<v t="ekr.20230509052845.2289"><vh>gzFile.write</vh></v>
<v t="ekr.20230509052845.2290"><vh>gzFile.__file_write_gen__</vh></v>
<v t="ekr.20230509052845.2291"><vh>gzFile.read</vh></v>
<v t="ekr.20230509052845.2292"><vh>gzFile.tell</vh></v>
<v t="ekr.20230509052845.2293"><vh>gzFile.seek</vh></v>
<v t="ekr.20230509052845.2294"><vh>gzFile.flush</vh></v>
<v t="ekr.20230509052845.2295"><vh>gzFile._iter</vh></v>
<v t="ekr.20230509052845.2296"><vh>gzFile._iter_trim_newline</vh></v>
<v t="ekr.20230509052845.2297"><vh>gzFile._ensure_open</vh></v>
<v t="ekr.20230509052845.2298"><vh>gzFile._reset</vh></v>
</v>
<v t="ekr.20230509052845.2299"><vh>open</vh></v>
<v t="ekr.20230509052845.2300"><vh>gzopen</vh></v>
<v t="ekr.20230509052845.2301"><vh>is_binary</vh></v>
</v>
<v t="ekr.20230509052845.2302"><vh>@@clean format.codon</vh>
<v t="ekr.20230509052845.2303"><vh>_format_error</vh></v>
<v t="ekr.20230509052845.2304"><vh>class int</vh></v>
<v t="ekr.20230509052845.2305"><vh>class Int</vh></v>
<v t="ekr.20230509052845.2306"><vh>class UInt</vh></v>
<v t="ekr.20230509052845.2307"><vh>class float</vh></v>
<v t="ekr.20230509052845.2308"><vh>class str</vh></v>
<v t="ekr.20230509052845.2309"><vh>class Ptr</vh></v>
<v t="ekr.20230509052845.2310"><vh>_divmod_10</vh></v>
<v t="ekr.20230509052845.2311"><vh>class Int</vh>
<v t="ekr.20230509052845.2312"><vh>Int.__str__</vh></v>
</v>
<v t="ekr.20230509052845.2313"><vh>class UInt</vh>
<v t="ekr.20230509052845.2314"><vh>UInt.__str__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2315"><vh>@@clean gc.codon</vh>
<v t="ekr.20230509052845.2316"><vh>seq_alloc</vh></v>
<v t="ekr.20230509052845.2317"><vh>seq_alloc_atomic</vh></v>
<v t="ekr.20230509052845.2318"><vh>seq_alloc_uncollectable</vh></v>
<v t="ekr.20230509052845.2319"><vh>seq_alloc_atomic_uncollectable</vh></v>
<v t="ekr.20230509052845.2320"><vh>seq_realloc</vh></v>
<v t="ekr.20230509052845.2321"><vh>seq_free</vh></v>
<v t="ekr.20230509052845.2322"><vh>seq_register_finalizer</vh></v>
<v t="ekr.20230509052845.2323"><vh>seq_gc_add_roots</vh></v>
<v t="ekr.20230509052845.2324"><vh>seq_gc_remove_roots</vh></v>
<v t="ekr.20230509052845.2325"><vh>seq_gc_clear_roots</vh></v>
<v t="ekr.20230509052845.2326"><vh>seq_gc_exclude_static_roots</vh></v>
<v t="ekr.20230509052845.2327"><vh>sizeof</vh></v>
<v t="ekr.20230509052845.2328"><vh>atomic</vh></v>
<v t="ekr.20230509052845.2329"><vh>alloc</vh></v>
<v t="ekr.20230509052845.2330"><vh>alloc_atomic</vh></v>
<v t="ekr.20230509052845.2331"><vh>alloc_uncollectable</vh></v>
<v t="ekr.20230509052845.2332"><vh>alloc_atomic_uncollectable</vh></v>
<v t="ekr.20230509052845.2333"><vh>realloc</vh></v>
<v t="ekr.20230509052845.2334"><vh>free</vh></v>
<v t="ekr.20230509052845.2335"><vh>add_roots</vh></v>
<v t="ekr.20230509052845.2336"><vh>remove_roots</vh></v>
<v t="ekr.20230509052845.2337"><vh>clear_roots</vh></v>
<v t="ekr.20230509052845.2338"><vh>exclude_static_roots</vh></v>
<v t="ekr.20230509052845.2339"><vh>register_finalizer</vh></v>
<v t="ekr.20230509052845.2340"><vh>construct_ref</vh></v>
</v>
<v t="ekr.20230509052845.2341"><vh>@@clean internal.codon</vh>
<v t="ekr.20230509052845.2342"><vh>class __internal__</vh>
<v t="ekr.20230509052845.2343"><vh>__internal__.yield_final</vh></v>
<v t="ekr.20230509052845.2344"><vh>__internal__.yield_in_no_suspend</vh></v>
<v t="ekr.20230509052845.2345"><vh>__internal__.class_raw</vh></v>
<v t="ekr.20230509052845.2346"><vh>__internal__.class_alloc</vh></v>
<v t="ekr.20230509052845.2347"><vh>__internal__.class_new</vh></v>
<v t="ekr.20230509052845.2348"><vh>__internal__.class_ctr</vh></v>
<v t="ekr.20230509052845.2349"><vh>__internal__.class_set_obj_vtable</vh></v>
<v t="ekr.20230509052845.2350"><vh>__internal__.class_init_vtables</vh></v>
<v t="ekr.20230509052845.2351"><vh>__internal__.class_make_n_vtables</vh></v>
<v t="ekr.20230509052845.2352"><vh>__internal__.class_populate_vtables</vh></v>
<v t="ekr.20230509052845.2353"><vh>__internal__.class_set_typeinfo</vh></v>
<v t="ekr.20230509052845.2354"><vh>__internal__.class_get_typeinfo</vh></v>
<v t="ekr.20230509052845.2355"><vh>__internal__.class_base_derived_dist</vh></v>
<v t="ekr.20230509052845.2356"><vh>__internal__.class_copy</vh></v>
<v t="ekr.20230509052845.2357"><vh>__internal__.class_super</vh></v>
<v t="ekr.20230509052845.2358"><vh>__internal__.Unions</vh></v>
<v t="ekr.20230509052845.2359"><vh>__internal__.union_set_tag</vh></v>
<v t="ekr.20230509052845.2360"><vh>__internal__.union_get_data_ptr</vh></v>
<v t="ekr.20230509052845.2361"><vh>__internal__.union_get_tag</vh></v>
<v t="ekr.20230509052845.2362"><vh>__internal__.union_get_data</vh></v>
<v t="ekr.20230509052845.2363"><vh>__internal__.union_make</vh></v>
<v t="ekr.20230509052845.2364"><vh>__internal__.new_union</vh></v>
<v t="ekr.20230509052845.2365"><vh>__internal__.get_union</vh></v>
<v t="ekr.20230509052845.2366"><vh>__internal__.get_union_first</vh></v>
<v t="ekr.20230509052845.2367"><vh>__internal__._get_union_method</vh></v>
<v t="ekr.20230509052845.2368"><vh>__internal__.get_union_method</vh></v>
<v t="ekr.20230509052845.2369"><vh>__internal__.Tuples</vh></v>
<v t="ekr.20230509052845.2370"><vh>__internal__._tuple_getitem_llvm</vh></v>
<v t="ekr.20230509052845.2371"><vh>__internal__.tuple_fix_index</vh></v>
<v t="ekr.20230509052845.2372"><vh>__internal__.tuple_getitem</vh></v>
<v t="ekr.20230509052845.2373"><vh>__internal__.tuple_add</vh></v>
<v t="ekr.20230509052845.2374"><vh>__internal__.tuple_mul</vh></v>
<v t="ekr.20230509052845.2375"><vh>__internal__....</vh></v>
<v t="ekr.20230509052845.2376"><vh>__internal__.fn_new</vh></v>
<v t="ekr.20230509052845.2377"><vh>__internal__.fn_raw</vh></v>
<v t="ekr.20230509052845.2378"><vh>__internal__.int_sext</vh></v>
<v t="ekr.20230509052845.2379"><vh>__internal__.int_zext</vh></v>
<v t="ekr.20230509052845.2380"><vh>__internal__.int_trunc</vh></v>
<v t="ekr.20230509052845.2381"><vh>__internal__.seq_assert</vh></v>
<v t="ekr.20230509052845.2382"><vh>__internal__.seq_assert_test</vh></v>
<v t="ekr.20230509052845.2383"><vh>__internal__.check_errno</vh></v>
<v t="ekr.20230509052845.2384"><vh>__internal__.opt_tuple_new</vh></v>
<v t="ekr.20230509052845.2385"><vh>__internal__.opt_ref_new</vh></v>
<v t="ekr.20230509052845.2386"><vh>__internal__.opt_tuple_new_arg</vh></v>
<v t="ekr.20230509052845.2387"><vh>__internal__.opt_ref_new_arg</vh></v>
<v t="ekr.20230509052845.2388"><vh>__internal__.opt_tuple_bool</vh></v>
<v t="ekr.20230509052845.2389"><vh>__internal__.opt_ref_bool</vh></v>
<v t="ekr.20230509052845.2390"><vh>__internal__.opt_tuple_invert</vh></v>
<v t="ekr.20230509052845.2391"><vh>__internal__.opt_ref_invert</vh></v>
<v t="ekr.20230509052845.2392"><vh>__internal__.to_class_ptr</vh></v>
<v t="ekr.20230509052845.2393"><vh>__internal__._tuple_offsetof</vh></v>
<v t="ekr.20230509052845.2394"><vh>__internal__.raw_type_str</vh></v>
<v t="ekr.20230509052845.2395"><vh>__internal__.tuple_str</vh></v>
<v t="ekr.20230509052845.2396"><vh>__internal__.undef</vh></v>
<v t="ekr.20230509052845.2397"><vh>__internal__.set_header</vh></v>
</v>
<v t="ekr.20230509052845.2398"><vh>class Import</vh></v>
<v t="ekr.20230509052845.2399"><vh>class Function</vh>
<v t="ekr.20230509052845.2400"><vh>Function.__new__</vh></v>
<v t="ekr.20230509052845.2401"><vh>Function.__new__</vh></v>
<v t="ekr.20230509052845.2402"><vh>Function.__raw__</vh></v>
<v t="ekr.20230509052845.2403"><vh>Function.__repr__</vh></v>
<v t="ekr.20230509052845.2404"><vh>Function.__call_internal__</vh></v>
<v t="ekr.20230509052845.2405"><vh>Function.__call__</vh></v>
</v>
<v t="ekr.20230509052845.2406"><vh>__vtables__ = __internal__.class_init_vtables()</vh></v>
<v t="ekr.20230509052845.2407"><vh>_____</vh></v>
<v t="ekr.20230509052845.2408"><vh>class PyObject</vh></v>
<v t="ekr.20230509052845.2409"><vh>class PyWrapper</vh></v>
</v>
<v t="ekr.20230509052845.2410"><vh>@@clean khash.codon</vh>
<v t="ekr.20230509052845.2411"><vh>__ac_isempty</vh></v>
<v t="ekr.20230509052845.2412"><vh>__ac_isdel</vh></v>
<v t="ekr.20230509052845.2413"><vh>__ac_iseither</vh></v>
<v t="ekr.20230509052845.2414"><vh>__ac_set_isdel_false</vh></v>
<v t="ekr.20230509052845.2415"><vh>__ac_set_isempty_false</vh></v>
<v t="ekr.20230509052845.2416"><vh>__ac_set_isboth_false</vh></v>
<v t="ekr.20230509052845.2417"><vh>__ac_set_isdel_true</vh></v>
<v t="ekr.20230509052845.2418"><vh>__ac_fsize</vh></v>
</v>
<v t="ekr.20230509052845.2419"><vh>@@clean pynumerics.codon</vh>
<v t="ekr.20230509052845.2420"><vh>_floordiv_int_float</vh></v>
<v t="ekr.20230509052845.2421"><vh>_floordiv_int_int</vh></v>
<v t="ekr.20230509052845.2422"><vh>_truediv_int_float</vh></v>
<v t="ekr.20230509052845.2423"><vh>_truediv_int_int</vh></v>
<v t="ekr.20230509052845.2424"><vh>_mod_int_float</vh></v>
<v t="ekr.20230509052845.2425"><vh>_mod_int_int</vh></v>
<v t="ekr.20230509052845.2426"><vh>_truediv_float_float</vh></v>
<v t="ekr.20230509052845.2427"><vh>_mod_float_float</vh></v>
<v t="ekr.20230509052845.2428"><vh>_divmod_int_int</vh></v>
<v t="ekr.20230509052845.2429"><vh>_divmod_float_float</vh></v>
<v t="ekr.20230509052845.2430"><vh>class int</vh>
<v t="ekr.20230509052845.2431"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.2432"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.2433"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.2434"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.2435"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.2436"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.2437"><vh>int.__divmod__</vh></v>
<v t="ekr.20230509052845.2438"><vh>int.__divmod__</vh></v>
</v>
<v t="ekr.20230509052845.2439"><vh>class float</vh>
<v t="ekr.20230509052845.2440"><vh>float.__floordiv__</vh></v>
<v t="ekr.20230509052845.2441"><vh>float.__floordiv__</vh></v>
<v t="ekr.20230509052845.2442"><vh>float.__truediv__</vh></v>
<v t="ekr.20230509052845.2443"><vh>float.__truediv__</vh></v>
<v t="ekr.20230509052845.2444"><vh>float.__mod__</vh></v>
<v t="ekr.20230509052845.2445"><vh>float.__mod__</vh></v>
<v t="ekr.20230509052845.2446"><vh>float.__divmod__</vh></v>
<v t="ekr.20230509052845.2447"><vh>float.__divmod__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2448"><vh>@@clean python.codon</vh>
<v t="ekr.20230509052845.2449"><vh>init_handles_dlopen</vh></v>
<v t="ekr.20230509052845.2450"><vh>init_handles_static</vh></v>
<v t="ekr.20230509052845.2451"><vh>init_error_py_types</vh></v>
<v t="ekr.20230509052845.2452"><vh>setup_python</vh></v>
<v t="ekr.20230509052845.2453"><vh>ensure_initialized</vh></v>
<v t="ekr.20230509052845.2454"><vh>setup_decorator</vh></v>
<v t="ekr.20230509052845.2455"><vh>class _PyArg_Parser</vh>
<v t="ekr.20230509052845.2456"><vh>_PyArg_Parser.__new__</vh></v>
</v>
<v t="ekr.20230509052845.2457"><vh>class pyobj</vh>
<v t="ekr.20230509052845.2458"><vh>pyobj.__new__</vh></v>
<v t="ekr.20230509052845.2459"><vh>pyobj.__raw__</vh></v>
<v t="ekr.20230509052845.2460"><vh>pyobj.__init__</vh></v>
<v t="ekr.20230509052845.2461"><vh>pyobj.__del__</vh></v>
<v t="ekr.20230509052845.2462"><vh>pyobj._getattr</vh></v>
<v t="ekr.20230509052845.2463"><vh>pyobj.__add__</vh></v>
<v t="ekr.20230509052845.2464"><vh>pyobj.__radd__</vh></v>
<v t="ekr.20230509052845.2465"><vh>pyobj.__sub__</vh></v>
<v t="ekr.20230509052845.2466"><vh>pyobj.__rsub__</vh></v>
<v t="ekr.20230509052845.2467"><vh>pyobj.__mul__</vh></v>
<v t="ekr.20230509052845.2468"><vh>pyobj.__rmul__</vh></v>
<v t="ekr.20230509052845.2469"><vh>pyobj.__matmul__</vh></v>
<v t="ekr.20230509052845.2470"><vh>pyobj.__rmatmul__</vh></v>
<v t="ekr.20230509052845.2471"><vh>pyobj.__floordiv__</vh></v>
<v t="ekr.20230509052845.2472"><vh>pyobj.__rfloordiv__</vh></v>
<v t="ekr.20230509052845.2473"><vh>pyobj.__truediv__</vh></v>
<v t="ekr.20230509052845.2474"><vh>pyobj.__rtruediv__</vh></v>
<v t="ekr.20230509052845.2475"><vh>pyobj.__mod__</vh></v>
<v t="ekr.20230509052845.2476"><vh>pyobj.__rmod__</vh></v>
<v t="ekr.20230509052845.2477"><vh>pyobj.__divmod__</vh></v>
<v t="ekr.20230509052845.2478"><vh>pyobj.__rdivmod__</vh></v>
<v t="ekr.20230509052845.2479"><vh>pyobj.__pow__</vh></v>
<v t="ekr.20230509052845.2480"><vh>pyobj.__rpow__</vh></v>
<v t="ekr.20230509052845.2481"><vh>pyobj.__neg__</vh></v>
<v t="ekr.20230509052845.2482"><vh>pyobj.__pos__</vh></v>
<v t="ekr.20230509052845.2483"><vh>pyobj.__invert__</vh></v>
<v t="ekr.20230509052845.2484"><vh>pyobj.__lshift__</vh></v>
<v t="ekr.20230509052845.2485"><vh>pyobj.__rlshift__</vh></v>
<v t="ekr.20230509052845.2486"><vh>pyobj.__rshift__</vh></v>
<v t="ekr.20230509052845.2487"><vh>pyobj.__rrshift__</vh></v>
<v t="ekr.20230509052845.2488"><vh>pyobj.__and__</vh></v>
<v t="ekr.20230509052845.2489"><vh>pyobj.__rand__</vh></v>
<v t="ekr.20230509052845.2490"><vh>pyobj.__xor__</vh></v>
<v t="ekr.20230509052845.2491"><vh>pyobj.__rxor__</vh></v>
<v t="ekr.20230509052845.2492"><vh>pyobj.__or__</vh></v>
<v t="ekr.20230509052845.2493"><vh>pyobj.__ror__</vh></v>
<v t="ekr.20230509052845.2494"><vh>pyobj.__iadd__</vh></v>
<v t="ekr.20230509052845.2495"><vh>pyobj.__isub__</vh></v>
<v t="ekr.20230509052845.2496"><vh>pyobj.__imul__</vh></v>
<v t="ekr.20230509052845.2497"><vh>pyobj.__imatmul__</vh></v>
<v t="ekr.20230509052845.2498"><vh>pyobj.__ifloordiv__</vh></v>
<v t="ekr.20230509052845.2499"><vh>pyobj.__itruediv__</vh></v>
<v t="ekr.20230509052845.2500"><vh>pyobj.__imod__</vh></v>
<v t="ekr.20230509052845.2501"><vh>pyobj.__ipow__</vh></v>
<v t="ekr.20230509052845.2502"><vh>pyobj.__ilshift__</vh></v>
<v t="ekr.20230509052845.2503"><vh>pyobj.__irshift__</vh></v>
<v t="ekr.20230509052845.2504"><vh>pyobj.__iand__</vh></v>
<v t="ekr.20230509052845.2505"><vh>pyobj.__ixor__</vh></v>
<v t="ekr.20230509052845.2506"><vh>pyobj.__ior__</vh></v>
<v t="ekr.20230509052845.2507"><vh>pyobj.__int__</vh></v>
<v t="ekr.20230509052845.2508"><vh>pyobj.__float__</vh></v>
<v t="ekr.20230509052845.2509"><vh>pyobj.__index__</vh></v>
<v t="ekr.20230509052845.2510"><vh>pyobj.__len__</vh></v>
<v t="ekr.20230509052845.2511"><vh>pyobj.__length_hint__</vh></v>
<v t="ekr.20230509052845.2512"><vh>pyobj.__getitem__</vh></v>
<v t="ekr.20230509052845.2513"><vh>pyobj.__setitem__</vh></v>
<v t="ekr.20230509052845.2514"><vh>pyobj.__delitem__</vh></v>
<v t="ekr.20230509052845.2515"><vh>pyobj.__lt__</vh></v>
<v t="ekr.20230509052845.2516"><vh>pyobj.__le__</vh></v>
<v t="ekr.20230509052845.2517"><vh>pyobj.__eq__</vh></v>
<v t="ekr.20230509052845.2518"><vh>pyobj.__ne__</vh></v>
<v t="ekr.20230509052845.2519"><vh>pyobj.__gt__</vh></v>
<v t="ekr.20230509052845.2520"><vh>pyobj.__ge__</vh></v>
<v t="ekr.20230509052845.2521"><vh>pyobj.__to_py__</vh></v>
<v t="ekr.20230509052845.2522"><vh>pyobj.__from_py__</vh></v>
<v t="ekr.20230509052845.2523"><vh>pyobj.__str__</vh></v>
<v t="ekr.20230509052845.2524"><vh>pyobj.__repr__</vh></v>
<v t="ekr.20230509052845.2525"><vh>pyobj.__hash__</vh></v>
<v t="ekr.20230509052845.2526"><vh>pyobj.__iter__</vh></v>
<v t="ekr.20230509052845.2527"><vh>pyobj.to_str</vh></v>
<v t="ekr.20230509052845.2528"><vh>pyobj.to_str</vh></v>
<v t="ekr.20230509052845.2529"><vh>pyobj.exc_check</vh></v>
<v t="ekr.20230509052845.2530"><vh>pyobj.exc_wrap</vh></v>
<v t="ekr.20230509052845.2531"><vh>pyobj.incref</vh></v>
<v t="ekr.20230509052845.2532"><vh>pyobj.incref</vh></v>
<v t="ekr.20230509052845.2533"><vh>pyobj.decref</vh></v>
<v t="ekr.20230509052845.2534"><vh>pyobj.decref</vh></v>
<v t="ekr.20230509052845.2535"><vh>pyobj.__call__</vh></v>
<v t="ekr.20230509052845.2536"><vh>pyobj._tuple_new</vh></v>
<v t="ekr.20230509052845.2537"><vh>pyobj._tuple_size</vh></v>
<v t="ekr.20230509052845.2538"><vh>pyobj._tuple_set</vh></v>
<v t="ekr.20230509052845.2539"><vh>pyobj._tuple_get</vh></v>
<v t="ekr.20230509052845.2540"><vh>pyobj._import</vh></v>
<v t="ekr.20230509052845.2541"><vh>pyobj._exec</vh></v>
<v t="ekr.20230509052845.2542"><vh>pyobj._globals</vh></v>
<v t="ekr.20230509052845.2543"><vh>pyobj._builtins</vh></v>
<v t="ekr.20230509052845.2544"><vh>pyobj._get_module</vh></v>
<v t="ekr.20230509052845.2545"><vh>pyobj._main_module</vh></v>
<v t="ekr.20230509052845.2546"><vh>pyobj._repr_mimebundle_</vh></v>
<v t="ekr.20230509052845.2547"><vh>pyobj.__bool__</vh></v>
</v>
<v t="ekr.20230509052845.2548"><vh>_get_identifier</vh></v>
<v t="ekr.20230509052845.2549"><vh>_isinstance</vh></v>
<v t="ekr.20230509052845.2550"><vh>class _PyObject_Struct</vh></v>
<v t="ekr.20230509052845.2551"><vh>_conversion_error</vh></v>
<v t="ekr.20230509052845.2552"><vh>_ensure_type</vh></v>
<v t="ekr.20230509052845.2553"><vh>Type conversions</vh></v>
<v t="ekr.20230509052845.2554"><vh>class NoneType</vh>
<v t="ekr.20230509052845.2555"><vh>NoneType.__to_py__</vh></v>
<v t="ekr.20230509052845.2556"><vh>NoneType.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2557"><vh>class int</vh></v>
<v t="ekr.20230509052845.2558"><vh>class float</vh></v>
<v t="ekr.20230509052845.2559"><vh>class bool</vh></v>
<v t="ekr.20230509052845.2560"><vh>class byte</vh></v>
<v t="ekr.20230509052845.2561"><vh>class str</vh></v>
<v t="ekr.20230509052845.2562"><vh>class complex</vh>
<v t="ekr.20230509052845.2563"><vh>complex.__to_py__</vh></v>
<v t="ekr.20230509052845.2564"><vh>complex.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2565"><vh>class List</vh>
<v t="ekr.20230509052845.2566"><vh>List.__to_py__</vh></v>
<v t="ekr.20230509052845.2567"><vh>List.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2568"><vh>class Dict</vh>
<v t="ekr.20230509052845.2569"><vh>Dict.__to_py__</vh></v>
<v t="ekr.20230509052845.2570"><vh>Dict.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2571"><vh>class Set</vh>
<v t="ekr.20230509052845.2572"><vh>Set.__to_py__</vh></v>
<v t="ekr.20230509052845.2573"><vh>Set.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2574"><vh>class DynamicTuple</vh>
<v t="ekr.20230509052845.2575"><vh>DynamicTuple.__to_py__</vh></v>
<v t="ekr.20230509052845.2576"><vh>DynamicTuple.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2577"><vh>class Slice</vh>
<v t="ekr.20230509052845.2578"><vh>Slice.__to_py__</vh></v>
<v t="ekr.20230509052845.2579"><vh>Slice.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2580"><vh>class Optional</vh>
<v t="ekr.20230509052845.2581"><vh>Optional.__to_py__</vh></v>
<v t="ekr.20230509052845.2582"><vh>Optional.__from_py__</vh></v>
</v>
<v t="ekr.20230509052845.2583"><vh>__pyenv__: Optional[pyobj] = None</vh></v>
<v t="ekr.20230509052845.2584"><vh>_____</vh></v>
<v t="ekr.20230509052845.2585"><vh>import internal.static as _S</vh></v>
<v t="ekr.20230509052845.2586"><vh>class _PyWrapError</vh></v>
<v t="ekr.20230509052845.2587"><vh>class _PyWrap</vh>
<v t="ekr.20230509052845.2588"><vh>_PyWrap._dispatch_error</vh></v>
<v t="ekr.20230509052845.2589"><vh>_PyWrap._wrap</vh></v>
<v t="ekr.20230509052845.2590"><vh>_PyWrap._wrap_unary</vh></v>
<v t="ekr.20230509052845.2591"><vh>_PyWrap._args_from_py</vh></v>
<v t="ekr.20230509052845.2592"><vh>_PyWrap._reorder_args</vh></v>
<v t="ekr.20230509052845.2593"><vh>_PyWrap._reorder_args_fastcall</vh></v>
<v t="ekr.20230509052845.2594"><vh>_PyWrap.wrap_magic_abs</vh></v>
<v t="ekr.20230509052845.2595"><vh>_PyWrap.wrap_magic_pos</vh></v>
<v t="ekr.20230509052845.2596"><vh>_PyWrap.wrap_magic_neg</vh></v>
<v t="ekr.20230509052845.2597"><vh>_PyWrap.wrap_magic_invert</vh></v>
<v t="ekr.20230509052845.2598"><vh>_PyWrap.wrap_magic_int</vh></v>
<v t="ekr.20230509052845.2599"><vh>_PyWrap.wrap_magic_float</vh></v>
<v t="ekr.20230509052845.2600"><vh>_PyWrap.wrap_magic_index</vh></v>
<v t="ekr.20230509052845.2601"><vh>_PyWrap.wrap_magic_repr</vh></v>
<v t="ekr.20230509052845.2602"><vh>_PyWrap.wrap_magic_str</vh></v>
<v t="ekr.20230509052845.2603"><vh>_PyWrap._wrap_binary</vh></v>
<v t="ekr.20230509052845.2604"><vh>_PyWrap.wrap_magic_add</vh></v>
<v t="ekr.20230509052845.2605"><vh>_PyWrap.wrap_magic_radd</vh></v>
<v t="ekr.20230509052845.2606"><vh>_PyWrap.wrap_magic_iadd</vh></v>
<v t="ekr.20230509052845.2607"><vh>_PyWrap.wrap_magic_sub</vh></v>
<v t="ekr.20230509052845.2608"><vh>_PyWrap.wrap_magic_rsub</vh></v>
<v t="ekr.20230509052845.2609"><vh>_PyWrap.wrap_magic_isub</vh></v>
<v t="ekr.20230509052845.2610"><vh>_PyWrap.wrap_magic_mul</vh></v>
<v t="ekr.20230509052845.2611"><vh>_PyWrap.wrap_magic_rmul</vh></v>
<v t="ekr.20230509052845.2612"><vh>_PyWrap.wrap_magic_imul</vh></v>
<v t="ekr.20230509052845.2613"><vh>_PyWrap.wrap_magic_mod</vh></v>
<v t="ekr.20230509052845.2614"><vh>_PyWrap.wrap_magic_rmod</vh></v>
<v t="ekr.20230509052845.2615"><vh>_PyWrap.wrap_magic_imod</vh></v>
<v t="ekr.20230509052845.2616"><vh>_PyWrap.wrap_magic_divmod</vh></v>
<v t="ekr.20230509052845.2617"><vh>_PyWrap.wrap_magic_rdivmod</vh></v>
<v t="ekr.20230509052845.2618"><vh>_PyWrap.wrap_magic_lshift</vh></v>
<v t="ekr.20230509052845.2619"><vh>_PyWrap.wrap_magic_rlshift</vh></v>
<v t="ekr.20230509052845.2620"><vh>_PyWrap.wrap_magic_ilshift</vh></v>
<v t="ekr.20230509052845.2621"><vh>_PyWrap.wrap_magic_rshift</vh></v>
<v t="ekr.20230509052845.2622"><vh>_PyWrap.wrap_magic_rrshift</vh></v>
<v t="ekr.20230509052845.2623"><vh>_PyWrap.wrap_magic_irshift</vh></v>
<v t="ekr.20230509052845.2624"><vh>_PyWrap.wrap_magic_and</vh></v>
<v t="ekr.20230509052845.2625"><vh>_PyWrap.wrap_magic_rand</vh></v>
<v t="ekr.20230509052845.2626"><vh>_PyWrap.wrap_magic_iand</vh></v>
<v t="ekr.20230509052845.2627"><vh>_PyWrap.wrap_magic_xor</vh></v>
<v t="ekr.20230509052845.2628"><vh>_PyWrap.wrap_magic_rxor</vh></v>
<v t="ekr.20230509052845.2629"><vh>_PyWrap.wrap_magic_ixor</vh></v>
<v t="ekr.20230509052845.2630"><vh>_PyWrap.wrap_magic_or</vh></v>
<v t="ekr.20230509052845.2631"><vh>_PyWrap.wrap_magic_ror</vh></v>
<v t="ekr.20230509052845.2632"><vh>_PyWrap.wrap_magic_ior</vh></v>
<v t="ekr.20230509052845.2633"><vh>_PyWrap.wrap_magic_floordiv</vh></v>
<v t="ekr.20230509052845.2634"><vh>_PyWrap.wrap_magic_ifloordiv</vh></v>
<v t="ekr.20230509052845.2635"><vh>_PyWrap.wrap_magic_truediv</vh></v>
<v t="ekr.20230509052845.2636"><vh>_PyWrap.wrap_magic_itruediv</vh></v>
<v t="ekr.20230509052845.2637"><vh>_PyWrap.wrap_magic_matmul</vh></v>
<v t="ekr.20230509052845.2638"><vh>_PyWrap.wrap_magic_rmatmul</vh></v>
<v t="ekr.20230509052845.2639"><vh>_PyWrap.wrap_magic_imatmul</vh></v>
<v t="ekr.20230509052845.2640"><vh>_PyWrap.wrap_magic_pow</vh></v>
<v t="ekr.20230509052845.2641"><vh>_PyWrap.wrap_magic_rpow</vh></v>
<v t="ekr.20230509052845.2642"><vh>_PyWrap.wrap_magic_ipow</vh></v>
<v t="ekr.20230509052845.2643"><vh>_PyWrap._wrap_hash</vh></v>
<v t="ekr.20230509052845.2644"><vh>_PyWrap.wrap_magic_len</vh></v>
<v t="ekr.20230509052845.2645"><vh>_PyWrap.wrap_magic_hash</vh></v>
<v t="ekr.20230509052845.2646"><vh>_PyWrap.wrap_magic_bool</vh></v>
<v t="ekr.20230509052845.2647"><vh>_PyWrap.wrap_magic_del</vh></v>
<v t="ekr.20230509052845.2648"><vh>_PyWrap.wrap_magic_contains</vh></v>
<v t="ekr.20230509052845.2649"><vh>_PyWrap.wrap_magic_init</vh></v>
<v t="ekr.20230509052845.2650"><vh>_PyWrap.wrap_magic_call</vh></v>
<v t="ekr.20230509052845.2651"><vh>_PyWrap._wrap_cmp</vh></v>
<v t="ekr.20230509052845.2652"><vh>_PyWrap.wrap_magic_lt</vh></v>
<v t="ekr.20230509052845.2653"><vh>_PyWrap.wrap_magic_le</vh></v>
<v t="ekr.20230509052845.2654"><vh>_PyWrap.wrap_magic_eq</vh></v>
<v t="ekr.20230509052845.2655"><vh>_PyWrap.wrap_magic_ne</vh></v>
<v t="ekr.20230509052845.2656"><vh>_PyWrap.wrap_magic_gt</vh></v>
<v t="ekr.20230509052845.2657"><vh>_PyWrap.wrap_magic_ge</vh></v>
<v t="ekr.20230509052845.2658"><vh>_PyWrap.wrap_cmp</vh></v>
<v t="ekr.20230509052845.2659"><vh>_PyWrap.wrap_magic_getitem</vh></v>
<v t="ekr.20230509052845.2660"><vh>_PyWrap.wrap_magic_setitem</vh></v>
<v t="ekr.20230509052845.2661"><vh>class IterWrap</vh></v>
<v t="ekr.20230509052845.2662"><vh>wrap_magic_iter</vh></v>
<v t="ekr.20230509052845.2663"><vh>wrap_multiple</vh></v>
<v t="ekr.20230509052845.2664"><vh>wrap_get</vh></v>
<v t="ekr.20230509052845.2665"><vh>wrap_set</vh></v>
<v t="ekr.20230509052845.2666"><vh>py_type</vh></v>
<v t="ekr.20230509052845.2667"><vh>wrap_to_py</vh></v>
<v t="ekr.20230509052845.2668"><vh>wrap_from_py</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2669"><vh>@@clean sort.codon</vh>
<v t="ekr.20230509052845.2670"><vh>sorted</vh></v>
<v t="ekr.20230509052845.2671"><vh>_is_pdq_compatible</vh></v>
<v t="ekr.20230509052845.2672"><vh>_sort_list</vh></v>
<v t="ekr.20230509052845.2673"><vh>class List</vh>
<v t="ekr.20230509052845.2674"><vh>List.sort</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2675"><vh>@@clean static.codon</vh>
<v t="ekr.20230509052845.2676"><vh>fn_overloads</vh></v>
<v t="ekr.20230509052845.2677"><vh>fn_args</vh></v>
<v t="ekr.20230509052845.2678"><vh>fn_arg_has_type</vh></v>
<v t="ekr.20230509052845.2679"><vh>fn_arg_get_type</vh></v>
<v t="ekr.20230509052845.2680"><vh>fn_can_call</vh></v>
<v t="ekr.20230509052845.2681"><vh>fn_wrap_call_args</vh></v>
<v t="ekr.20230509052845.2682"><vh>fn_has_default</vh></v>
<v t="ekr.20230509052845.2683"><vh>fn_get_default</vh></v>
<v t="ekr.20230509052845.2684"><vh>class_args</vh></v>
<v t="ekr.20230509052845.2685"><vh>static_print</vh></v>
</v>
<v t="ekr.20230509052845.2686"><vh>@@clean str.codon</vh>
<v t="ekr.20230509052845.2687"><vh>class str</vh>
<v t="ekr.20230509052845.2688"><vh>str.__hash__</vh></v>
<v t="ekr.20230509052845.2689"><vh>str.__lt__</vh></v>
<v t="ekr.20230509052845.2690"><vh>str.__le__</vh></v>
<v t="ekr.20230509052845.2691"><vh>str.__gt__</vh></v>
<v t="ekr.20230509052845.2692"><vh>str.__ge__</vh></v>
<v t="ekr.20230509052845.2693"><vh>str.__repr__</vh></v>
<v t="ekr.20230509052845.2694"><vh>str.__getitem__</vh></v>
<v t="ekr.20230509052845.2695"><vh>str.__getitem__</vh></v>
<v t="ekr.20230509052845.2696"><vh>str._make_from_range</vh></v>
<v t="ekr.20230509052845.2697"><vh>str.__iter__</vh></v>
<v t="ekr.20230509052845.2698"><vh>str.__reversed__</vh></v>
<v t="ekr.20230509052845.2699"><vh>str.__mul__</vh></v>
<v t="ekr.20230509052845.2700"><vh>str._cmp</vh></v>
</v>
<v t="ekr.20230509052845.2701"><vh>import algorithms.strings as algorithms</vh></v>
<v t="ekr.20230509052845.2702"><vh>class str</vh>
<v t="ekr.20230509052845.2703"><vh>str.__contains__</vh></v>
<v t="ekr.20230509052845.2704"><vh>str.Helper methods</vh></v>
<v t="ekr.20230509052845.2705"><vh>str._isdigit</vh></v>
<v t="ekr.20230509052845.2706"><vh>str._isspace</vh></v>
<v t="ekr.20230509052845.2707"><vh>str._isupper</vh></v>
<v t="ekr.20230509052845.2708"><vh>str._islower</vh></v>
<v t="ekr.20230509052845.2709"><vh>str._isalpha</vh></v>
<v t="ekr.20230509052845.2710"><vh>str._isalnum</vh></v>
<v t="ekr.20230509052845.2711"><vh>str._toupper</vh></v>
<v t="ekr.20230509052845.2712"><vh>str._tolower</vh></v>
<v t="ekr.20230509052845.2713"><vh>str._slice</vh></v>
<v t="ekr.20230509052845.2714"><vh>str._at</vh></v>
<v t="ekr.20230509052845.2715"><vh>str.join</vh></v>
<v t="ekr.20230509052845.2716"><vh>str.join</vh></v>
<v t="ekr.20230509052845.2717"><vh>str.isdigit</vh></v>
<v t="ekr.20230509052845.2718"><vh>str.islower</vh></v>
<v t="ekr.20230509052845.2719"><vh>str.isupper</vh></v>
<v t="ekr.20230509052845.2720"><vh>str.isalnum</vh></v>
<v t="ekr.20230509052845.2721"><vh>str.isalpha</vh></v>
<v t="ekr.20230509052845.2722"><vh>str.isspace</vh></v>
<v t="ekr.20230509052845.2723"><vh>str.istitle</vh></v>
<v t="ekr.20230509052845.2724"><vh>str.capitalize</vh></v>
<v t="ekr.20230509052845.2725"><vh>str.isdecimal</vh></v>
<v t="ekr.20230509052845.2726"><vh>str.lower</vh></v>
<v t="ekr.20230509052845.2727"><vh>str.upper</vh></v>
<v t="ekr.20230509052845.2728"><vh>str.isascii</vh></v>
<v t="ekr.20230509052845.2729"><vh>str.casefold</vh></v>
<v t="ekr.20230509052845.2730"><vh>str.swapcase</vh></v>
<v t="ekr.20230509052845.2731"><vh>str.title</vh></v>
<v t="ekr.20230509052845.2732"><vh>str.isnumeric</vh></v>
<v t="ekr.20230509052845.2733"><vh>str._build</vh></v>
<v t="ekr.20230509052845.2734"><vh>str.ljust</vh></v>
<v t="ekr.20230509052845.2735"><vh>str.rjust</vh></v>
<v t="ekr.20230509052845.2736"><vh>str.center</vh></v>
<v t="ekr.20230509052845.2737"><vh>str.zfill</vh></v>
<v t="ekr.20230509052845.2738"><vh>str.count</vh></v>
<v t="ekr.20230509052845.2739"><vh>str.find</vh></v>
<v t="ekr.20230509052845.2740"><vh>str.rfind</vh></v>
<v t="ekr.20230509052845.2741"><vh>str.isidentifier</vh></v>
<v t="ekr.20230509052845.2742"><vh>str.isprintable</vh></v>
<v t="ekr.20230509052845.2743"><vh>str._has_char</vh></v>
<v t="ekr.20230509052845.2744"><vh>str.lstrip</vh></v>
<v t="ekr.20230509052845.2745"><vh>str.rstrip</vh></v>
<v t="ekr.20230509052845.2746"><vh>strip</vh></v>
<v t="ekr.20230509052845.2747"><vh>str.partition</vh></v>
<v t="ekr.20230509052845.2748"><vh>str.rpartition</vh></v>
<v t="ekr.20230509052845.2749"><vh>str.split</vh></v>
<v t="ekr.20230509052845.2750"><vh>str.rsplit</vh></v>
<v t="ekr.20230509052845.2751"><vh>str.splitlines</vh></v>
<v t="ekr.20230509052845.2752"><vh>str.startswith</vh></v>
<v t="ekr.20230509052845.2753"><vh>str.endswith</vh></v>
<v t="ekr.20230509052845.2754"><vh>str.index</vh></v>
<v t="ekr.20230509052845.2755"><vh>str.rindex</vh></v>
<v t="ekr.20230509052845.2756"><vh>str.replace</vh></v>
<v t="ekr.20230509052845.2757"><vh>str.expandtabs</vh></v>
<v t="ekr.20230509052845.2758"><vh>str.translate</vh></v>
<v t="ekr.20230509052845.2759"><vh>str.Internal helpers</vh></v>
<v t="ekr.20230509052845.2760"><vh>str._correct_indices</vh></v>
<v t="ekr.20230509052845.2761"><vh>str._split_whitespace</vh></v>
<v t="ekr.20230509052845.2762"><vh>str._rsplit_whitespace</vh></v>
<v t="ekr.20230509052845.2763"><vh>str._split_char</vh></v>
<v t="ekr.20230509052845.2764"><vh>str._rsplit_char</vh></v>
<v t="ekr.20230509052845.2765"><vh>str._findchar</vh></v>
<v t="ekr.20230509052845.2766"><vh>str._countchar</vh></v>
<v t="ekr.20230509052845.2767"><vh>str._replace_interleave</vh></v>
<v t="ekr.20230509052845.2768"><vh>str._replace_delete_single_character</vh></v>
<v t="ekr.20230509052845.2769"><vh>str._replace_delete_substring</vh></v>
<v t="ekr.20230509052845.2770"><vh>str._replace_single_character_in_place</vh></v>
<v t="ekr.20230509052845.2771"><vh>str._replace_substring_in_place</vh></v>
<v t="ekr.20230509052845.2772"><vh>str._replace_single_character</vh></v>
<v t="ekr.20230509052845.2773"><vh>str._replace_substring</vh></v>
<v t="ekr.20230509052845.2774"><vh>str._replace</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2775"><vh>@@clean __init_test__.codon</vh>
<v t="ekr.20230509052845.2776"><vh>next</vh></v>
<v t="ekr.20230509052845.2777"><vh>from C import seq_print_full(str, cobj)</vh></v>
<v t="ekr.20230509052845.2778"><vh>class Set</vh>
<v t="ekr.20230509052845.2779"><vh>Set.__init__</vh></v>
<v t="ekr.20230509052845.2780"><vh>Set.__iter__</vh></v>
<v t="ekr.20230509052845.2781"><vh>Set.add</vh></v>
<v t="ekr.20230509052845.2782"><vh>Set.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.2783"><vh>class Dict</vh>
<v t="ekr.20230509052845.2784"><vh>Dict.__init__</vh></v>
<v t="ekr.20230509052845.2785"><vh>Dict.__iter__</vh></v>
<v t="ekr.20230509052845.2786"><vh>Dict.items</vh></v>
<v t="ekr.20230509052845.2787"><vh>Dict.__contains__</vh></v>
<v t="ekr.20230509052845.2788"><vh>Dict.__getitem__</vh></v>
<v t="ekr.20230509052845.2789"><vh>Dict.__setitem__</vh></v>
<v t="ekr.20230509052845.2790"><vh>Dict.__len__</vh></v>
<v t="ekr.20230509052845.2791"><vh>Dict.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.2792"><vh>class str</vh>
<v t="ekr.20230509052845.2793"><vh>str.__getitem__</vh></v>
<v t="ekr.20230509052845.2794"><vh>str.__getitem__</vh></v>
<v t="ekr.20230509052845.2795"><vh>strip</vh></v>
<v t="ekr.20230509052845.2796"><vh>str.__repr__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2797"><vh>@@clean __init__.codon</vh></v>
<v t="ekr.20230509052845.2798"><vh>@path types</vh>
<v t="ekr.20230509052845.2799"><vh>@@clean array.codon</vh>
<v t="ekr.20230509052845.2800"><vh>class Array</vh>
<v t="ekr.20230509052845.2801"><vh>Array.__new__</vh></v>
<v t="ekr.20230509052845.2802"><vh>Array.__new__</vh></v>
<v t="ekr.20230509052845.2803"><vh>Array.__copy__</vh></v>
<v t="ekr.20230509052845.2804"><vh>Array.__deepcopy__</vh></v>
<v t="ekr.20230509052845.2805"><vh>Array.__len__</vh></v>
<v t="ekr.20230509052845.2806"><vh>Array.__bool__</vh></v>
<v t="ekr.20230509052845.2807"><vh>Array.__getitem__</vh></v>
<v t="ekr.20230509052845.2808"><vh>Array.__setitem__</vh></v>
<v t="ekr.20230509052845.2809"><vh>Array.slice</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2810"><vh>@@clean bool.codon</vh>
<v t="ekr.20230509052845.2811"><vh>class bool</vh>
<v t="ekr.20230509052845.2812"><vh>bool.__new__</vh></v>
<v t="ekr.20230509052845.2813"><vh>bool.__new__</vh></v>
<v t="ekr.20230509052845.2814"><vh>bool.__repr__</vh></v>
<v t="ekr.20230509052845.2815"><vh>bool.__copy__</vh></v>
<v t="ekr.20230509052845.2816"><vh>bool.__deepcopy__</vh></v>
<v t="ekr.20230509052845.2817"><vh>bool.__bool__</vh></v>
<v t="ekr.20230509052845.2818"><vh>bool.__hash__</vh></v>
<v t="ekr.20230509052845.2819"><vh>bool.__invert__</vh></v>
<v t="ekr.20230509052845.2820"><vh>bool.__eq__</vh></v>
<v t="ekr.20230509052845.2821"><vh>bool.__ne__</vh></v>
<v t="ekr.20230509052845.2822"><vh>bool.__lt__</vh></v>
<v t="ekr.20230509052845.2823"><vh>bool.__gt__</vh></v>
<v t="ekr.20230509052845.2824"><vh>bool.__le__</vh></v>
<v t="ekr.20230509052845.2825"><vh>bool.__ge__</vh></v>
<v t="ekr.20230509052845.2826"><vh>bool.__and__</vh></v>
<v t="ekr.20230509052845.2827"><vh>bool.__or__</vh></v>
<v t="ekr.20230509052845.2828"><vh>bool.__xor__</vh></v>
<v t="ekr.20230509052845.2829"><vh>bool.__int__</vh></v>
<v t="ekr.20230509052845.2830"><vh>bool.__float__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2831"><vh>@@clean byte.codon</vh>
<v t="ekr.20230509052845.2832"><vh>class byte</vh>
<v t="ekr.20230509052845.2833"><vh>byte.__new__</vh></v>
<v t="ekr.20230509052845.2834"><vh>byte.__new__</vh></v>
<v t="ekr.20230509052845.2835"><vh>byte.__new__</vh></v>
<v t="ekr.20230509052845.2836"><vh>byte.__new__</vh></v>
<v t="ekr.20230509052845.2837"><vh>byte.__copy__</vh></v>
<v t="ekr.20230509052845.2838"><vh>byte.__deepcopy__</vh></v>
<v t="ekr.20230509052845.2839"><vh>byte.__bool__</vh></v>
<v t="ekr.20230509052845.2840"><vh>byte.__eq__</vh></v>
<v t="ekr.20230509052845.2841"><vh>byte.__eq__</vh></v>
<v t="ekr.20230509052845.2842"><vh>byte.__ne__</vh></v>
<v t="ekr.20230509052845.2843"><vh>byte.__lt__</vh></v>
<v t="ekr.20230509052845.2844"><vh>byte.__gt__</vh></v>
<v t="ekr.20230509052845.2845"><vh>byte.__le__</vh></v>
<v t="ekr.20230509052845.2846"><vh>byte.__ge__</vh></v>
<v t="ekr.20230509052845.2847"><vh>byte.__str__</vh></v>
<v t="ekr.20230509052845.2848"><vh>byte.__repr__</vh></v>
<v t="ekr.20230509052845.2849"><vh>byte.__int__</vh></v>
<v t="ekr.20230509052845.2850"><vh>byte.__float__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2851"><vh>@@clean complex.codon</vh>
<v t="ekr.20230509052845.2852"><vh>class complex64</vh></v>
<v t="ekr.20230509052845.2853"><vh>class complex</vh>
<v t="ekr.20230509052845.2854"><vh>complex.__new__</vh></v>
<v t="ekr.20230509052845.2855"><vh>complex.__new__</vh></v>
<v t="ekr.20230509052845.2856"><vh>complex.__new__</vh></v>
<v t="ekr.20230509052845.2857"><vh>complex.__complex__</vh></v>
<v t="ekr.20230509052845.2858"><vh>complex.__bool__</vh></v>
<v t="ekr.20230509052845.2859"><vh>complex.__pos__</vh></v>
<v t="ekr.20230509052845.2860"><vh>complex.__neg__</vh></v>
<v t="ekr.20230509052845.2861"><vh>complex.__abs__</vh></v>
<v t="ekr.20230509052845.2862"><vh>complex.__copy__</vh></v>
<v t="ekr.20230509052845.2863"><vh>complex.__hash__</vh></v>
<v t="ekr.20230509052845.2864"><vh>complex.__add__</vh></v>
<v t="ekr.20230509052845.2865"><vh>complex.__sub__</vh></v>
<v t="ekr.20230509052845.2866"><vh>complex.__mul__</vh></v>
<v t="ekr.20230509052845.2867"><vh>complex.__truediv__</vh></v>
<v t="ekr.20230509052845.2868"><vh>complex.__eq__</vh></v>
<v t="ekr.20230509052845.2869"><vh>complex.__ne__</vh></v>
<v t="ekr.20230509052845.2870"><vh>complex.__pow__</vh></v>
<v t="ekr.20230509052845.2871"><vh>complex.__radd__</vh></v>
<v t="ekr.20230509052845.2872"><vh>complex.__rsub__</vh></v>
<v t="ekr.20230509052845.2873"><vh>complex.__rmul__</vh></v>
<v t="ekr.20230509052845.2874"><vh>complex.__rtruediv__</vh></v>
<v t="ekr.20230509052845.2875"><vh>complex.__rpow__</vh></v>
<v t="ekr.20230509052845.2876"><vh>complex.__add__</vh></v>
<v t="ekr.20230509052845.2877"><vh>complex.__sub__</vh></v>
<v t="ekr.20230509052845.2878"><vh>complex.__mul__</vh></v>
<v t="ekr.20230509052845.2879"><vh>complex.__truediv__</vh></v>
<v t="ekr.20230509052845.2880"><vh>complex.__eq__</vh></v>
<v t="ekr.20230509052845.2881"><vh>complex.__ne__</vh></v>
<v t="ekr.20230509052845.2882"><vh>complex.__pow__</vh></v>
<v t="ekr.20230509052845.2883"><vh>complex.__pow__</vh></v>
<v t="ekr.20230509052845.2884"><vh>complex.__repr__</vh></v>
<v t="ekr.20230509052845.2885"><vh>complex.conjugate</vh></v>
<v t="ekr.20230509052845.2886"><vh>complex._phase</vh></v>
<v t="ekr.20230509052845.2887"><vh>complex._polar</vh></v>
<v t="ekr.20230509052845.2888"><vh>complex._exp</vh></v>
<v t="ekr.20230509052845.2889"><vh>complex._sqrt</vh></v>
<v t="ekr.20230509052845.2890"><vh>complex._cos</vh></v>
<v t="ekr.20230509052845.2891"><vh>complex._sin</vh></v>
<v t="ekr.20230509052845.2892"><vh>complex._log</vh></v>
</v>
<v t="ekr.20230509052845.2893"><vh>class int</vh></v>
<v t="ekr.20230509052845.2894"><vh>class float</vh></v>
<v t="ekr.20230509052845.2895"><vh>f32 = float32</vh></v>
<v t="ekr.20230509052845.2896"><vh>class complex64</vh>
<v t="ekr.20230509052845.2897"><vh>complex64.__new__</vh></v>
<v t="ekr.20230509052845.2898"><vh>complex64.__new__</vh></v>
<v t="ekr.20230509052845.2899"><vh>complex64.__new__</vh></v>
<v t="ekr.20230509052845.2900"><vh>complex64.__new__</vh></v>
<v t="ekr.20230509052845.2901"><vh>complex64.__complex__</vh></v>
<v t="ekr.20230509052845.2902"><vh>complex64.__bool__</vh></v>
<v t="ekr.20230509052845.2903"><vh>complex64.__pos__</vh></v>
<v t="ekr.20230509052845.2904"><vh>complex64.__neg__</vh></v>
<v t="ekr.20230509052845.2905"><vh>complex64.__abs__</vh></v>
<v t="ekr.20230509052845.2906"><vh>complex64.__copy__</vh></v>
<v t="ekr.20230509052845.2907"><vh>complex64.__hash__</vh></v>
<v t="ekr.20230509052845.2908"><vh>complex64.__add__</vh></v>
<v t="ekr.20230509052845.2909"><vh>complex64.__sub__</vh></v>
<v t="ekr.20230509052845.2910"><vh>complex64.__mul__</vh></v>
<v t="ekr.20230509052845.2911"><vh>complex64.__truediv__</vh></v>
<v t="ekr.20230509052845.2912"><vh>complex64.__eq__</vh></v>
<v t="ekr.20230509052845.2913"><vh>complex64.__ne__</vh></v>
<v t="ekr.20230509052845.2914"><vh>complex64.__pow__</vh></v>
<v t="ekr.20230509052845.2915"><vh>complex64.__radd__</vh></v>
<v t="ekr.20230509052845.2916"><vh>complex64.__rsub__</vh></v>
<v t="ekr.20230509052845.2917"><vh>complex64.__rmul__</vh></v>
<v t="ekr.20230509052845.2918"><vh>complex64.__rtruediv__</vh></v>
<v t="ekr.20230509052845.2919"><vh>complex64.__rpow__</vh></v>
<v t="ekr.20230509052845.2920"><vh>complex64.__add__</vh></v>
<v t="ekr.20230509052845.2921"><vh>complex64.__sub__</vh></v>
<v t="ekr.20230509052845.2922"><vh>complex64.__mul__</vh></v>
<v t="ekr.20230509052845.2923"><vh>complex64.__truediv__</vh></v>
<v t="ekr.20230509052845.2924"><vh>complex64.__eq__</vh></v>
<v t="ekr.20230509052845.2925"><vh>complex64.__ne__</vh></v>
<v t="ekr.20230509052845.2926"><vh>complex64.__pow__</vh></v>
<v t="ekr.20230509052845.2927"><vh>complex64.__pow__</vh></v>
<v t="ekr.20230509052845.2928"><vh>complex64.__repr__</vh></v>
<v t="ekr.20230509052845.2929"><vh>complex64.conjugate</vh></v>
<v t="ekr.20230509052845.2930"><vh>complex64._phase</vh></v>
<v t="ekr.20230509052845.2931"><vh>complex64._polar</vh></v>
<v t="ekr.20230509052845.2932"><vh>complex64._exp</vh></v>
<v t="ekr.20230509052845.2933"><vh>complex64._sqrt</vh></v>
<v t="ekr.20230509052845.2934"><vh>complex64._cos</vh></v>
<v t="ekr.20230509052845.2935"><vh>complex64._sin</vh></v>
<v t="ekr.20230509052845.2936"><vh>complex64._log</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2937"><vh>@@clean error.codon</vh>
<v t="ekr.20230509052845.2938"><vh>class BaseException</vh>
<v t="ekr.20230509052845.2939"><vh>BaseException.__init__</vh></v>
<v t="ekr.20230509052845.2940"><vh>BaseException.__str__</vh></v>
<v t="ekr.20230509052845.2941"><vh>BaseException.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.2942"><vh>class Exception</vh></v>
<v t="ekr.20230509052845.2943"><vh>class NameError</vh></v>
<v t="ekr.20230509052845.2944"><vh>class OSError</vh></v>
<v t="ekr.20230509052845.2945"><vh>class IOError</vh></v>
<v t="ekr.20230509052845.2946"><vh>class ValueError</vh></v>
<v t="ekr.20230509052845.2947"><vh>class LookupError</vh></v>
<v t="ekr.20230509052845.2948"><vh>class IndexError</vh></v>
<v t="ekr.20230509052845.2949"><vh>class KeyError</vh></v>
<v t="ekr.20230509052845.2950"><vh>class CError</vh></v>
<v t="ekr.20230509052845.2951"><vh>class PyError</vh></v>
<v t="ekr.20230509052845.2952"><vh>class TypeError</vh></v>
<v t="ekr.20230509052845.2953"><vh>class ArithmeticError</vh></v>
<v t="ekr.20230509052845.2954"><vh>class ZeroDivisionError</vh></v>
<v t="ekr.20230509052845.2955"><vh>class OverflowError</vh></v>
<v t="ekr.20230509052845.2956"><vh>class AttributeError</vh></v>
<v t="ekr.20230509052845.2957"><vh>class RuntimeError</vh></v>
<v t="ekr.20230509052845.2958"><vh>class NotImplementedError</vh></v>
<v t="ekr.20230509052845.2959"><vh>class StopIteration</vh></v>
<v t="ekr.20230509052845.2960"><vh>class AssertionError</vh></v>
<v t="ekr.20230509052845.2961"><vh>class SystemExit</vh>
<v t="ekr.20230509052845.2962"><vh>SystemExit.__init__</vh></v>
<v t="ekr.20230509052845.2963"><vh>SystemExit.__init__</vh></v>
<v t="ekr.20230509052845.2964"><vh>SystemExit.status</vh></v>
</v>
</v>
<v t="ekr.20230509052845.2965"><vh>@@clean float.codon</vh>
<v t="ekr.20230509052845.2966"><vh>class float</vh>
<v t="ekr.20230509052845.2967"><vh>float.__new__</vh></v>
<v t="ekr.20230509052845.2968"><vh>float.__new__</vh></v>
<v t="ekr.20230509052845.2969"><vh>float.__repr__</vh></v>
<v t="ekr.20230509052845.2970"><vh>float.__copy__</vh></v>
<v t="ekr.20230509052845.2971"><vh>float.__deepcopy__</vh></v>
<v t="ekr.20230509052845.2972"><vh>float.__int__</vh></v>
<v t="ekr.20230509052845.2973"><vh>float.__float__</vh></v>
<v t="ekr.20230509052845.2974"><vh>float.__bool__</vh></v>
<v t="ekr.20230509052845.2975"><vh>float.__complex__</vh></v>
<v t="ekr.20230509052845.2976"><vh>float.__pos__</vh></v>
<v t="ekr.20230509052845.2977"><vh>float.__neg__</vh></v>
<v t="ekr.20230509052845.2978"><vh>float.__add__</vh></v>
<v t="ekr.20230509052845.2979"><vh>float.__sub__</vh></v>
<v t="ekr.20230509052845.2980"><vh>float.__mul__</vh></v>
<v t="ekr.20230509052845.2981"><vh>float.__floordiv__</vh></v>
<v t="ekr.20230509052845.2982"><vh>float.__truediv__</vh></v>
<v t="ekr.20230509052845.2983"><vh>float.__mod__</vh></v>
<v t="ekr.20230509052845.2984"><vh>float.__divmod__</vh></v>
<v t="ekr.20230509052845.2985"><vh>float.__eq__</vh></v>
<v t="ekr.20230509052845.2986"><vh>float.__ne__</vh></v>
<v t="ekr.20230509052845.2987"><vh>float.__lt__</vh></v>
<v t="ekr.20230509052845.2988"><vh>float.__gt__</vh></v>
<v t="ekr.20230509052845.2989"><vh>float.__le__</vh></v>
<v t="ekr.20230509052845.2990"><vh>float.__ge__</vh></v>
<v t="ekr.20230509052845.2991"><vh>float.sqrt</vh></v>
<v t="ekr.20230509052845.2992"><vh>float.sin</vh></v>
<v t="ekr.20230509052845.2993"><vh>float.cos</vh></v>
<v t="ekr.20230509052845.2994"><vh>float.exp</vh></v>
<v t="ekr.20230509052845.2995"><vh>float.exp2</vh></v>
<v t="ekr.20230509052845.2996"><vh>float.log</vh></v>
<v t="ekr.20230509052845.2997"><vh>float.log10</vh></v>
<v t="ekr.20230509052845.2998"><vh>float.log2</vh></v>
<v t="ekr.20230509052845.2999"><vh>float.__abs__</vh></v>
<v t="ekr.20230509052845.3000"><vh>float.__floor__</vh></v>
<v t="ekr.20230509052845.3001"><vh>float.__ceil__</vh></v>
<v t="ekr.20230509052845.3002"><vh>float.__trunc__</vh></v>
<v t="ekr.20230509052845.3003"><vh>float.rint</vh></v>
<v t="ekr.20230509052845.3004"><vh>float.nearbyint</vh></v>
<v t="ekr.20230509052845.3005"><vh>float.__round__</vh></v>
<v t="ekr.20230509052845.3006"><vh>float.__pow__</vh></v>
<v t="ekr.20230509052845.3007"><vh>float.min</vh></v>
<v t="ekr.20230509052845.3008"><vh>float.max</vh></v>
<v t="ekr.20230509052845.3009"><vh>float.copysign</vh></v>
<v t="ekr.20230509052845.3010"><vh>float.fma</vh></v>
<v t="ekr.20230509052845.3011"><vh>float.__atomic_xchg__</vh></v>
<v t="ekr.20230509052845.3012"><vh>float.__atomic_add__</vh></v>
<v t="ekr.20230509052845.3013"><vh>float.__atomic_sub__</vh></v>
<v t="ekr.20230509052845.3014"><vh>float.__hash__</vh></v>
<v t="ekr.20230509052845.3015"><vh>float.__match__</vh></v>
<v t="ekr.20230509052845.3016"><vh>float.real</vh></v>
<v t="ekr.20230509052845.3017"><vh>float.imag</vh></v>
</v>
<v t="ekr.20230509052845.3018"><vh>class float32</vh>
<v t="ekr.20230509052845.3019"><vh>float32.__new__</vh></v>
<v t="ekr.20230509052845.3020"><vh>float32.__new__</vh></v>
<v t="ekr.20230509052845.3021"><vh>float32.__new__</vh></v>
<v t="ekr.20230509052845.3022"><vh>float32.__repr__</vh></v>
<v t="ekr.20230509052845.3023"><vh>float32.__format__</vh></v>
<v t="ekr.20230509052845.3024"><vh>float32.__copy__</vh></v>
<v t="ekr.20230509052845.3025"><vh>float32.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3026"><vh>float32.__int__</vh></v>
<v t="ekr.20230509052845.3027"><vh>float32.__float__</vh></v>
<v t="ekr.20230509052845.3028"><vh>float32.__bool__</vh></v>
<v t="ekr.20230509052845.3029"><vh>float32.__pos__</vh></v>
<v t="ekr.20230509052845.3030"><vh>float32.__neg__</vh></v>
<v t="ekr.20230509052845.3031"><vh>float32.__add__</vh></v>
<v t="ekr.20230509052845.3032"><vh>float32.__sub__</vh></v>
<v t="ekr.20230509052845.3033"><vh>float32.__mul__</vh></v>
<v t="ekr.20230509052845.3034"><vh>float32.__floordiv__</vh></v>
<v t="ekr.20230509052845.3035"><vh>float32.__truediv__</vh></v>
<v t="ekr.20230509052845.3036"><vh>float32.__mod__</vh></v>
<v t="ekr.20230509052845.3037"><vh>float32.__divmod__</vh></v>
<v t="ekr.20230509052845.3038"><vh>float32.__eq__</vh></v>
<v t="ekr.20230509052845.3039"><vh>float32.__ne__</vh></v>
<v t="ekr.20230509052845.3040"><vh>float32.__lt__</vh></v>
<v t="ekr.20230509052845.3041"><vh>float32.__gt__</vh></v>
<v t="ekr.20230509052845.3042"><vh>float32.__le__</vh></v>
<v t="ekr.20230509052845.3043"><vh>float32.__ge__</vh></v>
<v t="ekr.20230509052845.3044"><vh>float32.sqrt</vh></v>
<v t="ekr.20230509052845.3045"><vh>float32.sin</vh></v>
<v t="ekr.20230509052845.3046"><vh>float32.cos</vh></v>
<v t="ekr.20230509052845.3047"><vh>float32.exp</vh></v>
<v t="ekr.20230509052845.3048"><vh>float32.exp2</vh></v>
<v t="ekr.20230509052845.3049"><vh>float32.log</vh></v>
<v t="ekr.20230509052845.3050"><vh>float32.log10</vh></v>
<v t="ekr.20230509052845.3051"><vh>float32.log2</vh></v>
<v t="ekr.20230509052845.3052"><vh>float32.__abs__</vh></v>
<v t="ekr.20230509052845.3053"><vh>float32.__floor__</vh></v>
<v t="ekr.20230509052845.3054"><vh>float32.__ceil__</vh></v>
<v t="ekr.20230509052845.3055"><vh>float32.__trunc__</vh></v>
<v t="ekr.20230509052845.3056"><vh>float32.rint</vh></v>
<v t="ekr.20230509052845.3057"><vh>float32.nearbyint</vh></v>
<v t="ekr.20230509052845.3058"><vh>float32.__round__</vh></v>
<v t="ekr.20230509052845.3059"><vh>float32.__pow__</vh></v>
<v t="ekr.20230509052845.3060"><vh>float32.min</vh></v>
<v t="ekr.20230509052845.3061"><vh>float32.max</vh></v>
<v t="ekr.20230509052845.3062"><vh>float32.copysign</vh></v>
<v t="ekr.20230509052845.3063"><vh>float32.fma</vh></v>
<v t="ekr.20230509052845.3064"><vh>float32.__atomic_xchg__</vh></v>
<v t="ekr.20230509052845.3065"><vh>float32.__atomic_add__</vh></v>
<v t="ekr.20230509052845.3066"><vh>float32.__atomic_sub__</vh></v>
<v t="ekr.20230509052845.3067"><vh>float32.__hash__</vh></v>
<v t="ekr.20230509052845.3068"><vh>float32.__match__</vh></v>
</v>
<v t="ekr.20230509052845.3069"><vh>class float</vh></v>
</v>
<v t="ekr.20230509052845.3070"><vh>@@clean generator.codon</vh>
<v t="ekr.20230509052845.3071"><vh>class Generator</vh>
<v t="ekr.20230509052845.3072"><vh>Generator.__promise__</vh></v>
<v t="ekr.20230509052845.3073"><vh>Generator.done</vh></v>
<v t="ekr.20230509052845.3074"><vh>Generator.next</vh></v>
<v t="ekr.20230509052845.3075"><vh>Generator.__iter__</vh></v>
<v t="ekr.20230509052845.3076"><vh>Generator.__raw__</vh></v>
<v t="ekr.20230509052845.3077"><vh>Generator.__new__</vh></v>
<v t="ekr.20230509052845.3078"><vh>Generator.__done__</vh></v>
<v t="ekr.20230509052845.3079"><vh>Generator.__resume__</vh></v>
<v t="ekr.20230509052845.3080"><vh>Generator.__repr__</vh></v>
<v t="ekr.20230509052845.3081"><vh>Generator.send</vh></v>
<v t="ekr.20230509052845.3082"><vh>Generator.destroy</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3083"><vh>@@clean int.codon</vh>
<v t="ekr.20230509052845.3084"><vh>class int</vh>
<v t="ekr.20230509052845.3085"><vh>int.__new__</vh></v>
<v t="ekr.20230509052845.3086"><vh>int.__new__</vh></v>
<v t="ekr.20230509052845.3087"><vh>int.__new__</vh></v>
<v t="ekr.20230509052845.3088"><vh>int.__int__</vh></v>
<v t="ekr.20230509052845.3089"><vh>int.__float__</vh></v>
<v t="ekr.20230509052845.3090"><vh>int.__complex__</vh></v>
<v t="ekr.20230509052845.3091"><vh>int.__index__</vh></v>
<v t="ekr.20230509052845.3092"><vh>int.__repr__</vh></v>
<v t="ekr.20230509052845.3093"><vh>int.__copy__</vh></v>
<v t="ekr.20230509052845.3094"><vh>int.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3095"><vh>int.__hash__</vh></v>
<v t="ekr.20230509052845.3096"><vh>int.__bool__</vh></v>
<v t="ekr.20230509052845.3097"><vh>int.__pos__</vh></v>
<v t="ekr.20230509052845.3098"><vh>int.__neg__</vh></v>
<v t="ekr.20230509052845.3099"><vh>int.__abs__</vh></v>
<v t="ekr.20230509052845.3100"><vh>int.__lshift__</vh></v>
<v t="ekr.20230509052845.3101"><vh>int.__rshift__</vh></v>
<v t="ekr.20230509052845.3102"><vh>int.__add__</vh></v>
<v t="ekr.20230509052845.3103"><vh>int.__add__</vh></v>
<v t="ekr.20230509052845.3104"><vh>int.__sub__</vh></v>
<v t="ekr.20230509052845.3105"><vh>int.__sub__</vh></v>
<v t="ekr.20230509052845.3106"><vh>int.__mul__</vh></v>
<v t="ekr.20230509052845.3107"><vh>int.__mul__</vh></v>
<v t="ekr.20230509052845.3108"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.3109"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.3110"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.3111"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.3112"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.3113"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.3114"><vh>int.__divmod__</vh></v>
<v t="ekr.20230509052845.3115"><vh>int.__divmod__</vh></v>
<v t="ekr.20230509052845.3116"><vh>int.__invert__</vh></v>
<v t="ekr.20230509052845.3117"><vh>int.__and__</vh></v>
<v t="ekr.20230509052845.3118"><vh>int.__or__</vh></v>
<v t="ekr.20230509052845.3119"><vh>int.__xor__</vh></v>
<v t="ekr.20230509052845.3120"><vh>int.__bitreverse__</vh></v>
<v t="ekr.20230509052845.3121"><vh>int.__bswap__</vh></v>
<v t="ekr.20230509052845.3122"><vh>int.__ctpop__</vh></v>
<v t="ekr.20230509052845.3123"><vh>int.__ctlz__</vh></v>
<v t="ekr.20230509052845.3124"><vh>int.__cttz__</vh></v>
<v t="ekr.20230509052845.3125"><vh>int.__eq__</vh></v>
<v t="ekr.20230509052845.3126"><vh>int.__eq__</vh></v>
<v t="ekr.20230509052845.3127"><vh>int.__ne__</vh></v>
<v t="ekr.20230509052845.3128"><vh>int.__ne__</vh></v>
<v t="ekr.20230509052845.3129"><vh>int.__lt__</vh></v>
<v t="ekr.20230509052845.3130"><vh>int.__lt__</vh></v>
<v t="ekr.20230509052845.3131"><vh>int.__gt__</vh></v>
<v t="ekr.20230509052845.3132"><vh>int.__gt__</vh></v>
<v t="ekr.20230509052845.3133"><vh>int.__le__</vh></v>
<v t="ekr.20230509052845.3134"><vh>int.__le__</vh></v>
<v t="ekr.20230509052845.3135"><vh>int.__ge__</vh></v>
<v t="ekr.20230509052845.3136"><vh>int.__ge__</vh></v>
<v t="ekr.20230509052845.3137"><vh>int.__pow__</vh></v>
<v t="ekr.20230509052845.3138"><vh>int.__pow__</vh></v>
<v t="ekr.20230509052845.3139"><vh>int.popcnt</vh></v>
<v t="ekr.20230509052845.3140"><vh>int.__atomic_xchg__</vh></v>
<v t="ekr.20230509052845.3141"><vh>int.__atomic_add__</vh></v>
<v t="ekr.20230509052845.3142"><vh>int.__atomic_sub__</vh></v>
<v t="ekr.20230509052845.3143"><vh>int.__atomic_and__</vh></v>
<v t="ekr.20230509052845.3144"><vh>int.__atomic_nand__</vh></v>
<v t="ekr.20230509052845.3145"><vh>int.__atomic_or__</vh></v>
<v t="ekr.20230509052845.3146"><vh>int.__atomic_xor__</vh></v>
<v t="ekr.20230509052845.3147"><vh>int.__atomic_min__</vh></v>
<v t="ekr.20230509052845.3148"><vh>int.__atomic_max__</vh></v>
<v t="ekr.20230509052845.3149"><vh>int.__match__</vh></v>
<v t="ekr.20230509052845.3150"><vh>int.real</vh></v>
<v t="ekr.20230509052845.3151"><vh>int.imag</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3152"><vh>@@clean intn.codon</vh>
<v t="ekr.20230509052845.3153"><vh>check_N</vh></v>
<v t="ekr.20230509052845.3154"><vh>class Int</vh>
<v t="ekr.20230509052845.3155"><vh>Int.__new__</vh></v>
<v t="ekr.20230509052845.3156"><vh>Int.__new__</vh></v>
<v t="ekr.20230509052845.3157"><vh>Int.__new__</vh></v>
<v t="ekr.20230509052845.3158"><vh>Int.__new__</vh></v>
<v t="ekr.20230509052845.3159"><vh>Int.__new__</vh></v>
<v t="ekr.20230509052845.3160"><vh>Int.__int__</vh></v>
<v t="ekr.20230509052845.3161"><vh>Int.__index__</vh></v>
<v t="ekr.20230509052845.3162"><vh>Int.__copy__</vh></v>
<v t="ekr.20230509052845.3163"><vh>Int.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3164"><vh>Int.__hash__</vh></v>
<v t="ekr.20230509052845.3165"><vh>Int.__float__</vh></v>
<v t="ekr.20230509052845.3166"><vh>Int.__bool__</vh></v>
<v t="ekr.20230509052845.3167"><vh>Int.__pos__</vh></v>
<v t="ekr.20230509052845.3168"><vh>Int.__neg__</vh></v>
<v t="ekr.20230509052845.3169"><vh>Int.__invert__</vh></v>
<v t="ekr.20230509052845.3170"><vh>Int.__abs__</vh></v>
<v t="ekr.20230509052845.3171"><vh>Int.__add__</vh></v>
<v t="ekr.20230509052845.3172"><vh>Int.__sub__</vh></v>
<v t="ekr.20230509052845.3173"><vh>Int.__mul__</vh></v>
<v t="ekr.20230509052845.3174"><vh>Int._floordiv</vh></v>
<v t="ekr.20230509052845.3175"><vh>Int.__floordiv__</vh></v>
<v t="ekr.20230509052845.3176"><vh>Int.__truediv__</vh></v>
<v t="ekr.20230509052845.3177"><vh>Int._mod</vh></v>
<v t="ekr.20230509052845.3178"><vh>Int.__mod__</vh></v>
<v t="ekr.20230509052845.3179"><vh>Int.__divmod__</vh></v>
<v t="ekr.20230509052845.3180"><vh>Int.__lshift__</vh></v>
<v t="ekr.20230509052845.3181"><vh>Int.__rshift__</vh></v>
<v t="ekr.20230509052845.3182"><vh>Int.__eq__</vh></v>
<v t="ekr.20230509052845.3183"><vh>Int.__ne__</vh></v>
<v t="ekr.20230509052845.3184"><vh>Int.__lt__</vh></v>
<v t="ekr.20230509052845.3185"><vh>Int.__gt__</vh></v>
<v t="ekr.20230509052845.3186"><vh>Int.__le__</vh></v>
<v t="ekr.20230509052845.3187"><vh>Int.__ge__</vh></v>
<v t="ekr.20230509052845.3188"><vh>Int.__and__</vh></v>
<v t="ekr.20230509052845.3189"><vh>Int.__or__</vh></v>
<v t="ekr.20230509052845.3190"><vh>Int.__xor__</vh></v>
<v t="ekr.20230509052845.3191"><vh>Int.__pow__</vh></v>
<v t="ekr.20230509052845.3192"><vh>Int.__repr__</vh></v>
<v t="ekr.20230509052845.3193"><vh>Int._popcnt</vh></v>
<v t="ekr.20230509052845.3194"><vh>Int.popcnt</vh></v>
<v t="ekr.20230509052845.3195"><vh>Int.len</vh></v>
</v>
<v t="ekr.20230509052845.3196"><vh>class UInt</vh>
<v t="ekr.20230509052845.3197"><vh>UInt.__new__</vh></v>
<v t="ekr.20230509052845.3198"><vh>UInt.__new__</vh></v>
<v t="ekr.20230509052845.3199"><vh>UInt.__new__</vh></v>
<v t="ekr.20230509052845.3200"><vh>UInt.__new__</vh></v>
<v t="ekr.20230509052845.3201"><vh>UInt.__new__</vh></v>
<v t="ekr.20230509052845.3202"><vh>UInt.__int__</vh></v>
<v t="ekr.20230509052845.3203"><vh>UInt.__index__</vh></v>
<v t="ekr.20230509052845.3204"><vh>UInt.__copy__</vh></v>
<v t="ekr.20230509052845.3205"><vh>UInt.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3206"><vh>UInt.__hash__</vh></v>
<v t="ekr.20230509052845.3207"><vh>UInt.__float__</vh></v>
<v t="ekr.20230509052845.3208"><vh>UInt.__bool__</vh></v>
<v t="ekr.20230509052845.3209"><vh>UInt.__pos__</vh></v>
<v t="ekr.20230509052845.3210"><vh>UInt.__neg__</vh></v>
<v t="ekr.20230509052845.3211"><vh>UInt.__invert__</vh></v>
<v t="ekr.20230509052845.3212"><vh>UInt.__abs__</vh></v>
<v t="ekr.20230509052845.3213"><vh>UInt.__add__</vh></v>
<v t="ekr.20230509052845.3214"><vh>UInt.__sub__</vh></v>
<v t="ekr.20230509052845.3215"><vh>UInt.__mul__</vh></v>
<v t="ekr.20230509052845.3216"><vh>UInt._floordiv</vh></v>
<v t="ekr.20230509052845.3217"><vh>UInt.__floordiv__</vh></v>
<v t="ekr.20230509052845.3218"><vh>UInt.__truediv__</vh></v>
<v t="ekr.20230509052845.3219"><vh>UInt._mod</vh></v>
<v t="ekr.20230509052845.3220"><vh>UInt.__mod__</vh></v>
<v t="ekr.20230509052845.3221"><vh>UInt.__divmod__</vh></v>
<v t="ekr.20230509052845.3222"><vh>UInt.__lshift__</vh></v>
<v t="ekr.20230509052845.3223"><vh>UInt.__rshift__</vh></v>
<v t="ekr.20230509052845.3224"><vh>UInt.__eq__</vh></v>
<v t="ekr.20230509052845.3225"><vh>UInt.__ne__</vh></v>
<v t="ekr.20230509052845.3226"><vh>UInt.__lt__</vh></v>
<v t="ekr.20230509052845.3227"><vh>UInt.__gt__</vh></v>
<v t="ekr.20230509052845.3228"><vh>UInt.__le__</vh></v>
<v t="ekr.20230509052845.3229"><vh>UInt.__ge__</vh></v>
<v t="ekr.20230509052845.3230"><vh>UInt.__and__</vh></v>
<v t="ekr.20230509052845.3231"><vh>UInt.__or__</vh></v>
<v t="ekr.20230509052845.3232"><vh>UInt.__xor__</vh></v>
<v t="ekr.20230509052845.3233"><vh>UInt.__pow__</vh></v>
<v t="ekr.20230509052845.3234"><vh>UInt.__repr__</vh></v>
<v t="ekr.20230509052845.3235"><vh>UInt.popcnt</vh></v>
<v t="ekr.20230509052845.3236"><vh>UInt.len</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3237"><vh>@@clean optional.codon</vh>
<v t="ekr.20230509052845.3238"><vh>class Optional</vh>
<v t="ekr.20230509052845.3239"><vh>Optional.__new__</vh></v>
<v t="ekr.20230509052845.3240"><vh>Optional.__new__</vh></v>
<v t="ekr.20230509052845.3241"><vh>Optional.__has__</vh></v>
<v t="ekr.20230509052845.3242"><vh>Optional.__val__</vh></v>
<v t="ekr.20230509052845.3243"><vh>Optional.__val_or__</vh></v>
<v t="ekr.20230509052845.3244"><vh>Optional.__bool__</vh></v>
<v t="ekr.20230509052845.3245"><vh>Optional.__eq__</vh></v>
<v t="ekr.20230509052845.3246"><vh>Optional.__eq__</vh></v>
<v t="ekr.20230509052845.3247"><vh>Optional.__ne__</vh></v>
<v t="ekr.20230509052845.3248"><vh>Optional.__ne__</vh></v>
<v t="ekr.20230509052845.3249"><vh>Optional.__str__</vh></v>
<v t="ekr.20230509052845.3250"><vh>Optional.__repr__</vh></v>
<v t="ekr.20230509052845.3251"><vh>Optional.__is_optional__</vh></v>
</v>
<v t="ekr.20230509052845.3252"><vh>optional = Optional</vh></v>
<v t="ekr.20230509052845.3253"><vh>unwrap</vh></v>
</v>
<v t="ekr.20230509052845.3254"><vh>@@clean ptr.codon</vh>
<v t="ekr.20230509052845.3255"><vh>class Ptr</vh>
<v t="ekr.20230509052845.3256"><vh>Ptr.__new__</vh></v>
<v t="ekr.20230509052845.3257"><vh>Ptr.__new__</vh></v>
<v t="ekr.20230509052845.3258"><vh>Ptr.__new__</vh></v>
<v t="ekr.20230509052845.3259"><vh>Ptr.__new__</vh></v>
<v t="ekr.20230509052845.3260"><vh>Ptr.__int__</vh></v>
<v t="ekr.20230509052845.3261"><vh>Ptr.__copy__</vh></v>
<v t="ekr.20230509052845.3262"><vh>Ptr.__bool__</vh></v>
<v t="ekr.20230509052845.3263"><vh>Ptr.__getitem__</vh></v>
<v t="ekr.20230509052845.3264"><vh>Ptr.__setitem__</vh></v>
<v t="ekr.20230509052845.3265"><vh>Ptr.__add__</vh></v>
<v t="ekr.20230509052845.3266"><vh>Ptr.__sub__</vh></v>
<v t="ekr.20230509052845.3267"><vh>Ptr.__sub__</vh></v>
<v t="ekr.20230509052845.3268"><vh>Ptr.__eq__</vh></v>
<v t="ekr.20230509052845.3269"><vh>Ptr.__ne__</vh></v>
<v t="ekr.20230509052845.3270"><vh>Ptr.__lt__</vh></v>
<v t="ekr.20230509052845.3271"><vh>Ptr.__gt__</vh></v>
<v t="ekr.20230509052845.3272"><vh>Ptr.__le__</vh></v>
<v t="ekr.20230509052845.3273"><vh>Ptr.__ge__</vh></v>
<v t="ekr.20230509052845.3274"><vh>Ptr.__prefetch_r0__</vh></v>
<v t="ekr.20230509052845.3275"><vh>Ptr.__prefetch_r1__</vh></v>
<v t="ekr.20230509052845.3276"><vh>Ptr.__prefetch_r2__</vh></v>
<v t="ekr.20230509052845.3277"><vh>Ptr.__prefetch_r3__</vh></v>
<v t="ekr.20230509052845.3278"><vh>Ptr.__prefetch_w0__</vh></v>
<v t="ekr.20230509052845.3279"><vh>Ptr.__prefetch_w1__</vh></v>
<v t="ekr.20230509052845.3280"><vh>Ptr.__prefetch_w2__</vh></v>
<v t="ekr.20230509052845.3281"><vh>Ptr.__prefetch_w3__</vh></v>
<v t="ekr.20230509052845.3282"><vh>Ptr.as_byte</vh></v>
<v t="ekr.20230509052845.3283"><vh>Ptr.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.3284"><vh>ptr = Ptr</vh></v>
<v t="ekr.20230509052845.3285"><vh>class List</vh></v>
<v t="ekr.20230509052845.3286"><vh>class NoneType</vh>
<v t="ekr.20230509052845.3287"><vh>NoneType.__new__</vh></v>
<v t="ekr.20230509052845.3288"><vh>NoneType.__eq__</vh></v>
<v t="ekr.20230509052845.3289"><vh>NoneType.__ne__</vh></v>
<v t="ekr.20230509052845.3290"><vh>NoneType.__bool__</vh></v>
<v t="ekr.20230509052845.3291"><vh>NoneType.__repr__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3292"><vh>@@clean range.codon</vh>
<v t="ekr.20230509052845.3293"><vh>class range</vh>
<v t="ekr.20230509052845.3294"><vh>range.__new__</vh></v>
<v t="ekr.20230509052845.3295"><vh>range.__new__</vh></v>
<v t="ekr.20230509052845.3296"><vh>range.__new__</vh></v>
<v t="ekr.20230509052845.3297"><vh>range._get</vh></v>
<v t="ekr.20230509052845.3298"><vh>range.__getitem__</vh></v>
<v t="ekr.20230509052845.3299"><vh>range.__getitem__</vh></v>
<v t="ekr.20230509052845.3300"><vh>range.__contains__</vh></v>
<v t="ekr.20230509052845.3301"><vh>range._index</vh></v>
<v t="ekr.20230509052845.3302"><vh>range.index</vh></v>
<v t="ekr.20230509052845.3303"><vh>range.count</vh></v>
<v t="ekr.20230509052845.3304"><vh>range.__iter__</vh></v>
<v t="ekr.20230509052845.3305"><vh>range.__len__</vh></v>
<v t="ekr.20230509052845.3306"><vh>range.__bool__</vh></v>
<v t="ekr.20230509052845.3307"><vh>range.__reversed__</vh></v>
<v t="ekr.20230509052845.3308"><vh>range.__repr__</vh></v>
</v>
<v t="ekr.20230509052845.3309"><vh>staticrange</vh></v>
<v t="ekr.20230509052845.3310"><vh>staticrange</vh></v>
</v>
<v t="ekr.20230509052845.3311"><vh>@@clean slice.codon</vh>
<v t="ekr.20230509052845.3312"><vh>class Slice</vh>
<v t="ekr.20230509052845.3313"><vh>Slice.adjust_indices</vh></v>
<v t="ekr.20230509052845.3314"><vh>Slice.adjust_indices_helper</vh></v>
<v t="ekr.20230509052845.3315"><vh>Slice.__repr__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3316"><vh>@@clean str.codon</vh>
<v t="ekr.20230509052845.3317"><vh>strlen</vh></v>
<v t="ekr.20230509052845.3318"><vh>class str</vh>
<v t="ekr.20230509052845.3319"><vh>str.__new__</vh></v>
<v t="ekr.20230509052845.3320"><vh>str.__new__</vh></v>
<v t="ekr.20230509052845.3321"><vh>str.__new__</vh></v>
<v t="ekr.20230509052845.3322"><vh>str.__new__</vh></v>
<v t="ekr.20230509052845.3323"><vh>str.__str__</vh></v>
<v t="ekr.20230509052845.3324"><vh>str.__len__</vh></v>
<v t="ekr.20230509052845.3325"><vh>str.__bool__</vh></v>
<v t="ekr.20230509052845.3326"><vh>str.__copy__</vh></v>
<v t="ekr.20230509052845.3327"><vh>str.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3328"><vh>str.__ptrcopy__</vh></v>
<v t="ekr.20230509052845.3329"><vh>str.memcpy</vh></v>
<v t="ekr.20230509052845.3330"><vh>str.memmove</vh></v>
<v t="ekr.20230509052845.3331"><vh>str.memset</vh></v>
<v t="ekr.20230509052845.3332"><vh>str.__add__</vh></v>
<v t="ekr.20230509052845.3333"><vh>str.c_str</vh></v>
<v t="ekr.20230509052845.3334"><vh>str.from_ptr</vh></v>
<v t="ekr.20230509052845.3335"><vh>str.__eq__</vh></v>
<v t="ekr.20230509052845.3336"><vh>str.__match__</vh></v>
<v t="ekr.20230509052845.3337"><vh>str.__ne__</vh></v>
<v t="ekr.20230509052845.3338"><vh>str.cat</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3339"><vh>@@clean strbuf.codon</vh>
<v t="ekr.20230509052845.3340"><vh>class strbuf</vh>
<v t="ekr.20230509052845.3341"><vh>strbuf.__init__</vh></v>
<v t="ekr.20230509052845.3342"><vh>strbuf.append</vh></v>
<v t="ekr.20230509052845.3343"><vh>strbuf.reverse</vh></v>
<v t="ekr.20230509052845.3344"><vh>strbuf.__str__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3345"><vh>@path collections</vh>
<v t="ekr.20230509052845.3346"><vh>@@clean dict.codon</vh>
<v t="ekr.20230509052845.3347"><vh>_dict_hash</vh></v>
<v t="ekr.20230509052845.3348"><vh>class Dict</vh>
<v t="ekr.20230509052845.3349"><vh>Dict._init</vh></v>
<v t="ekr.20230509052845.3350"><vh>Dict._init_from</vh></v>
<v t="ekr.20230509052845.3351"><vh>Dict.__init__</vh></v>
<v t="ekr.20230509052845.3352"><vh>Dict.__init__</vh></v>
<v t="ekr.20230509052845.3353"><vh>Dict.__init__</vh></v>
<v t="ekr.20230509052845.3354"><vh>Dict.__getitem__</vh></v>
<v t="ekr.20230509052845.3355"><vh>Dict.__setitem__</vh></v>
<v t="ekr.20230509052845.3356"><vh>Dict.__delitem__</vh></v>
<v t="ekr.20230509052845.3357"><vh>Dict.__contains__</vh></v>
<v t="ekr.20230509052845.3358"><vh>Dict.__eq__</vh></v>
<v t="ekr.20230509052845.3359"><vh>Dict.__ne__</vh></v>
<v t="ekr.20230509052845.3360"><vh>Dict.__iter__</vh></v>
<v t="ekr.20230509052845.3361"><vh>Dict.__len__</vh></v>
<v t="ekr.20230509052845.3362"><vh>Dict.__or__</vh></v>
<v t="ekr.20230509052845.3363"><vh>Dict.__ior__</vh></v>
<v t="ekr.20230509052845.3364"><vh>Dict.__copy__</vh></v>
<v t="ekr.20230509052845.3365"><vh>Dict.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3366"><vh>Dict.__repr__</vh></v>
<v t="ekr.20230509052845.3367"><vh>Dict.Helper methods</vh></v>
<v t="ekr.20230509052845.3368"><vh>Dict.resize</vh></v>
<v t="ekr.20230509052845.3369"><vh>Dict.get</vh></v>
<v t="ekr.20230509052845.3370"><vh>Dict.setdefault</vh></v>
<v t="ekr.20230509052845.3371"><vh>Dict.increment</vh></v>
<v t="ekr.20230509052845.3372"><vh>Dict.__dict_do_op_throws__</vh></v>
<v t="ekr.20230509052845.3373"><vh>Dict.__dict_do_op__</vh></v>
<v t="ekr.20230509052845.3374"><vh>Dict.update</vh></v>
<v t="ekr.20230509052845.3375"><vh>Dict.pop</vh></v>
<v t="ekr.20230509052845.3376"><vh>Dict.popitem</vh></v>
<v t="ekr.20230509052845.3377"><vh>Dict.clear</vh></v>
<v t="ekr.20230509052845.3378"><vh>Dict.items</vh></v>
<v t="ekr.20230509052845.3379"><vh>Dict.keys</vh></v>
<v t="ekr.20230509052845.3380"><vh>Dict.values</vh></v>
<v t="ekr.20230509052845.3381"><vh>Dict.copy</vh></v>
<v t="ekr.20230509052845.3382"><vh>Dict.fromkeys</vh></v>
<v t="ekr.20230509052845.3383"><vh>Dict.Internal helpers</vh></v>
<v t="ekr.20230509052845.3384"><vh>Dict._kh_clear</vh></v>
<v t="ekr.20230509052845.3385"><vh>Dict._kh_get</vh></v>
<v t="ekr.20230509052845.3386"><vh>Dict._kh_resize</vh></v>
<v t="ekr.20230509052845.3387"><vh>Dict._kh_put</vh></v>
<v t="ekr.20230509052845.3388"><vh>Dict._kh_del</vh></v>
<v t="ekr.20230509052845.3389"><vh>Dict._kh_begin</vh></v>
<v t="ekr.20230509052845.3390"><vh>Dict._kh_end</vh></v>
<v t="ekr.20230509052845.3391"><vh>Dict._kh_exist</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3392"><vh>@@clean list.codon</vh>
<v t="ekr.20230509052845.3393"><vh>class List</vh>
<v t="ekr.20230509052845.3394"><vh>List.__init__</vh></v>
<v t="ekr.20230509052845.3395"><vh>List.__init__</vh></v>
<v t="ekr.20230509052845.3396"><vh>List.__init__</vh></v>
<v t="ekr.20230509052845.3397"><vh>List.__init__</vh></v>
<v t="ekr.20230509052845.3398"><vh>List.__init__</vh></v>
<v t="ekr.20230509052845.3399"><vh>List._get</vh></v>
<v t="ekr.20230509052845.3400"><vh>List._set</vh></v>
<v t="ekr.20230509052845.3401"><vh>List.__len__</vh></v>
<v t="ekr.20230509052845.3402"><vh>List.__bool__</vh></v>
<v t="ekr.20230509052845.3403"><vh>List.__getitem__</vh></v>
<v t="ekr.20230509052845.3404"><vh>List.__setitem__</vh></v>
<v t="ekr.20230509052845.3405"><vh>List.__delitem__</vh></v>
<v t="ekr.20230509052845.3406"><vh>List.__eq__</vh></v>
<v t="ekr.20230509052845.3407"><vh>List.__ne__</vh></v>
<v t="ekr.20230509052845.3408"><vh>List.__getitem__</vh></v>
<v t="ekr.20230509052845.3409"><vh>List.__setitem__</vh></v>
<v t="ekr.20230509052845.3410"><vh>List.__delitem__</vh></v>
<v t="ekr.20230509052845.3411"><vh>List.__contains__</vh></v>
<v t="ekr.20230509052845.3412"><vh>List.__copy__</vh></v>
<v t="ekr.20230509052845.3413"><vh>List.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3414"><vh>List.__iter__</vh></v>
<v t="ekr.20230509052845.3415"><vh>List.__reversed__</vh></v>
<v t="ekr.20230509052845.3416"><vh>List.__add__</vh></v>
<v t="ekr.20230509052845.3417"><vh>List.__iadd__</vh></v>
<v t="ekr.20230509052845.3418"><vh>List.__mul__</vh></v>
<v t="ekr.20230509052845.3419"><vh>List.__rmul__</vh></v>
<v t="ekr.20230509052845.3420"><vh>List.__imul__</vh></v>
<v t="ekr.20230509052845.3421"><vh>List.__repr__</vh></v>
<v t="ekr.20230509052845.3422"><vh>List.Helper functions</vh></v>
<v t="ekr.20230509052845.3423"><vh>List.append</vh></v>
<v t="ekr.20230509052845.3424"><vh>List.extend</vh></v>
<v t="ekr.20230509052845.3425"><vh>List.insert</vh></v>
<v t="ekr.20230509052845.3426"><vh>List.pop</vh></v>
<v t="ekr.20230509052845.3427"><vh>List.remove</vh></v>
<v t="ekr.20230509052845.3428"><vh>List.clear</vh></v>
<v t="ekr.20230509052845.3429"><vh>List.index</vh></v>
<v t="ekr.20230509052845.3430"><vh>List.count</vh></v>
<v t="ekr.20230509052845.3431"><vh>List.reverse</vh></v>
<v t="ekr.20230509052845.3432"><vh>List.copy</vh></v>
<v t="ekr.20230509052845.3433"><vh>List.Internal helpers</vh></v>
<v t="ekr.20230509052845.3434"><vh>List._idx_check</vh></v>
<v t="ekr.20230509052845.3435"><vh>List._resize</vh></v>
<v t="ekr.20230509052845.3436"><vh>List._resize_if_full</vh></v>
<v t="ekr.20230509052845.3437"><vh>List.__hash__</vh></v>
<v t="ekr.20230509052845.3438"><vh>List._assign_slice</vh></v>
<v t="ekr.20230509052845.3439"><vh>List._copy_arr</vh></v>
<v t="ekr.20230509052845.3440"><vh>List._cmp</vh></v>
<v t="ekr.20230509052845.3441"><vh>List.__lt__</vh></v>
<v t="ekr.20230509052845.3442"><vh>List.__gt__</vh></v>
<v t="ekr.20230509052845.3443"><vh>List.__le__</vh></v>
<v t="ekr.20230509052845.3444"><vh>List.__ge__</vh></v>
<v t="ekr.20230509052845.3445"><vh>List.list addition optimization helpers</vh></v>
<v t="ekr.20230509052845.3446"><vh>List._list_add_opt_default_len</vh></v>
<v t="ekr.20230509052845.3447"><vh>List._list_add_opt_default_append</vh></v>
<v t="ekr.20230509052845.3448"><vh>List._list_add_opt_slice_len</vh></v>
<v t="ekr.20230509052845.3449"><vh>List._list_add_opt_slice_append</vh></v>
<v t="ekr.20230509052845.3450"><vh>List._list_add_opt_literal_append</vh></v>
<v t="ekr.20230509052845.3451"><vh>List._list_add_opt_opt_new</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3452"><vh>@@clean set.codon</vh>
<v t="ekr.20230509052845.3453"><vh>_set_hash</vh></v>
<v t="ekr.20230509052845.3454"><vh>class Set</vh>
<v t="ekr.20230509052845.3455"><vh>Set._init</vh></v>
<v t="ekr.20230509052845.3456"><vh>Set.__init__</vh></v>
<v t="ekr.20230509052845.3457"><vh>Set.__init__</vh></v>
<v t="ekr.20230509052845.3458"><vh>Set.__sub__</vh></v>
<v t="ekr.20230509052845.3459"><vh>Set.__isub__</vh></v>
<v t="ekr.20230509052845.3460"><vh>Set.__and__</vh></v>
<v t="ekr.20230509052845.3461"><vh>Set.__iand__</vh></v>
<v t="ekr.20230509052845.3462"><vh>Set.__or__</vh></v>
<v t="ekr.20230509052845.3463"><vh>Set.__ior__</vh></v>
<v t="ekr.20230509052845.3464"><vh>Set.__xor__</vh></v>
<v t="ekr.20230509052845.3465"><vh>Set.__ixor__</vh></v>
<v t="ekr.20230509052845.3466"><vh>Set.__contains__</vh></v>
<v t="ekr.20230509052845.3467"><vh>Set.__eq__</vh></v>
<v t="ekr.20230509052845.3468"><vh>Set.__ne__</vh></v>
<v t="ekr.20230509052845.3469"><vh>Set.__le__</vh></v>
<v t="ekr.20230509052845.3470"><vh>Set.__ge__</vh></v>
<v t="ekr.20230509052845.3471"><vh>Set.__lt__</vh></v>
<v t="ekr.20230509052845.3472"><vh>Set.__gt__</vh></v>
<v t="ekr.20230509052845.3473"><vh>Set.__iter__</vh></v>
<v t="ekr.20230509052845.3474"><vh>Set.__len__</vh></v>
<v t="ekr.20230509052845.3475"><vh>Set.__bool__</vh></v>
<v t="ekr.20230509052845.3476"><vh>Set.__copy__</vh></v>
<v t="ekr.20230509052845.3477"><vh>Set.__deepcopy__</vh></v>
<v t="ekr.20230509052845.3478"><vh>Set.__repr__</vh></v>
<v t="ekr.20230509052845.3479"><vh>Set.Helper methods</vh></v>
<v t="ekr.20230509052845.3480"><vh>Set.resize</vh></v>
<v t="ekr.20230509052845.3481"><vh>Set.add</vh></v>
<v t="ekr.20230509052845.3482"><vh>Set.update</vh></v>
<v t="ekr.20230509052845.3483"><vh>Set.remove</vh></v>
<v t="ekr.20230509052845.3484"><vh>Set.pop</vh></v>
<v t="ekr.20230509052845.3485"><vh>Set.discard</vh></v>
<v t="ekr.20230509052845.3486"><vh>Set.difference</vh></v>
<v t="ekr.20230509052845.3487"><vh>Set.difference_update</vh></v>
<v t="ekr.20230509052845.3488"><vh>Set.intersection</vh></v>
<v t="ekr.20230509052845.3489"><vh>Set.intersection_update</vh></v>
<v t="ekr.20230509052845.3490"><vh>Set.symmetric_difference</vh></v>
<v t="ekr.20230509052845.3491"><vh>Set.symmetric_difference_update</vh></v>
<v t="ekr.20230509052845.3492"><vh>Set.union</vh></v>
<v t="ekr.20230509052845.3493"><vh>Set.isdisjoint</vh></v>
<v t="ekr.20230509052845.3494"><vh>Set.issubset</vh></v>
<v t="ekr.20230509052845.3495"><vh>Set.issuperset</vh></v>
<v t="ekr.20230509052845.3496"><vh>Set.clear</vh></v>
<v t="ekr.20230509052845.3497"><vh>Set.copy</vh></v>
<v t="ekr.20230509052845.3498"><vh>Set.Internal helpers</vh></v>
<v t="ekr.20230509052845.3499"><vh>Set._kh_clear</vh></v>
<v t="ekr.20230509052845.3500"><vh>Set._kh_get</vh></v>
<v t="ekr.20230509052845.3501"><vh>Set._kh_resize</vh></v>
<v t="ekr.20230509052845.3502"><vh>Set._kh_put</vh></v>
<v t="ekr.20230509052845.3503"><vh>Set._kh_del</vh></v>
<v t="ekr.20230509052845.3504"><vh>Set._kh_begin</vh></v>
<v t="ekr.20230509052845.3505"><vh>Set._kh_end</vh></v>
<v t="ekr.20230509052845.3506"><vh>Set._kh_exist</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3507"><vh>@@clean tuple.codon</vh>
<v t="ekr.20230509052845.3508"><vh>class DynamicTuple</vh>
<v t="ekr.20230509052845.3509"><vh>DynamicTuple.__new__</vh></v>
<v t="ekr.20230509052845.3510"><vh>DynamicTuple.__new__</vh></v>
<v t="ekr.20230509052845.3511"><vh>DynamicTuple.__new__</vh></v>
<v t="ekr.20230509052845.3512"><vh>DynamicTuple.__len__</vh></v>
<v t="ekr.20230509052845.3513"><vh>DynamicTuple.__bool__</vh></v>
<v t="ekr.20230509052845.3514"><vh>DynamicTuple._ensure_tuple</vh></v>
<v t="ekr.20230509052845.3515"><vh>DynamicTuple.__eq__</vh></v>
<v t="ekr.20230509052845.3516"><vh>DynamicTuple.__eq__</vh></v>
<v t="ekr.20230509052845.3517"><vh>DynamicTuple.__ne__</vh></v>
<v t="ekr.20230509052845.3518"><vh>DynamicTuple.__ne__</vh></v>
<v t="ekr.20230509052845.3519"><vh>DynamicTuple._cmp</vh></v>
<v t="ekr.20230509052845.3520"><vh>DynamicTuple._cmp</vh></v>
<v t="ekr.20230509052845.3521"><vh>DynamicTuple.__lt__</vh></v>
<v t="ekr.20230509052845.3522"><vh>DynamicTuple.__gt__</vh></v>
<v t="ekr.20230509052845.3523"><vh>DynamicTuple.__le__</vh></v>
<v t="ekr.20230509052845.3524"><vh>DynamicTuple.__ge__</vh></v>
<v t="ekr.20230509052845.3525"><vh>DynamicTuple.__lt__</vh></v>
<v t="ekr.20230509052845.3526"><vh>DynamicTuple.__gt__</vh></v>
<v t="ekr.20230509052845.3527"><vh>DynamicTuple.__le__</vh></v>
<v t="ekr.20230509052845.3528"><vh>DynamicTuple.__ge__</vh></v>
<v t="ekr.20230509052845.3529"><vh>DynamicTuple.__hash__</vh></v>
<v t="ekr.20230509052845.3530"><vh>DynamicTuple.__iter__</vh></v>
<v t="ekr.20230509052845.3531"><vh>DynamicTuple.__contains__</vh></v>
<v t="ekr.20230509052845.3532"><vh>DynamicTuple.__getitem__</vh></v>
<v t="ekr.20230509052845.3533"><vh>DynamicTuple.__getitem__</vh></v>
<v t="ekr.20230509052845.3534"><vh>DynamicTuple.__repr__</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509052845.3535"><vh>@path os</vh>
<v t="ekr.20230509052845.3536"><vh>@@clean path.codon</vh>
<v t="ekr.20230509052845.3537"><vh>splitext</vh></v>
</v>
<v t="ekr.20230509052845.3538"><vh>@@clean __init__.codon</vh>
<v t="ekr.20230509052845.3539"><vh>system</vh></v>
<v t="ekr.20230509052845.3540"><vh>SEEK_SET = 0</vh></v>
<v t="ekr.20230509052845.3541"><vh>class EnvMap</vh>
<v t="ekr.20230509052845.3542"><vh>EnvMap.__new__</vh></v>
<v t="ekr.20230509052845.3543"><vh>EnvMap._init_if_needed</vh></v>
<v t="ekr.20230509052845.3544"><vh>EnvMap.__getitem__</vh></v>
<v t="ekr.20230509052845.3545"><vh>EnvMap.__repr__</vh></v>
<v t="ekr.20230509052845.3546"><vh>EnvMap.__contains__</vh></v>
<v t="ekr.20230509052845.3547"><vh>EnvMap.__iter__</vh></v>
</v>
<v t="ekr.20230509052845.3548"><vh>environ = EnvMap()</vh></v>
<v t="ekr.20230509052845.3549"><vh>getenv</vh></v>
<v t="ekr.20230509052845.3550"><vh>mkdir</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.3551"><vh>@path test</vh>
<v t="ekr.20230509052845.3552"><vh>@path app</vh>
<v t="ekr.20230509052845.3553"><vh>@@clean argv.codon</vh></v>
<v t="ekr.20230509052845.3554"><vh>@@clean build.codon</vh></v>
<v t="ekr.20230509052845.3555"><vh>@@clean exit.codon</vh></v>
<v t="ekr.20230509052845.3556"><vh>@@clean export.codon</vh></v>
<v t="ekr.20230509052845.3557"><vh>@@clean test.c</vh></v>
</v>
<v t="ekr.20230509052845.3558"><vh>@path cir</vh>
<v t="ekr.20230509052845.3559"><vh>@@clean test.h</vh>
<v t="ekr.20230509052845.3560"><vh>class CIRCoreTest</vh>
<v t="ekr.20230509052845.3561"><vh>CIRCoreTest.void SetUp</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.3562"><vh>@path core</vh>
<v t="ekr.20230509052845.3563"><vh>@@clean arguments.codon</vh>
<v t="ekr.20230509052845.3564"><vh>t1</vh></v>
<v t="ekr.20230509052845.3565"><vh>t1()</vh></v>
<v t="ekr.20230509052845.3566"><vh>class A</vh></v>
<v t="ekr.20230509052845.3567"><vh>t2</vh></v>
<v t="ekr.20230509052845.3568"><vh>t2()</vh></v>
<v t="ekr.20230509052845.3569"><vh>g</vh></v>
<v t="ekr.20230509052845.3570"><vh>t3</vh></v>
<v t="ekr.20230509052845.3571"><vh>t3()</vh></v>
<v t="ekr.20230509052845.3572"><vh>_unwrap</vh></v>
<v t="ekr.20230509052845.3573"><vh>foo</vh></v>
<v t="ekr.20230509052845.3574"><vh>t4</vh></v>
<v t="ekr.20230509052845.3575"><vh>t4()</vh></v>
<v t="ekr.20230509052845.3576"><vh>class A</vh>
<v t="ekr.20230509052845.3577"><vh>A.__init__</vh></v>
<v t="ekr.20230509052845.3578"><vh>A.foo</vh></v>
<v t="ekr.20230509052845.3579"><vh>A.bar</vh></v>
</v>
<v t="ekr.20230509052845.3580"><vh>t5</vh></v>
<v t="ekr.20230509052845.3581"><vh>t5()</vh></v>
<v t="ekr.20230509052845.3582"><vh>t6</vh>
<v t="ekr.20230509052845.3583"><vh>it1</vh></v>
<v t="ekr.20230509052845.3584"><vh>it2</vh></v>
<v t="ekr.20230509052845.3585"><vh>it3</vh></v>
</v>
<v t="ekr.20230509052845.3586"><vh>t6()</vh></v>
<v t="ekr.20230509052845.3587"><vh>class B</vh>
<v t="ekr.20230509052845.3588"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.3589"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.3590"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.3591"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.3592"><vh>B.val</vh></v>
</v>
<v t="ekr.20230509052845.3593"><vh>test_named_construct1</vh></v>
<v t="ekr.20230509052845.3594"><vh>test_named_construct1(0)</vh></v>
<v t="ekr.20230509052845.3595"><vh>class C</vh>
<v t="ekr.20230509052845.3596"><vh>C.__new__</vh></v>
<v t="ekr.20230509052845.3597"><vh>C.__new__</vh></v>
<v t="ekr.20230509052845.3598"><vh>C.__new__</vh></v>
<v t="ekr.20230509052845.3599"><vh>C.__new__</vh></v>
<v t="ekr.20230509052845.3600"><vh>C.val</vh></v>
</v>
<v t="ekr.20230509052845.3601"><vh>test_named_construct2</vh></v>
</v>
<v t="ekr.20230509052845.3602"><vh>@@clean arithmetic.codon</vh>
<v t="ekr.20230509052845.3603"><vh>t1</vh></v>
<v t="ekr.20230509052845.3604"><vh>t1()</vh></v>
<v t="ekr.20230509052845.3605"><vh>test_popcnt</vh></v>
<v t="ekr.20230509052845.3606"><vh>test_popcnt()</vh></v>
<v t="ekr.20230509052845.3607"><vh>test_conversions</vh></v>
<v t="ekr.20230509052845.3608"><vh>test_conversions()</vh></v>
<v t="ekr.20230509052845.3609"><vh>test_int_pow</vh>
<v t="ekr.20230509052845.3610"><vh>f</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3611"><vh>@@clean bltin.codon</vh>
<v t="ekr.20230509052845.3612"><vh>test_min_max</vh></v>
<v t="ekr.20230509052845.3613"><vh>test_map_filter</vh>
<v t="ekr.20230509052845.3614"><vh>f</vh></v>
<v t="ekr.20230509052845.3615"><vh>g</vh></v>
<v t="ekr.20230509052845.3616"><vh>assert list(map(f, map(g, (i*2 for i in range(5))))) == [0, 2, 4, 6, 8]</vh></v>
<v t="ekr.20230509052845.3617"><vh>h</vh></v>
</v>
<v t="ekr.20230509052845.3618"><vh>test_gen_builtins</vh>
<v t="ekr.20230509052845.3619"><vh>g1</vh></v>
<v t="ekr.20230509052845.3620"><vh>assert sum(g1(), 10) == 14.0</vh></v>
<v t="ekr.20230509052845.3621"><vh>g2</vh></v>
<v t="ekr.20230509052845.3622"><vh>assert sum(g2()) == 2</vh></v>
<v t="ekr.20230509052845.3623"><vh>class A</vh></v>
<v t="ekr.20230509052845.3624"><vh>assert sum((A(i) for i in range(5)), A(100)).n == 110</vh></v>
<v t="ekr.20230509052845.3625"><vh>g3</vh></v>
</v>
<v t="ekr.20230509052845.3626"><vh>test_int_format</vh></v>
<v t="ekr.20230509052845.3627"><vh>class A</vh></v>
<v t="ekr.20230509052845.3628"><vh>test_reversed</vh></v>
<v t="ekr.20230509052845.3629"><vh>test_divmod</vh>
<v t="ekr.20230509052845.3630"><vh>class X</vh></v>
</v>
<v t="ekr.20230509052845.3631"><vh>test_pow</vh></v>
<v t="ekr.20230509052845.3632"><vh>test_num_from_str</vh></v>
<v t="ekr.20230509052845.3633"><vh>test_files</vh></v>
<v t="ekr.20230509052845.3634"><vh>test_min_max()</vh></v>
<v t="ekr.20230509052845.3635"><vh>zext</vh></v>
<v t="ekr.20230509052845.3636"><vh>test_narrow_int_str</vh></v>
<v t="ekr.20230509052845.3637"><vh>test_narrow_uint_str</vh></v>
<v t="ekr.20230509052845.3638"><vh>test_wide_int_str</vh></v>
<v t="ekr.20230509052845.3639"><vh>test_wide_uint_str</vh></v>
</v>
<v t="ekr.20230509052845.3640"><vh>@@clean containers.codon</vh>
<v t="ekr.20230509052845.3641"><vh>class A</vh>
<v t="ekr.20230509052845.3642"><vh>A.__getitem__</vh></v>
<v t="ekr.20230509052845.3643"><vh>A.__getitem__</vh></v>
</v>
<v t="ekr.20230509052845.3644"><vh>test_tuple</vh>
<v t="ekr.20230509052845.3645"><vh>test_in</vh></v>
<v t="ekr.20230509052845.3646"><vh>assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]</vh></v>
<v t="ekr.20230509052845.3647"><vh>test_cmp</vh></v>
</v>
<v t="ekr.20230509052845.3648"><vh>test_tuple()</vh></v>
<v t="ekr.20230509052845.3649"><vh>test_dyn_tuple</vh>
<v t="ekr.20230509052845.3650"><vh>D</vh></v>
<v t="ekr.20230509052845.3651"><vh>test_in</vh></v>
<v t="ekr.20230509052845.3652"><vh>assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]</vh></v>
<v t="ekr.20230509052845.3653"><vh>test_cmp</vh></v>
</v>
<v t="ekr.20230509052845.3654"><vh>test_dyn_tuple()</vh></v>
<v t="ekr.20230509052845.3655"><vh>test_list</vh>
<v t="ekr.20230509052845.3656"><vh>test_cmp</vh></v>
</v>
<v t="ekr.20230509052845.3657"><vh>test_list()</vh></v>
<v t="ekr.20230509052845.3658"><vh>test_setslice</vh></v>
<v t="ekr.20230509052845.3659"><vh>test_setslice()</vh></v>
<v t="ekr.20230509052845.3660"><vh>test_delslice</vh></v>
<v t="ekr.20230509052845.3661"><vh>test_delslice()</vh></v>
<v t="ekr.20230509052845.3662"><vh>test_extendedslicing</vh></v>
<v t="ekr.20230509052845.3663"><vh>test_extendedslicing()</vh></v>
<v t="ekr.20230509052845.3664"><vh>test_set</vh></v>
<v t="ekr.20230509052845.3665"><vh>test_set()</vh></v>
<v t="ekr.20230509052845.3666"><vh>test_dict</vh></v>
<v t="ekr.20230509052845.3667"><vh>test_dict()</vh></v>
<v t="ekr.20230509052845.3668"><vh>test_deque</vh></v>
<v t="ekr.20230509052845.3669"><vh>test_deque()</vh></v>
<v t="ekr.20230509052845.3670"><vh>test_counter</vh></v>
<v t="ekr.20230509052845.3671"><vh>test_counter()</vh></v>
<v t="ekr.20230509052845.3672"><vh>test_defaultdict</vh>
<v t="ekr.20230509052845.3673"><vh>foo</vh></v>
<v t="ekr.20230509052845.3674"><vh>d3 = defaultdict(foo)</vh></v>
<v t="ekr.20230509052845.3675"><vh>constant_factory</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3676"><vh>@@clean empty.codon</vh></v>
<v t="ekr.20230509052845.3677"><vh>@@clean exceptions.codon</vh>
<v t="ekr.20230509052845.3678"><vh>class Exc1</vh></v>
<v t="ekr.20230509052845.3679"><vh>class Exc2</vh></v>
<v t="ekr.20230509052845.3680"><vh>class A</vh></v>
<v t="ekr.20230509052845.3681"><vh>class B</vh></v>
<v t="ekr.20230509052845.3682"><vh>class C</vh></v>
<v t="ekr.20230509052845.3683"><vh>class D</vh></v>
<v t="ekr.20230509052845.3684"><vh>class E</vh></v>
<v t="ekr.20230509052845.3685"><vh>foo1</vh></v>
<v t="ekr.20230509052845.3686"><vh>foo2</vh></v>
<v t="ekr.20230509052845.3687"><vh>foo</vh></v>
<v t="ekr.20230509052845.3688"><vh>square</vh></v>
<v t="ekr.20230509052845.3689"><vh>bar</vh></v>
<v t="ekr.20230509052845.3690"><vh>baz</vh></v>
<v t="ekr.20230509052845.3691"><vh>baz1</vh></v>
<v t="ekr.20230509052845.3692"><vh>baz2</vh></v>
<v t="ekr.20230509052845.3693"><vh>nest1</vh></v>
<v t="ekr.20230509052845.3694"><vh>nest2</vh></v>
<v t="ekr.20230509052845.3695"><vh>nest3</vh></v>
<v t="ekr.20230509052845.3696"><vh>finally_return</vh></v>
<v t="ekr.20230509052845.3697"><vh>finally_return_void</vh></v>
<v t="ekr.20230509052845.3698"><vh>finally_break_continue1</vh></v>
<v t="ekr.20230509052845.3699"><vh>finally_break_continue2</vh></v>
<v t="ekr.20230509052845.3700"><vh>finally_break_continue3</vh></v>
<v t="ekr.20230509052845.3701"><vh>test_try_with_loop1</vh></v>
<v t="ekr.20230509052845.3702"><vh>test_try_with_loop2</vh></v>
<v t="ekr.20230509052845.3703"><vh>test_try_with_loop3</vh></v>
<v t="ekr.20230509052845.3704"><vh>test_try_with_loop4</vh></v>
<v t="ekr.20230509052845.3705"><vh>EXPECT: try</vh></v>
<v t="ekr.20230509052845.3706"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3707"><vh>class Bar</vh></v>
<v t="ekr.20230509052845.3708"><vh>test_with</vh></v>
<v t="ekr.20230509052845.3709"><vh>EXPECT: &gt; foo! 0</vh></v>
<v t="ekr.20230509052845.3710"><vh>class PropClass</vh></v>
<v t="ekr.20230509052845.3711"><vh>test_property_exceptions</vh></v>
<v t="ekr.20230509052845.3712"><vh>EXPECT: foo</vh></v>
<v t="ekr.20230509052845.3713"><vh>test_empty_raise</vh>
<v t="ekr.20230509052845.3714"><vh>foo</vh></v>
<v t="ekr.20230509052845.3715"><vh>bar</vh></v>
<v t="ekr.20230509052845.3716"><vh>baz</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3717"><vh>@@clean generators.codon</vh>
<v t="ekr.20230509052845.3718"><vh>perms</vh></v>
<v t="ekr.20230509052845.3719"><vh>for a in perms([1,2,3,4]):</vh></v>
<v t="ekr.20230509052845.3720"><vh>mysum</vh></v>
<v t="ekr.20230509052845.3721"><vh>iadder = mysum(0)</vh></v>
<v t="ekr.20230509052845.3722"><vh>test_generator_in_finally</vh>
<v t="ekr.20230509052845.3723"><vh>foo</vh></v>
</v>
</v>
<v t="ekr.20230509052845.3724"><vh>@@clean generics.codon</vh>
<v t="ekr.20230509052845.3725"><vh>class A</vh>
<v t="ekr.20230509052845.3726"><vh>A.dump</vh></v>
<v t="ekr.20230509052845.3727"><vh>A.m0</vh></v>
<v t="ekr.20230509052845.3728"><vh>A.m1</vh></v>
<v t="ekr.20230509052845.3729"><vh>A.m2</vh></v>
<v t="ekr.20230509052845.3730"><vh>A.m3</vh></v>
<v t="ekr.20230509052845.3731"><vh>A.m4</vh></v>
<v t="ekr.20230509052845.3732"><vh>A.m5</vh></v>
<v t="ekr.20230509052845.3733"><vh>A.m6</vh></v>
</v>
<v t="ekr.20230509052845.3734"><vh>m7</vh></v>
<v t="ekr.20230509052845.3735"><vh>class B1</vh></v>
<v t="ekr.20230509052845.3736"><vh>class B2</vh></v>
<v t="ekr.20230509052845.3737"><vh>a1 = A(42, 3.14, "hello")</vh></v>
<v t="ekr.20230509052845.3738"><vh>foo</vh></v>
<v t="ekr.20230509052845.3739"><vh>EXPECT: True</vh></v>
<v t="ekr.20230509052845.3740"><vh>bar</vh></v>
</v>
<v t="ekr.20230509052845.3741"><vh>@@clean helloworld.codon</vh></v>
<v t="ekr.20230509052845.3742"><vh>@@clean llvmops.codon</vh>
<v t="ekr.20230509052845.3743"><vh>test_int_llvm_ops</vh></v>
<v t="ekr.20230509052845.3744"><vh>test_float_llvm_ops</vh>
<v t="ekr.20230509052845.3745"><vh>approx_eq</vh></v>
</v>
<v t="ekr.20230509052845.3746"><vh>test_conversion_llvm_ops</vh></v>
<v t="ekr.20230509052845.3747"><vh>test_str_llvm_ops</vh></v>
</v>
<v t="ekr.20230509052845.3748"><vh>@@clean match.codon</vh>
<v t="ekr.20230509052845.3749"><vh>test_bool_match</vh></v>
<v t="ekr.20230509052845.3750"><vh>test_bool_match()</vh></v>
<v t="ekr.20230509052845.3751"><vh>test_str_match</vh></v>
<v t="ekr.20230509052845.3752"><vh>test_str_match()</vh></v>
<v t="ekr.20230509052845.3753"><vh>test_tuple_match</vh></v>
<v t="ekr.20230509052845.3754"><vh>test_tuple_match()</vh></v>
<v t="ekr.20230509052845.3755"><vh>test_int_match</vh></v>
<v t="ekr.20230509052845.3756"><vh>test_int_match()</vh></v>
<v t="ekr.20230509052845.3757"><vh>test_list_match</vh></v>
</v>
<v t="ekr.20230509052845.3758"><vh>@@clean numerics.codon</vh>
<v t="ekr.20230509052845.3759"><vh>test_py_numerics_int</vh></v>
<v t="ekr.20230509052845.3760"><vh>test_py_numerics_float</vh></v>
<v t="ekr.20230509052845.3761"><vh>import math</vh></v>
<v t="ekr.20230509052845.3762"><vh>close</vh></v>
<v t="ekr.20230509052845.3763"><vh>test_isnan</vh></v>
<v t="ekr.20230509052845.3764"><vh>test_isinf</vh></v>
<v t="ekr.20230509052845.3765"><vh>test_isfinite</vh></v>
<v t="ekr.20230509052845.3766"><vh>test_ceil</vh></v>
<v t="ekr.20230509052845.3767"><vh>test_floor</vh></v>
<v t="ekr.20230509052845.3768"><vh>test_fabs</vh></v>
<v t="ekr.20230509052845.3769"><vh>test_fmod</vh></v>
<v t="ekr.20230509052845.3770"><vh>test_exp</vh></v>
<v t="ekr.20230509052845.3771"><vh>test_expm1</vh></v>
<v t="ekr.20230509052845.3772"><vh>test_ldexp</vh></v>
<v t="ekr.20230509052845.3773"><vh>test_log</vh></v>
<v t="ekr.20230509052845.3774"><vh>test_log2</vh></v>
<v t="ekr.20230509052845.3775"><vh>test_log10</vh></v>
<v t="ekr.20230509052845.3776"><vh>test_degrees</vh></v>
<v t="ekr.20230509052845.3777"><vh>test_radians</vh></v>
<v t="ekr.20230509052845.3778"><vh>test_sqrt</vh></v>
<v t="ekr.20230509052845.3779"><vh>test_pow</vh></v>
<v t="ekr.20230509052845.3780"><vh>test_acos</vh></v>
<v t="ekr.20230509052845.3781"><vh>test_asin</vh></v>
<v t="ekr.20230509052845.3782"><vh>test_atan</vh></v>
<v t="ekr.20230509052845.3783"><vh>test_atan2</vh></v>
<v t="ekr.20230509052845.3784"><vh>test_cos</vh></v>
<v t="ekr.20230509052845.3785"><vh>test_sin</vh></v>
<v t="ekr.20230509052845.3786"><vh>test_hypot</vh></v>
<v t="ekr.20230509052845.3787"><vh>test_tan</vh></v>
<v t="ekr.20230509052845.3788"><vh>test_cosh</vh></v>
<v t="ekr.20230509052845.3789"><vh>test_sinh</vh></v>
<v t="ekr.20230509052845.3790"><vh>test_tanh</vh></v>
<v t="ekr.20230509052845.3791"><vh>test_acosh</vh></v>
<v t="ekr.20230509052845.3792"><vh>test_asinh</vh></v>
<v t="ekr.20230509052845.3793"><vh>test_atanh</vh></v>
<v t="ekr.20230509052845.3794"><vh>test_copysign</vh></v>
<v t="ekr.20230509052845.3795"><vh>test_log1p</vh></v>
<v t="ekr.20230509052845.3796"><vh>test_trunc</vh></v>
<v t="ekr.20230509052845.3797"><vh>test_erf</vh></v>
<v t="ekr.20230509052845.3798"><vh>test_erfc</vh></v>
<v t="ekr.20230509052845.3799"><vh>test_gamma</vh></v>
<v t="ekr.20230509052845.3800"><vh>test_lgamma</vh></v>
<v t="ekr.20230509052845.3801"><vh>test_remainder</vh></v>
<v t="ekr.20230509052845.3802"><vh>test_gcd</vh></v>
<v t="ekr.20230509052845.3803"><vh>test_frexp</vh></v>
<v t="ekr.20230509052845.3804"><vh>test_modf</vh></v>
<v t="ekr.20230509052845.3805"><vh>test_isclose</vh></v>
</v>
<v t="ekr.20230509052845.3806"><vh>@@clean parser.codon</vh></v>
<v t="ekr.20230509052845.3807"><vh>@@clean pipeline.codon</vh>
<v t="ekr.20230509052845.3808"><vh>inc</vh></v>
<v t="ekr.20230509052845.3809"><vh>dec</vh></v>
<v t="ekr.20230509052845.3810"><vh>lock = Lock()</vh></v>
<v t="ekr.20230509052845.3811"><vh>inc_lock</vh></v>
<v t="ekr.20230509052845.3812"><vh>dec_lock</vh></v>
<v t="ekr.20230509052845.3813"><vh>rlock = RLock()</vh></v>
<v t="ekr.20230509052845.3814"><vh>inc_rlock</vh></v>
<v t="ekr.20230509052845.3815"><vh>dec_rlock</vh></v>
<v t="ekr.20230509052845.3816"><vh>foo</vh></v>
<v t="ekr.20230509052845.3817"><vh>test_parallel_pipe</vh></v>
<v t="ekr.20230509052845.3818"><vh>test_nested_parallel_pipe</vh></v>
</v>
<v t="ekr.20230509052845.3819"><vh>@@clean range.codon</vh>
<v t="ekr.20230509052845.3820"><vh>test_range</vh></v>
<v t="ekr.20230509052845.3821"><vh>test_index</vh></v>
<v t="ekr.20230509052845.3822"><vh>test_count</vh></v>
<v t="ekr.20230509052845.3823"><vh>test_repr</vh></v>
<v t="ekr.20230509052845.3824"><vh>test_strided_limits</vh></v>
<v t="ekr.20230509052845.3825"><vh>test_empty</vh></v>
<v t="ekr.20230509052845.3826"><vh>test_slice</vh></v>
<v t="ekr.20230509052845.3827"><vh>test_contains</vh></v>
<v t="ekr.20230509052845.3828"><vh>test_reverse_iteration</vh></v>
</v>
<v t="ekr.20230509052845.3829"><vh>@@clean serialization.codon</vh>
<v t="ekr.20230509052845.3830"><vh>class MyType</vh></v>
<v t="ekr.20230509052845.3831"><vh>class A</vh>
<v t="ekr.20230509052845.3832"><vh>A.__eq__</vh></v>
<v t="ekr.20230509052845.3833"><vh>A.__ne__</vh></v>
<v t="ekr.20230509052845.3834"><vh>A.__hash__</vh></v>
<v t="ekr.20230509052845.3835"><vh>A.__copy__</vh></v>
</v>
<v t="ekr.20230509052845.3836"><vh>test_pickle</vh></v>
<v t="ekr.20230509052845.3837"><vh>test_non_atomic_list_pickle</vh></v>
<v t="ekr.20230509052845.3838"><vh>test_non_atomic_dict_pickle</vh></v>
<v t="ekr.20230509052845.3839"><vh>test_non_atomic_set_pickle</vh></v>
</v>
<v t="ekr.20230509052845.3840"><vh>@@clean sort.codon</vh>
<v t="ekr.20230509052845.3841"><vh>print_test</vh></v>
<v t="ekr.20230509052845.3842"><vh>## Comparison Functions ###</vh></v>
<v t="ekr.20230509052845.3843"><vh>compare_less</vh></v>
<v t="ekr.20230509052845.3844"><vh>compare_greater</vh></v>
<v t="ekr.20230509052845.3845"><vh>compare_string</vh></v>
<v t="ekr.20230509052845.3846"><vh>compare_dict</vh></v>
<v t="ekr.20230509052845.3847"><vh>## Basic Sort Tests ###</vh></v>
<v t="ekr.20230509052845.3848"><vh>test_stable</vh></v>
</v>
<v t="ekr.20230509052845.3849"><vh>@@clean trees.codon</vh>
<v t="ekr.20230509052845.3850"><vh>max</vh></v>
<v t="ekr.20230509052845.3851"><vh>class AVLNode</vh>
<v t="ekr.20230509052845.3852"><vh>AVLNode.__init__</vh></v>
<v t="ekr.20230509052845.3853"><vh>AVLNode.find</vh></v>
<v t="ekr.20230509052845.3854"><vh>AVLNode.find_min</vh></v>
<v t="ekr.20230509052845.3855"><vh>AVLNode.next_larger</vh></v>
<v t="ekr.20230509052845.3856"><vh>AVLNode.insert</vh></v>
<v t="ekr.20230509052845.3857"><vh>AVLNode.delete</vh></v>
<v t="ekr.20230509052845.3858"><vh>AVLNode.__iter__</vh></v>
</v>
<v t="ekr.20230509052845.3859"><vh>height</vh></v>
<v t="ekr.20230509052845.3860"><vh>update_height</vh></v>
<v t="ekr.20230509052845.3861"><vh>class AVL</vh>
<v t="ekr.20230509052845.3862"><vh>AVL.__init__</vh></v>
<v t="ekr.20230509052845.3863"><vh>AVL.find</vh></v>
<v t="ekr.20230509052845.3864"><vh>AVL.find_min</vh></v>
<v t="ekr.20230509052845.3865"><vh>AVL.next_larger</vh></v>
<v t="ekr.20230509052845.3866"><vh>AVL.left_rotate</vh></v>
<v t="ekr.20230509052845.3867"><vh>AVL.right_rotate</vh></v>
<v t="ekr.20230509052845.3868"><vh>AVL.rebalance</vh></v>
<v t="ekr.20230509052845.3869"><vh>AVL.insert</vh></v>
<v t="ekr.20230509052845.3870"><vh>AVL.delete</vh></v>
<v t="ekr.20230509052845.3871"><vh>AVL.__setitem__</vh></v>
<v t="ekr.20230509052845.3872"><vh>AVL.__getitem__</vh></v>
<v t="ekr.20230509052845.3873"><vh>AVL.__delitem__</vh></v>
<v t="ekr.20230509052845.3874"><vh>AVL.__contains__</vh></v>
<v t="ekr.20230509052845.3875"><vh>AVL.__iter__</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509052845.3876"><vh>@path parser</vh>
<v t="ekr.20230509052845.3877"><vh>@@clean llvm.codon</vh>
<v t="ekr.20230509052845.3878"><vh>foo</vh></v>
</v>
<v t="ekr.20230509052845.3879"><vh>@@clean simplify_expr.codon</vh>
<v t="ekr.20230509052845.3880"><vh>class Optional</vh></v>
<v t="ekr.20230509052845.3881"><vh>a = None</vh></v>
<v t="ekr.20230509052845.3882"><vh>class int</vh></v>
<v t="ekr.20230509052845.3883"><vh>print 123_456test #: TEST: 123456</vh></v>
<v t="ekr.20230509052845.3884"><vh>class float</vh></v>
<v t="ekr.20230509052845.3885"><vh>print 1.2e-1zoo #: 0.12_zoo</vh></v>
<v t="ekr.20230509052845.3886"><vh>class str</vh></v>
<v t="ekr.20230509052845.3887"><vh>print pfx'HELLO' #: PFX HELLO</vh></v>
<v t="ekr.20230509052845.3888"><vh>class str</vh></v>
<v t="ekr.20230509052845.3889"><vh>print pxf'HELLO' #: PXF HELLO 5</vh></v>
<v t="ekr.20230509052845.3890"><vh>foo</vh></v>
<v t="ekr.20230509052845.3891"><vh>foo()</vh></v>
<v t="ekr.20230509052845.3892"><vh>fox</vh></v>
<v t="ekr.20230509052845.3893"><vh>fox()()</vh></v>
<v t="ekr.20230509052845.3894"><vh>class List</vh></v>
<v t="ekr.20230509052845.3895"><vh>foo</vh></v>
<v t="ekr.20230509052845.3896"><vh>print [i for i in range(3)] #: optimize 3</vh></v>
<v t="ekr.20230509052845.3897"><vh>nest</vh></v>
<v t="ekr.20230509052845.3898"><vh>nest(4)</vh></v>
<v t="ekr.20230509052845.3899"><vh>foo</vh></v>
<v t="ekr.20230509052845.3900"><vh>a = b = c = foo() #: foo</vh></v>
<v t="ekr.20230509052845.3901"><vh>b</vh></v>
<v t="ekr.20230509052845.3902"><vh>1 |&gt; b(1, ..., 2, ...)  #! multiple ellipsis expressions</vh></v>
<v t="ekr.20230509052845.3903"><vh>foo</vh></v>
<v t="ekr.20230509052845.3904"><vh>f: Callable[[int], int] = foo</vh></v>
<v t="ekr.20230509052845.3905"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3906"><vh>f = Foo()</vh></v>
<v t="ekr.20230509052845.3907"><vh>foo</vh></v>
<v t="ekr.20230509052845.3908"><vh>f1 = partial(foo, 1, z=3)</vh></v>
<v t="ekr.20230509052845.3909"><vh>foo</vh></v>
<v t="ekr.20230509052845.3910"><vh>print foo(4, lp) #: 11</vh></v>
<v t="ekr.20230509052845.3911"><vh>foox</vh></v>
<v t="ekr.20230509052845.3912"><vh>print foox(4, lp) #: 11</vh></v>
<v t="ekr.20230509052845.3913"><vh>foo</vh></v>
<v t="ekr.20230509052845.3914"><vh>foo()  #: [0, 1, 4]</vh></v>
<v t="ekr.20230509052845.3915"><vh>foo</vh></v>
<v t="ekr.20230509052845.3916"><vh>if x := foo(4):</vh></v>
<v t="ekr.20230509052845.3917"><vh>foo</vh></v>
<v t="ekr.20230509052845.3918"><vh>x = 5</vh></v>
<v t="ekr.20230509052845.3919"><vh>foo</vh></v>
<v t="ekr.20230509052845.3920"><vh>if False or (x := foo(4)):</vh></v>
<v t="ekr.20230509052845.3921"><vh>foo</vh></v>
<v t="ekr.20230509052845.3922"><vh>if False and (x := foo(4)):</vh></v>
<v t="ekr.20230509052845.3923"><vh>foo</vh></v>
<v t="ekr.20230509052845.3924"><vh>%% unpack_specials,barebones</vh></v>
<v t="ekr.20230509052845.3925"><vh>goo</vh>
<v t="ekr.20230509052845.3926"><vh>foo</vh></v>
</v>
<v t="ekr.20230509052845.3927"><vh>b = goo('s')</vh></v>
<v t="ekr.20230509052845.3928"><vh>goo</vh></v>
<v t="ekr.20230509052845.3929"><vh>goo()  #! local variable 'z' referenced before assignment</vh></v>
<v t="ekr.20230509052845.3930"><vh>foo</vh></v>
</v>
<v t="ekr.20230509052845.3931"><vh>@@clean typecheck_expr.codon</vh>
<v t="ekr.20230509052845.3932"><vh>foo</vh></v>
<v t="ekr.20230509052845.3933"><vh>foo(5) #: 5</vh></v>
<v t="ekr.20230509052845.3934"><vh>fox</vh></v>
<v t="ekr.20230509052845.3935"><vh>fox(6) #: 6</vh></v>
<v t="ekr.20230509052845.3936"><vh>class float</vh>
<v t="ekr.20230509052845.3937"><vh>float.__add__</vh></v>
<v t="ekr.20230509052845.3938"><vh>float.__sub__</vh></v>
<v t="ekr.20230509052845.3939"><vh>float.__mul__</vh></v>
<v t="ekr.20230509052845.3940"><vh>float.__pow__</vh></v>
<v t="ekr.20230509052845.3941"><vh>float.__truediv__</vh></v>
<v t="ekr.20230509052845.3942"><vh>float.__floordiv__</vh></v>
<v t="ekr.20230509052845.3943"><vh>float.__matmul__</vh></v>
<v t="ekr.20230509052845.3944"><vh>float.__mod__</vh></v>
<v t="ekr.20230509052845.3945"><vh>float.__lt__</vh></v>
<v t="ekr.20230509052845.3946"><vh>float.__le__</vh></v>
<v t="ekr.20230509052845.3947"><vh>float.__gt__</vh></v>
<v t="ekr.20230509052845.3948"><vh>float.__ge__</vh></v>
<v t="ekr.20230509052845.3949"><vh>float.__eq__</vh></v>
<v t="ekr.20230509052845.3950"><vh>float.__ne__</vh></v>
<v t="ekr.20230509052845.3951"><vh>float.__lshift__</vh></v>
<v t="ekr.20230509052845.3952"><vh>float.__rshift__</vh></v>
<v t="ekr.20230509052845.3953"><vh>float.__and__</vh></v>
<v t="ekr.20230509052845.3954"><vh>float.__or__</vh></v>
<v t="ekr.20230509052845.3955"><vh>float.__xor__</vh></v>
</v>
<v t="ekr.20230509052845.3956"><vh>f</vh></v>
<v t="ekr.20230509052845.3957"><vh>a = f(1.0)</vh></v>
<v t="ekr.20230509052845.3958"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3959"><vh>foo = Foo[int]()</vh></v>
<v t="ekr.20230509052845.3960"><vh>moo</vh></v>
<v t="ekr.20230509052845.3961"><vh>print True or moo() #: True</vh></v>
<v t="ekr.20230509052845.3962"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3963"><vh>x = Foo(1)</vh></v>
<v t="ekr.20230509052845.3964"><vh>foo</vh></v>
<v t="ekr.20230509052845.3965"><vh>bar = lambda c, d: c+d</vh></v>
<v t="ekr.20230509052845.3966"><vh>hai</vh></v>
<v t="ekr.20230509052845.3967"><vh>echo</vh></v>
<v t="ekr.20230509052845.3968"><vh>foo(1,2) |&gt; bar(4) |&gt; echo  #: 7</vh></v>
<v t="ekr.20230509052845.3969"><vh>foo</vh></v>
<v t="ekr.20230509052845.3970"><vh>5 |&gt; foo #: 5</vh></v>
<v t="ekr.20230509052845.3971"><vh>foo2</vh></v>
<v t="ekr.20230509052845.3972"><vh>Optional(5) |&gt; foo2 #: 5</vh></v>
<v t="ekr.20230509052845.3973"><vh>foo2</vh></v>
<v t="ekr.20230509052845.3974"><vh>try:</vh></v>
<v t="ekr.20230509052845.3975"><vh>foo</vh></v>
<v t="ekr.20230509052845.3976"><vh>foo(int, float)  #! foo() takes 1 arguments (2 given)</vh></v>
<v t="ekr.20230509052845.3977"><vh>foo</vh></v>
<v t="ekr.20230509052845.3978"><vh>foo(int)  #! generic 'T' not provided</vh></v>
<v t="ekr.20230509052845.3979"><vh>foo</vh></v>
<v t="ekr.20230509052845.3980"><vh>print (foo(2), foo(1))[::-1]</vh></v>
<v t="ekr.20230509052845.3981"><vh>class X</vh></v>
<v t="ekr.20230509052845.3982"><vh>x = X()</vh></v>
<v t="ekr.20230509052845.3983"><vh>class Foo</vh>
<v t="ekr.20230509052845.3984"><vh>Foo.bar</vh></v>
<v t="ekr.20230509052845.3985"><vh>Foo.bar</vh></v>
<v t="ekr.20230509052845.3986"><vh>Foo.bar</vh></v>
</v>
<v t="ekr.20230509052845.3987"><vh>f = Foo()</vh></v>
<v t="ekr.20230509052845.3988"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3989"><vh>f = Foo()</vh></v>
<v t="ekr.20230509052845.3990"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3991"><vh>Foo.clsmethod() #: foo</vh></v>
<v t="ekr.20230509052845.3992"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.3993"><vh>Foo().clsmethod() #! 'Foo' object has no method 'clsmethod' with arguments (Foo)</vh></v>
<v t="ekr.20230509052845.3994"><vh>foo</vh></v>
<v t="ekr.20230509052845.3995"><vh>class Foo</vh>
<v t="ekr.20230509052845.3996"><vh>Foo.__init__</vh></v>
<v t="ekr.20230509052845.3997"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.3998"><vh>Foo.bar</vh></v>
<v t="ekr.20230509052845.3999"><vh>Foo.__call__</vh></v>
</v>
<v t="ekr.20230509052845.4000"><vh>foo(1, 2.2, True) #: foo 1 2.2 True</vh></v>
<v t="ekr.20230509052845.4001"><vh>class Moo</vh></v>
<v t="ekr.20230509052845.4002"><vh>print Moo(1) #: Moo.__new__</vh></v>
<v t="ekr.20230509052845.4003"><vh>class A</vh></v>
<v t="ekr.20230509052845.4004"><vh>a = A() #! argument 'a' has recursive default value</vh></v>
<v t="ekr.20230509052845.4005"><vh>class G</vh></v>
<v t="ekr.20230509052845.4006"><vh>class A</vh></v>
<v t="ekr.20230509052845.4007"><vh>a = A() #! argument 'ga' has recursive default value</vh></v>
<v t="ekr.20230509052845.4008"><vh>foo</vh></v>
<v t="ekr.20230509052845.4009"><vh>print foo(1.1, 2.2, 3.3)  #: 6.6</vh></v>
<v t="ekr.20230509052845.4010"><vh>moo</vh></v>
<v t="ekr.20230509052845.4011"><vh>m = moo(b=2, ...)</vh></v>
<v t="ekr.20230509052845.4012"><vh>ff</vh></v>
<v t="ekr.20230509052845.4013"><vh>print ff(1.1, 2, True).__class__.__name__ #: Tuple[float,int,bool]</vh></v>
<v t="ekr.20230509052845.4014"><vh>fx</vh></v>
<v t="ekr.20230509052845.4015"><vh>f1 = fx(1, x=1, ...)</vh></v>
<v t="ekr.20230509052845.4016"><vh>doo</vh></v>
<v t="ekr.20230509052845.4017"><vh>l = [1, 2, 3]</vh></v>
<v t="ekr.20230509052845.4018"><vh>adder</vh></v>
<v t="ekr.20230509052845.4019"><vh>doo(b=l, d=Optional(5), c=l[0], a=adder(b=4, ...))</vh></v>
<v t="ekr.20230509052845.4020"><vh>foo</vh></v>
<v t="ekr.20230509052845.4021"><vh>p = foo(...)</vh></v>
<v t="ekr.20230509052845.4022"><vh>foo</vh></v>
<v t="ekr.20230509052845.4023"><vh>foo(1, f=1)  #: (1) (f: 1) Tuple[float]</vh></v>
<v t="ekr.20230509052845.4024"><vh>sum</vh></v>
<v t="ekr.20230509052845.4025"><vh>sum_gens</vh></v>
<v t="ekr.20230509052845.4026"><vh>print sum_gens([1, 2, 3])  #: 6</vh></v>
<v t="ekr.20230509052845.4027"><vh>kwhatever</vh></v>
<v t="ekr.20230509052845.4028"><vh>whatever</vh></v>
<v t="ekr.20230509052845.4029"><vh>foo</vh></v>
<v t="ekr.20230509052845.4030"><vh>foo(1, 2, 3, 4, 5, arg1='s', kwa=2)</vh></v>
<v t="ekr.20230509052845.4031"><vh>foo</vh></v>
<v t="ekr.20230509052845.4032"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4033"><vh>t = (1, 's')</vh></v>
<v t="ekr.20230509052845.4034"><vh>foo</vh></v>
<v t="ekr.20230509052845.4035"><vh>a = foo(1, 2, ...)</vh></v>
<v t="ekr.20230509052845.4036"><vh>fox</vh></v>
<v t="ekr.20230509052845.4037"><vh>xa = fox(1, 2, x=5, ...)</vh></v>
<v t="ekr.20230509052845.4038"><vh>class Foo</vh>
<v t="ekr.20230509052845.4039"><vh>Foo.__str__</vh></v>
<v t="ekr.20230509052845.4040"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.4041"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.4042"><vh>Foo.foo</vh></v>
</v>
<v t="ekr.20230509052845.4043"><vh>f = Foo(4)</vh></v>
<v t="ekr.20230509052845.4044"><vh>pacman</vh></v>
<v t="ekr.20230509052845.4045"><vh>pacman(f, Foo.foo)</vh></v>
<v t="ekr.20230509052845.4046"><vh>macman</vh></v>
<v t="ekr.20230509052845.4047"><vh>macman(f.foo)</vh></v>
<v t="ekr.20230509052845.4048"><vh>class Fox</vh>
<v t="ekr.20230509052845.4049"><vh>Fox.__str__</vh></v>
<v t="ekr.20230509052845.4050"><vh>Fox.foo</vh></v>
<v t="ekr.20230509052845.4051"><vh>Fox.foo</vh></v>
<v t="ekr.20230509052845.4052"><vh>Fox.foo</vh></v>
<v t="ekr.20230509052845.4053"><vh>Fox.foo</vh></v>
</v>
<v t="ekr.20230509052845.4054"><vh>ff = Fox(5)</vh></v>
<v t="ekr.20230509052845.4055"><vh>maxman</vh></v>
<v t="ekr.20230509052845.4056"><vh>maxman(ff.foo)</vh></v>
<v t="ekr.20230509052845.4057"><vh>class AX</vh></v>
<v t="ekr.20230509052845.4058"><vh>class Side</vh></v>
<v t="ekr.20230509052845.4059"><vh>class BX</vh></v>
<v t="ekr.20230509052845.4060"><vh>class CX</vh></v>
<v t="ekr.20230509052845.4061"><vh>c = CX('a', False)</vh></v>
<v t="ekr.20230509052845.4062"><vh>mysum</vh></v>
<v t="ekr.20230509052845.4063"><vh>iadder = mysum(0)</vh></v>
<v t="ekr.20230509052845.4064"><vh>foo</vh></v>
<v t="ekr.20230509052845.4065"><vh>foo(1)</vh></v>
<v t="ekr.20230509052845.4066"><vh>class unpackable_plain</vh></v>
<v t="ekr.20230509052845.4067"><vh>u = unpackable_plain(1, 'str')</vh></v>
<v t="ekr.20230509052845.4068"><vh>class unpackable_gen</vh></v>
<v t="ekr.20230509052845.4069"><vh>u2 = unpackable_gen(1, 'str')</vh></v>
<v t="ekr.20230509052845.4070"><vh>class plain</vh></v>
<v t="ekr.20230509052845.4071"><vh>c = plain(3, 'heh')</vh></v>
<v t="ekr.20230509052845.4072"><vh>foo</vh></v>
<v t="ekr.20230509052845.4073"><vh>foo</vh></v>
<v t="ekr.20230509052845.4074"><vh>class A</vh></v>
<v t="ekr.20230509052845.4075"><vh>class B</vh></v>
<v t="ekr.20230509052845.4076"><vh>b = B()</vh></v>
<v t="ekr.20230509052845.4077"><vh>class AX</vh></v>
<v t="ekr.20230509052845.4078"><vh>class BX</vh></v>
<v t="ekr.20230509052845.4079"><vh>class CX</vh></v>
<v t="ekr.20230509052845.4080"><vh>c = CX('a', False)</vh></v>
<v t="ekr.20230509052845.4081"><vh>class Base</vh></v>
<v t="ekr.20230509052845.4082"><vh>class A</vh></v>
<v t="ekr.20230509052845.4083"><vh>a = A()</vh></v>
<v t="ekr.20230509052845.4084"><vh>moo</vh></v>
<v t="ekr.20230509052845.4085"><vh>moo(a)</vh></v>
<v t="ekr.20230509052845.4086"><vh>class A</vh></v>
<v t="ekr.20230509052845.4087"><vh>class B</vh></v>
<v t="ekr.20230509052845.4088"><vh>b = B()</vh></v>
<v t="ekr.20230509052845.4089"><vh>class A</vh></v>
</v>
<v t="ekr.20230509052845.4090"><vh>@@clean typecheck_stmt.codon</vh>
<v t="ekr.20230509052845.4091"><vh>xchg</vh></v>
<v t="ekr.20230509052845.4092"><vh>aadd</vh></v>
<v t="ekr.20230509052845.4093"><vh>amin</vh></v>
<v t="ekr.20230509052845.4094"><vh>amax</vh></v>
<v t="ekr.20230509052845.4095"><vh>min</vh></v>
<v t="ekr.20230509052845.4096"><vh>max</vh></v>
<v t="ekr.20230509052845.4097"><vh>class int</vh>
<v t="ekr.20230509052845.4098"><vh>int.__atomic_xchg__</vh></v>
<v t="ekr.20230509052845.4099"><vh>int.__atomic_add__</vh></v>
<v t="ekr.20230509052845.4100"><vh>int.__atomic_min__</vh></v>
<v t="ekr.20230509052845.4101"><vh>int.__atomic_max__</vh></v>
</v>
<v t="ekr.20230509052845.4102"><vh>foo</vh></v>
<v t="ekr.20230509052845.4103"><vh>foo(1)</vh></v>
<v t="ekr.20230509052845.4104"><vh>foo</vh></v>
<v t="ekr.20230509052845.4105"><vh>foo(1)</vh></v>
<v t="ekr.20230509052845.4106"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4107"><vh>f = Foo()</vh></v>
<v t="ekr.20230509052845.4108"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4109"><vh>Foo().y = 5 #! 'Foo' object has no attribute 'y'</vh></v>
<v t="ekr.20230509052845.4110"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4111"><vh>Foo().x = 5 #! cannot modify tuple attributes</vh></v>
<v t="ekr.20230509052845.4112"><vh>foo</vh></v>
<v t="ekr.20230509052845.4113"><vh>print foo()  #: 1</vh></v>
<v t="ekr.20230509052845.4114"><vh>bar</vh></v>
<v t="ekr.20230509052845.4115"><vh>bar()  #: 2</vh></v>
<v t="ekr.20230509052845.4116"><vh>foo</vh></v>
<v t="ekr.20230509052845.4117"><vh>print [i for i in foo()], str(foo())[:16]  #: [1] &lt;generator at 0x</vh></v>
<v t="ekr.20230509052845.4118"><vh>foo</vh></v>
<v t="ekr.20230509052845.4119"><vh>y = foo()</vh></v>
<v t="ekr.20230509052845.4120"><vh>foo</vh></v>
<v t="ekr.20230509052845.4121"><vh>print list(foo())  #: [1]</vh></v>
<v t="ekr.20230509052845.4122"><vh>foo</vh></v>
<v t="ekr.20230509052845.4123"><vh>for i in foo():</vh></v>
<v t="ekr.20230509052845.4124"><vh>foo</vh></v>
<v t="ekr.20230509052845.4125"><vh>print foo(N=1, x=1) #: 2</vh></v>
<v t="ekr.20230509052845.4126"><vh>class MyError</vh></v>
<v t="ekr.20230509052845.4127"><vh>try:</vh></v>
<v t="ekr.20230509052845.4128"><vh>foo</vh></v>
<v t="ekr.20230509052845.4129"><vh>try:</vh></v>
<v t="ekr.20230509052845.4130"><vh>foo</vh></v>
<v t="ekr.20230509052845.4131"><vh>! builtin, exported and external functions cannot be generic</vh></v>
<v t="ekr.20230509052845.4132"><vh>class int</vh></v>
<v t="ekr.20230509052845.4133"><vh>print list((5).run_lola_run())  #: [5, 4, 3, 2, 1]</vh></v>
<v t="ekr.20230509052845.4134"><vh>foo</vh></v>
<v t="ekr.20230509052845.4135"><vh>foo(5) #: 4</vh></v>
<v t="ekr.20230509052845.4136"><vh>foo2</vh></v>
<v t="ekr.20230509052845.4137"><vh>foo2(1) #: 2</vh></v>
<v t="ekr.20230509052845.4138"><vh>class Foo</vh>
<v t="ekr.20230509052845.4139"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.4140"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.4141"><vh>Foo.foo</vh></v>
<v t="ekr.20230509052845.4142"><vh>Foo.foo</vh></v>
</v>
<v t="ekr.20230509052845.4143"><vh>Foo.foo(1)</vh></v>
<v t="ekr.20230509052845.4144"><vh>class Bear</vh></v>
<v t="ekr.20230509052845.4145"><vh>class Bear</vh></v>
<v t="ekr.20230509052845.4146"><vh>print Bear.woof('!')</vh></v>
<v t="ekr.20230509052845.4147"><vh>class PolarBear</vh></v>
<v t="ekr.20230509052845.4148"><vh>print PolarBear.woof()</vh></v>
<v t="ekr.20230509052845.4149"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4150"><vh>Foo.foo(1)</vh></v>
<v t="ekr.20230509052845.4151"><vh>class Foo</vh></v>
</v>
<v t="ekr.20230509052845.4152"><vh>@@clean types.codon</vh>
<v t="ekr.20230509052845.4153"><vh>class XX</vh></v>
<v t="ekr.20230509052845.4154"><vh>a = XX()</vh></v>
<v t="ekr.20230509052845.4155"><vh>f</vh></v>
<v t="ekr.20230509052845.4156"><vh>print a.y.__class__.__name__ #: int</vh></v>
<v t="ekr.20230509052845.4157"><vh>map</vh></v>
<v t="ekr.20230509052845.4158"><vh>e = 1</vh></v>
<v t="ekr.20230509052845.4159"><vh>map2</vh></v>
<v t="ekr.20230509052845.4160"><vh>print map2([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]</vh></v>
<v t="ekr.20230509052845.4161"><vh>m4</vh></v>
<v t="ekr.20230509052845.4162"><vh>m4(1, 's')  #: 1 s 1.12</vh></v>
<v t="ekr.20230509052845.4163"><vh>class A</vh></v>
<v t="ekr.20230509052845.4164"><vh>ax = A(42)</vh></v>
<v t="ekr.20230509052845.4165"><vh>class A</vh></v>
<v t="ekr.20230509052845.4166"><vh>A.dump(1, 2, 3)  #: 1 2 3</vh></v>
<v t="ekr.20230509052845.4167"><vh>foo</vh></v>
<v t="ekr.20230509052845.4168"><vh>foo</vh></v>
<v t="ekr.20230509052845.4169"><vh>foo(10)</vh></v>
<v t="ekr.20230509052845.4170"><vh>class A</vh>
<v t="ekr.20230509052845.4171"><vh>A.dump</vh></v>
<v t="ekr.20230509052845.4172"><vh>A.m0</vh></v>
<v t="ekr.20230509052845.4173"><vh>A.m1</vh></v>
<v t="ekr.20230509052845.4174"><vh>A.m2</vh></v>
<v t="ekr.20230509052845.4175"><vh>A.m3</vh></v>
<v t="ekr.20230509052845.4176"><vh>A.m4</vh></v>
<v t="ekr.20230509052845.4177"><vh>A.m5</vh></v>
<v t="ekr.20230509052845.4178"><vh>A.m6</vh></v>
</v>
<v t="ekr.20230509052845.4179"><vh>a1 = A(42, 3.14, "hello")</vh></v>
<v t="ekr.20230509052845.4180"><vh>class B1</vh></v>
<v t="ekr.20230509052845.4181"><vh>b1 = B1[bool](True).foo()</vh></v>
<v t="ekr.20230509052845.4182"><vh>class B2</vh></v>
<v t="ekr.20230509052845.4183"><vh>b2 = B2[str]("x").foo()</vh></v>
<v t="ekr.20230509052845.4184"><vh>m7</vh></v>
<v t="ekr.20230509052845.4185"><vh>m7(str,float)                       #: works</vh></v>
<v t="ekr.20230509052845.4186"><vh>foo</vh></v>
<v t="ekr.20230509052845.4187"><vh>foo(0)</vh></v>
<v t="ekr.20230509052845.4188"><vh>bar</vh></v>
<v t="ekr.20230509052845.4189"><vh>bar(0)</vh></v>
<v t="ekr.20230509052845.4190"><vh>rec2</vh></v>
<v t="ekr.20230509052845.4191"><vh>print rec2(1, False).__class__.__name__ #: float</vh></v>
<v t="ekr.20230509052845.4192"><vh>pq</vh></v>
<v t="ekr.20230509052845.4193"><vh>rec3</vh></v>
<v t="ekr.20230509052845.4194"><vh>print rec3('x', 's').__class__.__name__  #: str</vh></v>
<v t="ekr.20230509052845.4195"><vh>f</vh></v>
<v t="ekr.20230509052845.4196"><vh>print f(1.2).__class__.__name__ #: float</vh></v>
<v t="ekr.20230509052845.4197"><vh>f2</vh></v>
<v t="ekr.20230509052845.4198"><vh>print f2(1) #: 1</vh></v>
<v t="ekr.20230509052845.4199"><vh>pq</vh></v>
<v t="ekr.20230509052845.4200"><vh>rec3</vh></v>
<v t="ekr.20230509052845.4201"><vh>rec3(1, 's')</vh></v>
<v t="ekr.20230509052845.4202"><vh>fx</vh></v>
<v t="ekr.20230509052845.4203"><vh>print fx(1.1).__class__.__name__, fx(1).__class__.__name__ #: float int</vh></v>
<v t="ekr.20230509052845.4204"><vh>foo</vh></v>
<v t="ekr.20230509052845.4205"><vh>foo(y, 6)  #: foo 5 6</vh></v>
<v t="ekr.20230509052845.4206"><vh>class Cls</vh></v>
<v t="ekr.20230509052845.4207"><vh>c = None</vh></v>
<v t="ekr.20230509052845.4208"><vh>class int</vh></v>
<v t="ekr.20230509052845.4209"><vh>y = None</vh></v>
<v t="ekr.20230509052845.4210"><vh>foo</vh></v>
<v t="ekr.20230509052845.4211"><vh>print a, b,</vh></v>
<v t="ekr.20230509052845.4212"><vh>class Test</vh></v>
<v t="ekr.20230509052845.4213"><vh>key_func</vh></v>
<v t="ekr.20230509052845.4214"><vh>print sorted([Test(1), Test(3), Test(2)], key=key_func)  #: [1, 2, 3]</vh></v>
<v t="ekr.20230509052845.4215"><vh>h</vh></v>
<v t="ekr.20230509052845.4216"><vh>print h(list(map(lambda i: i-1, map(lambda i: i+2, range(5)))))</vh></v>
<v t="ekr.20230509052845.4217"><vh>foo</vh></v>
<v t="ekr.20230509052845.4218"><vh>z = 1 &amp; foo #! unsupported operand type(s) for &amp;: 'int' and 'foo[int]'</vh></v>
<v t="ekr.20230509052845.4219"><vh>foo</vh></v>
<v t="ekr.20230509052845.4220"><vh>bar</vh></v>
<v t="ekr.20230509052845.4221"><vh>a = foo()  #: foo</vh></v>
<v t="ekr.20230509052845.4222"><vh>x</vh></v>
<v t="ekr.20230509052845.4223"><vh>b = lambda: x()</vh></v>
<v t="ekr.20230509052845.4224"><vh>foo</vh></v>
<v t="ekr.20230509052845.4225"><vh>a = list(foo())</vh></v>
<v t="ekr.20230509052845.4226"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4227"><vh>print Foo[int, bool](), Foo[bool, int]() #: 0 False False 0</vh></v>
<v t="ekr.20230509052845.4228"><vh>class Num</vh></v>
<v t="ekr.20230509052845.4229"><vh>foo</vh></v>
<v t="ekr.20230509052845.4230"><vh>foo(3) #: [6]</vh></v>
<v t="ekr.20230509052845.4231"><vh>class XX</vh></v>
<v t="ekr.20230509052845.4232"><vh>y = XX[5]()</vh></v>
<v t="ekr.20230509052845.4233"><vh>class FooBar</vh></v>
<v t="ekr.20230509052845.4234"><vh>z = FooBar(i32(5))</vh></v>
<v t="ekr.20230509052845.4235"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4236"><vh>foo = Foo[10](Int[20](0))</vh></v>
<v t="ekr.20230509052845.4237"><vh>class Num</vh></v>
<v t="ekr.20230509052845.4238"><vh>class Foo</vh>
<v t="ekr.20230509052845.4239"><vh>Foo.__init__</vh></v>
<v t="ekr.20230509052845.4240"><vh>Foo.__str__</vh></v>
</v>
<v t="ekr.20230509052845.4241"><vh>print Foo[int, 3, 4](), Foo[int, 5, 4]()</vh></v>
<v t="ekr.20230509052845.4242"><vh>foo</vh></v>
<v t="ekr.20230509052845.4243"><vh>a: Static[int] = 5</vh></v>
<v t="ekr.20230509052845.4244"><vh>class X</vh></v>
<v t="ekr.20230509052845.4245"><vh>foo</vh></v>
<v t="ekr.20230509052845.4246"><vh>z: Static[str] = "woo"</vh></v>
<v t="ekr.20230509052845.4247"><vh>class Dict</vh>
<v t="ekr.20230509052845.4248"><vh>Dict.__getitem2__</vh></v>
<v t="ekr.20230509052845.4249"><vh>Dict.__getitem1__</vh></v>
</v>
<v t="ekr.20230509052845.4250"><vh>d = {'s': 3.19}</vh></v>
<v t="ekr.20230509052845.4251"><vh>test</vh></v>
<v t="ekr.20230509052845.4252"><vh>test(Int[5](1)) #! 'Int[5]' does not match expected type 'Int[32]'</vh></v>
<v t="ekr.20230509052845.4253"><vh>test3</vh></v>
<v t="ekr.20230509052845.4254"><vh>test3(zi) #! 'N' does not match expected type 'N'</vh></v>
<v t="ekr.20230509052845.4255"><vh>test3</vh></v>
<v t="ekr.20230509052845.4256"><vh>test3(1, int) #! expected static expression</vh></v>
<v t="ekr.20230509052845.4257"><vh>f</vh></v>
<v t="ekr.20230509052845.4258"><vh>print f(5), f('s') #: 5 s</vh></v>
<v t="ekr.20230509052845.4259"><vh>f2</vh></v>
<v t="ekr.20230509052845.4260"><vh>x, y = 1, 'haha'</vh></v>
<v t="ekr.20230509052845.4261"><vh>f</vh></v>
<v t="ekr.20230509052845.4262"><vh>print f(1.1, 1, int).__class__.__name__ #! 'float' does not match expected type 'int'</vh></v>
<v t="ekr.20230509052845.4263"><vh>ff</vh></v>
<v t="ekr.20230509052845.4264"><vh>x = ff(1, (1,))</vh></v>
<v t="ekr.20230509052845.4265"><vh>fg</vh></v>
<v t="ekr.20230509052845.4266"><vh>fg(1)</vh></v>
<v t="ekr.20230509052845.4267"><vh>f</vh></v>
<v t="ekr.20230509052845.4268"><vh>print f(1), f(1).__class__.__name__ #: 1 int</vh></v>
<v t="ekr.20230509052845.4269"><vh>f</vh></v>
<v t="ekr.20230509052845.4270"><vh>f('s')</vh></v>
<v t="ekr.20230509052845.4271"><vh>class X</vh></v>
<v t="ekr.20230509052845.4272"><vh>y = X.Y()</vh></v>
<v t="ekr.20230509052845.4273"><vh>class A</vh>
<v t="ekr.20230509052845.4274"><vh>class B</vh></v>
</v>
<v t="ekr.20230509052845.4275"><vh>print A.B.C[bool].foo(W=str, ...).__class__.__name__ #: foo[bool,bool,bool,str,str]</vh></v>
<v t="ekr.20230509052845.4276"><vh>class A</vh>
<v t="ekr.20230509052845.4277"><vh>class B</vh></v>
</v>
<v t="ekr.20230509052845.4278"><vh>print A.B.C[str].foo(1,1,1,True) #! 'A.B.C[str]' object has no method 'foo' with arguments (int, int, int, bool)</vh></v>
<v t="ekr.20230509052845.4279"><vh>class A</vh></v>
<v t="ekr.20230509052845.4280"><vh>print A.B[int].C[float].foo(1,1,1,True) #! 'A.B[int]' object has no attribute 'C'</vh></v>
<v t="ekr.20230509052845.4281"><vh>f</vh></v>
<v t="ekr.20230509052845.4282"><vh>print f(1.1).__class__.__name__ #: Tuple[int,str,float]</vh></v>
<v t="ekr.20230509052845.4283"><vh>class A</vh>
<v t="ekr.20230509052845.4284"><vh>class B</vh>
<v t="ekr.20230509052845.4285"><vh>B.f</vh></v>
</v>
</v>
<v t="ekr.20230509052845.4286"><vh>print A.B.C.f(1.1).__class__.__name__ #: Tuple[int,str,float]</vh></v>
<v t="ekr.20230509052845.4287"><vh>class A</vh></v>
<v t="ekr.20230509052845.4288"><vh>x = A()</vh></v>
<v t="ekr.20230509052845.4289"><vh>class A</vh></v>
<v t="ekr.20230509052845.4290"><vh>a = A[int]()</vh></v>
<v t="ekr.20230509052845.4291"><vh>class X</vh>
<v t="ekr.20230509052845.4292"><vh>X.__init__</vh></v>
<v t="ekr.20230509052845.4293"><vh>X.foo</vh></v>
<v t="ekr.20230509052845.4294"><vh>class Y</vh></v>
</v>
<v t="ekr.20230509052845.4295"><vh>x, y = X(), X.Y()</vh></v>
<v t="ekr.20230509052845.4296"><vh>class A</vh></v>
<v t="ekr.20230509052845.4297"><vh>class B</vh>
<v t="ekr.20230509052845.4298"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.4299"><vh>class Nest1</vh></v>
<v t="ekr.20230509052845.4300"><vh>class Nest2</vh></v>
</v>
<v t="ekr.20230509052845.4301"><vh>b = B[float]()</vh></v>
<v t="ekr.20230509052845.4302"><vh>class A</vh></v>
<v t="ekr.20230509052845.4303"><vh>a = A()</vh></v>
<v t="ekr.20230509052845.4304"><vh>class A</vh></v>
<v t="ekr.20230509052845.4305"><vh>a = A()</vh></v>
<v t="ekr.20230509052845.4306"><vh>fun</vh></v>
<v t="ekr.20230509052845.4307"><vh>print fun(2, 1.1, float, byte).__class__.__name__ #: byte</vh></v>
<v t="ekr.20230509052845.4308"><vh>fun</vh></v>
<v t="ekr.20230509052845.4309"><vh>print fun(2, 1.1).__class__.__name__ #! cannot typecheck the program</vh></v>
<v t="ekr.20230509052845.4310"><vh>foo</vh></v>
<v t="ekr.20230509052845.4311"><vh>foo()</vh></v>
<v t="ekr.20230509052845.4312"><vh>class F</vh></v>
<v t="ekr.20230509052845.4313"><vh>foo</vh></v>
<v t="ekr.20230509052845.4314"><vh>goo</vh></v>
<v t="ekr.20230509052845.4315"><vh>f = F(foo, goo, 2)</vh></v>
<v t="ekr.20230509052845.4316"><vh>hoo</vh></v>
<v t="ekr.20230509052845.4317"><vh>f.g = hoo</vh></v>
<v t="ekr.20230509052845.4318"><vh>hai</vh></v>
<v t="ekr.20230509052845.4319"><vh>fn = Function[[int, int, int], None](hai)</vh></v>
<v t="ekr.20230509052845.4320"><vh>test</vh></v>
<v t="ekr.20230509052845.4321"><vh>foo</vh></v>
<v t="ekr.20230509052845.4322"><vh>test('hi', foo, lambda x: x+1) #: hi [2, 3, 4, 5]</vh></v>
<v t="ekr.20230509052845.4323"><vh>foof</vh></v>
<v t="ekr.20230509052845.4324"><vh>test('qsort', foof(x=3, ...), lambda x: x+1) #: qsort [5, 6, 7, 8]</vh></v>
<v t="ekr.20230509052845.4325"><vh>class X</vh></v>
<v t="ekr.20230509052845.4326"><vh>y = X[X[int]]()</vh></v>
<v t="ekr.20230509052845.4327"><vh>class X</vh></v>
<v t="ekr.20230509052845.4328"><vh>y = X[X[int]]()</vh></v>
<v t="ekr.20230509052845.4329"><vh>foo</vh></v>
<v t="ekr.20230509052845.4330"><vh>bar</vh></v>
<v t="ekr.20230509052845.4331"><vh>foo(bar, 1)</vh></v>
<v t="ekr.20230509052845.4332"><vh>foo</vh></v>
<v t="ekr.20230509052845.4333"><vh>bar</vh></v>
<v t="ekr.20230509052845.4334"><vh>foo(bar(T=int,...), 1)</vh></v>
<v t="ekr.20230509052845.4335"><vh>foo</vh></v>
<v t="ekr.20230509052845.4336"><vh>print sorted([1,2,3,4,5], key=foo(y=2, ...))</vh></v>
<v t="ekr.20230509052845.4337"><vh>bl</vh></v>
<v t="ekr.20230509052845.4338"><vh>frec</vh></v>
<v t="ekr.20230509052845.4339"><vh>print frec(1, 2).__class__.__name__, frec('s', 1).__class__.__name__</vh></v>
<v t="ekr.20230509052845.4340"><vh>retfn</vh></v>
<v t="ekr.20230509052845.4341"><vh>f = retfn(1)</vh></v>
<v t="ekr.20230509052845.4342"><vh>foo</vh></v>
<v t="ekr.20230509052845.4343"><vh>dec</vh></v>
<v t="ekr.20230509052845.4344"><vh>ff = dec(foo(...), 10)</vh></v>
<v t="ekr.20230509052845.4345"><vh>foo</vh></v>
<v t="ekr.20230509052845.4346"><vh>dec</vh></v>
<v t="ekr.20230509052845.4347"><vh>ff = dec(10)(foo)</vh></v>
<v t="ekr.20230509052845.4348"><vh>zoo</vh></v>
<v t="ekr.20230509052845.4349"><vh>print zoo(2, 3)</vh></v>
<v t="ekr.20230509052845.4350"><vh>mydecorator</vh></v>
<v t="ekr.20230509052845.4351"><vh>foo2</vh></v>
<v t="ekr.20230509052845.4352"><vh>foo2()</vh></v>
<v t="ekr.20230509052845.4353"><vh>timeme</vh></v>
<v t="ekr.20230509052845.4354"><vh>factorial</vh></v>
<v t="ekr.20230509052845.4355"><vh>factorial(10)</vh></v>
<v t="ekr.20230509052845.4356"><vh>dx1</vh></v>
<v t="ekr.20230509052845.4357"><vh>dx2</vh></v>
<v t="ekr.20230509052845.4358"><vh>num</vh></v>
<v t="ekr.20230509052845.4359"><vh>print(num()) #: 400</vh></v>
<v t="ekr.20230509052845.4360"><vh>dy1</vh></v>
<v t="ekr.20230509052845.4361"><vh>dy2</vh></v>
<v t="ekr.20230509052845.4362"><vh>num2</vh></v>
<v t="ekr.20230509052845.4363"><vh>print(num2(10, 20)) #: 3600</vh></v>
<v t="ekr.20230509052845.4364"><vh>foo</vh></v>
<v t="ekr.20230509052845.4365"><vh>args, result = ((), [()])</vh></v>
<v t="ekr.20230509052845.4366"><vh>tee</vh>
<v t="ekr.20230509052845.4367"><vh>gen</vh></v>
</v>
<v t="ekr.20230509052845.4368"><vh>it = [1,2,3,4]</vh></v>
<v t="ekr.20230509052845.4369"><vh>foo</vh></v>
<v t="ekr.20230509052845.4370"><vh>print foo(T=int,U=str,...).__class__.__name__ #: foo[T1,x,z,int,str]</vh></v>
<v t="ekr.20230509052845.4371"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4372"><vh>print Foo[5,int,float,6].__class__.__name__ #: Foo[5,int,float,6]</vh></v>
<v t="ekr.20230509052845.4373"><vh>foo2</vh></v>
<v t="ekr.20230509052845.4374"><vh>x: Static[int] = 5</vh></v>
<v t="ekr.20230509052845.4375"><vh>fox</vh></v>
<v t="ekr.20230509052845.4376"><vh>fox(5) #: Int[5] 5</vh></v>
<v t="ekr.20230509052845.4377"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4378"><vh>print Foo[float,6].__class__.__name__ #! Foo takes 4 generics (2 given)</vh></v>
<v t="ekr.20230509052845.4379"><vh>t</vh></v>
<v t="ekr.20230509052845.4380"><vh>print t(5) #: 5</vh></v>
<v t="ekr.20230509052845.4381"><vh>foo</vh></v>
<v t="ekr.20230509052845.4382"><vh>print foo(1) #: 1</vh></v>
<v t="ekr.20230509052845.4383"><vh>call</vh></v>
<v t="ekr.20230509052845.4384"><vh>foo</vh></v>
<v t="ekr.20230509052845.4385"><vh>call(foo)</vh></v>
<v t="ekr.20230509052845.4386"><vh>foo</vh></v>
<v t="ekr.20230509052845.4387"><vh>call(foo)</vh></v>
<v t="ekr.20230509052845.4388"><vh>call</vh></v>
<v t="ekr.20230509052845.4389"><vh>foo</vh></v>
<v t="ekr.20230509052845.4390"><vh>call(foo(zzz=1.1, ...))</vh></v>
<v t="ekr.20230509052845.4391"><vh>t</vh></v>
<v t="ekr.20230509052845.4392"><vh>print t(6, Optional(1)) #! 'Optional[int]' does not match expected type 'Optional[Callable[[int],S]]'</vh></v>
<v t="ekr.20230509052845.4393"><vh>test</vh></v>
<v t="ekr.20230509052845.4394"><vh>test(5) #: int</vh></v>
<v t="ekr.20230509052845.4395"><vh>foo</vh></v>
<v t="ekr.20230509052845.4396"><vh>foo()(1, 2) #: bar 1 2</vh></v>
<v t="ekr.20230509052845.4397"><vh>methodcaller</vh></v>
<v t="ekr.20230509052845.4398"><vh>v = [1]</vh></v>
<v t="ekr.20230509052845.4399"><vh>foo</vh></v>
<v t="ekr.20230509052845.4400"><vh>print(foo(''))  #: (1, '')</vh></v>
<v t="ekr.20230509052845.4401"><vh>foo</vh></v>
<v t="ekr.20230509052845.4402"><vh>foo</vh></v>
<v t="ekr.20230509052845.4403"><vh>print foo('hi') #: (3, 2)</vh></v>
<v t="ekr.20230509052845.4404"><vh>foo</vh></v>
<v t="ekr.20230509052845.4405"><vh>print foo('hi') #: (1, 'hi')</vh></v>
<v t="ekr.20230509052845.4406"><vh>foo</vh></v>
<v t="ekr.20230509052845.4407"><vh>print foo('hi') #: (2, 'hi')</vh></v>
<v t="ekr.20230509052845.4408"><vh>foo</vh></v>
<v t="ekr.20230509052845.4409"><vh>foo</vh></v>
<v t="ekr.20230509052845.4410"><vh>foo('hooooooooy!', 1, 2) #! no function 'foo' with arguments (str, int, int)</vh></v>
<v t="ekr.20230509052845.4411"><vh>foo</vh></v>
<v t="ekr.20230509052845.4412"><vh>for i in statictuple(1, 2, 3, 4, 5):</vh></v>
<v t="ekr.20230509052845.4413"><vh>class dd</vh>
<v t="ekr.20230509052845.4414"><vh>dd.__init__</vh></v>
<v t="ekr.20230509052845.4415"><vh>dd.__init__</vh></v>
<v t="ekr.20230509052845.4416"><vh>dd.__getitem__</vh></v>
</v>
<v t="ekr.20230509052845.4417"><vh>x = dd(list)</vh></v>
<v t="ekr.20230509052845.4418"><vh>foo</vh></v>
<v t="ekr.20230509052845.4419"><vh>foo(foo=1, bar='s')</vh></v>
<v t="ekr.20230509052845.4420"><vh>foo_int</vh></v>
<v t="ekr.20230509052845.4421"><vh>foo_str</vh></v>
<v t="ekr.20230509052845.4422"><vh>foo</vh></v>
<v t="ekr.20230509052845.4423"><vh>a: Union[int, str] = 5</vh></v>
<v t="ekr.20230509052845.4424"><vh>class str</vh></v>
<v t="ekr.20230509052845.4425"><vh>a += 6  ## this is U.__new__(a.__getter__(__add__)(59))</vh></v>
<v t="ekr.20230509052845.4426"><vh>ret</vh></v>
<v t="ekr.20230509052845.4427"><vh>r = ret(2)</vh></v>
<v t="ekr.20230509052845.4428"><vh>ret2</vh></v>
<v t="ekr.20230509052845.4429"><vh>r = ret2(20)</vh></v>
<v t="ekr.20230509052845.4430"><vh>class A</vh></v>
<v t="ekr.20230509052845.4431"><vh>class B</vh></v>
<v t="ekr.20230509052845.4432"><vh>x : Union[A,B] = A(5)  # TODO: just Union does not work :/</vh></v>
<v t="ekr.20230509052845.4433"><vh>do</vh></v>
<v t="ekr.20230509052845.4434"><vh>try:</vh></v>
<v t="ekr.20230509052845.4435"><vh>do2</vh></v>
<v t="ekr.20230509052845.4436"><vh>do2(x)  #: do2 bee</vh></v>
<v t="ekr.20230509052845.4437"><vh>class A</vh></v>
<v t="ekr.20230509052845.4438"><vh>class B</vh></v>
<v t="ekr.20230509052845.4439"><vh>class C</vh></v>
<v t="ekr.20230509052845.4440"><vh>x : Union[A,B,C] = A()</vh></v>
<v t="ekr.20230509052845.4441"><vh>foo</vh></v>
<v t="ekr.20230509052845.4442"><vh>for x in range(2):</vh></v>
<v t="ekr.20230509052845.4443"><vh>kernel</vh></v>
<v t="ekr.20230509052845.4444"><vh>test_mandelbrot</vh>
<v t="ekr.20230509052845.4445"><vh>scale</vh></v>
<v t="ekr.20230509052845.4446"><vh>k</vh></v>
</v>
<v t="ekr.20230509052845.4447"><vh>test_mandelbrot()  #: 0 1024 (10, 2, [0, 0], 0.4)</vh></v>
<v t="ekr.20230509052845.4448"><vh>class A</vh></v>
<v t="ekr.20230509052845.4449"><vh>foo = [1,2,11,30]</vh></v>
<v t="ekr.20230509052845.4450"><vh>class A</vh></v>
<v t="ekr.20230509052845.4451"><vh>class B</vh></v>
<v t="ekr.20230509052845.4452"><vh>class M</vh></v>
<v t="ekr.20230509052845.4453"><vh>class X</vh></v>
<v t="ekr.20230509052845.4454"><vh>foo</vh></v>
<v t="ekr.20230509052845.4455"><vh>a = A(1)</vh></v>
<v t="ekr.20230509052845.4456"><vh>moo</vh></v>
<v t="ekr.20230509052845.4457"><vh>moo(M[float](5.5))</vh></v>
<v t="ekr.20230509052845.4458"><vh>class A</vh></v>
<v t="ekr.20230509052845.4459"><vh>class Ho</vh></v>
<v t="ekr.20230509052845.4460"><vh>class B</vh></v>
<v t="ekr.20230509052845.4461"><vh>B[Ho]()</vh></v>
<v t="ekr.20230509052845.4462"><vh>class Vehicle</vh></v>
<v t="ekr.20230509052845.4463"><vh>class Car</vh></v>
<v t="ekr.20230509052845.4464"><vh>class Truck</vh></v>
<v t="ekr.20230509052845.4465"><vh>class SUV</vh></v>
<v t="ekr.20230509052845.4466"><vh>suv = SUV()</vh></v>
<v t="ekr.20230509052845.4467"><vh>moo</vh></v>
<v t="ekr.20230509052845.4468"><vh>moo(suv)</vh></v>
<v t="ekr.20230509052845.4469"><vh>class M</vh></v>
<v t="ekr.20230509052845.4470"><vh>class X</vh></v>
<v t="ekr.20230509052845.4471"><vh>l = [M[float](1.1), X(2)]</vh></v>
<v t="ekr.20230509052845.4472"><vh>class Expr</vh></v>
<v t="ekr.20230509052845.4473"><vh>class Const</vh></v>
<v t="ekr.20230509052845.4474"><vh>class Add</vh>
<v t="ekr.20230509052845.4475"><vh>Add.__init__</vh></v>
<v t="ekr.20230509052845.4476"><vh>Add.eval</vh></v>
<v t="ekr.20230509052845.4477"><vh>Add.__str__</vh></v>
</v>
<v t="ekr.20230509052845.4478"><vh>class Mul</vh>
<v t="ekr.20230509052845.4479"><vh>Mul.__init__</vh></v>
<v t="ekr.20230509052845.4480"><vh>Mul.eval</vh></v>
<v t="ekr.20230509052845.4481"><vh>Mul.__str__</vh></v>
</v>
<v t="ekr.20230509052845.4482"><vh>c1 = Const(5)</vh></v>
<v t="ekr.20230509052845.4483"><vh>random_expr</vh></v>
<v t="ekr.20230509052845.4484"><vh>for i in range(11):</vh></v>
<v t="ekr.20230509052845.4485"><vh>class A</vh></v>
<v t="ekr.20230509052845.4486"><vh>class B</vh></v>
<v t="ekr.20230509052845.4487"><vh>class C</vh></v>
<v t="ekr.20230509052845.4488"><vh>class D</vh></v>
<v t="ekr.20230509052845.4489"><vh>l = [A(), B(), C(), D()]</vh></v>
<v t="ekr.20230509052845.4490"><vh>class Expr</vh></v>
<v t="ekr.20230509052845.4491"><vh>class Const</vh></v>
<v t="ekr.20230509052845.4492"><vh>class BinOp</vh>
<v t="ekr.20230509052845.4493"><vh>BinOp.__init__</vh></v>
<v t="ekr.20230509052845.4494"><vh>BinOp.eval_from_fn</vh></v>
</v>
<v t="ekr.20230509052845.4495"><vh>class Add</vh></v>
<v t="ekr.20230509052845.4496"><vh>class Sub</vh></v>
<v t="ekr.20230509052845.4497"><vh>class Mul</vh></v>
<v t="ekr.20230509052845.4498"><vh>class Div</vh></v>
<v t="ekr.20230509052845.4499"><vh>TODO: remove Expr requirement</vh></v>
<v t="ekr.20230509052845.4500"><vh>class A</vh>
<v t="ekr.20230509052845.4501"><vh>A.__init__</vh></v>
<v t="ekr.20230509052845.4502"><vh>A.test_a</vh></v>
<v t="ekr.20230509052845.4503"><vh>A.test</vh></v>
<v t="ekr.20230509052845.4504"><vh>A.test2</vh></v>
</v>
<v t="ekr.20230509052845.4505"><vh>class B</vh>
<v t="ekr.20230509052845.4506"><vh>B.__init__</vh></v>
<v t="ekr.20230509052845.4507"><vh>B.test</vh></v>
<v t="ekr.20230509052845.4508"><vh>B.test2</vh></v>
</v>
<v t="ekr.20230509052845.4509"><vh>class C</vh></v>
<v t="ekr.20230509052845.4510"><vh>b = B(1, 2)</vh></v>
<v t="ekr.20230509052845.4511"><vh>foo</vh></v>
<v t="ekr.20230509052845.4512"><vh>foo(5)  #! generic 'b' not provided</vh></v>
<v t="ekr.20230509052845.4513"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.4514"><vh>@path a</vh>
<v t="ekr.20230509052845.4515"><vh>@@clean __init__.codon</vh>
<v t="ekr.20230509052845.4516"><vh>foo</vh></v>
<v t="ekr.20230509052845.4517"><vh>bar</vh></v>
<v t="ekr.20230509052845.4518"><vh>print 'a'</vh></v>
<v t="ekr.20230509052845.4519"><vh>class B</vh></v>
<v t="ekr.20230509052845.4520"><vh>C = B</vh></v>
<v t="ekr.20230509052845.4521"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4522"><vh>ha</vh></v>
</v>
<v t="ekr.20230509052845.4523"><vh>@path b</vh>
<v t="ekr.20230509052845.4524"><vh>@@clean rec1.codon</vh>
<v t="ekr.20230509052845.4525"><vh>bar</vh></v>
</v>
<v t="ekr.20230509052845.4526"><vh>@@clean rec1_err.codon</vh></v>
<v t="ekr.20230509052845.4527"><vh>@@clean rec2.codon</vh></v>
<v t="ekr.20230509052845.4528"><vh>@@clean rec2_err.codon</vh></v>
<v t="ekr.20230509052845.4529"><vh>@@clean __init__.codon</vh>
<v t="ekr.20230509052845.4530"><vh>har</vh></v>
<v t="ekr.20230509052845.4531"><vh>from .. import foo as fx</vh></v>
<v t="ekr.20230509052845.4532"><vh>class A</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509052845.4533"><vh>@path python</vh>
<v t="ekr.20230509052845.4534"><vh>@@clean cython_jit.py</vh>
<v t="ekr.20230509052845.4535"><vh>class Foo</vh>
<v t="ekr.20230509052845.4536"><vh>Foo.__init__</vh></v>
<v t="ekr.20230509052845.4537"><vh>Foo.__eq__</vh></v>
<v t="ekr.20230509052845.4538"><vh>Foo.__hash__</vh></v>
<v t="ekr.20230509052845.4539"><vh>Foo.total</vh></v>
</v>
<v t="ekr.20230509052845.4540"><vh>test_convertible</vh></v>
<v t="ekr.20230509052845.4541"><vh>test_many</vh>
<v t="ekr.20230509052845.4542"><vh>is_prime</vh></v>
</v>
<v t="ekr.20230509052845.4543"><vh>test_roundtrip</vh>
<v t="ekr.20230509052845.4544"><vh>roundtrip</vh></v>
</v>
<v t="ekr.20230509052845.4545"><vh>test_return_type</vh>
<v t="ekr.20230509052845.4546"><vh>run</vh></v>
</v>
<v t="ekr.20230509052845.4547"><vh>test_param_types</vh>
<v t="ekr.20230509052845.4548"><vh>run</vh></v>
</v>
<v t="ekr.20230509052845.4549"><vh>test_error_handling</vh>
<v t="ekr.20230509052845.4550"><vh>type_error</vh></v>
</v>
<v t="ekr.20230509052845.4551"><vh>test_convertible()</vh></v>
<v t="ekr.20230509052845.4552"><vh>foo</vh></v>
<v t="ekr.20230509052845.4553"><vh>foo2</vh></v>
<v t="ekr.20230509052845.4554"><vh>class Foo</vh></v>
<v t="ekr.20230509052845.4555"><vh>a</vh></v>
<v t="ekr.20230509052845.4556"><vh>b</vh></v>
<v t="ekr.20230509052845.4557"><vh>c</vh></v>
<v t="ekr.20230509052845.4558"><vh>test_cross_calls</vh></v>
</v>
<v t="ekr.20230509052845.4559"><vh>@@clean find-python-library.py</vh>
<v t="ekr.20230509052845.4560"><vh>get_python_library</vh></v>
</v>
<v t="ekr.20230509052845.4561"><vh>@@clean myextension.codon</vh>
<v t="ekr.20230509052845.4562"><vh>f1</vh></v>
<v t="ekr.20230509052845.4563"><vh>f2</vh></v>
<v t="ekr.20230509052845.4564"><vh>f3</vh></v>
<v t="ekr.20230509052845.4565"><vh>f4</vh></v>
<v t="ekr.20230509052845.4566"><vh>f4</vh></v>
<v t="ekr.20230509052845.4567"><vh>f4</vh></v>
<v t="ekr.20230509052845.4568"><vh>f4</vh></v>
<v t="ekr.20230509052845.4569"><vh>f5</vh></v>
<v t="ekr.20230509052845.4570"><vh>class Vec</vh>
<v t="ekr.20230509052845.4571"><vh>Vec.__init__</vh></v>
<v t="ekr.20230509052845.4572"><vh>Vec.__init__</vh></v>
<v t="ekr.20230509052845.4573"><vh>Vec.foo</vh></v>
<v t="ekr.20230509052845.4574"><vh>Vec.bar</vh></v>
<v t="ekr.20230509052845.4575"><vh>Vec.baz</vh></v>
<v t="ekr.20230509052845.4576"><vh>Vec.nop</vh></v>
<v t="ekr.20230509052845.4577"><vh>Vec.c</vh></v>
<v t="ekr.20230509052845.4578"><vh>Vec.__str__</vh></v>
<v t="ekr.20230509052845.4579"><vh>Vec.__repr__</vh></v>
<v t="ekr.20230509052845.4580"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4581"><vh>Vec.__iadd__</vh></v>
<v t="ekr.20230509052845.4582"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4583"><vh>Vec.__iadd__</vh></v>
<v t="ekr.20230509052845.4584"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4585"><vh>Vec.__sub__</vh></v>
<v t="ekr.20230509052845.4586"><vh>Vec.__isub__</vh></v>
<v t="ekr.20230509052845.4587"><vh>Vec.__mul__</vh></v>
<v t="ekr.20230509052845.4588"><vh>Vec.__imul__</vh></v>
<v t="ekr.20230509052845.4589"><vh>Vec.__mod__</vh></v>
<v t="ekr.20230509052845.4590"><vh>Vec.__imod__</vh></v>
<v t="ekr.20230509052845.4591"><vh>Vec.__divmod__</vh></v>
<v t="ekr.20230509052845.4592"><vh>Vec.__pow__</vh></v>
<v t="ekr.20230509052845.4593"><vh>Vec.__ipow__</vh></v>
<v t="ekr.20230509052845.4594"><vh>Vec.__neg__</vh></v>
<v t="ekr.20230509052845.4595"><vh>Vec.__pos__</vh></v>
<v t="ekr.20230509052845.4596"><vh>Vec.__abs__</vh></v>
<v t="ekr.20230509052845.4597"><vh>Vec.__bool__</vh></v>
<v t="ekr.20230509052845.4598"><vh>Vec.__invert__</vh></v>
<v t="ekr.20230509052845.4599"><vh>Vec.__lshift__</vh></v>
<v t="ekr.20230509052845.4600"><vh>Vec.__ilshift__</vh></v>
<v t="ekr.20230509052845.4601"><vh>Vec.__rshift__</vh></v>
<v t="ekr.20230509052845.4602"><vh>Vec.__irshift__</vh></v>
<v t="ekr.20230509052845.4603"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.4604"><vh>Vec.__iand__</vh></v>
<v t="ekr.20230509052845.4605"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.4606"><vh>Vec.__ior__</vh></v>
<v t="ekr.20230509052845.4607"><vh>Vec.__xor__</vh></v>
<v t="ekr.20230509052845.4608"><vh>Vec.__ixor__</vh></v>
<v t="ekr.20230509052845.4609"><vh>Vec.def __int__(self):</vh></v>
<v t="ekr.20230509052845.4610"><vh>Vec.__floordiv__</vh></v>
<v t="ekr.20230509052845.4611"><vh>Vec.__ifloordiv__</vh></v>
<v t="ekr.20230509052845.4612"><vh>Vec.__truediv__</vh></v>
<v t="ekr.20230509052845.4613"><vh>Vec.__itruediv__</vh></v>
<v t="ekr.20230509052845.4614"><vh>Vec.__matmul__</vh></v>
<v t="ekr.20230509052845.4615"><vh>Vec.__imatmul__</vh></v>
<v t="ekr.20230509052845.4616"><vh>Vec.__len__</vh></v>
<v t="ekr.20230509052845.4617"><vh>Vec.__getitem__</vh></v>
<v t="ekr.20230509052845.4618"><vh>Vec.__setitem__</vh></v>
<v t="ekr.20230509052845.4619"><vh>Vec.__delitem__</vh></v>
<v t="ekr.20230509052845.4620"><vh>Vec.__contains__</vh></v>
<v t="ekr.20230509052845.4621"><vh>Vec.__contains__</vh></v>
<v t="ekr.20230509052845.4622"><vh>Vec.__hash__</vh></v>
<v t="ekr.20230509052845.4623"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4624"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4625"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4626"><vh>Vec.__iter__</vh></v>
<v t="ekr.20230509052845.4627"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.4628"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.4629"><vh>Vec.__ne__</vh></v>
<v t="ekr.20230509052845.4630"><vh>Vec.__lt__</vh></v>
<v t="ekr.20230509052845.4631"><vh>Vec.__le__</vh></v>
<v t="ekr.20230509052845.4632"><vh>Vec.__gt__</vh></v>
<v t="ekr.20230509052845.4633"><vh>Vec.__ge__</vh></v>
<v t="ekr.20230509052845.4634"><vh>Vec.__del__</vh></v>
<v t="ekr.20230509052845.4635"><vh>Vec.nd</vh></v>
</v>
<v t="ekr.20230509052845.4636"><vh>f6</vh></v>
<v t="ekr.20230509052845.4637"><vh>reset</vh></v>
<v t="ekr.20230509052845.4638"><vh>par_sum</vh></v>
<v t="ekr.20230509052845.4639"><vh>class Foo</vh>
<v t="ekr.20230509052845.4640"><vh>Foo.__new__</vh></v>
<v t="ekr.20230509052845.4641"><vh>Foo.__iter__</vh></v>
<v t="ekr.20230509052845.4642"><vh>Foo.__repr__</vh></v>
<v t="ekr.20230509052845.4643"><vh>Foo.hello</vh></v>
<v t="ekr.20230509052845.4644"><vh>Foo.__int__</vh></v>
<v t="ekr.20230509052845.4645"><vh>Foo.__float__</vh></v>
<v t="ekr.20230509052845.4646"><vh>Foo.__index__</vh></v>
</v>
</v>
<v t="ekr.20230509052845.4647"><vh>@@clean myextension2.codon</vh>
<v t="ekr.20230509052845.4648"><vh>class Vec</vh>
<v t="ekr.20230509052845.4649"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.4650"><vh>Vec.__new__</vh></v>
<v t="ekr.20230509052845.4651"><vh>Vec.foo</vh></v>
<v t="ekr.20230509052845.4652"><vh>Vec.bar</vh></v>
<v t="ekr.20230509052845.4653"><vh>Vec.baz</vh></v>
<v t="ekr.20230509052845.4654"><vh>Vec.nop</vh></v>
<v t="ekr.20230509052845.4655"><vh>Vec.c</vh></v>
<v t="ekr.20230509052845.4656"><vh>Vec.__str__</vh></v>
<v t="ekr.20230509052845.4657"><vh>Vec.__repr__</vh></v>
<v t="ekr.20230509052845.4658"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4659"><vh>Vec.__iadd__</vh></v>
<v t="ekr.20230509052845.4660"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4661"><vh>Vec.__iadd__</vh></v>
<v t="ekr.20230509052845.4662"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.4663"><vh>Vec.__sub__</vh></v>
<v t="ekr.20230509052845.4664"><vh>Vec.__isub__</vh></v>
<v t="ekr.20230509052845.4665"><vh>Vec.__mul__</vh></v>
<v t="ekr.20230509052845.4666"><vh>Vec.__imul__</vh></v>
<v t="ekr.20230509052845.4667"><vh>Vec.__mod__</vh></v>
<v t="ekr.20230509052845.4668"><vh>Vec.__imod__</vh></v>
<v t="ekr.20230509052845.4669"><vh>Vec.__divmod__</vh></v>
<v t="ekr.20230509052845.4670"><vh>Vec.__pow__</vh></v>
<v t="ekr.20230509052845.4671"><vh>Vec.__ipow__</vh></v>
<v t="ekr.20230509052845.4672"><vh>Vec.__neg__</vh></v>
<v t="ekr.20230509052845.4673"><vh>Vec.__pos__</vh></v>
<v t="ekr.20230509052845.4674"><vh>Vec.__abs__</vh></v>
<v t="ekr.20230509052845.4675"><vh>Vec.__bool__</vh></v>
<v t="ekr.20230509052845.4676"><vh>Vec.__invert__</vh></v>
<v t="ekr.20230509052845.4677"><vh>Vec.__lshift__</vh></v>
<v t="ekr.20230509052845.4678"><vh>Vec.__ilshift__</vh></v>
<v t="ekr.20230509052845.4679"><vh>Vec.__rshift__</vh></v>
<v t="ekr.20230509052845.4680"><vh>Vec.__irshift__</vh></v>
<v t="ekr.20230509052845.4681"><vh>Vec.__and__</vh></v>
<v t="ekr.20230509052845.4682"><vh>Vec.__iand__</vh></v>
<v t="ekr.20230509052845.4683"><vh>Vec.__or__</vh></v>
<v t="ekr.20230509052845.4684"><vh>Vec.__ior__</vh></v>
<v t="ekr.20230509052845.4685"><vh>Vec.__xor__</vh></v>
<v t="ekr.20230509052845.4686"><vh>Vec.__ixor__</vh></v>
<v t="ekr.20230509052845.4687"><vh>Vec.def __int__(self):</vh></v>
<v t="ekr.20230509052845.4688"><vh>Vec.__floordiv__</vh></v>
<v t="ekr.20230509052845.4689"><vh>Vec.__ifloordiv__</vh></v>
<v t="ekr.20230509052845.4690"><vh>Vec.__truediv__</vh></v>
<v t="ekr.20230509052845.4691"><vh>Vec.__itruediv__</vh></v>
<v t="ekr.20230509052845.4692"><vh>Vec.__matmul__</vh></v>
<v t="ekr.20230509052845.4693"><vh>Vec.__imatmul__</vh></v>
<v t="ekr.20230509052845.4694"><vh>Vec.__len__</vh></v>
<v t="ekr.20230509052845.4695"><vh>Vec.__getitem__</vh></v>
<v t="ekr.20230509052845.4696"><vh>Vec.__contains__</vh></v>
<v t="ekr.20230509052845.4697"><vh>Vec.__contains__</vh></v>
<v t="ekr.20230509052845.4698"><vh>Vec.__hash__</vh></v>
<v t="ekr.20230509052845.4699"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4700"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4701"><vh>Vec.__call__</vh></v>
<v t="ekr.20230509052845.4702"><vh>Vec.__iter__</vh></v>
<v t="ekr.20230509052845.4703"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.4704"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.4705"><vh>Vec.__ne__</vh></v>
<v t="ekr.20230509052845.4706"><vh>Vec.__lt__</vh></v>
<v t="ekr.20230509052845.4707"><vh>Vec.__le__</vh></v>
<v t="ekr.20230509052845.4708"><vh>Vec.__gt__</vh></v>
<v t="ekr.20230509052845.4709"><vh>Vec.__ge__</vh></v>
<v t="ekr.20230509052845.4710"><vh>Vec.__del__</vh></v>
<v t="ekr.20230509052845.4711"><vh>Vec.nd</vh></v>
</v>
<v t="ekr.20230509052845.4712"><vh>reset</vh></v>
<v t="ekr.20230509052845.4713"><vh>par_sum</vh></v>
</v>
<v t="ekr.20230509052845.4714"><vh>@@clean mymodule.py</vh>
<v t="ekr.20230509052845.4715"><vh>multiply</vh></v>
<v t="ekr.20230509052845.4716"><vh>print_args</vh></v>
<v t="ekr.20230509052845.4717"><vh>print_args_var</vh></v>
<v t="ekr.20230509052845.4718"><vh>throw_exc</vh></v>
</v>
<v t="ekr.20230509052845.4719"><vh>@@clean pybridge.codon</vh>
<v t="ekr.20230509052845.4720"><vh>test_basic</vh></v>
<v t="ekr.20230509052845.4721"><vh>test_basic()</vh></v>
<v t="ekr.20230509052845.4722"><vh>test_pybridge</vh></v>
<v t="ekr.20230509052845.4723"><vh>test_pybridge()</vh></v>
<v t="ekr.20230509052845.4724"><vh>test_conversions</vh></v>
<v t="ekr.20230509052845.4725"><vh>test_conversions()</vh></v>
<v t="ekr.20230509052845.4726"><vh>test_pythrow</vh></v>
<v t="ekr.20230509052845.4727"><vh>test_pythrow()</vh></v>
<v t="ekr.20230509052845.4728"><vh>test_pyargs</vh></v>
<v t="ekr.20230509052845.4729"><vh>test_pyargs()</vh></v>
<v t="ekr.20230509052845.4730"><vh>test_roundtrip</vh></v>
<v t="ekr.20230509052845.4731"><vh>test_roundtrip(42)</vh></v>
<v t="ekr.20230509052845.4732"><vh>test_ops</vh></v>
</v>
<v t="ekr.20230509052845.4733"><vh>@@clean pyext.py</vh>
<v t="ekr.20230509052845.4734"><vh>equal</vh></v>
<v t="ekr.20230509052845.4735"><vh>saw_fun = False</vh></v>
<v t="ekr.20230509052845.4736"><vh>test_codon_extensions</vh>
<v t="ekr.20230509052845.4737"><vh>dup</vh></v>
<v t="ekr.20230509052845.4738"><vh>y1 = dup(y)</vh></v>
<v t="ekr.20230509052845.4739"><vh>par_sum_check</vh></v>
</v>
</v>
<v t="ekr.20230509052845.4740"><vh>@@clean setup.py</vh>
<v t="ekr.20230509052845.4741"><vh>class CodonExtension</vh></v>
<v t="ekr.20230509052845.4742"><vh>class BuildCodonExt</vh>
<v t="ekr.20230509052845.4743"><vh>BuildCodonExt.build_extensions</vh></v>
<v t="ekr.20230509052845.4744"><vh>BuildCodonExt.run</vh></v>
<v t="ekr.20230509052845.4745"><vh>BuildCodonExt.build_codon</vh></v>
</v>
</v>
<v t="ekr.20230509052845.4746"><vh>@@clean __init__.py</vh></v>
</v>
<v t="ekr.20230509052845.4747"><vh>@path stdlib</vh>
<v t="ekr.20230509052845.4748"><vh>@@clean bisect_test.codon</vh>
<v t="ekr.20230509052845.4749"><vh>bisect_left</vh></v>
<v t="ekr.20230509052845.4750"><vh>bisect_right</vh></v>
<v t="ekr.20230509052845.4751"><vh>bisect1</vh></v>
<v t="ekr.20230509052845.4752"><vh>insort_left</vh></v>
<v t="ekr.20230509052845.4753"><vh>insort_right</vh></v>
<v t="ekr.20230509052845.4754"><vh>insort</vh></v>
</v>
<v t="ekr.20230509052845.4755"><vh>@@clean cmath_test.codon</vh>
<v t="ekr.20230509052845.4756"><vh>float_identical</vh></v>
<v t="ekr.20230509052845.4757"><vh>complex_identical</vh></v>
<v t="ekr.20230509052845.4758"><vh>complex #</vh></v>
<v t="ekr.20230509052845.4759"><vh>close_abs</vh></v>
<v t="ekr.20230509052845.4760"><vh>close_complex</vh></v>
<v t="ekr.20230509052845.4761"><vh>check_div</vh></v>
<v t="ekr.20230509052845.4762"><vh>test_truediv</vh></v>
<v t="ekr.20230509052845.4763"><vh>test_truediv()</vh></v>
<v t="ekr.20230509052845.4764"><vh>test_richcompare</vh></v>
<v t="ekr.20230509052845.4765"><vh>test_richcompare()</vh></v>
<v t="ekr.20230509052845.4766"><vh>test_pow</vh>
<v t="ekr.20230509052845.4767"><vh>pow</vh></v>
</v>
<v t="ekr.20230509052845.4768"><vh>test_pow()</vh></v>
<v t="ekr.20230509052845.4769"><vh>test_conjugate</vh></v>
<v t="ekr.20230509052845.4770"><vh>test_conjugate()</vh></v>
<v t="ekr.20230509052845.4771"><vh>test_cabs</vh></v>
<v t="ekr.20230509052845.4772"><vh>test_cabs()</vh></v>
<v t="ekr.20230509052845.4773"><vh>test_negative_zero_repr_str</vh>
<v t="ekr.20230509052845.4774"><vh>test</vh></v>
</v>
<v t="ekr.20230509052845.4775"><vh>test_negative_zero_repr_str()</vh></v>
<v t="ekr.20230509052845.4776"><vh>small</vh></v>
<v t="ekr.20230509052845.4777"><vh>almost_equal</vh></v>
<v t="ekr.20230509052845.4778"><vh>test_constants</vh></v>
<v t="ekr.20230509052845.4779"><vh>test_constants()</vh></v>
<v t="ekr.20230509052845.4780"><vh>test_infinity_and_nan_constants</vh></v>
<v t="ekr.20230509052845.4781"><vh>test_infinity_and_nan_constants()</vh></v>
<v t="ekr.20230509052845.4782"><vh>test_user_object</vh>
<v t="ekr.20230509052845.4783"><vh>class MyComplexOS</vh></v>
</v>
<v t="ekr.20230509052845.4784"><vh>test_user_object()</vh></v>
<v t="ekr.20230509052845.4785"><vh>test_input_type</vh></v>
<v t="ekr.20230509052845.4786"><vh>test_input_type()</vh></v>
<v t="ekr.20230509052845.4787"><vh>test_cmath_matches_math</vh></v>
<v t="ekr.20230509052845.4788"><vh>test_cmath_matches_math()</vh></v>
<v t="ekr.20230509052845.4789"><vh>test_polar</vh>
<v t="ekr.20230509052845.4790"><vh>check</vh></v>
</v>
<v t="ekr.20230509052845.4791"><vh>test_polar()</vh></v>
<v t="ekr.20230509052845.4792"><vh>test_phase</vh></v>
<v t="ekr.20230509052845.4793"><vh>test_phase()</vh></v>
<v t="ekr.20230509052845.4794"><vh>test_abs</vh></v>
<v t="ekr.20230509052845.4795"><vh>test_abs()</vh></v>
<v t="ekr.20230509052845.4796"><vh>c_equal</vh></v>
<v t="ekr.20230509052845.4797"><vh>test_rect</vh></v>
<v t="ekr.20230509052845.4798"><vh>test_rect()</vh></v>
<v t="ekr.20230509052845.4799"><vh>test_isfinite</vh></v>
<v t="ekr.20230509052845.4800"><vh>test_isfinite()</vh></v>
<v t="ekr.20230509052845.4801"><vh>test_isnan</vh></v>
<v t="ekr.20230509052845.4802"><vh>test_isnan()</vh></v>
<v t="ekr.20230509052845.4803"><vh>test_isinf</vh></v>
<v t="ekr.20230509052845.4804"><vh>test_isinf()</vh></v>
<v t="ekr.20230509052845.4805"><vh>test_tanh_sign</vh></v>
<v t="ekr.20230509052845.4806"><vh>test_tanh_sign()</vh></v>
<v t="ekr.20230509052845.4807"><vh>test_atan_sign</vh></v>
<v t="ekr.20230509052845.4808"><vh>test_atan_sign()</vh></v>
<v t="ekr.20230509052845.4809"><vh>test_atanh_sign</vh></v>
<v t="ekr.20230509052845.4810"><vh>test_atanh_sign()</vh></v>
<v t="ekr.20230509052845.4811"><vh>test_is_close</vh></v>
<v t="ekr.20230509052845.4812"><vh>test_is_close()</vh></v>
<v t="ekr.20230509052845.4813"><vh>test_cmath_testcases</vh>
<v t="ekr.20230509052845.4814"><vh>check</vh></v>
<v t="ekr.20230509052845.4815"><vh>run_test</vh></v>
</v>
<v t="ekr.20230509052845.4816"><vh>test_cmath_testcases()</vh></v>
<v t="ekr.20230509052845.4817"><vh>test_complex64</vh></v>
</v>
<v t="ekr.20230509052845.4818"><vh>@@clean datetime_test.codon</vh>
<v t="ekr.20230509052845.4819"><vh>class TestTimeDelta</vh>
<v t="ekr.20230509052845.4820"><vh>TestTimeDelta.test_constructor</vh></v>
<v t="ekr.20230509052845.4821"><vh>TestTimeDelta.test_computations</vh></v>
<v t="ekr.20230509052845.4822"><vh>TestTimeDelta."""</vh></v>
<v t="ekr.20230509052845.4823"><vh>TestTimeDelta.test_basic_attributes</vh></v>
<v t="ekr.20230509052845.4824"><vh>TestTimeDelta.test_total_seconds</vh></v>
<v t="ekr.20230509052845.4825"><vh>TestTimeDelta.test_carries</vh></v>
<v t="ekr.20230509052845.4826"><vh>TestTimeDelta.test_hash_equality</vh></v>
<v t="ekr.20230509052845.4827"><vh>TestTimeDelta.test_compare</vh></v>
<v t="ekr.20230509052845.4828"><vh>TestTimeDelta.test_str</vh></v>
<v t="ekr.20230509052845.4829"><vh>TestTimeDelta.test_repr</vh></v>
<v t="ekr.20230509052845.4830"><vh>TestTimeDelta.test_resolution_info</vh></v>
<v t="ekr.20230509052845.4831"><vh>TestTimeDelta."""</vh></v>
<v t="ekr.20230509052845.4832"><vh>TestTimeDelta.test_microsecond_rounding</vh></v>
<v t="ekr.20230509052845.4833"><vh>TestTimeDelta.test_massive_normalization</vh></v>
<v t="ekr.20230509052845.4834"><vh>TestTimeDelta.test_bool</vh></v>
<v t="ekr.20230509052845.4835"><vh>TestTimeDelta.test_division</vh></v>
<v t="ekr.20230509052845.4836"><vh>TestTimeDelta.test_remainder</vh></v>
<v t="ekr.20230509052845.4837"><vh>TestTimeDelta.test_divmod</vh></v>
</v>
<v t="ekr.20230509052845.4838"><vh>class TestDateOnly</vh>
<v t="ekr.20230509052845.4839"><vh>TestDateOnly.test_delta_non_days_ignored</vh></v>
</v>
<v t="ekr.20230509052845.4840"><vh>class TestDate</vh>
<v t="ekr.20230509052845.4841"><vh>TestDate.test_basic_attributes</vh></v>
<v t="ekr.20230509052845.4842"><vh>TestDate.test_ordinal_conversions</vh></v>
<v t="ekr.20230509052845.4843"><vh>TestDate."""</vh></v>
<v t="ekr.20230509052845.4844"><vh>TestDate.test_bad_constructor_arguments</vh></v>
<v t="ekr.20230509052845.4845"><vh>TestDate.test_hash_equality</vh></v>
<v t="ekr.20230509052845.4846"><vh>TestDate.test_computations</vh></v>
<v t="ekr.20230509052845.4847"><vh>TestDate."""</vh></v>
<v t="ekr.20230509052845.4848"><vh>TestDate.test_fromtimestamp</vh></v>
<v t="ekr.20230509052845.4849"><vh>TestDate.test_today</vh></v>
<v t="ekr.20230509052845.4850"><vh>TestDate.test_weekday</vh></v>
<v t="ekr.20230509052845.4851"><vh>TestDate.test_isocalendar</vh></v>
<v t="ekr.20230509052845.4852"><vh>TestDate.test_iso_long_years</vh></v>
<v t="ekr.20230509052845.4853"><vh>TestDate.test_isoformat</vh></v>
<v t="ekr.20230509052845.4854"><vh>TestDate.test_ctime</vh></v>
<v t="ekr.20230509052845.4855"><vh>TestDate.test_resolution_info</vh></v>
<v t="ekr.20230509052845.4856"><vh>TestDate."""</vh></v>
<v t="ekr.20230509052845.4857"><vh>TestDate.test_timetuple</vh></v>
<v t="ekr.20230509052845.4858"><vh>TestDate.test_compare</vh></v>
<v t="ekr.20230509052845.4859"><vh>TestDate.test_bool</vh></v>
<v t="ekr.20230509052845.4860"><vh>TestDate.test_replace</vh></v>
<v t="ekr.20230509052845.4861"><vh>TestDate.test_fromisoformat</vh></v>
<v t="ekr.20230509052845.4862"><vh>TestDate.test_fromisoformat_fails</vh></v>
<v t="ekr.20230509052845.4863"><vh>TestDate.test_fromisocalendar</vh></v>
<v t="ekr.20230509052845.4864"><vh>TestDate.test_fromisocalendar_value_errors</vh></v>
</v>
<v t="ekr.20230509052845.4865"><vh>class TestDateTime</vh>
<v t="ekr.20230509052845.4866"><vh>TestDateTime.test_basic_attributes</vh></v>
<v t="ekr.20230509052845.4867"><vh>TestDateTime.test_basic_attributes_nonzero</vh></v>
<v t="ekr.20230509052845.4868"><vh>TestDateTime.test_isoformat</vh></v>
<v t="ekr.20230509052845.4869"><vh>TestDateTime."""</vh></v>
<v t="ekr.20230509052845.4870"><vh>TestDateTime.test_tz_independent_comparing</vh></v>
<v t="ekr.20230509052845.4871"><vh>TestDateTime.test_bad_constructor_arguments</vh></v>
<v t="ekr.20230509052845.4872"><vh>TestDateTime.test_hash_equality</vh></v>
<v t="ekr.20230509052845.4873"><vh>TestDateTime.test_computations</vh></v>
<v t="ekr.20230509052845.4874"><vh>TestDateTime.test_more_compare</vh></v>
<v t="ekr.20230509052845.4875"><vh>TestDateTime.verify_field_equality</vh></v>
<v t="ekr.20230509052845.4876"><vh>TestDateTime.test_fromtimestamp</vh></v>
<v t="ekr.20230509052845.4877"><vh>TestDateTime."""</vh></v>
<v t="ekr.20230509052845.4878"><vh>TestDateTime.test_timestamp_naive</vh></v>
<v t="ekr.20230509052845.4879"><vh>TestDateTime."""</vh></v>
<v t="ekr.20230509052845.4880"><vh>TestDateTime.test_negative_float_fromtimestamp</vh></v>
<v t="ekr.20230509052845.4881"><vh>TestDateTime."""</vh></v>
<v t="ekr.20230509052845.4882"><vh>TestDateTime.test_utcnow</vh></v>
<v t="ekr.20230509052845.4883"><vh>TestDateTime.test_extract</vh></v>
<v t="ekr.20230509052845.4884"><vh>TestDateTime.test_combine</vh></v>
<v t="ekr.20230509052845.4885"><vh>TestDateTime.test_replace</vh></v>
<v t="ekr.20230509052845.4886"><vh>TestDateTime."""</vh></v>
<v t="ekr.20230509052845.4887"><vh>TestDateTime.test_fromisoformat_datetime</vh></v>
<v t="ekr.20230509052845.4888"><vh>TestDateTime.test_fromisoformat_separators</vh></v>
<v t="ekr.20230509052845.4889"><vh>TestDateTime.test_fromisoformat_ambiguous</vh></v>
<v t="ekr.20230509052845.4890"><vh>TestDateTime.test_fromisoformat_timespecs</vh></v>
<v t="ekr.20230509052845.4891"><vh>TestDateTime.test_fromisoformat_fails_datetime</vh></v>
</v>
<v t="ekr.20230509052845.4892"><vh>class TestTime</vh>
<v t="ekr.20230509052845.4893"><vh>TestTime.test_basic_attributes</vh></v>
<v t="ekr.20230509052845.4894"><vh>TestTime.test_basic_attributes_nonzero</vh></v>
<v t="ekr.20230509052845.4895"><vh>TestTime.test_comparing</vh></v>
<v t="ekr.20230509052845.4896"><vh>TestTime.test_bad_constructor_arguments</vh></v>
<v t="ekr.20230509052845.4897"><vh>TestTime.test_hash_equality</vh></v>
<v t="ekr.20230509052845.4898"><vh>TestTime.test_isoformat</vh></v>
<v t="ekr.20230509052845.4899"><vh>TestTime.test_str</vh></v>
<v t="ekr.20230509052845.4900"><vh>TestTime.test_repr</vh></v>
<v t="ekr.20230509052845.4901"><vh>TestTime.test_resolution_info</vh></v>
<v t="ekr.20230509052845.4902"><vh>TestTime.test_bool</vh></v>
<v t="ekr.20230509052845.4903"><vh>TestTime.test_replace</vh></v>
</v>
<v t="ekr.20230509052845.4904"><vh>case_td = TestTimeDelta()</vh></v>
<v t="ekr.20230509052845.4905"><vh>test_constants</vh></v>
</v>
<v t="ekr.20230509052845.4906"><vh>@@clean heapq_test.codon</vh>
<v t="ekr.20230509052845.4907"><vh>check_invariant</vh></v>
<v t="ekr.20230509052845.4908"><vh>test_heapify</vh></v>
<v t="ekr.20230509052845.4909"><vh>test_naive_nbest</vh></v>
<v t="ekr.20230509052845.4910"><vh>heapiter</vh></v>
<v t="ekr.20230509052845.4911"><vh>test_nbest</vh></v>
<v t="ekr.20230509052845.4912"><vh>test_nbest_with_pushpop</vh></v>
<v t="ekr.20230509052845.4913"><vh>test_heappushpop</vh></v>
<v t="ekr.20230509052845.4914"><vh>test_heappop_max</vh></v>
<v t="ekr.20230509052845.4915"><vh>test_heapsort</vh></v>
<v t="ekr.20230509052845.4916"><vh>"""</vh></v>
<v t="ekr.20230509052845.4917"><vh>mykey</vh></v>
<v t="ekr.20230509052845.4918"><vh>test_nsmallest</vh></v>
<v t="ekr.20230509052845.4919"><vh>test_nlargest</vh></v>
<v t="ekr.20230509052845.4920"><vh>test_comparison_operator</vh>
<v t="ekr.20230509052845.4921"><vh>hsort</vh></v>
<v t="ekr.20230509052845.4922"><vh>class LT</vh></v>
</v>
<v t="ekr.20230509052845.4923"><vh>test_merge</vh></v>
</v>
<v t="ekr.20230509052845.4924"><vh>@@clean itertools_test.codon</vh>
<v t="ekr.20230509052845.4925"><vh>lzip</vh></v>
<v t="ekr.20230509052845.4926"><vh>onearg</vh></v>
<v t="ekr.20230509052845.4927"><vh>errfunc</vh></v>
<v t="ekr.20230509052845.4928"><vh>gen3</vh></v>
<v t="ekr.20230509052845.4929"><vh>isEven</vh></v>
<v t="ekr.20230509052845.4930"><vh>isOdd</vh></v>
<v t="ekr.20230509052845.4931"><vh>tupleize</vh></v>
<v t="ekr.20230509052845.4932"><vh>irange</vh></v>
<v t="ekr.20230509052845.4933"><vh>take</vh></v>
<v t="ekr.20230509052845.4934"><vh>testR</vh></v>
<v t="ekr.20230509052845.4935"><vh>testR2</vh></v>
<v t="ekr.20230509052845.4936"><vh>underten</vh></v>
<v t="ekr.20230509052845.4937"><vh>test_combinations</vh></v>
<v t="ekr.20230509052845.4938"><vh>test_combinations_with_replacement</vh></v>
<v t="ekr.20230509052845.4939"><vh>test_islice</vh></v>
<v t="ekr.20230509052845.4940"><vh>test_count</vh></v>
<v t="ekr.20230509052845.4941"><vh>test_repeat</vh></v>
<v t="ekr.20230509052845.4942"><vh>test_cycle</vh></v>
<v t="ekr.20230509052845.4943"><vh>test_compress</vh></v>
<v t="ekr.20230509052845.4944"><vh>test_dropwhile</vh></v>
<v t="ekr.20230509052845.4945"><vh>test_takewhile</vh></v>
<v t="ekr.20230509052845.4946"><vh>test_filterfalse</vh></v>
<v t="ekr.20230509052845.4947"><vh>test_permutations</vh></v>
<v t="ekr.20230509052845.4948"><vh>test_accumulate</vh></v>
<v t="ekr.20230509052845.4949"><vh>test_chain</vh></v>
<v t="ekr.20230509052845.4950"><vh>test_starmap</vh></v>
<v t="ekr.20230509052845.4951"><vh>test_groupby</vh>
<v t="ekr.20230509052845.4952"><vh>key_str</vh></v>
</v>
<v t="ekr.20230509052845.4953"><vh>test_zip_longest</vh></v>
<v t="ekr.20230509052845.4954"><vh>test_zip_test</vh></v>
<v t="ekr.20230509052845.4955"><vh>test_combinations()</vh></v>
<v t="ekr.20230509052845.4956"><vh>test_accumulate_from_cpython</vh></v>
<v t="ekr.20230509052845.4957"><vh>test_accumulate_from_cpython()</vh></v>
<v t="ekr.20230509052845.4958"><vh>test_chain_from_cpython</vh></v>
<v t="ekr.20230509052845.4959"><vh>test_chain_from_cpython()</vh></v>
<v t="ekr.20230509052845.4960"><vh>test_chain_from_iterable_from_cpython</vh></v>
<v t="ekr.20230509052845.4961"><vh>test_chain_from_iterable_from_cpython()</vh></v>
<v t="ekr.20230509052845.4962"><vh>test_combinations_from_cpython</vh></v>
<v t="ekr.20230509052845.4963"><vh>test_combinations_from_cpython()</vh></v>
<v t="ekr.20230509052845.4964"><vh>test_combinations_with_replacement_from_cpython</vh>
<v t="ekr.20230509052845.4965"><vh>numcombs</vh></v>
</v>
<v t="ekr.20230509052845.4966"><vh>test_combinations_with_replacement_from_cpython()</vh></v>
<v t="ekr.20230509052845.4967"><vh>test_permutations_from_cpython</vh></v>
<v t="ekr.20230509052845.4968"><vh>test_permutations_from_cpython()</vh></v>
<v t="ekr.20230509052845.4969"><vh>class List</vh>
<v t="ekr.20230509052845.4970"><vh>List.__lt__</vh></v>
<v t="ekr.20230509052845.4971"><vh>List.__le__</vh></v>
<v t="ekr.20230509052845.4972"><vh>List.__gt__</vh></v>
<v t="ekr.20230509052845.4973"><vh>List.__ge__</vh></v>
</v>
<v t="ekr.20230509052845.4974"><vh>test_combinatorics_from_cpython</vh></v>
<v t="ekr.20230509052845.4975"><vh>test_combinatorics_from_cpython()</vh></v>
<v t="ekr.20230509052845.4976"><vh>test_compress_from_cpython</vh></v>
<v t="ekr.20230509052845.4977"><vh>test_compress_from_cpython()</vh></v>
<v t="ekr.20230509052845.4978"><vh>test_count_from_cpython</vh></v>
<v t="ekr.20230509052845.4979"><vh>test_count_from_cpython()</vh></v>
<v t="ekr.20230509052845.4980"><vh>test_count_with_stride_from_cpython</vh></v>
<v t="ekr.20230509052845.4981"><vh>test_count_with_stride_from_cpython()</vh></v>
<v t="ekr.20230509052845.4982"><vh>test_cycle_from_cpython</vh></v>
<v t="ekr.20230509052845.4983"><vh>test_cycle_from_cpython()</vh></v>
<v t="ekr.20230509052845.4984"><vh>test_groupby_from_cpython</vh></v>
<v t="ekr.20230509052845.4985"><vh>test_groupby_from_cpython()</vh></v>
<v t="ekr.20230509052845.4986"><vh>test_filter_from_cpython</vh></v>
<v t="ekr.20230509052845.4987"><vh>test_filter_from_cpython()</vh></v>
<v t="ekr.20230509052845.4988"><vh>test_filterfalse_from_cpython</vh></v>
<v t="ekr.20230509052845.4989"><vh>test_filterfalse_from_cpython()</vh></v>
<v t="ekr.20230509052845.4990"><vh>test_zip_from_cpython</vh></v>
<v t="ekr.20230509052845.4991"><vh>test_zip_from_cpython()</vh></v>
<v t="ekr.20230509052845.4992"><vh>test_ziplongest_from_cpython</vh></v>
<v t="ekr.20230509052845.4993"><vh>test_ziplongest_from_cpython()</vh></v>
<v t="ekr.20230509052845.4994"><vh>test_product_from_cpython</vh></v>
<v t="ekr.20230509052845.4995"><vh>test_product_from_cpython()</vh></v>
<v t="ekr.20230509052845.4996"><vh>test_repeat_from_cpython</vh></v>
<v t="ekr.20230509052845.4997"><vh>test_repeat_from_cpython()</vh></v>
<v t="ekr.20230509052845.4998"><vh>test_map_from_cpython</vh></v>
<v t="ekr.20230509052845.4999"><vh>test_map_from_cpython()</vh></v>
<v t="ekr.20230509052845.5000"><vh>test_starmap_from_cpython</vh></v>
<v t="ekr.20230509052845.5001"><vh>test_starmap_from_cpython()</vh></v>
<v t="ekr.20230509052845.5002"><vh>test_islice_from_cpython</vh></v>
<v t="ekr.20230509052845.5003"><vh>test_islice_from_cpython()</vh></v>
<v t="ekr.20230509052845.5004"><vh>test_takewhile_from_cpython</vh></v>
<v t="ekr.20230509052845.5005"><vh>test_takewhile_from_cpython()</vh></v>
<v t="ekr.20230509052845.5006"><vh>test_dropwhile_from_cpython</vh></v>
<v t="ekr.20230509052845.5007"><vh>test_dropwhile_from_cpython()</vh></v>
<v t="ekr.20230509052845.5008"><vh>test_tee_from_cpython</vh></v>
</v>
<v t="ekr.20230509052845.5009"><vh>@@clean math_test.codon</vh>
<v t="ekr.20230509052845.5010"><vh>close</vh></v>
<v t="ekr.20230509052845.5011"><vh>test_isnan</vh></v>
<v t="ekr.20230509052845.5012"><vh>test_isinf</vh></v>
<v t="ekr.20230509052845.5013"><vh>test_isfinite</vh></v>
<v t="ekr.20230509052845.5014"><vh>test_ceil</vh></v>
<v t="ekr.20230509052845.5015"><vh>test_floor</vh></v>
<v t="ekr.20230509052845.5016"><vh>test_fabs</vh></v>
<v t="ekr.20230509052845.5017"><vh>test_fmod</vh></v>
<v t="ekr.20230509052845.5018"><vh>test_exp</vh></v>
<v t="ekr.20230509052845.5019"><vh>test_expm1</vh></v>
<v t="ekr.20230509052845.5020"><vh>test_ldexp</vh></v>
<v t="ekr.20230509052845.5021"><vh>test_log</vh></v>
<v t="ekr.20230509052845.5022"><vh>test_log2</vh></v>
<v t="ekr.20230509052845.5023"><vh>test_log10</vh></v>
<v t="ekr.20230509052845.5024"><vh>test_degrees</vh></v>
<v t="ekr.20230509052845.5025"><vh>test_radians</vh></v>
<v t="ekr.20230509052845.5026"><vh>test_sqrt</vh></v>
<v t="ekr.20230509052845.5027"><vh>test_pow</vh></v>
<v t="ekr.20230509052845.5028"><vh>test_acos</vh></v>
<v t="ekr.20230509052845.5029"><vh>test_asin</vh></v>
<v t="ekr.20230509052845.5030"><vh>test_atan</vh></v>
<v t="ekr.20230509052845.5031"><vh>test_atan2</vh></v>
<v t="ekr.20230509052845.5032"><vh>test_cos</vh></v>
<v t="ekr.20230509052845.5033"><vh>test_sin</vh></v>
<v t="ekr.20230509052845.5034"><vh>test_hypot</vh></v>
<v t="ekr.20230509052845.5035"><vh>test_tan</vh></v>
<v t="ekr.20230509052845.5036"><vh>test_cosh</vh></v>
<v t="ekr.20230509052845.5037"><vh>test_sinh</vh></v>
<v t="ekr.20230509052845.5038"><vh>test_tanh</vh></v>
<v t="ekr.20230509052845.5039"><vh>test_acosh</vh></v>
<v t="ekr.20230509052845.5040"><vh>test_asinh</vh></v>
<v t="ekr.20230509052845.5041"><vh>test_atanh</vh></v>
<v t="ekr.20230509052845.5042"><vh>test_copysign</vh></v>
<v t="ekr.20230509052845.5043"><vh>test_log1p</vh></v>
<v t="ekr.20230509052845.5044"><vh>test_trunc</vh></v>
<v t="ekr.20230509052845.5045"><vh>test_erf</vh></v>
<v t="ekr.20230509052845.5046"><vh>test_erfc</vh></v>
<v t="ekr.20230509052845.5047"><vh>test_gamma</vh></v>
<v t="ekr.20230509052845.5048"><vh>test_lgamma</vh></v>
<v t="ekr.20230509052845.5049"><vh>test_remainder</vh></v>
<v t="ekr.20230509052845.5050"><vh>test_gcd</vh></v>
<v t="ekr.20230509052845.5051"><vh>test_frexp</vh></v>
<v t="ekr.20230509052845.5052"><vh>test_modf</vh></v>
<v t="ekr.20230509052845.5053"><vh>test_isclose</vh></v>
<v t="ekr.20230509052845.5054"><vh>test_fsum</vh>
<v t="ekr.20230509052845.5055"><vh>sum_exact</vh></v>
<v t="ekr.20230509052845.5056"><vh>msum</vh></v>
<v t="ekr.20230509052845.5057"><vh>float1</vh></v>
<v t="ekr.20230509052845.5058"><vh>float2</vh></v>
<v t="ekr.20230509052845.5059"><vh>float3</vh></v>
</v>
<v t="ekr.20230509052845.5060"><vh>test_isnan()</vh></v>
<v t="ekr.20230509052845.5061"><vh>close32</vh></v>
<v t="ekr.20230509052845.5062"><vh>test_float32_isnan</vh></v>
<v t="ekr.20230509052845.5063"><vh>test_float32_isinf</vh></v>
<v t="ekr.20230509052845.5064"><vh>test_float32_isfinite</vh></v>
<v t="ekr.20230509052845.5065"><vh>test_float32_ceil</vh></v>
<v t="ekr.20230509052845.5066"><vh>test_float32_floor</vh></v>
<v t="ekr.20230509052845.5067"><vh>test_float32_fabs</vh></v>
<v t="ekr.20230509052845.5068"><vh>test_float32_fmod</vh></v>
<v t="ekr.20230509052845.5069"><vh>test_float32_exp</vh></v>
<v t="ekr.20230509052845.5070"><vh>test_float32_expm1</vh></v>
<v t="ekr.20230509052845.5071"><vh>test_float32_ldexp</vh></v>
<v t="ekr.20230509052845.5072"><vh>test_float32_log</vh></v>
<v t="ekr.20230509052845.5073"><vh>test_float32_log2</vh></v>
<v t="ekr.20230509052845.5074"><vh>test_float32_log10</vh></v>
<v t="ekr.20230509052845.5075"><vh>test_float32_degrees</vh></v>
<v t="ekr.20230509052845.5076"><vh>test_float32_radians</vh></v>
<v t="ekr.20230509052845.5077"><vh>test_float32_sqrt</vh></v>
<v t="ekr.20230509052845.5078"><vh>test_float32_pow</vh></v>
<v t="ekr.20230509052845.5079"><vh>test_float32_acos</vh></v>
<v t="ekr.20230509052845.5080"><vh>test_float32_asin</vh></v>
<v t="ekr.20230509052845.5081"><vh>test_float32_atan</vh></v>
<v t="ekr.20230509052845.5082"><vh>test_float32_atan2</vh></v>
<v t="ekr.20230509052845.5083"><vh>test_float32_cos</vh></v>
<v t="ekr.20230509052845.5084"><vh>test_float32_sin</vh></v>
<v t="ekr.20230509052845.5085"><vh>test_float32_hypot</vh></v>
<v t="ekr.20230509052845.5086"><vh>test_float32_tan</vh></v>
<v t="ekr.20230509052845.5087"><vh>test_float32_cosh</vh></v>
<v t="ekr.20230509052845.5088"><vh>test_float32_sinh</vh></v>
<v t="ekr.20230509052845.5089"><vh>test_float32_tanh</vh></v>
<v t="ekr.20230509052845.5090"><vh>test_float32_acosh</vh></v>
<v t="ekr.20230509052845.5091"><vh>test_float32_asinh</vh></v>
<v t="ekr.20230509052845.5092"><vh>test_float32_atanh</vh></v>
<v t="ekr.20230509052845.5093"><vh>test_float32_copysign</vh></v>
<v t="ekr.20230509052845.5094"><vh>test_float32_log1p</vh></v>
<v t="ekr.20230509052845.5095"><vh>test_float32_trunc</vh></v>
<v t="ekr.20230509052845.5096"><vh>test_float32_erf</vh></v>
<v t="ekr.20230509052845.5097"><vh>test_float32_erfc</vh></v>
<v t="ekr.20230509052845.5098"><vh>test_float32_gamma</vh></v>
<v t="ekr.20230509052845.5099"><vh>test_float32_lgamma</vh></v>
<v t="ekr.20230509052845.5100"><vh>test_float32_remainder</vh></v>
<v t="ekr.20230509052845.5101"><vh>test_float32_gcd</vh></v>
<v t="ekr.20230509052845.5102"><vh>test_float32_frexp</vh></v>
<v t="ekr.20230509052845.5103"><vh>test_float32_modf</vh></v>
<v t="ekr.20230509052845.5104"><vh>test_float32_isclose</vh></v>
</v>
<v t="ekr.20230509052845.5105"><vh>@@clean operator_test.codon</vh>
<v t="ekr.20230509052845.5106"><vh>apply1</vh></v>
<v t="ekr.20230509052845.5107"><vh>apply2</vh></v>
<v t="ekr.20230509052845.5108"><vh>n_eq = 0</vh></v>
<v t="ekr.20230509052845.5109"><vh>class C</vh>
<v t="ekr.20230509052845.5110"><vh>C.__eq__</vh></v>
<v t="ekr.20230509052845.5111"><vh>C.__ne__</vh></v>
<v t="ekr.20230509052845.5112"><vh>C.__lt__</vh></v>
<v t="ekr.20230509052845.5113"><vh>C.__le__</vh></v>
<v t="ekr.20230509052845.5114"><vh>C.__gt__</vh></v>
<v t="ekr.20230509052845.5115"><vh>C.__ge__</vh></v>
<v t="ekr.20230509052845.5116"><vh>C.__len__</vh></v>
<v t="ekr.20230509052845.5117"><vh>C.__bool__</vh></v>
<v t="ekr.20230509052845.5118"><vh>C.__abs__</vh></v>
<v t="ekr.20230509052845.5119"><vh>C.__pos__</vh></v>
<v t="ekr.20230509052845.5120"><vh>C.__neg__</vh></v>
<v t="ekr.20230509052845.5121"><vh>C.__invert__</vh></v>
<v t="ekr.20230509052845.5122"><vh>C.__index__</vh></v>
<v t="ekr.20230509052845.5123"><vh>C.__add__</vh></v>
<v t="ekr.20230509052845.5124"><vh>C.__sub__</vh></v>
<v t="ekr.20230509052845.5125"><vh>C.__mul__</vh></v>
<v t="ekr.20230509052845.5126"><vh>C.__matmul__</vh></v>
<v t="ekr.20230509052845.5127"><vh>C.__truediv__</vh></v>
<v t="ekr.20230509052845.5128"><vh>C.__floordiv__</vh></v>
<v t="ekr.20230509052845.5129"><vh>C.__mod__</vh></v>
<v t="ekr.20230509052845.5130"><vh>C.__pow__</vh></v>
<v t="ekr.20230509052845.5131"><vh>C.__and__</vh></v>
<v t="ekr.20230509052845.5132"><vh>C.__or__</vh></v>
<v t="ekr.20230509052845.5133"><vh>C.__xor__</vh></v>
<v t="ekr.20230509052845.5134"><vh>C.__lshift__</vh></v>
<v t="ekr.20230509052845.5135"><vh>C.__rshift__</vh></v>
<v t="ekr.20230509052845.5136"><vh>C.__iadd__</vh></v>
<v t="ekr.20230509052845.5137"><vh>C.__isub__</vh></v>
<v t="ekr.20230509052845.5138"><vh>C.__imul__</vh></v>
<v t="ekr.20230509052845.5139"><vh>C.__imatmul__</vh></v>
<v t="ekr.20230509052845.5140"><vh>C.__itruediv__</vh></v>
<v t="ekr.20230509052845.5141"><vh>C.__ifloordiv__</vh></v>
<v t="ekr.20230509052845.5142"><vh>C.__imod__</vh></v>
<v t="ekr.20230509052845.5143"><vh>C.__ipow__</vh></v>
<v t="ekr.20230509052845.5144"><vh>C.__iand__</vh></v>
<v t="ekr.20230509052845.5145"><vh>C.__ior__</vh></v>
<v t="ekr.20230509052845.5146"><vh>C.__ixor__</vh></v>
<v t="ekr.20230509052845.5147"><vh>C.__ilshift__</vh></v>
<v t="ekr.20230509052845.5148"><vh>C.__irshift__</vh></v>
</v>
<v t="ekr.20230509052845.5149"><vh>test_comparisons</vh></v>
<v t="ekr.20230509052845.5150"><vh>test_comparisons()</vh></v>
<v t="ekr.20230509052845.5151"><vh>class A1</vh></v>
<v t="ekr.20230509052845.5152"><vh>class A2</vh></v>
<v t="ekr.20230509052845.5153"><vh>test_truthiness</vh></v>
<v t="ekr.20230509052845.5154"><vh>test_truthiness()</vh></v>
<v t="ekr.20230509052845.5155"><vh>test_ops</vh></v>
<v t="ekr.20230509052845.5156"><vh>test_ops()</vh></v>
<v t="ekr.20230509052845.5157"><vh>class B1</vh></v>
<v t="ekr.20230509052845.5158"><vh>class B2</vh></v>
<v t="ekr.20230509052845.5159"><vh>class B3</vh></v>
<v t="ekr.20230509052845.5160"><vh>test_sequence_ops</vh></v>
<v t="ekr.20230509052845.5161"><vh>test_sequence_ops()</vh></v>
<v t="ekr.20230509052845.5162"><vh>class C</vh>
<v t="ekr.20230509052845.5163"><vh>C.__init__</vh></v>
<v t="ekr.20230509052845.5164"><vh>C.bar</vh></v>
</v>
<v t="ekr.20230509052845.5165"><vh>test_getter_ops</vh></v>
</v>
<v t="ekr.20230509052845.5166"><vh>@@clean random_test.codon</vh>
<v t="ekr.20230509052845.5167"><vh>test_rnd_result</vh></v>
<v t="ekr.20230509052845.5168"><vh>test_rnd_result(</vh></v>
<v t="ekr.20230509052845.5169"><vh>test_shuffle</vh></v>
<v t="ekr.20230509052845.5170"><vh>test_shuffle(list(range(100)))</vh></v>
<v t="ekr.20230509052845.5171"><vh>test_sample</vh></v>
<v t="ekr.20230509052845.5172"><vh>test_sample(100, 5)</vh></v>
<v t="ekr.20230509052845.5173"><vh>test_vs_python</vh></v>
<v t="ekr.20230509052845.5174"><vh>test_vs_python(-10, 10, seed=22, method='randrange', T=int)</vh></v>
<v t="ekr.20230509052845.5175"><vh>test_state</vh></v>
</v>
<v t="ekr.20230509052845.5176"><vh>@@clean re_test.codon</vh>
<v t="ekr.20230509052845.5177"><vh>test_search_star_plus</vh></v>
<v t="ekr.20230509052845.5178"><vh>test_search_star_plus()</vh></v>
<v t="ekr.20230509052845.5179"><vh>test_branching</vh></v>
<v t="ekr.20230509052845.5180"><vh>test_branching()</vh></v>
<v t="ekr.20230509052845.5181"><vh>test_basic_re_sub</vh>
<v t="ekr.20230509052845.5182"><vh>bump_num</vh></v>
</v>
<v t="ekr.20230509052845.5183"><vh>test_basic_re_sub()</vh></v>
<v t="ekr.20230509052845.5184"><vh>test_bug_449964</vh></v>
<v t="ekr.20230509052845.5185"><vh>test_bug_449964()</vh></v>
<v t="ekr.20230509052845.5186"><vh>test_bug_449000</vh></v>
<v t="ekr.20230509052845.5187"><vh>test_bug_449000()</vh></v>
<v t="ekr.20230509052845.5188"><vh>test_sub_template_numeric_escape</vh></v>
<v t="ekr.20230509052845.5189"><vh>test_sub_template_numeric_escape()</vh></v>
<v t="ekr.20230509052845.5190"><vh>test_qualified_re_sub</vh></v>
<v t="ekr.20230509052845.5191"><vh>test_qualified_re_sub()</vh></v>
<v t="ekr.20230509052845.5192"><vh>test_bug_114660</vh></v>
<v t="ekr.20230509052845.5193"><vh>test_bug_114660()</vh></v>
<v t="ekr.20230509052845.5194"><vh>test_symbolic_refs</vh></v>
<v t="ekr.20230509052845.5195"><vh>test_symbolic_refs()</vh></v>
<v t="ekr.20230509052845.5196"><vh>test_re_subn</vh></v>
<v t="ekr.20230509052845.5197"><vh>test_re_subn()</vh></v>
<v t="ekr.20230509052845.5198"><vh>cmp_opt</vh></v>
<v t="ekr.20230509052845.5199"><vh>cmp_list</vh></v>
<v t="ekr.20230509052845.5200"><vh>cmp_tuple</vh></v>
<v t="ekr.20230509052845.5201"><vh>test_re_split</vh></v>
<v t="ekr.20230509052845.5202"><vh>test_re_split()</vh></v>
<v t="ekr.20230509052845.5203"><vh>test_qualified_re_split</vh></v>
<v t="ekr.20230509052845.5204"><vh>test_qualified_re_split()</vh></v>
<v t="ekr.20230509052845.5205"><vh>test_re_findall</vh></v>
<v t="ekr.20230509052845.5206"><vh>test_re_findall()</vh></v>
<v t="ekr.20230509052845.5207"><vh>test_re_match</vh></v>
<v t="ekr.20230509052845.5208"><vh>test_re_match()</vh></v>
<v t="ekr.20230509052845.5209"><vh>raises</vh></v>
<v t="ekr.20230509052845.5210"><vh>test_group</vh>
<v t="ekr.20230509052845.5211"><vh>class Index</vh></v>
</v>
<v t="ekr.20230509052845.5212"><vh>test_group()</vh></v>
<v t="ekr.20230509052845.5213"><vh>test_match_getitem</vh></v>
<v t="ekr.20230509052845.5214"><vh>test_match_getitem()</vh></v>
<v t="ekr.20230509052845.5215"><vh>test_re_fullmatch</vh></v>
<v t="ekr.20230509052845.5216"><vh>test_re_fullmatch()</vh></v>
<v t="ekr.20230509052845.5217"><vh>test_finditer</vh></v>
<v t="ekr.20230509052845.5218"><vh>test_finditer()</vh></v>
<v t="ekr.20230509052845.5219"><vh>test_constants</vh></v>
<v t="ekr.20230509052845.5220"><vh>test_constants()</vh></v>
<v t="ekr.20230509052845.5221"><vh>test_anyall</vh></v>
<v t="ekr.20230509052845.5222"><vh>test_anyall()</vh></v>
<v t="ekr.20230509052845.5223"><vh>test_groupdict</vh></v>
<v t="ekr.20230509052845.5224"><vh>test_groupdict()</vh></v>
<v t="ekr.20230509052845.5225"><vh>test_expand</vh></v>
<v t="ekr.20230509052845.5226"><vh>test_expand()</vh></v>
<v t="ekr.20230509052845.5227"><vh>test_getattr</vh></v>
<v t="ekr.20230509052845.5228"><vh>test_getattr()</vh></v>
<v t="ekr.20230509052845.5229"><vh>check_match</vh></v>
<v t="ekr.20230509052845.5230"><vh>LITERAL_CHARS = string.ascii_letters + string.digits</vh></v>
<v t="ekr.20230509052845.5231"><vh>test_re_escape</vh></v>
</v>
<v t="ekr.20230509052845.5232"><vh>@@clean sort_test.codon</vh>
<v t="ekr.20230509052845.5233"><vh>key</vh></v>
<v t="ekr.20230509052845.5234"><vh>gen_list</vh></v>
<v t="ekr.20230509052845.5235"><vh>copy_to</vh></v>
<v t="ekr.20230509052845.5236"><vh>ensure_sorted</vh></v>
<v t="ekr.20230509052845.5237"><vh>v0 = gen_list(100)</vh></v>
<v t="ekr.20230509052845.5238"><vh>test_sort1</vh></v>
<v t="ekr.20230509052845.5239"><vh>test_sort1("qsort   :", qsort_inplace)</vh></v>
<v t="ekr.20230509052845.5240"><vh>test_sort2</vh></v>
<v t="ekr.20230509052845.5241"><vh>test_sort2("qsort   :", qsort_inplace)</vh></v>
<v t="ekr.20230509052845.5242"><vh>test_standard_sort</vh></v>
</v>
<v t="ekr.20230509052845.5243"><vh>@@clean statistics_test.codon</vh>
<v t="ekr.20230509052845.5244"><vh>med</vh></v>
<v t="ekr.20230509052845.5245"><vh>med()</vh></v>
<v t="ekr.20230509052845.5246"><vh>med_low</vh></v>
<v t="ekr.20230509052845.5247"><vh>med_low()</vh></v>
<v t="ekr.20230509052845.5248"><vh>med_high</vh></v>
<v t="ekr.20230509052845.5249"><vh>med_high()</vh></v>
<v t="ekr.20230509052845.5250"><vh>med_grouped</vh></v>
<v t="ekr.20230509052845.5251"><vh>med_grouped()</vh></v>
<v t="ekr.20230509052845.5252"><vh>test_mode</vh></v>
<v t="ekr.20230509052845.5253"><vh>test_mode()</vh></v>
<v t="ekr.20230509052845.5254"><vh>test_multimode</vh></v>
<v t="ekr.20230509052845.5255"><vh>test_multimode()</vh></v>
<v t="ekr.20230509052845.5256"><vh>test_quantiles</vh></v>
<v t="ekr.20230509052845.5257"><vh>test_quantiles()</vh></v>
<v t="ekr.20230509052845.5258"><vh>test_mean</vh></v>
<v t="ekr.20230509052845.5259"><vh>test_mean()</vh></v>
<v t="ekr.20230509052845.5260"><vh>test_geometric_mean</vh></v>
<v t="ekr.20230509052845.5261"><vh>test_geometric_mean()</vh></v>
<v t="ekr.20230509052845.5262"><vh>test_harmonic_mean</vh></v>
<v t="ekr.20230509052845.5263"><vh>test_harmonic_mean()</vh></v>
<v t="ekr.20230509052845.5264"><vh>test_pvariance</vh></v>
<v t="ekr.20230509052845.5265"><vh>test_pvariance()</vh></v>
<v t="ekr.20230509052845.5266"><vh>test_pstdev</vh></v>
<v t="ekr.20230509052845.5267"><vh>test_pstdev()</vh></v>
<v t="ekr.20230509052845.5268"><vh>test_variance</vh></v>
<v t="ekr.20230509052845.5269"><vh>test_variance()</vh></v>
<v t="ekr.20230509052845.5270"><vh>test_stdev</vh></v>
<v t="ekr.20230509052845.5271"><vh>test_stdev()</vh></v>
<v t="ekr.20230509052845.5272"><vh>test_mean_NormalDist</vh></v>
<v t="ekr.20230509052845.5273"><vh>test_mean_NormalDist()</vh></v>
<v t="ekr.20230509052845.5274"><vh>test_stdev</vh></v>
<v t="ekr.20230509052845.5275"><vh>test_stdev()</vh></v>
<v t="ekr.20230509052845.5276"><vh>test_variance</vh></v>
<v t="ekr.20230509052845.5277"><vh>test_variance()</vh></v>
<v t="ekr.20230509052845.5278"><vh>test_pdf</vh></v>
<v t="ekr.20230509052845.5279"><vh>test_pdf()</vh></v>
<v t="ekr.20230509052845.5280"><vh>test_cdf</vh></v>
<v t="ekr.20230509052845.5281"><vh>test_cdf()</vh></v>
<v t="ekr.20230509052845.5282"><vh>test_inv_cdf</vh></v>
<v t="ekr.20230509052845.5283"><vh>test_inv_cdf()</vh></v>
<v t="ekr.20230509052845.5284"><vh>test_ND_quartiles</vh></v>
<v t="ekr.20230509052845.5285"><vh>test_ND_quartiles()</vh></v>
<v t="ekr.20230509052845.5286"><vh>test_overlap</vh></v>
<v t="ekr.20230509052845.5287"><vh>test_overlap()</vh></v>
<v t="ekr.20230509052845.5288"><vh>test_samples</vh></v>
<v t="ekr.20230509052845.5289"><vh>test_samples()</vh></v>
<v t="ekr.20230509052845.5290"><vh>test_from_samples</vh></v>
</v>
<v t="ekr.20230509052845.5291"><vh>@@clean str_test.codon</vh>
<v t="ekr.20230509052845.5292"><vh>test_isdigit</vh></v>
<v t="ekr.20230509052845.5293"><vh>test_islower</vh></v>
<v t="ekr.20230509052845.5294"><vh>test_isupper</vh></v>
<v t="ekr.20230509052845.5295"><vh>test_isalnum</vh></v>
<v t="ekr.20230509052845.5296"><vh>test_isalpha</vh></v>
<v t="ekr.20230509052845.5297"><vh>test_isspace</vh></v>
<v t="ekr.20230509052845.5298"><vh>test_istitle</vh></v>
<v t="ekr.20230509052845.5299"><vh>test_capitalize</vh></v>
<v t="ekr.20230509052845.5300"><vh>test_isdecimal</vh></v>
<v t="ekr.20230509052845.5301"><vh>test_lower</vh></v>
<v t="ekr.20230509052845.5302"><vh>test_upper</vh></v>
<v t="ekr.20230509052845.5303"><vh>test_isascii</vh></v>
<v t="ekr.20230509052845.5304"><vh>test_casefold</vh></v>
<v t="ekr.20230509052845.5305"><vh>test_swapcase</vh></v>
<v t="ekr.20230509052845.5306"><vh>test_title</vh></v>
<v t="ekr.20230509052845.5307"><vh>test_isnumeric</vh></v>
<v t="ekr.20230509052845.5308"><vh>test_ljust</vh></v>
<v t="ekr.20230509052845.5309"><vh>test_rjust</vh></v>
<v t="ekr.20230509052845.5310"><vh>test_center</vh></v>
<v t="ekr.20230509052845.5311"><vh>test_zfill</vh></v>
<v t="ekr.20230509052845.5312"><vh>test_count</vh></v>
<v t="ekr.20230509052845.5313"><vh>test_find</vh></v>
<v t="ekr.20230509052845.5314"><vh>test_rfind</vh></v>
<v t="ekr.20230509052845.5315"><vh>test_isidentifier</vh></v>
<v t="ekr.20230509052845.5316"><vh>test_isprintable</vh></v>
<v t="ekr.20230509052845.5317"><vh>test_lstrip</vh></v>
<v t="ekr.20230509052845.5318"><vh>test_rstrip</vh></v>
<v t="ekr.20230509052845.5319"><vh>test_strip</vh></v>
<v t="ekr.20230509052845.5320"><vh>test_partition</vh></v>
<v t="ekr.20230509052845.5321"><vh>test_rpartition</vh></v>
<v t="ekr.20230509052845.5322"><vh>test_split</vh></v>
<v t="ekr.20230509052845.5323"><vh>test_rsplit</vh></v>
<v t="ekr.20230509052845.5324"><vh>test_splitlines</vh></v>
<v t="ekr.20230509052845.5325"><vh>test_startswith</vh></v>
<v t="ekr.20230509052845.5326"><vh>test_endswith</vh></v>
<v t="ekr.20230509052845.5327"><vh>test_index</vh></v>
<v t="ekr.20230509052845.5328"><vh>test_rindex</vh></v>
<v t="ekr.20230509052845.5329"><vh>test_replace</vh></v>
<v t="ekr.20230509052845.5330"><vh>test_expandtabs</vh></v>
<v t="ekr.20230509052845.5331"><vh>test_translate</vh></v>
<v t="ekr.20230509052845.5332"><vh>test_repr</vh></v>
<v t="ekr.20230509052845.5333"><vh>test_fstr</vh></v>
<v t="ekr.20230509052845.5334"><vh>test_slice</vh></v>
<v t="ekr.20230509052845.5335"><vh>test_join</vh></v>
<v t="ekr.20230509052845.5336"><vh>test_repr</vh></v>
</v>
</v>
<v t="ekr.20230509052845.5337"><vh>@path transform</vh>
<v t="ekr.20230509052845.5338"><vh>@@clean canonical.codon</vh>
<v t="ekr.20230509052845.5339"><vh>class Vec</vh>
<v t="ekr.20230509052845.5340"><vh>Vec.__abs__</vh></v>
<v t="ekr.20230509052845.5341"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.5342"><vh>Vec.__add__</vh></v>
<v t="ekr.20230509052845.5343"><vh>Vec.__sub__</vh></v>
<v t="ekr.20230509052845.5344"><vh>Vec.__sub__</vh></v>
<v t="ekr.20230509052845.5345"><vh>Vec.__mul__</vh></v>
<v t="ekr.20230509052845.5346"><vh>Vec.__mul__</vh></v>
<v t="ekr.20230509052845.5347"><vh>Vec.__eq__</vh></v>
<v t="ekr.20230509052845.5348"><vh>Vec.__ne__</vh></v>
<v t="ekr.20230509052845.5349"><vh>Vec.__lt__</vh></v>
<v t="ekr.20230509052845.5350"><vh>Vec.__le__</vh></v>
<v t="ekr.20230509052845.5351"><vh>Vec.__gt__</vh></v>
<v t="ekr.20230509052845.5352"><vh>Vec.__ge__</vh></v>
</v>
<v t="ekr.20230509052845.5353"><vh>test_op_chain_canon</vh>
<v t="ekr.20230509052845.5354"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.5355"><vh>test_op_chain_canon()</vh></v>
<v t="ekr.20230509052845.5356"><vh>class C</vh></v>
<v t="ekr.20230509052845.5357"><vh>test_inequality_canon</vh>
<v t="ekr.20230509052845.5358"><vh>f</vh></v>
</v>
<v t="ekr.20230509052845.5359"><vh>test_inequality_canon()</vh></v>
<v t="ekr.20230509052845.5360"><vh>test_add_mul_canon</vh></v>
</v>
<v t="ekr.20230509052845.5361"><vh>@@clean dict_opt.codon</vh>
<v t="ekr.20230509052845.5362"><vh>class DummyDict</vh>
<v t="ekr.20230509052845.5363"><vh>DummyDict.__getitem__</vh></v>
<v t="ekr.20230509052845.5364"><vh>DummyDict.get</vh></v>
<v t="ekr.20230509052845.5365"><vh>DummyDict.__setitem__</vh></v>
<v t="ekr.20230509052845.5366"><vh>DummyDict.__dict_do_op_throws__</vh></v>
<v t="ekr.20230509052845.5367"><vh>DummyDict.__dict_do_op__</vh></v>
</v>
<v t="ekr.20230509052845.5368"><vh>class WrappedDict</vh>
<v t="ekr.20230509052845.5369"><vh>WrappedDict.__init__</vh></v>
<v t="ekr.20230509052845.5370"><vh>WrappedDict.__getitem__</vh></v>
<v t="ekr.20230509052845.5371"><vh>WrappedDict.get</vh></v>
<v t="ekr.20230509052845.5372"><vh>WrappedDict.__setitem__</vh></v>
<v t="ekr.20230509052845.5373"><vh>WrappedDict.setdefault</vh></v>
<v t="ekr.20230509052845.5374"><vh>WrappedDict.__dict_do_op_throws__</vh></v>
<v t="ekr.20230509052845.5375"><vh>WrappedDict.__dict_do_op__</vh></v>
</v>
<v t="ekr.20230509052845.5376"><vh>test_dict_op</vh></v>
<v t="ekr.20230509052845.5377"><vh>test_dict_op()</vh></v>
<v t="ekr.20230509052845.5378"><vh>test_dict_do_not_op</vh></v>
<v t="ekr.20230509052845.5379"><vh>test_dict_do_not_op()</vh></v>
<v t="ekr.20230509052845.5380"><vh>test_wrapped_dict</vh>
<v t="ekr.20230509052845.5381"><vh>my_op</vh></v>
<v t="ekr.20230509052845.5382"><vh>my_op_throws</vh></v>
</v>
</v>
<v t="ekr.20230509052845.5383"><vh>@@clean escapes.codon</vh>
<v t="ekr.20230509052845.5384"><vh>expect_capture</vh></v>
<v t="ekr.20230509052845.5385"><vh>g = [0]</vh></v>
<v t="ekr.20230509052845.5386"><vh>make_sure_globals_arent_optd_out</vh></v>
<v t="ekr.20230509052845.5387"><vh>make_sure_globals_arent_optd_out()</vh></v>
<v t="ekr.20230509052845.5388"><vh>test_1</vh></v>
<v t="ekr.20230509052845.5389"><vh>test_1([42])</vh></v>
<v t="ekr.20230509052845.5390"><vh>test_2</vh></v>
<v t="ekr.20230509052845.5391"><vh>test_2([42], [[1]], ['x'])</vh></v>
<v t="ekr.20230509052845.5392"><vh>test_3</vh></v>
<v t="ekr.20230509052845.5393"><vh>test_3([42])</vh></v>
<v t="ekr.20230509052845.5394"><vh>test_4</vh></v>
<v t="ekr.20230509052845.5395"><vh>test_4([42])</vh></v>
<v t="ekr.20230509052845.5396"><vh>test_5</vh></v>
<v t="ekr.20230509052845.5397"><vh>test_5([42])</vh></v>
<v t="ekr.20230509052845.5398"><vh>test_6</vh></v>
<v t="ekr.20230509052845.5399"><vh>test_6([[0]], [42], [[[0]]])</vh></v>
<v t="ekr.20230509052845.5400"><vh>test_7</vh></v>
<v t="ekr.20230509052845.5401"><vh>test_7([11], g, [22])</vh></v>
<v t="ekr.20230509052845.5402"><vh>class X</vh></v>
<v t="ekr.20230509052845.5403"><vh>test_8</vh></v>
<v t="ekr.20230509052845.5404"><vh>test_8([42])</vh></v>
<v t="ekr.20230509052845.5405"><vh>test_9</vh></v>
<v t="ekr.20230509052845.5406"><vh>test_9([42])</vh></v>
<v t="ekr.20230509052845.5407"><vh>test_10</vh></v>
<v t="ekr.20230509052845.5408"><vh>test_10([42], [99])</vh></v>
<v t="ekr.20230509052845.5409"><vh>test_11</vh></v>
<v t="ekr.20230509052845.5410"><vh>test_11([42])</vh></v>
<v t="ekr.20230509052845.5411"><vh>test_12</vh></v>
<v t="ekr.20230509052845.5412"><vh>test_12([42], [[0]])</vh></v>
<v t="ekr.20230509052845.5413"><vh>test_13</vh></v>
<v t="ekr.20230509052845.5414"><vh>test_13([42], 3)</vh></v>
<v t="ekr.20230509052845.5415"><vh>test_14</vh></v>
<v t="ekr.20230509052845.5416"><vh>test_14([42])</vh></v>
<v t="ekr.20230509052845.5417"><vh>class A</vh></v>
<v t="ekr.20230509052845.5418"><vh>test_15</vh></v>
<v t="ekr.20230509052845.5419"><vh>test_15(A(None), A(None))</vh></v>
<v t="ekr.20230509052845.5420"><vh>test_16</vh></v>
<v t="ekr.20230509052845.5421"><vh>test_16(A(None), A(None))</vh></v>
<v t="ekr.20230509052845.5422"><vh>test_17</vh></v>
<v t="ekr.20230509052845.5423"><vh>test_17('hello world')</vh></v>
<v t="ekr.20230509052845.5424"><vh>test_18</vh></v>
<v t="ekr.20230509052845.5425"><vh>test_18([0 for _ in range(0)], 'b')</vh></v>
<v t="ekr.20230509052845.5426"><vh>assign1</vh></v>
<v t="ekr.20230509052845.5427"><vh>test_19</vh></v>
<v t="ekr.20230509052845.5428"><vh>test_19(['a'], ['b'], [True], 'x')</vh></v>
<v t="ekr.20230509052845.5429"><vh>test_20</vh></v>
<v t="ekr.20230509052845.5430"><vh>test_20('x')</vh></v>
<v t="ekr.20230509052845.5431"><vh>test_21</vh></v>
<v t="ekr.20230509052845.5432"><vh>test_21('x')</vh></v>
<v t="ekr.20230509052845.5433"><vh>class A</vh></v>
<v t="ekr.20230509052845.5434"><vh>test_22</vh></v>
<v t="ekr.20230509052845.5435"><vh>test_22('x')</vh></v>
<v t="ekr.20230509052845.5436"><vh>assign</vh></v>
<v t="ekr.20230509052845.5437"><vh>test_23</vh></v>
<v t="ekr.20230509052845.5438"><vh>test_23('x')</vh></v>
<v t="ekr.20230509052845.5439"><vh>class S</vh></v>
<v t="ekr.20230509052845.5440"><vh>test_24</vh></v>
<v t="ekr.20230509052845.5441"><vh>test_24(S('s'), 'b', True)</vh></v>
<v t="ekr.20230509052845.5442"><vh>test_25</vh></v>
<v t="ekr.20230509052845.5443"><vh>test_25(S('s'), 'b', [0,1,0,1])</vh></v>
<v t="ekr.20230509052845.5444"><vh>test_26</vh></v>
<v t="ekr.20230509052845.5445"><vh>test_26(S('s'), 'b', [0,1,0,1])</vh></v>
<v t="ekr.20230509052845.5446"><vh>test_27</vh></v>
</v>
<v t="ekr.20230509052845.5447"><vh>@@clean folding.codon</vh>
<v t="ekr.20230509052845.5448"><vh>inc</vh></v>
<v t="ekr.20230509052845.5449"><vh>class I</vh>
<v t="ekr.20230509052845.5450"><vh>I.__float__</vh></v>
<v t="ekr.20230509052845.5451"><vh>I.__bool__</vh></v>
<v t="ekr.20230509052845.5452"><vh>I.__pos__</vh></v>
<v t="ekr.20230509052845.5453"><vh>I.__neg__</vh></v>
<v t="ekr.20230509052845.5454"><vh>I.__abs__</vh></v>
<v t="ekr.20230509052845.5455"><vh>I.__lshift__</vh></v>
<v t="ekr.20230509052845.5456"><vh>I.__rshift__</vh></v>
<v t="ekr.20230509052845.5457"><vh>I.__add__</vh></v>
<v t="ekr.20230509052845.5458"><vh>I.__add__</vh></v>
<v t="ekr.20230509052845.5459"><vh>I.__sub__</vh></v>
<v t="ekr.20230509052845.5460"><vh>I.__sub__</vh></v>
<v t="ekr.20230509052845.5461"><vh>I.__mul__</vh></v>
<v t="ekr.20230509052845.5462"><vh>I.__mul__</vh></v>
<v t="ekr.20230509052845.5463"><vh>I.__floordiv__</vh></v>
<v t="ekr.20230509052845.5464"><vh>I.__floordiv__</vh></v>
<v t="ekr.20230509052845.5465"><vh>I.__truediv__</vh></v>
<v t="ekr.20230509052845.5466"><vh>I.__truediv__</vh></v>
<v t="ekr.20230509052845.5467"><vh>I.__mod__</vh></v>
<v t="ekr.20230509052845.5468"><vh>I.__mod__</vh></v>
<v t="ekr.20230509052845.5469"><vh>I.__invert__</vh></v>
<v t="ekr.20230509052845.5470"><vh>I.__and__</vh></v>
<v t="ekr.20230509052845.5471"><vh>I.__or__</vh></v>
<v t="ekr.20230509052845.5472"><vh>I.__xor__</vh></v>
<v t="ekr.20230509052845.5473"><vh>I.__shr__</vh></v>
<v t="ekr.20230509052845.5474"><vh>I.__shl__</vh></v>
<v t="ekr.20230509052845.5475"><vh>I.__bitreverse__</vh></v>
<v t="ekr.20230509052845.5476"><vh>I.__bswap__</vh></v>
<v t="ekr.20230509052845.5477"><vh>I.__ctpop__</vh></v>
<v t="ekr.20230509052845.5478"><vh>I.__ctlz__</vh></v>
<v t="ekr.20230509052845.5479"><vh>I.__cttz__</vh></v>
<v t="ekr.20230509052845.5480"><vh>I.__eq__</vh></v>
<v t="ekr.20230509052845.5481"><vh>I.__eq__</vh></v>
<v t="ekr.20230509052845.5482"><vh>I.__ne__</vh></v>
<v t="ekr.20230509052845.5483"><vh>I.__ne__</vh></v>
<v t="ekr.20230509052845.5484"><vh>I.__lt__</vh></v>
<v t="ekr.20230509052845.5485"><vh>I.__lt__</vh></v>
<v t="ekr.20230509052845.5486"><vh>I.__gt__</vh></v>
<v t="ekr.20230509052845.5487"><vh>I.__gt__</vh></v>
<v t="ekr.20230509052845.5488"><vh>I.__le__</vh></v>
<v t="ekr.20230509052845.5489"><vh>I.__le__</vh></v>
<v t="ekr.20230509052845.5490"><vh>I.__ge__</vh></v>
<v t="ekr.20230509052845.5491"><vh>I.__ge__</vh></v>
<v t="ekr.20230509052845.5492"><vh>I.__pow__</vh></v>
<v t="ekr.20230509052845.5493"><vh>I.__pow__</vh></v>
</v>
<v t="ekr.20230509052845.5494"><vh>class int</vh>
<v t="ekr.20230509052845.5495"><vh>int.__int__</vh></v>
<v t="ekr.20230509052845.5496"><vh>int.__float__</vh></v>
<v t="ekr.20230509052845.5497"><vh>int.__bool__</vh></v>
<v t="ekr.20230509052845.5498"><vh>int.__pos__</vh></v>
<v t="ekr.20230509052845.5499"><vh>int.__neg__</vh></v>
<v t="ekr.20230509052845.5500"><vh>int.__lshift__</vh></v>
<v t="ekr.20230509052845.5501"><vh>int.__rshift__</vh></v>
<v t="ekr.20230509052845.5502"><vh>int.__add__</vh></v>
<v t="ekr.20230509052845.5503"><vh>int.__add__</vh></v>
<v t="ekr.20230509052845.5504"><vh>int.__sub__</vh></v>
<v t="ekr.20230509052845.5505"><vh>int.__sub__</vh></v>
<v t="ekr.20230509052845.5506"><vh>int.__mul__</vh></v>
<v t="ekr.20230509052845.5507"><vh>int.__mul__</vh></v>
<v t="ekr.20230509052845.5508"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.5509"><vh>int.__floordiv__</vh></v>
<v t="ekr.20230509052845.5510"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.5511"><vh>int.__truediv__</vh></v>
<v t="ekr.20230509052845.5512"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.5513"><vh>int.__mod__</vh></v>
<v t="ekr.20230509052845.5514"><vh>int.__invert__</vh></v>
<v t="ekr.20230509052845.5515"><vh>int.__and__</vh></v>
<v t="ekr.20230509052845.5516"><vh>int.__or__</vh></v>
<v t="ekr.20230509052845.5517"><vh>int.__xor__</vh></v>
<v t="ekr.20230509052845.5518"><vh>int.__eq__</vh></v>
<v t="ekr.20230509052845.5519"><vh>int.__eq__</vh></v>
<v t="ekr.20230509052845.5520"><vh>int.__ne__</vh></v>
<v t="ekr.20230509052845.5521"><vh>int.__ne__</vh></v>
<v t="ekr.20230509052845.5522"><vh>int.__lt__</vh></v>
<v t="ekr.20230509052845.5523"><vh>int.__lt__</vh></v>
<v t="ekr.20230509052845.5524"><vh>int.__gt__</vh></v>
<v t="ekr.20230509052845.5525"><vh>int.__gt__</vh></v>
<v t="ekr.20230509052845.5526"><vh>int.__le__</vh></v>
<v t="ekr.20230509052845.5527"><vh>int.__le__</vh></v>
<v t="ekr.20230509052845.5528"><vh>int.__ge__</vh></v>
<v t="ekr.20230509052845.5529"><vh>int.__ge__</vh></v>
<v t="ekr.20230509052845.5530"><vh>int.__pow__</vh></v>
<v t="ekr.20230509052845.5531"><vh>int.__pow__</vh></v>
</v>
<v t="ekr.20230509052845.5532"><vh>class F</vh>
<v t="ekr.20230509052845.5533"><vh>F.__int__</vh></v>
<v t="ekr.20230509052845.5534"><vh>F.__float__</vh></v>
<v t="ekr.20230509052845.5535"><vh>F.__bool__</vh></v>
</v>
<v t="ekr.20230509052845.5536"><vh>class float</vh>
<v t="ekr.20230509052845.5537"><vh>float.__int__</vh></v>
<v t="ekr.20230509052845.5538"><vh>float.__float__</vh></v>
<v t="ekr.20230509052845.5539"><vh>float.__bool__</vh></v>
</v>
<v t="ekr.20230509052845.5540"><vh>class bool</vh>
<v t="ekr.20230509052845.5541"><vh>bool.__int__</vh></v>
<v t="ekr.20230509052845.5542"><vh>bool.__float__</vh></v>
<v t="ekr.20230509052845.5543"><vh>bool.__bool__</vh></v>
</v>
<v t="ekr.20230509052845.5544"><vh>eq</vh></v>
<v t="ekr.20230509052845.5545"><vh>foo</vh></v>
<v t="ekr.20230509052845.5546"><vh>test_int_simple_fold</vh></v>
<v t="ekr.20230509052845.5547"><vh>test_int_simple_fold()</vh></v>
<v t="ekr.20230509052845.5548"><vh>test_ternary_fold</vh></v>
<v t="ekr.20230509052845.5549"><vh>test_ternary_fold()</vh></v>
<v t="ekr.20230509052845.5550"><vh>test_try_catch_fold</vh></v>
<v t="ekr.20230509052845.5551"><vh>test_try_catch_fold()</vh></v>
<v t="ekr.20230509052845.5552"><vh>test_while_fold</vh></v>
<v t="ekr.20230509052845.5553"><vh>test_while_fold()</vh></v>
<v t="ekr.20230509052845.5554"><vh>test_imperative_for_fold</vh></v>
<v t="ekr.20230509052845.5555"><vh>test_imperative_for_fold()</vh></v>
<v t="ekr.20230509052845.5556"><vh>test_long_fold</vh></v>
<v t="ekr.20230509052845.5557"><vh>test_long_fold()</vh></v>
<v t="ekr.20230509052845.5558"><vh>test_conversions</vh></v>
<v t="ekr.20230509052845.5559"><vh>test_conversions()</vh></v>
<v t="ekr.20230509052845.5560"><vh>test_no_ops</vh></v>
<v t="ekr.20230509052845.5561"><vh>test_no_ops()</vh></v>
<v t="ekr.20230509052845.5562"><vh>test_algebraic_simplification</vh>
<v t="ekr.20230509052845.5563"><vh>v</vh></v>
</v>
<v t="ekr.20230509052845.5564"><vh>test_algebraic_simplification()</vh></v>
<v t="ekr.20230509052845.5565"><vh>test_global_fold</vh></v>
<v t="ekr.20230509052845.5566"><vh>test_global_fold()</vh></v>
<v t="ekr.20230509052845.5567"><vh>test_global_fold_non_const</vh></v>
<v t="ekr.20230509052845.5568"><vh>test_global_fold_non_const()</vh></v>
<v t="ekr.20230509052845.5569"><vh>test_side_effect_analysis</vh>
<v t="ekr.20230509052845.5570"><vh>foo</vh></v>
<v t="ekr.20230509052845.5571"><vh>bar</vh></v>
<v t="ekr.20230509052845.5572"><vh>baz</vh></v>
<v t="ekr.20230509052845.5573"><vh>fab</vh></v>
</v>
</v>
<v t="ekr.20230509052845.5574"><vh>@@clean for_lowering.codon</vh>
<v t="ekr.20230509052845.5575"><vh>class range</vh></v>
<v t="ekr.20230509052845.5576"><vh>test_for_lowering</vh></v>
</v>
<v t="ekr.20230509052845.5577"><vh>@@clean inlining.codon</vh>
<v t="ekr.20230509052845.5578"><vh>inline_me_aggressive_simple</vh></v>
<v t="ekr.20230509052845.5579"><vh>inline_me_aggressive_complex</vh></v>
<v t="ekr.20230509052845.5580"><vh>inline_me_aggressive_args</vh></v>
<v t="ekr.20230509052845.5581"><vh>inline_me_simple</vh></v>
<v t="ekr.20230509052845.5582"><vh>inline_me_complex</vh></v>
<v t="ekr.20230509052845.5583"><vh>inline_me_args</vh></v>
<v t="ekr.20230509052845.5584"><vh>inlining_test</vh></v>
<v t="ekr.20230509052845.5585"><vh>inlining_test()</vh></v>
<v t="ekr.20230509052845.5586"><vh>inline_me_aggressive_nested_while_finally</vh></v>
<v t="ekr.20230509052845.5587"><vh>inline_test_nested_while_finally</vh></v>
</v>
<v t="ekr.20230509052845.5588"><vh>@@clean io_opt.codon</vh>
<v t="ekr.20230509052845.5589"><vh>class DummyFile</vh></v>
<v t="ekr.20230509052845.5590"><vh>test_file_io</vh></v>
<v t="ekr.20230509052845.5591"><vh>test_file_io()</vh></v>
<v t="ekr.20230509052845.5592"><vh>test_print</vh></v>
</v>
<v t="ekr.20230509052845.5593"><vh>@@clean kernels.codon</vh>
<v t="ekr.20230509052845.5594"><vh>test_hello_world</vh>
<v t="ekr.20230509052845.5595"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5596"><vh>test_raw</vh>
<v t="ekr.20230509052845.5597"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5598"><vh>test_conversions</vh>
<v t="ekr.20230509052845.5599"><vh>kernel</vh></v>
<v t="ekr.20230509052845.5600"><vh>check</vh></v>
</v>
<v t="ekr.20230509052845.5601"><vh>test_user_classes</vh>
<v t="ekr.20230509052845.5602"><vh>class A</vh></v>
<v t="ekr.20230509052845.5603"><vh>class B</vh></v>
<v t="ekr.20230509052845.5604"><vh>kernel</vh></v>
<v t="ekr.20230509052845.5605"><vh>a = A(42, [-1])</vh></v>
<v t="ekr.20230509052845.5606"><vh>kernel2</vh></v>
</v>
<v t="ekr.20230509052845.5607"><vh>test_intrinsics</vh>
<v t="ekr.20230509052845.5608"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5609"><vh>test_matmul</vh>
<v t="ekr.20230509052845.5610"><vh>mmz</vh></v>
<v t="ekr.20230509052845.5611"><vh>matmul</vh></v>
<v t="ekr.20230509052845.5612"><vh>expected = matmul(A, B)</vh></v>
<v t="ekr.20230509052845.5613"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5614"><vh>MAX    = 1000  # maximum Mandelbrot iterations</vh></v>
<v t="ekr.20230509052845.5615"><vh>test_mandelbrot</vh>
<v t="ekr.20230509052845.5616"><vh>scale</vh></v>
<v t="ekr.20230509052845.5617"><vh>expected = [0 for _ in range(N * N)]</vh></v>
<v t="ekr.20230509052845.5618"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5619"><vh>test_kitchen_sink</vh>
<v t="ekr.20230509052845.5620"><vh>kernel</vh></v>
</v>
<v t="ekr.20230509052845.5621"><vh>test_auto_par</vh></v>
</v>
<v t="ekr.20230509052845.5622"><vh>@@clean list_opt.codon</vh>
<v t="ekr.20230509052845.5623"><vh>class List</vh>
<v t="ekr.20230509052845.5624"><vh>List.__add__</vh></v>
</v>
<v t="ekr.20230509052845.5625"><vh>test_list_optimization</vh>
<v t="ekr.20230509052845.5626"><vh>f</vh></v>
</v>
</v>
<v t="ekr.20230509052845.5627"><vh>@@clean omp.codon</vh>
<v t="ekr.20230509052845.5628"><vh>class A</vh>
<v t="ekr.20230509052845.5629"><vh>A.__new__</vh></v>
<v t="ekr.20230509052845.5630"><vh>A.__add__</vh></v>
<v t="ekr.20230509052845.5631"><vh>A.__atomic_add__</vh></v>
</v>
<v t="ekr.20230509052845.5632"><vh>test_omp_api</vh></v>
<v t="ekr.20230509052845.5633"><vh>test_omp_schedules</vh></v>
<v t="ekr.20230509052845.5634"><vh>test_omp_ranges</vh>
<v t="ekr.20230509052845.5635"><vh>add</vh></v>
</v>
<v t="ekr.20230509052845.5636"><vh>my_global = 42</vh></v>
<v t="ekr.20230509052845.5637"><vh>class Vector</vh>
<v t="ekr.20230509052845.5638"><vh>Vector.__init__</vh></v>
<v t="ekr.20230509052845.5639"><vh>Vector.__add__</vh></v>
<v t="ekr.20230509052845.5640"><vh>Vector.__str__</vh></v>
</v>
<v t="ekr.20230509052845.5641"><vh>test_omp_reductions</vh>
<v t="ekr.20230509052845.5642"><vh>expected</vh></v>
</v>
<v t="ekr.20230509052845.5643"><vh>another_global = 0</vh></v>
<v t="ekr.20230509052845.5644"><vh>test_omp_critical</vh>
<v t="ekr.20230509052845.5645"><vh>foo</vh></v>
<v t="ekr.20230509052845.5646"><vh>bar</vh></v>
</v>
<v t="ekr.20230509052845.5647"><vh>test_omp_non_imperative</vh>
<v t="ekr.20230509052845.5648"><vh>squares</vh></v>
</v>
<v t="ekr.20230509052845.5649"><vh>test_generator_based_loops_global = 0.7</vh></v>
<v t="ekr.20230509052845.5650"><vh>test_omp_non_imperative_reductions</vh>
<v t="ekr.20230509052845.5651"><vh>squares</vh></v>
<v t="ekr.20230509052845.5652"><vh>add</vh></v>
<v t="ekr.20230509052845.5653"><vh>foo</vh></v>
</v>
<v t="ekr.20230509052845.5654"><vh>test_omp_transform</vh></v>
<v t="ekr.20230509052845.5655"><vh>test_omp_nested</vh>
<v t="ekr.20230509052845.5656"><vh>squares</vh></v>
</v>
<v t="ekr.20230509052845.5657"><vh>test_omp_corner_cases</vh>
<v t="ekr.20230509052845.5658"><vh>squares</vh></v>
<v t="ekr.20230509052845.5659"><vh>foo</vh></v>
</v>
<v t="ekr.20230509052845.5660"><vh>test_omp_collapse</vh>
<v t="ekr.20230509052845.5661"><vh>zstart</vh></v>
<v t="ekr.20230509052845.5662"><vh>zstop</vh></v>
</v>
</v>
<v t="ekr.20230509052845.5663"><vh>@@clean outlining.codon</vh>
<v t="ekr.20230509052845.5664"><vh>__outline_begin__</vh></v>
<v t="ekr.20230509052845.5665"><vh>__outline_end__</vh></v>
<v t="ekr.20230509052845.5666"><vh>__outline_successes__</vh></v>
<v t="ekr.20230509052845.5667"><vh>__outline_failures__</vh></v>
<v t="ekr.20230509052845.5668"><vh>N</vh></v>
<v t="ekr.20230509052845.5669"><vh>test_basic_outline</vh></v>
<v t="ekr.20230509052845.5670"><vh>test_basic_outline()</vh></v>
<v t="ekr.20230509052845.5671"><vh>test_private_vars_outline</vh></v>
<v t="ekr.20230509052845.5672"><vh>test_private_vars_outline('x')</vh></v>
<v t="ekr.20230509052845.5673"><vh>test_shared_vars_outline</vh></v>
<v t="ekr.20230509052845.5674"><vh>test_shared_vars_outline(100)</vh></v>
<v t="ekr.20230509052845.5675"><vh>test_shared_vars_with_mod_outline</vh></v>
<v t="ekr.20230509052845.5676"><vh>test_shared_vars_with_mod_outline(100)</vh></v>
<v t="ekr.20230509052845.5677"><vh>test_out_flow_return_outline</vh></v>
<v t="ekr.20230509052845.5678"><vh>test_out_flow_return_outline(100)</vh></v>
<v t="ekr.20230509052845.5679"><vh>test_out_flow_break_continue_outline</vh></v>
<v t="ekr.20230509052845.5680"><vh>test_out_flow_break_continue_outline(100)</vh></v>
<v t="ekr.20230509052845.5681"><vh>test_generator_return_outline</vh></v>
<v t="ekr.20230509052845.5682"><vh>print list(test_generator_return_outline(10))</vh></v>
<v t="ekr.20230509052845.5683"><vh>test_normal_return_outline</vh></v>
<v t="ekr.20230509052845.5684"><vh>print list(test_normal_return_outline(1))</vh></v>
<v t="ekr.20230509052845.5685"><vh>test_invalid_outline_yield</vh></v>
<v t="ekr.20230509052845.5686"><vh>test_invalid_outline_yield(-123)</vh></v>
<v t="ekr.20230509052845.5687"><vh>test_invalid_outline_yield_in</vh></v>
<v t="ekr.20230509052845.5688"><vh>test_invalid_outline_yield_in(-123)</vh></v>
<v t="ekr.20230509052845.5689"><vh>test_invalid_outline_stack_alloc</vh></v>
</v>
<v t="ekr.20230509052845.5690"><vh>@@clean str_opt.codon</vh>
<v t="ekr.20230509052845.5691"><vh>old_cat</vh></v>
<v t="ekr.20230509052845.5692"><vh>class str</vh></v>
<v t="ekr.20230509052845.5693"><vh>test_str_optimization</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20230509052845.1">https://github.com/exaloop/codon</t>
<t tx="ekr.20230509052845.10">def main(n, min_depth=4):
    max_depth = max(min_depth + 2, n)
    stretch_depth = max_depth + 1
    print(f'stretch tree of depth {stretch_depth}\t check: {make_check((0, stretch_depth))}')

    long_lived_tree = make_tree(max_depth)

    mmd = max_depth + min_depth
    for d in range(min_depth, stretch_depth, 2):
        i = 2 ** (mmd - d)
        cs = 0
        for argchunk in get_argchunks(i, d):
            cs += sum(map(make_check, argchunk))
        print(f'{i}\t trees of depth {d}\t check: {cs}')

    print(f'long lived tree of depth {max_depth}\t check: {check_tree(long_lived_tree)}')

</t>
<t tx="ekr.20230509052845.100">class ZobristHash[Board]:
    board: Board
    hash_set: Set[int]
    hash: int

    @others
</t>
<t tx="ekr.20230509052845.1000">@property
def microsecond(self) -&gt; int:
    v = self._value
    return v &amp; 0xFFFFFF

</t>
<t tx="ekr.20230509052845.1001">def __repr__(self) -&gt; str:
    h, m, s, us = self.hour, self.minute, self.second, self.microsecond
    v = []
    v.append(f"hour={h}")
    v.append(f"minute={m}")
    if s or us:
        v.append(f"second={s}")
    if us:
        v.append(f"microsecond={us}")
    return f"time({', '.join(v)})"

</t>
<t tx="ekr.20230509052845.1002">def __str__(self) -&gt; str:
    return self.isoformat()

</t>
<t tx="ekr.20230509052845.1003">def __bool__(self) -&gt; bool:
    return True

</t>
<t tx="ekr.20230509052845.1004">def fromisoformat(time_string: str) -&gt; time:
    (
        hour,
        minute,
        second,
        microsecond,
        tzoffset,
        tzmicrosecond,
    ) = _parse_isoformat_time(time_string)
    # TODO: deal with timezone
    return time(hour, minute, second, microsecond)

</t>
<t tx="ekr.20230509052845.1005">def replace(
    self, hour: int = -1, minute: int = -1, second: int = -1, microsecond: int = -1
) -&gt; time:
    if hour == -1:
        hour = self.hour
    if second == -1:
        second = self.second
    if minute == -1:
        minute = self.minute
    if microsecond == -1:
        microsecond = self.microsecond
    return time(hour, minute, second, microsecond)

</t>
<t tx="ekr.20230509052845.1006">def isoformat(self, timespec: Static[str] = "auto") -&gt; str:
    hh = str(self.hour).zfill(2)
    mm = str(self.minute).zfill(2)
    ss = str(self.second).zfill(2)
    us = str(self.microsecond).zfill(6)
    ms = str(self.microsecond // 1000).zfill(3)

    if timespec == "auto":
        if self.microsecond:
            return f"{hh}:{mm}:{ss}.{us}"
        else:
            return f"{hh}:{mm}:{ss}"
    elif timespec == "hours":
        return hh
    elif timespec == "minutes":
        return f"{hh}:{mm}"
    elif timespec == "seconds":
        return f"{hh}:{mm}:{ss}"
    elif timespec == "milliseconds":
        return f"{hh}:{mm}:{ss}.{ms}"
    elif timespec == "microseconds":
        return f"{hh}:{mm}:{ss}.{us}"
    else:
        compile_error(
            "invalid timespec; valid ones are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds' and 'microseconds'"
        )

</t>
<t tx="ekr.20230509052845.1007">@tuple
class datetime:
    min: ClassVar[datetime] = datetime(MINYEAR, 1, 1)
    max: ClassVar[datetime] = datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _time: time
    _date: date

    @others
</t>
<t tx="ekr.20230509052845.1008">def __new__(
    year: int,
    month: int,
    day: int,
    hour: int = 0,
    minute: int = 0,
    second: int = 0,
    microsecond: int = 0,
) -&gt; datetime:
    return datetime(time(hour, minute, second, microsecond), date(year, month, day))

</t>
<t tx="ekr.20230509052845.1009">def date(self) -&gt; date:
    return self._date

</t>
<t tx="ekr.20230509052845.101">def __init__(self, board):
    self.board = board
    self.hash_set = set()
    self.hash = 0
    for square in self.board.squares:
        self.hash ^= square.zobrist_strings[EMPTY]
    self.hash_set.clear()
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509052845.1010">def time(self) -&gt; time:
    return self._time

</t>
<t tx="ekr.20230509052845.1011">@property
def year(self) -&gt; int:
    return self.date().year

</t>
<t tx="ekr.20230509052845.1012">@property
def month(self) -&gt; int:
    return self.date().month

</t>
<t tx="ekr.20230509052845.1013">@property
def day(self) -&gt; int:
    return self.date().day

</t>
<t tx="ekr.20230509052845.1014">@property
def hour(self) -&gt; int:
    return self.time().hour

</t>
<t tx="ekr.20230509052845.1015">@property
def minute(self) -&gt; int:
    return self.time().minute

</t>
<t tx="ekr.20230509052845.1016">@property
def second(self) -&gt; int:
    return self.time().second

</t>
<t tx="ekr.20230509052845.1017">@property
def microsecond(self) -&gt; int:
    return self.time().microsecond

</t>
<t tx="ekr.20230509052845.1018">def __repr__(self) -&gt; str:
    return f"datetime(year={self.year}, month={self.month}, day={self.day}, hour={self.hour}, minute={self.minute}, second={self.second}, microsecond={self.microsecond})"

</t>
<t tx="ekr.20230509052845.1019">def __str__(self) -&gt; str:
    return self.isoformat(sep=" ")

</t>
<t tx="ekr.20230509052845.102">def update(self, square, color):
    self.hash ^= square.zobrist_strings[square.color]
    self.hash ^= square.zobrist_strings[color]

</t>
<t tx="ekr.20230509052845.1020">def _from_timet_and_us(timet, us) -&gt; datetime:
    tm = localtime(timet)
    year = tm.tm_year
    month = tm.tm_mon
    day = tm.tm_mday
    hour = tm.tm_hour
    minute = tm.tm_min
    second = min(59, tm.tm_sec)
    # TODO: timezone adjustments
    return datetime(year, month, day, hour, minute, second, us)

</t>
<t tx="ekr.20230509052845.1021">def today() -&gt; datetime:
    from time import time as ttime

    return datetime.fromtimestamp(ttime())

</t>
<t tx="ekr.20230509052845.1022"># TODO: support timezone
def now() -&gt; datetime:
    return datetime.today()

</t>
<t tx="ekr.20230509052845.1023">def utcnow() -&gt; datetime:
    return datetime.now()

</t>
<t tx="ekr.20230509052845.1024"># TODO: support timezone
def fromtimestamp(timestamp) -&gt; datetime:
    from time import _time_to_timeval, _ROUND_HALF_EVEN

    timet, us = _time_to_timeval(float(timestamp), _ROUND_HALF_EVEN)
    return datetime._from_timet_and_us(timet, us)

</t>
<t tx="ekr.20230509052845.1025">def utcfromtimestamp(timestamp) -&gt; datetime:
    return datetime.fromtimestamp(timestamp)

</t>
<t tx="ekr.20230509052845.1026">def fromordinal(ordinal: int) -&gt; datetime:
    return datetime.combine(date.fromordinal(ordinal), time())

</t>
<t tx="ekr.20230509052845.1027"># TODO: support timezone
def combine(date: date, time: time) -&gt; datetime:
    return datetime(time, date)

</t>
<t tx="ekr.20230509052845.1028">def fromisoformat(date_string: str) -&gt; datetime:
    time_string = "" if len(date_string) &lt; 10 else date_string[:10]
    year, month, day = _parse_isoformat_date(time_string)
    if len(date_string) == 10:
        return datetime(year=year, month=month, day=day)
    date_string = "" if len(date_string) &lt; 12 else date_string[11:]
    hour, minute, second, microsecond = _parse_hh_mm_ss_ff(date_string)
    return datetime(
        year=year,
        month=month,
        day=day,
        hour=hour,
        minute=minute,
        second=second,
        microsecond=microsecond,
    )

</t>
<t tx="ekr.20230509052845.1029">def fromisocalendar(year: int, week: int, day: int) -&gt; datetime:
    return datetime.combine(date.fromisocalendar(year, week, day), time())

</t>
<t tx="ekr.20230509052845.103">def add(self):
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509052845.1030">def __add__(self, other: timedelta) -&gt; datetime:
    td_days, td_seconds, td_microseconds = _normalize_d_s_us(
        0, 0, other._microseconds
    )
    year = self.year
    month = self.month
    day = self.day + td_days
    hour = self.hour
    minute = self.minute
    second = self.second + td_seconds
    microsecond = self.microsecond + td_microseconds
    return datetime(
        *_normalize_datetime(year, month, day, hour, minute, second, microsecond)
    )

</t>
<t tx="ekr.20230509052845.1031">def __sub__(self, other: timedelta) -&gt; datetime:
    td_days, td_seconds, td_microseconds = _normalize_d_s_us(
        0, 0, other._microseconds
    )
    year = self.year
    month = self.month
    day = self.day - td_days
    hour = self.hour
    minute = self.minute
    second = self.second - td_seconds
    microsecond = self.microsecond - td_microseconds
    return datetime(
        *_normalize_datetime(year, month, day, hour, minute, second, microsecond)
    )

</t>
<t tx="ekr.20230509052845.1032">def __sub__(self, other: datetime) -&gt; timedelta:
    delta_d = _ymd_to_ord(self.year, self.month, self.day) - _ymd_to_ord(
        other.year, other.month, other.day
    )
    delta_s = (
        (self.hour - other.hour) * 3600
        + (self.minute - other.minute) * 60
        + (self.second - other.second)
    )
    delta_us = self.microsecond - other.microsecond
    return timedelta(days=delta_d, seconds=delta_s, microseconds=delta_us)

</t>
<t tx="ekr.20230509052845.1033">def __eq__(self, other: datetime) -&gt; bool:
    return self.date() == other.date() and self.time() == other.time()

</t>
<t tx="ekr.20230509052845.1034">def __ne__(self, other: datetime) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.1035">def __lt__(self, other: datetime) -&gt; bool:
    return (self.date(), self.time()) &lt; (other.date(), other.time())

</t>
<t tx="ekr.20230509052845.1036">def __le__(self, other: datetime) -&gt; bool:
    return (self.date(), self.time()) &lt;= (other.date(), other.time())

</t>
<t tx="ekr.20230509052845.1037">def __gt__(self, other: datetime) -&gt; bool:
    return (self.date(), self.time()) &gt; (other.date(), other.time())

</t>
<t tx="ekr.20230509052845.1038">def __ge__(self, other: datetime) -&gt; bool:
    return (self.date(), self.time()) &gt;= (other.date(), other.time())

</t>
<t tx="ekr.20230509052845.1039">def __bool__(self) -&gt; bool:
    return True

</t>
<t tx="ekr.20230509052845.104">def dupe(self):
    return self.hash in self.hash_set


</t>
<t tx="ekr.20230509052845.1040">def replace(
    self,
    year: int = -1,
    month: int = -1,
    day: int = -1,
    hour: int = -1,
    minute: int = -1,
    second: int = -1,
    microsecond: int = -1,
) -&gt; datetime:
    return datetime(
        self.time().replace(hour, minute, second, microsecond),
        self.date().replace(year, month, day),
    )

</t>
<t tx="ekr.20230509052845.1041">def timetuple(self) -&gt; struct_time:
    yday = self.toordinal() - date(self.year, 1, 1).toordinal() + 1
    return struct_time(
        self.year,
        self.month,
        self.day,
        self.hour,
        self.minute,
        self.second,
        self.weekday(),
        yday,
        -1,
    )

</t>
<t tx="ekr.20230509052845.1042">def utctimetuple(self) -&gt; struct_time:
    return self.timetuple()

</t>
<t tx="ekr.20230509052845.1043">def toordinal(self) -&gt; int:
    return self.date().toordinal()

</t>
<t tx="ekr.20230509052845.1044">def timestamp(self) -&gt; float:
    return (self - datetime(1970, 1, 1)).total_seconds()

</t>
<t tx="ekr.20230509052845.1045">def weekday(self) -&gt; int:
    return self.date().weekday()

</t>
<t tx="ekr.20230509052845.1046">def isoweekday(self) -&gt; int:
    return self.date().isoweekday()

</t>
<t tx="ekr.20230509052845.1047">def isocalendar(self) -&gt; IsoCalendarDate:
    return self.date().isocalendar()

</t>
<t tx="ekr.20230509052845.1048">def isoformat(self, sep: str = "T", timespec: Static[str] = "auto") -&gt; str:
    date_part = str(self.date())
    time_part = self.time().isoformat(timespec=timespec)
    return f"{date_part}{sep}{time_part}"

</t>
<t tx="ekr.20230509052845.1049">def ctime(self) -&gt; str:
    date = self.date()
    time = self.time()
    return _format_ctime(
        date.year, date.month, date.day, time.hour, time.minute, time.second
    )

</t>
<t tx="ekr.20230509052845.105">class Board:
    squares: List[Square[Board]]
    emptyset: EmptySet[Board]
    zobrist: ZobristHash[Board]
    color: int
    finished: bool
    lastmove: int
    history: List[int]
    white_dead: int
    black_dead: int

    @others
</t>
<t tx="ekr.20230509052845.1050">@extend
class timedelta:
    def __add__(self, other: date) -&gt; date:
        return other + self

    def __add__(self, other: datetime) -&gt; datetime:
        return other + self
</t>
<t tx="ekr.20230509052845.1051">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def partial():  # internal
    pass
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1052">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

"""
Parser for command line options.

This module helps scripts to parse the command line arguments in
sys.argv.  It supports the same conventions as the Unix getopt()
function (including the special meanings of arguments of the form `-'
and `--').  Long options similar to those supported by GNU software
may be used as well via an optional third argument.  This module
provides two functions and an exception:

getopt() -- Parse command line options
gnu_getopt() -- Like getopt(), but allow option and non-option arguments
to be intermixed.
GetoptError -- exception (class) raised with 'opt' attribute, which is the
option involved with the exception.

Adapted from https://raw.githubusercontent.com/python/cpython/2.7/Lib/getopt.py
"""

import os

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1053">class GetoptError(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("GetoptError", message)

</t>
<t tx="ekr.20230509052845.1054">def long_has_args(opt: str, longopts: List[str]) -&gt; Tuple[bool, str]:
    possibilities = [o for o in longopts if o.startswith(opt)]
    if not possibilities:
        raise GetoptError(f"option --{opt} not recognized")
    # Is there an exact match?
    if opt in possibilities:
        return False, opt
    elif opt + "=" in possibilities:
        return True, opt
    # No exact match, so better be unique.
    if len(possibilities) &gt; 1:
        # XXX since possibilities contains all valid continuations, might be
        # nice to work them into the error msg
        raise GetoptError(f"option --{opt} not a unique prefix")
    assert len(possibilities) == 1
    unique_match = possibilities[0]
    has_arg = unique_match.endswith("=")
    if has_arg:
        unique_match = unique_match[:-1]
    return has_arg, unique_match

</t>
<t tx="ekr.20230509052845.1055">def do_longs(
    opts: List[Tuple[str, str]], opt: str, longopts: List[str], args: List[str]
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    optarg = ""
    try:
        i = opt.index("=")
        opt, optarg = opt[:i], opt[i + 1 :]
    except ValueError:
        pass

    has_arg, opt = long_has_args(opt, longopts)
    if has_arg:
        if optarg == "":
            if not args:
                raise GetoptError(f"option --{opt} requires argument")
            optarg, args = args[0], args[1:]
    elif optarg != "":
        raise GetoptError(f"option --{opt} must not have an argument")
    opts.append((f"--{opt}", optarg))
    return opts, args

</t>
<t tx="ekr.20230509052845.1056">def short_has_arg(opt: str, shortopts: str) -&gt; bool:
    for i in range(len(shortopts)):
        if opt == shortopts[i] != ":":
            return shortopts.startswith(":", i + 1)
    raise GetoptError(f"option -{opt} not recognized")

</t>
<t tx="ekr.20230509052845.1057">def do_shorts(
    opts: List[Tuple[str, str]], optstring: str, shortopts: str, args: List[str]
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    while optstring != "":
        opt, optstring = optstring[0], optstring[1:]
        optarg = ""
        if short_has_arg(opt, shortopts):
            if optstring == "":
                if not args:
                    raise GetoptError(f"option -{opt} requires argument")
                optstring, args = args[0], args[1:]
            optarg, optstring = optstring, ""
        opts.append((f"-{opt}", optarg))
    return opts, args

</t>
<t tx="ekr.20230509052845.1058">def getopt(
    args: List[str], shortopts: str, longopts: List[str] = []
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    """
    Parses command line options and parameter list.  args is the
    argument list to be parsed, without the leading reference to the
    running program.  Typically, this means "sys.argv[1:]".  shortopts
    is the string of option letters that the script wants to
    recognize, with options that require an argument followed by a
    colon (i.e., the same format that Unix getopt() uses).  If
    specified, longopts is a list of strings with the names of the
    long options which should be supported.  The leading '--'
    characters should not be included in the option name.  Options
    which require an argument should be followed by an equal sign
    ('=').

    The return value consists of two elements: the first is a list of
    (option, value) pairs; the second is the list of program arguments
    left after the option list was stripped (this is a trailing slice
    of the first argument).  Each option-and-value pair returned has
    the option as its first element, prefixed with a hyphen (e.g.,
    '-x'), and the option argument as its second element, or an empty
    string if the option has no argument.  The options occur in the
    list in the same order in which they were found, thus allowing
    multiple occurrences.  Long and short options may be mixed.

    NOTES:
    This function works like the above-mentioned getopt(), except that GNU style scanning
    mode is used by default. This means that option and non-option
    arguments may be intermixed. The getopt() function stops
    processing options as soon as a non-option argument is
    encountered.
    If the first character of the option string is `+', or if the
    environment variable POSIXLY_CORRECT is set, then option
    processing stops as soon as a non-option argument is encountered.
    """

    opts = []
    prog_args = []

    # Allow options after non-option arguments?
    all_options_first = False
    if shortopts.startswith("+"):
        shortopts = shortopts[1:]
        all_options_first = True
    elif "POSIXLY_CORRECT" in os.environ:
        all_options_first = True

    while args:
        if args[0] == "--":
            prog_args += args[1:]
            break

        if args[0][:2] == "--":
            opts, args = do_longs(opts, args[0][2:], longopts, args[1:])
        elif args[0][:1] == "-" and args[0] != "-":
            opts, args = do_shorts(opts, args[0][1:], shortopts, args[1:])
        else:
            if all_options_first:
                prog_args += args
                break
            else:
                prog_args.append(args[0])
                args = args[1:]

    return opts, prog_args
</t>
<t tx="ekr.20230509052845.1059">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import sizeof as _sizeof

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.106">def __init__(self):
    self.squares = [Square(self, pos) for pos in range(SIZE * SIZE)]
    for square in self.squares:
        square.set_neighbours()
    self.reset()

</t>
<t tx="ekr.20230509052845.1060">@tuple
class Device:
    _device: i32

    @others
</t>
<t tx="ekr.20230509052845.1061">def __new__(device: int):
    from C import seq_nvptx_device(int) -&gt; i32
    return Device(seq_nvptx_device(device))

</t>
<t tx="ekr.20230509052845.1062">@staticmethod
def count():
    from C import seq_nvptx_device_count() -&gt; int
    return seq_nvptx_device_count()

</t>
<t tx="ekr.20230509052845.1063">def __str__(self):
    from C import seq_nvptx_device_name(i32) -&gt; str
    return seq_nvptx_device_name(self._device)

</t>
<t tx="ekr.20230509052845.1064">def __index__(self):
    return int(self._device)

</t>
<t tx="ekr.20230509052845.1065">def __bool__(self):
    return True

</t>
<t tx="ekr.20230509052845.1066">@property
def compute_capability(self):
    from C import seq_nvptx_device_capability(i32) -&gt; int
    c = seq_nvptx_device_capability(self._device)
    return (c &gt;&gt; 32, c &amp; 0xffffffff)

</t>
<t tx="ekr.20230509052845.1067">@tuple
class Memory[T]:
    _ptr: Ptr[byte]

    @others
</t>
<t tx="ekr.20230509052845.1068">def _alloc(n: int, T: type):
    from C import seq_nvptx_device_alloc(int) -&gt; Ptr[byte]
    return Memory[T](seq_nvptx_device_alloc(n * _sizeof(T)))

</t>
<t tx="ekr.20230509052845.1069">def _read(self, p: Ptr[T], n: int):
    from C import seq_nvptx_memcpy_d2h(Ptr[byte], Ptr[byte], int)
    seq_nvptx_memcpy_d2h(p.as_byte(), self._ptr, n * _sizeof(T))

</t>
<t tx="ekr.20230509052845.107">def reset(self):
    for square in self.squares:
        square.color = EMPTY
        square.used = False
    self.emptyset = EmptySet(self)
    self.zobrist = ZobristHash(self)
    self.color = BLACK
    self.finished = False
    self.lastmove = -2
    self.history = []
    self.white_dead = 0
    self.black_dead = 0

</t>
<t tx="ekr.20230509052845.1070">def _write(self, p: Ptr[T], n: int):
    from C import seq_nvptx_memcpy_h2d(Ptr[byte], Ptr[byte], int)
    seq_nvptx_memcpy_h2d(self._ptr, p.as_byte(), n * _sizeof(T))

</t>
<t tx="ekr.20230509052845.1071">def _free(self):
    from C import seq_nvptx_device_free(Ptr[byte])
    seq_nvptx_device_free(self._ptr)

</t>
<t tx="ekr.20230509052845.1072">@llvm
def syncthreads() -&gt; None:
    declare void @llvm.nvvm.barrier0()
    call void @llvm.nvvm.barrier0()
    ret {} {}

</t>
<t tx="ekr.20230509052845.1073">@tuple
class Dim3:
    _x: u32
    _y: u32
    _z: u32

    @others
</t>
<t tx="ekr.20230509052845.1074">def __new__(x: int, y: int, z: int):
    return Dim3(u32(x), u32(y), u32(z))

</t>
<t tx="ekr.20230509052845.1075">@property
def x(self):
    return int(self._x)

</t>
<t tx="ekr.20230509052845.1076">@property
def y(self):
    return int(self._y)

</t>
<t tx="ekr.20230509052845.1077">@property
def z(self):
    return int(self._z)

</t>
<t tx="ekr.20230509052845.1078">@tuple
class Thread:
    @others
</t>
<t tx="ekr.20230509052845.1079">@property
def x(self):
    @pure
    @llvm
    def get_x() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
        ret i32 %res

    return int(get_x())

</t>
<t tx="ekr.20230509052845.108">def move(self, pos):
    square = self.squares[pos]
    if pos != PASS:
        square.move(self.color)
        self.emptyset.remove(square.pos)
    elif self.lastmove == PASS:
        self.finished = True
    if self.color == BLACK:
        self.color = WHITE
    else:
        self.color = BLACK
    self.lastmove = pos
    self.history.append(pos)

</t>
<t tx="ekr.20230509052845.1080">@property
def y(self):
    @pure
    @llvm
    def get_y() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.tid.y()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.y()
        ret i32 %res

    return int(get_y())

</t>
<t tx="ekr.20230509052845.1081">@property
def z(self):
    @pure
    @llvm
    def get_z() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.tid.z()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.z()
        ret i32 %res

    return int(get_z())

</t>
<t tx="ekr.20230509052845.1082">@tuple
class Block:
    @others
</t>
<t tx="ekr.20230509052845.1083">@property
def x(self):
    @pure
    @llvm
    def get_x() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
        ret i32 %res

    return int(get_x())

</t>
<t tx="ekr.20230509052845.1084">@property
def y(self):
    @pure
    @llvm
    def get_y() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
        ret i32 %res

    return int(get_y())

</t>
<t tx="ekr.20230509052845.1085">@property
def z(self):
    @pure
    @llvm
    def get_z() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
        ret i32 %res

    return int(get_z())

</t>
<t tx="ekr.20230509052845.1086">@property
def dim(self):
    @pure
    @llvm
    def get_x() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
        ret i32 %res

    @pure
    @llvm
    def get_y() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
        ret i32 %res

    @pure
    @llvm
    def get_z() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
        ret i32 %res

    return Dim3(get_x(), get_y(), get_z())

</t>
<t tx="ekr.20230509052845.1087">@tuple
class Grid:
    @others
</t>
<t tx="ekr.20230509052845.1088">@property
def dim(self):
    @pure
    @llvm
    def get_x() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
        ret i32 %res

    @pure
    @llvm
    def get_y() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
        ret i32 %res

    @pure
    @llvm
    def get_z() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
        ret i32 %res

    return Dim3(get_x(), get_y(), get_z())

</t>
<t tx="ekr.20230509052845.1089">@tuple
class Warp:
    @others
</t>
<t tx="ekr.20230509052845.109">def random_move(self):
    return self.emptyset.random_choice()

</t>
<t tx="ekr.20230509052845.1090">def __len__(self):
    @pure
    @llvm
    def get_warpsize() -&gt; u32:
        declare i32 @llvm.nvvm.read.ptx.sreg.warpsize()
        %res = call i32 @llvm.nvvm.read.ptx.sreg.warpsize()
        ret i32 %res

    return int(get_warpsize())

</t>
<t tx="ekr.20230509052845.1091">thread = Thread()
block = Block()
grid = Grid()
warp = Warp()

</t>
<t tx="ekr.20230509052845.1092">def _catch():
    return (thread, block, grid, warp)

</t>
<t tx="ekr.20230509052845.1093">_catch()

</t>
<t tx="ekr.20230509052845.1094">@tuple
class AllocCache:
    v: List[Ptr[byte]]

    @others
</t>
<t tx="ekr.20230509052845.1095">def add(self, p: Ptr[byte]):
    self.v.append(p)

</t>
<t tx="ekr.20230509052845.1096">def free(self):
    for p in self.v:
        Memory[byte](p)._free()

</t>
<t tx="ekr.20230509052845.1097">def _tuple_from_gpu(args, gpu_args):
    if staticlen(args) &gt; 0:
        a = args[0]
        g = gpu_args[0]
        a.__from_gpu__(g)
        _tuple_from_gpu(args[1:], gpu_args[1:])

</t>
<t tx="ekr.20230509052845.1098">def kernel(fn):
    from C import seq_nvptx_function(str) -&gt; cobj
    from C import seq_nvptx_invoke(cobj, u32, u32, u32, u32, u32, u32, u32, cobj)

    @others
    return wrapper

</t>
<t tx="ekr.20230509052845.1099">def canonical_dim(dim):
    if isinstance(dim, NoneType):
        return (1, 1, 1)
    elif isinstance(dim, int):
        return (dim, 1, 1)
    elif isinstance(dim, Tuple[int,int]):
        return (dim[0], dim[1], 1)
    elif isinstance(dim, Tuple[int,int,int]):
        return dim
    elif isinstance(dim, Dim3):
        return (dim.x, dim.y, dim.z)
    else:
        compile_error("bad dimension argument")

</t>
<t tx="ekr.20230509052845.11">@path C:/Repos/codon/bench/binary_trees/
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# contributed by Antoine Pitrou
# modified by Dominique Wahli and Daniel Nanz
# modified by Joerg Baumann
# modified by @arshajii for Codon

import sys
import time

@others
t0 = time.time()
main(int(sys.argv[1]))
t1 = time.time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.110">def useful_fast(self, square):
    if not square.used:
        for neighbour in square.neighbours:
            if neighbour.color == EMPTY:
                return True
    return False

</t>
<t tx="ekr.20230509052845.1100">def offsets(t):
    @pure
    @llvm
    def offsetof(t: T, i: Static[int], T: type, S: type) -&gt; int:
        %p = getelementptr {=T}, ptr null, i64 0, i32 {=i}
        %s = ptrtoint ptr %p to i64
        ret i64 %s

    if staticlen(t) == 0:
        return ()
    else:
        T = type(t)
        S = type(t[-1])
        return (*offsets(t[:-1]), offsetof(t, staticlen(t) - 1, T, S))

</t>
<t tx="ekr.20230509052845.1101">def wrapper(*args, grid, block):
    grid = canonical_dim(grid)
    block = canonical_dim(block)
    cache = AllocCache([])
    shared_mem = 0
    gpu_args = tuple(arg.__to_gpu__(cache) for arg in args)
    kernel_ptr = seq_nvptx_function(__realized__(fn, gpu_args).__llvm_name__)
    p = __ptr__(gpu_args).as_byte()
    arg_ptrs = tuple((p + offset) for offset in offsets(gpu_args))
    seq_nvptx_invoke(kernel_ptr, u32(grid[0]), u32(grid[1]), u32(grid[2]), u32(block[0]),
                     u32(block[1]), u32(block[2]), u32(shared_mem), __ptr__(arg_ptrs).as_byte())
    _tuple_from_gpu(args, gpu_args)
    cache.free()

</t>
<t tx="ekr.20230509052845.1102">def _ptr_to_gpu(p: Ptr[T], n: int, cache: AllocCache, index_filter = lambda i: True, T: type):
    from internal.gc import atomic

    if not atomic(T):
        tmp = Ptr[T](n)
        for i in range(n):
            if index_filter(i):
                tmp[i] = p[i].__to_gpu__(cache)
        p = tmp

    mem = Memory._alloc(n, T)
    cache.add(mem._ptr)
    mem._write(p, n)
    return Ptr[T](mem._ptr)

</t>
<t tx="ekr.20230509052845.1103">def _ptr_from_gpu(p: Ptr[T], q: Ptr[T], n: int, index_filter = lambda i: True, T: type):
    from internal.gc import atomic

    mem = Memory[T](q.as_byte())
    if not atomic(T):
        tmp = Ptr[T](n)
        mem._read(tmp, n)
        for i in range(n):
            if index_filter(i):
                p[i] = T.__from_gpu_new__(tmp[i])
    else:
        mem._read(p, n)

</t>
<t tx="ekr.20230509052845.1104">@pure
@llvm
def _ptr_to_type(p: cobj, T: type) -&gt; T:
    ret ptr %p

</t>
<t tx="ekr.20230509052845.1105">def _object_to_gpu(obj: T, cache: AllocCache, T: type):
    s = tuple(obj)
    gpu_mem = Memory._alloc(1, type(s))
    cache.add(gpu_mem._ptr)
    gpu_mem._write(__ptr__(s), 1)
    return _ptr_to_type(gpu_mem._ptr, T)

</t>
<t tx="ekr.20230509052845.1106">def _object_from_gpu(obj):
    T = type(obj)
    S = type(tuple(obj))

    tmp = T.__new__()
    p = Ptr[S](tmp.__raw__())
    q = Ptr[S](obj.__raw__())

    mem = Memory[S](q.as_byte())
    mem._read(p, 1)
    return tmp

</t>
<t tx="ekr.20230509052845.1107">@tuple
class Pointer[T]:
    _ptr: Ptr[T]
    _len: int

    @others
</t>
<t tx="ekr.20230509052845.1108">def __to_gpu__(self, cache: AllocCache):
    return _ptr_to_gpu(self._ptr, self._len, cache)

</t>
<t tx="ekr.20230509052845.1109">def __from_gpu__(self, other: Ptr[T]):
    _ptr_from_gpu(self._ptr, other, self._len)

</t>
<t tx="ekr.20230509052845.111">def useful(self, pos):
    global TIMESTAMP
    TIMESTAMP += 1
    square = self.squares[pos]
    if self.useful_fast(square):
        return True
    old_hash = self.zobrist.hash
    self.zobrist.update(square, self.color)
    empties = opps = weak_opps = neighs = weak_neighs = 0
    for neighbour in square.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            empties += 1
            continue
        neighbour_ref = neighbour.find()
        if neighbour_ref.timestamp != TIMESTAMP:
            if neighcolor == self.color:
                neighs += 1
            else:
                opps += 1
            neighbour_ref.timestamp = TIMESTAMP
            neighbour_ref.temp_ledges = neighbour_ref.ledges
        neighbour_ref.temp_ledges -= 1
        if neighbour_ref.temp_ledges == 0:
            if neighcolor == self.color:
                weak_neighs += 1
            else:
                weak_opps += 1
                neighbour_ref.remove(neighbour_ref, update=False)
    dupe = self.zobrist.dupe()
    self.zobrist.hash = old_hash
    strong_neighs = neighs - weak_neighs
    strong_opps = opps - weak_opps
    return not dupe and \
        (empties or weak_opps or (strong_neighs and (strong_opps or weak_neighs)))

</t>
<t tx="ekr.20230509052845.1110">def __from_gpu_new__(other: Ptr[T]):
    return other

</t>
<t tx="ekr.20230509052845.1111">def raw(v: List[T], T: type):
    return Pointer(v.arr.ptr, len(v))

</t>
<t tx="ekr.20230509052845.1112">@extend
class Ptr:
    @others
</t>
<t tx="ekr.20230509052845.1113">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1114">def __from_gpu__(self, other: Ptr[T]):
    pass

</t>
<t tx="ekr.20230509052845.1115">def __from_gpu_new__(other: Ptr[T]):
    return other

</t>
<t tx="ekr.20230509052845.1116">@extend
class NoneType:
    @others
</t>
<t tx="ekr.20230509052845.1117">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1118">def __from_gpu__(self, other: NoneType):
    pass

</t>
<t tx="ekr.20230509052845.1119">def __from_gpu_new__(other: NoneType):
    return other

</t>
<t tx="ekr.20230509052845.112">def useful_moves(self):
    return [pos for pos in self.emptyset.empties if self.useful(pos)]

</t>
<t tx="ekr.20230509052845.1120">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.1121">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1122">def __from_gpu__(self, other: int):
    pass

</t>
<t tx="ekr.20230509052845.1123">def __from_gpu_new__(other: int):
    return other

</t>
<t tx="ekr.20230509052845.1124">@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.1125">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1126">def __from_gpu__(self, other: float):
    pass

</t>
<t tx="ekr.20230509052845.1127">def __from_gpu_new__(other: float):
    return other

</t>
<t tx="ekr.20230509052845.1128">@extend
class float32:
    @others
</t>
<t tx="ekr.20230509052845.1129">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.113">def replay(self, history):
    for pos in history:
        self.move(pos)

</t>
<t tx="ekr.20230509052845.1130">def __from_gpu__(self, other: float32):
    pass

</t>
<t tx="ekr.20230509052845.1131">def __from_gpu_new__(other: float32):
    return other

</t>
<t tx="ekr.20230509052845.1132">@extend
class bool:
    @others
</t>
<t tx="ekr.20230509052845.1133">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1134">def __from_gpu__(self, other: bool):
    pass

</t>
<t tx="ekr.20230509052845.1135">def __from_gpu_new__(other: bool):
    return other

</t>
<t tx="ekr.20230509052845.1136">@extend
class byte:
    @others
</t>
<t tx="ekr.20230509052845.1137">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1138">def __from_gpu__(self, other: byte):
    pass

</t>
<t tx="ekr.20230509052845.1139">def __from_gpu_new__(other: byte):
    return other

</t>
<t tx="ekr.20230509052845.114">def score(self, color):
    if color == WHITE:
        count = KOMI + self.black_dead
    else:
        count = float(self.white_dead)
    for square in self.squares:
        squarecolor = square.color
        if squarecolor == color:
            count += 1
        elif squarecolor == EMPTY:
            surround = 0
            for neighbour in square.neighbours:
                if neighbour.color == color:
                    surround += 1
            if surround == len(square.neighbours):
                count += 1
    return count

</t>
<t tx="ekr.20230509052845.1140">@extend
class Int:
    @others
</t>
<t tx="ekr.20230509052845.1141">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1142">def __from_gpu__(self, other: Int[N]):
    pass

</t>
<t tx="ekr.20230509052845.1143">def __from_gpu_new__(other: Int[N]):
    return other

</t>
<t tx="ekr.20230509052845.1144">@extend
class UInt:
    @others
</t>
<t tx="ekr.20230509052845.1145">def __to_gpu__(self, cache: AllocCache):
    return self

</t>
<t tx="ekr.20230509052845.1146">def __from_gpu__(self, other: UInt[N]):
    pass

</t>
<t tx="ekr.20230509052845.1147">def __from_gpu_new__(other: UInt[N]):
    return other

</t>
<t tx="ekr.20230509052845.1148">@extend
class str:
    @others
</t>
<t tx="ekr.20230509052845.1149">def __to_gpu__(self, cache: AllocCache):
    n = self.len
    return str(_ptr_to_gpu(self.ptr, n, cache), n)

</t>
<t tx="ekr.20230509052845.115">def check(self):
    for square in self.squares:
        if square.color == EMPTY:
            continue

        members1 = set([square])
        changed = True
        while changed:
            changed = False
            for member in members1.copy():
                for neighbour in member.neighbours:
                    if neighbour.color == square.color and neighbour not in members1:
                        changed = True
                        members1.add(neighbour)
        ledges1 = 0
        for member in members1:
            for neighbour in member.neighbours:
                if neighbour.color == EMPTY:
                    ledges1 += 1

        root = square.find()

        # print 'members1', square, root, members1
        # print 'ledges1', square, ledges1

        members2 = set()
        for square2 in self.squares:
            if square2.color != EMPTY and square2.find() == root:
                members2.add(square2)

        ledges2 = root.ledges
        # print 'members2', square, root, members1
        # print 'ledges2', square, ledges2

        assert members1 == members2
        assert ledges1 == ledges2

        set(self.emptyset.empties)

        empties2 = set()
        for square in self.squares:
            if square.color == EMPTY:
                empties2.add(square.pos)

</t>
<t tx="ekr.20230509052845.1150">def __from_gpu__(self, other: str):
    pass

</t>
<t tx="ekr.20230509052845.1151">def __from_gpu_new__(other: str):
    n = other.len
    p = Ptr[byte](n)
    _ptr_from_gpu(p, other.ptr, n)
    return str(p, n)

</t>
<t tx="ekr.20230509052845.1152">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.1153">@inline
def __to_gpu__(self, cache: AllocCache):
    mem = List[T].__new__()
    n = self.len
    gpu_ptr = _ptr_to_gpu(self.arr.ptr, n, cache)
    mem.arr = Array[T](gpu_ptr, n)
    mem.len = n
    return _object_to_gpu(mem, cache)

</t>
<t tx="ekr.20230509052845.1154">@inline
def __from_gpu__(self, other: List[T]):
    mem = _object_from_gpu(other)
    my_cap = self.arr.len
    other_cap = mem.arr.len

    if other_cap &gt; my_cap:
        self._resize(other_cap)

    _ptr_from_gpu(self.arr.ptr, mem.arr.ptr, mem.len)
    self.len = mem.len

</t>
<t tx="ekr.20230509052845.1155">@inline
def __from_gpu_new__(other: List[T]):
    mem = _object_from_gpu(other)
    arr = Array[T](mem.arr.len)
    _ptr_from_gpu(arr.ptr, mem.arr.ptr, arr.len)
    mem.arr = arr
    return mem

</t>
<t tx="ekr.20230509052845.1156">@extend
class DynamicTuple:
    @others
</t>
<t tx="ekr.20230509052845.1157">@inline
def __to_gpu__(self, cache: AllocCache):
    n = self._len
    gpu_ptr = _ptr_to_gpu(self._ptr, n, cache)
    return DynamicTuple(gpu_ptr, n)

</t>
<t tx="ekr.20230509052845.1158">@inline
def __from_gpu__(self, other: DynamicTuple[T]):
    _ptr_from_gpu(self._ptr, other._ptr, self._len)

</t>
<t tx="ekr.20230509052845.1159">@inline
def __from_gpu_new__(other: DynamicTuple[T]):
    n = other._len
    p = Ptr[T](n)
    _ptr_from_gpu(p, other._ptr, n)
    return DynamicTuple(p, n)

</t>
<t tx="ekr.20230509052845.116">def __repr__(self):
    result = []
    for y in range(SIZE):
        start = to_pos(0, y)
        result.append(''.join(
            [SHOW[square.color] + ' ' for square in self.squares[start:start + SIZE]]))
    return '\n'.join(result)


</t>
<t tx="ekr.20230509052845.1160">@extend
class Dict:
    @others
</t>
<t tx="ekr.20230509052845.1161">def __to_gpu__(self, cache: AllocCache):
    from internal.khash import __ac_fsize
    mem = Dict[K,V].__new__()
    n = self._n_buckets
    f = __ac_fsize(n) if n else 0

    mem._n_buckets = n
    mem._size = self._size
    mem._n_occupied = self._n_occupied
    mem._upper_bound = self._upper_bound
    mem._flags = _ptr_to_gpu(self._flags, f, cache)
    mem._keys = _ptr_to_gpu(self._keys, n, cache, lambda i: self._kh_exist(i))
    mem._vals = _ptr_to_gpu(self._vals, n, cache, lambda i: self._kh_exist(i))

    return _object_to_gpu(mem, cache)

</t>
<t tx="ekr.20230509052845.1162">def __from_gpu__(self, other: Dict[K,V]):
    from internal.khash import __ac_fsize
    mem = _object_from_gpu(other)
    my_n = self._n_buckets
    n = mem._n_buckets
    f = __ac_fsize(n) if n else 0

    if my_n != n:
        self._flags = Ptr[u32](f)
        self._keys = Ptr[K](n)
        self._vals = Ptr[V](n)

    _ptr_from_gpu(self._flags, mem._flags, f)
    _ptr_from_gpu(self._keys, mem._keys, n, lambda i: self._kh_exist(i))
    _ptr_from_gpu(self._vals, mem._vals, n, lambda i: self._kh_exist(i))

    self._n_buckets = n
    self._size = mem._size
    self._n_occupied = mem._n_occupied
    self._upper_bound = mem._upper_bound

</t>
<t tx="ekr.20230509052845.1163">def __from_gpu_new__(other: Dict[K,V]):
    from internal.khash import __ac_fsize
    mem = _object_from_gpu(other)

    n = mem._n_buckets
    f = __ac_fsize(n) if n else 0
    flags = Ptr[u32](f)
    keys = Ptr[K](n)
    vals = Ptr[V](n)

    _ptr_from_gpu(flags, mem._flags, f)
    mem._flags = flags
    _ptr_from_gpu(keys, mem._keys, n, lambda i: mem._kh_exist(i))
    mem._keys = keys
    _ptr_from_gpu(vals, mem._vals, n, lambda i: mem._kh_exist(i))
    mem._vals = vals
    return mem

</t>
<t tx="ekr.20230509052845.1164">@extend
class Set:
    @others
</t>
<t tx="ekr.20230509052845.1165">def __to_gpu__(self, cache: AllocCache):
    from internal.khash import __ac_fsize
    mem = Set[K].__new__()
    n = self._n_buckets
    f = __ac_fsize(n) if n else 0

    mem._n_buckets = n
    mem._size = self._size
    mem._n_occupied = self._n_occupied
    mem._upper_bound = self._upper_bound
    mem._flags = _ptr_to_gpu(self._flags, f, cache)
    mem._keys = _ptr_to_gpu(self._keys, n, cache, lambda i: self._kh_exist(i))

    return _object_to_gpu(mem, cache)

</t>
<t tx="ekr.20230509052845.1166">def __from_gpu__(self, other: Set[K]):
    from internal.khash import __ac_fsize
    mem = _object_from_gpu(other)

    my_n = self._n_buckets
    n = mem._n_buckets
    f = __ac_fsize(n) if n else 0

    if my_n != n:
        self._flags = Ptr[u32](f)
        self._keys = Ptr[K](n)

    _ptr_from_gpu(self._flags, mem._flags, f)
    _ptr_from_gpu(self._keys, mem._keys, n, lambda i: self._kh_exist(i))

    self._n_buckets = n
    self._size = mem._size
    self._n_occupied = mem._n_occupied
    self._upper_bound = mem._upper_bound

</t>
<t tx="ekr.20230509052845.1167">def __from_gpu_new__(other: Set[K]):
    from internal.khash import __ac_fsize
    mem = _object_from_gpu(other)

    n = mem._n_buckets
    f = __ac_fsize(n) if n else 0
    flags = Ptr[u32](f)
    keys = Ptr[K](n)

    _ptr_from_gpu(flags, mem._flags, f)
    mem._flags = flags
    _ptr_from_gpu(keys, mem._keys, n, lambda i: mem._kh_exist(i))
    mem._keys = keys
    return mem

</t>
<t tx="ekr.20230509052845.1168">@extend
class Optional:
    @others
</t>
<t tx="ekr.20230509052845.1169">def __to_gpu__(self, cache: AllocCache):
    if self is None:
        return self
    else:
        return Optional[T](self.__val__().__to_gpu__(cache))

</t>
<t tx="ekr.20230509052845.117">class UCTNode:
    bestchild: Optional[UCTNode]
    pos: int
    wins: int
    losses: int
    pos_child: List[Optional[UCTNode]]
    parent: Optional[UCTNode]
    unexplored: List[int]

    @others
</t>
<t tx="ekr.20230509052845.1170">def __from_gpu__(self, other: Optional[T]):
    if self is not None and other is not None:
        self.__val__().__from_gpu__(other.__val__())

</t>
<t tx="ekr.20230509052845.1171">def __from_gpu_new__(other: Optional[T]):
    if other is None:
        return Optional[T]()
    else:
        return Optional[T](T.__from_gpu_new__(other.__val__()))

</t>
<t tx="ekr.20230509052845.1172">@extend
class __internal__:
    @others
</t>
<t tx="ekr.20230509052845.1173">def class_to_gpu(obj, cache: AllocCache):
    if isinstance(obj, Tuple):
        return tuple(a.__to_gpu__(cache) for a in obj)
    elif isinstance(obj, ByVal):
        T = type(obj)
        return T(*tuple(a.__to_gpu__(cache) for a in tuple(obj)))
    else:
        T = type(obj)
        S = type(tuple(obj))
        mem = T.__new__()
        Ptr[S](mem.__raw__())[0] = tuple(obj).__to_gpu__(cache)
        return _object_to_gpu(mem, cache)

</t>
<t tx="ekr.20230509052845.1174">def class_from_gpu(obj, other):
    if isinstance(obj, Tuple):
        _tuple_from_gpu(obj, other)
    elif isinstance(obj, ByVal):
        _tuple_from_gpu(tuple(obj), tuple(other))
    else:
        S = type(tuple(obj))
        Ptr[S](obj.__raw__())[0] = S.__from_gpu_new__(tuple(_object_from_gpu(other)))

</t>
<t tx="ekr.20230509052845.1175">def class_from_gpu_new(other):
    if isinstance(other, Tuple):
        return tuple(type(a).__from_gpu_new__(a) for a in other)
    elif isinstance(other, ByVal):
        T = type(other)
        return T(*tuple(type(a).__from_gpu_new__(a) for a in tuple(other)))
    else:
        S = type(tuple(other))
        mem = _object_from_gpu(other)
        Ptr[S](mem.__raw__())[0] = S.__from_gpu_new__(tuple(mem))
        return mem

</t>
<t tx="ekr.20230509052845.1176"># @par(gpu=True) support

</t>
<t tx="ekr.20230509052845.1177">@pure
@llvm
def _gpu_thread_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
    ret i32 %res

</t>
<t tx="ekr.20230509052845.1178">@pure
@llvm
def _gpu_block_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
    ret i32 %res

</t>
<t tx="ekr.20230509052845.1179">@pure
@llvm
def _gpu_block_dim_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
    ret i32 %res

</t>
<t tx="ekr.20230509052845.118">def __init__(self):
    self.bestchild = None
    self.pos = -1
    self.wins = 0
    self.losses = 0
    self.pos_child = [None for x in range(SIZE * SIZE)]
    self.parent = None
    self.unexplored = []

</t>
<t tx="ekr.20230509052845.1180">def _gpu_loop_outline_template(start, stop, args, instance: Static[int]):
    @others
    step = _loop_step()
    loop = range(start, stop, step)

    MAX_BLOCK = 1024
    MAX_GRID = 2147483647
    G = MAX_BLOCK * MAX_GRID
    n = len(loop)

    if n == 0:
        return
    elif n &gt; G:
        raise ValueError(f'loop exceeds GPU iteration limit of {G}')

    block = n
    grid = 1
    if n &gt; MAX_BLOCK:
        block = MAX_BLOCK
        grid = (n // MAX_BLOCK) + (0 if n % MAX_BLOCK == 0 else 1)

    _kernel_stub(start, n, args, grid=grid, block=block)
</t>
<t tx="ekr.20230509052845.1181">@nonpure
def _loop_step():
    return 1

</t>
<t tx="ekr.20230509052845.1182">@kernel
def _kernel_stub(start: int, count: int, args):
    @nonpure
    def _gpu_loop_body_stub(idx, args):
        pass

    @nonpure
    def _dummy_use(n):
        pass

    _dummy_use(instance)
    idx = (int(_gpu_block_dim_x()) * int(_gpu_block_x())) + int(_gpu_thread_x())
    step = _loop_step()
    if idx &lt; count:
        _gpu_loop_body_stub(start + (idx * step), args)

</t>
<t tx="ekr.20230509052845.1183">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.file import gzFile

def open(path: str, mode: str = "r") -&gt; gzFile:
    return gzFile(path, mode)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1184">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1185"># 'heap' is a heap at all indices &gt;= startpos, except possibly for pos.  pos
# is the index of a leaf with a possibly out-of-order value.  Restore the
# heap invariant.
def _siftdown(heap: List[T], startpos: int, pos: int, T: type):
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos &gt; startpos:
        parentpos = (pos - 1) &gt;&gt; 1
        parent = heap[parentpos]
        if newitem &lt; parent:
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem

</t>
<t tx="ekr.20230509052845.1186">def _siftup(heap: List[T], pos: int, T: type):
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]
    # Bubble up the smaller child until hitting a leaf.
    childpos = 2 * pos + 1  # leftmost child position
    while childpos &lt; endpos:
        # Set childpos to index of smaller child.
        rightpos = childpos + 1
        if rightpos &lt; endpos and not heap[childpos] &lt; heap[rightpos]:
            childpos = rightpos
        # Move the smaller child up.
        heap[pos] = heap[childpos]
        pos = childpos
        childpos = 2 * pos + 1
    # The leaf at pos is empty now.  Put newitem there, and bubble it up
    # to its final resting place (by sifting its parents down).
    heap[pos] = newitem
    _siftdown(heap, startpos, pos)

</t>
<t tx="ekr.20230509052845.1187">def _siftdown_max(heap: List[T], startpos: int, pos: int, T: type):
    "Maxheap variant of _siftdown"
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos &gt; startpos:
        parentpos = (pos - 1) &gt;&gt; 1
        parent = heap[parentpos]
        if parent &lt; newitem:
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem

</t>
<t tx="ekr.20230509052845.1188">def _siftup_max(heap: List[T], pos: int, T: type):
    "Maxheap variant of _siftup"
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]
    # Bubble up the larger child until hitting a leaf.
    childpos = 2 * pos + 1  # leftmost child position
    while childpos &lt; endpos:
        # Set childpos to index of larger child.
        rightpos = childpos + 1
        if rightpos &lt; endpos and not heap[rightpos] &lt; heap[childpos]:
            childpos = rightpos
        # Move the larger child up.
        heap[pos] = heap[childpos]
        pos = childpos
        childpos = 2 * pos + 1
    # The leaf at pos is empty now.  Put newitem there, and bubble it up
    # to its final resting place (by sifting its parents down).
    heap[pos] = newitem
    _siftdown_max(heap, startpos, pos)

</t>
<t tx="ekr.20230509052845.1189">def heappush(heap: List[T], item: T, T: type):
    """Push item onto heap, maintaining the heap invariant."""
    heap.append(item)
    _siftdown(heap, 0, len(heap) - 1)

</t>
<t tx="ekr.20230509052845.119">def play(self, board):
    """ uct tree search """
    color = board.color
    node = self
    path = [node]
    while True:
        pos = node.select(board)
        if pos == PASS:
            break
        board.move(pos)
        child = node.pos_child[pos]
        if not child:
            child = node.pos_child[pos] = UCTNode()
            child.unexplored = board.useful_moves()
            child.pos = pos
            child.parent = node
            path.append(child)
            break
        path.append(child)
        node = child
    self.random_playout(board)
    self.update_path(board, color, path)

</t>
<t tx="ekr.20230509052845.1190">def heappop(heap: List[T], T: type) -&gt; T:
    """Pop the smallest item off the heap, maintaining the heap invariant."""
    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup(heap, 0)
        return returnitem
    return lastelt

</t>
<t tx="ekr.20230509052845.1191">def heapreplace(heap: List[T], item: T, T: type) -&gt; T:
    """
    Pop and return the current smallest value, and add the new item.
    This is more efficient than heappop() followed by heappush(), and can be
    more appropriate when using a fixed-size heap.  Note that the value
    returned may be larger than item!  That constrains reasonable uses of
    this routine unless written as part of a conditional replacement:
    ``if item &gt; heap[0]: item = heapreplace(heap, item)``.
    """
    returnitem = heap[0]  # raises appropriate IndexError if heap is empty
    heap[0] = item
    _siftup(heap, 0)
    return returnitem

</t>
<t tx="ekr.20230509052845.1192">def heappushpop(heap: List[T], item: T, T: type) -&gt; T:
    """Fast version of a heappush followed by a heappop."""
    if heap and heap[0] &lt; item:
        item, heap[0] = heap[0], item
        _siftup(heap, 0)
    return item

</t>
<t tx="ekr.20230509052845.1193">def heapify(x: List[T], T: type):
    """Transform list into a heap, in-place, in $O(len(x))$ time."""
    n = len(x)
    # Transform bottom-up.  The largest index there's any point to looking at
    # is the largest with a child index in-range, so must have 2*i + 1 &lt; n,
    # or i &lt; (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so
    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is
    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.
    for i in reversed(range(n // 2)):
        _siftup(x, i)

</t>
<t tx="ekr.20230509052845.1194">def _heappop_max(heap: List[T], T: type) -&gt; T:
    """Maxheap version of a heappop."""
    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup_max(heap, 0)
        return returnitem
    return lastelt

</t>
<t tx="ekr.20230509052845.1195">def _heapreplace_max(heap: List[T], item: T, T: type) -&gt; T:
    """Maxheap version of a heappop followed by a heappush."""
    returnitem = heap[0]  # raises appropriate IndexError if heap is empty
    heap[0] = item
    _siftup_max(heap, 0)
    return returnitem

</t>
<t tx="ekr.20230509052845.1196">def _heapify_max(x: List[T], T: type):
    """Transform list into a maxheap, in-place, in O(len(x)) time."""
    n = len(x)
    for i in reversed(range(n // 2)):
        _siftup_max(x, i)

</t>
<t tx="ekr.20230509052845.1197">def nsmallest(n: int, iterable: Generator[T], key=Optional[int](), T: type) -&gt; List[T]:
    """Find the n smallest elements in a dataset.
    Equivalent to:  sorted(iterable, key=key)[:n]
    """
    if n == 1:
        v = List(1)
        for a in iterable:
            if not v:
                v.append(a)
            else:
                if not isinstance(key, Optional):
                    if key(a) &lt; key(v[0]):
                        v[0] = a
                elif a &lt; v[0]:
                    v[0] = a
        return v

    # When key is none, use simpler decoration
    if isinstance(key, Optional):
        it = iter(iterable)
        # put the range(n) first so that zip() doesn't
        # consume one too many elements from the iterator
        result = List(n)
        done = False
        for i in range(n):
            if it.done():
                done = True
                break
            result.append((it.next(), i))
        if not result:
            it.destroy()
            return []
        _heapify_max(result)
        top = result[0][0]
        order = n
        if not done:
            for elem in it:
                if elem &lt; top:
                    _heapreplace_max(result, (elem, order))
                    top, _order = result[0]
                    order += 1
        else:
            it.destroy()
        result.sort()
        return [elem for elem, order in result]
    else:
        # General case, slowest method
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(n):
            if it.done():
                done = True
                break
            elem = it.next()
            result.append((key(elem), i, elem))
        if not result:
            it.destroy()
            return []
        _heapify_max(result)
        top = result[0][0]
        order = n
        if not done:
            for elem in it:
                k = key(elem)
                if k &lt; top:
                    _heapreplace_max(result, (k, order, elem))
                    top, _order, _elem = result[0]
                    order += 1
        else:
            it.destroy()
        result.sort()
        return [elem for k, order, elem in result]

</t>
<t tx="ekr.20230509052845.1198">def nlargest(n: int, iterable: Generator[T], key=Optional[int](), T: type) -&gt; List[T]:
    """Find the n largest elements in a dataset.
    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]
    """
    if n == 1:
        v = List(1)
        for a in iterable:
            if not v:
                v.append(a)
            else:
                if not isinstance(key, Optional):
                    if key(a) &gt; key(v[0]):
                        v[0] = a
                elif a &gt; v[0]:
                    v[0] = a
        return v

    # When key is none, use simpler decoration
    if isinstance(key, Optional):
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(0, -n, -1):
            if it.done():
                done = True
                break
            result.append((it.next(), i))
        if not result:
            it.destroy()
            return []
        heapify(result)
        top = result[0][0]
        order = -n
        if not done:
            for elem in it:
                if top &lt; elem:
                    heapreplace(result, (elem, order))
                    top, _order = result[0]
                    order -= 1
        else:
            it.destroy()
        result.sort()
        return [elem for elem, order in reversed(result)]
    else:
        # General case, slowest method
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(0, -n, -1):
            if it.done():
                done = True
                break
            elem = it.next()
            result.append((key(elem), i, elem))
        if not result:
            return []
        heapify(result)
        top = result[0][0]
        order = -n
        if not done:
            for elem in it:
                k = key(elem)
                if top &lt; k:
                    heapreplace(result, (k, order, elem))
                    top, _order, _elem = result[0]
                    order -= 1
        else:
            it.destroy()
        result.sort()
        return [elem for k, order, elem in reversed(result)]

</t>
<t tx="ekr.20230509052845.1199">@tuple
class _MergeItem:
    value: T
    order: int
    gen: Generator[T]
    key: S
    T: type
    S: type

    @others
</t>
<t tx="ekr.20230509052845.12">class Node:
    def __init__(self, left = None, right = None):
        self.left = left
        self.right = right

</t>
<t tx="ekr.20230509052845.120">def select(self, board):
    """ select move; unexplored children first, then according to uct value """
    if self.unexplored:
        i = random.randrange(len(self.unexplored))
        pos = self.unexplored[i]
        self.unexplored[i] = self.unexplored[len(self.unexplored) - 1]
        self.unexplored.pop()
        return pos
    elif self.bestchild:
        return self.bestchild.pos
    else:
        return PASS

</t>
<t tx="ekr.20230509052845.1200">def __lt__(self, other):
    if isinstance(self.key, Optional):
        return (self.value, self.order) &lt; (other.value, other.order)
    else:
        return (self.key(self.value), self.order, self.value) &lt; (
            other.key(other.value),
            other.order,
            other.value,
        )

</t>
<t tx="ekr.20230509052845.1201">def merge(*iterables, key=Optional[int](), reverse: bool = False):
    items = []

    @others
    _heappop = lambda x: _heappop_max(x) if reverse else heappop(x)
    _heapreplace = lambda x, s: _heapreplace_max(x, s) if reverse else heapreplace(x, s)
    direction = -1 if reverse else 1

    order = 0
    for it in iterables:
        gen = iter(it)
        if not gen.done():
            items.append(_MergeItem(gen.next(), order * direction, gen, key))
        order += 1
    _heapify(items)
    while len(items) &gt; 1:
        while True:
            # TODO: @tuple unpacking does not work
            value, order, gen = items[0].value, items[0].order, items[0].gen
            yield value
            if gen.done():
                _heappop(items)
                break
            _heapreplace(items, _MergeItem(gen.next(), order, gen, key))
    if items:
        # fast case when only a single iterator remains
        value, order, gen = items[0].value, items[0].order, items[0].gen
        yield value
        yield from gen
</t>
<t tx="ekr.20230509052845.1202"># TODO: unify types of different compatible functions
# TODO: lambdas with void?
def _heapify(x):
    if reverse:
        _heapify_max(x)
    else:
        heapify(x)

</t>
<t tx="ekr.20230509052845.1203">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.types.optional import unwrap

# Infinite iterators

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1204">@inline
def count(start: T = 0, step: T = 1, T: type) -&gt; Generator[T]:
    """
    Return a count object whose ``__next__`` method returns consecutive values.
    """
    n = start
    while True:
        yield n
        n += step

</t>
<t tx="ekr.20230509052845.1205">@inline
def cycle(iterable: Generator[T], T: type) -&gt; Generator[T]:
    """
    Cycles repeatedly through an iterable.
    """
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element

</t>
<t tx="ekr.20230509052845.1206">@inline
def repeat(object: T, times: Optional[int] = None, T: type) -&gt; Generator[T]:
    """
    Make an iterator that returns a given object over and over again.
    """
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object

</t>
<t tx="ekr.20230509052845.1207"># Iterators terminating on the shortest input sequence

</t>
<t tx="ekr.20230509052845.1208">@inline
def accumulate(iterable: Generator[T], func=lambda a, b: a + b, initial=0, T: type):
    """
    Make an iterator that returns accumulated sums, or accumulated results
    of other binary functions (specified via the optional func argument).
    """
    total = initial
    yield total
    for element in iterable:
        total = func(total, element)
        yield total

</t>
<t tx="ekr.20230509052845.1209">@inline
@overload
def accumulate(iterable: Generator[T], func=lambda a, b: a + b, T: type):
    """
    Make an iterator that returns accumulated sums, or accumulated results
    of other binary functions (specified via the optional func argument).
    """
    total = None
    for element in iterable:
        total = element if total is None else func(unwrap(total), element)
        yield unwrap(total)

</t>
<t tx="ekr.20230509052845.121">def random_playout(self, board):
    """ random play until both players pass """
    for x in range(MAXMOVES):  # XXX while not self.finished?
        if board.finished:
            break
        board.move(board.random_move())

</t>
<t tx="ekr.20230509052845.1210">@tuple
class chain:
    """
    Make an iterator that returns elements from the first iterable until it is exhausted,
    then proceeds to the next iterable, until all of the iterables are exhausted.
    """

    @others
</t>
<t tx="ekr.20230509052845.1211">@inline
def __new__(*iterables):
    for it in iterables:
        for element in it:
            yield element

</t>
<t tx="ekr.20230509052845.1212">@inline
def from_iterable(iterables):
    for it in iterables:
        for element in it:
            yield element

</t>
<t tx="ekr.20230509052845.1213">@inline
def compress(
    data: Generator[T], selectors: Generator[B], T: type, B: type
) -&gt; Generator[T]:
    """
    Return data elements corresponding to true selector elements.
    Forms a shorter iterator from selected data elements using the selectors to
    choose the data elements.
    """
    for d, s in zip(data, selectors):
        if s:
            yield d

</t>
<t tx="ekr.20230509052845.1214">@inline
def dropwhile(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Drop items from the iterable while predicate(item) is true.
    Afterwards, return every element until the iterable is exhausted.
    """
    b = False
    for x in iterable:
        if not b and not predicate(x):
            b = True
        if b:
            yield x

</t>
<t tx="ekr.20230509052845.1215">@inline
def filterfalse(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Return those items of iterable for which function(item) is false.
    """
    for x in iterable:
        if not predicate(x):
            yield x

</t>
<t tx="ekr.20230509052845.1216"># TODO: fix this once Optional[Callable] lands
@inline
def groupby(iterable, key=Optional[int]()):
    """
    Make an iterator that returns consecutive keys and groups from the iterable.
    """
    currkey = None
    group = []

    for currvalue in iterable:
        k = currvalue if isinstance(key, Optional) else key(currvalue)
        if currkey is None:
            currkey = k
        if k != unwrap(currkey):
            yield unwrap(currkey), group
            currkey = k
            group = []
        group.append(currvalue)
    if currkey is not None:
        yield unwrap(currkey), group

</t>
<t tx="ekr.20230509052845.1217">def islice(iterable: Generator[T], stop: Optional[int], T: type) -&gt; Generator[T]:
    """
    Make an iterator that returns selected elements from the iterable.
    """
    if stop is not None and stop.__val__() &lt; 0:
        raise ValueError(
            "Indices for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize."
        )
    i = 0
    for x in iterable:
        if stop is not None and i &gt;= stop.__val__():
            break
        yield x
        i += 1

</t>
<t tx="ekr.20230509052845.1218">@overload
def islice(
    iterable: Generator[T],
    start: Optional[int],
    stop: Optional[int],
    step: Optional[int] = None,
    T: type,
) -&gt; Generator[T]:
    """
    Make an iterator that returns selected elements from the iterable.
    """
    from sys import maxsize

    start: int = 0 if start is None else start
    stop: int = maxsize if stop is None else stop
    step: int = 1 if step is None else step
    have_stop = False

    if start &lt; 0 or stop &lt; 0:
        raise ValueError(
            "Indices for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize."
        )
    elif step &lt; 0:
        raise ValueError("Step for islice() must be a positive integer or None.")

    it = range(start, stop, step)
    N = len(it)
    idx = 0
    b = -1

    if N == 0:
        for i, element in zip(range(start), iterable):
            pass
        return

    nexti = it[0]
    for i, element in enumerate(iterable):
        if i == nexti:
            yield element
            idx += 1
            if idx &gt;= N:
                b = i
                break
            nexti = it[idx]

    if b &gt;= 0:
        for i, element in zip(range(b + 1, stop), iterable):
            pass

</t>
<t tx="ekr.20230509052845.1219">@inline
def starmap(function, iterable):
    """
    Return an iterator whose values are returned from the function
    evaluated with an argument tuple taken from the given sequence.
    """
    for args in iterable:
        yield function(*args)

</t>
<t tx="ekr.20230509052845.122">def update_path(self, board, color, path):
    """ update win/loss count along path """
    wins = board.score(BLACK) &gt;= board.score(WHITE)
    for node in path:
        if color == BLACK:
            color = WHITE
        else:
            color = BLACK
        if wins == (color == BLACK):
            node.wins += 1
        else:
            node.losses += 1
        if node.parent:
            node.parent.bestchild = node.parent.best_child()

</t>
<t tx="ekr.20230509052845.1220">@inline
def takewhile(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Return successive entries from an iterable as long as the predicate evaluates to true for each entry.
    """
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break

</t>
<t tx="ekr.20230509052845.1221">def tee(iterable: Generator[T], n: int = 2, T: type) -&gt; List[Generator[T]]:
    """
    Return n independent iterators from a single iterable.
    """
    from collections import deque

    it = iter(iterable)
    deques = [deque[T]() for i in range(n)]

    @others
    return [gen(d) for d in deques]

</t>
<t tx="ekr.20230509052845.1222">def gen(mydeque: deque[T], T: type) -&gt; Generator[T]:
    while True:
        if not mydeque:  # when the local deque is empty
            if it.__done__():
                return
            it.__resume__()
            if it.__done__():
                return
            newval = it.next()
            for d in deques:  # load it to all the deques
                d.append(newval)
        yield mydeque.popleft()

</t>
<t tx="ekr.20230509052845.1223">@inline
def zip_longest(*iterables, fillvalue):
    """
    Make an iterator that aggregates elements from each of the iterables.
    If the iterables are of uneven length, missing values are filled-in
    with fillvalue. Iteration continues until the longest iterable is
    exhausted.
    """
    if staticlen(iterables) == 2:
        a = iter(iterables[0])
        b = iter(iterables[1])
        a_done = False
        b_done = False

        while not a.done():
            a_val = a.next()
            b_val = fillvalue
            if not b_done:
                b_done = b.done()
            if not b_done:
                b_val = b.next()
            yield a_val, b_val

        if not b_done:
            while not b.done():
                yield fillvalue, b.next()

        a.destroy()
        b.destroy()
    else:
        iterators = tuple(iter(it) for it in iterables)
        num_active = len(iterators)
        if not num_active:
            return
        while True:
            values = []
            for it in iterators:
                if it.__done__():  # already done
                    values.append(fillvalue)
                elif it.done():  # resume and check
                    num_active -= 1
                    if not num_active:
                        return
                    values.append(fillvalue)
                else:
                    values.append(it.next())
            yield values

</t>
<t tx="ekr.20230509052845.1224">@inline
@overload
def zip_longest(*args):
    """
    Make an iterator that aggregates elements from each of the iterables.
    If the iterables are of uneven length, missing values are filled-in
    with fillvalue. Iteration continues until the longest iterable is
    exhausted.
    """

    @others
    iters = tuple(iter(arg) for arg in args)
    while True:
        done_count = 0
        result = tuple(get_next(it) for it in iters)
        all_none = True
        for a in result:
            if a is not None:
                all_none = False
        if all_none:
            return
        yield result
    for it in iters:
        it.destroy()

</t>
<t tx="ekr.20230509052845.1225">def get_next(it):
    if it.__done__() or it.done():
        return None
    return it.next()

</t>
<t tx="ekr.20230509052845.1226"># Combinatoric iterators

</t>
<t tx="ekr.20230509052845.1227">def combinations(pool: Generator[T], r: int, T: type) -&gt; Generator[List[T]]:
    """
    Return successive r-length combinations of elements in the iterable.

    combinations(range(4), 3) --&gt; (0,1,2), (0,1,3), (0,2,3), (1,2,3)
    """

    @others
    if r &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return combinations_helper(pool, r)
    else:
        return combinations_helper([a for a in pool], r)

</t>
<t tx="ekr.20230509052845.1228">def combinations_helper(pool: List[T], r: int, T: type) -&gt; Generator[List[T]]:
    n = len(pool)
    if r &gt; n:
        return
    indices = list(range(r))
    yield [pool[i] for i in indices]
    while True:
        b = -1
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                b = i
                break
        if b == -1:
            return
        indices[b] += 1
        for j in range(b + 1, r):
            indices[j] = indices[j - 1] + 1
        yield [pool[i] for i in indices]

</t>
<t tx="ekr.20230509052845.1229">def combinations_with_replacement(
    pool: Generator[T], r: int, T: type
) -&gt; Generator[List[T]]:
    """
    Return successive r-length combinations of elements in the iterable
    allowing individual elements to have successive repeats.
    """

    @others
    if r &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return combinations_with_replacement_helper(pool, r)
    else:
        return combinations_with_replacement_helper([a for a in pool], r)

</t>
<t tx="ekr.20230509052845.123">def score(self):
    winrate = self.wins / float(self.wins + self.losses)
    parentvisits = self.parent.wins + self.parent.losses
    if not parentvisits:
        return winrate
    nodevisits = self.wins + self.losses
    return winrate + math.sqrt((math.log(parentvisits)) / (5 * nodevisits))

</t>
<t tx="ekr.20230509052845.1230">def combinations_with_replacement_helper(
    pool: List[T], r: int, T: type
) -&gt; Generator[List[T]]:
    n = len(pool)
    if not n and r:
        return
    indices = [0 for _ in range(r)]
    yield [pool[i] for i in indices]
    while True:
        b = -1
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                b = i
                break
        if b == -1:
            return
        newval = indices[b] + 1
        for j in range(r - b):
            indices[b + j] = newval
        yield [pool[i] for i in indices]

</t>
<t tx="ekr.20230509052845.1231">def permutations(
    pool: Generator[T], r: Optional[int] = None, T: type
) -&gt; Generator[List[T]]:
    """
    Return successive r-length permutations of elements in the iterable.
    """

    @others
    if r is not None and r.__val__() &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return permutations_helper(pool, r)
    else:
        return permutations_helper([a for a in pool], r)

</t>
<t tx="ekr.20230509052845.1232">def permutations_helper(
    pool: List[T], r: Optional[int], T: type
) -&gt; Generator[List[T]]:
    n = len(pool)
    r: int = r if r is not None else n
    if r &gt; n:
        return

    indices = list(range(n))
    cycles = list(range(n, n - r, -1))
    yield [pool[i] for i in indices[:r]]
    while n:
        b = -1
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices = indices[:i] + indices[i + 1 :] + indices[i : i + 1]
                cycles[i] = n - i
            else:
                b = i
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield [pool[i] for i in indices[:r]]
                break
        if b == -1:
            return

</t>
<t tx="ekr.20230509052845.1233">@inline
def product(*args):
    """
    Cartesian product of input iterables.
    """
    if staticlen(args) == 0:
        yield ()
    else:
        for a in args[0]:
            rest = args[1:]
            for b in product(*rest):
                yield (a, *b)

</t>
<t tx="ekr.20230509052845.1234">@inline
@overload
def product(*args, repeat: int):
    """
    Cartesian product of input iterables.
    """
    if repeat &lt; 0:
        raise ValueError("repeat argument cannot be negative")
    pools = [list(pool) for _ in range(repeat) for pool in args]
    result = [List[type(pools[0][0])]()]
    for pool in pools:
        result = [x + [y] for x in result for y in pool]
    for prod in result:
        yield prod
</t>
<t tx="ekr.20230509052845.1235">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1236">@pure
@llvm
def _inf() -&gt; float:
    ret double 0x7FF0000000000000

</t>
<t tx="ekr.20230509052845.1237">@pure
@llvm
def _nan() -&gt; float:
    ret double 0x7FF8000000000000

</t>
<t tx="ekr.20230509052845.1238">e = 2.7182818284590452354
pi = 3.14159265358979323846
tau = 6.28318530717958647693
inf = _inf()
nan = _nan()

</t>
<t tx="ekr.20230509052845.1239">def factorial(x: int) -&gt; int:
    _F = (
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800,
        39916800,
        479001600,
        6227020800,
        87178291200,
        1307674368000,
        20922789888000,
        355687428096000,
        6402373705728000,
        121645100408832000,
        2432902008176640000,
    )
    if not (0 &lt;= x &lt;= 20):
        raise ValueError("factorial is only supported for 0 &lt;= x &lt;= 20")
    return _F[x]

</t>
<t tx="ekr.20230509052845.124">def best_child(self):
    maxscore = -1.
    maxchild = None
    for child in self.pos_child:
        if child and child.score() &gt; maxscore:
            maxchild = child
            maxscore = child.score()
    return maxchild

</t>
<t tx="ekr.20230509052845.1240">def isnan(x: float) -&gt; bool:
    """
    isnan(float) -&gt; bool

    Return True if float arg is a NaN, else False.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1241">@pure
@llvm
def f(x: float) -&gt; bool:
    %y = fcmp uno double %x, 0.000000e+00
    %z = zext i1 %y to i8
    ret i8 %z

</t>
<t tx="ekr.20230509052845.1242">def isinf(x: float) -&gt; bool:
    """
    isinf(float) -&gt; bool:

    Return True if float arg is an INF, else False.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1243">@pure
@llvm
def f(x: float) -&gt; bool:
    declare double @llvm.fabs.f64(double)
    %a = call double @llvm.fabs.f64(double %x)
    %b = fcmp oeq double %a, 0x7FF0000000000000
    %c = zext i1 %b to i8
    ret i8 %c

</t>
<t tx="ekr.20230509052845.1244">def isfinite(x: float) -&gt; bool:
    """
    isfinite(float) -&gt; bool

    Return True if x is neither an infinity nor a NaN,
    and False otherwise.
    """
    return not (isnan(x) or isinf(x))

</t>
<t tx="ekr.20230509052845.1245">def _check1(arg: float, r: float, can_overflow: bool = False):
    if __py_numerics__:
        if isnan(r) and not isnan(arg):
            raise ValueError("math domain error")

        if isinf(r) and isfinite(arg):
            if can_overflow:
                raise OverflowError("math range error")
            else:
                raise ValueError("math domain error")

    return r

</t>
<t tx="ekr.20230509052845.1246">def _check2(x: float, y: float, r: float, can_overflow: bool = False):
    if __py_numerics__:
        if isnan(r) and not isnan(x) and not isnan(y):
            raise ValueError("math domain error")

        if isinf(r) and isfinite(x) and isfinite(y):
            if can_overflow:
                raise OverflowError("math range error")
            else:
                raise ValueError("math domain error")

    return r

</t>
<t tx="ekr.20230509052845.1247">def ceil(x: float) -&gt; float:
    """
    ceil(float) -&gt; float

    Return the ceiling of x as an Integral.
    This is the smallest integer &gt;= x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1248">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.ceil.f64(double)
    %y = call double @llvm.ceil.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1249">def floor(x: float) -&gt; float:
    """
    floor(float) -&gt; float

    Return the floor of x as an Integral.
    This is the largest integer &lt;= x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.125">def best_visited(self):
    maxvisits = -1
    maxchild = None
    for child in self.pos_child:
        #            if child:
        # print to_xy(child.pos), child.wins, child.losses, child.score()
        if child and (child.wins + child.losses) &gt; maxvisits:
            maxvisits, maxchild = (child.wins + child.losses), child
    return maxchild


</t>
<t tx="ekr.20230509052845.1250">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.floor.f64(double)
    %y = call double @llvm.floor.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1251">def fabs(x: float) -&gt; float:
    """
    fabs(float) -&gt; float

    Returns the absolute value of a floating point number.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1252">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.fabs.f64(double)
    %y = call double @llvm.fabs.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1253">def fmod(x: float, y: float) -&gt; float:
    """
    fmod(float, float) -&gt; float

    Returns the remainder of x divided by y.
    """
    @others
    return f(x, y)

</t>
<t tx="ekr.20230509052845.1254">@pure
@llvm
def f(x: float, y: float) -&gt; float:
    %z = frem double %x, %y
    ret double %z

</t>
<t tx="ekr.20230509052845.1255">def exp(x: float) -&gt; float:
    """
    exp(float) -&gt; float

    Returns the value of e raised to the xth power.
    """
    @others
    return _check1(x, f(x), True)

</t>
<t tx="ekr.20230509052845.1256">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.exp.f64(double)
    %y = call double @llvm.exp.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1257">def expm1(x: float) -&gt; float:
    """
    expm1(float) -&gt; float

    Return e raised to the power x, minus 1. expm1 provides
    a way to compute this quantity to full precision.
    """
    return _check1(x, _C.expm1(x), True)

</t>
<t tx="ekr.20230509052845.1258">def ldexp(x: float, i: int) -&gt; float:
    """
    ldexp(float, int) -&gt; float

    Returns x multiplied by 2 raised to the power of exponent.
    """
    return _check1(x, _C.ldexp(x, i32(i)), True)

</t>
<t tx="ekr.20230509052845.1259">def log(x: float, base: float = e) -&gt; float:
    """
    log(float) -&gt; float

    Returns the natural logarithm (base-e logarithm) of x.
    """
    @others
    if base == e:
        return _check1(x, f(x))
    else:
        return _check1(x, f(x)) / _check1(base, f(base))

</t>
<t tx="ekr.20230509052845.126"># def user_move(board):
#     while True:
#         text = input('?').strip()
#         if text == 'p':
#             return PASS
#         if text == 'q':
#             raise EOFError
#         try:
#             x, y = [int(i) for i in text.split()]
#         except ValueError:
#             continue
#         if not (0 &lt;= x &lt; SIZE and 0 &lt;= y &lt; SIZE):
#             continue
#         pos = to_pos(x, y)
#         if board.useful(pos):
#             return pos


</t>
<t tx="ekr.20230509052845.1260">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.log.f64(double)
    %y = call double @llvm.log.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1261">def log2(x: float) -&gt; float:
    """
    log2(float) -&gt; float

    Return the base-2 logarithm of x.
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1262">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.log2.f64(double)
    %y = call double @llvm.log2.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1263">def log10(x: float) -&gt; float:
    """
    log10(float) -&gt; float

    Returns the common logarithm (base-10 logarithm) of x.
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1264">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.log10.f64(double)
    %y = call double @llvm.log10.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1265">def degrees(x: float) -&gt; float:
    """
    degrees(float) -&gt; float

    Convert angle x from radians to degrees.
    """
    radToDeg = 180.0 / pi
    return x * radToDeg

</t>
<t tx="ekr.20230509052845.1266">def radians(x: float) -&gt; float:
    """
    radians(float) -&gt; float

    Convert angle x from degrees to radians.
    """
    degToRad = pi / 180.0
    return x * degToRad

</t>
<t tx="ekr.20230509052845.1267">def sqrt(x: float) -&gt; float:
    """
    sqrt(float) -&gt; float

    Returns the square root of x.
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1268">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.sqrt.f64(double)
    %y = call double @llvm.sqrt.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1269">def pow(x: float, y: float) -&gt; float:
    """
    pow(float, float) -&gt; float

    Returns x raised to the power of y.
    """
    @others
    return _check2(x, y, f(x, y), True)

</t>
<t tx="ekr.20230509052845.127">def computer_move(board):
    pos = board.random_move()
    if pos == PASS:
        return PASS
    tree = UCTNode()
    tree.unexplored = board.useful_moves()
    nboard = Board()
    for game in range(GAMES):
        node = tree
        nboard.reset()
        nboard.replay(board.history)
        node.play(nboard)
    return tree.best_visited().pos


</t>
<t tx="ekr.20230509052845.1270">@pure
@llvm
def f(x: float, y: float) -&gt; float:
    declare double @llvm.pow.f64(double, double)
    %z = call double @llvm.pow.f64(double %x, double %y)
    ret double %z

</t>
<t tx="ekr.20230509052845.1271">def acos(x: float) -&gt; float:
    """
    acos(float) -&gt; float

    Returns the arc cosine of x in radians.
    """
    return _check1(x, _C.acos(x))

</t>
<t tx="ekr.20230509052845.1272">def asin(x: float) -&gt; float:
    """
    asin(float) -&gt; float

    Returns the arc sine of x in radians.
    """
    return _check1(x, _C.asin(x))

</t>
<t tx="ekr.20230509052845.1273">def atan(x: float) -&gt; float:
    """
    atan(float) -&gt; float

    Returns the arc tangent of x in radians.
    """
    return _check1(x, _C.atan(x))

</t>
<t tx="ekr.20230509052845.1274">def atan2(y: float, x: float) -&gt; float:
    """
    atan2(float, float) -&gt; float

    Returns the arc tangent in radians of y/x based
    on the signs of both values to determine the
    correct quadrant.
    """
    return _check2(x, y, _C.atan2(y, x))

</t>
<t tx="ekr.20230509052845.1275">def cos(x: float) -&gt; float:
    """
    cos(float) -&gt; float

    Returns the cosine of a radian angle x.
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1276">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.cos.f64(double)
    %y = call double @llvm.cos.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1277">def sin(x: float) -&gt; float:
    """
    sin(float) -&gt; float

    Returns the sine of a radian angle x.
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1278">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.sin.f64(double)
    %y = call double @llvm.sin.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1279">def hypot(x: float, y: float) -&gt; float:
    """
    hypot(float, float) -&gt; float

    Return the Euclidean norm.
    This is the length of the vector from the
    origin to point (x, y).
    """
    return _check2(x, y, _C.hypot(x, y), True)

</t>
<t tx="ekr.20230509052845.128">def versus_cpu():
    for i in range(100):
        random.seed(i)
        board = Board()
        computer_move(board)


</t>
<t tx="ekr.20230509052845.1280">def tan(x: float) -&gt; float:
    """
    tan(float) -&gt; float

    Return the tangent of a radian angle x.
    """
    return _check1(x, _C.tan(x))

</t>
<t tx="ekr.20230509052845.1281">def cosh(x: float) -&gt; float:
    """
    cosh(float) -&gt; float

    Returns the hyperbolic cosine of x.
    """
    return _check1(x, _C.cosh(x), True)

</t>
<t tx="ekr.20230509052845.1282">def sinh(x: float) -&gt; float:
    """
    sinh(float) -&gt; float

    Returns the hyperbolic sine of x.
    """
    return _check1(x, _C.sinh(x), True)

</t>
<t tx="ekr.20230509052845.1283">def tanh(x: float) -&gt; float:
    """
    tanh(float) -&gt; float

    Returns the hyperbolic tangent of x.
    """
    return _check1(x, _C.tanh(x))

</t>
<t tx="ekr.20230509052845.1284">def acosh(x: float) -&gt; float:
    """
    acosh(float) -&gt; float

    Return the inverse hyperbolic cosine of x.
    """
    return _check1(x, _C.acosh(x))

</t>
<t tx="ekr.20230509052845.1285">def asinh(x: float) -&gt; float:
    """
    asinh(float) -&gt; float

    Return the inverse hyperbolic sine of x.
    """
    return _check1(x, _C.asinh(x))

</t>
<t tx="ekr.20230509052845.1286">def atanh(x: float) -&gt; float:
    """
    atanh(float) -&gt; float

    Return the inverse hyperbolic tangent of x.
    """
    return _check1(x, _C.atanh(x))

</t>
<t tx="ekr.20230509052845.1287">def copysign(x: float, y: float) -&gt; float:
    """
    copysign(float, float) -&gt; float

    Return a float with the magnitude (absolute value) of
    x but the sign of y.
    """
    @others
    return _check2(x, y, f(x, y))

</t>
<t tx="ekr.20230509052845.1288">@pure
@llvm
def f(x: float, y: float) -&gt; float:
    declare double @llvm.copysign.f64(double, double)
    %z = call double @llvm.copysign.f64(double %x, double %y)
    ret double %z

</t>
<t tx="ekr.20230509052845.1289">def log1p(x: float) -&gt; float:
    """
    log1p(float) -&gt; float

    Return the natural logarithm of 1+x (base e).
    """
    return _check1(x, _C.log1p(x))

</t>
<t tx="ekr.20230509052845.129">@path C:/Repos/codon/bench/go/
"""
Go board game
"""
import math
import random
from time import time

SIZE = 9
GAMES = 200
KOMI = 7.5
EMPTY, WHITE, BLACK = 0, 1, 2
SHOW = {EMPTY: '.', WHITE: 'o', BLACK: 'x'}
PASS = -1
MAXMOVES = SIZE * SIZE * 3
TIMESTAMP = 0
MOVES = 0


@others
if __name__ == "__main__":
    t0 = time()
    versus_cpu()
    t1 = time()
    print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1290">def trunc(x: float) -&gt; float:
    """
    trunc(float) -&gt; float

    Return the Real value x truncated to an Integral
    (usually an integer).
    """
    @others
    return _check1(x, f(x))

</t>
<t tx="ekr.20230509052845.1291">@pure
@llvm
def f(x: float) -&gt; float:
    declare double @llvm.trunc.f64(double)
    %y = call double @llvm.trunc.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.1292">def erf(x: float) -&gt; float:
    """
    erf(float) -&gt; float

    Return the error function at x.
    """
    return _check1(x, _C.erf(x))

</t>
<t tx="ekr.20230509052845.1293">def erfc(x: float) -&gt; float:
    """
    erfc(float) -&gt; float

    Return the complementary error function at x.
    """
    return _check1(x, _C.erfc(x))

</t>
<t tx="ekr.20230509052845.1294">def gamma(x: float) -&gt; float:
    """
    gamma(float) -&gt; float

    Return the Gamma function at x.
    """
    return _check1(x, _C.tgamma(x), True)

</t>
<t tx="ekr.20230509052845.1295">def lgamma(x: float) -&gt; float:
    """
    lgamma(float) -&gt; float

    Return the natural logarithm of
    the absolute value of the Gamma function at x.
    """
    return _check1(x, _C.lgamma(x), True)

</t>
<t tx="ekr.20230509052845.1296">def remainder(x: float, y: float) -&gt; float:
    """
    remainder(float, float) -&gt; float

    Return the IEEE 754-style remainder of x with respect to y.
    For finite x and finite nonzero y, this is the difference
    x - n*y, where n is the closest integer to the exact value
    of the quotient x / y. If x / y is exactly halfway between
    two consecutive integers, the nearest even integer is used
    for n.
    """
    return _check2(x, y, _C.remainder(x, y))

</t>
<t tx="ekr.20230509052845.1297">def gcd(a: float, b: float) -&gt; float:
    """
    gcd(float, float) -&gt; float

    returns greatest common divisor of x and y.
    """
    a = abs(a)
    b = abs(b)
    while a:
        a, b = b % a, a
    return b

</t>
<t tx="ekr.20230509052845.1298">@pure
def frexp(x: float) -&gt; Tuple[float, int]:
    """
    frexp(float) -&gt; Tuple[float, int]

    The returned value is the mantissa and the integer pointed
    to by exponent is the exponent. The resultant value is
    x = mantissa * 2 ^ exponent.
    """
    tmp = i32(0)
    res = _C.frexp(float(x), __ptr__(tmp))
    return (res, int(tmp))

</t>
<t tx="ekr.20230509052845.1299">@pure
def modf(x: float) -&gt; Tuple[float, float]:
    """
    modf(float) -&gt; Tuple[float, float]

    The returned value is the fraction component (part after
    the decimal), and sets integer to the integer component.
    """
    tmp = 0.0
    res = _C.modf(float(x), __ptr__(tmp))
    return (res, tmp)

</t>
<t tx="ekr.20230509052845.13">def make_tree(d):
    return Node(make_tree(d - 1), make_tree(d - 1)) if d &gt; 0 else Node()

</t>
<t tx="ekr.20230509052845.130">def to_pos(x, y):
    return y * SIZE + x


</t>
<t tx="ekr.20230509052845.1300">def isclose(a: float, b: float, rel_tol: float = 1e-09, abs_tol: float = 0.0) -&gt; bool:
    """
    isclose(float, float) -&gt; bool

    Return True if a is close in value to b, and False otherwise.
    For the values to be considered close, the difference between them
    must be smaller than at least one of the tolerances.
    """

    # short circuit exact equality -- needed to catch two
    # infinities of the same sign. And perhaps speeds things
    # up a bit sometimes.
    if a == b:
        return True

    # This catches the case of two infinities of opposite sign, or
    # one infinity and one finite number. Two infinities of opposite
    # sign would otherwise have an infinite relative tolerance.
    # Two infinities of the same sign are caught by the equality check
    # above.
    if a == inf or b == inf:
        return False

    # NAN is not close to anything, not even itself
    if a == nan or b == nan:
        return False

    # regular computation
    diff = fabs(b - a)

    return ((diff &lt;= fabs(rel_tol * b)) or (diff &lt;= fabs(rel_tol * a))) or (
        diff &lt;= abs_tol
    )

</t>
<t tx="ekr.20230509052845.1301">def fsum(seq):
    @others
    _NUM_PARTIALS: Static[int] = 32
    ps_arr = __array__[float](_NUM_PARTIALS)
    ps = ps_arr.ptr
    p = ps
    n, m = 0, _NUM_PARTIALS
    xsave, special_sum, inf_sum = 0.0, 0.0, 0.0
    hi, yr, lo = 0.0, 0.0, 0.0

    for item in seq:
        x = float(item)
        xsave = x
        i = 0

        for j in range(n):  # for y in partials
            y = p[j]
            if fabs(x) &lt; fabs(y):
                x, y = y, x
            hi = x + y
            yr = hi - x
            lo = y - yr
            if lo != 0.0:
                p[i] = lo
                i += 1
            x = hi

        n = i
        if x != 0.0:
            if not isfinite(x):
                # a nonfinite x could arise either as
                # a result of intermediate overflow, or
                if isfinite(xsave):
                    raise OverflowError("intermediate overflow in fsum")
                if isinf(xsave):
                    inf_sum += xsave
                special_sum += xsave
                # reset partials
                n = 0
            else:
                if n &gt;= m:
                    p, m = _fsum_realloc(p, ps, n, m)
                p[n] = x
                n += 1

    if special_sum != 0.0:
        if isnan(inf_sum):
            raise ValueError("-inf + inf in fsum")
        else:
            return special_sum

    hi = 0.0
    if n &gt; 0:
        hi = p[n - 1]
        n -= 1
        # sum_exact(ps, hi) from the top, stop when the sum becomes inexact
        while n &gt; 0:
            x = hi
            y = p[n - 1]
            n -= 1
            # assert fabs(y) &lt; fabs(x)
            hi = x + y
            yr = hi - x
            lo = y - yr
            if lo != 0.0:
                break

        # Make half-even rounding work across multiple partials.
        # Needed so that sum([1e-16, 1, 1e16]) will round-up the last
        # digit to two instead of down to zero (the 1e-16 makes the 1
        # slightly closer to two).  With a potential 1 ULP rounding
        # error fixed-up, math.fsum() can guarantee commutativity.
        if n &gt; 0 and ((lo &lt; 0.0 and p[n-1] &lt; 0.0) or (lo &gt; 0.0 and p[n-1] &gt; 0.0)):
            y = lo * 2.0
            x = hi + y
            yr = x - hi
            if y == yr:
                hi = x

    return hi

</t>
<t tx="ekr.20230509052845.1302">def _fsum_realloc(p: Ptr[float], ps: Ptr[float], n: int, m: int):
    from internal.gc import realloc, sizeof
    v = Ptr[float]()
    m += m
    if n &lt; m:
        if p == ps:
            v = Ptr[float](m)
            str.memcpy(v.as_byte(), ps.as_byte(), n * sizeof(float))
        else:
            v = Ptr[float](realloc(p.as_byte(), m * sizeof(float), n * sizeof(float)))
    return v, m

</t>
<t tx="ekr.20230509052845.1303"># 32-bit float ops

e32 = float32(e)
pi32 = float32(pi)
tau32 = float32(tau)

inf32 = float32(inf)
nan32 = float32(nan)

</t>
<t tx="ekr.20230509052845.1304">@overload
def isnan(x: float32) -&gt; bool:
    """
    isnan(float32) -&gt; bool

    Return True if float arg is a NaN, else False.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1305">@pure
@llvm
def f(x: float32) -&gt; bool:
    %y = fcmp uno float %x, 0.000000e+00
    %z = zext i1 %y to i8
    ret i8 %z

</t>
<t tx="ekr.20230509052845.1306">@overload
def isinf(x: float32) -&gt; bool:
    """
    isinf(float32) -&gt; bool:

    Return True if float arg is an INF, else False.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1307">@pure
@llvm
def f(x: float32) -&gt; bool:
    declare float @llvm.fabs.f32(float)
    %a = call float @llvm.fabs.f32(float %x)
    %b = fcmp oeq float %a, 0x7FF0000000000000
    %c = zext i1 %b to i8
    ret i8 %c

</t>
<t tx="ekr.20230509052845.1308">@overload
def isfinite(x: float32) -&gt; bool:
    """
    isfinite(float32) -&gt; bool

    Return True if x is neither an infinity nor a NaN,
    and False otherwise.
    """
    return not (isnan(x) or isinf(x))

</t>
<t tx="ekr.20230509052845.1309">@overload
def ceil(x: float32) -&gt; float32:
    """
    ceil(float32) -&gt; float32

    Return the ceiling of x as an Integral.
    This is the smallest integer &gt;= x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.131">def to_xy(pos):
    y, x = divmod(pos, SIZE)
    return x, y


</t>
<t tx="ekr.20230509052845.1310">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.ceil.f32(float)
    %y = call float @llvm.ceil.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1311">@overload
def floor(x: float32) -&gt; float32:
    """
    floor(float32) -&gt; float32

    Return the floor of x as an Integral.
    This is the largest integer &lt;= x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1312">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.floor.f32(float)
    %y = call float @llvm.floor.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1313">@overload
def fabs(x: float32) -&gt; float32:
    """
    fabs(float32) -&gt; float32

    Returns the absolute value of a float32ing point number.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1314">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.fabs.f32(float)
    %y = call float @llvm.fabs.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1315">@overload
def fmod(x: float32, y: float32) -&gt; float32:
    """
    fmod(float32, float32) -&gt; float32

    Returns the remainder of x divided by y.
    """
    @others
    return f(x, y)

</t>
<t tx="ekr.20230509052845.1316">@pure
@llvm
def f(x: float32, y: float32) -&gt; float32:
    %z = frem float %x, %y
    ret float %z

</t>
<t tx="ekr.20230509052845.1317">@overload
def exp(x: float32) -&gt; float32:
    """
    exp(float32) -&gt; float32

    Returns the value of e raised to the xth power.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1318">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.exp.f32(float)
    %y = call float @llvm.exp.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1319">@overload
def expm1(x: float32) -&gt; float32:
    """
    expm1(float32) -&gt; float32

    Return e raised to the power x, minus 1. expm1 provides
    a way to compute this quantity to full precision.
    """
    return _C.expm1f(x)

</t>
<t tx="ekr.20230509052845.132">class Square:

    @others
</t>
<t tx="ekr.20230509052845.1320">@overload
def ldexp(x: float32, i: int) -&gt; float32:
    """
    ldexp(float32, int) -&gt; float32

    Returns x multiplied by 2 raised to the power of exponent.
    """
    return _C.ldexpf(x, i32(i))

</t>
<t tx="ekr.20230509052845.1321">@overload
def log(x: float32, base: float32 = e32) -&gt; float32:
    """
    log(float32) -&gt; float32

    Returns the natural logarithm (base-e logarithm) of x.
    """
    @others
    if base == e32:
        return f(x)
    else:
        return f(x) / f(base)

</t>
<t tx="ekr.20230509052845.1322">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.log.f32(float)
    %y = call float @llvm.log.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1323">@overload
def log2(x: float32) -&gt; float32:
    """
    log2(float32) -&gt; float32

    Return the base-2 logarithm of x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1324">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.log2.f32(float)
    %y = call float @llvm.log2.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1325">@overload
def log10(x: float32) -&gt; float32:
    """
    log10(float32) -&gt; float32

    Returns the common logarithm (base-10 logarithm) of x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1326">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.log10.f32(float)
    %y = call float @llvm.log10.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1327">@overload
def degrees(x: float32) -&gt; float32:
    """
    degrees(float32) -&gt; float32

    Convert angle x from radians to degrees.
    """
    radToDeg = float32(180.0) / pi32
    return x * radToDeg

</t>
<t tx="ekr.20230509052845.1328">@overload
def radians(x: float32) -&gt; float32:
    """
    radians(float32) -&gt; float32

    Convert angle x from degrees to radians.
    """
    degToRad = pi32 / float32(180.0)
    return x * degToRad

</t>
<t tx="ekr.20230509052845.1329">@overload
def sqrt(x: float32) -&gt; float32:
    """
    sqrt(float32) -&gt; float32

    Returns the square root of x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.133">def __init__(self, board, pos):
    self.board = board
    self.pos = pos
    self.timestamp = TIMESTAMP
    self.removestamp = TIMESTAMP
    self.zobrist_strings = [random.randrange(9223372036854775807)
                            for i in range(3)]

</t>
<t tx="ekr.20230509052845.1330">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.sqrt.f32(float)
    %y = call float @llvm.sqrt.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1331">@overload
def pow(x: float32, y: float32) -&gt; float32:
    """
    pow(float32, float32) -&gt; float32

    Returns x raised to the power of y.
    """
    @others
    return f(x, y)

</t>
<t tx="ekr.20230509052845.1332">@pure
@llvm
def f(x: float32, y: float32) -&gt; float32:
    declare float @llvm.pow.f32(float, float)
    %z = call float @llvm.pow.f32(float %x, float %y)
    ret float %z

</t>
<t tx="ekr.20230509052845.1333">@overload
def acos(x: float32) -&gt; float32:
    """
    acos(float32) -&gt; float32

    Returns the arc cosine of x in radians.
    """
    return _C.acosf(x)

</t>
<t tx="ekr.20230509052845.1334">@overload
def asin(x: float32) -&gt; float32:
    """
    asin(float32) -&gt; float32

    Returns the arc sine of x in radians.
    """
    return _C.asinf(x)

</t>
<t tx="ekr.20230509052845.1335">@overload
def atan(x: float32) -&gt; float32:
    """
    atan(float32) -&gt; float32

    Returns the arc tangent of x in radians.
    """
    return _C.atanf(x)

</t>
<t tx="ekr.20230509052845.1336">@overload
def atan2(y: float32, x: float32) -&gt; float32:
    """
    atan2(float32, float32) -&gt; float32

    Returns the arc tangent in radians of y/x based
    on the signs of both values to determine the
    correct quadrant.
    """
    return _C.atan2f(y, x)

</t>
<t tx="ekr.20230509052845.1337">@overload
def cos(x: float32) -&gt; float32:
    """
    cos(float32) -&gt; float32

    Returns the cosine of a radian angle x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1338">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.cos.f32(float)
    %y = call float @llvm.cos.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1339">@overload
def sin(x: float32) -&gt; float32:
    """
    sin(float32) -&gt; float32

    Returns the sine of a radian angle x.
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.134">def set_neighbours(self):
    x, y = self.pos % SIZE, self.pos // SIZE
    self.neighbours = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        newx, newy = x + dx, y + dy
        if 0 &lt;= newx &lt; SIZE and 0 &lt;= newy &lt; SIZE:
            self.neighbours.append(self.board.squares[to_pos(newx, newy)])

</t>
<t tx="ekr.20230509052845.1340">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.sin.f32(float)
    %y = call float @llvm.sin.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1341">@overload
def hypot(x: float32, y: float32) -&gt; float32:
    """
    hypot(float32, float32) -&gt; float32

    Return the Euclidean norm.
    This is the length of the vector from the
    origin to point (x, y).
    """
    return _C.hypotf(x, y)

</t>
<t tx="ekr.20230509052845.1342">@overload
def tan(x: float32) -&gt; float32:
    """
    tan(float32) -&gt; float32

    Return the tangent of a radian angle x.
    """
    return _C.tanf(x)

</t>
<t tx="ekr.20230509052845.1343">@overload
def cosh(x: float32) -&gt; float32:
    """
    cosh(float32) -&gt; float32

    Returns the hyperbolic cosine of x.
    """
    return _C.coshf(x)

</t>
<t tx="ekr.20230509052845.1344">@overload
def sinh(x: float32) -&gt; float32:
    """
    sinh(float32) -&gt; float32

    Returns the hyperbolic sine of x.
    """
    return _C.sinhf(x)

</t>
<t tx="ekr.20230509052845.1345">@overload
def tanh(x: float32) -&gt; float32:
    """
    tanh(float32) -&gt; float32

    Returns the hyperbolic tangent of x.
    """
    return _C.tanhf(x)

</t>
<t tx="ekr.20230509052845.1346">@overload
def acosh(x: float32) -&gt; float32:
    """
    acosh(float32) -&gt; float32

    Return the inverse hyperbolic cosine of x.
    """
    return _C.acoshf(x)

</t>
<t tx="ekr.20230509052845.1347">@overload
def asinh(x: float32) -&gt; float32:
    """
    asinh(float32) -&gt; float32

    Return the inverse hyperbolic sine of x.
    """
    return _C.asinhf(x)

</t>
<t tx="ekr.20230509052845.1348">@overload
def atanh(x: float32) -&gt; float32:
    """
    atanh(float32) -&gt; float32

    Return the inverse hyperbolic tangent of x.
    """
    return _C.atanhf(x)

</t>
<t tx="ekr.20230509052845.1349">@overload
def copysign(x: float32, y: float32) -&gt; float32:
    """
    copysign(float32, float32) -&gt; float32

    Return a float32 with the magnitude (absolute value) of
    x but the sign of y.
    """
    @others
    return f(x, y)

</t>
<t tx="ekr.20230509052845.135">def move(self, color):
    global TIMESTAMP, MOVES
    TIMESTAMP += 1
    MOVES += 1
    self.board.zobrist.update(self, color)
    self.color = color
    self.reference = self
    self.ledges = 0
    self.used = True
    for neighbour in self.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            self.ledges += 1
        else:
            neighbour_ref = neighbour.find(update=True)
            if neighcolor == color:
                if neighbour_ref.reference.pos != self.pos:
                    self.ledges += neighbour_ref.ledges
                    neighbour_ref.reference = self
                self.ledges -= 1
            else:
                neighbour_ref.ledges -= 1
                if neighbour_ref.ledges == 0:
                    neighbour.remove(neighbour_ref)
    self.board.zobrist.add()

</t>
<t tx="ekr.20230509052845.1350">@pure
@llvm
def f(x: float32, y: float32) -&gt; float32:
    declare float @llvm.copysign.f32(float, float)
    %z = call float @llvm.copysign.f32(float %x, float %y)
    ret float %z

</t>
<t tx="ekr.20230509052845.1351">@overload
def log1p(x: float32) -&gt; float32:
    """
    log1p(float32) -&gt; float32

    Return the natural logarithm of 1+x (base e).
    """
    return _C.log1pf(x)

</t>
<t tx="ekr.20230509052845.1352">@overload
def trunc(x: float32) -&gt; float32:
    """
    trunc(float32) -&gt; float32

    Return the Real value x truncated to an Integral
    (usually an integer).
    """
    @others
    return f(x)

</t>
<t tx="ekr.20230509052845.1353">@pure
@llvm
def f(x: float32) -&gt; float32:
    declare float @llvm.trunc.f32(float)
    %y = call float @llvm.trunc.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.1354">@overload
def erf(x: float32) -&gt; float32:
    """
    erf(float32) -&gt; float32

    Return the error function at x.
    """
    return _C.erff(x)

</t>
<t tx="ekr.20230509052845.1355">@overload
def erfc(x: float32) -&gt; float32:
    """
    erfc(float32) -&gt; float32

    Return the complementary error function at x.
    """
    return _C.erfcf(x)

</t>
<t tx="ekr.20230509052845.1356">@overload
def gamma(x: float32) -&gt; float32:
    """
    gamma(float32) -&gt; float32

    Return the Gamma function at x.
    """
    return _C.tgammaf(x)

</t>
<t tx="ekr.20230509052845.1357">@overload
def lgamma(x: float32) -&gt; float32:
    """
    lgamma(float32) -&gt; float32

    Return the natural logarithm of
    the absolute value of the Gamma function at x.
    """
    return _C.lgammaf(x)

</t>
<t tx="ekr.20230509052845.1358">@overload
def remainder(x: float32, y: float32) -&gt; float32:
    """
    remainder(float32, float32) -&gt; float32

    Return the IEEE 754-style remainder of x with respect to y.
    For finite x and finite nonzero y, this is the difference
    x - n*y, where n is the closest integer to the exact value
    of the quotient x / y. If x / y is exactly halfway between
    two consecutive integers, the nearest even integer is used
    for n.
    """
    return _C.remainderf(x, y)

</t>
<t tx="ekr.20230509052845.1359">@overload
def gcd(a: float32, b: float32) -&gt; float32:
    """
    gcd(float32, float32) -&gt; float32

    returns greatest common divisor of x and y.
    """
    a = abs(a)
    b = abs(b)
    while a:
        a, b = b % a, a
    return b

</t>
<t tx="ekr.20230509052845.136">def remove(self, reference, update=True):
    self.board.zobrist.update(self, EMPTY)
    self.removestamp = TIMESTAMP
    if update:
        self.color = EMPTY
        self.board.emptyset.add(self.pos)
</t>
<t tx="ekr.20230509052845.1360">@overload
@pure
def frexp(x: float32) -&gt; Tuple[float32, int]:
    """
    frexp(float32) -&gt; Tuple[float32, int]

    The returned value is the mantissa and the integer pointed
    to by exponent is the exponent. The resultant value is
    x = mantissa * 2 ^ exponent.
    """
    tmp = i32(0)
    res = _C.frexpf(float32(x), __ptr__(tmp))
    return (res, int(tmp))

</t>
<t tx="ekr.20230509052845.1361">@overload
@pure
def modf(x: float32) -&gt; Tuple[float32, float32]:
    """
    modf(float32) -&gt; Tuple[float32, float32]

    The returned value is the fraction component (part after
    the decimal), and sets integer to the integer component.
    """
    tmp = float32(0.0)
    res = _C.modff(float32(x), __ptr__(tmp))
    return (res, tmp)

</t>
<t tx="ekr.20230509052845.1362">@overload
def isclose(a: float32, b: float32, rel_tol: float32 = float32(1e-09), abs_tol: float32 = float32(0.0)) -&gt; bool:
    """
    isclose(float32, float32) -&gt; bool

    Return True if a is close in value to b, and False otherwise.
    For the values to be considered close, the difference between them
    must be smaller than at least one of the tolerances.
    """

    # short circuit exact equality -- needed to catch two
    # infinities of the same sign. And perhaps speeds things
    # up a bit sometimes.
    if a == b:
        return True

    # This catches the case of two infinities of opposite sign, or
    # one infinity and one finite number. Two infinities of opposite
    # sign would otherwise have an infinite relative tolerance.
    # Two infinities of the same sign are caught by the equality check
    # above.
    if a == inf32 or b == inf32:
        return False

    # NAN is not close to anything, not even itself
    if a == nan32 or b == nan32:
        return False

    # regular computation
    diff = fabs(b - a)

    return ((diff &lt;= fabs(rel_tol * b)) or (diff &lt;= fabs(rel_tol * a))) or (
        diff &lt;= abs_tol
    )
</t>
<t tx="ekr.20230509052845.1363">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# OpenMP interface
# Ref: https://github.com/llvm/llvm-project/tree/main/openmp

Routine = Function[[i32, cobj], i32]

_KMP_IDENT_IMB = 0x01
_KMP_IDENT_KMPC = 0x02
_KMP_IDENT_AUTOPAR = 0x08
_KMP_IDENT_ATOMIC_REDUCE = 0x10
_KMP_IDENT_BARRIER_EXPL = 0x20
_KMP_IDENT_BARRIER_IMPL = 0x0040
_KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0
_KMP_IDENT_BARRIER_IMPL_FOR = 0x0040
_KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0
_KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140
_KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0
_KMP_IDENT_WORK_LOOP = 0x200
_KMP_IDENT_WORK_SECTIONS = 0x400
_KMP_IDENT_WORK_DISTRIBUTE = 0x800
_KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000
_KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000
_KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000
_KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000
_KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000
_KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1364">@tuple
class Lock:
    a1: i32
    a2: i32
    a3: i32
    a4: i32
    a5: i32
    a6: i32
    a7: i32
    a8: i32

    @others
</t>
<t tx="ekr.20230509052845.1365">def __new__() -&gt; Lock:
    z = i32(0)
    return Lock(z, z, z, z, z, z, z, z)

</t>
<t tx="ekr.20230509052845.1366">@tuple
class Ident:
    reserved_1: i32
    flags: i32
    reserved_2: i32
    reserved_3: i32
    psource: cobj

    @others
</t>
<t tx="ekr.20230509052845.1367">def __new__(flags: int = 0, source: str = ";unknown;unknown;0;0;;") -&gt; Ident:
    return Ident(i32(0), i32(flags | _KMP_IDENT_KMPC), i32(0), i32(0), source.ptr)

</t>
<t tx="ekr.20230509052845.1368">@tuple
class LRData:
    routine: Routine

</t>
<t tx="ekr.20230509052845.1369">@tuple
class Task:
    shareds: cobj
    routine: Routine
    flags: i32
    x: LRData
    y: LRData

</t>
<t tx="ekr.20230509052845.137">#            if color == BLACK:
#                self.board.black_dead += 1
#            else:
#                self.board.white_dead += 1
        for neighbour in self.neighbours:
            if neighbour.color != EMPTY and neighbour.removestamp != TIMESTAMP:
                neighbour_ref = neighbour.find(update)
                if neighbour_ref.pos == reference.pos:
                    neighbour.remove(reference, update)
                else:
                    if update:
                        neighbour_ref.ledges += 1

    def find(self, update=False):
        reference = self.reference
        if reference.pos != self.pos:
            reference = reference.find(update)
            if update:
                self.reference = reference
        return reference

    def __repr__(self):
        return repr(to_xy(self.pos))


</t>
<t tx="ekr.20230509052845.1370">@tuple
class TaskWithPrivates:
    task: Task
    data: T
    T: type

</t>
<t tx="ekr.20230509052845.1371">@tuple
class TaskReductionInput:
    reduce_shar: cobj
    reduce_orig: cobj
    reduce_size: int
    reduce_init: cobj
    reduce_fini: cobj
    reduce_comb: cobj
    flags: u32

    @others
</t>
<t tx="ekr.20230509052845.1372">def __new__(reduce_shar, reduce_orig, reduce_size: int,
            reduce_init: cobj, reduce_comb: cobj):
    return TaskReductionInput(reduce_shar.as_byte(), reduce_orig.as_byte(), reduce_size,
                              reduce_init, cobj(), reduce_comb, u32(0))

</t>
<t tx="ekr.20230509052845.1373">@tuple
class TaskReductionInputArray:
    len: int
    ptr: Ptr[TaskReductionInput]

    def __setitem__(self, idx: int, x: TaskReductionInput):
        self.ptr[idx] = x

</t>
<t tx="ekr.20230509052845.1374">_DEFAULT_IDENT = Ident()
_STATIC_LOOP_IDENT = Ident(_KMP_IDENT_WORK_LOOP)
_REDUCTION_IDENT = Ident(_KMP_IDENT_ATOMIC_REDUCE)

</t>
<t tx="ekr.20230509052845.1375">def _default_loc():
    return __ptr__(_DEFAULT_IDENT)

</t>
<t tx="ekr.20230509052845.1376">_default_loc()

</t>
<t tx="ekr.20230509052845.1377">def _static_loop_loc():
    return __ptr__(_STATIC_LOOP_IDENT)

</t>
<t tx="ekr.20230509052845.1378">_static_loop_loc()

</t>
<t tx="ekr.20230509052845.1379">def _reduction_loc():
    return __ptr__(_REDUCTION_IDENT)

</t>
<t tx="ekr.20230509052845.138">class EmptySet:

    @others
</t>
<t tx="ekr.20230509052845.1380">_reduction_loc()

</t>
<t tx="ekr.20230509052845.1381">def _critical_begin(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_critical(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_critical(loc_ref, i32(gtid), lck)

</t>
<t tx="ekr.20230509052845.1382">def _critical_end(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_end_critical(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_end_critical(loc_ref, i32(gtid), lck)

</t>
<t tx="ekr.20230509052845.1383">def _single_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_single(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_single(loc_ref, i32(gtid)))

</t>
<t tx="ekr.20230509052845.1384">def _single_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_single(Ptr[Ident], i32)
    __kmpc_end_single(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1385">def _master_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_master(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_master(loc_ref, i32(gtid)))

</t>
<t tx="ekr.20230509052845.1386">def _master_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_master(Ptr[Ident], i32)
    __kmpc_end_master(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1387">def _ordered_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_ordered(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_ordered(loc_ref, i32(gtid)))

</t>
<t tx="ekr.20230509052845.1388">def _ordered_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_ordered(Ptr[Ident], i32)
    __kmpc_end_ordered(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1389">def _taskwait(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_omp_taskwait(Ptr[Ident], i32)
    __kmpc_omp_taskwait(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.139">def __init__(self, board):
    self.board = board
    self.empties = list(range(SIZE * SIZE))
    self.empty_pos = list(range(SIZE * SIZE))

</t>
<t tx="ekr.20230509052845.1390">def _taskgroup_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_taskgroup(Ptr[Ident], i32)
    __kmpc_taskgroup(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1391">def _taskgroup_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_taskgroup(Ptr[Ident], i32)
    __kmpc_end_taskgroup(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1392">def _task_alloc_size(
    size_of_task: int,
    size_of_shareds: int,
):
    from C import __kmpc_omp_task_alloc_size(int, int) -&gt; int
    return __kmpc_omp_task_alloc_size(size_of_task, size_of_shareds)

</t>
<t tx="ekr.20230509052845.1393">def _task_alloc(
    loc_ref: Ptr[Ident],
    gtid: int,
    flags: int,
    size_of_task: int,
    size_of_shareds: int,
    task_entry: Routine,
):
    from internal.gc import alloc
    from C import __kmpc_omp_task_alloc(Ptr[Ident], i32, i32, int, int, Routine, cobj) -&gt; cobj

    taskdata = alloc(_task_alloc_size(size_of_task, size_of_shareds))
    return __kmpc_omp_task_alloc(
        loc_ref, i32(gtid), i32(flags), size_of_task, size_of_shareds, task_entry, taskdata
    )

</t>
<t tx="ekr.20230509052845.1394">def _task_run(loc_ref: Ptr[Ident], gtid: int, new_task: cobj):
    from C import __kmpc_omp_task(Ptr[Ident], i32, cobj) -&gt; i32
    return int(__kmpc_omp_task(loc_ref, i32(gtid), new_task))

</t>
<t tx="ekr.20230509052845.1395">def _barrier(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_barrier(Ptr[Ident], i32)
    __kmpc_barrier(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1396">def _flush(loc_ref: Ptr[Ident]):
    from C import __kmpc_flush(Ptr[Ident])
    __kmpc_flush(loc_ref)

</t>
<t tx="ekr.20230509052845.1397">def flush():
    _flush(_default_loc())

</t>
<t tx="ekr.20230509052845.1398">def _static_init(
    loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, incr: int, chunk: int
):
    from C import __kmpc_for_static_init_8(Ptr[Ident], i32, i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int], int, int)
    last = i32(0)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_for_static_init_8(
        loc_ref,
        i32(gtid),
        i32(schedtype),
        __ptr__(last),
        __ptr__(lower),
        __ptr__(upper),
        __ptr__(stride),
        incr,
        chunk,
    )
    return bool(last), range(loop._get(lower), loop._get(upper + 1), loop.step), stride

</t>
<t tx="ekr.20230509052845.1399">def _static_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_for_static_fini(Ptr[Ident], i32)
    __kmpc_for_static_fini(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.14">def check_tree(node):
    l, r = node.left, node.right
    if l is None:
        return 1
    else:
        return 1 + check_tree(l) + check_tree(r)

</t>
<t tx="ekr.20230509052845.140">def random_choice(self):
    choices = len(self.empties)
    while choices:
        i = int(random.random() * choices)
        pos = self.empties[i]
        if self.board.useful(pos):
            return pos
        choices -= 1
        self.set(i, self.empties[choices])
        self.set(choices, pos)
    return PASS

</t>
<t tx="ekr.20230509052845.1400">def _dynamic_init(
    loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, chunk: int
):
    from C import __kmpc_dispatch_init_8(Ptr[Ident], i32, i32, int, int, int, int)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_dispatch_init_8(
        loc_ref, i32(gtid), i32(schedtype), lower, upper, stride, chunk
    )

</t>
<t tx="ekr.20230509052845.1401">def _dynamic_next(loc_ref: Ptr[Ident], gtid: int, loop: range):
    from C import __kmpc_dispatch_next_8(Ptr[Ident], i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int]) -&gt; i32
    last = i32(0)
    lower = 0
    upper = 0
    stride = 0
    more = __kmpc_dispatch_next_8(
        loc_ref,
        i32(gtid),
        __ptr__(last),
        __ptr__(lower),
        __ptr__(upper),
        __ptr__(stride),
    )
    return (
        bool(more),
        bool(last),
        range(loop._get(lower), loop._get(upper + 1), loop.step),
    )

</t>
<t tx="ekr.20230509052845.1402">def _dynamic_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_dispatch_fini_8(Ptr[Ident], i32)
    __kmpc_dispatch_fini_8(loc_ref, i32(gtid))

</t>
<t tx="ekr.20230509052845.1403">def _reduce(
    loc_ref: Ptr[Ident],
    gtid: int,
    reduce_data: T,
    reduce_func: cobj,
    lck: cobj,
    T: type,
):
    from internal.gc import sizeof

    from C import __kmpc_reduce(Ptr[Ident], i32, i32, int, cobj, cobj, cobj) -&gt; i32
    num_vars = staticlen(reduce_data)
    reduce_size = sizeof(T)
    return int(
        __kmpc_reduce(
            loc_ref,
            i32(gtid),
            i32(num_vars),
            reduce_size,
            __ptr__(reduce_data).as_byte(),
            reduce_func,
            lck,
        )
    )

</t>
<t tx="ekr.20230509052845.1404">def _end_reduce(loc_ref: Ptr[Ident], gtid: int, lck: cobj):
    from C import __kmpc_end_reduce(Ptr[Ident], i32, cobj)
    __kmpc_end_reduce(loc_ref, i32(gtid), lck)

</t>
<t tx="ekr.20230509052845.1405">def _reduce_nowait(
    loc_ref: Ptr[Ident],
    gtid: int,
    reduce_data: T,
    reduce_func: cobj,
    lck: Ptr[Lock],
    T: type,
):
    from internal.gc import sizeof

    from C import __kmpc_reduce_nowait(Ptr[Ident], i32, i32, int, cobj, cobj, Ptr[Lock]) -&gt; i32
    num_vars = staticlen(reduce_data)
    reduce_size = sizeof(T)
    return int(
        __kmpc_reduce_nowait(
            loc_ref,
            i32(gtid),
            i32(num_vars),
            reduce_size,
            __ptr__(reduce_data).as_byte(),
            reduce_func,
            lck,
        )
    )

</t>
<t tx="ekr.20230509052845.1406">def _end_reduce_nowait(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_end_reduce_nowait(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_end_reduce_nowait(loc_ref, i32(gtid), lck)

</t>
<t tx="ekr.20230509052845.1407">def _taskred_init(loc_ref: Ptr[Ident], gtid: int, num: int, data):
    from C import __kmpc_taskred_modifier_init(Ptr[Ident], i32, i32, i32, cobj) -&gt; cobj
    return __kmpc_taskred_modifier_init(loc_ref, i32(gtid), i32(0), i32(num), data.as_byte())

</t>
<t tx="ekr.20230509052845.1408">def _taskred_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_task_reduction_modifier_fini(Ptr[Ident], i32, i32)
    __kmpc_task_reduction_modifier_fini(loc_ref, i32(gtid), i32(0))

</t>
<t tx="ekr.20230509052845.1409"># add tskgrp arg?
def _taskred_data(gtid: int, data):
    from C import __kmpc_task_reduction_get_th_data(i32, cobj, cobj) -&gt; cobj
    T = type(data)
    return T(__kmpc_task_reduction_get_th_data(i32(gtid), cobj(), data.as_byte()))

</t>
<t tx="ekr.20230509052845.141">def add(self, pos):
    self.empty_pos[pos] = len(self.empties)
    self.empties.append(pos)

</t>
<t tx="ekr.20230509052845.1410">def _fork_call(microtask: cobj, args):
    from C import __kmpc_fork_call(Ptr[Ident], i32, cobj, ...)
    loc_ref = _default_loc()  # TODO: pass real loc?
    __kmpc_fork_call(loc_ref, i32(1), microtask, __ptr__(args))

</t>
<t tx="ekr.20230509052845.1411">def _static_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @others
    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    static_loop_loc_ref = _static_loop_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()

    last, subloop, stride = _static_init(
        static_loop_loc_ref, gtid, schedtype=schedule, loop=loop, incr=1, chunk=1
    )
    i = subloop.start
    stop = min(subloop.stop, loop.stop) if step &gt;= 0 else max(subloop.stop, loop.stop)

    while (step &gt;= 0 and i &lt; stop) or (step &lt; 0 and i &gt; stop):
        _loop_body_stub(i, extra)
        i += step
    _static_fini(static_loop_loc_ref, gtid)

    if last:
        _loop_shared_updates(extra)

    _loop_reductions(extra)

</t>
<t tx="ekr.20230509052845.1412">@nonpure
def _loop_step():
    return 1

</t>
<t tx="ekr.20230509052845.1413">@nonpure
def _loop_loc_and_gtid(
    loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
):
    pass

</t>
<t tx="ekr.20230509052845.1414">@nonpure
def _loop_body_stub(i, args):
    pass

</t>
<t tx="ekr.20230509052845.1415">@nonpure
def _loop_schedule():
    return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

</t>
<t tx="ekr.20230509052845.1416">@nonpure
def _loop_shared_updates(args):
    pass

</t>
<t tx="ekr.20230509052845.1417">@nonpure
def _loop_reductions(args):
    pass

</t>
<t tx="ekr.20230509052845.1418">def _static_chunked_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @others
    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    static_loop_loc_ref = _static_loop_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()

    last, subloop, stride = _static_init(
        static_loop_loc_ref, gtid, schedtype=schedule, loop=loop, incr=1, chunk=chunk
    )
    start = subloop.start
    stop = min(subloop.stop, loop.stop) if step &gt;= 0 else max(subloop.stop, loop.stop)

    while (step &gt;= 0 and start &lt; loop.stop) or (step &lt; 0 and start &gt; loop.stop):
        i = start
        while (step &gt;= 0 and i &lt; stop) or (step &lt; 0 and i &gt; stop):
            _loop_body_stub(i, extra)
            i += step

        start += stride * step
        stop += stride * step
        stop = min(stop, loop.stop) if step &gt;= 0 else max(stop, loop.stop)
    _static_fini(static_loop_loc_ref, gtid)

    if last:
        _loop_shared_updates(extra)

    _loop_reductions(extra)

</t>
<t tx="ekr.20230509052845.1419">@nonpure
def _loop_step():
    return 1

</t>
<t tx="ekr.20230509052845.142">def remove(self, pos):
    self.set(self.empty_pos[pos], self.empties[len(self.empties) - 1])
    self.empties.pop()

</t>
<t tx="ekr.20230509052845.1420">@nonpure
def _loop_loc_and_gtid(
    loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
):
    pass

</t>
<t tx="ekr.20230509052845.1421">@nonpure
def _loop_body_stub(i, args):
    pass

</t>
<t tx="ekr.20230509052845.1422">@nonpure
def _loop_schedule():
    return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

</t>
<t tx="ekr.20230509052845.1423">@nonpure
def _loop_shared_updates(args):
    pass

</t>
<t tx="ekr.20230509052845.1424">@nonpure
def _loop_reductions(args):
    pass

</t>
<t tx="ekr.20230509052845.1425">def _dynamic_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @others
    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()
    ordered = _loop_ordered()

    _dynamic_init(loc_ref, gtid, schedtype=schedule, loop=loop, chunk=chunk)
    while True:
        more, last, subloop = _dynamic_next(loc_ref, gtid, loop)
        if not more:
            break
        i = subloop.start
        while (step &gt;= 0 and i &lt; subloop.stop) or (step &lt; 0 and i &gt; subloop.stop):
            _loop_body_stub(i, extra)
            i += step
            if ordered:
                _dynamic_fini(loc_ref, gtid)
        if last:
            _loop_shared_updates(extra)

    _loop_reductions(extra)

</t>
<t tx="ekr.20230509052845.1426">@nonpure
def _loop_step():
    return 1

</t>
<t tx="ekr.20230509052845.1427">@nonpure
def _loop_loc_and_gtid(
    loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
):
    pass

</t>
<t tx="ekr.20230509052845.1428">@nonpure
def _loop_body_stub(i, args):
    pass

</t>
<t tx="ekr.20230509052845.1429">@nonpure
def _loop_schedule():
    return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

</t>
<t tx="ekr.20230509052845.143">def set(self, i, pos):
    self.empties[i] = pos
    self.empty_pos[pos] = i


</t>
<t tx="ekr.20230509052845.1430">@nonpure
def _loop_shared_updates(args):
    pass

</t>
<t tx="ekr.20230509052845.1431">@nonpure
def _loop_reductions(args):
    pass

</t>
<t tx="ekr.20230509052845.1432">@nonpure
def _loop_ordered():
    return False

</t>
<t tx="ekr.20230509052845.1433"># P = privates; tuple of types
# S = shareds; tuple of pointers
def _spawn_and_run_task(
    loc_ref: Ptr[Ident], gtid: int, routine: cobj, priv: P, shared: S, P: type, S: type
):
    from internal.gc import sizeof

    TaskThunk = TaskWithPrivates[P]
    flags = 1
    size_of_kmp_task_t = sizeof(TaskThunk)
    size_of_privs = sizeof(P)
    size_of_shareds = sizeof(S)
    loc_ref = _default_loc()

    task = Ptr[TaskThunk](
        _task_alloc(
            loc_ref, gtid, flags, size_of_kmp_task_t, size_of_shareds, Routine(routine)
        )
    )
    if staticlen(shared) != 0:
        shared_ptr = task[0].task.shareds
        str.memcpy(shared_ptr, __ptr__(shared).as_byte(), size_of_shareds)
    if staticlen(priv) != 0:
        priv_ptr = task.as_byte() + sizeof(Task)
        str.memcpy(priv_ptr, __ptr__(priv).as_byte(), size_of_privs)

    _task_run(loc_ref, gtid, task.as_byte())

</t>
<t tx="ekr.20230509052845.1434"># Note: this is different than OpenMP's "taskloop" -- this template simply
# spawns a new task for each loop iteration.
def _task_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @others
    iterable, priv, shared = args[0]
    P = type(priv)
    S = type(shared)

    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)

    _taskred_setup(shared)

    if _single_begin(loc_ref, gtid) != 0:
        _taskgroup_begin(loc_ref, gtid)
        try:
            for i in iterable:
                priv_fixed, shared_fixed = _fix_privates_and_shareds(i, priv, shared)
                _spawn_and_run_task(
                    loc_ref, gtid, _routine_stub(P=P, S=S, ...).__raw__(), priv_fixed, shared_fixed
                )
        finally:
            _taskgroup_end(loc_ref, gtid)
            _single_end(loc_ref, gtid)

    _taskred_finish()
    _loop_reductions(shared)
    _barrier(loc_ref, gtid)

</t>
<t tx="ekr.20230509052845.1435">def _routine_stub(gtid: i32, data: cobj, P: type, S: type):
    @nonpure
    def _task_loop_body_stub(gtid: int, priv, shared):
        pass

    task = Ptr[TaskWithPrivates[P]](data)[0]
    priv = task.data
    gtid64 = int(gtid)
    if staticlen(S()) != 0:
        shared = Ptr[S](task.task.shareds)[0]
        _task_loop_body_stub(gtid64, priv, shared)
    else:
        shared = ()
        _task_loop_body_stub(gtid64, priv, shared)
    return i32(0)

</t>
<t tx="ekr.20230509052845.1436">@nonpure
def _loop_loc_and_gtid(
    loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
):
    pass

</t>
<t tx="ekr.20230509052845.1437">@nonpure
def _fix_privates_and_shareds(i, priv, shared):
    return priv, shared

</t>
<t tx="ekr.20230509052845.1438">@nonpure
def _taskred_setup(args):
    pass

</t>
<t tx="ekr.20230509052845.1439">@nonpure
def _taskred_finish():
    pass

</t>
<t tx="ekr.20230509052845.144">class ZobristHash:

    @others
</t>
<t tx="ekr.20230509052845.1440">@nonpure
def _loop_reductions(args):
    pass

</t>
<t tx="ekr.20230509052845.1441">@pure
def get_num_threads():
    from C import omp_get_num_threads() -&gt; i32
    return int(omp_get_num_threads())

</t>
<t tx="ekr.20230509052845.1442">@pure
def get_thread_num():
    from C import omp_get_thread_num() -&gt; i32
    return int(omp_get_thread_num())

</t>
<t tx="ekr.20230509052845.1443">@pure
def get_max_threads():
    from C import omp_get_max_threads() -&gt; i32
    return int(omp_get_max_threads())

</t>
<t tx="ekr.20230509052845.1444">@pure
def get_num_procs():
    from C import omp_get_num_procs() -&gt; i32
    return int(omp_get_num_procs())

</t>
<t tx="ekr.20230509052845.1445">def set_num_threads(num_threads: int):
    from C import omp_set_num_threads(i32)
    omp_set_num_threads(i32(num_threads))

</t>
<t tx="ekr.20230509052845.1446">@pure
def in_parallel():
    from C import omp_in_parallel() -&gt; i32
    return bool(omp_in_parallel())

</t>
<t tx="ekr.20230509052845.1447">def set_dynamic(dynamic_threads: bool = True):
    from C import omp_set_dynamic(i32)
    omp_set_dynamic(i32(1 if dynamic_threads else 0))

</t>
<t tx="ekr.20230509052845.1448">@pure
def get_dynamic():
    from C import omp_get_dynamic() -&gt; i32
    return bool(omp_get_dynamic())

</t>
<t tx="ekr.20230509052845.1449">@pure
def get_cancellation():
    from C import omp_get_cancellation() -&gt; i32
    return bool(omp_get_cancellation())

</t>
<t tx="ekr.20230509052845.145">def __init__(self, board):
    self.board = board
    self.hash_set = set()
    self.hash = 0
    for square in self.board.squares:
        self.hash ^= square.zobrist_strings[EMPTY]
    self.hash_set.clear()
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509052845.1450">def set_schedule(kind: str, chunk_size: int = 0):
    from C import omp_set_schedule(i32, i32)
    if kind == "static":
        omp_set_schedule(i32(1), i32(chunk_size))
    elif kind == "dynamic":
        omp_set_schedule(i32(2), i32(chunk_size))
    elif kind == "guided":
        omp_set_schedule(i32(3), i32(chunk_size))
    elif kind == "auto":
        if chunk_size != 0:
            raise ValueError("cannot specify chunk size for auto schedule")
        omp_set_schedule(i32(4), i32(chunk_size))
    else:
        raise ValueError(
            "invalid schedule kind; valid ones are: 'static', 'dynamic', 'guided', 'auto'"
        )

</t>
<t tx="ekr.20230509052845.1451">@pure
def get_schedule():
    from C import omp_get_schedule(Ptr[i32], Ptr[i32])
    kind_code = i32(0)
    chunk_size = i32(0)
    omp_get_schedule(__ptr__(kind_code), __ptr__(chunk_size))
    idx = int(kind_code)
    kind = (
        ("static", "dynamic", "guided", "auto")[idx - 1] if 1 &lt; idx &lt;= 4 else "unknown"
    )
    return kind, int(chunk_size)

</t>
<t tx="ekr.20230509052845.1452">@pure
def get_thread_limit():
    from C import omp_get_thread_limit() -&gt; i32
    return int(omp_get_thread_limit())

</t>
<t tx="ekr.20230509052845.1453">def set_max_active_levels(max_levels: int):
    from C import omp_set_max_active_levels(i32)
    omp_set_max_active_levels(i32(max_levels))

</t>
<t tx="ekr.20230509052845.1454">@pure
def get_max_active_levels():
    from C import omp_get_max_active_levels() -&gt; i32
    return int(omp_get_max_active_levels())

</t>
<t tx="ekr.20230509052845.1455">@pure
def get_level():
    from C import omp_get_level() -&gt; i32
    return int(omp_get_level())

</t>
<t tx="ekr.20230509052845.1456">@pure
def get_ancestor_thread_num(level: int):
    from C import omp_get_ancestor_thread_num(i32) -&gt; i32
    return int(omp_get_ancestor_thread_num(i32(level)))

</t>
<t tx="ekr.20230509052845.1457">@pure
def get_team_size(level: int):
    from C import omp_get_team_size(i32) -&gt; i32
    return int(omp_get_team_size(i32(level)))

</t>
<t tx="ekr.20230509052845.1458">@pure
def get_active_level():
    from C import omp_get_active_level() -&gt; i32
    return int(omp_get_active_level())

</t>
<t tx="ekr.20230509052845.1459">@pure
def in_final():
    from C import omp_in_final() -&gt; i32
    return bool(omp_in_final())

</t>
<t tx="ekr.20230509052845.146">def update(self, square, color):
    self.hash ^= square.zobrist_strings[square.color]
    self.hash ^= square.zobrist_strings[color]

</t>
<t tx="ekr.20230509052845.1460">@pure
def get_proc_bind():
    from C import omp_get_proc_bind() -&gt; i32
    result = int(omp_get_proc_bind())
    if result &lt; 0 or result &gt; 4:
        return "unknown"
    return ("false", "true", "master", "close", "spread")[result]

</t>
<t tx="ekr.20230509052845.1461">def set_default_device(device_num: int):
    from C import omp_set_default_device(i32)
    omp_set_default_device(i32(device_num))

</t>
<t tx="ekr.20230509052845.1462">@pure
def get_default_device():
    from C import omp_get_default_device() -&gt; i32
    return int(omp_get_default_device())

</t>
<t tx="ekr.20230509052845.1463">@pure
def get_num_devices():
    from C import omp_get_num_devices() -&gt; i32
    return int(omp_get_num_devices())

</t>
<t tx="ekr.20230509052845.1464">@pure
def get_num_teams():
    from C import omp_get_num_teams() -&gt; i32
    return int(omp_get_num_teams())

</t>
<t tx="ekr.20230509052845.1465">@pure
def get_team_num():
    from C import omp_get_team_num() -&gt; i32
    return int(omp_get_team_num())

</t>
<t tx="ekr.20230509052845.1466">@pure
def is_initial_device():
    from C import omp_is_initial_device() -&gt; i32
    return bool(omp_is_initial_device())

</t>
<t tx="ekr.20230509052845.1467">@pure
def get_wtime():
    from C import omp_get_wtime() -&gt; float
    return omp_get_wtime()

</t>
<t tx="ekr.20230509052845.1468">@pure
def get_wtick():
    from C import omp_get_wtick() -&gt; float
    return omp_get_wtick()

</t>
<t tx="ekr.20230509052845.1469">def single(func):
    @others
    return _wrapper

</t>
<t tx="ekr.20230509052845.147">def add(self):
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509052845.1470">def _wrapper(*args, **kwargs):
    gtid = get_thread_num()
    loc = _default_loc()
    if _single_begin(loc, gtid) != 0:
        try:
            func(*args, **kwargs)
        finally:
            _single_end(loc, gtid)

</t>
<t tx="ekr.20230509052845.1471">def master(func):
    @others
    return _wrapper

</t>
<t tx="ekr.20230509052845.1472">def _wrapper(*args, **kwargs):
    gtid = get_thread_num()
    loc = _default_loc()
    if _master_begin(loc, gtid) != 0:
        try:
            func(*args, **kwargs)
        finally:
            _master_end(loc, gtid)

</t>
<t tx="ekr.20230509052845.1473">def ordered(func):
    @others
    return _wrapper

</t>
<t tx="ekr.20230509052845.1474">def _wrapper(*args, **kwargs):
    gtid = get_thread_num()
    loc = _default_loc()
    if _ordered_begin(loc, gtid) != 0:
        try:
            func(*args, **kwargs)
        finally:
            _ordered_end(loc, gtid)

</t>
<t tx="ekr.20230509052845.1475">_default_lock = Lock()

</t>
<t tx="ekr.20230509052845.1476">def critical(func):
    @others
    return _wrapper

</t>
<t tx="ekr.20230509052845.1477">def _wrapper(*args, **kwargs):
    gtid = get_thread_num()
    loc = _default_loc()
    _critical_begin(loc, gtid, __ptr__(_default_lock))
    try:
        func(*args, **kwargs)
    finally:
        _critical_end(loc, gtid, __ptr__(_default_lock))

</t>
<t tx="ekr.20230509052845.1478">def _push_num_threads(num_threads: int):
    from C import __kmpc_push_num_threads(Ptr[Ident], i32, i32)
    gtid = get_thread_num()
    loc = _default_loc()
    __kmpc_push_num_threads(loc, i32(gtid), i32(num_threads))

</t>
<t tx="ekr.20230509052845.1479">@llvm
def _atomic_int_add(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw add ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.148">def dupe(self):
    return self.hash in self.hash_set


</t>
<t tx="ekr.20230509052845.1480">def _atomic_int_mul(a: Ptr[int], b: int):
    from C import __kmpc_atomic_fixed8_mul(Ptr[Ident], i32, Ptr[int], int)
    __kmpc_atomic_fixed8_mul(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1481">@llvm
def _atomic_int_and(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw and ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.1482">@llvm
def _atomic_int_or(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw or ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.1483">@llvm
def _atomic_int_xor(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw xor ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.1484">@llvm
def _atomic_int_min(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw min ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.1485">@llvm
def _atomic_int_max(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw max ptr %a, i64 %b monotonic
    ret {} {}

</t>
<t tx="ekr.20230509052845.1486">def _atomic_float_add(a: Ptr[float], b: float) -&gt; None:
    from C import __kmpc_atomic_float8_add(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_add(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1487">def _atomic_float_mul(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_mul(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_mul(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1488">def _atomic_float_min(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_min(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_min(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1489">def _atomic_float_max(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_max(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_max(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.149">class Board:

    @others
</t>
<t tx="ekr.20230509052845.1490">def _atomic_float32_add(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_add(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_add(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1491">def _atomic_float32_mul(a: Ptr[float32], b: float32):
    from C import __kmpc_atomic_float4_mul(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_mul(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1492">def _atomic_float32_min(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_min(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_min(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1493">def _atomic_float32_max(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_max(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_max(_default_loc(), i32(0), a, b)

</t>
<t tx="ekr.20230509052845.1494">def _range_len(start: int, stop: int, step: int):
    if step &gt; 0 and start &lt; stop:
        return 1 + (stop - 1 - start) // step
    elif step &lt; 0 and start &gt; stop:
        return 1 + (start - 1 - stop) // (-step)
    else:
        return 0

</t>
<t tx="ekr.20230509052845.1495">def for_par(
    num_threads: int = -1,
    chunk_size: int = -1,
    schedule: Static[str] = "static",
    ordered: Static[int] = False,
    collapse: Static[int] = 0,
    gpu: Static[int] = False,
):
    pass
</t>
<t tx="ekr.20230509052845.1496">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

lt = lambda a, b: a &lt; b
le = lambda a, b: a &lt;= b
eq = lambda a, b: a == b
ne = lambda a, b: a != b
gt = lambda a, b: a &gt; b
ge = lambda a, b: a &gt;= b
__lt__ = lt
__le__ = le
__eq__ = eq
__ne__ = ne
__gt__ = gt
__ge__ = ge

@others
__ixor__ = ixor
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1497">def not_(a) -&gt; bool:
    if hasattr(a, "__bool__"):
        return not bool(a)
    elif hasattr(a, "__len__"):
        return len(a) == 0
    else:
        compile_error("argument has no __bool__ or __len__ methods")

</t>
<t tx="ekr.20230509052845.1498">def truth(a) -&gt; bool:
    return bool(a)

</t>
<t tx="ekr.20230509052845.1499">def is_(a, b) -&gt; bool:
    return a is b

</t>
<t tx="ekr.20230509052845.15">def make_check(itde, make=make_tree, check=check_tree):
    i, d = itde
    return check(make(d))

</t>
<t tx="ekr.20230509052845.150">def __init__(self):
    self.squares = [Square(self, pos) for pos in range(SIZE * SIZE)]
    for square in self.squares:
        square.set_neighbours()
    self.reset()

</t>
<t tx="ekr.20230509052845.1500">def is_not(a, b) -&gt; bool:
    return a is not b

</t>
<t tx="ekr.20230509052845.1501">def abs(a):
    return a.__abs__()

</t>
<t tx="ekr.20230509052845.1502">__abs__ = abs

</t>
<t tx="ekr.20230509052845.1503">def add(a, b):
    return a + b

</t>
<t tx="ekr.20230509052845.1504">__add__ = add

</t>
<t tx="ekr.20230509052845.1505">def and_(a, b):
    return a &amp; b

</t>
<t tx="ekr.20230509052845.1506">__and__ = and_

</t>
<t tx="ekr.20230509052845.1507">def floordiv(a, b):
    return a // b

</t>
<t tx="ekr.20230509052845.1508">__floordiv__ = floordiv

</t>
<t tx="ekr.20230509052845.1509">def index(a):
    return a.__index__()

</t>
<t tx="ekr.20230509052845.151">def reset(self):
    for square in self.squares:
        square.color = EMPTY
        square.used = False
    self.emptyset = EmptySet(self)
    self.zobrist = ZobristHash(self)
    self.color = BLACK
    self.finished = False
    self.lastmove = -2
    self.history = []
    self.white_dead = 0
    self.black_dead = 0

</t>
<t tx="ekr.20230509052845.1510">__index__ = index

</t>
<t tx="ekr.20230509052845.1511">def inv(a):
    return ~a

</t>
<t tx="ekr.20230509052845.1512">invert = inv
__inv__ = inv
__invert__ = inv

</t>
<t tx="ekr.20230509052845.1513">def lshift(a, b):
    return a &lt;&lt; b

</t>
<t tx="ekr.20230509052845.1514">__lshift__ = lshift

</t>
<t tx="ekr.20230509052845.1515">def mod(a, b):
    return a % b

</t>
<t tx="ekr.20230509052845.1516">__mod__ = mod

</t>
<t tx="ekr.20230509052845.1517">def mul(a, b):
    return a * b

</t>
<t tx="ekr.20230509052845.1518">__mul__ = mul

</t>
<t tx="ekr.20230509052845.1519">def matmul(a, b):
    return a @ b

</t>
<t tx="ekr.20230509052845.152">def move(self, pos):
    square = self.squares[pos]
    if pos != PASS:
        square.move(self.color)
        self.emptyset.remove(square.pos)
    elif self.lastmove == PASS:
        self.finished = True
    if self.color == BLACK:
        self.color = WHITE
    else:
        self.color = BLACK
    self.lastmove = pos
    self.history.append(pos)

</t>
<t tx="ekr.20230509052845.1520">__matmul__ = matmul

</t>
<t tx="ekr.20230509052845.1521">def neg(a):
    return -a

</t>
<t tx="ekr.20230509052845.1522">__neg__ = neg

</t>
<t tx="ekr.20230509052845.1523">def or_(a, b):
    return a | b

</t>
<t tx="ekr.20230509052845.1524">__or__ = or_

</t>
<t tx="ekr.20230509052845.1525">def pos(a):
    return +a

</t>
<t tx="ekr.20230509052845.1526">__pos__ = pos

</t>
<t tx="ekr.20230509052845.1527">def pow(a, b):
    return a ** b

</t>
<t tx="ekr.20230509052845.1528">__pow__ = pow

</t>
<t tx="ekr.20230509052845.1529">def rshift(a, b):
    return a &gt;&gt; b

</t>
<t tx="ekr.20230509052845.153">def random_move(self):
    return self.emptyset.random_choice()

</t>
<t tx="ekr.20230509052845.1530">__rshift__ = rshift

</t>
<t tx="ekr.20230509052845.1531">def sub(a, b):
    return a - b

</t>
<t tx="ekr.20230509052845.1532">__sub__ = sub

</t>
<t tx="ekr.20230509052845.1533">def truediv(a, b):
    return a / b

</t>
<t tx="ekr.20230509052845.1534">__truediv__ = truediv

</t>
<t tx="ekr.20230509052845.1535">def xor(a, b):
    return a ^ b

</t>
<t tx="ekr.20230509052845.1536">__xor__ = xor

</t>
<t tx="ekr.20230509052845.1537">def concat(a, b):
    return a + b

</t>
<t tx="ekr.20230509052845.1538">__concat__ = concat

</t>
<t tx="ekr.20230509052845.1539">def contains(a, b):
    return b in a  # intentionally reversed

</t>
<t tx="ekr.20230509052845.154">def useful_fast(self, square):
    if not square.used:
        for neighbour in square.neighbours:
            if neighbour.color == EMPTY:
                return True
    return False

</t>
<t tx="ekr.20230509052845.1540">__contains__ = contains

</t>
<t tx="ekr.20230509052845.1541">def countOf(a, b):
    n = 0
    for x in a:
        if x == b:
            n += 1
    return n

</t>
<t tx="ekr.20230509052845.1542">def delitem(a, b):
    del a[b]

</t>
<t tx="ekr.20230509052845.1543">__delitem__ = delitem

</t>
<t tx="ekr.20230509052845.1544">def getitem(a, b):
    return a[b]

</t>
<t tx="ekr.20230509052845.1545">__getitem__ = getitem

</t>
<t tx="ekr.20230509052845.1546">def indexOf(a, b):
    n = 0
    for x in a:
        if x == b:
            return n
        n += 1
    raise ValueError(f"sequence.index(x): x not in sequence")

</t>
<t tx="ekr.20230509052845.1547">def setitem(a, b, c):
    a[b] = c

</t>
<t tx="ekr.20230509052845.1548">__setitem__ = setitem

</t>
<t tx="ekr.20230509052845.1549">def length_hint(a, default=0):
    if hasattr(a, "__len__"):
        return len(a)
    elif hasattr(a, "__length_hint__"):
        return a.__length_hint__()
    else:
        return default

</t>
<t tx="ekr.20230509052845.155">def useful(self, pos):
    global TIMESTAMP
    TIMESTAMP += 1
    square = self.squares[pos]
    if self.useful_fast(square):
        return True
    old_hash = self.zobrist.hash
    self.zobrist.update(square, self.color)
    empties = opps = weak_opps = neighs = weak_neighs = 0
    for neighbour in square.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            empties += 1
            continue
        neighbour_ref = neighbour.find()
        if neighbour_ref.timestamp != TIMESTAMP:
            if neighcolor == self.color:
                neighs += 1
            else:
                opps += 1
            neighbour_ref.timestamp = TIMESTAMP
            neighbour_ref.temp_ledges = neighbour_ref.ledges
        neighbour_ref.temp_ledges -= 1
        if neighbour_ref.temp_ledges == 0:
            if neighcolor == self.color:
                weak_neighs += 1
            else:
                weak_opps += 1
                neighbour_ref.remove(neighbour_ref, update=False)
    dupe = self.zobrist.dupe()
    self.zobrist.hash = old_hash
    strong_neighs = neighs - weak_neighs
    strong_opps = opps - weak_opps
    return not dupe and \
        (empties or weak_opps or (strong_neighs and (strong_opps or weak_neighs)))

</t>
<t tx="ekr.20230509052845.1550">def attrgetter(attr: Static[str]):
    def getter(obj):
        return getattr(obj, attr)
    return getter

</t>
<t tx="ekr.20230509052845.1551">def itemgetter(*items):
    if staticlen(items) == 1:
        item = items[0]

        def g(obj):
            return obj[item]

        return g
    else:

        def g(obj):
            return tuple(obj[item] for item in items)

        return g

</t>
<t tx="ekr.20230509052845.1552">def methodcaller(name: Static[str], *args, **kwargs):
    def caller(obj):
        return getattr(obj, name)(*args, **kwargs)
    return caller

</t>
<t tx="ekr.20230509052845.1553">def iadd(a, b):
    a += b
    return a

</t>
<t tx="ekr.20230509052845.1554">__iadd__ = iadd

</t>
<t tx="ekr.20230509052845.1555">def iand(a, b):
    a &amp;= b
    return a

</t>
<t tx="ekr.20230509052845.1556">__iand__ = iand

</t>
<t tx="ekr.20230509052845.1557">def iconcat(a, b):
    a += b
    return a

</t>
<t tx="ekr.20230509052845.1558">__iconcat__ = iconcat

</t>
<t tx="ekr.20230509052845.1559">def ifloordiv(a, b):
    a //= b
    return a

</t>
<t tx="ekr.20230509052845.156">def useful_moves(self):
    return [pos for pos in self.emptyset.empties if self.useful(pos)]

</t>
<t tx="ekr.20230509052845.1560">__ifloordiv__ = ifloordiv

</t>
<t tx="ekr.20230509052845.1561">def ilshift(a, b):
    a &lt;&lt;= b
    return a

</t>
<t tx="ekr.20230509052845.1562">__ilshift__ = ilshift

</t>
<t tx="ekr.20230509052845.1563">def imod(a, b):
    a %= b
    return a

</t>
<t tx="ekr.20230509052845.1564">__imod__ = imod

</t>
<t tx="ekr.20230509052845.1565">def imul(a, b):
    a *= b
    return a

</t>
<t tx="ekr.20230509052845.1566">__imul__ = imul

</t>
<t tx="ekr.20230509052845.1567">def imatmul(a, b):
    a @= b
    return a

</t>
<t tx="ekr.20230509052845.1568">__imatmul__ = imatmul

</t>
<t tx="ekr.20230509052845.1569">def ior(a, b):
    a |= b
    return a

</t>
<t tx="ekr.20230509052845.157">def replay(self, history):
    for pos in history:
        self.move(pos)

</t>
<t tx="ekr.20230509052845.1570">__ior__ = ior

</t>
<t tx="ekr.20230509052845.1571">def ipow(a, b):
    a **= b
    return a

</t>
<t tx="ekr.20230509052845.1572">__ipow__ = ipow

</t>
<t tx="ekr.20230509052845.1573">def irshift(a, b):
    a &gt;&gt;= b
    return a

</t>
<t tx="ekr.20230509052845.1574">__irshift__ = irshift

</t>
<t tx="ekr.20230509052845.1575">def isub(a, b):
    a -= b
    return a

</t>
<t tx="ekr.20230509052845.1576">__isub__ = isub

</t>
<t tx="ekr.20230509052845.1577">def itruediv(a, b):
    a /= b
    return a

</t>
<t tx="ekr.20230509052845.1578">__itruediv__ = itruediv

</t>
<t tx="ekr.20230509052845.1579">def ixor(a, b):
    a ^= b
    return a

</t>
<t tx="ekr.20230509052845.158">def score(self, color):
    if color == WHITE:
        count = KOMI + self.black_dead
    else:
        count = self.white_dead
    for square in self.squares:
        squarecolor = square.color
        if squarecolor == color:
            count += 1
        elif squarecolor == EMPTY:
            surround = 0
            for neighbour in square.neighbours:
                if neighbour.color == color:
                    surround += 1
            if surround == len(square.neighbours):
                count += 1
    return count

</t>
<t tx="ekr.20230509052845.1580">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.file import _gz_errcheck
from internal.gc import sizeof, atomic

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1581">def pickle(x: T, jar: Jar, T: type):
    x.__pickle__(jar)

</t>
<t tx="ekr.20230509052845.1582">def unpickle(jar: Jar, T: type) -&gt; T:
    return T.__unpickle__(jar)

</t>
<t tx="ekr.20230509052845.1583">def dump(x: T, f, T: type):
    x.__pickle__(f.fp)

</t>
<t tx="ekr.20230509052845.1584">def load(f, T: type) -&gt; T:
    return T.__unpickle__(f.fp)

</t>
<t tx="ekr.20230509052845.1585">def _write_raw(jar: Jar, p: cobj, n: int):
    LIMIT = 0x7FFFFFFF
    while n &gt; 0:
        b = n if n &lt; LIMIT else LIMIT
        status = int(_C.gzwrite(jar, p, u32(b)))
        if status != b:
            _gz_errcheck(jar)
            raise IOError(f"pickle error: gzwrite returned {status}")
        p += b
        n -= b

</t>
<t tx="ekr.20230509052845.1586">def _read_raw(jar: Jar, p: cobj, n: int):
    LIMIT = 0x7FFFFFFF
    while n &gt; 0:
        b = n if n &lt; LIMIT else LIMIT
        status = int(_C.gzread(jar, p, u32(b)))
        if status != b:
            _gz_errcheck(jar)
            raise IOError(f"pickle error: gzread returned {status}")
        p += b
        n -= b

</t>
<t tx="ekr.20230509052845.1587">def _write(jar: Jar, x: T, T: type):
    y = __ptr__(x)
    _write_raw(jar, y.as_byte(), sizeof(T))

</t>
<t tx="ekr.20230509052845.1588">def _read(jar: Jar, T: type) -&gt; T:
    x = T()
    y = __ptr__(x)
    _read_raw(jar, y.as_byte(), sizeof(T))
    return x

</t>
<t tx="ekr.20230509052845.1589"># Extend core types to allow pickling

</t>
<t tx="ekr.20230509052845.159">def check(self):
    for square in self.squares:
        if square.color == EMPTY:
            continue

        members1 = set([square])
        changed = True
        while changed:
            changed = False
            for member in members1.copy():
                for neighbour in member.neighbours:
                    if neighbour.color == square.color and neighbour not in members1:
                        changed = True
                        members1.add(neighbour)
        ledges1 = 0
        for member in members1:
            for neighbour in member.neighbours:
                if neighbour.color == EMPTY:
                    ledges1 += 1

        root = square.find()

        # print 'members1', square, root, members1
        # print 'ledges1', square, ledges1

        members2 = set()
        for square2 in self.squares:
            if square2.color != EMPTY and square2.find() == root:
                members2.add(square2)

        ledges2 = root.ledges
        # print 'members2', square, root, members1
        # print 'ledges2', square, ledges2

        assert members1 == members2
        assert ledges1 == ledges2, ('ledges differ at %r: %d %d' % (
            square, ledges1, ledges2))

        set(self.emptyset.empties)

        empties2 = set()
        for square in self.squares:
            if square.color == EMPTY:
                empties2.add(square.pos)

</t>
<t tx="ekr.20230509052845.1590">@extend
class int:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; int:
        return _read(jar, int)

</t>
<t tx="ekr.20230509052845.1591">@extend
class Int:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; Int[N]:
        return _read(jar, Int[N])

</t>
<t tx="ekr.20230509052845.1592">@extend
class UInt:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; UInt[N]:
        return _read(jar, UInt[N])

</t>
<t tx="ekr.20230509052845.1593">@extend
class float:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; float:
        return _read(jar, float)

</t>
<t tx="ekr.20230509052845.1594">@extend
class float32:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; float32:
        return _read(jar, float32)

</t>
<t tx="ekr.20230509052845.1595">@extend
class bool:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; bool:
        return _read(jar, bool)

</t>
<t tx="ekr.20230509052845.1596">@extend
class byte:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; byte:
        return _read(jar, byte)

</t>
<t tx="ekr.20230509052845.1597">@extend
class str:
    @others
</t>
<t tx="ekr.20230509052845.1598">def __pickle__(self, jar: Jar):
    _write(jar, self.len)
    _write_raw(jar, self.ptr, self.len)

</t>
<t tx="ekr.20230509052845.1599">def __unpickle__(jar: Jar) -&gt; str:
    n = _read(jar, int)
    p = Ptr[byte](n)
    _read_raw(jar, p, n)
    return str(p, n)

</t>
<t tx="ekr.20230509052845.16">def get_argchunks(i, d, chunksize=5000):
    assert chunksize % 2 == 0
    chunk = []
    for k in range(1, i + 1):
        chunk.append((k, d))
        if len(chunk) == chunksize:
            yield chunk
            chunk = []
    if len(chunk) &gt; 0:
        yield chunk

</t>
<t tx="ekr.20230509052845.160">def __repr__(self):
    result = []
    for y in range(SIZE):
        start = to_pos(0, y)
        result.append(''.join(
            [SHOW[square.color] + ' ' for square in self.squares[start:start + SIZE]]))
    return '\n'.join(result)


</t>
<t tx="ekr.20230509052845.1600">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.1601">def __pickle__(self, jar: Jar):
    n = len(self)
    pickle(n, jar)
    if atomic(T):
        _write_raw(jar, (self.arr.ptr).as_byte(), n * sizeof(T))
    else:
        for i in range(n):
            pickle(self.arr[i], jar)

</t>
<t tx="ekr.20230509052845.1602">def __unpickle__(jar: Jar) -&gt; List[T]:
    n = unpickle(jar, int)
    arr = Array[T](n)
    if atomic(T):
        _read_raw(jar, (arr.ptr).as_byte(), n * sizeof(T))
    else:
        for i in range(n):
            arr[i] = unpickle(jar, T)
    return List[T](arr, n)

</t>
<t tx="ekr.20230509052845.1603">@extend
class DynamicTuple:
    @others
</t>
<t tx="ekr.20230509052845.1604">def __pickle__(self, jar: Jar):
    n = len(self)
    pickle(n, jar)
    if atomic(T):
        _write_raw(jar, (self._ptr).as_byte(), n * sizeof(T))
    else:
        for i in range(n):
            pickle(self._ptr[i], jar)

</t>
<t tx="ekr.20230509052845.1605">def __unpickle__(jar: Jar) -&gt; DynamicTuple[T]:
    n = unpickle(jar, int)
    p = Ptr[T](n)
    if atomic(T):
        _read_raw(jar, p.as_byte(), n * sizeof(T))
    else:
        for i in range(n):
            p[i] = unpickle(jar, T)
    return DynamicTuple[T](p, n)

</t>
<t tx="ekr.20230509052845.1606">@extend
class Dict:
    @others
</t>
<t tx="ekr.20230509052845.1607">def __pickle__(self, jar: Jar):
    import internal.khash as khash

    if atomic(K) and atomic(V):
        pickle(self._n_buckets, jar)
        pickle(self._size, jar)
        pickle(self._n_occupied, jar)
        pickle(self._upper_bound, jar)
        fsize = khash.__ac_fsize(self._n_buckets) if self._n_buckets &gt; 0 else 0
        _write_raw(jar, self._flags.as_byte(), fsize * sizeof(u32))
        _write_raw(jar, self._keys.as_byte(), self._n_buckets * sizeof(K))
        _write_raw(jar, self._vals.as_byte(), self._n_buckets * sizeof(V))
    else:
        pickle(self._n_buckets, jar)
        size = len(self)
        pickle(size, jar)

        for k, v in self.items():
            pickle(k, jar)
            pickle(v, jar)

</t>
<t tx="ekr.20230509052845.1608">def __unpickle__(jar: Jar) -&gt; Dict[K, V]:
    import internal.khash as khash

    d = {}
    if atomic(K) and atomic(V):
        n_buckets = unpickle(jar, int)
        size = unpickle(jar, int)
        n_occupied = unpickle(jar, int)
        upper_bound = unpickle(jar, int)
        fsize = khash.__ac_fsize(n_buckets) if n_buckets &gt; 0 else 0
        flags = Ptr[u32](fsize)
        keys = Ptr[K](n_buckets)
        vals = Ptr[V](n_buckets)
        _read_raw(jar, flags.as_byte(), fsize * sizeof(u32))
        _read_raw(jar, keys.as_byte(), n_buckets * sizeof(K))
        _read_raw(jar, vals.as_byte(), n_buckets * sizeof(V))

        d._n_buckets = n_buckets
        d._size = size
        d._n_occupied = n_occupied
        d._upper_bound = upper_bound
        d._flags = flags
        d._keys = keys
        d._vals = vals
    else:
        n_buckets = unpickle(jar, int)
        size = unpickle(jar, int)
        d.resize(n_buckets)
        i = 0
        while i &lt; size:
            k = unpickle(jar, K)
            v = unpickle(jar, V)
            d[k] = v
            i += 1
    return d

</t>
<t tx="ekr.20230509052845.1609">@extend
class Set:
    @others
</t>
<t tx="ekr.20230509052845.161">class UCTNode:

    @others
</t>
<t tx="ekr.20230509052845.1610">def __pickle__(self, jar: Jar):
    import internal.khash as khash

    if atomic(K):
        pickle(self._n_buckets, jar)
        pickle(self._size, jar)
        pickle(self._n_occupied, jar)
        pickle(self._upper_bound, jar)
        fsize = khash.__ac_fsize(self._n_buckets) if self._n_buckets &gt; 0 else 0
        _write_raw(jar, self._flags.as_byte(), fsize * sizeof(u32))
        _write_raw(jar, self._keys.as_byte(), self._n_buckets * sizeof(K))
    else:
        pickle(self._n_buckets, jar)
        size = len(self)
        pickle(size, jar)

        for k in self:
            pickle(k, jar)

</t>
<t tx="ekr.20230509052845.1611">def __unpickle__(jar: Jar) -&gt; Set[K]:
    import internal.khash as khash

    s = set[K]()
    if atomic(K):
        n_buckets = unpickle(jar, int)
        size = unpickle(jar, int)
        n_occupied = unpickle(jar, int)
        upper_bound = unpickle(jar, int)
        fsize = khash.__ac_fsize(n_buckets) if n_buckets &gt; 0 else 0
        flags = Ptr[u32](fsize)
        keys = Ptr[K](n_buckets)
        _read_raw(jar, flags.as_byte(), fsize * sizeof(u32))
        _read_raw(jar, keys.as_byte(), n_buckets * sizeof(K))

        s._n_buckets = n_buckets
        s._size = size
        s._n_occupied = n_occupied
        s._upper_bound = upper_bound
        s._flags = flags
        s._keys = keys
    else:
        n_buckets = unpickle(jar, int)
        size = unpickle(jar, int)
        s.resize(n_buckets)
        i = 0
        while i &lt; size:
            k = unpickle(jar, K)
            s.add(k)
            i += 1
    return s
</t>
<t tx="ekr.20230509052845.1612">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.python import ensure_initialized

ensure_initialized()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1613">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import sys
from math import inf as INF, sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
from bisect import bisect as _bisect
from time import time as _time

N = 624
M = 397
LOG4 = _log(4.0)
NV_MAGICCONST = 4 * _exp(-0.5) / _sqrt(2.0)
SG_MAGICCONST = 1.0 + _log(4.5)
TWOPI = 2.0 * _pi

MATRIX_A = u32(0x9908b0df)    # constant vector a
UPPER_MASK = u32(0x80000000)  # most significant w-r bits
LOWER_MASK = u32(0x7fffffff)  # least significant r bits

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1614">@tuple
class RandomGenerator:
    data: Ptr[u32]

    @others
</t>
<t tx="ekr.20230509052845.1615">def __new__():
    return RandomGenerator(Ptr[u32](N + 1))

</t>
<t tx="ekr.20230509052845.1616">@property
def index(self):
    return int(self.data[0])

</t>
<t tx="ekr.20230509052845.1617">@property
def state(self):
    return self.data + 1

</t>
<t tx="ekr.20230509052845.1618">def getstate(self):
    from internal.gc import sizeof
    p = Ptr[u32](N + 1)
    str.memcpy(p.as_byte(), self.data.as_byte(), (N + 1) * sizeof(u32))
    return p

</t>
<t tx="ekr.20230509052845.1619">def setstate(self, state):
    from internal.gc import sizeof
    str.memcpy(self.data.as_byte(), state.as_byte(), (N + 1) * sizeof(u32))

</t>
<t tx="ekr.20230509052845.162">def __init__(self):
    self.bestchild = None
    self.pos = -1
    self.wins = 0
    self.losses = 0
    self.pos_child = [None for x in range(SIZE * SIZE)]
    self.parent = None

</t>
<t tx="ekr.20230509052845.1620">def genrand_int32(self) -&gt; u32:
    mag01 = (u32(0), MATRIX_A)
    mt = self.state

    if self.index &gt;= N:
        kk = 0

        while kk &lt; int(N - M):
            y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK)
            mt[kk] = mt[kk + M] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
            kk += 1

        while kk &lt; int(N - 1):
            y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK)
            mt[kk] = mt[kk+(M-N)] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
            kk += 1

        y = (mt[N-1] &amp; UPPER_MASK) | (mt[0] &amp; LOWER_MASK)
        mt[N-1] = mt[M-1] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
        self.data[0] = u32(0)

    i = self.index
    y = mt[i]
    self.data[0] = u32(i + 1)
    y ^= (y &gt;&gt; u32(11))
    y ^= (y &lt;&lt; u32(7)) &amp; u32(0x9d2c5680)
    y ^= (y &lt;&lt; u32(15)) &amp; u32(0xefc60000)
    y ^= (y &gt;&gt; u32(18))
    return y

</t>
<t tx="ekr.20230509052845.1621">def genrand_res53(self) -&gt; float:
    a = self.genrand_int32() &gt;&gt; u32(5)
    b = self.genrand_int32() &gt;&gt; u32(6)
    return (int(a) * 67108864.0 + int(b)) * (1.0 / 9007199254740992.0)

</t>
<t tx="ekr.20230509052845.1622">def random(self):
    return self.genrand_res53()

</t>
<t tx="ekr.20230509052845.1623">def init_u32(self, s: u32):
    mt = self.state
    mt[0] = s
    for mti in range(1, N):
        mt[mti] = (u32(1812433253) * (mt[mti-1] ^ (mt[mti-1] &gt;&gt; u32(30))) + u32(mti))
    self.data[0] = u32(N)

</t>
<t tx="ekr.20230509052845.1624">def init_array(self, init_key: Ptr[u32], key_length: int):
    mt = self.state
    self.init_u32(u32(19650218))
    i = 1
    j = 0

    k = N if N &gt; key_length else key_length
    while k:
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; u32(30))) * u32(1664525))) + init_key[j] + u32(j)
        i += 1
        j += 1
        if i &gt;= N:
            mt[0] = mt[N - 1]
            i = 1
        if j &gt;= key_length:
            j = 0
        k -= 1

    k = N - 1
    while k:
        mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; u32(30))) * u32(1566083941))) - u32(i)
        i += 1
        if i &gt;= N:
            mt[0] = mt[N - 1]
            i = 1
        k -= 1

    mt[0] = u32(0x80000000)

</t>
<t tx="ekr.20230509052845.1625">def init_int(self, s: int):
    init_key = (u32(s &amp; ((1 &lt;&lt; 32) - 1)), u32(s &gt;&gt; 32))
    self.init_array(Ptr[u32](__ptr__(init_key).as_byte()), 2 if init_key[1] else 1)

</t>
<t tx="ekr.20230509052845.1626">def random_seed_time_pid(self):
    now = _C.seq_time() * 1000
    key = __array__[u32](5)
    key[0] = u32(now &amp; 0xFFFFFFFF)
    key[1] = u32(now &gt;&gt; 32)
    key[2] = u32(_C.seq_pid())
    now = _C.seq_time_monotonic()
    key[3] = u32(now &amp; 0xFFFFFFFF)
    key[4] = u32(now &gt;&gt; 32)
    self.init_array(key.ptr, len(key))

</t>
<t tx="ekr.20230509052845.1627">def seed(self, s: int):
    self.init_int(s)

</t>
<t tx="ekr.20230509052845.1628">def seed(self):
    self.random_seed_time_pid()

</t>
<t tx="ekr.20230509052845.1629">class Random:
    """
    Random number generator base class used by bound module functions.
    Used to instantiate instances of Random to get generators that don't
    share state.
    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods:  random(), seed(), getstate(), and setstate().
    Optionally, implement a getrandbits() method so that randrange()
    can cover arbitrarily large ranges.
    """
    gen: RandomGenerator  # comment for another error
    gauss_next: Optional[float]

    @others
</t>
<t tx="ekr.20230509052845.163">def play(self, board):
    """ uct tree search """
    color = board.color
    node = self
    path = [node]
    while True:
        pos = node.select(board)
        if pos == PASS:
            break
        board.move(pos)
        child = node.pos_child[pos]
        if not child:
            child = node.pos_child[pos] = UCTNode()
            child.unexplored = board.useful_moves()
            child.pos = pos
            child.parent = node
            path.append(child)
            break
        path.append(child)
        node = child
    self.random_playout(board)
    self.update_path(board, color, path)

</t>
<t tx="ekr.20230509052845.1630">def __init__(self, seed: Optional[int] = None):
    """
    Initialize an instance.

    Optional argument x controls seeding, as for Random.seed().

    For now x is set to its default None.
    """
    self.gen = RandomGenerator()
    self.seed(seed)

</t>
<t tx="ekr.20230509052845.1631">def seed(self, a: Optional[int]):
    """
    Initialize internal state from hashable object.

    None or no argument seeds from current time or from an operating
    system specific randomness source if available.

    If *a* is an int, all bits are used.

    For version 2 (the default), all of the bits are used if *a* is a str,
    bytes, or bytearray.  For version 1 (provided for reproducing random
    sequences from older versions of Python), the algorithm for str and
    bytes generates a narrower range of seeds.
    """
    if a is not None:
        self.gen.seed(abs(a))
    else:
        self.gen.seed()
    self.gauss_next = None

</t>
<t tx="ekr.20230509052845.1632">def getstate(self):
    return self.gen.getstate(), self.gauss_next

</t>
<t tx="ekr.20230509052845.1633">def setstate(self, state):
    gen_state, gauss_next = state
    self.gen.setstate(gen_state)
    self.gauss_next = gauss_next

</t>
<t tx="ekr.20230509052845.1634">def getrandbits(self, k: int) -&gt; int:
    """
    getrandbits(k) -&gt; x
    Generates an int with k random bits.
    """
    if k == 0:
        return 0

    if k &lt; 0:
        raise ValueError("number of bits must be non-negative")

    if k &gt; 64:
        raise ValueError("number of bits cannot be greater than 64")

    if k &lt;= 32:  # Fast path
        r = int(self.gen.genrand_int32())
        m = r &gt;&gt; (32 - k)
        return m

    lo = u64(int(self.gen.genrand_int32()))
    hi = u64(int(self.gen.genrand_int32()))
    mask = ~((u64(1) &lt;&lt; u64(64 - k)) - u64(1))
    hi &amp;= mask
    hi &gt;&gt;= u64(64 - k)
    return int((hi &lt;&lt; u64(32)) | lo)

</t>
<t tx="ekr.20230509052845.1635">def bit_length(self, n: int) -&gt; int:
    """ """
    len = 0
    while n:
        len += 1
        n = int(u64(n) &gt;&gt; u64(1))
    return len

</t>
<t tx="ekr.20230509052845.1636">def _randbelow_with_getrandbits(self, n: int) -&gt; int:
    """
    Return a random int in the range [0,n).  Raises ValueError if n==0.
    """
    getrandbits = self.getrandbits
    k = self.bit_length(n)  # don't use (n-1) here because n can be 1
    r = getrandbits(k)  # 0 &lt;= r &lt; 2**k
    while r &gt;= n:
        r = getrandbits(k)
    return r

</t>
<t tx="ekr.20230509052845.1637">def randrange(self, start: int, stop: int, step: int = 1) -&gt; int:
    """
    Choose a random item from range(start, stop[, step]).

    Return a randomly selected element from range(start, stop, step).
    This is equivalent to choice(range(start, stop, step)), but
    doesnt actually build a range object.

    For now stop == 0 for randrange(stop) where start = stop in our parameter.
    Defaults include: stop = None, step = 1
    for now we will use default value for step.
    """
    if stop == 0:
        if start &gt; 0:
            return self._randbelow_with_getrandbits(start)
        raise ValueError("empty range for randrange()")

    # stop argument supplied.
    width = stop - start
    if step == 1 and width &gt; 0:
        return start + self._randbelow_with_getrandbits(width)
    if step == 1:
        raise ValueError("empty range for randrange()")

    # Non-unit step argument supplied.
    n = INF
    if step &gt; 0:
        n = float((width + step - 1) // step)
    elif step &lt; 0:
        n = float((width + step + 1) // step)
    else:
        raise ValueError("zero step for randrange()")

    if n &lt;= 0:
        raise ValueError("empty range for randrange()")

    return start + step * self._randbelow_with_getrandbits(int(n))

</t>
<t tx="ekr.20230509052845.1638">def randint(self, a: int, b: int):
    """
    Return random integer in range [a, b], including both end points.
    """
    return self.randrange(a, b + 1, 1)

</t>
<t tx="ekr.20230509052845.1639">def random(self) -&gt; float:
    """
    random(self) -&gt; float

    Return the next random floating point number in the range [0.0, 1.0).
    """
    return self.gen.genrand_res53()

</t>
<t tx="ekr.20230509052845.164">def select(self, board):
    """ select move; unexplored children first, then according to uct value """
    if self.unexplored:
        i = random.randrange(len(self.unexplored))
        pos = self.unexplored[i]
        self.unexplored[i] = self.unexplored[len(self.unexplored) - 1]
        self.unexplored.pop()
        return pos
    elif self.bestchild:
        return self.bestchild.pos
    else:
        return PASS

</t>
<t tx="ekr.20230509052845.1640">def choice(self, sequence: Generator[T], T: type) -&gt; T:
    """
    Choose a random element from a non-empty sequence.
    """
    i = 0
    l = list(sequence)
    try:
        i = self._randbelow_with_getrandbits(len(l))
    except ValueError:
        raise IndexError("Cannot choose from an empty sequence")
    return l[i]

</t>
<t tx="ekr.20230509052845.1641">def shuffle(self, x):
    """
    Shuffle list x in place, and return None.

    Optional argument random is a 0-argument function returning a
    random float in [0.0, 1.0); if it is the default None, the
    standard random.random will be used.

    For now seq will use random = 0  (None = default)
    """
    random = 0
    if random == 0:
        randbelow = self._randbelow_with_getrandbits
        for i in reversed(range(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = randbelow(i + 1)
            x[i], x[j] = x[j], x[i]
    else:
        for i in reversed(range(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = int(self.random() * (i + 1))
            x[i], x[j] = x[j], x[i]

</t>
<t tx="ekr.20230509052845.1642">def uniform(self, a, b) -&gt; float:
    """
    Get a random number in the range [a, b) or [a, b] depending on rounding.
    """
    return a + (b - a) * self.random()

</t>
<t tx="ekr.20230509052845.1643">def triangular(self, low: float, high: float, mode: float) -&gt; float:
    """
    Triangular distribution.

    Continuous distribution bounded by given lower and upper limits,
    and having a given mode value in-between.

    http://en.wikipedia.org/wiki/Triangular_distribution

    For now we mode to default: mode = None
    default for low and high : low = 0.0, high = 1.0
    """
    # mode = None
    if high == low:
        return low
    u = self.random()
    c = (mode - low) / (high - low)
    if u &gt; c:
        u = 1.0 - u
        c = 1.0 - c
        low, high = high, low
    return low + (high - low) * _sqrt(u * c)

</t>
<t tx="ekr.20230509052845.1644">def gammavariate(self, alpha: float, beta: float) -&gt; float:
    """
    Gamma distribution.  Not the gamma function!

    Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.

    The probability distribution function is:

    ::

                x ** (alpha - 1) * math.exp(-x / beta)
      pdf(x) =  --------------------------------------
                  math.gamma(alpha) * beta ** alpha
    """
    # alpha &gt; 0, beta &gt; 0, mean is alpha*beta, variance is alpha*beta**2

    # Warning: a few older sources define the gamma distribution in terms
    # of alpha &gt; -1.0
    if alpha &lt;= 0.0 or beta &lt;= 0.0:
        raise ValueError("gammavariate: alpha and beta must be &gt; 0.0")

    if alpha &gt; 1.0:

        # Uses R.C.H. Cheng, "The generation of Gamma
        # variables with non-integral shape parameters",
        # Applied Statistics, (1977), 26, No. 1, p71-74

        ainv = _sqrt(2.0 * alpha - 1.0)
        bbb = alpha - LOG4
        ccc = alpha + ainv

        while 1:
            u1 = self.random()
            if not 1e-7 &lt; u1 &lt; 0.9999999:
                continue
            u2 = 1.0 - self.random()
            v = _log(u1 / (1.0 - u1)) / ainv
            x = alpha * _exp(v)
            z = u1 * u1 * u2
            r = bbb + ccc * v - x
            if r + SG_MAGICCONST - 4.5 * z &gt;= 0.0 or r &gt;= _log(z):
                return x * beta

    elif alpha == 1.0:
        # expovariate(1/beta)
        return -_log(1.0 - self.random()) * beta

    else:  # alpha is between 0 and 1 (exclusive)

        # Uses ALGORITHM GS of Statistical Computing - Kennedy &amp; Gentle
        x = 0.0
        while 1:
            u = self.random()
            b = (_e + alpha) / _e
            p = b * u
            if p &lt;= 1.0:
                x = p ** (1.0 / alpha)
            else:
                x = -_log((b - p) / alpha)
            u1 = self.random()
            if p &gt; 1.0:
                if u1 &lt;= x ** (alpha - 1.0):
                    break
            elif u1 &lt;= _exp(-x):
                break
        return x * beta

</t>
<t tx="ekr.20230509052845.1645">def betavariate(self, alpha: float, beta: float) -&gt; float:
    """
    Beta distribution.
    Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.
    Returned values range between 0 and 1.
    """
    # This version due to Janne Sinkkonen, and matches all the std
    # texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").
    y = self.gammavariate(alpha, 1.0)
    if y == 0:
        return 0.0
    else:
        return y / (y + self.gammavariate(beta, 1.0))

</t>
<t tx="ekr.20230509052845.1646">def expovariate(self, lambd: float) -&gt; float:
    """
    Exponential distribution.

    lambd is 1.0 divided by the desired mean.  It should be
    nonzero.

    Returned values range from 0 to
    positive infinity if lambd is positive, and from negative
    infinity to 0 if lambd is negative.
    """
    if lambd == 0.0:
        raise ZeroDivisionError("Cannot divide by zero")
    # lambd: rate lambd = 1/mean
    # we use 1-random() instead of random() to preclude the
    # possibility of taking the log of zero.
    return -_log(1.0 - self.random()) / lambd

</t>
<t tx="ekr.20230509052845.1647">def gauss(self, mu: float = 0.0, sigma: float = 1.0) -&gt; float:
    """
    Gaussian distribution.

    mu is the mean, and sigma is the standard deviation.  This is
    slightly faster than the normalvariate() function.
    Not thread-safe without a lock around calls.
    """
    z = self.gauss_next
    self.gauss_next = None
    if z is None:
        x2pi = self.random() * TWOPI
        g2rad = _sqrt(-2.0 * _log(1.0 - self.random()))
        z = _cos(x2pi) * g2rad
        self.gauss_next = _sin(x2pi) * g2rad
    return mu + z * sigma

</t>
<t tx="ekr.20230509052845.1648">def paretovariate(self, alpha: float) -&gt; float:
    """
    Pareto distribution.  alpha is the shape parameter."""
    u = 1.0 - self.random()
    return 1.0 / u ** (1.0 / alpha)

</t>
<t tx="ekr.20230509052845.1649">def weibullvariate(self, alpha: float, beta: float) -&gt; float:
    """
    Weibull distribution.

    alpha is the scale parameter and beta is the shape parameter.
    """
    u = 1.0 - self.random()
    return alpha * (-_log(u)) ** (1.0 / beta)

</t>
<t tx="ekr.20230509052845.165">def random_playout(self, board):
    """ random play until both players pass """
    for x in range(MAXMOVES):  # XXX while not self.finished?
        if board.finished:
            break
        board.move(board.random_move())

</t>
<t tx="ekr.20230509052845.1650">def normalvariate(self, mu: float = 0.0, sigma: float = 1.0) -&gt; float:
    """
    Normal distribution.

    mu is the mean, and sigma is the standard deviation.
    """
    z = 0.0
    while 1:
        u1 = self.random()
        u2 = 1.0 - self.random()
        z = NV_MAGICCONST * (u1 - 0.5) / u2
        zz = z * z / 4.0
        if zz &lt;= -_log(u2):
            break
    return mu + z * sigma

</t>
<t tx="ekr.20230509052845.1651">def lognormvariate(self, mu: float, sigma: float) -&gt; float:
    """
    Log normal distribution.

    If you take the natural logarithm of this distribution, you'll get a
    normal distribution with mean mu and standard deviation sigma.
    mu can have any value, and sigma must be greater than zero.
    """
    return _exp(self.normalvariate(mu, sigma))

</t>
<t tx="ekr.20230509052845.1652">def vonmisesvariate(self, mu: float, kappa: float) -&gt; float:
    """
    Circular data distribution.

    mu is the mean angle, expressed in radians between 0.0 and 2*pi, and
    kappa is the concentration parameter, which must be greater than or
    equal to zero.  If kappa is equal to zero, this distribution reduces
    to a uniform random angle over the range 0.0 to 2*pi.
    """
    def _mod(a: float, b: float):
        @others
        mod = _mod_float_float(a, b)
        div = _truediv_float_float(a - mod, b)
        if mod:
            if (b &lt; 0) != (mod &lt; 0):
                mod += b
                div -= 1.0
        else:
            mod = (0.0).copysign(b)
        return mod

    z = 0.0
    theta = 0.0

    if kappa &lt;= 1e-6:
        return TWOPI * self.random()

    s = 0.5 / kappa
    r = s + _sqrt(1.0 + s * s)

    while 1:
        u1 = self.random()
        z = _cos(_pi * u1)

        d = z / (r + z)
        u2 = self.random()
        if u2 &lt; 1.0 - d * d or u2 &lt;= (1.0 - d) * _exp(d):
            break

    q = 1.0 / r
    f = (q + z) / (1.0 + q * z)
    u3 = self.random()
    if u3 &gt; 0.5:
        theta = _mod(mu + _acos(f), TWOPI)
    else:
        theta = _mod(mu - _acos(f), TWOPI)

    return theta

</t>
<t tx="ekr.20230509052845.1653">@pure
@llvm
def _truediv_float_float(self: float, other: float) -&gt; float:
    %0 = fdiv double %self, %other
    ret double %0

</t>
<t tx="ekr.20230509052845.1654">@pure
@llvm
def _mod_float_float(self: float, other: float) -&gt; float:
    %0 = frem double %self, %other
    ret double %0

</t>
<t tx="ekr.20230509052845.1655">def sample(self, population: List[T], k: int, T: type):
    """
    Chooses k unique random elements from a population sequence or set.

    Returns a new list containing elements from the population while
    leaving the original population unchanged.  The resulting list is
    in selection order so that all sub-slices will also be valid random
    samples.  This allows raffle winners (the sample) to be partitioned
    into grand prize and second place winners (the subslices).

    Members of the population need not be hashable or unique.  If the
    population contains repeats, then each occurrence is a possible
    selection in the sample.

    To choose a sample in a range of integers, use range as an argument.
    This is especially fast and space efficient for sampling from a
    large population:   sample(range(10000000), 60)

    For now seq will deal with only lists.
    """
    randbelow = self._randbelow_with_getrandbits
    n = len(population)
    if not 0 &lt;= k &lt;= n:
        raise ValueError("Sample larger than population or is negative")
    result = [T() for _ in range(k)]
    setsize = 21.0  # size of a small set minus size of an empty list
    if k &gt; 5:
        # Should be _log(k * 3, 4)
        setsize += 4 ** _ceil(_log(float(k * 3)))  # table size for big sets
    if n &lt;= setsize:
        # An n-length list is smaller than a k-length set
        pool = list(population)
        for i in range(k):  # invariant:  non-selected at [0,n-i)
            j = randbelow(n - i)
            result[i] = pool[j]
            pool[j] = pool[n - i - 1]  # move non-selected item into vacancy
    else:
        selected = Set[int]()
        selected_add = selected.add
        for i in range(k):
            j = randbelow(n)
            while j in selected:
                j = randbelow(n)
            selected_add(j)
            result[i] = population[j]
    return result

</t>
<t tx="ekr.20230509052845.1656">def choices(
    self,
    population,
    weights: Optional[List[int]],
    cum_weights: Optional[List[int]],
    k: int,
):
    """
    Return a k sized list of population elements chosen with replacement.

    If the relative weights or cumulative weights are not specified,
    the selections are made with equal probability.

    Since weights and cum_weights is assumed to be positive, we will replace None with [-1].
    """

    def accumulate(weights: List[int]) -&gt; List[int]:
        """
        Calculate cum_weights
        """
        n = len(weights)
        cum_weight = List[int](n)
        accum = 0
        if n &gt; 0:
            for i in range(n):
                accum += weights[i]
                cum_weight.append(accum)

        return cum_weight

    n = len(population)
    if cum_weights is None:
        if weights is None:
            return [population[int(self.random() * n)] for i in range(k)]
        cum_weights = accumulate(weights)
    elif weights is not None:
        raise TypeError("Cannot specify both weights and cumulative weights")
    if len(cum_weights) != n:
        raise ValueError("The number of weights does not match the population")

    total = float(cum_weights[-1])  # convert to float
    hi = n - 1
    return [
        population[_bisect(cum_weights, int(self.random() * total), 0, hi)]
        for i in range(k)
    ]

</t>
<t tx="ekr.20230509052845.1657">_rnd = Random()

</t>
<t tx="ekr.20230509052845.1658">def seed(a: int):
    _rnd.seed(a)

</t>
<t tx="ekr.20230509052845.1659">def getrandbits(k: int):
    return _rnd.getrandbits(k)

</t>
<t tx="ekr.20230509052845.166">def update_path(self, board, color, path):
    """ update win/loss count along path """
    wins = board.score(BLACK) &gt;= board.score(WHITE)
    for node in path:
        if color == BLACK:
            color = WHITE
        else:
            color = BLACK
        if wins == (color == BLACK):
            node.wins += 1
        else:
            node.losses += 1
        if node.parent:
            node.parent.bestchild = node.parent.best_child()

</t>
<t tx="ekr.20230509052845.1660">def randrange(start: int, stop: Optional[int] = None, step: int = 1):
    return _rnd.randrange(start, stop, step) if stop is not None else _rnd.randrange(0, start, step)

</t>
<t tx="ekr.20230509052845.1661">def randint(a: int, b: int):
    return _rnd.randint(a, b)

</t>
<t tx="ekr.20230509052845.1662">def choice(s):
    return _rnd.choice(s)

</t>
<t tx="ekr.20230509052845.1663">def choices(
    population,
    weights: Optional[List[int]] = None,
    cum_weights: Optional[List[int]] = None,
    k: int = 1,
):
    return _rnd.choices(population, weights, cum_weights, k)

</t>
<t tx="ekr.20230509052845.1664">def shuffle(s):
    _rnd.shuffle(s)

</t>
<t tx="ekr.20230509052845.1665">def sample(population, k: int):
    return _rnd.sample(population, k)

</t>
<t tx="ekr.20230509052845.1666">def random():
    return _rnd.random()

</t>
<t tx="ekr.20230509052845.1667">def uniform(a, b):
    return _rnd.uniform(a, b)

</t>
<t tx="ekr.20230509052845.1668">def triangular(low: float = 0.0, high: float = 1.0, mode: Optional[float] = None):
    return _rnd.triangular(low, high, mode if mode is not None else (low + high) / 2)

</t>
<t tx="ekr.20230509052845.1669">def betavariate(alpha: float, beta: float):
    return _rnd.betavariate(alpha, beta)

</t>
<t tx="ekr.20230509052845.167">def score(self):
    winrate = self.wins / float(self.wins + self.losses)
    parentvisits = self.parent.wins + self.parent.losses
    if not parentvisits:
        return winrate
    nodevisits = self.wins + self.losses
    return winrate + math.sqrt((math.log(parentvisits)) / (5 * nodevisits))

</t>
<t tx="ekr.20230509052845.1670">def expovariate(lambd: float):
    return _rnd.expovariate(lambd)

</t>
<t tx="ekr.20230509052845.1671">def gammavariate(alpha: float, beta: float):
    return _rnd.gammavariate(alpha, beta)

</t>
<t tx="ekr.20230509052845.1672">def gauss(mu: float, sigma: float):
    return _rnd.gauss(mu, sigma)

</t>
<t tx="ekr.20230509052845.1673">def lognormvariate(mu: float, sigma: float):
    return _rnd.lognormvariate(mu, sigma)

</t>
<t tx="ekr.20230509052845.1674">def normalvariate(mu: float, sigma: float):
    return _rnd.normalvariate(mu, sigma)

</t>
<t tx="ekr.20230509052845.1675">def vonmisesvariate(mu: float, kappa: float):
    return _rnd.vonmisesvariate(mu, kappa)

</t>
<t tx="ekr.20230509052845.1676">def paretovariate(alpha: float):
    return _rnd.paretovariate(alpha)

</t>
<t tx="ekr.20230509052845.1677">def weibullvariate(alpha: float, beta: float):
    return _rnd.weibullvariate(alpha, beta)
</t>
<t tx="ekr.20230509052845.1678">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Adapted in part from Google's Python re2 wrapper
# https://github.com/google/re2/blob/abseil/python/re2.py

A          = (1 &lt;&lt; 0)
ASCII      = (1 &lt;&lt; 0)
DEBUG      = (1 &lt;&lt; 1)
I          = (1 &lt;&lt; 2)
IGNORECASE = (1 &lt;&lt; 2)
L          = (1 &lt;&lt; 3)
LOCALE     = (1 &lt;&lt; 3)
M          = (1 &lt;&lt; 4)
MULTILINE  = (1 &lt;&lt; 4)
S          = (1 &lt;&lt; 5)
DOTALL     = (1 &lt;&lt; 5)
X          = (1 &lt;&lt; 6)
VERBOSE    = (1 &lt;&lt; 6)

_ANCHOR_NONE  = 0
_ANCHOR_START = 1
_ANCHOR_BOTH  = 2

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1679">@tuple
class Span:
    start: int
    end: int

    def __bool__(self):
        return not (self.start == -1 and self.end == -1)

</t>
<t tx="ekr.20230509052845.168">def best_child(self):
    maxscore = -1
    maxchild = None
    for child in self.pos_child:
        if child and child.score() &gt; maxscore:
            maxchild = child
            maxscore = child.score()
    return maxchild

</t>
<t tx="ekr.20230509052845.1680">@C
@pure
def seq_re_match(re: cobj,
                 anchor: int,
                 string: str,
                 pos: int,
                 endpos: int) -&gt; Ptr[Span]:
    pass

</t>
<t tx="ekr.20230509052845.1681">@C
@pure
def seq_re_match_one(re: cobj,
                     anchor: int,
                     string: str,
                     pos: int,
                     endpos: int) -&gt; Span:
    pass

</t>
<t tx="ekr.20230509052845.1682">@C
@pure
def seq_re_pattern_groups(re: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.1683">@C
@pure
def seq_re_group_name_to_index(re: cobj, name: str) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.1684">@C
@pure
def seq_re_group_index_to_name(re: cobj, index: int) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.1685">@C
@pure
def seq_re_pattern_error(re: cobj) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.1686">@C
@pure
def seq_re_escape(pattern: str) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.1687">@C
def seq_re_purge() -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.1688">@C
@pure
def seq_re_compile(pattern: str, flags: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.1689">class error(Static[Exception]):
    pattern: str

    @others
</t>
<t tx="ekr.20230509052845.169">def best_visited(self):
    maxvisits = -1
    maxchild = None
    for child in self.pos_child:
        #            if child:
        # print to_xy(child.pos), child.wins, child.losses, child.score()
        if child and (child.wins + child.losses) &gt; maxvisits:
            maxvisits, maxchild = (child.wins + child.losses), child
    return maxchild


</t>
<t tx="ekr.20230509052845.1690">def __init__(self, message: str = "", pattern: str = ""):
    super().__init__("re.error", message)
    self.pattern = pattern

</t>
<t tx="ekr.20230509052845.1691">@property
def msg(self):
    return self.message

</t>
<t tx="ekr.20230509052845.1692">@tuple
class Pattern:
    pattern: str
    flags: int
    _re: cobj

</t>
<t tx="ekr.20230509052845.1693">def compile(pattern: str, flags: int = 0):
    re = seq_re_compile(pattern, flags)
    err_msg = seq_re_pattern_error(re)
    if err_msg:
        raise error(err_msg, pattern)
    return Pattern(pattern, flags, re)

</t>
<t tx="ekr.20230509052845.1694">def search(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).search(string)

</t>
<t tx="ekr.20230509052845.1695">def match(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).match(string)

</t>
<t tx="ekr.20230509052845.1696">def fullmatch(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).fullmatch(string)

</t>
<t tx="ekr.20230509052845.1697">def finditer(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).finditer(string)

</t>
<t tx="ekr.20230509052845.1698">def findall(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).findall(string)

</t>
<t tx="ekr.20230509052845.1699">def split(pattern: str, string: str, maxsplit: int = 0, flags: int = 0):
    return compile(pattern, flags).split(string, maxsplit)

</t>
<t tx="ekr.20230509052845.17">def main(n, min_depth=4):
    max_depth = max(min_depth + 2, n)
    stretch_depth = max_depth + 1
    print(f'stretch tree of depth {stretch_depth}\t check: {make_check((0, stretch_depth))}')

    long_lived_tree = make_tree(max_depth)

    mmd = max_depth + min_depth
    for d in range(min_depth, stretch_depth, 2):
        i = 2 ** (mmd - d)
        cs = 0
        for argchunk in get_argchunks(i, d):
            cs += sum(map(make_check, argchunk))
        print(f'{i}\t trees of depth {d}\t check: {cs}')

    print(f'long lived tree of depth {max_depth}\t check: {check_tree(long_lived_tree)}')

</t>
<t tx="ekr.20230509052845.170"># def user_move(board):
#     while True:
#         text = input('?').strip()
#         if text == 'p':
#             return PASS
#         if text == 'q':
#             raise EOFError
#         try:
#             x, y = [int(i) for i in text.split()]
#         except ValueError:
#             continue
#         if not (0 &lt;= x &lt; SIZE and 0 &lt;= y &lt; SIZE):
#             continue
#         pos = to_pos(x, y)
#         if board.useful(pos):
#             return pos


</t>
<t tx="ekr.20230509052845.1700">def sub(pattern: str, repl, string: str, count: int = 0, flags: int = 0):
    return compile(pattern, flags).sub(repl, string, count)

</t>
<t tx="ekr.20230509052845.1701">def subn(pattern: str, repl, string: str, count: int = 0, flags: int = 0):
    return compile(pattern, flags).subn(repl, string, count)

</t>
<t tx="ekr.20230509052845.1702">def escape(pattern: str):
    return seq_re_escape(pattern)

</t>
<t tx="ekr.20230509052845.1703">def purge():
    seq_re_purge()

</t>
<t tx="ekr.20230509052845.1704">@tuple
class Match:
    _spans: Ptr[Span]
    pos: int
    endpos: int
    re: Pattern
    string: str

    @others
</t>
<t tx="ekr.20230509052845.1705">def _get_group_int(self, g: int, n: int):
    if not (0 &lt;= g &lt;= n):
        raise IndexError("no such group")
    return self._spans[g]

</t>
<t tx="ekr.20230509052845.1706">def _get_group_str(self, g: str, n: int):
    return self._get_group_int(seq_re_group_name_to_index(self.re._re, g), n)

</t>
<t tx="ekr.20230509052845.1707">def _get_group(self, g, n: int):
    if isinstance(g, int):
        return self._get_group_int(g, n)
    elif isinstance(g, str):
        return self._get_group_str(g, n)
    else:
        return self._get_group(g.__index__(), n)

</t>
<t tx="ekr.20230509052845.1708">def _span_match(self, span: Span):
    if not span:
        return None
    return self.string._slice(span.start, span.end)

</t>
<t tx="ekr.20230509052845.1709">def _get_match(self, g, n: int):
    span = self._get_group(g, n)
    return self._span_match(span)

</t>
<t tx="ekr.20230509052845.171">def computer_move(board):
    pos = board.random_move()
    if pos == PASS:
        return PASS
    tree = UCTNode()
    tree.unexplored = board.useful_moves()
    nboard = Board()
    for game in range(GAMES):
        node = tree
        nboard.reset()
        nboard.replay(board.history)
        node.play(nboard)
    return tree.best_visited().pos


</t>
<t tx="ekr.20230509052845.1710">def _group_multi(self, n: int, *args):
    if staticlen(args) == 1:
        return (self._get_match(args[0], n),)
    else:
        return (self._get_match(args[0], n), *self._group_multi(n, *args[1:]))

</t>
<t tx="ekr.20230509052845.1711">def group(self, *args):
    if staticlen(args) == 0:
        return self._get_match(0, 1).__val__()
    elif staticlen(args) == 1:
        return self._get_match(args[0], self.re.groups)
    else:
        return self._group_multi(self.re.groups, *args)

</t>
<t tx="ekr.20230509052845.1712">def __getitem__(self, g):
    return self._get_match(g, self.re.groups)

</t>
<t tx="ekr.20230509052845.1713">def start(self, group = 0):
    return self._get_group(group, self.re.groups).start

</t>
<t tx="ekr.20230509052845.1714">def end(self, group = 0):
    return self._get_group(group, self.re.groups).end

</t>
<t tx="ekr.20230509052845.1715">def span(self, group = 0):
    start, end = self._get_group(group, self.re.groups)
    return start, end

</t>
<t tx="ekr.20230509052845.1716">def _split(template: str):
    backslash = '\\'
    pieces = ['']
    index = template.find(backslash)

    OCTAL = compile(r'\\[0-7][0-7][0-7]')
    GROUP = compile(r'\\[1-9][0-9]?|\\g&lt;\w+&gt;')

    while index != -1:
        piece, template = template[:index], template[index:]
        pieces[-1] += piece

        octal_match = OCTAL.match(template)
        group_match = GROUP.match(template)

        if (not octal_match) and group_match:
            index = group_match.end()
            piece, template = template[:index], template[index:]
            pieces.extend((piece, ''))
        else:
            index = 2
            piece, template = template[:index], template[index:]
            pieces[-1] += piece

        index = template.find(backslash)

    pieces[-1] += template
    return pieces

</t>
<t tx="ekr.20230509052845.1717">def _unescape(s: str):
    r = []
    n = len(s)
    i = 0
    while i &lt; n:
        if s[i] == '\\' and i + 1 &lt; n:
            c = s[i + 1]
            if c == 'a':
                r.append('\a')
                i += 1
            elif c == 'b':
                r.append('\b')
                i += 1
            elif c == 'f':
                r.append('\f')
                i += 1
            elif c == 'n':
                r.append('\n')
                i += 1
            elif c == 'r':
                r.append('\r')
                i += 1
            elif c == 't':
                r.append('\t')
                i += 1
            elif c == 'v':
                r.append('\v')
                i += 1
            elif c == '"':
                r.append('\"')
                i += 1
            elif c == '\'':
                r.append('\'')
                i += 1
            elif c == '\\':
                r.append('\\')
                i += 1
            elif '0' &lt;= c &lt;= '7':
                    k = i + 2
                    while k &lt; n and k - i &lt;= 4 and '0' &lt;= s[k] &lt;= '7':
                        k += 1
                    code = int(s[i+1:k], 8)
                    p = Ptr[byte](1)
                    p[0] = byte(code)
                    r.append(str(p, 1))
                    i = k - 1
            elif c.isalpha():
                raise error(f"bad escape \\{c} at position {i}")
            else:
                r.append(s[i])
        else:
            r.append(s[i])
        i += 1

    return str.cat(r)

</t>
<t tx="ekr.20230509052845.1718">def expand(self, template: str):
    def get_or_empty(s: Optional[str]):
        return s if s is not None else ''

    pieces = list(Match._split(template))
    INT = compile(r'[+-]?\d+')

    for index, piece in enumerate(pieces):
        if not (index % 2):
            pieces[index] = Match._unescape(piece)
        else:
            if len(piece) &lt;= 3:
                pieces[index] = get_or_empty(self[int(piece[1:])])
            else:
                group = piece[3:-1]
                if INT.fullmatch(group):
                    pieces[index] = get_or_empty(self[int(group)])
                else:
                    pieces[index] = get_or_empty(self[group])
    return str.cat(pieces)

</t>
<t tx="ekr.20230509052845.1719">@property
def lastindex(self):
    max_end = -1
    max_group = None
    for group in range(1, self.re.groups + 1):
        end = self._spans[group].end
        if max_end &lt; end:
            max_end = end
            max_group = group
    return max_group

</t>
<t tx="ekr.20230509052845.172">def versus_cpu():
    for i in range(100):
        random.seed(i)
        board = Board()
        computer_move(board)


</t>
<t tx="ekr.20230509052845.1720">@property
def lastgroup(self):
    max_group = self.lastindex
    if max_group is None:
        return None
    return seq_re_group_index_to_name(self.re._re, max_group)

</t>
<t tx="ekr.20230509052845.1721">def groups(self, default: Optional[str] = None):
    def get_or_default(item, default):
        return item if item is not None else default

    n = self.re.groups
    return [get_or_default(self._span_match(self._spans[i]), default)
            for i in range(1, n + 1)]

</t>
<t tx="ekr.20230509052845.1722">def groupdict(self, default: Optional[str] = None):
    d = {}
    for group, index in self.re.groupindex.items():
        item = self[index]
        d[group] = item if item is not None else default
    return d

</t>
<t tx="ekr.20230509052845.1723">def __copy__(self):
    return self

</t>
<t tx="ekr.20230509052845.1724">def __deepcopy__(self):
    return self

</t>
<t tx="ekr.20230509052845.1725">def __bool__(self):
    return True

</t>
<t tx="ekr.20230509052845.1726">@extend
class Pattern:
    @others
</t>
<t tx="ekr.20230509052845.1727">@property
def groups(self):
    return seq_re_pattern_groups(self._re)

</t>
<t tx="ekr.20230509052845.1728">@property
def groupindex(self):
    d = {}
    for i in range(1, self.groups + 1):
        name = seq_re_group_index_to_name(self._re, i)
        if name:
            d[name] = i
    return d

</t>
<t tx="ekr.20230509052845.1729">def _match_one(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
    posx = 0 if pos is None else max(0, min(pos.__val__(), len(string)))
    endposx = len(string) if endpos is None else max(0, min(endpos.__val__(), len(string)))

    if posx &gt; endposx:
        return None

    spans = seq_re_match(self._re, anchor, string, posx, endposx)
    if not spans[0]:
        return None

    return Match(spans, posx, endposx, self, string)

</t>
<t tx="ekr.20230509052845.173"></t>
<t tx="ekr.20230509052845.1730">def _match(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
    posx = 0 if pos is None else max(0, min(pos.__val__(), len(string)))
    endposx = len(string) if endpos is None else max(0, min(endpos.__val__(), len(string)))

    if posx &gt; endposx:
        return

    while True:
        spans = seq_re_match(self._re, anchor, string, posx, endposx)

        if not spans[0]:
            break

        yield Match(spans, posx, endposx, self, string)

        if posx == endposx:
            break

        elif posx == spans[0][1]:
            # We matched the empty string at pos and would be stuck, so in order
            # to make forward progress, increment the bytes offset.
            posx += 1
        else:
            posx = spans[0][1]

</t>
<t tx="ekr.20230509052845.1731">def search(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
    return self._match_one(_ANCHOR_NONE, string, pos, endpos)

</t>
<t tx="ekr.20230509052845.1732">def match(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
    return self._match_one(_ANCHOR_START, string, pos, endpos)

</t>
<t tx="ekr.20230509052845.1733">def fullmatch(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
    return self._match_one(_ANCHOR_BOTH, string, pos, endpos)

</t>
<t tx="ekr.20230509052845.1734">def finditer(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
    return self._match(_ANCHOR_NONE, string, pos, endpos)

</t>
<t tx="ekr.20230509052845.1735">def findall(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
    return [m.group() for m in self.finditer(string, pos, endpos)]

</t>
<t tx="ekr.20230509052845.1736">def _split(self, cb, string: str, maxsplit: int = 0, T: type = str):
    if maxsplit &lt; 0:
        return [T(string)], 0

    pieces: List[T] = []
    end = 0
    numsplit = 0
    for match in self.finditer(string):
        if (maxsplit &gt; 0 and numsplit &gt;= maxsplit):
            break
        pieces.append(string[end:match.start()])
        pieces.extend(cb(match))
        end = match.end()
        numsplit += 1
    pieces.append(string[end:])
    return pieces, numsplit

</t>
<t tx="ekr.20230509052845.1737">def split(self, string: str, maxsplit: int = 0):
    cb = lambda match: [match[group] for group in range(1, self.groups + 1)]
    pieces, _ = self._split(cb, string, maxsplit, Optional[str])
    return pieces

</t>
<t tx="ekr.20230509052845.1738">def _repl(match, repl):
    if isinstance(repl, str):
        return match.expand(repl)
    else:
        return repl(match)

</t>
<t tx="ekr.20230509052845.1739">def subn(self, repl, string: str, count: int = 0):
    cb = lambda match: [Pattern._repl(match, repl)]
    pieces, numsplit = self._split(cb, string, count, str)
    joined_pieces = str.cat(pieces)
    return joined_pieces, numsplit

</t>
<t tx="ekr.20230509052845.174">@path C:/Repos/codon/bench/mandelbrot/
import time
MAX    = 1000  # maximum Mandelbrot iterations
N      = 4096  # width and height of image
pixels = [0 for _ in range(N * N)]

@others
t0 = time.time()
@par(gpu=True, collapse=2)
for i in range(N):
    for j in range(N):
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        pixels[i*N + j] = int(255 * iteration/MAX)
print(sum(pixels))
print(time.time() - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1740">def sub(self, repl, string: str, count: int = 0):
    joined_pieces, _ = self.subn(repl, string, count)
    return joined_pieces

</t>
<t tx="ekr.20230509052845.1741">def __bool__(self):
    return True
</t>
<t tx="ekr.20230509052845.1742">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from bisect import bisect_right, bisect_left, insort
from collections import deque

DEFAULT_LOAD_FACTOR = 1000

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1743">class SortedList:
    _len: int
    _load: int
    _lists: List[List[T]]
    _maxes: List[T]
    _offset: int
    T: type

    @others
</t>
<t tx="ekr.20230509052845.1744">def __init__(self):
    self._len = 0
    self._load = DEFAULT_LOAD_FACTOR
    self._lists = []
    self._maxes = []
    self._offset = 0

</t>
<t tx="ekr.20230509052845.1745">def clear(self):
    """
    Remove all values from sorted list.
    Runtime complexity: `O(n)`
    """
    self._len = 0
    self._lists.clear()
    self._maxes.clear()
    self._offset = 0

</t>
<t tx="ekr.20230509052845.1746">@property
def left(self) -&gt; T:
    if not self._lists:
        raise IndexError("list index out of range")
    return self._lists[0][0]

</t>
<t tx="ekr.20230509052845.1747">def add(self, value: T):
    """
    Add `value` to sorted list.
    Runtime complexity: `O(log(n))` -- approximate.
    &gt;&gt;&gt; sl = SortedList()
    &gt;&gt;&gt; sl.add(3)
    &gt;&gt;&gt; sl.add(1)
    &gt;&gt;&gt; sl.add(2)
    &gt;&gt;&gt; sl
    SortedList([1, 2, 3])
    :param value: value to add to sorted list
    """
    if self._maxes:
        pos = bisect_right(self._maxes, value)
        if pos == len(self._maxes):
            pos -= 1
            self._lists[pos].append(value)
            self._maxes[pos] = value
        else:
            insort(self._lists[pos], value)
        self._expand(pos)
    else:
        self._lists.append([value])
        self._maxes.append(value)
    self._len += 1

</t>
<t tx="ekr.20230509052845.1748">def _expand(self, pos: int):
    """
    Split sublists with length greater than double the load-factor.
    Updates the index when the sublist length is less than double the load
    level. This requires incrementing the nodes in a traversal from the
    leaf node to the root. For an example traversal see
    ``SortedList._loc``.
    """
    if len(self._lists[pos]) &gt; (self._load &lt;&lt; 1):
        _maxes = self._maxes

        _lists_pos = self._lists[pos]
        half = _lists_pos[self._load :]
        del _lists_pos[self._load :]
        _maxes[pos] = _lists_pos[-1]

        self._lists.insert(pos + 1, half)
        _maxes.insert(pos + 1, half[-1])

</t>
<t tx="ekr.20230509052845.1749">def _delete(self, pos: int, idx: int):
    """
    Delete value at the given `(pos, idx)`.
    Combines lists that are less than half the load level.
    Updates the index when the sublist length is more than half the load
    level. This requires decrementing the nodes in a traversal from the
    leaf node to the root. For an example traversal see
    ``SortedList._loc``.
    :param int pos: lists index
    :param int idx: sublist index
    """
    _lists_pos = self._lists[pos]
    del _lists_pos[idx]
    self._len -= 1

    len_lists_pos = len(_lists_pos)

    if len_lists_pos &gt; (self._load &gt;&gt; 1):
        self._maxes[pos] = _lists_pos[-1]
    elif len(self._lists) &gt; 1:
        if not pos:
            pos += 1

        prev = pos - 1
        self._lists[prev].extend(self._lists[pos])
        self._maxes[prev] = self._lists[prev][-1]

        del self._lists[pos]
        del self._maxes[pos]

        self._expand(prev)
    elif len_lists_pos:
        self._maxes[pos] = _lists_pos[-1]
    else:
        del self._lists[pos]
        del self._maxes[pos]

</t>
<t tx="ekr.20230509052845.175">def scale(x, a, b):
    return a + (x/N)*(b - a)

</t>
<t tx="ekr.20230509052845.1750">def __iter__(self) -&gt; Generator[T]:
    for l in self._lists:
        yield from l

</t>
<t tx="ekr.20230509052845.1751">def __len__(self) -&gt; int:
    return self._len

</t>
<t tx="ekr.20230509052845.1752">def __bool__(self) -&gt; bool:
    return self._len &gt; 0
</t>
<t tx="ekr.20230509052845.1753">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import bisect
import random
from math import frexp as _frexp, floor as _floor, fabs as _fabs, erf as _erf
from math import (
    gcd as _gcd,
    exp as _exp,
    log as _log,
    sqrt as _sqrt,
    tau as _tau,
    hypot as _hypot,
)

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1754">class StatisticsError(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("StatisticsError", message)

</t>
<t tx="ekr.20230509052845.1755">def median(data: List[T], T: type) -&gt; float:
    """
    Return the median (middle value) of numeric data.

    When the number of data points is odd, return the middle data point.
    When the number of data points is even, the median is interpolated by
    taking the average of the two middle values
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    if n % 2 == 1:
        return float(data[n // 2])
    else:
        i = n // 2
        return (data[i - 1] + data[i]) / 2

</t>
<t tx="ekr.20230509052845.1756">def median_low(data: List[T], T: type) -&gt; float:
    """
    Return the low median of numeric data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the smaller of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    if n % 2 == 1:
        return float(data[n // 2])
    else:
        return float(data[n // 2 - 1])

</t>
<t tx="ekr.20230509052845.1757">def median_high(data: List[T], T: type) -&gt; float:
    """
    Return the high median of data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the larger of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    return float(data[n // 2])

</t>
<t tx="ekr.20230509052845.1758">def _find_lteq(a: List[T], x: float, T: type):
    """
    Locate the leftmost value exactly equal to x
    """
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    assert False

</t>
<t tx="ekr.20230509052845.1759">def _find_rteq(a: List[T], l: int, x: float, T: type):
    """
    Locate the rightmost value exactly equal to x
    """
    i = bisect.bisect_right(a, x, lo=l)
    if i != (len(a) + 1) and a[i - 1] == x:
        return i - 1
    assert False

</t>
<t tx="ekr.20230509052845.176">@path C:/Repos/codon/bench/mandelbrot/
import time
MAX    = 1000  # maximum Mandelbrot iterations
N      = 4096  # width and height of image
pixels = [0 for _ in range(N * N)]

@others
t0 = time.time()
for i in range(N):
    for j in range(N):
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        pixels[i*N + j] = int(255 * iteration/MAX)
print(sum(pixels))
print(time.time() - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1760">def median_grouped(data: List[T], interval: S = 1, T: type, S: type = int) -&gt; float:
    """
    Return the 50th percentile (median) of grouped continuous data.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    elif n == 1:
        return float(data[0])

    # Find the value at the midpoint.
    x = float(data[n // 2])
    L = x - float(interval) / 2  # The lower limit of the median interval.

    # Find the position of leftmost occurrence of x in data
    l1 = _find_lteq(data, x)
    # Find the position of rightmost occurrence of x in data[l1...len(data)]
    # Assuming always l1 &lt;= l2
    l2 = _find_rteq(data, l1, x)
    cf = l1
    f = l2 - l1 + 1
    return L + interval * (n / 2 - cf) / f

</t>
<t tx="ekr.20230509052845.1761">def mode(data: List[T], T: type) -&gt; T:
    """
    Return the most common data point from discrete or nominal data.
    """
    counter = 0
    elem = data[0]

    for i in data:
        curr_frequency = data.count(i)
        if curr_frequency &gt; counter:
            counter = curr_frequency
            elem = i
    return elem

</t>
<t tx="ekr.20230509052845.1762">def multimode(data: List[T], T: type):
    """
    Return a list of the most frequently occurring values.

    Will return more than one result if there are multiple modes
    or an empty list if *data* is empty.
    """
    elem = data[0]
    counter = data.count(elem)
    li = sorted(data)
    mulmode = []

    for i in li:
        curr_frequency = data.count(i)
        if curr_frequency &gt; counter:
            mulmode = []
            mulmode.append(i)
            counter = curr_frequency
        elif curr_frequency == counter and i not in mulmode:
            mulmode.append(i)
    return mulmode

</t>
<t tx="ekr.20230509052845.1763">def quantiles(
    data: List[T], n: int = 4, method: str = "exclusive", T: type
) -&gt; List[float]:
    """
    Divide *data* into *n* continuous intervals with equal probability.

    Returns a list of (n - 1) cut points separating the intervals.

    Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
    Set *n* to 100 for percentiles which gives the 99 cuts points that
    separate *data* into 100 equal sized groups.

    The *data* can be any iterable containing sample.
    The cut points are linearly interpolated between data points.

    If *method* is set to *inclusive*, *data* is treated as population
    data.  The minimum value is treated as the 0th percentile and the
    maximum value is treated as the 100th percentile.
    """
    if n &lt; 1:
        raise StatisticsError("n must be at least 1")
    data = sorted(data)
    ld = len(data)
    if ld &lt; 2:
        raise StatisticsError("must have at least two data points")

    if method == "inclusive":
        m = ld - 1
        result = []
        for i in range(1, n):
            j = i * m // n
            delta = (i * m) - (j * n)
            interpolated = (data[j] * (n - delta) + data[j + 1] * delta) / n
            result.append(interpolated)
        return result
    if method == "exclusive":
        m = ld + 1
        result = []
        for i in range(1, n):
            j = i * m // n  # rescale i to m/n
            j = 1 if j &lt; 1 else ld - 1 if j &gt; ld - 1 else j  # clamp to 1 .. ld-1
            delta = (i * m) - (j * n)  # exact integer math
            interpolated = (data[j - 1] * (n - delta) + data[j] * delta) / n
            result.append(interpolated)
        return result
    raise ValueError(f"Unknown method: {method}")

</t>
<t tx="ekr.20230509052845.1764">def _lcm(x: int, y: int):
    """
    Returns the lowest common multiple between x and y
    """
    greater = 0
    if x &gt; y:
        greater = x
    else:
        greater = y

    while True:
        if greater % x == 0 and greater % y == 0:
            lcm = greater
            return lcm
        greater += 1

</t>
<t tx="ekr.20230509052845.1765">def _sum(data: List[float]) -&gt; float:
    """
    Return a high-precision sum of the given numeric data as a fraction,
    together with the type to be converted to and the count of items.

    If optional argument ``start`` is given, it is added to the total.
    If ``data`` is empty, ``start`` (defaulting to 0) is returned.

    TODO/CAVEATS
      - The start argument should default to 0 or 0.0
      - Assumes input is floats
    """
    # Neumaier sum
    # https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements
    # https://www.mat.univie.ac.at/~neum/scan/01.pdf (German)
    s = 0.0
    c = 0.0
    i = 0
    N = len(data)
    while i &lt; N:
        x = data[i]
        t = s + x
        if abs(s) &gt;= abs(x):
            c += (s - t) + x
        else:
            c += (x - t) + s
        s = t
        i += 1
    return s + c

</t>
<t tx="ekr.20230509052845.1766">def mean(data: List[float]) -&gt; float:
    """
    Return the sample arithmetic mean of data.

    TODO/CAVEATS
      - Assumes input is floats
      - Does not address NAN or INF
    """
    n = len(data)
    if n &lt; 1:
        raise StatisticsError("mean requires at least one data point")
    total = _sum(data)
    return total / n

</t>
<t tx="ekr.20230509052845.1767">'''
def fmean(data: List[float]) -&gt; float:
    """
    Convert data to floats and compute the arithmetic mean.

    TODO/CAVEATS
    @jordan- fsum is not implemented in math.seq yet and the above
             mean(data) deals with only floats. Thus this function is passed for now.
    """
    pass
'''

</t>
<t tx="ekr.20230509052845.1768">def geometric_mean(data: List[float]) -&gt; float:
    """
    Convert data to floats and compute the geometric mean.

    Raises a StatisticsError if the input dataset is empty,

    TODO/CAVEATS:
      - Assumes input is a list of floats
      - Uses mean instead of fmean for now
      - Does not handle data that contains a zero, or if it contains a negative value.
    """
    if len(data) &lt; 1:
        raise StatisticsError("geometric mean requires a non-empty dataset")
    return _exp(mean(list(map(_log, data))))

</t>
<t tx="ekr.20230509052845.1769">def _fail_neg(values: List[float], errmsg: str):
    """
    Iterate over values, failing if any are less than zero.
    """
    for x in values:
        if x &lt; 0:
            raise StatisticsError(errmsg)
        yield x

</t>
<t tx="ekr.20230509052845.177">def scale(x, a, b):
    return a + (x/N)*(b - a)

</t>
<t tx="ekr.20230509052845.1770">def harmonic_mean(data: List[float]) -&gt; float:
    """
    Return the harmonic mean of data.

    The harmonic mean, sometimes called the subcontrary mean, is the
    reciprocal of the arithmetic mean of the reciprocals of the data,
    and is often appropriate when averaging quantities which are rates
    or ratios.
    """
    errmsg = "harmonic mean does not support negative values"
    n = len(data)
    if n &lt; 1:
        raise StatisticsError("harmonic_mean requires at least one data point")

    x = data[0]

    if n == 1:
        return x
    total = 0.0

    li = List[float](n)
    for x in _fail_neg(data, errmsg):
        if x == 0.0:
            return 0.0
        li.append(1 / x)
    total = _sum(li)
    return n / total

</t>
<t tx="ekr.20230509052845.1771">def _ss(data: List[float], c: float):
    """
    Return sum of square deviations of sequence data.

    If c is None, the mean is calculated in one pass, and the deviations
    from the mean are calculated in a second pass. Otherwise, deviations are
    calculated from c as given.
    """
    total = _sum([(x - c) ** 2 for x in data])
    total2 = _sum([(x - c) for x in data])

    total -= total2 ** 2 / len(data)
    return total

</t>
<t tx="ekr.20230509052845.1772">def pvariance(data: List[float], mu: Optional[float] = None):
    """
    Return the population variance of `data`.

    Should contain atleast one value.
    The optional argument mu, if given, should be the mean of
    the data. If it is missing or None, the mean is automatically calculated.

    TODO/CAVEATS:
      - Assumes input is a list of floats
    """
    if mu is None:
        mu = mean(data)

    n = len(data)
    if n &lt; 1:
        raise StatisticsError("pvariance requires at least one data point")

    ss = _ss(data, mu)
    return ss / n

</t>
<t tx="ekr.20230509052845.1773">def pstdev(data: List[float], mu: Optional[float] = None):
    """
    Return the square root of the population variance.
    """
    if mu is None:
        mu = mean(data)
    var = pvariance(data, mu)
    return _sqrt(var)

</t>
<t tx="ekr.20230509052845.1774">def variance(data: List[float], xbar: Optional[float] = None):
    """
    Return the sample variance of data.

    Shoulw contain atleast two values.
    The optional argument xbar, if given, should be the mean of
    the data. If it is missing or None, the mean is automatically calculated.
    """
    if xbar is None:
        xbar = mean(data)
    n = len(data)
    if n &lt; 2:
        raise StatisticsError("variance requires at least two data points")
    ss = _ss(data, xbar)
    return ss / (n - 1)

</t>
<t tx="ekr.20230509052845.1775">def stdev(data, xbar: Optional[float] = None):
    """
    Return the square root of the sample variance.
    """
    if xbar is None:
        xbar = mean(data)
    var = variance(data, xbar)
    return _sqrt(var)

</t>
<t tx="ekr.20230509052845.1776">class NormalDist:
    """
    Normal distribution of a random variable
    """

    PRECISION: float
    _mu: float
    _sigma: float

    @others
</t>
<t tx="ekr.20230509052845.1777">def __eq__(self, other: NormalDist):
    return (self._mu - other._mu) &lt; self.PRECISION and (
        self._sigma - other._sigma
    ) &lt; self.PRECISION

</t>
<t tx="ekr.20230509052845.1778">def _init(self, mu: float, sigma: float):
    self.PRECISION = 1e-6
    if sigma &lt; 0.0:
        raise StatisticsError("sigma must be non-negative")
    self._mu = mu
    self._sigma = sigma

</t>
<t tx="ekr.20230509052845.1779">def __init__(self, mu, sigma):
    self._init(float(mu), float(sigma))

</t>
<t tx="ekr.20230509052845.178"></t>
<t tx="ekr.20230509052845.1780">def __init__(self, mu):
    self._init(float(mu), 1.0)

</t>
<t tx="ekr.20230509052845.1781">def __init__(self):
    self._init(0.0, 1.0)

</t>
<t tx="ekr.20230509052845.1782">@property
def mean(self):
    """
    Arithmetic mean of the normal distribution.
    """
    return self._mu

</t>
<t tx="ekr.20230509052845.1783">@property
def median(self):
    """
    Return the median of the normal distribution
    """
    return self._mu

</t>
<t tx="ekr.20230509052845.1784">@property
def mode(self):
    """
    Return the mode of the normal distribution

    The mode is the value x where which the probability density
    function (pdf) takes its maximum value.
    """
    return self._mu

</t>
<t tx="ekr.20230509052845.1785">@property
def stdev(self):
    """
    Standard deviation of the normal distribution.
    """
    return self._sigma

</t>
<t tx="ekr.20230509052845.1786">@property
def variance(self):
    """
    Square of the standard deviation.
    """
    return self._sigma ** 2.0

</t>
<t tx="ekr.20230509052845.1787">def pdf(self, x):
    """
    Probability density function.  P(x &lt;= X &lt; x+dx) / dx
    """
    variance = self._sigma ** 2.0
    if not variance:
        raise StatisticsError("pdf() not defined when sigma is zero")
    return _exp((x - self._mu) ** 2.0 / (-2.0 * variance)) / _sqrt(_tau * variance)

</t>
<t tx="ekr.20230509052845.1788">def cdf(self, x):
    """
    Cumulative distribution function.  P(X &lt;= x)
    """
    if not self._sigma:
        raise StatisticsError("cdf() not defined when sigma is zero")
    return 0.5 * (1.0 + _erf((x - self._mu) / (self._sigma * _sqrt(2.0))))

</t>
<t tx="ekr.20230509052845.1789">def _normal_dist_inv_cdf(self, p: float, mu: float, sigma: float):
    """
    Wichura, M.J. (1988). "Algorithm AS241: The Percentage Points of the
    Normal Distribution".  Applied Statistics. Blackwell Publishing. 37
    (3): 477484. doi:10.2307/2347330. JSTOR 2347330.
    """
    q = p - 0.5
    num = 0.0
    den = 0.0
    if _fabs(q) &lt;= 0.425:
        r = 0.180625 - q * q
        # Hash sum: 55.88319_28806_14901_4439
        num = (((((((2.5090809287301226727e+3 * r +
                3.3430575583588128105e+4) * r +
                6.7265770927008700853e+4) * r +
                4.5921953931549871457e+4) * r +
                1.3731693765509461125e+4) * r +
                1.9715909503065514427e+3) * r +
                1.3314166789178437745e+2) * r +
                3.3871328727963666080e+0) * q
        den = (((((((5.2264952788528545610e+3 * r +
                2.8729085735721942674e+4) * r +
                3.9307895800092710610e+4) * r +
                2.1213794301586595867e+4) * r +
                5.3941960214247511077e+3) * r +
                6.8718700749205790830e+2) * r +
                4.2313330701600911252e+1) * r +
                1.0)
        x = num / den
        return mu + (x * sigma)
    r = p if q &lt;= 0.0 else 1.0 - p
    r = _sqrt(-_log(r))
    if r &lt;= 5.0:
        r = r - 1.6
        # Hash sum: 49.33206_50330_16102_89036
        num = (((((((7.74545014278341407640e-4 * r +
                2.27238449892691845833e-2) * r +
                2.41780725177450611770e-1) * r +
                1.27045825245236838258e+0) * r +
                3.64784832476320460504e+0) * r +
                5.76949722146069140550e+0) * r +
                4.63033784615654529590e+0) * r +
                1.42343711074968357734e+0)
        den = (((((((1.05075007164441684324e-9 * r +
                5.47593808499534494600e-4) * r +
                1.51986665636164571966e-2) * r +
                1.48103976427480074590e-1) * r +
                6.89767334985100004550e-1) * r +
                1.67638483018380384940e+0) * r +
                2.05319162663775882187e+0) * r +
                1.0)
    else:
        r = r - 5.0
        # Hash sum: 47.52583_31754_92896_71629
        num = (((((((2.01033439929228813265e-7 * r +
                2.71155556874348757815e-5) * r +
                1.24266094738807843860e-3) * r +
                2.65321895265761230930e-2) * r +
                2.96560571828504891230e-1) * r +
                1.78482653991729133580e+0) * r +
                5.46378491116411436990e+0) * r +
                6.65790464350110377720e+0)
        den = (((((((2.04426310338993978564e-15 * r +
                1.42151175831644588870e-7) * r +
                1.84631831751005468180e-5) * r +
                7.86869131145613259100e-4) * r +
                1.48753612908506148525e-2) * r +
                1.36929880922735805310e-1) * r +
                5.99832206555887937690e-1) * r +
                1.0)
    x = num / den
    if q &lt; 0.0:
        x = -x
    return mu + (x * sigma)

</t>
<t tx="ekr.20230509052845.179">@path C:/Repos/codon/bench/nbody/
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# originally by Kevin Carson
# modified by Tupteq, Fredrik Johansson, and Daniel Nanz
# modified by Maciej Fijalkowski
# modified by @arshajii
# 2to3

from time import time
import sys

@others
t0 = time()
main(int(sys.argv[1]))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1790">def inv_cdf(self, p: float):
    """
    Inverse cumulative distribution function.  x : P(X &lt;= x) = p

    Finds the value of the random variable such that the probability of
    the variable being less than or equal to that value equals the given
    probability.
    """
    if p &lt;= 0.0 or p &gt;= 1.0:
        raise StatisticsError("p must be in the range 0.0 &lt; p &lt; 1.0")
    if self._sigma &lt;= 0.0:
        raise StatisticsError("cdf() not defined when sigma at or below zero")
    return self._normal_dist_inv_cdf(p, self._mu, self._sigma)

</t>
<t tx="ekr.20230509052845.1791">def quantiles(self, n: int = 4):
    """
    Divide into *n* continuous intervals with equal probability.

    Returns a list of (n - 1) cut points separating the intervals.

    Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
    Set *n* to 100 for percentiles which gives the 99 cuts points that
    separate the normal distribution into 100 equal sized groups.
    """
    return [self.inv_cdf(float(i) / float(n)) for i in range(1, n)]

</t>
<t tx="ekr.20230509052845.1792">def overlap(self, other: NormalDist) -&gt; float:
    """
    Compute the overlapping coefficient (OVL) between two normal distributions.

    Measures the agreement between two normal probability distributions.
    Returns a value between 0.0 and 1.0 giving the overlapping area in
    the two underlying probability density functions.
    """
    X, Y = self, other

    if (Y._sigma, Y._mu) &lt; (X._sigma, X._mu):  # sort to assure commutativity
        X, Y = Y, X

    X_var, Y_var = X.variance, Y.variance

    if not X_var or not Y_var:
        raise StatisticsError("overlap() not defined when sigma is zero")

    dv = Y_var - X_var
    dm = _fabs(Y._mu - X._mu)

    if not dv:
        return 1.0 - _erf(dm / (2.0 * X._sigma * _sqrt(2.0)))

    a = X._mu * Y_var - Y._mu * X_var
    b = X._sigma * Y._sigma * _sqrt(dm ** 2.0 + dv * _log(Y_var / X_var))
    x1 = (a + b) / dv
    x2 = (a - b) / dv

    return 1.0 - (_fabs(Y.cdf(x1) - X.cdf(x1)) + _fabs(Y.cdf(x2) - X.cdf(x2)))

</t>
<t tx="ekr.20230509052845.1793">def samples(self, n: int):
    """
    Generate *n* samples for a given mean and standard deviation.
    """
    gauss = random.gauss
    return [gauss(self._mu, self._sigma) for i in range(n)]

</t>
<t tx="ekr.20230509052845.1794">def from_samples(data: List[float]):
    """
    Make a normal distribution instance from sample data.
    TODO/CAVEATS:
      - Assumes input is a list of floats
      - Uses mean instead of fmean for now
    """
    xbar = mean(data)
    return NormalDist(xbar, stdev(data, xbar))

</t>
<t tx="ekr.20230509052845.1795">def __add__(x1: NormalDist, x2: NormalDist):
    """
    Add a constant or another NormalDist instance.
    If *other* is a constant, translate mu by the constant,
    leaving sigma unchanged.
    If *other* is a NormalDist, add both the means and the variances.
    Mathematically, this works only if the two distributions are
    independent or if they are jointly normally distributed.
    """
    return NormalDist(x1._mu + x2._mu, _hypot(x1._sigma, x2._sigma))

</t>
<t tx="ekr.20230509052845.1796">def __add__(x1: NormalDist, x2: float):
    """
    Add a constant or another NormalDist instance.
    If *other* is a constant, translate mu by the constant,
    leaving sigma unchanged.
    If *other* is a NormalDist, add both the means and the variances.
    Mathematically, this works only if the two distributions are
    independent or if they are jointly normally distributed.
    """
    return NormalDist(x1._mu + x2, x1._sigma)

</t>
<t tx="ekr.20230509052845.1797">def __sub__(x1: NormalDist, x2: NormalDist):
    """
    Subtract a constant or another NormalDist instance.
    If *other* is a constant, translate by the constant mu,
    leaving sigma unchanged.
    If *other* is a NormalDist, subtract the means and add the variances.
    Mathematically, this works only if the two distributions are
    independent or if they are jointly normally distributed.
    """
    return NormalDist(x1._mu - x2._mu, _hypot(x1._sigma, x2._sigma))

</t>
<t tx="ekr.20230509052845.1798">def __sub__(x1: NormalDist, x2: float):
    """
    Subtract a constant or another NormalDist instance.
    If *other* is a constant, translate by the constant mu,
    leaving sigma unchanged.
    If *other* is a NormalDist, subtract the means and add the variances.
    Mathematically, this works only if the two distributions are
    independent or if they are jointly normally distributed.
    """
    return NormalDist(x1._mu - x2, x1._sigma)

</t>
<t tx="ekr.20230509052845.1799">def __mul__(x1: NormalDist, x2: float):
    """
    Multiply both mu and sigma by a constant.
    Used for rescaling, perhaps to change measurement units.
    Sigma is scaled with the absolute value of the constant.
    """
    return NormalDist(x1._mu * x2, x1._sigma * _fabs(x2))

</t>
<t tx="ekr.20230509052845.18"></t>
<t tx="ekr.20230509052845.180">def combinations(l):
    result = []
    for x in range(len(l) - 1):
        ls = l[x+1:]
        for y in ls:
            result.append((l[x],y))
    return result

</t>
<t tx="ekr.20230509052845.1800">def __truediv__(x1: NormalDist, x2: float):
    """
    Divide both mu and sigma by a constant.
    Used for rescaling, perhaps to change measurement units.
    Sigma is scaled with the absolute value of the constant.
    """
    return NormalDist(x1._mu / x2, x1._sigma / _fabs(x2))

</t>
<t tx="ekr.20230509052845.1801">def __pos__(x1: NormalDist):
    return NormalDist(x1._mu, x1._sigma)

</t>
<t tx="ekr.20230509052845.1802">def __neg__(x1: NormalDist):
    return NormalDist(-x1._mu, x1._sigma)

</t>
<t tx="ekr.20230509052845.1803">def __radd__(x1: NormalDist, x2: float):
    return x1 + x2

</t>
<t tx="ekr.20230509052845.1804">def __rsub__(x1: NormalDist, x2: NormalDist):
    return -(x1 - x2)

</t>
<t tx="ekr.20230509052845.1805">def __rmul__(x1: NormalDist, x2: float):
    return x1 * x2

</t>
<t tx="ekr.20230509052845.1806">def __eq__(x1: NormalDist, x2: NormalDist):
    return x1._mu == x2._mu and x1._sigma == x2._sigma

</t>
<t tx="ekr.20230509052845.1807">def __hash__(self):
    return hash((self._mu, self._sigma))

</t>
<t tx="ekr.20230509052845.1808">def __repr__(self):
    return f"NormalDist(mu={self._mu}, sigma={self._sigma})"
</t>
<t tx="ekr.20230509052845.1809">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

ascii_letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
ascii_lowercase = "abcdefghijklmnopqrstuvwxyz"
ascii_uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

digits = "0123456789"
hexdigits = "0123456789abcdefABCDEF"
octdigits = "01234567"

punctuation = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"
printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \t\n\r\x0b\x0c"
whitespace = " \t\n\r\x0b\x0c"
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.181">PI = 3.14159265358979323
SOLAR_MASS = 4 * PI * PI
DAYS_PER_YEAR = 365.24

BODIES = {
    'sun': ([0.0, 0.0, 0.0], [0.0, 0.0, 0.0], SOLAR_MASS),

    'jupiter': ([4.84143144246472090e+00,
                 -1.16032004402742839e+00,
                 -1.03622044471123109e-01],
                [1.66007664274403694e-03 * DAYS_PER_YEAR,
                 7.69901118419740425e-03 * DAYS_PER_YEAR,
                 -6.90460016972063023e-05 * DAYS_PER_YEAR],
                9.54791938424326609e-04 * SOLAR_MASS),

    'saturn': ([8.34336671824457987e+00,
                4.12479856412430479e+00,
                -4.03523417114321381e-01],
               [-2.76742510726862411e-03 * DAYS_PER_YEAR,
                4.99852801234917238e-03 * DAYS_PER_YEAR,
                2.30417297573763929e-05 * DAYS_PER_YEAR],
               2.85885980666130812e-04 * SOLAR_MASS),

    'uranus': ([1.28943695621391310e+01,
                -1.51111514016986312e+01,
                -2.23307578892655734e-01],
               [2.96460137564761618e-03 * DAYS_PER_YEAR,
                2.37847173959480950e-03 * DAYS_PER_YEAR,
                -2.96589568540237556e-05 * DAYS_PER_YEAR],
               4.36624404335156298e-05 * SOLAR_MASS),

    'neptune': ([1.53796971148509165e+01,
                 -2.59193146099879641e+01,
                 1.79258772950371181e-01],
                [2.68067772490389322e-03 * DAYS_PER_YEAR,
                 1.62824170038242295e-03 * DAYS_PER_YEAR,
                 -9.51592254519715870e-05 * DAYS_PER_YEAR],
                5.15138902046611451e-05 * SOLAR_MASS) }


SYSTEM = list(BODIES.values())
PAIRS = combinations(SYSTEM)


</t>
<t tx="ekr.20230509052845.1810">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

argv = list(__argv__, len(__argv__))

stdin = File(_C.seq_stdin())
stdout = File(_C.seq_stdout())
stderr = File(_C.seq_stderr())

@others
maxsize = 0x7FFFFFFFFFFFFFFF
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1811">def exit(status: int = 0):
    raise SystemExit(status)

</t>
<t tx="ekr.20230509052845.1812">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1813">@tuple
class Lock:
    p: cobj

    @others
</t>
<t tx="ekr.20230509052845.1814">def __new__() -&gt; Lock:
    return (_C.seq_lock_new(),)

</t>
<t tx="ekr.20230509052845.1815">def acquire(self, block: bool = True, timeout: float = -1.0) -&gt; bool:
    if timeout &gt;= 0.0 and not block:
        raise ValueError("can't specify a timeout for a non-blocking call")
    return _C.seq_lock_acquire(self.p, block, timeout)

</t>
<t tx="ekr.20230509052845.1816">def release(self):
    _C.seq_lock_release(self.p)

</t>
<t tx="ekr.20230509052845.1817">def __enter__(self):
    self.acquire()

</t>
<t tx="ekr.20230509052845.1818">def __exit__(self):
    self.release()

</t>
<t tx="ekr.20230509052845.1819">@tuple
class RLock:
    p: cobj

    @others
</t>
<t tx="ekr.20230509052845.182">def advance(dt, n, bodies=SYSTEM, pairs=PAIRS):

    for i in range(n):
        for (([x1, y1, z1], v1, m1),
             ([x2, y2, z2], v2, m2)) in pairs:
            dx = x1 - x2
            dy = y1 - y2
            dz = z1 - z2
            mag = dt * ((dx * dx + dy * dy + dz * dz) ** (-1.5))
            b1m = m1 * mag
            b2m = m2 * mag
            v1[0] -= dx * b2m
            v1[1] -= dy * b2m
            v1[2] -= dz * b2m
            v2[0] += dx * b1m
            v2[1] += dy * b1m
            v2[2] += dz * b1m
        for (r, [vx, vy, vz], m) in bodies:
            r[0] += dt * vx
            r[1] += dt * vy
            r[2] += dt * vz


</t>
<t tx="ekr.20230509052845.1820">def __new__() -&gt; RLock:
    return (_C.seq_rlock_new(),)

</t>
<t tx="ekr.20230509052845.1821">def acquire(self, block: bool = True, timeout: float = -1.0) -&gt; bool:
    if timeout &gt;= 0.0 and not block:
        raise ValueError("can't specify a timeout for a non-blocking call")
    return _C.seq_rlock_acquire(self.p, block, timeout)

</t>
<t tx="ekr.20230509052845.1822">def release(self):
    _C.seq_rlock_release(self.p)

</t>
<t tx="ekr.20230509052845.1823">def __enter__(self):
    self.acquire()

</t>
<t tx="ekr.20230509052845.1824">def __exit__(self):
    self.release()

</t>
<t tx="ekr.20230509052845.1825">def active_count() -&gt; int:
    from openmp import get_num_threads
    return get_num_threads()

</t>
<t tx="ekr.20230509052845.1826">def get_native_id() -&gt; int:
    from openmp import get_thread_num
    return get_thread_num()

</t>
<t tx="ekr.20230509052845.1827">def get_ident() -&gt; int:
    return get_native_id() + 1
</t>
<t tx="ekr.20230509052845.1828">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from sys import stderr

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1829">def time() -&gt; float:
    return _C.seq_time() / 1e9

</t>
<t tx="ekr.20230509052845.183">def report_energy(bodies=SYSTEM, pairs=PAIRS, e=0.0):

    for (((x1, y1, z1), v1, m1),
         ((x2, y2, z2), v2, m2)) in pairs:
        dx = x1 - x2
        dy = y1 - y2
        dz = z1 - z2
        e -= (m1 * m2) / ((dx * dx + dy * dy + dz * dz) ** 0.5)
    for (r, [vx, vy, vz], m) in bodies:
        e += m * (vx * vx + vy * vy + vz * vz) / 2.
    print(e)

</t>
<t tx="ekr.20230509052845.1830">def time_ns() -&gt; int:
    return _C.seq_time()

</t>
<t tx="ekr.20230509052845.1831">def monotonic() -&gt; float:
    return _C.seq_time_monotonic() / 1e9

</t>
<t tx="ekr.20230509052845.1832">def monotonic_ns() -&gt; int:
    return _C.seq_time_monotonic()

</t>
<t tx="ekr.20230509052845.1833">def perf_counter() -&gt; float:
    return _C.seq_time_highres() / 1e9

</t>
<t tx="ekr.20230509052845.1834">def perf_counter_ns() -&gt; int:
    return _C.seq_time_highres()

</t>
<t tx="ekr.20230509052845.1835">def sleep(secs: float):
    if secs &lt; 0:
        raise ValueError("sleep length must be non-negative")
    _C.seq_sleep(secs)

</t>
<t tx="ekr.20230509052845.1836">class TimeInterval:
    """
    Utility class for timing Seq code
    """

    start: int
    msg: str

    @others
</t>
<t tx="ekr.20230509052845.1837">def __init__(self):
    self.start = _C.seq_time()
    self.msg = ""

</t>
<t tx="ekr.20230509052845.1838">def __enter__(self):
    self.start = _C.seq_time()

</t>
<t tx="ekr.20230509052845.1839">def __exit__(self):
    print(self.report(self.msg), file=stderr)

</t>
<t tx="ekr.20230509052845.184">def offset_momentum(ref, bodies=SYSTEM, px=0.0, py=0.0, pz=0.0):

    for (r, [vx, vy, vz], m) in bodies:
        px -= vx * m
        py -= vy * m
        pz -= vz * m
    (r, v, m) = ref
    v[0] = px / m
    v[1] = py / m
    v[2] = pz / m

</t>
<t tx="ekr.20230509052845.1840">def report(self, msg="", memory=False) -&gt; str:
    msg = f"{'Block' if not self.msg else self.msg} took {self.elapsed()}s"
    # if memory:
    # msg = f'{msg} ({_C.memory()} MB)'
    return msg

</t>
<t tx="ekr.20230509052845.1841">def elapsed(self) -&gt; float:
    return float(_C.seq_time() - self.start) / 1e9

</t>
<t tx="ekr.20230509052845.1842">def tick(self, msg, memory=False):
    ret = self.report(msg)
    self.start = _C.seq_time()

</t>
<t tx="ekr.20230509052845.1843">def timing(msg: str = "") -&gt; TimeInterval:
    """
    Example usage:

    .. code-block:: python

        from time import timing
        with timing('foo function'):
            foo()  # prints runtime of foo
    """
    return TimeInterval(0, msg)

</t>
<t tx="ekr.20230509052845.1844">@tuple
class struct_time:
    _year: i16
    _yday: i16
    _sec: i8
    _min: i8
    _hour: i8
    _mday: i8
    _mon: i8
    _wday: i8
    _isdst: i8

    @others
</t>
<t tx="ekr.20230509052845.1845"># (sunday=0) --&gt; (monday=0)
def _wday_adjust_monday_start(wday: int) -&gt; int:
    x = wday - 1
    if x &lt; 0:
        x = 6
    return x

</t>
<t tx="ekr.20230509052845.1846"># (monday=0) --&gt; (sunday=0)
def _wday_adjust_sunday_start(wday: int) -&gt; int:
    x = wday + 1
    if x &gt; 6:
        x = 0
    return x

</t>
<t tx="ekr.20230509052845.1847">def __new__(
    year: int,
    mon: int,
    mday: int,
    hour: int,
    min: int,
    sec: int,
    wday: int,
    yday: int,
    isdst: int,
) -&gt; struct_time:
    return struct_time(
        i16(year - 1900),
        i16(yday - 1),
        i8(sec),
        i8(min),
        i8(hour),
        i8(mday),
        i8(mon - 1),
        i8(struct_time._wday_adjust_sunday_start(wday)),
        i8(isdst),
    )

</t>
<t tx="ekr.20230509052845.1848">@property
def tm_year(self) -&gt; int:
    return int(self._year) + 1900

</t>
<t tx="ekr.20230509052845.1849">@property
def tm_yday(self) -&gt; int:
    return int(self._yday) + 1

</t>
<t tx="ekr.20230509052845.185">def main(n, ref='sun'):
    offset_momentum(BODIES[ref])
    report_energy()
    advance(0.01, n)
    report_energy()

</t>
<t tx="ekr.20230509052845.1850">@property
def tm_sec(self) -&gt; int:
    return int(self._sec)

</t>
<t tx="ekr.20230509052845.1851">@property
def tm_min(self) -&gt; int:
    return int(self._min)

</t>
<t tx="ekr.20230509052845.1852">@property
def tm_hour(self) -&gt; int:
    return int(self._hour)

</t>
<t tx="ekr.20230509052845.1853">@property
def tm_mday(self) -&gt; int:
    return int(self._mday)

</t>
<t tx="ekr.20230509052845.1854">@property
def tm_mon(self) -&gt; int:
    return int(self._mon) + 1

</t>
<t tx="ekr.20230509052845.1855">@property
def tm_wday(self) -&gt; int:
    return struct_time._wday_adjust_monday_start(int(self._wday))

</t>
<t tx="ekr.20230509052845.1856">@property
def tm_isdst(self) -&gt; int:
    return int(self._isdst)


</t>
<t tx="ekr.20230509052845.1857">def localtime(secs: int = -1) -&gt; struct_time:
    tm = struct_time()
    worked = _C.seq_localtime(secs, __ptr__(tm).as_byte())
    if not worked:
        raise OSError("localtime failed")
    return tm


</t>
<t tx="ekr.20230509052845.1858">def gmtime(secs: int = -1) -&gt; struct_time:
    tm = struct_time()
    worked = _C.seq_gmtime(secs, __ptr__(tm).as_byte())
    if not worked:
        raise OSError("localtime failed")
    return tm


</t>
<t tx="ekr.20230509052845.1859">def mktime(t) -&gt; int:
    if isinstance(t, struct_time):
        return _C.seq_mktime(__ptr__(t).as_byte())
    else:
        tm = struct_time(*t)
        return _C.seq_mktime(__ptr__(tm).as_byte())

</t>
<t tx="ekr.20230509052845.186"></t>
<t tx="ekr.20230509052845.1860"># pytime.h funcs

_ROUND_HALF_EVEN = 0
_ROUND_CEILING = 1
_ROUND_FLOOR = 2
_ROUND_UP = 3

_MIN = 0x8000000000000000
_MAX = 0x7FFFFFFFFFFFFFFF

</t>
<t tx="ekr.20230509052845.1861">def _overflow():
    raise OverflowError("timestamp too large")

</t>
<t tx="ekr.20230509052845.1862">def _add(t1: int, t2: int) -&gt; int:
    if t2 &gt; 0 and t1 &gt; _MAX - t2:
        return _MAX
    elif t2 &lt; 0 and t1 &lt; _MIN - t2:
        return _MIN
    else:
        return t1 + t2

</t>
<t tx="ekr.20230509052845.1863">def _mul_check_overflow(a: int, b: int) -&gt; bool:
    if b != 0:
        # assert b &gt; 0
        return (a &lt; _MIN // b) or (_MAX // b &lt; a)
    else:
        return False

</t>
<t tx="ekr.20230509052845.1864">def _mul(t: int, k: int) -&gt; int:
    # assert k &gt;= 0
    if _mul_check_overflow(t, k):
        return _MAX if t &gt;= 0 else _MIN
    else:
        return t * k

</t>
<t tx="ekr.20230509052845.1865">def _muldiv(ticks: int, mul: int, div: int) -&gt; int:
    intpart = ticks / div
    ticks %= div
    remaining = _mul(ticks, mul) // div
    return _add(_mul(intpart, mul), remaining)

</t>
<t tx="ekr.20230509052845.1866">def _round_half_even(x: float) -&gt; float:
    from math import fabs

    rounded = x.__round__()
    if fabs(x - rounded) == 0.5:
        rounded = 2.0 * (x / 2.0).__round__()
    return rounded

</t>
<t tx="ekr.20230509052845.1867">def _round(x: float, mode: int) -&gt; float:
    d = x
    if mode == _ROUND_HALF_EVEN:
        d = _round_half_even(d)
    elif mode == _ROUND_CEILING:
        d = d.__ceil__()
    elif mode == _ROUND_FLOOR:
        d = d.__floor__()
    elif mode == _ROUND_UP:
        d = d.__ceil__() if d &gt;= 0 else d.__floor__()
    return d

</t>
<t tx="ekr.20230509052845.1868">def _double_to_denominator(d: float, idenominator: int, mode: int) -&gt; Tuple[int, int]:
    from math import modf

    denominator = float(idenominator)
    floatpart, intpart = modf(d)

    floatpart *= denominator
    floatpart = _round(floatpart, mode)
    if floatpart &gt;= denominator:
        floatpart -= denominator
        intpart += 1.0
    elif floatpart &lt; 0.0:
        floatpart += denominator
        intpart -= 1.0
    # assert 0.0 &lt;= floatpart &lt; denominator

    if intpart &lt; _MIN or intpart &gt; _MAX:
        _overflow()

    sec = int(intpart)
    numerator = int(floatpart)
    # assert 0 &lt;= numerator &lt; idenominator
    return sec, numerator

</t>
<t tx="ekr.20230509052845.1869">def _time_to_timespec(t: float, mode: int) -&gt; Tuple[int, int]:
    return _double_to_denominator(t, 1000000000, mode)

</t>
<t tx="ekr.20230509052845.187">@path C:/Repos/codon/bench/primes/
from sys import argv
from time import time

@others
limit = int(argv[1])
total = 0

t0 = time()
@par(schedule='dynamic')
for i in range(2, limit):
    if is_prime(i):
        total += 1
t1 = time()

print(total)
print(t1 - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1870">def _time_to_timeval(t: float, mode: int) -&gt; Tuple[int, int]:
    return _double_to_denominator(t, 1000000, mode)
</t>
<t tx="ekr.20230509052845.1871">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# (empty)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1872">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Simplified version of Python's unittest.TestCase to allow
# copy/pasting tests directly from CPython's test suite.

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1873">class TestCase:
    @others
</t>
<t tx="ekr.20230509052845.1874">def fail(self, standard_message: str, special_message: str = ""):
    print("TEST FAILED:", special_message if special_message else standard_message)

</t>
<t tx="ekr.20230509052845.1875">def assertTrue(self, obj, msg=""):
    if not bool(obj):
        self.fail(f"expected object to be true: {obj}", msg)

</t>
<t tx="ekr.20230509052845.1876">def assertFalse(self, obj, msg=""):
    if bool(obj):
        self.fail(f"expected object to be false: {obj}", msg)

</t>
<t tx="ekr.20230509052845.1877">def assertEqual(self, first, second, msg=""):
    result = first == second
    if not result:
        self.fail(f"expected equality of:\n  1: {first}\n  2: {second}", msg)

</t>
<t tx="ekr.20230509052845.1878">def assertNotEqual(self, first, second, msg=""):
    result = first != second
    if not result:
        self.fail(f"expected inequality of:\n  1: {first}\n  2: {second}", msg)

</t>
<t tx="ekr.20230509052845.1879">def assertSequenceEqual(self, seq1, seq2, msg=""):
    len1 = len(seq1)
    len2 = len(seq2)
    if len1 != len2:
        self.fail(
            f"expected equality of sequences (len1={len1}, len2={len2}):\n  1: {seq1}\n  2: {seq2}",
            msg,
        )

    for i in range(len1):
        a, b = seq1[i], seq2[i]
        if a != b:
            self.fail(
                f"expected equality of sequences (diff at elem {i}):\n  1: {seq1}\n  2: {seq2}",
                msg,
            )

</t>
<t tx="ekr.20230509052845.188">def is_prime(n):
    factors = 0
    for i in range(2, n):
        if n % i == 0:
            factors += 1
    return factors == 0

</t>
<t tx="ekr.20230509052845.1880">def assertIn(self, member, container, msg=""):
    if member not in container:
        self.fail(f"expected {member} to be in {container}", msg)

</t>
<t tx="ekr.20230509052845.1881">def assertNotIn(self, member, container, msg=""):
    if member in container:
        self.fail(f"expected {member} to not be in {container}", msg)

</t>
<t tx="ekr.20230509052845.1882">def assertIs(self, expr1, expr2, msg=""):
    if expr1 is not expr2:
        self.fail(f"expected {expr1} to be identical to {expr2}", msg)

</t>
<t tx="ekr.20230509052845.1883">def assertIsNot(self, expr1, expr2, msg=""):
    if expr1 is expr2:
        self.fail(f"expected {expr1} to not be identical to {expr2}", msg)

</t>
<t tx="ekr.20230509052845.1884">def assertIsNot(self, expr1, expr2, msg=""):
    if expr1 is expr2:
        self.fail(f"expected {expr1} to not be identical to {expr2}", msg)

</t>
<t tx="ekr.20230509052845.1885">def assertCountEqual(self, first, second, msg=""):
    from collections import Counter

    first_seq, second_seq = list(first), list(second)

    first_counter = Counter(first_seq)
    second_counter = Counter(second_seq)

    if first_counter != second_counter:
        self.fail(f"expected equal counts:\n  1: {first}\n  2: {second}", msg)

</t>
<t tx="ekr.20230509052845.1886">def assertLess(self, a, b, msg=""):
    if not (a &lt; b):
        self.fail(f"expected less-than:\n  1: {a}\n  2: {b}", msg)

</t>
<t tx="ekr.20230509052845.1887">def assertLessEqual(self, a, b, msg=""):
    if not (a &lt;= b):
        self.fail(f"expected less-than-or-equal:\n  1: {a}\n  2: {b}", msg)

</t>
<t tx="ekr.20230509052845.1888">def assertGreater(self, a, b, msg=""):
    if not (a &gt; b):
        self.fail(f"expected greater-than:\n  1: {a}\n  2: {b}", msg)

</t>
<t tx="ekr.20230509052845.1889">def assertGreaterEqual(self, a, b, msg=""):
    if not (a &gt;= b):
        self.fail(f"expected greater-than-or-equal:\n  1: {a}\n  2: {b}", msg)

</t>
<t tx="ekr.20230509052845.189">@path C:/Repos/codon/bench/primes/
from sys import argv
from time import time

@others
limit = int(argv[1])
total = 0

t0 = time()
for i in range(2, limit):
    if is_prime(i):
        total += 1
t1 = time()

print(total)
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1890">def assertIsNone(self, obj, msg=""):
    if obj is not None:
        self.fail(f"expected {obj} to be None", msg)

</t>
<t tx="ekr.20230509052845.1891">def assertIsNotNone(self, obj, msg=""):
    if obj is None:
        self.fail(f"expected {obj} to not be None", msg)

</t>
<t tx="ekr.20230509052845.1892">def assertRaises(self, exception: type, function, *args, **kwargs):
    try:
        function(*args, **kwargs)
    except exception:
        return
    except:
        pass
    self.fail(f"call to function did not raise the given exception")

</t>
<t tx="ekr.20230509052845.1893">def assertAlmostEqual(
    self, first, second, places: int = 0, msg="", delta=None
):
    if first == second:
        # shortcut
        return
    if places &lt;= 0 and delta is None:
        raise ValueError("specify delta or places not both")

    standard_msg = ""
    diff = abs(first - second)
    if delta is not None:
        if diff &lt;= delta:
            return
        standard_msg = (
            f"{first} != {second} within {delta} delta ({diff} difference)"
        )
    else:
        if places &lt;= 0:
            places = 7
        if round(diff, places) == 0:
            return
        standard_msg = (
            f"{first} != {second} within {places} places ({diff} difference)"
        )
    self.fail(standard_msg, msg)
</t>
<t tx="ekr.20230509052845.1894"></t>
<t tx="ekr.20230509052845.1895">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1896">def _heapify(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Makes the array a heap from [begin, end).
    """
    root = begin
    left = 2 * begin + 1
    right = 2 * begin + 2

    if left &lt; end and keyf(arr[root]) &lt; keyf(arr[left]):
        root = left

    if right &lt; end and keyf(arr[root]) &lt; keyf(arr[right]):
        root = right

    if root != begin:
        arr[begin], arr[root] = arr[root], arr[begin]
        _heapify(arr, root, end, keyf)

</t>
<t tx="ekr.20230509052845.1897">def _heap_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    if end - begin &lt; 2:
        return

    arr = arr.slice(begin, end)
    end -= begin
    begin = 0

    i = end // 2 - 1
    while i &gt;= 0:
        _heapify(arr, i, end, keyf)
        i -= 1

    i = end - 1
    while i &gt;= 0:
        arr[i], arr[0] = arr[0], arr[i]
        _heapify(arr, 0, i, keyf)
        i -= 1

</t>
<t tx="ekr.20230509052845.1898">def heap_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Heap Sort
    Sorts the array inplace.
    """
    _heap_sort(collection, 0, size, keyf)

</t>
<t tx="ekr.20230509052845.1899">def heap_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Heap Sort
    Sorts the list inplace.
    """
    heap_sort_array(collection.arr, collection.len, keyf)

</t>
<t tx="ekr.20230509052845.19">@path C:/Repos/codon/bench/chaos/
"""create chaosgame-like fractals
Copyright (C) 2005 Carl Friedrich Bolz

adapted by @arshajii for Codon
"""

import math
import random
import sys
import time

DEFAULT_THICKNESS = 1.0
DEFAULT_WIDTH = 2048 #256
DEFAULT_HEIGHT = 2048 #256
DEFAULT_ITERATIONS = 1000000 #5000
DEFAULT_RNG_SEED = 1234


@others
t0 = time.time()
main()
t1 = time.time()
print(t1 - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.190">def is_prime(n):
    factors = 0
    for i in range(2, n):
        if n % i == 0:
            factors += 1
    return factors == 0

</t>
<t tx="ekr.20230509052845.1900">def heap_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Heap Sort
    Returns a sorted list.
    """
    newlst = collection.__copy__()
    heap_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509052845.1901">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1902">def _insertion_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    i = begin + 1
    while i &lt; end:
        x = arr[i]
        j = i - 1
        while j &gt;= begin and keyf(x) &lt; keyf(arr[j]):
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = x
        i += 1

</t>
<t tx="ekr.20230509052845.1903">def insertion_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Insertion Sort
    Sorts the array inplace.
    """
    _insertion_sort(collection, 0, size, keyf)

</t>
<t tx="ekr.20230509052845.1904">def insertion_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Insertion Sort
    Sorts the list inplace.
    """
    insertion_sort_array(collection.arr, collection.len, keyf)

</t>
<t tx="ekr.20230509052845.1905">def insertion_sort(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
) -&gt; List[T]:
    """
    Insertion Sort
    Returns the sorted list.
    """
    newlst = collection.__copy__()
    insertion_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509052845.1906">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: https://github.com/orlp/pdqsort
# License:
#    Copyright (c) 2021 Orson Peters &lt;orsonpeters@gmail.com&gt;
#
#    This software is provided 'as-is', without any express or implied warranty. In no event will the
#    authors be held liable for any damages arising from the use of this software.
#
#    Permission is granted to anyone to use this software for any purpose, including commercial
#    applications, and to alter it and redistribute it freely, subject to the following restrictions:
#
#    1. The origin of this software must not be misrepresented; you must not claim that you wrote the
#    original software. If you use this software in a product, an acknowledgment in the product
#    documentation would be appreciated but is not required.
#
#    2. Altered source versions must be plainly marked as such, and must not be misrepresented as
#    being the original software.
#
#    3. This notice may not be removed or altered from any source distribution.

INSERTION_SORT_THRESHOLD = 24
NINTHER_THRESHOLD = 128
PARTIAL_INSERTION_SORT_LIMIT = 8

from algorithms.insertionsort import _insertion_sort
from algorithms.heapsort import _heap_sort

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1907">def _floor_log2(n: int) -&gt; int:
    """Returns floor(log2(n))"""
    log = 0
    while True:
        n &gt;&gt;= 1
        if n == 0:
            break
        log += 1
    return log

</t>
<t tx="ekr.20230509052845.1908">def _partial_insertion_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; bool:
    if begin == end:
        return True

    limit = 0
    cur = begin + 1
    while cur != end:
        if limit &gt; PARTIAL_INSERTION_SORT_LIMIT:
            return False

        sift = cur
        sift_1 = cur - 1

        if keyf(arr[sift]) &lt; keyf(arr[sift_1]):
            tmp = arr[sift]

            while True:
                arr[sift] = arr[sift_1]
                sift -= 1
                sift_1 -= 1
                if sift == begin or not keyf(tmp) &lt; keyf(arr[sift_1]):
                    break

            arr[sift] = tmp
            limit += cur - sift

        cur += 1

    return True

</t>
<t tx="ekr.20230509052845.1909">def _partition_left(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; int:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        last -= 1
        if not keyf(pivot) &lt; keyf(arr[last]):
            break

    if last + 1 == end:
        while first &lt; last:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    else:
        while True:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    while first &lt; last:
        arr[first], arr[last] = arr[last], arr[first]
        while True:
            last -= 1
            if not keyf(pivot) &lt; keyf(arr[last]):
                break
        while True:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    pivot_pos = last
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return pivot_pos

</t>
<t tx="ekr.20230509052845.191"></t>
<t tx="ekr.20230509052845.1910">def _partition_right(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; Tuple[int, int]:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        first += 1
        if not keyf(arr[first]) &lt; keyf(pivot):
            break

    if first - 1 == begin:
        while first &lt; last:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    else:
        while True:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    already_partitioned = 0
    if first &gt;= last:
        already_partitioned = 1

    while first &lt; last:
        arr[first], arr[last] = arr[last], arr[first]

        while True:
            first += 1
            if not keyf(arr[first]) &lt; keyf(pivot):
                break

        while True:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    pivot_pos = first - 1
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return (pivot_pos, already_partitioned)

</t>
<t tx="ekr.20230509052845.1911">def _sort2(
    arr: Array[T], i: int, j: int, keyf: Callable[[T], S], T: type, S: type
):
    if keyf(arr[j]) &lt; keyf(arr[i]):
        arr[i], arr[j] = arr[j], arr[i]

</t>
<t tx="ekr.20230509052845.1912">def _sort3(
    arr: Array[T], i: int, j: int, k: int, keyf: Callable[[T], S], T: type, S: type
):
    _sort2(arr, i, j, keyf)
    _sort2(arr, j, k, keyf)
    _sort2(arr, i, j, keyf)

</t>
<t tx="ekr.20230509052845.1913">def _pdq_sort(
    arr: Array[T],
    begin: int,
    end: int,
    keyf: Callable[[T], S],
    bad_allowed: int,
    leftmost: bool,
    T: type,
    S: type,
):
    while True:
        size = end - begin
        if size &lt; INSERTION_SORT_THRESHOLD:
            _insertion_sort(arr, begin, end, keyf)
            return

        size_2 = size // 2
        if size &gt; NINTHER_THRESHOLD:
            _sort3(arr, begin, begin + size_2, end - 1, keyf)
            _sort3(arr, begin + 1, begin + (size_2 - 1), end - 2, keyf)
            _sort3(arr, begin + 2, begin + (size_2 + 1), end - 3, keyf)
            _sort3(
                arr, begin + (size_2 - 1), begin + size_2, begin + (size_2 + 1), keyf
            )
            arr[begin], arr[begin + size_2] = arr[begin + size_2], arr[begin]
        else:
            _sort3(arr, begin + size_2, begin, end - 1, keyf)

        if not leftmost and not keyf(arr[begin - 1]) &lt; keyf(arr[begin]):
            begin = _partition_left(arr, begin, end, keyf) + 1
            continue

        part_result = _partition_right(arr, begin, end, keyf)
        pivot_pos = part_result[0]
        already_partitioned = part_result[1] == 1

        l_size = pivot_pos - begin
        r_size = end - (pivot_pos + 1)
        highly_unbalanced = (l_size &lt; (size // 8)) or (r_size &lt; (size // 8))

        if highly_unbalanced:
            bad_allowed -= 1
            if bad_allowed == 0:
                _heap_sort(arr, begin, end, keyf)
                return

            if l_size &gt;= INSERTION_SORT_THRESHOLD:
                arr[begin], arr[begin + l_size // 4] = (
                    arr[begin + l_size // 4],
                    arr[begin],
                )
                arr[pivot_pos - 1], arr[pivot_pos - l_size // 4] = (
                    arr[pivot_pos - l_size // 4],
                    arr[pivot_pos - 1],
                )

                if l_size &gt; NINTHER_THRESHOLD:
                    arr[begin + 1], arr[begin + (l_size // 4 + 1)] = (
                        arr[begin + (l_size // 4 + 1)],
                        arr[begin + 1],
                    )
                    arr[begin + 2], arr[begin + (l_size // 4 + 2)] = (
                        arr[begin + (l_size // 4 + 2)],
                        arr[begin + 2],
                    )
                    arr[pivot_pos - 2], arr[pivot_pos - (l_size // 4 + 1)] = (
                        arr[pivot_pos - (l_size // 4 + 1)],
                        arr[pivot_pos - 2],
                    )
                    arr[pivot_pos - 3], arr[pivot_pos - (l_size // 4 + 2)] = (
                        arr[pivot_pos - (l_size // 4 + 2)],
                        arr[pivot_pos - 3],
                    )

            if r_size &gt;= INSERTION_SORT_THRESHOLD:
                arr[pivot_pos + 1], arr[pivot_pos + (1 + r_size // 4)] = (
                    arr[pivot_pos + (1 + r_size // 4)],
                    arr[pivot_pos + 1],
                )
                arr[end - 1], arr[end - r_size // 4] = (
                    arr[end - r_size // 4],
                    arr[end - 1],
                )

                if r_size &gt; NINTHER_THRESHOLD:
                    arr[pivot_pos + 2], arr[pivot_pos + (2 + r_size // 4)] = (
                        arr[pivot_pos + (2 + r_size // 4)],
                        arr[pivot_pos + 2],
                    )
                    arr[pivot_pos + 3], arr[pivot_pos + (3 + r_size // 4)] = (
                        arr[pivot_pos + (3 + r_size // 4)],
                        arr[pivot_pos + 3],
                    )
                    arr[end - 2], arr[end - (1 + r_size // 4)] = (
                        arr[end - (1 + r_size // 4)],
                        arr[end - 2],
                    )
                    arr[end - 3], arr[end - (2 + r_size // 4)] = (
                        arr[end - (2 + r_size // 4)],
                        arr[end - 3],
                    )

        else:
            if (
                already_partitioned
                and _partial_insertion_sort(arr, begin, pivot_pos, keyf)
                and _partial_insertion_sort(arr, pivot_pos + 1, end, keyf)
            ):
                return

        _pdq_sort(arr, begin, pivot_pos, keyf, bad_allowed, leftmost)
        begin = pivot_pos + 1
        leftmost = False

</t>
<t tx="ekr.20230509052845.1914">def pdq_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the array inplace.
    """
    _pdq_sort(collection, 0, size, keyf, _floor_log2(size), True)

</t>
<t tx="ekr.20230509052845.1915">def pdq_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the list inplace.
    """
    pdq_sort_array(collection.arr, collection.len, keyf)

</t>
<t tx="ekr.20230509052845.1916">def pdq_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Returns a sorted list.
    """
    newlst = collection.__copy__()
    pdq_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509052845.1917">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: https://github.com/orlp/pdqsort
# License:
#    Copyright (c) 2021 Orson Peters &lt;orsonpeters@gmail.com&gt;
#
#    This software is provided 'as-is', without any express or implied warranty. In no event will the
#    authors be held liable for any damages arising from the use of this software.
#
#    Permission is granted to anyone to use this software for any purpose, including commercial
#    applications, and to alter it and redistribute it freely, subject to the following restrictions:
#
#    1. The origin of this software must not be misrepresented; you must not claim that you wrote the
#    original software. If you use this software in a product, an acknowledgment in the product
#    documentation would be appreciated but is not required.
#
#    2. Altered source versions must be plainly marked as such, and must not be misrepresented as
#    being the original software.
#
#    3. This notice may not be removed or altered from any source distribution.

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1918">def _med3(
    a: int, b: int, c: int, d: Array[T], k: Callable[[T], S], T: type, S: type
) -&gt; int:
    if k(d[a]) &lt; k(d[b]):
        return b if (k(d[b]) &lt; k(d[c])) else (c if k(d[a]) &lt; k(d[c]) else a)
    else:
        return (
            b
            if not (k(d[b]) &lt; k(d[c]) or k(d[b]) == k(d[c]))
            else (c if not (k(d[a]) &lt; k(d[c]) or k(d[a]) == k(d[c])) else a)
        )

</t>
<t tx="ekr.20230509052845.1919">def _swap(i: int, j: int, a: Array[T], T: type):
    a[i], a[j] = a[j], a[i]

</t>
<t tx="ekr.20230509052845.192">@path C:/Repos/codon/bench/set_partition/
# https://stackoverflow.com/questions/73473074/speed-up-set-partition-generation-by-skipping-ones-with-subsets-smaller-or-large
import sys
import time

@others
import time

t = time.time()
something = list(range(1, int(sys.argv[1])))
v = partition_filtered(something, minsize=2)
x = 0
for p in v:
    p.sort()
    x += p[len(p) // 3][0]
print(x)
print(time.time() - t)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1920">def _vecswap(i: int, j: int, n: int, a: Array[T], T: type):
    while n &gt; 0:
        _swap(i, j, a)
        i += 1
        j += 1
        n -= 1

</t>
<t tx="ekr.20230509052845.1921">def _qsort(
    arr: Array[T], frm: int, cnt: int, key: Callable[[T], S], T: type, S: type
):
    if cnt &lt;= 7:
        i = frm + 1
        while i &lt; frm + cnt:
            j = i
            while j &gt; frm and not (
                key(arr[j - 1]) &lt; key(arr[j]) or key(arr[j - 1]) == key(arr[j])
            ):
                _swap(j, j - 1, arr)
                j -= 1
            i += 1
        return

    mid = cnt // 2
    lo = frm
    hi = frm + cnt - 1

    if cnt &gt; 40:
        s = cnt // 8
        lo = _med3(lo, lo + s, lo + 2 * s, arr, key)
        mid = _med3(mid - s, mid, mid + s, arr, key)
        hi = _med3(hi - 2 * s, hi - s, hi, arr, key)
    mid = _med3(lo, mid, hi, arr, key)

    _swap(frm, mid, arr)
    a = frm
    b = a
    c = frm + cnt - 1
    d = c

    while True:
        while b &lt;= c and (
            key(arr[b]) &lt; key(arr[frm]) or key(arr[b]) == key(arr[frm])
        ):
            if key(arr[b]) == key(arr[frm]):
                _swap(a, b, arr)
                a += 1
            b += 1

        while c &gt;= b and not key(arr[c]) &lt; key(arr[frm]):
            if key(arr[c]) == key(arr[frm]):
                _swap(c, d, arr)
                d -= 1
            c -= 1

        if b &gt; c:
            break
        _swap(b, c, arr)
        b += 1
        c -= 1

    hi = frm + cnt
    span = min(a - frm, b - a)
    _vecswap(frm, b - span, span, arr)

    span = min(d - c, hi - d - 1)
    _vecswap(b, hi - span, span, arr)

    span = b - a
    if span &gt; 1:
        _qsort(arr, frm, span, key)

    span = d - c
    if span &gt; 1:
        _qsort(arr, hi - span, span, key)

</t>
<t tx="ekr.20230509052845.1922">def qsort_array(
    collection: Array[T], size: int, key: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the array inplace.
    """
    _qsort(collection, 0, size, key)

</t>
<t tx="ekr.20230509052845.1923">def qsort_inplace(
    collection: List[T], key: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the list inplace.
    """
    qsort_array(collection.arr, collection.len, key)

</t>
<t tx="ekr.20230509052845.1924">def qsort(collection: List[T], key: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Returns a sorted list.
    """
    collection = collection[:]
    qsort_inplace(collection, key)
    return collection
</t>
<t tx="ekr.20230509052845.1925">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Implementation of vectorized Rabin-Karp string search.
# See http://0x80.pl/articles/simd-strfind.html for
# details. These implementations are modified to not
# perform any out-of-bounds memory accesses.

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1926">@pure
@llvm
def cttz(n: UInt[N], N: Static[int]) -&gt; UInt[N]:
    declare i{=N} @llvm.cttz.i{=N}(i{=N}, i1)
    %0 = call i{=N} @llvm.cttz.i{=N}(i{=N} %n, i1 true)
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.1927">@pure
@llvm
def ctlz(n: UInt[N], N: Static[int]) -&gt; UInt[N]:
    declare i{=N} @llvm.ctlz.i{=N}(i{=N}, i1)
    %0 = call i{=N} @llvm.ctlz.i{=N}(i{=N} %n, i1 true)
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.1928">@pure
@llvm
def forward_mask(s: Ptr[byte], n: int, needle: Ptr[byte], k: int, i: int, firstb: byte, lastb: byte) -&gt; u16:
    %first0 = insertelement &lt;16 x i8&gt; undef, i8 %firstb, i64 0
    %first = shufflevector &lt;16 x i8&gt; %first0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %last0 = insertelement &lt;16 x i8&gt; undef, i8 %lastb, i64 0
    %last = shufflevector &lt;16 x i8&gt; %last0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %offset0 = add i64 %i, %k
    %offset = sub i64 %offset0, 1
    %ptr_first = getelementptr inbounds i8, ptr %s, i64 %i
    %ptr_last = getelementptr inbounds i8, ptr %s, i64 %offset
    %block_first = load &lt;16 x i8&gt;, ptr %ptr_first, align 1
    %block_last = load &lt;16 x i8&gt;, ptr %ptr_last, align 1
    %eq_first = icmp eq &lt;16 x i8&gt; %first, %block_first
    %eq_last = icmp eq &lt;16 x i8&gt; %last, %block_last
    %mask0 = and &lt;16 x i1&gt; %eq_first, %eq_last
    %mask = bitcast &lt;16 x i1&gt; %mask0 to i16
    ret i16 %mask

</t>
<t tx="ekr.20230509052845.1929">@pure
@llvm
def backward_mask(s: Ptr[byte], n: int, needle: Ptr[byte], k: int, i: int, firstb: byte, lastb: byte) -&gt; u16:
    %j0 = sub i64 %i, 16
    %j = add i64 %j0, 1
    %first0 = insertelement &lt;16 x i8&gt; undef, i8 %firstb, i64 0
    %first = shufflevector &lt;16 x i8&gt; %first0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %last0 = insertelement &lt;16 x i8&gt; undef, i8 %lastb, i64 0
    %last = shufflevector &lt;16 x i8&gt; %last0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %offset0 = sub i64 %j, %k
    %offset = add i64 %offset0, 1
    %ptr_first = getelementptr inbounds i8, ptr %s, i64 %offset
    %ptr_last = getelementptr inbounds i8, ptr %s, i64 %j
    %block_first = load &lt;16 x i8&gt;, ptr %ptr_first, align 1
    %block_last = load &lt;16 x i8&gt;, ptr %ptr_last, align 1
    %eq_first = icmp eq &lt;16 x i8&gt; %last, %block_last
    %eq_last = icmp eq &lt;16 x i8&gt; %first, %block_first
    %mask0 = and &lt;16 x i1&gt; %eq_first, %eq_last
    %mask = bitcast &lt;16 x i1&gt; %mask0 to i16
    ret i16 %mask

</t>
<t tx="ekr.20230509052845.193">def conforms(candidate, minsize, forgive):
    """
    Check if partition `candidate` is at most `forgive` additions from making
    all its elements conform to having minimum size `minsize`
    """
    deficit = 0
    for p in candidate:
        need = minsize - len(p)
        if need &gt; 0:
            deficit += need

    # Is the deficit small enough?
    return (deficit &lt;= forgive)

</t>
<t tx="ekr.20230509052845.1930">def forward_find(s: Ptr[byte], n: int, needle: Ptr[byte], k: int):
    if k == 0:
        return 0

    if n &lt; k:
        return -1

    if k == 1:
        p = _C.memchr(s, i32(int(needle[0])), n)
        return p - s if p else -1

    firstb = needle[0]
    lastb = needle[k - 1]
    i = 0

    while i + k + 16 - 1 &lt;= n:
        mask = forward_mask(s, n, needle, k, i, firstb, lastb)
        while mask:
            bitpos = int(cttz(mask))
            if _C.memcmp(s + i + bitpos + 1, needle + 1, k - 2) == i32(0):
                return i + bitpos
            mask = mask &amp; (mask - u16(1))
        i += 16

    # unrolled by hand
    while True:
        j = i + 0
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 1
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 2
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 3
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 4
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 5
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 6
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 7
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 8
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 9
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 10
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 11
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 12
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 13
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 14
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 15
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        break

    return -1

</t>
<t tx="ekr.20230509052845.1931">def backward_find(s: Ptr[byte], n: int, needle: Ptr[byte], k: int):
    if k == 0:
        return n

    if n &lt; k:
        return -1

    if k == 1:
        i = n - 1
        while i &gt;= 0:
            if s[i] == needle[0]:
                return i
            i -= 1
        return -1

    firstb = needle[0]
    lastb = needle[k - 1]
    i = n - 1

    while i - (k - 1) - (16 - 1) &gt;= 0:
        mask = backward_mask(s, n, needle, k, i, firstb, lastb)
        while mask:
            bitpos = int(ctlz(mask))
            if _C.memcmp(s + i - (k - 1) - bitpos + 1, needle + 1, k - 2) == i32(0):
                return i - (k - 1) - bitpos
            mask &amp;= ~(u16(1) &lt;&lt; u16(16 - 1 - bitpos))
        i -= 16

    # unrolled by hand
    while True:
        j = i - 0
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 1
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 2
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 3
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 4
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 5
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 6
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 7
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 8
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 9
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i + 10
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 11
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 12
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 13
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 14
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 15
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        break

    return -1

</t>
<t tx="ekr.20230509052845.1932">def find(haystack: str, needle: str):
    return forward_find(haystack.ptr, haystack.len, needle.ptr, needle.len)

</t>
<t tx="ekr.20230509052845.1933">def rfind(haystack: str, needle: str):
    return backward_find(haystack.ptr, haystack.len, needle.ptr, needle.len)

</t>
<t tx="ekr.20230509052845.1934">def count(haystack: str, needle: str):
    occ = 0
    tmp = haystack.ptr
    n = haystack.len
    k = needle.len

    if k == 0:
        return n + 1

    while True:
        pos = forward_find(tmp, n - (tmp - haystack.ptr), needle.ptr, k)
        if pos == -1:
            break
        tmp += pos + k
        occ += 1
    return occ

</t>
<t tx="ekr.20230509052845.1935">def count_with_max(haystack: str, needle: str, maxcount: int):
    occ = 0
    tmp = haystack.ptr
    n = haystack.len
    k = needle.len

    if maxcount == 0:
        return 0

    if k == 0:
        return n + 1 if n + 1 &lt; maxcount else maxcount

    while True:
        pos = forward_find(tmp, n - (tmp - haystack.ptr), needle.ptr, k)
        if pos == -1:
            break
        tmp += pos + k
        occ += 1
        if occ == maxcount:
            return occ
    return occ
</t>
<t tx="ekr.20230509052845.1936">@path C:/Repos/codon/stdlib/algorithms/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Pats of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.
#
# Timsort by Tim Peters, published at https://github.com/python/cpython/blob/master/Objects/listobject.c#L2187

BLOCK_SIZE = 64
CACHELINE_SIZE = 64
MIN_GALLOP = 7

from algorithms.insertionsort import _insertion_sort

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1937">def _count_run(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; Tuple[int, int]:
    """
    Returns the # of elements in the next run and if the run is "inorder" or "reversed"
    """
    inorder = 1

    if end - begin == 1:
        return 1, inorder

    n = 2
    i = begin + 1
    if keyf(arr[i - 1]) &gt;= keyf(arr[i]):
        inorder = 0
        i += 1
        while i &lt; end:
            if keyf(arr[i - 1]) &lt; keyf(arr[i]):
                break
            i += 1
            n += 1

    else:
        i += 1
        while i &lt; end:
            if keyf(arr[i - 1]) &gt;= keyf(arr[i]):
                break
            i += 1
            n += 1

    return n, inorder

</t>
<t tx="ekr.20230509052845.1938">def _merge_compute_minrun(n: int) -&gt; int:
    """
    Computes the minrun for Timsort
    """
    r = 0
    while n &gt;= 64:
        r |= n &amp; 1
        n &gt;&gt;= 1
    return n + r

</t>
<t tx="ekr.20230509052845.1939">def _reverse_sortslice(arr: Array[T], begin: int, end: int, T: type):
    if end - begin &lt; 2:
        return
    arr[begin], arr[end - 1] = arr[end - 1], arr[begin]
    _reverse_sortslice(arr, begin + 1, end - 1)

</t>
<t tx="ekr.20230509052845.194">def partition_filtered(collection, minsize=1, forgive=0):
    """
    Generate partitions that contain at least `minsize` elements per set;
    allow `forgive` missing elements, which can get added in subsequent steps
    """
    if len(collection) == 1:
        yield [ collection ]
        return

    first = collection[0]
    for smaller in partition_filtered(collection[1:], minsize, forgive=forgive+1):
        # insert `first` in each of the subpartition's subsets
        for n, subset in enumerate(smaller):
            candidate = smaller[:n] + [[ first ] + subset]  + smaller[n+1:]
            if conforms(candidate, minsize, forgive):
                yield candidate

        # put `first` in its own subset
        candidate = [ [ first ] ] + smaller
        if conforms(candidate, minsize, forgive):
            yield candidate


</t>
<t tx="ekr.20230509052845.1940">def _modified_comp(
    a: T, b: T, keyf: Callable[[T], S], left: bool, T: type, S: type
) -&gt; bool:
    """
    Abstracts the left or right compare in gallop
    """
    if left:
        return keyf(b) &gt;= keyf(a)
    else:
        return keyf(a) &lt; keyf(b)

</t>
<t tx="ekr.20230509052845.1941">def _gallop(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    hint: int,
    left: bool,
    T: type,
    S: type,
) -&gt; int:
    """
    Gallop for Timsort
    """

    key = arr[0]  # just to initialize k
    if left:
        key = arr[b[0] + b[1] - 1]
    else:
        key = arr[b[0]]

    curr = a[0] + hint
    ofs, lastofs = 1, 0

    if _modified_comp(key, arr[curr], keyf, left):
        # Gallop left
        maxofs = hint + 1

        while ofs &lt; maxofs:
            if _modified_comp(key, arr[curr - ofs], keyf, left):
                lastofs = ofs
                ofs = (ofs &lt;&lt; 1) + 1
            else:
                break

        if ofs &gt; maxofs:
            ofs = maxofs

        ofs, lastofs = hint - lastofs, hint - ofs

    else:
        # Gallop right
        maxofs = a[1] - hint

        while ofs &lt; maxofs:
            if _modified_comp(key, arr[curr + ofs], keyf, left):
                break
            lastofs = ofs
            ofs = (ofs &lt;&lt; 1) + 1

        if ofs &gt; maxofs:
            ofs = maxofs

        lastofs += hint
        ofs += hint

    lastofs += 1
    while lastofs &lt; ofs:
        m = lastofs + ((ofs - lastofs) &gt;&gt; 1)
        if _modified_comp(key, arr[a[0] + m], keyf, left):
            ofs = m
        else:
            lastofs = m + 1

    return ofs

</t>
<t tx="ekr.20230509052845.1942">def _merge_with_gallop(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    min_gallop = MIN_GALLOP

    combined = Array[T](a[1] + b[1])
    a_copy = combined.slice(0, a[1])
    b_copy = combined.slice(a[1], len(combined))

    j = 0
    for i in range(a[0], a[0] + a[1]):
        combined[j] = arr[i]
        j += 1
    for i in range(b[0], b[0] + b[1]):
        combined[j] = arr[i]
        j += 1

    i, j, k = 0, 0, a[0]

    while i &lt; len(a_copy) and j &lt; len(b_copy):
        acount, bcount = 0, 0

        while i &lt; len(a_copy) and j &lt; len(b_copy):
            if keyf(b_copy[j]) &lt; keyf(a_copy[i]):
                arr[k] = b_copy[j]
                acount = 0
                bcount += 1
                j += 1
                k += 1
                if bcount &gt;= min_gallop:
                    break
            else:
                arr[k] = a_copy[i]
                acount += 1
                bcount = 0
                i += 1
                k += 1
                if acount &gt;= min_gallop:
                    break

        if i == len(a_copy) or j == len(b_copy):
            break

        min_gallop += 1

        while i &lt; len(a_copy) and j &lt; len(b_copy):
            if min_gallop &gt; 1:
                min_gallop -= 1

            acount = _gallop(
                combined, (0, len(a_copy)), (len(a_copy), len(b_copy)), keyf, i, False
            )
            if acount:
                while i &lt; acount:
                    arr[k] = a_copy[i]
                    i += 1
                    k += 1
                arr[k] = b_copy[j]
                j += 1
                k += 1

            if i == len(a_copy) or j == len(b_copy):
                break

            b_end = _gallop(
                combined, (len(a_copy), len(b_copy)), (0, len(a_copy)), keyf, j, True
            )
            bcount = len(b_copy) - b_end
            if bcount:
                while j &lt; b_end:
                    arr[k] = b_copy[j]
                    j += 1
                    k += 1
                arr[k] = a_copy[i]
                i += 1
                k += 1

            if acount &lt; MIN_GALLOP and bcount &lt; MIN_GALLOP:
                break

        min_gallop += 1

    while i &lt; len(a_copy):
        arr[k] = a_copy[i]
        i += 1
        k += 1

    while j &lt; len(b_copy):
        arr[k] = b_copy[j]
        j += 1
        k += 1

</t>
<t tx="ekr.20230509052845.1943">def _merge_at(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    start_a, len_a = a
    start_b, len_b = b

    # Where does b start in a?
    k = _gallop(arr, a, b, keyf, 0, False)
    start_a, len_a = start_a + k, len_a - k
    if len_a == 0:
        return

    # Where does a end in b?
    len_b = _gallop(arr, b, a, keyf, len_b - 1, True)
    if len_b == 0:
        return

    _merge_with_gallop(arr, (start_a, len_a), (start_b, len_b), keyf)

</t>
<t tx="ekr.20230509052845.1944">def _merge_collapse(
    arr: Array[T],
    stack: List[Tuple[int, int]],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    if len(stack) &lt;= 1:
        return

    while len(stack) &gt; 2:
        X = stack[-3]
        Y = stack[-2]
        Z = stack[-1]

        if X[1] &gt; Y[1] + Z[1] and Y[1] &gt; Z[1]:
            break

        C = stack.pop()
        B = stack.pop()
        A = stack.pop()

        if A[1] &lt;= B[1] + C[1]:
            if A[1] &lt; C[1]:
                _merge_at(arr, A, B, keyf)
                stack.append((A[0], A[1] + B[1]))
                stack.append(C)
            else:
                _merge_at(arr, B, C, keyf)
                stack.append(A)
                stack.append((B[0], B[1] + C[1]))

        else:
            _merge_at(arr, B, C, keyf)
            stack.append(A)
            stack.append((B[0], B[1] + C[1]))

    if len(stack) == 2:
        X = stack[-2]
        Y = stack[-1]

        if X[1] &lt;= Y[1]:
            C = stack.pop()
            B = stack.pop()
            _merge_at(arr, B, C, keyf)
            stack.append((B[0], B[1] + C[1]))
            return

</t>
<t tx="ekr.20230509052845.1945">def _final_merge(
    arr: Array[T],
    stack: List[Tuple[int, int]],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    while len(stack) &gt; 1:
        C = stack.pop()
        B = stack.pop()
        _merge_at(arr, B, C, keyf)
        stack.append((B[0], B[1] + C[1]))

</t>
<t tx="ekr.20230509052845.1946">def _tim_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    if end - begin &lt; 2:
        return

    merge_pending = List[Tuple[int, int]]()
    minrun = _merge_compute_minrun(end - begin)
    i = begin
    while i &lt; end:
        n, inorder = _count_run(arr, i, end, keyf)
        if not inorder:
            _reverse_sortslice(arr, i, i + n)

        if n &lt; minrun:
            force = min(minrun, end - i)
            _insertion_sort(arr, i, i + force, keyf)
            n = force

        merge_pending.append((i, n))
        _merge_collapse(arr, merge_pending, keyf)
        i += n

    _final_merge(arr, merge_pending, keyf)

</t>
<t tx="ekr.20230509052845.1947">def tim_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    _tim_sort(collection, 0, size, keyf)

</t>
<t tx="ekr.20230509052845.1948">def tim_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    tim_sort_array(collection.arr, collection.len, keyf)

</t>
<t tx="ekr.20230509052845.1949">def tim_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    newlst = list(collection)
    tim_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509052845.195"></t>
<t tx="ekr.20230509052845.1950"></t>
<t tx="ekr.20230509052845.1951">@path C:/Repos/codon/stdlib/experimental/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
u8x16 = Vec[u8, 16]
u8x32 = Vec[u8, 32]
f32x8 = Vec[f32, 8]
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1952">@tuple(container=False)  # disallow default __getitem__
class Vec[T, N: Static[int]]:
    ZERO_16x8i = Vec[u8,16](u8(0))
    FF_16x8i = Vec[u8,16](u8(0xff))
    ZERO_32x8i = Vec[u8,32](u8(0))
    FF_32x8i = Vec[u8,32](u8(0xff))

    @others
</t>
<t tx="ekr.20230509052845.1953">@llvm
def _mm_set1_epi8(val: u8) -&gt; Vec[u8, 16]:
    %0 = insertelement &lt;16 x i8&gt; undef, i8 %val, i32 0
    %1 = shufflevector &lt;16 x i8&gt; %0, &lt;16 x i8&gt; undef, &lt;16 x i32&gt; zeroinitializer
    ret &lt;16 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1954">@llvm
def _mm256_set1_epi8(val: u8) -&gt; Vec[u8, 32]:
    %0 = insertelement &lt;32 x i8&gt; undef, i8 %val, i32 0
    %1 = shufflevector &lt;32 x i8&gt; %0, &lt;32 x i8&gt; undef, &lt;32 x i32&gt; zeroinitializer
    ret &lt;32 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1955">@llvm
def _mm_loadu_si128(data) -&gt; Vec[u8, 16]:
    %0 = bitcast i8* %data to &lt;16 x i8&gt;*
    %1 = load &lt;16 x i8&gt;, &lt;16 x i8&gt;* %0, align 1
    ret &lt;16 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1956">@llvm
def _mm256_loadu_si256(data) -&gt; Vec[u8, 32]:
    %0 = bitcast i8* %data to &lt;32 x i8&gt;*
    %1 = load &lt;32 x i8&gt;, &lt;32 x i8&gt;* %0, align 1
    ret &lt;32 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1957">@llvm
def _mm256_set1_ps(val: f32) -&gt; Vec[f32, 8]:
    %0 = insertelement &lt;8 x float&gt; undef, float %val, i32 0
    %1 = shufflevector &lt;8 x float&gt; %0, &lt;8 x float&gt; undef, &lt;8 x i32&gt; zeroinitializer
    ret &lt;8 x float&gt; %1

</t>
<t tx="ekr.20230509052845.1958">@llvm
def _mm512_set1_ps(val: f32) -&gt; Vec[f32, 16]:
    %0 = insertelement &lt;16 x float&gt; undef, float %val, i32 0
    %1 = shufflevector &lt;16 x float&gt; %0, &lt;16 x float&gt; undef, &lt;16 x i32&gt; zeroinitializer
    ret &lt;16 x float&gt; %1

</t>
<t tx="ekr.20230509052845.1959">@llvm
def _mm256_loadu_ps(data: Ptr[f32]) -&gt; Vec[f32, 8]:
    %0 = bitcast float* %data to &lt;8 x float&gt;*
    %1 = load &lt;8 x float&gt;, &lt;8 x float&gt;* %0
    ret &lt;8 x float&gt; %1

</t>
<t tx="ekr.20230509052845.196">@path C:/Repos/codon/bench/spectral_norm/
"""
MathWorld: "Hundred-Dollar, Hundred-Digit Challenge Problems", Challenge #3.
http://mathworld.wolfram.com/Hundred-DollarHundred-DigitChallengeProblems.html

The Computer Language Benchmarks Game
http://benchmarksgame.alioth.debian.org/u64q/spectralnorm-description.html#spectralnorm

Contributed by Sebastien Loisel
Fixed by Isaac Gouy
Sped up by Josh Goldfoot
Dirtily sped up by Simon Descarpentries
Concurrency by Jason Stitt
Adapted for Codon by @arshajii
"""

from time import time

DEFAULT_N = 260

@others
t0 = time()
print(bench_spectral_norm(100))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.1960">@llvm
def _mm512_loadu_ps(data: Ptr[f32]) -&gt; Vec[f32, 16]:
    %0 = bitcast float* %data to &lt;16 x float&gt;*
    %1 = load &lt;16 x float&gt;, &lt;16 x float&gt;* %0
    ret &lt;16 x float&gt; %1

</t>
<t tx="ekr.20230509052845.1961">@llvm
def _mm256_cvtepi8_epi32(vec: Vec[u8, 16]) -&gt; Vec[u32, 8]:
    %0 = shufflevector &lt;16 x i8&gt; %vec, &lt;16 x i8&gt; undef, &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7&gt;
    %1 = sext &lt;8 x i8&gt; %0 to &lt;8 x i32&gt;
    ret &lt;8 x i32&gt; %1

</t>
<t tx="ekr.20230509052845.1962">@llvm
def _mm512_cvtepi8_epi64(vec: Vec[u8, 32]) -&gt; Vec[u32, 16]:
    %0 = shufflevector &lt;32 x i8&gt; %vec, &lt;32 x i8&gt; undef, &lt;16 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15&gt;
    %1 = sext &lt;16 x i8&gt; %0 to &lt;16 x i32&gt;
    ret &lt;16 x i32&gt; %1

</t>
<t tx="ekr.20230509052845.1963">@llvm
def _mm256_castsi256_ps(vec: Vec[u32, 8]) -&gt; Vec[f32, 8]:
    %0 = bitcast &lt;8 x i32&gt; %vec to &lt;8 x float&gt;
    ret &lt;8 x float&gt; %0

</t>
<t tx="ekr.20230509052845.1964">@llvm
def _mm512_castsi512_ps(vec: Vec[u32, 16]) -&gt; Vec[f32, 16]:
    %0 = bitcast &lt;16 x i32&gt; %vec to &lt;16 x float&gt;
    ret &lt;16 x float&gt; %0

</t>
<t tx="ekr.20230509052845.1965">def __new__(x, T: type, N: Static[int]) -&gt; Vec[T, N]:
    if isinstance(T, u8) and N == 16:
        if isinstance(x, u8) or isinstance(x, byte): # TODO: u8&lt;-&gt;byte
            return Vec._mm_set1_epi8(x)
        if isinstance(x, Ptr[u8]) or isinstance(x, Ptr[byte]):
            return Vec._mm_loadu_si128(x)
        if isinstance(x, str):
            return Vec._mm_loadu_si128(x.ptr)
    if isinstance(T, u8) and N == 32:
        if isinstance(x, u8) or isinstance(x, byte): # TODO: u8&lt;-&gt;byte
            return Vec._mm256_set1_epi8(x)
        if isinstance(x, Ptr[u8]) or isinstance(x, Ptr[byte]):
            return Vec._mm256_loadu_si256(x)
        if isinstance(x, str):
            return Vec._mm256_loadu_si256(x.ptr)
    if isinstance(T, f32) and N == 8:
        if isinstance(x, f32):
            return Vec._mm256_set1_ps(x)
        if isinstance(x, Ptr[f32]):  # TODO: multi-elif does NOT work with statics [why?!]
            return Vec._mm256_loadu_ps(x)
        if isinstance(x, List[f32]):
            return Vec._mm256_loadu_ps(x.arr.ptr)
        if isinstance(x, Vec[u8, 16]):
            return Vec._mm256_castsi256_ps(Vec._mm256_cvtepi8_epi32(x))
    if isinstance(T, f32) and N == 16:
        if isinstance(x, f32):
            return Vec._mm512_set1_ps(x)
        if isinstance(x, Ptr[f32]):  # TODO: multi-elif does NOT work with statics [why?!]
            return Vec._mm512_loadu_ps(x)
        if isinstance(x, List[f32]):
            return Vec._mm512_loadu_ps(x.arr.ptr)
        if isinstance(x, Vec[u8, 32]):
            return Vec._mm512_castsi512_ps(Vec._mm512_cvtepi8_epi64(x))
    compile_error("invalid SIMD vector constructor")

</t>
<t tx="ekr.20230509052845.1966">def __new__(x: str, offset: int = 0) -&gt; Vec[u8, N]:
    return Vec(x.ptr + offset, u8, N)

</t>
<t tx="ekr.20230509052845.1967">def __new__(x: List[T], offset: int = 0) -&gt; Vec[T, N]:
    return Vec(x.arr.ptr + offset, T, N)

</t>
<t tx="ekr.20230509052845.1968">def __new__(x) -&gt; Vec[T, N]:
    return Vec(x, T, N)

</t>
<t tx="ekr.20230509052845.1969">@llvm
def _mm_cmpeq_epi8(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    %0 = icmp eq &lt;16 x i8&gt; %x, %y
    %1 = sext &lt;16 x i1&gt; %0 to &lt;16 x i8&gt;
    ret &lt;16 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.197">def eval_A(i, j):
    return 1.0 / ((i + j) * (i + j + 1) // 2 + i + 1)

</t>
<t tx="ekr.20230509052845.1970">def __eq__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    return Vec._mm_cmpeq_epi8(self, other)

</t>
<t tx="ekr.20230509052845.1971">@llvm
def _mm256_cmpeq_epi8(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    %0 = icmp eq &lt;32 x i8&gt; %x, %y
    %1 = sext &lt;32 x i1&gt; %0 to &lt;32 x i8&gt;
    ret &lt;32 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1972">def __eq__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    return Vec._mm256_cmpeq_epi8(self, other)

</t>
<t tx="ekr.20230509052845.1973">@llvm
def _mm_andnot_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    %0 = xor &lt;16 x i8&gt; %x, &lt;i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1&gt;
    %1 = and &lt;16 x i8&gt; %y, %0
    ret &lt;16 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1974">def __ne__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    return Vec._mm_andnot_si128((self == other), Vec.FF_16x8i)

</t>
<t tx="ekr.20230509052845.1975">@llvm
def _mm256_andnot_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    %0 = xor &lt;32 x i8&gt; %x, &lt;i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1&gt;
    %1 = and &lt;32 x i8&gt; %y, %0
    ret &lt;32 x i8&gt; %1

</t>
<t tx="ekr.20230509052845.1976">def __ne__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    return Vec._mm256_andnot_si256((self == other), Vec.FF_32x8i)

</t>
<t tx="ekr.20230509052845.1977">def __eq__(self: Vec[u8, 16], other: bool) -&gt; Vec[u8, 16]:
    if not other:
        return Vec._mm_andnot_si128(self, Vec.FF_16x8i)
    else:
        return Vec._mm_andnot_si128(self, Vec.ZERO_16x8i)

</t>
<t tx="ekr.20230509052845.1978">def __eq__(self: Vec[u8, 32], other: bool) -&gt; Vec[u8, 32]:
    if not other:
        return Vec._mm256_andnot_si256(self, Vec.FF_32x8i)
    else:
        return Vec._mm256_andnot_si256(self, Vec.ZERO_32x8i)

</t>
<t tx="ekr.20230509052845.1979">@llvm
def _mm_and_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    %0 = and &lt;16 x i8&gt; %x, %y
    ret &lt;16 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.198">def eval_times_u(func, u):
    return [func((i, u)) for i in range(len(list(u)))]

</t>
<t tx="ekr.20230509052845.1980">def __and__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    return Vec._mm_and_si128(self, other)

</t>
<t tx="ekr.20230509052845.1981">@llvm
def _mm_and_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    %0 = and &lt;32 x i8&gt; %x, %y
    ret &lt;32 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.1982">def __and__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    return Vec._mm_and_si256(self, other)

</t>
<t tx="ekr.20230509052845.1983">@llvm
def _mm256_and_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    %0 = bitcast &lt;8 x float&gt; %x to &lt;8 x i32&gt;
    %1 = bitcast &lt;8 x float&gt; %y to &lt;8 x i32&gt;
    %2 = and &lt;8 x i32&gt; %0, %1
    %3 = bitcast &lt;8 x i32&gt; %2 to &lt;8 x float&gt;
    ret &lt;8 x float&gt; %3

</t>
<t tx="ekr.20230509052845.1984">def __and__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    return Vec._mm256_and_ps(self, other)

</t>
<t tx="ekr.20230509052845.1985">@llvm
def _mm512_and_ps(x: Vec[f32, 16], y: Vec[f32, 16]) -&gt; Vec[f32, 16]:
    %0 = bitcast &lt;16 x float&gt; %x to &lt;16 x i32&gt;
    %1 = bitcast &lt;16 x float&gt; %y to &lt;16 x i32&gt;
    %2 = and &lt;16 x i32&gt; %0, %1
    %3 = bitcast &lt;16 x i32&gt; %2 to &lt;16 x float&gt;
    ret &lt;16 x float&gt; %3

</t>
<t tx="ekr.20230509052845.1986">def __and__(self: Vec[f32, 16], other: Vec[f32, 16]) -&gt; Vec[f32, 16]:
    return Vec._mm512_and_ps(self, other)

</t>
<t tx="ekr.20230509052845.1987">@llvm
def _mm_or_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    %0 = or &lt;16 x i8&gt; %x, %y
    ret &lt;16 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.1988">def __or__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    return Vec._mm_or_si128(self, other)

</t>
<t tx="ekr.20230509052845.1989">@llvm
def _mm_or_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    %0 = or &lt;32 x i8&gt; %x, %y
    ret &lt;32 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.199">def part_At_times_u(i_u):
    i, u = i_u
    partial_sum = 0.
    for j, u_j in enumerate(u):
        partial_sum += eval_A(j, i) * u_j
    return partial_sum

</t>
<t tx="ekr.20230509052845.1990">def __or__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    return Vec._mm_or_si256(self, other)

</t>
<t tx="ekr.20230509052845.1991">@llvm
def _mm256_or_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    %0 = bitcast &lt;8 x float&gt; %x to &lt;8 x i32&gt;
    %1 = bitcast &lt;8 x float&gt; %y to &lt;8 x i32&gt;
    %2 = or &lt;8 x i32&gt; %0, %1
    %3 = bitcast &lt;8 x i32&gt; %2 to &lt;8 x float&gt;
    ret &lt;8 x float&gt; %3

</t>
<t tx="ekr.20230509052845.1992">def __or__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    return Vec._mm256_or_ps(self, other)

</t>
<t tx="ekr.20230509052845.1993">@llvm
def _mm512_or_ps(x: Vec[f32, 16], y: Vec[f32, 16]) -&gt; Vec[f32, 16]:
    %0 = bitcast &lt;16 x float&gt; %x to &lt;16 x i32&gt;
    %1 = bitcast &lt;16 x float&gt; %y to &lt;16 x i32&gt;
    %2 = or &lt;16 x i32&gt; %0, %1
    %3 = bitcast &lt;16 x i32&gt; %2 to &lt;16 x float&gt;
    ret &lt;16 x float&gt; %3

</t>
<t tx="ekr.20230509052845.1994">def __or__(self: Vec[f32, 16], other: Vec[f32, 16]) -&gt; Vec[f32, 16]:
    return Vec._mm512_or_ps(self, other)

</t>
<t tx="ekr.20230509052845.1995">@llvm
def _mm_bsrli_si128_8(vec: Vec[u8, 16]) -&gt; Vec[u8, 16]:
    %0 = shufflevector &lt;16 x i8&gt; %vec, &lt;16 x i8&gt; zeroinitializer, &lt;16 x i32&gt; &lt;i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23&gt;
    ret &lt;16 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.1996">@llvm
def _mm256_add_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    %0 = fadd &lt;8 x float&gt; %x, %y
    ret &lt;8 x float&gt; %0

</t>
<t tx="ekr.20230509052845.1997">def __add__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
    return Vec._mm256_add_ps(self, other)

</t>
<t tx="ekr.20230509052845.1998">def __rshift__(self: Vec[u8, 16], shift: Static[int]) -&gt; Vec[u8, 16]:
    if shift == 0:
        return self
    elif shift == 8:
        return Vec._mm_bsrli_si128_8(self)
    else:
        compile_error("invalid bitshift")

</t>
<t tx="ekr.20230509052845.1999">@llvm
def _mm_bsrli_256(vec: Vec[u8, 32]) -&gt; Vec[u8, 32]:
    %0 = shufflevector &lt;32 x i8&gt; %vec, &lt;32 x i8&gt; zeroinitializer, &lt;32 x i32&gt; &lt;i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47&gt;
    ret &lt;32 x i8&gt; %0

</t>
<t tx="ekr.20230509052845.2"></t>
<t tx="ekr.20230509052845.20">class GVector(object):
    x: float
    y: float
    z: float

    @others
    #def __str__(self):
    #    return "&lt;%f, %f, %f&gt;" % (self.x, self.y, self.z)

    #def __repr__(self):
    #    return "GVector(%f, %f, %f)" % (self.x, self.y, self.z)


</t>
<t tx="ekr.20230509052845.200">def part_A_times_u(i_u):
    i, u = i_u
    partial_sum = 0.
    for j, u_j in enumerate(u):
        partial_sum += eval_A(i, j) * u_j
    return partial_sum

</t>
<t tx="ekr.20230509052845.2000">def __rshift__(self: Vec[u8, 32], shift: Static[int]) -&gt; Vec[u8, 32]:
    if shift == 0:
        return self
    elif shift == 16:
        return Vec._mm_bsrli_256(self)
    else:
        compile_error("invalid bitshift")

</t>
<t tx="ekr.20230509052845.2001"># @llvm  # https://stackoverflow.com/questions/6996764/fastest-way-to-do-horizontal-sse-vector-sum-or-other-reduction
# def sum(self: Vec[f32, 8]) -&gt; f32:
#     %0 = shufflevector &lt;8 x float&gt; %self, &lt;8 x float&gt; undef, &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;
#     %1 = shufflevector &lt;8 x float&gt; %self, &lt;8 x float&gt; poison, &lt;4 x i32&gt; &lt;i32 4, i32 5, i32 6, i32 7&gt;
#     %2 = fadd &lt;4 x float&gt; %0, %1
#     %3 = shufflevector &lt;4 x float&gt; %2, &lt;4 x float&gt; undef, &lt;4 x i32&gt; &lt;i32 1, i32 undef, i32 3, i32 undef&gt;
#     %4 = fadd &lt;4 x float&gt; %2, %3
#     %5 = shufflevector &lt;4 x float&gt; %4, &lt;4 x float&gt; poison, &lt;4 x i32&gt; &lt;i32 2, i32 undef, i32 undef, i32 undef&gt;
#     %6 = fadd &lt;4 x float&gt; %4, %5
#     %7 = extractelement &lt;4 x float&gt; %6, i32 0
#     ret float %7

</t>
<t tx="ekr.20230509052845.2002">def sum(self: Vec[f32, 8], x: f32 = f32(0.0)) -&gt; f32:
    return x + self[0] + self[1] + self[2] + self[3] + self[4] + self[5] + self[6] + self[7]

</t>
<t tx="ekr.20230509052845.2003">@llvm
def __getitem__(self, n: Static[int]) -&gt; T:
    %0 = extractelement &lt;{=N} x {=T}&gt; %self, i32 {=n}
    ret {=T} %0

</t>
<t tx="ekr.20230509052845.2004">def __repr__(self):
    if N == 8:
        return f"&lt;{self[0]}, {self[1]}, {self[2]}, {self[3]}, {self[4]}, {self[5]}, {self[6]}, {self[7]}&gt;"
    elif N == 16:
        return f"&lt;{self[0]}, {self[1]}, {self[2]}, {self[3]}, {self[4]}, {self[5]}, {self[6]}, {self[7]}, {self[8]}, {self[9]}, {self[10]}, {self[11]}, {self[12]}, {self[13]}, {self[14]}, {self[15]}&gt;"
    else:
        return "?"

</t>
<t tx="ekr.20230509052845.2005">def scatter(self: Vec[T, N]) -&gt; List[T]:
    return [self[i] for i in staticrange(N)]


</t>
<t tx="ekr.20230509052845.2006"></t>
<t tx="ekr.20230509052845.2007">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2008">@__attribute__
def test():
    pass

</t>
<t tx="ekr.20230509052845.2009">@__attribute__
def export():
    pass

</t>
<t tx="ekr.20230509052845.201">def eval_AtA_times_u(u):
    return eval_times_u(part_At_times_u, eval_times_u(part_A_times_u, u))

</t>
<t tx="ekr.20230509052845.2010">@__attribute__
def inline():
    pass

</t>
<t tx="ekr.20230509052845.2011">@__attribute__
def noinline():
    pass

</t>
<t tx="ekr.20230509052845.2012">@__attribute__
def pure():
    pass

</t>
<t tx="ekr.20230509052845.2013">@__attribute__
def nonpure():
    pass

</t>
<t tx="ekr.20230509052845.2014">@__attribute__
def no_side_effect():
    pass

</t>
<t tx="ekr.20230509052845.2015">@__attribute__
def nocapture():
    pass

</t>
<t tx="ekr.20230509052845.2016">@__attribute__
def pycapture():
    pass

</t>
<t tx="ekr.20230509052845.2017">@__attribute__
def derives():
    pass

</t>
<t tx="ekr.20230509052845.2018">@__attribute__
def self_captures():
    pass

</t>
<t tx="ekr.20230509052845.2019">@__attribute__
def commutative():
    pass

</t>
<t tx="ekr.20230509052845.202">def bench_spectral_norm(loops):
    range_it = range(loops)
    total = 0.
    for _ in range_it:
        u = [1.] * DEFAULT_N
        v = None
        for dummy in range(10):
            v = eval_AtA_times_u(u)
            u = eval_AtA_times_u(v)
        vBv = vv = 0.
        for ue, ve in zip(u, v):
            vBv += ue * ve
            vv += ve * ve
        total += vBv + vv
    return total

</t>
<t tx="ekr.20230509052845.2020">@__attribute__
def associative():
    pass

</t>
<t tx="ekr.20230509052845.2021">@__attribute__
def distributive():
    pass

</t>
<t tx="ekr.20230509052845.2022">@__attribute__
def realize_without_self():
    pass

</t>
<t tx="ekr.20230509052845.2023">@__attribute__
def virtual():
    pass

</t>
<t tx="ekr.20230509052845.2024">@__attribute__
def no_argument_wrap():
    pass

</t>
<t tx="ekr.20230509052845.2025">@__attribute__
def no_type_wrap():
    pass
</t>
<t tx="ekr.20230509052845.2026">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2027">class object:
    def __init__(self):
        pass

    def __repr__(self) -&gt; str:
        return f"&lt;{self.__class__.__name__} object at {self.__raw__()}&gt;"

</t>
<t tx="ekr.20230509052845.2028">def id(x) -&gt; int:
    if isinstance(x, ByRef):
        return int(x.__raw__())
    else:
        return 0

</t>
<t tx="ekr.20230509052845.2029">_stdout = _C.seq_stdout()

</t>
<t tx="ekr.20230509052845.203"></t>
<t tx="ekr.20230509052845.2030">def print(*args, sep: str = " ", end: str = "\n", file=_stdout, flush: bool = False):
    """
    Print args to the text stream file.
    """
    fp = cobj()
    if isinstance(file, cobj):
        fp = file
    else:
        fp = file.fp
    i = 0
    for a in args:
        if i and sep:
            _C.seq_print_full(sep, fp)
        _C.seq_print_full(str(a), fp)
        i += 1
    _C.seq_print_full(end, fp)
    if flush:
        _C.fflush(fp)

</t>
<t tx="ekr.20230509052845.2031">@extend
class __internal__:
    def prn(*args):
        print(*args)

</t>
<t tx="ekr.20230509052845.2032">def min(*args):
    if staticlen(args) == 0:
        raise ValueError("empty sequence")
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        x = args[0].__iter__()
        if not x.done():
            s = x.next()
            while not x.done():
                i = x.next()
                if i &lt; s:
                    s = i
            x.destroy()
            return s
        else:
            x.destroy()
        raise ValueError("empty sequence")
    elif staticlen(args) == 2:
        a, b = args
        return a if a &lt;= b else b
    else:
        m = args[0]
        for i in args:
            if i &lt; m:
                m = i
        return m

</t>
<t tx="ekr.20230509052845.2033">def max(*args):
    if staticlen(args) == 0:
        raise ValueError("empty sequence")
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        x = args[0].__iter__()
        if not x.done():
            s = x.next()
            while not x.done():
                i = x.next()
                if i &gt; s:
                    s = i
            x.destroy()
            return s
        else:
            x.destroy()
        raise ValueError("empty sequence")
    elif staticlen(args) == 2:
        a, b = args
        return a if a &gt;= b else b
    else:
        m = args[0]
        for i in args:
            if i &gt; m:
                m = i
        return m

</t>
<t tx="ekr.20230509052845.2034">def len(x) -&gt; int:
    """
    Return the length of x
    """
    return x.__len__()

</t>
<t tx="ekr.20230509052845.2035">def iter(x):
    """
    Return an iterator for the given object
    """
    return x.__iter__()

</t>
<t tx="ekr.20230509052845.2036">def abs(x):
    """
    Return the absolute value of x
    """
    return x.__abs__()

</t>
<t tx="ekr.20230509052845.2037">def hash(x) -&gt; int:
    """
    Returns hashed value only for immutable objects
    """
    return x.__hash__()

</t>
<t tx="ekr.20230509052845.2038">def ord(s: str) -&gt; int:
    """
    Return an integer representing the Unicode code point of s
    """
    if len(s) != 1:
        raise TypeError(
            f"ord() expected a character, but string of length {len(s)} found"
        )
    return int(s.ptr[0])

</t>
<t tx="ekr.20230509052845.2039">def divmod(a, b):
    if hasattr(a, "__divmod__"):
        return a.__divmod__(b)
    else:
        return (a // b, a % b)

</t>
<t tx="ekr.20230509052845.204">@path C:/Repos/codon/bench/sum/
# https://towardsdatascience.com/getting-started-with-pypy-ef4ba5cb431c
import time
t1 = time.time()
nums = range(50000000)
sum = 0
for k in nums:
    sum = sum + k
print("Sum of 50000000 numbers is : ", sum)
t2 = time.time()
t = t2 - t1
print(t)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2040">def chr(i: int) -&gt; str:
    """
    Return a string representing a character whose Unicode
    code point is an integer
    """
    p = cobj(1)
    p[0] = byte(i)
    return str(p, 1)

</t>
<t tx="ekr.20230509052845.2041">def next(g: Generator[T], default: Optional[T] = None, T: type) -&gt; T:
    """
    Return the next item from g
    """
    if g.done():
        if default is not None:
            return default.__val__()
        else:
            raise StopIteration()
    return g.next()

</t>
<t tx="ekr.20230509052845.2042">def any(x: Generator[T], T: type) -&gt; bool:
    """
    Returns True if any item in x is true,
    False otherwise
    """
    for a in x:
        if a:
            return True
    return False

</t>
<t tx="ekr.20230509052845.2043">def all(x: Generator[T], T: type) -&gt; bool:
    """
    Returns True when all elements in x are true,
    False otherwise
    """
    for a in x:
        if not a:
            return False
    return True

</t>
<t tx="ekr.20230509052845.2044">def zip(*args):
    """
    Returns a zip object, which is an iterator of tuples
    that aggregates elements based on the iterables passed
    """
    if staticlen(args) == 0:
        yield from List[int]()
    else:
        iters = tuple(iter(i) for i in args)
        done = False
        while not done:
            for i in iters:
                if i.done():
                    done = True
            if not done:
                yield tuple(i.next() for i in iters)
        for i in iters:
            i.destroy()

</t>
<t tx="ekr.20230509052845.2045">def filter(f: Callable[[T], bool], x: Generator[T], T: type) -&gt; Generator[T]:
    """
    Returns all a from the iterable x that are filtered by f
    """
    for a in x:
        if f(a):
            yield a

</t>
<t tx="ekr.20230509052845.2046">def map(f, *args):
    """
    Applies a function on all a in x and returns map object
    """
    if staticlen(args) == 0:
        compile_error("map() expects at least one iterator")
    elif staticlen(args) == 1:
        for a in args[0]:
            yield f(a)
    else:
        for a in zip(*args):
            yield f(*a)

</t>
<t tx="ekr.20230509052845.2047">def enumerate(x, start: int = 0):
    """
    Creates a tuple containing a count (from start which defaults
    to 0) and the values obtained from iterating over x
    """
    i = start
    for a in x:
        yield (i, a)
        i += 1

</t>
<t tx="ekr.20230509052845.2048">def staticenumerate(tup):
    i = -1
    return tuple(((i := i + 1), t) for t in tup)
    i

</t>
<t tx="ekr.20230509052845.2049">def echo(x):
    """
    Print and return argument
    """
    print x
    return x

</t>
<t tx="ekr.20230509052845.205"></t>
<t tx="ekr.20230509052845.2050">def reversed(x):
    """
    Return an iterator that accesses x in the reverse order
    """
    if hasattr(x, "__reversed__"):
        return x.__reversed__()
    else:
        i = x.__len__() - 1
        while i &gt;= 0:
            yield x[i]
            i -= 1

</t>
<t tx="ekr.20230509052845.2051">def round(x, n=0):
    """
    Return the x rounded off to the given
    n digits after the decimal point.
    """
    nx = float.__pow__(10.0, n)
    return float.__round__(x * nx) / nx

</t>
<t tx="ekr.20230509052845.2052">def _sum_start(x, start):
    if isinstance(x.__iter__(), Generator[float]) and isinstance(start, int):
        return float(start)
    else:
        return start

</t>
<t tx="ekr.20230509052845.2053">def sum(x, start=0):
    """
    Return the sum of the items added together from x
    """
    s = _sum_start(x, start)

    for a in x:
        # don't use += to avoid calling iadd
        if isinstance(a, bool):
            s = s + (1 if a else 0)
        else:
            s = s + a

    return s

</t>
<t tx="ekr.20230509052845.2054">def repr(x):
    """Return the string representation of x"""
    return x.__repr__()

</t>
<t tx="ekr.20230509052845.2055">def _int_format(a: int, base: int, prefix: str = ""):
    assert base == 2 or base == 8 or base == 10 or base == 16
    chars = "0123456789abcdef-"

    b = a
    digits = 0
    while b != 0:
        digits += 1
        b //= base

    sz = digits + (1 if a &lt;= 0 else 0) + len(prefix)
    p = Ptr[byte](sz)
    q = p

    if a &lt; 0:
        q[0] = chars[-1].ptr[0]
        q += 1

    if prefix:
        str.memcpy(q, prefix.ptr, len(prefix))
        q += len(prefix)

    if digits != 0:
        b = a
        q += digits - 1
        i = 1
        while b != 0:
            i += 1
            q[0] = chars.ptr[abs(b % base)]
            q += -1
            b //= base
    else:
        q[0] = chars.ptr[0]

    return str(p, sz)

</t>
<t tx="ekr.20230509052845.2056">def bin(n):
    return _int_format(n.__index__(), 2, "0b")

</t>
<t tx="ekr.20230509052845.2057">def oct(n):
    return _int_format(n.__index__(), 8, "0o")

</t>
<t tx="ekr.20230509052845.2058">def hex(n):
    return _int_format(n.__index__(), 16, "0x")

</t>
<t tx="ekr.20230509052845.2059">def pow(base: float, exp: float):
    return base ** exp

</t>
<t tx="ekr.20230509052845.206">@path C:/Repos/codon/bench/taq/
# Parses TAQ file and performs volume peak detection
from sys import argv
from time import time
from statistics import mean, stdev

@others
BUCKET_SIZE = 1_000_000_000
t0 = time()

data = {}
with open(argv[1]) as f:
    header = True

    for line in f:
        if header:
            header = False
            continue

        x = line.split('|')
        if x[0] == 'END' or x[4] == 'ENDP':
            continue

        timestamp = int(x[0])
        symbol = x[2]
        volume = int(x[4])

        series = data.setdefault(symbol, [])
        series.append((timestamp // BUCKET_SIZE, volume))

for symbol, series in data.items():
    y, signals = process_data(series)
    print(symbol, sum(signals))

t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2060">@overload
def pow(base: int, exp: int, mod: Optional[int] = None):
    if exp &lt; 0:
        raise ValueError("pow() negative int exponent not supported")

    if mod is not None:
        if mod == 0:
            raise ValueError("pow() 3rd argument cannot be 0")
        base %= mod

    result = 1
    while exp &gt; 0:
        if exp &amp; 1:
            x = result * base
            result = x % mod if mod is not None else x
        y = base * base
        base = y % mod if mod is not None else y
        exp &gt;&gt;= 1
    return result % mod if mod is not None else result

</t>
<t tx="ekr.20230509052845.2061">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.2062">def _from_str(s: str, base: int):
    from internal.gc import alloc_atomic, free

    if base &lt; 0 or base &gt; 36 or base == 1:
        raise ValueError("int() base must be &gt;= 2 and &lt;= 36, or 0")

    s0 = s
    s = s.strip()
    buf = __array__[byte](32)
    n = len(s)
    need_dyn_alloc = n &gt;= len(buf)

    p = alloc_atomic(n + 1) if need_dyn_alloc else buf.ptr
    str.memcpy(p, s.ptr, n)
    p[n] = byte(0)

    end = cobj()
    result = _C.strtoll(p, __ptr__(end), i32(base))

    if need_dyn_alloc:
        free(p)

    if n == 0 or end != p + n:
        raise ValueError(
            f"invalid literal for int() with base {base}: {s0.__repr__()}"
        )

    return result

</t>
<t tx="ekr.20230509052845.2063">@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.2064">def _from_str(s: str) -&gt; float:
    s0 = s
    s = s.strip()
    buf = __array__[byte](32)
    n = len(s)
    need_dyn_alloc = n &gt;= len(buf)

    p = alloc_atomic(n + 1) if need_dyn_alloc else buf.ptr
    str.memcpy(p, s.ptr, n)
    p[n] = byte(0)

    end = cobj()
    result = _C.strtod(p, __ptr__(end))

    if need_dyn_alloc:
        free(p)

    if n == 0 or end != p + n:
        raise ValueError(f"could not convert string to float: {s0.__repr__()}")

    return result

</t>
<t tx="ekr.20230509052845.2065">def _jit_display(x, s: Static[str], bundle: Set[str] = Set[str]()):
    if isinstance(x, None):
        return
    if hasattr(x, "_repr_mimebundle_") and s == "jupyter":
        d = x._repr_mimebundle_(bundle)
        # TODO: pick appropriate mime
        mime = next(d.keys()) # just pick first
        print(f"\x00\x00__codon/mime__\x00{mime}\x00{d[mime]}", end='')
    elif hasattr(x, "__repr__"):
        print(x.__repr__(), end='')
    elif hasattr(x, "__str__"):
        print(x.__str__(), end='')
</t>
<t tx="ekr.20230509052845.2066">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2067">@__internal__
class __internal__:
    pass

</t>
<t tx="ekr.20230509052845.2068">@tuple
@__internal__
@__notuple__
class bool:
    pass

</t>
<t tx="ekr.20230509052845.2069">@tuple
@__internal__
@__notuple__
class byte:
    pass

</t>
<t tx="ekr.20230509052845.207"># https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data
def find_peaks(y):
    lag = 100
    threshold = 10.0
    influence = 0.5

    t = len(y)
    signals = [0. for _ in range(t)]

    if t &lt;= lag:
        return signals

    filtered_y = [y[i] if i &lt; lag else 0. for i in range(t)]
    avg_filter = [0. for _ in range(t)]
    std_filter = [0. for _ in range(t)]
    avg_filter[lag] = mean(y[:lag])
    std_filter[lag] = stdev(y[:lag])

    for i in range(lag, t):
        if abs(y[i] - avg_filter[i-1]) &gt; threshold * std_filter[i-1]:
            signals[i] = +1 if y[i] &gt; avg_filter[i-1] else -1
            filtered_y[i] = influence*y[i] + (1 - influence)*filtered_y[i-1]
        else:
            signals[i] = 0
            filtered_y[i] = y[i]

        avg_filter[i] = mean(filtered_y[i-lag:i])
        std_filter[i] = stdev(filtered_y[i-lag:i])

    return signals

</t>
<t tx="ekr.20230509052845.2070">@tuple
@__internal__
@__notuple__
class int:
    MAX = 9223372036854775807
    pass

</t>
<t tx="ekr.20230509052845.2071">@tuple
@__internal__
@__notuple__
class float:
    MIN_10_EXP = -307
    pass

</t>
<t tx="ekr.20230509052845.2072">@tuple
@__internal__
@__notuple__
class float32:
    MIN_10_EXP = -37
    pass

</t>
<t tx="ekr.20230509052845.2073">@tuple
@__internal__
class NoneType:
    pass

</t>
<t tx="ekr.20230509052845.2074">@tuple
@__internal__
class type:
    pass

</t>
<t tx="ekr.20230509052845.2075">@tuple
@__internal__
@__notuple__
class Function[T, TR]:
    pass

</t>
<t tx="ekr.20230509052845.2076">@tuple
@__internal__
class Callable[T, TR]:
    pass

</t>
<t tx="ekr.20230509052845.2077">@tuple
@__internal__
@__notuple__
class Ptr[T]:
    pass
</t>
<t tx="ekr.20230509052845.2078">cobj = Ptr[byte]

</t>
<t tx="ekr.20230509052845.2079">@tuple
@__internal__
@__notuple__
class Generator[T]:
    pass

</t>
<t tx="ekr.20230509052845.208">def process_data(series):
    grouped = {}
    for bucket, volume in series:
        grouped[bucket] = grouped.get(bucket, 0) + volume

    y = [float(t[1]) for t in sorted(grouped.items())]
    return y, find_peaks(y)

</t>
<t tx="ekr.20230509052845.2080">@tuple
@__internal__
@__notuple__
class Optional:
    T: type = NoneType

</t>
<t tx="ekr.20230509052845.2081">@tuple
@__internal__
@__notuple__
class Int[N: Static[int]]:
    pass

</t>
<t tx="ekr.20230509052845.2082">@tuple
@__internal__
@__notuple__
class UInt[N: Static[int]]:
    pass

</t>
<t tx="ekr.20230509052845.2083">@__internal__
class pyobj:
    p: Ptr[byte]

</t>
<t tx="ekr.20230509052845.2084">@tuple
@__internal__
class str:
    ptr: Ptr[byte]
    len: int

</t>
<t tx="ekr.20230509052845.2085">@tuple
@__internal__
class Array:
    len: int
    ptr: Ptr[T]
    T: type

</t>
<t tx="ekr.20230509052845.2086">@extend
class type:
    def __new__(obj):
        pass
</t>
<t tx="ekr.20230509052845.2087">function = Function

</t>
<t tx="ekr.20230509052845.2088">@__internal__
class Ref[T]:
    pass

</t>
<t tx="ekr.20230509052845.2089">@tuple
@__internal__
@__notuple__
class Union[TU]:
    # compiler-generated
    def __new__(val):
        TU

</t>
<t tx="ekr.20230509052845.209"></t>
<t tx="ekr.20230509052845.2090"># dummy
@__internal__
class TypeVar[T]: pass
</t>
<t tx="ekr.20230509052845.2091">@__internal__
class ByVal: pass
</t>
<t tx="ekr.20230509052845.2092">@__internal__
class ByRef: pass
</t>
<t tx="ekr.20230509052845.2093">@__internal__
class Tuple: pass

</t>
<t tx="ekr.20230509052845.2094">@__internal__
class ClassVar[T]:
    pass

</t>
<t tx="ekr.20230509052845.2095">@__internal__
@tuple
class CVar[T]:
    def __new__(name: Static[str]) -&gt; T:
        return T()

</t>
<t tx="ekr.20230509052845.2096">@tuple
@__internal__
class __array__:
    T: type
    def __new__(sz: Static[int]) -&gt; Array[T]:
        pass

</t>
<t tx="ekr.20230509052845.2097">def __ptr__(var):
    pass

</t>
<t tx="ekr.20230509052845.2098">def staticlen(obj):
    pass

</t>
<t tx="ekr.20230509052845.2099">def compile_error(msg: Static[str]):
    pass

</t>
<t tx="ekr.20230509052845.21">def __init__(self, x=0, y=0, z=0):
    self.x = x
    self.y = y
    self.z = z

</t>
<t tx="ekr.20230509052845.210">@path C:/Repos/codon/bench/word_count/
from sys import argv
from time import time

t0 = time()
wc = {}
filename = argv[-1]

with open(filename) as f:
    for l in f:
        for w in l.split():
            wc[w] = wc.get(w, 0) + 1

print(len(wc))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2100">def isinstance(obj, what):
    pass

</t>
<t tx="ekr.20230509052845.2101">@__attribute__
def overload():
    pass

</t>
<t tx="ekr.20230509052845.2102">def hasattr(obj, attr: Static[str], *args, **kwargs):
    """Special handling"""
    pass

</t>
<t tx="ekr.20230509052845.2103">@overload
def hasattr(obj, attr: Static[str]):
    pass

</t>
<t tx="ekr.20230509052845.2104">def getattr(obj, attr: Static[str]):
    pass

</t>
<t tx="ekr.20230509052845.2105">def setattr(obj, attr: Static[str], what):
    pass

</t>
<t tx="ekr.20230509052845.2106">def tuple(iterable):
    pass

</t>
<t tx="ekr.20230509052845.2107">def super():
    pass

</t>
<t tx="ekr.20230509052845.2108">def superf(*args):
    """Special handling"""
    pass

</t>
<t tx="ekr.20230509052845.2109">def __realized__(fn, args):
    pass

</t>
<t tx="ekr.20230509052845.211"></t>
<t tx="ekr.20230509052845.2110">def statictuple(*args):
    return args
</t>
<t tx="ekr.20230509052845.2111">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# runtime functions
from C import seq_print(str)
from C import seq_print_full(str, cobj)

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2112">@nocapture
@C
def seq_str_int(a: int, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2113">@nocapture
@C
def seq_str_uint(a: int, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2114">@nocapture
@C
def seq_str_float(a: float, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2115">@nocapture
@C
def seq_str_str(a: str, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2116">@nocapture
@C
def seq_str_ptr(a: cobj, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2117">@pure
@C
def seq_strdup(a: cobj) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.2118">@pure
@C
def seq_stdin() -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2119">@pure
@C
def seq_stdout() -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.212"></t>
<t tx="ekr.20230509052845.2120">@pure
@C
def seq_stderr() -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2121">@no_side_effect
@C
def seq_env() -&gt; Ptr[cobj]:
    pass

</t>
<t tx="ekr.20230509052845.2122">@no_side_effect
@C
def seq_time() -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2123">@no_side_effect
@C
def seq_time_monotonic() -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2124">@no_side_effect
@C
def seq_time_highres() -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2125">@no_side_effect
@C
def seq_localtime(a: int, b: cobj) -&gt; bool:
    pass

</t>
<t tx="ekr.20230509052845.2126">@no_side_effect
@C
def seq_gmtime(a: int, b: cobj) -&gt; bool:
    pass

</t>
<t tx="ekr.20230509052845.2127">@pure
@C
def seq_mktime(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2128">from C import seq_sleep(float)

</t>
<t tx="ekr.20230509052845.2129">@pure
@C
def seq_pid() -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.213">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/util/common.h"

namespace codon {
namespace ir {

class Func;
class Value;

namespace util {
class CloneVisitor;
}

/// Base for CIR attributes.
struct Attribute {
  virtual ~Attribute() noexcept = default;

  /// @return true if the attribute should be propagated across clones
  virtual bool needsClone() const { return true; }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Attribute &amp;a) {
    return a.doFormat(os);
  }

  /// @return a clone of the attribute
  virtual std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const = 0;

  /// @return a clone of the attribute
  virtual std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const {
    return clone(cv);
  }

private:
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

/// Attribute containing SrcInfo
struct SrcInfoAttribute : public Attribute {
  static const std::string AttributeName;

  /// source info
  codon::SrcInfo info;

  SrcInfoAttribute() = default;
  /// Constructs a SrcInfoAttribute.
  /// @param info the source info
  explicit SrcInfoAttribute(codon::SrcInfo info) : info(std::move(info)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;SrcInfoAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; info; }
};

/// Attribute containing docstring from source
struct DocstringAttribute : public Attribute {
  static const std::string AttributeName;

  /// the docstring
  std::string docstring;

  DocstringAttribute() = default;
  /// Constructs a DocstringAttribute.
  /// @param docstring the docstring
  explicit DocstringAttribute(const std::string &amp;docstring) : docstring(docstring) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;DocstringAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; docstring; }
};

/// Attribute containing function information
struct KeyValueAttribute : public Attribute {
  static const std::string AttributeName;

  /// attributes map
  std::map&lt;std::string, std::string&gt; attributes;

  KeyValueAttribute() = default;
  /// Constructs a KeyValueAttribute.
  /// @param attributes the map of attributes
  explicit KeyValueAttribute(std::map&lt;std::string, std::string&gt; attributes)
      : attributes(std::move(attributes)) {}

  /// @param key the key
  /// @return true if the map contains key, false otherwise
  bool has(const std::string &amp;key) const;

  /// @param key the key
  /// @return the value associated with the given key, or empty
  ///         string if none
  std::string get(const std::string &amp;key) const;

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;KeyValueAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute containing type member information
struct MemberAttribute : public Attribute {
  static const std::string AttributeName;

  /// member source info map
  std::map&lt;std::string, SrcInfo&gt; memberSrcInfo;

  MemberAttribute() = default;
  /// Constructs a KeyValueAttribute.
  /// @param attributes the map of attributes
  explicit MemberAttribute(std::map&lt;std::string, SrcInfo&gt; memberSrcInfo)
      : memberSrcInfo(std::move(memberSrcInfo)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;MemberAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to tuple literals
struct TupleLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// values contained in tuple literal
  std::vector&lt;Value *&gt; elements;

  explicit TupleLiteralAttribute(std::vector&lt;Value *&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Information about an element in a collection literal
struct LiteralElement {
  /// the element value
  Value *value;
  /// true if preceded by "*", as in "[*x]"
  bool star;
};

/// Attribute attached to IR structures corresponding to list literals
struct ListLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// elements contained in list literal
  std::vector&lt;LiteralElement&gt; elements;

  explicit ListLiteralAttribute(std::vector&lt;LiteralElement&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to set literals
struct SetLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// elements contained in set literal
  std::vector&lt;LiteralElement&gt; elements;

  explicit SetLiteralAttribute(std::vector&lt;LiteralElement&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to dict literals
struct DictLiteralAttribute : public Attribute {
  struct KeyValuePair {
    /// the key in the literal
    Value *key;
    /// the value in the literal, or null if key is being star-unpacked
    Value *value;
  };

  static const std::string AttributeName;

  /// keys and values contained in dict literal
  std::vector&lt;KeyValuePair&gt; elements;

  explicit DictLiteralAttribute(std::vector&lt;KeyValuePair&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to partial functions
struct PartialFunctionAttribute : public Attribute {
  static const std::string AttributeName;

  /// base name of the function being used in the partial
  std::string name;

  /// partial arguments, or null if none
  /// e.g. "f(a, ..., b)" has elements [a, null, b]
  std::vector&lt;Value *&gt; args;

  PartialFunctionAttribute(const std::string &amp;name, std::vector&lt;Value *&gt; args)
      : name(name), args(std::move(args)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Attribute&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2130">@pure
@C
def seq_lock_new() -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2131">@nocapture
@C
def seq_lock_acquire(a: cobj, b: bool, c: float) -&gt; bool:
    pass

</t>
<t tx="ekr.20230509052845.2132">@nocapture
@C
def seq_lock_release(a: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2133">@pure
@C
def seq_rlock_new() -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2134">@nocapture
@C
def seq_rlock_acquire(a: cobj, b: bool, c: float) -&gt; bool:
    pass

</t>
<t tx="ekr.20230509052845.2135">@nocapture
@C
def seq_rlock_release(a: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2136">@pure
@C
def seq_i32_to_float(a: i32) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2137"># &lt;ctype.h&gt;
@pure
@C
def isdigit(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2138">@pure
@C
def isspace(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2139">@pure
@C
def isupper(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.214">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;cstdint&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/cir/attribute.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/util/visitor.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

using id_t = std::int64_t;

class Func;
class Module;

@others
template &lt;typename Derived&gt; const char ReplaceableNodeBase&lt;Derived&gt;::NodeId = 0;

template &lt;typename Desired&gt; Desired *cast(Node *other) {
  return other != nullptr ? other-&gt;as&lt;Desired&gt;() : nullptr;
}

template &lt;typename Desired&gt; const Desired *cast(const Node *other) {
  return other != nullptr ? other-&gt;as&lt;Desired&gt;() : nullptr;
}

template &lt;typename Desired&gt; bool isA(Node *other) {
  return other &amp;&amp; other-&gt;is&lt;Desired&gt;();
}

template &lt;typename Desired&gt; bool isA(const Node *other) {
  return other &amp;&amp; other-&gt;is&lt;Desired&gt;();
}

} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Node&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2140">@pure
@C
def islower(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2141">@pure
@C
def toupper(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2142">@pure
@C
def tolower(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2143">@pure
@C
def isalnum(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2144">@pure
@C
def isalpha(a: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2145"># &lt;math.h&gt;
@pure
@C
def ceil(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2146">@pure
@C
def floor(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2147">@pure
@C
def fabs(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2148">@pure
@C
def fmod(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2149">@pure
@C
def exp(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.215">/// Mixin class for IR nodes that need ids.
class IdMixin {
private:
  /// the global id counter
  static id_t currentId;

protected:
  /// the instance's id
  id_t id;

public:
  /// Resets the global id counter.
  static void resetId();

  IdMixin() : id(currentId++) {}

  /// @return the node's id.
  virtual id_t getId() const { return id; }
};

</t>
<t tx="ekr.20230509052845.2150">@pure
@C
def expm1(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2151">@pure
@C
def ldexp(a: float, b: i32) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2152">@pure
@C
def log(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2153">@pure
@C
def log2(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2154">@pure
@C
def log10(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2155">@pure
@C
def sqrt(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2156">@pure
@C
def pow(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2157">@pure
@C
def round(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2158">@pure
@C
def acos(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2159">@pure
@C
def asin(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.216">/// Base for named IR nodes.
class Node {
private:
  /// the node's name
  std::string name;
  /// key-value attribute store
  std::map&lt;std::string, std::unique_ptr&lt;Attribute&gt;&gt; attributes;
  /// the module
  Module *module = nullptr;
  /// a replacement, if set
  Node *replacement = nullptr;

public:
  // RTTI is implemented using a port of LLVM's Extensible RTTI
  // For more details, see
  // https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#rtti-for-open-class-hierarchies
  static const char NodeId;

  /// Constructs a node.
  /// @param name the node's name
  explicit Node(std::string name = "") : name(std::move(name)) {}

  /// See LLVM documentation.
  static const void *nodeId() { return &amp;NodeId; }
  /// See LLVM documentation.
  virtual bool isConvertible(const void *other) const {
    if (hasReplacement())
      return getActual()-&gt;isConvertible(other);
    return other == nodeId();
  }
  /// See LLVM documentation.
  template &lt;typename Target&gt; bool is() const { return isConvertible(Target::nodeId()); }
  /// See LLVM documentation.
  template &lt;typename Target&gt; Target *as() {
    return isConvertible(Target::nodeId()) ? static_cast&lt;Target *&gt;(getActual())
                                           : nullptr;
  }
  /// See LLVM documentation.
  template &lt;typename Target&gt; const Target *as() const {
    return isConvertible(Target::nodeId()) ? static_cast&lt;const Target *&gt;(getActual())
                                           : nullptr;
  }

  /// @return the node's name
  const std::string &amp;getName() const { return getActual()-&gt;name; }
  /// Sets the node's name
  /// @param n the new name
  void setName(std::string n) { getActual()-&gt;name = std::move(n); }

  /// Accepts visitors.
  /// @param v the visitor
  virtual void accept(util::Visitor &amp;v) = 0;
  /// Accepts visitors.
  /// @param v the visitor
  virtual void accept(util::ConstVisitor &amp;v) const = 0;

@others
};

</t>
<t tx="ekr.20230509052845.2160">@pure
@C
def atan(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2161">@pure
@C
def atan2(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2162">@pure
@C
def cos(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2163">@pure
@C
def sin(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2164">@pure
@C
def tan(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2165">@pure
@C
def cosh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2166">@pure
@C
def sinh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2167">@pure
@C
def tanh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2168">@pure
@C
def acosh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2169">@pure
@C
def asinh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.217">  /// Sets an attribute
  /// @param the attribute key
  /// @param value the attribute
  void setAttribute(std::unique_ptr&lt;Attribute&gt; value, const std::string &amp;key) {
    getActual()-&gt;attributes[key] = std::move(value);
  }
</t>
<t tx="ekr.20230509052845.2170">@pure
@C
def atanh(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2171">@pure
@C
def copysign(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2172">@pure
@C
def log1p(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2173">@pure
@C
def trunc(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2174">@pure
@C
def log2(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2175">@pure
@C
def erf(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2176">@pure
@C
def erfc(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2177">@pure
@C
def tgamma(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2178">@pure
@C
def lgamma(a: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2179">@pure
@C
def remainder(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.218">  /// Sets an attribute
  /// @param value the attribute
  template &lt;typename AttributeType&gt;
  void setAttribute(std::unique_ptr&lt;AttributeType&gt; value) {
    setAttribute(std::move(value), AttributeType::AttributeName);
  }

</t>
<t tx="ekr.20230509052845.2180">@pure
@C
def hypot(a: float, b: float) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2181">@nocapture
@C
def frexp(a: float, b: Ptr[Int[32]]) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2182">@nocapture
@C
def modf(a: float, b: Ptr[float]) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2183">@pure
@C
def ceilf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2184">@pure
@C
def floorf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2185">@pure
@C
def fabsf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2186">@pure
@C
def fmodf(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2187">@pure
@C
def expf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2188">@pure
@C
def expm1f(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2189">@pure
@C
def ldexpf(a: float32, b: i32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.219">  /// @param n the name
  /// @return true if the attribute is in the store
  bool hasAttribute(const std::string &amp;n) const {
    auto *actual = getActual();
    return actual-&gt;attributes.find(n) != actual-&gt;attributes.end();
  }
</t>
<t tx="ekr.20230509052845.2190">@pure
@C
def logf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2191">@pure
@C
def log2f(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2192">@pure
@C
def log10f(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2193">@pure
@C
def sqrtf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2194">@pure
@C
def powf(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2195">@pure
@C
def roundf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2196">@pure
@C
def acosf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2197">@pure
@C
def asinf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2198">@pure
@C
def atanf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2199">@pure
@C
def atan2f(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.22">def Mag(self):
    return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)

</t>
<t tx="ekr.20230509052845.220">  /// @return true if the attribute is in the store
  template &lt;typename AttributeType&gt; bool hasAttribute() const {
    return hasAttribute(AttributeType::AttributeName);
  }

  /// Gets the appropriate attribute.
  /// @param key the attribute key
  Attribute *getAttribute(const std::string &amp;key) {
    auto *actual = getActual();

    auto it = actual-&gt;attributes.find(key);
    return it != actual-&gt;attributes.end() ? it-&gt;second.get() : nullptr;
  }
</t>
<t tx="ekr.20230509052845.2200">@pure
@C
def cosf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2201">@pure
@C
def sinf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2202">@pure
@C
def tanf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2203">@pure
@C
def coshf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2204">@pure
@C
def sinhf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2205">@pure
@C
def tanhf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2206">@pure
@C
def acoshf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2207">@pure
@C
def asinhf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2208">@pure
@C
def atanhf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2209">@pure
@C
def copysignf(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.221">  /// Gets the appropriate attribute.
  /// @param key the attribute key
  const Attribute *getAttribute(const std::string &amp;key) const {
    auto *actual = getActual();

    auto it = actual-&gt;attributes.find(key);
    return it != actual-&gt;attributes.end() ? it-&gt;second.get() : nullptr;
  }
</t>
<t tx="ekr.20230509052845.2210">@pure
@C
def log1pf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2211">@pure
@C
def truncf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2212">@pure
@C
def log2f(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2213">@pure
@C
def erff(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2214">@pure
@C
def erfcf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2215">@pure
@C
def tgammaf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2216">@pure
@C
def lgammaf(a: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2217">@pure
@C
def remainderf(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2218">@pure
@C
def hypotf(a: float32, b: float32) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2219">@nocapture
@C
def frexpf(a: float32, b: Ptr[Int[32]]) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.222">  /// Gets the appropriate attribute.
  /// @tparam AttributeType the return type
  template &lt;typename AttributeType&gt; AttributeType *getAttribute() {
    return static_cast&lt;AttributeType *&gt;(getAttribute(AttributeType::AttributeName));
  }
  /// Gets the appropriate attribute.
  /// @tparam AttributeType the return type
  template &lt;typename AttributeType&gt; const AttributeType *getAttribute() const {
    return static_cast&lt;const AttributeType *&gt;(
        getAttribute(AttributeType::AttributeName));
  }

</t>
<t tx="ekr.20230509052845.2220">@nocapture
@C
def modff(a: float32, b: Ptr[float32]) -&gt; float32:
    pass

</t>
<t tx="ekr.20230509052845.2221"># &lt;stdio.h&gt;
@pure
@C
def ferror(a: cobj) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2222">@nocapture
@C
def fgetc(a: cobj) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2223">@nocapture
@C
def fopen(a: cobj, b: cobj) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2224">@nocapture
@C
def fdopen(a: int, b: cobj) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2225">@nocapture
@C
def fclose(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2226">@nocapture
@C
def fread(a: cobj, b: int, c: int, d: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2227">@nocapture
@C
def fwrite(a: cobj, b: int, c: int, d: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2228">@nocapture
@C
def ftell(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2229">@nocapture
@C
def fseek(a: cobj, b: int, c: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.223">  /// @return iterator to the first attribute
  auto attributes_begin() {
    return util::map_key_adaptor(getActual()-&gt;attributes.begin());
  }
</t>
<t tx="ekr.20230509052845.2230">@nocapture
@C
def fgets(a: cobj, b: int, c: cobj) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2231">@nocapture
@C
def fflush(a: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2232">@nocapture
@C
def getline(a: Ptr[cobj], b: Ptr[int], c: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2233"># &lt;stdlib.h&gt;
from C import exit(int)

</t>
<t tx="ekr.20230509052845.2234">@nocapture
@C
def system(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2235">@nocapture
@C
def free(a: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2236">@pure
@C
def atoi(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2237">@nocapture
@C
def strtoll(a: cobj, b: Ptr[cobj], c: i32) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2238">@nocapture
@C
def strtod(a: cobj, b: Ptr[cobj]) -&gt; float:
    pass

</t>
<t tx="ekr.20230509052845.2239"># &lt;zlib.h&gt;
@nocapture
@C
def gzopen(a: cobj, b: cobj) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.224">  /// @return iterator beyond the last attribute
  auto attributes_end() { return util::map_key_adaptor(getActual()-&gt;attributes.end()); }
</t>
<t tx="ekr.20230509052845.2240">@nocapture
@C
def gzerror(a: cobj, b: Ptr[i32]) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2241">@nocapture
@C
def gzgetc(a: cobj) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2242">@nocapture
@C
def gzgets(a: cobj, b: cobj, c: i32) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2243">@nocapture
@C
def gzclose(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2244">@nocapture
@C
def gzread(a: cobj, b: cobj, c: u32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2245">@nocapture
@C
def gzwrite(a: cobj, b: cobj, c: u32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2246">@nocapture
@C
def gztell(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2247">@nocapture
@C
def gzseek(a: cobj, b: int, c: i32) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.2248">@nocapture
@C
def gzflush(a: cobj, b: i32) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.2249"># &lt;string.h&gt;
@pure
@C
def memcmp(lhs: Ptr[byte], rhs: Ptr[byte], count: int) -&gt; i32:
    pass

</t>
<t tx="ekr.20230509052845.225">  /// @return iterator to the first attribute
  auto attributes_begin() const {
    return util::const_map_key_adaptor(getActual()-&gt;attributes.begin());
  }
</t>
<t tx="ekr.20230509052845.2250">@pure
@C
def memchr(p: Ptr[byte], ch: i32, count: int) -&gt; Ptr[byte]:
    pass
</t>
<t tx="ekr.20230509052845.2251">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2252">@pure
@C
def seq_is_macos() -&gt; bool:
    pass

</t>
<t tx="ekr.20230509052845.2253"># &lt;dlfcn.h&gt;
from C import dlerror() -&gt; cobj as c_dlerror
from C import dlopen(cobj, int) -&gt; cobj as c_dlopen
from C import dlsym(cobj, cobj) -&gt; cobj as c_dlsym
from C import dlclose(cobj) -&gt; i32 as c_dlclose

RTLD_NOW = 2
RTLD_GLOBAL = 8 if seq_is_macos() else 256
RTLD_LOCAL = 0 if seq_is_macos() else 256

</t>
<t tx="ekr.20230509052845.2254">def dlext() -&gt; str:
    if seq_is_macos():
        return "dylib"
    else:
        return "so"

</t>
<t tx="ekr.20230509052845.2255">@pure
def dlerror() -&gt; str:
    return str.from_ptr(c_dlerror())

</t>
<t tx="ekr.20230509052845.2256">def dlopen(name: str, flag: int = RTLD_NOW | RTLD_GLOBAL) -&gt; cobj:
    h = c_dlopen(cobj() if name == "" else name.c_str(), flag)
    if h == cobj():
        raise CError(dlerror())
    return h

</t>
<t tx="ekr.20230509052845.2257">def dlsym(lib, name: str, Fn: type) -&gt; Fn:
    h = cobj()
    if isinstance(lib, str):
        h = dlopen(lib)
    else:
        h = lib
    fn = c_dlsym(h, name.c_str())
    if fn == cobj():
        raise CError(dlerror())
    return Fn(fn)

</t>
<t tx="ekr.20230509052845.2258">def dlclose(handle: cobj):
    if c_dlclose(handle) != i32(0):
        raise CError(dlerror())
</t>
<t tx="ekr.20230509052845.2259">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import realloc, free

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.226">  /// @return iterator beyond the last attribute
  auto attributes_end() const {
    return util::const_map_key_adaptor(getActual()-&gt;attributes.end());
  }

</t>
<t tx="ekr.20230509052845.2260">class File:
    sz: int
    buf: Ptr[byte]
    fp: cobj

    @others
</t>
<t tx="ekr.20230509052845.2261">def __init__(self, fp: cobj):
    self.fp = fp
    self._reset()

</t>
<t tx="ekr.20230509052845.2262">def __init__(self, path: str, mode: str):
    self.fp = _C.fopen(path.c_str(), mode.c_str())
    if not self.fp:
        raise IOError(f"file {path} could not be opened")
    self._reset()

</t>
<t tx="ekr.20230509052845.2263">def _errcheck(self, msg: str):
    err = int(_C.ferror(self.fp))
    if err:
        raise IOError(f"file I/O error: {msg}")

</t>
<t tx="ekr.20230509052845.2264">def __enter__(self):
    pass

</t>
<t tx="ekr.20230509052845.2265">def __exit__(self):
    self.close()

</t>
<t tx="ekr.20230509052845.2266">def __iter__(self) -&gt; Generator[str]:
    for a in self._iter():
        yield a.__ptrcopy__()

</t>
<t tx="ekr.20230509052845.2267">def readlines(self) -&gt; List[str]:
    return [l for l in self]

</t>
<t tx="ekr.20230509052845.2268">def write(self, s: str):
    self._ensure_open()
    _C.fwrite(s.ptr, 1, len(s), self.fp)
    self._errcheck("error in write")

</t>
<t tx="ekr.20230509052845.2269">def __file_write_gen__(self, g: Generator[T], T: type):
    for s in g:
        self.write(str(s))

</t>
<t tx="ekr.20230509052845.227">  /// Helper to add source information.
  /// @param the source information
  void setSrcInfo(codon::SrcInfo s) {
    setAttribute(std::make_unique&lt;SrcInfoAttribute&gt;(std::move(s)));
  }
</t>
<t tx="ekr.20230509052845.2270">def read(self, sz: int = -1) -&gt; str:
    self._ensure_open()
    if sz &lt; 0:
        SEEK_SET = 0
        SEEK_END = 2
        cur = _C.ftell(self.fp)
        _C.fseek(self.fp, 0, i32(SEEK_END))
        sz = _C.ftell(self.fp) - cur
        _C.fseek(self.fp, cur, i32(SEEK_SET))
    buf = Ptr[byte](sz)
    ret = _C.fread(buf, 1, sz, self.fp)
    self._errcheck("error in read")
    return str(buf, ret)

</t>
<t tx="ekr.20230509052845.2271">def tell(self) -&gt; int:
    self._ensure_open()
    ret = _C.ftell(self.fp)
    self._errcheck("error in tell")
    return ret

</t>
<t tx="ekr.20230509052845.2272">def seek(self, offset: int, whence: int):
    self._ensure_open()
    _C.fseek(self.fp, offset, i32(whence))
    self._errcheck("error in seek")

</t>
<t tx="ekr.20230509052845.2273">def flush(self):
    self._ensure_open()
    _C.fflush(self.fp)

</t>
<t tx="ekr.20230509052845.2274">def close(self):
    if self.fp:
        _C.fclose(self.fp)
        self.fp = cobj()
    if self.buf:
        _C.free(self.buf)
        self._reset()

</t>
<t tx="ekr.20230509052845.2275">def _ensure_open(self):
    if not self.fp:
        raise IOError("I/O operation on closed file")

</t>
<t tx="ekr.20230509052845.2276">def _reset(self):
    self.buf = Ptr[byte]()
    self.sz = 0

</t>
<t tx="ekr.20230509052845.2277">def _iter(self) -&gt; Generator[str]:
    self._ensure_open()
    while True:
        rd = _C.getline(
            Ptr[Ptr[byte]](self.__raw__() + 8), Ptr[int](self.__raw__()), self.fp
        )
        if rd != -1:
            yield str(self.buf, rd)
        else:
            break

</t>
<t tx="ekr.20230509052845.2278">def _iter_trim_newline(self) -&gt; Generator[str]:
    self._ensure_open()
    while True:
        rd = _C.getline(
            Ptr[Ptr[byte]](self.__raw__() + 8), Ptr[int](self.__raw__()), self.fp
        )
        if rd != -1:
            if self.buf[rd - 1] == byte(10):
                rd -= 1
            yield str(self.buf, rd)
        else:
            break

</t>
<t tx="ekr.20230509052845.2279">def _gz_errcheck(stream: cobj):
    errnum = i32(0)
    msg = _C.gzerror(stream, __ptr__(errnum))
    if msg and msg[0]:
        raise IOError(f"zlib error: {str(msg, _C.strlen(msg))}")

</t>
<t tx="ekr.20230509052845.228">  /// @return the src info
  codon::SrcInfo getSrcInfo() const {
    return getAttribute&lt;SrcInfoAttribute&gt;() ? getAttribute&lt;SrcInfoAttribute&gt;()-&gt;info
                                            : codon::SrcInfo();
  }

  /// @return a text representation of a reference to the object
  virtual std::string referenceString() const { return getActual()-&gt;name; }

  /// @return the IR module
  Module *getModule() const { return getActual()-&gt;module; }
  /// Sets the module.
  /// @param m the new module
  void setModule(Module *m) { getActual()-&gt;module = m; }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Node &amp;a);

  bool hasReplacement() const { return replacement != nullptr; }

  /// @return a vector of all the node's children
  virtual std::vector&lt;Value *&gt; getUsedValues() { return {}; }
  /// @return a vector of all the node's children
  virtual std::vector&lt;const Value *&gt; getUsedValues() const { return {}; }
  /// Physically replaces all instances of a child value.
  /// @param id the id of the value to be replaced
  /// @param newValue the new value
  /// @return number of replacements
  virtual int replaceUsedValue(id_t id, Value *newValue) { return 0; }
  /// Physically replaces all instances of a child value.
  /// @param oldValue the old value
  /// @param newValue the new value
  /// @return number of replacements
  int replaceUsedValue(Value *old, Value *newValue);

  /// @return a vector of all the node's used types
  virtual std::vector&lt;types::Type *&gt; getUsedTypes() const { return {}; }
  /// Physically replaces all instances of a used type.
  /// @param name the name of the type being replaced
  /// @param newType the new type
  /// @return number of replacements
  virtual int replaceUsedType(const std::string &amp;name, types::Type *newType) {
    return 0;
  }
  /// Physically replaces all instances of a used type.
  /// @param old the old type
  /// @param newType the new type
  /// @return number of replacements
  int replaceUsedType(types::Type *old, types::Type *newType);

  /// @return a vector of all the node's used variables
  virtual std::vector&lt;Var *&gt; getUsedVariables() { return {}; }
  /// @return a vector of all the node's used variables
  virtual std::vector&lt;const Var *&gt; getUsedVariables() const { return {}; }
  /// Physically replaces all instances of a used variable.
  /// @param id the id of the variable
  /// @param newType the new type
  /// @return number of replacements
  virtual int replaceUsedVariable(id_t id, Var *newVar) { return 0; }
  /// Physically replaces all instances of a used variable.
  /// @param old the old variable
  /// @param newVar the new variable
  /// @return number of replacements
  int replaceUsedVariable(Var *old, Var *newVar);

  template &lt;typename, typename&gt; friend class AcceptorExtend;
  template &lt;typename&gt; friend class ReplaceableNodeBase;

private:
  Node *getActual() { return replacement ? replacement-&gt;getActual() : this; }
</t>
<t tx="ekr.20230509052845.2280">class gzFile:
    sz: int
    buf: Ptr[byte]
    fp: cobj

    @others
</t>
<t tx="ekr.20230509052845.2281">def __init__(self, fp: cobj):
    self.fp = fp
    self._reset()

</t>
<t tx="ekr.20230509052845.2282">def __init__(self, path: str, mode: str):
    self.fp = _C.gzopen(path.c_str(), mode.c_str())
    if not self.fp:
        raise IOError(f"file {path} could not be opened")
    self._reset()

</t>
<t tx="ekr.20230509052845.2283">def _getline(self) -&gt; int:
    if not self.buf:
        self.sz = 128
        self.buf = Ptr[byte](self.sz)

    offset = 0
    while True:
        if not _C.gzgets(self.fp, self.buf + offset, i32(self.sz - offset)):
            _gz_errcheck(self.fp)
            if offset == 0:
                return -1
            break

        offset += _C.strlen(self.buf + offset)

        if self.buf[offset - 1] == byte(10):  # '\n'
            break

        oldsz = self.sz
        self.sz *= 2
        self.buf = realloc(self.buf, self.sz, oldsz)

    return offset

</t>
<t tx="ekr.20230509052845.2284">def __iter__(self) -&gt; Generator[str]:
    for a in self._iter():
        yield a.__ptrcopy__()

</t>
<t tx="ekr.20230509052845.2285">def __enter__(self):
    pass

</t>
<t tx="ekr.20230509052845.2286">def __exit__(self):
    self.close()

</t>
<t tx="ekr.20230509052845.2287">def close(self):
    if self.fp:
        _C.gzclose(self.fp)
        self.fp = cobj()
    if self.buf:
        free(self.buf)
        self._reset()

</t>
<t tx="ekr.20230509052845.2288">def readlines(self) -&gt; List[str]:
    return [l for l in self]

</t>
<t tx="ekr.20230509052845.2289">def write(self, s: str):
    self._ensure_open()
    _C.gzwrite(self.fp, s.ptr, u32(len(s)))
    _gz_errcheck(self.fp)

</t>
<t tx="ekr.20230509052845.229">  const Node *getActual() const {
    return replacement ? replacement-&gt;getActual() : this;
  }
</t>
<t tx="ekr.20230509052845.2290">def __file_write_gen__(self, g: Generator[T], T: type):
    for s in g:
        self.write(str(s))

</t>
<t tx="ekr.20230509052845.2291">def read(self, sz: int = -1) -&gt; str:
    self._ensure_open()
    if sz &lt; 0:
        buf = _strbuf()
        for a in self._iter():
            buf.append(a)
        return buf.__str__()
    buf = Ptr[byte](sz)
    ret = _C.gzread(self.fp, buf, u32(sz))
    _gz_errcheck(self.fp)
    return str(buf, int(ret))

</t>
<t tx="ekr.20230509052845.2292">def tell(self) -&gt; int:
    self._ensure_open()
    ret = _C.gztell(self.fp)
    _gz_errcheck(self.fp)
    return ret

</t>
<t tx="ekr.20230509052845.2293">def seek(self, offset: int, whence: int):
    self._ensure_open()
    _C.gzseek(self.fp, offset, i32(whence))
    _gz_errcheck(self.fp)

</t>
<t tx="ekr.20230509052845.2294">def flush(self):
    Z_FINISH = 4
    self._ensure_open()
    _C.gzflush(self.fp, i32(Z_FINISH))
    _gz_errcheck(self.fp)

</t>
<t tx="ekr.20230509052845.2295">def _iter(self) -&gt; Generator[str]:
    self._ensure_open()
    while True:
        rd = self._getline()
        if rd != -1:
            yield str(self.buf, rd)
        else:
            break

</t>
<t tx="ekr.20230509052845.2296">def _iter_trim_newline(self) -&gt; Generator[str]:
    self._ensure_open()
    while True:
        rd = self._getline()
        if rd != -1:
            if self.buf[rd - 1] == byte(10):
                rd -= 1
            yield str(self.buf, rd)
        else:
            break

</t>
<t tx="ekr.20230509052845.2297">def _ensure_open(self):
    if not self.fp:
        raise IOError("I/O operation on closed file")

</t>
<t tx="ekr.20230509052845.2298">def _reset(self):
    self.buf = cobj()
    self.sz = 0

</t>
<t tx="ekr.20230509052845.2299">def open(path: str, mode: str = "r") -&gt; File:
    return File(path, mode)

</t>
<t tx="ekr.20230509052845.23">def dist(self, other):
    return math.sqrt((self.x - other.x) ** 2
                     + (self.y - other.y) ** 2
                     + (self.z - other.z) ** 2)

</t>
<t tx="ekr.20230509052845.230">template &lt;typename Derived, typename Parent&gt; class AcceptorExtend : public Parent {
public:
  using Parent::Parent;

  /// See LLVM documentation.
  static const void *nodeId() { return &amp;Derived::NodeId; }
  /// See LLVM documentation.
  virtual bool isConvertible(const void *other) const {
    if (Node::hasReplacement())
      return Node::getActual()-&gt;isConvertible(other);

    return other == nodeId() || Parent::isConvertible(other);
  }

</t>
<t tx="ekr.20230509052845.2300">def gzopen(path: str, mode: str = "r") -&gt; gzFile:
    return gzFile(path, mode)

</t>
<t tx="ekr.20230509052845.2301">def is_binary(path: str) -&gt; bool:
    # https://stackoverflow.com/questions/898669/how-can-i-detect-if-a-file-is-binary-non-text-in-python/7392391#7392391
    # Can get both false positive and false negatives, but still is a
    # clever approach that works for the large majority of files
    textchars = {7, 8, 9, 10, 12, 13, 27} | set(iter(range(0x20, 0x100))) - {0x7F}
    with open(path, "rb") as f:
        header = f.read(1024)
        return any(ord(c) not in textchars for c in header)
</t>
<t tx="ekr.20230509052845.2302">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2303">def _format_error(ret: str):
	raise ValueError(f"invalid format specifier: {ret}")

</t>
<t tx="ekr.20230509052845.2304">@extend
class int:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_int(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

</t>
<t tx="ekr.20230509052845.2305">@extend
class Int:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_int(self.__int__(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

</t>
<t tx="ekr.20230509052845.2306">@extend
class UInt:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_uint(self.__int__(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

</t>
<t tx="ekr.20230509052845.2307">@extend
class float:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_float(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret if ret != "-nan" else "nan"

</t>
<t tx="ekr.20230509052845.2308">@extend
class str:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_str(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

</t>
<t tx="ekr.20230509052845.2309">@extend
class Ptr:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_ptr(self.as_byte(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

</t>
<t tx="ekr.20230509052845.231">  void accept(util::Visitor &amp;v) {
    if (Node::hasReplacement())
      Node::getActual()-&gt;accept(v);
    else
      v.visit(static_cast&lt;Derived *&gt;(this));
  }

</t>
<t tx="ekr.20230509052845.2310">def _divmod_10(dividend, N: Static[int]):
    T = type(dividend)
    zero, one = T(0), T(1)
    neg = dividend &lt; zero
    dvd = dividend.__abs__()

    remainder = 0
    quotient = zero

    # Euclidean division
    for bit_idx in range(N - 1, -1, -1):
        mask = int((dvd &amp; (one &lt;&lt; T(bit_idx))) != zero)
        remainder = (remainder &lt;&lt; 1) + mask
        if remainder &gt;= 10:
            quotient = (quotient &lt;&lt; one) + one
            remainder -= 10
        else:
            quotient = quotient &lt;&lt; one

    if neg:
        quotient = -quotient
        remainder = -remainder

    return quotient, remainder

</t>
<t tx="ekr.20230509052845.2311">@extend
class Int:
    @others
</t>
<t tx="ekr.20230509052845.2312">def __str__(self) -&gt; str:
    if N &lt;= 64:
        return str(int(self))

    if not self:
        return '0'

    s = _strbuf()
    d = self

    if d &gt;= Int[N](0):
        while True:
            d, m = _divmod_10(d, N)
            b = byte(48 + m)  # 48 == ord('0')
            s.append(str(__ptr__(b), 1))
            if not d:
                break
    else:
        while True:
            d, m = _divmod_10(d, N)
            b = byte(48 - m)  # 48 == ord('0')
            s.append(str(__ptr__(b), 1))

            if not d:
                break
        s.append('-')

    s.reverse()
    return s.__str__()

</t>
<t tx="ekr.20230509052845.2313">@extend
class UInt:
    @others
</t>
<t tx="ekr.20230509052845.2314">def __str__(self) -&gt; str:
    if N &lt;= 64:
        return self.__format__("")

    s = _strbuf()
    d = self

    while True:
        d, m = _divmod_10(d, N)
        b = byte(48 + int(m))  # 48 == ord('0')
        s.append(str(__ptr__(b), 1))
        if not d:
            break

    s.reverse()
    return s.__str__()
</t>
<t tx="ekr.20230509052845.2315">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Primarily for internal use. Regular users should not use this module.

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2316">@pure
@C
def seq_alloc(a: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2317">@pure
@C
def seq_alloc_atomic(a: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2318">@pure
@C
def seq_alloc_uncollectable(a: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2319">@pure
@C
def seq_alloc_atomic_uncollectable(a: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.232">  void accept(util::ConstVisitor &amp;v) const {
    if (Node::hasReplacement())
      Node::getActual()-&gt;accept(v);
    else
      v.visit(static_cast&lt;const Derived *&gt;(this));
  }
</t>
<t tx="ekr.20230509052845.2320">@nocapture
@derives
@C
def seq_realloc(p: cobj, newsize: int, oldsize: int) -&gt; cobj:
    pass

</t>
<t tx="ekr.20230509052845.2321">@nocapture
@C
def seq_free(p: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2322">@nocapture
@C
def seq_register_finalizer(p: cobj, f: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2323">@nocapture
@C
def seq_gc_add_roots(p: cobj, q: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2324">@nocapture
@C
def seq_gc_remove_roots(p: cobj, q: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2325">@C
def seq_gc_clear_roots() -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2326">@nocapture
@C
def seq_gc_exclude_static_roots(p: cobj, q: cobj) -&gt; None:
    pass

</t>
<t tx="ekr.20230509052845.2327">def sizeof(T: type):
    return T.__elemsize__

</t>
<t tx="ekr.20230509052845.2328">def atomic(T: type):
    return T.__atomic__

</t>
<t tx="ekr.20230509052845.2329">def alloc(sz: int):
    return seq_alloc(sz)

</t>
<t tx="ekr.20230509052845.233">};

</t>
<t tx="ekr.20230509052845.2330"># Allocates a block of memory via GC, where the
# caller guarantees that this block will not store
# pointers to other GC-allocated data.
def alloc_atomic(sz: int):
    return seq_alloc_atomic(sz)

</t>
<t tx="ekr.20230509052845.2331"># Allocates a block of memory via GC that is scanned,
# but not collected itself. Should be free'd explicitly.
def alloc_uncollectable(sz: int):
    return seq_alloc_uncollectable(sz)

</t>
<t tx="ekr.20230509052845.2332"># Allocates a block of memory via GC that is scanned,
# but not collected itself. Should be free'd explicitly.
def alloc_atomic_uncollectable(sz: int):
    return seq_alloc_atomic_uncollectable(sz)

</t>
<t tx="ekr.20230509052845.2333">def realloc(p: cobj, newsz: int, oldsz: int):
    return seq_realloc(p, newsz, oldsz)

</t>
<t tx="ekr.20230509052845.2334">def free(p: cobj):
    seq_free(p)

</t>
<t tx="ekr.20230509052845.2335">def add_roots(start: cobj, end: cobj):
    seq_gc_add_roots(start, end)

</t>
<t tx="ekr.20230509052845.2336">def remove_roots(start: cobj, end: cobj):
    seq_gc_remove_roots(start, end)

</t>
<t tx="ekr.20230509052845.2337">def clear_roots():
    seq_gc_clear_roots()

</t>
<t tx="ekr.20230509052845.2338">def exclude_static_roots(start: cobj, end: cobj):
    seq_gc_exclude_static_roots(start, end)

</t>
<t tx="ekr.20230509052845.2339">def register_finalizer(p):
    if hasattr(p, "__del__"):

        def f(x: cobj, data: cobj, T: type):
            Ptr[T](__ptr__(x).as_byte())[0].__del__()

        seq_register_finalizer(p.__raw__(), f(T=type(p), ...).__raw__())

</t>
<t tx="ekr.20230509052845.234">template &lt;typename Derived&gt;
@others
</t>
<t tx="ekr.20230509052845.2340">def construct_ref[T](args) -&gt; T:
    p = T.__new__()
    p.__init__(*args)
    return p
</t>
<t tx="ekr.20230509052845.2341">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import (
    alloc, alloc_atomic, alloc_uncollectable, alloc_atomic_uncollectable,
    free, atomic, sizeof, register_finalizer
)

__vtable_size__ = 0

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2342">@extend
class __internal__:
    @others
    # TODO: keep this commented until static for lands
    # @pure
    # @llvm
    # def __raw__(self) -&gt; Ptr[byte]:
    #     ret i8* %self
    # def __iter__(self):
    #     for _, i in self.__static_list__:
    #         yield i
    # def __contains__(self, what):
    #     for _, i in self.__static_list__:
    #         if isinstance(what, type(i)):
    #             if what == i:
    #                 return True
    #     return False
    # def __eq__(self, obj) -&gt; bool:
    #     for ii, i in self.__static_list__:
    #         if not i == obj.__static_list__[ii]:
    #             return False
    #     return True
    # def __ne__(self, obj) -&gt; bool:
    #     return not self == obj
    # def __lt__(self, obj) -&gt; bool:
    #     for ii, i in self.__static_list__:
    #         if i &lt; obj.__static_list__[ii]:
    #             return True
    #         elif not i == obj.__static_list__[ii]:
    #             return False
    #     return False
    # def __le__(self, obj) -&gt; bool:
    #     return self &lt; obj or self == obj
    # def __ge__(self, obj) -&gt; bool:
    #     return not self &lt; obj
    # def __gt__(self, obj) -&gt; bool:
    #     return not self &lt; obj and not self == obj
    # def __hash__(self) -&gt; int:
    #     seed = 0
    #     for _, i in self.__static_list__:
    #         seed = seed ^ ((i.__hash__() + 2654435769) + ((seed &lt;&lt; 6) + (seed &gt;&gt; 2)))
    #     return seed
    # def __pickle__(self, dest: Ptr[byte]) -&gt; None:
    #     for _, i in self.__static_list__:
    #         i.__pickle__(dest)
    # # __unpickle
    # def __len__(self):
    #     return staticlen(self)
    # def __to_py__(self) -&gt; cobj:
    #     o = pyobj._tuple_new(staticlen(self))
    #     for ii, i in self.__static_list__:
    #         pyobj._tuple_set(o, ii + 1, i.__to_py__())
    #     return o
    # # __from_py__
    # def __repr__(self) -&gt; str:
    #     a = __array__[str](staticlen(self))
    #     n = __array__[str](staticlen(self))
    #     for ii, i in self.__static_list__:
    #         a.__setitem__(ii, i.__repr__())
    #         n.__setitem__(ii, i.__static_name__)
    #     return __internal__.tuple_str(a.ptr, n.ptr, staticlen(self))
    # def __dict__(self) -&gt; str:
    #     d = List[str](staticlen(self))
    #     for _, i in self.__static_list__:
    #         d.append(i.__static_name)
    #     return d
    # def __add__(self, obj):
    #     return (*self, *obj)

</t>
<t tx="ekr.20230509052845.2343">def yield_final(val):
    pass
</t>
<t tx="ekr.20230509052845.2344">def yield_in_no_suspend(T: type) -&gt; T:
    pass

</t>
<t tx="ekr.20230509052845.2345">@pure
@derives
@llvm
def class_raw(obj) -&gt; Ptr[byte]:
    ret ptr %obj

</t>
<t tx="ekr.20230509052845.2346">def class_alloc(T: type) -&gt; T:
    """Allocates a new reference (class) type"""
    sz = sizeof(tuple(T))
    p = alloc_atomic(sz) if T.__contents_atomic__ else alloc(sz)
    register_finalizer(p)
    return __internal__.to_class_ptr(p, T)

</t>
<t tx="ekr.20230509052845.2347">def class_new(T: type) -&gt; T:
    """Create a new reference (class) type"""
    pf = __internal__.class_alloc(T)
    __internal__.class_set_obj_vtable(pf)
    return pf

</t>
<t tx="ekr.20230509052845.2348">def class_ctr(T: type, *args, **kwargs) -&gt; T:
    """Shorthand for `t = T.__new__(); t.__init__(*args, **kwargs); t`"""
    return T(*args, **kwargs)

</t>
<t tx="ekr.20230509052845.2349">def class_set_obj_vtable(pf: T, T: type) -&gt; None:
    """
    Initialize a vtable of a T() object. Compiler generated.
    Corresponds to:
        pf.__vtable__ = __vtables__[pf.__vtable_id___]
    """
    pass

</t>
<t tx="ekr.20230509052845.235">class ReplaceableNodeBase : public AcceptorExtend&lt;Derived, Node&gt; {
private:
  /// true if the node can be lazily replaced
  bool replaceable = true;

public:
  using AcceptorExtend&lt;Derived, Node&gt;::AcceptorExtend;

  static const char NodeId;

  /// @return the logical value of the node
  Derived *getActual() {
    return Node::replacement ? static_cast&lt;Derived *&gt;(Node::replacement)-&gt;getActual()
                             : static_cast&lt;Derived *&gt;(this);
  }

@others
  /// @return true if the object can be replaced
  bool isReplaceable() const { return replaceable; }
  /// Sets the object's replaceable flag.
  /// @param v the new value
  void setReplaceable(bool v = true) { replaceable = v; }
};

</t>
<t tx="ekr.20230509052845.2350">def class_init_vtables() -&gt; Ptr[Ptr[cobj]]:
    """
    Create a global vtable. Compiler generated.
    Corresponds to:
        return __internal__.class_make_n_vtables(&lt;number of class realizations&gt;)
    """
    pass

</t>
<t tx="ekr.20230509052845.2351">def class_make_n_vtables(sz: int) -&gt; Ptr[Ptr[cobj]]:
    """Create a global vtable."""
    p = Ptr[Ptr[cobj]](alloc_atomic_uncollectable(sz * sizeof(Ptr[cobj])))
    __internal__.class_populate_vtables(p)
    return p

</t>
<t tx="ekr.20230509052845.2352">def class_populate_vtables(p: Ptr[Ptr[cobj]]) -&gt; None:
    """
    Populate content of vtables. Compiler generated.
    Corresponds to:
        for each realized class C:
            p.__setitem__(&lt;C's realization ID&gt;, Ptr[cobj](&lt;C's vtable size&gt; + 1))
            __internal__.class_set_typeinfo(p[&lt;C's realization ID&gt;], &lt;C's realization ID&gt;)
            for each fn F in C's vtable:
                p[&lt;C's realization ID&gt;].__setitem__(&lt;F's vtable ID&gt;, Function(&lt;instantiated F&gt;).__raw__())
    """
    pass

</t>
<t tx="ekr.20230509052845.2353">def class_set_typeinfo(p: Ptr[cobj], typeinfo: T, T: type) -&gt; None:
    i = Ptr[T](1)
    i[0] = typeinfo
    p[0] = i.as_byte()

</t>
<t tx="ekr.20230509052845.2354">def class_get_typeinfo(p) -&gt; int:
    c = Ptr[Ptr[cobj]](p.__raw__())
    vt = c[0]
    return Ptr[int](vt[0])[0]

</t>
<t tx="ekr.20230509052845.2355">@inline
def class_base_derived_dist(B: type, D: type) -&gt; int:
    """Calculates the byte distance of base class B and derived class D. Compiler generated."""
    return 0

</t>
<t tx="ekr.20230509052845.2356">def class_copy(obj: T, T: type) -&gt; T:
    p = __internal__.class_alloc(T)
    str.memcpy(p.__raw__(), obj.__raw__(), sizeof(tuple(T)))
    return p

</t>
<t tx="ekr.20230509052845.2357">def class_super(obj: D, B: type, D: type) -&gt; B:
    pf = __internal__.to_class_ptr(obj.__raw__() + __internal__.class_base_derived_dist(B, D), B)
    pn = __internal__.class_copy(pf)
    # Replace vtables
    __internal__.class_set_obj_vtable(pn)  # replace vtables to point to its vtables!
    return pn

</t>
<t tx="ekr.20230509052845.2358"># Unions

</t>
<t tx="ekr.20230509052845.2359">@llvm
def union_set_tag(tag: byte, U: type) -&gt; U:
    %0 = insertvalue {=U} undef, i8 %tag, 0
    ret {=U} %0

</t>
<t tx="ekr.20230509052845.236">  /// @return the logical value of the node
  const Derived *getActual() const {
    return Node::replacement
               ? static_cast&lt;const Derived *&gt;(Node::replacement)-&gt;getActual()
               : static_cast&lt;const Derived *&gt;(this);
  }

</t>
<t tx="ekr.20230509052845.2360">@llvm
def union_get_data_ptr(ptr: Ptr[U], U: type, T: type) -&gt; Ptr[T]:
    %0 = getelementptr inbounds {=U}, ptr %ptr, i64 0, i32 1
    ret ptr %0

</t>
<t tx="ekr.20230509052845.2361">@llvm
def union_get_tag(u: U, U: type) -&gt; byte:
    %0 = extractvalue {=U} %u, 0
    ret i8 %0

</t>
<t tx="ekr.20230509052845.2362">def union_get_data(u, T: type) -&gt; T:
    return __internal__.union_get_data_ptr(__ptr__(u), T=T)[0]

</t>
<t tx="ekr.20230509052845.2363">def union_make(tag: int, value, U: type) -&gt; U:
    u = __internal__.union_set_tag(byte(tag), U)
    __internal__.union_get_data_ptr(__ptr__(u), T=type(value))[0] = value
    return u

</t>
<t tx="ekr.20230509052845.2364">def new_union(value, U: type) -&gt; U:
    pass

</t>
<t tx="ekr.20230509052845.2365">def get_union(union, T: type) -&gt; T:
    pass

</t>
<t tx="ekr.20230509052845.2366">def get_union_first(union):
    pass

</t>
<t tx="ekr.20230509052845.2367">def _get_union_method(union, method: Static[str], *args, **kwargs):
    pass

</t>
<t tx="ekr.20230509052845.2368">def get_union_method(union, method: Static[str], *args, **kwargs):
    t = __internal__._get_union_method(union, method, *args, **kwargs)
    if staticlen(t) == 1:
        return __internal__.get_union_first(t)
    return t

</t>
<t tx="ekr.20230509052845.2369"># Tuples

</t>
<t tx="ekr.20230509052845.237">  /// Lazily replaces all instances of the node.
  /// @param v the new value
  void replaceAll(Derived *v) {
    seqassertn(replaceable, "node {} not replaceable", *v);
    Node::replacement = v;
  }

</t>
<t tx="ekr.20230509052845.2370">@pure
@derives
@llvm
def _tuple_getitem_llvm(t: T, idx: int, T: type, E: type) -&gt; E:
    %x = alloca {=T}
    store {=T} %t, ptr %x
    %p = getelementptr {=E}, ptr %x, i64 %idx
    %v = load {=E}, ptr %p
    ret {=E} %v

</t>
<t tx="ekr.20230509052845.2371">def tuple_fix_index(idx: int, len: int) -&gt; int:
    if idx &lt; 0:
        idx += len
    if idx &lt; 0 or idx &gt;= len:
        raise IndexError(f"tuple index {idx} out of range 0..{len}")
    return idx

</t>
<t tx="ekr.20230509052845.2372">def tuple_getitem(t: T, idx: int, T: type, E: type) -&gt; E:
    return __internal__._tuple_getitem_llvm(
        t, __internal__.tuple_fix_index(idx, staticlen(t)), T, E
    )

</t>
<t tx="ekr.20230509052845.2373">def tuple_add(t, i):
    if isinstance(i, Tuple):
        return (*t, *i)
    else:
        compile_error("can only concatenate tuple to tuple")

</t>
<t tx="ekr.20230509052845.2374">def tuple_mul(t, i: Static[int]):
    if i &lt; 1:
        return ()
    elif i == 1:
        return t
    else:
        return (*(__internal__.tuple_mul(t, i - 1)), *t)

</t>
<t tx="ekr.20230509052845.2375"># ...

</t>
<t tx="ekr.20230509052845.2376">@pure
@derives
@llvm
def fn_new(p: Ptr[byte], T: type) -&gt; T:
    ret ptr %p

</t>
<t tx="ekr.20230509052845.2377">@pure
@derives
@llvm
def fn_raw(fn: T, T: type) -&gt; Ptr[byte]:
    ret ptr %fn

</t>
<t tx="ekr.20230509052845.2378">@pure
@llvm
def int_sext(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
    %0 = sext i{=F} %what to i{=T}
    ret i{=T} %0

</t>
<t tx="ekr.20230509052845.2379">@pure
@llvm
def int_zext(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
    %0 = zext i{=F} %what to i{=T}
    ret i{=T} %0

</t>
<t tx="ekr.20230509052845.238">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/const.h"
#include "codon/cir/dsl/nodes.h"
#include "codon/cir/flow.h"
#include "codon/cir/func.h"
#include "codon/cir/instr.h"
#include "codon/cir/module.h"
#include "codon/cir/types/types.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2380">@pure
@llvm
def int_trunc(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
    %0 = trunc i{=F} %what to i{=T}
    ret i{=T} %0

</t>
<t tx="ekr.20230509052845.2381">def seq_assert(file: str, line: int, msg: str) -&gt; AssertionError:
    s = f": {msg}" if msg else ""
    s = f"Assert failed{s} ({file}:{line.__repr__()})"
    return AssertionError(s)

</t>
<t tx="ekr.20230509052845.2382">def seq_assert_test(file: str, line: int, msg: str):
    from C import seq_print(str)
    s = f": {msg}" if msg else ""
    s = f"\033[1;31mTEST FAILED:\033[0m {file} (line {line}){s}\n"
    seq_print(s)

</t>
<t tx="ekr.20230509052845.2383">def check_errno(prefix: str):
    @pure
    @C
    def seq_check_errno() -&gt; str:
        pass

    msg = seq_check_errno()
    if msg:
        raise OSError(prefix + msg)

</t>
<t tx="ekr.20230509052845.2384">@pure
@llvm
def opt_tuple_new(T: type) -&gt; Optional[T]:
    ret { i1, {=T} } { i1 false, {=T} undef }

</t>
<t tx="ekr.20230509052845.2385">@pure
@llvm
def opt_ref_new(T: type) -&gt; Optional[T]:
    ret ptr null

</t>
<t tx="ekr.20230509052845.2386">@pure
@derives
@llvm
def opt_tuple_new_arg(what: T, T: type) -&gt; Optional[T]:
    %0 = insertvalue { i1, {=T} } { i1 true, {=T} undef }, {=T} %what, 1
    ret { i1, {=T} } %0

</t>
<t tx="ekr.20230509052845.2387">@pure
@derives
@llvm
def opt_ref_new_arg(what: T, T: type) -&gt; Optional[T]:
    ret ptr %what

</t>
<t tx="ekr.20230509052845.2388">@pure
@llvm
def opt_tuple_bool(what: Optional[T], T: type) -&gt; bool:
    %0 = extractvalue { i1, {=T} } %what, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2389">@pure
@llvm
def opt_ref_bool(what: Optional[T], T: type) -&gt; bool:
    %0 = icmp ne ptr %what, null
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.239">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/module.h"
#include "codon/cir/value.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2390">@pure
@derives
@llvm
def opt_tuple_invert(what: Optional[T], T: type) -&gt; T:
    %0 = extractvalue { i1, {=T} } %what, 1
    ret {=T} %0

</t>
<t tx="ekr.20230509052845.2391">@pure
@derives
@llvm
def opt_ref_invert(what: Optional[T], T: type) -&gt; T:
    ret ptr %what

</t>
<t tx="ekr.20230509052845.2392">@pure
@derives
@llvm
def to_class_ptr(p: Ptr[byte], T: type) -&gt; T:
    ret ptr %p

</t>
<t tx="ekr.20230509052845.2393">def _tuple_offsetof(x, field: Static[int]) -&gt; int:
    @pure
    @llvm
    def _llvm_offsetof(T: type, idx: Static[int], TE: type) -&gt; int:
        %a = alloca {=T}
        %b = getelementptr inbounds {=T}, ptr %a, i64 0, i32 {=idx}
        %base = ptrtoint ptr %a to i64
        %elem = ptrtoint ptr %b to i64
        %offset = sub i64 %elem, %base
        ret i64 %offset

    return _llvm_offsetof(type(x), field, type(x[field]))

</t>
<t tx="ekr.20230509052845.2394">def raw_type_str(p: Ptr[byte], name: str) -&gt; str:
    pstr = p.__repr__()
    # '&lt;[name] at [pstr]&gt;'
    total = 1 + name.len + 4 + pstr.len + 1
    buf = Ptr[byte](total)
    where = 0
    buf[where] = byte(60)  # '&lt;'
    where += 1
    str.memcpy(buf + where, name.ptr, name.len)
    where += name.len
    buf[where] = byte(32)  # ' '
    where += 1
    buf[where] = byte(97)  # 'a'
    where += 1
    buf[where] = byte(116)  # 't'
    where += 1
    buf[where] = byte(32)  # ' '
    where += 1
    str.memcpy(buf + where, pstr.ptr, pstr.len)
    where += pstr.len
    buf[where] = byte(62)  # '&gt;'
    free(pstr.ptr)
    return str(buf, total)

</t>
<t tx="ekr.20230509052845.2395">def tuple_str(strs: Ptr[str], names: Ptr[str], n: int) -&gt; str:
    total = 2  # one for each of '(' and ')'
    i = 0
    while i &lt; n:
        total += strs[i].len
        if names[i].len:
            total += names[i].len + 2  # extra : and space
        if i &lt; n - 1:
            total += 2  # ", "
        i += 1
    buf = Ptr[byte](total)
    where = 0
    buf[where] = byte(40)  # '('
    where += 1
    i = 0
    while i &lt; n:
        s = names[i]
        l = s.len
        if l:
            str.memcpy(buf + where, s.ptr, l)
            where += l
            buf[where] = byte(58)  # ':'
            where += 1
            buf[where] = byte(32)  # ' '
            where += 1
        s = strs[i]
        l = s.len
        str.memcpy(buf + where, s.ptr, l)
        where += l
        if i &lt; n - 1:
            buf[where] = byte(44)  # ','
            where += 1
            buf[where] = byte(32)  # ' '
            where += 1
        i += 1
    buf[where] = byte(41)  # ')'
    return str(buf, total)

</t>
<t tx="ekr.20230509052845.2396">def undef(v, s):
    if not v:
        raise NameError(f"variable '{s}' not yet defined")

</t>
<t tx="ekr.20230509052845.2397">@__hidden__
def set_header(e, func, file, line, col):
    if not isinstance(e, BaseException):
        compile_error("exceptions must derive from BaseException")

    e.func = func
    e.file = file
    e.line = line
    e.col = col
    return e

</t>
<t tx="ekr.20230509052845.2398">@dataclass(init=True)
@tuple
class Import:
    name: str
    file: str

    def __repr__(self) -&gt; str:
        return f"&lt;module '{self.name}' from '{self.file}'&gt;"

</t>
<t tx="ekr.20230509052845.2399">@extend
class Function:
    @others
</t>
<t tx="ekr.20230509052845.24">def __add__(self, other):
    if not isinstance(other, GVector):
        raise ValueError("Can't add GVector to " + str(type(other)))
    v = GVector(self.x + other.x, self.y + other.y, self.z + other.z)
    return v

</t>
<t tx="ekr.20230509052845.240">/// CIR constant base. Once created, constants are immutable.
class Const : public AcceptorExtend&lt;Const, Value&gt; {
private:
  /// the type
  types::Type *type;

public:
  static const char NodeId;

  /// Constructs a constant.
  /// @param type the type
  /// @param name the name
  explicit Const(types::Type *type, std::string name = "")
      : AcceptorExtend(std::move(name)), type(type) {}

private:
  types::Type *doGetType() const override { return type; }

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {type}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509052845.2400">@pure
@llvm
def __new__(what: Ptr[byte]) -&gt; Function[T, TR]:
    ret ptr %what

</t>
<t tx="ekr.20230509052845.2401">def __new__(what: Function[T, TR]) -&gt; Function[T, TR]:
   return what

</t>
<t tx="ekr.20230509052845.2402">@pure
@llvm
def __raw__(self) -&gt; Ptr[byte]:
    ret ptr %self

</t>
<t tx="ekr.20230509052845.2403">def __repr__(self) -&gt; str:
   return __internal__.raw_type_str(self.__raw__(), "function")

</t>
<t tx="ekr.20230509052845.2404">@llvm
def __call_internal__(self: Function[T, TR], args: T) -&gt; TR:
    noop  # compiler will populate this one

</t>
<t tx="ekr.20230509052845.2405">def __call__(self, *args) -&gt; TR:
    return Function.__call_internal__(self, args)

</t>
<t tx="ekr.20230509052845.2406">__vtables__ = __internal__.class_init_vtables()
</t>
<t tx="ekr.20230509052845.2407">def _____(): __vtables__  # make it global!


</t>
<t tx="ekr.20230509052845.2408">@tuple
class PyObject:
    refcnt: int
    pytype: Ptr[byte]


</t>
<t tx="ekr.20230509052845.2409">@tuple
class PyWrapper[T]:
    head: PyObject
    data: T
</t>
<t tx="ekr.20230509052845.241">template &lt;typename ValueType&gt;
@others
</t>
<t tx="ekr.20230509052845.2410">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2411">def __ac_isempty(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 2

</t>
<t tx="ekr.20230509052845.2412">def __ac_isdel(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 1

</t>
<t tx="ekr.20230509052845.2413">def __ac_iseither(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 3

</t>
<t tx="ekr.20230509052845.2414">def __ac_set_isdel_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(1 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

</t>
<t tx="ekr.20230509052845.2415">def __ac_set_isempty_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(2 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

</t>
<t tx="ekr.20230509052845.2416">def __ac_set_isboth_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(3 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

</t>
<t tx="ekr.20230509052845.2417">def __ac_set_isdel_true(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] |= u32(1 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1))

</t>
<t tx="ekr.20230509052845.2418">def __ac_fsize(m) -&gt; int:
    return 1 if m &lt; 16 else m &gt;&gt; 4
</t>
<t tx="ekr.20230509052845.2419">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.242">class TemplatedConst : public AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt; {
private:
  ValueType val;

public:
  static const char NodeId;

  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getModule;
  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getSrcInfo;
  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getType;

  TemplatedConst(ValueType v, types::Type *type, std::string name = "")
      : AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;(type, std::move(name)),
        val(v) {}

  /// @return the internal value.
  ValueType getVal() const { return val; }
  /// Sets the value.
  /// @param v the value
  void setVal(ValueType v) { val = v; }
};

</t>
<t tx="ekr.20230509052845.2420">@pure
@llvm
def _floordiv_int_float(self: int, other: float) -&gt; float:
    declare double @llvm.floor.f64(double)
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    %2 = call double @llvm.floor.f64(double %1)
    ret double %2

</t>
<t tx="ekr.20230509052845.2421">@pure
@llvm
def _floordiv_int_int(self: int, other: int) -&gt; int:
    %0 = sdiv i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.2422">@pure
@llvm
def _truediv_int_float(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.2423">@pure
@llvm
def _truediv_int_int(self: int, other: int) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = sitofp i64 %other to double
    %2 = fdiv double %0, %1
    ret double %2

</t>
<t tx="ekr.20230509052845.2424">@pure
@llvm
def _mod_int_float(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = frem double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.2425">@pure
@llvm
def _mod_int_int(self: int, other: int) -&gt; int:
    %0 = srem i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.2426">@pure
@llvm
def _truediv_float_float(self: float, other: float) -&gt; float:
    %0 = fdiv double %self, %other
    ret double %0

</t>
<t tx="ekr.20230509052845.2427">@pure
@llvm
def _mod_float_float(self: float, other: float) -&gt; float:
    %0 = frem double %self, %other
    ret double %0

</t>
<t tx="ekr.20230509052845.2428">def _divmod_int_int(self: int, other: int):
    d = _floordiv_int_int(self, other)
    m = self - d * other
    if m and ((other ^ m) &lt; 0):
        m += other
        d -= 1
    return (d, m)

</t>
<t tx="ekr.20230509052845.2429">def _divmod_float_float(self: float, other: float):
    mod = _mod_float_float(self, other)
    div = _truediv_float_float(self - mod, other)
    if mod:
        if (other &lt; 0) != (mod &lt; 0):
            mod += other
            div -= 1.0
    else:
        mod = (0.0).copysign(other)

    floordiv = 0.0
    if div:
        floordiv = div.__floor__()
        if div - floordiv &gt; 0.5:
            floordiv += 1.0
    else:
        floordiv = (0.0).copysign(self / other)

    return (floordiv, mod)

</t>
<t tx="ekr.20230509052845.243">using IntConst = TemplatedConst&lt;int64_t&gt;;
using FloatConst = TemplatedConst&lt;double&gt;;
using BoolConst = TemplatedConst&lt;bool&gt;;
using StringConst = TemplatedConst&lt;std::string&gt;;

template &lt;typename T&gt; const char TemplatedConst&lt;T&gt;::NodeId = 0;

</t>
<t tx="ekr.20230509052845.2430">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.2431">def __floordiv__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float floor division by zero")
    return _divmod_float_float(float(self), other)[0]

</t>
<t tx="ekr.20230509052845.2432">def __floordiv__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("integer division or modulo by zero")
    return _divmod_int_int(self, other)[0]

</t>
<t tx="ekr.20230509052845.2433">def __truediv__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float division by zero")
    return _truediv_int_float(self, other)

</t>
<t tx="ekr.20230509052845.2434">def __truediv__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("division by zero")
    return _truediv_int_int(self, other)

</t>
<t tx="ekr.20230509052845.2435">def __mod__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float modulo")
    return _divmod_float_float(self, other)[1]

</t>
<t tx="ekr.20230509052845.2436">def __mod__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("integer division or modulo by zero")
    return _divmod_int_int(self, other)[1]

</t>
<t tx="ekr.20230509052845.2437">def __divmod__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float divmod()")
    return _divmod_float_float(float(self), other)

</t>
<t tx="ekr.20230509052845.2438">def __divmod__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("integer division or modulo by zero")
    return _divmod_int_int(self, other)

</t>
<t tx="ekr.20230509052845.2439">@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.244">template &lt;&gt;
@others
</t>
<t tx="ekr.20230509052845.2440">def __floordiv__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float floor division by zero")
    return _divmod_float_float(self, other)[0]

</t>
<t tx="ekr.20230509052845.2441">def __floordiv__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("float floor division by zero")
    return _divmod_float_float(self, float(other))[0]

</t>
<t tx="ekr.20230509052845.2442">def __truediv__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float division by zero")
    return _truediv_float_float(self, other)

</t>
<t tx="ekr.20230509052845.2443">def __truediv__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("float division by zero")
    return _truediv_float_float(self, float(other))

</t>
<t tx="ekr.20230509052845.2444">def __mod__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float modulo")
    return _divmod_float_float(self, other)[1]

</t>
<t tx="ekr.20230509052845.2445">def __mod__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("float modulo")
    return _divmod_float_float(self, float(other))[1]

</t>
<t tx="ekr.20230509052845.2446">def __divmod__(self, other: float):
    if other == 0.0:
        raise ZeroDivisionError("float divmod()")
    return _divmod_float_float(self, other)

</t>
<t tx="ekr.20230509052845.2447">def __divmod__(self, other: int):
    if other == 0:
        raise ZeroDivisionError("float divmod()")
    return _divmod_float_float(self, float(other))
</t>
<t tx="ekr.20230509052845.2448">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import os

from internal.dlopen import *

# general
Py_DecRef = Function[[cobj], NoneType](cobj())
Py_IncRef = Function[[cobj], NoneType](cobj())
Py_Initialize = Function[[], NoneType](cobj())
PyImport_AddModule = Function[[cobj], cobj](cobj())
PyImport_AddModuleObject = Function[[cobj], cobj](cobj())
PyImport_ImportModule = Function[[cobj], cobj](cobj())
PyRun_SimpleString = Function[[cobj], NoneType](cobj())
PyEval_GetGlobals = Function[[], cobj](cobj())
PyEval_GetBuiltins = Function[[], cobj](cobj())

# conversions
PyLong_AsLong = Function[[cobj], int](cobj())
PyLong_FromLong = Function[[int], cobj](cobj())
PyFloat_AsDouble = Function[[cobj], float](cobj())
PyFloat_FromDouble = Function[[float], cobj](cobj())
PyBool_FromLong = Function[[int], cobj](cobj())
PyBytes_AsString = Function[[cobj], cobj](cobj())
PyList_New = Function[[int], cobj](cobj())
PyList_Size = Function[[cobj], int](cobj())
PyList_GetItem = Function[[cobj, int], cobj](cobj())
PyList_SetItem = Function[[cobj, int, cobj], cobj](cobj())
PyDict_New = Function[[], cobj](cobj())
PyDict_Next = Function[[cobj, Ptr[int], Ptr[cobj], Ptr[cobj]], int](cobj())
PyDict_GetItem = Function[[cobj, cobj], cobj](cobj())
PyDict_GetItemString = Function[[cobj, cobj], cobj](cobj())
PyDict_SetItem = Function[[cobj, cobj, cobj], cobj](cobj())
PyDict_Size = Function[[cobj], int](cobj())
PySet_Add = Function[[cobj, cobj], cobj](cobj())
PySet_New = Function[[cobj], cobj](cobj())
PyTuple_New = Function[[int], cobj](cobj())
PyTuple_Size = Function[[cobj], int](cobj())
PyTuple_GetItem = Function[[cobj, int], cobj](cobj())
PyTuple_SetItem = Function[[cobj, int, cobj], NoneType](cobj())
PyUnicode_AsEncodedString = Function[[cobj, cobj, cobj], cobj](cobj())
PyUnicode_DecodeFSDefaultAndSize = Function[[cobj, int], cobj](cobj())
PyUnicode_FromString = Function[[cobj], cobj](cobj())
PyComplex_FromDoubles = Function[[float, float], cobj](cobj())
PyComplex_RealAsDouble = Function[[cobj], float](cobj())
PyComplex_ImagAsDouble = Function[[cobj], float](cobj())
PyIter_Next = Function[[cobj], cobj](cobj())
PySlice_New = Function[[cobj, cobj, cobj], cobj](cobj())
PySlice_Unpack = Function[[cobj, Ptr[int], Ptr[int], Ptr[int]], int](cobj())

# number
PyNumber_Add = Function[[cobj, cobj], cobj](cobj())
PyNumber_Subtract = Function[[cobj, cobj], cobj](cobj())
PyNumber_Multiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_MatrixMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_FloorDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_TrueDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_Remainder = Function[[cobj, cobj], cobj](cobj())
PyNumber_Divmod = Function[[cobj, cobj], cobj](cobj())
PyNumber_Power = Function[[cobj, cobj, cobj], cobj](cobj())
PyNumber_Negative = Function[[cobj], cobj](cobj())
PyNumber_Positive = Function[[cobj], cobj](cobj())
PyNumber_Absolute = Function[[cobj], cobj](cobj())
PyNumber_Invert = Function[[cobj], cobj](cobj())
PyNumber_Lshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_Rshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_And = Function[[cobj, cobj], cobj](cobj())
PyNumber_Xor = Function[[cobj, cobj], cobj](cobj())
PyNumber_Or = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceAdd = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceSubtract = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceMatrixMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceFloorDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceTrueDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceRemainder = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlacePower = Function[[cobj, cobj, cobj], cobj](cobj())
PyNumber_InPlaceLshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceRshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceAnd = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceXor = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceOr = Function[[cobj, cobj], cobj](cobj())
PyNumber_Long = Function[[cobj], cobj](cobj())
PyNumber_Float = Function[[cobj], cobj](cobj())
PyNumber_Index = Function[[cobj], cobj](cobj())

# object
PyObject_Call = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_GetAttr = Function[[cobj, cobj], cobj](cobj())
PyObject_GetAttrString = Function[[cobj, cobj], cobj](cobj())
PyObject_GetIter = Function[[cobj], cobj](cobj())
PyObject_HasAttrString = Function[[cobj, cobj], int](cobj())
PyObject_IsTrue = Function[[cobj], int](cobj())
PyObject_Length = Function[[cobj], int](cobj())
PyObject_LengthHint = Function[[cobj, int], int](cobj())
PyObject_SetAttrString = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_Str = Function[[cobj], cobj](cobj())
PyObject_Repr = Function[[cobj], cobj](cobj())
PyObject_Hash = Function[[cobj], int](cobj())
PyObject_GetItem = Function[[cobj, cobj], cobj](cobj())
PyObject_SetItem = Function[[cobj, cobj, cobj], int](cobj())
PyObject_DelItem = Function[[cobj, cobj], int](cobj())
PyObject_RichCompare = Function[[cobj, cobj, i32], cobj](cobj())
PyObject_IsInstance = Function[[cobj, cobj], i32](cobj())

# error handling
PyErr_Fetch = Function[[Ptr[cobj], Ptr[cobj], Ptr[cobj]], NoneType](cobj())
PyErr_NormalizeException = Function[[Ptr[cobj], Ptr[cobj], Ptr[cobj]], NoneType](cobj())
PyErr_SetString = Function[[cobj, cobj], NoneType](cobj())

# constants
Py_None = cobj()
Py_True = cobj()
Py_False = cobj()
Py_Ellipsis = cobj()
Py_NotImplemented = cobj()
Py_LT = 0
Py_LE = 1
Py_EQ = 2
Py_NE = 3
Py_GT = 4
Py_GE = 5

# types
PyLong_Type = cobj()
PyFloat_Type = cobj()
PyBool_Type = cobj()
PyUnicode_Type = cobj()
PyComplex_Type = cobj()
PyList_Type = cobj()
PyDict_Type = cobj()
PySet_Type = cobj()
PyTuple_Type = cobj()
PySlice_Type = cobj()

# exceptions
PyExc_BaseException = cobj()
PyExc_Exception = cobj()
PyExc_NameError = cobj()
PyExc_OSError = cobj()
PyExc_IOError = cobj()
PyExc_ValueError = cobj()
PyExc_LookupError = cobj()
PyExc_IndexError = cobj()
PyExc_KeyError = cobj()
PyExc_TypeError = cobj()
PyExc_ArithmeticError = cobj()
PyExc_ZeroDivisionError = cobj()
PyExc_OverflowError = cobj()
PyExc_AttributeError = cobj()
PyExc_RuntimeError = cobj()
PyExc_NotImplementedError = cobj()
PyExc_StopIteration = cobj()
PyExc_AssertionError = cobj()
PyExc_SystemExit = cobj()

_PY_MODULE_CACHE = Dict[str, pyobj]()

_PY_INIT = """
import io

clsf = None
clsa = None
plt = None
try:
    import matplotlib.figure
    import matplotlib.pyplot
    plt = matplotlib.pyplot
    clsf = matplotlib.figure.Figure
    clsa = matplotlib.artist.Artist
except ModuleNotFoundError:
    pass

def __codon_repr__(fig):
    if clsf and isinstance(fig, clsf):
        stream = io.StringIO()
        fig.savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif clsa and isinstance(fig, list) and all(
        isinstance(i, clsa) for i in fig
    ):
        stream = io.StringIO()
        plt.gcf().savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif hasattr(fig, "_repr_html_"):
        return 'text/html', fig._repr_html_()
    else:
        return 'text/plain', fig.__repr__()
"""

_PY_INITIALIZED = False

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2449">def init_handles_dlopen(py_handle: cobj):
    global Py_DecRef
    global Py_IncRef
    global Py_Initialize
    global PyImport_AddModule
    global PyImport_AddModuleObject
    global PyImport_ImportModule
    global PyRun_SimpleString
    global PyEval_GetGlobals
    global PyEval_GetBuiltins
    global PyLong_AsLong
    global PyLong_FromLong
    global PyFloat_AsDouble
    global PyFloat_FromDouble
    global PyBool_FromLong
    global PyBytes_AsString
    global PyList_New
    global PyList_Size
    global PyList_GetItem
    global PyList_SetItem
    global PyDict_New
    global PyDict_Next
    global PyDict_GetItem
    global PyDict_GetItemString
    global PyDict_SetItem
    global PyDict_Size
    global PySet_Add
    global PySet_New
    global PyTuple_New
    global PyTuple_Size
    global PyTuple_GetItem
    global PyTuple_SetItem
    global PyUnicode_AsEncodedString
    global PyUnicode_DecodeFSDefaultAndSize
    global PyUnicode_FromString
    global PyComplex_FromDoubles
    global PyComplex_RealAsDouble
    global PyComplex_ImagAsDouble
    global PyIter_Next
    global PySlice_New
    global PySlice_Unpack
    global PyNumber_Add
    global PyNumber_Subtract
    global PyNumber_Multiply
    global PyNumber_MatrixMultiply
    global PyNumber_FloorDivide
    global PyNumber_TrueDivide
    global PyNumber_Remainder
    global PyNumber_Divmod
    global PyNumber_Power
    global PyNumber_Negative
    global PyNumber_Positive
    global PyNumber_Absolute
    global PyNumber_Invert
    global PyNumber_Lshift
    global PyNumber_Rshift
    global PyNumber_And
    global PyNumber_Xor
    global PyNumber_Or
    global PyNumber_InPlaceAdd
    global PyNumber_InPlaceSubtract
    global PyNumber_InPlaceMultiply
    global PyNumber_InPlaceMatrixMultiply
    global PyNumber_InPlaceFloorDivide
    global PyNumber_InPlaceTrueDivide
    global PyNumber_InPlaceRemainder
    global PyNumber_InPlacePower
    global PyNumber_InPlaceLshift
    global PyNumber_InPlaceRshift
    global PyNumber_InPlaceAnd
    global PyNumber_InPlaceXor
    global PyNumber_InPlaceOr
    global PyNumber_Long
    global PyNumber_Float
    global PyNumber_Index
    global PyObject_Call
    global PyObject_GetAttr
    global PyObject_GetAttrString
    global PyObject_GetIter
    global PyObject_HasAttrString
    global PyObject_IsTrue
    global PyObject_Length
    global PyObject_LengthHint
    global PyObject_SetAttrString
    global PyObject_Str
    global PyObject_Repr
    global PyObject_Hash
    global PyObject_GetItem
    global PyObject_SetItem
    global PyObject_DelItem
    global PyObject_RichCompare
    global PyObject_IsInstance
    global PyErr_Fetch
    global PyErr_NormalizeException
    global PyErr_SetString
    global Py_None
    global Py_True
    global Py_False
    global Py_Ellipsis
    global Py_NotImplemented
    global PyLong_Type
    global PyFloat_Type
    global PyBool_Type
    global PyUnicode_Type
    global PyComplex_Type
    global PyList_Type
    global PyDict_Type
    global PySet_Type
    global PyTuple_Type
    global PySlice_Type
    global PyExc_BaseException
    global PyExc_Exception
    global PyExc_NameError
    global PyExc_OSError
    global PyExc_IOError
    global PyExc_ValueError
    global PyExc_LookupError
    global PyExc_IndexError
    global PyExc_KeyError
    global PyExc_TypeError
    global PyExc_ArithmeticError
    global PyExc_ZeroDivisionError
    global PyExc_OverflowError
    global PyExc_AttributeError
    global PyExc_RuntimeError
    global PyExc_NotImplementedError
    global PyExc_StopIteration
    global PyExc_AssertionError
    global PyExc_SystemExit

    Py_DecRef = dlsym(py_handle, "Py_DecRef")
    Py_IncRef = dlsym(py_handle, "Py_IncRef")
    Py_Initialize = dlsym(py_handle, "Py_Initialize")
    PyImport_AddModule = dlsym(py_handle, "PyImport_AddModule")
    PyImport_AddModuleObject = dlsym(py_handle, "PyImport_AddModuleObject")
    PyImport_ImportModule = dlsym(py_handle, "PyImport_ImportModule")
    PyRun_SimpleString = dlsym(py_handle, "PyRun_SimpleString")
    PyEval_GetGlobals = dlsym(py_handle, "PyEval_GetGlobals")
    PyEval_GetBuiltins = dlsym(py_handle, "PyEval_GetBuiltins")
    PyLong_AsLong = dlsym(py_handle, "PyLong_AsLong")
    PyLong_FromLong = dlsym(py_handle, "PyLong_FromLong")
    PyFloat_AsDouble = dlsym(py_handle, "PyFloat_AsDouble")
    PyFloat_FromDouble = dlsym(py_handle, "PyFloat_FromDouble")
    PyBool_FromLong = dlsym(py_handle, "PyBool_FromLong")
    PyBytes_AsString = dlsym(py_handle, "PyBytes_AsString")
    PyList_New = dlsym(py_handle, "PyList_New")
    PyList_Size = dlsym(py_handle, "PyList_Size")
    PyList_GetItem = dlsym(py_handle, "PyList_GetItem")
    PyList_SetItem = dlsym(py_handle, "PyList_SetItem")
    PyDict_New = dlsym(py_handle, "PyDict_New")
    PyDict_Next = dlsym(py_handle, "PyDict_Next")
    PyDict_GetItem = dlsym(py_handle, "PyDict_GetItem")
    PyDict_GetItemString = dlsym(py_handle, "PyDict_GetItemString")
    PyDict_SetItem = dlsym(py_handle, "PyDict_SetItem")
    PyDict_Size = dlsym(py_handle, "PyDict_Size")
    PySet_Add = dlsym(py_handle, "PySet_Add")
    PySet_New = dlsym(py_handle, "PySet_New")
    PyTuple_New = dlsym(py_handle, "PyTuple_New")
    PyTuple_Size = dlsym(py_handle, "PyTuple_Size")
    PyTuple_GetItem = dlsym(py_handle, "PyTuple_GetItem")
    PyTuple_SetItem = dlsym(py_handle, "PyTuple_SetItem")
    PyUnicode_AsEncodedString = dlsym(py_handle, "PyUnicode_AsEncodedString")
    PyUnicode_DecodeFSDefaultAndSize = dlsym(py_handle, "PyUnicode_DecodeFSDefaultAndSize")
    PyUnicode_FromString = dlsym(py_handle, "PyUnicode_FromString")
    PyComplex_FromDoubles = dlsym(py_handle, "PyComplex_FromDoubles")
    PyComplex_RealAsDouble = dlsym(py_handle, "PyComplex_RealAsDouble")
    PyComplex_ImagAsDouble = dlsym(py_handle, "PyComplex_ImagAsDouble")
    PyIter_Next = dlsym(py_handle, "PyIter_Next")
    PySlice_New = dlsym(py_handle, "PySlice_New")
    PySlice_Unpack = dlsym(py_handle, "PySlice_Unpack")
    PyNumber_Add = dlsym(py_handle, "PyNumber_Add")
    PyNumber_Subtract = dlsym(py_handle, "PyNumber_Subtract")
    PyNumber_Multiply = dlsym(py_handle, "PyNumber_Multiply")
    PyNumber_MatrixMultiply = dlsym(py_handle, "PyNumber_MatrixMultiply")
    PyNumber_FloorDivide = dlsym(py_handle, "PyNumber_FloorDivide")
    PyNumber_TrueDivide = dlsym(py_handle, "PyNumber_TrueDivide")
    PyNumber_Remainder = dlsym(py_handle, "PyNumber_Remainder")
    PyNumber_Divmod = dlsym(py_handle, "PyNumber_Divmod")
    PyNumber_Power = dlsym(py_handle, "PyNumber_Power")
    PyNumber_Negative = dlsym(py_handle, "PyNumber_Negative")
    PyNumber_Positive = dlsym(py_handle, "PyNumber_Positive")
    PyNumber_Absolute = dlsym(py_handle, "PyNumber_Absolute")
    PyNumber_Invert = dlsym(py_handle, "PyNumber_Invert")
    PyNumber_Lshift = dlsym(py_handle, "PyNumber_Lshift")
    PyNumber_Rshift = dlsym(py_handle, "PyNumber_Rshift")
    PyNumber_And = dlsym(py_handle, "PyNumber_And")
    PyNumber_Xor = dlsym(py_handle, "PyNumber_Xor")
    PyNumber_Or = dlsym(py_handle, "PyNumber_Or")
    PyNumber_InPlaceAdd = dlsym(py_handle, "PyNumber_InPlaceAdd")
    PyNumber_InPlaceSubtract = dlsym(py_handle, "PyNumber_InPlaceSubtract")
    PyNumber_InPlaceMultiply = dlsym(py_handle, "PyNumber_InPlaceMultiply")
    PyNumber_InPlaceMatrixMultiply = dlsym(py_handle, "PyNumber_InPlaceMatrixMultiply")
    PyNumber_InPlaceFloorDivide = dlsym(py_handle, "PyNumber_InPlaceFloorDivide")
    PyNumber_InPlaceTrueDivide = dlsym(py_handle, "PyNumber_InPlaceTrueDivide")
    PyNumber_InPlaceRemainder = dlsym(py_handle, "PyNumber_InPlaceRemainder")
    PyNumber_InPlacePower = dlsym(py_handle, "PyNumber_InPlacePower")
    PyNumber_InPlaceLshift = dlsym(py_handle, "PyNumber_InPlaceLshift")
    PyNumber_InPlaceRshift = dlsym(py_handle, "PyNumber_InPlaceRshift")
    PyNumber_InPlaceAnd = dlsym(py_handle, "PyNumber_InPlaceAnd")
    PyNumber_InPlaceXor = dlsym(py_handle, "PyNumber_InPlaceXor")
    PyNumber_InPlaceOr = dlsym(py_handle, "PyNumber_InPlaceOr")
    PyNumber_Long = dlsym(py_handle, "PyNumber_Long")
    PyNumber_Float = dlsym(py_handle, "PyNumber_Float")
    PyNumber_Index = dlsym(py_handle, "PyNumber_Index")
    PyObject_Call = dlsym(py_handle, "PyObject_Call")
    PyObject_GetAttr = dlsym(py_handle, "PyObject_GetAttr")
    PyObject_GetAttrString = dlsym(py_handle, "PyObject_GetAttrString")
    PyObject_GetIter = dlsym(py_handle, "PyObject_GetIter")
    PyObject_HasAttrString = dlsym(py_handle, "PyObject_HasAttrString")
    PyObject_IsTrue = dlsym(py_handle, "PyObject_IsTrue")
    PyObject_Length = dlsym(py_handle, "PyObject_Length")
    PyObject_LengthHint = dlsym(py_handle, "PyObject_LengthHint")
    PyObject_SetAttrString = dlsym(py_handle, "PyObject_SetAttrString")
    PyObject_Str = dlsym(py_handle, "PyObject_Str")
    PyObject_Repr = dlsym(py_handle, "PyObject_Repr")
    PyObject_Hash = dlsym(py_handle, "PyObject_Hash")
    PyObject_GetItem = dlsym(py_handle, "PyObject_GetItem")
    PyObject_SetItem = dlsym(py_handle, "PyObject_SetItem")
    PyObject_DelItem = dlsym(py_handle, "PyObject_DelItem")
    PyObject_RichCompare = dlsym(py_handle, "PyObject_RichCompare")
    PyObject_IsInstance = dlsym(py_handle, "PyObject_IsInstance")
    PyErr_Fetch = dlsym(py_handle, "PyErr_Fetch")
    PyErr_NormalizeException = dlsym(py_handle, "PyErr_NormalizeException")
    PyErr_SetString = dlsym(py_handle, "PyErr_SetString")
    Py_None = dlsym(py_handle, "_Py_NoneStruct")
    Py_True = dlsym(py_handle, "_Py_TrueStruct")
    Py_False = dlsym(py_handle, "_Py_FalseStruct")
    Py_Ellipsis = dlsym(py_handle, "_Py_EllipsisObject")
    Py_NotImplemented = dlsym(py_handle, "_Py_NotImplementedStruct")
    PyLong_Type = dlsym(py_handle, "PyLong_Type")
    PyFloat_Type = dlsym(py_handle, "PyFloat_Type")
    PyBool_Type = dlsym(py_handle, "PyBool_Type")
    PyUnicode_Type = dlsym(py_handle, "PyUnicode_Type")
    PyComplex_Type = dlsym(py_handle, "PyComplex_Type")
    PyList_Type = dlsym(py_handle, "PyList_Type")
    PyDict_Type = dlsym(py_handle, "PyDict_Type")
    PySet_Type = dlsym(py_handle, "PySet_Type")
    PyTuple_Type = dlsym(py_handle, "PyTuple_Type")
    PySlice_Type = dlsym(py_handle, "PySlice_Type")
    PyExc_BaseException = Ptr[cobj](dlsym(py_handle, "PyExc_BaseException"))[0]
    PyExc_Exception = Ptr[cobj](dlsym(py_handle, "PyExc_Exception"))[0]
    PyExc_NameError = Ptr[cobj](dlsym(py_handle, "PyExc_NameError"))[0]
    PyExc_OSError = Ptr[cobj](dlsym(py_handle, "PyExc_OSError"))[0]
    PyExc_IOError = Ptr[cobj](dlsym(py_handle, "PyExc_IOError"))[0]
    PyExc_ValueError = Ptr[cobj](dlsym(py_handle, "PyExc_ValueError"))[0]
    PyExc_LookupError = Ptr[cobj](dlsym(py_handle, "PyExc_LookupError"))[0]
    PyExc_IndexError = Ptr[cobj](dlsym(py_handle, "PyExc_IndexError"))[0]
    PyExc_KeyError = Ptr[cobj](dlsym(py_handle, "PyExc_KeyError"))[0]
    PyExc_TypeError = Ptr[cobj](dlsym(py_handle, "PyExc_TypeError"))[0]
    PyExc_ArithmeticError = Ptr[cobj](dlsym(py_handle, "PyExc_ArithmeticError"))[0]
    PyExc_ZeroDivisionError = Ptr[cobj](dlsym(py_handle, "PyExc_ZeroDivisionError"))[0]
    PyExc_OverflowError = Ptr[cobj](dlsym(py_handle, "PyExc_OverflowError"))[0]
    PyExc_AttributeError = Ptr[cobj](dlsym(py_handle, "PyExc_AttributeError"))[0]
    PyExc_RuntimeError = Ptr[cobj](dlsym(py_handle, "PyExc_RuntimeError"))[0]
    PyExc_NotImplementedError = Ptr[cobj](dlsym(py_handle, "PyExc_NotImplementedError"))[0]
    PyExc_StopIteration = Ptr[cobj](dlsym(py_handle, "PyExc_StopIteration"))[0]
    PyExc_AssertionError = Ptr[cobj](dlsym(py_handle, "PyExc_AssertionError"))[0]
    PyExc_SystemExit = Ptr[cobj](dlsym(py_handle, "PyExc_SystemExit"))[0]

</t>
<t tx="ekr.20230509052845.245">class TemplatedConst&lt;std::string&gt;
    : public AcceptorExtend&lt;TemplatedConst&lt;std::string&gt;, Const&gt; {
private:
  std::string val;

public:
  static const char NodeId;

  TemplatedConst(std::string v, types::Type *type, std::string name = "")
      : AcceptorExtend(type, std::move(name)), val(std::move(v)) {}

  /// @return the internal value.
  std::string getVal() const { return val; }
  /// Sets the value.
  /// @param v the value
  void setVal(std::string v) { val = std::move(v); }
};

</t>
<t tx="ekr.20230509052845.2450">def init_handles_static():
    from C import Py_DecRef(cobj) as _Py_DecRef
    from C import Py_IncRef(cobj) as _Py_IncRef
    from C import Py_Initialize() as _Py_Initialize
    from C import PyImport_AddModule(cobj) -&gt; cobj as _PyImport_AddModule
    from C import PyImport_AddModuleObject(cobj) -&gt; cobj as _PyImport_AddModuleObject
    from C import PyImport_ImportModule(cobj) -&gt; cobj as _PyImport_ImportModule
    from C import PyRun_SimpleString(cobj) as _PyRun_SimpleString
    from C import PyEval_GetGlobals() -&gt; cobj as _PyEval_GetGlobals
    from C import PyEval_GetBuiltins() -&gt; cobj as _PyEval_GetBuiltins
    from C import PyLong_AsLong(cobj) -&gt; int as _PyLong_AsLong
    from C import PyLong_FromLong(int) -&gt; cobj as _PyLong_FromLong
    from C import PyFloat_AsDouble(cobj) -&gt; float as _PyFloat_AsDouble
    from C import PyFloat_FromDouble(float) -&gt; cobj as _PyFloat_FromDouble
    from C import PyBool_FromLong(int) -&gt; cobj as _PyBool_FromLong
    from C import PyBytes_AsString(cobj) -&gt; cobj as _PyBytes_AsString
    from C import PyList_New(int) -&gt; cobj as _PyList_New
    from C import PyList_Size(cobj) -&gt; int as _PyList_Size
    from C import PyList_GetItem(cobj, int) -&gt; cobj as _PyList_GetItem
    from C import PyList_SetItem(cobj, int, cobj) -&gt; cobj as _PyList_SetItem
    from C import PyDict_New() -&gt; cobj as _PyDict_New
    from C import PyDict_Next(cobj, Ptr[int], Ptr[cobj], Ptr[cobj]) -&gt; int as _PyDict_Next
    from C import PyDict_GetItem(cobj, cobj) -&gt; cobj as _PyDict_GetItem
    from C import PyDict_GetItemString(cobj, cobj) -&gt; cobj as _PyDict_GetItemString
    from C import PyDict_SetItem(cobj, cobj, cobj) -&gt; cobj as _PyDict_SetItem
    from C import PyDict_Size(cobj) -&gt; int as _PyDict_Size
    from C import PySet_Add(cobj, cobj) -&gt; cobj as _PySet_Add
    from C import PySet_New(cobj) -&gt; cobj as _PySet_New
    from C import PyTuple_New(int) -&gt; cobj as _PyTuple_New
    from C import PyTuple_Size(cobj) -&gt; int as _PyTuple_Size
    from C import PyTuple_GetItem(cobj, int) -&gt; cobj as _PyTuple_GetItem
    from C import PyTuple_SetItem(cobj, int, cobj) as _PyTuple_SetItem
    from C import PyUnicode_AsEncodedString(cobj, cobj, cobj) -&gt; cobj as _PyUnicode_AsEncodedString
    from C import PyUnicode_DecodeFSDefaultAndSize(cobj, int) -&gt; cobj as _PyUnicode_DecodeFSDefaultAndSize
    from C import PyUnicode_FromString(cobj) -&gt; cobj as _PyUnicode_FromString
    from C import PyComplex_FromDoubles(float, float) -&gt; cobj as _PyComplex_FromDoubles
    from C import PyComplex_RealAsDouble(cobj) -&gt; float as _PyComplex_RealAsDouble
    from C import PyComplex_ImagAsDouble(cobj) -&gt; float as _PyComplex_ImagAsDouble
    from C import PyIter_Next(cobj) -&gt; cobj as _PyIter_Next
    from C import PySlice_New(cobj, cobj, cobj) -&gt; cobj as _PySlice_New
    from C import PySlice_Unpack(cobj, Ptr[int], Ptr[int], Ptr[int]) -&gt; int as _PySlice_Unpack
    from C import PyNumber_Add(cobj, cobj) -&gt; cobj as _PyNumber_Add
    from C import PyNumber_Subtract(cobj, cobj) -&gt; cobj as _PyNumber_Subtract
    from C import PyNumber_Multiply(cobj, cobj) -&gt; cobj as _PyNumber_Multiply
    from C import PyNumber_MatrixMultiply(cobj, cobj) -&gt; cobj as _PyNumber_MatrixMultiply
    from C import PyNumber_FloorDivide(cobj, cobj) -&gt; cobj as _PyNumber_FloorDivide
    from C import PyNumber_TrueDivide(cobj, cobj) -&gt; cobj as _PyNumber_TrueDivide
    from C import PyNumber_Remainder(cobj, cobj) -&gt; cobj as _PyNumber_Remainder
    from C import PyNumber_Divmod(cobj, cobj) -&gt; cobj as _PyNumber_Divmod
    from C import PyNumber_Power(cobj, cobj, cobj) -&gt; cobj as _PyNumber_Power
    from C import PyNumber_Negative(cobj) -&gt; cobj as _PyNumber_Negative
    from C import PyNumber_Positive(cobj) -&gt; cobj as _PyNumber_Positive
    from C import PyNumber_Absolute(cobj) -&gt; cobj as _PyNumber_Absolute
    from C import PyNumber_Invert(cobj) -&gt; cobj as _PyNumber_Invert
    from C import PyNumber_Lshift(cobj, cobj) -&gt; cobj as _PyNumber_Lshift
    from C import PyNumber_Rshift(cobj, cobj) -&gt; cobj as _PyNumber_Rshift
    from C import PyNumber_And(cobj, cobj) -&gt; cobj as _PyNumber_And
    from C import PyNumber_Xor(cobj, cobj) -&gt; cobj as _PyNumber_Xor
    from C import PyNumber_Or(cobj, cobj) -&gt; cobj as _PyNumber_Or
    from C import PyNumber_InPlaceAdd(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceAdd
    from C import PyNumber_InPlaceSubtract(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceSubtract
    from C import PyNumber_InPlaceMultiply(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceMultiply
    from C import PyNumber_InPlaceMatrixMultiply(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceMatrixMultiply
    from C import PyNumber_InPlaceFloorDivide(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceFloorDivide
    from C import PyNumber_InPlaceTrueDivide(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceTrueDivide
    from C import PyNumber_InPlaceRemainder(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceRemainder
    from C import PyNumber_InPlacePower(cobj, cobj, cobj) -&gt; cobj as _PyNumber_InPlacePower
    from C import PyNumber_InPlaceLshift(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceLshift
    from C import PyNumber_InPlaceRshift(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceRshift
    from C import PyNumber_InPlaceAnd(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceAnd
    from C import PyNumber_InPlaceXor(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceXor
    from C import PyNumber_InPlaceOr(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceOr
    from C import PyNumber_Long(cobj) -&gt; cobj as _PyNumber_Long
    from C import PyNumber_Float(cobj) -&gt; cobj as _PyNumber_Float
    from C import PyNumber_Index(cobj) -&gt; cobj as _PyNumber_Index
    from C import PyObject_Call(cobj, cobj, cobj) -&gt; cobj as _PyObject_Call
    from C import PyObject_GetAttr(cobj, cobj) -&gt; cobj as _PyObject_GetAttr
    from C import PyObject_GetAttrString(cobj, cobj) -&gt; cobj as _PyObject_GetAttrString
    from C import PyObject_GetIter(cobj) -&gt; cobj as _PyObject_GetIter
    from C import PyObject_HasAttrString(cobj, cobj) -&gt; int as _PyObject_HasAttrString
    from C import PyObject_IsTrue(cobj) -&gt; int as _PyObject_IsTrue
    from C import PyObject_Length(cobj) -&gt; int as _PyObject_Length
    from C import PyObject_LengthHint(cobj, int) -&gt; int as _PyObject_LengthHint
    from C import PyObject_SetAttrString(cobj, cobj, cobj) -&gt; cobj as _PyObject_SetAttrString
    from C import PyObject_Str(cobj) -&gt; cobj as _PyObject_Str
    from C import PyObject_Repr(cobj) -&gt; cobj as _PyObject_Repr
    from C import PyObject_Hash(cobj) -&gt; int as _PyObject_Hash
    from C import PyObject_GetItem(cobj, cobj) -&gt; cobj as _PyObject_GetItem
    from C import PyObject_SetItem(cobj, cobj, cobj) -&gt; int as _PyObject_SetItem
    from C import PyObject_DelItem(cobj, cobj) -&gt; int as _PyObject_DelItem
    from C import PyObject_RichCompare(cobj, cobj, i32) -&gt; cobj as _PyObject_RichCompare
    from C import PyObject_IsInstance(cobj, cobj) -&gt; i32 as _PyObject_IsInstance
    from C import PyErr_Fetch(Ptr[cobj], Ptr[cobj], Ptr[cobj]) as _PyErr_Fetch
    from C import PyErr_NormalizeException(Ptr[cobj], Ptr[cobj], Ptr[cobj]) as _PyErr_NormalizeException
    from C import PyErr_SetString(cobj, cobj) as _PyErr_SetString
    from C import _Py_NoneStruct: cobj
    from C import _Py_TrueStruct: cobj
    from C import _Py_FalseStruct: cobj
    from C import _Py_EllipsisObject: cobj
    from C import _Py_NotImplementedStruct: cobj
    from C import PyLong_Type: cobj as _PyLong_Type
    from C import PyFloat_Type: cobj as _PyFloat_Type
    from C import PyBool_Type: cobj as _PyBool_Type
    from C import PyUnicode_Type: cobj as _PyUnicode_Type
    from C import PyComplex_Type: cobj as _PyComplex_Type
    from C import PyList_Type: cobj as _PyList_Type
    from C import PyDict_Type: cobj as _PyDict_Type
    from C import PySet_Type: cobj as _PySet_Type
    from C import PyTuple_Type: cobj as _PyTuple_Type
    from C import PySlice_Type: cobj as _PySlice_Type
    from C import PyExc_BaseException: cobj as _PyExc_BaseException
    from C import PyExc_Exception: cobj as _PyExc_Exception
    from C import PyExc_NameError: cobj as _PyExc_NameError
    from C import PyExc_OSError: cobj as _PyExc_OSError
    from C import PyExc_IOError: cobj as _PyExc_IOError
    from C import PyExc_ValueError: cobj as _PyExc_ValueError
    from C import PyExc_LookupError: cobj as _PyExc_LookupError
    from C import PyExc_IndexError: cobj as _PyExc_IndexError
    from C import PyExc_KeyError: cobj as _PyExc_KeyError
    from C import PyExc_TypeError: cobj as _PyExc_TypeError
    from C import PyExc_ArithmeticError: cobj as _PyExc_ArithmeticError
    from C import PyExc_ZeroDivisionError: cobj as _PyExc_ZeroDivisionError
    from C import PyExc_OverflowError: cobj as _PyExc_OverflowError
    from C import PyExc_AttributeError: cobj as _PyExc_AttributeError
    from C import PyExc_RuntimeError: cobj as _PyExc_RuntimeError
    from C import PyExc_NotImplementedError: cobj as _PyExc_NotImplementedError
    from C import PyExc_StopIteration: cobj as _PyExc_StopIteration
    from C import PyExc_AssertionError: cobj as _PyExc_AssertionError
    from C import PyExc_SystemExit: cobj as _PyExc_SystemExit

    global Py_DecRef
    global Py_IncRef
    global Py_Initialize
    global PyImport_AddModule
    global PyImport_AddModuleObject
    global PyImport_ImportModule
    global PyRun_SimpleString
    global PyEval_GetGlobals
    global PyEval_GetBuiltins
    global PyLong_AsLong
    global PyLong_FromLong
    global PyFloat_AsDouble
    global PyFloat_FromDouble
    global PyBool_FromLong
    global PyBytes_AsString
    global PyList_New
    global PyList_Size
    global PyList_GetItem
    global PyList_SetItem
    global PyDict_New
    global PyDict_Next
    global PyDict_GetItem
    global PyDict_GetItemString
    global PyDict_SetItem
    global PyDict_Size
    global PySet_Add
    global PySet_New
    global PyTuple_New
    global PyTuple_Size
    global PyTuple_GetItem
    global PyTuple_SetItem
    global PyUnicode_AsEncodedString
    global PyUnicode_DecodeFSDefaultAndSize
    global PyUnicode_FromString
    global PyComplex_FromDoubles
    global PyComplex_RealAsDouble
    global PyComplex_ImagAsDouble
    global PyIter_Next
    global PySlice_New
    global PySlice_Unpack
    global PyNumber_Add
    global PyNumber_Subtract
    global PyNumber_Multiply
    global PyNumber_MatrixMultiply
    global PyNumber_FloorDivide
    global PyNumber_TrueDivide
    global PyNumber_Remainder
    global PyNumber_Divmod
    global PyNumber_Power
    global PyNumber_Negative
    global PyNumber_Positive
    global PyNumber_Absolute
    global PyNumber_Invert
    global PyNumber_Lshift
    global PyNumber_Rshift
    global PyNumber_And
    global PyNumber_Xor
    global PyNumber_Or
    global PyNumber_InPlaceAdd
    global PyNumber_InPlaceSubtract
    global PyNumber_InPlaceMultiply
    global PyNumber_InPlaceMatrixMultiply
    global PyNumber_InPlaceFloorDivide
    global PyNumber_InPlaceTrueDivide
    global PyNumber_InPlaceRemainder
    global PyNumber_InPlacePower
    global PyNumber_InPlaceLshift
    global PyNumber_InPlaceRshift
    global PyNumber_InPlaceAnd
    global PyNumber_InPlaceXor
    global PyNumber_InPlaceOr
    global PyNumber_Long
    global PyNumber_Float
    global PyNumber_Index
    global PyObject_Call
    global PyObject_GetAttr
    global PyObject_GetAttrString
    global PyObject_GetIter
    global PyObject_HasAttrString
    global PyObject_IsTrue
    global PyObject_Length
    global PyObject_LengthHint
    global PyObject_SetAttrString
    global PyObject_Str
    global PyObject_Repr
    global PyObject_Hash
    global PyObject_GetItem
    global PyObject_SetItem
    global PyObject_DelItem
    global PyObject_RichCompare
    global PyObject_IsInstance
    global PyErr_Fetch
    global PyErr_NormalizeException
    global PyErr_SetString
    global Py_None
    global Py_True
    global Py_False
    global Py_Ellipsis
    global Py_NotImplemented
    global PyLong_Type
    global PyFloat_Type
    global PyBool_Type
    global PyUnicode_Type
    global PyComplex_Type
    global PyList_Type
    global PyDict_Type
    global PySet_Type
    global PyTuple_Type
    global PySlice_Type
    global PyExc_BaseException
    global PyExc_Exception
    global PyExc_NameError
    global PyExc_OSError
    global PyExc_IOError
    global PyExc_ValueError
    global PyExc_LookupError
    global PyExc_IndexError
    global PyExc_KeyError
    global PyExc_TypeError
    global PyExc_ArithmeticError
    global PyExc_ZeroDivisionError
    global PyExc_OverflowError
    global PyExc_AttributeError
    global PyExc_RuntimeError
    global PyExc_NotImplementedError
    global PyExc_StopIteration
    global PyExc_AssertionError
    global PyExc_SystemExit

    Py_DecRef = _Py_DecRef
    Py_IncRef = _Py_IncRef
    Py_Initialize = _Py_Initialize
    PyImport_AddModule = _PyImport_AddModule
    PyImport_AddModuleObject = _PyImport_AddModuleObject
    PyImport_ImportModule = _PyImport_ImportModule
    PyRun_SimpleString = _PyRun_SimpleString
    PyEval_GetGlobals = _PyEval_GetGlobals
    PyEval_GetBuiltins = _PyEval_GetBuiltins
    PyLong_AsLong = _PyLong_AsLong
    PyLong_FromLong = _PyLong_FromLong
    PyFloat_AsDouble = _PyFloat_AsDouble
    PyFloat_FromDouble = _PyFloat_FromDouble
    PyBool_FromLong = _PyBool_FromLong
    PyBytes_AsString = _PyBytes_AsString
    PyList_New = _PyList_New
    PyList_Size = _PyList_Size
    PyList_GetItem = _PyList_GetItem
    PyList_SetItem = _PyList_SetItem
    PyDict_New = _PyDict_New
    PyDict_Next = _PyDict_Next
    PyDict_GetItem = _PyDict_GetItem
    PyDict_GetItemString = _PyDict_GetItemString
    PyDict_SetItem = _PyDict_SetItem
    PyDict_Size = _PyDict_Size
    PySet_Add = _PySet_Add
    PySet_New = _PySet_New
    PyTuple_New = _PyTuple_New
    PyTuple_Size = _PyTuple_Size
    PyTuple_GetItem = _PyTuple_GetItem
    PyTuple_SetItem = _PyTuple_SetItem
    PyUnicode_AsEncodedString = _PyUnicode_AsEncodedString
    PyUnicode_DecodeFSDefaultAndSize = _PyUnicode_DecodeFSDefaultAndSize
    PyUnicode_FromString = _PyUnicode_FromString
    PyComplex_FromDoubles = _PyComplex_FromDoubles
    PyComplex_RealAsDouble = _PyComplex_RealAsDouble
    PyComplex_ImagAsDouble = _PyComplex_ImagAsDouble
    PyIter_Next = _PyIter_Next
    PySlice_New = _PySlice_New
    PySlice_Unpack = _PySlice_Unpack
    PyNumber_Add = _PyNumber_Add
    PyNumber_Subtract = _PyNumber_Subtract
    PyNumber_Multiply = _PyNumber_Multiply
    PyNumber_MatrixMultiply = _PyNumber_MatrixMultiply
    PyNumber_FloorDivide = _PyNumber_FloorDivide
    PyNumber_TrueDivide = _PyNumber_TrueDivide
    PyNumber_Remainder = _PyNumber_Remainder
    PyNumber_Divmod = _PyNumber_Divmod
    PyNumber_Power = _PyNumber_Power
    PyNumber_Negative = _PyNumber_Negative
    PyNumber_Positive = _PyNumber_Positive
    PyNumber_Absolute = _PyNumber_Absolute
    PyNumber_Invert = _PyNumber_Invert
    PyNumber_Lshift = _PyNumber_Lshift
    PyNumber_Rshift = _PyNumber_Rshift
    PyNumber_And = _PyNumber_And
    PyNumber_Xor = _PyNumber_Xor
    PyNumber_Or = _PyNumber_Or
    PyNumber_InPlaceAdd = _PyNumber_InPlaceAdd
    PyNumber_InPlaceSubtract = _PyNumber_InPlaceSubtract
    PyNumber_InPlaceMultiply = _PyNumber_InPlaceMultiply
    PyNumber_InPlaceMatrixMultiply = _PyNumber_InPlaceMatrixMultiply
    PyNumber_InPlaceFloorDivide = _PyNumber_InPlaceFloorDivide
    PyNumber_InPlaceTrueDivide = _PyNumber_InPlaceTrueDivide
    PyNumber_InPlaceRemainder = _PyNumber_InPlaceRemainder
    PyNumber_InPlacePower = _PyNumber_InPlacePower
    PyNumber_InPlaceLshift = _PyNumber_InPlaceLshift
    PyNumber_InPlaceRshift = _PyNumber_InPlaceRshift
    PyNumber_InPlaceAnd = _PyNumber_InPlaceAnd
    PyNumber_InPlaceXor = _PyNumber_InPlaceXor
    PyNumber_InPlaceOr = _PyNumber_InPlaceOr
    PyNumber_Long = _PyNumber_Long
    PyNumber_Float = _PyNumber_Float
    PyNumber_Index = _PyNumber_Index
    PyObject_Call = _PyObject_Call
    PyObject_GetAttr = _PyObject_GetAttr
    PyObject_GetAttrString = _PyObject_GetAttrString
    PyObject_GetIter = _PyObject_GetIter
    PyObject_HasAttrString = _PyObject_HasAttrString
    PyObject_IsTrue = _PyObject_IsTrue
    PyObject_Length = _PyObject_Length
    PyObject_LengthHint = _PyObject_LengthHint
    PyObject_SetAttrString = _PyObject_SetAttrString
    PyObject_Str = _PyObject_Str
    PyObject_Repr = _PyObject_Repr
    PyObject_Hash = _PyObject_Hash
    PyObject_GetItem = _PyObject_GetItem
    PyObject_SetItem = _PyObject_SetItem
    PyObject_DelItem = _PyObject_DelItem
    PyObject_RichCompare = _PyObject_RichCompare
    PyObject_IsInstance = _PyObject_IsInstance
    PyErr_Fetch = _PyErr_Fetch
    PyErr_NormalizeException = _PyErr_NormalizeException
    PyErr_SetString = _PyErr_SetString
    Py_None = __ptr__(_Py_NoneStruct).as_byte()
    Py_True = __ptr__(_Py_TrueStruct).as_byte()
    Py_False = __ptr__(_Py_FalseStruct).as_byte()
    Py_Ellipsis = __ptr__(_Py_EllipsisObject).as_byte()
    Py_NotImplemented = __ptr__(_Py_NotImplementedStruct).as_byte()
    PyLong_Type = __ptr__(_PyLong_Type).as_byte()
    PyFloat_Type = __ptr__(_PyFloat_Type).as_byte()
    PyBool_Type = __ptr__(_PyBool_Type).as_byte()
    PyUnicode_Type = __ptr__(_PyUnicode_Type).as_byte()
    PyComplex_Type = __ptr__(_PyComplex_Type).as_byte()
    PyList_Type = __ptr__(_PyList_Type).as_byte()
    PyDict_Type = __ptr__(_PyDict_Type).as_byte()
    PySet_Type = __ptr__(_PySet_Type).as_byte()
    PyTuple_Type = __ptr__(_PyTuple_Type).as_byte()
    PySlice_Type = __ptr__(_PySlice_Type).as_byte()
    PyExc_BaseException = _PyExc_BaseException
    PyExc_Exception = _PyExc_Exception
    PyExc_NameError = _PyExc_NameError
    PyExc_OSError = _PyExc_OSError
    PyExc_IOError = _PyExc_IOError
    PyExc_ValueError = _PyExc_ValueError
    PyExc_LookupError = _PyExc_LookupError
    PyExc_IndexError = _PyExc_IndexError
    PyExc_KeyError = _PyExc_KeyError
    PyExc_TypeError = _PyExc_TypeError
    PyExc_ArithmeticError = _PyExc_ArithmeticError
    PyExc_ZeroDivisionError = _PyExc_ZeroDivisionError
    PyExc_OverflowError = _PyExc_OverflowError
    PyExc_AttributeError = _PyExc_AttributeError
    PyExc_RuntimeError = _PyExc_RuntimeError
    PyExc_NotImplementedError = _PyExc_NotImplementedError
    PyExc_StopIteration = _PyExc_StopIteration
    PyExc_AssertionError = _PyExc_AssertionError
    PyExc_SystemExit = _PyExc_SystemExit

</t>
<t tx="ekr.20230509052845.2451">def init_error_py_types():
    BaseException._pytype = PyExc_BaseException
    Exception._pytype = PyExc_Exception
    NameError._pytype = PyExc_NameError
    OSError._pytype = PyExc_OSError
    IOError._pytype = PyExc_IOError
    ValueError._pytype = PyExc_ValueError
    LookupError._pytype = PyExc_LookupError
    IndexError._pytype = PyExc_IndexError
    KeyError._pytype = PyExc_KeyError
    TypeError._pytype = PyExc_TypeError
    ArithmeticError._pytype = PyExc_ArithmeticError
    ZeroDivisionError._pytype = PyExc_ZeroDivisionError
    OverflowError._pytype = PyExc_OverflowError
    AttributeError._pytype = PyExc_AttributeError
    RuntimeError._pytype = PyExc_RuntimeError
    NotImplementedError._pytype = PyExc_NotImplementedError
    StopIteration._pytype = PyExc_StopIteration
    AssertionError._pytype = PyExc_AssertionError
    SystemExit._pytype = PyExc_SystemExit

</t>
<t tx="ekr.20230509052845.2452">def setup_python(python_loaded: bool):
    global _PY_INITIALIZED
    if _PY_INITIALIZED:
        return

    py_handle = cobj()
    if python_loaded:
        py_handle = dlopen("", RTLD_LOCAL | RTLD_NOW)
    else:
        LD = os.getenv("CODON_PYTHON", default="libpython." + dlext())
        py_handle = dlopen(LD, RTLD_LOCAL | RTLD_NOW)

    init_handles_dlopen(py_handle)
    init_error_py_types()

    if not python_loaded:
        Py_Initialize()

    _PY_INITIALIZED = True

</t>
<t tx="ekr.20230509052845.2453">def ensure_initialized(python_loaded: bool = False):
    if __py_extension__:
        init_handles_static()
        init_error_py_types()
    else:
        setup_python(python_loaded)
        PyRun_SimpleString(_PY_INIT.c_str())

</t>
<t tx="ekr.20230509052845.2454">def setup_decorator():
    setup_python(True)

</t>
<t tx="ekr.20230509052845.2455">@tuple
class _PyArg_Parser:
    initialized: i32
    format: cobj
    keywords: Ptr[cobj]
    fname: cobj
    custom_msg: cobj
    pos: i32
    min: i32
    max: i32
    kwtuple: cobj
    next: cobj

    @others
</t>
<t tx="ekr.20230509052845.2456">def __new__(fname: cobj, keywords: Ptr[cobj], format: cobj):
    z = i32(0)
    o = cobj()
    return _PyArg_Parser(z, format, keywords, fname, o, z, z, z, o, o)

</t>
<t tx="ekr.20230509052845.2457">@extend
class pyobj:
    @others
</t>
<t tx="ekr.20230509052845.2458">@__internal__
def __new__() -&gt; pyobj:
    pass

</t>
<t tx="ekr.20230509052845.2459">def __raw__(self) -&gt; Ptr[byte]:
    return __internal__.class_raw(self)

</t>
<t tx="ekr.20230509052845.246">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;list&gt;
#include &lt;vector&gt;

#include "codon/cir/base.h"
#include "codon/cir/transform/parallel/schedule.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2460">def __init__(self, p: Ptr[byte], steal: bool = False):
    self.p = p
    if not steal:
        self.incref()

</t>
<t tx="ekr.20230509052845.2461">def __del__(self):
    self.decref()

</t>
<t tx="ekr.20230509052845.2462">def _getattr(self, name: str) -&gt; pyobj:
    return pyobj(pyobj.exc_wrap(PyObject_GetAttrString(self.p, name.c_str())), steal=True)

</t>
<t tx="ekr.20230509052845.2463">def __add__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Add(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2464">def __radd__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Add(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2465">def __sub__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Subtract(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2466">def __rsub__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Subtract(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2467">def __mul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Multiply(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2468">def __rmul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Multiply(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2469">def __matmul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_MatrixMultiply(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.247">/// Base for flows, which represent control flow.
class Flow : public AcceptorExtend&lt;Flow, Value&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

protected:
  types::Type *doGetType() const final;
};

</t>
<t tx="ekr.20230509052845.2470">def __rmatmul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_MatrixMultiply(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2471">def __floordiv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_FloorDivide(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2472">def __rfloordiv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_FloorDivide(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2473">def __truediv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_TrueDivide(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2474">def __rtruediv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_TrueDivide(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2475">def __mod__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Remainder(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2476">def __rmod__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Remainder(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2477">def __divmod__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Divmod(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2478">def __rdivmod__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Divmod(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2479">def __pow__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Power(self.p, other.__to_py__(), Py_None)), steal=True)

</t>
<t tx="ekr.20230509052845.248">/// Flow that contains a series of flows or instructions.
class SeriesFlow : public AcceptorExtend&lt;SeriesFlow, Flow&gt; {
private:
  std::list&lt;Value *&gt; series;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return an iterator to the first instruction/flow
  auto begin() { return series.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() { return series.end(); }
  /// @return an iterator to the first instruction/flow
  auto begin() const { return series.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() const { return series.end(); }

  /// @return a pointer to the first instruction/flow
  Value *front() { return series.front(); }
  /// @return a pointer to the last instruction/flow
  Value *back() { return series.back(); }
  /// @return a pointer to the first instruction/flow
  const Value *front() const { return series.front(); }
  /// @return a pointer to the last instruction/flow
  const Value *back() const { return series.back(); }

  /// Inserts an instruction/flow at the given position.
  /// @param pos the position
  /// @param v the flow or instruction
  /// @return an iterator to the newly added instruction/flow
  template &lt;typename It&gt; auto insert(It pos, Value *v) { return series.insert(pos, v); }
  /// Appends an instruction/flow.
  /// @param f the flow or instruction
  void push_back(Value *f) { series.push_back(f); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed flow or instruction
  template &lt;typename It&gt; auto erase(It pos) { return series.erase(pos); }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return std::vector&lt;Value *&gt;(series.begin(), series.end());
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2480">def __rpow__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Power(other.__to_py__(), self.p, Py_None)), steal=True)

</t>
<t tx="ekr.20230509052845.2481">def __neg__(self):
    return pyobj(pyobj.exc_wrap(PyNumber_Negative(self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2482">def __pos__(self):
    return pyobj(pyobj.exc_wrap(PyNumber_Positive(self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2483">def __invert__(self):
    return pyobj(pyobj.exc_wrap(PyNumber_Invert(self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2484">def __lshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Lshift(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2485">def __rlshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Lshift(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2486">def __rshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Rshift(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2487">def __rrshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Rshift(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2488">def __and__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_And(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2489">def __rand__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_And(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.249">/// Flow representing a while loop.
class WhileFlow : public AcceptorExtend&lt;WhileFlow, Flow&gt; {
private:
  /// the condition
  Value *cond;
  /// the body
  Value *body;

public:
  static const char NodeId;

  /// Constructs a while loop.
  /// @param cond the condition
  /// @param body the body
  /// @param name the flow's name
  WhileFlow(Value *cond, Flow *body, std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), body(body) {}

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param c the new condition
  void setCond(Value *c) { cond = c; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new value
  void setBody(Flow *f) { body = f; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {cond, body}; }

  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2490">def __xor__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Xor(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2491">def __rxor__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Xor(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2492">def __or__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Or(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2493">def __ror__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_Or(other.__to_py__(), self.p)), steal=True)

</t>
<t tx="ekr.20230509052845.2494">def __iadd__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceAdd(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2495">def __isub__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceSubtract(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2496">def __imul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceMultiply(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2497">def __imatmul__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceMatrixMultiply(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2498">def __ifloordiv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceFloorDivide(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2499">def __itruediv__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceTrueDivide(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.25">def __sub__(self, other):
    return self + other * -1

</t>
<t tx="ekr.20230509052845.250">/// Flow representing a for loop.
class ForFlow : public AcceptorExtend&lt;ForFlow, Flow&gt; {
private:
  /// the iterator
  Value *iter;
  /// the body
  Value *body;
  /// the variable
  Var *var;
  /// parallel loop schedule, or null if none
  std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule;

public:
  static const char NodeId;

  /// Constructs a for loop.
  /// @param iter the iterator
  /// @param body the body
  /// @param var the variable
  /// @param name the flow's name
  ForFlow(Value *iter, Flow *body, Var *var,
          std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule = {},
          std::string name = "")
      : AcceptorExtend(std::move(name)), iter(iter), body(body), var(var),
        schedule(std::move(schedule)) {}

  /// @return the iter
  Value *getIter() { return iter; }
  /// @return the iter
  const Value *getIter() const { return iter; }
  /// Sets the iter.
  /// @param f the new iter
  void setIter(Value *f) { iter = f; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new body
  void setBody(Flow *f) { body = f; }

  /// @return the var
  Var *getVar() { return var; }
  /// @return the var
  const Var *getVar() const { return var; }
  /// Sets the var.
  /// @param c the new var
  void setVar(Var *c) { var = c; }

  /// @return true if parallel
  bool isParallel() const { return bool(schedule); }
@others
protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {var}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.2500">def __imod__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceRemainder(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2501">def __ipow__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlacePower(self.p, other.__to_py__(), Py_None)), steal=True)

</t>
<t tx="ekr.20230509052845.2502">def __ilshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceLshift(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2503">def __irshift__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceRshift(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2504">def __iand__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceAnd(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2505">def __ixor__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceXor(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2506">def __ior__(self, other):
    return pyobj(pyobj.exc_wrap(PyNumber_InPlaceOr(self.p, other.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2507">def __int__(self):
    o = pyobj.exc_wrap(PyNumber_Long(self.p))
    x = int.__from_py__(o)
    pyobj.decref(o)
    return x

</t>
<t tx="ekr.20230509052845.2508">def __float__(self):
    o = pyobj.exc_wrap(PyNumber_Float(self.p))
    x = float.__from_py__(o)
    pyobj.decref(o)
    return x

</t>
<t tx="ekr.20230509052845.2509">def __index__(self):
    o = pyobj.exc_wrap(PyNumber_Index(self.p))
    x = int.__from_py__(o)
    pyobj.decref(o)
    return x

</t>
<t tx="ekr.20230509052845.251">  /// Sets parallel status.
  /// @param a true if parallel
  void setParallel(bool a = true) {
    if (a)
      schedule = std::make_unique&lt;transform::parallel::OMPSched&gt;();
    else
      schedule = std::unique_ptr&lt;transform::parallel::OMPSched&gt;();
  }

</t>
<t tx="ekr.20230509052845.2510">def __len__(self) -&gt; int:
    return pyobj.exc_wrap(PyObject_Length(self.p))

</t>
<t tx="ekr.20230509052845.2511">def __length_hint__(self) -&gt; int:
    return pyobj.exc_wrap(PyObject_LengthHint(self.p))

</t>
<t tx="ekr.20230509052845.2512">def __getitem__(self, key):
    return pyobj(pyobj.exc_wrap(PyObject_GetItem(self.p, key.__to_py__())), steal=True)

</t>
<t tx="ekr.20230509052845.2513">def __setitem__(self, key, v):
    pyobj.exc_wrap(PyObject_SetItem(self.p, key.__to_py__(), v.__to_py__()))

</t>
<t tx="ekr.20230509052845.2514">def __delitem__(self, key):
    return pyobj.exc_wrap(PyObject_DelItem(self.p, key.__to_py__()))

</t>
<t tx="ekr.20230509052845.2515">def __lt__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_LT))), steal=True)

</t>
<t tx="ekr.20230509052845.2516">def __le__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_LE))), steal=True)

</t>
<t tx="ekr.20230509052845.2517">def __eq__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_EQ))), steal=True)

</t>
<t tx="ekr.20230509052845.2518">def __ne__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_NE))), steal=True)

</t>
<t tx="ekr.20230509052845.2519">def __gt__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_GT))), steal=True)

</t>
<t tx="ekr.20230509052845.252">  /// @return the parallel loop schedule, or null if none
  transform::parallel::OMPSched *getSchedule() { return schedule.get(); }
  /// @return the parallel loop schedule, or null if none
  const transform::parallel::OMPSched *getSchedule() const { return schedule.get(); }
</t>
<t tx="ekr.20230509052845.2520">def __ge__(self, other):
    return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_GE))), steal=True)

</t>
<t tx="ekr.20230509052845.2521">def __to_py__(self) -&gt; cobj:
    return self.p

</t>
<t tx="ekr.20230509052845.2522">def __from_py__(p: cobj) -&gt; pyobj:
    return pyobj(p)

</t>
<t tx="ekr.20230509052845.2523">def __str__(self) -&gt; str:
    o = pyobj.exc_wrap(PyObject_Str(self.p))
    return pyobj.exc_wrap(str.__from_py__(o))

</t>
<t tx="ekr.20230509052845.2524">def __repr__(self) -&gt; str:
    o = pyobj.exc_wrap(PyObject_Repr(self.p))
    return pyobj.exc_wrap(str.__from_py__(o))

</t>
<t tx="ekr.20230509052845.2525">def __hash__(self) -&gt; int:
    return pyobj.exc_wrap(PyObject_Hash(self.p))

</t>
<t tx="ekr.20230509052845.2526">def __iter__(self) -&gt; Generator[pyobj]:
    it = PyObject_GetIter(self.p)
    if not it:
        raise TypeError("Python object is not iterable")
    try:
        while i := PyIter_Next(it):
            yield pyobj(pyobj.exc_wrap(i), steal=True)
    finally:
        pyobj.decref(it)
    pyobj.exc_check()

</t>
<t tx="ekr.20230509052845.2527">def to_str(self, errors: str, empty: str = "") -&gt; str:
    return pyobj.to_str(self.p, errors, empty)

</t>
<t tx="ekr.20230509052845.2528">def to_str(p: cobj, errors: str, empty: str = "") -&gt; str:
    obj = PyUnicode_AsEncodedString(p, "utf-8".c_str(), errors.c_str())
    if obj == cobj():
        return empty
    bts = PyBytes_AsString(obj)
    res = str.from_ptr(bts)
    pyobj.decref(obj)
    return res

</t>
<t tx="ekr.20230509052845.2529">def exc_check():
    ptype, pvalue, ptraceback = cobj(), cobj(), cobj()
    PyErr_Fetch(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
    PyErr_NormalizeException(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
    if ptype != cobj():
        py_msg = PyObject_Str(pvalue) if pvalue != cobj() else pvalue
        msg = pyobj.to_str(py_msg, "ignore", "&lt;empty Python message&gt;")

        pyobj.decref(ptype)
        pyobj.decref(ptraceback)
        pyobj.decref(py_msg)

        # pyobj.decref(pvalue)
        raise PyError(msg, pyobj(pvalue))

</t>
<t tx="ekr.20230509052845.253">  /// Sets the parallel loop schedule
  /// @param s the schedule string (e.g. OpenMP pragma)
  void setSchedule(std::unique_ptr&lt;transform::parallel::OMPSched&gt; s) {
    schedule = std::move(s);
  }

</t>
<t tx="ekr.20230509052845.2530">def exc_wrap(_retval: T, T: type) -&gt; T:
    pyobj.exc_check()
    return _retval

</t>
<t tx="ekr.20230509052845.2531">def incref(self):
    Py_IncRef(self.p)
    return self

</t>
<t tx="ekr.20230509052845.2532">def incref(ptr: Ptr[byte]):
    Py_IncRef(ptr)

</t>
<t tx="ekr.20230509052845.2533">def decref(self):
    Py_DecRef(self.p)
    return self

</t>
<t tx="ekr.20230509052845.2534">def decref(ptr: Ptr[byte]):
    Py_DecRef(ptr)

</t>
<t tx="ekr.20230509052845.2535">def __call__(self, *args, **kwargs):
    args_py = args.__to_py__()
    kws_py = cobj()
    if staticlen(kwargs) &gt; 0:
        names = iter(kwargs.__dict__())
        kws = {next(names): pyobj(i.__to_py__(), steal=True) for i in kwargs}
        kws_py = kws.__to_py__()
    return pyobj(pyobj.exc_wrap(PyObject_Call(self.p, args_py, kws_py)), steal=True)

</t>
<t tx="ekr.20230509052845.2536">def _tuple_new(length: int):
    return pyobj.exc_wrap(PyTuple_New(length))

</t>
<t tx="ekr.20230509052845.2537">def _tuple_size(p: cobj):
    return pyobj.exc_wrap(PyTuple_Size(p))

</t>
<t tx="ekr.20230509052845.2538">def _tuple_set(p: cobj, idx: int, val: cobj):
    PyTuple_SetItem(p, idx, val)
    pyobj.exc_check()

</t>
<t tx="ekr.20230509052845.2539">def _tuple_get(p: cobj, idx: int) -&gt; cobj:
    return pyobj.exc_wrap(PyTuple_GetItem(p, idx))

</t>
<t tx="ekr.20230509052845.254">/// Flow representing an imperative for loop.
class ImperativeForFlow : public AcceptorExtend&lt;ImperativeForFlow, Flow&gt; {
private:
  /// the initial value
  Value *start;
  /// the step value
  int64_t step;
  /// the end value
  Value *end;
  /// the body
  Value *body;
  /// the variable, must be integer type
  Var *var;
  /// parallel loop schedule, or null if none
  std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule;

public:
  static const char NodeId;

  /// Constructs an imperative for loop.
  /// @param body the body
  /// @param start the start value
  /// @param step the step value
  /// @param end the end value
  /// @param var the end variable, must be integer
  /// @param name the flow's name
  ImperativeForFlow(Value *start, int64_t step, Value *end, Flow *body, Var *var,
                    std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule = {},
                    std::string name = "")
      : AcceptorExtend(std::move(name)), start(start), step(step), end(end), body(body),
        var(var), schedule(std::move(schedule)) {}

  /// @return the start value
  Value *getStart() const { return start; }
  /// Sets the start value.
  /// @param v the new value
  void setStart(Value *val) { start = val; }

  /// @return the step value
  int64_t getStep() const { return step; }
  /// Sets the step value.
  /// @param v the new value
  void setStep(int64_t val) { step = val; }

  /// @return the end value
  Value *getEnd() const { return end; }
  /// Sets the end value.
  /// @param v the new value
  void setEnd(Value *val) { end = val; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new body
  void setBody(Flow *f) { body = f; }

  /// @return the var
  Var *getVar() { return var; }
  /// @return the var
  const Var *getVar() const { return var; }
  /// Sets the var.
  /// @param c the new var
  void setVar(Var *c) { var = c; }

  /// @return true if parallel
  bool isParallel() const { return bool(schedule); }
@others
protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {var}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.2540">def _import(name: str) -&gt; pyobj:
    ensure_initialized()
    if name in _PY_MODULE_CACHE:
        return _PY_MODULE_CACHE[name]
    m = pyobj(pyobj.exc_wrap(PyImport_ImportModule(name.c_str())), steal=True)
    _PY_MODULE_CACHE[name] = m
    return m

</t>
<t tx="ekr.20230509052845.2541">def _exec(code: str):
    ensure_initialized()
    PyRun_SimpleString(code.c_str())

</t>
<t tx="ekr.20230509052845.2542">def _globals() -&gt; pyobj:
    p = PyEval_GetGlobals()
    if p == cobj():
        Py_IncRef(Py_None)
        return pyobj(Py_None)
    return pyobj(p)

</t>
<t tx="ekr.20230509052845.2543">def _builtins() -&gt; pyobj:
    return pyobj(PyEval_GetBuiltins())

</t>
<t tx="ekr.20230509052845.2544">def _get_module(name: str) -&gt; pyobj:
    p = pyobj(pyobj.exc_wrap(PyImport_AddModule(name.c_str())))
    return p

</t>
<t tx="ekr.20230509052845.2545">def _main_module() -&gt; pyobj:
    return pyobj._get_module("__main__")

</t>
<t tx="ekr.20230509052845.2546">def _repr_mimebundle_(self, bundle=Set[str]()) -&gt; Dict[str, str]:
    fn = pyobj._main_module()._getattr("__codon_repr__")
    assert fn.p != cobj(), "cannot find python.__codon_repr__"
    mime, txt = Tuple[str, str].__from_py__(fn.__call__(self).p)
    return {mime: txt}

</t>
<t tx="ekr.20230509052845.2547">def __bool__(self):
    return bool(pyobj.exc_wrap(PyObject_IsTrue(self.p) == 1))

</t>
<t tx="ekr.20230509052845.2548">def _get_identifier(typ: str) -&gt; pyobj:
    t = pyobj._builtins()[typ]
    if t.p == cobj():
        t = pyobj._main_module()[typ]
    return t

</t>
<t tx="ekr.20230509052845.2549">def _isinstance(what: pyobj, typ: pyobj) -&gt; bool:
    return bool(pyobj.exc_wrap(PyObject_IsInstance(what.p, typ.p)))

</t>
<t tx="ekr.20230509052845.255">  /// Sets parallel status.
  /// @param a true if parallel
  void setParallel(bool a = true) {
    if (a)
      schedule = std::make_unique&lt;transform::parallel::OMPSched&gt;();
    else
      schedule = std::unique_ptr&lt;transform::parallel::OMPSched&gt;();
  }

</t>
<t tx="ekr.20230509052845.2550">@tuple
class _PyObject_Struct:
    refcnt: int
    pytype: cobj

</t>
<t tx="ekr.20230509052845.2551">def _conversion_error(name: Static[str]):
    raise PyError("conversion error: Python object did not have type '" + name + "'")

</t>
<t tx="ekr.20230509052845.2552">def _ensure_type(o: cobj, t: cobj, name: Static[str]):
    if Ptr[_PyObject_Struct](o)[0].pytype != t:
        _conversion_error(name)


</t>
<t tx="ekr.20230509052845.2553"># Type conversions

</t>
<t tx="ekr.20230509052845.2554">@extend
class NoneType:
    @others
</t>
<t tx="ekr.20230509052845.2555">def __to_py__(self) -&gt; cobj:
    Py_IncRef(Py_None)
    return Py_None

</t>
<t tx="ekr.20230509052845.2556">def __from_py__(x: cobj) -&gt; None:
    if x != Py_None:
        _conversion_error("NoneType")
    return

</t>
<t tx="ekr.20230509052845.2557">@extend
class int:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyLong_FromLong(self))

    def __from_py__(i: cobj) -&gt; int:
        _ensure_type(i, PyLong_Type, "int")
        return PyLong_AsLong(i)

</t>
<t tx="ekr.20230509052845.2558">@extend
class float:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyFloat_FromDouble(self))

    def __from_py__(d: cobj) -&gt; float:
        return pyobj.exc_wrap(PyFloat_AsDouble(d))

</t>
<t tx="ekr.20230509052845.2559">@extend
class bool:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyBool_FromLong(int(self)))

    def __from_py__(b: cobj) -&gt; bool:
        _ensure_type(b, PyBool_Type, "bool")
        return PyObject_IsTrue(b) != 0

</t>
<t tx="ekr.20230509052845.256">  /// @return the parallel loop schedule, or null if none
  transform::parallel::OMPSched *getSchedule() { return schedule.get(); }
  /// @return the parallel loop schedule, or null if none
  const transform::parallel::OMPSched *getSchedule() const { return schedule.get(); }
</t>
<t tx="ekr.20230509052845.2560">@extend
class byte:
    def __to_py__(self) -&gt; cobj:
        return str.__to_py__(str(__ptr__(self), 1))

    def __from_py__(c: cobj) -&gt; byte:
        return str.__from_py__(c).ptr[0]

</t>
<t tx="ekr.20230509052845.2561">@extend
class str:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyUnicode_DecodeFSDefaultAndSize(self.ptr, self.len))

    def __from_py__(s: cobj) -&gt; str:
        return pyobj.exc_wrap(pyobj.to_str(s, "strict"))

</t>
<t tx="ekr.20230509052845.2562">@extend
class complex:
    @others
</t>
<t tx="ekr.20230509052845.2563">def __to_py__(self) -&gt; cobj:
    return pyobj.exc_wrap(PyComplex_FromDoubles(self.real, self.imag))

</t>
<t tx="ekr.20230509052845.2564">def __from_py__(c: cobj) -&gt; complex:
    _ensure_type(c, PyComplex_Type, "complex")
    real = PyComplex_RealAsDouble(c)
    imag = PyComplex_ImagAsDouble(c)
    return complex(real, imag)

</t>
<t tx="ekr.20230509052845.2565">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.2566">def __to_py__(self) -&gt; cobj:
    pylist = PyList_New(len(self))
    pyobj.exc_check()
    idx = 0
    for a in self:
        PyList_SetItem(pylist, idx, a.__to_py__())
        pyobj.exc_check()
        idx += 1
    return pylist

</t>
<t tx="ekr.20230509052845.2567">def __from_py__(v: cobj) -&gt; List[T]:
    _ensure_type(v, PyList_Type, "list")
    n = PyList_Size(v)
    t = List[T](n)
    for i in range(n):
        elem = PyList_GetItem(v, i)
        t.append(T.__from_py__(elem))
    return t

</t>
<t tx="ekr.20230509052845.2568">@extend
class Dict:
    @others
</t>
<t tx="ekr.20230509052845.2569">def __to_py__(self) -&gt; cobj:
    pydict = PyDict_New()
    pyobj.exc_check()
    for k, v in self.items():
        PyDict_SetItem(pydict, k.__to_py__(), v.__to_py__())
        pyobj.exc_check()
    return pydict

</t>
<t tx="ekr.20230509052845.257">  /// Sets the parallel loop schedule
  /// @param s the schedule string (e.g. OpenMP pragma)
  void setSchedule(std::unique_ptr&lt;transform::parallel::OMPSched&gt; s) {
    schedule = std::move(s);
  }

</t>
<t tx="ekr.20230509052845.2570">def __from_py__(d: cobj) -&gt; Dict[K, V]:
    _ensure_type(d, PyDict_Type, "dict")
    b = dict[K, V]()
    pos = 0
    k_ptr = cobj()
    v_ptr = cobj()
    while PyDict_Next(d, __ptr__(pos), __ptr__(k_ptr), __ptr__(v_ptr)):
        k = K.__from_py__(k_ptr)
        v = V.__from_py__(v_ptr)
        b[k] = v
    return b

</t>
<t tx="ekr.20230509052845.2571">@extend
class Set:
    @others
</t>
<t tx="ekr.20230509052845.2572">def __to_py__(self) -&gt; cobj:
    pyset = PySet_New(cobj())
    pyobj.exc_check()
    for a in self:
        PySet_Add(pyset, a.__to_py__())
        pyobj.exc_check()
    return pyset

</t>
<t tx="ekr.20230509052845.2573">def __from_py__(s: cobj) -&gt; Set[K]:
    _ensure_type(s, PySet_Type, "set")
    b = set[K]()
    s_iter = PyObject_GetIter(s)
    while True:
        k_ptr = pyobj.exc_wrap(PyIter_Next(s_iter))
        if not k_ptr:
            break
        k = K.__from_py__(k_ptr)
        pyobj.decref(k_ptr)
        b.add(k)
    pyobj.decref(s_iter)
    return b

</t>
<t tx="ekr.20230509052845.2574">@extend
class DynamicTuple:
    @others
</t>
<t tx="ekr.20230509052845.2575">def __to_py__(self) -&gt; cobj:
    pytup = PyTuple_New(len(self))
    i = 0
    for a in self:
        PyTuple_SetItem(pytup, i, a.__to_py__())
        pyobj.exc_check()
        i += 1
    return pytup

</t>
<t tx="ekr.20230509052845.2576">def __from_py__(t: cobj) -&gt; DynamicTuple[T]:
    _ensure_type(t, PyTuple_Type, "tuple")
    n = PyTuple_Size(t)
    p = Ptr[T](n)
    for i in range(n):
        p[i] = T.__from_py__(PyTuple_GetItem(t, i))
    return DynamicTuple(p, n)

</t>
<t tx="ekr.20230509052845.2577">@extend
class Slice:
    @others
</t>
<t tx="ekr.20230509052845.2578">def __to_py__(self) -&gt; cobj:
    start = self.start
    stop = self.stop
    step = self.step
    start_py = start.__to_py__() if start is not None else cobj()
    stop_py = stop.__to_py__() if stop is not None else cobj()
    step_py = step.__to_py__() if step is not None else cobj()
    return PySlice_New(start_py, stop_py, step_py)

</t>
<t tx="ekr.20230509052845.2579">def __from_py__(s: cobj) -&gt; Slice:
    _ensure_type(s, PySlice_Type, "slice")
    start = 0
    stop = 0
    step = 0
    PySlice_Unpack(s, __ptr__(start), __ptr__(stop), __ptr__(step))
    return Slice(Optional(start), Optional(stop), Optional(step))

</t>
<t tx="ekr.20230509052845.258">/// Flow representing an if statement.
class IfFlow : public AcceptorExtend&lt;IfFlow, Flow&gt; {
private:
  /// the condition
  Value *cond;
  /// the true branch
  Value *trueBranch;
  /// the false branch
  Value *falseBranch;

public:
  static const char NodeId;

  /// Constructs an if.
  /// @param cond the condition
  /// @param trueBranch the true branch
  /// @param falseBranch the false branch
  /// @param name the flow's name
  IfFlow(Value *cond, Flow *trueBranch, Flow *falseBranch = nullptr,
         std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), trueBranch(trueBranch),
        falseBranch(falseBranch) {}

  /// @return the true branch
  Flow *getTrueBranch() { return cast&lt;Flow&gt;(trueBranch); }
  /// @return the true branch
  const Flow *getTrueBranch() const { return cast&lt;Flow&gt;(trueBranch); }
  /// Sets the true branch.
  /// @param f the new true branch
  void setTrueBranch(Flow *f) { trueBranch = f; }

  /// @return the false branch
  Flow *getFalseBranch() { return cast&lt;Flow&gt;(falseBranch); }
  /// @return the false branch
  const Flow *getFalseBranch() const { return cast&lt;Flow&gt;(falseBranch); }
  /// Sets the false.
  /// @param f the new false
  void setFalseBranch(Flow *f) { falseBranch = f; }

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param c the new condition
  void setCond(Value *c) { cond = c; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2580">@extend
class Optional:
    @others
</t>
<t tx="ekr.20230509052845.2581">def __to_py__(self) -&gt; cobj:
    if self is None:
        return Py_None
    else:
        return self.__val__().__to_py__()

</t>
<t tx="ekr.20230509052845.2582">def __from_py__(o: cobj) -&gt; Optional[T]:
    if o == Py_None:
        return Optional[T]()
    else:
        return Optional[T](T.__from_py__(o))


</t>
<t tx="ekr.20230509052845.2583">__pyenv__: Optional[pyobj] = None
</t>
<t tx="ekr.20230509052845.2584">def _____(): __pyenv__  # make it global!


</t>
<t tx="ekr.20230509052845.2585">import internal.static as _S


</t>
<t tx="ekr.20230509052845.2586">class _PyWrapError(Static[PyError]):
    def __init__(self, message: str, pytype: pyobj = pyobj(cobj(), steal=True)):
        super().__init__("_PyWrapError", message)
        self.pytype = pytype

    def __init__(self, e: PyError):
        self.__init__("_PyWrapError", e.message, e.pytype)


</t>
<t tx="ekr.20230509052845.2587">class _PyWrap:
    @others
</t>
<t tx="ekr.20230509052845.2588">def _dispatch_error(F: Static[str]):
    raise TypeError("could not find callable method '" + F + "' for given arguments")

</t>
<t tx="ekr.20230509052845.2589">def _wrap(args, T: type, F: Static[str], map):
    for fn in _S.fn_overloads(T, F):
        a = _PyWrap._args_from_py(fn, args)
        if a is None:
            continue
        if _S.fn_can_call(fn, *a):
            try:
                return map(fn, a)
            except PyError as e:
                pass
    _PyWrap._dispatch_error(F)

</t>
<t tx="ekr.20230509052845.259">/// Flow representing a try-catch statement.
class TryCatchFlow : public AcceptorExtend&lt;TryCatchFlow, Flow&gt; {
public:
@others
private:
  /// the catch clauses
  std::list&lt;Catch&gt; catches;

  /// the body
  Value *body;
  /// the finally, may be nullptr
  Value *finally;

public:
  static const char NodeId;

  /// Constructs an try-catch.
  /// @param name the's name
  /// @param body the body
  /// @param finally the finally
  explicit TryCatchFlow(Flow *body, Flow *finally = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), body(body), finally(finally) {}

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new
  void setBody(Flow *f) { body = f; }

  /// @return the finally
  Flow *getFinally() { return cast&lt;Flow&gt;(finally); }
  /// @return the finally
  const Flow *getFinally() const { return cast&lt;Flow&gt;(finally); }
  /// Sets the finally.
  /// @param f the new
  void setFinally(Flow *f) { finally = f; }

  /// @return an iterator to the first catch
  auto begin() { return catches.begin(); }
  /// @return an iterator beyond the last catch
  auto end() { return catches.end(); }
  /// @return an iterator to the first catch
  auto begin() const { return catches.begin(); }
  /// @return an iterator beyond the last catch
  auto end() const { return catches.end(); }

  /// @return a reference to the first catch
  auto &amp;front() { return catches.front(); }
  /// @return a reference to the last catch
  auto &amp;back() { return catches.back(); }
  /// @return a reference to the first catch
  auto &amp;front() const { return catches.front(); }
  /// @return a reference to the last catch
  auto &amp;back() const { return catches.back(); }

  /// Inserts a catch at the given position.
  /// @param pos the position
  /// @param v the catch
  /// @return an iterator to the newly added catch
  template &lt;typename It&gt; auto insert(It pos, Catch v) { return catches.insert(pos, v); }

  /// Appends a catch.
  /// @param v the catch
  void push_back(Catch v) { catches.push_back(v); }

  /// Emplaces a catch.
  /// @tparam Args the catch constructor args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    catches.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

  /// Erases a catch at the given position.
  /// @param pos the position
  /// @return the iterator beyond the erased catch
  template &lt;typename It&gt; auto erase(It pos) { return catches.erase(pos); }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.2590">def _wrap_unary(obj: cobj, T: type, F: Static[str]) -&gt; cobj:
    return _PyWrap._wrap(
        (obj,), T=T, F=F,
        map=lambda f, a: f(*a).__to_py__()
    )

</t>
<t tx="ekr.20230509052845.2591">def _args_from_py(fn, args):
    def err(fail: Ptr[bool], T: type = NoneType) -&gt; T:
        fail[0] = True
        # auto-return zero-initialized T

    def get_arg(F, p, k, fail: Ptr[bool], i: Static[int]):
        if _S.fn_arg_has_type(F, i):
            return _S.fn_arg_get_type(F, i).__from_py__(p[i]) if p[i] != cobj() else (
                _S.fn_get_default(F, i) if _S.fn_has_default(F, i)
                else err(fail, _S.fn_arg_get_type(F, i))
            )
        else:
            return pyobj(p[i], steal=False) if p[i] != cobj() else (
                _S.fn_get_default(F, i) if _S.fn_has_default(F, i) else err(fail)
            )

    fail = False
    pargs = Ptr[cobj](__ptr__(args).as_byte())
    try:
        ta = tuple(get_arg(fn, pargs, k, __ptr__(fail), i) for i, k in staticenumerate(_S.fn_args(fn)))
        if fail:
            return None
        return _S.fn_wrap_call_args(fn, *ta)
    except PyError:
        return None

</t>
<t tx="ekr.20230509052845.2592">def _reorder_args(fn, self: cobj, args: cobj, kwargs: cobj, M: Static[int] = 1):
    nargs = PyTuple_Size(args)
    nkwargs = PyDict_Size(kwargs) if kwargs != cobj() else 0

    args_ordered = tuple(cobj() for _ in _S.fn_args(fn))
    pargs = Ptr[cobj](__ptr__(args_ordered).as_byte())

    if nargs + nkwargs + M &gt; len(args_ordered):
        return None

    if M:
        pargs[0] = self

    for i in range(nargs):
        pargs[i + M] = PyTuple_GetItem(args, i)

    kwused = 0
    for i, k in staticenumerate(_S.fn_args(fn)):
        if i &lt; nargs + M:
            continue

        p = PyDict_GetItemString(kwargs, k.ptr) if nkwargs else cobj()
        if p != cobj():
            pargs[i] = p
            kwused += 1

    if kwused != nkwargs:
        return None

    return _PyWrap._args_from_py(fn, args_ordered)

</t>
<t tx="ekr.20230509052845.2593">def _reorder_args_fastcall(
    fn, self: cobj, args: Ptr[cobj], nargs: int,
    kwds: Ptr[str], nkw: int, M: Static[int] = 1
):
    args_ordered = tuple(cobj() for _ in _S.fn_args(fn))
    pargs = Ptr[cobj](__ptr__(args_ordered).as_byte())

    if nargs + M &gt; len(args_ordered):
        return None

    if M:
        pargs[0] = self

    for i in range(nargs):
        pargs[i + M] = args[i]

    for i in range(nargs, nargs + nkw):
        kw = kwds[i - nargs]
        o = args[i]

        found = False
        j = M
        for i, k in staticenumerate(_S.fn_args(fn)):
            if M and i == 0:
                continue
            if kw == k:
                if not pargs[j]:
                    pargs[j] = o
                else:
                    return None
                found = True
                break
            j += 1
        if not found:
            return None

    return _PyWrap._args_from_py(fn, args_ordered)

</t>
<t tx="ekr.20230509052845.2594">def wrap_magic_abs(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__abs__")

</t>
<t tx="ekr.20230509052845.2595">def wrap_magic_pos(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__pos__")

</t>
<t tx="ekr.20230509052845.2596">def wrap_magic_neg(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__neg__")

</t>
<t tx="ekr.20230509052845.2597">def wrap_magic_invert(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__invert__")

</t>
<t tx="ekr.20230509052845.2598">def wrap_magic_int(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__int__")

</t>
<t tx="ekr.20230509052845.2599">def wrap_magic_float(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__float__")

</t>
<t tx="ekr.20230509052845.26">def __mul__(self, other):
    v = GVector(self.x * other, self.y * other, self.z * other)
    return v
</t>
<t tx="ekr.20230509052845.260">  /// Class representing a catch clause.
  class Catch {
  private:
    /// the handler
    Value *handler;
    /// the catch type, may be nullptr
    types::Type *type;
    /// the catch variable, may be nullptr
    Var *catchVar;

  public:
    explicit Catch(Flow *handler, types::Type *type = nullptr, Var *catchVar = nullptr)
        : handler(handler), type(type), catchVar(catchVar) {}

    /// @return the handler
    Flow *getHandler() { return cast&lt;Flow&gt;(handler); }
    /// @return the handler
    const Flow *getHandler() const { return cast&lt;Flow&gt;(handler); }
    /// Sets the handler.
    /// @param h the new value
    void setHandler(Flow *h) { handler = h; }

    /// @return the catch type, may be nullptr
    types::Type *getType() const { return type; }
    /// Sets the catch type.
    /// @param t the new type, nullptr for catch all
    void setType(types::Type *t) { type = t; }

    /// @return the variable, may be nullptr
    Var *getVar() { return catchVar; }
    /// @return the variable, may be nullptr
    const Var *getVar() const { return catchVar; }
    /// Sets the variable.
    /// @param v the new value, may be nullptr
    void setVar(Var *v) { catchVar = v; }
  };

</t>
<t tx="ekr.20230509052845.2600">def wrap_magic_index(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__index__")

</t>
<t tx="ekr.20230509052845.2601">def wrap_magic_repr(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__repr__")

</t>
<t tx="ekr.20230509052845.2602">def wrap_magic_str(obj: cobj, T: type):
    return _PyWrap._wrap_unary(obj, T, "__str__")

</t>
<t tx="ekr.20230509052845.2603">def _wrap_binary(obj: cobj, obj2: cobj, T: type, F: Static[str]) -&gt; cobj:
    return _PyWrap._wrap(
        (obj, obj2), T=T, F=F,
        map=lambda f, a: f(*a).__to_py__()
    )

</t>
<t tx="ekr.20230509052845.2604">def wrap_magic_add(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__add__")

</t>
<t tx="ekr.20230509052845.2605">def wrap_magic_radd(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__radd__")

</t>
<t tx="ekr.20230509052845.2606">def wrap_magic_iadd(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__iadd__")

</t>
<t tx="ekr.20230509052845.2607">def wrap_magic_sub(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__sub__")

</t>
<t tx="ekr.20230509052845.2608">def wrap_magic_rsub(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rsub__")

</t>
<t tx="ekr.20230509052845.2609">def wrap_magic_isub(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__isub__")

</t>
<t tx="ekr.20230509052845.261">/// Flow that represents a pipeline. Pipelines with only function
/// stages are expressions and have a concrete type. Pipelines with
/// generator stages are not expressions and have no type. This
/// representation allows for stages that output generators but do
/// not get explicitly iterated in the pipeline, since generator
/// stages are denoted by a separate flag.
class PipelineFlow : public AcceptorExtend&lt;PipelineFlow, Flow&gt; {
public:
@others
private:
  /// pipeline stages
  std::list&lt;Stage&gt; stages;

public:
  static const char NodeId;

  /// Constructs a pipeline flow.
  /// @param stages vector of pipeline stages
  /// @param name the name
  explicit PipelineFlow(std::vector&lt;Stage&gt; stages = {}, std::string name = "")
      : AcceptorExtend(std::move(name)), stages(stages.begin(), stages.end()) {}

  /// @return an iterator to the first stage
  auto begin() { return stages.begin(); }
  /// @return an iterator beyond the last stage
  auto end() { return stages.end(); }
  /// @return an iterator to the first stage
  auto begin() const { return stages.begin(); }
  /// @return an iterator beyond the last stage
  auto end() const { return stages.end(); }

  /// @return a pointer to the first stage
  Stage &amp;front() { return stages.front(); }
  /// @return a pointer to the last stage
  Stage &amp;back() { return stages.back(); }
  /// @return a pointer to the first stage
  const Stage &amp;front() const { return stages.front(); }
  /// @return a pointer to the last stage
  const Stage &amp;back() const { return stages.back(); }

  /// Inserts a stage
  /// @param pos the position
  /// @param v the stage
  /// @return an iterator to the newly added stage
  template &lt;typename It&gt; auto insert(It pos, Stage v) { return stages.insert(pos, v); }
  /// Appends an stage.
  /// @param v the stage
  void push_back(Stage v) { stages.push_back(std::move(v)); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed stage
  template &lt;typename It&gt; auto erase(It pos) { return stages.erase(pos); }

  /// Emplaces a stage.
  /// @param args the args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    stages.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2610">def wrap_magic_mul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__mul__")

</t>
<t tx="ekr.20230509052845.2611">def wrap_magic_rmul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rmul__")

</t>
<t tx="ekr.20230509052845.2612">def wrap_magic_imul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__imul__")

</t>
<t tx="ekr.20230509052845.2613">def wrap_magic_mod(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__mod__")

</t>
<t tx="ekr.20230509052845.2614">def wrap_magic_rmod(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rmod__")

</t>
<t tx="ekr.20230509052845.2615">def wrap_magic_imod(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__imod__")

</t>
<t tx="ekr.20230509052845.2616">def wrap_magic_divmod(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__divmod__")

</t>
<t tx="ekr.20230509052845.2617">def wrap_magic_rdivmod(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rdivmod__")

</t>
<t tx="ekr.20230509052845.2618">def wrap_magic_lshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__lshift__")

</t>
<t tx="ekr.20230509052845.2619">def wrap_magic_rlshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rlshift__")

</t>
<t tx="ekr.20230509052845.262">  /// Represents a single stage in a pipeline.
  class Stage {
  private:
    /// the function being (partially) called in this stage
    Value *callee;
    /// the function arguments, where null represents where
    /// previous pipeline output should go
    std::vector&lt;Value *&gt; args;
    /// true if this stage is a generator
    bool generator;
    /// true if this stage is marked parallel
    bool parallel;

  public:
    /// Constructs a pipeline stage.
    /// @param callee the function being called
    /// @param args call arguments, with exactly one null entry
    /// @param generator whether this stage is a generator stage
    /// @param parallel whether this stage is parallel
    Stage(Value *callee, std::vector&lt;Value *&gt; args, bool generator, bool parallel)
        : callee(callee), args(std::move(args)), generator(generator),
          parallel(parallel) {}

    /// @return an iterator to the first argument
    auto begin() { return args.begin(); }
    /// @return an iterator beyond the last argument
    auto end() { return args.end(); }
    /// @return an iterator to the first argument
    auto begin() const { return args.begin(); }
    /// @return an iterator beyond the last argument
    auto end() const { return args.end(); }

    /// @return a pointer to the first argument
    Value *front() { return args.front(); }
    /// @return a pointer to the last argument
    Value *back() { return args.back(); }
    /// @return a pointer to the first argument
    const Value *front() const { return args.front(); }
    /// @return a pointer to the last argument
    const Value *back() const { return args.back(); }

    /// Inserts an argument.
    /// @param pos the position
    /// @param v the argument
    /// @return an iterator to the newly added argument
    template &lt;typename It&gt; auto insert(It pos, Value *v) { return args.insert(pos, v); }
    /// Appends an argument.
    /// @param v the argument
    void push_back(Value *v) { args.push_back(v); }

    /// Erases the item at the supplied position.
    /// @param pos the position
    /// @return the iterator beyond the removed argument
    template &lt;typename It&gt; auto erase(It pos) { return args.erase(pos); }

    /// Sets the called function.
    /// @param c the callee
    void setCallee(Value *c) { callee = c; }
    /// @return the called function
    Value *getCallee() { return callee; }
    /// @return the called function
    const Value *getCallee() const { return callee; }

    /// Sets the stage's generator flag.
    /// @param v the new value
    void setGenerator(bool v = true) { generator = v; }
    /// @return whether this stage is a generator stage
    bool isGenerator() const { return generator; }
    /// Sets the stage's parallel flag.
    /// @param v the new value
    void setParallel(bool v = true) { parallel = v; }
    /// @return whether this stage is parallel
    bool isParallel() const { return parallel; }
    /// @return the output type of this stage
    types::Type *getOutputType() const;
    /// @return the output element type of this stage
    types::Type *getOutputElementType() const;

    friend class PipelineFlow;
  };

</t>
<t tx="ekr.20230509052845.2620">def wrap_magic_ilshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ilshift__")

</t>
<t tx="ekr.20230509052845.2621">def wrap_magic_rshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rshift__")

</t>
<t tx="ekr.20230509052845.2622">def wrap_magic_rrshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rrshift__")

</t>
<t tx="ekr.20230509052845.2623">def wrap_magic_irshift(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__irshift__")

</t>
<t tx="ekr.20230509052845.2624">def wrap_magic_and(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__and__")

</t>
<t tx="ekr.20230509052845.2625">def wrap_magic_rand(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rand__")

</t>
<t tx="ekr.20230509052845.2626">def wrap_magic_iand(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__iand__")

</t>
<t tx="ekr.20230509052845.2627">def wrap_magic_xor(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__xor__")

</t>
<t tx="ekr.20230509052845.2628">def wrap_magic_rxor(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rxor__")

</t>
<t tx="ekr.20230509052845.2629">def wrap_magic_ixor(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ixor__")

</t>
<t tx="ekr.20230509052845.263">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/flow.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Func&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2630">def wrap_magic_or(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__or__")

</t>
<t tx="ekr.20230509052845.2631">def wrap_magic_ror(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ror__")

</t>
<t tx="ekr.20230509052845.2632">def wrap_magic_ior(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ior__")

</t>
<t tx="ekr.20230509052845.2633">def wrap_magic_floordiv(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__floordiv__")

</t>
<t tx="ekr.20230509052845.2634">def wrap_magic_ifloordiv(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ifloordiv__")

</t>
<t tx="ekr.20230509052845.2635">def wrap_magic_truediv(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__truediv__")

</t>
<t tx="ekr.20230509052845.2636">def wrap_magic_itruediv(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__itruediv__")

</t>
<t tx="ekr.20230509052845.2637">def wrap_magic_matmul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__matmul__")

</t>
<t tx="ekr.20230509052845.2638">def wrap_magic_rmatmul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rmatmul__")

</t>
<t tx="ekr.20230509052845.2639">def wrap_magic_imatmul(obj: cobj, obj2: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__imatmul__")

</t>
<t tx="ekr.20230509052845.264">/// CIR function
class Func : public AcceptorExtend&lt;Func, Var&gt; {
private:
  /// unmangled (source code) name of the function
  std::string unmangledName;
  /// whether the function is a generator
  bool generator;
  /// Parent type if func is a method, or null if not
  types::Type *parentType;

protected:
  /// list of arguments
  std::list&lt;Var *&gt; args;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;

public:
  static const char NodeId;

  /// Constructs an unrealized CIR function.
  /// @param name the function's name
  explicit Func(std::string name = "")
      : AcceptorExtend(nullptr, true, false, std::move(name)), generator(false),
        parentType(nullptr) {}

  /// Re-initializes the function with a new type and names.
  /// @param newType the function's new type
  /// @param names the function's new argument names
  void realize(types::Type *newType, const std::vector&lt;std::string&gt; &amp;names);

  /// @return iterator to the first arg
  auto arg_begin() { return args.begin(); }
  /// @return iterator beyond the last arg
  auto arg_end() { return args.end(); }
  /// @return iterator to the first arg
  auto arg_begin() const { return args.begin(); }
  /// @return iterator beyond the last arg
  auto arg_end() const { return args.end(); }

  /// @return a pointer to the last arg
  Var *arg_front() { return args.front(); }
  /// @return a pointer to the last arg
  Var *arg_back() { return args.back(); }
  /// @return a pointer to the last arg
  const Var *arg_back() const { return args.back(); }
  /// @return a pointer to the first arg
  const Var *arg_front() const { return args.front(); }

  /// @return the function's unmangled (source code) name
  std::string getUnmangledName() const { return unmangledName; }
  /// Sets the unmangled name.
  /// @param v the new value
  void setUnmangledName(std::string v) { unmangledName = std::move(v); }

  /// @return true if the function is a generator
  bool isGenerator() const { return generator; }
  /// Sets the function's generator flag.
  /// @param v the new value
  void setGenerator(bool v = true) { generator = v; }

  /// @return the variable corresponding to the given argument name
  /// @param n the argument name
  Var *getArgVar(const std::string &amp;n);

  /// @return the parent type
  types::Type *getParentType() const { return parentType; }
  /// Sets the parent type.
  /// @param p the new parent
  void setParentType(types::Type *p) { parentType = p; }
};

</t>
<t tx="ekr.20230509052845.2640">def wrap_magic_pow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__pow__")

</t>
<t tx="ekr.20230509052845.2641">def wrap_magic_rpow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__rpow__")

</t>
<t tx="ekr.20230509052845.2642">def wrap_magic_ipow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
    return _PyWrap._wrap_binary(obj, obj2, T, "__ipow__")

</t>
<t tx="ekr.20230509052845.2643">def _wrap_hash(obj: cobj, T: type, F: Static[str]) -&gt; i64:
    return _PyWrap._wrap(
        (obj,), T=T, F=F,
        map=lambda f, a: f(*a)
    )

</t>
<t tx="ekr.20230509052845.2644">def wrap_magic_len(obj: cobj, T: type):
    return _PyWrap._wrap_hash(obj, T, "__len__")

</t>
<t tx="ekr.20230509052845.2645">def wrap_magic_hash(obj: cobj, T: type):
    return _PyWrap._wrap_hash(obj, T, "__hash__")

</t>
<t tx="ekr.20230509052845.2646">def wrap_magic_bool(obj: cobj, T: type) -&gt; i32:
    return _PyWrap._wrap(
        (obj,), T=T, F="__bool__",
        map=lambda f, a: i32(1) if f(*a) else i32(0)
    )

</t>
<t tx="ekr.20230509052845.2647">def wrap_magic_del(obj: cobj, T: type):
    _PyWrap._wrap(
        (obj,), T=T, F="__del__",
        map=lambda f, a: f(*a)
    )

</t>
<t tx="ekr.20230509052845.2648">def wrap_magic_contains(obj: cobj, arg: cobj, T: type) -&gt; i32:
    return _PyWrap._wrap(
        (obj, arg,), T=T, F="__contains__",
        map=lambda f, a: i32(1) if f(*a) else i32(0)
    )

</t>
<t tx="ekr.20230509052845.2649">def wrap_magic_init(obj: cobj, args: cobj, kwargs: cobj, T: type) -&gt; i32:
    if isinstance(T, ByRef):
        F: Static[str] = "__init__"
        for fn in _S.fn_overloads(T, F):
            a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=1)
            if a is not None and _S.fn_can_call(fn, *a):
                fn(*a)
                return i32(0)
        _PyWrap._dispatch_error(F)
    else:
        F: Static[str] = "__new__"
        for fn in _S.fn_overloads(T, F):
            a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=0)
            if a is not None and _S.fn_can_call(fn, *a):
                x = fn(*a)
                p = Ptr[PyObject](obj) + 1
                Ptr[T](p.as_byte())[0] = x
                return i32(0)
        _PyWrap._dispatch_error(F)

</t>
<t tx="ekr.20230509052845.265">class BodiedFunc : public AcceptorExtend&lt;BodiedFunc, Func&gt; {
private:
  /// list of variables defined and used within the function
  std::list&lt;Var *&gt; symbols;
  /// the function body
  Value *body = nullptr;
  /// whether the function is a JIT input
  bool jit = false;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return iterator to the first symbol
  auto begin() { return symbols.begin(); }
  /// @return iterator beyond the last symbol
  auto end() { return symbols.end(); }
  /// @return iterator to the first symbol
  auto begin() const { return symbols.begin(); }
  /// @return iterator beyond the last symbol
  auto end() const { return symbols.end(); }

  /// @return a pointer to the first symbol
  Var *front() { return symbols.front(); }
  /// @return a pointer to the last symbol
  Var *back() { return symbols.back(); }
  /// @return a pointer to the first symbol
  const Var *front() const { return symbols.front(); }
  /// @return a pointer to the last symbol
  const Var *back() const { return symbols.back(); }

  /// Inserts an symbol at the given position.
  /// @param pos the position
  /// @param v the symbol
  /// @return an iterator to the newly added symbol
  template &lt;typename It&gt; auto insert(It pos, Var *v) { return symbols.insert(pos, v); }
  /// Appends an symbol.
  /// @param v the new symbol
  void push_back(Var *v) { symbols.push_back(v); }

  /// Erases the symbol at the given position.
  /// @param pos the position
  /// @return symbol_iterator following the removed symbol.
  template &lt;typename It&gt; auto erase(It pos) { return symbols.erase(pos); }

  /// @return the function body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the function body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the function's body.
  /// @param b the new body
  void setBody(Flow *b) { body = b; }

  /// @return true if the function is a JIT input
  bool isJIT() const { return jit; }
  /// Changes the function's JIT input status.
  /// @param v true if JIT input, false otherwise
  void setJIT(bool v = true) { jit = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return body ? std::vector&lt;Value *&gt;{body} : std::vector&lt;Value *&gt;{};
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.2650">def wrap_magic_call(obj: cobj, args: cobj, kwargs: cobj, T: type) -&gt; cobj:
    F: Static[str] = "__call__"
    for fn in _S.fn_overloads(T, F):
        a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=1)
        if a is not None and _S.fn_can_call(fn, *a):
            return fn(*a).__to_py__()
    _PyWrap._dispatch_error(F)

</t>
<t tx="ekr.20230509052845.2651">def _wrap_cmp(obj: cobj, other: cobj, T: type, F: Static[str]) -&gt; cobj:
    return _PyWrap._wrap(
        (obj, other), T=T, F=F,
        map=lambda f, a: f(*a).__to_py__()
    )

</t>
<t tx="ekr.20230509052845.2652">def wrap_magic_lt(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__lt__")

</t>
<t tx="ekr.20230509052845.2653">def wrap_magic_le(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__le__")

</t>
<t tx="ekr.20230509052845.2654">def wrap_magic_eq(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__eq__")

</t>
<t tx="ekr.20230509052845.2655">def wrap_magic_ne(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__ne__")

</t>
<t tx="ekr.20230509052845.2656">def wrap_magic_gt(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__gt__")

</t>
<t tx="ekr.20230509052845.2657">def wrap_magic_ge(obj: cobj, other: cobj, T: type):
    return _PyWrap._wrap_cmp(obj, other, T, "__ge__")

</t>
<t tx="ekr.20230509052845.2658">def wrap_cmp(obj: cobj, other: cobj, op: i32, C: type) -&gt; cobj:
    if hasattr(C, "__lt__") and op == 0i32:
        return _PyWrap.wrap_magic_lt(obj, other, C)
    elif hasattr(C, "__le__") and op == 1i32:
        return _PyWrap.wrap_magic_le(obj, other, C)
    elif hasattr(C, "__eq__") and op == 2i32:
        return _PyWrap.wrap_magic_eq(obj, other, C)
    elif hasattr(C, "__ne__") and op == 3i32:
        return _PyWrap.wrap_magic_ne(obj, other, C)
    elif hasattr(C, "__gt__") and op == 4i32:
        return _PyWrap.wrap_magic_gt(obj, other, C)
    elif hasattr(C, "__ge__") and op == 5i32:
        return _PyWrap.wrap_magic_ge(obj, other, C)
    else:
        Py_IncRef(Py_NotImplemented)
        return Py_NotImplemented

</t>
<t tx="ekr.20230509052845.2659">def wrap_magic_getitem(obj: cobj, idx: cobj, T: type):
    return _PyWrap._wrap(
        (obj, idx), T=T, F="__getitem__",
        map=lambda f, a: f(*a).__to_py__()
    )

</t>
<t tx="ekr.20230509052845.266">class ExternalFunc : public AcceptorExtend&lt;ExternalFunc, Func&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return true if the function is variadic
  bool isVariadic() const { return cast&lt;types::FuncType&gt;(getType())-&gt;isVariadic(); }
};

</t>
<t tx="ekr.20230509052845.2660">def wrap_magic_setitem(obj: cobj, idx: cobj, val: cobj, T: type) -&gt; i32:
    if val == cobj():
        _PyWrap._wrap(
            (obj, idx), T=T, F="__delitem__",
            map=lambda f, a: f(*a)
        )
    else:
        _PyWrap._wrap(
            (obj, idx, val), T=T, F="__setitem__",
            map=lambda f, a: f(*a)
        )
    return i32(0)

</t>
<t tx="ekr.20230509052845.2661">class IterWrap:
    _gen: cobj
    T: type

    def _init(obj: cobj, T: type) -&gt; cobj:
        return _PyWrap.IterWrap(T.__from_py__(obj)).__to_py__()

    @realize_without_self
    def __init__(self, it: T):
        self._gen = it.__iter__().__raw__()

    def _iter(obj: cobj) -&gt; cobj:
        T  # need separate fn for each instantiation
        p = Ptr[PyObject](obj)
        o = p[0]
        p[0] = PyObject(o.refcnt + 1, o.pytype)
        return obj

    def _iternext(self: cobj) -&gt; cobj:
        pt = _PyWrap.IterWrap[T].__from_py__(self)
        if pt._gen == cobj():
            return cobj()

        gt = type(T().__iter__())(pt._gen)
        if gt.done():
            pt._gen = cobj()
            return cobj()
        else:
            return gt.next().__to_py__()

    def __to_py__(self):
        return _PyWrap.wrap_to_py(self)

    def __from_py__(obj: cobj):
        return _PyWrap.wrap_from_py(obj, _PyWrap.IterWrap[T])

</t>
<t tx="ekr.20230509052845.2662">def wrap_magic_iter(obj: cobj, T: type) -&gt; cobj:
    return _PyWrap.IterWrap._init(obj, T)

</t>
<t tx="ekr.20230509052845.2663">def wrap_multiple(
    obj: cobj, args: Ptr[cobj], nargs: int, _kwds: cobj, T: type, F: Static[str],
    M: Static[int] = 1
):
    kwds = Ptr[str]()
    nkw = 0
    if _kwds:
        nkw = PyTuple_Size(_kwds)
        kwds = Ptr[str](nkw)
        for i in range(nkw):
            kwds[i] = str.__from_py__(PyTuple_GetItem(_kwds, i))

    for fn in _S.fn_overloads(T, F):
        a = _PyWrap._reorder_args_fastcall(fn, obj, args, nargs, kwds, nkw, M)
        if a is not None and _S.fn_can_call(fn, *a):
            return fn(*a).__to_py__()

    _PyWrap._dispatch_error(F)

</t>
<t tx="ekr.20230509052845.2664">def wrap_get(obj: cobj, closure: cobj, T: type, S: Static[str]):
    return getattr(T.__from_py__(obj), S).__to_py__()

</t>
<t tx="ekr.20230509052845.2665">def wrap_set(obj: cobj, what: cobj, closure: cobj, T: type, S: Static[str]) -&gt; i32:
    t = T.__from_py__(obj)
    val = type(getattr(t, S)).__from_py__(what)
    setattr(t, S, val)
    return i32(0)

</t>
<t tx="ekr.20230509052845.2666">def py_type(T: type) -&gt; cobj:
    return cobj()

</t>
<t tx="ekr.20230509052845.2667">def wrap_to_py(o) -&gt; cobj:
    O = type(o)
    P = PyWrapper[O]
    sz = sizeof(P)
    pytype = _PyWrap.py_type(O)
    mem = alloc_atomic_uncollectable(sz) if atomic(O) else alloc_uncollectable(sz)
    obj = Ptr[P](mem.as_byte())
    obj[0] = PyWrapper(PyObject(1, pytype), o)
    return obj.as_byte()

</t>
<t tx="ekr.20230509052845.2668">def wrap_from_py(o: cobj, T: type) -&gt; T:
    obj = Ptr[PyWrapper[T]](o)[0]
    pytype = _PyWrap.py_type(T)
    if obj.head.pytype != pytype:
        _conversion_error(T.__name__)
    return obj.data
</t>
<t tx="ekr.20230509052845.2669">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from algorithms.pdqsort import pdq_sort_inplace
from algorithms.insertionsort import insertion_sort_inplace
from algorithms.heapsort import heap_sort_inplace
from algorithms.qsort import qsort_inplace
from algorithms.timsort import tim_sort_inplace

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.267">/// Internal, LLVM-only function.
class InternalFunc : public AcceptorExtend&lt;InternalFunc, Func&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509052845.2670">def sorted(
    v: Generator[T],
    key=Optional[int](),
    reverse: bool = False,
    algorithm: Static[str] = "auto",
    T: type,
) -&gt; List[T]:
    """
    Return a sorted list of the elements in v
    """
    newlist = [a for a in v]
    if not isinstance(key, Optional):
        newlist.sort(key, reverse, algorithm)
    else:
        newlist.sort(reverse=reverse, algorithm=algorithm)
    return newlist

</t>
<t tx="ekr.20230509052845.2671">def _is_pdq_compatible(x):
    if (isinstance(x, int) or
        isinstance(x, float) or
        isinstance(x, bool) or
        isinstance(x, byte) or
        isinstance(x, str) or
        isinstance(x, Int) or
        isinstance(x, UInt)):
        return True
    elif isinstance(x, Tuple):
        for a in x:
            if not _is_pdq_compatible(a):
                return False
        return True
    else:
        return False

</t>
<t tx="ekr.20230509052845.2672">def _sort_list(
    self: List[T], key: Callable[[T], S], algorithm: Static[str], T: type, S: type
):
    if algorithm == "tim" or algorithm == "auto":
        tim_sort_inplace(self, key)
    elif algorithm == "pdq":
        pdq_sort_inplace(self, key)
    elif algorithm == "insertion":
        insertion_sort_inplace(self, key)
    elif algorithm == "heap":
        heap_sort_inplace(self, key)
    elif algorithm == "quick":
        qsort_inplace(self, key)
    else:
        compile_error("invalid sort algorithm")

</t>
<t tx="ekr.20230509052845.2673">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.2674">def sort(
    self,
    key=Optional[int](),
    reverse: bool = False,
    algorithm: Static[str] = "auto",
):
    if isinstance(key, Optional):
        if algorithm == "auto":
            # Python uses Timsort in all cases, but if we
            # know stability does not matter (i.e. sorting
            # primitive type with no key), we will use
            # faster PDQ instead. PDQ is ~50% faster than
            # Timsort for sorting 1B 64-bit ints.
            if self:
                if _is_pdq_compatible(self[0]):
                    pdq_sort_inplace(self, lambda x: x)
                else:
                    tim_sort_inplace(self, lambda x: x)
        else:
            _sort_list(self, lambda x: x, algorithm)
    else:
        _sort_list(self, key, algorithm)
    if reverse:
        self.reverse()
</t>
<t tx="ekr.20230509052845.2675">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Methods for static reflection. Implemented within call.cpp and/or loops.cpp.
# !! Not intended for public use !!

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2676">def fn_overloads(T: type, F: Static[str]):
    pass

</t>
<t tx="ekr.20230509052845.2677">def fn_args(F):  # function: (i, name)
    pass

</t>
<t tx="ekr.20230509052845.2678">def fn_arg_has_type(F, i: Static[int]):
    pass

</t>
<t tx="ekr.20230509052845.2679">def fn_arg_get_type(F, i: Static[int]):
    pass

</t>
<t tx="ekr.20230509052845.268">/// LLVM function defined in Seq source.
class LLVMFunc : public AcceptorExtend&lt;LLVMFunc, Func&gt; {
private:
  /// literals that must be formatted into the body
  std::vector&lt;types::Generic&gt; llvmLiterals;
  /// declares for llvm-only function
  std::string llvmDeclares;
  /// body of llvm-only function
  std::string llvmBody;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// Sets the LLVM literals.
  /// @param v the new values.
  void setLLVMLiterals(std::vector&lt;types::Generic&gt; v) { llvmLiterals = std::move(v); }

  /// @return iterator to the first literal
  auto literal_begin() { return llvmLiterals.begin(); }
  /// @return iterator beyond the last literal
  auto literal_end() { return llvmLiterals.end(); }
  /// @return iterator to the first literal
  auto literal_begin() const { return llvmLiterals.begin(); }
  /// @return iterator beyond the last literal
  auto literal_end() const { return llvmLiterals.end(); }

  /// @return a reference to the first literal
  auto &amp;literal_front() { return llvmLiterals.front(); }
  /// @return a reference to the last literal
  auto &amp;literal_back() { return llvmLiterals.back(); }
  /// @return a reference to the first literal
  auto &amp;literal_front() const { return llvmLiterals.front(); }
  /// @return a reference to the last literal
  auto &amp;literal_back() const { return llvmLiterals.back(); }

  /// @return the LLVM declarations
  const std::string &amp;getLLVMDeclarations() const { return llvmDeclares; }
  /// Sets the LLVM declarations.
  /// @param v the new value
  void setLLVMDeclarations(std::string v) { llvmDeclares = std::move(v); }
  /// @return the LLVM body
  const std::string &amp;getLLVMBody() const { return llvmBody; }
  /// Sets the LLVM body.
  /// @param v the new value
  void setLLVMBody(std::string v) { llvmBody = std::move(v); }

protected:
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509052845.2680">def fn_can_call(F, *args, **kwargs):
    pass

</t>
<t tx="ekr.20230509052845.2681">def fn_wrap_call_args(F, *args, **kwargs):
    pass

</t>
<t tx="ekr.20230509052845.2682">def fn_has_default(F, i: Static[int]):
    pass

</t>
<t tx="ekr.20230509052845.2683">def fn_get_default(F, i: Static[int]):
    pass

</t>
<t tx="ekr.20230509052845.2684">def class_args(T: type):
    pass

</t>
<t tx="ekr.20230509052845.2685">@no_type_wrap
def static_print(*args):
    pass
</t>
<t tx="ekr.20230509052845.2686">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

_MAX: Static[int] = 0x7FFFFFFFFFFFFFFF

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2687">@extend
class str:
    # Magic methods

    @others
</t>
<t tx="ekr.20230509052845.2688">def __hash__(self) -&gt; int:
    h = 0
    p, n = self.ptr, self.len
    i = 0
    while i &lt; n:
        h = 31 * h + int(p[i])
        i += 1
    return h

</t>
<t tx="ekr.20230509052845.2689">def __lt__(self, other: str) -&gt; bool:
    return self._cmp(other) &lt; 0

</t>
<t tx="ekr.20230509052845.269">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;

#include "codon/cir/flow.h"
#include "codon/cir/types/types.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2690">def __le__(self, other: str) -&gt; bool:
    return self._cmp(other) &lt;= 0

</t>
<t tx="ekr.20230509052845.2691">def __gt__(self, other: str) -&gt; bool:
    return self._cmp(other) &gt; 0

</t>
<t tx="ekr.20230509052845.2692">def __ge__(self, other: str) -&gt; bool:
    return self._cmp(other) &gt;= 0

</t>
<t tx="ekr.20230509052845.2693">def __repr__(self) -&gt; str:
    v = _strbuf(len(self) + 2)

    q, qe = "'", "\\'"
    found_single = False
    found_double = False
    for c in self:
        if c == "'":
            found_single = True
        elif c == '"':
            found_double = True

    if found_single and not found_double:
        q, qe = '"', '\\"'

    v.append(q)
    for c in self:
        d = c
        if c == "\n":
            d = "\\n"
        elif c == "\r":
            d = "\\r"
        elif c == "\t":
            d = "\\t"
        elif c == "\\":
            d = "\\\\"
        elif c == q:
            d = qe
        else:
            b = int(c.ptr[0])
            if not (32 &lt;= b &lt;= 126):
                h = "0123456789abcdef"
                v.append("\\x")
                v.append(h[b // 16])
                v.append(h[b % 16])
                d = ""
        if d:
            v.append(d)
    v.append(q)
    return v.__str__()

</t>
<t tx="ekr.20230509052845.2694">def __getitem__(self, idx: int) -&gt; str:
    if idx &lt; 0:
        idx += len(self)
    if not (0 &lt;= idx &lt; len(self)):
        raise IndexError("string index out of range")
    return str(self.ptr + idx, 1)

</t>
<t tx="ekr.20230509052845.2695">def __getitem__(self, s: Slice) -&gt; str:
    if s.start is None and s.stop is None and s.step is None:
        return self.__copy__()
    elif s.step is None:
        start, stop, step, length = s.adjust_indices(len(self))
        return str(self.ptr + start, length)
    else:
        start, stop, step, length = s.adjust_indices(len(self))
        return self._make_from_range(start, stop, step, length)

</t>
<t tx="ekr.20230509052845.2696">def _make_from_range(self, start: int, stop: int, step: int, length: int) -&gt; str:
    p = Ptr[byte](length)
    j = 0
    for i in range(start, stop, step):
        p[j] = self.ptr[i]
        j += 1
    return str(p, length)

</t>
<t tx="ekr.20230509052845.2697">def __iter__(self) -&gt; Generator[str]:
    i = 0
    n = len(self)
    while i &lt; n:
        yield str(self.ptr + i, 1)
        i += 1

</t>
<t tx="ekr.20230509052845.2698">def __reversed__(self) -&gt; Generator[str]:
    i = len(self) - 1
    while i &gt;= 0:
        yield str(self.ptr + i, 1)
        i -= 1

</t>
<t tx="ekr.20230509052845.2699">def __mul__(self, x: int) -&gt; str:
    total = x * self.len
    p = Ptr[byte](total)
    n = 0
    for _ in range(x):
        str.memcpy(p + n, self.ptr, self.len)
        n += self.len
    return str(p, total)

</t>
<t tx="ekr.20230509052845.27">#__rmul__ = __mul__

</t>
<t tx="ekr.20230509052845.270">/// CIR object representing an "instruction," or discrete operation in the context of a
/// block.
class Instr : public AcceptorExtend&lt;Instr, Value&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

private:
  types::Type *doGetType() const override;
};

</t>
<t tx="ekr.20230509052845.2700">def _cmp(self, other: str) -&gt; int:
    n = min(self.len, other.len)
    i = 0
    while i &lt; n:
        c1 = self.ptr[i]
        c2 = other.ptr[i]
        if c1 != c2:
            return int(c1) - int(c2)
        i += 1
    return self.len - other.len

</t>
<t tx="ekr.20230509052845.2701">import algorithms.strings as algorithms

</t>
<t tx="ekr.20230509052845.2702">@extend
class str:
    @others
</t>
<t tx="ekr.20230509052845.2703">def __contains__(self, pattern: str) -&gt; bool:
    return self.find(pattern) &gt;= 0

</t>
<t tx="ekr.20230509052845.2704"># Helper methods

</t>
<t tx="ekr.20230509052845.2705">def _isdigit(a: byte) -&gt; bool:
    return _C.isdigit(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.2706">def _isspace(a: byte) -&gt; bool:
    return _C.isspace(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.2707">def _isupper(a: byte) -&gt; bool:
    return _C.isupper(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.2708">def _islower(a: byte) -&gt; bool:
    return _C.islower(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.2709">def _isalpha(a: byte) -&gt; bool:
    return _C.isalpha(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.271">/// Instr representing setting a memory location.
class AssignInstr : public AcceptorExtend&lt;AssignInstr, Instr&gt; {
private:
  /// the left-hand side
  Var *lhs;
  /// the right-hand side
  Value *rhs;

public:
  static const char NodeId;

  /// Constructs an assign instruction.
  /// @param lhs the left-hand side
  /// @param rhs the right-hand side
  /// @param field the field being set, may be empty
  /// @param name the instruction's name
  AssignInstr(Var *lhs, Value *rhs, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), rhs(rhs) {}

  /// @return the left-hand side
  Var *getLhs() { return lhs; }
  /// @return the left-hand side
  const Var *getLhs() const { return lhs; }
  /// Sets the left-hand side
  /// @param l the new value
  void setLhs(Var *v) { lhs = v; }

  /// @return the right-hand side
  Value *getRhs() { return rhs; }
  /// @return the right-hand side
  const Value *getRhs() const { return rhs; }
  /// Sets the right-hand side
  /// @param l the new value
  void setRhs(Value *v) { rhs = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {rhs}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {lhs}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.2710">def _isalnum(a: byte) -&gt; bool:
    return _C.isalnum(i32(int(a))) != i32(0)

</t>
<t tx="ekr.20230509052845.2711">def _toupper(a: byte) -&gt; byte:
    return byte(int(_C.toupper(i32(int(a)))))

</t>
<t tx="ekr.20230509052845.2712">def _tolower(a: byte) -&gt; byte:
    return byte(int(_C.tolower(i32(int(a)))))

</t>
<t tx="ekr.20230509052845.2713">def _slice(self, i: int, j: int) -&gt; str:
    return str(self.ptr + i, j - i)

</t>
<t tx="ekr.20230509052845.2714">def _at(self, i: int) -&gt; str:
    return str(self.ptr + i, 1)

</t>
<t tx="ekr.20230509052845.2715">def join(self, l: Generator[str]) -&gt; str:
    buf = _strbuf()
    if len(self) == 0:
        for a in l:
            buf.append(a)
    else:
        first = True
        for a in l:
            if first:
                first = False
            else:
                buf.append(self)
            buf.append(a)
    return buf.__str__()

</t>
<t tx="ekr.20230509052845.2716">def join(self, l: List[str]) -&gt; str:
    if len(l) == 0:
        return ""
    if len(l) == 1:
        return l[0]
    if len(self) == 0:
        return str.cat(l)

    # compute length
    n = 0
    i = 0
    while i &lt; len(l):
        n += len(l[i])
        if i &lt; len(l) - 1:
            n += len(self)
        i += 1

    # copy to new buffer
    p = Ptr[byte](n)
    r = 0
    i = 0
    while i &lt; len(l):
        str.memcpy(p + r, l[i].ptr, len(l[i]))
        r += len(l[i])
        if i &lt; len(l) - 1:
            str.memcpy(p + r, self.ptr, len(self))
            r += len(self)
        i += 1

    return str(p, n)

</t>
<t tx="ekr.20230509052845.2717">def isdigit(self) -&gt; bool:
    """
    str.isdigit() -&gt; bool

    Return True if all characters in str are digits
    and there is at least one character in str, False otherwise.
    """
    if len(self) == 0:
        return False

    for i in range(len(self)):
        if not str._isdigit(self.ptr[i]):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2718">def islower(self) -&gt; bool:
    """
    str.islower() -&gt; bool

    Return True if all cased characters in str are lowercase and there is
    at least one cased character in str, False otherwise.
    """
    cased = False

    # For empty strings
    if len(self) == 0:
        return False

    # For single character strings
    if len(self) == 1:
        return str._islower(self.ptr[0])

    for i in range(len(self)):
        if str._isupper(self.ptr[i]):
            return False
        elif not cased and str._islower(self.ptr[i]):
            cased = True
    return cased

</t>
<t tx="ekr.20230509052845.2719">def isupper(self) -&gt; bool:
    """
    str.isupper() -&gt; bool

    Return True if all cased characters in str are uppercase and there is
    at least one cased character in str, False otherwise.
    """
    cased = False

    # For empty strings
    if len(self) == 0:
        return False

    # For single character strings
    if len(self) == 1:
        return str._isupper(self.ptr[0])

    for i in range(len(self)):
        if str._islower(self.ptr[i]):
            return False
        elif not cased and str._isupper(self.ptr[i]):
            cased = True
    return cased

</t>
<t tx="ekr.20230509052845.272">/// Instr representing loading the field of a value.
class ExtractInstr : public AcceptorExtend&lt;ExtractInstr, Instr&gt; {
private:
  /// the value being manipulated
  Value *val;
  /// the field
  std::string field;

public:
  static const char NodeId;

  /// Constructs a load instruction.
  /// @param val the value being manipulated
  /// @param field the field
  /// @param name the instruction's name
  explicit ExtractInstr(Value *val, std::string field, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val), field(std::move(field)) {}

  /// @return the location
  Value *getVal() { return val; }
  /// @return the location
  const Value *getVal() const { return val; }
  /// Sets the location.
  /// @param p the new value
  void setVal(Value *p) { val = p; }

  /// @return the field
  const std::string &amp;getField() const { return field; }
  /// Sets the field.
  /// @param f the new field
  void setField(std::string f) { field = std::move(f); }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {val}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2720">def isalnum(self) -&gt; bool:
    """
    str.isalnum() -&gt; bool

    Return True if all characters in str are alphanumeric
    and there is at least one character in str, False otherwise.
    """
    if len(self) == 0:
        return False

    for i in range(len(self)):
        if not str._isalnum(self.ptr[i]):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2721">def isalpha(self) -&gt; bool:
    """
    str.isalpha() -&gt; bool

    Return True if all characters in str are alphabetic
    and there is at least one character in str, False otherwise.
    """
    if len(self) == 0:
        return False

    for i in range(len(self)):
        if not str._isalpha(self.ptr[i]):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2722">def isspace(self) -&gt; bool:
    """
    str.isspace() -&gt; bool

    Return True if all characters in str are whitespace
    and there is at least one character in str, False otherwise.
    """
    if len(self) == 0:
        return False

    for i in range(len(self)):
        if not str._isspace(self.ptr[i]):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2723">def istitle(self) -&gt; bool:
    """
    str.istitle() -&gt; bool

    Return True if str is a titlecased string and there is at least one
    character in str, i.e. uppercase characters may only follow uncased
    characters and lowercase characters only cased ones. Return False
    otherwise.
    """

    # For empty strings
    if len(self) == 0:
        return False

    # For single character strings
    if len(self) == 1:
        return str._isupper(self.ptr[0])

    cased = False
    prev_is_cased = False
    for i in range(len(self)):
        if str._isupper(self.ptr[i]):
            if prev_is_cased:
                return False
            prev_is_cased = True
            cased = True
        elif str._islower(self.ptr[i]):
            if not prev_is_cased:
                return False
            prev_is_cased = True
            cased = True
        else:
            prev_is_cased = False
    return cased

</t>
<t tx="ekr.20230509052845.2724">def capitalize(self) -&gt; str:
    """
    str.capitalize() -&gt; copy of str

    Return a copy of str with only its first character capitalized (ASCII)
    and the rest lower-cased.
    """
    n = len(self)
    if n &gt; 0:
        p = Ptr[byte](n)
        p[0] = str._toupper(self.ptr[0])
        for i in range(1, n):
            p[i] = str._tolower(self.ptr[i])
        return str(p, n)
    return ""

</t>
<t tx="ekr.20230509052845.2725">def isdecimal(self) -&gt; bool:
    """
    str.isdecimal() -&gt; bool

    Return True if str is a decimal string, False otherwise.
    str is a decimal string if all characters in str are decimal and
    there is at least one character in str.
    """
    if len(self) == 0:
        return False

    for i in range(len(self)):
        # test ascii values 48-57 == 0-9
        if not (48 &lt;= int(self.ptr[i]) &lt;= 57):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2726">def lower(self) -&gt; str:
    """
    str.lower() -&gt; copy of str

    Return a copy of str with all ASCII characters converted to lowercase.
    """
    # Empty string
    n = len(self)
    if n == 0:
        return ""
    p = Ptr[byte](n)
    for i in range(n):
        p[i] = str._tolower(self.ptr[i])
    return str(p, n)

</t>
<t tx="ekr.20230509052845.2727">def upper(self) -&gt; str:
    """
    str.upper() -&gt; copy of str

    Return a copy of str with all ASCII characters converted to uppercase.
    """
    # Empty string
    n = len(self)
    if n == 0:
        return ""
    p = Ptr[byte](n)
    for i in range(n):
        p[i] = str._toupper(self.ptr[i])
    return str(p, n)

</t>
<t tx="ekr.20230509052845.2728">def isascii(self) -&gt; bool:
    """
    str.isascii() -&gt; bool

    Return True if str is empty or all characters in str are ASCII,
    False otherwise.
    """
    for i in range(len(self)):
        if int(self.ptr[i]) &gt;= 128:
            return False
    return True

</t>
<t tx="ekr.20230509052845.2729">def casefold(self) -&gt; str:
    """
    str.casefold() -&gt; copy of str

    Return a version of the string suitable for caseless comparisons.

    Unlike Python, casefold() deals with just ASCII characters.
    """
    return self.lower()

</t>
<t tx="ekr.20230509052845.273">/// Instr representing setting the field of a value.
class InsertInstr : public AcceptorExtend&lt;InsertInstr, Instr&gt; {
private:
  /// the value being manipulated
  Value *lhs;
  /// the field
  std::string field;
  /// the value being inserted
  Value *rhs;

public:
  static const char NodeId;

  /// Constructs a load instruction.
  /// @param lhs the value being manipulated
  /// @param field the field
  /// @param rhs the new value
  /// @param name the instruction's name
  explicit InsertInstr(Value *lhs, std::string field, Value *rhs, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), field(std::move(field)), rhs(rhs) {}

  /// @return the left-hand side
  Value *getLhs() { return lhs; }
  /// @return the left-hand side
  const Value *getLhs() const { return lhs; }
  /// Sets the left-hand side.
  /// @param p the new value
  void setLhs(Value *p) { lhs = p; }

  /// @return the right-hand side
  Value *getRhs() { return rhs; }
  /// @return the right-hand side
  const Value *getRhs() const { return rhs; }
  /// Sets the right-hand side.
  /// @param p the new value
  void setRhs(Value *p) { rhs = p; }

  /// @return the field
  const std::string &amp;getField() const { return field; }
  /// Sets the field.
  /// @param f the new field
  void setField(std::string f) { field = std::move(f); }

protected:
  types::Type *doGetType() const override { return lhs-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {lhs, rhs}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2730">def swapcase(self) -&gt; str:
    """
    str.swapcase() -&gt; copy of str

    Return a copy of str with uppercase ASCII characters converted
    to lowercase ASCII and vice versa.
    """
    # Empty string
    n = len(self)
    if n == 0:
        return ""
    p = Ptr[byte](n)
    for i in range(n):
        if str._islower(self.ptr[i]):
            p[i] = str._toupper(self.ptr[i])
        elif str._isupper(self.ptr[i]):
            p[i] = str._tolower(self.ptr[i])
        else:
            p[i] = self.ptr[i]
    return str(p, n)

</t>
<t tx="ekr.20230509052845.2731">def title(self) -&gt; str:
    """
    str.title() -&gt; copy of str

    Return a titlecased version of str, i.e. ASCII words start with uppercase
    characters, all remaining cased characters have lowercase.
    """
    prev_is_cased = False

    n = len(self)
    if n == 0:
        return ""

    p = Ptr[byte](n)
    for i in range(n):
        if str._islower(self.ptr[i]):
            # lowercase to uppercase
            if not prev_is_cased:
                p[i] = str._toupper(self.ptr[i])
            else:
                p[i] = self.ptr[i]
            prev_is_cased = True
        elif str._isupper(self.ptr[i]):
            # uppercase to lowercase
            if prev_is_cased:
                p[i] = str._tolower(self.ptr[i])
            else:
                p[i] = self.ptr[i]
            prev_is_cased = True
        else:
            p[i] = self.ptr[i]
            prev_is_cased = False
    return str(p, n)

</t>
<t tx="ekr.20230509052845.2732">def isnumeric(self) -&gt; bool:
    """
    str.isdecimal() -&gt; bool

    Return True if the string is a numeric string, False otherwise.
    A string is numeric if all characters in the string are numeric
    and there is at least one character in the string.

    Unlike Python, isnumeric() deals with just ASCII characters.
    """
    return self.isdecimal()

</t>
<t tx="ekr.20230509052845.2733">def _build(*args):
    total = 0
    for t in args:
        if isinstance(t, str):
            total += len(t)
        else:
            total += len(t[0]) * t[1]
    p = Ptr[byte](total)
    i = 0

    for t in args:
        if isinstance(t, str):
            str.memcpy(p + i, t.ptr, t.len)
            i += t.len
        else:
            s, n = t
            for _ in range(n):
                str.memcpy(p + i, s.ptr, s.len)
                i += s.len

    return str(p, total)

</t>
<t tx="ekr.20230509052845.2734">def ljust(self, width: int, fillchar: str = " ") -&gt; str:
    """
    ljust(width[, fillchar]) -&gt; string

    Return a left-justified string of length width.

    Padding is done using the specified fill character (default is a space).
    """
    if len(fillchar) != 1:
        raise ValueError("The fill character must be exactly one character long")
    if width &lt;= len(self):
        return self
    return str._build(self, (fillchar, width - len(self)))

</t>
<t tx="ekr.20230509052845.2735">def rjust(self, width: int, fillchar: str = " ") -&gt; str:
    """
    rjust(width[, fillchar]) -&gt; string

    Return a right-justified string of length width.

    Padding is done using the specified fill character (default is a space).
    """
    if len(fillchar) != 1:
        raise ValueError("The fill character must be exactly one character long")
    if width &lt;= len(self):
        return self
    return str._build((fillchar, width - len(self)), self)

</t>
<t tx="ekr.20230509052845.2736">def center(self, width: int, fillchar: str = " ") -&gt; str:
    """
    str.center(width[, fillchar]) -&gt; string

    Return str centered in a string of length width. Padding is
    done using the specified fill character (default is a space)
    """
    if len(fillchar) != 1:
        raise ValueError("The fill character must be exactly one character long")
    if width &lt;= len(self):
        return self

    pad = width - len(self)
    left_pad = pad // 2
    right_pad = width - len(self) - left_pad
    return str._build((fillchar, left_pad), self, (fillchar, right_pad))

</t>
<t tx="ekr.20230509052845.2737">def zfill(self, width: int) -&gt; str:
    """
    str.zfill(width) -&gt; string

    Pad a numeric string str with zeros on the left, to fill a field
    of the specified width.  The string str is never truncated.
    """
    if len(self) &gt;= width:
        return self

    plus = byte(43)   # +
    minus = byte(45)  # -
    zero = byte(48)   # 0

    zf = self.rjust(width, '0')
    fill = width - len(self)
    p = zf.ptr

    if p[fill] == plus or p[fill] == minus:
        p[0] = p[fill]
        p[fill] = zero

    return zf

</t>
<t tx="ekr.20230509052845.2738">def count(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
    """
    str.count(sub[, start[, end]]) -&gt; int

    Return the number of occurrences of subsection sub in
    bytes str[start:end].  Optional arguments start and end are interpreted
    as in slice notation.
    """
    end: int = end if end is not None else len(self)
    start, end = self._correct_indices(start, end)
    if end - start &lt; len(sub):
        return 0
    return algorithms.count(self._slice(start, end), sub)

</t>
<t tx="ekr.20230509052845.2739">def find(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
    """
    str.find(sub [,start [,end]]) -&gt; int

    Return the lowest index in str where substring sub is found,
    such that sub is contained within str[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
    """
    end: int = end if end is not None else len(self)
    start, end = self._correct_indices(start, end)
    if end - start &lt; len(sub):
        return -1
    pos = algorithms.find(self._slice(start, end), sub)
    return pos if pos &lt; 0 else pos + start

</t>
<t tx="ekr.20230509052845.274">/// Instr representing calling a function.
class CallInstr : public AcceptorExtend&lt;CallInstr, Instr&gt; {
private:
  /// the function
  Value *callee;
  /// the arguments
  std::vector&lt;Value *&gt; args;

public:
  static const char NodeId;

  /// Constructs a call instruction.
  /// @param callee the function
  /// @param args the arguments
  /// @param name the instruction's name
  CallInstr(Value *callee, std::vector&lt;Value *&gt; args, std::string name = "")
      : AcceptorExtend(std::move(name)), callee(callee), args(std::move(args)) {}

  /// Constructs a call instruction with no arguments.
  /// @param callee the function
  /// @param name the instruction's name
  explicit CallInstr(Value *callee, std::string name = "")
      : CallInstr(callee, {}, std::move(name)) {}

  /// @return the callee
  Value *getCallee() { return callee; }
  /// @return the callee
  const Value *getCallee() const { return callee; }
  /// Sets the callee.
  /// @param c the new value
  void setCallee(Value *c) { callee = c; }

  /// @return an iterator to the first argument
  auto begin() { return args.begin(); }
  /// @return an iterator beyond the last argument
  auto end() { return args.end(); }
  /// @return an iterator to the first argument
  auto begin() const { return args.begin(); }
  /// @return an iterator beyond the last argument
  auto end() const { return args.end(); }

  /// @return a pointer to the first argument
  Value *front() { return args.front(); }
  /// @return a pointer to the last argument
  Value *back() { return args.back(); }
  /// @return a pointer to the first argument
  const Value *front() const { return args.front(); }
  /// @return a pointer to the last argument
  const Value *back() const { return args.back(); }

  /// Inserts an argument at the given position.
  /// @param pos the position
  /// @param v the argument
  /// @return an iterator to the newly added argument
  template &lt;typename It&gt; auto insert(It pos, Value *v) { return args.insert(pos, v); }
  /// Appends an argument.
  /// @param v the argument
  void push_back(Value *v) { args.push_back(v); }

  /// Sets the args.
  /// @param v the new args vector
  void setArgs(std::vector&lt;Value *&gt; v) { args = std::move(v); }

  /// @return the number of arguments
  int numArgs() const { return args.size(); }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2740">def rfind(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
    """
    str.rfind(sub [,start [,end]]) -&gt; int

    Return the highest index in str where substring sub is found,
    such that sub is contained within str[start:end].  Optional
    arguments start and end are interpreted as in slice notation.

    Return -1 on failure.
    """
    end: int = end if end is not None else len(self)
    start, end = self._correct_indices(start, end)
    if end - start &lt; len(sub):
        return -1
    pos = algorithms.rfind(self._slice(start, end), sub)
    return pos if pos &lt; 0 else pos + start

</t>
<t tx="ekr.20230509052845.2741">def isidentifier(self) -&gt; bool:
    """
    str.isidentifier() -&gt; bool

    Return True if the string is a valid identifier, False otherwise.
    Unlike Python, isidentifier() deals with just ASCII characters.
    """
    # empty string
    if len(self) == 0:
        return False

    # is not a letter or _
    first = self._at(0)
    if not first.isalpha():
        if first != "_":
            return False

    if first.isalpha() or first == "_":
        for i in range(1, len(self)):
            ith = self._at(i)
            if not ith.isalpha():
                if not ith.isdecimal():
                    if ith != "_":
                        return False

    return True

</t>
<t tx="ekr.20230509052845.2742">def isprintable(self) -&gt; bool:
    """
    str.isprintable() -&gt; bool

    Return True if the string is printable or empty, False otherwise.
    Unlike Python, isprintable() deals with just ASCII characters.
    """
    for i in range(len(self)):
        if not (31 &lt; int(self.ptr[i]) &lt; 128):
            return False
    return True

</t>
<t tx="ekr.20230509052845.2743">def _has_char(self, chars: str) -&gt; bool:
    s = self._at(0)
    if chars:
        for c in chars:
            if s == c:
                return True
        return False
    else:
        return s.isspace()

</t>
<t tx="ekr.20230509052845.2744">def lstrip(self, chars: str = "") -&gt; str:
    """
    str.lstrip([chars]) -&gt; string

    Return a copy of the string str with leading whitespace removed.
    If chars is given, remove characters in chars instead.
    Unlike Python, lstrip() deals with just ASCII characters.
    """
    i = 0
    while i &lt; len(self) and self._at(i)._has_char(chars):
        i += 1
    return self._slice(i, len(self))

</t>
<t tx="ekr.20230509052845.2745">def rstrip(self, chars: str = "") -&gt; str:
    """
    str.rstrip([chars]) -&gt; string

    Return a copy of the string str with trailing whitespace removed.
    If chars is given, remove characters in chars instead.
    Unlike Python, rstrip() deals with just ASCII characters.
    """
    i = len(self) - 1
    while i &gt;= 0 and self._at(i)._has_char(chars):
        i -= 1
    return self._slice(0, i + 1)

</t>
<t tx="ekr.20230509052845.2746">def strip(self, chars: str = "") -&gt; str:
    """
    str.strip([chars]) -&gt; string

    Return a copy of the string str with leading and trailing
    whitespace removed.
    If chars is given, remove characters in chars instead.
    Unlike Python, strip() deals with just ASCII characters.
    """
    return self.lstrip(chars).rstrip(chars)

</t>
<t tx="ekr.20230509052845.2747">def partition(self, sep: str) -&gt; Tuple[str, str, str]:
    """
    Search for the separator sep in str, and return the part before it,
    the separator itself, and the part after it.  If the separator is not
    found, return str and two empty strings.
    """
    if not sep:
        raise ValueError("empty separator")
    pos = algorithms.find(self, sep)
    if pos &lt; 0:
        return self, "", ""
    return self._slice(0, pos), sep, self._slice(pos + len(sep), len(self))

</t>
<t tx="ekr.20230509052845.2748">def rpartition(self, sep: str) -&gt; Tuple[str, str, str]: # XXX
    """
    Search for the separator sep in str, starting at the end of str, and return
    the part before it, the separator itself, and the part after it.  If the
    separator is not found, return two empty strings and str.
    """
    if not sep:
        raise ValueError("empty separator")
    pos = algorithms.rfind(self, sep)
    if pos &lt; 0:
        return "", "", self
    return self._slice(0, pos), sep, self._slice(pos + len(sep), len(self))

</t>
<t tx="ekr.20230509052845.2749">def split(self, sep: Optional[str] = None, maxsplit: int = -1) -&gt; List[str]:
    """
    str.split([sep [,maxsplit]]) -&gt; list of strings

    Return a list of the words in the string str, using sep as the
    delimiter string.  If maxsplit is given, at most maxsplit
    splits are done. If sep is not specified, any
    whitespace string is a separator and empty strings are removed
    from the result.
    """
    if sep is None:
        return self._split_whitespace(
            maxsplit if maxsplit &gt;= 0 else _MAX
        )
    sep: str = sep

    if len(sep) == 0:
        raise ValueError("empty separator")

    # special case for length-1 pattern
    if len(sep) == 1:
        return self._split_char(sep.ptr[0], maxsplit if maxsplit &gt;= 0 else _MAX)

    MAX_PREALLOC = 12
    maxsplit = maxsplit if maxsplit &gt;= 0 else _MAX
    prealloc_size = MAX_PREALLOC if maxsplit &gt;= MAX_PREALLOC else maxsplit + 1
    v = List[str](capacity=prealloc_size)
    i = 0
    j = 0
    n = len(self)

    while maxsplit &gt; 0:
        maxsplit -= 1
        pos = algorithms.find(self._slice(i, n), sep)
        if pos &lt; 0:
            break
        j = i + pos
        v.append(self._slice(i, j))
        i = j + len(sep)

    v.append(self._slice(i, n))
    return v

</t>
<t tx="ekr.20230509052845.275">/// Instr representing allocating an array on the stack.
class StackAllocInstr : public AcceptorExtend&lt;StackAllocInstr, Instr&gt; {
private:
  /// the array type
  types::Type *arrayType;
  /// number of elements to allocate
  int64_t count;

public:
  static const char NodeId;

  /// Constructs a stack allocation instruction.
  /// @param arrayType the type of the array
  /// @param count the number of elements
  /// @param name the name
  StackAllocInstr(types::Type *arrayType, int64_t count, std::string name = "")
      : AcceptorExtend(std::move(name)), arrayType(arrayType), count(count) {}

  /// @return the count
  int64_t getCount() const { return count; }
  /// Sets the count.
  /// @param c the new value
  void setCount(int64_t c) { count = c; }

  /// @return the array type
  types::Type *getArrayType() { return arrayType; }
  /// @return the array type
  types::Type *getArrayType() const { return arrayType; }
  /// Sets the array type.
  /// @param t the new type
  void setArrayType(types::Type *t) { arrayType = t; }

protected:
  types::Type *doGetType() const override { return arrayType; }
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {arrayType}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509052845.2750">def rsplit(self, sep: Optional[str] = None, maxsplit: int = -1) -&gt; List[str]:
    """
    str.rsplit([sep [,maxsplit]]) -&gt; list of strings

    Return a list of the words in the string str, using sep as the
    delimiter string, starting at the end of the string and working
    to the front.  If maxsplit is given, at most maxsplit splits are
    done. If sep is not specified, any whitespace string
    is a separator.
    """
    if sep is None:
        return self._rsplit_whitespace(
            maxsplit if maxsplit &gt;= 0 else _MAX
        )
    sep: str = sep

    if len(sep) == 0:
        raise ValueError("empty separator")

    # special case for length-1 pattern
    if len(sep) == 1:
        return self._rsplit_char(sep.ptr[0], maxsplit if maxsplit &gt;= 0 else _MAX)

    MAX_PREALLOC = 12
    maxsplit = maxsplit if maxsplit &gt;= 0 else _MAX
    prealloc_size = MAX_PREALLOC if maxsplit &gt;= MAX_PREALLOC else maxsplit + 1
    v = List[str](capacity=prealloc_size)
    i = 0
    j = len(self)
    n = j

    while maxsplit &gt; 0:
        maxsplit -= 1
        pos = algorithms.rfind(self._slice(0, j), sep)
        if pos &lt; 0:
            break
        v.append(self._slice(pos + len(sep), j))
        j = pos

    v.append(self._slice(0, j))
    v.reverse()
    return v

</t>
<t tx="ekr.20230509052845.2751">def splitlines(self, keepends: bool = False) -&gt; List[str]:
    """
    str.splitlines([keepends]) -&gt; list of strings

    Return a list of the lines in str, breaking at line boundaries.
    Line breaks are not included in the resulting list unless keepends
    is given and true.
    """
    v = []
    i = 0
    j = 0
    n = len(self)

    break_r = byte(13)  # \r
    break_n = byte(10)  # \n

    while i &lt; n:
        while i &lt; n and not (self.ptr[i] == break_r or self.ptr[i] == break_n):
            i += 1

        eol = i
        if i &lt; n:
            if self.ptr[i] == break_r and i + 1 &lt; n and self.ptr[i + 1] == break_n:
                i += 2
            else:
                i += 1
            if keepends:
                eol = i

        if j == 0 and eol == n:
            v.append(self)
            break

        v.append(self._slice(j, eol))
        j = i

    return v

</t>
<t tx="ekr.20230509052845.2752">def startswith(
    self, prefix: str, start: int = 0, end: Optional[int] = None
) -&gt; bool:
    """
    str.startswith(prefix[, start[, end]]) -&gt; bool

    Return True if str starts with the specified prefix, False otherwise.
    With optional start, test str beginning at that position.
    With optional end, stop comparing str at that position.
    """
    end: int = end if end is not None else len(self)
    if end &lt; 0:
        end += len(self)
    elif start &lt; 0:
        start += len(self)

    # length prefix is longer than range of string being compared to
    if start + len(prefix) &gt; len(self):
        return False

    # length of prefix is longer than range of string[start:end]
    if end - start &lt; len(prefix):
        return False

    # prefix is an empty string
    if not prefix:
        return True

    return prefix == self._slice(start, start + len(prefix))

</t>
<t tx="ekr.20230509052845.2753">def endswith(self, suffix: str, start: int = 0, end: Optional[int] = None) -&gt; bool:
    """
    str.endswith(prefix[, start[, end]]) -&gt; bool

    Return True if str ends with the specified suffix, False otherwise.
    With optional start, test str beginning at that position.
    With optional end, stop comparing str at that position.
    """
    end: int = end if end is not None else len(self)
    if end &lt; 0:
        end += len(self)
    elif start &lt; 0:
        start += len(self)
    if end &gt; len(self):
        end = len(self)

    # length prefix is longer than range of string being compared to
    if end - start &lt; len(suffix) or start &gt; len(self):
        return False

    if end - len(suffix) &gt; start:
        start = end - len(suffix)

    # length of prefix is longer than range of string[start:end]
    if end - start &lt; len(suffix):
        return False

    # prefix is an empty string
    if not suffix:
        return True

    return suffix == self._slice(start, start + len(suffix))

</t>
<t tx="ekr.20230509052845.2754">def index(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
    """
    str.index(sub [,start [,end]]) -&gt; int

    Like str.find() but raise ValueError when the substring is not found.
    """
    i = self.find(sub, start, end)
    if i == -1:
        raise ValueError("substring not found")
    else:
        return i

</t>
<t tx="ekr.20230509052845.2755">def rindex(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
    """
    str.index(sub [,start [,end]]) -&gt; int

    Like str.find() but raise ValueError when the substring is not found.
    """
    i = self.rfind(sub, start, end)
    if i == -1:
        raise ValueError("substring not found")
    else:
        return i

</t>
<t tx="ekr.20230509052845.2756">def replace(self, old: str, new: str, maxcount: int = -1) -&gt; str:
    """
    str.replace(old, new[, count]) -&gt; string

    Return a copy of string str with all occurrences of substring
    old replaced by new.  If the optional argument maxcount is
    given, only the first maxcount occurrences are replaced.
    """
    return self._replace(old, new, maxcount)

</t>
<t tx="ekr.20230509052845.2757">def expandtabs(self, tabsize: int = 8) -&gt; str:
    """
    str.expandtabs([tabsize]) -&gt; string

    Return a copy of str where all tab characters are expanded using spaces.
    If tabsize is not given, a tab size of 8 characters is assumed.
    """
    i = 0
    j = 0
    p = self.ptr
    e = p + len(self)

    break_r = byte(13)  # \r
    break_n = byte(10)  # \n
    tab = byte(9)       # \t
    space = byte(32)    # ' '

    def overflow():
        raise OverflowError("result too long")

    while p &lt; e:
        if p[0] == tab:
            if tabsize &gt; 0:
                incr = tabsize - (j % tabsize)
                if j &gt; _MAX - incr:
                    overflow()
                j += incr
        else:
            if j &gt; _MAX - 1:
                overflow()
            j += 1
            if p[0] == break_n or p[0] == break_r:
                if i &gt; _MAX - j:
                    overflow()
                i += j
                j = 0
        p += 1

    if i &gt; _MAX - j:
        overflow()

    u_len = i + j
    u = Ptr[byte](u_len)
    j = 0
    q = u
    p = self.ptr

    while p &lt; e:
        if p[0] == tab:
            if tabsize &gt; 0:
                i = tabsize - (j % tabsize)
                j += i
                while True:
                    k = i
                    i -= 1
                    if k == 0:
                        break
                    q[0] = space
                    q += 1
        else:
            j += 1
            q[0] = p[0]
            q += 1
            if p[0] == break_n or p[0] == break_r:
                j = 0
        p += 1

    return str(u, u_len)

</t>
<t tx="ekr.20230509052845.2758">def translate(self, map) -&gt; str:
    """
    Return a copy with each character mapped by the given translation table.
    """
    n = len(self)
    m = 0

    for i in range(n):
        key = int(self.ptr[i])
        if key in map:
            val = map[key]
            if val is not None:
                m += len(val)
        else:
            m += 1

    p = Ptr[byte](m)
    q = p

    for i in range(n):
        key = int(self.ptr[i])
        if key in map:
            val = map[key]
            if val is not None:
                str.memcpy(q, val.ptr, len(val))
                q += len(val)
        else:
            q[0] = self.ptr[i]
            q += 1

    return str(p, m)


</t>
<t tx="ekr.20230509052845.2759"># Internal helpers

</t>
<t tx="ekr.20230509052845.276">/// Instr representing getting information about a type.
class TypePropertyInstr : public AcceptorExtend&lt;TypePropertyInstr, Instr&gt; {
public:
  enum Property { IS_ATOMIC, IS_CONTENT_ATOMIC, SIZEOF };

private:
  /// the type being inspected
  types::Type *inspectType;
  /// the property being checked
  Property property;

public:
  static const char NodeId;

  /// Constructs a type property instruction.
  /// @param type the type being inspected
  /// @param name the name
  explicit TypePropertyInstr(types::Type *type, Property property,
                             std::string name = "")
      : AcceptorExtend(std::move(name)), inspectType(type), property(property) {}

  /// @return the type being inspected
  types::Type *getInspectType() { return inspectType; }
  /// @return the type being inspected
  types::Type *getInspectType() const { return inspectType; }
  /// Sets the type being inspected
  /// @param t the new type
  void setInspectType(types::Type *t) { inspectType = t; }

  /// @return the property being inspected
  Property getProperty() const { return property; }
  /// Sets the property.
  /// @param p the new value
  void setProperty(Property p) { property = p; }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {inspectType}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509052845.2760">def _correct_indices(self, start: int, end: int) -&gt; Tuple[int, int]:
    n = len(self)

    if end &gt; n:
        end = n
    elif end &lt; 0:
        end += n
        if end &lt; 0:
            end = 0

    if start &lt; 0:
        start += n
        if start &lt; 0:
            start = 0

    return (start, end)

</t>
<t tx="ekr.20230509052845.2761">def _split_whitespace(self, maxcount: int) -&gt; List[str]:
    PREALLOC_MAX = 12
    l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

    str_len = len(self)
    i = 0
    j = 0
    while maxcount &gt; 0:
        maxcount -= 1
        while i &lt; str_len and str._isspace(self.ptr[i]):
            i += 1
        if i == str_len:
            break
        j = i
        i += 1
        while i &lt; str_len and not str._isspace(self.ptr[i]):
            i += 1
        l.append(self._slice(j, i))

    if i &lt; str_len:
        while i &lt; str_len and str._isspace(self.ptr[i]):
            i += 1
        if i != str_len:
            l.append(self._slice(i, str_len))

    return l

</t>
<t tx="ekr.20230509052845.2762">def _rsplit_whitespace(self, maxcount: int) -&gt; List[str]:
    PREALLOC_MAX = 12
    l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

    str_len = len(self)
    i = str_len - 1
    j = str_len - 1
    while maxcount &gt; 0:
        maxcount -= 1
        while i &gt;= 0 and str._isspace(self.ptr[i]):
            i -= 1
        if i &lt; 0:
            break
        j = i
        i -= 1
        while i &gt;= 0 and not str._isspace(self.ptr[i]):
            i -= 1
        l.append(self._slice(i + 1, j + 1))

    if i &gt;= 0:
        while i &gt;= 0 and str._isspace(self.ptr[i]):
            i -= 1
        if i &gt;= 0:
            l.append(self._slice(0, i + 1))

    l.reverse()
    return l

</t>
<t tx="ekr.20230509052845.2763">def _split_char(self, char: byte, maxcount: int) -&gt; List[str]:
    PREALLOC_MAX = 12
    l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

    str_len = len(self)
    i = 0
    j = 0

    while i &lt; str_len and maxcount &gt; 0:
        if self.ptr[i] == char:
            l.append(self._slice(j, i))
            j = i + 1
            maxcount -= 1
        i += 1

    l.append(self._slice(j, str_len))
    return l

</t>
<t tx="ekr.20230509052845.2764">def _rsplit_char(self, char: byte, maxcount: int) -&gt; List[str]:
    PREALLOC_MAX = 12
    l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

    str_len = len(self)
    i = str_len - 1
    j = str_len - 1

    while i &gt;= 0 and maxcount &gt; 0:
        if self.ptr[i] == char:
            l.append(self._slice(i + 1, j + 1))
            j = i - 1
            maxcount -= 1
        i -= 1

    l.append(self._slice(0, j + 1))
    l.reverse()
    return l

</t>
<t tx="ekr.20230509052845.2765">def _findchar(self, c: byte):
    return _C.memchr(self.ptr, i32(int(c)), len(self))

</t>
<t tx="ekr.20230509052845.2766">def _countchar(self, c: byte, maxcount: int):
    count = 0
    start = self.ptr
    end = start + len(self)

    while True:
        start = str(start, end - start)._findchar(c)
        if not start:
            break
        count += 1
        if count &gt;= maxcount:
            break
        start += 1
    return count

</t>
<t tx="ekr.20230509052845.2767">def _replace_interleave(self, to: str, maxcount: int):
    self_s = self.ptr
    self_len = len(self)
    to_len = len(to)
    to_s = to.ptr
    count = 0
    i = 0

    if maxcount &lt;= self_len:
        count = maxcount
    else:
        count = self_len + 1

    # assert count &gt; 0
    if to_len &gt; (_MAX - self_len) // count:
        raise OverflowError("replace bytes is too long")

    result_len = count * to_len + self_len
    result_s = Ptr[byte](result_len)
    result_s0 = result_s

    if to_len &gt; 1:
        str.memcpy(result_s, to_s, to_len)
        result_s += to_len
        count -= 1

        while i &lt; count:
            result_s[0] = self_s[0]
            result_s += 1
            self_s += 1
            str.memcpy(result_s, to_s, to_len)
            result_s += to_len
            i += 1
    else:
        result_s[0] = to_s[0]
        result_s += to_len
        count -= 1

        while i &lt; count:
            result_s[0] = self_s[0]
            result_s += 1
            self_s += 1
            result_s[0] = to_s[0]
            result_s += to_len
            i += 1

    str.memcpy(result_s, self_s, self_len - i)
    return str(result_s0, result_len)

</t>
<t tx="ekr.20230509052845.2768">def _replace_delete_single_character(self, from_c: byte, maxcount: int):
    self_len = len(self)
    self_s = self.ptr

    count = self._countchar(from_c, maxcount)
    if count == 0:
        return self

    result_len = self_len - count
    # assert result_len &gt;= 0
    result_s = Ptr[byte](result_len)
    result_s0 = result_s

    start = self_s
    end = self_s + self_len
    while count &gt; 0:
        count -= 1
        nxt = str(start, end - start)._findchar(from_c)
        if not nxt:
            break
        str.memcpy(result_s, start, nxt - start)
        result_s += nxt - start
        start = nxt + 1

    str.memcpy(result_s, start, end - start)
    return str(result_s0, result_len)

</t>
<t tx="ekr.20230509052845.2769">def _replace_delete_substring(self, from_s: str, maxcount: int):
    self_len = len(self)
    self_s = self.ptr
    from_len = len(from_s)

    count = algorithms.count_with_max(self, from_s, maxcount)
    if count == 0:
        return self

    result_len = self_len - (count * from_len)
    # assert result_len &gt;= 0
    result_s = Ptr[byte](result_len)
    result_s0 = result_s

    start = self_s
    end = self_s + self_len
    while count &gt; 0:
        count -= 1
        offset = algorithms.find(str(start, end - start), from_s)
        if offset == -1:
            break
        nxt = start + offset
        str.memcpy(result_s, start, nxt - start)
        result_s += nxt - start
        start = nxt + from_len

    str.memcpy(result_s, start, end - start)
    return str(result_s0, result_len)

</t>
<t tx="ekr.20230509052845.277">/// Instr representing a Python yield expression.
class YieldInInstr : public AcceptorExtend&lt;YieldInInstr, Instr&gt; {
private:
  /// the type of the value being yielded in.
  types::Type *type;
  /// whether or not to suspend
  bool suspend;

public:
  static const char NodeId;

  /// Constructs a yield in instruction.
  /// @param type the type of the value being yielded in
  /// @param suspend whether to suspend
  /// @param name the instruction's name
  explicit YieldInInstr(types::Type *type, bool suspend = true, std::string name = "")
      : AcceptorExtend(std::move(name)), type(type), suspend(suspend) {}

  /// @return true if the instruction suspends
  bool isSuspending() const { return suspend; }
  /// Sets the instruction suspending flag.
  /// @param v the new value
  void setSuspending(bool v = true) { suspend = v; }

  /// Sets the type being inspected
  /// @param t the new type
  void setType(types::Type *t) { type = t; }

protected:
  types::Type *doGetType() const override { return type; }
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {type}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509052845.2770">def _replace_single_character_in_place(self, from_c: byte, to_c: byte, maxcount: int):
    self_s = self.ptr
    self_len = len(self)

    nxt = self._findchar(from_c)
    if not nxt:
        return self

    result_s = Ptr[byte](self_len)
    str.memcpy(result_s, self_s, self_len)

    start = result_s + (nxt - self_s)
    start[0] = to_c
    start += 1
    end = result_s + self_len
    maxcount -= 1

    while maxcount &gt; 0:
        maxcount -= 1
        nxt = str(start, end - start)._findchar(from_c)
        if not nxt:
            break
        nxt[0] = to_c
        start = nxt + 1

    return str(result_s, self_len)

</t>
<t tx="ekr.20230509052845.2771">def _replace_substring_in_place(self, from_s: str, to: str, maxcount: int):
    self_s = self.ptr
    self_len = len(self)
    from_len = len(from_s)
    to_s = to.ptr

    offset = algorithms.find(self, from_s)
    if offset == -1:
        return self

    result_s = Ptr[byte](self_len)
    str.memcpy(result_s, self_s, self_len)

    start = result_s + offset
    str.memcpy(start, to_s, from_len)
    start += from_len
    end = result_s + self_len
    maxcount -= 1

    while maxcount &gt; 0:
        maxcount -= 1
        offset = algorithms.find(str(start, end - start), from_s)
        if offset == -1:
            break
        str.memcpy(start + offset, to_s, from_len)
        start += offset + from_len

    return str(result_s, self_len)

</t>
<t tx="ekr.20230509052845.2772">def _replace_single_character(self, from_c: byte, to_s: str, maxcount: int):
    self_s = self.ptr
    self_len = len(self)
    to_len = len(to_s)

    count = self._countchar(from_c, maxcount)
    if count == 0:
        return self

    # assert count &gt; 0
    if to_len - 1 &gt; (_MAX - self_len) // count:
        raise OverflowError("replace bytes is too long")

    result_len = self_len + count * (to_len - 1)
    result_s = Ptr[byte](result_len)
    result_s0 = result_s

    start = self_s
    end = self_s + self_len
    while count &gt; 0:
        count -= 1
        nxt = str(start, end - start)._findchar(from_c)
        if not nxt:
            break

        if nxt == start:
            str.memcpy(result_s, to_s.ptr, to_len)
            result_s += to_len
            start += 1
        else:
            str.memcpy(result_s, start, nxt - start)
            result_s += (nxt - start)
            str.memcpy(result_s, to_s.ptr, to_len)
            result_s += to_len
            start = nxt + 1

    str.memcpy(result_s, start, end - start)
    return str(result_s0, result_len)

</t>
<t tx="ekr.20230509052845.2773">def _replace_substring(self, from_s: str, to_s: str, maxcount: int):
    self_s = self.ptr
    self_len = len(self)
    from_len = len(from_s)
    to_len = len(to_s)

    count = algorithms.count_with_max(self, from_s, maxcount)
    if count == 0:
        return self

    # assert count &gt; 0
    if to_len - from_len &gt; (_MAX - self_len) // count:
        raise OverflowError("replace bytes is too long")

    result_len = self_len + count * (to_len - from_len)
    result_s = Ptr[byte](result_len)
    result_s0 = result_s

    start = self_s
    end = self_s + self_len
    while count &gt; 0:
        count -= 1
        offset = algorithms.find(str(start, end - start), from_s)
        if offset == -1:
            break

        nxt = start + offset
        if nxt == start:
            str.memcpy(result_s, to_s.ptr, to_len)
            result_s += to_len
            start += from_len
        else:
            str.memcpy(result_s, start, nxt - start)
            result_s += (nxt - start)
            str.memcpy(result_s, to_s.ptr, to_len)
            result_s += to_len
            start = nxt + from_len

    str.memcpy(result_s, start, end - start)
    return str(result_s0, result_len)

</t>
<t tx="ekr.20230509052845.2774">def _replace(self, from_s: str, to_s: str, maxcount: int):
    self_len = len(self)
    from_len = len(from_s)
    to_len = len(to_s)

    if self_len &lt; from_len:
        return self

    if maxcount &lt; 0:
        maxcount = _MAX
    elif maxcount == 0:
        return self

    if from_len == 0:
        if to_len == 0:
            return self
        return self._replace_interleave(to_s, maxcount)

    if to_len == 0:
        if from_len == 1:
            return self._replace_delete_single_character(from_s.ptr[0], maxcount)
        return self._replace_delete_substring(from_s, maxcount)

    if from_len == to_len:
        if from_len == 1:
            return self._replace_single_character_in_place(from_s.ptr[0], to_s.ptr[0], maxcount)
        return self._replace_substring_in_place(from_s, to_s, maxcount)

    if from_len == 1:
        return self._replace_single_character(from_s.ptr[0], to_s, maxcount)
    else:
        return self._replace_substring(from_s, to_s, maxcount)
</t>
<t tx="ekr.20230509052845.2775">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Core library

from internal.core import *
from internal.attributes import *
from internal.types.ptr import *
from internal.types.str import *
from internal.types.int import *
from internal.types.bool import *
from internal.types.array import *
from internal.types.error import *
from internal.types.intn import *
from internal.types.float import *
from internal.types.byte import *
from internal.types.generator import *
from internal.types.optional import *
from internal.types.slice import *
from internal.types.range import *
from internal.internal import *
from internal.types.strbuf import strbuf as _strbuf
from internal.types.collections.list import *
import internal.c_stubs as _C
from internal.format import *

@others
from internal.builtin import *

from openmp import Ident as __OMPIdent, for_par
from internal.dlopen import dlsym as _dlsym
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2776">def next(g: Generator[T], default: Optional[T] = None, T: type) -&gt; T:
    if g.done():
        if default:
            return unwrap(default)
        else:
            raise StopIteration()
    return g.next()

</t>
<t tx="ekr.20230509052845.2777">from C import seq_print_full(str, cobj)

</t>
<t tx="ekr.20230509052845.2778">class Set:
    items: List[T]
    T: type

    @others
</t>
<t tx="ekr.20230509052845.2779">def __init__(self):
    self.items = []

</t>
<t tx="ekr.20230509052845.278">/// Instr representing a ternary operator.
class TernaryInstr : public AcceptorExtend&lt;TernaryInstr, Instr&gt; {
private:
  /// the condition
  Value *cond;
  /// the true value
  Value *trueValue;
  /// the false value
  Value *falseValue;

public:
  static const char NodeId;

  /// Constructs a ternary instruction.
  /// @param cond the condition
  /// @param trueValue the true value
  /// @param falseValue the false value
  /// @param name the instruction's name
  TernaryInstr(Value *cond, Value *trueValue, Value *falseValue, std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), trueValue(trueValue),
        falseValue(falseValue) {}

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param v the new value
  void setCond(Value *v) { cond = v; }

  /// @return the condition
  Value *getTrueValue() { return trueValue; }
  /// @return the condition
  const Value *getTrueValue() const { return trueValue; }
  /// Sets the true value.
  /// @param v the new value
  void setTrueValue(Value *v) { trueValue = v; }

  /// @return the false value
  Value *getFalseValue() { return falseValue; }
  /// @return the false value
  const Value *getFalseValue() const { return falseValue; }
  /// Sets the value.
  /// @param v the new value
  void setFalseValue(Value *v) { falseValue = v; }

protected:
  types::Type *doGetType() const override { return trueValue-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return {cond, trueValue, falseValue};
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2780">def __iter__(self) -&gt; Generator[T]:
    yield from self.items

</t>
<t tx="ekr.20230509052845.2781">def add(self, what: T):
    if what not in self.items:
        self.items.append(what)

</t>
<t tx="ekr.20230509052845.2782">def __repr__(self) -&gt; str:
    s = self.items.__repr__()
    s.ptr[0] = "{".ptr[0]
    s.ptr[s.len - 1] = "}".ptr[0]
    return s

</t>
<t tx="ekr.20230509052845.2783">class Dict:
    keys: List[K]
    values: List[V]
    K: type
    V: type

    @others
</t>
<t tx="ekr.20230509052845.2784">def __init__(self):
    self.keys = []
    self.values = []

</t>
<t tx="ekr.20230509052845.2785">def __iter__(self) -&gt; Generator[K]:
    yield from self.keys

</t>
<t tx="ekr.20230509052845.2786">def items(self) -&gt; Generator[Tuple[K, V]]:
    for i in range(self.keys.len):
        yield (self.keys[i], self.values[i])

</t>
<t tx="ekr.20230509052845.2787">def __contains__(self, key: K) -&gt; bool:
    return self.keys.index(key) != -1

</t>
<t tx="ekr.20230509052845.2788">def __getitem__(self, key: K) -&gt; V:
    i = self.keys.index(key)
    return self.values[i]

</t>
<t tx="ekr.20230509052845.2789">def __setitem__(self, key: K, val: V):
    i = self.keys.index(key)
    if i != -1:
        self.values[i] = val
    else:
        self.keys.append(key)
        self.values.append(val)

</t>
<t tx="ekr.20230509052845.279">/// Base for control flow instructions
class ControlFlowInstr : public AcceptorExtend&lt;ControlFlowInstr, Instr&gt; {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509052845.2790">def __len__(self) -&gt; int:
    return self.keys.len

</t>
<t tx="ekr.20230509052845.2791">def __repr__(self) -&gt; str:
    n = self.__len__()
    if n == 0:
        return "{}"
    else:
        lst = []
        lst.append("{")
        first = True
        for k, v in self.items():
            if not first:
                lst.append(", ")
            else:
                first = False
            lst.append(k.__repr__())
            lst.append(": ")
            lst.append(v.__repr__())
        lst.append("}")
        return str.cat(lst)

</t>
<t tx="ekr.20230509052845.2792">@extend
class str:
    @others
</t>
<t tx="ekr.20230509052845.2793">def __getitem__(self, idx: int) -&gt; str:
    if idx &lt; 0:
        idx += self.len
    if not (0 &lt;= idx &lt; self.len):
        raise IndexError("string index out of range")
    return str(self.ptr + idx, 1)

</t>
<t tx="ekr.20230509052845.2794">def __getitem__(self, s: Slice) -&gt; str:
    if s.start is None and s.stop is None and s.step is None:
        return self.__copy__()
    elif s.step is None:
        start, stop, step, length = s.adjust_indices(self.len)
        return str(self.ptr + start, length)
    else:
        raise ValueError("nope")

</t>
<t tx="ekr.20230509052845.2795">def strip(self):
    if self.__len__() == 0:
        return ""

    i = 0
    while i &lt; self.__len__() and _C.isspace(i32(int(self.ptr[i]))):
        i += 1

    j = self.__len__() - 1
    while j &gt;= 0 and _C.isspace(i32(int(self.ptr[j]))):
        j -= 1
    j += 1

    if j &lt;= i:
        return ""

    return str(self.ptr + i, j - i)

</t>
<t tx="ekr.20230509052845.2796">def __repr__(self) -&gt; str:
    return f"'{self}'"

</t>
<t tx="ekr.20230509052845.2797">@path C:/Repos/codon/stdlib/internal/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Core library

from internal.attributes import *
from internal.static import static_print as __static_print__
from internal.types.ptr import *
from internal.types.str import *
from internal.types.int import *
from internal.types.bool import *
from internal.types.array import *
from internal.types.error import *
from internal.types.intn import *
from internal.types.float import *
from internal.types.byte import *
from internal.types.generator import *
from internal.types.optional import *
from internal.types.slice import *
from internal.types.range import *
from internal.types.complex import *
from internal.internal import *

__argv__ = Array[str](0)

from internal.types.strbuf import strbuf as _strbuf
from internal.types.collections.list import *
from internal.types.collections.set import *
from internal.types.collections.dict import *
from internal.types.collections.tuple import *

# Extended core library

import internal.c_stubs as _C
from internal.format import *
from internal.builtin import *
from internal.builtin import _jit_display
from internal.str import *

from internal.sort import sorted

from openmp import Ident as __OMPIdent, for_par
from gpu import _gpu_loop_outline_template
from internal.file import File, gzFile, open, gzopen
from pickle import pickle, unpickle
from internal.dlopen import dlsym as _dlsym
import internal.python

if __py_numerics__:
    import internal.pynumerics
if __py_extension__:
    internal.python.ensure_initialized()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2798"></t>
<t tx="ekr.20230509052845.2799">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import sizeof

@others
array = Array
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.28">def linear_combination(self, other, l1, l2=None):
    if l2 is None:
        l2 = 1 - l1
    v = GVector(self.x * l1 + other.x * l2,
                self.y * l1 + other.y * l2,
                self.z * l1 + other.z * l2)
    return v

</t>
<t tx="ekr.20230509052845.280">/// Instr representing a break statement.
class BreakInstr : public AcceptorExtend&lt;BreakInstr, ControlFlowInstr&gt; {
private:
  /// the loop being broken, nullptr if the immediate ancestor
  Value *loop;

public:
  static const char NodeId;

  /// Constructs a break instruction.
  /// @param loop the loop being broken, nullptr if immediate ancestor
  /// @param name the instruction's name
  explicit BreakInstr(Value *loop = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), loop(loop) {}

  /// @return the loop, nullptr if immediate ancestor
  Value *getLoop() const { return loop; }
  /// Sets the loop id.
  /// @param v the new loop, nullptr if immediate ancestor
  void setLoop(Value *v) { loop = v; }

  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2800">@extend
class Array:
    @others
</t>
<t tx="ekr.20230509052845.2801">def __new__(ptr: Ptr[T], sz: int) -&gt; Array[T]:
    return (sz, ptr)

</t>
<t tx="ekr.20230509052845.2802">def __new__(sz: int) -&gt; Array[T]:
    return (sz, Ptr[T](sz))

</t>
<t tx="ekr.20230509052845.2803">def __copy__(self) -&gt; Array[T]:
    p = Ptr[T](self.len)
    str.memcpy(p.as_byte(), self.ptr.as_byte(), self.len * sizeof(T))
    return (self.len, p)

</t>
<t tx="ekr.20230509052845.2804">def __deepcopy__(self) -&gt; Array[T]:
    p = Ptr[T](self.len)
    i = 0
    while i &lt; self.len:
        p[i] = self.ptr[i].__deepcopy__()
        i += 1
    return (self.len, p)

</t>
<t tx="ekr.20230509052845.2805">def __len__(self) -&gt; int:
    return self.len

</t>
<t tx="ekr.20230509052845.2806">def __bool__(self) -&gt; bool:
    return bool(self.len)

</t>
<t tx="ekr.20230509052845.2807">def __getitem__(self, index: int) -&gt; T:
    return self.ptr[index]

</t>
<t tx="ekr.20230509052845.2808">def __setitem__(self, index: int, what: T):
    self.ptr[index] = what

</t>
<t tx="ekr.20230509052845.2809">def slice(self, s: int, e: int) -&gt; Array[T]:
    return (e - s, self.ptr + s)

</t>
<t tx="ekr.20230509052845.281">/// Instr representing a continue statement.
class ContinueInstr : public AcceptorExtend&lt;ContinueInstr, ControlFlowInstr&gt; {
private:
  /// the loop being continued, nullptr if the immediate ancestor
  Value *loop;

public:
  static const char NodeId;

  /// Constructs a continue instruction.
  /// @param loop the loop being continued, nullptr if immediate ancestor
  /// @param name the instruction's name
  explicit ContinueInstr(Value *loop = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), loop(loop) {}

  /// @return the loop, nullptr if immediate ancestor
  Value *getLoop() const { return loop; }
  /// Sets the loop id.
  /// @param v the new loop, -1 if immediate ancestor
  void setLoop(Value *v) { loop = v; }

  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2810">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2811">@extend
class bool:
    @others
</t>
<t tx="ekr.20230509052845.2812">def __new__() -&gt; bool:
    return False

</t>
<t tx="ekr.20230509052845.2813">def __new__(what) -&gt; bool:
    return what.__bool__()

</t>
<t tx="ekr.20230509052845.2814">def __repr__(self) -&gt; str:
    return "True" if self else "False"

</t>
<t tx="ekr.20230509052845.2815">def __copy__(self) -&gt; bool:
    return self

</t>
<t tx="ekr.20230509052845.2816">def __deepcopy__(self) -&gt; bool:
    return self

</t>
<t tx="ekr.20230509052845.2817">def __bool__(self) -&gt; bool:
    return self

</t>
<t tx="ekr.20230509052845.2818">def __hash__(self) -&gt; int:
    return int(self)

</t>
<t tx="ekr.20230509052845.2819">@pure
@llvm
def __invert__(self) -&gt; bool:
    %0 = trunc i8 %self to i1
    %1 = xor i1 %0, true
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.282">/// Instr representing a return statement.
class ReturnInstr : public AcceptorExtend&lt;ReturnInstr, ControlFlowInstr&gt; {
private:
  /// the value
  Value *value;

public:
  static const char NodeId;

  explicit ReturnInstr(Value *value = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2820">@pure
@llvm
def __eq__(self, other: bool) -&gt; bool:
    %0 = icmp eq i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2821">@pure
@llvm
def __ne__(self, other: bool) -&gt; bool:
    %0 = icmp ne i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2822">@pure
@llvm
def __lt__(self, other: bool) -&gt; bool:
    %0 = icmp ult i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2823">@pure
@llvm
def __gt__(self, other: bool) -&gt; bool:
    %0 = icmp ugt i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2824">@pure
@llvm
def __le__(self, other: bool) -&gt; bool:
    %0 = icmp ule i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2825">@pure
@llvm
def __ge__(self, other: bool) -&gt; bool:
    %0 = icmp uge i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2826">@pure
@commutative
@associative
@llvm
def __and__(self, other: bool) -&gt; bool:
    %0 = and i8 %self, %other
    ret i8 %0

</t>
<t tx="ekr.20230509052845.2827">@pure
@commutative
@associative
@llvm
def __or__(self, other: bool) -&gt; bool:
    %0 = or i8 %self, %other
    ret i8 %0

</t>
<t tx="ekr.20230509052845.2828">@pure
@commutative
@associative
@llvm
def __xor__(self, other: bool) -&gt; bool:
    %0 = xor i8 %self, %other
    ret i8 %0

</t>
<t tx="ekr.20230509052845.2829">@pure
@llvm
def __int__(self) -&gt; int:
    %0 = zext i8 %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.283">class YieldInstr : public AcceptorExtend&lt;YieldInstr, Instr&gt; {
private:
  /// the value
  Value *value;
  /// whether this yield is final
  bool final;

public:
  static const char NodeId;

  explicit YieldInstr(Value *value = nullptr, bool final = false, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value), final(final) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

  /// @return if this yield is final
  bool isFinal() const { return final; }
  /// Sets whether this yield is final.
  /// @param f true if final
  void setFinal(bool f = true) { final = f; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2830">@pure
@llvm
def __float__(self) -&gt; float:
    %0 = uitofp i8 %self to double
    ret double %0
</t>
<t tx="ekr.20230509052845.2831">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2832">@extend
class byte:
    @others
</t>
<t tx="ekr.20230509052845.2833">@pure
@llvm
def __new__() -&gt; byte:
    ret i8 0

</t>
<t tx="ekr.20230509052845.2834">def __new__(b: byte) -&gt; byte:
    return b

</t>
<t tx="ekr.20230509052845.2835">def __new__(s: str) -&gt; byte:
    if s.__len__() != 1:
        raise ValueError("str length must be 1 in byte constructor")
    return s.ptr[0]

</t>
<t tx="ekr.20230509052845.2836">@pure
@llvm
def __new__(i: int) -&gt; byte:
    %0 = trunc i64 %i to i8
    ret i8 %0

</t>
<t tx="ekr.20230509052845.2837">def __copy__(self) -&gt; byte:
    return self

</t>
<t tx="ekr.20230509052845.2838">def __deepcopy__(self) -&gt; byte:
    return self

</t>
<t tx="ekr.20230509052845.2839">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = icmp ne i8 %self, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.284">class ThrowInstr : public AcceptorExtend&lt;ThrowInstr, Instr&gt; {
private:
  /// the value
  Value *value;

public:
  static const char NodeId;

  explicit ThrowInstr(Value *value = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2840">@pure
@llvm
def __eq__(self, other: byte) -&gt; bool:
    %0 = icmp eq i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2841">def __eq__(self, other: int) -&gt; bool:
    return self == byte(other)

</t>
<t tx="ekr.20230509052845.2842">@pure
@llvm
def __ne__(self, other: byte) -&gt; bool:
    %0 = icmp ne i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2843">@pure
@llvm
def __lt__(self, other: byte) -&gt; bool:
    %0 = icmp ult i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2844">@pure
@llvm
def __gt__(self, other: byte) -&gt; bool:
    %0 = icmp ugt i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2845">@pure
@llvm
def __le__(self, other: byte) -&gt; bool:
    %0 = icmp ule i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2846">@pure
@llvm
def __ge__(self, other: byte) -&gt; bool:
    %0 = icmp uge i8 %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2847">def __str__(self) -&gt; str:
    p = Ptr[byte](1)
    p[0] = self
    return str(p, 1)

</t>
<t tx="ekr.20230509052845.2848">def __repr__(self) -&gt; str:
    return f"byte({str(__ptr__(self), 1).__repr__()})"

</t>
<t tx="ekr.20230509052845.2849">@pure
@llvm
def __int__(self) -&gt; int:
    %0 = zext i8 %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.285">/// Instr that contains a flow and value.
class FlowInstr : public AcceptorExtend&lt;FlowInstr, Instr&gt; {
private:
  /// the flow
  Value *flow;
  /// the output value
  Value *val;

public:
  static const char NodeId;

  /// Constructs a flow value.
  /// @param flow the flow
  /// @param val the output value
  /// @param name the name
  explicit FlowInstr(Flow *flow, Value *val, std::string name = "")
      : AcceptorExtend(std::move(name)), flow(flow), val(val) {}

  /// @return the flow
  Flow *getFlow() { return cast&lt;Flow&gt;(flow); }
  /// @return the flow
  const Flow *getFlow() const { return cast&lt;Flow&gt;(flow); }
  /// Sets the flow.
  /// @param f the new flow
  void setFlow(Flow *f) { flow = f; }

  /// @return the value
  Value *getValue() { return val; }
  /// @return the value
  const Value *getValue() const { return val; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { val = v; }

protected:
  types::Type *doGetType() const override { return val-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {flow, val}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.2850">@pure
@llvm
def __float__(self) -&gt; float:
    %0 = uitofp i8 %self to double
    ret double %0
</t>
<t tx="ekr.20230509052845.2851">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2852">@tuple
class complex64:
    real: float32
    imag: float32

</t>
<t tx="ekr.20230509052845.2853">@tuple
class complex:
    real: float
    imag: float

    @others
</t>
<t tx="ekr.20230509052845.2854">def __new__() -&gt; complex:
    return (0.0, 0.0)

</t>
<t tx="ekr.20230509052845.2855">def __new__(other):
    return other.__complex__()

</t>
<t tx="ekr.20230509052845.2856">def __new__(real, imag) -&gt; complex:
    return (float(real), float(imag))

</t>
<t tx="ekr.20230509052845.2857">def __complex__(self) -&gt; complex:
    return self

</t>
<t tx="ekr.20230509052845.2858">def __bool__(self) -&gt; bool:
    return self.real != 0.0 and self.imag != 0.0

</t>
<t tx="ekr.20230509052845.2859">def __pos__(self) -&gt; complex:
    return self

</t>
<t tx="ekr.20230509052845.286">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iterator&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

#include "codon/cir/func.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {

namespace ast {
struct Cache;
class TranslateVisitor;
class TypecheckVisitor;
} // namespace ast

namespace ir {

@others
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Module&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2860">def __neg__(self) -&gt; complex:
    return complex(-self.real, -self.imag)

</t>
<t tx="ekr.20230509052845.2861">def __abs__(self) -&gt; float:
    @pure
    @C
    def hypot(a: float, b: float) -&gt; float:
        pass

    return hypot(self.real, self.imag)

</t>
<t tx="ekr.20230509052845.2862">def __copy__(self) -&gt; complex:
    return self

</t>
<t tx="ekr.20230509052845.2863">def __hash__(self) -&gt; int:
    return self.real.__hash__() + self.imag.__hash__() * 1000003

</t>
<t tx="ekr.20230509052845.2864">def __add__(self, other) -&gt; complex:
    return self + complex(other)

</t>
<t tx="ekr.20230509052845.2865">def __sub__(self, other) -&gt; complex:
    return self - complex(other)

</t>
<t tx="ekr.20230509052845.2866">def __mul__(self, other) -&gt; complex:
    return self * complex(other)

</t>
<t tx="ekr.20230509052845.2867">def __truediv__(self, other) -&gt; complex:
    return self / complex(other)

</t>
<t tx="ekr.20230509052845.2868">def __eq__(self, other) -&gt; bool:
    return self == complex(other)

</t>
<t tx="ekr.20230509052845.2869">def __ne__(self, other) -&gt; bool:
    return self != complex(other)

</t>
<t tx="ekr.20230509052845.287">/// CIR object representing a program.
class Module : public AcceptorExtend&lt;Module, Node&gt; {
public:
  static const std::string VOID_NAME;
  static const std::string BOOL_NAME;
  static const std::string BYTE_NAME;
  static const std::string INT_NAME;
  static const std::string FLOAT_NAME;
  static const std::string FLOAT32_NAME;
  static const std::string STRING_NAME;

  static const std::string EQ_MAGIC_NAME;
  static const std::string NE_MAGIC_NAME;
  static const std::string LT_MAGIC_NAME;
  static const std::string GT_MAGIC_NAME;
  static const std::string LE_MAGIC_NAME;
  static const std::string GE_MAGIC_NAME;

  static const std::string POS_MAGIC_NAME;
  static const std::string NEG_MAGIC_NAME;
  static const std::string INVERT_MAGIC_NAME;

  static const std::string ADD_MAGIC_NAME;
  static const std::string SUB_MAGIC_NAME;
  static const std::string MUL_MAGIC_NAME;
  static const std::string MATMUL_MAGIC_NAME;
  static const std::string TRUE_DIV_MAGIC_NAME;
  static const std::string FLOOR_DIV_MAGIC_NAME;
  static const std::string MOD_MAGIC_NAME;
  static const std::string POW_MAGIC_NAME;
  static const std::string LSHIFT_MAGIC_NAME;
  static const std::string RSHIFT_MAGIC_NAME;
  static const std::string AND_MAGIC_NAME;
  static const std::string OR_MAGIC_NAME;
  static const std::string XOR_MAGIC_NAME;

  static const std::string IADD_MAGIC_NAME;
  static const std::string ISUB_MAGIC_NAME;
  static const std::string IMUL_MAGIC_NAME;
  static const std::string IMATMUL_MAGIC_NAME;
  static const std::string ITRUE_DIV_MAGIC_NAME;
  static const std::string IFLOOR_DIV_MAGIC_NAME;
  static const std::string IMOD_MAGIC_NAME;
  static const std::string IPOW_MAGIC_NAME;
  static const std::string ILSHIFT_MAGIC_NAME;
  static const std::string IRSHIFT_MAGIC_NAME;
  static const std::string IAND_MAGIC_NAME;
  static const std::string IOR_MAGIC_NAME;
  static const std::string IXOR_MAGIC_NAME;

  static const std::string RADD_MAGIC_NAME;
  static const std::string RSUB_MAGIC_NAME;
  static const std::string RMUL_MAGIC_NAME;
  static const std::string RMATMUL_MAGIC_NAME;
  static const std::string RTRUE_DIV_MAGIC_NAME;
  static const std::string RFLOOR_DIV_MAGIC_NAME;
  static const std::string RMOD_MAGIC_NAME;
  static const std::string RPOW_MAGIC_NAME;
  static const std::string RLSHIFT_MAGIC_NAME;
  static const std::string RRSHIFT_MAGIC_NAME;
  static const std::string RAND_MAGIC_NAME;
  static const std::string ROR_MAGIC_NAME;
  static const std::string RXOR_MAGIC_NAME;

  static const std::string INT_MAGIC_NAME;
  static const std::string FLOAT_MAGIC_NAME;
  static const std::string BOOL_MAGIC_NAME;
  static const std::string STR_MAGIC_NAME;
  static const std::string REPR_MAGIC_NAME;

  static const std::string GETITEM_MAGIC_NAME;
  static const std::string SETITEM_MAGIC_NAME;
  static const std::string ITER_MAGIC_NAME;
  static const std::string LEN_MAGIC_NAME;

  static const std::string NEW_MAGIC_NAME;
  static const std::string INIT_MAGIC_NAME;

private:
  /// the module's "main" function
  std::unique_ptr&lt;Func&gt; mainFunc;
  /// the module's argv variable
  std::unique_ptr&lt;Var&gt; argVar;
  /// the global variables list
  std::list&lt;std::unique_ptr&lt;Var&gt;&gt; vars;
  /// the global variables map
  std::unordered_map&lt;id_t, std::list&lt;std::unique_ptr&lt;Var&gt;&gt;::iterator&gt; varMap;
  /// the global value list
  std::list&lt;std::unique_ptr&lt;Value&gt;&gt; values;
  /// the global value map
  std::unordered_map&lt;id_t, std::list&lt;std::unique_ptr&lt;Value&gt;&gt;::iterator&gt; valueMap;
  /// the global types list
  std::list&lt;std::unique_ptr&lt;types::Type&gt;&gt; types;
  /// the global types map
  std::unordered_map&lt;std::string, std::list&lt;std::unique_ptr&lt;types::Type&gt;&gt;::iterator&gt;
      typesMap;

  /// the type-checker cache
  ast::Cache *cache = nullptr;

public:
  static const char NodeId;

  /// Constructs an CIR module.
  /// @param name the module name
  explicit Module(const std::string &amp;name = "");

  virtual ~Module() noexcept = default;

  /// @return the main function
  Func *getMainFunc() { return mainFunc.get(); }
  /// @return the main function
  const Func *getMainFunc() const { return mainFunc.get(); }

  /// @return the arg var
  Var *getArgVar() { return argVar.get(); }
  /// @return the arg var
  const Var *getArgVar() const { return argVar.get(); }

  /// @return iterator to the first symbol
  auto begin() { return util::raw_ptr_adaptor(vars.begin()); }
  /// @return iterator beyond the last symbol
  auto end() { return util::raw_ptr_adaptor(vars.end()); }
  /// @return iterator to the first symbol
  auto begin() const { return util::const_raw_ptr_adaptor(vars.begin()); }
  /// @return iterator beyond the last symbol
  auto end() const { return util::const_raw_ptr_adaptor(vars.end()); }
  /// @return a pointer to the first symbol
  Var *front() { return vars.front().get(); }
  /// @return a pointer to the last symbol
  Var *back() { return vars.back().get(); }
  /// @return a pointer to the first symbol
  const Var *front() const { return vars.front().get(); }
  /// @return a pointer to the last symbol
  const Var *back() const { return vars.back().get(); }
  /// Gets a var by id.
  /// @param id the id
  /// @return the variable or nullptr
  Var *getVar(id_t id) {
    auto it = varMap.find(id);
    return it != varMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
@others
};

</t>
<t tx="ekr.20230509052845.2870">def __pow__(self, other) -&gt; complex:
    return self ** complex(other)

</t>
<t tx="ekr.20230509052845.2871">def __radd__(self, other) -&gt; complex:
    return complex(other) + self

</t>
<t tx="ekr.20230509052845.2872">def __rsub__(self, other) -&gt; complex:
    return complex(other) - self

</t>
<t tx="ekr.20230509052845.2873">def __rmul__(self, other) -&gt; complex:
    return complex(other) * self

</t>
<t tx="ekr.20230509052845.2874">def __rtruediv__(self, other) -&gt; complex:
    return complex(other) / self

</t>
<t tx="ekr.20230509052845.2875">def __rpow__(self, other) -&gt; complex:
    return complex(other) ** self

</t>
<t tx="ekr.20230509052845.2876">def __add__(self, other: complex) -&gt; complex:
    return complex(self.real + other.real, self.imag + other.imag)

</t>
<t tx="ekr.20230509052845.2877">def __sub__(self, other: complex) -&gt; complex:
    return complex(self.real - other.real, self.imag - other.imag)

</t>
<t tx="ekr.20230509052845.2878">def __mul__(self, other: complex) -&gt; complex:
    a = (self.real * other.real) - (self.imag * other.imag)
    b = (self.real * other.imag) + (self.imag * other.real)
    return complex(a, b)

</t>
<t tx="ekr.20230509052845.2879">def __truediv__(self, other: complex) -&gt; complex:
    a = self
    b = other
    abs_breal = (-b.real) if b.real &lt; 0 else b.real
    abs_bimag = (-b.imag) if b.imag &lt; 0 else b.imag

    if abs_breal &gt;= abs_bimag:
        # divide tops and bottom by b.real
        if abs_breal == 0.0:
            # errno = EDOM
            return complex(0.0, 0.0)
        else:
            ratio = b.imag / b.real
            denom = b.real + b.imag * ratio
            return complex(
                (a.real + a.imag * ratio) / denom, (a.imag - a.real * ratio) / denom
            )
    elif abs_bimag &gt;= abs_breal:
        # divide tops and bottom by b.imag
        ratio = b.real / b.imag
        denom = b.real * ratio + b.imag
        # assert b.imag != 0.0
        return complex(
            (a.real * ratio + a.imag) / denom, (a.imag * ratio - a.real) / denom
        )
    else:
        nan = 0.0 / 0.0
        return complex(nan, nan)

</t>
<t tx="ekr.20230509052845.288">  /// Gets a var by id.
  /// @param id the id
  /// @return the variable or nullptr
  const Var *getVar(id_t id) const {
    auto it = varMap.find(id);
    return it != varMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509052845.2880">def __eq__(self, other: complex) -&gt; bool:
    return self.real == other.real and self.imag == other.imag

</t>
<t tx="ekr.20230509052845.2881">def __ne__(self, other: complex) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.2882">def __pow__(self, other: int) -&gt; complex:
    def powu(x: complex, n: int) -&gt; complex:
        mask = 1
        r = complex(1.0, 0.0)
        p = x
        while mask &gt; 0 and n &gt;= mask:
            if n &amp; mask:
                r = r * p
            mask &lt;&lt;= 1
            p = p * p
        return r

    if other &gt; 0:
        return powu(self, other)
    else:
        return complex(1.0, 0.0) / powu(self, -other)

</t>
<t tx="ekr.20230509052845.2883">def __pow__(self, other: complex) -&gt; complex:
    @pure
    @C
    def hypot(a: float, b: float) -&gt; float:
        pass

    @pure
    @C
    def atan2(a: float, b: float) -&gt; float:
        pass

    @pure
    @llvm
    def exp(x: float) -&gt; float:
        declare double @llvm.exp.f64(double)
        %y = call double @llvm.exp.f64(double %x)
        ret double %y

    @pure
    @llvm
    def pow(x: float, y: float) -&gt; float:
        declare double @llvm.pow.f64(double, double)
        %z = call double @llvm.pow.f64(double %x, double %y)
        ret double %z

    @pure
    @llvm
    def log(x: float) -&gt; float:
        declare double @llvm.log.f64(double)
        %y = call double @llvm.log.f64(double %x)
        ret double %y

    @pure
    @llvm
    def sin(x: float) -&gt; float:
        declare double @llvm.sin.f64(double)
        %y = call double @llvm.sin.f64(double %x)
        ret double %y

    @pure
    @llvm
    def cos(x: float) -&gt; float:
        declare double @llvm.cos.f64(double)
        %y = call double @llvm.cos.f64(double %x)
        ret double %y

    if other.real == 0.0 and other.imag == 0.0:
        return complex(1.0, 0.0)
    elif self.real == 0.0 and self.imag == 0.0:
        # if other.imag != 0. or other.real &lt; 0.: errno = EDOM
        return complex(0.0, 0.0)
    else:
        vabs = hypot(self.real, self.imag)
        len = pow(vabs, other.real)
        at = atan2(self.imag, self.real)
        phase = at * other.real
        if other.imag != 0.0:
            len /= exp(at * other.imag)
            phase += other.imag * log(vabs)
        return complex(len * cos(phase), len * sin(phase))

</t>
<t tx="ekr.20230509052845.2884">def __repr__(self) -&gt; str:
    @pure
    @llvm
    def copysign(x: float, y: float) -&gt; float:
        declare double @llvm.copysign.f64(double, double)
        %z = call double @llvm.copysign.f64(double %x, double %y)
        ret double %z

    @pure
    @llvm
    def fabs(x: float) -&gt; float:
        declare double @llvm.fabs.f64(double)
        %y = call double @llvm.fabs.f64(double %x)
        ret double %y

    if self.real == 0.0 and copysign(1.0, self.real) == 1.0:
        return f"{self.imag}j"
    else:
        sign = "+"
        if self.imag &lt; 0.0 or (
            self.imag == 0.0 and copysign(1.0, self.imag) == -1.0
        ):
            sign = "-"
        return f"({self.real}{sign}{fabs(self.imag)}j)"

</t>
<t tx="ekr.20230509052845.2885">def conjugate(self) -&gt; complex:
    return complex(self.real, -self.imag)

</t>
<t tx="ekr.20230509052845.2886"># helpers
def _phase(self) -&gt; float:
    @pure
    @C
    def atan2(a: float, b: float) -&gt; float:
        pass

    return atan2(self.imag, self.real)

</t>
<t tx="ekr.20230509052845.2887">def _polar(self) -&gt; Tuple[float, float]:
    return (self.__abs__(), self._phase())

</t>
<t tx="ekr.20230509052845.2888">@pure
@llvm
def _exp(x: float) -&gt; float:
    declare double @llvm.exp.f64(double)
    %y = call double @llvm.exp.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.2889">@pure
@llvm
def _sqrt(x: float) -&gt; float:
    declare double @llvm.sqrt.f64(double)
    %y = call double @llvm.sqrt.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.289">  /// Removes a given var.
  /// @param v the var
  void remove(const Var *v) {
    auto it = varMap.find(v-&gt;getId());
    vars.erase(it-&gt;second);
    varMap.erase(it);
  }

</t>
<t tx="ekr.20230509052845.2890">@pure
@llvm
def _cos(x: float) -&gt; float:
    declare double @llvm.cos.f64(double)
    %y = call double @llvm.cos.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.2891">@pure
@llvm
def _sin(x: float) -&gt; float:
    declare double @llvm.sin.f64(double)
    %y = call double @llvm.sin.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.2892">@pure
@llvm
def _log(x: float) -&gt; float:
    declare double @llvm.log.f64(double)
    %y = call double @llvm.log.f64(double %x)
    ret double %y

</t>
<t tx="ekr.20230509052845.2893">@extend
class int:
    def __suffix_j__(x: int) -&gt; complex:
        return complex(0, x)

</t>
<t tx="ekr.20230509052845.2894">@extend
class float:
    def __suffix_j__(x: float) -&gt; complex:
        return complex(0, x)

</t>
<t tx="ekr.20230509052845.2895">f32 = float32

</t>
<t tx="ekr.20230509052845.2896">@extend
class complex64:
    @others
</t>
<t tx="ekr.20230509052845.2897">def __new__() -&gt; complex64:
    return (f32(0.0), f32(0.0))

</t>
<t tx="ekr.20230509052845.2898">def __new__(other):
    return complex64(other.__complex__())

</t>
<t tx="ekr.20230509052845.2899">def __new__(other: complex) -&gt; complex64:
    return (f32(other.real), f32(other.imag))

</t>
<t tx="ekr.20230509052845.29">class Spline(object):
    """Class for representing B-Splines and NURBS of arbitrary degree"""
    knots: List[int]
    degree: int
    points: List[GVector]

    @others
    #def __repr__(self):
    #    return "Spline(%r, %r, %r)" % (self.points, self.degree, self.knots)


</t>
<t tx="ekr.20230509052845.290">  /// @return iterator to the first value
  auto values_begin() { return util::raw_ptr_adaptor(values.begin()); }
  /// @return iterator beyond the last value
  auto values_end() { return util::raw_ptr_adaptor(values.end()); }
  /// @return iterator to the first value
  auto values_begin() const { return util::const_raw_ptr_adaptor(values.begin()); }
  /// @return iterator beyond the last value
  auto values_end() const { return util::const_raw_ptr_adaptor(values.end()); }
  /// @return a pointer to the first value
  Value *values_front() { return values.front().get(); }
  /// @return a pointer to the last value
  Value *values_back() { return values.back().get(); }
  /// @return a pointer to the first value
  const Value *values_front() const { return values.front().get(); }
  /// @return a pointer to the last value
  const Value *values_back() const { return values.back().get(); }
  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  Value *getValue(id_t id) {
    auto it = valueMap.find(id);
    return it != valueMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509052845.2900">def __new__(real, imag) -&gt; complex64:
    return (f32(float(real)), f32(float(imag)))

</t>
<t tx="ekr.20230509052845.2901">def __complex__(self) -&gt; complex:
    return complex(float(self.real), float(self.imag))

</t>
<t tx="ekr.20230509052845.2902">def __bool__(self) -&gt; bool:
    return self.real != f32(0.0) and self.imag != f32(0.0)

</t>
<t tx="ekr.20230509052845.2903">def __pos__(self) -&gt; complex64:
    return self

</t>
<t tx="ekr.20230509052845.2904">def __neg__(self) -&gt; complex64:
    return complex64(-self.real, -self.imag)

</t>
<t tx="ekr.20230509052845.2905">def __abs__(self) -&gt; f32:
    @pure
    @C
    def hypotf(a: f32, b: f32) -&gt; f32:
        pass

    return hypotf(self.real, self.imag)

</t>
<t tx="ekr.20230509052845.2906">def __copy__(self) -&gt; complex64:
    return self

</t>
<t tx="ekr.20230509052845.2907">def __hash__(self) -&gt; int:
    return self.real.__hash__() + self.imag.__hash__() * 1000003

</t>
<t tx="ekr.20230509052845.2908">def __add__(self, other) -&gt; complex64:
    return self + complex64(other)

</t>
<t tx="ekr.20230509052845.2909">def __sub__(self, other) -&gt; complex64:
    return self - complex64(other)

</t>
<t tx="ekr.20230509052845.291">  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  const Value *getValue(id_t id) const {
    auto it = valueMap.find(id);
    return it != valueMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509052845.2910">def __mul__(self, other) -&gt; complex64:
    return self * complex64(other)

</t>
<t tx="ekr.20230509052845.2911">def __truediv__(self, other) -&gt; complex64:
    return self / complex64(other)

</t>
<t tx="ekr.20230509052845.2912">def __eq__(self, other) -&gt; bool:
    return self == complex64(other)

</t>
<t tx="ekr.20230509052845.2913">def __ne__(self, other) -&gt; bool:
    return self != complex64(other)

</t>
<t tx="ekr.20230509052845.2914">def __pow__(self, other) -&gt; complex64:
    return self ** complex64(other)

</t>
<t tx="ekr.20230509052845.2915">def __radd__(self, other) -&gt; complex64:
    return complex64(other) + self

</t>
<t tx="ekr.20230509052845.2916">def __rsub__(self, other) -&gt; complex64:
    return complex64(other) - self

</t>
<t tx="ekr.20230509052845.2917">def __rmul__(self, other) -&gt; complex64:
    return complex64(other) * self

</t>
<t tx="ekr.20230509052845.2918">def __rtruediv__(self, other) -&gt; complex64:
    return complex64(other) / self

</t>
<t tx="ekr.20230509052845.2919">def __rpow__(self, other) -&gt; complex64:
    return complex64(other) ** self

</t>
<t tx="ekr.20230509052845.292">  /// Removes a given value.
  /// @param v the value
  void remove(const Value *v) {
    auto it = valueMap.find(v-&gt;getId());
    values.erase(it-&gt;second);
    valueMap.erase(it);
  }

</t>
<t tx="ekr.20230509052845.2920">def __add__(self, other: complex64) -&gt; complex64:
    return complex64(self.real + other.real, self.imag + other.imag)

</t>
<t tx="ekr.20230509052845.2921">def __sub__(self, other: complex64) -&gt; complex64:
    return complex64(self.real - other.real, self.imag - other.imag)

</t>
<t tx="ekr.20230509052845.2922">def __mul__(self, other: complex64) -&gt; complex64:
    a = (self.real * other.real) - (self.imag * other.imag)
    b = (self.real * other.imag) + (self.imag * other.real)
    return complex64(a, b)

</t>
<t tx="ekr.20230509052845.2923">def __truediv__(self, other: complex64) -&gt; complex64:
    a = self
    b = other
    abs_breal = (-b.real) if b.real &lt; f32(0) else b.real
    abs_bimag = (-b.imag) if b.imag &lt; f32(0) else b.imag

    if abs_breal &gt;= abs_bimag:
        # divide tops and bottom by b.real
        if abs_breal == f32(0.0):
            # errno = EDOM
            return complex64(0.0, 0.0)
        else:
            ratio = b.imag / b.real
            denom = b.real + b.imag * ratio
            return complex64(
                (a.real + a.imag * ratio) / denom, (a.imag - a.real * ratio) / denom
            )
    elif abs_bimag &gt;= abs_breal:
        # divide tops and bottom by b.imag
        ratio = b.real / b.imag
        denom = b.real * ratio + b.imag
        # assert b.imag != 0.0
        return complex64(
            (a.real * ratio + a.imag) / denom, (a.imag * ratio - a.real) / denom
        )
    else:
        nan = 0.0 / 0.0
        return complex64(nan, nan)

</t>
<t tx="ekr.20230509052845.2924">def __eq__(self, other: complex64) -&gt; bool:
    return self.real == other.real and self.imag == other.imag

</t>
<t tx="ekr.20230509052845.2925">def __ne__(self, other: complex64) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.2926">def __pow__(self, other: int) -&gt; complex64:
    def powu(x: complex64, n: int) -&gt; complex64:
        mask = 1
        r = complex64(1.0, 0.0)
        p = x
        while mask &gt; 0 and n &gt;= mask:
            if n &amp; mask:
                r = r * p
            mask &lt;&lt;= 1
            p = p * p
        return r

    if other &gt; 0:
        return powu(self, other)
    else:
        return complex64(1.0, 0.0) / powu(self, -other)

</t>
<t tx="ekr.20230509052845.2927">def __pow__(self, other: complex64) -&gt; complex64:
    @pure
    @C
    def hypotf(a: f32, b: f32) -&gt; f32:
        pass

    @pure
    @C
    def atan2f(a: f32, b: f32) -&gt; f32:
        pass

    @pure
    @llvm
    def exp(x: f32) -&gt; f32:
        declare float @llvm.exp.f32(float)
        %y = call float @llvm.exp.f32(float %x)
        ret float %y

    @pure
    @llvm
    def pow(x: f32, y: f32) -&gt; f32:
        declare float @llvm.pow.f32(float, float)
        %z = call float @llvm.pow.f32(float %x, float %y)
        ret float %z

    @pure
    @llvm
    def log(x: f32) -&gt; f32:
        declare float @llvm.log.f32(float)
        %y = call float @llvm.log.f32(float %x)
        ret float %y

    @pure
    @llvm
    def sin(x: f32) -&gt; f32:
        declare float @llvm.sin.f32(float)
        %y = call float @llvm.sin.f32(float %x)
        ret float %y

    @pure
    @llvm
    def cos(x: f32) -&gt; f32:
        declare float @llvm.cos.f32(float)
        %y = call float @llvm.cos.f32(float %x)
        ret float %y

    if other.real == f32(0.0) and other.imag == f32(0.0):
        return complex64(1.0, 0.0)
    elif self.real == f32(0.0) and self.imag == f32(0.0):
        # if other.imag != 0. or other.real &lt; 0.: errno = EDOM
        return complex64(0.0, 0.0)
    else:
        vabs = hypotf(self.real, self.imag)
        len = pow(vabs, other.real)
        at = atan2f(self.imag, self.real)
        phase = at * other.real
        if other.imag != f32(0.0):
            len /= exp(at * other.imag)
            phase += other.imag * log(vabs)
        return complex64(len * cos(phase), len * sin(phase))

</t>
<t tx="ekr.20230509052845.2928">def __repr__(self) -&gt; str:
    @pure
    @llvm
    def copysign(x: f32, y: f32) -&gt; f32:
        declare float @llvm.copysign.f32(float, float)
        %z = call float @llvm.copysign.f32(float %x, float %y)
        ret float %z

    @pure
    @llvm
    def fabs(x: f32) -&gt; f32:
        declare float @llvm.fabs.f32(float)
        %y = call float @llvm.fabs.f32(float %x)
        ret float %y

    if self.real == f32(0.0) and copysign(f32(1.0), self.real) == f32(1.0):
        return f"complex64({self.imag}j)"
    else:
        sign = "+"
        if self.imag &lt; f32(0.0) or (
            self.imag == f32(0.0) and copysign(f32(1.0), self.imag) == f32(-1.0)
        ):
            sign = "-"
        return f"complex64({self.real}{sign}{fabs(self.imag)}j)"

</t>
<t tx="ekr.20230509052845.2929">def conjugate(self) -&gt; complex64:
    return complex64(self.real, -self.imag)

</t>
<t tx="ekr.20230509052845.293">  /// @return iterator to the first type
  auto types_begin() { return util::raw_ptr_adaptor(types.begin()); }
  /// @return iterator beyond the last type
  auto types_end() { return util::raw_ptr_adaptor(types.end()); }
  /// @return iterator to the first type
  auto types_begin() const { return util::const_raw_ptr_adaptor(types.begin()); }
  /// @return iterator beyond the last type
  auto types_end() const { return util::const_raw_ptr_adaptor(types.end()); }
  /// @return a pointer to the first type
  types::Type *types_front() const { return types.front().get(); }
  /// @return a pointer to the last type
  types::Type *types_back() const { return types.back().get(); }
  /// @param name the type's name
  /// @return the type with the given name
  types::Type *getType(const std::string &amp;name) {
    auto it = typesMap.find(name);
    return it == typesMap.end() ? nullptr : it-&gt;second-&gt;get();
  }
  /// @param name the type's name
  /// @return the type with the given name
  types::Type *getType(const std::string &amp;name) const {
    auto it = typesMap.find(name);
    return it == typesMap.end() ? nullptr : it-&gt;second-&gt;get();
  }
</t>
<t tx="ekr.20230509052845.2930"># helpers
def _phase(self) -&gt; f32:
    @pure
    @C
    def atan2f(a: f32, b: f32) -&gt; f32:
        pass

    return atan2f(self.imag, self.real)

</t>
<t tx="ekr.20230509052845.2931">def _polar(self) -&gt; Tuple[f32, f32]:
    return (self.__abs__(), self._phase())

</t>
<t tx="ekr.20230509052845.2932">@pure
@llvm
def _exp(x: f32) -&gt; f32:
    declare float @llvm.exp.f32(float)
    %y = call float @llvm.exp.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.2933">@pure
@llvm
def _sqrt(x: f32) -&gt; f32:
    declare float @llvm.sqrt.f32(float)
    %y = call float @llvm.sqrt.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.2934">@pure
@llvm
def _cos(x: f32) -&gt; f32:
    declare float @llvm.cos.f32(float)
    %y = call float @llvm.cos.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.2935">@pure
@llvm
def _sin(x: f32) -&gt; f32:
    declare float @llvm.sin.f32(float)
    %y = call float @llvm.sin.f32(float %x)
    ret float %y

</t>
<t tx="ekr.20230509052845.2936">@pure
@llvm
def _log(x: f32) -&gt; f32:
    declare float @llvm.log.f32(float)
    %y = call float @llvm.log.f32(float %x)
    ret float %y
</t>
<t tx="ekr.20230509052845.2937">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2938"># Warning(!): This type must be consistent with the exception
# header type defined in runtime/exc.cpp.
class BaseException:
    _pytype: ClassVar[cobj] = cobj()
    typename: str
    message: str
    func: str
    file: str
    line: int
    col: int
    python_type: cobj

    @others
</t>
<t tx="ekr.20230509052845.2939">def __init__(self, typename: str, message: str = ""):
    self.typename = typename
    self.message = message
    self.func = ""
    self.file = ""
    self.line = 0
    self.col = 0
    self.python_type = BaseException._pytype

</t>
<t tx="ekr.20230509052845.294">  /// Removes a given type.
  /// @param t the type
  void remove(types::Type *t) {
    auto it = typesMap.find(t-&gt;getName());
    types.erase(it-&gt;second);
    typesMap.erase(it);
  }

</t>
<t tx="ekr.20230509052845.2940">def __str__(self):
    return self.message

</t>
<t tx="ekr.20230509052845.2941">def __repr__(self):
    return f'{self.typename}({self.message.__repr__()})'

</t>
<t tx="ekr.20230509052845.2942">class Exception(Static[BaseException]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, msg: str = ""):
        super().__init__(typename, msg)
        if (hasattr(self.__class__, "_pytype")):
            self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2943">class NameError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("NameError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2944">class OSError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("OSError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2945">class IOError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("IOError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2946">class ValueError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("ValueError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2947">class LookupError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, msg: str = ""):
        super().__init__("LookupError", msg)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2948">class IndexError(Static[LookupError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("IndexError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2949">class KeyError(Static[LookupError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("KeyError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.295">  /// Constructs and registers an IR node with provided source information.
  /// @param s the source information
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(codon::SrcInfo s, Args &amp;&amp;...args) {
    auto *ret = new DesiredType(std::forward&lt;Args&gt;(args)...);
    ret-&gt;setModule(this);
    ret-&gt;setSrcInfo(s);

    store(ret);
    return ret;
  }
</t>
<t tx="ekr.20230509052845.2950">class CError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("CError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2951">class PyError(Static[Exception]):
    pytype: pyobj

    def __init__(self, message: str, pytype: pyobj = pyobj(cobj(), steal=True)):
        super().__init__("PyError", message)
        self.pytype = pytype

</t>
<t tx="ekr.20230509052845.2952">class TypeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("TypeError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2953">class ArithmeticError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, msg: str = ""):
        super().__init__("ArithmeticError", msg)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2954">class ZeroDivisionError(Static[ArithmeticError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, message: str = ""):
        super().__init__("ZeroDivisionError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2955">class OverflowError(Static[ArithmeticError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("OverflowError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2956">class AttributeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("AttributeError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2957">class RuntimeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, message: str = ""):
        super().__init__("RuntimeError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2958">class NotImplementedError(Static[RuntimeError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("NotImplementedError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2959">class StopIteration(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("StopIteration", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.296">  /// Constructs and registers an IR node with provided source node.
  /// @param s the source node
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(const codon::SrcObject *s, Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(s-&gt;getSrcInfo(), std::forward&lt;Args&gt;(args)...);
  }
</t>
<t tx="ekr.20230509052845.2960">class AssertionError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("AssertionError", message)
        self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2961">class SystemExit(Static[BaseException]):
    _pytype: ClassVar[cobj] = cobj()
    _status: int

    @others
</t>
<t tx="ekr.20230509052845.2962">def __init__(self, message: str = "", status: int = 0):
    super().__init__("SystemExit", message)
    self._status = status
    self.python_type = self.__class__._pytype

</t>
<t tx="ekr.20230509052845.2963">def __init__(self, status: int):
    self.__init__("", status)

</t>
<t tx="ekr.20230509052845.2964">@property
def status(self):
    return self._status
</t>
<t tx="ekr.20230509052845.2965">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative
from internal.gc import alloc_atomic, free
from internal.types.complex import complex

@others
f32 = float32
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.2966">@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.2967">def __new__() -&gt; float:
    return 0.0

</t>
<t tx="ekr.20230509052845.2968">def __new__(what) -&gt; float:
    # do not overload! (needed to avoid pyobj conversion)
    if isinstance(what, str) or isinstance(what, Optional[str]):
        return float._from_str(what)
    else:
        return what.__float__()

</t>
<t tx="ekr.20230509052845.2969">def __repr__(self) -&gt; str:
    return self.__format__("")

</t>
<t tx="ekr.20230509052845.297">  /// Constructs and registers an IR node with provided source node.
  /// @param s the source node
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(const Node *s, Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(s-&gt;getSrcInfo(), std::forward&lt;Args&gt;(args)...);
  }
</t>
<t tx="ekr.20230509052845.2970">def __copy__(self) -&gt; float:
    return self

</t>
<t tx="ekr.20230509052845.2971">def __deepcopy__(self) -&gt; float:
    return self

</t>
<t tx="ekr.20230509052845.2972">@pure
@llvm
def __int__(self) -&gt; int:
    %0 = fptosi double %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.2973">def __float__(self) -&gt; float:
    return self

</t>
<t tx="ekr.20230509052845.2974">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = fcmp one double %self, 0.000000e+00
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.2975">def __complex__(self) -&gt; complex:
    return complex(self, 0.0)

</t>
<t tx="ekr.20230509052845.2976">def __pos__(self) -&gt; float:
    return self

</t>
<t tx="ekr.20230509052845.2977">@pure
@llvm
def __neg__(self) -&gt; float:
    %0 = fneg double %self
    ret double %0

</t>
<t tx="ekr.20230509052845.2978">@pure
@commutative
@llvm
def __add__(a: float, b: float) -&gt; float:
    %tmp = fadd double %a, %b
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2979">@pure
@llvm
def __sub__(a: float, b: float) -&gt; float:
    %tmp = fsub double %a, %b
    ret double %tmp

</t>
<t tx="ekr.20230509052845.298">  /// Constructs and registers an IR node with no source information.
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt; DesiredType *Nr(Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(codon::SrcInfo(), std::forward&lt;Args&gt;(args)...);
  }

  /// @return the type-checker cache
  ast::Cache *getCache() const { return cache; }
  /// Sets the type-checker cache.
  /// @param c the cache
  void setCache(ast::Cache *c) { cache = c; }

  /// Parse a codon code block.
  void parseCode(const std::string &amp;code);

  /// Gets or realizes a method.
  /// @param parent the parent class
  /// @param methodName the method name
  /// @param args the argument types
  /// @param generics the generics
  /// @return the method or nullptr
  Func *getOrRealizeMethod(types::Type *parent, const std::string &amp;methodName,
                           std::vector&lt;types::Type *&gt; args,
                           std::vector&lt;types::Generic&gt; generics = {});

  /// Gets or realizes a function.
  /// @param funcName the function name
  /// @param args the argument types
  /// @param generics the generics
  /// @param module the module of the function
  /// @return the function or nullptr
  Func *getOrRealizeFunc(const std::string &amp;funcName, std::vector&lt;types::Type *&gt; args,
                         std::vector&lt;types::Generic&gt; generics = {},
                         const std::string &amp;module = "");

  /// Gets or realizes a type.
  /// @param typeName the type name
  /// @param generics the generics
  /// @param module the module of the type
  /// @return the function or nullptr
  types::Type *getOrRealizeType(const std::string &amp;typeName,
                                std::vector&lt;types::Generic&gt; generics = {},
                                const std::string &amp;module = "");

  /// @return the void type
  types::Type *getVoidType();
  /// @return the bool type
  types::Type *getBoolType();
  /// @return the byte type
  types::Type *getByteType();
  /// @return the int type
  types::Type *getIntType();
  /// @return the float type
  types::Type *getFloatType();
  /// @return the float32 type
  types::Type *getFloat32Type();
  /// @return the string type
  types::Type *getStringType();
  /// Gets a pointer type.
  /// @param base the base type
  /// @return a pointer type that references the base
  types::Type *getPointerType(types::Type *base);
  /// Gets an array type.
  /// @param base the base type
  /// @return an array type that contains the base
  types::Type *getArrayType(types::Type *base);
  /// Gets a generator type.
  /// @param base the base type
  /// @return a generator type that yields the base
  types::Type *getGeneratorType(types::Type *base);
  /// Gets an optional type.
  /// @param base the base type
  /// @return an optional type that contains the base
  types::Type *getOptionalType(types::Type *base);
  /// Gets a function type.
  /// @param rType the return type
  /// @param argTypes the argument types
  /// @param variadic true if variadic (e.g. "printf" in C)
  /// @return the void type
  types::Type *getFuncType(types::Type *rType, std::vector&lt;types::Type *&gt; argTypes,
                           bool variadic = false);
  /// Gets a variable length integer type.
  /// @param len the length
  /// @param sign true if signed
  /// @return a variable length integer type
  types::Type *getIntNType(unsigned len, bool sign);
  /// Gets a vector type.
  /// @param count the vector size
  /// @param base the vector base type (MUST be a primitive type)
  /// @return a vector type
  types::Type *getVectorType(unsigned count, types::Type *base);
  /// Gets a tuple type.
  /// @param args the arg types
  /// @return the tuple type
  types::Type *getTupleType(std::vector&lt;types::Type *&gt; args);
  /// Gets a union type.
  /// @param types the alternative types
  /// @return the union type
  types::Type *getUnionType(std::vector&lt;types::Type *&gt; types);
  /// Gets the "none" type (i.e. empty tuple).
  /// @return none type
  types::Type *getNoneType();

  /// @param v the value
  /// @return an int constant
  Value *getInt(int64_t v);
  /// @param v the value
  /// @return a float constant
  Value *getFloat(double v);
  /// @param v the value
  /// @return a bool constant
  Value *getBool(bool v);
  /// @param v the value
  /// @return a string constant
  Value *getString(std::string v);

  /// Gets a dummy function type. Should generally not be used as no type-checker
  /// information is generated.
  /// @return a func type with no args and void return type.
  types::Type *unsafeGetDummyFuncType();
  /// Gets a pointer type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return a pointer type that references the base
  types::Type *unsafeGetPointerType(types::Type *base);
  /// Gets an array type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return an array type that contains the base
  types::Type *unsafeGetArrayType(types::Type *base);
  /// Gets a generator type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return a generator type that yields the base
  types::Type *unsafeGetGeneratorType(types::Type *base);
  /// Gets an optional type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return an optional type that contains the base
  types::Type *unsafeGetOptionalType(types::Type *base);
  /// Gets a function type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param rType the return type
  /// @param argTypes the argument types
  /// @param variadic true if variadic (e.g. "printf" in C)
  /// @return the void type
  types::Type *unsafeGetFuncType(const std::string &amp;name, types::Type *rType,
                                 std::vector&lt;types::Type *&gt; argTypes,
                                 bool variadic = false);
  /// Gets a membered type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param name the type's name
  /// @param ref whether the type should be a ref
  /// @return an empty membered/ref type
  types::Type *unsafeGetMemberedType(const std::string &amp;name, bool ref = false);
  /// Gets a variable length integer type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param len the length
  /// @param sign true if signed
  /// @return a variable length integer type
  types::Type *unsafeGetIntNType(unsigned len, bool sign);
  /// Gets a vector type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param count the vector size
  /// @param base the vector base type (MUST be a primitive type)
  /// @return a vector type
  types::Type *unsafeGetVectorType(unsigned count, types::Type *base);
  /// Gets a union type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param types the alternative types
  /// @return a union type
  types::Type *unsafeGetUnionType(const std::vector&lt;types::Type *&gt; &amp;types);

private:
</t>
<t tx="ekr.20230509052845.2980">@pure
@commutative
@llvm
def __mul__(a: float, b: float) -&gt; float:
    %tmp = fmul double %a, %b
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2981">def __floordiv__(self, other: float) -&gt; float:
    return self.__truediv__(other).__floor__()

</t>
<t tx="ekr.20230509052845.2982">@pure
@llvm
def __truediv__(a: float, b: float) -&gt; float:
    %tmp = fdiv double %a, %b
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2983">@pure
@llvm
def __mod__(a: float, b: float) -&gt; float:
    %tmp = frem double %a, %b
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2984">def __divmod__(self, other: float) -&gt; Tuple[float, float]:
    mod = self % other
    div = (self - mod) / other
    if mod:
        if (other &lt; 0) != (mod &lt; 0):
            mod += other
            div -= 1.0
    else:
        mod = (0.0).copysign(other)

    floordiv = 0.0
    if div:
        floordiv = div.__floor__()
        if div - floordiv &gt; 0.5:
            floordiv += 1.0
    else:
        floordiv = (0.0).copysign(self / other)

    return (floordiv, mod)

</t>
<t tx="ekr.20230509052845.2985">@pure
@llvm
def __eq__(a: float, b: float) -&gt; bool:
    %tmp = fcmp oeq double %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.2986">@pure
@llvm
def __ne__(a: float, b: float) -&gt; bool:
    entry:
        %tmp = fcmp one double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

</t>
<t tx="ekr.20230509052845.2987">@pure
@llvm
def __lt__(a: float, b: float) -&gt; bool:
    %tmp = fcmp olt double %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.2988">@pure
@llvm
def __gt__(a: float, b: float) -&gt; bool:
    %tmp = fcmp ogt double %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.2989">@pure
@llvm
def __le__(a: float, b: float) -&gt; bool:
    %tmp = fcmp ole double %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.299">  void store(types::Type *t) {
    types.emplace_back(t);
    typesMap[t-&gt;getName()] = std::prev(types.end());
  }
</t>
<t tx="ekr.20230509052845.2990">@pure
@llvm
def __ge__(a: float, b: float) -&gt; bool:
    %tmp = fcmp oge double %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.2991">@pure
@llvm
def sqrt(a: float) -&gt; float:
    declare double @llvm.sqrt.f64(double %a)
    %tmp = call double @llvm.sqrt.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2992">@pure
@llvm
def sin(a: float) -&gt; float:
    declare double @llvm.sin.f64(double %a)
    %tmp = call double @llvm.sin.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2993">@pure
@llvm
def cos(a: float) -&gt; float:
    declare double @llvm.cos.f64(double %a)
    %tmp = call double @llvm.cos.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2994">@pure
@llvm
def exp(a: float) -&gt; float:
    declare double @llvm.exp.f64(double %a)
    %tmp = call double @llvm.exp.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2995">@pure
@llvm
def exp2(a: float) -&gt; float:
    declare double @llvm.exp2.f64(double %a)
    %tmp = call double @llvm.exp2.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2996">@pure
@llvm
def log(a: float) -&gt; float:
    declare double @llvm.log.f64(double %a)
    %tmp = call double @llvm.log.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2997">@pure
@llvm
def log10(a: float) -&gt; float:
    declare double @llvm.log10.f64(double %a)
    %tmp = call double @llvm.log10.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2998">@pure
@llvm
def log2(a: float) -&gt; float:
    declare double @llvm.log2.f64(double %a)
    %tmp = call double @llvm.log2.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.2999">@pure
@llvm
def __abs__(a: float) -&gt; float:
    declare double @llvm.fabs.f64(double %a)
    %tmp = call double @llvm.fabs.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3"></t>
<t tx="ekr.20230509052845.30">def __init__(self, points, degree, knots):
    """Creates a Spline.
    points is a list of GVector, degree is the degree of the Spline.
    """
    if len(points) &gt; len(knots) - degree + 1:
        raise ValueError("too many control points")
    elif len(points) &lt; len(knots) - degree + 1:
        raise ValueError("not enough control points")
    last = knots[0]
    for cur in knots[1:]:
        if cur &lt; last:
            raise ValueError("knots not strictly increasing")
        last = cur
    self.knots = knots
    self.points = points
    self.degree = degree

</t>
<t tx="ekr.20230509052845.300">  void store(Value *v) {
    values.emplace_back(v);
    valueMap[v-&gt;getId()] = std::prev(values.end());
  }
</t>
<t tx="ekr.20230509052845.3000">@pure
@llvm
def __floor__(a: float) -&gt; float:
    declare double @llvm.floor.f64(double %a)
    %tmp = call double @llvm.floor.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3001">@pure
@llvm
def __ceil__(a: float) -&gt; float:
    declare double @llvm.ceil.f64(double %a)
    %tmp = call double @llvm.ceil.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3002">@pure
@llvm
def __trunc__(a: float) -&gt; float:
    declare double @llvm.trunc.f64(double %a)
    %tmp = call double @llvm.trunc.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3003">@pure
@llvm
def rint(a: float) -&gt; float:
    declare double @llvm.rint.f64(double %a)
    %tmp = call double @llvm.rint.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3004">@pure
@llvm
def nearbyint(a: float) -&gt; float:
    declare double @llvm.nearbyint.f64(double %a)
    %tmp = call double @llvm.nearbyint.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3005">@pure
@llvm
def __round__(a: float) -&gt; float:
    declare double @llvm.round.f64(double %a)
    %tmp = call double @llvm.round.f64(double %a)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3006">@pure
@llvm
def __pow__(a: float, b: float) -&gt; float:
    declare double @llvm.pow.f64(double %a, double %b)
    %tmp = call double @llvm.pow.f64(double %a, double %b)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3007">@pure
@llvm
def min(a: float, b: float) -&gt; float:
    declare double @llvm.minnum.f64(double %a, double %b)
    %tmp = call double @llvm.minnum.f64(double %a, double %b)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3008">@pure
@llvm
def max(a: float, b: float) -&gt; float:
    declare double @llvm.maxnum.f64(double %a, double %b)
    %tmp = call double @llvm.maxnum.f64(double %a, double %b)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3009">@pure
@llvm
def copysign(a: float, b: float) -&gt; float:
    declare double @llvm.copysign.f64(double %a, double %b)
    %tmp = call double @llvm.copysign.f64(double %a, double %b)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.301">  void store(Var *v) {
    vars.emplace_back(v);
    varMap[v-&gt;getId()] = std::prev(vars.end());
  }
</t>
<t tx="ekr.20230509052845.3010">@pure
@llvm
def fma(a: float, b: float, c: float) -&gt; float:
    declare double @llvm.fma.f64(double %a, double %b, double %c)
    %tmp = call double @llvm.fma.f64(double %a, double %b, double %c)
    ret double %tmp

</t>
<t tx="ekr.20230509052845.3011">@nocapture
@llvm
def __atomic_xchg__(d: Ptr[float], b: float) -&gt; None:
    %tmp = atomicrmw xchg ptr %d, double %b seq_cst
    ret {} {}

</t>
<t tx="ekr.20230509052845.3012">@nocapture
@llvm
def __atomic_add__(d: Ptr[float], b: float) -&gt; float:
    0:
    %1 = load atomic i64, ptr %d monotonic, align 8
    %2 = bitcast i64 %1 to double
    %3 = fadd double %2, %b
    %4 = bitcast double %3 to i64
    %5 = cmpxchg weak ptr %d, i64 %1, i64 %4 seq_cst monotonic, align 8
    %6 = extractvalue { i64, i1 } %5, 1
    br i1 %6, label %15, label %7
    7:                                                ; preds = %0, %7
    %8 = phi { i64, i1 } [ %13, %7 ], [ %5, %0 ]
    %9 = extractvalue { i64, i1 } %8, 0
    %10 = bitcast i64 %9 to double
    %11 = fadd double %10, %b
    %12 = bitcast double %11 to i64
    %13 = cmpxchg weak ptr %d, i64 %9, i64 %12 seq_cst monotonic, align 8
    %14 = extractvalue { i64, i1 } %13, 1
    br i1 %14, label %15, label %7
    15:                                               ; preds = %7, %0
    %16 = phi double [ %2, %0 ], [ %10, %7 ]
    ret double %16

</t>
<t tx="ekr.20230509052845.3013">@nocapture
@llvm
def __atomic_sub__(d: Ptr[float], b: float) -&gt; float:
    0:
    %1 = load atomic i64, ptr %d monotonic, align 8
    %2 = bitcast i64 %1 to double
    %3 = fsub double %2, %b
    %4 = bitcast double %3 to i64
    %5 = cmpxchg weak ptr %d, i64 %1, i64 %4 seq_cst monotonic, align 8
    %6 = extractvalue { i64, i1 } %5, 1
    br i1 %6, label %15, label %7
    7:                                                ; preds = %0, %7
    %8 = phi { i64, i1 } [ %13, %7 ], [ %5, %0 ]
    %9 = extractvalue { i64, i1 } %8, 0
    %10 = bitcast i64 %9 to double
    %11 = fsub double %10, %b
    %12 = bitcast double %11 to i64
    %13 = cmpxchg weak ptr %d, i64 %9, i64 %12 seq_cst monotonic, align 8
    %14 = extractvalue { i64, i1 } %13, 1
    br i1 %14, label %15, label %7
    15:                                               ; preds = %7, %0
    %16 = phi double [ %2, %0 ], [ %10, %7 ]
    ret double %16

</t>
<t tx="ekr.20230509052845.3014">def __hash__(self) -&gt; int:
    @nocapture
    @C
    def frexp(a: float, b: Ptr[Int[32]]) -&gt; float: pass

    HASH_BITS = 61
    HASH_MODULUS = (1 &lt;&lt; HASH_BITS) - 1
    HASH_INF = 314159
    HASH_NAN = 0
    INF = 1.0 / 0.0
    NAN = 0.0 / 0.0
    v = self

    if v == INF or v == -INF:
        return HASH_INF if v &gt; 0 else -HASH_INF
    if v == NAN:
        return HASH_NAN

    _e = i32(0)
    m = frexp(v, __ptr__(_e))
    e = int(_e)

    sign = 1
    if m &lt; 0:
        sign = -1
        m = -m

    x = 0
    while m:
        x = ((x &lt;&lt; 28) &amp; HASH_MODULUS) | x &gt;&gt; (HASH_BITS - 28)
        m *= 268435456.0  # 2**28
        e -= 28
        y = int(m)
        m -= y
        x += y
        if x &gt;= HASH_MODULUS:
            x -= HASH_MODULUS

    e = e % HASH_BITS if e &gt;= 0 else HASH_BITS - 1 - ((-1 - e) % HASH_BITS)
    x = ((x &lt;&lt; e) &amp; HASH_MODULUS) | x &gt;&gt; (HASH_BITS - e)

    x = x * sign
    if x == -1:
        x = -2
    return x

</t>
<t tx="ekr.20230509052845.3015">def __match__(self, i: float) -&gt; bool:
    return self == i

</t>
<t tx="ekr.20230509052845.3016">@property
def real(self) -&gt; float:
    return self

</t>
<t tx="ekr.20230509052845.3017">@property
def imag(self) -&gt; float:
    return 0.0

</t>
<t tx="ekr.20230509052845.3018">@extend
class float32:
    @others
</t>
<t tx="ekr.20230509052845.3019">@pure
@llvm
def __new__(self: float) -&gt; float32:
    %0 = fptrunc double %self to float
    ret float %0

</t>
<t tx="ekr.20230509052845.302">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/func.h"
#include "codon/cir/types/types.h"

namespace codon {
namespace ir {

struct PyFunction {
  enum Type { TOPLEVEL, METHOD, CLASS, STATIC };
  std::string name;
  std::string doc;
  Func *func = nullptr;
  Type type = Type::TOPLEVEL;
  int nargs = 0;
  bool keywords = false;
  bool coexist = false;
};

struct PyMember {
  enum Type {
    SHORT = 0,
    INT = 1,
    LONG = 2,
    FLOAT = 3,
    DOUBLE = 4,
    STRING = 5,
    OBJECT = 6,
    CHAR = 7,
    BYTE = 8,
    UBYTE = 9,
    USHORT = 10,
    UINT = 11,
    ULONG = 12,
    STRING_INPLACE = 13,
    BOOL = 14,
    OBJECT_EX = 16,
    LONGLONG = 17,
    ULONGLONG = 18,
    PYSSIZET = 19,
  };

  std::string name;
  std::string doc;
  Type type = Type::SHORT;
  bool readonly = false;
  /// Indexes of the member. For example, in the
  /// tuple (a, (b, c, (d,))), 'a' would have indexes
  /// [0], 'b' would have indexes [1, 0], 'c' would
  /// have indexes [1, 1], and 'd' would have indexes
  /// [1, 2, 0]. This corresponds to an LLVM GEP.
  std::vector&lt;int&gt; indexes;
};

struct PyGetSet {
  std::string name;
  std::string doc;
  Func *get = nullptr;
  Func *set = nullptr;
};

struct PyType {
  std::string name;
  std::string doc;
  types::Type *type = nullptr;
  PyType *base = nullptr;
  Func *repr = nullptr;
  Func *add = nullptr;
  Func *iadd = nullptr;
  Func *sub = nullptr;
  Func *isub = nullptr;
  Func *mul = nullptr;
  Func *imul = nullptr;
  Func *mod = nullptr;
  Func *imod = nullptr;
  Func *divmod = nullptr;
  Func *pow = nullptr;
  Func *ipow = nullptr;
  Func *neg = nullptr;
  Func *pos = nullptr;
  Func *abs = nullptr;
  Func *bool_ = nullptr;
  Func *invert = nullptr;
  Func *lshift = nullptr;
  Func *ilshift = nullptr;
  Func *rshift = nullptr;
  Func *irshift = nullptr;
  Func *and_ = nullptr;
  Func *iand = nullptr;
  Func *xor_ = nullptr;
  Func *ixor = nullptr;
  Func *or_ = nullptr;
  Func *ior = nullptr;
  Func *int_ = nullptr;
  Func *float_ = nullptr;
  Func *floordiv = nullptr;
  Func *ifloordiv = nullptr;
  Func *truediv = nullptr;
  Func *itruediv = nullptr;
  Func *index = nullptr;
  Func *matmul = nullptr;
  Func *imatmul = nullptr;
  Func *len = nullptr;
  Func *getitem = nullptr;
  Func *setitem = nullptr;
  Func *contains = nullptr;
  Func *hash = nullptr;
  Func *call = nullptr;
  Func *str = nullptr;
  Func *cmp = nullptr;
  Func *iter = nullptr;
  Func *iternext = nullptr;
  Func *del = nullptr;
  Func *init = nullptr;
  std::vector&lt;PyFunction&gt; methods;
  std::vector&lt;PyMember&gt; members;
  std::vector&lt;PyGetSet&gt; getset;
  Func *typePtrHook = nullptr;
};

struct PyModule {
  std::string name;
  std::string doc;
  std::vector&lt;PyFunction&gt; functions;
  std::vector&lt;PyType&gt; types;
};

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3020">def __new__(what: float32) -&gt; float32:
    return what

</t>
<t tx="ekr.20230509052845.3021">def __new__() -&gt; float32:
    return float32.__new__(0.0)

</t>
<t tx="ekr.20230509052845.3022">def __repr__(self) -&gt; str:
    return self.__float__().__repr__()

</t>
<t tx="ekr.20230509052845.3023">def __format__(self, format_spec: str) -&gt; str:
    return self.__float__().__format(format_spec)

</t>
<t tx="ekr.20230509052845.3024">def __copy__(self) -&gt; float32:
    return self

</t>
<t tx="ekr.20230509052845.3025">def __deepcopy__(self) -&gt; float32:
    return self

</t>
<t tx="ekr.20230509052845.3026">@pure
@llvm
def __int__(self) -&gt; int:
    %0 = fptosi float %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.3027">@pure
@llvm
def __float__(self) -&gt; float:
    %0 = fpext float %self to double
    ret double %0

</t>
<t tx="ekr.20230509052845.3028">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = fcmp one float %self, 0.000000e+00
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3029">def __pos__(self) -&gt; float32:
    return self

</t>
<t tx="ekr.20230509052845.303">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/base.h"
#include "codon/cir/types/types.h"
#include "codon/cir/util/packs.h"

namespace codon {
namespace ir {

class Func;

@others
} // namespace ir
} // namespace codon

template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ir::Value, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3030">@pure
@llvm
def __neg__(self) -&gt; float32:
    %0 = fneg float %self
    ret float %0

</t>
<t tx="ekr.20230509052845.3031">@pure
@commutative
@llvm
def __add__(a: float32, b: float32) -&gt; float32:
    %tmp = fadd float %a, %b
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3032">@pure
@llvm
def __sub__(a: float32, b: float32) -&gt; float32:
    %tmp = fsub float %a, %b
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3033">@pure
@commutative
@llvm
def __mul__(a: float32, b: float32) -&gt; float32:
    %tmp = fmul float %a, %b
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3034">def __floordiv__(self, other: float32) -&gt; float:
    return self.__truediv__(other).__floor__()

</t>
<t tx="ekr.20230509052845.3035">@pure
@llvm
def __truediv__(a: float32, b: float32) -&gt; float32:
    %tmp = fdiv float %a, %b
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3036">@pure
@llvm
def __mod__(a: float32, b: float32) -&gt; float32:
    %tmp = frem float %a, %b
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3037">def __divmod__(self, other: float32) -&gt; Tuple[float32, float32]:
    mod = self % other
    div = (self - mod) / other
    if mod:
        if (other &lt; 0) != (mod &lt; 0):
            mod += other
            div -= 1.0
    else:
        mod = (0.0).copysign(other)

    floordiv = 0.0
    if div:
        floordiv = div.__floor__()
        if div - floordiv &gt; 0.5:
            floordiv += 1.0
    else:
        floordiv = (0.0).copysign(self / other)

    return (floordiv, mod)

</t>
<t tx="ekr.20230509052845.3038">@pure
@llvm
def __eq__(a: float32, b: float32) -&gt; bool:
    %tmp = fcmp oeq float %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3039">@pure
@llvm
def __ne__(a: float32, b: float32) -&gt; bool:
    entry:
        %tmp = fcmp one float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

</t>
<t tx="ekr.20230509052845.304">class Value : public ReplaceableNodeBase&lt;Value&gt;, public IdMixin {
public:
  static const char NodeId;

  /// Constructs a value.
  /// @param the value's name
  explicit Value(std::string name = "") : ReplaceableNodeBase(std::move(name)) {}

  virtual ~Value() noexcept = default;

  std::string referenceString() const final {
    return fmt::format(FMT_STRING("{}.{}"), getName(), getId());
  }

  std::vector&lt;Value *&gt; getUsedValues() final { return getActual()-&gt;doGetUsedValues(); }
  std::vector&lt;const Value *&gt; getUsedValues() const final {
    auto ret = getActual()-&gt;doGetUsedValues();
    return std::vector&lt;const Value *&gt;(ret.begin(), ret.end());
  }
@others
  using Node::replaceUsedVariable;

  /// @return the value's type
  types::Type *getType() const { return getActual()-&gt;doGetType(); }

  id_t getId() const override { return getActual()-&gt;id; }

  Value *operator==(Value &amp;other);
  Value *operator!=(Value &amp;other);
  Value *operator&lt;(Value &amp;other);
  Value *operator&gt;(Value &amp;other);
  Value *operator&lt;=(Value &amp;other);
  Value *operator&gt;=(Value &amp;other);

  Value *operator+();
  Value *operator-();
  Value *operator~();

  Value *operator+(Value &amp;other);
  Value *operator-(Value &amp;other);
  Value *operator*(Value &amp;other);
  Value *matMul(Value &amp;other);
  Value *trueDiv(Value &amp;other);
  Value *operator/(Value &amp;other);
  Value *operator%(Value &amp;other);
  Value *pow(Value &amp;other);
  Value *operator&lt;&lt;(Value &amp;other);
  Value *operator&gt;&gt;(Value &amp;other);
  Value *operator&amp;(Value &amp;other);
  Value *operator|(Value &amp;other);
  Value *operator^(Value &amp;other);

  Value *operator||(Value &amp;other);
  Value *operator&amp;&amp;(Value &amp;other);

  template &lt;typename... Args&gt; Value *operator()(Args &amp;&amp;...args) {
    std::vector&lt;Value *&gt; dst;
    util::stripPack(dst, std::forward&lt;Args&gt;(args)...);
    return doCall(dst);
  }
  Value *operator[](Value &amp;other);

  Value *toInt();
  Value *toFloat();
  Value *toBool();
  Value *toStr();

  Value *len();
  Value *iter();

private:
  Value *doUnaryOp(const std::string &amp;name);
  Value *doBinaryOp(const std::string &amp;name, Value &amp;other);

  Value *doCall(const std::vector&lt;Value *&gt; &amp;args);

  virtual types::Type *doGetType() const = 0;

  virtual std::vector&lt;Value *&gt; doGetUsedValues() const { return {}; }
  virtual int doReplaceUsedValue(id_t id, Value *newValue) { return 0; }

  virtual std::vector&lt;types::Type *&gt; doGetUsedTypes() const { return {}; }
  virtual int doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
    return 0;
  }

  virtual std::vector&lt;Var *&gt; doGetUsedVariables() const { return {}; }
  virtual int doReplaceUsedVariable(id_t id, Var *newVar) { return 0; }
};

</t>
<t tx="ekr.20230509052845.3040">@pure
@llvm
def __lt__(a: float32, b: float32) -&gt; bool:
    %tmp = fcmp olt float %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3041">@pure
@llvm
def __gt__(a: float32, b: float32) -&gt; bool:
    %tmp = fcmp ogt float %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3042">@pure
@llvm
def __le__(a: float32, b: float32) -&gt; bool:
    %tmp = fcmp ole float %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3043">@pure
@llvm
def __ge__(a: float32, b: float32) -&gt; bool:
    %tmp = fcmp oge float %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3044">@pure
@llvm
def sqrt(a: float32) -&gt; float32:
    declare float @llvm.sqrt.f32(float %a)
    %tmp = call float @llvm.sqrt.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3045">@pure
@llvm
def sin(a: float32) -&gt; float32:
    declare float @llvm.sin.f32(float %a)
    %tmp = call float @llvm.sin.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3046">@pure
@llvm
def cos(a: float32) -&gt; float32:
    declare float @llvm.cos.f32(float %a)
    %tmp = call float @llvm.cos.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3047">@pure
@llvm
def exp(a: float32) -&gt; float32:
    declare float @llvm.exp.f32(float %a)
    %tmp = call float @llvm.exp.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3048">@pure
@llvm
def exp2(a: float32) -&gt; float32:
    declare float @llvm.exp2.f32(float %a)
    %tmp = call float @llvm.exp2.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3049">@pure
@llvm
def log(a: float32) -&gt; float32:
    declare float @llvm.log.f32(float %a)
    %tmp = call float @llvm.log.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.305">  int replaceUsedValue(id_t id, Value *newValue) final {
    return getActual()-&gt;doReplaceUsedValue(id, newValue);
  }
</t>
<t tx="ekr.20230509052845.3050">@pure
@llvm
def log10(a: float32) -&gt; float32:
    declare float @llvm.log10.f32(float %a)
    %tmp = call float @llvm.log10.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3051">@pure
@llvm
def log2(a: float32) -&gt; float32:
    declare float @llvm.log2.f32(float %a)
    %tmp = call float @llvm.log2.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3052">@pure
@llvm
def __abs__(a: float32) -&gt; float32:
    declare float @llvm.fabs.f32(float %a)
    %tmp = call float @llvm.fabs.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3053">@pure
@llvm
def __floor__(a: float32) -&gt; float32:
    declare float @llvm.floor.f32(float %a)
    %tmp = call float @llvm.floor.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3054">@pure
@llvm
def __ceil__(a: float32) -&gt; float32:
    declare float @llvm.ceil.f32(float %a)
    %tmp = call float @llvm.ceil.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3055">@pure
@llvm
def __trunc__(a: float32) -&gt; float32:
    declare float @llvm.trunc.f32(float %a)
    %tmp = call float @llvm.trunc.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3056">@pure
@llvm
def rint(a: float32) -&gt; float32:
    declare float @llvm.rint.f32(float %a)
    %tmp = call float @llvm.rint.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3057">@pure
@llvm
def nearbyint(a: float32) -&gt; float32:
    declare float @llvm.nearbyint.f32(float %a)
    %tmp = call float @llvm.nearbyint.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3058">@pure
@llvm
def __round__(a: float32) -&gt; float32:
    declare float @llvm.round.f32(float %a)
    %tmp = call float @llvm.round.f32(float %a)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3059">@pure
@llvm
def __pow__(a: float32, b: float32) -&gt; float32:
    declare float @llvm.pow.f32(float %a, float %b)
    %tmp = call float @llvm.pow.f32(float %a, float %b)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.306">  using Node::replaceUsedValue;

  std::vector&lt;types::Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
</t>
<t tx="ekr.20230509052845.3060">@pure
@llvm
def min(a: float32, b: float32) -&gt; float32:
    declare float @llvm.minnum.f32(float %a, float %b)
    %tmp = call float @llvm.minnum.f32(float %a, float %b)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3061">@pure
@llvm
def max(a: float32, b: float32) -&gt; float32:
    declare float @llvm.maxnum.f32(float %a, float %b)
    %tmp = call float @llvm.maxnum.f32(float %a, float %b)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3062">@pure
@llvm
def copysign(a: float32, b: float32) -&gt; float32:
    declare float @llvm.copysign.f32(float %a, float %b)
    %tmp = call float @llvm.copysign.f32(float %a, float %b)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3063">@pure
@llvm
def fma(a: float32, b: float32, c: float32) -&gt; float32:
    declare float @llvm.fma.f32(float %a, float %b, float %c)
    %tmp = call float @llvm.fma.f32(float %a, float %b, float %c)
    ret float %tmp

</t>
<t tx="ekr.20230509052845.3064">@nocapture
@llvm
def __atomic_xchg__(d: Ptr[float32], b: float32) -&gt; None:
    %tmp = atomicrmw xchg ptr %d, float %b seq_cst
    ret {} {}

</t>
<t tx="ekr.20230509052845.3065">@nocapture
@llvm
def __atomic_add__(d: Ptr[float32], b: float32) -&gt; float32:
    0:
    %1 = load atomic i32, ptr %d monotonic, align 4
    %2 = bitcast i32 %1 to float
    %3 = fadd float %2, %b
    %4 = bitcast float %3 to i32
    %5 = cmpxchg weak ptr %d, i32 %1, i32 %4 seq_cst monotonic, align 4
    %6 = extractvalue { i32, i1 } %5, 1
    br i1 %6, label %15, label %7
    7:                                                ; preds = %0, %7
    %8 = phi { i32, i1 } [ %13, %7 ], [ %5, %0 ]
    %9 = extractvalue { i32, i1 } %8, 0
    %10 = bitcast i32 %9 to float
    %11 = fadd float %10, %b
    %12 = bitcast float %11 to i32
    %13 = cmpxchg weak ptr %d, i32 %9, i32 %12 seq_cst monotonic, align 4
    %14 = extractvalue { i32, i1 } %13, 1
    br i1 %14, label %15, label %7
    15:                                               ; preds = %7, %0
    %16 = phi float [ %2, %0 ], [ %10, %7 ]
    ret float %16

</t>
<t tx="ekr.20230509052845.3066">@nocapture
@llvm
def __atomic_sub__(d: Ptr[float32], b: float32) -&gt; float32:
    0:
    %1 = load atomic i32, ptr %d monotonic, align 4
    %2 = bitcast i32 %1 to float
    %3 = fsub float %2, %b
    %4 = bitcast float %3 to i32
    %5 = cmpxchg weak ptr %d, i32 %1, i32 %4 seq_cst monotonic, align 4
    %6 = extractvalue { i32, i1 } %5, 1
    br i1 %6, label %15, label %7
    7:                                                ; preds = %0, %7
    %8 = phi { i32, i1 } [ %13, %7 ], [ %5, %0 ]
    %9 = extractvalue { i32, i1 } %8, 0
    %10 = bitcast i32 %9 to float
    %11 = fsub float %10, %b
    %12 = bitcast float %11 to i32
    %13 = cmpxchg weak ptr %d, i32 %9, i32 %12 seq_cst monotonic, align 4
    %14 = extractvalue { i32, i1 } %13, 1
    br i1 %14, label %15, label %7
    15:                                               ; preds = %7, %0
    %16 = phi float [ %2, %0 ], [ %10, %7 ]
    ret float %16

</t>
<t tx="ekr.20230509052845.3067">def __hash__(self) -&gt; int:
    return self.__float__().__hash__()

</t>
<t tx="ekr.20230509052845.3068">def __match__(self, i: float32) -&gt; bool:
    return self == i

</t>
<t tx="ekr.20230509052845.3069">@extend
class float:
    def __suffix_f32__(double) -&gt; float32:
        return float32.__new__(double)

</t>
<t tx="ekr.20230509052845.307">  int replaceUsedType(const std::string &amp;name, types::Type *newType) final {
    return getActual()-&gt;doReplaceUsedType(name, newType);
  }
</t>
<t tx="ekr.20230509052845.3070">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
generator = Generator
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3071">@extend
class Generator:
    @others
</t>
<t tx="ekr.20230509052845.3072">@__internal__
def __promise__(self) -&gt; Ptr[T]:
    pass

</t>
<t tx="ekr.20230509052845.3073">def done(self) -&gt; bool:
    self.__resume__()
    return self.__done__()

</t>
<t tx="ekr.20230509052845.3074">def next(self: Generator[T]) -&gt; T:
    if isinstance(T, None):
        pass
    else:
        return self.__promise__()[0]

</t>
<t tx="ekr.20230509052845.3075">def __iter__(self) -&gt; Generator[T]:
    return self

</t>
<t tx="ekr.20230509052845.3076">@pure
@llvm
def __raw__(self) -&gt; Ptr[byte]:
    ret ptr %self

</t>
<t tx="ekr.20230509052845.3077">@pure
@derives
@llvm
def __new__(ptr: cobj) -&gt; Generator[T]:
    ret ptr %ptr

</t>
<t tx="ekr.20230509052845.3078">@pure
@llvm
def __done__(self) -&gt; bool:
    declare i1 @llvm.coro.done(ptr nocapture readonly)
    %0 = call i1 @llvm.coro.done(ptr %self)
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3079">@nocapture
@llvm
def __resume__(self) -&gt; None:
    declare void @llvm.coro.resume(ptr)
    call void @llvm.coro.resume(ptr %self)
    ret {} {}

</t>
<t tx="ekr.20230509052845.308">  using Node::replaceUsedType;

  std::vector&lt;Var *&gt; getUsedVariables() final {
    return getActual()-&gt;doGetUsedVariables();
  }
  std::vector&lt;const Var *&gt; getUsedVariables() const final {
    auto ret = getActual()-&gt;doGetUsedVariables();
    return std::vector&lt;const Var *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509052845.3080">def __repr__(self) -&gt; str:
    return __internal__.raw_type_str(self.__raw__(), "generator")

</t>
<t tx="ekr.20230509052845.3081">def send(self, what: T) -&gt; T:
    p = self.__promise__()
    p[0] = what
    self.__resume__()
    return p[0]

</t>
<t tx="ekr.20230509052845.3082">@nocapture
@llvm
def destroy(self) -&gt; None:
    declare void @llvm.coro.destroy(ptr)
    call void @llvm.coro.destroy(ptr %self)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3083">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative, distributive
from internal.types.complex import complex

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3084">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.3085">@pure
@llvm
def __new__() -&gt; int:
    ret i64 0

</t>
<t tx="ekr.20230509052845.3086">def __new__(s: str, base: int) -&gt; int:
    return int._from_str(s, base)

</t>
<t tx="ekr.20230509052845.3087">def __new__(what) -&gt; int:
    # do not overload! (needed to avoid pyobj conversion)
    if isinstance(what, str) or isinstance(what, Optional[str]):
        return int._from_str(what, 10)
    else:
        return what.__int__()

</t>
<t tx="ekr.20230509052845.3088">def __int__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3089">@pure
@llvm
def __float__(self) -&gt; float:
    %tmp = sitofp i64 %self to double
    ret double %tmp

</t>
<t tx="ekr.20230509052845.309">  int replaceUsedVariable(id_t id, Var *newVar) final {
    return getActual()-&gt;doReplaceUsedVariable(id, newVar);
  }
</t>
<t tx="ekr.20230509052845.3090">def __complex__(self) -&gt; complex:
    return complex(float(self), 0.0)

</t>
<t tx="ekr.20230509052845.3091">def __index__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3092">def __repr__(self) -&gt; str:
    return self.__format__("")

</t>
<t tx="ekr.20230509052845.3093">def __copy__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3094">def __deepcopy__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3095">def __hash__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3096">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = icmp ne i64 %self, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3097">def __pos__(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3098">def __neg__(self) -&gt; int:
    return 0 - self

</t>
<t tx="ekr.20230509052845.3099">@pure
@llvm
def __abs__(self) -&gt; int:
    declare i64 @llvm.abs.i64(i64, i1)
    %0 = call i64 @llvm.abs.i64(i64 %self, i1 false)
    ret i64 %0

</t>
<t tx="ekr.20230509052845.31">def GetDomain(self):
    """Returns the domain of the B-Spline"""
    return (self.knots[self.degree - 1],
            self.knots[len(self.knots) - self.degree])

</t>
<t tx="ekr.20230509052845.310">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/types/types.h"
#include "codon/cir/value.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

class Func;
class Var;

@others
} // namespace ir
} // namespace codon

template &lt;typename T&gt;
struct fmt::formatter&lt;T,
                      std::enable_if_t&lt;std::is_base_of&lt;codon::ir::Var, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3100">@pure
@llvm
def __lshift__(self, other: int) -&gt; int:
    %0 = shl i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.3101">@pure
@llvm
def __rshift__(self, other: int) -&gt; int:
    %0 = ashr i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.3102">@pure
@commutative
@llvm
def __add__(self, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fadd double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.3103">@pure
@commutative
@associative
@llvm
def __add__(self, b: int) -&gt; int:
    %tmp = add i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3104">@pure
@llvm
def __sub__(self, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fsub double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.3105">@pure
@llvm
def __sub__(self, b: int) -&gt; int:
    %tmp = sub i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3106">@pure
@commutative
@llvm
def __mul__(self, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fmul double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.3107">@pure
@commutative
@associative
@distributive
@llvm
def __mul__(self, b: int) -&gt; int:
    %tmp = mul i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3108">@pure
@llvm
def __floordiv__(self, other: float) -&gt; float:
    declare double @llvm.floor.f64(double)
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    %2 = call double @llvm.floor.f64(double %1)
    ret double %2

</t>
<t tx="ekr.20230509052845.3109">@pure
@llvm
def __floordiv__(self, b: int) -&gt; int:
    %tmp = sdiv i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.311">/// CIR object representing a variable.
class Var : public ReplaceableNodeBase&lt;Var&gt;, public IdMixin {
private:
  /// the variable's type
  types::Type *type;
  /// true if the variable is global
  bool global;
  /// true if the variable is external
  bool external;

public:
  static const char NodeId;

  /// Constructs a variable.
  /// @param type the variable's type
  /// @param global true if the variable is global
  /// @param external true if the variable is external
  /// @param name the variable's name
  explicit Var(types::Type *type, bool global = false, bool external = false,
               std::string name = "")
      : ReplaceableNodeBase(std::move(name)), type(type), global(global),
@others
  using Node::replaceUsedVariable;

  /// @return the type
  types::Type *getType() const { return getActual()-&gt;type; }
  /// Sets the type.
  /// @param t the new type
  void setType(types::Type *t) { getActual()-&gt;type = t; }

  /// @return true if the variable is global
  bool isGlobal() const { return getActual()-&gt;global; }
  /// Sets the global flag.
  /// @param v the new value
  void setGlobal(bool v = true) { getActual()-&gt;global = v; }

  /// @return true if the variable is external
  bool isExternal() const { return getActual()-&gt;external; }
  /// Sets the external flag.
  /// @param v the new value
  void setExternal(bool v = true) { getActual()-&gt;external = v; }

  std::string referenceString() const final {
    return fmt::format(FMT_STRING("{}.{}"), getName(), getId());
  }

  id_t getId() const override { return getActual()-&gt;id; }

protected:
  virtual std::vector&lt;Value *&gt; doGetUsedValues() const { return {}; }
  virtual int doReplaceUsedValue(id_t id, Value *newValue) { return 0; }

  virtual std::vector&lt;types::Type *&gt; doGetUsedTypes() const { return {type}; }
  virtual int doReplaceUsedType(const std::string &amp;name, types::Type *newType);

  virtual std::vector&lt;Var *&gt; doGetUsedVariables() const { return {}; }
  virtual int doReplaceUsedVariable(id_t id, Var *newVar) { return 0; }
};

</t>
<t tx="ekr.20230509052845.3110">@pure
@llvm
def __truediv__(self, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.3111">@pure
@llvm
def __truediv__(self, other: int) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = sitofp i64 %other to double
    %2 = fdiv double %0, %1
    ret double %2

</t>
<t tx="ekr.20230509052845.3112">@pure
@llvm
def __mod__(self, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = frem double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.3113">@pure
@llvm
def __mod__(a: int, b: int) -&gt; int:
    %tmp = srem i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3114">def __divmod__(self, other: float) -&gt; Tuple[float, float]:
    return float(self).__divmod__(other)

</t>
<t tx="ekr.20230509052845.3115">def __divmod__(self, other: int) -&gt; Tuple[int, int]:
    d = self // other
    m = self - d * other
    if m and ((other ^ m) &lt; 0):
        m += other
        d -= 1
    return (d, m)

</t>
<t tx="ekr.20230509052845.3116">@pure
@llvm
def __invert__(a: int) -&gt; int:
    %tmp = xor i64 %a, -1
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3117">@pure
@commutative
@associative
@llvm
def __and__(a: int, b: int) -&gt; int:
    %tmp = and i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3118">@pure
@commutative
@associative
@llvm
def __or__(a: int, b: int) -&gt; int:
    %tmp = or i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3119">@pure
@commutative
@associative
@llvm
def __xor__(a: int, b: int) -&gt; int:
    %tmp = xor i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.312">        external(external) {}

  virtual ~Var() noexcept = default;

  std::vector&lt;Value *&gt; getUsedValues() final { return getActual()-&gt;doGetUsedValues(); }
  std::vector&lt;const Value *&gt; getUsedValues() const final {
    auto ret = getActual()-&gt;doGetUsedValues();
    return std::vector&lt;const Value *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509052845.3120">@pure
@llvm
def __bitreverse__(a: int) -&gt; int:
    declare i64 @llvm.bitreverse.i64(i64 %a)
    %tmp = call i64 @llvm.bitreverse.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3121">@pure
@llvm
def __bswap__(a: int) -&gt; int:
    declare i64 @llvm.bswap.i64(i64 %a)
    %tmp = call i64 @llvm.bswap.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3122">@pure
@llvm
def __ctpop__(a: int) -&gt; int:
    declare i64 @llvm.ctpop.i64(i64 %a)
    %tmp = call i64 @llvm.ctpop.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3123">@pure
@llvm
def __ctlz__(a: int) -&gt; int:
    declare i64 @llvm.ctlz.i64(i64 %a, i1 %is_zero_undef)
    %tmp = call i64 @llvm.ctlz.i64(i64 %a, i1 false)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3124">@pure
@llvm
def __cttz__(a: int) -&gt; int:
    declare i64 @llvm.cttz.i64(i64 %a, i1 %is_zero_undef)
    %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3125">@pure
@llvm
def __eq__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp oeq double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.3126">@pure
@llvm
def __eq__(a: int, b: int) -&gt; bool:
    %tmp = icmp eq i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3127">@pure
@llvm
def __ne__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp one double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.3128">@pure
@llvm
def __ne__(a: int, b: int) -&gt; bool:
    %tmp = icmp ne i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3129">@pure
@llvm
def __lt__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp olt double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.313">  int replaceUsedValue(id_t id, Value *newValue) final {
    return doReplaceUsedValue(id, newValue);
  }
</t>
<t tx="ekr.20230509052845.3130">@pure
@llvm
def __lt__(a: int, b: int) -&gt; bool:
    %tmp = icmp slt i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3131">@pure
@llvm
def __gt__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp ogt double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.3132">@pure
@llvm
def __gt__(a: int, b: int) -&gt; bool:
    %tmp = icmp sgt i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3133">@pure
@llvm
def __le__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp ole double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.3134">@pure
@llvm
def __le__(a: int, b: int) -&gt; bool:
    %tmp = icmp sle i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3135">@pure
@llvm
def __ge__(self, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp oge double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.3136">@pure
@llvm
def __ge__(a: int, b: int) -&gt; bool:
    %tmp = icmp sge i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.3137">def __pow__(self, exp: float) -&gt; float:
    return float(self) ** exp

</t>
<t tx="ekr.20230509052845.3138">def __pow__(self, exp: int) -&gt; int:
    if exp &lt; 0:
        return 0
    result = 1
    while True:
        if exp &amp; 1:
            result *= self
        exp &gt;&gt;= 1
        if not exp:
            break
        self *= self
    return result

</t>
<t tx="ekr.20230509052845.3139">def popcnt(self) -&gt; int:
    return Int[64](self).popcnt()

</t>
<t tx="ekr.20230509052845.314">  using Node::replaceUsedValue;

  std::vector&lt;types::Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
</t>
<t tx="ekr.20230509052845.3140">@nocapture
@llvm
def __atomic_xchg__(d: Ptr[int], b: int) -&gt; None:
    %tmp = atomicrmw xchg ptr %d, i64 %b seq_cst
    ret {} {}

</t>
<t tx="ekr.20230509052845.3141">@nocapture
@llvm
def __atomic_add__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw add ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3142">@nocapture
@llvm
def __atomic_sub__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw sub ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3143">@nocapture
@llvm
def __atomic_and__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw and ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3144">@nocapture
@llvm
def __atomic_nand__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw nand ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3145">@nocapture
@llvm
def __atomic_or__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw or ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3146">@nocapture
@llvm
def __atomic_xor__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw xor ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3147">@nocapture
@llvm
def __atomic_min__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw min ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3148">@nocapture
@llvm
def __atomic_max__(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw max ptr %d, i64 %b seq_cst
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.3149">def __match__(self, i: int) -&gt; bool:
    return self == i

</t>
<t tx="ekr.20230509052845.315">  int replaceUsedType(const std::string &amp;name, types::Type *newType) final {
    return getActual()-&gt;doReplaceUsedType(name, newType);
  }
</t>
<t tx="ekr.20230509052845.3150">@property
def real(self) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.3151">@property
def imag(self) -&gt; int:
    return 0
</t>
<t tx="ekr.20230509052845.3152">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative, distributive

@others
i8 = Int[8]
i16 = Int[16]
i32 = Int[32]
i64 = Int[64]
u8 = UInt[8]
u16 = UInt[16]
u32 = UInt[32]
u64 = UInt[64]
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3153">def check_N(N: Static[int]):
    if N &lt;= 0:
        compile_error("N must be greater than 0")
    pass

</t>
<t tx="ekr.20230509052845.3154">@extend
class Int:
    @others
</t>
<t tx="ekr.20230509052845.3155">def __new__() -&gt; Int[N]:
    check_N(N)
    return Int[N](0)

</t>
<t tx="ekr.20230509052845.3156">def __new__(what: Int[N]) -&gt; Int[N]:
    check_N(N)
    return what

</t>
<t tx="ekr.20230509052845.3157">def __new__(what: int) -&gt; Int[N]:
    check_N(N)
    if N &lt; 64:
        return __internal__.int_trunc(what, 64, N)
    elif N == 64:
        return what
    else:
        return __internal__.int_sext(what, 64, N)

</t>
<t tx="ekr.20230509052845.3158">@pure
@llvm
def __new__(what: UInt[N]) -&gt; Int[N]:
    ret i{=N} %what

</t>
<t tx="ekr.20230509052845.3159">def __new__(what: str) -&gt; Int[N]:
    check_N(N)
    ret = Int[N]()
    i = 0
    sign = Int[N](1)
    if i &lt; what.len and what.ptr[0] == byte(45):
        sign = Int[N](-1)
        i += 1
    while i &lt; what.len:
        if what.ptr[i] &lt; byte(48) or what.ptr[i] &gt;= byte(58):
            raise ValueError("Invalid integer string")
        ret = ret * Int[N](10) + Int[N](int(what.ptr[i]) - 48)
        i += 1
    return sign * ret

</t>
<t tx="ekr.20230509052845.316">  using Node::replaceUsedType;

  std::vector&lt;Var *&gt; getUsedVariables() final { return doGetUsedVariables(); }
  std::vector&lt;const Var *&gt; getUsedVariables() const final {
    auto ret = doGetUsedVariables();
    return std::vector&lt;const Var *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509052845.3160">def __int__(self) -&gt; int:
    if N &gt; 64:
        return __internal__.int_trunc(self, N, 64)
    elif N == 64:
        return self
    else:
        return __internal__.int_sext(self, N, 64)

</t>
<t tx="ekr.20230509052845.3161">def __index__(self) -&gt; int:
    return int(self)

</t>
<t tx="ekr.20230509052845.3162">def __copy__(self) -&gt; Int[N]:
    return self

</t>
<t tx="ekr.20230509052845.3163">def __deepcopy__(self) -&gt; Int[N]:
    return self

</t>
<t tx="ekr.20230509052845.3164">def __hash__(self) -&gt; int:
    return int(self)

</t>
<t tx="ekr.20230509052845.3165">@pure
@llvm
def __float__(self) -&gt; float:
    %0 = sitofp i{=N} %self to double
    ret double %0

</t>
<t tx="ekr.20230509052845.3166">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = icmp ne i{=N} %self, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3167">def __pos__(self) -&gt; Int[N]:
    return self

</t>
<t tx="ekr.20230509052845.3168">@pure
@llvm
def __neg__(self) -&gt; Int[N]:
    %0 = sub i{=N} 0, %self
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3169">@pure
@llvm
def __invert__(self) -&gt; Int[N]:
    %0 = xor i{=N} %self, -1
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.317">  int replaceUsedVariable(id_t id, Var *newVar) final {
    return getActual()-&gt;doReplaceUsedVariable(id, newVar);
  }
</t>
<t tx="ekr.20230509052845.3170">@pure
@llvm
def __abs__(self) -&gt; Int[N]:
    declare i{=N} @llvm.abs.i{=N}(i{=N}, i1)
    %0 = call i{=N} @llvm.abs.i{=N}(i{=N} %self, i1 false)
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3171">@pure
@commutative
@associative
@llvm
def __add__(self, other: Int[N]) -&gt; Int[N]:
    %0 = add i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3172">@pure
@llvm
def __sub__(self, other: Int[N]) -&gt; Int[N]:
    %0 = sub i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3173">@pure
@commutative
@associative
@distributive
@llvm
def __mul__(self, other: Int[N]) -&gt; Int[N]:
    %0 = mul i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3174">@pure
@llvm
def _floordiv(self, other: Int[N]) -&gt; Int[N]:
    %0 = sdiv i{=N} %self, %other
    ret i{=N} %0
</t>
<t tx="ekr.20230509052845.3175">def __floordiv__(self, other: Int[N]) -&gt; Int[N]:
    if N &gt; 128:
        compile_error("division is not supported on Int[N] when N &gt; 128")
    return self._floordiv(other)

</t>
<t tx="ekr.20230509052845.3176">@pure
@llvm
def __truediv__(self, other: Int[N]) -&gt; float:
    %0 = sitofp i{=N} %self to double
    %1 = sitofp i{=N} %other to double
    %2 = fdiv double %0, %1
    ret double %2

</t>
<t tx="ekr.20230509052845.3177">@pure
@llvm
def _mod(self, other: Int[N]) -&gt; Int[N]:
    %0 = srem i{=N} %self, %other
    ret i{=N} %0
</t>
<t tx="ekr.20230509052845.3178">def __mod__(self, other: Int[N]) -&gt; Int[N]:
    if N &gt; 128:
        compile_error("modulus is not supported on Int[N] when N &gt; 128")
    return self._mod(other)

</t>
<t tx="ekr.20230509052845.3179">def __divmod__(self, other: Int[N]) -&gt; Tuple[Int[N], Int[N]]:
    d = self // other
    m = self - d * other
    if m and ((other ^ m) &lt; Int[N](0)):
        m += other
        d -= Int[N](1)
    return (d, m)

</t>
<t tx="ekr.20230509052845.318">/// Value that contains an unowned variable reference.
class VarValue : public AcceptorExtend&lt;VarValue, Value&gt; {
private:
  /// the referenced var
  Var *val;

public:
  static const char NodeId;

  /// Constructs a variable value.
  /// @param val the referenced value
  /// @param name the name
  explicit VarValue(Var *val, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val) {}

  /// @return the variable
  Var *getVar() { return val; }
  /// @return the variable
  const Var *getVar() const { return val; }
  /// Sets the variable.
  /// @param v the new variable
  void setVar(Var *v) { val = v; }

private:
  types::Type *doGetType() const override { return val-&gt;getType(); }

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {val}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.3180">@pure
@llvm
def __lshift__(self, other: Int[N]) -&gt; Int[N]:
    %0 = shl i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3181">@pure
@llvm
def __rshift__(self, other: Int[N]) -&gt; Int[N]:
    %0 = ashr i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3182">@pure
@llvm
def __eq__(self, other: Int[N]) -&gt; bool:
    %0 = icmp eq i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3183">@pure
@llvm
def __ne__(self, other: Int[N]) -&gt; bool:
    %0 = icmp ne i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3184">@pure
@llvm
def __lt__(self, other: Int[N]) -&gt; bool:
    %0 = icmp slt i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3185">@pure
@llvm
def __gt__(self, other: Int[N]) -&gt; bool:
    %0 = icmp sgt i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3186">@pure
@llvm
def __le__(self, other: Int[N]) -&gt; bool:
    %0 = icmp sle i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3187">@pure
@llvm
def __ge__(self, other: Int[N]) -&gt; bool:
    %0 = icmp sge i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3188">@pure
@commutative
@associative
@llvm
def __and__(self, other: Int[N]) -&gt; Int[N]:
    %0 = and i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3189">@pure
@commutative
@associative
@llvm
def __or__(self, other: Int[N]) -&gt; Int[N]:
    %0 = or i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.319">/// Value that represents a pointer.
class PointerValue : public AcceptorExtend&lt;PointerValue, Value&gt; {
private:
  /// the referenced var
  Var *val;

public:
  static const char NodeId;

  /// Constructs a variable value.
  /// @param val the referenced value
  /// @param name the name
  explicit PointerValue(Var *val, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val) {}

  /// @return the variable
  Var *getVar() { return val; }
  /// @return the variable
  const Var *getVar() const { return val; }
  /// Sets the variable.
  /// @param v the new variable
  void setVar(Var *v) { val = v; }

private:
  types::Type *doGetType() const override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {val}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.3190">@pure
@commutative
@associative
@llvm
def __xor__(self, other: Int[N]) -&gt; Int[N]:
    %0 = xor i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3191">def __pow__(self, exp: Int[N]) -&gt; Int[N]:
    zero = Int[N](0)
    one = Int[N](1)

    if exp &lt; zero:
        return zero
    result = one
    while True:
        if exp &amp; one:
            result *= self
        exp &gt;&gt;= one
        if not exp:
            break
        self *= self
    return result

</t>
<t tx="ekr.20230509052845.3192">def __repr__(self) -&gt; str:
    return f"Int[{N}]({self.__str__()})"

</t>
<t tx="ekr.20230509052845.3193">@pure
@llvm
def _popcnt(self) -&gt; Int[N]:
    declare i{=N} @llvm.ctpop.i{=N}(i{=N})
    %0 = call i{=N} @llvm.ctpop.i{=N}(i{=N} %self)
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3194">def popcnt(self) -&gt; int:
    return int(self._popcnt())

</t>
<t tx="ekr.20230509052845.3195">def len() -&gt; int:
    return N


</t>
<t tx="ekr.20230509052845.3196">@extend
class UInt:
    @others
</t>
<t tx="ekr.20230509052845.3197">def __new__() -&gt; UInt[N]:
    check_N(N)
    return UInt[N](0)

</t>
<t tx="ekr.20230509052845.3198">def __new__(what: UInt[N]) -&gt; UInt[N]:
    check_N(N)
    return what

</t>
<t tx="ekr.20230509052845.3199">def __new__(what: int) -&gt; UInt[N]:
    check_N(N)
    if N &lt; 64:
        return UInt[N](__internal__.int_trunc(what, 64, N))
    elif N == 64:
        return UInt[N](Int[N](what))
    else:
        return UInt[N](__internal__.int_sext(what, 64, N))

</t>
<t tx="ekr.20230509052845.32">def __call__(self, u):
    """Calculates a point of the B-Spline using de Boors Algorithm"""
    dom = self.GetDomain()
    if u &lt; dom[0] or u &gt; dom[1]:
        raise ValueError("Function value not in domain")
    if u == dom[0]:
        return self.points[0]
    if u == dom[1]:
        return self.points[-1]
    I = self.GetIndex(u)
    d = [self.points[I - self.degree + 1 + ii]
         for ii in range(self.degree + 1)]
    U = self.knots
    for ik in range(1, self.degree + 1):
        for ii in range(I - self.degree + ik + 1, I + 2):
            ua = U[ii + self.degree - ik]
            ub = U[ii - 1]
            co1 = (ua - u) / (ua - ub)
            co2 = (u - ub) / (ua - ub)
            index = ii - I + self.degree - ik - 1
            d[index] = d[index].linear_combination(d[index + 1], co1, co2)
    return d[0]

</t>
<t tx="ekr.20230509052845.320"></t>
<t tx="ekr.20230509052845.3200">@pure
@llvm
def __new__(what: Int[N]) -&gt; UInt[N]:
    ret i{=N} %what

</t>
<t tx="ekr.20230509052845.3201">def __new__(what: str) -&gt; UInt[N]:
    check_N(N)
    return UInt[N](Int[N](what))

</t>
<t tx="ekr.20230509052845.3202">def __int__(self) -&gt; int:
    if N &gt; 64:
        return __internal__.int_trunc(self, N, 64)
    elif N == 64:
        return Int[64](self)
    else:
        return __internal__.int_zext(self, N, 64)

</t>
<t tx="ekr.20230509052845.3203">def __index__(self) -&gt; int:
    return int(self)

</t>
<t tx="ekr.20230509052845.3204">def __copy__(self) -&gt; UInt[N]:
    return self

</t>
<t tx="ekr.20230509052845.3205">def __deepcopy__(self) -&gt; UInt[N]:
    return self

</t>
<t tx="ekr.20230509052845.3206">def __hash__(self) -&gt; int:
    return int(self)

</t>
<t tx="ekr.20230509052845.3207">@pure
@llvm
def __float__(self) -&gt; float:
    %0 = uitofp i{=N} %self to double
    ret double %0

</t>
<t tx="ekr.20230509052845.3208">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = icmp ne i{=N} %self, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3209">def __pos__(self) -&gt; UInt[N]:
    return self

</t>
<t tx="ekr.20230509052845.321">@path C:/Repos/codon/codon/cir/analyze/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/module.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace analyze {

/// Analysis result base struct.
struct Result {
  virtual ~Result() noexcept = default;
};

@others
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3210">@pure
@llvm
def __neg__(self) -&gt; UInt[N]:
    %0 = sub i{=N} 0, %self
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3211">@pure
@llvm
def __invert__(self) -&gt; UInt[N]:
    %0 = xor i{=N} %self, -1
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3212">def __abs__(self) -&gt; UInt[N]:
    return self

</t>
<t tx="ekr.20230509052845.3213">@pure
@commutative
@associative
@llvm
def __add__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = add i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3214">@pure
@llvm
def __sub__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = sub i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3215">@pure
@commutative
@associative
@distributive
@llvm
def __mul__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = mul i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3216">@pure
@llvm
def _floordiv(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = udiv i{=N} %self, %other
    ret i{=N} %0
</t>
<t tx="ekr.20230509052845.3217">def __floordiv__(self, other: UInt[N]) -&gt; UInt[N]:
    if N &gt; 128:
        compile_error("division is not supported on UInt[N] when N &gt; 128")
    return self._floordiv(other)

</t>
<t tx="ekr.20230509052845.3218">@pure
@llvm
def __truediv__(self, other: UInt[N]) -&gt; float:
    %0 = uitofp i{=N} %self to double
    %1 = uitofp i{=N} %other to double
    %2 = fdiv double %0, %1
    ret double %2

</t>
<t tx="ekr.20230509052845.3219">@pure
@llvm
def _mod(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = urem i{=N} %self, %other
    ret i{=N} %0
</t>
<t tx="ekr.20230509052845.322">/// Base class for IR analyses.
class Analysis {
private:
  transform::PassManager *manager = nullptr;

public:
  virtual ~Analysis() noexcept = default;

  /// @return a unique key for this pass
  virtual std::string getKey() const = 0;

  /// Execute the analysis.
  /// @param module the module
  virtual std::unique_ptr&lt;Result&gt; run(const Module *module) = 0;

  /// Sets the manager.
  /// @param mng the new manager
  void setManager(transform::PassManager *mng) { manager = mng; }
@others
private:
  analyze::Result *doGetAnalysis(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509052845.3220">def __mod__(self, other: UInt[N]) -&gt; UInt[N]:
    if N &gt; 128:
        compile_error("modulus is not supported on UInt[N] when N &gt; 128")
    return self._mod(other)

</t>
<t tx="ekr.20230509052845.3221">def __divmod__(self, other: UInt[N]) -&gt; Tuple[UInt[N], UInt[N]]:
    return (self // other, self % other)

</t>
<t tx="ekr.20230509052845.3222">@pure
@llvm
def __lshift__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = shl i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3223">@pure
@llvm
def __rshift__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = lshr i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3224">@pure
@llvm
def __eq__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp eq i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3225">@pure
@llvm
def __ne__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp ne i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3226">@pure
@llvm
def __lt__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp ult i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3227">@pure
@llvm
def __gt__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp ugt i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3228">@pure
@llvm
def __le__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp ule i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3229">@pure
@llvm
def __ge__(self, other: UInt[N]) -&gt; bool:
    %0 = icmp uge i{=N} %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.323">  /// Returns the result of a given analysis.
  /// @param key the analysis key
  template &lt;typename AnalysisType&gt;
  AnalysisType *getAnalysisResult(const std::string &amp;key) {
    return static_cast&lt;AnalysisType *&gt;(doGetAnalysis(key));
  }

</t>
<t tx="ekr.20230509052845.3230">@pure
@commutative
@associative
@llvm
def __and__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = and i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3231">@pure
@commutative
@associative
@llvm
def __or__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = or i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3232">@pure
@commutative
@associative
@llvm
def __xor__(self, other: UInt[N]) -&gt; UInt[N]:
    %0 = xor i{=N} %self, %other
    ret i{=N} %0

</t>
<t tx="ekr.20230509052845.3233">def __pow__(self, exp: UInt[N]) -&gt; UInt[N]:
    zero = UInt[N](0)
    one = UInt[N](1)

    if exp &lt; zero:
        return zero
    result = one
    while True:
        if exp &amp; one:
            result *= self
        exp &gt;&gt;= one
        if not exp:
            break
        self *= self
    return result

</t>
<t tx="ekr.20230509052845.3234">def __repr__(self) -&gt; str:
    return f"UInt[{N}]({self.__str__()})"

</t>
<t tx="ekr.20230509052845.3235">def popcnt(self) -&gt; int:
    return int(Int[N](self)._popcnt())

</t>
<t tx="ekr.20230509052845.3236">def len() -&gt; int:
    return N

</t>
<t tx="ekr.20230509052845.3237">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3238">@extend
class Optional:
    @others
</t>
<t tx="ekr.20230509052845.3239">def __new__() -&gt; Optional[T]:
    if isinstance(T, ByVal):
        return __internal__.opt_tuple_new(T)
    else:
        return __internal__.opt_ref_new(T)

</t>
<t tx="ekr.20230509052845.324"></t>
<t tx="ekr.20230509052845.3240">def __new__(what: T) -&gt; Optional[T]:
    if isinstance(T, ByVal):
        return __internal__.opt_tuple_new_arg(what, T)
    else:
        return __internal__.opt_ref_new_arg(what, T)

</t>
<t tx="ekr.20230509052845.3241">def __has__(self) -&gt; bool:
    if isinstance(T, ByVal):
        return __internal__.opt_tuple_bool(self, T)
    else:
        return __internal__.opt_ref_bool(self, T)

</t>
<t tx="ekr.20230509052845.3242">def __val__(self) -&gt; T:
    if isinstance(T, ByVal):
        return __internal__.opt_tuple_invert(self, T)
    else:
        return __internal__.opt_ref_invert(self, T)

</t>
<t tx="ekr.20230509052845.3243">def __val_or__(self, default: T):
    if self.__has__():
        return self.__val__()
    return default

</t>
<t tx="ekr.20230509052845.3244">def __bool__(self) -&gt; bool:
    if not self.__has__():
        return False
    if hasattr(self.__val__(), "__bool__"):
        return self.__val__().__bool__()
    else:
        return True

</t>
<t tx="ekr.20230509052845.3245">def __eq__(self, other: T) -&gt; bool:
    if self is None:
        return False
    return self.__val__() == other

</t>
<t tx="ekr.20230509052845.3246">def __eq__(self, other: Optional[T]) -&gt; bool:
    if (self is None) or (other is None):
        return (self is None) and (other is None)
    return self.__val__() == other.__val__()

</t>
<t tx="ekr.20230509052845.3247">def __ne__(self, other: T) -&gt; bool:
    if self is None:
        return True
    return self.__val__() != other

</t>
<t tx="ekr.20230509052845.3248">def __ne__(self, other: Optional[T]) -&gt; bool:
    if (self is None) or (other is None):
        return not ((self is None) and (other is None))
    return self.__val__() != other.__val__()

</t>
<t tx="ekr.20230509052845.3249">def __str__(self) -&gt; str:
    return "None" if self is None else str(self.__val__())

</t>
<t tx="ekr.20230509052845.325">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/dominator.h"
#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

/// Information about how a function argument is captured.
struct CaptureInfo {
  /// vector of other argument indices capturing this one
  std::vector&lt;unsigned&gt; argCaptures;
  /// true if the return value of the function captures this argument
  bool returnCaptures = false;
  /// true if this argument is externally captured e.g. by assignment to global
  bool externCaptures = false;
  /// true if this argument is modified
  bool modified = false;

  /// @return true if anything captures
  operator bool() const {
    return !argCaptures.empty() || returnCaptures || externCaptures;
  }

  /// Returns an instance denoting no captures.
  /// @return an instance denoting no captures
  static CaptureInfo nothing() { return {}; }

  /// Returns an instance denoting unknown capture status.
  /// @param func the function containing this argument
  /// @param type the argument's type
  /// @return an instance denoting unknown capture status
  static CaptureInfo unknown(const Func *func, types::Type *type);
};

/// Capture analysis result.
struct CaptureResult : public Result {
  /// the corresponding reaching definitions result
  RDResult *rdResult = nullptr;

  /// the corresponding dominator result
  DominatorResult *domResult = nullptr;

  /// map from function id to capture information, where
  /// each element of the value vector corresponds to an
  /// argument of the function
  std::unordered_map&lt;id_t, std::vector&lt;CaptureInfo&gt;&gt; results;
};

@others
CaptureInfo escapes(const BodiedFunc *func, const Value *value, CaptureResult *cr);

} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3250">def __repr__(self) -&gt; str:
    return "None" if self is None else self.__val__().__repr__()

</t>
<t tx="ekr.20230509052845.3251">def __is_optional__(self, other: Optional[T]) -&gt; bool:
    self_has = self.__has__()
    other_has = other.__has__()
    if (not self_has) or (not other_has):
        return (not self_has) and (not other_has)
    return self.__val__() is other.__val__()

</t>
<t tx="ekr.20230509052845.3252">optional = Optional

</t>
<t tx="ekr.20230509052845.3253">def unwrap(opt: Optional[T], T: type) -&gt; T:
    if opt.__has__():
        return opt.__val__()
    raise ValueError("optional is None")
</t>
<t tx="ekr.20230509052845.3254">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3255">@extend
class Ptr:
    @others
</t>
<t tx="ekr.20230509052845.3256">@pure
@llvm
def __new__() -&gt; Ptr[T]:
    ret ptr null

</t>
<t tx="ekr.20230509052845.3257">@__internal__
def __new__(sz: int) -&gt; Ptr[T]:
    pass

</t>
<t tx="ekr.20230509052845.3258">@pure
@derives
@llvm
def __new__(other: Ptr[T]) -&gt; Ptr[T]:
    ret ptr %other

</t>
<t tx="ekr.20230509052845.3259">@pure
@derives
@llvm
def __new__(other: Ptr[byte]) -&gt; Ptr[T]:
    ret ptr %other

</t>
<t tx="ekr.20230509052845.326">/// Capture analysis that runs on all functions.
class CaptureAnalysis : public Analysis {
private:
  /// the reaching definitions analysis key
  std::string rdAnalysisKey;
  /// the dominator analysis key
  std::string domAnalysisKey;

public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  /// Initializes a capture analysis.
  /// @param rdAnalysisKey the reaching definitions analysis key
  /// @param domAnalysisKey the dominator analysis key
  explicit CaptureAnalysis(std::string rdAnalysisKey, std::string domAnalysisKey)
      : rdAnalysisKey(std::move(rdAnalysisKey)),
        domAnalysisKey(std::move(domAnalysisKey)) {}

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3260">@pure
@llvm
def __int__(self) -&gt; int:
    %0 = ptrtoint ptr %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.3261">@pure
@llvm
def __copy__(self) -&gt; Ptr[T]:
    ret ptr %self

</t>
<t tx="ekr.20230509052845.3262">@pure
@llvm
def __bool__(self) -&gt; bool:
    %0 = icmp ne ptr %self, null
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3263">@pure
@derives
@llvm
def __getitem__(self, index: int) -&gt; T:
    %0 = getelementptr {=T}, ptr %self, i64 %index
    %1 = load {=T}, ptr %0
    ret {=T} %1

</t>
<t tx="ekr.20230509052845.3264">@self_captures
@llvm
def __setitem__(self, index: int, what: T) -&gt; None:
    %0 = getelementptr {=T}, ptr %self, i64 %index
    store {=T} %what, ptr %0
    ret {} {}

</t>
<t tx="ekr.20230509052845.3265">@pure
@derives
@llvm
def __add__(self, other: int) -&gt; Ptr[T]:
    %0 = getelementptr {=T}, ptr %self, i64 %other
    ret ptr %0

</t>
<t tx="ekr.20230509052845.3266">@pure
@llvm
def __sub__(self, other: Ptr[T]) -&gt; int:
    %0 = ptrtoint ptr %self to i64
    %1 = ptrtoint ptr %other to i64
    %2 = sub i64 %0, %1
    %3 = sdiv exact i64 %2, ptrtoint (ptr getelementptr ({=T}, {=T}* null, i32 1) to i64)
    ret i64 %3

</t>
<t tx="ekr.20230509052845.3267">@pure
@derives
@llvm
def __sub__(self, other: int) -&gt; Ptr[T]:
    %0 = sub i64 0, %other
    %1 = getelementptr {=T}, {=T}* %self, i64 %0
    ret {=T}* %1

</t>
<t tx="ekr.20230509052845.3268">@pure
@llvm
def __eq__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp eq ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3269">@pure
@llvm
def __ne__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp ne ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.327">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/cir.h"
#include "codon/cir/util/iterators.h"

#define DEFAULT_VISIT(x)                                                               \
  void visit(const x *v) override { defaultInsert(v); }

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

class CFGraph;

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3270">@pure
@llvm
def __lt__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp slt ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3271">@pure
@llvm
def __gt__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp sgt ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3272">@pure
@llvm
def __le__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp sle ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3273">@pure
@llvm
def __ge__(self, other: Ptr[T]) -&gt; bool:
    %0 = icmp sge ptr %self, %other
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.3274">@nocapture
@llvm
def __prefetch_r0__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 0, i32 0, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3275">@nocapture
@llvm
def __prefetch_r1__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 0, i32 1, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3276">@nocapture
@llvm
def __prefetch_r2__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 0, i32 2, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3277">@nocapture
@llvm
def __prefetch_r3__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 0, i32 3, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3278">@nocapture
@llvm
def __prefetch_w0__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 1, i32 0, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3279">@nocapture
@llvm
def __prefetch_w1__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 1, i32 1, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.328">class CFBlock : public IdMixin {
private:
  /// the in-order list of values in this block
  std::list&lt;const Value *&gt; values;
  /// an un-ordered list of successor blocks
  std::unordered_set&lt;CFBlock *&gt; successors;
  /// an un-ordered list of successor blocks
  std::unordered_set&lt;CFBlock *&gt; predecessors;
  /// the block's name
  std::string name;
  /// the graph
  CFGraph *graph;

public:
  /// Constructs a control-flow block.
  /// @param graph the parent graph
  /// @param name the block's name
  explicit CFBlock(CFGraph *graph, std::string name = "")
      : name(std::move(name)), graph(graph) {}

  virtual ~CFBlock() noexcept = default;

  /// @return this block's name
  std::string getName() const { return name; }

  /// @return an iterator to the first value
  auto begin() { return values.begin(); }
  /// @return an iterator beyond the last value
  auto end() { return values.end(); }
  /// @return an iterator to the first value
  auto begin() const { return values.begin(); }
  /// @return an iterator beyond the last value
  auto end() const { return values.end(); }
  /// @return a pointer to the first value
  const Value *front() const { return values.front(); }
  /// @return a pointer to the last value
  const Value *back() const { return values.back(); }

  /// Inserts a value at a given position.
  /// @param it the position
  /// @param v the new value
  /// @param an iterator to the new value
  template &lt;typename It&gt; auto insert(It it, const Value *v) {
    values.insert(it, v);
    reg(v);
  }
@others
  /// @return an iterator to the first predecessor
  auto predecessors_begin() { return predecessors.begin(); }
  /// @return an iterator beyond the last predecessor
  auto predecessors_end() { return predecessors.end(); }
  /// @return an iterator to the first predecessor
  auto predecessors_begin() const { return predecessors.begin(); }
  /// @return an iterator beyond the last predecessor
  auto predecessors_end() const { return predecessors.end(); }

  /// @return the graph
  CFGraph *getGraph() { return graph; }
  /// @return the graph
  const CFGraph *getGraph() const { return graph; }
  /// Sets the graph.
  /// @param g the new graph
  void setGraph(CFGraph *g) { graph = g; }

private:
  void reg(const Value *v);
};

</t>
<t tx="ekr.20230509052845.3280">@nocapture
@llvm
def __prefetch_w2__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 1, i32 2, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3281">@nocapture
@llvm
def __prefetch_w3__(self) -&gt; None:
    declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
    call void @llvm.prefetch(ptr %self, i32 1, i32 3, i32 1)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3282">@pure
@derives
@llvm
def as_byte(self) -&gt; Ptr[byte]:
    ret ptr %self

</t>
<t tx="ekr.20230509052845.3283">def __repr__(self) -&gt; str:
    return self.__format__("")

</t>
<t tx="ekr.20230509052845.3284">ptr = Ptr
Jar = Ptr[byte]

</t>
<t tx="ekr.20230509052845.3285"># Forward declarations
class List:
    len: int
    arr: Array[T]
    T: type

</t>
<t tx="ekr.20230509052845.3286">@extend
class NoneType:
    @others
</t>
<t tx="ekr.20230509052845.3287">def __new__() -&gt; NoneType:
    return ()

</t>
<t tx="ekr.20230509052845.3288">def __eq__(self, other: NoneType):
    return True

</t>
<t tx="ekr.20230509052845.3289">def __ne__(self, other: NoneType):
    return False

</t>
<t tx="ekr.20230509052845.329">  /// Inserts a value at the back.
  /// @param v the new value
  void push_back(const Value *v) {
    values.push_back(v);
    reg(v);
  }
</t>
<t tx="ekr.20230509052845.3290">def __bool__(self) -&gt; bool:
    return False

</t>
<t tx="ekr.20230509052845.3291">def __repr__(self) -&gt; str:
    return "None"
</t>
<t tx="ekr.20230509052845.3292">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3293">@tuple
class range:
    start: int
    stop: int
    step: int

    # Magic methods

    @others
</t>
<t tx="ekr.20230509052845.3294">def __new__(start: int, stop: int, step: int) -&gt; range:
    if step == 0:
        raise ValueError("range() step argument must not be zero")
    return (start, stop, step)

</t>
<t tx="ekr.20230509052845.3295">def __new__(start: int, stop: int) -&gt; range:
    return (start, stop, 1)

</t>
<t tx="ekr.20230509052845.3296">def __new__(stop: int) -&gt; range:
    return (0, stop, 1)

</t>
<t tx="ekr.20230509052845.3297">def _get(self, idx: int) -&gt; int:
    return self.start + (idx * self.step)

</t>
<t tx="ekr.20230509052845.3298">def __getitem__(self, idx: int) -&gt; int:
    n = self.__len__()
    if idx &lt; 0:
        idx += n
    if idx &lt; 0 or idx &gt;= n:
        raise IndexError("range object index out of range")
    return self._get(idx)

</t>
<t tx="ekr.20230509052845.3299">def __getitem__(self, s: Slice) -&gt; range:
    if s.start is None and s.stop is None and s.step is None:
        return self
    else:
        start, stop, step, length = s.adjust_indices(self.__len__())
        substep = self.step * step
        substart = self._get(start)
        substop = self._get(stop)
        return range(substart, substop, substep)

</t>
<t tx="ekr.20230509052845.33">def GetIndex(self, u):
    dom = self.GetDomain()
    for ii in range(self.degree - 1, len(self.knots) - self.degree):
        if u &gt;= self.knots[ii] and u &lt; self.knots[ii + 1]:
            I = ii
            break
    else:
        I = dom[1] - 1
    return I

</t>
<t tx="ekr.20230509052845.330">  /// Erases a value at the given position.
  /// @param it the position
  /// @return an iterator following the removed value
  template &lt;typename It&gt; auto erase(It it) { values.erase(it); }

  /// @return an iterator to the first successor
  auto successors_begin() { return successors.begin(); }
  /// @return an iterator beyond the last successor
  auto successors_end() { return successors.end(); }
  /// @return an iterator to the first successor
  auto successors_begin() const { return successors.begin(); }
  /// @return an iterator beyond the last successor
  auto successors_end() const { return successors.end(); }
</t>
<t tx="ekr.20230509052845.3300">def __contains__(self, idx: int) -&gt; bool:
    start, stop, step = self.start, self.stop, self.step
    if (step &gt; 0 and not (start &lt;= idx &lt; stop)) or (
        step &lt; 0 and not (stop &lt; idx &lt;= start)
    ):
        return False
    return (idx - start) % step == 0

</t>
<t tx="ekr.20230509052845.3301">def _index(self, n: int) -&gt; int:
    return (n - self.start) // self.step

</t>
<t tx="ekr.20230509052845.3302">def index(self, n: int) -&gt; int:
    if n in self:
        return self._index(n)
    else:
        raise ValueError(str(n) + " is not in range")

</t>
<t tx="ekr.20230509052845.3303">def count(self, n: int) -&gt; int:
    return int(n in self)

</t>
<t tx="ekr.20230509052845.3304">def __iter__(self) -&gt; Generator[int]:
    start, stop, step = self.start, self.stop, self.step
    i = start
    if step &gt; 0:
        while i &lt; stop:
            yield i
            i += step
    else:
        while i &gt; stop:
            yield i
            i += step

</t>
<t tx="ekr.20230509052845.3305">def __len__(self) -&gt; int:
    start, stop, step = self.start, self.stop, self.step
    if step &gt; 0 and start &lt; stop:
        return 1 + (stop - 1 - start) // step
    elif step &lt; 0 and start &gt; stop:
        return 1 + (start - 1 - stop) // (-step)
    else:
        return 0

</t>
<t tx="ekr.20230509052845.3306">def __bool__(self) -&gt; bool:
    return self.__len__() &gt; 0

</t>
<t tx="ekr.20230509052845.3307">def __reversed__(self) -&gt; Generator[int]:
    start, stop, step = self.start, self.stop, self.step
    n = self.__len__()
    return range(start + (n - 1) * step, start - step, -step).__iter__()

</t>
<t tx="ekr.20230509052845.3308">def __repr__(self) -&gt; str:
    if self.step == 1:
        return f"range({self.start}, {self.stop})"
    else:
        return f"range({self.start}, {self.stop}, {self.step})"

</t>
<t tx="ekr.20230509052845.3309">@overload
def staticrange(start: Static[int], stop: Static[int], step: Static[int] = 1):
    return range(start, stop, step)

</t>
<t tx="ekr.20230509052845.331">  /// Inserts a successor at some position.
  /// @param v the new successor
  /// @return an iterator to the new successor
  auto successors_insert(CFBlock *v) {
    successors.insert(v);
    v-&gt;predecessors.insert(this);
  }
</t>
<t tx="ekr.20230509052845.3310">@overload
def staticrange(stop: Static[int]):
    return range(0, stop, 1)
</t>
<t tx="ekr.20230509052845.3311">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
slice = Slice
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3312">@tuple
class Slice:
    start: Optional[int]
    stop: Optional[int]
    step: Optional[int]

    @others
</t>
<t tx="ekr.20230509052845.3313">def adjust_indices(self, length: int) -&gt; Tuple[int, int, int, int]:
    step: int = self.step if self.step is not None else 1
    start: int = 0
    stop: int = 0
    if step == 0:
        raise ValueError("slice step cannot be zero")
    if step &gt; 0:
        start = self.start if self.start is not None else 0
        stop = self.stop if self.stop is not None else length
    else:
        start = self.start if self.start is not None else length - 1
        stop = self.stop if self.stop is not None else -(length + 1)

    return Slice.adjust_indices_helper(length, start, stop, step)

</t>
<t tx="ekr.20230509052845.3314">def adjust_indices_helper(
    length: int, start: int, stop: int, step: int
) -&gt; Tuple[int, int, int, int]:
    if start &lt; 0:
        start += length
        if start &lt; 0:
            start = -1 if step &lt; 0 else 0
    elif start &gt;= length:
        start = length - 1 if step &lt; 0 else length

    if stop &lt; 0:
        stop += length
        if stop &lt; 0:
            stop = -1 if step &lt; 0 else 0
    elif stop &gt;= length:
        stop = length - 1 if step &lt; 0 else length

    if step &lt; 0:
        if stop &lt; start:
            return start, stop, step, (start - stop - 1) // (-step) + 1
    else:
        if start &lt; stop:
            return start, stop, step, (stop - start - 1) // step + 1

    return start, stop, step, 0

</t>
<t tx="ekr.20230509052845.3315">def __repr__(self):
    return f"slice({self.start}, {self.stop}, {self.step})"

</t>
<t tx="ekr.20230509052845.3316">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3317">@pure
@C
def strlen(a: cobj) -&gt; int:
    pass

</t>
<t tx="ekr.20230509052845.3318">@extend
class str:
    @others
</t>
<t tx="ekr.20230509052845.3319">@__internal__
def __new__(l: int, p: Ptr[byte]) -&gt; str:
    pass

</t>
<t tx="ekr.20230509052845.332">  /// Removes a given successor.
  /// @param v the successor to remove
  auto successors_erase(CFBlock *v) {
    successors.erase(v);
    v-&gt;predecessors.erase(this);
  }

</t>
<t tx="ekr.20230509052845.3320">def __new__(p: Ptr[byte], l: int) -&gt; str:
    return str(l, p)

</t>
<t tx="ekr.20230509052845.3321">def __new__() -&gt; str:
    return str(Ptr[byte](), 0)

</t>
<t tx="ekr.20230509052845.3322">def __new__(what) -&gt; str:
    if hasattr(what, "__str__"):
        return what.__str__()
    else:
        return what.__repr__()

</t>
<t tx="ekr.20230509052845.3323">def __str__(what: str) -&gt; str:
    return what

</t>
<t tx="ekr.20230509052845.3324">def __len__(self) -&gt; int:
    return self.len

</t>
<t tx="ekr.20230509052845.3325">def __bool__(self) -&gt; bool:
    return self.len != 0

</t>
<t tx="ekr.20230509052845.3326">def __copy__(self) -&gt; str:
    return self

</t>
<t tx="ekr.20230509052845.3327">def __deepcopy__(self) -&gt; str:
    return self

</t>
<t tx="ekr.20230509052845.3328">def __ptrcopy__(self) -&gt; str:
    n = self.len
    p = cobj(n)
    str.memcpy(p, self.ptr, n)
    return str(p, n)

</t>
<t tx="ekr.20230509052845.3329">@llvm
def memcpy(dest: Ptr[byte], src: Ptr[byte], len: int) -&gt; None:
    declare void @llvm.memcpy.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 %align, i1 %isvolatile)
    call void @llvm.memcpy.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 0, i1 false)
    ret {} {}

</t>
<t tx="ekr.20230509052845.333">class SyntheticAssignInstr : public AcceptorExtend&lt;SyntheticAssignInstr, Instr&gt; {
public:
  enum Kind { UNKNOWN, KNOWN, NEXT_VALUE, ADD };

private:
  /// the left-hand side
  Var *lhs;
  /// the kind of synthetic assignment
  Kind kind;
  /// any argument to the synthetic assignment
  Value *arg = nullptr;
  /// the difference
  int64_t diff = 0;

public:
  static const char NodeId;

  /// Constructs a synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param arg the argument
  /// @param k the kind of assignment
  /// @param name the name of the instruction
  SyntheticAssignInstr(Var *lhs, Value *arg, Kind k = KNOWN, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), kind(k), arg(arg) {}
  /// Constructs an unknown synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param name the name of the instruction
  explicit SyntheticAssignInstr(Var *lhs, std::string name = "")
      : SyntheticAssignInstr(lhs, nullptr, UNKNOWN, std::move(name)) {}
  /// Constructs an addition synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param diff the difference
  /// @param name the name of the instruction
  SyntheticAssignInstr(Var *lhs, int64_t diff, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), kind(ADD), diff(diff) {}

  /// @return the variable being assigned
  Var *getLhs() { return lhs; }
  /// @return the variable being assigned
  const Var *getLhs() const { return lhs; }
  /// Sets the variable being assigned.
  /// @param v the variable
  void setLhs(Var *v) { lhs = v; }

  /// @return the argument
  Value *getArg() { return arg; }
  /// @return the argument
  const Value *getArg() const { return arg; }
  /// Sets the argument.
  /// @param v the new value
  void setArg(Value *v) { arg = v; }

  /// @return the diff
  int64_t getDiff() const { return diff; }
  /// Sets the diff.
  /// @param v the new value
  void setDiff(int64_t v) { diff = v; }

  /// @return the kind of synthetic assignment
  Kind getKind() const { return kind; }
  /// Sets the kind.
  /// @param k the new value
  void setKind(Kind k) { kind = k; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {arg}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {lhs}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509052845.3330">@llvm
def memmove(dest: Ptr[byte], src: Ptr[byte], len: int) -&gt; None:
    declare void @llvm.memmove.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 %align, i1 %isvolatile)
    call void @llvm.memmove.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 0, i1 false)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3331">@llvm
def memset(dest: Ptr[byte], val: byte, len: int) -&gt; None:
    declare void @llvm.memset.p0i8.i64(ptr %dest, i8 %val, i64 %len, i32 %align, i1 %isvolatile)
    call void @llvm.memset.p0i8.i64(ptr %dest, i8 %val, i64 %len, i32 0, i1 false)
    ret {} {}

</t>
<t tx="ekr.20230509052845.3332">def __add__(self, other: str) -&gt; str:
    len1 = self.len
    len2 = other.len
    len3 = len1 + len2
    p = Ptr[byte](len3)
    str.memcpy(p, self.ptr, len1)
    str.memcpy(p + len1, other.ptr, len2)
    return str(p, len3)

</t>
<t tx="ekr.20230509052845.3333">def c_str(self) -&gt; cobj:
    n = self.__len__()
    p = cobj(n + 1)
    str.memcpy(p, self.ptr, n)
    p[n] = byte(0)
    return p

</t>
<t tx="ekr.20230509052845.3334">def from_ptr(t: cobj) -&gt; str:
    n = strlen(t)
    p = Ptr[byte](n)
    str.memcpy(p, t, n)
    return str(p, n)

</t>
<t tx="ekr.20230509052845.3335">def __eq__(self, other: str) -&gt; bool:
    if self.len != other.len:
        return False
    i = 0
    while i &lt; self.len:
        if self.ptr[i] != other.ptr[i]:
            return False
        i += 1
    return True

</t>
<t tx="ekr.20230509052845.3336">def __match__(self, other: str) -&gt; bool:
    return self.__eq__(other)

</t>
<t tx="ekr.20230509052845.3337">def __ne__(self, other: str) -&gt; bool:
    return not self.__eq__(other)

</t>
<t tx="ekr.20230509052845.3338">def cat(*args) -&gt; str:
    total = 0
    if (
        staticlen(args) == 1
        and hasattr(args[0], "__iter__")
        and hasattr(args[0], "__len__")
    ):
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            total += s.len
        p = cobj(total)
        n = 0
        for s in args[0]:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        sz = 10
        p = cobj(sz)
        n = 0
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            if n + s.len &gt; sz:
                sz = 1 + 3 * (n + s.len) // 2
                pp = cobj(sz)
                str.memcpy(pp, p, n)
                p = pp
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, n)
    else:
        total = 0
        for i in args:
            if not isinstance(i, str):
                compile_error("not a string")
            total += i.len
        p = cobj(total)
        n = 0
        for i in args:
            str.memcpy(p + n, i.ptr, i.len)
            n += i.len
        return str(p, total)
</t>
<t tx="ekr.20230509052845.3339">@path C:/Repos/codon/stdlib/internal/types/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.334">class SyntheticPhiInstr : public AcceptorExtend&lt;SyntheticPhiInstr, Instr&gt; {
public:
@others
private:
  std::list&lt;Predecessor&gt; preds;

public:
  static const char NodeId;

  explicit SyntheticPhiInstr(std::string name = "") : AcceptorExtend(std::move(name)) {}

  /// @return an iterator to the first instruction/flow
  auto begin() { return preds.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() { return preds.end(); }
  /// @return an iterator to the first instruction/flow
  auto begin() const { return preds.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() const { return preds.end(); }

  /// @return a pointer to the first instruction/flow
  Predecessor &amp;front() { return preds.front(); }
  /// @return a pointer to the last instruction/flow
  Predecessor &amp;back() { return preds.back(); }
  /// @return a pointer to the first instruction/flow
  const Predecessor &amp;front() const { return preds.front(); }
  /// @return a pointer to the last instruction/flow
  const Predecessor &amp;back() const { return preds.back(); }

  /// Inserts a predecessor.
  /// @param pos the position
  /// @param v the predecessor
  /// @return an iterator to the newly added predecessor
  template &lt;typename It&gt; auto insert(It pos, Predecessor v) {
    return preds.insert(pos, v);
  }
  /// Appends an predecessor.
  /// @param v the predecessor
  void push_back(Predecessor v) { preds.push_back(v); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed predecessor
  template &lt;typename It&gt; auto erase(It pos) { return preds.erase(pos); }

  /// Emplaces a predecessor.
  /// @param args the args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    preds.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509052845.3340">class strbuf:
    data: Ptr[byte]
    n: int
    m: int

    @others
</t>
<t tx="ekr.20230509052845.3341">def __init__(self, capacity: int = 16):
    self.data = Ptr[byte](capacity)
    self.n = 0
    self.m = capacity

</t>
<t tx="ekr.20230509052845.3342">def append(self, s: str):
    from internal.gc import realloc
    adding = s.__len__()
    needed = self.n + adding
    if needed &gt; self.m:
        m = self.m
        while m &lt; needed:
            m *= 2
        self.data = realloc(self.data, m, self.m)
        self.m = m
    str.memcpy(self.data + self.n, s.ptr, adding)
    self.n = needed

</t>
<t tx="ekr.20230509052845.3343">def reverse(self):
    a = 0
    b = self.n - 1
    p = self.data
    while a &lt; b:
        p[a], p[b] = p[b], p[a]
        a += 1
        b -= 1

</t>
<t tx="ekr.20230509052845.3344">def __str__(self):
    return str(self.data, self.n)
</t>
<t tx="ekr.20230509052845.3345"></t>
<t tx="ekr.20230509052845.3346">@path C:/Repos/codon/stdlib/internal/types/collections/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# dict implementation based on klib's khash

import internal.khash as khash
import internal.gc as gc

@others
dict = Dict
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3347">def _dict_hash(key) -&gt; int:
    k = key.__hash__()
    return (k &gt;&gt; 33) ^ k ^ (k &lt;&lt; 11)

</t>
<t tx="ekr.20230509052845.3348">class Dict:
    _n_buckets: int
    _size: int
    _n_occupied: int
    _upper_bound: int

    _flags: Ptr[u32]
    _keys: Ptr[K]
    _vals: Ptr[V]

    K: type
    V: type

    # Magic methods

    @others
</t>
<t tx="ekr.20230509052845.3349">def _init(self):
    self._n_buckets = 0
    self._size = 0
    self._n_occupied = 0
    self._upper_bound = 0
    self._flags = Ptr[u32]()
    self._keys = Ptr[K]()
    self._vals = Ptr[V]()

</t>
<t tx="ekr.20230509052845.335">  class Predecessor {
  private:
    /// the predecessor block
    CFBlock *pred;
    /// the value
    Value *result;

  public:
    /// Constructs a predecessor.
    /// @param pred the predecessor block
    /// @param result the result of this predecessor.
    Predecessor(CFBlock *pred, Value *result) : pred(pred), result(result) {}

    /// @return the predecessor block
    CFBlock *getPred() { return pred; }
    /// @return the predecessor block
    const CFBlock *getPred() const { return pred; }
    /// Sets the predecessor.
    /// @param v the new value
    void setPred(CFBlock *v) { pred = v; }

    /// @return the result
    Value *getResult() { return result; }
    /// @return the result
    const Value *getResult() const { return result; }
    /// Sets the result
    /// @param v the new value
    void setResult(Value *v) { result = v; }
  };

</t>
<t tx="ekr.20230509052845.3350">def _init_from(self, other):
    n = other._n_buckets

    if n == 0:
        self._init()
        return

    f = khash.__ac_fsize(n)
    self._n_buckets = n
    self._size = other._size
    self._n_occupied = other._n_occupied
    self._upper_bound = other._upper_bound

    flags_copy = Ptr[u32](f)
    keys_copy = Ptr[K](n)
    vals_copy = Ptr[V](n)
    str.memcpy(flags_copy.as_byte(), other._flags.as_byte(), f * gc.sizeof(u32))
    str.memcpy(keys_copy.as_byte(), other._keys.as_byte(), n * gc.sizeof(K))
    str.memcpy(vals_copy.as_byte(), other._vals.as_byte(), n * gc.sizeof(V))

    self._flags = flags_copy
    self._keys = keys_copy
    self._vals = vals_copy

</t>
<t tx="ekr.20230509052845.3351">def __init__(self):
    self._init()

</t>
<t tx="ekr.20230509052845.3352">def __init__(self, g: Generator[Tuple[K, V]]):
    self._init()
    for k, v in g:
        self[k] = v

</t>
<t tx="ekr.20230509052845.3353">def __init__(self, other: Dict[K, V]):
    self._init_from(other)

</t>
<t tx="ekr.20230509052845.3354">def __getitem__(self, key: K) -&gt; V:
    x = self._kh_get(key)
    if x != self._kh_end():
        return self._vals[x]
    raise KeyError(str(key))

</t>
<t tx="ekr.20230509052845.3355">def __setitem__(self, key: K, val: V):
    ret, x = self._kh_put(key)
    self._vals[x] = val

</t>
<t tx="ekr.20230509052845.3356">def __delitem__(self, key: K):
    x = self._kh_get(key)
    if x != self._kh_end():
        self._kh_del(x)
    else:
        raise KeyError(str(key))

</t>
<t tx="ekr.20230509052845.3357">def __contains__(self, key: K) -&gt; bool:
    return self._kh_get(key) != self._kh_end()

</t>
<t tx="ekr.20230509052845.3358">def __eq__(self, other: Dict[K, V]) -&gt; bool:
    if self.__len__() != other.__len__():
        return False
    for k, v in self.items():
        if k not in other or other[k] != v:
            return False
    return True

</t>
<t tx="ekr.20230509052845.3359">def __ne__(self, other: Dict[K, V]) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.336">class CFGraph {
private:
  /// owned list of blocks
  std::list&lt;std::unique_ptr&lt;CFBlock&gt;&gt; blocks;
  /// the current block
  CFBlock *cur = nullptr;
  /// the function being analyzed
  const BodiedFunc *func;
  /// a list of synthetic values
  std::list&lt;std::unique_ptr&lt;Value&gt;&gt; syntheticValues;
  /// a map of synthetic values
  std::unordered_map&lt;id_t, Value *&gt; valueMapping;
  /// a list of synthetic variables
  std::list&lt;std::unique_ptr&lt;Var&gt;&gt; syntheticVars;
  /// a mapping from value id to block
  std::unordered_map&lt;id_t, CFBlock *&gt; valueLocations;

public:
  /// Constructs a control-flow graph.
  explicit CFGraph(const BodiedFunc *f);

  /// @return an iterator to the first block
  auto begin() { return util::raw_ptr_adaptor(blocks.begin()); }
  /// @return an iterator beyond the last block
  auto end() { return util::raw_ptr_adaptor(blocks.end()); }
  /// @return an iterator to the first block
  auto begin() const { return util::raw_ptr_adaptor(blocks.begin()); }
  /// @return an iterator beyond the last block
  auto end() const { return util::raw_ptr_adaptor(blocks.end()); }

  /// @return an iterator to the synthetic value
  auto synth_begin() { return util::raw_ptr_adaptor(syntheticValues.begin()); }
  /// @return an iterator beyond the last synthetic value
  auto synth_end() { return util::raw_ptr_adaptor(syntheticValues.end()); }
  /// @return an iterator to the first synthetic value
  auto synth_begin() const { return util::raw_ptr_adaptor(syntheticValues.begin()); }
  /// @return an iterator beyond the last synthetic value
  auto synth_end() const { return util::raw_ptr_adaptor(syntheticValues.end()); }

  /// @return the entry block
  CFBlock *getEntryBlock() { return blocks.front().get(); }
  /// @return the entry block
  const CFBlock *getEntryBlock() const { return blocks.front().get(); }

  /// @return the entry block
  CFBlock *getCurrentBlock() { return cur; }
  /// @return the entry block
  const CFBlock *getCurrentBlock() const { return cur; }
  /// Sets the current block.
  /// @param v the new value
  void setCurrentBlock(CFBlock *v) { cur = v; }

  /// @return the function
  const BodiedFunc *getFunc() const { return func; }
  /// Sets the function.
  /// @param f the new value
  void setFunc(BodiedFunc *f) { func = f; }

  /// Gets the block containing a value.
  /// @param val the value
  /// @return the block
  CFBlock *getBlock(const Value *v) {
    auto vmIt = valueMapping.find(v-&gt;getId());
    if (vmIt != valueMapping.end())
      v = vmIt-&gt;second;

    auto it = valueLocations.find(v-&gt;getId());
    return it != valueLocations.end() ? it-&gt;second : nullptr;
  }
@others
};

</t>
<t tx="ekr.20230509052845.3360">def __iter__(self) -&gt; Generator[K]:
    return self.keys()

</t>
<t tx="ekr.20230509052845.3361">def __len__(self) -&gt; int:
    return self._size

</t>
<t tx="ekr.20230509052845.3362">def __or__(self, other):
    new = self.__copy__()
    new.update(other)
    return new

</t>
<t tx="ekr.20230509052845.3363">def __ior__(self, other):
    self.update(other)
    return self

</t>
<t tx="ekr.20230509052845.3364">def __copy__(self):
    if self.__len__() == 0:
        return Dict[K, V]()
    n = self._n_buckets
    f = khash.__ac_fsize(n)
    flags_copy = Ptr[u32](f)
    keys_copy = Ptr[K](n)
    vals_copy = Ptr[V](n)
    str.memcpy(flags_copy.as_byte(), self._flags.as_byte(), f * gc.sizeof(u32))
    str.memcpy(keys_copy.as_byte(), self._keys.as_byte(), n * gc.sizeof(K))
    str.memcpy(vals_copy.as_byte(), self._vals.as_byte(), n * gc.sizeof(V))
    return Dict[K, V](
        n,
        self._size,
        self._n_occupied,
        self._upper_bound,
        flags_copy,
        keys_copy,
        vals_copy,
    )

</t>
<t tx="ekr.20230509052845.3365">def __deepcopy__(self) -&gt; Dict[K, V]:
    return {k.__deepcopy__(): v.__deepcopy__() for k, v in self.items()}

</t>
<t tx="ekr.20230509052845.3366">def __repr__(self) -&gt; str:
    n = self.__len__()
    if n == 0:
        return "{}"
    else:
        buf = _strbuf()
        buf.append("{")
        first = True
        for k, v in self.items():
            if not first:
                buf.append(", ")
            else:
                first = False
            buf.append(k.__repr__())
            buf.append(": ")
            buf.append(v.__repr__())
        buf.append("}")
        return buf.__str__()

</t>
<t tx="ekr.20230509052845.3367"># Helper methods

</t>
<t tx="ekr.20230509052845.3368">def resize(self, new_n_buckets: int):
    self._kh_resize(new_n_buckets)

</t>
<t tx="ekr.20230509052845.3369">def get(self, key: K, s: V) -&gt; V:
    x = self._kh_get(key)
    return self._vals[x] if x != self._kh_end() else s

</t>
<t tx="ekr.20230509052845.337">  /// Gets the block containing a value.
  /// @param val the value
  /// @return the block
  const CFBlock *getBlock(const Value *v) const {
    auto vmIt = valueMapping.find(v-&gt;getId());
    if (vmIt != valueMapping.end())
      v = vmIt-&gt;second;

    auto it = valueLocations.find(v-&gt;getId());
    return it != valueLocations.end() ? it-&gt;second : nullptr;
  }

</t>
<t tx="ekr.20230509052845.3370">def setdefault(self, key: K, val: V) -&gt; V:
    ret, x = self._kh_put(key)
    if ret != 0:  # i.e. key not present
        self._vals[x] = val
        return val
    return self._vals[x]

</t>
<t tx="ekr.20230509052845.3371">def increment(self, key: K, by: T = 1, T: type):
    ret, x = self._kh_put(key)
    if ret != 0:  # i.e. key not present
        self._vals[x] = by
    else:
        self._vals[x] += by

</t>
<t tx="ekr.20230509052845.3372">def __dict_do_op_throws__(self, key: K, other: Z, op: F, F: type, Z: type):
    x = self._kh_get(key)
    if x == self._kh_end():
        raise KeyError(str(key))
    else:
        self._vals[x] = op(self._vals[x], other)

</t>
<t tx="ekr.20230509052845.3373">def __dict_do_op__(self, key: K, other: Z, dflt: V, op: F, F: type, Z: type):
    ret, x = self._kh_put(key)
    self._vals[x] = op(dflt if ret != 0 else self._vals[x], other)

</t>
<t tx="ekr.20230509052845.3374">def update(self, other):
    if isinstance(other, Dict[K, V]):
        for k, v in other.items():
            self[k] = v
    else:
        for k, v in other:
            self[k] = v

</t>
<t tx="ekr.20230509052845.3375">def pop(self, key: K) -&gt; V:
    x = self._kh_get(key)
    if x != self._kh_end():
        v = self._vals[x]
        self._kh_del(x)
        return v
    raise KeyError(str(key))

</t>
<t tx="ekr.20230509052845.3376">def popitem(self) -&gt; Tuple[K, V]:
    for k in self:
        return (k, self.pop(k))
    raise KeyError("dictionary is empty")

</t>
<t tx="ekr.20230509052845.3377">def clear(self):
    self._kh_clear()

</t>
<t tx="ekr.20230509052845.3378">def items(self) -&gt; Generator[Tuple[K, V]]:
    i = self._kh_begin()
    while i &lt; self._kh_end():
        if self._kh_exist(i):
            yield self._keys[i], self._vals[i]
        i += 1

</t>
<t tx="ekr.20230509052845.3379">def keys(self) -&gt; Generator[K]:
    for k, v in self.items():
        yield k

</t>
<t tx="ekr.20230509052845.338">  /// Creates and inserts a new block
  /// @param name the name
  /// @param setCur true if the block should be made the current one
  /// @return a newly inserted block
  CFBlock *newBlock(std::string name = "", bool setCur = false) {
    auto *ret = new CFBlock(this, std::move(name));
    blocks.emplace_back(ret);
    if (setCur)
      setCurrentBlock(ret);
    return ret;
  }

  template &lt;typename NodeType, typename... Args&gt; NodeType *N(Args &amp;&amp;...args) {
    auto *ret = new NodeType(std::forward&lt;Args&gt;(args)...);
    reg(ret);
    ret-&gt;setModule(func-&gt;getModule());
    return ret;
  }

  /// Remaps a value.
  /// @param id original id
  /// @param newValue the new value
  void remapValue(id_t id, Value *newValue) { valueMapping[id] = newValue; }
</t>
<t tx="ekr.20230509052845.3380">def values(self) -&gt; Generator[V]:
    for k, v in self.items():
        yield v

</t>
<t tx="ekr.20230509052845.3381">def copy(self):
    return self.__copy__()

</t>
<t tx="ekr.20230509052845.3382">def fromkeys(ks: Generator[K], v: V, K: type, V: type) -&gt; Dict[K, V]:
    return {k: v for k in ks}

</t>
<t tx="ekr.20230509052845.3383"># Internal helpers

</t>
<t tx="ekr.20230509052845.3384">def _kh_clear(self):
    if self._flags:
        i = 0
        n = khash.__ac_fsize(self._n_buckets)
        while i &lt; n:
            self._flags[i] = u32(0xAAAAAAAA)
            i += 1
        self._size = 0
        self._n_occupied = 0

</t>
<t tx="ekr.20230509052845.3385">def _kh_get(self, key: K) -&gt; int:
    if self._n_buckets:
        step = 0
        mask = self._n_buckets - 1
        k = _dict_hash(key)
        i = k &amp; mask
        last = i
        while not khash.__ac_isempty(self._flags, i) and (
            khash.__ac_isdel(self._flags, i) or self._keys[i] != key
        ):
            step += 1
            i = (i + step) &amp; mask
            if i == last:
                return self._n_buckets
        return self._n_buckets if khash.__ac_iseither(self._flags, i) else i
    else:
        return 0

</t>
<t tx="ekr.20230509052845.3386">def _kh_resize(self, new_n_buckets: int):
    HASH_UPPER = 0.77
    new_flags = Ptr[u32]()
    j = 1

    # round up to next power of 2
    new_n_buckets -= 1
    new_n_buckets |= new_n_buckets &gt;&gt; 1
    new_n_buckets |= new_n_buckets &gt;&gt; 2
    new_n_buckets |= new_n_buckets &gt;&gt; 4
    new_n_buckets |= new_n_buckets &gt;&gt; 8
    new_n_buckets |= new_n_buckets &gt;&gt; 16
    new_n_buckets |= new_n_buckets &gt;&gt; 32
    new_n_buckets += 1

    if new_n_buckets &lt; 4:
        new_n_buckets = 4

    if self._size &gt;= int(new_n_buckets * HASH_UPPER + 0.5):
        j = 0
    else:
        fsize = khash.__ac_fsize(new_n_buckets)
        new_flags = Ptr[u32](fsize)
        i = 0
        while i &lt; fsize:
            new_flags[i] = u32(0xAAAAAAAA)
            i += 1

        if self._n_buckets &lt; new_n_buckets:
            self._keys = Ptr[K](
                gc.realloc(self._keys.as_byte(),
                           new_n_buckets * gc.sizeof(K),
                           self._n_buckets * gc.sizeof(K))
            )
            self._vals = Ptr[V](
                gc.realloc(self._vals.as_byte(),
                           new_n_buckets * gc.sizeof(V),
                           self._n_buckets * gc.sizeof(V))
            )

    if j:
        j = 0
        while j != self._n_buckets:
            if khash.__ac_iseither(self._flags, j) == 0:
                key = self._keys[j]
                val = self._vals[j]
                new_mask = new_n_buckets - 1
                khash.__ac_set_isdel_true(self._flags, j)

                while True:
                    step = 0
                    k = _dict_hash(key)
                    i = k &amp; new_mask

                    while not khash.__ac_isempty(new_flags, i):
                        step += 1
                        i = (i + step) &amp; new_mask

                    khash.__ac_set_isempty_false(new_flags, i)
                    if (
                        i &lt; self._n_buckets
                        and khash.__ac_iseither(self._flags, i) == 0
                    ):
                        self._keys[i], key = key, self._keys[i]
                        self._vals[i], val = val, self._vals[i]
                        khash.__ac_set_isdel_true(self._flags, i)
                    else:
                        self._keys[i] = key
                        self._vals[i] = val
                        break
            j += 1

        if self._n_buckets &gt; new_n_buckets:
            self._keys = Ptr[K](
                gc.realloc(self._keys.as_byte(),
                           new_n_buckets * gc.sizeof(K),
                           self._n_buckets * gc.sizeof(K))
            )
            self._vals = Ptr[V](
                gc.realloc(self._vals.as_byte(),
                           new_n_buckets * gc.sizeof(V),
                           self._n_buckets * gc.sizeof(V))
            )

        self._flags = new_flags
        self._n_buckets = new_n_buckets
        self._n_occupied = self._size
        self._upper_bound = int(self._n_buckets * HASH_UPPER + 0.5)

</t>
<t tx="ekr.20230509052845.3387">def _kh_put(self, key: K) -&gt; Tuple[int, int]:
    if self._n_occupied &gt;= self._upper_bound:
        if self._n_buckets &gt; (self._size &lt;&lt; 1):
            self._kh_resize(self._n_buckets - 1)
        else:
            self._kh_resize(self._n_buckets + 1)

    mask = self._n_buckets - 1
    step = 0
    site = self._n_buckets
    x = site
    k = _dict_hash(key)
    i = k &amp; mask
    if khash.__ac_isempty(self._flags, i):
        x = i
    else:
        last = i
        while not khash.__ac_isempty(self._flags, i) and (
            khash.__ac_isdel(self._flags, i) or self._keys[i] != key
        ):
            if khash.__ac_isdel(self._flags, i):
                site = i
            step += 1
            i = (i + step) &amp; mask
            if i == last:
                x = site
                break

        if x == self._n_buckets:
            if khash.__ac_isempty(self._flags, i) and site != self._n_buckets:
                x = site
            else:
                x = i

    ret = 0
    if khash.__ac_isempty(self._flags, x):
        self._keys[x] = key
        khash.__ac_set_isboth_false(self._flags, x)
        self._size += 1
        self._n_occupied += 1
        ret = 1
    elif khash.__ac_isdel(self._flags, x):
        self._keys[x] = key
        khash.__ac_set_isboth_false(self._flags, x)
        self._size += 1
        ret = 2

    return (ret, x)

</t>
<t tx="ekr.20230509052845.3388">def _kh_del(self, x: int):
    if x != self._n_buckets and not khash.__ac_iseither(self._flags, x):
        khash.__ac_set_isdel_true(self._flags, x)
        self._size -= 1

</t>
<t tx="ekr.20230509052845.3389">def _kh_begin(self) -&gt; int:
    return 0

</t>
<t tx="ekr.20230509052845.339">  /// Remaps a value.
  /// @param original the original value
  /// @param newValue the new value
  void remapValue(const Value *original, Value *newValue) {
    remapValue(original-&gt;getId(), newValue);
  }

</t>
<t tx="ekr.20230509052845.3390">def _kh_end(self) -&gt; int:
    return self._n_buckets

</t>
<t tx="ekr.20230509052845.3391">def _kh_exist(self, x: int) -&gt; bool:
    return not khash.__ac_iseither(self._flags, x)

</t>
<t tx="ekr.20230509052845.3392">@path C:/Repos/codon/stdlib/internal/types/collections/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import internal.gc as gc

@others
list = List
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3393">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.3394">def __init__(self):
    self.arr = Array[T](10)
    self.len = 0

</t>
<t tx="ekr.20230509052845.3395">def __init__(self, it: Generator[T]):
    self.arr = Array[T](10)
    self.len = 0
    for i in it:
        self.append(i)

</t>
<t tx="ekr.20230509052845.3396">def __init__(self, other: List[T]):
    self.arr = Array[T](other.len)
    self.len = 0
    for i in other:
        self.append(i)

</t>
<t tx="ekr.20230509052845.3397">def __init__(self, capacity: int):
    self.arr = Array[T](capacity)
    self.len = 0

</t>
<t tx="ekr.20230509052845.3398">def __init__(self, arr: Array[T], len: int):
    self.arr = arr
    self.len = len

</t>
<t tx="ekr.20230509052845.3399">def _get(self, idx: int):
    return self.arr.ptr[idx]

</t>
<t tx="ekr.20230509052845.34">def __len__(self):
    return len(self.points)

</t>
<t tx="ekr.20230509052845.340">  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  Value *getValue(id_t id) {
    auto it = valueMapping.find(id);
    return it != valueMapping.end() ? it-&gt;second : func-&gt;getModule()-&gt;getValue(id);
  }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CFGraph &amp;cfg);
  friend class CFBlock;

private:
  void reg(Var *v) { syntheticVars.emplace_back(v); }

</t>
<t tx="ekr.20230509052845.3400">def _set(self, idx: int, val: T):
    self.arr.ptr[idx] = val

</t>
<t tx="ekr.20230509052845.3401">def __len__(self) -&gt; int:
    return self.len

</t>
<t tx="ekr.20230509052845.3402">def __bool__(self) -&gt; bool:
    return self.__len__() &gt; 0

</t>
<t tx="ekr.20230509052845.3403">def __getitem__(self, idx: int) -&gt; T:
    if idx &lt; 0:
        idx += self.__len__()
    self._idx_check(idx, "list index out of range")
    return self._get(idx)

</t>
<t tx="ekr.20230509052845.3404">def __setitem__(self, idx: int, val: T):
    if idx &lt; 0:
        idx += self.__len__()
    self._idx_check(idx, "list assignment index out of range")
    self._set(idx, val)

</t>
<t tx="ekr.20230509052845.3405">def __delitem__(self, idx: int):
    if idx &lt; 0:
        idx += self.__len__()
    self._idx_check(idx, "list assignment index out of range")
    while idx &lt; self.len - 1:
        self._set(idx, self._get(idx + 1))
        idx += 1
    self.len -= 1

</t>
<t tx="ekr.20230509052845.3406">def __eq__(self, other: List[T]) -&gt; bool:
    if self.__len__() != other.__len__():
        return False
    for i in range(self.__len__()):
        if self._get(i) != other._get(i):
            return False
    return True

</t>
<t tx="ekr.20230509052845.3407">def __ne__(self, other: List[T]) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.3408">def __getitem__(self, s: Slice) -&gt; List[T]:
    if s.start is None and s.stop is None and s.step is None:
        return self.__copy__()
    if s.step is None:
        start, stop, step, length = s.adjust_indices(self.__len__())
        return List[T](self._copy_arr(start, stop, length), length)
    else:
        start, stop, step, length = s.adjust_indices(self.__len__())
        other = List[T](length)
        for i in range(start, stop, step):
            other.append(self._get(i))
        return other

</t>
<t tx="ekr.20230509052845.3409">def __setitem__(self, s: Slice, other):
    if s.start is None and s.stop is None and s.step is None:
        self.clear()
        for a in other:
            self.append(a)
        return

    start, stop, step, length = s.adjust_indices(self.__len__())
    if s.step is None or step == 1:
        if isinstance(other, List[T]):
            if other is self:
                other = other.__copy__()
            self._assign_slice(start, stop, other.arr.ptr, other.__len__())
        else:
            items = [a for a in other]
            self._assign_slice(start, stop, items.arr.ptr, items.__len__())
    else:
        if (step &lt; 0 and start &lt; stop) or (step &gt; 0 and start &gt; stop):
            stop = start

        seq: Optional[List[T]] = None
        if isinstance(other, List[T]):
            if other is self:
                seq = other.__copy__()
            else:
                seq = other
        else:
            seq = [a for a in other]

        seq_len = seq.__len__()
        if seq_len != length:
            raise ValueError(
                f"attempt to assign sequence of size {seq_len} to extended slice of size {length}"
            )

        if length == 0:
            return

        cur = start
        i = 0
        while i &lt; length:
            self._set(cur, seq._get(i))
            cur += step
            i += 1

</t>
<t tx="ekr.20230509052845.341">  void reg(Value *v) {
    syntheticValues.emplace_back(v);
    valueMapping[v-&gt;getId()] = v;
  }
</t>
<t tx="ekr.20230509052845.3410">def __delitem__(self, s: Slice):
    if s.start is None and s.stop is None and s.step is None:
        self.clear()
    else:
        start, stop, step, length = s.adjust_indices(self.__len__())
        if s.step is None or step == 1:
            self._assign_slice(start, stop, Ptr[T](), 0)
        else:
            if length &lt; 0:
                return

            if step &lt; 0:
                stop = start + 1
                start = stop + step * (length - 1) - 1
                step = -step

            cur = start
            i = 0
            while cur &lt; stop:
                lim = step - 1
                if cur + step &gt; self.__len__():
                    lim = self.__len__() - cur - 1
                str.memmove(
                    (self.arr.ptr + (cur - i)).as_byte(),
                    (self.arr.ptr + (cur + 1)).as_byte(),
                    lim * gc.sizeof(T),
                )
                cur += step
                i += 1

            cur = start + length * step
            if cur &lt; self.__len__():
                str.memmove(
                    (self.arr.ptr + (cur - length)).as_byte(),
                    (self.arr.ptr + cur).as_byte(),
                    (self.__len__() - cur) * gc.sizeof(T),
                )

            self.len -= length
            # self._resize(self.__len__())

</t>
<t tx="ekr.20230509052845.3411">def __contains__(self, x: T) -&gt; bool:
    for a in self:
        if a == x:
            return True
    return False

</t>
<t tx="ekr.20230509052845.3412">def __copy__(self) -&gt; List[T]:
    return List[T](self.arr.__copy__(), self.len)

</t>
<t tx="ekr.20230509052845.3413">def __deepcopy__(self) -&gt; List[T]:
    return [l.__deepcopy__() for l in self]

</t>
<t tx="ekr.20230509052845.3414">def __iter__(self) -&gt; Generator[T]:
    i = 0
    N = self.len
    p = self.arr.ptr
    while i &lt; N:
        yield p[i]
        i += 1

</t>
<t tx="ekr.20230509052845.3415">def __reversed__(self) -&gt; Generator[T]:
    i = self.len - 1
    while i &gt;= 0:
        yield self._get(i)
        i -= 1

</t>
<t tx="ekr.20230509052845.3416">def __add__(self, other: List[T]) -&gt; List[T]:
    n = self.len + other.len
    v = List[T](n)
    v.len = n
    p = v.arr.ptr
    str.memcpy(p.as_byte(),
               self.arr.ptr.as_byte(),
               self.len * gc.sizeof(T))
    str.memcpy((p + self.len).as_byte(),
               other.arr.ptr.as_byte(),
               other.len * gc.sizeof(T))
    return v

</t>
<t tx="ekr.20230509052845.3417">def __iadd__(self, other: List[T]) -&gt; List[T]:
    n = self.len + other.len
    if self.arr.len &lt; n:
        self._resize(n)
    str.memcpy((self.arr.ptr + self.len).as_byte(),
               other.arr.ptr.as_byte(),
               other.len * gc.sizeof(T))
    self.len = n
    return self

</t>
<t tx="ekr.20230509052845.3418">def __mul__(self, n: int) -&gt; List[T]:
    if n &lt;= 0:
        return List[T]()

    new_len = self.len * n
    v = List[T](new_len)
    i = 0
    while i &lt; n:
        j = 0
        while j &lt; self.len:
            v.append(self._get(j))
            j += 1
        i += 1
    return v

</t>
<t tx="ekr.20230509052845.3419">def __rmul__(self, n: int) -&gt; List[T]:
    return self.__mul__(n)

</t>
<t tx="ekr.20230509052845.342">/// Builds a control-flow graph from a given function.
/// @param f the function
/// @return the control-flow graph
std::unique_ptr&lt;CFGraph&gt; buildCFGraph(const BodiedFunc *f);

/// Control-flow analysis result.
struct CFResult : public Result {
  /// map from function id to control-flow graph
  std::unordered_map&lt;id_t, std::unique_ptr&lt;CFGraph&gt;&gt; graphs;
};

</t>
<t tx="ekr.20230509052845.3420">def __imul__(self, n: int) -&gt; List[T]:
    if n == 1:
        return self

    if n &lt;= 0:
        self.clear()
        return self

    len0 = self.__len__()
    new_cap = n * len0
    if self.arr.len &lt; new_cap:
        p = Ptr[T](gc.realloc(self.arr.ptr.as_byte(),
                              new_cap * gc.sizeof(T),
                              self.arr.len * gc.sizeof(T)))
        self.arr = Array[T](p, new_cap)

    idx = len0
    i = 0
    while i &lt; n - 1:
        j = 0
        while j &lt; len0:
            self._set(idx, self._get(j))
            idx += 1
            j += 1
        i += 1

    self.len = new_cap
    return self

</t>
<t tx="ekr.20230509052845.3421">def __repr__(self) -&gt; str:
    n = self.__len__()
    if n == 0:
        return "[]"
    else:
        buf = _strbuf()
        buf.append("[")
        buf.append(self._get(0).__repr__())
        for i in range(1, n):
            buf.append(", ")
            buf.append(self._get(i).__repr__())
        buf.append("]")
        return buf.__str__()

</t>
<t tx="ekr.20230509052845.3422"># Helper functions

</t>
<t tx="ekr.20230509052845.3423">def append(self, x: T):
    self._resize_if_full()
    self._set(self.len, x)
    self.len += 1

</t>
<t tx="ekr.20230509052845.3424">def extend(self, itr: Generator[T]):
    for a in itr:
        self.append(a)

</t>
<t tx="ekr.20230509052845.3425">def insert(self, idx: int, x: T):
    n = self.__len__()
    if idx &lt; 0:
        idx += n
        if idx &lt; 0:
            idx = 0
    if idx &gt; n:
        idx = n
    self._resize_if_full()
    i = n
    while i &gt; idx:
        self._set(i, self._get(i - 1))
        i -= 1
    self._set(idx, x)
    self.len += 1

</t>
<t tx="ekr.20230509052845.3426">def pop(self, idx: int = -1) -&gt; T:
    if self.__len__() == 0:
        raise IndexError("pop from empty list")
    if idx &lt; 0:
        idx += self.__len__()
    self._idx_check(idx, "pop index out of range")
    x = self._get(idx)
    del self[idx]
    return x

</t>
<t tx="ekr.20230509052845.3427">def remove(self, x: T) -&gt; bool:
    i = 0
    for a in self:
        if a == x:
            del self[i]
            return True
        i += 1
    return False

</t>
<t tx="ekr.20230509052845.3428">def clear(self):
    self.len = 0

</t>
<t tx="ekr.20230509052845.3429">def index(self, x: T) -&gt; int:
    i = 0
    for a in self:
        if a == x:
            return i
        i += 1
    return -1

</t>
<t tx="ekr.20230509052845.343">/// Control-flow analysis that runs on all functions.
class CFAnalysis : public Analysis {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3430">def count(self, x: T) -&gt; int:
    count = 0
    for a in self:
        if a == x:
            count += 1
    return count

</t>
<t tx="ekr.20230509052845.3431">def reverse(self):
    i = 0
    while i &lt; self.len // 2:
        j = self.len - i - 1
        x = self._get(i)
        self._set(i, self._get(j))
        self._set(j, x)
        i += 1

</t>
<t tx="ekr.20230509052845.3432">def copy(self) -&gt; List[T]:
    return self.__copy__()

</t>
<t tx="ekr.20230509052845.3433"># Internal helpers

</t>
<t tx="ekr.20230509052845.3434">def _idx_check(self, idx: int, msg: str):
    if idx &gt;= self.len or idx &lt; 0:
        raise IndexError(msg)

</t>
<t tx="ekr.20230509052845.3435">def _resize(self, new_cap: int):
    p = Ptr[T](gc.realloc(self.arr.ptr.as_byte(),
                          new_cap * gc.sizeof(T),
                          self.arr.len * gc.sizeof(T)))
    self.arr = Array[T](p, new_cap)

</t>
<t tx="ekr.20230509052845.3436">def _resize_if_full(self):
    if self.len == self.arr.len:
        new_cap = (1 + 3 * self.len) // 2
        self._resize(new_cap)

</t>
<t tx="ekr.20230509052845.3437">def __hash__(self) -&gt; int:
    # https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html
    seed = 0
    for v in self:
        seed ^= v.__hash__() + 0x9E3779B9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2)
    return seed

</t>
<t tx="ekr.20230509052845.3438">def _assign_slice(self, ilow: int, ihigh: int, v: Ptr[T], n: int):
    a = self
    L = a.len

    if ilow &lt; 0:
        ilow = 0
    elif ilow &gt; L:
        ilow = L

    if ihigh &lt; ilow:
        ihigh = ilow
    elif ihigh &gt; L:
        ihigh = L

    norig = ihigh - ilow
    assert norig &gt;= 0
    d = n - norig
    if L + d == 0:
        a.clear()
        return

    if d &lt; 0:
        tail = L - ihigh
        str.memmove(
            (a.arr.ptr + (ihigh + d)).as_byte(),
            (a.arr.ptr + ihigh).as_byte(),
            tail * gc.sizeof(T),
        )
        a._resize(L + d)
    elif d &gt; 0:
        k = L
        a._resize(k + d)
        str.memmove(
            (a.arr.ptr + (ihigh + d)).as_byte(),
            (a.arr.ptr + ihigh).as_byte(),
            (k - ihigh) * gc.sizeof(T),
        )

    k = 0
    while k &lt; n:
        a._set(ilow, v[k])
        k += 1
        ilow += 1
    a.len += d

</t>
<t tx="ekr.20230509052845.3439">def _copy_arr(self, start: int, stop: int, length: int) -&gt; Array[T]:
    if length &lt;= 0:
        return Array[T](Ptr[T](), 0)
    return self.arr.slice(start, stop).__copy__()

</t>
<t tx="ekr.20230509052845.344">class CFVisitor : public util::ConstVisitor {
private:
  struct Loop {
    analyze::dataflow::CFBlock *nextIt;
    analyze::dataflow::CFBlock *end;
    id_t loopId;
    int tcIndex;

    Loop(analyze::dataflow::CFBlock *nextIt, analyze::dataflow::CFBlock *end,
         id_t loopId, int tcIndex = -1)
        : nextIt(nextIt), end(end), loopId(loopId), tcIndex(tcIndex) {}
  };

  analyze::dataflow::CFGraph *graph;
  std::vector&lt;std::pair&lt;analyze::dataflow::CFBlock *, analyze::dataflow::CFBlock *&gt;&gt;
      tryCatchStack;
  std::unordered_set&lt;id_t&gt; seenIds;
  std::vector&lt;Loop&gt; loopStack;

public:
  explicit CFVisitor(analyze::dataflow::CFGraph *graph) : graph(graph) {}

  void visit(const BodiedFunc *f) override;

  DEFAULT_VISIT(VarValue)
  DEFAULT_VISIT(PointerValue)

  void visit(const SeriesFlow *v) override;
  void visit(const IfFlow *v) override;
  void visit(const WhileFlow *v) override;
  void visit(const ForFlow *v) override;
  void visit(const ImperativeForFlow *v) override;

  void visit(const TryCatchFlow *v) override;
  void visit(const PipelineFlow *v) override;
  void visit(const dsl::CustomFlow *v) override;

  DEFAULT_VISIT(TemplatedConst&lt;int64_t&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;double&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;bool&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;std::string&gt;);
  DEFAULT_VISIT(dsl::CustomConst);

  void visit(const AssignInstr *v) override;
  void visit(const ExtractInstr *v) override;
  void visit(const InsertInstr *v) override;
  void visit(const CallInstr *v) override;
  DEFAULT_VISIT(StackAllocInstr);
  DEFAULT_VISIT(TypePropertyInstr);
  DEFAULT_VISIT(YieldInInstr);

  void visit(const TernaryInstr *v) override;

  void visit(const BreakInstr *v) override;
  void visit(const ContinueInstr *v) override;
  void visit(const ReturnInstr *v) override;
  void visit(const YieldInstr *v) override;
  void visit(const ThrowInstr *v) override;
  void visit(const FlowInstr *v) override;
  void visit(const dsl::CustomInstr *v) override;

  template &lt;typename NodeType&gt; void process(const NodeType *v) {
    if (!v)
      return;
    if (seenIds.find(v-&gt;getId()) != seenIds.end())
      return;
    seenIds.insert(v-&gt;getId());
    v-&gt;accept(*this);
  }

  void defaultInsert(const Value *v);
  void defaultJump(const CFBlock *cf, int newTcLevel = -1);

private:
  Loop &amp;findLoop(id_t id);
};

</t>
<t tx="ekr.20230509052845.3440">def _cmp(self, other: List[T]):
    n1 = self.__len__()
    n2 = other.__len__()
    nmin = n1 if n1 &lt; n2 else n2
    for i in range(nmin):
        a = self._get(i)
        b = other._get(i)

        if a &lt; b:
            return -1
        elif a == b:
            continue
        else:
            return 1
    if n1 &lt; n2:
        return -1
    elif n1 == n2:
        return 0
    else:
        return 1

</t>
<t tx="ekr.20230509052845.3441">def __lt__(self, other: List[T]):
    return self._cmp(other) &lt; 0

</t>
<t tx="ekr.20230509052845.3442">def __gt__(self, other: List[T]):
    return self._cmp(other) &gt; 0

</t>
<t tx="ekr.20230509052845.3443">def __le__(self, other: List[T]):
    return self._cmp(other) &lt;= 0

</t>
<t tx="ekr.20230509052845.3444">def __ge__(self, other: List[T]):
    return self._cmp(other) &gt;= 0

</t>
<t tx="ekr.20230509052845.3445"># list addition optimization helpers

</t>
<t tx="ekr.20230509052845.3446">def _list_add_opt_default_len(v: List[T]):
    return v.__len__()

</t>
<t tx="ekr.20230509052845.3447">def _list_add_opt_default_append(ans: List[T], v: List[T]):
    from internal.gc import sizeof
    n = v.__len__()
    str.memcpy((ans.arr.ptr + ans.len).as_byte(), v.arr.ptr.as_byte(), n * sizeof(T))
    ans.len += n

</t>
<t tx="ekr.20230509052845.3448">def _list_add_opt_slice_len(v: List[T], s: Slice):
    if s.start is None and s.stop is None and s.step is None:
        return v.__len__()
    start, stop, step, length = s.adjust_indices(v.__len__())
    return length

</t>
<t tx="ekr.20230509052845.3449">def _list_add_opt_slice_append(ans: List[T], v: List[T], s: Slice):
    from internal.gc import sizeof
    if s.start is None and s.stop is None and s.step is None:
        n = v.__len__()
        str.memcpy((ans.arr.ptr + ans.len).as_byte(), v.arr.ptr.as_byte(), n * sizeof(T))
        ans.len += n
    elif s.step is None:
        start, stop, step, length = s.adjust_indices(v.__len__())
        n = stop - start
        str.memcpy((ans.arr.ptr + ans.len).as_byte(), (v.arr.ptr + start).as_byte(), n * sizeof(T))
        ans.len += n
    else:
        start, stop, step, length = s.adjust_indices(v.__len__())
        for i in range(start, stop, step):
            ans.arr.ptr[ans.len] = v._get(i)
            ans.len += 1

</t>
<t tx="ekr.20230509052845.345">} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon

</t>
<t tx="ekr.20230509052845.3450">def _list_add_opt_literal_append(ans: List[T], elem: T):
    ans.arr.ptr[ans.len] = elem
    ans.len += 1

</t>
<t tx="ekr.20230509052845.3451">def _list_add_opt_opt_new(capacity: int):
    return List[T](capacity=capacity)

</t>
<t tx="ekr.20230509052845.3452">@path C:/Repos/codon/stdlib/internal/types/collections/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# set implementation based on klib's khash

from internal.attributes import commutative, associative
import internal.khash as khash
import internal.gc as gc

@others
set = Set
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3453">def _set_hash(key) -&gt; int:
    k = key.__hash__()
    return (k &gt;&gt; 33) ^ k ^ (k &lt;&lt; 11)

</t>
<t tx="ekr.20230509052845.3454">class Set:
    _n_buckets: int
    _size: int
    _n_occupied: int
    _upper_bound: int

    _flags: Ptr[u32]
    _keys: Ptr[K]

    K: type

    @others
</t>
<t tx="ekr.20230509052845.3455"># Magic methods
def _init(self):
    self._n_buckets = 0
    self._size = 0
    self._n_occupied = 0
    self._upper_bound = 0
    self._flags = Ptr[u32]()
    self._keys = Ptr[K]()

</t>
<t tx="ekr.20230509052845.3456">def __init__(self):
    self._init()

</t>
<t tx="ekr.20230509052845.3457">def __init__(self, g: Generator[K]):
    self._init()
    for a in g:
        self.add(a)

</t>
<t tx="ekr.20230509052845.3458">def __sub__(self, other: Set[K]) -&gt; Set[K]:
    return self.difference(other)

</t>
<t tx="ekr.20230509052845.3459">def __isub__(self, other: Set[K]) -&gt; Set[K]:
    self.difference_update(other)
    return self

</t>
<t tx="ekr.20230509052845.346">template &lt;&gt;
struct fmt::formatter&lt;codon::ir::analyze::dataflow::CFGraph&gt; : fmt::ostream_formatter {
};

#undef DEFAULT_VISIT
</t>
<t tx="ekr.20230509052845.3460">@commutative
@associative
def __and__(self, other: Set[K]) -&gt; Set[K]:
    return self.intersection(other)

</t>
<t tx="ekr.20230509052845.3461">def __iand__(self, other: Set[K]) -&gt; Set[K]:
    self.intersection_update(other)
    return self

</t>
<t tx="ekr.20230509052845.3462">@commutative
@associative
def __or__(self, other: Set[K]) -&gt; Set[K]:
    return self.union(other)

</t>
<t tx="ekr.20230509052845.3463">def __ior__(self, other: Set[K]) -&gt; Set[K]:
    for a in other:
        self.add(a)
    return self

</t>
<t tx="ekr.20230509052845.3464">@commutative
@associative
def __xor__(self, other: Set[K]) -&gt; Set[K]:
    return self.symmetric_difference(other)

</t>
<t tx="ekr.20230509052845.3465">def __ixor__(self, other: Set[K]) -&gt; Set[K]:
    self.symmetric_difference_update(other)
    return self

</t>
<t tx="ekr.20230509052845.3466">def __contains__(self, key: K) -&gt; bool:
    return self._kh_get(key) != self._kh_end()

</t>
<t tx="ekr.20230509052845.3467">def __eq__(self, other: Set[K]) -&gt; bool:
    if self.__len__() != other.__len__():
        return False
    for k in self:
        if k not in other:
            return False
    return True

</t>
<t tx="ekr.20230509052845.3468">def __ne__(self, other: Set[K]) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.3469">def __le__(self, other: Set[K]) -&gt; bool:
    return self.issubset(other)

</t>
<t tx="ekr.20230509052845.347">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;set&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/cfg.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

@others
} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3470">def __ge__(self, other: Set[K]) -&gt; bool:
    return self.issuperset(other)

</t>
<t tx="ekr.20230509052845.3471">def __lt__(self, other: Set[K]) -&gt; bool:
    return self != other and self &lt;= other

</t>
<t tx="ekr.20230509052845.3472">def __gt__(self, other: Set[K]) -&gt; bool:
    return self != other and self &gt;= other

</t>
<t tx="ekr.20230509052845.3473">def __iter__(self) -&gt; Generator[K]:
    i = self._kh_begin()
    while i &lt; self._kh_end():
        if self._kh_exist(i):
            yield self._keys[i]
        i += 1

</t>
<t tx="ekr.20230509052845.3474">def __len__(self) -&gt; int:
    return self._size

</t>
<t tx="ekr.20230509052845.3475">def __bool__(self) -&gt; bool:
    return self.__len__() != 0

</t>
<t tx="ekr.20230509052845.3476">def __copy__(self) -&gt; Set[K]:
    if self.__len__() == 0:
        return Set[K]()
    n = self._n_buckets
    f = khash.__ac_fsize(n)
    flags_copy = Ptr[u32](f)
    keys_copy = Ptr[K](n)
    str.memcpy(flags_copy.as_byte(), self._flags.as_byte(), f * gc.sizeof(u32))
    str.memcpy(keys_copy.as_byte(), self._keys.as_byte(), n * gc.sizeof(K))
    return Set[K](
        n, self._size, self._n_occupied, self._upper_bound, flags_copy, keys_copy
    )

</t>
<t tx="ekr.20230509052845.3477">def __deepcopy__(self) -&gt; Set[K]:
    return {s.__deepcopy__() for s in self}

</t>
<t tx="ekr.20230509052845.3478">def __repr__(self) -&gt; str:
    n = self.__len__()
    if n == 0:
        return "set()"
    else:
        buf = _strbuf()
        buf.append("{")
        first = True
        for k in self:
            if not first:
                buf.append(", ")
            else:
                first = False
            buf.append(k.__repr__())
        buf.append("}")
        return buf.__str__()

</t>
<t tx="ekr.20230509052845.3479"># Helper methods

</t>
<t tx="ekr.20230509052845.348">/// Helper to query the dominators of a particular function.
class DominatorInspector {
private:
  std::unordered_map&lt;id_t, std::set&lt;id_t&gt;&gt; sets;
  CFGraph *cfg;

public:
  explicit DominatorInspector(CFGraph *cfg) : cfg(cfg) {}

  /// Do the analysis.
  void analyze();

  /// Checks if one value dominates another.
  /// @param v the value
  /// @param dominator the dominator value
  bool isDominated(const Value *v, const Value *dominator);
};

</t>
<t tx="ekr.20230509052845.3480">def resize(self, new_n_buckets: int):
    self._kh_resize(new_n_buckets)

</t>
<t tx="ekr.20230509052845.3481">def add(self, key: K):
    self._kh_put(key)

</t>
<t tx="ekr.20230509052845.3482">def update(self, other: Generator[K]):
    for k in other:
        self.add(k)

</t>
<t tx="ekr.20230509052845.3483">def remove(self, key: K):
    x = self._kh_get(key)
    if x != self._kh_end():
        self._kh_del(x)
    else:
        raise KeyError(str(key))

</t>
<t tx="ekr.20230509052845.3484">def pop(self) -&gt; K:
    if self.__len__() == 0:
        raise ValueError("empty set")
    for a in self:
        self.remove(a)
        return a

</t>
<t tx="ekr.20230509052845.3485">def discard(self, key: K):
    x = self._kh_get(key)
    if x != self._kh_end():
        self._kh_del(x)

</t>
<t tx="ekr.20230509052845.3486">def difference(self, other: Set[K]) -&gt; Set[K]:
    s = Set[K]()
    for a in self:
        if a not in other:
            s.add(a)
    return s

</t>
<t tx="ekr.20230509052845.3487">def difference_update(self, other: Set[K]):
    for a in other:
        self.discard(a)

</t>
<t tx="ekr.20230509052845.3488">def intersection(self, other: Set[K]) -&gt; Set[K]:
    if other.__len__() &lt; self.__len__():
        self, other = other, self
    s = Set[K]()
    for a in self:
        if a in other:
            s.add(a)
    return s

</t>
<t tx="ekr.20230509052845.3489">def intersection_update(self, other: Set[K]):
    for a in self:
        if a not in other:
            self.discard(a)

</t>
<t tx="ekr.20230509052845.349">/// Result of a dominator analysis.
struct DominatorResult : public Result {
  /// the corresponding control flow result
  const CFResult *cfgResult;
  /// the dominator inspectors
  std::unordered_map&lt;id_t, std::unique_ptr&lt;DominatorInspector&gt;&gt; results;

  explicit DominatorResult(const CFResult *cfgResult) : cfgResult(cfgResult) {}
};

</t>
<t tx="ekr.20230509052845.3490">def symmetric_difference(self, other: Set[K]) -&gt; Set[K]:
    s = Set[K]()
    for a in self:
        if a not in other:
            s.add(a)
    for a in other:
        if a not in self:
            s.add(a)
    return s

</t>
<t tx="ekr.20230509052845.3491">def symmetric_difference_update(self, other: Set[K]):
    for a in other:
        if a in self:
            self.discard(a)
    for a in self:
        if a in other:
            self.discard(a)

</t>
<t tx="ekr.20230509052845.3492">def union(self, other: Set[K]) -&gt; Set[K]:
    s = Set[K]()
    s.resize(
        self._n_buckets if self._n_buckets &gt;= other._n_buckets else other._n_buckets
    )
    for a in self:
        s.add(a)
    for a in other:
        s.add(a)
    return s

</t>
<t tx="ekr.20230509052845.3493">def isdisjoint(self, other: Set[K]) -&gt; bool:
    if other.__len__() &lt; self.__len__():
        self, other = other, self
    for a in self:
        if a in other:
            return False
    return True

</t>
<t tx="ekr.20230509052845.3494">def issubset(self, other: Set[K]) -&gt; bool:
    if other.__len__() &lt; self.__len__():
        return False
    for a in self:
        if a not in other:
            return False
    return True

</t>
<t tx="ekr.20230509052845.3495">def issuperset(self, other: Set[K]) -&gt; bool:
    return other.issubset(self)

</t>
<t tx="ekr.20230509052845.3496">def clear(self):
    self._kh_clear()

</t>
<t tx="ekr.20230509052845.3497">def copy(self) -&gt; Set[K]:
    return self.__copy__()

</t>
<t tx="ekr.20230509052845.3498"># Internal helpers

</t>
<t tx="ekr.20230509052845.3499">def _kh_clear(self):
    if self._flags:
        i = 0
        n = khash.__ac_fsize(self._n_buckets)
        while i &lt; n:
            self._flags[i] = u32(0xAAAAAAAA)
            i += 1
        self._size = 0
        self._n_occupied = 0

</t>
<t tx="ekr.20230509052845.35">def write_ppm(im, filename):
    magic = 'P6\n'
    maxval = 255
    w = len(im)
    h = len(im[0])

    #with open(filename, "w", encoding="latin1", newline='') as fp:
    with open(filename, "w") as fp:
        fp.write(magic)
        #fp.write('%i %i\n%i\n' % (w, h, maxval))
        fp.write(f'{w} {h}\n{maxval}\n')
        for j in range(h):
            for i in range(w):
                val = im[i][j]
                c = val * 255
                #fp.write('%c%c%c' % (c, c, c))
                c = chr(c)
                fp.write(f'{c}{c}{c}')


</t>
<t tx="ekr.20230509052845.350">/// Dominator analysis. Must have control flow-graph available.
class DominatorAnalysis : public Analysis {
private:
  /// the control-flow analysis key
  std::string cfAnalysisKey;

public:
  static const std::string KEY;

  /// Initializes a dominator analysis.
  /// @param cfAnalysisKey the control-flow analysis key
  explicit DominatorAnalysis(std::string cfAnalysisKey)
      : cfAnalysisKey(std::move(cfAnalysisKey)) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3500">def _kh_get(self, key: K) -&gt; int:
    if self._n_buckets:
        step = 0
        mask = self._n_buckets - 1
        k = _set_hash(key)
        i = k &amp; mask
        last = i
        while not khash.__ac_isempty(self._flags, i) and (
            khash.__ac_isdel(self._flags, i) or self._keys[i] != key
        ):
            step += 1
            i = (i + step) &amp; mask
            if i == last:
                return self._n_buckets
        return self._n_buckets if khash.__ac_iseither(self._flags, i) else i
    else:
        return 0

</t>
<t tx="ekr.20230509052845.3501">def _kh_resize(self, new_n_buckets: int):
    HASH_UPPER = 0.77
    new_flags = Ptr[u32]()
    j = 1

    # round up to next power of 2
    new_n_buckets -= 1
    new_n_buckets |= new_n_buckets &gt;&gt; 1
    new_n_buckets |= new_n_buckets &gt;&gt; 2
    new_n_buckets |= new_n_buckets &gt;&gt; 4
    new_n_buckets |= new_n_buckets &gt;&gt; 8
    new_n_buckets |= new_n_buckets &gt;&gt; 16
    new_n_buckets |= new_n_buckets &gt;&gt; 32
    new_n_buckets += 1

    if new_n_buckets &lt; 4:
        new_n_buckets = 4

    if self._size &gt;= int(new_n_buckets * HASH_UPPER + 0.5):
        j = 0
    else:
        fsize = khash.__ac_fsize(new_n_buckets)
        new_flags = Ptr[u32](fsize)
        i = 0
        while i &lt; fsize:
            new_flags[i] = u32(0xAAAAAAAA)
            i += 1

        if self._n_buckets &lt; new_n_buckets:
            self._keys = Ptr[K](
                gc.realloc(self._keys.as_byte(),
                           new_n_buckets * gc.sizeof(K),
                           self._n_buckets * gc.sizeof(K))
            )

    if j:
        j = 0
        while j != self._n_buckets:
            if khash.__ac_iseither(self._flags, j) == 0:
                key = self._keys[j]
                new_mask = new_n_buckets - 1
                khash.__ac_set_isdel_true(self._flags, j)

                while True:
                    step = 0
                    k = _set_hash(key)
                    i = k &amp; new_mask

                    while not khash.__ac_isempty(new_flags, i):
                        step += 1
                        i = (i + step) &amp; new_mask

                    khash.__ac_set_isempty_false(new_flags, i)
                    if (
                        i &lt; self._n_buckets
                        and khash.__ac_iseither(self._flags, i) == 0
                    ):
                        self._keys[i], key = key, self._keys[i]
                        khash.__ac_set_isdel_true(self._flags, i)
                    else:
                        self._keys[i] = key
                        break
            j += 1

        if self._n_buckets &gt; new_n_buckets:
            self._keys = Ptr[K](
                gc.realloc(self._keys.as_byte(),
                           new_n_buckets * gc.sizeof(K),
                           self._n_buckets * gc.sizeof(K))
            )

        self._flags = new_flags
        self._n_buckets = new_n_buckets
        self._n_occupied = self._size
        self._upper_bound = int(self._n_buckets * HASH_UPPER + 0.5)

</t>
<t tx="ekr.20230509052845.3502">def _kh_put(self, key: K) -&gt; Tuple[int, int]:
    if self._n_occupied &gt;= self._upper_bound:
        if self._n_buckets &gt; (self._size &lt;&lt; 1):
            self._kh_resize(self._n_buckets - 1)
        else:
            self._kh_resize(self._n_buckets + 1)

    mask = self._n_buckets - 1
    step = 0
    site = self._n_buckets
    x = site
    k = _set_hash(key)
    i = k &amp; mask
    if khash.__ac_isempty(self._flags, i):
        x = i
    else:
        last = i
        while not khash.__ac_isempty(self._flags, i) and (
            khash.__ac_isdel(self._flags, i) or self._keys[i] != key
        ):
            if khash.__ac_isdel(self._flags, i):
                site = i
            step += 1
            i = (i + step) &amp; mask
            if i == last:
                x = site
                break

        if x == self._n_buckets:
            if khash.__ac_isempty(self._flags, i) and site != self._n_buckets:
                x = site
            else:
                x = i

    ret = 0
    if khash.__ac_isempty(self._flags, x):
        self._keys[x] = key
        khash.__ac_set_isboth_false(self._flags, x)
        self._size += 1
        self._n_occupied += 1
        ret = 1
    elif khash.__ac_isdel(self._flags, x):
        self._keys[x] = key
        khash.__ac_set_isboth_false(self._flags, x)
        self._size += 1
        ret = 2

    return (ret, x)

</t>
<t tx="ekr.20230509052845.3503">def _kh_del(self, x: int):
    if x != self._n_buckets and not khash.__ac_iseither(self._flags, x):
        khash.__ac_set_isdel_true(self._flags, x)
        self._size -= 1

</t>
<t tx="ekr.20230509052845.3504">def _kh_begin(self) -&gt; int:
    return 0

</t>
<t tx="ekr.20230509052845.3505">def _kh_end(self) -&gt; int:
    return self._n_buckets

</t>
<t tx="ekr.20230509052845.3506">def _kh_exist(self, x: int) -&gt; bool:
    return not khash.__ac_iseither(self._flags, x)

</t>
<t tx="ekr.20230509052845.3507">@path C:/Repos/codon/stdlib/internal/types/collections/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3508">@tuple
class DynamicTuple:
    _ptr: Ptr[T]
    _len: int
    T: type

    @others
</t>
<t tx="ekr.20230509052845.3509">def __new__(x: List[T]):
    from internal.gc import sizeof
    n = x.__len__()
    p = Ptr[T](n)
    str.memcpy(p.as_byte(), x.arr.ptr.as_byte(), n * sizeof(T))
    return DynamicTuple(p, n)

</t>
<t tx="ekr.20230509052845.351">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;utility&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/cfg.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

@others
} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3510">def __new__(x: Generator[T]):
    from internal.gc import realloc, sizeof
    n = 0
    m = 0
    if hasattr(x, "__len__"):
        m = x.__len__()
    elif hasattr(x, "__length_hint__"):
        m = x.__length_hint__()
    else:
        m = 10
    p = Ptr[T](m)
    for a in x:
        if n == m:
            new_m = (1 + 3*m) // 2
            p = Ptr[T](realloc(p.as_byte(), new_m * sizeof(T), m * sizeof(T)))
            m = new_m
        p[n] = a
        n += 1

    return DynamicTuple(p, n)

</t>
<t tx="ekr.20230509052845.3511">def __new__():
    return DynamicTuple(Ptr[T](), 0)

</t>
<t tx="ekr.20230509052845.3512">def __len__(self):
    return self._len

</t>
<t tx="ekr.20230509052845.3513">def __bool__(self):
    return self._len &gt; 0

</t>
<t tx="ekr.20230509052845.3514">def _ensure_tuple(x):
    if not isinstance(x, Tuple):
        compile_error("expected tuple type")

</t>
<t tx="ekr.20230509052845.3515">def __eq__(self, other):
    DynamicTuple._ensure_tuple(other)

    p = self._ptr
    n = self._len

    if staticlen(other) == 0:
        return n == 0

    if n != staticlen(other):
        return False

    for i in range(n):
        if p[i] != other[i]:
            return False

    return True

</t>
<t tx="ekr.20230509052845.3516">def __eq__(self, other: DynamicTuple[T]):
    p = self._ptr
    n = self._len
    q = other._ptr
    m = other._len

    if n != m:
        return False

    for i in range(n):
        if p[i] != q[i]:
            return False

    return True

</t>
<t tx="ekr.20230509052845.3517">def __ne__(self, other):
    DynamicTuple._ensure_tuple(other)
    return not (self == other)

</t>
<t tx="ekr.20230509052845.3518">def __ne__(self, other: DynamicTuple[T]):
    return not (self == other)

</t>
<t tx="ekr.20230509052845.3519">def _cmp(self, other):
    DynamicTuple._ensure_tuple(other)
    p = self._ptr
    n = self._len

    if staticlen(other) == 0:
        return (1 if n &gt; 0 else 0)

    m = staticlen(other)

    for i in range(n if n &lt; m else m):
        a = p[i]
        b = other[i]

        if a &lt; b:
            return -1
        elif a == b:
            pass
        else:
            return 1

    if n &lt; m:
        return -1
    elif n == m:
        return 0
    else:
        return 1

</t>
<t tx="ekr.20230509052845.352">/// Helper to query the reaching definitions of a particular function.
class RDInspector {
private:
  struct BlockData {
    std::unordered_map&lt;id_t, std::unordered_set&lt;id_t&gt;&gt; in;
    BlockData() = default;
  };
  std::unordered_set&lt;id_t&gt; invalid;
  std::unordered_map&lt;id_t, BlockData&gt; sets;
  CFGraph *cfg;

public:
  explicit RDInspector(CFGraph *cfg) : cfg(cfg) {}

  /// Do the analysis.
  void analyze();

  /// Gets the reaching definitions at a particular location.
  /// @param var the variable being inspected
  /// @param loc the location
  /// @return an unordered set of value ids
  std::unordered_set&lt;id_t&gt; getReachingDefinitions(const Var *var, const Value *loc);

  bool isInvalid(const Var *var) const { return invalid.count(var-&gt;getId()) != 0; }
};

</t>
<t tx="ekr.20230509052845.3520">def _cmp(self, other: DynamicTuple[T]):
    p = self._ptr
    n = self._len
    q = other._ptr
    m = other._len

    for i in range(n if n &lt; m else m):
        a = p[i]
        b = q[i]

        if a &lt; b:
            return -1
        elif a == b:
            pass
        else:
            return 1

    if n &lt; m:
        return -1
    elif n == m:
        return 0
    else:
        return 1

</t>
<t tx="ekr.20230509052845.3521">def __lt__(self, other):
    return self._cmp(other) &lt; 0

</t>
<t tx="ekr.20230509052845.3522">def __gt__(self, other):
    return self._cmp(other) &gt; 0

</t>
<t tx="ekr.20230509052845.3523">def __le__(self, other):
    return self._cmp(other) &lt;= 0

</t>
<t tx="ekr.20230509052845.3524">def __ge__(self, other):
    return self._cmp(other) &gt;= 0

</t>
<t tx="ekr.20230509052845.3525">def __lt__(self, other: DynamicTuple[T]):
    return self._cmp(other) &lt; 0

</t>
<t tx="ekr.20230509052845.3526">def __gt__(self, other: DynamicTuple[T]):
    return self._cmp(other) &gt; 0

</t>
<t tx="ekr.20230509052845.3527">def __le__(self, other: DynamicTuple[T]):
    return self._cmp(other) &lt;= 0

</t>
<t tx="ekr.20230509052845.3528">def __ge__(self, other: DynamicTuple[T]):
    return self._cmp(other) &gt;= 0

</t>
<t tx="ekr.20230509052845.3529">def __hash__(self):
    p = self._ptr
    n = self._len
    seed = 0
    for i in range(n):
        seed = seed ^ ((p[i].__hash__() + 2654435769) + ((seed &lt;&lt; 6) + (seed &gt;&gt; 2)))
    return seed

</t>
<t tx="ekr.20230509052845.353">/// Result of a reaching definition analysis.
struct RDResult : public Result {
  /// the corresponding control flow result
  const CFResult *cfgResult;
  /// the reaching definition inspectors
  std::unordered_map&lt;id_t, std::unique_ptr&lt;RDInspector&gt;&gt; results;

  explicit RDResult(const CFResult *cfgResult) : cfgResult(cfgResult) {}
};

</t>
<t tx="ekr.20230509052845.3530">def __iter__(self):
    p = self._ptr
    n = self._len
    for i in range(n):
        yield p[i]

</t>
<t tx="ekr.20230509052845.3531">def __contains__(self, item: T):
    p = self._ptr
    n = self._len
    for i in range(n):
        if p[i] == item:
            return True
    return False

</t>
<t tx="ekr.20230509052845.3532">def __getitem__(self, idx: int):
    p = self._ptr
    n = self._len
    if idx &lt; 0:
        idx += n
    if idx &lt; 0 or idx &gt;= n:
        raise IndexError(f"tuple index {idx} out of range 0..{n}")
    return p[idx]

</t>
<t tx="ekr.20230509052845.3533">def __getitem__(self, s: Slice):
    p = self._ptr
    n = self._len

    if s.start is None and s.stop is None and s.step is None:
        return self
    if s.step is None:
        start, stop, step, length = s.adjust_indices(n)
        return DynamicTuple(p + start, length)
    else:
        start, stop, step, length = s.adjust_indices(n)
        q = Ptr[T](length)
        n = 0
        for i in range(start, stop, step):
            q[n] = self[i]
            n += 1
        return DynamicTuple(q, length)

</t>
<t tx="ekr.20230509052845.3534">def __repr__(self):
    return f"({', '.join(a.__repr__() for a in self)})"
</t>
<t tx="ekr.20230509052845.3535"></t>
<t tx="ekr.20230509052845.3536">@path C:/Repos/codon/stdlib/os/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3537">def splitext(p: str) -&gt; Tuple[str, str]:
    """
    Split the extension from a pathname.
    Extension is everything from the last dot to the end, ignoring
    leading dots.  Returns "(root, ext)"; ext may be empty."""
    sep = "/"
    extsep = "."

    sepIndex = p.rfind(sep)
    dotIndex = p.rfind(extsep)
    if dotIndex &gt; sepIndex:
        # skip all leading dots
        filenameIndex = sepIndex + 1
        while filenameIndex &lt; dotIndex:
            if p[filenameIndex : filenameIndex + 1] != extsep:
                return p[:dotIndex], p[dotIndex:]
            filenameIndex += 1
    return p, p[:0]
</t>
<t tx="ekr.20230509052845.3538">@path C:/Repos/codon/stdlib/os/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3539">def system(cmd: str) -&gt; int:
    return _C.system(cmd.c_str())

</t>
<t tx="ekr.20230509052845.354">/// Reaching definition analysis. Must have control flow-graph available.
class RDAnalysis : public Analysis {
private:
  /// the control-flow analysis key
  std::string cfAnalysisKey;

public:
  static const std::string KEY;

  /// Initializes a reaching definition analysis.
  /// @param cfAnalysisKey the control-flow analysis key
  explicit RDAnalysis(std::string cfAnalysisKey)
      : cfAnalysisKey(std::move(cfAnalysisKey)) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3540">SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

</t>
<t tx="ekr.20230509052845.3541">@tuple
class EnvMap:
    _map: Dict[str, str]

    @others
</t>
<t tx="ekr.20230509052845.3542">def __new__() -&gt; EnvMap:
    return (Dict[str, str](),)

</t>
<t tx="ekr.20230509052845.3543">def _init_if_needed(self):
    if len(self._map) == 0:
        env = _C.seq_env()
        p = env[0]
        i = 0
        while p:
            s = str.from_ptr(p)
            if s:
                j = 0
                found = False
                while j &lt; len(s):
                    if s[j] == "=":
                        found = True
                        break
                    j += 1
                k = s[0:j] if found else s
                v = s[j + 1 :] if found else ""
                self._map[k] = v
            i += 1
            p = env[i]

</t>
<t tx="ekr.20230509052845.3544">def __getitem__(self, key: str) -&gt; str:
    self._init_if_needed()
    return self._map[key]

</t>
<t tx="ekr.20230509052845.3545">def __repr__(self) -&gt; str:
    self._init_if_needed()
    return repr(self._map)

</t>
<t tx="ekr.20230509052845.3546">def __contains__(self, key: str) -&gt; bool:
    self._init_if_needed()
    return key in self._map

</t>
<t tx="ekr.20230509052845.3547">def __iter__(self) -&gt; Generator[Tuple[str, str]]:
    self._init_if_needed()
    return self._map.items()

</t>
<t tx="ekr.20230509052845.3548">environ = EnvMap()

</t>
<t tx="ekr.20230509052845.3549">def getenv(key: str, default: str = "") -&gt; str:
    return environ[key] if key in environ else default

</t>
<t tx="ekr.20230509052845.355"></t>
<t tx="ekr.20230509052845.3550">def mkdir(name: str, mode: int = 0x1FF) -&gt; int:
    # TODO: use errno
    from C import mkdir(cobj, int) -&gt; int
    ret = mkdir(name.ptr, mode)
    if ret != 0:
        raise OSError("mkdir failed")
</t>
<t tx="ekr.20230509052845.3551"></t>
<t tx="ekr.20230509052845.3552"></t>
<t tx="ekr.20230509052845.3553">@path C:/Repos/codon/test/app/
from sys import argv
print(','.join(argv[1:]))
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3554">@path C:/Repos/codon/test/app/
print('hello')
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3555">@path C:/Repos/codon/test/app/
import sys
sys.exit(42)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3556">@path C:/Repos/codon/test/app/
a = ['a', 'b', 'c']

@export
def foo(n: int):
    print(''.join(a) * n)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3557">@path C:/Repos/codon/test/app/
extern void foo(long);
int main(void) { foo(3); }
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3558"></t>
<t tx="ekr.20230509052845.3559">@path C:/Repos/codon/test/cir/
#include &lt;algorithm&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/cloning.h"
#include "gtest/gtest.h"

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.356">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/analyze/analysis.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {

struct GlobalVarsResult : public Result {
  std::unordered_map&lt;id_t, id_t&gt; assignments;
  explicit GlobalVarsResult(std::unordered_map&lt;id_t, id_t&gt; assignments)
      : assignments(std::move(assignments)) {}
};

@others
} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3560">class CIRCoreTest : public testing::Test {
protected:
  std::unique_ptr&lt;codon::ir::Module&gt; module;
  std::unique_ptr&lt;codon::ir::util::CloneVisitor&gt; cv;

@others
};
</t>
<t tx="ekr.20230509052845.3561">  void SetUp() override {
    codon::ir::IdMixin::resetId();
    module = std::make_unique&lt;codon::ir::Module&gt;("test");
    cv = std::make_unique&lt;codon::ir::util::CloneVisitor&gt;(module.get());
  }
</t>
<t tx="ekr.20230509052845.3562"></t>
<t tx="ekr.20230509052845.3563">@path C:/Repos/codon/test/core/
@others
test_named_construct2(0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3564">@test
def t1():
    def baz(x, y, z = 3):
        return x, y, z
    assert baz(1, 2, 3) == (1, 2, 3)
    assert baz(1, 3) == (1, 3, 3)
    assert baz(z = 'z', y = 'y', x = 'x') == ('x', 'y', 'z')
    assert baz(y = 'y', x = 'x') == ('x', 'y', 3)
    assert baz('x', y = 'y') == ('x', 'y', 3)
</t>
<t tx="ekr.20230509052845.3565">t1()

</t>
<t tx="ekr.20230509052845.3566">class A:
    def foo(self: A, x = 3, y = 'hello'):
        return x, y

</t>
<t tx="ekr.20230509052845.3567">@test
def t2():
    assert A().foo(y = 3.14, x = 42) == (42, 3.14)
</t>
<t tx="ekr.20230509052845.3568">t2()

</t>
<t tx="ekr.20230509052845.3569">def g[T](a: T, b: optional[T] = None):
    b: T = b if b else T()
    return a, b

</t>
<t tx="ekr.20230509052845.357">class GlobalVarsAnalyses : public Analysis {
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3570">@test
def t3():
    assert g(99, 4242) == (99, 4242)
    assert g(99) == (99, 0)
    assert (None |&gt; g(a=1, b=...)) == (1, 0)
</t>
<t tx="ekr.20230509052845.3571">t3()

</t>
<t tx="ekr.20230509052845.3572">def _unwrap(opt: Optional[T], T: type) -&gt; T:
    return opt

</t>
<t tx="ekr.20230509052845.3573">def foo(x: int, y: int, z: optional[list[float]]):
    xs = str(x)
    ys = str(y)
    zs = str(_unwrap(z)) if z else 'None'
    return xs, ys, zs

</t>
<t tx="ekr.20230509052845.3574">@test
def t4():
    assert foo(1, 2, [3.14]) == ('1', '2', '[3.14]')
    assert foo(77, 99, None) == ('77', '99', 'None')
</t>
<t tx="ekr.20230509052845.3575">t4()

</t>
<t tx="ekr.20230509052845.3576">class A:
    @others
</t>
<t tx="ekr.20230509052845.3577">def __init__(self: A):
    pass

</t>
<t tx="ekr.20230509052845.3578">def foo(x: int, y: int, z: optional[list[float]]):
    xs = str(x)
    ys = str(y)
    zs = str(_unwrap(z)) if z else 'None'
    return xs, ys, zs

</t>
<t tx="ekr.20230509052845.3579"># TODO: def bar[S](self: A, x: S, y: S, z: optional[type(S() + 0.0)] = None)
def bar[S](self: A, x: S, y: S, z: optional[S] = None):
    xs = str(x)
    ys = str(y)
    zs = str(_unwrap(z)) if z else 'None'
    return xs, ys, zs

</t>
<t tx="ekr.20230509052845.358">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/util/side_effect.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {

struct SideEffectResult : public Result {
  /// mapping of ID to corresponding node's side effect status
  std::unordered_map&lt;id_t, util::SideEffectStatus&gt; result;

  SideEffectResult(std::unordered_map&lt;id_t, util::SideEffectStatus&gt; result)
      : result(std::move(result)) {}

  /// @param v the value to check
  /// @return true if the node has side effects (false positives allowed)
  bool hasSideEffect(const Value *v) const;
};

@others
} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3580">@test
def t5():
    assert A.foo(1, 2, [3.14]) == ('1', '2', '[3.14]')
    assert A.foo(77, 99, None) == ('77', '99', 'None')

    assert A().bar(1.0, 2.0, 3.14) == ('1', '2', '3.14')
    assert A().bar(77, 99, None) == ('77', '99', 'None')
    assert A().bar(77, 99) == ('77', '99', 'None')

    assert (1 |&gt; foo(2, [3.14])) == ('1', '2', '[3.14]')
    assert (1 |&gt; foo(77, ..., None)) == ('77', '1', 'None')
    assert (None |&gt; foo(-5, -1, ...)) == ('-5', '-1', 'None')
    assert ([1.23] |&gt; foo(-5, -1, ...)) == ('-5', '-1', '[1.23]')
</t>
<t tx="ekr.20230509052845.3581">t5()

</t>
<t tx="ekr.20230509052845.3582"># test auto-iter
@test
def t6():
    assert list('abc') == ['a', 'b', 'c']

    @others
    assert it1([1, 2, 3]) == [1, 2, 3]
    assert it2(iter([1.1, 2.2, 3.3])) == [1.1, 2.2, 3.3]
    assert it3() == ['x', 'y', 'z']
</t>
<t tx="ekr.20230509052845.3583">def it1[T](v: generator[T]):
    return list(v)

</t>
<t tx="ekr.20230509052845.3584">def it2[T](v: T):
    return list(v)

</t>
<t tx="ekr.20230509052845.3585">def it3[T](v: generator[T] = 'xyz'):
    return list(v)

</t>
<t tx="ekr.20230509052845.3586">t6()

</t>
<t tx="ekr.20230509052845.3587">class B[T]:
    a: T
    b: tuple[int,int,int]

    @others
</t>
<t tx="ekr.20230509052845.3588">def __init__(self: B[T], y: T):
    self.a = y
    self.b = 0, 0, 0

</t>
<t tx="ekr.20230509052845.3589">def __init__(self: B[T], y: T, foo: int):
    self.a = y
    self.b = foo, 1, 0

</t>
<t tx="ekr.20230509052845.359">class SideEffectAnalysis : public Analysis {
private:
  /// the capture analysis key
  std::string capAnalysisKey;
  /// true if assigning to a global variable automatically has side effects
  bool globalAssignmentHasSideEffects;

public:
  static const std::string KEY;

  /// Constructs a side effect analysis.
  /// @param globalAssignmentHasSideEffects true if global variable assignment
  /// automatically has side effects
  explicit SideEffectAnalysis(const std::string &amp;capAnalysisKey,
                              bool globalAssignmentHasSideEffects = true)
      : Analysis(), capAnalysisKey(capAnalysisKey),
        globalAssignmentHasSideEffects(globalAssignmentHasSideEffects) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509052845.3590">def __init__(self: B[T], x: list[T], a: int, b: int, c: int):
    self.a = x[0]
    self.b = a, b, c

</t>
<t tx="ekr.20230509052845.3591">def __init__(self: B[T], a: T, b: T):
    self.a, self.b = a + b, (-1, -1, -1)

</t>
<t tx="ekr.20230509052845.3592">@property
def val(self: B[T]):
    return self.a, self.b

</t>
<t tx="ekr.20230509052845.3593">@test
def test_named_construct1(_):
    assert B(10).val == (10, (0, 0, 0))
    assert B(y=-10).val == (-10, (0, 0, 0))
    assert B[bool](y=False).val == (False, (0, 0, 0))
    assert B(b=2, x=[3.14], c=3, a=1).val == (3.14, (1, 2, 3))
    assert B(x=[3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert B([3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert B([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert B[float]([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert B([3.14], 1, 2, c=3).val == (3.14, (1, 2, 3))
    assert B(foo=42, y='hello').val == ('hello', (42, 1, 0))
    assert B(a='a', b='b').val == ('ab', (-1, -1, -1))
    assert B(b='b', a='a').val == ('ab', (-1, -1, -1))
</t>
<t tx="ekr.20230509052845.3594">test_named_construct1(0)

</t>
<t tx="ekr.20230509052845.3595">@tuple
class C:
    a: float
    b: tuple[int,int,int]

    @others
</t>
<t tx="ekr.20230509052845.3596">def __new__(y: float) -&gt; C:
    return (y, (0, 0, 0))

</t>
<t tx="ekr.20230509052845.3597">def __new__(y: float, foo: int) -&gt; C:
    return (y, (foo, 1, 0))

</t>
<t tx="ekr.20230509052845.3598">def __new__(x: list[float], a: int, b: int, c: int) -&gt; C:
    return (x[0], (a, b, c))

</t>
<t tx="ekr.20230509052845.3599">def __new__(a: int, b: int):
    return (a, b)

</t>
<t tx="ekr.20230509052845.36">class Chaosgame(object):
    splines: List[Spline]
    thickness: float
    minx: float
    miny: float
    maxx: float
    maxy: float
    height: float
    width: float
    num_trafos: List[int]
    num_total: int

    @others
</t>
<t tx="ekr.20230509052845.360"></t>
<t tx="ekr.20230509052845.3600">@property
def val(self: C):
    return self.a, self.b

</t>
<t tx="ekr.20230509052845.3601">@test
def test_named_construct2(_):
    assert C(10.0).val == (10.0, (0, 0, 0))
    assert C(y=-10.0).val == (-10.0, (0, 0, 0))
    assert C(b=2, x=[3.14], c=3, a=1).val == (3.14, (1, 2, 3))
    assert C(x=[3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert C([3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, 2, c=3).val == (3.14, (1, 2, 3))
    assert C(foo=42, y=-4.2).val == (-4.2, (42, 1, 0))
    assert C(a=111, b=222) == (111, 222)
    assert C(b=222, a=111) == (111, 222)
</t>
<t tx="ekr.20230509052845.3602">@path C:/Repos/codon/test/core/
@others
test_int_pow()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3603">@test
def t1():
    assert 2 + 2 == 4
    assert 3.14 * 2 == 6.28
    assert 2 + 3*2 == 8
    assert 1.0/0 == float('inf')
    assert str(0.0/0) == 'nan'

    assert 5 // 2 == 2
    assert 5 / 2 == 2.5
    assert 5.0 // 2.0 == 2
    assert 5.0 / 2.0 == 2.5
    assert 5 // 2.0 == 2
    assert 5 / 2.0 == 2.5
    assert 5.0 // 2 == 2
    assert 5.0 / 2 == 2.5
    assert int(Int[128](5) // Int[128](2)) == 2
    assert Int[128](5) / Int[128](2) == 2.5
</t>
<t tx="ekr.20230509052845.3604">t1()

</t>
<t tx="ekr.20230509052845.3605">@test
def test_popcnt():
    assert (42).popcnt() == 3
    assert (123).popcnt() == 6
    assert (0).popcnt() == 0
    assert int.popcnt(-1) == 64
    assert u8(-1).popcnt() == 8
    assert (UInt[1024](0xfffffffffffffff3) * UInt[1024](0xfffffffffffffff3)).popcnt() == 4
    assert UInt[128](-1).popcnt() == 128
</t>
<t tx="ekr.20230509052845.3606">test_popcnt()

</t>
<t tx="ekr.20230509052845.3607">@test
def test_conversions():
    # int -&gt; int, float, bool, str
    assert int(-42) == -42
    assert float(-42) == -42.0
    assert bool(0) == False
    assert bool(-1) == bool(1) == True
    assert str(-42) == '-42'

    # float -&gt; int, float, bool, str
    assert int(-4.2) == -4
    assert int(4.2) == 4
    assert float(-4.2) == -4.2
    assert bool(0.0) == False
    assert bool(-0.1) == bool(0.1) == True
    assert str(-4.2) == '-4.2'

    # bool -&gt; int, float, bool, str
    assert int(False) == 0
    assert int(True) == 1
    assert float(False) == 0.0
    assert float(True) == 1.0
    assert bool(False) == False
    assert bool(True) == True
    assert str(False) == 'False'
    assert str(True) == 'True'

    # byte -&gt; int, float, bool, str
    assert int(byte(42)) == 42
    assert float(byte(42)) == 42.0
    assert bool(byte(0)) == False
    assert bool(byte(42)) == True
    assert str(byte(42)) == '*'

    # intN -&gt; int, float, bool, str | N &lt; 64
    assert int(i32(-42)) == -42
    assert float(i32(-42)) == -42.0
    assert bool(i32(0)) == False
    assert bool(i32(-1)) == bool(i32(1)) == True
    assert str(i32(-42)) == '-42'

    # intN -&gt; int, float, bool, str | N == 64
    assert int(Int[64](-42)) == -42
    assert float(Int[64](-42)) == -42.0
    assert bool(Int[64](0)) == False
    assert bool(Int[64](-1)) == bool(Int[64](1)) == True
    assert str(Int[64](-42)) == '-42'

    # intN -&gt; int, float, bool, str | N &gt; 64
    assert int(Int[80](-42)) == -42
    assert float(Int[80](-42)) == -42.0
    assert bool(Int[80](0)) == False
    assert bool(Int[80](-1)) == bool(Int[80](1)) == True
    assert str(Int[80](-42)) == '-42'

    # uintN -&gt; int, float, bool, str | N &lt; 64
    assert int(u32(42)) == 42
    assert float(u32(42)) == 42.0
    assert bool(u32(0)) == False
    assert bool(u32(42)) == True
    assert str(u32(42)) == '42'

    # uintN -&gt; int, float, bool, str | N == 64
    assert int(UInt[64](42)) == 42
    assert float(UInt[64](42)) == 42.0
    assert bool(UInt[64](0)) == False
    assert bool(UInt[64](42)) == True
    assert str(UInt[64](42)) == '42'

    # uintN -&gt; int, float, bool, str | N &gt; 64
    assert int(UInt[80](42)) == 42
    assert float(UInt[80](42)) == 42.0
    assert bool(UInt[80](0)) == False
    assert bool(Int[80](42)) == True
    assert str(Int[80](42)) == '42'
</t>
<t tx="ekr.20230509052845.3608">test_conversions()

</t>
<t tx="ekr.20230509052845.3609">@test
def test_int_pow():
    @others
    assert f(3) ** f(2) == 9
    assert f(27) ** f(7) == 10460353203
    assert f(-27) ** f(7) == -10460353203
    assert f(-27) ** f(6) == 387420489
    assert f(1) ** f(0) == 1
    assert f(1) ** f(1000) == 1
    assert f(0) ** f(3) == 0
    assert f(0) ** f(0) == 1

    T1 = Int[512]
    assert f(T1(3)) ** f(T1(2)) == T1(9)
    assert f(T1(27)) ** f(T1(7)) == T1(10460353203)
    assert f(T1(-27)) ** f(T1(7)) == T1(-10460353203)
    assert f(T1(-27)) ** f(T1(6)) == T1(387420489)
    assert f(T1(1)) ** f(T1(0)) == T1(1)
    assert f(T1(1)) ** f(T1(1000)) == T1(1)
    assert f(T1(0)) ** f(T1(3)) == T1(0)
    assert f(T1(0)) ** f(T1(0)) == T1(1)
    assert str(f(T1(31)) ** f(T1(31))) == '17069174130723235958610643029059314756044734431'
    assert str(f(T1(-31)) ** f(T1(31))) == '-17069174130723235958610643029059314756044734431'

    T2 = UInt[200]
    assert f(T2(3)) ** f(T2(2)) == T2(9)
    assert f(T2(27)) ** f(T2(7)) == T2(10460353203)
    assert f(T2(1)) ** f(T2(0)) == T2(1)
    assert f(T2(1)) ** f(T2(1000)) == T2(1)
    assert f(T2(0)) ** f(T2(3)) == T2(0)
    assert f(T2(0)) ** f(T2(0)) == T2(1)
    assert str(f(T2(31)) ** f(T2(31))) == '17069174130723235958610643029059314756044734431'
</t>
<t tx="ekr.20230509052845.361">@path C:/Repos/codon/codon/cir/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/cir/types/types.h"

namespace codon {
namespace ir {

namespace analyze {
namespace dataflow {
class CFVisitor;
} // namespace dataflow
} // namespace analyze

class LLVMVisitor;

namespace dsl {
namespace codegen {

/// Builder for LLVM types.
struct TypeBuilder {
  virtual ~TypeBuilder() noexcept = default;

  /// Construct the LLVM type.
  /// @param the LLVM visitor
  /// @return the LLVM type
  virtual llvm::Type *buildType(LLVMVisitor *visitor) = 0;
  /// Construct the LLVM debug type.
  /// @param the LLVM visitor
  /// @return the LLVM debug type
  virtual llvm::DIType *buildDebugType(LLVMVisitor *visitor) = 0;
};

/// Builder for LLVM values.
struct ValueBuilder {
  virtual ~ValueBuilder() noexcept = default;

  /// Construct the LLVM value.
  /// @param the LLVM visitor
  /// @return the LLVM value
  virtual llvm::Value *buildValue(LLVMVisitor *visitor) = 0;
};

/// Builder for control flow graphs.
struct CFBuilder {
  virtual ~CFBuilder() noexcept = default;

  /// Construct the control-flow nodes.
  /// @param graph the graph
  virtual void buildCFNodes(analyze::dataflow::CFVisitor *visitor) = 0;
};

} // namespace codegen
} // namespace dsl
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3610">@nonpure
def f(n):
    return n

</t>
<t tx="ekr.20230509052845.3611">@path C:/Repos/codon/test/core/
# Python-specific

@others
test_narrow_int_str(Int[7])
test_narrow_int_str(Int[8])
test_narrow_int_str(Int[10])
test_narrow_int_str(Int[16])
test_narrow_int_str(Int[32])
test_narrow_int_str(Int[60])
test_narrow_int_str(Int[63])
test_narrow_int_str(Int[64])

test_narrow_uint_str(UInt[7])
test_narrow_uint_str(UInt[8])
test_narrow_uint_str(UInt[10])
test_narrow_uint_str(UInt[16])
test_narrow_uint_str(UInt[32])
test_narrow_uint_str(UInt[60])
test_narrow_uint_str(UInt[63])
test_narrow_uint_str(UInt[64])

test_wide_int_str(Int[128])
test_wide_int_str(Int[200])
test_wide_int_str(Int[256])
test_wide_int_str(Int[512])
test_wide_int_str(Int[1024])
test_wide_int_str(Int[2048])
test_wide_int_str(Int[4096])

test_wide_uint_str(UInt[128])
test_wide_uint_str(UInt[200])
test_wide_uint_str(UInt[256])
test_wide_uint_str(UInt[512])
test_wide_uint_str(UInt[1024])
test_wide_uint_str(UInt[2048])
test_wide_uint_str(UInt[4096])
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3612">@test
def test_min_max():
    assert max(2, 1, 1, 1, 1) == 2
    assert max(1, 2, 1, 1, 1) == 2
    assert max(1, 1, 2, 1, 1) == 2
    assert max(1, 1, 1, 2, 1) == 2
    assert max(1, 1, 1, 1, 2) == 2
    assert max(2, 1, 1, 1) == 2
    assert max(1, 2, 1, 1) == 2
    assert max(1, 1, 2, 1) == 2
    assert max(1, 1, 1, 2) == 2
    assert max(2, 1, 1) == 2
    assert max(1, 2, 1) == 2
    assert max(1, 1, 2) == 2
    assert max(2, 1) == 2
    assert max(1, 2) == 2

    assert min(2, 1, 1, 1, 1) == 1
    assert min(1, 2, 1, 1, 1) == 1
    assert min(1, 1, 2, 1, 1) == 1
    assert min(1, 1, 1, 2, 1) == 1
    assert min(1, 1, 1, 1, 2) == 1
    assert min(2, 1, 1, 1) == 1
    assert min(1, 2, 1, 1) == 1
    assert min(1, 1, 2, 1) == 1
    assert min(1, 1, 1, 2) == 1
    assert min(2, 1, 1) == 1
    assert min(1, 2, 1) == 1
    assert min(1, 1, 2) == 1
    assert min(2, 1) == 1
    assert min(1, 2) == 1

    assert max(0, 1, 1, 1, 1) == 1
    assert max(1, 0, 1, 1, 1) == 1
    assert max(1, 1, 0, 1, 1) == 1
    assert max(1, 1, 1, 0, 1) == 1
    assert max(1, 1, 1, 1, 0) == 1
    assert max(0, 1, 1, 1) == 1
    assert max(1, 0, 1, 1) == 1
    assert max(1, 1, 0, 1) == 1
    assert max(1, 1, 1, 0) == 1
    assert max(0, 1, 1) == 1
    assert max(1, 0, 1) == 1
    assert max(1, 1, 0) == 1
    assert max(0, 1) == 1
    assert max(1, 0) == 1

    assert min(0, 1, 1, 1, 1) == 0
    assert min(1, 0, 1, 1, 1) == 0
    assert min(1, 1, 0, 1, 1) == 0
    assert min(1, 1, 1, 0, 1) == 0
    assert min(1, 1, 1, 1, 0) == 0
    assert min(0, 1, 1, 1) == 0
    assert min(1, 0, 1, 1) == 0
    assert min(1, 1, 0, 1) == 0
    assert min(1, 1, 1, 0) == 0
    assert min(0, 1, 1) == 0
    assert min(1, 0, 1) == 0
    assert min(1, 1, 0) == 0
    assert min(0, 1) == 0
    assert min(1, 0) == 0

    assert min(a*a for a in range(3)) == 0
    assert max(a*a for a in range(3)) == 4
    assert min([0, 2, -1]) == -1
    assert max([0, 2, -1]) == 2

</t>
<t tx="ekr.20230509052845.3613">@test
def test_map_filter():
    assert list(map(lambda i: i+1, (i*2 for i in range(5)))) == [1, 3, 5, 7, 9]
    assert list(map(lambda i: i+1, (i*2 for i in range(0)))) == []
    assert list(map(lambda i: i//2, map(lambda i: i-1, map(lambda i: i+1, (i*2 for i in range(5)))))) == [0, 1, 2, 3, 4]
    @others
    assert h(list(map(lambda i: i-1, map(lambda i: i+1, range(5))))) == [0, 1, 2, 3, 4]

    assert list(filter(lambda i: i % 2 == 0, range(5))) == [0, 2, 4]
    assert list(filter(lambda i: i % 2 == 1, filter(lambda i: i % 2 == 0, range(5)))) == []

    assert list(filter(lambda i: i%2 == 0, map(lambda i: i*i, range(10)))) == [0, 4, 16, 36, 64]

</t>
<t tx="ekr.20230509052845.3614">def f(x: int) -&gt; int:
    return x - 1
</t>
<t tx="ekr.20230509052845.3615">def g(x: int) -&gt; int:
    return x + 1
</t>
<t tx="ekr.20230509052845.3616">assert list(map(f, map(g, (i*2 for i in range(5))))) == [0, 2, 4, 6, 8]

</t>
<t tx="ekr.20230509052845.3617">def h(x: list[int]):
    return x
</t>
<t tx="ekr.20230509052845.3618">@test
def test_gen_builtins():
    assert sum([1, 2, 3]) == 6
    assert sum([1, 2, 3], 0.5) == 6.5
    assert sum([True, False, True, False, True], 0.5) == 3.5
    assert sum(List[float]()) == 0
    assert sum(i/2 for i in range(10)) == 22.5

    @others
    assert all([True, True])
    assert all(i for i in range(0))
    assert not all([True, False])
    assert all(List[str]())
    assert all(g3(True, True))
    assert not all(g3(True, False))
    assert not all(g3(False, True))
    assert not all(g3(False, False))

    assert any([True, True])
    assert not any(i for i in range(0))
    assert not any([False, False])
    assert not any(List[bool]())
    assert any(g3(True, True))
    assert any(g3(True, False))
    assert any(g3(False, True))
    assert not any(g3(False, False))

</t>
<t tx="ekr.20230509052845.3619">def g1():
    yield 1.5
    yield 2.5
    return
    yield 3.5

</t>
<t tx="ekr.20230509052845.362">@path C:/Repos/codon/codon/cir/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/base.h"
#include "codon/cir/const.h"
#include "codon/cir/instr.h"
#include "codon/cir/util/side_effect.h"

namespace codon {
namespace ir {

namespace util {
class CloneVisitor;
} // namespace util

namespace dsl {

namespace codegen {
struct CFBuilder;
struct TypeBuilder;
struct ValueBuilder;
} // namespace codegen

namespace types {

@others
} // namespace dsl
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3620">assert sum(g1(), 10) == 14.0

</t>
<t tx="ekr.20230509052845.3621">def g2():
    yield True
    yield False
    yield True

</t>
<t tx="ekr.20230509052845.3622">assert sum(g2()) == 2

</t>
<t tx="ekr.20230509052845.3623">class A:
    iadd_count = 0
    n: int

    def __init__(self, n):
        self.n = n

    def __add__(self, other):
        return A(self.n + other.n)

    def __iadd__(self, other):
        A.iadd_count += 1
        self.n += other.n
        return self

</t>
<t tx="ekr.20230509052845.3624">assert sum((A(i) for i in range(5)), A(100)).n == 110
assert A.iadd_count == 0

</t>
<t tx="ekr.20230509052845.3625">def g3(a, b):
    for i in range(10):
        yield a
    yield b

</t>
<t tx="ekr.20230509052845.3626">@test
def test_int_format():
    n = 0
    assert (str(n), bin(n), oct(n), hex(n)) == ('0', '0b0', '0o0', '0x0')

    n = -1
    assert (str(n), bin(n), oct(n), hex(n)) == ('-1', '-0b1', '-0o1', '-0x1')

    n = 12345
    assert (str(n), bin(n), oct(n), hex(n)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    n = -12345
    assert (str(n), bin(n), oct(n), hex(n)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    # this one is different than Python due to 64-bit ints
    n = 0x8000000000000000
    assert (str(n), bin(n), oct(n), hex(n)) == ('-9223372036854775808', '-0b1000000000000000000000000000000000000000000000000000000000000000', '-0o1000000000000000000000', '-0x8000000000000000')

    n = 0x7fffffffffffffff
    assert (str(n), bin(n), oct(n), hex(n)) == ('9223372036854775807', '0b111111111111111111111111111111111111111111111111111111111111111', '0o777777777777777777777', '0x7fffffffffffffff')

    m = i32(0)
    assert (str(m), bin(m), oct(m), hex(m)) == ('0', '0b0', '0o0', '0x0')

    m = i32(-1)
    assert (str(m), bin(m), oct(m), hex(m)) == ('-1', '-0b1', '-0o1', '-0x1')

    m = i32(12345)
    assert (str(m), bin(m), oct(m), hex(m)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    m = i32(-12345)
    assert (str(m), bin(m), oct(m), hex(m)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    k = Int[128](0)
    assert (str(k), bin(k), oct(k), hex(k)) == ('0', '0b0', '0o0', '0x0')

    k = Int[128](-1)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-1', '-0b1', '-0o1', '-0x1')

    k = Int[128](12345)
    assert (str(k), bin(k), oct(k), hex(k)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    k = Int[128](-12345)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    # this one is different than Python due to 64-bit ints
    k = Int[128](0x8000000000000000)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-9223372036854775808', '-0b1000000000000000000000000000000000000000000000000000000000000000', '-0o1000000000000000000000', '-0x8000000000000000')

    k = Int[128](0x7fffffffffffffff)
    assert (str(k), bin(k), oct(k), hex(k)) == ('9223372036854775807', '0b111111111111111111111111111111111111111111111111111111111111111', '0o777777777777777777777', '0x7fffffffffffffff')

</t>
<t tx="ekr.20230509052845.3627">class A:
    def __len__(self):
        return 42
    def __getitem__(self, idx):
        return idx

</t>
<t tx="ekr.20230509052845.3628">@test
def test_reversed():
    assert list(reversed([1,2,3])) == [3,2,1]
    assert list(reversed('abc')) == ['c','b','a']
    assert list(reversed('')) == []
    assert list(reversed(A())) == list(reversed(range(42)))

</t>
<t tx="ekr.20230509052845.3629">@test
def test_divmod():
    import sys, math
    assert divmod(12, 7) == (1, 5)
    assert divmod(-12, 7) == (-2, 2)
    assert divmod(12, -7) == (-2, -2)
    assert divmod(-12, -7) == (1, -5)

    assert divmod(i32(12), i32(7)) == (i32(1), i32(5))
    assert divmod(i32(-12), i32(7)) == (i32(-2), i32(2))
    assert divmod(i32(12), i32(-7)) == (i32(-2), i32(-2))
    assert divmod(i32(-12), i32(-7)) == (i32(1), i32(-5))

    assert divmod(u32(12), u32(7)) == (u32(1), u32(5))

    i128 = Int[128]
    assert divmod(i128(12), i128(7)) == (i128(1), i128(5))
    assert divmod(i128(-12), i128(7)) == (i128(-2), i128(2))
    assert divmod(i128(12), i128(-7)) == (i128(-2), i128(-2))
    assert divmod(i128(-12), i128(-7)) == (i128(1), i128(-5))

    @others
    assert divmod(X(12), X(7)) == (X(1), X(5))

    # following is invalid in our case due to 64-bit ints
    # print divmod(-sys.maxsize-1, -1), (sys.maxsize+1, 0)

    for num, denom, exp_result in [ (3.25, 1.0, (3.0, 0.25)),
                                    (-3.25, 1.0, (-4.0, 0.75)),
                                    (3.25, -1.0, (-4.0, -0.75)),
                                    (-3.25, -1.0, (3.0, -0.25))]:
        result = divmod(num, denom)
        assert math.isclose(result[0], exp_result[0])
        assert math.isclose(result[1], exp_result[1])

</t>
<t tx="ekr.20230509052845.363">/// DSL type.
class CustomType : public AcceptorExtend&lt;CustomType, ir::types::Type&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the type builder
  virtual std::unique_ptr&lt;codegen::TypeBuilder&gt; getBuilder() const = 0;

  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Type *v) const = 0;

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509052845.3630">class X:
    n: int
    def __floordiv__(self, other: X):
        return X(self.n // other.n)
    def __mod__(self, other: X):
        return X(self.n % other.n)
    def __eq__(self, other: X):
        return self.n == other.n
    def __nq__(self, other: X):
        return self.n != other.n
</t>
<t tx="ekr.20230509052845.3631">@test
def test_pow():
    assert pow(3, 4) == 81
    assert pow(-3, 3) == -27
    assert pow(1, 0) == 1
    assert pow(-1, 0) == 1
    assert pow(0, 0) == 1
    assert pow(12, 12, 42) == 36
    assert pow(1234, 4321, 99) == 46
    assert pow(9999, 9999, 2) == 1
    assert pow(0, 0, 1) == 0

    try:
        pow(1, -1, 2)
        assert False
    except ValueError as e:
        assert 'negative' in str(e)

    try:
        pow(1, 1, 0)
        assert False
    except ValueError as e:
        assert 'cannot be 0' in str(e)

    assert pow(1.5, 2) == 2.25
    assert pow(9, 0.5) == 3.0
    assert pow(2.0, -1.0) == 0.5

</t>
<t tx="ekr.20230509052845.3632">@test
def test_num_from_str():
    assert int('0') == 0
    assert int('010') == 10
    assert int('3\n') == 3
    assert int('\r\t\n 42\r\t\n ') == 42
    assert int('0101', 2) == 5
    assert int('-0101', 2) == -5
    assert int('0111', 8) == 73
    assert int('-0111', 8) == -73
    assert int('-0xabc', 16) == -2748
    assert int('0xabc', 16) == 2748
    assert int('-0xabc', 16) == -2748
    assert int('111', 0) == 111
    assert int('-111', 0) == -111
    assert int('-0xabc', 0) == -2748
    assert int('0xabc', 0) == 2748
    assert int('-0xabc', 0) == -2748

    try:
        int('  10  a')
        assert False
    except ValueError as e:
        assert str(e) == "invalid literal for int() with base 10: '  10  a'"

    try:
        int('')
        assert False
    except ValueError as e:
        assert str(e) == "invalid literal for int() with base 10: ''"

    assert float('0') == 0
    assert float('3.14') == 3.14
    assert float('3\n') == 3
    assert float('\r\t\n -4.2\r\t\n ') == -4.2

    try:
        float('  3.14  a')
        assert False
    except ValueError as e:
        assert str(e) == "could not convert string to float: '  3.14  a'"

    try:
        float('')
        assert False
    except ValueError as e:
        assert str(e) == "could not convert string to float: ''"

</t>
<t tx="ekr.20230509052845.3633">@test
def test_files(open_fn):
    path = 'build/testfile.txt'
    f = open_fn(path, 'w')
    f.write('hello\nworld\n')
    f.close()

    with open_fn(path) as f:
        assert [line for line in f] == ['hello\n', 'world\n']

    with open_fn(path) as f:
        assert f.read(3) == 'hel'
        assert f.read() == 'lo\nworld\n'
        f.seek(0, 0)
        assert f.tell() == 0
        assert f.read() == 'hello\nworld\n'

    try:
        f.tell()
        assert False
    except IOError:
        pass

    try:
        f.seek(0, 0)
        assert False
    except IOError:
        pass

    try:
        f.flush()
        assert False
    except IOError:
        pass

    f = open_fn(path, 'a')
    f.write('goodbye')
    f.flush()
    f.close()

    with open_fn(path) as f:
        assert [line for line in f] == ['hello\n', 'world\n', 'goodbye']

    with open_fn(path) as f:
        assert f.read(3) == 'hel'
        assert f.read() == 'lo\nworld\ngoodbye'

</t>
<t tx="ekr.20230509052845.3634">test_min_max()
test_map_filter()
test_gen_builtins()
test_int_format()
test_reversed()
test_divmod()
test_pow()
test_num_from_str()
test_files(open)
import gzip
test_files(gzip.open)


# Codon-specific

</t>
<t tx="ekr.20230509052845.3635">@pure
@llvm
def zext(x: int, T: type) -&gt; T:
    %0 = zext i64 %x to {=T}
    ret {=T} %0

</t>
<t tx="ekr.20230509052845.3636">@test
def test_narrow_int_str(T: type):
    z = T(0)
    o = T(1)
    a = T(42)
    b = T(-9)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(-o) == '-1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '42'
    assert str(b) == '-9'
    assert repr(a) == f'Int[{T.N}](42)'

</t>
<t tx="ekr.20230509052845.3637">@test
def test_narrow_uint_str(T: type):
    z = T(0)
    o = T(1)
    a = T(42)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '42'

    if T.N == 32:
        assert str(T(0xffffffff)) == '4294967295'

    if T.N == 64:
        assert str(T(0xffffffffffffffff)) == '18446744073709551615'

    assert repr(a) == f'UInt[{T.N}](42)'

</t>
<t tx="ekr.20230509052845.3638">@test
def test_wide_int_str(T: type):
    z = T(0)
    o = T(1)
    a = T(0xf23ff2341234)
    b = T(-77777)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(-o) == '-1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '266356460360244'
    assert str(b) == '-77777'
    assert str(a * a) == '70945763975638233282255739536'
    assert str(b * b) == '6049261729'
    assert str(a * b) == '-20716406417438697588'

    n = zext(0x7fffffffffffffff, T)
    m = zext(0xffffffffffffffff, T)
    s = T(64)
    assert str((n &lt;&lt; s) | m) == '170141183460469231731687303715884105727'
    if T.N == 128:
        assert str(T(1) &lt;&lt; T(127)) == '-170141183460469231731687303715884105728'
    if T.N &gt; 500:
        assert str(a * a * a * a * a * a * a * a) == '25334123245849102734940743817373556303530349383588924760280652082676453679304226528003335153202090430651964934127616'
        assert str(a * a * a * a * a * a * a * a * b) == '-1970412103692405663415486231883863088619679984007395801080348277034326537815244826668515398210598987424817876681643589632'

    assert repr(a) == f'Int[{T.N}](266356460360244)'
    assert repr(a * b) == f'Int[{T.N}](-20716406417438697588)'

</t>
<t tx="ekr.20230509052845.3639">@test
def test_wide_uint_str(T: type):
    z = T(0)
    o = T(1)
    a = T(0xf23ff2341234)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '266356460360244'
    assert str(a * a) == '70945763975638233282255739536'

    n = zext(0xffffffffffffffff, T)
    s = T(64)
    assert str((n &lt;&lt; s) | n) == '340282366920938463463374607431768211455'
    assert str((n &lt;&lt; s) | (n - T(1))) == '340282366920938463463374607431768211454'
    if T.N &gt; 500:
        assert str(a * a * a * a * a * a * a * a) == '25334123245849102734940743817373556303530349383588924760280652082676453679304226528003335153202090430651964934127616'

    assert repr(a) == f'UInt[{T.N}](266356460360244)'
    assert repr(a * a) == f'UInt[{T.N}](70945763975638233282255739536)'

</t>
<t tx="ekr.20230509052845.364">} // namespace types

</t>
<t tx="ekr.20230509052845.3640">@path C:/Repos/codon/test/core/
from copy import copy, deepcopy

@others
test_defaultdict()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3641">@tuple
class A:
    a: int
    b: float

    @others
</t>
<t tx="ekr.20230509052845.3642">def __getitem__(self: A, n: int):
    return 1

</t>
<t tx="ekr.20230509052845.3643">def __getitem__(self: A, x: Slice):
    if x.start is None and x.stop is None:
        return -1
    if x.start is None:
        return 2
    elif x.stop is None:
        return 3
    else:
        return self.a

</t>
<t tx="ekr.20230509052845.3644">@test
def test_tuple():
    @others
    assert list(test_cmp((1,2), (1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp((1,2,2), (1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp((1,2,-1), (1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp((), ())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    t = (1,2,3)
    assert (t[0], t[1], t[2]) == (1, 2, 3)
    assert (t[-1], t[-2], t[-3]) == (3, 2, 1)
    assert t[1:3] == (2, 3)
    assert t[-3:1] == (1,)
    assert t[-10:2] == (1, 2)
    assert t[0:] == (1, 2, 3)
    assert t[-2:] == (2, 3)
    assert t[3:] == ()
    assert t[:-1] == (1, 2)
    assert t[:1] == (1,)
    assert t[:] == (1, 2, 3)
    assert t[::] == (1, 2, 3)
    assert t[1::1] == (2, 3)
    assert t[:2:1] == (1, 2)
    assert t[::2] == (1, 3)
    assert t[::-1] == (3, 2, 1)
    assert t[0:3:-1] == ()
    assert t[3:0:-1] == (3, 2)

    a = A(42, 3.14)
    assert a[0] == 1
    assert a[:1] == 2
    assert a[0:] == 3
    assert a[0:1] == 42
    assert a[:] == -1
</t>
<t tx="ekr.20230509052845.3645">def test_in():
    for i in range(10):
        yield i, i in (4, 9, 10, -1, 3, 1), i in (7,)
</t>
<t tx="ekr.20230509052845.3646">assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]

</t>
<t tx="ekr.20230509052845.3647">def test_cmp[T](a: T, b: T):
    yield 'EQ', a == b
    yield 'NE', a != b
    yield 'LT', a &lt; b
    yield 'GT', a &gt; b
    yield 'LE', a &lt;= b
    yield 'GE', a &gt;= b

</t>
<t tx="ekr.20230509052845.3648">test_tuple()

</t>
<t tx="ekr.20230509052845.3649">@test
def test_dyn_tuple():
    @others
    assert list(test_cmp(D(1,2), D(1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp(D(1,2,2), D(1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp(D(1,2,-1), D(1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(DynamicTuple[int](), DynamicTuple[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    assert list(test_cmp((1,2), D(1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp((1,2,2), D(1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp((1,2,-1), D(1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp((), DynamicTuple[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    assert list(test_cmp(D(1,2), (1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp(D(1,2,2), (1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp(D(1,2,-1), (1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(DynamicTuple[int](), ())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    t = D(1,2,3)
    assert D(t[0], t[1], t[2]) == D(1, 2, 3)
    assert D(t[-1], t[-2], t[-3]) == D(3, 2, 1)
    assert t[1:3] == D(2, 3)
    assert t[-3:1] == D(1,)
    assert t[-10:2] == D(1, 2)
    assert t[0:] == D(1, 2, 3)
    assert t[-2:] == D(2, 3)
    assert t[3:] == DynamicTuple[int]()
    assert t[:-1] == D(1, 2)
    assert t[:1] == D(1)
    assert t[:] == D(1, 2, 3)
    assert t[::] == D(1, 2, 3)
    assert t[1::1] == D(2, 3)
    assert t[:2:1] == D(1, 2)
    assert t[::2] == D(1, 3)
    assert t[::-1] == D(3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == D(3, 2)

    assert D(t[0], t[1], t[2]) == (1, 2, 3)
    assert D(t[-1], t[-2], t[-3]) == (3, 2, 1)
    assert t[1:3] == (2, 3)
    assert t[-3:1] == (1,)
    assert t[-10:2] == (1, 2)
    assert t[0:] == (1, 2, 3)
    assert t[-2:] == (2, 3)
    assert t[3:] == ()
    assert t[:-1] == (1, 2)
    assert t[:1] == (1,)
    assert t[:] == (1, 2, 3)
    assert t[::] == (1, 2, 3)
    assert t[1::1] == (2, 3)
    assert t[:2:1] == (1, 2)
    assert t[::2] == (1, 3)
    assert t[::-1] == (3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == (3, 2)

    t = (1,2,3)
    assert (t[0], t[1], t[2]) == D(1, 2, 3)
    assert (t[-1], t[-2], t[-3]) == D(3, 2, 1)
    assert t[1:3] == D(2, 3)
    assert t[-3:1] == D(1,)
    assert t[-10:2] == D(1, 2)
    assert t[0:] == D(1, 2, 3)
    assert t[-2:] == D(2, 3)
    assert t[3:] == DynamicTuple[int]()
    assert t[:-1] == D(1, 2)
    assert t[:1] == D(1)
    assert t[:] == D(1, 2, 3)
    assert t[::] == D(1, 2, 3)
    assert t[1::1] == D(2, 3)
    assert t[:2:1] == D(1, 2)
    assert t[::2] == D(1, 3)
    assert t[::-1] == D(3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == D(3, 2)

    assert hash(D(1,2,3,4,5)) == hash((1,2,3,4,5))

    assert (1, 2) + (3,) == (1, 2, 3)
    assert (1,) + (2, 3) == (1, 2, 3)
    assert (1, 2) + () == (1, 2)
    assert () + () == ()
    assert () + (1, 2) == (1, 2)
    assert (1,) + (2,) == (1, 2)
    assert (1, 2) * 3 == (1, 2, 1, 2, 1, 2)
    assert () * 99 == ()
    assert (1, 2, 3, 4) * 1 == (1, 2, 3, 4)
    assert (1, 2) * 0 == ()
    assert (1, 2) * (-1) == ()
    assert () * -1 == ()
</t>
<t tx="ekr.20230509052845.365">/// DSL constant.
class CustomConst : public AcceptorExtend&lt;CustomConst, Const&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509052845.3650">def D(*args):
    return DynamicTuple(args)

</t>
<t tx="ekr.20230509052845.3651">def test_in():
    for i in range(10):
        yield i, i in D(4, 9, 10, -1, 3, 1), i in D(7)
</t>
<t tx="ekr.20230509052845.3652">assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]

</t>
<t tx="ekr.20230509052845.3653">def test_cmp(a, b):
    yield 'EQ', a == b
    yield 'NE', a != b
    yield 'LT', a &lt; b
    yield 'GT', a &gt; b
    yield 'LE', a &lt;= b
    yield 'GE', a &gt;= b

</t>
<t tx="ekr.20230509052845.3654">test_dyn_tuple()

</t>
<t tx="ekr.20230509052845.3655">@test
def test_list():
    l1 = [i+1 for i in range(100)]
    assert len(l1) == 100
    l1 = l1[98:]
    l2 = [1, 2] * 2

    assert [a for a in l1] == [99, 100]
    assert [a for a in l2] == [1, 2, 1, 2]
    assert 2 * [1, 2] == l2

    l1 = [i*2 for i in range(3)]
    l1.insert(0, 99)
    l1[0] += 1
    del l1[1]
    assert [a for a in l1[0:3]] == [100, 2, 4]

    l3 = [1, 2, 3]
    assert l3.remove(2) == True
    assert l3.remove(2) == False
    assert l3 == [1, 3]
    assert list[int]().remove(0) == False

    # l4 = [5, 1, 4, 2, 1, -10, 10, 100, -100]
    # assert sorted(l4) == [-100, -10, 1, 1, 2, 4, 5, 10, 100]
    #l4.sort()
    #assert l4 == [-100, -10, 1, 1, 2, 4, 5, 10, 100]
    #assert str(sorted(list[int]())) == "[]"

    l5 = [11, 22, 33, 44]
    del l5[-1]
    assert l5 == [11, 22, 33]
    l5.insert(-1, 55)
    l5.insert(1000, 66)
    l5.insert(-100, 77)
    assert l5 == [77, 11, 22, 55, 33, 66]
    l5 = [11, 22, 55, 33]
    assert l5 + [1,2,3] == [11, 22, 55, 33, 1, 2, 3]
    l5 += [1,2,3]
    assert l5 == [11, 22, 55, 33, 1, 2, 3]
    assert l5.pop() == 3
    assert l5 * 2 == [11, 22, 55, 33, 1, 2, 11, 22, 55, 33, 1, 2]
    l5 *= 2
    assert l5 == [11, 22, 55, 33, 1, 2, 11, 22, 55, 33, 1, 2]
    assert l5.index(33) == 3
    l5 *= 0
    assert len(l5) == 0

    l6 = []
    l6.extend('abc')
    l6.extend(['xyz'])
    l6.extend('')
    assert l6 == ['a', 'b', 'c', 'xyz']

    assert List[int]().copy() == List[int]()
    assert [1,2,3].copy() == [1,2,3]

    @others
    assert list(test_cmp([1,2], [1,2])) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp([1,2,2], [1,2,3])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [1,0,1])) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(List[int](), List[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp([1], List[int]())) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(List[int](), [1])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [2])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [1,2,-1,3])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1,3], [1,2,-1])) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]

    assert str([1] + [2] + [] + [3]) == '[1, 2, 3]'
    assert ['a', 'b'] + ['x', 'y', 'z'] == ['a', 'b'] + ['x', 'y', 'z']
    assert [(1,1), (2,2)] + [] == [(1,1), (2,2)]
    assert [] + [(1,1), (2,2)] == [(1,1), (2,2)]
    assert List[int]() + List[int]() == List[int]()
    l7 = [3.14, 2.5]
    l7 += [9.99, -1.0]
    assert l7 == [3.14, 2.5, 9.99, -1.0]
    l8 = []
    l8 += [11, 22, 33]
    assert l8 == [11, 22, 33]
    l8 = [11, 22, 33]
    l8 += []
    assert l8 == [11, 22, 33]
    l8 = List[int]()
    l8 += List[int]()
    assert l8 == List[int]()

    assert list(reversed(list('abc'))) == ['c', 'b', 'a']
    assert list(list('abc')[::-1]) == ['c', 'b', 'a']
    assert list(reversed(List[str]())) == List[str]()
</t>
<t tx="ekr.20230509052845.3656">def test_cmp[T](a: T, b: T):
    yield 'EQ', a == b
    yield 'NE', a != b
    yield 'LT', a &lt; b
    yield 'GT', a &gt; b
    yield 'LE', a &lt;= b
    yield 'GE', a &gt;= b

</t>
<t tx="ekr.20230509052845.3657">test_list()

</t>
<t tx="ekr.20230509052845.3658">@test
def test_setslice():
    l = [0, 1]
    a = l

    for i in range(-3, 4):
        a[:i] = l[:i]
        assert a == l
        a2 = a[:]
        a2[:i] = a[:i]
        assert a2 == a
        a[i:] = l[i:]
        assert a == l
        a2 = a[:]
        a2[i:] = a[i:]
        assert a2 == a
        for j in range(-3, 4):
            a[i:j] = l[i:j]
            assert a == l
            a2 = a[:]
            a2[i:j] = a[i:j]
            assert a2 == a

    a2 = a[:]
    aa2 = a2[:]
    aa2[:0] = [-2, -1]
    assert aa2 == [-2, -1, 0, 1]
    aa2[0:] = list[int]()
    assert aa2 == list[int]()

    a = [1, 2, 3, 4, 5]
    a[:-1] = a
    assert a == [1, 2, 3, 4, 5, 5]
    a = [1, 2, 3, 4, 5]
    a[1:] = a
    assert a == [1, 1, 2, 3, 4, 5]
    a = [1, 2, 3, 4, 5]
    a[1:-1] = a
    assert a == [1, 1, 2, 3, 4, 5, 5]

    a = list[int]()
    a[:] = list(range(10))
    assert a == list(range(10))

    a = list(range(20))
    try:
        a[0:10:0] = [1,2,3]
        assert False
    except ValueError:
        pass

    try:
        a[0:10:2] = [1,2]
        assert False
    except ValueError:
        pass

    a[2:10:3] = [1,2,3]
    assert a == [0, 1, 1, 3, 4, 2, 6, 7, 3, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
</t>
<t tx="ekr.20230509052845.3659">test_setslice()

</t>
<t tx="ekr.20230509052845.366">/// DSL flow.
class CustomFlow : public AcceptorExtend&lt;CustomFlow, Flow&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;
  /// @return the control-flow builder
  virtual std::unique_ptr&lt;codegen::CFBuilder&gt; getCFBuilder() const = 0;
  /// Query this custom node for its side effect properties. If "local"
  /// is true, then the return value should reflect this node and this
  /// node alone, otherwise the value should reflect functions containing
  /// this node in their bodies. For example, a "break" instruction has
  /// side effects locally, but functions containing "break" might still
  /// be side effect free, hence the distinction.
  /// @param local true if result should reflect only this node
  /// @return this node's side effect status
  virtual util::SideEffectStatus getSideEffectStatus(bool local = true) const {
    return util::SideEffectStatus::UNKNOWN;
  }

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509052845.3660">@test
def test_delslice():
    a = [0, 1]
    del a[1:2]
    del a[0:1]
    assert a == list[int]()

    a = [0, 1]
    del a[1:2]
    del a[0:1]
    assert a == list[int]()

    a = [0, 1]
    del a[-2:-1]
    assert a == [1]

    a = [0, 1]
    del a[-2:-1]
    assert a == [1]

    a = [0, 1]
    del a[1:]
    del a[:1]
    assert a == list[int]()

    a = [0, 1]
    del a[1:]
    del a[:1]
    assert a == list[int]()

    a = [0, 1]
    del a[-1:]
    assert a == [0]

    a = [0, 1]
    del a[-1:]
    assert a == [0]

    a = [0,1]
    del a[:]
    assert a == list[int]()
</t>
<t tx="ekr.20230509052845.3661">test_delslice()

</t>
<t tx="ekr.20230509052845.3662">@test
def test_extendedslicing():
    a = [0,1,2,3,4]
    del a[::2]
    assert a == [1,3]

    a = list(range(5))
    del a[1::2]
    assert a == [0,2,4]

    a = list(range(5))
    del a[1::-2]
    assert a == [0,2,3,4]

    a = list(range(10))
    del a[::1000]
    assert a == [1, 2, 3, 4, 5, 6, 7, 8, 9]

    a = list(range(10))
    a[::2] = [-1]*5
    assert a == [-1, 1, -1, 3, -1, 5, -1, 7, -1, 9]

    a = list(range(10))
    a[::-4] = [10]*3
    assert a == [0, 10, 2, 3, 4, 10, 6, 7, 8 ,10]

    a = list(range(4))
    a[::-1] = a
    assert a == [3, 2, 1, 0]

    a = list(range(10))
    b = a[:]
    c = a[:]
    a[2:3] = [222, 333]
    b[2:3] = [222, 333]
    c[2:3:] = [222, 333]
    assert a == b
    assert a == c

    a = list(range(10))
    a[::2] = (0, 1, 2, 3, 4)
    assert a == [0, 1, 1, 3, 2, 5, 3, 7, 4, 9]

    assert repr(['x', 'y', 'z']) == "['x', 'y', 'z']"
    assert repr(List[int]()) == '[]'
</t>
<t tx="ekr.20230509052845.3663">test_extendedslicing()

</t>
<t tx="ekr.20230509052845.3664">@test
def test_set():
    s1 = {a for a in range(100)}
    assert len(s1) == 100
    s1 = {a%8 for a in range(100)}
    for a in range(8):
        assert a in s1
    for a in range(8,100):
        assert a not in s1

    assert 5 in s1
    s1.remove(5)
    assert 5 not in s1
    assert len(s1) == 7

    s1 = {1,2,3,4}
    s2 = {2,3,4,5}
    s3 = set[int]()

    assert (s1 | s2) == {1, 2, 3, 4, 5}
    assert (s1 &amp; s2) == {4, 2, 3}
    assert (s1 ^ s2) == {1, 5}
    assert (s1 | s3) == {1, 2, 3, 4}
    assert (s1 &amp; s3) == set[int]()
    assert (s1 ^ s3) == {1, 2, 3, 4}
    assert (s1 - s2) == {1}
    assert (s2 - s1) == {5}
    assert (s3 - s1 - s2) == set[int]()
    assert (s1 &gt; s2) == False
    assert (s1 &lt; s2) == False
    assert (s3 &lt;= s1) == True
    assert (s2 &gt;= s1) == False
    assert ((s1 | s2) &gt; s1) == True

    s1c = copy(s1)
    s2c = copy(s2)
    s3c = copy(s3)

    assert s1c == {1, 2, 3, 4}
    s1c &amp;= s2c
    assert s1c == {2, 3, 4}
    s1c -= s3c
    assert s1c == {2, 3, 4}
    s1c ^= s1c
    assert s1c == set[int]()
    s1c |= s2c
    assert s1c == {2, 3, 4, 5}
    assert s1 == {1, 2, 3, 4}

    s1 = {1, 2, 3, 999999}
    s2 = {1, 2, 3, 999999}
    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    try:
        s1.pop()
        assert False
    except ValueError:
        pass

    assert repr({(1,2)}) == '{(1, 2)}'
    assert repr(Set[int]()) == 'set()'
</t>
<t tx="ekr.20230509052845.3665">test_set()

</t>
<t tx="ekr.20230509052845.3666">@test
def test_dict():
    d1 = copy({a: a*a for a in range(100)})
    assert len(d1) == 100
    d1 = {a: a*a for a in range(5)}
    assert len(copy(dict[int,int]())) == 0

    assert [d1.get(a, -1) for a in range(6)] == [0, 1, 4, 9, 16, -1]

    assert 2 in d1
    del d1[2]
    assert 2 not in d1
    d1[2] = 44
    assert 2 in d1
    assert d1.get(2, -1) == 44
    assert d1[3] == 9

    del d1[3]
    del d1[4]

    assert [k for k in d1] == [0, 1, 2]
    assert [t for t in d1.items()] == [(0, 0), (1, 1), (2, 44)]

    d2 = {'x': 10, 'y': 0}
    d2.increment('x')
    d2.increment('y', by=-1)
    d2.increment('z', by=2)
    assert d2['x'] == 11
    assert d2['y'] == -1
    assert d2['z'] == 2
    assert d2 == {'x': 11, 'y': -1, 'z': 2}

    d3 = {1: 2, 42: 42}
    d4 = {1: 5, 2: 9}
    assert d3 | d4 == {1: 5, 42: 42, 2: 9}
    d3 |= d4
    assert d3 == {1: 5, 42: 42, 2: 9}

    assert repr({1: ['x']}) == "{1: ['x']}"
    assert repr(Dict[int,int]()) == '{}'
</t>
<t tx="ekr.20230509052845.3667">test_dict()

</t>
<t tx="ekr.20230509052845.3668">@test
def test_deque():
    from collections import deque

    dq = deque[int]()
    dq.append(1)
    dq.append(2)
    dq.append(3)
    dq.appendleft(11)
    dq.appendleft(22)
    assert str(dq) == 'deque([22, 11, 1, 2, 3])'
    assert bool(dq) == True

    # test cap increase:
    dq.clear()
    assert bool(dq) == False
    for i in range(20):
        dq.append(i)
        dq.appendleft(i)
    assert str(dq) == 'deque([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])'
    assert len(dq) == 40

    for i in range(19):
        dq.pop()
        dq.popleft()
    assert str(dq) == 'deque([0, 0])'
    for a in dq:
        assert a == 0

    assert (0 in dq) == True
    assert (1 in dq) == False
    assert str(copy(dq)) == 'deque([0, 0])'

    # test maxlen:
    dq = deque[int](5)
    for i in range(100):
        dq.append(i)
    assert str(dq) == 'deque([95, 96, 97, 98, 99])'

    for i in range(5):
        dq.append(i)
    assert str(dq) == 'deque([0, 1, 2, 3, 4])'
</t>
<t tx="ekr.20230509052845.3669">test_deque()

</t>
<t tx="ekr.20230509052845.367">/// DSL instruction.
class CustomInstr : public AcceptorExtend&lt;CustomInstr, Instr&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;
  /// @return the control-flow builder
  virtual std::unique_ptr&lt;codegen::CFBuilder&gt; getCFBuilder() const = 0;
  /// Query this custom node for its side effect properties. If "local"
  /// is true, then the return value should reflect this node and this
  /// node alone, otherwise the value should reflect functions containing
  /// this node in their bodies. For example, a "break" instruction has
  /// side effects locally, but functions containing "break" might still
  /// be side effect free, hence the distinction.
  /// @param local true if result should reflect only this node
  /// @return this node's side effect status
  virtual util::SideEffectStatus getSideEffectStatus(bool local = true) const {
    return util::SideEffectStatus::UNKNOWN;
  }

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509052845.3670">@test
def test_counter():
    from collections import Counter

    # main
    c = Counter('abcaba')
    assert c == Counter({'a':3 , 'b': 2, 'c': 1})
    assert len(c) == 3
    assert sum(c.values()) == 6
    assert set(c.values()) == {1, 2, 3}
    assert set(c.keys()) == {'a','b','c'}
    assert set(c.items()) == {('a',3), ('b',2), ('c',1)}
    assert c['b'] == 2
    assert c['z'] == 0
    assert c.__contains__('b')
    assert not c.__contains__('z')
    assert c.get('b', 10) == 2
    assert c.get('z', 10) == 10
    assert c == {'a':3 , 'b': 2, 'c': 1}
    assert c.most_common() == [('a', 3), ('b', 2), ('c', 1)]
    for i in range(5):
        assert c.most_common(i) == [('a', 3), ('b', 2), ('c', 1)][:i]

    c['a'] += 1         # increment an existing value
    c['b'] -= 2         # sub existing value to zero
    del c['c']          # remove an entry
    del c['c']          # make sure that del doesn't raise KeyError
    c['d'] -= 2         # sub from a missing value
    c['e'] = -5         # directly assign a missing value
    c['f'] += 4         # add to a missing value

    assert dict(c) == {'a':4, 'b':0, 'd':-2, 'e':-5, 'f':4}
    assert c.pop('f') == 4
    assert 'f' not in c
    for i in range(3):
        elem, cnt = c.popitem()
        assert elem not in c
    c.clear()
    assert c == {}
    c.update({'a':5, 'b':3})
    c.update({'c': 1})
    c.update(Counter('a' * 50 + 'b' * 30))
    c.update()
    c.update('a' * 500 + 'b' * 300)
    c.update('cdc')
    assert c == {'a':555, 'b':333, 'c':3, 'd':1}

    assert c.setdefault('d',5) == 1
    assert c['d'] == 1
    assert c.setdefault('e', 5) == 5
    assert c['e'] == 5


    # total
    c = Counter({'a':10, 'b':5, 'c':0})
    assert c.total() == 15


    # conversions
    s = 'she sells sea shells by the sea shore'
    assert sorted(Counter(s).elements()) == sorted(s)
    assert sorted(Counter(s)) == sorted(set(s))
    assert dict(Counter(s)) == dict(Counter(s).items())
    assert set(Counter(s)) == set(s)


    # in invariant
    c = Counter({'a':10, 'b':-2, 'c':0})
    for elem in c:
        assert elem in c


    # multiset
    c = Counter({'a':10, 'b':-2, 'c':0}) + Counter()
    assert dict(c) == {'a':10}

    from random import randrange, randint
    elements = 'abcd'
    for i in range(1000):
        # test random pairs of multisets
        p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        p.update({'e':1, 'f':-1, 'g':0})
        q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        q.update({'h':1, 'i':-1, 'j':0})

        result = p + q
        for x in elements:
            assert max(0, p[x] + q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p - q
        for x in elements:
            assert max(0, p[x] - q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p | q
        for x in elements:
            assert max(0, p[x], q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p &amp; q
        for x in elements:
            assert max(0, min(p[x], q[x])) == result[x]
        assert all(x&gt;0 for x in result.values())

    elements = 'abcdef'
    for i in range(100):
        # verify that random multisets with no repeats are exactly like sets
        p = Counter(dict((elem, randrange(0, 2)) for elem in elements))
        q = Counter(dict((elem, randrange(0, 2)) for elem in elements))

        counter_result = p - q
        set_result = set(p.elements()) - set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)

        counter_result = p | q
        set_result = set(p.elements()) | set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)

        counter_result = p &amp; q
        set_result = set(p.elements()) &amp; set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)


    # in-place
    elements = 'abcd'
    for i in range(1000):
        # test random pairs of multisets
        p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        p.update({'e':1, 'f':-1, 'g':0})
        q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        q.update({'h':1, 'i':-1, 'j':0})

        c = p.copy()
        c_id = id(c)
        regular_result = c + q
        inplace_result = c.__iadd__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c - q
        inplace_result = c.__isub__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c | q
        inplace_result = c.__ior__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c &amp; q
        inplace_result = c.__iand__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id


    # subtract
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15,'g':40})
    c.subtract({'a':1, 'b':2, 'c':-3, 'd':10, 'e':20, 'f':30, 'h':-50})
    assert c == Counter({'a':-6, 'b':-2, 'c':8, 'd':0, 'e':-5, 'f':-30, 'g':40, 'h':50})
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15,'g':40})
    c.subtract(Counter({'a':1, 'b':2, 'c':-3, 'd':10, 'e':20, 'f':30, 'h':-50}))
    assert c == Counter({'a':-6, 'b':-2, 'c':8, 'd':0, 'e':-5, 'f':-30, 'g':40, 'h':50})

    c = Counter('aaabbcd')
    c.subtract('aaaabbcce')
    assert c == Counter({'a':-1, 'b':0, 'c':-1, 'd':1, 'e':-1})

    c = Counter()
    c.subtract({'self':42})
    assert list(c.items()) == [('self', -42)]
    c = Counter()
    c.subtract({'iterable':42})
    assert list(c.items()) == [('iterable', -42)]


    # unary
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15, 'g':40})
    assert dict(+c) == {'c':5, 'd':10, 'e':15, 'g':40}
    assert dict(-c) == {'a':5}


    # equality
    assert Counter({'a':3, 'b':2}) == Counter('ababa')
    assert Counter({'a':3, 'b':2}) != Counter('babab')


    # most common
    c = Counter({v:k for k,v in enumerate('hgfedcba')})
    q = [(v,k) for k,v in enumerate('hgfedcba')][::-1]
    assert c.most_common() == q
    for i in range(10):
        assert c.most_common(i) == q[:i]

    for limit in range(100):
        for samples in range(100):
            for most_common in range(100):
                data = [randint(0, limit) for _ in range(samples)]
                d = Counter(data)
                exp = sorted(d.values(), reverse=True)[:most_common]
                got = [v for k,v in d.most_common(most_common)]
                assert exp == got

    for limit in range(100):
        for samples in range(100):
            data = [randint(0, limit) for _ in range(samples)]
            d = Counter(data)
            exp = sorted(d.values(), reverse=True)
            got = [v for k,v in d.most_common()]
            assert exp == got

    assert repr(Counter('abcabc')) == "Counter({'a': 2, 'b': 2, 'c': 2})"
</t>
<t tx="ekr.20230509052845.3671">test_counter()

</t>
<t tx="ekr.20230509052845.3672">@test
def test_defaultdict():
    from collections import defaultdict

    # basic
    #d1 = defaultdict()
    #self.assertEqual(d1.default_factory, None)
    #d1.default_factory = list
    d1 = defaultdict(list)
    d1[12].append(42)
    assert d1 == {12: [42]}
    d1[12].append(24)
    assert d1 == {12: [42, 24]}
    d1[13]
    d1[14]
    assert d1 == {12: [42, 24], 13: [], 14: []}
    assert d1[12] is not d1[13] is not d1[14]
    #d2 = defaultdict(list, foo=1, bar=2)
    #self.assertEqual(d2.default_factory, list)
    #self.assertEqual(d2, {"foo": 1, "bar": 2})
    #self.assertEqual(d2["foo"], 1)
    #self.assertEqual(d2["bar"], 2)
    #self.assertEqual(d2[42], [])
    #self.assertIn("foo", d2)
    #self.assertIn("foo", d2.keys())
    #self.assertIn("bar", d2)
    #self.assertIn("bar", d2.keys())
    #self.assertIn(42, d2)
    #self.assertIn(42, d2.keys())
    #self.assertNotIn(12, d2)
    #self.assertNotIn(12, d2.keys())
    #d2.default_factory = None
    #self.assertEqual(d2.default_factory, None)
    #try:
    #    d2[15]
    #except KeyError as err:
    #    self.assertEqual(err.args, (15,))
    #else:
    #    self.fail("d2[15] didn't raise KeyError")
    #self.assertRaises(TypeError, defaultdict, 1)

    # missing
    #d1 = defaultdict()
    #self.assertRaises(KeyError, d1.__missing__, 42)
    #d1.default_factory = list
    #d1 = defaultdict(list)
    assert d1.__missing__(42) == []

    # repr
    d1 = defaultdict(lambda: 0)
    #self.assertEqual(d1.default_factory, None)
    #self.assertEqual(repr(d1), "defaultdict(None, {})")
    #self.assertEqual(eval(repr(d1)), d1)
    d1[11] = 41
    assert repr(d1) == "defaultdict(&lt;default factory of 'int'&gt;, {11: 41})"
    d2 = defaultdict(lambda: 0)  # TODO: use 'int' when it's fixed...
    #self.assertEqual(d2.default_factory, int)
    d2[12] = 42
    assert repr(d2) == "defaultdict(&lt;default factory of 'int'&gt;, {12: 42})"
    @others
    d = defaultdict(constant_factory('&lt;missing&gt;'))
    assert d[10] == '&lt;missing&gt;'
</t>
<t tx="ekr.20230509052845.3673">def foo(): return 43
</t>
<t tx="ekr.20230509052845.3674">d3 = defaultdict(foo)
#self.assertTrue(d3.default_factory is foo)
d3[13]
assert repr(d3) == "defaultdict(&lt;default factory of 'int'&gt;, {13: 43})"


# copy
d1 = defaultdict(list)
d2 = d1.copy()
#self.assertEqual(type(d2), defaultdict)
#self.assertEqual(d2.default_factory, None)
assert d2 == {}
#d1.default_factory = list
#d3 = d1.copy()
#self.assertEqual(type(d3), defaultdict)
#self.assertEqual(d3.default_factory, list)
#self.assertEqual(d3, {})
d1[42].append(0)
#d4 = d1.copy()
#assert d4 == {42: [0]}
#d4[12]
#assert d4 == {42: [], 12: []}

# Issue 6637: Copy fails for empty default dict
#d = defaultdict()
#d['a'] = 42
#e = d.copy()
#assert e['a'] == 42


# shallow copy
foobar = list
d1 = defaultdict(foobar)
d1[1] += [1]
d2 = copy(d1)
#self.assertEqual(d2.default_factory, foobar)
assert d2 == d1
#d1.default_factory = list
d2 = copy(d1)
#self.assertEqual(d2.default_factory, list)
assert d2 == d1

# deep copy
d1 = defaultdict(foobar)
d1[1].append(1)
d2 = deepcopy(d1)
#self.assertEqual(d2.default_factory, foobar)
assert d2 == d1
assert d1[1] is not d2[1]
#d1.default_factory = list
d2 = deepcopy(d1)
#self.assertEqual(d2.default_factory, list)
assert d2 == d1

# KeyError without factory
#d1 = defaultdict()
#try:
#    d1[(1,)]
#except KeyError as err:
#    self.assertEqual(err.args[0], (1,))
#else:
#    self.fail("expected KeyError")

# pickling
#d = defaultdict(int)
#d[1]
#for proto in range(pickle.HIGHEST_PROTOCOL + 1):
#    s = pickle.dumps(d, proto)
#    o = pickle.loads(s)
#    self.assertEqual(d, o)

# union
i = defaultdict(int, {1: 1, 2: 2})
s = defaultdict(int, {0: 0, 1: 111})

i_s = i | s
#self.assertIs(i_s.default_factory, int)
assert i_s == {1: 111, 2: 2, 0: 0}
assert sorted(i_s) == [0, 1, 2]

s_i = s | i
#self.assertIs(s_i.default_factory, str)
assert s_i == {0: 0, 1: 1, 2: 2}
assert sorted(s_i) == [0, 1, 2]

i_ds = i | dict(s)
#self.assertIs(i_ds.default_factory, int)
assert i_ds == {1: 111, 2: 2, 0: 0}
assert sorted(i_ds) == [0, 1, 2]

ds_i = dict(s) | i
#self.assertIs(ds_i.default_factory, int)
assert ds_i == {0: 0, 1: 1, 2: 2}
assert sorted(ds_i) == [0, 1, 2]

# We inherit a fine |= from dict, so just a few sanity checks here:
i |= list(s.items())
#self.assertIs(i.default_factory, int)
assert i == {1: 111, 2: 2, 0: 0}
assert sorted(i), [1, 2, 0]

# general
s = 'mississippi'
d = defaultdict(int)
for k in s:
    d[k] += 1
assert sorted(d.items()) == [('i', 4), ('m', 1), ('p', 2), ('s', 4)]

s = 'mississippi'
d = defaultdict(int)
for k in s:
    d[k] = d.get(k, 0) + 1
assert sorted(d.items()) == [('i', 4), ('m', 1), ('p', 2), ('s', 4)]

s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
d = defaultdict(list)
for k, v in s:
    d[k].append(v)
assert sorted(d.items()) == [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

</t>
<t tx="ekr.20230509052845.3675">def constant_factory(value):
    return lambda: value

</t>
<t tx="ekr.20230509052845.3676">@path C:/Repos/codon/test/core/
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3677">@path C:/Repos/codon/test/core/
@others
# EXPECT: B
# EXPECT: C
# EXPECT: A
# EXPECT: C
test_empty_raise()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3678">class Exc1(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('Exc1', msg)

    def show(self):
        print self.message

</t>
<t tx="ekr.20230509052845.3679">class Exc2(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('Exc2', msg)

    def show(self):
        print self.message

</t>
<t tx="ekr.20230509052845.368"></t>
<t tx="ekr.20230509052845.3680">class A(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('A', msg)

</t>
<t tx="ekr.20230509052845.3681">class B(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('B', msg)

</t>
<t tx="ekr.20230509052845.3682">class C(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('C', msg)

</t>
<t tx="ekr.20230509052845.3683">class D(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('D', msg)

</t>
<t tx="ekr.20230509052845.3684">class E(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('E', msg)

</t>
<t tx="ekr.20230509052845.3685">def foo1(x):
    if x:
        raise Exc1('e1')
    else:
        raise Exc2('e2')

</t>
<t tx="ekr.20230509052845.3686">def foo2(x):
    foo1(x)

</t>
<t tx="ekr.20230509052845.3687">def foo(x):
    foo2(x)

</t>
<t tx="ekr.20230509052845.3688">def square(x):
    return x * x

</t>
<t tx="ekr.20230509052845.3689">def bar(x):
    try:
        print 'try'
        foo(x)
        print 'error'
    except Exc1 as e:
        print 'catch Exc1 1'
        print e.message
        print 'catch Exc1 2'
    except Exc2 as e:
        print 'catch Exc2 1'
        print e.message
        print 'catch Exc2 2'
    finally:
        print 'finally'
    print 'done'

</t>
<t tx="ekr.20230509052845.369">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {
namespace ir {

/// Applies GPU-specific transformations and generates PTX
/// code from kernel functions in the given LLVM module.
/// @param module LLVM module containing GPU kernel functions (marked with "kernel"
/// annotation)
/// @param ptxFilename Filename for output PTX code; empty to use filename based on
/// module
void applyGPUTransformations(llvm::Module *module, const std::string &amp;ptxFilename = "");

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3690">def baz(x):
    try:
        print 'try 1'
        square(x)
        print 'try 2'
    except Exc1 as e:
        print 'catch Exc1 1'
        print e.message
        print 'catch Exc1 2'
    except Exc2 as e:
        print 'catch Exc2 1'
        print e.message
        print 'catch Exc2 2'
    finally:
        print 'finally'
    print 'done'

</t>
<t tx="ekr.20230509052845.3691">def baz1(x):
    try:
        print 'try 1.1'
        foo(x)
        print 'try 1.2'
    except Exc1 as e:
        print 'catch Exc1 1.1'
        print e.message
        print 'catch Exc1 1.2'
    finally:
        print 'finally 1'
    print 'done 1'

</t>
<t tx="ekr.20230509052845.3692">def baz2(x):
    try:
        print 'try 2.1'
        baz1(x)
        print 'try 2.2'
    except:
        print 'catch Exc2'
    finally:
        print 'finally 2'
    print 'done 2'

</t>
<t tx="ekr.20230509052845.3693">def nest1(b):
    if b:
        raise C('C')
    else:
        raise E('E')

</t>
<t tx="ekr.20230509052845.3694">def nest2(b):
    try:
        try:
            try:
                try:
                    nest1(b)
                except A:
                    print 'A'
                finally:
                    print 'f A'
            except B:
                print 'B'
            finally:
                print 'f B'
        except C as c:
            print c.message
        finally:
            print 'f C'
    except D:
        print 'D'
    finally:
        print 'f D'

</t>
<t tx="ekr.20230509052845.3695">def nest3(b):
    try:
        nest2(b)
    except:
        print 'except'
    finally:
        print 'done'

</t>
<t tx="ekr.20230509052845.3696">def finally_return(x):
    try:
        try:
            return 'A'
        finally:
            if x &lt; 5:
                return 'B'
    finally:
        if x &gt; 10:
            return 'C'

</t>
<t tx="ekr.20230509052845.3697">def finally_return_void():
    try:
        try:
            print 'A'
            return
        finally:
            print 'B'
            return
    finally:
        print 'C'

</t>
<t tx="ekr.20230509052845.3698">def finally_break_continue1():
    try:
        for i in range(3):
            try:
                continue
            finally:
                print i
                continue
            print 'X'
    finally:
        print 'f'

</t>
<t tx="ekr.20230509052845.3699">def finally_break_continue2():
    try:
        for i in range(5):
            try:
                if i == 4:
                    continue

                for j in range(i):
                    try:
                        try:
                            if j == 3:
                                break
                            elif j == 1:
                                continue
                            print j
                        finally:
                            print 'f1'
                    finally:
                        print 'f2'
                        if j == 4:
                            break
            finally:
                print 'f3'
    finally:
        print 'f4'

</t>
<t tx="ekr.20230509052845.37">def __init__(self, splines, thickness=0.1):
    self.splines = splines
    self.thickness = thickness
    self.minx = min([p.x for spl in splines for p in spl.points])
    self.miny = min([p.y for spl in splines for p in spl.points])
    self.maxx = max([p.x for spl in splines for p in spl.points])
    self.maxy = max([p.y for spl in splines for p in spl.points])
    self.height = self.maxy - self.miny
    self.width = self.maxx - self.minx
    self.num_trafos = []
    maxlength = thickness * self.width / self.height
    for spl in splines:
        length = 0.
        curr = spl(0)
        for i in range(1, 1000):
            last = curr
            t = 1 / 999 * i
            curr = spl(t)
            length += curr.dist(last)
        self.num_trafos.append(max(1, int(length / maxlength * 1.5)))
    self.num_total = sum(self.num_trafos)

</t>
<t tx="ekr.20230509052845.370">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"
#include "codon/cir/llvm/llvm.h"
#include "codon/cir/pyextension.h"
#include "codon/dsl/plugins.h"
#include "codon/util/common.h"

#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3700">def finally_break_continue3(n):
    while n != 0:
        print 'A'
        try:
            while n != 0:
                print 'B'
                if n == 42:
                    print 'C'
                    n -= 1
                    continue
                try:
                    print 'D'
                    if n &gt; 0:
                        print 'E'
                        continue
                    else:
                        print 'F'
                        break
                finally:
                    print('G')
                    return -1
            print 'H'
            return -2
        finally:
            print 'I'
            return n + 1

</t>
<t tx="ekr.20230509052845.3701">def test_try_with_loop1(_):
    try:
        print 'A'
        while True:
            print 'B'
            try:
                print 'C'
                raise ValueError()
                assert False
            except ValueError:
                print 'D'
                break
    finally:
        print 'E'

</t>
<t tx="ekr.20230509052845.3702">def test_try_with_loop2(_):
    try:
        print 'A'
        while True:
            print 'B'
            try:
                print 'C'
                raise ValueError()
                assert False
            except:
                print 'D'
                break
    finally:
        print 'E'

</t>
<t tx="ekr.20230509052845.3703">def test_try_with_loop3(_):
    try:
        try:
            print 'A'
            while True:
                print 'B'
                try:
                    print 'C'
                    raise ValueError()
                    assert False
                except IOError:
                    print 'D'
                    break
        finally:
            print 'E'
    except:
        print 'F'
    finally:
        print 'G'

</t>
<t tx="ekr.20230509052845.3704">def test_try_with_loop4(_):
    try:
        try:
            print 'A'
            while True:
                print 'B'
                try:
                    print 'C'
                    raise ValueError()
                    assert False
                except:
                    print 'D'
                    raise IOError()
                    break
        finally:
            print 'E'
    except:
        print 'F'
    finally:
        print 'G'

</t>
<t tx="ekr.20230509052845.3705"># EXPECT: try
# EXPECT: catch Exc1 1
# EXPECT: e1
# EXPECT: catch Exc1 2
# EXPECT: finally
# EXPECT: done
bar(True)

# EXPECT: try
# EXPECT: catch Exc2 1
# EXPECT: e2
# EXPECT: catch Exc2 2
# EXPECT: finally
# EXPECT: done
bar(0)

# EXPECT: try 1
# EXPECT: try 2
# EXPECT: finally
# EXPECT: done
baz(3.14)

# EXPECT: try 2.1
# EXPECT: try 1.1
# EXPECT: catch Exc1 1.1
# EXPECT: e1
# EXPECT: catch Exc1 1.2
# EXPECT: finally 1
# EXPECT: done 1
# EXPECT: try 2.2
# EXPECT: finally 2
# EXPECT: done 2
baz2(1)

# EXPECT: try 2.1
# EXPECT: try 1.1
# EXPECT: finally 1
# EXPECT: catch Exc2
# EXPECT: finally 2
# EXPECT: done 2
baz2(0)

# EXPECT: f A
# EXPECT: f B
# EXPECT: C
# EXPECT: f C
# EXPECT: f D
# EXPECT: done
nest3(True)

# EXPECT: f A
# EXPECT: f B
# EXPECT: f C
# EXPECT: f D
# EXPECT: except
# EXPECT: done
nest3(0)

print finally_return(3.14)  # EXPECT: B
print finally_return(7)     # EXPECT: A
print finally_return(11)    # EXPECT: C

# EXPECT: A
# EXPECT: B
# EXPECT: C
finally_return_void()

# EXPECT: 0
# EXPECT: 1
# EXPECT: 2
# EXPECT: f
finally_break_continue1()

# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f1
# EXPECT: f2
# EXPECT: 2
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: f3
# EXPECT: f4
finally_break_continue2()

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: B
# EXPECT: D
# EXPECT: E
# EXPECT: G
# EXPECT: I
# EXPECT: 42
print finally_break_continue3(42)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
test_try_with_loop1(0)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
test_try_with_loop2(0.0)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: E
# EXPECT: F
# EXPECT: G
test_try_with_loop3('')

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
# EXPECT: F
# EXPECT: G
test_try_with_loop4(False)

</t>
<t tx="ekr.20230509052845.3706">class Foo:
    i: int
    def __enter__(self: Foo):
        print '&gt; foo! ' + str(self.i)
    def __exit__(self: Foo):
        print '&lt; foo! ' + str(self.i)
    def foo(self: Foo):
        print 'woof'

</t>
<t tx="ekr.20230509052845.3707">class Bar:
    s: str
    def __enter__(self: Bar):
        print '&gt; bar! ' + self.s
    def __exit__(self: Bar):
        print '&lt; bar! ' + self.s
    def bar(self: Bar):
        print 'meow'

</t>
<t tx="ekr.20230509052845.3708">def test_with():
    with Foo(0) as f:
        f.foo()
    with Foo(1) as f, Bar('s') as b:
        f.foo()
        b.bar()
    with Foo(2), Bar('t') as q:
        print 'eeh'
        q.bar()

</t>
<t tx="ekr.20230509052845.3709"># EXPECT: &gt; foo! 0
# EXPECT: woof
# EXPECT: &lt; foo! 0
# EXPECT: &gt; foo! 1
# EXPECT: &gt; bar! s
# EXPECT: woof
# EXPECT: meow
# EXPECT: &lt; bar! s
# EXPECT: &lt; foo! 1
# EXPECT: &gt; foo! 2
# EXPECT: &gt; bar! t
# EXPECT: eeh
# EXPECT: meow
# EXPECT: &lt; bar! t
# EXPECT: &lt; foo! 2
test_with()


</t>
<t tx="ekr.20230509052845.371">class LLVMVisitor : public util::ConstVisitor {
private:
  struct CoroData {
    /// Coroutine promise (where yielded values are stored)
    llvm::Value *promise;
    /// Coroutine handle
    llvm::Value *handle;
    /// Coroutine cleanup block
    llvm::BasicBlock *cleanup;
    /// Coroutine suspend block
    llvm::BasicBlock *suspend;
    /// Coroutine exit block
    llvm::BasicBlock *exit;

    void reset() { promise = handle = cleanup = suspend = exit = nullptr; }
  };

  struct NestableData {
    int sequenceNumber;

    NestableData() : sequenceNumber(-1) {}
  };

  struct LoopData : NestableData {
    /// Block to branch to in case of "break"
    llvm::BasicBlock *breakBlock;
    /// Block to branch to in case of "continue"
    llvm::BasicBlock *continueBlock;
    /// Loop id
    id_t loopId;

    LoopData(llvm::BasicBlock *breakBlock, llvm::BasicBlock *continueBlock, id_t loopId)
        : NestableData(), breakBlock(breakBlock), continueBlock(continueBlock),
          loopId(loopId) {}

    void reset() { breakBlock = continueBlock = nullptr; }
  };

  struct TryCatchData : NestableData {
    /// Possible try-catch states when reaching finally block
    enum State { NOT_THROWN = 0, THROWN, CAUGHT, RETURN, BREAK, CONTINUE };
    /// Exception block
    llvm::BasicBlock *exceptionBlock;
    /// Exception route block
    llvm::BasicBlock *exceptionRouteBlock;
    /// Finally start block
    llvm::BasicBlock *finallyBlock;
    /// Try-catch catch types
    std::vector&lt;types::Type *&gt; catchTypes;
    /// Try-catch handlers, corresponding to catch types
    std::vector&lt;llvm::BasicBlock *&gt; handlers;
    /// Exception state flag (see "State")
    llvm::Value *excFlag;
    /// Storage for caught exception
    llvm::Value *catchStore;
    /// How far to delegate up the finally chain
    llvm::Value *delegateDepth;
    /// Storage for postponed return
    llvm::Value *retStore;
    /// Loop being manipulated
    llvm::Value *loopSequence;

    TryCatchData()
        : NestableData(), exceptionBlock(nullptr), exceptionRouteBlock(nullptr),
          finallyBlock(nullptr), catchTypes(), handlers(), excFlag(nullptr),
          catchStore(nullptr), delegateDepth(nullptr), retStore(nullptr),
          loopSequence(nullptr) {}

@others
  /// Constructs an LLVM visitor.
  LLVMVisitor();

  /// @return true if in debug mode, false otherwise
  bool getDebug() const { return db.debug; }
  /// Sets debug status.
  /// @param d true if debug mode
  void setDebug(bool d = true) { db.debug = d; }

  /// @return true if in JIT mode, false otherwise
  bool getJIT() const { return db.jit; }
  /// Sets JIT status.
  /// @param j true if JIT mode
  void setJIT(bool j = true) { db.jit = j; }

  /// @return true if in standalone mode, false otherwise
  bool getStandalone() const { return db.standalone; }
  /// Sets standalone status.
  /// @param s true if standalone
  void setStandalone(bool s = true) { db.standalone = s; }

  /// @return true if capturing outputs, false otherwise
  bool getCapture() const { return db.capture; }
  /// Sets capture status.
  /// @param c true to capture
  void setCapture(bool c = true) { db.capture = c; }

  /// @return program flags
  std::string getFlags() const { return db.flags; }
  /// Sets program flags.
  /// @param f flags
  void setFlags(const std::string &amp;f) { db.flags = f; }

  llvm::LLVMContext &amp;getContext() { return *context; }
  llvm::IRBuilder&lt;&gt; &amp;getBuilder() { return *B; }
  llvm::Module *getModule() { return M.get(); }
  llvm::FunctionCallee getFunc() { return func; }
  llvm::BasicBlock *getBlock() { return block; }
  llvm::Value *getValue() { return value; }
  std::unordered_map&lt;id_t, llvm::Value *&gt; &amp;getVars() { return vars; }
  std::unordered_map&lt;id_t, llvm::Function *&gt; &amp;getFuncs() { return funcs; }
  CoroData &amp;getCoro() { return coro; }
  std::vector&lt;LoopData&gt; &amp;getLoops() { return loops; }
  std::vector&lt;TryCatchData&gt; &amp;getTryCatch() { return trycatch; }
  DebugInfo &amp;getDebugInfo() { return db; }

  void setFunc(llvm::Function *f) { func = f; }
  void setBlock(llvm::BasicBlock *b) { block = b; }
  void setValue(llvm::Value *v) { value = v; }

  /// Registers a new global variable or function with
  /// this visitor.
  /// @param var the global variable (or function) to register
  void registerGlobal(const Var *var);

  /// Returns a new LLVM module initialized for the host
  /// architecture.
  /// @param context LLVM context used for creating module
  /// @param src source information for the new module
  /// @return a new module
  std::unique_ptr&lt;llvm::Module&gt; makeModule(llvm::LLVMContext &amp;context,
                                           const SrcInfo *src = nullptr);

  /// Returns the current module/LLVM context and replaces them
  /// with new, fresh ones. References to variables or functions
  /// from the old module will be included as "external".
  /// @param module the IR module
  /// @param src source information for the new module
  /// @return the current module/context, replaced internally
  std::pair&lt;std::unique_ptr&lt;llvm::Module&gt;, std::unique_ptr&lt;llvm::LLVMContext&gt;&gt;
  takeModule(Module *module, const SrcInfo *src = nullptr);

  /// Sets current debug info based on a given node.
  /// @param node the node whose debug info to use
  void setDebugInfoForNode(const Node *node);

  /// Compiles a given IR node, updating the internal
  /// LLVM value and/or function as a result.
  /// @param node the node to compile
  void process(const Node *node);

  /// Dumps the unoptimized module IR to a file.
  /// @param filename name of file to write IR to
  void dump(const std::string &amp;filename = "_dump.ll");
  /// Writes module as native object file.
  /// @param filename the .o file to write to
  /// @param pic true to write position-independent code
  void writeToObjectFile(const std::string &amp;filename, bool pic = false);
  /// Writes module as LLVM bitcode file.
  /// @param filename the .bc file to write to
  void writeToBitcodeFile(const std::string &amp;filename);
  /// Writes module as LLVM IR file.
  /// @param filename the .ll file to write to
  void writeToLLFile(const std::string &amp;filename, bool optimize = true);
  /// Writes module as native executable. Invokes an
  /// external linker to generate the final executable.
  /// @param filename the file to write to
  /// @param argv0 compiler's argv[0] used to set rpath
  /// @param library whether to make a shared library
  /// @param libs library names to link
  /// @param lflags extra flags to pass linker
  void writeToExecutable(const std::string &amp;filename, const std::string &amp;argv0,
                         bool library = false,
                         const std::vector&lt;std::string&gt; &amp;libs = {},
                         const std::string &amp;lflags = "");
  /// Writes module as Python extension object.
  /// @param pymod extension module
  /// @param filename the file to write to
  void writeToPythonExtension(const PyModule &amp;pymod, const std::string &amp;filename);
  /// Runs optimization passes on module and writes the result
  /// to the specified file. The output type is determined by
  /// the file extension (.ll for LLVM IR, .bc for LLVM bitcode
  /// .o or .obj for object file, other for executable).
  /// @param filename name of the file to write to
  /// @param argv0 compiler's argv[0] used to set rpath
  /// @param libs library names to link to, if creating executable
  /// @param lflags extra flags to pass linker, if creating executable
  void compile(const std::string &amp;filename, const std::string &amp;argv0,
               const std::vector&lt;std::string&gt; &amp;libs = {},
               const std::string &amp;lflags = "");
  /// Runs optimization passes on module and executes it.
  /// @param args vector of arguments to program
  /// @param libs vector of libraries to load
  /// @param envp program environment
  void run(const std::vector&lt;std::string&gt; &amp;args = {},
           const std::vector&lt;std::string&gt; &amp;libs = {},
           const char *const *envp = nullptr);

  /// Gets LLVM type from IR type
  /// @param t the IR type
  /// @return corresponding LLVM type
  llvm::Type *getLLVMType(types::Type *t);
  /// Gets LLVM function type from IR function type
  /// @param t the IR type (must be FuncType)
  /// @return corresponding LLVM function type
  llvm::FunctionType *getLLVMFuncType(types::Type *t);
  /// Gets the LLVM debug info type from the IR type
  /// @param t the IR type
  /// @return corresponding LLVM DI type
  llvm::DIType *getDIType(types::Type *t);
  /// Gets loop data for a given loop id
  /// @param loopId the IR id of the loop
  /// @return the loop's datas
  LoopData *getLoopData(id_t loopId);

  /// Sets the plugin manager
  /// @param p the plugin manager
  void setPluginManager(PluginManager *p) { plugins = p; }
  /// @return the plugin manager
  PluginManager *getPluginManager() { return plugins; }

  void visit(const Module *) override;
  void visit(const BodiedFunc *) override;
  void visit(const ExternalFunc *) override;
  void visit(const InternalFunc *) override;
  void visit(const LLVMFunc *) override;
  void visit(const Var *) override;
  void visit(const VarValue *) override;
  void visit(const PointerValue *) override;

  void visit(const IntConst *) override;
  void visit(const FloatConst *) override;
  void visit(const BoolConst *) override;
  void visit(const StringConst *) override;
  void visit(const dsl::CustomConst *) override;

  void visit(const SeriesFlow *) override;
  void visit(const IfFlow *) override;
  void visit(const WhileFlow *) override;
  void visit(const ForFlow *) override;
  void visit(const ImperativeForFlow *) override;
  void visit(const TryCatchFlow *) override;
  void visit(const PipelineFlow *) override;
  void visit(const dsl::CustomFlow *) override;

  void visit(const AssignInstr *) override;
  void visit(const ExtractInstr *) override;
  void visit(const InsertInstr *) override;
  void visit(const CallInstr *) override;
  void visit(const StackAllocInstr *) override;
  void visit(const TypePropertyInstr *) override;
  void visit(const YieldInInstr *) override;
  void visit(const TernaryInstr *) override;
  void visit(const BreakInstr *) override;
  void visit(const ContinueInstr *) override;
  void visit(const ReturnInstr *) override;
  void visit(const YieldInstr *) override;
  void visit(const ThrowInstr *) override;
  void visit(const FlowInstr *) override;
  void visit(const dsl::CustomInstr *) override;
};

</t>
<t tx="ekr.20230509052845.3710">class PropClass:
    x: int

    @property
    def foo(self: PropClass):
        raise IOError('foo')

</t>
<t tx="ekr.20230509052845.3711">def test_property_exceptions():
    try:
        PropClass(42).foo
        print 'X'
    except IOError as e:
        print e.message

</t>
<t tx="ekr.20230509052845.3712"># EXPECT: foo
test_property_exceptions()

</t>
<t tx="ekr.20230509052845.3713">def test_empty_raise():
    @others
    for b in (False, True):
        try:
            baz(b)
        except:
            print('C')

</t>
<t tx="ekr.20230509052845.3714">def foo(b):
    if b:
        raise ValueError('A')
    else:
        raise IOError('B')

</t>
<t tx="ekr.20230509052845.3715">def bar(b):
    try:
        foo(b)
        print('X')
    except IOError as e:
        print(e)
        raise
    except:
        raise

</t>
<t tx="ekr.20230509052845.3716">def baz(b):
    try:
        bar(b)
    except ValueError as e:
        print(e)
        raise

</t>
<t tx="ekr.20230509052845.3717">@path C:/Repos/codon/test/core/
v = range(5)
print len(v)  # EXPECT: 5
print 2 in v  # EXPECT: True
print 5 in v  # EXPECT: False
print [a for a in v]  # EXPECT: [0, 1, 2, 3, 4]
print list(reversed(v))  # EXPECT: [4, 3, 2, 1, 0]
print bool(v)  # EXPECT: True

v = range(10, 2, -3)
print len(v)  # EXPECT: 3
print 13 in v  # EXPECT: False
print 10 in v  # EXPECT: True
print 7 in v  # EXPECT: True
print 4 in v  # EXPECT: True
print 1 in v  # EXPECT: False
print [a for a in v]  # EXPECT: [10, 7, 4]
print list(reversed(v))  # EXPECT: [4, 7, 10]
print bool(v)  # EXPECT: True

v = range(10, 2, 3)
print len(v)  # EXPECT: 0
print 13 in v  # EXPECT: False
print 10 in v  # EXPECT: False
print 7 in v  # EXPECT: False
print 4 in v  # EXPECT: False
print 1 in v  # EXPECT: False
print [a for a in v]  # EXPECT: []
print list(reversed(v))  # EXPECT: []
print bool(v)  # EXPECT: False

@others
test_generator_in_finally()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3718">def perms[T](elements: list[T]):
    if len(elements) &lt;=1:
        yield elements
    else:
        for perm in perms(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + elements[0:1] + perm[i:]

</t>
<t tx="ekr.20230509052845.3719">for a in perms([1,2,3,4]):
    print a

# EXPECT: [1, 2, 3, 4]
# EXPECT: [2, 1, 3, 4]
# EXPECT: [2, 3, 1, 4]
# EXPECT: [2, 3, 4, 1]
# EXPECT: [1, 3, 2, 4]
# EXPECT: [3, 1, 2, 4]
# EXPECT: [3, 2, 1, 4]
# EXPECT: [3, 2, 4, 1]
# EXPECT: [1, 3, 4, 2]
# EXPECT: [3, 1, 4, 2]
# EXPECT: [3, 4, 1, 2]
# EXPECT: [3, 4, 2, 1]
# EXPECT: [1, 2, 4, 3]
# EXPECT: [2, 1, 4, 3]
# EXPECT: [2, 4, 1, 3]
# EXPECT: [2, 4, 3, 1]
# EXPECT: [1, 4, 2, 3]
# EXPECT: [4, 1, 2, 3]
# EXPECT: [4, 2, 1, 3]
# EXPECT: [4, 2, 3, 1]
# EXPECT: [1, 4, 3, 2]
# EXPECT: [4, 1, 3, 2]
# EXPECT: [4, 3, 1, 2]
# EXPECT: [4, 3, 2, 1]


</t>
<t tx="ekr.20230509052845.372">    void reset() {
      exceptionBlock = exceptionRouteBlock = finallyBlock = nullptr;
      catchTypes.clear();
      handlers.clear();
      excFlag = catchStore = delegateDepth = loopSequence = nullptr;
    }
</t>
<t tx="ekr.20230509052845.3720">def mysum[T](start: T):
    m = start
    while True:
        a = (yield)
        if a == -1:
            break
        m += a
    yield m

</t>
<t tx="ekr.20230509052845.3721">iadder = mysum(0)
next(iadder)
for i in range(10):
    iadder.send(i)
print(iadder.send(-1))  # EXPECT: 45

fadder = mysum(0.0)
next(fadder)
for i in range(10):
    fadder.send(float(i))
print(fadder.send(-1.0))  # EXPECT: 45


</t>
<t tx="ekr.20230509052845.3722">@test
def test_generator_in_finally():
    @others
    b = False
    try:
        try:
            a = 1
            x = 2
            z = 0
            for a in (foo(i) * x for i in [a,2,3,4,z,5] * x):
                pass
        finally:
            b = True
    except ValueError as e:
        assert e.message == 'not n'
    assert b
</t>
<t tx="ekr.20230509052845.3723">def foo(n):
    if not n:
        raise ValueError('not n')
    return n

</t>
<t tx="ekr.20230509052845.3724">@path C:/Repos/codon/test/core/
@others
# EXPECT: True
# EXPECT: 0
bar(0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3725">class A[TA,TB,TC]:
    a: TA
    b: TB
    c: TC

    @others
</t>
<t tx="ekr.20230509052845.3726">def dump(a, b, c):
    print a, b, c

</t>
<t tx="ekr.20230509052845.3727"># non-generic method:
def m0(self: A[TA,TB,TC], a: int):
    print a

</t>
<t tx="ekr.20230509052845.3728"># basic generics:
def m1[X](self: A[TA,TB,TC], other: A[X,X,X]):
    print other.a, other.b, other.c

</t>
<t tx="ekr.20230509052845.3729"># non-generic method referencing outer generics:
def m2(a: TA, b: TB, c: TC):
    A.dump(a, b, c)

</t>
<t tx="ekr.20230509052845.373">  };

  struct CatchData : NestableData {
    llvm::Value *exception;
    llvm::Value *typeId;
  };

  struct DebugInfo {
    /// LLVM debug info builder
    std::unique_ptr&lt;llvm::DIBuilder&gt; builder;
    /// Current compilation unit
    llvm::DICompileUnit *unit;
    /// Whether we are compiling in debug mode
    bool debug;
    /// Whether we are compiling in JIT mode
    bool jit;
    /// Whether we are compiling a standalone object/executable
    bool standalone;
    /// Whether to capture writes to stdout/stderr
    bool capture;
    /// Program command-line flags
    std::string flags;

    DebugInfo()
        : builder(), unit(nullptr), debug(false), jit(false), standalone(false),
          capture(false), flags() {}

    llvm::DIFile *getFile(const std::string &amp;path);

</t>
<t tx="ekr.20230509052845.3730"># generic args:
def m3(self, other):
    return self.a

</t>
<t tx="ekr.20230509052845.3731"># lots of nesting:
def m4[TD](self: A[TA,TB,TC], d: TD):
    def m5[TA,TB,TC,TD,TE](a: TA, b: TB, c: TC, d: TD, e: TE):
        print a, b, c, d, e
    m5(self.a, self.b, self.c, d, d)

</t>
<t tx="ekr.20230509052845.3732"># instantiating the type:
def m5(self):
    x = A(self.a, self.b, self.c)
    A.dump(x.a, x.b, x.c)

</t>
<t tx="ekr.20230509052845.3733"># deeply nested generic type:
def m6[T](v: array[array[array[T]]]):
    return v[0][0][0]

</t>
<t tx="ekr.20230509052845.3734"># explicit realization:
def m7(T: type, S: type):
    print "works"

</t>
<t tx="ekr.20230509052845.3735">class B1[T]:
    a: T
    def foo[S](self: S) -&gt; B1[int]:
        return B1[int](111)

</t>
<t tx="ekr.20230509052845.3736">class B2[T]:
    a: T
    def foo[S](self: B2[S]):
        return B2[int](222)

</t>
<t tx="ekr.20230509052845.3737">a1 = A(42, 3.14, "hello")
a2 = A(1, 2, 3)
b1 = B1[bool](True).foo()
b2 = B2[str]("x").foo()

v1 = array[array[array[str]]](1)
v2 = array[array[str]](1)
v3 = array[str](1)
v1[0] = v2
v2[0] = v3
v3[0] = "world"
f = a2.m0

a1.m1(a2)                           # EXPECT: 1 2 3
A[int,float,str].m2(1, 1.0, "one")  # EXPECT: 1 1 one
A[int,int,int].m2(11, 22, 33)       # EXPECT: 11 22 33
print a1.m3(a2)                     # EXPECT: 42
print a1.m3(a2)                     # EXPECT: 42
print a2.m3(a1)                     # EXPECT: 1
a1.m4(True)                         # EXPECT: 42 3.14 hello True True
a1.m4([1])                          # EXPECT: 42 3.14 hello [1] [1]
a2.m4("x")                          # EXPECT: 1 2 3 x x
a1.m5()                             # EXPECT: 42 3.14 hello
a2.m5()                             # EXPECT: 1 2 3
print A.m6(v1)                      # EXPECT: world
m7(str,float)                       # EXPECT: works
m7(str,float)                       # EXPECT: works
m7(float,str)                       # EXPECT: works
f(99)                               # EXPECT: 99
print b1.foo().a                    # EXPECT: 111
print b2.foo().a                    # EXPECT: 222


</t>
<t tx="ekr.20230509052845.3738"># recursive generics with different inner type parameter
def foo(a):
    if not a:
        foo(True)
    print a
</t>
<t tx="ekr.20230509052845.3739"># EXPECT: True
# EXPECT: 0
foo(0)

</t>
<t tx="ekr.20230509052845.374">    void reset() {
      builder = {};
      unit = nullptr;
    }
</t>
<t tx="ekr.20230509052845.3740">def bar(a):
    def baz(x):
        if not x:
            bar(True)
        print(x)
    baz(a)
</t>
<t tx="ekr.20230509052845.3741">@path C:/Repos/codon/test/core/
print "hello world"  # EXPECT: hello world
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3742">@path C:/Repos/codon/test/core/
from core.llvm import *

@others
test_int_llvm_ops()
test_float_llvm_ops()
test_conversion_llvm_ops()
test_str_llvm_ops()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3743">@test
def test_int_llvm_ops():
    assert add_int(42, 99) == 141
    assert add_int(-10, 10) == 0
    assert sub_int(12, 6) == 6
    assert sub_int(5, -5) == 10
    assert mul_int(22, 33) == 726
    assert mul_int(-3, 3) == -9
    assert div_int(10, 2) == 5
    assert div_int(10, 3) == 3
    assert div_int(10, -3) == -3
    assert mod_int(10, 2) == 0
    assert mod_int(10, 3) == 1

    assert eq_int(42, 42)
    assert not eq_int(10, -10)
    assert ne_int(0, 1)
    assert not ne_int(-3, -3)

    assert lt_int(2, 3)
    assert not lt_int(3, 2)
    assert not lt_int(3, 3)

    assert not gt_int(2, 3)
    assert gt_int(3, 2)
    assert not gt_int(3, 3)

    assert le_int(2, 3)
    assert not le_int(3, 2)
    assert le_int(3, 3)

    assert not ge_int(2, 3)
    assert ge_int(3, 2)
    assert ge_int(3, 3)

    assert inv_int(0b1010) == -11
    assert and_int(0b1010, 0b1101) == 0b1000
    assert or_int(0b1010, 0b1101) == 0b1111
    assert xor_int(0b1010, 0b1101) == 0b0111
    assert shr_int(0b1010, 3) == 0b1
    assert shl_int(0b1010, 3) == 0b1010000

    assert bitreverse_int(0b0111110111010110001001001000001010001000110001010110001101001101) == 0b1011001011000110101000110001000101000001001001000110101110111110
    assert bitreverse_int(0) == 0
    assert bitreverse_int(0xffffffffffffffff) == 0xffffffffffffffff
    assert ctpop_int(0x7dd6248288c5634d) == 29
    assert ctpop_int(0) == 0
    assert ctpop_int(0xffffffffffffffff) == 64
    assert bswap_int(0x7dd6248288c5634d) == 0x4d63c5888224d67d
    assert bswap_int(0) == 0
    assert bswap_int(0xffffffffffffffff) == 0xffffffffffffffff
    assert ctlz_int(0b0001110111010110001001001000001010001000110001010110001101001101) == 3
    assert ctlz_int(0b0011110111010110001001001000001010001000110001010110001101001101) == 2
    assert ctlz_int(0b0111110111010110001001001000001010001000110001010110001101001101) == 1
    assert ctlz_int(0b1111110111010110001001001000001010001000110001010110001101001101) == 0
    assert ctlz_int(0) == 64
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001000) == 3
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001100) == 2
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001110) == 1
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001111) == 0
    assert cttz_int(0) == 64

</t>
<t tx="ekr.20230509052845.3744">@test
def test_float_llvm_ops():
    @others
    PI = 3.1415926535897932384626433832795028841971693993751058209749445923078164062
    E = 2.718281828459045235360287471352662497757247093699959574966967627724076630353

    assert add_float(42., 99.) == 141.
    assert add_float(-10., 10.) == 0.
    assert sub_float(12., 6.) == 6.
    assert sub_float(5., -5.) == 10.
    assert mul_float(22., 33.) == 726.
    assert mul_float(-3., 3.) == -9.
    assert div_float(10., 2.) == 5.
    assert div_float(10., 4.) == 2.5
    assert div_float(10., -2.5) == -4.
    assert mod_float(10., 2.) == 0.
    assert mod_float(10., 3.) == 1.

    assert eq_float(42., 42.)
    assert not eq_float(10., -10.)
    assert ne_float(0., 1.)
    assert not ne_float(-3., -3.)

    assert lt_float(2., 3.)
    assert not lt_float(3., 2.)
    assert not lt_float(3., 3.)

    assert not gt_float(2., 3.)
    assert gt_float(3., 2.)
    assert not gt_float(3., 3.)

    assert le_float(2., 3.)
    assert not le_float(3., 2.)
    assert le_float(3., 3.)

    assert not ge_float(2., 3.)
    assert ge_float(3., 2.)
    assert ge_float(3., 3.)

    assert pow_float(10., 2.) == 100.
    assert sqrt_float(100.) == 10.
    assert sin_float(0.0) == 0.
    assert sin_float(PI/2) == 1.
    assert approx_eq(sin_float(PI), 0.)
    assert cos_float(0.0) == 1.
    assert approx_eq(cos_float(PI/2), 0.)
    assert cos_float(PI) == -1.
    assert exp_float(0.) == 1.
    assert exp_float(1.) == E
    assert exp2_float(0.) == 1.
    assert exp2_float(1.) == 2.
    assert log_float(1.) == 0.
    assert log_float(E) == 1.
    assert log10_float(1.) == 0.
    assert log10_float(10.) == 1.
    assert log2_float(1.) == 0.
    assert log2_float(2.) == 1.
    assert abs_float(1.5) == 1.5
    assert abs_float(-1.5) == 1.5
    assert pow_float(1., 0.) == 1.
    assert pow_float(3., 2.) == 9.
    assert pow_float(2., -2.) == 0.25
    assert pow_float(-2., 2.) == 4.
    assert min_float(1., 1.) == 1.
    assert min_float(-1., 1.) == -1.
    assert min_float(3., 2.) == 2.
    assert max_float(1., 1.) == 1.
    assert max_float(-1., 1.) == 1.
    assert max_float(3., 2.) == 3.
    assert copysign_float(100., 1.234) == 100.
    assert copysign_float(100., -1.234) == -100.
    assert copysign_float(-100., 1.234) == 100.
    assert copysign_float(-100., -1.234) == -100.
    assert fma_float(2., 3., 4.) == 10.

    assert floor_float(1.5) == 1.
    assert ceil_float(1.5) == 2.
    assert trunc_float(-1.5) == -1.
    assert rint_float(1.8) == 2.
    assert rint_float(1.3) == 1.
    assert nearbyint_float(2.3) == 2.
    assert nearbyint_float(-3.8) == -4.
    assert round_float(2.3) == 2.
    assert round_float(-2.3) == -2.

</t>
<t tx="ekr.20230509052845.3745">def approx_eq(a: float, b: float, thresh: float = 1e-10):
    return -thresh &lt;= a - b &lt;= thresh
</t>
<t tx="ekr.20230509052845.3746">@test
def test_conversion_llvm_ops():
    assert int_to_float(42) == 42.0
    assert int_to_float(-100) == -100.0
    assert float_to_int(3.14) == 3
    assert float_to_int(-3.14) == -3

</t>
<t tx="ekr.20230509052845.3747">@test
def test_str_llvm_ops():
    N = 10
    p = ptr[byte](N)
    for i in range(N):
        p[i] = byte(i + 1)

    q = ptr[byte](N)
    for i in range(N):
        q[i] = byte(0)

    memcpy(q, p, N)
    for i in range(10):
        assert q[i] == byte(i + 1)

    memmove(p + 1, p, N - 1)
    assert p[1] == p[0]
    for i in range(1, N):
        assert p[i] == byte(i)

    memset(p, byte(42), N)
    for i in range(N):
        assert p[i] == byte(42)

</t>
<t tx="ekr.20230509052845.3748">@path C:/Repos/codon/test/core/
@others
test_list_match()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3749">@test
def test_bool_match():
    T, F = True, False

    b = False
    match T:
        case True:
            b = True
        case False:
            assert False
        case _:
            assert False
    assert b

    b = False
    match F:
        case True:
            assert False
        case False:
            b = True
        case _:
            assert False
    assert b
</t>
<t tx="ekr.20230509052845.375">  };

  /// LLVM context used for compilation
  std::unique_ptr&lt;llvm::LLVMContext&gt; context;
  /// Module we are compiling
  std::unique_ptr&lt;llvm::Module&gt; M;
  /// LLVM IR builder used for constructing LLVM IR
  std::unique_ptr&lt;llvm::IRBuilder&lt;&gt;&gt; B;
  /// Current function we are compiling
  llvm::Function *func;
  /// Current basic block we are compiling
  llvm::BasicBlock *block;
  /// Last compiled value
  llvm::Value *value;
  /// LLVM values corresponding to IR variables
  std::unordered_map&lt;id_t, llvm::Value *&gt; vars;
  /// LLVM functions corresponding to IR functions
  std::unordered_map&lt;id_t, llvm::Function *&gt; funcs;
  /// Coroutine data, if current function is a coroutine
  CoroData coro;
  /// Loop data stack, containing break/continue blocks
  std::vector&lt;LoopData&gt; loops;
  /// Try-catch data stack
  std::vector&lt;TryCatchData&gt; trycatch;
  /// Catch-block data stack
  std::vector&lt;CatchData&gt; catches;
  /// Debug information
  DebugInfo db;
  /// Plugin manager
  PluginManager *plugins;

  llvm::DIType *
  getDITypeHelper(types::Type *t,
                  std::unordered_map&lt;std::string, llvm::DICompositeType *&gt; &amp;cache);

  /// GC allocation functions
  llvm::FunctionCallee makeAllocFunc(bool atomic);
  /// Personality function for exception handling
  llvm::FunctionCallee makePersonalityFunc();
  /// Exception allocation function
  llvm::FunctionCallee makeExcAllocFunc();
  /// Exception throw function
  llvm::FunctionCallee makeThrowFunc();
  /// Program termination function
  llvm::FunctionCallee makeTerminateFunc();

  // Try-catch types and utilities
  llvm::StructType *getTypeInfoType();
  llvm::StructType *getPadType();
  llvm::StructType *getExceptionType();
  llvm::GlobalVariable *getTypeIdxVar(const std::string &amp;name);
  llvm::GlobalVariable *getTypeIdxVar(types::Type *catchType);
  int getTypeIdx(types::Type *catchType = nullptr);

  // General function helpers
  llvm::Value *call(llvm::FunctionCallee callee, llvm::ArrayRef&lt;llvm::Value *&gt; args);
  llvm::Function *makeLLVMFunction(const Func *);
  void makeYield(llvm::Value *value = nullptr, bool finalYield = false);
  std::string buildLLVMCodeString(const LLVMFunc *);
  void callStage(const PipelineFlow::Stage *stage);
  void codegenPipeline(const std::vector&lt;const PipelineFlow::Stage *&gt; &amp;stages,
                       unsigned where = 0);

  // Loop and try-catch state
  void enterLoop(LoopData data);
  void exitLoop();
  void enterTryCatch(TryCatchData data);
  void exitTryCatch();
  void enterCatch(CatchData data);
  void exitCatch();
  TryCatchData *getInnermostTryCatch();
  TryCatchData *getInnermostTryCatchBeforeLoop();

  // Shared library setup
  void setupGlobalCtorForSharedLibrary();

  // Python extension setup
  llvm::Function *createPyTryCatchWrapper(llvm::Function *func);

  // LLVM passes
  void runLLVMPipeline();

  llvm::Value *getVar(const Var *var);
  void insertVar(const Var *var, llvm::Value *x) { vars.emplace(var-&gt;getId(), x); }
  llvm::Function *getFunc(const Func *func);
</t>
<t tx="ekr.20230509052845.3750">test_bool_match()

</t>
<t tx="ekr.20230509052845.3751">@test
def test_str_match():
    s = 'abc'
    t = 'xyz'
    e = ''

    b = False
    match s:
        case '':
            assert False
        case 'abc':
            b = True
        case _:
            assert False
    assert b

    b = False
    match e:
        case '':
            b = True
        case 'abc':
            assert False
        case _:
            assert False
    assert b

    b = False
    match t:
        case '':
            assert False
        case 'abc':
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case '':
            assert False
        case x if len(x) &gt;= 3:
            b = True
        case _:
            assert False
    assert b
</t>
<t tx="ekr.20230509052845.3752">test_str_match()

</t>
<t tx="ekr.20230509052845.3753">@test
def test_tuple_match():
    t = (42, 99)
    r = (12, 12)

    b = False
    match t:
        case (0, 0):
            assert False
        case (42, 99):
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (42, 0):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (0, 99):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, _) if a == 42:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, bb) if 40 &lt; a &lt; bb &lt; 100:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, bb) if a == bb:
            assert False
        case _:
            b = True
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (a, bb) if a == bb:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (41 ... 43, 98 ... 100):
            b = True
        case _:
            assert False
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (41 ... 43, 98 ... 100):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (41 ... 43, 99 | 10) | (11 ... 13, 11 ... 13) | (-1, -1):
            b = True
        case _:
            assert False
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (-1, -1) | (41 ... 43, 10 | 99) | (12 | 11, 9 | 11 ... 13):
            b = True
        case _:
            assert False
    assert b
</t>
<t tx="ekr.20230509052845.3754">test_tuple_match()

</t>
<t tx="ekr.20230509052845.3755">@test
def test_int_match():
    n = 42
    m = -99

    b = False
    match n:
        case 0:
            assert False
        case 1:
            assert False
        case _:
            b = True
    assert b

    b = False
    match n:
        case 0:
            assert False
        case 42:
            b = True
        case 99:
            assert False
        case _:
            assert False
    assert b

    b = False
    match n:
        case 0:
            assert False
        case 1:
            assert False
        case _:
            b = True
    assert b

    b = False
    match m:
        case 0:
            assert False
        case 42:
            assert False
        case -99:
            b = True
        case _:
            assert False
    assert b

    b = False
    match m:
        case 0 ... 10:
            assert False
        case 12 ... 42:
            assert False
        case 42:
            assert False
        case _:
            b = True
    assert b

    b = False
    match n:
        case 0 ... 10:
            assert False
        case 42 ... 100:
            b = True
        case 42:
            assert False
        case _:
            assert False
    assert b

    b = False
    match n:
        case t if t &lt; 10:
            assert False
        case t if 41 &lt; t &lt; 43:
            b = True
        case _:
            assert False
    assert b
</t>
<t tx="ekr.20230509052845.3756">test_int_match()

</t>
<t tx="ekr.20230509052845.3757">@test
def test_list_match():
    v = [1, 2, 3, 4, 5]
    e = list[int]()

    b = False
    match v:
        case []:
            assert False
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            b = True
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case []:
            b = True
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case [...]:
            b = True
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case [_]:
            assert False
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            b = True
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, ..., 4]:
            assert False
        case [1, ..., 5]:
            b = True
        case [1, ..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [_, ..., 4]:
            assert False
        case [_, ..., 5]:
            b = True
        case [_, ..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [5]:
        case []:
            assert False
        case [_, ..., 4]:
            assert False
        case [_, ..., 5]:
            assert False
        case [_, ..., 6]:
            assert False
        case _:
            b = True
    assert b

    b = False
    match v:
        case []:
            assert False
        case [..., 4]:
            assert False
        case [..., 5]:
            b = True
        case [..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, ...]:
            b = True
        case [2, ...]:
            assert False
        case [3, ...]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [2, ..., a, bb] if (a,bb) == (4,5):
            assert False
        case [1, ..., a, bb] if (a,bb) == (4,5):
            b = True
        case [3, ..., a, bb] if (a,bb) == (4,5):
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [2, ..., a, _, bb] if (a,bb) == (3,5):
            assert False
        case [1, ..., a, _, bb] if (a,bb) == (3,5):
            b = True
        case [3, ..., a, _, bb] if (a,bb) == (3,5):
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, _, 3, _, 5]:
            b = True
        case [_, _]:
            assert False
        case [_]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [[v]]:
        case [[[]]]:
            assert False
        case [[[..., 4]]]:
            assert False
        case [[[..., 5]]]:
            b = True
        case [[[..., 6]]]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [[v]]:
        case [[[]]]:
            assert False
        case [[[1, _, 3, _, 5]]]:
            b = True
        case [[[_, _]]]:
            assert False
        case [[[_]]]:
            assert False
        case _:
            assert False
    assert b
</t>
<t tx="ekr.20230509052845.3758">@path C:/Repos/codon/test/core/
import operator as op
import math

NAN = math.nan
INF = math.inf
NINF = -math.inf

@others
test_py_numerics_int()
test_py_numerics_float()

test_isnan()
test_isinf()
test_isfinite()
test_ceil()
test_floor()
test_fabs()
test_fmod()
test_exp()
test_expm1()
test_ldexp()
test_log()
test_log2()
test_log10()
test_degrees()
test_radians()
test_sqrt()
test_pow()
test_acos()
test_asin()
test_atan()
test_atan2()
test_cos()
test_sin()
test_hypot()
test_tan()
test_cosh()
test_sinh()
test_tanh()
test_acosh()
test_asinh()
test_atanh()
test_copysign()
test_log1p()
test_trunc()
test_erf()
test_erfc()
test_gamma()
test_lgamma()
test_remainder()
test_gcd()
test_frexp()
test_modf()
test_isclose()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3759">@test
def test_py_numerics_int():
    one = 1
    iz = 0
    fz = 0.0
    n = 0

    # through function (not optimized / pre-evaluated)
    assert op.floordiv(-5, 2) == -3
    assert op.floordiv(-5, 2.0) == -3.0
    assert op.truediv(-5, 2) == -2.5
    assert op.truediv(-5, 2.0) == -2.5
    assert op.mod(-10, 3) == 2
    assert op.mod(-1, 0.3) == 0.19999999999999996
    assert divmod(-10, 3) == (-4, 2)
    assert divmod(-1, 0.3) == (-4.0, 0.19999999999999996)

    # with vars (evaluated in IR)
    a = -5
    b = 2
    c = 2.0
    d = -10
    e = 3
    f = -1
    g = 0.3
    assert a // b == -3
    assert a // c == -3.0
    assert a / b == -2.5
    assert a / c == -2.5
    assert d % e == 2
    assert f % g == 0.19999999999999996

    # constant (evaluated statically by parser)
    assert -5 // 2 == -3
    assert -10 % 3 == 2

    # errors
    try:
        print(one // fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one // iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(one / fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one / iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'division by zero'
        n += 1

    try:
        print(one % fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(one % iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(divmod(one, iz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(divmod(one, fz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    assert n == 8

</t>
<t tx="ekr.20230509052845.376">  void insertFunc(const Func *func, llvm::Function *x) {
    funcs.emplace(func-&gt;getId(), x);
  }
</t>
<t tx="ekr.20230509052845.3760">@test
def test_py_numerics_float():
    one = 1.0
    iz = 0
    fz = 0.0
    n = 0

    # through function (not optimized / pre-evaluated)
    assert op.floordiv(-5.6, 2) == -3.0
    assert op.floordiv(-5.6, 2.0) == -3.0
    assert op.truediv(-5.6, 2) == -2.8
    assert op.truediv(-5.6, 2.0) == -2.8
    assert op.mod(-10.0, 3) == 2.0
    assert op.mod(-1.0, 0.3) == 0.19999999999999996
    assert divmod(-10.0, 3) == (-4.0, 2.0)
    assert divmod(-1.0, 0.3) == (-4.0, 0.19999999999999996)

    # with vars (evaluated in IR)
    a = -5.6
    b = 2
    c = 2.0
    d = -10.0
    e = 3
    f = -1.0
    g = 0.3
    assert a // b == -3
    assert a // c == -3.0
    assert a / b == -2.8
    assert a / c == -2.8
    assert d % e == 2
    assert f % g == 0.19999999999999996

    try:
        print(one // fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one // iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one / fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one / iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one % fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(one % iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(divmod(one, iz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    try:
        print(divmod(one, fz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    assert n == 8


</t>
<t tx="ekr.20230509052845.3761">import math

NAN = math.nan
INF = math.inf
NINF = -math.inf


</t>
<t tx="ekr.20230509052845.3762">def close(a: float, b: float, epsilon: float = 1e-7):
    return abs(a - b) &lt;= epsilon


</t>
<t tx="ekr.20230509052845.3763">@test
def test_isnan():
    assert math.isnan(float("nan")) == True
    assert math.isnan(4.0) == False


</t>
<t tx="ekr.20230509052845.3764">@test
def test_isinf():
    assert math.isinf(float("inf")) == True
    assert math.isinf(7.0) == False


</t>
<t tx="ekr.20230509052845.3765">@test
def test_isfinite():
    assert math.isfinite(1.4) == True
    assert math.isfinite(0.0) == True
    assert math.isfinite(NAN) == False
    assert math.isfinite(INF) == False
    assert math.isfinite(NINF) == False


</t>
<t tx="ekr.20230509052845.3766">@test
def test_ceil():
    assert math.ceil(3.3) == 4
    assert math.ceil(0.5) == 1
    assert math.ceil(1.0) == 1
    assert math.ceil(1.5) == 2
    assert math.ceil(-0.5) == 0
    assert math.ceil(-1.0) == -1
    assert math.ceil(-1.5) == -1


</t>
<t tx="ekr.20230509052845.3767">@test
def test_floor():
    assert math.floor(3.3) == 3
    assert math.floor(0.5) == 0
    assert math.floor(1.0) == 1
    assert math.floor(1.5) == 1
    assert math.floor(-0.5) == -1
    assert math.floor(-1.0) == -1
    assert math.floor(-1.5) == -2


</t>
<t tx="ekr.20230509052845.3768">@test
def test_fabs():
    assert math.fabs(-1.0) == 1
    assert math.fabs(0.0) == 0
    assert math.fabs(1.0) == 1


</t>
<t tx="ekr.20230509052845.3769">@test
def test_fmod():
    assert math.fmod(10.0, 1.0) == 0.0
    assert math.fmod(10.0, 0.5) == 0.0
    assert math.fmod(10.0, 1.5) == 1.0
    assert math.fmod(-10.0, 1.0) == -0.0
    assert math.fmod(-10.0, 0.5) == -0.0
    assert math.fmod(-10.0, 1.5) == -1.0


</t>
<t tx="ekr.20230509052845.377">  llvm::Value *getDummyVoidValue() { return llvm::ConstantTokenNone::get(*context); }
  llvm::DISubprogram *getDISubprogramForFunc(const Func *x);
  void clearLLVMData();

public:
  static std::string getNameForFunction(const Func *x);
  static std::string getNameForVar(const Var *x);

</t>
<t tx="ekr.20230509052845.3770">@test
def test_exp():
    assert math.exp(0.0) == 1
    assert math.exp(-1.0) == 1 / math.e
    assert math.exp(1.0) == math.e


</t>
<t tx="ekr.20230509052845.3771">@test
def test_expm1():
    assert math.expm1(0.0) == 0
    assert close(math.expm1(1.0), 1.7182818284590453)
    assert close(math.expm1(3.0), 19.085536923187668)
    assert close(math.expm1(5.0), 147.4131591025766)
    assert math.expm1(INF) == INF
    assert math.expm1(NINF) == -1
    assert math.isnan(math.expm1(NAN)) == True


</t>
<t tx="ekr.20230509052845.3772">@test
def test_ldexp():
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, 1) == 2.0
    assert math.ldexp(1.0, -1) == 0.5
    assert math.ldexp(-1.0, 1) == -2.0
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, -1000000) == 0.0
    assert math.ldexp(-1.0, -1000000) == -0.0
    assert math.ldexp(INF, 30) == INF
    assert math.ldexp(NINF, -213) == NINF
    assert math.isnan(math.ldexp(NAN, 0)) == True


</t>
<t tx="ekr.20230509052845.3773">@test
def test_log():
    assert math.log(1.0 / math.e) == -1
    assert math.log(1.0) == 0
    assert math.log(math.e) == 1


</t>
<t tx="ekr.20230509052845.3774">@test
def test_log2():
    assert math.log2(1.0) == 0.0
    assert math.log2(2.0) == 1.0
    assert math.log2(4.0) == 2.0
    assert math.log2(2.0 ** 1023) == 1023.0
    try:
        math.log2(-1.5)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    try:
        math.log2(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.log2(NAN)) == True


</t>
<t tx="ekr.20230509052845.3775">@test
def test_log10():
    assert math.log10(0.1) == -1
    assert math.log10(1.0) == 0
    assert math.log10(10.0) == 1
    assert math.log10(10000.0) == 4


</t>
<t tx="ekr.20230509052845.3776">@test
def test_degrees():
    assert math.degrees(math.pi) == 180.0
    assert math.degrees(math.pi / 2) == 90.0
    assert math.degrees(-math.pi / 4) == -45.0
    assert math.degrees(0.0) == 0.0


</t>
<t tx="ekr.20230509052845.3777">@test
def test_radians():
    assert math.radians(180.0) == math.pi
    assert math.radians(90.0) == math.pi / 2
    assert math.radians(-45.0) == -math.pi / 4
    assert math.radians(0.0) == 0.0


</t>
<t tx="ekr.20230509052845.3778">@test
def test_sqrt():
    assert math.sqrt(4.0) == 2
    assert math.sqrt(0.0) == 0
    assert math.sqrt(1.0) == 1
    try:
        math.sqrt(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


</t>
<t tx="ekr.20230509052845.3779">@test
def test_pow():
    assert math.pow(0.0, 1.0) == 0
    assert math.pow(1.0, 0.0) == 1
    assert math.pow(2.0, 1.0) == 2
    assert math.pow(2.0, -1.0) == 0.5
    assert math.pow(-0.0, 3.0) == -0.0
    assert math.pow(-0.0, 2.3) == 0.0
    assert math.pow(-0.0, 0.0) == 1
    assert math.pow(-0.0, -0.0) == 1
    assert math.pow(-2.0, 2.0) == 4.0
    assert math.pow(-2.0, 3.0) == -8.0
    assert math.pow(-2.0, -3.0) == -0.125
    assert math.pow(INF, 1.0) == INF
    assert math.pow(NINF, 1.0) == NINF
    assert math.pow(1.0, INF) == 1
    assert math.pow(1.0, NINF) == 1
    assert math.isnan(math.pow(NAN, 1.0)) == True
    assert math.isnan(math.pow(2.0, NAN)) == True
    assert math.isnan(math.pow(0.0, NAN)) == True
    assert math.pow(1.0, NAN) == 1
    try:
        math.pow(10.0, 400.0)
        assert False
    except OverflowError as e:
        assert str(e) == 'math range error'


</t>
<t tx="ekr.20230509052845.378">  static std::string getDebugNameForVariable(const Var *x) {
    std::string name = x-&gt;getName();
    auto pos = name.find(".");
    if (pos != 0 &amp;&amp; pos != std::string::npos) {
      return name.substr(0, pos);
    } else {
      return name;
    }
  }

</t>
<t tx="ekr.20230509052845.3780">@test
def test_acos():
    assert math.acos(-1.0) == math.pi
    assert math.acos(0.0) == math.pi / 2
    assert math.acos(1.0) == 0
    assert math.isnan(math.acos(NAN)) == True


</t>
<t tx="ekr.20230509052845.3781">@test
def test_asin():
    assert math.asin(-1.0) == -math.pi / 2
    assert math.asin(0.0) == 0
    assert math.asin(1.0) == math.pi / 2
    assert math.isnan(math.asin(NAN)) == True


</t>
<t tx="ekr.20230509052845.3782">@test
def test_atan():
    assert math.atan(-1.0) == -math.pi / 4
    assert math.atan(0.0) == 0
    assert math.atan(1.0) == math.pi / 4
    assert math.atan(INF) == math.pi / 2
    assert math.atan(NINF) == -math.pi / 2
    assert math.isnan(math.atan(NAN)) == True


</t>
<t tx="ekr.20230509052845.3783">@test
def test_atan2():
    assert math.atan2(-1.0, 0.0) == -math.pi / 2
    assert math.atan2(-1.0, 1.0) == -math.pi / 4
    assert math.atan2(0.0, 1.0) == 0
    assert math.atan2(1.0, 1.0) == math.pi / 4
    assert math.atan2(1.0, 0.0) == math.pi / 2
    assert math.atan2(-0.0, 0.0) == -0
    assert math.atan2(-0.0, 2.3) == -0
    assert math.atan2(0.0, -2.3) == math.pi
    assert math.atan2(INF, NINF) == math.pi * 3 / 4
    assert math.atan2(INF, 2.3) == math.pi / 2
    assert math.isnan(math.atan2(NAN, 0.0)) == True


</t>
<t tx="ekr.20230509052845.3784">@test
def test_cos():
    assert math.cos(0.0) == 1
    assert close(math.cos(math.pi / 2), 6.123233995736766e-17)
    assert close(math.cos(-math.pi / 2), 6.123233995736766e-17)
    assert math.cos(math.pi) == -1

    try:
        math.cos(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.cos(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.cos(NAN)) == True


</t>
<t tx="ekr.20230509052845.3785">@test
def test_sin():
    assert math.sin(0.0) == 0
    assert math.sin(math.pi / 2) == 1
    assert math.sin(-math.pi / 2) == -1

    try:
        math.sin(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.sin(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.sin(NAN)) == True


</t>
<t tx="ekr.20230509052845.3786">@test
def test_hypot():
    assert math.hypot(12.0, 5.0) == 13
    assert math.hypot(12.0 / 32.0, 5.0 / 32) == 13 / 32
    assert math.hypot(0.0, 0.0) == 0
    assert math.hypot(-3.0, 4.0) == 5
    assert math.hypot(3.0, 4.0) == 5


</t>
<t tx="ekr.20230509052845.3787">@test
def test_tan():
    assert math.tan(0.0) == 0
    assert close(math.tan(math.pi / 4), 0.9999999999999999)
    assert close(math.tan(-math.pi / 4), -0.9999999999999999)

    try:
        math.tan(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.tan(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.tan(NAN)) == True


</t>
<t tx="ekr.20230509052845.3788">@test
def test_cosh():
    assert math.cosh(0.0) == 1
    assert math.cosh(2.0) - 2 * math.cosh(1.0) ** 2 == -1
    assert math.cosh(INF) == INF
    assert math.cosh(NINF) == INF
    assert math.isnan(math.cosh(NAN)) == True


</t>
<t tx="ekr.20230509052845.3789">@test
def test_sinh():
    assert math.sinh(0.0) == 0
    assert math.sinh(1.0) + math.sinh(-1.0) == 0
    assert math.sinh(INF) == INF
    assert math.sinh(NINF) == NINF
    assert math.isnan(math.sinh(NAN)) == True


</t>
<t tx="ekr.20230509052845.379">  static const SrcInfo *getDefaultSrcInfo() {
    static SrcInfo defaultSrcInfo("&lt;internal&gt;", 0, 0, 0);
    return &amp;defaultSrcInfo;
  }

</t>
<t tx="ekr.20230509052845.3790">@test
def test_tanh():
    assert math.tanh(0.0) == 0
    assert math.tanh(1.0) + math.tanh(-1.0) == 0
    assert math.tanh(INF) == 1
    assert math.tanh(NINF) == -1
    assert math.isnan(math.tanh(NAN)) == True


</t>
<t tx="ekr.20230509052845.3791">@test
def test_acosh():
    assert math.acosh(1.0) == 0
    assert close(math.acosh(2.0), 1.3169578969248166)
    assert math.acosh(INF) == INF
    assert math.isnan(math.acosh(NAN)) == True
    try:
        math.acosh(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


</t>
<t tx="ekr.20230509052845.3792">@test
def test_asinh():
    assert math.asinh(0.0) == 0
    assert close(math.asinh(1.0), 0.881373587019543)
    assert close(math.asinh(-1.0), -0.881373587019543)
    assert math.asinh(INF) == INF
    assert math.isnan(math.asinh(NAN)) == True
    assert math.asinh(NINF) == NINF


</t>
<t tx="ekr.20230509052845.3793">@test
def test_atanh():
    assert math.atanh(0.0) == 0
    assert close(math.atanh(0.5), 0.5493061443340549)
    assert close(math.atanh(-0.5), -0.5493061443340549)

    try:
        math.atanh(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.atanh(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.atanh(NAN)) == True


</t>
<t tx="ekr.20230509052845.3794">@test
def test_copysign():
    assert math.copysign(1.0, -0.0) == -1
    assert math.copysign(1.0, 42.0) == 1
    assert math.copysign(1.0, -42.0) == -1
    assert math.copysign(3.0, 0.0) == 3
    assert math.copysign(INF, 0.0) == INF
    assert math.copysign(INF, -0.0) == NINF
    assert math.copysign(NINF, 0.0) == INF
    assert math.copysign(NINF, -0.0) == NINF
    assert math.copysign(1.0, INF) == 1
    assert math.copysign(1.0, NINF) == -1
    assert math.copysign(INF, INF) == INF
    assert math.copysign(INF, NINF) == NINF
    assert math.copysign(NINF, INF) == INF
    assert math.copysign(NINF, NINF) == NINF
    assert math.isnan(math.copysign(NAN, 1.0)) == True
    assert math.isnan(math.copysign(NAN, INF)) == True
    assert math.isnan(math.copysign(NAN, NINF)) == True
    assert math.isnan(math.copysign(NAN, NAN)) == True


</t>
<t tx="ekr.20230509052845.3795">@test
def test_log1p():
    assert close(math.log1p(2.0), 1.0986122886681098)
    assert close(math.log1p(2.0 ** 90), 62.383246250395075)
    assert close(math.log1p(2.0 ** 300), 207.94415416798358)
    assert math.log1p(INF) == INF
    try:
        math.log1p(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


</t>
<t tx="ekr.20230509052845.3796">@test
def test_trunc():
    assert math.trunc(1.0) == 1
    assert math.trunc(-1.0) == -1
    assert math.trunc(1.5) == 1
    assert math.trunc(-1.5) == -1
    assert math.trunc(1.99999999) == 1
    assert math.trunc(-1.99999999) == -1
    assert math.trunc(0.99999999) == 0
    assert math.trunc(-100.999) == -100


</t>
<t tx="ekr.20230509052845.3797">@test
def test_erf():
    assert close(math.erf(1.0), 0.8427007929497148)
    assert math.erf(0.0) == 0
    assert close(math.erf(3.0), 0.9999779095030015)
    assert math.erf(256.0) == 1.0
    assert math.erf(INF) == 1.0
    assert math.erf(NINF) == -1.0
    assert math.isnan(math.erf(NAN)) == True


</t>
<t tx="ekr.20230509052845.3798">@test
def test_erfc():
    assert math.erfc(0.0) == 1.0
    assert close(math.erfc(1.0), 0.15729920705028516)
    assert close(math.erfc(2.0), 0.0046777349810472645)
    assert close(math.erfc(-1.0), 1.8427007929497148)
    assert math.erfc(INF) == 0.0
    assert math.erfc(NINF) == 2.0
    assert math.isnan(math.erfc(NAN)) == True


</t>
<t tx="ekr.20230509052845.3799">@test
def test_gamma():
    assert close(math.gamma(6.0), 120.0)
    assert close(math.gamma(1.0), 1.0)
    assert close(math.gamma(2.0), 1.0)
    assert close(math.gamma(3.0), 2.0)
    try:
        math.gamma(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.gamma(INF) == INF
    try:
        math.gamma(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.gamma(NAN)) == True


</t>
<t tx="ekr.20230509052845.38">def get_random_trafo(self):
    r = random.randrange(int(self.num_total) + 1)
    l = 0
    for i in range(len(self.num_trafos)):
        if r &gt;= l and r &lt; l + self.num_trafos[i]:
            return i, random.randrange(self.num_trafos[i])
        l += self.num_trafos[i]
    return len(self.num_trafos) - 1, random.randrange(self.num_trafos[-1])

</t>
<t tx="ekr.20230509052845.380">  static const SrcInfo *getSrcInfo(const Node *x) {
    if (auto *srcInfo = x-&gt;getAttribute&lt;SrcInfoAttribute&gt;()) {
      return &amp;srcInfo-&gt;info;
    } else {
      return getDefaultSrcInfo();
    }
  }

</t>
<t tx="ekr.20230509052845.3800">@test
def test_lgamma():
    assert math.lgamma(1.0) == 0.0
    assert math.lgamma(2.0) == 0.0
    #assert math.lgamma(-1.0) == INF  # Python's custom lgamma gives math domain error
    assert math.lgamma(INF) == INF
    assert math.lgamma(NINF) == INF
    assert math.isnan(math.lgamma(NAN)) == True


</t>
<t tx="ekr.20230509052845.3801">@test
def test_remainder():
    assert math.remainder(2.0, 2.0) == 0.0
    assert math.remainder(-4.0, 1.0) == -0.0
    assert close(math.remainder(-3.8, 1.0), 0.20000000000000018)
    assert close(math.remainder(3.8, 1.0), -0.20000000000000018)
    try:
        math.remainder(INF, 1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    try:
        math.remainder(NINF, 1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.remainder(NAN, 1.0)) == True


</t>
<t tx="ekr.20230509052845.3802">@test
def test_gcd():
    assert math.gcd(0.0, 0.0) == 0
    assert math.gcd(1.0, 0.0) == 1
    assert math.gcd(-1.0, 0.0) == 1
    assert math.gcd(0.0, -1.0) == 1
    assert math.gcd(0.0, 1.0) == 1
    assert math.gcd(7.0, 1.0) == 1
    assert math.gcd(7.0, -1.0) == 1
    assert math.gcd(-23.0, 15.0) == 1
    assert math.gcd(120.0, 84.0) == 12
    assert math.gcd(84.0, -120.0) == 12


</t>
<t tx="ekr.20230509052845.3803">@test
def test_frexp():
    assert math.frexp(-2.0) == (-0.5, 2)
    assert math.frexp(-1.0) == (-0.5, 1)
    assert math.frexp(0.0) == (0.0, 0)
    assert math.frexp(1.0) == (0.5, 1)
    assert math.frexp(2.0) == (0.5, 2)
    assert math.frexp(INF)[0] == INF
    assert math.frexp(NINF)[0] == NINF
    assert math.isnan(math.frexp(NAN)[0]) == True


</t>
<t tx="ekr.20230509052845.3804">@test
def test_modf():
    assert math.modf(1.5) == (0.5, 1.0)
    assert math.modf(-1.5) == (-0.5, -1.0)
    assert math.modf(math.inf) == (0.0, INF)
    assert math.modf(-math.inf) == (-0.0, NINF)
    modf_nan = math.modf(NAN)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


</t>
<t tx="ekr.20230509052845.3805">@test
def test_isclose():
    assert math.isclose(1.0 + 1.0, 1.000000000001 + 1.0) == True
    assert math.isclose(2.90909324093284, 2.909093240932844234234234234) == True
    assert math.isclose(2.90909324093284, 2.9) == False
    assert math.isclose(2.90909324093284, 2.90909324) == True
    assert math.isclose(2.90909324, 2.90909325) == False
    assert math.isclose(NAN, 2.9) == False
    assert math.isclose(2.9, NAN) == False
    assert math.isclose(INF, INF) == True
    assert math.isclose(NINF, NINF) == True
    assert math.isclose(NINF, INF) == False
    assert math.isclose(INF, NINF) == False

</t>
<t tx="ekr.20230509052845.3806">@path C:/Repos/codon/test/core/
x, y = 1, 2
print x, y # EXPECT: 1 2
(x, y) = (3, 4)
print x, y # EXPECT: 3 4
x, y = (1, 2)
print x, y # EXPECT: 1 2
(x, y) = 3, 4
print x, y # EXPECT: 3 4
(x, y) = [3, 4]
print x, y # EXPECT: 3 4
[x, y] = [1, 2]
print x, y # EXPECT: 1 2

# TODO generator/range slices?
# a, b, *tx, c, d = range(10)
# print a, b, tx, c, d # 0 1 [2, 3, 4, 5, 6, 7] 8 9

l = list(iter(range(10)))
[a, b, *lx, c, d] = l
print a, b, lx, c, d # EXPECT: 0 1 [2, 3, 4, 5, 6, 7] 8 9
a, b, *lx = l
print a, b, lx # EXPECT: 0 1 [2, 3, 4, 5, 6, 7, 8, 9]
*lx, a, b = l
print lx, a, b # EXPECT: [0, 1, 2, 3, 4, 5, 6, 7] 8 9

*xz, a, b = (1, 2, 3, 4, 5)
print xz, a, b # EXPECT: (1, 2, 3) 4 5


# *x = range(5) # ERR
(*ex,) = [1, 2, 3]
print ex # EXPECT: [1, 2, 3]

# https://stackoverflow.com/questions/6967632/unpacking-extended-unpacking-and-nested-extended-unpacking

sa, sb = 'XY'
print sa, sb # EXPECT: X Y
(sa, sb), sc = 'XY', 'Z'
print sa, sb, sc # EXPECT: X Y Z
# (sa, sb), sc = 'XYZ' # ERROR:

sa, *la = 'X'
print sa, la, 1 # EXPECT: X  1

sa, *la = 'XYZ'
print sa, la # EXPECT: X YZ

# a, *b, c, *d = 1,2,3,4,5             # ERROR -- two starred expressions in assignment

(xa,xb), *xc, xd = [1,2],'this'
print xa, xb, xc, xd # EXPECT: 1 2 () this

(a, b), (sc, *sl) = [1,2], 'this'
print a, b, sc, sl # EXPECT: 1 2 t his



# // a, b, *x, c, d = y
#   // (^) = y
#   // [^] = y
#   // *a = y NO ; *a, = y YES
#   // (a, b), c = d, e
#   // *(a, *b), c = this
#   // a = *iterable


# # Issue #116
# def foo():
#     a = 42
#     def bar():
#         print a  # &lt;-- this should be a parser error; 'a' has to be global
#     bar()
# foo() # ERROR: identifier 'a' not found
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3807">@path C:/Repos/codon/test/core/
from threading import Lock, RLock

n = 0
f = 0.0
g = f32(0.0)

@others
test_parallel_pipe(0)
test_parallel_pipe(1)
test_parallel_pipe(10)
test_parallel_pipe(10000)

test_nested_parallel_pipe(0)
test_nested_parallel_pipe(1)
test_nested_parallel_pipe(10)
test_nested_parallel_pipe(10000)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3808">@atomic
def inc(_):
    global n, f, g
    n += 1
    f += 1.0
    g += f32(1.0)
    return 0

</t>
<t tx="ekr.20230509052845.3809">@atomic
def dec(_):
    global n, f, g
    n -= 1
    f -= 1.0
    g -= f32(1.0)
    return 0

</t>
<t tx="ekr.20230509052845.381">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "llvm/ADT/FunctionExtras.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/Triple.h"
#include "llvm/Analysis/CallGraph.h"
#include "llvm/Analysis/CallGraphSCCPass.h"
#include "llvm/Analysis/CaptureTracking.h"
#include "llvm/Analysis/LoopPass.h"
#include "llvm/Analysis/RegionPass.h"
#include "llvm/Analysis/TargetLibraryInfo.h"
#include "llvm/Analysis/TargetTransformInfo.h"
#include "llvm/AsmParser/Parser.h"
#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/CodeGen/CommandFlags.h"
#include "llvm/CodeGen/MachineModuleInfo.h"
#include "llvm/CodeGen/TargetPassConfig.h"
#include "llvm/DebugInfo/Symbolize/Symbolize.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/ExecutionEngine/JITLink/JITLink.h"
#include "llvm/ExecutionEngine/JITLink/JITLinkDylib.h"
#include "llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h"
#include "llvm/ExecutionEngine/JITLink/MemoryFlags.h"
#include "llvm/ExecutionEngine/JITSymbol.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h"
#include "llvm/ExecutionEngine/Orc/CompileUtils.h"
#include "llvm/ExecutionEngine/Orc/Core.h"
#include "llvm/ExecutionEngine/Orc/DebugObjectManagerPlugin.h"
#include "llvm/ExecutionEngine/Orc/DebugUtils.h"
#include "llvm/ExecutionEngine/Orc/ELFNixPlatform.h"
#include "llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h"
#include "llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h"
#include "llvm/ExecutionEngine/Orc/EPCEHFrameRegistrar.h"
#include "llvm/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.h"
#include "llvm/ExecutionEngine/Orc/EPCIndirectionUtils.h"
#include "llvm/ExecutionEngine/Orc/ExecutionUtils.h"
#include "llvm/ExecutionEngine/Orc/ExecutorProcessControl.h"
#include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
#include "llvm/ExecutionEngine/Orc/IRTransformLayer.h"
#include "llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h"
#include "llvm/ExecutionEngine/Orc/LLJIT.h"
#include "llvm/ExecutionEngine/Orc/MachOPlatform.h"
#include "llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h"
#include "llvm/ExecutionEngine/Orc/Shared/AllocationActions.h"
#include "llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h"
#include "llvm/ExecutionEngine/Orc/SimpleRemoteEPC.h"
#include "llvm/ExecutionEngine/Orc/SymbolStringPool.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h"
#include "llvm/ExecutionEngine/RuntimeDyld.h"
#include "llvm/ExecutionEngine/SectionMemoryManager.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DIBuilder.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/LLVMRemarkStreamer.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/LegacyPassNameParser.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Verifier.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/InitializePasses.h"
#include "llvm/LinkAllIR.h"
#include "llvm/LinkAllPasses.h"
#include "llvm/Linker/Linker.h"
#include "llvm/MC/SubtargetFeature.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/DynamicLibrary.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Support/Host.h"
#include "llvm/Support/InitLLVM.h"
#include "llvm/Support/Memory.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/RecyclingAllocator.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/SystemUtils.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/ToolOutputFile.h"
#include "llvm/Support/YAMLTraits.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetLoweringObjectFile.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Transforms/IPO.h"
#include "llvm/Transforms/IPO/AlwaysInliner.h"
#include "llvm/Transforms/IPO/GlobalDCE.h"
#include "llvm/Transforms/IPO/Internalize.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/Transforms/IPO/StripDeadPrototypes.h"
#include "llvm/Transforms/IPO/StripSymbols.h"
#include "llvm/Transforms/IPO/WholeProgramDevirt.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Transforms/Utils/Debugify.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3810">lock = Lock()
</t>
<t tx="ekr.20230509052845.3811">def inc_lock(_):
    global n
    with lock:
        n += 1
    return 0

</t>
<t tx="ekr.20230509052845.3812">def dec_lock(_):
    global n
    with lock:
        n -= 1
    return 0

</t>
<t tx="ekr.20230509052845.3813">rlock = RLock()
</t>
<t tx="ekr.20230509052845.3814">def inc_rlock(_):
    global n
    with rlock:
        n += 1
    return 0

</t>
<t tx="ekr.20230509052845.3815">def dec_rlock(_):
    global n
    with rlock:
        n -= 1
    return 0

</t>
<t tx="ekr.20230509052845.3816">def foo(_):
    yield 0

</t>
<t tx="ekr.20230509052845.3817">@test
def test_parallel_pipe(m: int):
    global n, f
    n, f = 0, 0.0
    range(m) |&gt; iter ||&gt; inc
    assert n == m
    assert f == float(m)
    assert g == f32(m)
    range(m) |&gt; iter ||&gt; dec
    assert n == 0
    assert f == 0.0
    assert g == f32(0.0)
    range(m) |&gt; iter ||&gt; inc |&gt; dec
    assert n == 0
    assert f == 0.0
    assert g == f32(0.0)

    n = 0
    range(m) |&gt; iter ||&gt; inc_lock
    assert n == m
    range(m) |&gt; iter ||&gt; dec_lock
    assert n == 0
    range(m) |&gt; iter ||&gt; inc_lock |&gt; dec_lock
    assert n == 0

    n = 0
    range(m) |&gt; iter ||&gt; inc_rlock
    assert n == m
    range(m) |&gt; iter ||&gt; dec_rlock
    assert n == 0
    range(m) |&gt; iter ||&gt; inc_rlock |&gt; dec_rlock
    assert n == 0

</t>
<t tx="ekr.20230509052845.3818">@test
def test_nested_parallel_pipe(m: int):
    global n
    n = 0
    range(m) |&gt; iter ||&gt; inc |&gt; foo ||&gt; dec
    assert n == 0

</t>
<t tx="ekr.20230509052845.3819">@path C:/Repos/codon/test/core/
# test adapted from https://github.com/python/cpython/blob/master/Lib/test/test_range.py

@others
test_range()
test_index()
test_count()
test_repr()
test_strided_limits()
test_empty()
test_slice()
test_contains()
test_reverse_iteration()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.382">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/dsl/plugins.h"

namespace codon {
namespace ir {
std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Triple triple, llvm::StringRef cpuStr,
                 llvm::StringRef featuresStr, const llvm::TargetOptions &amp;options,
                 bool pic = false);

std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Module *module, bool setFunctionAttributes = false,
                 bool pic = false);

void optimize(llvm::Module *module, bool debug, bool jit = false,
              PluginManager *plugins = nullptr);
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3820">@test
def test_range():
    assert list(range(3)) == [0, 1, 2]
    assert list(range(1, 5)) == [1, 2, 3, 4]
    assert list(range(0)) == list[int]()
    assert list(range(-3)) == list[int]()
    assert list(range(1, 10, 3)) == [1, 4, 7]
    assert list(range(5, -5, -3)) == [5, 2, -1, -4]

    a = 10
    b = 100
    c = 50

    assert list(range(a, a+2)) == [a, a+1]
    assert list(range(a+2, a, -1)) == [a+2, a+1]
    assert list(range(a+4, a, -2)) == [a+4, a+2]

    s = list(range(a, b, c))
    assert a in s
    assert b not in s
    assert len(s) == 2

    s = list(range(b, a, -c))
    assert b in s
    assert a not in s
    assert len(s) == 2

    s = list(range(-a, -b, -c))
    assert -a in s
    assert -b not in s
    assert len(s) == 2

    val_err = False
    try:
        range(1, 2, 0)
    except ValueError:
        val_err = True
    assert val_err

</t>
<t tx="ekr.20230509052845.3821">@test
def test_index():
    u = range(2)
    assert u.index(0) == 0
    assert u.index(1) == 1
    val_err = False
    try:
        u.index(2)
    except ValueError:
        val_err = True
    assert val_err

    u = range(-2, 3)
    assert u.count(0) == 1
    assert u.index(0) == 2

    a = range(-2, 3)
    assert a.index(0) == 2

    assert range(1, 10, 3).index(4) == 1
    assert range(1, -10, -3).index(-5) == 2

</t>
<t tx="ekr.20230509052845.3822">@test
def test_count():
    assert range(3).count(-1) == 0
    assert range(3).count(0) == 1
    assert range(3).count(1) == 1
    assert range(3).count(2) == 1
    assert range(3).count(3) == 0
    assert range(3).index(1) == 1
    assert range(7, 0, -2).count(5) == 1
    assert range(7, 0, -2).count(-2) == 0
    assert range(7, 0, -1).count(0) == 0
    assert range(7, 0, -1).count(1) == 1

</t>
<t tx="ekr.20230509052845.3823">@test
def test_repr():
    assert str(range(1)) == 'range(0, 1)'
    assert str(range(1, 2)) == 'range(1, 2)'
    assert str(range(1, 2, 3)) == 'range(1, 2, 3)'

</t>
<t tx="ekr.20230509052845.3824">@test
def test_strided_limits():
    r = range(0, 101, 2)
    assert 0 in r
    assert 1 not in r
    assert 2 in r
    assert 99 not in r
    assert 100 in r
    assert 101 not in r

    r = range(0, -20, -1)
    assert 0 in r
    assert -1 in r
    assert -19 in r
    assert -20 not in r

    r = range(0, -20, -2)
    assert -18 in r
    assert -19 not in r
    assert -20 not in r

</t>
<t tx="ekr.20230509052845.3825">@test
def test_empty():
    r = range(0)
    assert 0 not in r
    assert 1 not in r

    r = range(0, -10)
    assert 0 not in r
    assert -1 not in r
    assert 1 not in r

</t>
<t tx="ekr.20230509052845.3826">@test
def test_slice():
    r = range(10)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(0)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(1, 9, 3)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(8, 0, -3)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

</t>
<t tx="ekr.20230509052845.3827">@test
def test_contains():
    r = range(10)
    assert 0 in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

    r = range(9, -1, -1)
    assert 0 in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

    r = range(0, 10, 2)
    assert 0 in r
    assert 1 not in r
    assert 5 not in r
    assert -1 not in r
    assert 10 not in r

    r = range(9, -1, -2)
    assert 0 not in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

</t>
<t tx="ekr.20230509052845.3828">@test
def test_reverse_iteration():
    for r in [range(10),
              range(0),
              range(1, 9, 3),
              range(8, 0, -3),
              ]:
        assert list(reversed(r)) == list(r)[::-1]

</t>
<t tx="ekr.20230509052845.3829">@path C:/Repos/codon/test/core/
import pickle
from copy import copy

@others
test_pickle(42)
test_pickle(3.14)
test_pickle(True)
test_pickle(byte(90))
test_pickle(UInt[123](123123123))
test_pickle(Int[123](-123123123))
test_pickle([11, 22, 33, 44])
test_pickle({11, 22, 33, 44})
test_pickle({11: 1.1, 22: 2.2, 33: 3.3, 44: 4.4})
test_pickle('hello world')
test_pickle('')
test_pickle(MyType(i32(-1001), 'xyz', 5.55))
test_pickle((A(1, ['x', 'abc', '1.1.1.1']), 42, A(1000, ['foo'])))
test_pickle(['ACGTAAGG', 'TATCTGTT'])
test_pickle(list[Int[8]]())
test_pickle({'ACGTAAGG', 'CATTTTTA'})
test_pickle({'ACGTAAGG'})
test_pickle({'ACGTAAGG', 'TTTTGGTT'})
test_pickle(set[Int[8]]())
test_pickle({'ACGTAAGG': 99, 'TTATTCTT': 42})
test_pickle(dict[Int[8],Int[8]]())
test_pickle({'ACGTAAGG': 'ACGTAAGG'})
test_pickle((42, 3.14, True, byte(90), 'ACGTAAGG', 'ACGTAAGG'))
test_pickle(DynamicTuple((111, 222, 333, 444)))
test_pickle(DynamicTuple('hello world'))
test_pickle(DynamicTuple[int]())
test_pickle(DynamicTuple[str]())
test_pickle({i32(42): [[{'ACG', 'ACGTAGCG', 'ACGTAGCG'}, {'ACG', 'ACGTAGCG', 'ACGTAGCG'}], list[set[str]](), [set[str]()], [{''}, {'', 'GCGC'}]]})

test_non_atomic_list_pickle([[3,2,1], [-1,-2,-3], [111,999,888,777], list[int]()])
test_non_atomic_dict_pickle({'first': [3,2,1], 'second': [-1,-2,-3], 'third': [111,999,888,777], 'fourth:': list[int]()})
test_non_atomic_set_pickle({A(42, ['fourty', 'two']), A(0, list[str]()), A(-99, ['negative', 'ninety', 'nine'])})
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.383"></t>
<t tx="ekr.20230509052845.3830">@tuple
class MyType:
    a: i32
    b: str
    c: float

</t>
<t tx="ekr.20230509052845.3831">class A:
    a: int
    v: list[str]

    @others
</t>
<t tx="ekr.20230509052845.3832">def __eq__(self: A, other: A):
    return self.a == other.a and self.v == other.v

</t>
<t tx="ekr.20230509052845.3833">def __ne__(self: A, other: A):
    return not (self == other)

</t>
<t tx="ekr.20230509052845.3834">def __hash__(self: A):
    return self.a

</t>
<t tx="ekr.20230509052845.3835">def __copy__(self: A):
    return A(self.a, copy(self.v))

</t>
<t tx="ekr.20230509052845.3836">@test
def test_pickle[T](x: T):
    import gzip
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, T)
    jar.close()

    assert x == y

</t>
<t tx="ekr.20230509052845.3837">@test
def test_non_atomic_list_pickle[T](x: list[list[T]]):
    import gzip
    copy = [copy(a) for a in x]
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for v in x:
        v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, list[list[T]])
    jar.close()

    assert y == copy

</t>
<t tx="ekr.20230509052845.3838">@test
def test_non_atomic_dict_pickle[T](x: dict[str, list[T]]):
    import gzip
    copy = {k: copy(v) for k,v in x.items()}
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for v in x.values():
        v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, dict[str, list[T]])
    jar.close()

    assert y == copy

</t>
<t tx="ekr.20230509052845.3839">@test
def test_non_atomic_set_pickle(x: set[A]):
    import gzip
    copy = {copy(a) for a in x}
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for a in x:
        a.v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, set[A])
    jar.close()

    assert y == copy

</t>
<t tx="ekr.20230509052845.384">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/module.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3840">@path C:/Repos/codon/test/core/
MANUAL_TEST = False

@others
### Stdlib sort tests ###
print_test(sorted(list[int](), compare_less, reverse=True), list[int]()) # EXPECT: []
print_test(sorted([3, 2, 1], reverse=True), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(sorted([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(sorted([1, 2, 3], compare_greater, reverse=True), [1, 2, 3]) # EXPECT: [1, 2, 3]

@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3841">def print_test[T](a: list[T], b: list[T]):
    if not MANUAL_TEST:
        print(a)
        return

    if len(a) != len(b):
        print(f"FAILED: length of a ({len(a)}) is not length of b ({len(b)})")
        return

    if len(a) == 0:
        print("PASSED")
        return

    for i in range(len(a)):
        if a[i] != b[i]:
            print(f"FAILED: element {i} of a is {a[i]} and is not equal to the element in b {b[i]}")
            return

    print("PASSED")

</t>
<t tx="ekr.20230509052845.3842">### Comparison Functions ###

</t>
<t tx="ekr.20230509052845.3843">def compare_less(x: int, y: int) -&gt; bool:
    return x &lt; y

</t>
<t tx="ekr.20230509052845.3844">def compare_greater(x: int, y: int) -&gt; bool:
    return x &gt; y

</t>
<t tx="ekr.20230509052845.3845">def compare_string(x: str, y: str) -&gt; bool:
    return x &lt; y

</t>
<t tx="ekr.20230509052845.3846">def compare_dict(x: dict[str,int], y: dict[str,int]) -&gt; bool:
    return x["key"] &lt; y["key"]

</t>
<t tx="ekr.20230509052845.3847">### Basic Sort Tests ###
print_test(insertion_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(insertion_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(insertion_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(insertion_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(insertion_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(heap_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(heap_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(heap_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(heap_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(heap_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(pdq_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(pdq_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(pdq_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(pdq_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(pdq_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(tim_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(tim_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(tim_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(tim_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(tim_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]


### Sort Different Types ###
words = ['The', 'quick', 'Brown', 'fox', 'Jumped', 'over', 'The', 'lazy', 'Dog']
dicts = [{"key": 5}, {"key": 9}, {"key": 1}]

print_test(insertion_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(insertion_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(insertion_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(heap_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(heap_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(heap_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(pdq_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(pdq_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(pdq_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(tim_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(tim_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(tim_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

### Sort longer lists ###
ordered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
ordered_r = [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
unordered = [98, 57, 39, 5, 70, 80, 93, 65, 96, 43, 99, 18, 26, 1, 46, 94, 55, 37, 95, 32, 49, 2, 24, 14, 9, 53, 64, 62, 16, 33, 77, 35, 69, 19, 44, 51, 76, 66, 52, 83, 38, 3, 20, 54, 100, 7, 6, 17, 84, 73, 58, 10, 11, 40, 15, 12, 68, 45, 81, 78, 30, 97, 13, 82, 79, 27, 22, 90, 74, 41, 29, 56, 50, 92, 71, 89, 72, 8, 91, 88, 23, 4, 59, 63, 36, 47, 86, 61, 25, 67, 34, 75, 85, 87, 31, 60, 42, 21, 28, 48]

print_test(insertion_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(insertion_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(insertion_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(heap_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(heap_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(heap_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(pdq_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(pdq_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(pdq_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(tim_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(tim_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(tim_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

### Testing Stability ###

</t>
<t tx="ekr.20230509052845.3848">@test
def test_stable():
    data_list = [{'key': 58, 'key2': 1}, {'key': 37, 'key2': 1}, {'key': 41, 'key2': 1}, {'key': 91, 'key2': 1}, {'key': 8, 'key2': 1}, {'key': 15, 'key2': 1}, {'key': 28, 'key2': 1}, {'key': 45, 'key2': 1}, {'key': 84, 'key2': 1}, {'key': 94, 'key2': 1}, {'key': 75, 'key2': 1}, {'key': 70, 'key2': 1}, {'key': 64, 'key2': 1}, {'key': 17, 'key2': 1}, {'key': 47, 'key2': 1}, {'key': 11, 'key2': 1}, {'key': 97, 'key2': 1}, {'key': 19, 'key2': 1}, {'key': 92, 'key2': 1}, {'key': 82, 'key2': 1}, {'key': 7, 'key2': 1}, {'key': 77, 'key2': 1}, {'key': 69, 'key2': 1}, {'key': 87, 'key2': 1}, {'key': 72, 'key2': 1}, {'key': 48, 'key2': 1}, {'key': 35, 'key2': 1}, {'key': 26, 'key2': 1}, {'key': 60, 'key2': 1}, {'key': 78, 'key2': 1}, {'key': 67, 'key2': 1}, {'key': 12, 'key2': 1}, {'key': 9, 'key2': 1}, {'key': 79, 'key2': 1}, {'key': 38, 'key2': 1}, {'key': 88, 'key2': 1}, {'key': 86, 'key2': 1}, {'key': 3, 'key2': 1}, {'key': 30, 'key2': 1}, {'key': 89, 'key2': 1}, {'key': 2, 'key2': 1}, {'key': 40, 'key2': 1}, {'key': 81, 'key2': 1}, {'key': 39, 'key2': 1}, {'key': 99, 'key2': 1}, {'key': 5, 'key2': 1}, {'key': 90, 'key2': 1}, {'key': 18, 'key2': 1}, {'key': 1, 'key2': 1}, {'key': 68, 'key2': 1}, {'key': 98, 'key2': 1}, {'key': 27, 'key2': 1}, {'key': 33, 'key2': 1}, {'key': 49, 'key2': 1}, {'key': 62, 'key2': 1}, {'key': 63, 'key2': 1}, {'key': 55, 'key2': 1}, {'key': 71, 'key2': 1}, {'key': 73, 'key2': 1}, {'key': 93, 'key2': 1}, {'key': 57, 'key2': 1}, {'key': 32, 'key2': 1}, {'key': 10, 'key2': 1}, {'key': 23, 'key2': 1}, {'key': 0, 'key2': 1}, {'key': 61, 'key2': 1}, {'key': 95, 'key2': 1}, {'key': 66, 'key2': 1}, {'key': 80, 'key2': 1}, {'key': 4, 'key2': 1}, {'key': 53, 'key2': 1}, {'key': 83, 'key2': 1}, {'key': 21, 'key2': 1}, {'key': 96, 'key2': 1}, {'key': 34, 'key2': 1}, {'key': 25, 'key2': 1}, {'key': 51, 'key2': 1}, {'key': 31, 'key2': 1}, {'key': 44, 'key2': 1}, {'key': 50, 'key2': 1}, {'key': 22, 'key2': 1}, {'key': 36, 'key2': 1}, {'key': 76, 'key2': 1}, {'key': 59, 'key2': 1}, {'key': 14, 'key2': 1}, {'key': 20, 'key2': 1}, {'key': 74, 'key2': 1}, {'key': 13, 'key2': 1}, {'key': 85, 'key2': 1}, {'key': 24, 'key2': 1}, {'key': 56, 'key2': 1}, {'key': 42, 'key2': 1}, {'key': 6, 'key2': 1}, {'key': 16, 'key2': 1}, {'key': 29, 'key2': 1}, {'key': 52, 'key2': 1}, {'key': 54, 'key2': 1}, {'key': 43, 'key2': 1}, {'key': 65, 'key2': 1}, {'key': 46, 'key2': 1}, {'key': 59, 'key2': 2}, {'key': 52, 'key2': 2}, {'key': 8, 'key2': 2}, {'key': 82, 'key2': 2}, {'key': 98, 'key2': 2}, {'key': 67, 'key2': 2}, {'key': 78, 'key2': 2}, {'key': 12, 'key2': 2}, {'key': 60, 'key2': 2}, {'key': 18, 'key2': 2}, {'key': 72, 'key2': 2}, {'key': 80, 'key2': 2}, {'key': 9, 'key2': 2}, {'key': 35, 'key2': 2}, {'key': 90, 'key2': 2}, {'key': 85, 'key2': 2}, {'key': 38, 'key2': 2}, {'key': 64, 'key2': 2}, {'key': 6, 'key2': 2}, {'key': 41, 'key2': 2}, {'key': 10, 'key2': 2}, {'key': 94, 'key2': 2}, {'key': 7, 'key2': 2}, {'key': 21, 'key2': 2}, {'key': 29, 'key2': 2}, {'key': 20, 'key2': 2}, {'key': 44, 'key2': 2}, {'key': 55, 'key2': 2}, {'key': 69, 'key2': 2}, {'key': 2, 'key2': 2}, {'key': 26, 'key2': 2}, {'key': 62, 'key2': 2}, {'key': 45, 'key2': 2}, {'key': 14, 'key2': 2}, {'key': 63, 'key2': 2}, {'key': 47, 'key2': 2}, {'key': 22, 'key2': 2}, {'key': 74, 'key2': 2}, {'key': 56, 'key2': 2}, {'key': 70, 'key2': 2}, {'key': 79, 'key2': 2}, {'key': 68, 'key2': 2}, {'key': 13, 'key2': 2}, {'key': 76, 'key2': 2}, {'key': 58, 'key2': 2}, {'key': 99, 'key2': 2}, {'key': 61, 'key2': 2}, {'key': 5, 'key2': 2}, {'key': 96, 'key2': 2}, {'key': 0, 'key2': 2}, {'key': 81, 'key2': 2}, {'key': 87, 'key2': 2}, {'key': 57, 'key2': 2}, {'key': 40, 'key2': 2}, {'key': 3, 'key2': 2}, {'key': 33, 'key2': 2}, {'key': 15, 'key2': 2}, {'key': 77, 'key2': 2}, {'key': 1, 'key2': 2}, {'key': 24, 'key2': 2}, {'key': 27, 'key2': 2}, {'key': 86, 'key2': 2}, {'key': 25, 'key2': 2}, {'key': 88, 'key2': 2}, {'key': 51, 'key2': 2}, {'key': 16, 'key2': 2}, {'key': 32, 'key2': 2}, {'key': 97, 'key2': 2}, {'key': 28, 'key2': 2}, {'key': 23, 'key2': 2}, {'key': 54, 'key2': 2}, {'key': 31, 'key2': 2}, {'key': 65, 'key2': 2}, {'key': 46, 'key2': 2}, {'key': 50, 'key2': 2}, {'key': 17, 'key2': 2}, {'key': 89, 'key2': 2}, {'key': 39, 'key2': 2}, {'key': 95, 'key2': 2}, {'key': 84, 'key2': 2}, {'key': 92, 'key2': 2}, {'key': 93, 'key2': 2}, {'key': 75, 'key2': 2}, {'key': 34, 'key2': 2}, {'key': 36, 'key2': 2}, {'key': 43, 'key2': 2}, {'key': 30, 'key2': 2}, {'key': 71, 'key2': 2}, {'key': 66, 'key2': 2}, {'key': 4, 'key2': 2}, {'key': 42, 'key2': 2}, {'key': 19, 'key2': 2}, {'key': 37, 'key2': 2}, {'key': 53, 'key2': 2}, {'key': 49, 'key2': 2}, {'key': 73, 'key2': 2}, {'key': 91, 'key2': 2}, {'key': 11, 'key2': 2}, {'key': 48, 'key2': 2}, {'key': 83, 'key2': 2}]
    sorted_list = [{'key': 0, 'key2': 1}, {'key': 0, 'key2': 2}, {'key': 1, 'key2': 1}, {'key': 1, 'key2': 2}, {'key': 2, 'key2': 1}, {'key': 2, 'key2': 2}, {'key': 3, 'key2': 1}, {'key': 3, 'key2': 2}, {'key': 4, 'key2': 1}, {'key': 4, 'key2': 2}, {'key': 5, 'key2': 1}, {'key': 5, 'key2': 2}, {'key': 6, 'key2': 1}, {'key': 6, 'key2': 2}, {'key': 7, 'key2': 1}, {'key': 7, 'key2': 2}, {'key': 8, 'key2': 1}, {'key': 8, 'key2': 2}, {'key': 9, 'key2': 1}, {'key': 9, 'key2': 2}, {'key': 10, 'key2': 1}, {'key': 10, 'key2': 2}, {'key': 11, 'key2': 1}, {'key': 11, 'key2': 2}, {'key': 12, 'key2': 1}, {'key': 12, 'key2': 2}, {'key': 13, 'key2': 1}, {'key': 13, 'key2': 2}, {'key': 14, 'key2': 1}, {'key': 14, 'key2': 2}, {'key': 15, 'key2': 1}, {'key': 15, 'key2': 2}, {'key': 16, 'key2': 1}, {'key': 16, 'key2': 2}, {'key': 17, 'key2': 1}, {'key': 17, 'key2': 2}, {'key': 18, 'key2': 1}, {'key': 18, 'key2': 2}, {'key': 19, 'key2': 1}, {'key': 19, 'key2': 2}, {'key': 20, 'key2': 1}, {'key': 20, 'key2': 2}, {'key': 21, 'key2': 1}, {'key': 21, 'key2': 2}, {'key': 22, 'key2': 1}, {'key': 22, 'key2': 2}, {'key': 23, 'key2': 1}, {'key': 23, 'key2': 2}, {'key': 24, 'key2': 1}, {'key': 24, 'key2': 2}, {'key': 25, 'key2': 1}, {'key': 25, 'key2': 2}, {'key': 26, 'key2': 1}, {'key': 26, 'key2': 2}, {'key': 27, 'key2': 1}, {'key': 27, 'key2': 2}, {'key': 28, 'key2': 1}, {'key': 28, 'key2': 2}, {'key': 29, 'key2': 1}, {'key': 29, 'key2': 2}, {'key': 30, 'key2': 1}, {'key': 30, 'key2': 2}, {'key': 31, 'key2': 1}, {'key': 31, 'key2': 2}, {'key': 32, 'key2': 1}, {'key': 32, 'key2': 2}, {'key': 33, 'key2': 1}, {'key': 33, 'key2': 2}, {'key': 34, 'key2': 1}, {'key': 34, 'key2': 2}, {'key': 35, 'key2': 1}, {'key': 35, 'key2': 2}, {'key': 36, 'key2': 1}, {'key': 36, 'key2': 2}, {'key': 37, 'key2': 1}, {'key': 37, 'key2': 2}, {'key': 38, 'key2': 1}, {'key': 38, 'key2': 2}, {'key': 39, 'key2': 1}, {'key': 39, 'key2': 2}, {'key': 40, 'key2': 1}, {'key': 40, 'key2': 2}, {'key': 41, 'key2': 1}, {'key': 41, 'key2': 2}, {'key': 42, 'key2': 1}, {'key': 42, 'key2': 2}, {'key': 43, 'key2': 1}, {'key': 43, 'key2': 2}, {'key': 44, 'key2': 1}, {'key': 44, 'key2': 2}, {'key': 45, 'key2': 1}, {'key': 45, 'key2': 2}, {'key': 46, 'key2': 1}, {'key': 46, 'key2': 2}, {'key': 47, 'key2': 1}, {'key': 47, 'key2': 2}, {'key': 48, 'key2': 1}, {'key': 48, 'key2': 2}, {'key': 49, 'key2': 1}, {'key': 49, 'key2': 2}, {'key': 50, 'key2': 1}, {'key': 50, 'key2': 2}, {'key': 51, 'key2': 1}, {'key': 51, 'key2': 2}, {'key': 52, 'key2': 1}, {'key': 52, 'key2': 2}, {'key': 53, 'key2': 1}, {'key': 53, 'key2': 2}, {'key': 54, 'key2': 1}, {'key': 54, 'key2': 2}, {'key': 55, 'key2': 1}, {'key': 55, 'key2': 2}, {'key': 56, 'key2': 1}, {'key': 56, 'key2': 2}, {'key': 57, 'key2': 1}, {'key': 57, 'key2': 2}, {'key': 58, 'key2': 1}, {'key': 58, 'key2': 2}, {'key': 59, 'key2': 1}, {'key': 59, 'key2': 2}, {'key': 60, 'key2': 1}, {'key': 60, 'key2': 2}, {'key': 61, 'key2': 1}, {'key': 61, 'key2': 2}, {'key': 62, 'key2': 1}, {'key': 62, 'key2': 2}, {'key': 63, 'key2': 1}, {'key': 63, 'key2': 2}, {'key': 64, 'key2': 1}, {'key': 64, 'key2': 2}, {'key': 65, 'key2': 1}, {'key': 65, 'key2': 2}, {'key': 66, 'key2': 1}, {'key': 66, 'key2': 2}, {'key': 67, 'key2': 1}, {'key': 67, 'key2': 2}, {'key': 68, 'key2': 1}, {'key': 68, 'key2': 2}, {'key': 69, 'key2': 1}, {'key': 69, 'key2': 2}, {'key': 70, 'key2': 1}, {'key': 70, 'key2': 2}, {'key': 71, 'key2': 1}, {'key': 71, 'key2': 2}, {'key': 72, 'key2': 1}, {'key': 72, 'key2': 2}, {'key': 73, 'key2': 1}, {'key': 73, 'key2': 2}, {'key': 74, 'key2': 1}, {'key': 74, 'key2': 2}, {'key': 75, 'key2': 1}, {'key': 75, 'key2': 2}, {'key': 76, 'key2': 1}, {'key': 76, 'key2': 2}, {'key': 77, 'key2': 1}, {'key': 77, 'key2': 2}, {'key': 78, 'key2': 1}, {'key': 78, 'key2': 2}, {'key': 79, 'key2': 1}, {'key': 79, 'key2': 2}, {'key': 80, 'key2': 1}, {'key': 80, 'key2': 2}, {'key': 81, 'key2': 1}, {'key': 81, 'key2': 2}, {'key': 82, 'key2': 1}, {'key': 82, 'key2': 2}, {'key': 83, 'key2': 1}, {'key': 83, 'key2': 2}, {'key': 84, 'key2': 1}, {'key': 84, 'key2': 2}, {'key': 85, 'key2': 1}, {'key': 85, 'key2': 2}, {'key': 86, 'key2': 1}, {'key': 86, 'key2': 2}, {'key': 87, 'key2': 1}, {'key': 87, 'key2': 2}, {'key': 88, 'key2': 1}, {'key': 88, 'key2': 2}, {'key': 89, 'key2': 1}, {'key': 89, 'key2': 2}, {'key': 90, 'key2': 1}, {'key': 90, 'key2': 2}, {'key': 91, 'key2': 1}, {'key': 91, 'key2': 2}, {'key': 92, 'key2': 1}, {'key': 92, 'key2': 2}, {'key': 93, 'key2': 1}, {'key': 93, 'key2': 2}, {'key': 94, 'key2': 1}, {'key': 94, 'key2': 2}, {'key': 95, 'key2': 1}, {'key': 95, 'key2': 2}, {'key': 96, 'key2': 1}, {'key': 96, 'key2': 2}, {'key': 97, 'key2': 1}, {'key': 97, 'key2': 2}, {'key': 98, 'key2': 1}, {'key': 98, 'key2': 2}, {'key': 99, 'key2': 1}, {'key': 99, 'key2': 2}]
    assert tim_sort(data_list, compare_dict) == sorted_list

</t>
<t tx="ekr.20230509052845.3849">@path C:/Repos/codon/test/core/
import sys

@others
d1 = AVL[int,int]()
for a in range(5):
    d1[a] = a*a

# EXPECT: 0
# EXPECT: 1
# EXPECT: 4
# EXPECT: 9
# EXPECT: 16
for a in range(5):
    print d1[a]

print 2 in d1  # EXPECT: True
del d1[2]
print 2 in d1  # EXPECT: False
d1[2] = 44
print 2 in d1  # EXPECT: True
print d1[2]    # EXPECT: 44

del d1[3]
del d1[4]

# EXPECT: 0 0
# EXPECT: 1 1
# EXPECT: 2 44
for t in d1:
    print t[0], t[1]
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.385">/// Utility class to run a series of passes.
class PassManager {
private:
@others
private:
  void runPass(Module *module, const std::string &amp;name);
  void registerStandardPasses(Init init);
  void runAnalysis(Module *module, const std::string &amp;name);
  void invalidate(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509052845.3850">def max(a, b):
    return a if a&gt;=b else b

</t>
<t tx="ekr.20230509052845.3851">class AVLNode[K,V]:
    key: K
    value: V
    parent: Optional[AVLNode[K,V]]
    left: Optional[AVLNode[K,V]]
    right: Optional[AVLNode[K,V]]
    height: int

    @others
</t>
<t tx="ekr.20230509052845.3852">def __init__(self: AVLNode[K,V], parent: Optional[AVLNode[K,V]], k: K, v: V):
    self.key = k
    self.value = v
    self.parent = parent
    self.left = None
    self.right = None
    self.height = -1

</t>
<t tx="ekr.20230509052845.3853">def find(self, k):
    if k &lt; self.key:
        if self.left is None:
            return None
        else:
            return self.left.find(k)
    elif k == self.key:
        return self
    else:
        if self.right is None:
            return None
        else:
            return self.right.find(k)

</t>
<t tx="ekr.20230509052845.3854">def find_min(self):
    current: Optional[AVLNode[K, V]] = self
    while current.left is not None:
        current = current.left
    return current

</t>
<t tx="ekr.20230509052845.3855">def next_larger(self):
    if self.right is not None:
        return self.right.find_min()
    current: Optional[AVLNode[K, V]] = self
    while current.parent is not None and current is current.parent.right:
        current = current.parent
    return current.parent

</t>
<t tx="ekr.20230509052845.3856">def insert(self, node):
    if node is None:
        return
    if node.key &lt; self.key:
        if self.left is None:
            node.parent = self
            self.left = node
        else:
            self.left.insert(node)
    else:
        if self.right is None:
            node.parent = self
            self.right = node
        else:
            self.right.insert(node)

</t>
<t tx="ekr.20230509052845.3857">def delete(self):
    if self.left is None or self.right is None:
        if self is self.parent.left:
            self.parent.left = self.left if self.left else self.right
            if self.parent.left is not None:
                self.parent.left.parent = self.parent
        else:
            self.parent.right = self.left if self.left else self.right
            if self.parent.right is not None:
                self.parent.right.parent = self.parent
        return self
    else:
        s = self.next_larger()
        self.key, s.key = s.key, self.key
        return s.delete()

</t>
<t tx="ekr.20230509052845.3858">def __iter__(self: AVLNode[K,V]):
    if self.left:
        for i in self.left:
            yield i
    yield self
    if self.right:
        for i in self.right:
            yield i

</t>
<t tx="ekr.20230509052845.3859">def height(node):
    if node is None:
        return -1
    else:
        return node.height

</t>
<t tx="ekr.20230509052845.386">  /// Manager for keys of passes.
  class KeyManager {
  private:
    /// mapping of raw key to number of occurences
    std::unordered_map&lt;std::string, int&gt; keys;

  public:
    KeyManager() = default;
    /// Returns a unique'd key for a given raw key.
    /// Does so by appending ":&lt;number&gt;" if the key
    /// has been seen.
    /// @param key the raw key
    /// @return the unique'd key
    std::string getUniqueKey(const std::string &amp;key);
  };

</t>
<t tx="ekr.20230509052845.3860">def update_height(node):
    node.height = max(height(node.left), height(node.right)) + 1

</t>
<t tx="ekr.20230509052845.3861">class AVL[K,V]:
    root: Optional[AVLNode[K,V]]

    @others
</t>
<t tx="ekr.20230509052845.3862">def __init__(self: AVL[K,V]):
    self.root = None

</t>
<t tx="ekr.20230509052845.3863">def find(self, k):
    if not self.root:
        return None
    return self.root.find(k)

</t>
<t tx="ekr.20230509052845.3864">def find_min(self):
    if not self.root:
        return None
    return self.root.find_min()

</t>
<t tx="ekr.20230509052845.3865">def next_larger(self, k):
    node = self.find(k)
    return node.next_larger() if node else None

</t>
<t tx="ekr.20230509052845.3866">def left_rotate(self, x):
    y = x.right
    y.parent = x.parent
    if y.parent is None:
        self.root = y
    else:
        if y.parent.left is x:
            y.parent.left = y
        elif y.parent.right is x:
            y.parent.right = y
    x.right = y.left
    if x.right is not None:
        x.right.parent = x
    y.left = x
    x.parent = y
    update_height(x)
    update_height(y)

</t>
<t tx="ekr.20230509052845.3867">def right_rotate(self, x):
    y = x.left
    y.parent = x.parent
    if y.parent is None:
        self.root = y
    else:
        if y.parent.left is x:
            y.parent.left = y
        elif y.parent.right is x:
            y.parent.right = y
    x.left = y.right
    if x.left is not None:
        x.left.parent = x
    y.right = x
    x.parent = y
    update_height(x)
    update_height(y)

</t>
<t tx="ekr.20230509052845.3868">def rebalance(self, node: Optional[AVLNode[K, V]]):
    while node is not None:
        update_height(node)
        if height(node.left) &gt;= 2 + height(node.right):
            if height(node.left.left) &gt;= height(node.left.right):
                self.right_rotate(node)
            else:
                self.left_rotate(node.left)
                self.right_rotate(node)
        elif height(node.right) &gt;= 2 + height(node.left):
            if height(node.right.right) &gt;= height(node.right.left):
                self.left_rotate(node)
            else:
                self.right_rotate(node.right)
                self.left_rotate(node)
        node = node.parent

</t>
<t tx="ekr.20230509052845.3869">def insert(self, k, v):
    node = AVLNode[K,V](None, k, v)
    if self.root is None:
        # The root's parent is None.
        self.root = node
    else:
        self.root.insert(node)
    self.rebalance(node)

</t>
<t tx="ekr.20230509052845.387">  /// Container for pass metadata.
  struct PassMetadata {
    /// pointer to the pass instance
    std::unique_ptr&lt;Pass&gt; pass;
    /// vector of required analyses
    std::vector&lt;std::string&gt; reqs;
    /// vector of invalidated analyses
    std::vector&lt;std::string&gt; invalidates;

    PassMetadata() = default;
    PassMetadata(std::unique_ptr&lt;Pass&gt; pass, std::vector&lt;std::string&gt; reqs,
                 std::vector&lt;std::string&gt; invalidates)
        : pass(std::move(pass)), reqs(std::move(reqs)),
          invalidates(std::move(invalidates)) {}
    PassMetadata(PassMetadata &amp;&amp;) = default;

    PassMetadata &amp;operator=(PassMetadata &amp;&amp;) = default;
  };

  /// Container for analysis metadata.
  struct AnalysisMetadata {
    /// pointer to the analysis instance
    std::unique_ptr&lt;analyze::Analysis&gt; analysis;
    /// vector of required analyses
    std::vector&lt;std::string&gt; reqs;
    /// vector of invalidated analyses
    std::vector&lt;std::string&gt; invalidates;

    AnalysisMetadata() = default;
    AnalysisMetadata(std::unique_ptr&lt;analyze::Analysis&gt; analysis,
                     std::vector&lt;std::string&gt; reqs)
        : analysis(std::move(analysis)), reqs(std::move(reqs)) {}
    AnalysisMetadata(AnalysisMetadata &amp;&amp;) = default;

    AnalysisMetadata &amp;operator=(AnalysisMetadata &amp;&amp;) = default;
  };

  /// key manager to handle duplicate keys (i.e. passes being added twice)
  KeyManager km;

  /// map of keys to passes
  std::unordered_map&lt;std::string, PassMetadata&gt; passes;
  /// map of keys to analyses
  std::unordered_map&lt;std::string, AnalysisMetadata&gt; analyses;
  /// reverse dependency map
  std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; deps;

  /// execution order of passes
  std::vector&lt;std::string&gt; executionOrder;
  /// map of valid analysis results
  std::unordered_map&lt;std::string, std::unique_ptr&lt;analyze::Result&gt;&gt; results;

  /// passes to avoid registering
  std::vector&lt;std::string&gt; disabled;

  /// whether to use Python (vs. C) numeric semantics in passes
  bool pyNumerics;

  /// true if we are compiling as a Python extension
  bool pyExtension;

public:
  /// PassManager initialization mode.
  enum Init {
    EMPTY,
    DEBUG,
    RELEASE,
    JIT,
  };

  explicit PassManager(Init init, std::vector&lt;std::string&gt; disabled = {},
</t>
<t tx="ekr.20230509052845.3870">def delete(self, k):
    node = self.find(k)
    if node is None:
        return
    deleted = None
    if node is self.root:
        pseudoroot = AVLNode[K,V](None, 0, 0)
        pseudoroot.left = self.root
        self.root.parent = pseudoroot
        deleted = self.root.delete()
        self.root = pseudoroot.left
        if self.root is not None:
            self.root.parent = None
    else:
        deleted = node.delete()
    self.rebalance(deleted.parent)

</t>
<t tx="ekr.20230509052845.3871">def __setitem__(self: AVL[K,V], k: K, v: V):
    self.insert(k, v)

</t>
<t tx="ekr.20230509052845.3872">def __getitem__(self: AVL[K,V], k: K):
    nd = self.find(k)
    if not nd:
        print 'whoops', k, 'not found'
        sys.exit(1)
    return nd.value

</t>
<t tx="ekr.20230509052845.3873">def __delitem__(self: AVL[K,V], k: K):
    self.delete(k)

</t>
<t tx="ekr.20230509052845.3874">def __contains__(self: AVL[K,V], k: K):
    return self.find(k) is not None

</t>
<t tx="ekr.20230509052845.3875">def __iter__(self: AVL[K,V]):
    if self.root:
        for i in self.root:
            yield i.key, i.value

</t>
<t tx="ekr.20230509052845.3876"></t>
<t tx="ekr.20230509052845.3877">@path C:/Repos/codon/test/parser/
#%% ptr,barebones
import internal.gc as gc
print gc.sizeof(Ptr[int]) #: 8
print gc.atomic(Ptr[int]) #: False
y = Ptr[int](1)
y[0] = 11
print y[0] #: 11
_y = y.as_byte()
print int(_y[0]) #: 11
y = Ptr[int](5)
y[0] = 1; y[1] = 2; y[2] = 3; y[3] = 4; y[4] = 5
z = Ptr[int](y)
print y[1], z[2] #: 2 3
z = Ptr[int](y.as_byte())
print y[1], z[2] #: 2 3
print z.__bool__() #: True
z.__int__() # big number...
zz = z.__copy__() # this is not a deep copy!
zz[2] = 10
print z[2], zz[2] #: 10 10
print y.__getitem__(1) #: 2
y.__setitem__(1, 3)
print y[1] #: 3
print y.__add__(1)[0] #: 3
print (y + 3).__sub__(y + 1) #: 2
print y.__eq__(z) #: True
print y.__eq__(zz) #: True
print y.as_byte().__eq__('abc'.ptr) #: False
print y.__ne__(z) #: False
print y.__lt__(y+1) #: True
print y.__gt__(y+1) #: False
print (y+1).__le__(y) #: False
print y.__ge__(y) #: True
y.__prefetch_r0__()
y.__prefetch_r1__()
y.__prefetch_r2__()
y.__prefetch_r3__()
y.__prefetch_w0__()
y.__prefetch_w1__()
y.__prefetch_w2__()
y.__prefetch_w3__()

#%% int,barebones
a = int()
b = int(5)
c = int(True)
d = int(byte(1))
e = int(1.1)
print a, b, c, d, e #: 0 5 1 1 1
print a.__repr__() #: 0
print b.__copy__() #: 5
print b.__hash__() #: 5
print a.__bool__(), b.__bool__() #: False True
print a.__pos__() #: 0
print b.__neg__() #: -5
print (-b).__abs__() #: 5
print c.__truediv__(5) #: 0.2
print b.__lshift__(1) #: 10
print b.__rshift__(1) #: 2
print b.__truediv__(5.15) #: 0.970874
print a.__add__(1) #: 1
print a.__add__(1.1) #: 1.1
print a.__sub__(1) #: -1
print a.__sub__(1.1) #: -1.1
print b.__mul__(1) #: 5
print b.__mul__(1.1) #: 5.5
print b.__floordiv__(2) #: 2
print b.__floordiv__(1.1) #: 4
print b.__mod__(2) #: 1
print b.__mod__(1.1) #: 0.6
print a.__eq__(1) #: False
print a.__eq__(1.1) #: False
print a.__ne__(1) #: True
print a.__ne__(1.1) #: True
print a.__lt__(1) #: True
print a.__lt__(1.1) #: True
print a.__le__(1) #: True
print a.__le__(1.1) #: True
print a.__gt__(1) #: False
print a.__gt__(1.1) #: False
print a.__ge__(1) #: False
print a.__ge__(1.1) #: False

#%% uint,barebones
au = Int[123](15)
a = UInt[123]()
b = UInt[123](a)
a = UInt[123](15)
a = UInt[123](au)
print a.__copy__() #: 15
print a.__hash__() #: 15
print a.__bool__() #: True
print a.__pos__() #: 15
print a.__neg__() #: 10633823966279326983230456482242756593
print a.__invert__() #: 10633823966279326983230456482242756592
m = UInt[123](4)
print a.__add__(m), a.__sub__(m), a.__mul__(m), a.__floordiv__(m), a.__truediv__(m) #: 19 11 60 3 3.75
print a.__mod__(m), a.__lshift__(m), a.__rshift__(m) #: 3 240 0
print a.__eq__(m), a.__ne__(m), a.__lt__(m), a.__gt__(m), a.__le__(m), a.__ge__(m) #: False True False True False True
print a.__and__(m), a.__or__(m), a.__xor__(m) #: 4 15 11
print a, a.popcnt() #: 15 4
ac = Int[128](5)
bc = Int[32](5)
print ac, bc, int(ac), int(bc) #: 5 5 5 5

print int(Int[12](12)) #: 12
print int(Int[122](12)) #: 12
print int(Int[64](12)) #: 12
print int(UInt[12](12)) #: 12
print int(UInt[122](12)) #: 12
print int(UInt[64](12)) #: 12

print Int[32](212) #: 212
print Int[64](212) #: 212
print Int[66](212) #: 212
print UInt[32](112) #: 112
print UInt[64](112) #: 112
print UInt[66](112) #: 112


#%% float,barebones
z = float.__new__()
z = 5.5
print z.__repr__() #: 5.5
print z.__copy__() #: 5.5
print z.__bool__(), z.__pos__(), z.__neg__() #: True 5.5 -5.5
f = 1.3
print z.__floordiv__(f), z.__floordiv__(2) #: 4 2
print z.__truediv__(f), z.__truediv__(2) #: 4.23077 2.75
print z.__pow__(2.2), z.__pow__(2) #: 42.54 30.25
print z.__add__(2) #: 7.5
print z.__sub__(2) #: 3.5
print z.__mul__(2) #: 11
print z.__truediv__(2) #: 2.75
print z.__mod__(2) #: 1.5
print z.__eq__(2) #: False
print z.__ne__(2) #: True
print z.__lt__(2) #: False
print z.__gt__(2) #: True
print z.__le__(2) #: False
print z.__ge__(2) #: True

#%% bool,barebones
z = bool.__new__()
print z.__repr__() #: False
print z.__copy__() #: False
print z.__bool__(), z.__invert__() #: False True
print z.__eq__(True) #: False
print z.__ne__(True) #: True
print z.__lt__(True) #: True
print z.__gt__(True) #: False
print z.__le__(True) #: True
print z.__ge__(True) #: False
print z.__and__(True), z.__or__(True), z.__xor__(True) #: False True True

#%% byte,barebones
z = byte.__new__()
z = byte(65)
print z.__repr__() #: byte('A')
print z.__bool__() #: True
print z.__eq__(byte(5)) #: False
print z.__ne__(byte(5)) #: True
print z.__lt__(byte(5)) #: False
print z.__gt__(byte(5)) #: True
print z.__le__(byte(5)) #: False
print z.__ge__(byte(5)) #: True

#%% array,barebones
a = Array[float](5)
pa = Ptr[float](3)
z = Array[float](pa, 3)
z.__copy__()
print z.__len__() #: 3
print z.__bool__() #: True
z.__setitem__(0, 1.0)
z.__setitem__(1, 2.0)
z.__setitem__(2, 3.0)
print z.__getitem__(1) #: 2
print z.slice(0, 2).len #: 2

#%% optional,barebones
a = Optional[float]()
print bool(a) #: False
a = Optional[float](0.0)
print bool(a) #: False
a = Optional[float](5.5)
print a.__bool__(), a.__val__() #: True 5.5

@others
z = foo()
y = z.__iter__()
print str(y.__raw__())[:2] #: 0x
print y.__done__() #: False
print y.__promise__()[0] #: 0
y.__resume__()
print y.__repr__()[:16] #: &lt;generator at 0x
print y.next() #: 1
print y.done() #: False
y.send(1)
y.destroy()
print y.done() #: True
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3878">#%% generator,barebones
def foo():
    yield 1
    yield 2
    yield 3
</t>
<t tx="ekr.20230509052845.3879">@path C:/Repos/codon/test/parser/
@others
try:
    f = foo()
    f(5)
except NameError:
    print('error') #: error
    # TODO: Python works here.
    # Need to capture these vars conditionally?

#%% new_scoping_loops_try,barebones
for i in range(10):
    pass
print(i) #: 9

j = 6
for j in range(0):
    pass
print(j) #: 6

for j in range(1):
    pass
print(j) #: 0

z = 6
for z in []:
    pass
print(z) #: 6

for z in [1, 2]:
    pass
print(z) #: 2

try:
    raise ValueError("hi")
except ValueError as e:
    pass
print(e.message) #: hi

try:
    pass
except ValueError as f:
    pass
try:
    print(f.message)
except NameError:
    print('error') #: error
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.388">                       bool pyNumerics = false, bool pyExtension = false)
      : km(), passes(), analyses(), executionOrder(), results(),
        disabled(std::move(disabled)), pyNumerics(pyNumerics),
        pyExtension(pyExtension) {
    registerStandardPasses(init);
  }

</t>
<t tx="ekr.20230509052845.3880">#%% none,barebones
@extend
class Optional:
    def __repr__(self):
        return 'OPTIONAL: ' + ('-' if self is None else self.__val__().__repr__())
    def __str__(self):
        return 'OPTIONAL: ' + ('-' if self is None else self.__val__().__repr__())

</t>
<t tx="ekr.20230509052845.3881">a = None
print a #: OPTIONAL: -
if True:
    a = 5
print a #: OPTIONAL: 5

#%% bool,barebones
print True, False #: True False

#%% int,barebones
print 0b0000_1111 #: 15
print 0B101 #: 5
print 3 #: 3
print 18_446_744_073_709_551_000 #: -616
print 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111 #: -1
print 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111u #: 18446744073709551615
print 18_446_744_073_709_551_000u #: 18446744073709551000
print 65i7 #: -63
print -1u7 #: 127

</t>
<t tx="ekr.20230509052845.3882">@extend
class int:
    def __suffix_test__(s):
        return 'TEST: ' + str(s)
</t>
<t tx="ekr.20230509052845.3883">print 123_456test #: TEST: 123456

#%% int_error,barebones
print 1844674407_3709551999 #! integer '18446744073709551999' cannot fit into 64-bit integer

#%% float,barebones
print 5.15 #: 5.15
print 2e2 #: 200
print 2.e-2 #: 0.02

</t>
<t tx="ekr.20230509052845.3884">#%% float_suffix,barebones
@extend
class float:
    def __suffix_zoo__(x):
        return str(x) + '_zoo'

</t>
<t tx="ekr.20230509052845.3885">print 1.2e-1zoo #: 0.12_zoo

#%% string,barebones
print 'kthxbai', "kthxbai" #: kthxbai kthxbai
print """hi
hello""", '''hai
hallo'''
#: hi
#: hello hai
#: hallo

#%% fstring,barebones
a, b = 1, 2
print f"string {a}" #: string 1
print F"{b} string" #: 2 string
print f"str {a+b} end" #: str 3 end
print f"str {a+b=}" #: str a+b=3
c = f'and this is {a} followed by {b}'
print c, f'{b}{a}', f'. {1+a=} .. {b} ...' #: and this is 1 followed by 2 21 . 1+a=2 .. 2 ...

#%% fstring_error,barebones
f"a{b + 3}}" #! single '}' is not allowed in f-string

#%% fstring_error_2,barebones
f"a{{b + 3}" #! expecting '}' in f-string

</t>
<t tx="ekr.20230509052845.3886">#%% prefix_str,barebones
@extend
class str:
    def __prefix_pfx__[N: Static[int]](s: str):
        return 'PFX ' + s
</t>
<t tx="ekr.20230509052845.3887">print pfx'HELLO' #: PFX HELLO

</t>
<t tx="ekr.20230509052845.3888">@extend
class str:
    def __prefix_pxf__(s: str, N: Static[int]):
        return 'PXF ' + s + " " + str(N)
</t>
<t tx="ekr.20230509052845.3889">print pxf'HELLO' #: PXF HELLO 5

#%% raw_str,barebones
print 'a\\b' #: a\b
print r'a\tb' #: a\tb
print R'\n\r\t\\' #: \n\r\t\\

#%% id_fstring_error,barebones
f"a{b + 3}" #! name 'b' is not defined

</t>
<t tx="ekr.20230509052845.389">  explicit PassManager(bool debug = false, std::vector&lt;std::string&gt; disabled = {},
</t>
<t tx="ekr.20230509052845.3890">#%% id_access,barebones
def foo():
    a = 5
    def bar():
        print a
    bar()  #: 5
    a = 4
    bar()  #: 5
</t>
<t tx="ekr.20230509052845.3891">foo()

z = {}
</t>
<t tx="ekr.20230509052845.3892">def fox():
    a = 5
    def goo():
        z['x'] = 'y'
        print a
    return goo
</t>
<t tx="ekr.20230509052845.3893">fox()()
print z
#: 5
#: {'x': 'y'}


#%% star_err,barebones
a = (1, 2, 3)
z = *a #! unexpected star expression

#%% list,barebones
a = [4, 5, 6]
print a #: [4, 5, 6]
b = [1, 2, 3, *a]
print b #: [1, 2, 3, 4, 5, 6]

#%% set,barebones
gs = {1.12}
print gs #: {1.12}
fs = {1, 2, 3, 1, 2, 3}
gs.add(1.12)
gs.add(1.13)
print fs, gs #: {1, 2, 3} {1.12, 1.13}
print {*fs, 5, *fs} #: {1, 2, 3, 5}

#%% dict,barebones
gd = {1: 'jedan', 2: 'dva', 2: 'two', 3: 'tri'}
fd = {}
fd['jedan'] = 1
fd['dva'] = 2
print gd, fd #: {1: 'jedan', 2: 'two', 3: 'tri'} {'jedan': 1, 'dva': 2}

#%% comprehension,barebones
l = [(i, j, f'i{i}/{j}')
     for i in range(50) if i % 2 == 0 if i % 3 == 0
     for j in range(2) if j == 1]
print l #: [(0, 1, 'i0/1'), (6, 1, 'i6/1'), (12, 1, 'i12/1'), (18, 1, 'i18/1'), (24, 1, 'i24/1'), (30, 1, 'i30/1'), (36, 1, 'i36/1'), (42, 1, 'i42/1'), (48, 1, 'i48/1')]

s = {i%3 for i in range(20)}
print s #: {0, 1, 2}

d = {i: j for i in range(10) if i &lt; 1 for j in range(10)}
print d  #: {0: 9}

x = {t: lambda x: x * t for t in range(5)}
print(x[3](10))  #: 30

</t>
<t tx="ekr.20230509052845.3894">#%% comprehension_opt,barebones
@extend
class List:
    def __init__(self, cap: int):
        print 'optimize', cap
        self.arr = Array[T](cap)
        self.len = 0
</t>
<t tx="ekr.20230509052845.3895">def foo():
    yield 0
    yield 1
    yield 2
</t>
<t tx="ekr.20230509052845.3896">print [i for i in range(3)] #: optimize 3
#: [0, 1, 2]
print [i for i in foo()] #: [0, 1, 2]
print [i for i in range(3) if i%2 == 0] #: [0, 2]
print [i + j for i in range(1) for j in range(1)] #: [0]
print {i for i in range(3)} #: {0, 1, 2}

#%% generator,barebones
z = 3
g = (e for e in range(20) if e % z == 1)
print str(g)[:13] #: &lt;generator at
print list(g) #: [1, 4, 7, 10, 13, 16, 19]

g1 = (a for a in range(3))
print list(g1) #: [0, 1, 2]
g2 = (a for a in range(z + 1))
print list(g2) #: [0, 1, 2, 3]

</t>
<t tx="ekr.20230509052845.3897">def nest(z):
    g1 = (a for a in range(3))
    print list(g1) #: [0, 1, 2]
    g2 = (a for a in range(z + 1))
    print list(g2) #: [0, 1, 2, 3, 4]
</t>
<t tx="ekr.20230509052845.3898">nest(4)

#%% cond,barebones
a = 5
print (1 &lt;= a &lt;= 10), (1 &gt;= a &gt;= -5) #: True False

#%% if,barebones
c = 5
a = 1 if c &lt; 5 else 2
b = -(1 if c else 2)
print a, b #: 2 -1

#%% unary,barebones
a, b = False, 1
print not a, not b, ~b, +b, -b, -(+(-b)) #: True False -2 1 -1 1

#%% binary,barebones
x, y = 1, 0
c = [1, 2, 3]

print x and y, x or y #: False True
print x in c, x not in c #: True False
print c is c, c is not c #: True False

z: Optional[int] = None
print z is None, None is z, None is not z, None is None #: True True False True

</t>
<t tx="ekr.20230509052845.3899">#%% chain_binary,barebones
def foo():
    print 'foo'
    return 15
</t>
<t tx="ekr.20230509052845.39">def transform_point(self, point):
    x = (point.x - self.minx) / self.width
    y = (point.y - self.miny) / self.height
    #if trafo is None:
    trafo = self.get_random_trafo()
    start, end = self.splines[trafo[0]].GetDomain()
    length = end - start
    seg_length = length / self.num_trafos[trafo[0]]
    t = start + seg_length * trafo[1] + seg_length * x
    basepoint = self.splines[trafo[0]](t)
    if t + 1 / 50000 &gt; end:
        neighbour = self.splines[trafo[0]](t - 1 / 50000)
        derivative = neighbour - basepoint
    else:
        neighbour = self.splines[trafo[0]](t + 1 / 50000)
        derivative = basepoint - neighbour
    if derivative.Mag() != 0:
        basepoint.x += derivative.y / derivative.Mag() * (y - 0.5) * \
            self.thickness
        basepoint.y += -derivative.x / derivative.Mag() * (y - 0.5) * \
            self.thickness
    else:
        print("r", end='')
    self.truncate(basepoint)
    return basepoint

</t>
<t tx="ekr.20230509052845.390">                       bool pyNumerics = false, bool pyExtension = false)
      : PassManager(debug ? Init::DEBUG : Init::RELEASE, std::move(disabled),
                    pyNumerics, pyExtension) {}

    @others
</t>
<t tx="ekr.20230509052845.3900">a = b = c = foo() #: foo
print a, b, c #: 15 15 15

x = y = []
x.append(1)
print x, y #: [1] [1]

print 1 &lt;= foo() &lt;= 10 #: foo
#: False
print 15 &gt;= foo()+1 &lt; 30 &gt; 20 &gt; foo()
#: foo
#: False
print 15 &gt;= foo()-1 &lt; 30 &gt; 20 &gt; foo()
#: foo
#: foo
#: True

print True == (b == 15) #: True

</t>
<t tx="ekr.20230509052845.3901">#%% pipe_error,barebones
def b(a, b, c, d):
    pass
</t>
<t tx="ekr.20230509052845.3902">1 |&gt; b(1, ..., 2, ...)  #! multiple ellipsis expressions

#%% index_normal,barebones
t: tuple[int, int] = (1, 2)
print t #: (1, 2)

tt: Tuple[int] = (1, )
print tt #: (1)

</t>
<t tx="ekr.20230509052845.3903">def foo(i: int) -&gt; int:
    return i + 1
</t>
<t tx="ekr.20230509052845.3904">f: Callable[[int], int] = foo
print f(1) #: 2
fx: function[[int], int] = foo
print fx(2) #: 3
fxx: Function[[int], int] = foo
print fxx(3) #: 4

</t>
<t tx="ekr.20230509052845.3905">#%% index_special,barebones
class Foo:
    def __getitem__(self, foo):
        print foo
</t>
<t tx="ekr.20230509052845.3906">f = Foo()
f[0,0] #: (0, 0)
f[0,:] #: (0, slice(None, None, None))
f[:,:] #: (slice(None, None, None), slice(None, None, None))
f[:,0] #: (slice(None, None, None), 0)

#%% index_error,barebones
Ptr[9.99] #! expected type expression

#%% index_error_b,barebones
Ptr['s'] #! ''s'' does not match expected type 'T'

#%% index_error_static,barebones
Ptr[1] #! '1' does not match expected type 'T'

#%% index_error_2,barebones
Ptr[int, 's'] #! Ptr takes 1 generics (2 given)

#%% index_error_3,barebones
Ptr[1, 's'] #! Ptr takes 1 generics (2 given)

#%% call_ptr,barebones
v = 5
p = __ptr__(v)
print p[0] #: 5

#%% call_ptr_error,barebones
__ptr__(1) #! __ptr__() only takes identifiers as arguments

#%% call_ptr_error_3,barebones
v = 1
__ptr__(v, 1) #! __ptr__() takes 1 arguments (2 given)

#%% call_array,barebones
a = __array__[int](2)
a[0] = a[1] = 5
print a[0], a[1] #: 5 5

#%% call_array_error,barebones
a = __array__[int](2, 3) #! '__array__[int]' object has no method '__new__' with arguments (int, int)

#%% call_err_1,barebones
seq_print(1, name="56", 2) #! positional argument follows keyword argument

#%% call_err_2,barebones
x = (1, 2)
seq_print(1, name=*x) #! syntax error, unexpected '*'

#%% call_err_3,barebones
x = (1, 2)
seq_print(1, name=**x) #! syntax error, unexpected '*'

#%% call_collections
from collections import namedtuple as nt

ee = nt('Foo', ['x', 'y'])
f = ee(1, 2)
print f #: (x: 1, y: 2)

ee = nt('FooX', [('x', str), 'y'])
fd = ee('s', 2)
print fd #: (x: 's', y: 2)

#%% call_partial_functools
from functools import partial
</t>
<t tx="ekr.20230509052845.3907">def foo(x, y, z):
    print x,y,z
</t>
<t tx="ekr.20230509052845.3908">f1 = partial(foo, 1, z=3)
f1(2) #: 1 2 3
f2 = partial(foo, y=2)
f2(1, 2) #: 1 2 2

#%% ellipsis_err,barebones
... #! unexpected ellipsis expression

#%% lambda,barebones
l = lambda a, b: a + b
print l(1, 2) #: 3

e = 5
lp = lambda x: x + e
print lp(1) #: 6

e = 7
print lp(2) #: 9

</t>
<t tx="ekr.20230509052845.3909">def foo[T](a: T, l: Callable[[T], T]):
    return l(a)
</t>
<t tx="ekr.20230509052845.391">/// Checks if the given pass is included in this manager.
/// @param key the pass key
/// @return true if manager has the given pass
bool hasPass(const std::string &amp;key) {
for (auto &amp;pair : passes) {
  if (pair.first == key)
    return true;
}
return false;
}

</t>
<t tx="ekr.20230509052845.3910">print foo(4, lp) #: 11

</t>
<t tx="ekr.20230509052845.3911">def foox(a, l):
    return l(a)
</t>
<t tx="ekr.20230509052845.3912">print foox(4, lp) #: 11

</t>
<t tx="ekr.20230509052845.3913">#%% nested_lambda,barebones
def foo():
    print list(a*a for a in range(3))
</t>
<t tx="ekr.20230509052845.3914">foo()  #: [0, 1, 4]

</t>
<t tx="ekr.20230509052845.3915">#%% walrus,barebones
def foo(x):
    return x * x
</t>
<t tx="ekr.20230509052845.3916">if x := foo(4):
    pass
if (x := foo(4)) and False:
    print 'Nope'
print x #: 16

a = [y := foo(1), y+1, y+2]
print a #: [1, 2, 3]

print {y: b for y in [1,2,3] if (b := (y - 1))} #: {2: 1, 3: 2}
print list(b for y in [1,2,3] if (b := (y // 3))) #: [1]

</t>
<t tx="ekr.20230509052845.3917">#%% walrus_update,barebones
def foo(x):
    return x * x
</t>
<t tx="ekr.20230509052845.3918">x = 5
if x := foo(4):
    pass
print x #: 16

</t>
<t tx="ekr.20230509052845.3919">#%% walrus_cond_1,barebones
def foo(x):
    return x * x
</t>
<t tx="ekr.20230509052845.392">  /// Checks if the given analysis is included in this manager.
  /// @param key the analysis key
  /// @return true if manager has the given analysis
  bool hasAnalysis(const std::string &amp;key) {
    for (auto &amp;pair : analyses) {
      if (pair.first == key)
        return true;
    }
    return false;
  }

</t>
<t tx="ekr.20230509052845.3920">if False or (x := foo(4)):
    pass
print(x) #: 16

y = (z := foo(5)) if True else 0
print(z) #: 25

</t>
<t tx="ekr.20230509052845.3921">#%% walrus_err,barebones
def foo(x):
    return x * x
</t>
<t tx="ekr.20230509052845.3922">if False and (x := foo(4)):
    pass
try:
    print(x)
except NameError:
    print("Error") #: Error

t = True
y = 0 if t else (z := foo(4))
try:
    print(z)
except NameError:
    print("Error") #: Error

#%% range_err,barebones
1 ... 3 #! unexpected range expression

</t>
<t tx="ekr.20230509052845.3923">#%% callable_error,barebones
def foo(x: Callable[[]]): pass  #! Callable takes 2 generics (1 given)

</t>
<t tx="ekr.20230509052845.3924">#%% unpack_specials,barebones
x, = 1,
print x  #: 1

a = (2, 3)
b = (1, *a[1:])
print a, b  #: (2, 3) (1, 3)

</t>
<t tx="ekr.20230509052845.3925">#%% nonlocal,barebones
def goo(ww):
  z = 0
  @others
  b = foo(10)
  print('goo', z)
  return b
</t>
<t tx="ekr.20230509052845.3926">def foo(x):
  f = 10
  def bar(y):
    nonlocal z
    f = x + y
    z += y
    print('goo.foo.bar', f, z)
  bar(5)
  print('goo.foo', f)
  return bar
</t>
<t tx="ekr.20230509052845.3927">b = goo('s')
# goo.foo.bar 15 5
# goo.foo 10
# goo 5
b(11)
# goo.foo.bar 21 16
b(12)
# goo.foo.bar 22 28
b = goo(1)  # test another instantiation
# goo.foo.bar 15 5
# goo.foo 10
# goo 5
b(11)
# goo.foo.bar 21 16
b(13)
# goo.foo.bar 23 29

</t>
<t tx="ekr.20230509052845.3928">#%% nonlocal_error,barebones
def goo():
  z = 0
  def foo():
    z += 1
</t>
<t tx="ekr.20230509052845.3929">goo()  #! local variable 'z' referenced before assignment

#%% new_scoping,barebones
try:
    if True and (x := (True or (y := 1 + 2))):
        pass
    try:
        print(x)  #: True
        print(y)
    except NameError:
        print("Error")  #: Error
    print(x) #: True
    if len("s") &gt; 0:
        print(x)  #: True
        print(y)
    print(y)  # TODO: test for __used__ usage
    print(y)  # (right now manual inspection is needed)
except NameError as e:
    print(e.message)  #: variable 'y' not yet defined

t = True
y = 0 if t else (xx := 1)
try:
    print(xx)
except NameError:
    print("Error")  #: Error

</t>
<t tx="ekr.20230509052845.393">  /// Registers a pass and appends it to the execution order.
  /// @param pass the pass
  /// @param insertBefore insert pass before the pass with this given key
  /// @param reqs keys of passes that must be run before the current one
  /// @param invalidates keys of passes that are invalidated by the current one
  /// @return unique'd key for the added pass, or empty string if not added
  std::string registerPass(std::unique_ptr&lt;Pass&gt; pass,
                           const std::string &amp;insertBefore = "",
                           std::vector&lt;std::string&gt; reqs = {},
                           std::vector&lt;std::string&gt; invalidates = {});

  /// Registers an analysis.
  /// @param analysis the analysis
  /// @param reqs keys of analyses that must be run before the current one
  /// @return unique'd key for the added analysis, or empty string if not added
  std::string registerAnalysis(std::unique_ptr&lt;analyze::Analysis&gt; analysis,
                               std::vector&lt;std::string&gt; reqs = {});

  /// Run all passes.
  /// @param module the module
  void run(Module *module);

  /// Gets the result of a given analysis.
  /// @param key the (unique'd) analysis key
  /// @return the result
  analyze::Result *getAnalysisResult(const std::string &amp;key) {
    auto it = results.find(key);
    return it != results.end() ? it-&gt;second.get() : nullptr;
  }

</t>
<t tx="ekr.20230509052845.3930">#%% new_scoping_weird,barebones
def foo():
    if len("s") == 3:
        x = 3
    def bar(y):
        print(x+y)
    x=5
    return bar
</t>
<t tx="ekr.20230509052845.3931">@path C:/Repos/codon/test/parser/
#%% bool,barebones
a = True
print a.__class__.__name__ #: bool

#%% int,barebones
i = 15
print i.__class__.__name__ #: int

#%% float,barebones
a = 1.11
print a.__class__.__name__ #: float

#%% str,barebones
a = 'hi'
print a.__class__.__name__ #: str

#%% none_unbound,barebones
a = None

#%% list_unbound,barebones
a = []
#! cannot typecheck the program


@others
a = A()
#! no super methods found
#! during the realization of __init__(self: A)

#%% super_error_2,barebones
super().foo(1) #! no super methods found
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3932">#%% id_static,barebones
def foo[N: Static[int]]():
    print N
</t>
<t tx="ekr.20230509052845.3933">foo(5) #: 5

</t>
<t tx="ekr.20230509052845.3934">def fox(N: Static[int]):
    print N
</t>
<t tx="ekr.20230509052845.3935">fox(6) #: 6

#%% if,barebones
y = 1 if True else 2
print y.__class__.__name__ #: int

a = None
b = 5
z = a if bool(True) else b # needs bool to prevent static evaluation
print z, z.__class__.__name__ #: None Optional[int]

zz = 1.11 if True else None
print zz, zz.__class__.__name__ #: 1.11 float

</t>
<t tx="ekr.20230509052845.3936">#%% binary,barebones
@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.3937">def __add__(self, i: int): print 'add'; return 0
</t>
<t tx="ekr.20230509052845.3938">def __sub__(self, i: int): print 'sub'; return 0
</t>
<t tx="ekr.20230509052845.3939">def __mul__(self, i: int): print 'mul'; return 0
</t>
<t tx="ekr.20230509052845.394">  /// Returns whether a given pass or analysis is disabled.
  /// @param key the (unique'd) pass or analysis key
  /// @return true if the pass or analysis is disabled
  bool isDisabled(const std::string &amp;key) {
    return std::find(disabled.begin(), disabled.end(), key) != disabled.end();
  }

</t>
<t tx="ekr.20230509052845.3940">def __pow__(self, i: int): print 'pow'; return 0
</t>
<t tx="ekr.20230509052845.3941">def __truediv__(self, i: int): print 'truediv'; return 0
</t>
<t tx="ekr.20230509052845.3942">def __floordiv__(self, i: int): print 'div'; return 0
</t>
<t tx="ekr.20230509052845.3943">def __matmul__(self, i: int): print 'matmul'; return 0
</t>
<t tx="ekr.20230509052845.3944">def __mod__(self, i: int): print 'mod'; return 0
</t>
<t tx="ekr.20230509052845.3945">def __lt__(self, i: int): print 'lt'; return 0
</t>
<t tx="ekr.20230509052845.3946">def __le__(self, i: int): print 'le'; return 0
</t>
<t tx="ekr.20230509052845.3947">def __gt__(self, i: int): print 'gt'; return 0
</t>
<t tx="ekr.20230509052845.3948">def __ge__(self, i: int): print 'ge'; return 0
</t>
<t tx="ekr.20230509052845.3949">def __eq__(self, i: int): print 'eq'; return 0
</t>
<t tx="ekr.20230509052845.395">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/module.h"
#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {

namespace analyze {
struct Result;
}

namespace transform {

class PassManager;

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.3950">def __ne__(self, i: int): print 'ne'; return 0
</t>
<t tx="ekr.20230509052845.3951">def __lshift__(self, i: int): print 'lshift'; return 0
</t>
<t tx="ekr.20230509052845.3952">def __rshift__(self, i: int): print 'rshift'; return 0
</t>
<t tx="ekr.20230509052845.3953">def __and__(self, i: int): print 'and'; return 0
</t>
<t tx="ekr.20230509052845.3954">def __or__(self, i: int): print 'or'; return 0
</t>
<t tx="ekr.20230509052845.3955">def __xor__(self, i: int): print 'xor'; return 0
</t>
<t tx="ekr.20230509052845.3956"># double assignment to disable propagation
def f(x): return x
</t>
<t tx="ekr.20230509052845.3957">a = f(1.0)
a = f(5.0)
a + f(1) #: add
# wrap in function to disable canonicalization
a - f(1) #: sub
a * f(2) #: mul
a ** f(2) #: pow
a // f(2) #: div
a / f(2) #: truediv
a @ f(1) #: matmul
a % f(1) #: mod
a &lt; f(1) #: lt
a &lt;= f(1) #: le
a &gt; f(1) #: gt
a &gt;= f(1) #: ge
a == f(1) #: eq
a != f(1) #: ne
a &lt;&lt; f(1) #: lshift
a &gt;&gt; f(1) #: rshift
a &amp; f(1) #: and
a | f(1) #: or
a ^ f(1) #: xor

</t>
<t tx="ekr.20230509052845.3958">#%% binary_rmagic,barebones
class Foo[T]:
    def __add__(self, other: T):
        print 'add'
        return self
    def __radd__(self, other: T):
        print 'radd'
        return self
</t>
<t tx="ekr.20230509052845.3959">foo = Foo[int]()
foo + 1 #: add
1 + foo #: radd

</t>
<t tx="ekr.20230509052845.396">/// General pass base class.
class Pass {
private:
  PassManager *manager = nullptr;

public:
  virtual ~Pass() noexcept = default;

  /// @return a unique key for this pass
  virtual std::string getKey() const = 0;

  /// Execute the pass.
  /// @param module the module
  virtual void run(Module *module) = 0;

  /// Determine if pass should repeat.
  /// @param num how many times this pass has already run
  /// @return true if pass should repeat
  virtual bool shouldRepeat(int num) const { return false; }

  /// Sets the manager.
  /// @param mng the new manager
  virtual void setManager(PassManager *mng) { manager = mng; }
@others
private:
  analyze::Result *doGetAnalysis(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509052845.3960">#%% binary_short_circuit,barebones
def moo():
    print 'moo'
    return True
</t>
<t tx="ekr.20230509052845.3961">print True or moo() #: True
print moo() or True #: moo
#: True
print False and moo() #: False
print moo() and False #: moo
#: False

#%% binary_is,barebones
print 5 is None #: False
print None is None #: True
print (None if bool(True) else 1) is None #: True
print (None if bool(False) else 1) is None #: False

print 5 is 5.0 #: False
print 5 is 6 #: False
print 5 is 5 #: True
print 5 is 1.12 #: False
</t>
<t tx="ekr.20230509052845.3962">class Foo:
    a: int
</t>
<t tx="ekr.20230509052845.3963">x = Foo(1)
y = Foo(1)
z = x
print x is x, x is y, x is z, z is x, z is y #: True False True True False

a, b, c, d = Optional(5), Optional[int](), Optional(5), Optional(4)
print a is a, a is b, b is b, a is c, a is d #: True False True True False
aa, bb, cc, dd = Optional(Foo(1)), Optional[Foo](), Optional(Foo(1)), Optional(Foo(2))
print aa is aa, aa is bb, bb is bb, aa is cc, aa is dd #: True False True False False


</t>
<t tx="ekr.20230509052845.3964">#%% pipe,barebones
def foo(a, b):
    return a+b
</t>
<t tx="ekr.20230509052845.3965">bar = lambda c, d: c+d
</t>
<t tx="ekr.20230509052845.3966">def hai(e):
    while e &gt; 0:
        yield e
        e -= 2
</t>
<t tx="ekr.20230509052845.3967">def echo(s):
    print s
</t>
<t tx="ekr.20230509052845.3968">foo(1,2) |&gt; bar(4) |&gt; echo  #: 7
foo(1,2) |&gt; bar(4) |&gt; hai |&gt; echo
#: 7
#: 5
#: 3
#: 1

</t>
<t tx="ekr.20230509052845.3969">#%% pipe_prepend,barebones
def foo(a: Optional[int]):
    print a
    return 1
</t>
<t tx="ekr.20230509052845.397">  /// Returns the result of a given analysis.
  /// @param key the analysis key
  /// @return the analysis result
  template &lt;typename AnalysisType&gt;
  AnalysisType *getAnalysisResult(const std::string &amp;key) {
    return static_cast&lt;AnalysisType *&gt;(doGetAnalysis(key));
  }

</t>
<t tx="ekr.20230509052845.3970">5 |&gt; foo #: 5
None |&gt; foo #: None
print (None |&gt; foo).__class__.__name__ #: int

</t>
<t tx="ekr.20230509052845.3971">def foo2(a: int):
    print a
    return 1
</t>
<t tx="ekr.20230509052845.3972">Optional(5) |&gt; foo2 #: 5
try:
    Optional[int]() |&gt; foo2
except ValueError as e:
    print e.message #: optional is None

</t>
<t tx="ekr.20230509052845.3973">#%% pipe_prepend_error,barebones
def foo2(a: int):
    print a
    return 1
</t>
<t tx="ekr.20230509052845.3974">try:
    None |&gt; foo2
except ValueError:
    print 'exception' #: exception
# Explanation: None can also be Optional[Generator[int]]
# We cannot decide if this is a generator to be unrolled in a pipe,
# or just an argument to be passed to a function.
# So this will default to NoneType at the end.

</t>
<t tx="ekr.20230509052845.3975">#%% instantiate_err,barebones
def foo[N]():
    return N()
</t>
<t tx="ekr.20230509052845.3976">foo(int, float)  #! foo() takes 1 arguments (2 given)

</t>
<t tx="ekr.20230509052845.3977">#%% instantiate_err_2,barebones
def foo[N, T]():
    return N()
</t>
<t tx="ekr.20230509052845.3978">foo(int)  #! generic 'T' not provided

#%% instantiate_err_3,barebones
Ptr[int, float]()  #! Ptr takes 1 generics (2 given)

#%% slice,barebones
z = [1, 2, 3, 4, 5]
y = (1, 'foo', True)
print z[2], y[1]  #: 3 foo
print z[:1], z[1:], z[1:3], z[:4:2], z[::-1]  #: [1] [2, 3, 4, 5] [2, 3] [1, 3] [5, 4, 3, 2, 1]

#%% static_index,barebones
a = (1, '2s', 3.3)
print a[1] #: 2s
print a[0:2], a[:2], a[1:] #: (1, '2s') (1, '2s') ('2s', 3.3)
print a[0:3:2], a[-1:] #: (1, 3.3) (3.3)

</t>
<t tx="ekr.20230509052845.3979">#%% static_index_side,barebones
def foo(a):
    print(a)
    return a

</t>
<t tx="ekr.20230509052845.398">class PassGroup : public Pass {
private:
  int repeat;
  std::vector&lt;std::unique_ptr&lt;Pass&gt;&gt; passes;

public:
  explicit PassGroup(int repeat = 0, std::vector&lt;std::unique_ptr&lt;Pass&gt;&gt; passes = {})
      : Pass(), repeat(repeat), passes(std::move(passes)) {}

  virtual ~PassGroup() noexcept = default;

  void push_back(std::unique_ptr&lt;Pass&gt; p) { passes.push_back(std::move(p)); }

  /// @return default number of times pass should repeat
  int getRepeat() const { return repeat; }

  /// Sets the default number of times pass should repeat.
  /// @param r number of repeats
  void setRepeat(int r) { repeat = r; }

  bool shouldRepeat(int num) const override { return num &lt; repeat; }

  void run(Module *module) override;

  void setManager(PassManager *mng) override;
};

</t>
<t tx="ekr.20230509052845.3980">print (foo(2), foo(1))[::-1]
#: 2
#: 1
#: (1, 2)
print (foo(1), foo(2), foo(3), foo(4))[2]
#: 1
#: 2
#: 3
#: 4
#: 3

#%% static_index_lenient,barebones
a = (1, 2)
print a[3:5] #: ()

#%% static_index_err,barebones
a = (1, 2)
a[5] #! tuple index out of range (expected 0..1, got instead 5)

#%% static_index_err_2,barebones
a = (1, 2)
a[-3] #! tuple index out of range (expected 0..1, got instead -1)

</t>
<t tx="ekr.20230509052845.3981">#%% index_func_instantiate,barebones
class X:
    def foo[T](self, x: T):
        print x.__class__.__name__, x
</t>
<t tx="ekr.20230509052845.3982">x = X()
x.foo(5, int) #: int 5

#%% index,barebones
l = [1, 2, 3]
print l[2] #: 3

#%% index_two_rounds,barebones
l = []
print l[::-1] #: []
l.append(('str', 1, True, 5.15))
print l, l.__class__.__name__ #: [('str', 1, True, 5.15)] List[Tuple[str,int,bool,float]]

#%% dot_case_1,barebones
a = []
print a[0].loop()  #! 'int' object has no attribute 'loop'
a.append(5)

#%% dot_case_2,barebones
a = Optional(0)
print a.__bool__() #: False
print a.__add__(1) #: 1

#%% dot_case_4,barebones
a = [5]
print a.len #: 1

#%% dot_case_4_err,barebones
a = [5]
a.foo #! 'List[int]' object has no attribute 'foo'

</t>
<t tx="ekr.20230509052845.3983">#%% dot_case_6,barebones
# Did heavy changes to this testcase because
# of the automatic optional wraps/unwraps and promotions
class Foo:
    @others
</t>
<t tx="ekr.20230509052845.3984">def bar(self, a):
    print 'generic', a, a.__class__.__name__
</t>
<t tx="ekr.20230509052845.3985">def bar(self, a: Optional[float]):
    print 'optional', a
</t>
<t tx="ekr.20230509052845.3986">def bar(self, a: int):
    print 'normal', a
</t>
<t tx="ekr.20230509052845.3987">f = Foo()
f.bar(1) #: normal 1
f.bar(1.1) #: optional 1.1
f.bar(Optional('s')) #: generic s Optional[str]
f.bar('hehe') #: generic hehe str


</t>
<t tx="ekr.20230509052845.3988">#%% dot_case_6b,barebones
class Foo:
    def bar(self, a, b):
        print '1', a, b
    def bar(self, a, b: str):
        print '2', a, b
    def bar(self, a: str, b):
        print '3', a, b
</t>
<t tx="ekr.20230509052845.3989">f = Foo()
# Take the newest highest scoring method
f.bar('s', 't') #: 3 s t
f.bar(1, 't') #: 2 1 t
f.bar('s', 1) #: 3 s 1
f.bar(1, 2) #: 1 1 2

</t>
<t tx="ekr.20230509052845.399">/// Pass that runs a single Operator.
class OperatorPass : public Pass, public util::Operator {
public:
  /// Constructs an operator pass.
  /// @param childrenFirst true if children should be iterated first
  explicit OperatorPass(bool childrenFirst = false) : util::Operator(childrenFirst) {}

@others
};

</t>
<t tx="ekr.20230509052845.3990">#%% dot,barebones
class Foo:
    def clsmethod():
        print 'foo'
    def method(self, a):
        print a
</t>
<t tx="ekr.20230509052845.3991">Foo.clsmethod() #: foo
Foo.method(Foo(), 1) #: 1
m1 = Foo.method
m1(Foo(), 's') #: s
m2 = Foo().method
m2(1.1) #: 1.1

</t>
<t tx="ekr.20230509052845.3992">#%% dot_error_static,barebones
class Foo:
    def clsmethod():
        print 'foo'
    def method(self, a):
        print a
</t>
<t tx="ekr.20230509052845.3993">Foo().clsmethod() #! 'Foo' object has no method 'clsmethod' with arguments (Foo)

</t>
<t tx="ekr.20230509052845.3994">#%% call,barebones
def foo(a, b, c='hi'):
    print 'foo', a, b, c
    return 1
</t>
<t tx="ekr.20230509052845.3995">class Foo:
    @others
</t>
<t tx="ekr.20230509052845.3996">def __init__(self):
    print 'Foo.__init__'
</t>
<t tx="ekr.20230509052845.3997">def foo(self, a):
    print 'Foo.foo', a
    return 's'
</t>
<t tx="ekr.20230509052845.3998">def bar[T](self, a: T):
    print 'Foo.bar', a
    return a.__class__.__name__
</t>
<t tx="ekr.20230509052845.3999">def __call__(self, y):
    print 'Foo.__call__'
    return foo(2, y)

</t>
<t tx="ekr.20230509052845.4">@path C:/Repos/codon/bench/binary_trees/
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# contributed by Antoine Pitrou
# modified by Dominique Wahli and Daniel Nanz
# modified by Joerg Baumann
# modified by @arshajii for Codon

import sys
import time

@others
t0 = time.time()
main(int(sys.argv[1]))
t1 = time.time()
print(t1 - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.40">def truncate(self, point):
    if point.x &gt;= self.maxx:
        point.x = self.maxx
    if point.y &gt;= self.maxy:
        point.y = self.maxy
    if point.x &lt; self.minx:
        point.x = self.minx
    if point.y &lt; self.miny:
        point.y = self.miny

</t>
<t tx="ekr.20230509052845.400">  void run(Module *module) override {
    reset();
    process(module);
  }
</t>
<t tx="ekr.20230509052845.4000">foo(1, 2.2, True) #: foo 1 2.2 True
foo(1, 2.2) #: foo 1 2.2 hi
foo(b=2.2, a=1) #: foo 1 2.2 hi
foo(b=2.2, c=12u, a=1) #: foo 1 2.2 12

f = Foo() #: Foo.__init__
print f.foo(a=5) #: Foo.foo 5
#: s
print f.bar(a=1, T=int) #: Foo.bar 1
#: int
print Foo.bar(Foo(), 1.1, T=float) #: Foo.__init__
#: Foo.bar 1.1
#: float
print Foo.bar(Foo(), 's') #: Foo.__init__
#: Foo.bar s
#: str
print f('hahaha') #: Foo.__call__
#: foo 2 hahaha hi
#: 1

</t>
<t tx="ekr.20230509052845.4001">@tuple
class Moo:
    moo: int
    def __new__(i: int) -&gt; Moo:
        print 'Moo.__new__'
        return (i,)
</t>
<t tx="ekr.20230509052845.4002">print Moo(1) #: Moo.__new__
#: (moo: 1)

</t>
<t tx="ekr.20230509052845.4003">#%% call_err_2,barebones
class A:
    a: A
</t>
<t tx="ekr.20230509052845.4004">a = A() #! argument 'a' has recursive default value

</t>
<t tx="ekr.20230509052845.4005">#%% call_err_3,barebones
class G[T]:
    t: T
</t>
<t tx="ekr.20230509052845.4006">class A:
    ga: G[A]
</t>
<t tx="ekr.20230509052845.4007">a = A() #! argument 'ga' has recursive default value

#%% call_err_4,barebones
seq_print_full(1, name="56", name=2) #! keyword argument repeated: name

</t>
<t tx="ekr.20230509052845.4008">#%% call_partial,barebones
def foo(i, j, k):
    return i + j + k
</t>
<t tx="ekr.20230509052845.4009">print foo(1.1, 2.2, 3.3)  #: 6.6
p = foo(6, ...)
print p.__class__.__name__ #: foo[int,...,...]
print p(2, 1)  #: 9
print p(k=3, j=6) #: 15
q = p(k=1, ...)
print q(3)  #: 10
qq = q(2, ...)
print qq()  #: 9
#
add_two = foo(3, k=-1, ...)
print add_two(42)  #: 44
print 3 |&gt; foo(1, 2)  #: 6
print 42 |&gt; add_two  #: 44
</t>
<t tx="ekr.20230509052845.401">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"
#include "codon/cir/util/visitor.h"

namespace codon {
namespace ir {
namespace transform {

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4010">#
def moo(a, b, c=3):
    print a, b, c
</t>
<t tx="ekr.20230509052845.4011">m = moo(b=2, ...)
print m.__class__.__name__ #: moo[...,int,...]
m('s', 1.1) #: s 2 1.1
# #
n = m(c=2.2, ...)
print n.__class__.__name__ #: moo[...,int,float]
n('x') #: x 2 2.2
print n('y').__class__.__name__ #: NoneType

</t>
<t tx="ekr.20230509052845.4012">def ff(a, b, c):
    return a, b, c
</t>
<t tx="ekr.20230509052845.4013">print ff(1.1, 2, True).__class__.__name__ #: Tuple[float,int,bool]
print ff(1.1, ...)(2, True).__class__.__name__ #: Tuple[float,int,bool]
y = ff(1.1, ...)(c=True, ...)
print y.__class__.__name__ #: ff[float,...,bool]
print ff(1.1, ...)(2, ...)(True).__class__.__name__ #: Tuple[float,int,bool]
print y('hei').__class__.__name__ #: Tuple[float,str,bool]
z = ff(1.1, ...)(c='s', ...)
print z.__class__.__name__ #: ff[float,...,str]

</t>
<t tx="ekr.20230509052845.4014">def fx(*args, **kw):
    print(args, kw)
</t>
<t tx="ekr.20230509052845.4015">f1 = fx(1, x=1, ...)
f2 = f1(2, y=2, ...)
f3 = f2(3, z=3, ...)
f3()
#: (1, 2, 3) (x: 1, y: 2, z: 3)

</t>
<t tx="ekr.20230509052845.4016">#%% call_arguments_partial,barebones
def doo[R, T](a: Callable[[T], R], b: Generator[T], c: Optional[T], d: T):
    print R.__class__.__name__, T.__class__.__name__
    print a.__class__.__name__[:8], b.__class__.__name__
    for i in b:
        print a(i)
    print c, c.__class__.__name__
    print d, d.__class__.__name__

</t>
<t tx="ekr.20230509052845.4017">l = [1, 2, 3]
doo(b=l, d=Optional(5), c=l[0], a=lambda x: x+1)
#: int int
#: ._lambda Generator[int]
#: 2
#: 3
#: 4
#: 1 Optional[int]
#: 5 int

l = [1]
</t>
<t tx="ekr.20230509052845.4018">def adder(a, b): return a+b
</t>
<t tx="ekr.20230509052845.4019">doo(b=l, d=Optional(5), c=l[0], a=adder(b=4, ...))
#: int int
#: adder[.. Generator[int]
#: 5
#: 1 Optional[int]
#: 5 int

</t>
<t tx="ekr.20230509052845.402">/// Base for rewrite rules.
class RewriteRule : public util::Visitor {
private:
  Value *result = nullptr;

protected:
  void defaultVisit(Node *) override {}
  void setResult(Value *r) { result = r; }
  void resetResult() { setResult(nullptr); }
  Value *getResult() const { return result; }

public:
  virtual ~RewriteRule() noexcept = default;

  /// Apply the rule.
  /// @param v the value to rewrite
  /// @return nullptr if no rewrite, the replacement otherwise
  Value *apply(Value *v) {
    v-&gt;accept(*this);
    auto *replacement = getResult();
    resetResult();
    return replacement;
  }
};

</t>
<t tx="ekr.20230509052845.4020">#%% call_partial_star,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
</t>
<t tx="ekr.20230509052845.4021">p = foo(...)
p(1, z=5) #: 1 () (z: 5)
p('s', zh=65) #: s () (zh: 65)
q = p(zh=43, ...)
q(1) #: 1 () (zh: 43)
r = q(5, 38, ...)
r() #: 5 (38) (zh: 43)
r(1, a=1) #: 5 (38, 1) (zh: 43, a: 1)

</t>
<t tx="ekr.20230509052845.4022">#%% call_args_kwargs_type,barebones
def foo(*args: float, **kwargs: int):
    print(args, kwargs, args.__class__.__name__)

</t>
<t tx="ekr.20230509052845.4023">foo(1, f=1)  #: (1) (f: 1) Tuple[float]
foo(1, 2.1, 3, z=2)  #: (1, 2.1, 3) (z: 2) Tuple[float,float,float]

</t>
<t tx="ekr.20230509052845.4024">def sum(x: Generator[int]):
    a = 0
    for i in x:
        a += i
    return a

</t>
<t tx="ekr.20230509052845.4025">def sum_gens(*x: Generator[int]) -&gt; int:
    a = 0
    for i in x:
        a += sum(i)
    return a
</t>
<t tx="ekr.20230509052845.4026">print sum_gens([1, 2, 3])  #: 6
print sum_gens({1, 2, 3})  #: 6
print sum_gens(iter([1, 2, 3]))  #: 6

</t>
<t tx="ekr.20230509052845.4027">#%% call_kwargs,barebones
def kwhatever(**kwargs):
    print 'k', kwargs
</t>
<t tx="ekr.20230509052845.4028">def whatever(*args):
    print 'a', args
</t>
<t tx="ekr.20230509052845.4029">def foo(a, b, c=1, *args, **kwargs):
    print a, b, c, args, kwargs
    whatever(a, b, *args, c)
    kwhatever(x=1, **kwargs)
</t>
<t tx="ekr.20230509052845.403">/// A collection of rewrite rules.
class Rewriter {
private:
  std::unordered_map&lt;std::string, std::unique_ptr&lt;RewriteRule&gt;&gt; rules;
  int numReplacements = 0;

public:
@others
  /// @return the number of replacements
  int getNumReplacements() const { return numReplacements; }

  /// Sets the replacement count to zero.
  void reset() { numReplacements = 0; }
};

</t>
<t tx="ekr.20230509052845.4030">foo(1, 2, 3, 4, 5, arg1='s', kwa=2)
#: 1 2 3 (4, 5) (arg1: 's', kwa: 2)
#: a (1, 2, 4, 5, 3)
#: k (arg1: 's', kwa: 2, x: 1)
foo(1, 2)
#: 1 2 1 () ()
#: a (1, 2, 1)
#: k (x: 1)
foo(1, 2, 3)
#: 1 2 3 () ()
#: a (1, 2, 3)
#: k (x: 1)
foo(1, 2, 3, 4)
#: 1 2 3 (4) ()
#: a (1, 2, 4, 3)
#: k (x: 1)
foo(1, 2, zamboni=3)
#: 1 2 1 () (zamboni: 3)
#: a (1, 2, 1)
#: k (x: 1, zamboni: 3)

</t>
<t tx="ekr.20230509052845.4031">#%% call_unpack,barebones
def foo(*args, **kwargs):
    print args, kwargs

</t>
<t tx="ekr.20230509052845.4032">@tuple
class Foo:
    x: int = 5
    y: bool = True

</t>
<t tx="ekr.20230509052845.4033">t = (1, 's')
f = Foo(6)
foo(*t, **f) #: (1, 's') (x: 6, y: True)
foo(*(1,2)) #: (1, 2) ()
foo(3, f) #: (3, (x: 6, y: True)) ()
foo(k = 3, **f) #: () (k: 3, x: 6, y: True)

</t>
<t tx="ekr.20230509052845.4034">#%% call_partial_args_kwargs,barebones
def foo(*args):
    print(args)
</t>
<t tx="ekr.20230509052845.4035">a = foo(1, 2, ...)
b = a(3, 4, ...)
c = b(5, ...)
c('zooooo')
#: (1, 2, 3, 4, 5, 'zooooo')

</t>
<t tx="ekr.20230509052845.4036">def fox(*args, **kwargs):
    print(args, kwargs)
</t>
<t tx="ekr.20230509052845.4037">xa = fox(1, 2, x=5, ...)
xb = xa(3, 4, q=6, ...)
xc = xb(5, ...)
xd = xc(z=5.1, ...)
xd('zooooo', w='lele')
#: (1, 2, 3, 4, 5, 'zooooo') (x: 5, q: 6, z: 5.1, w: 'lele')

</t>
<t tx="ekr.20230509052845.4038">class Foo:
    i: int
    @others
</t>
<t tx="ekr.20230509052845.4039">def __str__(self):
    return f'#{self.i}'
</t>
<t tx="ekr.20230509052845.404">  /// Adds a given rewrite rule with the given key.
  /// @param key the rule's key
  /// @param rule the rewrite rule
  void registerRule(const std::string &amp;key, std::unique_ptr&lt;RewriteRule&gt; rule) {
    rules.emplace(std::make_pair(key, std::move(rule)));
  }

</t>
<t tx="ekr.20230509052845.4040">def foo(self, a):
    return f'{self}:generic'
</t>
<t tx="ekr.20230509052845.4041">def foo(self, a: float):
    return f'{self}:float'
</t>
<t tx="ekr.20230509052845.4042">def foo(self, a: int):
    return f'{self}:int'
</t>
<t tx="ekr.20230509052845.4043">f = Foo(4)

</t>
<t tx="ekr.20230509052845.4044">def pacman(x, f):
    print f(x, '5')
    print f(x, 2.1)
    print f(x, 4)
</t>
<t tx="ekr.20230509052845.4045">pacman(f, Foo.foo)
#: #4:generic
#: #4:float
#: #4:int

</t>
<t tx="ekr.20230509052845.4046">def macman(f):
    print f('5')
    print f(2.1)
    print f(4)
</t>
<t tx="ekr.20230509052845.4047">macman(f.foo)
#: #4:generic
#: #4:float
#: #4:int

</t>
<t tx="ekr.20230509052845.4048">class Fox:
    i: int
    @others
</t>
<t tx="ekr.20230509052845.4049">def __str__(self):
    return f'#{self.i}'
</t>
<t tx="ekr.20230509052845.405">  /// Applies all rewrite rules to the given node, and replaces the given
  /// node with the result of the rewrites.
  /// @param v the node to rewrite
  void rewrite(Value *v) {
    Value *result = v;
    for (auto &amp;r : rules) {
      if (auto *rep = r.second-&gt;apply(result)) {
        ++numReplacements;
        result = rep;
      }
    }
    if (v != result)
      v-&gt;replaceAll(result);
  }

</t>
<t tx="ekr.20230509052845.4050">def foo(self, a, b):
    return f'{self}:generic b={b}'
</t>
<t tx="ekr.20230509052845.4051">def foo(self, a: float, c):
    return f'{self}:float, c={c}'
</t>
<t tx="ekr.20230509052845.4052">def foo(self, a: int):
    return f'{self}:int'
</t>
<t tx="ekr.20230509052845.4053">def foo(self, a: int, z, q):
    return f'{self}:int z={z} q={q}'
</t>
<t tx="ekr.20230509052845.4054">ff = Fox(5)
</t>
<t tx="ekr.20230509052845.4055">def maxman(f):
    print f('5', b=1)
    print f(2.1, 3)
    print f(4)
    print f(5, 1, q=3)
</t>
<t tx="ekr.20230509052845.4056">maxman(ff.foo)
#: #5:generic b=1
#: #5:float, c=3
#: #5:int
#: #5:int z=1 q=3


#%% call_static,barebones
print isinstance(1, int), isinstance(2.2, float), isinstance(3, bool)
#: True True False
print isinstance((1, 2), Tuple), isinstance((1, 2), Tuple[int, int]), isinstance((1, 2), Tuple[float, int])
#: True True False
print isinstance([1, 2], List), isinstance([1, 2], List[int]), isinstance([1, 2], List[float])
#: True True False
print isinstance({1, 2}, List), isinstance({1, 2}, Set[float])
#: False False
print isinstance(Optional(5), Optional[int]), isinstance(Optional(), Optional)
#: True True
print isinstance(Optional(), Optional[int]), isinstance(Optional('s'), Optional[int])
#: False False
print isinstance(None, Optional), isinstance(None, Optional[int])
#: True False
print isinstance(None, Optional[NoneType])
#: True
print isinstance({1, 2}, List)
#: False

print staticlen((1, 2, 3)), staticlen((1, )), staticlen('hehe')
#: 3 1 2

print hasattr([1, 2], "__getitem__")
#: True
print hasattr(type([1, 2]), "__getitem__")
#: True
print hasattr(int, "__getitem__")
#: False
print hasattr([1, 2], "__getitem__", str)
#: False

</t>
<t tx="ekr.20230509052845.4057">#%% isinstance_inheritance,barebones
class AX[T]:
    a: T
    def __init__(self, a: T):
        self.a = a
</t>
<t tx="ekr.20230509052845.4058">class Side:
    def __init__(self):
        pass
</t>
<t tx="ekr.20230509052845.4059">class BX[T,U](Static[AX[T]], Static[Side]):
    b: U
    def __init__(self, a: T, b: U):
        super().__init__(a)
        self.b = b
</t>
<t tx="ekr.20230509052845.406"></t>
<t tx="ekr.20230509052845.4060">class CX[T,U](Static[BX[T,U]]):
    c: int
    def __init__(self, a: T, b: U):
        super().__init__(a, b)
        self.c = 1
</t>
<t tx="ekr.20230509052845.4061">c = CX('a', False)
print isinstance(c, CX), isinstance(c, BX), isinstance(c, AX), isinstance(c, Side)
#: True True True True
print isinstance(c, BX[str, bool]), isinstance(c, BX[str, str]), isinstance(c, AX[int])
#: True False False

#%% staticlen_err,barebones
print staticlen([1, 2]) #! expected tuple type

#%% compile_error,barebones
compile_error("woo-hoo") #! woo-hoo

#%% stack_alloc,barebones
a = __array__[int](2)
print a.__class__.__name__ #: Array[int]

#%% typeof,barebones
a = 5
z = []
z.append(6)
print z.__class__.__name__, z, type(1.1).__class__.__name__  #: List[int] [6] float

#%% ptr,barebones
v = 5
c = __ptr__(v)
print c.__class__.__name__ #: Ptr[int]

</t>
<t tx="ekr.20230509052845.4062">#%% yieldexpr,barebones
def mysum(start):
    m = start
    while True:
        a = (yield)
        print a.__class__.__name__ #: int
        if a == -1:
            break
        m += a
    yield m
</t>
<t tx="ekr.20230509052845.4063">iadder = mysum(0)
next(iadder)
for i in range(10):
    iadder.send(i)
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
print iadder.send(-1)  #: 45

</t>
<t tx="ekr.20230509052845.4064">#%% function_typecheck_level,barebones
def foo(x):
    def bar(z):  # bar has a parent foo(), however its unbounds must not be generalized!
        print z
    bar(x)
    bar('x')
</t>
<t tx="ekr.20230509052845.4065">foo(1)
#: 1
#: x
foo('s')
#: s
#: x

#%% tuple_generator,barebones
a = (1, 2)
b = ('f', 'g')
print a, b #: (1, 2) ('f', 'g')
c = (*a, True, *b)
print c #: (1, 2, True, 'f', 'g')
print a + b + c #: (1, 2, 'f', 'g', 1, 2, True, 'f', 'g')
print () + (1, ) + ('a', 'b') #: (1, 'a', 'b')

t = tuple(i+1 for i in (1,2,3))
print t #: (2, 3, 4)
print tuple((j, i) for i, j in ((1, 'a'), (2, 'b'), (3, 'c')))
#: (('a', 1), ('b', 2), ('c', 3))

</t>
<t tx="ekr.20230509052845.4066">#%% tuple_fn,barebones
@tuple
class unpackable_plain:
  a: int
  b: str

</t>
<t tx="ekr.20230509052845.4067">u = unpackable_plain(1, 'str')
a, b = tuple(u)
print a, b #: 1 str

</t>
<t tx="ekr.20230509052845.4068">@tuple
class unpackable_gen:
  a: int
  b: T
  T: type

</t>
<t tx="ekr.20230509052845.4069">u2 = unpackable_gen(1, 'str')
a2, b2 = tuple(u2)
print a2,b2  #: 1 str

</t>
<t tx="ekr.20230509052845.407">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"
#include "codon/cir/transform/rewrite.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4070">class plain:
  a: int
  b: str

</t>
<t tx="ekr.20230509052845.4071">c = plain(3, 'heh')
z = tuple(c)
print z, z.__class__.__name__  #: (3, 'heh') Tuple[int,str]

</t>
<t tx="ekr.20230509052845.4072">#%% static_unify,barebones
def foo(x: Callable[[1,2], 3]): pass  #! '1' does not match expected type 'T1'

</t>
<t tx="ekr.20230509052845.4073">#%% static_unify_2,barebones
def foo(x: List[1]): pass  #! '1' does not match expected type 'T'

</t>
<t tx="ekr.20230509052845.4074">#%% super,barebones
class A[T]:
    a: T
    def __init__(self, t: T):
        self.a = t
    def foo(self):
        return f'A:{self.a}'
</t>
<t tx="ekr.20230509052845.4075">class B(Static[A[str]]):
    b: int
    def __init__(self):
        super().__init__('s')
        self.b = 6
    def baz(self):
        return f'{super().foo()}::{self.b}'
</t>
<t tx="ekr.20230509052845.4076">b = B()
print b.foo() #: A:s
print b.baz() #: A:s::6

</t>
<t tx="ekr.20230509052845.4077">class AX[T]:
    a: T
    def __init__(self, a: T):
        self.a = a
    def foo(self):
        return f'[AX:{self.a}]'
</t>
<t tx="ekr.20230509052845.4078">class BX[T,U](Static[AX[T]]):
    b: U
    def __init__(self, a: T, b: U):
        print super().__class__.__name__
        super().__init__(a)
        self.b = b
    def foo(self):
        return f'[BX:{super().foo()}:{self.b}]'
</t>
<t tx="ekr.20230509052845.4079">class CX[T,U](Static[BX[T,U]]):
    c: int
    def __init__(self, a: T, b: U):
        print super().__class__.__name__
        super().__init__(a, b)
        self.c = 1
    def foo(self):
        return f'CX:{super().foo()}:{self.c}'
</t>
<t tx="ekr.20230509052845.408">/// Canonicalization pass that flattens nested series
/// flows, puts operands in a predefined order, etc.
class CanonicalizationPass : public OperatorPass, public Rewriter {
private:
  std::string sideEffectsKey;

public:
  /// Constructs a canonicalization pass
  /// @param sideEffectsKey the side effect analysis' key
  CanonicalizationPass(const std::string &amp;sideEffectsKey)
      : OperatorPass(/*childrenFirst=*/true), sideEffectsKey(sideEffectsKey) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void run(Module *m) override;
  void handle(CallInstr *) override;
  void handle(SeriesFlow *) override;

private:
  void registerStandardRules(Module *m);
};

</t>
<t tx="ekr.20230509052845.4080">c = CX('a', False)
print c.__class__.__name__, c.foo()
#: BX[str,bool]
#: AX[str]
#: CX[str,bool] CX:[BX:[AX:a]:False]:1

</t>
<t tx="ekr.20230509052845.4081">#%% super_vtable_2
class Base:
    def test(self):
        print('base.test')
</t>
<t tx="ekr.20230509052845.4082">class A(Base):
    def test(self):
        super().test()
        Base.test(self)
        print('a.test')
</t>
<t tx="ekr.20230509052845.4083">a = A()
a.test()
</t>
<t tx="ekr.20230509052845.4084">def moo(x: Base):
    x.test()
</t>
<t tx="ekr.20230509052845.4085">moo(a)
Base.test(a)
#: base.test
#: base.test
#: a.test
#: base.test
#: base.test
#: a.test
#: base.test

</t>
<t tx="ekr.20230509052845.4086">#%% super_tuple,barebones
@tuple
class A[T]:
    a: T
    x: int
    def __new__(a: T) -&gt; A[T]:
        return (a, 1)
    def foo(self):
        return f'A:{self.a}'
</t>
<t tx="ekr.20230509052845.4087">@tuple
class B(Static[A[str]]):
    b: int
    def __new__() -&gt; B:
        return (*(A('s')), 6)
    def baz(self):
        return f'{super().foo()}::{self.b}'

</t>
<t tx="ekr.20230509052845.4088">b = B()
print b.foo() #: A:s
print b.baz() #: A:s::6


</t>
<t tx="ekr.20230509052845.4089">#%% super_error,barebones
class A:
    def __init__(self):
        super().__init__()
</t>
<t tx="ekr.20230509052845.409">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4090">@path C:/Repos/codon/test/parser/
#%% expr,barebones
a = 5; b = 3
print a, b  #: 5 3

#%% assign_optional,barebones
a = None
print a  #: None
a = 5
print a  #: 5

b: Optional[float] = Optional[float](6.5)
c: Optional[float] = 5.5
print b, c #: 6.5 5.5

#%% assign_type_alias,barebones
I = int
print I(5) #: 5

L = Dict[int, str]
l = L()
print l #: {}
l[5] = 'haha'
print l #: {5: 'haha'}

#%% assign_type_annotation,barebones
a: List[int] = []
print a  #: []

#%% assign_type_err,barebones
a = 5
if 1:
    a = 3.3  #! 'float' does not match expected type 'int'
a

#%% assign_atomic,barebones
i = 1
f = 1.1

@others
Foo.sm(1)  #: sm 1
Foo().sm(2)  #: sm 2
Foo().m()  #: m Foo
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4091">@llvm
def xchg(d: Ptr[int], b: int) -&gt; None:
    %tmp = atomicrmw xchg i64* %d, i64 %b seq_cst
    ret {} {}
</t>
<t tx="ekr.20230509052845.4092">@llvm
def aadd(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw add i64* %d, i64 %b seq_cst
    ret i64 %tmp
</t>
<t tx="ekr.20230509052845.4093">@llvm
def amin(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw min i64* %d, i64 %b seq_cst
    ret i64 %tmp
</t>
<t tx="ekr.20230509052845.4094">@llvm
def amax(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw max i64* %d, i64 %b seq_cst
    ret i64 %tmp
</t>
<t tx="ekr.20230509052845.4095">def min(a, b): return a if a &lt; b else b
</t>
<t tx="ekr.20230509052845.4096">def max(a, b): return a if a &gt; b else b

</t>
<t tx="ekr.20230509052845.4097">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.4098">def __atomic_xchg__(self: Ptr[int], i: int):
    print 'atomic:', self[0], '&lt;-', i
    xchg(self, i)
</t>
<t tx="ekr.20230509052845.4099">def __atomic_add__(self: Ptr[int], i: int):
    print 'atomic:', self[0], '+=', i
    return aadd(self, i)
</t>
<t tx="ekr.20230509052845.41">def create_image_chaos(self, w, h, iterations, filename, rng_seed):
    # Always use the same sequence of random numbers
    # to get reproducible benchmark
    random.seed(rng_seed)

    im = [[1] * h for i in range(w)]
    point = GVector((self.maxx + self.minx) / 2,
                    (self.maxy + self.miny) / 2, 0)
    for _ in range(iterations):
        point = self.transform_point(point)
        x = (point.x - self.minx) / self.width * w
        y = (point.y - self.miny) / self.height * h
        x = int(x)
        y = int(y)
        if x == w:
            x -= 1
        if y == h:
            y -= 1
        im[x][h - y - 1] = 0

    if filename:
        write_ppm(im, filename)


</t>
<t tx="ekr.20230509052845.410">/// Cleanup pass that removes dead code.
class DeadCodeCleanupPass : public OperatorPass {
private:
  std::string sideEffectsKey;
  int numReplacements;

public:
  static const std::string KEY;

  /// Constructs a dead code elimination pass
  /// @param sideEffectsKey the side effect analysis' key
  DeadCodeCleanupPass(std::string sideEffectsKey)
      : OperatorPass(), sideEffectsKey(std::move(sideEffectsKey)), numReplacements(0) {}

  std::string getKey() const override { return KEY; }

  void run(Module *m) override;

  void handle(SeriesFlow *v) override;
  void handle(IfFlow *v) override;
  void handle(WhileFlow *v) override;
  void handle(ImperativeForFlow *v) override;
  void handle(TernaryInstr *v) override;

  /// @return the number of replacements
  int getNumReplacements() const { return numReplacements; }

private:
  void doReplacement(Value *og, Value *v);
};

</t>
<t tx="ekr.20230509052845.4100">def __atomic_min__(self: Ptr[int], b: int):
    print 'atomic:', self[0], '&lt;?=', b
    return amin(self, b)
</t>
<t tx="ekr.20230509052845.4101">def __atomic_max__(self: Ptr[int], b: int):
    print 'atomic:', self[0], '&gt;?=', b
    return amax(self, b)

</t>
<t tx="ekr.20230509052845.4102">@atomic
def foo(x):
    global i, f

    i += 1 #: atomic: 1 += 1
    print i #: 2
    i //= 2 #: atomic: 2 &lt;- 1
    print i #: 1
    i = 3 #: atomic: 1 &lt;- 3
    print i #: 3
    i = min(i, 10) #: atomic: 3 &lt;?= 10
    print i #: 3
    i = max(i, 10) #: atomic: 3 &gt;?= 10
    print i #: 10
    i = max(20, i) #: atomic: 10 &lt;- 20
    print i #: 20

    f += 1.1
    f = 3.3
    f = max(f, 5.5)
</t>
<t tx="ekr.20230509052845.4103">foo(1)
print i, f #: 20 5.5

#%% assign_atomic_real
i = 1
f = 1.1
</t>
<t tx="ekr.20230509052845.4104">@atomic
def foo(x):
    global i, f

    i += 1
    print i #: 2
    i //= 2
    print i #: 1
    i = 3
    print i #: 3
    i = min(i, 10)
    print i #: 3
    i = max(i, 10)
    print i #: 10

    f += 1.1
    f = 3.3
    f = max(f, 5.5)
</t>
<t tx="ekr.20230509052845.4105">foo(1)
print i, f #: 10 5.5

</t>
<t tx="ekr.20230509052845.4106">#%% assign_member,barebones
class Foo:
    x: Optional[int]
</t>
<t tx="ekr.20230509052845.4107">f = Foo()
print f.x #: None
f.x = 5
print f.x #: 5

fo = Optional(Foo())
fo.x = 6
print fo.x #: 6

</t>
<t tx="ekr.20230509052845.4108">#%% assign_member_err_1,barebones
class Foo:
    x: Optional[int]
</t>
<t tx="ekr.20230509052845.4109">Foo().y = 5 #! 'Foo' object has no attribute 'y'

</t>
<t tx="ekr.20230509052845.411">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4110">#%% assign_member_err_2,barebones
@tuple
class Foo:
    x: Optional[int]
</t>
<t tx="ekr.20230509052845.4111">Foo().x = 5 #! cannot modify tuple attributes

</t>
<t tx="ekr.20230509052845.4112">#%% return,barebones
def foo():
    return 1
</t>
<t tx="ekr.20230509052845.4113">print foo()  #: 1

</t>
<t tx="ekr.20230509052845.4114">def bar():
    print 2
    return
    print 1
</t>
<t tx="ekr.20230509052845.4115">bar()  #: 2

</t>
<t tx="ekr.20230509052845.4116">#%% yield,barebones
def foo():
    yield 1
</t>
<t tx="ekr.20230509052845.4117">print [i for i in foo()], str(foo())[:16]  #: [1] &lt;generator at 0x

</t>
<t tx="ekr.20230509052845.4118">#%% yield_void,barebones
def foo():
    yield
    print 1
</t>
<t tx="ekr.20230509052845.4119">y = foo()
print y.done()  #: False
y.next()  #: 1
# TODO: next() should work here!
print y.done()  #: True

</t>
<t tx="ekr.20230509052845.412">/// Demotes global variables that are used in only one
/// function to locals of that function.
class GlobalDemotionPass : public Pass {
private:
  /// number of variables we've demoted
  int numDemotions;

public:
  static const std::string KEY;

  /// Constructs a global variable demotion pass
  GlobalDemotionPass() : Pass(), numDemotions(0) {}

  std::string getKey() const override { return KEY; }
  void run(Module *v) override;

  /// @return number of variables we've demoted
  int getNumDemotions() const { return numDemotions; }
};

</t>
<t tx="ekr.20230509052845.4120">#%% yield_return,barebones
def foo():
    yield 1
    return
    yield 2
</t>
<t tx="ekr.20230509052845.4121">print list(foo())  #: [1]

#%% while,barebones
a = 3
while a:
    print a
    a -= 1
#: 3
#: 2
#: 1

#%% for_break_continue,barebones
for i in range(10):
    if i % 2 == 0:
        continue
    print i
    if i &gt;= 5:
        break
#: 1
#: 3
#: 5

#%% for_error,barebones
for i in 1:
    pass
#! 'int' object has no attribute '__iter__'

</t>
<t tx="ekr.20230509052845.4122">#%% for_void,barebones
def foo(): yield
</t>
<t tx="ekr.20230509052845.4123">for i in foo():
    print i.__class__.__name__  #: NoneType

#%% if,barebones
for a, b in [(1, 2), (3, 3), (5, 4)]:
    if a &gt; b:
        print '1',
    elif a == b:
        print '=',
    else:
        print '2',
print '_'  #: 2 = 1 _

if 1:
    print '1' #: 1

</t>
<t tx="ekr.20230509052845.4124">#%% static_if,barebones
def foo(x, N: Static[int]):
    if isinstance(x, int):
        return x + 1
    elif isinstance(x, float):
        return x.__pow__(.5)
    elif isinstance(x, Tuple[int, str]):
        return f'foo: {x[1]}'
    elif isinstance(x, Tuple) and (N &gt;= 3 or staticlen(x) &gt; 2):
        return x[2:]
    elif hasattr(x, '__len__'):
        return 'len ' + str(x.__len__())
    else:
        compile_error('invalid type')
</t>
<t tx="ekr.20230509052845.4125">print foo(N=1, x=1) #: 2
print foo(N=1, x=2.0) #: 1.41421
print foo(N=1, x=(1, 'bar')) #: foo: bar
print foo(N=1, x=(1, 2)) #: len 2
print foo(N=3, x=(1, 2)) #: ()
print foo(N=1, x=(1, 2, 3)) #: (3)

</t>
<t tx="ekr.20230509052845.4126">#%% try_throw,barebones
class MyError(Static[Exception]):
    def __init__(self, message: str):
        super().__init__('MyError', message)
</t>
<t tx="ekr.20230509052845.4127">try:
    raise MyError("hello!")
except MyError as e:
    print str(e)  #: hello!
try:
    raise OSError("hello os!")
# TODO: except (MyError, OSError) as e:
#     print str(e)
except MyError:
    print "my"
except OSError as o:
    print "os", o.typename, len(o.message), o.file[-20:], o.line
    #: os OSError 9 typecheck_stmt.codon 249
finally:
    print "whoa"  #: whoa

</t>
<t tx="ekr.20230509052845.4128"># Test function name
def foo():
    raise MyError("foo!")
</t>
<t tx="ekr.20230509052845.4129">try:
    foo()
except MyError as e:
    print e.typename, e.message #: MyError foo!

#%% throw_error,barebones
raise 'hello'
#! exceptions must derive from BaseException

</t>
<t tx="ekr.20230509052845.413">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4130">#%% function_builtin_error,barebones
@__force__
def foo(x):
    pass
</t>
<t tx="ekr.20230509052845.4131">#! builtin, exported and external functions cannot be generic

</t>
<t tx="ekr.20230509052845.4132">#%% extend,barebones
@extend
class int:
    def run_lola_run(self):
        while self &gt; 0:
            yield self
            self -= 1
</t>
<t tx="ekr.20230509052845.4133">print list((5).run_lola_run())  #: [5, 4, 3, 2, 1]


</t>
<t tx="ekr.20230509052845.4134">#%% early_return,barebones
def foo(x):
    print  x-1
    return
    print len(x)
</t>
<t tx="ekr.20230509052845.4135">foo(5) #: 4

</t>
<t tx="ekr.20230509052845.4136">def foo2(x):
    if isinstance(x, int):
        print  x+1
        return
    print len(x)
</t>
<t tx="ekr.20230509052845.4137">foo2(1) #: 2
foo2('s') #: 1

</t>
<t tx="ekr.20230509052845.4138">#%% superf,barebones
class Foo:
    @others
</t>
<t tx="ekr.20230509052845.4139">def foo(a):
    # superf(a)
    print 'foo-1', a
</t>
<t tx="ekr.20230509052845.414">/// Cleanup pass that physically replaces nodes.
class ReplaceCleanupPass : public Pass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void run(Module *module) override;
};

</t>
<t tx="ekr.20230509052845.4140">def foo(a: int):
    superf(a)
    print 'foo-2', a
</t>
<t tx="ekr.20230509052845.4141">def foo(a: str):
    superf(a)
    print 'foo-3', a
</t>
<t tx="ekr.20230509052845.4142">def foo(a):
    superf(a)
    print 'foo-4', a
</t>
<t tx="ekr.20230509052845.4143">Foo.foo(1)
#: foo-1 1
#: foo-2 1
#: foo-4 1

</t>
<t tx="ekr.20230509052845.4144">class Bear:
    def woof(x):
        return f'bear woof {x}'
</t>
<t tx="ekr.20230509052845.4145">@extend
class Bear:
    def woof(x):
        return superf(x) + f' bear w--f {x}'
</t>
<t tx="ekr.20230509052845.4146">print Bear.woof('!')
#: bear woof ! bear w--f !

</t>
<t tx="ekr.20230509052845.4147">class PolarBear(Static[Bear]):
    def woof():
        return 'polar ' + superf('@')
</t>
<t tx="ekr.20230509052845.4148">print PolarBear.woof()
#: polar bear woof @ bear w--f @

</t>
<t tx="ekr.20230509052845.4149">#%% superf_error,barebones
class Foo:
    def foo(a):
        superf(a)
        print 'foo-1', a
</t>
<t tx="ekr.20230509052845.415"></t>
<t tx="ekr.20230509052845.4150">Foo.foo(1)
#! no superf methods found
#! during the realization of foo(a: int)

</t>
<t tx="ekr.20230509052845.4151">#%% staticmethod,barebones
class Foo:
    def __repr__(self):
        return 'Foo'
    def m(self):
        print 'm', self
    @staticmethod
    def sm(i):
        print 'sm', i
</t>
<t tx="ekr.20230509052845.4152">@path C:/Repos/codon/test/parser/
#%% basic,barebones
a = 5
b: float = 6.16
c: optional[str] = None
print a, b, c  #: 5 6.16 None

#%% late_unify,barebones
a = []
a.append(1)
print a  #: [1]
print [1]+[1]  #: [1, 1]

@others
f(1, 2)  #! generic 'T' not provided
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4153">#%% late_unify_2,barebones
class XX[T]:
    y: T
</t>
<t tx="ekr.20230509052845.4154">a = XX()
</t>
<t tx="ekr.20230509052845.4155">def f(i: int) -&gt; int:
    return i
</t>
<t tx="ekr.20230509052845.4156">print a.y.__class__.__name__ #: int
f(a.y)
print a.__class__.__name__ #: XX[int]
print XX[bool].__class__.__name__ #: XX[bool]

#%% nested_generic,barebones
x = Array[Array[int]](0)
f = Optional[Optional[Optional[int]]](Optional[Optional[int]](Optional[int](5)))
print x.len, f  #: 0 5

</t>
<t tx="ekr.20230509052845.4157">#%% map_unify
def map[T,S](l: List[T], f: Callable[[T], S]):
    return [f(x) for x in l]
</t>
<t tx="ekr.20230509052845.4158">e = 1
print map([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]

</t>
<t tx="ekr.20230509052845.4159">def map2(l, f):
    return [f(x) for x in l]
</t>
<t tx="ekr.20230509052845.416">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;unordered_map&gt;

#include "codon/cir/transform/folding/rule.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4160">print map2([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]

</t>
<t tx="ekr.20230509052845.4161">#%% nested,barebones
def m4[TD](a: int, d: TD):
    def m5[TD,TE](a: int, d: TD, e: TE):
        print a, d, e
    m5(a, d, 1.12)
</t>
<t tx="ekr.20230509052845.4162">m4(1, 's')  #: 1 s 1.12
m4(1, True)  #: 1 True 1.12

</t>
<t tx="ekr.20230509052845.4163">#%% nested_class,barebones
class A[TA]:
    a: TA
    # lots of nesting:
    def m4[TD](self: A[TA], d: TD):
        def m5[TA,TD,TE](a: TA, d: TD, e: TE):
            print a, d, e
        m5(self.a, d, d)
</t>
<t tx="ekr.20230509052845.4164">ax = A(42)
ax.m4(1)  #: 42 1 1

</t>
<t tx="ekr.20230509052845.4165">#%% static_fn,barebones
class A[TA]:
    a: TA
    def dump(a, b, c):
        print a, b, c
    def m2():
        A.dump(1, 2, 's')
    def __str__(self):
        return 'A'
</t>
<t tx="ekr.20230509052845.4166">A.dump(1, 2, 3)  #: 1 2 3
A[int].m2()  #: 1 2 s
A.m2()  #: 1 2 s
c = A[str]('s')
c.dump('y', 1.1)  #: A y 1.1

</t>
<t tx="ekr.20230509052845.4167">#%% static_fn_overload,barebones
def foo(x: Static[int]):
    print('int', x)

</t>
<t tx="ekr.20230509052845.4168">@overload
def foo(x: Static[str]):
    print('str', x)

</t>
<t tx="ekr.20230509052845.4169">foo(10)
#: int 10
foo('s')
#: str s

</t>
<t tx="ekr.20230509052845.417">class FoldingPass : public OperatorPass, public Rewriter {
private:
  bool pyNumerics;

  void registerStandardRules(Module *m);

public:
  /// Constructs a folding pass.
  FoldingPass(bool pyNumerics = false)
      : OperatorPass(/*childrenFirst=*/true), pyNumerics(pyNumerics) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void run(Module *m) override;
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4170">#%% realization_big
class A[TA,TB,TC]:
    a: TA
    b: TB
    c: TC

    @others
</t>
<t tx="ekr.20230509052845.4171">def dump(a, b, c):
    print a, b, c

</t>
<t tx="ekr.20230509052845.4172"># non-generic method:
def m0(self: A[TA,TB,TC], a: int):
    print a

</t>
<t tx="ekr.20230509052845.4173"># basic generics:
def m1[X](self: A[TA,TB,TC], other: A[X,X,X]):
    print other.a, other.b, other.c

</t>
<t tx="ekr.20230509052845.4174"># non-generic method referencing outer generics:
def m2(a: TA, b: TB, c: TC):
    A.dump(a, b, c)

</t>
<t tx="ekr.20230509052845.4175"># generic args:
def m3(self, other):
    return self.a

</t>
<t tx="ekr.20230509052845.4176"># lots of nesting:
def m4[TD](self: A[TA,TB,TC], d: TD):
    def m5[TA,TB,TC,TD,TE](a: TA, b: TB, c: TC, d: TD, e: TE):
        print a, b, c, d, e
    m5(self.a, self.b, self.c, d, d)

</t>
<t tx="ekr.20230509052845.4177"># instantiating the type:
def m5(self):
    x = A(self.a, self.b, self.c)
    A.dump(x.a, x.b, x.c)

</t>
<t tx="ekr.20230509052845.4178"># deeply nested generic type:
def m6[T](v: array[array[array[T]]]):
    return v[0][0][0]
</t>
<t tx="ekr.20230509052845.4179">a1 = A(42, 3.14, "hello")
a2 = A(1, 2, 3)
a1.m1(a2)                           #: 1 2 3
A[int,float,str].m2(1, 1.0, "one")  #: 1 1 one
A[int,int,int].m2(11, 22, 33)       #: 11 22 33
print a1.m3(a2)                     #: 42
print a1.m3(a2)                     #: 42
print a2.m3(a1)                     #: 1
a1.m4(True)                         #: 42 3.14 hello True True
a1.m4([1])                          #: 42 3.14 hello [1] [1]
a2.m4("x")                          #: 1 2 3 x x
a1.m5()                             #: 42 3.14 hello
a2.m5()                             #: 1 2 3

v1 = array[array[array[str]]](1)
v2 = array[array[str]](1)
v3 = array[str](1)
v1[0] = v2
v2[0] = v3
v3[0] = "world"
print A.m6(v1)                      #: world

f = a2.m0
f(99)                               #: 99

</t>
<t tx="ekr.20230509052845.418">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4180">#%% realization_small,barebones
class B1[T]:
    a: T
    def foo[S](self: S) -&gt; B1[int]:
        return B1[int](111)
</t>
<t tx="ekr.20230509052845.4181">b1 = B1[bool](True).foo()
print b1.foo().a                    #: 111

</t>
<t tx="ekr.20230509052845.4182">class B2[T]:
    a: T
    def foo[S](self: B2[S]):
        return B2[int](222)
</t>
<t tx="ekr.20230509052845.4183">b2 = B2[str]("x").foo()
print b2.foo().a                    #: 222

</t>
<t tx="ekr.20230509052845.4184"># explicit realization:
def m7[T,S]():
    print "works"
</t>
<t tx="ekr.20230509052845.4185">m7(str,float)                       #: works
m7(str,float)                       #: works
m7(float,str)                       #: works

</t>
<t tx="ekr.20230509052845.4186">#%% recursive,barebones
def foo(a):
    if not a:
        foo(True)
    print a
</t>
<t tx="ekr.20230509052845.4187">foo(0)
#: True
#: 0

</t>
<t tx="ekr.20230509052845.4188">def bar(a):
    def baz(x):
        if not x:
            bar(True)
        print (x)
    baz(a)
</t>
<t tx="ekr.20230509052845.4189">bar(0)
#: True
#: 0

</t>
<t tx="ekr.20230509052845.419">/// Constant propagation pass.
class ConstPropPass : public OperatorPass {
private:
  /// Key of the reaching definition analysis
  std::string reachingDefKey;
  /// Key of the global variables analysis
  std::string globalVarsKey;

public:
  static const std::string KEY;

  /// Constructs a constant propagation pass.
  /// @param reachingDefKey the reaching definition analysis' key
  /// @param globalVarsKey global variables analysis' key
  ConstPropPass(const std::string &amp;reachingDefKey, const std::string &amp;globalVarsKey)
      : reachingDefKey(reachingDefKey), globalVarsKey(globalVarsKey) {}

  std::string getKey() const override { return KEY; }
  void handle(VarValue *v) override;
};

</t>
<t tx="ekr.20230509052845.4190">def rec2(x, y):
    if x:
        return rec2(y, x)
    else:
        return 1.0
</t>
<t tx="ekr.20230509052845.4191">print rec2(1, False).__class__.__name__ #: float

</t>
<t tx="ekr.20230509052845.4192">def pq(x):
    return True
</t>
<t tx="ekr.20230509052845.4193">def rec3(x, y):
    if pq(x):
        return rec3(y, x)
    else:
        return y
</t>
<t tx="ekr.20230509052845.4194">print rec3('x', 's').__class__.__name__  #: str

</t>
<t tx="ekr.20230509052845.4195"># Nested mutually recursive function
def f[T](x: T) -&gt; T:
    def g[T](z):
        return z(T())
    return g(f, T=T)
</t>
<t tx="ekr.20230509052845.4196">print f(1.2).__class__.__name__ #: float
print f('s').__class__.__name__ #: str

</t>
<t tx="ekr.20230509052845.4197">def f2[T](x: T):
    return f2(x - 1, T) if x else 1
</t>
<t tx="ekr.20230509052845.4198">print f2(1) #: 1
print f2(1.1).__class__.__name__ #: int


</t>
<t tx="ekr.20230509052845.4199">#%% recursive_error,barebones
def pq(x):
    return True
</t>
<t tx="ekr.20230509052845.42">def main():
    splines = [
        Spline([
            GVector(1.597350, 3.304460, 0.000000),
            GVector(1.575810, 4.123260, 0.000000),
            GVector(1.313210, 5.288350, 0.000000),
            GVector(1.618900, 5.329910, 0.000000),
            GVector(2.889940, 5.502700, 0.000000),
            GVector(2.373060, 4.381830, 0.000000),
            GVector(1.662000, 4.360280, 0.000000)],
            3, [0, 0, 0, 1, 1, 1, 2, 2, 2]),
        Spline([
            GVector(2.804500, 4.017350, 0.000000),
            GVector(2.550500, 3.525230, 0.000000),
            GVector(1.979010, 2.620360, 0.000000),
            GVector(1.979010, 2.620360, 0.000000)],
            3, [0, 0, 0, 1, 1, 1]),
        Spline([
            GVector(2.001670, 4.011320, 0.000000),
            GVector(2.335040, 3.312830, 0.000000),
            GVector(2.366800, 3.233460, 0.000000),
            GVector(2.366800, 3.233460, 0.000000)],
            3, [0, 0, 0, 1, 1, 1])
    ]

    chaos = Chaosgame(splines, DEFAULT_THICKNESS)
    chaos.create_image_chaos(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_ITERATIONS, sys.argv[1], DEFAULT_RNG_SEED)

</t>
<t tx="ekr.20230509052845.420">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/cleanup/canonical.h"
#include "codon/cir/transform/cleanup/dead_code.h"
#include "codon/cir/transform/cleanup/global_demote.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

class FoldingPass;

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4200">def rec3(x, y): #- ('a, 'b) -&gt; 'b
    if pq(x):
        return rec3(y, x)
    else:
        return y
</t>
<t tx="ekr.20230509052845.4201">rec3(1, 's')
#! 'int' does not match expected type 'str'
#! during the realization of rec3(x: int, y: str)

</t>
<t tx="ekr.20230509052845.4202">#%% instantiate_function_2,barebones
def fx[T](x: T) -&gt; T:
    def g[T](z):
        return z(T())
    return g(fx, T)
</t>
<t tx="ekr.20230509052845.4203">print fx(1.1).__class__.__name__, fx(1).__class__.__name__ #: float int

#%% optionals,barebones
y = None
print y  #: None
y = 5
print y  #: 5

</t>
<t tx="ekr.20230509052845.4204">def foo(x: optional[int], y: int):
    print 'foo', x, y
</t>
<t tx="ekr.20230509052845.4205">foo(y, 6)  #: foo 5 6
foo(5, 6)  #: foo 5 6
foo(5, y)  #: foo 5 5
y = None
try:
    foo(5, y)
except ValueError:
    print 'unwrap failed'  #: unwrap failed

</t>
<t tx="ekr.20230509052845.4206">class Cls:
    x: int
</t>
<t tx="ekr.20230509052845.4207">c = None
for i in range(2):
    if c: c.x += 1  # check for unwrap() dot access
    c = Cls(1)
print(c.x)  #: 1

</t>
<t tx="ekr.20230509052845.4208">#%% optional_methods,barebones
@extend
class int:
    def x(self):
        print 'x()!', self

</t>
<t tx="ekr.20230509052845.4209">y = None
z = 1 if y else None
print z  #: None

y = 6
z = 1 + y if y else None
print z  #: 7
z.x()  #: x()! 7
if 1: # otherwise compiler won't compile z.x() later
    z = None
try:
    z.x()
except ValueError:
    print 'unwrap failed'  #: unwrap failed

print Optional(1) + Optional(2)  #: 3
print Optional(1) + 3  #: 4
print 1 + Optional(1)  #: 2

#%% optional_tuple,barebones
a = None
if True:
    a = ('x', 's')
print(a)  #: ('x', 's')
print(*a, (1, *a))  #: x s (1, 'x', 's')
x,y=a
print(x,y,[*a]) #: x s ['x', 's']

#%% global_none,barebones
a, b = None, None
</t>
<t tx="ekr.20230509052845.421">/// Group of constant folding passes.
class FoldingPassGroup : public PassGroup {
private:
  cleanup::GlobalDemotionPass *gd;
  cleanup::CanonicalizationPass *canon;
  FoldingPass *fp;
  cleanup::DeadCodeCleanupPass *dce;

public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  /// @param sideEffectsPass the key of the side effects pass
  /// @param reachingDefPass the key of the reaching definitions pass
  /// @param globalVarPass the key of the global variables pass
  /// @param repeat default number of times to repeat the pass
  /// @param runGlobalDemotion whether to demote globals if possible
  /// @param pyNumerics whether to use Python (vs. C) semantics when folding
  FoldingPassGroup(const std::string &amp;sideEffectsPass,
                   const std::string &amp;reachingDefPass, const std::string &amp;globalVarPass,
                   int repeat = 5, bool runGlobalDemotion = true,
                   bool pyNumerics = false);

  bool shouldRepeat(int num) const override;
};

</t>
<t tx="ekr.20230509052845.4210">def foo():
    global a, b
    a = [1, 2]
    b = 3
</t>
<t tx="ekr.20230509052845.4211">print a, b,
foo()
print a, b #: None None [1, 2] 3

</t>
<t tx="ekr.20230509052845.4212">#%% default_type_none
class Test:
    value: int
    def __init__(self, value: int):
        self.value = value
    def __repr__(self):
        return str(self.value)
</t>
<t tx="ekr.20230509052845.4213">def key_func(k: Test):
    return k.value
</t>
<t tx="ekr.20230509052845.4214">print sorted([Test(1), Test(3), Test(2)], key=key_func)  #: [1, 2, 3]
print sorted([Test(1), Test(3), Test(2)], key=lambda x: x.value)  #: [1, 2, 3]
print sorted([1, 3, 2])  #: [1, 2, 3]

#%% nested_map
print list(map(lambda i: i-2, map(lambda i: i+1, range(5))))
#: [-1, 0, 1, 2, 3]

</t>
<t tx="ekr.20230509052845.4215">def h(x: list[int]):
    return x
</t>
<t tx="ekr.20230509052845.4216">print h(list(map(lambda i: i-1, map(lambda i: i+2, range(5)))))
#: [1, 2, 3, 4, 5]

</t>
<t tx="ekr.20230509052845.4217">#%% func_unify_error,barebones
def foo(x:int):
    print x
</t>
<t tx="ekr.20230509052845.4218">z = 1 &amp; foo #! unsupported operand type(s) for &amp;: 'int' and 'foo[int]'

#%% tuple_type_late,barebones
coords = []
for i in range(2):
    coords.append( ('c', i, []) )
coords[0][2].append((1, 's'))
print(coords)  #: [('c', 0, [(1, 's')]), ('c', 1, [])]

</t>
<t tx="ekr.20230509052845.4219">#%% void,barebones
def foo():
    print 'foo'
</t>
<t tx="ekr.20230509052845.422">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;utility&gt;

#include "codon/cir/transform/pass.h"
#include "codon/cir/transform/rewrite.h"
#include "codon/cir/util/irtools.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4220">def bar(x):
    print 'bar', x.__class__.__name__
</t>
<t tx="ekr.20230509052845.4221">a = foo()  #: foo
bar(a)  #: bar NoneType

</t>
<t tx="ekr.20230509052845.4222">def x():
  pass
</t>
<t tx="ekr.20230509052845.4223">b = lambda: x()
b()
x() if True else x()

</t>
<t tx="ekr.20230509052845.4224">#%% void_2,barebones
def foo():
    i = 0
    while i &lt; 10:
        print i  #: 0
        yield
        i += 10
</t>
<t tx="ekr.20230509052845.4225">a = list(foo())
print(a)  #: [None]

</t>
<t tx="ekr.20230509052845.4226">#%% instantiate_swap,barebones
class Foo[T, U]:
    t: T
    u: U
    def __init__(self):
        self.t = T()
        self.u = U()
    def __str__(self):
        return f'{self.t} {self.u}'
</t>
<t tx="ekr.20230509052845.4227">print Foo[int, bool](), Foo[bool, int]() #: 0 False False 0

</t>
<t tx="ekr.20230509052845.4228">#%% static,barebones
class Num[N_: Static[int]]:
    def __str__(self):
        return f'[{N_}]'
    def __init__(self):
        pass
</t>
<t tx="ekr.20230509052845.4229">def foo[N: Static[int]]():
    print Num[N*2]()
</t>
<t tx="ekr.20230509052845.423">/// Commutative, binary rule that requires a single constant.
template &lt;typename ConstantType&gt;
@others
</t>
<t tx="ekr.20230509052845.4230">foo(3) #: [6]

</t>
<t tx="ekr.20230509052845.4231">class XX[N_: Static[int]]:
    a: Num[N_*2]
    def __init__(self):
        self.a = Num()
</t>
<t tx="ekr.20230509052845.4232">y = XX[5]()
print y.a, y.__class__.__name__, y.a.__class__.__name__ #: [10] XX[5] Num[10]

</t>
<t tx="ekr.20230509052845.4233">@tuple
class FooBar[N: Static[int]]:
    x: Int[N]
</t>
<t tx="ekr.20230509052845.4234">z = FooBar(i32(5))
print z, z.__class__.__name__, z.x.__class__.__name__ #: (x: Int[32](5)) FooBar[32] Int[32]

</t>
<t tx="ekr.20230509052845.4235">@tuple
class Foo[N: Static[int]]:
    x: Int[2*N]
    def __new__(x: Int[2*N]) -&gt; Foo[N]:
        return (x,)
</t>
<t tx="ekr.20230509052845.4236">foo = Foo[10](Int[20](0))
print foo.__class__.__name__, foo.x.__class__.__name__ #: Foo[10] Int[20]

</t>
<t tx="ekr.20230509052845.4237">#%% static_2,barebones
class Num[N: Static[int]]:
    def __str__(self):
        return f'~{N}'
    def __init__(self):
        pass
</t>
<t tx="ekr.20230509052845.4238">class Foo[T, A: Static[int], B: Static[int]]:
    a: Num[A+B]
    b: Num[A-B]
    c: Num[A if A &gt; 3 else B]
    t: T
    @others
</t>
<t tx="ekr.20230509052845.4239">def __init__(self):
    self.a = Num()
    self.b = Num()
    self.c = Num()
    self.t = T()
</t>
<t tx="ekr.20230509052845.424">class SingleConstantCommutativeRule : public RewriteRule {
public:
  using Calculator = std::function&lt;Value *(Value *)&gt;;
  enum Kind { LEFT, RIGHT, COMMUTATIVE };

private:
  /// the value being matched against
  ConstantType val;
  /// the type being matched
  types::Type *type;
  /// the magic method name
  std::string magic;
  /// the calculator
  Calculator calc;
  /// left, right or commutative
  Kind kind;

public:
  /// Constructs a commutative rule.
  /// @param val the matched value
  /// @param newVal the result
  /// @param magic the magic name
  /// @param kind left, right, or commutative
  /// @param type the matched type
  SingleConstantCommutativeRule(ConstantType val, ConstantType newVal,
                                std::string magic, Kind kind, types::Type *type)
      : val(val), type(type), magic(std::move(magic)), kind(kind) {
    calc = [=](Value *v) -&gt; Value * {
      return v-&gt;getModule()-&gt;N&lt;TemplatedConst&lt;ConstantType&gt;&gt;(v-&gt;getSrcInfo(), val,
                                                             type);
    };
  }
  /// Constructs a commutative rule.
  /// @param val the matched value
  /// @param newVal the result
  /// @param magic the magic name
  /// @param calc the calculator
  /// @param kind left, right, or commutative
  /// @param type the matched type
  SingleConstantCommutativeRule(ConstantType val, Calculator calc, std::string magic,
                                Kind kind, types::Type *type)
      : val(val), type(type), magic(std::move(magic)), calc(std::move(calc)),
        kind(kind) {}

  virtual ~SingleConstantCommutativeRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509052845.4240">def __str__(self):
    return f'&lt;{self.a} {self.b} {self.c} :: {self.t}&gt;'
</t>
<t tx="ekr.20230509052845.4241">print Foo[int, 3, 4](), Foo[int, 5, 4]()
#: &lt;~7 ~-1 ~4 :: 0&gt; &lt;~9 ~1 ~5 :: 0&gt;

</t>
<t tx="ekr.20230509052845.4242">#%% static_int,barebones
def foo(n: Static[int]):
    print n

</t>
<t tx="ekr.20230509052845.4243">a: Static[int] = 5
foo(a &lt; 1)   #: 0
foo(a &lt;= 1)  #: 0
foo(a &gt; 1)   #: 1
foo(a &gt;= 1)  #: 1
foo(a == 1)  #: 0
foo(a != 1)  #: 1
foo(a and 1) #: 1
foo(a or 1)  #: 1
foo(a + 1)   #: 6
foo(a - 1)   #: 4
foo(a * 1)   #: 5
foo(a // 2)  #: 2
foo(a % 2)   #: 1
foo(a &amp; 2)   #: 0
foo(a | 2)   #: 7
foo(a ^ 1)   #: 4

</t>
<t tx="ekr.20230509052845.4244">#%% static_str,barebones
class X:
    s: Static[str]
    i: Int[1 + (s == "abc")]
    def __init__(self: X[s], s: Static[str]):
        i = Int[1+(s=="abc")]()
        print s, self.s, self.i.__class__.__name__
</t>
<t tx="ekr.20230509052845.4245">def foo(x: Static[str], y: Static[str]):
    print x+y
</t>
<t tx="ekr.20230509052845.4246">z: Static[str] = "woo"
foo("he", z)  #: hewoo
X(s='lolo') #: lolo lolo Int[1]
X('abc') #: abc abc Int[2]

#%% static_getitem
print Int[staticlen("ee")].__class__.__name__ #: Int[2]

y = [1, 2]
print getattr(y, "len") #: 2
print y.len #: 2
getattr(y, 'append')(1)
print y #: [1, 2, 1]

</t>
<t tx="ekr.20230509052845.4247">@extend
class Dict:
    @others
</t>
<t tx="ekr.20230509052845.4248">def __getitem2__(self, attr: Static[str]):
    if hasattr(self, attr):
        return getattr(self, attr)
    else:
        return self[attr]
</t>
<t tx="ekr.20230509052845.4249">def __getitem1__(self, attr: Static[int]):
    return self[attr]

</t>
<t tx="ekr.20230509052845.425">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {type, type}, type, /*method=*/true))
      return;

    auto *left = v-&gt;front();
    auto *right = v-&gt;back();
    auto *leftConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(left);
    auto *rightConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(right);

    if ((kind == Kind::COMMUTATIVE || kind == Kind::LEFT) &amp;&amp; leftConst &amp;&amp;
        leftConst-&gt;getVal() == val)
      return setResult(calc(right));
    if ((kind == Kind::COMMUTATIVE || kind == Kind::RIGHT) &amp;&amp; rightConst &amp;&amp;
        rightConst-&gt;getVal() == val)
      return setResult(calc(left));
  }
</t>
<t tx="ekr.20230509052845.4250">d = {'s': 3.19}
print d.__getitem2__('_upper_bound') #: 3
print d.__getitem2__('s') #: 3.19
e = {1: 3.33}
print e.__getitem1__(1) #: 3.33

</t>
<t tx="ekr.20230509052845.4251">#%% static_fail,barebones
def test(i: Int[32]):
    print int(i)
</t>
<t tx="ekr.20230509052845.4252">test(Int[5](1)) #! 'Int[5]' does not match expected type 'Int[32]'

#%% static_fail_2,barebones
zi = Int[32](6)
</t>
<t tx="ekr.20230509052845.4253">def test3[N](i: Int[N]):
    print int(i)
</t>
<t tx="ekr.20230509052845.4254">test3(zi) #! 'N' does not match expected type 'N'
# TODO: nicer error message!

#%% static_fail_3,barebones
zi = Int[32](6)
</t>
<t tx="ekr.20230509052845.4255">def test3[N: Static[int]](i: Int[N]):
    print int(i)
</t>
<t tx="ekr.20230509052845.4256">test3(1, int) #! expected static expression
# TODO: nicer error message!

</t>
<t tx="ekr.20230509052845.4257">#%% nested_fn_generic,barebones
def f(x):
    def g(y):
        return y
    return g(x)
</t>
<t tx="ekr.20230509052845.4258">print f(5), f('s') #: 5 s

</t>
<t tx="ekr.20230509052845.4259">def f2[U](x: U, y):
    def g[T, U](x: T, y: U):
        return (x, y)
    return g(y, x)
</t>
<t tx="ekr.20230509052845.426">/// Binary rule that requires two constants.
template &lt;typename ConstantType, typename Func, typename OutputType = ConstantType&gt;
@others
</t>
<t tx="ekr.20230509052845.4260">x, y = 1, 'haha'
print f2(x, y).__class__.__name__ #: Tuple[str,int]
print f2('aa', 1.1, U=str).__class__.__name__ #: Tuple[float,str]

</t>
<t tx="ekr.20230509052845.4261">#%% nested_fn_generic_error,barebones
def f[U](x: U, y): # ('u, 'a) -&gt; tuple['a, 'u]
    def g[T, U](x: T, y: U): # ('t, 'u) -&gt; tuple['t, 'u]
        return (x, y)
    return g(y, x)
</t>
<t tx="ekr.20230509052845.4262">print f(1.1, 1, int).__class__.__name__ #! 'float' does not match expected type 'int'

</t>
<t tx="ekr.20230509052845.4263">#%% fn_realization,barebones
def ff[T](x: T, y: tuple[T]):
      print ff(T=str,...).__class__.__name__ #: ff[str,Tuple[str],str]
      return x
</t>
<t tx="ekr.20230509052845.4264">x = ff(1, (1,))
print x, x.__class__.__name__ #: 1 int
# print f.__class__.__name__  # TODO ERRORS

</t>
<t tx="ekr.20230509052845.4265">def fg[T](x:T):
    def g[T](y):
        z = T()
        return z
    print fg(T=str,...).__class__.__name__  #: fg[str,str]
    print g(1, T).__class__.__name__ #: int
</t>
<t tx="ekr.20230509052845.4266">fg(1)
print fg(1).__class__.__name__ #: NoneType

</t>
<t tx="ekr.20230509052845.4267">def f[T](x: T):
    print f(x, T).__class__.__name__  #: int
    print f(x).__class__.__name__      #: int
    print f(x, int).__class__.__name__ #: int
    return x
</t>
<t tx="ekr.20230509052845.4268">print f(1), f(1).__class__.__name__ #: 1 int
print f(1, int).__class__.__name__ #: int

</t>
<t tx="ekr.20230509052845.4269">#%% fn_realization_error,barebones
def f[T](x: T):
    print f(x, int).__class__.__name__
    return x
</t>
<t tx="ekr.20230509052845.427">class DoubleConstantBinaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the output type
  types::Type *resultType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a binary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  /// @param resultType the output type
  DoubleConstantBinaryRule(Func f, std::string magic, types::Type *inputType,
                           types::Type *resultType)
      : f(std::move(f)), inputType(inputType), resultType(resultType),
        magic(std::move(magic)) {}

  virtual ~DoubleConstantBinaryRule() noexcept = default;

@others
private:
  Value *toValue(Value *, Value *v) { return v; }

  Value *toValue(Value *og, OutputType v) {
    return og-&gt;getModule()-&gt;template N&lt;TemplatedConst&lt;OutputType&gt;&gt;(og-&gt;getSrcInfo(), v,
                                                                   resultType);
  }
};

</t>
<t tx="ekr.20230509052845.4270">f('s')
#! 'str' does not match expected type 'int'
#! during the realization of f(x: str, T: str)

</t>
<t tx="ekr.20230509052845.4271">#%% nested_class_error,barebones
class X:
    def foo(self, x):
        return x
    class Y:
        def bar(self, x):
            return x
</t>
<t tx="ekr.20230509052845.4272">y = X.Y()
y.foo(1) #! 'X.Y' object has no attribute 'foo'

</t>
<t tx="ekr.20230509052845.4273">#%% nested_deep_class,barebones
class A[T]:
    a: T
    @others
</t>
<t tx="ekr.20230509052845.4274">class B[U]:
    b: U
    class C[V]:
        c: V
        def foo[W](t: V, u: V, v: V, w: W):
            return (t, u, v, w)

</t>
<t tx="ekr.20230509052845.4275">print A.B.C[bool].foo(W=str, ...).__class__.__name__ #: foo[bool,bool,bool,str,str]
print A.B.C.foo(1,1,1,True) #: (1, 1, 1, True)
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')

x = A.B.C[bool]()
print x.__class__.__name__ #: A.B.C[bool]

</t>
<t tx="ekr.20230509052845.4276">#%% nested_deep_class_error,barebones
class A[T]:
    a: T
    @others
</t>
<t tx="ekr.20230509052845.4277">class B[U]:
    b: U
    class C[V]:
        c: V
        def foo[W](t: V, u: V, v: V, w: W):
            return (t, u, v, w)

</t>
<t tx="ekr.20230509052845.4278">print A.B.C[str].foo(1,1,1,True) #! 'A.B.C[str]' object has no method 'foo' with arguments (int, int, int, bool)

</t>
<t tx="ekr.20230509052845.4279">#%% nested_deep_class_error_2,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)
</t>
<t tx="ekr.20230509052845.428">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType, inputType}, resultType, /*method=*/true))
      return;

    auto *left = v-&gt;front();
    auto *right = v-&gt;back();
    auto *leftConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(left);
    auto *rightConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(right);

    if (leftConst &amp;&amp; rightConst)
      return setResult(toValue(v, f(leftConst-&gt;getVal(), rightConst-&gt;getVal())));
  }

</t>
<t tx="ekr.20230509052845.4280">print A.B[int].C[float].foo(1,1,1,True) #! 'A.B[int]' object has no attribute 'C'

</t>
<t tx="ekr.20230509052845.4281">#%% nested_class_function,barebones
def f(x):
    def g(y):
        return y
    a = g(1)
    b = g('s')
    c = g(x)
    return a, b, c
</t>
<t tx="ekr.20230509052845.4282">print f(1.1).__class__.__name__ #: Tuple[int,str,float]
print f(False).__class__.__name__ #: Tuple[int,str,bool]

</t>
<t tx="ekr.20230509052845.4283">class A[T]:
    a: T
    @others
</t>
<t tx="ekr.20230509052845.4284">class B[U]:
    b: U
    class C[V]:
        c: V
        @others
</t>
<t tx="ekr.20230509052845.4285">def f(x):
def g(y):
    return y
a = g(1)
b = g('s')
c = g(x)
return a, b, c
</t>
<t tx="ekr.20230509052845.4286">print A.B.C.f(1.1).__class__.__name__ #: Tuple[int,str,float]
print A.B.C[Optional[int]].f(False).__class__.__name__ #: Tuple[int,str,bool]

</t>
<t tx="ekr.20230509052845.4287">#%% rec_class_1,barebones
class A:
    y: A
    def __init__(self): pass  # necessary to prevent recursive instantiation!
</t>
<t tx="ekr.20230509052845.4288">x = A()
print x.__class__.__name__, x.y.__class__.__name__ #: A A

</t>
<t tx="ekr.20230509052845.4289">#%% rec_class_2,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
</t>
<t tx="ekr.20230509052845.429">/// Unary rule that requires one constant.
template &lt;typename ConstantType, typename Func&gt;
@others
</t>
<t tx="ekr.20230509052845.4290">a = A[int]()
print a.__class__.__name__, a.b.__class__.__name__, a.c.__class__.__name__, a.b.b.__class__.__name__, a.b.c.__class__.__name__
#: A[int] A[int] A[str] A[int] A[str]
print a.c.b.__class__.__name__, a.c.c.__class__.__name__, a.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.__class__.__name__
#: A[str] A[str] A[int]

</t>
<t tx="ekr.20230509052845.4291">#%% rec_class_3,barebones
class X:
    x: int
    rec: X
    @others
</t>
<t tx="ekr.20230509052845.4292">def __init__(self): pass
</t>
<t tx="ekr.20230509052845.4293">def foo(x: X, y: int):
    return y
</t>
<t tx="ekr.20230509052845.4294">class Y:
    y: int
    def bar(self, y):
        print y
        return self.y
</t>
<t tx="ekr.20230509052845.4295">x, y = X(), X.Y()
print x.__class__.__name__, y.__class__.__name__
#: X X.Y
print X.foo(x, 4), x.foo(5)
#: 4 5
print y.bar(1), y.bar('s'), X.Y.bar(y, True)
#: 1
#: s
#: True
#: 0 0 0

</t>
<t tx="ekr.20230509052845.4296">#%% rec_class_4,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
</t>
<t tx="ekr.20230509052845.4297">class B[T]:
    a: T
    b: A[T]
    c: B[T]
    @others
</t>
<t tx="ekr.20230509052845.4298">def __init__(self): pass
</t>
<t tx="ekr.20230509052845.4299">class Nest1[U]:
    n: U
</t>
<t tx="ekr.20230509052845.43">@path C:/Repos/codon/bench/chaos/
"""create chaosgame-like fractals
Copyright (C) 2005 Carl Friedrich Bolz

adapted by @arshajii for Codon
"""

import math
import random
import sys
import time

DEFAULT_THICKNESS = 1.0
DEFAULT_WIDTH = 2048 #256
DEFAULT_HEIGHT = 2048 #256
DEFAULT_ITERATIONS = 1000000 #5000
DEFAULT_RNG_SEED = 1234


@others
t0 = time.time()
main()
t1 = time.time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.430">class SingleConstantUnaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the output type
  types::Type *resultType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a unary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  /// @param resultType the output type
  SingleConstantUnaryRule(Func f, std::string magic, types::Type *inputType,
                          types::Type *resultType)
      : f(std::move(f)), inputType(inputType), resultType(resultType),
        magic(std::move(magic)) {}

  virtual ~SingleConstantUnaryRule() noexcept = default;

@others
private:
  Value *toValue(Value *, Value *v) { return v; }

  template &lt;typename NewType&gt; Value *toValue(Value *og, NewType v) {
    return og-&gt;getModule()-&gt;template N&lt;TemplatedConst&lt;NewType&gt;&gt;(og-&gt;getSrcInfo(), v,
                                                                resultType);
  }
};

</t>
<t tx="ekr.20230509052845.4300">class Nest2[T, U]:
    m: T
    n: U
</t>
<t tx="ekr.20230509052845.4301">b = B[float]()
print b.__class__.__name__, b.a.__class__.__name__, b.b.__class__.__name__, b.c.__class__.__name__, b.c.b.c.a.__class__.__name__
#: B[float] float A[float] B[float] str

n1 = B.Nest1[int]()
print n1.n, n1.__class__.__name__, n1.n.__class__.__name__ #: 0 B.Nest1[int] int

n1: B.Nest2 = B.Nest2[float, int]()
print (n1.m, n1.n), n1.__class__.__name__, n1.m.__class__.__name__, n1.n.__class__.__name__ #: (0, 0) B.Nest2[float,int] float int

</t>
<t tx="ekr.20230509052845.4302">#%% func_arg_instantiate,barebones
class A[T]:
    y: T
    def foo(self, y: T):
        self.y = y
        return y
    def bar(self, y):
        return y
</t>
<t tx="ekr.20230509052845.4303">a = A()
print a.__class__.__name__ #: A[int]
a.y = 5
print a.__class__.__name__ #: A[int]

b = A()
print b.foo(5) #: 5
print b.__class__.__name__, b.y #: A[int] 5
print b.bar('s'), b.bar('s').__class__.__name__ #: s str
print b.bar(5), b.bar(5).__class__.__name__ #: 5 int

aa = A()
print aa.foo('s') #: s
print aa.__class__.__name__, aa.y, aa.bar(5.1).__class__.__name__ #: A[str] s float

</t>
<t tx="ekr.20230509052845.4304">#%% no_func_arg_instantiate_err,barebones
# TODO: allow unbound self?
class A[T]:
    y: T
    def foo(self, y): self.y = y
</t>
<t tx="ekr.20230509052845.4305">a = A()
a.foo(1) #! cannot typecheck the program

</t>
<t tx="ekr.20230509052845.4306">#%% return_deduction,barebones
def fun[T, R](x, y: T) -&gt; R:
   	def ffi[T, R, Z](x: T, y: R, z: Z):
   		return (x, y, z)
   	yy = ffi(False, byte(2), 's', T=bool, Z=str, R=R)
   	yz = ffi(1, byte(2), 's', T=int, Z=str, R=R)
   	return byte(1)
</t>
<t tx="ekr.20230509052845.4307">print fun(2, 1.1, float, byte).__class__.__name__ #: byte

</t>
<t tx="ekr.20230509052845.4308">#%% return_auto_deduction_err,barebones
def fun[T, R](x, y: T) -&gt; R:
   	return byte(1)
</t>
<t tx="ekr.20230509052845.4309">print fun(2, 1.1).__class__.__name__ #! cannot typecheck the program

</t>
<t tx="ekr.20230509052845.431">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, resultType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    auto *argConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(arg);
    if (argConst)
      return setResult(toValue(v, f(argConst-&gt;getVal())));
  }

</t>
<t tx="ekr.20230509052845.4310">#%% random
# shuffle used to fail before for some reason (sth about unbound variables)...
def foo():
    from random import shuffle
    v = list(range(10))
    shuffle(v)
    print sorted(v) #: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
</t>
<t tx="ekr.20230509052845.4311">foo()

</t>
<t tx="ekr.20230509052845.4312">#%% function_type,barebones
class F:
    f: Function[[int], int]
    g: function[[int], None]
    x: int
</t>
<t tx="ekr.20230509052845.4313">def foo(x: int):
    return x+1
</t>
<t tx="ekr.20230509052845.4314">def goo(x: int):
    print x+2
</t>
<t tx="ekr.20230509052845.4315">f = F(foo, goo, 2)
print f.f(f.x) #: 3
f.g(f.x) #: 4

</t>
<t tx="ekr.20230509052845.4316">def hoo(z):
    print z+3
</t>
<t tx="ekr.20230509052845.4317">f.g = hoo
f.g(f.x)  #: 5

</t>
<t tx="ekr.20230509052845.4318">def hai(x, y, z):
    print f'hai({x},{y},{z})'
</t>
<t tx="ekr.20230509052845.4319">fn = Function[[int, int, int], None](hai)
fn(1, 2, 3) #: hai(1,2,3)
print str(fn)[:12] #: &lt;function at
z = fn(2, 3, ...)
z(3) #: hai(2,3,3)

#%% int_float,barebones
l = [1., 2, 3, 4]
print l, l.__class__.__name__ #: [1, 2, 3, 4] List[float]

</t>
<t tx="ekr.20230509052845.432">/// Unary rule that requires no constant.
template &lt;typename Func&gt; class UnaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a unary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  UnaryRule(Func f, std::string magic, types::Type *inputType)
      : f(std::move(f)), inputType(inputType), magic(std::move(magic)) {}

  virtual ~UnaryRule() noexcept = default;

</t>
<t tx="ekr.20230509052845.4320">#%% forward_fn,barebones
def test(name, sort, key):
    v1 = [1, 2, 3, 4]
    sp = sort(v1, key)
    print name, sp
</t>
<t tx="ekr.20230509052845.4321">def foo(l, f):
    return [f(i) for i in l]
</t>
<t tx="ekr.20230509052845.4322">test('hi', foo, lambda x: x+1) #: hi [2, 3, 4, 5]

</t>
<t tx="ekr.20230509052845.4323">def foof(l: List[int], x, f: Callable[[int], int]):
    return [f(i)+x for i in l]
</t>
<t tx="ekr.20230509052845.4324">test('qsort', foof(x=3, ...), lambda x: x+1) #: qsort [5, 6, 7, 8]

</t>
<t tx="ekr.20230509052845.4325">#%% class_fn_access,barebones
class X[T]:
    def foo[U](self, x: T, y: U):
        return (x+x, y+y)
</t>
<t tx="ekr.20230509052845.4326">y = X[X[int]]()
print y.__class__.__name__ #: X[X[int]]
print X[float].foo(U=int, ...).__class__.__name__ #: foo[X[float],float,int,int]
print X[int]().foo(1, 's') #: (2, 'ss')

</t>
<t tx="ekr.20230509052845.4327">#%% class_partial_access,barebones
class X[T]:
    def foo[U](self, x, y: U):
        return (x+x, y+y)
</t>
<t tx="ekr.20230509052845.4328">y = X[X[int]]()
# TODO: should this even be the case?
# print y.foo(U=float,...).__class__.__name__  -&gt;  X.foo[X[X[int]],...,...]
print y.foo(1, 2.2, float) #: (2, 4.4)

</t>
<t tx="ekr.20230509052845.4329">#%% forward,barebones
def foo(f, x):
    f(x, type(x))
    print f.__class__.__name__
</t>
<t tx="ekr.20230509052845.433">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(f(arg));
  }
</t>
<t tx="ekr.20230509052845.4330">def bar[T](x):
    print x, T.__class__.__name__
</t>
<t tx="ekr.20230509052845.4331">foo(bar, 1)
#: 1 int
#: bar[...]
foo(bar(...), 's')
#: s str
#: bar[...]
z = bar
z('s', int)
#: s int
z(1, T=str)
#: 1 str

zz = bar(T=int,...)
zz(1)
#: 1 int

</t>
<t tx="ekr.20230509052845.4332">#%% forward_error,barebones
def foo(f, x):
    f(x, type(x))
    print f.__class__.__name__
</t>
<t tx="ekr.20230509052845.4333">def bar[T](x):
    print x, T.__class__.__name__
</t>
<t tx="ekr.20230509052845.4334">foo(bar(T=int,...), 1)
#! bar() takes 2 arguments (2 given)
#! during the realization of foo(f: bar[...], x: int)
# TODO fix this error message

</t>
<t tx="ekr.20230509052845.4335">#%% sort_partial
def foo(x, y):
    return y**x
</t>
<t tx="ekr.20230509052845.4336">print sorted([1,2,3,4,5], key=foo(y=2, ...))
print sorted([1,2,3,4,5], key=foo(y=-2, ...))
#: [1, 2, 3, 4, 5]
#: [5, 3, 1, 2, 4]

</t>
<t tx="ekr.20230509052845.4337">#%% mutually_recursive_error,barebones
def bl(x):
    return True
</t>
<t tx="ekr.20230509052845.4338">def frec(x, y):
    def grec(x, y):
        return frec(y, x)
    return grec(x, y) if bl(y) else 2
</t>
<t tx="ekr.20230509052845.4339">print frec(1, 2).__class__.__name__, frec('s', 1).__class__.__name__
#! 'NoneType' does not match expected type 'int'
#! during the realization of frec(x: int, y: int)

</t>
<t tx="ekr.20230509052845.434">};

</t>
<t tx="ekr.20230509052845.4340">#%% return_fn,barebones
def retfn(a):
    def inner(b, *args, **kwargs):
        print a, b, args, kwargs
    print inner.__class__.__name__ #: inner[...,...,int,...]
    return inner(15, ...)
</t>
<t tx="ekr.20230509052845.4341">f = retfn(1)
print f.__class__.__name__ #: inner[int,...,int,...]
f(2,3,foo='bar') #: 1 15 (2, 3) (foo: 'bar')

</t>
<t tx="ekr.20230509052845.4342">#%% decorator_manual,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
    return 1
</t>
<t tx="ekr.20230509052845.4343">def dec(fn, a):
    print 'decorating', fn.__class__.__name__ #: decorating foo[...,...,...]
    def inner(*args, **kwargs):
        print 'decorator', args, kwargs #: decorator (5.5, 's') (z: True)
        return fn(a, *args, **kwargs)
    return inner(...)
</t>
<t tx="ekr.20230509052845.4344">ff = dec(foo(...), 10)
print ff(5.5, 's', z=True)
#: 10 (5.5, 's') (z: True)
#: 1


</t>
<t tx="ekr.20230509052845.4345">#%% decorator,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
    return 1
</t>
<t tx="ekr.20230509052845.4346">def dec(a):
    def f(fn):
        print 'decorating', fn.__class__.__name__
        def inner(*args, **kwargs):
            print 'decorator', args, kwargs
            return fn(a, *args, **kwargs)
        return inner
    return f
</t>
<t tx="ekr.20230509052845.4347">ff = dec(10)(foo)
print ff(5.5, 's', z=True)
#: decorating foo[...,...,...]
#: decorator (5.5, 's') (z: True)
#: 10 (5.5, 's') (z: True)
#: 1

</t>
<t tx="ekr.20230509052845.4348">@dec(a=5)
def zoo(e, b, *args):
    return f'zoo: {e}, {b}, {args}'
</t>
<t tx="ekr.20230509052845.4349">print zoo(2, 3)
print zoo('s', 3)
#: decorating zoo[...,...,...]
#: decorator (2, 3) ()
#: zoo: 5, 2, (3)
#: decorator ('s', 3) ()
#: zoo: 5, s, (3)

</t>
<t tx="ekr.20230509052845.435">/// Rule that eliminates an operation, like "+x".
class NoOpRule : public RewriteRule {
private:
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a no-op rule.
  /// @param magic the magic method name
  /// @param inputType the input type
  NoOpRule(std::string magic, types::Type *inputType)
      : inputType(inputType), magic(std::move(magic)) {}

  virtual ~NoOpRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509052845.4350">def mydecorator(func):
    def inner():
        print("before")
        func()
        print("after")
    return inner
</t>
<t tx="ekr.20230509052845.4351">@mydecorator
def foo2():
    print("foo")
</t>
<t tx="ekr.20230509052845.4352">foo2()
#: before
#: foo
#: after

</t>
<t tx="ekr.20230509052845.4353">def timeme(func):
    def inner(*args, **kwargs):
        begin = 1
        end = func(*args, **kwargs) - begin
        print('time needed for', func.__class__.__name__, 'is', end)
    return inner
</t>
<t tx="ekr.20230509052845.4354">@timeme
def factorial(num):
    n = 1
    for i in range(1,num + 1):
        n *= i
    print(n)
    return n
</t>
<t tx="ekr.20230509052845.4355">factorial(10)
#: 3628800
#: time needed for factorial[...] is 3628799

</t>
<t tx="ekr.20230509052845.4356">def dx1(func):
    def inner():
        x = func()
        return x * x
    return inner
</t>
<t tx="ekr.20230509052845.4357">def dx2(func):
    def inner():
        x = func()
        return 2 * x
    return inner
</t>
<t tx="ekr.20230509052845.4358">@dx1
@dx2
def num():
    return 10
</t>
<t tx="ekr.20230509052845.4359">print(num()) #: 400

</t>
<t tx="ekr.20230509052845.436">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(arg);
  }
</t>
<t tx="ekr.20230509052845.4360">def dy1(func):
    def inner(*a, **kw):
        x = func(*a, **kw)
        return x * x
    return inner
</t>
<t tx="ekr.20230509052845.4361">def dy2(func):
    def inner(*a, **kw):
        x = func(*a, **kw)
        return 2 * x
    return inner
</t>
<t tx="ekr.20230509052845.4362">@dy1
@dy2
def num2(a, b):
    return a+b
</t>
<t tx="ekr.20230509052845.4363">print(num2(10, 20)) #: 3600

#%% hetero_iter,barebones
e = (1, 2, 3, 'foo', 5, 'bar', 6)
for i in e:
    if isinstance(i, int):
        if i == 1: continue
    if isinstance(i, str):
        if i == 'bar': break
    print i

#%% type_loc,barebones
a = 1
T = type(a)
print T.__class__.__name__  #: int

#%% empty_tuple,barebones
T = type(())  # only errors with empty tuple type
p = Ptr[T](cobj())
print p.__class__.__name__  #: Ptr[Tuple]

print [a for a in ()]  #: []

</t>
<t tx="ekr.20230509052845.4364">def foo(*args):
    return [a for a in args]
</t>
<t tx="ekr.20230509052845.4365">args, result = ((), [()])
print list(foo(*args))  #: []
print result  #: [()]


</t>
<t tx="ekr.20230509052845.4366">#%% type_error_reporting
# TODO: improve this certainly
def tee(iterable, n=2):
    from collections import deque
    it = iter(iterable)
    deques = [deque() for i in range(n)]
    @others
    return list(gen(d) for d in deques)
</t>
<t tx="ekr.20230509052845.4367">def gen(mydeque):
    while True:
        if not mydeque:             # when the local deque is empty
            if it.done():
                return
            newval = it.next()
            for d in deques:        # load it to all the deques
                d.append(newval)
        yield mydeque.popleft()
</t>
<t tx="ekr.20230509052845.4368">it = [1,2,3,4]
a, b = tee(it)
#! cannot typecheck the program
#! during the realization of tee(iterable: List[int], n: int)

</t>
<t tx="ekr.20230509052845.4369">#%% new_syntax,barebones
def foo[T,U](x: type, y, z: Static[int] = 10):
    print T.__class__.__name__, U.__class__.__name__, x.__class__.__name__, y.__class__.__name__, Int[z+1].__class__.__name__
    return List[x]()
</t>
<t tx="ekr.20230509052845.437">/// Rule that eliminates a double-application of an operation, like "-(-x)".
class DoubleApplicationNoOpRule : public RewriteRule {
private:
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a double-application no-op rule.
  /// @param magic the magic method name
  /// @param inputType the input type
  DoubleApplicationNoOpRule(std::string magic, types::Type *inputType)
      : inputType(inputType), magic(std::move(magic)) {}

  virtual ~DoubleApplicationNoOpRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509052845.4370">print foo(T=int,U=str,...).__class__.__name__ #: foo[T1,x,z,int,str]
print foo(T=int,U=str,z=5,x=bool,...).__class__.__name__ #: foo[T1,bool,5,int,str]
print foo(float,3,T=int,U=str,z=5).__class__.__name__ #: List[float]
foo(float,1,10,str,int) #: str int float int Int[11]


</t>
<t tx="ekr.20230509052845.4371">class Foo[T,U: Static[int]]:
    a: T
    b: Static[int]
    c: Int[U]
    d: type
    e: List[d]
    f: UInt[b]
</t>
<t tx="ekr.20230509052845.4372">print Foo[5,int,float,6].__class__.__name__ #: Foo[5,int,float,6]
print Foo(1.1, 10i32, [False], 10u66).__class__.__name__ #: Foo[66,bool,float,32]


</t>
<t tx="ekr.20230509052845.4373">def foo2[N: Static[int]]():
    print Int[N].__class__.__name__, N
</t>
<t tx="ekr.20230509052845.4374">x: Static[int] = 5
y: Static[int] = 105 - x * 2
foo2(y-x) #: Int[90] 90

if 1.1+2.2 &gt; 0:
    z: Static[int] = 88
    print z #: 88
print x #: 5
x : Static[int] = 3
print x #: 3

</t>
<t tx="ekr.20230509052845.4375">def fox(N: Static[int] = 4):
    print Int[N].__class__.__name__, N
</t>
<t tx="ekr.20230509052845.4376">fox(5) #: Int[5] 5
fox() #: Int[4] 4

</t>
<t tx="ekr.20230509052845.4377">#%% new_syntax_err,barebones
class Foo[T,U: Static[int]]:
    a: T
    b: Static[int]
    c: Int[U]
    d: type
    e: List[d]
    f: UInt[b]
</t>
<t tx="ekr.20230509052845.4378">print Foo[float,6].__class__.__name__ #! Foo takes 4 generics (2 given)

#%% partial_star_pipe_args,barebones
iter(['A', 'C']) |&gt; print
#: A
#: C
iter(range(4)) |&gt; print('x', ..., 1)
#: x 0 1
#: x 1 1
#: x 2 1
#: x 3 1

#%% type_arg_transform,barebones
print list(map(str, range(5)))
#: ['0', '1', '2', '3', '4']


</t>
<t tx="ekr.20230509052845.4379">#%% traits,barebones
def t[T](x: T, key: Optional[Callable[[T], S]] = None, S: type = NoneType):
    if isinstance(S, NoneType):
        return x
    else:
        return (key.__val__())(x)
</t>
<t tx="ekr.20230509052845.438">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    if (!util::isCallOf(v-&gt;front(), magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(cast&lt;CallInstr&gt;(arg)-&gt;front());
  }
</t>
<t tx="ekr.20230509052845.4380">print t(5) #: 5
print t(6, lambda x: f'#{x}') #: #6

z: Callable[[int],int] = lambda x: x+1
print z(5) #: 6

</t>
<t tx="ekr.20230509052845.4381">def foo[T](x: T, func: Optional[Callable[[], T]] = None) -&gt; T:
    return x
</t>
<t tx="ekr.20230509052845.4382">print foo(1) #: 1

#%% trait_callable
foo = [1,2,11]
print(sorted(foo, key=str))
#: [1, 11, 2]

foo = {1: "a", 2: "a", 11: "c"}
print(sorted(foo.items(), key=str))
#: [(1, 'a'), (11, 'c'), (2, 'a')]

</t>
<t tx="ekr.20230509052845.4383">def call(f: Callable[[int,int], Tuple[str,int]]):
    print(f(1, 2))

</t>
<t tx="ekr.20230509052845.4384">def foo(*x): return f"{x}_{x.__class__.__name__}",1
</t>
<t tx="ekr.20230509052845.4385">call(foo)
#: ('(1, 2)_Tuple[int,int]', 1)

</t>
<t tx="ekr.20230509052845.4386">def foo(a:int, *b: float): return f"{a}_{b}", a+b[0]
</t>
<t tx="ekr.20230509052845.4387">call(foo)
#: ('1_(2)', 3)

</t>
<t tx="ekr.20230509052845.4388">def call(f: Callable[[int,int],str]):
    print(f(1, 2))
</t>
<t tx="ekr.20230509052845.4389">def foo(a: int, *b: int, **kw): return f"{a}_{b}_{kw}"
</t>
<t tx="ekr.20230509052845.439"></t>
<t tx="ekr.20230509052845.4390">call(foo(zzz=1.1, ...))
#: 1_(2)_(zzz: 1.1)

</t>
<t tx="ekr.20230509052845.4391">#%% traits_error,barebones
def t[T](x: T, key: Optional[Callable[[T], S]] = None, S: type = NoneType):
    if isinstance(S, NoneType):
        return x
    else:
        return (key.__val__())(x)
</t>
<t tx="ekr.20230509052845.4392">print t(6, Optional(1)) #! 'Optional[int]' does not match expected type 'Optional[Callable[[int],S]]'

#%% traits_error_2,barebones
z: Callable[[int],int] = 4 #! 'Callable[[int],int]' does not match expected type 'int'

#%% assign_wrappers,barebones
a = 1.5
print a #: 1.5
if 1:
    a = 1
print a, a.__class__.__name__ #: 1 float

a: Optional[int] = None
if 1:
    a = 5
print a.__class__.__name__, a #: Optional[int] 5

b = 5
c = Optional(6)
if 1:
    b = c
print b.__class__.__name__, c.__class__.__name__, b, c #: int Optional[int] 6 6

z: Generator[int] = [1, 2]
print z.__class__.__name__ #: Generator[int]

zx: float = 1
print zx.__class__.__name__, zx #: float 1

</t>
<t tx="ekr.20230509052845.4393">def test(v: Optional[int]):
    v: int = v if v is not None else 3
    print v.__class__.__name__
</t>
<t tx="ekr.20230509052845.4394">test(5) #: int
test(None) #: int

</t>
<t tx="ekr.20230509052845.4395">#%% methodcaller,barebones
def foo():
    def bar(a, b):
        print 'bar', a, b
    return bar
</t>
<t tx="ekr.20230509052845.4396">foo()(1, 2) #: bar 1 2

</t>
<t tx="ekr.20230509052845.4397">def methodcaller(foo: Static[str]):
    def caller(foo: Static[str], obj, *args, **kwargs):
        if isinstance(getattr(obj, foo)(*args, **kwargs), None):
            getattr(obj, foo)(*args, **kwargs)
        else:
            return getattr(obj, foo)(*args, **kwargs)
    return caller(foo=foo, ...)
</t>
<t tx="ekr.20230509052845.4398">v = [1]
methodcaller('append')(v, 42)
print v #: [1, 42]
print methodcaller('index')(v, 42) #: 1

</t>
<t tx="ekr.20230509052845.4399">#%% fn_overloads,barebones
def foo(x):
    return 1, x

</t>
<t tx="ekr.20230509052845.44">class GVector(object):

    @others
</t>
<t tx="ekr.20230509052845.440">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {

@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4400">print(foo(''))  #: (1, '')

</t>
<t tx="ekr.20230509052845.4401">@overload
def foo(x, y):
    def foo(x, y):
        return f'{x}_{y}'
    return 2, foo(x, y)

</t>
<t tx="ekr.20230509052845.4402">@overload
def foo(x):
    if x == '':
        return 3, 0
    return 3, 1 + foo(x[1:])[1]

</t>
<t tx="ekr.20230509052845.4403">print foo('hi') #: (3, 2)
print foo('hi', 1) #: (2, 'hi_1')

</t>
<t tx="ekr.20230509052845.4404">#%% fn_shadow,barebones
def foo(x):
    return 1, x
</t>
<t tx="ekr.20230509052845.4405">print foo('hi') #: (1, 'hi')

</t>
<t tx="ekr.20230509052845.4406">def foo(x):
    return 2, x
</t>
<t tx="ekr.20230509052845.4407">print foo('hi') #: (2, 'hi')

</t>
<t tx="ekr.20230509052845.4408">#%% fn_overloads_error,barebones
def foo(x):
    return 1, x
</t>
<t tx="ekr.20230509052845.4409">@overload
def foo(x, y):
    return 2, x, y
</t>
<t tx="ekr.20230509052845.441">class ImperativeForFlowLowering : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(ForFlow *v) override;
};

</t>
<t tx="ekr.20230509052845.4410">foo('hooooooooy!', 1, 2) #! no function 'foo' with arguments (str, int, int)

#%% c_void_return,barebones
from C import seq_print(str)
x = seq_print("not ")
print x  #: not None


</t>
<t tx="ekr.20230509052845.4411">#%% static_for,barebones
def foo(i: Static[int]):
    print('static', i, Int[i].__class__.__name__)

</t>
<t tx="ekr.20230509052845.4412">for i in statictuple(1, 2, 3, 4, 5):
    foo(i)
    if i == 3: break
#: static 1 Int[1]
#: static 2 Int[2]
#: static 3 Int[3]
for i in staticrange(9, 4, -2):
    foo(i)
    if i == 3:
        break
#: static 9 Int[9]
#: static 7 Int[7]
#: static 5 Int[5]
for i in statictuple("x", 1, 3.3, 2):
    print(i)
#: x
#: 1
#: 3.3
#: 2

print tuple(Int[i+10](i) for i in statictuple(1, 2, 3)).__class__.__name__
#: Tuple[Int[11],Int[12],Int[13]]

for i in staticrange(0, 10):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[1]
#: xyz Int[3]
#: xyz Int[5]
#: xyz Int[7]
#: whoa

for i in staticrange(15):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[1]
#: xyz Int[3]
#: xyz Int[5]
#: xyz Int[7]
#: whoa

print tuple(Int[i-10](i) for i in staticrange(30,33)).__class__.__name__
#: Tuple[Int[20],Int[21],Int[22]]

for i in statictuple(0, 2, 4, 7, 11, 12, 13):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[7]
#: whoa

for i in staticrange(10):  # TODO: large values are too slow!
    pass
print('done')
#: done

tt = (5, 'x', 3.14, False, [1, 2])
for i, j in staticenumerate(tt):
    print(foo(i * 2 + 1), j)
#: static 1 Int[1]
#: None 5
#: static 3 Int[3]
#: None x
#: static 5 Int[5]
#: None 3.14
#: static 7 Int[7]
#: None False
#: static 9 Int[9]
#: None [1, 2]

print tuple((Int[i+1](i), j) for i, j in staticenumerate(tt)).__class__.__name__
#: Tuple[Tuple[Int[1],int],Tuple[Int[2],str],Tuple[Int[3],float],Tuple[Int[4],bool],Tuple[Int[5],List[int]]]

#%% static_range_error,barebones
for i in staticrange(1000, -2000, -2):
    pass
#! staticrange too large (expected 0..1024, got instead 1500)

</t>
<t tx="ekr.20230509052845.4413">#%% trait_defdict
class dd(Static[Dict[K,V]]):
    fn: S
    K: type
    V: type
    S: TypeVar[Callable[[], V]]

    @others
</t>
<t tx="ekr.20230509052845.4414">def __init__(self: dd[K, VV, Function[[], V]], VV: TypeVar[V]):
    self.fn = lambda: VV()

</t>
<t tx="ekr.20230509052845.4415">def __init__(self, f: S):
    self.fn = f

</t>
<t tx="ekr.20230509052845.4416">def __getitem__(self, key: K) -&gt; V:
    if key not in self:
        self.__setitem__(key, self.fn())
    return super().__getitem__(key)


</t>
<t tx="ekr.20230509052845.4417">x = dd(list)
x[1] = [1, 2]
print(x[2])
#: []
print(x)
#: {1: [1, 2], 2: []}

z = 5
y = dd(lambda: z+1)
y.update({'a': 5})
print(y['b'])
#: 6
z = 6
print(y['c'])
#: 7
print(y)
#: {'a': 5, 'b': 6, 'c': 7}

xx = dd(lambda: 'empty')
xx.update({1: 's', 2: 'b'})
print(xx[1], xx[44])
#: s empty
print(xx)
#: {44: 'empty', 1: 's', 2: 'b'}

s = 'mississippi'
d = dd(int)
for k in s:
    d[k] = d["x" + k]
print(sorted(d.items()))
#: [('i', 0), ('m', 0), ('p', 0), ('s', 0), ('xi', 0), ('xm', 0), ('xp', 0), ('xs', 0)]


</t>
<t tx="ekr.20230509052845.4418">#%% kwargs_getattr,barebones
def foo(**kwargs):
    print kwargs['foo'], kwargs['bar']

</t>
<t tx="ekr.20230509052845.4419">foo(foo=1, bar='s')
#: 1 s



</t>
<t tx="ekr.20230509052845.442">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {

@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4420">#%% union_types,barebones
def foo_int(x: int):
    print(f'{x} {x.__class__.__name__}')
</t>
<t tx="ekr.20230509052845.4421">def foo_str(x: str):
    print(f'{x} {x.__class__.__name__}')
</t>
<t tx="ekr.20230509052845.4422">def foo(x):
    print(f'{x} {int(__internal__.union_get_tag(x))} {x.__class__.__name__}')

</t>
<t tx="ekr.20230509052845.4423">a: Union[int, str] = 5
foo_int(a)  #: 5 int
foo(a)  #: 5 0 Union[int,str]
print(staticlen(a))  #: 2
print(staticlen(Union[int, int]), staticlen(Tuple[int, float, int]))  #: 1 3

</t>
<t tx="ekr.20230509052845.4424">@extend
class str:
    def __add__(self, i: int):
        return int(self) + i

</t>
<t tx="ekr.20230509052845.4425">a += 6  ## this is U.__new__(a.__getter__(__add__)(59))
b = a + 59
print(a, b, a.__class__.__name__, b.__class__.__name__)  #: 11 70 Union[int,str] int

if True:
    a = 'hello'
    foo_str(a)  #: hello str
    foo(a)  #: 'hello' 1 Union[int,str]
    # b = a[1:3]
    # print(b)
print(a)  #: 'hello'

a: Union[Union[Union[str], int], Union[int, int, str]] = 9
foo(a)  #: 9 0 Union[int,str]

</t>
<t tx="ekr.20230509052845.4426">def ret(x):
    z : Union = x
    if x &lt; 1: z = 1
    elif x &lt; 10: z = False
    else: z = 'oops'
    return z
</t>
<t tx="ekr.20230509052845.4427">r = ret(2)
print(r, r.__class__.__name__)  #: False Union[bool,int,str]
r = ret(33.3)
print(r, r.__class__.__name__)  #: 'oops' Union[bool,float,int,str]

</t>
<t tx="ekr.20230509052845.4428">def ret2(x) -&gt; Union:
    if x &lt; 1: return 1
    elif x &lt; 10: return 2.2
    else: return ['oops']
</t>
<t tx="ekr.20230509052845.4429">r = ret2(20)
print(r, r.__class__.__name__)  #: ['oops'] Union[List[str],float,int]

</t>
<t tx="ekr.20230509052845.443">/// Converts pipelines to for-loops
class PipelineLowering : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(PipelineFlow *v) override;
};

</t>
<t tx="ekr.20230509052845.4430">class A:
    x: int
    def foo(self):
        return f"A: {self.x}"
</t>
<t tx="ekr.20230509052845.4431">class B:
    y: str
    def foo(self):
        return f"B: {self.y}"
</t>
<t tx="ekr.20230509052845.4432">x : Union[A,B] = A(5)  # TODO: just Union does not work :/
print(x.foo())  #: A: 5
if True:
    x = B("bee")
print(x.foo())  #: B: bee

</t>
<t tx="ekr.20230509052845.4433">def do(x: A):
    print('do', x.x)
</t>
<t tx="ekr.20230509052845.4434">try:
    do(x)
except TypeError:
    print('error') #: error

</t>
<t tx="ekr.20230509052845.4435">def do2(x: B):
    print('do2', x.y)
</t>
<t tx="ekr.20230509052845.4436">do2(x)  #: do2 bee

z: Union[int, str] = 1
print isinstance(z, int), isinstance(z, str), isinstance(z, float), isinstance(z, Union[int, float]), isinstance(z, Union[int, str])
#: True False False False True

print isinstance(z, Union[int]), isinstance(z, Union[int, float, str])
#: False False

if True:
    z = 's'
print isinstance(z, int), isinstance(z, str), isinstance(z, float), isinstance(z, Union[int, float]), isinstance(z, Union[int, str])
#: False True False False True

</t>
<t tx="ekr.20230509052845.4437">class A:
    def foo(self): return 1
</t>
<t tx="ekr.20230509052845.4438">class B:
    def foo(self): return 's'
</t>
<t tx="ekr.20230509052845.4439">class C:
    def foo(self): return [True, False]
</t>
<t tx="ekr.20230509052845.444"></t>
<t tx="ekr.20230509052845.4440">x : Union[A,B,C] = A()
print x.foo(), x.foo().__class__.__name__
#: 1 Union[List[bool],int,str]

xx = Union[int, str](0)
print(xx)  #: 0

#%% union_error,barebones
a: Union[int, str] = 123
print(123 == a)  #: True
print(a == 123)  #: True
try:
    a = "foo"
    print(a == 123)
except TypeError:
    print("oops", a)  #: oops 'foo'


</t>
<t tx="ekr.20230509052845.4441">#%% generator_capture_nonglobal,barebones
# Issue #49
def foo(iter):
    print(iter.__class__.__name__, list(iter))

</t>
<t tx="ekr.20230509052845.4442">for x in range(2):
    foo(1 for _ in range(x))
#: Generator[int] []
#: Generator[int] [1]
for x in range(2):
    for y in range(x):
        foo('z' for _ in range(y))
#: Generator[str] []

</t>
<t tx="ekr.20230509052845.4443">#%% nonlocal_capture_loop,barebones
# Issue #51
def kernel(fn):
    def wrapper(*args, grid, block):
        print(grid, block, fn(*args))
    return wrapper
</t>
<t tx="ekr.20230509052845.4444">def test_mandelbrot():
    MAX    = 10  # maximum Mandelbrot iterations
    N      = 2   # width and height of image
    pixels = [0 for _ in range(N)]
    @others
    k(pixels, grid=(N*N)//1024, block=1024)
</t>
<t tx="ekr.20230509052845.4445">def scale(x, a, b):
    return a + (x/N)*(b - a)
</t>
<t tx="ekr.20230509052845.4446">@kernel
def k(pixels):
    i = 0
    while i &lt; MAX: i += 1  # this is needed for test to make sense
    return (MAX, N, pixels, scale(N, -2, 0.4))
</t>
<t tx="ekr.20230509052845.4447">test_mandelbrot()  #: 0 1024 (10, 2, [0, 0], 0.4)

#%% delayed_lambda_realization,barebones
x = []
for i in range(2):
    print(all(x[j] &lt; 0 for j in range(i)))
    x.append(i)
#: True
#: False

</t>
<t tx="ekr.20230509052845.4448">#%% constructor_passing
class A:
    s: str
    def __init__(self, x):
        self.s = str(x)[::-1]
    def __lt__(self, o): return self.s &lt; o.s
    def __eq__(self, o): return self.s == o.s
    def __ge__(self, o): return self.s &gt;= o.s
</t>
<t tx="ekr.20230509052845.4449">foo = [1,2,11,30]
print(sorted(foo, key=str))
#: [1, 11, 2, 30]
print(sorted(foo, key=A))
#: [30, 1, 11, 2]


</t>
<t tx="ekr.20230509052845.445">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace parallel {

@others
} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4450">#%% polymorphism,barebones
class A:
    a: int
    def foo(self, a: int): return (f'A({self.a})', a)
    def bar(self): return 'A.bar'
    def aaz(self): return 'A.aaz'
</t>
<t tx="ekr.20230509052845.4451">class B(A):
    b: int
    def foo(self, a): return (f'B({self.a},{self.b})', a + self.b)
    def bar(self): return 'B.bar'
    def baz(self): return 'B.baz'
</t>
<t tx="ekr.20230509052845.4452">class M[T]:
    m: T
    def moo(self): return (f'M_{T.__class__.__name__}', self.m)
</t>
<t tx="ekr.20230509052845.4453">class X(B,M[int]):
    def foo(self, a): return (f'X({self.a},{self.b},{self.m})', a + self.b + self.m)
    def bar(self): return 'X.bar'

</t>
<t tx="ekr.20230509052845.4454">def foo(i):
    x = i.foo(1)
    y = i.bar()
    z = i.aaz()
    print(*x, y, z)
</t>
<t tx="ekr.20230509052845.4455">a = A(1)
l = [a, B(2,3), X(2,3,-1)]
for i in l: foo(i)
#: A(1) 1 A.bar A.aaz
#: B(2,3) 4 B.bar A.aaz
#: X(2,3,-1) 3 X.bar A.aaz

</t>
<t tx="ekr.20230509052845.4456">def moo(m: M):
    print(m.moo())
</t>
<t tx="ekr.20230509052845.4457">moo(M[float](5.5))
moo(X(1,2,3))
#: ('M_float', 5.5)
#: ('M_int', 3)


</t>
<t tx="ekr.20230509052845.4458">class A[T]:
    def __init__(self):
        print("init A", T.__class__.__name__)
</t>
<t tx="ekr.20230509052845.4459">class Ho:
    def __init__(self):
        print("init Ho")
</t>
<t tx="ekr.20230509052845.446">class OpenMPPass : public OperatorPass {
public:
  /// Constructs an OpenMP pass.
  OpenMPPass() : OperatorPass(/*childrenFirst=*/true) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void handle(ForFlow *) override;
  void handle(ImperativeForFlow *) override;
};

</t>
<t tx="ekr.20230509052845.4460"># TODO: this throws and error: B[U](U)
class B[U](A[U], Ho):
    def __init__(self):
        super().__init__()
        print("init B", U.__class__.__name__)
</t>
<t tx="ekr.20230509052845.4461">B[Ho]()
#: init A Ho
#: init B Ho


</t>
<t tx="ekr.20230509052845.4462">class Vehicle:
    def drive(self):
        return "I'm driving a vehicle"

</t>
<t tx="ekr.20230509052845.4463">class Car(Vehicle):
    def drive(self):
        return "I'm driving a car"

</t>
<t tx="ekr.20230509052845.4464">class Truck(Vehicle):
    def drive(self):
        return "I'm driving a truck"

</t>
<t tx="ekr.20230509052845.4465">class SUV(Car, Truck):
    def drive(self):
        return "I'm driving an SUV"

</t>
<t tx="ekr.20230509052845.4466">suv = SUV()
</t>
<t tx="ekr.20230509052845.4467">def moo(s):
    print(s.drive())
</t>
<t tx="ekr.20230509052845.4468">moo(suv)
moo(Truck())
moo(Car())
moo(Vehicle())
#: I'm driving an SUV
#: I'm driving a truck
#: I'm driving a car
#: I'm driving a vehicle


</t>
<t tx="ekr.20230509052845.4469">#%% polymorphism_error_1,barebones
class M[T]:
    m: T
</t>
<t tx="ekr.20230509052845.447">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/value.h"

namespace codon {
namespace ir {

class Value;

namespace transform {
namespace parallel {

struct OMPSched {
  int code;
  bool dynamic;
  Value *threads;
  Value *chunk;
  bool ordered;
  int64_t collapse;
  bool gpu;

  explicit OMPSched(int code = -1, bool dynamic = false, Value *threads = nullptr,
                    Value *chunk = nullptr, bool ordered = false, int64_t collapse = 0,
                    bool gpu = false);
  explicit OMPSched(const std::string &amp;code, Value *threads = nullptr,
                    Value *chunk = nullptr, bool ordered = false, int64_t collapse = 0,
                    bool gpu = false);
  OMPSched(const OMPSched &amp;s)
      : code(s.code), dynamic(s.dynamic), threads(s.threads), chunk(s.chunk),
        ordered(s.ordered), collapse(s.collapse), gpu(s.gpu) {}

  std::vector&lt;Value *&gt; getUsedValues() const;
  int replaceUsedValue(id_t id, Value *newValue);
};

} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4470">class X(M[int]):
    pass
</t>
<t tx="ekr.20230509052845.4471">l = [M[float](1.1), X(2)]
#! 'List[M[float]]' object has no method 'append' with arguments (List[M[float]], X)

</t>
<t tx="ekr.20230509052845.4472">#%% polymorphism_2
class Expr:
    def __init__(self):
        pass
    def eval(self):
        raise ValueError('invalid expr')
        return 0.0
    def __str__(self):
        return "Expr"
</t>
<t tx="ekr.20230509052845.4473">class Const(Expr):
    x: float
    def __init__(self, x):
        self.x=x
    def __str__(self):
        return f"{self.x}"
    def eval(self):
        return self.x
</t>
<t tx="ekr.20230509052845.4474">class Add(Expr):
    lhs: Expr
    rhs: Expr
    @others
</t>
<t tx="ekr.20230509052845.4475">def __init__(self, lhs, rhs):
    self.lhs=lhs
    self.rhs=rhs
    # print(f'ctr: {self}')
</t>
<t tx="ekr.20230509052845.4476">def eval(self):
    return self.lhs.eval()+self.rhs.eval()
</t>
<t tx="ekr.20230509052845.4477">def __str__(self):
    return f"({self.lhs}) + ({self.rhs})"
</t>
<t tx="ekr.20230509052845.4478">class Mul(Expr):
    lhs: Expr
    rhs: Expr
    @others
</t>
<t tx="ekr.20230509052845.4479">def __init__(self, lhs, rhs):
    self.lhs=lhs
    self.rhs=rhs
</t>
<t tx="ekr.20230509052845.448"></t>
<t tx="ekr.20230509052845.4480">def eval(self):
    return self.lhs.eval()*self.rhs.eval()
</t>
<t tx="ekr.20230509052845.4481">def __str__(self):
    return f"({self.lhs}) * ({self.rhs})"

</t>
<t tx="ekr.20230509052845.4482">c1 = Const(5)
c2 = Const(4)
m = Add(c1, c2)
c3 = Const(2)
a : Expr = Mul(m, c3)
print(f'{a} = {a.eval()}')
#: ((5) + (4)) * (2) = 18

from random import random, seed
seed(137)
</t>
<t tx="ekr.20230509052845.4483">def random_expr(depth) -&gt; Expr:
    if depth&lt;=0:
        return Const(int(random()*42.0))
    else:
        lhs=random_expr(depth-1)
        rhs=random_expr(depth-1)
        ctorid = int(random()*3)
        if ctorid==0:
            return Mul(lhs,rhs)
        else:
            return Add(lhs,rhs)
</t>
<t tx="ekr.20230509052845.4484">for i in range(11):
    print(random_expr(i).eval())
#: 17
#: 71
#: 1760
#: 118440
#: 94442
#: 8.02435e+15
#: 1.07463e+13
#: 1.43017e+19
#: 2.40292e+34
#: 6.1307e+28
#: 5.16611e+49


#%% collection_common_type,barebones
l = [1, 2, 3]
print(l, l.__class__.__name__)
#: [1, 2, 3] List[int]

l = [1.1, 2, 3]
print(l, l.__class__.__name__)
#: [1.1, 2, 3] List[float]

l = [1, 2, 3.3]
print(l, l.__class__.__name__)
#: [1, 2, 3.3] List[float]

l = [1, None]
print(l, l.__class__.__name__)
#: [1, None] List[Optional[int]]

l = [None, 2.2]
print(l, l.__class__.__name__)
#: [None, 2.2] List[Optional[float]]

</t>
<t tx="ekr.20230509052845.4485">class A:
    def __repr__(self): return 'A'
</t>
<t tx="ekr.20230509052845.4486">class B(A):
    def __repr__(self): return 'B'
</t>
<t tx="ekr.20230509052845.4487">class C(B):
    def __repr__(self): return 'C'
</t>
<t tx="ekr.20230509052845.4488">class D(A):
    def __repr__(self): return 'D'

</t>
<t tx="ekr.20230509052845.4489">l = [A(), B(), C(), D()]
print(l, l.__class__.__name__)
#: [A, B, C, D] List[A]

l = [D(), C(), B(), A()]
print(l, l.__class__.__name__)
#: [D, C, B, A] List[A]

l = [C(), B()]
print(l, l.__class__.__name__)
#: [C, B] List[B]

l = [C(), A(), B()]
print(l, l.__class__.__name__)
#: [C, A, B] List[A]

l = [None, *[1, 2], None]
print(l, l.__class__.__name__)
#: [None, 1, 2, None] List[Optional[int]]

# l = [C(), D(), B()] # does not work (correct behaviour)
# print(l, l.__class__.__name__)

d = {1: None, 2.2: 's'}
print(d, d.__class__.__name__)
#: {1: None, 2.2: 's'} Dict[float,Optional[str]]

#%% polymorphism_3
import operator

</t>
<t tx="ekr.20230509052845.449">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4490">class Expr:
    def eval(self):
        return 0

</t>
<t tx="ekr.20230509052845.4491">class Const(Expr):
    value: int

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

</t>
<t tx="ekr.20230509052845.4492">class BinOp(Expr):
    lhs: Expr
    rhs: Expr

    @others
</t>
<t tx="ekr.20230509052845.4493">def __init__(self, lhs, rhs):
    self.lhs = lhs
    self.rhs = rhs

</t>
<t tx="ekr.20230509052845.4494">def eval_from_fn(self, fn):
    return fn(self.lhs.eval(), self.rhs.eval())

</t>
<t tx="ekr.20230509052845.4495">class Add(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.add)

</t>
<t tx="ekr.20230509052845.4496">class Sub(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.sub)

</t>
<t tx="ekr.20230509052845.4497">class Mul(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.mul)

</t>
<t tx="ekr.20230509052845.4498">class Div(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.floordiv)

</t>
<t tx="ekr.20230509052845.4499"># TODO: remove Expr requirement
expr : Expr = Mul(Const(3), Add(Const(10), Const(5)))
print(expr.eval()) #: 45


</t>
<t tx="ekr.20230509052845.45">def __init__(self, x=0, y=0, z=0):
    self.x = x
    self.y = y
    self.z = z

</t>
<t tx="ekr.20230509052845.450">/// Pass to optimize calls of form d[x] = func(d[x], any).
/// This will work on any dictionary-like object that implements _do_op and
/// _do_op_throws as well as getters.
class DictArithmeticOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4500">#%% polymorphism_4
class A(object):
    a: int
    @others
</t>
<t tx="ekr.20230509052845.4501">def __init__(self, a: int):
    self.a = a

</t>
<t tx="ekr.20230509052845.4502">def test_a(self, n: int):
    print("test_a:A", n)

</t>
<t tx="ekr.20230509052845.4503">def test(self, n: int):
    print("test:A", n)

</t>
<t tx="ekr.20230509052845.4504">def test2(self, n: int):
    print("test2:A", n)

</t>
<t tx="ekr.20230509052845.4505">class B(A):
    b: int
    @others
</t>
<t tx="ekr.20230509052845.4506">def __init__(self, a: int, b: int):
    super().__init__(a)
    self.b = b

</t>
<t tx="ekr.20230509052845.4507">def test(self, n: int):
    print("test:B", n)

</t>
<t tx="ekr.20230509052845.4508">def test2(self, n: int):
    print("test2:B", n)

</t>
<t tx="ekr.20230509052845.4509">class C(B):
    pass

</t>
<t tx="ekr.20230509052845.451">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4510">b = B(1, 2)
b.test_a(1)
b.test(1)
#: test_a:A 1
#: test:B 1

a: A = b
a.test(1)
a.test2(2)
#: test:B 1
#: test2:B 2


</t>
<t tx="ekr.20230509052845.4511">#%% no_generic,barebones
def foo(a, b: Static[int]):
    pass
</t>
<t tx="ekr.20230509052845.4512">foo(5)  #! generic 'b' not provided


</t>
<t tx="ekr.20230509052845.4513">#%% no_generic_2,barebones
def f(a, b, T: type):
    print(a, b)
</t>
<t tx="ekr.20230509052845.4514"></t>
<t tx="ekr.20230509052845.4515">@path C:/Repos/codon/test/parser/a/
@others
par = 'y'
if len('x') == 1:
    par = 'x'
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4516">def foo():
    print 'a.foo'
</t>
<t tx="ekr.20230509052845.4517">def bar():
    print 'a.bar'
</t>
<t tx="ekr.20230509052845.4518">print 'a'

zoo = 5
_zoo = 3

</t>
<t tx="ekr.20230509052845.4519">class B:
    pass
</t>
<t tx="ekr.20230509052845.452">/// Pass to optimize passing a generator to some built-in functions
/// like sum(), any() or all(), which will be converted to regular
/// for-loops.
class GeneratorArgumentOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4520">C = B
tt = Ptr[B]
</t>
<t tx="ekr.20230509052845.4521">@tuple
class Foo:
    t: tt

</t>
<t tx="ekr.20230509052845.4522">def ha():
    c = C()
    print(c.__class__.__name__)


</t>
<t tx="ekr.20230509052845.4523"></t>
<t tx="ekr.20230509052845.4524">@path C:/Repos/codon/test/parser/a/b/
print 'import rec1'

var = 'x'

import rec2
rec2.foo()

@others
print 'done rec1'
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4525">def bar():
    print 'rec1.bar'

</t>
<t tx="ekr.20230509052845.4526">@path C:/Repos/codon/test/parser/a/b/
print 'import rec1'

import rec2_err
rec2_err.foo()

def bar():
    print 'rec1.bar'
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4527">@path C:/Repos/codon/test/parser/a/b/
print 'import rec2'

from .rec1 import var

def foo():
    print 'rec2.' + var

print 'done rec2'
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4528">@path C:/Repos/codon/test/parser/a/b/
print 'import rec2'

from .rec1_err import bar
bar()

def foo():
    print 'rec2.foo'
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4529">@path C:/Repos/codon/test/parser/a/b/
c = 'a.b.c'
@others
stt: Static[int] = 5
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.453">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4530">def har():
    print 'a.b.har', __name__[-12:], c

</t>
<t tx="ekr.20230509052845.4531">from .. import foo as fx

</t>
<t tx="ekr.20230509052845.4532">class A:
    class B:
        def b_foo():
            print 'a.b.A.B.b_foo()'
            return 1

</t>
<t tx="ekr.20230509052845.4533"></t>
<t tx="ekr.20230509052845.4534">@path C:/Repos/codon/test/python/
from typing import Dict, List, Tuple

import codon

@others
test_cross_calls()
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4535">@codon.convert
class Foo:
    __slots__ = 'a', 'b', 'c'

    @others
</t>
<t tx="ekr.20230509052845.4536">def __init__(self, n):
    self.a = n
    self.b = n**2
    self.c = n**3

</t>
<t tx="ekr.20230509052845.4537">def __eq__(self, other):
    return (self.a == other.a and
            self.b == other.b and
            self.c == other.c)

</t>
<t tx="ekr.20230509052845.4538">def __hash__(self):
    return hash((self.a, self.b, self.c))

</t>
<t tx="ekr.20230509052845.4539">@codon.jit
def total(self):
    return self.a + self.b + self.c

</t>
<t tx="ekr.20230509052845.454">/// Pass to optimize print str.cat(...) or file.write(str.cat(...)).
class IOCatOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4540">def test_convertible():
    assert Foo(10).total() == 1110

</t>
<t tx="ekr.20230509052845.4541">def test_many():
    @others
    assert sum(1 for i in range(100000, 200000) if is_prime(i)) == 8392

</t>
<t tx="ekr.20230509052845.4542">@codon.jit
def is_prime(n):
    if n &lt;= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

</t>
<t tx="ekr.20230509052845.4543">def test_roundtrip():
    @others
    for _ in range(5):
        assert roundtrip(None) == None
        assert roundtrip(42) == 42
        assert roundtrip(3.14) == 3.14
        assert roundtrip(False) == False
        assert roundtrip(True) == True
        assert roundtrip('hello') == 'hello'
        assert roundtrip('') == ''
        assert roundtrip(2+3j) == 2+3j
        assert roundtrip(slice(1,2,3)) == slice(1,2,3)
        assert roundtrip([11,22,33]) == [11,22,33]
        assert roundtrip([[[42]]]) == [[[42]]]
        assert roundtrip({11,22,33}) == {11,22,33}
        assert roundtrip({11: 'one', 22: 'two', 33: 'three'}) == {11: 'one', 22: 'two', 33: 'three'}
        assert roundtrip((11,22,33)) == (11,22,33)
        assert Foo(roundtrip(Foo(123))[0]) == Foo(123)
        assert roundtrip(roundtrip) is roundtrip

</t>
<t tx="ekr.20230509052845.4544">@codon.jit
def roundtrip(x):
    return x

</t>
<t tx="ekr.20230509052845.4545">def test_return_type():
    @others
    r = run()
    assert type(r) == tuple
    assert type(r[0]) == int
    assert type(r[1]) == str
    assert type(r[2]) == float
    assert type(r[3]) == list
    assert len(r[3]) == 3
    assert type(r[3][0]) == int
    assert type(r[4]) == dict
    assert len(r[4].items()) == 2
    assert type(next(iter(r[4].keys()))) == str
    assert type(next(iter(r[4].values()))) == int

</t>
<t tx="ekr.20230509052845.4546">@codon.jit
def run() -&gt; Tuple[int, str, float, List[int], Dict[str, int]]:
    return (1, "str", 2.45, [1, 2, 3], {"a": 1, "b": 2})

</t>
<t tx="ekr.20230509052845.4547">def test_param_types():
    @others
    r = run(1, (2, 3), [4, 5, 6], dict(a=7, b=8, c=9))
    assert type(r) == int
    assert r == 45

</t>
<t tx="ekr.20230509052845.4548">@codon.jit
def run(a: int, b: Tuple[int, int], c: List[int], d: Dict[str, int]) -&gt; int:
    s = 0
    for v in [a, *b, *c, *d.values()]:
        s += v
    return s

</t>
<t tx="ekr.20230509052845.4549">def test_error_handling():
    @others
    try:
        type_error()
    except codon.JITError:
        pass
    except:
        assert False
    else:
        assert False

</t>
<t tx="ekr.20230509052845.455">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4550">@codon.jit
def type_error():
    return 1 + '1'

</t>
<t tx="ekr.20230509052845.4551">test_convertible()
test_many()
test_roundtrip()
test_return_type()
test_param_types()
test_error_handling()


</t>
<t tx="ekr.20230509052845.4552">@codon.jit
def foo(y):
    return f"{y.__class__.__name__}; {y}"


</t>
<t tx="ekr.20230509052845.4553">@codon.jit(debug=True)
def foo2(y):
    return f"{y.__class__.__name__}; {y}"

</t>
<t tx="ekr.20230509052845.4554">class Foo:
    def __init__(self):
        self.x = 1

</t>
<t tx="ekr.20230509052845.4555">@codon.jit
def a(x):
    return x+1

</t>
<t tx="ekr.20230509052845.4556">def b(x, z):
    y = a(x)
    return y * z

</t>
<t tx="ekr.20230509052845.4557">@codon.jit(pyvars=['b'])
def c(x, y):
    n = b(x,y) ** a(1)
    return n

</t>
<t tx="ekr.20230509052845.4558">def test_cross_calls():
    assert foo([None, 1]) == "List[Optional[int]]; [None, 1]"
    assert foo([1, None, 1]) == "List[Optional[int]]; [1, None, 1]"
    assert foo([1, None, 1.2]) == "List[pyobj]; [1, None, 1.2]"
    assert foo({None: 1}) == "Dict[pyobj,int]; {None: 1}"
    assert foo2([None, Foo()]).startswith("List[pyobj]; [None, &lt;__main__.Foo object at")

    assert a(3) == 4
    assert b(3, 4) == 16
    assert round(c(5, 6.1), 2) == 1339.56

</t>
<t tx="ekr.20230509052845.4559">@path C:/Repos/codon/test/python/
import sys, sysconfig, os, distutils.sysconfig as du_sysconfig, itertools

@others
print(get_python_library('{}.{}'.format(sys.version_info[0], sys.version_info[1])))
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.456">/// Pass to optimize list1 + list2 + ...
/// Also handles list slices and list literals efficiently.
class ListAdditionOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4560">def get_python_library(python_version):
    """Get path to the python library associated with the current python
    interpreter. Adapted from https://github.com/scikit-build/scikit-build/blob/master/skbuild/cmaker.py#L272"""
    # determine direct path to libpython
    python_library = sysconfig.get_config_var('LIBRARY')

    # if static (or nonexistent), try to find a suitable dynamic libpython
    if (not python_library or os.path.splitext(python_library)[1][-2:] == '.a'):

        candidate_lib_prefixes = ['', 'lib']

        candidate_implementations = ['python']
        if hasattr(sys, "pypy_version_info"):
            candidate_implementations = ['pypy-c', 'pypy3-c']

        candidate_extensions = ['.lib', '.so', '.a']
        if sysconfig.get_config_var('WITH_DYLD'):
            candidate_extensions.insert(0, '.dylib')

        candidate_versions = [python_version]
        if python_version:
            candidate_versions.append('')
            candidate_versions.insert(
                0, "".join(python_version.split(".")[:2]))

        abiflags = getattr(sys, 'abiflags', '')
        candidate_abiflags = [abiflags]
        if abiflags:
            candidate_abiflags.append('')

        # Ensure the value injected by virtualenv is
        # returned on windows.
        # Because calling `sysconfig.get_config_var('multiarchsubdir')`
        # returns an empty string on Linux, `du_sysconfig` is only used to
        # get the value of `LIBDIR`.
        libdir = du_sysconfig.get_config_var('LIBDIR')
        if sysconfig.get_config_var('MULTIARCH'):
            masd = sysconfig.get_config_var('multiarchsubdir')
            if masd:
                if masd.startswith(os.sep):
                    masd = masd[len(os.sep):]
                libdir = os.path.join(libdir, masd)

        if libdir is None:
            libdir = os.path.abspath(os.path.join(
                sysconfig.get_config_var('LIBDEST'), "..", "libs"))

        candidates = [
            os.path.join (sysconfig.get_config_var('LIBPL'), sysconfig.get_config_var('LDLIBRARY'))
        ] + [
            os.path.join(
                libdir,
                ''.join((pre, impl, ver, abi, ext))
            )
            for (pre, impl, ext, ver, abi) in itertools.product(
                candidate_lib_prefixes,
                candidate_implementations,
                candidate_extensions,
                candidate_versions,
                candidate_abiflags
            )
        ]

        for candidate in candidates:
            if os.path.exists(candidate):
                # we found a (likely alternate) libpython
                python_library = candidate
                break

    # TODO(opadron): what happens if we don't find a libpython?

    return python_library

</t>
<t tx="ekr.20230509052845.4561">@path C:/Repos/codon/test/python/
print('Hello from Codon')

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4562">def f1(a: float = 1.11, b: float = 2.22):
    return (a, b)

</t>
<t tx="ekr.20230509052845.4563">def f2():
    return ({1: 'one'}, {2}, [3])

</t>
<t tx="ekr.20230509052845.4564">def f3(x):
    return x * 2

</t>
<t tx="ekr.20230509052845.4565">def f4(x):
    return x

</t>
<t tx="ekr.20230509052845.4566">@overload
def f4(a: float = 1.11, b: float = 2.22):
    return f1(a=a, b=b)

</t>
<t tx="ekr.20230509052845.4567">@overload
def f4():
    return ['f4()']

</t>
<t tx="ekr.20230509052845.4568">@overload
def f4(x: str):
    return x, x

</t>
<t tx="ekr.20230509052845.4569">def f5():
    pass

</t>
<t tx="ekr.20230509052845.457">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4570">@dataclass(python=True)
class Vec:
    a: float
    b: float
    tag: str
    n: ClassVar[int] = 0
    d: ClassVar[int] = 0

    @others
</t>
<t tx="ekr.20230509052845.4571">def __init__(self, a: float, b: float, tag: str):
    self.a = a
    self.b = b
    self.tag = tag

</t>
<t tx="ekr.20230509052845.4572">def __init__(self, a: float = 0.0, b: float = 0.0):
    self.__init__(a, b, 'v' + str(Vec.n))
    Vec.n += 1

</t>
<t tx="ekr.20230509052845.4573">def foo(self, a: float = 1.11, b: float = 2.22):
    return (self.a, a, b)

</t>
<t tx="ekr.20230509052845.4574">def bar(self):
    return self

</t>
<t tx="ekr.20230509052845.4575">def baz(a: float = 1.11, b: float = 2.22):
    return (a, b)

</t>
<t tx="ekr.20230509052845.4576">def nop():
    return 'nop'

</t>
<t tx="ekr.20230509052845.4577">@property
def c(self):
    return self.a + self.b

</t>
<t tx="ekr.20230509052845.4578">def __str__(self):
    return f'{self.tag}: &lt;{self.a}, {self.b}&gt;'

</t>
<t tx="ekr.20230509052845.4579">def __repr__(self):
    return f'Vec({self.a}, {self.b}, {repr(self.tag)})'

</t>
<t tx="ekr.20230509052845.458">/// Pass to optimize str1 + str2 + ...
class StrAdditionOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509052845.4580">def __add__(self, other: Vec):
    return Vec(self.a + other.a, self.b + other.b, f'({self.tag}+{other.tag})')

</t>
<t tx="ekr.20230509052845.4581">def __iadd__(self, other: Vec):
    self.a += other.a
    self.b += other.b
    self.tag = f'({self.tag}+={other.tag})'
    return self

</t>
<t tx="ekr.20230509052845.4582">def __add__(self, x: float):
    return Vec(self.a + x, self.b + x, f'({self.tag}+{x})')

</t>
<t tx="ekr.20230509052845.4583">def __iadd__(self, x: float):
    self.a += x
    self.b += x
    self.tag = f'({self.tag}+={x})'
    return self

</t>
<t tx="ekr.20230509052845.4584">def __add__(self, x: int):
    return Vec(self.a + x, self.b + x, f'({self.tag}++{x})')

</t>
<t tx="ekr.20230509052845.4585">def __sub__(self, other: Vec):
    return Vec(self.a - other.a, self.b - other.b, f'({self.tag}-{other.tag})')

</t>
<t tx="ekr.20230509052845.4586">def __isub__(self, other: Vec):
    self.a -= other.a
    self.b -= other.b
    self.tag = f'({self.tag}-={other.tag})'
    return self

</t>
<t tx="ekr.20230509052845.4587">def __mul__(self, x: float):
    return Vec(self.a * x, self.b * x, f'({self.tag}*{x})')

</t>
<t tx="ekr.20230509052845.4588">def __imul__(self, x: float):
    self.a *= x
    self.b *= x
    self.tag = f'({self.tag}*={x})'
    return self

</t>
<t tx="ekr.20230509052845.4589">def __mod__(self, x: float):
    return Vec(self.a % x, self.b % x, f'({self.tag}%{x})')

</t>
<t tx="ekr.20230509052845.459"></t>
<t tx="ekr.20230509052845.4590">def __imod__(self, x: float):
    self.a %= x
    self.b %= x
    self.tag = f'({self.tag}%={x})'
    return self

</t>
<t tx="ekr.20230509052845.4591">def __divmod__(self, x: float):
    raise ArithmeticError('no divmod')
    # return self.a / x, self.a % x

</t>
<t tx="ekr.20230509052845.4592">def __pow__(self, x: float):
    return Vec(self.a ** x, self.b ** x, f'({self.tag}**{x})')

</t>
<t tx="ekr.20230509052845.4593">def __ipow__(self, x: float):
    self.a **= x
    self.b **= x
    self.tag = f'({self.tag}**={x})'
    return self

</t>
<t tx="ekr.20230509052845.4594">def __neg__(self):
    return Vec(-self.a, -self.b, f'(-{self.tag})')

</t>
<t tx="ekr.20230509052845.4595">def __pos__(self):
    return Vec(self.a, self.b, f'(+{self.tag})')

</t>
<t tx="ekr.20230509052845.4596">def __abs__(self):
    import math
    return math.hypot(self.a, self.b)

</t>
<t tx="ekr.20230509052845.4597">def __bool__(self):
    return bool(self.a) and bool(self.b)

</t>
<t tx="ekr.20230509052845.4598">def __invert__(self):
    return Vec(-self.a - 1, -self.b - 1, f'(~{self.tag})')

</t>
<t tx="ekr.20230509052845.4599">def __lshift__(self, x: int):
    y = 1 &lt;&lt; x
    return Vec(self.a * y, self.b * y, f'({self.tag}&lt;&lt;{x})')

</t>
<t tx="ekr.20230509052845.46">def Mag(self):
    return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)

</t>
<t tx="ekr.20230509052845.460">@path C:/Repos/codon/codon/cir/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/base.h"
#include "codon/cir/util/packs.h"
#include "codon/cir/util/visitor.h"
#include "codon/parser/ast.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

class Value;

namespace types {

class Type;

@others
} // namespace types
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::types::Type&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4600">def __ilshift__(self, x: int):
    y = 1 &lt;&lt; x
    self.a *= y
    self.b *= y
    self.tag = f'({self.tag}&lt;&lt;={x})'
    return self

</t>
<t tx="ekr.20230509052845.4601">def __rshift__(self, x: int):
    y = 1 &lt;&lt; x
    return Vec(self.a / y, self.b / y, f'({self.tag}&gt;&gt;{x})')

</t>
<t tx="ekr.20230509052845.4602">def __irshift__(self, x: int):
    y = 1 &lt;&lt; x
    self.a /= y
    self.b /= y
    self.tag = f'({self.tag}&gt;&gt;={x})'
    return self

</t>
<t tx="ekr.20230509052845.4603">def __and__(self, x: int):
    return Vec(int(self.a) &amp; x, int(self.b) &amp; x, f'({self.tag}&amp;{x})')

</t>
<t tx="ekr.20230509052845.4604">def __iand__(self, x: int):
    self.a = int(self.a) &amp; x
    self.b = int(self.b) &amp; x
    self.tag = f'({self.tag}&amp;={x})'
    return self

</t>
<t tx="ekr.20230509052845.4605">def __or__(self, x: int):
    return Vec(int(self.a) | x, int(self.b) | x, f'({self.tag}|{x})')

</t>
<t tx="ekr.20230509052845.4606">def __ior__(self, x: int):
    self.a = int(self.a) | x
    self.b = int(self.b) | x
    self.tag = f'({self.tag}|={x})'
    return self

</t>
<t tx="ekr.20230509052845.4607">def __xor__(self, x: int):
    return Vec(int(self.a) ^ x, int(self.b) ^ x, f'({self.tag}^{x})')

</t>
<t tx="ekr.20230509052845.4608">def __ixor__(self, x: int):
    self.a = int(self.a) ^ x
    self.b = int(self.b) ^ x
    self.tag = f'({self.tag}^={x})'
    return self

</t>
<t tx="ekr.20230509052845.4609">#def __int__(self):
#    return int(self.b)

#def __float__(self):
#    return self.b

#def __index__(self):
#    return int(self.a)

</t>
<t tx="ekr.20230509052845.461">class Generic {
private:
  union {
    int64_t staticValue;
    char *staticStringValue;
    types::Type *typeValue;
  } value;
  enum { STATIC, STATIC_STR, TYPE } tag;

public:
  Generic(int64_t staticValue) : value(), tag(STATIC) {
    value.staticValue = staticValue;
  }
  Generic(const std::string &amp;staticValue) : value(), tag(STATIC_STR) {
    value.staticStringValue = new char[staticValue.size() + 1];
    strncpy(value.staticStringValue, staticValue.data(), staticValue.size());
    value.staticStringValue[staticValue.size()] = 0;
  }
  Generic(types::Type *typeValue) : value(), tag(TYPE) { value.typeValue = typeValue; }
  Generic(const types::Generic &amp;) = default;
  ~Generic() {
    // if (tag == STATIC_STR)
    //   delete[] value.staticStringValue;
  }

  /// @return true if the generic is a type
  bool isType() const { return tag == TYPE; }
  /// @return true if the generic is static
  bool isStatic() const { return tag == STATIC; }
  /// @return true if the generic is static
  bool isStaticStr() const { return tag == STATIC_STR; }

  /// @return the static value
  int64_t getStaticValue() const { return value.staticValue; }
  /// @return the static string value
  std::string getStaticStringValue() const { return value.staticStringValue; }
  /// @return the type value
  types::Type *getTypeValue() const { return value.typeValue; }
};

</t>
<t tx="ekr.20230509052845.4610">def __floordiv__(self, x: float):
    return Vec(self.a // x, self.b // x, f'({self.tag}//{x})')

</t>
<t tx="ekr.20230509052845.4611">def __ifloordiv__(self, x: float):
    self.a //= x
    self.b //= x
    self.tag = f'({self.tag}//={x})'
    return self

</t>
<t tx="ekr.20230509052845.4612">def __truediv__(self, x: float):
    return Vec(self.a / x, self.b / x, f'({self.tag}/{x})')

</t>
<t tx="ekr.20230509052845.4613">def __itruediv__(self, x: float):
    self.a /= x
    self.b /= x
    self.tag = f'({self.tag}/={x})'
    return self

</t>
<t tx="ekr.20230509052845.4614">def __matmul__(self, other: Vec):
    return (self.a * other.a) + (self.b * other.b)

</t>
<t tx="ekr.20230509052845.4615">def __imatmul__(self, x: float):
    self.a *= x
    self.b *= x
    self.tag = f'({self.tag}@={x})'
    return self

</t>
<t tx="ekr.20230509052845.4616">def __len__(self):
    return len(self.tag)

</t>
<t tx="ekr.20230509052845.4617">def __getitem__(self, idx: int):
    if idx == 0:
        return self.a
    elif idx == 1:
        return self.b
    elif idx == 11:
        return self.a + self.b
    else:
        raise KeyError('bad vec key ' + str(idx))

</t>
<t tx="ekr.20230509052845.4618">def __setitem__(self, idx: int, val: float):
    if idx == 0:
        self.a = val
    elif idx == 1:
        self.b = val
    elif idx == 11:
        self.a = val
        self.b = val
    else:
        raise KeyError('bad vec key ' + str(idx) + ' with val ' + str(val))

</t>
<t tx="ekr.20230509052845.4619">def __delitem__(self, idx: int):
    self[idx] = 0.0

</t>
<t tx="ekr.20230509052845.462">/// Type from which other CIR types derive. Generally types are immutable.
class Type : public ReplaceableNodeBase&lt;Type&gt; {
private:
  ast::types::TypePtr astType;

public:
  static const char NodeId;

  using ReplaceableNodeBase::ReplaceableNodeBase;

  virtual ~Type() noexcept = default;

  std::vector&lt;Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
@others
  using Node::replaceUsedType;

  /// @param other another type
  /// @return true if this type is equal to the argument type
  bool is(types::Type *other) const { return getName() == other-&gt;getName(); }

  /// A type is "atomic" iff it contains no pointers to dynamically
  /// allocated memory. Atomic types do not need to be scanned during
  /// garbage collection.
  /// @return true if the type is atomic
  bool isAtomic() const { return getActual()-&gt;doIsAtomic(); }

  /// Checks if the contents (i.e. within an allocated block of memory)
  /// of a type are atomic. Currently only meaningful for reference types.
  /// @return true if the type's content is atomic
  bool isContentAtomic() const { return getActual()-&gt;doIsContentAtomic(); }

  /// @return the ast type
  ast::types::TypePtr getAstType() const { return getActual()-&gt;astType; }
  /// Sets the ast type. Should not generally be used.
  /// @param t the new type
  void setAstType(ast::types::TypePtr t) { getActual()-&gt;astType = std::move(t); }

  /// @return the generics used in the type
  std::vector&lt;Generic&gt; getGenerics() const { return getActual()-&gt;doGetGenerics(); }

  /// Constructs an instance of the type given the supplied args.
  /// @param args the arguments
  /// @return the new value
  Value *construct(std::vector&lt;Value *&gt; args) {
    return getActual()-&gt;doConstruct(std::move(args));
  }
  template &lt;typename... Args&gt; Value *operator()(Args &amp;&amp;...args) {
    std::vector&lt;Value *&gt; dst;
    util::stripPack(dst, std::forward&lt;Args&gt;(args)...);
    return construct(dst);
  }

private:
  virtual std::vector&lt;Generic&gt; doGetGenerics() const;

  virtual std::vector&lt;Type *&gt; doGetUsedTypes() const { return {}; }
  virtual bool doIsAtomic() const = 0;
  virtual bool doIsContentAtomic() const { return true; }

  virtual Value *doConstruct(std::vector&lt;Value *&gt; args);
};

</t>
<t tx="ekr.20230509052845.4620">def __contains__(self, val: float):
    return self.a == val or self.b == val

</t>
<t tx="ekr.20230509052845.4621">def __contains__(self, val: str):
    return self.tag == val

</t>
<t tx="ekr.20230509052845.4622">def __hash__(self):
    return int(self.a + self.b)

</t>
<t tx="ekr.20230509052845.4623">def __call__(self, a: float = 1.11, b: float = 2.22):
    return self.foo(a=a, b=b)

</t>
<t tx="ekr.20230509052845.4624">def __call__(self, x: str):
    return (self.a, self.b, x)

</t>
<t tx="ekr.20230509052845.4625">def __call__(self):
    return Vec(self.a, self.b, f'({self.tag}())')

</t>
<t tx="ekr.20230509052845.4626">def __iter__(self):
    for c in self.tag:
        yield c

</t>
<t tx="ekr.20230509052845.4627">def __eq__(self, other: Vec):
    return self.a == other.a and self.b == other.b

</t>
<t tx="ekr.20230509052845.4628">def __eq__(self, x: float):
    return self.a == x and self.b == x

</t>
<t tx="ekr.20230509052845.4629">def __ne__(self, other: Vec):
    return self.a != other.a or self.b != other.b

</t>
<t tx="ekr.20230509052845.463">  int replaceUsedType(const std::string &amp;name, Type *newType) final {
    seqassertn(false, "types not replaceable");
    return -1;
  }
</t>
<t tx="ekr.20230509052845.4630">def __lt__(self, other: Vec):
    return abs(self) &lt; abs(other)

</t>
<t tx="ekr.20230509052845.4631">def __le__(self, other: Vec):
    return abs(self) &lt;= abs(other)

</t>
<t tx="ekr.20230509052845.4632">def __gt__(self, other: Vec):
    return abs(self) &gt; abs(other)

</t>
<t tx="ekr.20230509052845.4633">def __ge__(self, other: Vec):
    return abs(self) &gt;= abs(other)

</t>
<t tx="ekr.20230509052845.4634">def __del__(self):
    Vec.d += 1

</t>
<t tx="ekr.20230509052845.4635">def nd():
    return Vec.d

</t>
<t tx="ekr.20230509052845.4636">def f6(x: float, t: str):
    return Vec(x, x, t)

</t>
<t tx="ekr.20230509052845.4637">def reset():
    Vec.n = 0

</t>
<t tx="ekr.20230509052845.4638">def par_sum(n: int):
    m = 0
    @par(num_threads=4)
    for i in range(n):
        m += 3*i + 7
    return m

</t>
<t tx="ekr.20230509052845.4639">@tuple
class Foo:
    a: List[str]
    x: Dict[str, int]

    @others
</t>
<t tx="ekr.20230509052845.464">/// Type from which primitive atomic types derive.
class PrimitiveType : public AcceptorExtend&lt;PrimitiveType, Type&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

private:
  bool doIsAtomic() const final { return true; }
};

</t>
<t tx="ekr.20230509052845.4640">def __new__(a: List[str]) -&gt; Foo:
    return (a, {s: i for i, s in enumerate(a)})

</t>
<t tx="ekr.20230509052845.4641">def __iter__(self):
    return iter(self.a)

</t>
<t tx="ekr.20230509052845.4642">def __repr__(self):
    return f'Foo({self.a}, {self.x})'

</t>
<t tx="ekr.20230509052845.4643">def hello(self):
    return 'x'

</t>
<t tx="ekr.20230509052845.4644">def __int__(self):
    return 42

</t>
<t tx="ekr.20230509052845.4645">def __float__(self):
    return 3.14

</t>
<t tx="ekr.20230509052845.4646">def __index__(self):
    return 99
</t>
<t tx="ekr.20230509052845.4647">@path C:/Repos/codon/test/python/
print('Hello from Codon 2')

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4648">@tuple
class Vec:
    a: float
    b: float
    tag: str
    n: ClassVar[int] = 0
    d: ClassVar[int] = 0

    @others
</t>
<t tx="ekr.20230509052845.4649">def __new__(a: float, b: float, tag: str) -&gt; Vec:
    return (a, b, tag)

</t>
<t tx="ekr.20230509052845.465">/// Int type (64-bit signed integer)
class IntType : public AcceptorExtend&lt;IntType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs an int type.
  IntType() : AcceptorExtend("int") {}
};

</t>
<t tx="ekr.20230509052845.4650">def __new__(a: float = 0.0, b: float = 0.0):
    v = Vec(a, b, 'v' + str(Vec.n))
    Vec.n += 1
    return v

</t>
<t tx="ekr.20230509052845.4651">def foo(self, a: float = 1.11, b: float = 2.22):
    return (self.a, a, b)

</t>
<t tx="ekr.20230509052845.4652">def bar(self):
    return self

</t>
<t tx="ekr.20230509052845.4653">def baz(a: float = 1.11, b: float = 2.22):
    return (a, b)

</t>
<t tx="ekr.20230509052845.4654">def nop():
    return 'nop'

</t>
<t tx="ekr.20230509052845.4655">@property
def c(self):
    return self.a + self.b

</t>
<t tx="ekr.20230509052845.4656">def __str__(self):
    return f'{self.tag}: &lt;{self.a}, {self.b}&gt;'

</t>
<t tx="ekr.20230509052845.4657">def __repr__(self):
    return f'Vec({self.a}, {self.b}, {repr(self.tag)})'

</t>
<t tx="ekr.20230509052845.4658">def __add__(self, other: Vec):
    return Vec(self.a + other.a, self.b + other.b, f'({self.tag}+{other.tag})')

</t>
<t tx="ekr.20230509052845.4659">def __iadd__(self, other: Vec):
    a, b = self.a, self.b
    a += other.a
    b += other.b
    tag = f'({self.tag}+={other.tag})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.466">/// Float type (64-bit double)
class FloatType : public AcceptorExtend&lt;FloatType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a float type.
  FloatType() : AcceptorExtend("float") {}
};

</t>
<t tx="ekr.20230509052845.4660">def __add__(self, x: float):
    return Vec(self.a + x, self.b + x, f'({self.tag}+{x})')

</t>
<t tx="ekr.20230509052845.4661">def __iadd__(self, x: float):
    a, b = self.a, self.b
    a += x
    b += x
    tag = f'({self.tag}+={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4662">def __add__(self, x: int):
    return Vec(self.a + x, self.b + x, f'({self.tag}++{x})')

</t>
<t tx="ekr.20230509052845.4663">def __sub__(self, other: Vec):
    return Vec(self.a - other.a, self.b - other.b, f'({self.tag}-{other.tag})')

</t>
<t tx="ekr.20230509052845.4664">def __isub__(self, other: Vec):
    a, b = self.a, self.b
    a -= other.a
    b -= other.b
    tag = f'({self.tag}-={other.tag})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4665">def __mul__(self, x: float):
    return Vec(self.a * x, self.b * x, f'({self.tag}*{x})')

</t>
<t tx="ekr.20230509052845.4666">def __imul__(self, x: float):
    a, b = self.a, self.b
    a *= x
    b *= x
    tag = f'({self.tag}*={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4667">def __mod__(self, x: float):
    return Vec(self.a % x, self.b % x, f'({self.tag}%{x})')

</t>
<t tx="ekr.20230509052845.4668">def __imod__(self, x: float):
    a, b = self.a, self.b
    a %= x
    b %= x
    tag = f'({self.tag}%={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4669">def __divmod__(self, x: float):
    raise ArithmeticError('no divmod')
    # return self.a / x, self.a % x

</t>
<t tx="ekr.20230509052845.467">/// Float32 type (32-bit float)
class Float32Type : public AcceptorExtend&lt;Float32Type, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a float32 type.
  Float32Type() : AcceptorExtend("float32") {}
};

</t>
<t tx="ekr.20230509052845.4670">def __pow__(self, x: float):
    return Vec(self.a ** x, self.b ** x, f'({self.tag}**{x})')

</t>
<t tx="ekr.20230509052845.4671">def __ipow__(self, x: float):
    a, b = self.a, self.b
    a **= x
    b **= x
    tag = f'({self.tag}**={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4672">def __neg__(self):
    return Vec(-self.a, -self.b, f'(-{self.tag})')

</t>
<t tx="ekr.20230509052845.4673">def __pos__(self):
    return Vec(self.a, self.b, f'(+{self.tag})')

</t>
<t tx="ekr.20230509052845.4674">def __abs__(self):
    import math
    return math.hypot(self.a, self.b)

</t>
<t tx="ekr.20230509052845.4675">def __bool__(self):
    return bool(self.a) and bool(self.b)

</t>
<t tx="ekr.20230509052845.4676">def __invert__(self):
    return Vec(-self.a - 1, -self.b - 1, f'(~{self.tag})')

</t>
<t tx="ekr.20230509052845.4677">def __lshift__(self, x: int):
    y = 1 &lt;&lt; x
    return Vec(self.a * y, self.b * y, f'({self.tag}&lt;&lt;{x})')

</t>
<t tx="ekr.20230509052845.4678">def __ilshift__(self, x: int):
    a, b = self.a, self.b
    y = 1 &lt;&lt; x
    a *= y
    b *= y
    tag = f'({self.tag}&lt;&lt;={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4679">def __rshift__(self, x: int):
    y = 1 &lt;&lt; x
    return Vec(self.a / y, self.b / y, f'({self.tag}&gt;&gt;{x})')

</t>
<t tx="ekr.20230509052845.468">/// Bool type (8-bit unsigned integer; either 0 or 1)
class BoolType : public AcceptorExtend&lt;BoolType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a bool type.
  BoolType() : AcceptorExtend("bool") {}
};

</t>
<t tx="ekr.20230509052845.4680">def __irshift__(self, x: int):
    a, b = self.a, self.b
    y = 1 &lt;&lt; x
    a /= y
    b /= y
    tag = f'({self.tag}&gt;&gt;={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4681">def __and__(self, x: int):
    return Vec(int(self.a) &amp; x, int(self.b) &amp; x, f'({self.tag}&amp;{x})')

</t>
<t tx="ekr.20230509052845.4682">def __iand__(self, x: int):
    a, b = self.a, self.b
    a = int(self.a) &amp; x
    b = int(self.b) &amp; x
    tag = f'({self.tag}&amp;={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4683">def __or__(self, x: int):
    return Vec(int(self.a) | x, int(self.b) | x, f'({self.tag}|{x})')

</t>
<t tx="ekr.20230509052845.4684">def __ior__(self, x: int):
    a, b = self.a, self.b
    a = int(self.a) | x
    b = int(self.b) | x
    tag = f'({self.tag}|={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4685">def __xor__(self, x: int):
    return Vec(int(self.a) ^ x, int(self.b) ^ x, f'({self.tag}^{x})')

</t>
<t tx="ekr.20230509052845.4686">def __ixor__(self, x: int):
    a, b = self.a, self.b
    a = int(self.a) ^ x
    b = int(self.b) ^ x
    tag = f'({self.tag}^={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4687">#def __int__(self):
#    return int(self.b)

#def __float__(self):
#    return self.b

#def __index__(self):
#    return int(self.a)

</t>
<t tx="ekr.20230509052845.4688">def __floordiv__(self, x: float):
    return Vec(self.a // x, self.b // x, f'({self.tag}//{x})')

</t>
<t tx="ekr.20230509052845.4689">def __ifloordiv__(self, x: float):
    a, b = self.a, self.b
    a //= x
    b //= x
    tag = f'({self.tag}//={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.469">/// Byte type (8-bit unsigned integer)
class ByteType : public AcceptorExtend&lt;ByteType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a byte type.
  ByteType() : AcceptorExtend("byte") {}
};

</t>
<t tx="ekr.20230509052845.4690">def __truediv__(self, x: float):
    return Vec(self.a / x, self.b / x, f'({self.tag}/{x})')

</t>
<t tx="ekr.20230509052845.4691">def __itruediv__(self, x: float):
    a, b = self.a, self.b
    a /= x
    b /= x
    tag = f'({self.tag}/={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4692">def __matmul__(self, other: Vec):
    return (self.a * other.a) + (self.b * other.b)

</t>
<t tx="ekr.20230509052845.4693">def __imatmul__(self, x: float):
    a, b = self.a, self.b
    a *= x
    b *= x
    tag = f'({self.tag}@={x})'
    return Vec(a, b, tag)

</t>
<t tx="ekr.20230509052845.4694">def __len__(self):
    return len(self.tag)

</t>
<t tx="ekr.20230509052845.4695">def __getitem__(self, idx: int):
    if idx == 0:
        return self.a
    elif idx == 1:
        return self.b
    elif idx == 11:
        return self.a + self.b
    else:
        raise KeyError('bad vec key ' + str(idx))

</t>
<t tx="ekr.20230509052845.4696">def __contains__(self, val: float):
    return self.a == val or self.b == val

</t>
<t tx="ekr.20230509052845.4697">def __contains__(self, val: str):
    return self.tag == val

</t>
<t tx="ekr.20230509052845.4698">def __hash__(self):
    return int(self.a + self.b)

</t>
<t tx="ekr.20230509052845.4699">def __call__(self, a: float = 1.11, b: float = 2.22):
    return self.foo(a=a, b=b)

</t>
<t tx="ekr.20230509052845.47">def dist(self, other):
    return math.sqrt((self.x - other.x) ** 2
                     + (self.y - other.y) ** 2
                     + (self.z - other.z) ** 2)

</t>
<t tx="ekr.20230509052845.470">/// Void type
class VoidType : public AcceptorExtend&lt;VoidType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a void type.
  VoidType() : AcceptorExtend("void") {}
};

</t>
<t tx="ekr.20230509052845.4700">def __call__(self, x: str):
    return (self.a, self.b, x)

</t>
<t tx="ekr.20230509052845.4701">def __call__(self):
    return Vec(self.a, self.b, f'({self.tag}())')

</t>
<t tx="ekr.20230509052845.4702">def __iter__(self):
    for c in self.tag:
        yield c

</t>
<t tx="ekr.20230509052845.4703">def __eq__(self, other: Vec):
    return self.a == other.a and self.b == other.b

</t>
<t tx="ekr.20230509052845.4704">def __eq__(self, x: float):
    return self.a == x and self.b == x

</t>
<t tx="ekr.20230509052845.4705">def __ne__(self, other: Vec):
    return self.a != other.a or self.b != other.b

</t>
<t tx="ekr.20230509052845.4706">def __lt__(self, other: Vec):
    return abs(self) &lt; abs(other)

</t>
<t tx="ekr.20230509052845.4707">def __le__(self, other: Vec):
    return abs(self) &lt;= abs(other)

</t>
<t tx="ekr.20230509052845.4708">def __gt__(self, other: Vec):
    return abs(self) &gt; abs(other)

</t>
<t tx="ekr.20230509052845.4709">def __ge__(self, other: Vec):
    return abs(self) &gt;= abs(other)

</t>
<t tx="ekr.20230509052845.471">/// Type from which membered types derive.
class MemberedType : public AcceptorExtend&lt;MemberedType, Type&gt; {
public:
  static const char NodeId;

@others
  using const_iterator = std::vector&lt;Field&gt;::const_iterator;
  using const_reference = std::vector&lt;Field&gt;::const_reference;

  /// Constructs a membered type.
  /// @param name the type's name
  explicit MemberedType(std::string name) : AcceptorExtend(std::move(name)) {}

  /// Gets a field type by name.
  /// @param name the field's name
  /// @return the type if it exists
  virtual Type *getMemberType(const std::string &amp;name) const = 0;
  /// Gets the index of a field by name.
  /// @param name the field's name
  /// @return 0-based field index, or -1 if not found
  virtual int getMemberIndex(const std::string &amp;name) const = 0;

  /// @return iterator to the first field
  virtual const_iterator begin() const = 0;
  /// @return iterator beyond the last field
  virtual const_iterator end() const = 0;
  /// @return a reference to the first field
  virtual const_reference front() const = 0;
  /// @return a reference to the last field
  virtual const_reference back() const = 0;

  /// Changes the body of the membered type.
  /// @param mTypes the new body
  /// @param mNames the new names
  virtual void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) = 0;
};

</t>
<t tx="ekr.20230509052845.4710">def __del__(self):
    Vec.d += 1

</t>
<t tx="ekr.20230509052845.4711">def nd():
    return Vec.d

</t>
<t tx="ekr.20230509052845.4712">def reset():
    Vec.n = 0

</t>
<t tx="ekr.20230509052845.4713">def par_sum(n: int):
    m = 0
    @par(num_threads=4)
    for i in range(n):
        m += 3*i + 7
    return m
</t>
<t tx="ekr.20230509052845.4714">@path C:/Repos/codon/test/python/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4715">def multiply(a,b):
    return a*b

</t>
<t tx="ekr.20230509052845.4716">def print_args(a,b,c,d,e):
    t = (a,b,c,d,e)
    if t != ((4, 5), {'a': 3.14, 'b': 2.123}, True, {'ACGT'}, [['abc'], ['1.1', '2.2'], []]):
        raise ValueError('TEST FAILED!')
    return ({'a': 3.14, 'b': 2.123}, (222, 3.14))

</t>
<t tx="ekr.20230509052845.4717">def print_args_var(a,b,c=1,*args,**kwargs):
    return 'a={}, b={}, c={}, args={}, kwargs={}'.format(a, b, c, args, kwargs)

</t>
<t tx="ekr.20230509052845.4718">def throw_exc():
    raise ValueError('foo')
    return 0
</t>
<t tx="ekr.20230509052845.4719">@path C:/Repos/codon/test/python/
import python

@others
test_ops()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.472">  /// Object that represents a field in a membered type.
  class Field {
  private:
    /// the field's name
    std::string name;
    /// the field's type
    Type *type;

  public:
    /// Constructs a field.
    /// @param name the field's name
    /// @param type the field's type
    Field(std::string name, Type *type) : name(std::move(name)), type(type) {}

    /// @return the field's name
    const std::string &amp;getName() const { return name; }
    /// @return the field type
    Type *getType() const { return type; }
  };

</t>
<t tx="ekr.20230509052845.4720">@test
def test_basic():
    from python import mymodule
    assert str(mymodule.multiply(3, 4)) == '12'
</t>
<t tx="ekr.20230509052845.4721">test_basic()

</t>
<t tx="ekr.20230509052845.4722">@test
def test_pybridge():
    @python
    def test_pydef(n: int) -&gt; str:
        return ''.join(map(str, range(n)))
    assert test_pydef(5) == '01234'
</t>
<t tx="ekr.20230509052845.4723">test_pybridge()

from python import mymodule
</t>
<t tx="ekr.20230509052845.4724">@test
def test_conversions():
    T = tuple[dict[str,float],tuple[int,float]]
    t = mymodule.print_args(
        (4,5),
        {'a': 3.14, 'b': 2.123},
        True,
        {'ACGT'},
        [['abc'], ['1.1', '2.2'], list[str]()]
    )
    assert T.__from_py__(t.p) == ({'a': 3.14, 'b': 2.123}, (222, 3.14))
</t>
<t tx="ekr.20230509052845.4725">test_conversions()

</t>
<t tx="ekr.20230509052845.4726">@test
def test_pythrow():
    from python import mymodule.throw_exc() -&gt; None as te
    try:
        te()
    except PyError as e:
        assert python.type(e.pytype)._getattr('__name__') + ":" + e.message == "ValueError:foo"
        return
    assert False
</t>
<t tx="ekr.20230509052845.4727">test_pythrow()

</t>
<t tx="ekr.20230509052845.4728">@test
def test_pyargs():
    from python import mymodule
    assert str(mymodule.print_args_var(1, 2, 3)) == "a=1, b=2, c=3, args=(), kwargs={}"
    assert str(mymodule.print_args_var(1, z=5, b=2)) == "a=1, b=2, c=1, args=(), kwargs={'z': 5}"
    assert str(mymodule.print_args_var(1, *(1,2,3,4,5), z=5)) == "a=1, b=1, c=2, args=(3, 4, 5), kwargs={'z': 5}"
</t>
<t tx="ekr.20230509052845.4729">test_pyargs()

</t>
<t tx="ekr.20230509052845.473">/// Membered type equivalent to C structs/C++ PODs
class RecordType : public AcceptorExtend&lt;RecordType, MemberedType&gt; {
private:
  std::vector&lt;Field&gt; fields;

public:
  static const char NodeId;

  /// Constructs a record type.
  /// @param name the type's name
  /// @param fieldTypes the member types
  /// @param fieldNames the member names
  RecordType(std::string name, std::vector&lt;Type *&gt; fieldTypes,
             std::vector&lt;std::string&gt; fieldNames);
  /// Constructs a record type. The field's names are "1", "2"...
  /// @param name the type's name
  /// @param mTypes a vector of member types
  RecordType(std::string name, std::vector&lt;Type *&gt; mTypes);
  /// Constructs an empty record type.
  /// @param name the name
  explicit RecordType(std::string name) : AcceptorExtend(std::move(name)) {}

  Type *getMemberType(const std::string &amp;n) const override;
  int getMemberIndex(const std::string &amp;n) const override;

  const_iterator begin() const override { return fields.begin(); }
  const_iterator end() const override { return fields.end(); }
  const_reference front() const override { return fields.front(); }
  const_reference back() const override { return fields.back(); }

  void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) override;

private:
  std::vector&lt;Type *&gt; doGetUsedTypes() const override;

@others
};

</t>
<t tx="ekr.20230509052845.4730">@test
def test_roundtrip(x: T, T: type):
    assert T.__from_py__(x.__to_py__()) == x

</t>
<t tx="ekr.20230509052845.4731">test_roundtrip(42)
test_roundtrip(3.14)
test_roundtrip(True)
test_roundtrip(False)
test_roundtrip(byte(99))
test_roundtrip('hello world')
test_roundtrip('')
test_roundtrip(List[int]())
test_roundtrip([11, 22, 33])
test_roundtrip(Set[int]())
test_roundtrip({11, 22, 33})
test_roundtrip(Dict[str,int]())
test_roundtrip({'aa': 11, 'bb': 22, 'cc': 33})
test_roundtrip((11, 1.1, '11', [1, 1], {1}, {1: 1}))
test_roundtrip(())
test_roundtrip(DynamicTuple((111, 222, 333, 444)))
test_roundtrip(DynamicTuple('hello world'))
test_roundtrip(DynamicTuple[int]())
test_roundtrip(DynamicTuple[str]())
test_roundtrip(Optional(0))
test_roundtrip(Optional(111))
test_roundtrip(Optional[int]())
test_roundtrip(None)

</t>
<t tx="ekr.20230509052845.4732">@test
def test_ops():
    from python import numpy as np
    a = np.array([1, 3])
    assert str(a + 1) == '[2 4]'
    assert str(a - 1) == '[0 2]'
    assert str(a * 2) == '[2 6]'
    assert str(a @ a) == '10'
    assert str(a // 2) == '[0 1]'
    assert str(a / 2) == '[0.5 1.5]'
    assert str(a % 2) == '[1 1]'
    assert str(a ** 2) == '[1 9]'
    assert str(-a) == '[-1 -3]'
    assert str(+a) == '[1 3]'
    assert str(~a) == '[-2 -4]'
    assert str(a &lt;&lt; 1) == '[2 6]'
    assert str(a &gt;&gt; 1) == '[0 1]'
    assert str(a &amp; 2) == '[0 2]'
    assert str(a ^ 2) == '[3 1]'
    assert str(a | 2) == '[3 3]'

    assert str(a &lt; 3) == '[ True False]'
    assert str(a &lt;= 3) == '[ True  True]'
    assert str(a == 3) == '[False  True]'
    assert str(a != 3) == '[ True False]'
    assert str(a &gt; 3) == '[False False]'
    assert str(a &gt;= 3) == '[False  True]'

    assert str(1 + a) == '[2 4]'
    assert str(1 - a) == '[ 0 -2]'
    assert str(2 * a) == '[2 6]'
    assert str(1 // a) == '[1 0]'
    assert str(2 &amp; a) == '[0 2]'
    assert str(2 ^ a) == '[3 1]'
    assert str(2 | a) == '[3 3]'
    n = a[0]
    assert str(10 // n) == '10'
    assert str(10 / n) == '10.0'
    assert str(10 % n) == '0'
    assert str(10 ** n) == '10'
    assert str(4 &lt;&lt; n) == '8'
    assert str(4 &gt;&gt; n) == '2'

    assert str(3 &lt; a) == '[False False]'
    assert str(3 &lt;= a) == '[False  True]'
    assert str(3 == a) == '[False  True]'
    assert str(3 != a) == '[ True False]'
    assert str(3 &gt; a) == '[ True False]'
    assert str(3 &gt;= a) == '[ True  True]'

    a = np.array([1, 3])
    b = a
    a += 1
    assert str(b) == '[2 4]'

    a = np.array([1, 3])
    b = a
    a -= 1
    assert str(b) == '[0 2]'

    a = np.array([1, 3])
    b = a
    a //= 2
    assert str(b) == '[0 1]'

    a = np.array([1.0, 3.0])
    b = a
    a /= 2
    assert str(b) == '[0.5 1.5]'

    a = np.array([1, 3])
    b = a
    a %= 2
    assert str(b) == '[1 1]'

    a = np.array([1, 3])
    b = a
    a **= 2
    assert str(b) == '[1 9]'

    a = np.array([1, 3])
    b = a
    a &lt;&lt;= 1
    assert str(b) == '[2 6]'

    a = np.array([1, 3])
    b = a
    a &gt;&gt;= 1
    assert str(b) == '[0 1]'

    a = np.array([1, 3])
    b = a
    a &amp;= 2
    assert str(b) == '[0 2]'

    a = np.array([1, 3])
    b = a
    a ^= 2
    assert str(b) == '[3 1]'

    a = np.array([1, 3])
    b = a
    a |= 2
    assert str(b) == '[3 3]'

    a = np.array([1, 3])
    n = a[-1]
    assert str(n) == '3'
    assert int(n) == 3
    assert float(n) == 3.0
    from operator import index
    assert index(n) == 3
    assert hash(n) == 3
    assert len(a) == 2
    v = list(iter(a))
    assert len(v) == 2 and v[0] == 1 and v[1] == 3
    a[-1] = 99
    assert repr(a) == 'array([ 1, 99])'
    assert bool(a[0]) == True
    assert bool(a[0] - 1) == False

</t>
<t tx="ekr.20230509052845.4733">@path C:/Repos/codon/test/python/
import myext as m
import myext2 as m2

@others
for _ in range(3000):
    test_codon_extensions(m)
    test_codon_extensions(m2)

assert saw_fun
assert saw_set
assert saw_foo
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4734">def equal(v, a, b, tag):
    ok = (v.a == a and v.b == b and v.tag == tag)
    if not ok:
        print('GOT:', v.a, v.b, v.tag)
        print('EXP:', a, b, tag)
    return ok

</t>
<t tx="ekr.20230509052845.4735">saw_fun = False
saw_set = False
saw_foo = False

</t>
<t tx="ekr.20230509052845.4736">def test_codon_extensions(m):
    m.reset()

    # functions #
    #############

    global saw_fun

    if hasattr(m, 'f1'):
        assert m.f1(2.2, 3.3) == (2.2, 3.3)
        assert m.f1(2.2, 3.3) == (2.2, 3.3)
        assert m.f1(3.3) == (3.3, 2.22)
        assert m.f1() == (1.11, 2.22)
        assert m.f1(a=2.2, b=3.3) == (2.2, 3.3)
        assert m.f1(2.2, b=3.3) == (2.2, 3.3)
        assert m.f1(b=3.3, a=2.2) == (2.2, 3.3)
        assert m.f1(a=2.2) == (2.2, 2.22)
        assert m.f1(b=3.3) == (1.11, 3.3)

        try:
            m.f1(1.1, 2.2, 3.3)
        except:
            pass
        else:
            assert False

        try:
            m.f1(z=1)
        except:
            pass
        else:
            assert False

        assert m.f2() == ({1: 'one'}, {2}, [3])

        try:
            m.f2(1)
        except:
            pass
        else:
            assert False

        try:
            m.f2(z=1, y=5)
        except:
            pass
        else:
            assert False

        assert m.f3(42) == 84
        assert m.f3(1.5) == 3.0
        assert m.f3('x') == 'xx'

        try:
            m.f3(1, 2)
        except:
            pass
        else:
            assert False

        try:
            m.f3(a=1, b=2)
        except:
            pass
        else:
            assert False

        assert m.f4() == ['f4()']
        assert m.f4(2.2, 3.3) == (2.2, 3.3)
        assert m.f4(3.3) == (3.3, 2.22)
        assert m.f4(a=2.2, b=3.3) == (2.2, 3.3)
        assert m.f4(2.2, b=3.3) == (2.2, 3.3)
        assert m.f4(b=3.3, a=2.2) == (2.2, 3.3)
        assert m.f4(a=2.2) == (2.2, 2.22)
        assert m.f4(b=3.3) == (1.11, 3.3)
        assert m.f4('foo') == ('foo', 'foo')
        assert m.f4({1}) == {1}
        assert m.f5() is None
        assert equal(m.f6(1.9, 't'), 1.9, 1.9, 't')

        saw_fun = True

    # constructors #
    ################

    x = m.Vec(3.14, 4.2, 'x')
    y = m.Vec(100, 1000, tag='y')
    z = m.Vec(b=2.2, a=1.1)
    s = m.Vec(10)
    t = m.Vec(b=11)
    r = m.Vec(3, 4)

    assert equal(x, 3.14, 4.2, 'x')
    assert equal(y, 100, 1000, 'y')
    assert equal(z, 1.1, 2.2, 'v0')
    assert equal(s, 10, 0.0, 'v1')
    assert equal(t, 0.0, 11, 'v2')

    try:
        m.Vec(tag=10, a=1, b=2)
    except:
        pass
    else:
        assert False

    # to-str #
    ##########

    assert str(x) == 'x: &lt;3.14, 4.2&gt;'
    assert repr(x) == "Vec(3.14, 4.2, 'x')"

    # methods #
    ###########

    assert x.foo(2.2, 3.3) == (3.14, 2.2, 3.3)
    assert y.foo(3.3) == (100, 3.3, 2.22)
    assert z.foo() == (1.1, 1.11, 2.22)
    assert x.foo(a=2.2, b=3.3) == (3.14, 2.2, 3.3)
    assert x.foo(2.2, b=3.3) == (3.14, 2.2, 3.3)
    assert x.foo(b=3.3, a=2.2) == (3.14, 2.2, 3.3)
    assert x.foo(a=2.2) == (3.14, 2.2, 2.22)
    assert x.foo(b=3.3) == (3.14, 1.11, 3.3)

    try:
        x.foo(1, a=1)
    except:
        pass
    else:
        assert False

    try:
        x.foo(1, 2, b=2)
    except:
        pass
    else:
        assert False

    try:
        x.foo(1, z=2)
    except:
        pass
    else:
        assert False

    assert equal(x.bar(), 3.14, 4.2, 'x')
    assert equal(y.bar(), 100, 1000, 'y')
    assert equal(z.bar(), 1.1, 2.2, 'v0')
    assert equal(s.bar(), 10, 0.0, 'v1')
    assert equal(t.bar(), 0.0, 11, 'v2')

    try:
        x.bar(1)
    except:
        pass
    else:
        assert False

    try:
        x.bar(z=1)
    except:
        pass
    else:
        assert False

    assert m.Vec.baz(2.2, 3.3) == (2.2, 3.3)
    assert x.baz(2.2, 3.3) == (2.2, 3.3)
    assert m.Vec.baz(3.3) == (3.3, 2.22)
    assert m.Vec.baz() == (1.11, 2.22)
    assert m.Vec.baz(a=2.2, b=3.3) == (2.2, 3.3)
    assert m.Vec.baz(2.2, b=3.3) == (2.2, 3.3)
    assert m.Vec.baz(b=3.3, a=2.2) == (2.2, 3.3)
    assert m.Vec.baz(a=2.2) == (2.2, 2.22)
    assert m.Vec.baz(b=3.3) == (1.11, 3.3)

    try:
        m.Vec.baz(1, a=1)
    except:
        pass
    else:
        assert False

    try:
        m.Vec.baz(1, 2, b=2)
    except:
        pass
    else:
        assert False

    assert m.Vec.nop() == 'nop'
    assert x.nop() == 'nop'
    assert y.c == 1100

    # fields #
    ##########

    if hasattr(t, '__setitem__'):
        t.a = 99
        assert equal(t, 99, 11, 'v2')
        t.tag = 't'
        assert equal(t, 99, 11, 't')

    # magics #
    ##########

    assert equal(+y, 100, 1000, '(+y)')
    assert equal(-y, -100, -1000, '(-y)')
    assert equal(~y, -101, -1001, '(~y)')
    assert abs(r) == 5.0
    assert bool(y)
    assert not bool(m.Vec())
    assert len(x) == 1
    assert len(x + y) == 5
    assert hash(y) == 1100

    assert equal(x + y, 103.14, 1004.2, '(x+y)')
    try:
        x + 'x'
    except:
        pass
    else:
        assert False
    assert equal(x + y + y, 203.14, 2004.2, '((x+y)+y)')
    assert equal(y + 50.5, 150.5, 1050.5, '(y+50.5)')
    assert equal(y + 50, 150, 1050, '(y++50)')
    # assert equal(50.5 + y, 150.5, 1050.5, '(y+50.5)')  # support for r-magics?
    assert equal(y - x, 96.86, 995.8, '(y-x)')
    assert equal(y * 3.5, 350.0, 3500.0, '(y*3.5)')
    assert equal(y // 3, 33, 333, '(y//3)')
    assert equal(y / 2.5, 40.0, 400.0, '(y/2.5)')
    try:
        divmod(y, 1)
    except ArithmeticError as e:
        assert str(e) == 'no divmod'
    else:
        assert False
    assert equal(y % 7, 2, 6, '(y%7)')
    assert equal(y ** 2, 10000, 1000000, '(y**2)')
    assert equal(y &lt;&lt; 1, 200, 2000, '(y&lt;&lt;1)')
    assert equal(y &gt;&gt; 2, 25, 250, '(y&gt;&gt;2)')
    assert equal(y &amp; 77, 68, 72, '(y&amp;77)')
    assert equal(y | 77, 109, 1005, '(y|77)')
    assert equal(y ^ 77, 41, 933, '(y^77)')
    assert y @ r == 4300

    @others
    for n in (0, 1, 10, 33, 999, 1237):
        assert m.par_sum(n) == par_sum_check(n)

</t>
<t tx="ekr.20230509052845.4737">def dup(v):
    return m.Vec(v.a, v.b, v.tag + '1')

</t>
<t tx="ekr.20230509052845.4738">y1 = dup(y)
y1 += x
assert equal(y1, 103.14, 1004.2, '(y1+=x)')

y1 = dup(y)
y1 += 1.5
assert equal(y1, 101.5, 1001.5, '(y1+=1.5)')

y1 = dup(y)
y1 -= x
assert equal(y1, 96.86, 995.8, '(y1-=x)')

y1 = dup(y)
y1 *= 3.5
assert equal(y1, 350.0, 3500.0, '(y1*=3.5)')

y1 = dup(y)
y1 //= 3
assert equal(y1, 33, 333, '(y1//=3)')

y1 = dup(y)
y1 /= 2.5
assert equal(y1, 40.0, 400.0, '(y1/=2.5)')

y1 = dup(y)
y1 %= 7
assert equal(y1, 2, 6, '(y1%=7)')

y1 = dup(y)
y1 **= 2
assert equal(y1, 10000, 1000000, '(y1**=2)')

y1 = dup(y)
y1 &lt;&lt;= 1
assert equal(y1, 200, 2000, '(y1&lt;&lt;=1)')

y1 = dup(y)
y1 &gt;&gt;= 2
assert equal(y1, 25, 250, '(y1&gt;&gt;=2)')

y1 = dup(y)
y1 &amp;= 77
assert equal(y1, 68, 72, '(y1&amp;=77)')

y1 = dup(y)
y1 |= 77
assert equal(y1, 109, 1005, '(y1|=77)')

y1 = dup(y)
y1 ^= 77
assert equal(y1, 41, 933, '(y1^=77)')

y1 = dup(y)
y1 @= 3.5
assert equal(y1, 350.0, 3500.0, '(y1@=3.5)')

assert equal(y(), 100, 1000, '(y())')
assert x(2.2, 3.3) == (3.14, 2.2, 3.3)
assert y(3.3) == (100, 3.3, 2.22)
assert x(a=2.2, b=3.3) == (3.14, 2.2, 3.3)
assert x(2.2, b=3.3) == (3.14, 2.2, 3.3)
assert x(b=3.3, a=2.2) == (3.14, 2.2, 3.3)
assert x(a=2.2) == (3.14, 2.2, 2.22)
assert x(b=3.3) == (3.14, 1.11, 3.3)
assert y('foo') == (100.0, 1000.0, 'foo')

assert x == x
assert x != y
assert r == m.Vec(3, 4, '?')
assert x &lt; y
assert y &gt; x
assert x &lt;= y
assert y &gt;= x
assert y &lt;= y
assert x &gt;= x

assert list(iter(x)) == ['x']
assert list(iter(x+y+y)) == list('((x+y)+y)')

assert 100 in y
assert 1000 in y
assert 100.5 not in y
assert 'y' in y
assert 'x' not in y

assert y[0] == 100
assert y[1] == 1000
assert y[11] == 1100
try:
    y[-1]
except KeyError as e:
    assert str(e) == "'bad vec key -1'"
else:
    assert False

global saw_set
if hasattr(y, '__setitem__'):
    y[0] = 99.9
    assert equal(y, 99.9, 1000, 'y')
    y[1] = -42.6
    assert equal(y, 99.9, -42.6, 'y')
    y[11] = 7.7
    assert equal(y, 7.7, 7.7, 'y')
    try:
        y[2] = 1.2
    except KeyError as e:
        assert str(e) == "'bad vec key 2 with val 1.2'"
    else:
        assert False

    del y[1]
    assert equal(y, 7.7, 0.0, 'y')

    saw_set = True

assert m.Vec.nd() &gt; 0

# tuple classes #
#################
global saw_foo
if hasattr(m, 'Foo'):
    x = m.Foo(list('hello'))
    assert x.a == list('hello')
    assert x.x == {s: i for i, s in enumerate('hello')}
    assert x.hello() == 'x'

    try:
        x.a = ['bye']
    except AttributeError:
        pass
    else:
        assert False

    assert int(x) == 42
    assert float(x) == 3.14
    assert x.__index__() == 99
    saw_foo = True

</t>
<t tx="ekr.20230509052845.4739"># Codon-specific #
##################
def par_sum_check(n):
    m = 0
    for i in range(n):
        m += 3*i + 7
    return m

</t>
<t tx="ekr.20230509052845.474">  bool doIsAtomic() const override {
    return !std::any_of(fields.begin(), fields.end(),
                        [](auto &amp;field) { return !field.getType()-&gt;isAtomic(); });
  }
</t>
<t tx="ekr.20230509052845.4740">@path C:/Repos/codon/test/python/
import os
import sys
import shutil

from pathlib import Path
from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext


codon_path = os.environ.get("CODON_DIR")
if not codon_path:
    c = shutil.which("codon")
    if c:
        codon_path = Path(c).parent / ".."
else:
    codon_path = Path(codon_path)
for path in [
    os.path.expanduser("~") + "/.codon",
    os.getcwd() + "/..",
]:
    path = Path(path)
    if not codon_path and path.exists():
        codon_path = path
        break

if (
    not codon_path
    or not (codon_path / "include" / "codon").exists()
    or not (codon_path / "lib" / "codon").exists()
):
    print(
        "Cannot find Codon.",
        'Please either install Codon (/bin/bash -c "$(curl -fsSL https://exaloop.io/install.sh)"),',
        "or set CODON_DIR if Codon is not in PATH or installed in ~/.codon",
        file=sys.stderr,
    )
    sys.exit(1)
codon_path = codon_path.resolve()
print("Codon: " + str(codon_path))


@others
setup(
    name='myext',
    version='0.1',
    packages=['myext'],
    ext_modules=[
        CodonExtension('myext', 'myextension.codon'),
    ],
    cmdclass={'build_ext': BuildCodonExt}
)

setup(
    name='myext2',
    version='0.1',
    packages=['myext2'],
    ext_modules=[
        CodonExtension('myext2', 'myextension2.codon'),
    ],
    cmdclass={'build_ext': BuildCodonExt}
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4741">class CodonExtension(Extension):
    def __init__(self, name, source):
        self.source = source
        super().__init__(name, sources=[], language='c')

</t>
<t tx="ekr.20230509052845.4742">class BuildCodonExt(build_ext):
    @others
</t>
<t tx="ekr.20230509052845.4743">def build_extensions(self):
    pass

</t>
<t tx="ekr.20230509052845.4744">def run(self):
    inplace, self.inplace = self.inplace, False
    super().run()
    for ext in self.extensions:
        self.build_codon(ext)
    if inplace:
        self.copy_extensions_to_source()

</t>
<t tx="ekr.20230509052845.4745">def build_codon(self, ext):
    extension_path = Path(self.get_ext_fullpath(ext.name))
    build_dir = Path(self.build_temp)
    os.makedirs(build_dir, exist_ok=True)
    os.makedirs(extension_path.parent.absolute(), exist_ok=True)

    optimization = '-debug' if self.debug else '-release'
    self.spawn([
        str(codon_path / "bin" / "codon"), 'build', optimization, "--relocation-model=pic",
        '-pyext', '-o', str(extension_path) + ".o", '-module', ext.name, ext.source])

    print('--&gt;', extension_path)
    ext.runtime_library_dirs = [str(codon_path / "lib" / "codon")]
    self.compiler.link_shared_object(
        [str(extension_path) + ".o"],
        str(extension_path),
        libraries=["codonrt"],
        library_dirs=ext.runtime_library_dirs,
        runtime_library_dirs=ext.runtime_library_dirs,
        extra_preargs=['-Wl,-rpath,@loader_path'],
        # export_symbols=self.get_export_symbols(ext),
        debug=self.debug,
        build_temp=self.build_temp,
    )
    self.distribution.codon_lib = extension_path

</t>
<t tx="ekr.20230509052845.4746">@path C:/Repos/codon/test/python/
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4747"></t>
<t tx="ekr.20230509052845.4748">@path C:/Repos/codon/test/stdlib/
import bisect
import sys

li = [1, 3, 4, 4, 4, 6, 7]
lst = [10, 20, 30, 40, 50]

str = ["a", "b", "b", "c", "d"]


@others
bisect_left()
bisect_right()
bisect1()
insort_left()
insort_right()
insort()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4749">@test
def bisect_left():
    assert bisect.bisect_left(li, 4, 0, len(li)) == 2
    assert bisect.bisect_left(li, 4) == 2
    assert bisect.bisect_left(str, "b", 0, len(str)) == 1
    assert bisect.bisect_left(lst, 25, 1, 3) == 2

    # precomputed cases
    assert bisect.bisect_left(List[int](), 1, 0, 0) == 0
    assert bisect.bisect_left([1], 0, 0, 1) == 0
    assert bisect.bisect_left([1], 1, 0, 1) == 0
    assert bisect.bisect_left([1], 2, 0, 1) == 1
    assert bisect.bisect_left([1, 1], 0, 0, 2) == 0
    assert bisect.bisect_left([1, 1], 1, 0, 2) == 0
    assert bisect.bisect_left([1, 1], 2, 0, 2) == 2
    assert bisect.bisect_left([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect_left([1, 1, 1], 1, 0, 3) == 0
    assert bisect.bisect_left([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect_left([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 1, 1], 1, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect_left([1, 2], 0, 0, 2) == 0
    assert bisect.bisect_left([1, 2], 1, 0, 2) == 0
    assert bisect.bisect_left([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect_left([1, 2], 2, 0, 2) == 1
    assert bisect.bisect_left([1, 2], 3, 0, 2) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 2, 2], 1, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 2, 0, 4) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect_left([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect_left([1, 2, 3], 1, 0, 3) == 0
    assert bisect.bisect_left([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect_left([1, 2, 3], 2, 0, 3) == 1
    assert bisect.bisect_left([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect_left([1, 2, 3], 3, 0, 3) == 2
    assert bisect.bisect_left([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 0
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 1
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 6
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


</t>
<t tx="ekr.20230509052845.475">/// Membered type that is passed by reference. Similar to Python classes.
class RefType : public AcceptorExtend&lt;RefType, MemberedType&gt; {
private:
  /// the internal contents of the type
  Type *contents;

public:
  static const char NodeId;

  /// Constructs a reference type.
  /// @param name the type's name
  /// @param contents the type's contents
  RefType(std::string name, RecordType *contents)
      : AcceptorExtend(std::move(name)), contents(contents) {}

  Type *getMemberType(const std::string &amp;n) const override {
    return getContents()-&gt;getMemberType(n);
  }
@others
private:
  std::vector&lt;Type *&gt; doGetUsedTypes() const override { return {contents}; }

  bool doIsAtomic() const override { return false; }

  bool doIsContentAtomic() const override;

  Value *doConstruct(std::vector&lt;Value *&gt; args) override;
};

</t>
<t tx="ekr.20230509052845.4750">@test
def bisect_right():
    assert bisect.bisect_right(li, 4, 0, len(li)) == 5
    assert bisect.bisect_right(li, 4) == 5
    assert bisect.bisect_right(str, "b", 0, len(str)) == 3
    assert bisect.bisect_right(lst, 25, 1, 3) == 2

    # precomputed casesrightrt bisect.bisect_right(List[int](), 1, 0, 0) == 0
    assert bisect.bisect_right([1], 0, 0, 1) == 0
    assert bisect.bisect_right([1], 1, 0, 1) == 1
    assert bisect.bisect_right([1], 2, 0, 1) == 1
    assert bisect.bisect_right([1, 1], 0, 0, 2) == 0
    assert bisect.bisect_right([1, 1], 1, 0, 2) == 2
    assert bisect.bisect_right([1, 1], 2, 0, 2) == 2
    assert bisect.bisect_right([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect_right([1, 1, 1], 1, 0, 3) == 3
    assert bisect.bisect_right([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect_right([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect_right([1, 1, 1, 1], 1, 0, 4) == 4
    assert bisect.bisect_right([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect_right([1, 2], 0, 0, 2) == 0
    assert bisect.bisect_right([1, 2], 1, 0, 2) == 1
    assert bisect.bisect_right([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect_right([1, 2], 2, 0, 2) == 2
    assert bisect.bisect_right([1, 2], 3, 0, 2) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect_right([1, 1, 2, 2], 1, 0, 4) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 2, 0, 4) == 4
    assert bisect.bisect_right([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect_right([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect_right([1, 2, 3], 1, 0, 3) == 1
    assert bisect.bisect_right([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect_right([1, 2, 3], 2, 0, 3) == 2
    assert bisect.bisect_right([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect_right([1, 2, 3], 3, 0, 3) == 3
    assert bisect.bisect_right([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 1
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 6
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 10
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


</t>
<t tx="ekr.20230509052845.4751">@test
def bisect1():
    assert bisect.bisect(li, 4, 0, len(li)) == 5
    assert bisect.bisect(str, "b", 0, len(str)) == 3
    assert bisect.bisect(lst, 25, 1, 3) == 2

    # precomputed casesrightrt bisect.bisect_right(List[int](), 1, 0, 0) == 0
    assert bisect.bisect([1], 0, 0, 1) == 0
    assert bisect.bisect([1], 1, 0, 1) == 1
    assert bisect.bisect([1], 2, 0, 1) == 1
    assert bisect.bisect([1, 1], 0, 0, 2) == 0
    assert bisect.bisect([1, 1], 1, 0, 2) == 2
    assert bisect.bisect([1, 1], 2, 0, 2) == 2
    assert bisect.bisect([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect([1, 1, 1], 1, 0, 3) == 3
    assert bisect.bisect([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect([1, 1, 1, 1], 1, 0, 4) == 4
    assert bisect.bisect([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect([1, 2], 0, 0, 2) == 0
    assert bisect.bisect([1, 2], 1, 0, 2) == 1
    assert bisect.bisect([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect([1, 2], 2, 0, 2) == 2
    assert bisect.bisect([1, 2], 3, 0, 2) == 2
    assert bisect.bisect([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect([1, 1, 2, 2], 1, 0, 4) == 2
    assert bisect.bisect([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect([1, 1, 2, 2], 2, 0, 4) == 4
    assert bisect.bisect([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect([1, 2, 3], 1, 0, 3) == 1
    assert bisect.bisect([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect([1, 2, 3], 2, 0, 3) == 2
    assert bisect.bisect([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect([1, 2, 3], 3, 0, 3) == 3
    assert bisect.bisect([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 1
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 6
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 10
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


</t>
<t tx="ekr.20230509052845.4752">@test
def insort_left():
    bisect.insort_left(li, 5)
    assert li == [1, 3, 4, 4, 4, 5, 6, 7]


</t>
<t tx="ekr.20230509052845.4753">@test
def insort_right():
    li = [1, 3, 4, 4, 4, 6, 7]
    bisect.insort_right(li, 0, 0, len(li))
    assert li == [0, 1, 3, 4, 4, 4, 6, 7]
    bisect.insort_right(li, 10)
    assert li == [0, 1, 3, 4, 4, 4, 6, 7, 10]


</t>
<t tx="ekr.20230509052845.4754">@test
def insort():
    li = [1, 3, 4, 4, 4, 6, 7]
    bisect.insort(li, 0, 0, len(li))
    assert li == [0, 1, 3, 4, 4, 4, 6, 7]
    bisect.insort(li, 10)
    assert li == [0, 1, 3, 4, 4, 4, 6, 7, 10]


</t>
<t tx="ekr.20230509052845.4755">@path C:/Repos/codon/test/stdlib/
import math
import cmath

INF = float("inf")
NAN = float("nan")


@others
test_complex64()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4756">def float_identical(x, y):
    if math.isnan(x) or math.isnan(y):
        if math.isnan(x) and math.isnan(y):
            return True
    elif x == y:
        if x != 0.0:
            return True
        # both zero; check that signs match
        elif math.copysign(1.0, x) == math.copysign(1.0, y):
            return True
        else:
            return False
    return False


</t>
<t tx="ekr.20230509052845.4757">def complex_identical(x, y):
    return float_identical(x.real, y.real) and float_identical(x.imag, y.imag)


</t>
<t tx="ekr.20230509052845.4758">###########
# complex #
###########

ZERO_DIVISION = (
    (1 + 1j, 0 + 0j),
    (1 + 1j, 0.0 + 0j),
    (1 + 1j, 0 + 0j),
    (1.0 + 0j, 0 + 0j),
    (1 + 0j, 0 + 0j),
)


</t>
<t tx="ekr.20230509052845.4759">def close_abs(x, y, eps=1e-9):
    """Return true iff floats x and y "are close"."""
    # put the one with larger magnitude second
    if abs(x) &gt; abs(y):
        x, y = y, x
    if y == 0:
        return abs(x) &lt; eps
    if x == 0:
        return abs(y) &lt; eps
    # check that relative difference &lt; eps
    return abs((x - y) / y) &lt; eps


</t>
<t tx="ekr.20230509052845.476">  int getMemberIndex(const std::string &amp;n) const override {
    return getContents()-&gt;getMemberIndex(n);
  }

</t>
<t tx="ekr.20230509052845.4760">def close_complex(x, y, eps=1e-9):
    a = complex(x)
    b = complex(y)
    return close_abs(a.real, b.real, eps) and close_abs(a.imag, b.imag, eps)


</t>
<t tx="ekr.20230509052845.4761">def check_div(x, y):
    """Compute complex z=x*y, and check that z/x==y and z/y==x."""
    z = x * y
    if x != 0:
        q = z / x
        if not close_complex(q, y):
            return False
        q = z.__truediv__(x)
        if not close_complex(q, y):
            return False
    if y != 0:
        q = z / y
        if not close_complex(q, x):
            return False
        q = z.__truediv__(y)
        if not close_complex(q, x):
            return False
    return True


</t>
<t tx="ekr.20230509052845.4762">@test
def test_truediv():
    from random import random

    simple_real = [float(i) for i in range(-5, 6)]
    simple_complex = [complex(x, y) for x in simple_real for y in simple_real]
    for x in simple_complex:
        for y in simple_complex:
            assert check_div(x, y)

    # A naive complex division algorithm (such as in 2.0) is very prone to
    # nonsense errors for these (overflows and underflows).
    assert check_div(complex(1e200, 1e200), 1 + 0j)
    assert check_div(complex(1e-200, 1e-200), 1 + 0j)

    # Just for fun.
    for i in range(100):
        check_div(complex(random(), random()), complex(random(), random()))

    assert close_complex(complex.__truediv__(2 + 0j, 1 + 1j), 1 - 1j)

    for denom_real, denom_imag in [(0.0, NAN), (NAN, 0.0), (NAN, NAN)]:
        z = complex(0, 0) / complex(denom_real, denom_imag)
        assert math.isnan(z.real)
        assert math.isnan(z.imag)


</t>
<t tx="ekr.20230509052845.4763">test_truediv()


</t>
<t tx="ekr.20230509052845.4764">@test
def test_richcompare():
    assert not complex.__eq__(1 + 1j, 1 &lt;&lt; 10000)
    assert complex.__eq__(1 + 1j, 1 + 1j)
    assert not complex.__eq__(1 + 1j, 2 + 2j)
    assert not complex.__ne__(1 + 1j, 1 + 1j)
    assert complex.__ne__(1 + 1j, 2 + 2j), True
    for i in range(1, 100):
        f = i / 100.0
        assert complex.__eq__(f + 0j, f)
        assert not complex.__ne__(f + 0j, f)
        assert not complex.__eq__(complex(f, f), f)
        assert complex.__ne__(complex(f, f), f)

    import operator

    assert operator.eq(1 + 1j, 1 + 1j) == True
    assert operator.eq(1 + 1j, 2 + 2j) == False
    assert operator.ne(1 + 1j, 1 + 1j) == False
    assert operator.ne(1 + 1j, 2 + 2j) == True


</t>
<t tx="ekr.20230509052845.4765">test_richcompare()


</t>
<t tx="ekr.20230509052845.4766">@test
def test_pow():
    @others
    assert close_complex(pow(1 + 1j, 0 + 0j), 1.0)
    assert close_complex(pow(0 + 0j, 2 + 0j), 0.0)
    assert close_complex(pow(1j, -1), 1 / (1j))
    assert close_complex(pow(1j, 200), 1)

    a = 3.33 + 4.43j
    assert a ** (0j) == 1
    assert a ** (0.0 + 0.0j) == 1

    assert (3j) ** (0j) == 1
    assert (3j) ** 0 == 1

    # The following is used to exercise certain code paths
    assert a ** 105 == a ** 105
    assert a ** -105 == a ** -105
    assert a ** -30 == a ** -30

    assert (0.0j) ** 0 == 1


</t>
<t tx="ekr.20230509052845.4767">def pow(a, b):
    return a ** b

</t>
<t tx="ekr.20230509052845.4768">test_pow()


</t>
<t tx="ekr.20230509052845.4769">@test
def test_conjugate():
    assert close_complex(complex(5.3, 9.8).conjugate(), 5.3 - 9.8j)


</t>
<t tx="ekr.20230509052845.477">  const_iterator begin() const override { return getContents()-&gt;begin(); }
  const_iterator end() const override { return getContents()-&gt;end(); }
  const_reference front() const override { return getContents()-&gt;front(); }
  const_reference back() const override { return getContents()-&gt;back(); }

  /// @return the reference type's contents
  RecordType *getContents() const { return cast&lt;RecordType&gt;(contents); }
  /// Sets the reference type's contents. Should not generally be used.
  /// @param t the new contents
  void setContents(RecordType *t) { contents = t; }

</t>
<t tx="ekr.20230509052845.4770">test_conjugate()


</t>
<t tx="ekr.20230509052845.4771">@test
def test_cabs():
    nums = [complex(x / 3.0, y / 7.0) for x in range(-9, 9) for y in range(-9, 9)]
    for num in nums:
        assert close_complex((num.real ** 2 + num.imag ** 2) ** 0.5, abs(num))


</t>
<t tx="ekr.20230509052845.4772">test_cabs()


</t>
<t tx="ekr.20230509052845.4773">@test
def test_negative_zero_repr_str():
    @others
    assert test(complex(0.0, 1.0), "1j")
    assert test(complex(-0.0, 1.0), "(-0+1j)")
    assert test(complex(0.0, -1.0), "-1j")
    assert test(complex(-0.0, -1.0), "(-0-1j)")

    assert test(complex(0.0, 0.0), "0j")
    assert test(complex(0.0, -0.0), "-0j")
    assert test(complex(-0.0, 0.0), "(-0+0j)")
    assert test(complex(-0.0, -0.0), "(-0-0j)")


</t>
<t tx="ekr.20230509052845.4774">def test(v, expected):
    return str(v) == expected

</t>
<t tx="ekr.20230509052845.4775">test_negative_zero_repr_str()

#########
# cmath #
#########

complex_zeros = [complex(x, y) for x in [0.0, -0.0] for y in [0.0, -0.0]]
complex_infinities = [
    complex(x, y)
    for x, y in [
        (INF, 0.0),  # 1st quadrant
        (INF, 2.3),
        (INF, INF),
        (2.3, INF),
        (0.0, INF),
        (-0.0, INF),  # 2nd quadrant
        (-2.3, INF),
        (-INF, INF),
        (-INF, 2.3),
        (-INF, 0.0),
        (-INF, -0.0),  # 3rd quadrant
        (-INF, -2.3),
        (-INF, -INF),
        (-2.3, -INF),
        (-0.0, -INF),
        (0.0, -INF),  # 4th quadrant
        (2.3, -INF),
        (INF, -INF),
        (INF, -2.3),
        (INF, -0.0),
    ]
]
complex_nans = [
    complex(x, y)
    for x, y in [
        (NAN, -INF),
        (NAN, -2.3),
        (NAN, -0.0),
        (NAN, 0.0),
        (NAN, 2.3),
        (NAN, INF),
        (-INF, NAN),
        (-2.3, NAN),
        (-0.0, NAN),
        (0.0, NAN),
        (2.3, NAN),
        (INF, NAN),
    ]
]


</t>
<t tx="ekr.20230509052845.4776">@llvm
@pure
def small() -&gt; float:
    ret double 4.940660e-323


</t>
<t tx="ekr.20230509052845.4777">def almost_equal(a, b, rel_err=2e-15, abs_err=small()):
    if math.isnan(a):
        if math.isnan(b):
            return True
        return False

    if math.isinf(a):
        if a == b:
            return True
        return False

    if not a and not b:
        if math.copysign(1.0, a) != math.copysign(1.0, b):
            return False

    absolute_error = abs(b - a)
    if absolute_error &lt;= max(abs_err, rel_err * abs(a)):
        return True
    return False


</t>
<t tx="ekr.20230509052845.4778">@test
def test_constants():
    e_expected = 2.71828182845904523536
    pi_expected = 3.14159265358979323846
    assert math.isclose(cmath.pi, pi_expected)
    assert math.isclose(cmath.e, e_expected)


</t>
<t tx="ekr.20230509052845.4779">test_constants()


</t>
<t tx="ekr.20230509052845.478">  void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) override {
    getContents()-&gt;realize(std::move(mTypes), std::move(mNames));
  }

</t>
<t tx="ekr.20230509052845.4780">@test
def test_infinity_and_nan_constants():
    assert cmath.inf.real == math.inf
    assert cmath.inf.imag == 0.0
    assert cmath.infj.real == 0.0
    assert cmath.infj.imag == math.inf

    assert math.isnan(cmath.nan.real)
    assert cmath.nan.imag == 0.0
    assert cmath.nanj.real == 0.0
    assert math.isnan(cmath.nanj.imag)

    assert str(cmath.inf) == "inf"
    assert str(cmath.infj) == "infj"
    assert str(cmath.nan) == "nan"
    assert str(cmath.nanj) == "nanj"


</t>
<t tx="ekr.20230509052845.4781">test_infinity_and_nan_constants()


</t>
<t tx="ekr.20230509052845.4782">@test
def test_user_object():
    @others
    x = MyComplexOS(4.2)
    assert cmath.acos(x) == cmath.acos(x.value)
    assert cmath.acosh(x) == cmath.acosh(x.value)
    assert cmath.asin(x) == cmath.asin(x.value)
    assert cmath.asinh(x) == cmath.asinh(x.value)
    assert cmath.atan(x) == cmath.atan(x.value)
    assert cmath.atanh(x) == cmath.atanh(x.value)
    assert cmath.cos(x) == cmath.cos(x.value)
    assert cmath.cosh(x) == cmath.cosh(x.value)
    assert cmath.exp(x) == cmath.exp(x.value)
    assert cmath.log(x) == cmath.log(x.value)
    assert cmath.log10(x) == cmath.log10(x.value)
    assert cmath.sin(x) == cmath.sin(x.value)
    assert cmath.sinh(x) == cmath.sinh(x.value)
    assert cmath.sqrt(x) == cmath.sqrt(x.value)
    assert cmath.tan(x) == cmath.tan(x.value)
    assert cmath.tanh(x) == cmath.tanh(x.value)


</t>
<t tx="ekr.20230509052845.4783">class MyComplexOS:
    value: T
    T: type

    def __init__(self, value: T):
        self.value = value

    def __complex__(self):
        return self.value

</t>
<t tx="ekr.20230509052845.4784">test_user_object()


</t>
<t tx="ekr.20230509052845.4785">@test
def test_input_type():
    x = 42
    y = float(x)
    assert cmath.acos(x) == cmath.acos(y)
    assert cmath.acosh(x) == cmath.acosh(y)
    assert cmath.asin(x) == cmath.asin(y)
    assert cmath.asinh(x) == cmath.asinh(y)
    assert cmath.atan(x) == cmath.atan(y)
    assert cmath.atanh(x) == cmath.atanh(y)
    assert cmath.cos(x) == cmath.cos(y)
    assert cmath.cosh(x) == cmath.cosh(y)
    assert cmath.exp(x) == cmath.exp(y)
    assert cmath.log(x) == cmath.log(y)
    assert cmath.log10(x) == cmath.log10(y)
    assert cmath.sin(x) == cmath.sin(y)
    assert cmath.sinh(x) == cmath.sinh(y)
    assert cmath.sqrt(x) == cmath.sqrt(y)
    assert cmath.tan(x) == cmath.tan(y)
    assert cmath.tanh(x) == cmath.tanh(y)


</t>
<t tx="ekr.20230509052845.4786">test_input_type()


</t>
<t tx="ekr.20230509052845.4787">@test
def test_cmath_matches_math():
    test_values = [0.01, 0.1, 0.2, 0.5, 0.9, 0.99]
    unit_interval = test_values + [-x for x in test_values] + [0.0, 1.0, -1.0]
    positive = test_values + [1.0] + [1.0 / x for x in test_values]
    nonnegative = [0.0] + positive
    real_line = [0.0] + positive + [-x for x in positive]

    test_functions = {
        "acos": unit_interval,
        "asin": unit_interval,
        "atan": real_line,
        "cos": real_line,
        "cosh": real_line,
        "exp": real_line,
        "log": positive,
        "log10": positive,
        "sin": real_line,
        "sinh": real_line,
        "sqrt": nonnegative,
        "tan": real_line,
        "tanh": real_line,
    }

    for v in test_functions["acos"]:
        z = cmath.acos(v)
        assert almost_equal(z.real, math.acos(v))
        assert z.imag == 0.0

    for v in test_functions["asin"]:
        z = cmath.asin(v)
        assert almost_equal(z.real, math.asin(v))
        assert z.imag == 0.0

    for v in test_functions["atan"]:
        z = cmath.atan(v)
        assert almost_equal(z.real, math.atan(v))
        assert z.imag == 0.0

    for v in test_functions["cos"]:
        z = cmath.cos(v)
        assert almost_equal(z.real, math.cos(v))
        assert z.imag == 0.0

    for v in test_functions["cosh"]:
        z = cmath.cosh(v)
        assert almost_equal(z.real, math.cosh(v))
        assert z.imag == 0.0

    for v in test_functions["exp"]:
        z = cmath.exp(v)
        assert almost_equal(z.real, math.exp(v))
        assert z.imag == 0.0

    for v in test_functions["log"]:
        z = cmath.log(v)
        assert almost_equal(z.real, math.log(v))
        assert z.imag == 0.0

    for v in test_functions["log10"]:
        z = cmath.log10(v)
        assert almost_equal(z.real, math.log10(v))
        assert z.imag == 0.0

    for v in test_functions["sin"]:
        z = cmath.sin(v)
        assert almost_equal(z.real, math.sin(v))
        assert z.imag == 0.0

    for v in test_functions["sinh"]:
        z = cmath.sinh(v)
        assert almost_equal(z.real, math.sinh(v))
        assert z.imag == 0.0

    for v in test_functions["sqrt"]:
        z = cmath.sqrt(v)
        assert almost_equal(z.real, math.sqrt(v))
        assert z.imag == 0.0

    for v in test_functions["tan"]:
        z = cmath.tan(v)
        assert almost_equal(z.real, math.tan(v))
        assert z.imag == 0.0

    for v in test_functions["tanh"]:
        z = cmath.tanh(v)
        assert almost_equal(z.real, math.tanh(v))
        assert z.imag == 0.0

    for base in [0.5, 2.0, 10.0]:
        for v in positive:
            z = cmath.log(v, base)
            s = math.log(v, base)
            # added 'or z.real == s' since Codon version gives -0 vs. +0 in one test
            assert almost_equal(z.real, math.log(v, base)) or z.real == s
            assert z.imag == 0.0


</t>
<t tx="ekr.20230509052845.4788">test_cmath_matches_math()


</t>
<t tx="ekr.20230509052845.4789">@test
def test_polar():
    @others
    pi = cmath.pi
    assert check(0, (0.0, 0.0))
    assert check(1, (1.0, 0.0))
    assert check(-1, (1.0, pi))
    assert check(1j, (1.0, pi / 2))
    assert check(-3j, (3.0, -pi / 2))
    inf = float("inf")
    assert check(complex(inf, 0), (inf, 0.0))
    assert check(complex(-inf, 0), (inf, pi))
    assert check(complex(3, inf), (inf, pi / 2))
    assert check(complex(5, -inf), (inf, -pi / 2))
    assert check(complex(inf, inf), (inf, pi / 4))
    assert check(complex(inf, -inf), (inf, -pi / 4))
    assert check(complex(-inf, inf), (inf, 3 * pi / 4))
    assert check(complex(-inf, -inf), (inf, -3 * pi / 4))
    nan = float("nan")
    assert check(complex(nan, 0), (nan, nan))
    assert check(complex(0, nan), (nan, nan))
    assert check(complex(nan, nan), (nan, nan))
    assert check(complex(inf, nan), (inf, nan))
    assert check(complex(-inf, nan), (inf, nan))
    assert check(complex(nan, inf), (inf, nan))
    assert check(complex(nan, -inf), (inf, nan))


</t>
<t tx="ekr.20230509052845.479">/// Type associated with a CIR function.
class FuncType : public AcceptorExtend&lt;FuncType, Type&gt; {
public:
  using const_iterator = std::vector&lt;Type *&gt;::const_iterator;
  using const_reference = std::vector&lt;Type *&gt;::const_reference;

private:
  /// return type
  Type *rType;
  /// argument types
  std::vector&lt;Type *&gt; argTypes;
  /// whether the function is variadic (e.g. "printf" in C)
  bool variadic;

public:
  static const char NodeId;

  /// Constructs a function type.
  /// @param rType the function's return type
  /// @param argTypes the function's arg types
  FuncType(std::string name, Type *rType, std::vector&lt;Type *&gt; argTypes,
           bool variadic = false)
      : AcceptorExtend(std::move(name)), rType(rType), argTypes(std::move(argTypes)),
        variadic(variadic) {}

  /// @return the function's return type
  Type *getReturnType() const { return rType; }
  /// @return true if the function is variadic
  bool isVariadic() const { return variadic; }

  /// @return iterator to the first argument
  const_iterator begin() const { return argTypes.begin(); }
  /// @return iterator beyond the last argument
  const_iterator end() const { return argTypes.end(); }
  /// @return a reference to the first argument
  const_reference front() const { return argTypes.front(); }
  /// @return a reference to the last argument
  const_reference back() const { return argTypes.back(); }

private:
  std::vector&lt;Generic&gt; doGetGenerics() const override;

  std::vector&lt;Type *&gt; doGetUsedTypes() const override;

  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509052845.4790">def check(arg, expected):
    got = cmath.polar(arg)
    return all(almost_equal(e, g) for e, g in zip(expected, got))

</t>
<t tx="ekr.20230509052845.4791">test_polar()


</t>
<t tx="ekr.20230509052845.4792">@test
def test_phase():
    from cmath import phase, pi

    assert almost_equal(phase(0), 0.0)
    assert almost_equal(phase(1.0), 0.0)
    assert almost_equal(phase(-1.0), pi)
    assert almost_equal(phase(-1.0 + 1e-300j), pi)
    assert almost_equal(phase(-1.0 - 1e-300j), -pi)
    assert almost_equal(phase(1j), pi / 2)
    assert almost_equal(phase(-1j), -pi / 2)

    # zeros
    assert phase(complex(0.0, 0.0)) == 0.0
    assert phase(complex(0.0, -0.0)) == -0.0
    assert phase(complex(-0.0, 0.0)) == pi
    assert phase(complex(-0.0, -0.0)) == -pi

    # infinities
    assert almost_equal(phase(complex(-INF, -0.0)), -pi)
    assert almost_equal(phase(complex(-INF, -2.3)), -pi)
    assert almost_equal(phase(complex(-INF, -INF)), -0.75 * pi)
    assert almost_equal(phase(complex(-2.3, -INF)), -pi / 2)
    assert almost_equal(phase(complex(-0.0, -INF)), -pi / 2)
    assert almost_equal(phase(complex(0.0, -INF)), -pi / 2)
    assert almost_equal(phase(complex(2.3, -INF)), -pi / 2)
    assert almost_equal(phase(complex(INF, -INF)), -pi / 4)
    assert phase(complex(INF, -2.3)) == -0.0
    assert phase(complex(INF, -0.0)) == -0.0
    assert phase(complex(INF, 0.0)) == 0.0
    assert phase(complex(INF, 2.3)) == 0.0
    assert almost_equal(phase(complex(INF, INF)), pi / 4)
    assert almost_equal(phase(complex(2.3, INF)), pi / 2)
    assert almost_equal(phase(complex(0.0, INF)), pi / 2)
    assert almost_equal(phase(complex(-0.0, INF)), pi / 2)
    assert almost_equal(phase(complex(-2.3, INF)), pi / 2)
    assert almost_equal(phase(complex(-INF, INF)), 0.75 * pi)
    assert almost_equal(phase(complex(-INF, 2.3)), pi)
    assert almost_equal(phase(complex(-INF, 0.0)), pi)

    # real or imaginary part NaN
    for z in complex_nans:
        assert math.isnan(phase(z))


</t>
<t tx="ekr.20230509052845.4793">test_phase()


</t>
<t tx="ekr.20230509052845.4794">@test
def test_abs():
    # zeros
    for z in complex_zeros:
        assert abs(z) == 0.0

    # infinities
    for z in complex_infinities:
        assert abs(z) == INF

    # real or imaginary part NaN
    assert abs(complex(NAN, -INF)) == INF
    assert math.isnan(abs(complex(NAN, -2.3)))
    assert math.isnan(abs(complex(NAN, -0.0)))
    assert math.isnan(abs(complex(NAN, 0.0)))
    assert math.isnan(abs(complex(NAN, 2.3)))
    assert abs(complex(NAN, INF)) == INF
    assert abs(complex(-INF, NAN)) == INF
    assert math.isnan(abs(complex(-2.3, NAN)))
    assert math.isnan(abs(complex(-0.0, NAN)))
    assert math.isnan(abs(complex(0.0, NAN)))
    assert math.isnan(abs(complex(2.3, NAN)))
    assert abs(complex(INF, NAN)) == INF
    assert math.isnan(abs(complex(NAN, NAN)))


</t>
<t tx="ekr.20230509052845.4795">test_abs()


</t>
<t tx="ekr.20230509052845.4796">def c_equal(a, b):
    eps = 1e-7
    if abs(a.real - b[0]) &gt; eps or abs(a.imag - b[1]) &gt; eps:
        return False
    return True


</t>
<t tx="ekr.20230509052845.4797">@test
def test_rect():
    from cmath import rect, pi

    assert c_equal(rect(0, 0), (0, 0))
    assert c_equal(rect(1, 0), (1.0, 0))
    assert c_equal(rect(1, -pi), (-1.0, 0))
    assert c_equal(rect(1, pi / 2), (0, 1.0))
    assert c_equal(rect(1, -pi / 2), (0, -1.0))


</t>
<t tx="ekr.20230509052845.4798">test_rect()


</t>
<t tx="ekr.20230509052845.4799">@test
def test_isfinite():
    real_vals = [float("-inf"), -2.3, -0.0, 0.0, 2.3, float("inf"), float("nan")]
    for x in real_vals:
        for y in real_vals:
            z = complex(x, y)
            assert cmath.isfinite(z) == (math.isfinite(x) and math.isfinite(y))


</t>
<t tx="ekr.20230509052845.48">def __add__(self, other):
    if not isinstance(other, GVector):
        raise ValueError("Can't add GVector to " + str(type(other)))
    v = GVector(self.x + other.x, self.y + other.y, self.z + other.z)
    return v

</t>
<t tx="ekr.20230509052845.480">/// Base for simple derived types.
class DerivedType : public AcceptorExtend&lt;DerivedType, Type&gt; {
private:
  /// the base type
  Type *base;

public:
  static const char NodeId;

  /// Constructs a derived type.
  /// @param name the type's name
  /// @param base the type's base
  explicit DerivedType(std::string name, Type *base)
      : AcceptorExtend(std::move(name)), base(base) {}

  /// @return the type's base
  Type *getBase() const { return base; }

private:
  bool doIsAtomic() const override { return base-&gt;isAtomic(); }

  std::vector&lt;Type *&gt; doGetUsedTypes() const override { return {base}; }
};

</t>
<t tx="ekr.20230509052845.4800">test_isfinite()


</t>
<t tx="ekr.20230509052845.4801">@test
def test_isnan():
    assert not cmath.isnan(1)
    assert not cmath.isnan(1j)
    assert not cmath.isnan(INF)
    assert cmath.isnan(NAN)
    assert cmath.isnan(complex(NAN, 0))
    assert cmath.isnan(complex(0, NAN))
    assert cmath.isnan(complex(NAN, NAN))
    assert cmath.isnan(complex(NAN, INF))
    assert cmath.isnan(complex(INF, NAN))


</t>
<t tx="ekr.20230509052845.4802">test_isnan()


</t>
<t tx="ekr.20230509052845.4803">@test
def test_isinf():
    assert not cmath.isinf(1)
    assert not cmath.isinf(1j)
    assert not cmath.isinf(NAN)
    assert cmath.isinf(INF)
    assert cmath.isinf(complex(INF, 0))
    assert cmath.isinf(complex(0, INF))
    assert cmath.isinf(complex(INF, INF))
    assert cmath.isinf(complex(NAN, INF))
    assert cmath.isinf(complex(INF, NAN))


</t>
<t tx="ekr.20230509052845.4804">test_isinf()


</t>
<t tx="ekr.20230509052845.4805">@test
def test_tanh_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.tanh(z), z)


</t>
<t tx="ekr.20230509052845.4806">test_tanh_sign()


</t>
<t tx="ekr.20230509052845.4807">@test
def test_atan_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.atan(z), z)


</t>
<t tx="ekr.20230509052845.4808">test_atan_sign()


</t>
<t tx="ekr.20230509052845.4809">@test
def test_atanh_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.atanh(z), z)


</t>
<t tx="ekr.20230509052845.481">/// Type of a pointer to another CIR type
class PointerType : public AcceptorExtend&lt;PointerType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs a pointer type.
  /// @param base the type's base
  explicit PointerType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509052845.4810">test_atanh_sign()


</t>
<t tx="ekr.20230509052845.4811">@test
def test_is_close():
    # test complex values that are close to within 12 decimal places
    complex_examples = [
        (1.0 + 1.0j, 1.000000000001 + 1.0j),
        (1.0 + 1.0j, 1.0 + 1.000000000001j),
        (-1.0 + 1.0j, -1.000000000001 + 1.0j),
        (1.0 - 1.0j, 1.0 - 0.999999999999j),
    ]

    for a, b in complex_examples:
        assert cmath.isclose(a, b, rel_tol=1e-12)
        assert not cmath.isclose(a, b, rel_tol=1e-13)

    # test values near zero that are near to within three decimal places
    near_zero_examples = [
        (0.001j, 0),
        (0.001 + 0j, 0),
        (0.001 + 0.001j, 0),
        (-0.001 + 0.001j, 0),
        (0.001 - 0.001j, 0),
        (-0.001 - 0.001j, 0),
    ]

    for a, b in near_zero_examples:
        assert cmath.isclose(a, b, abs_tol=1.5e-03)
        assert not cmath.isclose(a, b, abs_tol=0.5e-03)

    assert cmath.isclose(0.001 - 0.001j, 0.001 + 0.001j, abs_tol=2e-03)
    assert not cmath.isclose(0.001 - 0.001j, 0.001 + 0.001j, abs_tol=1e-03)


</t>
<t tx="ekr.20230509052845.4812">test_is_close()


</t>
<t tx="ekr.20230509052845.4813">@test
def test_cmath_testcases():
    @others
    tests = []
    with open("test/stdlib/cmath_testcases.txt") as f:
        for line in f:
            line = line.strip()
            if not line.startswith("--"):
                tests.append(line)

    for test in tests:
        assert run_test(test)


</t>
<t tx="ekr.20230509052845.4814">def check(exp, got, flags):
    def close(a, b):
        if math.isnan(a):
            return math.isnan(b)
        elif math.isnan(b):
            return math.isnan(a)
        return math.isclose(a, b, rel_tol=1e-10, abs_tol=1e-15)

    x1 = exp.real
    y1 = exp.imag

    x2 = got.real
    y2 = got.imag

    if "ignore-real-sign" in flags:
        x1 = math.fabs(x1)
        x2 = math.fabs(x2)

    if "ignore-imag-sign" in flags:
        y1 = math.fabs(y1)
        y2 = math.fabs(y2)

    return close(x1, x2) and close(y1, y2)

</t>
<t tx="ekr.20230509052845.4815">def run_test(test):
    v = test.split()
    if not v:
        return True
    name = v[0]
    func = v[1]
    inp = complex(float(v[2]), float(v[3]))
    exp = complex(float(v[5]), float(v[6]))
    flags = v[7:]

    got = complex()
    if func == "rect":
        got = cmath.rect(inp.real, inp.imag)
    elif func == "polar":
        got = complex(*cmath.polar(inp))
    elif func == "exp":
        got = cmath.exp(inp)
    elif func == "log":
        got = cmath.log(inp)
    elif func == "log10":
        got = cmath.log10(inp)
    elif func == "sqrt":
        got = cmath.sqrt(inp)
    elif func == "acos":
        got = cmath.acos(inp)
    elif func == "asin":
        got = cmath.asin(inp)
    elif func == "atan":
        got = cmath.atan(inp)
    elif func == "cos":
        got = cmath.cos(inp)
    elif func == "sin":
        got = cmath.sin(inp)
    elif func == "tan":
        got = cmath.tan(inp)
    elif func == "acosh":
        got = cmath.acosh(inp)
    elif func == "asinh":
        got = cmath.asinh(inp)
    elif func == "atanh":
        got = cmath.atanh(inp)
    elif func == "cosh":
        got = cmath.cosh(inp)
    elif func == "sinh":
        got = cmath.sinh(inp)
    elif func == "tanh":
        got = cmath.tanh(inp)
    else:
        assert False, f"ERROR: unknown function: {func}"

    if not check(exp, got, flags):
        print(f"{name} {func} {inp=} {got=} {exp=} {flags=}")
        return False
    return True

</t>
<t tx="ekr.20230509052845.4816">test_cmath_testcases()


</t>
<t tx="ekr.20230509052845.4817">@test
def test_complex64():
    c64 = complex64
    z = c64(.5 + .5j)
    assert c64() == z * 0
    assert z + 1 == c64(1.5, .5)
    assert bool(z) == True
    assert bool(0 * z) == False
    assert +z == z
    assert -z == c64(-.5 - .5j)
    assert abs(z) == float32(0.7071067811865476)
    assert z + 1 == c64(1.5 + .5j)
    assert 1j + z == c64(.5 + 1.5j)
    assert z * 2 == c64(1 + 1j)
    assert 2j * z == c64(-1 + 1j)
    assert z / .5 == c64(1 + 1j)
    assert 1j / z == c64(1 + 1j)
    assert z ** 2 == c64(.5j)
    y = 1j ** z
    assert math.isclose(float(y.real), 0.32239694194483454)
    assert math.isclose(float(y.imag), 0.32239694194483454)
    assert z != -z
    assert z != 0
    assert z.real == float32(.5)
    assert (z + 1j).imag == float32(1.5)
    assert z.conjugate() == c64(.5 - .5j)
    assert z.__copy__() == z
    assert hash(z)
    assert c64(complex(z)) == z

</t>
<t tx="ekr.20230509052845.4818">@path C:/Repos/codon/test/stdlib/
from datetime import *
from unittest import TestCase
from operator import lt, le, gt, ge, eq, ne, truediv, floordiv, mod


@others
test_constants()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4819">class TestTimeDelta(Static[TestCase]):
    @others
</t>
<t tx="ekr.20230509052845.482">/// Type of an optional containing another CIR type
class OptionalType : public AcceptorExtend&lt;OptionalType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs an optional type.
  /// @param base the type's base
  explicit OptionalType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return getBase()-&gt;isAtomic(); }
};

</t>
<t tx="ekr.20230509052845.4820">def test_constructor(self):
    eq = self.assertEqual
    td = timedelta

    # Check keyword args to constructor
    eq(
        td(),
        td(
            weeks=0,
            days=0,
            hours=0,
            minutes=0,
            seconds=0,
            milliseconds=0,
            microseconds=0,
        ),
    )
    eq(td(1), td(days=1))
    eq(td(0, 1), td(seconds=1))
    eq(td(0, 0, 1), td(microseconds=1))
    eq(td(weeks=1), td(days=7))
    eq(td(days=1), td(hours=24))
    eq(td(hours=1), td(minutes=60))
    eq(td(minutes=1), td(seconds=60))
    eq(td(seconds=1), td(milliseconds=1000))
    eq(td(milliseconds=1), td(microseconds=1000))

    # Check float args to constructor
    eq(td(weeks=1.0 / 7), td(days=1))
    eq(td(days=1.0 / 24), td(hours=1))
    eq(td(hours=1.0 / 60), td(minutes=1))
    eq(td(minutes=1.0 / 60), td(seconds=1))
    eq(td(seconds=0.001), td(milliseconds=1))
    eq(td(milliseconds=0.001), td(microseconds=1))

</t>
<t tx="ekr.20230509052845.4821">def test_computations(self):
    eq = self.assertEqual
    td = timedelta

    a = td(7)  # One week
    b = td(0, 60)  # One minute
    c = td(0, 0, 1000)  # One millisecond
    eq(a + b + c, td(7, 60, 1000))
    eq(a - b, td(6, 24 * 3600 - 60))
    # eq(b.__rsub__(a), td(6, 24*3600 - 60))
    eq(-a, td(-7))
    eq(+a, td(7))
    eq(-b, td(-1, 24 * 3600 - 60))
    eq(-c, td(-1, 24 * 3600 - 1, 999000))
    eq(abs(a), a)
    eq(abs(-a), a)
    eq(td(6, 24 * 3600), a)
    eq(td(0, 0, 60 * 1000000), b)
    eq(a * 10, td(70))
    eq(a * 10, 10 * a)
    eq(a * 10, 10 * a)
    eq(b * 10, td(0, 600))
    eq(10 * b, td(0, 600))
    eq(b * 10, td(0, 600))
    eq(c * 10, td(0, 0, 10000))
    eq(10 * c, td(0, 0, 10000))
    eq(c * 10, td(0, 0, 10000))
    eq(a * -1, -a)
    eq(b * -2, -b - b)
    eq(c * -2, -c + -c)
    eq(b * (60 * 24), (b * 60) * 24)
    eq(b * (60 * 24), (60 * b) * 24)
    eq(c * 1000, td(0, 1))
    eq(1000 * c, td(0, 1))
    eq(a // 7, td(1))
    eq(b // 10, td(0, 6))
    eq(c // 1000, td(0, 0, 1))
    eq(a // 10, td(0, 7 * 24 * 360))
    eq(a // 3600000, td(0, 0, 7 * 24 * 1000))
    eq(a / 0.5, td(14))
    eq(b / 0.5, td(0, 120))
    eq(a / 7, td(1))
    eq(b / 10, td(0, 6))
    eq(c / 1000, td(0, 0, 1))
    eq(a / 10, td(0, 7 * 24 * 360))
    eq(a / 3600000, td(0, 0, 7 * 24 * 1000))

    # Multiplication by float
    us = td(microseconds=1)
    eq((3 * us) * 0.5, 2 * us)
    eq((5 * us) * 0.5, 2 * us)
    eq(0.5 * (3 * us), 2 * us)
    eq(0.5 * (5 * us), 2 * us)
    eq((-3 * us) * 0.5, -2 * us)
    eq((-5 * us) * 0.5, -2 * us)

    # TODO: check Python's Issue #23521 and possibly
    # incorporate the same fix here. For now a couple
    # tests are disabled.

    # Issue #23521
    eq(td(seconds=1) * 0.123456, td(microseconds=123456))
    # eq(td(seconds=1) * 0.6112295, td(microseconds=611229))

    # Division by int and float
    eq((3 * us) / 2, 2 * us)
    eq((5 * us) / 2, 2 * us)
    eq((-3 * us) / 2.0, -2 * us)
    eq((-5 * us) / 2.0, -2 * us)
    eq((3 * us) / -2, -2 * us)
    eq((5 * us) / -2, -2 * us)
    eq((3 * us) / -2.0, -2 * us)
    eq((5 * us) / -2.0, -2 * us)
    for i in range(-10, 10):
        eq((i * us / 3) // us, round(i / 3))
    for i in range(-10, 10):
        eq((i * us / -3) // us, round(i / -3))

    # Issue #23521
    # eq(td(seconds=1) / (1 / 0.6112295), td(microseconds=611229))

    # Issue #11576
    eq(td(999999999, 86399, 999999) - td(999999999, 86399, 999998), td(0, 0, 1))
    eq(td(999999999, 1, 1) - td(999999999, 1, 0), td(0, 0, 1))

</t>
<t tx="ekr.20230509052845.4822">"""
def test_disallowed_special(self):
    a = timedelta(42)
    NAN = 0. / 0.
    self.assertRaises(ValueError, a.__mul__, NAN)
    self.assertRaises(ValueError, a.__truediv__, NAN)
"""

</t>
<t tx="ekr.20230509052845.4823">def test_basic_attributes(self):
    days, seconds, us = 1, 7, 31
    td = timedelta(days, seconds, us)
    self.assertEqual(td.days, days)
    self.assertEqual(td.seconds, seconds)
    self.assertEqual(td.microseconds, us)

</t>
<t tx="ekr.20230509052845.4824">def test_total_seconds(self):
    td = timedelta(days=365)
    self.assertEqual(td.total_seconds(), 31536000.0)
    for total_seconds in [123456.789012, -123456.789012, 0.123456, 0, 1e6]:
        td = timedelta(seconds=total_seconds)
        self.assertEqual(td.total_seconds(), total_seconds)
    # Issue8644: Test that td.total_seconds() has the same
    # accuracy as td / timedelta(seconds=1).
    for ms in [-1, -2, -123]:
        td = timedelta(microseconds=ms)
        self.assertEqual(td.total_seconds(), td / timedelta(seconds=1))

</t>
<t tx="ekr.20230509052845.4825">def test_carries(self):
    t1 = timedelta(
        days=100,
        weeks=-7,
        hours=-24 * (100 - 49),
        minutes=-3,
        seconds=12,
        microseconds=(3 * 60 - 12) * 1e6 + 1,
    )
    t2 = timedelta(microseconds=1)
    self.assertEqual(t1, t2)

</t>
<t tx="ekr.20230509052845.4826">def test_hash_equality(self):
    t1 = timedelta(
        days=100,
        weeks=-7,
        hours=-24 * (100 - 49),
        minutes=-3,
        seconds=12,
        microseconds=(3 * 60 - 12) * 1000000,
    )
    t2 = timedelta()
    self.assertEqual(hash(t1), hash(t2))

    t1 += timedelta(weeks=7)
    t2 += timedelta(days=7 * 7)
    self.assertEqual(t1, t2)
    self.assertEqual(hash(t1), hash(t2))

    d = {t1: 1}
    d[t2] = 2
    self.assertEqual(len(d), 1)
    self.assertEqual(d[t1], 2)

</t>
<t tx="ekr.20230509052845.4827">def test_compare(self):
    t1 = timedelta(2, 3, 4)
    t2 = timedelta(2, 3, 4)
    self.assertEqual(t1, t2)
    self.assertTrue(t1 &lt;= t2)
    self.assertTrue(t1 &gt;= t2)
    self.assertFalse(t1 != t2)
    self.assertFalse(t1 &lt; t2)
    self.assertFalse(t1 &gt; t2)

    for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
        t2 = timedelta(*args)  # this is larger than t1
        self.assertTrue(t1 &lt; t2)
        self.assertTrue(t2 &gt; t1)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t2 &gt;= t1)
        self.assertTrue(t1 != t2)
        self.assertTrue(t2 != t1)
        self.assertFalse(t1 == t2)
        self.assertFalse(t2 == t1)
        self.assertFalse(t1 &gt; t2)
        self.assertFalse(t2 &lt; t1)
        self.assertFalse(t1 &gt;= t2)
        self.assertFalse(t2 &lt;= t1)

</t>
<t tx="ekr.20230509052845.4828">def test_str(self):
    td = timedelta
    eq = self.assertEqual

    eq(str(td(1)), "1 day, 0:00:00")
    eq(str(td(-1)), "-1 day, 0:00:00")
    eq(str(td(2)), "2 days, 0:00:00")
    eq(str(td(-2)), "-2 days, 0:00:00")

    eq(str(td(hours=12, minutes=58, seconds=59)), "12:58:59")
    eq(str(td(hours=2, minutes=3, seconds=4)), "2:03:04")
    eq(str(td(weeks=-30, hours=23, minutes=12, seconds=34)), "-210 days, 23:12:34")

    eq(str(td(milliseconds=1)), "0:00:00.001000")
    eq(str(td(microseconds=3)), "0:00:00.000003")

    # Codon's timedelta has a smaller range than Python's
    # since it uses a pure microseconds representation, so
    # below case is not supported.
    """
    eq(str(td(days=999999999, hours=23, minutes=59, seconds=59,
               microseconds=999999)),
       "999999999 days, 23:59:59.999999")
    """

</t>
<t tx="ekr.20230509052845.4829">def test_repr(self):
    td = timedelta
    self.assertEqual(repr(td(1)), "timedelta(days=1)")
    self.assertEqual(repr(td(10, 2)), "timedelta(days=10, seconds=2)")
    self.assertEqual(
        repr(td(-10, 2, 400000)),
        "timedelta(days=-10, seconds=2, microseconds=400000)",
    )
    self.assertEqual(repr(td(seconds=60)), "timedelta(seconds=60)")
    self.assertEqual(repr(td()), "timedelta(0)")
    self.assertEqual(repr(td(microseconds=100)), "timedelta(microseconds=100)")
    self.assertEqual(
        repr(td(days=1, microseconds=100)), "timedelta(days=1, microseconds=100)"
    )
    self.assertEqual(
        repr(td(seconds=1, microseconds=100)),
        "timedelta(seconds=1, microseconds=100)",
    )

</t>
<t tx="ekr.20230509052845.483">/// Type of a generator yielding another CIR type
class GeneratorType : public AcceptorExtend&lt;GeneratorType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs a generator type.
  /// @param base the type's base
  explicit GeneratorType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509052845.4830">def test_resolution_info(self):
    self.assertTrue(timedelta.max &gt; timedelta.min)
    #self.assertEqual(timedelta.min, timedelta(-999999999))
    #self.assertEqual(timedelta.max, timedelta(999999999, 24*3600-1, 1e6-1))
    self.assertEqual(timedelta.resolution, timedelta(0, 0, 1))

</t>
<t tx="ekr.20230509052845.4831">"""
def test_overflow(self):
    tiny = timedelta(microseconds=1)  # timedelta.resolution

    td = timedelta.min + tiny
    td -= tiny  # no problem
    self.assertRaises(OverflowError, td.__sub__, tiny)
    self.assertRaises(OverflowError, td.__add__, -tiny)

    td = timedelta.max - tiny
    td += tiny  # no problem
    self.assertRaises(OverflowError, td.__add__, tiny)
    self.assertRaises(OverflowError, td.__sub__, -tiny)

    self.assertRaises(OverflowError, lambda: -timedelta.max)

    day = timedelta(1)
    self.assertRaises(OverflowError, day.__mul__, 10**9)
    self.assertRaises(OverflowError, day.__mul__, 1e9)
    self.assertRaises(OverflowError, day.__truediv__, 1e-20)
    self.assertRaises(OverflowError, day.__truediv__, 1e-10)
    self.assertRaises(OverflowError, day.__truediv__, 9e-10)

def _test_overflow_special(self):
    day = timedelta(1)
    INF = 1. / 0.
    self.assertRaises(OverflowError, day.__mul__, INF)
    self.assertRaises(OverflowError, day.__mul__, -INF)
"""

</t>
<t tx="ekr.20230509052845.4832">def test_microsecond_rounding(self):
    td = timedelta
    eq = self.assertEqual

    # Single-field rounding.
    eq(td(milliseconds=0.4 / 1000), td(0))  # rounds to 0
    eq(td(milliseconds=-0.4 / 1000), td(0))  # rounds to 0
    eq(td(milliseconds=0.5 / 1000), td(microseconds=0))
    eq(td(milliseconds=-0.5 / 1000), td(microseconds=-0))
    eq(td(milliseconds=0.6 / 1000), td(microseconds=1))
    eq(td(milliseconds=-0.6 / 1000), td(microseconds=-1))
    eq(td(milliseconds=1.5 / 1000), td(microseconds=2))
    eq(td(milliseconds=-1.5 / 1000), td(microseconds=-2))
    eq(td(seconds=0.5 / 10 ** 6), td(microseconds=0))
    eq(td(seconds=-0.5 / 10 ** 6), td(microseconds=-0))
    eq(td(seconds=1 / 2 ** 7), td(microseconds=7812))
    eq(td(seconds=-1 / 2 ** 7), td(microseconds=-7812))

    # Rounding due to contributions from more than one field.
    us_per_hour = 3600e6
    us_per_day = us_per_hour * 24
    eq(td(days=0.4 / us_per_day), td(0))
    eq(td(hours=0.2 / us_per_hour), td(0))
    eq(td(days=0.4 / us_per_day, hours=0.2 / us_per_hour), td(microseconds=1))

    eq(td(days=-0.4 / us_per_day), td(0))
    eq(td(hours=-0.2 / us_per_hour), td(0))
    eq(td(days=-0.4 / us_per_day, hours=-0.2 / us_per_hour), td(microseconds=-1))

    # Test for a patch in Issue 8860
    eq(td(microseconds=0.5), 0.5 * td(microseconds=1.0))
    resolution = td(microseconds=1)  # td.resolution
    eq(td(microseconds=0.5) // resolution, 0.5 * resolution // resolution)

</t>
<t tx="ekr.20230509052845.4833">def test_massive_normalization(self):
    td = timedelta(microseconds=-1)
    self.assertEqual(
        (td.days, td.seconds, td.microseconds), (-1, 24 * 3600 - 1, 999999)
    )

</t>
<t tx="ekr.20230509052845.4834">def test_bool(self):
    self.assertTrue(timedelta(1))
    self.assertTrue(timedelta(0, 1))
    self.assertTrue(timedelta(0, 0, 1))
    self.assertTrue(timedelta(microseconds=1))
    self.assertFalse(timedelta(0))

</t>
<t tx="ekr.20230509052845.4835">def test_division(self):
    t = timedelta(hours=1, minutes=24, seconds=19)
    second = timedelta(seconds=1)
    self.assertEqual(t / second, 5059.0)
    self.assertEqual(t // second, 5059)

    t = timedelta(minutes=2, seconds=30)
    minute = timedelta(minutes=1)
    self.assertEqual(t / minute, 2.5)
    self.assertEqual(t // minute, 2)

    zerotd = timedelta(0)
    # self.assertRaises(ZeroDivisionError, truediv, t, zerotd)
    # self.assertRaises(ZeroDivisionError, floordiv, t, zerotd)

</t>
<t tx="ekr.20230509052845.4836">def test_remainder(self):
    t = timedelta(minutes=2, seconds=30)
    minute = timedelta(minutes=1)
    r = t % minute
    self.assertEqual(r, timedelta(seconds=30))

    t = timedelta(minutes=-2, seconds=30)
    r = t % minute
    self.assertEqual(r, timedelta(seconds=30))

    zerotd = timedelta(0)
    # self.assertRaises(ZeroDivisionError, mod, t, zerotd)

</t>
<t tx="ekr.20230509052845.4837">def test_divmod(self):
    t = timedelta(minutes=2, seconds=30)
    minute = timedelta(minutes=1)
    q, r = divmod(t, minute)
    self.assertEqual(q, 2)
    self.assertEqual(r, timedelta(seconds=30))

    t = timedelta(minutes=-2, seconds=30)
    q, r = divmod(t, minute)
    self.assertEqual(q, -2)
    self.assertEqual(r, timedelta(seconds=30))

    zerotd = timedelta(0)
    # self.assertRaises(ZeroDivisionError, divmod, t, zerotd)


</t>
<t tx="ekr.20230509052845.4838">class TestDateOnly(Static[TestCase]):
    @others
</t>
<t tx="ekr.20230509052845.4839">def test_delta_non_days_ignored(self):
    dt = date(2000, 1, 2)
    delta = timedelta(days=1, hours=2, minutes=3, seconds=4, microseconds=5)
    days = timedelta(delta.days)
    self.assertEqual(days, timedelta(1))

    dt2 = dt + delta
    self.assertEqual(dt2, dt + days)

    dt2 = delta + dt
    self.assertEqual(dt2, dt + days)

    dt2 = dt - delta
    self.assertEqual(dt2, dt - days)

    delta = -delta
    days = timedelta(delta.days)
    self.assertEqual(days, timedelta(-2))

    dt2 = dt + delta
    self.assertEqual(dt2, dt + days)

    dt2 = delta + dt
    self.assertEqual(dt2, dt + days)

    dt2 = dt - delta
    self.assertEqual(dt2, dt - days)


</t>
<t tx="ekr.20230509052845.484">/// Type of a variably sized integer
class IntNType : public AcceptorExtend&lt;IntNType, PrimitiveType&gt; {
private:
  /// length of the integer
  unsigned len;
  /// whether the variable is signed
  bool sign;

public:
  static const char NodeId;

  static const unsigned MAX_LEN = 2048;

  /// Constructs a variably sized integer type.
  /// @param len the length of the integer
  /// @param sign true if signed, false otherwise
  IntNType(unsigned len, bool sign)
      : AcceptorExtend(getInstanceName(len, sign)), len(len), sign(sign) {}

  /// @return the length of the integer
  unsigned getLen() const { return len; }
  /// @return true if signed
  bool isSigned() const { return sign; }

  /// @return the name of the opposite signed corresponding type
  std::string oppositeSignName() const { return getInstanceName(len, !sign); }

  static std::string getInstanceName(unsigned len, bool sign);
};

</t>
<t tx="ekr.20230509052845.4840">class TestDate(Static[TestCase]):
    theclass: type

    @others
</t>
<t tx="ekr.20230509052845.4841">def test_basic_attributes(self):
    dt = self.theclass(2002, 3, 1)
    self.assertEqual(dt.year, 2002)
    self.assertEqual(dt.month, 3)
    self.assertEqual(dt.day, 1)

</t>
<t tx="ekr.20230509052845.4842">def test_ordinal_conversions(self):
    # Check some fixed values.
    for y, m, d, n in [
        (1, 1, 1, 1),  # calendar origin
        (1, 12, 31, 365),
        (2, 1, 1, 366),
        # first example from "Calendrical Calculations"
        (1945, 11, 12, 710347),
    ]:
        dt = self.theclass(y, m, d)
        self.assertEqual(n, dt.toordinal())
        fromord = self.theclass.fromordinal(n)
        self.assertEqual(dt, fromord)
        if hasattr(fromord, "hour"):
            # if we're checking something fancier than a date, verify
            # the extra fields have been zeroed out
            self.assertEqual(fromord.hour, 0)
            self.assertEqual(fromord.minute, 0)
            self.assertEqual(fromord.second, 0)
            self.assertEqual(fromord.microsecond, 0)

    # Check first and last days of year spottily across the whole
    # range of years supported.
    for year in range(MINYEAR, MAXYEAR + 1, 7):
        # Verify (year, 1, 1) -&gt; ordinal -&gt; y, m, d is identity.
        d = self.theclass(year, 1, 1)
        n = d.toordinal()
        d2 = self.theclass.fromordinal(n)
        self.assertEqual(d, d2)
        # Verify that moving back a day gets to the end of year-1.
        if year &gt; 1:
            d = self.theclass.fromordinal(n - 1)
            d2 = self.theclass(year - 1, 12, 31)
            self.assertEqual(d, d2)
            self.assertEqual(d2.toordinal(), n - 1)

    # Test every day in a leap-year and a non-leap year.
    dim = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    for year, isleap in (2000, True), (2002, False):
        n = self.theclass(year, 1, 1).toordinal()
        for month, maxday in zip(range(1, 13), dim):
            if month == 2 and isleap:
                maxday += 1
            for day in range(1, maxday + 1):
                d = self.theclass(year, month, day)
                self.assertEqual(d.toordinal(), n)
                self.assertEqual(d, self.theclass.fromordinal(n))
                n += 1

</t>
<t tx="ekr.20230509052845.4843">"""
def test_extreme_ordinals(self):
    a = self.theclass.min
    a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
    aord = a.toordinal()
    b = a.fromordinal(aord)
    self.assertEqual(a, b)

    self.assertRaises(ValueError, lambda: a.fromordinal(aord - 1))

    b = a + timedelta(days=1)
    self.assertEqual(b.toordinal(), aord + 1)
    self.assertEqual(b, self.theclass.fromordinal(aord + 1))

    a = self.theclass.max
    a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
    aord = a.toordinal()
    b = a.fromordinal(aord)
    self.assertEqual(a, b)

    self.assertRaises(ValueError, lambda: a.fromordinal(aord + 1))

    b = a - timedelta(days=1)
    self.assertEqual(b.toordinal(), aord - 1)
    self.assertEqual(b, self.theclass.fromordinal(aord - 1))
"""

</t>
<t tx="ekr.20230509052845.4844">def test_bad_constructor_arguments(self):
    # bad years
    self.theclass(MINYEAR, 1, 1)  # no exception
    self.theclass(MAXYEAR, 1, 1)  # no exception

    def make(theclass, a, b, c):
        return self.theclass(a, b, c)

    self.assertRaises(ValueError, make(self.theclass, ...), MINYEAR - 1, 1, 1)
    self.assertRaises(ValueError, make(self.theclass, ...), MAXYEAR + 1, 1, 1)
    # bad months
    self.theclass(2000, 1, 1)  # no exception
    self.theclass(2000, 12, 1)  # no exception
    self.assertRaises(ValueError, make(self.theclass, ...), 2000, 0, 1)
    self.assertRaises(ValueError, make(self.theclass, ...), 2000, 13, 1)
    # bad days
    self.theclass(2000, 2, 29)  # no exception
    self.theclass(2004, 2, 29)  # no exception
    self.theclass(2400, 2, 29)  # no exception
    self.assertRaises(ValueError, make(self.theclass, ...), 2000, 2, 30)
    self.assertRaises(ValueError, make(self.theclass, ...), 2001, 2, 29)
    self.assertRaises(ValueError, make(self.theclass, ...), 2100, 2, 29)
    self.assertRaises(ValueError, make(self.theclass, ...), 1900, 2, 29)
    self.assertRaises(ValueError, make(self.theclass, ...), 2000, 1, 0)
    self.assertRaises(ValueError, make(self.theclass, ...), 2000, 1, 32)

</t>
<t tx="ekr.20230509052845.4845">def test_hash_equality(self):
    d = self.theclass(2000, 12, 31)
    # same thing
    e = self.theclass(2000, 12, 31)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

    d = self.theclass(2001, 1, 1)
    # same thing
    e = self.theclass(2001, 1, 1)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

</t>
<t tx="ekr.20230509052845.4846">def test_computations(self):
    a = self.theclass(2002, 1, 31)
    b = self.theclass(1956, 1, 31)
    c = self.theclass(2001, 2, 1)

    diff = a - b
    self.assertEqual(diff.days, 46 * 365 + len(range(1956, 2002, 4)))
    self.assertEqual(diff.seconds, 0)
    self.assertEqual(diff.microseconds, 0)

    day = timedelta(1)
    week = timedelta(7)
    a = self.theclass(2002, 3, 2)
    self.assertEqual(a + day, self.theclass(2002, 3, 3))
    self.assertEqual(day + a, self.theclass(2002, 3, 3))
    self.assertEqual(a - day, self.theclass(2002, 3, 1))
    self.assertEqual(-day + a, self.theclass(2002, 3, 1))
    self.assertEqual(a + week, self.theclass(2002, 3, 9))
    self.assertEqual(a - week, self.theclass(2002, 2, 23))
    self.assertEqual(a + 52 * week, self.theclass(2003, 3, 1))
    self.assertEqual(a - 52 * week, self.theclass(2001, 3, 3))
    self.assertEqual((a + week) - a, week)
    self.assertEqual((a + day) - a, day)
    self.assertEqual((a - week) - a, -week)
    self.assertEqual((a - day) - a, -day)
    self.assertEqual(a - (a + week), -week)
    self.assertEqual(a - (a + day), -day)
    self.assertEqual(a - (a - week), week)
    self.assertEqual(a - (a - day), day)
    self.assertEqual(c - (c - day), day)

    """
    # Add/sub ints or floats should be illegal
    for i in 1, 1.0:
        self.assertRaises(TypeError, lambda: a+i)
        self.assertRaises(TypeError, lambda: a-i)
        self.assertRaises(TypeError, lambda: i+a)
        self.assertRaises(TypeError, lambda: i-a)

    # delta - date is senseless.
    self.assertRaises(TypeError, lambda: day - a)
    # mixing date and (delta or date) via * or // is senseless
    self.assertRaises(TypeError, lambda: day * a)
    self.assertRaises(TypeError, lambda: a * day)
    self.assertRaises(TypeError, lambda: day // a)
    self.assertRaises(TypeError, lambda: a // day)
    self.assertRaises(TypeError, lambda: a * a)
    self.assertRaises(TypeError, lambda: a // a)
    # date + date is senseless
    self.assertRaises(TypeError, lambda: a + a)
    """

</t>
<t tx="ekr.20230509052845.4847">"""
def test_overflow(self):
    tiny = self.theclass.resolution

    for delta in [tiny, timedelta(1), timedelta(2)]:
        dt = self.theclass.min + delta
        dt -= delta  # no problem
        self.assertRaises(OverflowError, dt.__sub__, delta)
        self.assertRaises(OverflowError, dt.__add__, -delta)

        dt = self.theclass.max - delta
        dt += delta  # no problem
        self.assertRaises(OverflowError, dt.__add__, delta)
        self.assertRaises(OverflowError, dt.__sub__, -delta)
"""

</t>
<t tx="ekr.20230509052845.4848">def test_fromtimestamp(self):
    import time

    # Try an arbitrary fixed value.
    year, month, day = 1999, 9, 19
    ts = time.mktime((year, month, day, 0, 0, 0, 0, 0, -1))
    d = self.theclass.fromtimestamp(ts)
    self.assertEqual(d.year, year)
    self.assertEqual(d.month, month)
    self.assertEqual(d.day, day)

</t>
<t tx="ekr.20230509052845.4849">def test_today(self):
    import time

    # We claim that today() is like fromtimestamp(time.time()), so
    # prove it.
    today = self.theclass.today()
    todayagain = today

    for dummy in range(3):
        today = self.theclass.today()
        ts = time.time()
        todayagain = self.theclass.fromtimestamp(ts)
        if today == todayagain:
            break
        # There are several legit reasons that could fail:
        # 1. It recently became midnight, between the today() and the
        #    time() calls.
        # 2. The platform time() has such fine resolution that we'll
        #    never get the same value twice.
        # 3. The platform time() has poor resolution, and we just
        #    happened to call today() right before a resolution quantum
        #    boundary.
        # 4. The system clock got fiddled between calls.
        # In any case, wait a little while and try again.
        time.sleep(0.1)

    # It worked or it didn't.  If it didn't, assume it's reason #2, and
    # let the test pass if they're within half a second of each other.
    if today != todayagain:
        self.assertAlmostEqual(todayagain, today, delta=timedelta(seconds=0.5))

</t>
<t tx="ekr.20230509052845.485">/// Type of a vector of primitives
class VectorType : public AcceptorExtend&lt;VectorType, PrimitiveType&gt; {
private:
  /// number of elements
  unsigned count;
  /// base type
  PrimitiveType *base;

public:
  static const char NodeId;

  /// Constructs a vector type.
  /// @param count the number of elements
  /// @param base the base type
  VectorType(unsigned count, PrimitiveType *base)
      : AcceptorExtend(getInstanceName(count, base)), count(count), base(base) {}

  /// @return the count of the vector
  unsigned getCount() const { return count; }
  /// @return the base type of the vector
  PrimitiveType *getBase() const { return base; }

  static std::string getInstanceName(unsigned count, PrimitiveType *base);
};

</t>
<t tx="ekr.20230509052845.4850">def test_weekday(self):
    for i in range(7):
        # March 4, 2002 is a Monday
        self.assertEqual(self.theclass(2002, 3, 4 + i).weekday(), i)
        self.assertEqual(self.theclass(2002, 3, 4 + i).isoweekday(), i + 1)
        # January 2, 1956 is a Monday
        self.assertEqual(self.theclass(1956, 1, 2 + i).weekday(), i)
        self.assertEqual(self.theclass(1956, 1, 2 + i).isoweekday(), i + 1)

</t>
<t tx="ekr.20230509052845.4851">def test_isocalendar(self):
    # Check examples from
    # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
    week_mondays = [
        ((2003, 12, 22), (2003, 52, 1)),
        ((2003, 12, 29), (2004, 1, 1)),
        ((2004, 1, 5), (2004, 2, 1)),
        ((2009, 12, 21), (2009, 52, 1)),
        ((2009, 12, 28), (2009, 53, 1)),
        ((2010, 1, 4), (2010, 1, 1)),
    ]

    test_cases = []
    for cal_date, iso_date in week_mondays:
        base_date = self.theclass(*cal_date)
        # Adds one test case for every day of the specified weeks
        for i in range(7):
            new_date = base_date + timedelta(i)
            new_iso = iso_date[0:2] + (iso_date[2] + i,)
            test_cases.append((new_date, new_iso))

    for d, exp_iso in test_cases:
        self.assertEqual(d.isocalendar(), exp_iso)

        # Check that the tuple contents are accessible by field name
        t = d.isocalendar()
        self.assertEqual((t.year, t.week, t.weekday), exp_iso)

</t>
<t tx="ekr.20230509052845.4852">def test_iso_long_years(self):
    # Calculate long ISO years and compare to table from
    # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
    ISO_LONG_YEARS_TABLE = """
          4   32   60   88
          9   37   65   93
         15   43   71   99
         20   48   76
         26   54   82
        105  133  161  189
        111  139  167  195
        116  144  172
        122  150  178
        128  156  184
        201  229  257  285
        207  235  263  291
        212  240  268  296
        218  246  274
        224  252  280
        303  331  359  387
        308  336  364  392
        314  342  370  398
        320  348  376
        325  353  381
    """
    iso_long_years = sorted(map(int, ISO_LONG_YEARS_TABLE.split()))
    L = []
    for i in range(400):
        d = self.theclass(2000 + i, 12, 31).isocalendar()
        d1 = self.theclass(1600 + i, 12, 31).isocalendar()
        self.assertEqual((d.week, d.weekday), (d1.week, d1.weekday))
        if d.week == 53:
            L.append(i)
    self.assertEqual(L, iso_long_years)

</t>
<t tx="ekr.20230509052845.4853">def test_isoformat(self):
    t = self.theclass(2, 3, 2)
    self.assertEqual(t.isoformat(), "0002-03-02")

</t>
<t tx="ekr.20230509052845.4854">def test_ctime(self):
    t = self.theclass(2002, 3, 2)
    self.assertEqual(t.ctime(), "Sat Mar  2 00:00:00 2002")

</t>
<t tx="ekr.20230509052845.4855">def test_resolution_info(self):
    self.assertTrue(self.theclass.max &gt; self.theclass.min)

</t>
<t tx="ekr.20230509052845.4856">"""
def test_extreme_timedelta(self):
    big = self.theclass.max - self.theclass.min
    # 3652058 days, 23 hours, 59 minutes, 59 seconds, 999999 microseconds
    n = (big.days*24*3600 + big.seconds)*1000000 + big.microseconds
    # n == 315537897599999999 ~= 2**58.13
    justasbig = timedelta(0, 0, n)
    self.assertEqual(big, justasbig)
    self.assertEqual(self.theclass.min + big, self.theclass.max)
    self.assertEqual(self.theclass.max - big, self.theclass.min)
"""

</t>
<t tx="ekr.20230509052845.4857">def test_timetuple(self):
    from time import struct_time

    for i in range(7):
        # January 2, 1956 is a Monday (0)
        d = self.theclass(1956, 1, 2 + i)
        t = d.timetuple()
        self.assertEqual(t, struct_time(1956, 1, 2 + i, 0, 0, 0, i, 2 + i, -1))
        # February 1, 1956 is a Wednesday (2)
        d = self.theclass(1956, 2, 1 + i)
        t = d.timetuple()
        self.assertEqual(
            t, struct_time(1956, 2, 1 + i, 0, 0, 0, (2 + i) % 7, 32 + i, -1)
        )
        # March 1, 1956 is a Thursday (3), and is the 31+29+1 = 61st day
        # of the year.
        d = self.theclass(1956, 3, 1 + i)
        t = d.timetuple()
        self.assertEqual(
            t, struct_time(1956, 3, 1 + i, 0, 0, 0, (3 + i) % 7, 61 + i, -1)
        )
        self.assertEqual(t.tm_year, 1956)
        self.assertEqual(t.tm_mon, 3)
        self.assertEqual(t.tm_mday, 1 + i)
        self.assertEqual(t.tm_hour, 0)
        self.assertEqual(t.tm_min, 0)
        self.assertEqual(t.tm_sec, 0)
        self.assertEqual(t.tm_wday, (3 + i) % 7)
        self.assertEqual(t.tm_yday, 61 + i)
        self.assertEqual(t.tm_isdst, -1)

</t>
<t tx="ekr.20230509052845.4858">def test_compare(self):
    t1 = self.theclass(2, 3, 4)
    t2 = self.theclass(2, 3, 4)
    self.assertEqual(t1, t2)
    self.assertTrue(t1 &lt;= t2)
    self.assertTrue(t1 &gt;= t2)
    self.assertFalse(t1 != t2)
    self.assertFalse(t1 &lt; t2)
    self.assertFalse(t1 &gt; t2)

    for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
        t2 = self.theclass(*args)  # this is larger than t1
        self.assertTrue(t1 &lt; t2)
        self.assertTrue(t2 &gt; t1)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t2 &gt;= t1)
        self.assertTrue(t1 != t2)
        self.assertTrue(t2 != t1)
        self.assertFalse(t1 == t2)
        self.assertFalse(t2 == t1)
        self.assertFalse(t1 &gt; t2)
        self.assertFalse(t2 &lt; t1)
        self.assertFalse(t1 &gt;= t2)
        self.assertFalse(t2 &lt;= t1)

    """
    for badarg in OTHERSTUFF:
        self.assertEqual(t1 == badarg, False)
        self.assertEqual(t1 != badarg, True)
        self.assertEqual(badarg == t1, False)
        self.assertEqual(badarg != t1, True)

        self.assertRaises(TypeError, lambda: t1 &lt; badarg)
        self.assertRaises(TypeError, lambda: t1 &gt; badarg)
        self.assertRaises(TypeError, lambda: t1 &gt;= badarg)
        self.assertRaises(TypeError, lambda: badarg &lt;= t1)
        self.assertRaises(TypeError, lambda: badarg &lt; t1)
        self.assertRaises(TypeError, lambda: badarg &gt; t1)
        self.assertRaises(TypeError, lambda: badarg &gt;= t1)
    """

</t>
<t tx="ekr.20230509052845.4859">def test_bool(self):
    # All dates are considered true.
    # self.assertTrue(self.theclass.min)
    # self.assertTrue(self.theclass.max)
    self.assertTrue(self.theclass(1, 1, 1))

</t>
<t tx="ekr.20230509052845.486">class UnionType : public AcceptorExtend&lt;UnionType, Type&gt; {
private:
  /// alternative types
  std::vector&lt;types::Type *&gt; types;

public:
  static const char NodeId;

  using const_iterator = std::vector&lt;types::Type *&gt;::const_iterator;
  using const_reference = std::vector&lt;types::Type *&gt;::const_reference;

  /// Constructs a UnionType.
  /// @param types the alternative types (must be sorted by caller)
  explicit UnionType(std::vector&lt;types::Type *&gt; types)
      : AcceptorExtend(), types(std::move(types)) {}

  const_iterator begin() const { return types.begin(); }
  const_iterator end() const { return types.end(); }
  const_reference front() const { return types.front(); }
  const_reference back() const { return types.back(); }

  static std::string getInstanceName(const std::vector&lt;types::Type *&gt; &amp;types);

private:
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return types; }

@others
};

</t>
<t tx="ekr.20230509052845.4860">def test_replace(self):
    cls = self.theclass
    args = (1, 2, 3)
    base = cls(*args)
    self.assertEqual(base, base.replace())
    self.assertEqual(base.replace(year=2), cls(2, 2, 3))
    self.assertEqual(base.replace(month=3), cls(1, 3, 3))
    self.assertEqual(base.replace(day=4), cls(1, 2, 4))

    # Out of bounds.
    base = cls(2000, 2, 29)
    self.assertRaises(ValueError, base.replace, year=2001)

</t>
<t tx="ekr.20230509052845.4861">def test_fromisoformat(self):
    # Test that isoformat() is reversible
    base_dates = [
        (1, 1, 1),
        (1000, 2, 14),
        (1900, 1, 1),
        (2000, 2, 29),
        (2004, 11, 12),
        (2004, 4, 3),
        (2017, 5, 30),
    ]

    for dt_tuple in base_dates:
        dt = self.theclass(*dt_tuple)
        dt_str = dt.isoformat()
        dt_rt = self.theclass.fromisoformat(dt.isoformat())
        self.assertEqual(dt, dt_rt)

</t>
<t tx="ekr.20230509052845.4862">def test_fromisoformat_fails(self):
    # Test that fromisoformat() fails on invalid values
    bad_strs = [
        "",  # Empty string
        "\ud800",  # bpo-34454: Surrogate code point
        "009-03-04",  # Not 10 characters
        "123456789",  # Not a date
        "200a-12-04",  # Invalid character in year
        "2009-1a-04",  # Invalid character in month
        "2009-12-0a",  # Invalid character in day
        "2009-01-32",  # Invalid day
        "2009-02-29",  # Invalid leap day
        "20090228",  # Valid ISO8601 output not from isoformat()
        "2009\ud80002\ud80028",  # Separators are surrogate codepoints
    ]

    for bad_str in bad_strs:
        self.assertRaises(ValueError, self.theclass.fromisoformat, bad_str)

</t>
<t tx="ekr.20230509052845.4863">def test_fromisocalendar(self):
    # For each test case, assert that fromisocalendar is the
    # inverse of the isocalendar function
    dates = [
        (2016, 4, 3),
        (2005, 1, 2),  # (2004, 53, 7)
        (2008, 12, 30),  # (2009, 1, 2)
        (2010, 1, 2),  # (2009, 53, 6)
        (2009, 12, 31),  # (2009, 53, 4)
        (1900, 1, 1),  # Unusual non-leap year (year % 100 == 0)
        (1900, 12, 31),
        (2000, 1, 1),  # Unusual leap year (year % 400 == 0)
        (2000, 12, 31),
        (2004, 1, 1),  # Leap year
        (2004, 12, 31),
        (1, 1, 1),
        (9999, 12, 31),
        (MINYEAR, 1, 1),
        (MAXYEAR, 12, 31),
    ]

    for datecomps in dates:
        dobj = self.theclass(*datecomps)
        isocal = dobj.isocalendar()

        d_roundtrip = self.theclass.fromisocalendar(*isocal)

        self.assertEqual(dobj, d_roundtrip)

</t>
<t tx="ekr.20230509052845.4864">def test_fromisocalendar_value_errors(self):
    isocals = [
        (2019, 0, 1),
        (2019, -1, 1),
        (2019, 54, 1),
        (2019, 1, 0),
        (2019, 1, -1),
        (2019, 1, 8),
        (2019, 53, 1),
        (10000, 1, 1),
        (0, 1, 1),
        (9999999, 1, 1),
        (2 &lt;&lt; 32, 1, 1),
        (2019, 2 &lt;&lt; 32, 1),
        (2019, 1, 2 &lt;&lt; 32),
    ]

    for isocal in isocals:
        self.assertRaises(ValueError, self.theclass.fromisocalendar, *isocal)


</t>
<t tx="ekr.20230509052845.4865">class TestDateTime(Static[TestDate[theclass]]):
    theclass: type

    @others
</t>
<t tx="ekr.20230509052845.4866">def test_basic_attributes(self):
    dt = self.theclass(2002, 3, 1, 12, 0)
    self.assertEqual(dt.year, 2002)
    self.assertEqual(dt.month, 3)
    self.assertEqual(dt.day, 1)
    self.assertEqual(dt.hour, 12)
    self.assertEqual(dt.minute, 0)
    self.assertEqual(dt.second, 0)
    self.assertEqual(dt.microsecond, 0)

</t>
<t tx="ekr.20230509052845.4867">def test_basic_attributes_nonzero(self):
    # Make sure all attributes are non-zero so bugs in
    # bit-shifting access show up.
    dt = self.theclass(2002, 3, 1, 12, 59, 59, 8000)
    self.assertEqual(dt.year, 2002)
    self.assertEqual(dt.month, 3)
    self.assertEqual(dt.day, 1)
    self.assertEqual(dt.hour, 12)
    self.assertEqual(dt.minute, 59)
    self.assertEqual(dt.second, 59)
    self.assertEqual(dt.microsecond, 8000)

</t>
<t tx="ekr.20230509052845.4868">def test_isoformat(self):
    t = self.theclass(1, 2, 3, 4, 5, 1, 123)
    self.assertEqual(t.isoformat(), "0001-02-03T04:05:01.000123")
    self.assertEqual(t.isoformat("T"), "0001-02-03T04:05:01.000123")
    self.assertEqual(t.isoformat(" "), "0001-02-03 04:05:01.000123")
    self.assertEqual(t.isoformat("\x00"), "0001-02-03\x0004:05:01.000123")
    # bpo-34482: Check that surrogates are handled properly.
    self.assertEqual(t.isoformat("\ud800"), "0001-02-03\ud80004:05:01.000123")
    self.assertEqual(t.isoformat(timespec="hours"), "0001-02-03T04")
    self.assertEqual(t.isoformat(timespec="minutes"), "0001-02-03T04:05")
    self.assertEqual(t.isoformat(timespec="seconds"), "0001-02-03T04:05:01")
    self.assertEqual(
        t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.000"
    )
    self.assertEqual(
        t.isoformat(timespec="microseconds"), "0001-02-03T04:05:01.000123"
    )
    self.assertEqual(t.isoformat(timespec="auto"), "0001-02-03T04:05:01.000123")
    self.assertEqual(t.isoformat(sep=" ", timespec="minutes"), "0001-02-03 04:05")
    # str is ISO format with the separator forced to a blank.
    self.assertEqual(str(t), "0001-02-03 04:05:01.000123")

    # t = self.theclass(1, 2, 3, 4, 5, 1, 999500, tzinfo=timezone.utc)
    # self.assertEqual(t.isoformat(timespec='milliseconds'), "0001-02-03T04:05:01.999+00:00")

    t = self.theclass(1, 2, 3, 4, 5, 1, 999500)
    self.assertEqual(
        t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.999"
    )

    t = self.theclass(1, 2, 3, 4, 5, 1)
    self.assertEqual(t.isoformat(timespec="auto"), "0001-02-03T04:05:01")
    self.assertEqual(
        t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.000"
    )
    self.assertEqual(
        t.isoformat(timespec="microseconds"), "0001-02-03T04:05:01.000000"
    )

    t = self.theclass(2, 3, 2)
    self.assertEqual(t.isoformat(), "0002-03-02T00:00:00")
    self.assertEqual(t.isoformat("T"), "0002-03-02T00:00:00")
    self.assertEqual(t.isoformat(" "), "0002-03-02 00:00:00")
    # str is ISO format with the separator forced to a blank.
    self.assertEqual(str(t), "0002-03-02 00:00:00")
    # ISO format with timezone
    # tz = FixedOffset(timedelta(seconds=16), 'XXX')
    # t = self.theclass(2, 3, 2, tzinfo=tz)
    # self.assertEqual(t.isoformat(), "0002-03-02T00:00:00+00:00:16")

</t>
<t tx="ekr.20230509052845.4869">"""
def test_isoformat_timezone(self):
    tzoffsets = [
        ('05:00', timedelta(hours=5)),
        ('02:00', timedelta(hours=2)),
        ('06:27', timedelta(hours=6, minutes=27)),
        ('12:32:30', timedelta(hours=12, minutes=32, seconds=30)),
        ('02:04:09.123456', timedelta(hours=2, minutes=4, seconds=9, microseconds=123456))
    ]

    tzinfos = [
        ('', None),
        ('+00:00', timezone.utc),
        ('+00:00', timezone(timedelta(0))),
    ]

    tzinfos += [
        (prefix + expected, timezone(sign * td))
        for expected, td in tzoffsets
        for prefix, sign in [('-', -1), ('+', 1)]
    ]

    dt_base = self.theclass(2016, 4, 1, 12, 37, 9)
    exp_base = '2016-04-01T12:37:09'

    for exp_tz, tzi in tzinfos:
        dt = dt_base.replace(tzinfo=tzi)
        exp = exp_base + exp_tz
        with self.subTest(tzi=tzi):
            assert dt.isoformat() == exp
"""

"""
def test_more_ctime(self):
    # Test fields that TestDate doesn't touch.
    import time

    t = self.theclass(2002, 3, 2, 18, 3, 5, 123)
    self.assertEqual(t.ctime(), "Sat Mar  2 18:03:05 2002")
    # Oops!  The next line fails on Win2K under MSVC 6, so it's commented
    # out.  The difference is that t.ctime() produces " 2" for the day,
    # but platform ctime() produces "02" for the day.  According to
    # C99, t.ctime() is correct here.
    # self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))

    # So test a case where that difference doesn't matter.
    t = self.theclass(2002, 3, 22, 18, 3, 5, 123)
    self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))
"""

</t>
<t tx="ekr.20230509052845.487">  bool doIsAtomic() const override {
    return !std::any_of(types.begin(), types.end(),
                        [](auto *type) { return !type-&gt;isAtomic(); });
  }
</t>
<t tx="ekr.20230509052845.4870">def test_tz_independent_comparing(self):
    dt1 = self.theclass(2002, 3, 1, 9, 0, 0)
    dt2 = self.theclass(2002, 3, 1, 10, 0, 0)
    dt3 = self.theclass(2002, 3, 1, 9, 0, 0)
    self.assertEqual(dt1, dt3)
    self.assertTrue(dt2 &gt; dt3)

    # Make sure comparison doesn't forget microseconds, and isn't done
    # via comparing a float timestamp (an IEEE double doesn't have enough
    # precision to span microsecond resolution across years 1 through 9999,
    # so comparing via timestamp necessarily calls some distinct values
    # equal).
    dt1 = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999998)
    us = timedelta(microseconds=1)
    dt2 = dt1 + us
    self.assertEqual(dt2 - dt1, us)
    self.assertTrue(dt1 &lt; dt2)

</t>
<t tx="ekr.20230509052845.4871">def test_bad_constructor_arguments(self):
    # bad years
    self.theclass(MINYEAR, 1, 1)  # no exception
    self.theclass(MAXYEAR, 1, 1)  # no exception

    make_dt1 = lambda a, b, c: self.theclass(a, b, c)
    make_dt2 = lambda a, b, c, d: self.theclass(a, b, c, d)
    make_dt3 = lambda a, b, c, d, e: self.theclass(a, b, c, d, e)
    make_dt4 = lambda a, b, c, d, e, f: self.theclass(a, b, c, d, e, f)
    make_dt5 = lambda a, b, c, d, e, f, g: self.theclass(a, b, c, d, e, f, g)

    self.assertRaises(ValueError, make_dt1, MINYEAR - 1, 1, 1)
    self.assertRaises(ValueError, make_dt1, MAXYEAR + 1, 1, 1)
    # bad months
    self.theclass(2000, 1, 1)  # no exception
    self.theclass(2000, 12, 1)  # no exception
    self.assertRaises(ValueError, make_dt1, 2000, 0, 1)
    self.assertRaises(ValueError, make_dt1, 2000, 13, 1)
    # bad days
    self.theclass(2000, 2, 29)  # no exception
    self.theclass(2004, 2, 29)  # no exception
    self.theclass(2400, 2, 29)  # no exception
    self.assertRaises(ValueError, make_dt1, 2000, 2, 30)
    self.assertRaises(ValueError, make_dt1, 2001, 2, 29)
    self.assertRaises(ValueError, make_dt1, 2100, 2, 29)
    self.assertRaises(ValueError, make_dt1, 1900, 2, 29)
    self.assertRaises(ValueError, make_dt1, 2000, 1, 0)
    self.assertRaises(ValueError, make_dt1, 2000, 1, 32)
    # bad hours
    self.theclass(2000, 1, 31, 0)  # no exception
    self.theclass(2000, 1, 31, 23)  # no exception
    self.assertRaises(ValueError, make_dt2, 2000, 1, 31, -1)
    self.assertRaises(ValueError, make_dt2, 2000, 1, 31, 24)
    # bad minutes
    self.theclass(2000, 1, 31, 23, 0)  # no exception
    self.theclass(2000, 1, 31, 23, 59)  # no exception
    self.assertRaises(ValueError, make_dt3, 2000, 1, 31, 23, -1)
    self.assertRaises(ValueError, make_dt3, 2000, 1, 31, 23, 60)
    # bad seconds
    self.theclass(2000, 1, 31, 23, 59, 0)  # no exception
    self.theclass(2000, 1, 31, 23, 59, 59)  # no exception
    self.assertRaises(ValueError, make_dt4, 2000, 1, 31, 23, 59, -1)
    self.assertRaises(ValueError, make_dt4, 2000, 1, 31, 23, 59, 60)
    # bad microseconds
    self.theclass(2000, 1, 31, 23, 59, 59, 0)  # no exception
    self.theclass(2000, 1, 31, 23, 59, 59, 999999)  # no exception
    self.assertRaises(ValueError, make_dt5, 2000, 1, 31, 23, 59, 59, -1)
    self.assertRaises(ValueError, make_dt5, 2000, 1, 31, 23, 59, 59, 1000000)
    """
    # bad fold
    self.assertRaises(ValueError, self.theclass,
                      2000, 1, 31, fold=-1)
    self.assertRaises(ValueError, self.theclass,
                      2000, 1, 31, fold=2)
    # Positional fold:
    self.assertRaises(TypeError, self.theclass,
                      2000, 1, 31, 23, 59, 59, 0, None, 1)
    """

</t>
<t tx="ekr.20230509052845.4872">def test_hash_equality(self):
    d = self.theclass(2000, 12, 31, 23, 30, 17)
    e = self.theclass(2000, 12, 31, 23, 30, 17)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

    d = self.theclass(2001, 1, 1, 0, 5, 17)
    e = self.theclass(2001, 1, 1, 0, 5, 17)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

</t>
<t tx="ekr.20230509052845.4873">def test_computations(self):
    a = self.theclass(2002, 1, 31)
    b = self.theclass(1956, 1, 31)
    diff = a - b
    self.assertEqual(diff.days, 46 * 365 + len(range(1956, 2002, 4)))
    self.assertEqual(diff.seconds, 0)
    self.assertEqual(diff.microseconds, 0)
    a = self.theclass(2002, 3, 2, 17, 6)
    millisec = timedelta(0, 0, 1000)
    hour = timedelta(0, 3600)
    day = timedelta(1)
    week = timedelta(7)
    self.assertEqual(a + hour, self.theclass(2002, 3, 2, 18, 6))
    self.assertEqual(hour + a, self.theclass(2002, 3, 2, 18, 6))
    self.assertEqual(a + 10 * hour, self.theclass(2002, 3, 3, 3, 6))
    self.assertEqual(a - hour, self.theclass(2002, 3, 2, 16, 6))
    self.assertEqual(-hour + a, self.theclass(2002, 3, 2, 16, 6))
    self.assertEqual(a - hour, a + -hour)
    self.assertEqual(a - 20 * hour, self.theclass(2002, 3, 1, 21, 6))
    self.assertEqual(a + day, self.theclass(2002, 3, 3, 17, 6))
    self.assertEqual(a - day, self.theclass(2002, 3, 1, 17, 6))
    self.assertEqual(a + week, self.theclass(2002, 3, 9, 17, 6))
    self.assertEqual(a - week, self.theclass(2002, 2, 23, 17, 6))
    self.assertEqual(a + 52 * week, self.theclass(2003, 3, 1, 17, 6))
    self.assertEqual(a - 52 * week, self.theclass(2001, 3, 3, 17, 6))
    self.assertEqual((a + week) - a, week)
    self.assertEqual((a + day) - a, day)
    self.assertEqual((a + hour) - a, hour)
    self.assertEqual((a + millisec) - a, millisec)
    self.assertEqual((a - week) - a, -week)
    self.assertEqual((a - day) - a, -day)
    self.assertEqual((a - hour) - a, -hour)
    self.assertEqual((a - millisec) - a, -millisec)
    self.assertEqual(a - (a + week), -week)
    self.assertEqual(a - (a + day), -day)
    self.assertEqual(a - (a + hour), -hour)
    self.assertEqual(a - (a + millisec), -millisec)
    self.assertEqual(a - (a - week), week)
    self.assertEqual(a - (a - day), day)
    self.assertEqual(a - (a - hour), hour)
    self.assertEqual(a - (a - millisec), millisec)
    self.assertEqual(
        a + (week + day + hour + millisec),
        self.theclass(2002, 3, 10, 18, 6, 0, 1000),
    )
    self.assertEqual(
        a + (week + day + hour + millisec), (((a + week) + day) + hour) + millisec
    )
    self.assertEqual(
        a - (week + day + hour + millisec),
        self.theclass(2002, 2, 22, 16, 5, 59, 999000),
    )
    self.assertEqual(
        a - (week + day + hour + millisec), (((a - week) - day) - hour) - millisec
    )
    """
    # Add/sub ints or floats should be illegal
    for i in 1, 1.0:
        self.assertRaises(TypeError, lambda: a+i)
        self.assertRaises(TypeError, lambda: a-i)
        self.assertRaises(TypeError, lambda: i+a)
        self.assertRaises(TypeError, lambda: i-a)

    # delta - datetime is senseless.
    self.assertRaises(TypeError, lambda: day - a)
    # mixing datetime and (delta or datetime) via * or // is senseless
    self.assertRaises(TypeError, lambda: day * a)
    self.assertRaises(TypeError, lambda: a * day)
    self.assertRaises(TypeError, lambda: day // a)
    self.assertRaises(TypeError, lambda: a // day)
    self.assertRaises(TypeError, lambda: a * a)
    self.assertRaises(TypeError, lambda: a // a)
    # datetime + datetime is senseless
    self.assertRaises(TypeError, lambda: a + a)
    """

</t>
<t tx="ekr.20230509052845.4874">def test_more_compare(self):
    # The test_compare() inherited from TestDate covers the error cases.
    # We just want to test lexicographic ordering on the members datetime
    # has that date lacks.
    args = (2000, 11, 29, 20, 58, 16, 999998)
    newargsx = [
        (2001, 11, 29, 20, 58, 16, 999998),
        (2000, 12, 29, 20, 58, 16, 999998),
        (2000, 11, 30, 20, 58, 16, 999998),
        (2000, 11, 29, 21, 58, 16, 999998),
        (2000, 11, 29, 20, 59, 16, 999998),
        (2000, 11, 29, 20, 58, 17, 999998),
        (2000, 11, 29, 20, 58, 16, 999999),
    ]
    t1 = self.theclass(*args)
    t2 = self.theclass(*args)
    self.assertEqual(t1, t2)
    self.assertTrue(t1 &lt;= t2)
    self.assertTrue(t1 &gt;= t2)
    self.assertFalse(t1 != t2)
    self.assertFalse(t1 &lt; t2)
    self.assertFalse(t1 &gt; t2)

    for i in range(len(args)):
        newargs = newargsx[i]
        t2 = self.theclass(*newargs)  # this is larger than t1
        self.assertTrue(t1 &lt; t2)
        self.assertTrue(t2 &gt; t1)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t2 &gt;= t1)
        self.assertTrue(t1 != t2)
        self.assertTrue(t2 != t1)
        self.assertFalse(t1 == t2)
        self.assertFalse(t2 == t1)
        self.assertFalse(t1 &gt; t2)
        self.assertFalse(t2 &lt; t1)
        self.assertFalse(t1 &gt;= t2)
        self.assertFalse(t2 &lt;= t1)

</t>
<t tx="ekr.20230509052845.4875"># A helper for timestamp constructor tests.
def verify_field_equality(self, expected, got):
    self.assertEqual(expected.tm_year, got.year)
    self.assertEqual(expected.tm_mon, got.month)
    self.assertEqual(expected.tm_mday, got.day)
    self.assertEqual(expected.tm_hour, got.hour)
    self.assertEqual(expected.tm_min, got.minute)
    self.assertEqual(expected.tm_sec, got.second)

</t>
<t tx="ekr.20230509052845.4876">def test_fromtimestamp(self):
    import time

    ts = time.time()
    expected = time.localtime(int(ts))
    got = self.theclass.fromtimestamp(ts)
    self.verify_field_equality(expected, got)

</t>
<t tx="ekr.20230509052845.4877">"""
def test_utcfromtimestamp(self):
    import time

    ts = time.time()
    expected = time.gmtime(int(ts))
    got = self.theclass.utcfromtimestamp(ts)
    self.verify_field_equality(expected, got)
"""

</t>
<t tx="ekr.20230509052845.4878">def test_timestamp_naive(self):
    """
    t = self.theclass(1970, 1, 1)
    self.assertEqual(t.timestamp(), 18000.0)
    t = self.theclass(1970, 1, 1, 1, 2, 3, 4)
    self.assertEqual(t.timestamp(),
                     18000.0 + 3600 + 2*60 + 3 + 4*1e-6)
    """

    t = self.theclass(1970, 1, 1)
    self.assertEqual(t.timestamp(), 0)
    t = self.theclass(1970, 1, 1, 1, 2, 3, 4)
    self.assertEqual(t.timestamp(), 3600 + 2 * 60 + 3 + 4 * 1e-6)

    """
    # Missing hour
    t0 = self.theclass(2012, 3, 11, 2, 30)
    t1 = t0.replace(fold=1)
    self.assertEqual(self.theclass.fromtimestamp(t1.timestamp()),
                     t0 - timedelta(hours=1))
    self.assertEqual(self.theclass.fromtimestamp(t0.timestamp()),
                     t1 + timedelta(hours=1))
    # Ambiguous hour defaults to DST
    t = self.theclass(2012, 11, 4, 1, 30)
    self.assertEqual(self.theclass.fromtimestamp(t.timestamp()), t)

    # Timestamp may raise an overflow error on some platforms
    # XXX: Do we care to support the first and last year?
    for t in [self.theclass(2,1,1), self.theclass(9998,12,12)]:
        s = None
        try:
            s = t.timestamp()
        except OverflowError:
            continue

        self.assertEqual(self.theclass.fromtimestamp(s), t)
    """

</t>
<t tx="ekr.20230509052845.4879">"""
def test_timestamp_aware(self):
    t = self.theclass(1970, 1, 1, tzinfo=timezone.utc)
    self.assertEqual(t.timestamp(), 0.0)
    t = self.theclass(1970, 1, 1, 1, 2, 3, 4, tzinfo=timezone.utc)
    self.assertEqual(t.timestamp(),
                     3600 + 2*60 + 3 + 4*1e-6)
    t = self.theclass(1970, 1, 1, 1, 2, 3, 4,
                      tzinfo=timezone(timedelta(hours=-5), 'EST'))
    self.assertEqual(t.timestamp(),
                     18000 + 3600 + 2*60 + 3 + 4*1e-6)
"""
"""
def test_microsecond_rounding(self):
    for fts in (self.theclass.fromtimestamp,
                self.theclass.utcfromtimestamp):
        zero = fts(0)
        self.assertEqual(zero.second, 0)
        self.assertEqual(zero.microsecond, 0)
        one = fts(1e-6)
        minus_one = fts(-1e-6)

        self.assertEqual(minus_one.second, 59)
        self.assertEqual(minus_one.microsecond, 999999)

        t = fts(-1e-8)
        self.assertEqual(t, zero)
        t = fts(-9e-7)
        self.assertEqual(t, minus_one)
        t = fts(-1e-7)
        self.assertEqual(t, zero)
        t = fts(-1/2**7)
        self.assertEqual(t.second, 59)
        self.assertEqual(t.microsecond, 992188)

        t = fts(1e-7)
        self.assertEqual(t, zero)
        t = fts(9e-7)
        self.assertEqual(t, one)
        t = fts(0.99999949)
        self.assertEqual(t.second, 0)
        self.assertEqual(t.microsecond, 999999)
        t = fts(0.9999999)
        self.assertEqual(t.second, 1)
        self.assertEqual(t.microsecond, 0)
        t = fts(1/2**7)
        self.assertEqual(t.second, 0)
        self.assertEqual(t.microsecond, 7812)
"""
"""
def test_timestamp_limits(self):
    # minimum timestamp
    min_dt = self.theclass.min.replace(tzinfo=timezone.utc)
    min_ts = min_dt.timestamp()
    try:
        # date 0001-01-01 00:00:00+00:00: timestamp=-62135596800
        self.assertEqual(self.theclass.fromtimestamp(min_ts, tz=timezone.utc),
                         min_dt)
    except (OverflowError, OSError) as exc:
        # the date 0001-01-01 doesn't fit into 32-bit time_t,
        # or platform doesn't support such very old date
        self.skipTest(str(exc))

    # maximum timestamp: set seconds to zero to avoid rounding issues
    max_dt = self.theclass.max.replace(tzinfo=timezone.utc,
                                       second=0, microsecond=0)
    max_ts = max_dt.timestamp()
    # date 9999-12-31 23:59:00+00:00: timestamp 253402300740
    self.assertEqual(self.theclass.fromtimestamp(max_ts, tz=timezone.utc),
                     max_dt)

    # number of seconds greater than 1 year: make sure that the new date
    # is not valid in datetime.datetime limits
    delta = 3600 * 24 * 400

    # too small
    ts = min_ts - delta
    # converting a Python int to C time_t can raise a OverflowError,
    # especially on 32-bit platforms.
    self.assertRaises(ValueError, self.theclass.fromtimestamp, ts)
    self.assertRaises(ValueError, self.theclass.utcfromtimestamp, ts)

    # too big
    ts = max_dt.timestamp() + delta
    self.assertRaises(ValueError, self.theclass.fromtimestamp, ts)
    self.assertRaises(ValueError, self.theclass.utcfromtimestamp, ts)
"""

</t>
<t tx="ekr.20230509052845.488"></t>
<t tx="ekr.20230509052845.4880">def test_negative_float_fromtimestamp(self):
    # The result is tz-dependent; at least test that this doesn't
    # fail (like it did before bug 1646728 was fixed).
    self.theclass.fromtimestamp(-1.05)

</t>
<t tx="ekr.20230509052845.4881">"""
def test_negative_float_utcfromtimestamp(self):
    d = self.theclass.utcfromtimestamp(-1.05)
    self.assertEqual(d, self.theclass(1969, 12, 31, 23, 59, 58, 950000))
"""

</t>
<t tx="ekr.20230509052845.4882">def test_utcnow(self):
    import time

    # Call it a success if utcnow() and utcfromtimestamp() are within
    # a second of each other.
    from_timestamp = None
    from_now = None
    tolerance = timedelta(seconds=1)
    for dummy in range(3):
        from_now = self.theclass.utcnow()
        from_timestamp = self.theclass.utcfromtimestamp(time.time())
        if abs(from_timestamp.__val__() - from_now.__val__()) &lt;= tolerance:
            break
        # Else try again a few times.
    self.assertLessEqual(abs(from_timestamp.__val__() - from_now.__val__()), tolerance)

</t>
<t tx="ekr.20230509052845.4883">def test_extract(self):
    dt = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
    self.assertEqual(dt.date(), date(2002, 3, 4))
    self.assertEqual(dt.time(), time(18, 45, 3, 1234))

</t>
<t tx="ekr.20230509052845.4884">def test_combine(self):
    d = date(2002, 3, 4)
    t = time(18, 45, 3, 1234)
    expected = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
    combine = self.theclass.combine
    dt = combine(d, t)
    self.assertEqual(dt, expected)

    dt = combine(time=t, date=d)
    self.assertEqual(dt, expected)

    self.assertEqual(d, dt.date())
    self.assertEqual(t, dt.time())
    self.assertEqual(dt, combine(dt.date(), dt.time()))

    """
    self.assertRaises(TypeError, combine) # need an arg
    self.assertRaises(TypeError, combine, d) # need two args
    self.assertRaises(TypeError, combine, t, d) # args reversed
    self.assertRaises(TypeError, combine, d, t, 1) # wrong tzinfo type
    self.assertRaises(TypeError, combine, d, t, 1, 2)  # too many args
    self.assertRaises(TypeError, combine, "date", "time") # wrong types
    self.assertRaises(TypeError, combine, d, "time") # wrong type
    self.assertRaises(TypeError, combine, "date", t) # wrong type

    # tzinfo= argument
    dt = combine(d, t, timezone.utc)
    self.assertIs(dt.tzinfo, timezone.utc)
    dt = combine(d, t, tzinfo=timezone.utc)
    self.assertIs(dt.tzinfo, timezone.utc)
    t = time()
    dt = combine(dt, t)
    self.assertEqual(dt.date(), d)
    self.assertEqual(dt.time(), t)
    """

</t>
<t tx="ekr.20230509052845.4885">def test_replace(self):
    cls = self.theclass
    args = (1, 2, 3, 4, 5, 6, 7)
    base = cls(*args)
    self.assertEqual(base, base.replace())

    self.assertEqual(base.replace(year=2), cls(2, 2, 3, 4, 5, 6, 7))
    self.assertEqual(base.replace(month=3), cls(1, 3, 3, 4, 5, 6, 7))
    self.assertEqual(base.replace(day=4), cls(1, 2, 4, 4, 5, 6, 7))
    self.assertEqual(base.replace(hour=5), cls(1, 2, 3, 5, 5, 6, 7))
    self.assertEqual(base.replace(minute=6), cls(1, 2, 3, 4, 6, 6, 7))
    self.assertEqual(base.replace(second=7), cls(1, 2, 3, 4, 5, 7, 7))
    self.assertEqual(base.replace(microsecond=8), cls(1, 2, 3, 4, 5, 6, 8))
    # Out of bounds.
    base = cls(2000, 2, 29)
    self.assertRaises(ValueError, lambda: base.replace(year=2001))

</t>
<t tx="ekr.20230509052845.4886">"""
def test_astimezone(self):
    dt = self.theclass.now()
    f = FixedOffset(44, "0044")
    dt_utc = dt.replace(tzinfo=timezone(timedelta(hours=-4), 'EDT'))
    self.assertEqual(dt.astimezone(), dt_utc) # naive
    self.assertRaises(TypeError, dt.astimezone, f, f) # too many args
    self.assertRaises(TypeError, dt.astimezone, dt) # arg wrong type
    dt_f = dt.replace(tzinfo=f) + timedelta(hours=4, minutes=44)
    self.assertEqual(dt.astimezone(f), dt_f) # naive
    self.assertEqual(dt.astimezone(tz=f), dt_f) # naive

    class Bogus(tzinfo):
        def utcoffset(self, dt): return None
        def dst(self, dt): return timedelta(0)
    bog = Bogus()
    self.assertRaises(ValueError, dt.astimezone, bog)   # naive
    self.assertEqual(dt.replace(tzinfo=bog).astimezone(f), dt_f)

    class AlsoBogus(tzinfo):
        def utcoffset(self, dt): return timedelta(0)
        def dst(self, dt): return None
    alsobog = AlsoBogus()
    self.assertRaises(ValueError, dt.astimezone, alsobog) # also naive

    class Broken(tzinfo):
        def utcoffset(self, dt): return 1
        def dst(self, dt): return 1
    broken = Broken()
    dt_broken = dt.replace(tzinfo=broken)
    with self.assertRaises(TypeError):
        dt_broken.astimezone()
"""

</t>
<t tx="ekr.20230509052845.4887">def test_fromisoformat_datetime(self):
    # Test that isoformat() is reversible
    base_dates = [(1, 1, 1), (1900, 1, 1), (2004, 11, 12), (2017, 5, 30)]

    base_times = [
        (0, 0, 0, 0),
        (0, 0, 0, 241000),
        (0, 0, 0, 234567),
        (12, 30, 45, 234567),
    ]

    separators = [" ", "T"]

    dts = [
        self.theclass(*date_tuple, *time_tuple)
        for date_tuple in base_dates
        for time_tuple in base_times
    ]

    for dt in dts:
        for sep in separators:
            dtstr = dt.isoformat(sep=sep)
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

</t>
<t tx="ekr.20230509052845.4888">def test_fromisoformat_separators(self):
    separators = [" ", "T"]

    for sep in separators:
        dt = self.theclass(2018, 1, 31, 23, 59, 47, 124789)
        dtstr = dt.isoformat(sep=sep)

        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

</t>
<t tx="ekr.20230509052845.4889">def test_fromisoformat_ambiguous(self):
    # Test strings like 2018-01-31+12:15 (where +12:15 is not a time zone)
    separators = ["+", "-"]
    for sep in separators:
        dt = self.theclass(2018, 1, 31, 12, 15)
        dtstr = dt.isoformat(sep=sep)

        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

</t>
<t tx="ekr.20230509052845.489">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/visitor.h"

namespace codon {
namespace ir {
namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4890">def test_fromisoformat_timespecs(self):
    datetime_bases = [(2009, 12, 4, 8, 17, 45, 123456), (2009, 12, 4, 8, 17, 45, 0)]

    timespecs = ["hours", "minutes", "seconds", "milliseconds", "microseconds"]

    for dt_tuple in datetime_bases:
        dt = self.theclass(*(dt_tuple[0:4]))
        dtstr = dt.isoformat(timespec="hours")
        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

        dt = self.theclass(*(dt_tuple[0:5]))
        dtstr = dt.isoformat(timespec="minutes")
        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

        dt = self.theclass(*(dt_tuple[0:6]))
        dtstr = dt.isoformat(timespec="seconds")
        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

        new_microseconds = 1000 * (dt_tuple[6] // 1000)
        dt_tuple2 = (*dt_tuple[0:6], new_microseconds)
        dt = self.theclass(*(dt_tuple2[0:7]))
        dtstr = dt.isoformat(timespec="milliseconds")
        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

        dt = self.theclass(*(dt_tuple[0:8]))
        dtstr = dt.isoformat(timespec="microseconds")
        dt_rt = self.theclass.fromisoformat(dtstr)
        self.assertEqual(dt, dt_rt)

</t>
<t tx="ekr.20230509052845.4891">def test_fromisoformat_fails_datetime(self):
    # Test that fromisoformat() fails on invalid values
    bad_strs = [
        "",  # Empty string
        "\ud800",  # bpo-34454: Surrogate code point
        "2009.04-19T03",  # Wrong first separator
        "2009-04.19T03",  # Wrong second separator
        "2009-04-19T0a",  # Invalid hours
        "2009-04-19T03:1a:45",  # Invalid minutes
        "2009-04-19T03:15:4a",  # Invalid seconds
        "2009-04-19T03;15:45",  # Bad first time separator
        "2009-04-19T03:15;45",  # Bad second time separator
        "2009-04-19T03:15:4500:00",  # Bad time zone separator
        "2009-04-19T03:15:45.2345",  # Too many digits for milliseconds
        "2009-04-19T03:15:45.1234567",  # Too many digits for microseconds
        "2009-04-19T03:15:45.123456+24:30",  # Invalid time zone offset
        "2009-04-19T03:15:45.123456-24:30",  # Invalid negative offset
        "2009-04-1012:15",  # Too many unicode separators
        "2009-04\ud80010T12:15",  # Surrogate char in date
        "2009-04-10T12\ud80015",  # Surrogate char in time
        "2009-04-19T1",  # Incomplete hours
        "2009-04-19T12:3",  # Incomplete minutes
        "2009-04-19T12:30:4",  # Incomplete seconds
        "2009-04-19T12:",  # Ends with time separator
        "2009-04-19T12:30:",  # Ends with time separator
        "2009-04-19T12:30:45.",  # Ends with time separator
        "2009-04-19T12:30:45.123456+",  # Ends with timzone separator
        "2009-04-19T12:30:45.123456-",  # Ends with timzone separator
        "2009-04-19T12:30:45.123456-05:00a",  # Extra text
        "2009-04-19T12:30:45.123-05:00a",  # Extra text
        "2009-04-19T12:30:45-05:00a",  # Extra text
    ]

    for bad_str in bad_strs:
        self.assertRaises(ValueError, self.theclass.fromisoformat, bad_str)


</t>
<t tx="ekr.20230509052845.4892">class TestTime(Static[TestCase]):
    theclass: type = time

    @others
</t>
<t tx="ekr.20230509052845.4893">def test_basic_attributes(self):
    t = self.theclass(12, 0)
    self.assertEqual(t.hour, 12)
    self.assertEqual(t.minute, 0)
    self.assertEqual(t.second, 0)
    self.assertEqual(t.microsecond, 0)

</t>
<t tx="ekr.20230509052845.4894">def test_basic_attributes_nonzero(self):
    # Make sure all attributes are non-zero so bugs in
    # bit-shifting access show up.
    t = self.theclass(12, 59, 59, 8000)
    self.assertEqual(t.hour, 12)
    self.assertEqual(t.minute, 59)
    self.assertEqual(t.second, 59)
    self.assertEqual(t.microsecond, 8000)

</t>
<t tx="ekr.20230509052845.4895">def test_comparing(self):
    args = (1, 2, 3, 4)
    newargsx = [(2, 2, 3, 4), (1, 3, 3, 4), (1, 2, 4, 4), (1, 2, 3, 5)]
    t1 = self.theclass(*args)
    t2 = self.theclass(*args)
    self.assertEqual(t1, t2)
    self.assertTrue(t1 &lt;= t2)
    self.assertTrue(t1 &gt;= t2)
    self.assertFalse(t1 != t2)
    self.assertFalse(t1 &lt; t2)
    self.assertFalse(t1 &gt; t2)

    for i in range(len(args)):
        newargs = newargsx[i]
        t2 = self.theclass(*newargs)  # this is larger than t1
        self.assertTrue(t1 &lt; t2)
        self.assertTrue(t2 &gt; t1)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t2 &gt;= t1)
        self.assertTrue(t1 != t2)
        self.assertTrue(t2 != t1)
        self.assertFalse(t1 == t2)
        self.assertFalse(t2 == t1)
        self.assertFalse(t1 &gt; t2)
        self.assertFalse(t2 &lt; t1)
        self.assertFalse(t1 &gt;= t2)
        self.assertFalse(t2 &lt;= t1)

    """
    for badarg in OTHERSTUFF:
        self.assertEqual(t1 == badarg, False)
        self.assertEqual(t1 != badarg, True)
        self.assertEqual(badarg == t1, False)
        self.assertEqual(badarg != t1, True)

        self.assertRaises(TypeError, lambda: t1 &lt;= badarg)
        self.assertRaises(TypeError, lambda: t1 &lt; badarg)
        self.assertRaises(TypeError, lambda: t1 &gt; badarg)
        self.assertRaises(TypeError, lambda: t1 &gt;= badarg)
        self.assertRaises(TypeError, lambda: badarg &lt;= t1)
        self.assertRaises(TypeError, lambda: badarg &lt; t1)
        self.assertRaises(TypeError, lambda: badarg &gt; t1)
        self.assertRaises(TypeError, lambda: badarg &gt;= t1)
    """

</t>
<t tx="ekr.20230509052845.4896">def test_bad_constructor_arguments(self):
    # bad hours
    self.theclass(0, 0)  # no exception
    self.theclass(23, 0)  # no exception

    make_time1 = lambda a, b: self.theclass(a, b)
    make_time2 = lambda a, b, c: self.theclass(a, b, c)
    make_time3 = lambda a, b, c, d: self.theclass(a, b, c, d)

    self.assertRaises(ValueError, make_time1, -1, 0)
    self.assertRaises(ValueError, make_time1, 24, 0)
    # bad minutes
    self.theclass(23, 0)  # no exception
    self.theclass(23, 59)  # no exception
    self.assertRaises(ValueError, make_time1, 23, -1)
    self.assertRaises(ValueError, make_time1, 23, 60)
    # bad seconds
    self.theclass(23, 59, 0)  # no exception
    self.theclass(23, 59, 59)  # no exception
    self.assertRaises(ValueError, make_time2, 23, 59, -1)
    self.assertRaises(ValueError, make_time2, 23, 59, 60)
    # bad microseconds
    self.theclass(23, 59, 59, 0)  # no exception
    self.theclass(23, 59, 59, 999999)  # no exception
    self.assertRaises(ValueError, make_time3, 23, 59, 59, -1)
    self.assertRaises(ValueError, make_time3, 23, 59, 59, 1000000)

</t>
<t tx="ekr.20230509052845.4897">def test_hash_equality(self):
    d = self.theclass(23, 30, 17)
    e = self.theclass(23, 30, 17)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

    d = self.theclass(0, 5, 17)
    e = self.theclass(0, 5, 17)
    self.assertEqual(d, e)
    self.assertEqual(hash(d), hash(e))

    dic = {d: 1}
    dic[e] = 2
    self.assertEqual(len(dic), 1)
    self.assertEqual(dic[d], 2)
    self.assertEqual(dic[e], 2)

</t>
<t tx="ekr.20230509052845.4898">def test_isoformat(self):
    t = self.theclass(4, 5, 1, 123)
    self.assertEqual(t.isoformat(), "04:05:01.000123")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass()
    self.assertEqual(t.isoformat(), "00:00:00")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=1)
    self.assertEqual(t.isoformat(), "00:00:00.000001")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=10)
    self.assertEqual(t.isoformat(), "00:00:00.000010")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=100)
    self.assertEqual(t.isoformat(), "00:00:00.000100")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=1000)
    self.assertEqual(t.isoformat(), "00:00:00.001000")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=10000)
    self.assertEqual(t.isoformat(), "00:00:00.010000")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(microsecond=100000)
    self.assertEqual(t.isoformat(), "00:00:00.100000")
    self.assertEqual(t.isoformat(), str(t))

    t = self.theclass(hour=12, minute=34, second=56, microsecond=123456)
    self.assertEqual(t.isoformat(timespec="hours"), "12")
    self.assertEqual(t.isoformat(timespec="minutes"), "12:34")
    self.assertEqual(t.isoformat(timespec="seconds"), "12:34:56")
    self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.123")
    self.assertEqual(t.isoformat(timespec="microseconds"), "12:34:56.123456")
    self.assertEqual(t.isoformat(timespec="auto"), "12:34:56.123456")

    t = self.theclass(hour=12, minute=34, second=56, microsecond=999500)
    self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.999")

    t = self.theclass(hour=12, minute=34, second=56, microsecond=0)
    self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.000")
    self.assertEqual(t.isoformat(timespec="microseconds"), "12:34:56.000000")
    self.assertEqual(t.isoformat(timespec="auto"), "12:34:56")

</t>
<t tx="ekr.20230509052845.4899">def test_str(self):
    self.assertEqual(str(self.theclass(1, 2, 3, 4)), "01:02:03.000004")
    self.assertEqual(str(self.theclass(10, 2, 3, 4000)), "10:02:03.004000")
    self.assertEqual(str(self.theclass(0, 2, 3, 400000)), "00:02:03.400000")
    self.assertEqual(str(self.theclass(12, 2, 3, 0)), "12:02:03")
    self.assertEqual(str(self.theclass(23, 15, 0, 0)), "23:15:00")

</t>
<t tx="ekr.20230509052845.49">def __sub__(self, other):
    return self + other * -1

</t>
<t tx="ekr.20230509052845.490">class CloneVisitor : public ConstVisitor {
private:
  /// the clone context
  std::unordered_map&lt;int, Node *&gt; ctx;
  /// the result
  Node *result;
  /// the module
  Module *module;
  /// true if break/continue loops should be cloned
  bool cloneLoop;

public:
  /// Constructs a clone visitor.
  /// @param module the module
  /// @param cloneLoop true if break/continue loops should be cloned
  explicit CloneVisitor(Module *module, bool cloneLoop = true)
      : ctx(), result(nullptr), module(module), cloneLoop(cloneLoop) {}

  virtual ~CloneVisitor() noexcept = default;

  void visit(const Var *v) override;

  void visit(const BodiedFunc *v) override;
  void visit(const ExternalFunc *v) override;
  void visit(const InternalFunc *v) override;
  void visit(const LLVMFunc *v) override;

  void visit(const VarValue *v) override;
  void visit(const PointerValue *v) override;

  void visit(const SeriesFlow *v) override;
  void visit(const IfFlow *v) override;
  void visit(const WhileFlow *v) override;
  void visit(const ForFlow *v) override;
  void visit(const ImperativeForFlow *v) override;
  void visit(const TryCatchFlow *v) override;
  void visit(const PipelineFlow *v) override;
  void visit(const dsl::CustomFlow *v) override;

  void visit(const IntConst *v) override;
  void visit(const FloatConst *v) override;
  void visit(const BoolConst *v) override;
  void visit(const StringConst *v) override;
  void visit(const dsl::CustomConst *v) override;

  void visit(const AssignInstr *v) override;
  void visit(const ExtractInstr *v) override;
  void visit(const InsertInstr *v) override;
  void visit(const CallInstr *v) override;
  void visit(const StackAllocInstr *v) override;
  void visit(const TypePropertyInstr *v) override;
  void visit(const YieldInInstr *v) override;
  void visit(const TernaryInstr *v) override;
  void visit(const BreakInstr *v) override;
  void visit(const ContinueInstr *v) override;
  void visit(const ReturnInstr *v) override;
  void visit(const YieldInstr *v) override;
  void visit(const ThrowInstr *v) override;
  void visit(const FlowInstr *v) override;
  void visit(const dsl::CustomInstr *v) override;

  /// Clones a value, returning the previous value if other has already been cloned.
  /// @param other the original
  /// @param cloneTo the function to clone locals to, or null if none
  /// @param remaps variable re-mappings
  /// @return the clone
  Value *clone(const Value *other, BodiedFunc *cloneTo = nullptr,
               const std::unordered_map&lt;id_t, Var *&gt; &amp;remaps = {});

  /// Returns the original unless the variable has been force cloned.
  /// @param other the original
  /// @return the original or the previous clone
  Var *clone(const Var *other);

  /// Clones a flow, returning the previous value if other has already been cloned.
  /// @param other the original
  /// @return the clone
  Flow *clone(const Flow *other) {
    return cast&lt;Flow&gt;(clone(static_cast&lt;const Value *&gt;(other)));
  }

  /// Forces a clone. No difference for values but ensures that variables are actually
  /// cloned.
  /// @param other the original
  /// @return the clone
  template &lt;typename NodeType&gt; NodeType *forceClone(const NodeType *other) {
    if (!other)
      return nullptr;

    auto id = other-&gt;getId();
    if (ctx.find(id) == ctx.end()) {
      other-&gt;accept(*this);
      ctx[id] = result;

      for (auto it = other-&gt;attributes_begin(); it != other-&gt;attributes_end(); ++it) {
        const auto *attr = other-&gt;getAttribute(*it);
        if (attr-&gt;needsClone()) {
          ctx[id]-&gt;setAttribute(attr-&gt;forceClone(*this), *it);
        }
      }
    }
    return cast&lt;NodeType&gt;(ctx[id]);
  }

@others
};

</t>
<t tx="ekr.20230509052845.4900">def test_repr(self):
    self.assertEqual(
        repr(self.theclass(1, 2, 3, 4)),
        "time(hour=1, minute=2, second=3, microsecond=4)",
    )
    self.assertEqual(
        repr(self.theclass(10, 2, 3, 4000)),
        "time(hour=10, minute=2, second=3, microsecond=4000)",
    )
    self.assertEqual(
        repr(self.theclass(0, 2, 3, 400000)),
        "time(hour=0, minute=2, second=3, microsecond=400000)",
    )
    self.assertEqual(
        repr(self.theclass(12, 2, 3, 0)), "time(hour=12, minute=2, second=3)"
    )
    self.assertEqual(repr(self.theclass(23, 15, 0, 0)), "time(hour=23, minute=15)")

</t>
<t tx="ekr.20230509052845.4901">def test_resolution_info(self):
    self.assertTrue(self.theclass.max &gt; self.theclass.min)

</t>
<t tx="ekr.20230509052845.4902">def test_bool(self):
    # time is always True.
    cls = self.theclass
    self.assertTrue(cls(1))
    self.assertTrue(cls(0, 1))
    self.assertTrue(cls(0, 0, 1))
    self.assertTrue(cls(0, 0, 0, 1))
    self.assertTrue(cls(0))
    self.assertTrue(cls())

</t>
<t tx="ekr.20230509052845.4903">def test_replace(self):
    cls = self.theclass
    args = (1, 2, 3, 4)
    base = cls(*args)
    self.assertEqual(base, base.replace())

    self.assertEqual(base.replace(hour=5), cls(5, 2, 3, 4))
    self.assertEqual(base.replace(minute=6), cls(1, 6, 3, 4))
    self.assertEqual(base.replace(second=7), cls(1, 2, 7, 4))
    self.assertEqual(base.replace(microsecond=8), cls(1, 2, 3, 8))

    # Out of bounds.
    base = cls(1)
    self.assertRaises(ValueError, lambda: base.replace(hour=24))
    self.assertRaises(
        ValueError, lambda: base.replace(minute=-2)
    )  # minute=-1 indicates default; changed to -2 for test
    self.assertRaises(ValueError, lambda: base.replace(second=100))
    self.assertRaises(ValueError, lambda: base.replace(microsecond=1000000))


</t>
<t tx="ekr.20230509052845.4904">case_td = TestTimeDelta()
case_td.test_computations()
case_td.test_constructor()
case_td.test_resolution_info()
case_td.test_basic_attributes()
case_td.test_total_seconds()
case_td.test_carries()
case_td.test_hash_equality()
case_td.test_compare()
case_td.test_str()
case_td.test_repr()
case_td.test_microsecond_rounding()
case_td.test_massive_normalization()
case_td.test_bool()
case_td.test_division()
case_td.test_remainder()
case_td.test_divmod()

case_do = TestDateOnly()
case_do.test_delta_non_days_ignored()

case_dx = TestDate[date]()
case_dx.test_basic_attributes()
case_dx.test_ordinal_conversions()
# case_dx.test_extreme_ordinals()
case_dx.test_bad_constructor_arguments()
case_dx.test_hash_equality()
case_dx.test_computations()
case_dx.test_fromtimestamp()
case_dx.test_today()
case_dx.test_weekday()
case_dx.test_isocalendar()
case_dx.test_iso_long_years()
case_dx.test_isoformat()
case_dx.test_ctime()
case_dx.test_timetuple()
case_dx.test_compare()
case_dx.test_replace()
case_dx.test_fromisoformat()
case_dx.test_fromisoformat_fails()
case_dx.test_fromisocalendar()
case_dx.test_fromisocalendar_value_errors()

case_dt = TestDateTime[datetime]()
case_dt.test_ordinal_conversions()
case_dt.test_today()
case_dt.test_weekday()
case_dt.test_isocalendar()
case_dt.test_iso_long_years()
case_dt.test_ctime()
case_dt.test_timetuple()
case_dt.test_compare()
case_dt.test_fromisoformat()
case_dt.test_fromisoformat_fails()
case_dt.test_fromisocalendar_value_errors()
# ---
case_dt.test_basic_attributes()
case_dt.test_basic_attributes_nonzero()
case_dt.test_isoformat()
# case_dt.test_more_ctime()
case_dt.test_tz_independent_comparing()
case_dt.test_bad_constructor_arguments()
case_dt.test_hash_equality()
case_dt.test_computations()
case_dt.test_more_compare()
case_dt.test_fromtimestamp()
# case_dt.test_utcfromtimestamp()
case_dt.test_timestamp_naive()
# case_dt.test_microsecond_rounding()
# case_dt.test_timestamp_limits()
case_dt.test_negative_float_fromtimestamp()
# case_dt.test_negative_float_utcfromtimestamp()
case_dt.test_utcnow()
case_dt.test_extract()
case_dt.test_combine()
case_dt.test_replace()
case_dt.test_fromisoformat_datetime()
case_dt.test_fromisoformat_separators()
case_dt.test_fromisoformat_ambiguous()
case_dt.test_fromisoformat_timespecs()
case_dt.test_fromisoformat_fails_datetime()

case_tx = TestTime()
case_tx.test_basic_attributes()
case_tx.test_basic_attributes_nonzero()
case_tx.test_comparing()
case_tx.test_bad_constructor_arguments()
case_tx.test_hash_equality()
case_tx.test_isoformat()
case_tx.test_str()
case_tx.test_repr()
case_tx.test_resolution_info()
case_tx.test_bool()
case_tx.test_replace()

</t>
<t tx="ekr.20230509052845.4905">@test
def test_constants():
    assert str(timedelta.min) == '-106751992 days, 19:59:05.224192'  # note: diff w/ Python
    assert str(timedelta.max) == '106751991 days, 4:00:54.775807'    # note: diff w/ Python
    assert str(timedelta.resolution) == '0:00:00.000001'

    assert str(date.min) == '0001-01-01'
    assert str(date.max) == '9999-12-31'
    assert str(date.resolution) == '1 day, 0:00:00'

    assert str(time.min) == '00:00:00'
    assert str(time.max) == '23:59:59.999999'
    assert str(time.resolution) == '0:00:00.000001'

    assert str(datetime.min) == '0001-01-01 00:00:00'
    assert str(datetime.max) == '9999-12-31 23:59:59.999999'
    assert str(datetime.resolution) == '0:00:00.000001'
</t>
<t tx="ekr.20230509052845.4906">@path C:/Repos/codon/test/stdlib/
import heapq
from random import random, randrange


@others
test_heapify()
test_naive_nbest()
test_nsmallest()
test_nlargest()
test_nbest()
test_nbest_with_pushpop()
test_heappushpop()
test_heappop_max()
test_heapsort()
# test_comparison_operator()
test_merge()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4907">@test
def check_invariant(heap):
    # Check the heap invariant.
    for pos, item in enumerate(heap):
        if pos:  # pos 0 has no parent
            parentpos = (pos - 1) &gt;&gt; 1
            assert heap[parentpos] &lt;= item


</t>
<t tx="ekr.20230509052845.4908">@test
def test_heapify():
    for size in list(range(30)) + [20000]:
        heap = [random() for dummy in range(size)]
        heapq.heapify(heap)
        check_invariant(heap)


</t>
<t tx="ekr.20230509052845.4909">@test
def test_naive_nbest():
    data = [randrange(2000) for i in range(1000)]
    heap = []
    for item in data:
        heapq.heappush(heap, item)
        if len(heap) &gt; 10:
            heapq.heappop(heap)
    heap.sort()
    assert heap == sorted(data)[-10:]


</t>
<t tx="ekr.20230509052845.491">  /// Remaps a clone.
  /// @param original the original
  /// @param newVal the clone
  template &lt;typename NodeType&gt;
  void forceRemap(const NodeType *original, const NodeType *newVal) {
    ctx[original-&gt;getId()] = const_cast&lt;NodeType *&gt;(newVal);
  }

</t>
<t tx="ekr.20230509052845.4910">def heapiter(heap):
    # An iterator returning a heap's elements, smallest-first.
    while heap:
        yield heapq.heappop(heap)


</t>
<t tx="ekr.20230509052845.4911">@test
def test_nbest():
    # Less-naive "N-best" algorithm, much faster (if len(data) is big
    # enough &lt;wink&gt;) than sorting all of data.  However, if we had a max
    # heap instead of a min heap, it could go faster still via
    # heapify'ing all of data (linear time), then doing 10 heappops
    # (10 log-time steps).
    data = [randrange(2000) for i in range(1000)]
    heap = data[:10]
    heapq.heapify(heap)
    for item in data[10:]:
        if item &gt; heap[0]:  # this gets rarer the longer we run
            heapq.heapreplace(heap, item)
    assert list(heapiter(heap)) == sorted(data)[-10:]


</t>
<t tx="ekr.20230509052845.4912">@test
def test_nbest_with_pushpop():
    data = [randrange(2000) for i in range(1000)]
    heap = data[:10]
    heapq.heapify(heap)
    for item in data[10:]:
        heapq.heappushpop(heap, item)
    assert list(heapiter(heap)) == sorted(data)[-10:]
    assert heapq.heappushpop(List[str](), "x") == "x"


</t>
<t tx="ekr.20230509052845.4913">@test
def test_heappushpop():
    h = List[int]()
    x = heapq.heappushpop(h, 10)
    assert (h, x) == (List[int](), 10)

    h = [10]
    x = heapq.heappushpop(h, 9)
    assert (h, x) == ([10], 9)

    h = [10]
    x = heapq.heappushpop(h, 11)
    assert (h, x) == ([11], 10)


</t>
<t tx="ekr.20230509052845.4914">@test
def test_heappop_max():
    # _heapop_max has an optimization for one-item lists which isn't
    # covered in other tests, so test that case explicitly here
    h = [3, 2]
    assert heapq._heappop_max(h) == 3
    assert heapq._heappop_max(h) == 2


</t>
<t tx="ekr.20230509052845.4915">@test
def test_heapsort():
    # Exercise everything with repeated heapsort checks
    for trial in range(100):
        size = randrange(50)
        data = [randrange(25) for i in range(size)]
        heap = None
        if trial &amp; 1:  # Half of the time, use heapify
            heap = data[:]
            heapq.heapify(heap)
        else:  # The rest of the time, use heappush
            heap = []
            for item in data:
                heapq.heappush(heap, item)
        heap_sorted = [heapq.heappop(heap) for i in range(size)]
        assert heap_sorted == sorted(data)


</t>
<t tx="ekr.20230509052845.4916">"""
def test_merge(self):
    inputs = []
    for i in range(randrange(25)):
        row = []
        for j in range(randrange(100)):
            tup = choice('ABC'), randrange(-500, 500)
            row.append(tup)
        inputs.append(row)

    for key in [None, itemgetter(0), itemgetter(1), itemgetter(1, 0)]:
        for reverse in [False, True]:
            seqs = []
            for seq in inputs:
                seqs.append(sorted(seq, key=key, reverse=reverse))
            self.assertEqual(sorted(chain(*inputs), key=key, reverse=reverse),
                             list(heapq.merge(*seqs, key=key, reverse=reverse)))
            self.assertEqual(list(heapq.merge()), [])

def test_empty_merges(self):
    # Merging two empty lists (with or without a key) should produce
    # another empty list.
    self.assertEqual(list(heapq.merge([], [])), [])
    self.assertEqual(list(heapq.merge([], [], key=lambda: 6)), [])

def test_merge_does_not_suppress_index_error(self):
    # Issue 19018: Heapq.merge suppresses IndexError from user generator
    def iterable():
        s = list(range(10))
        for i in range(20):
            yield s[i]       # IndexError when i &gt; 10
    with self.assertRaises(IndexError):
        list(heapq.merge(iterable(), iterable()))

def test_merge_stability(self):
    class Int(int):
        pass
    inputs = [[], [], [], []]
    for i in range(20000):
        stream = randrange(4)
        x = randrange(500)
        obj = Int(x)
        obj.pair = (x, stream)
        inputs[stream].append(obj)
    for stream in inputs:
        stream.sort()
    result = [i.pair for i in heapq.merge(*inputs)]
    self.assertEqual(result, sorted(result))
"""


</t>
<t tx="ekr.20230509052845.4917">def mykey(x: Tuple[int, int]):
    return (x[0] * 547 % 2000, x[1] * 547 % 2000)


</t>
<t tx="ekr.20230509052845.4918">@test
def test_nsmallest():
    data = [(randrange(2000), i) for i in range(1000)]
    for n in (10,):
        assert list(heapq.nsmallest(n, data)) == sorted(data)[: min(n, len(data))]
        assert (
            list(heapq.nsmallest(n, data, key=mykey))
            == sorted(data, key=mykey)[: min(n, len(data))]
        )
        assert list(heapq.nsmallest(n, data)) == sorted(data)[: min(n, len(data))]


</t>
<t tx="ekr.20230509052845.4919">@test
def test_nlargest():
    data = [(randrange(2000), i) for i in range(1000)]
    for n in (0, 1, 2, 10, 100, 400, 999, 1000, 1100):
        assert list(heapq.nlargest(n, data)) == sorted(data)[::-1][: min(n, len(data))]
        assert (
            list(heapq.nlargest(n, data, key=mykey))
            == sorted(data, key=mykey)[::-1][: min(n, len(data))]
        )
        assert list(heapq.nlargest(n, data)) == sorted(data)[::-1][: min(n, len(data))]


</t>
<t tx="ekr.20230509052845.492">  PipelineFlow::Stage clone(const PipelineFlow::Stage &amp;other) {
    std::vector&lt;Value *&gt; args;
    for (const auto *a : other)
      args.push_back(clone(a));
    return {clone(other.getCallee()), std::move(args), other.isGenerator(),
            other.isParallel()};
  }

private:
</t>
<t tx="ekr.20230509052845.4920">@test
def test_comparison_operator():
    @others
    data = [random() for i in range(100)]
    target = list(reversed(sorted(data)))
    assert hsort(data, LT) == target


</t>
<t tx="ekr.20230509052845.4921">def hsort(data: List[float], T: type):
    data2 = [T(x) for x in data]
    heapq.heapify(data2)
    return [heapq.heappop(data2).x for i in range(len(data))]

</t>
<t tx="ekr.20230509052845.4922">class LT:
    x: float

    def __init__(self, x: float):
        self.x = x

    def __lt__(self, other: LT):
        return self.x &gt; other.x

</t>
<t tx="ekr.20230509052845.4923">@test
def test_merge():
    assert [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25] == list(heapq.merge([1, 3, 5, 7], [0, 2, 4, 8], [5, 10, 15, 20], List[int](), [25]))
    assert ['dog', 'cat', 'fish', 'horse', 'kangaroo'] == list(heapq.merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))

    assert [25, 20, 15, 10, 8, 7, 5, 5, 4, 3, 2, 1, 0] == list(heapq.merge([7, 5, 3, 1], [8, 4, 2, 0], [20, 15, 10, 5], List[int](), [25], reverse=True))
    assert ['kangaroo', 'horse', 'fish', 'dog', 'cat'] == list(heapq.merge(['horse', 'dog'], ['kangaroo', 'fish', 'cat'], key=len, reverse=True))


</t>
<t tx="ekr.20230509052845.4924">@path C:/Repos/codon/test/stdlib/
import itertools
from itertools import *
import math


@others
test_tee_from_cpython()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4925">def lzip(*args):
    return list(zip(*args))


</t>
<t tx="ekr.20230509052845.4926">def onearg(x):
    "Test function of one argument"
    return 2 * x


</t>
<t tx="ekr.20230509052845.4927">def errfunc(*args):
    "Test function that raises an error"
    raise ValueError()


</t>
<t tx="ekr.20230509052845.4928">def gen3():
    "Non-restartable source sequence"
    for i in (0, 1, 2):
        yield i


</t>
<t tx="ekr.20230509052845.4929">def isEven(x):
    "Test predicate"
    return x % 2 == 0


</t>
<t tx="ekr.20230509052845.493">  template &lt;typename NodeType, typename... Args&gt;
  NodeType *Nt(const NodeType *source, Args... args) {
    return module-&gt;N&lt;NodeType&gt;(source, std::forward&lt;Args&gt;(args)..., source-&gt;getName());
  }
</t>
<t tx="ekr.20230509052845.4930">def isOdd(x):
    "Test predicate"
    return x % 2 == 1


</t>
<t tx="ekr.20230509052845.4931">def tupleize(*args):
    return args


</t>
<t tx="ekr.20230509052845.4932">def irange(n):
    for i in range(n):
        yield i


</t>
<t tx="ekr.20230509052845.4933">def take(n, seq):
    "Convenience function for partially consuming a long of infinite iterable"
    return list(islice(seq, n))


</t>
<t tx="ekr.20230509052845.4934">def testR(r):
    return r[0]


</t>
<t tx="ekr.20230509052845.4935">def testR2(r):
    return r[2]


</t>
<t tx="ekr.20230509052845.4936">def underten(x):
    return x &lt; 10


</t>
<t tx="ekr.20230509052845.4937">@test
def test_combinations():
    assert list(itertools.combinations("ABCD", 2)) == [
        ["A", "B"],
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    test_intermediate = itertools.combinations("ABCD", 2)
    next(test_intermediate)
    assert list(test_intermediate) == [
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    assert list(itertools.combinations(range(4), 3)) == [
        [0, 1, 2],
        [0, 1, 3],
        [0, 2, 3],
        [1, 2, 3],
    ]
    test_intermediate = itertools.combinations(range(4), 3)
    next(test_intermediate)
    assert list(test_intermediate) == [[0, 1, 3], [0, 2, 3], [1, 2, 3]]


</t>
<t tx="ekr.20230509052845.4938">@test
def test_combinations_with_replacement():
    assert list(itertools.combinations_with_replacement(range(3), 3)) == [
        [0, 0, 0],
        [0, 0, 1],
        [0, 0, 2],
        [0, 1, 1],
        [0, 1, 2],
        [0, 2, 2],
        [1, 1, 1],
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 2],
    ]
    assert list(itertools.combinations_with_replacement("ABC", 2)) == [
        ["A", "A"],
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]
    test_intermediate = itertools.combinations_with_replacement("ABC", 2)
    next(test_intermediate)
    assert list(test_intermediate) == [
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]


</t>
<t tx="ekr.20230509052845.4939">@test
def test_islice():
    ra100 = range(100)
    ra = range(10)
    assert list(itertools.islice(iter("ABCDEFG"), 0, 2, 1)) == ["A", "B"]
    assert list(itertools.islice(iter(ra100), 10, 20, 3)) == [10, 13, 16, 19]
    assert list(itertools.islice(iter(ra100), 10, 3, 20)) == []
    assert list(itertools.islice(iter(ra100), 10, 20, 1)) == [
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]
    assert list(itertools.islice(iter(ra100), 10, 10, 1)) == []
    assert list(itertools.islice(iter(ra100), 10, 3, 1)) == []
    # stop=len(iterable)
    assert list(itertools.islice(iter(ra), 0, 10, 1)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    assert list(itertools.islice(iter(ra), 2, 10, 1)) == [2, 3, 4, 5, 6, 7, 8, 9]
    assert list(itertools.islice(iter(ra), 1, 10, 2)) == [1, 3, 5, 7, 9]
    try:
        list(itertools.islice(iter(ra), -5, 10, 1))
        assert False
    except ValueError:
        pass


</t>
<t tx="ekr.20230509052845.494">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;vector&gt;

namespace codon {
namespace ir {
namespace util {

/// Base for CIR visitor contexts.
template &lt;typename Frame&gt; class CIRContext {
private:
  std::vector&lt;Frame&gt; frames;

public:
  /// Emplaces a frame onto the stack.
  /// @param args a parameter pack of the arguments
  template &lt;typename... Args&gt; void emplaceFrame(Args... args) {
    frames.emplace_back(args...);
  }
@others
  /// @return all frames
  std::vector&lt;Frame&gt; &amp;getFrames() { return frames; }
  /// @return the current frame
  Frame &amp;getFrame() { return frames.back(); }
  /// Pops a frame.
  void popFrame() { return frames.pop_back(); }
};

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4940">@test
def test_count():
    # infinite loop here
    assert take(3, itertools.count(3.25, 1.0)) == [3.25, 4.25, 5.25]
    assert take(3, zip("abc", itertools.count(3.25, 1.0))) == [
        ("a", 3.25),
        ("b", 4.25),
        ("c", 5.25),
    ]
    assert take(2, zip("abc", itertools.count(-1.0, 1.0))) == [("a", -1.0), ("b", 0.0)]
    assert take(2, zip("abc", itertools.count(-3.0, 1.0))) == [("a", -3.0), ("b", -2.0)]


</t>
<t tx="ekr.20230509052845.4941">@test
def test_repeat():
    assert list(itertools.repeat("a", 3)) == ["a", "a", "a"]
    assert list(itertools.repeat(1, 10)) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    assert list(itertools.repeat("a", -1)) == []
    assert len(list(itertools.repeat("a", 0))) == 0


</t>
<t tx="ekr.20230509052845.4942">@test
def test_cycle():
    assert take(10, zip("zzzzzzzzzzz", itertools.cycle(iter("abc")))) == [
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
    ]
    assert take(10, zip("zzzzzzzzzzz", itertools.cycle(["a", "b"]))) == [
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
    ]


</t>
<t tx="ekr.20230509052845.4943">@test
def test_compress():
    assert list(itertools.compress("ABCDEF", [1, 0, 1, 0, 1, 1])) == [
        "A",
        "C",
        "E",
        "F",
    ]
    assert list(itertools.compress("ABCDEF", [1, 1, 1, 1, 1, 1])) == [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
    ]
    assert list(itertools.compress("ABCDEF", [1, 0, 1])) == ["A", "C"]
    assert list(itertools.compress("ABC", [0, 1, 1, 1, 1, 1])) == ["B", "C"]


</t>
<t tx="ekr.20230509052845.4944">@test
def test_dropwhile():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(itertools.dropwhile(underten, data)) == [20, 2, 4, 6, 8]


</t>
<t tx="ekr.20230509052845.4945">@test
def test_takewhile():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(itertools.takewhile(underten, data)) == [1, 3, 5]


</t>
<t tx="ekr.20230509052845.4946">@test
def test_filterfalse():
    assert list(itertools.filterfalse(isEven, range(10))) == [1, 3, 5, 7, 9]
    assert list(itertools.filterfalse(lambda x: bool(x), [0, 1, 0, 2, 0])) == [0, 0, 0]


</t>
<t tx="ekr.20230509052845.4947">@test
def test_permutations():
    assert list(itertools.permutations(range(3), 2)) == [
        [0, 1],
        [0, 2],
        [1, 0],
        [1, 2],
        [2, 0],
        [2, 1],
    ]

    for n in range(3):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(itertools.permutations(values, r))
            if r &gt; n:  # right number of perms
                assert len(result) == 0
            # factorial is not yet implemented in math
            # else: fact(n) / fact(n - r)


</t>
<t tx="ekr.20230509052845.4948">@test
def test_accumulate():
    # addition
    assert list(itertools.accumulate(range(10), int.__add__, initial=0)) == [
        0,
        0,
        1,
        3,
        6,
        10,
        15,
        21,
        28,
        36,
        45,
    ]
    assert list(itertools.accumulate([7], int.__add__, initial=0)) == [
        0,
        7,
    ]  # iterable of length 1
    assert list(itertools.accumulate(range(10), int.__add__)) == [
        0,
        1,
        3,
        6,
        10,
        15,
        21,
        28,
        36,
        45,
    ]
    assert list(itertools.accumulate([7], int.__add__)) == [7]  # iterable of length 1
    assert list(itertools.accumulate("abc", str.__add__, initial="")) == [
        "",
        "a",
        "ab",
        "abc",
    ]
    assert list(itertools.accumulate([""], str.__add__, initial=str(0))) == ["0", "0"]
    # multiply
    assert list(itertools.accumulate(range(10), int.__mul__, initial=0)) == [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ]
    assert list(itertools.accumulate([1, 2, 3, 4, 5], int.__mul__, initial=1)) == [
        1,
        1,
        2,
        6,
        24,
        120,
    ]
    assert list(itertools.accumulate([7], int.__mul__)) == [7]
    # pass


</t>
<t tx="ekr.20230509052845.4949">@test
def test_chain():
    assert list(itertools.chain("abc", "def")) == ["a", "b", "c", "d", "e", "f"]
    assert list(itertools.chain("abc")) == ["a", "b", "c"]
    assert list(itertools.chain("a", "b", "c")) == ["a", "b", "c"]
    assert list(itertools.chain(["abc", "def"])) == ["abc", "def"]
    assert list(itertools.chain(["abc"])) == ["abc"]
    assert list(itertools.chain(["a", "b", "c"])) == ["a", "b", "c"]


</t>
<t tx="ekr.20230509052845.495">  /// Replaces a frame.
  /// @param newFrame the new frame
  void replaceFrame(Frame newFrame) {
    frames.pop_back();
    frames.push_back(newFrame);
  }
</t>
<t tx="ekr.20230509052845.4950">@test
def test_starmap():
    assert list(itertools.starmap(math.pow, [(2.0, 5.0), (3.0, 2.0), (10.0, 3.0)])) == [
        32.0,
        9.0,
        1000.0,
    ]
    assert list(itertools.starmap(math.pow, [(0.0, 1.0), (1.0, 2.0), (2.0, 3.0)])) == [
        0.0 ** 1.0,
        1.0 ** 2.0,
        2.0 ** 3.0,
    ]


</t>
<t tx="ekr.20230509052845.4951">@test
def test_groupby():
    @others
    assert list(itertools.groupby(iter("AAAABBBCCDAABBC"), key_str)) == [
        ("A", ["A", "A", "A", "A"]),
        ("B", ["B", "B", "B"]),
        ("C", ["C", "C"]),
        ("D", ["D"]),
        ("A", ["A", "A"]),
        ("B", ["B", "B"]),
        ("C", ["C"]),
    ]


</t>
<t tx="ekr.20230509052845.4952">def key_str(s: str):
    return s

</t>
<t tx="ekr.20230509052845.4953">@test
def test_zip_longest():
    assert list(itertools.zip_longest("ABCDE", "12345", fillvalue="-")) == [
        ("A", "1"),
        ("B", "2"),
        ("C", "3"),
        ("D", "4"),
        ("E", "5"),
    ]
    assert list(itertools.zip_longest("ABCDE", "123", fillvalue="-")) == [
        ("A", "1"),
        ("B", "2"),
        ("C", "3"),
        ("D", "-"),
        ("E", "-"),
    ]
    assert list(itertools.zip_longest("123", "ABCDE", fillvalue="-")) == [
        ("1", "A"),
        ("2", "B"),
        ("3", "C"),
        ("-", "D"),
        ("-", "E"),
    ]
    assert list(itertools.zip_longest("", "ABCDE", fillvalue="-")) == [
        ("-", "A"),
        ("-", "B"),
        ("-", "C"),
        ("-", "D"),
        ("-", "E"),
    ]
    assert list(itertools.zip_longest("ABCDE", "", fillvalue="-")) == [
        ("A", "-"),
        ("B", "-"),
        ("C", "-"),
        ("D", "-"),
        ("E", "-"),
    ]
    assert not list(itertools.zip_longest("", "", fillvalue="-"))


</t>
<t tx="ekr.20230509052845.4954">@test
def test_zip_test():
    assert list(zip()) == []
    assert list(zip((1, 2))) == [(1,), (2,)]
    assert list(zip([1, 2], ["a", "b"], (False, True))) == [
        (1, "a", False),
        (2, "b", True),
    ]


</t>
<t tx="ekr.20230509052845.4955">test_combinations()
test_combinations_with_replacement()
test_islice()
test_count()
test_repeat()
test_cycle()
test_compress()
test_dropwhile()
test_takewhile()
test_filterfalse()
test_permutations()
test_accumulate()
test_chain()
test_starmap()
test_groupby()
test_zip_longest()
test_zip_test()


# Updated tests lifted from CPython test suite


</t>
<t tx="ekr.20230509052845.4956">@test
def test_accumulate_from_cpython():
    assert list(accumulate(range(10))) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
    assert list(accumulate(iterable=range(10))) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
    assert list(accumulate("abc")) == ["a", "ab", "abc"]
    assert list(accumulate(List[float]())) == []
    assert list(accumulate([7])) == [7]

    s = [2, 8, 9, 5, 7, 0, 3, 4, 1, 6]
    assert list(accumulate(s, min)) == [2, 2, 2, 2, 2, 0, 0, 0, 0, 0]
    assert list(accumulate(s, max)) == [2, 8, 9, 9, 9, 9, 9, 9, 9, 9]
    mul = lambda a, b: a * b
    assert list(accumulate(s, mul)) == [2, 16, 144, 720, 5040, 0, 0, 0, 0, 0]

    # assert list(accumulate([10, 5, 1], initial=None)) == [10, 15, 16]
    assert list(accumulate([10, 5, 1], initial=100)) == [100, 110, 115, 116]
    assert list(accumulate([10, 5, 1], initial=100.5)) == [100.5, 110.5, 115.5, 116.5]
    assert list(accumulate(List[int](), initial=100)) == [100]


</t>
<t tx="ekr.20230509052845.4957">test_accumulate_from_cpython()


</t>
<t tx="ekr.20230509052845.4958">@test
def test_chain_from_cpython():
    assert list(chain("abc", "def")) == list("abcdef")
    assert list(chain("abc")) == list("abc")
    assert list(chain("")) == []
    assert list(take(4, chain("abc", "def"))) == list("abcd")


</t>
<t tx="ekr.20230509052845.4959">test_chain_from_cpython()


</t>
<t tx="ekr.20230509052845.496">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Formats an IR node.
/// @param node the node
/// @return the formatted node
std::string format(const Node *node);

/// Formats an IR node to an IO stream.
/// @param os the output stream
/// @param node the node
/// @return the resulting output stream
std::ostream &amp;format(std::ostream &amp;os, const Node *node);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4960">@test
def test_chain_from_iterable_from_cpython():
    assert list(chain.from_iterable(["abc", "def"])) == list("abcdef")
    assert list(chain.from_iterable(["abc"])) == list("abc")
    assert list(chain.from_iterable([""])) == []
    assert take(4, chain.from_iterable(["abc", "def"])) == list("abcd")


</t>
<t tx="ekr.20230509052845.4961">test_chain_from_iterable_from_cpython()


</t>
<t tx="ekr.20230509052845.4962">@test
def test_combinations_from_cpython():
    from math import factorial as fact

    err = False
    try:
        list(combinations("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(combinations("abc", 32)) == []  # r &gt; n
    assert list(combinations("ABCD", 2)) == [
        ["A", "B"],
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    assert list(combinations(range(4), 3)) == [
        [0, 1, 2],
        [0, 1, 3],
        [0, 2, 3],
        [1, 2, 3],
    ]

    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(combinations(values, r))

            assert len(result) == (0 if r &gt; n else fact(n) // fact(r) // fact(n - r))
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                     # lexicographic order
            for c in result:
                assert len(c) == r  # r-length combinations
                assert len(set(c)) == r  # no duplicate elements
                assert list(c) == sorted(c)  # keep original ordering
                assert all(e in values for e in c)  # elements taken from input iterable
                assert list(c) == [
                    e for e in values if e in c
                ]  # comb is a subsequence of the input iterable


</t>
<t tx="ekr.20230509052845.4963">test_combinations_from_cpython()


</t>
<t tx="ekr.20230509052845.4964">@test
def test_combinations_with_replacement_from_cpython():
    cwr = combinations_with_replacement
    err = False
    try:
        list(cwr("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(cwr("ABC", 2)) == [
        ["A", "A"],
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]

    @others
    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(cwr(values, r))
            regular_combs = list(combinations(values, r))

            assert len(result) == numcombs(n, r)
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                     # lexicographic order

            if n == 0 or r &lt;= 1:
                assert result == regular_combs  # cases that should be identical
            else:
                assert set(result) &gt;= set(regular_combs)

            for c in result:
                assert len(c) == r  # r-length combinations
                noruns = [k for k, v in groupby(c)]  # combo without consecutive repeats
                assert len(noruns) == len(
                    set(noruns)
                )  # no repeats other than consecutive
                assert list(c) == sorted(c)  # keep original ordering
                assert all(e in values for e in c)  # elements taken from input iterable
                assert noruns == [
                    e for e in values if e in c
                ]  # comb is a subsequence of the input iterable


</t>
<t tx="ekr.20230509052845.4965">def numcombs(n, r):
    from math import factorial as fact

    if not n:
        return 0 if r else 1
    return fact(n + r - 1) // fact(r) // fact(n - 1)

</t>
<t tx="ekr.20230509052845.4966">test_combinations_with_replacement_from_cpython()


</t>
<t tx="ekr.20230509052845.4967">@test
def test_permutations_from_cpython():
    from math import factorial as fact

    err = False
    try:
        list(permutations("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(permutations("abc", 32)) == []
    assert list(permutations(range(3), 2)) == [
        [0, 1],
        [0, 2],
        [1, 0],
        [1, 2],
        [2, 0],
        [2, 1],
    ]

    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(permutations(values, r))
            assert len(result) == (
                0 if r &gt; n else fact(n) // fact(n - r)
            )  # right number of perms
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                # lexicographic order
            for p in result:
                assert len(p) == r  # r-length permutations
                assert len(set(p)) == r  # no duplicate elements
                assert all(e in values for e in p)  # elements taken from input iterable

            if r == n:
                assert result == list(permutations(values, None))  # test r as None
                assert result == list(permutations(values))  # test default r


</t>
<t tx="ekr.20230509052845.4968">test_permutations_from_cpython()


</t>
<t tx="ekr.20230509052845.4969">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.497">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Result of an inlining operation.
struct InlineResult {
  /// the result, either a SeriesFlow or FlowInstr
  Value *result;
  /// variables added by the inlining
  std::vector&lt;Var *&gt; newVars;

  operator bool() const { return bool(result); }
};

/// Inline the given function with the supplied arguments.
/// @param func the function
/// @param args the arguments
/// @param callInfo the call information
/// @param aggressive true if should inline complex functions
/// @return the inlined result, nullptr if unsuccessful
InlineResult inlineFunction(Func *func, std::vector&lt;Value *&gt; args,
                            bool aggressive = false, codon::SrcInfo callInfo = {});

/// Inline the given call.
/// @param v the instruction
/// @param aggressive true if should inline complex functions
/// @return the inlined result, nullptr if unsuccessful
InlineResult inlineCall(CallInstr *v, bool aggressive = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4970">def __lt__(self, other: List[T]):
    if len(self) != len(other):
        return len(self) &lt; len(other)
    for a, b in zip(self, other):
        if a &lt; b:
            return True
        if a &gt; b:
            return False
    return False

</t>
<t tx="ekr.20230509052845.4971">def __le__(self, other: List[T]):
    if len(self) != len(other):
        return len(self) &lt; len(other)
    for a, b in zip(self, other):
        if a &lt; b:
            return True
        if a &gt; b:
            return False
    return True

</t>
<t tx="ekr.20230509052845.4972">def __gt__(self, other: List[T]):
    if len(self) != len(other):
        return len(self) &lt; len(other)
    for a, b in zip(self, other):
        if a &gt; b:
            return True
        if a &lt; b:
            return False
    return False

</t>
<t tx="ekr.20230509052845.4973">def __ge__(self, other: List[T]):
    if len(self) != len(other):
        return len(self) &lt; len(other)
    for a, b in zip(self, other):
        if a &gt; b:
            return True
        if a &lt; b:
            return False
    return True


</t>
<t tx="ekr.20230509052845.4974">@test
def test_combinatorics_from_cpython():
    # Test relationships between product(), permutations(),
    # combinations() and combinations_with_replacement().
    from math import factorial as fact

    for n in range(6):
        s = "ABCDEFG"[:n]
        for r in range(8):
            prod = list(product(s, repeat=r))
            cwr = list(combinations_with_replacement(s, r))
            perm = list(permutations(s, r))
            comb = list(combinations(s, r))

            # Check size
            assert len(prod) == n ** r
            assert len(cwr) == (
                (fact(n + r - 1) // fact(r) // fact(n - 1)) if n else (0 if r else 1)
            )
            assert len(perm) == (0 if r &gt; n else fact(n) // fact(n - r))
            assert len(comb) == (0 if r &gt; n else fact(n) // fact(r) // fact(n - r))

            # Check lexicographic order without repeated tuples
            assert prod == sorted(set(prod))
            assert cwr == sorted(set(cwr))
            assert perm == sorted(set(perm))
            assert comb == sorted(set(comb))

            # Check interrelationships
            assert cwr == [
                t for t in prod if sorted(t) == list(t)
            ]  # cwr: prods which are sorted
            assert perm == [
                t for t in prod if len(set(t)) == r
            ]  # perm: prods with no dups
            assert comb == [
                t for t in perm if sorted(t) == list(t)
            ]  # comb: perms that are sorted
            assert comb == [
                t for t in cwr if len(set(t)) == r
            ]  # comb: cwrs without dups
            assert comb == list(
                filter(set(cwr).__contains__, perm)
            )  # comb: perm that is a cwr
            assert comb == list(
                filter(set(perm).__contains__, cwr)
            )  # comb: cwr that is a perm
            assert comb == sorted(set(cwr) &amp; set(perm))  # comb: both a cwr and a perm


</t>
<t tx="ekr.20230509052845.4975">test_combinatorics_from_cpython()


</t>
<t tx="ekr.20230509052845.4976">@test
def test_compress_from_cpython():
    assert list(compress(data="ABCDEF", selectors=[1, 0, 1, 0, 1, 1])) == list("ACEF")
    assert list(compress("ABCDEF", [1, 0, 1, 0, 1, 1])) == list("ACEF")
    assert list(compress("ABCDEF", [0, 0, 0, 0, 0, 0])) == list("")
    assert list(compress("ABCDEF", [1, 1, 1, 1, 1, 1])) == list("ABCDEF")
    assert list(compress("ABCDEF", [1, 0, 1])) == list("AC")
    assert list(compress("ABC", [0, 1, 1, 1, 1, 1])) == list("BC")
    n = 10000
    data = chain.from_iterable(repeat(range(6), n))
    selectors = chain.from_iterable(repeat((0, 1)))
    assert list(compress(data, selectors)) == [1, 3, 5] * n


</t>
<t tx="ekr.20230509052845.4977">test_compress_from_cpython()


</t>
<t tx="ekr.20230509052845.4978">@test
def test_count_from_cpython():
    assert lzip("abc", count()) == [("a", 0), ("b", 1), ("c", 2)]
    assert lzip("abc", count(3)) == [("a", 3), ("b", 4), ("c", 5)]
    assert take(2, lzip("abc", count(3))) == [("a", 3), ("b", 4)]
    assert take(2, zip("abc", count(-1))) == [("a", -1), ("b", 0)]
    assert take(2, zip("abc", count(-3))) == [("a", -3), ("b", -2)]
    assert take(3, count(3.25)) == [3.25, 4.25, 5.25]


</t>
<t tx="ekr.20230509052845.4979">test_count_from_cpython()


</t>
<t tx="ekr.20230509052845.498">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Checks whether a function has a given attribute.
/// @param func the function
/// @param attribute the attribute name
/// @return true if the function has the given attribute
bool hasAttribute(const Func *func, const std::string &amp;attribute);

/// Checks whether a function comes from the standard library, and
/// optionally a specific module therein.
/// @param func the function
/// @param submodule module name (e.g. "std::bio"), or empty if
///                  no module check is required
/// @return true if the function is from the standard library in
///         the given module
bool isStdlibFunc(const Func *func, const std::string &amp;submodule = "");

/// Calls a function.
/// @param func the function
/// @param args vector of call arguments
/// @return call instruction with the given function and arguments
CallInstr *call(Func *func, const std::vector&lt;Value *&gt; &amp;args);

/// Checks if a value represents a call of a particular function.
/// @param value the value to check
/// @param name the function's (unmangled) name
/// @param inputs vector of input types
/// @param output output type, null for no check
/// @param method true to ensure this call is a method call
/// @return true if value is a call matching all parameters above
bool isCallOf(const Value *value, const std::string &amp;name,
              const std::vector&lt;types::Type *&gt; &amp;inputs, types::Type *output = nullptr,
              bool method = false);

/// Checks if a value represents a call of a particular function.
/// @param value the value to check
/// @param name the function's (unmangled) name
/// @param numArgs argument count, negative for no check
/// @param output output type, null for no check
/// @param method true to ensure this call is a method call
/// @return true if value is a call matching all parameters above
bool isCallOf(const Value *value, const std::string &amp;name, int numArgs = -1,
              types::Type *output = nullptr, bool method = false);

/// Checks if a value represents a call to a magic method.
/// Magic method names start and end in "__" (two underscores).
/// @param value the value to check
/// @return true if value is a magic method call
bool isMagicMethodCall(const Value *value);

/// Constructs a new tuple.
/// @param args vector of tuple contents
/// @param M the module; inferred from elements if null
/// @return value represents a tuple with the given contents
Value *makeTuple(const std::vector&lt;Value *&gt; &amp;args, Module *M = nullptr);

/// Constructs and assigns a new variable.
/// @param x the value to assign to the new variable
/// @param flow series flow in which to assign the new variable
/// @param parent function to add the new variable to, or null for global variable
/// @param prepend true to insert assignment at start of block
/// @return value containing the new variable
VarValue *makeVar(Value *x, SeriesFlow *flow, BodiedFunc *parent, bool prepend = false);

/// Dynamically allocates memory for the given type with the given
/// number of elements.
/// @param type the type
/// @param count integer value representing the number of elements
/// @return value representing a pointer to the allocated memory
Value *alloc(types::Type *type, Value *count);

/// Dynamically allocates memory for the given type with the given
/// number of elements.
/// @param type the type
/// @param count the number of elements
/// @return value representing a pointer to the allocated memory
Value *alloc(types::Type *type, int64_t count);

/// Builds a new series flow with the given contents. Returns
/// null if no contents are provided.
/// @param args contents of the series flow
/// @return new series flow
template &lt;typename... Args&gt; SeriesFlow *series(Args... args) {
  std::vector&lt;Value *&gt; vals = {args...};
  if (vals.empty())
    return nullptr;
  auto *series = vals[0]-&gt;getModule()-&gt;Nr&lt;SeriesFlow&gt;();
  for (auto *val : vals) {
    series-&gt;push_back(val);
  }
  return series;
}

/// Checks whether the given value is a constant of the given
/// type. Note that standard "int" corresponds to the C type
/// "int64_t", which should be used here.
/// @param x the value to check
/// @return true if the value is constant
template &lt;typename T&gt; bool isConst(const Value *x) { return isA&lt;TemplatedConst&lt;T&gt;&gt;(x); }

/// Checks whether the given value is a constant of the given
/// type, and that is has a particular value. Note that standard
/// "int" corresponds to the C type "int64_t", which should be used here.
/// @param x the value to check
/// @param value constant value to compare to
/// @return true if the value is constant with the given value
template &lt;typename T&gt; bool isConst(const Value *x, const T &amp;value) {
  if (auto *c = cast&lt;TemplatedConst&lt;T&gt;&gt;(x)) {
    return c-&gt;getVal() == value;
  }
  return false;
}

/// Returns the constant represented by a given value. Raises an assertion
/// error if the given value is not constant. Note that standard
/// "int" corresponds to the C type "int64_t", which should be used here.
/// @param x the (constant) value
/// @return the constant represented by the given value
template &lt;typename T&gt; T getConst(const Value *x) {
  auto *c = cast&lt;TemplatedConst&lt;T&gt;&gt;(x);
  seqassertn(c, "{} is not a constant [{}]", *x, x-&gt;getSrcInfo());
  return c-&gt;getVal();
}

/// Gets a variable from a value.
/// @param x the value
/// @return the variable represented by the given value, or null if none
Var *getVar(Value *x);

/// Gets a variable from a value.
/// @param x the value
/// @return the variable represented by the given value, or null if none
const Var *getVar(const Value *x);

/// Gets a function from a value.
/// @param x the value
/// @return the function represented by the given value, or null if none
Func *getFunc(Value *x);

/// Gets a function from a value.
/// @param x the value
/// @return the function represented by the given value, or null if none
const Func *getFunc(const Value *x);

/// Loads value from a pointer.
/// @param ptr the pointer
/// @return the value pointed to by the argument
Value *ptrLoad(Value *ptr);

/// Stores a value into a pointer.
/// @param ptr the pointer
/// @param val the value to store
/// @return "__setitem__" call representing the store
Value *ptrStore(Value *ptr, Value *val);

/// Gets value from a tuple at the given index.
/// @param tuple the tuple
/// @param index the 0-based index
/// @return tuple element at the given index
Value *tupleGet(Value *tuple, unsigned index);

/// Stores value in a tuple at the given index. Since tuples are immutable,
/// a new instance is returned with the appropriate element replaced.
/// @param tuple the tuple
/// @param index the 0-based index
/// @param val the value to store
/// @return new tuple instance with the given value inserted
Value *tupleStore(Value *tuple, unsigned index, Value *val);

/// Gets a bodied standard library function from a value.
/// @param x the value
/// @param name name of the function
/// @param submodule optional module to check
/// @return the standard library function (with the given name, from the given
/// submodule) represented by the given value, or null if none
BodiedFunc *getStdlibFunc(Value *x, const std::string &amp;name,
                          const std::string &amp;submodule = "");

/// Gets a bodied standard library function from a value.
/// @param x the value
/// @param name name of the function
/// @param submodule optional module to check
/// @return the standard library function (with the given name, from the given
/// submodule) represented by the given value, or null if none
const BodiedFunc *getStdlibFunc(const Value *x, const std::string &amp;name,
                                const std::string &amp;submodule = "");

/// Gets the return type of a function.
/// @param func the function
/// @return the return type of the given function
types::Type *getReturnType(const Func *func);

/// Sets the return type of a function. Argument types remain unchanged.
/// @param func the function
/// @param rType the new return type
void setReturnType(Func *func, types::Type *rType);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4980">@test
def test_count_with_stride_from_cpython():
    assert lzip("abc", count(2, 3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert lzip("abc", count(start=2, step=3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert lzip("abc", count(step=-1)) == [("a", 0), ("b", -1), ("c", -2)]
    assert lzip("abc", count(2, 0)) == [("a", 2), ("b", 2), ("c", 2)]
    assert lzip("abc", count(2, 1)) == [("a", 2), ("b", 3), ("c", 4)]
    assert lzip("abc", count(2, 3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert take(3, count(2.0, 1.25)) == [2.0, 3.25, 4.5]


</t>
<t tx="ekr.20230509052845.4981">test_count_with_stride_from_cpython()


</t>
<t tx="ekr.20230509052845.4982">@test
def test_cycle_from_cpython():
    assert take(10, cycle("abc")) == list("abcabcabca")
    assert list(cycle("")) == []
    assert list(islice(cycle(gen3()), 10)) == [0, 1, 2, 0, 1, 2, 0, 1, 2, 0]


</t>
<t tx="ekr.20230509052845.4983">test_cycle_from_cpython()


</t>
<t tx="ekr.20230509052845.4984">@test
def test_groupby_from_cpython():
    # Check whether it accepts arguments correctly
    assert [] == list(groupby(List[int]()))
    assert [] == list(groupby(List[int](), key=lambda a: a))
    # Check normal input
    if 1:
        s = [
            (0, 10, 20),
            (0, 11, 21),
            (0, 12, 21),
            (1, 13, 21),
            (1, 14, 22),
            (2, 15, 22),
            (3, 16, 23),
            (3, 17, 23),
        ]

        if 1:
            dup = []
            for k, g in groupby(s, lambda r: r[0]):
                for elem in g:
                    assert k == elem[0]
                    dup.append(elem)
            assert s == dup

        # Check nested case
        if 1:
            dup = []
            for k, g in groupby(s, testR):
                for ik, ig in groupby(g, testR2):
                    for elem in ig:
                        assert k == elem[0]
                        assert ik == elem[2]
                        dup.append(elem)
            assert s == dup

        # Check case where inner iterator is not used
        keys = [k for k, g in groupby(s, testR)]
        expectedkeys = set([r[0] for r in s])
        assert set(keys) == expectedkeys
        assert len(keys) == len(expectedkeys)

    if 1:
        # Exercise pipes and filters style
        s = "abracadabra"
        if 1:
            # sort s | uniq
            r = [k for k, g in groupby(sorted(s))]
            assert r == ["a", "b", "c", "d", "r"]
        if 1:
            # sort s | uniq -d
            r = [k for k, g in groupby(sorted(s)) if list(islice(g, 1, 2))]
            assert r == ["a", "b", "r"]
        if 1:
            # sort s | uniq -c
            r = [(len(list(g)), k) for k, g in groupby(sorted(s))]
            assert r == [(5, "a"), (2, "b"), (1, "c"), (1, "d"), (2, "r")]
        if 1:
            # sort s | uniq -c | sort -rn | head -3
            r = sorted(
                [(len(list(g)), k) for k, g in groupby(sorted(s))], reverse=True
            )[:3]
            assert r == [(5, "a"), (2, "r"), (2, "b")]


</t>
<t tx="ekr.20230509052845.4985">test_groupby_from_cpython()


</t>
<t tx="ekr.20230509052845.4986">@test
def test_filter_from_cpython():
    assert list(filter(isEven, range(6))) == [0, 2, 4]
    # assert list(filter(None, [0,1,0,2,0])) == [1,2]  # TODO
    assert list(filter(lambda x: bool(x), [0, 1, 0, 2, 0])) == [1, 2]
    assert take(4, filter(isEven, count())) == [0, 2, 4, 6]


</t>
<t tx="ekr.20230509052845.4987">test_filter_from_cpython()


</t>
<t tx="ekr.20230509052845.4988">@test
def test_filterfalse_from_cpython():
    assert list(filterfalse(isEven, range(6))) == [1, 3, 5]
    # assert list(filter(None, [0,1,0,2,0])) == [0,0,0]  # TODO
    assert list(filterfalse(lambda x: bool(x), [0, 1, 0, 2, 0])) == [0, 0, 0]
    assert take(4, filterfalse(isEven, count())) == [1, 3, 5, 7]


</t>
<t tx="ekr.20230509052845.4989">test_filterfalse_from_cpython()


</t>
<t tx="ekr.20230509052845.499">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iterator&gt;
#include &lt;memory&gt;
#include &lt;type_traits&gt;

namespace codon {
namespace ir {
namespace util {

@others
/// Creates an adaptor that dereferences values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto dereference_adaptor(It it) {
  auto f = [](const auto &amp;v) -&gt; auto &amp; { return *v; };
  auto m = [](const auto &amp;v) -&gt; auto{ return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the address of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto raw_ptr_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; auto * { return v.get(); };
  auto m = [](auto &amp;v) -&gt; auto * { return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the const address of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto const_raw_ptr_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; const auto * { return v.get(); };
  auto m = [](auto &amp;v) -&gt; const auto * { return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the keys of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto map_key_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; auto &amp; { return v.first; };
  auto m = [](auto &amp;v) -&gt; auto &amp; { return v.first; };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the const keys of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto const_map_key_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; const auto &amp; { return v.first; };
  auto m = [](auto &amp;v) -&gt; const auto &amp; { return v.first; };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.4990">@test
def test_zip_from_cpython():
    ans = [(x, y) for x, y in zip("abc", count())]
    assert ans == [("a", 0), ("b", 1), ("c", 2)]
    assert list(zip("abc", range(6))) == lzip("abc", range(6))
    assert list(zip("abcdef", range(3))) == lzip("abcdef", range(3))
    assert take(3, zip("abcdef", count())) == lzip("abcdef", range(3))
    assert list(zip("abcdef")) == lzip("abcdef")
    assert list(zip()) == lzip()
    assert [pair for pair in zip("abc", "def")] == lzip("abc", "def")


</t>
<t tx="ekr.20230509052845.4991">test_zip_from_cpython()


</t>
<t tx="ekr.20230509052845.4992">@test
def test_ziplongest_from_cpython():
    for args in (
        (range(1000), range(2000, 2100), range(3000, 3050)),
        (range(1000), range(0), range(3000, 3050), range(1200), range(1500)),
        (range(1000), range(0), range(3000, 3050), range(1200), range(1500), range(0)),
    ):
        target = [
            tuple(arg[i] if i &lt; len(arg) else None for arg in args)
            for i in range(max(map(len, args)))
        ]
        assert str(list(zip_longest(*args))) == str(target)
        target2 = [
            [(-999 if e is None else e.__val__()) for e in t] for t in target
        ]  # Replace None fills with 'X'
        assert list(zip_longest(*args, fillvalue=-999)) == target2

    assert (
        str(list(zip_longest("abc", range(6))))
        == "[('a', 0), ('b', 1), ('c', 2), (None, 3), (None, 4), (None, 5)]"
    )
    assert (
        str(list(zip_longest(range(6), "abc")))
        == "[(0, 'a'), (1, 'b'), (2, 'c'), (3, None), (4, None), (5, None)]"
    )


</t>
<t tx="ekr.20230509052845.4993">test_ziplongest_from_cpython()


</t>
<t tx="ekr.20230509052845.4994">@test
def test_product_from_cpython():
    for args, result in (
        # ((), [()]),                     # zero iterables  # TODO
        (("ab",), [("a",), ("b",)]),  # one iterable
        (
            (range(2), range(3)),
            [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)],
        ),  # two iterables
        (
            (range(0), range(2), range(3)),
            List[Tuple[int, int, int]](),
        ),  # first iterable with zero length
        (
            (range(2), range(0), range(3)),
            List[Tuple[int, int, int]](),
        ),  # middle iterable with zero length
        (
            (range(2), range(3), range(0)),
            List[Tuple[int, int, int]](),
        ),  # last iterable with zero length
    ):
        assert list(product(*args)) == result

    assert (
        len(list(product(range(7), range(7), range(7), range(7), range(7), range(7))))
        == 7 ** 6
    )


</t>
<t tx="ekr.20230509052845.4995">test_product_from_cpython()


</t>
<t tx="ekr.20230509052845.4996">@test
def test_repeat_from_cpython():
    assert list(repeat(object="a", times=3)) == ["a", "a", "a"]
    assert lzip(range(3), repeat("a")) == [(0, "a"), (1, "a"), (2, "a")]
    assert list(repeat("a", 3)) == ["a", "a", "a"]
    assert take(3, repeat("a")) == ["a", "a", "a"]
    assert list(repeat("a", 0)) == []
    assert list(repeat("a", -3)) == []


</t>
<t tx="ekr.20230509052845.4997">test_repeat_from_cpython()


</t>
<t tx="ekr.20230509052845.4998">@test
def test_map_from_cpython():
    power = lambda a, b: a ** b
    assert list(map(power, range(3), range(1, 7))) == [0 ** 1, 1 ** 2, 2 ** 3]
    assert list(map(tupleize, "abc", range(5))) == [("a", 0), ("b", 1), ("c", 2)]
    assert list(map(tupleize, "abc", count())) == [("a", 0), ("b", 1), ("c", 2)]
    assert take(2, map(tupleize, "abc", count())) == [("a", 0), ("b", 1)]
    assert list(map(tupleize, List[int]())) == []


</t>
<t tx="ekr.20230509052845.4999">test_map_from_cpython()


</t>
<t tx="ekr.20230509052845.5">class Node:
    left: Optional[Node] = None
    right: Optional[Node] = None

</t>
<t tx="ekr.20230509052845.50">def __mul__(self, other):
    v = GVector(self.x * other, self.y * other, self.z * other)
    return v
</t>
<t tx="ekr.20230509052845.500">/// Iterator wrapper that applies a function to the iterator.
template &lt;typename It, typename DereferenceFunc, typename MemberFunc&gt;
struct function_iterator_adaptor {
  It internal;
  DereferenceFunc d;
  MemberFunc m;

  using iterator_category = std::input_iterator_tag;
  using value_type = typename std::remove_reference&lt;decltype(d(*internal))&gt;::type;
  using reference = void;
  using pointer = void;
  using difference_type = typename std::iterator_traits&lt;It&gt;::difference_type;

  /// Constructs an adaptor.
  /// @param internal the internal iterator
  /// @param d the dereference function
  /// @param m the member access function
  function_iterator_adaptor(It internal, DereferenceFunc &amp;&amp;d, MemberFunc &amp;&amp;m)
      : internal(std::move(internal)), d(std::move(d)), m(std::move(m)) {}

  decltype(auto) operator*() { return d(*internal); }
  decltype(auto) operator-&gt;() { return m(*internal); }

  function_iterator_adaptor &amp;operator++() {
    internal++;
    return *this;
  }
  function_iterator_adaptor operator++(int) {
    function_iterator_adaptor&lt;It, DereferenceFunc, MemberFunc&gt; copy(*this);
    internal++;
    return copy;
  }

  @others
};

</t>
<t tx="ekr.20230509052845.5000">@test
def test_starmap_from_cpython():
    power = lambda a, b: a ** b
    assert list(starmap(power, zip(range(3), range(1, 7)))) == [0 ** 1, 1 ** 2, 2 ** 3]
    assert take(3, starmap(power, zip(count(), count(1)))) == [0 ** 1, 1 ** 2, 2 ** 3]
    # assert list(starmap(tupleize, List[int]())) == []  # TODO
    assert list(starmap(power, [(4, 5)])) == [4 ** 5]


</t>
<t tx="ekr.20230509052845.5001">test_starmap_from_cpython()


</t>
<t tx="ekr.20230509052845.5002">@test
def test_islice_from_cpython():
    for args in (  # islice(args) should agree with range(args)
        (10, 20, 3),
        (10, 3, 20),
        (10, 20),
        (10, 10),
        (10, 3),
        (20,),
    ):
        assert list(islice(range(100), *args)) == list(range(*args))

    for args, tgtargs in (  # Stop when seqn is exhausted
        ((10, 110, 3), ((10, 100, 3))),
        ((10, 110), ((10, 100))),
        ((110,), (100,)),
    ):
        assert list(islice(range(100), *args)) == list(range(*tgtargs))

    # Test stop=None
    assert list(islice(range(10), None)) == list(range(10))
    assert list(islice(range(10), None, None)) == list(range(10))
    assert list(islice(range(10), None, None, None)) == list(range(10))
    assert list(islice(range(10), 2, None)) == list(range(2, 10))
    assert list(islice(range(10), 1, None, 2)) == list(range(1, 10, 2))


</t>
<t tx="ekr.20230509052845.5003">test_islice_from_cpython()


</t>
<t tx="ekr.20230509052845.5004">@test
def test_takewhile_from_cpython():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(takewhile(underten, data)) == [1, 3, 5]
    assert list(takewhile(underten, List[int]())) == []
    t = takewhile(lambda x: bool(x), [1, 1, 1, 0, 0, 0])
    assert list(t) == [1, 1, 1]


</t>
<t tx="ekr.20230509052845.5005">test_takewhile_from_cpython()


</t>
<t tx="ekr.20230509052845.5006">@test
def test_dropwhile_from_cpython():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(dropwhile(underten, data)) == [20, 2, 4, 6, 8]
    assert list(dropwhile(underten, List[int]())) == []


</t>
<t tx="ekr.20230509052845.5007">test_dropwhile_from_cpython()


</t>
<t tx="ekr.20230509052845.5008">@test
def test_tee_from_cpython():
    import random

    n = 200

    a, b = tee(List[int]())  # test empty iterator
    assert list(a) == []
    assert list(b) == []

    a, b = tee(irange(n))  # test 100% interleaved
    assert lzip(a, b) == lzip(range(n), range(n))

    a, b = tee(irange(n))  # test 0% interleaved
    assert list(a) == list(range(n))
    assert list(b) == list(range(n))

    a, b = tee(irange(n))  # test dealloc of leading iterator
    for i in range(100):
        assert next(a) == i
    assert list(b) == list(range(n))

    a, b = tee(irange(n))  # test dealloc of trailing iterator
    for i in range(100):
        assert next(a) == i
    assert list(a) == list(range(100, n))

    for j in range(5):  # test randomly interleaved
        order = [0] * n + [1] * n
        random.shuffle(order)
        lists = ([], [])
        its = tee(irange(n))
        for i in order:
            value = next(its[i])
            lists[i].append(value)
        assert lists[0] == list(range(n))
        assert lists[1] == list(range(n))

    # test long-lagged and multi-way split
    a, b, c = tee(range(2000), 3)
    for i in range(100):
        assert next(a) == i
    assert list(b) == list(range(2000))
    assert [next(c), next(c)] == list(range(2))
    assert list(a) == list(range(100, 2000))
    assert list(c) == list(range(2, 2000))


</t>
<t tx="ekr.20230509052845.5009">@path C:/Repos/codon/test/stdlib/
import math

NAN = math.nan
INF = math.inf
NINF = -math.inf


@others
test_float32_isnan()
test_float32_isinf()
test_float32_isfinite()
test_float32_ceil()
test_float32_floor()
test_float32_fabs()
test_float32_fmod()
test_float32_exp()
test_float32_expm1()
test_float32_ldexp()
test_float32_log()
test_float32_log2()
test_float32_log10()
test_float32_degrees()
test_float32_radians()
test_float32_sqrt()
test_float32_pow()
test_float32_acos()
test_float32_asin()
test_float32_atan()
test_float32_atan2()
test_float32_cos()
test_float32_sin()
test_float32_hypot()
test_float32_tan()
test_float32_cosh()
test_float32_sinh()
test_float32_tanh()
test_float32_acosh()
test_float32_asinh()
test_float32_atanh()
test_float32_copysign()
test_float32_log1p()
test_float32_trunc()
test_float32_erf()
test_float32_erfc()
test_float32_gamma()
test_float32_lgamma()
test_float32_remainder()
test_float32_gcd()
test_float32_frexp()
test_float32_modf()
test_float32_isclose()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.501">template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;
bool operator==(const function_iterator_adaptor&lt;OtherIt, OtherDereferenceFunc,
                                                OtherMemberFunc&gt; &amp;other) const {
  return other.internal == internal;
}

</t>
<t tx="ekr.20230509052845.5010">def close(a: float, b: float, epsilon: float = 1e-7):
    return abs(a - b) &lt;= epsilon


</t>
<t tx="ekr.20230509052845.5011">@test
def test_isnan():
    assert math.isnan(float("nan")) == True
    assert math.isnan(4.0) == False


</t>
<t tx="ekr.20230509052845.5012">@test
def test_isinf():
    assert math.isinf(float("inf")) == True
    assert math.isinf(7.0) == False


</t>
<t tx="ekr.20230509052845.5013">@test
def test_isfinite():
    assert math.isfinite(1.4) == True
    assert math.isfinite(0.0) == True
    assert math.isfinite(NAN) == False
    assert math.isfinite(INF) == False
    assert math.isfinite(NINF) == False


</t>
<t tx="ekr.20230509052845.5014">@test
def test_ceil():
    assert math.ceil(3.3) == 4
    assert math.ceil(0.5) == 1
    assert math.ceil(1.0) == 1
    assert math.ceil(1.5) == 2
    assert math.ceil(-0.5) == 0
    assert math.ceil(-1.0) == -1
    assert math.ceil(-1.5) == -1


</t>
<t tx="ekr.20230509052845.5015">@test
def test_floor():
    assert math.floor(3.3) == 3
    assert math.floor(0.5) == 0
    assert math.floor(1.0) == 1
    assert math.floor(1.5) == 1
    assert math.floor(-0.5) == -1
    assert math.floor(-1.0) == -1
    assert math.floor(-1.5) == -2


</t>
<t tx="ekr.20230509052845.5016">@test
def test_fabs():
    assert math.fabs(-1.0) == 1
    assert math.fabs(0.0) == 0
    assert math.fabs(1.0) == 1


</t>
<t tx="ekr.20230509052845.5017">@test
def test_fmod():
    assert math.fmod(10.0, 1.0) == 0.0
    assert math.fmod(10.0, 0.5) == 0.0
    assert math.fmod(10.0, 1.5) == 1.0
    assert math.fmod(-10.0, 1.0) == -0.0
    assert math.fmod(-10.0, 0.5) == -0.0
    assert math.fmod(-10.0, 1.5) == -1.0


</t>
<t tx="ekr.20230509052845.5018">@test
def test_exp():
    assert math.exp(0.0) == 1
    assert math.exp(-1.0) == 1 / math.e
    assert math.exp(1.0) == math.e


</t>
<t tx="ekr.20230509052845.5019">@test
def test_expm1():
    assert math.expm1(0.0) == 0
    assert close(math.expm1(1.0), 1.7182818284590453)
    assert close(math.expm1(3.0), 19.085536923187668)
    assert close(math.expm1(5.0), 147.4131591025766)
    assert math.expm1(INF) == INF
    assert math.expm1(NINF) == -1
    assert math.isnan(math.expm1(NAN)) == True


</t>
<t tx="ekr.20230509052845.502">template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;
bool operator!=(const function_iterator_adaptor&lt;OtherIt, OtherDereferenceFunc,
                                                OtherMemberFunc&gt; &amp;other) const {
  return other.internal != internal;
}
</t>
<t tx="ekr.20230509052845.5020">@test
def test_ldexp():
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, 1) == 2.0
    assert math.ldexp(1.0, -1) == 0.5
    assert math.ldexp(-1.0, 1) == -2.0
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, -1000000) == 0.0
    assert math.ldexp(-1.0, -1000000) == -0.0
    assert math.ldexp(INF, 30) == INF
    assert math.ldexp(NINF, -213) == NINF
    assert math.isnan(math.ldexp(NAN, 0)) == True


</t>
<t tx="ekr.20230509052845.5021">@test
def test_log():
    assert math.log(1.0 / math.e) == -1
    assert math.log(1.0) == 0
    assert math.log(math.e) == 1


</t>
<t tx="ekr.20230509052845.5022">@test
def test_log2():
    assert math.log2(1.0) == 0.0
    assert math.log2(2.0) == 1.0
    assert math.log2(4.0) == 2.0
    assert math.log2(2.0 ** 1023) == 1023.0
    assert math.isnan(math.log2(-1.5)) == True
    assert math.isnan(math.log2(NINF)) == True
    assert math.isnan(math.log2(NAN)) == True


</t>
<t tx="ekr.20230509052845.5023">@test
def test_log10():
    assert math.log10(0.1) == -1
    assert math.log10(1.0) == 0
    assert math.log10(10.0) == 1
    assert math.log10(10000.0) == 4


</t>
<t tx="ekr.20230509052845.5024">@test
def test_degrees():
    assert math.degrees(math.pi) == 180.0
    assert math.degrees(math.pi / 2) == 90.0
    assert math.degrees(-math.pi / 4) == -45.0
    assert math.degrees(0.0) == 0.0


</t>
<t tx="ekr.20230509052845.5025">@test
def test_radians():
    assert math.radians(180.0) == math.pi
    assert math.radians(90.0) == math.pi / 2
    assert math.radians(-45.0) == -math.pi / 4
    assert math.radians(0.0) == 0.0


</t>
<t tx="ekr.20230509052845.5026">@test
def test_sqrt():
    assert math.sqrt(4.0) == 2
    assert math.sqrt(0.0) == 0
    assert math.sqrt(1.0) == 1
    assert math.isnan(math.sqrt(-1.0)) == True


</t>
<t tx="ekr.20230509052845.5027">@test
def test_pow():
    assert math.pow(0.0, 1.0) == 0
    assert math.pow(1.0, 0.0) == 1
    assert math.pow(2.0, 1.0) == 2
    assert math.pow(2.0, -1.0) == 0.5
    assert math.pow(-0.0, 3.0) == -0.0
    assert math.pow(-0.0, 2.3) == 0.0
    assert math.pow(-0.0, 0.0) == 1
    assert math.pow(-0.0, -0.0) == 1
    assert math.pow(-2.0, 2.0) == 4.0
    assert math.pow(-2.0, 3.0) == -8.0
    assert math.pow(-2.0, -3.0) == -0.125
    assert math.pow(INF, 1.0) == INF
    assert math.pow(NINF, 1.0) == NINF
    assert math.pow(1.0, INF) == 1
    assert math.pow(1.0, NINF) == 1
    assert math.isnan(math.pow(NAN, 1.0)) == True
    assert math.isnan(math.pow(2.0, NAN)) == True
    assert math.isnan(math.pow(0.0, NAN)) == True
    assert math.pow(1.0, NAN) == 1


</t>
<t tx="ekr.20230509052845.5028">@test
def test_acos():
    assert math.acos(-1.0) == math.pi
    assert math.acos(0.0) == math.pi / 2
    assert math.acos(1.0) == 0
    assert math.isnan(math.acos(NAN)) == True


</t>
<t tx="ekr.20230509052845.5029">@test
def test_asin():
    assert math.asin(-1.0) == -math.pi / 2
    assert math.asin(0.0) == 0
    assert math.asin(1.0) == math.pi / 2
    assert math.isnan(math.asin(NAN)) == True


</t>
<t tx="ekr.20230509052845.503">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Base class for IR nodes that match anything.
class Any {};

@others
/// Checks if IR nodes match.
/// @param a the first IR node
/// @param b the second IR node
/// @param checkNames whether or not to check the node names
/// @param varIdMatch whether or not variable ids must match
/// @return true if the nodes are equal
bool match(Node *a, Node *b, bool checkNames = false, bool varIdMatch = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5030">@test
def test_atan():
    assert math.atan(-1.0) == -math.pi / 4
    assert math.atan(0.0) == 0
    assert math.atan(1.0) == math.pi / 4
    assert math.atan(INF) == math.pi / 2
    assert math.atan(NINF) == -math.pi / 2
    assert math.isnan(math.atan(NAN)) == True


</t>
<t tx="ekr.20230509052845.5031">@test
def test_atan2():
    assert math.atan2(-1.0, 0.0) == -math.pi / 2
    assert math.atan2(-1.0, 1.0) == -math.pi / 4
    assert math.atan2(0.0, 1.0) == 0
    assert math.atan2(1.0, 1.0) == math.pi / 4
    assert math.atan2(1.0, 0.0) == math.pi / 2
    assert math.atan2(-0.0, 0.0) == -0
    assert math.atan2(-0.0, 2.3) == -0
    assert math.atan2(0.0, -2.3) == math.pi
    assert math.atan2(INF, NINF) == math.pi * 3 / 4
    assert math.atan2(INF, 2.3) == math.pi / 2
    assert math.isnan(math.atan2(NAN, 0.0)) == True


</t>
<t tx="ekr.20230509052845.5032">@test
def test_cos():
    assert math.cos(0.0) == 1
    assert close(math.cos(math.pi / 2), 6.123233995736766e-17)
    assert close(math.cos(-math.pi / 2), 6.123233995736766e-17)
    assert math.cos(math.pi) == -1
    assert math.isnan(math.cos(INF)) == True
    assert math.isnan(math.cos(NINF)) == True
    assert math.isnan(math.cos(NAN)) == True


</t>
<t tx="ekr.20230509052845.5033">@test
def test_sin():
    assert math.sin(0.0) == 0
    assert math.sin(math.pi / 2) == 1
    assert math.sin(-math.pi / 2) == -1
    assert math.isnan(math.sin(INF)) == True
    assert math.isnan(math.sin(NINF)) == True
    assert math.isnan(math.sin(NAN)) == True


</t>
<t tx="ekr.20230509052845.5034">@test
def test_hypot():
    assert math.hypot(12.0, 5.0) == 13
    assert math.hypot(12.0 / 32.0, 5.0 / 32) == 13 / 32
    assert math.hypot(0.0, 0.0) == 0
    assert math.hypot(-3.0, 4.0) == 5
    assert math.hypot(3.0, 4.0) == 5


</t>
<t tx="ekr.20230509052845.5035">@test
def test_tan():
    assert math.tan(0.0) == 0
    assert close(math.tan(math.pi / 4), 0.9999999999999999)
    assert close(math.tan(-math.pi / 4), -0.9999999999999999)
    assert math.isnan(math.tan(INF)) == True
    assert math.isnan(math.tan(NINF)) == True
    assert math.isnan(math.tan(NAN)) == True


</t>
<t tx="ekr.20230509052845.5036">@test
def test_cosh():
    assert math.cosh(0.0) == 1
    assert math.cosh(2.0) - 2 * math.cosh(1.0) ** 2 == -1
    assert math.cosh(INF) == INF
    assert math.cosh(NINF) == INF
    assert math.isnan(math.cosh(NAN)) == True


</t>
<t tx="ekr.20230509052845.5037">@test
def test_sinh():
    assert math.sinh(0.0) == 0
    assert math.sinh(1.0) + math.sinh(-1.0) == 0
    assert math.sinh(INF) == INF
    assert math.sinh(NINF) == NINF
    assert math.isnan(math.sinh(NAN)) == True


</t>
<t tx="ekr.20230509052845.5038">@test
def test_tanh():
    assert math.tanh(0.0) == 0
    assert math.tanh(1.0) + math.tanh(-1.0) == 0
    assert math.tanh(INF) == 1
    assert math.tanh(NINF) == -1
    assert math.isnan(math.tanh(NAN)) == True


</t>
<t tx="ekr.20230509052845.5039">@test
def test_acosh():
    assert math.acosh(1.0) == 0
    assert close(math.acosh(2.0), 1.3169578969248166)
    assert math.acosh(INF) == INF
    assert math.isnan(math.acosh(NAN)) == True
    assert math.isnan(math.acosh(-1.0)) == True


</t>
<t tx="ekr.20230509052845.504">/// Any value.
class AnyValue : public AcceptorExtend&lt;AnyValue, Value&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;

private:
  types::Type *doGetType() const override { return getModule()-&gt;getVoidType(); }
};

</t>
<t tx="ekr.20230509052845.5040">@test
def test_asinh():
    assert math.asinh(0.0) == 0
    assert close(math.asinh(1.0), 0.881373587019543)
    assert close(math.asinh(-1.0), -0.881373587019543)
    assert math.asinh(INF) == INF
    assert math.isnan(math.asinh(NAN)) == True
    assert math.asinh(NINF) == NINF


</t>
<t tx="ekr.20230509052845.5041">@test
def test_atanh():
    assert math.atanh(0.0) == 0
    assert close(math.atanh(0.5), 0.5493061443340549)
    assert close(math.atanh(-0.5), -0.5493061443340549)
    assert math.isnan(math.atanh(INF)) == True
    assert math.isnan(math.atanh(NAN)) == True
    assert math.isnan(math.atanh(NINF)) == True


</t>
<t tx="ekr.20230509052845.5042">@test
def test_copysign():
    assert math.copysign(1.0, -0.0) == -1
    assert math.copysign(1.0, 42.0) == 1
    assert math.copysign(1.0, -42.0) == -1
    assert math.copysign(3.0, 0.0) == 3
    assert math.copysign(INF, 0.0) == INF
    assert math.copysign(INF, -0.0) == NINF
    assert math.copysign(NINF, 0.0) == INF
    assert math.copysign(NINF, -0.0) == NINF
    assert math.copysign(1.0, INF) == 1
    assert math.copysign(1.0, NINF) == -1
    assert math.copysign(INF, INF) == INF
    assert math.copysign(INF, NINF) == NINF
    assert math.copysign(NINF, INF) == INF
    assert math.copysign(NINF, NINF) == NINF
    assert math.isnan(math.copysign(NAN, 1.0)) == True
    assert math.isnan(math.copysign(NAN, INF)) == True
    assert math.isnan(math.copysign(NAN, NINF)) == True
    assert math.isnan(math.copysign(NAN, NAN)) == True


</t>
<t tx="ekr.20230509052845.5043">@test
def test_log1p():
    assert close(math.log1p(2.0), 1.0986122886681098)
    assert close(math.log1p(2.0 ** 90), 62.383246250395075)
    assert close(math.log1p(2.0 ** 300), 207.94415416798358)
    assert math.log1p(INF) == INF
    assert math.log1p(-1.0) == NINF


</t>
<t tx="ekr.20230509052845.5044">@test
def test_trunc():
    assert math.trunc(1.0) == 1
    assert math.trunc(-1.0) == -1
    assert math.trunc(1.5) == 1
    assert math.trunc(-1.5) == -1
    assert math.trunc(1.99999999) == 1
    assert math.trunc(-1.99999999) == -1
    assert math.trunc(0.99999999) == 0
    assert math.trunc(-100.999) == -100


</t>
<t tx="ekr.20230509052845.5045">@test
def test_erf():
    assert close(math.erf(1.0), 0.8427007929497148)
    assert math.erf(0.0) == 0
    assert close(math.erf(3.0), 0.9999779095030015)
    assert math.erf(256.0) == 1.0
    assert math.erf(INF) == 1.0
    assert math.erf(NINF) == -1.0
    assert math.isnan(math.erf(NAN)) == True


</t>
<t tx="ekr.20230509052845.5046">@test
def test_erfc():
    assert math.erfc(0.0) == 1.0
    assert close(math.erfc(1.0), 0.15729920705028516)
    assert close(math.erfc(2.0), 0.0046777349810472645)
    assert close(math.erfc(-1.0), 1.8427007929497148)
    assert math.erfc(INF) == 0.0
    assert math.erfc(NINF) == 2.0
    assert math.isnan(math.erfc(NAN)) == True


</t>
<t tx="ekr.20230509052845.5047">@test
def test_gamma():
    assert close(math.gamma(6.0), 120.0)
    assert close(math.gamma(1.0), 1.0)
    assert close(math.gamma(2.0), 1.0)
    assert close(math.gamma(3.0), 2.0)
    assert math.isnan(math.gamma(-1.0)) == True
    assert math.gamma(INF) == INF
    assert math.isnan(math.gamma(NINF)) == True
    assert math.isnan(math.gamma(NAN)) == True


</t>
<t tx="ekr.20230509052845.5048">@test
def test_lgamma():
    assert math.lgamma(1.0) == 0.0
    assert math.lgamma(2.0) == 0.0
    assert math.lgamma(-1.0) == INF
    assert math.lgamma(INF) == INF
    assert math.lgamma(NINF) == INF
    assert math.isnan(math.lgamma(NAN)) == True


</t>
<t tx="ekr.20230509052845.5049">@test
def test_remainder():
    assert math.remainder(2.0, 2.0) == 0.0
    assert math.remainder(-4.0, 1.0) == -0.0
    assert close(math.remainder(-3.8, 1.0), 0.20000000000000018)
    assert close(math.remainder(3.8, 1.0), -0.20000000000000018)
    assert math.isnan(math.remainder(INF, 1.0)) == True
    assert math.isnan(math.remainder(NINF, 1.0)) == True
    assert math.isnan(math.remainder(NAN, 1.0)) == True


</t>
<t tx="ekr.20230509052845.505">/// Any flow.
class AnyFlow : public AcceptorExtend&lt;AnyFlow, Flow&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509052845.5050">@test
def test_gcd():
    assert math.gcd(0.0, 0.0) == 0
    assert math.gcd(1.0, 0.0) == 1
    assert math.gcd(-1.0, 0.0) == 1
    assert math.gcd(0.0, -1.0) == 1
    assert math.gcd(0.0, 1.0) == 1
    assert math.gcd(7.0, 1.0) == 1
    assert math.gcd(7.0, -1.0) == 1
    assert math.gcd(-23.0, 15.0) == 1
    assert math.gcd(120.0, 84.0) == 12
    assert math.gcd(84.0, -120.0) == 12


</t>
<t tx="ekr.20230509052845.5051">@test
def test_frexp():
    assert math.frexp(-2.0) == (-0.5, 2)
    assert math.frexp(-1.0) == (-0.5, 1)
    assert math.frexp(0.0) == (0.0, 0)
    assert math.frexp(1.0) == (0.5, 1)
    assert math.frexp(2.0) == (0.5, 2)
    assert math.frexp(INF)[0] == INF
    assert math.frexp(NINF)[0] == NINF
    assert math.isnan(math.frexp(NAN)[0]) == True


</t>
<t tx="ekr.20230509052845.5052">@test
def test_modf():
    assert math.modf(1.5) == (0.5, 1.0)
    assert math.modf(-1.5) == (-0.5, -1.0)
    assert math.modf(math.inf) == (0.0, INF)
    assert math.modf(-math.inf) == (-0.0, NINF)
    modf_nan = math.modf(NAN)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


</t>
<t tx="ekr.20230509052845.5053">@test
def test_isclose():
    assert math.isclose(1.0 + 1.0, 1.000000000001 + 1.0) == True
    assert math.isclose(2.90909324093284, 2.909093240932844234234234234) == True
    assert math.isclose(2.90909324093284, 2.9) == False
    assert math.isclose(2.90909324093284, 2.90909324) == True
    assert math.isclose(2.90909324, 2.90909325) == False
    assert math.isclose(NAN, 2.9) == False
    assert math.isclose(2.9, NAN) == False
    assert math.isclose(INF, INF) == True
    assert math.isclose(NINF, NINF) == True
    assert math.isclose(NINF, INF) == False
    assert math.isclose(INF, NINF) == False


</t>
<t tx="ekr.20230509052845.5054">@test
def test_fsum():
    assert math.fsum((42,)) == 42.0
    assert math.fsum((1,2,3)) == 6.0
    assert math.fsum((1,2,-3)) == 0.0
    assert math.fsum(()) == 0.0
    assert math.fsum([.1] * 10) == 1.0

    mant_dig = 53
    etiny = -1074

    @others
    test_values = [
        ([], 0.0),
        ([0.0], 0.0),
        ([1e100, 1.0, -1e100, 1e-100, 1e50, -1.0, -1e50], 1e-100),
        ([2.0**53, -0.5, -2.0**-54], 2.0**53-1.0),
        ([2.0**53, 1.0, 2.0**-100], 2.0**53+2.0),
        ([2.0**53+10.0, 1.0, 2.0**-100], 2.0**53+12.0),
        ([2.0**53-4.0, 0.5, 2.0**-54], 2.0**53-3.0),
        ([1./n for n in range(1, 1001)], float1()),
        ([(-1.)**n/n for n in range(1, 1001)], float2()),
        ([1e16, 1., 1e-16], 10000000000000002.0),
        ([1e16-2., 1.-2.**-53, -(1e16-2.), -(1.-2.**-53)], 0.0),
        # exercise code for resizing partials array
        ([2.**n - 2.**(n+50) + 2.**(n+52) for n in range(-1074, 972, 2)] +
         [-2.**1022],
         float3()),
        ]

    # Telescoping sum, with exact differences (due to Sterbenz)
    terms = [1.7**i for i in range(1001)]
    test_values.append((
        [terms[i+1] - terms[i] for i in range(1000)] + [-terms[1000]],
        -terms[0]
    ))

    for i, (vals, expected) in enumerate(test_values):
        try:
            actual = math.fsum(vals)
        except OverflowError:
            # self.fail("test %d failed: got OverflowError, expected %r "
            #           "for math.fsum(%.100r)" % (i, expected, vals))
            assert False
        except ValueError:
            # self.fail("test %d failed: got ValueError, expected %r "
            #           "for math.fsum(%.100r)" % (i, expected, vals))
            assert False

        assert actual == expected

    from random import random, gauss, shuffle
    for j in range(10000):
        vals = [7, 1e100, -7, -1e100, -9e-20, 8e-20] * 10
        s = 0.
        for i in range(200):
            v = gauss(0, random()) ** 7 - s
            s += v
            vals.append(v)
        shuffle(vals)
        assert msum(vals) == math.fsum(vals)


</t>
<t tx="ekr.20230509052845.5055">def sum_exact(p):
    n = len(p)
    hi = 0.0
    if n &gt; 0:
        hi = p[n-1]
        n -= 1
        while n &gt; 0:
            x = hi
            y = p[n-1]
            n -= 1
            hi = x + y
            yr = hi - x
            lo = y - yr
            if lo != 0.0:
                break

        if n &gt; 0 and ((lo &lt; 0 and p[n-1] &lt; 0) or (lo &gt; 0 and p[n-1] &gt; 0)):
            y = lo * 2
            x = hi + y
            yr = x - hi
            if y == yr:
                hi = x
    return hi

</t>
<t tx="ekr.20230509052845.5056">def msum(iterable):
    "Full precision summation using multiple floats for intermediate values"
    # Rounded x+y stored in hi with the round-off stored in lo.  Together
    # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation
    # to each partial so that the list of partial sums remains exact.
    # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:
    # www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps

    partials = []               # sorted, non-overlapping partial sums
    for x in iterable:
        i = 0
        for y in partials:
            if abs(x) &lt; abs(y):
                x, y = y, x
            hi = x + y
            lo = y - (hi - x)
            if lo:
                partials[i] = lo
                i += 1
            x = hi
        partials[i:] = [x]
    return sum_exact(partials)

</t>
<t tx="ekr.20230509052845.5057">@pure
@llvm
def float1() -&gt; float:
    ret double 0x401DF11F45F4E61A

</t>
<t tx="ekr.20230509052845.5058">@pure
@llvm
def float2() -&gt; float:
    ret double 0xBFE62A2AF1BD3624

</t>
<t tx="ekr.20230509052845.5059">@pure
@llvm
def float3() -&gt; float:
    ret double 0x7C95555555555555

</t>
<t tx="ekr.20230509052845.506">/// Any variable.
class AnyVar : public AcceptorExtend&lt;AnyVar, Var&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509052845.5060">test_isnan()
test_isinf()
test_isfinite()
test_ceil()
test_floor()
test_fabs()
test_fmod()
test_exp()
test_expm1()
test_ldexp()
test_log()
test_log2()
test_log10()
test_degrees()
test_radians()
test_sqrt()
test_pow()
test_acos()
test_asin()
test_atan()
test_atan2()
test_cos()
test_sin()
test_hypot()
test_tan()
test_cosh()
test_sinh()
test_tanh()
test_acosh()
test_asinh()
test_atanh()
test_copysign()
test_log1p()
test_trunc()
test_erf()
test_erfc()
test_gamma()
test_lgamma()
test_remainder()
test_gcd()
test_frexp()
test_modf()
test_isclose()
test_fsum()


# 32-bit float ops

NAN32 = math.nan32
INF32 = math.inf32
NINF32 = -math.inf32


</t>
<t tx="ekr.20230509052845.5061">def close32(a: float32, b: float32, epsilon: float32 = 1e-5f32):
    return abs(a - b) &lt;= epsilon


</t>
<t tx="ekr.20230509052845.5062">@test
def test_float32_isnan():
    assert math.isnan(float32(float("nan"))) == True
    assert math.isnan(4.0f32) == False


</t>
<t tx="ekr.20230509052845.5063">@test
def test_float32_isinf():
    assert math.isinf(float32(float("inf"))) == True
    assert math.isinf(7.0f32) == False


</t>
<t tx="ekr.20230509052845.5064">@test
def test_float32_isfinite():
    assert math.isfinite(1.4f32) == True
    assert math.isfinite(0.0f32) == True
    assert math.isfinite(NAN32) == False
    assert math.isfinite(INF32) == False
    assert math.isfinite(NINF32) == False


</t>
<t tx="ekr.20230509052845.5065">@test
def test_float32_ceil():
    assert math.ceil(3.3f32) == 4.0f32
    assert math.ceil(0.5f32) == 1.0f32
    assert math.ceil(1.0f32) == 1.0f32
    assert math.ceil(1.5f32) == 2.0f32
    assert math.ceil(-0.5f32) == 0.0f32
    assert math.ceil(-1.0f32) == -1.0f32
    assert math.ceil(-1.5f32) == -1.0f32


</t>
<t tx="ekr.20230509052845.5066">@test
def test_float32_floor():
    assert math.floor(3.3f32) == 3.0f32
    assert math.floor(0.5f32) == 0.0f32
    assert math.floor(1.0f32) == 1.0f32
    assert math.floor(1.5f32) == 1.0f32
    assert math.floor(-0.5f32) == -1.0f32
    assert math.floor(-1.0f32) == -1.0f32
    assert math.floor(-1.5f32) == -2.0f32


</t>
<t tx="ekr.20230509052845.5067">@test
def test_float32_fabs():
    assert math.fabs(-1.0f32) == 1.0f32
    assert math.fabs(0.0f32) == 0.0f32
    assert math.fabs(1.0f32) == 1.0f32


</t>
<t tx="ekr.20230509052845.5068">@test
def test_float32_fmod():
    assert math.fmod(10.0f32, 1.0f32) == 0.0f32
    assert math.fmod(10.0f32, 0.5f32) == 0.0f32
    assert math.fmod(10.0f32, 1.5f32) == 1.0f32
    assert math.fmod(-10.0f32, 1.0f32) == -0.0f32
    assert math.fmod(-10.0f32, 0.5f32) == -0.0f32
    assert math.fmod(-10.0f32, 1.5f32) == -1.0f32


</t>
<t tx="ekr.20230509052845.5069">@test
def test_float32_exp():
    assert math.exp(0.0f32) == 1.0f32
    assert math.exp(-1.0f32) == 1.0f32 / math.e32
    assert math.exp(1.0f32) == math.e32


</t>
<t tx="ekr.20230509052845.507">/// Any function.
class AnyFunc : public AcceptorExtend&lt;AnyFunc, Func&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;

  AnyFunc() : AcceptorExtend() { setUnmangledName("any"); }
};

</t>
<t tx="ekr.20230509052845.5070">@test
def test_float32_expm1():
    assert math.expm1(0.0f32) == 0.0f32
    assert close32(math.expm1(1.0f32), 1.7182818284590453f32)
    assert close32(math.expm1(3.0f32), 19.085536923187668f32)
    assert close32(math.expm1(5.0f32), 147.4131591025766f32)
    assert math.expm1(INF32) == INF32
    assert math.expm1(NINF32) == -1.0f32
    assert math.isnan(math.expm1(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5071">@test
def test_float32_ldexp():
    assert math.ldexp(0.0f32, 1) == 0.0f32
    assert math.ldexp(1.0f32, 1) == 2.0f32
    assert math.ldexp(1.0f32, -1) == 0.5f32
    assert math.ldexp(-1.0f32, 1) == -2.0f32
    assert math.ldexp(0.0f32, 1) == 0.0f32
    assert math.ldexp(1.0f32, -1000000) == 0.0f32
    assert math.ldexp(-1.0f32, -1000000) == -0.0f32
    assert math.ldexp(INF32, 30) == INF32
    assert math.ldexp(NINF32, -213) == NINF32
    assert math.isnan(math.ldexp(NAN32, 0)) == True


</t>
<t tx="ekr.20230509052845.5072">@test
def test_float32_log():
    assert math.log(1.0f32 / math.e32) == -1.0f32
    assert math.log(1.0f32) == 0.0f32
    assert close32(math.log(math.e32), 1.0f32)


</t>
<t tx="ekr.20230509052845.5073">@test
def test_float32_log2():
    assert math.log2(1.0f32) == 0.0f32
    assert math.log2(2.0f32) == 1.0f32
    assert math.log2(4.0f32) == 2.0f32
    assert math.log2(2.0f32 ** 50.0f32) == 50.0f32
    assert math.isnan(math.log2(-1.5f32)) == True
    assert math.isnan(math.log2(NINF32)) == True
    assert math.isnan(math.log2(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5074">@test
def test_float32_log10():
    assert math.log10(0.1f32) == -1.0f32
    assert math.log10(1.0f32) == 0.0f32
    assert math.log10(10.0f32) == 1.0f32
    assert math.log10(10000.0f32) == 4.0f32


</t>
<t tx="ekr.20230509052845.5075">@test
def test_float32_degrees():
    assert math.degrees(math.pi32) == 180.0f32
    assert math.degrees(math.pi32 / 2.0f32) == 90.0f32
    assert math.degrees(-math.pi32 / 4.0f32) == -45.0f32
    assert math.degrees(0.0f32) == 0.0f32


</t>
<t tx="ekr.20230509052845.5076">@test
def test_float32_radians():
    assert math.radians(180.0f32) == math.pi32
    assert math.radians(90.0f32) == math.pi32 / 2.0f32
    assert math.radians(-45.0f32) == -math.pi32 / 4.0f32
    assert math.radians(0.0f32) == 0.0f32


</t>
<t tx="ekr.20230509052845.5077">@test
def test_float32_sqrt():
    assert math.sqrt(4.0f32) == 2.0f32
    assert math.sqrt(0.0f32) == 0.0f32
    assert math.sqrt(1.0f32) == 1.0f32
    assert math.isnan(math.sqrt(-1.0f32)) == True


</t>
<t tx="ekr.20230509052845.5078">@test
def test_float32_pow():
    assert math.pow(0.0f32, 1.0f32) == 0.0f32
    assert math.pow(1.0f32, 0.0f32) == 1.0f32
    assert math.pow(2.0f32, 1.0f32) == 2.0f32
    assert math.pow(2.0f32, -1.0f32) == 0.5f32
    assert math.pow(-0.0f32, 3.0f32) == -0.0f32
    assert math.pow(-0.0f32, 2.3f32) == 0.0f32
    assert math.pow(-0.0f32, 0.0f32) == 1.0f32
    assert math.pow(-0.0f32, -0.0f32) == 1.0f32
    assert math.pow(-2.0f32, 2.0f32) == 4.0f32
    assert math.pow(-2.0f32, 3.0f32) == -8.0f32
    assert math.pow(-2.0f32, -3.0f32) == -0.125f32
    assert math.pow(INF32, 1.0f32) == INF32
    assert math.pow(NINF32, 1.0f32) == NINF32
    assert math.pow(1.0f32, INF32) == 1.0f32
    assert math.pow(1.0f32, NINF32) == 1.0f32
    assert math.isnan(math.pow(NAN32, 1.0f32)) == True
    assert math.isnan(math.pow(2.0f32, NAN32)) == True
    assert math.isnan(math.pow(0.0f32, NAN32)) == True
    assert math.pow(1.0f32, NAN32) == 1.0f32


</t>
<t tx="ekr.20230509052845.5079">@test
def test_float32_acos():
    assert close32(math.acos(-1.0f32), math.pi32)
    assert close32(math.acos(0.0f32), math.pi32 / 2.0f32)
    assert math.acos(1.0f32) == 0.0f32
    assert math.isnan(math.acos(NAN32)) == True


</t>
<t tx="ekr.20230509052845.508">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_set&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/visitor.h"

#define LAMBDA_VISIT(x)                                                                \
  virtual void handle(codon::ir::x *v) {}                                              \
@others
} // namespace util
} // namespace ir
} // namespace codon

#undef LAMBDA_VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5080">@test
def test_float32_asin():
    assert close32(math.asin(-1.0f32), -math.pi32 / 2.0f32)
    assert math.asin(0.0f32) == 0.0f32
    assert close32(math.asin(1.0f32), math.pi32 / 2.0f32)
    assert math.isnan(math.asin(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5081">@test
def test_float32_atan():
    assert math.atan(-1.0f32) == -math.pi32 / 4.0f32
    assert math.atan(0.0f32) == 0.0f32
    assert close32(math.atan(1.0f32), math.pi32 / 4.0f32)
    assert close32(math.atan(INF32), math.pi32 / 2.0f32)
    assert close32(math.atan(NINF32), -math.pi32 / 2.0f32)
    assert math.isnan(math.atan(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5082">@test
def test_float32_atan2():
    assert math.atan2(-1.0f32, 0.0f32) == -math.pi32 / 2.0f32
    assert math.atan2(-1.0f32, 1.0f32) == -math.pi32 / 4.0f32
    assert math.atan2(0.0f32, 1.0f32) == 0.0f32
    assert math.atan2(1.0f32, 1.0f32) == math.pi32 / 4.0f32
    assert math.atan2(1.0f32, 0.0f32) == math.pi32 / 2.0f32
    assert math.atan2(-0.0f32, 0.0f32) == -0.0f32
    assert math.atan2(-0.0f32, 2.3f32) == -0.0f32
    assert close32(math.atan2(0.0f32, -2.3f32), math.pi32)
    assert math.atan2(INF32, NINF32) == math.pi32 * 3.0f32 / 4.0f32
    assert math.atan2(INF32, 2.3f32) == math.pi32 / 2.0f32
    assert math.isnan(math.atan2(NAN32, 0.0f32)) == True


</t>
<t tx="ekr.20230509052845.5083">@test
def test_float32_cos():
    assert math.cos(0.0f32) == 1.0f32
    assert close32(math.cos(math.pi32 / 2.0f32), 6.123233995736766e-17f32)
    assert close32(math.cos(-math.pi32 / 2.0f32), 6.123233995736766e-17f32)
    assert math.cos(math.pi32) == -1.0f32
    assert math.isnan(math.cos(INF32)) == True
    assert math.isnan(math.cos(NINF32)) == True
    assert math.isnan(math.cos(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5084">@test
def test_float32_sin():
    assert math.sin(0.0f32) == 0.0f32
    assert math.sin(math.pi32 / 2.0f32) == 1.0f32
    assert math.sin(-math.pi32 / 2.0f32) == -1.0f32
    assert math.isnan(math.sin(INF32)) == True
    assert math.isnan(math.sin(NINF32)) == True
    assert math.isnan(math.sin(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5085">@test
def test_float32_hypot():
    assert math.hypot(12.0f32, 5.0f32) == 13.0f32
    assert math.hypot(12.0f32 / 32.0f32, 5.0f32 / 32.0f32) == 13.0f32 / 32.0f32
    assert math.hypot(0.0f32, 0.0f32) == 0.0f32
    assert math.hypot(-3.0f32, 4.0f32) == 5.0f32
    assert math.hypot(3.0f32, 4.0f32) == 5.0f32


</t>
<t tx="ekr.20230509052845.5086">@test
def test_float32_tan():
    assert math.tan(0.0f32) == 0.0f32
    assert close32(math.tan(math.pi32 / 4.0f32), 0.9999999999999999f32)
    assert close32(math.tan(-math.pi32 / 4.0f32), -0.9999999999999999f32)
    assert math.isnan(math.tan(INF32)) == True
    assert math.isnan(math.tan(NINF32)) == True
    assert math.isnan(math.tan(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5087">@test
def test_float32_cosh():
    assert math.cosh(0.0f32) == 1.0f32
    assert close32(math.cosh(2.0f32) - 2.0f32 * math.cosh(1.0f32) ** 2.0f32, -1.0f32)
    assert math.cosh(INF32) == INF32
    assert math.cosh(NINF32) == INF32
    assert math.isnan(math.cosh(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5088">@test
def test_float32_sinh():
    assert math.sinh(0.0f32) == 0.0f32
    assert math.sinh(1.0f32) + math.sinh(-1.0f32) == 0.0f32
    assert math.sinh(INF32) == INF32
    assert math.sinh(NINF32) == NINF32
    assert math.isnan(math.sinh(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5089">@test
def test_float32_tanh():
    assert math.tanh(0.0f32) == 0.0f32
    assert math.tanh(1.0f32) + math.tanh(-1.0f32) == 0.0f32
    assert math.tanh(INF32) == 1.0f32
    assert math.tanh(NINF32) == -1.0f32
    assert math.isnan(math.tanh(NAN32)) == True


</t>
<t tx="ekr.20230509052845.509">  void visit(codon::ir::x *v) override {                                               \
    if (childrenFirst)                                                                 \
      processChildren(v);                                                              \
    preHook(v);                                                                        \
    handle(v);                                                                         \
    postHook(v);                                                                       \
    if (!childrenFirst)                                                                \
      processChildren(v);                                                              \
  }

</t>
<t tx="ekr.20230509052845.5090">@test
def test_float32_acosh():
    assert math.acosh(1.0f32) == 0.0f32
    assert close32(math.acosh(2.0f32), 1.3169578969248166f32)
    assert math.acosh(INF32) == INF32
    assert math.isnan(math.acosh(NAN32)) == True
    assert math.isnan(math.acosh(-1.0f32)) == True


</t>
<t tx="ekr.20230509052845.5091">@test
def test_float32_asinh():
    assert math.asinh(0.0f32) == 0.0f32
    assert close32(math.asinh(1.0f32), 0.881373587019543f32)
    assert close32(math.asinh(-1.0f32), -0.881373587019543f32)
    assert math.asinh(INF32) == INF32
    assert math.isnan(math.asinh(NAN32)) == True
    assert math.asinh(NINF32) == NINF32


</t>
<t tx="ekr.20230509052845.5092">@test
def test_float32_atanh():
    assert math.atanh(0.0f32) == 0.0f32
    assert close32(math.atanh(0.5f32), 0.5493061443340549f32)
    assert close32(math.atanh(-0.5f32), -0.5493061443340549f32)
    assert math.isnan(math.atanh(INF32)) == True
    assert math.isnan(math.atanh(NAN32)) == True
    assert math.isnan(math.atanh(NINF32)) == True


</t>
<t tx="ekr.20230509052845.5093">@test
def test_float32_copysign():
    assert math.copysign(1.0f32, -0.0f32) == -1.0f32
    assert math.copysign(1.0f32, 42.0f32) == 1.0f32
    assert math.copysign(1.0f32, -42.0f32) == -1.0f32
    assert math.copysign(3.0f32, 0.0f32) == 3.0f32
    assert math.copysign(INF32, 0.0f32) == INF32
    assert math.copysign(INF32, -0.0f32) == NINF32
    assert math.copysign(NINF32, 0.0f32) == INF32
    assert math.copysign(NINF32, -0.0f32) == NINF32
    assert math.copysign(1.0f32, INF32) == 1.0f32
    assert math.copysign(1.0f32, NINF32) == -1.0f32
    assert math.copysign(INF32, INF32) == INF32
    assert math.copysign(INF32, NINF32) == NINF32
    assert math.copysign(NINF32, INF32) == INF32
    assert math.copysign(NINF32, NINF32) == NINF32
    assert math.isnan(math.copysign(NAN32, 1.0f32)) == True
    assert math.isnan(math.copysign(NAN32, INF32)) == True
    assert math.isnan(math.copysign(NAN32, NINF32)) == True
    assert math.isnan(math.copysign(NAN32, NAN32)) == True


</t>
<t tx="ekr.20230509052845.5094">@test
def test_float32_log1p():
    assert close32(math.log1p(2.0f32), 1.0986122886681098f32)
    assert close32(math.log1p(2.0f32 ** 90.0f32), 62.383246250395075f32)
    assert math.log1p(INF32) == INF32
    assert math.log1p(-1.0f32) == NINF32


</t>
<t tx="ekr.20230509052845.5095">@test
def test_float32_trunc():
    assert math.trunc(1.0f32) == 1.0f32
    assert math.trunc(-1.0f32) == -1.0f32
    assert math.trunc(1.5f32) == 1.0f32
    assert math.trunc(-1.5f32) == -1.0f32
    assert math.trunc(1.99999f32) == 1.0f32
    assert math.trunc(-1.99999f32) == -1.0f32
    assert math.trunc(0.99999f32) == 0.0f32
    assert math.trunc(-100.999f32) == -100.0f32


</t>
<t tx="ekr.20230509052845.5096">@test
def test_float32_erf():
    assert close32(math.erf(1.0f32), 0.8427007929497148f32)
    assert math.erf(0.0f32) == 0.0f32
    assert close32(math.erf(3.0f32), 0.9999779095030015f32)
    assert math.erf(256.0f32) == 1.0f32
    assert math.erf(INF32) == 1.0f32
    assert math.erf(NINF32) == -1.0f32
    assert math.isnan(math.erf(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5097">@test
def test_float32_erfc():
    assert math.erfc(0.0f32) == 1.0f32
    assert close32(math.erfc(1.0f32), 0.15729920705028516f32)
    assert close32(math.erfc(2.0f32), 0.0046777349810472645f32)
    assert close32(math.erfc(-1.0f32), 1.8427007929497148f32)
    assert math.erfc(INF32) == 0.0f32
    assert math.erfc(NINF32) == 2.0f32
    assert math.isnan(math.erfc(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5098">@test
def test_float32_gamma():
    assert close32(math.gamma(6.0f32), 120.0f32)
    assert close32(math.gamma(1.0f32), 1.0f32)
    assert close32(math.gamma(2.0f32), 1.0f32)
    assert close32(math.gamma(3.0f32), 2.0f32)
    assert math.isnan(math.gamma(-1.0f32)) == True
    assert math.gamma(INF32) == INF32
    assert math.isnan(math.gamma(NINF32)) == True
    assert math.isnan(math.gamma(NAN32)) == True


</t>
<t tx="ekr.20230509052845.5099">@test
def test_float32_lgamma():
    assert math.lgamma(1.0f32) == 0.0f32
    assert math.lgamma(2.0f32) == 0.0f32
    assert math.lgamma(-1.0f32) == INF32
    assert math.lgamma(INF32) == INF32
    assert math.lgamma(NINF32) == INF32
    assert math.isnan(math.lgamma(NAN32)) == True


</t>
<t tx="ekr.20230509052845.51">__rmul__ = __mul__

</t>
<t tx="ekr.20230509052845.510">namespace codon {
namespace ir {
namespace util {

</t>
<t tx="ekr.20230509052845.5100">@test
def test_float32_remainder():
    assert math.remainder(2.0f32, 2.0f32) == 0.0f32
    assert math.remainder(-4.0f32, 1.0f32) == -0.0f32
    assert close32(math.remainder(-3.8f32, 1.0f32), 0.20000000000000018f32)
    assert close32(math.remainder(3.8f32, 1.0f32), -0.20000000000000018f32)
    assert math.isnan(math.remainder(INF32, 1.0f32)) == True
    assert math.isnan(math.remainder(NINF32, 1.0f32)) == True
    assert math.isnan(math.remainder(NAN32, 1.0f32)) == True


</t>
<t tx="ekr.20230509052845.5101">@test
def test_float32_gcd():
    assert math.gcd(0.0f32, 0.0f32) == 0.0f32
    assert math.gcd(1.0f32, 0.0f32) == 1.0f32
    assert math.gcd(-1.0f32, 0.0f32) == 1.0f32
    assert math.gcd(0.0f32, -1.0f32) == 1.0f32
    assert math.gcd(0.0f32, 1.0f32) == 1.0f32
    assert math.gcd(7.0f32, 1.0f32) == 1.0f32
    assert math.gcd(7.0f32, -1.0f32) == 1.0f32
    assert math.gcd(-23.0f32, 15.0f32) == 1.0f32
    assert math.gcd(120.0f32, 84.0f32) == 12.0f32
    assert math.gcd(84.0f32, -120.0f32) == 12.0f32


</t>
<t tx="ekr.20230509052845.5102">@test
def test_float32_frexp():
    assert math.frexp(-2.0f32) == (-0.5f32, 2)
    assert math.frexp(-1.0f32) == (-0.5f32, 1)
    assert math.frexp(0.0f32) == (0.0f32, 0)
    assert math.frexp(1.0f32) == (0.5f32, 1)
    assert math.frexp(2.0f32) == (0.5f32, 2)
    assert math.frexp(INF32)[0] == INF32
    assert math.frexp(NINF32)[0] == NINF32
    assert math.isnan(math.frexp(NAN32)[0]) == True


</t>
<t tx="ekr.20230509052845.5103">@test
def test_float32_modf():
    assert math.modf(1.5f32) == (0.5f32, 1.0f32)
    assert math.modf(-1.5f32) == (-0.5f32, -1.0f32)
    assert math.modf(math.inf32) == (0.0f32, INF32)
    assert math.modf(-math.inf32) == (-0.0f32, NINF32)
    modf_nan = math.modf(NAN32)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


</t>
<t tx="ekr.20230509052845.5104">@test
def test_float32_isclose():
    assert math.isclose(1.0f32 + 1.0f32, 1.000000000001f32 + 1.0f32) == True
    assert math.isclose(2.90909324093284f32, 2.909093240932844234234234234f32) == True
    assert math.isclose(2.90909324093284f32, 2.9f32) == False
    assert math.isclose(2.90909324093284f32, 2.90909324f32) == True
    assert math.isclose(2.909094f32, 2.909095f32) == False
    assert math.isclose(NAN32, 2.9f32) == False
    assert math.isclose(2.9f32, NAN32) == False
    assert math.isclose(INF32, INF32) == True
    assert math.isclose(NINF32, NINF32) == True
    assert math.isclose(NINF32, INF32) == False
    assert math.isclose(INF32, NINF32) == False


</t>
<t tx="ekr.20230509052845.5105">@path C:/Repos/codon/test/stdlib/
from operator import *
import operator


@others
test_getter_ops()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5106">def apply1(f, x, expected):
    return f(x) == expected


</t>
<t tx="ekr.20230509052845.5107">def apply2(f, lhs, rhs, expected):
    return f(lhs, rhs) == expected


</t>
<t tx="ekr.20230509052845.5108">n_eq = 0
n_ne = 0
n_lt = 0
n_le = 0
n_gt = 0
n_ge = 0

n_len = 0
n_bool = 0

n_abs = 0
n_pos = 0
n_neg = 0
n_inv = 0
n_index = 0

n_add = 0
n_sub = 0
n_mul = 0
n_matmul = 0
n_truediv = 0
n_floordiv = 0
n_mod = 0
n_pow = 0
n_and = 0
n_or = 0
n_xor = 0
n_lshift = 0
n_rshift = 0

n_iadd = 0
n_isub = 0
n_imul = 0
n_imatmul = 0
n_itruediv = 0
n_ifloordiv = 0
n_imod = 0
n_ipow = 0
n_iand = 0
n_ior = 0
n_ixor = 0
n_ilshift = 0
n_irshift = 0


</t>
<t tx="ekr.20230509052845.5109">class C:
    @others
</t>
<t tx="ekr.20230509052845.511">/// Pass that visits all values in a module.
class Operator : public Visitor {
private:
  /// IDs of previously visited nodes
  std::unordered_set&lt;id_t&gt; seen;
  /// stack of IR nodes being visited
  std::vector&lt;Node *&gt; nodeStack;
  /// stack of iterators
  std::vector&lt;decltype(SeriesFlow().begin())&gt; itStack;
  /// true if should visit children first
  bool childrenFirst;

protected:
  void defaultVisit(Node *) override {}

public:
  /// Constructs an operator.
  /// @param childrenFirst true if children should be visited first
  explicit Operator(bool childrenFirst = false) : childrenFirst(childrenFirst) {}

  virtual ~Operator() noexcept = default;

  /// This function is applied to all nodes before handling the node
  /// itself. It provides a way to write one function that gets
  /// applied to every visited node.
  /// @param node the node
  virtual void preHook(Node *node) {}
  /// This function is applied to all nodes after handling the node
  /// itself. It provides a way to write one function that gets
  /// applied to every visited node.
  /// @param node the node
  virtual void postHook(Node *node) {}

@others
};

</t>
<t tx="ekr.20230509052845.5110">def __eq__(self, other: C):
    global n_eq
    n_eq += 1
    return False

</t>
<t tx="ekr.20230509052845.5111">def __ne__(self, other: C):
    global n_ne
    n_ne += 1
    return False

</t>
<t tx="ekr.20230509052845.5112">def __lt__(self, other: C):
    global n_lt
    n_lt += 1
    return False

</t>
<t tx="ekr.20230509052845.5113">def __le__(self, other: C):
    global n_le
    n_le += 1
    return False

</t>
<t tx="ekr.20230509052845.5114">def __gt__(self, other: C):
    global n_gt
    n_gt += 1
    return False

</t>
<t tx="ekr.20230509052845.5115">def __ge__(self, other: C):
    global n_ge
    n_ge += 1
    return False

</t>
<t tx="ekr.20230509052845.5116">def __len__(self):
    global n_len
    n_len += 1
    return 42

</t>
<t tx="ekr.20230509052845.5117">def __bool__(self):
    global n_bool
    n_bool += 1
    return True

</t>
<t tx="ekr.20230509052845.5118">def __abs__(self):
    global n_abs
    n_abs += 1
    return "abs"

</t>
<t tx="ekr.20230509052845.5119">def __pos__(self):
    global n_pos
    n_pos += 1
    return "pos"

</t>
<t tx="ekr.20230509052845.512">  void visit(Module *m) override {
    nodeStack.push_back(m);
    nodeStack.push_back(m-&gt;getMainFunc());
    process(m-&gt;getMainFunc());
    nodeStack.pop_back();
    for (auto *s : *m) {
      nodeStack.push_back(s);
      process(s);
      nodeStack.pop_back();
    }
    nodeStack.pop_back();
  }

</t>
<t tx="ekr.20230509052845.5120">def __neg__(self):
    global n_neg
    n_neg += 1
    return "neg"

</t>
<t tx="ekr.20230509052845.5121">def __invert__(self):
    global n_inv
    n_inv += 1
    return "inv"

</t>
<t tx="ekr.20230509052845.5122">def __index__(self):
    global n_index
    n_index += 1
    return "index"

</t>
<t tx="ekr.20230509052845.5123">def __add__(self, other: C):
    global n_add
    n_add += 1
    return "add"

</t>
<t tx="ekr.20230509052845.5124">def __sub__(self, other: C):
    global n_sub
    n_sub += 1
    return "sub"

</t>
<t tx="ekr.20230509052845.5125">def __mul__(self, other: C):
    global n_mul
    n_mul += 1
    return "mul"

</t>
<t tx="ekr.20230509052845.5126">def __matmul__(self, other: C):
    global n_matmul
    n_matmul += 1
    return "matmul"

</t>
<t tx="ekr.20230509052845.5127">def __truediv__(self, other: C):
    global n_truediv
    n_truediv += 1
    return "truediv"

</t>
<t tx="ekr.20230509052845.5128">def __floordiv__(self, other: C):
    global n_floordiv
    n_floordiv += 1
    return "floordiv"

</t>
<t tx="ekr.20230509052845.5129">def __mod__(self, other: C):
    global n_mod
    n_mod += 1
    return "mod"

</t>
<t tx="ekr.20230509052845.513">  void visit(BodiedFunc *f) override {
    if (f-&gt;getBody()) {
      seen.insert(f-&gt;getBody()-&gt;getId());
      process(f-&gt;getBody());
    }
  }

</t>
<t tx="ekr.20230509052845.5130">def __pow__(self, other: C):
    global n_pow
    n_pow += 1
    return "pow"

</t>
<t tx="ekr.20230509052845.5131">def __and__(self, other: C):
    global n_and
    n_and += 1
    return "and"

</t>
<t tx="ekr.20230509052845.5132">def __or__(self, other: C):
    global n_or
    n_or += 1
    return "or"

</t>
<t tx="ekr.20230509052845.5133">def __xor__(self, other: C):
    global n_xor
    n_xor += 1
    return "xor"

</t>
<t tx="ekr.20230509052845.5134">def __lshift__(self, other: C):
    global n_lshift
    n_lshift += 1
    return "lshift"

</t>
<t tx="ekr.20230509052845.5135">def __rshift__(self, other: C):
    global n_rshift
    n_rshift += 1
    return "rshift"

</t>
<t tx="ekr.20230509052845.5136">def __iadd__(self, other: C):
    global n_iadd
    n_iadd += 1
    return self

</t>
<t tx="ekr.20230509052845.5137">def __isub__(self, other: C):
    global n_isub
    n_isub += 1
    return self

</t>
<t tx="ekr.20230509052845.5138">def __imul__(self, other: C):
    global n_imul
    n_imul += 1
    return self

</t>
<t tx="ekr.20230509052845.5139">def __imatmul__(self, other: C):
    global n_imatmul
    n_imatmul += 1
    return self

</t>
<t tx="ekr.20230509052845.514">  LAMBDA_VISIT(VarValue);
  LAMBDA_VISIT(PointerValue);

</t>
<t tx="ekr.20230509052845.5140">def __itruediv__(self, other: C):
    global n_itruediv
    n_itruediv += 1
    return self

</t>
<t tx="ekr.20230509052845.5141">def __ifloordiv__(self, other: C):
    global n_ifloordiv
    n_ifloordiv += 1
    return self

</t>
<t tx="ekr.20230509052845.5142">def __imod__(self, other: C):
    global n_imod
    n_imod += 1
    return self

</t>
<t tx="ekr.20230509052845.5143">def __ipow__(self, other: C):
    global n_ipow
    n_ipow += 1
    return self

</t>
<t tx="ekr.20230509052845.5144">def __iand__(self, other: C):
    global n_iand
    n_iand += 1
    return self

</t>
<t tx="ekr.20230509052845.5145">def __ior__(self, other: C):
    global n_ior
    n_ior += 1
    return self

</t>
<t tx="ekr.20230509052845.5146">def __ixor__(self, other: C):
    global n_ixor
    n_ixor += 1
    return self

</t>
<t tx="ekr.20230509052845.5147">def __ilshift__(self, other: C):
    global n_ilshift
    n_ilshift += 1
    return self

</t>
<t tx="ekr.20230509052845.5148">def __irshift__(self, other: C):
    global n_irshift
    n_irshift += 1
    return "rshift"


</t>
<t tx="ekr.20230509052845.5149">@test
def test_comparisons():
    assert apply2(eq, 1, 2, False)
    assert apply2(eq, 2, 1, False)
    assert apply2(eq, 1, 1, True)
    assert apply2(eq, 1, 1.1, False)

    assert apply2(operator.__eq__, 1, 2, False)
    assert apply2(operator.__eq__, 2, 1, False)
    assert apply2(operator.__eq__, 1, 1, True)
    assert apply2(operator.__eq__, 1, 1.1, False)

    assert apply2(ne, 1, 2, True)
    assert apply2(ne, 2, 1, True)
    assert apply2(ne, 1, 1, False)
    assert apply2(ne, 1, 1.1, True)

    assert apply2(operator.__ne__, 1, 2, True)
    assert apply2(operator.__ne__, 2, 1, True)
    assert apply2(operator.__ne__, 1, 1, False)
    assert apply2(operator.__ne__, 1, 1.1, True)

    assert apply2(lt, 1, 2, True)
    assert apply2(lt, 2, 1, False)
    assert apply2(lt, 1, 1, False)
    assert apply2(lt, 1, 1.1, True)

    assert apply2(operator.__lt__, 1, 2, True)
    assert apply2(operator.__lt__, 2, 1, False)
    assert apply2(operator.__lt__, 1, 1, False)
    assert apply2(operator.__lt__, 1, 1.1, True)

    assert apply2(le, 1, 2, True)
    assert apply2(le, 2, 1, False)
    assert apply2(le, 1, 1, True)
    assert apply2(le, 1, 1.1, True)

    assert apply2(operator.__le__, 1, 2, True)
    assert apply2(operator.__le__, 2, 1, False)
    assert apply2(operator.__le__, 1, 1, True)
    assert apply2(operator.__le__, 1, 1.1, True)

    assert apply2(gt, 1, 2, False)
    assert apply2(gt, 2, 1, True)
    assert apply2(gt, 1, 1, False)
    assert apply2(gt, 1, 1.1, False)

    assert apply2(operator.__gt__, 1, 2, False)
    assert apply2(operator.__gt__, 2, 1, True)
    assert apply2(operator.__gt__, 1, 1, False)
    assert apply2(operator.__gt__, 1, 1.1, False)

    assert apply2(ge, 1, 2, False)
    assert apply2(ge, 2, 1, True)
    assert apply2(ge, 1, 1, True)
    assert apply2(ge, 1, 1.1, False)

    assert apply2(operator.__ge__, 1, 2, False)
    assert apply2(operator.__ge__, 2, 1, True)
    assert apply2(operator.__ge__, 1, 1, True)
    assert apply2(operator.__ge__, 1, 1.1, False)

    assert apply2(eq, C(), C(), False)
    assert n_eq == 1
    assert apply2(ne, C(), C(), False)
    assert n_ne == 1
    assert apply2(lt, C(), C(), False)
    assert n_lt == 1
    assert apply2(le, C(), C(), False)
    assert n_le == 1
    assert apply2(gt, C(), C(), False)
    assert n_gt == 1
    assert apply2(ge, C(), C(), False)
    assert n_ge == 1

    assert apply2(operator.__eq__, C(), C(), False)
    assert n_eq == 2
    assert apply2(operator.__ne__, C(), C(), False)
    assert n_ne == 2
    assert apply2(operator.__lt__, C(), C(), False)
    assert n_lt == 2
    assert apply2(operator.__le__, C(), C(), False)
    assert n_le == 2
    assert apply2(operator.__gt__, C(), C(), False)
    assert n_gt == 2
    assert apply2(operator.__ge__, C(), C(), False)
    assert n_ge == 2


</t>
<t tx="ekr.20230509052845.515">  void visit(codon::ir::SeriesFlow *v) override {
    if (childrenFirst)
      processSeriesFlowChildren(v);
    preHook(v);
    handle(v);
    postHook(v);
    if (!childrenFirst)
      processSeriesFlowChildren(v);
  }

</t>
<t tx="ekr.20230509052845.5150">test_comparisons()


</t>
<t tx="ekr.20230509052845.5151">class A1:
    def __bool__(self):
        return True

    def __len__(self):
        return 0


</t>
<t tx="ekr.20230509052845.5152">class A2:
    def __len__(self):
        return 42


</t>
<t tx="ekr.20230509052845.5153">@test
def test_truthiness():
    assert truth(1)
    assert not truth(0)
    assert not_(False)
    assert not not_(True)
    assert not not_(A1())
    assert not not_(A2())

    a = A1()
    b = A1()

    assert is_(a, a)
    assert not is_(a, b)
    assert is_not(a, b)
    assert not is_not(a, a)

    assert truth(C())
    assert n_bool == 1


</t>
<t tx="ekr.20230509052845.5154">test_truthiness()


</t>
<t tx="ekr.20230509052845.5155">@test
def test_ops():
    x = C()
    y = C()

    assert abs(x) == "abs"
    assert n_abs == 1
    assert operator.__abs__(x) == "abs"
    assert n_abs == 2

    assert pos(x) == "pos"
    assert n_pos == 1
    assert operator.__pos__(x) == "pos"
    assert n_pos == 2

    assert neg(x) == "neg"
    assert n_neg == 1
    assert operator.__neg__(x) == "neg"
    assert n_neg == 2

    assert inv(x) == "inv"
    assert n_inv == 1
    assert operator.__inv__(x) == "inv"
    assert n_inv == 2
    assert invert(x) == "inv"
    assert n_inv == 3
    assert operator.__invert__(x) == "inv"
    assert n_inv == 4

    assert index(x) == "index"
    assert n_index == 1
    assert operator.__index__(x) == "index"
    assert n_index == 2

    assert add(x, y) == "add"
    assert n_add == 1
    assert operator.__add__(x, y) == "add"
    assert n_add == 2

    assert iadd(x, y) is x
    assert n_iadd == 1
    assert operator.__iadd__(x, y) is x
    assert n_iadd == 2

    assert sub(x, y) == "sub"
    assert n_sub == 1
    assert operator.__sub__(x, y) == "sub"
    assert n_sub == 2

    assert isub(x, y) is x
    assert n_isub == 1
    assert operator.__isub__(x, y) is x
    assert n_isub == 2

    assert mul(x, y) == "mul"
    assert n_mul == 1
    assert operator.__mul__(x, y) == "mul"
    assert n_mul == 2

    assert imul(x, y) is x
    assert n_imul == 1
    assert operator.__imul__(x, y) is x
    assert n_imul == 2

    assert matmul(x, y) == "matmul"
    assert n_matmul == 1
    assert operator.__matmul__(x, y) == "matmul"
    assert n_matmul == 2

    assert imatmul(x, y) is x
    assert n_imatmul == 1
    assert operator.__imatmul__(x, y) is x
    assert n_imatmul == 2

    assert truediv(x, y) == "truediv"
    assert n_truediv == 1
    assert operator.__truediv__(x, y) == "truediv"
    assert n_truediv == 2

    assert itruediv(x, y) is x
    assert n_itruediv == 1
    assert operator.__itruediv__(x, y) is x
    assert n_itruediv == 2

    assert floordiv(x, y) == "floordiv"
    assert n_floordiv == 1
    assert operator.__floordiv__(x, y) == "floordiv"
    assert n_floordiv == 2

    assert ifloordiv(x, y) is x
    assert n_ifloordiv == 1
    assert operator.__ifloordiv__(x, y) is x
    assert n_ifloordiv == 2

    assert mod(x, y) == "mod"
    assert n_mod == 1
    assert operator.__mod__(x, y) == "mod"
    assert n_mod == 2

    assert imod(x, y) is x
    assert n_imod == 1
    assert operator.__imod__(x, y) is x
    assert n_imod == 2

    assert pow(x, y) == "pow"
    assert n_pow == 1
    assert operator.__pow__(x, y) == "pow"
    assert n_pow == 2

    assert ipow(x, y) is x
    assert n_ipow == 1
    assert operator.__ipow__(x, y) is x
    assert n_ipow == 2

    assert and_(x, y) == "and"
    assert n_and == 1
    assert operator.__and__(x, y) == "and"
    assert n_and == 2

    assert iand(x, y) is x
    assert n_iand == 1
    assert operator.__iand__(x, y) is x
    assert n_iand == 2

    assert or_(x, y) == "or"
    assert n_or == 1
    assert operator.__or__(x, y) == "or"
    assert n_or == 2

    assert ior(x, y) is x
    assert n_ior == 1
    assert operator.__ior__(x, y) is x
    assert n_ior == 2

    assert xor(x, y) == "xor"
    assert n_xor == 1
    assert operator.__xor__(x, y) == "xor"
    assert n_xor == 2

    assert ixor(x, y) is x
    assert n_ixor == 1
    assert operator.__ixor__(x, y) is x
    assert n_ixor == 2

    assert lshift(x, y) == "lshift"
    assert n_lshift == 1
    assert operator.__lshift__(x, y) == "lshift"
    assert n_lshift == 2

    assert ilshift(x, y) is x
    assert n_ilshift == 1
    assert operator.__ilshift__(x, y) is x
    assert n_ilshift == 2

    assert rshift(x, y) == "rshift"
    assert n_rshift == 1
    assert operator.__rshift__(x, y) == "rshift"
    assert n_rshift == 2

    assert irshift(x, y) is x
    assert n_irshift == 1
    assert operator.__irshift__(x, y) is x
    assert n_irshift == 2


</t>
<t tx="ekr.20230509052845.5156">test_ops()


</t>
<t tx="ekr.20230509052845.5157">class B1:
    def __length_hint__(self):
        return 101


</t>
<t tx="ekr.20230509052845.5158">class B2:
    def __length_hint__(self):
        return 202

    def __len__(self):
        return 303


</t>
<t tx="ekr.20230509052845.5159">class B3:
    pass


</t>
<t tx="ekr.20230509052845.516">  virtual void handle(codon::ir::SeriesFlow *v) {}
  LAMBDA_VISIT(IfFlow);
  LAMBDA_VISIT(WhileFlow);
  LAMBDA_VISIT(ForFlow);
  LAMBDA_VISIT(ImperativeForFlow);
  LAMBDA_VISIT(TryCatchFlow);
  LAMBDA_VISIT(PipelineFlow);
  LAMBDA_VISIT(dsl::CustomFlow);

  LAMBDA_VISIT(TemplatedConst&lt;int64_t&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;double&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;bool&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;std::string&gt;);
  LAMBDA_VISIT(dsl::CustomConst);

  LAMBDA_VISIT(Instr);
  LAMBDA_VISIT(AssignInstr);
  LAMBDA_VISIT(ExtractInstr);
  LAMBDA_VISIT(InsertInstr);
  LAMBDA_VISIT(CallInstr);
  LAMBDA_VISIT(StackAllocInstr);
  LAMBDA_VISIT(TypePropertyInstr);
  LAMBDA_VISIT(YieldInInstr);
  LAMBDA_VISIT(TernaryInstr);
  LAMBDA_VISIT(BreakInstr);
  LAMBDA_VISIT(ContinueInstr);
  LAMBDA_VISIT(ReturnInstr);
  LAMBDA_VISIT(YieldInstr);
  LAMBDA_VISIT(ThrowInstr);
  LAMBDA_VISIT(FlowInstr);
  LAMBDA_VISIT(dsl::CustomInstr);

  template &lt;typename Node&gt; void process(Node *v) { v-&gt;accept(*this); }

  /// Return the parent of the current node.
  /// @param level the number of levels up from the current node
  template &lt;typename Desired = Node&gt; Desired *getParent(int level = 0) {
    return cast&lt;Desired&gt;(nodeStack[nodeStack.size() - level - 1]);
  }
  /// @return current depth in the tree
  int depth() const { return nodeStack.size(); }

  /// @tparam Desired the desired type
  /// @return the last encountered example of the desired type
  template &lt;typename Desired&gt; Desired *findLast() {
    for (auto it = nodeStack.rbegin(); it != nodeStack.rend(); ++it) {
      if (auto *v = cast&lt;Desired&gt;(*it))
        return v;
    }
    return nullptr;
  }
  /// @return the last encountered function
  Func *getParentFunc() { return findLast&lt;Func&gt;(); }

  /// @return an iterator to the first parent
  auto parent_begin() const { return nodeStack.begin(); }
  /// @return an iterator beyond the last parent
  auto parent_end() const { return nodeStack.end(); }

  /// @param v the value
  /// @return whether we have visited ("seen") the given value
  bool saw(const Value *v) const { return seen.find(v-&gt;getId()) != seen.end(); }
  /// Avoid visiting the given value in the future.
  /// @param v the value
  void see(const Value *v) { seen.insert(v-&gt;getId()); }

</t>
<t tx="ekr.20230509052845.5160">@test
def test_sequence_ops():
    assert concat([1, 2], [3, 4]) == [1, 2, 3, 4]
    assert operator.__concat__([1, 2], [3, 4]) == [1, 2, 3, 4]
    assert contains([1, 2, 3], 2)
    assert not contains([1, 2, 3], 0)
    assert operator.__contains__([1, 2, 3], 2)
    assert not operator.__contains__([1, 2, 3], 0)
    assert countOf([1, 2, 1, 1], 1) == 3

    v = [1, 2, 3]
    assert getitem(v, 1) == 2
    delitem(v, 1)
    assert v == [1, 3]
    setitem(v, 1, 99)
    assert v == [1, 99]

    assert length_hint(B1()) == 101
    assert length_hint(B2()) == 303
    assert length_hint(B3()) == 0
    assert length_hint(B3(), default=404) == 404

    assert itemgetter(-1)([11, 22, 33]) == 33
    assert itemgetter(-1, -2, -3)([11, 22, 33]) == (33, 22, 11)


</t>
<t tx="ekr.20230509052845.5161">test_sequence_ops()


</t>
<t tx="ekr.20230509052845.5162">class C:
    foo: int

    @others
</t>
<t tx="ekr.20230509052845.5163">def __init__(self, foo):
    self.foo = foo

</t>
<t tx="ekr.20230509052845.5164">def bar(self, k, m, n):
    return self.foo + k + m*100 + n*1000


</t>
<t tx="ekr.20230509052845.5165">@test
def test_getter_ops():
    v = ['a']
    operator.attrgetter('append')(v)('hello')
    operator.methodcaller('append', 'goodbye')(v)
    assert v == ['a', 'hello', 'goodbye']

    c = C(10)
    assert operator.attrgetter('foo')(c) == 10
    assert operator.methodcaller('bar', 9, n=7, m=3)(c) == 7319


</t>
<t tx="ekr.20230509052845.5166">@path C:/Repos/codon/test/stdlib/
import random as R
import time
import sys
from copy import copy

seed = int(time.time())
# sys.stderr.write('seed: ' + str(seed) + '\n')
R.seed(seed)


@others
test_state()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5167">@test
def test_rnd_result(name, results, invariant):
    print(name)
    for a in results:
        assert invariant(a)


</t>
<t tx="ekr.20230509052845.5168">test_rnd_result(
    "randrange", [R.randrange(10) for _ in range(100)], range(10).__contains__
)
test_rnd_result(
    "randrange", [R.randrange(5, 20) for _ in range(100)], range(5, 20).__contains__
)
test_rnd_result(
    "randrange",
    [R.randrange(9, 99, 3) for _ in range(100)],
    range(9, 99, 3).__contains__,
)
test_rnd_result(
    "randint", [R.randint(5, 20) for _ in range(100)], range(5, 20 + 1).__contains__
)

population = list("ABCDEFGHIJKLMNOP")
test_rnd_result(
    "choice", [R.choice(population) for _ in range(100)], population.__contains__
)
test_rnd_result(
    "choice", [R.choice(population) for _ in range(100)], population.__contains__
)
test_rnd_result("choices", R.choices(population), population.__contains__)
test_rnd_result("choices", R.choices(population, k=100), population.__contains__)


</t>
<t tx="ekr.20230509052845.5169">@test
def test_shuffle(v):
    s = copy(v)
    R.shuffle(s)
    assert sorted(v) == sorted(s)


</t>
<t tx="ekr.20230509052845.517">  /// Inserts the new value before the current position in the last seen SeriesFlow.
  /// @param v the new value
  auto insertBefore(Value *v) {
    return findLast&lt;SeriesFlow&gt;()-&gt;insert(itStack.back(), v);
  }
</t>
<t tx="ekr.20230509052845.5170">test_shuffle(list(range(100)))


</t>
<t tx="ekr.20230509052845.5171">@test
def test_sample(n: int, k: int):
    s = R.sample(list(range(n)), k=k)
    assert len(s) == k
    assert len(set(s)) == len(s)
    for a in s:
        assert a in range(n)


</t>
<t tx="ekr.20230509052845.5172">test_sample(100, 5)
test_sample(100, 100)
test_sample(100, 0)


from python import random as Rpy

</t>
<t tx="ekr.20230509052845.5173">@test
def test_vs_python(*args, seed, method: Static[str], T: type = float):
    print(seed, method, args)
    R1 = R.Random(seed)
    R2 = Rpy.Random(seed)

    N = 50
    A1 = [T(getattr(R1, method)(*args)) for _ in range(N)]
    A2 = [T.__from_py__(getattr(R2, method)(*args).p) for _ in range(N)]
    assert A1 == A2

</t>
<t tx="ekr.20230509052845.5174">test_vs_python(-10, 10, seed=22, method='randrange', T=int)
test_vs_python(-10, 10, 3, seed=33, method='randrange', T=int)
test_vs_python(-10, 10, seed=44, method='randint', T=int)
test_vs_python(20, seed=55, method='getrandbits', T=int)
test_vs_python(32, seed=55, method='getrandbits', T=int)
test_vs_python(40, seed=55, method='getrandbits', T=int)
test_vs_python(63, seed=55, method='getrandbits', T=int)
test_vs_python(seed=0, method='random')
test_vs_python(-12.5, 101.2, seed=1, method='uniform')
test_vs_python(-13, 5.5, 0, seed=2, method='triangular')
#test_vs_python(1.0, 2, seed=3, method='betavariate')  # different in older Python versions
test_vs_python(0.3, seed=4, method='expovariate')
#test_vs_python(1.0, 2, seed=5, method='gammavariate')  # different in older Python versions
test_vs_python(1.0, 2.0, seed=-101, method='gauss')
test_vs_python(1.0, 2.0, seed=-102, method='lognormvariate')
test_vs_python(1.0, 2.0, seed=-103, method='normalvariate')
test_vs_python(1.0, 2.0, seed=0xffffffff, method='vonmisesvariate')
test_vs_python(1.0, seed=0xffffffff-1, method='paretovariate')
test_vs_python(1.0, 2.0, seed=0, method='weibullvariate')


</t>
<t tx="ekr.20230509052845.5175">@test
def test_state():
    r = R.Random(1234)
    state = r.getstate()
    N = 100
    A1 = [r.random() for _ in range(N)]
    B1 = [r.gauss() for _ in range(N)]
    r.setstate(state)
    A2 = [r.random() for _ in range(N)]
    B2 = [r.gauss() for _ in range(N)]
    r.seed(1234)
    A3 = [r.random() for _ in range(N)]
    B3 = [r.gauss() for _ in range(N)]

    assert A1 == A2 == A3
    assert B1 == B2 == B3

</t>
<t tx="ekr.20230509052845.5176">@path C:/Repos/codon/test/stdlib/
import re
import string

@others
test_re_escape()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5177">@test
def test_search_star_plus():
    assert re.search('x*', 'axx').span(0) == (0, 0)
    assert re.search('x*', 'axx').span() == (0, 0)
    assert re.search('x+', 'axx').span(0) == (1, 3)
    assert re.search('x+', 'axx').span() == (1, 3)
    assert re.search('x', 'aaa') is None
    assert re.match('a*', 'xxx').span(0) == (0, 0)
    assert re.match('a*', 'xxx').span() == (0, 0)
    assert re.match('x*', 'xxxa').span(0) == (0, 3)
    assert re.match('x*', 'xxxa').span() == (0, 3)
    assert re.match('a+', 'xxx') is None
</t>
<t tx="ekr.20230509052845.5178">test_search_star_plus()

</t>
<t tx="ekr.20230509052845.5179">@test
def test_branching():
    """Test Branching
    Test expressions using the OR ('|') operator."""
    assert re.match('(ab|ba)', 'ab').span() == (0, 2)
    assert re.match('(ab|ba)', 'ba').span() == (0, 2)
    assert re.match('(abc|bac|ca|cb)', 'abc').span() == (0, 3)
    assert re.match('(abc|bac|ca|cb)', 'bac').span() == (0, 3)
    assert re.match('(abc|bac|ca|cb)', 'ca').span() == (0, 2)
    assert re.match('(abc|bac|ca|cb)', 'cb').span() == (0, 2)
    assert re.match('((a)|(b)|(c))', 'a').span() == (0, 1)
    assert re.match('((a)|(b)|(c))', 'b').span() == (0, 1)
    assert re.match('((a)|(b)|(c))', 'c').span() == (0, 1)
</t>
<t tx="ekr.20230509052845.518">  /// Inserts the new value after the current position in the last seen SeriesFlow.
  /// @param v the new value, which is marked seen
  auto insertAfter(Value *v) {
    auto newPos = itStack.back();
    ++newPos;
    see(v);

    return findLast&lt;SeriesFlow&gt;()-&gt;insert(newPos, v);
  }

</t>
<t tx="ekr.20230509052845.5180">test_branching()

</t>
<t tx="ekr.20230509052845.5181">@test
def test_basic_re_sub():
    @others
    assert re.sub('y', 'a', 'xyz') == 'xaz'

    assert re.sub("(?i)b+", "x", "bbbb BBBB") == 'x x'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y') == '9.3 -3 24x100y'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y', 3) == '9.3 -3 23x99y'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y', count=3) == '9.3 -3 23x99y'

    assert re.sub('.', lambda m: r"\n", 'x') == '\\n'
    assert re.sub('.', r"\n", 'x') == '\n'

    s = r"\1\1"
    assert re.sub('(.)', s, 'x') == 'xx'
    assert re.sub('(.)', s.replace('\\', r'\\'), 'x') == s
    assert re.sub('(.)', lambda m: s, 'x') == s

    assert re.sub('(?P&lt;a&gt;x)', r'\g&lt;a&gt;\g&lt;a&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;a&gt;x)', r'\g&lt;a&gt;\g&lt;1&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;unk&gt;x)', r'\g&lt;unk&gt;\g&lt;unk&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;unk&gt;x)', r'\g&lt;1&gt;\g&lt;1&gt;', 'xx') == 'xxxx'
    assert re.sub('()x', r'\g&lt;0&gt;\g&lt;0&gt;', 'xx') == 'xxxx'

    assert re.sub('a', r'\t\n\v\r\f\a\b', 'a') == '\t\n\v\r\f\a\b'
    assert re.sub('a', '\t\n\v\r\f\a\b', 'a') == '\t\n\v\r\f\a\b'
    assert re.sub('a', '\t\n\v\r\f\a\b', 'a') == (chr(9)+chr(10)+chr(11)+chr(13)+chr(12)+chr(7)+chr(8))
    for c in 'cdehijklmopqsuwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
        try:
            re.sub('a', '\\' + c, 'a')
            assert False
        except re.error:
            pass
    assert re.sub(r'^\s*', 'X', 'test') == 'Xtest'
</t>
<t tx="ekr.20230509052845.5182">def bump_num(matchobj):
    int_value = int(matchobj.group(0))
    return str(int_value + 1)

</t>
<t tx="ekr.20230509052845.5183">test_basic_re_sub()

</t>
<t tx="ekr.20230509052845.5184">@test
def test_bug_449964():
    assert re.sub(r'(?P&lt;unk&gt;x)', r'\g&lt;1&gt;\g&lt;1&gt;\b', 'xx') == 'xx\bxx\b'
</t>
<t tx="ekr.20230509052845.5185">test_bug_449964()

</t>
<t tx="ekr.20230509052845.5186">@test
def test_bug_449000():
    # Test for sub() on escaped characters
    assert re.sub(r'\r\n', r'\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
    assert re.sub('\r\n', r'\n', 'abc\r\ndef\r\n') =='abc\ndef\n'
    assert re.sub(r'\r\n', '\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
    assert re.sub('\r\n', '\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
</t>
<t tx="ekr.20230509052845.5187">test_bug_449000()

</t>
<t tx="ekr.20230509052845.5188">@test
def test_sub_template_numeric_escape():
    # bug 776311 and friends
    assert re.sub('x', r'\0', 'x') == '\0'
    assert re.sub('x', r'\000', 'x') == '\000'
    assert re.sub('x', r'\001', 'x') == '\001'
    assert re.sub('x', r'\008', 'x') == '\0' + '8'
    assert re.sub('x', r'\009', 'x') == '\0' + '9'
    assert re.sub('x', r'\111', 'x') == '\111'
    assert re.sub('x', r'\117', 'x') == '\117'
    assert re.sub('x', r'\377', 'x') == '\377'

    assert re.sub('x', r'\1111', 'x'), '\1111'
    assert re.sub('x', r'\1111', 'x'), '\111' + '1'

    assert re.sub('x', r'\00', 'x') == '\x00'
    assert re.sub('x', r'\07', 'x') == '\x07'
    assert re.sub('x', r'\08', 'x') == '\0' + '8'
    assert re.sub('x', r'\09', 'x') == '\0' + '9'
    assert re.sub('x', r'\0a', 'x') == '\0' + 'a'

    '''
    self.checkTemplateError('x', r'\400', 'x',
                            r'octal escape value \400 outside of '
                            r'range 0-0o377', 0)
    self.checkTemplateError('x', r'\777', 'x',
                            r'octal escape value \777 outside of '
                            r'range 0-0o377', 0)

    self.checkTemplateError('x', r'\1', 'x', 'invalid group reference 1', 1)
    self.checkTemplateError('x', r'\8', 'x', 'invalid group reference 8', 1)
    self.checkTemplateError('x', r'\9', 'x', 'invalid group reference 9', 1)
    self.checkTemplateError('x', r'\11', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\18', 'x', 'invalid group reference 18', 1)
    self.checkTemplateError('x', r'\1a', 'x', 'invalid group reference 1', 1)
    self.checkTemplateError('x', r'\90', 'x', 'invalid group reference 90', 1)
    self.checkTemplateError('x', r'\99', 'x', 'invalid group reference 99', 1)
    self.checkTemplateError('x', r'\118', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\11a', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\181', 'x', 'invalid group reference 18', 1)
    self.checkTemplateError('x', r'\800', 'x', 'invalid group reference 80', 1)
    self.checkTemplateError('x', r'\8', '', 'invalid group reference 8', 1)
    '''

    assert re.sub('(((((((((((x)))))))))))', r'\11', 'x') == 'x'
    assert re.sub('((((((((((y))))))))))(.)', r'\118', 'xyz') == 'xz8'
    assert re.sub('((((((((((y))))))))))(.)', r'\11a', 'xyz') == 'xza'
</t>
<t tx="ekr.20230509052845.5189">test_sub_template_numeric_escape()

</t>
<t tx="ekr.20230509052845.519">  /// Resets the operator.
  void reset() {
    seen.clear();
    nodeStack.clear();
    itStack.clear();
  }

</t>
<t tx="ekr.20230509052845.5190">@test
def test_qualified_re_sub():
    assert re.sub('a', 'b', 'aaaaa') == 'bbbbb'
    assert re.sub('a', 'b', 'aaaaa', 1) == 'baaaa'
    assert re.sub('a', 'b', 'aaaaa', count=1) == 'baaaa'
</t>
<t tx="ekr.20230509052845.5191">test_qualified_re_sub()

</t>
<t tx="ekr.20230509052845.5192">@test
def test_bug_114660():
    assert re.sub(r'(\S)\s+(\S)', r'\1 \2', 'hello  there') == 'hello there'
</t>
<t tx="ekr.20230509052845.5193">test_bug_114660()

</t>
<t tx="ekr.20230509052845.5194">@test
def test_symbolic_refs():
    assert re.sub('(?P&lt;a&gt;x)|(?P&lt;b&gt;y)', r'\g&lt;b&gt;', 'xx') == ''
    assert re.sub('(?P&lt;a&gt;x)|(?P&lt;b&gt;y)', r'\2', 'xx') == ''
    # Support &gt; 100 groups.
    pat = '|'.join(f'x(?P&lt;a{i}&gt;{hex(i)[2:]})y' for i in range(1, 200 + 1))
    assert re.sub(pat, r'\g&lt;200&gt;', 'xc8yzxc8y') == 'c8zc8'
</t>
<t tx="ekr.20230509052845.5195">test_symbolic_refs()

</t>
<t tx="ekr.20230509052845.5196">@test
def test_re_subn():
    assert re.subn("(?i)b+", "x", "bbbb BBBB") == ('x x', 2)
    assert re.subn("b+", "x", "bbbb BBBB") == ('x BBBB', 1)
    assert re.subn("b+", "x", "xyz") == ('xyz', 0)
    assert re.subn("b*", "x", "xyz") == ('xxxyxzx', 4)
    assert re.subn("b*", "x", "xyz", 2) == ('xxxyz', 2)
    assert re.subn("b*", "x", "xyz", count=2) == ('xxxyz', 2)
</t>
<t tx="ekr.20230509052845.5197">test_re_subn()

</t>
<t tx="ekr.20230509052845.5198"># TODO: Current version does not allow None == None,
#       so use this as a workaround.
def cmp_opt(x, y):
    if x is None:
        return y is None
    elif y is None:
        return x is None
    else:
        return unwrap(x) == unwrap(y)

</t>
<t tx="ekr.20230509052845.5199">def cmp_list(a, b):
    if len(a) != len(b):
        return False

    for i in range(len(a)):
        if not cmp_opt(a[i], b[i]):
            return False

    return True

</t>
<t tx="ekr.20230509052845.52">def linear_combination(self, other, l1, l2=None):
    if l2 is None:
        l2 = 1 - l1
    v = GVector(self.x * l1 + other.x * l2,
                self.y * l1 + other.y * l2,
                self.z * l1 + other.z * l2)
    return v

</t>
<t tx="ekr.20230509052845.520">private:
</t>
<t tx="ekr.20230509052845.5200">def cmp_tuple(a, b):
    if staticlen(a) != staticlen(b):
        return False
    elif staticlen(a) == 0:
        return True
    else:
        if not cmp_opt(a[0], b[0]):
            return False
        return cmp_tuple(a[1:], b[1:])

</t>
<t tx="ekr.20230509052845.5201">@test
def test_re_split():
    assert cmp_list(re.split(":", ":a:b::c"), ['', 'a', 'b', '', 'c'])
    assert cmp_list(re.split(":+", ":a:b::c"), ['', 'a', 'b', 'c'])
    assert cmp_list(re.split("(:+)", ":a:b::c"), ['', ':', 'a', ':', 'b', '::', 'c'])

    assert cmp_list(re.split("(?::+)", ":a:b::c"), ['', 'a', 'b', 'c'])
    assert cmp_list(re.split("(:)+", ":a:b::c"), ['', ':', 'a', ':', 'b', ':', 'c'])
    assert cmp_list(re.split("([b:]+)", ":a:b::c"), ['', ':', 'a', ':b::', 'c'])
    assert cmp_list(re.split("(b)|(:+)", ":a:b::c"), [None, '', None, ':', 'a', None, ':', '', 'b', None, '', None, '::', 'c'][1:])
    assert cmp_list(re.split("(?:b)|(?::+)", ":a:b::c"), ['', 'a', '', '', 'c'])

    for sep, expected in [
        (':*', [None, '', '', 'a', '', 'b', '', 'c', ''][1:]),
        ('(?::*)', [None, '', '', 'a', '', 'b', '', 'c', ''][1:]),
        ('(:*)', [None, '', ':', '', '', 'a', ':', '', '', 'b', '::', '', '', 'c', '', ''][1:]),
        ('(:)*', [None, '', ':', '', None, 'a', ':', '', None, 'b', ':', '', None, 'c', None, ''][1:]),
    ]:
        assert cmp_list(re.split(sep, ':a:b::c'), expected)

    for sep, expected in [
        ('', ['', ':', 'a', ':', 'b', ':', ':', 'c', '']),
        # (r'\b', [':', 'a', ':', 'b', '::', 'c', '']),  # TODO: this fails; re2 difference maybe?
    ]:
        assert cmp_list(re.split(sep, ':a:b::c'), expected)
</t>
<t tx="ekr.20230509052845.5202">test_re_split()

</t>
<t tx="ekr.20230509052845.5203">@test
def test_qualified_re_split():
    assert cmp_list(re.split(":", ":a:b::c", 2), ['', 'a', 'b::c'])
    assert cmp_list(re.split(":", ":a:b::c", maxsplit=2), ['', 'a', 'b::c'])
    assert cmp_list(re.split(':', 'a:b:c:d', maxsplit=2), ['a', 'b', 'c:d'])
    assert cmp_list(re.split("(:)", ":a:b::c", maxsplit=2), ['', ':', 'a', ':', 'b::c'])
    assert cmp_list(re.split("(:+)", ":a:b::c", maxsplit=2), ['', ':', 'a', ':', 'b::c'])
    assert cmp_list(re.split("(:*)", ":a:b::c", maxsplit=2), ['', ':', '', '', 'a:b::c'])
</t>
<t tx="ekr.20230509052845.5204">test_qualified_re_split()

</t>
<t tx="ekr.20230509052845.5205">@test
def test_re_findall():
    assert re.findall(":+", "abc") == []
    assert re.findall(":+", "a:b::c:::d") == [":", "::", ":::"]
    assert re.findall("(:+)", "a:b::c:::d") == [":", "::", ":::"]
    # (!) Note: this is different in Codon, as we always return the full match even
    #           if there are capturing groups.
    assert re.findall("(:)(:*)", "a:b::c:::d") == [":", "::", ":::"]

    x = "\xe0"
    xx = x * 2
    xxx = x * 3
    string = f"a{x}b{xx}c{xxx}d"
    assert re.findall(f"{x}+", string) == [x, xx, xxx]
    assert re.findall(f"({x}+)", string) == [x, xx, xxx]
    # (!) Note: same as above.
    assert re.findall(f"({x})({x}*)", string) == [x, xx, xxx]
</t>
<t tx="ekr.20230509052845.5206">test_re_findall()

</t>
<t tx="ekr.20230509052845.5207">@test
def test_re_match():
    assert cmp_list(re.match('a', 'a').groups(), List[Optional[str]]())
    assert cmp_list(re.match('(a)', 'a').groups(), [None, 'a',][1:])
    assert re.match('(a)', 'a').group(0).__val__() == 'a'
    assert re.match('(a)', 'a').group(1).__val__() == 'a'
    assert re.match('(a)', 'a').group(1, 1) == (Optional('a'), Optional('a'))
    assert cmp_list(re.match('\xe0', '\xe0').groups(), List[Optional[str]]())
    assert cmp_list(re.match('(\xe0)', '\xe0').groups(), ['\xe0'])
    assert unwrap(re.match('(\xe0)', '\xe0').group(0)) == '\xe0'
    assert unwrap(re.match('(\xe0)', '\xe0').group(1)) == '\xe0'
    assert re.match('(\xe0)', '\xe0').group(1, 1) == (Optional('\xe0'), Optional('\xe0'))

    pat = re.compile('((a)|(b))(c)?')
    assert cmp_list(pat.match('a').groups(), [None, 'a', 'a', None, None][1:])
    assert cmp_list(pat.match('b').groups(), [None, 'b', None, 'b', None][1:])
    assert cmp_list(pat.match('ac').groups(), [None, 'a', 'a', None, 'c'][1:])
    assert cmp_list(pat.match('bc').groups(), [None, 'b', None, 'b', 'c'][1:])
    assert cmp_list(pat.match('bc').groups(""), [None, 'b', "", 'b', 'c'][1:])

    pat = re.compile('(?:(?P&lt;a1&gt;a)|(?P&lt;b2&gt;b))(?P&lt;c3&gt;c)?')
    assert cmp_tuple(pat.match('a').group(1, 2, 3), (Optional('a'), Optional[str](), Optional[str]()))
    assert cmp_tuple(pat.match('b').group('a1', 'b2', 'c3'), (Optional[str](), Optional('b'), Optional[str]()))
    assert cmp_tuple(pat.match('ac').group(1, 'b2', 3), (Optional('a'), Optional[str](), Optional('c')))
</t>
<t tx="ekr.20230509052845.5208">test_re_match()

</t>
<t tx="ekr.20230509052845.5209">def raises(exception: type, function, *args, **kwargs):
    try:
        function(*args, **kwargs)
    except exception:
        return True
    except:
        pass
    return False

</t>
<t tx="ekr.20230509052845.521">  void processChildren(Value *v) {
    nodeStack.push_back(v);
    for (auto *c : v-&gt;getUsedValues()) {
      if (saw(c))
        continue;
      see(c);
      process(c);
    }
    nodeStack.pop_back();
  }

</t>
<t tx="ekr.20230509052845.5210">@test
def test_group():
    @others
    # A single group
    m = re.match('(a)(b)', 'ab')
    assert m.group() == 'ab'
    assert unwrap(m.group(0)) == 'ab'
    assert unwrap(m.group(1)) == 'a'
    assert unwrap(m.group(Index(1))) == 'a'
    assert raises(IndexError, m.group, -1)
    assert raises(IndexError, m.group, 3)
    assert raises(IndexError, m.group, 1&lt;&lt;1000)
    assert raises(IndexError, m.group, Index(1&lt;&lt;1000))
    assert raises(IndexError, m.group, 'x')
    # Multiple groups
    assert cmp_tuple(m.group(2, 1), ('b', 'a'))
    assert cmp_tuple(m.group(Index(2), Index(1)), ('b', 'a'))
</t>
<t tx="ekr.20230509052845.5211">class Index:
    value: int
    def __init__(self, value):
        self.value = value
    def __index__(self):
        return self.value
</t>
<t tx="ekr.20230509052845.5212">test_group()

</t>
<t tx="ekr.20230509052845.5213">@test
def test_match_getitem():
    pat = re.compile('(?:(?P&lt;a1&gt;a)|(?P&lt;b2&gt;b))(?P&lt;c3&gt;c)?')

    m = pat.match('a')
    assert unwrap(m['a1']) == 'a'
    assert m['b2'] is None
    assert m['c3'] is None
    assert unwrap(m[0]) == 'a'
    assert unwrap(m[1]) == 'a'
    assert m[2] is None
    assert m[3] is None

    assert raises(IndexError, lambda i: m[i], 'X')
    assert raises(IndexError, lambda i: m[i], -1)
    assert raises(IndexError, lambda i: m[i], 4)

    m = pat.match('ac')
    assert unwrap(m['a1']) == 'a'
    assert m['b2'] is None
    assert unwrap(m['c3']) == 'c'
    assert unwrap(m[0]) == 'ac'
    assert unwrap(m[1]) == 'a'
    assert m[2] is None
    assert unwrap(m[3]) == 'c'
</t>
<t tx="ekr.20230509052845.5214">test_match_getitem()

</t>
<t tx="ekr.20230509052845.5215">@test
def test_re_fullmatch():
    assert re.fullmatch(r"a", "a").span() == (0, 1)
    assert re.fullmatch(r"a|ab", "ab").span() == (0, 2)
    assert re.fullmatch("\xe0|\xe0\xdf", "\xe0\xdf").span() == (0, 2)

    assert re.fullmatch(r".*?$", "abc").span() == (0, 3)
    assert re.fullmatch(r".*?", "abc").span() == (0, 3)
    assert re.fullmatch(r"a.*?b", "ab").span() == (0, 2)
    assert re.fullmatch(r"a.*?b", "abb").span() == (0, 3)
    assert re.fullmatch(r"a.*?b", "axxb").span() == (0, 4)
    assert re.fullmatch(r"a+", "ab") is None
    assert re.fullmatch(r"abc$", "abc\n") is None
    assert re.fullmatch(r"(?m)abc$", "abc\n") is None

    assert re.compile(r"bc").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
    # TODO: following fails; $ does not respect endpos in re2?
    #assert re.compile(r".*?$").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
    assert re.compile(r".*?").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
</t>
<t tx="ekr.20230509052845.5216">test_re_fullmatch()

</t>
<t tx="ekr.20230509052845.5217">@test
def test_finditer():
    iter = re.finditer(r":+", "a:b::c:::d")
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", 1, 10)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", pos=1, endpos=10)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", endpos=10, pos=1)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", pos=3, endpos=8)
    assert cmp_list([item.group(0) for item in iter], ["::", "::"])
</t>
<t tx="ekr.20230509052845.5218">test_finditer()

</t>
<t tx="ekr.20230509052845.5219">@test
def test_constants():
    assert re.I == re.IGNORECASE
    assert re.L == re.LOCALE
    assert re.M == re.MULTILINE
    assert re.S == re.DOTALL
    assert re.X == re.VERBOSE
</t>
<t tx="ekr.20230509052845.522">  void processSeriesFlowChildren(codon::ir::SeriesFlow *v) {
    nodeStack.push_back(v);
    for (auto it = v-&gt;begin(); it != v-&gt;end(); ++it) {
      itStack.push_back(it);
      process(*it);
      itStack.pop_back();
    }
    nodeStack.pop_back();
  }
</t>
<t tx="ekr.20230509052845.5220">test_constants()

</t>
<t tx="ekr.20230509052845.5221">@test
def test_anyall():
    assert unwrap(re.match("a.b", "a\nb", re.DOTALL).group(0)) == "a\nb"
    assert unwrap(re.match("a.*b", "a\n\nb", re.DOTALL).group(0)) == "a\n\nb"
</t>
<t tx="ekr.20230509052845.5222">test_anyall()

</t>
<t tx="ekr.20230509052845.5223">@test
def test_groupdict():
    d = re.match('(?P&lt;first&gt;first) (?P&lt;second&gt;second)', 'first second').groupdict()
    assert len(d) == 2 and unwrap(d['first']) == 'first' and unwrap(d['second']) == 'second'
</t>
<t tx="ekr.20230509052845.5224">test_groupdict()

</t>
<t tx="ekr.20230509052845.5225">@test
def test_expand():
    assert re.match("(?P&lt;first&gt;first) (?P&lt;second&gt;second)", "first second").expand(r"\2 \1 \g&lt;second&gt; \g&lt;first&gt;") == "second first second first"
    assert re.match("(?P&lt;first&gt;first)|(?P&lt;second&gt;second)", "first").expand(r"\2 \g&lt;second&gt;") == " "
</t>
<t tx="ekr.20230509052845.5226">test_expand()

</t>
<t tx="ekr.20230509052845.5227">@test
def test_getattr():
    assert re.compile("(?i)(a)(b)").pattern == "(?i)(a)(b)"
    # TODO: Codon does not support flags like this
    # self.assertEqual(re.compile("(?i)(a)(b)").flags, re.I | re.U)
    assert re.compile("(?i)(a)(b)").groups == 2
    assert re.compile("(?i)(a)(b)").groupindex == {}
    assert re.compile("(?i)(?P&lt;first&gt;a)(?P&lt;other&gt;b)").groupindex == {'first': 1, 'other': 2}

    assert re.match("(a)", "a").pos == 0
    assert re.match("(a)", "a").endpos == 1
    assert re.match("(a)", "a").string == "a"
    assert re.match("(a)", "a").re
</t>
<t tx="ekr.20230509052845.5228">test_getattr()

</t>
<t tx="ekr.20230509052845.5229">def check_match(pattern, text, match: Optional[str] = None, span: Optional[re.Span] = None, matcher = re.fullmatch):
    if match is None and span is None:
        # the pattern matches the whole text
        match = text
        span = (0, len(text))
    elif match is None or span is None:
        raise ValueError('If match is not None, span should be specified '
                         '(and vice versa).')
    m = matcher(pattern, text)
    return bool(m) and m.group() == match and m.span() == span

</t>
<t tx="ekr.20230509052845.523">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// The result of an outlining operation.
struct OutlineResult {
  /// Information about an argument of an outlined function.
  enum ArgKind {
    CONSTANT, ///&lt; Argument is not modified by outlined function
    MODIFIED, ///&lt; Argument is modified and passed by pointer
  };

  /// The outlined function
  BodiedFunc *func = nullptr;

  /// The call to the outlined function
  CallInstr *call = nullptr;

  /// Information about each argument of the outlined function.
  /// "CONSTANT" arguments are passed by value; "MODIFIED"
  /// arguments are passed by pointer and written to by the
  /// outlined function. The size of this vector is the same
  /// as the number of arguments of the outlined function; each
  /// entry corresponds to one of those arguments.
  std::vector&lt;ArgKind&gt; argKinds;

  /// Number of externally-handled control flows.
  /// For example, an outlined function that contains a "break"
  /// of a non-outlined loop will return an integer code that
  /// tells the callee to perform this break. A series of
  /// if-statements are added to the call site to check the
  /// returned code and perform the correct action. This value
  /// is the number of if-statements generated. If it is zero,
  /// the function returns void and no such checks are done.
  int numOutFlows = 0;

  operator bool() const { return bool(func); }
};

/// Outlines a region of IR delineated by begin and end iterators
/// on a particular series flow. The outlined code will be replaced
/// by a call to the outlined function, and possibly extra logic if
/// control flow needs to be handled.
/// @param parent the function containing the series flow
/// @param series the series flow on which outlining will happen
/// @param begin start of outlining
/// @param end end of outlining (non-inclusive like standard iterators)
/// @param allowOutflows allow outlining regions with "out-flows"
/// @param outlineGlobals outline globals as arguments to outlined function
/// @param allByValue pass all outlined vars by value (can change semantics)
/// @return the result of outlining
OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series,
                            decltype(series-&gt;begin()) begin,
                            decltype(series-&gt;end()) end, bool allowOutflows = true,
                            bool outlineGlobals = false, bool allByValue = false);

/// Outlines a series flow from its parent function. The outlined code
/// will be replaced by a call to the outlined function, and possibly
/// extra logic if control flow needs to be handled.
/// @param parent the function containing the series flow
/// @param series the series flow on which outlining will happen
/// @param allowOutflows allow outlining regions with "out-flows"
/// @param outlineGlobals outline globals as arguments to outlined function
/// @param allByValue pass all outlined vars by value (can change semantics)
/// @return the result of outlining
OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series,
                            bool allowOutflows = true, bool outlineGlobals = false,
                            bool allByValue = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5230">LITERAL_CHARS = string.ascii_letters + string.digits

</t>
<t tx="ekr.20230509052845.5231">@test
def test_re_escape():
    p = ''.join(chr(i) for i in range(256))
    for c in p:
        assert check_match(re.escape(c), c)
        assert check_match('[' + re.escape(c) + ']', c)
    assert check_match(re.escape(p), p)
    for c in '-.]{}':
        assert re.escape(c)[:1] == '\\'
    literal_chars = LITERAL_CHARS
    assert re.escape(literal_chars) == literal_chars
</t>
<t tx="ekr.20230509052845.5232">@path C:/Repos/codon/test/stdlib/
from algorithms.qsort import qsort_inplace
from algorithms.heapsort import heap_sort_inplace
from algorithms.pdqsort import pdq_sort_inplace
from algorithms.timsort import tim_sort_inplace
from time import time


@others
test_standard_sort()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5233">def key(n: int):
    return -n


</t>
<t tx="ekr.20230509052845.5234">def gen_list(n: int):
    import random

    v = List[int](n)
    for _ in range(n):
        v.append(random.randint(0, 10000))
    return v


</t>
<t tx="ekr.20230509052845.5235">def copy_to(a, b):
    b.clear()
    for i in a:
        b.append(i)


</t>
<t tx="ekr.20230509052845.5236">@test
def ensure_sorted(v):
    for i in range(len(v) - 1):
        assert key(v[i]) &lt;= key(v[i + 1])


</t>
<t tx="ekr.20230509052845.5237">v0 = gen_list(100)
v1 = List[int](len(v0))


</t>
<t tx="ekr.20230509052845.5238">def test_sort1(name, sort):
    copy_to(v0, v1)
    t0 = time()
    sort(v1, key)
    t1 = time()
    print name, t1 - t0
    ensure_sorted(v1)


</t>
<t tx="ekr.20230509052845.5239">test_sort1("qsort   :", qsort_inplace)
test_sort1("heapsort:", heap_sort_inplace)
test_sort1("pdqsort :", pdq_sort_inplace)
test_sort1("timsort :", tim_sort_inplace)


</t>
<t tx="ekr.20230509052845.524">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;vector&gt;

namespace codon {
namespace ir {
namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5240">@test
def test_sort2(name, sort):
    from random import shuffle

    fail = False
    print name
    for N in (0, 1, 10, 100, 1000, 10000):  # , 100000): # too slow; maybe add later?
        print N
        for i in range(1000):
            v = list(range(N))
            shuffle(v)
            sort(v, key)
            if v != list(reversed(range(N))):
                fail = True
    assert not fail


</t>
<t tx="ekr.20230509052845.5241">test_sort2("qsort   :", qsort_inplace)
test_sort2("heapsort:", heap_sort_inplace)
test_sort2("pdqsort :", pdq_sort_inplace)
test_sort2("timsort :", tim_sort_inplace)

</t>
<t tx="ekr.20230509052845.5242"># test standard sort routines
@test
def test_standard_sort():
    copy_to(v0, v1)
    v2 = sorted(v1)
    for i in range(len(v2) - 1):
        assert v2[i] &lt;= v2[i + 1]

    v2 = sorted(v1, key=key)
    for i in range(len(v2) - 1):
        assert key(v2[i]) &lt;= key(v2[i + 1])

    v2.sort()
    for i in range(len(v2) - 1):
        assert v2[i] &lt;= v2[i + 1]

    v2.sort(key=key)
    for i in range(len(v2) - 1):
        assert key(v2[i]) &lt;= key(v2[i + 1])


</t>
<t tx="ekr.20230509052845.5243">@path C:/Repos/codon/test/stdlib/
import statistics
import math


@others
test_from_samples()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5244">@test
def med():
    # Test median with even nuber of int data points.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median(data) == 3.5

    # Test median with an odd number of int data points.
    data = [1, 2, 3, 4, 5, 6, 9]
    assert statistics.median(data) == 4

    # Test median works with an odd number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7]
    assert statistics.median(fdata) == 3 / 7

    # Test median works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median(fdata) == 1 / 2

    # Test median works with an odd number of Decimals.
    ddata = [2.5, 3.1, 4.2, 5.7, 5.8]
    assert statistics.median(ddata) == 4.2


</t>
<t tx="ekr.20230509052845.5245">med()


</t>
<t tx="ekr.20230509052845.5246">@test
def med_low():
    # Test median_low with an even number of ints.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median_low(data) == 3

    # Test median_low works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median_low(fdata) == 3 / 7

    # Test median_low works with an even number of Decimals.
    ddata = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
    assert statistics.median_low(ddata) == 3.3


</t>
<t tx="ekr.20230509052845.5247">med_low()


</t>
<t tx="ekr.20230509052845.5248">@test
def med_high():
    # Test median_high with an even number of ints.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median_high(data) == 4

    # Test median_high works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median_high(fdata) == 4 / 7

    # Test median_high works with an even number of Decimals.
    ddata = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
    assert statistics.median_high(ddata) == 4.4


</t>
<t tx="ekr.20230509052845.5249">med_high()


</t>
<t tx="ekr.20230509052845.525">/// Utility function to strip parameter packs.
/// @param dst the destination vector
/// @param first the value
template &lt;typename Desired&gt;
void stripPack(std::vector&lt;Desired *&gt; &amp;dst, Desired &amp;first) {
  dst.push_back(&amp;first);
}

</t>
<t tx="ekr.20230509052845.5250">@test
def med_grouped():
    # Test median_grouped with repeated median values.
    data = [12, 13, 14, 14, 14, 15, 15]
    assert statistics.median_grouped(data) == 14

    data = [12, 13, 14, 14, 14, 14, 15]
    assert statistics.median_grouped(data) == 13.875

    data = [5, 10, 10, 15, 20, 20, 20, 20, 25, 25, 30]
    assert statistics.median_grouped(data, 5) == 19.375

    # Test median_grouped with repeated median values.
    data = [2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6]
    assert statistics.median_grouped(data) == 4.5

    data = [3, 4, 4, 4, 5, 5, 5, 5, 6, 6]
    assert statistics.median_grouped(data) == 4.75

    # Test median_grouped with repeated single values.
    ddata = [3.2]
    assert statistics.median_grouped(ddata) == 3.2

    # Test median_grouped works with an odd number of Fractions.
    fdata = [5 / 4, 9 / 4, 13 / 4, 13 / 4, 17 / 4]
    assert statistics.median_grouped(fdata) == 3.0

    # Test median_grouped works with an even number of Fractions.
    fdata = [5 / 4, 9 / 4, 13 / 4, 13 / 4, 17 / 4, 17 / 4]
    assert statistics.median_grouped(fdata) == 3.25

    # Test median_grouped works with an odd number of Decimals.
    ddata = [5.5, 6.5, 6.5, 7.5, 8.5]
    assert statistics.median_grouped(ddata) == 6.75

    # Test median_grouped works with an even number of Decimals.
    ddata = [5.5, 5.5, 6.5, 6.5, 7.5, 8.5]
    assert statistics.median_grouped(ddata) == 6.5


</t>
<t tx="ekr.20230509052845.5251">med_grouped()


</t>
<t tx="ekr.20230509052845.5252">@test
def test_mode():
    data = [12, 13, 14, 14, 14, 15, 15]
    assert statistics.mode(data) == 14

    data = list(range(20, 50, 3))
    assert statistics.mode(data) == 20

    # Test mode with nominal data.
    ndata = ["a", "b", "c", "b", "d", "b"]
    assert statistics.mode(ndata) == "b"

    ndata = ["fe", "fi", "fo", "fum", "fi", "fi"]
    assert statistics.mode(ndata) == "fi"

    # Test mode with bimodal data.
    data = [1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9]
    assert statistics.mode(data) == 2

    # Test mode when data points are all unique.
    data = list(range(10))
    assert statistics.mode(data) == 0


</t>
<t tx="ekr.20230509052845.5253">test_mode()


</t>
<t tx="ekr.20230509052845.5254">@test
def test_multimode():
    data = [1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9]
    assert statistics.multimode(data) == [2, 6]

    ndata = ["a", "a", "b", "b", "b", "b", "b", "b", "b", "b", "c", "c"]
    assert statistics.multimode(ndata) == ["b"]

    ndata = [
        "a",
        "a",
        "b",
        "b",
        "b",
        "b",
        "c",
        "c",
        "d",
        "d",
        "d",
        "d",
        "e",
        "e",
        "f",
        "f",
        "f",
        "f",
        "g",
        "g",
    ]
    assert statistics.multimode(ndata) == ["b", "d", "f"]


</t>
<t tx="ekr.20230509052845.5255">test_multimode()


</t>
<t tx="ekr.20230509052845.5256">@test
def test_quantiles():
    for n in range(2, 10):
        data = [10.0] * n
        assert statistics.quantiles(data) == [10.0, 10.0, 10.0]
        assert statistics.quantiles(data, method="inclusive") == [10.0, 10.0, 10.0]

    data = [100, 200, 400, 800]
    for n, expected in [
        (2, [300.0]),
        (3, [200.0, 400.0]),
        (4, [175.0, 300.0, 500.0]),
        (5, [160.0, 240.0, 360.0, 560.0]),
        (6, [150.0, 200.0, 300.0, 400.0, 600.0]),
        (8, [137.5, 175.0, 225.0, 300.0, 375.0, 500.0, 650.0]),
        (10, [130.0, 160.0, 190.0, 240.0, 300.0, 360.0, 440.0, 560.0, 680.0]),
        (12, [125.0, 150.0, 175.0, 200.0, 250.0, 300.0, 350.0, 400.0, 500.0, 600.0, 700.0]),
        (15, [120.0, 140.0, 160.0, 180.0, 200.0, 240.0, 280.0, 320.0, 360.0, 400.0, 480.0, 560.0, 640.0, 720.0])
    ]:
        assert statistics.quantiles(data, n=n, method="inclusive") == expected


</t>
<t tx="ekr.20230509052845.5257">test_quantiles()


</t>
<t tx="ekr.20230509052845.5258">@test
def test_mean():
    data = [100.0, 200.0, 400.0, 800.0]
    assert statistics.mean(data) == 375.0

    data = [17.25, 19.75, 20.0, 21.5, 21.75, 23.25, 25.125, 27.5]
    assert statistics.mean(data) == 22.015625

    data = [
        0.0,
        1.0,
        2.0,
        3.0,
        3.0,
        3.0,
        4.0,
        5.0,
        5.0,
        6.0,
        7.0,
        7.0,
        7.0,
        7.0,
        8.0,
        9.0,
    ]
    assert statistics.mean(data) == 4.8125


</t>
<t tx="ekr.20230509052845.5259">test_mean()


</t>
<t tx="ekr.20230509052845.526">/// Utility function to strip parameter packs.
/// @param dst the destination vector
template &lt;typename Desired&gt; void stripPack(std::vector&lt;Desired *&gt; &amp;dst) {}

</t>
<t tx="ekr.20230509052845.5260">@test
def test_geometric_mean():
    PRECISION = 1e-6

    data = [54.0, 24.0, 36.0]
    assert math.fabs(statistics.geometric_mean(data) - 36) &lt; PRECISION

    data = [4.0, 9.0]
    assert math.fabs(statistics.geometric_mean(data) - 6) &lt; PRECISION

    data = [17.625]
    assert math.fabs(statistics.geometric_mean(data) - 17.625) &lt; PRECISION

    data = [3.5, 4.0, 5.25]
    assert math.fabs(statistics.geometric_mean(data) - 4.18886) &lt; PRECISION


</t>
<t tx="ekr.20230509052845.5261">test_geometric_mean()


</t>
<t tx="ekr.20230509052845.5262">@test
def test_harmonic_mean():
    data = [1.0, 0.0, 2.0]
    assert statistics.harmonic_mean(data) == 0

    data = [2.0, 4.0, 4.0, 8.0, 16.0, 16.0]
    assert statistics.harmonic_mean(data) == 6 * 4 / 5

    data = [1 / 8, 1 / 4, 1 / 4, 1 / 2, 1 / 2]
    assert statistics.harmonic_mean(data) == 1 / 4

    for x in range(1, 101):
        assert statistics.harmonic_mean([float(x)]) == float(x)


</t>
<t tx="ekr.20230509052845.5263">test_harmonic_mean()


</t>
<t tx="ekr.20230509052845.5264">@test
def test_pvariance():
    data = [float(i) for i in range(10000)]
    assert statistics.pvariance(data) == (10000 ** 2 - 1) / 12

    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.pvariance(data) == 22.5

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.pvariance(data) == 3 / 8


</t>
<t tx="ekr.20230509052845.5265">test_pvariance()


</t>
<t tx="ekr.20230509052845.5266">@test
def test_pstdev():
    data = [float(i) for i in range(10000)]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))

    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))


</t>
<t tx="ekr.20230509052845.5267">test_pstdev()


</t>
<t tx="ekr.20230509052845.5268">@test
def test_variance():
    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.variance(data) == 30.0

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.variance(data) == 1 / 2


</t>
<t tx="ekr.20230509052845.5269">test_variance()


</t>
<t tx="ekr.20230509052845.527">/// Utility function to strip parameter packs.
/// @param dst the destination vector
/// @param first the value
/// @param args the argument pack
template &lt;typename Desired, typename... Args&gt;
  @others
</t>
<t tx="ekr.20230509052845.5270">@test
def test_stdev():
    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.stdev(data) == math.sqrt(statistics.variance(data))

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.stdev(data) == math.sqrt(statistics.variance(data))


</t>
<t tx="ekr.20230509052845.5271">test_stdev()


</t>
<t tx="ekr.20230509052845.5272">@test
def test_mean_NormalDist():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.mean == 10000.0


</t>
<t tx="ekr.20230509052845.5273">test_mean_NormalDist()


</t>
<t tx="ekr.20230509052845.5274">@test
def test_stdev():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.stdev == 3.0


</t>
<t tx="ekr.20230509052845.5275">test_stdev()


</t>
<t tx="ekr.20230509052845.5276">@test
def test_variance():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.variance == 9.0


</t>
<t tx="ekr.20230509052845.5277">test_variance()


</t>
<t tx="ekr.20230509052845.5278">@test
def test_pdf():
    PRECISION = 1e-6
    X = statistics.NormalDist(100.0, 15.0)

    # verify peak around center
    assert X.pdf(99.0) &lt; X.pdf(100.0)
    assert X.pdf(101.0) &lt; X.pdf(100.0)

    for i in range(50):
        assert (
            math.fabs((X.pdf(100.0 - float(i)) - X.pdf(100.0 + float(i)))) &lt; PRECISION
        )


</t>
<t tx="ekr.20230509052845.5279">test_pdf()


</t>
<t tx="ekr.20230509052845.528">void stripPack(std::vector&lt;Desired *&gt; &amp;dst, Desired &amp;first, Args &amp;&amp;...args) {
dst.push_back(&amp;first);
stripPack&lt;Desired&gt;(dst, std::forward&lt;Args&gt;(args)...);
}

</t>
<t tx="ekr.20230509052845.5280">@test
def test_cdf():
    X = statistics.NormalDist(100.0, 15.0)
    # Verify center (should be exact)
    assert X.cdf(100.0) == 0.50


</t>
<t tx="ekr.20230509052845.5281">test_cdf()


</t>
<t tx="ekr.20230509052845.5282">@test
def test_inv_cdf():
    PRECISION = 1e-6
    iq = statistics.NormalDist(100.0, 15.0)
    assert iq.inv_cdf(0.50) == iq.mean

    # One hundred ever smaller probabilities to test tails out to
    # extreme probabilities: 1 / 2**50 and (2**50-1) / 2 ** 50
    for e in range(1, 51):
        p = 2.0 ** (-e)
        assert math.fabs(iq.cdf(iq.inv_cdf(p)) - p) &lt; PRECISION
        p = 1.0 - p
        assert math.fabs(iq.cdf(iq.inv_cdf(p)) - p) &lt; PRECISION


</t>
<t tx="ekr.20230509052845.5283">test_inv_cdf()


</t>
<t tx="ekr.20230509052845.5284">@test
def test_ND_quartiles():
    PRECISION = 1e-6
    Z = statistics.NormalDist(0.0, 1.0)
    for n, expected in [
        (2, [0.0]),
        (3, [-0.430727, 0.430727]),
        (4, [-0.67449, 0.0, 0.67449]),
    ]:
        actual = Z.quantiles(n)
        for i in range(len(expected)):
            assert math.fabs(actual[i] - expected[i]) &lt; PRECISION


</t>
<t tx="ekr.20230509052845.5285">test_ND_quartiles()


</t>
<t tx="ekr.20230509052845.5286">@test
def test_overlap():
    PRECISION = 1e-5
    for X1, X2, published_result in [
        (statistics.NormalDist(0.0, 2.0), statistics.NormalDist(1.0, 2.0), 0.80258),
        (statistics.NormalDist(0.0, 1.0), statistics.NormalDist(1.0, 2.0), 0.60993),
    ]:
        assert math.fabs(X1.overlap(X2) - published_result) &lt; PRECISION
        assert math.fabs(X2.overlap(X1) - published_result) &lt; PRECISION


</t>
<t tx="ekr.20230509052845.5287">test_overlap()


</t>
<t tx="ekr.20230509052845.5288">@test
def test_samples():
    mu, sigma = 10000.0, 3.0
    X = statistics.NormalDist(mu, sigma)
    n = 1000
    data = X.samples(n)
    assert len(data) == n


</t>
<t tx="ekr.20230509052845.5289">test_samples()


</t>
<t tx="ekr.20230509052845.529">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;

namespace codon {
namespace ir {
namespace util {

/// Function side effect status. "Pure" functions by definition give the same
/// output for the same inputs and have no side effects. "No side effect"
/// functions have no side effects, but can give different outputs for the
/// same input (e.g. time() is one such function). "No capture" functions do
/// not capture any of their arguments; note that capturing an argument is
/// considered a side effect. Therefore, we have pure &lt; no_side_effect &lt;
/// no_capture &lt; unknown, where "&lt;" denotes subset. The enum values are also
/// ordered in this way, which is relied on by the implementation.
enum SideEffectStatus {
  PURE = 0,
  NO_SIDE_EFFECT,
  NO_CAPTURE,
  UNKNOWN,
};

extern const std::string NON_PURE_ATTR;
extern const std::string PURE_ATTR;
extern const std::string NO_SIDE_EFFECT_ATTR;
extern const std::string NO_CAPTURE_ATTR;
extern const std::string DERIVES_ATTR;
extern const std::string SELF_CAPTURES_ATTR;

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5290">@test
def test_from_samples():
    data = [96.0, 107.0, 90.0, 92.0, 110.0]
    ND = statistics.NormalDist.from_samples(data)
    assert ND == statistics.NormalDist(99.0, 9.0)


</t>
<t tx="ekr.20230509052845.5291">@path C:/Repos/codon/test/stdlib/
@others
test_isdigit()
test_islower()
test_isupper()
test_isalnum()
test_isalpha()
test_isspace()
test_istitle()
test_capitalize()
test_isdecimal()
test_lower()
test_upper()
test_isascii()
test_casefold()
test_swapcase()
test_title()
test_isnumeric()
test_ljust()
test_rjust()
test_center()
test_zfill()
test_count()
test_find()
test_rfind()
test_isidentifier()
test_isprintable()
test_lstrip()
test_rstrip()
test_strip()
test_partition()
test_rpartition()
test_split()
test_rsplit()
test_splitlines()
test_startswith()
test_endswith()
test_index()
test_rindex()
test_replace()
test_expandtabs()
test_translate()
test_repr()
test_fstr()
test_slice()
test_join()
test_repr()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5292">@test
def test_isdigit():
    assert "0".isdigit() == True
    assert "".isdigit() == False
    assert "a".isdigit() == False
    assert "2829357".isdigit() == True
    assert "kshfkjhe".isdigit() == False
    assert "9735g385497".isdigit() == False


</t>
<t tx="ekr.20230509052845.5293">@test
def test_islower():
    assert "".islower() == False
    assert "a".islower() == True
    assert "A".islower() == False
    assert "5".islower() == False
    assert "ahuiuej".islower() == True
    assert "AhUiUeJ".islower() == False
    assert "9735g385497".islower() == True
    assert "9735G385497".islower() == False


</t>
<t tx="ekr.20230509052845.5294">@test
def test_isupper():
    assert "".isupper() == False
    assert "a".isupper() == False
    assert "A".isupper() == True
    assert "5".isupper() == False
    assert ".J, U-I".isupper() == True
    assert "AHUIUEJ".isupper() == True
    assert "AhUiUeJ".isupper() == False
    assert "9735g385497".isupper() == False
    assert "9735G385497".isupper() == True


</t>
<t tx="ekr.20230509052845.5295">@test
def test_isalnum():
    assert "".isalnum() == False
    assert "a".isalnum() == True
    assert "5".isalnum() == True
    assert ",".isalnum() == False
    assert "H6".isalnum() == True
    assert ".J, U-I".isalnum() == False
    assert "A4kki83UE".isalnum() == True
    assert "AhUiUeJ".isalnum() == True
    assert "973 g38597".isalnum() == False
    assert "9735G3-5497".isalnum() == False


</t>
<t tx="ekr.20230509052845.5296">@test
def test_isalpha():
    assert "".isalpha() == False
    assert "a".isalpha() == True
    assert "5".isalpha() == False
    assert ",".isalpha() == False
    assert "Hh".isalpha() == True
    assert ".J, U-I".isalpha() == False
    assert "A4kki83UE".isalpha() == False
    assert "AhUiUeJ".isalpha() == True
    assert "973 g38597".isalpha() == False
    assert "9735G3-5497".isalpha() == False


</t>
<t tx="ekr.20230509052845.5297">@test
def test_isspace():
    assert "".isspace() == False
    assert " ".isspace() == True
    assert "5 ".isspace() == False
    assert "\t\n\r ".isspace() == True
    assert "\t ".isspace() == True
    assert "\t\ngh\r ".isspace() == False
    assert "A4kki 3UE".isspace() == False


</t>
<t tx="ekr.20230509052845.5298">@test
def test_istitle():
    assert "".istitle() == False
    assert " ".istitle() == False
    assert "I ".istitle() == True
    assert "IH".istitle() == False
    assert "Ih".istitle() == True
    assert "Hter Hewri".istitle() == True
    assert "Kweiur oiejf".istitle() == False


</t>
<t tx="ekr.20230509052845.5299">@test
def test_capitalize():
    assert " hello ".capitalize() == " hello "
    assert "Hello ".capitalize() == "Hello "
    assert "hello ".capitalize() == "Hello "
    assert "aaaa".capitalize() == "Aaaa"
    assert "AaAa".capitalize() == "Aaaa"


</t>
<t tx="ekr.20230509052845.53">def __str__(self):
    return "&lt;%f, %f, %f&gt;" % (self.x, self.y, self.z)

</t>
<t tx="ekr.20230509052845.530">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

#define VISIT(x) virtual void visit(codon::ir::x *)
#define CONST_VISIT(x) virtual void visit(const codon::ir::x *)

namespace codon {
namespace ir {
class Node;

namespace types {
class Type;
class PrimitiveType;
class IntType;
class FloatType;
class Float32Type;
class BoolType;
class ByteType;
class VoidType;
class RecordType;
class RefType;
class FuncType;
class OptionalType;
class PointerType;
class GeneratorType;
class IntNType;
class VectorType;
class UnionType;
} // namespace types

namespace dsl {

namespace types {
class CustomType;
}

class CustomConst;
class CustomFlow;
class CustomInstr;
} // namespace dsl

class Module;

class Var;

class Func;
class BodiedFunc;
class ExternalFunc;
class InternalFunc;
class LLVMFunc;

class Value;
class VarValue;
class PointerValue;

class Flow;
class SeriesFlow;
class IfFlow;
class WhileFlow;
class ForFlow;
class ImperativeForFlow;
class TryCatchFlow;
class PipelineFlow;

class Const;

template &lt;typename ValueType&gt; class TemplatedConst;

class Instr;
class AssignInstr;
class ExtractInstr;
class InsertInstr;
class CallInstr;
class StackAllocInstr;
class TypePropertyInstr;
class YieldInInstr;
class TernaryInstr;
class BreakInstr;
class ContinueInstr;
class ReturnInstr;
class YieldInstr;
class ThrowInstr;
class FlowInstr;

namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon

#undef VISIT
#undef CONST_VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5300">@test
def test_isdecimal():
    assert "".isdecimal() == False
    assert "a".isdecimal() == False
    assert "0".isdecimal() == True
    assert "\xbc".isdecimal() == False
    assert "0123456789".isdecimal() == True
    assert "0123456789a".isdecimal() == False


</t>
<t tx="ekr.20230509052845.5301">@test
def test_lower():
    assert "HeLLo".lower() == "hello"
    assert "hello".lower() == "hello"
    assert "HELLO".lower() == "hello"
    assert "HEL _ LO".lower() == "hel _ lo"


</t>
<t tx="ekr.20230509052845.5302">@test
def test_upper():
    assert "HeLLo".upper() == "HELLO"
    assert "hello".upper() == "HELLO"
    assert "HELLO".upper() == "HELLO"
    assert "HEL _ LO".upper() == "HEL _ LO"


</t>
<t tx="ekr.20230509052845.5303">@test
def test_isascii():
    assert "".isascii() == True
    assert "\x00".isascii() == True
    assert "\x7f".isascii() == True
    assert "\x00\x7f".isascii() == True
    assert "\x80".isascii() == False
    assert "".isascii() == False
    assert "\xe9".isascii() == False


</t>
<t tx="ekr.20230509052845.5304">@test
def test_casefold():
    assert "".casefold() == ""
    assert "HeLLo".casefold() == "hello"
    assert "hello".casefold() == "hello"
    assert "HELLO".casefold() == "hello"
    assert "HEL _ LO".casefold() == "hel _ lo"


</t>
<t tx="ekr.20230509052845.5305">@test
def test_swapcase():
    assert "".swapcase() == ""
    assert "HeLLo cOmpUteRs".swapcase() == "hEllO CoMPuTErS"
    assert "H.e_L,L-o cOmpUteRs".swapcase() == "h.E_l,l-O CoMPuTErS"


</t>
<t tx="ekr.20230509052845.5306">@test
def test_title():
    assert "".title() == ""
    assert " hello ".title() == " Hello "
    assert "hello ".title() == "Hello "
    assert "Hello ".title() == "Hello "
    assert "fOrMaT thIs aS titLe String".title() == "Format This As Title String"
    assert "fOrMaT,thIs-aS*titLe;String".title() == "Format,This-As*Title;String"
    assert "getInt".title() == "Getint"


</t>
<t tx="ekr.20230509052845.5307">@test
def test_isnumeric():
    assert "".isdecimal() == False
    assert "a".isdecimal() == False
    assert "0".isdecimal() == True
    assert "\xbc".isdecimal() == False
    assert "0123456789".isdecimal() == True
    assert "0123456789a".isdecimal() == False


</t>
<t tx="ekr.20230509052845.5308">@test
def test_ljust():
    assert "abc".ljust(10, " ") == "abc       "
    assert "abc".ljust(6, " ") == "abc   "
    assert "abc".ljust(3, " ") == "abc"
    assert "abc".ljust(2, " ") == "abc"
    assert "abc".ljust(10, "*") == "abc*******"


</t>
<t tx="ekr.20230509052845.5309">@test
def test_rjust():
    assert "abc".rjust(10, " ") == "       abc"
    assert "abc".rjust(6, " ") == "   abc"
    assert "abc".rjust(3, " ") == "abc"
    assert "abc".rjust(2, " ") == "abc"
    assert "abc".rjust(10, "*") == "*******abc"


</t>
<t tx="ekr.20230509052845.531">/// Base for CIR visitors
class Visitor {
protected:
  virtual void defaultVisit(codon::ir::Node *) {
    throw std::runtime_error("cannot visit node");
  }

public:
  virtual ~Visitor() noexcept = default;

  VISIT(Module);

  VISIT(Var);

  VISIT(Func);
  VISIT(BodiedFunc);
  VISIT(ExternalFunc);
  VISIT(InternalFunc);
  VISIT(LLVMFunc);

  VISIT(Value);
  VISIT(VarValue);
  VISIT(PointerValue);

  VISIT(Flow);
  VISIT(SeriesFlow);
  VISIT(IfFlow);
  VISIT(WhileFlow);
  VISIT(ForFlow);
  VISIT(ImperativeForFlow);
  VISIT(TryCatchFlow);
  VISIT(PipelineFlow);
  VISIT(dsl::CustomFlow);

  VISIT(Const);
  VISIT(TemplatedConst&lt;int64_t&gt;);
  VISIT(TemplatedConst&lt;double&gt;);
  VISIT(TemplatedConst&lt;bool&gt;);
  VISIT(TemplatedConst&lt;std::string&gt;);
  VISIT(dsl::CustomConst);

  VISIT(Instr);
  VISIT(AssignInstr);
  VISIT(ExtractInstr);
  VISIT(InsertInstr);
  VISIT(CallInstr);
  VISIT(StackAllocInstr);
  VISIT(TypePropertyInstr);
  VISIT(YieldInInstr);
  VISIT(TernaryInstr);
  VISIT(BreakInstr);
  VISIT(ContinueInstr);
  VISIT(ReturnInstr);
  VISIT(YieldInstr);
  VISIT(ThrowInstr);
  VISIT(FlowInstr);
  VISIT(dsl::CustomInstr);

  VISIT(types::Type);
  VISIT(types::PrimitiveType);
  VISIT(types::IntType);
  VISIT(types::FloatType);
  VISIT(types::Float32Type);
  VISIT(types::BoolType);
  VISIT(types::ByteType);
  VISIT(types::VoidType);
  VISIT(types::RecordType);
  VISIT(types::RefType);
  VISIT(types::FuncType);
  VISIT(types::OptionalType);
  VISIT(types::PointerType);
  VISIT(types::GeneratorType);
  VISIT(types::IntNType);
  VISIT(types::VectorType);
  VISIT(types::UnionType);
  VISIT(dsl::types::CustomType);
};

</t>
<t tx="ekr.20230509052845.5310">@test
def test_center():
    assert "abc".center(10, " ") == "   abc    "
    assert "abc".center(6, " ") == " abc  "
    assert "abc".center(3, " ") == "abc"
    assert "abc".center(2, " ") == "abc"
    assert "abc".center(10, "*") == "***abc****"


</t>
<t tx="ekr.20230509052845.5311">@test
def test_zfill():
    assert "123".zfill(2) == "123"
    assert "123".zfill(3) == "123"
    assert "123".zfill(4) == "0123"
    assert "+123".zfill(3) == "+123"
    assert "+123".zfill(4) == "+123"
    assert "+123".zfill(5) == "+0123"
    assert "-123".zfill(3) == "-123"
    assert "-123".zfill(4) == "-123"
    assert "-123".zfill(5) == "-0123"
    assert "".zfill(3) == "000"
    assert "34".zfill(1) == "34"
    assert "34".zfill(4) == "0034"
    assert "1+2".zfill(5) == "001+2"
    assert "+".zfill(10) == "+000000000"
    assert "-".zfill(10) == "-000000000"


</t>
<t tx="ekr.20230509052845.5312">@test
def test_count():
    assert "aaa".count("a", 0, len("aaa")) == 3
    assert "aaa".count("b", 0, len("aaa")) == 0
    assert "aaa".count("a", 1, len("aaa")) == 2
    assert "aaa".count("a", 10, len("aaa")) == 0
    assert "aaa".count("a", -1, len("aaa")) == 1
    assert "aaa".count("a", 0, 1) == 1
    assert "aaa".count("a", 0, 10) == 3
    assert "aaa".count("a", 0, -1) == 2
    assert "aaa".count("aa") == 1
    assert "ababa".count("aba") == 1
    assert "abababa".count("aba") == 2
    assert "abababa".count("abab") == 1


</t>
<t tx="ekr.20230509052845.5313">@test
def test_find():
    assert "abcdefghiabc".find("abc", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".find("abc") == 0
    assert "abcdefghiabc".find("abc", 1, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".find("def", 4, len("abcdefghiabc")) == -1
    assert "abcdefghiabc".find("abcdef", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".find("abcdef") == 0
    assert "abcdefghiabc".find("hiabc", 1, len("abcdefghiabc")) == 7
    assert "abcdefghiabc".find("defgh", 4, len("abcdefghiabc")) == -1
    assert "rrarrrrrrrrra".find("a", 0, len("rrarrrrrrrrra")) == 2
    assert "rrarrrrrrrrra".find("a", 4, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".find("a", 4, 6) == -1
    assert "abc".find("", 0, len("abc")) == 0
    assert "abc".find("", 3, len("abc")) == 3
    assert "abc".find("", 4, len("abc")) == -1


</t>
<t tx="ekr.20230509052845.5314">@test
def test_rfind():
    assert "abcdefghiabc".rfind("abc", 0, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".rfind("", 0, len("abcdefghiabc")) == 12
    assert "abcdefghiabc".rfind("abcd", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".rfind("abcz", 0, len("abcdefghiabc")) == -1
    assert "abcdefghiabc".rfind("abc") == 9
    assert "abcdefghiabc".rfind("") == 12
    assert "abcdefghiabc".rfind("abcd") == 0
    assert "abcdefghiabc".rfind("abcz") == -1
    assert "rrarrrrrrrrra".rfind("a", 0, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rfind("a", 4, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rfind("a", 4, 6) == -1
    assert "abc".rfind("", 0, len("abc")) == 3
    assert "abc".rfind("", 3, len("abc")) == 3
    assert "abc".rfind("", 4, len("abc")) == -1


</t>
<t tx="ekr.20230509052845.5315">@test
def test_isidentifier():
    assert "a".isidentifier() == True
    assert "Z".isidentifier() == True
    assert "_".isidentifier() == True
    assert "b0".isidentifier() == True
    assert "bc".isidentifier() == True
    assert "b_".isidentifier() == True
    assert " ".isidentifier() == False
    assert "3t".isidentifier() == False
    assert "_gth_45".isidentifier() == True


</t>
<t tx="ekr.20230509052845.5316">@test
def test_isprintable():
    assert "".isprintable() == True
    assert '"'.isprintable() == True
    assert "'".isprintable() == True
    assert " ".isprintable() == True
    assert "abcdef".isprintable() == True
    assert "0123456789".isprintable() == True
    assert "ABCDEFGHIJKLMNOPQRSTUVWXYZ".isprintable() == True
    assert "abcdefghijklmnopqrstuvwxyz".isprintable() == True
    assert "!#$%&amp;()*+,-./:;?@[\\]^_`{|}~".isprintable() == True
    assert "abcdef\n".isprintable() == False


</t>
<t tx="ekr.20230509052845.5317">@test
def test_lstrip():
    assert "".lstrip() == ""
    assert "   ".lstrip() == ""
    assert "   hello   ".lstrip("") == "hello   "
    assert " \t\n\rabc \t\n\r".lstrip("") == "abc \t\n\r"
    assert "xyzzyhelloxyzzy".lstrip("xyz") == "helloxyzzy"


</t>
<t tx="ekr.20230509052845.5318">@test
def test_rstrip():
    assert "".rstrip() == ""
    assert "   ".rstrip() == ""
    assert "   hello   ".rstrip("") == "   hello"
    assert " \t\n\rabc \t\n\r".rstrip("") == " \t\n\rabc"
    assert "xyzzyhelloxyzzy".rstrip("xyz") == "xyzzyhello"


</t>
<t tx="ekr.20230509052845.5319">@test
def test_strip():
    assert "".strip() == ""
    assert "   ".strip() == ""
    assert "   hello   ".strip("") == "hello"
    assert "   hello   ".strip() == "hello"
    assert " \t\n\rabc \t\n\r".strip() == "abc"
    assert "xyzzyhelloxyzzy".strip("xyz") == "hello"
    assert "hello".strip("xyz") == "hello"
    assert "mississippi".strip("mississippi") == ""
    assert "mississippi".strip("i") == "mississipp"


</t>
<t tx="ekr.20230509052845.532">class ConstVisitor {
protected:
  virtual void defaultVisit(const codon::ir::Node *) {
    throw std::runtime_error("cannot visit const node");
  }

public:
  virtual ~ConstVisitor() noexcept = default;

  CONST_VISIT(Module);

  CONST_VISIT(Var);

  CONST_VISIT(Func);
  CONST_VISIT(BodiedFunc);
  CONST_VISIT(ExternalFunc);
  CONST_VISIT(InternalFunc);
  CONST_VISIT(LLVMFunc);

  CONST_VISIT(Value);
  CONST_VISIT(VarValue);
  CONST_VISIT(PointerValue);

  CONST_VISIT(Flow);
  CONST_VISIT(SeriesFlow);
  CONST_VISIT(IfFlow);
  CONST_VISIT(WhileFlow);
  CONST_VISIT(ForFlow);
  CONST_VISIT(ImperativeForFlow);
  CONST_VISIT(TryCatchFlow);
  CONST_VISIT(PipelineFlow);
  CONST_VISIT(dsl::CustomFlow);

  CONST_VISIT(Const);
  CONST_VISIT(TemplatedConst&lt;int64_t&gt;);
  CONST_VISIT(TemplatedConst&lt;double&gt;);
  CONST_VISIT(TemplatedConst&lt;bool&gt;);
  CONST_VISIT(TemplatedConst&lt;std::string&gt;);
  CONST_VISIT(dsl::CustomConst);

  CONST_VISIT(Instr);
  CONST_VISIT(AssignInstr);
  CONST_VISIT(ExtractInstr);
  CONST_VISIT(InsertInstr);
  CONST_VISIT(CallInstr);
  CONST_VISIT(StackAllocInstr);
  CONST_VISIT(TypePropertyInstr);
  CONST_VISIT(YieldInInstr);
  CONST_VISIT(TernaryInstr);
  CONST_VISIT(BreakInstr);
  CONST_VISIT(ContinueInstr);
  CONST_VISIT(ReturnInstr);
  CONST_VISIT(YieldInstr);
  CONST_VISIT(ThrowInstr);
  CONST_VISIT(FlowInstr);
  CONST_VISIT(dsl::CustomInstr);

  CONST_VISIT(types::Type);
  CONST_VISIT(types::PrimitiveType);
  CONST_VISIT(types::IntType);
  CONST_VISIT(types::FloatType);
  CONST_VISIT(types::Float32Type);
  CONST_VISIT(types::BoolType);
  CONST_VISIT(types::ByteType);
  CONST_VISIT(types::VoidType);
  CONST_VISIT(types::RecordType);
  CONST_VISIT(types::RefType);
  CONST_VISIT(types::FuncType);
  CONST_VISIT(types::OptionalType);
  CONST_VISIT(types::PointerType);
  CONST_VISIT(types::GeneratorType);
  CONST_VISIT(types::IntNType);
  CONST_VISIT(types::VectorType);
  CONST_VISIT(types::UnionType);
  CONST_VISIT(dsl::types::CustomType);
};

</t>
<t tx="ekr.20230509052845.5320">@test
def test_partition():
    assert "hello".partition("l") == ("he", "l", "lo")
    assert "this is the partition method".partition("ti") == (
        "this is the par",
        "ti",
        "tion method",
    )
    assert "http://www.seq.org".partition("://") == ("http", "://", "www.seq.org")
    assert "http://www.seq.org".partition("?") == ("http://www.seq.org", "", "")
    assert "http://www.seq.org".partition("http://") == ("", "http://", "www.seq.org")
    assert "http://www.seq.org".partition("org") == ("http://www.seq.", "org", "")


</t>
<t tx="ekr.20230509052845.5321">@test
def test_rpartition():
    assert "hello".rpartition("l") == ("hel", "l", "o")
    assert "this is the rpartition method".rpartition("ti") == (
        "this is the rparti",
        "ti",
        "on method",
    )
    assert "http://www.seq.org".rpartition("://") == ("http", "://", "www.seq.org")
    assert "http://www.seq.org".rpartition("?") == ("", "", "http://www.seq.org")
    assert "http://www.seq.org".rpartition("http://") == ("", "http://", "www.seq.org")
    assert "http://www.seq.org".rpartition("org") == ("http://www.seq.", "org", "")


</t>
<t tx="ekr.20230509052845.5322">@test
def test_split():
    assert "  h    l \t\n l   o ".split() == ["h", "l", "l", "o"]
    assert "  h    l \t\n l   o ".split(None, 2) == ["h", "l", "l   o "]
    assert "  h    l \t\n l   o ".split(None, 0) == ["h    l \t\n l   o "]
    assert not "".split()
    assert not "   ".split()
    assert "h l l o".split(" ", -1) == ["h", "l", "l", "o"]
    assert "a|b|c|d".split("|", -1) == ["a", "b", "c", "d"]
    assert "h l l o".split(" ") == ["h", "l", "l", "o"]
    assert "a|b|c|d".split("|") == ["a", "b", "c", "d"]
    assert "a|b|c|d".split("|", 0) == ["a|b|c|d"]
    assert "abcd".split("|", -1) == ["abcd"]
    assert "".split("|", -1) == [""]
    assert "endcase |".split("|", -1) == ["endcase ", ""]
    assert "| startcase".split("|", -1) == ["", " startcase"]
    assert "|bothcase|".split("|", -1) == ["", "bothcase", ""]
    assert "abbbc".split("bb", -1) == ["a", "bc"]
    assert "aaa".split("aaa", -1) == ["", ""]
    assert "aaa".split("aaa", 0) == ["aaa"]
    assert "abbaab".split("ba", -1) == ["ab", "ab"]
    assert "aa".split("aaa", -1) == ["aa"]
    assert "Abbobbbobb".split("bbobb", -1) == ["A", "bobb"]
    assert "AbbobbBbbobb".split("bbobb", -1) == ["A", "B", ""]
    assert ("a|" * 20)[:-1].split("|", -1) == ["a"] * 20
    assert ("a|" * 20)[:-1].split("|", 15) == ["a"] * 15 + ["a|a|a|a|a"]
    assert "a|b|c|d".split("|", 1) == ["a", "b|c|d"]
    assert "a|b|c|d".split("|", 2) == ["a", "b", "c|d"]
    assert "a|b|c|d".split("|", 3) == ["a", "b", "c", "d"]
    assert "a|b|c|d".split("|", 4) == ["a", "b", "c", "d"]
    assert "a||b||c||d".split("|", 2) == ["a", "", "b||c||d"]


</t>
<t tx="ekr.20230509052845.5323">@test
def test_rsplit():
    assert "  h    l \t\n l   o ".rsplit() == ["h", "l", "l", "o"]
    assert "  h    l \t\n l   o ".rsplit(None, 2) == ["  h    l", "l", "o"]
    assert "  h    l \t\n l   o ".rsplit(None, 0) == ["  h    l \t\n l   o"]
    assert not "".rsplit()
    assert not "   ".rsplit()
    assert "a|b|c|d".rsplit("|", -1) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|") == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 1) == ["a|b|c", "d"]
    assert "a|b|c|d".rsplit("|", 2) == ["a|b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 3) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 4) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 0) == ["a|b|c|d"]
    assert "a||b||c||d".rsplit("|", 2) == ["a||b||c", "", "d"]
    assert "abcd".rsplit("|", -1) == ["abcd"]
    assert "".rsplit("|", -1) == [""]
    assert "endcase |".rsplit("|", -1) == ["endcase ", ""]
    assert "| startcase".rsplit("|", -1) == ["", " startcase"]
    assert "|bothcase|".rsplit("|", -1) == ["", "bothcase", ""]
    # assert 'a\x00\x00b\x00c\x00d'.rsplit('\x00', -1)
    assert "abbbc".rsplit("bb", -1) == ["ab", "c"]
    assert "aaa".rsplit("aaa", -1) == ["", ""]
    assert "aaa".rsplit("aaa", 0) == ["aaa"]
    assert "abbaab".rsplit("ba", -1) == ["ab", "ab"]
    assert "aa".rsplit("aaa", -1) == ["aa"]
    assert "bbobbbobbA".rsplit("bbobb", -1) == ["bbob", "A"]
    assert "bbobbBbbobbA".rsplit("bbobb", -1) == ["", "B", "A"]
    assert ("aBLAH" * 20)[:-4].rsplit("BLAH", -1) == ["a"] * 20
    assert ("a|" * 20)[:-1].rsplit("|", 15) == ["a|a|a|a|a"] + ["a"] * 15
    assert "a||b||c||d".rsplit("|", 2) == ["a||b||c", "", "d"]


</t>
<t tx="ekr.20230509052845.5324">@test
def test_splitlines():
    assert "\n\nasdf\nsadf\nsdf\n".splitlines(False) == ["", "", "asdf", "sadf", "sdf"]
    assert "\n\nasdf\nsadf\nsdf\n".splitlines() == ["", "", "asdf", "sadf", "sdf"]
    assert "abc\ndef\n\rghi".splitlines(False) == ["abc", "def", "", "ghi"]
    assert "abc\ndef\n\r\nghi".splitlines(False) == ["abc", "def", "", "ghi"]
    assert "abc\ndef\r\nghi".splitlines(False) == ["abc", "def", "ghi"]
    assert "abc\ndef\r\nghi\n".splitlines(False) == ["abc", "def", "ghi"]
    assert "abc\ndef\r\nghi\n\r".splitlines(False) == ["abc", "def", "ghi", ""]
    assert "\nabc\ndef\r\nghi\n\r".splitlines(False) == ["", "abc", "def", "ghi", ""]
    assert "\nabc\ndef\r\nghi\n\r".splitlines(True) == [
        "\n",
        "abc\n",
        "def\r\n",
        "ghi\n",
        "\r",
    ]
    assert "abc\ndef\r\nghi\n".splitlines(True) == ["abc\n", "def\r\n", "ghi\n"]


</t>
<t tx="ekr.20230509052845.5325">@test
def test_startswith():
    assert "hello".startswith("he", 0, len("hello")) == True
    assert "hello".startswith("hello", 0, len("hello")) == True
    assert "hello".startswith("hello world", 0, len("hello")) == False
    assert "hello".startswith("", 0, len("hello")) == True
    assert "hello".startswith("ello", 0, len("hello")) == False
    assert "hello".startswith("he") == True
    assert "hello".startswith("hello") == True
    assert "hello".startswith("hello world") == False
    assert "hello".startswith("") == True
    assert "hello".startswith("ello") == False
    assert "hello".startswith("ello", 1, len("hello")) == True
    assert "hello".startswith("o", 4, len("hello")) == True
    assert "hello".startswith("o", 5, len("hello")) == False
    assert "hello".startswith("lo", 3, len("hello")) == True
    assert "hello".startswith("", 5, len("hello")) == True
    assert "hello".startswith("lo", 6, len("hello")) == False
    assert "helloworld".startswith("lowo", 3, len("helloworld")) == True
    assert "helloworld".startswith("lowo", 3, 7) == True
    assert "helloworld".startswith("lowo", 3, 6) == False
    assert "".startswith("", 0, 1) == True
    assert "".startswith("", 0, 0) == True
    assert "".startswith("", 1, 0) == False
    assert "hello".startswith("he", 0, -1) == True
    assert "hello".startswith("hello", 0, -1) == False
    assert "hello".startswith("he", 0, -3) == True
    assert "hello".startswith("ello", -4, len("hello")) == True
    assert "hello".startswith("ello", -5, len("hello")) == False
    assert "hello".startswith("", -3, -3) == True
    assert "hello".startswith("o", -1, len("hello")) == True


</t>
<t tx="ekr.20230509052845.5326">@test
def test_endswith():
    assert "hello".endswith("lo", 0, len("hello")) == True
    assert "hello".endswith("he", 0, len("hello")) == False
    assert "hello".endswith("", 0, len("hello")) == True
    assert "hello".endswith("hello world", 0, len("hello")) == False
    assert "hello".endswith("lo") == True
    assert "hello".endswith("he") == False
    assert "hello".endswith("") == True
    assert "hello".endswith("hello world") == False
    assert "helloworld".endswith("worl", 0, len("hello")) == False
    assert "helloworld".endswith("worl", 3, 9) == True
    assert "helloworld".endswith("world", 3, 12) == True
    assert "helloworld".endswith("lowo", 1, 7) == True
    assert "helloworld".endswith("lowo", 2, 7) == True
    assert "helloworld".endswith("lowo", 3, 7) == True
    assert "helloworld".endswith("lowo", 4, 7) == False
    assert "helloworld".endswith("lowo", 3, 8) == False
    assert "ab".endswith("ab", 0, 1) == False
    assert "ab".endswith("ab", 0, 0) == False
    assert "".endswith("", 0, 1) == True
    assert "".endswith("", 0, 0) == True
    assert "".endswith("", 1, 0) == False
    assert "hello".endswith("lo", -2, len("hello")) == True
    assert "hello".endswith("he", -2, len("hello")) == False
    assert "hello".endswith("", -3, -3) == True
    assert "helloworld".endswith("worl", -6, len("helloworld")) == False
    assert "helloworld".endswith("worl", -5, -1) == True
    assert "helloworld".endswith("worl", -5, 9) == True
    assert "helloworld".endswith("world", -7, 12) == True
    assert "helloworld".endswith("lowo", -99, -3) == True
    assert "helloworld".endswith("lowo", -8, -3) == True
    assert "helloworld".endswith("lowo", -7, -3) == True
    assert "helloworld".endswith("lowo", 3, -4) == False
    assert "helloworld".endswith("lowo", -8, -2) == False


</t>
<t tx="ekr.20230509052845.5327">@test
def test_index():
    assert "abcdefghiabc".index("abc", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".index("abc") == 0
    assert "abcdefghiabc".index("abc", 1, len("abcdefghiabc")) == 9
    assert "abc".index("", 0, len("abc")) == 0
    assert "abc".index("", 3, len("abc")) == 3
    assert "rrarrrrrrrrra".index("a", 0, len("rrarrrrrrrrra")) == 2
    assert "rrarrrrrrrrra".index("a", 4, len("rrarrrrrrrrra")) == 12
    try:
        "abcdefghiabc".index("def", 4, len("abcdefghiabc"))
        assert False
    except ValueError:
        pass


</t>
<t tx="ekr.20230509052845.5328">@test
def test_rindex():
    assert "abcdefghiabc".rindex("", 0, len("abcdefghiabc")) == 12
    assert "abcdefghiabc".rindex("") == 12
    assert "abcdefghiabc".rindex("def", 0, len("abcdefghiabc")) == 3
    assert "abcdefghiabc".rindex("abc", 0, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".rindex("abc", 0, -1) == 0
    assert "rrarrrrrrrrra".rindex("a", 0, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rindex("a", 4, len("rrarrrrrrrrra")) == 12
    try:
        "rrarrrrrrrrra".rindex("a", 4, 6)
        assert False
    except ValueError:
        pass


</t>
<t tx="ekr.20230509052845.5329">@test
def test_replace():
    # interleave-- default will be len(str) + 1
    assert "A".replace("", "", len("A") + 1) == "A"
    assert "A".replace("", "*", len("A") + 1) == "*A*"
    assert "A".replace("", "*1", len("A") + 1) == "*1A*1"
    assert "A".replace("", "*-#", len("A") + 1) == "*-#A*-#"
    assert "AA".replace("", "*-", len("AA") + 1) == "*-A*-A*-"
    assert "AA".replace("", "*-", -1) == "*-A*-A*-"
    assert "AA".replace("", "*-") == "*-A*-A*-"
    assert "AA".replace("", "*-", 4) == "*-A*-A*-"
    assert "AA".replace("", "*-", 3) == "*-A*-A*-"
    assert "AA".replace("", "*-", 2) == "*-A*-A"
    assert "AA".replace("", "*-", 1) == "*-AA"
    assert "AA".replace("", "*-", 0) == "AA"

    # substring deletion
    assert "A".replace("A", "", len("A") + 1) == ""
    assert "AAA".replace("A", "", len("AAA") + 1) == ""
    assert "AAA".replace("A", "", -1) == ""
    assert "AAA".replace("A", "") == ""
    assert "AAA".replace("A", "", 4) == ""
    assert "AAA".replace("A", "", 3) == ""
    assert "AAA".replace("A", "", 2) == "A"
    assert "AAA".replace("A", "", 1) == "AA"
    assert "AAA".replace("A", "", 0) == "AAA"
    assert "ABACADA".replace("A", "", len("ABACADA") + 1) == "BCD"
    assert "ABACADA".replace("A", "", -1) == "BCD"
    assert "ABACADA".replace("A", "", 5) == "BCD"
    assert "ABACADA".replace("A", "", 4) == "BCD"
    assert "ABACADA".replace("A", "", 3) == "BCDA"
    assert "ABACADA".replace("A", "", 2) == "BCADA"
    assert "ABACADA".replace("A", "", 1) == "BACADA"
    assert "ABACADA".replace("A", "", 0) == "ABACADA"
    assert "ABCAD".replace("A", "", len("ABCAD") + 1) == "BCD"
    assert "ABCADAA".replace("A", "", len("ABCADAA") + 1) == "BCD"
    assert "BCD".replace("A", "", len("BCD") + 1) == "BCD"
    assert ("^" + ("A" * 1000) + "^").replace("A", "", 999) == "^A^"
    assert "the".replace("the", "", len("the") + 1) == ""
    assert "theater".replace("the", "", len("theater") + 1) == "ater"
    assert "thethe".replace("the", "", len("thethe") + 1) == ""
    assert "thethethethe".replace("the", "", len("thethethethe") + 1) == ""
    assert "theatheatheathea".replace("the", "", len("theatheatheathea") + 1) == "aaaa"
    assert "that".replace("the", "", len("that") + 1) == "that"
    assert (
        "here and there".replace("the", "", len("here and there") + 1) == "here and re"
    )
    assert (
        "here and there and there".replace(
            "the", "", len("here and there and there") + 1
        )
        == "here and re and re"
    )
    assert "here and there and there".replace("the", "", -1) == "here and re and re"
    assert "here and there and there".replace("the", "", 3) == "here and re and re"
    assert "here and there and there".replace("the", "", 2) == "here and re and re"
    assert "here and there and there".replace("the", "", 1) == "here and re and there"
    assert (
        "here and there and there".replace("the", "", 0) == "here and there and there"
    )

    # substring replace in place
    assert (
        "Who goes there?".replace("o", "o", len("Who goes there?") + 1)
        == "Who goes there?"
    )
    assert (
        "Who goes there?".replace("o", "O", len("Who goes there?") + 1)
        == "WhO gOes there?"
    )
    assert "Who goes there?".replace("o", "O", -1) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 3) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 2) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 1) == "WhO goes there?"
    assert "Who goes there?".replace("o", "O", 0) == "Who goes there?"
    assert (
        "Who goes there?".replace("a", "q", len("Who goes there?") + 1)
        == "Who goes there?"
    )
    assert (
        "Who goes there?".replace("W", "w", len("Who goes there?") + 1)
        == "who goes there?"
    )
    assert (
        "WWho goes there?WW".replace("W", "w", len("WWho goes there?WW") + 1)
        == "wwho goes there?ww"
    )
    assert (
        "Who goes there?".replace("?", "!", len("Who goes there?") + 1)
        == "Who goes there!"
    )
    assert (
        "This is a tissue".replace("is", "**", len("This is a tissue") + 1)
        == "Th** ** a t**sue"
    )
    assert "This is a tissue".replace("is", "**", -1) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 4) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 3) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 2) == "Th** ** a tissue"
    assert "This is a tissue".replace("is", "**", 1) == "Th** is a tissue"
    assert "This is a tissue".replace("is", "**", 0) == "This is a tissue"
    assert "Reykjavik".replace("k", "KK", len("Reykjavik") + 1) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", -1) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", 2) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", 1) == "ReyKKjavik"
    assert "Reykjavik".replace("k", "KK", 0) == "Reykjavik"
    assert "A.B.C.".replace(".", "----", len("A.B.C.") + 1) == "A----B----C----"
    assert (
        "spam, spam, eggs and spam".replace(
            "spam", "ham", len("spam, spam, eggs and spam") + 1
        )
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", -1)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 4)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 3)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 2)
        == "ham, ham, eggs and spam"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 1)
        == "ham, spam, eggs and spam"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 0)
        == "spam, spam, eggs and spam"
    )


</t>
<t tx="ekr.20230509052845.533"></t>
<t tx="ekr.20230509052845.5330">@test
def test_expandtabs():
    assert "abc\rab\tdef\ng\thi".expandtabs(8) == "abc\rab      def\ng       hi"
    assert "abc\rab\tdef\ng\thi".expandtabs(8) == "abc\rab      def\ng       hi"
    assert "abc\rab\tdef\ng\thi".expandtabs(4) == "abc\rab  def\ng   hi"
    assert "abc\r\nab\tdef\ng\thi".expandtabs(8) == "abc\r\nab      def\ng       hi"
    assert "abc\r\nab\tdef\ng\thi".expandtabs(4) == "abc\r\nab  def\ng   hi"
    assert "abc\r\nab\r\ndef\ng\r\nhi".expandtabs(4) == "abc\r\nab\r\ndef\ng\r\nhi"
    assert " \ta\n\tb".expandtabs(1) == "  a\n b"
    assert "\tdndhd\ty\ty\tyu\t".expandtabs(3) == "   dndhd y  y  yu "


</t>
<t tx="ekr.20230509052845.5331">@test
def test_translate():
    assert "I yor ge".translate({ord("g"): "w", ord("y"): "f"}) == "I for we"
    assert "abababc".translate({ord("a"): ""}) == "bbbc"
    assert "abababc".translate({ord("a"): "", ord("b"): "i"}) == "iiic"
    assert "abababc".translate({ord("a"): "", ord("b"): "i", ord("c"): "x"}) == "iiix"
    assert "abababc".translate({ord("a"): "", ord("b"): ""}) == "c"
    assert "xzx".translate({ord("z"): "yy"}) == "xyyx"
    assert "aaabbbccc".translate({ord("b"): Optional("XY"), ord("c"): None, ord("a"): Optional("")}) == "XYXYXY"

</t>
<t tx="ekr.20230509052845.5332">@test
def test_repr():
    assert repr("") == "''"
    assert repr("hello") == "'hello'"
    assert repr("     ") == "'     '"
    assert repr("\r\a\n\t") == "'\\r\\a\\n\\t'"


</t>
<t tx="ekr.20230509052845.5333">@test
def test_fstr():
    assert f"{2+2}" == "4"
    n = 42
    assert f"{n}{n}xx{n}" == "4242xx42"
    assert f"{n=}" == "n=42"
    assert f"hello {n=} world" == "hello n=42 world"


</t>
<t tx="ekr.20230509052845.5334">@test
def test_slice(
    s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    indices=(0, 1, 3, 41, 0xFFFFFFFFFFF, -1, -2, -37),
):
    for start in indices:
        for stop in indices:
            for step in indices[1:]:
                L = list(s)[start:stop:step]
                assert s[start:stop:step] == "".join(L)


</t>
<t tx="ekr.20230509052845.5335">@test
def test_join():
    assert "".join(str(a) for a in range(0)) == ""
    assert "".join(List[str]()) == ""
    assert "a".join(str(a) for a in range(0)) == ""
    assert "a".join(List[str]()) == ""
    assert "ab".join(str(a) for a in range(999, 1000)) == "999"
    assert "ab".join(["999"]) == "999"
    assert "xyz".join(str(a) for a in range(5)) == "0xyz1xyz2xyz3xyz4"
    assert "xyz".join(["00", "1", "22", "3", "44"]) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(iter(["00", "1", "22", "3", "44"])) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(["00", "1", "22", "3", "44"]) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(iter(["00", "", "22", "3", ""])) == "00xyzxyz22xyz3xyz"


</t>
<t tx="ekr.20230509052845.5336">@test
def test_repr():
    s = (
        "\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
        "\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg"
        "hijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91"
        "\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xff"
    )
    assert repr(s) == (
        "'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11"
        "\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&amp;\\'()*+,"
        "-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\"
        "x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90"
        "\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xff'"
    )
    assert repr("") == "''"
    assert repr('"') == "'\"'"
    assert repr("'") == '"\'"'
    assert repr("\"'") == "'\"\\''"


</t>
<t tx="ekr.20230509052845.5337"></t>
<t tx="ekr.20230509052845.5338">@path C:/Repos/codon/test/transform/
@others
test_add_mul_canon()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5339">@tuple
class Vec[T]:
    x: T
    y: T

    @others
</t>
<t tx="ekr.20230509052845.534">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvisitor.h"
#include "codon/cir/module.h"
#include "codon/cir/transform/manager.h"
#include "codon/compiler/error.h"
#include "codon/dsl/plugins.h"
#include "codon/parser/cache.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5340">@pure
def __abs__(self):
    return ((self.x * self.x) + (self.y * self.y)) ** 0.5

</t>
<t tx="ekr.20230509052845.5341">@pure
@commutative
@associative
def __add__(self, other: Vec[T]):
    print 'vec add', self, other
    return Vec[T](self.x + other.x, self.y + other.y)

</t>
<t tx="ekr.20230509052845.5342">@pure
@commutative
@associative
def __add__(self, other: T):
    print 'vec add', self, other
    return Vec[T](self.x + other, self.y + other)

</t>
<t tx="ekr.20230509052845.5343">@pure
def __sub__(self, other: Vec[T]):
    print 'vec sub', self, other
    return Vec[T](self.x - other.x, self.y - other.y)

</t>
<t tx="ekr.20230509052845.5344">@pure
def __sub__(self, other: T):
    print 'vec sub', self, other
    return Vec[T](self.x - other, self.y - other)

</t>
<t tx="ekr.20230509052845.5345">@pure
@commutative
@associative
@distributive
def __mul__(self, other: Vec[T]):
    print 'vec mul', self, other
    return Vec[T](self.x * other.x, self.y * other.y)

</t>
<t tx="ekr.20230509052845.5346">@pure
@commutative
@associative
@distributive
def __mul__(self, other: T):
    print 'vec mul', self, other
    return Vec[T](self.x * other, self.y * other)

</t>
<t tx="ekr.20230509052845.5347">@pure
@commutative
def __eq__(self, other: Vec[T]):
    print 'vec eq', self, other
    return abs(self) == abs(other)

</t>
<t tx="ekr.20230509052845.5348">@pure
@commutative
def __ne__(self, other: Vec[T]):
    print 'vec ne', self, other
    return abs(self) != abs(other)

</t>
<t tx="ekr.20230509052845.5349">@pure
def __lt__(self, other: Vec[T]):
    print 'vec lt', self, other
    return abs(self) &lt; abs(other)

</t>
<t tx="ekr.20230509052845.535">class Compiler {
public:
  enum Mode {
    DEBUG,
    RELEASE,
    JIT,
  };

private:
  std::string argv0;
  bool debug;
  bool pyNumerics;
  bool pyExtension;
  std::string input;
  std::unique_ptr&lt;PluginManager&gt; plm;
  std::unique_ptr&lt;ast::Cache&gt; cache;
  std::unique_ptr&lt;ir::Module&gt; module;
  std::unique_ptr&lt;ir::transform::PassManager&gt; pm;
  std::unique_ptr&lt;ir::LLVMVisitor&gt; llvisitor;

  llvm::Error parse(bool isCode, const std::string &amp;file, const std::string &amp;code,
                    int startLine, int testFlags,
                    const std::unordered_map&lt;std::string, std::string&gt; &amp;defines);

public:
  Compiler(const std::string &amp;argv0, Mode mode,
           const std::vector&lt;std::string&gt; &amp;disabledPasses = {}, bool isTest = false,
           bool pyNumerics = false, bool pyExtension = false);

  explicit Compiler(const std::string &amp;argv0, bool debug = false,
                    const std::vector&lt;std::string&gt; &amp;disabledPasses = {},
                    bool isTest = false, bool pyNumerics = false,
                    bool pyExtension = false)
      : Compiler(argv0, debug ? Mode::DEBUG : Mode::RELEASE, disabledPasses, isTest,
                 pyNumerics, pyExtension) {}

  std::string getInput() const { return input; }
  PluginManager *getPluginManager() const { return plm.get(); }
  ast::Cache *getCache() const { return cache.get(); }
  ir::Module *getModule() const { return module.get(); }
  ir::transform::PassManager *getPassManager() const { return pm.get(); }
  ir::LLVMVisitor *getLLVMVisitor() const { return llvisitor.get(); }

  llvm::Error load(const std::string &amp;plugin);
  llvm::Error
  parseFile(const std::string &amp;file, int testFlags = 0,
            const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {});
  llvm::Error
  parseCode(const std::string &amp;file, const std::string &amp;code, int startLine = 0,
            int testFlags = 0,
            const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {});
  llvm::Error compile();
  llvm::Expected&lt;std::string&gt; docgen(const std::vector&lt;std::string&gt; &amp;files);

  std::unordered_map&lt;std::string, std::string&gt; getEarlyDefines();
};

</t>
<t tx="ekr.20230509052845.5350">@pure
def __le__(self, other: Vec[T]):
    print 'vec le', self, other
    return abs(self) &lt;= abs(other)

</t>
<t tx="ekr.20230509052845.5351">@pure
def __gt__(self, other: Vec[T]):
    print 'vec gt', self, other
    return abs(self) &gt; abs(other)

</t>
<t tx="ekr.20230509052845.5352">@pure
def __ge__(self, other: Vec[T]):
    print 'vec ge', self, other
    return abs(self) &gt;= abs(other)

</t>
<t tx="ekr.20230509052845.5353">@test
def test_op_chain_canon():
    @others
    a = Vec(1, 2)
    b = Vec(3, 4)
    c = a + f(b)  # -&gt; f(b) + a
    assert (c.x, c.y) == (4, 6)
    # EXPECT: vec add (x: 3, y: 4) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = Vec(5, 6)
    d = f(a + f(b) + f(f(c)))  # -&gt; f(f(f(c)) + f(b) + a)
    assert (d.x, d.y) == (9, 12)
    # EXPECT: vec add (x: 5, y: 6) (x: 3, y: 4)
    # EXPECT: vec add (x: 8, y: 10) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = Vec(5, 6)
    d = f(a + (f(b) + f(f(c))))  # -&gt; f(f(f(c)) + f(b) + a)
    assert (d.x, d.y) == (9, 12)
    # EXPECT: vec add (x: 5, y: 6) (x: 3, y: 4)
    # EXPECT: vec add (x: 8, y: 10) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = a - f(b)  # -&gt; no change
    assert (c.x, c.y) == (-2, -2)
    # EXPECT: vec sub (x: 1, y: 2) (x: 3, y: 4)

    # don't canon float ops
    assert f(1e100) + f(f(-1e100)) + f(f(f(1.))) == 1.
</t>
<t tx="ekr.20230509052845.5354">@pure
def f(a): return a

</t>
<t tx="ekr.20230509052845.5355">test_op_chain_canon()

</t>
<t tx="ekr.20230509052845.5356">class C:
    n: int

    def __lt__(self: C, other: C):
        return self.n &lt; other.n

</t>
<t tx="ekr.20230509052845.5357">@test
def test_inequality_canon():
    @others
    a = Vec(1,1)
    b = Vec(2,2)

    assert not (f(a) == b)
    assert f(a) != b
    assert f(a) &lt; b
    assert f(a) &lt;= b
    assert not (f(a) &gt; b)
    assert not (f(a) &gt;= b)
    # EXPECT: vec eq (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec ne (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec lt (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec le (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec gt (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec ge (x: 1, y: 1) (x: 2, y: 2)

    assert not (a == f(b))
    assert a != f(b)
    assert a &lt; f(b)
    assert a &lt;= f(b)
    assert not (a &gt; f(b))
    assert not (a &gt;= f(b))
    # EXPECT: vec eq (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec ne (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec gt (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec ge (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec lt (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec le (x: 2, y: 2) (x: 1, y: 1)

    c1 = C(1)
    c2 = C(2)
    # ensure we don't use missing ops
    assert c1 &lt; f(c2)
</t>
<t tx="ekr.20230509052845.5358">@pure
def f(a): return a

</t>
<t tx="ekr.20230509052845.5359">test_inequality_canon()

</t>
<t tx="ekr.20230509052845.536">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5360">@test
def test_add_mul_canon():
    @pure
    def f(a): return a

    a = Vec(1,1)
    b = Vec(2,2)
    c = Vec(3,3)
    d = (a*f(b) + c*a)  # -&gt; (f(b) + c) * a
    assert (d.x, d.y) == (5, 5)
    # EXPECT: vec add (x: 2, y: 2) (x: 3, y: 3)
    # EXPECT: vec mul (x: 5, y: 5) (x: 1, y: 1)

    d = (a + c*a)  # -&gt; (c + 1) * a
    assert (d.x, d.y) == (4, 4)
    # EXPECT: vec add (x: 3, y: 3) 1
    # EXPECT: vec mul (x: 4, y: 4) (x: 1, y: 1)

    d = (c*a + a)  # -&gt; (c + 1) * a
    assert (d.x, d.y) == (4, 4)
    # EXPECT: vec add (x: 3, y: 3) 1
    # EXPECT: vec mul (x: 4, y: 4) (x: 1, y: 1)

    a = Vec(1,1)
    b = a + a + a + a + a
    assert (b.x, b.y) == (5, 5)
    # EXPECT: vec mul (x: 1, y: 1) 5

    a = Vec(1,1)
    b = a + a*2 + a*3 + a*4 + a*5
    assert (b.x, b.y) == (15, 15)
    # EXPECT: vec mul (x: 1, y: 1) 15

    x = f(100.)  # don't distribute float ops
    assert (x * 0.1) + (x * 0.2) == 30.
</t>
<t tx="ekr.20230509052845.5361">@path C:/Repos/codon/test/transform/
@others
test_wrapped_dict()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5362">class DummyDict[K, V]:
    @others
</t>
<t tx="ekr.20230509052845.5363">def __getitem__(self, k: K):
    raise ValueError('failed')
    return V()
</t>
<t tx="ekr.20230509052845.5364">def get(self, k: K, d: V):
    raise ValueError('failed')
    return V()
</t>
<t tx="ekr.20230509052845.5365">def __setitem__(self, k: K, v: V):
    assert False
</t>
<t tx="ekr.20230509052845.5366">def __dict_do_op_throws__[F, Z](self, key: K, other: Z, op: F):
    pass
</t>
<t tx="ekr.20230509052845.5367">def __dict_do_op__[F, Z](self, key: K, other: Z, dflt: V, op: F):
    pass

</t>
<t tx="ekr.20230509052845.5368">class WrappedDict[K, V]:
    d: Dict[K,V]
    do_op_throws_count: int
    do_op_count: int

    @others
</t>
<t tx="ekr.20230509052845.5369">def __init__(self):
    self.d = {}
    self.do_op_throws_count = 0
    self.do_op_count = 0
</t>
<t tx="ekr.20230509052845.537">/// Debug info tracker for MCJIT.
class DebugListener : public llvm::JITEventListener {
public:
@others
private:
  std::vector&lt;ObjectInfo&gt; objects;

  void notifyObjectLoaded(ObjectKey key, const llvm::object::ObjectFile &amp;obj,
                          const llvm::RuntimeDyld::LoadedObjectInfo &amp;L) override;
  void notifyFreeingObject(ObjectKey key) override;

public:
  DebugListener() : llvm::JITEventListener(), objects() {}

  llvm::Expected&lt;llvm::DILineInfo&gt; symbolize(uintptr_t pc);
  llvm::Expected&lt;std::string&gt; getPrettyBacktrace(uintptr_t pc);
  std::string getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace);
};

</t>
<t tx="ekr.20230509052845.5370">def __getitem__(self, k: K):
    return self.d.__getitem__(k)
</t>
<t tx="ekr.20230509052845.5371">def get(self, k: K, d: V):
    return self.d.get(k, d)
</t>
<t tx="ekr.20230509052845.5372">def __setitem__(self, k: K, v: V):
    self.d.__setitem__(k, v)
</t>
<t tx="ekr.20230509052845.5373">def setdefault(self, k: K, v: V):
    return self.d.setdefault(k, v)

</t>
<t tx="ekr.20230509052845.5374">def __dict_do_op_throws__[F, Z](self, key: K, other: Z, op: F):
    self.do_op_throws_count += 1
    self.d.__dict_do_op_throws__(key, other, op)
</t>
<t tx="ekr.20230509052845.5375">def __dict_do_op__[F, Z](self, key: K, other: Z, dflt: V, op: F):
    self.do_op_count += 1
    self.d.__dict_do_op__(key, other, dflt, op)

</t>
<t tx="ekr.20230509052845.5376">@test
def test_dict_op():
    x = DummyDict[int, int]()
    x[1] = x[1] + 1
    x[1] = x.get(1, 1) + 1
</t>
<t tx="ekr.20230509052845.5377">test_dict_op()

</t>
<t tx="ekr.20230509052845.5378">@test
def test_dict_do_not_op():
    x = DummyDict[int, int]()
    try:
        x[1] = x[2] + 1
    except ValueError:
        return
    assert False
</t>
<t tx="ekr.20230509052845.5379">test_dict_do_not_op()

</t>
<t tx="ekr.20230509052845.538">  class ObjectInfo {
  private:
    ObjectKey key;
    std::unique_ptr&lt;llvm::object::ObjectFile&gt; object;
    std::unique_ptr&lt;llvm::MemoryBuffer&gt; buffer;
    uintptr_t start;
    uintptr_t stop;

  public:
    ObjectInfo(ObjectKey key, std::unique_ptr&lt;llvm::object::ObjectFile&gt; object,
               std::unique_ptr&lt;llvm::MemoryBuffer&gt; buffer, uintptr_t start,
               uintptr_t stop)
        : key(key), object(std::move(object)), buffer(std::move(buffer)), start(start),
          stop(stop) {}

    ObjectKey getKey() const { return key; }
    const llvm::object::ObjectFile &amp;getObject() const { return *object; }
    uintptr_t getStart() const { return start; }
    uintptr_t getStop() const { return stop; }
    bool contains(uintptr_t pc) const { return start &lt;= pc &amp;&amp; pc &lt; stop; }
  };

</t>
<t tx="ekr.20230509052845.5380">@test
def test_wrapped_dict():
    @others
    x = WrappedDict[str, float]()
    x['a'] = x.get('a', 0.0) + 1.0        # invokes opt (do_op_count)
    x['a'] = x['a'] * 2                   # invokes opt (do_op_throws_count)
    x['b'] = x.setdefault('b', 4.5) + 99  # no opt (no getitem/get)
    x['a'] += x['b']                      # invokes opt (do_op_throws_count)
    x['b'] = my_op(x['b'], 2.0)           # no opt (not a int/float method)
    foo = x['a']
    x['a'] = x['b'] + foo                 # no opt (different keys)

    try:
        x['c'] += 1.0                     # invokes opt (do_op_throws_count)
        assert False
    except KeyError:
        pass

    try:
        x['d'] = my_op_throws(x['d'], 2.0)  # no opt (not a int/float method)
        assert False
    except KeyError:
        pass

    try:
        x['d'] = my_op_throws(x.get('d', 111.0), 2.0)  # no opt (not a int/float method)
        assert False
    except ValueError:
        pass

    assert x.do_op_throws_count == 3
    assert x.do_op_count == 1
    assert x.d == {'a': 312.5, 'b': 207}
</t>
<t tx="ekr.20230509052845.5381">def my_op(a, b):
    return a * b
</t>
<t tx="ekr.20230509052845.5382">def my_op_throws(a, b):
    raise ValueError('my_op_throws')
    return a * b

</t>
<t tx="ekr.20230509052845.5383">@path C:/Repos/codon/test/transform/
@others
test_27('x')
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5384"># entry point for validator
@nonpure
def expect_capture(return_captures: bool, extern_captures: bool, arg_captures):
    return False

</t>
<t tx="ekr.20230509052845.5385">g = [0]
h = ''

</t>
<t tx="ekr.20230509052845.5386">@nonpure
def make_sure_globals_arent_optd_out():
    g.append(1)
    print(h)

</t>
<t tx="ekr.20230509052845.5387">make_sure_globals_arent_optd_out()

</t>
<t tx="ekr.20230509052845.5388">@test
def test_1(a):
    global g
    g = a
    assert expect_capture(False, True, ())  # a
</t>
<t tx="ekr.20230509052845.5389">test_1([42])

</t>
<t tx="ekr.20230509052845.539">/// Debug info tracker for JITLink. Adapted from Julia's implementation:
/// https://github.com/JuliaLang/julia/blob/master/src/jitlayers.cpp
class DebugPlugin : public llvm::orc::ObjectLinkingLayer::Plugin {
  struct JITObjectInfo {
    std::unique_ptr&lt;llvm::MemoryBuffer&gt; backingBuffer;
    std::unique_ptr&lt;llvm::object::ObjectFile&gt; object;
    llvm::StringMap&lt;uint64_t&gt; sectionLoadAddresses;
  };

  std::mutex pluginMutex;
  std::map&lt;llvm::orc::MaterializationResponsibility *, std::unique_ptr&lt;JITObjectInfo&gt;&gt;
      pendingObjs;
  std::map&lt;llvm::orc::ResourceKey, std::vector&lt;std::unique_ptr&lt;JITObjectInfo&gt;&gt;&gt;
      registeredObjs;

public:
  void notifyMaterializing(llvm::orc::MaterializationResponsibility &amp;mr,
                           llvm::jitlink::LinkGraph &amp;graph,
                           llvm::jitlink::JITLinkContext &amp;ctx,
                           llvm::MemoryBufferRef inputObject) override;
  llvm::Error notifyEmitted(llvm::orc::MaterializationResponsibility &amp;mr) override;
  llvm::Error notifyFailed(llvm::orc::MaterializationResponsibility &amp;mr) override;
  llvm::Error notifyRemovingResources(llvm::orc::ResourceKey key) override;
  void notifyTransferringResources(llvm::orc::ResourceKey dstKey,
                                   llvm::orc::ResourceKey srcKey) override;
  void modifyPassConfig(llvm::orc::MaterializationResponsibility &amp;mr,
                        llvm::jitlink::LinkGraph &amp;,
                        llvm::jitlink::PassConfiguration &amp;config) override;

  llvm::Expected&lt;llvm::DILineInfo&gt; symbolize(uintptr_t pc);
  llvm::Expected&lt;std::string&gt; getPrettyBacktrace(uintptr_t pc);
  std::string getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace);
};

</t>
<t tx="ekr.20230509052845.5390">@test
def test_2(a, b, c):
    x = c
    b[0] = a
    y = x
    assert expect_capture(False, False, (1,))  # a
    assert expect_capture(False, False, ())    # b
    assert expect_capture(False, False, ())    # c
</t>
<t tx="ekr.20230509052845.5391">test_2([42], [[1]], ['x'])

</t>
<t tx="ekr.20230509052845.5392">@test
def test_3(a):
    global g
    x = [1]
    p = __ptr__(x)
    p[0] = a
    q = p
    g = p[0]
    assert expect_capture(False, True, ())  # a
</t>
<t tx="ekr.20230509052845.5393">test_3([42])

</t>
<t tx="ekr.20230509052845.5394">@test
def test_4(a):
    global g
    v = [a]
    g = v[0]
    assert expect_capture(False, True, ())  # a
</t>
<t tx="ekr.20230509052845.5395">test_4([42])

</t>
<t tx="ekr.20230509052845.5396">@test
def test_5(a):
    global g
    v = [a]
    for i in v:
        g = i
    assert expect_capture(False, True, ())  # a
</t>
<t tx="ekr.20230509052845.5397">test_5([42])

</t>
<t tx="ekr.20230509052845.5398">@test
def test_6(a, b, c):
    a[0] = b
    c[0] = a
    assert expect_capture(False, False, (2,))    # a
    assert expect_capture(False, False, (0, 2))  # b
    assert expect_capture(False, False, ())      # c
</t>
<t tx="ekr.20230509052845.5399">test_6([[0]], [42], [[[0]]])

</t>
<t tx="ekr.20230509052845.54">def __repr__(self):
    return "GVector(%f, %f, %f)" % (self.x, self.y, self.z)


</t>
<t tx="ekr.20230509052845.540">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/compiler/debug_listener.h"

namespace codon {
namespace jit {

@others
} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5400">@test
def test_7(a, b, c):
    assert expect_capture(True, False, ())   # a
    assert expect_capture(False, False, ())  # b
    assert expect_capture(True, False, ())   # c
    return a if b else c
</t>
<t tx="ekr.20230509052845.5401">test_7([11], g, [22])

</t>
<t tx="ekr.20230509052845.5402">class X:
    v: List[List[int]]

</t>
<t tx="ekr.20230509052845.5403">@test
def test_8(a):
    x = X([])
    x.v.append(a)
    assert expect_capture(True, False, ())  # a
    return x
</t>
<t tx="ekr.20230509052845.5404">test_8([42])

</t>
<t tx="ekr.20230509052845.5405">@test
def test_9(a):
    a = [0]
    assert expect_capture(False, False, ())  # a
    return a
</t>
<t tx="ekr.20230509052845.5406">test_9([42])

</t>
<t tx="ekr.20230509052845.5407">@test
def test_10(a, b):
    if b:
        a = [0]
    assert expect_capture(True, False, ())   # a
    assert expect_capture(False, False, ())  # b
    return a
</t>
<t tx="ekr.20230509052845.5408">test_10([42], [99])

</t>
<t tx="ekr.20230509052845.5409">@test
def test_11(a):
    global g
    g = a
    assert expect_capture(True, True, ())  # a
    return g
</t>
<t tx="ekr.20230509052845.541">class Engine {
private:
  std::unique_ptr&lt;llvm::orc::ExecutionSession&gt; sess;
  std::unique_ptr&lt;llvm::orc::EPCIndirectionUtils&gt; epciu;

  llvm::DataLayout layout;
  llvm::orc::MangleAndInterner mangle;

  llvm::orc::RTDyldObjectLinkingLayer objectLayer;
  llvm::orc::IRCompileLayer compileLayer;
  llvm::orc::IRTransformLayer optimizeLayer;
  llvm::orc::CompileOnDemandLayer codLayer;

  llvm::orc::JITDylib &amp;mainJD;

  std::unique_ptr&lt;DebugListener&gt; dbListener;

  static void handleLazyCallThroughError();

  static llvm::Expected&lt;llvm::orc::ThreadSafeModule&gt;
  optimizeModule(llvm::orc::ThreadSafeModule module,
                 const llvm::orc::MaterializationResponsibility &amp;R);

public:
  Engine(std::unique_ptr&lt;llvm::orc::ExecutionSession&gt; sess,
         std::unique_ptr&lt;llvm::orc::EPCIndirectionUtils&gt; epciu,
         llvm::orc::JITTargetMachineBuilder jtmb, llvm::DataLayout layout);

  ~Engine();

  static llvm::Expected&lt;std::unique_ptr&lt;Engine&gt;&gt; create();

  const llvm::DataLayout &amp;getDataLayout() const { return layout; }

  llvm::orc::JITDylib &amp;getMainJITDylib() { return mainJD; }

  DebugListener *getDebugListener() const { return dbListener.get(); }

  llvm::Error addModule(llvm::orc::ThreadSafeModule module,
                        llvm::orc::ResourceTrackerSP rt = nullptr);

  llvm::Expected&lt;llvm::JITEvaluatedSymbol&gt; lookup(llvm::StringRef name);
};

</t>
<t tx="ekr.20230509052845.5410">test_11([42])

</t>
<t tx="ekr.20230509052845.5411">@test
def test_12(a, b):
    global g
    b[0] = a
    x = {2: b}
    y = [x]
    z = {'z': y}
    g = z['z'][0][2][0]
    assert expect_capture(True, True, (1,))  # a
    assert expect_capture(True, True, (0,))  # b
    return z
</t>
<t tx="ekr.20230509052845.5412">test_12([42], [[0]])

</t>
<t tx="ekr.20230509052845.5413">@test
def test_13(a, n):
    if n &gt; 0:
        test_13(a, n - 1)
    assert expect_capture(True, True, ())    # a
    assert expect_capture(False, False, ())  # b
    return a
</t>
<t tx="ekr.20230509052845.5414">test_13([42], 3)

</t>
<t tx="ekr.20230509052845.5415">@test
def test_14(a):
    def assign_global(a):
        global g
        g = a

    assign_global(a)
    assert expect_capture(True, True, ())  # a
    return g
</t>
<t tx="ekr.20230509052845.5416">test_14([42])

</t>
<t tx="ekr.20230509052845.5417">class A:
    a: Optional[A]

</t>
<t tx="ekr.20230509052845.5418">@test
def test_15(a, b):
    a.a = b
    b.a = a
    assert expect_capture(False, False, (1,))  # a
    assert expect_capture(False, False, (0,))  # b
</t>
<t tx="ekr.20230509052845.5419">test_15(A(None), A(None))

</t>
<t tx="ekr.20230509052845.542">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/error.h"
#include "llvm/Support/Error.h"
#include &lt;fmt/format.h&gt;

namespace codon {
namespace error {

@others
} // namespace error
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5420">@test
def test_16(a, b):
    a.a = b
    b.a = a
    assert expect_capture(True, False, (1,))  # a
    assert expect_capture(True, False, (0,))  # b
    return a
</t>
<t tx="ekr.20230509052845.5421">test_16(A(None), A(None))

</t>
<t tx="ekr.20230509052845.5422">@test
def test_17(a):
    global h
    h = a[1:-1]
    assert expect_capture(True, True, ())  # a
    return a[2:-2]
</t>
<t tx="ekr.20230509052845.5423">test_17('hello world')

</t>
<t tx="ekr.20230509052845.5424">@test
def test_18(a, b):
    if a:
        x = (b, b)
        raise ValueError(x[len(b)])
    assert expect_capture(False, False, ())  # a
    assert expect_capture(False, True, ())   # b
</t>
<t tx="ekr.20230509052845.5425">test_18([0 for _ in range(0)], 'b')

</t>
<t tx="ekr.20230509052845.5426">def assign1(x, y):
    x[0] = y

</t>
<t tx="ekr.20230509052845.5427">@test
def test_19(a, b, cond, elem):
    assign1(a if cond else b, elem)
    assert expect_capture(False, False, ())     # a
    assert expect_capture(True, False, ())      # b
    assert expect_capture(False, False, ())     # cond
    assert expect_capture(True, False, (0, 1))  # elem
    return b
</t>
<t tx="ekr.20230509052845.5428">test_19(['a'], ['b'], [True], 'x')

</t>
<t tx="ekr.20230509052845.5429">@test
def test_20(x):
    a = ['']
    p = a
    p[0] = x
    assert expect_capture(True, False, ())  # x
    return a
</t>
<t tx="ekr.20230509052845.543">class Message {
private:
  std::string msg;
  std::string file;
  int line = 0;
  int col = 0;
  int len = 0;
  int errorCode = -1;

public:
  explicit Message(const std::string &amp;msg, const std::string &amp;file = "", int line = 0,
@others
};

</t>
<t tx="ekr.20230509052845.5430">test_20('x')

</t>
<t tx="ekr.20230509052845.5431">@test
def test_21(x):
    a = ''
    p = __ptr__(a)
    p[0] = x
    assert expect_capture(True, False, ())  # x
    return a
</t>
<t tx="ekr.20230509052845.5432">test_21('x')

</t>
<t tx="ekr.20230509052845.5433">class A:
    a: List[str]

</t>
<t tx="ekr.20230509052845.5434">@test
def test_22(x):
    a = ['']
    p = A([])
    p.a = a
    p.a[0] = x
    assert expect_capture(True, False, ())  # x
    return a
</t>
<t tx="ekr.20230509052845.5435">test_22('x')

</t>
<t tx="ekr.20230509052845.5436">def assign(p, a):
    p.a = a

</t>
<t tx="ekr.20230509052845.5437">def test_23(x):
    a = ['']
    p = A([])
    assign(p, a)
    p.a[0] = x
    assert expect_capture(True, False, ())  # x
    return a
</t>
<t tx="ekr.20230509052845.5438">test_23('x')

</t>
<t tx="ekr.20230509052845.5439">class S:
    s: str

</t>
<t tx="ekr.20230509052845.544">                   int col = 0, int len = 0, int errorCode = -1)
      : msg(msg), file(file), line(line), col(col), len(len), errorCode(-1) {}

  std::string getMessage() const { return msg; }
  std::string getFile() const { return file; }
  int getLine() const { return line; }
  int getColumn() const { return col; }
  int getLength() const { return len; }
  int getErrorCode() const { return errorCode; }

    @others
</t>
<t tx="ekr.20230509052845.5440">@test
def test_24(a, b, cond):
    q = S('')
    if cond:
        q = a
    q.s = b
    assert expect_capture(False, False, ())    # a
    assert expect_capture(False, False, (0,))  # b
    assert expect_capture(False, False, ())    # cond
</t>
<t tx="ekr.20230509052845.5441">test_24(S('s'), 'b', True)

</t>
<t tx="ekr.20230509052845.5442">@test
def test_25(a, b, v):
    q = S('')
    for i in v:
        if i:
            q = a
        else:
            q = S('q')
    q.s = b
    assert expect_capture(False, False, ())    # a
    assert expect_capture(False, False, (0,))  # b
    assert expect_capture(False, False, ())    # v
</t>
<t tx="ekr.20230509052845.5443">test_25(S('s'), 'b', [0,1,0,1])

</t>
<t tx="ekr.20230509052845.5444">@test
def test_26(a, b, v):
    q = S('')
    for i in v:
        if i:
            q = a
        else:
            q.s = b
    return q
    assert expect_capture(True, False, ())    # a
    assert expect_capture(True, False, (0,))  # b
    assert expect_capture(False, False, ())   # v
    return q
</t>
<t tx="ekr.20230509052845.5445">test_26(S('s'), 'b', [0,1,0,1])

</t>
<t tx="ekr.20230509052845.5446">@test
def test_27(x):
    a = ''
    p = __ptr__(a)
    q = __ptr__(p)
    q[0][0] = x
    assert expect_capture(True, False, ())  # x
    return a
</t>
<t tx="ekr.20230509052845.5447">@path C:/Repos/codon/test/transform/
OP_COUNT = 0

@others
test_side_effect_analysis()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5448">@llvm
def inc(a: int) -&gt; int:
    %tmp = add i64 %a, 1
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5449">class I:
    @others
</t>
<t tx="ekr.20230509052845.545">void log(llvm::raw_ostream &amp;out) const {
if (!getFile().empty()) {
  out &lt;&lt; getFile();
  if (getLine() != 0) {
    out &lt;&lt; ":" &lt;&lt; getLine();
    if (getColumn() != 0) {
      out &lt;&lt; ":" &lt;&lt; getColumn();
    }
  }
  out &lt;&lt; ": ";
}
out &lt;&lt; getMessage();
}
</t>
<t tx="ekr.20230509052845.5450">@llvm
def __float__(self: int) -&gt; float:
    %tmp = sitofp i64 %self to double
    ret double %tmp

</t>
<t tx="ekr.20230509052845.5451">@llvm
def __bool__(self: int) -&gt; bool:
    %0 = icmp ne i64 %self, 0
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.5452">def __pos__(self: int) -&gt; int:
    return self

</t>
<t tx="ekr.20230509052845.5453">def __neg__(self: int) -&gt; int:
    return I.__sub__(0, self)

</t>
<t tx="ekr.20230509052845.5454">@llvm
def __abs__(self: int) -&gt; int:
    %0 = icmp sgt i64 %self, 0
    %1 = sub i64 0, %self
    %2 = select i1 %0, i64 %self, i64 %1
    ret i64 %2

</t>
<t tx="ekr.20230509052845.5455">@llvm
def __lshift__(self: int, other: int) -&gt; int:
    %0 = shl i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.5456">@llvm
def __rshift__(self: int, other: int) -&gt; int:
    %0 = ashr i64 %self, %other
    ret i64 %0

</t>
<t tx="ekr.20230509052845.5457">@llvm
def __add__(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fadd double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.5458">@llvm
def __add__(self: int, b: int) -&gt; int:
    %tmp = add i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5459">@llvm
def __sub__(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fsub double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.546">class ParserErrorInfo : public llvm::ErrorInfo&lt;ParserErrorInfo&gt; {
private:
  std::vector&lt;std::vector&lt;Message&gt;&gt; messages;

public:
  explicit ParserErrorInfo(const std::vector&lt;Message&gt; &amp;m) : messages() {
    for (auto &amp;msg : m) {
      messages.push_back({msg});
    }
  }
  explicit ParserErrorInfo(const exc::ParserException &amp;e) : messages() {
    std::vector&lt;Message&gt; group;
    for (unsigned i = 0; i &lt; e.messages.size(); i++) {
      if (!e.messages[i].empty())
        group.emplace_back(e.messages[i], e.locations[i].file, e.locations[i].line,
                           e.locations[i].col, e.locations[i].len);
    }
    messages.push_back(group);
  }

  auto begin() { return messages.begin(); }
  auto end() { return messages.end(); }
  auto begin() const { return messages.begin(); }
  auto end() const { return messages.end(); }

@others
  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509052845.5460">@llvm
def __sub__(self: int, b: int) -&gt; int:
    %tmp = sub i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5461">@llvm
def __mul__(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fmul double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.5462">@llvm
def __mul__(self: int, b: int) -&gt; int:
    %tmp = mul i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5463">@llvm
def __floordiv__(self: int, other: float) -&gt; float:
    declare double @llvm.floor.f64(double)
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    %2 = call double @llvm.floor.f64(double %1)
    ret double %2

</t>
<t tx="ekr.20230509052845.5464">@llvm
def __floordiv__(self: int, b: int) -&gt; int:
    %tmp = sdiv i64 %self, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5465">@llvm
def __truediv__(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.5466">@llvm
def __truediv__(self: int, other: int) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = sitofp i64 %other to double
    %2 = fdiv double %0, %1
    ret double %2

</t>
<t tx="ekr.20230509052845.5467">@llvm
def __mod__(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = frem double %0, %other
    ret double %1

</t>
<t tx="ekr.20230509052845.5468">@llvm
def __mod__(a: int, b: int) -&gt; int:
    %tmp = srem i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5469">@llvm
def __invert__(a: int) -&gt; int:
    %tmp = xor i64 %a, -1
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.547">  void log(llvm::raw_ostream &amp;out) const override {
    for (auto &amp;group : messages) {
      for (auto &amp;msg : group) {
        msg.log(out);
        out &lt;&lt; "\n";
      }
    }
  }

</t>
<t tx="ekr.20230509052845.5470">@llvm
def __and__(a: int, b: int) -&gt; int:
    %tmp = and i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5471">@llvm
def __or__(a: int, b: int) -&gt; int:
    %tmp = or i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5472">@llvm
def __xor__(a: int, b: int) -&gt; int:
    %tmp = xor i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5473">@llvm
def __shr__(a: int, b: int) -&gt; int:
    %tmp = ashr i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5474">@llvm
def __shl__(a: int, b: int) -&gt; int:
    %tmp = shl i64 %a, %b
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5475">@llvm
def __bitreverse__(a: int) -&gt; int:
    declare i64 @llvm.bitreverse.i64(i64 %a)
    %tmp = call i64 @llvm.bitreverse.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5476">@llvm
def __bswap__(a: int) -&gt; int:
    declare i64 @llvm.bswap.i64(i64 %a)
    %tmp = call i64 @llvm.bswap.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5477">@llvm
def __ctpop__(a: int) -&gt; int:
    declare i64 @llvm.ctpop.i64(i64 %a)
    %tmp = call i64 @llvm.ctpop.i64(i64 %a)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5478">@llvm
def __ctlz__(a: int) -&gt; int:
    declare i64 @llvm.ctlz.i64(i64 %a, i1 %is_zero_undef)
    %tmp = call i64 @llvm.ctlz.i64(i64 %a, i1 false)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.5479">@llvm
def __cttz__(a: int) -&gt; int:
    declare i64 @llvm.cttz.i64(i64 %a, i1 %is_zero_undef)
    %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
    ret i64 %tmp

</t>
<t tx="ekr.20230509052845.548">class RuntimeErrorInfo : public llvm::ErrorInfo&lt;RuntimeErrorInfo&gt; {
private:
  std::string output;
  std::string type;
  Message message;
  std::vector&lt;std::string&gt; backtrace;

public:
  RuntimeErrorInfo(const std::string &amp;output, const std::string &amp;type,
                   const std::string &amp;msg, const std::string &amp;file = "", int line = 0,
                   int col = 0, std::vector&lt;std::string&gt; backtrace = {})
      : output(output), type(type), message(msg, file, line, col),
        backtrace(std::move(backtrace)) {}

  std::string getOutput() const { return output; }
  std::string getType() const { return type; }
  std::string getMessage() const { return message.getMessage(); }
  std::string getFile() const { return message.getFile(); }
  int getLine() const { return message.getLine(); }
  int getColumn() const { return message.getColumn(); }
  std::vector&lt;std::string&gt; getBacktrace() const { return backtrace; }

@others
  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509052845.5480">@llvm
def __eq__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp oeq double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5481">@llvm
def __eq__(a: int, b: int) -&gt; bool:
    %tmp = icmp eq i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.5482">@llvm
def __ne__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp one double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5483">@llvm
def __ne__(a: int, b: int) -&gt; bool:
    %tmp = icmp ne i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.5484">@llvm
def __lt__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp olt double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5485">@llvm
def __lt__(a: int, b: int) -&gt; bool:
    %tmp = icmp slt i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.5486">@llvm
def __gt__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp ogt double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5487">@llvm
def __gt__(a: int, b: int) -&gt; bool:
    %tmp = icmp sgt i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.5488">@llvm
def __le__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp ole double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5489">@llvm
def __le__(a: int, b: int) -&gt; bool:
    %tmp = icmp sle i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.549">  void log(llvm::raw_ostream &amp;out) const override {
    out &lt;&lt; type &lt;&lt; ": ";
    message.log(out);
  }

</t>
<t tx="ekr.20230509052845.5490">@llvm
def __ge__(self: int, b: float) -&gt; bool:
    %0 = sitofp i64 %self to double
    %1 = fcmp oge double %0, %b
    %2 = zext i1 %1 to i8
    ret i8 %2

</t>
<t tx="ekr.20230509052845.5491">@llvm
def __ge__(a: int, b: int) -&gt; bool:
    %tmp = icmp sge i64 %a, %b
    %res = zext i1 %tmp to i8
    ret i8 %res

</t>
<t tx="ekr.20230509052845.5492">def __pow__(self: int, exp: float):
    return float(self) ** exp

</t>
<t tx="ekr.20230509052845.5493">def __pow__(self: int, exp: int):
    if exp &lt; 0:
        return 0
    result = 1
    while True:
        if exp &amp; 1:
            result *= self
        exp &gt;&gt;= 1
        if not exp:
            break
        self *= self
    return result

</t>
<t tx="ekr.20230509052845.5494">@extend
class int:
    @others
</t>
<t tx="ekr.20230509052845.5495">def __int__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return self

</t>
<t tx="ekr.20230509052845.5496">def __float__(self) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__float__(self)

</t>
<t tx="ekr.20230509052845.5497">def __bool__(self) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__bool__(self)

</t>
<t tx="ekr.20230509052845.5498">def __pos__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return self

</t>
<t tx="ekr.20230509052845.5499">def __neg__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__neg__(self)

</t>
<t tx="ekr.20230509052845.55">class Spline(object):
    """Class for representing B-Splines and NURBS of arbitrary degree"""

    @others
</t>
<t tx="ekr.20230509052845.550">class PluginErrorInfo : public llvm::ErrorInfo&lt;PluginErrorInfo&gt; {
private:
  std::string message;

public:
  explicit PluginErrorInfo(const std::string &amp;message) : message(message) {}

  std::string getMessage() const { return message; }

  void log(llvm::raw_ostream &amp;out) const override { out &lt;&lt; message; }

  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509052845.5500">def __lshift__(self, other: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__lshift__(self, other)

</t>
<t tx="ekr.20230509052845.5501">def __rshift__(self, other: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__rshift__(self, other)

</t>
<t tx="ekr.20230509052845.5502">def __add__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__add__(self, other)

</t>
<t tx="ekr.20230509052845.5503">def __add__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__add__(self, b)

</t>
<t tx="ekr.20230509052845.5504">def __sub__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__sub__(self, other)

</t>
<t tx="ekr.20230509052845.5505">def __sub__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__sub__(self, b)

</t>
<t tx="ekr.20230509052845.5506">def __mul__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__mul__(self, other)

</t>
<t tx="ekr.20230509052845.5507">def __mul__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__mul__(self, b)

</t>
<t tx="ekr.20230509052845.5508">def __floordiv__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__floordiv__(self, other)

</t>
<t tx="ekr.20230509052845.5509">def __floordiv__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__floordiv__(self, b)

</t>
<t tx="ekr.20230509052845.551">class IOErrorInfo : public llvm::ErrorInfo&lt;IOErrorInfo&gt; {
private:
  std::string message;

public:
  explicit IOErrorInfo(const std::string &amp;message) : message(message) {}

  std::string getMessage() const { return message; }

  void log(llvm::raw_ostream &amp;out) const override { out &lt;&lt; message; }

  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509052845.5510">def __truediv__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__truediv__(self, other)

</t>
<t tx="ekr.20230509052845.5511">def __truediv__(self, other: int) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__truediv__(self, other)

</t>
<t tx="ekr.20230509052845.5512">def __mod__(self, other: float) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__mod__(self, other)

</t>
<t tx="ekr.20230509052845.5513">def __mod__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__mod__(self, b)

</t>
<t tx="ekr.20230509052845.5514">def __invert__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__invert__(self)

</t>
<t tx="ekr.20230509052845.5515">def __and__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__and__(self, b)

</t>
<t tx="ekr.20230509052845.5516">def __or__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__or__(self, b)

</t>
<t tx="ekr.20230509052845.5517">def __xor__(self, b: int) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__xor__(self, b)

</t>
<t tx="ekr.20230509052845.5518">def __eq__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__eq__(self, b)

</t>
<t tx="ekr.20230509052845.5519">def __eq__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__eq__(self, b)

</t>
<t tx="ekr.20230509052845.552">enum Error {
  CALL_NAME_ORDER,
  CALL_NAME_STAR,
  CALL_ELLIPSIS,
  IMPORT_IDENTIFIER,
  IMPORT_FN,
  FN_LLVM,
  FN_LAST_KWARG,
  FN_MULTIPLE_ARGS,
  FN_DEFAULT_STARARG,
  FN_ARG_TWICE,
  FN_DEFAULT,
  FN_C_DEFAULT,
  FN_C_TYPE,
  FN_SINGLE_DECORATOR,
  CLASS_EXTENSION,
  CLASS_MISSING_TYPE,
  CLASS_ARG_TWICE,
  CLASS_BAD_DECORATOR,
  CLASS_MULTIPLE_DECORATORS,
  CLASS_SINGLE_DECORATOR,
  CLASS_CONFLICT_DECORATOR,
  CLASS_NONSTATIC_DECORATOR,
  CLASS_BAD_DECORATOR_ARG,
  ID_NOT_FOUND,
  ID_CANNOT_CAPTURE,
  ID_INVALID_BIND,
  UNION_TOO_BIG,
  COMPILER_NO_FILE,
  COMPILER_NO_STDLIB,
  ID_NONLOCAL,
  IMPORT_NO_MODULE,
  IMPORT_NO_NAME,
  DEL_NOT_ALLOWED,
  DEL_INVALID,
  ASSIGN_INVALID,
  ASSIGN_LOCAL_REFERENCE,
  ASSIGN_MULTI_STAR,
  INT_RANGE,
  FLOAT_RANGE,
  STR_FSTRING_BALANCE_EXTRA,
  STR_FSTRING_BALANCE_MISSING,
  CALL_NO_TYPE,
  CALL_TUPLE_COMPREHENSION,
  CALL_NAMEDTUPLE,
  CALL_PARTIAL,
  EXPECTED_TOPLEVEL,
  CLASS_ID_NOT_FOUND,
  CLASS_INVALID_BIND,
  CLASS_NO_INHERIT,
  CLASS_TUPLE_INHERIT,
  CLASS_BAD_MRO,
  CLASS_BAD_ATTR,
  MATCH_MULTI_ELLIPSIS,
  FN_OUTSIDE_ERROR,
  FN_GLOBAL_ASSIGNED,
  FN_GLOBAL_NOT_FOUND,
  FN_NO_DECORATORS,
  FN_BAD_LLVM,
  FN_REALIZE_BUILTIN,
  EXPECTED_LOOP,
  LOOP_DECORATOR,
  BAD_STATIC_TYPE,
  EXPECTED_TYPE,
  UNEXPECTED_TYPE,
  DOT_NO_ATTR,
  DOT_NO_ATTR_ARGS,
  FN_NO_ATTR_ARGS,
  EXPECTED_STATIC,
  EXPECTED_STATIC_SPECIFIED,
  ASSIGN_UNEXPECTED_STATIC,
  ASSIGN_UNEXPECTED_FROZEN,
  CALL_BAD_UNPACK,
  CALL_BAD_ITER,
  CALL_BAD_KWUNPACK,
  CALL_REPEATED_NAME,
  CALL_RECURSIVE_DEFAULT,
  CALL_SUPERF,
  CALL_SUPER_PARENT,
  CALL_PTR_VAR,
  EXPECTED_TUPLE,
  CALL_REALIZED_FN,
  CALL_ARGS_MANY,
  CALL_ARGS_INVALID,
  CALL_ARGS_MISSING,
  GENERICS_MISMATCH,
  EXPECTED_GENERATOR,
  STATIC_RANGE_BOUNDS,
  TUPLE_RANGE_BOUNDS,
  STATIC_DIV_ZERO,
  SLICE_STEP_ZERO,
  OP_NO_MAGIC,
  INST_CALLABLE_STATIC,
  TYPE_CANNOT_REALIZE_ATTR,
  TYPE_UNIFY,
  TYPE_FAILED,
  MAX_REALIZATION,
  CUSTOM,
  __END__
};

template &lt;class... TA&gt; std::string Emsg(Error e, const TA &amp;...args) {
  switch (e) {
  /// Validations
  case Error::CALL_NAME_ORDER:
    return fmt::format("positional argument follows keyword argument");
  case Error::CALL_NAME_STAR:
    return fmt::format("cannot use starred expression here");
  case Error::CALL_ELLIPSIS:
    return fmt::format("multiple ellipsis expressions");
  case Error::IMPORT_IDENTIFIER:
    return fmt::format("expected identifier");
  case Error::IMPORT_FN:
    return fmt::format(
        "function signatures only allowed when importing C or Python functions");
  case Error::FN_LLVM:
    return fmt::format("return types required for LLVM and C functions");
  case Error::FN_LAST_KWARG:
    return fmt::format("kwargs must be the last argument");
  case Error::FN_MULTIPLE_ARGS:
    return fmt::format("multiple star arguments provided");
  case Error::FN_DEFAULT_STARARG:
    return fmt::format("star arguments cannot have default values");
  case Error::FN_ARG_TWICE:
    return fmt::format("duplicate argument '{}' in function definition", args...);
  case Error::FN_DEFAULT:
    return fmt::format("non-default argument '{}' follows default argument", args...);
  case Error::FN_C_DEFAULT:
    return fmt::format(
        "argument '{}' within C function definition cannot have default value",
        args...);
  case Error::FN_C_TYPE:
    return fmt::format(
        "argument '{}' within C function definition requires type annotation", args...);
  case Error::FN_SINGLE_DECORATOR:
    return fmt::format("cannot combine '@{}' with other attributes or decorators",
                       args...);
  case Error::CLASS_EXTENSION:
    return fmt::format("class extensions cannot define data attributes and generics or "
                       "inherit other classes");
  case Error::CLASS_MISSING_TYPE:
    return fmt::format("type required for data attribute '{}'", args...);
  case Error::CLASS_ARG_TWICE:
    return fmt::format("duplicate data attribute '{}' in class definition", args...);
  case Error::CLASS_BAD_DECORATOR:
    return fmt::format("unsupported class decorator");
  case Error::CLASS_MULTIPLE_DECORATORS:
    return fmt::format("duplicate decorator '@{}' in class definition", args...);
  case Error::CLASS_SINGLE_DECORATOR:
    return fmt::format("cannot combine '@{}' with other attributes or decorators",
                       args...);
  case Error::CLASS_CONFLICT_DECORATOR:
    return fmt::format("cannot combine '@{}' with '@{}'", args...);
  case Error::CLASS_NONSTATIC_DECORATOR:
    return fmt::format("class decorator arguments must be compile-time static values");
  case Error::CLASS_BAD_DECORATOR_ARG:
    return fmt::format("class decorator got unexpected argument");
  /// Simplification
  case Error::ID_NOT_FOUND:
    return fmt::format("name '{}' is not defined", args...);
  case Error::ID_CANNOT_CAPTURE:
    return fmt::format("name '{}' cannot be captured", args...);
  case Error::ID_NONLOCAL:
    return fmt::format("no binding for nonlocal '{}' found", args...);
  case Error::ID_INVALID_BIND:
    return fmt::format("cannot bind '{}' to global or nonlocal name", args...);
  case Error::IMPORT_NO_MODULE:
    return fmt::format("no module named '{}'", args...);
  case Error::IMPORT_NO_NAME:
    return fmt::format("cannot import name '{}' from '{}'", args...);
  case Error::DEL_NOT_ALLOWED:
    return fmt::format("name '{}' cannot be deleted", args...);
  case Error::DEL_INVALID:
    return fmt::format("cannot delete given expression", args...);
  case Error::ASSIGN_INVALID:
    return fmt::format("cannot assign to given expression");
  case Error::ASSIGN_LOCAL_REFERENCE:
    return fmt::format("local variable '{}' referenced before assignment", args...);
  case Error::ASSIGN_MULTI_STAR:
    return fmt::format("multiple starred expressions in assignment");
  case Error::INT_RANGE:
    return fmt::format("integer '{}' cannot fit into 64-bit integer", args...);
  case Error::FLOAT_RANGE:
    return fmt::format("float '{}' cannot fit into 64-bit float", args...);
  case Error::STR_FSTRING_BALANCE_EXTRA:
    return fmt::format("expecting '}}' in f-string");
  case Error::STR_FSTRING_BALANCE_MISSING:
    return fmt::format("single '}}' is not allowed in f-string");
  case Error::CALL_NO_TYPE:
    return fmt::format("cannot use type() in type signatures", args...);
  case Error::CALL_TUPLE_COMPREHENSION:
    return fmt::format(
        "tuple constructor does not accept nested or conditioned comprehensions",
        args...);
  case Error::CALL_NAMEDTUPLE:
    return fmt::format("namedtuple() takes 2 static arguments", args...);
  case Error::CALL_PARTIAL:
    return fmt::format("partial() takes 1 or more arguments", args...);
  case Error::EXPECTED_TOPLEVEL:
    return fmt::format("{} must be a top-level statement", args...);
  case Error::CLASS_ID_NOT_FOUND:
    // Note that type aliases are not valid class names
    return fmt::format("class name '{}' is not defined", args...);
  case Error::CLASS_INVALID_BIND:
    return fmt::format("cannot bind '{}' to class or function", args...);
  case Error::CLASS_NO_INHERIT:
    return fmt::format("{} classes cannot inherit other classes", args...);
  case Error::CLASS_TUPLE_INHERIT:
    return fmt::format("reference classes cannot inherit tuple classes");
  case Error::CLASS_BAD_MRO:
    return fmt::format("inconsistent class hierarchy");
  case Error::CLASS_BAD_ATTR:
    return fmt::format("unexpected expression in class definition");
  case Error::MATCH_MULTI_ELLIPSIS:
    return fmt::format("multiple ellipses in a pattern");
  case Error::FN_OUTSIDE_ERROR:
    return fmt::format("'{}' outside function", args...);
  case Error::FN_GLOBAL_ASSIGNED:
    return fmt::format("name '{}' is assigned to before global declaration", args...);
  case Error::FN_GLOBAL_NOT_FOUND:
    return fmt::format("no binding for {} '{}' found", args...);
  case Error::FN_NO_DECORATORS:
    return fmt::format("class methods cannot be decorated", args...);
  case Error::FN_BAD_LLVM:
    return fmt::format("invalid LLVM code");
  case Error::FN_REALIZE_BUILTIN:
    return fmt::format("builtin, exported and external functions cannot be generic");
  case Error::EXPECTED_LOOP:
    return fmt::format("'{}' outside loop", args...);
  case Error::LOOP_DECORATOR:
    return fmt::format("invalid loop decorator");
  case Error::BAD_STATIC_TYPE:
    return fmt::format(
        "expected 'int' or 'str' (only integers and strings can be static)");
  case Error::EXPECTED_TYPE:
    return fmt::format("expected {} expression", args...);
  case Error::UNEXPECTED_TYPE:
    return fmt::format("unexpected {} expression", args...);

  /// Typechecking
  case Error::UNION_TOO_BIG:
    return fmt::format(
        "union exceeded its maximum capacity (contains more than {} types)");
  case Error::DOT_NO_ATTR:
    return fmt::format("'{}' object has no attribute '{}'", args...);
  case Error::DOT_NO_ATTR_ARGS:
    return fmt::format("'{}' object has no method '{}' with arguments {}", args...);
  case Error::FN_NO_ATTR_ARGS:
    return fmt::format("no function '{}' with arguments {}", args...);
  case Error::EXPECTED_STATIC:
    return fmt::format("expected static expression");
  case Error::EXPECTED_STATIC_SPECIFIED:
    return fmt::format("expected static {} expression", args...);
  case Error::ASSIGN_UNEXPECTED_STATIC:
    return fmt::format("cannot modify static expressions");
  case Error::ASSIGN_UNEXPECTED_FROZEN:
    return fmt::format("cannot modify tuple attributes");
  case Error::CALL_BAD_UNPACK:
    return fmt::format("argument after * must be a tuple, not '{}'", args...);
  case Error::CALL_BAD_ITER:
    return fmt::format("iterable must be a tuple, not '{}'", args...);
  case Error::CALL_BAD_KWUNPACK:
    return fmt::format("argument after ** must be a named tuple, not '{}'", args...);
  case Error::CALL_REPEATED_NAME:
    return fmt::format("keyword argument repeated: {}", args...);
  case Error::CALL_RECURSIVE_DEFAULT:
    return fmt::format("argument '{}' has recursive default value", args...);
  case Error::CALL_SUPERF:
    return fmt::format("no superf methods found");
  case Error::CALL_SUPER_PARENT:
    return fmt::format("no super methods found");
  case Error::CALL_PTR_VAR:
    return fmt::format("__ptr__() only takes identifiers as arguments");
  case Error::EXPECTED_TUPLE:
    return fmt::format("expected tuple type");
  case Error::CALL_REALIZED_FN:
    return fmt::format("__realized__() only takes functions as a first argument");
  case Error::CALL_ARGS_MANY:
    return fmt::format("{}() takes {} arguments ({} given)", args...);
  case Error::CALL_ARGS_INVALID:
    return fmt::format("'{}' is an invalid keyword argument for {}()", args...);
  case Error::CALL_ARGS_MISSING:
    return fmt::format("{}() missing 1 required positional argument: '{}'", args...);
  case Error::GENERICS_MISMATCH:
    return fmt::format("{} takes {} generics ({} given)", args...);
  case Error::EXPECTED_GENERATOR:
    return fmt::format("expected iterable expression");
  case Error::STATIC_RANGE_BOUNDS:
    return fmt::format("staticrange too large (expected 0..{}, got instead {})",
                       args...);
  case Error::TUPLE_RANGE_BOUNDS:
    return fmt::format("tuple index out of range (expected 0..{}, got instead {})",
                       args...);
  case Error::STATIC_DIV_ZERO:
    return fmt::format("static division by zero");
  case Error::SLICE_STEP_ZERO:
    return fmt::format("slice step cannot be zero");
  case Error::OP_NO_MAGIC:
    return fmt::format("unsupported operand type(s) for {}: '{}' and '{}'", args...);
  case Error::INST_CALLABLE_STATIC:
    return fmt::format("Callable cannot take static types");

  case Error::TYPE_CANNOT_REALIZE_ATTR:
    return fmt::format("type of attribute '{}' of object '{}' cannot be inferred",
                       args...);
  case Error::TYPE_UNIFY:
    return fmt::format("'{}' does not match expected type '{}'", args...);
  case Error::TYPE_FAILED:
    return fmt::format(
        "cannot infer the complete type of an expression (inferred only '{}')",
        args...);

  case Error::COMPILER_NO_FILE:
    return fmt::format("cannot open file '{}' for parsing", args...);
  case Error::COMPILER_NO_STDLIB:
    return fmt::format("cannot locate standard library");
  case Error::MAX_REALIZATION:
    return fmt::format(
        "maximum realization depth reached during the realization of '{}'", args...);
  case Error::CUSTOM:
    return fmt::format("{}", args...);

  default:
    assert(false);
  }
}

/// Raise a parsing error.
void raise_error(const char *format);
/// Raise a parsing error at a source location p.
void raise_error(int e, const codon::SrcInfo &amp;info, const char *format);
void raise_error(int e, const codon::SrcInfo &amp;info, const std::string &amp;format);

</t>
<t tx="ekr.20230509052845.5520">def __ne__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__ne__(self, b)

</t>
<t tx="ekr.20230509052845.5521">def __ne__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__ne__(self, b)

</t>
<t tx="ekr.20230509052845.5522">def __lt__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__lt__(self, b)

</t>
<t tx="ekr.20230509052845.5523">def __lt__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__lt__(self, b)

</t>
<t tx="ekr.20230509052845.5524">def __gt__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__gt__(self, b)

</t>
<t tx="ekr.20230509052845.5525">def __gt__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__gt__(self, b)

</t>
<t tx="ekr.20230509052845.5526">def __le__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__le__(self, b)

</t>
<t tx="ekr.20230509052845.5527">def __le__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__le__(self, b)

</t>
<t tx="ekr.20230509052845.5528">def __ge__(self, b: float) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__ge__(self, b)

</t>
<t tx="ekr.20230509052845.5529">def __ge__(self, b: int) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__ge__(self, b)

</t>
<t tx="ekr.20230509052845.553">template &lt;class... TA&gt;
void E(Error e, const codon::SrcInfo &amp;o = codon::SrcInfo(), const TA &amp;...args) {
  auto msg = Emsg(e, args...);
  raise_error((int)e, o, msg);
}

</t>
<t tx="ekr.20230509052845.5530">def __pow__(self, exp: float):
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__pow__(self, exp)

</t>
<t tx="ekr.20230509052845.5531">def __pow__(self, exp: int):
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return I.__pow__(self, exp)


</t>
<t tx="ekr.20230509052845.5532">class F:
    @others
</t>
<t tx="ekr.20230509052845.5533">@llvm
def __int__(self: float) -&gt; int:
    %0 = fptosi double %self to i64
    ret i64 %0

</t>
<t tx="ekr.20230509052845.5534">def __float__(self: float):
    return self

</t>
<t tx="ekr.20230509052845.5535">@llvm
def __bool__(self: float) -&gt; bool:
    %0 = fcmp one double %self, 0.000000e+00
    %1 = zext i1 %0 to i8
    ret i8 %1

</t>
<t tx="ekr.20230509052845.5536">@extend
class float:
    @others
</t>
<t tx="ekr.20230509052845.5537">def __int__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return F.__int__(self)

</t>
<t tx="ekr.20230509052845.5538">def __float__(self) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return self

</t>
<t tx="ekr.20230509052845.5539">def __bool__(self) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return F.__bool__(self)

</t>
<t tx="ekr.20230509052845.554">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvisitor.h"
#include "codon/cir/transform/manager.h"
#include "codon/cir/var.h"
#include "codon/compiler/compiler.h"
#include "codon/compiler/engine.h"
#include "codon/compiler/error.h"
#include "codon/parser/cache.h"
#include "codon/runtime/lib.h"

#include "codon/compiler/jit_extern.h"

namespace codon {
namespace jit {

@others
} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5540">@extend
class bool:
    @others
</t>
<t tx="ekr.20230509052845.5541">def __int__(self) -&gt; int:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return 1 if self else 0

</t>
<t tx="ekr.20230509052845.5542">def __float__(self) -&gt; float:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return 1. if self else 0.

</t>
<t tx="ekr.20230509052845.5543">def __bool__(self) -&gt; bool:
    global OP_COUNT
    OP_COUNT = inc(OP_COUNT)
    return self

</t>
<t tx="ekr.20230509052845.5544">def eq(a: int, b: int) -&gt; bool:
    return I.__eq__(a, b)

</t>
<t tx="ekr.20230509052845.5545">@noinline
def foo(x):
  return x

</t>
<t tx="ekr.20230509052845.5546">@test
def test_int_simple_fold():
    op_count = OP_COUNT
    x = 1
    y = x + 2
    z = x + 3
    assert eq(foo(x + 1), 2)
    assert eq(foo(y * 2), 6)
    assert eq(foo(z // 3), 1)
    assert eq(foo(x &gt;&gt; 2), 0)
    assert eq(foo(x &lt;&lt; y), 8)
    assert eq(foo(x | y), 3)
    assert eq(foo(z &amp; z), 4)
    assert not foo(x &gt; y)
    assert foo(y &lt; z)
    assert not foo(x &gt;= z)
    assert foo(x &lt;= 2)
    assert foo(x == 1)
    assert foo(x != 2)
    assert eq(foo(y ** 3), 27)
    assert eq(foo(y ** 0), 1)
    assert eq(foo(y ** -1), 0)
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5547">test_int_simple_fold()

</t>
<t tx="ekr.20230509052845.5548">@test
def test_ternary_fold():
    op_count = OP_COUNT
    x = 1
    y = x * 2
    assert (x + 1 if x != 0 else -1) &gt; 0
    assert (x + 1 if x == 0 else -1) &lt; 0
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5549">test_ternary_fold()

</t>
<t tx="ekr.20230509052845.555">class JIT {
public:
  struct PythonData {
    ir::types::Type *cobj;
    std::unordered_map&lt;std::string, ir::Func *&gt; cache;

    PythonData();
    ir::types::Type *getCObjType(ir::Module *M);
  };

private:
  std::unique_ptr&lt;Compiler&gt; compiler;
  std::unique_ptr&lt;Engine&gt; engine;
  std::unique_ptr&lt;PythonData&gt; pydata;
  std::string mode;

public:
  explicit JIT(const std::string &amp;argv0, const std::string &amp;mode = "");

  Compiler *getCompiler() const { return compiler.get(); }
  Engine *getEngine() const { return engine.get(); }

  // General
  llvm::Error init();
  llvm::Error compile(const ir::Func *input);
  llvm::Expected&lt;ir::Func *&gt; compile(const std::string &amp;code,
                                     const std::string &amp;file = "", int line = 0);
  llvm::Expected&lt;void *&gt; address(const ir::Func *input);
  llvm::Expected&lt;std::string&gt; run(const ir::Func *input);
  llvm::Expected&lt;std::string&gt; execute(const std::string &amp;code,
                                      const std::string &amp;file = "", int line = 0,
                                      bool debug = false);

  // Python
  llvm::Expected&lt;void *&gt; runPythonWrapper(const ir::Func *wrapper, void *arg);
  llvm::Expected&lt;ir::Func *&gt; getWrapperFunc(const std::string &amp;name,
                                            const std::vector&lt;std::string&gt; &amp;types);
  JITResult executePython(const std::string &amp;name,
                          const std::vector&lt;std::string&gt; &amp;types,
                          const std::string &amp;pyModule,
                          const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
                          bool debug);
  JITResult executeSafe(const std::string &amp;code, const std::string &amp;file, int line,
                        bool debug);

  // Errors
  llvm::Error handleJITError(const runtime::JITError &amp;e);
};

</t>
<t tx="ekr.20230509052845.5550">@test
def test_try_catch_fold():
    op_count = OP_COUNT
    x = 0
    y = x + 1
    try:
        x = 1
    finally:
        x = 4
    assert x == 4
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5551">test_try_catch_fold()

</t>
<t tx="ekr.20230509052845.5552">@test
def test_while_fold():
    op_count = OP_COUNT
    x = 0
    y = 1
    while (x != 0):
        y = 2
    assert y + 1 == 2
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5553">test_while_fold()

</t>
<t tx="ekr.20230509052845.5554">@test
def test_imperative_for_fold():
    op_count = OP_COUNT
    foo = 2
    y = 1
    for i in range(foo, 2):
        y = foo - 1
    assert y == 1
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5555">test_imperative_for_fold()

</t>
<t tx="ekr.20230509052845.5556">@test
def test_long_fold():
    op_count = OP_COUNT
    x = 3
    assert eq(foo(x + x + x + x + x + x + x + x + x + x + x + x), 36)
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5557">test_long_fold()

</t>
<t tx="ekr.20230509052845.5558">@test
def test_conversions():
    op_count = OP_COUNT
    n = 42
    b = True
    x = 3.14

    assert eq(foo(n.__int__()), n)
    assert foo(n.__float__()) == 42.0
    assert foo(n.__bool__())

    assert eq(foo(b.__int__()), 1)
    assert foo(b.__float__()) == 1.0
    assert foo(b.__bool__())

    assert eq(foo(x.__int__()), 3)
    assert foo(x.__float__()) == x
    assert foo(x.__bool__())
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5559">test_conversions()

</t>
<t tx="ekr.20230509052845.556">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {
namespace jit {

class JIT;

struct JITResult {
  void *result;
  std::string message;

  operator bool() const { return message.empty(); }
  static JITResult success(void *result) { return {result, ""}; }
  static JITResult error(const std::string &amp;message) { return {nullptr, message}; }
};

JIT *jitInit(const std::string &amp;name);

JITResult jitExecutePython(JIT *jit, const std::string &amp;name,
                           const std::vector&lt;std::string&gt; &amp;types,
                           const std::string &amp;pyModule,
                           const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
                           bool debug);

JITResult jitExecuteSafe(JIT *jit, const std::string &amp;code, const std::string &amp;file,
                         int line, bool debug);

std::string getJITLibrary();

} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5560">@test
def test_no_ops():
    def v(): return 42
    op_count = OP_COUNT
    n = v()
    assert eq(+n, n)
    assert eq(-(-n), n)
    assert eq(~(~n), n)
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5561">test_no_ops()

</t>
<t tx="ekr.20230509052845.5562">@test
def test_algebraic_simplification():
    @others
    op_count = OP_COUNT
    n = v()
    assert eq(0*n, 0)
    assert eq(n*0, 0)
    assert eq(n*1, n)
    assert eq(1*n, n)
    assert eq(n+0, n)
    assert eq(0+n, n)
    assert eq(n-0, n)
    assert eq(0//n, 0)
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5563">def v(): return 42
</t>
<t tx="ekr.20230509052845.5564">test_algebraic_simplification()

n = 42
</t>
<t tx="ekr.20230509052845.5565">@test
def test_global_fold():
    op_count = OP_COUNT
    m = 1
    assert eq(n + m, 43)
    assert eq(op_count, OP_COUNT)
</t>
<t tx="ekr.20230509052845.5566">test_global_fold()

# make sure globals fold properly with demotion
op_count1 = OP_COUNT
a = foo(42)
a = 42
b = a + 10
c = b
op_count2 = OP_COUNT

</t>
<t tx="ekr.20230509052845.5567">@test
def test_global_fold_non_const():
    op_count = OP_COUNT
    assert c == 52
    assert op_count1 == op_count2
</t>
<t tx="ekr.20230509052845.5568">test_global_fold_non_const()

some_global = 42
</t>
<t tx="ekr.20230509052845.5569">@test
def test_side_effect_analysis():
    @others
    foo()
    x = foo()
    bar()
    y = bar()
    assert baz() == 43
    baz()
    assert some_global == 44
    assert fab() == 45
    fab()
    assert some_global == 46
</t>
<t tx="ekr.20230509052845.557">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;mutex&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5570">@pure
@test
def foo():
    assert False
    return some_global

</t>
<t tx="ekr.20230509052845.5571">def bar():
    a = 1
    b = 2
    c = 3
    return foo()

</t>
<t tx="ekr.20230509052845.5572">def baz():
    global some_global
    some_global += 1
    return some_global

</t>
<t tx="ekr.20230509052845.5573">def fab():
    return baz()

</t>
<t tx="ekr.20230509052845.5574">@path C:/Repos/codon/test/transform/
@others
test_for_lowering()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5575">@extend
class range:
    def __iter__(self):
        yield 999

</t>
<t tx="ekr.20230509052845.5576">@test
def test_for_lowering():
    from random import randint
    x = 10
    v = []
    for i in range(x):
        v.append(i)
    assert v == [0,1,2,3,4,5,6,7,8,9]

    v = []
    for i in range(x - 11, x//10):
        v.append(i)
    assert v == [-1, 0]

    v = []
    for i in range(x, -x):
        v.append(i)
    assert v == []

    v = []
    for i in range(x//3, -x//3, -2):
        v.append(i)
    assert v == [3, 1, -1]

    v = []
    for i in range(-1, 7, 3):
        v.append(i)
    assert v == [-1, 2, 5]

    v = []
    for i in range(0, 1, randint(1,1)):  # no lowering for non-const step
        v.append(i)
    assert v == [999]

    v = []
    try:
        for i in range(0, 1, 0):  # no lowering for zero step
            v.append(i)
        v.append(-1)
    except:
        v.append(-2)
    assert v == [-2]

    v = []
    for i in range(5):
        if i == 1:
            continue
        if i == 3:
            break
        v.append(i)
    assert v == [0, 2]

</t>
<t tx="ekr.20230509052845.5577">@path C:/Repos/codon/test/transform/
v = 1
v = 2

@others
inline_test_nested_while_finally()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5578">def inline_me_aggressive_simple():
  return 1

</t>
<t tx="ekr.20230509052845.5579">def inline_me_aggressive_complex():
  while True:
    if v == 1:
      return 1
    return 2

</t>
<t tx="ekr.20230509052845.558">/// Simple extension of LLVM's SectionMemoryManager which catches data section
/// allocations and registers them with the GC. This allows the GC to know not
/// to collect globals even in JIT mode.
class BoehmGCMemoryManager : public llvm::SectionMemoryManager {
private:
  /// Vector of (start, end) address pairs registered with GC.
  std::vector&lt;std::pair&lt;void *, void *&gt;&gt; roots;
  uint8_t *allocateDataSection(uintptr_t size, unsigned alignment, unsigned sectionID,
                               llvm::StringRef sectionName, bool isReadOnly) override;

public:
  BoehmGCMemoryManager();
  ~BoehmGCMemoryManager() override;
};

</t>
<t tx="ekr.20230509052845.5580">def inline_me_aggressive_args(x):
  return x + 1

</t>
<t tx="ekr.20230509052845.5581">def inline_me_simple():
  return 1

</t>
<t tx="ekr.20230509052845.5582">def inline_me_complex():
  while True:
    if v == 1:
      return 1
    return 2

</t>
<t tx="ekr.20230509052845.5583">def inline_me_args(x):
  return x + 1

</t>
<t tx="ekr.20230509052845.5584">@test
def inlining_test():
  assert inline_me_simple() == -1
  assert inline_me_complex() == 2
  assert inline_me_args(2) == -3
  assert inline_me_aggressive_simple() == -1
  assert inline_me_aggressive_complex() == -2
  assert inline_me_aggressive_args(2) == -3

</t>
<t tx="ekr.20230509052845.5585">inlining_test()

</t>
<t tx="ekr.20230509052845.5586">def inline_me_aggressive_nested_while_finally(n):
    while n != 0:
        try:
            while n != 0:
                if n == 42:
                    n -= 1
                    continue
                try:
                    if n &gt; 0:
                        continue
                    else:
                        break
                finally:
                    return -1
            return -2
        finally:
            return n + 1

</t>
<t tx="ekr.20230509052845.5587">def inline_test_nested_while_finally():
    a = 42
    checkpoint1 = False
    checkpoint2 = False
    checkpoint3 = False
    try:
        while a != 4:
            try:
                a = inline_me_aggressive_nested_while_finally(a)
                checkpoint1 = True
                assert a == -42
            finally:
                a = 4
            checkpoint2 = True
            assert a == 4
    finally:
        checkpoint3 = True
        assert a == 4
        a = 5
    assert a == 5
    assert checkpoint1
    assert checkpoint2
    assert checkpoint3

</t>
<t tx="ekr.20230509052845.5588">@path C:/Repos/codon/test/transform/
@others
test_print()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5589">class DummyFile:
    write_count: int = 0
    write_gen_count: int = 0

    def write(self, s: str):
        self.write_count += 1
    def __file_write_gen__(self, g):
        self.write_gen_count += 1

</t>
<t tx="ekr.20230509052845.559">/// Basically a copy of LLVM's jitlink::InProcessMemoryManager that registers
/// relevant allocated sections with the GC. TODO: Avoid copying this entire
/// class if/when there's an API to perform the registration externally.
class BoehmGCJITLinkMemoryManager : public llvm::jitlink::JITLinkMemoryManager {
public:
  class IPInFlightAlloc;

  /// Attempts to auto-detect the host page size.
  static llvm::Expected&lt;std::unique_ptr&lt;BoehmGCJITLinkMemoryManager&gt;&gt; Create();

  /// Create an instance using the given page size.
  BoehmGCJITLinkMemoryManager(uint64_t PageSize) : PageSize(PageSize) {}

  void allocate(const llvm::jitlink::JITLinkDylib *JD, llvm::jitlink::LinkGraph &amp;G,
                OnAllocatedFunction OnAllocated) override;

  // Use overloads from base class.
  using llvm::jitlink::JITLinkMemoryManager::allocate;

@others
  FinalizedAlloc createFinalizedAlloc(
      llvm::sys::MemoryBlock StandardSegments,
      std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt; DeallocActions);

  uint64_t PageSize;
  std::mutex FinalizedAllocsMutex;
  llvm::RecyclingAllocator&lt;llvm::BumpPtrAllocator, FinalizedAllocInfo&gt;
      FinalizedAllocInfos;
};

</t>
<t tx="ekr.20230509052845.5590">@test
def test_file_io():
    f = DummyFile()
    f.write('')                                     # opt not applied
    f.write('hello world')                          # opt not applied
    f.write(str.cat("hello ", "world"))             # opt applied
    a, b, c = 3.14, 'xyz', 42
    f.write(f'hello {a} world {b=} abc {a+c} zzz')  # opt applied
    f.write(f'hello world')                         # opt applied
    assert f.write_count == 2
    assert f.write_gen_count == 3
</t>
<t tx="ekr.20230509052845.5591">test_file_io()

</t>
<t tx="ekr.20230509052845.5592">@test
def test_print():
    from sys import stdout
    print('hello world')               # EXPECT: hello world
    print(str.cat("hello ", "world"))  # EXPECT: hello world
    a, b, c = 3.14, 'xyz', 42
    print(f'hello {a} world {b=} abc {a+c} zzz', file=stdout, sep='x')  # EXPECT: hello 3.14 world b=xyz abc 45.14 zzz
    print(f'hello', f'world', sep='x')  # EXPECT: helloxworld
</t>
<t tx="ekr.20230509052845.5593">@path C:/Repos/codon/test/transform/
import gpu

@others
test_hello_world()
test_raw()
test_conversions()
test_user_classes()
test_intrinsics()
test_matmul()
test_mandelbrot()
test_kitchen_sink()
test_auto_par()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5594">@test
def test_hello_world():
    @others
    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]
    kernel(a, b, c, grid=1, block=16)

    assert c == [3*i for i in range(16)]

</t>
<t tx="ekr.20230509052845.5595">@gpu.kernel
def kernel(a, b, c):
    i = gpu.thread.x
    c[i] = a[i] + b[i]

</t>
<t tx="ekr.20230509052845.5596">@test
def test_raw():
    @others
    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]
    kernel(gpu.raw(a), gpu.raw(b), gpu.raw(c), grid=1, block=16)

    assert c == [3*i for i in range(16)]

</t>
<t tx="ekr.20230509052845.5597">@gpu.kernel
def kernel(a, b, c):
    i = gpu.thread.x
    c[i] = a[i] + b[i]

</t>
<t tx="ekr.20230509052845.5598">@test
def test_conversions():
    @others
    assert check(None)
    assert check(42)
    assert check(3.14)
    assert check(f32(2.718))
    assert check(byte(99))
    assert check(Int[128](123123))
    assert check(UInt[128](321321))
    assert check(Optional[int]())
    assert check(Optional(111))
    assert check((1, 2, 3))
    assert check(([1], [2], [3]))
    # assert check(())  # TODO: PTX can't handle this; why?
    assert check(DynamicTuple((1, 2, 3)))
    assert check(DynamicTuple(([1], [2], [3])))
    assert check(DynamicTuple[int]())
    assert check(DynamicTuple[List[List[List[str]]]]())
    assert check('hello world')
    assert check([1, 2, 3])
    assert check([[1], [2], [3]])
    assert check({1: [1.1], 2: [2.2]})
    assert check({'a', 'b', 'c'})
    assert check(Optional([1, 2, 3]))

</t>
<t tx="ekr.20230509052845.5599">@gpu.kernel
def kernel(x, v):
    v[0] = x

</t>
<t tx="ekr.20230509052845.56">def __init__(self, points, degree, knots):
    """Creates a Spline.
    points is a list of GVector, degree is the degree of the Spline.
    """
    if len(points) &gt; len(knots) - degree + 1:
        raise ValueError("too many control points")
    elif len(points) &lt; len(knots) - degree + 1:
        raise ValueError("not enough control points")
    last = knots[0]
    for cur in knots[1:]:
        if cur &lt; last:
            raise ValueError("knots not strictly increasing")
        last = cur
    self.knots = knots
    self.points = points
    self.degree = degree

</t>
<t tx="ekr.20230509052845.560">  void deallocate(std::vector&lt;FinalizedAlloc&gt; Alloc,
                  OnDeallocatedFunction OnDeallocated) override;

  // Use overloads from base class.
  using llvm::jitlink::JITLinkMemoryManager::deallocate;

private:
  // FIXME: Use an in-place array instead of a vector for DeallocActions.
  //        There shouldn't need to be a heap alloc for this.
  struct FinalizedAllocInfo {
    llvm::sys::MemoryBlock StandardSegments;
    std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt; DeallocActions;
  };

</t>
<t tx="ekr.20230509052845.5600">def check(x):
    T = type(x)
    v = [T()]
    kernel(x, v, grid=1, block=1)
    return v == [x]

</t>
<t tx="ekr.20230509052845.5601">@test
def test_user_classes():
    @others
    a = [A(42, [-1])]
    b = [B(100, [-2])]
    c = [(1000, [[-1]])]
    kernel2(a, b, c, grid=1, block=1)

    assert a == [A(1142, [1001])]
    assert b == [B(100, [1002])]
    assert c == [(1000, [[9999]])]

</t>
<t tx="ekr.20230509052845.5602">@dataclass(gpu=True, eq=True)
class A:
   x: int
   y: List[int]

</t>
<t tx="ekr.20230509052845.5603">@tuple
class B:
    x: int
    y: List[int]

</t>
<t tx="ekr.20230509052845.5604">@gpu.kernel
def kernel(a, b, c):
    a.x += b.x + c[0]
    c[1][0][0] = 9999
    a.y[0] = c[0] + 1
    b.y[0] = c[0] + 2

</t>
<t tx="ekr.20230509052845.5605">a = A(42, [-1])
b = B(100, [-2])
c = (1000, [[-1]])
kernel(a, b, c, grid=1, block=1)

assert a == A(1142, [1001])
assert b == B(100, [1002])
assert c == (1000, [[9999]])

</t>
<t tx="ekr.20230509052845.5606">@gpu.kernel
def kernel2(a, b, c):
    a[0].x += b[0].x + c[0][0]
    c[0][1][0][0] = 9999
    a[0].y[0] = c[0][0] + 1
    b[0].y[0] = c[0][0] + 2

</t>
<t tx="ekr.20230509052845.5607">@test
def test_intrinsics():
    @others
    grid = gpu.Dim3(3, 4, 5)
    block = gpu.Dim3(6, 7, 8)
    N = grid.x * grid.y * grid.z * block.x * block.y * block.z
    v = [0 for _ in range(N)]
    kernel(v, grid=grid, block=block)
    assert v == list(range(N))

</t>
<t tx="ekr.20230509052845.5608">@gpu.kernel
def kernel(v):
    block_id = (gpu.block.x + gpu.block.y*gpu.grid.dim.x +
                gpu.block.z*gpu.grid.dim.x*gpu.grid.dim.y)
    thread_id = (block_id*gpu.block.dim.x*gpu.block.dim.y*gpu.block.dim.z +
                 gpu.thread.z*gpu.block.dim.x*gpu.block.dim.y +
                 gpu.thread.y*gpu.block.dim.x +
                 gpu.thread.x)
    v[thread_id] = thread_id
    gpu.syncthreads()

</t>
<t tx="ekr.20230509052845.5609">@test
def test_matmul():
    A = [[12, 7, 3],
         [4, 5, 6],
         [7, 8, 9]]

    B = [[5, 8, 1, 2],
         [6, 7, 3, 0],
         [4, 5, 9, 1]]

    @others
    result = mmz(A, B)
    kernel(A, B, result, grid=1, block=(len(result), len(result[0])))
    assert result == expected

</t>
<t tx="ekr.20230509052845.561"></t>
<t tx="ekr.20230509052845.5610">def mmz(A, B):
    return [[0]*len(B[0]) for _ in range(len(A))]

</t>
<t tx="ekr.20230509052845.5611">def matmul(A, B):
    result = mmz(A, B)
    for i in range(len(A)):
        for j in range(len(B[0])):
            for k in range(len(B)):
                result[i][j] += A[i][k] * B[k][j]
    return result

</t>
<t tx="ekr.20230509052845.5612">expected = matmul(A, B)

</t>
<t tx="ekr.20230509052845.5613">@gpu.kernel
def kernel(A, B, result):
    i = gpu.thread.x
    j = gpu.thread.y
    result[i][j] = sum(A[i][k]*B[k][j] for k in range(len(A[0])))

</t>
<t tx="ekr.20230509052845.5614">MAX    = 1000  # maximum Mandelbrot iterations
N      = 256   # width and height of image

</t>
<t tx="ekr.20230509052845.5615">@test
def test_mandelbrot():
    pixels = [0 for _ in range(N * N)]

    @others
    kernel(pixels, grid=(N*N)//1024, block=1024)
    assert pixels == expected

</t>
<t tx="ekr.20230509052845.5616">def scale(x, a, b):
    return a + (x/N)*(b - a)

</t>
<t tx="ekr.20230509052845.5617">expected = [0 for _ in range(N * N)]
for i in range(N):
    for j in range(N):
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        expected[N*i + j] = int(255 * iteration/MAX)

</t>
<t tx="ekr.20230509052845.5618">@gpu.kernel
def kernel(pixels):
    idx = (gpu.block.x * gpu.block.dim.x) + gpu.thread.x
    i, j = divmod(idx, N)
    c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
    z = 0j
    iteration = 0

    while abs(z) &lt;= 2 and iteration &lt; MAX:
        z = z**2 + c
        iteration += 1

    pixels[idx] = int(255 * iteration/MAX)

</t>
<t tx="ekr.20230509052845.5619">@test
def test_kitchen_sink():
    @others
    x = [i for i in range(16)]
    kernel(x, grid=1, block=16)
    assert x == [0, 2, 6, 9, 12, 20, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0]

</t>
<t tx="ekr.20230509052845.562">@path C:/Repos/codon/codon/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"
#include "codon/cir/transform/manager.h"
#include "codon/cir/transform/pass.h"
#include "codon/parser/cache.h"
#include "llvm/Passes/PassBuilder.h"
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5620">@gpu.kernel
def kernel(x):
    i = gpu.thread.x
    d = {1: 2.1, 2: 3.5, 3: 4.2}
    s = {4, 5, 6}
    z = sum(
        d.get(x[i], j) + (j if i in s else -j)
        for j in range(i)
    )
    x[i] = int(z)

</t>
<t tx="ekr.20230509052845.5621">@test
def test_auto_par():
    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]

    @par(gpu=True)
    for i in range(16):
        c[i] = a[i] + b[i]

    assert c == [3*i for i in range(16)]

    @par(gpu=True)
    for i in range(16):
        c[i] += a[i] + b[i]

    assert c == [6*i for i in range(16)]

    N = 200
    Z = 42
    x = [0] * (N*N)
    y = [0] * (N*N)

    for i in range(2, N - 1, 3):
        for j in range(3, N, 2):
            x[i*N + j] = i + j + Z

    @par(gpu=True, collapse=2)
    for i in range(2, N - 1, 3):
        for j in range(3, N, 2):
            y[i*N + j] = i + j + Z

    assert x == y

    @par(gpu=True)
    for i in range(1):
        pass

</t>
<t tx="ekr.20230509052845.5622">@path C:/Repos/codon/test/transform/
add_count = 0

@others
test_list_optimization()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5623">@extend
class List:
    @others
</t>
<t tx="ekr.20230509052845.5624">def __add__(self, other: List[T]) -&gt; List[T]:
    global add_count
    add_count += 1
    n = self.len + other.len
    v = List[T](n)
    v.len = n
    p = v.arr.ptr
    str.memcpy(p.as_byte(),
               self.arr.ptr.as_byte(),
               self.len * gc.sizeof(T))
    str.memcpy((p + self.len).as_byte(),
               other.arr.ptr.as_byte(),
               other.len * gc.sizeof(T))
    return v

</t>
<t tx="ekr.20230509052845.5625">@test
def test_list_optimization():
    add_count0 = add_count
    A = list(range(3))
    B = list(range(10))
    assert [0] + [1] == [0, 1]
    assert A + B == [0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    assert (A + B[:] + B[7:] + B[:3] + B[3:7] + B[7:3:-1] + A[::-1] + [11, 22, 33] ==
            [0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 2, 1, 0, 11, 22, 33])

    @others
    order = []
    X = (f([1, 2], 'a', order) +
         [f(3, 'b', order), f(4, 'c', order)] +
         f(list(range(10)), 'd', order)[f(5, 'e', order):f(2, 'f', order):f(-1, 'g', order)])
    assert X == [1, 2, 3, 4, 5, 4, 3]
    assert order == ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    assert add_count == add_count0

</t>
<t tx="ekr.20230509052845.5626">def f(a, tag, order):
    order.append(tag)
    return a

</t>
<t tx="ekr.20230509052845.5627">@path C:/Repos/codon/test/transform/
import openmp as omp
import threading as thr

lock = thr.Lock()

@others
test_omp_api()
test_omp_schedules()
test_omp_ranges()
test_omp_reductions()
test_omp_critical()
test_omp_non_imperative()
test_omp_non_imperative_reductions()
test_omp_transform(111, 222, 333)
test_omp_transform(111.1, 222.2, 333.3)
test_omp_nested()
test_omp_corner_cases()
test_omp_collapse()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5628">@tuple
class A:
    n: int

    @others
</t>
<t tx="ekr.20230509052845.5629">def __new__() -&gt; A:
    return A(0)

</t>
<t tx="ekr.20230509052845.563">/// Base class for DSL plugins. Plugins will return an instance of
/// a child of this class, which defines various characteristics of
/// the DSL, like keywords and IR passes.
class DSL {
public:
  /// General information about this plugin.
  struct Info {
    /// Extension name
    std::string name;
    /// Extension description
    std::string description;
    /// Extension version
    std::string version;
    /// Extension URL
    std::string url;
    /// Supported Codon versions (semver range)
    std::string supported;
    /// Plugin stdlib path
    std::string stdlibPath;
    /// Plugin dynamic library path
    std::string dylibPath;
    /// Linker arguments (to replace "-l dylibPath" if present)
    std::vector&lt;std::string&gt; linkArgs;
  };

  using KeywordCallback =
      std::function&lt;ast::StmtPtr(ast::SimplifyVisitor *, ast::CustomStmt *)&gt;;

  struct ExprKeyword {
    std::string keyword;
    KeywordCallback callback;
  };

  struct BlockKeyword {
    std::string keyword;
    KeywordCallback callback;
    bool hasExpr;
  };

  virtual ~DSL() noexcept = default;

  /// Registers this DSL's IR passes with the given pass manager.
  /// @param pm the pass manager to add the passes to
  /// @param debug true if compiling in debug mode
  virtual void addIRPasses(ir::transform::PassManager *pm, bool debug) {}

  /// Registers this DSL's LLVM passes with the given pass builder.
  /// @param pb the pass builder to add the passes to
  /// @param debug true if compiling in debug mode
  virtual void addLLVMPasses(llvm::PassBuilder *pb, bool debug) {}

  /// Returns a vector of "expression keywords", defined as keywords of
  /// the form "keyword &lt;expr&gt;".
  /// @return this DSL's expression keywords
  virtual std::vector&lt;ExprKeyword&gt; getExprKeywords() { return {}; }

  /// Returns a vector of "block keywords", defined as keywords of the
  /// form "keyword &lt;expr&gt;: &lt;block of code&gt;".
  /// @return this DSL's block keywords
  virtual std::vector&lt;BlockKeyword&gt; getBlockKeywords() { return {}; }
};

</t>
<t tx="ekr.20230509052845.5630">def __add__(self, other: A):
    return A(self.n + other.n)

</t>
<t tx="ekr.20230509052845.5631">def __atomic_add__(a: Ptr[A], other: A):
    with lock:
        a[0] = A(a[0].n + other.n)

</t>
<t tx="ekr.20230509052845.5632">@test
def test_omp_api():
    thr.active_count()
    thr.get_native_id()
    omp.set_num_threads(4)
    omp.get_num_threads()
    omp.get_max_threads()
    omp.get_thread_num()
    omp.get_num_procs()
    omp.in_parallel()
    omp.set_dynamic(False)
    omp.get_dynamic()
    omp.get_cancellation()
    omp.set_schedule('static', 10)
    omp.get_schedule()
    omp.get_thread_limit()
    omp.set_max_active_levels(1)
    omp.get_max_active_levels()
    omp.get_level()
    omp.get_ancestor_thread_num(0)
    omp.get_team_size(0)
    omp.get_active_level()
    omp.in_final()
    omp.get_proc_bind()
    omp.set_default_device(0)
    omp.get_default_device()
    omp.get_num_devices()
    omp.get_num_teams()
    omp.get_team_num()
    omp.is_initial_device()
    omp.get_wtime()
    omp.get_wtick()

</t>
<t tx="ekr.20230509052845.5633">@test
def test_omp_schedules():
    omp.set_num_threads(4)
    N = 10001

    x = list(range(N))
    y = [0] * N
    @par
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static')
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    chunk = 13
    @par(schedule='static', chunk_size=chunk)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N-1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N+1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic')
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    chunk = 17
    @par(schedule='dynamic', chunk_size=chunk)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N-1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N+1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

</t>
<t tx="ekr.20230509052845.5634">@test
def test_omp_ranges():
    nt = 4
    lock = thr.Lock()
    seen = set()

    @others
    @par
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(chunk_size=12)
    for i in range(3, 123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(chunk_size=12)
    for i in range(-3, -123, 7):
        add(seen, i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(chunk_size=12, num_threads=nt)
    for i in range(-3, -123, -7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(chunk_size=10000)
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(chunk_size=10000)
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(chunk_size=10000, num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(schedule='dynamic', num_threads=nt)
    for i in range(-3, -123, -7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12)
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12)
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12, num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

</t>
<t tx="ekr.20230509052845.5635">@omp.critical
def add(seen, i):
    seen.add(i)

</t>
<t tx="ekr.20230509052845.5636">my_global = 42

</t>
<t tx="ekr.20230509052845.5637">class Vector:
    x: float
    y: float

    @others
</t>
<t tx="ekr.20230509052845.5638">def __init__(self):
    self.x = 0.0
    self.y = 0.0

</t>
<t tx="ekr.20230509052845.5639">def __add__(self, other: Vector):
    return Vector(self.x + other.x, self.y + other.y)

</t>
<t tx="ekr.20230509052845.564">@path C:/Repos/codon/codon/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/util/iterators.h"
#include "codon/compiler/error.h"
#include "codon/dsl/dsl.h"
#include "llvm/Support/DynamicLibrary.h"

namespace codon {

/// Plugin metadata
struct Plugin {
  /// the associated DSL
  std::unique_ptr&lt;DSL&gt; dsl;
  /// plugin information
  DSL::Info info;
  /// library handle
  llvm::sys::DynamicLibrary handle;

  Plugin(std::unique_ptr&lt;DSL&gt; dsl, DSL::Info info, llvm::sys::DynamicLibrary handle)
      : dsl(std::move(dsl)), info(std::move(info)), handle(std::move(handle)) {}
};

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5640">def __str__(self):
    return f'&lt;{self.x}, {self.y}&gt;'

</t>
<t tx="ekr.20230509052845.5641">@test
def test_omp_reductions():
    @others
    from math import inf
    omp.set_num_threads(4)
    N = 10001
    L = list(range(N))

    # static
    a = 0
    @par
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par
    for i in L:
        a *= i
    assert a == expected(N, 1, int.__mul__)

    a = 0
    @par
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # static chunked
    a = 0
    @par(chunk_size=3)
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par(chunk_size=3)
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par(chunk_size=3)
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par(chunk_size=3)
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par(chunk_size=3)
    for i in L[1:10]:
        a *= i
    assert a == 1*2*3*4*5*6*7*8*9

    a = 0
    @par(chunk_size=3)
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par(chunk_size=3)
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par(chunk_size=3)
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # dynamic
    a = 0
    @par(schedule='dynamic')
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par(schedule='dynamic')
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par(schedule='dynamic')
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par(schedule='dynamic')
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par(schedule='dynamic')
    for i in L[1:10]:
        a *= i
    assert a == 1*2*3*4*5*6*7*8*9

    a = 0
    @par(schedule='dynamic')
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par(schedule='dynamic')
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par(schedule='dynamic')
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # floats
    c = 0.
    @par
    for i in L:
        c += float(i)
    assert c == expected(N, 0., float.__add__)

    c = 1.
    @par
    for i in L[1:10]:
        c *= float(i)
    assert c == float(1*2*3*4*5*6*7*8*9)

    c = 0.
    @par
    for i in L:
        b = float(N+1 if i == N//2 else i)
        c = max(b, c)
    assert c == float(N+1)

    c = 0.
    @par
    for i in L:
        b = float(-1 if i == N//2 else i)
        c = min(b, c)
    assert c == -1.

    # float32s
    c = f32(0.)
    # this one can give different results due to
    # non-commutativity of floats; so limit to 1001
    @par
    for i in L[1:1001]:
        c += f32(i)
    assert c == sum((f32(i) for i in range(1001)), f32(0))

    c = f32(1.)
    @par
    for i in L[1:10]:
        c *= f32(i)
    assert c == f32(1*2*3*4*5*6*7*8*9)

    c = f32(0.)
    @par
    for i in L:
        b = f32(N+1 if i == N//2 else i)
        c = max(b, c)
    assert c == f32(N+1)

    c = f32(0.)
    @par
    for i in L:
        b = f32(-1 if i == N//2 else i)
        c = min(b, c)
    assert c == f32(-1.)

    x_add = 10.
    x_min = inf
    x_max = -inf
    @par
    for i in L:
        x_i = float(i)
        x_add += x_i
        x_min = min(x_min, x_i)
        x_max = max(x_i, x_max)
    assert x_add == expected(N, 10., float.__add__)
    assert x_min == expected(N, inf, min)
    assert x_max == expected(N, -inf, max)

    x_mul = 2.
    @par
    for i in L[:10]:
        x_i = float(i)
        x_mul *= x_i
    assert x_mul == expected(10, 2., float.__mul__)

    # multiple reductions
    global my_global
    g = my_global
    a = 0
    b = 0
    @par(schedule='dynamic', num_threads=3)
    for i in L:
        a += i
        b ^= i
        my_global += i
    assert a == expected(N, 0, int.__add__)
    assert b == expected(N, 0, int.__xor__)
    assert my_global == g + expected(N, 0, int.__add__)

    # custom reductions
    vectors = [Vector(i, i) for i in range(10)]
    v = Vector()
    @par
    for vv in vectors:
        v += vv
    assert v.x == 45.0
    assert v.y == 45.0

</t>
<t tx="ekr.20230509052845.5642">def expected(N, a, op):
    for i in range(N):
        a = op(a, type(a)(i))
    return a

</t>
<t tx="ekr.20230509052845.5643">another_global = 0
</t>
<t tx="ekr.20230509052845.5644">@test
def test_omp_critical():
    @others
    global another_global
    for n in (99999, 100000, 100001):
        another_global = 0
        @par(schedule='dynamic')
        for i in range(n):
            foo(i)
            bar(i)
        assert another_global == 2*sum(range(n))

</t>
<t tx="ekr.20230509052845.5645">@omp.critical
def foo(i):
    global another_global
    another_global += i

</t>
<t tx="ekr.20230509052845.5646">@omp.critical
def bar(i):
    global another_global
    another_global += i

</t>
<t tx="ekr.20230509052845.5647">@test
def test_omp_non_imperative():
    @others
    N = 10001
    v = [0] * N

    @par
    for i,s in enumerate(squares(N)):
        v[i] = s

    assert all(s == i*i for i,s in enumerate(v))

</t>
<t tx="ekr.20230509052845.5648">def squares(N):
    for i in range(N):
        yield i*i

</t>
<t tx="ekr.20230509052845.5649">test_generator_based_loops_global = 0.7

</t>
<t tx="ekr.20230509052845.565">/// Manager for loading, applying and unloading plugins.
class PluginManager {
private:
  /// Codon executable location
  std::string argv0;
  /// vector of loaded plugins
  std::vector&lt;std::unique_ptr&lt;Plugin&gt;&gt; plugins;

public:
  /// Constructs a plugin manager
  PluginManager(const std::string &amp;argv0) : argv0(argv0), plugins() {}

  /// @return iterator to the first plugin
  auto begin() { return ir::util::raw_ptr_adaptor(plugins.begin()); }
  /// @return iterator beyond the last plugin
  auto end() { return ir::util::raw_ptr_adaptor(plugins.end()); }
  /// @return const iterator to the first plugin
  auto begin() const { return ir::util::const_raw_ptr_adaptor(plugins.begin()); }
  /// @return const iterator beyond the last plugin
  auto end() const { return ir::util::const_raw_ptr_adaptor(plugins.end()); }

  /// Loads the plugin at the given load path.
  /// @param path path to plugin directory containing "plugin.toml" file
  /// @return plugin pointer if successful, plugin error otherwise
  llvm::Expected&lt;Plugin *&gt; load(const std::string &amp;path);
};

</t>
<t tx="ekr.20230509052845.5650">@test
def test_omp_non_imperative_reductions():
    @others
    global test_generator_based_loops_global
    N = 1001

    # no reductions
    v = set()
    @par
    for i in squares(N):
        x = i - 1
        add(v, x)
    assert v == {i**2 - 1 for i in range(N)}

    # one reduction
    a = 0
    @par
    for i in squares(N):
        a += i
    assert a == 333833500

    # kitchen sink
    a = 7
    b = 0
    c = 0.5
    d = foo(0)
    e = foo(1)
    f = foo(-1)
    g = -1
    h = Vector(1.5, 1.25)
    @par
    for i in squares(N):
        x = foo(i) + d
        y = foo(x) + e + f
        a = x + a + d
        b ^= y - d
        c += x + d
        test_generator_based_loops_global += y - d
        f = foo(-1)
        g = max(i, g)
        h += Vector(i, i)
    assert a == 333833507
    assert b == 332752
    assert c == 333833500.5
    assert test_generator_based_loops_global == 333833500.7
    assert g == (N - 1) ** 2
    assert h.x == 333833501.5
    assert h.y == 333833501.25

</t>
<t tx="ekr.20230509052845.5651">def squares(n):
    for i in range(n):
        yield i*i

</t>
<t tx="ekr.20230509052845.5652">@omp.critical
def add(v, x):
    v.add(x)

</t>
<t tx="ekr.20230509052845.5653">@nonpure
def foo(x):
    return x

</t>
<t tx="ekr.20230509052845.5654">@test
def test_omp_transform(a, b, c):
    a0, b0, c0 = a, b, c
    d = a + b + c
    v = list(range(int(d*d)))
    ids = set()

    @par('schedule(static, 5) num_threads(3) ordered')
    for i in v:
        a += type(a)(i)
        z = i * i
        c = type(c)(z)
        b += type(b)(z)
        with lock:
            ids.add(omp.get_thread_num())

    for i in v:
        a0 += type(a0)(i)
        z = i * i
        c0 = type(c0)(z)
        b0 += type(b0)(z)

    assert ids == {0, 1, 2}
    assert int(a) == int(a0)
    assert abs(b - b0) &lt; b/1e6
    assert c == v[-1] ** 2

</t>
<t tx="ekr.20230509052845.5655">@test
def test_omp_nested():
    @others
    N = 100
    v = []

    v.clear()
    @par
    for i in range(N):
        @par
        for j in range(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in range(N) for j in range(i)}

    v.clear()
    @par
    for i in range(N):
        @par
        for j in squares(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in range(N) for j in squares(i)}

    v.clear()
    @par
    for i in squares(N):
        @par
        for j in range(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in squares(N) for j in range(i)}

    v.clear()
    @par
    for i in squares(N):
        @par
        for j in squares(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in squares(N) for j in squares(i)}

</t>
<t tx="ekr.20230509052845.5656">def squares(n):
    for i in range(n):
        yield i*i

</t>
<t tx="ekr.20230509052845.5657">@test
def test_omp_corner_cases():
    @others
    v = list(range(10))

    @par
    for i in range(10):
        pass

    @par
    for i in v:
        pass

    @par(num_threads=2)
    for i in range(10):
        pass

    @par(schedule='dynamic')
    for i in range(10):
        pass

    @par(num_threads=2, schedule='dynamic')
    for i in range(10):
        pass

    @par
    for i in squares(10):
        pass

    @par(num_threads=2)
    for i in squares(10):
        pass

    @par
    for i in range(10):
        foo(i)

    @par
    for i in squares(10):
        foo(i)

    @par
    for i in range(10):
        a = foo(i)

    @par
    for i in squares(10):
        a = foo(i)

    @par
    for i in range(10):
        i += i

    @par
    for i in squares(10):
        i += i

</t>
<t tx="ekr.20230509052845.5658">def squares(n):
    for i in range(n):
        yield i*i

</t>
<t tx="ekr.20230509052845.5659">@nonpure
def foo(x):
    return x

</t>
<t tx="ekr.20230509052845.566"></t>
<t tx="ekr.20230509052845.5660">@test
def test_omp_collapse():
    # trivial
    A0 = []
    B0 = []

    for i in range(10):
        A0.append(i)

    @par(num_threads=4, collapse=1)
    for i in range(10):
        with lock:
            B0.append(i)

    assert sorted(A0) == sorted(B0)

    # basic
    A1 = []
    B1 = []

    for i in range(10):
        for j in range(10):
            A1.append((i,j))

    @par(num_threads=4, collapse=2)
    for i in range(10):
        for j in range(10):
            with lock:
                B1.append((i,j))

    assert sorted(A1) == sorted(B1)

    # deep
    A2 = []
    B2 = []

    for a in range(3):
        for b in range(4):
            for c in range(5):
                for d in range(6):
                    A2.append((a,b,c,d))

    @par(num_threads=4, collapse=4)
    for a in range(3):
        for b in range(4):
            for c in range(5):
                for d in range(6):
                    with lock:
                        B2.append((a,b,c,d))

    assert sorted(A2) == sorted(B2)

    # ranges 1
    A3 = []
    B3 = []

    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    A3.append((a,b,c,d))

    @par(num_threads=4, collapse=4)
    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    with lock:
                        B3.append((a,b,c,d))

    assert sorted(A3) == sorted(B3)

    # ranges 2
    A4 = []
    B4 = []

    for i in range(10):
        for j in range(7,-5,-2):
            for k in range(-5,10,3):
                A4.append((i,j,k))

    @par(num_threads=4, collapse=3)
    for i in range(10):
        for j in range(7,-5,-2):
            for k in range(-5,10,3):
                with lock:
                    B4.append((i,j,k))

    assert sorted(A4) == sorted(B4)

    # zero
    B5 = []

    @others
    start = zstart()
    stop = zstop()

    @par(num_threads=4, collapse=3)
    for i in range(10):
        for j in range(start, stop, 1):
            for k in range(-5,10,3):
                with lock:
                    B5.append((i,j,k))

    assert len(B5) == 0

    # order
    A6 = []
    B6 = []

    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    A6.append((a,b,c,d))

    @par(num_threads=1, collapse=4)
    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    B6.append((a,b,c,d))  # no lock since threads=1

    assert A6 == B6

</t>
<t tx="ekr.20230509052845.5661">@noinline
def zstart():
    return 5

</t>
<t tx="ekr.20230509052845.5662">@noinline
def zstop():
    return -5

</t>
<t tx="ekr.20230509052845.5663">@path C:/Repos/codon/test/transform/
@others
test_invalid_outline_stack_alloc()
# EXPECT: 42

print __outline_successes__()
print __outline_failures__()
# EXPECT: 8
# EXPECT: 3
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5664">@nonpure
def __outline_begin__():
    pass

</t>
<t tx="ekr.20230509052845.5665">@nonpure
def __outline_end__():
    pass

</t>
<t tx="ekr.20230509052845.5666">@nonpure
def __outline_successes__():
    return 0

</t>
<t tx="ekr.20230509052845.5667">@nonpure
def __outline_failures__():
    return 0

</t>
<t tx="ekr.20230509052845.5668"># use this to avoid const-folding
def N(n):
    return n

</t>
<t tx="ekr.20230509052845.5669">@test
def test_basic_outline():
    __outline_begin__()
    print 'hello world'
    __outline_end__()
</t>
<t tx="ekr.20230509052845.567">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/parser/ast/error.h"
#include "codon/parser/ast/expr.h"
#include "codon/parser/ast/stmt.h"
#include "codon/parser/ast/types.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5670">test_basic_outline()
# EXPECT: hello world

</t>
<t tx="ekr.20230509052845.5671">@test
def test_private_vars_outline(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    print a + 1
    a = N(99)
    __outline_end__()
    b = N(13)
</t>
<t tx="ekr.20230509052845.5672">test_private_vars_outline('x')
# EXPECT: 43

</t>
<t tx="ekr.20230509052845.5673">@test
def test_shared_vars_outline(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    print a + b + x
    a = N(99)
    y = N(-42)
    __outline_end__()
    b = N(13)
    print a
    print b
    print y
</t>
<t tx="ekr.20230509052845.5674">test_shared_vars_outline(100)
# EXPECT: 152
# EXPECT: 99
# EXPECT: 13
# EXPECT: -42

f = 'f'
</t>
<t tx="ekr.20230509052845.5675">@test
def test_shared_vars_with_mod_outline(x):
    global f
    b = N(10)
    f = 'o'
    __outline_begin__()
    for i in range(1):
        a = N(42)
        print a + b + x
        a = N(99)
        x = N(-5)
        f = str(i)
    __outline_end__()
    b = N(13)
    print b, x
</t>
<t tx="ekr.20230509052845.5676">test_shared_vars_with_mod_outline(100)
print f
# EXPECT: 152
# EXPECT: 13 -5
# EXPECT: 0

g = 'g'
</t>
<t tx="ekr.20230509052845.5677">@test
def test_out_flow_return_outline(x):
    global g
    b = N(10)
    g = 'o'
    __outline_begin__()
    for i in range(1):
        a = N(42)
        print a + b + x
        a = N(99)
        x = N(-5)
        g = str(i)
        return a
        break
    __outline_end__()
    assert False
</t>
<t tx="ekr.20230509052845.5678">test_out_flow_return_outline(100)
print g
# EXPECT: 152
# EXPECT: 0

h = 'h'
</t>
<t tx="ekr.20230509052845.5679">@test
def test_out_flow_break_continue_outline(x):
    global h
    b = N(10)
    h = 'o'
    for i in range(3):
        __outline_begin__()
        if i == 0:
            continue
        if i == 2:
            break
        for j in range(2):
            if j == 0:
                continue

            a = N(42)
            print a + b + x + j
            a = N(99)
            x = N(-5)
            h = str(i)
            break
        __outline_end__()
    b = N(13)
    print b, x
</t>
<t tx="ekr.20230509052845.568">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/cir/pyextension.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

#define FILE_GENERATED "&lt;generated&gt;"
#define MODULE_MAIN "__main__"
#define MAIN_IMPORT ""
#define STDLIB_IMPORT ":stdlib:"
#define STDLIB_INTERNAL_MODULE "internal"

#define TYPE_TUPLE "Tuple.N"
#define TYPE_KWTUPLE "KwTuple.N"
#define TYPE_TYPEVAR "TypeVar"
#define TYPE_CALLABLE "Callable"
#define TYPE_PARTIAL "Partial.N"
#define TYPE_OPTIONAL "Optional"
#define TYPE_SLICE "std.internal.types.slice.Slice"
#define FN_UNWRAP "std.internal.types.optional.unwrap"
#define VAR_ARGV "__argv__"
#define VAR_VTABLE ".__vtable__"

#define MAX_INT_WIDTH 10000
#define MAX_REALIZATION_DEPTH 200
#define MAX_STATIC_ITER 1024

namespace codon::ast {

/// Forward declarations
struct SimplifyContext;
class SimplifyVisitor;
struct TypeContext;
struct TranslateContext;

/**
 * Cache encapsulation that holds data structures shared across various transformation
 * stages (AST transformation, type checking etc.). The subsequent stages (e.g. type
 * checking) assumes that previous stages populated this structure correctly.
 * Implemented to avoid bunch of global objects.
 */
struct Cache : public std::enable_shared_from_this&lt;Cache&gt; {
  /// Stores a count for each identifier (name) seen in the code.
  /// Used to generate unique identifier for each name in the code (e.g. Foo -&gt; Foo.2).
  std::unordered_map&lt;std::string, int&gt; identifierCount;
  /// Maps a unique identifier back to the original name in the code
  /// (e.g. Foo.2 -&gt; Foo).
  std::unordered_map&lt;std::string, std::string&gt; reverseIdentifierLookup;
  /// Number of code-generated source code positions. Used to generate the next unique
  /// source-code position information.
  int generatedSrcInfoCount;
  /// Number of unbound variables so far. Used to generate the next unique unbound
  /// identifier.
  int unboundCount;
  /// Number of auto-generated variables so far. Used to generate the next unique
  /// variable name in getTemporaryVar() below.
  int varCount;
  /// Stores the count of imported files. Used to track class method ages
  /// and to prevent using extended methods before they were seen.
  int age;

  /// Holds module import data.
  struct Import {
    /// Absolute filename of an import.
    std::string filename;
    /// Import simplify context.
    std::shared_ptr&lt;SimplifyContext&gt; ctx;
    /// Unique import variable for checking already loaded imports.
    std::string importVar;
    /// File content (line:col indexable)
    std::vector&lt;std::string&gt; content;
    /// Relative module name (e.g., `foo.bar`)
    std::string moduleName;
  };

  /// Absolute path of seqc executable (if available).
  std::string argv0;
  /// Absolute path of the entry-point module (if available).
  std::string module0;
  /// IR module.
  ir::Module *module = nullptr;

  /// Table of imported files that maps an absolute filename to a Import structure.
  /// By convention, the key of the Codon's standard library is "".
  std::unordered_map&lt;std::string, Import&gt; imports;

  /// Set of unique (canonical) global identifiers for marking such variables as global
  /// in code-generation step and in JIT.
  std::map&lt;std::string, ir::Var *&gt; globals;

  /// Stores class data for each class (type) in the source code.
  struct Class {
    /// Generic (unrealized) class template AST.
    std::shared_ptr&lt;ClassStmt&gt; ast;
    /// Non-simplified AST. Used for base class instantiation.
    std::shared_ptr&lt;ClassStmt&gt; originalAst;

    /// Class method lookup table. Each non-canonical name points
    /// to a root function name of a corresponding method.
    std::unordered_map&lt;std::string, std::string&gt; methods;

    /// A class field (member).
    struct ClassField {
      /// Field name.
      std::string name;
      /// A corresponding generic field type.
      types::TypePtr type;
    };
    /// A list of class' ClassField instances. List is needed (instead of map) because
    /// the order of the fields matters.
    std::vector&lt;ClassField&gt; fields;

    /// Dictionary of class variables: a name maps to a canonical name.
    std::unordered_map&lt;std::string, std::string&gt; classVars;

    /// A class realization.
    struct ClassRealization {
      /// Realized class type.
      types::ClassTypePtr type;
      /// A list of field names and realization's realized field types.
      std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt; fields;
      /// IR type pointer.
      codon::ir::types::Type *ir = nullptr;

      /// Realization vtable.
      struct VTable {
        // Maps {base, thunk signature} to {thunk realization, thunk ID}
        std::map&lt;std::pair&lt;std::string, std::string&gt;,
                 std::pair&lt;types::FuncTypePtr, size_t&gt;&gt;
            table;
        codon::ir::Var *ir = nullptr;
      };
      /// All vtables (for each base class)
      std::unordered_map&lt;std::string, VTable&gt; vtables;
      /// Realization ID
      size_t id = 0;
    };
    /// Realization lookup table that maps a realized class name to the corresponding
    /// ClassRealization instance.
    std::unordered_map&lt;std::string, std::shared_ptr&lt;ClassRealization&gt;&gt; realizations;

    /// List of virtual method names
    std::unordered_set&lt;std::string&gt; virtuals;
    /// MRO
    std::vector&lt;ExprPtr&gt; mro;

    /// List of statically inherited classes.
    std::vector&lt;std::string&gt; staticParentClasses;

    /// Module information
    std::string module;

    Class() : ast(nullptr), originalAst(nullptr) {}
  };
  /// Class lookup table that maps a canonical class identifier to the corresponding
  /// Class instance.
  std::unordered_map&lt;std::string, Class&gt; classes;
  size_t classRealizationCnt = 0;

  struct Function {
    /// Generic (unrealized) function template AST.
    std::shared_ptr&lt;FunctionStmt&gt; ast;
    /// Non-simplified AST.
    std::shared_ptr&lt;FunctionStmt&gt; origAst;

    /// A function realization.
    struct FunctionRealization {
      /// Realized function type.
      types::FuncTypePtr type;
      /// Realized function AST (stored here for later realization in code generations
      /// stage).
      std::shared_ptr&lt;FunctionStmt&gt; ast;
      /// IR function pointer.
      ir::Func *ir;
    };
    /// Realization lookup table that maps a realized function name to the corresponding
    /// FunctionRealization instance.
    std::unordered_map&lt;std::string, std::shared_ptr&lt;FunctionRealization&gt;&gt; realizations;

    /// Unrealized function type.
    types::FuncTypePtr type;

    /// Module information
    std::string rootName = "";
    bool isToplevel = false;

    Function()
        : ast(nullptr), origAst(nullptr), type(nullptr), rootName(""),
          isToplevel(false) {}
  };
  /// Function lookup table that maps a canonical function identifier to the
  /// corresponding Function instance.
  std::unordered_map&lt;std::string, Function&gt; functions;

  struct Overload {
    /// Canonical name of an overload (e.g. Foo.__init__.1).
    std::string name;
    /// Overload age (how many class extension were seen before a method definition).
    /// Used to prevent the usage of an overload before it was defined in the code.
    /// TODO: I have no recollection of how this was supposed to work. Most likely
    /// it does not work at all...
    int age;
  };
  /// Maps a "root" name of each function to the list of names of the function
  /// overloads.
  std::unordered_map&lt;std::string, std::vector&lt;Overload&gt;&gt; overloads;

  /// Pointer to the later contexts needed for IR API access.
  std::shared_ptr&lt;TypeContext&gt; typeCtx;
  std::shared_ptr&lt;TranslateContext&gt; codegenCtx;
  /// Set of function realizations that are to be translated to IR.
  std::set&lt;std::pair&lt;std::string, std::string&gt;&gt; pendingRealizations;
  /// Mapping of partial record names to function pointers and corresponding masks.
  std::unordered_map&lt;std::string, std::pair&lt;types::FuncTypePtr, std::vector&lt;char&gt;&gt;&gt;
      partials;

  /// Custom operators
  std::unordered_map&lt;std::string,
                     std::pair&lt;bool, std::function&lt;StmtPtr(ast::SimplifyVisitor *,
                                                           ast::CustomStmt *)&gt;&gt;&gt;
      customBlockStmts;
  std::unordered_map&lt;std::string,
                     std::function&lt;StmtPtr(ast::SimplifyVisitor *, ast::CustomStmt *)&gt;&gt;
      customExprStmts;

  /// Plugin-added import paths
  std::vector&lt;std::string&gt; pluginImportPaths;

  /// Set if the Codon is running in JIT mode.
  bool isJit;
  int jitCell;

  std::unordered_map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt; replacements;
  std::unordered_map&lt;std::string, int&gt; generatedTuples;
  std::vector&lt;exc::ParserException&gt; errors;

  /// Set if Codon operates in Python compatibility mode (e.g., with Python numerics)
  bool pythonCompat = false;
  /// Set if Codon operates in Python extension mode
  bool pythonExt = false;

public:
  explicit Cache(std::string argv0 = "");

  /// Return a uniquely named temporary variable of a format
  /// "{sigil}_{prefix}{counter}". A sigil should be a non-lexable symbol.
  std::string getTemporaryVar(const std::string &amp;prefix = "", char sigil = '.');
  /// Get the non-canonical version of a canonical name.
  std::string rev(const std::string &amp;s);

  /// Generate a unique SrcInfo for internally generated AST nodes.
  SrcInfo generateSrcInfo();
  /// Get file contents at the given location.
  std::string getContent(const SrcInfo &amp;info);
  /// Register a global identifier.
  void addGlobal(const std::string &amp;name, ir::Var *var = nullptr);

  /// Realization API.

  /// Find a class with a given canonical name and return a matching types::Type pointer
  /// or a nullptr if a class is not found.
  /// Returns an _uninstantiated_ type.
  types::ClassTypePtr findClass(const std::string &amp;name) const;
  /// Find a function with a given canonical name and return a matching types::Type
  /// pointer or a nullptr if a function is not found.
  /// Returns an _uninstantiated_ type.
  types::FuncTypePtr findFunction(const std::string &amp;name) const;
  /// Find the canonical name of a class method.
  std::string getMethod(const types::ClassTypePtr &amp;typ, const std::string &amp;member) {
    if (auto m = in(classes, typ-&gt;name)) {
      if (auto t = in(m-&gt;methods, member))
        return *t;
    }
    seqassertn(false, "cannot find '{}' in '{}'", member, typ-&gt;toString());
    return "";
  }
  /// Find the class method in a given class type that best matches the given arguments.
  /// Returns an _uninstantiated_ type.
  types::FuncTypePtr findMethod(types::ClassType *typ, const std::string &amp;member,
                                const std::vector&lt;types::TypePtr&gt; &amp;args);

  /// Given a class type and the matching generic vector, instantiate the type and
  /// realize it.
  ir::types::Type *realizeType(types::ClassTypePtr type,
                               const std::vector&lt;types::TypePtr&gt; &amp;generics = {});
  /// Given a function type and function arguments, instantiate the type and
  /// realize it. The first argument is the function return type.
  /// You can also pass function generics if a function has one (e.g. T in def
  /// foo[T](...)). If a generic is used as an argument, it will be auto-deduced. Pass
  /// only if a generic cannot be deduced from the provided args.
  ir::Func *realizeFunction(types::FuncTypePtr type,
                            const std::vector&lt;types::TypePtr&gt; &amp;args,
                            const std::vector&lt;types::TypePtr&gt; &amp;generics = {},
                            const types::ClassTypePtr &amp;parentClass = nullptr);

  ir::types::Type *makeTuple(const std::vector&lt;types::TypePtr&gt; &amp;types);
  ir::types::Type *makeFunction(const std::vector&lt;types::TypePtr&gt; &amp;types);
  ir::types::Type *makeUnion(const std::vector&lt;types::TypePtr&gt; &amp;types);

  void parseCode(const std::string &amp;code);

  static std::vector&lt;ExprPtr&gt; mergeC3(std::vector&lt;std::vector&lt;ExprPtr&gt;&gt; &amp;);

  std::shared_ptr&lt;ir::PyModule&gt; pyModule = nullptr;
  void populatePythonModule();
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5680">test_out_flow_break_continue_outline(100)
print h
# EXPECT: 153
# EXPECT: 13 -5
# EXPECT: 1

</t>
<t tx="ekr.20230509052845.5681">@test
def test_generator_return_outline(x):
    for i in range(x):
        yield i
        __outline_begin__()
        if i == 2:
            continue
        if i == 4:
            return
        __outline_end__()
        yield i
</t>
<t tx="ekr.20230509052845.5682">print list(test_generator_return_outline(10))
# EXPECT: [0, 0, 1, 1, 2, 3, 3, 4]

</t>
<t tx="ekr.20230509052845.5683">@test
def test_normal_return_outline(x):
    for i in range(x):
        yield i
        __outline_begin__()
        if i == 2:
            continue
        if i == 4:
            return
        __outline_end__()
        yield i
</t>
<t tx="ekr.20230509052845.5684">print list(test_normal_return_outline(1))
# EXPECT: [0, 0]

</t>
<t tx="ekr.20230509052845.5685">@test
def test_invalid_outline_yield(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    yield a + b + x
    a = N(99)
    __outline_end__()
    b = N(13)
</t>
<t tx="ekr.20230509052845.5686">test_invalid_outline_yield(-123)

</t>
<t tx="ekr.20230509052845.5687">@test
def test_invalid_outline_yield_in(x):
    b = N(10)
    __outline_begin__()
    a = (yield) + b
    yield b
    __outline_end__()
    b = N(13)
</t>
<t tx="ekr.20230509052845.5688">test_invalid_outline_yield_in(-123)

</t>
<t tx="ekr.20230509052845.5689">@test
def test_invalid_outline_stack_alloc():
    __outline_begin__()
    a = __array__[int](1)
    a[0] = 42
    __outline_end__()
    print a[0]
</t>
<t tx="ekr.20230509052845.569">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/util/common.h"

#define CAST(s, T) dynamic_cast&lt;T *&gt;(s.get())

namespace codon {

namespace ast {

/// String and collection utilities

/// Split a delimiter-separated string into a vector of strings.
std::vector&lt;std::string&gt; split(const std::string &amp;str, char delim);
/// Escape a C string (replace \n with \\n etc.).
std::string escape(const std::string &amp;str);
/// Unescape a C string (replace \\n with \n etc.).
std::string unescape(const std::string &amp;str);
/// Escape an F-string braces (replace { and } with {{ and }}).
std::string escapeFStringBraces(const std::string &amp;str, int start, int len);
int findStar(const std::string &amp;s);
/// True if a string str starts with a prefix.
size_t startswith(const std::string &amp;str, const std::string &amp;prefix);
/// True if a string str ends with a suffix.
size_t endswith(const std::string &amp;str, const std::string &amp;suffix);
/// Trims whitespace at the beginning of the string.
void ltrim(std::string &amp;str);
/// Trims whitespace at the end of the string.
void rtrim(std::string &amp;str);
/// Removes leading stars in front of the string and returns the number of such stars.
int trimStars(std::string &amp;str);
/// True if a string only contains digits.
bool isdigit(const std::string &amp;str);
@others
/// @return vector c transformed by the function f.
template &lt;typename T, typename F&gt; auto vmap(const std::vector&lt;T&gt; &amp;c, F &amp;&amp;f) {
  std::vector&lt;typename std::result_of&lt;F(const T &amp;)&gt;::type&gt; ret;
  std::transform(std::begin(c), std::end(c), std::inserter(ret, std::end(ret)), f);
  return ret;
}

/// AST utilities

/// Clones a pointer even if it is a nullptr.
template &lt;typename T&gt; auto clone(const std::shared_ptr&lt;T&gt; &amp;t) {
  return t ? t-&gt;clone() : nullptr;
}

/// Clones a vector of cloneable pointer objects.
template &lt;typename T&gt; std::vector&lt;T&gt; clone(const std::vector&lt;T&gt; &amp;t) {
  std::vector&lt;T&gt; v;
  for (auto &amp;i : t)
    v.push_back(clone(i));
  return v;
}

/// Clones a vector of cloneable objects.
template &lt;typename T&gt; std::vector&lt;T&gt; clone_nop(const std::vector&lt;T&gt; &amp;t) {
  std::vector&lt;T&gt; v;
  for (auto &amp;i : t)
    v.push_back(i.clone());
  return v;
}

/// Path utilities

/// @return The absolute canonical path of a given path.
std::string getAbsolutePath(const std::string &amp;path);

/// Detect an absolute path of the current executable (whose argv0 is known).
/// @return Absolute executable path or argv0 if one cannot be found.
std::string executable_path(const char *argv0);
/// Detect an absolute path of the current libcodonc.
/// @return Absolute executable path or argv0 if one cannot be found.
std::string library_path();

struct ImportFile {
  enum Status { STDLIB, PACKAGE };
  Status status;
  /// Absolute path of an import.
  std::string path;
  /// Module name (e.g. foo.bar.baz).
  std::string module;
};
/// Find an import file what given an executable path (argv0) either in the standard
/// library or relative to a file relativeTo. Set forceStdlib for searching only the
/// standard library.
std::shared_ptr&lt;ImportFile&gt; getImportFile(const std::string &amp;argv0,
                                          const std::string &amp;what,
                                          const std::string &amp;relativeTo,
                                          bool forceStdlib = false,
                                          const std::string &amp;module0 = "",
                                          const std::vector&lt;std::string&gt; &amp;plugins = {});

} // namespace ast
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5690">@path C:/Repos/codon/test/transform/
cat_count = 0

@others
test_str_optimization()
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.5691"># c/p from str.seq
def old_cat(*args):
    total = 0
    if staticlen(args) == 1 and hasattr(args[0], "__iter__") and hasattr(args[0], "__len__"):
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            total += s.len
        p = cobj(total)
        n = 0
        for s in args[0]:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        sz = 10
        p = cobj(sz)
        n = 0
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            if n + s.len &gt; sz:
                sz = 1 + 3 * (n + s.len) // 2
                pp = cobj(sz)
                str.memcpy(pp, p, n)
                p = pp
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, n)
    else:
        total = 0
        for i in args:
            if not isinstance(i, str):
                compile_error("not a string")
            total += i.len
        p = cobj(total)
        n = 0
        for i in args:
            str.memcpy(p + n, i.ptr, i.len)
            n += i.len
        return str(p, total)

</t>
<t tx="ekr.20230509052845.5692">@extend
class str:
    def cat(*args):
        global cat_count
        cat_count += 1
        return old_cat(*args)

</t>
<t tx="ekr.20230509052845.5693">@test
def test_str_optimization():
    assert 'hello ' + 'world' == "hello world"  # no opt: just adding 2 strs
    assert cat_count == 0
    # assert 'a' + 'b' + 'c' == 'abc' # superseded by string statics
    # assert cat_count == 1
    assert 'a' * 2 == 'aa'  # no opt: mul instead of add
    assert cat_count == 0
    # assert 'a' + ('b' + 'c') == 'abc'
    # assert cat_count == 2
    # assert 'a' + ('b' + ('c' + 'd')) == 'abcd'
    # assert cat_count == 3

    a = 'a'
    b = 'b'
    c = 'c'
    assert (a*2 + b*3 + c*4) == 'aabbbcccc'
    assert cat_count == 1
</t>
<t tx="ekr.20230509052845.57">def GetDomain(self):
    """Returns the domain of the B-Spline"""
    return (self.knots[self.degree - 1],
            self.knots[len(self.knots) - self.degree])

</t>
<t tx="ekr.20230509052845.570">/// Combine items separated by a delimiter into a string.
template &lt;typename T&gt;
std::string join(const T &amp;items, const std::string &amp;delim = " ", size_t start = 0,
                 size_t end = (1ull &lt;&lt; 31)) {
  std::string s;
  if (end &gt; items.size())
    end = items.size();
  for (int i = start; i &lt; end; i++)
    s += (i &gt; start ? delim : "") + items[i];
  return s;
}
</t>
<t tx="ekr.20230509052845.571">/// Combine items separated by a delimiter into a string.
template &lt;typename T&gt;
std::string combine(const std::vector&lt;T&gt; &amp;items, const std::string &amp;delim = " ") {
  std::string s;
  for (int i = 0; i &lt; items.size(); i++)
    if (items[i])
      s += (i ? delim : "") + items[i]-&gt;toString();
  return s;
}
</t>
<t tx="ekr.20230509052845.572">template &lt;typename T&gt;
std::string combine2(const std::vector&lt;T&gt; &amp;items, const std::string &amp;delim = ",",
  @others
</t>
<t tx="ekr.20230509052845.573">                   int start = 0, int end = -1) {
std::string s;
if (end == -1)
  end = items.size();
for (int i = start; i &lt; end; i++)
  s += (i ? delim : "") + fmt::format("{}", items[i]);
return s;
}
</t>
<t tx="ekr.20230509052845.574">/// @return True if an item is found in a vector vec.
template &lt;typename T, typename U&gt;
const T *in(const std::vector&lt;T&gt; &amp;vec, const U &amp;item, size_t start = 0) {
  auto f = std::find(vec.begin() + start, vec.end(), item);
  return f != vec.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509052845.575">/// @return True if an item is found in a set s.
template &lt;typename T, typename U&gt; const T *in(const std::set&lt;T&gt; &amp;s, const U &amp;item) {
  auto f = s.find(item);
  return f != s.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509052845.576">/// @return True if an item is found in an unordered_set s.
template &lt;typename T, typename U&gt;
const T *in(const std::unordered_set&lt;T&gt; &amp;s, const U &amp;item) {
  auto f = s.find(item);
  return f != s.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509052845.577">/// @return True if an item is found in a map m.
template &lt;typename K, typename V, typename U&gt;
const V *in(const std::map&lt;K, V&gt; &amp;m, const U &amp;item) {
  auto f = m.find(item);
  return f != m.end() ? &amp;(f-&gt;second) : nullptr;
}
</t>
<t tx="ekr.20230509052845.578">/// @return True if an item is found in an unordered_map m.
template &lt;typename K, typename V, typename U&gt;
const V *in(const std::unordered_map&lt;K, V&gt; &amp;m, const U &amp;item) {
  auto f = m.find(item);
  return f != m.end() ? &amp;(f-&gt;second) : nullptr;
}
</t>
<t tx="ekr.20230509052845.579">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"

namespace codon::ast {

/**
 * A variable table (transformation context).
 * Base class that holds a list of existing identifiers and their block hierarchy.
 * @tparam T Variable type.
 */
template &lt;typename T&gt; class Context : public std::enable_shared_from_this&lt;Context&lt;T&gt;&gt; {
public:
  using Item = std::shared_ptr&lt;T&gt;;

protected:
  using Map = std::unordered_map&lt;std::string, std::list&lt;Item&gt;&gt;;
  /// Maps a identifier to a stack of objects that share the same identifier.
  /// Each object is represented by a nesting level and a pointer to that object.
  /// Top of the stack is the current block; the bottom is the outer-most block.
  /// Stack is represented as std::deque to allow iteration and access to the outer-most
  /// block.
  Map map;
  /// Stack of blocks and their corresponding identifiers. Top of the stack is the
  /// current block.
  std::deque&lt;std::list&lt;std::string&gt;&gt; stack;

private:
  /// Set of current context flags.
  std::unordered_set&lt;std::string&gt; flags;
  /// The absolute path of the current module.
  std::string filename;
  /// SrcInfo stack used for obtaining source information of the current expression.
  std::vector&lt;SrcInfo&gt; srcInfos;

public:
  explicit Context(std::string filename) : filename(std::move(filename)) {
    /// Add a top-level block to the stack.
    stack.push_front(std::list&lt;std::string&gt;());
  }
  virtual ~Context() = default;

  /// Add an object to the top of the stack.
  virtual void add(const std::string &amp;name, const Item &amp;var) {
    seqassertn(!name.empty(), "adding an empty identifier");
    map[name].push_front(var);
    stack.front().push_back(name);
  }
@others
public:
  /* SrcInfo helpers */
  void pushSrcInfo(SrcInfo s) { srcInfos.emplace_back(std::move(s)); }
  void popSrcInfo() { srcInfos.pop_back(); }
  SrcInfo getSrcInfo() const { return srcInfos.back(); }
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.58">def __call__(self, u):
    """Calculates a point of the B-Spline using de Boors Algorithm"""
    dom = self.GetDomain()
    if u &lt; dom[0] or u &gt; dom[1]:
        raise ValueError("Function value not in domain")
    if u == dom[0]:
        return self.points[0]
    if u == dom[1]:
        return self.points[-1]
    I = self.GetIndex(u)
    d = [self.points[I - self.degree + 1 + ii]
         for ii in range(self.degree + 1)]
    U = self.knots
    for ik in range(1, self.degree + 1):
        for ii in range(I - self.degree + ik + 1, I + 2):
            ua = U[ii + self.degree - ik]
            ub = U[ii - 1]
            co1 = (ua - u) / (ua - ub)
            co2 = (u - ub) / (ua - ub)
            index = ii - I + self.degree - ik - 1
            d[index] = d[index].linear_combination(d[index + 1], co1, co2)
    return d[0]

</t>
<t tx="ekr.20230509052845.580">  /// Remove the top-most object with a given identifier.
  void remove(const std::string &amp;name) {
    removeFromMap(name);
    for (auto &amp;s : stack) {
      auto i = std::find(s.begin(), s.end(), name);
      if (i != s.end()) {
        s.erase(i);
        return;
      }
    }
  }
</t>
<t tx="ekr.20230509052845.581">  /// Return a top-most object with a given identifier or nullptr if it does not exist.
  virtual Item find(const std::string &amp;name) const {
    auto it = map.find(name);
    return it != map.end() ? it-&gt;second.front() : nullptr;
  }
  /// Add a new block (i.e. adds a stack level).
  virtual void addBlock() { stack.push_front(std::list&lt;std::string&gt;()); }
  /// Remove the top-most block and all variables it holds.
  virtual void popBlock() {
    for (auto &amp;name : stack.front())
      removeFromMap(name);
    stack.pop_front();
  }

  /// The absolute path of a current module.
  std::string getFilename() const { return filename; }
  /// Sets the absolute path of a current module.
  void setFilename(std::string file) { filename = std::move(file); }

  /// Convenience functions to allow range-based for loops over a context.
  typename Map::iterator begin() { return map.begin(); }
  typename Map::iterator end() { return map.end(); }

  /// Pretty-prints the current context state.
  virtual void dump() {}

private:
</t>
<t tx="ekr.20230509052845.582">  /// Remove an identifier from the map only.
  void removeFromMap(const std::string &amp;name) {
    auto i = map.find(name);
    if (i == map.end())
      return;
    seqassertn(i-&gt;second.size(), "identifier {} not found in the map", name);
    i-&gt;second.pop_front();
    if (!i-&gt;second.size())
      map.erase(name);
  }

</t>
<t tx="ekr.20230509052845.583"></t>
<t tx="ekr.20230509052845.584">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

/**
 * WARNING: do not include anything else in this file, especially format.h
 * peglib.h uses this file. However, it is not compatible with format.h
 * (and possibly some other includes). Their inclusion will result in a succesful
 * compilation but extremely weird behaviour and hard-to-debug crashes (it seems that
 * some parts of peglib conflict with format.h in a weird way---further investigation
 * needed).
 */

namespace codon {
struct SrcInfo {
  std::string file;
  int line;
  int col;
  int len;
  int id; /// used to differentiate different instances

  SrcInfo(std::string file, int line, int col, int len)
      : file(std::move(file)), line(line), col(col), len(len), id(0) {
    static int nextId = 0;
    id = nextId++;
  };

  SrcInfo() : SrcInfo("", 0, 0, 0) {}

  bool operator==(const SrcInfo &amp;src) const { return id == src.id; }
};

} // namespace codon

namespace codon::exc {

/**
 * Parser error exception.
 * Used for parsing, transformation and type-checking errors.
 */
@others
} // namespace codon::exc
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.585">class ParserException : public std::runtime_error {
public:
  /// These vectors (stacks) store an error stack-trace.
  std::vector&lt;SrcInfo&gt; locations;
  std::vector&lt;std::string&gt; messages;
  int errorCode = -1;

public:
  ParserException(int errorCode, const std::string &amp;msg, const SrcInfo &amp;info) noexcept
      : std::runtime_error(msg), errorCode(errorCode) {
    messages.push_back(msg);
    locations.push_back(info);
  }
  ParserException() noexcept : std::runtime_error("") {}
  ParserException(int errorCode, const std::string &amp;msg) noexcept
      : ParserException(errorCode, msg, {}) {}
  explicit ParserException(const std::string &amp;msg) noexcept
      : ParserException(-1, msg, {}) {}
  ParserException(const ParserException &amp;e) noexcept
      : std::runtime_error(e), locations(e.locations), messages(e.messages),
        errorCode(e.errorCode){};

@others
};

</t>
<t tx="ekr.20230509052845.586">  /// Add an error message to the current stack trace
  void trackRealize(const std::string &amp;msg, const SrcInfo &amp;info) {
    locations.push_back(info);
    messages.push_back("during the realization of " + msg);
  }

</t>
<t tx="ekr.20230509052845.587">  /// Add an error message to the current stack trace
  void track(const std::string &amp;msg, const SrcInfo &amp;info) {
    locations.push_back(info);
    messages.push_back(msg);
  }
</t>
<t tx="ekr.20230509052845.588">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;variant&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types.h"
#include "codon/parser/common.h"

namespace codon::ast {

#define ACCEPT(X)                                                                      \
  ExprPtr clone() const override;                                                      \
  void accept(X &amp;visitor) override

// Forward declarations
struct ASTVisitor;
struct BinaryExpr;
struct CallExpr;
struct DotExpr;
struct EllipsisExpr;
struct IdExpr;
struct IfExpr;
struct IndexExpr;
struct IntExpr;
struct ListExpr;
struct NoneExpr;
struct StarExpr;
struct StmtExpr;
struct StringExpr;
struct TupleExpr;
struct UnaryExpr;
struct Stmt;

struct StaticValue {
  std::variant&lt;int64_t, std::string&gt; value;
  enum Type { NOT_STATIC = 0, STRING = 1, INT = 2, NOT_SUPPORTED = 3 } type;
  bool evaluated;

  explicit StaticValue(Type);
  // Static(bool);
  explicit StaticValue(int64_t);
  explicit StaticValue(std::string);
  bool operator==(const StaticValue &amp;s) const;
  std::string toString() const;
  int64_t getInt() const;
  std::string getString() const;
};

/**
 * A Seq AST expression.
 * Each AST expression is intended to be instantiated as a shared_ptr.
 */
struct Expr : public codon::SrcObject {
  using base_type = Expr;

  // private:
  /// Type of the expression. nullptr by default.
  types::TypePtr type;
  /// Flag that indicates if an expression describes a type (e.g. int or list[T]).
  /// Used by transformation and type-checking stages.
  bool isTypeExpr;
  /// Flag that indicates if an expression is a compile-time static expression.
  /// Such expression is of a form:
  ///   an integer (IntExpr) without any suffix that is within i64 range
  ///   a static generic
  ///   [-,not] a
  ///   a [+,-,*,//,%,and,or,==,!=,&lt;,&lt;=,&gt;,&gt;=] b
  ///     (note: and/or will NOT short-circuit)
  ///   a if cond else b
  ///     (note: cond is static, and is true if non-zero, false otherwise).
  ///     (note: both branches will be evaluated).
  StaticValue staticValue;
  /// Flag that indicates if all types in an expression are inferred (i.e. if a
  /// type-checking procedure was successful).
  bool done;

  /// Set of attributes.
  int attributes;

  /// Original (pre-transformation) expression
  std::shared_ptr&lt;Expr&gt; origExpr;

public:
  Expr();
  Expr(const Expr &amp;expr) = default;

  /// Convert a node to an S-expression.
  virtual std::string toString() const = 0;
  /// Validate a node. Throw ParseASTException if a node is not valid.
  void validate() const;
  /// Deep copy a node.
  virtual std::shared_ptr&lt;Expr&gt; clone() const = 0;
  /// Accept an AST visitor.
  virtual void accept(ASTVisitor &amp;visitor) = 0;

  /// Get a node type.
  /// @return Type pointer or a nullptr if a type is not set.
  types::TypePtr getType() const;
  /// Set a node type.
  void setType(types::TypePtr type);
  /// @return true if a node describes a type expression.
  bool isType() const;
  /// Marks a node as a type expression.
  void markType();
  /// True if a node is static expression.
  bool isStatic() const;

  /// Allow pretty-printing to C++ streams.
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Expr &amp;expr) {
    return out &lt;&lt; expr.toString();
  }

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual bool isId(const std::string &amp;val) const { return false; }
  virtual BinaryExpr *getBinary() { return nullptr; }
  virtual CallExpr *getCall() { return nullptr; }
  virtual DotExpr *getDot() { return nullptr; }
  virtual EllipsisExpr *getEllipsis() { return nullptr; }
  virtual IdExpr *getId() { return nullptr; }
  virtual IfExpr *getIf() { return nullptr; }
  virtual IndexExpr *getIndex() { return nullptr; }
  virtual IntExpr *getInt() { return nullptr; }
  virtual ListExpr *getList() { return nullptr; }
  virtual NoneExpr *getNone() { return nullptr; }
  virtual StarExpr *getStar() { return nullptr; }
  virtual StmtExpr *getStmtExpr() { return nullptr; }
  virtual StringExpr *getString() { return nullptr; }
  virtual TupleExpr *getTuple() { return nullptr; }
  virtual UnaryExpr *getUnary() { return nullptr; }

  /// Attribute helpers
  bool hasAttr(int attr) const;
  void setAttr(int attr);

  bool isDone() const { return done; }
  void setDone() { done = true; }

  /// @return Type name for IdExprs or instantiations.
  std::string getTypeName();

protected:
  /// Add a type to S-expression string.
  std::string wrapType(const std::string &amp;sexpr) const;
};
using ExprPtr = std::shared_ptr&lt;Expr&gt;;

/// Function signature parameter helper node (name: type = defaultValue).
struct Param : public codon::SrcObject {
  std::string name;
  ExprPtr type;
  ExprPtr defaultValue;
  enum {
    Normal,
    Generic,
    HiddenGeneric
  } status; // 1 for normal generic, 2 for hidden generic

  explicit Param(std::string name = "", ExprPtr type = nullptr,
                 ExprPtr defaultValue = nullptr, int generic = 0);
  explicit Param(const SrcInfo &amp;info, std::string name = "", ExprPtr type = nullptr,
                 ExprPtr defaultValue = nullptr, int generic = 0);

  std::string toString() const;
  Param clone() const;
};

/// None expression.
/// @li None
struct NoneExpr : public Expr {
  NoneExpr();
  NoneExpr(const NoneExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  NoneExpr *getNone() override { return this; }
};

/// Bool expression (value).
/// @li True
struct BoolExpr : public Expr {
  bool value;

  explicit BoolExpr(bool value);
  BoolExpr(const BoolExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Int expression (value.suffix).
/// @li 12
/// @li 13u
/// @li 000_010b
struct IntExpr : public Expr {
  /// Expression value is stored as a string that is parsed during the simplify stage.
  std::string value;
  /// Number suffix (e.g. "u" for "123u").
  std::string suffix;

  /// Parsed value and sign for "normal" 64-bit integers.
  std::unique_ptr&lt;int64_t&gt; intValue;

  explicit IntExpr(int64_t intValue);
  explicit IntExpr(const std::string &amp;value, std::string suffix = "");
  IntExpr(const IntExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IntExpr *getInt() override { return this; }
};

/// Float expression (value.suffix).
/// @li 12.1
/// @li 13.15z
/// @li e-12
struct FloatExpr : public Expr {
  /// Expression value is stored as a string that is parsed during the simplify stage.
  std::string value;
  /// Number suffix (e.g. "u" for "123u").
  std::string suffix;

  /// Parsed value for 64-bit floats.
  std::unique_ptr&lt;double&gt; floatValue;

  explicit FloatExpr(double floatValue);
  explicit FloatExpr(const std::string &amp;value, std::string suffix = "");
  FloatExpr(const FloatExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// String expression (prefix"value").
/// @li s'ACGT'
/// @li "fff"
struct StringExpr : public Expr {
  // Vector of {value, prefix} strings.
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; strings;

  explicit StringExpr(std::string value, std::string prefix = "");
  explicit StringExpr(std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; strings);
  StringExpr(const StringExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StringExpr *getString() override { return this; }
  std::string getValue() const;
};

/// Identifier expression (value).
struct IdExpr : public Expr {
  std::string value;

  explicit IdExpr(std::string value);
  IdExpr(const IdExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  bool isId(const std::string &amp;val) const override { return this-&gt;value == val; }
  IdExpr *getId() override { return this; }
};

/// Star (unpacking) expression (*what).
/// @li *args
struct StarExpr : public Expr {
  ExprPtr what;

  explicit StarExpr(ExprPtr what);
  StarExpr(const StarExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StarExpr *getStar() override { return this; }
};

/// KeywordStar (unpacking) expression (**what).
/// @li **kwargs
struct KeywordStarExpr : public Expr {
  ExprPtr what;

  explicit KeywordStarExpr(ExprPtr what);
  KeywordStarExpr(const KeywordStarExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Tuple expression ((items...)).
/// @li (1, a)
struct TupleExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit TupleExpr(std::vector&lt;ExprPtr&gt; items = {});
  TupleExpr(const TupleExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  TupleExpr *getTuple() override { return this; }
};

/// List expression ([items...]).
/// @li [1, 2]
struct ListExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit ListExpr(std::vector&lt;ExprPtr&gt; items);
  ListExpr(const ListExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  ListExpr *getList() override { return this; }
};

/// Set expression ({items...}).
/// @li {1, 2}
struct SetExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit SetExpr(std::vector&lt;ExprPtr&gt; items);
  SetExpr(const SetExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Dictionary expression ({(key: value)...}).
/// Each (key, value) pair is stored as a TupleExpr.
/// @li {'s': 1, 't': 2}
struct DictExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit DictExpr(std::vector&lt;ExprPtr&gt; items);
  DictExpr(const DictExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Generator body node helper [for vars in gen (if conds)...].
/// @li for i in lst if a if b
struct GeneratorBody {
  ExprPtr vars;
  ExprPtr gen;
  std::vector&lt;ExprPtr&gt; conds;

  GeneratorBody clone() const;
};

/// Generator or comprehension expression [(expr (loops...))].
/// @li [i for i in j]
/// @li (f + 1 for j in k if j for f in j)
struct GeneratorExpr : public Expr {
  /// Generator kind: normal generator, list comprehension, set comprehension.
  enum GeneratorKind { Generator, ListGenerator, SetGenerator };

  GeneratorKind kind;
  ExprPtr expr;
  std::vector&lt;GeneratorBody&gt; loops;

  GeneratorExpr(GeneratorKind kind, ExprPtr expr, std::vector&lt;GeneratorBody&gt; loops);
  GeneratorExpr(const GeneratorExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Dictionary comprehension expression [{key: expr (loops...)}].
/// @li {i: j for i, j in z.items()}
struct DictGeneratorExpr : public Expr {
  ExprPtr key, expr;
  std::vector&lt;GeneratorBody&gt; loops;

  DictGeneratorExpr(ExprPtr key, ExprPtr expr, std::vector&lt;GeneratorBody&gt; loops);
  DictGeneratorExpr(const DictGeneratorExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Conditional expression [cond if ifexpr else elsexpr].
/// @li 1 if a else 2
struct IfExpr : public Expr {
  ExprPtr cond, ifexpr, elsexpr;

  IfExpr(ExprPtr cond, ExprPtr ifexpr, ExprPtr elsexpr);
  IfExpr(const IfExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IfExpr *getIf() override { return this; }
};

/// Unary expression [op expr].
/// @li -56
struct UnaryExpr : public Expr {
  std::string op;
  ExprPtr expr;

  UnaryExpr(std::string op, ExprPtr expr);
  UnaryExpr(const UnaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  UnaryExpr *getUnary() override { return this; }
};

/// Binary expression [lexpr op rexpr].
/// @li 1 + 2
/// @li 3 or 4
struct BinaryExpr : public Expr {
  std::string op;
  ExprPtr lexpr, rexpr;

  /// True if an expression modifies lhs in-place (e.g. a += b).
  bool inPlace;

  BinaryExpr(ExprPtr lexpr, std::string op, ExprPtr rexpr, bool inPlace = false);
  BinaryExpr(const BinaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  BinaryExpr *getBinary() override { return this; }
};

/// Chained binary expression.
/// @li 1 &lt;= x &lt;= 2
struct ChainBinaryExpr : public Expr {
  std::vector&lt;std::pair&lt;std::string, ExprPtr&gt;&gt; exprs;

  ChainBinaryExpr(std::vector&lt;std::pair&lt;std::string, ExprPtr&gt;&gt; exprs);
  ChainBinaryExpr(const ChainBinaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Pipe expression [(op expr)...].
/// op is either "" (only the first item), "|&gt;" or "||&gt;".
/// @li a |&gt; b ||&gt; c
struct PipeExpr : public Expr {
  struct Pipe {
    std::string op;
    ExprPtr expr;

    Pipe clone() const;
  };

  std::vector&lt;Pipe&gt; items;
  /// Output type of a "prefix" pipe ending at the index position.
  /// Example: for a |&gt; b |&gt; c, inTypes[1] is typeof(a |&gt; b).
  std::vector&lt;types::TypePtr&gt; inTypes;

  explicit PipeExpr(std::vector&lt;Pipe&gt; items);
  PipeExpr(const PipeExpr &amp;expr);

  std::string toString() const override;
  void validate() const;
  ACCEPT(ASTVisitor);
};

/// Index expression (expr[index]).
/// @li a[5]
struct IndexExpr : public Expr {
  ExprPtr expr, index;

  IndexExpr(ExprPtr expr, ExprPtr index);
  IndexExpr(const IndexExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IndexExpr *getIndex() override { return this; }
};

/// Call expression (expr((name=value)...)).
/// @li a(1, b=2)
struct CallExpr : public Expr {
  /// Each argument can have a name (e.g. foo(1, b=5))
  struct Arg : public codon::SrcObject {
    std::string name;
    ExprPtr value;

    Arg clone() const;

    Arg(const SrcInfo &amp;info, const std::string &amp;name, ExprPtr value);
    Arg(const std::string &amp;name, ExprPtr value);
    Arg(ExprPtr value);
  };

  ExprPtr expr;
  std::vector&lt;Arg&gt; args;
  /// True if type-checker has processed and re-ordered args.
  bool ordered;

  CallExpr(ExprPtr expr, std::vector&lt;Arg&gt; args = {});
  /// Convenience constructors
  CallExpr(ExprPtr expr, std::vector&lt;ExprPtr&gt; args);
  template &lt;typename... Ts&gt;
  CallExpr(ExprPtr expr, ExprPtr arg, Ts... args)
      : CallExpr(expr, std::vector&lt;ExprPtr&gt;{arg, args...}) {}
  CallExpr(const CallExpr &amp;expr);

  void validate() const;
  std::string toString() const override;
  ACCEPT(ASTVisitor);

  CallExpr *getCall() override { return this; }
};

/// Dot (access) expression (expr.member).
/// @li a.b
struct DotExpr : public Expr {
  ExprPtr expr;
  std::string member;

  DotExpr(ExprPtr expr, std::string member);
  /// Convenience constructor.
  DotExpr(const std::string &amp;left, std::string member);
  DotExpr(const DotExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  DotExpr *getDot() override { return this; }
};

/// Slice expression (st:stop:step).
/// @li 1:10:3
/// @li s::-1
/// @li :::
struct SliceExpr : public Expr {
  /// Any of these can be nullptr to account for partial slices.
  ExprPtr start, stop, step;

  SliceExpr(ExprPtr start, ExprPtr stop, ExprPtr step);
  SliceExpr(const SliceExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Ellipsis expression.
/// @li ...
struct EllipsisExpr : public Expr {
  /// True if this is a target partial argument within a PipeExpr.
  /// If true, this node will be handled differently during the type-checking stage.
  bool isPipeArg;

  explicit EllipsisExpr(bool isPipeArg = false);
  EllipsisExpr(const EllipsisExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  EllipsisExpr *getEllipsis() override { return this; }
};

/// Lambda expression (lambda (vars)...: expr).
/// @li lambda a, b: a + b
struct LambdaExpr : public Expr {
  std::vector&lt;std::string&gt; vars;
  ExprPtr expr;

  LambdaExpr(std::vector&lt;std::string&gt; vars, ExprPtr expr);
  LambdaExpr(const LambdaExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Yield (send to generator) expression.
/// @li (yield)
struct YieldExpr : public Expr {
  YieldExpr();
  YieldExpr(const YieldExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Assignment (walrus) expression (var := expr).
/// @li a := 5 + 3
struct AssignExpr : public Expr {
  ExprPtr var, expr;

  AssignExpr(ExprPtr var, ExprPtr expr);
  AssignExpr(const AssignExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Range expression (start ... end).
/// Used only in match-case statements.
/// @li 1 ... 2
struct RangeExpr : public Expr {
  ExprPtr start, stop;

  RangeExpr(ExprPtr start, ExprPtr stop);
  RangeExpr(const RangeExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// The following nodes are created after the simplify stage.

/// Statement expression (stmts...; expr).
/// Statements are evaluated only if the expression is evaluated
/// (to support short-circuiting).
/// @li (a = 1; b = 2; a + b)
struct StmtExpr : public Expr {
  std::vector&lt;std::shared_ptr&lt;Stmt&gt;&gt; stmts;
  ExprPtr expr;

  StmtExpr(std::vector&lt;std::shared_ptr&lt;Stmt&gt;&gt; stmts, ExprPtr expr);
  StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, ExprPtr expr);
  StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, std::shared_ptr&lt;Stmt&gt; stmt2, ExprPtr expr);
  StmtExpr(const StmtExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StmtExpr *getStmtExpr() override { return this; }
};

/// Static tuple indexing expression (expr[index]).
/// @li (1, 2, 3)[2]
struct InstantiateExpr : Expr {
  ExprPtr typeExpr;
  std::vector&lt;ExprPtr&gt; typeParams;

  InstantiateExpr(ExprPtr typeExpr, std::vector&lt;ExprPtr&gt; typeParams);
  /// Convenience constructor for a single type parameter.
  InstantiateExpr(ExprPtr typeExpr, ExprPtr typeParam);
  InstantiateExpr(const InstantiateExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

#undef ACCEPT

enum ExprAttr {
  SequenceItem,
  StarSequenceItem,
  List,
  Set,
  Dict,
  Partial,
  Dominated,
  StarArgument,
  KwStarArgument,
  OrderedCall,
  ExternVar,
  __LAST__
};

StaticValue::Type getStaticGeneric(Expr *e);

} // namespace codon::ast

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.589">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::Expr, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509052845.59">def GetIndex(self, u):
    dom = self.GetDomain()
    for ii in range(self.degree - 1, len(self.knots) - self.degree):
        if u &gt;= self.knots[ii] and u &lt; self.knots[ii + 1]:
            I = ii
            break
    else:
        I = dom[1] - 1
    return I

</t>
<t tx="ekr.20230509052845.590">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::CallExpr::Arg&gt; : fmt::formatter&lt;std::string_view&gt; {
@others
};

</t>
<t tx="ekr.20230509052845.591">template &lt;typename FormatContext&gt;
auto format(const codon::ast::CallExpr::Arg &amp;p, FormatContext &amp;ctx) const
  -&gt; decltype(ctx.out()) {
return fmt::format_to(ctx.out(), "({}{})",
                      p.name.empty() ? "" : fmt::format("{} = ", p.name), p.value);
}
</t>
<t tx="ekr.20230509052845.592">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::Param&gt; : fmt::formatter&lt;std::string_view&gt; {
  template &lt;typename FormatContext&gt;
  auto format(const codon::ast::Param &amp;p, FormatContext &amp;ctx) const
      -&gt; decltype(ctx.out()) {
    return fmt::format_to(ctx.out(), "{}", p.toString());
  }
};

</t>
<t tx="ekr.20230509052845.593">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;
           std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::Expr&gt;&gt;::value, char&gt;&gt;
    : fmt::formatter&lt;std::string_view&gt; {
  @others
};
</t>
<t tx="ekr.20230509052845.594">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;toString() : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509052845.595">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/expr.h"
#include "codon/parser/ast/types.h"
#include "codon/parser/common.h"

namespace codon::ast {

#define ACCEPT(X)                                                                      \
  using Stmt::toString;                                                                \
  StmtPtr clone() const override;                                                      \
  void accept(X &amp;visitor) override

// Forward declarations
struct ASTVisitor;
struct AssignStmt;
struct ClassStmt;
struct ExprStmt;
struct SuiteStmt;
struct FunctionStmt;

/**
 * A Seq AST statement.
 * Each AST statement is intended to be instantiated as a shared_ptr.
 */
struct Stmt : public codon::SrcObject {
  using base_type = Stmt;

  /// Flag that indicates if all types in a statement are inferred (i.e. if a
  /// type-checking procedure was successful).
  bool done;
  /// Statement age.
  int age;

public:
  Stmt();
  Stmt(const Stmt &amp;s) = default;
  explicit Stmt(const codon::SrcInfo &amp;s);

  /// Convert a node to an S-expression.
  std::string toString() const;
  virtual std::string toString(int indent) const = 0;
  /// Validate a node. Throw ParseASTException if a node is not valid.
  void validate() const;
  /// Deep copy a node.
  virtual std::shared_ptr&lt;Stmt&gt; clone() const = 0;
  /// Accept an AST visitor.
  virtual void accept(ASTVisitor &amp;) = 0;

  /// Allow pretty-printing to C++ streams.
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Stmt &amp;stmt) {
    return out &lt;&lt; stmt.toString();
  }

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual AssignStmt *getAssign() { return nullptr; }
  virtual ClassStmt *getClass() { return nullptr; }
  virtual ExprStmt *getExpr() { return nullptr; }
  virtual SuiteStmt *getSuite() { return nullptr; }
  virtual FunctionStmt *getFunction() { return nullptr; }

  /// @return the first statement in a suite; if a statement is not a suite, returns the
  /// statement itself
  virtual Stmt *firstInBlock() { return this; }

  bool isDone() const { return done; }
  void setDone() { done = true; }
};
using StmtPtr = std::shared_ptr&lt;Stmt&gt;;

/// Suite (block of statements) statement (stmt...).
/// @li a = 5; foo(1)
struct SuiteStmt : public Stmt {
  using Stmt::Stmt;

  std::vector&lt;StmtPtr&gt; stmts;

  /// These constructors flattens the provided statement vector (see flatten() below).
  explicit SuiteStmt(std::vector&lt;StmtPtr&gt; stmts = {});
@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.596">  /// Convenience constructor
  template &lt;typename... Ts&gt;
  SuiteStmt(StmtPtr stmt, Ts... stmts) : stmts({stmt, stmts...}) {}
  SuiteStmt(const SuiteStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  SuiteStmt *getSuite() override { return this; }
  Stmt *firstInBlock() override {
    return stmts.empty() ? nullptr : stmts[0]-&gt;firstInBlock();
  }
</t>
<t tx="ekr.20230509052845.597">  StmtPtr *lastInBlock();

  /// Flatten all nested SuiteStmt objects that do not own a block in the statement
  /// vector. This is shallow flattening.
  static void flatten(const StmtPtr &amp;s, std::vector&lt;StmtPtr&gt; &amp;stmts);
};

/// Break statement.
/// @li break
struct BreakStmt : public Stmt {
  BreakStmt() = default;
  BreakStmt(const BreakStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Continue statement.
/// @li continue
struct ContinueStmt : public Stmt {
  ContinueStmt() = default;
  ContinueStmt(const ContinueStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Expression statement (expr).
/// @li 3 + foo()
struct ExprStmt : public Stmt {
  ExprPtr expr;

  explicit ExprStmt(ExprPtr expr);
  ExprStmt(const ExprStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  ExprStmt *getExpr() override { return this; }
};

/// Assignment statement (lhs: type = rhs).
/// @li a = 5
/// @li a: Optional[int] = 5
/// @li a, b, c = 5, *z
struct AssignStmt : public Stmt {
  ExprPtr lhs, rhs, type;

  AssignStmt(ExprPtr lhs, ExprPtr rhs, ExprPtr type = nullptr);
  AssignStmt(const AssignStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  AssignStmt *getAssign() override { return this; }

  bool isUpdate() const { return update != Assign; }
  bool isAtomicUpdate() const { return update == UpdateAtomic; }
  void setUpdate() { update = Update; }
  void setAtomicUpdate() { update = UpdateAtomic; }

private:
  enum { Assign, Update, UpdateAtomic } update;
};

/// Deletion statement (del expr).
/// @li del a
/// @li del a[5]
struct DelStmt : public Stmt {
  ExprPtr expr;

  explicit DelStmt(ExprPtr expr);
  DelStmt(const DelStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Print statement (print expr).
/// @li print a, b
struct PrintStmt : public Stmt {
  std::vector&lt;ExprPtr&gt; items;
  /// True if there is a dangling comma after print: print a,
  bool isInline;

  explicit PrintStmt(std::vector&lt;ExprPtr&gt; items, bool isInline);
  PrintStmt(const PrintStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Return statement (return expr).
/// @li return
/// @li return a
struct ReturnStmt : public Stmt {
  /// nullptr if this is an empty return/yield statements.
  ExprPtr expr;

  explicit ReturnStmt(ExprPtr expr = nullptr);
  ReturnStmt(const ReturnStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Yield statement (yield expr).
/// @li yield
/// @li yield a
struct YieldStmt : public Stmt {
  /// nullptr if this is an empty return/yield statements.
  ExprPtr expr;

  explicit YieldStmt(ExprPtr expr = nullptr);
  YieldStmt(const YieldStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Assert statement (assert expr).
/// @li assert a
/// @li assert a, "Message"
struct AssertStmt : public Stmt {
  ExprPtr expr;
  /// nullptr if there is no message.
  ExprPtr message;

  explicit AssertStmt(ExprPtr expr, ExprPtr message = nullptr);
  AssertStmt(const AssertStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// While loop statement (while cond: suite; else: elseSuite).
/// @li while True: print
/// @li while True: break
///          else: print
struct WhileStmt : public Stmt {
  ExprPtr cond;
  StmtPtr suite;
  /// nullptr if there is no else suite.
  StmtPtr elseSuite;
  /// Set if a while loop is used to emulate goto statement
  /// (as `while gotoVar: ...`).
  std::string gotoVar = "";

  WhileStmt(ExprPtr cond, StmtPtr suite, StmtPtr elseSuite = nullptr);
  WhileStmt(const WhileStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// For loop statement (for var in iter: suite; else elseSuite).
/// @li for a, b in c: print
/// @li for i in j: break
///          else: print
struct ForStmt : public Stmt {
  ExprPtr var;
  ExprPtr iter;
  StmtPtr suite;
  StmtPtr elseSuite;
  ExprPtr decorator;
  std::vector&lt;CallExpr::Arg&gt; ompArgs;

  /// Indicates if iter was wrapped with __iter__() call.
  bool wrapped;

  ForStmt(ExprPtr var, ExprPtr iter, StmtPtr suite, StmtPtr elseSuite = nullptr,
          ExprPtr decorator = nullptr, std::vector&lt;CallExpr::Arg&gt; ompArgs = {});
  ForStmt(const ForStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// If block statement (if cond: suite; (elif cond: suite)...).
/// @li if a: foo()
/// @li if a: foo()
///          elif b: bar()
/// @li if a: foo()
///          elif b: bar()
///          else: baz()
struct IfStmt : public Stmt {
  ExprPtr cond;
  /// elseSuite can be nullptr (if no else is found).
  StmtPtr ifSuite, elseSuite;

  IfStmt(ExprPtr cond, StmtPtr ifSuite, StmtPtr elseSuite = nullptr);
  IfStmt(const IfStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Match statement (match what: (case pattern: case)...).
/// @li match a:
///          case 1: print
///          case _: pass
struct MatchStmt : public Stmt {
  struct MatchCase {
    ExprPtr pattern;
    ExprPtr guard;
    StmtPtr suite;

    MatchCase clone() const;
  };
  ExprPtr what;
  std::vector&lt;MatchCase&gt; cases;

  MatchStmt(ExprPtr what, std::vector&lt;MatchCase&gt; cases);
  MatchStmt(const MatchStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Import statement.
/// This node describes various kinds of import statements:
///  - from from import what (as as)
///  - import what (as as)
///  - from c import what(args...) (-&gt; ret) (as as)
///  - from .(dots...)from import what (as as)
/// @li import a
/// @li from b import a
/// @li from ...b import a as ai
/// @li from c import foo(int) -&gt; int as bar
/// @li from python.numpy import array
/// @li from python import numpy.array(int) -&gt; int as na
struct ImportStmt : public Stmt {
  ExprPtr from, what;
  std::string as;
  /// Number of dots in a relative import (e.g. dots is 3 for "from ...foo").
  size_t dots;
  /// Function argument types for C imports.
  std::vector&lt;Param&gt; args;
  /// Function return type for C imports.
  ExprPtr ret;
  /// Set if this is a function C import (not variable import)
  bool isFunction;

  ImportStmt(ExprPtr from, ExprPtr what, std::vector&lt;Param&gt; args = {},
             ExprPtr ret = nullptr, std::string as = "", size_t dots = 0,
             bool isFunction = true);
  ImportStmt(const ImportStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);
};

/// Try-catch statement (try: suite; (catch var (as exc): suite)...; finally: finally).
/// @li: try: a
///           catch e: pass
///           catch e as Exc: pass
///           catch: pass
///           finally: print
struct TryStmt : public Stmt {
  struct Catch {
    /// empty string if a catch is unnamed.
    std::string var;
    /// nullptr if there is no explicit exception type.
    ExprPtr exc;
    StmtPtr suite;

    Catch clone() const;
  };

  StmtPtr suite;
  std::vector&lt;Catch&gt; catches;
  /// nullptr if there is no finally block.
  StmtPtr finally;

  TryStmt(StmtPtr suite, std::vector&lt;Catch&gt; catches, StmtPtr finally = nullptr);
  TryStmt(const TryStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Throw statement (raise expr).
/// @li: raise a
struct ThrowStmt : public Stmt {
  ExprPtr expr;
  // True if a statement was transformed during type-checking stage
  // (to avoid setting up ExcHeader multiple times).
  bool transformed;

  explicit ThrowStmt(ExprPtr expr, bool transformed = false);
  ThrowStmt(const ThrowStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Global variable statement (global var).
/// @li: global a
struct GlobalStmt : public Stmt {
  std::string var;
  bool nonLocal;

  explicit GlobalStmt(std::string var, bool nonLocal = false);
  GlobalStmt(const GlobalStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

struct Attr {
  // Toplevel attributes
  const static std::string LLVM;
  const static std::string Python;
  const static std::string Atomic;
  const static std::string Property;
  const static std::string StaticMethod;
  const static std::string Attribute;
  const static std::string C;
  // Internal attributes
  const static std::string Internal;
  const static std::string HiddenFromUser;
  const static std::string ForceRealize;
  const static std::string RealizeWithoutSelf; // not internal
  // Compiler-generated attributes
  const static std::string CVarArg;
  const static std::string Method;
  const static std::string Capture;
  const static std::string HasSelf;
  // Class attributes
  const static std::string Extend;
  const static std::string Tuple;
  // Standard library attributes
  const static std::string Test;
  const static std::string Overload;
  const static std::string Export;
  // Function module
  std::string module;
  // Parent class (set for methods only)
  std::string parentClass;
  // True if a function is decorated with __attribute__
  bool isAttribute;

  std::set&lt;std::string&gt; magics;

  // Set of attributes
  std::set&lt;std::string&gt; customAttr;

  explicit Attr(const std::vector&lt;std::string&gt; &amp;attrs = std::vector&lt;std::string&gt;());
  void set(const std::string &amp;attr);
  void unset(const std::string &amp;attr);
  bool has(const std::string &amp;attr) const;
};

/// Function statement (@(attributes...) def name[funcs...](args...) -&gt; ret: suite).
/// @li: @decorator
///           def foo[T=int, U: int](a, b: int = 0) -&gt; list[T]: pass
struct FunctionStmt : public Stmt {
  std::string name;
  /// nullptr if return type is not specified.
  ExprPtr ret;
  std::vector&lt;Param&gt; args;
  StmtPtr suite;
  Attr attributes;
  std::vector&lt;ExprPtr&gt; decorators;

  FunctionStmt(std::string name, ExprPtr ret, std::vector&lt;Param&gt; args, StmtPtr suite,
               Attr attributes = Attr(), std::vector&lt;ExprPtr&gt; decorators = {});
  FunctionStmt(const FunctionStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);

  /// @return a function signature that consists of generics and arguments in a
  /// S-expression form.
  /// @li (T U (int 0))
  std::string signature() const;
  bool hasAttr(const std::string &amp;attr) const;
  void parseDecorators();

  size_t getStarArgs() const;
  size_t getKwStarArgs() const;

  FunctionStmt *getFunction() override { return this; }
  std::string getDocstr();
  std::unordered_set&lt;std::string&gt; getNonInferrableGenerics();
};

/// Class statement (@(attributes...) class name[generics...]: args... ; suite).
/// @li: @type
///           class F[T]:
///              m: T
///              def __new__() -&gt; F[T]: ...
struct ClassStmt : public Stmt {
  std::string name;
  std::vector&lt;Param&gt; args;
  StmtPtr suite;
  Attr attributes;
  std::vector&lt;ExprPtr&gt; decorators;
  std::vector&lt;ExprPtr&gt; baseClasses;
  std::vector&lt;ExprPtr&gt; staticBaseClasses;

  ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite,
            std::vector&lt;ExprPtr&gt; decorators = {}, std::vector&lt;ExprPtr&gt; baseClasses = {},
            std::vector&lt;ExprPtr&gt; staticBaseClasses = {});
  ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite, Attr attr);
  ClassStmt(const ClassStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);

  /// @return true if a class is a tuple-like record (e.g. has a "@tuple" attribute)
  bool isRecord() const;
  bool hasAttr(const std::string &amp;attr) const;

  ClassStmt *getClass() override { return this; }

  void parseDecorators();
  static bool isClassVar(const Param &amp;p);
  std::string getDocstr();
};

/// Yield-from statement (yield from expr).
/// @li: yield from it
struct YieldFromStmt : public Stmt {
  ExprPtr expr;

  explicit YieldFromStmt(ExprPtr expr);
  YieldFromStmt(const YieldFromStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// With statement (with (item as var)...: suite).
/// @li: with foo(), bar() as b: pass
struct WithStmt : public Stmt {
  std::vector&lt;ExprPtr&gt; items;
  /// empty string if a corresponding item is unnamed
  std::vector&lt;std::string&gt; vars;
  StmtPtr suite;

  WithStmt(std::vector&lt;ExprPtr&gt; items, std::vector&lt;std::string&gt; vars, StmtPtr suite);
  WithStmt(std::vector&lt;std::pair&lt;ExprPtr, ExprPtr&gt;&gt; items, StmtPtr suite);
  WithStmt(const WithStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Custom block statement (foo: ...).
/// @li: pt_tree: pass
struct CustomStmt : public Stmt {
  std::string keyword;
  ExprPtr expr;
  StmtPtr suite;

  CustomStmt(std::string keyword, ExprPtr expr, StmtPtr suite);
  CustomStmt(const CustomStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// The following nodes are created after the simplify stage.

/// Member assignment statement (lhs.member = rhs).
/// @li: a.x = b
struct AssignMemberStmt : public Stmt {
  ExprPtr lhs;
  std::string member;
  ExprPtr rhs;

  AssignMemberStmt(ExprPtr lhs, std::string member, ExprPtr rhs);
  AssignMemberStmt(const AssignMemberStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Comment statement (# comment).
/// Currently used only for pretty-printing.
struct CommentStmt : public Stmt {
  std::string comment;

  explicit CommentStmt(std::string comment);
  CommentStmt(const CommentStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

#undef ACCEPT

} // namespace codon::ast

</t>
<t tx="ekr.20230509052845.598">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::Stmt, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509052845.599">template &lt;typename T&gt;
struct fmt::formatter&lt;
  T, std::enable_if_t&lt;
         std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::Stmt&gt;&gt;::value, char&gt;&gt;
  : fmt::formatter&lt;std::string_view&gt; {
@others
};
</t>
<t tx="ekr.20230509052845.6">def make_tree(d):
    return Node(make_tree(d - 1), make_tree(d - 1)) if d &gt; 0 else Node()

</t>
<t tx="ekr.20230509052845.60">def __len__(self):
    return len(self.points)

</t>
<t tx="ekr.20230509052845.600">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
return fmt::format_to(ctx.out(), "{}", p ? p-&gt;toString() : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509052845.601">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/parser/ast/types/class.h"
#include "codon/parser/ast/types/function.h"
#include "codon/parser/ast/types/link.h"
#include "codon/parser/ast/types/static.h"
#include "codon/parser/ast/types/traits.h"
#include "codon/parser/ast/types/type.h"
#include "codon/parser/ast/types/union.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.602"></t>
<t tx="ekr.20230509052845.603">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

/**
 * A generic class reference type. All Seq types inherit from this class.
 */
struct ClassType : public Type {
  /**
   * A generic type declaration.
   * Each generic is defined by its unique ID.
   */
  struct Generic {
    // Generic name.
    std::string name;
    // Name used for pretty-printing.
    std::string niceName;
    // Unique generic ID.
    int id;
    // Pointer to realized type (or generic LinkType).
    TypePtr type;

    Generic(std::string name, std::string niceName, TypePtr type, int id)
        : name(std::move(name)), niceName(std::move(niceName)), id(id),
          type(std::move(type)) {}
  };

  /// Canonical type name.
  std::string name;
  /// Name used for pretty-printing.
  std::string niceName;
  /// List of generics, if present.
  std::vector&lt;Generic&gt; generics;

  std::vector&lt;Generic&gt; hiddenGenerics;

  std::string _rn;

  explicit ClassType(Cache *cache, std::string name, std::string niceName,
                     std::vector&lt;Generic&gt; generics = {},
                     std::vector&lt;Generic&gt; hiddenGenerics = {});
  explicit ClassType(const std::shared_ptr&lt;ClassType&gt; &amp;base);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;
  /// Convenience function to get the name of realized type
  /// (needed if a subclass realizes something else as well).
  virtual std::string realizedTypeName() const;
  std::shared_ptr&lt;ClassType&gt; getClass() override {
    return std::static_pointer_cast&lt;ClassType&gt;(shared_from_this());
  }
};
using ClassTypePtr = std::shared_ptr&lt;ClassType&gt;;

/**
 * A generic class tuple (record) type. All Seq tuples inherit from this class.
 */
struct RecordType : public ClassType {
  /// List of tuple arguments.
  std::vector&lt;TypePtr&gt; args;
  bool noTuple;

  explicit RecordType(
      Cache *cache, std::string name, std::string niceName,
      std::vector&lt;ClassType::Generic&gt; generics = std::vector&lt;ClassType::Generic&gt;(),
      std::vector&lt;TypePtr&gt; args = std::vector&lt;TypePtr&gt;(), bool noTuple = false);
  RecordType(const ClassTypePtr &amp;base, std::vector&lt;TypePtr&gt; args, bool noTuple = false);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;

  std::shared_ptr&lt;RecordType&gt; getRecord() override {
    return std::static_pointer_cast&lt;RecordType&gt;(shared_from_this());
  }
  std::shared_ptr&lt;RecordType&gt; getHeterogenousTuple() override;
};

} // namespace codon::ast::types

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.604">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::types::ClassType::Generic&gt;
    : fmt::formatter&lt;std::string_view&gt; {
  @others
};
</t>
<t tx="ekr.20230509052845.605">template &lt;typename FormatContext&gt;
auto format(const codon::ast::types::ClassType::Generic &amp;p, FormatContext &amp;ctx) const
    -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "({}{})",
                        p.name.empty() ? "" : fmt::format("{} = ", p.name), p.type);
}
</t>
<t tx="ekr.20230509052845.606">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"
#include "codon/parser/ast/types/type.h"

namespace codon::ast {
struct FunctionStmt;
}

namespace codon::ast::types {

/**
 * A generic type that represents a Seq function instantiation.
 * It inherits RecordType that realizes Callable[...].
 *
 *  This is not a function pointer (Function[...]) type.
 */
struct FuncType : public RecordType {
  /// Canonical AST node.
  FunctionStmt *ast;
  /// Function generics (e.g. T in def foo[T](...)).
  std::vector&lt;ClassType::Generic&gt; funcGenerics;
  /// Enclosing class or a function.
  TypePtr funcParent;

public:
  FuncType(
      const std::shared_ptr&lt;RecordType&gt; &amp;baseType, FunctionStmt *ast,
      std::vector&lt;ClassType::Generic&gt; funcGenerics = std::vector&lt;ClassType::Generic&gt;(),
      TypePtr funcParent = nullptr);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  std::shared_ptr&lt;FuncType&gt; getFunc() override {
    return std::static_pointer_cast&lt;FuncType&gt;(shared_from_this());
  }

  std::vector&lt;TypePtr&gt; &amp;getArgTypes() const {
    return generics[0].type-&gt;getRecord()-&gt;args;
  }
  TypePtr getRetType() const { return generics[1].type; }
};
using FuncTypePtr = std::shared_ptr&lt;FuncType&gt;;

/**
 * A generic type that represents a partial Seq function instantiation.
 * It inherits RecordType that realizes Tuple[...].
 *
 * Note: partials only work on Seq functions. Function pointer partials
 *       will become a partials of Function.__call__ Seq function.
 */
struct PartialType : public RecordType {
  /// Seq function that is being partialized. Always generic (not instantiated).
  FuncTypePtr func;
  /// Arguments that are already provided (1 for known argument, 0 for expecting).
  std::vector&lt;char&gt; known;

public:
  PartialType(const std::shared_ptr&lt;RecordType&gt; &amp;baseType,
              std::shared_ptr&lt;FuncType&gt; func, std::vector&lt;char&gt; known);

public:
  int unify(Type *typ, Unification *us) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

  std::string debugString(char mode) const override;
  std::string realizedName() const override;

public:
  std::shared_ptr&lt;PartialType&gt; getPartial() override {
    return std::static_pointer_cast&lt;PartialType&gt;(shared_from_this());
  }
};
using PartialTypePtr = std::shared_ptr&lt;PartialType&gt;;

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.607">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/traits.h"
#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

struct LinkType : public Type {
  /// Enumeration describing the current state.
  enum Kind { Unbound, Generic, Link } kind;
  /// The unique identifier of an unbound or generic type.
  int id;
  /// The type-checking level of an unbound type.
  int level;
  /// The type to which LinkType points to. nullptr if unknown (unbound or generic).
  TypePtr type;
  /// &gt;0 if a type is a static type (e.g. N in Int[N: int]); 0 otherwise.
  char isStatic;
  /// Optional trait that unbound type requires prior to unification.
  std::shared_ptr&lt;Trait&gt; trait;
  /// The generic name of a generic type, if applicable. Used for pretty-printing.
  std::string genericName;
  /// Type that will be used if an unbound is not resolved.
  TypePtr defaultType;

public:
  LinkType(Cache *cache, Kind kind, int id, int level = 0, TypePtr type = nullptr,
           char isStatic = 0, std::shared_ptr&lt;Trait&gt; trait = nullptr,
           TypePtr defaultType = nullptr, std::string genericName = "");
  /// Convenience constructor for linked types.
  explicit LinkType(TypePtr type);

public:
  int unify(Type *typ, Unification *undodo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  TypePtr follow() override;
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  std::shared_ptr&lt;LinkType&gt; getLink() override;
  std::shared_ptr&lt;FuncType&gt; getFunc() override;
  std::shared_ptr&lt;PartialType&gt; getPartial() override;
  std::shared_ptr&lt;ClassType&gt; getClass() override;
  std::shared_ptr&lt;RecordType&gt; getRecord() override;
  std::shared_ptr&lt;StaticType&gt; getStatic() override;
  std::shared_ptr&lt;UnionType&gt; getUnion() override;
  std::shared_ptr&lt;LinkType&gt; getUnbound() override;

private:
  /// Checks if a current (unbound) type occurs within a given type.
  /// Needed to prevent a recursive unification (e.g. ?1 with list[?1]).
  bool occurs(Type *typ, Type::Unification *undo);
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.608">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"

namespace codon::ast {
struct StaticValue;
}

namespace codon::ast::types {

/**
 * A static integer type (e.g. N in def foo[N: int]). Usually an integer, but can point
 * to a static expression.
 */
struct StaticType : public Type {
  /// List of static variables that a type depends on
  /// (e.g. for A+B+2, generics are {A, B}).
  std::vector&lt;ClassType::Generic&gt; generics;
  /// A static expression that needs to be evaluated.
  /// Can be nullptr if there is no expression.
  std::shared_ptr&lt;Expr&gt; expr;

  StaticType(Cache *cache, std::vector&lt;ClassType::Generic&gt; generics,
             const std::shared_ptr&lt;Expr&gt; &amp;expr);
  /// Convenience function that parses expr and populates static type generics.
  StaticType(Cache *cache, const std::shared_ptr&lt;Expr&gt; &amp;expr);
  /// Convenience function for static types whose evaluation is already known.
  explicit StaticType(Cache *cache, int64_t i);
  explicit StaticType(Cache *cache, const std::string &amp;s);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  StaticValue evaluate() const;
  std::shared_ptr&lt;StaticType&gt; getStatic() override {
    return std::static_pointer_cast&lt;StaticType&gt;(shared_from_this());
  }

private:
  void parseExpr(const std::shared_ptr&lt;Expr&gt; &amp;e, std::unordered_set&lt;std::string&gt; &amp;seen);
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.609">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

struct Trait : public Type {
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string realizedName() const override;

protected:
  explicit Trait(const std::shared_ptr&lt;Type&gt; &amp;);
  explicit Trait(Cache *);
};

struct CallableTrait : public Trait {
  std::vector&lt;TypePtr&gt; args; // tuple with arg types, ret type

public:
  explicit CallableTrait(Cache *cache, std::vector&lt;TypePtr&gt; args);
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;
  std::string debugString(char mode) const override;
};

struct TypeTrait : public Trait {
  TypePtr type;

public:
  explicit TypeTrait(TypePtr type);
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;
  std::string debugString(char mode) const override;
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.61">def __repr__(self):
    return "Spline(%r, %r, %r)" % (self.points, self.degree, self.knots)


</t>
<t tx="ekr.20230509052845.610">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/common.h"

namespace codon::ast {
struct Cache;
struct Expr;
} // namespace codon::ast

namespace codon::ast::types {

/// Forward declarations
struct FuncType;
struct ClassType;
struct LinkType;
struct RecordType;
struct PartialType;
struct StaticType;
struct UnionType;

/**
 * An abstract type class that describes methods needed for the type inference.
 * (Hindley-Milner's Algorithm W inference; see
 * https://github.com/tomprimozic/type-systems).
 *
 * Type instances are mutable and each type is intended to be instantiated and
 * manipulated as a shared_ptr.
 */
struct Type : public codon::SrcObject, public std::enable_shared_from_this&lt;Type&gt; {
  /// A structure that keeps the list of unification steps that can be undone later.
  /// Needed because the unify() is destructive.
  struct Unification {
    /// List of unbound types that have been changed.
    std::vector&lt;LinkType *&gt; linked;
    /// List of unbound types whose level has been changed.
    std::vector&lt;std::pair&lt;LinkType *, int&gt;&gt; leveled;
    /// List of assigned traits.
    std::vector&lt;LinkType *&gt; traits;
    /// List of pointers that are owned by unification process
    /// (to avoid memory issues with undoing).
    std::vector&lt;std::shared_ptr&lt;Type&gt;&gt; ownedTypes;

  public:
    /// Undo the unification step.
    void undo();
  };

public:
  /// Unifies a given type with the current type.
  /// @param typ A given type.
  /// @param undo A reference to Unification structure to track the unification steps
  ///             and allow later undoing of the unification procedure.
  /// @return Unification score: -1 for failure, anything &gt;= 0 for success.
  ///         Higher score translates to a "better" unification.
  ///  Destructive operation if undo is not null!
  ///    (both the current and a given type are modified).
  virtual int unify(Type *typ, Unification *undo) = 0;
  /// Generalize all unbound types whose level is below the provided level.
  /// This method replaces all unbound types with a generic types (e.g. ?1 -&gt; T1).
  /// Note that the generalized type keeps the unbound type's ID.
  virtual std::shared_ptr&lt;Type&gt; generalize(int atLevel) = 0;
  /// Instantiate all generic types. Inverse of generalize(): it replaces all
  /// generic types with new unbound types (e.g. T1 -&gt; ?1234).
  /// Note that the instantiated type has a distinct and unique ID.
  /// @param level Level of the instantiation.
  /// @param unboundCount A reference of the unbound counter to ensure that no two
  ///                     unbound types share the same ID.
  /// @param cache A reference to a lookup table to ensure that all instances of a
  ///              generic point to the same unbound type (e.g. dict[T, list[T]] should
  ///              be instantiated as dict[?1, list[?1]]).
  virtual std::shared_ptr&lt;Type&gt;
  instantiate(int atLevel, int *unboundCount,
              std::unordered_map&lt;int, std::shared_ptr&lt;Type&gt;&gt; *cache) = 0;

public:
  /// Get the final type (follow through all LinkType links).
  /// For example, for (a-&gt;b-&gt;c-&gt;d) it returns d.
  virtual std::shared_ptr&lt;Type&gt; follow();
  /// Obtain the list of internal unbound types.
  virtual std::vector&lt;std::shared_ptr&lt;Type&gt;&gt; getUnbounds() const;
  /// True if a type is realizable.
  virtual bool canRealize() const = 0;
  /// True if a type is completely instantiated (has no unbounds or generics).
  virtual bool isInstantiated() const = 0;
  /// Pretty-print facility.
  std::string toString() const;
  /// Pretty-print facility.
  std::string prettyString() const;
  /// Pretty-print facility. mode is [0: pretty, 1: llvm, 2: debug]
  virtual std::string debugString(char mode) const = 0;
  /// Print the realization string.
  /// Similar to toString, but does not print the data unnecessary for realization
  /// (e.g. the function return type).
  virtual std::string realizedName() const = 0;

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual std::shared_ptr&lt;FuncType&gt; getFunc() { return nullptr; }
  virtual std::shared_ptr&lt;PartialType&gt; getPartial() { return nullptr; }
  virtual std::shared_ptr&lt;ClassType&gt; getClass() { return nullptr; }
  virtual std::shared_ptr&lt;RecordType&gt; getRecord() { return nullptr; }
  virtual std::shared_ptr&lt;LinkType&gt; getLink() { return nullptr; }
  virtual std::shared_ptr&lt;LinkType&gt; getUnbound() { return nullptr; }
  virtual std::shared_ptr&lt;StaticType&gt; getStatic() { return nullptr; }
  virtual std::shared_ptr&lt;UnionType&gt; getUnion() { return nullptr; }
  virtual std::shared_ptr&lt;RecordType&gt; getHeterogenousTuple() { return nullptr; }

  virtual bool is(const std::string &amp;s);
  char isStaticType();

public:
  static std::shared_ptr&lt;Type&gt; makeType(Cache *, const std::string &amp;,
                                        const std::string &amp;, bool = false);
  static std::shared_ptr&lt;StaticType&gt; makeStatic(Cache *, const std::shared_ptr&lt;Expr&gt; &amp;);

protected:
  Cache *cache;
  explicit Type(const std::shared_ptr&lt;Type&gt; &amp;);
  explicit Type(Cache *, const SrcInfo &amp; = SrcInfo());
};
using TypePtr = std::shared_ptr&lt;Type&gt;;

} // namespace codon::ast::types

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.611">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::types::Type, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509052845.612">template &lt;typename T&gt;
struct fmt::formatter&lt;
  T,
  std::enable_if_t&lt;
      std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::types::Type&gt;&gt;::value, char&gt;&gt;
  : fmt::formatter&lt;std::string_view&gt; {
char presentation = 'd';

@others
};
</t>
<t tx="ekr.20230509052845.613">constexpr auto parse(format_parse_context &amp;ctx) -&gt; decltype(ctx.begin()) {
  auto it = ctx.begin(), end = ctx.end();
  if (it != end &amp;&amp; (*it == 'p' || *it == 'd' || *it == 'D'))
    presentation = *it++;
  return it;
}

</t>
<t tx="ekr.20230509052845.614">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
if (presentation == 'p')
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(0) : "&lt;nullptr&gt;");
else if (presentation == 'd')
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(1) : "&lt;nullptr&gt;");
else
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(2) : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509052845.615">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"

namespace codon::ast::types {

struct UnionType : public RecordType {
  std::vector&lt;TypePtr&gt; pendingTypes;

  explicit UnionType(Cache *cache);
  UnionType(Cache *, const std::vector&lt;ClassType::Generic&gt; &amp;,
            const std::vector&lt;TypePtr&gt; &amp;);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  bool canRealize() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;
  std::string realizedTypeName() const override;
  bool isSealed() const;

  std::shared_ptr&lt;UnionType&gt; getUnion() override {
    return std::static_pointer_cast&lt;UnionType&gt;(shared_from_this());
  }

  void addType(TypePtr typ);
  void seal();
  std::vector&lt;types::TypePtr&gt; getRealizationTypes();
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.616"></t>
<t tx="ekr.20230509052845.617">@path C:/Repos/codon/codon/parser/peg/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/util/common.h"

namespace codon::ast {

/// Parse a Seq code block with the appropriate file and position offsets.
StmtPtr parseCode(Cache *cache, const std::string &amp;file, const std::string &amp;code,
                  int line_offset = 0);
/// Parse a Seq code expression.
/// @return pair of ExprPtr and a string indicating format specification
/// (empty if not available).
std::pair&lt;ExprPtr, std::string&gt; parseExpr(Cache *cache, const std::string &amp;code,
                                          const codon::SrcInfo &amp;offset);
/// Parse a Seq file.
StmtPtr parseFile(Cache *cache, const std::string &amp;file);

/// Parse a OpenMP clause.
std::vector&lt;CallExpr::Arg&gt; parseOpenMP(Cache *cache, const std::string &amp;code,
                                       const codon::SrcInfo &amp;loc);

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.618">@path C:/Repos/codon/codon/parser/peg/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;any&gt;
#include &lt;cstdio&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;peglib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"

namespace codon::ast {

struct ParseContext {
  Cache *cache;
  std::stack&lt;int&gt; indent;
  int parens;
  int line_offset, col_offset;
  ParseContext(Cache *cache, int parens = 0, int line_offset = 0, int col_offset = 0)
      : cache(cache), parens(parens), line_offset(line_offset), col_offset(col_offset) {
  }

@others
};

} // namespace codon::ast

void init_codon_rules(peg::Grammar &amp;);
void init_codon_actions(peg::Grammar &amp;);
void init_omp_rules(peg::Grammar &amp;);
void init_omp_actions(peg::Grammar &amp;);
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.619">  bool hasCustomStmtKeyword(const std::string &amp;kwd, bool hasExpr) const {
    auto i = cache-&gt;customBlockStmts.find(kwd);
    if (i != cache-&gt;customBlockStmts.end())
      return i-&gt;second.first == hasExpr;
    return false;
  }
</t>
<t tx="ekr.20230509052845.62">def write_ppm(im, filename):
    magic = 'P6\n'
    maxval = 255
    w = len(im)
    h = len(im[0])

    with open(filename, "w", encoding="latin1", newline='') as fp:
        fp.write(magic)
        fp.write('%i %i\n%i\n' % (w, h, maxval))
        for j in range(h):
            for i in range(w):
                val = im[i][j]
                c = val * 255
                fp.write('%c%c%c' % (c, c, c))


</t>
<t tx="ekr.20230509052845.620">  bool hasCustomExprStmt(const std::string &amp;kwd) const {
    return in(cache-&gt;customExprStmts, kwd);
  }
</t>
<t tx="ekr.20230509052845.621"></t>
<t tx="ekr.20230509052845.622">@path C:/Repos/codon/codon/parser/visitors/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/compiler/error.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"

namespace codon::ast {

/**
 * Base Seq AST visitor.
 * Each visit() by default calls an appropriate defaultVisit().
 */
struct ASTVisitor {
protected:
  /// Default expression node visitor if a particular visitor is not overloaded.
  virtual void defaultVisit(Expr *expr);
  /// Default statement node visitor if a particular visitor is not overloaded.
  virtual void defaultVisit(Stmt *stmt);

public:
  virtual void visit(NoneExpr *);
  virtual void visit(BoolExpr *);
  virtual void visit(IntExpr *);
  virtual void visit(FloatExpr *);
  virtual void visit(StringExpr *);
  virtual void visit(IdExpr *);
  virtual void visit(StarExpr *);
  virtual void visit(KeywordStarExpr *);
  virtual void visit(TupleExpr *);
  virtual void visit(ListExpr *);
  virtual void visit(SetExpr *);
  virtual void visit(DictExpr *);
  virtual void visit(GeneratorExpr *);
  virtual void visit(DictGeneratorExpr *);
  virtual void visit(IfExpr *);
  virtual void visit(UnaryExpr *);
  virtual void visit(BinaryExpr *);
  virtual void visit(ChainBinaryExpr *);
  virtual void visit(PipeExpr *);
  virtual void visit(IndexExpr *);
  virtual void visit(CallExpr *);
  virtual void visit(DotExpr *);
  virtual void visit(SliceExpr *);
  virtual void visit(EllipsisExpr *);
  virtual void visit(LambdaExpr *);
  virtual void visit(YieldExpr *);
  virtual void visit(AssignExpr *);
  virtual void visit(RangeExpr *);
  virtual void visit(InstantiateExpr *);
  virtual void visit(StmtExpr *);

  virtual void visit(AssignMemberStmt *);
  virtual void visit(SuiteStmt *);
  virtual void visit(BreakStmt *);
  virtual void visit(ContinueStmt *);
  virtual void visit(ExprStmt *);
  virtual void visit(AssignStmt *);
  virtual void visit(DelStmt *);
  virtual void visit(PrintStmt *);
  virtual void visit(ReturnStmt *);
  virtual void visit(YieldStmt *);
  virtual void visit(AssertStmt *);
  virtual void visit(WhileStmt *);
  virtual void visit(ForStmt *);
  virtual void visit(IfStmt *);
  virtual void visit(MatchStmt *);
  virtual void visit(ImportStmt *);
  virtual void visit(TryStmt *);
  virtual void visit(GlobalStmt *);
  virtual void visit(ThrowStmt *);
  virtual void visit(FunctionStmt *);
  virtual void visit(ClassStmt *);
  virtual void visit(YieldFromStmt *);
  virtual void visit(WithStmt *);
  virtual void visit(CustomStmt *);
  virtual void visit(CommentStmt *);
};

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.623">template &lt;typename TE, typename TS&gt;
/**
 * Callback AST visitor.
 * This visitor extends base ASTVisitor and stores node's source location (SrcObject).
 * Function simplify() will visit a node and return the appropriate transformation. As
 * each node type (expression or statement) might return a different type,
 * this visitor is generic for each different return type.
 */
struct CallbackASTVisitor : public ASTVisitor, public SrcObject {
  virtual TE transform(const std::shared_ptr&lt;Expr&gt; &amp;expr) = 0;
  virtual TE transform(std::shared_ptr&lt;Expr&gt; &amp;expr) {
    return transform(static_cast&lt;const std::shared_ptr&lt;Expr&gt; &amp;&gt;(expr));
  }
  virtual TS transform(const std::shared_ptr&lt;Stmt&gt; &amp;stmt) = 0;
  virtual TS transform(std::shared_ptr&lt;Stmt&gt; &amp;stmt) {
    return transform(static_cast&lt;const std::shared_ptr&lt;Stmt&gt; &amp;&gt;(stmt));
  }

  /// Convenience method that transforms a vector of nodes.
  template &lt;typename T&gt; auto transform(const std::vector&lt;T&gt; &amp;ts) {
    std::vector&lt;T&gt; r;
    for (auto &amp;e : ts)
      r.push_back(transform(e));
    return r;
  }

  /// Convenience method that constructs a clone of a node.
  template &lt;typename Tn&gt; auto N(const Tn &amp;ptr) { return std::make_shared&lt;Tn&gt;(ptr); }
  /// Convenience method that constructs a node.
  /// @param s source location.
  template &lt;typename Tn, typename... Ts&gt; auto N(codon::SrcInfo s, Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(s);
    return t;
  }
  /// Convenience method that constructs a node with the visitor's source location.
  template &lt;typename Tn, typename... Ts&gt; auto N(Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(getSrcInfo());
    return t;
  }
  template &lt;typename Tn, typename... Ts&gt; auto NT(Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(getSrcInfo());
    t-&gt;markType();
    return t;
  }

  /// Convenience method that raises an error at the current source location.
  template &lt;typename... TArgs&gt; void error(const char *format, TArgs &amp;&amp;...args) {
    error::raise_error(-1, getSrcInfo(), fmt::format(format, args...).c_str());
  }

  @others
};

</t>
<t tx="ekr.20230509052845.624">/// Convenience method that raises an error at the source location of p.
template &lt;typename T, typename... TArgs&gt;
void error(const T &amp;p, const char *format, TArgs &amp;&amp;...args) {
  error::raise_error(-1, p-&gt;getSrcInfo(), fmt::format(format, args...).c_str());
}

</t>
<t tx="ekr.20230509052845.625">/// Convenience method that raises an internal error.
template &lt;typename T, typename... TArgs&gt;
void internalError(const char *format, TArgs &amp;&amp;...args) {
  throw exc::ParserException(
      fmt::format("INTERNAL: {}", fmt::format(format, args...), getSrcInfo()));
}

</t>
<t tx="ekr.20230509052845.626">public:
</t>
<t tx="ekr.20230509052845.627">void visit(NoneExpr *expr) override {}
  @others
</t>
<t tx="ekr.20230509052845.628">void visit(BoolExpr *expr) override {}
@others
</t>
<t tx="ekr.20230509052845.629">void visit(IntExpr *expr) override {}
@others
</t>
<t tx="ekr.20230509052845.63">class Chaosgame(object):

    @others
</t>
<t tx="ekr.20230509052845.630">void visit(FloatExpr *expr) override {}
void visit(StringExpr *expr) override {}
void visit(IdExpr *expr) override {}
void visit(StarExpr *expr) override { transform(expr-&gt;what); }
void visit(KeywordStarExpr *expr) override { transform(expr-&gt;what); }
void visit(TupleExpr *expr) override {
for (auto &amp;i : expr-&gt;items)
transform(i);
}
</t>
<t tx="ekr.20230509052845.631">void visit(ListExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509052845.632">void visit(SetExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509052845.633">void visit(DictExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509052845.634">void visit(GeneratorExpr *expr) override {
  transform(expr-&gt;expr);
  for (auto &amp;l : expr-&gt;loops) {
    transform(l.vars);
    transform(l.gen);
    for (auto &amp;c : l.conds)
      transform(c);
  }
}
</t>
<t tx="ekr.20230509052845.635">void visit(DictGeneratorExpr *expr) override {
  transform(expr-&gt;key);
  transform(expr-&gt;expr);
  for (auto &amp;l : expr-&gt;loops) {
    transform(l.vars);
    transform(l.gen);
    for (auto &amp;c : l.conds)
      transform(c);
  }
}
</t>
<t tx="ekr.20230509052845.636">void visit(IfExpr *expr) override {
  transform(expr-&gt;cond);
  transform(expr-&gt;ifexpr);
  transform(expr-&gt;elsexpr);
}
</t>
<t tx="ekr.20230509052845.637">void visit(UnaryExpr *expr) override { transform(expr-&gt;expr); }
</t>
<t tx="ekr.20230509052845.638">void visit(BinaryExpr *expr) override {
  transform(expr-&gt;lexpr);
  transform(expr-&gt;rexpr);
}
</t>
<t tx="ekr.20230509052845.639">void visit(ChainBinaryExpr *expr) override {
  for (auto &amp;e : expr-&gt;exprs)
    transform(e.second);
}
</t>
<t tx="ekr.20230509052845.64">def __init__(self, splines, thickness=0.1):
    self.splines = splines
    self.thickness = thickness
    self.minx = min([p.x for spl in splines for p in spl.points])
    self.miny = min([p.y for spl in splines for p in spl.points])
    self.maxx = max([p.x for spl in splines for p in spl.points])
    self.maxy = max([p.y for spl in splines for p in spl.points])
    self.height = self.maxy - self.miny
    self.width = self.maxx - self.minx
    self.num_trafos = []
    maxlength = thickness * self.width / self.height
    for spl in splines:
        length = 0
        curr = spl(0)
        for i in range(1, 1000):
            last = curr
            t = 1 / 999 * i
            curr = spl(t)
            length += curr.dist(last)
        self.num_trafos.append(max(1, int(length / maxlength * 1.5)))
    self.num_total = sum(self.num_trafos)

</t>
<t tx="ekr.20230509052845.640">void visit(PipeExpr *expr) override {
  for (auto &amp;e : expr-&gt;items)
    transform(e.expr);
}
</t>
<t tx="ekr.20230509052845.641">void visit(IndexExpr *expr) override {
  transform(expr-&gt;expr);
  transform(expr-&gt;index);
}
</t>
<t tx="ekr.20230509052845.642">void visit(CallExpr *expr) override {
  transform(expr-&gt;expr);
  for (auto &amp;a : expr-&gt;args)
    transform(a.value);
}
</t>
<t tx="ekr.20230509052845.643">void visit(DotExpr *expr) override { transform(expr-&gt;expr); }
</t>
<t tx="ekr.20230509052845.644">void visit(SliceExpr *expr) override {
  transform(expr-&gt;start);
  transform(expr-&gt;stop);
  transform(expr-&gt;step);
}
</t>
<t tx="ekr.20230509052845.645">void visit(EllipsisExpr *expr) override {}
void visit(LambdaExpr *expr) override { transform(expr-&gt;expr); }
void visit(YieldExpr *expr) override {}
void visit(AssignExpr *expr) override {
  transform(expr-&gt;var);
  transform(expr-&gt;expr);
}
</t>
<t tx="ekr.20230509052845.646">void visit(RangeExpr *expr) override {
  transform(expr-&gt;start);
  transform(expr-&gt;stop);
}
</t>
<t tx="ekr.20230509052845.647">void visit(InstantiateExpr *expr) override {
  transform(expr-&gt;typeExpr);
  for (auto &amp;e : expr-&gt;typeParams)
    transform(e);
}
</t>
<t tx="ekr.20230509052845.648">void visit(StmtExpr *expr) override {
  for (auto &amp;s : expr-&gt;stmts)
    transform(s);
  transform(expr-&gt;expr);
}
</t>
<t tx="ekr.20230509052845.649">void visit(SuiteStmt *stmt) override {
  for (auto &amp;s : stmt-&gt;stmts)
    transform(s);
}
</t>
<t tx="ekr.20230509052845.65">def get_random_trafo(self):
    r = random.randrange(int(self.num_total) + 1)
    l = 0
    for i in range(len(self.num_trafos)):
        if r &gt;= l and r &lt; l + self.num_trafos[i]:
            return i, random.randrange(self.num_trafos[i])
        l += self.num_trafos[i]
    return len(self.num_trafos) - 1, random.randrange(self.num_trafos[-1])

</t>
<t tx="ekr.20230509052845.650">void visit(BreakStmt *stmt) override {}
void visit(ContinueStmt *stmt) override {}
void visit(ExprStmt *stmt) override { transform(stmt-&gt;expr); }
void visit(AssignStmt *stmt) override {
  transform(stmt-&gt;lhs);
  transform(stmt-&gt;rhs);
  transform(stmt-&gt;type);
}
</t>
<t tx="ekr.20230509052845.651">void visit(AssignMemberStmt *stmt) override {
  transform(stmt-&gt;lhs);
  transform(stmt-&gt;rhs);
}
</t>
<t tx="ekr.20230509052845.652">void visit(DelStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509052845.653">void visit(PrintStmt *stmt) override {
  for (auto &amp;e : stmt-&gt;items)
    transform(e);
}
</t>
<t tx="ekr.20230509052845.654">void visit(ReturnStmt *stmt) override { transform(stmt-&gt;expr); }
void visit(YieldStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509052845.655">void visit(AssertStmt *stmt) override {
  transform(stmt-&gt;expr);
  transform(stmt-&gt;message);
}
</t>
<t tx="ekr.20230509052845.656">void visit(WhileStmt *stmt) override {
  transform(stmt-&gt;cond);
  transform(stmt-&gt;suite);
  transform(stmt-&gt;elseSuite);
}
</t>
<t tx="ekr.20230509052845.657">void visit(ForStmt *stmt) override {
  transform(stmt-&gt;var);
  transform(stmt-&gt;iter);
  transform(stmt-&gt;suite);
  transform(stmt-&gt;elseSuite);
  transform(stmt-&gt;decorator);
  for (auto &amp;a : stmt-&gt;ompArgs)
    transform(a.value);
}
</t>
<t tx="ekr.20230509052845.658">void visit(IfStmt *stmt) override {
  transform(stmt-&gt;cond);
  transform(stmt-&gt;ifSuite);
  transform(stmt-&gt;elseSuite);
}
</t>
<t tx="ekr.20230509052845.659">void visit(MatchStmt *stmt) override {
  transform(stmt-&gt;what);
  for (auto &amp;m : stmt-&gt;cases) {
    transform(m.pattern);
    transform(m.guard);
    transform(m.suite);
  }
}
</t>
<t tx="ekr.20230509052845.66">def transform_point(self, point, trafo=None):
    x = (point.x - self.minx) / self.width
    y = (point.y - self.miny) / self.height
    if trafo is None:
        trafo = self.get_random_trafo()
    start, end = self.splines[trafo[0]].GetDomain()
    length = end - start
    seg_length = length / self.num_trafos[trafo[0]]
    t = start + seg_length * trafo[1] + seg_length * x
    basepoint = self.splines[trafo[0]](t)
    if t + 1 / 50000 &gt; end:
        neighbour = self.splines[trafo[0]](t - 1 / 50000)
        derivative = neighbour - basepoint
    else:
        neighbour = self.splines[trafo[0]](t + 1 / 50000)
        derivative = basepoint - neighbour
    if derivative.Mag() != 0:
        basepoint.x += derivative.y / derivative.Mag() * (y - 0.5) * \
            self.thickness
        basepoint.y += -derivative.x / derivative.Mag() * (y - 0.5) * \
            self.thickness
    else:
        print("r", end='')
    self.truncate(basepoint)
    return basepoint

</t>
<t tx="ekr.20230509052845.660">void visit(ImportStmt *stmt) override {
  transform(stmt-&gt;from);
  transform(stmt-&gt;what);
  for (auto &amp;a : stmt-&gt;args) {
    transform(a.type);
    transform(a.defaultValue);
  }
  transform(stmt-&gt;ret);
}
</t>
<t tx="ekr.20230509052845.661">void visit(TryStmt *stmt) override {
  transform(stmt-&gt;suite);
  for (auto &amp;a : stmt-&gt;catches) {
    transform(a.exc);
    transform(a.suite);
  }
  transform(stmt-&gt;finally);
}
</t>
<t tx="ekr.20230509052845.662">void visit(GlobalStmt *stmt) override {}
void visit(ThrowStmt *stmt) override { transform(stmt-&gt;expr); }
  @others
</t>
<t tx="ekr.20230509052845.663">void visit(FunctionStmt *stmt) override {
transform(stmt-&gt;ret);
for (auto &amp;a : stmt-&gt;args) {
  transform(a.type);
  transform(a.defaultValue);
}
transform(stmt-&gt;suite);
for (auto &amp;d : stmt-&gt;decorators)
  transform(d);
}
</t>
<t tx="ekr.20230509052845.664">void visit(ClassStmt *stmt) override {
  for (auto &amp;a : stmt-&gt;args) {
    transform(a.type);
    transform(a.defaultValue);
  }
  transform(stmt-&gt;suite);
  for (auto &amp;d : stmt-&gt;decorators)
    transform(d);
  for (auto &amp;d : stmt-&gt;baseClasses)
    transform(d);
  for (auto &amp;d : stmt-&gt;staticBaseClasses)
    transform(d);
}
</t>
<t tx="ekr.20230509052845.665">void visit(YieldFromStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509052845.666">void visit(WithStmt *stmt) override {
  for (auto &amp;a : stmt-&gt;items)
    transform(a);
  transform(stmt-&gt;suite);
}
</t>
<t tx="ekr.20230509052845.667">void visit(CustomStmt *stmt) override {
  transform(stmt-&gt;expr);
  transform(stmt-&gt;suite);
}
</t>
<t tx="ekr.20230509052845.668"></t>
<t tx="ekr.20230509052845.669">@path C:/Repos/codon/codon/parser/visitors/doc/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

struct json {
  // values={str -&gt; null} -&gt; string value
  // values={i -&gt; json} -&gt; list (if list=true)
  // values={...} -&gt; dictionary
  std::unordered_map&lt;std::string, std::shared_ptr&lt;json&gt;&gt; values;
  bool list;

  json();
  json(const std::string &amp;s);
  json(const std::string &amp;s, const std::string &amp;v);
  json(const std::vector&lt;std::shared_ptr&lt;json&gt;&gt; &amp;vs);
  json(const std::vector&lt;std::string&gt; &amp;vs);
  json(const std::unordered_map&lt;std::string, std::string&gt; &amp;vs);
  std::string toString();
  std::shared_ptr&lt;json&gt; get(const std::string &amp;s);
  std::shared_ptr&lt;json&gt; set(const std::string &amp;s, const std::string &amp;value);
  std::shared_ptr&lt;json&gt; set(const std::string &amp;s, const std::shared_ptr&lt;json&gt; &amp;value);
};

struct DocContext;
struct DocShared {
  int itemID = 1;
  std::shared_ptr&lt;json&gt; j;
  std::unordered_map&lt;std::string, std::shared_ptr&lt;DocContext&gt;&gt; modules;
  std::string argv0;
  Cache *cache = nullptr;
  std::unordered_map&lt;int, std::vector&lt;std::string&gt;&gt; generics;
  DocShared() {}
};

struct DocContext : public Context&lt;int&gt; {
  std::shared_ptr&lt;DocShared&gt; shared;
  explicit DocContext(std::shared_ptr&lt;DocShared&gt; shared)
      : Context&lt;int&gt;(""), shared(std::move(shared)) {}
  std::shared_ptr&lt;int&gt; find(const std::string &amp;s) const override;
};

struct DocVisitor : public CallbackASTVisitor&lt;std::shared_ptr&lt;json&gt;, std::string&gt; {
  std::shared_ptr&lt;DocContext&gt; ctx;
  std::shared_ptr&lt;json&gt; resultExpr;
  std::string resultStmt;

public:
  explicit DocVisitor(std::shared_ptr&lt;DocContext&gt; ctx) : ctx(std::move(ctx)) {}
  static std::shared_ptr&lt;json&gt; apply(const std::string &amp;argv0,
                                     const std::vector&lt;std::string&gt; &amp;files);

  std::shared_ptr&lt;json&gt; transform(const ExprPtr &amp;e) override;
  std::string transform(const StmtPtr &amp;e) override;

  void transformModule(StmtPtr stmt);
  std::shared_ptr&lt;json&gt; jsonify(const codon::SrcInfo &amp;s);
  std::vector&lt;StmtPtr&gt; flatten(StmtPtr stmt, std::string *docstr = nullptr,
                               bool deep = true);

public:
  void visit(IntExpr *) override;
  void visit(IdExpr *) override;
  void visit(IndexExpr *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  void visit(AssignStmt *) override;
  void visit(ImportStmt *) override;
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.67">def truncate(self, point):
    if point.x &gt;= self.maxx:
        point.x = self.maxx
    if point.y &gt;= self.maxy:
        point.y = self.maxy
    if point.x &lt; self.minx:
        point.x = self.minx
    if point.y &lt; self.miny:
        point.y = self.miny

</t>
<t tx="ekr.20230509052845.670"></t>
<t tx="ekr.20230509052845.671">@path C:/Repos/codon/codon/parser/visitors/format/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/visitor.h"

namespace codon {
namespace ast {

@others
} // namespace ast
} // namespace codon

template &lt;&gt;
struct fmt::formatter&lt;codon::ast::FormatVisitor&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.672">class FormatVisitor : public CallbackASTVisitor&lt;std::string, std::string&gt; {
  std::string result;
  std::string space;
  bool renderType, renderHTML;
  int indent;

  std::string header, footer, nl;
  std::string typeStart, typeEnd;
  std::string nodeStart, nodeEnd;
  std::string exprStart, exprEnd;
  std::string commentStart, commentEnd;
  std::string keywordStart, keywordEnd;

  Cache *cache;

private:
  template &lt;typename T, typename... Ts&gt; std::string renderExpr(T &amp;&amp;t, Ts &amp;&amp;...args) {
    std::string s;
    return fmt::format("{}{}{}{}{}{}", exprStart, s, nodeStart, fmt::format(args...),
                       nodeEnd, exprEnd);
  }
  template &lt;typename... Ts&gt; std::string renderComment(Ts &amp;&amp;...args) {
    return fmt::format("{}{}{}", commentStart, fmt::format(args...), commentEnd);
  }
  std::string pad(int indent = 0) const;
  std::string newline() const;
  std::string keyword(const std::string &amp;s) const;

public:
  FormatVisitor(bool html, Cache *cache = nullptr);
  std::string transform(const ExprPtr &amp;e) override;
  std::string transform(const Expr *expr);
  std::string transform(const StmtPtr &amp;stmt) override;
  std::string transform(Stmt *stmt, int indent);

  @others
  void defaultVisit(Expr *e) override { error("cannot format {}", *e); }
  void defaultVisit(Stmt *e) override { error("cannot format {}", *e); }

public:
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;
  void visit(IdExpr *) override;
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *) override;
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  void visit(DictGeneratorExpr *) override;
  void visit(InstantiateExpr *expr) override;
  void visit(IfExpr *) override;
  void visit(UnaryExpr *) override;
  void visit(BinaryExpr *) override;
  void visit(PipeExpr *) override;
  void visit(IndexExpr *) override;
  void visit(CallExpr *) override;
  void visit(DotExpr *) override;
  void visit(SliceExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(LambdaExpr *) override;
  void visit(YieldExpr *) override;
  void visit(StmtExpr *expr) override;
  void visit(AssignExpr *expr) override;

  void visit(SuiteStmt *) override;
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(ExprStmt *) override;
  void visit(AssignStmt *) override;
  void visit(AssignMemberStmt *) override;
  void visit(DelStmt *) override;
  void visit(PrintStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(AssertStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  void visit(IfStmt *) override;
  void visit(MatchStmt *) override;
  void visit(ImportStmt *) override;
  void visit(TryStmt *) override;
  void visit(GlobalStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  void visit(YieldFromStmt *) override;
  void visit(WithStmt *) override;

public:
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const FormatVisitor &amp;c) {
    return out &lt;&lt; c.result;
  }

  using CallbackASTVisitor&lt;std::string, std::string&gt;::transform;
  template &lt;typename T&gt; std::string transform(const std::vector&lt;T&gt; &amp;ts) {
    std::vector&lt;std::string&gt; r;
    for (auto &amp;e : ts)
      r.push_back(transform(e));
    return fmt::format("{}", fmt::join(r, ", "));
  }
};

</t>
<t tx="ekr.20230509052845.673">template &lt;typename T&gt;
static std::string apply(const T &amp;stmt, Cache *cache = nullptr, bool html = false,
                         bool init = false) {
  auto t = FormatVisitor(html, cache);
  return fmt::format("{}{}{}", t.header, t.transform(stmt), t.footer);
}

</t>
<t tx="ekr.20230509052845.674"></t>
<t tx="ekr.20230509052845.675">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;deque&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * Simplification context identifier.
 * Can be either a function, a class (type), or a variable.
 */
struct SimplifyItem : public SrcObject {
  /// Type of the identifier
  enum Kind { Func, Type, Var } kind;
  /// Base name (e.g., foo.bar.baz)
  std::string baseName;
  /// Unique identifier (canonical name)
  std::string canonicalName;
  /// Full module name
  std::string moduleName;
  /// Full scope information
  std::vector&lt;int&gt; scope;
  /// Non-empty string if a variable is import variable
  std::string importPath;
  /// List of scopes where the identifier is accessible
  /// without __used__ check
  std::vector&lt;std::vector&lt;int&gt;&gt; accessChecked;
  /// Set if an identifier cannot be shadowed
  /// (e.g., global-marked variables)
  bool noShadow = false;
  /// Set if an identifier is a class or a function generic
  bool generic = false;
  /// Set if an identifier is a static variable.
  char staticType = 0;
  /// Set if an identifier should not be dominated
  /// (e.g., a loop variable in a comprehension).
  bool avoidDomination = false;

public:
  SimplifyItem(Kind kind, std::string baseName, std::string canonicalName,
               std::string moduleName, std::vector&lt;int&gt; scope,
               std::string importPath = "")
      : kind(kind), baseName(std::move(baseName)),
        canonicalName(std::move(canonicalName)), moduleName(std::move(moduleName)),
        scope(std::move(scope)), importPath(std::move(importPath)) {}

  /* Convenience getters */
  std::string getBaseName() const { return baseName; }
  std::string getModule() const { return moduleName; }
  bool isVar() const { return kind == Var; }
  bool isFunc() const { return kind == Func; }
  bool isType() const { return kind == Type; }
  bool isImport() const { return !importPath.empty(); }
  bool isGlobal() const { return scope.size() == 1 &amp;&amp; baseName.empty(); }
  /// True if an identifier is within a conditional block
  /// (i.e., a block that might not be executed during the runtime)
  bool isConditional() const { return scope.size() &gt; 1; }
  bool isGeneric() const { return generic; }
  char isStatic() const { return staticType; }
  /// True if an identifier is a loop variable in a comprehension
  bool canDominate() const { return !avoidDomination; }
};

/** Context class that tracks identifiers during the simplification. **/
struct SimplifyContext : public Context&lt;SimplifyItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;

  /// Holds the information about current scope.
  /// A scope is defined as a stack of conditional blocks
  /// (i.e., blocks that might not get executed during the runtime).
  /// Used mainly to support Python's variable scoping rules.
  struct {
    /// Scope counter. Each conditional block gets a new scope ID.
    int counter;
    /// Current hierarchy of conditional blocks.
    std::vector&lt;int&gt; blocks;
    /// List of statements that are to be prepended to a block
    /// after its transformation.
    std::map&lt;int, std::vector&lt;StmtPtr&gt;&gt; stmts;
  } scope;

  /// Holds the information about current base.
  /// A base is defined as a function or a class block.
  struct Base {
    /// Canonical name of a function or a class that owns this base.
    std::string name;
    /// Tracks function attributes (e.g. if it has @atomic or @test attributes).
    /// Only set for functions.
    Attr *attributes;
    /// Set if the base is class base and if class is marked with @deduce.
    /// Stores the list of class fields in the order of traversal.
    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; deducedMembers;
    /// Canonical name of `self` parameter that is used to deduce class fields
    /// (e.g., self in self.foo).
    std::string selfName;
    /// Map of captured identifiers (i.e., identifiers not defined in a function).
    /// Captured (canonical) identifiers are mapped to the new canonical names
    /// (representing the canonical function argument names that are appended to the
    /// function after processing) and their types (indicating if they are a type, a
    /// static or a variable).
    std::unordered_map&lt;std::string, std::pair&lt;std::string, ExprPtr&gt;&gt; *captures;

    /// Map of identifiers that are to be fetched from Python.
    std::unordered_set&lt;std::string&gt; *pyCaptures;

    /// Scope that defines the base.
    std::vector&lt;int&gt; scope;

    /// A stack of nested loops enclosing the current statement used for transforming
    /// "break" statement in loop-else constructs. Each loop is defined by a "break"
    /// variable created while parsing a loop-else construct. If a loop has no else
    /// block, the corresponding loop variable is empty.
    struct Loop {
      std::string breakVar;
      std::vector&lt;int&gt; scope;
      /// List of variables "seen" before their assignment within a loop.
      /// Used to dominate variables that are updated within a loop.
      std::unordered_set&lt;std::string&gt; seenVars;
    };
    std::vector&lt;Loop&gt; loops;

  public:
    explicit Base(std::string name, Attr *attributes = nullptr);
    Loop *getLoop() { return loops.empty() ? nullptr : &amp;(loops.back()); }
    bool isType() const { return attributes == nullptr; }
  };
  /// Current base stack (the last enclosing base is the last base in the stack).
  std::vector&lt;Base&gt; bases;

  struct BaseGuard {
    SimplifyContext *holder;
    BaseGuard(SimplifyContext *holder, const std::string &amp;name) : holder(holder) {
      holder-&gt;bases.emplace_back(Base(name));
      holder-&gt;bases.back().scope = holder-&gt;scope.blocks;
      holder-&gt;addBlock();
    }
    ~BaseGuard() {
      holder-&gt;bases.pop_back();
      holder-&gt;popBlock();
    }
  };

  /// Set of seen global identifiers used to prevent later creation of local variables
  /// with the same name.
  std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, ExprPtr&gt;&gt;
      seenGlobalIdentifiers;

  /// Set if the standard library is currently being loaded.
  bool isStdlibLoading;
  /// Current module. The default module is named `__main__`.
  ImportFile moduleName;
  /// Tracks if we are in a dependent part of a short-circuiting expression (e.g. b in a
  /// and b) to disallow assignment expressions there.
  bool isConditionalExpr;
  /// Allow type() expressions. Currently used to disallow type() in class
  /// and function definitions.
  bool allowTypeOf;
  /// Set if all assignments should not be dominated later on.
  bool avoidDomination = false;

public:
  SimplifyContext(std::string filename, Cache *cache);

  void add(const std::string &amp;name, const Item &amp;var) override;
  /// Convenience method for adding an object to the context.
  Item addVar(const std::string &amp;name, const std::string &amp;canonicalName,
              const SrcInfo &amp;srcInfo = SrcInfo());
  Item addType(const std::string &amp;name, const std::string &amp;canonicalName,
               const SrcInfo &amp;srcInfo = SrcInfo());
  Item addFunc(const std::string &amp;name, const std::string &amp;canonicalName,
               const SrcInfo &amp;srcInfo = SrcInfo());
  /// Add the item to the standard library module, thus ensuring its visibility from all
  /// modules.
  Item addAlwaysVisible(const Item &amp;item);

  /// Get an item from the context. If the item does not exist, nullptr is returned.
  Item find(const std::string &amp;name) const override;
  /// Get an item that exists in the context. If the item does not exist, assertion is
  /// raised.
  Item forceFind(const std::string &amp;name) const;
  /// Get an item from the context. Perform domination analysis for accessing items
  /// defined in the conditional blocks (i.e., Python scoping).
  Item findDominatingBinding(const std::string &amp;name);

  /// Return a canonical name of the current base.
  /// An empty string represents the toplevel base.
  std::string getBaseName() const;
  /// Return the current module.
  std::string getModule() const;
  /// Pretty-print the current context state.
  void dump() override;

  /// Generate a unique identifier (name) for a given string.
  std::string generateCanonicalName(const std::string &amp;name, bool includeBase = false,
                                    bool zeroId = false) const;
  /// Enter a conditional block.
  void enterConditionalBlock();
  /// Leave a conditional block. Populate stmts (if set) with the declarations of newly
  /// added identifiers that dominate the children blocks.
  void leaveConditionalBlock(std::vector&lt;StmtPtr&gt; *stmts = nullptr);
  /// True if we are at the toplevel.
  bool isGlobal() const;
  /// True if we are within a conditional block.
  bool isConditional() const;
  /// Get the current base.
  Base *getBase();
  /// True if the current base is function.
  bool inFunction() const;
  /// True if the current base is class.
  bool inClass() const;
  /// True if an item is defined outside of the current base or a module.
  bool isOuter(const Item &amp;val) const;
  /// Get the enclosing class base (or nullptr if such does not exist).
  Base *getClassBase();

private:
  /// Pretty-print the current context state.
  void dump(int pad);
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.676">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

/**
 * Visitor that implements the initial AST simplification transformation.
 * In this stage. the following steps are done:
 *  - All imports are flattened resulting in a single self-containing
 *    (and fairly large) AST
 *  - All identifiers are normalized (no two distinct objects share the same name)
 *  - Variadic classes (e.g., Tuple.N) are generated
 *  - Any AST node that can be trivially expressed as a set of "simpler" nodes
 *    type is simplified. If a transformation requires a type information,
 *    it is done during the type checking.
 *
 * -&gt; Note: this stage *modifies* the provided AST. Clone it before simplification
 *    if you need it intact.
 */
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.677">class SimplifyVisitor : public CallbackASTVisitor&lt;ExprPtr, StmtPtr&gt; {
  /// Shared simplification context.
  std::shared_ptr&lt;SimplifyContext&gt; ctx;
  /// Preamble contains definition statements shared across all visitors
  /// in all modules. It is executed before simplified statements.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; preamble;
  /// Statements to prepend before the current statement.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; prependStmts;

  /// Each new expression is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  ExprPtr resultExpr;
  /// Each new statement is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  StmtPtr resultStmt;

public:
  static StmtPtr
  apply(Cache *cache, const StmtPtr &amp;node, const std::string &amp;file,
        const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {},
        const std::unordered_map&lt;std::string, std::string&gt; &amp;earlyDefines = {},
        bool barebones = false);
  static StmtPtr apply(const std::shared_ptr&lt;SimplifyContext&gt; &amp;cache,
                       const StmtPtr &amp;node, const std::string &amp;file, int atAge = -1);

public:
  explicit SimplifyVisitor(
      std::shared_ptr&lt;SimplifyContext&gt; ctx,
      std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; preamble,
      const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts = nullptr);

public: // Convenience transformators
  ExprPtr transform(ExprPtr &amp;expr) override;
  ExprPtr transform(const ExprPtr &amp;expr) override {
    auto e = expr;
    return transform(e);
  }
  ExprPtr transform(ExprPtr &amp;expr, bool allowTypes);
  ExprPtr transform(ExprPtr &amp;&amp;expr, bool allowTypes) {
    return transform(expr, allowTypes);
  }
  ExprPtr transformType(ExprPtr &amp;expr, bool allowTypeOf = true);
  ExprPtr transformType(ExprPtr &amp;&amp;expr, bool allowTypeOf = true) {
    return transformType(expr, allowTypeOf);
  }
  StmtPtr transform(StmtPtr &amp;stmt) override;
  StmtPtr transform(const StmtPtr &amp;stmt) override {
    auto s = stmt;
    return transform(s);
  }
  StmtPtr transformConditionalScope(StmtPtr &amp;stmt);

private: // Node simplification rules
  /* Basic type expressions (basic.cpp) */
  void visit(IntExpr *) override;
  ExprPtr transformInt(IntExpr *);
  void visit(FloatExpr *) override;
  ExprPtr transformFloat(FloatExpr *);
  void visit(StringExpr *) override;
  ExprPtr transformFString(const std::string &amp;);

  /* Identifier access expressions (access.cpp) */
  void visit(IdExpr *) override;
  bool checkCapture(const SimplifyContext::Item &amp;);
  void visit(DotExpr *) override;
  std::pair&lt;size_t, SimplifyContext::Item&gt; getImport(const std::vector&lt;std::string&gt; &amp;);

  /* Collection and comprehension expressions (collections.cpp) */
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  void visit(DictGeneratorExpr *) override;
  StmtPtr transformGeneratorBody(const std::vector&lt;GeneratorBody&gt; &amp;, SuiteStmt *&amp;);

  /* Conditional expression and statements (cond.cpp) */
  void visit(IfExpr *) override;
  void visit(IfStmt *) override;
  void visit(MatchStmt *) override;
  StmtPtr transformPattern(const ExprPtr &amp;, ExprPtr, StmtPtr);

  /* Operators (op.cpp) */
  void visit(UnaryExpr *) override;
  void visit(BinaryExpr *) override;
  void visit(ChainBinaryExpr *) override;
  void visit(IndexExpr *) override;
  void visit(InstantiateExpr *) override;

  /* Calls (call.cpp) */
  void visit(PrintStmt *) override;
  void visit(CallExpr *) override;
  ExprPtr transformSpecialCall(const ExprPtr &amp;, const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformTupleGenerator(const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformNamedTuple(const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformFunctoolsPartial(std::vector&lt;CallExpr::Arg&gt;);

  /* Assignments (assign.cpp) */
  void visit(AssignExpr *) override;
  void visit(AssignStmt *) override;
  StmtPtr transformAssignment(ExprPtr, ExprPtr, ExprPtr = nullptr, bool = false);
  void unpackAssignments(const ExprPtr &amp;, ExprPtr, std::vector&lt;StmtPtr&gt; &amp;);
  void visit(DelStmt *) override;

  /* Imports (import.cpp) */
  void visit(ImportStmt *) override;
  StmtPtr transformSpecialImport(ImportStmt *);
  std::vector&lt;std::string&gt; getImportPath(Expr *, size_t = 0);
  StmtPtr transformCImport(const std::string &amp;, const std::vector&lt;Param&gt; &amp;,
                           const Expr *, const std::string &amp;);
  StmtPtr transformCVarImport(const std::string &amp;, const Expr *, const std::string &amp;);
  StmtPtr transformCDLLImport(const Expr *, const std::string &amp;,
                              const std::vector&lt;Param&gt; &amp;, const Expr *,
                              const std::string &amp;, bool);
  StmtPtr transformPythonImport(Expr *, const std::vector&lt;Param&gt; &amp;, Expr *,
                                const std::string &amp;);
  StmtPtr transformNewImport(const ImportFile &amp;);

  /* Loops (loops.cpp) */
  void visit(ContinueStmt *) override;
  void visit(BreakStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  ExprPtr transformForDecorator(const ExprPtr &amp;);

  /* Errors and exceptions (error.cpp) */
  void visit(AssertStmt *) override;
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(WithStmt *) override;

  /* Functions (function.cpp) */
  void visit(YieldExpr *) override;
  void visit(LambdaExpr *) override;
  void visit(GlobalStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(YieldFromStmt *) override;
  void visit(FunctionStmt *) override;
  ExprPtr makeAnonFn(std::vector&lt;StmtPtr&gt;, const std::vector&lt;std::string&gt; &amp; = {});
  StmtPtr transformPythonDefinition(const std::string &amp;, const std::vector&lt;Param&gt; &amp;,
                                    const Expr *, Stmt *);
  StmtPtr transformLLVMDefinition(Stmt *);
  std::pair&lt;bool, std::string&gt; getDecorator(const ExprPtr &amp;);

  /* Classes (class.cpp) */
  void visit(ClassStmt *) override;
  std::vector&lt;ClassStmt *&gt; parseBaseClasses(std::vector&lt;ExprPtr&gt; &amp;,
                                            std::vector&lt;Param&gt; &amp;, const Attr &amp;,
                                            const std::string &amp;,
                                            const ExprPtr &amp; = nullptr);
  std::pair&lt;StmtPtr, FunctionStmt *&gt; autoDeduceMembers(ClassStmt *,
                                                       std::vector&lt;Param&gt; &amp;);
  std::vector&lt;StmtPtr&gt; getClassMethods(const StmtPtr &amp;s);
  void transformNestedClasses(ClassStmt *, std::vector&lt;StmtPtr&gt; &amp;,
                              std::vector&lt;StmtPtr&gt; &amp;, std::vector&lt;StmtPtr&gt; &amp;);
  StmtPtr codegenMagic(const std::string &amp;, const ExprPtr &amp;, const std::vector&lt;Param&gt; &amp;,
                       bool);

  /* The rest (simplify.cpp) */
  void visit(StmtExpr *) override;
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *expr) override;
  void visit(RangeExpr *) override;
  void visit(SliceExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(SuiteStmt *) override;
  void visit(ExprStmt *) override;
  void visit(CustomStmt *) override;
};

</t>
<t tx="ekr.20230509052845.678"></t>
<t tx="ekr.20230509052845.679">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/translate/translate_ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.68">def create_image_chaos(self, w, h, iterations, filename, rng_seed):
    # Always use the same sequence of random numbers
    # to get reproducible benchmark
    random.seed(rng_seed)

    im = [[1] * h for i in range(w)]
    point = GVector((self.maxx + self.minx) / 2,
                    (self.maxy + self.miny) / 2, 0)
    for _ in range(iterations):
        point = self.transform_point(point)
        x = (point.x - self.minx) / self.width * w
        y = (point.y - self.miny) / self.height * h
        x = int(x)
        y = int(y)
        if x == w:
            x -= 1
        if y == h:
            y -= 1
        im[x][h - y - 1] = 0

    if filename:
        write_ppm(im, filename)


</t>
<t tx="ekr.20230509052845.680">class TranslateVisitor : public CallbackASTVisitor&lt;ir::Value *, ir::Value *&gt; {
  std::shared_ptr&lt;TranslateContext&gt; ctx;
  ir::Value *result;

public:
  explicit TranslateVisitor(std::shared_ptr&lt;TranslateContext&gt; ctx);
  static codon::ir::Func *apply(Cache *cache, const StmtPtr &amp;stmts);

  ir::Value *transform(const ExprPtr &amp;expr) override;
  ir::Value *transform(const StmtPtr &amp;stmt) override;

private:
  void defaultVisit(Expr *expr) override;
  void defaultVisit(Stmt *expr) override;

public:
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;
  void visit(IdExpr *) override;
  void visit(IfExpr *) override;
  void visit(CallExpr *) override;
  void visit(DotExpr *) override;
  void visit(YieldExpr *) override;
  void visit(StmtExpr *) override;
  void visit(PipeExpr *) override;

  void visit(SuiteStmt *) override;
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(ExprStmt *) override;
  void visit(AssignStmt *) override;
  void visit(AssignMemberStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  void visit(IfStmt *) override;
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  @others
};

</t>
<t tx="ekr.20230509052845.681">void visit(CommentStmt *) override {}

private:
ir::types::Type *getType(const types::TypePtr &amp;t);

void transformFunction(types::FuncType *type, FunctionStmt *ast, ir::Func *func);
void transformLLVMFunction(types::FuncType *type, FunctionStmt *ast, ir::Func *func);

template &lt;typename ValueType, typename... Args&gt; ValueType *make(Args &amp;&amp;...args) {
  auto *ret = ctx-&gt;getModule()-&gt;N&lt;ValueType&gt;(std::forward&lt;Args&gt;(args)...);
  return ret;
}
</t>
<t tx="ekr.20230509052845.682">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/cir/types/types.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * IR context object description.
 * This represents an identifier that can be either a function, a class (type), or a
 * variable.
 */
struct TranslateItem {
  enum Kind { Func, Type, Var } kind;
  /// IR handle.
  union {
    codon::ir::Var *var;
    codon::ir::Func *func;
    codon::ir::types::Type *type;
  } handle;
  /// Base function pointer.
  codon::ir::BodiedFunc *base;

  TranslateItem(Kind k, codon::ir::BodiedFunc *base)
      : kind(k), handle{nullptr}, base(base) {}
  const codon::ir::BodiedFunc *getBase() const { return base; }
  codon::ir::Func *getFunc() const { return kind == Func ? handle.func : nullptr; }
  codon::ir::types::Type *getType() const {
    return kind == Type ? handle.type : nullptr;
  }
  codon::ir::Var *getVar() const { return kind == Var ? handle.var : nullptr; }
};

/**
 * A variable table (context) for the IR translation stage.
 */
struct TranslateContext : public Context&lt;TranslateItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;
  /// Stack of function bases.
  std::vector&lt;codon::ir::BodiedFunc *&gt; bases;
  /// Stack of IR series (blocks).
  std::vector&lt;codon::ir::SeriesFlow *&gt; series;
  /// Stack of sequence items for attribute initialization.
  std::vector&lt;std::vector&lt;std::pair&lt;ExprAttr, ir::Value *&gt;&gt;&gt; seqItems;

public:
  TranslateContext(Cache *cache);

  using Context&lt;TranslateItem&gt;::add;
  /// Convenience method for adding an object to the context.
  std::shared_ptr&lt;TranslateItem&gt; add(TranslateItem::Kind kind, const std::string &amp;name,
                                     void *type);
  std::shared_ptr&lt;TranslateItem&gt; find(const std::string &amp;name) const override;
  std::shared_ptr&lt;TranslateItem&gt; forceFind(const std::string &amp;name) const;

  /// Convenience method for adding a series.
  void addSeries(codon::ir::SeriesFlow *s);
  void popSeries();

public:
  codon::ir::Module *getModule() const;
  codon::ir::BodiedFunc *getBase() const;
  codon::ir::SeriesFlow *getSeries() const;
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.683"></t>
<t tx="ekr.20230509052845.684">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * Typecheck context identifier.
 * Can be either a function, a class (type), or a variable.
 */
struct TypecheckItem {
  /// Identifier kind
  enum Kind { Func, Type, Var } kind;
  /// Type
  types::TypePtr type;

  TypecheckItem(Kind k, types::TypePtr type) : kind(k), type(std::move(type)) {}

  /* Convenience getters */
  bool isType() const { return kind == Type; }
  bool isVar() const { return kind == Var; }
};

/** Context class that tracks identifiers during the typechecking. **/
struct TypeContext : public Context&lt;TypecheckItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;

  /// A realization base definition. Each function realization defines a new base scope.
  /// Used to properly realize enclosed functions and to prevent mess with mutually
  /// recursive enclosed functions.
  struct RealizationBase {
    /// Function name
    std::string name;
    /// Function type
    types::TypePtr type;
    /// The return type of currently realized function
    types::TypePtr returnType = nullptr;
    /// Typechecking iteration
    int iteration = 0;
  };
  std::vector&lt;RealizationBase&gt; realizationBases;

  /// The current type-checking level (for type instantiation and generalization).
  int typecheckLevel;
  std::set&lt;types::TypePtr&gt; pendingDefaults;
  int changedNodes;

  /// The age of the currently parsed statement.
  int age;
  /// Number of nested realizations. Used to prevent infinite instantiations.
  int realizationDepth;
  /// Nested default argument calls. Used to prevent infinite CallExpr chains
  /// (e.g. class A: def __init__(a: A = A())).
  std::set&lt;std::string&gt; defaultCallDepth;

  /// Number of nested blocks (0 for toplevel)
  int blockLevel;
  /// True if an early return is found (anything afterwards won't be typechecked)
  bool returnEarly;
  /// Stack of static loop control variables (used to emulate goto statements).
  std::vector&lt;std::string&gt; staticLoops;

public:
  explicit TypeContext(Cache *cache);

  using Context&lt;TypecheckItem&gt;::add;
  /// Convenience method for adding an object to the context.
  std::shared_ptr&lt;TypecheckItem&gt; add(TypecheckItem::Kind kind, const std::string &amp;name,
                                     const types::TypePtr &amp;type = nullptr);
  std::shared_ptr&lt;TypecheckItem&gt;
  addToplevel(const std::string &amp;name, const std::shared_ptr&lt;TypecheckItem&gt; &amp;item) {
    map[name].push_front(item);
    return item;
  }
  std::shared_ptr&lt;TypecheckItem&gt; find(const std::string &amp;name) const override;
  /// Find an internal type. Assumes that it exists.
  std::shared_ptr&lt;TypecheckItem&gt; forceFind(const std::string &amp;name) const;
  types::TypePtr getType(const std::string &amp;name) const;

  /// Pretty-print the current context state.
  void dump() override { dump(0); }

public:
  /// Get the current realization depth (i.e., the number of nested realizations).
  size_t getRealizationDepth() const;
  /// Get the current base.
  RealizationBase *getRealizationBase();
  /// Get the name of the current realization stack (e.g., `fn1:fn2:...`).
  std::string getRealizationStackName() const;

public:
  /// Create an unbound type with the provided typechecking level.
  std::shared_ptr&lt;types::LinkType&gt; getUnbound(const SrcInfo &amp;info, int level) const;
  std::shared_ptr&lt;types::LinkType&gt; getUnbound(const SrcInfo &amp;info) const;
  std::shared_ptr&lt;types::LinkType&gt; getUnbound() const;

  /// Call `type-&gt;instantiate`.
  /// Prepare the generic instantiation table with the given generics parameter.
  /// Example: when instantiating List[T].foo, generics=List[int].foo will ensure that
  ///          T=int.
  /// @param expr Expression that needs the type. Used to set type's srcInfo.
  /// @param setActive If True, add unbounds to activeUnbounds.
  types::TypePtr instantiate(const SrcInfo &amp;info, const types::TypePtr &amp;type,
                             const types::ClassTypePtr &amp;generics = nullptr);
  types::TypePtr instantiate(types::TypePtr type,
@others
  /// Returns the list of generic methods that correspond to typeName.method.
  std::vector&lt;types::FuncTypePtr&gt; findMethod(const std::string &amp;typeName,
                                             const std::string &amp;method,
                                             bool hideShadowed = true) const;
  /// Returns the generic type of typeName.member, if it exists (nullptr otherwise).
  /// Special cases: __elemsize__ and __atomic__.
  types::TypePtr findMember(const std::string &amp;typeName,
                            const std::string &amp;member) const;

  using ReorderDoneFn =
      std::function&lt;int(int, int, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;, bool)&gt;;
  using ReorderErrorFn = std::function&lt;int(error::Error, const SrcInfo &amp;, std::string)&gt;;
  /// Reorders a given vector or named arguments (consisting of names and the
  /// corresponding types) according to the signature of a given function.
  /// Returns the reordered vector and an associated reordering score (missing
  /// default arguments' score is half of the present arguments).
  /// Score is -1 if the given arguments cannot be reordered.
  /// @param known Bitmask that indicated if an argument is already provided
  ///              (partial function) or not.
  int reorderNamedArgs(types::FuncType *func, const std::vector&lt;CallExpr::Arg&gt; &amp;args,
                       const ReorderDoneFn &amp;onDone, const ReorderErrorFn &amp;onError,
                       const std::vector&lt;char&gt; &amp;known = std::vector&lt;char&gt;());

private:
  /// Pretty-print the current context state.
  void dump(int pad);
  /// Pretty-print the current realization context.
  std::string debugInfo();

public:
  std::shared_ptr&lt;std::pair&lt;std::vector&lt;types::TypePtr&gt;, std::vector&lt;types::TypePtr&gt;&gt;&gt;
  getFunctionArgs(types::TypePtr t);
  std::shared_ptr&lt;std::string&gt; getStaticString(types::TypePtr t);
  std::shared_ptr&lt;int64_t&gt; getStaticInt(types::TypePtr t);
  types::FuncTypePtr extractFunction(types::TypePtr t);
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.685">                             const types::ClassTypePtr &amp;generics = nullptr) {
    return instantiate(getSrcInfo(), std::move(type), generics);
  }

</t>
<t tx="ekr.20230509052845.686">  /// Instantiate the generic type root with the provided generics.
  /// @param expr Expression that needs the type. Used to set type's srcInfo.
  types::TypePtr instantiateGeneric(const SrcInfo &amp;info, const types::TypePtr &amp;root,
                                    const std::vector&lt;types::TypePtr&gt; &amp;generics);
  types::TypePtr instantiateGeneric(types::TypePtr root,
</t>
<t tx="ekr.20230509052845.687">                                    const std::vector&lt;types::TypePtr&gt; &amp;generics) {
    return instantiateGeneric(getSrcInfo(), std::move(root), generics);
  }

</t>
<t tx="ekr.20230509052845.688">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

/**
 * Visitor that infers expression types and performs type-guided transformations.
 *
 * -&gt; Note: this stage *modifies* the provided AST. Clone it before simplification
 *    if you need it intact.
 */
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.689">class TypecheckVisitor : public CallbackASTVisitor&lt;ExprPtr, StmtPtr&gt; {
  /// Shared simplification context.
  std::shared_ptr&lt;TypeContext&gt; ctx;
  /// Statements to prepend before the current statement.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; prependStmts;

  /// Each new expression is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  ExprPtr resultExpr;
  /// Each new statement is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  StmtPtr resultStmt;

public:
  static StmtPtr apply(Cache *cache, const StmtPtr &amp;stmts);

public:
  explicit TypecheckVisitor(
      std::shared_ptr&lt;TypeContext&gt; ctx,
      const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts = nullptr);

public: // Convenience transformators
  ExprPtr transform(ExprPtr &amp;e) override;
  ExprPtr transform(const ExprPtr &amp;expr) override {
    auto e = expr;
    return transform(e);
  }
  StmtPtr transform(StmtPtr &amp;s) override;
  StmtPtr transform(const StmtPtr &amp;stmt) override {
    auto s = stmt;
    return transform(s);
  }
  ExprPtr transformType(ExprPtr &amp;expr);
  ExprPtr transformType(const ExprPtr &amp;expr) {
    auto e = expr;
    return transformType(e);
  }

private:
  void defaultVisit(Expr *e) override;
  void defaultVisit(Stmt *s) override;

private: // Node typechecking rules
  /* Basic type expressions (basic.cpp) */
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;

  /* Identifier access expressions (access.cpp) */
  void visit(IdExpr *) override;
  void visit(DotExpr *) override;
  ExprPtr transformDot(DotExpr *, std::vector&lt;CallExpr::Arg&gt; * = nullptr);
  ExprPtr getClassMember(DotExpr *, std::vector&lt;CallExpr::Arg&gt; *);
  types::TypePtr findSpecialMember(const std::string &amp;);
  types::FuncTypePtr getBestOverload(Expr *, std::vector&lt;CallExpr::Arg&gt; *);
  types::FuncTypePtr getDispatch(const std::string &amp;);

  /* Collection and comprehension expressions (collections.cpp) */
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  ExprPtr transformComprehension(const std::string &amp;, const std::string &amp;,
                                 std::vector&lt;ExprPtr&gt; &amp;);

  /* Conditional expression and statements (cond.cpp) */
  void visit(IfExpr *) override;
  void visit(IfStmt *) override;

  /* Operators (op.cpp) */
  void visit(UnaryExpr *) override;
  ExprPtr evaluateStaticUnary(UnaryExpr *);
  void visit(BinaryExpr *) override;
  ExprPtr evaluateStaticBinary(BinaryExpr *);
  ExprPtr transformBinarySimple(BinaryExpr *);
  ExprPtr transformBinaryIs(BinaryExpr *);
  std::pair&lt;std::string, std::string&gt; getMagic(const std::string &amp;);
  ExprPtr transformBinaryInplaceMagic(BinaryExpr *, bool);
  ExprPtr transformBinaryMagic(BinaryExpr *);
  void visit(PipeExpr *) override;
  void visit(IndexExpr *) override;
  std::pair&lt;bool, ExprPtr&gt; transformStaticTupleIndex(const types::ClassTypePtr &amp;,
                                                     const ExprPtr &amp;, const ExprPtr &amp;);
  int64_t translateIndex(int64_t, int64_t, bool = false);
  int64_t sliceAdjustIndices(int64_t, int64_t *, int64_t *, int64_t);
  void visit(InstantiateExpr *) override;
  void visit(SliceExpr *) override;

  /* Calls (call.cpp) */
  /// Holds partial call information for a CallExpr.
  struct PartialCallData {
    bool isPartial = false;                   // true if the call is partial
    std::string var;                          // set if calling a partial type itself
    std::vector&lt;char&gt; known = {};             // mask of known arguments
    ExprPtr args = nullptr, kwArgs = nullptr; // partial *args/**kwargs expressions
  };
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(CallExpr *) override;
  bool transformCallArgs(std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::pair&lt;types::FuncTypePtr, ExprPtr&gt; getCalleeFn(CallExpr *, PartialCallData &amp;);
  ExprPtr callReorderArguments(types::FuncTypePtr, CallExpr *, PartialCallData &amp;);
  bool typecheckCallArgs(const types::FuncTypePtr &amp;, std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::pair&lt;bool, ExprPtr&gt; transformSpecialCall(CallExpr *);
  ExprPtr transformSuperF(CallExpr *expr);
  ExprPtr transformSuper();
  ExprPtr transformPtr(CallExpr *expr);
  ExprPtr transformArray(CallExpr *expr);
  ExprPtr transformIsInstance(CallExpr *expr);
  ExprPtr transformStaticLen(CallExpr *expr);
  ExprPtr transformHasAttr(CallExpr *expr);
  ExprPtr transformGetAttr(CallExpr *expr);
  ExprPtr transformSetAttr(CallExpr *expr);
  ExprPtr transformCompileError(CallExpr *expr);
  ExprPtr transformTupleFn(CallExpr *expr);
  ExprPtr transformTypeFn(CallExpr *expr);
  ExprPtr transformRealizedFn(CallExpr *expr);
  ExprPtr transformStaticPrintFn(CallExpr *expr);
  std::pair&lt;bool, ExprPtr&gt; transformInternalStaticFn(CallExpr *expr);
  std::vector&lt;types::ClassTypePtr&gt; getSuperTypes(const types::ClassTypePtr &amp;cls);
  void addFunctionGenerics(const types::FuncType *t);
  std::string generatePartialStub(const std::vector&lt;char&gt; &amp;mask, types::FuncType *fn);

  /* Assignments (assign.cpp) */
  void visit(AssignStmt *) override;
  void transformUpdate(AssignStmt *);
  void visit(AssignMemberStmt *) override;
  std::pair&lt;bool, ExprPtr&gt; transformInplaceUpdate(AssignStmt *);

  /* Loops (loops.cpp) */
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  StmtPtr transformHeterogenousTupleFor(ForStmt *);
  StmtPtr transformStaticForLoop(ForStmt *);

  /* Errors and exceptions (error.cpp) */
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;

  /* Functions (function.cpp) */
  void visit(YieldExpr *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(FunctionStmt *) override;
  ExprPtr partializeFunction(const types::FuncTypePtr &amp;);
  std::shared_ptr&lt;types::RecordType&gt; getFuncTypeBase(size_t);

  /* Classes (class.cpp) */
  void visit(ClassStmt *) override;
  void parseBaseClasses(ClassStmt *);
  std::string generateTuple(size_t, const std::string &amp; = TYPE_TUPLE,
                            std::vector&lt;std::string&gt; = {}, bool = true);

  /* The rest (typecheck.cpp) */
  void visit(SuiteStmt *) override;
  void visit(ExprStmt *) override;
  void visit(StmtExpr *) override;
  void visit(CommentStmt *stmt) override;

private:
  /* Type inference (infer.cpp) */
  types::TypePtr unify(types::TypePtr &amp;a, const types::TypePtr &amp;b);
  types::TypePtr unify(types::TypePtr &amp;&amp;a, const types::TypePtr &amp;b) {
    auto x = a;
    return unify(x, b);
  }
  StmtPtr inferTypes(StmtPtr, bool isToplevel = false);
  types::TypePtr realize(types::TypePtr);
  types::TypePtr realizeFunc(types::FuncType *, bool = false);
  types::TypePtr realizeType(types::ClassType *);
  std::shared_ptr&lt;FunctionStmt&gt; generateSpecialAst(types::FuncType *);
  size_t getRealizationID(types::ClassType *, types::FuncType *);
  codon::ir::types::Type *makeIRType(types::ClassType *);
  codon::ir::Func *
  makeIRFunction(const std::shared_ptr&lt;Cache::Function::FunctionRealization&gt; &amp;);

private:
  types::FuncTypePtr findBestMethod(const types::ClassTypePtr &amp;typ,
                                    const std::string &amp;member,
                                    const std::vector&lt;types::TypePtr&gt; &amp;args);
  types::FuncTypePtr findBestMethod(const types::ClassTypePtr &amp;typ,
                                    const std::string &amp;member,
                                    const std::vector&lt;ExprPtr&gt; &amp;args);
  types::FuncTypePtr
  findBestMethod(const types::ClassTypePtr &amp;typ, const std::string &amp;member,
                 const std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt; &amp;args);
  int canCall(const types::FuncTypePtr &amp;, const std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::vector&lt;types::FuncTypePtr&gt;
  findMatchingMethods(const types::ClassTypePtr &amp;typ,
                      const std::vector&lt;types::FuncTypePtr&gt; &amp;methods,
                      const std::vector&lt;CallExpr::Arg&gt; &amp;args);
  bool wrapExpr(ExprPtr &amp;expr, const types::TypePtr &amp;expectedType,
                const types::FuncTypePtr &amp;callee = nullptr, bool allowUnwrap = true);
  ExprPtr castToSuperClass(ExprPtr expr, types::ClassTypePtr superTyp, bool = false);
  StmtPtr prepareVTables();

public:
  bool isTuple(const std::string &amp;s) const { return startswith(s, TYPE_TUPLE); }

  friend class Cache;
  friend class types::CallableTrait;
  friend class types::UnionType;

private: // Helpers
  std::shared_ptr&lt;std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt;&gt;
      unpackTupleTypes(ExprPtr);
  std::pair&lt;bool, std::vector&lt;std::shared_ptr&lt;codon::SrcObject&gt;&gt;&gt;
  transformStaticLoopCall(const std::vector&lt;std::string&gt; &amp;, ExprPtr,
                          std::function&lt;std::shared_ptr&lt;codon::SrcObject&gt;(StmtPtr)&gt;);
};

</t>
<t tx="ekr.20230509052845.69">def main():
    splines = [
        Spline([
            GVector(1.597350, 3.304460, 0.000000),
            GVector(1.575810, 4.123260, 0.000000),
            GVector(1.313210, 5.288350, 0.000000),
            GVector(1.618900, 5.329910, 0.000000),
            GVector(2.889940, 5.502700, 0.000000),
            GVector(2.373060, 4.381830, 0.000000),
            GVector(1.662000, 4.360280, 0.000000)],
            3, [0, 0, 0, 1, 1, 1, 2, 2, 2]),
        Spline([
            GVector(2.804500, 4.017350, 0.000000),
            GVector(2.550500, 3.525230, 0.000000),
            GVector(1.979010, 2.620360, 0.000000),
            GVector(1.979010, 2.620360, 0.000000)],
            3, [0, 0, 0, 1, 1, 1]),
        Spline([
            GVector(2.001670, 4.011320, 0.000000),
            GVector(2.335040, 3.312830, 0.000000),
            GVector(2.366800, 3.233460, 0.000000),
            GVector(2.366800, 3.233460, 0.000000)],
            3, [0, 0, 0, 1, 1, 1])
    ]

    chaos = Chaosgame(splines, DEFAULT_THICKNESS)
    chaos.create_image_chaos(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_ITERATIONS, sys.argv[1], DEFAULT_RNG_SEED)

</t>
<t tx="ekr.20230509052845.690"></t>
<t tx="ekr.20230509052845.691">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;unwind.h&gt;

#define SEQ_FLAG_DEBUG (1 &lt;&lt; 0)          // compiled/running in debug mode
#define SEQ_FLAG_CAPTURE_OUTPUT (1 &lt;&lt; 1) // capture writes to stdout/stderr
#define SEQ_FLAG_STANDALONE (1 &lt;&lt; 2)     // compiled as a standalone object/binary

#define SEQ_FUNC extern "C"

typedef int64_t seq_int_t;

struct seq_str_t {
  seq_int_t len;
  char *str;
};

struct seq_time_t {
  int16_t year;
  int16_t yday;
  int8_t sec;
  int8_t min;
  int8_t hour;
  int8_t mday;
  int8_t mon;
  int8_t wday;
  int8_t isdst;
};

SEQ_FUNC int seq_flags;

SEQ_FUNC void seq_init(int flags);

SEQ_FUNC bool seq_is_macos();
SEQ_FUNC seq_int_t seq_pid();
SEQ_FUNC seq_int_t seq_time();
SEQ_FUNC seq_int_t seq_time_monotonic();
SEQ_FUNC seq_int_t seq_time_highres();
SEQ_FUNC bool seq_localtime(seq_int_t secs, seq_time_t *output);
SEQ_FUNC bool seq_gmtime(seq_int_t secs, seq_time_t *output);
SEQ_FUNC seq_int_t seq_mktime(seq_time_t *time);
SEQ_FUNC void seq_sleep(double secs);
SEQ_FUNC char **seq_env();
SEQ_FUNC void seq_assert_failed(seq_str_t file, seq_int_t line);

SEQ_FUNC void *seq_alloc(size_t n);
SEQ_FUNC void *seq_alloc_atomic(size_t n);
SEQ_FUNC void *seq_calloc(size_t m, size_t n);
SEQ_FUNC void *seq_calloc_atomic(size_t m, size_t n);
SEQ_FUNC void *seq_realloc(void *p, size_t newsize, size_t oldsize);
SEQ_FUNC void seq_free(void *p);
SEQ_FUNC void seq_register_finalizer(void *p, void (*f)(void *obj, void *data));

SEQ_FUNC void seq_gc_add_roots(void *start, void *end);
SEQ_FUNC void seq_gc_remove_roots(void *start, void *end);
SEQ_FUNC void seq_gc_clear_roots();
SEQ_FUNC void seq_gc_exclude_static_roots(void *start, void *end);

SEQ_FUNC void *seq_alloc_exc(int type, void *obj);
SEQ_FUNC void seq_throw(void *exc);
SEQ_FUNC _Unwind_Reason_Code seq_personality(int version, _Unwind_Action actions,
                                             uint64_t exceptionClass,
                                             _Unwind_Exception *exceptionObject,
                                             _Unwind_Context *context);
SEQ_FUNC int64_t seq_exc_offset();
SEQ_FUNC uint64_t seq_exc_class();

SEQ_FUNC seq_str_t seq_str_int(seq_int_t n, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_uint(seq_int_t n, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_float(double f, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_ptr(void *p, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_str(seq_str_t s, seq_str_t format, bool *error);

SEQ_FUNC void *seq_stdin();
SEQ_FUNC void *seq_stdout();
SEQ_FUNC void *seq_stderr();

SEQ_FUNC void seq_print(seq_str_t str);
SEQ_FUNC void seq_print_full(seq_str_t str, FILE *fo);

SEQ_FUNC void *seq_lock_new();
SEQ_FUNC void *seq_lock_new();
SEQ_FUNC bool seq_lock_acquire(void *lock, bool block, double timeout);
SEQ_FUNC void seq_lock_release(void *lock);
SEQ_FUNC void *seq_rlock_new();
SEQ_FUNC bool seq_rlock_acquire(void *lock, bool block, double timeout);
SEQ_FUNC void seq_rlock_release(void *lock);

namespace codon {
namespace runtime {
@others
std::string makeBacktraceFrameString(uintptr_t pc, const std::string &amp;func = "",
                                     const std::string &amp;file = "", int line = 0,
                                     int col = 0);

std::string getCapturedOutput();

void setJITErrorCallback(std::function&lt;void(const JITError &amp;)&gt; callback);
} // namespace runtime
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.692">class JITError : public std::runtime_error {
private:
  std::string output;
  std::string type;
  std::string file;
  int line;
  int col;
  std::vector&lt;uintptr_t&gt; backtrace;

public:
  JITError(const std::string &amp;output, const std::string &amp;what, const std::string &amp;type,
           const std::string &amp;file, int line, int col,
           std::vector&lt;uintptr_t&gt; backtrace = {})
      : std::runtime_error(what), output(output), type(type), file(file), line(line),
        col(col), backtrace(std::move(backtrace)) {}

  std::string getOutput() const { return output; }
  std::string getType() const { return type; }
  std::string getFile() const { return file; }
  int getLine() const { return line; }
  int getCol() const { return col; }
  std::vector&lt;uintptr_t&gt; getBacktrace() const { return backtrace; }
};

</t>
<t tx="ekr.20230509052845.693"></t>
<t tx="ekr.20230509052845.694">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;chrono&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;
#include &lt;fmt/ranges.h&gt;
#include &lt;fmt/std.h&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

#include "codon/compiler/error.h"
#include "codon/config/config.h"
#include "codon/parser/ast/error.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-zero-variadic-macro-arguments"

#define DBG(c, ...)                                                                    \
  fmt::print(codon::getLogger().log, "{}" c "\n",                                      \
             std::string(2 * codon::getLogger().level, ' '), ##__VA_ARGS__)
#define LOG(c, ...) DBG(c, ##__VA_ARGS__)
#define LOG_TIME(c, ...)                                                               \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_TIME)                           \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_REALIZE(c, ...)                                                            \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_REALIZE)                        \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_TYPECHECK(c, ...)                                                          \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_TYPECHECK)                      \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_IR(c, ...)                                                                 \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_IR)                             \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_USER(c, ...)                                                               \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER)                           \
      DBG(c, ##__VA_ARGS__);                                                           \
  }

#define TIME(name) codon::Timer __timer(name)

#ifndef NDEBUG
#define seqassertn(expr, msg, ...)                                                     \
  ((expr) ? (void)(0)                                                                  \
          : codon::assertionFailure(#expr, __FILE__, __LINE__,                         \
                                    fmt::format(msg, ##__VA_ARGS__)))
#define seqassert(expr, msg, ...)                                                      \
  ((expr) ? (void)(0)                                                                  \
          : codon::assertionFailure(                                                   \
                #expr, __FILE__, __LINE__,                                             \
                fmt::format(msg " [{}]", ##__VA_ARGS__, getSrcInfo())))
#else
#define seqassertn(expr, msg, ...) ;
#define seqassert(expr, msg, ...) ;
#endif
#pragma clang diagnostic pop

namespace codon {

@others
enum MessageGroupPos {
  NONE = 0,
  HEAD,
  MID,
  LAST,
};

void compilationError(const std::string &amp;msg, const std::string &amp;file = "",
                      int line = 0, int col = 0, int len = 0, int errorCode = -1,
                      bool terminate = true, MessageGroupPos pos = NONE);

void compilationWarning(const std::string &amp;msg, const std::string &amp;file = "",
                        int line = 0, int col = 0, int len = 0, int errorCode = -1,
                        bool terminate = false, MessageGroupPos pos = NONE);

} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::SrcInfo&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.695">void assertionFailure(const char *expr_str, const char *file, int line,
                      const std::string &amp;msg);

struct Logger {
  static constexpr int FLAG_TIME = (1 &lt;&lt; 0);
  static constexpr int FLAG_REALIZE = (1 &lt;&lt; 1);
  static constexpr int FLAG_TYPECHECK = (1 &lt;&lt; 2);
  static constexpr int FLAG_IR = (1 &lt;&lt; 3);
  static constexpr int FLAG_USER = (1 &lt;&lt; 4);

  int flags;
  int level;
  std::ostream &amp;out;
  std::ostream &amp;err;
  std::ostream &amp;log;

  Logger() : flags(0), level(0), out(std::cout), err(std::cerr), log(std::clog) {}

  void parse(const std::string &amp;logs);
};

</t>
<t tx="ekr.20230509052845.696">Logger &amp;getLogger();
void pushLogger();
bool popLogger();

</t>
<t tx="ekr.20230509052845.697">class Timer {
private:
  using clock_type = std::chrono::high_resolution_clock;
  std::string name;
  std::chrono::time_point&lt;clock_type&gt; start, end;

public:
  bool logged;

public:
@others
  Timer(std::string name) : name(std::move(name)), start(), end(), logged(false) {
    start = clock_type::now();
  }

  ~Timer() { log(); }
};

</t>
<t tx="ekr.20230509052845.698">  void log() {
    if (!logged) {
      LOG_TIME("[T] {} = {:.3f}", name, elapsed());
      logged = true;
    }
  }

</t>
<t tx="ekr.20230509052845.699">  double elapsed(std::chrono::time_point&lt;clock_type&gt; end = clock_type::now()) const {
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() /
           1000.0;
  }

</t>
<t tx="ekr.20230509052845.7">def check_tree(node):
    l, r = node.left, node.right
    if l is None:
        return 1
    else:
        return 1 + check_tree(l) + check_tree(r)

</t>
<t tx="ekr.20230509052845.70"></t>
<t tx="ekr.20230509052845.700">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const codon::SrcInfo &amp;src);

struct SrcObject {
private:
  SrcInfo info;

public:
  SrcObject() : info() {}
  SrcObject(const SrcObject &amp;s) { setSrcInfo(s.getSrcInfo()); }

  virtual ~SrcObject() = default;

  SrcInfo getSrcInfo() const { return info; }

  void setSrcInfo(SrcInfo info) { this-&gt;info = std::move(info); }
};
template &lt;class... TA&gt; void E(error::Error e, codon::SrcObject *o, const TA &amp;...args) {
  E(e, o-&gt;getSrcInfo(), args...);
}
</t>
<t tx="ekr.20230509052845.701">template &lt;class... TA&gt;
void E(error::Error e, const codon::SrcObject &amp;o, const TA &amp;...args) {
  E(e, o.getSrcInfo(), args...);
}
</t>
<t tx="ekr.20230509052845.702">template &lt;class... TA&gt;
void E(error::Error e, const std::shared_ptr&lt;SrcObject&gt; &amp;o, const TA &amp;...args) {
  E(e, o-&gt;getSrcInfo(), args...);
}

</t>
<t tx="ekr.20230509052845.703">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {
int startJupyterKernel(const std::string &amp;argv0,
                       const std::vector&lt;std::string&gt; &amp;plugins,
                       const std::string &amp;configPath);
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.704"></t>
<t tx="ekr.20230509052845.705">@path C:/Repos/codon/docs/
#%%
import json
import itertools
import os
import os.path
import sys
import subprocess as sp
import collections
from pprint import pprint

from sphinxcontrib.napoleon.docstring import GoogleDocstring
from sphinxcontrib.napoleon import Config

napoleon_config=Config(napoleon_use_param=True,napoleon_use_rtype=True)

root=os.path.abspath(sys.argv[1])
print(f"Generating documentation for {root}...")


@others
# 3. Create documentation for each module
for directory,(name,mid) in {(d,m) for d,mm in parsed_modules.items() for m in mm}:
    module=directory.replace('/','.')+f".{name}"

    file,mode=f'stdlib/{directory}/{name}.rst','w'
    if os.path.isdir(f'{root}/{directory}/{name}'):
        continue
    if name=='__init__':
        file,mode=f'stdlib/{directory}/index.rst','a'
    with open(file,mode) as f:
        print(f".. codon:module:: {module}\n",file=f)
        print(f":codon:mod:`{module}`",file=f)
        print("-"*(len(module)+13)+"\n",file=f)
        directory_prefix=directory+'/' if directory!='.' else ''
        print(f"Source code: `{directory_prefix}{name}.codon &lt;https://github.com/exaloop/codon/blob/master/stdlib/{directory}/{name}.codon&gt;`_\n",file=f)
        if 'doc' in j[mid]:
            print(parse_docstr(j[mid]['doc']),file=f)

        for i in j[mid]['children']:
            v=j[i]

            if v['kind']=='class' and v['type']=='extension':
                v['name']=j[v['parent']]['name']
            if v['name'].startswith('_'):
                continue

            if v['kind']=='class':
                if v['name'].endswith('Error'):
                    v["type"]="exception"
                f.write(f'.. codon:{v["type"]}:: {v["name"]}')
                if 'generics' in v and v['generics']:
                    f.write(f'[{",".join(v["generics"])}]')
            elif v['kind']=='function':
                f.write(f'.. codon:function:: {v["name"]}{parse_fn(v)}')
            elif v['kind']=='variable':
                f.write(f'.. codon:data:: {v["name"]}')
            # if v['kind'] == 'class' and v['type'] == 'extension':
            #     f.write(f'**`{getLink(v["parent"])}`**')
            # else:
            # f.write(f'{m}.**`{v["name"]}`**')
            f.write("\n")

            # f.write("\n")
            # if v['kind'] == 'function' and 'attrs' in v and v['attrs']:
            #     f.write("**Attributes:**" + ', '.join(f'`{x}`' for x in v['attrs']))
            #     f.write("\n")
            if 'doc' in v:
                f.write("\n"+parse_docstr(v['doc'])+"\n")
            f.write("\n")

            if v['kind']=='class':
                # if 'args' in v and any(c['name'][0] != '_' for c in v['args']):
                #     f.write('#### Arguments:\n')
                #     for c in v['args']:
                #         if c['name'][0] == '_':
                #             continue
                #         f.write(f'- **`{c["name"]} : `**')
                #         f.write(parse_type(c["type"]) + "\n")
                #         if 'doc' in c:
                #             f.write(parse_docstr(c['doc'], 1) + "\n")
                #         f.write("\n")

                mt=[c for c in v['members'] if j[c]['kind']=='function']

                props=[c for c in mt if 'property' in j[c].get('attrs',[])]
                if props:
                    print('   **Properties:**\n',file=f)
                    for c in props:
                        v=j[c]
                        f.write(f'      .. codon:attribute:: {v["name"]}\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")

                magics=[c for c in mt if len(j[c]['name'])&gt;4 and j[c]['name'].startswith('__') and j[c]['name'].endswith('__')]
                if magics:
                    print('   **Magic methods:**\n',file=f)
                    for c in magics:
                        v=j[c]
                        f.write(f'      .. codon:method:: {v["name"]}{parse_fn(v,True)}\n')
                        f.write('         :noindex:\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")
                methods=[c for c in mt if j[c]['name'][0]!='_' and c not in props]
                if methods:
                    print('   **Methods:**\n',file=f)
                    for c in methods:
                        v=j[c]
                        f.write(f'      .. codon:method:: {v["name"]}{parse_fn(v,True)}\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")
            f.write("\n\n")

        f.write("\n\n")
print(f" - Done with modules")
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.706"># 1. Call codon -docstr and get a documentation in JSON format
def load_json(directory):
    # Get all codon files in the directory
    files=[]
    for root,_,items in os.walk(directory):
        for f in items:
            if f.endswith('.codon') and "__init_test__.codon" not in f:
                files.append(os.path.abspath(os.path.join(root,f)))
    files='\n'.join(files)
    s=sp.run(['../../build/codon','doc'],stdout=sp.PIPE,input=files.encode('utf-8'))
    if s.returncode!=0:
        raise ValueError('codon failed')
    return json.loads(s.stdout.decode('utf-8'))


</t>
<t tx="ekr.20230509052845.707">j=load_json(root)
print(f" - Done with codon")
sys.exit(0)
# with open('x.json','w') as f:
#     json.dump(j,f,indent=2)

# 2. Get the list of modules and create the documentation tree
modules={k:v["path"] for k,v in j.items() if v["kind"]=="module"}
prefix=os.path.commonprefix(list(modules.values()))
parsed_modules=collections.defaultdict(set)
os.system("rm -rf stdlib/*")
for mid,module in modules.items():
    while module!=root:
        directory,name=os.path.split(module)
        print(root,mid,module)
        directory=os.path.relpath(directory,root)  # remove the prefix
        os.makedirs(f"stdlib/{directory}",exist_ok=True)
        if name.endswith('.codon'):
            name=name[:-6] # drop suffix
        if name!='__init__':
            parsed_modules[directory].add((name,mid))
        module=os.path.split(module)[0]
for directory,modules in parsed_modules.items():
    module=directory.replace('/','.')
    with open(f'stdlib/{directory}/index.rst','w') as f:
        if module!='.':
            print(f".. codon:module:: {module}\n",file=f)
            print(f"{module}",file=f)
        else:
            print("Standard Library Reference",file=f)
        print(f"========\n",file=f)

        print(".. toctree::\n",file=f)
        for m in sorted(set(m for m,_ in modules)):
            if os.path.isdir(f'{root}/{directory}/{m}'):
                print(f"   {m}/index",file=f)
            else:
                print(f"   {m}",file=f)
print(f" - Done with directory tree")


</t>
<t tx="ekr.20230509052845.708">def parse_docstr(s,level=1):
    """Parse docstr s and indent it with level spaces"""
    lines=GoogleDocstring(s,napoleon_config).lines()
    if isinstance(lines,str):  # Napoleon failed
        s=s.split('\n')
        while s and s[0]=='':
            s=s[1:]
        while s and s[-1]=='':
            s=s[:-1]
        if not s:
            return ''
        i=0
        indent=len(list(itertools.takewhile(lambda i:i==' ',s[0])))
        lines=[l[indent:] for l in s]
    return '\n'.join(('   '*level)+l for l in lines)


</t>
<t tx="ekr.20230509052845.709">def parse_type(a):
    """Parse type signature"""
    s=''
    if isinstance(a,list):
        head,tail=a[0],a[1:]
    else:
        head,tail=a,[]
    s+=j[head]["name"] if head[0].isdigit() else head
    if tail:
        for ti,t in enumerate(tail):
            s+="[" if not ti else ", "
            s+=parse_type(t)
        s+="]"
    return s


</t>
<t tx="ekr.20230509052845.71">@path C:/Repos/codon/bench/fannkuch/
# FANNKUCH benchmark
from math import factorial as fact
from sys import argv
from time import time

@others
n = int(argv[1])
max_flips = 0

t0 = time()
@par(schedule='dynamic', num_threads=4)
for idx in range(fact(n)):
    p = perm(n, idx)
    flips = 0
    k = p[0]

    while k:
        i = 0
        j = k
        while i &lt; j:
            p[i], p[j] = p[j], p[i]
            i += 1
            j -= 1

        k = p[0]
        flips += 1

    max_flips = max(flips, max_flips)

print(f'Pfannkuchen({n}) = {max_flips}')
t1 = time()
print(t1 - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.710">def parse_fn(v,skip_self=False,skip_braces=False):
    """Parse function signature after the name"""
    s=""
    if 'generics' in v and v['generics']:
        s+=f'[{", ".join(v["generics"])}]'
    if not skip_braces:
        s+="("
    cnt=0
    for ai,a in enumerate(v['args']):
        if ai==0 and a["name"]=="self" and skip_self:
            continue
        s+="" if not cnt else ", "
        cnt+=1
        s+=f'{a["name"]}'
        if "type" in a:
            s+=" : "+parse_type(a["type"])
        if "default" in a:
            s+=" = "+a["default"]+""
    if not skip_braces:
        s+=')'
    if "ret" in v:
        s+=" -&gt; "+parse_type(v["ret"])
    # if "extern" in v:
    #     s += f" (_{v['extern']} function_)"
    # s += "\n"
    return s


</t>
<t tx="ekr.20230509052845.711"></t>
<t tx="ekr.20230509052845.712"></t>
<t tx="ekr.20230509052845.713">@path C:/Repos/codon/extra/python/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

import os
import sys
import shutil
import subprocess
from pathlib import Path
from Cython.Distutils import build_ext
from setuptools import setup
from setuptools.extension import Extension

exec(open("codon/version.py").read())

ext = "dylib" if sys.platform == "darwin" else "so"

codon_path = os.environ.get("CODON_DIR")
if not codon_path:
    c = shutil.which("codon")
    if c:
        codon_path = Path(c).parent / ".."
else:
    codon_path = Path(codon_path)
for path in [
    os.path.expanduser("~") + "/.codon",
    os.getcwd() + "/..",
]:
    path = Path(path)
    if not codon_path and path.exists():
        codon_path = path
        break

if (
    not codon_path
    or not (codon_path / "include" / "codon").exists()
    or not (codon_path / "lib" / "codon").exists()
):
    print(
        "Cannot find Codon.",
        'Please either install Codon (/bin/bash -c "$(curl -fsSL https://exaloop.io/install.sh)"),',
        "or set CODON_DIR if Codon is not in PATH or installed in ~/.codon",
        file=sys.stderr,
    )
    sys.exit(1)
codon_path = codon_path.resolve()
print("Codon: " + str(codon_path))


if sys.platform == "darwin":
    libraries=["codonrt", "codonc"]
    linker_args = ["-Wl,-rpath," + str(codon_path / "lib" / "codon")]
else:
    libraries=["codonrt"]
    linker_args = [
        "-Wl,-rpath=" + str(codon_path / "lib" / "codon"),
        "-Wl,--no-as-needed",
        "-lcodonc",
    ]

    # TODO: handle ABI changes better
    out = subprocess.check_output(["nm", "-g", str(codon_path / "lib" / "codon" / "libcodonc.so")])
    out = [i for i in out.decode(sys.stdout.encoding).split("\n") if "jitExecuteSafe" in i]
    if out and "cxx11" not in out[0]:
        print("CXX11 ABI not detected")
        os.environ["CFLAGS"] = os.environ.get("CFLAGS", "") + " -D_GLIBCXX_USE_CXX11_ABI=0"

jit_extension = Extension(
    "codon.codon_jit",
    sources=["codon/jit.pyx", "codon/jit.pxd"],
    libraries=libraries,
    language="c++",
    extra_compile_args=["-w"],
    extra_link_args=linker_args,
    include_dirs=[str(codon_path / "include")],
    library_dirs=[str(codon_path / "lib" / "codon")],
)

setup(
    name="codon-jit",
    version=__version__,
    install_requires=["cython", "astunparse"],
    python_requires="&gt;=3.6",
    description="Codon JIT decorator",
    url="https://exaloop.io",
    long_description="Please see https://exaloop.io for more details.",
    author="Exaloop Inc.",
    author_email="info@exaloop.io",
    license="Commercial",
    ext_modules=[jit_extension],
    packages=["codon"],
    include_package_data=True,
    cmdclass={
        "build_ext": build_ext,
    },
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.714"></t>
<t tx="ekr.20230509052845.715">@path C:/Repos/codon/extra/python/codon/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

from argparse import ArgumentError
import ctypes
import inspect
import sys
import os
import functools
import itertools
import ast
import shutil
import astunparse
from pathlib import Path

sys.setdlopenflags(sys.getdlopenflags() | ctypes.RTLD_GLOBAL)

from .codon_jit import JITWrapper, JITError, codon_library

if "CODON_PATH" not in os.environ:
    codon_path = []
    codon_lib_path = codon_library()
    if codon_lib_path:
        codon_path.append(Path(codon_lib_path).parent / "stdlib")
    codon_path.append(
        Path(os.path.expanduser("~")) / ".codon" / "lib" / "codon" / "stdlib"
    )
    for path in codon_path:
        if path.exists():
            os.environ["CODON_PATH"] = str(path.resolve())
            break
    else:
        raise RuntimeError(
            "Cannot locate Codon. Please install Codon or set CODON_PATH."
        )

pod_conversions = {
    type(None): "pyobj",
    int: "int",
    float: "float",
    bool: "bool",
    str: "str",
    complex: "complex",
    slice: "slice",
}

custom_conversions = {}
_error_msgs = set()


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.716">def _common_type(t, debug, sample_size):
    sub, is_optional = None, False
    for i in itertools.islice(t, sample_size):
        if i is None:
            is_optional = True
        else:
            s = _codon_type(i, debug=debug, sample_size=sample_size)
            if sub and sub != s:
                return "pyobj"
            sub = s
    if is_optional and sub and sub != "pyobj":
        sub = "Optional[{}]".format(sub)
    return sub if sub else "pyobj"


</t>
<t tx="ekr.20230509052845.717">def _codon_type(arg, **kwargs):
    t = type(arg)

    s = pod_conversions.get(t, "")
    if s:
        return s
    if issubclass(t, list):
        return "List[{}]".format(_common_type(arg, **kwargs))
    if issubclass(t, set):
        return "Set[{}]".format(_common_type(arg, **kwargs))
    if issubclass(t, dict):
        return "Dict[{},{}]".format(
            _common_type(arg.keys(), **kwargs), _common_type(arg.values(), **kwargs)
        )
    if issubclass(t, tuple):
        return "Tuple[{}]".format(",".join(_codon_type(a, **kwargs) for a in arg))
    s = custom_conversions.get(t, "")
    if s:
        j = ",".join(_codon_type(getattr(arg, slot), **kwargs) for slot in t.__slots__)
        return "{}[{}]".format(s, j)

    debug = kwargs.get("debug", None)
    if debug:
        msg = "cannot convert " + t.__name__
        if msg not in _error_msgs:
            print("[python]", msg, file=sys.stderr)
            _error_msgs.add(msg)
    return "pyobj"


</t>
<t tx="ekr.20230509052845.718">def _codon_types(args, **kwargs):
    return tuple(_codon_type(arg, **kwargs) for arg in args)


</t>
<t tx="ekr.20230509052845.719">def _reset_jit():
    global _jit
    _jit = JITWrapper()
    init_code = (
        "from internal.python import "
        "setup_decorator, PyTuple_GetItem, PyObject_GetAttrString\n"
        "setup_decorator()\n"
    )
    _jit.execute(init_code, "", 0, False)
    return _jit


</t>
<t tx="ekr.20230509052845.72">def perm(n, i):
    p = [0] * n

    for k in range(n):
        f = fact(n - 1 - k)
        p[k] = i // f
        i = i % f

    for k in range(n - 1, -1, -1):
        for j in range(k - 1, -1, -1):
            if p[j] &lt;= p[k]:
                p[k] += 1

    return p

</t>
<t tx="ekr.20230509052845.720">_jit = _reset_jit()


</t>
<t tx="ekr.20230509052845.721">class RewriteFunctionArgs(ast.NodeTransformer):
    @others
</t>
<t tx="ekr.20230509052845.722">def __init__(self, args):
    self.args = args

</t>
<t tx="ekr.20230509052845.723">def visit_FunctionDef(self, node):
    for a in self.args:
        node.args.args.append(ast.arg(arg=a, annotation=None))
    return node


</t>
<t tx="ekr.20230509052845.724">def _obj_to_str(obj, **kwargs) -&gt; str:
    if inspect.isclass(obj):
        lines = inspect.getsourcelines(obj)[0]
        extra_spaces = lines[0].find("class")
        obj_str = "".join(l[extra_spaces:] for l in lines)
    elif callable(obj):
        lines = inspect.getsourcelines(obj)[0]
        extra_spaces = lines[0].find("@")
        obj_str = "".join(l[extra_spaces:] for l in lines[1:])
        if kwargs.get("pyvars", None):
            node = ast.fix_missing_locations(
                RewriteFunctionArgs(kwargs["pyvars"]).visit(ast.parse(obj_str))
            )
            obj_str = astunparse.unparse(node)
    else:
        raise TypeError("Function or class expected, got " + type(obj).__name__)
    return obj_str.replace("_@par", "@par")


</t>
<t tx="ekr.20230509052845.725">def _obj_name(obj) -&gt; str:
    if inspect.isclass(obj) or callable(obj):
        return obj.__name__
    else:
        raise TypeError("Function or class expected, got " + type(obj).__name__)


</t>
<t tx="ekr.20230509052845.726">def _parse_decorated(obj, **kwargs):
    return _obj_name(obj), _obj_to_str(obj, **kwargs)


</t>
<t tx="ekr.20230509052845.727">def convert(t):
    if not hasattr(t, "__slots__"):
        raise JITError("class '{}' does not have '__slots__' attribute".format(str(t)))

    name = t.__name__
    slots = t.__slots__
    code = (
        "@tuple\n"
        "class "
        + name
        + "["
        + ",".join("T{}".format(i) for i in range(len(slots)))
        + "]:\n"
    )
    for i, slot in enumerate(slots):
        code += "    {}: T{}\n".format(slot, i)

    # PyObject_GetAttrString
    code += "    def __from_py__(p: cobj):\n"
    for i, slot in enumerate(slots):
        code += "        a{} = T{}.__from_py__(PyObject_GetAttrString(p, '{}'.ptr))\n".format(
            i, i, slot
        )
    code += "        return {}({})\n".format(
        name, ", ".join("a{}".format(i) for i in range(len(slots)))
    )

    _jit.execute(code, "", 0, False)
    custom_conversions[t] = name
    return t


</t>
<t tx="ekr.20230509052845.728">def jit(fn=None, debug=None, sample_size=5, pyvars=None):
    if not pyvars:
        pyvars = []
    if not isinstance(pyvars, list):
        raise ArgumentError("pyvars must be a list")

    @others
    if fn:
        return _decorate(fn)
    return _decorate
</t>
<t tx="ekr.20230509052845.729">def _decorate(f):
    try:
        obj_name, obj_str = _parse_decorated(f, pyvars=pyvars)
        _jit.execute(
            obj_str,
            f.__code__.co_filename,
            f.__code__.co_firstlineno,
            1 if debug else 0,
        )
    except JITError:
        _reset_jit()
        raise

    @functools.wraps(f)
    def wrapped(*args, **kwargs):
        try:
            args = (*args, *kwargs.values())
            types = _codon_types(args, debug=debug, sample_size=sample_size)
            if debug:
                print(
                    "[python] {}({})".format(f.__name__, list(types)),
                    file=sys.stderr,
                )
            return _jit.run_wrapper(
                obj_name, types, f.__module__, pyvars, args, 1 if debug else 0
            )
        except JITError:
            _reset_jit()
            raise

    return wrapped

</t>
<t tx="ekr.20230509052845.73">@path C:/Repos/codon/bench/fannkuch/
# FANNKUCH benchmark
from math import factorial as fact
from sys import argv
from time import time

@others
n = int(argv[1])
max_flips = 0

t0 = time()
for idx in range(fact(n)):
    p = perm(n, idx)
    flips = 0
    k = p[0]

    while k:
        i = 0
        j = k
        while i &lt; j:
            p[i], p[j] = p[j], p[i]
            i += 1
            j -= 1

        k = p[0]
        flips += 1

    max_flips = max(flips, max_flips)

print(f'Pfannkuchen({n}) = {max_flips}')
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.730">@path C:/Repos/codon/extra/python/codon/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

__all__ = ["jit", "convert", "JITError"]

from .decorator import jit, convert, JITError
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.731"></t>
<t tx="ekr.20230509052845.732">@path C:/Repos/codon/jupyter/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once
#include &lt;codon/compiler/jit.h&gt;
#include &lt;nlohmann/json.hpp&gt;
#include &lt;xeus/xinterpreter.hpp&gt;

using xeus::xinterpreter;
namespace nl = nlohmann;

namespace codon {
@others
int startJupyterKernel(const std::string &amp;argv0,
                       const std::vector&lt;std::string&gt; &amp;plugins,
                       const std::string &amp;configPath);

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509052845.733">class CodonJupyter : public xinterpreter {
  std::unique_ptr&lt;codon::jit::JIT&gt; jit;
  std::string argv0;
  std::vector&lt;std::string&gt; plugins;

public:
  CodonJupyter(const std::string &amp;argv0, const std::vector&lt;std::string&gt; &amp;plugins);

private:
  void configure_impl() override;

  nl::json execute_request_impl(int execution_counter, const std::string &amp;code,
                                bool silent, bool store_history,
                                nl::json user_expressions, bool allow_stdin) override;

  nl::json complete_request_impl(const std::string &amp;code, int cursor_pos) override;

  nl::json inspect_request_impl(const std::string &amp;code, int cursor_pos,
                                int detail_level) override;

  nl::json is_complete_request_impl(const std::string &amp;code) override;

  nl::json kernel_info_request_impl() override;

  void shutdown_request_impl() override;
};

</t>
<t tx="ekr.20230509052845.734"></t>
<t tx="ekr.20230509052845.735"></t>
<t tx="ekr.20230509052845.736"></t>
<t tx="ekr.20230509052845.737"></t>
<t tx="ekr.20230509052845.738">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Pats of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

@others
bisect = bisect_right
insort = insort_right
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.739">def bisect_left(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
) -&gt; int:
    """
    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e &lt; x, and all e in
    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.

    Default values: lo=0, hi=None
    """
    if lo &lt; 0:
        raise ValueError("lo must be non-negative")
    hi: int = len(a) if hi is None else hi
    while lo &lt; hi:
        mid = (lo + hi) // 2
        if a[mid] &lt; x:
            lo = mid + 1
        else:
            hi = mid
    return lo

</t>
<t tx="ekr.20230509052845.74">def perm(n, i):
    p = [0] * n

    for k in range(n):
        f = fact(n - 1 - k)
        p[k] = i // f
        i = i % f

    for k in range(n - 1, -1, -1):
        for j in range(k - 1, -1, -1):
            if p[j] &lt;= p[k]:
                p[k] += 1

    return p

</t>
<t tx="ekr.20230509052845.740">def bisect_right(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
) -&gt; int:
    """
    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e &lt;= x, and all e in
    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will
    insert just after the rightmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.

    Default values: lo=0, hi=None
    """
    if lo &lt; 0:
        raise ValueError("lo must be non-negative")
    hi: int = len(a) if hi is None else hi
    while lo &lt; hi:
        mid = (lo + hi) // 2
        if x &lt; a[mid]:
            hi = mid
        else:
            lo = mid + 1
    return lo

</t>
<t tx="ekr.20230509052845.741">def insort_left(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
):
    """
    Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the left of the leftmost x.

    Default values: lo=0, hi=None
    For now seq will use len(a) instead of None
    """
    lo = bisect_left(a, x, lo, hi)
    a.insert(lo, x)

</t>
<t tx="ekr.20230509052845.742">def insort_right(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
):
    """
    Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the right of the rightmost x.

    Default values: lo=0, hi=None
    For now seq will use len(a) instead of None
    """
    lo = bisect_right(a, x, lo, hi)

    if lo == len(a):
        a.append(x)
    else:
        a.insert(lo, x)

</t>
<t tx="ekr.20230509052845.743">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import math

e = math.e
pi = math.pi
tau = math.tau
inf = math.inf
nan = math.nan
infj = complex(0.0, inf)
nanj = complex(0.0, nan)

# internal constants
_FLT_RADIX = 2
_M_LN2 = 0.6931471805599453094  # ln(2)
_M_LN10 = 2.302585092994045684  # ln(10)

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.744">@pure
@llvm
def _max_float() -&gt; float:
    ret double 0x7FEFFFFFFFFFFFFF

</t>
<t tx="ekr.20230509052845.745">@pure
@llvm
def _min_float() -&gt; float:
    ret double 0x10000000000000

</t>
<t tx="ekr.20230509052845.746">_DBL_MAX = _max_float()
_DBL_MIN = _min_float()
_DBL_MANT_DIG = 53

_CM_LARGE_DOUBLE = _DBL_MAX/4.
_CM_SQRT_LARGE_DOUBLE = math.sqrt(_CM_LARGE_DOUBLE)
_CM_LOG_LARGE_DOUBLE = math.log(_CM_LARGE_DOUBLE)
_CM_SQRT_DBL_MIN = math.sqrt(_DBL_MIN)
_CM_SCALE_UP = (2*(_DBL_MANT_DIG // 2) + 1)
_CM_SCALE_DOWN = (-(_CM_SCALE_UP+1)//2)

# special types
_ST_NINF  = 0  # negative infinity
_ST_NEG   = 1  # negative finite number (nonzero)
_ST_NZERO = 2  # -0.
_ST_PZERO = 3  # +0.
_ST_POS   = 4  # positive finite number (nonzero)
_ST_PINF  = 5  # positive infinity
_ST_NAN   = 6  # Not a Number

</t>
<t tx="ekr.20230509052845.747">def _special_type(d: float):
    if math.isfinite(d):
        if d != 0:
            if math.copysign(1., d) == 1.:
                return _ST_POS
            else:
                return _ST_NEG
        else:
            if math.copysign(1., d) == 1.:
                return _ST_PZERO
            else:
                return _ST_NZERO
    if math.isnan(d):
        return _ST_NAN
    if math.copysign(1., d) == 1.:
        return _ST_PINF
    else:
        return _ST_NINF

</t>
<t tx="ekr.20230509052845.748">def _acos_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(P34,INF), C(P,INF), C(P,INF), C(P,-INF), C(P,-INF), C(P34,-INF), C(N,INF),
         C(P12,INF), C(U,U), C(U,U), C(U,U), C(U,U), C(P12,-INF), C(N,N), C(P12,INF),
         C(U,U), C(P12,0.), C(P12,-0.), C(U,U), C(P12,-INF), C(P12,N), C(P12,INF), C(U,U),
         C(P12,0.), C(P12,-0.), C(U,U), C(P12,-INF), C(P12,N), C(P12,INF), C(U,U), C(U,U),
         C(U,U), C(U,U), C(P12,-INF), C(N,N), C(P14,INF), C(0.,INF), C(0.,INF), C(0.,-INF),
         C(0.,-INF), C(P14,-INF), C(N,INF), C(N,INF), C(N,N), C(N,N), C(N,N), C(N,N),
         C(N,-INF), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.749">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.75"></t>
<t tx="ekr.20230509052845.750">def _acosh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,-P34), C(INF,-P), C(INF,-P), C(INF,P), C(INF,P), C(INF,P34), C(INF,N),
         C(INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P12),
         C(U,U), C(0.,-P12), C(0.,P12), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U),
         C(0.,-P12), C(0.,P12), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(U,U),
         C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.),
         C(INF,0.), C(INF,P14), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,N),
         C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.751">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.752">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.753">def _asinh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(-INF,-P14), C(-INF,-0.), C(-INF,-0.), C(-INF,0.), C(-INF,0.), C(-INF,P14), C(-INF,N),
         C(-INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(-INF,P12), C(N,N), C(-INF,-P12), C(U,U),
         C(-0.,-0.), C(-0.,0.), C(U,U), C(-INF,P12), C(N,N), C(INF,-P12), C(U,U), C(0.,-0.),
         C(0.,0.), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U),
         C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.), C(INF,P14),
         C(INF,N), C(INF,N), C(N,N), C(N,-0.), C(N,0.), C(N,N), C(INF,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.754">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.755">def _atanh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(-0.,-P12), C(-0.,-P12), C(-0.,-P12), C(-0.,P12), C(-0.,P12), C(-0.,P12), C(-0.,N),
         C(-0.,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(-0.,P12), C(N,N), C(-0.,-P12), C(U,U),
         C(-0.,-0.), C(-0.,0.), C(U,U), C(-0.,P12), C(-0.,N), C(0.,-P12), C(U,U), C(0.,-0.), C(0.,0.),
         C(U,U), C(0.,P12), C(0.,N), C(0.,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(0.,P12), C(N,N),
         C(0.,-P12), C(0.,-P12), C(0.,-P12), C(0.,P12), C(0.,P12), C(0.,P12), C(0.,N), C(0.,-P12),
         C(N,N), C(N,N), C(N,N), C(N,N), C(0.,P12), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.756">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.757">def _cosh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,N), C(U,U), C(INF,0.), C(INF,-0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U),
         C(U,U), C(U,U), C(N,N), C(N,N), C(N,0.), C(U,U), C(1.,0.), C(1.,-0.), C(U,U), C(N,0.), C(N,0.),
         C(N,0.), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(N,0.), C(N,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N),
         C(N,N), C(N,N), C(N,0.), C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.758">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.759">def _exp_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(0.,0.), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(0.,0.), C(0.,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U),
         C(1.,-0.), C(1.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N),
         C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,-0.),
         C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.76">@path C:/Repos/codon/bench/float/
from math import sin, cos, sqrt
from time import time

POINTS = 10000000


@others
t0 = time()
print(benchmark(POINTS))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509052845.760">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.761">def _log_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,-P34), C(INF,-P), C(INF,-P), C(INF,P), C(INF,P), C(INF,P34), C(INF,N), C(INF,-P12), C(U,U),
         C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(-INF,-P), C(-INF,P), C(U,U), C(INF,P12),
         C(N,N), C(INF,-P12), C(U,U), C(-INF,-0.), C(-INF,0.), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U),
         C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.),
         C(INF,P14), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.762">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.763">def _sinh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,N), C(U,U), C(-INF,-0.), C(-INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U), C(U,U),
        C(U,U), C(N,N), C(N,N), C(0.,N), C(U,U), C(-0.,-0.), C(-0.,0.), C(U,U), C(0.,N), C(0.,N), C(0.,N),
        C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(0.,N), C(0.,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N),
        C(N,N), C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,-0.),
        C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.764">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.765">def _sqrt_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,-INF), C(0.,-INF), C(0.,-INF), C(0.,INF), C(0.,INF), C(INF,INF), C(N,INF), C(INF,-INF), C(U,U), C(U,U),
         C(U,U), C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(INF,INF), C(N,N),
         C(INF,-INF), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(U,U), C(U,U), C(U,U),
         C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.), C(INF,INF), C(INF,N),
         C(INF,-INF), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,INF), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.766">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.767">def _tanh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(-1.,0.), C(U,U), C(-1.,-0.), C(-1.,0.), C(U,U), C(-1.,0.), C(-1.,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(-0.,-0.), C(-0.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U),
         C(0.,-0.), C(0.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N),
         C(1.,0.), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(1.,0.), C(1.,0.), C(N,N), C(N,N), C(N,-0.), C(N,0.),
         C(N,N), C(N,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.768">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.769">def _rect_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    @others
    v = (C(INF,N), C(U,U), C(-INF,0.), C(-INF,-0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U),
         C(N,N), C(N,N), C(0.,0.), C(U,U), C(-0.,0.), C(-0.,-0.), C(U,U), C(0.,0.), C(0.,0.), C(0.,0.), C(U,U), C(0.,-0.),
         C(0.,0.), C(U,U), C(0.,0.), C(0.,0.), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N), C(INF,N), C(U,U),
         C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,0.), C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

</t>
<t tx="ekr.20230509052845.77">class Point:
    x: float
    y: float
    z: float

    @others
</t>
<t tx="ekr.20230509052845.770">def C(a,b): return complex(a, b)
</t>
<t tx="ekr.20230509052845.771">def _is_special(z):
    return (not math.isfinite(z.real)) or (not math.isfinite(z.imag))

</t>
<t tx="ekr.20230509052845.772">def _special_get(z, table):
    t1 = _special_type(z.real)
    t2 = _special_type(z.imag)
    return table[7*t1 + t2]

</t>
<t tx="ekr.20230509052845.773">def _sqrt_impl(z):
    if _is_special(z):
        return _special_get(z, _sqrt_special())

    r_real = 0.
    r_imag = 0.
    if z.real == 0. and z.imag == 0.:
        r_real = 0.
        r_imag = z.imag
        return complex(r_real, r_imag)

    ax = math.fabs(z.real)
    ay = math.fabs(z.imag)
    s = 0.
    if ax &lt; _DBL_MIN and ay &lt; _DBL_MIN and (ax &gt; 0. or ay &gt; 0.):
        # here we catch cases where hypot(ax, ay) is subnormal
        ax = math.ldexp(ax, _CM_SCALE_UP)
        s = math.ldexp(math.sqrt(ax + math.hypot(ax, math.ldexp(ay, _CM_SCALE_UP))), _CM_SCALE_DOWN)
    else:
        ax /= 8.
        s = 2.*math.sqrt(ax + math.hypot(ax, ay/8.))
    d = ay/(2.*s)

    if z.real &gt;= 0.:
        r_real = s
        r_imag = math.copysign(d, z.imag)
    else:
        r_real = d
        r_imag = math.copysign(s, z.imag)
    # errno = 0
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.774">def _acos_impl(z):
    if _is_special(z):
        return _special_get(z, _acos_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        # avoid unnecessary overflow for large arguments
        r_real = math.atan2(math.fabs(z.imag), z.real)
        # split into cases to make sure that the branch cut has the
        # correct continuity on systems with unsigned zeros
        if z.real &lt; 0.:
            r_imag = -math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, z.imag)
        else:
            r_imag = math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, -z.imag)
    else:
        s1 = _sqrt_impl(complex(1. - z.real, -z.imag))
        s2 = _sqrt_impl(complex(1. + z.real, z.imag))
        r_real = 2.*math.atan2(s1.real, s2.real)
        r_imag = math.asinh(s2.real*s1.imag - s2.imag*s1.real)
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.775">def _acosh_impl(z):
    if _is_special(z):
        return _special_get(z, _acosh_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        # avoid unnecessary overflow for large arguments
        r_real = math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2.
        r_imag = math.atan2(z.imag, z.real)
    else:
        s1 = _sqrt_impl(complex(z.real - 1., z.imag))
        s2 = _sqrt_impl(complex(z.real + 1., z.imag))
        r_real = math.asinh(s1.real*s2.real + s1.imag*s2.imag)
        r_imag = 2.*math.atan2(s1.imag, s2.real)
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.776">def _asinh_impl(z):
    if _is_special(z):
        return _special_get(z, _asinh_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        if z.imag &gt;= 0.:
            r_real = math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, z.real)
        else:
            r_real = -math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, -z.real)
        r_imag = math.atan2(z.imag, math.fabs(z.real))
    else:
        s1 = _sqrt_impl(complex(1. + z.imag, -z.real))
        s2 = _sqrt_impl(complex(1. - z.imag, z.real))
        r_real = math.asinh(s1.real*s2.imag - s2.real*s1.imag)
        r_imag = math.atan2(z.imag, s1.real*s2.real - s1.imag*s2.imag)
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.777">def _asin_impl(z):
    s = _asinh_impl(complex(-z.imag, z.real))
    r_real = s.imag
    r_imag = -s.real
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.778">def _atanh_impl(z):
    if _is_special(z):
        return _special_get(z, _atanh_special())

    # Reduce to case where z.real &gt;= 0., using atanh(z) = -atanh(-z).
    if z.real &lt; 0.:
        return -_atanh_impl(-z)

    r_real = 0.
    r_imag = 0.
    ay = math.fabs(z.imag)
    if z.real &gt; _CM_SQRT_LARGE_DOUBLE or ay &gt; _CM_SQRT_LARGE_DOUBLE:
        # if abs(z) is large then we use the approximation
        # atanh(z) ~ 1/z +/- i*pi/2 (+/- depending on the sign
        # of z.imag)
        h = math.hypot(z.real/2., z.imag/2.)  # safe from overflow
        r_real = z.real/4./h/h
        # the two negations in the next line cancel each other out
        # except when working with unsigned zeros: they're there to
        # ensure that the branch cut has the correct continuity on
        # systems that don't support signed zeros
        r_imag = -math.copysign(pi/2., -z.imag)
        # errno = 0
    elif z.real == 1. and ay &lt; _CM_SQRT_DBL_MIN:
        # C99 standard says:  atanh(1+/-0.) should be inf +/- 0i
        if ay == 0.:
            r_real = inf
            r_imag = z.imag
            # errno = EDOM
        else:
            r_real = -math.log(math.sqrt(ay)/math.sqrt(math.hypot(ay, 2.)))
            r_imag = math.copysign(math.atan2(2., -ay)/2, z.imag)
            # errno = 0
    else:
        r_real = math.log1p(4.*z.real/((1-z.real)*(1-z.real) + ay*ay))/4.
        r_imag = -math.atan2(-2.*z.imag, (1-z.real)*(1+z.real) - ay*ay)/2.
        # errno = 0
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.779">def _atan_impl(z):
    s = _atanh_impl(complex(-z.imag, z.real))
    r_real = s.imag
    r_imag = -s.real
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.78">def __init__(self, i):
    self.x = x = sin(i)
    self.y = cos(i) * 3
    self.z = (x * x) / 2

</t>
<t tx="ekr.20230509052845.780">def _cosh_impl(z):
    r_real = 0.
    r_imag = 0.
    # special treatment for cosh(+/-inf + iy) if y is not a NaN
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = -math.copysign(inf, math.sin(z.imag))
        else:
            r = _special_get(z, _cosh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; !Py_IS_NAN(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        # deal correctly with cases where cosh(z.real) overflows but
        # cosh(z) does not.
        x_minus_one = z.real - math.copysign(1., z.real)
        r_real = math.cos(z.imag) * math.cosh(x_minus_one) * e
        r_imag = math.sin(z.imag) * math.sinh(x_minus_one) * e
    else:
        r_real = math.cos(z.imag) * math.cosh(z.real)
        r_imag = math.sin(z.imag) * math.sinh(z.real)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.781">def _cos_impl(z):
    r = _cosh_impl(complex(-z.imag, z.real))
    return r

</t>
<t tx="ekr.20230509052845.782">def _exp_impl(z):
    r_real = 0.
    r_imag = 0.
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = math.copysign(0., math.cos(z.imag))
                r_imag = math.copysign(0., math.sin(z.imag))
        else:
            r = _special_get(z, _exp_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN and not -infinity */
        if (Py_IS_INFINITY(z.imag) &amp;&amp;
            (Py_IS_FINITE(z.real) ||
             (Py_IS_INFINITY(z.real) &amp;&amp; z.real &gt; 0)))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if z.real &gt; _CM_LOG_LARGE_DOUBLE:
        l = math.exp(z.real - 1.)
        r_real = l*math.cos(z.imag)*e
        r_imag = l*math.sin(z.imag)*e
    else:
        l = math.exp(z.real)
        r_real = l*math.cos(z.imag)
        r_imag = l*math.sin(z.imag)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.783">def _c_log(z):
    if _is_special(z):
        return _special_get(z, _log_special())

    ax = math.fabs(z.real)
    ay = math.fabs(z.imag)

    r_real = 0.
    r_imag = 0.
    if ax &gt; _CM_LARGE_DOUBLE or ay &gt; _CM_LARGE_DOUBLE:
        r_real = math.log(math.hypot(ax/2., ay/2.)) + _M_LN2
    elif ax &lt; _DBL_MIN and ay &lt; _DBL_MIN:
        if ax &gt; 0. or ay &gt; 0.:
            # catch cases where hypot(ax, ay) is subnormal
            r_real = math.log(math.hypot(math.ldexp(ax, _DBL_MANT_DIG), math.ldexp(ay, _DBL_MANT_DIG))) - _DBL_MANT_DIG*_M_LN2
        else:
            # log(+/-0. +/- 0i)
            r_real = -inf
            r_imag = math.atan2(z.imag, z.real)
            # errno = EDOM
            return complex(r_real, r_imag)
    else:
        h = math.hypot(ax, ay)
        if 0.71 &lt;= h &lt;= 1.73:
            am = max(ax, ay)
            an = min(ax, ay)
            r_real = math.log1p((am-1)*(am+1) + an*an)/2.
        else:
            r_real = math.log(h)
    r_imag = math.atan2(z.imag, z.real)
    # errno = 0
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.784">def _log10_impl(z):
    s = _c_log(z)
    return complex(s.real / _M_LN10, s.imag / _M_LN10)

</t>
<t tx="ekr.20230509052845.785">def _sinh_impl(z):
    r_real = 0.
    r_imag = 0.
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = -math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
        else:
            r = _special_get(z, _sinh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; !Py_IS_NAN(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        x_minus_one = z.real - math.copysign(1., z.real)
        r_real = math.cos(z.imag) * math.sinh(x_minus_one) * e
        r_imag = math.sin(z.imag) * math.cosh(x_minus_one) * e
    else:
        r_real = math.cos(z.imag) * math.sinh(z.real)
        r_imag = math.sin(z.imag) * math.cosh(z.real)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.786">def _sin_impl(z):
    s = _sinh_impl(complex(-z.imag, z.real))
    r = complex(s.imag, -s.real)
    return r

</t>
<t tx="ekr.20230509052845.787">def _tanh_impl(z):
    r_real = 0.
    r_imag = 0.
    # special treatment for tanh(+/-inf + iy) if y is finite and
    # nonzero
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = 1.0
                r_imag = math.copysign(0., 2.*math.sin(z.imag)*math.cos(z.imag))
            else:
                r_real = -1.0
                r_imag = math.copysign(0., 2.*math.sin(z.imag)*math.cos(z.imag))
        else:
            r = _special_get(z, _tanh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if z.imag is +/-infinity and
           z.real is finite */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; Py_IS_FINITE(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    # danger of overflow in 2.*z.imag !
    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        r_real = math.copysign(1., z.real)
        r_imag = 4.*math.sin(z.imag)*math.cos(z.imag)*math.exp(-2.*math.fabs(z.real))
    else:
        tx = math.tanh(z.real)
        ty = math.tan(z.imag)
        cx = 1./math.cosh(z.real)
        txty = tx*ty
        denom = 1. + txty*txty
        r_real = tx*(1. + ty*ty)/denom
        r_imag = ((ty/denom)*cx)*cx
    # errno = 0
    return complex(r_real, r_imag)

</t>
<t tx="ekr.20230509052845.788">def _tan_impl(z):
    s = _tanh_impl(complex(-z.imag, z.real))
    r = complex(s.imag, -s.real)
    return r

</t>
<t tx="ekr.20230509052845.789">def phase(x):
    z = complex(x)
    return z._phase()

</t>
<t tx="ekr.20230509052845.79">def __repr__(self):
    return f"&lt;Point: x={self.x}, y={self.y}, z={self.z}&gt;"

</t>
<t tx="ekr.20230509052845.790">def polar(x):
    z = complex(x)
    return complex(x)._polar()

</t>
<t tx="ekr.20230509052845.791">def rect(r, phi):
    z_real = 0.
    z_imag = 0.
    if (not math.isfinite(r)) or (not math.isfinite(phi)):
        # if r is +/-infinity and phi is finite but nonzero then
        # result is (+-INF +-INF i), but we need to compute cos(phi)
        # and sin(phi) to figure out the signs.
        if math.isinf(r) and (math.isfinite(phi) and phi != 0.):
            if r &gt; 0:
                z_real = math.copysign(inf, math.cos(phi))
                z_imag = math.copysign(inf, math.sin(phi))
            else:
                z_real = -math.copysign(inf, math.cos(phi))
                z_imag = -math.copysign(inf, math.sin(phi))
        else:
            z = _special_get(complex(r, phi), _rect_special())
            z_real = z.real
            z_imag = z.imag
        '''
        /* need to set errno = EDOM if r is a nonzero number and phi
           is infinite */
        if (r != 0. &amp;&amp; !Py_IS_NAN(r) &amp;&amp; Py_IS_INFINITY(phi))
            errno = EDOM;
        else
            errno = 0;
        '''
    elif phi == 0.0:
        # Workaround for buggy results with phi=-0.0 on OS X 10.8.  See
        # bugs.python.org/issue18513.
        z_real = r
        z_imag = r * phi
        # errno = 0
    else:
        z_real = r * math.cos(phi)
        z_imag = r * math.sin(phi)
        # errno = 0
    return complex(z_real, z_imag)

</t>
<t tx="ekr.20230509052845.792">def exp(x):
    z = complex(x)
    return _exp_impl(z)

</t>
<t tx="ekr.20230509052845.793">def log(x, base = e):
    z = complex(x)
    y = complex(base)
    r = _c_log(z)
    if y == complex(e, 0.0):
        return r
    else:
        return r/_c_log(y)

</t>
<t tx="ekr.20230509052845.794">def log10(x):
    z = complex(x)
    return _log10_impl(z)

</t>
<t tx="ekr.20230509052845.795">def sqrt(x):
    z = complex(x)
    return _sqrt_impl(z)

</t>
<t tx="ekr.20230509052845.796">def asin(x):
    z = complex(x)
    return _asin_impl(z)

</t>
<t tx="ekr.20230509052845.797">def acos(x):
    z = complex(x)
    return _acos_impl(z)

</t>
<t tx="ekr.20230509052845.798">def atan(x):
    z = complex(x)
    return _atan_impl(z)

</t>
<t tx="ekr.20230509052845.799">def sin(x):
    z = complex(x)
    return _sin_impl(z)

</t>
<t tx="ekr.20230509052845.8">def make_check(itde, make=make_tree, check=check_tree):
    i, d = itde
    return check(make(d))

</t>
<t tx="ekr.20230509052845.80">def normalize(self):
    x = self.x
    y = self.y
    z = self.z
    norm = sqrt(x * x + y * y + z * z)
    self.x /= norm
    self.y /= norm
    self.z /= norm

</t>
<t tx="ekr.20230509052845.800">def cos(x):
    z = complex(x)
    return _cos_impl(z)

</t>
<t tx="ekr.20230509052845.801">def tan(x):
    z = complex(x)
    return _tan_impl(z)

</t>
<t tx="ekr.20230509052845.802">def asinh(x):
    z = complex(x)
    return _asinh_impl(z)

</t>
<t tx="ekr.20230509052845.803">def acosh(x):
    z = complex(x)
    return _acosh_impl(z)

</t>
<t tx="ekr.20230509052845.804">def atanh(x):
    z = complex(x)
    return _atanh_impl(z)

</t>
<t tx="ekr.20230509052845.805">def sinh(x):
    z = complex(x)
    return _sinh_impl(z)

</t>
<t tx="ekr.20230509052845.806">def cosh(x):
    z = complex(x)
    return _cosh_impl(z)

</t>
<t tx="ekr.20230509052845.807">def tanh(x):
    z = complex(x)
    return _tanh_impl(z)

</t>
<t tx="ekr.20230509052845.808">def isfinite(x):
    z = complex(x)
    return math.isfinite(z.real) and math.isfinite(z.imag)

</t>
<t tx="ekr.20230509052845.809">def isinf(x):
    z = complex(x)
    return math.isinf(z.real) or math.isinf(z.imag)

</t>
<t tx="ekr.20230509052845.81">def maximize(self, other):
    self.x = self.x if self.x &gt; other.x else other.x
    self.y = self.y if self.y &gt; other.y else other.y
    self.z = self.z if self.z &gt; other.z else other.z
    return self


</t>
<t tx="ekr.20230509052845.810">def isnan(x):
    z = complex(x)
    return math.isnan(z.real) or math.isnan(z.imag)

</t>
<t tx="ekr.20230509052845.811">def isclose(a, b, rel_tol: float = 1e-09, abs_tol: float = 0.0):
    if rel_tol &lt; 0. or abs_tol &lt; 0.:
        raise ValueError("tolerances must be non-negative")

    x = complex(a)
    y = complex(b)

    if x.real == y.real and x.imag == y.imag:
        return True

    if (math.isinf(x.real) or math.isinf(x.imag) or
        math.isinf(y.real) or math.isinf(y.imag)):
        return False

    diff = abs(x - y)
    return (((diff &lt;= rel_tol * abs(y)) or
             (diff &lt;= rel_tol * abs(x))) or
             (diff &lt;= abs_tol))
</t>
<t tx="ekr.20230509052845.812">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.types.optional import unwrap

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.813">class deque:
    _arr: Array[T]
    _head: int
    _tail: int
    _maxlen: int
    T: type

    @others
</t>
<t tx="ekr.20230509052845.814">def __init__(self, arr: Array[T], head: int, tail: int, maxlen: int):
    self._arr = arr
    self._head = head
    self._tail = tail
    self._maxlen = maxlen

</t>
<t tx="ekr.20230509052845.815">def __init__(self):
    self._arr = Array[T](16)
    self._head = 0
    self._tail = 0
    self._maxlen = -1

</t>
<t tx="ekr.20230509052845.816">def __init__(self, maxlen: int):
    cap = 1
    while cap &lt; maxlen:
        cap *= 2
    self._arr = Array[T](cap)
    self._head = 0
    self._tail = 0
    self._maxlen = maxlen

</t>
<t tx="ekr.20230509052845.817">def __init__(self, it: Generator[T]):
    self._arr = Array[T](16)
    self._head = 0
    self._tail = 0
    self._maxlen = -1
    for i in it:
        self.append(i)

</t>
<t tx="ekr.20230509052845.818">@property
def maxlen(self) -&gt; int:
    return self._maxlen

</t>
<t tx="ekr.20230509052845.819">def _double_cap(self):
    p = self._head
    n = len(self._arr)
    r = n - p
    new_cap = n * 2
    new_arr = Array[T](new_cap)
    for i in range(r):
        new_arr[i] = self._arr[p + i]
    for i in range(p):
        new_arr[i + r] = self._arr[i]
    self._arr = new_arr
    self._head = 0
    self._tail = n

</t>
<t tx="ekr.20230509052845.82">def maximize(points):
    next = points[0]
    for p in points[1:]:
        next = next.maximize(p)
    return next


</t>
<t tx="ekr.20230509052845.820">def _check_not_empty(self):
    if not self:
        raise IndexError("pop from an empty deque")

</t>
<t tx="ekr.20230509052845.821">def __bool__(self) -&gt; bool:
    return self._head != self._tail

</t>
<t tx="ekr.20230509052845.822">def __len__(self) -&gt; int:
    return (self._tail - self._head) &amp; (len(self._arr) - 1)

</t>
<t tx="ekr.20230509052845.823">def appendleft(self, x: T):
    self._head = (self._head - 1) &amp; (len(self._arr) - 1)
    self._arr[self._head] = x
    if self._maxlen &gt;= 0 and len(self) &gt; self._maxlen:
        self.pop()
    if self._head == self._tail:
        self._double_cap()

</t>
<t tx="ekr.20230509052845.824">def append(self, x: T):
    self._arr[self._tail] = x
    self._tail = (self._tail + 1) &amp; (len(self._arr) - 1)
    if self._maxlen &gt;= 0 and len(self) &gt; self._maxlen:
        self.popleft()
    if self._head == self._tail:
        self._double_cap()

</t>
<t tx="ekr.20230509052845.825">def popleft(self) -&gt; T:
    self._check_not_empty()
    res = self._arr[self._head]
    self._head = (self._head + 1) &amp; (len(self._arr) - 1)
    return res

</t>
<t tx="ekr.20230509052845.826">def pop(self) -&gt; T:
    self._check_not_empty()
    self._tail = (self._tail - 1) &amp; (len(self._arr) - 1)
    return self._arr[self._tail]

</t>
<t tx="ekr.20230509052845.827">def clear(self):
    self._head = 0
    self._tail = 0

</t>
<t tx="ekr.20230509052845.828">def __iter__(self) -&gt; Generator[T]:
    i = self._head
    while i != self._tail:
        yield self._arr[i]
        i = (i + 1) &amp; (len(self._arr) - 1)

</t>
<t tx="ekr.20230509052845.829">def __contains__(self, x: T) -&gt; bool:
    for i in self:
        if i == x:
            return True
    return False

</t>
<t tx="ekr.20230509052845.83">def benchmark(n):
    points = [None] * n
    for i in range(n):
        points[i] = Point(i)
    for p in points:
        p.normalize()
    return maximize(points)


</t>
<t tx="ekr.20230509052845.830">def __deepcopy__(self) -&gt; deque[T]:
    return deque(i.__deepcopy__() for i in self)

</t>
<t tx="ekr.20230509052845.831">def __copy__(self) -&gt; deque[T]:
    return deque[T](self._arr.__copy__(), self._head, self._tail, self._maxlen)

</t>
<t tx="ekr.20230509052845.832">def copy(self) -&gt; deque[T]:
    return self.__copy__()

</t>
<t tx="ekr.20230509052845.833">def __repr__(self) -&gt; str:
    return f"deque({repr(List[T](iter(self)))})"

</t>
<t tx="ekr.20230509052845.834">def _idx_check(self, idx: int, msg: str):
    if self._head == self._tail or idx &gt;= len(self) or idx &lt; 0:
        raise IndexError(msg)

</t>
<t tx="ekr.20230509052845.835">@property
def left(self) -&gt; T:
    self._idx_check(0, "list index out of range")
    return self._arr[self._head]

</t>
<t tx="ekr.20230509052845.836">def __getitem__(self, idx: int) -&gt; T:
    if idx &lt; 0:
        idx += len(self)
    self._idx_check(idx, "list index out of range")
    if self._head &lt;= self._tail:
        return self._arr[self._head + idx]
    elif self._head + idx &lt; len(self._arr):
        return self._arr[self._head + idx]
    else:
        idx -= len(self._arr) - self._head
        assert 0 &lt;= idx &lt; self._tail
        return self._arr[idx]

</t>
<t tx="ekr.20230509052845.837">@tuple
class _CounterItem:
    element: T
    count: int
    T: type

    @others
</t>
<t tx="ekr.20230509052845.838">def __eq__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count == other.count

</t>
<t tx="ekr.20230509052845.839">def __ne__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count != other.count

</t>
<t tx="ekr.20230509052845.84"></t>
<t tx="ekr.20230509052845.840">def __lt__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count &lt; other.count

</t>
<t tx="ekr.20230509052845.841">def __gt__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count &gt; other.count

</t>
<t tx="ekr.20230509052845.842">def __le__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count &lt;= other.count

</t>
<t tx="ekr.20230509052845.843">def __ge__(self, other: _CounterItem[T]) -&gt; bool:
    return self.count &gt;= other.count

</t>
<t tx="ekr.20230509052845.844">class Counter(Static[Dict[T, int]]):
    T: type

    @others
</t>
<t tx="ekr.20230509052845.845">def __init__(self, elements: Generator[T]):
    self._init()
    self.update(elements)

</t>
<t tx="ekr.20230509052845.846">def __init__(self, other: Counter[T]):
    self._init_from(other)

</t>
<t tx="ekr.20230509052845.847">def __init__(self, other: Dict[T, int]):
    self._init_from(other)

</t>
<t tx="ekr.20230509052845.848">def elements(self) -&gt; Generator[T]:
    for k, v in self.items():
        for i in range(v):
            yield k

</t>
<t tx="ekr.20230509052845.849">def most_common(self, n: Optional[int] = None) -&gt; List[Tuple[T, int]]:
    if len(self) == 0:
        return List[_CounterItem](capacity=0)

    if n is None:
        v = List[_CounterItem](capacity=len(self))
        for t in self.items():
            v.append(t)
        v.sort(reverse=True)
        return v
    else:
        from heapq import heapify, heapreplace

        n: int = n

        if n == 1:
            top: Optional[_CounterItem] = None
            for t in self.items():
                if top is None or t[1] &gt; top.count:
                    top = t
            return [unwrap(top)]

        if n &lt;= 0:
            return List[_CounterItem](capacity=0)

        result = List[_CounterItem](capacity=n)
        for t in self.items():
            if len(result) &lt; n:
                result.append(t)
                if len(result) == n:
                    heapify(result)
            else:
                if result[0] &lt; t:
                    heapreplace(result, t)

        result.sort(reverse=True)
        return result

</t>
<t tx="ekr.20230509052845.85">@path C:/Repos/codon/bench/go/
"""
Go board game
"""
import math
import random
from time import time

SIZE = 9
GAMES = 200
KOMI = 7.5
EMPTY, WHITE, BLACK = 0, 1, 2
SHOW = {EMPTY: '.', WHITE: 'o', BLACK: 'x'}
PASS = -1
MAXMOVES = SIZE * SIZE * 3
TIMESTAMP = 0
MOVES = 0


@others
if __name__ == "__main__":
    t0 = time()
    versus_cpu()
    t1 = time()
    print(t1 - t0)
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.850">def subtract(self, elements: Generator[T]):
    for a in elements:
        self.increment(a, -1)

</t>
<t tx="ekr.20230509052845.851">def subtract(self, other: Counter[T]):
    for k, v in other.items():
        self.increment(k, -v)

</t>
<t tx="ekr.20230509052845.852">def subtract(self, other: Dict[T, int]):
    for k, v in other.items():
        self.increment(k, -v)

</t>
<t tx="ekr.20230509052845.853">def update(self, elements: Generator[T]):
    for a in elements:
        self.increment(a)

</t>
<t tx="ekr.20230509052845.854">def update(self, other: Counter[T]):
    for k, v in other.items():
        self.increment(k, by=v)

</t>
<t tx="ekr.20230509052845.855">def update(self, other: Dict[T, int]):
    for k, v in other.items():
        self.increment(k, by=v)

</t>
<t tx="ekr.20230509052845.856">def update(self):
    pass

</t>
<t tx="ekr.20230509052845.857">def total(self) -&gt; int:
    m = 0
    for v in self.values():
        m += v
    return m

</t>
<t tx="ekr.20230509052845.858">def __getitem__(self, key: T) -&gt; int:
    return self.get(key, 0)

</t>
<t tx="ekr.20230509052845.859">def __delitem__(self, key: T):
    x = self._kh_get(key)
    if x != self._kh_end():
        self._kh_del(x)

</t>
<t tx="ekr.20230509052845.86">def to_pos(x, y):
    return y * SIZE + x


</t>
<t tx="ekr.20230509052845.860">def __eq__(self, other: Counter[T]) -&gt; bool:
    if self.__len__() != other.__len__():
        return False
    for k, v in self.items():
        if k not in other or other[k] != v:
            return False
    return True

</t>
<t tx="ekr.20230509052845.861">def __ne__(self, other: Counter[T]) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.862">def __copy__(self) -&gt; Counter[T]:
    return Counter[T](self)

</t>
<t tx="ekr.20230509052845.863">def __iadd__(self, other: Counter[T]) -&gt; Counter[T]:
    for k, v in other.items():
        self.increment(k, by=v)
    self._del_non_positives()
    return self

</t>
<t tx="ekr.20230509052845.864">def __isub__(self, other: Counter[T]) -&gt; Counter[T]:
    for k, v in other.items():
        self.increment(k, by=-v)
    self._del_non_positives()
    return self

</t>
<t tx="ekr.20230509052845.865">def __iand__(self, other: Counter[T]) -&gt; Counter[T]:
    for k, v in other.items():
        self[k] = min(self.get(k, 0), v)
    self._del_non_positives()
    return self

</t>
<t tx="ekr.20230509052845.866">def __ior__(self, other: Counter[T]) -&gt; Counter[T]:
    self._del_non_positives()
    for k, v in other.items():
        self[k] = max(self.get(k, 0), v)
    self._del_non_positives()
    return self

</t>
<t tx="ekr.20230509052845.867">def __pos__(self) -&gt; Counter[T]:
    result = Counter[T]()
    result.resize(self._n_buckets)
    for k, v in self.items():
        if v &gt; 0:
            result[k] = v
    return result

</t>
<t tx="ekr.20230509052845.868">def __neg__(self) -&gt; Counter[T]:
    result = Counter[T]()
    result.resize(self._n_buckets)
    for k, v in self.items():
        if v &lt; 0:
            result[k] = -v
    return result

</t>
<t tx="ekr.20230509052845.869">def __add__(self, other: Counter[T]) -&gt; Counter[T]:
    result = self.__copy__()
    result += other
    return result

</t>
<t tx="ekr.20230509052845.87">def to_xy(pos):
    y, x = divmod(pos, SIZE)
    return x, y


</t>
<t tx="ekr.20230509052845.870">def __sub__(self, other: Counter[T]) -&gt; Counter[T]:
    result = self.__copy__()
    result -= other
    return result

</t>
<t tx="ekr.20230509052845.871">def __and__(self, other: Counter[T]) -&gt; Counter[T]:
    result = self.__copy__()
    result &amp;= other
    return result

</t>
<t tx="ekr.20230509052845.872">def __or__(self, other: Counter[T]) -&gt; Counter[T]:
    result = self.__copy__()
    result |= other
    return result

</t>
<t tx="ekr.20230509052845.873">def __repr__(self):
    return f"Counter({super().__repr__()})"

</t>
<t tx="ekr.20230509052845.874">def __dict_do_op_throws__(self, key: T, other: Z, op: F, F: type, Z: type):
    self.__dict_do_op__(key, other, 0, op)

</t>
<t tx="ekr.20230509052845.875">def _del_non_positives(self):
    for k, v in self.items():
        if v &lt;= 0:
            del self[k]

</t>
<t tx="ekr.20230509052845.876">@extend
class Dict:
    def __init__(self: Dict[K, int], other: Counter[K]):
        self._init_from(other)

</t>
<t tx="ekr.20230509052845.877">class defaultdict(Static[Dict[K,V]]):
    default_factory: S
    K: type
    V: type
    S: TypeVar[Callable[[], V]]

    @others
</t>
<t tx="ekr.20230509052845.878">def __init__(self: defaultdict[K, VV, Function[[], V]], VV: TypeVar[V]):
    super().__init__()
    self.default_factory = lambda: VV()

</t>
<t tx="ekr.20230509052845.879">def __init__(self, f: S):
    super().__init__()
    self.default_factory = f

</t>
<t tx="ekr.20230509052845.88">@dataclass(init=False)
class Square[Board]:
    board: Board
    pos: int
    timestamp: int
    removestamp: int
    zobrist_strings: List[int]
    neighbours: Optional[List[Square[Board]]]
    color: int
    used: bool
    reference: Optional[Square[Board]]
    ledges: int
    temp_ledges: int

    @others
</t>
<t tx="ekr.20230509052845.880">def __init__(self: defaultdict[K, VV, Function[[], V]], VV: TypeVar[V], other: Dict[K, V]):
    super().__init__(other)
    self.default_factory = lambda: VV()

</t>
<t tx="ekr.20230509052845.881">def __init__(self, f: S, other: Dict[K, V]):
    super().__init__(other)
    self.default_factory = f

</t>
<t tx="ekr.20230509052845.882">def __missing__(self, key: K):
    default_value = self.default_factory()
    self.__setitem__(key, default_value)
    return default_value

</t>
<t tx="ekr.20230509052845.883">def __getitem__(self, key: K) -&gt; V:
    if key not in self:
        return self.__missing__(key)
    return super().__getitem__(key)

</t>
<t tx="ekr.20230509052845.884">def __dict_do_op_throws__(self, key: K, other: Z, op: F, F: type, Z: type):
    x = self._kh_get(key)
    if x == self._kh_end():
        self.__missing__(key)
        x = self._kh_get(key)
    self._vals[x] = op(self._vals[x], other)

</t>
<t tx="ekr.20230509052845.885">def copy(self):
    d = defaultdict[K,V,S](self.default_factory)
    d._init_from(self)
    return d

</t>
<t tx="ekr.20230509052845.886">def __copy__(self):
    return self.copy()

</t>
<t tx="ekr.20230509052845.887">def __deepcopy__(self):
    d = defaultdict[K,V,S](self.default_factory)
    for k,v in self.items():
        d[k.__deepcopy__()] = v.__deepcopy__()
    return d

</t>
<t tx="ekr.20230509052845.888">def __eq__(self, other: defaultdict[K,V,S]) -&gt; bool:
    if self.__len__() != other.__len__():
        return False
    for k, v in self.items():
        if k not in other or other[k] != v:
            return False
    return True

</t>
<t tx="ekr.20230509052845.889">def __ne__(self, other: defaultdict[K,V,S]) -&gt; bool:
    return not (self == other)

</t>
<t tx="ekr.20230509052845.89">def __init__(self, board, pos):
    self.board = board
    self.pos = pos
    self.timestamp = TIMESTAMP
    self.removestamp = TIMESTAMP
    self.zobrist_strings = [random.randrange(9223372036854775807)
                            for i in range(3)]
    self.neighbours = None
    self.color = EMPTY
    self.used = False
    self.reference = None
    self.ledges = 0
    self.temp_ledges = 0

</t>
<t tx="ekr.20230509052845.890">def __repr__(self):
    return f"defaultdict(&lt;default factory of '{V.__name__}'&gt;, {super().__repr__()})"

</t>
<t tx="ekr.20230509052845.891">@extend
class Dict:
    def __init__(self: Dict[K, V], other: defaultdict[K, V, S], S: type):
        self._init_from(other)

</t>
<t tx="ekr.20230509052845.892">def namedtuple(name: Static[str], args):  # internal
    pass
</t>
<t tx="ekr.20230509052845.893">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.894">class Error(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("copy.Error", message)

</t>
<t tx="ekr.20230509052845.895">def copy(x):
	return x.__copy__()

</t>
<t tx="ekr.20230509052845.896">def deepcopy(x):
	return x.__deepcopy__()
</t>
<t tx="ekr.20230509052845.897">@path C:/Repos/codon/stdlib/
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: (c) 2022 Python Software Foundation. All right reserved.
# - Currently does not support timezones
# - Timedeltas use a pure-microseconds representations for efficiency, meaning they
#   have a smaller range (+/- 292,471.2 years) but should be more than enough for
#   all practical uses
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

from time import localtime
from time import struct_time

#############
# constants #
#############

MINYEAR = 1
MAXYEAR = 9999
MAXORDINAL = 3652059
MAX_DELTA_DAYS = 999999999

_DI4Y = 1461
_DI100Y = 36524
_DI400Y = 146097

_ROUND_HALF_EVEN = 0
_ROUND_CEILING = 1
_ROUND_FLOOR = 2
_ROUND_UP = 3

#############
# utilities #
#############

@others
@language codon
@tabwidth -4
</t>
<t tx="ekr.20230509052845.898">def _signed_add_overflowed(result: int, i: int, j: int) -&gt; bool:
    return ((result ^ i) &amp; (result ^ j)) &lt; 0

</t>
<t tx="ekr.20230509052845.899">def _divmod(x: int, y: int) -&gt; Tuple[int, int]:
    # assert y &gt; 0
    quo = x // y
    r = x - quo * y
    if r &lt; 0:
        quo -= 1
        r += y
    # assert 0 &lt;= r &lt; y
    return quo, r

</t>
<t tx="ekr.20230509052845.9">def get_argchunks(i, d, chunksize=5000):
    assert chunksize % 2 == 0
    chunk = []
    for k in range(1, i + 1):
        chunk.append((k, d))
        if len(chunk) == chunksize:
            yield chunk
            chunk = []
    if len(chunk) &gt; 0:
        yield chunk

</t>
<t tx="ekr.20230509052845.90">def set_neighbours(self):
    x, y = self.pos % SIZE, self.pos // SIZE
    self.neighbours = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        newx, newy = x + dx, y + dy
        if 0 &lt;= newx &lt; SIZE and 0 &lt;= newy &lt; SIZE:
            self.neighbours.append(self.board.squares[to_pos(newx, newy)])

</t>
<t tx="ekr.20230509052845.900">def _divide_nearest(m: int, n: int) -&gt; int:
    return m // n  # TODO

</t>
<t tx="ekr.20230509052845.901">def _days_in_monthx(i: int) -&gt; int:
    return (0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[i]

</t>
<t tx="ekr.20230509052845.902">def _days_before_monthx(i: int) -&gt; int:
    return (0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334)[i]

</t>
<t tx="ekr.20230509052845.903">def _is_leap(year: int) -&gt; bool:
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

</t>
<t tx="ekr.20230509052845.904">def _days_in_month(year: int, month: int) -&gt; int:
    # assert 1 &lt;= month &lt;= 12
    if month == 2 and _is_leap(year):
        return 29
    else:
        return _days_in_monthx(month)

</t>
<t tx="ekr.20230509052845.905">def _days_before_month(year: int, month: int) -&gt; int:
    # assert 1 &lt;= month &lt;= 12
    days = _days_before_monthx(month)
    if month &gt; 2 and _is_leap(year):
        days += 1
    return days

</t>
<t tx="ekr.20230509052845.906">def _days_before_year(year: int) -&gt; int:
    y = year - 1
    # assert year &gt;= 1
    return y * 365 + y // 4 - y // 100 + y // 400

</t>
<t tx="ekr.20230509052845.907">def _ord_to_ymd(ordinal: int) -&gt; Tuple[int, int, int]:
    ordinal -= 1
    n400 = ordinal // _DI400Y
    n = ordinal % _DI400Y
    year = n400 * 400 + 1

    n100 = n // _DI100Y
    n = n % _DI100Y

    n4 = n // _DI4Y
    n = n % _DI4Y

    n1 = n // 365
    n = n % 365

    year += n100 * 100 + n4 * 4 + n1
    if n1 == 4 or n100 == 4:
        # assert n == 0
        year -= 1
        return (year, 12, 31)

    leapyear = (n1 == 3) and (n4 != 24 or n100 == 3)
    # assert leapyear == is_leap(year)
    month = (n + 50) &gt;&gt; 5
    preceding = _days_before_monthx(month) + int(month &gt; 2 and leapyear)
    if preceding &gt; n:
        month -= 1
        preceding -= _days_in_month(year, month)
    n -= preceding
    # assert 0 &lt;= n
    # assert n &lt; _days_in_month(year, month)
    day = n + 1
    return (year, month, day)

</t>
<t tx="ekr.20230509052845.908">def _ymd_to_ord(year: int, month: int, day: int) -&gt; int:
    return _days_before_year(year) + _days_before_month(year, month) + day

</t>
<t tx="ekr.20230509052845.909">def _weekday(year: int, month: int, day: int) -&gt; int:
    return (_ymd_to_ord(year, month, day) + 6) % 7

</t>
<t tx="ekr.20230509052845.91">def move(self, color):
    global TIMESTAMP, MOVES
    TIMESTAMP += 1
    MOVES += 1
    self.board.zobrist.update(self, color)
    self.color = color
    self.reference = self
    self.ledges = 0
    self.used = True
    for neighbour in self.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            self.ledges += 1
        else:
            neighbour_ref = neighbour.find(update=True)
            if neighcolor == color:
                if neighbour_ref.reference.pos != self.pos:
                    self.ledges += neighbour_ref.ledges
                    neighbour_ref.reference = self
                self.ledges -= 1
            else:
                neighbour_ref.ledges -= 1
                if neighbour_ref.ledges == 0:
                    neighbour.remove(neighbour_ref)
    self.board.zobrist.add()

</t>
<t tx="ekr.20230509052845.910">def _iso_week1_monday(year: int) -&gt; int:
    first_day = _ymd_to_ord(year, 1, 1)
    first_weekday = (first_day + 6) % 7
    week1_monday = first_day - first_weekday
    if first_weekday &gt; 3:
        week1_monday += 7
    return week1_monday

</t>
<t tx="ekr.20230509052845.911">def _check_delta_day_range(days: int):
    if not (-MAX_DELTA_DAYS &lt;= days &lt;= MAX_DELTA_DAYS):
        raise OverflowError(f"days={days}; must have magnitude &lt;= {MAX_DELTA_DAYS}")

</t>
<t tx="ekr.20230509052845.912">def _check_date_args(year: int, month: int, day: int):
    if not (MINYEAR &lt;= year &lt;= MAXYEAR):
        raise ValueError(f"year {year} is out of range")
    if not (1 &lt;= month &lt;= 12):
        raise ValueError("month must be in 1..12")
    if not (1 &lt;= day &lt;= _days_in_month(year, month)):
        raise ValueError("day is out of range for month")

</t>
<t tx="ekr.20230509052845.913">def _check_time_args(hour: int, minute: int, second: int, microsecond: int):
    if not (0 &lt;= hour &lt;= 23):
        raise ValueError("hour must be in 0..23")
    if not (0 &lt;= minute &lt;= 59):
        raise ValueError("minute must be in 0..59")
    if not (0 &lt;= second &lt;= 59):
        raise ValueError("second must be in 0..59")
    if not (0 &lt;= microsecond &lt;= 999999):
        raise ValueError("microsecond must be in 0..999999")

</t>
<t tx="ekr.20230509052845.914">def _normalize_pair(hi: int, lo: int, factor: int) -&gt; Tuple[int, int]:
    # assert factor &gt; 0
    if lo &lt; 0 or lo &gt;= factor:
        num_hi, lo = _divmod(lo, factor)
        new_hi = hi + num_hi
        # assert not _signed_add_overflowed(new_hi, hi, num_hi)
        hi = new_hi
    # assert 0 &lt;= lo &lt; factor
    return hi, lo

</t>
<t tx="ekr.20230509052845.915">def _normalize_d_s_us(d: int, s: int, us: int) -&gt; Tuple[int, int, int]:
    if us &lt; 0 or us &gt;= 1000000:
        s, us = _normalize_pair(s, us, 1000000)
    if s &lt; 0 or s &gt;= 24 * 3600:
        d, s = _normalize_pair(d, s, 24 * 3600)
    # assert 0 &lt;= s &lt; 24*3600
    # assert 0 &lt;= us &lt; 1000000
    return d, s, us

</t>
<t tx="ekr.20230509052845.916">def _normalize_y_m_d(y: int, m: int, d: int) -&gt; Tuple[int, int, int]:
    @others
    # assert 1 &lt;= m &lt;= 12
    dim = _days_in_month(y, m)
    if d &lt; 1 or d &gt; dim:
        if d == 0:
            m -= 1
            if m &gt; 0:
                d = _days_in_month(y, m)
            else:
                y -= 1
                m = 12
                d = 31
        elif d == dim + 1:
            m += 1
            d = 1
            if m &gt; 12:
                m = 1
                y += 1
        else:
            ordinal = _ymd_to_ord(y, m, 1) + d - 1
            if ordinal &lt; 1 or ordinal &gt; MAXORDINAL:
                error()
            else:
                return _ord_to_ymd(ordinal)
    # assert m &gt; 0
    # assert d &gt; 0
    if not (MINYEAR &lt;= y &lt;= MAXYEAR):
        error()
    return y, m, d

</t>
<t tx="ekr.20230509052845.917">def error():
    raise OverflowError("date value out of range")

</t>
<t tx="ekr.20230509052845.918">def _normalize_date(year: int, month: int, day: int) -&gt; Tuple[int, int, int]:
    return _normalize_y_m_d(year, month, day)

</t>
<t tx="ekr.20230509052845.919">def _normalize_datetime(
    year: int,
    month: int,
    day: int,
    hour: int,
    minute: int,
    second: int,
    microsecond: int,
) -&gt; Tuple[int, int, int, int, int, int, int]:
    second, microsecond = _normalize_pair(second, microsecond, 1000000)
    minute, second = _normalize_pair(minute, second, 60)
    hour, minute = _normalize_pair(hour, minute, 60)
    day, hour = _normalize_pair(day, hour, 24)
    year, month, day = _normalize_date(year, month, day)
    return year, month, day, hour, minute, second, microsecond


</t>
<t tx="ekr.20230509052845.92">def remove(self, reference, update=True):
    self.board.zobrist.update(self, EMPTY)
    self.removestamp = TIMESTAMP
    if update:
        self.color = EMPTY
        self.board.emptyset.add(self.pos)
</t>
<t tx="ekr.20230509052845.920">def _parse_digits(digits: str, num_digits: int) -&gt; Tuple[str, int]:
    if len(digits) &lt; num_digits:
        return "", -1
    p = digits.ptr
    var = 0
    for i in range(num_digits):
        tmp = int(p[0]) - 48  # 48 == '0'
        if not (0 &lt;= tmp &lt;= 9):
            return "", -1
        var *= 10
        var += tmp
        p += 1
    return str(p, len(digits) - num_digits), var

</t>
<t tx="ekr.20230509052845.921">def _isoformat_error(s: str):
    raise ValueError(f"Invalid isoformat string: {s}")

</t>
<t tx="ekr.20230509052845.922">def _parse_isoformat_date(dtstr: str) -&gt; Tuple[int, int, int]:
    p = dtstr
    p, year = _parse_digits(p, 4)
    if year &lt; 0:
        _isoformat_error(dtstr)

    if not p or p[0] != "-":
        _isoformat_error(dtstr)
    p = p[1:]

    p, month = _parse_digits(p, 2)
    if month &lt; 0:
        _isoformat_error(dtstr)

    if not p or p[0] != "-":
        _isoformat_error(dtstr)
    p = p[1:]

    p, day = _parse_digits(p, 2)
    if day &lt; 0 or p:
        _isoformat_error(dtstr)

    return year, month, day

</t>
<t tx="ekr.20230509052845.923">def _parse_hh_mm_ss_ff(tstr: str) -&gt; Tuple[int, int, int, int]:
    hour, minute, second, microsecond = 0, 0, 0, 0

    p = tstr
    for i in range(3):
        p, val = _parse_digits(p, 2)
        if val &lt; 0:
            _isoformat_error(tstr)

        if i == 0:
            hour = val
        if i == 1:
            minute = val
        if i == 2:
            second = val

        if not p:
            return hour, minute, second, microsecond
        c = p[0]
        p = p[1:]
        if c == ":":
            continue
        elif c == ".":
            break
        else:
            _isoformat_error(tstr)

    len_remains = len(p)
    if not (len_remains == 6 or len_remains == 3):
        _isoformat_error(tstr)

    p, microsecond = _parse_digits(p, len_remains)
    if microsecond &lt; 0:
        _isoformat_error(tstr)

    if len_remains == 3:
        microsecond *= 1000

    return hour, minute, second, microsecond

</t>
<t tx="ekr.20230509052845.924">def _parse_isoformat_time(dtstr: str) -&gt; Tuple[int, int, int, int, int, int]:
    n = len(dtstr)
    tzinfo_pos = 0
    tzsign = 0
    while tzinfo_pos &lt; n:
        c = dtstr[tzinfo_pos]
        if c == "+":
            tzsign = 1
            break
        if c == "-":
            tzsign = -1
            break
        tzinfo_pos += 1

    hour, minute, second, microsecond = _parse_hh_mm_ss_ff(dtstr[:tzinfo_pos])
    if tzinfo_pos == n:
        return hour, minute, second, microsecond, 0, 0

    tzlen = n - tzinfo_pos
    if not (tzlen == 6 or tzlen == 9 or tzlen == 16):
        _isoformat_error(dtstr)

    tzhour, tzminute, tzsecond, tzmicrosecond = _parse_hh_mm_ss_ff(
        dtstr[tzinfo_pos + 1 :]
    )
    tzoffset = tzsign * ((tzhour * 3600) + (tzminute * 60) + tzsecond)
    tzmicrosecond *= tzsign
    return hour, minute, second, microsecond, tzoffset, tzmicrosecond

</t>
<t tx="ekr.20230509052845.925">def _format_ctime(
    year: int, month: int, day: int, hours: int, minutes: int, seconds: int
) -&gt; str:
    DAY_NAMES = ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
    MONTH_NAMES = (
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    )
    wday = _weekday(year, month, day)
    return f"{DAY_NAMES[wday]} {MONTH_NAMES[month - 1]} {str(day).rjust(2)} {str(hours).zfill(2)}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)} {str(year).zfill(4)}"

</t>
<t tx="ekr.20230509052845.926">def _utc_to_seconds(
    year: int, month: int, day: int, hour: int, minute: int, second: int
) -&gt; int:
    if year &lt; MINYEAR or year &gt; MAXYEAR:
        raise ValueError(f"year {year} is out of range")
    ordinal = _ymd_to_ord(year, month, day)
    return ((ordinal * 24 + hour) * 60 + minute) * 60 + second

</t>
<t tx="ekr.20230509052845.927">def _round_half_even(x: float) -&gt; float:
    from math import fabs

    rounded = x.__round__()
    if fabs(x - rounded) == 0.5:
        rounded = 2.0 * (x / 2.0).__round__()
    return rounded

</t>
<t tx="ekr.20230509052845.928">################
# core classes #
################

</t>
<t tx="ekr.20230509052845.929">@tuple
class timedelta:
    min: ClassVar[timedelta] = timedelta._new(-9223372036854775808)
    max: ClassVar[timedelta] = timedelta._new(9223372036854775807)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _microseconds: int

    @others
</t>
<t tx="ekr.20230509052845.93">#            if color == BLACK:
#                self.board.black_dead += 1
#            else:
#                self.board.white_dead += 1
        for neighbour in self.neighbours:
            if neighbour.color != EMPTY and neighbour.removestamp != TIMESTAMP:
                neighbour_ref = neighbour.find(update)
                if neighbour_ref.pos == reference.pos:
                    neighbour.remove(reference, update)
                else:
                    if update:
                        neighbour_ref.ledges += 1

    def find(self, update=False):
        reference = self.reference
        if reference.pos != self.pos:
            reference = reference.find(update)
            if update:
                self.reference = reference
        return reference

    def __repr__(self):
        return repr(to_xy(self.pos))


</t>
<t tx="ekr.20230509052845.930">def _new(microseconds: int) -&gt; timedelta:
    return (microseconds,)

</t>
<t tx="ekr.20230509052845.931">@inline
def _accum(sofar: int, leftover: float, num: int, factor: int) -&gt; Tuple[int, float]:
    sofar += num * factor
    return sofar, leftover

</t>
<t tx="ekr.20230509052845.932">@inline
def _accum(
    sofar: int, leftover: float, num: float, factor: int
) -&gt; Tuple[int, float]:
    from math import modf

    fracpart, intpart = modf(num)
    prod = int(intpart) * factor
    s = sofar + prod

    if fracpart == 0.0:
        return s, leftover
    dnum = factor * fracpart
    fracpart, intpart = modf(dnum)
    y = s + int(intpart)
    return y, leftover + fracpart

</t>
<t tx="ekr.20230509052845.933"># override default constructor
def __new__(days: int) -&gt; timedelta:
    return timedelta(days, 0)

</t>
<t tx="ekr.20230509052845.934">def __new__(
    days: float = 0,
    seconds: float = 0,
    microseconds: float = 0,
    milliseconds: float = 0,
    minutes: float = 0,
    hours: float = 0,
    weeks: float = 0,
) -&gt; timedelta:
    us = 0
    leftover = 0.0

    us, leftover = timedelta._accum(us, leftover, days, 24 * 60 * 60 * 1000000)
    us, leftover = timedelta._accum(us, leftover, seconds, 1000000)
    us, leftover = timedelta._accum(us, leftover, microseconds, 1)
    us, leftover = timedelta._accum(us, leftover, milliseconds, 1000)
    us, leftover = timedelta._accum(us, leftover, minutes, 60 * 1000000)
    us, leftover = timedelta._accum(us, leftover, hours, 60 * 60 * 1000000)
    us, leftover = timedelta._accum(us, leftover, weeks, 7 * 24 * 60 * 60 * 1000000)

    if leftover:
        from math import fabs

        whole_us = leftover.__round__()
        if fabs(whole_us - leftover) == 0.5:
            is_odd = us &amp; 1
            whole_us = 2.0 * ((leftover + is_odd) * 0.5).__round__() - is_odd
        us += int(whole_us)

    return (us,)

</t>
<t tx="ekr.20230509052845.935">@property
def days(self) -&gt; int:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
    return days

</t>
<t tx="ekr.20230509052845.936">@property
def seconds(self) -&gt; int:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
    return seconds

</t>
<t tx="ekr.20230509052845.937">@property
def microseconds(self) -&gt; int:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
    return microseconds

</t>
<t tx="ekr.20230509052845.938">def __repr__(self) -&gt; str:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
    if days == 0 and seconds == 0 and microseconds == 0:
        return "timedelta(0)"
    v = []
    if days:
        v.append(f"days={days}")
    if seconds:
        v.append(f"seconds={seconds}")
    if microseconds:
        v.append(f"microseconds={microseconds}")
    return f"timedelta({', '.join(v)})"

</t>
<t tx="ekr.20230509052845.939">def __str__(self) -&gt; str:
    days, seconds, us = _normalize_d_s_us(0, 0, self._microseconds)
    minutes, seconds = _divmod(seconds, 60)
    hours, minutes = _divmod(minutes, 60)

    if days:
        if us:
            return f"{days} day{'' if days == 1 or days == -1 else 's'}, {hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}.{str(us).zfill(6)}"
        else:
            return f"{days} day{'' if days == 1 or days == -1 else 's'}, {hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}"
    else:
        if us:
            return f"{hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}.{str(us).zfill(6)}"
        else:
            return f"{hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}"

</t>
<t tx="ekr.20230509052845.94">class EmptySet[Board]:
    board: Board
    empties: List[int]
    empty_pos: List[int]

    @others
</t>
<t tx="ekr.20230509052845.940">def __add__(self, other: timedelta) -&gt; timedelta:
    return timedelta._new(self._microseconds + other._microseconds)

</t>
<t tx="ekr.20230509052845.941">def __sub__(self, other: timedelta) -&gt; timedelta:
    return timedelta._new(self._microseconds - other._microseconds)

</t>
<t tx="ekr.20230509052845.942">def __mul__(self, other: int) -&gt; timedelta:
    return timedelta._new(self._microseconds * other)

</t>
<t tx="ekr.20230509052845.943">def __rmul__(self, other: int) -&gt; timedelta:
    return self * other

</t>
<t tx="ekr.20230509052845.944">def __mul__(self, other: float) -&gt; timedelta:
    return timedelta._new(int(_round_half_even(self._microseconds * other)))

</t>
<t tx="ekr.20230509052845.945">def __rmul__(self, other: float) -&gt; timedelta:
    return self * other

</t>
<t tx="ekr.20230509052845.946">def __truediv__(self, other: timedelta) -&gt; float:
    return self._microseconds / other._microseconds

</t>
<t tx="ekr.20230509052845.947">def __truediv__(self, other: float) -&gt; timedelta:
    return timedelta._new(int(_round_half_even(self._microseconds / other)))

</t>
<t tx="ekr.20230509052845.948">def __truediv__(self, other: int) -&gt; timedelta:
    return self / float(other)

</t>
<t tx="ekr.20230509052845.949">def __floordiv__(self, other: timedelta) -&gt; int:
    return int((self._microseconds / other._microseconds).__floor__())

</t>
<t tx="ekr.20230509052845.95">def __init__(self, board):
    self.board = board
    self.empties = list(range(SIZE * SIZE))
    self.empty_pos = list(range(SIZE * SIZE))

</t>
<t tx="ekr.20230509052845.950">def __floordiv__(self, other: int) -&gt; timedelta:
    return timedelta._new(self._microseconds // other)

</t>
<t tx="ekr.20230509052845.951">def __mod__(self, other: timedelta) -&gt; timedelta:
    n = self._microseconds
    M = other._microseconds
    m = self._microseconds % other._microseconds
    return timedelta._new(((n % M) + M) % M)

</t>
<t tx="ekr.20230509052845.952">def __divmod__(self, other: timedelta) -&gt; Tuple[int, timedelta]:
    return self // other, self % other

</t>
<t tx="ekr.20230509052845.953">def __pos__(self) -&gt; timedelta:
    return self

</t>
<t tx="ekr.20230509052845.954">def __neg__(self) -&gt; timedelta:
    return timedelta._new(-self._microseconds)

</t>
<t tx="ekr.20230509052845.955">def __abs__(self) -&gt; timedelta:
    return timedelta._new(abs(self._microseconds))

</t>
<t tx="ekr.20230509052845.956">def __eq__(self, other: timedelta) -&gt; bool:
    return self._microseconds == other._microseconds

</t>
<t tx="ekr.20230509052845.957">def __ne__(self, other: timedelta) -&gt; bool:
    return self._microseconds != other._microseconds

</t>
<t tx="ekr.20230509052845.958">def __lt__(self, other: timedelta) -&gt; bool:
    return self._microseconds &lt; other._microseconds

</t>
<t tx="ekr.20230509052845.959">def __le__(self, other: timedelta) -&gt; bool:
    return self._microseconds &lt;= other._microseconds

</t>
<t tx="ekr.20230509052845.96">def random_choice(self):
    choices = len(self.empties)
    while choices:
        i = int(random.random() * choices)
        pos = self.empties[i]
        if self.board.useful(pos):
            return pos
        choices -= 1
        self.set(i, self.empties[choices])
        self.set(choices, pos)
    return PASS

</t>
<t tx="ekr.20230509052845.960">def __gt__(self, other: timedelta) -&gt; bool:
    return self._microseconds &gt; other._microseconds

</t>
<t tx="ekr.20230509052845.961">def __ge__(self, other: timedelta) -&gt; bool:
    return self._microseconds &gt;= other._microseconds

</t>
<t tx="ekr.20230509052845.962">def __bool__(self) -&gt; bool:
    return bool(self._microseconds)

</t>
<t tx="ekr.20230509052845.963">def total_seconds(self) -&gt; float:
    return self._microseconds / 1e6

</t>
<t tx="ekr.20230509052845.964">@tuple
class IsoCalendarDate:
    year: int
    week: int
    weekday: int

    def __repr__(self) -&gt; str:
        return f"IsoCalendarDate(year={self.year}, week={self.week}, weekday={self.weekday})"

</t>
<t tx="ekr.20230509052845.965">@tuple
class date:
    min: ClassVar[date] = date(MINYEAR, 1, 1)
    max: ClassVar[date] = date(MAXYEAR, 12, 31)
    resolution: ClassVar[timedelta] = timedelta(days=1)

    _value: UInt[32]

    @others
    # strftime() / __format__() not supported

</t>
<t tx="ekr.20230509052845.966">def __new__(year: int, month: int, day: int) -&gt; date:
    _check_date_args(year, month, day)
    v = (year &lt;&lt; 16) | (month &lt;&lt; 8) | day
    return date(UInt[32](v))

</t>
<t tx="ekr.20230509052845.967">@property
def year(self) -&gt; int:
    v = int(self._value)
    return v &gt;&gt; 16

</t>
<t tx="ekr.20230509052845.968">@property
def month(self) -&gt; int:
    v = int(self._value)
    return (v &gt;&gt; 8) &amp; 0xFF

</t>
<t tx="ekr.20230509052845.969">@property
def day(self) -&gt; int:
    v = int(self._value)
    return v &amp; 0xFF

</t>
<t tx="ekr.20230509052845.97">def add(self, pos):
    self.empty_pos[pos] = len(self.empties)
    self.empties.append(pos)

</t>
<t tx="ekr.20230509052845.970">def __repr__(self) -&gt; str:
    return f"date(year={self.year}, month={self.month}, day={self.day})"

</t>
<t tx="ekr.20230509052845.971">def today() -&gt; date:
    from time import time as ttime

    return date.fromtimestamp(ttime())

</t>
<t tx="ekr.20230509052845.972">def fromtimestamp(timestamp) -&gt; date:
    ts = int(timestamp)
    tm = localtime(ts)
    return date(tm.tm_year, tm.tm_mon, tm.tm_mday)

</t>
<t tx="ekr.20230509052845.973">def fromordinal(ordinal: int) -&gt; date:
    return date(*_ord_to_ymd(ordinal))

</t>
<t tx="ekr.20230509052845.974">def fromisoformat(date_string: str) -&gt; date:
    return date(*_parse_isoformat_date(date_string))

</t>
<t tx="ekr.20230509052845.975">def fromisocalendar(year, week, day) -&gt; date:
    if year &lt; MINYEAR or year &gt; MAXYEAR:
        raise ValueError(f"Year is out of range: {year}")

    if week &lt;= 0 or week &gt;= 53:
        out_of_range = True
        if week == 53:
            first_weekday = _weekday(year, 1, 1)
            if first_weekday == 3 or (first_weekday == 2 and _is_leap(year)):
                out_of_range = False

        if out_of_range:
            raise ValueError(f"Invalid week: {week}")

    if day &lt;= 0 or day &gt;= 8:
        raise ValueError(f"Invalid day: {day} (range is [1, 7])")

    day_1 = _iso_week1_monday(year)
    month = week
    day_offset = (month - 1) * 7 + day - 1
    return date(*_ord_to_ymd(day_1 + day_offset))

</t>
<t tx="ekr.20230509052845.976">def __add__(self, other: timedelta) -&gt; date:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, other._microseconds)
    day = self.day + days
    return date(*_normalize_date(self.year, self.month, day))

</t>
<t tx="ekr.20230509052845.977">def __sub__(self, other: timedelta) -&gt; date:
    days, seconds, microseconds = _normalize_d_s_us(0, 0, other._microseconds)
    day = self.day - days
    return date(*_normalize_date(self.year, self.month, day))

</t>
<t tx="ekr.20230509052845.978">def __sub__(self, other: date) -&gt; timedelta:
    left_ord = _ymd_to_ord(self.year, self.month, self.day)
    right_ord = _ymd_to_ord(other.year, other.month, other.day)
    return timedelta(days=left_ord - right_ord)

</t>
<t tx="ekr.20230509052845.979">def __eq__(self, other: date) -&gt; bool:
    return self._value == other._value

</t>
<t tx="ekr.20230509052845.98">def remove(self, pos):
    self.set(self.empty_pos[pos], self.empties[len(self.empties) - 1])
    self.empties.pop()

</t>
<t tx="ekr.20230509052845.980">def __ne__(self, other: date) -&gt; bool:
    return self._value != other._value

</t>
<t tx="ekr.20230509052845.981">def __lt__(self, other: date) -&gt; bool:
    return self._value &lt; other._value

</t>
<t tx="ekr.20230509052845.982">def __le__(self, other: date) -&gt; bool:
    return self._value &lt;= other._value

</t>
<t tx="ekr.20230509052845.983">def __gt__(self, other: date) -&gt; bool:
    return self._value &gt; other._value

</t>
<t tx="ekr.20230509052845.984">def __ge__(self, other: date) -&gt; bool:
    return self._value &gt;= other._value

</t>
<t tx="ekr.20230509052845.985">def __bool__(self) -&gt; bool:
    return True

</t>
<t tx="ekr.20230509052845.986">def replace(self, year: int = -1, month: int = -1, day: int = -1) -&gt; date:
    if year == -1:
        year = self.year
    if month == -1:
        month = self.month
    if day == -1:
        day = self.day
    return date(year, month, day)

</t>
<t tx="ekr.20230509052845.987">def timetuple(self) -&gt; struct_time:
    yday = self.toordinal() - date(self.year, 1, 1).toordinal() + 1
    return struct_time(
        self.year, self.month, self.day, 0, 0, 0, self.weekday(), yday, -1
    )

</t>
<t tx="ekr.20230509052845.988">def toordinal(self) -&gt; int:
    return _ymd_to_ord(self.year, self.month, self.day)

</t>
<t tx="ekr.20230509052845.989">def weekday(self) -&gt; int:
    return _weekday(self.year, self.month, self.day)

</t>
<t tx="ekr.20230509052845.99">def set(self, i, pos):
    self.empties[i] = pos
    self.empty_pos[pos] = i


</t>
<t tx="ekr.20230509052845.990">def isoweekday(self) -&gt; int:
    return self.weekday() + 1

</t>
<t tx="ekr.20230509052845.991">def isocalendar(self) -&gt; IsoCalendarDate:
    year = self.year
    week1_monday = _iso_week1_monday(year)
    today = _ymd_to_ord(year, self.month, self.day)
    week, day = _divmod(today - week1_monday, 7)
    if week &lt; 0:
        year -= 1
        week1_monday = _iso_week1_monday(year)
        week, day = _divmod(today - week1_monday, 7)
    elif week &gt;= 52 and today &gt;= _iso_week1_monday(year + 1):
        year += 1
        week = 0
    return IsoCalendarDate(year, week + 1, day + 1)

</t>
<t tx="ekr.20230509052845.992">def isoformat(self) -&gt; str:
    return f"{str(self.year).zfill(4)}-{str(self.month).zfill(2)}-{str(self.day).zfill(2)}"

</t>
<t tx="ekr.20230509052845.993">def __str__(self) -&gt; str:
    return self.isoformat()

</t>
<t tx="ekr.20230509052845.994">def ctime(self) -&gt; str:
    return _format_ctime(self.year, self.month, self.day, 0, 0, 0)

</t>
<t tx="ekr.20230509052845.995">@tuple
class time:
    min: ClassVar[time] = time(0, 0, 0, 0)
    max: ClassVar[time] = time(23, 59, 59, 999999)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _value: int

    @others
</t>
<t tx="ekr.20230509052845.996">def __new__(
    hour: int = 0, minute: int = 0, second: int = 0, microsecond: int = 0
) -&gt; time:
    _check_time_args(hour, minute, second, microsecond)
    v = (hour &lt;&lt; 40) | (minute &lt;&lt; 32) | (second &lt;&lt; 24) | microsecond
    return (v,)

</t>
<t tx="ekr.20230509052845.997">@property
def hour(self) -&gt; int:
    v = self._value
    return v &gt;&gt; 40

</t>
<t tx="ekr.20230509052845.998">@property
def minute(self) -&gt; int:
    v = self._value
    return (v &gt;&gt; 32) &amp; 0xFF

</t>
<t tx="ekr.20230509052845.999">@property
def second(self) -&gt; int:
    v = self._value
    return (v &gt;&gt; 24) &amp; 0xFF

</t>
</tnodes>
</leo_file>
