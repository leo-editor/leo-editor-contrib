<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="http://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20230509052845.1"><vh>codon</vh></v>
<v t="ekr.20230509083458.1"><vh>@settings</vh>
<v t="ekr.20230509083532.1"><vh>@bool run-flake8-on-write = False</vh></v>
</v>
<v t="ekr.20230509083132.1"><vh> Recursive import script</vh></v>
<v t="ekr.20230509083242.3"><vh>@path bench</vh>
<v t="ekr.20230509083242.4"><vh>@path binary_trees</vh>
<v t="ekr.20230509083242.5"><vh>@@clean binary_trees.codon</vh></v>
<v t="ekr.20230509083242.6"><vh>@@clean binary_trees.cpp</vh>
<v t="ekr.20230509083242.7"><vh>bool next</vh></v>
<v t="ekr.20230509083242.8"><vh>}</vh></v>
<v t="ekr.20230509083242.9"><vh>int main</vh></v>
</v>
<v t="ekr.20230509083242.10"><vh>@@clean binary_trees.py</vh>
<v t="ekr.20230509083242.11"><vh>class Node</vh></v>
<v t="ekr.20230509083242.12"><vh>make_tree</vh></v>
<v t="ekr.20230509083242.13"><vh>check_tree</vh></v>
<v t="ekr.20230509083242.14"><vh>make_check</vh></v>
<v t="ekr.20230509083242.15"><vh>get_argchunks</vh></v>
<v t="ekr.20230509083242.16"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509083242.17"><vh>@path chaos</vh>
<v t="ekr.20230509083242.18"><vh>@@clean chaos.codon</vh></v>
<v t="ekr.20230509083242.19"><vh>@@clean chaos.py</vh>
<v t="ekr.20230509083242.20"><vh>class GVector</vh>
<v t="ekr.20230509083242.21"><vh>GVector.__init__</vh></v>
<v t="ekr.20230509083242.22"><vh>GVector.Mag</vh></v>
<v t="ekr.20230509083242.23"><vh>GVector.dist</vh></v>
<v t="ekr.20230509083242.24"><vh>GVector.__add__</vh></v>
<v t="ekr.20230509083242.25"><vh>GVector.__sub__</vh></v>
<v t="ekr.20230509083242.26"><vh>GVector.__mul__</vh></v>
<v t="ekr.20230509083242.27"><vh>GVector.__rmul__ = __mul__</vh></v>
<v t="ekr.20230509083242.28"><vh>GVector.linear_combination</vh></v>
<v t="ekr.20230509083242.29"><vh>GVector.__str__</vh></v>
<v t="ekr.20230509083242.30"><vh>GVector.__repr__</vh></v>
</v>
<v t="ekr.20230509083242.31"><vh>class Spline</vh>
<v t="ekr.20230509083242.32"><vh>Spline.__init__</vh></v>
<v t="ekr.20230509083242.33"><vh>Spline.GetDomain</vh></v>
<v t="ekr.20230509083242.34"><vh>Spline.__call__</vh></v>
<v t="ekr.20230509083242.35"><vh>Spline.GetIndex</vh></v>
<v t="ekr.20230509083242.36"><vh>Spline.__len__</vh></v>
<v t="ekr.20230509083242.37"><vh>Spline.__repr__</vh></v>
</v>
<v t="ekr.20230509083242.38"><vh>write_ppm</vh></v>
<v t="ekr.20230509083242.39"><vh>class Chaosgame</vh>
<v t="ekr.20230509083242.40"><vh>Chaosgame.__init__</vh></v>
<v t="ekr.20230509083242.41"><vh>Chaosgame.get_random_trafo</vh></v>
<v t="ekr.20230509083242.42"><vh>Chaosgame.transform_point</vh></v>
<v t="ekr.20230509083242.43"><vh>Chaosgame.truncate</vh></v>
<v t="ekr.20230509083242.44"><vh>Chaosgame.create_image_chaos</vh></v>
</v>
<v t="ekr.20230509083242.45"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509083242.46"><vh>@path fannkuch</vh>
<v t="ekr.20230509083242.47"><vh>@@clean fannkuch.codon</vh></v>
<v t="ekr.20230509083242.48"><vh>@@clean fannkuch.py</vh>
<v t="ekr.20230509083242.49"><vh>perm</vh></v>
</v>
</v>
<v t="ekr.20230509083242.50"><vh>@path float</vh>
<v t="ekr.20230509083242.51"><vh>@@clean float.py</vh>
<v t="ekr.20230509083242.52"><vh>class Point</vh>
<v t="ekr.20230509083242.53"><vh>Point.__init__</vh></v>
<v t="ekr.20230509083242.54"><vh>Point.__repr__</vh></v>
<v t="ekr.20230509083242.55"><vh>Point.normalize</vh></v>
<v t="ekr.20230509083242.56"><vh>Point.maximize</vh></v>
</v>
<v t="ekr.20230509083242.57"><vh>maximize</vh></v>
<v t="ekr.20230509083242.58"><vh>benchmark</vh></v>
</v>
</v>
<v t="ekr.20230509083242.59"><vh>@path go</vh>
<v t="ekr.20230509083242.60"><vh>@@clean go.codon</vh></v>
<v t="ekr.20230509083242.61"><vh>@@clean go.py</vh>
<v t="ekr.20230509083242.62"><vh>to_pos</vh></v>
<v t="ekr.20230509083242.63"><vh>to_xy</vh></v>
<v t="ekr.20230509083242.64"><vh>class Square</vh>
<v t="ekr.20230509083242.65"><vh>Square.__init__</vh></v>
<v t="ekr.20230509083242.66"><vh>Square.set_neighbours</vh></v>
<v t="ekr.20230509083242.67"><vh>Square.move</vh></v>
<v t="ekr.20230509083242.68"><vh>Square.remove</vh></v>
</v>
<v t="ekr.20230509083242.69"><vh>if color == BLACK:</vh></v>
<v t="ekr.20230509083242.70"><vh>class EmptySet</vh>
<v t="ekr.20230509083242.71"><vh>EmptySet.__init__</vh></v>
<v t="ekr.20230509083242.72"><vh>EmptySet.random_choice</vh></v>
<v t="ekr.20230509083242.73"><vh>EmptySet.add</vh></v>
<v t="ekr.20230509083242.74"><vh>EmptySet.remove</vh></v>
<v t="ekr.20230509083242.75"><vh>EmptySet.set</vh></v>
</v>
<v t="ekr.20230509083242.76"><vh>class ZobristHash</vh>
<v t="ekr.20230509083242.77"><vh>ZobristHash.__init__</vh></v>
<v t="ekr.20230509083242.78"><vh>ZobristHash.update</vh></v>
<v t="ekr.20230509083242.79"><vh>ZobristHash.add</vh></v>
<v t="ekr.20230509083242.80"><vh>ZobristHash.dupe</vh></v>
</v>
<v t="ekr.20230509083242.81"><vh>class Board</vh>
<v t="ekr.20230509083242.82"><vh>Board.__init__</vh></v>
<v t="ekr.20230509083242.83"><vh>Board.reset</vh></v>
<v t="ekr.20230509083242.84"><vh>Board.move</vh></v>
<v t="ekr.20230509083242.85"><vh>Board.random_move</vh></v>
<v t="ekr.20230509083242.86"><vh>Board.useful_fast</vh></v>
<v t="ekr.20230509083242.87"><vh>Board.useful</vh></v>
<v t="ekr.20230509083242.88"><vh>Board.useful_moves</vh></v>
<v t="ekr.20230509083242.89"><vh>Board.replay</vh></v>
<v t="ekr.20230509083242.90"><vh>Board.score</vh></v>
<v t="ekr.20230509083242.91"><vh>Board.check</vh></v>
<v t="ekr.20230509083242.92"><vh>Board.__repr__</vh></v>
</v>
<v t="ekr.20230509083242.93"><vh>class UCTNode</vh>
<v t="ekr.20230509083242.94"><vh>UCTNode.__init__</vh></v>
<v t="ekr.20230509083242.95"><vh>UCTNode.play</vh></v>
<v t="ekr.20230509083242.96"><vh>UCTNode.select</vh></v>
<v t="ekr.20230509083242.97"><vh>UCTNode.random_playout</vh></v>
<v t="ekr.20230509083242.98"><vh>UCTNode.update_path</vh></v>
<v t="ekr.20230509083242.99"><vh>UCTNode.score</vh></v>
<v t="ekr.20230509083242.100"><vh>UCTNode.best_child</vh></v>
<v t="ekr.20230509083242.101"><vh>UCTNode.best_visited</vh></v>
</v>
<v t="ekr.20230509083242.102"><vh>def user_move(board):</vh></v>
<v t="ekr.20230509083242.103"><vh>computer_move</vh></v>
<v t="ekr.20230509083242.104"><vh>versus_cpu</vh></v>
</v>
</v>
<v t="ekr.20230509083242.105"><vh>@path mandelbrot</vh>
<v t="ekr.20230509083242.106"><vh>@@clean mandelbrot.codon</vh></v>
<v t="ekr.20230509083242.107"><vh>@@clean mandelbrot.py</vh>
<v t="ekr.20230509083242.108"><vh>scale</vh></v>
</v>
</v>
<v t="ekr.20230509083242.109"><vh>@@path nbody</vh>
<v t="ekr.20230509084801.1"><vh>@edit nbody.cpp</vh></v>
<v t="ekr.20230509083242.118"><vh>@@clean nbody.py</vh>
<v t="ekr.20230509083242.119"><vh>combinations</vh></v>
<v t="ekr.20230509083242.120"><vh>PI = 3.14159265358979323</vh></v>
<v t="ekr.20230509083242.121"><vh>advance</vh></v>
<v t="ekr.20230509083242.122"><vh>report_energy</vh></v>
<v t="ekr.20230509083242.123"><vh>offset_momentum</vh></v>
<v t="ekr.20230509083242.124"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20230509083242.125"><vh>@path primes</vh>
<v t="ekr.20230509083242.126"><vh>@@clean primes.codon</vh></v>
<v t="ekr.20230509083242.127"><vh>@@clean primes.py</vh>
<v t="ekr.20230509083242.128"><vh>is_prime</vh></v>
</v>
</v>
<v t="ekr.20230509083242.129"><vh>@path set_partition</vh>
<v t="ekr.20230509083242.130"><vh>@@clean set_partition.cpp</vh>
<v t="ekr.20230509083242.131"><vh>int minsize</vh>
<v t="ekr.20230509083242.132"><vh>auto loop</vh></v>
</v>
<v t="ekr.20230509083242.133"><vh>int main</vh>
<v t="ekr.20230509083242.134"><vh>auto callback</vh></v>
</v>
</v>
<v t="ekr.20230509083242.135"><vh>@@clean set_partition.py</vh>
<v t="ekr.20230509083242.136"><vh>conforms</vh></v>
<v t="ekr.20230509083242.137"><vh>partition_filtered</vh></v>
</v>
</v>
<v t="ekr.20230509083242.138"><vh>@path spectral_norm</vh>
<v t="ekr.20230509083242.139"><vh>@@clean spectral_norm.py</vh>
<v t="ekr.20230509083242.140"><vh>eval_A</vh></v>
<v t="ekr.20230509083242.141"><vh>eval_times_u</vh></v>
<v t="ekr.20230509083242.142"><vh>part_At_times_u</vh></v>
<v t="ekr.20230509083242.143"><vh>part_A_times_u</vh></v>
<v t="ekr.20230509083242.144"><vh>eval_AtA_times_u</vh></v>
<v t="ekr.20230509083242.145"><vh>bench_spectral_norm</vh></v>
</v>
</v>
<v t="ekr.20230509083242.146"><vh>@path sum</vh>
<v t="ekr.20230509083242.147"><vh>@@clean sum.py</vh></v>
</v>
<v t="ekr.20230509083242.148"><vh>@path taq</vh>
<v t="ekr.20230509083242.149"><vh>@@clean taq.cpp</vh>
<v t="ekr.20230509083242.150"><vh>int main</vh></v>
</v>
<v t="ekr.20230509083242.151"><vh>@@clean taq.py</vh>
<v t="ekr.20230509083242.152"><vh>find_peaks</vh></v>
<v t="ekr.20230509083242.153"><vh>process_data</vh></v>
</v>
</v>
<v t="ekr.20230509083242.154"><vh>@path word_count</vh>
<v t="ekr.20230509083242.155"><vh>@@clean word_count.cpp</vh>
<v t="ekr.20230509083242.156"><vh>int main</vh></v>
</v>
<v t="ekr.20230509083242.157"><vh>@@clean word_count.py</vh></v>
</v>
</v>
<v t="ekr.20230509083242.159"><vh>@path codon</vh>
<v t="ekr.20230509083242.160"><vh>@path app</vh>
<v t="ekr.20230509083242.161"><vh>@@clean main.cpp</vh>
<v t="ekr.20230509083242.162"><vh>void versMsg</vh></v>
<v t="ekr.20230509083242.163"><vh>bool isMacOS</vh></v>
<v t="ekr.20230509083242.164"><vh>const std::vector</vh></v>
<v t="ekr.20230509083242.165"><vh>bool hasExtension</vh></v>
<v t="ekr.20230509083242.166"><vh>std::string trimExtension</vh></v>
<v t="ekr.20230509083242.167"><vh>const std::string</vh></v>
<v t="ekr.20230509083242.168"><vh>void display</vh></v>
<v t="ekr.20230509083242.169"><vh>void initLogFlags</vh></v>
<v t="ekr.20230509083242.170"><vh>enum BuildKind</vh></v>
<v t="ekr.20230509083242.171"><vh>int docMode</vh></v>
<v t="ekr.20230509083242.172"><vh>std::unique_ptr&lt;codon::Compiler&gt; processSource</vh></v>
<v t="ekr.20230509083242.173"><vh>const std::vector</vh>
<v t="ekr.20230509083242.174"><vh>auto compiler</vh></v>
</v>
<v t="ekr.20230509083242.175"><vh>int runMode</vh></v>
<v t="ekr.20230509083242.176"><vh>namespace</vh></v>
<v t="ekr.20230509083242.177"><vh>void jitLoop</vh></v>
<v t="ekr.20230509083242.178"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.179"><vh>int jitMode</vh></v>
<v t="ekr.20230509083242.180"><vh>int buildMode</vh>
<v t="ekr.20230509083242.181"><vh>auto compiler</vh></v>
<v t="ekr.20230509083242.182"><vh>const std::string</vh></v>
</v>
<v t="ekr.20230509083242.183"><vh>int jupyterMode</vh></v>
<v t="ekr.20230509083242.184"><vh>void showCommandsAndExit</vh></v>
<v t="ekr.20230509083242.185"><vh>int otherMode</vh></v>
<v t="ekr.20230509083242.186"><vh>int main</vh></v>
</v>
</v>
<v t="ekr.20230509083242.187"><vh>@path cir</vh>
<v t="ekr.20230509083242.188"><vh>@@clean attribute.cpp</vh>
<v t="ekr.20230509083242.189"><vh>bool KeyValueAttribute::has</vh></v>
</v>
<v t="ekr.20230509083242.190"><vh>@@clean attribute.h</vh></v>
<v t="ekr.20230509083242.191"><vh>@@clean base.cpp</vh>
<v t="ekr.20230509083242.192"><vh>int Node::replaceUsedValue</vh></v>
<v t="ekr.20230509083242.193"><vh>int Node::replaceUsedType</vh></v>
<v t="ekr.20230509083242.194"><vh>int Node::replaceUsedVariable</vh></v>
</v>
<v t="ekr.20230509083242.195"><vh>@@clean base.h</vh>
<v t="ekr.20230509083242.196"><vh>class IdMixin</vh></v>
<v t="ekr.20230509083242.197"><vh>class Node</vh>
<v t="ekr.20230509083242.198"><vh>Node.void setAttribute</vh></v>
<v t="ekr.20230509083242.199"><vh>Node.template &lt;typename AttributeType&gt;</vh></v>
<v t="ekr.20230509083242.200"><vh>Node.bool hasAttribute</vh></v>
<v t="ekr.20230509083242.201"><vh>Node./// @return true if the attribute is in the store</vh></v>
<v t="ekr.20230509083242.202"><vh>Node.const Attribute</vh></v>
<v t="ekr.20230509083242.203"><vh>Node./// Gets the appropriate attribute.</vh></v>
<v t="ekr.20230509083242.204"><vh>Node.auto attributes_begin</vh></v>
<v t="ekr.20230509083242.205"><vh>Node./// @return iterator beyond the last attribute</vh></v>
<v t="ekr.20230509083242.206"><vh>Node.auto attributes_begin</vh></v>
<v t="ekr.20230509083242.207"><vh>Node.auto attributes_end</vh></v>
<v t="ekr.20230509083242.208"><vh>Node.void setSrcInfo</vh></v>
<v t="ekr.20230509083242.209"><vh>Node./// @return the src info</vh></v>
<v t="ekr.20230509083242.210"><vh>Node.const Node</vh></v>
</v>
<v t="ekr.20230509083242.211"><vh>template &lt;typename Derived, typename Parent&gt; class AcceptorExtend : public Parent</vh></v>
<v t="ekr.20230509083242.212"><vh>void accept</vh></v>
<v t="ekr.20230509083242.213"><vh>void accept</vh></v>
<v t="ekr.20230509083242.214"><vh>}</vh></v>
<v t="ekr.20230509083242.215"><vh>template &lt;typename Derived&gt;</vh>
<v t="ekr.20230509083242.216"><vh>class ReplaceableNodeBase</vh>
<v t="ekr.20230509083242.217"><vh>ReplaceableNodeBase.const Derived</vh></v>
<v t="ekr.20230509083242.218"><vh>ReplaceableNodeBase.void replaceAll</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.219"><vh>@@clean cir.h</vh></v>
<v t="ekr.20230509083242.220"><vh>@@clean const.cpp</vh>
<v t="ekr.20230509083242.221"><vh>int Const::doReplaceUsedType</vh></v>
</v>
<v t="ekr.20230509083242.222"><vh>@@clean const.h</vh>
<v t="ekr.20230509083242.223"><vh>class Const</vh></v>
<v t="ekr.20230509083242.224"><vh>template &lt;typename ValueType&gt;</vh>
<v t="ekr.20230509083242.225"><vh>class TemplatedConst</vh></v>
</v>
<v t="ekr.20230509083242.226"><vh>using IntConst</vh></v>
<v t="ekr.20230509083242.227"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509083242.228"><vh>class TemplatedConst</vh></v>
</v>
</v>
<v t="ekr.20230509083242.229"><vh>@@clean flow.cpp</vh>
<v t="ekr.20230509083242.230"><vh>int findAndReplace</vh></v>
<v t="ekr.20230509083242.231"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.232"><vh>int SeriesFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.233"><vh>const char WhileFlow::NodeId</vh></v>
<v t="ekr.20230509083242.234"><vh>int WhileFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.235"><vh>const char ForFlow::NodeId</vh></v>
<v t="ekr.20230509083242.236"><vh>int ForFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.237"><vh>int ForFlow::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.238"><vh>const char ImperativeForFlow::NodeId</vh></v>
<v t="ekr.20230509083242.239"><vh>int ImperativeForFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.240"><vh>int ImperativeForFlow::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.241"><vh>const char IfFlow::NodeId</vh></v>
<v t="ekr.20230509083242.242"><vh>int IfFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.243"><vh>const char TryCatchFlow::NodeId</vh></v>
<v t="ekr.20230509083242.244"><vh>int TryCatchFlow::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.245"><vh>std::vector&lt;types::Type *&gt; TryCatchFlow::doGetUsedTypes</vh></v>
<v t="ekr.20230509083242.246"><vh>int TryCatchFlow::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.247"><vh>std::vector&lt;Var *&gt; TryCatchFlow::doGetUsedVariables</vh></v>
<v t="ekr.20230509083242.248"><vh>int TryCatchFlow::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.249"><vh>const char PipelineFlow::NodeId</vh></v>
<v t="ekr.20230509083242.250"><vh>int PipelineFlow::doReplaceUsedValue</vh></v>
</v>
<v t="ekr.20230509083242.251"><vh>@@clean flow.h</vh>
<v t="ekr.20230509083242.252"><vh>class Flow</vh></v>
<v t="ekr.20230509083242.253"><vh>class SeriesFlow</vh></v>
<v t="ekr.20230509083242.254"><vh>class WhileFlow</vh></v>
<v t="ekr.20230509083242.255"><vh>class ForFlow</vh>
<v t="ekr.20230509083242.256"><vh>ForFlow.void setParallel</vh></v>
<v t="ekr.20230509083242.257"><vh>ForFlow./// @return the parallel loop schedule, or null if none</vh></v>
<v t="ekr.20230509083242.258"><vh>ForFlow.void setSchedule</vh></v>
</v>
<v t="ekr.20230509083242.259"><vh>class ImperativeForFlow</vh>
<v t="ekr.20230509083242.260"><vh>ImperativeForFlow.void setParallel</vh></v>
<v t="ekr.20230509083242.261"><vh>ImperativeForFlow./// @return the parallel loop schedule, or null if none</vh></v>
<v t="ekr.20230509083242.262"><vh>ImperativeForFlow.void setSchedule</vh></v>
</v>
<v t="ekr.20230509083242.263"><vh>class IfFlow</vh></v>
<v t="ekr.20230509083242.264"><vh>class TryCatchFlow</vh>
<v t="ekr.20230509083242.265"><vh>class Catch</vh></v>
</v>
<v t="ekr.20230509083242.266"><vh>class PipelineFlow</vh>
<v t="ekr.20230509083242.267"><vh>class Stage</vh></v>
</v>
</v>
<v t="ekr.20230509083242.268"><vh>@@clean func.cpp</vh>
<v t="ekr.20230509083242.269"><vh>int findAndReplace</vh></v>
<v t="ekr.20230509083242.270"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.271"><vh>void Func::realize</vh></v>
<v t="ekr.20230509083242.272"><vh>Var *Func::getArgVar</vh></v>
<v t="ekr.20230509083242.273"><vh>auto it</vh></v>
<v t="ekr.20230509083242.274"><vh>int Func::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.275"><vh>std::vector&lt;types::Type *&gt; Func::doGetUsedTypes</vh></v>
<v t="ekr.20230509083242.276"><vh>int Func::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.277"><vh>const char BodiedFunc::NodeId</vh></v>
<v t="ekr.20230509083242.278"><vh>int BodiedFunc::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.279"><vh>std::vector&lt;Var *&gt; BodiedFunc::doGetUsedVariables</vh></v>
<v t="ekr.20230509083242.280"><vh>int BodiedFunc::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.281"><vh>const char ExternalFunc::NodeId</vh></v>
<v t="ekr.20230509083242.282"><vh>int LLVMFunc::doReplaceUsedType</vh></v>
</v>
<v t="ekr.20230509083242.283"><vh>@@clean func.h</vh>
<v t="ekr.20230509083242.284"><vh>class Func</vh></v>
<v t="ekr.20230509083242.285"><vh>class BodiedFunc</vh></v>
<v t="ekr.20230509083242.286"><vh>class ExternalFunc</vh></v>
<v t="ekr.20230509083242.287"><vh>class InternalFunc</vh></v>
<v t="ekr.20230509083242.288"><vh>class LLVMFunc</vh></v>
</v>
<v t="ekr.20230509083242.289"><vh>@@clean instr.cpp</vh>
<v t="ekr.20230509083242.290"><vh>int findAndReplace</vh></v>
<v t="ekr.20230509083242.291"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.292"><vh>int AssignInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.293"><vh>int AssignInstr::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.294"><vh>const char ExtractInstr::NodeId</vh></v>
<v t="ekr.20230509083242.295"><vh>int ExtractInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.296"><vh>const char InsertInstr::NodeId</vh></v>
<v t="ekr.20230509083242.297"><vh>int InsertInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.298"><vh>const char CallInstr::NodeId</vh></v>
<v t="ekr.20230509083242.299"><vh>int CallInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.300"><vh>const char StackAllocInstr::NodeId</vh></v>
<v t="ekr.20230509083242.301"><vh>int StackAllocInstr::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.302"><vh>const char TypePropertyInstr::NodeId</vh></v>
<v t="ekr.20230509083242.303"><vh>int TypePropertyInstr::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.304"><vh>const char YieldInInstr::NodeId</vh></v>
<v t="ekr.20230509083242.305"><vh>int YieldInInstr::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.306"><vh>const char TernaryInstr::NodeId</vh></v>
<v t="ekr.20230509083242.307"><vh>int TernaryInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.308"><vh>const char ControlFlowInstr::NodeId</vh></v>
<v t="ekr.20230509083242.309"><vh>int BreakInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.310"><vh>const char ContinueInstr::NodeId</vh></v>
<v t="ekr.20230509083242.311"><vh>int ContinueInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.312"><vh>const char ReturnInstr::NodeId</vh></v>
<v t="ekr.20230509083242.313"><vh>int ReturnInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.314"><vh>const char YieldInstr::NodeId</vh></v>
<v t="ekr.20230509083242.315"><vh>int YieldInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.316"><vh>const char ThrowInstr::NodeId</vh></v>
<v t="ekr.20230509083242.317"><vh>int ThrowInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.318"><vh>const char FlowInstr::NodeId</vh></v>
<v t="ekr.20230509083242.319"><vh>int FlowInstr::doReplaceUsedValue</vh></v>
</v>
<v t="ekr.20230509083242.320"><vh>@@clean instr.h</vh>
<v t="ekr.20230509083242.321"><vh>class Instr</vh></v>
<v t="ekr.20230509083242.322"><vh>class AssignInstr</vh></v>
<v t="ekr.20230509083242.323"><vh>class ExtractInstr</vh></v>
<v t="ekr.20230509083242.324"><vh>class InsertInstr</vh></v>
<v t="ekr.20230509083242.325"><vh>class CallInstr</vh></v>
<v t="ekr.20230509083242.326"><vh>class StackAllocInstr</vh></v>
<v t="ekr.20230509083242.327"><vh>class TypePropertyInstr</vh></v>
<v t="ekr.20230509083242.328"><vh>class YieldInInstr</vh></v>
<v t="ekr.20230509083242.329"><vh>class TernaryInstr</vh></v>
<v t="ekr.20230509083242.330"><vh>class ControlFlowInstr</vh></v>
<v t="ekr.20230509083242.331"><vh>class BreakInstr</vh></v>
<v t="ekr.20230509083242.332"><vh>class ContinueInstr</vh></v>
<v t="ekr.20230509083242.333"><vh>class ReturnInstr</vh></v>
<v t="ekr.20230509083242.334"><vh>class YieldInstr</vh></v>
<v t="ekr.20230509083242.335"><vh>class ThrowInstr</vh></v>
<v t="ekr.20230509083242.336"><vh>class FlowInstr</vh></v>
</v>
<v t="ekr.20230509083242.337"><vh>@@clean module.cpp</vh>
<v t="ekr.20230509083242.338"><vh>auto cls</vh></v>
<v t="ekr.20230509083242.339"><vh>}</vh></v>
<v t="ekr.20230509083242.340"><vh>const std::string</vh>
<v t="ekr.20230509083242.341"><vh>auto fqName</vh></v>
</v>
<v t="ekr.20230509083242.342"><vh>types::Type *Module::getOrRealizeType</vh></v>
<v t="ekr.20230509083242.343"><vh>const std::string</vh>
<v t="ekr.20230509083242.344"><vh>auto fqName</vh></v>
</v>
<v t="ekr.20230509083242.345"><vh>types::Type *Module::getVoidType</vh></v>
<v t="ekr.20230509083242.346"><vh>bool variadic</vh></v>
</v>
<v t="ekr.20230509083242.347"><vh>@@clean module.h</vh>
<v t="ekr.20230509083242.348"><vh>class Module</vh>
<v t="ekr.20230509083242.349"><vh>Module.const Var</vh></v>
<v t="ekr.20230509083242.350"><vh>Module.void remove</vh></v>
<v t="ekr.20230509083242.351"><vh>Module./// @return iterator to the first value</vh></v>
<v t="ekr.20230509083242.352"><vh>Module.const Value</vh></v>
<v t="ekr.20230509083242.353"><vh>Module.void remove</vh></v>
<v t="ekr.20230509083242.354"><vh>Module./// @return iterator to the first type</vh></v>
<v t="ekr.20230509083242.355"><vh>Module.void remove</vh></v>
<v t="ekr.20230509083242.356"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509083242.357"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509083242.358"><vh>Module.template &lt;typename DesiredType, typename... Args&gt;</vh></v>
<v t="ekr.20230509083242.359"><vh>Module./// Constructs and registers an IR node with no source information.</vh></v>
<v t="ekr.20230509083242.360"><vh>Module.void store</vh></v>
<v t="ekr.20230509083242.361"><vh>Module.void store</vh></v>
<v t="ekr.20230509083242.362"><vh>Module.void store</vh></v>
</v>
</v>
<v t="ekr.20230509083242.363"><vh>@@clean pyextension.h</vh></v>
<v t="ekr.20230509083242.364"><vh>@@clean value.cpp</vh></v>
<v t="ekr.20230509083242.365"><vh>@@clean value.h</vh>
<v t="ekr.20230509083242.366"><vh>class Value</vh>
<v t="ekr.20230509083242.367"><vh>Value.int replaceUsedValue</vh></v>
<v t="ekr.20230509083242.368"><vh>Value.using Node::replaceUsedValue</vh></v>
<v t="ekr.20230509083242.369"><vh>Value.int replaceUsedType</vh></v>
<v t="ekr.20230509083242.370"><vh>Value.using Node::replaceUsedType</vh></v>
<v t="ekr.20230509083242.371"><vh>Value.int replaceUsedVariable</vh></v>
</v>
</v>
<v t="ekr.20230509083242.372"><vh>@@clean var.cpp</vh>
<v t="ekr.20230509083242.373"><vh>int Var::doReplaceUsedType</vh></v>
<v t="ekr.20230509083242.374"><vh>const char VarValue::NodeId</vh></v>
<v t="ekr.20230509083242.375"><vh>int VarValue::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.376"><vh>const char PointerValue::NodeId</vh></v>
<v t="ekr.20230509083242.377"><vh>int PointerValue::doReplaceUsedVariable</vh></v>
</v>
<v t="ekr.20230509083242.378"><vh>@@clean var.h</vh>
<v t="ekr.20230509083242.379"><vh>class Var</vh>
<v t="ekr.20230509083242.380"><vh>Var.extern al</vh></v>
<v t="ekr.20230509083242.381"><vh>Var.int replaceUsedValue</vh></v>
<v t="ekr.20230509083242.382"><vh>Var.using Node::replaceUsedValue</vh></v>
<v t="ekr.20230509083242.383"><vh>Var.int replaceUsedType</vh></v>
<v t="ekr.20230509083242.384"><vh>Var.using Node::replaceUsedType</vh></v>
<v t="ekr.20230509083242.385"><vh>Var.int replaceUsedVariable</vh></v>
</v>
<v t="ekr.20230509083242.386"><vh>class VarValue</vh></v>
<v t="ekr.20230509083242.387"><vh>class PointerValue</vh></v>
</v>
<v t="ekr.20230509083242.388"><vh>@path analyze</vh>
<v t="ekr.20230509083242.389"><vh>@@clean analysis.cpp</vh></v>
<v t="ekr.20230509083242.390"><vh>@@clean analysis.h</vh>
<v t="ekr.20230509083242.391"><vh>class Analysis</vh>
<v t="ekr.20230509083242.392"><vh>Analysis.template &lt;typename AnalysisType&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083242.393"><vh>@path dataflow</vh>
<v t="ekr.20230509083242.394"><vh>@@clean capture.cpp</vh>
<v t="ekr.20230509083242.395"><vh>bool reachable</vh></v>
<v t="ekr.20230509083242.396"><vh>bool happensBefore</vh></v>
<v t="ekr.20230509083242.397"><vh>struct RDManager</vh></v>
<v t="ekr.20230509083242.398"><vh>template &lt;class T1, class T2&gt;</vh></v>
<v t="ekr.20230509083242.399"><vh>}</vh></v>
<v t="ekr.20230509083242.400"><vh>void setReturnCaptured</vh></v>
<v t="ekr.20230509083242.401"><vh>void setExternCaptured</vh></v>
<v t="ekr.20230509083242.402"><vh>bool isDerived</vh></v>
<v t="ekr.20230509083242.403"><vh>bool isDerived</vh></v>
<v t="ekr.20230509083242.404"><vh>void setDerived</vh></v>
<v t="ekr.20230509083242.405"><vh>void setDerived</vh></v>
<v t="ekr.20230509083242.406"><vh>unsigned size</vh></v>
<v t="ekr.20230509083242.407"><vh>explicit DerivedSet</vh></v>
<v t="ekr.20230509083242.408"><vh>bool noCaptureByAnnotation</vh></v>
<v t="ekr.20230509083242.409"><vh>std::vector&lt;CaptureInfo&gt; makeAllCaptureInfo</vh></v>
<v t="ekr.20230509083242.410"><vh>void add</vh></v>
<v t="ekr.20230509083242.411"><vh>void defaultVisit</vh>
<v t="ekr.20230509083242.412"><vh>void visit</vh>
<v t="ekr.20230509083242.413"><vh>auto info</vh></v>
</v>
</v>
<v t="ekr.20230509083242.414"><vh>void visit</vh></v>
<v t="ekr.20230509083242.415"><vh>void visit</vh></v>
<v t="ekr.20230509083242.416"><vh>void visit</vh></v>
<v t="ekr.20230509083242.417"><vh>void visit</vh></v>
<v t="ekr.20230509083242.418"><vh>}</vh></v>
<v t="ekr.20230509083242.419"><vh>bool extractVars</vh></v>
<v t="ekr.20230509083242.420"><vh>struct CaptureTracker : public util::Operator</vh></v>
<v t="ekr.20230509083242.421"><vh>unsigned size</vh></v>
<v t="ekr.20230509083242.422"><vh>void forEachDSetOf</vh></v>
<v t="ekr.20230509083242.423"><vh>void forEachDSetOf</vh></v>
<v t="ekr.20230509083242.424"><vh>void forwardLink</vh>
<v t="ekr.20230509083242.425"><vh>bool toEscapes</vh></v>
</v>
<v t="ekr.20230509083242.426"><vh>void backwardLinkFunc</vh>
<v t="ekr.20230509083242.427"><vh>const std::vector</vh>
<v t="ekr.20230509083242.428"><vh>const std::vector</vh></v>
</v>
</v>
<v t="ekr.20230509083242.429"><vh>void link</vh></v>
<v t="ekr.20230509083242.430"><vh>void link</vh></v>
<v t="ekr.20230509083242.431"><vh>void handle</vh></v>
<v t="ekr.20230509083242.432"><vh>void handle</vh></v>
<v t="ekr.20230509083242.433"><vh>void handle</vh></v>
<v t="ekr.20230509083242.434"><vh>void handle</vh></v>
<v t="ekr.20230509083242.435"><vh>void handle</vh></v>
<v t="ekr.20230509083242.436"><vh>void handle</vh>
<v t="ekr.20230509083242.437"><vh>auto info</vh></v>
</v>
<v t="ekr.20230509083242.438"><vh>void handle</vh></v>
<v t="ekr.20230509083242.439"><vh>void handle</vh></v>
<v t="ekr.20230509083242.440"><vh>void handle</vh></v>
<v t="ekr.20230509083242.441"><vh>void handle</vh></v>
<v t="ekr.20230509083242.442"><vh>void handle</vh></v>
<v t="ekr.20230509083242.443"><vh>void handle</vh></v>
<v t="ekr.20230509083242.444"><vh>void handle</vh></v>
<v t="ekr.20230509083242.445"><vh>void runToCompletion</vh></v>
<v t="ekr.20230509083242.446"><vh>}</vh></v>
<v t="ekr.20230509083242.447"><vh>bool isPromise</vh></v>
<v t="ekr.20230509083242.448"><vh>seqassertn</vh></v>
<v t="ekr.20230509083242.449"><vh>void CaptureContext::set</vh></v>
</v>
<v t="ekr.20230509083242.450"><vh>@@clean capture.h</vh>
<v t="ekr.20230509083242.451"><vh>class CaptureAnalysis</vh></v>
</v>
<v t="ekr.20230509083242.452"><vh>@@clean cfg.cpp</vh>
<v t="ekr.20230509083242.453"><vh>unsigned idx</vh></v>
<v t="ekr.20230509083242.454"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.455"><vh>const Value</vh></v>
<v t="ekr.20230509083242.456"><vh>void CFBlock::reg</vh></v>
<v t="ekr.20230509083242.457"><vh>int SyntheticAssignInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.458"><vh>int SyntheticAssignInstr::doReplaceUsedVariable</vh></v>
<v t="ekr.20230509083242.459"><vh>const char SyntheticPhiInstr::NodeId</vh></v>
<v t="ekr.20230509083242.460"><vh>int SyntheticPhiInstr::doReplaceUsedValue</vh></v>
<v t="ekr.20230509083242.461"><vh>CFGraph::CFGraph</vh></v>
<v t="ekr.20230509083242.462"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.463"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.464"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.465"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.466"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.467"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.468"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.469"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.470"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.471"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.472"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.473"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.474"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.475"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.476"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.477"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.478"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.479"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.480"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.481"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.482"><vh>void CFVisitor::visit</vh></v>
<v t="ekr.20230509083242.483"><vh>void CFVisitor::defaultInsert</vh></v>
<v t="ekr.20230509083242.484"><vh>void CFVisitor::defaultJump</vh></v>
</v>
<v t="ekr.20230509083242.485"><vh>@@clean cfg.h</vh>
<v t="ekr.20230509083242.486"><vh>class CFBlock</vh>
<v t="ekr.20230509083242.487"><vh>CFBlock.void push_back</vh></v>
<v t="ekr.20230509083242.488"><vh>CFBlock./// Erases a value at the given position.</vh></v>
<v t="ekr.20230509083242.489"><vh>CFBlock.auto successors_insert</vh></v>
<v t="ekr.20230509083242.490"><vh>CFBlock.auto successors_erase</vh></v>
</v>
<v t="ekr.20230509083242.491"><vh>class SyntheticAssignInstr</vh></v>
<v t="ekr.20230509083242.492"><vh>class SyntheticPhiInstr</vh>
<v t="ekr.20230509083242.493"><vh>class Predecessor</vh></v>
</v>
<v t="ekr.20230509083242.494"><vh>class CFGraph</vh>
<v t="ekr.20230509083242.495"><vh>CFGraph.const CFBlock</vh></v>
<v t="ekr.20230509083242.496"><vh>CFGraph./// Creates and inserts a new block</vh></v>
<v t="ekr.20230509083242.497"><vh>CFGraph.void remapValue</vh></v>
<v t="ekr.20230509083242.498"><vh>CFGraph./// Gets a value by id.</vh></v>
<v t="ekr.20230509083242.499"><vh>CFGraph.void reg</vh></v>
</v>
<v t="ekr.20230509083242.500"><vh>/// Builds a control-flow graph from a given function.</vh></v>
<v t="ekr.20230509083242.501"><vh>class CFAnalysis</vh></v>
<v t="ekr.20230509083242.502"><vh>class CFVisitor</vh></v>
<v t="ekr.20230509083242.503"><vh>} // namespace dataflow</vh></v>
<v t="ekr.20230509083242.504"><vh>template &lt;&gt;</vh></v>
</v>
<v t="ekr.20230509083242.505"><vh>@@clean dominator.cpp</vh>
<v t="ekr.20230509083242.506"><vh>void DominatorInspector::analyze</vh></v>
<v t="ekr.20230509083242.507"><vh>bool DominatorInspector::isDominated</vh></v>
<v t="ekr.20230509083242.508"><vh>auto dDist</vh></v>
</v>
<v t="ekr.20230509083242.509"><vh>@@clean dominator.h</vh>
<v t="ekr.20230509083242.510"><vh>class DominatorInspector</vh></v>
<v t="ekr.20230509083242.511"><vh>/// Result of a dominator analysis.</vh></v>
<v t="ekr.20230509083242.512"><vh>class DominatorAnalysis</vh></v>
</v>
<v t="ekr.20230509083242.513"><vh>@@clean reaching.cpp</vh>
<v t="ekr.20230509083242.514"><vh>void push</vh></v>
<v t="ekr.20230509083242.515"><vh>T *pop</vh></v>
<v t="ekr.20230509083242.516"><vh>bool get</vh></v>
<v t="ekr.20230509083242.517"><vh>bool equals</vh></v>
<v t="ekr.20230509083242.518"><vh>void clear</vh></v>
<v t="ekr.20230509083242.519"><vh>void setAll</vh></v>
<v t="ekr.20230509083242.520"><vh>void overwrite</vh></v>
<v t="ekr.20230509083242.521"><vh>void update</vh></v>
<v t="ekr.20230509083242.522"><vh>void subtract</vh></v>
<v t="ekr.20230509083242.523"><vh>}</vh></v>
<v t="ekr.20230509083242.524"><vh>void RDInspector::analyze</vh></v>
<v t="ekr.20230509083242.525"><vh>std::unordered_set&lt;id_t&gt; RDInspector::getReachingDefinitions</vh></v>
<v t="ekr.20230509083242.526"><vh>const Value</vh></v>
</v>
<v t="ekr.20230509083242.527"><vh>@@clean reaching.h</vh>
<v t="ekr.20230509083242.528"><vh>class RDInspector</vh></v>
<v t="ekr.20230509083242.529"><vh>/// Result of a reaching definition analysis.</vh></v>
<v t="ekr.20230509083242.530"><vh>class RDAnalysis</vh></v>
</v>
</v>
<v t="ekr.20230509083242.531"><vh>@path module</vh>
<v t="ekr.20230509083242.532"><vh>@@clean global_vars.cpp</vh>
<v t="ekr.20230509083242.533"><vh>void handle</vh></v>
<v t="ekr.20230509083242.534"><vh>void handle</vh></v>
</v>
<v t="ekr.20230509083242.535"><vh>@@clean global_vars.h</vh>
<v t="ekr.20230509083242.536"><vh>class GlobalVarsAnalyses</vh></v>
</v>
<v t="ekr.20230509083242.537"><vh>@@clean side_effect.cpp</vh>
<v t="ekr.20230509083242.538"><vh>template &lt;typename T0, typename T1, typename... Ts&gt;</vh></v>
<v t="ekr.20230509083242.539"><vh>struct VarUseAnalyzer : public util::Operator</vh></v>
<v t="ekr.20230509083242.540"><vh>void preHook</vh></v>
<v t="ekr.20230509083242.541"><vh>void handle</vh></v>
<v t="ekr.20230509083242.542"><vh>static Status</vh></v>
<v t="ekr.20230509083242.543"><vh>VarUseAnalyzer &amp;vua</vh></v>
<v t="ekr.20230509083242.544"><vh>bool globalAssignmentHasSideEffects</vh></v>
<v t="ekr.20230509083242.545"><vh>template &lt;typename T&gt; void set</vh></v>
<v t="ekr.20230509083242.546"><vh>void handleVarAssign</vh></v>
<v t="ekr.20230509083242.547"><vh>void visit</vh></v>
<v t="ekr.20230509083242.548"><vh>void visit</vh></v>
<v t="ekr.20230509083242.549"><vh>void visit</vh></v>
<v t="ekr.20230509083242.550"><vh>void visit</vh></v>
<v t="ekr.20230509083242.551"><vh>void visit</vh></v>
<v t="ekr.20230509083242.552"><vh>void visit</vh></v>
<v t="ekr.20230509083242.553"><vh>void visit</vh></v>
<v t="ekr.20230509083242.554"><vh>void visit</vh></v>
<v t="ekr.20230509083242.555"><vh>void visit</vh></v>
<v t="ekr.20230509083242.556"><vh>void visit</vh></v>
<v t="ekr.20230509083242.557"><vh>void visit</vh></v>
<v t="ekr.20230509083242.558"><vh>void visit</vh></v>
<v t="ekr.20230509083242.559"><vh>void visit</vh></v>
<v t="ekr.20230509083242.560"><vh>void visit</vh></v>
<v t="ekr.20230509083242.561"><vh>void visit</vh></v>
<v t="ekr.20230509083242.562"><vh>void visit</vh></v>
<v t="ekr.20230509083242.563"><vh>void visit</vh></v>
<v t="ekr.20230509083242.564"><vh>void visit</vh></v>
<v t="ekr.20230509083242.565"><vh>void visit</vh></v>
<v t="ekr.20230509083242.566"><vh>void visit</vh></v>
<v t="ekr.20230509083242.567"><vh>void visit</vh></v>
<v t="ekr.20230509083242.568"><vh>void visit</vh></v>
<v t="ekr.20230509083242.569"><vh>void visit</vh></v>
<v t="ekr.20230509083242.570"><vh>void visit</vh></v>
<v t="ekr.20230509083242.571"><vh>void visit</vh></v>
<v t="ekr.20230509083242.572"><vh>void visit</vh></v>
<v t="ekr.20230509083242.573"><vh>}</vh></v>
<v t="ekr.20230509083242.574"><vh>bool SideEffectResult::hasSideEffect</vh></v>
</v>
<v t="ekr.20230509083242.575"><vh>@@clean side_effect.h</vh>
<v t="ekr.20230509083242.576"><vh>class SideEffectAnalysis</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.577"><vh>@path dsl</vh>
<v t="ekr.20230509083242.578"><vh>@@clean codegen.h</vh></v>
<v t="ekr.20230509083242.579"><vh>@@clean nodes.cpp</vh></v>
<v t="ekr.20230509083242.580"><vh>@@clean nodes.h</vh>
<v t="ekr.20230509083242.581"><vh>class CustomType</vh></v>
<v t="ekr.20230509083242.582"><vh>} // namespace types</vh></v>
<v t="ekr.20230509083242.583"><vh>class CustomConst</vh></v>
<v t="ekr.20230509083242.584"><vh>class CustomFlow</vh></v>
<v t="ekr.20230509083242.585"><vh>class CustomInstr</vh></v>
</v>
</v>
<v t="ekr.20230509083242.586"><vh>@path llvm</vh>
<v t="ekr.20230509083242.587"><vh>@@clean gpu.cpp</vh>
<v t="ekr.20230509083242.588"><vh>const std::string</vh>
<v t="ekr.20230509083242.589"><vh>class GVExtractor</vh>
<v t="ekr.20230509083242.590"><vh>GVExtractor.bool keepConstInit</vh>
<v t="ekr.20230509083242.591"><vh>GVExtractor.void makeVisible</vh></v>
</v>
<v t="ekr.20230509083242.592"><vh>GVExtractor.llvm::PreservedAnalyses run</vh></v>
<v t="ekr.20230509083242.593"><vh>GVExtractor.bool del</vh></v>
</v>
</v>
<v t="ekr.20230509083242.594"><vh>std::string cleanUpName</vh></v>
<v t="ekr.20230509083242.595"><vh>auto valid</vh></v>
<v t="ekr.20230509083242.596"><vh>bool first</vh></v>
<v t="ekr.20230509083242.597"><vh>void linkLibdevice</vh></v>
<v t="ekr.20230509083242.598"><vh>llvm::Function *copyPrototype</vh></v>
<v t="ekr.20230509083242.599"><vh>void remapFunctions</vh>
<v t="ekr.20230509083242.600"><vh>const std::vector</vh></v>
<v t="ekr.20230509083242.601"><vh>const std::vector</vh>
<v t="ekr.20230509083242.602"><vh>auto F</vh></v>
<v t="ekr.20230509083242.603"><vh>auto F</vh></v>
<v t="ekr.20230509083242.604"><vh>auto F</vh></v>
</v>
</v>
<v t="ekr.20230509083242.605"><vh>void exploreGV</vh></v>
<v t="ekr.20230509083242.606"><vh>std::vector&lt;llvm::GlobalValue *&gt;</vh></v>
<v t="ekr.20230509083242.607"><vh>void moduleToPTX</vh>
<v t="ekr.20230509083242.608"><vh>const std::string</vh>
<v t="ekr.20230509083242.609"><vh>const std::string</vh>
<v t="ekr.20230509083242.610"><vh>auto prune</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.611"><vh>const _cast</vh>
<v t="ekr.20230509083242.612"><vh>void addInitCall</vh></v>
</v>
<v t="ekr.20230509083242.613"><vh>void cleanUpIntrinsics</vh></v>
<v t="ekr.20230509083242.614"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.615"><vh>void applyGPUTransformations</vh></v>
</v>
<v t="ekr.20230509083242.616"><vh>@@clean gpu.h</vh></v>
<v t="ekr.20230509083242.617"><vh>@@clean llvisitor.cpp</vh>
<v t="ekr.20230509083242.618"><vh>void LLVMVisitor::registerGlobal</vh>
<v t="ekr.20230509083242.619"><vh>auto linkage</vh>
<v t="ekr.20230509083242.620"><vh>extern al</vh></v>
</v>
</v>
<v t="ekr.20230509083242.621"><vh>llvm::Value *LLVMVisitor::getVar</vh></v>
<v t="ekr.20230509083242.622"><vh>const SrcInfo</vh></v>
<v t="ekr.20230509083242.623"><vh>void LLVMVisitor::clearLLVMData</vh></v>
<v t="ekr.20230509083242.624"><vh>std::pair&lt;std::unique_ptr&lt;llvm::Module&gt;, std::unique_ptr&lt;llvm::LLVMContext&gt;&gt;</vh></v>
<v t="ekr.20230509083242.625"><vh>void LLVMVisitor::setDebugInfoForNode</vh></v>
<v t="ekr.20230509083242.626"><vh>void LLVMVisitor::process</vh></v>
<v t="ekr.20230509083242.627"><vh>void LLVMVisitor::dump</vh></v>
<v t="ekr.20230509083242.628"><vh>void LLVMVisitor::runLLVMPipeline</vh></v>
<v t="ekr.20230509083242.629"><vh>void LLVMVisitor::writeToObjectFile</vh></v>
<v t="ekr.20230509083242.630"><vh>const _cast</vh>
<v t="ekr.20230509083242.631"><vh>void LLVMVisitor::writeToBitcodeFile</vh></v>
</v>
<v t="ekr.20230509083242.632"><vh>void LLVMVisitor::writeToLLFile</vh></v>
<v t="ekr.20230509083242.633"><vh>namespace</vh></v>
<v t="ekr.20230509083242.634"><vh>void executeCommand</vh></v>
<v t="ekr.20230509083242.635"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.636"><vh>void LLVMVisitor::setupGlobalCtorForSharedLibrary</vh></v>
<v t="ekr.20230509083242.637"><vh>void LLVMVisitor::writeToExecutable</vh>
<v t="ekr.20230509083242.638"><vh>const std::string</vh>
<v t="ekr.20230509083242.639"><vh>const std::vector</vh>
<v t="ekr.20230509083242.640"><vh>const std::string</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.641"><vh>namespace</vh></v>
<v t="ekr.20230509083242.642"><vh>void LLVMVisitor::writeToPythonExtension</vh>
<v t="ekr.20230509083242.643"><vh>const std::string</vh>
<v t="ekr.20230509083242.644"><vh>auto free</vh>
<v t="ekr.20230509083242.645"><vh>auto pyFuncWrap</vh></v>
</v>
<v t="ekr.20230509083242.646"><vh>auto pyFunc</vh></v>
<v t="ekr.20230509083242.647"><vh>auto pyString</vh></v>
<v t="ekr.20230509083242.648"><vh>auto pyFunctions</vh></v>
<v t="ekr.20230509083242.649"><vh>auto pyMembers</vh></v>
<v t="ekr.20230509083242.650"><vh>auto pyGetSet</vh></v>
<v t="ekr.20230509083242.651"><vh>// Construct PyModuleDef array</vh></v>
<v t="ekr.20230509083242.652"><vh>bool needMappingSlots</vh></v>
<v t="ekr.20230509083242.653"><vh>if</vh></v>
<v t="ekr.20230509083242.654"><vh>auto codonSize</vh></v>
</v>
</v>
<v t="ekr.20230509083242.655"><vh>void LLVMVisitor::compile</vh>
<v t="ekr.20230509083242.656"><vh>const std::vector</vh>
<v t="ekr.20230509083242.657"><vh>const std::string</vh></v>
</v>
</v>
<v t="ekr.20230509083242.658"><vh>void LLVMVisitor::run</vh>
<v t="ekr.20230509083242.659"><vh>const std::vector</vh>
<v t="ekr.20230509083242.660"><vh>auto epc</vh></v>
</v>
</v>
<v t="ekr.20230509083242.661"><vh>llvm::FunctionCallee LLVMVisitor::makeAllocFunc</vh></v>
<v t="ekr.20230509083242.662"><vh>auto f</vh></v>
<v t="ekr.20230509083242.663"><vh>llvm::FunctionCallee LLVMVisitor::makeExcAllocFunc</vh></v>
<v t="ekr.20230509083242.664"><vh>auto f</vh></v>
<v t="ekr.20230509083242.665"><vh>llvm::FunctionCallee LLVMVisitor::makeTerminateFunc</vh></v>
<v t="ekr.20230509083242.666"><vh>int typeIdxLookup</vh></v>
<v t="ekr.20230509083242.667"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.668"><vh>int LLVMVisitor::getTypeIdx</vh></v>
<v t="ekr.20230509083242.669"><vh>llvm::Value *LLVMVisitor::call</vh></v>
<v t="ekr.20230509083242.670"><vh>void LLVMVisitor::enterLoop</vh></v>
<v t="ekr.20230509083242.671"><vh>void LLVMVisitor::exitLoop</vh></v>
<v t="ekr.20230509083242.672"><vh>void LLVMVisitor::enterTryCatch</vh></v>
<v t="ekr.20230509083242.673"><vh>void LLVMVisitor::exitTryCatch</vh></v>
<v t="ekr.20230509083242.674"><vh>void LLVMVisitor::enterCatch</vh></v>
<v t="ekr.20230509083242.675"><vh>void LLVMVisitor::exitCatch</vh></v>
<v t="ekr.20230509083242.676"><vh>LLVMVisitor::TryCatchData *LLVMVisitor::getInnermostTryCatch</vh></v>
<v t="ekr.20230509083242.677"><vh>void LLVMVisitor::visit</vh>
<v t="ekr.20230509083242.678"><vh>int flags</vh></v>
</v>
<v t="ekr.20230509083242.679"><vh>llvm::DISubprogram *LLVMVisitor::getDISubprogramForFunc</vh></v>
<v t="ekr.20230509083242.680"><vh>void LLVMVisitor::makeYield</vh></v>
<v t="ekr.20230509083242.681"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.682"><vh>namespace</vh></v>
<v t="ekr.20230509083242.683"><vh>template &lt;typename ParentType&gt;</vh></v>
<v t="ekr.20230509083242.684"><vh>template &lt;typename ParentType, typename... ArgTypes, std::size_t... Index&gt;</vh>
<v t="ekr.20230509083242.685"><vh>int ernalFuncMatches</vh></v>
</v>
<v t="ekr.20230509083242.686"><vh>template &lt;typename ParentType, typename... ArgTypes&gt;</vh></v>
<v t="ekr.20230509083242.687"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.688"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.689"><vh>std::string LLVMVisitor::buildLLVMCodeString</vh></v>
<v t="ekr.20230509083242.690"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.691"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.692"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.693"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.694"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.695"><vh>/*</vh></v>
<v t="ekr.20230509083242.696"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.697"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.698"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.699"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.700"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.701"><vh>/*</vh></v>
<v t="ekr.20230509083242.702"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.703"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.704"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.705"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.706"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.707"><vh>namespace</vh></v>
<v t="ekr.20230509083242.708"><vh>bool anyMatch</vh></v>
<v t="ekr.20230509083242.709"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.710"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.711"><vh>void LLVMVisitor::callStage</vh></v>
<v t="ekr.20230509083242.712"><vh>void LLVMVisitor::codegenPipeline</vh>
<v t="ekr.20230509083242.713"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083242.714"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.715"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.716"><vh>/*</vh></v>
<v t="ekr.20230509083242.717"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.718"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.719"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.720"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.721"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.722"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.723"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.724"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.725"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.726"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.727"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.728"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.729"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.730"><vh>void LLVMVisitor::visit</vh></v>
<v t="ekr.20230509083242.731"><vh>void LLVMVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083242.732"><vh>@@clean llvisitor.h</vh>
<v t="ekr.20230509083242.733"><vh>class LLVMVisitor</vh>
<v t="ekr.20230509083242.734"><vh>LLVMVisitor.void reset</vh></v>
<v t="ekr.20230509083242.735"><vh>LLVMVisitor.}</vh></v>
<v t="ekr.20230509083242.736"><vh>LLVMVisitor.void reset</vh></v>
<v t="ekr.20230509083242.737"><vh>LLVMVisitor.}</vh></v>
<v t="ekr.20230509083242.738"><vh>LLVMVisitor.void insertFunc</vh></v>
<v t="ekr.20230509083242.739"><vh>LLVMVisitor.llvm::Value *getDummyVoidValue</vh></v>
<v t="ekr.20230509083242.740"><vh>LLVMVisitor.static std::string</vh></v>
<v t="ekr.20230509083242.741"><vh>LLVMVisitor.const SrcInfo</vh></v>
<v t="ekr.20230509083242.742"><vh>LLVMVisitor.const SrcInfo</vh></v>
</v>
</v>
<v t="ekr.20230509083242.743"><vh>@@clean llvm.h</vh></v>
<v t="ekr.20230509083242.744"><vh>@@clean optimize.cpp</vh>
<v t="ekr.20230509083242.745"><vh>bool pic</vh></v>
<v t="ekr.20230509083242.746"><vh>std::unique_ptr&lt;llvm::TargetMachine&gt;</vh></v>
<v t="ekr.20230509083242.747"><vh>const llvm::TargetOptions</vh></v>
<v t="ekr.20230509083242.748"><vh>return</vh></v>
<v t="ekr.20230509083242.749"><vh>void applyDebugTransformations</vh></v>
<v t="ekr.20230509083242.750"><vh>/// Lowers allocations of known, small size to alloca when possible.</vh></v>
<v t="ekr.20230509083242.751"><vh>const std::string</vh>
<v t="ekr.20230509083242.752"><vh>const llvm::Function</vh></v>
</v>
<v t="ekr.20230509083242.753"><vh>bool isAlloc</vh></v>
<v t="ekr.20230509083242.754"><vh>bool isRealloc</vh></v>
<v t="ekr.20230509083242.755"><vh>bool isFree</vh></v>
<v t="ekr.20230509083242.756"><vh>bool getFixedArg</vh></v>
<v t="ekr.20230509083242.757"><vh>bool isNeverEqualToUnescapedAlloc</vh></v>
<v t="ekr.20230509083242.758"><vh>bool isAllocSiteRemovable</vh></v>
<v t="ekr.20230509083242.759"><vh>bool isAllocSiteDemotable</vh></v>
<v t="ekr.20230509083242.760"><vh>void getErasesAndReplacementsForAlloc</vh></v>
<v t="ekr.20230509083242.761"><vh>llvm::PreservedAnalyses run</vh></v>
<v t="ekr.20230509083242.762"><vh>static llvm::Value</vh></v>
<v t="ekr.20230509083242.763"><vh>llvm::PreservedAnalyses run</vh></v>
<v t="ekr.20230509083242.764"><vh>void runLLVMOptimizationPasses</vh></v>
<v t="ekr.20230509083242.765"><vh>void verify</vh></v>
<v t="ekr.20230509083242.766"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.767"><vh>void optimize</vh></v>
</v>
<v t="ekr.20230509083242.768"><vh>@@clean optimize.h</vh></v>
</v>
<v t="ekr.20230509083242.769"><vh>@path transform</vh>
<v t="ekr.20230509083242.770"><vh>@@clean manager.cpp</vh>
<v t="ekr.20230509083242.771"><vh>const std::string</vh></v>
<v t="ekr.20230509083242.772"><vh>std::string PassManager::registerAnalysis</vh></v>
<v t="ekr.20230509083242.773"><vh>void PassManager::run</vh></v>
<v t="ekr.20230509083242.774"><vh>void PassManager::runPass</vh></v>
<v t="ekr.20230509083242.775"><vh>void PassManager::runAnalysis</vh></v>
<v t="ekr.20230509083242.776"><vh>void PassManager::invalidate</vh></v>
<v t="ekr.20230509083242.777"><vh>void PassManager::registerStandardPasses</vh>
<v t="ekr.20230509083242.778"><vh>register Pass</vh>
<v t="ekr.20230509083242.779"><vh>register Pass</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.780"><vh>@@clean manager.h</vh>
<v t="ekr.20230509083242.781"><vh>class PassManager</vh>
<v t="ekr.20230509083242.782"><vh>class KeyManager</vh></v>
<v t="ekr.20230509083242.783"><vh>/// Container for pass metadata.</vh></v>
<v t="ekr.20230509083242.784"><vh>bool pyNumerics</vh></v>
<v t="ekr.20230509083242.785"><vh>explicit PassManager</vh></v>
<v t="ekr.20230509083242.786"><vh>bool pyNumerics</vh>
<v t="ekr.20230509083242.787"><vh>bool hasPass</vh></v>
</v>
<v t="ekr.20230509083242.788"><vh>bool hasAnalysis</vh></v>
<v t="ekr.20230509083242.789"><vh>/// Registers a pass and appends it to the execution order.</vh></v>
<v t="ekr.20230509083242.790"><vh>bool isDisabled</vh></v>
</v>
</v>
<v t="ekr.20230509083242.791"><vh>@@clean pass.cpp</vh>
<v t="ekr.20230509083242.792"><vh>void PassGroup::run</vh></v>
<v t="ekr.20230509083242.793"><vh>void PassGroup::setManager</vh></v>
</v>
<v t="ekr.20230509083242.794"><vh>@@clean pass.h</vh>
<v t="ekr.20230509083242.795"><vh>class Pass</vh>
<v t="ekr.20230509083242.796"><vh>Pass.template &lt;typename AnalysisType&gt;</vh></v>
</v>
<v t="ekr.20230509083242.797"><vh>class PassGroup</vh></v>
<v t="ekr.20230509083242.798"><vh>class OperatorPass</vh>
<v t="ekr.20230509083242.799"><vh>OperatorPass.void run</vh></v>
</v>
</v>
<v t="ekr.20230509083242.800"><vh>@@clean rewrite.h</vh>
<v t="ekr.20230509083242.801"><vh>class RewriteRule</vh></v>
<v t="ekr.20230509083242.802"><vh>class Rewriter</vh>
<v t="ekr.20230509083242.803"><vh>Rewriter.register Rule</vh></v>
<v t="ekr.20230509083242.804"><vh>Rewriter.void rewrite</vh></v>
</v>
</v>
<v t="ekr.20230509083242.805"><vh>@path cleanup</vh>
<v t="ekr.20230509083242.806"><vh>@@clean canonical.cpp</vh>
<v t="ekr.20230509083242.807"><vh>void preHook</vh></v>
<v t="ekr.20230509083242.808"><vh>Rank getRank</vh></v>
<v t="ekr.20230509083242.809"><vh>bool isCommutativeOp</vh></v>
<v t="ekr.20230509083242.810"><vh>bool isAssociativeOp</vh></v>
<v t="ekr.20230509083242.811"><vh>bool isDistributiveOp</vh></v>
<v t="ekr.20230509083242.812"><vh>bool isInequalityOp</vh></v>
<v t="ekr.20230509083242.813"><vh>// c + b + a --&gt; a + b + c</vh></v>
<v t="ekr.20230509083242.814"><vh>void extractAssociativeOpChain</vh></v>
<v t="ekr.20230509083242.815"><vh>void orderOperands</vh></v>
<v t="ekr.20230509083242.816"><vh>void visit</vh></v>
<v t="ekr.20230509083242.817"><vh>}</vh></v>
<v t="ekr.20230509083242.818"><vh>void visit</vh></v>
<v t="ekr.20230509083242.819"><vh>}</vh></v>
<v t="ekr.20230509083242.820"><vh>bool varMatch</vh></v>
<v t="ekr.20230509083242.821"><vh>static Func</vh></v>
<v t="ekr.20230509083242.822"><vh>static Value</vh></v>
<v t="ekr.20230509083242.823"><vh>void visit</vh></v>
<v t="ekr.20230509083242.824"><vh>}</vh></v>
<v t="ekr.20230509083242.825"><vh>void visit</vh></v>
<v t="ekr.20230509083242.826"><vh>}</vh></v>
<v t="ekr.20230509083242.827"><vh>void CanonicalizationPass::run</vh></v>
<v t="ekr.20230509083242.828"><vh>void CanonicalizationPass::handle</vh></v>
<v t="ekr.20230509083242.829"><vh>void CanonicalizationPass::handle</vh></v>
<v t="ekr.20230509083242.830"><vh>void CanonicalizationPass::registerStandardRules</vh></v>
</v>
<v t="ekr.20230509083242.831"><vh>@@clean canonical.h</vh>
<v t="ekr.20230509083242.832"><vh>class CanonicalizationPass</vh></v>
</v>
<v t="ekr.20230509083242.833"><vh>@@clean dead_code.cpp</vh>
<v t="ekr.20230509083242.834"><vh>void DeadCodeCleanupPass::run</vh></v>
<v t="ekr.20230509083242.835"><vh>void DeadCodeCleanupPass::handle</vh></v>
<v t="ekr.20230509083242.836"><vh>void DeadCodeCleanupPass::handle</vh></v>
<v t="ekr.20230509083242.837"><vh>void DeadCodeCleanupPass::handle</vh></v>
<v t="ekr.20230509083242.838"><vh>void DeadCodeCleanupPass::handle</vh></v>
<v t="ekr.20230509083242.839"><vh>void DeadCodeCleanupPass::handle</vh></v>
<v t="ekr.20230509083242.840"><vh>void DeadCodeCleanupPass::doReplacement</vh></v>
</v>
<v t="ekr.20230509083242.841"><vh>@@clean dead_code.h</vh>
<v t="ekr.20230509083242.842"><vh>class DeadCodeCleanupPass</vh></v>
</v>
<v t="ekr.20230509083242.843"><vh>@@clean global_demote.cpp</vh>
<v t="ekr.20230509083242.844"><vh>void preHook</vh></v>
<v t="ekr.20230509083242.845"><vh>}</vh></v>
<v t="ekr.20230509083242.846"><vh>void GlobalDemotionPass::run</vh></v>
</v>
<v t="ekr.20230509083242.847"><vh>@@clean global_demote.h</vh>
<v t="ekr.20230509083242.848"><vh>class GlobalDemotionPass</vh></v>
</v>
<v t="ekr.20230509083242.849"><vh>@@clean replacer.cpp</vh>
<v t="ekr.20230509083242.850"><vh>void ReplaceCleanupPass::run</vh></v>
</v>
<v t="ekr.20230509083242.851"><vh>@@clean replacer.h</vh>
<v t="ekr.20230509083242.852"><vh>class ReplaceCleanupPass</vh></v>
</v>
</v>
<v t="ekr.20230509083242.853"><vh>@path folding</vh>
<v t="ekr.20230509083242.854"><vh>@@clean const_fold.cpp</vh>
<v t="ekr.20230509083242.855"><vh>auto pyDivmod</vh></v>
<v t="ekr.20230509083242.856"><vh>template &lt;typename Func, typename Out&gt; class IntFloatBinaryRule : public RewriteRule</vh></v>
<v t="ekr.20230509083242.857"><vh>bool excludeRHSZero</vh>
<v t="ekr.20230509083242.858"><vh>void visit</vh></v>
</v>
<v t="ekr.20230509083242.859"><vh>}</vh></v>
<v t="ekr.20230509083242.860"><vh>template &lt;typename ConstantType, typename Func, typename OutputType</vh>
<v t="ekr.20230509083242.861"><vh>class DoubleConstantBinaryRuleExcludeRHSZero</vh>
<v t="ekr.20230509083242.862"><vh>DoubleConstantBinaryRuleExcludeRHSZero.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083242.863"><vh>auto id_val</vh></v>
<v t="ekr.20230509083242.864"><vh>int 64_t</vh></v>
<v t="ekr.20230509083242.865"><vh>template &lt;typename From, typename To&gt; To convert</vh></v>
<v t="ekr.20230509083242.866"><vh>int NoOp</vh></v>
<v t="ekr.20230509083242.867"><vh>int DoubleApplyNoOp</vh></v>
<v t="ekr.20230509083242.868"><vh>template &lt;typename Func&gt; auto intToIntBinary</vh></v>
<v t="ekr.20230509083242.869"><vh>template &lt;typename Func&gt;</vh></v>
<v t="ekr.20230509083242.870"><vh>template &lt;typename Func&gt; auto intToBoolBinary</vh></v>
<v t="ekr.20230509083242.871"><vh>template &lt;typename Func&gt;</vh></v>
<v t="ekr.20230509083242.872"><vh>template &lt;typename Func&gt; auto floatToBoolBinary</vh></v>
<v t="ekr.20230509083242.873"><vh>template &lt;typename Func&gt;</vh></v>
<v t="ekr.20230509083242.874"><vh>template &lt;typename Func&gt;</vh></v>
<v t="ekr.20230509083242.875"><vh>template &lt;typename Func&gt; auto intToIntUnary</vh></v>
<v t="ekr.20230509083242.876"><vh>auto identityConvert</vh></v>
<v t="ekr.20230509083242.877"><vh>template &lt;typename From, typename To&gt;</vh></v>
<v t="ekr.20230509083242.878"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.879"><vh>void FoldingPass::run</vh></v>
<v t="ekr.20230509083242.880"><vh>void FoldingPass::handle</vh></v>
<v t="ekr.20230509083242.881"><vh>void FoldingPass::registerStandardRules</vh>
<v t="ekr.20230509083242.882"><vh>register Rule</vh>
<v t="ekr.20230509083242.883"><vh>register Rule</vh></v>
</v>
<v t="ekr.20230509083242.884"><vh>registerRule</vh></v>
<v t="ekr.20230509083242.885"><vh>register Rule</vh>
<v t="ekr.20230509083242.886"><vh>register Rule</vh></v>
</v>
<v t="ekr.20230509083242.887"><vh>// binary, double constant, int-&gt;bool</vh></v>
<v t="ekr.20230509083242.888"><vh>register Rule</vh>
<v t="ekr.20230509083242.889"><vh>register Rule</vh>
<v t="ekr.20230509083242.890"><vh>register Rule</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509083242.891"><vh>@@clean const_fold.h</vh>
<v t="ekr.20230509083242.892"><vh>class FoldingPass</vh></v>
</v>
<v t="ekr.20230509083242.893"><vh>@@clean const_prop.cpp</vh>
<v t="ekr.20230509083242.894"><vh>bool okConst</vh></v>
<v t="ekr.20230509083242.895"><vh>} // namespace</vh></v>
<v t="ekr.20230509083242.896"><vh>void ConstPropPass::handle</vh></v>
</v>
<v t="ekr.20230509083242.897"><vh>@@clean const_prop.h</vh>
<v t="ekr.20230509083242.898"><vh>class ConstPropPass</vh></v>
</v>
<v t="ekr.20230509083242.899"><vh>@@clean folding.cpp</vh>
<v t="ekr.20230509083242.900"><vh>const std::string</vh>
<v t="ekr.20230509083242.901"><vh>const std::string</vh>
<v t="ekr.20230509083242.902"><vh>bool runGlobalDemotion</vh></v>
</v>
</v>
<v t="ekr.20230509083242.903"><vh>bool FoldingPassGroup::shouldRepeat</vh></v>
</v>
<v t="ekr.20230509083242.904"><vh>@@clean folding.h</vh>
<v t="ekr.20230509083242.905"><vh>class FoldingPassGroup</vh></v>
</v>
<v t="ekr.20230509083242.906"><vh>@@clean rule.h</vh>
<v t="ekr.20230509083242.907"><vh>template &lt;typename ConstantType&gt;</vh>
<v t="ekr.20230509083242.908"><vh>class SingleConstantCommutativeRule</vh>
<v t="ekr.20230509083242.909"><vh>SingleConstantCommutativeRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083242.910"><vh>template &lt;typename ConstantType, typename Func, typename OutputType</vh>
<v t="ekr.20230509083242.911"><vh>class DoubleConstantBinaryRule</vh>
<v t="ekr.20230509083242.912"><vh>DoubleConstantBinaryRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083242.913"><vh>template &lt;typename ConstantType, typename Func&gt;</vh>
<v t="ekr.20230509083242.914"><vh>class SingleConstantUnaryRule</vh>
<v t="ekr.20230509083242.915"><vh>SingleConstantUnaryRule.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083242.916"><vh>/// Unary rule that requires no constant.</vh></v>
<v t="ekr.20230509083242.917"><vh>void visit</vh></v>
<v t="ekr.20230509083242.918"><vh>}</vh></v>
<v t="ekr.20230509083242.919"><vh>class NoOpRule</vh>
<v t="ekr.20230509083242.920"><vh>NoOpRule.void visit</vh></v>
</v>
<v t="ekr.20230509083242.921"><vh>class DoubleApplicationNoOpRule</vh>
<v t="ekr.20230509083242.922"><vh>DoubleApplicationNoOpRule.void visit</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083242.923"><vh>@path lowering</vh>
<v t="ekr.20230509083242.924"><vh>@@clean imperative.cpp</vh>
<v t="ekr.20230509083242.925"><vh>void ImperativeForFlowLowering::handle</vh></v>
</v>
<v t="ekr.20230509083242.926"><vh>@@clean imperative.h</vh>
<v t="ekr.20230509083242.927"><vh>class ImperativeForFlowLowering</vh></v>
</v>
<v t="ekr.20230509083242.928"><vh>@@clean pipeline.cpp</vh>
<v t="ekr.20230509083242.929"><vh>const std::vector</vh>
<v t="ekr.20230509083242.930"><vh>unsigned idx</vh></v>
</v>
<v t="ekr.20230509083242.931"><vh>Value *convertPipelineToForLoops</vh></v>
<v t="ekr.20230509083242.932"><vh>void PipelineLowering::handle</vh></v>
</v>
<v t="ekr.20230509083242.933"><vh>@@clean pipeline.h</vh>
<v t="ekr.20230509083242.934"><vh>class PipelineLowering</vh></v>
</v>
</v>
<v t="ekr.20230509083242.935"><vh>@path parallel</vh>
<v t="ekr.20230509083242.936"><vh>@@clean openmp.cpp</vh>
<v t="ekr.20230509083242.937"><vh>void warn</vh></v>
<v t="ekr.20230509083242.938"><vh>struct OMPTypes</vh></v>
<v t="ekr.20230509083242.939"><vh>bool isShared</vh></v>
<v t="ekr.20230509083242.940"><vh>bool isSharedDeref</vh></v>
<v t="ekr.20230509083242.941"><vh>void extractAssociativeOpChain</vh></v>
<v t="ekr.20230509083242.942"><vh>Reduction getReductionFromCall</vh></v>
<v t="ekr.20230509083242.943"><vh>const std::vector</vh></v>
<v t="ekr.20230509083242.944"><vh>for</vh></v>
<v t="ekr.20230509083242.945"><vh>void handle</vh></v>
<v t="ekr.20230509083242.946"><vh>}</vh></v>
<v t="ekr.20230509083242.947"><vh>unsigned numReductions</vh></v>
<v t="ekr.20230509083242.948"><vh>Value *getReductionTuple</vh></v>
<v t="ekr.20230509083242.949"><vh>void handle</vh></v>
<v t="ekr.20230509083242.950"><vh>}</vh></v>
<v t="ekr.20230509083242.951"><vh>void handle</vh></v>
<v t="ekr.20230509083242.952"><vh>}</vh></v>
<v t="ekr.20230509083242.953"><vh>void setupReductionRemap</vh></v>
<v t="ekr.20230509083242.954"><vh>TaskLoopReductionVarReplacer</vh></v>
<v t="ekr.20230509083242.955"><vh>void preHook</vh></v>
<v t="ekr.20230509083242.956"><vh>void finalize</vh></v>
<v t="ekr.20230509083242.957"><vh>}</vh></v>
<v t="ekr.20230509083242.958"><vh>void handle</vh>
<v t="ekr.20230509083242.959"><vh>bool hasReductions</vh></v>
</v>
<v t="ekr.20230509083242.960"><vh>}</vh></v>
<v t="ekr.20230509083242.961"><vh>void setupSharedInfo</vh></v>
<v t="ekr.20230509083242.962"><vh>TaskLoopRoutineStubReplacer</vh></v>
<v t="ekr.20230509083242.963"><vh>void handle</vh></v>
<v t="ekr.20230509083242.964"><vh>void handle</vh></v>
<v t="ekr.20230509083242.965"><vh>}</vh></v>
<v t="ekr.20230509083242.966"><vh>void handle</vh></v>
<v t="ekr.20230509083242.967"><vh>}</vh></v>
<v t="ekr.20230509083242.968"><vh>int 64_t</vh>
<v t="ekr.20230509083242.969"><vh>void handle</vh></v>
</v>
<v t="ekr.20230509083242.970"><vh>}</vh></v>
<v t="ekr.20230509083242.971"><vh>template &lt;typename T&gt;</vh></v>
<v t="ekr.20230509083242.972"><vh>struct ForkCallData</vh></v>
<v t="ekr.20230509083242.973"><vh>const std::vector</vh></v>
<v t="ekr.20230509083242.974"><vh>struct CollapseResult</vh></v>
<v t="ekr.20230509083242.975"><vh>auto fail</vh></v>
<v t="ekr.20230509083242.976"><vh>auto *M</vh></v>
<v t="ekr.20230509083242.977"><vh>void OpenMPPass::handle</vh></v>
<v t="ekr.20230509083242.978"><vh>void OpenMPPass::handle</vh></v>
</v>
<v t="ekr.20230509083242.979"><vh>@@clean openmp.h</vh>
<v t="ekr.20230509083242.980"><vh>class OpenMPPass</vh></v>
</v>
<v t="ekr.20230509083242.981"><vh>@@clean schedule.cpp</vh>
<v t="ekr.20230509083242.982"><vh>int getScheduleCode</vh>
<v t="ekr.20230509083242.983"><vh>bool ordered</vh></v>
</v>
<v t="ekr.20230509083242.984"><vh>Value *nullIfNeg</vh></v>
<v t="ekr.20230509083242.985"><vh>int 64_t</vh></v>
<v t="ekr.20230509083242.986"><vh>OMPSched::OMPSched</vh></v>
<v t="ekr.20230509083242.987"><vh>bool ordered</vh></v>
<v t="ekr.20230509083242.988"><vh>int OMPSched::replaceUsedValue</vh></v>
</v>
<v t="ekr.20230509083242.989"><vh>@@clean schedule.h</vh></v>
</v>
<v t="ekr.20230509083242.990"><vh>@path pythonic</vh>
<v t="ekr.20230509083242.991"><vh>@@clean dict.cpp</vh>
<v t="ekr.20230509083242.992"><vh>void DictArithmeticOptimization::handle</vh></v>
</v>
<v t="ekr.20230509083242.993"><vh>@@clean dict.h</vh>
<v t="ekr.20230509083242.994"><vh>class DictArithmeticOptimization</vh></v>
</v>
<v t="ekr.20230509083242.995"><vh>@@clean generator.cpp</vh>
<v t="ekr.20230509083243.1"><vh>bool isSum</vh></v>
<v t="ekr.20230509083243.2"><vh>bool isAny</vh></v>
<v t="ekr.20230509083243.3"><vh>bool isAll</vh></v>
<v t="ekr.20230509083243.4"><vh>// Replaces yields with updates to the accumulator variable.</vh></v>
<v t="ekr.20230509083243.5"><vh>void handle</vh></v>
<v t="ekr.20230509083243.6"><vh>void handle</vh></v>
<v t="ekr.20230509083243.7"><vh>void handle</vh></v>
<v t="ekr.20230509083243.8"><vh>void handle</vh></v>
<v t="ekr.20230509083243.9"><vh>void handle</vh></v>
<v t="ekr.20230509083243.10"><vh>void handle</vh></v>
<v t="ekr.20230509083243.11"><vh>const std::string</vh>
<v t="ekr.20230509083243.12"><vh>void GeneratorArgumentOptimization::handle</vh></v>
</v>
</v>
<v t="ekr.20230509083243.13"><vh>@@clean generator.h</vh>
<v t="ekr.20230509083243.14"><vh>class GeneratorArgumentOptimization</vh></v>
</v>
<v t="ekr.20230509083243.15"><vh>@@clean io.cpp</vh>
<v t="ekr.20230509083243.16"><vh>void optimizePrint</vh></v>
<v t="ekr.20230509083243.17"><vh>void optimizeWrite</vh></v>
<v t="ekr.20230509083243.18"><vh>} // namespace</vh></v>
<v t="ekr.20230509083243.19"><vh>void IOCatOptimization::handle</vh></v>
</v>
<v t="ekr.20230509083243.20"><vh>@@clean io.h</vh>
<v t="ekr.20230509083243.21"><vh>class IOCatOptimization</vh></v>
</v>
<v t="ekr.20230509083243.22"><vh>@@clean list.cpp</vh>
<v t="ekr.20230509083243.23"><vh>void doSetup</vh></v>
<v t="ekr.20230509083243.24"><vh>static std::unique_ptr&lt;ElementHandler&gt; get</vh></v>
<v t="ekr.20230509083243.25"><vh>void setup</vh></v>
<v t="ekr.20230509083243.26"><vh>Value *length</vh></v>
<v t="ekr.20230509083243.27"><vh>static std::unique_ptr</vh></v>
<v t="ekr.20230509083243.28"><vh>}</vh></v>
<v t="ekr.20230509083243.29"><vh>void setup</vh></v>
<v t="ekr.20230509083243.30"><vh>Value *length</vh></v>
<v t="ekr.20230509083243.31"><vh>static std::unique_ptr</vh></v>
<v t="ekr.20230509083243.32"><vh>}</vh></v>
<v t="ekr.20230509083243.33"><vh>void setup</vh></v>
<v t="ekr.20230509083243.34"><vh>Value *length</vh></v>
<v t="ekr.20230509083243.35"><vh>static std::unique_ptr</vh></v>
<v t="ekr.20230509083243.36"><vh>}</vh></v>
<v t="ekr.20230509083243.37"><vh>void inspect</vh></v>
<v t="ekr.20230509083243.38"><vh>Value *optimize</vh></v>
<v t="ekr.20230509083243.39"><vh>void ListAdditionOptimization::handle</vh></v>
</v>
<v t="ekr.20230509083243.40"><vh>@@clean list.h</vh>
<v t="ekr.20230509083243.41"><vh>class ListAdditionOptimization</vh></v>
</v>
<v t="ekr.20230509083243.42"><vh>@@clean str.cpp</vh>
<v t="ekr.20230509083243.43"><vh>bool isString</vh></v>
<v t="ekr.20230509083243.44"><vh>void inspect</vh></v>
<v t="ekr.20230509083243.45"><vh>} // namespace</vh></v>
<v t="ekr.20230509083243.46"><vh>void StrAdditionOptimization::handle</vh></v>
</v>
<v t="ekr.20230509083243.47"><vh>@@clean str.h</vh>
<v t="ekr.20230509083243.48"><vh>class StrAdditionOptimization</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.49"><vh>@path types</vh>
<v t="ekr.20230509083243.50"><vh>@@clean types.cpp</vh>
<v t="ekr.20230509083243.51"><vh>auto it</vh>
<v t="ekr.20230509083243.52"><vh>int RecordType::getMemberIndex</vh></v>
</v>
<v t="ekr.20230509083243.53"><vh>auto it</vh>
<v t="ekr.20230509083243.54"><vh>void RecordType::realize</vh></v>
</v>
<v t="ekr.20230509083243.55"><vh>const char RefType::NodeId</vh></v>
<v t="ekr.20230509083243.56"><vh>bool RefType::doIsContentAtomic</vh></v>
</v>
<v t="ekr.20230509083243.57"><vh>@@clean types.h</vh>
<v t="ekr.20230509083243.58"><vh>class Generic</vh></v>
<v t="ekr.20230509083243.59"><vh>class Type</vh>
<v t="ekr.20230509083243.60"><vh>Type.int replaceUsedType</vh></v>
</v>
<v t="ekr.20230509083243.61"><vh>class PrimitiveType</vh></v>
<v t="ekr.20230509083243.62"><vh>class IntType</vh></v>
<v t="ekr.20230509083243.63"><vh>class FloatType</vh></v>
<v t="ekr.20230509083243.64"><vh>class Float32Type</vh></v>
<v t="ekr.20230509083243.65"><vh>class BoolType</vh></v>
<v t="ekr.20230509083243.66"><vh>class ByteType</vh></v>
<v t="ekr.20230509083243.67"><vh>class VoidType</vh></v>
<v t="ekr.20230509083243.68"><vh>class MemberedType</vh>
<v t="ekr.20230509083243.69"><vh>class Field</vh></v>
</v>
<v t="ekr.20230509083243.70"><vh>class RecordType</vh>
<v t="ekr.20230509083243.71"><vh>RecordType.bool doIsAtomic</vh></v>
</v>
<v t="ekr.20230509083243.72"><vh>class RefType</vh>
<v t="ekr.20230509083243.73"><vh>RefType.int getMemberIndex</vh></v>
<v t="ekr.20230509083243.74"><vh>RefType.const_iterator begin</vh></v>
<v t="ekr.20230509083243.75"><vh>RefType.void realize</vh></v>
</v>
<v t="ekr.20230509083243.76"><vh>class FuncType</vh></v>
<v t="ekr.20230509083243.77"><vh>class DerivedType</vh></v>
<v t="ekr.20230509083243.78"><vh>class PointerType</vh></v>
<v t="ekr.20230509083243.79"><vh>class OptionalType</vh></v>
<v t="ekr.20230509083243.80"><vh>class GeneratorType</vh></v>
<v t="ekr.20230509083243.81"><vh>class IntNType</vh></v>
<v t="ekr.20230509083243.82"><vh>class VectorType</vh></v>
<v t="ekr.20230509083243.83"><vh>class UnionType</vh>
<v t="ekr.20230509083243.84"><vh>UnionType.bool doIsAtomic</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.85"><vh>@path util</vh>
<v t="ekr.20230509083243.86"><vh>@@clean cloning.cpp</vh>
<v t="ekr.20230509083243.87"><vh>void preHook</vh></v>
<v t="ekr.20230509083243.88"><vh>}</vh></v>
<v t="ekr.20230509083243.89"><vh>const std::unordered_map</vh></v>
<v t="ekr.20230509083243.90"><vh>Var *CloneVisitor::clone</vh></v>
<v t="ekr.20230509083243.91"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.92"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.93"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.94"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.95"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.96"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.97"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.98"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.99"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.100"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.101"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.102"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.103"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.104"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.105"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.106"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.107"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.108"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.109"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.110"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.111"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.112"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.113"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.114"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.115"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.116"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.117"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.118"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.119"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.120"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.121"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.122"><vh>void CloneVisitor::visit</vh></v>
<v t="ekr.20230509083243.123"><vh>void CloneVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.124"><vh>@@clean cloning.h</vh>
<v t="ekr.20230509083243.125"><vh>class CloneVisitor</vh>
<v t="ekr.20230509083243.126"><vh>CloneVisitor.template &lt;typename NodeType&gt;</vh></v>
<v t="ekr.20230509083243.127"><vh>CloneVisitor.PipelineFlow::Stage clone</vh></v>
<v t="ekr.20230509083243.128"><vh>CloneVisitor.template &lt;typename NodeType, typename... Args&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083243.129"><vh>@@clean context.h</vh>
<v t="ekr.20230509083243.130"><vh>void replaceFrame</vh></v>
</v>
<v t="ekr.20230509083243.131"><vh>@@clean format.cpp</vh></v>
<v t="ekr.20230509083243.132"><vh>@@clean format.h</vh></v>
<v t="ekr.20230509083243.133"><vh>@@clean inlining.cpp</vh>
<v t="ekr.20230509083243.134"><vh>class ReturnVerifier</vh>
<v t="ekr.20230509083243.135"><vh>ReturnVerifier.void handle</vh></v>
</v>
<v t="ekr.20230509083243.136"><vh>class ReturnReplacer</vh>
<v t="ekr.20230509083243.137"><vh>ReturnReplacer.void handle</vh></v>
</v>
</v>
<v t="ekr.20230509083243.138"><vh>@@clean inlining.h</vh></v>
<v t="ekr.20230509083243.139"><vh>@@clean irtools.cpp</vh>
<v t="ekr.20230509083243.140"><vh>bool hasAttribute</vh></v>
<v t="ekr.20230509083243.141"><vh>bool isStdlibFunc</vh></v>
<v t="ekr.20230509083243.142"><vh>CallInstr *call</vh></v>
<v t="ekr.20230509083243.143"><vh>bool isCallOf</vh>
<v t="ekr.20230509083243.144"><vh>const std::vector</vh>
<v t="ekr.20230509083243.145"><vh>bool method</vh></v>
</v>
</v>
<v t="ekr.20230509083243.146"><vh>bool isCallOf</vh></v>
<v t="ekr.20230509083243.147"><vh>bool isMagicMethodCall</vh></v>
<v t="ekr.20230509083243.148"><vh>Value *makeTuple</vh></v>
<v t="ekr.20230509083243.149"><vh>const Var</vh></v>
<v t="ekr.20230509083243.150"><vh>Func *getFunc</vh></v>
<v t="ekr.20230509083243.151"><vh>const Func</vh></v>
<v t="ekr.20230509083243.152"><vh>Value *ptrLoad</vh></v>
<v t="ekr.20230509083243.153"><vh>const std::string</vh></v>
<v t="ekr.20230509083243.154"><vh>const BodiedFunc</vh>
<v t="ekr.20230509083243.155"><vh>const std::string</vh></v>
</v>
<v t="ekr.20230509083243.156"><vh>types::Type *getReturnType</vh></v>
<v t="ekr.20230509083243.157"><vh>void setReturnType</vh></v>
</v>
<v t="ekr.20230509083243.158"><vh>@@clean irtools.h</vh></v>
<v t="ekr.20230509083243.159"><vh>@@clean iterators.h</vh>
<v t="ekr.20230509083243.160"><vh>template &lt;typename It, typename DereferenceFunc, typename MemberFunc&gt;</vh>
<v t="ekr.20230509083243.161"><vh>template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;</vh></v>
<v t="ekr.20230509083243.162"><vh>template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083243.163"><vh>@@clean matching.cpp</vh>
<v t="ekr.20230509083243.164"><vh>void visit</vh></v>
<v t="ekr.20230509083243.165"><vh>namespace codon</vh></v>
<v t="ekr.20230509083243.166"><vh>class MatchVisitor</vh>
<v t="ekr.20230509083243.167"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.168"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.169"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.170"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.171"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.172"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.173"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.174"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.175"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.176"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.177"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.178"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.179"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.180"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.181"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.182"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.183"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.184"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.185"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.186"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.187"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.188"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.189"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.190"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.191"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.192"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.193"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.194"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.195"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.196"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.197"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.198"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.199"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.200"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.201"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.202"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.203"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.204"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.205"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.206"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.207"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.208"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.209"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.210"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.211"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.212"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.213"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.214"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.215"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.216"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.217"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.218"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.219"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.220"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.221"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.222"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.223"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.224"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.225"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.226"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.227"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.228"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.229"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.230"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.231"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.232"><vh>MatchVisitor.VISIT</vh></v>
<v t="ekr.20230509083243.233"><vh>MatchVisitor.void handle</vh></v>
<v t="ekr.20230509083243.234"><vh>MatchVisitor.bool process</vh></v>
<v t="ekr.20230509083243.235"><vh>MatchVisitor.private:</vh></v>
<v t="ekr.20230509083243.236"><vh>MatchVisitor.bool compareVars</vh></v>
<v t="ekr.20230509083243.237"><vh>MatchVisitor.bool compareFuncs</vh></v>
</v>
<v t="ekr.20230509083243.238"><vh>} // namespace</vh></v>
<v t="ekr.20230509083243.239"><vh>bool match</vh></v>
</v>
<v t="ekr.20230509083243.240"><vh>@@clean matching.h</vh>
<v t="ekr.20230509083243.241"><vh>class AnyValue</vh></v>
<v t="ekr.20230509083243.242"><vh>class AnyFlow</vh></v>
<v t="ekr.20230509083243.243"><vh>class AnyVar</vh></v>
<v t="ekr.20230509083243.244"><vh>class AnyFunc</vh></v>
</v>
<v t="ekr.20230509083243.245"><vh>@@clean operator.h</vh>
<v t="ekr.20230509083243.246"><vh>void visit</vh></v>
<v t="ekr.20230509083243.247"><vh>namespace codon</vh></v>
<v t="ekr.20230509083243.248"><vh>class Operator</vh>
<v t="ekr.20230509083243.249"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509083243.250"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509083243.251"><vh>Operator.LAMBDA_VISIT</vh></v>
<v t="ekr.20230509083243.252"><vh>Operator.void visit</vh></v>
<v t="ekr.20230509083243.253"><vh>Operator.virtual void handle</vh></v>
<v t="ekr.20230509083243.254"><vh>Operator.auto insertBefore</vh></v>
<v t="ekr.20230509083243.255"><vh>Operator.auto insertAfter</vh></v>
<v t="ekr.20230509083243.256"><vh>Operator.void reset</vh></v>
<v t="ekr.20230509083243.257"><vh>Operator.private:</vh></v>
<v t="ekr.20230509083243.258"><vh>Operator.void processChildren</vh></v>
<v t="ekr.20230509083243.259"><vh>Operator.void processSeriesFlowChildren</vh></v>
</v>
</v>
<v t="ekr.20230509083243.260"><vh>@@clean outlining.cpp</vh>
<v t="ekr.20230509083243.261"><vh>void postHook</vh></v>
<v t="ekr.20230509083243.262"><vh>Var *mappedVar</vh></v>
<v t="ekr.20230509083243.263"><vh>void handle</vh></v>
<v t="ekr.20230509083243.264"><vh>void handle</vh></v>
<v t="ekr.20230509083243.265"><vh>void handle</vh></v>
<v t="ekr.20230509083243.266"><vh>}</vh></v>
<v t="ekr.20230509083243.267"><vh>bool outlineGlobals</vh>
<v t="ekr.20230509083243.268"><vh>bool isEnclosingLoopInRegion</vh></v>
</v>
<v t="ekr.20230509083243.269"><vh>void handle</vh></v>
<v t="ekr.20230509083243.270"><vh>void handle</vh></v>
<v t="ekr.20230509083243.271"><vh>void handle</vh></v>
<v t="ekr.20230509083243.272"><vh>void handle</vh></v>
<v t="ekr.20230509083243.273"><vh>void handle</vh></v>
<v t="ekr.20230509083243.274"><vh>void handle</vh></v>
<v t="ekr.20230509083243.275"><vh>void handle</vh></v>
<v t="ekr.20230509083243.276"><vh>void handle</vh></v>
<v t="ekr.20230509083243.277"><vh>void handle</vh></v>
<v t="ekr.20230509083243.278"><vh>void handle</vh></v>
<v t="ekr.20230509083243.279"><vh>void handle</vh></v>
<v t="ekr.20230509083243.280"><vh>void visit</vh></v>
<v t="ekr.20230509083243.281"><vh>void visit</vh></v>
<v t="ekr.20230509083243.282"><vh>void preHook</vh></v>
<v t="ekr.20230509083243.283"><vh>// private</vh></v>
<v t="ekr.20230509083243.284"><vh>bool outlineGlobals</vh></v>
<v t="ekr.20230509083243.285"><vh>OutlineResult outlineRegion</vh></v>
<v t="ekr.20230509083243.286"><vh>bool outlineGlobals</vh></v>
</v>
<v t="ekr.20230509083243.287"><vh>@@clean outlining.h</vh></v>
<v t="ekr.20230509083243.288"><vh>@@clean packs.h</vh>
<v t="ekr.20230509083243.289"><vh>template &lt;typename Desired&gt;</vh></v>
<v t="ekr.20230509083243.290"><vh>/// Utility function to strip parameter packs.</vh></v>
<v t="ekr.20230509083243.291"><vh>template &lt;typename Desired, typename... Args&gt;</vh>
<v t="ekr.20230509083243.292"><vh>void stripPack</vh></v>
</v>
</v>
<v t="ekr.20230509083243.293"><vh>@@clean side_effect.cpp</vh></v>
<v t="ekr.20230509083243.294"><vh>@@clean side_effect.h</vh></v>
<v t="ekr.20230509083243.295"><vh>@@clean visitor.cpp</vh></v>
<v t="ekr.20230509083243.296"><vh>@@clean visitor.h</vh>
<v t="ekr.20230509083243.297"><vh>class Visitor</vh></v>
<v t="ekr.20230509083243.298"><vh>class ConstVisitor</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.299"><vh>@path compiler</vh>
<v t="ekr.20230509083243.300"><vh>@@clean compiler.cpp</vh>
<v t="ekr.20230509083243.301"><vh>const std::vector</vh>
<v t="ekr.20230509083243.302"><vh>bool pyNumerics</vh></v>
</v>
<v t="ekr.20230509083243.303"><vh>llvm::Error Compiler::load</vh></v>
<v t="ekr.20230509083243.304"><vh>int startLine</vh>
<v t="ekr.20230509083243.305"><vh>const std::unordered_map</vh>
<v t="ekr.20230509083243.306"><vh>auto transformed</vh></v>
<v t="ekr.20230509083243.307"><vh>Timer t3</vh></v>
<v t="ekr.20230509083243.308"><vh>auto typechecked</vh></v>
</v>
</v>
<v t="ekr.20230509083243.309"><vh>llvm::Error</vh></v>
<v t="ekr.20230509083243.310"><vh>const std::unordered_map</vh></v>
<v t="ekr.20230509083243.311"><vh>llvm::Error</vh></v>
<v t="ekr.20230509083243.312"><vh>int testFlags</vh></v>
</v>
<v t="ekr.20230509083243.313"><vh>@@clean compiler.h</vh>
<v t="ekr.20230509083243.314"><vh>class Compiler</vh></v>
</v>
<v t="ekr.20230509083243.315"><vh>@@clean debug_listener.cpp</vh>
<v t="ekr.20230509083243.316"><vh>void DebugListener::notifyObjectLoaded</vh>
<v t="ekr.20230509083243.317"><vh>const llvm::object::ObjectFile</vh>
<v t="ekr.20230509083243.318"><vh>const llvm::RuntimeDyld::LoadedObjectInfo</vh></v>
</v>
</v>
<v t="ekr.20230509083243.319"><vh>auto newObj</vh>
<v t="ekr.20230509083243.320"><vh>void DebugListener::notifyFreeingObject</vh></v>
</v>
<v t="ekr.20230509083243.321"><vh>llvm::Expected&lt;llvm::DILineInfo&gt; DebugListener::symbolize</vh></v>
<v t="ekr.20230509083243.322"><vh>void DebugPlugin::notifyMaterializing</vh>
<v t="ekr.20230509083243.323"><vh>auto newBuf</vh>
<v t="ekr.20230509083243.324"><vh>auto newObj</vh></v>
</v>
</v>
<v t="ekr.20230509083243.325"><vh>llvm::Error DebugPlugin::notifyEmitted</vh></v>
<v t="ekr.20230509083243.326"><vh>auto getLoadAddress</vh></v>
<v t="ekr.20230509083243.327"><vh>// register</vh></v>
<v t="ekr.20230509083243.328"><vh>void DebugPlugin::notifyTransferringResources</vh></v>
<v t="ekr.20230509083243.329"><vh>void DebugPlugin::modifyPassConfig</vh></v>
</v>
<v t="ekr.20230509083243.330"><vh>@@clean debug_listener.h</vh>
<v t="ekr.20230509083243.331"><vh>class DebugListener</vh>
<v t="ekr.20230509083243.332"><vh>class ObjectInfo</vh></v>
</v>
<v t="ekr.20230509083243.333"><vh>class DebugPlugin</vh></v>
</v>
<v t="ekr.20230509083243.334"><vh>@@clean engine.cpp</vh>
<v t="ekr.20230509083243.335"><vh>void Engine::handleLazyCallThroughError</vh></v>
<v t="ekr.20230509083243.336"><vh>llvm::Expected&lt;llvm::orc::ThreadSafeModule&gt;</vh></v>
<v t="ekr.20230509083243.337"><vh>const llvm::orc::MaterializationResponsibility</vh></v>
</v>
<v t="ekr.20230509083243.338"><vh>@@clean engine.h</vh>
<v t="ekr.20230509083243.339"><vh>class Engine</vh></v>
</v>
<v t="ekr.20230509083243.340"><vh>@@clean error.cpp</vh>
<v t="ekr.20230509083243.341"><vh>void raise_error</vh></v>
<v t="ekr.20230509083243.342"><vh>void raise_error</vh></v>
</v>
<v t="ekr.20230509083243.343"><vh>@@clean error.h</vh>
<v t="ekr.20230509083243.344"><vh>class Message</vh>
<v t="ekr.20230509083243.345"><vh>Message.int col</vh>
<v t="ekr.20230509083243.346"><vh>Message.void log</vh></v>
</v>
</v>
<v t="ekr.20230509083243.347"><vh>class ParserErrorInfo</vh>
<v t="ekr.20230509083243.348"><vh>ParserErrorInfo.void log</vh></v>
</v>
<v t="ekr.20230509083243.349"><vh>class RuntimeErrorInfo</vh>
<v t="ekr.20230509083243.350"><vh>RuntimeErrorInfo.void log</vh></v>
</v>
<v t="ekr.20230509083243.351"><vh>class PluginErrorInfo</vh></v>
<v t="ekr.20230509083243.352"><vh>class IOErrorInfo</vh></v>
<v t="ekr.20230509083243.353"><vh>enum Error</vh></v>
<v t="ekr.20230509083243.354"><vh>template &lt;class... TA&gt;</vh></v>
</v>
<v t="ekr.20230509083243.355"><vh>@@clean jit.cpp</vh>
<v t="ekr.20230509083243.356"><vh>const std::string</vh>
<v t="ekr.20230509083243.357"><vh>auto func</vh></v>
</v>
<v t="ekr.20230509083243.358"><vh>llvm::Expected&lt;void *&gt; JIT::address</vh></v>
<v t="ekr.20230509083243.359"><vh>const std::vector</vh>
<v t="ekr.20230509083243.360"><vh>const std::string</vh>
<v t="ekr.20230509083243.361"><vh>const std::vector</vh></v>
</v>
</v>
<v t="ekr.20230509083243.362"><vh>} // namespace</vh></v>
<v t="ekr.20230509083243.363"><vh>bool debug</vh></v>
<v t="ekr.20230509083243.364"><vh>JITResult JIT::executePython</vh></v>
<v t="ekr.20230509083243.365"><vh>const std::vector</vh>
<v t="ekr.20230509083243.366"><vh>const std::string</vh>
<v t="ekr.20230509083243.367"><vh>const std::vector</vh>
<v t="ekr.20230509083243.368"><vh>bool debug</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.369"><vh>JIT *jitInit</vh></v>
<v t="ekr.20230509083243.370"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.371"><vh>JITResult jitExecuteSafe</vh></v>
<v t="ekr.20230509083243.372"><vh>int line</vh></v>
</v>
<v t="ekr.20230509083243.373"><vh>@@clean jit.h</vh>
<v t="ekr.20230509083243.374"><vh>class JIT</vh></v>
</v>
<v t="ekr.20230509083243.375"><vh>@@clean jit_extern.h</vh></v>
<v t="ekr.20230509083243.376"><vh>@@clean memory_manager.cpp</vh>
<v t="ekr.20230509083243.377"><vh>unsigned sectionID</vh>
<v t="ekr.20230509083243.378"><vh>bool isReadOnly</vh></v>
</v>
<v t="ekr.20230509083243.379"><vh>BoehmGCMemoryManager::~BoehmGCMemoryManager</vh></v>
<v t="ekr.20230509083243.380"><vh>class BoehmGCJITLinkMemoryManager</vh>
<v t="ekr.20230509083243.381"><vh>BoehmGCJITLinkMemoryManager.void finalize</vh></v>
<v t="ekr.20230509083243.382"><vh>BoehmGCJITLinkMemoryManager.void abandon</vh></v>
</v>
<v t="ekr.20230509083243.383"><vh>llvm::Expected&lt;std::unique_ptr&lt;BoehmGCJITLinkMemoryManager&gt;&gt;</vh></v>
<v t="ekr.20230509083243.384"><vh>void BoehmGCJITLinkMemoryManager::allocate</vh>
<v t="ekr.20230509083243.385"><vh>const llvm::sys::Memory::ProtectionFlags</vh>
<v t="ekr.20230509083243.386"><vh>static _cast</vh></v>
</v>
<v t="ekr.20230509083243.387"><vh>// Zero-fill the whole slab up-front.</vh></v>
<v t="ekr.20230509083243.388"><vh>static _cast</vh></v>
</v>
<v t="ekr.20230509083243.389"><vh>void BoehmGCJITLinkMemoryManager::deallocate</vh></v>
</v>
<v t="ekr.20230509083243.390"><vh>@@clean memory_manager.h</vh>
<v t="ekr.20230509083243.391"><vh>class BoehmGCMemoryManager</vh></v>
<v t="ekr.20230509083243.392"><vh>class BoehmGCJITLinkMemoryManager</vh>
<v t="ekr.20230509083243.393"><vh>BoehmGCJITLinkMemoryManager.void deallocate</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.395"><vh>@path dsl</vh>
<v t="ekr.20230509083243.396"><vh>@@clean dsl.h</vh>
<v t="ekr.20230509083243.397"><vh>class DSL</vh></v>
</v>
<v t="ekr.20230509083243.398"><vh>@@clean plugins.cpp</vh></v>
<v t="ekr.20230509083243.399"><vh>@@clean plugins.h</vh>
<v t="ekr.20230509083243.400"><vh>class PluginManager</vh></v>
</v>
</v>
<v t="ekr.20230509083243.401"><vh>@path parser</vh>
<v t="ekr.20230509083243.402"><vh>@@clean ast.h</vh></v>
<v t="ekr.20230509083243.403"><vh>@@clean cache.cpp</vh>
<v t="ekr.20230509083243.404"><vh>void Cache::addGlobal</vh></v>
<v t="ekr.20230509083243.405"><vh>SrcInfo Cache::generateSrcInfo</vh></v>
<v t="ekr.20230509083243.406"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.407"><vh>ir::types::Type *Cache::realizeType</vh></v>
<v t="ekr.20230509083243.408"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.409"><vh>ir::Func *Cache::realizeFunction</vh></v>
<v t="ekr.20230509083243.410"><vh>const std::vector</vh>
<v t="ekr.20230509083243.411"><vh>const std::vector</vh>
<v t="ekr.20230509083243.412"><vh>const types::ClassTypePtr</vh></v>
</v>
</v>
<v t="ekr.20230509083243.413"><vh>ir::types::Type *Cache::makeTuple</vh></v>
<v t="ekr.20230509083243.414"><vh>auto argType</vh></v>
<v t="ekr.20230509083243.415"><vh>void Cache::parseCode</vh></v>
<v t="ekr.20230509083243.416"><vh>std::vector&lt;ExprPtr&gt; Cache::mergeC3</vh></v>
<v t="ekr.20230509083243.417"><vh>void Cache::populatePythonModule</vh>
<v t="ekr.20230509083243.418"><vh>auto realizeIR</vh>
<v t="ekr.20230509083243.419"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.420"><vh>const std::string pyWrap</vh></v>
<v t="ekr.20230509083243.421"><vh>auto generics</vh></v>
<v t="ekr.20230509083243.422"><vh>ir::Func *sf</vh></v>
<v t="ekr.20230509083243.423"><vh>auto generics</vh></v>
</v>
</v>
<v t="ekr.20230509083243.424"><vh>@@clean cache.h</vh></v>
<v t="ekr.20230509083243.425"><vh>@@clean common.cpp</vh></v>
<v t="ekr.20230509083243.426"><vh>@@clean common.h</vh>
<v t="ekr.20230509083243.427"><vh>template &lt;typename T&gt;</vh></v>
<v t="ekr.20230509083243.428"><vh>template &lt;typename T&gt;</vh></v>
<v t="ekr.20230509083243.429"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.430"><vh>int start</vh></v>
</v>
<v t="ekr.20230509083243.431"><vh>template &lt;typename T, typename U&gt;</vh></v>
<v t="ekr.20230509083243.432"><vh>/// @return True if an item is found in a set s.</vh></v>
<v t="ekr.20230509083243.433"><vh>template &lt;typename T, typename U&gt;</vh></v>
<v t="ekr.20230509083243.434"><vh>template &lt;typename K, typename V, typename U&gt;</vh></v>
<v t="ekr.20230509083243.435"><vh>template &lt;typename K, typename V, typename U&gt;</vh></v>
</v>
<v t="ekr.20230509083243.436"><vh>@@clean ctx.h</vh>
<v t="ekr.20230509083243.437"><vh>void remove</vh></v>
<v t="ekr.20230509083243.438"><vh>/// Return a top-most object with a given identifier or nullptr if it does not exist.</vh></v>
<v t="ekr.20230509083243.439"><vh>void removeFromMap</vh></v>
</v>
<v t="ekr.20230509083243.440"><vh>@path ast</vh>
<v t="ekr.20230509083243.441"><vh>@@clean error.h</vh>
<v t="ekr.20230509083243.442"><vh>class ParserException</vh>
<v t="ekr.20230509083243.443"><vh>ParserException.void trackRealize</vh></v>
<v t="ekr.20230509083243.444"><vh>ParserException.void track</vh></v>
</v>
</v>
<v t="ekr.20230509083243.445"><vh>@@clean expr.cpp</vh>
<v t="ekr.20230509083243.446"><vh>void Expr::validate</vh></v>
<v t="ekr.20230509083243.447"><vh>bool Expr::isStatic</vh></v>
<v t="ekr.20230509083243.448"><vh>bool StaticValue::operator</vh></v>
<v t="ekr.20230509083243.449"><vh>std::string StaticValue::toString</vh></v>
<v t="ekr.20230509083243.450"><vh>int 64_t</vh></v>
<v t="ekr.20230509083243.451"><vh>std::string StaticValue::getString</vh></v>
<v t="ekr.20230509083243.452"><vh>int status</vh></v>
<v t="ekr.20230509083243.453"><vh>std::string Param::toString</vh></v>
<v t="ekr.20230509083243.454"><vh>int Value</vh></v>
<v t="ekr.20230509083243.455"><vh>std::string IntExpr::toString</vh></v>
<v t="ekr.20230509083243.456"><vh>void PipeExpr::validate</vh></v>
<v t="ekr.20230509083243.457"><vh>ACCEPT_IMPL</vh></v>
<v t="ekr.20230509083243.458"><vh>void CallExpr::validate</vh></v>
</v>
<v t="ekr.20230509083243.459"><vh>@@clean expr.h</vh>
<v t="ekr.20230509083243.460"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.461"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509083243.462"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083243.463"><vh>template &lt;&gt;</vh></v>
<v t="ekr.20230509083243.464"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.465"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083243.466"><vh>@@clean stmt.cpp</vh>
<v t="ekr.20230509083243.467"><vh>void Stmt::validate</vh></v>
<v t="ekr.20230509083243.468"><vh>SuiteStmt::SuiteStmt</vh></v>
<v t="ekr.20230509083243.469"><vh>void SuiteStmt::flatten</vh></v>
<v t="ekr.20230509083243.470"><vh>StmtPtr *SuiteStmt::lastInBlock</vh></v>
<v t="ekr.20230509083243.471"><vh>void ImportStmt::validate</vh></v>
<v t="ekr.20230509083243.472"><vh>ACCEPT_IMPL</vh></v>
<v t="ekr.20230509083243.473"><vh>void FunctionStmt::validate</vh></v>
<v t="ekr.20230509083243.474"><vh>ACCEPT_IMPL</vh></v>
<v t="ekr.20230509083243.475"><vh>bool FunctionStmt::hasAttr</vh></v>
<v t="ekr.20230509083243.476"><vh>void FunctionStmt::parseDecorators</vh></v>
<v t="ekr.20230509083243.477"><vh>size_t FunctionStmt::getStarArgs</vh></v>
<v t="ekr.20230509083243.478"><vh>class IdSearchVisitor</vh>
<v t="ekr.20230509083243.479"><vh>IdSearchVisitor.bool transform</vh></v>
<v t="ekr.20230509083243.480"><vh>IdSearchVisitor.bool transform</vh></v>
<v t="ekr.20230509083243.481"><vh>IdSearchVisitor.void visit</vh></v>
</v>
<v t="ekr.20230509083243.482"><vh>/// Check if a function can be called with the given arguments.</vh></v>
<v t="ekr.20230509083243.483"><vh>static BaseClasses</vh></v>
<v t="ekr.20230509083243.484"><vh>ClassStmt::ClassStmt</vh></v>
<v t="ekr.20230509083243.485"><vh>static BaseClasses</vh></v>
<v t="ekr.20230509083243.486"><vh>void ClassStmt::validate</vh></v>
<v t="ekr.20230509083243.487"><vh>ACCEPT_IMPL</vh></v>
<v t="ekr.20230509083243.488"><vh>void ClassStmt::parseDecorators</vh></v>
<v t="ekr.20230509083243.489"><vh>bool ClassStmt::isClassVar</vh></v>
</v>
<v t="ekr.20230509083243.490"><vh>@@clean stmt.h</vh>
<v t="ekr.20230509083243.491"><vh>template &lt;typename... Ts&gt;</vh></v>
<v t="ekr.20230509083243.492"><vh>StmtPtr *lastInBlock</vh></v>
<v t="ekr.20230509083243.493"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.494"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.495"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.496"><vh>@@clean types.h</vh></v>
<v t="ekr.20230509083243.497"><vh>@path types</vh>
<v t="ekr.20230509083243.498"><vh>@@clean class.cpp</vh>
<v t="ekr.20230509083243.499"><vh>int ClassType::unify</vh></v>
<v t="ekr.20230509083243.500"><vh>TypePtr ClassType::generalize</vh></v>
<v t="ekr.20230509083243.501"><vh>bool ClassType::canRealize</vh></v>
<v t="ekr.20230509083243.502"><vh>bool ClassType::isInstantiated</vh></v>
<v t="ekr.20230509083243.503"><vh>std::string ClassType::debugString</vh></v>
<v t="ekr.20230509083243.504"><vh>const _cast</vh></v>
<v t="ekr.20230509083243.505"><vh>RecordType::RecordType</vh></v>
<v t="ekr.20230509083243.506"><vh>bool noTuple</vh>
<v t="ekr.20230509083243.507"><vh>bool noTuple</vh>
<v t="ekr.20230509083243.508"><vh>int RecordType::unify</vh></v>
</v>
</v>
<v t="ekr.20230509083243.509"><vh>TypePtr RecordType::generalize</vh></v>
<v t="ekr.20230509083243.510"><vh>auto c</vh></v>
<v t="ekr.20230509083243.511"><vh>bool RecordType::canRealize</vh></v>
<v t="ekr.20230509083243.512"><vh>bool RecordType::isInstantiated</vh></v>
</v>
<v t="ekr.20230509083243.513"><vh>@@clean class.h</vh>
<v t="ekr.20230509083243.514"><vh>template &lt;&gt;</vh>
<v t="ekr.20230509083243.515"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
<v t="ekr.20230509083243.516"><vh>@@clean function.cpp</vh>
<v t="ekr.20230509083243.517"><vh>int FuncType::unify</vh></v>
<v t="ekr.20230509083243.518"><vh>TypePtr FuncType::generalize</vh></v>
<v t="ekr.20230509083243.519"><vh>bool FuncType::canRealize</vh></v>
<v t="ekr.20230509083243.520"><vh>bool generics</vh>
<v t="ekr.20230509083243.521"><vh>bool FuncType::isInstantiated</vh></v>
</v>
<v t="ekr.20230509083243.522"><vh>auto res</vh></v>
<v t="ekr.20230509083243.523"><vh>std::string FuncType::realizedName</vh></v>
<v t="ekr.20230509083243.524"><vh>int PartialType::unify</vh></v>
<v t="ekr.20230509083243.525"><vh>TypePtr PartialType::generalize</vh></v>
<v t="ekr.20230509083243.526"><vh>auto rec</vh></v>
</v>
<v t="ekr.20230509083243.527"><vh>@@clean function.h</vh></v>
<v t="ekr.20230509083243.528"><vh>@@clean link.cpp</vh>
<v t="ekr.20230509083243.529"><vh>char isStatic</vh></v>
<v t="ekr.20230509083243.530"><vh>LinkType::LinkType</vh></v>
<v t="ekr.20230509083243.531"><vh>int LinkType::unify</vh></v>
<v t="ekr.20230509083243.532"><vh>TypePtr LinkType::generalize</vh></v>
<v t="ekr.20230509083243.533"><vh>bool LinkType::canRealize</vh></v>
<v t="ekr.20230509083243.534"><vh>bool LinkType::isInstantiated</vh></v>
<v t="ekr.20230509083243.535"><vh>bool LinkType::occurs</vh></v>
</v>
<v t="ekr.20230509083243.536"><vh>@@clean link.h</vh></v>
<v t="ekr.20230509083243.537"><vh>@@clean static.cpp</vh>
<v t="ekr.20230509083243.538"><vh>const std::shared_ptr</vh>
<v t="ekr.20230509083243.539"><vh>int StaticType::unify</vh></v>
</v>
<v t="ekr.20230509083243.540"><vh>TypePtr StaticType::generalize</vh></v>
<v t="ekr.20230509083243.541"><vh>bool StaticType::canRealize</vh></v>
<v t="ekr.20230509083243.542"><vh>bool StaticType::isInstantiated</vh></v>
<v t="ekr.20230509083243.543"><vh>void StaticType::parseExpr</vh></v>
</v>
<v t="ekr.20230509083243.544"><vh>@@clean static.h</vh></v>
<v t="ekr.20230509083243.545"><vh>@@clean traits.cpp</vh>
<v t="ekr.20230509083243.546"><vh>int CallableTrait::unify</vh></v>
</v>
<v t="ekr.20230509083243.547"><vh>@@clean traits.h</vh></v>
<v t="ekr.20230509083243.548"><vh>@@clean type.cpp</vh>
<v t="ekr.20230509083243.549"><vh>void Type::Unification::undo</vh></v>
<v t="ekr.20230509083243.550"><vh>Type::Type</vh></v>
<v t="ekr.20230509083243.551"><vh>char Type::isStaticType</vh></v>
<v t="ekr.20230509083243.552"><vh>TypePtr Type::makeType</vh></v>
<v t="ekr.20230509083243.553"><vh>const std::string</vh></v>
</v>
<v t="ekr.20230509083243.554"><vh>@@clean type.h</vh>
<v t="ekr.20230509083243.555"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.556"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.557"><vh>const expr</vh></v>
<v t="ekr.20230509083243.558"><vh>template &lt;typename FormatContext&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.559"><vh>@@clean union.cpp</vh>
<v t="ekr.20230509083243.560"><vh>const std::vector</vh>
<v t="ekr.20230509083243.561"><vh>int UnionType::unify</vh></v>
</v>
<v t="ekr.20230509083243.562"><vh>TypePtr UnionType::generalize</vh></v>
<v t="ekr.20230509083243.563"><vh>void UnionType::addType</vh></v>
<v t="ekr.20230509083243.564"><vh>bool UnionType::isSealed</vh></v>
<v t="ekr.20230509083243.565"><vh>void UnionType::seal</vh></v>
<v t="ekr.20230509083243.566"><vh>auto t</vh></v>
</v>
<v t="ekr.20230509083243.567"><vh>@@clean union.h</vh></v>
</v>
</v>
<v t="ekr.20230509083243.568"><vh>@path peg</vh>
<v t="ekr.20230509083243.569"><vh>@@clean peg.cpp</vh>
<v t="ekr.20230509083243.570"><vh>template &lt;typename T&gt;</vh>
<v t="ekr.20230509083243.571"><vh>int line_offset</vh>
<v t="ekr.20230509083243.572"><vh>auto log</vh></v>
<v t="ekr.20230509083243.573"><vh>T result</vh></v>
<v t="ekr.20230509083243.574"><vh>auto r</vh></v>
</v>
</v>
<v t="ekr.20230509083243.575"><vh>StmtPtr parseCode</vh></v>
<v t="ekr.20230509083243.576"><vh>int line_offset</vh></v>
<v t="ekr.20230509083243.577"><vh>std::pair&lt;ExprPtr, std::string&gt; parseExpr</vh></v>
<v t="ekr.20230509083243.578"><vh>const codon::SrcInfo</vh></v>
<v t="ekr.20230509083243.579"><vh>auto e</vh></v>
<v t="ekr.20230509083243.580"><vh>std::shared_ptr&lt;peg::Grammar&gt; initOpenMPParser</vh></v>
<v t="ekr.20230509083243.581"><vh>const codon::SrcInfo</vh>
<v t="ekr.20230509083243.582"><vh>auto log</vh></v>
<v t="ekr.20230509083243.583"><vh>std::vector&lt;CallExpr::Arg&gt; result</vh></v>
<v t="ekr.20230509083243.584"><vh>auto r</vh></v>
</v>
</v>
<v t="ekr.20230509083243.585"><vh>@@clean peg.h</vh></v>
<v t="ekr.20230509083243.586"><vh>@@clean rules.h</vh>
<v t="ekr.20230509083243.587"><vh>bool hasCustomStmtKeyword</vh></v>
<v t="ekr.20230509083243.588"><vh>bool hasCustomExprStmt</vh></v>
</v>
</v>
<v t="ekr.20230509083243.589"><vh>@path visitors</vh>
<v t="ekr.20230509083243.590"><vh>@@clean visitor.cpp</vh></v>
<v t="ekr.20230509083243.591"><vh>@@clean visitor.h</vh>
<v t="ekr.20230509083243.592"><vh>template &lt;typename TE, typename TS&gt;</vh>
<v t="ekr.20230509083243.593"><vh>template &lt;typename T, typename... TArgs&gt;</vh></v>
<v t="ekr.20230509083243.594"><vh>template &lt;typename T, typename... TArgs&gt;</vh></v>
<v t="ekr.20230509083243.595"><vh>public:</vh></v>
<v t="ekr.20230509083243.596"><vh>void visit</vh>
<v t="ekr.20230509083243.597"><vh>void visit</vh>
<v t="ekr.20230509083243.598"><vh>void visit</vh>
<v t="ekr.20230509083243.599"><vh>void visit</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.600"><vh>void visit</vh></v>
<v t="ekr.20230509083243.601"><vh>void visit</vh></v>
<v t="ekr.20230509083243.602"><vh>void visit</vh></v>
<v t="ekr.20230509083243.603"><vh>void visit</vh></v>
<v t="ekr.20230509083243.604"><vh>void visit</vh></v>
<v t="ekr.20230509083243.605"><vh>void visit</vh></v>
<v t="ekr.20230509083243.606"><vh>void visit</vh></v>
<v t="ekr.20230509083243.607"><vh>void visit</vh></v>
<v t="ekr.20230509083243.608"><vh>void visit</vh></v>
<v t="ekr.20230509083243.609"><vh>void visit</vh></v>
<v t="ekr.20230509083243.610"><vh>void visit</vh></v>
<v t="ekr.20230509083243.611"><vh>void visit</vh></v>
<v t="ekr.20230509083243.612"><vh>void visit</vh></v>
<v t="ekr.20230509083243.613"><vh>void visit</vh></v>
<v t="ekr.20230509083243.614"><vh>void visit</vh></v>
<v t="ekr.20230509083243.615"><vh>void visit</vh></v>
<v t="ekr.20230509083243.616"><vh>void visit</vh></v>
<v t="ekr.20230509083243.617"><vh>void visit</vh></v>
<v t="ekr.20230509083243.618"><vh>void visit</vh></v>
<v t="ekr.20230509083243.619"><vh>void visit</vh></v>
<v t="ekr.20230509083243.620"><vh>void visit</vh></v>
<v t="ekr.20230509083243.621"><vh>void visit</vh></v>
<v t="ekr.20230509083243.622"><vh>void visit</vh></v>
<v t="ekr.20230509083243.623"><vh>void visit</vh></v>
<v t="ekr.20230509083243.624"><vh>void visit</vh></v>
<v t="ekr.20230509083243.625"><vh>void visit</vh></v>
<v t="ekr.20230509083243.626"><vh>void visit</vh></v>
<v t="ekr.20230509083243.627"><vh>void visit</vh></v>
<v t="ekr.20230509083243.628"><vh>void visit</vh></v>
<v t="ekr.20230509083243.629"><vh>void visit</vh></v>
<v t="ekr.20230509083243.630"><vh>void visit</vh></v>
<v t="ekr.20230509083243.631"><vh>void visit</vh>
<v t="ekr.20230509083243.632"><vh>void visit</vh></v>
</v>
<v t="ekr.20230509083243.633"><vh>void visit</vh></v>
<v t="ekr.20230509083243.634"><vh>void visit</vh></v>
<v t="ekr.20230509083243.635"><vh>void visit</vh></v>
<v t="ekr.20230509083243.636"><vh>void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083243.637"><vh>@path doc</vh>
<v t="ekr.20230509083243.638"><vh>@@clean doc.cpp</vh></v>
<v t="ekr.20230509083243.639"><vh>@@clean doc.h</vh></v>
</v>
<v t="ekr.20230509083243.640"><vh>@path format</vh>
<v t="ekr.20230509083243.641"><vh>@@clean format.cpp</vh>
<v t="ekr.20230509083243.642"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.643"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.644"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.645"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.646"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.647"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.648"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.649"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.650"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.651"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.652"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.653"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.654"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.655"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.656"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.657"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.658"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.659"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.660"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.661"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.662"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.663"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.664"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.665"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.666"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.667"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.668"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.669"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.670"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.671"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.672"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.673"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.674"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.675"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.676"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.677"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.678"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.679"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.680"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.681"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.682"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.683"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.684"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.685"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.686"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.687"><vh>void FormatVisitor::visit</vh></v>
<v t="ekr.20230509083243.688"><vh>void FormatVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.689"><vh>@@clean format.h</vh>
<v t="ekr.20230509083243.690"><vh>class FormatVisitor</vh>
<v t="ekr.20230509083243.691"><vh>FormatVisitor.template &lt;typename T&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.692"><vh>@path simplify</vh>
<v t="ekr.20230509083243.693"><vh>@@clean access.cpp</vh>
<v t="ekr.20230509083243.694"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.695"><vh>auto checkStmt</vh></v>
</v>
<v t="ekr.20230509083243.696"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.697"><vh>bool SimplifyVisitor::checkCapture</vh>
<v t="ekr.20230509083243.698"><vh>bool parentClassGeneric</vh></v>
</v>
</v>
<v t="ekr.20230509083243.699"><vh>@@clean assign.cpp</vh>
<v t="ekr.20230509083243.700"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.701"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.702"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.703"><vh>/// Transform simple assignments.</vh></v>
<v t="ekr.20230509083243.704"><vh>bool mustExist</vh></v>
<v t="ekr.20230509083243.705"><vh>void SimplifyVisitor::unpackAssignments</vh></v>
</v>
<v t="ekr.20230509083243.706"><vh>@@clean basic.cpp</vh>
<v t="ekr.20230509083243.707"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.708"><vh>@@clean call.cpp</vh>
<v t="ekr.20230509083243.709"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.710"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.711"><vh>/// Simplify the following special call expressions:</vh></v>
<v t="ekr.20230509083243.712"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.713"><vh>@@clean class.cpp</vh>
<v t="ekr.20230509083243.714"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.715"><vh>auto classItem</vh></v>
<v t="ekr.20230509083243.716"><vh>std::vector&lt;StmtPtr&gt; clsStmts</vh></v>
<v t="ekr.20230509083243.717"><vh>auto banned</vh></v>
</v>
<v t="ekr.20230509083243.718"><vh>/// Parse statically inherited classes.</vh></v>
<v t="ekr.20230509083243.719"><vh>const std::string</vh></v>
<v t="ekr.20230509083243.720"><vh>/// Find the first __init__ with self parameter and use it to deduce class members.</vh></v>
<v t="ekr.20230509083243.721"><vh>void SimplifyVisitor::transformNestedClasses</vh></v>
<v t="ekr.20230509083243.722"><vh>/// Generate a magic method `__op__` for each magic `op`</vh></v>
<v t="ekr.20230509083243.723"><vh>const std::vector</vh>
<v t="ekr.20230509083243.724"><vh>bool isRecord</vh></v>
</v>
</v>
<v t="ekr.20230509083243.725"><vh>@@clean collections.cpp</vh>
<v t="ekr.20230509083243.726"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.727"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.728"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.729"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.730"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.731"><vh>bool canOptimize</vh></v>
<v t="ekr.20230509083243.732"><vh>SuiteStmt *prev</vh></v>
<v t="ekr.20230509083243.733"><vh>auto noOptStmt</vh></v>
</v>
<v t="ekr.20230509083243.734"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.735"><vh>@@clean cond.cpp</vh>
<v t="ekr.20230509083243.736"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.737"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.738"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.739"><vh>/// Transform a match pattern into a series of if statements.</vh></v>
<v t="ekr.20230509083243.740"><vh>auto isinstance</vh></v>
<v t="ekr.20230509083243.741"><vh>auto findEllipsis</vh></v>
</v>
<v t="ekr.20230509083243.742"><vh>@@clean ctx.cpp</vh>
<v t="ekr.20230509083243.743"><vh>void SimplifyContext::add</vh></v>
<v t="ekr.20230509083243.744"><vh>SimplifyContext::Item SimplifyContext::addVar</vh></v>
<v t="ekr.20230509083243.745"><vh>const std::string</vh>
<v t="ekr.20230509083243.746"><vh>const SrcInfo</vh></v>
</v>
<v t="ekr.20230509083243.747"><vh>auto t</vh>
<v t="ekr.20230509083243.748"><vh>const std::string</vh>
<v t="ekr.20230509083243.749"><vh>const SrcInfo</vh></v>
</v>
</v>
<v t="ekr.20230509083243.750"><vh>auto t</vh>
<v t="ekr.20230509083243.751"><vh>const std::string</vh>
<v t="ekr.20230509083243.752"><vh>const SrcInfo</vh></v>
</v>
</v>
<v t="ekr.20230509083243.753"><vh>auto t</vh>
<v t="ekr.20230509083243.754"><vh>auto i</vh></v>
</v>
<v t="ekr.20230509083243.755"><vh>SimplifyContext::Item SimplifyContext::find</vh></v>
<v t="ekr.20230509083243.756"><vh>bool includeBase</vh>
<v t="ekr.20230509083243.757"><vh>bool zeroId</vh></v>
</v>
<v t="ekr.20230509083243.758"><vh>void SimplifyContext::enterConditionalBlock</vh></v>
<v t="ekr.20230509083243.759"><vh>void SimplifyContext::leaveConditionalBlock</vh></v>
<v t="ekr.20230509083243.760"><vh>bool SimplifyContext::isGlobal</vh></v>
<v t="ekr.20230509083243.761"><vh>bool SimplifyContext::inFunction</vh></v>
<v t="ekr.20230509083243.762"><vh>bool SimplifyContext::inClass</vh></v>
<v t="ekr.20230509083243.763"><vh>bool SimplifyContext::isOuter</vh></v>
<v t="ekr.20230509083243.764"><vh>SimplifyContext::Base *SimplifyContext::getClassBase</vh></v>
<v t="ekr.20230509083243.765"><vh>void SimplifyContext::dump</vh>
<v t="ekr.20230509083243.766"><vh>auto ordered</vh></v>
</v>
</v>
<v t="ekr.20230509083243.767"><vh>@@clean ctx.h</vh></v>
<v t="ekr.20230509083243.768"><vh>@@clean error.cpp</vh>
<v t="ekr.20230509083243.769"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.770"><vh>auto test</vh>
<v t="ekr.20230509083243.771"><vh>auto ex</vh></v>
</v>
</v>
<v t="ekr.20230509083243.772"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.773"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.774"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.775"><vh>@@clean function.cpp</vh>
<v t="ekr.20230509083243.776"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.777"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.778"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.779"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.780"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.781"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.782"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.783"><vh>auto canonicalName</vh></v>
</v>
<v t="ekr.20230509083243.784"><vh>/// Make a capturing anonymous function with the provided suite and argument names.</vh></v>
<v t="ekr.20230509083243.785"><vh>const std::vector</vh>
<v t="ekr.20230509083243.786"><vh>auto f</vh></v>
</v>
<v t="ekr.20230509083243.787"><vh>/// Transform Python code blocks.</vh></v>
<v t="ekr.20230509083243.788"><vh>const std::vector</vh>
<v t="ekr.20230509083243.789"><vh>const Expr</vh></v>
</v>
</v>
<v t="ekr.20230509083243.790"><vh>@@clean import.cpp</vh>
<v t="ekr.20230509083243.791"><vh>void SimplifyVisitor::visit</vh>
<v t="ekr.20230509083243.792"><vh>auto file</vh></v>
</v>
<v t="ekr.20230509083243.793"><vh>/// Transform special `from C` and `from python` imports.</vh></v>
<v t="ekr.20230509083243.794"><vh>const std::vector</vh>
<v t="ekr.20230509083243.795"><vh>const Expr</vh></v>
</v>
<v t="ekr.20230509083243.796"><vh>/// Transform a C variable import.</vh></v>
<v t="ekr.20230509083243.797"><vh>const std::string</vh></v>
<v t="ekr.20230509083243.798"><vh>/// Transform a dynamic C import.</vh></v>
<v t="ekr.20230509083243.799"><vh>const std::vector</vh>
<v t="ekr.20230509083243.800"><vh>const Expr</vh>
<v t="ekr.20230509083243.801"><vh>const std::string</vh>
<v t="ekr.20230509083243.802"><vh>bool isFunction</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.803"><vh>/// Transform a Python module and function imports.</vh></v>
<v t="ekr.20230509083243.804"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.805"><vh>/// Import a new file into its own context and wrap its top-level statements into a</vh></v>
<v t="ekr.20230509083243.806"><vh>auto processToplevelStmt</vh></v>
</v>
<v t="ekr.20230509083243.807"><vh>@@clean loops.cpp</vh>
<v t="ekr.20230509083243.808"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.809"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.810"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.811"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.812"><vh>@@clean op.cpp</vh>
<v t="ekr.20230509083243.813"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.814"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.815"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.816"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.817"><vh>@@clean simplify.cpp</vh>
<v t="ekr.20230509083243.818"><vh>const std::unordered_map</vh>
<v t="ekr.20230509083243.819"><vh>const std::unordered_map</vh>
<v t="ekr.20230509083243.820"><vh>bool barebones</vh>
<v t="ekr.20230509083243.821"><vh>auto stdlibPath</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.822"><vh>/// Simplify an AST node. Assumes that the standard library is loaded.</vh></v>
<v t="ekr.20230509083243.823"><vh>const StmtPtr</vh>
<v t="ekr.20230509083243.824"><vh>int atAge</vh></v>
</v>
<v t="ekr.20230509083243.825"><vh>/**************************************************************************************/</vh></v>
<v t="ekr.20230509083243.826"><vh>const std::shared_ptr</vh></v>
<v t="ekr.20230509083243.827"><vh>/**************************************************************************************/</vh></v>
<v t="ekr.20230509083243.828"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.829"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.830"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.831"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.832"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.833"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.834"><vh>void SimplifyVisitor::visit</vh></v>
<v t="ekr.20230509083243.835"><vh>void SimplifyVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.836"><vh>@@clean simplify.h</vh>
<v t="ekr.20230509083243.837"><vh>class SimplifyVisitor</vh></v>
</v>
</v>
<v t="ekr.20230509083243.838"><vh>@path translate</vh>
<v t="ekr.20230509083243.839"><vh>@@clean translate.cpp</vh>
<v t="ekr.20230509083243.840"><vh>void TranslateVisitor::defaultVisit</vh></v>
<v t="ekr.20230509083243.841"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.842"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.843"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.844"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.845"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.846"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.847"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.848"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.849"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.850"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.851"><vh>void TranslateVisitor::visit</vh>
<v t="ekr.20230509083243.852"><vh>auto isGen</vh></v>
</v>
<v t="ekr.20230509083243.853"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.854"><vh>/************************************************************************************/</vh></v>
<v t="ekr.20230509083243.855"><vh>void TranslateVisitor::defaultVisit</vh></v>
<v t="ekr.20230509083243.856"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.857"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.858"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.859"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.860"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.861"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.862"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.863"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.864"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.865"><vh>auto loop</vh>
<v t="ekr.20230509083243.866"><vh>void TranslateVisitor::visit</vh>
<v t="ekr.20230509083243.867"><vh>int 64_t</vh></v>
</v>
</v>
<v t="ekr.20230509083243.868"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.869"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.870"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.871"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.872"><vh>void TranslateVisitor::visit</vh></v>
<v t="ekr.20230509083243.873"><vh>/************************************************************************************/</vh></v>
<v t="ekr.20230509083243.874"><vh>void TranslateVisitor::transformFunction</vh></v>
<v t="ekr.20230509083243.875"><vh>void TranslateVisitor::transformLLVMFunction</vh></v>
</v>
<v t="ekr.20230509083243.876"><vh>@@clean translate.h</vh>
<v t="ekr.20230509083243.877"><vh>class TranslateVisitor</vh>
<v t="ekr.20230509083243.878"><vh>TranslateVisitor.void visit</vh></v>
</v>
</v>
<v t="ekr.20230509083243.879"><vh>@@clean translate_ctx.cpp</vh></v>
<v t="ekr.20230509083243.880"><vh>@@clean translate_ctx.h</vh></v>
</v>
<v t="ekr.20230509083243.881"><vh>@path typecheck</vh>
<v t="ekr.20230509083243.882"><vh>@@clean access.cpp</vh>
<v t="ekr.20230509083243.883"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.884"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.885"><vh>/// Find an overload dispatch function for a given overload. If it does not exist and</vh></v>
<v t="ekr.20230509083243.886"><vh>auto fnType</vh></v>
<v t="ekr.20230509083243.887"><vh>auto e</vh></v>
<v t="ekr.20230509083243.888"><vh>}</vh></v>
<v t="ekr.20230509083243.889"><vh>auto dot</vh></v>
<v t="ekr.20230509083243.890"><vh>// Case: transform `union.m` to `__internal__.get_union_method</vh></v>
<v t="ekr.20230509083243.891"><vh>auto methods</vh></v>
</v>
<v t="ekr.20230509083243.892"><vh>@@clean assign.cpp</vh>
<v t="ekr.20230509083243.893"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.894"><vh>auto val</vh></v>
</v>
<v t="ekr.20230509083243.895"><vh>void TypecheckVisitor::transformUpdate</vh></v>
<v t="ekr.20230509083243.896"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.897"><vh>/// Transform in-place and atomic updates.</vh></v>
<v t="ekr.20230509083243.898"><vh>auto ptrTyp</vh></v>
<v t="ekr.20230509083243.899"><vh>}</vh></v>
<v t="ekr.20230509083243.900"><vh>auto ptrType</vh></v>
</v>
<v t="ekr.20230509083243.901"><vh>@@clean basic.cpp</vh>
<v t="ekr.20230509083243.902"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.903"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.904"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.905"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.906"><vh>void TypecheckVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.907"><vh>@@clean call.cpp</vh>
<v t="ekr.20230509083243.908"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.909"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.910"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.911"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.912"><vh>bool TypecheckVisitor::transformCallArgs</vh></v>
<v t="ekr.20230509083243.913"><vh>/// Extract the @c FuncType that represents the function to be called by the callee.</vh></v>
<v t="ekr.20230509083243.914"><vh>auto newInit</vh>
<v t="ekr.20230509083243.915"><vh>auto init</vh></v>
</v>
<v t="ekr.20230509083243.916"><vh>return</vh></v>
<v t="ekr.20230509083243.917"><vh>auto getPartialArg</vh></v>
<v t="ekr.20230509083243.918"><vh>// Handle reordered arguments</vh></v>
<v t="ekr.20230509083243.919"><vh>auto reorderFn</vh>
<v t="ekr.20230509083243.920"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.921"><vh>// Reorder arguments if needed</vh></v>
<v t="ekr.20230509083243.922"><vh>bool TypecheckVisitor::typecheckCallArgs</vh></v>
<v t="ekr.20230509083243.923"><vh>/// Transform and typecheck the following special call expressions:</vh></v>
<v t="ekr.20230509083243.924"><vh>auto m</vh></v>
<v t="ekr.20230509083243.925"><vh>/// Typecheck __ptr__ method. This method creates a pointer to an object. Ensure that</vh></v>
<v t="ekr.20230509083243.926"><vh>auto member</vh>
<v t="ekr.20230509083243.927"><vh>auto kwCls</vh></v>
</v>
<v t="ekr.20230509083243.928"><vh>bool exists</vh></v>
<v t="ekr.20230509083243.929"><vh>/// Transform setattr method to a AssignMemberStmt.</vh></v>
<v t="ekr.20230509083243.930"><vh>static Typ</vh></v>
<v t="ekr.20230509083243.931"><vh>/// Convert a class to a tuple.</vh></v>
<v t="ekr.20230509083243.932"><vh>auto call</vh></v>
<v t="ekr.20230509083243.933"><vh>return nullptr</vh></v>
<v t="ekr.20230509083243.934"><vh>void TypecheckVisitor::addFunctionGenerics</vh></v>
</v>
<v t="ekr.20230509083243.935"><vh>@@clean class.cpp</vh>
<v t="ekr.20230509083243.936"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.937"><vh>auto typ</vh></v>
</v>
<v t="ekr.20230509083243.938"><vh>/// Generate a tuple class `Tuple.N[T1,...,TN]`.</vh></v>
<v t="ekr.20230509083243.939"><vh>bool hasSuffix</vh>
<v t="ekr.20230509083243.940"><vh>auto getItem</vh></v>
</v>
</v>
<v t="ekr.20230509083243.941"><vh>@@clean collections.cpp</vh>
<v t="ekr.20230509083243.942"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.943"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.944"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.945"><vh>/// Transform a collection of type `type` to a statement expression:</vh></v>
<v t="ekr.20230509083243.946"><vh>const std::string</vh>
<v t="ekr.20230509083243.947"><vh>auto superTyp</vh>
<v t="ekr.20230509083243.948"><vh>const ClassTypePtr</vh></v>
</v>
</v>
<v t="ekr.20230509083243.949"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.950"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.951"><vh>auto suiteVec</vh></v>
</v>
</v>
<v t="ekr.20230509083243.952"><vh>@@clean cond.cpp</vh>
<v t="ekr.20230509083243.953"><vh>template &lt;typename TT, typename TF&gt;</vh>
<v t="ekr.20230509083243.954"><vh>auto evaluateStaticCondition</vh></v>
</v>
<v t="ekr.20230509083243.955"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.956"><vh>void TypecheckVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.957"><vh>@@clean ctx.cpp</vh>
<v t="ekr.20230509083243.958"><vh>const std::string</vh></v>
<v t="ekr.20230509083243.959"><vh>std::shared_ptr&lt;TypecheckItem&gt; TypeContext::find</vh></v>
<v t="ekr.20230509083243.960"><vh>int level</vh></v>
<v t="ekr.20230509083243.961"><vh>auto typ</vh></v>
<v t="ekr.20230509083243.962"><vh>std::shared_ptr&lt;types::LinkType&gt; TypeContext::getUnbound</vh></v>
<v t="ekr.20230509083243.963"><vh>const types::TypePtr</vh>
<v t="ekr.20230509083243.964"><vh>const types::ClassTypePtr</vh></v>
</v>
<v t="ekr.20230509083243.965"><vh>types::TypePtr</vh></v>
<v t="ekr.20230509083243.966"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.967"><vh>std::vector&lt;types::FuncTypePtr&gt; TypeContext::findMethod</vh></v>
<v t="ekr.20230509083243.968"><vh>const std::string</vh>
<v t="ekr.20230509083243.969"><vh>bool hideShadowed</vh>
<v t="ekr.20230509083243.970"><vh>auto populate</vh></v>
</v>
</v>
<v t="ekr.20230509083243.971"><vh>types::TypePtr TypeContext::findMember</vh></v>
<v t="ekr.20230509083243.972"><vh>const std::string</vh></v>
<v t="ekr.20230509083243.973"><vh>int TypeContext::reorderNamedArgs</vh>
<v t="ekr.20230509083243.974"><vh>const std::vector</vh>
<v t="ekr.20230509083243.975"><vh>const ReorderDoneFn</vh>
<v t="ekr.20230509083243.976"><vh>const ReorderErrorFn</vh>
<v t="ekr.20230509083243.977"><vh>const std::vector</vh>
<v t="ekr.20230509083243.978"><vh>bool partial</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509083243.979"><vh>void TypeContext::dump</vh>
<v t="ekr.20230509083243.980"><vh>auto ordered</vh></v>
</v>
<v t="ekr.20230509083243.981"><vh>std::string TypeContext::debugInfo</vh></v>
<v t="ekr.20230509083243.982"><vh>auto ret</vh></v>
</v>
<v t="ekr.20230509083243.983"><vh>@@clean ctx.h</vh>
<v t="ekr.20230509083243.984"><vh>const types::ClassTypePtr</vh></v>
<v t="ekr.20230509083243.985"><vh>/// Instantiate the generic type root with the provided generics.</vh></v>
<v t="ekr.20230509083243.986"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.987"><vh>@@clean error.cpp</vh>
<v t="ekr.20230509083243.988"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.989"><vh>void TypecheckVisitor::visit</vh></v>
</v>
<v t="ekr.20230509083243.990"><vh>@@clean function.cpp</vh>
<v t="ekr.20230509083243.991"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.992"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.993"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.994"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.995"><vh>auto funcTyp</vh></v>
<v t="ekr.20230509083243.996"><vh>funcTyp</vh></v>
<v t="ekr.20230509083243.997"><vh>auto m</vh></v>
</v>
</v>
<v t="ekr.20230509083243.998"><vh>@@clean infer.cpp</vh>
<v t="ekr.20230509083243.999"><vh>auto realization</vh></v>
<v t="ekr.20230509083243.1000"><vh>// Create LLVM stub</vh></v>
<v t="ekr.20230509083243.1001"><vh>auto sig</vh></v>
<v t="ekr.20230509083243.1002"><vh>// Set up the base class information</vh></v>
<v t="ekr.20230509083243.1003"><vh>auto ct</vh></v>
<v t="ekr.20230509083243.1004"><vh>std::vector&lt;std::string&gt; ns</vh></v>
<v t="ekr.20230509083243.1005"><vh>auto forceFindIRType</vh></v>
<v t="ekr.20230509083243.1006"><vh>// Prepare generics and statics</vh></v>
<v t="ekr.20230509083243.1007"><vh>const std::shared_ptr</vh></v>
<v t="ekr.20230509083243.1008"><vh>auto irType</vh>
<v t="ekr.20230509083243.1009"><vh>auto ast</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1010"><vh>@@clean loops.cpp</vh>
<v t="ekr.20230509083243.1011"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1012"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1013"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1014"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.1015"><vh>bool maybeHeterogenous</vh></v>
</v>
<v t="ekr.20230509083243.1016"><vh>/// Handle heterogeneous tuple iteration.</vh></v>
<v t="ekr.20230509083243.1017"><vh>auto loop</vh></v>
<v t="ekr.20230509083243.1018"><vh>// Close the loop</vh></v>
<v t="ekr.20230509083243.1019"><vh>auto loop</vh>
<v t="ekr.20230509083243.1020"><vh>const std::vector</vh>
<v t="ekr.20230509083243.1021"><vh>int st</vh>
<v t="ekr.20230509083243.1022"><vh>int ed</vh>
<v t="ekr.20230509083243.1023"><vh>int step</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1024"><vh>} else if</vh></v>
<v t="ekr.20230509083243.1025"><vh>int ed</vh></v>
<v t="ekr.20230509083243.1026"><vh>} else if</vh></v>
<v t="ekr.20230509083243.1027"><vh>auto b</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1028"><vh>@@clean op.cpp</vh>
<v t="ekr.20230509083243.1029"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.1030"><vh>static std::unordered_map</vh></v>
</v>
<v t="ekr.20230509083243.1031"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.1032"><vh>static std::unordered_map</vh></v>
</v>
<v t="ekr.20230509083243.1033"><vh>/// Helper function that locates the pipe ellipsis within a collection of</vh></v>
<v t="ekr.20230509083243.1034"><vh>void TypecheckVisitor::visit</vh>
<v t="ekr.20230509083243.1035"><vh>auto getIterableType</vh></v>
</v>
<v t="ekr.20230509083243.1036"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1037"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1038"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1039"><vh>/// Evaluate a static unary expression and return the resulting static expression.</vh></v>
<v t="ekr.20230509083243.1040"><vh>auto magics</vh></v>
<v t="ekr.20230509083243.1041"><vh>auto mi</vh></v>
<v t="ekr.20230509083243.1042"><vh>auto rightMagics</vh></v>
<v t="ekr.20230509083243.1043"><vh>auto rm</vh></v>
<v t="ekr.20230509083243.1044"><vh>const ExprPtr</vh>
<v t="ekr.20230509083243.1045"><vh>auto getInt</vh></v>
</v>
<v t="ekr.20230509083243.1046"><vh>int 64_t</vh></v>
<v t="ekr.20230509083243.1047"><vh>int 64_t</vh>
<v t="ekr.20230509083243.1048"><vh>int 64_t</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1049"><vh>@@clean typecheck.cpp</vh>
<v t="ekr.20230509083243.1050"><vh>const std::shared_ptr</vh></v>
<v t="ekr.20230509083243.1051"><vh>/**************************************************************************************/</vh></v>
<v t="ekr.20230509083243.1052"><vh>void TypecheckVisitor::defaultVisit</vh></v>
<v t="ekr.20230509083243.1053"><vh>/// Transform a statement node.</vh></v>
<v t="ekr.20230509083243.1054"><vh>void TypecheckVisitor::defaultVisit</vh></v>
<v t="ekr.20230509083243.1055"><vh>/**************************************************************************************/</vh></v>
<v t="ekr.20230509083243.1056"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1057"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1058"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1059"><vh>void TypecheckVisitor::visit</vh></v>
<v t="ekr.20230509083243.1060"><vh>const std::vector</vh></v>
<v t="ekr.20230509083243.1061"><vh>/// Select the best method indicated of an object that matches the given argument</vh></v>
<v t="ekr.20230509083243.1062"><vh>const std::string</vh>
<v t="ekr.20230509083243.1063"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.1064"><vh>/// Select the best method indicated of an object that matches the given argument</vh></v>
<v t="ekr.20230509083243.1065"><vh>const ClassTypePtr</vh>
<v t="ekr.20230509083243.1066"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.1067"><vh>class IdSearchVisitor</vh>
<v t="ekr.20230509083243.1068"><vh>IdSearchVisitor.bool transform</vh></v>
<v t="ekr.20230509083243.1069"><vh>IdSearchVisitor.bool transform</vh></v>
<v t="ekr.20230509083243.1070"><vh>IdSearchVisitor.void visit</vh></v>
</v>
<v t="ekr.20230509083243.1071"><vh>int TypecheckVisitor::canCall</vh>
<v t="ekr.20230509083243.1072"><vh>const std::vector</vh>
<v t="ekr.20230509083243.1073"><vh>auto score</vh></v>
<v t="ekr.20230509083243.1074"><vh>[]</vh></v>
<v t="ekr.20230509083243.1075"><vh>auto expectTyp</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1076"><vh>/// Select the best method among the provided methods given the list of arguments.</vh></v>
<v t="ekr.20230509083243.1077"><vh>const std::vector</vh>
<v t="ekr.20230509083243.1078"><vh>const std::vector</vh></v>
</v>
<v t="ekr.20230509083243.1079"><vh>bool TypecheckVisitor::wrapExpr</vh>
<v t="ekr.20230509083243.1080"><vh>const FuncTypePtr</vh>
<v t="ekr.20230509083243.1081"><vh>auto doArgWrap</vh>
<v t="ekr.20230509083243.1082"><vh>auto doTypeWrap</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1083"><vh>/// Cast derived class to a base class.</vh></v>
<v t="ekr.20230509083243.1084"><vh>bool isVirtual</vh></v>
</v>
<v t="ekr.20230509083243.1085"><vh>@@clean typecheck.h</vh>
<v t="ekr.20230509083243.1086"><vh>class TypecheckVisitor</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1087"><vh>@path runtime</vh>
<v t="ekr.20230509083243.1088"><vh>@@clean exc.cpp</vh>
<v t="ekr.20230509083243.1089"><vh>void push_back</vh>
<v t="ekr.20230509083243.1090"><vh>int 32_t</vh></v>
</v>
<v t="ekr.20230509083243.1091"><vh>void push_back</vh></v>
<v t="ekr.20230509083243.1092"><vh>void free</vh></v>
<v t="ekr.20230509083243.1093"><vh>}</vh></v>
<v t="ekr.20230509083243.1094"><vh>void seq_backtrace_error_callback</vh></v>
<v t="ekr.20230509083243.1095"><vh>int seq_backtrace_full_callback</vh></v>
<v t="ekr.20230509083243.1096"><vh>int seq_backtrace_simple_callback</vh></v>
<v t="ekr.20230509083243.1097"><vh>/*</vh></v>
<v t="ekr.20230509083243.1098"><vh>char ourBaseExcpClassChars</vh>
<v t="ekr.20230509083243.1099"><vh>static uint64_t</vh></v>
</v>
<v t="ekr.20230509083243.1100"><vh>static uint64_t ourBaseExceptionClass</vh></v>
<v t="ekr.20230509083243.1101"><vh>void seq_exc_init</vh></v>
<v t="ekr.20230509083243.1102"><vh>void seq_delete_exc</vh></v>
<v t="ekr.20230509083243.1103"><vh>void seq_delete_unwind_exc</vh></v>
<v t="ekr.20230509083243.1104"><vh>static struct backtrace_state *state</vh></v>
<v t="ekr.20230509083243.1105"><vh>void print_from_last_dot</vh></v>
<v t="ekr.20230509083243.1106"><vh>static std::function&lt;void</vh></v>
<v t="ekr.20230509083243.1107"><vh>static uintptr_t</vh></v>
<v t="ekr.20230509083243.1108"><vh>static uintptr_t</vh></v>
<v t="ekr.20230509083243.1109"><vh>unsigned getEncodingSize</vh></v>
<v t="ekr.20230509083243.1110"><vh>static uintptr_t</vh></v>
<v t="ekr.20230509083243.1111"><vh>bool handleActionValue</vh>
<v t="ekr.20230509083243.1112"><vh>const uint8_t</vh></v>
</v>
<v t="ekr.20230509083243.1113"><vh>static _Unwind_Reason_Code</vh></v>
<v t="ekr.20230509083243.1114"><vh>SEQ_FUNC _Unwind_Reason_Code seq_personality</vh></v>
<v t="ekr.20230509083243.1115"><vh>const std::string</vh>
<v t="ekr.20230509083243.1116"><vh>const std::string</vh>
<v t="ekr.20230509083243.1117"><vh>int col</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1118"><vh>void codon::runtime::setJITErrorCallback</vh></v>
</v>
<v t="ekr.20230509083243.1119"><vh>@@clean gpu.cpp</vh>
<v t="ekr.20230509083243.1120"><vh>void seq_nvptx_init</vh></v>
<v t="ekr.20230509083243.1121"><vh>SEQ_FUNC void seq_nvptx_load_module</vh></v>
<v t="ekr.20230509083243.1122"><vh>bool name_char_valid</vh></v>
<v t="ekr.20230509083243.1123"><vh>SEQ_FUNC CUfunction seq_nvptx_function</vh></v>
<v t="ekr.20230509083243.1124"><vh>int gridDimY</vh></v>
</v>
<v t="ekr.20230509083243.1125"><vh>@@clean lib.cpp</vh>
<v t="ekr.20230509083243.1126"><vh>void copy_time_c_to_seq</vh></v>
<v t="ekr.20230509083243.1127"><vh>void copy_time_seq_to_c</vh></v>
<v t="ekr.20230509083243.1128"><vh>SEQ_FUNC bool seq_localtime</vh></v>
<v t="ekr.20230509083243.1129"><vh>static seq_str_t</vh></v>
</v>
<v t="ekr.20230509083243.1130"><vh>@@clean lib.h</vh>
<v t="ekr.20230509083243.1131"><vh>class JITError</vh></v>
</v>
<v t="ekr.20230509083243.1132"><vh>@@clean re.cpp</vh>
<v t="ekr.20230509083243.1133"><vh>static inline</vh></v>
<v t="ekr.20230509083243.1134"><vh>/*</vh></v>
<v t="ekr.20230509083243.1135"><vh>template &lt;typename KV1&gt;</vh></v>
<v t="ekr.20230509083243.1136"><vh>}</vh></v>
<v t="ekr.20230509083243.1137"><vh>static inline</vh></v>
<v t="ekr.20230509083243.1138"><vh>static inline</vh></v>
<v t="ekr.20230509083243.1139"><vh>using Key</vh></v>
<v t="ekr.20230509083243.1140"><vh>bool operator</vh></v>
<v t="ekr.20230509083243.1141"><vh>}</vh></v>
<v t="ekr.20230509083243.1142"><vh>static thread_local</vh>
<v t="ekr.20230509083243.1143"><vh>static inline</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1144"><vh>@path util</vh>
<v t="ekr.20230509083243.1145"><vh>@@clean common.cpp</vh>
<v t="ekr.20230509083243.1146"><vh>void compilationMessage</vh>
<v t="ekr.20230509083243.1147"><vh>const std::string</vh>
<v t="ekr.20230509083243.1148"><vh>int errorCode</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1149"><vh>std::vector&lt;Logger&gt; loggers</vh></v>
<v t="ekr.20230509083243.1150"><vh>void compilationError</vh></v>
<v t="ekr.20230509083243.1151"><vh>void compilationWarning</vh></v>
<v t="ekr.20230509083243.1152"><vh>void Logger::parse</vh></v>
<v t="ekr.20230509083243.1153"><vh>} // namespace codon</vh></v>
<v t="ekr.20230509083243.1154"><vh>bool codon::popLogger</vh></v>
<v t="ekr.20230509083243.1155"><vh>void codon::assertionFailure</vh></v>
</v>
<v t="ekr.20230509083243.1156"><vh>@@clean common.h</vh>
<v t="ekr.20230509083243.1157"><vh>void assertionFailure</vh></v>
<v t="ekr.20230509083243.1158"><vh>Logger &amp;getLogger</vh></v>
<v t="ekr.20230509083243.1159"><vh>class Timer</vh>
<v t="ekr.20230509083243.1160"><vh>Timer.void log</vh></v>
<v t="ekr.20230509083243.1161"><vh>Timer.double elapsed</vh></v>
</v>
<v t="ekr.20230509083243.1162"><vh>std::ostream &amp;operator&lt;&lt;</vh></v>
<v t="ekr.20230509083243.1163"><vh>template &lt;class... TA&gt;</vh></v>
<v t="ekr.20230509083243.1164"><vh>template &lt;class... TA&gt;</vh></v>
</v>
<v t="ekr.20230509083243.1165"><vh>@@clean jupyter.cpp</vh>
<v t="ekr.20230509083243.1166"><vh>int startJupyterKernel</vh></v>
</v>
<v t="ekr.20230509083243.1167"><vh>@@clean jupyter.h</vh></v>
<v t="ekr.20230509083243.1168"><vh>@@clean peg2cpp.cpp</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1169"><vh>@path docs</vh>
<v t="ekr.20230509083243.1170"><vh>@@clean docgen.py</vh>
<v t="ekr.20230509083243.1171"><vh>load_json</vh></v>
<v t="ekr.20230509083243.1172"><vh>j=load_json(root)</vh></v>
<v t="ekr.20230509083243.1173"><vh>parse_docstr</vh></v>
<v t="ekr.20230509083243.1174"><vh>parse_type</vh></v>
<v t="ekr.20230509083243.1175"><vh>parse_fn</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1181"><vh>@path extra</vh>
<v t="ekr.20230509083243.1182"><vh>@path python</vh>
<v t="ekr.20230509083243.1183"><vh>@@clean setup.py</vh></v>
<v t="ekr.20230509083243.1184"><vh>@path codon</vh>
<v t="ekr.20230509083243.1185"><vh>@@clean decorator.py</vh>
<v t="ekr.20230509083243.1186"><vh>_common_type</vh></v>
<v t="ekr.20230509083243.1187"><vh>_codon_type</vh></v>
<v t="ekr.20230509083243.1188"><vh>_codon_types</vh></v>
<v t="ekr.20230509083243.1189"><vh>_reset_jit</vh></v>
<v t="ekr.20230509083243.1190"><vh>_jit = _reset_jit()</vh></v>
<v t="ekr.20230509083243.1191"><vh>class RewriteFunctionArgs</vh>
<v t="ekr.20230509083243.1192"><vh>RewriteFunctionArgs.__init__</vh></v>
<v t="ekr.20230509083243.1193"><vh>RewriteFunctionArgs.visit_FunctionDef</vh></v>
</v>
<v t="ekr.20230509083243.1194"><vh>_obj_to_str</vh></v>
<v t="ekr.20230509083243.1195"><vh>_obj_name</vh></v>
<v t="ekr.20230509083243.1196"><vh>_parse_decorated</vh></v>
<v t="ekr.20230509083243.1197"><vh>convert</vh></v>
<v t="ekr.20230509083243.1198"><vh>jit</vh>
<v t="ekr.20230509083243.1199"><vh>_decorate</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1200"><vh>@@clean __init__.py</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1201"><vh>@path jupyter</vh>
<v t="ekr.20230509083243.1202"><vh>@@clean jupyter.cpp</vh>
<v t="ekr.20230509083243.1203"><vh>const std::vector</vh>
<v t="ekr.20230509083243.1204"><vh>bool silent</vh>
<v t="ekr.20230509083243.1205"><vh>bool allow_stdin</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1206"><vh>void CodonJupyter::configure_impl</vh></v>
<v t="ekr.20230509083243.1207"><vh>nl::json CodonJupyter::complete_request_impl</vh></v>
<v t="ekr.20230509083243.1208"><vh>int detail_level</vh></v>
<v t="ekr.20230509083243.1209"><vh>nl::json CodonJupyter::is_complete_request_impl</vh></v>
<v t="ekr.20230509083243.1210"><vh>void CodonJupyter::shutdown_request_impl</vh>
<v t="ekr.20230509083243.1211"><vh>int startJupyterKernel</vh>
<v t="ekr.20230509083243.1212"><vh>const std::vector</vh>
<v t="ekr.20230509083243.1213"><vh>const std::string</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1214"><vh>@@clean jupyter.h</vh>
<v t="ekr.20230509083243.1215"><vh>class CodonJupyter</vh></v>
</v>
<v t="ekr.20230509083243.1216"><vh>@path share</vh>
<v t="ekr.20230509083243.1217"><vh>@path jupyter</vh>
<v t="ekr.20230509083243.1218"><vh>@path kernels</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1221"><vh>@path stdlib</vh>
<v t="ekr.20230509083243.1222"><vh>@@clean bisect.codon</vh></v>
<v t="ekr.20230509083243.1223"><vh>@@clean cmath.codon</vh></v>
<v t="ekr.20230509083243.1224"><vh>@@clean collections.codon</vh></v>
<v t="ekr.20230509083243.1225"><vh>@@clean copy.codon</vh></v>
<v t="ekr.20230509083243.1226"><vh>@@clean datetime.codon</vh></v>
<v t="ekr.20230509083243.1227"><vh>@@clean functools.codon</vh></v>
<v t="ekr.20230509083243.1228"><vh>@@clean getopt.codon</vh></v>
<v t="ekr.20230509083243.1229"><vh>@@clean gpu.codon</vh></v>
<v t="ekr.20230509083243.1230"><vh>@@clean gzip.codon</vh></v>
<v t="ekr.20230509083243.1231"><vh>@@clean heapq.codon</vh></v>
<v t="ekr.20230509083243.1232"><vh>@@clean itertools.codon</vh></v>
<v t="ekr.20230509083243.1233"><vh>@@clean math.codon</vh></v>
<v t="ekr.20230509083243.1234"><vh>@@clean openmp.codon</vh></v>
<v t="ekr.20230509083243.1235"><vh>@@clean operator.codon</vh></v>
<v t="ekr.20230509083243.1236"><vh>@@clean pickle.codon</vh></v>
<v t="ekr.20230509083243.1237"><vh>@@clean python.codon</vh></v>
<v t="ekr.20230509083243.1238"><vh>@@clean random.codon</vh></v>
<v t="ekr.20230509083243.1239"><vh>@@clean re.codon</vh></v>
<v t="ekr.20230509083243.1240"><vh>@@clean sortedlist.codon</vh></v>
<v t="ekr.20230509083243.1241"><vh>@@clean statistics.codon</vh></v>
<v t="ekr.20230509083243.1242"><vh>@@clean string.codon</vh></v>
<v t="ekr.20230509083243.1243"><vh>@@clean sys.codon</vh></v>
<v t="ekr.20230509083243.1244"><vh>@@clean threading.codon</vh></v>
<v t="ekr.20230509083243.1245"><vh>@@clean time.codon</vh></v>
<v t="ekr.20230509083243.1246"><vh>@@clean typing.codon</vh></v>
<v t="ekr.20230509083243.1247"><vh>@@clean unittest.codon</vh></v>
<v t="ekr.20230509083243.1248"><vh>@path algorithms</vh>
<v t="ekr.20230509083243.1249"><vh>@@clean heapsort.codon</vh></v>
<v t="ekr.20230509083243.1250"><vh>@@clean insertionsort.codon</vh></v>
<v t="ekr.20230509083243.1251"><vh>@@clean pdqsort.codon</vh></v>
<v t="ekr.20230509083243.1252"><vh>@@clean qsort.codon</vh></v>
<v t="ekr.20230509083243.1253"><vh>@@clean strings.codon</vh></v>
<v t="ekr.20230509083243.1254"><vh>@@clean timsort.codon</vh></v>
</v>
<v t="ekr.20230509083243.1255"><vh>@path experimental</vh>
<v t="ekr.20230509083243.1256"><vh>@@clean simd.codon</vh></v>
</v>
<v t="ekr.20230509083243.1257"><vh>@path internal</vh>
<v t="ekr.20230509083243.1258"><vh>@@clean attributes.codon</vh></v>
<v t="ekr.20230509083243.1259"><vh>@@clean builtin.codon</vh></v>
<v t="ekr.20230509083243.1260"><vh>@@clean core.codon</vh></v>
<v t="ekr.20230509083243.1261"><vh>@@clean c_stubs.codon</vh></v>
<v t="ekr.20230509083243.1262"><vh>@@clean dlopen.codon</vh></v>
<v t="ekr.20230509083243.1263"><vh>@@clean file.codon</vh></v>
<v t="ekr.20230509083243.1264"><vh>@@clean format.codon</vh></v>
<v t="ekr.20230509083243.1265"><vh>@@clean gc.codon</vh></v>
<v t="ekr.20230509083243.1266"><vh>@@clean internal.codon</vh></v>
<v t="ekr.20230509083243.1267"><vh>@@clean khash.codon</vh></v>
<v t="ekr.20230509083243.1268"><vh>@@clean pynumerics.codon</vh></v>
<v t="ekr.20230509083243.1269"><vh>@@clean python.codon</vh></v>
<v t="ekr.20230509083243.1270"><vh>@@clean sort.codon</vh></v>
<v t="ekr.20230509083243.1271"><vh>@@clean static.codon</vh></v>
<v t="ekr.20230509083243.1272"><vh>@@clean str.codon</vh></v>
<v t="ekr.20230509083243.1273"><vh>@@clean __init_test__.codon</vh></v>
<v t="ekr.20230509083243.1274"><vh>@@clean __init__.codon</vh></v>
<v t="ekr.20230509083243.1275"><vh>@path types</vh>
<v t="ekr.20230509083243.1276"><vh>@@clean array.codon</vh></v>
<v t="ekr.20230509083243.1277"><vh>@@clean bool.codon</vh></v>
<v t="ekr.20230509083243.1278"><vh>@@clean byte.codon</vh></v>
<v t="ekr.20230509083243.1279"><vh>@@clean complex.codon</vh></v>
<v t="ekr.20230509083243.1280"><vh>@@clean error.codon</vh></v>
<v t="ekr.20230509083243.1281"><vh>@@clean float.codon</vh></v>
<v t="ekr.20230509083243.1282"><vh>@@clean generator.codon</vh></v>
<v t="ekr.20230509083243.1283"><vh>@@clean int.codon</vh></v>
<v t="ekr.20230509083243.1284"><vh>@@clean intn.codon</vh></v>
<v t="ekr.20230509083243.1285"><vh>@@clean optional.codon</vh></v>
<v t="ekr.20230509083243.1286"><vh>@@clean ptr.codon</vh></v>
<v t="ekr.20230509083243.1287"><vh>@@clean range.codon</vh></v>
<v t="ekr.20230509083243.1288"><vh>@@clean slice.codon</vh></v>
<v t="ekr.20230509083243.1289"><vh>@@clean str.codon</vh></v>
<v t="ekr.20230509083243.1290"><vh>@@clean strbuf.codon</vh></v>
<v t="ekr.20230509083243.1291"><vh>@path collections</vh>
<v t="ekr.20230509083243.1292"><vh>@@clean dict.codon</vh></v>
<v t="ekr.20230509083243.1293"><vh>@@clean list.codon</vh></v>
<v t="ekr.20230509083243.1294"><vh>@@clean set.codon</vh></v>
<v t="ekr.20230509083243.1295"><vh>@@clean tuple.codon</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083243.1296"><vh>@path os</vh>
<v t="ekr.20230509083243.1297"><vh>@@clean path.codon</vh></v>
<v t="ekr.20230509083243.1298"><vh>@@clean __init__.codon</vh></v>
</v>
</v>
<v t="ekr.20230509083243.1299"><vh>@path test</vh>
<v t="ekr.20230509083243.1300"><vh>@@clean main.cpp</vh>
<v t="ekr.20230509083244.1"><vh>class TestOutliner</vh>
<v t="ekr.20230509083244.2"><vh>TestOutliner.void handle</vh></v>
<v t="ekr.20230509083244.3"><vh>TestOutliner.auto result</vh>
<v t="ekr.20230509083244.4"><vh>TestOutliner.void handle</vh></v>
</v>
</v>
<v t="ekr.20230509083244.5"><vh>class TestInliner</vh>
<v t="ekr.20230509083244.6"><vh>TestInliner.void handle</vh></v>
</v>
<v t="ekr.20230509083244.7"><vh>struct PartitionArgsByEscape : public ir::util::Operator</vh></v>
<v t="ekr.20230509083244.8"><vh>void handle</vh></v>
<v t="ekr.20230509083244.9"><vh>}</vh></v>
<v t="ekr.20230509083244.10"><vh>void run</vh></v>
<v t="ekr.20230509083244.11"><vh>bool good</vh></v>
<v t="ekr.20230509083244.12"><vh>static pair</vh></v>
<v t="ekr.20230509083244.13"><vh>static pair</vh></v>
<v t="ekr.20230509083244.14"><vh>string argv0</vh></v>
<v t="ekr.20230509083244.15"><vh>class SeqTest</vh>
<v t="ekr.20230509083244.16"><vh>SeqTest.int runInChildProcess</vh>
<v t="ekr.20230509083244.17"><vh>SeqTest.auto compiler</vh></v>
<v t="ekr.20230509083244.18"><vh>SeqTest.auto *pm</vh></v>
<v t="ekr.20230509083244.19"><vh>SeqTest.auto capKey</vh></v>
</v>
</v>
<v t="ekr.20230509083244.20"><vh>static string</vh></v>
<v t="ekr.20230509083244.21"><vh>static string</vh></v>
<v t="ekr.20230509083244.22"><vh>TEST_P</vh></v>
<v t="ekr.20230509083244.23"><vh>auto getTypeTests</vh></v>
<v t="ekr.20230509083244.24"><vh>// clang-format off</vh></v>
<v t="ekr.20230509083244.25"><vh>int main</vh></v>
</v>
<v t="ekr.20230509083244.26"><vh>@@clean types.cpp</vh></v>
<v t="ekr.20230509083244.27"><vh>@path app</vh>
<v t="ekr.20230509083244.28"><vh>@@clean argv.codon</vh></v>
<v t="ekr.20230509083244.29"><vh>@@clean build.codon</vh></v>
<v t="ekr.20230509083244.30"><vh>@@clean exit.codon</vh></v>
<v t="ekr.20230509083244.31"><vh>@@clean export.codon</vh></v>
<v t="ekr.20230509083244.32"><vh>@@clean test.c</vh></v>
</v>
<v t="ekr.20230509083244.33"><vh>@path cir</vh>
<v t="ekr.20230509083244.34"><vh>@@clean base.cpp</vh>
<v t="ekr.20230509083244.35"><vh>class TestVisitor</vh></v>
<v t="ekr.20230509083244.36"><vh>void visit</vh></v>
<v t="ekr.20230509083244.37"><vh>void visit</vh></v>
</v>
<v t="ekr.20230509083244.38"><vh>@@clean constant.cpp</vh></v>
<v t="ekr.20230509083244.39"><vh>@@clean flow.cpp</vh></v>
<v t="ekr.20230509083244.40"><vh>@@clean func.cpp</vh></v>
<v t="ekr.20230509083244.41"><vh>@@clean instr.cpp</vh></v>
<v t="ekr.20230509083244.42"><vh>@@clean module.cpp</vh></v>
<v t="ekr.20230509083244.43"><vh>@@clean test.h</vh>
<v t="ekr.20230509083244.44"><vh>class CIRCoreTest</vh>
<v t="ekr.20230509083244.45"><vh>CIRCoreTest.void SetUp</vh></v>
</v>
</v>
<v t="ekr.20230509083244.46"><vh>@@clean value.cpp</vh></v>
<v t="ekr.20230509083244.47"><vh>@@clean var.cpp</vh></v>
<v t="ekr.20230509083244.48"><vh>@path analyze</vh>
<v t="ekr.20230509083244.49"><vh>@@clean dominator.cpp</vh></v>
<v t="ekr.20230509083244.50"><vh>@@clean reaching.cpp</vh></v>
</v>
<v t="ekr.20230509083244.51"><vh>@path transform</vh>
<v t="ekr.20230509083244.52"><vh>@@clean manager.cpp</vh>
<v t="ekr.20230509083244.53"><vh>class DummyAnalysis</vh></v>
<v t="ekr.20230509083244.54"><vh>int DummyAnalysis::runCounter</vh></v>
<v t="ekr.20230509083244.55"><vh>class DummyPass</vh>
<v t="ekr.20230509083244.56"><vh>DummyPass.void run</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083244.57"><vh>@path types</vh>
<v t="ekr.20230509083244.58"><vh>@@clean types.cpp</vh></v>
</v>
<v t="ekr.20230509083244.59"><vh>@path util</vh>
<v t="ekr.20230509083244.60"><vh>@@clean matching.cpp</vh></v>
</v>
</v>
<v t="ekr.20230509083244.61"><vh>@path core</vh>
<v t="ekr.20230509083244.62"><vh>@@clean arguments.codon</vh></v>
<v t="ekr.20230509083244.63"><vh>@@clean arithmetic.codon</vh></v>
<v t="ekr.20230509083244.64"><vh>@@clean bltin.codon</vh></v>
<v t="ekr.20230509083244.65"><vh>@@clean containers.codon</vh></v>
<v t="ekr.20230509083244.67"><vh>@@clean exceptions.codon</vh></v>
<v t="ekr.20230509083244.68"><vh>@@clean generators.codon</vh></v>
<v t="ekr.20230509083244.69"><vh>@@clean generics.codon</vh></v>
<v t="ekr.20230509083244.70"><vh>@@clean helloworld.codon</vh></v>
<v t="ekr.20230509083244.71"><vh>@@clean llvmops.codon</vh></v>
<v t="ekr.20230509083244.72"><vh>@@clean match.codon</vh></v>
<v t="ekr.20230509083244.73"><vh>@@clean numerics.codon</vh></v>
<v t="ekr.20230509083244.74"><vh>@@clean parser.codon</vh></v>
<v t="ekr.20230509083244.75"><vh>@@clean pipeline.codon</vh></v>
<v t="ekr.20230509083244.76"><vh>@@clean range.codon</vh></v>
<v t="ekr.20230509083244.77"><vh>@@clean serialization.codon</vh></v>
<v t="ekr.20230509083244.78"><vh>@@clean sort.codon</vh></v>
<v t="ekr.20230509083244.79"><vh>@@clean trees.codon</vh></v>
</v>
<v t="ekr.20230509083244.80"><vh>@path parser</vh>
<v t="ekr.20230509083244.81"><vh>@@clean llvm.codon</vh></v>
<v t="ekr.20230509083244.82"><vh>@@clean simplify_expr.codon</vh></v>
<v t="ekr.20230509083244.83"><vh>@@clean simplify_stmt.codon</vh></v>
<v t="ekr.20230509083244.84"><vh>@@clean typecheck_expr.codon</vh></v>
<v t="ekr.20230509083244.85"><vh>@@clean typecheck_stmt.codon</vh></v>
<v t="ekr.20230509083244.86"><vh>@@clean types.codon</vh></v>
<v t="ekr.20230509083244.87"><vh>@path a</vh>
<v t="ekr.20230509083244.88"><vh>@@clean __init__.codon</vh></v>
<v t="ekr.20230509083244.89"><vh>@path b</vh>
<v t="ekr.20230509083244.90"><vh>@@clean rec1.codon</vh></v>
<v t="ekr.20230509083244.91"><vh>@@clean rec1_err.codon</vh></v>
<v t="ekr.20230509083244.92"><vh>@@clean rec2.codon</vh></v>
<v t="ekr.20230509083244.93"><vh>@@clean rec2_err.codon</vh></v>
<v t="ekr.20230509083244.94"><vh>@@clean __init__.codon</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083244.95"><vh>@path python</vh>
<v t="ekr.20230509083244.96"><vh>@@clean cython_jit.py</vh>
<v t="ekr.20230509083244.97"><vh>class Foo</vh>
<v t="ekr.20230509083244.98"><vh>Foo.__init__</vh></v>
<v t="ekr.20230509083244.99"><vh>Foo.__eq__</vh></v>
<v t="ekr.20230509083244.100"><vh>Foo.__hash__</vh></v>
<v t="ekr.20230509083244.101"><vh>Foo.total</vh></v>
</v>
<v t="ekr.20230509083244.102"><vh>test_convertible</vh></v>
<v t="ekr.20230509083244.103"><vh>test_many</vh>
<v t="ekr.20230509083244.104"><vh>is_prime</vh></v>
</v>
<v t="ekr.20230509083244.105"><vh>test_roundtrip</vh>
<v t="ekr.20230509083244.106"><vh>roundtrip</vh></v>
</v>
<v t="ekr.20230509083244.107"><vh>test_return_type</vh>
<v t="ekr.20230509083244.108"><vh>run</vh></v>
</v>
<v t="ekr.20230509083244.109"><vh>test_param_types</vh>
<v t="ekr.20230509083244.110"><vh>run</vh></v>
</v>
<v t="ekr.20230509083244.111"><vh>test_error_handling</vh>
<v t="ekr.20230509083244.112"><vh>type_error</vh></v>
</v>
<v t="ekr.20230509083244.113"><vh>test_convertible()</vh></v>
<v t="ekr.20230509083244.114"><vh>foo</vh></v>
<v t="ekr.20230509083244.115"><vh>foo2</vh></v>
<v t="ekr.20230509083244.116"><vh>class Foo</vh></v>
<v t="ekr.20230509083244.117"><vh>a</vh></v>
<v t="ekr.20230509083244.118"><vh>b</vh></v>
<v t="ekr.20230509083244.119"><vh>c</vh></v>
<v t="ekr.20230509083244.120"><vh>test_cross_calls</vh></v>
</v>
<v t="ekr.20230509083244.121"><vh>@@clean find-python-library.py</vh>
<v t="ekr.20230509083244.122"><vh>get_python_library</vh></v>
</v>
<v t="ekr.20230509083244.123"><vh>@@clean myextension.codon</vh></v>
<v t="ekr.20230509083244.124"><vh>@@clean myextension2.codon</vh></v>
<v t="ekr.20230509083244.125"><vh>@@clean mymodule.py</vh>
<v t="ekr.20230509083244.126"><vh>multiply</vh></v>
<v t="ekr.20230509083244.127"><vh>print_args</vh></v>
<v t="ekr.20230509083244.128"><vh>print_args_var</vh></v>
<v t="ekr.20230509083244.129"><vh>throw_exc</vh></v>
</v>
<v t="ekr.20230509083244.130"><vh>@@clean pybridge.codon</vh></v>
<v t="ekr.20230509083244.131"><vh>@@clean pyext.py</vh>
<v t="ekr.20230509083244.132"><vh>equal</vh></v>
<v t="ekr.20230509083244.133"><vh>saw_fun = False</vh></v>
<v t="ekr.20230509083244.134"><vh>test_codon_extensions</vh>
<v t="ekr.20230509083244.135"><vh>dup</vh></v>
<v t="ekr.20230509083244.136"><vh>y1 = dup(y)</vh></v>
<v t="ekr.20230509083244.137"><vh>par_sum_check</vh></v>
</v>
</v>
<v t="ekr.20230509083244.138"><vh>@@clean setup.py</vh>
<v t="ekr.20230509083244.139"><vh>class CodonExtension</vh></v>
<v t="ekr.20230509083244.140"><vh>class BuildCodonExt</vh>
<v t="ekr.20230509083244.141"><vh>BuildCodonExt.build_extensions</vh></v>
<v t="ekr.20230509083244.142"><vh>BuildCodonExt.run</vh></v>
<v t="ekr.20230509083244.143"><vh>BuildCodonExt.build_codon</vh></v>
</v>
</v>
</v>
<v t="ekr.20230509083244.145"><vh>@path stdlib</vh>
<v t="ekr.20230509083244.146"><vh>@@clean bisect_test.codon</vh></v>
<v t="ekr.20230509083244.147"><vh>@@clean cmath_test.codon</vh></v>
<v t="ekr.20230509083244.148"><vh>@@clean datetime_test.codon</vh></v>
<v t="ekr.20230509083244.149"><vh>@@clean heapq_test.codon</vh></v>
<v t="ekr.20230509083244.150"><vh>@@clean itertools_test.codon</vh></v>
<v t="ekr.20230509083244.151"><vh>@@clean math_test.codon</vh></v>
<v t="ekr.20230509083244.152"><vh>@@clean operator_test.codon</vh></v>
<v t="ekr.20230509083244.153"><vh>@@clean random_test.codon</vh></v>
<v t="ekr.20230509083244.154"><vh>@@clean re_test.codon</vh></v>
<v t="ekr.20230509083244.155"><vh>@@clean sort_test.codon</vh></v>
<v t="ekr.20230509083244.156"><vh>@@clean statistics_test.codon</vh></v>
<v t="ekr.20230509083244.157"><vh>@@clean str_test.codon</vh></v>
</v>
<v t="ekr.20230509083244.158"><vh>@path transform</vh>
<v t="ekr.20230509083244.159"><vh>@@clean canonical.codon</vh></v>
<v t="ekr.20230509083244.160"><vh>@@clean dict_opt.codon</vh></v>
<v t="ekr.20230509083244.161"><vh>@@clean escapes.codon</vh></v>
<v t="ekr.20230509083244.162"><vh>@@clean folding.codon</vh></v>
<v t="ekr.20230509083244.163"><vh>@@clean for_lowering.codon</vh></v>
<v t="ekr.20230509083244.164"><vh>@@clean inlining.codon</vh></v>
<v t="ekr.20230509083244.165"><vh>@@clean io_opt.codon</vh></v>
<v t="ekr.20230509083244.166"><vh>@@clean kernels.codon</vh></v>
<v t="ekr.20230509083244.167"><vh>@@clean list_opt.codon</vh></v>
<v t="ekr.20230509083244.168"><vh>@@clean omp.codon</vh></v>
<v t="ekr.20230509083244.169"><vh>@@clean outlining.codon</vh></v>
<v t="ekr.20230509083244.170"><vh>@@clean str_opt.codon</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20230509052845.1">https://github.com/exaloop/codon</t>
<t tx="ekr.20230509083132.1">@language python
'''Recursively import all python files in a directory and clean the result.'''
@tabwidth -4 # For a better match.
g.cls()
dir_ = r'C:\Python\Python3.10\Lib\site-packages\coverage'
dir_ = r'C:\Repos\codon'
c.recursiveImport(
    add_context=True,  # Override setting only if True/False
    add_file_context=False,  # Override setting only if True/False
    dir_=dir_,
    kind = '@@clean', # '@auto', '@@clean', '@nosent','@file',
    add_path = True,
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py', '.c', '.cpp', '.h', '.codon'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    # for p in last.self_and_subtree():
        # p.expand()
    # c.expandAllSubheads()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20230509083242.10">@path C:/Repos/codon/bench/binary_trees/
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# contributed by Antoine Pitrou
# modified by Dominique Wahli and Daniel Nanz
# modified by Joerg Baumann
# modified by @arshajii for Codon

import sys
import time

@others
t0 = time.time()
main(int(sys.argv[1]))
t1 = time.time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.100">def best_child(self):
    maxscore = -1
    maxchild = None
    for child in self.pos_child:
        if child and child.score() &gt; maxscore:
            maxchild = child
            maxscore = child.score()
    return maxchild

</t>
<t tx="ekr.20230509083242.101">def best_visited(self):
    maxvisits = -1
    maxchild = None
    for child in self.pos_child:
        #            if child:
        # print to_xy(child.pos), child.wins, child.losses, child.score()
        if child and (child.wins + child.losses) &gt; maxvisits:
            maxvisits, maxchild = (child.wins + child.losses), child
    return maxchild


</t>
<t tx="ekr.20230509083242.102"># def user_move(board):
#     while True:
#         text = input('?').strip()
#         if text == 'p':
#             return PASS
#         if text == 'q':
#             raise EOFError
#         try:
#             x, y = [int(i) for i in text.split()]
#         except ValueError:
#             continue
#         if not (0 &lt;= x &lt; SIZE and 0 &lt;= y &lt; SIZE):
#             continue
#         pos = to_pos(x, y)
#         if board.useful(pos):
#             return pos


</t>
<t tx="ekr.20230509083242.103">def computer_move(board):
    pos = board.random_move()
    if pos == PASS:
        return PASS
    tree = UCTNode()
    tree.unexplored = board.useful_moves()
    nboard = Board()
    for game in range(GAMES):
        node = tree
        nboard.reset()
        nboard.replay(board.history)
        node.play(nboard)
    return tree.best_visited().pos


</t>
<t tx="ekr.20230509083242.104">def versus_cpu():
    for i in range(100):
        random.seed(i)
        board = Board()
        computer_move(board)


</t>
<t tx="ekr.20230509083242.105"></t>
<t tx="ekr.20230509083242.106">@path C:/Repos/codon/bench/mandelbrot/
@language unknown_language
import time
MAX    = 1000  # maximum Mandelbrot iterations
N      = 4096  # width and height of image
pixels = [0 for _ in range(N * N)]

def scale(x, a, b):
    return a + (x/N)*(b - a)

t0 = time.time()
@par(gpu=True, collapse=2)
for i in range(N):
    for j in range(N):
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        pixels[i*N + j] = int(255 * iteration/MAX)
print(sum(pixels))
print(time.time() - t0)
</t>
<t tx="ekr.20230509083242.107">@path C:/Repos/codon/bench/mandelbrot/
import time
MAX    = 1000  # maximum Mandelbrot iterations
N      = 4096  # width and height of image
pixels = [0 for _ in range(N * N)]

@others
t0 = time.time()
for i in range(N):
    for j in range(N):
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        pixels[i*N + j] = int(255 * iteration/MAX)
print(sum(pixels))
print(time.time() - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.108">def scale(x, a, b):
    return a + (x/N)*(b - a)

</t>
<t tx="ekr.20230509083242.109">@path C:/Repos/codon/bench/nbody/</t>
<t tx="ekr.20230509083242.11">class Node:
    def __init__(self, left = None, right = None):
        self.left = left
        self.right = right

</t>
<t tx="ekr.20230509083242.118">@path C:/Repos/codon/bench/nbody/
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# originally by Kevin Carson
# modified by Tupteq, Fredrik Johansson, and Daniel Nanz
# modified by Maciej Fijalkowski
# modified by @arshajii
# 2to3

from time import time
import sys

@others
t0 = time()
main(int(sys.argv[1]))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.119">def combinations(l):
    result = []
    for x in range(len(l) - 1):
        ls = l[x+1:]
        for y in ls:
            result.append((l[x],y))
    return result

</t>
<t tx="ekr.20230509083242.12">def make_tree(d):
    return Node(make_tree(d - 1), make_tree(d - 1)) if d &gt; 0 else Node()

</t>
<t tx="ekr.20230509083242.120">PI = 3.14159265358979323
SOLAR_MASS = 4 * PI * PI
DAYS_PER_YEAR = 365.24

BODIES = {
    'sun': ([0.0, 0.0, 0.0], [0.0, 0.0, 0.0], SOLAR_MASS),

    'jupiter': ([4.84143144246472090e+00,
                 -1.16032004402742839e+00,
                 -1.03622044471123109e-01],
                [1.66007664274403694e-03 * DAYS_PER_YEAR,
                 7.69901118419740425e-03 * DAYS_PER_YEAR,
                 -6.90460016972063023e-05 * DAYS_PER_YEAR],
                9.54791938424326609e-04 * SOLAR_MASS),

    'saturn': ([8.34336671824457987e+00,
                4.12479856412430479e+00,
                -4.03523417114321381e-01],
               [-2.76742510726862411e-03 * DAYS_PER_YEAR,
                4.99852801234917238e-03 * DAYS_PER_YEAR,
                2.30417297573763929e-05 * DAYS_PER_YEAR],
               2.85885980666130812e-04 * SOLAR_MASS),

    'uranus': ([1.28943695621391310e+01,
                -1.51111514016986312e+01,
                -2.23307578892655734e-01],
               [2.96460137564761618e-03 * DAYS_PER_YEAR,
                2.37847173959480950e-03 * DAYS_PER_YEAR,
                -2.96589568540237556e-05 * DAYS_PER_YEAR],
               4.36624404335156298e-05 * SOLAR_MASS),

    'neptune': ([1.53796971148509165e+01,
                 -2.59193146099879641e+01,
                 1.79258772950371181e-01],
                [2.68067772490389322e-03 * DAYS_PER_YEAR,
                 1.62824170038242295e-03 * DAYS_PER_YEAR,
                 -9.51592254519715870e-05 * DAYS_PER_YEAR],
                5.15138902046611451e-05 * SOLAR_MASS) }


SYSTEM = list(BODIES.values())
PAIRS = combinations(SYSTEM)


</t>
<t tx="ekr.20230509083242.121">def advance(dt, n, bodies=SYSTEM, pairs=PAIRS):

    for i in range(n):
        for (([x1, y1, z1], v1, m1),
             ([x2, y2, z2], v2, m2)) in pairs:
            dx = x1 - x2
            dy = y1 - y2
            dz = z1 - z2
            mag = dt * ((dx * dx + dy * dy + dz * dz) ** (-1.5))
            b1m = m1 * mag
            b2m = m2 * mag
            v1[0] -= dx * b2m
            v1[1] -= dy * b2m
            v1[2] -= dz * b2m
            v2[0] += dx * b1m
            v2[1] += dy * b1m
            v2[2] += dz * b1m
        for (r, [vx, vy, vz], m) in bodies:
            r[0] += dt * vx
            r[1] += dt * vy
            r[2] += dt * vz


</t>
<t tx="ekr.20230509083242.122">def report_energy(bodies=SYSTEM, pairs=PAIRS, e=0.0):

    for (((x1, y1, z1), v1, m1),
         ((x2, y2, z2), v2, m2)) in pairs:
        dx = x1 - x2
        dy = y1 - y2
        dz = z1 - z2
        e -= (m1 * m2) / ((dx * dx + dy * dy + dz * dz) ** 0.5)
    for (r, [vx, vy, vz], m) in bodies:
        e += m * (vx * vx + vy * vy + vz * vz) / 2.
    print(e)

</t>
<t tx="ekr.20230509083242.123">def offset_momentum(ref, bodies=SYSTEM, px=0.0, py=0.0, pz=0.0):

    for (r, [vx, vy, vz], m) in bodies:
        px -= vx * m
        py -= vy * m
        pz -= vz * m
    (r, v, m) = ref
    v[0] = px / m
    v[1] = py / m
    v[2] = pz / m

</t>
<t tx="ekr.20230509083242.124">def main(n, ref='sun'):
    offset_momentum(BODIES[ref])
    report_energy()
    advance(0.01, n)
    report_energy()

</t>
<t tx="ekr.20230509083242.125"></t>
<t tx="ekr.20230509083242.126">@path C:/Repos/codon/bench/primes/
@language unknown_language
from sys import argv
from time import time

def is_prime(n):
    factors = 0
    for i in range(2, n):
        if n % i == 0:
            factors += 1
    return factors == 0

limit = int(argv[1])
total = 0

t0 = time()
@par(schedule='dynamic')
for i in range(2, limit):
    if is_prime(i):
        total += 1
t1 = time()

print(total)
print(t1 - t0)
</t>
<t tx="ekr.20230509083242.127">@path C:/Repos/codon/bench/primes/
from sys import argv
from time import time

@others
limit = int(argv[1])
total = 0

t0 = time()
for i in range(2, limit):
    if is_prime(i):
        total += 1
t1 = time()

print(total)
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.128">def is_prime(n):
    factors = 0
    for i in range(2, n):
        if n % i == 0:
            factors += 1
    return factors == 0

</t>
<t tx="ekr.20230509083242.129"></t>
<t tx="ekr.20230509083242.13">def check_tree(node):
    l, r = node.left, node.right
    if l is None:
        return 1
    else:
        return 1 + check_tree(l) + check_tree(r)

</t>
<t tx="ekr.20230509083242.130">@path C:/Repos/codon/bench/set_partition/
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

template &lt;class T&gt; using vec = std::vector&lt;T&gt;;

inline vec&lt;int&gt; range(int start, int stop) {
  vec&lt;int&gt; v(stop - start);
  uint j = 0;
  for (int i = start; i &lt; stop; i++)
    v[j++] = i;
  return v;
}

inline bool conforms(const vec&lt;vec&lt;int&gt;&gt; &amp;candidate, int minsize, int forgive) {
  int deficit = 0;
  for (const auto &amp;p : candidate) {
    int need = minsize - static_cast&lt;int&gt;(p.size());
    if (need &gt; 0)
      deficit += need;
  }
  return deficit &lt;= forgive;
}

inline void partition_filtered(const vec&lt;int&gt; &amp;collection,
                               std::function&lt;void(const vec&lt;vec&lt;int&gt;&gt; &amp;)&gt; callback,
@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.131">                               int minsize = 1, int forgive = 0) {
  if (collection.size() == 1) {
    callback({collection});
    return;
  }

  auto first = collection[0];
  @others
  vec&lt;int&gt; new_collection(collection.begin() + 1, collection.end());
  partition_filtered(new_collection, loop, minsize, forgive + 1);
}

</t>
<t tx="ekr.20230509083242.132">auto loop = [&amp;](const vec&lt;vec&lt;int&gt;&gt; &amp;smaller) {
  int n = 0;

  vec&lt;vec&lt;int&gt;&gt; candidate;
  candidate.reserve(smaller.size() + 1);
  vec&lt;int&gt; rep;

  for (const auto &amp;subset : smaller) {
    candidate.resize(n);
    for (int i = 0; i &lt; n; i++)
      candidate[i] = smaller[i];

    rep.clear();
    rep.reserve(subset.size() + 1);
    rep.push_back(first);
    rep.insert(rep.end(), subset.begin(), subset.end());
    candidate.push_back({rep});

    for (int i = n + 1; i &lt; smaller.size(); i++)
      candidate.push_back(smaller[i]);

    if (conforms(candidate, minsize, forgive))
      callback(candidate);
    ++n;
  }

  candidate.clear();
  candidate.push_back({first});
  candidate.insert(candidate.end(), smaller.begin(), smaller.end());

  if (conforms(candidate, minsize, forgive))
    callback(candidate);
};

</t>
<t tx="ekr.20230509083242.133">int main(int argc, char *argv[]) {
  using clock = std::chrono::high_resolution_clock;
  using std::chrono::duration_cast;
  using std::chrono::milliseconds;

  auto t = clock::now();
  int n = 1;
  int x = 0;

  @others
  auto something = range(1, std::atoi(argv[1]));
  partition_filtered(something, callback, 2);
  std::cout &lt;&lt; x &lt;&lt; std::endl;
  std::cout &lt;&lt; (duration_cast&lt;milliseconds&gt;(clock::now() - t).count() / 1e3)
            &lt;&lt; std::endl;
}
</t>
<t tx="ekr.20230509083242.134">auto callback = [&amp;](const vec&lt;vec&lt;int&gt;&gt; &amp;p) {
  auto copy = p;
  std::sort(copy.begin(), copy.end());
  x += copy[copy.size() / 3][0];
};

</t>
<t tx="ekr.20230509083242.135">@path C:/Repos/codon/bench/set_partition/
# https://stackoverflow.com/questions/73473074/speed-up-set-partition-generation-by-skipping-ones-with-subsets-smaller-or-large
import sys
import time

@others
import time

t = time.time()
something = list(range(1, int(sys.argv[1])))
v = partition_filtered(something, minsize=2)
x = 0
for p in v:
    p.sort()
    x += p[len(p) // 3][0]
print(x)
print(time.time() - t)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.136">def conforms(candidate, minsize, forgive):
    """
    Check if partition `candidate` is at most `forgive` additions from making
    all its elements conform to having minimum size `minsize`
    """
    deficit = 0
    for p in candidate:
        need = minsize - len(p)
        if need &gt; 0:
            deficit += need

    # Is the deficit small enough?
    return (deficit &lt;= forgive)

</t>
<t tx="ekr.20230509083242.137">def partition_filtered(collection, minsize=1, forgive=0):
    """
    Generate partitions that contain at least `minsize` elements per set;
    allow `forgive` missing elements, which can get added in subsequent steps
    """
    if len(collection) == 1:
        yield [ collection ]
        return

    first = collection[0]
    for smaller in partition_filtered(collection[1:], minsize, forgive=forgive+1):
        # insert `first` in each of the subpartition's subsets
        for n, subset in enumerate(smaller):
            candidate = smaller[:n] + [[ first ] + subset]  + smaller[n+1:]
            if conforms(candidate, minsize, forgive):
                yield candidate

        # put `first` in its own subset
        candidate = [ [ first ] ] + smaller
        if conforms(candidate, minsize, forgive):
            yield candidate


</t>
<t tx="ekr.20230509083242.138"></t>
<t tx="ekr.20230509083242.139">@path C:/Repos/codon/bench/spectral_norm/
"""
MathWorld: "Hundred-Dollar, Hundred-Digit Challenge Problems", Challenge #3.
http://mathworld.wolfram.com/Hundred-DollarHundred-DigitChallengeProblems.html

The Computer Language Benchmarks Game
http://benchmarksgame.alioth.debian.org/u64q/spectralnorm-description.html#spectralnorm

Contributed by Sebastien Loisel
Fixed by Isaac Gouy
Sped up by Josh Goldfoot
Dirtily sped up by Simon Descarpentries
Concurrency by Jason Stitt
Adapted for Codon by @arshajii
"""

from time import time

DEFAULT_N = 260

@others
t0 = time()
print(bench_spectral_norm(100))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.14">def make_check(itde, make=make_tree, check=check_tree):
    i, d = itde
    return check(make(d))

</t>
<t tx="ekr.20230509083242.140">def eval_A(i, j):
    return 1.0 / ((i + j) * (i + j + 1) // 2 + i + 1)

</t>
<t tx="ekr.20230509083242.141">def eval_times_u(func, u):
    return [func((i, u)) for i in range(len(list(u)))]

</t>
<t tx="ekr.20230509083242.142">def part_At_times_u(i_u):
    i, u = i_u
    partial_sum = 0.
    for j, u_j in enumerate(u):
        partial_sum += eval_A(j, i) * u_j
    return partial_sum

</t>
<t tx="ekr.20230509083242.143">def part_A_times_u(i_u):
    i, u = i_u
    partial_sum = 0.
    for j, u_j in enumerate(u):
        partial_sum += eval_A(i, j) * u_j
    return partial_sum

</t>
<t tx="ekr.20230509083242.144">def eval_AtA_times_u(u):
    return eval_times_u(part_At_times_u, eval_times_u(part_A_times_u, u))

</t>
<t tx="ekr.20230509083242.145">def bench_spectral_norm(loops):
    range_it = range(loops)
    total = 0.
    for _ in range_it:
        u = [1.] * DEFAULT_N
        v = None
        for dummy in range(10):
            v = eval_AtA_times_u(u)
            u = eval_AtA_times_u(v)
        vBv = vv = 0.
        for ue, ve in zip(u, v):
            vBv += ue * ve
            vv += ve * ve
        total += vBv + vv
    return total

</t>
<t tx="ekr.20230509083242.146"></t>
<t tx="ekr.20230509083242.147">@path C:/Repos/codon/bench/sum/
# https://towardsdatascience.com/getting-started-with-pypy-ef4ba5cb431c
import time
t1 = time.time()
nums = range(50000000)
sum = 0
for k in nums:
    sum = sum + k
print("Sum of 50000000 numbers is : ", sum)
t2 = time.time()
t = t2 - t1
print(t)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.148"></t>
<t tx="ekr.20230509083242.149">@path C:/Repos/codon/bench/taq/
#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;cmath&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

namespace {
template &lt;typename It&gt; double mean(It begin, It end) {
  double sum = std::accumulate(begin, end, 0.0);
  double mean = sum / std::distance(begin, end);
  return mean;
}

template &lt;typename It&gt; double stdev(It begin, It end) {
  auto n = std::distance(begin, end);
  double sum = std::accumulate(begin, end, 0.0);
  double mean = sum / n;
  double sq_sum = std::inner_product(begin, end, begin, 0.0);
  double stdev = std::sqrt(sq_sum / n - mean * mean);
  return stdev;
}

std::vector&lt;int&gt; find_peaks(const std::vector&lt;double&gt; &amp;y) {
  int lag = 100;
  double threshold = 10.0;
  double influence = 0.5;
  int t = y.size();
  std::vector&lt;int&gt; signals(t);

  if (t &lt;= lag)
    return signals;

  std::vector&lt;double&gt; filtered_y;
  filtered_y.reserve(t);
  for (int i = 0; i &lt; t; i++)
    filtered_y.push_back(i &lt; lag ? y[i] : 0.0);

  std::vector&lt;double&gt; avg_filter(t);
  std::vector&lt;double&gt; std_filter(t);
  avg_filter[lag] = mean(y.begin(), y.begin() + lag);
  avg_filter[lag] = stdev(y.begin(), y.begin() + lag);

  for (int i = lag; i &lt; t; i++) {
    if (std::abs(y[i] - avg_filter[i - 1]) &gt; threshold * std_filter[i - 1]) {
      signals[i] = y[i] &gt; avg_filter[i - 1] ? +1 : -1;
      filtered_y[i] = influence * y[i] + (1 - influence) * filtered_y[i - 1];
    } else {
      signals[i] = 0;
      filtered_y[i] = y[i];
    }

    avg_filter[i] = mean(filtered_y.begin() + (i - lag), filtered_y.begin() + i);
    std_filter[i] = stdev(filtered_y.begin() + (i - lag), filtered_y.begin() + i);
  }

  return signals;
}

std::pair&lt;std::vector&lt;double&gt;, std::vector&lt;int&gt;&gt;
process_data(const std::vector&lt;std::pair&lt;uint64_t, long&gt;&gt; &amp;series) {
  std::unordered_map&lt;uint64_t, long&gt; grouped;
  for (const auto &amp;p : series) {
    auto bucket = p.first;
    auto volume = p.second;
    grouped[bucket] += volume;
  }

  std::vector&lt;std::pair&lt;uint64_t, long&gt;&gt; temp;
  temp.reserve(grouped.size());
  for (const auto &amp;p : grouped)
    temp.emplace_back(p.first, p.second);
  std::sort(temp.begin(), temp.end());

  std::vector&lt;double&gt; y;
  y.reserve(grouped.size());
  for (const auto &amp;p : temp)
    y.push_back(p.second);

  return {y, find_peaks(y)};
}

const uint64_t BUCKET_SIZE = 1000000000;
} // namespace

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.15">def get_argchunks(i, d, chunksize=5000):
    assert chunksize % 2 == 0
    chunk = []
    for k in range(1, i + 1):
        chunk.append((k, d))
        if len(chunk) == chunksize:
            yield chunk
            chunk = []
    if len(chunk) &gt; 0:
        yield chunk

</t>
<t tx="ekr.20230509083242.150">int main(int argc, char *argv[]) {
  using clock = std::chrono::high_resolution_clock;
  using std::chrono::duration_cast;
  using std::chrono::milliseconds;

  auto t = clock::now();
  std::unordered_map&lt;std::string, std::vector&lt;std::pair&lt;uint64_t, long&gt;&gt;&gt; data;
  std::ifstream file(argv[1]);
  bool header = true;

  for (std::string line; std::getline(file, line);) {
    if (header) {
      header = false;
      continue;
    }

    std::stringstream ss(line);
    std::vector&lt;std::string&gt; x;
    for (std::string field; std::getline(ss, field, '|');)
      x.push_back(field);

    if (x[0] == "END" || x[4] == "ENDP")
      continue;

    uint64_t timestamp = std::stoull(x[0]);
    std::string symbol = x[2];
    long volume = std::stol(x[4]);
    data[symbol].emplace_back(timestamp / BUCKET_SIZE, volume);
  }

  for (auto &amp;e : data) {
    auto symbol = e.first;
    auto &amp;series = e.second;
    auto p = process_data(series);
    auto &amp;signals = p.second;
    std::cout &lt;&lt; symbol &lt;&lt; " " &lt;&lt; std::reduce(signals.begin(), signals.end())
              &lt;&lt; std::endl;
  }

  std::cout &lt;&lt; (duration_cast&lt;milliseconds&gt;(clock::now() - t).count() / 1e3)
            &lt;&lt; std::endl;
}
</t>
<t tx="ekr.20230509083242.151">@path C:/Repos/codon/bench/taq/
# Parses TAQ file and performs volume peak detection
from sys import argv
from time import time
from statistics import mean, stdev

@others
BUCKET_SIZE = 1_000_000_000
t0 = time()

data = {}
with open(argv[1]) as f:
    header = True

    for line in f:
        if header:
            header = False
            continue

        x = line.split('|')
        if x[0] == 'END' or x[4] == 'ENDP':
            continue

        timestamp = int(x[0])
        symbol = x[2]
        volume = int(x[4])

        series = data.setdefault(symbol, [])
        series.append((timestamp // BUCKET_SIZE, volume))

for symbol, series in data.items():
    y, signals = process_data(series)
    print(symbol, sum(signals))

t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.152"># https://stackoverflow.com/questions/22583391/peak-signal-detection-in-realtime-timeseries-data
def find_peaks(y):
    lag = 100
    threshold = 10.0
    influence = 0.5

    t = len(y)
    signals = [0. for _ in range(t)]

    if t &lt;= lag:
        return signals

    filtered_y = [y[i] if i &lt; lag else 0. for i in range(t)]
    avg_filter = [0. for _ in range(t)]
    std_filter = [0. for _ in range(t)]
    avg_filter[lag] = mean(y[:lag])
    std_filter[lag] = stdev(y[:lag])

    for i in range(lag, t):
        if abs(y[i] - avg_filter[i-1]) &gt; threshold * std_filter[i-1]:
            signals[i] = +1 if y[i] &gt; avg_filter[i-1] else -1
            filtered_y[i] = influence*y[i] + (1 - influence)*filtered_y[i-1]
        else:
            signals[i] = 0
            filtered_y[i] = y[i]

        avg_filter[i] = mean(filtered_y[i-lag:i])
        std_filter[i] = stdev(filtered_y[i-lag:i])

    return signals

</t>
<t tx="ekr.20230509083242.153">def process_data(series):
    grouped = {}
    for bucket, volume in series:
        grouped[bucket] = grouped.get(bucket, 0) + volume

    y = [float(t[1]) for t in sorted(grouped.items())]
    return y, find_peaks(y)

</t>
<t tx="ekr.20230509083242.154"></t>
<t tx="ekr.20230509083242.155">@path C:/Repos/codon/bench/word_count/
#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

using namespace std;

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.156">int main(int argc, char *argv[]) {
  using clock = chrono::high_resolution_clock;
  using chrono::duration_cast;
  using chrono::milliseconds;
  auto t = clock::now();

  cin.tie(nullptr);
  cout.sync_with_stdio(false);

  if (argc != 2) {
    cerr &lt;&lt; "Expected one argument." &lt;&lt; endl;
    return -1;
  }

  ifstream file(argv[1]);
  if (!file.is_open()) {
    cerr &lt;&lt; "Could not open file: " &lt;&lt; argv[1] &lt;&lt; endl;
    return -1;
  }

  unordered_map&lt;string, int&gt; map;
  for (string line; getline(file, line);) {
    istringstream sin(line);
    for (string word; sin &gt;&gt; word;)
      map[word] += 1;
  }

  cout &lt;&lt; map.size() &lt;&lt; endl;
  cout &lt;&lt; (duration_cast&lt;milliseconds&gt;(clock::now() - t).count() / 1e3) &lt;&lt; endl;
}
</t>
<t tx="ekr.20230509083242.157">@path C:/Repos/codon/bench/word_count/
from sys import argv
from time import time

t0 = time()
wc = {}
filename = argv[-1]

with open(filename) as f:
    for l in f:
        for w in l.split():
            wc[w] = wc.get(w, 0) + 1

print(len(wc))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.159"></t>
<t tx="ekr.20230509083242.16">def main(n, min_depth=4):
    max_depth = max(min_depth + 2, n)
    stretch_depth = max_depth + 1
    print(f'stretch tree of depth {stretch_depth}\t check: {make_check((0, stretch_depth))}')

    long_lived_tree = make_tree(max_depth)

    mmd = max_depth + min_depth
    for d in range(min_depth, stretch_depth, 2):
        i = 2 ** (mmd - d)
        cs = 0
        for argchunk in get_argchunks(i, d):
            cs += sum(map(make_check, argchunk))
        print(f'{i}\t trees of depth {d}\t check: {cs}')

    print(f'long lived tree of depth {max_depth}\t check: {check_tree(long_lived_tree)}')

</t>
<t tx="ekr.20230509083242.160"></t>
<t tx="ekr.20230509083242.161">@path C:/Repos/codon/codon/app/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/compiler/compiler.h"
#include "codon/compiler/error.h"
#include "codon/compiler/jit.h"
#include "codon/util/common.h"
#include "codon/util/jupyter.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/FileSystem.h"

namespace {
@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.162">void versMsg(llvm::raw_ostream &amp;out) {
  out &lt;&lt; CODON_VERSION_MAJOR &lt;&lt; "." &lt;&lt; CODON_VERSION_MINOR &lt;&lt; "." &lt;&lt; CODON_VERSION_PATCH
      &lt;&lt; "\n";
}

</t>
<t tx="ekr.20230509083242.163">bool isMacOS() {
#ifdef __APPLE__
  return true;
#else
  return false;
#endif
}

</t>
<t tx="ekr.20230509083242.164">const std::vector&lt;std::string&gt; &amp;supportedExtensions() {
  static const std::vector&lt;std::string&gt; extensions = {".codon", ".py", ".seq"};
  return extensions;
}

</t>
<t tx="ekr.20230509083242.165">bool hasExtension(const std::string &amp;filename, const std::string &amp;extension) {
  return filename.size() &gt;= extension.size() &amp;&amp;
         filename.compare(filename.size() - extension.size(), extension.size(),
                          extension) == 0;
}

</t>
<t tx="ekr.20230509083242.166">std::string trimExtension(const std::string &amp;filename, const std::string &amp;extension) {
  if (hasExtension(filename, extension)) {
    return filename.substr(0, filename.size() - extension.size());
  } else {
    return filename;
  }
}

std::string makeOutputFilename(const std::string &amp;filename,
</t>
<t tx="ekr.20230509083242.167">                               const std::string &amp;extension) {
  for (const auto &amp;ext : supportedExtensions()) {
    if (hasExtension(filename, ext))
      return trimExtension(filename, ext) + extension;
  }
  return filename + extension;
}

</t>
<t tx="ekr.20230509083242.168">void display(const codon::error::ParserErrorInfo &amp;e) {
  using codon::MessageGroupPos;
  for (auto &amp;group : e) {
    for (auto &amp;msg : group) {
      MessageGroupPos pos = MessageGroupPos::NONE;
      if (&amp;msg == &amp;group.front()) {
        pos = MessageGroupPos::HEAD;
      } else if (&amp;msg == &amp;group.back()) {
        pos = MessageGroupPos::LAST;
      } else {
        pos = MessageGroupPos::MID;
      }
      codon::compilationError(msg.getMessage(), msg.getFile(), msg.getLine(),
                              msg.getColumn(), msg.getLength(), msg.getErrorCode(),
                              /*terminate=*/false, pos);
    }
  }
}

</t>
<t tx="ekr.20230509083242.169">void initLogFlags(const llvm::cl::opt&lt;std::string&gt; &amp;log) {
  codon::getLogger().parse(log);
  if (auto *d = getenv("CODON_DEBUG"))
    codon::getLogger().parse(std::string(d));
}

</t>
<t tx="ekr.20230509083242.17"></t>
<t tx="ekr.20230509083242.170">enum BuildKind { LLVM, Bitcode, Object, Executable, Library, PyExtension, Detect };
enum OptMode { Debug, Release };
enum Numerics { C, Python };
} // namespace

</t>
<t tx="ekr.20230509083242.171">int docMode(const std::vector&lt;const char *&gt; &amp;args, const std::string &amp;argv0) {
  llvm::cl::ParseCommandLineOptions(args.size(), args.data());
  std::vector&lt;std::string&gt; files;
  for (std::string line; std::getline(std::cin, line);)
    files.push_back(line);

  auto compiler = std::make_unique&lt;codon::Compiler&gt;(args[0]);
  bool failed = false;
  auto result = compiler-&gt;docgen(files);
  llvm::handleAllErrors(result.takeError(),
                        [&amp;failed](const codon::error::ParserErrorInfo &amp;e) {
                          display(e);
                          failed = true;
                        });
  if (failed)
    return EXIT_FAILURE;

  fmt::print("{}\n", *result);
  return EXIT_SUCCESS;
}

</t>
<t tx="ekr.20230509083242.172">std::unique_ptr&lt;codon::Compiler&gt; processSource(
</t>
<t tx="ekr.20230509083242.173">    const std::vector&lt;const char *&gt; &amp;args, bool standalone,
    std::function&lt;bool()&gt; pyExtension = [] { return false; }) {
  llvm::cl::opt&lt;std::string&gt; input(llvm::cl::Positional, llvm::cl::desc("&lt;input file&gt;"),
                                   llvm::cl::init("-"));
  auto regs = llvm::cl::getRegisteredOptions();
  llvm::cl::opt&lt;OptMode&gt; optMode(
      llvm::cl::desc("optimization mode"),
      llvm::cl::values(
          clEnumValN(Debug, regs.find("debug") != regs.end() ? "default" : "debug",
                     "Turn off compiler optimizations and show backtraces"),
          clEnumValN(Release, "release",
                     "Turn on compiler optimizations and disable debug info")),
      llvm::cl::init(Debug));
  llvm::cl::list&lt;std::string&gt; defines(
      "D", llvm::cl::Prefix,
      llvm::cl::desc("Add static variable definitions. The syntax is &lt;name&gt;=&lt;value&gt;"));
  llvm::cl::list&lt;std::string&gt; disabledOpts(
      "disable-opt", llvm::cl::desc("Disable the specified IR optimization"));
  llvm::cl::list&lt;std::string&gt; plugins("plugin",
                                      llvm::cl::desc("Load specified plugin"));
  llvm::cl::opt&lt;std::string&gt; log("log", llvm::cl::desc("Enable given log streams"));
  llvm::cl::opt&lt;Numerics&gt; numerics(
      "numerics", llvm::cl::desc("numerical semantics"),
      llvm::cl::values(
          clEnumValN(C, "c", "C semantics: best performance but deviates from Python"),
          clEnumValN(Python, "py",
                     "Python semantics: mirrors Python but might disable optimizations "
                     "like vectorization")),
      llvm::cl::init(C));

  llvm::cl::ParseCommandLineOptions(args.size(), args.data());
  initLogFlags(log);

  std::unordered_map&lt;std::string, std::string&gt; defmap;
  for (const auto &amp;define : defines) {
    auto eq = define.find('=');
    if (eq == std::string::npos || !eq) {
      codon::compilationWarning("ignoring malformed definition: " + define);
      continue;
    }

    auto name = define.substr(0, eq);
    auto value = define.substr(eq + 1);

    if (defmap.find(name) != defmap.end()) {
      codon::compilationWarning("ignoring duplicate definition: " + define);
      continue;
    }

    defmap.emplace(name, value);
  }

  const bool isDebug = (optMode == OptMode::Debug);
  std::vector&lt;std::string&gt; disabledOptsVec(disabledOpts);
  @others
  bool failed = false;
  int testFlags = 0;
  if (auto *tf = getenv("CODON_TEST_FLAGS"))
    testFlags = std::atoi(tf);
  llvm::handleAllErrors(compiler-&gt;parseFile(input, /*testFlags=*/testFlags, defmap),
                        [&amp;failed](const codon::error::ParserErrorInfo &amp;e) {
                          display(e);
                          failed = true;
                        });
  if (failed)
    return {};

  {
    TIME("compile");
    llvm::cantFail(compiler-&gt;compile());
  }
  return compiler;
}

</t>
<t tx="ekr.20230509083242.174">auto compiler = std::make_unique&lt;codon::Compiler&gt;(
    args[0], isDebug, disabledOptsVec,
    /*isTest=*/false, (numerics == Numerics::Python), pyExtension());
compiler-&gt;getLLVMVisitor()-&gt;setStandalone(standalone);

// load plugins
for (const auto &amp;plugin : plugins) {
  bool failed = false;
  llvm::handleAllErrors(
      compiler-&gt;load(plugin), [&amp;failed](const codon::error::PluginErrorInfo &amp;e) {
        codon::compilationError(e.getMessage(), /*file=*/"",
                                /*line=*/0, /*col=*/0, /*len*/ 0, /*errorCode*/ -1,
                                /*terminate=*/false);
        failed = true;
      });
  if (failed)
    return {};
}

</t>
<t tx="ekr.20230509083242.175">int runMode(const std::vector&lt;const char *&gt; &amp;args) {
  llvm::cl::list&lt;std::string&gt; libs(
      "l", llvm::cl::desc("Load and link the specified library"));
  llvm::cl::list&lt;std::string&gt; progArgs(llvm::cl::ConsumeAfter,
                                       llvm::cl::desc("&lt;program arguments&gt;..."));
  auto compiler = processSource(args, /*standalone=*/false);
  if (!compiler)
    return EXIT_FAILURE;
  std::vector&lt;std::string&gt; libsVec(libs);
  std::vector&lt;std::string&gt; argsVec(progArgs);
  argsVec.insert(argsVec.begin(), compiler-&gt;getInput());
  compiler-&gt;getLLVMVisitor()-&gt;run(argsVec, libsVec);
  return EXIT_SUCCESS;
}

</t>
<t tx="ekr.20230509083242.176">namespace {
std::string jitExec(codon::jit::JIT *jit, const std::string &amp;code) {
  auto result = jit-&gt;execute(code);
  if (auto err = result.takeError()) {
    std::string output;
    llvm::handleAllErrors(
        std::move(err), [](const codon::error::ParserErrorInfo &amp;e) { display(e); },
        [&amp;output](const codon::error::RuntimeErrorInfo &amp;e) {
          std::stringstream buf;
          buf &lt;&lt; e.getOutput();
          buf &lt;&lt; "\n\033[1mBacktrace:\033[0m\n";
          for (const auto &amp;line : e.getBacktrace()) {
            buf &lt;&lt; "  " &lt;&lt; line &lt;&lt; "\n";
          }
          output = buf.str();
        });
    return output;
  }
  return *result;
}

</t>
<t tx="ekr.20230509083242.177">void jitLoop(codon::jit::JIT *jit, std::istream &amp;fp) {
  std::string code;
  for (std::string line; std::getline(fp, line);) {
    if (line != "#%%") {
      code += line + "\n";
    } else {
      fmt::print("{}[done]\n", jitExec(jit, code));
      code = "";
      fflush(stdout);
    }
  }
  if (!code.empty())
    fmt::print("{}[done]\n", jitExec(jit, code));
}
</t>
<t tx="ekr.20230509083242.178">} // namespace

</t>
<t tx="ekr.20230509083242.179">int jitMode(const std::vector&lt;const char *&gt; &amp;args) {
  llvm::cl::opt&lt;std::string&gt; input(llvm::cl::Positional, llvm::cl::desc("&lt;input file&gt;"),
                                   llvm::cl::init("-"));
  llvm::cl::list&lt;std::string&gt; plugins("plugin",
                                      llvm::cl::desc("Load specified plugin"));
  llvm::cl::opt&lt;std::string&gt; log("log", llvm::cl::desc("Enable given log streams"));
  llvm::cl::ParseCommandLineOptions(args.size(), args.data());
  initLogFlags(log);
  codon::jit::JIT jit(args[0]);

  // load plugins
  for (const auto &amp;plugin : plugins) {
    bool failed = false;
    llvm::handleAllErrors(jit.getCompiler()-&gt;load(plugin),
                          [&amp;failed](const codon::error::PluginErrorInfo &amp;e) {
                            codon::compilationError(e.getMessage(), /*file=*/"",
                                                    /*line=*/0, /*col=*/0, /*len=*/0,
                                                    /*errorCode*/ -1,
                                                    /*terminate=*/false);
                            failed = true;
                          });
    if (failed)
      return EXIT_FAILURE;
  }

  llvm::cantFail(jit.init());
  fmt::print("&gt;&gt;&gt; Codon JIT v{} &lt;&lt;&lt;\n", CODON_VERSION);
  if (input == "-") {
    jitLoop(&amp;jit, std::cin);
  } else {
    std::ifstream fileInput(input);
    jitLoop(&amp;jit, fileInput);
  }
  return EXIT_SUCCESS;
}

</t>
<t tx="ekr.20230509083242.18">@path C:/Repos/codon/bench/chaos/
@language unknown_language
"""create chaosgame-like fractals
Copyright (C) 2005 Carl Friedrich Bolz

adapted by @arshajii for Codon
"""

import math
import random
import sys
import time

DEFAULT_THICKNESS = 1.0
DEFAULT_WIDTH = 2048 #256
DEFAULT_HEIGHT = 2048 #256
DEFAULT_ITERATIONS = 1000000 #5000
DEFAULT_RNG_SEED = 1234


class GVector(object):
    x: float
    y: float
    z: float

    def __init__(self, x=0, y=0, z=0):
        self.x = x
        self.y = y
        self.z = z

    def Mag(self):
        return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)

    def dist(self, other):
        return math.sqrt((self.x - other.x) ** 2
                         + (self.y - other.y) ** 2
                         + (self.z - other.z) ** 2)

    def __add__(self, other):
        if not isinstance(other, GVector):
            raise ValueError("Can't add GVector to " + str(type(other)))
        v = GVector(self.x + other.x, self.y + other.y, self.z + other.z)
        return v

    def __sub__(self, other):
        return self + other * -1

    def __mul__(self, other):
        v = GVector(self.x * other, self.y * other, self.z * other)
        return v
    #__rmul__ = __mul__

    def linear_combination(self, other, l1, l2=None):
        if l2 is None:
            l2 = 1 - l1
        v = GVector(self.x * l1 + other.x * l2,
                    self.y * l1 + other.y * l2,
                    self.z * l1 + other.z * l2)
        return v

    #def __str__(self):
    #    return "&lt;%f, %f, %f&gt;" % (self.x, self.y, self.z)

    #def __repr__(self):
    #    return "GVector(%f, %f, %f)" % (self.x, self.y, self.z)


class Spline(object):
    """Class for representing B-Splines and NURBS of arbitrary degree"""
    knots: List[int]
    degree: int
    points: List[GVector]

    def __init__(self, points, degree, knots):
        """Creates a Spline.
        points is a list of GVector, degree is the degree of the Spline.
        """
        if len(points) &gt; len(knots) - degree + 1:
            raise ValueError("too many control points")
        elif len(points) &lt; len(knots) - degree + 1:
            raise ValueError("not enough control points")
        last = knots[0]
        for cur in knots[1:]:
            if cur &lt; last:
                raise ValueError("knots not strictly increasing")
            last = cur
        self.knots = knots
        self.points = points
        self.degree = degree

    def GetDomain(self):
        """Returns the domain of the B-Spline"""
        return (self.knots[self.degree - 1],
                self.knots[len(self.knots) - self.degree])

    def __call__(self, u):
        """Calculates a point of the B-Spline using de Boors Algorithm"""
        dom = self.GetDomain()
        if u &lt; dom[0] or u &gt; dom[1]:
            raise ValueError("Function value not in domain")
        if u == dom[0]:
            return self.points[0]
        if u == dom[1]:
            return self.points[-1]
        I = self.GetIndex(u)
        d = [self.points[I - self.degree + 1 + ii]
             for ii in range(self.degree + 1)]
        U = self.knots
        for ik in range(1, self.degree + 1):
            for ii in range(I - self.degree + ik + 1, I + 2):
                ua = U[ii + self.degree - ik]
                ub = U[ii - 1]
                co1 = (ua - u) / (ua - ub)
                co2 = (u - ub) / (ua - ub)
                index = ii - I + self.degree - ik - 1
                d[index] = d[index].linear_combination(d[index + 1], co1, co2)
        return d[0]

    def GetIndex(self, u):
        dom = self.GetDomain()
        for ii in range(self.degree - 1, len(self.knots) - self.degree):
            if u &gt;= self.knots[ii] and u &lt; self.knots[ii + 1]:
                I = ii
                break
        else:
            I = dom[1] - 1
        return I

    def __len__(self):
        return len(self.points)

    #def __repr__(self):
    #    return "Spline(%r, %r, %r)" % (self.points, self.degree, self.knots)


def write_ppm(im, filename):
    magic = 'P6\n'
    maxval = 255
    w = len(im)
    h = len(im[0])

    #with open(filename, "w", encoding="latin1", newline='') as fp:
    with open(filename, "w") as fp:
        fp.write(magic)
        #fp.write('%i %i\n%i\n' % (w, h, maxval))
        fp.write(f'{w} {h}\n{maxval}\n')
        for j in range(h):
            for i in range(w):
                val = im[i][j]
                c = val * 255
                #fp.write('%c%c%c' % (c, c, c))
                c = chr(c)
                fp.write(f'{c}{c}{c}')


class Chaosgame(object):
    splines: List[Spline]
    thickness: float
    minx: float
    miny: float
    maxx: float
    maxy: float
    height: float
    width: float
    num_trafos: List[int]
    num_total: int

    def __init__(self, splines, thickness=0.1):
        self.splines = splines
        self.thickness = thickness
        self.minx = min([p.x for spl in splines for p in spl.points])
        self.miny = min([p.y for spl in splines for p in spl.points])
        self.maxx = max([p.x for spl in splines for p in spl.points])
        self.maxy = max([p.y for spl in splines for p in spl.points])
        self.height = self.maxy - self.miny
        self.width = self.maxx - self.minx
        self.num_trafos = []
        maxlength = thickness * self.width / self.height
        for spl in splines:
            length = 0.
            curr = spl(0)
            for i in range(1, 1000):
                last = curr
                t = 1 / 999 * i
                curr = spl(t)
                length += curr.dist(last)
            self.num_trafos.append(max(1, int(length / maxlength * 1.5)))
        self.num_total = sum(self.num_trafos)

    def get_random_trafo(self):
        r = random.randrange(int(self.num_total) + 1)
        l = 0
        for i in range(len(self.num_trafos)):
            if r &gt;= l and r &lt; l + self.num_trafos[i]:
                return i, random.randrange(self.num_trafos[i])
            l += self.num_trafos[i]
        return len(self.num_trafos) - 1, random.randrange(self.num_trafos[-1])

    def transform_point(self, point):
        x = (point.x - self.minx) / self.width
        y = (point.y - self.miny) / self.height
        #if trafo is None:
        trafo = self.get_random_trafo()
        start, end = self.splines[trafo[0]].GetDomain()
        length = end - start
        seg_length = length / self.num_trafos[trafo[0]]
        t = start + seg_length * trafo[1] + seg_length * x
        basepoint = self.splines[trafo[0]](t)
        if t + 1 / 50000 &gt; end:
            neighbour = self.splines[trafo[0]](t - 1 / 50000)
            derivative = neighbour - basepoint
        else:
            neighbour = self.splines[trafo[0]](t + 1 / 50000)
            derivative = basepoint - neighbour
        if derivative.Mag() != 0:
            basepoint.x += derivative.y / derivative.Mag() * (y - 0.5) * \
                self.thickness
            basepoint.y += -derivative.x / derivative.Mag() * (y - 0.5) * \
                self.thickness
        else:
            print("r", end='')
        self.truncate(basepoint)
        return basepoint

    def truncate(self, point):
        if point.x &gt;= self.maxx:
            point.x = self.maxx
        if point.y &gt;= self.maxy:
            point.y = self.maxy
        if point.x &lt; self.minx:
            point.x = self.minx
        if point.y &lt; self.miny:
            point.y = self.miny

    def create_image_chaos(self, w, h, iterations, filename, rng_seed):
        # Always use the same sequence of random numbers
        # to get reproducible benchmark
        random.seed(rng_seed)

        im = [[1] * h for i in range(w)]
        point = GVector((self.maxx + self.minx) / 2,
                        (self.maxy + self.miny) / 2, 0)
        for _ in range(iterations):
            point = self.transform_point(point)
            x = (point.x - self.minx) / self.width * w
            y = (point.y - self.miny) / self.height * h
            x = int(x)
            y = int(y)
            if x == w:
                x -= 1
            if y == h:
                y -= 1
            im[x][h - y - 1] = 0

        if filename:
            write_ppm(im, filename)


def main():
    splines = [
        Spline([
            GVector(1.597350, 3.304460, 0.000000),
            GVector(1.575810, 4.123260, 0.000000),
            GVector(1.313210, 5.288350, 0.000000),
            GVector(1.618900, 5.329910, 0.000000),
            GVector(2.889940, 5.502700, 0.000000),
            GVector(2.373060, 4.381830, 0.000000),
            GVector(1.662000, 4.360280, 0.000000)],
            3, [0, 0, 0, 1, 1, 1, 2, 2, 2]),
        Spline([
            GVector(2.804500, 4.017350, 0.000000),
            GVector(2.550500, 3.525230, 0.000000),
            GVector(1.979010, 2.620360, 0.000000),
            GVector(1.979010, 2.620360, 0.000000)],
            3, [0, 0, 0, 1, 1, 1]),
        Spline([
            GVector(2.001670, 4.011320, 0.000000),
            GVector(2.335040, 3.312830, 0.000000),
            GVector(2.366800, 3.233460, 0.000000),
            GVector(2.366800, 3.233460, 0.000000)],
            3, [0, 0, 0, 1, 1, 1])
    ]

    chaos = Chaosgame(splines, DEFAULT_THICKNESS)
    chaos.create_image_chaos(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_ITERATIONS, sys.argv[1], DEFAULT_RNG_SEED)

t0 = time.time()
main()
t1 = time.time()
print(t1 - t0)
</t>
<t tx="ekr.20230509083242.180">int buildMode(const std::vector&lt;const char *&gt; &amp;args, const std::string &amp;argv0) {
  llvm::cl::list&lt;std::string&gt; libs(
      "l", llvm::cl::desc("Link the specified library (only for executables)"));
  llvm::cl::opt&lt;std::string&gt; lflags("linker-flags",
                                    llvm::cl::desc("Pass given flags to linker"));
  llvm::cl::opt&lt;BuildKind&gt; buildKind(
      llvm::cl::desc("output type"),
      llvm::cl::values(
          clEnumValN(LLVM, "llvm", "Generate LLVM IR"),
          clEnumValN(Bitcode, "bc", "Generate LLVM bitcode"),
          clEnumValN(Object, "obj", "Generate native object file"),
          clEnumValN(Executable, "exe", "Generate executable"),
          clEnumValN(Library, "lib", "Generate shared library"),
          clEnumValN(PyExtension, "pyext", "Generate Python extension module"),
          clEnumValN(Detect, "detect",
                     "Detect output type based on output file extension")),
      llvm::cl::init(Detect));
  llvm::cl::opt&lt;std::string&gt; output(
      "o",
      llvm::cl::desc(
          "Write compiled output to specified file. Supported extensions: "
          "none (executable), .o (object file), .ll (LLVM IR), .bc (LLVM bitcode)"));
  llvm::cl::opt&lt;std::string&gt; pyModule(
      "module", llvm::cl::desc("Python extension module name (only applicable when "
                               "building Python extension module)"));

  @others
  return EXIT_SUCCESS;
}

</t>
<t tx="ekr.20230509083242.181">auto compiler = processSource(args, /*standalone=*/true,
                              [&amp;] { return buildKind == BuildKind::PyExtension; });
if (!compiler)
  return EXIT_FAILURE;
std::vector&lt;std::string&gt; libsVec(libs);

if (output.empty() &amp;&amp; compiler-&gt;getInput() == "-")
  codon::compilationError("output file must be specified when reading from stdin");
std::string extension;
switch (buildKind) {
case BuildKind::LLVM:
  extension = ".ll";
  break;
case BuildKind::Bitcode:
  extension = ".bc";
  break;
case BuildKind::Object:
case BuildKind::PyExtension:
  extension = ".o";
  break;
case BuildKind::Library:
  extension = isMacOS() ? ".dylib" : ".so";
  break;
case BuildKind::Executable:
case BuildKind::Detect:
  extension = "";
  break;
default:
  seqassertn(0, "unknown build kind");
}
</t>
<t tx="ekr.20230509083242.182">const std::string filename =
    output.empty() ? makeOutputFilename(compiler-&gt;getInput(), extension) : output;
switch (buildKind) {
case BuildKind::LLVM:
  compiler-&gt;getLLVMVisitor()-&gt;writeToLLFile(filename);
  break;
case BuildKind::Bitcode:
  compiler-&gt;getLLVMVisitor()-&gt;writeToBitcodeFile(filename);
  break;
case BuildKind::Object:
  compiler-&gt;getLLVMVisitor()-&gt;writeToObjectFile(filename);
  break;
case BuildKind::Executable:
  compiler-&gt;getLLVMVisitor()-&gt;writeToExecutable(filename, argv0, false, libsVec,
                                                lflags);
  break;
case BuildKind::Library:
  compiler-&gt;getLLVMVisitor()-&gt;writeToExecutable(filename, argv0, true, libsVec,
                                                lflags);
  break;
case BuildKind::PyExtension:
  compiler-&gt;getCache()-&gt;pyModule-&gt;name =
      pyModule.empty() ? llvm::sys::path::stem(compiler-&gt;getInput()).str() : pyModule;
  compiler-&gt;getLLVMVisitor()-&gt;writeToPythonExtension(*compiler-&gt;getCache()-&gt;pyModule,
                                                     filename);
  break;
case BuildKind::Detect:
  compiler-&gt;getLLVMVisitor()-&gt;compile(filename, argv0, libsVec, lflags);
  break;
default:
  seqassertn(0, "unknown build kind");
}

</t>
<t tx="ekr.20230509083242.183">int jupyterMode(const std::vector&lt;const char *&gt; &amp;args) {
  llvm::cl::list&lt;std::string&gt; plugins("plugin",
                                      llvm::cl::desc("Load specified plugin"));
  llvm::cl::opt&lt;std::string&gt; input(llvm::cl::Positional,
                                   llvm::cl::desc("&lt;connection file&gt;"),
                                   llvm::cl::init("connection.json"));
  llvm::cl::ParseCommandLineOptions(args.size(), args.data());
  int code = codon::startJupyterKernel(args[0], plugins, input);
  return code;
}

</t>
<t tx="ekr.20230509083242.184">void showCommandsAndExit() {
  codon::compilationError("Available commands: codon &lt;run|build|doc&gt;");
}

</t>
<t tx="ekr.20230509083242.185">int otherMode(const std::vector&lt;const char *&gt; &amp;args) {
  llvm::cl::opt&lt;std::string&gt; input(llvm::cl::Positional, llvm::cl::desc("&lt;mode&gt;"));
  llvm::cl::extrahelp("\nMODES:\n\n"
                      "  run   - run a program interactively\n"
                      "  build - build a program\n"
                      "  doc   - generate program documentation\n");
  llvm::cl::ParseCommandLineOptions(args.size(), args.data());

  if (!input.empty())
    showCommandsAndExit();
  return EXIT_SUCCESS;
}

</t>
<t tx="ekr.20230509083242.186">int main(int argc, const char **argv) {
  if (argc &lt; 2)
    showCommandsAndExit();

  llvm::cl::SetVersionPrinter(versMsg);
  std::vector&lt;const char *&gt; args{argv[0]};
  for (int i = 2; i &lt; argc; i++)
    args.push_back(argv[i]);

  std::string mode(argv[1]);
  std::string argv0 = std::string(args[0]) + " " + mode;
  if (mode == "run") {
    args[0] = argv0.data();
    return runMode(args);
  }
  if (mode == "build") {
    const char *oldArgv0 = args[0];
    args[0] = argv0.data();
    return buildMode(args, oldArgv0);
  }
  if (mode == "doc") {
    const char *oldArgv0 = args[0];
    args[0] = argv0.data();
    return docMode(args, oldArgv0);
  }
  if (mode == "jit") {
    args[0] = argv0.data();
    return jitMode(args);
  }
  if (mode == "jupyter") {
    args[0] = argv0.data();
    return jupyterMode(args);
  }
  return otherMode({argv, argv + argc});
}
</t>
<t tx="ekr.20230509083242.187"></t>
<t tx="ekr.20230509083242.188">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "attribute.h"

#include "codon/cir/func.h"
#include "codon/cir/util/cloning.h"
#include "codon/cir/value.h"
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

const std::string KeyValueAttribute::AttributeName = "kvAttribute";

@others
std::string KeyValueAttribute::get(const std::string &amp;key) const {
  auto it = attributes.find(key);
  return it != attributes.end() ? it-&gt;second : "";
}

std::ostream &amp;KeyValueAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; keys;
  for (auto &amp;val : attributes)
    keys.push_back(val.second);
  fmt::print(os, FMT_STRING("{}"), fmt::join(keys.begin(), keys.end(), ","));
  return os;
}

const std::string MemberAttribute::AttributeName = "memberAttribute";

std::ostream &amp;MemberAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto &amp;val : memberSrcInfo)
    strings.push_back(fmt::format(FMT_STRING("{}={}"), val.first, val.second));
  fmt::print(os, FMT_STRING("({})"), fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

const std::string SrcInfoAttribute::AttributeName = "srcInfoAttribute";

const std::string DocstringAttribute::AttributeName = "docstringAttribute";

const std::string TupleLiteralAttribute::AttributeName = "tupleLiteralAttribute";

std::unique_ptr&lt;Attribute&gt; TupleLiteralAttribute::clone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;Value *&gt; elementsCloned;
  for (auto *val : elements)
    elementsCloned.push_back(cv.clone(val));
  return std::make_unique&lt;TupleLiteralAttribute&gt;(elementsCloned);
}

std::unique_ptr&lt;Attribute&gt;
TupleLiteralAttribute::forceClone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;Value *&gt; elementsCloned;
  for (auto *val : elements)
    elementsCloned.push_back(cv.forceClone(val));
  return std::make_unique&lt;TupleLiteralAttribute&gt;(elementsCloned);
}

std::ostream &amp;TupleLiteralAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto *val : elements)
    strings.push_back(fmt::format(FMT_STRING("{}"), *val));
  fmt::print(os, FMT_STRING("({})"), fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

const std::string ListLiteralAttribute::AttributeName = "listLiteralAttribute";

std::unique_ptr&lt;Attribute&gt; ListLiteralAttribute::clone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;LiteralElement&gt; elementsCloned;
  for (auto &amp;e : elements)
    elementsCloned.push_back({cv.clone(e.value), e.star});
  return std::make_unique&lt;ListLiteralAttribute&gt;(elementsCloned);
}

std::unique_ptr&lt;Attribute&gt;
ListLiteralAttribute::forceClone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;LiteralElement&gt; elementsCloned;
  for (auto &amp;e : elements)
    elementsCloned.push_back({cv.forceClone(e.value), e.star});
  return std::make_unique&lt;ListLiteralAttribute&gt;(elementsCloned);
}

std::ostream &amp;ListLiteralAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto &amp;e : elements)
    strings.push_back(fmt::format(FMT_STRING("{}{}"), e.star ? "*" : "", *e.value));
  fmt::print(os, FMT_STRING("[{}]"), fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

const std::string SetLiteralAttribute::AttributeName = "setLiteralAttribute";

std::unique_ptr&lt;Attribute&gt; SetLiteralAttribute::clone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;LiteralElement&gt; elementsCloned;
  for (auto &amp;e : elements)
    elementsCloned.push_back({cv.clone(e.value), e.star});
  return std::make_unique&lt;SetLiteralAttribute&gt;(elementsCloned);
}

std::unique_ptr&lt;Attribute&gt;
SetLiteralAttribute::forceClone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;LiteralElement&gt; elementsCloned;
  for (auto &amp;e : elements)
    elementsCloned.push_back({cv.forceClone(e.value), e.star});
  return std::make_unique&lt;SetLiteralAttribute&gt;(elementsCloned);
}

std::ostream &amp;SetLiteralAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto &amp;e : elements)
    strings.push_back(fmt::format(FMT_STRING("{}{}"), e.star ? "*" : "", *e.value));
  fmt::print(os, FMT_STRING("set([{}])"),
             fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

const std::string DictLiteralAttribute::AttributeName = "dictLiteralAttribute";

std::unique_ptr&lt;Attribute&gt; DictLiteralAttribute::clone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;DictLiteralAttribute::KeyValuePair&gt; elementsCloned;
  for (auto &amp;val : elements)
    elementsCloned.push_back(
        {cv.clone(val.key), val.value ? cv.clone(val.value) : nullptr});
  return std::make_unique&lt;DictLiteralAttribute&gt;(elementsCloned);
}

std::unique_ptr&lt;Attribute&gt;
DictLiteralAttribute::forceClone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;DictLiteralAttribute::KeyValuePair&gt; elementsCloned;
  for (auto &amp;val : elements)
    elementsCloned.push_back(
        {cv.forceClone(val.key), val.value ? cv.forceClone(val.value) : nullptr});
  return std::make_unique&lt;DictLiteralAttribute&gt;(elementsCloned);
}

std::ostream &amp;DictLiteralAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto &amp;val : elements) {
    if (val.value) {
      strings.push_back(fmt::format(FMT_STRING("{}:{}"), *val.key, *val.value));
    } else {
      strings.push_back(fmt::format(FMT_STRING("**{}"), *val.key));
    }
  }
  fmt::print(os, FMT_STRING("dict([{}])"),
             fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

const std::string PartialFunctionAttribute::AttributeName = "partialFunctionAttribute";

std::unique_ptr&lt;Attribute&gt;
PartialFunctionAttribute::clone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;Value *&gt; argsCloned;
  for (auto *val : args)
    argsCloned.push_back(cv.clone(val));
  return std::make_unique&lt;PartialFunctionAttribute&gt;(name, argsCloned);
}

std::unique_ptr&lt;Attribute&gt;
PartialFunctionAttribute::forceClone(util::CloneVisitor &amp;cv) const {
  std::vector&lt;Value *&gt; argsCloned;
  for (auto *val : args)
    argsCloned.push_back(cv.forceClone(val));
  return std::make_unique&lt;PartialFunctionAttribute&gt;(name, argsCloned);
}

std::ostream &amp;PartialFunctionAttribute::doFormat(std::ostream &amp;os) const {
  std::vector&lt;std::string&gt; strings;
  for (auto *val : args)
    strings.push_back(val ? fmt::format(FMT_STRING("{}"), *val) : "...");
  fmt::print(os, FMT_STRING("{}({})"), name,
             fmt::join(strings.begin(), strings.end(), ","));
  return os;
}

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.189">bool KeyValueAttribute::has(const std::string &amp;key) const {
  return attributes.find(key) != attributes.end();
}

</t>
<t tx="ekr.20230509083242.19">@path C:/Repos/codon/bench/chaos/
"""create chaosgame-like fractals
Copyright (C) 2005 Carl Friedrich Bolz

adapted by @arshajii for Codon
"""

import math
import random
import sys
import time

DEFAULT_THICKNESS = 1.0
DEFAULT_WIDTH = 2048 #256
DEFAULT_HEIGHT = 2048 #256
DEFAULT_ITERATIONS = 1000000 #5000
DEFAULT_RNG_SEED = 1234


@others
t0 = time.time()
main()
t1 = time.time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.190">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/util/common.h"

namespace codon {
namespace ir {

class Func;
class Value;

namespace util {
class CloneVisitor;
}

/// Base for CIR attributes.
struct Attribute {
  virtual ~Attribute() noexcept = default;

  /// @return true if the attribute should be propagated across clones
  virtual bool needsClone() const { return true; }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Attribute &amp;a) {
    return a.doFormat(os);
  }

  /// @return a clone of the attribute
  virtual std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const = 0;

  /// @return a clone of the attribute
  virtual std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const {
    return clone(cv);
  }

private:
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

/// Attribute containing SrcInfo
struct SrcInfoAttribute : public Attribute {
  static const std::string AttributeName;

  /// source info
  codon::SrcInfo info;

  SrcInfoAttribute() = default;
  /// Constructs a SrcInfoAttribute.
  /// @param info the source info
  explicit SrcInfoAttribute(codon::SrcInfo info) : info(std::move(info)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;SrcInfoAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; info; }
};

/// Attribute containing docstring from source
struct DocstringAttribute : public Attribute {
  static const std::string AttributeName;

  /// the docstring
  std::string docstring;

  DocstringAttribute() = default;
  /// Constructs a DocstringAttribute.
  /// @param docstring the docstring
  explicit DocstringAttribute(const std::string &amp;docstring) : docstring(docstring) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;DocstringAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override { return os &lt;&lt; docstring; }
};

/// Attribute containing function information
struct KeyValueAttribute : public Attribute {
  static const std::string AttributeName;

  /// attributes map
  std::map&lt;std::string, std::string&gt; attributes;

  KeyValueAttribute() = default;
  /// Constructs a KeyValueAttribute.
  /// @param attributes the map of attributes
  explicit KeyValueAttribute(std::map&lt;std::string, std::string&gt; attributes)
      : attributes(std::move(attributes)) {}

  /// @param key the key
  /// @return true if the map contains key, false otherwise
  bool has(const std::string &amp;key) const;

  /// @param key the key
  /// @return the value associated with the given key, or empty
  ///         string if none
  std::string get(const std::string &amp;key) const;

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;KeyValueAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute containing type member information
struct MemberAttribute : public Attribute {
  static const std::string AttributeName;

  /// member source info map
  std::map&lt;std::string, SrcInfo&gt; memberSrcInfo;

  MemberAttribute() = default;
  /// Constructs a KeyValueAttribute.
  /// @param attributes the map of attributes
  explicit MemberAttribute(std::map&lt;std::string, SrcInfo&gt; memberSrcInfo)
      : memberSrcInfo(std::move(memberSrcInfo)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override {
    return std::make_unique&lt;MemberAttribute&gt;(*this);
  }

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to tuple literals
struct TupleLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// values contained in tuple literal
  std::vector&lt;Value *&gt; elements;

  explicit TupleLiteralAttribute(std::vector&lt;Value *&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Information about an element in a collection literal
struct LiteralElement {
  /// the element value
  Value *value;
  /// true if preceded by "*", as in "[*x]"
  bool star;
};

/// Attribute attached to IR structures corresponding to list literals
struct ListLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// elements contained in list literal
  std::vector&lt;LiteralElement&gt; elements;

  explicit ListLiteralAttribute(std::vector&lt;LiteralElement&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to set literals
struct SetLiteralAttribute : public Attribute {
  static const std::string AttributeName;

  /// elements contained in set literal
  std::vector&lt;LiteralElement&gt; elements;

  explicit SetLiteralAttribute(std::vector&lt;LiteralElement&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to dict literals
struct DictLiteralAttribute : public Attribute {
  struct KeyValuePair {
    /// the key in the literal
    Value *key;
    /// the value in the literal, or null if key is being star-unpacked
    Value *value;
  };

  static const std::string AttributeName;

  /// keys and values contained in dict literal
  std::vector&lt;KeyValuePair&gt; elements;

  explicit DictLiteralAttribute(std::vector&lt;KeyValuePair&gt; elements)
      : elements(std::move(elements)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

/// Attribute attached to IR structures corresponding to partial functions
struct PartialFunctionAttribute : public Attribute {
  static const std::string AttributeName;

  /// base name of the function being used in the partial
  std::string name;

  /// partial arguments, or null if none
  /// e.g. "f(a, ..., b)" has elements [a, null, b]
  std::vector&lt;Value *&gt; args;

  PartialFunctionAttribute(const std::string &amp;name, std::vector&lt;Value *&gt; args)
      : name(name), args(std::move(args)) {}

  std::unique_ptr&lt;Attribute&gt; clone(util::CloneVisitor &amp;cv) const override;
  std::unique_ptr&lt;Attribute&gt; forceClone(util::CloneVisitor &amp;cv) const override;

private:
  std::ostream &amp;doFormat(std::ostream &amp;os) const override;
};

} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Attribute&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.191">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "base.h"

#include "codon/cir/types/types.h"
#include "codon/cir/util/format.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

id_t IdMixin::currentId = 0;

void IdMixin::resetId() { currentId = 0; }

const char Node::NodeId = 0;

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Node &amp;other) {
  return util::format(os, &amp;other);
}

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.192">int Node::replaceUsedValue(Value *old, Value *newValue) {
  return replaceUsedValue(old-&gt;getId(), newValue);
}

</t>
<t tx="ekr.20230509083242.193">int Node::replaceUsedType(types::Type *old, types::Type *newType) {
  return replaceUsedType(old-&gt;getName(), newType);
}

</t>
<t tx="ekr.20230509083242.194">int Node::replaceUsedVariable(Var *old, Var *newVar) {
  return replaceUsedVariable(old-&gt;getId(), newVar);
}

</t>
<t tx="ekr.20230509083242.195">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;cstdint&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/cir/attribute.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/util/visitor.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

using id_t = std::int64_t;

class Func;
class Module;

@others
template &lt;typename Derived&gt; const char ReplaceableNodeBase&lt;Derived&gt;::NodeId = 0;

template &lt;typename Desired&gt; Desired *cast(Node *other) {
  return other != nullptr ? other-&gt;as&lt;Desired&gt;() : nullptr;
}

template &lt;typename Desired&gt; const Desired *cast(const Node *other) {
  return other != nullptr ? other-&gt;as&lt;Desired&gt;() : nullptr;
}

template &lt;typename Desired&gt; bool isA(Node *other) {
  return other &amp;&amp; other-&gt;is&lt;Desired&gt;();
}

template &lt;typename Desired&gt; bool isA(const Node *other) {
  return other &amp;&amp; other-&gt;is&lt;Desired&gt;();
}

} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Node&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.196">/// Mixin class for IR nodes that need ids.
class IdMixin {
private:
  /// the global id counter
  static id_t currentId;

protected:
  /// the instance's id
  id_t id;

public:
  /// Resets the global id counter.
  static void resetId();

  IdMixin() : id(currentId++) {}

  /// @return the node's id.
  virtual id_t getId() const { return id; }
};

</t>
<t tx="ekr.20230509083242.197">/// Base for named IR nodes.
class Node {
private:
  /// the node's name
  std::string name;
  /// key-value attribute store
  std::map&lt;std::string, std::unique_ptr&lt;Attribute&gt;&gt; attributes;
  /// the module
  Module *module = nullptr;
  /// a replacement, if set
  Node *replacement = nullptr;

public:
  // RTTI is implemented using a port of LLVM's Extensible RTTI
  // For more details, see
  // https://llvm.org/docs/HowToSetUpLLVMStyleRTTI.html#rtti-for-open-class-hierarchies
  static const char NodeId;

  /// Constructs a node.
  /// @param name the node's name
  explicit Node(std::string name = "") : name(std::move(name)) {}

  /// See LLVM documentation.
  static const void *nodeId() { return &amp;NodeId; }
  /// See LLVM documentation.
  virtual bool isConvertible(const void *other) const {
    if (hasReplacement())
      return getActual()-&gt;isConvertible(other);
    return other == nodeId();
  }
  /// See LLVM documentation.
  template &lt;typename Target&gt; bool is() const { return isConvertible(Target::nodeId()); }
  /// See LLVM documentation.
  template &lt;typename Target&gt; Target *as() {
    return isConvertible(Target::nodeId()) ? static_cast&lt;Target *&gt;(getActual())
                                           : nullptr;
  }
  /// See LLVM documentation.
  template &lt;typename Target&gt; const Target *as() const {
    return isConvertible(Target::nodeId()) ? static_cast&lt;const Target *&gt;(getActual())
                                           : nullptr;
  }

  /// @return the node's name
  const std::string &amp;getName() const { return getActual()-&gt;name; }
  /// Sets the node's name
  /// @param n the new name
  void setName(std::string n) { getActual()-&gt;name = std::move(n); }

  /// Accepts visitors.
  /// @param v the visitor
  virtual void accept(util::Visitor &amp;v) = 0;
  /// Accepts visitors.
  /// @param v the visitor
  virtual void accept(util::ConstVisitor &amp;v) const = 0;

@others
};

</t>
<t tx="ekr.20230509083242.198">  /// Sets an attribute
  /// @param the attribute key
  /// @param value the attribute
  void setAttribute(std::unique_ptr&lt;Attribute&gt; value, const std::string &amp;key) {
    getActual()-&gt;attributes[key] = std::move(value);
  }
</t>
<t tx="ekr.20230509083242.199">  /// Sets an attribute
  /// @param value the attribute
  template &lt;typename AttributeType&gt;
  void setAttribute(std::unique_ptr&lt;AttributeType&gt; value) {
    setAttribute(std::move(value), AttributeType::AttributeName);
  }

</t>
<t tx="ekr.20230509083242.20">class GVector(object):

    @others
</t>
<t tx="ekr.20230509083242.200">  /// @param n the name
  /// @return true if the attribute is in the store
  bool hasAttribute(const std::string &amp;n) const {
    auto *actual = getActual();
    return actual-&gt;attributes.find(n) != actual-&gt;attributes.end();
  }
</t>
<t tx="ekr.20230509083242.201">  /// @return true if the attribute is in the store
  template &lt;typename AttributeType&gt; bool hasAttribute() const {
    return hasAttribute(AttributeType::AttributeName);
  }

  /// Gets the appropriate attribute.
  /// @param key the attribute key
  Attribute *getAttribute(const std::string &amp;key) {
    auto *actual = getActual();

    auto it = actual-&gt;attributes.find(key);
    return it != actual-&gt;attributes.end() ? it-&gt;second.get() : nullptr;
  }
</t>
<t tx="ekr.20230509083242.202">  /// Gets the appropriate attribute.
  /// @param key the attribute key
  const Attribute *getAttribute(const std::string &amp;key) const {
    auto *actual = getActual();

    auto it = actual-&gt;attributes.find(key);
    return it != actual-&gt;attributes.end() ? it-&gt;second.get() : nullptr;
  }
</t>
<t tx="ekr.20230509083242.203">  /// Gets the appropriate attribute.
  /// @tparam AttributeType the return type
  template &lt;typename AttributeType&gt; AttributeType *getAttribute() {
    return static_cast&lt;AttributeType *&gt;(getAttribute(AttributeType::AttributeName));
  }
  /// Gets the appropriate attribute.
  /// @tparam AttributeType the return type
  template &lt;typename AttributeType&gt; const AttributeType *getAttribute() const {
    return static_cast&lt;const AttributeType *&gt;(
        getAttribute(AttributeType::AttributeName));
  }

</t>
<t tx="ekr.20230509083242.204">  /// @return iterator to the first attribute
  auto attributes_begin() {
    return util::map_key_adaptor(getActual()-&gt;attributes.begin());
  }
</t>
<t tx="ekr.20230509083242.205">  /// @return iterator beyond the last attribute
  auto attributes_end() { return util::map_key_adaptor(getActual()-&gt;attributes.end()); }
</t>
<t tx="ekr.20230509083242.206">  /// @return iterator to the first attribute
  auto attributes_begin() const {
    return util::const_map_key_adaptor(getActual()-&gt;attributes.begin());
  }
</t>
<t tx="ekr.20230509083242.207">  /// @return iterator beyond the last attribute
  auto attributes_end() const {
    return util::const_map_key_adaptor(getActual()-&gt;attributes.end());
  }

</t>
<t tx="ekr.20230509083242.208">  /// Helper to add source information.
  /// @param the source information
  void setSrcInfo(codon::SrcInfo s) {
    setAttribute(std::make_unique&lt;SrcInfoAttribute&gt;(std::move(s)));
  }
</t>
<t tx="ekr.20230509083242.209">  /// @return the src info
  codon::SrcInfo getSrcInfo() const {
    return getAttribute&lt;SrcInfoAttribute&gt;() ? getAttribute&lt;SrcInfoAttribute&gt;()-&gt;info
                                            : codon::SrcInfo();
  }

  /// @return a text representation of a reference to the object
  virtual std::string referenceString() const { return getActual()-&gt;name; }

  /// @return the IR module
  Module *getModule() const { return getActual()-&gt;module; }
  /// Sets the module.
  /// @param m the new module
  void setModule(Module *m) { getActual()-&gt;module = m; }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Node &amp;a);

  bool hasReplacement() const { return replacement != nullptr; }

  /// @return a vector of all the node's children
  virtual std::vector&lt;Value *&gt; getUsedValues() { return {}; }
  /// @return a vector of all the node's children
  virtual std::vector&lt;const Value *&gt; getUsedValues() const { return {}; }
  /// Physically replaces all instances of a child value.
  /// @param id the id of the value to be replaced
  /// @param newValue the new value
  /// @return number of replacements
  virtual int replaceUsedValue(id_t id, Value *newValue) { return 0; }
  /// Physically replaces all instances of a child value.
  /// @param oldValue the old value
  /// @param newValue the new value
  /// @return number of replacements
  int replaceUsedValue(Value *old, Value *newValue);

  /// @return a vector of all the node's used types
  virtual std::vector&lt;types::Type *&gt; getUsedTypes() const { return {}; }
  /// Physically replaces all instances of a used type.
  /// @param name the name of the type being replaced
  /// @param newType the new type
  /// @return number of replacements
  virtual int replaceUsedType(const std::string &amp;name, types::Type *newType) {
    return 0;
  }
  /// Physically replaces all instances of a used type.
  /// @param old the old type
  /// @param newType the new type
  /// @return number of replacements
  int replaceUsedType(types::Type *old, types::Type *newType);

  /// @return a vector of all the node's used variables
  virtual std::vector&lt;Var *&gt; getUsedVariables() { return {}; }
  /// @return a vector of all the node's used variables
  virtual std::vector&lt;const Var *&gt; getUsedVariables() const { return {}; }
  /// Physically replaces all instances of a used variable.
  /// @param id the id of the variable
  /// @param newType the new type
  /// @return number of replacements
  virtual int replaceUsedVariable(id_t id, Var *newVar) { return 0; }
  /// Physically replaces all instances of a used variable.
  /// @param old the old variable
  /// @param newVar the new variable
  /// @return number of replacements
  int replaceUsedVariable(Var *old, Var *newVar);

  template &lt;typename, typename&gt; friend class AcceptorExtend;
  template &lt;typename&gt; friend class ReplaceableNodeBase;

private:
  Node *getActual() { return replacement ? replacement-&gt;getActual() : this; }
</t>
<t tx="ekr.20230509083242.21">def __init__(self, x=0, y=0, z=0):
    self.x = x
    self.y = y
    self.z = z

</t>
<t tx="ekr.20230509083242.210">  const Node *getActual() const {
    return replacement ? replacement-&gt;getActual() : this;
  }
</t>
<t tx="ekr.20230509083242.211">template &lt;typename Derived, typename Parent&gt; class AcceptorExtend : public Parent {
public:
  using Parent::Parent;

  /// See LLVM documentation.
  static const void *nodeId() { return &amp;Derived::NodeId; }
  /// See LLVM documentation.
  virtual bool isConvertible(const void *other) const {
    if (Node::hasReplacement())
      return Node::getActual()-&gt;isConvertible(other);

    return other == nodeId() || Parent::isConvertible(other);
  }

</t>
<t tx="ekr.20230509083242.212">  void accept(util::Visitor &amp;v) {
    if (Node::hasReplacement())
      Node::getActual()-&gt;accept(v);
    else
      v.visit(static_cast&lt;Derived *&gt;(this));
  }

</t>
<t tx="ekr.20230509083242.213">  void accept(util::ConstVisitor &amp;v) const {
    if (Node::hasReplacement())
      Node::getActual()-&gt;accept(v);
    else
      v.visit(static_cast&lt;const Derived *&gt;(this));
  }
</t>
<t tx="ekr.20230509083242.214">};

</t>
<t tx="ekr.20230509083242.215">template &lt;typename Derived&gt;
@others
</t>
<t tx="ekr.20230509083242.216">class ReplaceableNodeBase : public AcceptorExtend&lt;Derived, Node&gt; {
private:
  /// true if the node can be lazily replaced
  bool replaceable = true;

public:
  using AcceptorExtend&lt;Derived, Node&gt;::AcceptorExtend;

  static const char NodeId;

  /// @return the logical value of the node
  Derived *getActual() {
    return Node::replacement ? static_cast&lt;Derived *&gt;(Node::replacement)-&gt;getActual()
                             : static_cast&lt;Derived *&gt;(this);
  }

@others
  /// @return true if the object can be replaced
  bool isReplaceable() const { return replaceable; }
  /// Sets the object's replaceable flag.
  /// @param v the new value
  void setReplaceable(bool v = true) { replaceable = v; }
};

</t>
<t tx="ekr.20230509083242.217">  /// @return the logical value of the node
  const Derived *getActual() const {
    return Node::replacement
               ? static_cast&lt;const Derived *&gt;(Node::replacement)-&gt;getActual()
               : static_cast&lt;const Derived *&gt;(this);
  }

</t>
<t tx="ekr.20230509083242.218">  /// Lazily replaces all instances of the node.
  /// @param v the new value
  void replaceAll(Derived *v) {
    seqassertn(replaceable, "node {} not replaceable", *v);
    Node::replacement = v;
  }

</t>
<t tx="ekr.20230509083242.219">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/const.h"
#include "codon/cir/dsl/nodes.h"
#include "codon/cir/flow.h"
#include "codon/cir/func.h"
#include "codon/cir/instr.h"
#include "codon/cir/module.h"
#include "codon/cir/types/types.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.22">def Mag(self):
    return math.sqrt(self.x ** 2 + self.y ** 2 + self.z ** 2)

</t>
<t tx="ekr.20230509083242.220">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "const.h"

namespace codon {
namespace ir {

const char Const::NodeId = 0;

@others
const char TemplatedConst&lt;std::string&gt;::NodeId = 0;

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.221">int Const::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  if (type-&gt;getName() == name) {
    type = newType;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.222">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/module.h"
#include "codon/cir/value.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.223">/// CIR constant base. Once created, constants are immutable.
class Const : public AcceptorExtend&lt;Const, Value&gt; {
private:
  /// the type
  types::Type *type;

public:
  static const char NodeId;

  /// Constructs a constant.
  /// @param type the type
  /// @param name the name
  explicit Const(types::Type *type, std::string name = "")
      : AcceptorExtend(std::move(name)), type(type) {}

private:
  types::Type *doGetType() const override { return type; }

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {type}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509083242.224">template &lt;typename ValueType&gt;
@others
</t>
<t tx="ekr.20230509083242.225">class TemplatedConst : public AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt; {
private:
  ValueType val;

public:
  static const char NodeId;

  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getModule;
  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getSrcInfo;
  using AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;::getType;

  TemplatedConst(ValueType v, types::Type *type, std::string name = "")
      : AcceptorExtend&lt;TemplatedConst&lt;ValueType&gt;, Const&gt;(type, std::move(name)),
        val(v) {}

  /// @return the internal value.
  ValueType getVal() const { return val; }
  /// Sets the value.
  /// @param v the value
  void setVal(ValueType v) { val = v; }
};

</t>
<t tx="ekr.20230509083242.226">using IntConst = TemplatedConst&lt;int64_t&gt;;
using FloatConst = TemplatedConst&lt;double&gt;;
using BoolConst = TemplatedConst&lt;bool&gt;;
using StringConst = TemplatedConst&lt;std::string&gt;;

template &lt;typename T&gt; const char TemplatedConst&lt;T&gt;::NodeId = 0;

</t>
<t tx="ekr.20230509083242.227">template &lt;&gt;
@others
</t>
<t tx="ekr.20230509083242.228">class TemplatedConst&lt;std::string&gt;
    : public AcceptorExtend&lt;TemplatedConst&lt;std::string&gt;, Const&gt; {
private:
  std::string val;

public:
  static const char NodeId;

  TemplatedConst(std::string v, types::Type *type, std::string name = "")
      : AcceptorExtend(type, std::move(name)), val(std::move(v)) {}

  /// @return the internal value.
  std::string getVal() const { return val; }
  /// Sets the value.
  /// @param v the value
  void setVal(std::string v) { val = std::move(v); }
};

</t>
<t tx="ekr.20230509083242.229">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "flow.h"

#include "codon/cir/module.h"
#include "codon/cir/util/iterators.h"
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {
namespace {
@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.23">def dist(self, other):
    return math.sqrt((self.x - other.x) ** 2
                     + (self.y - other.y) ** 2
                     + (self.z - other.z) ** 2)

</t>
<t tx="ekr.20230509083242.230">int findAndReplace(id_t id, codon::ir::Value *newVal,
                   std::list&lt;codon::ir::Value *&gt; &amp;values) {
  auto replacements = 0;
  for (auto &amp;value : values) {
    if (value-&gt;getId() == id) {
      value = newVal;
      ++replacements;
    }
  }
  return replacements;
}
</t>
<t tx="ekr.20230509083242.231">} // namespace

const char Flow::NodeId = 0;

types::Type *Flow::doGetType() const { return getModule()-&gt;getNoneType(); }

const char SeriesFlow::NodeId = 0;

</t>
<t tx="ekr.20230509083242.232">int SeriesFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  return findAndReplace(id, newValue, series);
}

</t>
<t tx="ekr.20230509083242.233">const char WhileFlow::NodeId = 0;

</t>
<t tx="ekr.20230509083242.234">int WhileFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;

  if (cond-&gt;getId() == id) {
    cond = newValue;
    ++replacements;
  }
  if (body-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    body = f;
    ++replacements;
  }
  return replacements;
}

</t>
<t tx="ekr.20230509083242.235">const char ForFlow::NodeId = 0;

std::vector&lt;Value *&gt; ForFlow::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret;
  if (isParallel())
    ret = getSchedule()-&gt;getUsedValues();
  ret.push_back(iter);
  ret.push_back(body);
  return ret;
}

</t>
<t tx="ekr.20230509083242.236">int ForFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto count = 0;
  if (isParallel())
    count += getSchedule()-&gt;replaceUsedValue(id, newValue);
  if (iter-&gt;getId() == id) {
    iter = newValue;
    ++count;
  }
  if (body-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    body = f;
    ++count;
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.237">int ForFlow::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (var-&gt;getId() == id) {
    var = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.238">const char ImperativeForFlow::NodeId = 0;

std::vector&lt;Value *&gt; ImperativeForFlow::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret;
  if (isParallel())
    ret = getSchedule()-&gt;getUsedValues();
  ret.push_back(start);
  ret.push_back(end);
  ret.push_back(body);
  return ret;
}

</t>
<t tx="ekr.20230509083242.239">int ImperativeForFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto count = 0;
  if (isParallel())
    count += getSchedule()-&gt;replaceUsedValue(id, newValue);
  if (body-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    body = f;
    ++count;
  }
  if (start-&gt;getId() == id) {
    start = newValue;
    ++count;
  }
  if (end-&gt;getId() == id) {
    end = newValue;
    ++count;
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.24">def __add__(self, other):
    if not isinstance(other, GVector):
        raise ValueError("Can't add GVector to " + str(type(other)))
    v = GVector(self.x + other.x, self.y + other.y, self.z + other.z)
    return v

</t>
<t tx="ekr.20230509083242.240">int ImperativeForFlow::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (var-&gt;getId() == id) {
    var = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.241">const char IfFlow::NodeId = 0;

std::vector&lt;Value *&gt; IfFlow::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret = {cond, trueBranch};
  if (falseBranch)
    ret.push_back(falseBranch);
  return ret;
}

</t>
<t tx="ekr.20230509083242.242">int IfFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;

  if (cond-&gt;getId() == id) {
    cond = newValue;
    ++replacements;
  }
  if (trueBranch-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    trueBranch = f;
    ++replacements;
  }
  if (falseBranch &amp;&amp; falseBranch-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    falseBranch = f;
    ++replacements;
  }

  return replacements;
}

</t>
<t tx="ekr.20230509083242.243">const char TryCatchFlow::NodeId = 0;

std::vector&lt;Value *&gt; TryCatchFlow::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret = {body};
  if (finally)
    ret.push_back(finally);

  for (auto &amp;c : catches)
    ret.push_back(const_cast&lt;Value *&gt;(static_cast&lt;const Value *&gt;(c.getHandler())));
  return ret;
}

</t>
<t tx="ekr.20230509083242.244">int TryCatchFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;

  if (body-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    body = f;
    ++replacements;
  }
  if (finally &amp;&amp; finally-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    finally = f;
    ++replacements;
  }

  for (auto &amp;c : catches) {
    if (c.getHandler()-&gt;getId() == id) {
      auto *f = cast&lt;Flow&gt;(newValue);
      seqassert(f, "{} is not a flow", *newValue);
      c.setHandler(f);
      ++replacements;
    }
  }

  return replacements;
}

</t>
<t tx="ekr.20230509083242.245">std::vector&lt;types::Type *&gt; TryCatchFlow::doGetUsedTypes() const {
  std::vector&lt;types::Type *&gt; ret;
  for (auto &amp;c : catches) {
    if (auto *t = c.getType())
      ret.push_back(const_cast&lt;types::Type *&gt;(t));
  }
  return ret;
}

</t>
<t tx="ekr.20230509083242.246">int TryCatchFlow::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  auto count = 0;
  for (auto &amp;c : catches) {
    if (c.getType()-&gt;getName() == name) {
      c.setType(newType);
      ++count;
    }
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.247">std::vector&lt;Var *&gt; TryCatchFlow::doGetUsedVariables() const {
  std::vector&lt;Var *&gt; ret;
  for (auto &amp;c : catches) {
    if (auto *t = c.getVar())
      ret.push_back(const_cast&lt;Var *&gt;(t));
  }
  return ret;
}

</t>
<t tx="ekr.20230509083242.248">int TryCatchFlow::doReplaceUsedVariable(id_t id, Var *newVar) {
  auto count = 0;
  for (auto &amp;c : catches) {
    if (c.getVar()-&gt;getId() == id) {
      c.setVar(newVar);
      ++count;
    }
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.249">const char PipelineFlow::NodeId = 0;

types::Type *PipelineFlow::Stage::getOutputType() const {
  if (args.empty()) {
    return callee-&gt;getType();
  } else {
    auto *funcType = cast&lt;types::FuncType&gt;(callee-&gt;getType());
    seqassertn(funcType, "{} is not a function type", *callee-&gt;getType());
    return funcType-&gt;getReturnType();
  }
}

types::Type *PipelineFlow::Stage::getOutputElementType() const {
  if (isGenerator()) {
    types::GeneratorType *genType = nullptr;
    if (args.empty()) {
      genType = cast&lt;types::GeneratorType&gt;(callee-&gt;getType());
      return genType-&gt;getBase();
    } else {
      auto *funcType = cast&lt;types::FuncType&gt;(callee-&gt;getType());
      seqassertn(funcType, "{} is not a function type", *callee-&gt;getType());
      genType = cast&lt;types::GeneratorType&gt;(funcType-&gt;getReturnType());
    }
    seqassertn(genType, "generator type not found");
    return genType-&gt;getBase();
  } else if (args.empty()) {
    return callee-&gt;getType();
  } else {
    auto *funcType = cast&lt;types::FuncType&gt;(callee-&gt;getType());
    seqassertn(funcType, "{} is not a function type", *callee-&gt;getType());
    return funcType-&gt;getReturnType();
  }
}

std::vector&lt;Value *&gt; PipelineFlow::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret;
  for (auto &amp;s : stages) {
    ret.push_back(const_cast&lt;Value *&gt;(s.getCallee()));
    for (auto *arg : s.args)
      if (arg)
        ret.push_back(arg);
  }
  return ret;
}

</t>
<t tx="ekr.20230509083242.25">def __sub__(self, other):
    return self + other * -1

</t>
<t tx="ekr.20230509083242.250">int PipelineFlow::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;

  for (auto &amp;c : stages) {
    if (c.getCallee()-&gt;getId() == id) {
      c.setCallee(newValue);
      ++replacements;
    }
    for (auto &amp;s : c.args)
      if (s &amp;&amp; s-&gt;getId() == id) {
        s = newValue;
        ++replacements;
      }
  }

  return replacements;
}

</t>
<t tx="ekr.20230509083242.251">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;list&gt;
#include &lt;vector&gt;

#include "codon/cir/base.h"
#include "codon/cir/transform/parallel/schedule.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.252">/// Base for flows, which represent control flow.
class Flow : public AcceptorExtend&lt;Flow, Value&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

protected:
  types::Type *doGetType() const final;
};

</t>
<t tx="ekr.20230509083242.253">/// Flow that contains a series of flows or instructions.
class SeriesFlow : public AcceptorExtend&lt;SeriesFlow, Flow&gt; {
private:
  std::list&lt;Value *&gt; series;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return an iterator to the first instruction/flow
  auto begin() { return series.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() { return series.end(); }
  /// @return an iterator to the first instruction/flow
  auto begin() const { return series.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() const { return series.end(); }

  /// @return a pointer to the first instruction/flow
  Value *front() { return series.front(); }
  /// @return a pointer to the last instruction/flow
  Value *back() { return series.back(); }
  /// @return a pointer to the first instruction/flow
  const Value *front() const { return series.front(); }
  /// @return a pointer to the last instruction/flow
  const Value *back() const { return series.back(); }

  /// Inserts an instruction/flow at the given position.
  /// @param pos the position
  /// @param v the flow or instruction
  /// @return an iterator to the newly added instruction/flow
  template &lt;typename It&gt; auto insert(It pos, Value *v) { return series.insert(pos, v); }
  /// Appends an instruction/flow.
  /// @param f the flow or instruction
  void push_back(Value *f) { series.push_back(f); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed flow or instruction
  template &lt;typename It&gt; auto erase(It pos) { return series.erase(pos); }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return std::vector&lt;Value *&gt;(series.begin(), series.end());
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.254">/// Flow representing a while loop.
class WhileFlow : public AcceptorExtend&lt;WhileFlow, Flow&gt; {
private:
  /// the condition
  Value *cond;
  /// the body
  Value *body;

public:
  static const char NodeId;

  /// Constructs a while loop.
  /// @param cond the condition
  /// @param body the body
  /// @param name the flow's name
  WhileFlow(Value *cond, Flow *body, std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), body(body) {}

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param c the new condition
  void setCond(Value *c) { cond = c; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new value
  void setBody(Flow *f) { body = f; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {cond, body}; }

  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.255">/// Flow representing a for loop.
class ForFlow : public AcceptorExtend&lt;ForFlow, Flow&gt; {
private:
  /// the iterator
  Value *iter;
  /// the body
  Value *body;
  /// the variable
  Var *var;
  /// parallel loop schedule, or null if none
  std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule;

public:
  static const char NodeId;

  /// Constructs a for loop.
  /// @param iter the iterator
  /// @param body the body
  /// @param var the variable
  /// @param name the flow's name
  ForFlow(Value *iter, Flow *body, Var *var,
          std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule = {},
          std::string name = "")
      : AcceptorExtend(std::move(name)), iter(iter), body(body), var(var),
        schedule(std::move(schedule)) {}

  /// @return the iter
  Value *getIter() { return iter; }
  /// @return the iter
  const Value *getIter() const { return iter; }
  /// Sets the iter.
  /// @param f the new iter
  void setIter(Value *f) { iter = f; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new body
  void setBody(Flow *f) { body = f; }

  /// @return the var
  Var *getVar() { return var; }
  /// @return the var
  const Var *getVar() const { return var; }
  /// Sets the var.
  /// @param c the new var
  void setVar(Var *c) { var = c; }

  /// @return true if parallel
  bool isParallel() const { return bool(schedule); }
@others
protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {var}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.256">  /// Sets parallel status.
  /// @param a true if parallel
  void setParallel(bool a = true) {
    if (a)
      schedule = std::make_unique&lt;transform::parallel::OMPSched&gt;();
    else
      schedule = std::unique_ptr&lt;transform::parallel::OMPSched&gt;();
  }

</t>
<t tx="ekr.20230509083242.257">  /// @return the parallel loop schedule, or null if none
  transform::parallel::OMPSched *getSchedule() { return schedule.get(); }
  /// @return the parallel loop schedule, or null if none
  const transform::parallel::OMPSched *getSchedule() const { return schedule.get(); }
</t>
<t tx="ekr.20230509083242.258">  /// Sets the parallel loop schedule
  /// @param s the schedule string (e.g. OpenMP pragma)
  void setSchedule(std::unique_ptr&lt;transform::parallel::OMPSched&gt; s) {
    schedule = std::move(s);
  }

</t>
<t tx="ekr.20230509083242.259">/// Flow representing an imperative for loop.
class ImperativeForFlow : public AcceptorExtend&lt;ImperativeForFlow, Flow&gt; {
private:
  /// the initial value
  Value *start;
  /// the step value
  int64_t step;
  /// the end value
  Value *end;
  /// the body
  Value *body;
  /// the variable, must be integer type
  Var *var;
  /// parallel loop schedule, or null if none
  std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule;

public:
  static const char NodeId;

  /// Constructs an imperative for loop.
  /// @param body the body
  /// @param start the start value
  /// @param step the step value
  /// @param end the end value
  /// @param var the end variable, must be integer
  /// @param name the flow's name
  ImperativeForFlow(Value *start, int64_t step, Value *end, Flow *body, Var *var,
                    std::unique_ptr&lt;transform::parallel::OMPSched&gt; schedule = {},
                    std::string name = "")
      : AcceptorExtend(std::move(name)), start(start), step(step), end(end), body(body),
        var(var), schedule(std::move(schedule)) {}

  /// @return the start value
  Value *getStart() const { return start; }
  /// Sets the start value.
  /// @param v the new value
  void setStart(Value *val) { start = val; }

  /// @return the step value
  int64_t getStep() const { return step; }
  /// Sets the step value.
  /// @param v the new value
  void setStep(int64_t val) { step = val; }

  /// @return the end value
  Value *getEnd() const { return end; }
  /// Sets the end value.
  /// @param v the new value
  void setEnd(Value *val) { end = val; }

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new body
  void setBody(Flow *f) { body = f; }

  /// @return the var
  Var *getVar() { return var; }
  /// @return the var
  const Var *getVar() const { return var; }
  /// Sets the var.
  /// @param c the new var
  void setVar(Var *c) { var = c; }

  /// @return true if parallel
  bool isParallel() const { return bool(schedule); }
@others
protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {var}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.26">def __mul__(self, other):
    v = GVector(self.x * other, self.y * other, self.z * other)
    return v
</t>
<t tx="ekr.20230509083242.260">  /// Sets parallel status.
  /// @param a true if parallel
  void setParallel(bool a = true) {
    if (a)
      schedule = std::make_unique&lt;transform::parallel::OMPSched&gt;();
    else
      schedule = std::unique_ptr&lt;transform::parallel::OMPSched&gt;();
  }

</t>
<t tx="ekr.20230509083242.261">  /// @return the parallel loop schedule, or null if none
  transform::parallel::OMPSched *getSchedule() { return schedule.get(); }
  /// @return the parallel loop schedule, or null if none
  const transform::parallel::OMPSched *getSchedule() const { return schedule.get(); }
</t>
<t tx="ekr.20230509083242.262">  /// Sets the parallel loop schedule
  /// @param s the schedule string (e.g. OpenMP pragma)
  void setSchedule(std::unique_ptr&lt;transform::parallel::OMPSched&gt; s) {
    schedule = std::move(s);
  }

</t>
<t tx="ekr.20230509083242.263">/// Flow representing an if statement.
class IfFlow : public AcceptorExtend&lt;IfFlow, Flow&gt; {
private:
  /// the condition
  Value *cond;
  /// the true branch
  Value *trueBranch;
  /// the false branch
  Value *falseBranch;

public:
  static const char NodeId;

  /// Constructs an if.
  /// @param cond the condition
  /// @param trueBranch the true branch
  /// @param falseBranch the false branch
  /// @param name the flow's name
  IfFlow(Value *cond, Flow *trueBranch, Flow *falseBranch = nullptr,
         std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), trueBranch(trueBranch),
        falseBranch(falseBranch) {}

  /// @return the true branch
  Flow *getTrueBranch() { return cast&lt;Flow&gt;(trueBranch); }
  /// @return the true branch
  const Flow *getTrueBranch() const { return cast&lt;Flow&gt;(trueBranch); }
  /// Sets the true branch.
  /// @param f the new true branch
  void setTrueBranch(Flow *f) { trueBranch = f; }

  /// @return the false branch
  Flow *getFalseBranch() { return cast&lt;Flow&gt;(falseBranch); }
  /// @return the false branch
  const Flow *getFalseBranch() const { return cast&lt;Flow&gt;(falseBranch); }
  /// Sets the false.
  /// @param f the new false
  void setFalseBranch(Flow *f) { falseBranch = f; }

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param c the new condition
  void setCond(Value *c) { cond = c; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.264">/// Flow representing a try-catch statement.
class TryCatchFlow : public AcceptorExtend&lt;TryCatchFlow, Flow&gt; {
public:
@others
private:
  /// the catch clauses
  std::list&lt;Catch&gt; catches;

  /// the body
  Value *body;
  /// the finally, may be nullptr
  Value *finally;

public:
  static const char NodeId;

  /// Constructs an try-catch.
  /// @param name the's name
  /// @param body the body
  /// @param finally the finally
  explicit TryCatchFlow(Flow *body, Flow *finally = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), body(body), finally(finally) {}

  /// @return the body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the body.
  /// @param f the new
  void setBody(Flow *f) { body = f; }

  /// @return the finally
  Flow *getFinally() { return cast&lt;Flow&gt;(finally); }
  /// @return the finally
  const Flow *getFinally() const { return cast&lt;Flow&gt;(finally); }
  /// Sets the finally.
  /// @param f the new
  void setFinally(Flow *f) { finally = f; }

  /// @return an iterator to the first catch
  auto begin() { return catches.begin(); }
  /// @return an iterator beyond the last catch
  auto end() { return catches.end(); }
  /// @return an iterator to the first catch
  auto begin() const { return catches.begin(); }
  /// @return an iterator beyond the last catch
  auto end() const { return catches.end(); }

  /// @return a reference to the first catch
  auto &amp;front() { return catches.front(); }
  /// @return a reference to the last catch
  auto &amp;back() { return catches.back(); }
  /// @return a reference to the first catch
  auto &amp;front() const { return catches.front(); }
  /// @return a reference to the last catch
  auto &amp;back() const { return catches.back(); }

  /// Inserts a catch at the given position.
  /// @param pos the position
  /// @param v the catch
  /// @return an iterator to the newly added catch
  template &lt;typename It&gt; auto insert(It pos, Catch v) { return catches.insert(pos, v); }

  /// Appends a catch.
  /// @param v the catch
  void push_back(Catch v) { catches.push_back(v); }

  /// Emplaces a catch.
  /// @tparam Args the catch constructor args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    catches.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

  /// Erases a catch at the given position.
  /// @param pos the position
  /// @return the iterator beyond the erased catch
  template &lt;typename It&gt; auto erase(It pos) { return catches.erase(pos); }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.265">  /// Class representing a catch clause.
  class Catch {
  private:
    /// the handler
    Value *handler;
    /// the catch type, may be nullptr
    types::Type *type;
    /// the catch variable, may be nullptr
    Var *catchVar;

  public:
    explicit Catch(Flow *handler, types::Type *type = nullptr, Var *catchVar = nullptr)
        : handler(handler), type(type), catchVar(catchVar) {}

    /// @return the handler
    Flow *getHandler() { return cast&lt;Flow&gt;(handler); }
    /// @return the handler
    const Flow *getHandler() const { return cast&lt;Flow&gt;(handler); }
    /// Sets the handler.
    /// @param h the new value
    void setHandler(Flow *h) { handler = h; }

    /// @return the catch type, may be nullptr
    types::Type *getType() const { return type; }
    /// Sets the catch type.
    /// @param t the new type, nullptr for catch all
    void setType(types::Type *t) { type = t; }

    /// @return the variable, may be nullptr
    Var *getVar() { return catchVar; }
    /// @return the variable, may be nullptr
    const Var *getVar() const { return catchVar; }
    /// Sets the variable.
    /// @param v the new value, may be nullptr
    void setVar(Var *v) { catchVar = v; }
  };

</t>
<t tx="ekr.20230509083242.266">/// Flow that represents a pipeline. Pipelines with only function
/// stages are expressions and have a concrete type. Pipelines with
/// generator stages are not expressions and have no type. This
/// representation allows for stages that output generators but do
/// not get explicitly iterated in the pipeline, since generator
/// stages are denoted by a separate flag.
class PipelineFlow : public AcceptorExtend&lt;PipelineFlow, Flow&gt; {
public:
@others
private:
  /// pipeline stages
  std::list&lt;Stage&gt; stages;

public:
  static const char NodeId;

  /// Constructs a pipeline flow.
  /// @param stages vector of pipeline stages
  /// @param name the name
  explicit PipelineFlow(std::vector&lt;Stage&gt; stages = {}, std::string name = "")
      : AcceptorExtend(std::move(name)), stages(stages.begin(), stages.end()) {}

  /// @return an iterator to the first stage
  auto begin() { return stages.begin(); }
  /// @return an iterator beyond the last stage
  auto end() { return stages.end(); }
  /// @return an iterator to the first stage
  auto begin() const { return stages.begin(); }
  /// @return an iterator beyond the last stage
  auto end() const { return stages.end(); }

  /// @return a pointer to the first stage
  Stage &amp;front() { return stages.front(); }
  /// @return a pointer to the last stage
  Stage &amp;back() { return stages.back(); }
  /// @return a pointer to the first stage
  const Stage &amp;front() const { return stages.front(); }
  /// @return a pointer to the last stage
  const Stage &amp;back() const { return stages.back(); }

  /// Inserts a stage
  /// @param pos the position
  /// @param v the stage
  /// @return an iterator to the newly added stage
  template &lt;typename It&gt; auto insert(It pos, Stage v) { return stages.insert(pos, v); }
  /// Appends an stage.
  /// @param v the stage
  void push_back(Stage v) { stages.push_back(std::move(v)); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed stage
  template &lt;typename It&gt; auto erase(It pos) { return stages.erase(pos); }

  /// Emplaces a stage.
  /// @param args the args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    stages.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.267">  /// Represents a single stage in a pipeline.
  class Stage {
  private:
    /// the function being (partially) called in this stage
    Value *callee;
    /// the function arguments, where null represents where
    /// previous pipeline output should go
    std::vector&lt;Value *&gt; args;
    /// true if this stage is a generator
    bool generator;
    /// true if this stage is marked parallel
    bool parallel;

  public:
    /// Constructs a pipeline stage.
    /// @param callee the function being called
    /// @param args call arguments, with exactly one null entry
    /// @param generator whether this stage is a generator stage
    /// @param parallel whether this stage is parallel
    Stage(Value *callee, std::vector&lt;Value *&gt; args, bool generator, bool parallel)
        : callee(callee), args(std::move(args)), generator(generator),
          parallel(parallel) {}

    /// @return an iterator to the first argument
    auto begin() { return args.begin(); }
    /// @return an iterator beyond the last argument
    auto end() { return args.end(); }
    /// @return an iterator to the first argument
    auto begin() const { return args.begin(); }
    /// @return an iterator beyond the last argument
    auto end() const { return args.end(); }

    /// @return a pointer to the first argument
    Value *front() { return args.front(); }
    /// @return a pointer to the last argument
    Value *back() { return args.back(); }
    /// @return a pointer to the first argument
    const Value *front() const { return args.front(); }
    /// @return a pointer to the last argument
    const Value *back() const { return args.back(); }

    /// Inserts an argument.
    /// @param pos the position
    /// @param v the argument
    /// @return an iterator to the newly added argument
    template &lt;typename It&gt; auto insert(It pos, Value *v) { return args.insert(pos, v); }
    /// Appends an argument.
    /// @param v the argument
    void push_back(Value *v) { args.push_back(v); }

    /// Erases the item at the supplied position.
    /// @param pos the position
    /// @return the iterator beyond the removed argument
    template &lt;typename It&gt; auto erase(It pos) { return args.erase(pos); }

    /// Sets the called function.
    /// @param c the callee
    void setCallee(Value *c) { callee = c; }
    /// @return the called function
    Value *getCallee() { return callee; }
    /// @return the called function
    const Value *getCallee() const { return callee; }

    /// Sets the stage's generator flag.
    /// @param v the new value
    void setGenerator(bool v = true) { generator = v; }
    /// @return whether this stage is a generator stage
    bool isGenerator() const { return generator; }
    /// Sets the stage's parallel flag.
    /// @param v the new value
    void setParallel(bool v = true) { parallel = v; }
    /// @return whether this stage is parallel
    bool isParallel() const { return parallel; }
    /// @return the output type of this stage
    types::Type *getOutputType() const;
    /// @return the output element type of this stage
    types::Type *getOutputElementType() const;

    friend class PipelineFlow;
  };

</t>
<t tx="ekr.20230509083242.268">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "func.h"

#include &lt;algorithm&gt;

#include "codon/cir/module.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/util/operator.h"
#include "codon/cir/util/visitor.h"
#include "codon/cir/var.h"
#include "codon/parser/common.h"

namespace codon {
namespace ir {
namespace {
@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.269">int findAndReplace(id_t id, codon::ir::Var *newVal,
                   std::list&lt;codon::ir::Var *&gt; &amp;values) {
  auto replacements = 0;
  for (auto &amp;value : values) {
    if (value-&gt;getId() == id) {
      value = newVal;
      ++replacements;
    }
  }
  return replacements;
}
</t>
<t tx="ekr.20230509083242.27">__rmul__ = __mul__

</t>
<t tx="ekr.20230509083242.270">} // namespace

const char Func::NodeId = 0;

</t>
<t tx="ekr.20230509083242.271">void Func::realize(types::Type *newType, const std::vector&lt;std::string&gt; &amp;names) {
  auto *funcType = cast&lt;types::FuncType&gt;(newType);
  seqassert(funcType, "{} is not a function type", *newType);

  setType(funcType);
  args.clear();

  auto i = 0;
  for (auto *t : *funcType) {
    args.push_back(getModule()-&gt;Nr&lt;Var&gt;(t, false, false, names[i]));
    ++i;
  }
}

</t>
<t tx="ekr.20230509083242.272">Var *Func::getArgVar(const std::string &amp;n) {
</t>
<t tx="ekr.20230509083242.273">  auto it = std::find_if(args.begin(), args.end(),
                         [n](auto *other) { return other-&gt;getName() == n; });
  return (it != args.end()) ? *it : nullptr;
}

std::vector&lt;Var *&gt; Func::doGetUsedVariables() const {
  std::vector&lt;Var *&gt; ret(args.begin(), args.end());
  return ret;
}

</t>
<t tx="ekr.20230509083242.274">int Func::doReplaceUsedVariable(id_t id, Var *newVar) {
  return findAndReplace(id, newVar, args);
}

</t>
<t tx="ekr.20230509083242.275">std::vector&lt;types::Type *&gt; Func::doGetUsedTypes() const {
  std::vector&lt;types::Type *&gt; ret;

  for (auto *t : Var::getUsedTypes())
    ret.push_back(const_cast&lt;types::Type *&gt;(t));

  if (parentType)
    ret.push_back(parentType);

  return ret;
}

</t>
<t tx="ekr.20230509083242.276">int Func::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  auto count = Var::replaceUsedType(name, newType);
  if (parentType &amp;&amp; parentType-&gt;getName() == name) {
    parentType = newType;
    ++count;
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.277">const char BodiedFunc::NodeId = 0;

</t>
<t tx="ekr.20230509083242.278">int BodiedFunc::doReplaceUsedValue(id_t id, Value *newValue) {
  if (body &amp;&amp; body-&gt;getId() == id) {
    auto *flow = cast&lt;Flow&gt;(newValue);
    seqassert(flow, "{} is not a flow", *newValue);
    body = flow;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.279">std::vector&lt;Var *&gt; BodiedFunc::doGetUsedVariables() const {
  auto ret = Func::doGetUsedVariables();
  ret.insert(ret.end(), symbols.begin(), symbols.end());
  return ret;
}

</t>
<t tx="ekr.20230509083242.28">def linear_combination(self, other, l1, l2=None):
    if l2 is None:
        l2 = 1 - l1
    v = GVector(self.x * l1 + other.x * l2,
                self.y * l1 + other.y * l2,
                self.z * l1 + other.z * l2)
    return v

</t>
<t tx="ekr.20230509083242.280">int BodiedFunc::doReplaceUsedVariable(id_t id, Var *newVar) {
  return Func::doReplaceUsedVariable(id, newVar) + findAndReplace(id, newVar, symbols);
}

</t>
<t tx="ekr.20230509083242.281">const char ExternalFunc::NodeId = 0;

const char InternalFunc::NodeId = 0;

const char LLVMFunc::NodeId = 0;

std::vector&lt;types::Type *&gt; LLVMFunc::doGetUsedTypes() const {
  std::vector&lt;types::Type *&gt; ret;

  for (auto *t : Func::getUsedTypes())
    ret.push_back(const_cast&lt;types::Type *&gt;(t));

  for (auto &amp;l : llvmLiterals)
    if (l.isType())
      ret.push_back(const_cast&lt;types::Type *&gt;(l.getTypeValue()));

  return ret;
}

</t>
<t tx="ekr.20230509083242.282">int LLVMFunc::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  auto count = Var::doReplaceUsedType(name, newType);
  for (auto &amp;l : llvmLiterals)
    if (l.isType() &amp;&amp; l.getTypeValue()-&gt;getName() == name) {
      l = newType;
      ++count;
    }
  return count;
}

</t>
<t tx="ekr.20230509083242.283">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/flow.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Func&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.284">/// CIR function
class Func : public AcceptorExtend&lt;Func, Var&gt; {
private:
  /// unmangled (source code) name of the function
  std::string unmangledName;
  /// whether the function is a generator
  bool generator;
  /// Parent type if func is a method, or null if not
  types::Type *parentType;

protected:
  /// list of arguments
  std::list&lt;Var *&gt; args;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;

  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;

public:
  static const char NodeId;

  /// Constructs an unrealized CIR function.
  /// @param name the function's name
  explicit Func(std::string name = "")
      : AcceptorExtend(nullptr, true, false, std::move(name)), generator(false),
        parentType(nullptr) {}

  /// Re-initializes the function with a new type and names.
  /// @param newType the function's new type
  /// @param names the function's new argument names
  void realize(types::Type *newType, const std::vector&lt;std::string&gt; &amp;names);

  /// @return iterator to the first arg
  auto arg_begin() { return args.begin(); }
  /// @return iterator beyond the last arg
  auto arg_end() { return args.end(); }
  /// @return iterator to the first arg
  auto arg_begin() const { return args.begin(); }
  /// @return iterator beyond the last arg
  auto arg_end() const { return args.end(); }

  /// @return a pointer to the last arg
  Var *arg_front() { return args.front(); }
  /// @return a pointer to the last arg
  Var *arg_back() { return args.back(); }
  /// @return a pointer to the last arg
  const Var *arg_back() const { return args.back(); }
  /// @return a pointer to the first arg
  const Var *arg_front() const { return args.front(); }

  /// @return the function's unmangled (source code) name
  std::string getUnmangledName() const { return unmangledName; }
  /// Sets the unmangled name.
  /// @param v the new value
  void setUnmangledName(std::string v) { unmangledName = std::move(v); }

  /// @return true if the function is a generator
  bool isGenerator() const { return generator; }
  /// Sets the function's generator flag.
  /// @param v the new value
  void setGenerator(bool v = true) { generator = v; }

  /// @return the variable corresponding to the given argument name
  /// @param n the argument name
  Var *getArgVar(const std::string &amp;n);

  /// @return the parent type
  types::Type *getParentType() const { return parentType; }
  /// Sets the parent type.
  /// @param p the new parent
  void setParentType(types::Type *p) { parentType = p; }
};

</t>
<t tx="ekr.20230509083242.285">class BodiedFunc : public AcceptorExtend&lt;BodiedFunc, Func&gt; {
private:
  /// list of variables defined and used within the function
  std::list&lt;Var *&gt; symbols;
  /// the function body
  Value *body = nullptr;
  /// whether the function is a JIT input
  bool jit = false;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return iterator to the first symbol
  auto begin() { return symbols.begin(); }
  /// @return iterator beyond the last symbol
  auto end() { return symbols.end(); }
  /// @return iterator to the first symbol
  auto begin() const { return symbols.begin(); }
  /// @return iterator beyond the last symbol
  auto end() const { return symbols.end(); }

  /// @return a pointer to the first symbol
  Var *front() { return symbols.front(); }
  /// @return a pointer to the last symbol
  Var *back() { return symbols.back(); }
  /// @return a pointer to the first symbol
  const Var *front() const { return symbols.front(); }
  /// @return a pointer to the last symbol
  const Var *back() const { return symbols.back(); }

  /// Inserts an symbol at the given position.
  /// @param pos the position
  /// @param v the symbol
  /// @return an iterator to the newly added symbol
  template &lt;typename It&gt; auto insert(It pos, Var *v) { return symbols.insert(pos, v); }
  /// Appends an symbol.
  /// @param v the new symbol
  void push_back(Var *v) { symbols.push_back(v); }

  /// Erases the symbol at the given position.
  /// @param pos the position
  /// @return symbol_iterator following the removed symbol.
  template &lt;typename It&gt; auto erase(It pos) { return symbols.erase(pos); }

  /// @return the function body
  Flow *getBody() { return cast&lt;Flow&gt;(body); }
  /// @return the function body
  const Flow *getBody() const { return cast&lt;Flow&gt;(body); }
  /// Sets the function's body.
  /// @param b the new body
  void setBody(Flow *b) { body = b; }

  /// @return true if the function is a JIT input
  bool isJIT() const { return jit; }
  /// Changes the function's JIT input status.
  /// @param v true if JIT input, false otherwise
  void setJIT(bool v = true) { jit = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return body ? std::vector&lt;Value *&gt;{body} : std::vector&lt;Value *&gt;{};
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override;
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.286">class ExternalFunc : public AcceptorExtend&lt;ExternalFunc, Func&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return true if the function is variadic
  bool isVariadic() const { return cast&lt;types::FuncType&gt;(getType())-&gt;isVariadic(); }
};

</t>
<t tx="ekr.20230509083242.287">/// Internal, LLVM-only function.
class InternalFunc : public AcceptorExtend&lt;InternalFunc, Func&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509083242.288">/// LLVM function defined in Seq source.
class LLVMFunc : public AcceptorExtend&lt;LLVMFunc, Func&gt; {
private:
  /// literals that must be formatted into the body
  std::vector&lt;types::Generic&gt; llvmLiterals;
  /// declares for llvm-only function
  std::string llvmDeclares;
  /// body of llvm-only function
  std::string llvmBody;

public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// Sets the LLVM literals.
  /// @param v the new values.
  void setLLVMLiterals(std::vector&lt;types::Generic&gt; v) { llvmLiterals = std::move(v); }

  /// @return iterator to the first literal
  auto literal_begin() { return llvmLiterals.begin(); }
  /// @return iterator beyond the last literal
  auto literal_end() { return llvmLiterals.end(); }
  /// @return iterator to the first literal
  auto literal_begin() const { return llvmLiterals.begin(); }
  /// @return iterator beyond the last literal
  auto literal_end() const { return llvmLiterals.end(); }

  /// @return a reference to the first literal
  auto &amp;literal_front() { return llvmLiterals.front(); }
  /// @return a reference to the last literal
  auto &amp;literal_back() { return llvmLiterals.back(); }
  /// @return a reference to the first literal
  auto &amp;literal_front() const { return llvmLiterals.front(); }
  /// @return a reference to the last literal
  auto &amp;literal_back() const { return llvmLiterals.back(); }

  /// @return the LLVM declarations
  const std::string &amp;getLLVMDeclarations() const { return llvmDeclares; }
  /// Sets the LLVM declarations.
  /// @param v the new value
  void setLLVMDeclarations(std::string v) { llvmDeclares = std::move(v); }
  /// @return the LLVM body
  const std::string &amp;getLLVMBody() const { return llvmBody; }
  /// Sets the LLVM body.
  /// @param v the new value
  void setLLVMBody(std::string v) { llvmBody = std::move(v); }

protected:
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override;
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509083242.289">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "instr.h"

#include "codon/cir/module.h"
#include "codon/cir/util/iterators.h"

namespace codon {
namespace ir {
namespace {
@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.29">def __str__(self):
    return "&lt;%f, %f, %f&gt;" % (self.x, self.y, self.z)

</t>
<t tx="ekr.20230509083242.290">int findAndReplace(id_t id, codon::ir::Value *newVal,
                   std::vector&lt;codon::ir::Value *&gt; &amp;values) {
  auto replacements = 0;
  for (auto &amp;value : values) {
    if (value-&gt;getId() == id) {
      value = newVal;
      ++replacements;
    }
  }
  return replacements;
}
</t>
<t tx="ekr.20230509083242.291">} // namespace

const char Instr::NodeId = 0;

types::Type *Instr::doGetType() const { return getModule()-&gt;getNoneType(); }

const char AssignInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.292">int AssignInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (rhs-&gt;getId() == id) {
    rhs = newValue;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.293">int AssignInstr::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (lhs-&gt;getId() == id) {
    lhs = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.294">const char ExtractInstr::NodeId = 0;

types::Type *ExtractInstr::doGetType() const {
  auto *memberedType = cast&lt;types::MemberedType&gt;(val-&gt;getType());
  seqassert(memberedType, "{} is not a membered type", *val-&gt;getType());
  return memberedType-&gt;getMemberType(field);
}

</t>
<t tx="ekr.20230509083242.295">int ExtractInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (val-&gt;getId() == id) {
    val = newValue;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.296">const char InsertInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.297">int InsertInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;
  if (lhs-&gt;getId() == id) {
    lhs = newValue;
    ++replacements;
  }
  if (rhs-&gt;getId() == id) {
    rhs = newValue;
    ++replacements;
  }
  return replacements;
}

</t>
<t tx="ekr.20230509083242.298">const char CallInstr::NodeId = 0;

types::Type *CallInstr::doGetType() const {
  auto *funcType = cast&lt;types::FuncType&gt;(callee-&gt;getType());
  seqassert(funcType, "{} is not a function type", *callee-&gt;getType());
  return funcType-&gt;getReturnType();
}

std::vector&lt;Value *&gt; CallInstr::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret(args.begin(), args.end());
  ret.push_back(callee);
  return ret;
}

</t>
<t tx="ekr.20230509083242.299">int CallInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;
  if (callee-&gt;getId() == id) {
    callee = newValue;
    ++replacements;
  }
  replacements += findAndReplace(id, newValue, args);
  return replacements;
}

</t>
<t tx="ekr.20230509083242.3"></t>
<t tx="ekr.20230509083242.30">def __repr__(self):
    return "GVector(%f, %f, %f)" % (self.x, self.y, self.z)


</t>
<t tx="ekr.20230509083242.300">const char StackAllocInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.301">int StackAllocInstr::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  if (arrayType-&gt;getName() == name) {
    arrayType = newType;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.302">const char TypePropertyInstr::NodeId = 0;

types::Type *TypePropertyInstr::doGetType() const {
  switch (property) {
  case Property::IS_ATOMIC:
    return getModule()-&gt;getBoolType();
  case Property::IS_CONTENT_ATOMIC:
    return getModule()-&gt;getBoolType();
  case Property::SIZEOF:
    return getModule()-&gt;getIntType();
  default:
    return getModule()-&gt;getNoneType();
  }
}

</t>
<t tx="ekr.20230509083242.303">int TypePropertyInstr::doReplaceUsedType(const std::string &amp;name,
                                         types::Type *newType) {
  if (inspectType-&gt;getName() == name) {
    inspectType = newType;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.304">const char YieldInInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.305">int YieldInInstr::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  if (type-&gt;getName() == name) {
    type = newType;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.306">const char TernaryInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.307">int TernaryInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;
  if (cond-&gt;getId() == id) {
    cond = newValue;
    ++replacements;
  }
  if (trueValue-&gt;getId() == id) {
    trueValue = newValue;
    ++replacements;
  }
  if (falseValue-&gt;getId() == id) {
    falseValue = newValue;
    ++replacements;
  }
  return replacements;
}

</t>
<t tx="ekr.20230509083242.308">const char ControlFlowInstr::NodeId = 0;

const char BreakInstr::NodeId = 0;

std::vector&lt;Value *&gt; BreakInstr::doGetUsedValues() const {
  if (loop)
    return {loop};
  return {};
}

</t>
<t tx="ekr.20230509083242.309">int BreakInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (loop &amp;&amp; loop-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    loop = f;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.31">class Spline(object):
    """Class for representing B-Splines and NURBS of arbitrary degree"""

    @others
</t>
<t tx="ekr.20230509083242.310">const char ContinueInstr::NodeId = 0;

std::vector&lt;Value *&gt; ContinueInstr::doGetUsedValues() const {
  if (loop)
    return {loop};
  return {};
}

</t>
<t tx="ekr.20230509083242.311">int ContinueInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (loop &amp;&amp; loop-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    loop = f;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.312">const char ReturnInstr::NodeId = 0;

std::vector&lt;Value *&gt; ReturnInstr::doGetUsedValues() const {
  if (value)
    return {value};
  return {};
}

</t>
<t tx="ekr.20230509083242.313">int ReturnInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;
  if (value &amp;&amp; value-&gt;getId() == id) {
    setValue(newValue);
    ++replacements;
  }
  return replacements;
}

</t>
<t tx="ekr.20230509083242.314">const char YieldInstr::NodeId = 0;

std::vector&lt;Value *&gt; YieldInstr::doGetUsedValues() const {
  if (value)
    return {value};
  return {};
}

</t>
<t tx="ekr.20230509083242.315">int YieldInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (value &amp;&amp; value-&gt;getId() == id) {
    setValue(newValue);
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.316">const char ThrowInstr::NodeId = 0;

std::vector&lt;Value *&gt; ThrowInstr::doGetUsedValues() const {
  if (value)
    return {value};
  return {};
}

</t>
<t tx="ekr.20230509083242.317">int ThrowInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (value &amp;&amp; value-&gt;getId() == id) {
    setValue(newValue);
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.318">const char FlowInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.319">int FlowInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto replacements = 0;
  if (flow-&gt;getId() == id) {
    auto *f = cast&lt;Flow&gt;(newValue);
    seqassert(f, "{} is not a flow", *newValue);
    setFlow(f);
    ++replacements;
  }
  if (val-&gt;getId() == id) {
    setValue(newValue);
    ++replacements;
  }
  return replacements;
}

</t>
<t tx="ekr.20230509083242.32">def __init__(self, points, degree, knots):
    """Creates a Spline.
    points is a list of GVector, degree is the degree of the Spline.
    """
    if len(points) &gt; len(knots) - degree + 1:
        raise ValueError("too many control points")
    elif len(points) &lt; len(knots) - degree + 1:
        raise ValueError("not enough control points")
    last = knots[0]
    for cur in knots[1:]:
        if cur &lt; last:
            raise ValueError("knots not strictly increasing")
        last = cur
    self.knots = knots
    self.points = points
    self.degree = degree

</t>
<t tx="ekr.20230509083242.320">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;

#include "codon/cir/flow.h"
#include "codon/cir/types/types.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.321">/// CIR object representing an "instruction," or discrete operation in the context of a
/// block.
class Instr : public AcceptorExtend&lt;Instr, Value&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

private:
  types::Type *doGetType() const override;
};

</t>
<t tx="ekr.20230509083242.322">/// Instr representing setting a memory location.
class AssignInstr : public AcceptorExtend&lt;AssignInstr, Instr&gt; {
private:
  /// the left-hand side
  Var *lhs;
  /// the right-hand side
  Value *rhs;

public:
  static const char NodeId;

  /// Constructs an assign instruction.
  /// @param lhs the left-hand side
  /// @param rhs the right-hand side
  /// @param field the field being set, may be empty
  /// @param name the instruction's name
  AssignInstr(Var *lhs, Value *rhs, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), rhs(rhs) {}

  /// @return the left-hand side
  Var *getLhs() { return lhs; }
  /// @return the left-hand side
  const Var *getLhs() const { return lhs; }
  /// Sets the left-hand side
  /// @param l the new value
  void setLhs(Var *v) { lhs = v; }

  /// @return the right-hand side
  Value *getRhs() { return rhs; }
  /// @return the right-hand side
  const Value *getRhs() const { return rhs; }
  /// Sets the right-hand side
  /// @param l the new value
  void setRhs(Value *v) { rhs = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {rhs}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {lhs}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.323">/// Instr representing loading the field of a value.
class ExtractInstr : public AcceptorExtend&lt;ExtractInstr, Instr&gt; {
private:
  /// the value being manipulated
  Value *val;
  /// the field
  std::string field;

public:
  static const char NodeId;

  /// Constructs a load instruction.
  /// @param val the value being manipulated
  /// @param field the field
  /// @param name the instruction's name
  explicit ExtractInstr(Value *val, std::string field, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val), field(std::move(field)) {}

  /// @return the location
  Value *getVal() { return val; }
  /// @return the location
  const Value *getVal() const { return val; }
  /// Sets the location.
  /// @param p the new value
  void setVal(Value *p) { val = p; }

  /// @return the field
  const std::string &amp;getField() const { return field; }
  /// Sets the field.
  /// @param f the new field
  void setField(std::string f) { field = std::move(f); }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {val}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.324">/// Instr representing setting the field of a value.
class InsertInstr : public AcceptorExtend&lt;InsertInstr, Instr&gt; {
private:
  /// the value being manipulated
  Value *lhs;
  /// the field
  std::string field;
  /// the value being inserted
  Value *rhs;

public:
  static const char NodeId;

  /// Constructs a load instruction.
  /// @param lhs the value being manipulated
  /// @param field the field
  /// @param rhs the new value
  /// @param name the instruction's name
  explicit InsertInstr(Value *lhs, std::string field, Value *rhs, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), field(std::move(field)), rhs(rhs) {}

  /// @return the left-hand side
  Value *getLhs() { return lhs; }
  /// @return the left-hand side
  const Value *getLhs() const { return lhs; }
  /// Sets the left-hand side.
  /// @param p the new value
  void setLhs(Value *p) { lhs = p; }

  /// @return the right-hand side
  Value *getRhs() { return rhs; }
  /// @return the right-hand side
  const Value *getRhs() const { return rhs; }
  /// Sets the right-hand side.
  /// @param p the new value
  void setRhs(Value *p) { rhs = p; }

  /// @return the field
  const std::string &amp;getField() const { return field; }
  /// Sets the field.
  /// @param f the new field
  void setField(std::string f) { field = std::move(f); }

protected:
  types::Type *doGetType() const override { return lhs-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {lhs, rhs}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.325">/// Instr representing calling a function.
class CallInstr : public AcceptorExtend&lt;CallInstr, Instr&gt; {
private:
  /// the function
  Value *callee;
  /// the arguments
  std::vector&lt;Value *&gt; args;

public:
  static const char NodeId;

  /// Constructs a call instruction.
  /// @param callee the function
  /// @param args the arguments
  /// @param name the instruction's name
  CallInstr(Value *callee, std::vector&lt;Value *&gt; args, std::string name = "")
      : AcceptorExtend(std::move(name)), callee(callee), args(std::move(args)) {}

  /// Constructs a call instruction with no arguments.
  /// @param callee the function
  /// @param name the instruction's name
  explicit CallInstr(Value *callee, std::string name = "")
      : CallInstr(callee, {}, std::move(name)) {}

  /// @return the callee
  Value *getCallee() { return callee; }
  /// @return the callee
  const Value *getCallee() const { return callee; }
  /// Sets the callee.
  /// @param c the new value
  void setCallee(Value *c) { callee = c; }

  /// @return an iterator to the first argument
  auto begin() { return args.begin(); }
  /// @return an iterator beyond the last argument
  auto end() { return args.end(); }
  /// @return an iterator to the first argument
  auto begin() const { return args.begin(); }
  /// @return an iterator beyond the last argument
  auto end() const { return args.end(); }

  /// @return a pointer to the first argument
  Value *front() { return args.front(); }
  /// @return a pointer to the last argument
  Value *back() { return args.back(); }
  /// @return a pointer to the first argument
  const Value *front() const { return args.front(); }
  /// @return a pointer to the last argument
  const Value *back() const { return args.back(); }

  /// Inserts an argument at the given position.
  /// @param pos the position
  /// @param v the argument
  /// @return an iterator to the newly added argument
  template &lt;typename It&gt; auto insert(It pos, Value *v) { return args.insert(pos, v); }
  /// Appends an argument.
  /// @param v the argument
  void push_back(Value *v) { args.push_back(v); }

  /// Sets the args.
  /// @param v the new args vector
  void setArgs(std::vector&lt;Value *&gt; v) { args = std::move(v); }

  /// @return the number of arguments
  int numArgs() const { return args.size(); }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.326">/// Instr representing allocating an array on the stack.
class StackAllocInstr : public AcceptorExtend&lt;StackAllocInstr, Instr&gt; {
private:
  /// the array type
  types::Type *arrayType;
  /// number of elements to allocate
  int64_t count;

public:
  static const char NodeId;

  /// Constructs a stack allocation instruction.
  /// @param arrayType the type of the array
  /// @param count the number of elements
  /// @param name the name
  StackAllocInstr(types::Type *arrayType, int64_t count, std::string name = "")
      : AcceptorExtend(std::move(name)), arrayType(arrayType), count(count) {}

  /// @return the count
  int64_t getCount() const { return count; }
  /// Sets the count.
  /// @param c the new value
  void setCount(int64_t c) { count = c; }

  /// @return the array type
  types::Type *getArrayType() { return arrayType; }
  /// @return the array type
  types::Type *getArrayType() const { return arrayType; }
  /// Sets the array type.
  /// @param t the new type
  void setArrayType(types::Type *t) { arrayType = t; }

protected:
  types::Type *doGetType() const override { return arrayType; }
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {arrayType}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509083242.327">/// Instr representing getting information about a type.
class TypePropertyInstr : public AcceptorExtend&lt;TypePropertyInstr, Instr&gt; {
public:
  enum Property { IS_ATOMIC, IS_CONTENT_ATOMIC, SIZEOF };

private:
  /// the type being inspected
  types::Type *inspectType;
  /// the property being checked
  Property property;

public:
  static const char NodeId;

  /// Constructs a type property instruction.
  /// @param type the type being inspected
  /// @param name the name
  explicit TypePropertyInstr(types::Type *type, Property property,
                             std::string name = "")
      : AcceptorExtend(std::move(name)), inspectType(type), property(property) {}

  /// @return the type being inspected
  types::Type *getInspectType() { return inspectType; }
  /// @return the type being inspected
  types::Type *getInspectType() const { return inspectType; }
  /// Sets the type being inspected
  /// @param t the new type
  void setInspectType(types::Type *t) { inspectType = t; }

  /// @return the property being inspected
  Property getProperty() const { return property; }
  /// Sets the property.
  /// @param p the new value
  void setProperty(Property p) { property = p; }

protected:
  types::Type *doGetType() const override;
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {inspectType}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509083242.328">/// Instr representing a Python yield expression.
class YieldInInstr : public AcceptorExtend&lt;YieldInInstr, Instr&gt; {
private:
  /// the type of the value being yielded in.
  types::Type *type;
  /// whether or not to suspend
  bool suspend;

public:
  static const char NodeId;

  /// Constructs a yield in instruction.
  /// @param type the type of the value being yielded in
  /// @param suspend whether to suspend
  /// @param name the instruction's name
  explicit YieldInInstr(types::Type *type, bool suspend = true, std::string name = "")
      : AcceptorExtend(std::move(name)), type(type), suspend(suspend) {}

  /// @return true if the instruction suspends
  bool isSuspending() const { return suspend; }
  /// Sets the instruction suspending flag.
  /// @param v the new value
  void setSuspending(bool v = true) { suspend = v; }

  /// Sets the type being inspected
  /// @param t the new type
  void setType(types::Type *t) { type = t; }

protected:
  types::Type *doGetType() const override { return type; }
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return {type}; }
  int doReplaceUsedType(const std::string &amp;name, types::Type *newType) override;
};

</t>
<t tx="ekr.20230509083242.329">/// Instr representing a ternary operator.
class TernaryInstr : public AcceptorExtend&lt;TernaryInstr, Instr&gt; {
private:
  /// the condition
  Value *cond;
  /// the true value
  Value *trueValue;
  /// the false value
  Value *falseValue;

public:
  static const char NodeId;

  /// Constructs a ternary instruction.
  /// @param cond the condition
  /// @param trueValue the true value
  /// @param falseValue the false value
  /// @param name the instruction's name
  TernaryInstr(Value *cond, Value *trueValue, Value *falseValue, std::string name = "")
      : AcceptorExtend(std::move(name)), cond(cond), trueValue(trueValue),
        falseValue(falseValue) {}

  /// @return the condition
  Value *getCond() { return cond; }
  /// @return the condition
  const Value *getCond() const { return cond; }
  /// Sets the condition.
  /// @param v the new value
  void setCond(Value *v) { cond = v; }

  /// @return the condition
  Value *getTrueValue() { return trueValue; }
  /// @return the condition
  const Value *getTrueValue() const { return trueValue; }
  /// Sets the true value.
  /// @param v the new value
  void setTrueValue(Value *v) { trueValue = v; }

  /// @return the false value
  Value *getFalseValue() { return falseValue; }
  /// @return the false value
  const Value *getFalseValue() const { return falseValue; }
  /// Sets the value.
  /// @param v the new value
  void setFalseValue(Value *v) { falseValue = v; }

protected:
  types::Type *doGetType() const override { return trueValue-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override {
    return {cond, trueValue, falseValue};
  }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.33">def GetDomain(self):
    """Returns the domain of the B-Spline"""
    return (self.knots[self.degree - 1],
            self.knots[len(self.knots) - self.degree])

</t>
<t tx="ekr.20230509083242.330">/// Base for control flow instructions
class ControlFlowInstr : public AcceptorExtend&lt;ControlFlowInstr, Instr&gt; {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509083242.331">/// Instr representing a break statement.
class BreakInstr : public AcceptorExtend&lt;BreakInstr, ControlFlowInstr&gt; {
private:
  /// the loop being broken, nullptr if the immediate ancestor
  Value *loop;

public:
  static const char NodeId;

  /// Constructs a break instruction.
  /// @param loop the loop being broken, nullptr if immediate ancestor
  /// @param name the instruction's name
  explicit BreakInstr(Value *loop = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), loop(loop) {}

  /// @return the loop, nullptr if immediate ancestor
  Value *getLoop() const { return loop; }
  /// Sets the loop id.
  /// @param v the new loop, nullptr if immediate ancestor
  void setLoop(Value *v) { loop = v; }

  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.332">/// Instr representing a continue statement.
class ContinueInstr : public AcceptorExtend&lt;ContinueInstr, ControlFlowInstr&gt; {
private:
  /// the loop being continued, nullptr if the immediate ancestor
  Value *loop;

public:
  static const char NodeId;

  /// Constructs a continue instruction.
  /// @param loop the loop being continued, nullptr if immediate ancestor
  /// @param name the instruction's name
  explicit ContinueInstr(Value *loop = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), loop(loop) {}

  /// @return the loop, nullptr if immediate ancestor
  Value *getLoop() const { return loop; }
  /// Sets the loop id.
  /// @param v the new loop, -1 if immediate ancestor
  void setLoop(Value *v) { loop = v; }

  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.333">/// Instr representing a return statement.
class ReturnInstr : public AcceptorExtend&lt;ReturnInstr, ControlFlowInstr&gt; {
private:
  /// the value
  Value *value;

public:
  static const char NodeId;

  explicit ReturnInstr(Value *value = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.334">class YieldInstr : public AcceptorExtend&lt;YieldInstr, Instr&gt; {
private:
  /// the value
  Value *value;
  /// whether this yield is final
  bool final;

public:
  static const char NodeId;

  explicit YieldInstr(Value *value = nullptr, bool final = false, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value), final(final) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

  /// @return if this yield is final
  bool isFinal() const { return final; }
  /// Sets whether this yield is final.
  /// @param f true if final
  void setFinal(bool f = true) { final = f; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.335">class ThrowInstr : public AcceptorExtend&lt;ThrowInstr, Instr&gt; {
private:
  /// the value
  Value *value;

public:
  static const char NodeId;

  explicit ThrowInstr(Value *value = nullptr, std::string name = "")
      : AcceptorExtend(std::move(name)), value(value) {}

  /// @return the value
  Value *getValue() { return value; }
  /// @return the value
  const Value *getValue() const { return value; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { value = v; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.336">/// Instr that contains a flow and value.
class FlowInstr : public AcceptorExtend&lt;FlowInstr, Instr&gt; {
private:
  /// the flow
  Value *flow;
  /// the output value
  Value *val;

public:
  static const char NodeId;

  /// Constructs a flow value.
  /// @param flow the flow
  /// @param val the output value
  /// @param name the name
  explicit FlowInstr(Flow *flow, Value *val, std::string name = "")
      : AcceptorExtend(std::move(name)), flow(flow), val(val) {}

  /// @return the flow
  Flow *getFlow() { return cast&lt;Flow&gt;(flow); }
  /// @return the flow
  const Flow *getFlow() const { return cast&lt;Flow&gt;(flow); }
  /// Sets the flow.
  /// @param f the new flow
  void setFlow(Flow *f) { flow = f; }

  /// @return the value
  Value *getValue() { return val; }
  /// @return the value
  const Value *getValue() const { return val; }
  /// Sets the value.
  /// @param v the new value
  void setValue(Value *v) { val = v; }

protected:
  types::Type *doGetType() const override { return val-&gt;getType(); }
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {flow, val}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.337">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "module.h"

#include &lt;algorithm&gt;
#include &lt;memory&gt;

#include "codon/cir/func.h"
#include "codon/parser/cache.h"

namespace codon {
namespace ir {
namespace {
std::vector&lt;codon::ast::types::TypePtr&gt;
translateGenerics(codon::ast::Cache *cache, std::vector&lt;types::Generic&gt; &amp;generics) {
  std::vector&lt;codon::ast::types::TypePtr&gt; ret;
  for (auto &amp;g : generics) {
    seqassertn(g.isStatic() || g.getTypeValue(), "generic must be static or a type");
    ret.push_back(std::make_shared&lt;codon::ast::types::LinkType&gt;(
        g.isStatic()
            ? std::make_shared&lt;codon::ast::types::StaticType&gt;(cache, g.getStaticValue())
            : (g.isStaticStr() ? std::make_shared&lt;codon::ast::types::StaticType&gt;(
                                     cache, g.getStaticStringValue())
                               : g.getTypeValue()-&gt;getAstType())));
  }
  return ret;
}

std::vector&lt;codon::ast::types::TypePtr&gt;
generateDummyNames(std::vector&lt;types::Type *&gt; &amp;types) {
  std::vector&lt;codon::ast::types::TypePtr&gt; ret;
  for (auto *t : types) {
    seqassertn(t-&gt;getAstType(), "{} must have an ast type", *t);
    ret.emplace_back(t-&gt;getAstType());
  }
  return ret;
}

std::vector&lt;codon::ast::types::TypePtr&gt;
translateArgs(codon::ast::Cache *cache, std::vector&lt;types::Type *&gt; &amp;types) {
  std::vector&lt;codon::ast::types::TypePtr&gt; ret = {
      std::make_shared&lt;codon::ast::types::LinkType&gt;(
          cache, codon::ast::types::LinkType::Kind::Unbound, 0)};
  for (auto *t : types) {
    seqassertn(t-&gt;getAstType(), "{} must have an ast type", *t);
    if (auto f = t-&gt;getAstType()-&gt;getFunc()) {
      auto *irType = cast&lt;types::FuncType&gt;(t);
      std::vector&lt;char&gt; mask(std::distance(irType-&gt;begin(), irType-&gt;end()), 0);
      ret.push_back(std::make_shared&lt;codon::ast::types::PartialType&gt;(
          t-&gt;getAstType()-&gt;getRecord(), f, mask));
    } else {
      ret.push_back(t-&gt;getAstType());
    }
  }
  return ret;
}
} // namespace

const std::string Module::VOID_NAME = "void";
const std::string Module::BOOL_NAME = "bool";
const std::string Module::BYTE_NAME = "byte";
const std::string Module::INT_NAME = "int";
const std::string Module::FLOAT_NAME = "float";
const std::string Module::FLOAT32_NAME = "float32";
const std::string Module::STRING_NAME = "str";

const std::string Module::EQ_MAGIC_NAME = "__eq__";
const std::string Module::NE_MAGIC_NAME = "__ne__";
const std::string Module::LT_MAGIC_NAME = "__lt__";
const std::string Module::GT_MAGIC_NAME = "__gt__";
const std::string Module::LE_MAGIC_NAME = "__le__";
const std::string Module::GE_MAGIC_NAME = "__ge__";

const std::string Module::POS_MAGIC_NAME = "__pos__";
const std::string Module::NEG_MAGIC_NAME = "__neg__";
const std::string Module::INVERT_MAGIC_NAME = "__invert__";

const std::string Module::ADD_MAGIC_NAME = "__add__";
const std::string Module::SUB_MAGIC_NAME = "__sub__";
const std::string Module::MUL_MAGIC_NAME = "__mul__";
const std::string Module::MATMUL_MAGIC_NAME = "__matmul__";
const std::string Module::TRUE_DIV_MAGIC_NAME = "__truediv__";
const std::string Module::FLOOR_DIV_MAGIC_NAME = "__floordiv__";
const std::string Module::MOD_MAGIC_NAME = "__mod__";
const std::string Module::POW_MAGIC_NAME = "__pow__";
const std::string Module::LSHIFT_MAGIC_NAME = "__lshift__";
const std::string Module::RSHIFT_MAGIC_NAME = "__rshift__";
const std::string Module::AND_MAGIC_NAME = "__and__";
const std::string Module::OR_MAGIC_NAME = "__or__";
const std::string Module::XOR_MAGIC_NAME = "__xor__";

const std::string Module::IADD_MAGIC_NAME = "__iadd__";
const std::string Module::ISUB_MAGIC_NAME = "__isub__";
const std::string Module::IMUL_MAGIC_NAME = "__imul__";
const std::string Module::IMATMUL_MAGIC_NAME = "__imatmul__";
const std::string Module::ITRUE_DIV_MAGIC_NAME = "__itruediv__";
const std::string Module::IFLOOR_DIV_MAGIC_NAME = "__ifloordiv__";
const std::string Module::IMOD_MAGIC_NAME = "__imod__";
const std::string Module::IPOW_MAGIC_NAME = "__ipow__";
const std::string Module::ILSHIFT_MAGIC_NAME = "__ilshift__";
const std::string Module::IRSHIFT_MAGIC_NAME = "__irshift__";
const std::string Module::IAND_MAGIC_NAME = "__iand__";
const std::string Module::IOR_MAGIC_NAME = "__ior__";
const std::string Module::IXOR_MAGIC_NAME = "__ixor__";

const std::string Module::RADD_MAGIC_NAME = "__radd__";
const std::string Module::RSUB_MAGIC_NAME = "__rsub__";
const std::string Module::RMUL_MAGIC_NAME = "__rmul__";
const std::string Module::RMATMUL_MAGIC_NAME = "__rmatmul__";
const std::string Module::RTRUE_DIV_MAGIC_NAME = "__rtruediv__";
const std::string Module::RFLOOR_DIV_MAGIC_NAME = "__rfloordiv__";
const std::string Module::RMOD_MAGIC_NAME = "__rmod__";
const std::string Module::RPOW_MAGIC_NAME = "__rpow__";
const std::string Module::RLSHIFT_MAGIC_NAME = "__rlshift__";
const std::string Module::RRSHIFT_MAGIC_NAME = "__rrshift__";
const std::string Module::RAND_MAGIC_NAME = "__rand__";
const std::string Module::ROR_MAGIC_NAME = "__ror__";
const std::string Module::RXOR_MAGIC_NAME = "__rxor__";

const std::string Module::INT_MAGIC_NAME = "__int__";
const std::string Module::FLOAT_MAGIC_NAME = "__float__";
const std::string Module::BOOL_MAGIC_NAME = "__bool__";
const std::string Module::STR_MAGIC_NAME = "__str__";
const std::string Module::REPR_MAGIC_NAME = "__repr__";

const std::string Module::GETITEM_MAGIC_NAME = "__getitem__";
const std::string Module::SETITEM_MAGIC_NAME = "__setitem__";
const std::string Module::ITER_MAGIC_NAME = "__iter__";
const std::string Module::LEN_MAGIC_NAME = "__len__";

const std::string Module::NEW_MAGIC_NAME = "__new__";
const std::string Module::INIT_MAGIC_NAME = "__init__";

const char Module::NodeId = 0;

Module::Module(const std::string &amp;name) : AcceptorExtend(name) {
  mainFunc = std::make_unique&lt;BodiedFunc&gt;("main");
  mainFunc-&gt;realize(cast&lt;types::FuncType&gt;(unsafeGetDummyFuncType()), {});
  mainFunc-&gt;setModule(this);
  mainFunc-&gt;setReplaceable(false);
  argVar = std::make_unique&lt;Var&gt;(unsafeGetArrayType(getStringType()), /*global=*/true,
                                 /*external=*/false, ".argv");
  argVar-&gt;setModule(this);
  argVar-&gt;setReplaceable(false);
}

void Module::parseCode(const std::string &amp;code) { cache-&gt;parseCode(code); }

Func *Module::getOrRealizeMethod(types::Type *parent, const std::string &amp;methodName,
                                 std::vector&lt;types::Type *&gt; args,
                                 std::vector&lt;types::Generic&gt; generics) {

@others
types::Type *Module::unsafeGetMemberedType(const std::string &amp;name, bool ref) {
  auto *rVal = getType(name);

  if (!rVal) {
    if (ref) {
      auto contentName = name + ".contents";
      auto *record = getType(contentName);
      if (!record) {
        record = Nr&lt;types::RecordType&gt;(contentName);
      }
      rVal = Nr&lt;types::RefType&gt;(name, cast&lt;types::RecordType&gt;(record));
    } else {
      rVal = Nr&lt;types::RecordType&gt;(name);
    }
  }

  return rVal;
}

types::Type *Module::unsafeGetIntNType(unsigned int len, bool sign) {
  auto name = types::IntNType::getInstanceName(len, sign);
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::IntNType&gt;(len, sign);
}

types::Type *Module::unsafeGetVectorType(unsigned int count, types::Type *base) {
  auto *primitive = cast&lt;types::PrimitiveType&gt;(base);
  auto name = types::VectorType::getInstanceName(count, primitive);
  if (auto *rVal = getType(name))
    return rVal;
  seqassertn(primitive, "base type must be a primitive type");
  return Nr&lt;types::VectorType&gt;(count, primitive);
}

types::Type *Module::unsafeGetUnionType(const std::vector&lt;types::Type *&gt; &amp;types) {
  auto name = types::UnionType::getInstanceName(types);
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::UnionType&gt;(types);
}

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.338">  auto cls =
      std::const_pointer_cast&lt;ast::types::Type&gt;(parent-&gt;getAstType())-&gt;getClass();
  auto method = cache-&gt;findMethod(cls.get(), methodName, generateDummyNames(args));
  if (!method)
    return nullptr;
  try {
    return cache-&gt;realizeFunction(method, translateArgs(cache, args),
                                  translateGenerics(cache, generics), cls);
  } catch (const exc::ParserException &amp;e) {
    for (int i = 0; i &lt; e.messages.size(); i++)
      LOG_IR("getOrRealizeMethod parser error at {}: {}", e.locations[i],
             e.messages[i]);
    return nullptr;
  }
</t>
<t tx="ekr.20230509083242.339">}

Func *Module::getOrRealizeFunc(const std::string &amp;funcName,
                               std::vector&lt;types::Type *&gt; args,
                               std::vector&lt;types::Generic&gt; generics,
</t>
<t tx="ekr.20230509083242.34">def __call__(self, u):
    """Calculates a point of the B-Spline using de Boors Algorithm"""
    dom = self.GetDomain()
    if u &lt; dom[0] or u &gt; dom[1]:
        raise ValueError("Function value not in domain")
    if u == dom[0]:
        return self.points[0]
    if u == dom[1]:
        return self.points[-1]
    I = self.GetIndex(u)
    d = [self.points[I - self.degree + 1 + ii]
         for ii in range(self.degree + 1)]
    U = self.knots
    for ik in range(1, self.degree + 1):
        for ii in range(I - self.degree + ik + 1, I + 2):
            ua = U[ii + self.degree - ik]
            ub = U[ii - 1]
            co1 = (ua - u) / (ua - ub)
            co2 = (u - ub) / (ua - ub)
            index = ii - I + self.degree - ik - 1
            d[index] = d[index].linear_combination(d[index + 1], co1, co2)
    return d[0]

</t>
<t tx="ekr.20230509083242.340">                               const std::string &amp;module) {
  @others
}

</t>
<t tx="ekr.20230509083242.341">auto fqName =
    module.empty() ? funcName : fmt::format(FMT_STRING("{}.{}"), module, funcName);
auto func = cache-&gt;findFunction(fqName);
if (!func)
  return nullptr;
auto arg = translateArgs(cache, args);
auto gens = translateGenerics(cache, generics);
try {
  return cache-&gt;realizeFunction(func, arg, gens);
} catch (const exc::ParserException &amp;e) {
  for (int i = 0; i &lt; e.messages.size(); i++)
    LOG_IR("getOrRealizeFunc parser error at {}: {}", e.locations[i], e.messages[i]);
  return nullptr;
}
</t>
<t tx="ekr.20230509083242.342">types::Type *Module::getOrRealizeType(const std::string &amp;typeName,
                                      std::vector&lt;types::Generic&gt; generics,
</t>
<t tx="ekr.20230509083242.343">                                      const std::string &amp;module) {
  @others
}

</t>
<t tx="ekr.20230509083242.344">auto fqName =
    module.empty() ? typeName : fmt::format(FMT_STRING("{}.{}"), module, typeName);
auto type = cache-&gt;findClass(fqName);
if (!type)
  return nullptr;
try {
  return cache-&gt;realizeType(type, translateGenerics(cache, generics));
} catch (const exc::ParserException &amp;e) {
  for (int i = 0; i &lt; e.messages.size(); i++)
    LOG_IR("getOrRealizeType parser error at {}: {}", e.locations[i], e.messages[i]);
  return nullptr;
}
</t>
<t tx="ekr.20230509083242.345">types::Type *Module::getVoidType() {
  if (auto *rVal = getType(VOID_NAME))
    return rVal;
  return Nr&lt;types::VoidType&gt;();
}

types::Type *Module::getBoolType() {
  if (auto *rVal = getType(BOOL_NAME))
    return rVal;
  return Nr&lt;types::BoolType&gt;();
}

types::Type *Module::getByteType() {
  if (auto *rVal = getType(BYTE_NAME))
    return rVal;
  return Nr&lt;types::ByteType&gt;();
}

types::Type *Module::getIntType() {
  if (auto *rVal = getType(INT_NAME))
    return rVal;
  return Nr&lt;types::IntType&gt;();
}

types::Type *Module::getFloatType() {
  if (auto *rVal = getType(FLOAT_NAME))
    return rVal;
  return Nr&lt;types::FloatType&gt;();
}

types::Type *Module::getFloat32Type() {
  if (auto *rVal = getType(FLOAT32_NAME))
    return rVal;
  return Nr&lt;types::Float32Type&gt;();
}

types::Type *Module::getStringType() {
  if (auto *rVal = getType(STRING_NAME))
    return rVal;
  return Nr&lt;types::RecordType&gt;(
      STRING_NAME,
      std::vector&lt;types::Type *&gt;{getIntType(), unsafeGetPointerType(getByteType())},
      std::vector&lt;std::string&gt;{"len", "ptr"});
}

types::Type *Module::getPointerType(types::Type *base) {
  return getOrRealizeType("Ptr", {base});
}

types::Type *Module::getArrayType(types::Type *base) {
  return getOrRealizeType("Array", {base});
}

types::Type *Module::getGeneratorType(types::Type *base) {
  return getOrRealizeType("Generator", {base});
}

types::Type *Module::getOptionalType(types::Type *base) {
  return getOrRealizeType("Optional", {base});
}

types::Type *Module::getFuncType(types::Type *rType,
                                 std::vector&lt;types::Type *&gt; argTypes, bool variadic) {
  auto args = translateArgs(cache, argTypes);
  args[0] = std::make_shared&lt;codon::ast::types::LinkType&gt;(rType-&gt;getAstType());
  auto *result = cache-&gt;makeFunction(args);
  if (variadic) {
    // Type checker types have no concept of variadic functions, so we will
    // create a new IR type here with the same AST type.
    auto *f = cast&lt;types::FuncType&gt;(result);
    result = unsafeGetFuncType(f-&gt;getName() + "$variadic", f-&gt;getReturnType(),
                               std::vector&lt;types::Type *&gt;(f-&gt;begin(), f-&gt;end()),
                               /*variadic=*/true);
    result-&gt;setAstType(f-&gt;getAstType());
  }
  return result;
}

types::Type *Module::getIntNType(unsigned int len, bool sign) {
  return getOrRealizeType(sign ? "Int" : "UInt", {len});
}

types::Type *Module::getVectorType(unsigned count, types::Type *base) {
  return getOrRealizeType("Vec", {base, count});
}

types::Type *Module::getTupleType(std::vector&lt;types::Type *&gt; args) {
  std::vector&lt;ast::types::TypePtr&gt; argTypes;
  for (auto *t : args) {
    seqassertn(t-&gt;getAstType(), "{} must have an ast type", *t);
    argTypes.push_back(t-&gt;getAstType());
  }
  return cache-&gt;makeTuple(argTypes);
}

types::Type *Module::getUnionType(std::vector&lt;types::Type *&gt; types) {
  std::vector&lt;ast::types::TypePtr&gt; argTypes;
  for (auto *t : types) {
    seqassertn(t-&gt;getAstType(), "{} must have an ast type", *t);
    argTypes.push_back(t-&gt;getAstType());
  }
  return cache-&gt;makeUnion(argTypes);
}

types::Type *Module::getNoneType() { return getOrRealizeType("NoneType"); }

Value *Module::getInt(int64_t v) { return Nr&lt;IntConst&gt;(v, getIntType()); }

Value *Module::getFloat(double v) { return Nr&lt;FloatConst&gt;(v, getFloatType()); }

Value *Module::getBool(bool v) { return Nr&lt;BoolConst&gt;(v, getBoolType()); }

Value *Module::getString(std::string v) {
  return Nr&lt;StringConst&gt;(std::move(v), getStringType());
}

types::Type *Module::unsafeGetDummyFuncType() {
  return unsafeGetFuncType("&lt;internal_func_type&gt;", getVoidType(), {});
}

types::Type *Module::unsafeGetPointerType(types::Type *base) {
  auto name = types::PointerType::getInstanceName(base);
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::PointerType&gt;(base);
}

types::Type *Module::unsafeGetArrayType(types::Type *base) {
  auto name = fmt::format(FMT_STRING(".Array[{}]"), base-&gt;referenceString());
  if (auto *rVal = getType(name))
    return rVal;
  std::vector&lt;types::Type *&gt; members = {getIntType(), unsafeGetPointerType(base)};
  std::vector&lt;std::string&gt; names = {"len", "ptr"};
  return Nr&lt;types::RecordType&gt;(name, members, names);
}

types::Type *Module::unsafeGetGeneratorType(types::Type *base) {
  auto name = types::GeneratorType::getInstanceName(base);
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::GeneratorType&gt;(base);
}

types::Type *Module::unsafeGetOptionalType(types::Type *base) {
  auto name = types::OptionalType::getInstanceName(base);
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::OptionalType&gt;(base);
}

types::Type *Module::unsafeGetFuncType(const std::string &amp;name, types::Type *rType,
                                       std::vector&lt;types::Type *&gt; argTypes,
</t>
<t tx="ekr.20230509083242.346">                                       bool variadic) {
  if (auto *rVal = getType(name))
    return rVal;
  return Nr&lt;types::FuncType&gt;(name, rType, std::move(argTypes), variadic);
}

</t>
<t tx="ekr.20230509083242.347">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iterator&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

#include "codon/cir/func.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {

namespace ast {
struct Cache;
class TranslateVisitor;
class TypecheckVisitor;
} // namespace ast

namespace ir {

@others
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::Module&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.348">/// CIR object representing a program.
class Module : public AcceptorExtend&lt;Module, Node&gt; {
public:
  static const std::string VOID_NAME;
  static const std::string BOOL_NAME;
  static const std::string BYTE_NAME;
  static const std::string INT_NAME;
  static const std::string FLOAT_NAME;
  static const std::string FLOAT32_NAME;
  static const std::string STRING_NAME;

  static const std::string EQ_MAGIC_NAME;
  static const std::string NE_MAGIC_NAME;
  static const std::string LT_MAGIC_NAME;
  static const std::string GT_MAGIC_NAME;
  static const std::string LE_MAGIC_NAME;
  static const std::string GE_MAGIC_NAME;

  static const std::string POS_MAGIC_NAME;
  static const std::string NEG_MAGIC_NAME;
  static const std::string INVERT_MAGIC_NAME;

  static const std::string ADD_MAGIC_NAME;
  static const std::string SUB_MAGIC_NAME;
  static const std::string MUL_MAGIC_NAME;
  static const std::string MATMUL_MAGIC_NAME;
  static const std::string TRUE_DIV_MAGIC_NAME;
  static const std::string FLOOR_DIV_MAGIC_NAME;
  static const std::string MOD_MAGIC_NAME;
  static const std::string POW_MAGIC_NAME;
  static const std::string LSHIFT_MAGIC_NAME;
  static const std::string RSHIFT_MAGIC_NAME;
  static const std::string AND_MAGIC_NAME;
  static const std::string OR_MAGIC_NAME;
  static const std::string XOR_MAGIC_NAME;

  static const std::string IADD_MAGIC_NAME;
  static const std::string ISUB_MAGIC_NAME;
  static const std::string IMUL_MAGIC_NAME;
  static const std::string IMATMUL_MAGIC_NAME;
  static const std::string ITRUE_DIV_MAGIC_NAME;
  static const std::string IFLOOR_DIV_MAGIC_NAME;
  static const std::string IMOD_MAGIC_NAME;
  static const std::string IPOW_MAGIC_NAME;
  static const std::string ILSHIFT_MAGIC_NAME;
  static const std::string IRSHIFT_MAGIC_NAME;
  static const std::string IAND_MAGIC_NAME;
  static const std::string IOR_MAGIC_NAME;
  static const std::string IXOR_MAGIC_NAME;

  static const std::string RADD_MAGIC_NAME;
  static const std::string RSUB_MAGIC_NAME;
  static const std::string RMUL_MAGIC_NAME;
  static const std::string RMATMUL_MAGIC_NAME;
  static const std::string RTRUE_DIV_MAGIC_NAME;
  static const std::string RFLOOR_DIV_MAGIC_NAME;
  static const std::string RMOD_MAGIC_NAME;
  static const std::string RPOW_MAGIC_NAME;
  static const std::string RLSHIFT_MAGIC_NAME;
  static const std::string RRSHIFT_MAGIC_NAME;
  static const std::string RAND_MAGIC_NAME;
  static const std::string ROR_MAGIC_NAME;
  static const std::string RXOR_MAGIC_NAME;

  static const std::string INT_MAGIC_NAME;
  static const std::string FLOAT_MAGIC_NAME;
  static const std::string BOOL_MAGIC_NAME;
  static const std::string STR_MAGIC_NAME;
  static const std::string REPR_MAGIC_NAME;

  static const std::string GETITEM_MAGIC_NAME;
  static const std::string SETITEM_MAGIC_NAME;
  static const std::string ITER_MAGIC_NAME;
  static const std::string LEN_MAGIC_NAME;

  static const std::string NEW_MAGIC_NAME;
  static const std::string INIT_MAGIC_NAME;

private:
  /// the module's "main" function
  std::unique_ptr&lt;Func&gt; mainFunc;
  /// the module's argv variable
  std::unique_ptr&lt;Var&gt; argVar;
  /// the global variables list
  std::list&lt;std::unique_ptr&lt;Var&gt;&gt; vars;
  /// the global variables map
  std::unordered_map&lt;id_t, std::list&lt;std::unique_ptr&lt;Var&gt;&gt;::iterator&gt; varMap;
  /// the global value list
  std::list&lt;std::unique_ptr&lt;Value&gt;&gt; values;
  /// the global value map
  std::unordered_map&lt;id_t, std::list&lt;std::unique_ptr&lt;Value&gt;&gt;::iterator&gt; valueMap;
  /// the global types list
  std::list&lt;std::unique_ptr&lt;types::Type&gt;&gt; types;
  /// the global types map
  std::unordered_map&lt;std::string, std::list&lt;std::unique_ptr&lt;types::Type&gt;&gt;::iterator&gt;
      typesMap;

  /// the type-checker cache
  ast::Cache *cache = nullptr;

public:
  static const char NodeId;

  /// Constructs an CIR module.
  /// @param name the module name
  explicit Module(const std::string &amp;name = "");

  virtual ~Module() noexcept = default;

  /// @return the main function
  Func *getMainFunc() { return mainFunc.get(); }
  /// @return the main function
  const Func *getMainFunc() const { return mainFunc.get(); }

  /// @return the arg var
  Var *getArgVar() { return argVar.get(); }
  /// @return the arg var
  const Var *getArgVar() const { return argVar.get(); }

  /// @return iterator to the first symbol
  auto begin() { return util::raw_ptr_adaptor(vars.begin()); }
  /// @return iterator beyond the last symbol
  auto end() { return util::raw_ptr_adaptor(vars.end()); }
  /// @return iterator to the first symbol
  auto begin() const { return util::const_raw_ptr_adaptor(vars.begin()); }
  /// @return iterator beyond the last symbol
  auto end() const { return util::const_raw_ptr_adaptor(vars.end()); }
  /// @return a pointer to the first symbol
  Var *front() { return vars.front().get(); }
  /// @return a pointer to the last symbol
  Var *back() { return vars.back().get(); }
  /// @return a pointer to the first symbol
  const Var *front() const { return vars.front().get(); }
  /// @return a pointer to the last symbol
  const Var *back() const { return vars.back().get(); }
  /// Gets a var by id.
  /// @param id the id
  /// @return the variable or nullptr
  Var *getVar(id_t id) {
    auto it = varMap.find(id);
    return it != varMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
@others
};

</t>
<t tx="ekr.20230509083242.349">  /// Gets a var by id.
  /// @param id the id
  /// @return the variable or nullptr
  const Var *getVar(id_t id) const {
    auto it = varMap.find(id);
    return it != varMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509083242.35">def GetIndex(self, u):
    dom = self.GetDomain()
    for ii in range(self.degree - 1, len(self.knots) - self.degree):
        if u &gt;= self.knots[ii] and u &lt; self.knots[ii + 1]:
            I = ii
            break
    else:
        I = dom[1] - 1
    return I

</t>
<t tx="ekr.20230509083242.350">  /// Removes a given var.
  /// @param v the var
  void remove(const Var *v) {
    auto it = varMap.find(v-&gt;getId());
    vars.erase(it-&gt;second);
    varMap.erase(it);
  }

</t>
<t tx="ekr.20230509083242.351">  /// @return iterator to the first value
  auto values_begin() { return util::raw_ptr_adaptor(values.begin()); }
  /// @return iterator beyond the last value
  auto values_end() { return util::raw_ptr_adaptor(values.end()); }
  /// @return iterator to the first value
  auto values_begin() const { return util::const_raw_ptr_adaptor(values.begin()); }
  /// @return iterator beyond the last value
  auto values_end() const { return util::const_raw_ptr_adaptor(values.end()); }
  /// @return a pointer to the first value
  Value *values_front() { return values.front().get(); }
  /// @return a pointer to the last value
  Value *values_back() { return values.back().get(); }
  /// @return a pointer to the first value
  const Value *values_front() const { return values.front().get(); }
  /// @return a pointer to the last value
  const Value *values_back() const { return values.back().get(); }
  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  Value *getValue(id_t id) {
    auto it = valueMap.find(id);
    return it != valueMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509083242.352">  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  const Value *getValue(id_t id) const {
    auto it = valueMap.find(id);
    return it != valueMap.end() ? it-&gt;second-&gt;get() : nullptr;
  }
</t>
<t tx="ekr.20230509083242.353">  /// Removes a given value.
  /// @param v the value
  void remove(const Value *v) {
    auto it = valueMap.find(v-&gt;getId());
    values.erase(it-&gt;second);
    valueMap.erase(it);
  }

</t>
<t tx="ekr.20230509083242.354">  /// @return iterator to the first type
  auto types_begin() { return util::raw_ptr_adaptor(types.begin()); }
  /// @return iterator beyond the last type
  auto types_end() { return util::raw_ptr_adaptor(types.end()); }
  /// @return iterator to the first type
  auto types_begin() const { return util::const_raw_ptr_adaptor(types.begin()); }
  /// @return iterator beyond the last type
  auto types_end() const { return util::const_raw_ptr_adaptor(types.end()); }
  /// @return a pointer to the first type
  types::Type *types_front() const { return types.front().get(); }
  /// @return a pointer to the last type
  types::Type *types_back() const { return types.back().get(); }
  /// @param name the type's name
  /// @return the type with the given name
  types::Type *getType(const std::string &amp;name) {
    auto it = typesMap.find(name);
    return it == typesMap.end() ? nullptr : it-&gt;second-&gt;get();
  }
  /// @param name the type's name
  /// @return the type with the given name
  types::Type *getType(const std::string &amp;name) const {
    auto it = typesMap.find(name);
    return it == typesMap.end() ? nullptr : it-&gt;second-&gt;get();
  }
</t>
<t tx="ekr.20230509083242.355">  /// Removes a given type.
  /// @param t the type
  void remove(types::Type *t) {
    auto it = typesMap.find(t-&gt;getName());
    types.erase(it-&gt;second);
    typesMap.erase(it);
  }

</t>
<t tx="ekr.20230509083242.356">  /// Constructs and registers an IR node with provided source information.
  /// @param s the source information
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(codon::SrcInfo s, Args &amp;&amp;...args) {
    auto *ret = new DesiredType(std::forward&lt;Args&gt;(args)...);
    ret-&gt;setModule(this);
    ret-&gt;setSrcInfo(s);

    store(ret);
    return ret;
  }
</t>
<t tx="ekr.20230509083242.357">  /// Constructs and registers an IR node with provided source node.
  /// @param s the source node
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(const codon::SrcObject *s, Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(s-&gt;getSrcInfo(), std::forward&lt;Args&gt;(args)...);
  }
</t>
<t tx="ekr.20230509083242.358">  /// Constructs and registers an IR node with provided source node.
  /// @param s the source node
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt;
  DesiredType *N(const Node *s, Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(s-&gt;getSrcInfo(), std::forward&lt;Args&gt;(args)...);
  }
</t>
<t tx="ekr.20230509083242.359">  /// Constructs and registers an IR node with no source information.
  /// @param args the arguments
  /// @return the new node
  template &lt;typename DesiredType, typename... Args&gt; DesiredType *Nr(Args &amp;&amp;...args) {
    return N&lt;DesiredType&gt;(codon::SrcInfo(), std::forward&lt;Args&gt;(args)...);
  }

  /// @return the type-checker cache
  ast::Cache *getCache() const { return cache; }
  /// Sets the type-checker cache.
  /// @param c the cache
  void setCache(ast::Cache *c) { cache = c; }

  /// Parse a codon code block.
  void parseCode(const std::string &amp;code);

  /// Gets or realizes a method.
  /// @param parent the parent class
  /// @param methodName the method name
  /// @param args the argument types
  /// @param generics the generics
  /// @return the method or nullptr
  Func *getOrRealizeMethod(types::Type *parent, const std::string &amp;methodName,
                           std::vector&lt;types::Type *&gt; args,
                           std::vector&lt;types::Generic&gt; generics = {});

  /// Gets or realizes a function.
  /// @param funcName the function name
  /// @param args the argument types
  /// @param generics the generics
  /// @param module the module of the function
  /// @return the function or nullptr
  Func *getOrRealizeFunc(const std::string &amp;funcName, std::vector&lt;types::Type *&gt; args,
                         std::vector&lt;types::Generic&gt; generics = {},
                         const std::string &amp;module = "");

  /// Gets or realizes a type.
  /// @param typeName the type name
  /// @param generics the generics
  /// @param module the module of the type
  /// @return the function or nullptr
  types::Type *getOrRealizeType(const std::string &amp;typeName,
                                std::vector&lt;types::Generic&gt; generics = {},
                                const std::string &amp;module = "");

  /// @return the void type
  types::Type *getVoidType();
  /// @return the bool type
  types::Type *getBoolType();
  /// @return the byte type
  types::Type *getByteType();
  /// @return the int type
  types::Type *getIntType();
  /// @return the float type
  types::Type *getFloatType();
  /// @return the float32 type
  types::Type *getFloat32Type();
  /// @return the string type
  types::Type *getStringType();
  /// Gets a pointer type.
  /// @param base the base type
  /// @return a pointer type that references the base
  types::Type *getPointerType(types::Type *base);
  /// Gets an array type.
  /// @param base the base type
  /// @return an array type that contains the base
  types::Type *getArrayType(types::Type *base);
  /// Gets a generator type.
  /// @param base the base type
  /// @return a generator type that yields the base
  types::Type *getGeneratorType(types::Type *base);
  /// Gets an optional type.
  /// @param base the base type
  /// @return an optional type that contains the base
  types::Type *getOptionalType(types::Type *base);
  /// Gets a function type.
  /// @param rType the return type
  /// @param argTypes the argument types
  /// @param variadic true if variadic (e.g. "printf" in C)
  /// @return the void type
  types::Type *getFuncType(types::Type *rType, std::vector&lt;types::Type *&gt; argTypes,
                           bool variadic = false);
  /// Gets a variable length integer type.
  /// @param len the length
  /// @param sign true if signed
  /// @return a variable length integer type
  types::Type *getIntNType(unsigned len, bool sign);
  /// Gets a vector type.
  /// @param count the vector size
  /// @param base the vector base type (MUST be a primitive type)
  /// @return a vector type
  types::Type *getVectorType(unsigned count, types::Type *base);
  /// Gets a tuple type.
  /// @param args the arg types
  /// @return the tuple type
  types::Type *getTupleType(std::vector&lt;types::Type *&gt; args);
  /// Gets a union type.
  /// @param types the alternative types
  /// @return the union type
  types::Type *getUnionType(std::vector&lt;types::Type *&gt; types);
  /// Gets the "none" type (i.e. empty tuple).
  /// @return none type
  types::Type *getNoneType();

  /// @param v the value
  /// @return an int constant
  Value *getInt(int64_t v);
  /// @param v the value
  /// @return a float constant
  Value *getFloat(double v);
  /// @param v the value
  /// @return a bool constant
  Value *getBool(bool v);
  /// @param v the value
  /// @return a string constant
  Value *getString(std::string v);

  /// Gets a dummy function type. Should generally not be used as no type-checker
  /// information is generated.
  /// @return a func type with no args and void return type.
  types::Type *unsafeGetDummyFuncType();
  /// Gets a pointer type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return a pointer type that references the base
  types::Type *unsafeGetPointerType(types::Type *base);
  /// Gets an array type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return an array type that contains the base
  types::Type *unsafeGetArrayType(types::Type *base);
  /// Gets a generator type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return a generator type that yields the base
  types::Type *unsafeGetGeneratorType(types::Type *base);
  /// Gets an optional type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param base the base type
  /// @return an optional type that contains the base
  types::Type *unsafeGetOptionalType(types::Type *base);
  /// Gets a function type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param rType the return type
  /// @param argTypes the argument types
  /// @param variadic true if variadic (e.g. "printf" in C)
  /// @return the void type
  types::Type *unsafeGetFuncType(const std::string &amp;name, types::Type *rType,
                                 std::vector&lt;types::Type *&gt; argTypes,
                                 bool variadic = false);
  /// Gets a membered type. Should generally not be used as no type-checker
  /// information is generated.
  /// @param name the type's name
  /// @param ref whether the type should be a ref
  /// @return an empty membered/ref type
  types::Type *unsafeGetMemberedType(const std::string &amp;name, bool ref = false);
  /// Gets a variable length integer type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param len the length
  /// @param sign true if signed
  /// @return a variable length integer type
  types::Type *unsafeGetIntNType(unsigned len, bool sign);
  /// Gets a vector type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param count the vector size
  /// @param base the vector base type (MUST be a primitive type)
  /// @return a vector type
  types::Type *unsafeGetVectorType(unsigned count, types::Type *base);
  /// Gets a union type. Should generally not be used as no
  /// type-checker information is generated.
  /// @param types the alternative types
  /// @return a union type
  types::Type *unsafeGetUnionType(const std::vector&lt;types::Type *&gt; &amp;types);

private:
</t>
<t tx="ekr.20230509083242.36">def __len__(self):
    return len(self.points)

</t>
<t tx="ekr.20230509083242.360">  void store(types::Type *t) {
    types.emplace_back(t);
    typesMap[t-&gt;getName()] = std::prev(types.end());
  }
</t>
<t tx="ekr.20230509083242.361">  void store(Value *v) {
    values.emplace_back(v);
    valueMap[v-&gt;getId()] = std::prev(values.end());
  }
</t>
<t tx="ekr.20230509083242.362">  void store(Var *v) {
    vars.emplace_back(v);
    varMap[v-&gt;getId()] = std::prev(vars.end());
  }
</t>
<t tx="ekr.20230509083242.363">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/func.h"
#include "codon/cir/types/types.h"

namespace codon {
namespace ir {

struct PyFunction {
  enum Type { TOPLEVEL, METHOD, CLASS, STATIC };
  std::string name;
  std::string doc;
  Func *func = nullptr;
  Type type = Type::TOPLEVEL;
  int nargs = 0;
  bool keywords = false;
  bool coexist = false;
};

struct PyMember {
  enum Type {
    SHORT = 0,
    INT = 1,
    LONG = 2,
    FLOAT = 3,
    DOUBLE = 4,
    STRING = 5,
    OBJECT = 6,
    CHAR = 7,
    BYTE = 8,
    UBYTE = 9,
    USHORT = 10,
    UINT = 11,
    ULONG = 12,
    STRING_INPLACE = 13,
    BOOL = 14,
    OBJECT_EX = 16,
    LONGLONG = 17,
    ULONGLONG = 18,
    PYSSIZET = 19,
  };

  std::string name;
  std::string doc;
  Type type = Type::SHORT;
  bool readonly = false;
  /// Indexes of the member. For example, in the
  /// tuple (a, (b, c, (d,))), 'a' would have indexes
  /// [0], 'b' would have indexes [1, 0], 'c' would
  /// have indexes [1, 1], and 'd' would have indexes
  /// [1, 2, 0]. This corresponds to an LLVM GEP.
  std::vector&lt;int&gt; indexes;
};

struct PyGetSet {
  std::string name;
  std::string doc;
  Func *get = nullptr;
  Func *set = nullptr;
};

struct PyType {
  std::string name;
  std::string doc;
  types::Type *type = nullptr;
  PyType *base = nullptr;
  Func *repr = nullptr;
  Func *add = nullptr;
  Func *iadd = nullptr;
  Func *sub = nullptr;
  Func *isub = nullptr;
  Func *mul = nullptr;
  Func *imul = nullptr;
  Func *mod = nullptr;
  Func *imod = nullptr;
  Func *divmod = nullptr;
  Func *pow = nullptr;
  Func *ipow = nullptr;
  Func *neg = nullptr;
  Func *pos = nullptr;
  Func *abs = nullptr;
  Func *bool_ = nullptr;
  Func *invert = nullptr;
  Func *lshift = nullptr;
  Func *ilshift = nullptr;
  Func *rshift = nullptr;
  Func *irshift = nullptr;
  Func *and_ = nullptr;
  Func *iand = nullptr;
  Func *xor_ = nullptr;
  Func *ixor = nullptr;
  Func *or_ = nullptr;
  Func *ior = nullptr;
  Func *int_ = nullptr;
  Func *float_ = nullptr;
  Func *floordiv = nullptr;
  Func *ifloordiv = nullptr;
  Func *truediv = nullptr;
  Func *itruediv = nullptr;
  Func *index = nullptr;
  Func *matmul = nullptr;
  Func *imatmul = nullptr;
  Func *len = nullptr;
  Func *getitem = nullptr;
  Func *setitem = nullptr;
  Func *contains = nullptr;
  Func *hash = nullptr;
  Func *call = nullptr;
  Func *str = nullptr;
  Func *cmp = nullptr;
  Func *iter = nullptr;
  Func *iternext = nullptr;
  Func *del = nullptr;
  Func *init = nullptr;
  std::vector&lt;PyFunction&gt; methods;
  std::vector&lt;PyMember&gt; members;
  std::vector&lt;PyGetSet&gt; getset;
  Func *typePtrHook = nullptr;
};

struct PyModule {
  std::string name;
  std::string doc;
  std::vector&lt;PyFunction&gt; functions;
  std::vector&lt;PyType&gt; types;
};

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.364">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "value.h"

#include "codon/cir/instr.h"
#include "codon/cir/module.h"

namespace codon {
namespace ir {

const char Value::NodeId = 0;

Value *Value::operator==(Value &amp;other) {
  return doBinaryOp(Module::EQ_MAGIC_NAME, other);
}

Value *Value::operator!=(Value &amp;other) {
  return doBinaryOp(Module::NE_MAGIC_NAME, other);
}

Value *Value::operator&lt;(Value &amp;other) {
  return doBinaryOp(Module::LT_MAGIC_NAME, other);
}

Value *Value::operator&gt;(Value &amp;other) {
  return doBinaryOp(Module::GT_MAGIC_NAME, other);
}

Value *Value::operator&lt;=(Value &amp;other) {
  return doBinaryOp(Module::LE_MAGIC_NAME, other);
}

Value *Value::operator&gt;=(Value &amp;other) {
  return doBinaryOp(Module::GE_MAGIC_NAME, other);
}

Value *Value::operator+() { return doUnaryOp(Module::POS_MAGIC_NAME); }

Value *Value::operator-() { return doUnaryOp(Module::NEG_MAGIC_NAME); }

Value *Value::operator~() { return doUnaryOp(Module::INVERT_MAGIC_NAME); }

Value *Value::operator+(Value &amp;other) {
  return doBinaryOp(Module::ADD_MAGIC_NAME, other);
}

Value *Value::operator-(Value &amp;other) {
  return doBinaryOp(Module::SUB_MAGIC_NAME, other);
}

Value *Value::operator*(Value &amp;other) {
  return doBinaryOp(Module::MUL_MAGIC_NAME, other);
}

Value *Value::matMul(Value &amp;other) {
  return doBinaryOp(Module::MATMUL_MAGIC_NAME, other);
}

Value *Value::trueDiv(Value &amp;other) {
  return doBinaryOp(Module::TRUE_DIV_MAGIC_NAME, other);
}

Value *Value::operator/(Value &amp;other) {
  return doBinaryOp(Module::FLOOR_DIV_MAGIC_NAME, other);
}

Value *Value::operator%(Value &amp;other) {
  return doBinaryOp(Module::MOD_MAGIC_NAME, other);
}

Value *Value::pow(Value &amp;other) { return doBinaryOp(Module::POW_MAGIC_NAME, other); }

Value *Value::operator&lt;&lt;(Value &amp;other) {
  return doBinaryOp(Module::LSHIFT_MAGIC_NAME, other);
}

Value *Value::operator&gt;&gt;(Value &amp;other) {
  return doBinaryOp(Module::RSHIFT_MAGIC_NAME, other);
}

Value *Value::operator&amp;(Value &amp;other) {
  return doBinaryOp(Module::AND_MAGIC_NAME, other);
}

Value *Value::operator|(Value &amp;other) {
  return doBinaryOp(Module::OR_MAGIC_NAME, other);
}

Value *Value::operator^(Value &amp;other) {
  return doBinaryOp(Module::XOR_MAGIC_NAME, other);
}

Value *Value::operator||(Value &amp;other) {
  auto *module = getModule();
  return module-&gt;Nr&lt;TernaryInstr&gt;(toBool(), module-&gt;getBool(true), other.toBool());
}

Value *Value::operator&amp;&amp;(Value &amp;other) {
  auto *module = getModule();
  return module-&gt;Nr&lt;TernaryInstr&gt;(toBool(), other.toBool(), module-&gt;getBool(false));
}

Value *Value::operator[](Value &amp;other) {
  return doBinaryOp(Module::GETITEM_MAGIC_NAME, other);
}

Value *Value::toInt() { return doUnaryOp(Module::INT_MAGIC_NAME); }

Value *Value::toFloat() { return doUnaryOp(Module::FLOAT_MAGIC_NAME); }

Value *Value::toBool() { return doUnaryOp(Module::BOOL_MAGIC_NAME); }

Value *Value::toStr() { return doUnaryOp(Module::REPR_MAGIC_NAME); }

Value *Value::len() { return doUnaryOp(Module::LEN_MAGIC_NAME); }

Value *Value::iter() { return doUnaryOp(Module::ITER_MAGIC_NAME); }

Value *Value::doUnaryOp(const std::string &amp;name) {
  auto *module = getModule();
  auto *fn = module-&gt;getOrRealizeMethod(getType(), name,
                                        std::vector&lt;types::Type *&gt;{getType()});

  if (!fn)
    return nullptr;

  auto *fnVal = module-&gt;Nr&lt;VarValue&gt;(fn);
  return (*fnVal)(*this);
}

Value *Value::doBinaryOp(const std::string &amp;name, Value &amp;other) {
  auto *module = getModule();
  auto *fn = module-&gt;getOrRealizeMethod(
      getType(), name, std::vector&lt;types::Type *&gt;{getType(), other.getType()});

  if (!fn)
    return nullptr;

  auto *fnVal = module-&gt;Nr&lt;VarValue&gt;(fn);
  return (*fnVal)(*this, other);
}

Value *Value::doCall(const std::vector&lt;Value *&gt; &amp;args) {
  auto *module = getModule();
  return module-&gt;Nr&lt;CallInstr&gt;(this, args);
}

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.365">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/base.h"
#include "codon/cir/types/types.h"
#include "codon/cir/util/packs.h"

namespace codon {
namespace ir {

class Func;

@others
} // namespace ir
} // namespace codon

template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ir::Value, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.366">class Value : public ReplaceableNodeBase&lt;Value&gt;, public IdMixin {
public:
  static const char NodeId;

  /// Constructs a value.
  /// @param the value's name
  explicit Value(std::string name = "") : ReplaceableNodeBase(std::move(name)) {}

  virtual ~Value() noexcept = default;

  std::string referenceString() const final {
    return fmt::format(FMT_STRING("{}.{}"), getName(), getId());
  }

  std::vector&lt;Value *&gt; getUsedValues() final { return getActual()-&gt;doGetUsedValues(); }
  std::vector&lt;const Value *&gt; getUsedValues() const final {
    auto ret = getActual()-&gt;doGetUsedValues();
    return std::vector&lt;const Value *&gt;(ret.begin(), ret.end());
  }
@others
  using Node::replaceUsedVariable;

  /// @return the value's type
  types::Type *getType() const { return getActual()-&gt;doGetType(); }

  id_t getId() const override { return getActual()-&gt;id; }

  Value *operator==(Value &amp;other);
  Value *operator!=(Value &amp;other);
  Value *operator&lt;(Value &amp;other);
  Value *operator&gt;(Value &amp;other);
  Value *operator&lt;=(Value &amp;other);
  Value *operator&gt;=(Value &amp;other);

  Value *operator+();
  Value *operator-();
  Value *operator~();

  Value *operator+(Value &amp;other);
  Value *operator-(Value &amp;other);
  Value *operator*(Value &amp;other);
  Value *matMul(Value &amp;other);
  Value *trueDiv(Value &amp;other);
  Value *operator/(Value &amp;other);
  Value *operator%(Value &amp;other);
  Value *pow(Value &amp;other);
  Value *operator&lt;&lt;(Value &amp;other);
  Value *operator&gt;&gt;(Value &amp;other);
  Value *operator&amp;(Value &amp;other);
  Value *operator|(Value &amp;other);
  Value *operator^(Value &amp;other);

  Value *operator||(Value &amp;other);
  Value *operator&amp;&amp;(Value &amp;other);

  template &lt;typename... Args&gt; Value *operator()(Args &amp;&amp;...args) {
    std::vector&lt;Value *&gt; dst;
    util::stripPack(dst, std::forward&lt;Args&gt;(args)...);
    return doCall(dst);
  }
  Value *operator[](Value &amp;other);

  Value *toInt();
  Value *toFloat();
  Value *toBool();
  Value *toStr();

  Value *len();
  Value *iter();

private:
  Value *doUnaryOp(const std::string &amp;name);
  Value *doBinaryOp(const std::string &amp;name, Value &amp;other);

  Value *doCall(const std::vector&lt;Value *&gt; &amp;args);

  virtual types::Type *doGetType() const = 0;

  virtual std::vector&lt;Value *&gt; doGetUsedValues() const { return {}; }
  virtual int doReplaceUsedValue(id_t id, Value *newValue) { return 0; }

  virtual std::vector&lt;types::Type *&gt; doGetUsedTypes() const { return {}; }
  virtual int doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
    return 0;
  }

  virtual std::vector&lt;Var *&gt; doGetUsedVariables() const { return {}; }
  virtual int doReplaceUsedVariable(id_t id, Var *newVar) { return 0; }
};

</t>
<t tx="ekr.20230509083242.367">  int replaceUsedValue(id_t id, Value *newValue) final {
    return getActual()-&gt;doReplaceUsedValue(id, newValue);
  }
</t>
<t tx="ekr.20230509083242.368">  using Node::replaceUsedValue;

  std::vector&lt;types::Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
</t>
<t tx="ekr.20230509083242.369">  int replaceUsedType(const std::string &amp;name, types::Type *newType) final {
    return getActual()-&gt;doReplaceUsedType(name, newType);
  }
</t>
<t tx="ekr.20230509083242.37">def __repr__(self):
    return "Spline(%r, %r, %r)" % (self.points, self.degree, self.knots)


</t>
<t tx="ekr.20230509083242.370">  using Node::replaceUsedType;

  std::vector&lt;Var *&gt; getUsedVariables() final {
    return getActual()-&gt;doGetUsedVariables();
  }
  std::vector&lt;const Var *&gt; getUsedVariables() const final {
    auto ret = getActual()-&gt;doGetUsedVariables();
    return std::vector&lt;const Var *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509083242.371">  int replaceUsedVariable(id_t id, Var *newVar) final {
    return getActual()-&gt;doReplaceUsedVariable(id, newVar);
  }
</t>
<t tx="ekr.20230509083242.372">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "var.h"

#include "codon/cir/module.h"

namespace codon {
namespace ir {

const char Var::NodeId = 0;

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.373">int Var::doReplaceUsedType(const std::string &amp;name, types::Type *newType) {
  if (type-&gt;getName() == name) {
    type = newType;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.374">const char VarValue::NodeId = 0;

</t>
<t tx="ekr.20230509083242.375">int VarValue::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (val-&gt;getId() == id) {
    val = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.376">const char PointerValue::NodeId = 0;

types::Type *PointerValue::doGetType() const {
  return getModule()-&gt;getPointerType(val-&gt;getType());
}

</t>
<t tx="ekr.20230509083242.377">int PointerValue::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (val-&gt;getId() == id) {
    val = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.378">@path C:/Repos/codon/codon/cir/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/types/types.h"
#include "codon/cir/value.h"
#include "codon/util/common.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

class Func;
class Var;

@others
} // namespace ir
} // namespace codon

template &lt;typename T&gt;
struct fmt::formatter&lt;T,
                      std::enable_if_t&lt;std::is_base_of&lt;codon::ir::Var, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.379">/// CIR object representing a variable.
class Var : public ReplaceableNodeBase&lt;Var&gt;, public IdMixin {
private:
  /// the variable's type
  types::Type *type;
  /// true if the variable is global
  bool global;
  /// true if the variable is external
  bool external;

public:
  static const char NodeId;

  /// Constructs a variable.
  /// @param type the variable's type
  /// @param global true if the variable is global
  /// @param external true if the variable is external
  /// @param name the variable's name
  explicit Var(types::Type *type, bool global = false, bool external = false,
               std::string name = "")
      : ReplaceableNodeBase(std::move(name)), type(type), global(global),
@others
  using Node::replaceUsedVariable;

  /// @return the type
  types::Type *getType() const { return getActual()-&gt;type; }
  /// Sets the type.
  /// @param t the new type
  void setType(types::Type *t) { getActual()-&gt;type = t; }

  /// @return true if the variable is global
  bool isGlobal() const { return getActual()-&gt;global; }
  /// Sets the global flag.
  /// @param v the new value
  void setGlobal(bool v = true) { getActual()-&gt;global = v; }

  /// @return true if the variable is external
  bool isExternal() const { return getActual()-&gt;external; }
  /// Sets the external flag.
  /// @param v the new value
  void setExternal(bool v = true) { getActual()-&gt;external = v; }

  std::string referenceString() const final {
    return fmt::format(FMT_STRING("{}.{}"), getName(), getId());
  }

  id_t getId() const override { return getActual()-&gt;id; }

protected:
  virtual std::vector&lt;Value *&gt; doGetUsedValues() const { return {}; }
  virtual int doReplaceUsedValue(id_t id, Value *newValue) { return 0; }

  virtual std::vector&lt;types::Type *&gt; doGetUsedTypes() const { return {type}; }
  virtual int doReplaceUsedType(const std::string &amp;name, types::Type *newType);

  virtual std::vector&lt;Var *&gt; doGetUsedVariables() const { return {}; }
  virtual int doReplaceUsedVariable(id_t id, Var *newVar) { return 0; }
};

</t>
<t tx="ekr.20230509083242.38">def write_ppm(im, filename):
    magic = 'P6\n'
    maxval = 255
    w = len(im)
    h = len(im[0])

    with open(filename, "w", encoding="latin1", newline='') as fp:
        fp.write(magic)
        fp.write('%i %i\n%i\n' % (w, h, maxval))
        for j in range(h):
            for i in range(w):
                val = im[i][j]
                c = val * 255
                fp.write('%c%c%c' % (c, c, c))


</t>
<t tx="ekr.20230509083242.380">        external(external) {}

  virtual ~Var() noexcept = default;

  std::vector&lt;Value *&gt; getUsedValues() final { return getActual()-&gt;doGetUsedValues(); }
  std::vector&lt;const Value *&gt; getUsedValues() const final {
    auto ret = getActual()-&gt;doGetUsedValues();
    return std::vector&lt;const Value *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509083242.381">  int replaceUsedValue(id_t id, Value *newValue) final {
    return doReplaceUsedValue(id, newValue);
  }
</t>
<t tx="ekr.20230509083242.382">  using Node::replaceUsedValue;

  std::vector&lt;types::Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
</t>
<t tx="ekr.20230509083242.383">  int replaceUsedType(const std::string &amp;name, types::Type *newType) final {
    return getActual()-&gt;doReplaceUsedType(name, newType);
  }
</t>
<t tx="ekr.20230509083242.384">  using Node::replaceUsedType;

  std::vector&lt;Var *&gt; getUsedVariables() final { return doGetUsedVariables(); }
  std::vector&lt;const Var *&gt; getUsedVariables() const final {
    auto ret = doGetUsedVariables();
    return std::vector&lt;const Var *&gt;(ret.begin(), ret.end());
  }
</t>
<t tx="ekr.20230509083242.385">  int replaceUsedVariable(id_t id, Var *newVar) final {
    return getActual()-&gt;doReplaceUsedVariable(id, newVar);
  }
</t>
<t tx="ekr.20230509083242.386">/// Value that contains an unowned variable reference.
class VarValue : public AcceptorExtend&lt;VarValue, Value&gt; {
private:
  /// the referenced var
  Var *val;

public:
  static const char NodeId;

  /// Constructs a variable value.
  /// @param val the referenced value
  /// @param name the name
  explicit VarValue(Var *val, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val) {}

  /// @return the variable
  Var *getVar() { return val; }
  /// @return the variable
  const Var *getVar() const { return val; }
  /// Sets the variable.
  /// @param v the new variable
  void setVar(Var *v) { val = v; }

private:
  types::Type *doGetType() const override { return val-&gt;getType(); }

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {val}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.387">/// Value that represents a pointer.
class PointerValue : public AcceptorExtend&lt;PointerValue, Value&gt; {
private:
  /// the referenced var
  Var *val;

public:
  static const char NodeId;

  /// Constructs a variable value.
  /// @param val the referenced value
  /// @param name the name
  explicit PointerValue(Var *val, std::string name = "")
      : AcceptorExtend(std::move(name)), val(val) {}

  /// @return the variable
  Var *getVar() { return val; }
  /// @return the variable
  const Var *getVar() const { return val; }
  /// Sets the variable.
  /// @param v the new variable
  void setVar(Var *v) { val = v; }

private:
  types::Type *doGetType() const override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {val}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.388"></t>
<t tx="ekr.20230509083242.389">@path C:/Repos/codon/codon/cir/analyze/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "analysis.h"

#include "codon/cir/transform/manager.h"

namespace codon {
namespace ir {
namespace analyze {

Result *Analysis::doGetAnalysis(const std::string &amp;key) {
  return manager ? manager-&gt;getAnalysisResult(key) : nullptr;
}

} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.39">class Chaosgame(object):

    @others
</t>
<t tx="ekr.20230509083242.390">@path C:/Repos/codon/codon/cir/analyze/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/module.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace analyze {

/// Analysis result base struct.
struct Result {
  virtual ~Result() noexcept = default;
};

@others
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.391">/// Base class for IR analyses.
class Analysis {
private:
  transform::PassManager *manager = nullptr;

public:
  virtual ~Analysis() noexcept = default;

  /// @return a unique key for this pass
  virtual std::string getKey() const = 0;

  /// Execute the analysis.
  /// @param module the module
  virtual std::unique_ptr&lt;Result&gt; run(const Module *module) = 0;

  /// Sets the manager.
  /// @param mng the new manager
  void setManager(transform::PassManager *mng) { manager = mng; }
@others
private:
  analyze::Result *doGetAnalysis(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509083242.392">  /// Returns the result of a given analysis.
  /// @param key the analysis key
  template &lt;typename AnalysisType&gt;
  AnalysisType *getAnalysisResult(const std::string &amp;key) {
    return static_cast&lt;AnalysisType *&gt;(doGetAnalysis(key));
  }

</t>
<t tx="ekr.20230509083242.393"></t>
<t tx="ekr.20230509083242.394">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "capture.h"

#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;utility&gt;

#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/side_effect.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {
namespace {

template &lt;typename S, typename T&gt; bool contains(const S &amp;x, T i) {
  for (auto a : x) {
    if (a == i)
      return true;
  }
  return false;
}

template &lt;typename S, typename T&gt; bool containsId(const S &amp;x, T i) {
  for (auto a : x) {
    if (a-&gt;getId() == i-&gt;getId())
      return true;
  }
  return false;
}

template &lt;typename T&gt; bool shouldTrack(const T *x) {
  // We only care about things with pointers,
  // since you can't capture primitive types
  // like int, float, etc.
  return x &amp;&amp; !x-&gt;getType()-&gt;isAtomic();
}

template &lt;&gt; bool shouldTrack(const types::Type *x) { return x &amp;&amp; !x-&gt;isAtomic(); }

struct CaptureContext;

bool extractVars(CaptureContext &amp;cc, const Value *v, std::vector&lt;const Var *&gt; &amp;result);

@others
} // namespace

CaptureInfo CaptureInfo::unknown(const Func *func, types::Type *type) {
  if (!shouldTrack(type))
    return CaptureInfo::nothing();

  CaptureInfo c;
  unsigned i = 0;
  for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
    if (shouldTrack(*it))
      c.argCaptures.push_back(i);
    ++i;
  }
  c.returnCaptures = shouldTrack(util::getReturnType(func));
  c.externCaptures = true;
  c.modified = true;
  return c;
}

const std::string CaptureAnalysis::KEY = "core-analyses-capture";

std::unique_ptr&lt;Result&gt; CaptureAnalysis::run(const Module *m) {
  auto res = std::make_unique&lt;CaptureResult&gt;();
  auto *rdResult = getAnalysisResult&lt;RDResult&gt;(rdAnalysisKey);
  auto *domResult = getAnalysisResult&lt;DominatorResult&gt;(domAnalysisKey);
  res-&gt;rdResult = rdResult;
  res-&gt;domResult = domResult;
  CaptureContext cc(rdResult, domResult);

  if (const auto *main = cast&lt;BodiedFunc&gt;(m-&gt;getMainFunc())) {
    auto ans = cc.get(main);
    res-&gt;results.emplace(main-&gt;getId(), ans);
  }

  for (const auto *var : *m) {
    if (const auto *f = cast&lt;Func&gt;(var)) {
      auto ans = cc.get(f);
      res-&gt;results.emplace(f-&gt;getId(), ans);
    }
  }

  return res;
}

CaptureInfo escapes(const BodiedFunc *func, const Value *value, CaptureResult *cr) {
  if (!shouldTrack(value))
    return CaptureInfo::nothing();

  CaptureContext cc(cr-&gt;rdResult, cr-&gt;domResult);
  cc.results = cr-&gt;results;
  CaptureTracker ct(cc, cast&lt;BodiedFunc&gt;(func), value);
  ct.runToCompletion(func);
  seqassertn(ct.dsets.size() == 1, "unexpected dsets size");
  return ct.dsets[0].result;
}

} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.395">bool reachable(CFBlock *start, CFBlock *end, std::unordered_set&lt;CFBlock *&gt; &amp;seen) {
  if (start == end)
    return true;

  if (seen.count(start))
    return false;

  seen.insert(start);
  for (auto it = start-&gt;successors_begin(); it != start-&gt;successors_end(); ++it) {
    if (reachable(*it, end, seen))
      return true;
  }

  return false;
}

</t>
<t tx="ekr.20230509083242.396">// Check if one value must always be encountered before another, if
// it is to be encountered at all. This is NOT the same as domination
// since we can have "(if _: B) ; A", where B does not dominate A yet
// must always occur before A is it does occur.
bool happensBefore(const Value *before, const Value *after, CFGraph *cfg,
                   DominatorInspector *dom) {
  auto *beforeBlock = cfg-&gt;getBlock(before);
  auto *afterBlock = cfg-&gt;getBlock(after);

  if (!beforeBlock || !afterBlock)
    return false;

  // If values are in the same block we just need to see
  // which one shows up first.
  if (beforeBlock == afterBlock) {
    for (auto *val : *beforeBlock) {
      if (val-&gt;getId() == before-&gt;getId())
        return true;
      else if (val-&gt;getId() == after-&gt;getId())
        return false;
    }
    seqassertn(false, "could not find values in CFG block");
    return false;
  }

  // If we have different blocks, then either 'before' dominates
  // 'after', in which case the answer is true, or there must be
  // no paths from 'afterBlock' to 'beforeBlock'.
  std::unordered_set&lt;CFBlock *&gt; seen;
  return dom-&gt;isDominated(after, before) || !reachable(afterBlock, beforeBlock, seen);
}

</t>
<t tx="ekr.20230509083242.397">struct RDManager {
  struct IDPairHash {
</t>
<t tx="ekr.20230509083242.398">    template &lt;class T1, class T2&gt;
    std::size_t operator()(const std::pair&lt;T1, T2&gt; &amp;pair) const {
      return (std::hash&lt;T1&gt;()(pair.first) &lt;&lt; 32) ^ std::hash&lt;T2&gt;()(pair.second);
    }
</t>
<t tx="ekr.20230509083242.399">  };

  RDInspector *rd;
  std::unordered_map&lt;std::pair&lt;id_t, id_t&gt;, std::unordered_set&lt;id_t&gt;, IDPairHash&gt; cache;

  explicit RDManager(RDInspector *rd) : rd(rd), cache() {}

  std::unordered_set&lt;id_t&gt; getReachingDefinitions(const Var *var, const Value *loc) {
    auto key = std::make_pair(var-&gt;getId(), loc-&gt;getId());
    auto it = cache.find(key);
    if (it == cache.end()) {
      auto result = rd-&gt;getReachingDefinitions(var, loc);
      cache.emplace(key, result);
      return result;
    } else {
      return it-&gt;second;
    }
  }

  bool isInvalid(const Var *v) { return rd-&gt;isInvalid(v); }
};

struct DerivedSet {
  const Func *func;
  const Var *root;
  std::vector&lt;id_t&gt; args;
  std::unordered_set&lt;id_t&gt; derivedVals;
  std::unordered_map&lt;id_t, std::vector&lt;const Value *&gt;&gt; derivedVars;
  CaptureInfo result;

</t>
<t tx="ekr.20230509083242.4"></t>
<t tx="ekr.20230509083242.40">def __init__(self, splines, thickness=0.1):
    self.splines = splines
    self.thickness = thickness
    self.minx = min([p.x for spl in splines for p in spl.points])
    self.miny = min([p.y for spl in splines for p in spl.points])
    self.maxx = max([p.x for spl in splines for p in spl.points])
    self.maxy = max([p.y for spl in splines for p in spl.points])
    self.height = self.maxy - self.miny
    self.width = self.maxx - self.minx
    self.num_trafos = []
    maxlength = thickness * self.width / self.height
    for spl in splines:
        length = 0
        curr = spl(0)
        for i in range(1, 1000):
            last = curr
            t = 1 / 999 * i
            curr = spl(t)
            length += curr.dist(last)
        self.num_trafos.append(max(1, int(length / maxlength * 1.5)))
    self.num_total = sum(self.num_trafos)

</t>
<t tx="ekr.20230509083242.400">  void setReturnCaptured() {
    if (shouldTrack(util::getReturnType(func)))
      result.returnCaptures = true;
  }

</t>
<t tx="ekr.20230509083242.401">  void setExternCaptured() {
    setReturnCaptured();
    result.externCaptures = true;
  }

</t>
<t tx="ekr.20230509083242.402">  bool isDerived(const Var *v, const Value *loc, RDManager &amp;rd) const {
    auto it = derivedVars.find(v-&gt;getId());
    if (it == derivedVars.end())
      return false;

    // We assume global references are always derived
    // if the var is derived, since they can change
    // at any point as far as we know. Same goes for
    // vars untracked by the reaching-def analysis.
    if (v-&gt;isGlobal() || rd.isInvalid(v))
      return true;

    // Make sure the var at this point is reached by
    // at least one definition that has led to a
    // derived value.
    auto mySet = rd.getReachingDefinitions(v, loc);
    for (auto *cause : it-&gt;second) {
      auto otherSet = rd.getReachingDefinitions(v, cause);
      bool derived = false;

      for (auto &amp;elem : mySet) {
        if (otherSet.count(elem))
          return true;
      }
    }

    return false;
  }

</t>
<t tx="ekr.20230509083242.403">  bool isDerived(const Value *v) const {
    return derivedVals.find(v-&gt;getId()) != derivedVals.end();
  }

</t>
<t tx="ekr.20230509083242.404">  void setDerived(const Var *v, const Value *cause, bool shouldArgCapture = true) {
    if (!shouldTrack(v))
      return;

    if (v-&gt;isGlobal())
      setExternCaptured();

    auto id = v-&gt;getId();
    if (shouldArgCapture &amp;&amp; root &amp;&amp; id != root-&gt;getId()) {
      for (unsigned i = 0; i &lt; args.size(); i++) {
        if (args[i] == id &amp;&amp; !contains(result.argCaptures, i))
          result.argCaptures.push_back(i);
      }
    }

    auto it = derivedVars.find(id);
    if (it == derivedVars.end()) {
      std::vector&lt;const Value *&gt; info = {cause};
      derivedVars.emplace(id, info);
    } else {
      if (!containsId(it-&gt;second, cause))
        it-&gt;second.push_back(cause);
    }
  }

</t>
<t tx="ekr.20230509083242.405">  void setDerived(const Value *v) {
    if (!shouldTrack(v))
      return;

    derivedVals.insert(v-&gt;getId());
  }

</t>
<t tx="ekr.20230509083242.406">  unsigned size() const {
    unsigned total = derivedVals.size();
    for (auto &amp;e : derivedVars) {
      total += e.second.size();
    }
    return total;
  }

</t>
<t tx="ekr.20230509083242.407">  explicit DerivedSet(const Func *func, const Var *root = nullptr)
      : func(func), root(root), args(), derivedVals(), derivedVars(), result() {}

  // Set for function argument
  DerivedSet(const Func *func, const Var *root, const Value *cause)
      : DerivedSet(func, root) {
    // extract arguments
    for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
      args.push_back((*it)-&gt;getId());
    }

    setDerived(root, cause);
  }

  // Set for function argument
  DerivedSet(const Func *func, const Value *value, CaptureContext &amp;cc)
      : DerivedSet(func) {
    std::vector&lt;const Var *&gt; vars;
    bool escapes = extractVars(cc, value, vars);
    if (escapes)
      setExternCaptured();

    setDerived(value);
    for (auto *var : vars) {
      setDerived(var, value);
    }
  }
};

</t>
<t tx="ekr.20230509083242.408">bool noCaptureByAnnotation(const Func *func) {
  return util::hasAttribute(func, util::PURE_ATTR) ||
         util::hasAttribute(func, util::NO_SIDE_EFFECT_ATTR) ||
         util::hasAttribute(func, util::NO_CAPTURE_ATTR);
}

</t>
<t tx="ekr.20230509083242.409">std::vector&lt;CaptureInfo&gt; makeAllCaptureInfo(const Func *func) {
  std::vector&lt;CaptureInfo&gt; result;
  for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
    result.push_back(CaptureInfo::unknown(func, (*it)-&gt;getType()));
  }
  return result;
}

std::vector&lt;CaptureInfo&gt; makeNoCaptureInfo(const Func *func, bool derives) {
  std::vector&lt;CaptureInfo&gt; result;
  for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
    auto info = CaptureInfo::nothing();
    if (derives &amp;&amp; shouldTrack(*it))
      info.returnCaptures = true;
    result.push_back(info);
  }
  return result;
}

struct CaptureContext {
  RDResult *reaching;
  DominatorResult *dominating;
  std::unordered_map&lt;id_t, std::vector&lt;CaptureInfo&gt;&gt; results;

  CaptureContext(RDResult *reaching, DominatorResult *dominating)
      : reaching(reaching), dominating(dominating), results() {}

  std::vector&lt;CaptureInfo&gt; get(const Func *func);
  void set(const Func *func, const std::vector&lt;CaptureInfo&gt; &amp;result);

  CFGraph *getCFGraph(const Func *func) {
    auto it = reaching-&gt;cfgResult-&gt;graphs.find(func-&gt;getId());
    seqassertn(it != reaching-&gt;cfgResult-&gt;graphs.end(),
               "could not find function in CFG results");
    return it-&gt;second.get();
  }

  RDInspector *getRDInspector(const Func *func) {
    auto it = reaching-&gt;results.find(func-&gt;getId());
    seqassertn(it != reaching-&gt;results.end(),
               "could not find function in reaching-definitions results");
    return it-&gt;second.get();
  }

  DominatorInspector *getDomInspector(const Func *func) {
    auto it = dominating-&gt;results.find(func-&gt;getId());
    seqassertn(it != dominating-&gt;results.end(),
               "could not find function in dominator results");
    return it-&gt;second.get();
  }
};

// This visitor answers the questions of what vars are
// relevant to track in a capturing expression. For
// example, in "a[i] = x", the expression "a[i]" captures
// "x"; in this case we need to track "a" but the variable
// "i" (typically) we would not care about.
struct ExtractVars : public util::ConstVisitor {
  CaptureContext &amp;cc;
  std::unordered_set&lt;id_t&gt; vars;
  bool escapes;

  explicit ExtractVars(CaptureContext &amp;cc)
      : util::ConstVisitor(), cc(cc), vars(), escapes(false) {}

  template &lt;typename Node&gt; void process(const Node *v) { v-&gt;accept(*this); }

</t>
<t tx="ekr.20230509083242.41">def get_random_trafo(self):
    r = random.randrange(int(self.num_total) + 1)
    l = 0
    for i in range(len(self.num_trafos)):
        if r &gt;= l and r &lt; l + self.num_trafos[i]:
            return i, random.randrange(self.num_trafos[i])
        l += self.num_trafos[i]
    return len(self.num_trafos) - 1, random.randrange(self.num_trafos[-1])

</t>
<t tx="ekr.20230509083242.410">  void add(const Var *v) {
    if (shouldTrack(v))
      vars.insert(v-&gt;getId());
  }

</t>
<t tx="ekr.20230509083242.411">  void defaultVisit(const Node *) override {}

  void visit(const VarValue *v) override { add(v-&gt;getVar()); }

  void visit(const PointerValue *v) override { add(v-&gt;getVar()); }

    @others
</t>
<t tx="ekr.20230509083242.412">  void visit(const CallInstr *v) override {
if (auto *func = util::getFunc(v-&gt;getCallee())) {
  auto capInfo = cc.get(util::getFunc(v-&gt;getCallee()));
  unsigned i = 0;
  for (auto *arg : *v) {
@others
}
  }

</t>
<t tx="ekr.20230509083242.413">    // note possibly capInfo.size() != v-&gt;numArgs() if calling vararg C function
    auto info = (i &lt; capInfo.size()) ? capInfo[i]
                                     : CaptureInfo::unknown(func, arg-&gt;getType());
    if (shouldTrack(arg) &amp;&amp; capInfo[i].returnCaptures)
      process(arg);
    ++i;
  }
} else {
  for (auto *arg : *v) {
    if (shouldTrack(arg))
      process(arg);
  }
</t>
<t tx="ekr.20230509083242.414">  void visit(const YieldInInstr *v) override {
    // We have no idea what the yield-in
    // value could be, so just assume we
    // escape in this case.
    escapes = true;
  }

</t>
<t tx="ekr.20230509083242.415">  void visit(const TernaryInstr *v) override {
    process(v-&gt;getTrueValue());
    process(v-&gt;getFalseValue());
  }

</t>
<t tx="ekr.20230509083242.416">  void visit(const ExtractInstr *v) override { process(v-&gt;getVal()); }

  void visit(const FlowInstr *v) override { process(v-&gt;getValue()); }

</t>
<t tx="ekr.20230509083242.417">  void visit(const dsl::CustomInstr *v) override {
    // TODO
  }
</t>
<t tx="ekr.20230509083242.418">};

</t>
<t tx="ekr.20230509083242.419">bool extractVars(CaptureContext &amp;cc, const Value *v, std::vector&lt;const Var *&gt; &amp;result) {
  auto *M = v-&gt;getModule();
  ExtractVars ev(cc);
  v-&gt;accept(ev);
  for (auto id : ev.vars) {
    result.push_back(M-&gt;getVar(id));
  }
  return ev.escapes;
}

</t>
<t tx="ekr.20230509083242.42">def transform_point(self, point, trafo=None):
    x = (point.x - self.minx) / self.width
    y = (point.y - self.miny) / self.height
    if trafo is None:
        trafo = self.get_random_trafo()
    start, end = self.splines[trafo[0]].GetDomain()
    length = end - start
    seg_length = length / self.num_trafos[trafo[0]]
    t = start + seg_length * trafo[1] + seg_length * x
    basepoint = self.splines[trafo[0]](t)
    if t + 1 / 50000 &gt; end:
        neighbour = self.splines[trafo[0]](t - 1 / 50000)
        derivative = neighbour - basepoint
    else:
        neighbour = self.splines[trafo[0]](t + 1 / 50000)
        derivative = basepoint - neighbour
    if derivative.Mag() != 0:
        basepoint.x += derivative.y / derivative.Mag() * (y - 0.5) * \
            self.thickness
        basepoint.y += -derivative.x / derivative.Mag() * (y - 0.5) * \
            self.thickness
    else:
        print("r", end='')
    self.truncate(basepoint)
    return basepoint

</t>
<t tx="ekr.20230509083242.420">struct CaptureTracker : public util::Operator {
  CaptureContext &amp;cc;
  CFGraph *cfg;
  RDManager rd;
  DominatorInspector *dom;
  std::vector&lt;DerivedSet&gt; dsets;

  CaptureTracker(CaptureContext &amp;cc, const Func *func, bool isArg)
      : Operator(), cc(cc), cfg(cc.getCFGraph(func)), rd(cc.getRDInspector(func)),
        dom(cc.getDomInspector(func)), dsets() {}

  CaptureTracker(CaptureContext &amp;cc, const BodiedFunc *func)
      : CaptureTracker(cc, func, /*isArg=*/true) {
    // find synthetic assignments in CFG for argument vars
    auto *entry = cfg-&gt;getEntryBlock();
    std::unordered_map&lt;id_t, const SyntheticAssignInstr *&gt; synthAssigns;

    for (auto *v : *entry) {
      if (auto *synth = cast&lt;SyntheticAssignInstr&gt;(v)) {
        if (shouldTrack(synth-&gt;getLhs()))
          synthAssigns[synth-&gt;getLhs()-&gt;getId()] = synth;
      }
    }

    // extract arguments
    std::vector&lt;id_t&gt; args;
    for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
      args.push_back((*it)-&gt;getId());
    }

    // make a derived set for each function argument
    for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
      if (!shouldTrack(*it))
        continue;

      auto it2 = synthAssigns.find((*it)-&gt;getId());
      seqassertn(it2 != synthAssigns.end(),
                 "could not find synthetic assignment for arg var");
      dsets.push_back(DerivedSet(func, *it, it2-&gt;second));
    }
  }

  CaptureTracker(CaptureContext &amp;cc, const BodiedFunc *func, const Value *value)
      : CaptureTracker(cc, func, /*isArg=*/false) {
    dsets.push_back(DerivedSet(func, value, cc));
  }

</t>
<t tx="ekr.20230509083242.421">  unsigned size() const {
    unsigned total = 0;
    for (auto &amp;dset : dsets) {
      total += dset.size();
    }
    return total;
  }

</t>
<t tx="ekr.20230509083242.422">  void forEachDSetOf(Value *v, std::function&lt;void(DerivedSet &amp;)&gt; func) {
    if (!v)
      return;

    for (auto &amp;dset : dsets) {
      if (dset.isDerived(v))
        func(dset);
    }
  }

</t>
<t tx="ekr.20230509083242.423">  void forEachDSetOf(Var *v, Value *loc, std::function&lt;void(DerivedSet &amp;)&gt; func) {
    if (!v)
      return;

    for (auto &amp;dset : dsets) {
      if (dset.isDerived(v, loc, rd))
        func(dset);
    }
  }

</t>
<t tx="ekr.20230509083242.424">  void forwardLink(Value *from, Value *cause, const std::vector&lt;const Var *&gt; &amp;toVars,
    @others
</t>
<t tx="ekr.20230509083242.425">               bool toEscapes, bool shouldArgCapture) {
forEachDSetOf(from, [&amp;](DerivedSet &amp;dset) {
  if (toEscapes)
    dset.setExternCaptured();

  for (auto *toVar : toVars) {
    dset.setDerived(toVar, cause, shouldArgCapture);
  }
});
  }

</t>
<t tx="ekr.20230509083242.426">  void backwardLinkFunc(DerivedSet &amp;dset, Value *cause,
    @others
</t>
<t tx="ekr.20230509083242.427">                    const std::vector&lt;const Var *&gt; &amp;toVars,
@others
</t>
<t tx="ekr.20230509083242.428">                    const std::vector&lt;const Var *&gt; &amp;fromVars, bool fromEscapes) {
if (fromEscapes)
  dset.setExternCaptured();

for (auto *toVar : toVars) {
  auto it = dset.derivedVars.find(toVar-&gt;getId());
  if (it == dset.derivedVars.end())
    continue;
  auto &amp;toCauses = it-&gt;second;

  for (auto *toCause : toCauses) {
    if (isA&lt;AssignInstr&gt;(toCause) || isA&lt;SyntheticAssignInstr&gt;(toCause) ||
        happensBefore(toCause, cause, cfg, dom))
      continue;

    bool derived = false;
    if (toVar-&gt;isGlobal() || rd.isInvalid(toVar)) {
      derived = true;
    } else {
      auto mySet = rd.getReachingDefinitions(toVar, cause);
      auto otherSet = rd.getReachingDefinitions(toVar, toCause);
      for (auto &amp;elem : mySet) {
        if (otherSet.count(elem)) {
          derived = true;
          break;
        }
      }
    }

    if (derived) {
      for (auto *fromVar : fromVars) {
        dset.setDerived(fromVar, toCause);
      }
    }
  }
}
  }

</t>
<t tx="ekr.20230509083242.429">  void link(Value *from, Value *to, Value *cause) {
    std::vector&lt;const Var *&gt; fromVars, toVars;
    bool fromEscapes = extractVars(cc, from, fromVars);
    bool toEscapes = extractVars(cc, to, toVars);

    forwardLink(from, cause, toVars, toEscapes, /*shouldArgCapture=*/true);
    forEachDSetOf(to, [&amp;](DerivedSet &amp;dset) {
      backwardLinkFunc(dset, cause, toVars, fromVars, fromEscapes);
    });
  }

</t>
<t tx="ekr.20230509083242.43">def truncate(self, point):
    if point.x &gt;= self.maxx:
        point.x = self.maxx
    if point.y &gt;= self.maxy:
        point.y = self.maxy
    if point.x &lt; self.minx:
        point.x = self.minx
    if point.y &lt; self.miny:
        point.y = self.miny

</t>
<t tx="ekr.20230509083242.430">  void link(Value *from, Var *to, Value *cause) {
    std::vector&lt;const Var *&gt; fromVars, toVars = {to};
    bool fromEscapes = extractVars(cc, from, fromVars);
    bool toEscapes = false;

    forwardLink(from, cause, toVars, toEscapes, /*shouldArgCapture=*/false);
    forEachDSetOf(to, cause, [&amp;](DerivedSet &amp;dset) {
      backwardLinkFunc(dset, cause, toVars, fromVars, fromEscapes);
    });
  }

</t>
<t tx="ekr.20230509083242.431">  void handle(VarValue *v) override {
    forEachDSetOf(v-&gt;getVar(), v, [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
  }

</t>
<t tx="ekr.20230509083242.432">  void handle(PointerValue *v) override {
    forEachDSetOf(v-&gt;getVar(), v, [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
  }

</t>
<t tx="ekr.20230509083242.433">  void handle(AssignInstr *v) override { link(v-&gt;getRhs(), v-&gt;getLhs(), v); }

</t>
<t tx="ekr.20230509083242.434">  void handle(ExtractInstr *v) override {
    if (!shouldTrack(v))
      return;

    forEachDSetOf(v-&gt;getVal(), [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
  }

</t>
<t tx="ekr.20230509083242.435">  void handle(InsertInstr *v) override {
    link(v-&gt;getRhs(), v-&gt;getLhs(), v);
    forEachDSetOf(v-&gt;getLhs(), [&amp;](DerivedSet &amp;dset) { dset.result.modified = true; });
  }

</t>
<t tx="ekr.20230509083242.436">  void handle(CallInstr *v) override {
    std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
    std::vector&lt;CaptureInfo&gt; capInfo;
    auto *func = util::getFunc(v-&gt;getCallee());

    if (func) {
      capInfo = cc.get(func);
    } else {
      std::vector&lt;unsigned&gt; argCaptures;
      unsigned i = 0;
      for (auto *arg : args) {
        if (shouldTrack(arg))
          argCaptures.push_back(i);
        ++i;
      }

      const bool returnCaptures = shouldTrack(v);
      for (auto *arg : args) {
        CaptureInfo info = CaptureInfo::nothing();
        if (shouldTrack(arg)) {
          info.argCaptures = argCaptures;
          info.returnCaptures = returnCaptures;
          info.externCaptures = true;
          info.modified = true;
        }
        capInfo.push_back(info);
      }
    }

    unsigned i = 0;
    for (auto *arg : args) {
    @others
      forEachDSetOf(arg, [&amp;](DerivedSet &amp;dset) {
        // Check if the return value captures.
        if (info.returnCaptures)
          dset.setDerived(v);

        // Check if we're externally captured.
        if (info.externCaptures)
          dset.setExternCaptured();

        if (info.modified)
          dset.result.modified = true;
      });
      ++i;
    }
  }

</t>
<t tx="ekr.20230509083242.437">  // note possibly capInfo.size() != v-&gt;numArgs() if calling vararg C function
  auto info = (i &lt; capInfo.size()) ? capInfo[i]
                                   : CaptureInfo::unknown(func, arg-&gt;getType());
  for (auto argno : info.argCaptures) {
    Value *other = args[argno];
    link(arg, other, v);
  }

</t>
<t tx="ekr.20230509083242.438">  void handle(ForFlow *v) override {
    auto *var = v-&gt;getVar();
    if (!shouldTrack(var))
      return;

    forEachDSetOf(v-&gt;getIter(), [&amp;](DerivedSet &amp;dset) {
      bool found = false;
      for (auto it = cfg-&gt;synth_begin(); it != cfg-&gt;synth_end(); ++it) {
        if (auto *synth = cast&lt;SyntheticAssignInstr&gt;(*it)) {
          if (synth-&gt;getKind() == SyntheticAssignInstr::Kind::NEXT_VALUE &amp;&amp;
              synth-&gt;getLhs()-&gt;getId() == var-&gt;getId()) {
            seqassertn(!found, "found multiple synthetic assignments for loop var");
            dset.setDerived(var, synth);
            found = true;
          }
        }
      }
    });
  }

</t>
<t tx="ekr.20230509083242.439">  void handle(TernaryInstr *v) override {
    forEachDSetOf(v-&gt;getTrueValue(), [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
    forEachDSetOf(v-&gt;getFalseValue(), [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
  }

</t>
<t tx="ekr.20230509083242.44">def create_image_chaos(self, w, h, iterations, filename, rng_seed):
    # Always use the same sequence of random numbers
    # to get reproducible benchmark
    random.seed(rng_seed)

    im = [[1] * h for i in range(w)]
    point = GVector((self.maxx + self.minx) / 2,
                    (self.maxy + self.miny) / 2, 0)
    for _ in range(iterations):
        point = self.transform_point(point)
        x = (point.x - self.minx) / self.width * w
        y = (point.y - self.miny) / self.height * h
        x = int(x)
        y = int(y)
        if x == w:
            x -= 1
        if y == h:
            y -= 1
        im[x][h - y - 1] = 0

    if filename:
        write_ppm(im, filename)


</t>
<t tx="ekr.20230509083242.440">  void handle(FlowInstr *v) override {
    forEachDSetOf(v-&gt;getValue(), [&amp;](DerivedSet &amp;dset) { dset.setDerived(v); });
  }

</t>
<t tx="ekr.20230509083242.441">  void handle(dsl::CustomInstr *v) override {
    // TODO
  }

</t>
<t tx="ekr.20230509083242.442">  // Actual capture points:

  void handle(ReturnInstr *v) override {
    forEachDSetOf(v-&gt;getValue(),
                  [&amp;](DerivedSet &amp;dset) { dset.result.returnCaptures = true; });
  }

</t>
<t tx="ekr.20230509083242.443">  void handle(YieldInstr *v) override {
    forEachDSetOf(v-&gt;getValue(),
                  [&amp;](DerivedSet &amp;dset) { dset.result.returnCaptures = true; });
  }

</t>
<t tx="ekr.20230509083242.444">  void handle(ThrowInstr *v) override {
    forEachDSetOf(v-&gt;getValue(), [&amp;](DerivedSet &amp;dset) { dset.setExternCaptured(); });
  }

</t>
<t tx="ekr.20230509083242.445">  // Helper to run to completion

  void runToCompletion(const Func *func) {
    unsigned oldSize = 0;
    do {
      oldSize = size();
      const_cast&lt;Func *&gt;(func)-&gt;accept(*this);
      reset();
    } while (size() != oldSize);
  }
</t>
<t tx="ekr.20230509083242.446">};

std::vector&lt;CaptureInfo&gt; CaptureContext::get(const Func *func) {
  // Don't know anything about external/LLVM funcs so use annotations.
  if (isA&lt;ExternalFunc&gt;(func) || isA&lt;LLVMFunc&gt;(func)) {
    bool derives = util::hasAttribute(func, util::DERIVES_ATTR);

    if (util::hasAttribute(func, util::SELF_CAPTURES_ATTR)) {
      auto ans = makeNoCaptureInfo(func, derives);
      if (!ans.empty())
        ans[0].modified = true;

      std::vector&lt;Var *&gt; argVars(func-&gt;arg_begin(), func-&gt;arg_end());
      for (unsigned i = 1; i &lt; ans.size(); i++) {
        if (shouldTrack(argVars[i]))
          ans[i].argCaptures.push_back(0);
      }
      return ans;
    }

    return noCaptureByAnnotation(func) ? makeNoCaptureInfo(func, derives)
                                       : makeAllCaptureInfo(func);
  }

  // Only Tuple.__new__(...) and Generator.__promise__(self) capture.
  if (isA&lt;InternalFunc&gt;(func)) {
    bool isTupleNew = func-&gt;getUnmangledName() == "__new__" &amp;&amp;
                      isA&lt;types::RecordType&gt;(util::getReturnType(func));

</t>
<t tx="ekr.20230509083242.447">    bool isPromise = func-&gt;getUnmangledName() == "__promise__" &amp;&amp;
                     std::distance(func-&gt;arg_begin(), func-&gt;arg_end()) == 1 &amp;&amp;
                     isA&lt;types::GeneratorType&gt;(func-&gt;arg_front()-&gt;getType());

    bool derives = (isTupleNew || isPromise);
    return makeNoCaptureInfo(func, derives);
  }

  // Bodied function
  if (isA&lt;BodiedFunc&gt;(func)) {
    auto it = results.find(func-&gt;getId());
    if (it != results.end())
      return it-&gt;second;

    set(func, makeAllCaptureInfo(func));

    CaptureTracker ct(*this, cast&lt;BodiedFunc&gt;(func));
    ct.runToCompletion(func);

    std::vector&lt;CaptureInfo&gt; answer;
    unsigned i = 0;
    for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
      if (shouldTrack(*it)) {
        answer.push_back(ct.dsets[i++].result);
      } else {
        answer.push_back(CaptureInfo::nothing());
      }
    }

    set(func, answer);
    return answer;
  }

</t>
<t tx="ekr.20230509083242.448">  seqassertn(false, "unknown function type");
  return {};
}

</t>
<t tx="ekr.20230509083242.449">void CaptureContext::set(const Func *func, const std::vector&lt;CaptureInfo&gt; &amp;result) {
  results[func-&gt;getId()] = result;
}

</t>
<t tx="ekr.20230509083242.45">def main():
    splines = [
        Spline([
            GVector(1.597350, 3.304460, 0.000000),
            GVector(1.575810, 4.123260, 0.000000),
            GVector(1.313210, 5.288350, 0.000000),
            GVector(1.618900, 5.329910, 0.000000),
            GVector(2.889940, 5.502700, 0.000000),
            GVector(2.373060, 4.381830, 0.000000),
            GVector(1.662000, 4.360280, 0.000000)],
            3, [0, 0, 0, 1, 1, 1, 2, 2, 2]),
        Spline([
            GVector(2.804500, 4.017350, 0.000000),
            GVector(2.550500, 3.525230, 0.000000),
            GVector(1.979010, 2.620360, 0.000000),
            GVector(1.979010, 2.620360, 0.000000)],
            3, [0, 0, 0, 1, 1, 1]),
        Spline([
            GVector(2.001670, 4.011320, 0.000000),
            GVector(2.335040, 3.312830, 0.000000),
            GVector(2.366800, 3.233460, 0.000000),
            GVector(2.366800, 3.233460, 0.000000)],
            3, [0, 0, 0, 1, 1, 1])
    ]

    chaos = Chaosgame(splines, DEFAULT_THICKNESS)
    chaos.create_image_chaos(DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_ITERATIONS, sys.argv[1], DEFAULT_RNG_SEED)

</t>
<t tx="ekr.20230509083242.450">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/dominator.h"
#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

/// Information about how a function argument is captured.
struct CaptureInfo {
  /// vector of other argument indices capturing this one
  std::vector&lt;unsigned&gt; argCaptures;
  /// true if the return value of the function captures this argument
  bool returnCaptures = false;
  /// true if this argument is externally captured e.g. by assignment to global
  bool externCaptures = false;
  /// true if this argument is modified
  bool modified = false;

  /// @return true if anything captures
  operator bool() const {
    return !argCaptures.empty() || returnCaptures || externCaptures;
  }

  /// Returns an instance denoting no captures.
  /// @return an instance denoting no captures
  static CaptureInfo nothing() { return {}; }

  /// Returns an instance denoting unknown capture status.
  /// @param func the function containing this argument
  /// @param type the argument's type
  /// @return an instance denoting unknown capture status
  static CaptureInfo unknown(const Func *func, types::Type *type);
};

/// Capture analysis result.
struct CaptureResult : public Result {
  /// the corresponding reaching definitions result
  RDResult *rdResult = nullptr;

  /// the corresponding dominator result
  DominatorResult *domResult = nullptr;

  /// map from function id to capture information, where
  /// each element of the value vector corresponds to an
  /// argument of the function
  std::unordered_map&lt;id_t, std::vector&lt;CaptureInfo&gt;&gt; results;
};

@others
CaptureInfo escapes(const BodiedFunc *func, const Value *value, CaptureResult *cr);

} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.451">/// Capture analysis that runs on all functions.
class CaptureAnalysis : public Analysis {
private:
  /// the reaching definitions analysis key
  std::string rdAnalysisKey;
  /// the dominator analysis key
  std::string domAnalysisKey;

public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  /// Initializes a capture analysis.
  /// @param rdAnalysisKey the reaching definitions analysis key
  /// @param domAnalysisKey the dominator analysis key
  explicit CaptureAnalysis(std::string rdAnalysisKey, std::string domAnalysisKey)
      : rdAnalysisKey(std::move(rdAnalysisKey)),
        domAnalysisKey(std::move(domAnalysisKey)) {}

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.452">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "cfg.h"

#include &lt;vector&gt;

#include "codon/cir/dsl/codegen.h"
#include "codon/cir/dsl/nodes.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {
namespace {
// TODO: this logic is very similar to lowering/pipeline -- unify somehow?
Value *callStage(analyze::dataflow::CFGraph *cfg, PipelineFlow::Stage *stage,
                 Value *last) {
  std::vector&lt;Value *&gt; args;
  for (auto *arg : *stage) {
    args.push_back(arg ? arg : last);
  }
  return cfg-&gt;N&lt;CallInstr&gt;(stage-&gt;getCallee(), args);
}

Value *convertPipelineToForLoopsHelper(analyze::dataflow::CFGraph *cfg,
                                       std::vector&lt;PipelineFlow::Stage *&gt; &amp;stages,
@others
CFVisitor::Loop &amp;CFVisitor::findLoop(id_t id) {
  return *std::find_if(loopStack.begin(), loopStack.end(),
                       [=](auto &amp;it) { return it.loopId == id; });
}

} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon

#undef DEFAULT_VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.453">                                       unsigned idx = 0, Value *last = nullptr) {
  if (idx &gt;= stages.size())
    return last;

  auto *stage = stages[idx];
  if (idx == 0)
    return convertPipelineToForLoopsHelper(cfg, stages, idx + 1, stage-&gt;getCallee());

  auto *prev = stages[idx - 1];
  if (prev-&gt;isGenerator()) {
    auto *var = cfg-&gt;N&lt;Var&gt;(prev-&gt;getOutputElementType());
    auto *body = convertPipelineToForLoopsHelper(
        cfg, stages, idx + 1, callStage(cfg, stage, cfg-&gt;N&lt;VarValue&gt;(var)));
    auto *series = cfg-&gt;N&lt;SeriesFlow&gt;();
    series-&gt;push_back(body);
    return cfg-&gt;N&lt;ForFlow&gt;(last, series, var);
  } else {
    return convertPipelineToForLoopsHelper(cfg, stages, idx + 1,
                                           callStage(cfg, stage, last));
  }
}
</t>
<t tx="ekr.20230509083242.454">} // namespace

</t>
<t tx="ekr.20230509083242.455">const Value *convertPipelineToForLoops(analyze::dataflow::CFGraph *cfg,
                                       const PipelineFlow *p) {
  std::vector&lt;PipelineFlow::Stage *&gt; stages;
  for (const auto &amp;stage : *p) {
    stages.push_back(const_cast&lt;PipelineFlow::Stage *&gt;(&amp;stage));
  }
  return convertPipelineToForLoopsHelper(cfg, stages);
}

</t>
<t tx="ekr.20230509083242.456">void CFBlock::reg(const Value *v) { graph-&gt;valueLocations[v-&gt;getId()] = this; }

const char SyntheticAssignInstr::NodeId = 0;

</t>
<t tx="ekr.20230509083242.457">int SyntheticAssignInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  if (arg &amp;&amp; arg-&gt;getId() == id) {
    arg = newValue;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.458">int SyntheticAssignInstr::doReplaceUsedVariable(id_t id, Var *newVar) {
  if (lhs-&gt;getId() == id) {
    lhs = newVar;
    return 1;
  }
  return 0;
}

</t>
<t tx="ekr.20230509083242.459">const char SyntheticPhiInstr::NodeId = 0;

std::vector&lt;Value *&gt; SyntheticPhiInstr::doGetUsedValues() const {
  std::vector&lt;Value *&gt; ret;
  for (auto &amp;p : *this) {
    ret.push_back(const_cast&lt;Value *&gt;(p.getResult()));
  }
  return ret;
}

</t>
<t tx="ekr.20230509083242.46"></t>
<t tx="ekr.20230509083242.460">int SyntheticPhiInstr::doReplaceUsedValue(id_t id, Value *newValue) {
  auto res = 0;
  for (auto &amp;p : *this) {
    if (p.getResult()-&gt;getId() == id) {
      p.setResult(newValue);
      ++res;
    }
  }
  return res;
}

</t>
<t tx="ekr.20230509083242.461">CFGraph::CFGraph(const BodiedFunc *f) : func(f) { newBlock("entry", true); }

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CFGraph &amp;cfg) {
  os &lt;&lt; "digraph \"" &lt;&lt; cfg.func-&gt;getName() &lt;&lt; "\" {\n";
  for (auto *block : cfg) {
    os &lt;&lt; "  ";
    os &lt;&lt; block-&gt;getName() &lt;&lt; "_" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(block);
    os &lt;&lt; " [ label=\"" &lt;&lt; block-&gt;getName() &lt;&lt; "\"";
    if (block == cfg.getEntryBlock()) {
      os &lt;&lt; " shape=square";
    }
    os &lt;&lt; " ];\n";
  }
  for (auto *block : cfg) {
    for (auto next = block-&gt;successors_begin(); next != block-&gt;successors_end();
         ++next) {
      CFBlock *succ = *next;
      os &lt;&lt; "  ";
      os &lt;&lt; block-&gt;getName() &lt;&lt; "_" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(block);
      os &lt;&lt; " -&gt; ";
      os &lt;&lt; succ-&gt;getName() &lt;&lt; "_" &lt;&lt; reinterpret_cast&lt;uintptr_t&gt;(succ);
      os &lt;&lt; ";\n";
    }
  }
  os &lt;&lt; "}";
  return os;
}

std::unique_ptr&lt;CFGraph&gt; buildCFGraph(const BodiedFunc *f) {
  auto ret = std::make_unique&lt;CFGraph&gt;(f);
  CFVisitor v(ret.get());
  v.process(f);
  return ret;
}

const std::string CFAnalysis::KEY = "core-analyses-cfg";

std::unique_ptr&lt;Result&gt; CFAnalysis::run(const Module *m) {
  auto res = std::make_unique&lt;CFResult&gt;();
  if (const auto *main = cast&lt;BodiedFunc&gt;(m-&gt;getMainFunc())) {
    res-&gt;graphs.insert(std::make_pair(main-&gt;getId(), buildCFGraph(main)));
  }

  for (const auto *var : *m) {
    if (const auto *f = cast&lt;BodiedFunc&gt;(var)) {
      res-&gt;graphs.insert(std::make_pair(f-&gt;getId(), buildCFGraph(f)));
    }
  }
  return res;
}

</t>
<t tx="ekr.20230509083242.462">void CFVisitor::visit(const BodiedFunc *f) {
  auto *blk = graph-&gt;getCurrentBlock();
  for (auto it = f-&gt;arg_begin(); it != f-&gt;arg_end(); it++) {
    blk-&gt;push_back(graph-&gt;N&lt;analyze::dataflow::SyntheticAssignInstr&gt;(
        const_cast&lt;Var *&gt;(*it), const_cast&lt;VarValue *&gt;(graph-&gt;N&lt;VarValue&gt;(*it))));
  }
  process(f-&gt;getBody());
}

</t>
<t tx="ekr.20230509083242.463">void CFVisitor::visit(const SeriesFlow *v) {
  for (auto *c : *v) {
    process(c);
  }
}

</t>
<t tx="ekr.20230509083242.464">void CFVisitor::visit(const IfFlow *v) {
  process(v-&gt;getCond());
  auto *original = graph-&gt;getCurrentBlock();
  auto *end = graph-&gt;newBlock("endIf");

  auto *tBranch = graph-&gt;newBlock("trueBranch", true);
  process(v-&gt;getTrueBranch());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(end);

  analyze::dataflow::CFBlock *fBranch = nullptr;
  if (v-&gt;getFalseBranch()) {
    fBranch = graph-&gt;newBlock("falseBranch", true);
    process(v-&gt;getFalseBranch());
    graph-&gt;getCurrentBlock()-&gt;successors_insert(end);
  }

  original-&gt;successors_insert(tBranch);
  if (fBranch)
    original-&gt;successors_insert(fBranch);
  else
    original-&gt;successors_insert(end);

  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.465">void CFVisitor::visit(const WhileFlow *v) {
  auto *original = graph-&gt;getCurrentBlock();
  auto *end = graph-&gt;newBlock("endWhile");

  auto *loopBegin = graph-&gt;newBlock("whileBegin", true);
  original-&gt;successors_insert(loopBegin);
  process(v-&gt;getCond());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(end);

  loopStack.emplace_back(loopBegin, end, v-&gt;getId(), tryCatchStack.size() - 1);
  auto *body = graph-&gt;newBlock("whileBody", true);
  loopBegin-&gt;successors_insert(body);
  process(v-&gt;getBody());
  loopStack.pop_back();
  graph-&gt;getCurrentBlock()-&gt;successors_insert(loopBegin);

  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.466">void CFVisitor::visit(const ForFlow *v) {
  if (v-&gt;isParallel()) {
    for (auto *v : v-&gt;getSchedule()-&gt;getUsedValues()) {
      process(v);
    }
  }
  auto *original = graph-&gt;getCurrentBlock();
  auto *end = graph-&gt;newBlock("endFor");

  auto *loopBegin = graph-&gt;newBlock("forBegin", true);
  original-&gt;successors_insert(loopBegin);
  process(v-&gt;getIter());

  auto *loopCheck = graph-&gt;newBlock("forCheck");
  graph-&gt;getCurrentBlock()-&gt;successors_insert(loopCheck);
  loopCheck-&gt;successors_insert(end);

  auto *loopNext = graph-&gt;newBlock("forNext");
  loopCheck-&gt;successors_insert(loopNext);
  loopNext-&gt;push_back(graph-&gt;N&lt;analyze::dataflow::SyntheticAssignInstr&gt;(
      const_cast&lt;Var *&gt;(v-&gt;getVar()), const_cast&lt;Value *&gt;(v-&gt;getIter()),
      analyze::dataflow::SyntheticAssignInstr::NEXT_VALUE));

  loopStack.emplace_back(loopCheck, end, v-&gt;getId(), tryCatchStack.size() - 1);
  auto *loopBody = graph-&gt;newBlock("forBody", true);
  loopNext-&gt;successors_insert(loopBody);
  process(v-&gt;getBody());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(loopCheck);
  loopStack.pop_back();

  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.467">void CFVisitor::visit(const ImperativeForFlow *v) {
  if (v-&gt;isParallel()) {
    for (auto *v : v-&gt;getSchedule()-&gt;getUsedValues()) {
      process(v);
    }
  }
  auto *original = graph-&gt;getCurrentBlock();
  auto *end = graph-&gt;newBlock("endFor");

  auto *loopBegin = graph-&gt;newBlock("forBegin", true);
  original-&gt;successors_insert(loopBegin);
  loopBegin-&gt;push_back(graph-&gt;N&lt;analyze::dataflow::SyntheticAssignInstr&gt;(
      const_cast&lt;Var *&gt;(v-&gt;getVar()), const_cast&lt;Value *&gt;(v-&gt;getStart()),
      analyze::dataflow::SyntheticAssignInstr::KNOWN));
  process(v-&gt;getStart());
  process(v-&gt;getEnd());

  auto *loopCheck = graph-&gt;newBlock("forCheck");
  graph-&gt;getCurrentBlock()-&gt;successors_insert(loopCheck);
  loopCheck-&gt;successors_insert(end);

  auto *loopNext = graph-&gt;newBlock("forUpdate");
  loopNext-&gt;push_back(graph-&gt;N&lt;analyze::dataflow::SyntheticAssignInstr&gt;(
      const_cast&lt;Var *&gt;(v-&gt;getVar()), v-&gt;getStep()));
  loopNext-&gt;successors_insert(loopCheck);

  loopStack.emplace_back(loopCheck, end, v-&gt;getId(), tryCatchStack.size() - 1);
  auto *loopBody = graph-&gt;newBlock("forBody", true);
  loopCheck-&gt;successors_insert(loopBody);
  process(v-&gt;getBody());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(loopCheck);
  loopStack.pop_back();

  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.468">void CFVisitor::visit(const TryCatchFlow *v) {
  auto *routeBlock = graph-&gt;newBlock("tcRoute");
  auto *end = graph-&gt;newBlock("tcEnd");
  analyze::dataflow::CFBlock *finally = nullptr;
  if (v-&gt;getFinally())
    finally = graph-&gt;newBlock("tcFinally");

  auto *dst = finally ? finally : end;

  tryCatchStack.emplace_back(routeBlock, finally);
  process(v-&gt;getBody());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(dst);

  for (auto &amp;c : *v) {
    auto *cBlock = graph-&gt;newBlock("catch", true);
    if (c.getVar())
      cBlock-&gt;push_back(graph-&gt;N&lt;analyze::dataflow::SyntheticAssignInstr&gt;(
          const_cast&lt;Var *&gt;(c.getVar())));
    process(c.getHandler());
    routeBlock-&gt;successors_insert(cBlock);
    graph-&gt;getCurrentBlock()-&gt;successors_insert(dst);
  }

  tryCatchStack.pop_back();

  if (v-&gt;getFinally()) {
    graph-&gt;setCurrentBlock(finally);
    process(v-&gt;getFinally());
    graph-&gt;getCurrentBlock()-&gt;successors_insert(end);
    routeBlock-&gt;successors_insert(finally);
  }

  if (!tryCatchStack.empty()) {
    if (finally)
      finally-&gt;successors_insert(tryCatchStack.back().first);
    else
      routeBlock-&gt;successors_insert(tryCatchStack.back().first);
  }

  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.469">void CFVisitor::visit(const PipelineFlow *v) {
  if (auto *loops = convertPipelineToForLoops(graph, v)) {
    process(loops);
  } else {
    // pipeline is empty
  }
}

</t>
<t tx="ekr.20230509083242.47">@path C:/Repos/codon/bench/fannkuch/
@language unknown_language
# FANNKUCH benchmark
from math import factorial as fact
from sys import argv
from time import time

def perm(n, i):
    p = [0] * n

    for k in range(n):
        f = fact(n - 1 - k)
        p[k] = i // f
        i = i % f

    for k in range(n - 1, -1, -1):
        for j in range(k - 1, -1, -1):
            if p[j] &lt;= p[k]:
                p[k] += 1

    return p

n = int(argv[1])
max_flips = 0

t0 = time()
@par(schedule='dynamic', num_threads=4)
for idx in range(fact(n)):
    p = perm(n, idx)
    flips = 0
    k = p[0]

    while k:
        i = 0
        j = k
        while i &lt; j:
            p[i], p[j] = p[j], p[i]
            i += 1
            j -= 1

        k = p[0]
        flips += 1

    max_flips = max(flips, max_flips)

print(f'Pfannkuchen({n}) = {max_flips}')
t1 = time()
print(t1 - t0)
</t>
<t tx="ekr.20230509083242.470">void CFVisitor::visit(const dsl::CustomFlow *v) {
  v-&gt;getCFBuilder()-&gt;buildCFNodes(this);
}

</t>
<t tx="ekr.20230509083242.471">void CFVisitor::visit(const AssignInstr *v) {
  process(v-&gt;getRhs());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.472">void CFVisitor::visit(const ExtractInstr *v) {
  process(v-&gt;getVal());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.473">void CFVisitor::visit(const InsertInstr *v) {
  process(v-&gt;getLhs());
  process(v-&gt;getRhs());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.474">void CFVisitor::visit(const CallInstr *v) {
  process(v-&gt;getCallee());
  for (auto *a : *v)
    process(a);
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.475">void CFVisitor::visit(const TernaryInstr *v) {
  auto *end = graph-&gt;newBlock("ternaryDone");
  auto *tBranch = graph-&gt;newBlock("ternaryTrue");
  auto *fBranch = graph-&gt;newBlock("ternaryFalse");

  process(v-&gt;getCond());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(tBranch);
  graph-&gt;getCurrentBlock()-&gt;successors_insert(fBranch);

  graph-&gt;setCurrentBlock(tBranch);
  process(v-&gt;getTrueValue());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(end);

  graph-&gt;setCurrentBlock(fBranch);
  process(v-&gt;getFalseValue());
  graph-&gt;getCurrentBlock()-&gt;successors_insert(end);

  auto *phi = graph-&gt;N&lt;analyze::dataflow::SyntheticPhiInstr&gt;();
  phi-&gt;emplace_back(tBranch, const_cast&lt;Value *&gt;(v-&gt;getTrueValue()));
  phi-&gt;emplace_back(fBranch, const_cast&lt;Value *&gt;(v-&gt;getFalseValue()));

  end-&gt;push_back(phi);
  graph-&gt;remapValue(v, phi);
  graph-&gt;setCurrentBlock(end);
}

</t>
<t tx="ekr.20230509083242.476">void CFVisitor::visit(const BreakInstr *v) {
  auto &amp;loop = v-&gt;getLoop() ? findLoop(v-&gt;getLoop()-&gt;getId()) : loopStack.back();
  defaultJump(loop.end, loop.tcIndex);
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.477">void CFVisitor::visit(const ContinueInstr *v) {
  auto &amp;loop = v-&gt;getLoop() ? findLoop(v-&gt;getLoop()-&gt;getId()) : loopStack.back();
  defaultJump(loop.nextIt, loop.tcIndex);
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.478">void CFVisitor::visit(const ReturnInstr *v) {
  if (v-&gt;getValue())
    process(v-&gt;getValue());
  defaultJump(nullptr, -1);
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.479">void CFVisitor::visit(const YieldInstr *v) {
  if (v-&gt;getValue())
    process(v-&gt;getValue());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.48">@path C:/Repos/codon/bench/fannkuch/
# FANNKUCH benchmark
from math import factorial as fact
from sys import argv
from time import time

@others
n = int(argv[1])
max_flips = 0

t0 = time()
for idx in range(fact(n)):
    p = perm(n, idx)
    flips = 0
    k = p[0]

    while k:
        i = 0
        j = k
        while i &lt; j:
            p[i], p[j] = p[j], p[i]
            i += 1
            j -= 1

        k = p[0]
        flips += 1

    max_flips = max(flips, max_flips)

print(f'Pfannkuchen({n}) = {max_flips}')
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.480">void CFVisitor::visit(const ThrowInstr *v) {
  if (v-&gt;getValue())
    process(v-&gt;getValue());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.481">void CFVisitor::visit(const FlowInstr *v) {
  process(v-&gt;getFlow());
  if (v-&gt;getValue())
    process(v-&gt;getValue());
  defaultInsert(v);
}

</t>
<t tx="ekr.20230509083242.482">void CFVisitor::visit(const dsl::CustomInstr *v) {
  v-&gt;getCFBuilder()-&gt;buildCFNodes(this);
}

</t>
<t tx="ekr.20230509083242.483">void CFVisitor::defaultInsert(const Value *v) {
  if (tryCatchStack.empty()) {
    graph-&gt;getCurrentBlock()-&gt;push_back(v);
  } else {
    auto *original = graph-&gt;getCurrentBlock();
    auto *newBlock = graph-&gt;newBlock("default", true);
    original-&gt;successors_insert(newBlock);
    newBlock-&gt;successors_insert(tryCatchStack.back().first);
    graph-&gt;getCurrentBlock()-&gt;push_back(v);
  }
  seenIds.insert(v-&gt;getId());
}

</t>
<t tx="ekr.20230509083242.484">void CFVisitor::defaultJump(const CFBlock *cf, int newTcLevel) {
  int curTc = tryCatchStack.size() - 1;

  if (curTc == -1 || curTc &lt;= newTcLevel) {
    if (cf)
      graph-&gt;getCurrentBlock()-&gt;successors_insert(const_cast&lt;CFBlock *&gt;(cf));
  } else {
    CFBlock *nearestFinally = nullptr;
    for (auto i = newTcLevel + 1; i &lt;= curTc; ++i) {
      if (auto *n = tryCatchStack[i].second) {
        nearestFinally = n;
        break;
      }
    }
    if (nearestFinally) {
      graph-&gt;getCurrentBlock()-&gt;successors_insert(tryCatchStack.back().first);
      if (cf)
        nearestFinally-&gt;successors_insert(const_cast&lt;CFBlock *&gt;(cf));
    } else {
      if (cf)
        graph-&gt;getCurrentBlock()-&gt;successors_insert(const_cast&lt;CFBlock *&gt;(cf));
    }
  }
}

</t>
<t tx="ekr.20230509083242.485">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/cir.h"
#include "codon/cir/util/iterators.h"

#define DEFAULT_VISIT(x)                                                               \
  void visit(const x *v) override { defaultInsert(v); }

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

class CFGraph;

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.486">class CFBlock : public IdMixin {
private:
  /// the in-order list of values in this block
  std::list&lt;const Value *&gt; values;
  /// an un-ordered list of successor blocks
  std::unordered_set&lt;CFBlock *&gt; successors;
  /// an un-ordered list of successor blocks
  std::unordered_set&lt;CFBlock *&gt; predecessors;
  /// the block's name
  std::string name;
  /// the graph
  CFGraph *graph;

public:
  /// Constructs a control-flow block.
  /// @param graph the parent graph
  /// @param name the block's name
  explicit CFBlock(CFGraph *graph, std::string name = "")
      : name(std::move(name)), graph(graph) {}

  virtual ~CFBlock() noexcept = default;

  /// @return this block's name
  std::string getName() const { return name; }

  /// @return an iterator to the first value
  auto begin() { return values.begin(); }
  /// @return an iterator beyond the last value
  auto end() { return values.end(); }
  /// @return an iterator to the first value
  auto begin() const { return values.begin(); }
  /// @return an iterator beyond the last value
  auto end() const { return values.end(); }
  /// @return a pointer to the first value
  const Value *front() const { return values.front(); }
  /// @return a pointer to the last value
  const Value *back() const { return values.back(); }

  /// Inserts a value at a given position.
  /// @param it the position
  /// @param v the new value
  /// @param an iterator to the new value
  template &lt;typename It&gt; auto insert(It it, const Value *v) {
    values.insert(it, v);
    reg(v);
  }
@others
  /// @return an iterator to the first predecessor
  auto predecessors_begin() { return predecessors.begin(); }
  /// @return an iterator beyond the last predecessor
  auto predecessors_end() { return predecessors.end(); }
  /// @return an iterator to the first predecessor
  auto predecessors_begin() const { return predecessors.begin(); }
  /// @return an iterator beyond the last predecessor
  auto predecessors_end() const { return predecessors.end(); }

  /// @return the graph
  CFGraph *getGraph() { return graph; }
  /// @return the graph
  const CFGraph *getGraph() const { return graph; }
  /// Sets the graph.
  /// @param g the new graph
  void setGraph(CFGraph *g) { graph = g; }

private:
  void reg(const Value *v);
};

</t>
<t tx="ekr.20230509083242.487">  /// Inserts a value at the back.
  /// @param v the new value
  void push_back(const Value *v) {
    values.push_back(v);
    reg(v);
  }
</t>
<t tx="ekr.20230509083242.488">  /// Erases a value at the given position.
  /// @param it the position
  /// @return an iterator following the removed value
  template &lt;typename It&gt; auto erase(It it) { values.erase(it); }

  /// @return an iterator to the first successor
  auto successors_begin() { return successors.begin(); }
  /// @return an iterator beyond the last successor
  auto successors_end() { return successors.end(); }
  /// @return an iterator to the first successor
  auto successors_begin() const { return successors.begin(); }
  /// @return an iterator beyond the last successor
  auto successors_end() const { return successors.end(); }
</t>
<t tx="ekr.20230509083242.489">  /// Inserts a successor at some position.
  /// @param v the new successor
  /// @return an iterator to the new successor
  auto successors_insert(CFBlock *v) {
    successors.insert(v);
    v-&gt;predecessors.insert(this);
  }
</t>
<t tx="ekr.20230509083242.49">def perm(n, i):
    p = [0] * n

    for k in range(n):
        f = fact(n - 1 - k)
        p[k] = i // f
        i = i % f

    for k in range(n - 1, -1, -1):
        for j in range(k - 1, -1, -1):
            if p[j] &lt;= p[k]:
                p[k] += 1

    return p

</t>
<t tx="ekr.20230509083242.490">  /// Removes a given successor.
  /// @param v the successor to remove
  auto successors_erase(CFBlock *v) {
    successors.erase(v);
    v-&gt;predecessors.erase(this);
  }

</t>
<t tx="ekr.20230509083242.491">class SyntheticAssignInstr : public AcceptorExtend&lt;SyntheticAssignInstr, Instr&gt; {
public:
  enum Kind { UNKNOWN, KNOWN, NEXT_VALUE, ADD };

private:
  /// the left-hand side
  Var *lhs;
  /// the kind of synthetic assignment
  Kind kind;
  /// any argument to the synthetic assignment
  Value *arg = nullptr;
  /// the difference
  int64_t diff = 0;

public:
  static const char NodeId;

  /// Constructs a synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param arg the argument
  /// @param k the kind of assignment
  /// @param name the name of the instruction
  SyntheticAssignInstr(Var *lhs, Value *arg, Kind k = KNOWN, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), kind(k), arg(arg) {}
  /// Constructs an unknown synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param name the name of the instruction
  explicit SyntheticAssignInstr(Var *lhs, std::string name = "")
      : SyntheticAssignInstr(lhs, nullptr, UNKNOWN, std::move(name)) {}
  /// Constructs an addition synthetic assignment.
  /// @param lhs the variable being assigned
  /// @param diff the difference
  /// @param name the name of the instruction
  SyntheticAssignInstr(Var *lhs, int64_t diff, std::string name = "")
      : AcceptorExtend(std::move(name)), lhs(lhs), kind(ADD), diff(diff) {}

  /// @return the variable being assigned
  Var *getLhs() { return lhs; }
  /// @return the variable being assigned
  const Var *getLhs() const { return lhs; }
  /// Sets the variable being assigned.
  /// @param v the variable
  void setLhs(Var *v) { lhs = v; }

  /// @return the argument
  Value *getArg() { return arg; }
  /// @return the argument
  const Value *getArg() const { return arg; }
  /// Sets the argument.
  /// @param v the new value
  void setArg(Value *v) { arg = v; }

  /// @return the diff
  int64_t getDiff() const { return diff; }
  /// Sets the diff.
  /// @param v the new value
  void setDiff(int64_t v) { diff = v; }

  /// @return the kind of synthetic assignment
  Kind getKind() const { return kind; }
  /// Sets the kind.
  /// @param k the new value
  void setKind(Kind k) { kind = k; }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override { return {arg}; }
  int doReplaceUsedValue(id_t id, Value *newValue) override;

  std::vector&lt;Var *&gt; doGetUsedVariables() const override { return {lhs}; }
  int doReplaceUsedVariable(id_t id, Var *newVar) override;
};

</t>
<t tx="ekr.20230509083242.492">class SyntheticPhiInstr : public AcceptorExtend&lt;SyntheticPhiInstr, Instr&gt; {
public:
@others
private:
  std::list&lt;Predecessor&gt; preds;

public:
  static const char NodeId;

  explicit SyntheticPhiInstr(std::string name = "") : AcceptorExtend(std::move(name)) {}

  /// @return an iterator to the first instruction/flow
  auto begin() { return preds.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() { return preds.end(); }
  /// @return an iterator to the first instruction/flow
  auto begin() const { return preds.begin(); }
  /// @return an iterator beyond the last instruction/flow
  auto end() const { return preds.end(); }

  /// @return a pointer to the first instruction/flow
  Predecessor &amp;front() { return preds.front(); }
  /// @return a pointer to the last instruction/flow
  Predecessor &amp;back() { return preds.back(); }
  /// @return a pointer to the first instruction/flow
  const Predecessor &amp;front() const { return preds.front(); }
  /// @return a pointer to the last instruction/flow
  const Predecessor &amp;back() const { return preds.back(); }

  /// Inserts a predecessor.
  /// @param pos the position
  /// @param v the predecessor
  /// @return an iterator to the newly added predecessor
  template &lt;typename It&gt; auto insert(It pos, Predecessor v) {
    return preds.insert(pos, v);
  }
  /// Appends an predecessor.
  /// @param v the predecessor
  void push_back(Predecessor v) { preds.push_back(v); }

  /// Erases the item at the supplied position.
  /// @param pos the position
  /// @return the iterator beyond the removed predecessor
  template &lt;typename It&gt; auto erase(It pos) { return preds.erase(pos); }

  /// Emplaces a predecessor.
  /// @param args the args
  template &lt;typename... Args&gt; void emplace_back(Args &amp;&amp;...args) {
    preds.emplace_back(std::forward&lt;Args&gt;(args)...);
  }

protected:
  std::vector&lt;Value *&gt; doGetUsedValues() const override;
  int doReplaceUsedValue(id_t id, Value *newValue) override;
};

</t>
<t tx="ekr.20230509083242.493">  class Predecessor {
  private:
    /// the predecessor block
    CFBlock *pred;
    /// the value
    Value *result;

  public:
    /// Constructs a predecessor.
    /// @param pred the predecessor block
    /// @param result the result of this predecessor.
    Predecessor(CFBlock *pred, Value *result) : pred(pred), result(result) {}

    /// @return the predecessor block
    CFBlock *getPred() { return pred; }
    /// @return the predecessor block
    const CFBlock *getPred() const { return pred; }
    /// Sets the predecessor.
    /// @param v the new value
    void setPred(CFBlock *v) { pred = v; }

    /// @return the result
    Value *getResult() { return result; }
    /// @return the result
    const Value *getResult() const { return result; }
    /// Sets the result
    /// @param v the new value
    void setResult(Value *v) { result = v; }
  };

</t>
<t tx="ekr.20230509083242.494">class CFGraph {
private:
  /// owned list of blocks
  std::list&lt;std::unique_ptr&lt;CFBlock&gt;&gt; blocks;
  /// the current block
  CFBlock *cur = nullptr;
  /// the function being analyzed
  const BodiedFunc *func;
  /// a list of synthetic values
  std::list&lt;std::unique_ptr&lt;Value&gt;&gt; syntheticValues;
  /// a map of synthetic values
  std::unordered_map&lt;id_t, Value *&gt; valueMapping;
  /// a list of synthetic variables
  std::list&lt;std::unique_ptr&lt;Var&gt;&gt; syntheticVars;
  /// a mapping from value id to block
  std::unordered_map&lt;id_t, CFBlock *&gt; valueLocations;

public:
  /// Constructs a control-flow graph.
  explicit CFGraph(const BodiedFunc *f);

  /// @return an iterator to the first block
  auto begin() { return util::raw_ptr_adaptor(blocks.begin()); }
  /// @return an iterator beyond the last block
  auto end() { return util::raw_ptr_adaptor(blocks.end()); }
  /// @return an iterator to the first block
  auto begin() const { return util::raw_ptr_adaptor(blocks.begin()); }
  /// @return an iterator beyond the last block
  auto end() const { return util::raw_ptr_adaptor(blocks.end()); }

  /// @return an iterator to the synthetic value
  auto synth_begin() { return util::raw_ptr_adaptor(syntheticValues.begin()); }
  /// @return an iterator beyond the last synthetic value
  auto synth_end() { return util::raw_ptr_adaptor(syntheticValues.end()); }
  /// @return an iterator to the first synthetic value
  auto synth_begin() const { return util::raw_ptr_adaptor(syntheticValues.begin()); }
  /// @return an iterator beyond the last synthetic value
  auto synth_end() const { return util::raw_ptr_adaptor(syntheticValues.end()); }

  /// @return the entry block
  CFBlock *getEntryBlock() { return blocks.front().get(); }
  /// @return the entry block
  const CFBlock *getEntryBlock() const { return blocks.front().get(); }

  /// @return the entry block
  CFBlock *getCurrentBlock() { return cur; }
  /// @return the entry block
  const CFBlock *getCurrentBlock() const { return cur; }
  /// Sets the current block.
  /// @param v the new value
  void setCurrentBlock(CFBlock *v) { cur = v; }

  /// @return the function
  const BodiedFunc *getFunc() const { return func; }
  /// Sets the function.
  /// @param f the new value
  void setFunc(BodiedFunc *f) { func = f; }

  /// Gets the block containing a value.
  /// @param val the value
  /// @return the block
  CFBlock *getBlock(const Value *v) {
    auto vmIt = valueMapping.find(v-&gt;getId());
    if (vmIt != valueMapping.end())
      v = vmIt-&gt;second;

    auto it = valueLocations.find(v-&gt;getId());
    return it != valueLocations.end() ? it-&gt;second : nullptr;
  }
@others
};

</t>
<t tx="ekr.20230509083242.495">  /// Gets the block containing a value.
  /// @param val the value
  /// @return the block
  const CFBlock *getBlock(const Value *v) const {
    auto vmIt = valueMapping.find(v-&gt;getId());
    if (vmIt != valueMapping.end())
      v = vmIt-&gt;second;

    auto it = valueLocations.find(v-&gt;getId());
    return it != valueLocations.end() ? it-&gt;second : nullptr;
  }

</t>
<t tx="ekr.20230509083242.496">  /// Creates and inserts a new block
  /// @param name the name
  /// @param setCur true if the block should be made the current one
  /// @return a newly inserted block
  CFBlock *newBlock(std::string name = "", bool setCur = false) {
    auto *ret = new CFBlock(this, std::move(name));
    blocks.emplace_back(ret);
    if (setCur)
      setCurrentBlock(ret);
    return ret;
  }

  template &lt;typename NodeType, typename... Args&gt; NodeType *N(Args &amp;&amp;...args) {
    auto *ret = new NodeType(std::forward&lt;Args&gt;(args)...);
    reg(ret);
    ret-&gt;setModule(func-&gt;getModule());
    return ret;
  }

  /// Remaps a value.
  /// @param id original id
  /// @param newValue the new value
  void remapValue(id_t id, Value *newValue) { valueMapping[id] = newValue; }
</t>
<t tx="ekr.20230509083242.497">  /// Remaps a value.
  /// @param original the original value
  /// @param newValue the new value
  void remapValue(const Value *original, Value *newValue) {
    remapValue(original-&gt;getId(), newValue);
  }

</t>
<t tx="ekr.20230509083242.498">  /// Gets a value by id.
  /// @param id the id
  /// @return the value or nullptr
  Value *getValue(id_t id) {
    auto it = valueMapping.find(id);
    return it != valueMapping.end() ? it-&gt;second : func-&gt;getModule()-&gt;getValue(id);
  }

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const CFGraph &amp;cfg);
  friend class CFBlock;

private:
  void reg(Var *v) { syntheticVars.emplace_back(v); }

</t>
<t tx="ekr.20230509083242.499">  void reg(Value *v) {
    syntheticValues.emplace_back(v);
    valueMapping[v-&gt;getId()] = v;
  }
</t>
<t tx="ekr.20230509083242.5">@path C:/Repos/codon/bench/binary_trees/
@language unknown_language
# The Computer Language Benchmarks Game
# http://benchmarksgame.alioth.debian.org/
#
# contributed by Antoine Pitrou
# modified by Dominique Wahli and Daniel Nanz
# modified by Joerg Baumann
# modified by @arshajii for Codon

import sys
import time

class Node:
    left: Optional[Node] = None
    right: Optional[Node] = None

def make_tree(d):
    return Node(make_tree(d - 1), make_tree(d - 1)) if d &gt; 0 else Node()

def check_tree(node):
    l, r = node.left, node.right
    if l is None:
        return 1
    else:
        return 1 + check_tree(l) + check_tree(r)

def make_check(itde, make=make_tree, check=check_tree):
    i, d = itde
    return check(make(d))

def get_argchunks(i, d, chunksize=5000):
    assert chunksize % 2 == 0
    chunk = []
    for k in range(1, i + 1):
        chunk.append((k, d))
        if len(chunk) == chunksize:
            yield chunk
            chunk = []
    if len(chunk) &gt; 0:
        yield chunk

def main(n, min_depth=4):
    max_depth = max(min_depth + 2, n)
    stretch_depth = max_depth + 1
    print(f'stretch tree of depth {stretch_depth}\t check: {make_check((0, stretch_depth))}')

    long_lived_tree = make_tree(max_depth)

    mmd = max_depth + min_depth
    for d in range(min_depth, stretch_depth, 2):
        i = 2 ** (mmd - d)
        cs = 0
        for argchunk in get_argchunks(i, d):
            cs += sum(map(make_check, argchunk))
        print(f'{i}\t trees of depth {d}\t check: {cs}')

    print(f'long lived tree of depth {max_depth}\t check: {check_tree(long_lived_tree)}')

t0 = time.time()
main(int(sys.argv[1]))
t1 = time.time()
print(t1 - t0)
</t>
<t tx="ekr.20230509083242.50"></t>
<t tx="ekr.20230509083242.500">/// Builds a control-flow graph from a given function.
/// @param f the function
/// @return the control-flow graph
std::unique_ptr&lt;CFGraph&gt; buildCFGraph(const BodiedFunc *f);

/// Control-flow analysis result.
struct CFResult : public Result {
  /// map from function id to control-flow graph
  std::unordered_map&lt;id_t, std::unique_ptr&lt;CFGraph&gt;&gt; graphs;
};

</t>
<t tx="ekr.20230509083242.501">/// Control-flow analysis that runs on all functions.
class CFAnalysis : public Analysis {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.502">class CFVisitor : public util::ConstVisitor {
private:
  struct Loop {
    analyze::dataflow::CFBlock *nextIt;
    analyze::dataflow::CFBlock *end;
    id_t loopId;
    int tcIndex;

    Loop(analyze::dataflow::CFBlock *nextIt, analyze::dataflow::CFBlock *end,
         id_t loopId, int tcIndex = -1)
        : nextIt(nextIt), end(end), loopId(loopId), tcIndex(tcIndex) {}
  };

  analyze::dataflow::CFGraph *graph;
  std::vector&lt;std::pair&lt;analyze::dataflow::CFBlock *, analyze::dataflow::CFBlock *&gt;&gt;
      tryCatchStack;
  std::unordered_set&lt;id_t&gt; seenIds;
  std::vector&lt;Loop&gt; loopStack;

public:
  explicit CFVisitor(analyze::dataflow::CFGraph *graph) : graph(graph) {}

  void visit(const BodiedFunc *f) override;

  DEFAULT_VISIT(VarValue)
  DEFAULT_VISIT(PointerValue)

  void visit(const SeriesFlow *v) override;
  void visit(const IfFlow *v) override;
  void visit(const WhileFlow *v) override;
  void visit(const ForFlow *v) override;
  void visit(const ImperativeForFlow *v) override;

  void visit(const TryCatchFlow *v) override;
  void visit(const PipelineFlow *v) override;
  void visit(const dsl::CustomFlow *v) override;

  DEFAULT_VISIT(TemplatedConst&lt;int64_t&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;double&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;bool&gt;);
  DEFAULT_VISIT(TemplatedConst&lt;std::string&gt;);
  DEFAULT_VISIT(dsl::CustomConst);

  void visit(const AssignInstr *v) override;
  void visit(const ExtractInstr *v) override;
  void visit(const InsertInstr *v) override;
  void visit(const CallInstr *v) override;
  DEFAULT_VISIT(StackAllocInstr);
  DEFAULT_VISIT(TypePropertyInstr);
  DEFAULT_VISIT(YieldInInstr);

  void visit(const TernaryInstr *v) override;

  void visit(const BreakInstr *v) override;
  void visit(const ContinueInstr *v) override;
  void visit(const ReturnInstr *v) override;
  void visit(const YieldInstr *v) override;
  void visit(const ThrowInstr *v) override;
  void visit(const FlowInstr *v) override;
  void visit(const dsl::CustomInstr *v) override;

  template &lt;typename NodeType&gt; void process(const NodeType *v) {
    if (!v)
      return;
    if (seenIds.find(v-&gt;getId()) != seenIds.end())
      return;
    seenIds.insert(v-&gt;getId());
    v-&gt;accept(*this);
  }

  void defaultInsert(const Value *v);
  void defaultJump(const CFBlock *cf, int newTcLevel = -1);

private:
  Loop &amp;findLoop(id_t id);
};

</t>
<t tx="ekr.20230509083242.503">} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon

</t>
<t tx="ekr.20230509083242.504">template &lt;&gt;
struct fmt::formatter&lt;codon::ir::analyze::dataflow::CFGraph&gt; : fmt::ostream_formatter {
};

#undef DEFAULT_VISIT
</t>
<t tx="ekr.20230509083242.505">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "dominator.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

@others
} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.506">void DominatorInspector::analyze() {
  auto changed = true;
  while (changed) {
    changed = false;
    for (auto *blk : *cfg) {
      auto init = false;
      std::set&lt;id_t&gt; old = sets[blk-&gt;getId()];
      std::set&lt;id_t&gt; working;

      for (auto it = blk-&gt;predecessors_begin(); it != blk-&gt;predecessors_end(); ++it) {
        auto &amp;predDoms = sets[(*it)-&gt;getId()];
        if (!init) {
          init = true;
          working = std::set&lt;id_t&gt;(predDoms.begin(), predDoms.end());
        }

        std::set&lt;id_t&gt; newWorking;
        std::set_intersection(working.begin(), working.end(), predDoms.begin(),
                              predDoms.end(),
                              std::inserter(newWorking, newWorking.begin()));
        working = newWorking;
      }

      working.insert(blk-&gt;getId());

      if (working != old) {
        changed = true;
        sets[blk-&gt;getId()] = working;
      }
    }
  }
}

</t>
<t tx="ekr.20230509083242.507">bool DominatorInspector::isDominated(const Value *v, const Value *dominator) {
  auto *vBlock = cfg-&gt;getBlock(v);
  auto *dBlock = cfg-&gt;getBlock(dominator);

  if (vBlock-&gt;getId() == dBlock-&gt;getId()) {
    auto vDist =
        std::distance(vBlock-&gt;begin(), std::find(vBlock-&gt;begin(), vBlock-&gt;end(), v));
    auto dDist = std::distance(vBlock-&gt;begin(),
                               std::find(vBlock-&gt;begin(), vBlock-&gt;end(), dominator));
    return dDist &lt;= vDist;
  }

  return sets[vBlock-&gt;getId()].find(dBlock-&gt;getId()) != sets[vBlock-&gt;getId()].end();
}

</t>
<t tx="ekr.20230509083242.508">const std::string DominatorAnalysis::KEY = "core-analyses-dominator";

std::unique_ptr&lt;Result&gt; DominatorAnalysis::run(const Module *m) {
  auto *cfgResult = getAnalysisResult&lt;CFResult&gt;(cfAnalysisKey);
  auto ret = std::make_unique&lt;DominatorResult&gt;(cfgResult);
  for (const auto &amp;graph : cfgResult-&gt;graphs) {
    auto inspector = std::make_unique&lt;DominatorInspector&gt;(graph.second.get());
    inspector-&gt;analyze();
    ret-&gt;results[graph.first] = std::move(inspector);
  }
  return ret;
}

</t>
<t tx="ekr.20230509083242.509">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;set&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/cfg.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

@others
} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.51">@path C:/Repos/codon/bench/float/
from math import sin, cos, sqrt
from time import time

POINTS = 10000000


@others
t0 = time()
print(benchmark(POINTS))
t1 = time()
print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.510">/// Helper to query the dominators of a particular function.
class DominatorInspector {
private:
  std::unordered_map&lt;id_t, std::set&lt;id_t&gt;&gt; sets;
  CFGraph *cfg;

public:
  explicit DominatorInspector(CFGraph *cfg) : cfg(cfg) {}

  /// Do the analysis.
  void analyze();

  /// Checks if one value dominates another.
  /// @param v the value
  /// @param dominator the dominator value
  bool isDominated(const Value *v, const Value *dominator);
};

</t>
<t tx="ekr.20230509083242.511">/// Result of a dominator analysis.
struct DominatorResult : public Result {
  /// the corresponding control flow result
  const CFResult *cfgResult;
  /// the dominator inspectors
  std::unordered_map&lt;id_t, std::unique_ptr&lt;DominatorInspector&gt;&gt; results;

  explicit DominatorResult(const CFResult *cfgResult) : cfgResult(cfgResult) {}
};

</t>
<t tx="ekr.20230509083242.512">/// Dominator analysis. Must have control flow-graph available.
class DominatorAnalysis : public Analysis {
private:
  /// the control-flow analysis key
  std::string cfAnalysisKey;

public:
  static const std::string KEY;

  /// Initializes a dominator analysis.
  /// @param cfAnalysisKey the control-flow analysis key
  explicit DominatorAnalysis(std::string cfAnalysisKey)
      : cfAnalysisKey(std::move(cfAnalysisKey)) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.513">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "reaching.h"

#include &lt;deque&gt;
#include &lt;tuple&gt;

namespace codon {
namespace ir {
namespace {
id_t getKilled(const Value *val) {
  if (auto *assign = cast&lt;AssignInstr&gt;(val)) {
    return assign-&gt;getLhs()-&gt;getId();
  } else if (auto *synthAssign = cast&lt;analyze::dataflow::SyntheticAssignInstr&gt;(val)) {
    return synthAssign-&gt;getLhs()-&gt;getId();
  }
  return -1;
}

std::pair&lt;id_t, id_t&gt; getGenerated(const Value *val) {
  if (auto *assign = cast&lt;AssignInstr&gt;(val)) {
    return {assign-&gt;getLhs()-&gt;getId(), assign-&gt;getRhs()-&gt;getId()};
  } else if (auto *synthAssign = cast&lt;analyze::dataflow::SyntheticAssignInstr&gt;(val)) {
    if (synthAssign-&gt;getKind() == analyze::dataflow::SyntheticAssignInstr::KNOWN)
      return {synthAssign-&gt;getLhs()-&gt;getId(), synthAssign-&gt;getArg()-&gt;getId()};
    else
      return {synthAssign-&gt;getLhs()-&gt;getId(), -1};
  }
  return {-1, -1};
}

template &lt;typename T&gt; struct WorkList {
  std::unordered_set&lt;id_t&gt; have;
  std::deque&lt;T *&gt; queue;

@others
const std::string RDAnalysis::KEY = "core-analyses-rd";

std::unique_ptr&lt;Result&gt; RDAnalysis::run(const Module *m) {
  auto *cfgResult = getAnalysisResult&lt;CFResult&gt;(cfAnalysisKey);
  auto ret = std::make_unique&lt;RDResult&gt;(cfgResult);
  for (const auto &amp;graph : cfgResult-&gt;graphs) {
    auto inspector = std::make_unique&lt;RDInspector&gt;(graph.second.get());
    inspector-&gt;analyze();
    ret-&gt;results[graph.first] = std::move(inspector);
  }
  return ret;
}

} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.514">  void push(T *a) {
    auto id = a-&gt;getId();
    if (have.count(id))
      return;
    have.insert(id);
    queue.push_back(a);
  }

</t>
<t tx="ekr.20230509083242.515">  T *pop() {
    if (queue.empty())
      return nullptr;
    auto *a = queue.front();
    queue.pop_front();
    have.erase(a-&gt;getId());
    return a;
  }

  template &lt;typename S&gt; WorkList(S *x) : have(), queue() {
    for (T *a : *x) {
      push(a);
    }
  }
};

struct BitSet {
  static constexpr unsigned B = 64;
  static unsigned allocSize(unsigned size) { return (size + B - 1) / B; }

  std::vector&lt;uint64_t&gt; words;

  explicit BitSet(unsigned size) : words(allocSize(size), 0) {}

  BitSet copy(unsigned size) const {
    auto res = BitSet(size);
    std::memcpy(res.words.data(), words.data(), allocSize(size) * (B / 8));
    return res;
  }

  void set(unsigned bit) { words.data()[bit / B] |= (1 &lt;&lt; (bit % B)); }

</t>
<t tx="ekr.20230509083242.516">  bool get(unsigned bit) const {
    return (words.data()[bit / B] &amp; (1 &lt;&lt; (bit % B))) != 0;
  }

</t>
<t tx="ekr.20230509083242.517">  bool equals(const BitSet &amp;other, unsigned size) {
    return std::memcmp(words.data(), other.words.data(), allocSize(size) * (B / 8)) ==
           0;
  }

</t>
<t tx="ekr.20230509083242.518">  void clear(unsigned size) { std::memset(words.data(), 0, allocSize(size) * (B / 8)); }

</t>
<t tx="ekr.20230509083242.519">  void setAll(unsigned size) {
    std::memset(words.data(), 0xff, allocSize(size) * (B / 8));
  }

</t>
<t tx="ekr.20230509083242.52">class Point:
    x: float
    y: float
    z: float

    @others
</t>
<t tx="ekr.20230509083242.520">  void overwrite(const BitSet &amp;other, unsigned size) {
    std::memcpy(words.data(), other.words.data(), allocSize(size) * (B / 8));
  }

</t>
<t tx="ekr.20230509083242.521">  void update(const BitSet &amp;other, unsigned size) {
    auto *p = words.data();
    auto *q = other.words.data();
    auto n = allocSize(size);
    for (unsigned i = 0; i &lt; n; i++) {
      p[i] |= q[i];
    }
  }

</t>
<t tx="ekr.20230509083242.522">  void subtract(const BitSet &amp;other, unsigned size) {
    auto *p = words.data();
    auto *q = other.words.data();
    auto n = allocSize(size);
    for (unsigned i = 0; i &lt; n; i++) {
      p[i] &amp;= ~q[i];
    }
  }
</t>
<t tx="ekr.20230509083242.523">};

template &lt;typename T&gt; struct BlockBitSets {
  T *blk;
  BitSet gen;
  BitSet kill;
  BitSet in;
  BitSet out;

  BlockBitSets(T *blk, BitSet gen, BitSet kill, BitSet in, BitSet out)
      : blk(blk), gen(std::move(gen)), kill(std::move(kill)), in(std::move(in)),
        out(std::move(out)) {}
};
} // namespace

namespace analyze {
namespace dataflow {

</t>
<t tx="ekr.20230509083242.524">void RDInspector::analyze() {
  std::vector&lt;const Value *&gt; ordering;
  std::unordered_map&lt;id_t, unsigned&gt; lookup;
  std::unordered_map&lt;id_t, std::vector&lt;const Value *&gt;&gt; varToAssignments;

  for (auto *blk : *cfg) {
    for (auto *val : *blk) {
      auto k = getKilled(val);
      if (k != -1) {
        lookup.emplace(val-&gt;getId(), ordering.size());
        ordering.push_back(val);
        varToAssignments[k].push_back(val);
      }
    }
  }

  unsigned n = ordering.size();
  std::unordered_map&lt;id_t, BlockBitSets&lt;CFBlock&gt;&gt; bitsets;

  // construct initial gen and kill sets
  for (auto *blk : *cfg) {
    auto gen = BitSet(n);
    auto kill = BitSet(n);

    std::unordered_map&lt;id_t, id_t&gt; generated;
    for (auto *val : *blk) {
      // vars that are used by pointer may change at any time, so don't track them
      if (auto *ptr = cast&lt;PointerValue&gt;(val)) {
        invalid.insert(ptr-&gt;getVar()-&gt;getId());
        continue;
      }

      auto g = getGenerated(val);
      if (g.first != -1) {
        // generated map will store latest generated assignment, as desired
        generated[g.first] = val-&gt;getId();
      }

      auto k = getKilled(val);
      if (k != -1) {
        // all other assignments that use the var are killed
        for (auto *assign : varToAssignments[k]) {
          if (assign-&gt;getId() != val-&gt;getId())
            kill.set(lookup[assign-&gt;getId()]);
        }
      }
    }

    // set gen for the last assignment of each var in the block
    for (auto &amp;entry : generated) {
      gen.set(lookup[entry.second]);
    }

    auto in = BitSet(n);
    auto out = gen.copy(n); // out = gen is an optimization over out = {}
    bitsets.emplace(std::piecewise_construct, std::forward_as_tuple(blk-&gt;getId()),
                    std::forward_as_tuple(blk, std::move(gen), std::move(kill),
                                          std::move(in), std::move(out)));
  }

  WorkList&lt;CFBlock&gt; worklist(cfg);
  while (auto *blk = worklist.pop()) {
    auto &amp;data = bitsets.find(blk-&gt;getId())-&gt;second;

    // IN[blk] = U OUT[pred], for all predecessors pred
    data.in.clear(n);
    for (auto it = blk-&gt;predecessors_begin(); it != blk-&gt;predecessors_end(); ++it) {
      data.in.update(bitsets.find((*it)-&gt;getId())-&gt;second.out, n);
    }

    // OUT[blk] = GEN[blk] U (IN[blk] - KILL[blk])
    auto oldout = data.out.copy(n);
    auto tmp = data.in.copy(n);
    tmp.subtract(data.kill, n);
    tmp.update(data.gen, n);
    data.out.overwrite(tmp, n);

    // if OUT changed, add all successors to worklist
    if (!data.out.equals(oldout, n)) {
      for (auto it = blk-&gt;successors_begin(); it != blk-&gt;successors_end(); ++it) {
        worklist.push(*it);
      }
    }
  }

  // reconstruct final sets in more convenient format
  for (auto &amp;elem : bitsets) {
    auto &amp;data = elem.second;
    auto &amp;entry = sets[data.blk-&gt;getId()];

    for (unsigned i = 0; i &lt; n; i++) {
      if (data.in.get(i)) {
        auto g = getGenerated(ordering[i]);
        entry.in[g.first].insert(g.second);
      }
    }
  }
}

</t>
<t tx="ekr.20230509083242.525">std::unordered_set&lt;id_t&gt; RDInspector::getReachingDefinitions(const Var *var,
</t>
<t tx="ekr.20230509083242.526">                                                             const Value *loc) {
  if (invalid.find(var-&gt;getId()) != invalid.end() || var-&gt;isGlobal())
    return {};

  auto *blk = cfg-&gt;getBlock(loc);
  if (!blk)
    return {};
  auto &amp;entry = sets[blk-&gt;getId()];
  auto defs = entry.in[var-&gt;getId()];
  if (blk-&gt;getId() == cfg-&gt;getEntryBlock()-&gt;getId())
    defs.insert(-1);

  auto done = false;
  for (auto *val : *blk) {
    if (done)
      break;
    if (val-&gt;getId() == loc-&gt;getId())
      done = true;

    auto killed = getKilled(val);
    if (killed == var-&gt;getId())
      defs.clear();
    auto gen = getGenerated(val);
    if (gen.first == var-&gt;getId())
      defs.insert(gen.second);
  }

  if (defs.find(-1) != defs.end())
    return {};

  return defs;
}

</t>
<t tx="ekr.20230509083242.527">@path C:/Repos/codon/codon/cir/analyze/dataflow/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;utility&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/cfg.h"

namespace codon {
namespace ir {
namespace analyze {
namespace dataflow {

@others
} // namespace dataflow
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.528">/// Helper to query the reaching definitions of a particular function.
class RDInspector {
private:
  struct BlockData {
    std::unordered_map&lt;id_t, std::unordered_set&lt;id_t&gt;&gt; in;
    BlockData() = default;
  };
  std::unordered_set&lt;id_t&gt; invalid;
  std::unordered_map&lt;id_t, BlockData&gt; sets;
  CFGraph *cfg;

public:
  explicit RDInspector(CFGraph *cfg) : cfg(cfg) {}

  /// Do the analysis.
  void analyze();

  /// Gets the reaching definitions at a particular location.
  /// @param var the variable being inspected
  /// @param loc the location
  /// @return an unordered set of value ids
  std::unordered_set&lt;id_t&gt; getReachingDefinitions(const Var *var, const Value *loc);

  bool isInvalid(const Var *var) const { return invalid.count(var-&gt;getId()) != 0; }
};

</t>
<t tx="ekr.20230509083242.529">/// Result of a reaching definition analysis.
struct RDResult : public Result {
  /// the corresponding control flow result
  const CFResult *cfgResult;
  /// the reaching definition inspectors
  std::unordered_map&lt;id_t, std::unique_ptr&lt;RDInspector&gt;&gt; results;

  explicit RDResult(const CFResult *cfgResult) : cfgResult(cfgResult) {}
};

</t>
<t tx="ekr.20230509083242.53">def __init__(self, i):
    self.x = x = sin(i)
    self.y = cos(i) * 3
    self.z = (x * x) / 2

</t>
<t tx="ekr.20230509083242.530">/// Reaching definition analysis. Must have control flow-graph available.
class RDAnalysis : public Analysis {
private:
  /// the control-flow analysis key
  std::string cfAnalysisKey;

public:
  static const std::string KEY;

  /// Initializes a reaching definition analysis.
  /// @param cfAnalysisKey the control-flow analysis key
  explicit RDAnalysis(std::string cfAnalysisKey)
      : cfAnalysisKey(std::move(cfAnalysisKey)) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.531"></t>
<t tx="ekr.20230509083242.532">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "global_vars.h"

#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {
namespace {
struct GlobalVarAnalyzer : public util::Operator {
  std::unordered_map&lt;id_t, id_t&gt; assignments;

@others
};
} // namespace

const std::string GlobalVarsAnalyses::KEY = "core-analyses-global-vars";

std::unique_ptr&lt;Result&gt; GlobalVarsAnalyses::run(const Module *m) {
  GlobalVarAnalyzer gva;
  gva.visit(const_cast&lt;Module *&gt;(m)); // TODO: any way around this cast?
  return std::make_unique&lt;GlobalVarsResult&gt;(std::move(gva.assignments));
}

} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.533">  void handle(PointerValue *v) override {
    if (v-&gt;getVar()-&gt;isGlobal())
      assignments[v-&gt;getVar()-&gt;getId()] = -1;
  }

</t>
<t tx="ekr.20230509083242.534">  void handle(AssignInstr *v) override {
    auto *lhs = v-&gt;getLhs();
    auto id = lhs-&gt;getId();
    if (lhs-&gt;isGlobal()) {
      if (assignments.find(id) != assignments.end()) {
        assignments[id] = -1;
      } else {
        assignments[id] = v-&gt;getRhs()-&gt;getId();
      }
    }
  }
</t>
<t tx="ekr.20230509083242.535">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/analyze/analysis.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {

struct GlobalVarsResult : public Result {
  std::unordered_map&lt;id_t, id_t&gt; assignments;
  explicit GlobalVarsResult(std::unordered_map&lt;id_t, id_t&gt; assignments)
      : assignments(std::move(assignments)) {}
};

@others
} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.536">class GlobalVarsAnalyses : public Analysis {
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.537">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "side_effect.h"

#include &lt;type_traits&gt;
#include &lt;utility&gt;

#include "codon/cir/analyze/dataflow/capture.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {
namespace {
template &lt;typename T&gt; T max(T &amp;&amp;t) { return std::forward&lt;T&gt;(t); }

@others
std::unique_ptr&lt;Result&gt; SideEffectAnalysis::run(const Module *m) {
  auto *capResult = getAnalysisResult&lt;dataflow::CaptureResult&gt;(capAnalysisKey);
  VarUseAnalyzer vua;
  const_cast&lt;Module *&gt;(m)-&gt;accept(vua);
  SideEfectAnalyzer sea(vua, capResult, globalAssignmentHasSideEffects);
  m-&gt;accept(sea);
  return std::make_unique&lt;SideEffectResult&gt;(sea.result);
}

} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.538">template &lt;typename T0, typename T1, typename... Ts&gt;
typename std::common_type&lt;T0, T1, Ts...&gt;::type max(T0 &amp;&amp;val1, T1 &amp;&amp;val2, Ts &amp;&amp;...vs) {
  return (val1 &gt; val2) ? max(val1, std::forward&lt;Ts&gt;(vs)...)
                       : max(val2, std::forward&lt;Ts&gt;(vs)...);
}

</t>
<t tx="ekr.20230509083242.539">struct VarUseAnalyzer : public util::Operator {
  std::unordered_map&lt;id_t, long&gt; varCounts;
  std::unordered_map&lt;id_t, long&gt; varAssignCounts;

</t>
<t tx="ekr.20230509083242.54">def __repr__(self):
    return f"&lt;Point: x={self.x}, y={self.y}, z={self.z}&gt;"

</t>
<t tx="ekr.20230509083242.540">  void preHook(Node *v) override {
    for (auto *var : v-&gt;getUsedVariables()) {
      ++varCounts[var-&gt;getId()];
    }
  }

</t>
<t tx="ekr.20230509083242.541">  void handle(AssignInstr *v) override { ++varAssignCounts[v-&gt;getLhs()-&gt;getId()]; }
};

struct SideEfectAnalyzer : public util::ConstVisitor {
  using Status = util::SideEffectStatus;

</t>
<t tx="ekr.20230509083242.542">  static Status getFunctionStatusFromAttributes(const Func *v, bool *force = nullptr) {
    auto attr = [v](const auto &amp;s) { return util::hasAttribute(v, s); };

    if (attr(util::PURE_ATTR)) {
      if (force)
        *force = true;
      return Status::PURE;
    }

    if (attr(util::NO_SIDE_EFFECT_ATTR)) {
      if (force)
        *force = true;
      return Status::NO_SIDE_EFFECT;
    }

    if (attr(util::NO_CAPTURE_ATTR)) {
      if (force)
        *force = true;
      return Status::NO_CAPTURE;
    }

    if (attr(util::NON_PURE_ATTR)) {
      if (force)
        *force = true;
      return Status::UNKNOWN;
    }

    if (force)
      *force = false;
    return Status::UNKNOWN;
  }

</t>
<t tx="ekr.20230509083242.543">  VarUseAnalyzer &amp;vua;
  dataflow::CaptureResult *cr;
  bool globalAssignmentHasSideEffects;
  std::unordered_map&lt;id_t, Status&gt; result;
  std::vector&lt;const BodiedFunc *&gt; funcStack;
  Status exprStatus;
  Status funcStatus;

  // We have to sometimes be careful with globals since future
  // IR passes might introduce globals that we've eliminated
  // or demoted earlier. Hence the distinction with whether
  // global assignments are considered to have side effects.
  SideEfectAnalyzer(VarUseAnalyzer &amp;vua, dataflow::CaptureResult *cr,
</t>
<t tx="ekr.20230509083242.544">                    bool globalAssignmentHasSideEffects)
      : util::ConstVisitor(), vua(vua), cr(cr),
        globalAssignmentHasSideEffects(globalAssignmentHasSideEffects), result(),
        funcStack(), exprStatus(Status::PURE), funcStatus(Status::PURE) {}

  template &lt;typename T&gt; bool has(const T *v) {
    return result.find(v-&gt;getId()) != result.end();
  }

</t>
<t tx="ekr.20230509083242.545">  template &lt;typename T&gt; void set(const T *v, Status expr, Status func = Status::PURE) {
    result[v-&gt;getId()] = exprStatus = expr;
    funcStatus = max(funcStatus, func);
  }

  template &lt;typename T&gt; Status process(const T *v) {
    if (!v)
      return Status::PURE;
    if (has(v))
      return result[v-&gt;getId()];
    v-&gt;accept(*this);
    seqassertn(has(v), "node not added to results");
    return result[v-&gt;getId()];
  }

  std::pair&lt;Status, Status&gt; getVarAssignStatus(const Var *var) {
    if (!var)
      return {Status::PURE, Status::PURE};

    auto id = var-&gt;getId();
    auto it1 = vua.varCounts.find(id);
    auto it2 = vua.varAssignCounts.find(id);
    auto count1 = (it1 != vua.varCounts.end()) ? it1-&gt;second : 0;
    auto count2 = (it2 != vua.varAssignCounts.end()) ? it2-&gt;second : 0;

    bool global = var-&gt;isGlobal();
    bool used = (count1 != count2);
    Status defaultStatus = global ? Status::UNKNOWN : Status::NO_CAPTURE;
    auto se2stat = [&amp;](bool b) { return b ? defaultStatus : Status::PURE; };

    if (globalAssignmentHasSideEffects || var-&gt;isExternal()) {
      return {se2stat(used || global), se2stat(global)};
    } else {
      return {se2stat(used), se2stat(used &amp;&amp; global)};
    }
  }

</t>
<t tx="ekr.20230509083242.546">  void handleVarAssign(const Value *v, const Var *var, Status base) {
    auto pair = getVarAssignStatus(var);
    set(v, max(pair.first, base), pair.second);
  }

</t>
<t tx="ekr.20230509083242.547">  void visit(const Module *v) override {
    process(v-&gt;getMainFunc());
    for (auto *x : *v) {
      process(x);
    }
  }

</t>
<t tx="ekr.20230509083242.548">  void visit(const Var *v) override { set(v, Status::PURE); }

</t>
<t tx="ekr.20230509083242.549">  void visit(const BodiedFunc *v) override {
    bool force;
    auto s = getFunctionStatusFromAttributes(v, &amp;force);
    set(v, s, s); // avoid infinite recursion
    auto oldFuncStatus = funcStatus;
    funcStatus = Status::PURE;
    funcStack.push_back(v);
    process(v-&gt;getBody());
    funcStack.pop_back();
    if (force)
      funcStatus = s;
    set(v, funcStatus);
    funcStatus = oldFuncStatus;
  }

</t>
<t tx="ekr.20230509083242.55">def normalize(self):
    x = self.x
    y = self.y
    z = self.z
    norm = sqrt(x * x + y * y + z * z)
    self.x /= norm
    self.y /= norm
    self.z /= norm

</t>
<t tx="ekr.20230509083242.550">  void visit(const ExternalFunc *v) override {
    set(v, getFunctionStatusFromAttributes(v));
  }

</t>
<t tx="ekr.20230509083242.551">  void visit(const InternalFunc *v) override { set(v, Status::PURE); }

  void visit(const LLVMFunc *v) override { set(v, getFunctionStatusFromAttributes(v)); }

  void visit(const VarValue *v) override { set(v, Status::PURE); }

  void visit(const PointerValue *v) override { set(v, Status::PURE); }

</t>
<t tx="ekr.20230509083242.552">  void visit(const SeriesFlow *v) override {
    Status s = Status::PURE;
    for (auto *x : *v) {
      s = max(s, process(x));
    }
    set(v, s);
  }

</t>
<t tx="ekr.20230509083242.553">  void visit(const IfFlow *v) override {
    set(v, max(process(v-&gt;getCond()), process(v-&gt;getTrueBranch()),
               process(v-&gt;getFalseBranch())));
  }

</t>
<t tx="ekr.20230509083242.554">  void visit(const WhileFlow *v) override {
    set(v, max(process(v-&gt;getCond()), process(v-&gt;getBody())));
  }

</t>
<t tx="ekr.20230509083242.555">  void visit(const ForFlow *v) override {
    auto s = max(process(v-&gt;getIter()), process(v-&gt;getBody()));
    if (auto *sched = v-&gt;getSchedule()) {
      for (auto *x : sched-&gt;getUsedValues()) {
        s = max(s, process(x));
      }
    }
    handleVarAssign(v, v-&gt;getVar(), s);
  }

</t>
<t tx="ekr.20230509083242.556">  void visit(const ImperativeForFlow *v) override {
    auto s = max(process(v-&gt;getStart()), process(v-&gt;getEnd()), process(v-&gt;getBody()));
    if (auto *sched = v-&gt;getSchedule()) {
      for (auto *x : sched-&gt;getUsedValues()) {
        s = max(s, process(x));
      }
    }
    handleVarAssign(v, v-&gt;getVar(), s);
  }

</t>
<t tx="ekr.20230509083242.557">  void visit(const TryCatchFlow *v) override {
    auto s = max(process(v-&gt;getBody()), process(v-&gt;getFinally()));
    auto callStatus = Status::PURE;

    for (auto &amp;x : *v) {
      auto pair = getVarAssignStatus(x.getVar());
      s = max(s, pair.first, process(x.getHandler()));
      callStatus = max(callStatus, pair.second);
    }

    set(v, s, callStatus);
  }

</t>
<t tx="ekr.20230509083242.558">  void visit(const PipelineFlow *v) override {
    auto s = Status::PURE;
    auto callStatus = Status::PURE;
    for (auto &amp;stage : *v) {
      // make sure we're treating this as a call
      if (auto *f = util::getFunc(stage.getCallee())) {
        auto stageCallStatus = process(f);
        callStatus = max(callStatus, stageCallStatus);
        s = max(s, stageCallStatus);
      } else {
        // unknown function
        process(stage.getCallee());
        callStatus = Status::UNKNOWN;
        s = Status::UNKNOWN;
      }

      for (auto *arg : stage) {
        s = max(s, process(arg));
      }
    }
    set(v, s, callStatus);
  }

</t>
<t tx="ekr.20230509083242.559">  void visit(const dsl::CustomFlow *v) override {
    set(v, v-&gt;getSideEffectStatus(/*local=*/true),
        v-&gt;getSideEffectStatus(/*local=*/false));
  }

</t>
<t tx="ekr.20230509083242.56">def maximize(self, other):
    self.x = self.x if self.x &gt; other.x else other.x
    self.y = self.y if self.y &gt; other.y else other.y
    self.z = self.z if self.z &gt; other.z else other.z
    return self


</t>
<t tx="ekr.20230509083242.560">  void visit(const IntConst *v) override { set(v, Status::PURE); }

  void visit(const FloatConst *v) override { set(v, Status::PURE); }

  void visit(const BoolConst *v) override { set(v, Status::PURE); }

  void visit(const StringConst *v) override { set(v, Status::PURE); }

  void visit(const dsl::CustomConst *v) override { set(v, Status::PURE); }

</t>
<t tx="ekr.20230509083242.561">  void visit(const AssignInstr *v) override {
    handleVarAssign(v, v-&gt;getLhs(), process(v-&gt;getRhs()));
  }

</t>
<t tx="ekr.20230509083242.562">  void visit(const ExtractInstr *v) override { set(v, process(v-&gt;getVal())); }

</t>
<t tx="ekr.20230509083242.563">  void visit(const InsertInstr *v) override {
    process(v-&gt;getLhs());
    process(v-&gt;getRhs());

    auto *func = funcStack.back();
    auto it = cr-&gt;results.find(func-&gt;getId());
    seqassertn(it != cr-&gt;results.end(), "function not found in capture results");
    auto captureInfo = it-&gt;second;

    bool pure = true;

    for (auto &amp;info : captureInfo) {
      if (info.externCaptures || info.modified || !info.argCaptures.empty()) {
        pure = false;
        break;
      }
    }

    if (pure) {
      // make sure the lhs does not escape
      auto escapeInfo = escapes(func, v-&gt;getLhs(), cr);
      pure = (!escapeInfo || (escapeInfo.returnCaptures &amp;&amp; !escapeInfo.externCaptures &amp;&amp;
                              escapeInfo.argCaptures.empty()));
    }

    set(v, Status::UNKNOWN, pure ? Status::PURE : Status::UNKNOWN);
  }

</t>
<t tx="ekr.20230509083242.564">  void visit(const CallInstr *v) override {
    auto s = Status::PURE;
    auto callStatus = Status::UNKNOWN;
    for (auto *x : *v) {
      s = max(s, process(x));
    }
    if (auto *f = util::getFunc(v-&gt;getCallee())) {
      callStatus = process(f);
      s = max(s, callStatus);
    } else {
      // unknown function
      process(v-&gt;getCallee());
      s = Status::UNKNOWN;
    }
    set(v, s, callStatus);
  }

</t>
<t tx="ekr.20230509083242.565">  void visit(const StackAllocInstr *v) override { set(v, Status::PURE); }

  void visit(const TypePropertyInstr *v) override { set(v, Status::PURE); }

  void visit(const YieldInInstr *v) override { set(v, Status::NO_CAPTURE); }

</t>
<t tx="ekr.20230509083242.566">  void visit(const TernaryInstr *v) override {
    set(v, max(process(v-&gt;getCond()), process(v-&gt;getTrueValue()),
               process(v-&gt;getFalseValue())));
  }

</t>
<t tx="ekr.20230509083242.567">  void visit(const BreakInstr *v) override { set(v, Status::NO_CAPTURE); }

  void visit(const ContinueInstr *v) override { set(v, Status::NO_CAPTURE); }

</t>
<t tx="ekr.20230509083242.568">  void visit(const ReturnInstr *v) override {
    set(v, max(Status::NO_CAPTURE, process(v-&gt;getValue())));
  }

</t>
<t tx="ekr.20230509083242.569">  void visit(const YieldInstr *v) override {
    set(v, max(Status::NO_CAPTURE, process(v-&gt;getValue())));
  }

</t>
<t tx="ekr.20230509083242.57">def maximize(points):
    next = points[0]
    for p in points[1:]:
        next = next.maximize(p)
    return next


</t>
<t tx="ekr.20230509083242.570">  void visit(const ThrowInstr *v) override {
    process(v-&gt;getValue());
    set(v, Status::UNKNOWN, Status::NO_CAPTURE);
  }

</t>
<t tx="ekr.20230509083242.571">  void visit(const FlowInstr *v) override {
    set(v, max(process(v-&gt;getFlow()), process(v-&gt;getValue())));
  }

</t>
<t tx="ekr.20230509083242.572">  void visit(const dsl::CustomInstr *v) override {
    set(v, v-&gt;getSideEffectStatus(/*local=*/true),
        v-&gt;getSideEffectStatus(/*local=*/false));
  }
</t>
<t tx="ekr.20230509083242.573">};
} // namespace

const std::string SideEffectAnalysis::KEY = "core-analyses-side-effect";

</t>
<t tx="ekr.20230509083242.574">bool SideEffectResult::hasSideEffect(const Value *v) const {
  auto it = result.find(v-&gt;getId());
  return it == result.end() || it-&gt;second != util::SideEffectStatus::PURE;
}

</t>
<t tx="ekr.20230509083242.575">@path C:/Repos/codon/codon/cir/analyze/module/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/util/side_effect.h"

namespace codon {
namespace ir {
namespace analyze {
namespace module {

struct SideEffectResult : public Result {
  /// mapping of ID to corresponding node's side effect status
  std::unordered_map&lt;id_t, util::SideEffectStatus&gt; result;

  SideEffectResult(std::unordered_map&lt;id_t, util::SideEffectStatus&gt; result)
      : result(std::move(result)) {}

  /// @param v the value to check
  /// @return true if the node has side effects (false positives allowed)
  bool hasSideEffect(const Value *v) const;
};

@others
} // namespace module
} // namespace analyze
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.576">class SideEffectAnalysis : public Analysis {
private:
  /// the capture analysis key
  std::string capAnalysisKey;
  /// true if assigning to a global variable automatically has side effects
  bool globalAssignmentHasSideEffects;

public:
  static const std::string KEY;

  /// Constructs a side effect analysis.
  /// @param globalAssignmentHasSideEffects true if global variable assignment
  /// automatically has side effects
  explicit SideEffectAnalysis(const std::string &amp;capAnalysisKey,
                              bool globalAssignmentHasSideEffects = true)
      : Analysis(), capAnalysisKey(capAnalysisKey),
        globalAssignmentHasSideEffects(globalAssignmentHasSideEffects) {}

  std::string getKey() const override { return KEY; }

  std::unique_ptr&lt;Result&gt; run(const Module *m) override;
};

</t>
<t tx="ekr.20230509083242.577"></t>
<t tx="ekr.20230509083242.578">@path C:/Repos/codon/codon/cir/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/cir/types/types.h"

namespace codon {
namespace ir {

namespace analyze {
namespace dataflow {
class CFVisitor;
} // namespace dataflow
} // namespace analyze

class LLVMVisitor;

namespace dsl {
namespace codegen {

/// Builder for LLVM types.
struct TypeBuilder {
  virtual ~TypeBuilder() noexcept = default;

  /// Construct the LLVM type.
  /// @param the LLVM visitor
  /// @return the LLVM type
  virtual llvm::Type *buildType(LLVMVisitor *visitor) = 0;
  /// Construct the LLVM debug type.
  /// @param the LLVM visitor
  /// @return the LLVM debug type
  virtual llvm::DIType *buildDebugType(LLVMVisitor *visitor) = 0;
};

/// Builder for LLVM values.
struct ValueBuilder {
  virtual ~ValueBuilder() noexcept = default;

  /// Construct the LLVM value.
  /// @param the LLVM visitor
  /// @return the LLVM value
  virtual llvm::Value *buildValue(LLVMVisitor *visitor) = 0;
};

/// Builder for control flow graphs.
struct CFBuilder {
  virtual ~CFBuilder() noexcept = default;

  /// Construct the control-flow nodes.
  /// @param graph the graph
  virtual void buildCFNodes(analyze::dataflow::CFVisitor *visitor) = 0;
};

} // namespace codegen
} // namespace dsl
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.579">@path C:/Repos/codon/codon/cir/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "nodes.h"

namespace codon {
namespace ir {
namespace dsl {

namespace types {
const char CustomType::NodeId = 0;
}

const char CustomConst::NodeId = 0;

const char CustomFlow::NodeId = 0;

const char CustomInstr::NodeId = 0;

} // namespace dsl
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.58">def benchmark(n):
    points = [None] * n
    for i in range(n):
        points[i] = Point(i)
    for p in points:
        p.normalize()
    return maximize(points)


</t>
<t tx="ekr.20230509083242.580">@path C:/Repos/codon/codon/cir/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/base.h"
#include "codon/cir/const.h"
#include "codon/cir/instr.h"
#include "codon/cir/util/side_effect.h"

namespace codon {
namespace ir {

namespace util {
class CloneVisitor;
} // namespace util

namespace dsl {

namespace codegen {
struct CFBuilder;
struct TypeBuilder;
struct ValueBuilder;
} // namespace codegen

namespace types {

@others
} // namespace dsl
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.581">/// DSL type.
class CustomType : public AcceptorExtend&lt;CustomType, ir::types::Type&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the type builder
  virtual std::unique_ptr&lt;codegen::TypeBuilder&gt; getBuilder() const = 0;

  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Type *v) const = 0;

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509083242.582">} // namespace types

</t>
<t tx="ekr.20230509083242.583">/// DSL constant.
class CustomConst : public AcceptorExtend&lt;CustomConst, Const&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509083242.584">/// DSL flow.
class CustomFlow : public AcceptorExtend&lt;CustomFlow, Flow&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;
  /// @return the control-flow builder
  virtual std::unique_ptr&lt;codegen::CFBuilder&gt; getCFBuilder() const = 0;
  /// Query this custom node for its side effect properties. If "local"
  /// is true, then the return value should reflect this node and this
  /// node alone, otherwise the value should reflect functions containing
  /// this node in their bodies. For example, a "break" instruction has
  /// side effects locally, but functions containing "break" might still
  /// be side effect free, hence the distinction.
  /// @param local true if result should reflect only this node
  /// @return this node's side effect status
  virtual util::SideEffectStatus getSideEffectStatus(bool local = true) const {
    return util::SideEffectStatus::UNKNOWN;
  }

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509083242.585">/// DSL instruction.
class CustomInstr : public AcceptorExtend&lt;CustomInstr, Instr&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

  /// @return the value builder
  virtual std::unique_ptr&lt;codegen::ValueBuilder&gt; getBuilder() const = 0;
  /// Compares DSL nodes.
  /// @param v the other node
  /// @return true if they match
  virtual bool match(const Value *v) const = 0;
  /// Clones the value.
  /// @param cv the clone visitor
  /// @return a clone of the object
  virtual Value *doClone(util::CloneVisitor &amp;cv) const = 0;
  /// @return the control-flow builder
  virtual std::unique_ptr&lt;codegen::CFBuilder&gt; getCFBuilder() const = 0;
  /// Query this custom node for its side effect properties. If "local"
  /// is true, then the return value should reflect this node and this
  /// node alone, otherwise the value should reflect functions containing
  /// this node in their bodies. For example, a "break" instruction has
  /// side effects locally, but functions containing "break" might still
  /// be side effect free, hence the distinction.
  /// @param local true if result should reflect only this node
  /// @return this node's side effect status
  virtual util::SideEffectStatus getSideEffectStatus(bool local = true) const {
    return util::SideEffectStatus::UNKNOWN;
  }

  /// Format the DSL node.
  /// @param os the output stream
  virtual std::ostream &amp;doFormat(std::ostream &amp;os) const = 0;
};

</t>
<t tx="ekr.20230509083242.586"></t>
<t tx="ekr.20230509083242.587">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "gpu.h"

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;string&gt;

#include "codon/util/common.h"

namespace codon {
namespace ir {
namespace {
const std::string GPU_TRIPLE = "nvptx64-nvidia-cuda";
@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.588">const std::string GPU_DL =
    "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-"
    "f64:64:64-v16:16:16-v32:32:32-v64:64:64-v128:128:128-n16:32:64";
llvm::cl::opt&lt;std::string&gt;
    libdevice("libdevice", llvm::cl::desc("libdevice path for GPU kernels"),
              llvm::cl::init("/usr/local/cuda/nvvm/libdevice/libdevice.10.bc"));

  @others
</t>
<t tx="ekr.20230509083242.589">// Adapted from LLVM's GVExtractorPass, which is not externally available
// as a pass for the new pass manager.
class GVExtractor : public llvm::PassInfoMixin&lt;GVExtractor&gt; {
llvm::SetVector&lt;llvm::GlobalValue *&gt; named;
bool deleteStuff;
bool keepConstInit;

public:
// If deleteS is true, this pass deletes the specified global values.
// Otherwise, it deletes as much of the module as possible, except for the
// global values specified.
explicit GVExtractor(std::vector&lt;llvm::GlobalValue *&gt; &amp;GVs, bool deleteS = true,
@others
    makeVisible(GV, del);

    if (del) {
      // Make this a declaration and drop it's comdat.
      GV.setInitializer(nullptr);
      GV.setComdat(nullptr);
    }
  }

  // Visit the Functions.
  for (auto &amp;F : M) {
    bool del = deleteStuff == (bool)named.count(&amp;F) &amp;&amp; !F.isDeclaration();
    if (!del) {
      if (F.hasAvailableExternallyLinkage())
        continue;
    }

    makeVisible(F, del);

    if (del) {
      // Make this a declaration and drop it's comdat.
      F.deleteBody();
      F.setComdat(nullptr);
    }
  }

  // Visit the Aliases.
  for (auto &amp;GA : llvm::make_early_inc_range(M.aliases())) {
    bool del = deleteStuff == (bool)named.count(&amp;GA);
    makeVisible(GA, del);

    if (del) {
      auto *ty = GA.getValueType();
      GA.removeFromParent();
      llvm::Value *decl;
      if (auto *funcTy = llvm::dyn_cast&lt;llvm::FunctionType&gt;(ty)) {
        decl = llvm::Function::Create(funcTy, llvm::GlobalValue::ExternalLinkage,
                                      GA.getAddressSpace(), GA.getName(), &amp;M);

      } else {
        decl = new llvm::GlobalVariable(
            M, ty, false, llvm::GlobalValue::ExternalLinkage, nullptr, GA.getName());
      }
      GA.replaceAllUsesWith(decl);
      delete &amp;GA;
    }
  }

  return llvm::PreservedAnalyses::none();
}
};

</t>
<t tx="ekr.20230509083242.59"></t>
<t tx="ekr.20230509083242.590">                     bool keepConstInit = false)
    : named(GVs.begin(), GVs.end()), deleteStuff(deleteS),
      keepConstInit(keepConstInit) {}

@others
</t>
<t tx="ekr.20230509083242.591">// Make sure GV is visible from both modules. Delete is true if it is
// being deleted from this module.
// This also makes sure GV cannot be dropped so that references from
// the split module remain valid.
static void makeVisible(llvm::GlobalValue &amp;GV, bool del) {
  bool local = GV.hasLocalLinkage();
  if (local || del) {
    GV.setLinkage(llvm::GlobalValue::ExternalLinkage);
    if (local)
      GV.setVisibility(llvm::GlobalValue::HiddenVisibility);
    return;
  }

  if (!GV.hasLinkOnceLinkage()) {
    seqassertn(!GV.isDiscardableIfUnused(), "bad global in extractor");
    return;
  }

  // Map linkonce* to weak* so that llvm doesn't drop this GV.
  switch (GV.getLinkage()) {
  default:
    seqassertn(false, "unexpected linkage");
  case llvm::GlobalValue::LinkOnceAnyLinkage:
    GV.setLinkage(llvm::GlobalValue::WeakAnyLinkage);
    return;
  case llvm::GlobalValue::LinkOnceODRLinkage:
    GV.setLinkage(llvm::GlobalValue::WeakODRLinkage);
    return;
  }
}

</t>
<t tx="ekr.20230509083242.592">llvm::PreservedAnalyses run(llvm::Module &amp;M, llvm::ModuleAnalysisManager &amp;) {
  // Visit the global inline asm.
  if (!deleteStuff)
    M.setModuleInlineAsm("");

  // For simplicity, just give all GlobalValues ExternalLinkage. A trickier
  // implementation could figure out which GlobalValues are actually
  // referenced by the 'named' set, and which GlobalValues in the rest of
  // the module are referenced by the NamedSet, and get away with leaving
  // more internal and private things internal and private. But for now,
  // be conservative and simple.

  // Visit the GlobalVariables.
  for (auto &amp;GV : M.globals()) {
</t>
<t tx="ekr.20230509083242.593">    bool del = deleteStuff == (bool)named.count(&amp;GV) &amp;&amp; !GV.isDeclaration() &amp;&amp;
               (!GV.isConstant() || !keepConstInit);
    if (!del) {
      if (GV.hasAvailableExternallyLinkage())
        continue;
      if (GV.getName() == "llvm.global_ctors")
        continue;
    }

</t>
<t tx="ekr.20230509083242.594">std::string cleanUpName(llvm::StringRef name) {
  std::string validName;
  llvm::raw_string_ostream validNameStream(validName);

</t>
<t tx="ekr.20230509083242.595">  auto valid = [](char c, bool first) {
    bool ok = ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || (c == '_');
    if (!first)
      ok = ok || ('0' &lt;= c &amp;&amp; c &lt;= '9');
    return ok;
  };

</t>
<t tx="ekr.20230509083242.596">  bool first = true;
  for (char c : name) {
    validNameStream &lt;&lt; (valid(c, first) ? c : '_');
    first = false;
  }

  return validNameStream.str();
}

</t>
<t tx="ekr.20230509083242.597">void linkLibdevice(llvm::Module *M, const std::string &amp;path) {
  llvm::SMDiagnostic err;
  auto libdevice = llvm::parseIRFile(path, err, M-&gt;getContext());
  if (!libdevice)
    compilationError(err.getMessage().str(), err.getFilename().str(), err.getLineNo(),
                     err.getColumnNo());
  libdevice-&gt;setDataLayout(M-&gt;getDataLayout());
  libdevice-&gt;setTargetTriple(M-&gt;getTargetTriple());

  llvm::Linker L(*M);
  const bool fail = L.linkInModule(std::move(libdevice));
  seqassertn(!fail, "linking libdevice failed");
}

</t>
<t tx="ekr.20230509083242.598">llvm::Function *copyPrototype(llvm::Function *F, const std::string &amp;name) {
  auto *M = F-&gt;getParent();
  return llvm::Function::Create(F-&gt;getFunctionType(), llvm::GlobalValue::PrivateLinkage,
                                name.empty() ? F-&gt;getName() : name, *M);
}

llvm::Function *makeNoOp(llvm::Function *F) {
  auto *M = F-&gt;getParent();
  auto &amp;context = M-&gt;getContext();
  auto dummyName = (".codon.gpu.dummy." + F-&gt;getName()).str();
  auto *dummy = M-&gt;getFunction(dummyName);
  if (!dummy) {
    dummy = copyPrototype(F, dummyName);
    auto *entry = llvm::BasicBlock::Create(context, "entry", dummy);
    llvm::IRBuilder&lt;&gt; B(entry);

    auto *retType = F-&gt;getReturnType();
    if (retType-&gt;isVoidTy()) {
      B.CreateRetVoid();
    } else {
      B.CreateRet(llvm::UndefValue::get(retType));
    }
  }
  return dummy;
}

using Codegen =
    std::function&lt;void(llvm::IRBuilder&lt;&gt; &amp;, const std::vector&lt;llvm::Value *&gt; &amp;)&gt;;

llvm::Function *makeFillIn(llvm::Function *F, Codegen codegen) {
  auto *M = F-&gt;getParent();
  auto &amp;context = M-&gt;getContext();
  auto fillInName = (".codon.gpu.fillin." + F-&gt;getName()).str();
  auto *fillIn = M-&gt;getFunction(fillInName);
  if (!fillIn) {
    fillIn = copyPrototype(F, fillInName);
    std::vector&lt;llvm::Value *&gt; args;
    for (auto it = fillIn-&gt;arg_begin(); it != fillIn-&gt;arg_end(); ++it) {
      args.push_back(it);
    }
    auto *entry = llvm::BasicBlock::Create(context, "entry", fillIn);
    llvm::IRBuilder&lt;&gt; B(entry);
    codegen(B, args);
  }
  return fillIn;
}

llvm::Function *makeMalloc(llvm::Module *M) {
  auto &amp;context = M-&gt;getContext();
  auto F = M-&gt;getOrInsertFunction("malloc", llvm::Type::getInt8PtrTy(context),
                                  llvm::Type::getInt64Ty(context));
  auto *G = llvm::cast&lt;llvm::Function&gt;(F.getCallee());
  G-&gt;setLinkage(llvm::GlobalValue::ExternalLinkage);
  G-&gt;setDoesNotThrow();
  G-&gt;setReturnDoesNotAlias();
  G-&gt;setOnlyAccessesInaccessibleMemory();
  G-&gt;setWillReturn();
  return G;
}

</t>
<t tx="ekr.20230509083242.599">void remapFunctions(llvm::Module *M) {
  @others
  for (auto &amp;pair : remapping) {
    if (auto *F = M-&gt;getFunction(pair.first)) {
      llvm::Function *G = nullptr;
      if (pair.second.empty()) {
        G = makeNoOp(F);
      } else {
        G = M-&gt;getFunction(pair.second);
        if (!G)
          G = copyPrototype(F, pair.second);
      }

      G-&gt;setWillReturn();
      F-&gt;replaceAllUsesWith(G);
      F-&gt;dropAllReferences();
      F-&gt;eraseFromParent();
    }
  }

  for (auto &amp;pair : fillins) {
    if (auto *F = M-&gt;getFunction(pair.first)) {
      llvm::Function *G = makeFillIn(F, pair.second);
      F-&gt;replaceAllUsesWith(G);
      F-&gt;dropAllReferences();
      F-&gt;eraseFromParent();
    }
  }
}

</t>
<t tx="ekr.20230509083242.6">@path C:/Repos/codon/bench/binary_trees/
#include &lt;cassert&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

struct Node {
  std::unique_ptr&lt;Node&gt; left{};
  std::unique_ptr&lt;Node&gt; right{};
};

inline std::unique_ptr&lt;Node&gt; make_tree(int d) {
  if (d &gt; 0) {
    return std::make_unique&lt;Node&gt;(Node{make_tree(d - 1), make_tree(d - 1)});
  } else {
    return std::make_unique&lt;Node&gt;();
  }
}

inline int check_tree(const std::unique_ptr&lt;Node&gt; &amp;node) {
  if (!node-&gt;left)
    return 1;
  else
    return 1 + check_tree(node-&gt;left) + check_tree(node-&gt;right);
}

inline int make_check(const std::pair&lt;int, int&gt; &amp;itde) {
  int i = itde.first, d = itde.second;
  auto tree = make_tree(d);
  return check_tree(tree);
}

struct ArgChunks {
  int i, k, d, chunksize;
  std::vector&lt;std::pair&lt;int, int&gt;&gt; chunk;

  ArgChunks(int i, int d, int chunksize = 5000)
      : i(i), k(1), d(d), chunksize(chunksize), chunk() {
    assert(chunksize % 2 == 0);
  }

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.60">@path C:/Repos/codon/bench/go/
@language unknown_language
"""
Go board game
"""
import math
import random
from time import time

SIZE = 9
GAMES = 200
KOMI = 7.5
EMPTY, WHITE, BLACK = 0, 1, 2
SHOW = {EMPTY: '.', WHITE: 'o', BLACK: 'x'}
PASS = -1
MAXMOVES = SIZE * SIZE * 3
TIMESTAMP = 0
MOVES = 0


def to_pos(x, y):
    return y * SIZE + x


def to_xy(pos):
    y, x = divmod(pos, SIZE)
    return x, y


@dataclass(init=False)
class Square[Board]:
    board: Board
    pos: int
    timestamp: int
    removestamp: int
    zobrist_strings: List[int]
    neighbours: Optional[List[Square[Board]]]
    color: int
    used: bool
    reference: Optional[Square[Board]]
    ledges: int
    temp_ledges: int

    def __init__(self, board, pos):
        self.board = board
        self.pos = pos
        self.timestamp = TIMESTAMP
        self.removestamp = TIMESTAMP
        self.zobrist_strings = [random.randrange(9223372036854775807)
                                for i in range(3)]
        self.neighbours = None
        self.color = EMPTY
        self.used = False
        self.reference = None
        self.ledges = 0
        self.temp_ledges = 0

    def set_neighbours(self):
        x, y = self.pos % SIZE, self.pos // SIZE
        self.neighbours = []
        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            newx, newy = x + dx, y + dy
            if 0 &lt;= newx &lt; SIZE and 0 &lt;= newy &lt; SIZE:
                self.neighbours.append(self.board.squares[to_pos(newx, newy)])

    def move(self, color):
        global TIMESTAMP, MOVES
        TIMESTAMP += 1
        MOVES += 1
        self.board.zobrist.update(self, color)
        self.color = color
        self.reference = self
        self.ledges = 0
        self.used = True
        for neighbour in self.neighbours:
            neighcolor = neighbour.color
            if neighcolor == EMPTY:
                self.ledges += 1
            else:
                neighbour_ref = neighbour.find(update=True)
                if neighcolor == color:
                    if neighbour_ref.reference.pos != self.pos:
                        self.ledges += neighbour_ref.ledges
                        neighbour_ref.reference = self
                    self.ledges -= 1
                else:
                    neighbour_ref.ledges -= 1
                    if neighbour_ref.ledges == 0:
                        neighbour.remove(neighbour_ref)
        self.board.zobrist.add()

    def remove(self, reference, update=True):
        self.board.zobrist.update(self, EMPTY)
        self.removestamp = TIMESTAMP
        if update:
            self.color = EMPTY
            self.board.emptyset.add(self.pos)
#            if color == BLACK:
#                self.board.black_dead += 1
#            else:
#                self.board.white_dead += 1
        for neighbour in self.neighbours:
            if neighbour.color != EMPTY and neighbour.removestamp != TIMESTAMP:
                neighbour_ref = neighbour.find(update)
                if neighbour_ref.pos == reference.pos:
                    neighbour.remove(reference, update)
                else:
                    if update:
                        neighbour_ref.ledges += 1

    def find(self, update=False):
        reference = self.reference
        if reference.pos != self.pos:
            reference = reference.find(update)
            if update:
                self.reference = reference
        return reference

    def __repr__(self):
        return repr(to_xy(self.pos))


class EmptySet[Board]:
    board: Board
    empties: List[int]
    empty_pos: List[int]

    def __init__(self, board):
        self.board = board
        self.empties = list(range(SIZE * SIZE))
        self.empty_pos = list(range(SIZE * SIZE))

    def random_choice(self):
        choices = len(self.empties)
        while choices:
            i = int(random.random() * choices)
            pos = self.empties[i]
            if self.board.useful(pos):
                return pos
            choices -= 1
            self.set(i, self.empties[choices])
            self.set(choices, pos)
        return PASS

    def add(self, pos):
        self.empty_pos[pos] = len(self.empties)
        self.empties.append(pos)

    def remove(self, pos):
        self.set(self.empty_pos[pos], self.empties[len(self.empties) - 1])
        self.empties.pop()

    def set(self, i, pos):
        self.empties[i] = pos
        self.empty_pos[pos] = i


class ZobristHash[Board]:
    board: Board
    hash_set: Set[int]
    hash: int

    def __init__(self, board):
        self.board = board
        self.hash_set = set()
        self.hash = 0
        for square in self.board.squares:
            self.hash ^= square.zobrist_strings[EMPTY]
        self.hash_set.clear()
        self.hash_set.add(self.hash)

    def update(self, square, color):
        self.hash ^= square.zobrist_strings[square.color]
        self.hash ^= square.zobrist_strings[color]

    def add(self):
        self.hash_set.add(self.hash)

    def dupe(self):
        return self.hash in self.hash_set


class Board:
    squares: List[Square[Board]]
    emptyset: EmptySet[Board]
    zobrist: ZobristHash[Board]
    color: int
    finished: bool
    lastmove: int
    history: List[int]
    white_dead: int
    black_dead: int

    def __init__(self):
        self.squares = [Square(self, pos) for pos in range(SIZE * SIZE)]
        for square in self.squares:
            square.set_neighbours()
        self.reset()

    def reset(self):
        for square in self.squares:
            square.color = EMPTY
            square.used = False
        self.emptyset = EmptySet(self)
        self.zobrist = ZobristHash(self)
        self.color = BLACK
        self.finished = False
        self.lastmove = -2
        self.history = []
        self.white_dead = 0
        self.black_dead = 0

    def move(self, pos):
        square = self.squares[pos]
        if pos != PASS:
            square.move(self.color)
            self.emptyset.remove(square.pos)
        elif self.lastmove == PASS:
            self.finished = True
        if self.color == BLACK:
            self.color = WHITE
        else:
            self.color = BLACK
        self.lastmove = pos
        self.history.append(pos)

    def random_move(self):
        return self.emptyset.random_choice()

    def useful_fast(self, square):
        if not square.used:
            for neighbour in square.neighbours:
                if neighbour.color == EMPTY:
                    return True
        return False

    def useful(self, pos):
        global TIMESTAMP
        TIMESTAMP += 1
        square = self.squares[pos]
        if self.useful_fast(square):
            return True
        old_hash = self.zobrist.hash
        self.zobrist.update(square, self.color)
        empties = opps = weak_opps = neighs = weak_neighs = 0
        for neighbour in square.neighbours:
            neighcolor = neighbour.color
            if neighcolor == EMPTY:
                empties += 1
                continue
            neighbour_ref = neighbour.find()
            if neighbour_ref.timestamp != TIMESTAMP:
                if neighcolor == self.color:
                    neighs += 1
                else:
                    opps += 1
                neighbour_ref.timestamp = TIMESTAMP
                neighbour_ref.temp_ledges = neighbour_ref.ledges
            neighbour_ref.temp_ledges -= 1
            if neighbour_ref.temp_ledges == 0:
                if neighcolor == self.color:
                    weak_neighs += 1
                else:
                    weak_opps += 1
                    neighbour_ref.remove(neighbour_ref, update=False)
        dupe = self.zobrist.dupe()
        self.zobrist.hash = old_hash
        strong_neighs = neighs - weak_neighs
        strong_opps = opps - weak_opps
        return not dupe and \
            (empties or weak_opps or (strong_neighs and (strong_opps or weak_neighs)))

    def useful_moves(self):
        return [pos for pos in self.emptyset.empties if self.useful(pos)]

    def replay(self, history):
        for pos in history:
            self.move(pos)

    def score(self, color):
        if color == WHITE:
            count = KOMI + self.black_dead
        else:
            count = float(self.white_dead)
        for square in self.squares:
            squarecolor = square.color
            if squarecolor == color:
                count += 1
            elif squarecolor == EMPTY:
                surround = 0
                for neighbour in square.neighbours:
                    if neighbour.color == color:
                        surround += 1
                if surround == len(square.neighbours):
                    count += 1
        return count

    def check(self):
        for square in self.squares:
            if square.color == EMPTY:
                continue

            members1 = set([square])
            changed = True
            while changed:
                changed = False
                for member in members1.copy():
                    for neighbour in member.neighbours:
                        if neighbour.color == square.color and neighbour not in members1:
                            changed = True
                            members1.add(neighbour)
            ledges1 = 0
            for member in members1:
                for neighbour in member.neighbours:
                    if neighbour.color == EMPTY:
                        ledges1 += 1

            root = square.find()

            # print 'members1', square, root, members1
            # print 'ledges1', square, ledges1

            members2 = set()
            for square2 in self.squares:
                if square2.color != EMPTY and square2.find() == root:
                    members2.add(square2)

            ledges2 = root.ledges
            # print 'members2', square, root, members1
            # print 'ledges2', square, ledges2

            assert members1 == members2
            assert ledges1 == ledges2

            set(self.emptyset.empties)

            empties2 = set()
            for square in self.squares:
                if square.color == EMPTY:
                    empties2.add(square.pos)

    def __repr__(self):
        result = []
        for y in range(SIZE):
            start = to_pos(0, y)
            result.append(''.join(
                [SHOW[square.color] + ' ' for square in self.squares[start:start + SIZE]]))
        return '\n'.join(result)


class UCTNode:
    bestchild: Optional[UCTNode]
    pos: int
    wins: int
    losses: int
    pos_child: List[Optional[UCTNode]]
    parent: Optional[UCTNode]
    unexplored: List[int]

    def __init__(self):
        self.bestchild = None
        self.pos = -1
        self.wins = 0
        self.losses = 0
        self.pos_child = [None for x in range(SIZE * SIZE)]
        self.parent = None
        self.unexplored = []

    def play(self, board):
        """ uct tree search """
        color = board.color
        node = self
        path = [node]
        while True:
            pos = node.select(board)
            if pos == PASS:
                break
            board.move(pos)
            child = node.pos_child[pos]
            if not child:
                child = node.pos_child[pos] = UCTNode()
                child.unexplored = board.useful_moves()
                child.pos = pos
                child.parent = node
                path.append(child)
                break
            path.append(child)
            node = child
        self.random_playout(board)
        self.update_path(board, color, path)

    def select(self, board):
        """ select move; unexplored children first, then according to uct value """
        if self.unexplored:
            i = random.randrange(len(self.unexplored))
            pos = self.unexplored[i]
            self.unexplored[i] = self.unexplored[len(self.unexplored) - 1]
            self.unexplored.pop()
            return pos
        elif self.bestchild:
            return self.bestchild.pos
        else:
            return PASS

    def random_playout(self, board):
        """ random play until both players pass """
        for x in range(MAXMOVES):  # XXX while not self.finished?
            if board.finished:
                break
            board.move(board.random_move())

    def update_path(self, board, color, path):
        """ update win/loss count along path """
        wins = board.score(BLACK) &gt;= board.score(WHITE)
        for node in path:
            if color == BLACK:
                color = WHITE
            else:
                color = BLACK
            if wins == (color == BLACK):
                node.wins += 1
            else:
                node.losses += 1
            if node.parent:
                node.parent.bestchild = node.parent.best_child()

    def score(self):
        winrate = self.wins / float(self.wins + self.losses)
        parentvisits = self.parent.wins + self.parent.losses
        if not parentvisits:
            return winrate
        nodevisits = self.wins + self.losses
        return winrate + math.sqrt((math.log(parentvisits)) / (5 * nodevisits))

    def best_child(self):
        maxscore = -1.
        maxchild = None
        for child in self.pos_child:
            if child and child.score() &gt; maxscore:
                maxchild = child
                maxscore = child.score()
        return maxchild

    def best_visited(self):
        maxvisits = -1
        maxchild = None
        for child in self.pos_child:
            #            if child:
            # print to_xy(child.pos), child.wins, child.losses, child.score()
            if child and (child.wins + child.losses) &gt; maxvisits:
                maxvisits, maxchild = (child.wins + child.losses), child
        return maxchild


# def user_move(board):
#     while True:
#         text = input('?').strip()
#         if text == 'p':
#             return PASS
#         if text == 'q':
#             raise EOFError
#         try:
#             x, y = [int(i) for i in text.split()]
#         except ValueError:
#             continue
#         if not (0 &lt;= x &lt; SIZE and 0 &lt;= y &lt; SIZE):
#             continue
#         pos = to_pos(x, y)
#         if board.useful(pos):
#             return pos


def computer_move(board):
    pos = board.random_move()
    if pos == PASS:
        return PASS
    tree = UCTNode()
    tree.unexplored = board.useful_moves()
    nboard = Board()
    for game in range(GAMES):
        node = tree
        nboard.reset()
        nboard.replay(board.history)
        node.play(nboard)
    return tree.best_visited().pos


def versus_cpu():
    for i in range(100):
        random.seed(i)
        board = Board()
        computer_move(board)


if __name__ == "__main__":
    t0 = time()
    versus_cpu()
    t1 = time()
    print(t1 - t0)
</t>
<t tx="ekr.20230509083242.600">// simple name-to-name remappings
static const std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; remapping = {
    // 64-bit float intrinsics
    {"llvm.ceil.f64", "__nv_ceil"},
    {"llvm.floor.f64", "__nv_floor"},
    {"llvm.fabs.f64", "__nv_fabs"},
    {"llvm.exp.f64", "__nv_exp"},
    {"llvm.log.f64", "__nv_log"},
    {"llvm.log2.f64", "__nv_log2"},
    {"llvm.log10.f64", "__nv_log10"},
    {"llvm.sqrt.f64", "__nv_sqrt"},
    {"llvm.pow.f64", "__nv_pow"},
    {"llvm.sin.f64", "__nv_sin"},
    {"llvm.cos.f64", "__nv_cos"},
    {"llvm.copysign.f64", "__nv_copysign"},
    {"llvm.trunc.f64", "__nv_trunc"},
    {"llvm.rint.f64", "__nv_rint"},
    {"llvm.nearbyint.f64", "__nv_nearbyint"},
    {"llvm.round.f64", "__nv_round"},
    {"llvm.minnum.f64", "__nv_fmin"},
    {"llvm.maxnum.f64", "__nv_fmax"},
    {"llvm.copysign.f64", "__nv_copysign"},
    {"llvm.fma.f64", "__nv_fma"},

    // 64-bit float math functions
    {"expm1", "__nv_expm1"},
    {"ldexp", "__nv_ldexp"},
    {"acos", "__nv_acos"},
    {"asin", "__nv_asin"},
    {"atan", "__nv_atan"},
    {"atan2", "__nv_atan2"},
    {"hypot", "__nv_hypot"},
    {"tan", "__nv_tan"},
    {"cosh", "__nv_cosh"},
    {"sinh", "__nv_sinh"},
    {"tanh", "__nv_tanh"},
    {"acosh", "__nv_acosh"},
    {"asinh", "__nv_asinh"},
    {"atanh", "__nv_atanh"},
    {"erf", "__nv_erf"},
    {"erfc", "__nv_erfc"},
    {"tgamma", "__nv_tgamma"},
    {"lgamma", "__nv_lgamma"},
    {"remainder", "__nv_remainder"},
    {"frexp", "__nv_frexp"},
    {"modf", "__nv_modf"},

    // 32-bit float intrinsics
    {"llvm.ceil.f32", "__nv_ceilf"},
    {"llvm.floor.f32", "__nv_floorf"},
    {"llvm.fabs.f32", "__nv_fabsf"},
    {"llvm.exp.f32", "__nv_expf"},
    {"llvm.log.f32", "__nv_logf"},
    {"llvm.log2.f32", "__nv_log2f"},
    {"llvm.log10.f32", "__nv_log10f"},
    {"llvm.sqrt.f32", "__nv_sqrtf"},
    {"llvm.pow.f32", "__nv_powf"},
    {"llvm.sin.f32", "__nv_sinf"},
    {"llvm.cos.f32", "__nv_cosf"},
    {"llvm.copysign.f32", "__nv_copysignf"},
    {"llvm.trunc.f32", "__nv_truncf"},
    {"llvm.rint.f32", "__nv_rintf"},
    {"llvm.nearbyint.f32", "__nv_nearbyintf"},
    {"llvm.round.f32", "__nv_roundf"},
    {"llvm.minnum.f32", "__nv_fminf"},
    {"llvm.maxnum.f32", "__nv_fmaxf"},
    {"llvm.copysign.f32", "__nv_copysignf"},
    {"llvm.fma.f32", "__nv_fmaf"},

    // 32-bit float math functions
    {"expm1f", "__nv_expm1f"},
    {"ldexpf", "__nv_ldexpf"},
    {"acosf", "__nv_acosf"},
    {"asinf", "__nv_asinf"},
    {"atanf", "__nv_atanf"},
    {"atan2f", "__nv_atan2f"},
    {"hypotf", "__nv_hypotf"},
    {"tanf", "__nv_tanf"},
    {"coshf", "__nv_coshf"},
    {"sinhf", "__nv_sinhf"},
    {"tanhf", "__nv_tanhf"},
    {"acoshf", "__nv_acoshf"},
    {"asinhf", "__nv_asinhf"},
    {"atanhf", "__nv_atanhf"},
    {"erff", "__nv_erff"},
    {"erfcf", "__nv_erfcf"},
    {"tgammaf", "__nv_tgammaf"},
    {"lgammaf", "__nv_lgammaf"},
    {"remainderf", "__nv_remainderf"},
    {"frexpf", "__nv_frexpf"},
    {"modff", "__nv_modff"},

    // runtime library functions
    {"seq_free", "free"},
    {"seq_register_finalizer", ""},
    {"seq_gc_add_roots", ""},
    {"seq_gc_remove_roots", ""},
    {"seq_gc_clear_roots", ""},
    {"seq_gc_exclude_static_roots", ""},
};

</t>
<t tx="ekr.20230509083242.601">// functions that need to be generated as they're not available on GPU
static const std::vector&lt;std::pair&lt;std::string, Codegen&gt;&gt; fillins = {
    {"seq_alloc",
     [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
       auto *M = B.GetInsertBlock()-&gt;getModule();
       llvm::Value *mem = B.CreateCall(makeMalloc(M), args[0]);
       B.CreateRet(mem);
     }},

    {"seq_alloc_atomic",
     [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
       auto *M = B.GetInsertBlock()-&gt;getModule();
       llvm::Value *mem = B.CreateCall(makeMalloc(M), args[0]);
       B.CreateRet(mem);
     }},

    {"seq_realloc",
     [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
       auto *M = B.GetInsertBlock()-&gt;getModule();
       llvm::Value *mem = B.CreateCall(makeMalloc(M), args[1]);
    @others
    {"seq_throw",
     [](llvm::IRBuilder&lt;&gt; &amp;B,
        const std::vector&lt;llvm::Value *&gt; &amp;args) { B.CreateUnreachable(); }},
};

</t>
<t tx="ekr.20230509083242.602">   auto F = llvm::Intrinsic::getDeclaration(
       M, llvm::Intrinsic::memcpy,
       {B.getInt8PtrTy(), B.getInt8PtrTy(), B.getInt64Ty()});
   B.CreateCall(F, {mem, args[0], args[2], B.getFalse()});
   B.CreateRet(mem);
 }},

{"seq_calloc",
 [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
   auto *M = B.GetInsertBlock()-&gt;getModule();
   llvm::Value *size = B.CreateMul(args[0], args[1]);
   llvm::Value *mem = B.CreateCall(makeMalloc(M), size);
   auto F = llvm::Intrinsic::getDeclaration(M, llvm::Intrinsic::memset,
                                            {B.getInt8PtrTy(), B.getInt64Ty()});
   B.CreateCall(F, {mem, B.getInt8(0), size, B.getFalse()});
   B.CreateRet(mem);
 }},

</t>
<t tx="ekr.20230509083242.603">{"seq_calloc_atomic",
 [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
   auto *M = B.GetInsertBlock()-&gt;getModule();
   llvm::Value *size = B.CreateMul(args[0], args[1]);
   llvm::Value *mem = B.CreateCall(makeMalloc(M), size);
   auto F = llvm::Intrinsic::getDeclaration(M, llvm::Intrinsic::memset,
                                            {B.getInt8PtrTy(), B.getInt64Ty()});
   B.CreateCall(F, {mem, B.getInt8(0), size, B.getFalse()});
   B.CreateRet(mem);
 }},

</t>
<t tx="ekr.20230509083242.604">{"seq_alloc_exc",
 [](llvm::IRBuilder&lt;&gt; &amp;B, const std::vector&lt;llvm::Value *&gt; &amp;args) {
   // TODO: print error message and abort if in debug mode
   B.CreateUnreachable();
 }},

</t>
<t tx="ekr.20230509083242.605">void exploreGV(llvm::GlobalValue *G, llvm::SmallPtrSetImpl&lt;llvm::GlobalValue *&gt; &amp;keep) {
  if (keep.contains(G))
    return;

  keep.insert(G);
  if (auto *F = llvm::dyn_cast&lt;llvm::Function&gt;(G)) {
    for (auto I = llvm::inst_begin(F), E = inst_end(F); I != E; ++I) {
      for (auto &amp;U : I-&gt;operands()) {
        if (auto *G2 = llvm::dyn_cast&lt;llvm::GlobalValue&gt;(U.get()))
          exploreGV(G2, keep);
      }
    }
  }
}

</t>
<t tx="ekr.20230509083242.606">std::vector&lt;llvm::GlobalValue *&gt;
getRequiredGVs(const std::vector&lt;llvm::GlobalValue *&gt; &amp;kernels) {
  llvm::SmallPtrSet&lt;llvm::GlobalValue *, 32&gt; keep;
  for (auto *G : kernels) {
    exploreGV(G, keep);
  }
  return std::vector&lt;llvm::GlobalValue *&gt;(keep.begin(), keep.end());
}

</t>
<t tx="ekr.20230509083242.607">void moduleToPTX(llvm::Module *M, const std::string &amp;filename,
                 std::vector&lt;llvm::GlobalValue *&gt; &amp;kernels,
  @others
</t>
<t tx="ekr.20230509083242.608">               const std::string &amp;cpuStr = "sm_30",
@others
</t>
<t tx="ekr.20230509083242.609">               const std::string &amp;featuresStr = "+ptx42") {
llvm::Triple triple(llvm::Triple::normalize(GPU_TRIPLE));
llvm::TargetLibraryInfoImpl tlii(triple);

std::string err;
const llvm::Target *target =
    llvm::TargetRegistry::lookupTarget("nvptx64", triple, err);
seqassertn(target, "couldn't lookup target: {}", err);

const llvm::TargetOptions options =
    llvm::codegen::InitTargetOptionsFromCodeGenFlags(triple);

std::unique_ptr&lt;llvm::TargetMachine&gt; machine(target-&gt;createTargetMachine(
    triple.getTriple(), cpuStr, featuresStr, options,
    llvm::codegen::getExplicitRelocModel(), llvm::codegen::getExplicitCodeModel(),
    llvm::CodeGenOpt::Aggressive));

M-&gt;setDataLayout(machine-&gt;createDataLayout());
auto keep = getRequiredGVs(kernels);

@others
// Remove non-kernel functions.
prune(keep);

// Link libdevice and other cleanup.
linkLibdevice(M, libdevice);
remapFunctions(M);

// Run NVPTX passes and general opt pipeline.
{
  llvm::LoopAnalysisManager lam;
  llvm::FunctionAnalysisManager fam;
  llvm::CGSCCAnalysisManager cgam;
  llvm::ModuleAnalysisManager mam;
  llvm::PassBuilder pb(machine.get());

  llvm::TargetLibraryInfoImpl tlii(triple);
  fam.registerPass([&amp;] { return llvm::TargetLibraryAnalysis(tlii); });

  pb.registerModuleAnalyses(mam);
  pb.registerCGSCCAnalyses(cgam);
  pb.registerFunctionAnalyses(fam);
  pb.registerLoopAnalyses(lam);
  pb.crossRegisterProxies(lam, fam, cgam, mam);

  pb.registerPipelineStartEPCallback(
      [&amp;](llvm::ModulePassManager &amp;pm, llvm::OptimizationLevel opt) {
        pm.addPass(llvm::InternalizePass([&amp;](const llvm::GlobalValue &amp;gv) {
          return std::find(keep.begin(), keep.end(), &amp;gv) != keep.end();
        }));
      });

  llvm::ModulePassManager mpm =
      pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O3);
  mpm.run(*M, mam);
}

// Prune again after optimizations.
keep = getRequiredGVs(kernels);
prune(keep);

// Clean up names.
{
  for (auto &amp;G : M-&gt;globals()) {
    G.setName(cleanUpName(G.getName()));
  }

  for (auto &amp;F : M-&gt;functions()) {
    if (F.getInstructionCount() &gt; 0)
      F.setName(cleanUpName(F.getName()));
  }

  for (auto *S : M-&gt;getIdentifiedStructTypes()) {
    S-&gt;setName(cleanUpName(S-&gt;getName()));
  }
}

// Generate PTX file.
{
  std::error_code errcode;
  auto out = std::make_unique&lt;llvm::ToolOutputFile&gt;(filename, errcode,
                                                    llvm::sys::fs::OF_Text);
  if (errcode)
    compilationError(errcode.message());
  llvm::raw_pwrite_stream *os = &amp;out-&gt;os();

  auto &amp;llvmtm = static_cast&lt;llvm::LLVMTargetMachine &amp;&gt;(*machine);
  auto *mmiwp = new llvm::MachineModuleInfoWrapperPass(&amp;llvmtm);
  llvm::legacy::PassManager pm;

  pm.add(new llvm::TargetLibraryInfoWrapperPass(tlii));
  seqassertn(!machine-&gt;addPassesToEmitFile(pm, *os, nullptr, llvm::CGFT_AssemblyFile,
                                           /*DisableVerify=*/false, mmiwp),
             "could not add passes");
</t>
<t tx="ekr.20230509083242.61">@path C:/Repos/codon/bench/go/
"""
Go board game
"""
import math
import random
from time import time

SIZE = 9
GAMES = 200
KOMI = 7.5
EMPTY, WHITE, BLACK = 0, 1, 2
SHOW = {EMPTY: '.', WHITE: 'o', BLACK: 'x'}
PASS = -1
MAXMOVES = SIZE * SIZE * 3
TIMESTAMP = 0
MOVES = 0


@others
if __name__ == "__main__":
    t0 = time()
    versus_cpu()
    t1 = time()
    print(t1 - t0)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083242.610">auto prune = [&amp;](std::vector&lt;llvm::GlobalValue *&gt; keep) {
  llvm::LoopAnalysisManager lam;
  llvm::FunctionAnalysisManager fam;
  llvm::CGSCCAnalysisManager cgam;
  llvm::ModuleAnalysisManager mam;
  llvm::ModulePassManager mpm;
  llvm::PassBuilder pb;

  pb.registerModuleAnalyses(mam);
  pb.registerCGSCCAnalyses(cgam);
  pb.registerFunctionAnalyses(fam);
  pb.registerLoopAnalyses(lam);
  pb.crossRegisterProxies(lam, fam, cgam, mam);

  mpm.addPass(GVExtractor(keep, false));
  mpm.addPass(llvm::GlobalDCEPass());
  mpm.addPass(llvm::StripDeadDebugInfoPass());
  mpm.addPass(llvm::StripDeadPrototypesPass());
  mpm.run(*M, mam);
};

</t>
<t tx="ekr.20230509083242.611">    const_cast&lt;llvm::TargetLoweringObjectFile *&gt;(llvmtm.getObjFileLowering())
        -&gt;Initialize(mmiwp-&gt;getMMI().getContext(), *machine);
    pm.run(*M);
    out-&gt;keep();
  }
}

  @others
</t>
<t tx="ekr.20230509083242.612">void addInitCall(llvm::Module *M, const std::string &amp;filename) {
llvm::LLVMContext &amp;context = M-&gt;getContext();
auto f =
    M-&gt;getOrInsertFunction("seq_nvptx_load_module", llvm::Type::getVoidTy(context),
                           llvm::Type::getInt8PtrTy(context));
auto *g = llvm::cast&lt;llvm::Function&gt;(f.getCallee());
g-&gt;setDoesNotThrow();

auto *filenameVar = new llvm::GlobalVariable(
    *M, llvm::ArrayType::get(llvm::Type::getInt8Ty(context), filename.length() + 1),
    /*isConstant=*/true, llvm::GlobalValue::PrivateLinkage,
    llvm::ConstantDataArray::getString(context, filename), ".nvptx.filename");
filenameVar-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
llvm::IRBuilder&lt;&gt; B(context);

if (auto *init = M-&gt;getFunction("seq_init")) {
  seqassertn(init-&gt;hasOneUse(), "seq_init used more than once");
  auto *use = llvm::dyn_cast&lt;llvm::CallBase&gt;(init-&gt;use_begin()-&gt;getUser());
  seqassertn(use, "seq_init use was not a call");
  B.SetInsertPoint(use-&gt;getNextNode());
  B.CreateCall(g, B.CreateBitCast(filenameVar, B.getInt8PtrTy()));
}

for (auto &amp;F : M-&gt;functions()) {
  if (F.hasFnAttribute("jit")) {
    B.SetInsertPoint(F.getEntryBlock().getFirstNonPHI());
    B.CreateCall(g, B.CreateBitCast(filenameVar, B.getInt8PtrTy()));
  }
}
}

</t>
<t tx="ekr.20230509083242.613">void cleanUpIntrinsics(llvm::Module *M) {
  llvm::LLVMContext &amp;context = M-&gt;getContext();
  llvm::SmallVector&lt;llvm::Function *, 16&gt; remove;
  for (auto &amp;F : *M) {
    if (F.getIntrinsicID() != llvm::Intrinsic::not_intrinsic &amp;&amp;
        F.getName().startswith("llvm.nvvm"))
      remove.push_back(&amp;F);
  }

  for (auto *F : remove) {
    F-&gt;replaceAllUsesWith(makeNoOp(F));
    F-&gt;dropAllReferences();
    F-&gt;eraseFromParent();
  }
}
</t>
<t tx="ekr.20230509083242.614">} // namespace

</t>
<t tx="ekr.20230509083242.615">void applyGPUTransformations(llvm::Module *M, const std::string &amp;ptxFilename) {
  llvm::LLVMContext &amp;context = M-&gt;getContext();
  std::unique_ptr&lt;llvm::Module&gt; clone = llvm::CloneModule(*M);
  clone-&gt;setTargetTriple(llvm::Triple::normalize(GPU_TRIPLE));
  clone-&gt;setDataLayout(GPU_DL);

  llvm::NamedMDNode *nvvmAnno = clone-&gt;getOrInsertNamedMetadata("nvvm.annotations");
  std::vector&lt;llvm::GlobalValue *&gt; kernels;

  for (auto &amp;F : *clone) {
    if (!F.hasFnAttribute("kernel"))
      continue;

    llvm::Metadata *nvvmElem[] = {
        llvm::ConstantAsMetadata::get(&amp;F),
        llvm::MDString::get(context, "kernel"),
        llvm::ConstantAsMetadata::get(
            llvm::ConstantInt::get(llvm::Type::getInt32Ty(context), 1)),
    };

    nvvmAnno-&gt;addOperand(llvm::MDNode::get(context, nvvmElem));
    kernels.push_back(&amp;F);
  }

  if (kernels.empty())
    return;

  std::string filename = ptxFilename.empty() ? M-&gt;getSourceFileName() : ptxFilename;
  if (filename.empty() || filename[0] == '&lt;')
    filename = "kernel";
  llvm::SmallString&lt;128&gt; path(filename);
  llvm::sys::path::replace_extension(path, "ptx");
  filename = path.str();

  moduleToPTX(clone.get(), filename, kernels);
  cleanUpIntrinsics(M);
  addInitCall(M, filename);
}

</t>
<t tx="ekr.20230509083242.616">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {
namespace ir {

/// Applies GPU-specific transformations and generates PTX
/// code from kernel functions in the given LLVM module.
/// @param module LLVM module containing GPU kernel functions (marked with "kernel"
/// annotation)
/// @param ptxFilename Filename for output PTX code; empty to use filename based on
/// module
void applyGPUTransformations(llvm::Module *module, const std::string &amp;ptxFilename = "");

} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.617">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "llvisitor.h"

#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;cstdlib&gt;
#include &lt;fmt/args.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
#include &lt;utility&gt;

#include "codon/cir/dsl/codegen.h"
#include "codon/cir/llvm/optimize.h"
#include "codon/cir/util/irtools.h"
#include "codon/compiler/debug_listener.h"
#include "codon/compiler/memory_manager.h"
#include "codon/parser/common.h"
#include "codon/runtime/lib.h"
#include "codon/util/common.h"

namespace codon {
namespace ir {
namespace {
const std::string EXPORT_ATTR = "std.internal.attributes.export";
const std::string INLINE_ATTR = "std.internal.attributes.inline";
const std::string NOINLINE_ATTR = "std.internal.attributes.noinline";
const std::string GPU_KERNEL_ATTR = "std.gpu.kernel";
} // namespace

llvm::DIFile *LLVMVisitor::DebugInfo::getFile(const std::string &amp;path) {
  std::string filename;
  std::string directory;
  auto pos = path.find_last_of("/");
  if (pos != std::string::npos) {
    filename = path.substr(pos + 1);
    directory = path.substr(0, pos);
  } else {
    filename = path;
    directory = ".";
  }
  return builder-&gt;createFile(filename, directory);
}

std::string LLVMVisitor::getNameForFunction(const Func *x) {
  if (isA&lt;ExternalFunc&gt;(x) || util::hasAttribute(x, EXPORT_ATTR)) {
    return x-&gt;getUnmangledName();
  } else if (util::hasAttribute(x, GPU_KERNEL_ATTR)) {
    return x-&gt;getName();
  } else {
    return x-&gt;referenceString();
  }
}

std::string LLVMVisitor::getNameForVar(const Var *x) {
  if (auto *f = cast&lt;Func&gt;(x))
    return getNameForFunction(f);

  if (x-&gt;isExternal()) {
    return x-&gt;getName();
  } else {
    return "." + x-&gt;getName();
  }
}

LLVMVisitor::LLVMVisitor()
    : util::ConstVisitor(), context(std::make_unique&lt;llvm::LLVMContext&gt;()), M(),
      B(std::make_unique&lt;llvm::IRBuilder&lt;&gt;&gt;(*context)), func(nullptr), block(nullptr),
      value(nullptr), vars(), funcs(), coro(), loops(), trycatch(), catches(), db(),
      plugins(nullptr) {
  llvm::InitializeAllTargets();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllAsmPrinters();
  llvm::InitializeAllAsmParsers();

  // Initialize passes
  auto &amp;registry = *llvm::PassRegistry::getPassRegistry();
  llvm::initializeCore(registry);
  llvm::initializeScalarOpts(registry);
  llvm::initializeObjCARCOpts(registry);
  llvm::initializeVectorization(registry);
  llvm::initializeIPO(registry);
  llvm::initializeAnalysis(registry);
  llvm::initializeTransformUtils(registry);
  llvm::initializeInstCombine(registry);
  llvm::initializeAggressiveInstCombine(registry);
  llvm::initializeInstrumentation(registry);
  llvm::initializeTarget(registry);

  llvm::initializeExpandMemCmpPassPass(registry);
  llvm::initializeScalarizeMaskedMemIntrinLegacyPassPass(registry);
  llvm::initializeSelectOptimizePass(registry);
  llvm::initializeCodeGenPreparePass(registry);
  llvm::initializeAtomicExpandPass(registry);
  llvm::initializeRewriteSymbolsLegacyPassPass(registry);
  llvm::initializeWinEHPreparePass(registry);
  llvm::initializeDwarfEHPrepareLegacyPassPass(registry);
  llvm::initializeSafeStackLegacyPassPass(registry);
  llvm::initializeSjLjEHPreparePass(registry);
  llvm::initializePreISelIntrinsicLoweringLegacyPassPass(registry);
  llvm::initializeGlobalMergePass(registry);
  llvm::initializeIndirectBrExpandPassPass(registry);
  llvm::initializeInterleavedLoadCombinePass(registry);
  llvm::initializeInterleavedAccessPass(registry);
  llvm::initializeUnreachableBlockElimLegacyPassPass(registry);
  llvm::initializeExpandReductionsPass(registry);
  llvm::initializeExpandVectorPredicationPass(registry);
  llvm::initializeWasmEHPreparePass(registry);
  llvm::initializeWriteBitcodePassPass(registry);
  llvm::initializeHardwareLoopsPass(registry);
  llvm::initializeTypePromotionPass(registry);
  llvm::initializeReplaceWithVeclibLegacyPass(registry);
  llvm::initializeJMCInstrumenterPass(registry);
}

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.618">void LLVMVisitor::registerGlobal(const Var *var) {
  if (!var-&gt;isGlobal())
    return;

  if (auto *f = cast&lt;Func&gt;(var)) {
    insertFunc(f, makeLLVMFunction(f));
  } else {
    llvm::Type *llvmType = getLLVMType(var-&gt;getType());
    if (llvmType-&gt;isVoidTy()) {
      insertVar(var, getDummyVoidValue());
    } else {
      bool external = var-&gt;isExternal();
  @others
    }
  }
}

</t>
<t tx="ekr.20230509083242.619">    auto linkage = (db.jit || external) ? llvm::GlobalValue::ExternalLinkage
                                        : llvm::GlobalValue::PrivateLinkage;
    auto *storage = new llvm::GlobalVariable(
        *M, llvmType, /*isConstant=*/false, linkage,
      @others
</t>
<t tx="ekr.20230509083242.62">def to_pos(x, y):
    return y * SIZE + x


</t>
<t tx="ekr.20230509083242.620">  external ? nullptr : llvm::Constant::getNullValue(llvmType),
  getNameForVar(var));
      insertVar(var, storage);

      if (external) {
if (db.jit) {
  storage-&gt;setDSOLocal(true);
} else {
  storage-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Local);
}
      } else {
// debug info
auto *srcInfo = getSrcInfo(var);
llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
llvm::DIScope *scope = db.unit;
llvm::DIGlobalVariableExpression *debugVar =
    db.builder-&gt;createGlobalVariableExpression(
        scope, getDebugNameForVariable(var), var-&gt;getName(), file,
        srcInfo-&gt;line, getDIType(var-&gt;getType()), !var-&gt;isExternal());
storage-&gt;addDebugInfo(debugVar);
      }
</t>
<t tx="ekr.20230509083242.621">llvm::Value *LLVMVisitor::getVar(const Var *var) {
  auto it = vars.find(var-&gt;getId());
  if (db.jit &amp;&amp; var-&gt;isGlobal()) {
    if (it != vars.end()) {
      if (!it-&gt;second) { // if value is null, it's from another module
        // see if it's in the module already
        auto name = var-&gt;getName();
        auto privName = getNameForVar(var);
        if (auto *global = M-&gt;getNamedValue(privName))
          return global;

        llvm::Type *llvmType = getLLVMType(var-&gt;getType());
        auto *storage = new llvm::GlobalVariable(*M, llvmType, /*isConstant=*/false,
                                                 llvm::GlobalValue::ExternalLinkage,
                                                 /*Initializer=*/nullptr, privName);
        storage-&gt;setExternallyInitialized(true);

        // debug info
        auto *srcInfo = getSrcInfo(var);
        llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
        llvm::DIScope *scope = db.unit;
        llvm::DIGlobalVariableExpression *debugVar =
            db.builder-&gt;createGlobalVariableExpression(
                scope, getDebugNameForVariable(var), name, file, srcInfo-&gt;line,
                getDIType(var-&gt;getType()),
                /*IsLocalToUnit=*/true);
        storage-&gt;addDebugInfo(debugVar);
        insertVar(var, storage);
        return storage;
      }
    } else {
      registerGlobal(var);
      it = vars.find(var-&gt;getId());
      return it-&gt;second;
    }
  }
  return (it != vars.end()) ? it-&gt;second : nullptr;
}

llvm::Function *LLVMVisitor::getFunc(const Func *func) {
  auto it = funcs.find(func-&gt;getId());
  if (db.jit) {
    if (it != funcs.end()) {
      if (!it-&gt;second) { // if value is null, it's from another module
        // see if it's in the module already
        const std::string name = getNameForFunction(func);
        if (auto *g = M-&gt;getFunction(name))
          return g;

        auto *funcType = cast&lt;types::FuncType&gt;(func-&gt;getType());
        llvm::Type *returnType = getLLVMType(funcType-&gt;getReturnType());
        std::vector&lt;llvm::Type *&gt; argTypes;
        for (const auto &amp;argType : *funcType) {
          argTypes.push_back(getLLVMType(argType));
        }

        auto *llvmFuncType =
            llvm::FunctionType::get(returnType, argTypes, funcType-&gt;isVariadic());
        auto *g = llvm::Function::Create(llvmFuncType, llvm::Function::ExternalLinkage,
                                         name, M.get());
        insertFunc(func, g);
        return g;
      }
    } else {
      registerGlobal(func);
      it = funcs.find(func-&gt;getId());
      return it-&gt;second;
    }
  }
  return (it != funcs.end()) ? it-&gt;second : nullptr;
}

std::unique_ptr&lt;llvm::Module&gt; LLVMVisitor::makeModule(llvm::LLVMContext &amp;context,
</t>
<t tx="ekr.20230509083242.622">                                                      const SrcInfo *src) {
  auto builder = llvm::EngineBuilder();
  builder.setMArch(llvm::codegen::getMArch());
  builder.setMCPU(llvm::codegen::getCPUStr());
  builder.setMAttrs(llvm::codegen::getFeatureList());

  auto target = builder.selectTarget();
  auto M = std::make_unique&lt;llvm::Module&gt;("codon", context);
  M-&gt;setTargetTriple(target-&gt;getTargetTriple().str());
  M-&gt;setDataLayout(target-&gt;createDataLayout());
  B = std::make_unique&lt;llvm::IRBuilder&lt;&gt;&gt;(context);

  auto *srcInfo = src ? src : getDefaultSrcInfo();
  M-&gt;setSourceFileName(srcInfo-&gt;file);
  // debug info setup
  db.builder = std::make_unique&lt;llvm::DIBuilder&gt;(*M);
  llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
  db.unit = db.builder-&gt;createCompileUnit(llvm::dwarf::DW_LANG_C, file,
                                          ("codon version " CODON_VERSION), !db.debug,
                                          db.flags,
                                          /*RV=*/0);
  M-&gt;addModuleFlag(llvm::Module::Warning, "Debug Info Version",
                   llvm::DEBUG_METADATA_VERSION);
  // darwin only supports dwarf2
  if (llvm::Triple(M-&gt;getTargetTriple()).isOSDarwin()) {
    M-&gt;addModuleFlag(llvm::Module::Warning, "Dwarf Version", 2);
  }

  return M;
}

</t>
<t tx="ekr.20230509083242.623">void LLVMVisitor::clearLLVMData() {
  B = {};
  func = nullptr;
  block = nullptr;
  value = nullptr;

  for (auto it = funcs.begin(); it != funcs.end();) {
    if (it-&gt;second &amp;&amp; it-&gt;second-&gt;hasPrivateLinkage()) {
      it = funcs.erase(it);
    } else {
      it-&gt;second = nullptr;
      ++it;
    }
  }

  for (auto it = vars.begin(); it != vars.end();) {
    if (it-&gt;second &amp;&amp; !llvm::isa&lt;llvm::GlobalValue&gt;(it-&gt;second)) {
      it = vars.erase(it);
    } else {
      it-&gt;second = nullptr;
      ++it;
    }
  }

  coro.reset();
  loops.clear();
  trycatch.clear();
  catches.clear();
  db.reset();
  context = {};
  M = {};
}

</t>
<t tx="ekr.20230509083242.624">std::pair&lt;std::unique_ptr&lt;llvm::Module&gt;, std::unique_ptr&lt;llvm::LLVMContext&gt;&gt;
LLVMVisitor::takeModule(Module *module, const SrcInfo *src) {
  // process any new functions or globals
  if (module) {
    std::unordered_set&lt;id_t&gt; funcsToProcess;
    for (auto *var : *module) {
      auto id = var-&gt;getId();
      if (auto *func = cast&lt;Func&gt;(var)) {
        if (funcs.find(id) != funcs.end())
          continue;
        else
          funcsToProcess.insert(id);
      } else {
        if (vars.find(id) != vars.end())
          continue;
      }

      registerGlobal(var);
    }

    for (auto *var : *module) {
      if (auto *func = cast&lt;Func&gt;(var)) {
        if (funcsToProcess.find(func-&gt;getId()) != funcsToProcess.end()) {
          process(func);
        }
      }
    }
  }

  db.builder-&gt;finalize();
  auto currentContext = std::move(context);
  auto currentModule = std::move(M);

  // reset all LLVM fields/data -- they are owned by the context
  clearLLVMData();
  context = std::make_unique&lt;llvm::LLVMContext&gt;();
  M = makeModule(*context, src);
  return {std::move(currentModule), std::move(currentContext)};
}

</t>
<t tx="ekr.20230509083242.625">void LLVMVisitor::setDebugInfoForNode(const Node *x) {
  if (x &amp;&amp; func) {
    auto *srcInfo = getSrcInfo(x);
    B-&gt;SetCurrentDebugLocation(llvm::DILocation::get(
        *context, srcInfo-&gt;line, srcInfo-&gt;col, func-&gt;getSubprogram()));
  } else {
    B-&gt;SetCurrentDebugLocation(llvm::DebugLoc());
  }
}

</t>
<t tx="ekr.20230509083242.626">void LLVMVisitor::process(const Node *x) {
  setDebugInfoForNode(x);
  x-&gt;accept(*this);
}

</t>
<t tx="ekr.20230509083242.627">void LLVMVisitor::dump(const std::string &amp;filename) { writeToLLFile(filename, false); }

</t>
<t tx="ekr.20230509083242.628">void LLVMVisitor::runLLVMPipeline() {
  db.builder-&gt;finalize();
  optimize(M.get(), db.debug, db.jit, plugins);
}

</t>
<t tx="ekr.20230509083242.629">void LLVMVisitor::writeToObjectFile(const std::string &amp;filename, bool pic) {
  runLLVMPipeline();

  std::error_code err;
  auto out =
      std::make_unique&lt;llvm::ToolOutputFile&gt;(filename, err, llvm::sys::fs::OF_None);
  if (err)
    compilationError(err.message());
  llvm::raw_pwrite_stream *os = &amp;out-&gt;os();

  auto machine = getTargetMachine(M.get(), /*setFunctionAttributes=*/false, pic);
  auto &amp;llvmtm = static_cast&lt;llvm::LLVMTargetMachine &amp;&gt;(*machine);
  auto *mmiwp = new llvm::MachineModuleInfoWrapperPass(&amp;llvmtm);
  llvm::legacy::PassManager pm;

  llvm::TargetLibraryInfoImpl tlii(llvm::Triple(M-&gt;getTargetTriple()));
  pm.add(new llvm::TargetLibraryInfoWrapperPass(tlii));
  seqassertn(!machine-&gt;addPassesToEmitFile(pm, *os, nullptr, llvm::CGFT_ObjectFile,
                                           /*DisableVerify=*/true, mmiwp),
             "could not add passes");
  const_cast&lt;llvm::TargetLoweringObjectFile *&gt;(llvmtm.getObjFileLowering())
      -&gt;Initialize(mmiwp-&gt;getMMI().getContext(), *machine);
  pm.run(*M);
  out-&gt;keep();
}

</t>
<t tx="ekr.20230509083242.63">def to_xy(pos):
    y, x = divmod(pos, SIZE)
    return x, y


</t>
<t tx="ekr.20230509083242.630">void LLVMVisitor::writeToBitcodeFile(const std::string &amp;filename) {
  @others
</t>
<t tx="ekr.20230509083242.631">runLLVMPipeline();
std::error_code err;
llvm::raw_fd_ostream stream(filename, err, llvm::sys::fs::OF_None);
llvm::WriteBitcodeToFile(*M, stream);
if (err) {
  compilationError(err.message());
}
}

</t>
<t tx="ekr.20230509083242.632">void LLVMVisitor::writeToLLFile(const std::string &amp;filename, bool optimize) {
  if (optimize)
    runLLVMPipeline();
  auto fo = fopen(filename.c_str(), "w");
  llvm::raw_fd_ostream fout(fileno(fo), true);
  fout &lt;&lt; *M;
  fout.close();
}

</t>
<t tx="ekr.20230509083242.633">namespace {
</t>
<t tx="ekr.20230509083242.634">void executeCommand(const std::vector&lt;std::string&gt; &amp;args) {
  std::vector&lt;const char *&gt; cArgs;
  for (auto &amp;arg : args) {
    cArgs.push_back(arg.c_str());
  }
  LOG_USER("Executing '{}'", fmt::join(cArgs, " "));
  cArgs.push_back(nullptr);

  if (fork() == 0) {
    int status = execvp(cArgs[0], (char *const *)&amp;cArgs[0]);
    exit(status);
  } else {
    int status;
    if (wait(&amp;status) &lt; 0) {
      compilationError("process for '" + args[0] + "' encountered an error in wait");
    }

    if (WEXITSTATUS(status) != 0) {
      compilationError("process for '" + args[0] + "' exited with status " +
                       std::to_string(WEXITSTATUS(status)));
    }
  }
}
</t>
<t tx="ekr.20230509083242.635">} // namespace

</t>
<t tx="ekr.20230509083242.636">void LLVMVisitor::setupGlobalCtorForSharedLibrary() {
  const std::string llvmCtor = "llvm.global_ctors";
  auto *main = M-&gt;getFunction("main");
  if (M-&gt;getNamedValue(llvmCtor) || !main)
    return;
  main-&gt;setName(".main"); // avoid clash with other main

  auto *ctorFuncTy = llvm::FunctionType::get(B-&gt;getVoidTy(), {}, /*isVarArg=*/false);
  auto *ctorEntryTy = llvm::StructType::get(B-&gt;getInt32Ty(), ctorFuncTy-&gt;getPointerTo(),
                                            B-&gt;getInt8PtrTy());
  auto *ctorArrayTy = llvm::ArrayType::get(ctorEntryTy, 1);

  auto *ctor = cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction(".main.ctor", ctorFuncTy).getCallee());
  ctor-&gt;setLinkage(llvm::GlobalValue::InternalLinkage);
  auto *entry = llvm::BasicBlock::Create(*context, "entry", ctor);
  B-&gt;SetInsertPoint(entry);
  B-&gt;CreateCall({main-&gt;getFunctionType(), main},
                {B-&gt;getInt32(0),
                 llvm::ConstantPointerNull::get(B-&gt;getInt8PtrTy()-&gt;getPointerTo())});
  B-&gt;CreateRetVoid();

  const int priority = 65535; // default
  auto *ctorEntry = llvm::ConstantStruct::get(
      ctorEntryTy,
      {B-&gt;getInt32(priority), ctor, llvm::ConstantPointerNull::get(B-&gt;getInt8PtrTy())});
  new llvm::GlobalVariable(*M, ctorArrayTy,
                           /*isConstant=*/true, llvm::GlobalValue::AppendingLinkage,
                           llvm::ConstantArray::get(ctorArrayTy, {ctorEntry}),
                           llvmCtor);
}

</t>
<t tx="ekr.20230509083242.637">void LLVMVisitor::writeToExecutable(const std::string &amp;filename,
  @others
</t>
<t tx="ekr.20230509083242.638">                                  const std::string &amp;argv0, bool library,
@others
</t>
<t tx="ekr.20230509083242.639">                                  const std::vector&lt;std::string&gt; &amp;libs,
@others
</t>
<t tx="ekr.20230509083242.64">class Square:

    @others
</t>
<t tx="ekr.20230509083242.640">                                  const std::string &amp;lflags) {
if (library)
  setupGlobalCtorForSharedLibrary();

const std::string objFile = filename + ".o";
writeToObjectFile(objFile, /*pic=*/library);

const std::string base = ast::executable_path(argv0.c_str());
auto path = llvm::SmallString&lt;128&gt;(llvm::sys::path::parent_path(base));

std::vector&lt;std::string&gt; relatives = {"../lib", "../lib/codon"};
std::vector&lt;std::string&gt; rpaths;
for (const auto &amp;rel : relatives) {
  auto newPath = path;
  llvm::sys::path::append(newPath, rel);
  llvm::sys::path::remove_dots(newPath, /*remove_dot_dot=*/true);
  if (llvm::sys::fs::exists(newPath)) {
    rpaths.push_back(std::string(newPath));
  }
}

if (rpaths.empty()) {
  rpaths.push_back(std::string(path));
}

std::vector&lt;std::string&gt; command = {"g++"};
// Avoid "argument unused during compilation" warning
command.push_back("-Wno-unused-command-line-argument");
// MUST go before -llib to compile on Linux
command.push_back(objFile);

if (library)
  command.push_back("-shared");

for (const auto &amp;rpath : rpaths) {
  if (!rpath.empty()) {
    command.push_back("-L" + rpath);
    command.push_back("-Wl,-rpath," + rpath);
  }
}

if (plugins) {
  for (auto *plugin : *plugins) {
    auto dylibPath = plugin-&gt;info.dylibPath;
    if (dylibPath.empty())
      continue;

    llvm::SmallString&lt;128&gt; rpath0 = llvm::sys::path::parent_path(dylibPath);
    llvm::sys::fs::make_absolute(rpath0);
    llvm::StringRef rpath = rpath0.str();
    if (!rpath.empty()) {
      command.push_back("-L" + rpath.str());
      command.push_back("-Wl,-rpath," + rpath.str());
    }
  }
}

for (const auto &amp;lib : libs) {
  command.push_back("-l" + lib);
}

if (plugins) {
  for (auto *plugin : *plugins) {
    if (plugin-&gt;info.linkArgs.empty()) {
      auto dylibPath = plugin-&gt;info.dylibPath;
      if (dylibPath.empty())
        continue;

      auto stem = llvm::sys::path::stem(dylibPath);
      if (stem.startswith("lib"))
        stem = stem.substr(3);

      command.push_back("-l" + stem.str());
    } else {
      for (auto &amp;l : plugin-&gt;info.linkArgs)
        command.push_back(l);
    }
  }
}

std::vector&lt;std::string&gt; extraArgs = {
    "-lcodonrt", "-lomp", "-lpthread", "-ldl", "-lz", "-lm", "-lc", "-o", filename};

for (const auto &amp;arg : extraArgs) {
  command.push_back(arg);
}

llvm::SmallVector&lt;llvm::StringRef&gt; userFlags(16);
llvm::StringRef(lflags).split(userFlags, " ", /*MaxSplit=*/-1, /*KeepEmpty=*/false);

for (const auto &amp;uflag : userFlags) {
  if (!uflag.empty())
    command.push_back(uflag.str());
}

// Avoid "relocation R_X86_64_32 against `.bss' can not be used when making a PIE
// object" complaints by gcc when it is built with --enable-default-pie
if (!library)
  command.push_back("-no-pie");

executeCommand(command);

#if __APPLE__
if (db.debug)
  executeCommand({"dsymutil", filename});
#endif

llvm::sys::fs::remove(objFile);
}

</t>
<t tx="ekr.20230509083242.641">namespace {
// https://github.com/python/cpython/blob/main/Include/methodobject.h
constexpr int PYEXT_METH_VARARGS = 0x0001;
constexpr int PYEXT_METH_KEYWORDS = 0x0002;
constexpr int PYEXT_METH_NOARGS = 0x0004;
constexpr int PYEXT_METH_O = 0x0008;
constexpr int PYEXT_METH_CLASS = 0x0010;
constexpr int PYEXT_METH_STATIC = 0x0020;
constexpr int PYEXT_METH_COEXIST = 0x0040;
constexpr int PYEXT_METH_FASTCALL = 0x0080;
constexpr int PYEXT_METH_METHOD = 0x0200;
// https://github.com/python/cpython/blob/main/Include/modsupport.h
constexpr int PYEXT_PYTHON_ABI_VERSION = 1013;
// https://github.com/python/cpython/blob/main/Include/descrobject.h
constexpr int PYEXT_READONLY = 1;
} // namespace

llvm::Function *LLVMVisitor::createPyTryCatchWrapper(llvm::Function *func) {
  auto *wrap =
      cast&lt;llvm::Function&gt;(M-&gt;getOrInsertFunction((func-&gt;getName() + ".tc_wrap").str(),
                                                  func-&gt;getFunctionType())
                               .getCallee());
  wrap-&gt;setPersonalityFn(llvm::cast&lt;llvm::Constant&gt;(makePersonalityFunc().getCallee()));
  auto *entry = llvm::BasicBlock::Create(*context, "entry", wrap);
  auto *normal = llvm::BasicBlock::Create(*context, "normal", wrap);
  auto *unwind = llvm::BasicBlock::Create(*context, "unwind", wrap);

  B-&gt;SetInsertPoint(entry);
  std::vector&lt;llvm::Value *&gt; args;
  for (auto &amp;arg : wrap-&gt;args()) {
    args.push_back(&amp;arg);
  }
  auto *result = B-&gt;CreateInvoke(func, normal, unwind, args);

  B-&gt;SetInsertPoint(normal);
  B-&gt;CreateRet(result);

  B-&gt;SetInsertPoint(unwind);
  auto *caughtResult = B-&gt;CreateLandingPad(getPadType(), 1);
  caughtResult-&gt;setCleanup(true);
  caughtResult-&gt;addClause(getTypeIdxVar(nullptr));
  auto *unwindType = llvm::StructType::get(B-&gt;getInt64Ty()); // header only
  auto *unwindException = B-&gt;CreateExtractValue(caughtResult, 0);
  auto *unwindExceptionClass = B-&gt;CreateLoad(
      B-&gt;getInt64Ty(),
      B-&gt;CreateStructGEP(
          unwindType, B-&gt;CreatePointerCast(unwindException, unwindType-&gt;getPointerTo()),
          0));
  unwindException = B-&gt;CreateExtractValue(caughtResult, 0);
  auto *excType = llvm::StructType::get(getTypeInfoType(), B-&gt;getInt8PtrTy());
  auto *excVal =
      B-&gt;CreatePointerCast(B-&gt;CreateConstGEP1_64(B-&gt;getInt8Ty(), unwindException,
                                                 (uint64_t)seq_exc_offset()),
                           excType-&gt;getPointerTo());
  auto *loadedExc = B-&gt;CreateLoad(excType, excVal);
  auto *objPtr = B-&gt;CreateExtractValue(loadedExc, 1);

  auto *strType = llvm::StructType::get(B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy());
  auto *excHeader =
      llvm::StructType::get(strType, strType, strType, strType, B-&gt;getInt64Ty(),
                            B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy());
  auto *header = B-&gt;CreateLoad(excHeader, objPtr);
  auto *msg = B-&gt;CreateExtractValue(header, 1);
  auto *msgLen = B-&gt;CreateExtractValue(msg, 0);
  auto *msgPtr = B-&gt;CreateExtractValue(msg, 1);
  auto *pyType = B-&gt;CreateExtractValue(header, 6);

  // copy msg into new null-terminated buffer
  auto alloc = makeAllocFunc(/*atomic=*/true);
  auto *buf = B-&gt;CreateCall(alloc, B-&gt;CreateAdd(msgLen, B-&gt;getInt64(1)));
  B-&gt;CreateMemCpy(buf, {}, msgPtr, {}, msgLen);
  auto *last = B-&gt;CreateInBoundsGEP(B-&gt;getInt8Ty(), buf, msgLen);
  B-&gt;CreateStore(B-&gt;getInt8(0), last);

  auto *pyErrSetString = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("PyErr_SetString", B-&gt;getVoidTy(), B-&gt;getInt8PtrTy(),
                             B-&gt;getInt8PtrTy())
          .getCallee());

  const std::string pyExcRuntimeErrorName = "PyExc_RuntimeError";
  llvm::Value *pyExcRuntimeError = M-&gt;getNamedValue(pyExcRuntimeErrorName);
  if (!pyExcRuntimeError) {
    auto *pyExcRuntimeErrorVar = new llvm::GlobalVariable(
        *M, B-&gt;getInt8PtrTy(), /*isConstant=*/false, llvm::GlobalValue::ExternalLinkage,
        /*Initializer=*/nullptr, pyExcRuntimeErrorName);
    pyExcRuntimeErrorVar-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
    pyExcRuntimeError = pyExcRuntimeErrorVar;
  }
  pyExcRuntimeError = B-&gt;CreateLoad(B-&gt;getInt8PtrTy(), pyExcRuntimeError);

  auto *havePyType =
      B-&gt;CreateICmpNE(pyType, llvm::ConstantPointerNull::get(B-&gt;getInt8PtrTy()));
  B-&gt;CreateCall(pyErrSetString,
                {B-&gt;CreateSelect(havePyType, pyType, pyExcRuntimeError), buf});

  auto *retType = wrap-&gt;getReturnType();
  if (retType == B-&gt;getInt32Ty()) {
    B-&gt;CreateRet(B-&gt;getInt32(-1));
  } else {
    B-&gt;CreateRet(llvm::Constant::getNullValue(retType));
  }

  return wrap;
}

</t>
<t tx="ekr.20230509083242.642">void LLVMVisitor::writeToPythonExtension(const PyModule &amp;pymod,
  @others
</t>
<t tx="ekr.20230509083242.643">                                       const std::string &amp;filename) {
// Setup LLVM types &amp; constants
auto *i64 = B-&gt;getInt64Ty();
auto *i32 = B-&gt;getInt32Ty();
auto *i8 = B-&gt;getInt8Ty();
auto *ptr = B-&gt;getInt8PtrTy();
auto *pyMethodDefType = llvm::StructType::create("PyMethodDef", ptr, ptr, i32, ptr);
auto *pyObjectType = llvm::StructType::create("PyObject", i64, ptr);
auto *pyVarObjectType = llvm::StructType::create("PyVarObject", pyObjectType, i64);
auto *pyModuleDefBaseType =
    llvm::StructType::create("PyMethodDefBase", pyObjectType, ptr, i64, ptr);
auto *pyModuleDefType =
    llvm::StructType::create("PyModuleDef", pyModuleDefBaseType, ptr, ptr, i64,
                             pyMethodDefType-&gt;getPointerTo(), ptr, ptr, ptr, ptr);
auto *pyMemberDefType =
    llvm::StructType::create("PyMemberDef", ptr, i32, i64, i32, ptr);
auto *pyGetSetDefType =
    llvm::StructType::create("PyGetSetDef", ptr, ptr, ptr, ptr, ptr);
std::vector&lt;llvm::Type *&gt; pyNumberMethodsFields(36, ptr);
auto *pyNumberMethodsType =
    llvm::StructType::create(*context, pyNumberMethodsFields, "PyNumberMethods");
std::vector&lt;llvm::Type *&gt; pySequenceMethodsFields(10, ptr);
auto *pySequenceMethodsType =
    llvm::StructType::create(*context, pySequenceMethodsFields, "PySequenceMethods");
std::vector&lt;llvm::Type *&gt; pyMappingMethodsFields(3, ptr);
auto *pyMappingMethodsType =
    llvm::StructType::create(*context, pyMappingMethodsFields, "PyMappingMethods");
std::vector&lt;llvm::Type *&gt; pyAsyncMethodsFields(4, ptr);
auto *pyAsyncMethodsType =
    llvm::StructType::create(*context, pyAsyncMethodsFields, "PyAsyncMethods");
auto *pyBufferProcsType = llvm::StructType::create("PyBufferProcs", ptr, ptr);
auto *pyTypeObjectType = llvm::StructType::create(
    "PyTypeObject", pyVarObjectType, ptr, i64, i64, ptr, i64, ptr, ptr, ptr, ptr, ptr,
    ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, i64, ptr, ptr,
    ptr, ptr, ptr, ptr, ptr, ptr, ptr, i64, ptr, ptr, ptr, ptr, ptr, ptr, ptr, ptr,
    ptr, ptr, ptr, i32, ptr, ptr, i8);
auto *zero64 = B-&gt;getInt64(0);
auto *zero32 = B-&gt;getInt32(0);
auto *zero8 = B-&gt;getInt8(0);
auto *null = llvm::Constant::getNullValue(ptr);
auto *pyTypeType = new llvm::GlobalVariable(*M, ptr, /*isConstant=*/false,
                                            llvm::GlobalValue::ExternalLinkage,
                                            /*Initializer=*/nullptr, "PyType_Type");

auto allocUncollectable = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("seq_alloc_uncollectable", ptr, i64).getCallee());
allocUncollectable-&gt;setDoesNotThrow();
allocUncollectable-&gt;setReturnDoesNotAlias();
allocUncollectable-&gt;setOnlyAccessesInaccessibleMemory();

@others
  auto *delFn = pyFuncWrap(pytype.del, /*wrap=*/false);
  auto *dealloc = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction(pytype.name + ".py_dealloc", B-&gt;getVoidTy(), ptr)
          .getCallee());
  {
    llvm::Value *obj = dealloc-&gt;arg_begin();
    auto *entry = llvm::BasicBlock::Create(*context, "entry", dealloc);
    B-&gt;SetInsertPoint(entry);
    if (delFn != null)
      B-&gt;CreateCall(llvm::FunctionCallee(dealloc-&gt;getFunctionType(), delFn), obj);
    B-&gt;CreateCall(free, obj);
    B-&gt;CreateRetVoid();
  }

  auto *pyNew = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("PyType_GenericNew", ptr, ptr, ptr, ptr).getCallee());

  std::vector&lt;llvm::Constant *&gt; typeSlots = {
      llvm::ConstantStruct::get(
          pyVarObjectType,
          llvm::ConstantStruct::get(pyObjectType, B-&gt;getInt64(1), pyTypeType),
          zero64),                              // PyObject_VAR_HEAD
      pyString(pymod.name + "." + pytype.name), // tp_name
      B-&gt;getInt64(pySize),                      // tp_basicsize
      zero64,                                   // tp_itemsize
      dealloc,                                  // tp_dealloc
      zero64,                                   // tp_vectorcall_offset
      null,                                     // tp_getattr
      null,                                     // tp_setattr
      null,                                     // tp_as_async
      pyFunc(pytype.repr),                      // tp_repr
      numberSlotsConst,                         // tp_as_number
      sequenceSlotsConst,                       // tp_as_sequence
      mappingSlotsConst,                        // tp_as_mapping
      pyFunc(pytype.hash),                      // tp_hash
      pyFunc(pytype.call),                      // tp_call
      pyFunc(pytype.str),                       // tp_str
      null,                                     // tp_getattro
      null,                                     // tp_setattro
      null,                                     // tp_as_buffer
      zero64,                                   // tp_flags
      pyString(pytype.doc),                     // tp_doc
      null,                                     // tp_traverse
      null,                                     // tp_clear
      pyFunc(pytype.cmp),                       // tp_richcompare
      zero64,                                   // tp_weaklistoffset
      pyFunc(pytype.iter),                      // tp_iter
      pyFunc(pytype.iternext),                  // tp_iternext
      pyFunctions(pytype.methods),              // tp_methods
      pyMembers(pytype.members, objectType),    // tp_members
      pyGetSet(pytype.getset),                  // tp_getset
      null,                                     // tp_base
      null,                                     // tp_dict
      null,                                     // tp_descr_get
      null,                                     // tp_descr_set
      zero64,                                   // tp_dictoffset
      pyFunc(pytype.init),                      // tp_init
      alloc,                                    // tp_alloc
      pyNew,                                    // tp_new
      free,                                     // tp_free
      null,                                     // tp_is_gc
      null,                                     // tp_bases
      null,                                     // tp_mro
      null,                                     // tp_cache
      null,                                     // tp_subclasses
      null,                                     // tp_weaklist
      null,                                     // tp_del
      zero32,                                   // tp_version_tag
      free,                                     // tp_finalize
      null,                                     // tp_vectorcall
      B-&gt;getInt8(0),                            // tp_watched
  };

  auto *pyTypeObjectVar = new llvm::GlobalVariable(
      *M, pyTypeObjectType,
      /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantStruct::get(pyTypeObjectType, typeSlots),
      ".pyext_type." + pytype.name);

  if (pytype.typePtrHook) {
    auto *hook = llvm::cast&lt;llvm::Function&gt;(pyFuncWrap(pytype.typePtrHook, false));
    for (auto it = llvm::inst_begin(hook), end = llvm::inst_end(hook); it != end;
         ++it) {
      if (auto *ret = llvm::dyn_cast&lt;llvm::ReturnInst&gt;(&amp;*it))
        ret-&gt;setOperand(0, pyTypeObjectVar);
    }
  }

  typeVars.emplace(pytype.type, pyTypeObjectVar);
}

// Construct initialization hook
auto pyIncRef = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("Py_IncRef", B-&gt;getVoidTy(), ptr).getCallee());
pyIncRef-&gt;setDoesNotThrow();

auto pyDecRef = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("Py_DecRef", B-&gt;getVoidTy(), ptr).getCallee());
pyDecRef-&gt;setDoesNotThrow();

auto *pyModuleCreate = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("PyModule_Create2", ptr, ptr, i32).getCallee());
pyModuleCreate-&gt;setDoesNotThrow();

auto *pyTypeReady = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("PyType_Ready", i32, ptr).getCallee());
pyTypeReady-&gt;setDoesNotThrow();

auto *pyModuleAddObject = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("PyModule_AddObject", i32, ptr, ptr, ptr).getCallee());
pyModuleAddObject-&gt;setDoesNotThrow();

auto *pyModuleInit = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("PyInit_" + pymod.name, ptr).getCallee());
auto *block = llvm::BasicBlock::Create(*context, "entry", pyModuleInit);
B-&gt;SetInsertPoint(block);

if (auto *main = M-&gt;getFunction("main")) {
  main-&gt;setName(".main");
  B-&gt;CreateCall({main-&gt;getFunctionType(), main}, {zero32, null});
}

// Set base types
for (auto &amp;pytype : pymod.types) {
  if (pytype.base) {
    auto subcIt = typeVars.find(pytype.type);
    auto baseIt = typeVars.find(pytype.base-&gt;type);
    seqassertn(subcIt != typeVars.end() &amp;&amp; baseIt != typeVars.end(),
               "types not found");
    // 30 is the index of tp_base
    B-&gt;CreateStore(baseIt-&gt;second, B-&gt;CreateConstInBoundsGEP2_64(
                                       pyTypeObjectType, subcIt-&gt;second, 0, 30));
  }
}

// Call PyType_Ready
for (auto &amp;pytype : pymod.types) {
  auto it = typeVars.find(pytype.type);
  seqassertn(it != typeVars.end(), "type not found");
  auto *typeVar = it-&gt;second;

  auto *fail = llvm::BasicBlock::Create(*context, "failure", pyModuleInit);
  block = llvm::BasicBlock::Create(*context, "success", pyModuleInit);
  auto *status = B-&gt;CreateCall(pyTypeReady, typeVar);
  B-&gt;CreateCondBr(B-&gt;CreateICmpSLT(status, zero32), fail, block);

  B-&gt;SetInsertPoint(fail);
  B-&gt;CreateRet(null);

  B-&gt;SetInsertPoint(block);
}

// Create module
auto *mod = B-&gt;CreateCall(pyModuleCreate,
                          {pyModuleVar, B-&gt;getInt32(PYEXT_PYTHON_ABI_VERSION)});
auto *fail = llvm::BasicBlock::Create(*context, "failure", pyModuleInit);
block = llvm::BasicBlock::Create(*context, "success", pyModuleInit);

B-&gt;CreateCondBr(B-&gt;CreateICmpEQ(mod, null), fail, block);
B-&gt;SetInsertPoint(fail);
B-&gt;CreateRet(null);

B-&gt;SetInsertPoint(block);

// Add types
for (auto &amp;pytype : pymod.types) {
  auto it = typeVars.find(pytype.type);
  seqassertn(it != typeVars.end(), "type not found");
  auto *typeVar = it-&gt;second;

  B-&gt;CreateCall(pyIncRef, typeVar);
  auto *status =
      B-&gt;CreateCall(pyModuleAddObject, {mod, pyString(pytype.name), typeVar});
  fail = llvm::BasicBlock::Create(*context, "failure", pyModuleInit);
  block = llvm::BasicBlock::Create(*context, "success", pyModuleInit);
  B-&gt;CreateCondBr(B-&gt;CreateICmpSLT(status, zero32), fail, block);

  B-&gt;SetInsertPoint(fail);
  B-&gt;CreateCall(pyDecRef, typeVar);
  B-&gt;CreateCall(pyDecRef, mod);
  B-&gt;CreateRet(null);

  B-&gt;SetInsertPoint(block);
}
B-&gt;CreateRet(mod);

writeToObjectFile(filename);
}

</t>
<t tx="ekr.20230509083242.644">auto free = llvm::cast&lt;llvm::Function&gt;(
    M-&gt;getOrInsertFunction("seq_free", B-&gt;getVoidTy(), ptr).getCallee());
free-&gt;setDoesNotThrow();

@others
</t>
<t tx="ekr.20230509083242.645">// Helpers
auto pyFuncWrap = [&amp;](Func *func, bool wrap) -&gt; llvm::Constant * {
  if (!func)
    return null;
  auto llvmName = getNameForFunction(func);
  auto *llvmFunc = M-&gt;getFunction(llvmName);
  seqassertn(llvmFunc, "function {} not found in LLVM module", llvmName);
  if (wrap)
    llvmFunc = createPyTryCatchWrapper(llvmFunc);
  return llvmFunc;
};

</t>
<t tx="ekr.20230509083242.646">auto pyFunc = [&amp;](Func *func) -&gt; llvm::Constant * { return pyFuncWrap(func, true); };

</t>
<t tx="ekr.20230509083242.647">auto pyString = [&amp;](const std::string &amp;str) -&gt; llvm::Constant * {
  if (str.empty())
    return null;
  auto *var = new llvm::GlobalVariable(
      *M, llvm::ArrayType::get(i8, str.length() + 1),
      /*isConstant=*/true, llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantDataArray::getString(*context, str), ".pyext_str");
  var-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
  return var;
};

</t>
<t tx="ekr.20230509083242.648">auto pyFunctions = [&amp;](const std::vector&lt;PyFunction&gt; &amp;functions) -&gt; llvm::Constant * {
  if (functions.empty())
    return null;

  std::vector&lt;llvm::Constant *&gt; pyMethods;
  for (auto &amp;pyfunc : functions) {
    int flag = 0;
    if (pyfunc.keywords) {
      flag = PYEXT_METH_FASTCALL | PYEXT_METH_KEYWORDS;
    } else {
      switch (pyfunc.nargs) {
      case 0:
        flag = PYEXT_METH_NOARGS;
        break;
      case 1:
        flag = PYEXT_METH_O;
        break;
      default:
        flag = PYEXT_METH_FASTCALL;
        break;
      }
    }

    switch (pyfunc.type) {
    case PyFunction::CLASS:
      flag |= PYEXT_METH_CLASS;
      break;
    case PyFunction::STATIC:
      flag |= PYEXT_METH_STATIC;
      break;
    default:
      break;
    }

    if (pyfunc.coexist)
      flag |= PYEXT_METH_COEXIST;

    pyMethods.push_back(llvm::ConstantStruct::get(
        pyMethodDefType, pyString(pyfunc.name), pyFunc(pyfunc.func),
        B-&gt;getInt32(flag), pyString(pyfunc.doc)));
  }
  pyMethods.push_back(
      llvm::ConstantStruct::get(pyMethodDefType, null, null, zero32, null));

  auto *pyMethodDefArrayType =
      llvm::ArrayType::get(pyMethodDefType, pyMethods.size());
  auto *pyMethodDefArray = new llvm::GlobalVariable(
      *M, pyMethodDefArrayType,
      /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantArray::get(pyMethodDefArrayType, pyMethods), ".pyext_methods");
  return pyMethodDefArray;
};

</t>
<t tx="ekr.20230509083242.649">auto pyMembers = [&amp;](const std::vector&lt;PyMember&gt; &amp;members,
                     llvm::StructType *type) -&gt; llvm::Constant * {
  if (members.empty())
    return null;

  std::vector&lt;llvm::Constant *&gt; pyMemb;
  for (auto &amp;memb : members) {
    // Calculate offset by creating const GEP into null ptr
    std::vector&lt;llvm::Constant *&gt; indexes = {zero64, B-&gt;getInt32(1)};
    for (auto idx : memb.indexes) {
      indexes.push_back(B-&gt;getInt32(idx));
    }
    auto offset = llvm::ConstantExpr::getPtrToInt(
        llvm::ConstantExpr::getGetElementPtr(type, null, indexes), i64);

    pyMemb.push_back(llvm::ConstantStruct::get(
        pyMemberDefType, pyString(memb.name), B-&gt;getInt32(memb.type), offset,
        B-&gt;getInt32(memb.readonly ? PYEXT_READONLY : 0), pyString(memb.doc)));
  }
  pyMemb.push_back(
      llvm::ConstantStruct::get(pyMemberDefType, null, zero32, zero64, zero32, null));

  auto *pyMemberDefArrayType = llvm::ArrayType::get(pyMemberDefType, pyMemb.size());
  auto *pyMemberDefArray = new llvm::GlobalVariable(
      *M, pyMemberDefArrayType,
      /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantArray::get(pyMemberDefArrayType, pyMemb), ".pyext_members");
  return pyMemberDefArray;
};

</t>
<t tx="ekr.20230509083242.65">def __init__(self, board, pos):
    self.board = board
    self.pos = pos
    self.timestamp = TIMESTAMP
    self.removestamp = TIMESTAMP
    self.zobrist_strings = [random.randrange(9223372036854775807)
                            for i in range(3)]

</t>
<t tx="ekr.20230509083242.650">auto pyGetSet = [&amp;](const std::vector&lt;PyGetSet&gt; &amp;getset) -&gt; llvm::Constant * {
  if (getset.empty())
    return null;

  std::vector&lt;llvm::Constant *&gt; pyGS;
  for (auto &amp;gs : getset) {
    pyGS.push_back(llvm::ConstantStruct::get(pyGetSetDefType, pyString(gs.name),
                                             pyFunc(gs.get), pyFunc(gs.set),
                                             pyString(gs.doc), null));
  }
  pyGS.push_back(
      llvm::ConstantStruct::get(pyGetSetDefType, null, null, null, null, null));

  auto *pyGetSetDefArrayType = llvm::ArrayType::get(pyGetSetDefType, pyGS.size());
  auto *pyGetSetDefArray = new llvm::GlobalVariable(
      *M, pyGetSetDefArrayType,
      /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
      llvm::ConstantArray::get(pyGetSetDefArrayType, pyGS), ".pyext_getset");
  return pyGetSetDefArray;
};

</t>
<t tx="ekr.20230509083242.651">// Construct PyModuleDef array
auto *pyObjectConst = llvm::ConstantStruct::get(pyObjectType, B-&gt;getInt64(1), null);
auto *pyModuleDefBaseConst =
    llvm::ConstantStruct::get(pyModuleDefBaseType, pyObjectConst, null, zero64, null);

auto *pyModuleDef = llvm::ConstantStruct::get(
    pyModuleDefType, pyModuleDefBaseConst, pyString(pymod.name), pyString(pymod.doc),
    B-&gt;getInt64(-1), pyFunctions(pymod.functions), null, null, null, null);
auto *pyModuleVar =
    new llvm::GlobalVariable(*M, pyModuleDef-&gt;getType(),
                             /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
                             pyModuleDef, ".pyext_module");

std::unordered_map&lt;types::Type *, llvm::GlobalVariable *&gt; typeVars;
for (auto &amp;pytype : pymod.types) {
  std::vector&lt;llvm::Constant *&gt; numberSlots = {
      pyFunc(pytype.add),       // nb_add
      pyFunc(pytype.sub),       // nb_subtract
      pyFunc(pytype.mul),       // nb_multiply
      pyFunc(pytype.mod),       // nb_remainder
      pyFunc(pytype.divmod),    // nb_divmod
      pyFunc(pytype.pow),       // nb_power
      pyFunc(pytype.neg),       // nb_negative
      pyFunc(pytype.pos),       // nb_positive
      pyFunc(pytype.abs),       // nb_absolute
      pyFunc(pytype.bool_),     // nb_bool
      pyFunc(pytype.invert),    // nb_invert
      pyFunc(pytype.lshift),    // nb_lshift
      pyFunc(pytype.rshift),    // nb_rshift
      pyFunc(pytype.and_),      // nb_and
      pyFunc(pytype.xor_),      // nb_xor
      pyFunc(pytype.or_),       // nb_or
      pyFunc(pytype.int_),      // nb_int
      null,                     // nb_reserved
      pyFunc(pytype.float_),    // nb_float
      pyFunc(pytype.iadd),      // nb_inplace_add
      pyFunc(pytype.isub),      // nb_inplace_subtract
      pyFunc(pytype.imul),      // nb_inplace_multiply
      pyFunc(pytype.imod),      // nb_inplace_remainder
      pyFunc(pytype.ipow),      // nb_inplace_power
      pyFunc(pytype.ilshift),   // nb_inplace_lshift
      pyFunc(pytype.irshift),   // nb_inplace_rshift
      pyFunc(pytype.iand),      // nb_inplace_and
      pyFunc(pytype.ixor),      // nb_inplace_xor
      pyFunc(pytype.ior),       // nb_inplace_or
      pyFunc(pytype.floordiv),  // nb_floor_divide
      pyFunc(pytype.truediv),   // nb_true_divide
      pyFunc(pytype.ifloordiv), // nb_inplace_floor_divide
      pyFunc(pytype.itruediv),  // nb_inplace_true_divide
      pyFunc(pytype.index),     // nb_index
      pyFunc(pytype.matmul),    // nb_matrix_multiply
      pyFunc(pytype.imatmul),   // nb_inplace_matrix_multiply
  };

  std::vector&lt;llvm::Constant *&gt; sequenceSlots = {
      pyFunc(pytype.len),      // sq_length
      null,                    // sq_concat
      null,                    // sq_repeat
      null,                    // sq_item
      null,                    // was_sq_slice
      null,                    // sq_ass_item
      null,                    // was_sq_ass_slice
      pyFunc(pytype.contains), // sq_contains
      null,                    // sq_inplace_concat
      null,                    // sq_inplace_repeat
  };

  std::vector&lt;llvm::Constant *&gt; mappingSlots = {
      null,                   // mp_length
      pyFunc(pytype.getitem), // mp_subscript
      pyFunc(pytype.setitem), // mp_ass_subscript
  };

  bool needNumberSlots =
      std::find_if(numberSlots.begin(), numberSlots.end(),
                   [&amp;](auto *v) { return v != null; }) != numberSlots.end();
  bool needSequenceSlots =
      std::find_if(sequenceSlots.begin(), sequenceSlots.end(),
                   [&amp;](auto *v) { return v != null; }) != sequenceSlots.end();
</t>
<t tx="ekr.20230509083242.652">  bool needMappingSlots =
      std::find_if(mappingSlots.begin(), mappingSlots.end(),
                   [&amp;](auto *v) { return v != null; }) != mappingSlots.end();

  llvm::Constant *numberSlotsConst = null;
  llvm::Constant *sequenceSlotsConst = null;
  llvm::Constant *mappingSlotsConst = null;

  if (needNumberSlots) {
    auto *pyNumberSlotsVar = new llvm::GlobalVariable(
        *M, pyNumberMethodsType,
        /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
        llvm::ConstantStruct::get(pyNumberMethodsType, numberSlots),
        ".pyext_number_slots." + pytype.name);
    numberSlotsConst = pyNumberSlotsVar;
  }

</t>
<t tx="ekr.20230509083242.653">  if (needSequenceSlots) {
    auto *pySequenceSlotsVar = new llvm::GlobalVariable(
        *M, pySequenceMethodsType,
        /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
        llvm::ConstantStruct::get(pySequenceMethodsType, sequenceSlots),
        ".pyext_sequence_slots." + pytype.name);
    sequenceSlotsConst = pySequenceSlotsVar;
  }

  if (needMappingSlots) {
    auto *pyMappingSlotsVar = new llvm::GlobalVariable(
        *M, pyMappingMethodsType,
        /*isConstant=*/false, llvm::GlobalValue::PrivateLinkage,
        llvm::ConstantStruct::get(pyMappingMethodsType, mappingSlots),
        ".pyext_mapping_slots." + pytype.name);
    mappingSlotsConst = pyMappingSlotsVar;
  }

  auto *refType = cast&lt;types::RefType&gt;(pytype.type);
  auto *llvmType = getLLVMType(pytype.type);
  auto *objectType = llvm::StructType::get(pyObjectType, llvmType);
</t>
<t tx="ekr.20230509083242.654">  auto codonSize =
      refType
          ? M-&gt;getDataLayout().getTypeAllocSize(getLLVMType(refType-&gt;getContents()))
          : 0;
  auto pySize = M-&gt;getDataLayout().getTypeAllocSize(objectType);

  auto *alloc = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction(pytype.name + ".py_alloc", ptr, ptr, i64).getCallee());
  {
    auto *entry = llvm::BasicBlock::Create(*context, "entry", alloc);
    B-&gt;SetInsertPoint(entry);
    auto *pythonObject = B-&gt;CreateCall(allocUncollectable, B-&gt;getInt64(pySize));
    auto *header = B-&gt;CreateInsertValue(
        llvm::ConstantStruct::get(pyObjectType, B-&gt;getInt64(1), null),
        alloc-&gt;arg_begin(), 1);
    B-&gt;CreateStore(header, pythonObject);
    if (refType) {
      auto *codonObject = B-&gt;CreateCall(
          makeAllocFunc(refType-&gt;getContents()-&gt;isAtomic()), B-&gt;getInt64(codonSize));
      B-&gt;CreateStore(codonObject, B-&gt;CreateGEP(objectType, pythonObject,
                                               {zero64, B-&gt;getInt32(1)}));
    }
    B-&gt;CreateRet(pythonObject);
  }

</t>
<t tx="ekr.20230509083242.655">void LLVMVisitor::compile(const std::string &amp;filename, const std::string &amp;argv0,
  @others
</t>
<t tx="ekr.20230509083242.656">                        const std::vector&lt;std::string&gt; &amp;libs,
@others
</t>
<t tx="ekr.20230509083242.657">                        const std::string &amp;lflags) {
llvm::StringRef f(filename);
if (f.endswith(".ll")) {
  writeToLLFile(filename);
} else if (f.endswith(".bc")) {
  writeToBitcodeFile(filename);
} else if (f.endswith(".o") || f.endswith(".obj")) {
  writeToObjectFile(filename);
} else if (f.endswith(".so") || f.endswith(".dylib")) {
  writeToExecutable(filename, argv0, /*library=*/true, libs, lflags);
} else {
  writeToExecutable(filename, argv0, /*library=*/false, libs, lflags);
}
}

</t>
<t tx="ekr.20230509083242.658">void LLVMVisitor::run(const std::vector&lt;std::string&gt; &amp;args,
  @others
</t>
<t tx="ekr.20230509083242.659">                    const std::vector&lt;std::string&gt; &amp;libs, const char *const *envp) {
runLLVMPipeline();

Timer t1("llvm/jitlink");
for (auto &amp;lib : libs) {
  std::string err;
  if (llvm::sys::DynamicLibrary::LoadLibraryPermanently(lib.c_str(), &amp;err)) {
    compilationError(err);
  }
}

DebugPlugin *dbp = nullptr;
llvm::Triple triple(M-&gt;getTargetTriple());
@others
builder.setJITTargetMachineBuilder(llvm::orc::JITTargetMachineBuilder(triple));

auto jit = llvm::cantFail(builder.create());
jit-&gt;getMainJITDylib().addGenerator(
    llvm::cantFail(llvm::orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(
        jit-&gt;getDataLayout().getGlobalPrefix())));

llvm::cantFail(jit-&gt;addIRModule({std::move(M), std::move(context)}));
clearLLVMData();
auto mainAddr = llvm::cantFail(jit-&gt;lookup("main"));

if (db.debug) {
  runtime::setJITErrorCallback([dbp](const runtime::JITError &amp;e) {
    fmt::print(stderr, "{}\n{}", e.getOutput(),
               dbp-&gt;getPrettyBacktrace(e.getBacktrace()));
    std::abort();
  });
} else {
  runtime::setJITErrorCallback([](const runtime::JITError &amp;e) {
    fmt::print(stderr, "{}", e.getOutput());
    std::abort();
  });
}
t1.log();

try {
  llvm::cantFail(epc-&gt;runAsMain(mainAddr, args));
} catch (const runtime::JITError &amp;e) {
  fmt::print(stderr, "{}\n", e.getOutput());
  std::abort();
}
}

</t>
<t tx="ekr.20230509083242.66">def set_neighbours(self):
    x, y = self.pos % SIZE, self.pos // SIZE
    self.neighbours = []
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        newx, newy = x + dx, y + dy
        if 0 &lt;= newx &lt; SIZE and 0 &lt;= newy &lt; SIZE:
            self.neighbours.append(self.board.squares[to_pos(newx, newy)])

</t>
<t tx="ekr.20230509083242.660">auto epc = llvm::cantFail(llvm::orc::SelfExecutorProcessControl::Create(
    std::make_shared&lt;llvm::orc::SymbolStringPool&gt;()));

llvm::orc::LLJITBuilder builder;
builder.setDataLayout(llvm::DataLayout(M.get()));
builder.setObjectLinkingLayerCreator(
    [&amp;epc, &amp;dbp](llvm::orc::ExecutionSession &amp;es, const llvm::Triple &amp;triple)
        -&gt; llvm::Expected&lt;std::unique_ptr&lt;llvm::orc::ObjectLayer&gt;&gt; {
      auto L = std::make_unique&lt;llvm::orc::ObjectLinkingLayer&gt;(
          es, llvm::cantFail(BoehmGCJITLinkMemoryManager::Create()));
      L-&gt;addPlugin(std::make_unique&lt;llvm::orc::EHFrameRegistrationPlugin&gt;(
          es, llvm::cantFail(llvm::orc::EPCEHFrameRegistrar::Create(es))));
      L-&gt;addPlugin(std::make_unique&lt;llvm::orc::DebugObjectManagerPlugin&gt;(
          es, llvm::cantFail(llvm::orc::createJITLoaderGDBRegistrar(es))));
      auto dbPlugin = std::make_unique&lt;DebugPlugin&gt;();
      dbp = dbPlugin.get();
      L-&gt;addPlugin(std::move(dbPlugin));
      return L;
    });
</t>
<t tx="ekr.20230509083242.661">llvm::FunctionCallee LLVMVisitor::makeAllocFunc(bool atomic) {
</t>
<t tx="ekr.20230509083242.662">  auto f = M-&gt;getOrInsertFunction(atomic ? "seq_alloc_atomic" : "seq_alloc",
                                  B-&gt;getInt8PtrTy(), B-&gt;getInt64Ty());
  auto *g = cast&lt;llvm::Function&gt;(f.getCallee());
  g-&gt;setDoesNotThrow();
  g-&gt;setReturnDoesNotAlias();
  g-&gt;setOnlyAccessesInaccessibleMemory();
  return f;
}

llvm::FunctionCallee LLVMVisitor::makePersonalityFunc() {
  return M-&gt;getOrInsertFunction("seq_personality", B-&gt;getInt32Ty(), B-&gt;getInt32Ty(),
                                B-&gt;getInt32Ty(), B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy(),
                                B-&gt;getInt8PtrTy());
}

</t>
<t tx="ekr.20230509083242.663">llvm::FunctionCallee LLVMVisitor::makeExcAllocFunc() {
</t>
<t tx="ekr.20230509083242.664">  auto f = M-&gt;getOrInsertFunction("seq_alloc_exc", B-&gt;getInt8PtrTy(), B-&gt;getInt32Ty(),
                                  B-&gt;getInt8PtrTy());
  auto *g = cast&lt;llvm::Function&gt;(f.getCallee());
  g-&gt;setDoesNotThrow();
  return f;
}

llvm::FunctionCallee LLVMVisitor::makeThrowFunc() {
  auto f = M-&gt;getOrInsertFunction("seq_throw", B-&gt;getVoidTy(), B-&gt;getInt8PtrTy());
  auto *g = cast&lt;llvm::Function&gt;(f.getCallee());
  g-&gt;setDoesNotReturn();
  return f;
}

</t>
<t tx="ekr.20230509083242.665">llvm::FunctionCallee LLVMVisitor::makeTerminateFunc() {
  auto f = M-&gt;getOrInsertFunction("seq_terminate", B-&gt;getVoidTy(), B-&gt;getInt8PtrTy());
  auto *g = cast&lt;llvm::Function&gt;(f.getCallee());
  g-&gt;setDoesNotReturn();
  return f;
}

llvm::StructType *LLVMVisitor::getTypeInfoType() {
  return llvm::StructType::get(B-&gt;getInt32Ty());
}

llvm::StructType *LLVMVisitor::getPadType() {
  return llvm::StructType::get(B-&gt;getInt8PtrTy(), B-&gt;getInt32Ty());
}

llvm::StructType *LLVMVisitor::getExceptionType() {
  return llvm::StructType::get(getTypeInfoType(), B-&gt;getInt8PtrTy());
}

namespace {
</t>
<t tx="ekr.20230509083242.666">int typeIdxLookup(const std::string &amp;name) {
  static std::unordered_map&lt;std::string, int&gt; cache;
  static int next = 1000;
  if (name.empty())
    return 0;
  auto it = cache.find(name);
  if (it != cache.end()) {
    return it-&gt;second;
  } else {
    const int myID = next++;
    cache[name] = myID;
    return myID;
  }
}
</t>
<t tx="ekr.20230509083242.667">} // namespace

llvm::GlobalVariable *LLVMVisitor::getTypeIdxVar(const std::string &amp;name) {
  auto *typeInfoType = getTypeInfoType();
  const std::string typeVarName = "codon.typeidx." + (name.empty() ? "&lt;all&gt;" : name);
  llvm::GlobalVariable *tidx = M-&gt;getGlobalVariable(typeVarName);
  int idx = typeIdxLookup(name);
  if (!tidx) {
    tidx = new llvm::GlobalVariable(
        *M, typeInfoType, /*isConstant=*/true, llvm::GlobalValue::PrivateLinkage,
        llvm::ConstantStruct::get(typeInfoType, B-&gt;getInt32(idx)), typeVarName);
    tidx-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
  }
  return tidx;
}

llvm::GlobalVariable *LLVMVisitor::getTypeIdxVar(types::Type *catchType) {
  return getTypeIdxVar(catchType ? catchType-&gt;getName() : "");
}

</t>
<t tx="ekr.20230509083242.668">int LLVMVisitor::getTypeIdx(types::Type *catchType) {
  return typeIdxLookup(catchType ? catchType-&gt;getName() : "");
}

</t>
<t tx="ekr.20230509083242.669">llvm::Value *LLVMVisitor::call(llvm::FunctionCallee callee,
                               llvm::ArrayRef&lt;llvm::Value *&gt; args) {
  B-&gt;SetInsertPoint(block);
  if (trycatch.empty()) {
    return B-&gt;CreateCall(callee, args);
  } else {
    auto *normalBlock = llvm::BasicBlock::Create(*context, "invoke.normal", func);
    auto *unwindBlock = trycatch.back().exceptionBlock;
    auto *result = B-&gt;CreateInvoke(callee, normalBlock, unwindBlock, args);
    block = normalBlock;
    return result;
  }
}

static int nextSequenceNumber = 0;

</t>
<t tx="ekr.20230509083242.67">def move(self, color):
    global TIMESTAMP, MOVES
    TIMESTAMP += 1
    MOVES += 1
    self.board.zobrist.update(self, color)
    self.color = color
    self.reference = self
    self.ledges = 0
    self.used = True
    for neighbour in self.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            self.ledges += 1
        else:
            neighbour_ref = neighbour.find(update=True)
            if neighcolor == color:
                if neighbour_ref.reference.pos != self.pos:
                    self.ledges += neighbour_ref.ledges
                    neighbour_ref.reference = self
                self.ledges -= 1
            else:
                neighbour_ref.ledges -= 1
                if neighbour_ref.ledges == 0:
                    neighbour.remove(neighbour_ref)
    self.board.zobrist.add()

</t>
<t tx="ekr.20230509083242.670">void LLVMVisitor::enterLoop(LoopData data) {
  loops.push_back(std::move(data));
  loops.back().sequenceNumber = nextSequenceNumber++;
}

</t>
<t tx="ekr.20230509083242.671">void LLVMVisitor::exitLoop() {
  seqassertn(!loops.empty(), "no loops present");
  loops.pop_back();
}

</t>
<t tx="ekr.20230509083242.672">void LLVMVisitor::enterTryCatch(TryCatchData data) {
  trycatch.push_back(std::move(data));
  trycatch.back().sequenceNumber = nextSequenceNumber++;
}

</t>
<t tx="ekr.20230509083242.673">void LLVMVisitor::exitTryCatch() {
  seqassertn(!trycatch.empty(), "no try catches present");
  trycatch.pop_back();
}

</t>
<t tx="ekr.20230509083242.674">void LLVMVisitor::enterCatch(CatchData data) {
  catches.push_back(std::move(data));
  catches.back().sequenceNumber = nextSequenceNumber++;
}

</t>
<t tx="ekr.20230509083242.675">void LLVMVisitor::exitCatch() {
  seqassertn(!catches.empty(), "no catches present");
  catches.pop_back();
}

</t>
<t tx="ekr.20230509083242.676">LLVMVisitor::TryCatchData *LLVMVisitor::getInnermostTryCatch() {
  return trycatch.empty() ? nullptr : &amp;trycatch.back();
}

LLVMVisitor::TryCatchData *LLVMVisitor::getInnermostTryCatchBeforeLoop() {
  if (!trycatch.empty() &amp;&amp;
      (loops.empty() || trycatch.back().sequenceNumber &gt; loops.back().sequenceNumber))
    return &amp;trycatch.back();
  return nullptr;
}

/*
 * General values, M, functions, vars
 */

</t>
<t tx="ekr.20230509083242.677">void LLVMVisitor::visit(const Module *x) {
  // initialize M
  M = makeModule(*context, getSrcInfo(x));

  // args variable
  seqassertn(x-&gt;getArgVar()-&gt;isGlobal(), "arg var is not global");
  registerGlobal(x-&gt;getArgVar());

  // set up global variables and initialize functions
  for (auto *var : *x) {
    registerGlobal(var);
  }

  // process functions
  for (auto *var : *x) {
    if (auto *f = cast&lt;Func&gt;(var)) {
      process(f);
    }
  }

  const Func *main = x-&gt;getMainFunc();
  llvm::FunctionCallee realMain = makeLLVMFunction(main);
  process(main);
  setDebugInfoForNode(nullptr);

  // build canonical main function
  auto *strType = llvm::StructType::get(*context, {B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy()});
  auto *arrType =
      llvm::StructType::get(*context, {B-&gt;getInt64Ty(), strType-&gt;getPointerTo()});

  auto *initFunc = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("seq_init", B-&gt;getVoidTy(), B-&gt;getInt32Ty()).getCallee());
  auto *strlenFunc = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("strlen", B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy()).getCallee());

  auto *canonicalMainFunc = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("main", B-&gt;getInt32Ty(), B-&gt;getInt32Ty(),
                             B-&gt;getInt8PtrTy()-&gt;getPointerTo())
          .getCallee());

  canonicalMainFunc-&gt;setPersonalityFn(
      llvm::cast&lt;llvm::Constant&gt;(makePersonalityFunc().getCallee()));
  auto argiter = canonicalMainFunc-&gt;arg_begin();
  llvm::Value *argc = argiter++;
  llvm::Value *argv = argiter;
  argc-&gt;setName("argc");
  argv-&gt;setName("argv");

  // The following generates code to put program arguments in an array, i.e.:
  //    for (int i = 0; i &lt; argc; i++)
  //      array[i] = {strlen(argv[i]), argv[i]}
  auto *entryBlock = llvm::BasicBlock::Create(*context, "entry", canonicalMainFunc);
  auto *loopBlock = llvm::BasicBlock::Create(*context, "loop", canonicalMainFunc);
  auto *bodyBlock = llvm::BasicBlock::Create(*context, "body", canonicalMainFunc);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "exit", canonicalMainFunc);

  B-&gt;SetInsertPoint(entryBlock);
  auto allocFunc = makeAllocFunc(/*atomic=*/false);
  llvm::Value *len = B-&gt;CreateZExt(argc, B-&gt;getInt64Ty());
  llvm::Value *elemSize = B-&gt;getInt64(M-&gt;getDataLayout().getTypeAllocSize(strType));
  llvm::Value *allocSize = B-&gt;CreateMul(len, elemSize);
  llvm::Value *ptr = B-&gt;CreateCall(allocFunc, allocSize);
  ptr = B-&gt;CreateBitCast(ptr, strType-&gt;getPointerTo());
  llvm::Value *arr = llvm::UndefValue::get(arrType);
  arr = B-&gt;CreateInsertValue(arr, len, 0);
  arr = B-&gt;CreateInsertValue(arr, ptr, 1);
  B-&gt;CreateBr(loopBlock);

  B-&gt;SetInsertPoint(loopBlock);
  llvm::PHINode *control = B-&gt;CreatePHI(B-&gt;getInt32Ty(), 2, "i");
  llvm::Value *next = B-&gt;CreateAdd(control, B-&gt;getInt32(1), "next");
  llvm::Value *cond = B-&gt;CreateICmpSLT(control, argc);
  control-&gt;addIncoming(B-&gt;getInt32(0), entryBlock);
  control-&gt;addIncoming(next, bodyBlock);
  B-&gt;CreateCondBr(cond, bodyBlock, exitBlock);

  B-&gt;SetInsertPoint(bodyBlock);
  llvm::Value *arg =
      B-&gt;CreateLoad(B-&gt;getInt8PtrTy(), B-&gt;CreateGEP(B-&gt;getInt8PtrTy(), argv, control));
  llvm::Value *argLen =
      B-&gt;CreateZExtOrTrunc(B-&gt;CreateCall(strlenFunc, arg), B-&gt;getInt64Ty());
  llvm::Value *str = llvm::UndefValue::get(strType);
  str = B-&gt;CreateInsertValue(str, argLen, 0);
  str = B-&gt;CreateInsertValue(str, arg, 1);
  B-&gt;CreateStore(str, B-&gt;CreateGEP(strType, ptr, control));
  B-&gt;CreateBr(loopBlock);

  B-&gt;SetInsertPoint(exitBlock);
  llvm::Value *argStorage = getVar(x-&gt;getArgVar());
  seqassertn(argStorage, "argument storage missing");
  B-&gt;CreateStore(arr, argStorage);
  @others
  B-&gt;SetInsertPoint(exitBlock);
  B-&gt;CreateRet(B-&gt;getInt32(0));
}

</t>
<t tx="ekr.20230509083242.678">const int flags = (db.debug ? SEQ_FLAG_DEBUG : 0) |
                  (db.capture ? SEQ_FLAG_CAPTURE_OUTPUT : 0) |
                  (db.standalone ? SEQ_FLAG_STANDALONE : 0);
B-&gt;CreateCall(initFunc, B-&gt;getInt32(flags));

// Put the entire program in a new function
{
  auto *proxyMainTy = llvm::FunctionType::get(B-&gt;getVoidTy(), {}, false);
  auto *proxyMain = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction("codon.proxy_main", proxyMainTy).getCallee());
  proxyMain-&gt;setLinkage(llvm::GlobalValue::PrivateLinkage);
  proxyMain-&gt;setPersonalityFn(
      llvm::cast&lt;llvm::Constant&gt;(makePersonalityFunc().getCallee()));
  auto *proxyBlockEntry = llvm::BasicBlock::Create(*context, "entry", proxyMain);
  auto *proxyBlockMain = llvm::BasicBlock::Create(*context, "main", proxyMain);
  auto *proxyBlockExit = llvm::BasicBlock::Create(*context, "exit", proxyMain);
  B-&gt;SetInsertPoint(proxyBlockEntry);

  llvm::Value *shouldExit = B-&gt;getFalse();
  B-&gt;CreateCondBr(shouldExit, proxyBlockExit, proxyBlockMain);

  B-&gt;SetInsertPoint(proxyBlockExit);
  B-&gt;CreateRetVoid();

  // invoke real main
  auto *normal = llvm::BasicBlock::Create(*context, "normal", proxyMain);
  auto *unwind = llvm::BasicBlock::Create(*context, "unwind", proxyMain);
  B-&gt;SetInsertPoint(proxyBlockMain);
  B-&gt;CreateInvoke(realMain, normal, unwind);

  B-&gt;SetInsertPoint(unwind);
  llvm::LandingPadInst *caughtResult = B-&gt;CreateLandingPad(getPadType(), 1);
  caughtResult-&gt;setCleanup(true);
  caughtResult-&gt;addClause(getTypeIdxVar(nullptr));
  llvm::Value *unwindException = B-&gt;CreateExtractValue(caughtResult, 0);
  B-&gt;CreateCall(makeTerminateFunc(), unwindException);
  B-&gt;CreateUnreachable();

  B-&gt;SetInsertPoint(normal);
  B-&gt;CreateRetVoid();

  // actually make the call
  B-&gt;SetInsertPoint(exitBlock);
  B-&gt;CreateCall(proxyMain);
}

</t>
<t tx="ekr.20230509083242.679">llvm::DISubprogram *LLVMVisitor::getDISubprogramForFunc(const Func *x) {
  auto *srcInfo = getSrcInfo(x);
  llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
  auto *derivedType = llvm::cast&lt;llvm::DIDerivedType&gt;(getDIType(x-&gt;getType()));
  auto *subroutineType =
      llvm::cast&lt;llvm::DISubroutineType&gt;(derivedType-&gt;getRawBaseType());

  std::string baseName = x-&gt;getUnmangledName();
  if (auto *parent = x-&gt;getParentType())
    baseName = parent-&gt;getName() + "." + baseName;
  llvm::DISubprogram *subprogram = db.builder-&gt;createFunction(
      file, baseName, getNameForFunction(x), file, srcInfo-&gt;line, subroutineType,
      /*ScopeLine=*/0, llvm::DINode::FlagZero,
      llvm::DISubprogram::toSPFlags(/*IsLocalToUnit=*/true,
                                    /*IsDefinition=*/true, /*IsOptimized=*/!db.debug));
  return subprogram;
}

llvm::Function *LLVMVisitor::makeLLVMFunction(const Func *x) {
  // process LLVM functions in full immediately
  if (auto *llvmFunc = cast&lt;LLVMFunc&gt;(x)) {
    auto *oldFunc = func;
    process(llvmFunc);
    setDebugInfoForNode(nullptr);
    auto *newFunc = func;
    func = oldFunc;
    return newFunc;
  }

  auto *funcType = cast&lt;types::FuncType&gt;(x-&gt;getType());
  llvm::Type *returnType = getLLVMType(funcType-&gt;getReturnType());
  std::vector&lt;llvm::Type *&gt; argTypes;
  for (const auto &amp;argType : *funcType) {
    argTypes.push_back(getLLVMType(argType));
  }

  auto *llvmFuncType =
      llvm::FunctionType::get(returnType, argTypes, funcType-&gt;isVariadic());
  const std::string functionName = getNameForFunction(x);
  auto *f = llvm::cast&lt;llvm::Function&gt;(
      M-&gt;getOrInsertFunction(functionName, llvmFuncType).getCallee());
  if (!cast&lt;ExternalFunc&gt;(x)) {
    f-&gt;setSubprogram(getDISubprogramForFunc(x));
  }
  return f;
}

</t>
<t tx="ekr.20230509083242.68">def remove(self, reference, update=True):
    self.board.zobrist.update(self, EMPTY)
    self.removestamp = TIMESTAMP
    if update:
        self.color = EMPTY
        self.board.emptyset.add(self.pos)
</t>
<t tx="ekr.20230509083242.680">void LLVMVisitor::makeYield(llvm::Value *value, bool finalYield) {
  B-&gt;SetInsertPoint(block);
  if (value) {
    seqassertn(coro.promise, "promise is null");
    B-&gt;CreateStore(value, coro.promise);
  }
  llvm::FunctionCallee coroSuspend =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_suspend);
  llvm::Value *suspendResult = B-&gt;CreateCall(
      coroSuspend, {llvm::ConstantTokenNone::get(*context), B-&gt;getInt1(finalYield)});

  block = llvm::BasicBlock::Create(*context, "yield.new", func);

  llvm::SwitchInst *inst = B-&gt;CreateSwitch(suspendResult, coro.suspend, 2);
  inst-&gt;addCase(B-&gt;getInt8(0), block);
  inst-&gt;addCase(B-&gt;getInt8(1), coro.cleanup);
}

</t>
<t tx="ekr.20230509083242.681">void LLVMVisitor::visit(const ExternalFunc *x) {
  func = M-&gt;getFunction(getNameForFunction(x));
  coro = {};
  seqassertn(func, "{} not inserted", *x);
  func-&gt;setDoesNotThrow();
}

</t>
<t tx="ekr.20230509083242.682">namespace {
</t>
<t tx="ekr.20230509083242.683">// internal function type checking
template &lt;typename ParentType&gt;
bool internalFuncMatchesIgnoreArgs(const std::string &amp;name, const InternalFunc *x) {
  return name == x-&gt;getUnmangledName() &amp;&amp; cast&lt;ParentType&gt;(x-&gt;getParentType());
}

</t>
<t tx="ekr.20230509083242.684">template &lt;typename ParentType, typename... ArgTypes, std::size_t... Index&gt;
  @others
</t>
<t tx="ekr.20230509083242.685">bool internalFuncMatches(const std::string &amp;name, const InternalFunc *x,
                       std::index_sequence&lt;Index...&gt;) {
auto *funcType = cast&lt;types::FuncType&gt;(x-&gt;getType());
if (name != x-&gt;getUnmangledName() ||
    std::distance(funcType-&gt;begin(), funcType-&gt;end()) != sizeof...(ArgTypes))
  return false;
std::vector&lt;types::Type *&gt; argTypes(funcType-&gt;begin(), funcType-&gt;end());
std::vector&lt;bool&gt; m = {bool(cast&lt;ParentType&gt;(x-&gt;getParentType())),
                       bool(cast&lt;ArgTypes&gt;(argTypes[Index]))...};
const bool match = std::all_of(m.begin(), m.end(), [](bool b) { return b; });
return match;
}

</t>
<t tx="ekr.20230509083242.686">template &lt;typename ParentType, typename... ArgTypes&gt;
bool internalFuncMatches(const std::string &amp;name, const InternalFunc *x) {
  return internalFuncMatches&lt;ParentType, ArgTypes...&gt;(
      name, x, std::make_index_sequence&lt;sizeof...(ArgTypes)&gt;());
}
</t>
<t tx="ekr.20230509083242.687">} // namespace

</t>
<t tx="ekr.20230509083242.688">void LLVMVisitor::visit(const InternalFunc *x) {
  using namespace types;
  func = M-&gt;getFunction(getNameForFunction(x));
  coro = {};
  seqassertn(func, "{} not inserted", *x);
  setDebugInfoForNode(x);

  Type *parentType = x-&gt;getParentType();
  auto *funcType = cast&lt;FuncType&gt;(x-&gt;getType());
  std::vector&lt;Type *&gt; argTypes(funcType-&gt;begin(), funcType-&gt;end());

  func-&gt;setLinkage(llvm::GlobalValue::PrivateLinkage);
  func-&gt;addFnAttr(llvm::Attribute::AttrKind::AlwaysInline);
  std::vector&lt;llvm::Value *&gt; args;
  for (auto it = func-&gt;arg_begin(); it != func-&gt;arg_end(); ++it) {
    args.push_back(it);
  }
  block = llvm::BasicBlock::Create(*context, "entry", func);
  B-&gt;SetInsertPoint(block);
  llvm::Value *result = nullptr;

  if (internalFuncMatches&lt;PointerType, IntType&gt;("__new__", x)) {
    auto *pointerType = cast&lt;PointerType&gt;(parentType);
    Type *baseType = pointerType-&gt;getBase();
    llvm::Type *llvmBaseType = getLLVMType(baseType);
    auto allocFunc = makeAllocFunc(baseType-&gt;isAtomic());
    llvm::Value *elemSize =
        B-&gt;getInt64(M-&gt;getDataLayout().getTypeAllocSize(llvmBaseType));
    llvm::Value *allocSize = B-&gt;CreateMul(elemSize, args[0]);
    result = B-&gt;CreateCall(allocFunc, allocSize);
    result = B-&gt;CreateBitCast(result, llvmBaseType-&gt;getPointerTo());
  }

  else if (internalFuncMatches&lt;IntType, IntNType&gt;("__new__", x)) {
    auto *intNType = cast&lt;IntNType&gt;(argTypes[0]);
    if (intNType-&gt;isSigned()) {
      result = B-&gt;CreateSExtOrTrunc(args[0], B-&gt;getInt64Ty());
    } else {
      result = B-&gt;CreateZExtOrTrunc(args[0], B-&gt;getInt64Ty());
    }
  }

  else if (internalFuncMatches&lt;IntNType, IntType&gt;("__new__", x)) {
    auto *intNType = cast&lt;IntNType&gt;(parentType);
    if (intNType-&gt;isSigned()) {
      result = B-&gt;CreateSExtOrTrunc(args[0], getLLVMType(intNType));
    } else {
      result = B-&gt;CreateZExtOrTrunc(args[0], getLLVMType(intNType));
    }
  }

  else if (internalFuncMatches&lt;RefType&gt;("__new__", x)) {
    auto *refType = cast&lt;RefType&gt;(parentType);
    auto allocFunc = makeAllocFunc(refType-&gt;getContents()-&gt;isAtomic());
    llvm::Value *size = B-&gt;getInt64(
        M-&gt;getDataLayout().getTypeAllocSize(getLLVMType(refType-&gt;getContents())));
    result = B-&gt;CreateCall(allocFunc, size);
  }

  else if (internalFuncMatches&lt;GeneratorType, GeneratorType&gt;("__promise__", x)) {
    auto *generatorType = cast&lt;GeneratorType&gt;(parentType);
    llvm::Type *baseType = getLLVMType(generatorType-&gt;getBase());
    if (baseType-&gt;isVoidTy()) {
      result = llvm::ConstantPointerNull::get(B-&gt;getVoidTy()-&gt;getPointerTo());
    } else {
      llvm::FunctionCallee coroPromise =
          llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_promise);
      llvm::Value *aln = B-&gt;getInt32(M-&gt;getDataLayout().getPrefTypeAlignment(baseType));
      llvm::Value *from = B-&gt;getFalse();
      llvm::Value *ptr = B-&gt;CreateCall(coroPromise, {args[0], aln, from});
      result = B-&gt;CreateBitCast(ptr, baseType-&gt;getPointerTo());
    }
  }

  else if (internalFuncMatchesIgnoreArgs&lt;RecordType&gt;("__new__", x)) {
    auto *recordType = cast&lt;RecordType&gt;(parentType);
    seqassertn(args.size() == std::distance(recordType-&gt;begin(), recordType-&gt;end()),
               "args size does not match");
    result = llvm::UndefValue::get(getLLVMType(recordType));
    for (auto i = 0; i &lt; args.size(); i++) {
      result = B-&gt;CreateInsertValue(result, args[i], i);
    }
  }

  seqassertn(result, "internal function {} not found", *x);
  B-&gt;CreateRet(result);
}

</t>
<t tx="ekr.20230509083242.689">std::string LLVMVisitor::buildLLVMCodeString(const LLVMFunc *x) {
  auto *funcType = cast&lt;types::FuncType&gt;(x-&gt;getType());
  seqassertn(funcType, "{} is not a function type", *x-&gt;getType());
  std::string bufStr;
  llvm::raw_string_ostream buf(bufStr);

  // build function signature
  buf &lt;&lt; "define ";
  getLLVMType(funcType-&gt;getReturnType())-&gt;print(buf);
  buf &lt;&lt; " @\"" &lt;&lt; getNameForFunction(x) &lt;&lt; "\"(";
  const int numArgs = std::distance(x-&gt;arg_begin(), x-&gt;arg_end());
  int argIndex = 0;
  for (auto it = x-&gt;arg_begin(); it != x-&gt;arg_end(); ++it) {
    getLLVMType((*it)-&gt;getType())-&gt;print(buf);
    buf &lt;&lt; " %" &lt;&lt; (*it)-&gt;getName();
    if (argIndex &lt; numArgs - 1)
      buf &lt;&lt; ", ";
    ++argIndex;
  }
  buf &lt;&lt; ")";
  std::string signature = buf.str();
  bufStr.clear();

  // replace literal '{' and '}'
  std::string::size_type n = 0;
  while ((n = signature.find("{", n)) != std::string::npos) {
    signature.replace(n, 1, "{{");
    n += 2;
  }
  n = 0;
  while ((n = signature.find("}", n)) != std::string::npos) {
    signature.replace(n, 1, "}}");
    n += 2;
  }

  // build remaining code
  auto body = x-&gt;getLLVMBody();
  buf &lt;&lt; x-&gt;getLLVMDeclarations() &lt;&lt; "\n" &lt;&lt; signature &lt;&lt; " {{\n" &lt;&lt; body &lt;&lt; "\n}}";
  return buf.str();
}

</t>
<t tx="ekr.20230509083242.69">#            if color == BLACK:
#                self.board.black_dead += 1
#            else:
#                self.board.white_dead += 1
        for neighbour in self.neighbours:
            if neighbour.color != EMPTY and neighbour.removestamp != TIMESTAMP:
                neighbour_ref = neighbour.find(update)
                if neighbour_ref.pos == reference.pos:
                    neighbour.remove(reference, update)
                else:
                    if update:
                        neighbour_ref.ledges += 1

    def find(self, update=False):
        reference = self.reference
        if reference.pos != self.pos:
            reference = reference.find(update)
            if update:
                self.reference = reference
        return reference

    def __repr__(self):
        return repr(to_xy(self.pos))


</t>
<t tx="ekr.20230509083242.690">void LLVMVisitor::visit(const LLVMFunc *x) {
  func = M-&gt;getFunction(getNameForFunction(x));
  coro = {};
  if (func)
    return;

  // build code
  std::string code = buildLLVMCodeString(x);

  // format code
  fmt::dynamic_format_arg_store&lt;fmt::format_context&gt; store;
  for (auto it = x-&gt;literal_begin(); it != x-&gt;literal_end(); ++it) {
    if (it-&gt;isStatic()) {
      store.push_back(it-&gt;getStaticValue());
    } else if (it-&gt;isStaticStr()) {
      store.push_back(it-&gt;getStaticStringValue());
    } else if (it-&gt;isType()) {
      llvm::Type *llvmType = getLLVMType(it-&gt;getTypeValue());
      std::string bufStr;
      llvm::raw_string_ostream buf(bufStr);
      llvmType-&gt;print(buf);
      store.push_back(buf.str());
    } else {
      seqassertn(0, "formatting failed");
    }
  }
  code = fmt::vformat(code, store);

  llvm::SMDiagnostic err;
  std::unique_ptr&lt;llvm::MemoryBuffer&gt; buf = llvm::MemoryBuffer::getMemBuffer(code);
  seqassertn(buf, "could not create buffer");
  std::unique_ptr&lt;llvm::Module&gt; sub =
      llvm::parseIR(buf-&gt;getMemBufferRef(), err, *context);
  if (!sub) {
    // LOG("-&gt; {}", code);
    std::string bufStr;
    llvm::raw_string_ostream buf(bufStr);
    err.print("LLVM", buf);
    // LOG("-&gt; ERR {}", x-&gt;referenceString());
    // LOG("       {}", code);
    compilationError(fmt::format("{} ({})", buf.str(), x-&gt;getName()));
  }
  sub-&gt;setDataLayout(M-&gt;getDataLayout());

  llvm::Linker L(*M);
  const bool fail = L.linkInModule(std::move(sub));
  seqassertn(!fail, "linking failed");
  func = M-&gt;getFunction(getNameForFunction(x));
  seqassertn(func, "function not linked in");
  func-&gt;setLinkage(llvm::GlobalValue::PrivateLinkage);
  func-&gt;addFnAttr(llvm::Attribute::AttrKind::AlwaysInline);
  func-&gt;setSubprogram(getDISubprogramForFunc(x));

  // set up debug info
  // for now we just set all to func's source location
  auto *srcInfo = getSrcInfo(x);
  for (auto &amp;block : func-&gt;getBasicBlockList()) {
    for (auto &amp;inst : block) {
      if (!inst.getDebugLoc()) {
        inst.setDebugLoc(llvm::DebugLoc(llvm::DILocation::get(
            *context, srcInfo-&gt;line, srcInfo-&gt;col, func-&gt;getSubprogram())));
      }
    }
  }
}

</t>
<t tx="ekr.20230509083242.691">void LLVMVisitor::visit(const BodiedFunc *x) {
  func = M-&gt;getFunction(getNameForFunction(x));
  coro = {};
  seqassertn(func, "{} not inserted", *x);
  setDebugInfoForNode(x);

  auto *fnAttributes = x-&gt;getAttribute&lt;KeyValueAttribute&gt;();
  if (x-&gt;isJIT()) {
    func-&gt;addFnAttr(llvm::Attribute::get(*context, "jit"));
  }
  if (x-&gt;isJIT() || (fnAttributes &amp;&amp; fnAttributes-&gt;has(EXPORT_ATTR))) {
    func-&gt;setLinkage(llvm::GlobalValue::ExternalLinkage);
  } else {
    func-&gt;setLinkage(llvm::GlobalValue::PrivateLinkage);
  }
  if (fnAttributes &amp;&amp; fnAttributes-&gt;has(INLINE_ATTR)) {
    func-&gt;addFnAttr(llvm::Attribute::AttrKind::AlwaysInline);
  }
  if (fnAttributes &amp;&amp; fnAttributes-&gt;has(NOINLINE_ATTR)) {
    func-&gt;addFnAttr(llvm::Attribute::AttrKind::NoInline);
  }
  if (fnAttributes &amp;&amp; fnAttributes-&gt;has(GPU_KERNEL_ATTR)) {
    func-&gt;addFnAttr(llvm::Attribute::AttrKind::NoInline);
    func-&gt;addFnAttr(llvm::Attribute::get(*context, "kernel"));
    func-&gt;setLinkage(llvm::GlobalValue::ExternalLinkage);
  }
  func-&gt;setPersonalityFn(llvm::cast&lt;llvm::Constant&gt;(makePersonalityFunc().getCallee()));

  auto *funcType = cast&lt;types::FuncType&gt;(x-&gt;getType());
  seqassertn(funcType, "{} is not a function type", *x-&gt;getType());
  auto *returnType = funcType-&gt;getReturnType();
  auto *entryBlock = llvm::BasicBlock::Create(*context, "entry", func);
  B-&gt;SetInsertPoint(entryBlock);

  // set up arguments and other symbols
  seqassertn(std::distance(func-&gt;arg_begin(), func-&gt;arg_end()) ==
                 std::distance(x-&gt;arg_begin(), x-&gt;arg_end()),
             "argument length does not match");
  unsigned argIdx = 1;
  auto argIter = func-&gt;arg_begin();
  for (auto varIter = x-&gt;arg_begin(); varIter != x-&gt;arg_end(); ++varIter) {
    const Var *var = *varIter;
    llvm::Value *storage = B-&gt;CreateAlloca(getLLVMType(var-&gt;getType()));
    B-&gt;CreateStore(argIter, storage);
    insertVar(var, storage);

    // debug info
    auto *srcInfo = getSrcInfo(var);
    llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
    llvm::DISubprogram *scope = func-&gt;getSubprogram();
    llvm::DILocalVariable *debugVar = db.builder-&gt;createParameterVariable(
        scope, getDebugNameForVariable(var), argIdx, file, srcInfo-&gt;line,
        getDIType(var-&gt;getType()), db.debug);
    db.builder-&gt;insertDeclare(
        storage, debugVar, db.builder-&gt;createExpression(),
        llvm::DILocation::get(*context, srcInfo-&gt;line, srcInfo-&gt;col, scope),
        entryBlock);

    ++argIter;
    ++argIdx;
  }

  for (auto *var : *x) {
    llvm::Type *llvmType = getLLVMType(var-&gt;getType());
    if (llvmType-&gt;isVoidTy()) {
      insertVar(var, getDummyVoidValue());
    } else {
      llvm::Value *storage = B-&gt;CreateAlloca(llvmType);
      insertVar(var, storage);

      // debug info
      auto *srcInfo = getSrcInfo(var);
      llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
      llvm::DISubprogram *scope = func-&gt;getSubprogram();
      llvm::DILocalVariable *debugVar = db.builder-&gt;createAutoVariable(
          scope, getDebugNameForVariable(var), file, srcInfo-&gt;line,
          getDIType(var-&gt;getType()), db.debug);
      db.builder-&gt;insertDeclare(
          storage, debugVar, db.builder-&gt;createExpression(),
          llvm::DILocation::get(*context, srcInfo-&gt;line, srcInfo-&gt;col, scope),
          entryBlock);
    }
  }

  auto *startBlock = llvm::BasicBlock::Create(*context, "start", func);

  if (x-&gt;isGenerator()) {
    func-&gt;setPresplitCoroutine();
    auto *generatorType = cast&lt;types::GeneratorType&gt;(returnType);
    seqassertn(generatorType, "{} is not a generator type", *returnType);

    llvm::FunctionCallee coroId =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_id);
    llvm::FunctionCallee coroBegin =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_begin);
    llvm::FunctionCallee coroSize = llvm::Intrinsic::getDeclaration(
        M.get(), llvm::Intrinsic::coro_size, {B-&gt;getInt64Ty()});
    llvm::FunctionCallee coroEnd =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_end);
    llvm::FunctionCallee coroAlloc =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_alloc);
    llvm::FunctionCallee coroFree =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_free);

    coro.cleanup = llvm::BasicBlock::Create(*context, "coro.cleanup", func);
    coro.suspend = llvm::BasicBlock::Create(*context, "coro.suspend", func);
    coro.exit = llvm::BasicBlock::Create(*context, "coro.exit", func);
    auto *allocBlock = llvm::BasicBlock::Create(*context, "coro.alloc", func);
    auto *freeBlock = llvm::BasicBlock::Create(*context, "coro.free", func);

    // coro ID and promise
    llvm::Value *id = nullptr;
    llvm::Value *nullPtr = llvm::ConstantPointerNull::get(B-&gt;getInt8PtrTy());
    if (!cast&lt;types::VoidType&gt;(generatorType-&gt;getBase())) {
      coro.promise = B-&gt;CreateAlloca(getLLVMType(generatorType-&gt;getBase()));
      coro.promise-&gt;setName("coro.promise");
      llvm::Value *promiseRaw = B-&gt;CreateBitCast(coro.promise, B-&gt;getInt8PtrTy());
      id = B-&gt;CreateCall(coroId, {B-&gt;getInt32(0), promiseRaw, nullPtr, nullPtr});
    } else {
      id = B-&gt;CreateCall(coroId, {B-&gt;getInt32(0), nullPtr, nullPtr, nullPtr});
    }
    id-&gt;setName("coro.id");
    llvm::Value *needAlloc = B-&gt;CreateCall(coroAlloc, id);
    B-&gt;CreateCondBr(needAlloc, allocBlock, startBlock);

    // coro alloc
    B-&gt;SetInsertPoint(allocBlock);
    llvm::Value *size = B-&gt;CreateCall(coroSize);
    auto allocFunc = makeAllocFunc(/*atomic=*/false);
    llvm::Value *alloc = B-&gt;CreateCall(allocFunc, size);
    B-&gt;CreateBr(startBlock);

    // coro start
    B-&gt;SetInsertPoint(startBlock);
    llvm::PHINode *phi = B-&gt;CreatePHI(B-&gt;getInt8PtrTy(), 2);
    phi-&gt;addIncoming(nullPtr, entryBlock);
    phi-&gt;addIncoming(alloc, allocBlock);
    coro.handle = B-&gt;CreateCall(coroBegin, {id, phi});
    coro.handle-&gt;setName("coro.handle");

    // coro cleanup
    B-&gt;SetInsertPoint(coro.cleanup);
    llvm::Value *mem = B-&gt;CreateCall(coroFree, {id, coro.handle});
    llvm::Value *needFree = B-&gt;CreateIsNotNull(mem);
    B-&gt;CreateCondBr(needFree, freeBlock, coro.suspend);

    // coro free
    B-&gt;SetInsertPoint(freeBlock); // no-op: GC will free automatically
    B-&gt;CreateBr(coro.suspend);

    // coro suspend
    B-&gt;SetInsertPoint(coro.suspend);
    B-&gt;CreateCall(coroEnd, {coro.handle, B-&gt;getFalse()});
    B-&gt;CreateRet(coro.handle);

    // coro exit
    block = coro.exit;
    makeYield(nullptr, /*finalYield=*/true);
    B-&gt;SetInsertPoint(block);
    B-&gt;CreateUnreachable();

    // initial yield
    block = startBlock;
    makeYield(); // coroutine will be initially suspended
  } else {
    B-&gt;CreateBr(startBlock);
    block = startBlock;
  }

  seqassertn(x-&gt;getBody(), "{} has no body [{}]", x-&gt;getName(), x-&gt;getSrcInfo());
  process(x-&gt;getBody());
  B-&gt;SetInsertPoint(block);

  if (x-&gt;isGenerator()) {
    B-&gt;CreateBr(coro.exit);
  } else {
    if (cast&lt;types::VoidType&gt;(returnType)) {
      B-&gt;CreateRetVoid();
    } else {
      B-&gt;CreateRet(llvm::Constant::getNullValue(getLLVMType(returnType)));
    }
  }
}

</t>
<t tx="ekr.20230509083242.692">void LLVMVisitor::visit(const Var *x) { seqassertn(0, "cannot visit var"); }

</t>
<t tx="ekr.20230509083242.693">void LLVMVisitor::visit(const VarValue *x) {
  if (auto *f = cast&lt;Func&gt;(x-&gt;getVar())) {
    value = getFunc(f);
    seqassertn(value, "{} value not found", *x);
  } else {
    llvm::Value *varPtr = getVar(x-&gt;getVar());
    seqassertn(varPtr, "{} value not found", *x);
    B-&gt;SetInsertPoint(block);
    value = B-&gt;CreateLoad(getLLVMType(x-&gt;getType()), varPtr);
  }
}

</t>
<t tx="ekr.20230509083242.694">void LLVMVisitor::visit(const PointerValue *x) {
  llvm::Value *var = getVar(x-&gt;getVar());
  seqassertn(var, "{} variable not found", *x);
  value = var; // note: we don't load the pointer
}

</t>
<t tx="ekr.20230509083242.695">/*
 * Types
 */

llvm::Type *LLVMVisitor::getLLVMType(types::Type *t) {
  if (auto *x = cast&lt;types::IntType&gt;(t)) {
    return B-&gt;getInt64Ty();
  }

  if (auto *x = cast&lt;types::FloatType&gt;(t)) {
    return B-&gt;getDoubleTy();
  }

  if (auto *x = cast&lt;types::Float32Type&gt;(t)) {
    return B-&gt;getFloatTy();
  }

  if (auto *x = cast&lt;types::BoolType&gt;(t)) {
    return B-&gt;getInt8Ty();
  }

  if (auto *x = cast&lt;types::ByteType&gt;(t)) {
    return B-&gt;getInt8Ty();
  }

  if (auto *x = cast&lt;types::VoidType&gt;(t)) {
    return B-&gt;getVoidTy();
  }

  if (auto *x = cast&lt;types::RecordType&gt;(t)) {
    std::vector&lt;llvm::Type *&gt; body;
    for (const auto &amp;field : *x) {
      body.push_back(getLLVMType(field.getType()));
    }
    return llvm::StructType::get(*context, body);
  }

  if (auto *x = cast&lt;types::RefType&gt;(t)) {
    return B-&gt;getInt8PtrTy();
  }

  if (auto *x = cast&lt;types::FuncType&gt;(t)) {
    return getLLVMFuncType(x)-&gt;getPointerTo();
  }

  if (auto *x = cast&lt;types::OptionalType&gt;(t)) {
    if (cast&lt;types::RefType&gt;(x-&gt;getBase())) {
      return getLLVMType(x-&gt;getBase());
    } else {
      return llvm::StructType::get(B-&gt;getInt1Ty(), getLLVMType(x-&gt;getBase()));
    }
  }

  if (auto *x = cast&lt;types::PointerType&gt;(t)) {
    return getLLVMType(x-&gt;getBase())-&gt;getPointerTo();
  }

  if (auto *x = cast&lt;types::GeneratorType&gt;(t)) {
    return B-&gt;getInt8PtrTy();
  }

  if (auto *x = cast&lt;types::IntNType&gt;(t)) {
    return B-&gt;getIntNTy(x-&gt;getLen());
  }

  if (auto *x = cast&lt;types::VectorType&gt;(t)) {
    return llvm::VectorType::get(getLLVMType(x-&gt;getBase()), x-&gt;getCount(),
                                 /*Scalable=*/false);
  }

  if (auto *x = cast&lt;types::UnionType&gt;(t)) {
    auto &amp;layout = M-&gt;getDataLayout();
    llvm::Type *largest = nullptr;
    size_t maxSize = 0;

    for (auto *t : *x) {
      auto *llvmType = getLLVMType(t);
      size_t size = layout.getTypeAllocSizeInBits(llvmType);
      if (!largest || size &gt; maxSize) {
        largest = llvmType;
        maxSize = size;
      }
    }

    if (!largest)
      largest = llvm::StructType::get(*context, {});

    return llvm::StructType::get(*context, {B-&gt;getInt8Ty(), largest});
  }

  if (auto *x = cast&lt;dsl::types::CustomType&gt;(t)) {
    return x-&gt;getBuilder()-&gt;buildType(this);
  }

  seqassertn(0, "unknown type: {}", *t);
  return nullptr;
}

llvm::FunctionType *LLVMVisitor::getLLVMFuncType(types::Type *t) {
  auto *x = cast&lt;types::FuncType&gt;(t);
  seqassertn(x, "input type was not a func type");
  llvm::Type *returnType = getLLVMType(x-&gt;getReturnType());
  std::vector&lt;llvm::Type *&gt; argTypes;
  for (auto *argType : *x) {
    argTypes.push_back(getLLVMType(argType));
  }
  return llvm::FunctionType::get(returnType, argTypes, x-&gt;isVariadic());
}

llvm::DIType *LLVMVisitor::getDITypeHelper(
    types::Type *t, std::unordered_map&lt;std::string, llvm::DICompositeType *&gt; &amp;cache) {
  llvm::Type *type = getLLVMType(t);
  auto &amp;layout = M-&gt;getDataLayout();

  if (auto *x = cast&lt;types::IntType&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type), llvm::dwarf::DW_ATE_signed);
  }

  if (auto *x = cast&lt;types::FloatType&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type), llvm::dwarf::DW_ATE_float);
  }

  if (auto *x = cast&lt;types::Float32Type&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type), llvm::dwarf::DW_ATE_float);
  }

  if (auto *x = cast&lt;types::BoolType&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type), llvm::dwarf::DW_ATE_boolean);
  }

  if (auto *x = cast&lt;types::ByteType&gt;(t)) {
    return db.builder-&gt;createBasicType(x-&gt;getName(),
                                       layout.getTypeAllocSizeInBits(type),
                                       llvm::dwarf::DW_ATE_signed_char);
  }

  if (auto *x = cast&lt;types::VoidType&gt;(t)) {
    return nullptr;
  }

  if (auto *x = cast&lt;types::RecordType&gt;(t)) {
    auto it = cache.find(x-&gt;getName());
    if (it != cache.end()) {
      return it-&gt;second;
    } else {
      auto *structType = llvm::cast&lt;llvm::StructType&gt;(type);
      auto *structLayout = layout.getStructLayout(structType);
      auto *srcInfo = getSrcInfo(x);
      auto *memberInfo = x-&gt;getAttribute&lt;MemberAttribute&gt;();
      llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
      std::vector&lt;llvm::Metadata *&gt; members;

      llvm::DICompositeType *diType = db.builder-&gt;createStructType(
          file, x-&gt;getName(), file, srcInfo-&gt;line, structLayout-&gt;getSizeInBits(),
          /*AlignInBits=*/0, llvm::DINode::FlagZero, /*DerivedFrom=*/nullptr,
          db.builder-&gt;getOrCreateArray(members));

      // prevent infinite recursion on recursive types
      cache.emplace(x-&gt;getName(), diType);

      unsigned memberIdx = 0;
      for (const auto &amp;field : *x) {
        auto *subSrcInfo = srcInfo;
        auto *subFile = file;
        if (memberInfo) {
          auto it = memberInfo-&gt;memberSrcInfo.find(field.getName());
          if (it != memberInfo-&gt;memberSrcInfo.end()) {
            subSrcInfo = &amp;it-&gt;second;
            subFile = db.getFile(subSrcInfo-&gt;file);
          }
        }
        members.push_back(db.builder-&gt;createMemberType(
            diType, field.getName(), subFile, subSrcInfo-&gt;line,
            layout.getTypeAllocSizeInBits(getLLVMType(field.getType())),
            /*AlignInBits=*/0, structLayout-&gt;getElementOffsetInBits(memberIdx),
            llvm::DINode::FlagZero, getDITypeHelper(field.getType(), cache)));
        ++memberIdx;
      }

      db.builder-&gt;replaceArrays(diType, db.builder-&gt;getOrCreateArray(members));
      return diType;
    }
  }

  if (auto *x = cast&lt;types::RefType&gt;(t)) {
    return db.builder-&gt;createReferenceType(llvm::dwarf::DW_TAG_reference_type,
                                           getDITypeHelper(x-&gt;getContents(), cache));
  }

  if (auto *x = cast&lt;types::FuncType&gt;(t)) {
    std::vector&lt;llvm::Metadata *&gt; argTypes = {
        getDITypeHelper(x-&gt;getReturnType(), cache)};
    for (auto *argType : *x) {
      argTypes.push_back(getDITypeHelper(argType, cache));
    }
    return db.builder-&gt;createPointerType(
        db.builder-&gt;createSubroutineType(llvm::MDTuple::get(*context, argTypes)),
        layout.getTypeAllocSizeInBits(type));
  }

  if (auto *x = cast&lt;types::OptionalType&gt;(t)) {
    if (cast&lt;types::RefType&gt;(x-&gt;getBase())) {
      return getDITypeHelper(x-&gt;getBase(), cache);
    } else {
      auto *baseType = getLLVMType(x-&gt;getBase());
      auto *structType = llvm::StructType::get(B-&gt;getInt1Ty(), baseType);
      auto *structLayout = layout.getStructLayout(structType);
      auto *srcInfo = getSrcInfo(x);
      auto i1SizeInBits = layout.getTypeAllocSizeInBits(B-&gt;getInt1Ty());
      auto *i1DebugType =
          db.builder-&gt;createBasicType("i1", i1SizeInBits, llvm::dwarf::DW_ATE_boolean);
      llvm::DIFile *file = db.getFile(srcInfo-&gt;file);
      std::vector&lt;llvm::Metadata *&gt; members;

      llvm::DICompositeType *diType = db.builder-&gt;createStructType(
          file, x-&gt;getName(), file, srcInfo-&gt;line, structLayout-&gt;getSizeInBits(),
          /*AlignInBits=*/0, llvm::DINode::FlagZero, /*DerivedFrom=*/nullptr,
          db.builder-&gt;getOrCreateArray(members));

      members.push_back(db.builder-&gt;createMemberType(
          diType, "has", file, srcInfo-&gt;line, i1SizeInBits,
          /*AlignInBits=*/0, structLayout-&gt;getElementOffsetInBits(0),
          llvm::DINode::FlagZero, i1DebugType));

      members.push_back(db.builder-&gt;createMemberType(
          diType, "val", file, srcInfo-&gt;line, layout.getTypeAllocSizeInBits(baseType),
          /*AlignInBits=*/0, structLayout-&gt;getElementOffsetInBits(1),
          llvm::DINode::FlagZero, getDITypeHelper(x-&gt;getBase(), cache)));

      db.builder-&gt;replaceArrays(diType, db.builder-&gt;getOrCreateArray(members));
      return diType;
    }
  }

  if (auto *x = cast&lt;types::PointerType&gt;(t)) {
    return db.builder-&gt;createPointerType(getDITypeHelper(x-&gt;getBase(), cache),
                                         layout.getTypeAllocSizeInBits(type));
  }

  if (auto *x = cast&lt;types::GeneratorType&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type), llvm::dwarf::DW_ATE_address);
  }

  if (auto *x = cast&lt;types::IntNType&gt;(t)) {
    return db.builder-&gt;createBasicType(
        x-&gt;getName(), layout.getTypeAllocSizeInBits(type),
        x-&gt;isSigned() ? llvm::dwarf::DW_ATE_signed : llvm::dwarf::DW_ATE_unsigned);
  }

  if (auto *x = cast&lt;types::VectorType&gt;(t)) {
    return db.builder-&gt;createBasicType(x-&gt;getName(),
                                       layout.getTypeAllocSizeInBits(type),
                                       llvm::dwarf::DW_ATE_unsigned);
  }

  if (auto *x = cast&lt;types::UnionType&gt;(t)) {
    return db.builder-&gt;createBasicType(x-&gt;getName(),
                                       layout.getTypeAllocSizeInBits(type),
                                       llvm::dwarf::DW_ATE_unsigned);
  }

  if (auto *x = cast&lt;dsl::types::CustomType&gt;(t)) {
    return x-&gt;getBuilder()-&gt;buildDebugType(this);
  }

  seqassertn(0, "unknown type");
  return nullptr;
}

llvm::DIType *LLVMVisitor::getDIType(types::Type *t) {
  std::unordered_map&lt;std::string, llvm::DICompositeType *&gt; cache;
  return getDITypeHelper(t, cache);
}

LLVMVisitor::LoopData *LLVMVisitor::getLoopData(id_t loopId) {
  for (auto &amp;d : loops) {
    if (d.loopId == loopId)
      return &amp;d;
  }
  return nullptr;
}

/*
 * Constants
 */

</t>
<t tx="ekr.20230509083242.696">void LLVMVisitor::visit(const IntConst *x) {
  B-&gt;SetInsertPoint(block);
  value = B-&gt;getInt64(x-&gt;getVal());
}

</t>
<t tx="ekr.20230509083242.697">void LLVMVisitor::visit(const FloatConst *x) {
  B-&gt;SetInsertPoint(block);
  value = llvm::ConstantFP::get(B-&gt;getDoubleTy(), x-&gt;getVal());
}

</t>
<t tx="ekr.20230509083242.698">void LLVMVisitor::visit(const BoolConst *x) {
  B-&gt;SetInsertPoint(block);
  value = B-&gt;getInt8(x-&gt;getVal() ? 1 : 0);
}

</t>
<t tx="ekr.20230509083242.699">void LLVMVisitor::visit(const StringConst *x) {
  B-&gt;SetInsertPoint(block);
  std::string s = x-&gt;getVal();
  auto *strVar =
      new llvm::GlobalVariable(*M, llvm::ArrayType::get(B-&gt;getInt8Ty(), s.length() + 1),
                               /*isConstant=*/true, llvm::GlobalValue::PrivateLinkage,
                               llvm::ConstantDataArray::getString(*context, s), ".str");
  strVar-&gt;setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);
  auto *strType = llvm::StructType::get(B-&gt;getInt64Ty(), B-&gt;getInt8PtrTy());
  llvm::Value *ptr = B-&gt;CreateBitCast(strVar, B-&gt;getInt8PtrTy());
  llvm::Value *len = B-&gt;getInt64(s.length());
  llvm::Value *str = llvm::UndefValue::get(strType);
  str = B-&gt;CreateInsertValue(str, len, 0);
  str = B-&gt;CreateInsertValue(str, ptr, 1);
  value = str;
}

</t>
<t tx="ekr.20230509083242.7">  bool next() {
    chunk.clear();
    while (k &lt;= i) {
      chunk.emplace_back(k++, d);
      if (chunk.size() == chunksize)
        return true;
    }
    return !chunk.empty();
  }
</t>
<t tx="ekr.20230509083242.70">class EmptySet:

    @others
</t>
<t tx="ekr.20230509083242.700">void LLVMVisitor::visit(const dsl::CustomConst *x) {
  x-&gt;getBuilder()-&gt;buildValue(this);
}

</t>
<t tx="ekr.20230509083242.701">/*
 * Control flow
 */

</t>
<t tx="ekr.20230509083242.702">void LLVMVisitor::visit(const SeriesFlow *x) {
  for (auto *value : *x) {
    process(value);
  }
}

</t>
<t tx="ekr.20230509083242.703">void LLVMVisitor::visit(const IfFlow *x) {
  auto *trueBlock = llvm::BasicBlock::Create(*context, "if.true", func);
  auto *falseBlock = llvm::BasicBlock::Create(*context, "if.false", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "if.exit", func);

  process(x-&gt;getCond());
  llvm::Value *cond = value;
  B-&gt;SetInsertPoint(block);
  cond = B-&gt;CreateTrunc(cond, B-&gt;getInt1Ty());
  B-&gt;CreateCondBr(cond, trueBlock, falseBlock);

  block = trueBlock;
  if (x-&gt;getTrueBranch()) {
    process(x-&gt;getTrueBranch());
  }
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(exitBlock);

  block = falseBlock;
  if (x-&gt;getFalseBranch()) {
    process(x-&gt;getFalseBranch());
  }
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(exitBlock);

  block = exitBlock;
}

</t>
<t tx="ekr.20230509083242.704">void LLVMVisitor::visit(const WhileFlow *x) {
  auto *condBlock = llvm::BasicBlock::Create(*context, "while.cond", func);
  auto *bodyBlock = llvm::BasicBlock::Create(*context, "while.body", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "while.exit", func);

  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  block = condBlock;
  process(x-&gt;getCond());
  llvm::Value *cond = value;
  B-&gt;SetInsertPoint(block);
  cond = B-&gt;CreateTrunc(cond, B-&gt;getInt1Ty());
  B-&gt;CreateCondBr(cond, bodyBlock, exitBlock);

  block = bodyBlock;
  enterLoop(
      {/*breakBlock=*/exitBlock, /*continueBlock=*/condBlock, /*loopId=*/x-&gt;getId()});
  process(x-&gt;getBody());
  exitLoop();
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  block = exitBlock;
}

</t>
<t tx="ekr.20230509083242.705">void LLVMVisitor::visit(const ForFlow *x) {
  seqassertn(!x-&gt;isParallel(), "parallel for-loop not lowered");
  llvm::Type *loopVarType = getLLVMType(x-&gt;getVar()-&gt;getType());
  llvm::Value *loopVar = getVar(x-&gt;getVar());
  seqassertn(loopVar, "{} loop variable not found", *x);

  auto *condBlock = llvm::BasicBlock::Create(*context, "for.cond", func);
  auto *bodyBlock = llvm::BasicBlock::Create(*context, "for.body", func);
  auto *cleanupBlock = llvm::BasicBlock::Create(*context, "for.cleanup", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "for.exit", func);

  // LLVM coroutine intrinsics
  // https://prereleases.llvm.org/6.0.0/rc3/docs/Coroutines.html
  llvm::FunctionCallee coroResume =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_resume);
  llvm::FunctionCallee coroDone =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_done);
  llvm::FunctionCallee coroPromise =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_promise);
  llvm::FunctionCallee coroDestroy =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_destroy);

  process(x-&gt;getIter());
  llvm::Value *iter = value;
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  block = condBlock;
  call(coroResume, {iter});
  B-&gt;SetInsertPoint(block);
  llvm::Value *done = B-&gt;CreateCall(coroDone, iter);
  B-&gt;CreateCondBr(done, cleanupBlock, bodyBlock);

  if (!loopVarType-&gt;isVoidTy()) {
    B-&gt;SetInsertPoint(bodyBlock);
    llvm::Value *alignment =
        B-&gt;getInt32(M-&gt;getDataLayout().getPrefTypeAlignment(loopVarType));
    llvm::Value *from = B-&gt;getFalse();
    llvm::Value *promise = B-&gt;CreateCall(coroPromise, {iter, alignment, from});
    llvm::Value *generatedValue = B-&gt;CreateLoad(loopVarType, promise);
    B-&gt;CreateStore(generatedValue, loopVar);
  }

  block = bodyBlock;
  enterLoop(
      {/*breakBlock=*/exitBlock, /*continueBlock=*/condBlock, /*loopId=*/x-&gt;getId()});
  process(x-&gt;getBody());
  exitLoop();
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  B-&gt;SetInsertPoint(cleanupBlock);
  B-&gt;CreateCall(coroDestroy, iter);
  B-&gt;CreateBr(exitBlock);

  block = exitBlock;
}

</t>
<t tx="ekr.20230509083242.706">void LLVMVisitor::visit(const ImperativeForFlow *x) {
  seqassertn(!x-&gt;isParallel(), "parallel for-loop not lowered");
  llvm::Value *loopVar = getVar(x-&gt;getVar());
  seqassertn(loopVar, "{} loop variable not found", *x);
  seqassertn(x-&gt;getStep() != 0, "step cannot be 0");

  auto *condBlock = llvm::BasicBlock::Create(*context, "imp_for.cond", func);
  auto *bodyBlock = llvm::BasicBlock::Create(*context, "imp_for.body", func);
  auto *updateBlock = llvm::BasicBlock::Create(*context, "imp_for.update", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "imp_for.exit", func);

  process(x-&gt;getStart());
  llvm::Value *start = value;

  process(x-&gt;getEnd());
  llvm::Value *end = value;

  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);
  B-&gt;SetInsertPoint(condBlock);

  llvm::PHINode *phi = B-&gt;CreatePHI(B-&gt;getInt64Ty(), 2);
  phi-&gt;addIncoming(start, block);

  llvm::Value *done =
      (x-&gt;getStep() &gt; 0) ? B-&gt;CreateICmpSGE(phi, end) : B-&gt;CreateICmpSLE(phi, end);
  B-&gt;CreateCondBr(done, exitBlock, bodyBlock);

  B-&gt;SetInsertPoint(bodyBlock);
  B-&gt;CreateStore(phi, loopVar);
  block = bodyBlock;

  enterLoop(
      {/*breakBlock=*/exitBlock, /*continueBlock=*/updateBlock, /*loopId=*/x-&gt;getId()});
  process(x-&gt;getBody());
  exitLoop();
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(updateBlock);

  B-&gt;SetInsertPoint(updateBlock);
  phi-&gt;addIncoming(B-&gt;CreateAdd(phi, B-&gt;getInt64(x-&gt;getStep())), updateBlock);
  B-&gt;CreateBr(condBlock);

  block = exitBlock;
}

</t>
<t tx="ekr.20230509083242.707">namespace {
</t>
<t tx="ekr.20230509083242.708">bool anyMatch(types::Type *type, std::vector&lt;types::Type *&gt; types) {
  if (type) {
    for (auto *t : types) {
      if (t &amp;&amp; t-&gt;getName() == type-&gt;getName())
        return true;
    }
  } else {
    for (auto *t : types) {
      if (!t)
        return true;
    }
  }
  return false;
}
</t>
<t tx="ekr.20230509083242.709">} // namespace

</t>
<t tx="ekr.20230509083242.71">def __init__(self, board):
    self.board = board
    self.empties = list(range(SIZE * SIZE))
    self.empty_pos = list(range(SIZE * SIZE))

</t>
<t tx="ekr.20230509083242.710">void LLVMVisitor::visit(const TryCatchFlow *x) {
  const bool isRoot = trycatch.empty();
  const bool supportBreakAndContinue = !loops.empty();
  B-&gt;SetInsertPoint(block);
  auto *entryBlock = llvm::BasicBlock::Create(*context, "trycatch.entry", func);
  B-&gt;CreateBr(entryBlock);

  TryCatchData tc;
  tc.exceptionBlock = llvm::BasicBlock::Create(*context, "trycatch.exception", func);
  tc.exceptionRouteBlock =
      llvm::BasicBlock::Create(*context, "trycatch.exception_route", func);
  tc.finallyBlock = llvm::BasicBlock::Create(*context, "trycatch.finally", func);

  auto *externalExcBlock =
      llvm::BasicBlock::Create(*context, "trycatch.exception_external", func);
  auto *unwindResumeBlock =
      llvm::BasicBlock::Create(*context, "trycatch.unwind_resume", func);
  auto *endBlock = llvm::BasicBlock::Create(*context, "trycatch.end", func);

  B-&gt;SetInsertPoint(func-&gt;getEntryBlock().getTerminator());
  auto *excStateNotThrown = B-&gt;getInt8(TryCatchData::State::NOT_THROWN);
  auto *excStateThrown = B-&gt;getInt8(TryCatchData::State::THROWN);
  auto *excStateCaught = B-&gt;getInt8(TryCatchData::State::CAUGHT);
  auto *excStateReturn = B-&gt;getInt8(TryCatchData::State::RETURN);
  auto *excStateBreak = B-&gt;getInt8(TryCatchData::State::BREAK);
  auto *excStateContinue = B-&gt;getInt8(TryCatchData::State::CONTINUE);

  llvm::StructType *padType = getPadType();
  llvm::StructType *unwindType = llvm::StructType::get(B-&gt;getInt64Ty()); // header only
  llvm::StructType *excType =
      llvm::StructType::get(getTypeInfoType(), B-&gt;getInt8PtrTy());

  if (isRoot) {
    tc.excFlag = B-&gt;CreateAlloca(B-&gt;getInt8Ty());
    tc.catchStore = B-&gt;CreateAlloca(padType);
    tc.delegateDepth = B-&gt;CreateAlloca(B-&gt;getInt64Ty());
    tc.retStore = (coro.exit || func-&gt;getReturnType()-&gt;isVoidTy())
                      ? nullptr
                      : B-&gt;CreateAlloca(func-&gt;getReturnType());
    tc.loopSequence = B-&gt;CreateAlloca(B-&gt;getInt64Ty());
    B-&gt;CreateStore(excStateNotThrown, tc.excFlag);
    B-&gt;CreateStore(llvm::ConstantAggregateZero::get(padType), tc.catchStore);
    B-&gt;CreateStore(B-&gt;getInt64(0), tc.delegateDepth);
    B-&gt;CreateStore(B-&gt;getInt64(-1), tc.loopSequence);
  } else {
    tc.excFlag = trycatch[0].excFlag;
    tc.catchStore = trycatch[0].catchStore;
    tc.delegateDepth = trycatch[0].delegateDepth;
    tc.retStore = trycatch[0].retStore;
    tc.loopSequence = trycatch[0].loopSequence;
  }

  // translate finally
  block = tc.finallyBlock;
  process(x-&gt;getFinally());
  auto *finallyBlock = block;
  B-&gt;SetInsertPoint(finallyBlock);
  llvm::Value *excFlagRead = B-&gt;CreateLoad(B-&gt;getInt8Ty(), tc.excFlag);

  if (!isRoot) {
    llvm::Value *depthRead = B-&gt;CreateLoad(B-&gt;getInt64Ty(), tc.delegateDepth);
    llvm::Value *delegate = B-&gt;CreateICmpSGT(depthRead, B-&gt;getInt64(0));
    auto *finallyNormal =
        llvm::BasicBlock::Create(*context, "trycatch.finally.normal", func);
    auto *finallyDelegate =
        llvm::BasicBlock::Create(*context, "trycatch.finally.delegate", func);
    B-&gt;CreateCondBr(delegate, finallyDelegate, finallyNormal);

    B-&gt;SetInsertPoint(finallyDelegate);
    llvm::Value *depthNew = B-&gt;CreateSub(depthRead, B-&gt;getInt64(1));
    llvm::Value *delegateNew = B-&gt;CreateICmpSGT(depthNew, B-&gt;getInt64(0));
    B-&gt;CreateStore(depthNew, tc.delegateDepth);
    B-&gt;CreateCondBr(delegateNew, trycatch.back().finallyBlock,
                    trycatch.back().exceptionRouteBlock);

    finallyBlock = finallyNormal;
    B-&gt;SetInsertPoint(finallyNormal);
  }

  B-&gt;SetInsertPoint(finallyBlock);
  llvm::SwitchInst *theSwitch =
      B-&gt;CreateSwitch(excFlagRead, endBlock, supportBreakAndContinue ? 5 : 3);
  theSwitch-&gt;addCase(excStateCaught, endBlock);
  theSwitch-&gt;addCase(excStateThrown, unwindResumeBlock);

  if (isRoot) {
    auto *finallyReturn =
        llvm::BasicBlock::Create(*context, "trycatch.finally.return", func);
    theSwitch-&gt;addCase(excStateReturn, finallyReturn);
    B-&gt;SetInsertPoint(finallyReturn);
    if (coro.exit) {
      B-&gt;CreateBr(coro.exit);
    } else if (tc.retStore) {
      llvm::Value *retVal = B-&gt;CreateLoad(func-&gt;getReturnType(), tc.retStore);
      B-&gt;CreateRet(retVal);
    } else {
      B-&gt;CreateRetVoid();
    }
  } else {
    theSwitch-&gt;addCase(excStateReturn, trycatch.back().finallyBlock);
  }

  if (supportBreakAndContinue) {
    auto prevSeq = isRoot ? -1 : trycatch.back().sequenceNumber;

    auto *finallyBreak =
        llvm::BasicBlock::Create(*context, "trycatch.finally.break", func);
    auto *finallyBreakDone =
        llvm::BasicBlock::Create(*context, "trycatch.finally.break.done", func);
    auto *finallyContinue =
        llvm::BasicBlock::Create(*context, "trycatch.finally.continue", func);
    auto *finallyContinueDone =
        llvm::BasicBlock::Create(*context, "trycatch.finally.continue.done", func);

    B-&gt;SetInsertPoint(finallyBreak);
    auto *breakSwitch =
        B-&gt;CreateSwitch(B-&gt;CreateLoad(B-&gt;getInt64Ty(), tc.loopSequence), endBlock, 0);
    B-&gt;SetInsertPoint(finallyBreakDone);
    B-&gt;CreateStore(excStateNotThrown, tc.excFlag);
    auto *breakDoneSwitch =
        B-&gt;CreateSwitch(B-&gt;CreateLoad(B-&gt;getInt64Ty(), tc.loopSequence), endBlock, 0);

    B-&gt;SetInsertPoint(finallyContinue);
    auto *continueSwitch =
        B-&gt;CreateSwitch(B-&gt;CreateLoad(B-&gt;getInt64Ty(), tc.loopSequence), endBlock, 0);
    B-&gt;SetInsertPoint(finallyContinueDone);
    B-&gt;CreateStore(excStateNotThrown, tc.excFlag);
    auto *continueDoneSwitch =
        B-&gt;CreateSwitch(B-&gt;CreateLoad(B-&gt;getInt64Ty(), tc.loopSequence), endBlock, 0);

    for (auto &amp;l : loops) {
      if (!trycatch.empty() &amp;&amp; l.sequenceNumber &lt; prevSeq) {
        breakSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber),
                             trycatch.back().finallyBlock);
        continueSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber),
                                trycatch.back().finallyBlock);
      } else {
        breakSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber), finallyBreakDone);
        breakDoneSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber), l.breakBlock);
        continueSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber), finallyContinueDone);
        continueDoneSwitch-&gt;addCase(B-&gt;getInt64(l.sequenceNumber), l.continueBlock);
      }
    }
    theSwitch-&gt;addCase(excStateBreak, finallyBreak);
    theSwitch-&gt;addCase(excStateContinue, finallyContinue);
  }

  // try and catch translate
  std::vector&lt;const TryCatchFlow::Catch *&gt; catches;
  for (auto &amp;c : *x) {
    catches.push_back(&amp;c);
  }
  llvm::BasicBlock *catchAll = nullptr;

  for (auto *c : catches) {
    auto *catchBlock = llvm::BasicBlock::Create(*context, "trycatch.catch", func);
    tc.catchTypes.push_back(c-&gt;getType());
    tc.handlers.push_back(catchBlock);

    if (!c-&gt;getType()) {
      seqassertn(!catchAll, "cannot be catch all");
      catchAll = catchBlock;
    }
  }

  // translate try
  block = entryBlock;
  enterTryCatch(tc);
  process(x-&gt;getBody());
  exitTryCatch();

  // make sure we always get to finally block
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(tc.finallyBlock);

  // rethrow if uncaught
  B-&gt;SetInsertPoint(unwindResumeBlock);
  B-&gt;CreateResume(B-&gt;CreateLoad(padType, tc.catchStore));

  // make sure we delegate to parent try-catch if necessary
  std::vector&lt;types::Type *&gt; catchTypesFull(tc.catchTypes);
  std::vector&lt;llvm::BasicBlock *&gt; handlersFull(tc.handlers);
  std::vector&lt;unsigned&gt; depths(tc.catchTypes.size(), 0);
  unsigned depth = 1;

  unsigned catchAllDepth = 0;
  for (auto it = trycatch.rbegin(); it != trycatch.rend(); ++it) {
    if (catchAll) // can't ever delegate past catch-all
      break;

    seqassertn(it-&gt;catchTypes.size() == it-&gt;handlers.size(), "handler mismatch");
    for (unsigned i = 0; i &lt; it-&gt;catchTypes.size(); i++) {
      if (!anyMatch(it-&gt;catchTypes[i], catchTypesFull)) {
        catchTypesFull.push_back(it-&gt;catchTypes[i]);
        depths.push_back(depth);

        if (!it-&gt;catchTypes[i] &amp;&amp; !catchAll) {
          // catch-all is in parent; set finally depth
          catchAll =
              llvm::BasicBlock::Create(*context, "trycatch.fdepth_catchall", func);
          B-&gt;SetInsertPoint(catchAll);
          B-&gt;CreateStore(B-&gt;getInt64(depth), tc.delegateDepth);
          B-&gt;CreateBr(it-&gt;handlers[i]);
          handlersFull.push_back(catchAll);
          catchAllDepth = depth;
        } else {
          handlersFull.push_back(it-&gt;handlers[i]);
        }
      }
    }
    ++depth;
  }

  // exception handling
  B-&gt;SetInsertPoint(tc.exceptionBlock);
  llvm::LandingPadInst *caughtResult = B-&gt;CreateLandingPad(padType, catches.size());
  caughtResult-&gt;setCleanup(true);
  std::vector&lt;llvm::Value *&gt; typeIndices;

  for (auto *catchType : catchTypesFull) {
    seqassertn(!catchType || cast&lt;types::RefType&gt;(catchType), "invalid catch type");
    const std::string typeVarName =
        "codon.typeidx." + (catchType ? catchType-&gt;getName() : "&lt;all&gt;");
    llvm::GlobalVariable *tidx = getTypeIdxVar(catchType);
    typeIndices.push_back(tidx);
    caughtResult-&gt;addClause(tidx);
  }

  llvm::Value *unwindException = B-&gt;CreateExtractValue(caughtResult, 0);
  B-&gt;CreateStore(caughtResult, tc.catchStore);
  B-&gt;CreateStore(excStateThrown, tc.excFlag);
  llvm::Value *depthMax = B-&gt;getInt64(trycatch.size());
  B-&gt;CreateStore(depthMax, tc.delegateDepth);

  llvm::Value *unwindExceptionClass = B-&gt;CreateLoad(
      B-&gt;getInt64Ty(),
      B-&gt;CreateStructGEP(
          unwindType, B-&gt;CreatePointerCast(unwindException, unwindType-&gt;getPointerTo()),
          0));

  // check for foreign exceptions
  B-&gt;CreateCondBr(B-&gt;CreateICmpEQ(unwindExceptionClass, B-&gt;getInt64(seq_exc_class())),
                  tc.exceptionRouteBlock, externalExcBlock);

  // external exception (currently assumed to be unreachable)
  B-&gt;SetInsertPoint(externalExcBlock);
  B-&gt;CreateUnreachable();

  // reroute Codon exceptions
  B-&gt;SetInsertPoint(tc.exceptionRouteBlock);
  unwindException = B-&gt;CreateExtractValue(B-&gt;CreateLoad(padType, tc.catchStore), 0);
  llvm::Value *excVal =
      B-&gt;CreatePointerCast(B-&gt;CreateConstGEP1_64(B-&gt;getInt8Ty(), unwindException,
                                                 (uint64_t)seq_exc_offset()),
                           excType-&gt;getPointerTo());

  llvm::Value *loadedExc = B-&gt;CreateLoad(excType, excVal);
  llvm::Value *objType = B-&gt;CreateExtractValue(loadedExc, 0);
  objType = B-&gt;CreateExtractValue(objType, 0);
  llvm::Value *objPtr = B-&gt;CreateExtractValue(loadedExc, 1);

  // set depth when catch-all entered
  auto *defaultRouteBlock = llvm::BasicBlock::Create(*context, "trycatch.fdepth", func);
  B-&gt;SetInsertPoint(defaultRouteBlock);
  if (catchAll)
    B-&gt;CreateStore(B-&gt;getInt64(catchAllDepth), tc.delegateDepth);
  B-&gt;CreateBr(catchAll ? (catchAllDepth &gt; 0 ? tc.finallyBlock : catchAll)
                       : tc.finallyBlock);

  B-&gt;SetInsertPoint(tc.exceptionRouteBlock);
  llvm::SwitchInst *switchToCatchBlock =
      B-&gt;CreateSwitch(objType, defaultRouteBlock, (unsigned)handlersFull.size());
  for (unsigned i = 0; i &lt; handlersFull.size(); i++) {
    // set finally depth
    auto *depthSet = llvm::BasicBlock::Create(*context, "trycatch.fdepth", func);
    B-&gt;SetInsertPoint(depthSet);
    B-&gt;CreateStore(B-&gt;getInt64(depths[i]), tc.delegateDepth);
    B-&gt;CreateBr((i &lt; tc.handlers.size()) ? handlersFull[i] : tc.finallyBlock);

    if (catchTypesFull[i]) {
      switchToCatchBlock-&gt;addCase(B-&gt;getInt32((uint64_t)getTypeIdx(catchTypesFull[i])),
                                  depthSet);
    }

    // translate catch body if this block is ours (vs. a parent's)
    if (i &lt; catches.size()) {
      block = handlersFull[i];
      B-&gt;SetInsertPoint(block);
      const Var *var = catches[i]-&gt;getVar();

      if (var) {
        llvm::Value *obj = B-&gt;CreateBitCast(objPtr, getLLVMType(catches[i]-&gt;getType()));
        llvm::Value *varPtr = getVar(var);
        seqassertn(varPtr, "could not get catch var");
        B-&gt;CreateStore(obj, varPtr);
      }

      B-&gt;CreateStore(excStateCaught, tc.excFlag);
      CatchData cd;
      cd.exception = objPtr;
      cd.typeId = objType;
      enterCatch(cd);
      process(catches[i]-&gt;getHandler());
      exitCatch();
      B-&gt;SetInsertPoint(block);
      B-&gt;CreateBr(tc.finallyBlock);
    }
  }

  block = endBlock;
}

</t>
<t tx="ekr.20230509083242.711">void LLVMVisitor::callStage(const PipelineFlow::Stage *stage) {
  llvm::Value *output = value;
  process(stage-&gt;getCallee());
  llvm::Value *f = value;
  std::vector&lt;llvm::Value *&gt; args;
  for (const auto *arg : *stage) {
    if (arg) {
      process(arg);
      args.push_back(value);
    } else {
      args.push_back(output);
    }
  }

  auto *funcType = getLLVMFuncType(stage-&gt;getCallee()-&gt;getType());
  value = call({funcType, f}, args);
}

</t>
<t tx="ekr.20230509083242.712">void LLVMVisitor::codegenPipeline(
  @others
</t>
<t tx="ekr.20230509083242.713">  const std::vector&lt;const PipelineFlow::Stage *&gt; &amp;stages, unsigned where) {
if (where &gt;= stages.size()) {
  return;
}

auto *stage = stages[where];

if (where == 0) {
  process(stage-&gt;getCallee());
  codegenPipeline(stages, where + 1);
  return;
}

auto *prevStage = stages[where - 1];
const bool generator = prevStage-&gt;isGenerator();

if (generator) {
  auto *generatorType = cast&lt;types::GeneratorType&gt;(prevStage-&gt;getOutputType());
  seqassertn(generatorType, "{} is not a generator type",
             *prevStage-&gt;getOutputType());
  auto *baseType = getLLVMType(generatorType-&gt;getBase());

  auto *condBlock = llvm::BasicBlock::Create(*context, "pipeline.cond", func);
  auto *bodyBlock = llvm::BasicBlock::Create(*context, "pipeline.body", func);
  auto *cleanupBlock = llvm::BasicBlock::Create(*context, "pipeline.cleanup", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "pipeline.exit", func);

  // LLVM coroutine intrinsics
  // https://prereleases.llvm.org/6.0.0/rc3/docs/Coroutines.html
  llvm::FunctionCallee coroResume =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_resume);
  llvm::FunctionCallee coroDone =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_done);
  llvm::FunctionCallee coroPromise =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_promise);
  llvm::FunctionCallee coroDestroy =
      llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_destroy);

  llvm::Value *iter = value;
  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  block = condBlock;
  call(coroResume, {iter});
  B-&gt;SetInsertPoint(block);
  llvm::Value *done = B-&gt;CreateCall(coroDone, iter);
  B-&gt;CreateCondBr(done, cleanupBlock, bodyBlock);

  B-&gt;SetInsertPoint(bodyBlock);
  llvm::Value *alignment =
      B-&gt;getInt32(M-&gt;getDataLayout().getPrefTypeAlignment(baseType));
  llvm::Value *from = B-&gt;getFalse();
  llvm::Value *promise = B-&gt;CreateCall(coroPromise, {iter, alignment, from});
  promise = B-&gt;CreateBitCast(promise, baseType-&gt;getPointerTo());
  value = B-&gt;CreateLoad(baseType, promise);

  block = bodyBlock;
  callStage(stage);
  codegenPipeline(stages, where + 1);

  B-&gt;SetInsertPoint(block);
  B-&gt;CreateBr(condBlock);

  B-&gt;SetInsertPoint(cleanupBlock);
  B-&gt;CreateCall(coroDestroy, iter);
  B-&gt;CreateBr(exitBlock);

  block = exitBlock;
} else {
  callStage(stage);
  codegenPipeline(stages, where + 1);
}
}

</t>
<t tx="ekr.20230509083242.714">void LLVMVisitor::visit(const PipelineFlow *x) {
  std::vector&lt;const PipelineFlow::Stage *&gt; stages;
  for (const auto &amp;stage : *x) {
    stages.push_back(&amp;stage);
  }
  codegenPipeline(stages);
}

</t>
<t tx="ekr.20230509083242.715">void LLVMVisitor::visit(const dsl::CustomFlow *x) {
  B-&gt;SetInsertPoint(block);
  value = x-&gt;getBuilder()-&gt;buildValue(this);
}

</t>
<t tx="ekr.20230509083242.716">/*
 * Instructions
 */

</t>
<t tx="ekr.20230509083242.717">void LLVMVisitor::visit(const AssignInstr *x) {
  llvm::Value *var = getVar(x-&gt;getLhs());
  seqassertn(var, "could not find {} var", *x-&gt;getLhs());
  process(x-&gt;getRhs());
  if (var != getDummyVoidValue()) {
    B-&gt;SetInsertPoint(block);
    B-&gt;CreateStore(value, var);
  }
}

</t>
<t tx="ekr.20230509083242.718">void LLVMVisitor::visit(const ExtractInstr *x) {
  auto *memberedType = cast&lt;types::MemberedType&gt;(x-&gt;getVal()-&gt;getType());
  seqassertn(memberedType, "{} is not a membered type", *x-&gt;getVal()-&gt;getType());
  const int index = memberedType-&gt;getMemberIndex(x-&gt;getField());
  seqassertn(index &gt;= 0, "invalid index");

  process(x-&gt;getVal());
  B-&gt;SetInsertPoint(block);
  if (auto *refType = cast&lt;types::RefType&gt;(memberedType))
    value = B-&gt;CreateLoad(getLLVMType(refType-&gt;getContents()), value);
  value = B-&gt;CreateExtractValue(value, index);
}

</t>
<t tx="ekr.20230509083242.719">void LLVMVisitor::visit(const InsertInstr *x) {
  auto *refType = cast&lt;types::RefType&gt;(x-&gt;getLhs()-&gt;getType());
  seqassertn(refType, "{} is not a reference type", *x-&gt;getLhs()-&gt;getType());
  const int index = refType-&gt;getMemberIndex(x-&gt;getField());
  seqassertn(index &gt;= 0, "invalid index");

  process(x-&gt;getLhs());
  llvm::Value *lhs = value;
  process(x-&gt;getRhs());
  llvm::Value *rhs = value;

  B-&gt;SetInsertPoint(block);
  llvm::Value *load = B-&gt;CreateLoad(getLLVMType(refType-&gt;getContents()), lhs);
  load = B-&gt;CreateInsertValue(load, rhs, index);
  B-&gt;CreateStore(load, lhs);
}

</t>
<t tx="ekr.20230509083242.72">def random_choice(self):
    choices = len(self.empties)
    while choices:
        i = int(random.random() * choices)
        pos = self.empties[i]
        if self.board.useful(pos):
            return pos
        choices -= 1
        self.set(i, self.empties[choices])
        self.set(choices, pos)
    return PASS

</t>
<t tx="ekr.20230509083242.720">void LLVMVisitor::visit(const CallInstr *x) {
  B-&gt;SetInsertPoint(block);
  process(x-&gt;getCallee());
  llvm::Value *f = value;

  std::vector&lt;llvm::Value *&gt; args;
  for (auto *arg : *x) {
    B-&gt;SetInsertPoint(block);
    process(arg);
    args.push_back(value);
  }

  auto *funcType = getLLVMFuncType(x-&gt;getCallee()-&gt;getType());
  value = call({funcType, f}, args);
}

</t>
<t tx="ekr.20230509083242.721">void LLVMVisitor::visit(const TypePropertyInstr *x) {
  B-&gt;SetInsertPoint(block);
  switch (x-&gt;getProperty()) {
  case TypePropertyInstr::Property::SIZEOF:
    value = B-&gt;getInt64(
        M-&gt;getDataLayout().getTypeAllocSize(getLLVMType(x-&gt;getInspectType())));
    break;
  case TypePropertyInstr::Property::IS_ATOMIC:
    value = B-&gt;getInt8(x-&gt;getInspectType()-&gt;isAtomic() ? 1 : 0);
    break;
  case TypePropertyInstr::Property::IS_CONTENT_ATOMIC:
    value = B-&gt;getInt8(x-&gt;getInspectType()-&gt;isContentAtomic() ? 1 : 0);
    break;
  default:
    seqassertn(0, "unknown type property");
  }
}

</t>
<t tx="ekr.20230509083242.722">void LLVMVisitor::visit(const YieldInInstr *x) {
  B-&gt;SetInsertPoint(block);
  if (x-&gt;isSuspending()) {
    llvm::FunctionCallee coroSuspend =
        llvm::Intrinsic::getDeclaration(M.get(), llvm::Intrinsic::coro_suspend);
    llvm::Value *tok = llvm::ConstantTokenNone::get(*context);
    llvm::Value *final = B-&gt;getFalse();
    llvm::Value *susp = B-&gt;CreateCall(coroSuspend, {tok, final});

    block = llvm::BasicBlock::Create(*context, "yieldin.new", func);
    llvm::SwitchInst *inst = B-&gt;CreateSwitch(susp, coro.suspend, 2);
    inst-&gt;addCase(B-&gt;getInt8(0), block);
    inst-&gt;addCase(B-&gt;getInt8(1), coro.cleanup);
    B-&gt;SetInsertPoint(block);
  }
  value = B-&gt;CreateLoad(getLLVMType(x-&gt;getType()), coro.promise);
}

</t>
<t tx="ekr.20230509083242.723">void LLVMVisitor::visit(const StackAllocInstr *x) {
  auto *recordType = cast&lt;types::RecordType&gt;(x-&gt;getType());
  seqassertn(recordType, "stack alloc does not have record type");
  auto *ptrType = cast&lt;types::PointerType&gt;(recordType-&gt;back().getType());
  seqassertn(ptrType, "array did not have ptr type");

  auto *arrayType = llvm::cast&lt;llvm::StructType&gt;(getLLVMType(x-&gt;getType()));
  B-&gt;SetInsertPoint(func-&gt;getEntryBlock().getTerminator());
  llvm::Value *len = B-&gt;getInt64(x-&gt;getCount());
  llvm::Value *ptr = B-&gt;CreateAlloca(getLLVMType(ptrType-&gt;getBase()), len);
  llvm::Value *arr = llvm::UndefValue::get(arrayType);
  arr = B-&gt;CreateInsertValue(arr, len, 0);
  arr = B-&gt;CreateInsertValue(arr, ptr, 1);
  value = arr;
}

</t>
<t tx="ekr.20230509083242.724">void LLVMVisitor::visit(const TernaryInstr *x) {
  auto *trueBlock = llvm::BasicBlock::Create(*context, "ternary.true", func);
  auto *falseBlock = llvm::BasicBlock::Create(*context, "ternary.false", func);
  auto *exitBlock = llvm::BasicBlock::Create(*context, "ternary.exit", func);

  llvm::Type *valueType = getLLVMType(x-&gt;getType());
  process(x-&gt;getCond());
  llvm::Value *cond = value;

  B-&gt;SetInsertPoint(block);
  cond = B-&gt;CreateTrunc(cond, B-&gt;getInt1Ty());
  B-&gt;CreateCondBr(cond, trueBlock, falseBlock);

  block = trueBlock;
  process(x-&gt;getTrueValue());
  llvm::Value *trueValue = value;
  trueBlock = block;
  B-&gt;SetInsertPoint(trueBlock);
  B-&gt;CreateBr(exitBlock);

  block = falseBlock;
  process(x-&gt;getFalseValue());
  llvm::Value *falseValue = value;
  falseBlock = block;
  B-&gt;SetInsertPoint(falseBlock);
  B-&gt;CreateBr(exitBlock);

  B-&gt;SetInsertPoint(exitBlock);
  llvm::PHINode *phi = B-&gt;CreatePHI(valueType, 2);
  phi-&gt;addIncoming(trueValue, trueBlock);
  phi-&gt;addIncoming(falseValue, falseBlock);
  value = phi;
  block = exitBlock;
}

</t>
<t tx="ekr.20230509083242.725">void LLVMVisitor::visit(const BreakInstr *x) {
  seqassertn(!loops.empty(), "not in a loop");
  B-&gt;SetInsertPoint(block);

  auto *loop = !x-&gt;getLoop() ? &amp;loops.back() : getLoopData(x-&gt;getLoop()-&gt;getId());

  if (trycatch.empty() || trycatch.back().sequenceNumber &lt; loop-&gt;sequenceNumber) {
    B-&gt;CreateBr(loop-&gt;breakBlock);
  } else {
    auto *tc = &amp;trycatch.back();
    auto *excStateBreak = B-&gt;getInt8(TryCatchData::State::BREAK);
    B-&gt;CreateStore(excStateBreak, tc-&gt;excFlag);
    B-&gt;CreateStore(B-&gt;getInt64(loop-&gt;sequenceNumber), tc-&gt;loopSequence);
    B-&gt;CreateBr(tc-&gt;finallyBlock);
  }

  block = llvm::BasicBlock::Create(*context, "break.new", func);
}

</t>
<t tx="ekr.20230509083242.726">void LLVMVisitor::visit(const ContinueInstr *x) {
  seqassertn(!loops.empty(), "not in a loop");
  B-&gt;SetInsertPoint(block);
  auto *loop = !x-&gt;getLoop() ? &amp;loops.back() : getLoopData(x-&gt;getLoop()-&gt;getId());

  if (trycatch.empty() || trycatch.back().sequenceNumber &lt; loop-&gt;sequenceNumber) {
    B-&gt;CreateBr(loop-&gt;continueBlock);
  } else {
    auto *tc = &amp;trycatch.back();
    auto *excStateContinue = B-&gt;getInt8(TryCatchData::State::CONTINUE);
    B-&gt;CreateStore(excStateContinue, tc-&gt;excFlag);
    B-&gt;CreateStore(B-&gt;getInt64(loop-&gt;sequenceNumber), tc-&gt;loopSequence);
    B-&gt;CreateBr(tc-&gt;finallyBlock);
  }

  block = llvm::BasicBlock::Create(*context, "continue.new", func);
}

</t>
<t tx="ekr.20230509083242.727">void LLVMVisitor::visit(const ReturnInstr *x) {
  if (x-&gt;getValue()) {
    process(x-&gt;getValue());
  }
  B-&gt;SetInsertPoint(block);
  if (coro.exit) {
    if (auto *tc = getInnermostTryCatch()) {
      auto *excStateReturn = B-&gt;getInt8(TryCatchData::State::RETURN);
      B-&gt;CreateStore(excStateReturn, tc-&gt;excFlag);
      B-&gt;CreateBr(tc-&gt;finallyBlock);
    } else {
      B-&gt;CreateBr(coro.exit);
    }
  } else {
    if (auto *tc = getInnermostTryCatch()) {
      auto *excStateReturn = B-&gt;getInt8(TryCatchData::State::RETURN);
      B-&gt;CreateStore(excStateReturn, tc-&gt;excFlag);
      if (tc-&gt;retStore) {
        seqassertn(value, "no return value storage");
        B-&gt;CreateStore(value, tc-&gt;retStore);
      }
      B-&gt;CreateBr(tc-&gt;finallyBlock);
    } else {
      if (x-&gt;getValue()) {
        B-&gt;CreateRet(value);
      } else {
        B-&gt;CreateRetVoid();
      }
    }
  }
  block = llvm::BasicBlock::Create(*context, "return.new", func);
}

</t>
<t tx="ekr.20230509083242.728">void LLVMVisitor::visit(const YieldInstr *x) {
  if (x-&gt;isFinal()) {
    if (x-&gt;getValue()) {
      seqassertn(coro.promise, "no coroutine promise");
      process(x-&gt;getValue());
      B-&gt;SetInsertPoint(block);
      B-&gt;CreateStore(value, coro.promise);
    }
    B-&gt;SetInsertPoint(block);
    if (auto *tc = getInnermostTryCatch()) {
      auto *excStateReturn = B-&gt;getInt8(TryCatchData::State::RETURN);
      B-&gt;CreateStore(excStateReturn, tc-&gt;excFlag);
      B-&gt;CreateBr(tc-&gt;finallyBlock);
    } else {
      B-&gt;CreateBr(coro.exit);
    }
    block = llvm::BasicBlock::Create(*context, "yield.new", func);
  } else {
    if (x-&gt;getValue()) {
      process(x-&gt;getValue());
      makeYield(value);
    } else {
      makeYield(nullptr);
    }
  }
}

</t>
<t tx="ekr.20230509083242.729">void LLVMVisitor::visit(const ThrowInstr *x) {
  // note: exception header should be set in the frontend
  auto excAllocFunc = makeExcAllocFunc();
  auto throwFunc = makeThrowFunc();
  llvm::Value *obj = nullptr;
  llvm::Value *typ = nullptr;

  if (x-&gt;getValue()) {
    process(x-&gt;getValue());
    obj = value;
    typ = B-&gt;getInt32(getTypeIdx(x-&gt;getValue()-&gt;getType()));
  } else {
    seqassertn(!catches.empty(), "empty raise outside of except block");
    obj = catches.back().exception;
    typ = catches.back().typeId;
  }

  B-&gt;SetInsertPoint(block);
  llvm::Value *exc = B-&gt;CreateCall(excAllocFunc, {typ, obj});
  call(throwFunc, exc);
}

</t>
<t tx="ekr.20230509083242.73">def add(self, pos):
    self.empty_pos[pos] = len(self.empties)
    self.empties.append(pos)

</t>
<t tx="ekr.20230509083242.730">void LLVMVisitor::visit(const FlowInstr *x) {
  process(x-&gt;getFlow());
  process(x-&gt;getValue());
}

</t>
<t tx="ekr.20230509083242.731">void LLVMVisitor::visit(const dsl::CustomInstr *x) {
  B-&gt;SetInsertPoint(block);
  value = x-&gt;getBuilder()-&gt;buildValue(this);
}

</t>
<t tx="ekr.20230509083242.732">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"
#include "codon/cir/llvm/llvm.h"
#include "codon/cir/pyextension.h"
#include "codon/dsl/plugins.h"
#include "codon/util/common.h"

#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace codon {
namespace ir {

@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.733">class LLVMVisitor : public util::ConstVisitor {
private:
  struct CoroData {
    /// Coroutine promise (where yielded values are stored)
    llvm::Value *promise;
    /// Coroutine handle
    llvm::Value *handle;
    /// Coroutine cleanup block
    llvm::BasicBlock *cleanup;
    /// Coroutine suspend block
    llvm::BasicBlock *suspend;
    /// Coroutine exit block
    llvm::BasicBlock *exit;

    void reset() { promise = handle = cleanup = suspend = exit = nullptr; }
  };

  struct NestableData {
    int sequenceNumber;

    NestableData() : sequenceNumber(-1) {}
  };

  struct LoopData : NestableData {
    /// Block to branch to in case of "break"
    llvm::BasicBlock *breakBlock;
    /// Block to branch to in case of "continue"
    llvm::BasicBlock *continueBlock;
    /// Loop id
    id_t loopId;

    LoopData(llvm::BasicBlock *breakBlock, llvm::BasicBlock *continueBlock, id_t loopId)
        : NestableData(), breakBlock(breakBlock), continueBlock(continueBlock),
          loopId(loopId) {}

    void reset() { breakBlock = continueBlock = nullptr; }
  };

  struct TryCatchData : NestableData {
    /// Possible try-catch states when reaching finally block
    enum State { NOT_THROWN = 0, THROWN, CAUGHT, RETURN, BREAK, CONTINUE };
    /// Exception block
    llvm::BasicBlock *exceptionBlock;
    /// Exception route block
    llvm::BasicBlock *exceptionRouteBlock;
    /// Finally start block
    llvm::BasicBlock *finallyBlock;
    /// Try-catch catch types
    std::vector&lt;types::Type *&gt; catchTypes;
    /// Try-catch handlers, corresponding to catch types
    std::vector&lt;llvm::BasicBlock *&gt; handlers;
    /// Exception state flag (see "State")
    llvm::Value *excFlag;
    /// Storage for caught exception
    llvm::Value *catchStore;
    /// How far to delegate up the finally chain
    llvm::Value *delegateDepth;
    /// Storage for postponed return
    llvm::Value *retStore;
    /// Loop being manipulated
    llvm::Value *loopSequence;

    TryCatchData()
        : NestableData(), exceptionBlock(nullptr), exceptionRouteBlock(nullptr),
          finallyBlock(nullptr), catchTypes(), handlers(), excFlag(nullptr),
          catchStore(nullptr), delegateDepth(nullptr), retStore(nullptr),
          loopSequence(nullptr) {}

@others
  /// Constructs an LLVM visitor.
  LLVMVisitor();

  /// @return true if in debug mode, false otherwise
  bool getDebug() const { return db.debug; }
  /// Sets debug status.
  /// @param d true if debug mode
  void setDebug(bool d = true) { db.debug = d; }

  /// @return true if in JIT mode, false otherwise
  bool getJIT() const { return db.jit; }
  /// Sets JIT status.
  /// @param j true if JIT mode
  void setJIT(bool j = true) { db.jit = j; }

  /// @return true if in standalone mode, false otherwise
  bool getStandalone() const { return db.standalone; }
  /// Sets standalone status.
  /// @param s true if standalone
  void setStandalone(bool s = true) { db.standalone = s; }

  /// @return true if capturing outputs, false otherwise
  bool getCapture() const { return db.capture; }
  /// Sets capture status.
  /// @param c true to capture
  void setCapture(bool c = true) { db.capture = c; }

  /// @return program flags
  std::string getFlags() const { return db.flags; }
  /// Sets program flags.
  /// @param f flags
  void setFlags(const std::string &amp;f) { db.flags = f; }

  llvm::LLVMContext &amp;getContext() { return *context; }
  llvm::IRBuilder&lt;&gt; &amp;getBuilder() { return *B; }
  llvm::Module *getModule() { return M.get(); }
  llvm::FunctionCallee getFunc() { return func; }
  llvm::BasicBlock *getBlock() { return block; }
  llvm::Value *getValue() { return value; }
  std::unordered_map&lt;id_t, llvm::Value *&gt; &amp;getVars() { return vars; }
  std::unordered_map&lt;id_t, llvm::Function *&gt; &amp;getFuncs() { return funcs; }
  CoroData &amp;getCoro() { return coro; }
  std::vector&lt;LoopData&gt; &amp;getLoops() { return loops; }
  std::vector&lt;TryCatchData&gt; &amp;getTryCatch() { return trycatch; }
  DebugInfo &amp;getDebugInfo() { return db; }

  void setFunc(llvm::Function *f) { func = f; }
  void setBlock(llvm::BasicBlock *b) { block = b; }
  void setValue(llvm::Value *v) { value = v; }

  /// Registers a new global variable or function with
  /// this visitor.
  /// @param var the global variable (or function) to register
  void registerGlobal(const Var *var);

  /// Returns a new LLVM module initialized for the host
  /// architecture.
  /// @param context LLVM context used for creating module
  /// @param src source information for the new module
  /// @return a new module
  std::unique_ptr&lt;llvm::Module&gt; makeModule(llvm::LLVMContext &amp;context,
                                           const SrcInfo *src = nullptr);

  /// Returns the current module/LLVM context and replaces them
  /// with new, fresh ones. References to variables or functions
  /// from the old module will be included as "external".
  /// @param module the IR module
  /// @param src source information for the new module
  /// @return the current module/context, replaced internally
  std::pair&lt;std::unique_ptr&lt;llvm::Module&gt;, std::unique_ptr&lt;llvm::LLVMContext&gt;&gt;
  takeModule(Module *module, const SrcInfo *src = nullptr);

  /// Sets current debug info based on a given node.
  /// @param node the node whose debug info to use
  void setDebugInfoForNode(const Node *node);

  /// Compiles a given IR node, updating the internal
  /// LLVM value and/or function as a result.
  /// @param node the node to compile
  void process(const Node *node);

  /// Dumps the unoptimized module IR to a file.
  /// @param filename name of file to write IR to
  void dump(const std::string &amp;filename = "_dump.ll");
  /// Writes module as native object file.
  /// @param filename the .o file to write to
  /// @param pic true to write position-independent code
  void writeToObjectFile(const std::string &amp;filename, bool pic = false);
  /// Writes module as LLVM bitcode file.
  /// @param filename the .bc file to write to
  void writeToBitcodeFile(const std::string &amp;filename);
  /// Writes module as LLVM IR file.
  /// @param filename the .ll file to write to
  void writeToLLFile(const std::string &amp;filename, bool optimize = true);
  /// Writes module as native executable. Invokes an
  /// external linker to generate the final executable.
  /// @param filename the file to write to
  /// @param argv0 compiler's argv[0] used to set rpath
  /// @param library whether to make a shared library
  /// @param libs library names to link
  /// @param lflags extra flags to pass linker
  void writeToExecutable(const std::string &amp;filename, const std::string &amp;argv0,
                         bool library = false,
                         const std::vector&lt;std::string&gt; &amp;libs = {},
                         const std::string &amp;lflags = "");
  /// Writes module as Python extension object.
  /// @param pymod extension module
  /// @param filename the file to write to
  void writeToPythonExtension(const PyModule &amp;pymod, const std::string &amp;filename);
  /// Runs optimization passes on module and writes the result
  /// to the specified file. The output type is determined by
  /// the file extension (.ll for LLVM IR, .bc for LLVM bitcode
  /// .o or .obj for object file, other for executable).
  /// @param filename name of the file to write to
  /// @param argv0 compiler's argv[0] used to set rpath
  /// @param libs library names to link to, if creating executable
  /// @param lflags extra flags to pass linker, if creating executable
  void compile(const std::string &amp;filename, const std::string &amp;argv0,
               const std::vector&lt;std::string&gt; &amp;libs = {},
               const std::string &amp;lflags = "");
  /// Runs optimization passes on module and executes it.
  /// @param args vector of arguments to program
  /// @param libs vector of libraries to load
  /// @param envp program environment
  void run(const std::vector&lt;std::string&gt; &amp;args = {},
           const std::vector&lt;std::string&gt; &amp;libs = {},
           const char *const *envp = nullptr);

  /// Gets LLVM type from IR type
  /// @param t the IR type
  /// @return corresponding LLVM type
  llvm::Type *getLLVMType(types::Type *t);
  /// Gets LLVM function type from IR function type
  /// @param t the IR type (must be FuncType)
  /// @return corresponding LLVM function type
  llvm::FunctionType *getLLVMFuncType(types::Type *t);
  /// Gets the LLVM debug info type from the IR type
  /// @param t the IR type
  /// @return corresponding LLVM DI type
  llvm::DIType *getDIType(types::Type *t);
  /// Gets loop data for a given loop id
  /// @param loopId the IR id of the loop
  /// @return the loop's datas
  LoopData *getLoopData(id_t loopId);

  /// Sets the plugin manager
  /// @param p the plugin manager
  void setPluginManager(PluginManager *p) { plugins = p; }
  /// @return the plugin manager
  PluginManager *getPluginManager() { return plugins; }

  void visit(const Module *) override;
  void visit(const BodiedFunc *) override;
  void visit(const ExternalFunc *) override;
  void visit(const InternalFunc *) override;
  void visit(const LLVMFunc *) override;
  void visit(const Var *) override;
  void visit(const VarValue *) override;
  void visit(const PointerValue *) override;

  void visit(const IntConst *) override;
  void visit(const FloatConst *) override;
  void visit(const BoolConst *) override;
  void visit(const StringConst *) override;
  void visit(const dsl::CustomConst *) override;

  void visit(const SeriesFlow *) override;
  void visit(const IfFlow *) override;
  void visit(const WhileFlow *) override;
  void visit(const ForFlow *) override;
  void visit(const ImperativeForFlow *) override;
  void visit(const TryCatchFlow *) override;
  void visit(const PipelineFlow *) override;
  void visit(const dsl::CustomFlow *) override;

  void visit(const AssignInstr *) override;
  void visit(const ExtractInstr *) override;
  void visit(const InsertInstr *) override;
  void visit(const CallInstr *) override;
  void visit(const StackAllocInstr *) override;
  void visit(const TypePropertyInstr *) override;
  void visit(const YieldInInstr *) override;
  void visit(const TernaryInstr *) override;
  void visit(const BreakInstr *) override;
  void visit(const ContinueInstr *) override;
  void visit(const ReturnInstr *) override;
  void visit(const YieldInstr *) override;
  void visit(const ThrowInstr *) override;
  void visit(const FlowInstr *) override;
  void visit(const dsl::CustomInstr *) override;
};

</t>
<t tx="ekr.20230509083242.734">    void reset() {
      exceptionBlock = exceptionRouteBlock = finallyBlock = nullptr;
      catchTypes.clear();
      handlers.clear();
      excFlag = catchStore = delegateDepth = loopSequence = nullptr;
    }
</t>
<t tx="ekr.20230509083242.735">  };

  struct CatchData : NestableData {
    llvm::Value *exception;
    llvm::Value *typeId;
  };

  struct DebugInfo {
    /// LLVM debug info builder
    std::unique_ptr&lt;llvm::DIBuilder&gt; builder;
    /// Current compilation unit
    llvm::DICompileUnit *unit;
    /// Whether we are compiling in debug mode
    bool debug;
    /// Whether we are compiling in JIT mode
    bool jit;
    /// Whether we are compiling a standalone object/executable
    bool standalone;
    /// Whether to capture writes to stdout/stderr
    bool capture;
    /// Program command-line flags
    std::string flags;

    DebugInfo()
        : builder(), unit(nullptr), debug(false), jit(false), standalone(false),
          capture(false), flags() {}

    llvm::DIFile *getFile(const std::string &amp;path);

</t>
<t tx="ekr.20230509083242.736">    void reset() {
      builder = {};
      unit = nullptr;
    }
</t>
<t tx="ekr.20230509083242.737">  };

  /// LLVM context used for compilation
  std::unique_ptr&lt;llvm::LLVMContext&gt; context;
  /// Module we are compiling
  std::unique_ptr&lt;llvm::Module&gt; M;
  /// LLVM IR builder used for constructing LLVM IR
  std::unique_ptr&lt;llvm::IRBuilder&lt;&gt;&gt; B;
  /// Current function we are compiling
  llvm::Function *func;
  /// Current basic block we are compiling
  llvm::BasicBlock *block;
  /// Last compiled value
  llvm::Value *value;
  /// LLVM values corresponding to IR variables
  std::unordered_map&lt;id_t, llvm::Value *&gt; vars;
  /// LLVM functions corresponding to IR functions
  std::unordered_map&lt;id_t, llvm::Function *&gt; funcs;
  /// Coroutine data, if current function is a coroutine
  CoroData coro;
  /// Loop data stack, containing break/continue blocks
  std::vector&lt;LoopData&gt; loops;
  /// Try-catch data stack
  std::vector&lt;TryCatchData&gt; trycatch;
  /// Catch-block data stack
  std::vector&lt;CatchData&gt; catches;
  /// Debug information
  DebugInfo db;
  /// Plugin manager
  PluginManager *plugins;

  llvm::DIType *
  getDITypeHelper(types::Type *t,
                  std::unordered_map&lt;std::string, llvm::DICompositeType *&gt; &amp;cache);

  /// GC allocation functions
  llvm::FunctionCallee makeAllocFunc(bool atomic);
  /// Personality function for exception handling
  llvm::FunctionCallee makePersonalityFunc();
  /// Exception allocation function
  llvm::FunctionCallee makeExcAllocFunc();
  /// Exception throw function
  llvm::FunctionCallee makeThrowFunc();
  /// Program termination function
  llvm::FunctionCallee makeTerminateFunc();

  // Try-catch types and utilities
  llvm::StructType *getTypeInfoType();
  llvm::StructType *getPadType();
  llvm::StructType *getExceptionType();
  llvm::GlobalVariable *getTypeIdxVar(const std::string &amp;name);
  llvm::GlobalVariable *getTypeIdxVar(types::Type *catchType);
  int getTypeIdx(types::Type *catchType = nullptr);

  // General function helpers
  llvm::Value *call(llvm::FunctionCallee callee, llvm::ArrayRef&lt;llvm::Value *&gt; args);
  llvm::Function *makeLLVMFunction(const Func *);
  void makeYield(llvm::Value *value = nullptr, bool finalYield = false);
  std::string buildLLVMCodeString(const LLVMFunc *);
  void callStage(const PipelineFlow::Stage *stage);
  void codegenPipeline(const std::vector&lt;const PipelineFlow::Stage *&gt; &amp;stages,
                       unsigned where = 0);

  // Loop and try-catch state
  void enterLoop(LoopData data);
  void exitLoop();
  void enterTryCatch(TryCatchData data);
  void exitTryCatch();
  void enterCatch(CatchData data);
  void exitCatch();
  TryCatchData *getInnermostTryCatch();
  TryCatchData *getInnermostTryCatchBeforeLoop();

  // Shared library setup
  void setupGlobalCtorForSharedLibrary();

  // Python extension setup
  llvm::Function *createPyTryCatchWrapper(llvm::Function *func);

  // LLVM passes
  void runLLVMPipeline();

  llvm::Value *getVar(const Var *var);
  void insertVar(const Var *var, llvm::Value *x) { vars.emplace(var-&gt;getId(), x); }
  llvm::Function *getFunc(const Func *func);
</t>
<t tx="ekr.20230509083242.738">  void insertFunc(const Func *func, llvm::Function *x) {
    funcs.emplace(func-&gt;getId(), x);
  }
</t>
<t tx="ekr.20230509083242.739">  llvm::Value *getDummyVoidValue() { return llvm::ConstantTokenNone::get(*context); }
  llvm::DISubprogram *getDISubprogramForFunc(const Func *x);
  void clearLLVMData();

public:
  static std::string getNameForFunction(const Func *x);
  static std::string getNameForVar(const Var *x);

</t>
<t tx="ekr.20230509083242.74">def remove(self, pos):
    self.set(self.empty_pos[pos], self.empties[len(self.empties) - 1])
    self.empties.pop()

</t>
<t tx="ekr.20230509083242.740">  static std::string getDebugNameForVariable(const Var *x) {
    std::string name = x-&gt;getName();
    auto pos = name.find(".");
    if (pos != 0 &amp;&amp; pos != std::string::npos) {
      return name.substr(0, pos);
    } else {
      return name;
    }
  }

</t>
<t tx="ekr.20230509083242.741">  static const SrcInfo *getDefaultSrcInfo() {
    static SrcInfo defaultSrcInfo("&lt;internal&gt;", 0, 0, 0);
    return &amp;defaultSrcInfo;
  }

</t>
<t tx="ekr.20230509083242.742">  static const SrcInfo *getSrcInfo(const Node *x) {
    if (auto *srcInfo = x-&gt;getAttribute&lt;SrcInfoAttribute&gt;()) {
      return &amp;srcInfo-&gt;info;
    } else {
      return getDefaultSrcInfo();
    }
  }

</t>
<t tx="ekr.20230509083242.743">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "llvm/ADT/FunctionExtras.h"
#include "llvm/ADT/SmallSet.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/Triple.h"
#include "llvm/Analysis/CallGraph.h"
#include "llvm/Analysis/CallGraphSCCPass.h"
#include "llvm/Analysis/CaptureTracking.h"
#include "llvm/Analysis/LoopPass.h"
#include "llvm/Analysis/RegionPass.h"
#include "llvm/Analysis/TargetLibraryInfo.h"
#include "llvm/Analysis/TargetTransformInfo.h"
#include "llvm/AsmParser/Parser.h"
#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/CodeGen/CommandFlags.h"
#include "llvm/CodeGen/MachineModuleInfo.h"
#include "llvm/CodeGen/TargetPassConfig.h"
#include "llvm/DebugInfo/Symbolize/Symbolize.h"
#include "llvm/ExecutionEngine/ExecutionEngine.h"
#include "llvm/ExecutionEngine/GenericValue.h"
#include "llvm/ExecutionEngine/JITEventListener.h"
#include "llvm/ExecutionEngine/JITLink/JITLink.h"
#include "llvm/ExecutionEngine/JITLink/JITLinkDylib.h"
#include "llvm/ExecutionEngine/JITLink/JITLinkMemoryManager.h"
#include "llvm/ExecutionEngine/JITLink/MemoryFlags.h"
#include "llvm/ExecutionEngine/JITSymbol.h"
#include "llvm/ExecutionEngine/MCJIT.h"
#include "llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h"
#include "llvm/ExecutionEngine/Orc/CompileUtils.h"
#include "llvm/ExecutionEngine/Orc/Core.h"
#include "llvm/ExecutionEngine/Orc/DebugObjectManagerPlugin.h"
#include "llvm/ExecutionEngine/Orc/DebugUtils.h"
#include "llvm/ExecutionEngine/Orc/ELFNixPlatform.h"
#include "llvm/ExecutionEngine/Orc/EPCDebugObjectRegistrar.h"
#include "llvm/ExecutionEngine/Orc/EPCDynamicLibrarySearchGenerator.h"
#include "llvm/ExecutionEngine/Orc/EPCEHFrameRegistrar.h"
#include "llvm/ExecutionEngine/Orc/EPCGenericRTDyldMemoryManager.h"
#include "llvm/ExecutionEngine/Orc/EPCIndirectionUtils.h"
#include "llvm/ExecutionEngine/Orc/ExecutionUtils.h"
#include "llvm/ExecutionEngine/Orc/ExecutorProcessControl.h"
#include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
#include "llvm/ExecutionEngine/Orc/IRTransformLayer.h"
#include "llvm/ExecutionEngine/Orc/JITTargetMachineBuilder.h"
#include "llvm/ExecutionEngine/Orc/LLJIT.h"
#include "llvm/ExecutionEngine/Orc/MachOPlatform.h"
#include "llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h"
#include "llvm/ExecutionEngine/Orc/Shared/AllocationActions.h"
#include "llvm/ExecutionEngine/Orc/Shared/ExecutorAddress.h"
#include "llvm/ExecutionEngine/Orc/SimpleRemoteEPC.h"
#include "llvm/ExecutionEngine/Orc/SymbolStringPool.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/JITLoaderGDB.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/RegisterEHFrames.h"
#include "llvm/ExecutionEngine/Orc/TargetProcess/TargetExecutionUtils.h"
#include "llvm/ExecutionEngine/RuntimeDyld.h"
#include "llvm/ExecutionEngine/SectionMemoryManager.h"
#include "llvm/IR/Argument.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DIBuilder.h"
#include "llvm/IR/DataLayout.h"
#include "llvm/IR/DebugInfo.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/LLVMRemarkStreamer.h"
#include "llvm/IR/LegacyPassManager.h"
#include "llvm/IR/LegacyPassNameParser.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Verifier.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/InitializePasses.h"
#include "llvm/LinkAllIR.h"
#include "llvm/LinkAllPasses.h"
#include "llvm/Linker/Linker.h"
#include "llvm/MC/SubtargetFeature.h"
#include "llvm/MC/TargetRegistry.h"
#include "llvm/Passes/PassBuilder.h"
#include "llvm/Support/Allocator.h"
#include "llvm/Support/Casting.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/DynamicLibrary.h"
#include "llvm/Support/Error.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/FormatVariadic.h"
#include "llvm/Support/Host.h"
#include "llvm/Support/InitLLVM.h"
#include "llvm/Support/Memory.h"
#include "llvm/Support/Process.h"
#include "llvm/Support/RecyclingAllocator.h"
#include "llvm/Support/SourceMgr.h"
#include "llvm/Support/SystemUtils.h"
#include "llvm/Support/TargetSelect.h"
#include "llvm/Support/ToolOutputFile.h"
#include "llvm/Support/YAMLTraits.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetLoweringObjectFile.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Transforms/IPO.h"
#include "llvm/Transforms/IPO/AlwaysInliner.h"
#include "llvm/Transforms/IPO/GlobalDCE.h"
#include "llvm/Transforms/IPO/Internalize.h"
#include "llvm/Transforms/IPO/PassManagerBuilder.h"
#include "llvm/Transforms/IPO/StripDeadPrototypes.h"
#include "llvm/Transforms/IPO/StripSymbols.h"
#include "llvm/Transforms/IPO/WholeProgramDevirt.h"
#include "llvm/Transforms/Utils/Cloning.h"
#include "llvm/Transforms/Utils/Debugify.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.744">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "optimize.h"

#include &lt;algorithm&gt;

#include "codon/cir/llvm/gpu.h"
#include "codon/util/common.h"

static llvm::codegen::RegisterCodeGenFlags CFG;

namespace codon {
namespace ir {

std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Triple triple, llvm::StringRef cpuStr,
                 llvm::StringRef featuresStr, const llvm::TargetOptions &amp;options,
@others
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.745">                 bool pic) {
  std::string err;
  const llvm::Target *target =
      llvm::TargetRegistry::lookupTarget(llvm::codegen::getMArch(), triple, err);

  if (!target)
    return nullptr;

  return std::unique_ptr&lt;llvm::TargetMachine&gt;(target-&gt;createTargetMachine(
      triple.getTriple(), cpuStr, featuresStr, options,
      pic ? llvm::Reloc::Model::PIC_ : llvm::codegen::getExplicitRelocModel(),
      llvm::codegen::getExplicitCodeModel(), llvm::CodeGenOpt::Aggressive));
}

</t>
<t tx="ekr.20230509083242.746">std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Module *module, bool setFunctionAttributes, bool pic) {
  llvm::Triple moduleTriple(module-&gt;getTargetTriple());
  std::string cpuStr, featuresStr;
</t>
<t tx="ekr.20230509083242.747">  const llvm::TargetOptions options =
      llvm::codegen::InitTargetOptionsFromCodeGenFlags(moduleTriple);
  llvm::TargetLibraryInfoImpl tlii(moduleTriple);

  if (moduleTriple.getArch()) {
    cpuStr = llvm::codegen::getCPUStr();
    featuresStr = llvm::codegen::getFeaturesStr();
    auto machine = getTargetMachine(moduleTriple, cpuStr, featuresStr, options);
    if (setFunctionAttributes)
      llvm::codegen::setFunctionAttributes(cpuStr, featuresStr, *module);
    return machine;
  }
</t>
<t tx="ekr.20230509083242.748">  return {};
}

namespace {
</t>
<t tx="ekr.20230509083242.749">void applyDebugTransformations(llvm::Module *module, bool debug, bool jit) {
  if (debug) {
    // remove tail calls and fix linkage for stack traces
    for (auto &amp;f : *module) {
      // needed for debug symbols
      if (!jit)
        f.setLinkage(llvm::GlobalValue::ExternalLinkage);
      if (!f.hasFnAttribute(llvm::Attribute::AttrKind::AlwaysInline))
        f.addFnAttr(llvm::Attribute::AttrKind::NoInline);
      f.setUWTableKind(llvm::UWTableKind::Default);
      f.addFnAttr("no-frame-pointer-elim", "true");
      f.addFnAttr("no-frame-pointer-elim-non-leaf");
      f.addFnAttr("no-jump-tables", "false");

      for (auto &amp;block : f.getBasicBlockList()) {
        for (auto &amp;inst : block) {
          if (auto *call = llvm::dyn_cast&lt;llvm::CallInst&gt;(&amp;inst)) {
            call-&gt;setTailCall(false);
          }
        }
      }
    }
  } else {
    llvm::StripDebugInfo(*module);
  }
}

</t>
<t tx="ekr.20230509083242.75">def set(self, i, pos):
    self.empties[i] = pos
    self.empty_pos[pos] = i


</t>
<t tx="ekr.20230509083242.750">/// Lowers allocations of known, small size to alloca when possible.
/// Also removes unused allocations.
struct AllocationRemover : public llvm::PassInfoMixin&lt;AllocationRemover&gt; {
  std::vector&lt;std::string&gt; allocators;
  std::string realloc;
  std::string free;

  explicit AllocationRemover(
      std::vector&lt;std::string&gt; allocators = {"seq_alloc", "seq_alloc_atomic",
                                             "seq_alloc_uncollectable",
                                             "seq_alloc_atomic_uncollectable"},
</t>
<t tx="ekr.20230509083242.751">      const std::string &amp;realloc = "seq_realloc", const std::string &amp;free = "seq_free")
      : allocators(std::move(allocators)), realloc(realloc), free(free) {}

  static bool sizeOkToDemote(uint64_t size) { return 0 &lt; size &amp;&amp; size &lt;= 1024; }

    @others
</t>
<t tx="ekr.20230509083242.752">  static const llvm::Function *getCalledFunction(const llvm::Value *value) {
// Don't care about intrinsics in this case.
if (llvm::isa&lt;llvm::IntrinsicInst&gt;(value))
  return nullptr;

const auto *cb = llvm::dyn_cast&lt;llvm::CallBase&gt;(value);
if (!cb)
  return nullptr;

if (const llvm::Function *callee = cb-&gt;getCalledFunction())
  return callee;
return nullptr;
  }

</t>
<t tx="ekr.20230509083242.753">  bool isAlloc(const llvm::Value *value) {
    if (auto *func = getCalledFunction(value)) {
      return func-&gt;arg_size() == 1 &amp;&amp; std::find(allocators.begin(), allocators.end(),
                                                func-&gt;getName()) != allocators.end();
    }
    return false;
  }

</t>
<t tx="ekr.20230509083242.754">  bool isRealloc(const llvm::Value *value) {
    if (auto *func = getCalledFunction(value)) {
      return func-&gt;arg_size() == 2 &amp;&amp; func-&gt;getName() == realloc;
    }
    return false;
  }

</t>
<t tx="ekr.20230509083242.755">  bool isFree(const llvm::Value *value) {
    if (auto *func = getCalledFunction(value)) {
      return func-&gt;arg_size() == 1 &amp;&amp; func-&gt;getName() == free;
    }
    return false;
  }

</t>
<t tx="ekr.20230509083242.756">  static bool getFixedArg(llvm::CallBase &amp;cb, uint64_t &amp;size, unsigned idx = 0) {
    if (cb.arg_empty())
      return false;

    if (auto *ci = llvm::dyn_cast&lt;llvm::ConstantInt&gt;(cb.getArgOperand(idx))) {
      size = ci-&gt;getZExtValue();
      return true;
    }

    return false;
  }

</t>
<t tx="ekr.20230509083242.757">  bool isNeverEqualToUnescapedAlloc(llvm::Value *value, llvm::Instruction *ai) {
    using namespace llvm;

    if (isa&lt;ConstantPointerNull&gt;(value))
      return true;
    if (auto *li = dyn_cast&lt;LoadInst&gt;(value))
      return isa&lt;GlobalVariable&gt;(li-&gt;getPointerOperand());
    // Two distinct allocations will never be equal.
    return isAlloc(value) &amp;&amp; value != ai;
  }

</t>
<t tx="ekr.20230509083242.758">  bool isAllocSiteRemovable(llvm::Instruction *ai,
                            llvm::SmallVectorImpl&lt;llvm::WeakTrackingVH&gt; &amp;users) {
    using namespace llvm;

    // Should never be an invoke, so just check right away.
    if (isa&lt;InvokeInst&gt;(ai))
      return false;

    SmallVector&lt;Instruction *, 4&gt; worklist;
    worklist.push_back(ai);

    do {
      Instruction *pi = worklist.pop_back_val();
      for (User *u : pi-&gt;users()) {
        Instruction *instr = cast&lt;Instruction&gt;(u);
        switch (instr-&gt;getOpcode()) {
        default:
          // Give up the moment we see something we can't handle.
          return false;

        case Instruction::AddrSpaceCast:
        case Instruction::BitCast:
        case Instruction::GetElementPtr:
          users.emplace_back(instr);
          worklist.push_back(instr);
          continue;

        case Instruction::ICmp: {
          ICmpInst *cmp = cast&lt;ICmpInst&gt;(instr);
          // We can fold eq/ne comparisons with null to false/true, respectively.
          // We also fold comparisons in some conditions provided the alloc has
          // not escaped (see isNeverEqualToUnescapedAlloc).
          if (!cmp-&gt;isEquality())
            return false;
          unsigned otherIndex = (cmp-&gt;getOperand(0) == pi) ? 1 : 0;
          if (!isNeverEqualToUnescapedAlloc(cmp-&gt;getOperand(otherIndex), ai))
            return false;
          users.emplace_back(instr);
          continue;
        }

        case Instruction::Call:
          // Ignore no-op and store intrinsics.
          if (IntrinsicInst *intrinsic = dyn_cast&lt;IntrinsicInst&gt;(instr)) {
            switch (intrinsic-&gt;getIntrinsicID()) {
            default:
              return false;

            case Intrinsic::memmove:
            case Intrinsic::memcpy:
            case Intrinsic::memset: {
              MemIntrinsic *MI = cast&lt;MemIntrinsic&gt;(intrinsic);
              if (MI-&gt;isVolatile() || MI-&gt;getRawDest() != pi)
                return false;
              LLVM_FALLTHROUGH;
            }
            case Intrinsic::assume:
            case Intrinsic::invariant_start:
            case Intrinsic::invariant_end:
            case Intrinsic::lifetime_start:
            case Intrinsic::lifetime_end:
              users.emplace_back(instr);
              continue;
            case Intrinsic::launder_invariant_group:
            case Intrinsic::strip_invariant_group:
              users.emplace_back(instr);
              worklist.push_back(instr);
              continue;
            }
          }

          if (isFree(instr)) {
            users.emplace_back(instr);
            continue;
          }

          if (isRealloc(instr)) {
            users.emplace_back(instr);
            worklist.push_back(instr);
            continue;
          }

          return false;

        case Instruction::Store: {
          StoreInst *si = cast&lt;StoreInst&gt;(instr);
          if (si-&gt;isVolatile() || si-&gt;getPointerOperand() != pi)
            return false;
          users.emplace_back(instr);
          continue;
        }
        }
        seqassertn(false, "missing a return?");
      }
    } while (!worklist.empty());
    return true;
  }

</t>
<t tx="ekr.20230509083242.759">  bool isAllocSiteDemotable(llvm::Instruction *ai, uint64_t &amp;size,
                            llvm::SmallVectorImpl&lt;llvm::WeakTrackingVH&gt; &amp;users) {
    using namespace llvm;

    // Should never be an invoke, so just check right away.
    if (isa&lt;InvokeInst&gt;(ai))
      return false;

    if (!(getFixedArg(*dyn_cast&lt;CallBase&gt;(&amp;*ai), size) &amp;&amp; sizeOkToDemote(size)))
      return false;

    SmallVector&lt;Instruction *, 4&gt; worklist;
    worklist.push_back(ai);

    do {
      Instruction *pi = worklist.pop_back_val();
      for (User *u : pi-&gt;users()) {
        Instruction *instr = cast&lt;Instruction&gt;(u);
        switch (instr-&gt;getOpcode()) {
        default:
          // Give up the moment we see something we can't handle.
          return false;

        case Instruction::AddrSpaceCast:
        case Instruction::BitCast:
        case Instruction::GetElementPtr:
          worklist.push_back(instr);
          continue;

        case Instruction::ICmp: {
          ICmpInst *cmp = cast&lt;ICmpInst&gt;(instr);
          // We can fold eq/ne comparisons with null to false/true, respectively.
          // We also fold comparisons in some conditions provided the alloc has
          // not escaped (see isNeverEqualToUnescapedAlloc).
          if (!cmp-&gt;isEquality())
            return false;
          unsigned otherIndex = (cmp-&gt;getOperand(0) == pi) ? 1 : 0;
          if (!isNeverEqualToUnescapedAlloc(cmp-&gt;getOperand(otherIndex), ai))
            return false;
          continue;
        }

        case Instruction::Call:
          // Ignore no-op and store intrinsics.
          if (IntrinsicInst *intrinsic = dyn_cast&lt;IntrinsicInst&gt;(instr)) {
            switch (intrinsic-&gt;getIntrinsicID()) {
            default:
              return false;

            case Intrinsic::memmove:
            case Intrinsic::memcpy:
            case Intrinsic::memset: {
              MemIntrinsic *MI = cast&lt;MemIntrinsic&gt;(intrinsic);
              if (MI-&gt;isVolatile())
                return false;
              LLVM_FALLTHROUGH;
            }
            case Intrinsic::assume:
            case Intrinsic::invariant_start:
            case Intrinsic::invariant_end:
            case Intrinsic::lifetime_start:
            case Intrinsic::lifetime_end:
              users.emplace_back(instr);
              continue;
            case Intrinsic::launder_invariant_group:
            case Intrinsic::strip_invariant_group:
              users.emplace_back(instr);
              worklist.push_back(instr);
              continue;
            }
          }

          if (isFree(instr)) {
            users.emplace_back(instr);
            continue;
          }

          if (isRealloc(instr)) {
            // If the realloc also has constant small size,
            // then we can just update the assumed size to be
            // max of original alloc's and this realloc's.
            uint64_t newSize = 0;
            if (getFixedArg(*dyn_cast&lt;CallBase&gt;(instr), newSize, 1) &amp;&amp;
                sizeOkToDemote(newSize)) {
              size = std::max(size, newSize);
            } else {
              return false;
            }

            users.emplace_back(instr);
            worklist.push_back(instr);
            continue;
          }

          return false;

        case Instruction::Store: {
          StoreInst *si = cast&lt;StoreInst&gt;(instr);
          if (si-&gt;isVolatile() || si-&gt;getPointerOperand() != pi)
            return false;
          continue;
        }

        case Instruction::Load: {
          LoadInst *li = cast&lt;LoadInst&gt;(instr);
          if (li-&gt;isVolatile())
            return false;
          continue;
        }
        }
        seqassertn(false, "missing a return?");
      }
    } while (!worklist.empty());
    return true;
  }

</t>
<t tx="ekr.20230509083242.76">class ZobristHash:

    @others
</t>
<t tx="ekr.20230509083242.760">  void getErasesAndReplacementsForAlloc(
      llvm::Instruction &amp;mi, llvm::SmallPtrSetImpl&lt;llvm::Instruction *&gt; &amp;erase,
      llvm::SmallVectorImpl&lt;std::pair&lt;llvm::Instruction *, llvm::Value *&gt;&gt; &amp;replace,
      llvm::SmallVectorImpl&lt;llvm::AllocaInst *&gt; &amp;alloca,
      llvm::SmallVectorImpl&lt;llvm::CallInst *&gt; &amp;untail) {
    using namespace llvm;

    uint64_t size = 0;
    SmallVector&lt;WeakTrackingVH, 64&gt; users;

    if (isAllocSiteRemovable(&amp;mi, users)) {
      for (unsigned i = 0, e = users.size(); i != e; ++i) {
        if (!users[i])
          continue;

        Instruction *instr = cast&lt;Instruction&gt;(&amp;*users[i]);
        if (ICmpInst *cmp = dyn_cast&lt;ICmpInst&gt;(instr)) {
          replace.emplace_back(cmp, ConstantInt::get(Type::getInt1Ty(cmp-&gt;getContext()),
                                                     cmp-&gt;isFalseWhenEqual()));
        } else if (!isa&lt;StoreInst&gt;(instr)) {
          // Casts, GEP, or anything else: we're about to delete this instruction,
          // so it can not have any valid uses.
          replace.emplace_back(instr, PoisonValue::get(instr-&gt;getType()));
        }
        erase.insert(instr);
      }
      erase.insert(&amp;mi);
      return;
    } else {
      users.clear();
    }

    if (isAllocSiteDemotable(&amp;mi, size, users)) {
      auto *replacement = new AllocaInst(
          Type::getInt8Ty(mi.getContext()), 0,
          ConstantInt::get(Type::getInt64Ty(mi.getContext()), size), Align());
      alloca.push_back(replacement);
      replace.emplace_back(&amp;mi, replacement);
      erase.insert(&amp;mi);

      for (unsigned i = 0, e = users.size(); i != e; ++i) {
        if (!users[i])
          continue;

        Instruction *instr = cast&lt;Instruction&gt;(&amp;*users[i]);
        if (isFree(instr)) {
          erase.insert(instr);
        } else if (isRealloc(instr)) {
          replace.emplace_back(instr, replacement);
          erase.insert(instr);
        } else if (auto *ci = dyn_cast&lt;CallInst&gt;(&amp;*instr)) {
          if (ci-&gt;isTailCall() || ci-&gt;isMustTailCall())
            untail.push_back(ci);
        }
      }
    }
  }

</t>
<t tx="ekr.20230509083242.761">  llvm::PreservedAnalyses run(llvm::Function &amp;func, llvm::FunctionAnalysisManager &amp;am) {
    using namespace llvm;

    SmallSet&lt;Instruction *, 32&gt; erase;
    SmallVector&lt;std::pair&lt;Instruction *, llvm::Value *&gt;, 32&gt; replace;
    SmallVector&lt;AllocaInst *, 32&gt; alloca;
    SmallVector&lt;CallInst *, 32&gt; untail;

    for (inst_iterator instr = inst_begin(func), end = inst_end(func); instr != end;
         ++instr) {
      auto *cb = dyn_cast&lt;CallBase&gt;(&amp;*instr);
      if (!cb || !isAlloc(cb))
        continue;

      getErasesAndReplacementsForAlloc(*cb, erase, replace, alloca, untail);
    }

    for (auto *A : alloca) {
      A-&gt;insertBefore(func.getEntryBlock().getFirstNonPHI());
    }

    for (auto *C : untail) {
      C-&gt;setTailCall(false);
    }

    for (auto &amp;P : replace) {
      P.first-&gt;replaceAllUsesWith(P.second);
    }

    for (auto *I : erase) {
      I-&gt;dropAllReferences();
    }

    for (auto *I : erase) {
      I-&gt;eraseFromParent();
    }

    if (!erase.empty() || !replace.empty() || !alloca.empty() || !untail.empty())
      return PreservedAnalyses::none();
    else
      return PreservedAnalyses::all();
  }
};

/// Sometimes coroutine lowering produces hard-to-analyze loops involving
/// function pointer comparisons. This pass puts them into a somewhat
/// easier-to-analyze form.
struct CoroBranchSimplifier : public llvm::PassInfoMixin&lt;CoroBranchSimplifier&gt; {
</t>
<t tx="ekr.20230509083242.762">  static llvm::Value *getNonNullOperand(llvm::Value *op1, llvm::Value *op2) {
    auto *ptr = llvm::dyn_cast&lt;llvm::PointerType&gt;(op1-&gt;getType());
    if (!ptr)
      return nullptr;

    auto *c1 = llvm::dyn_cast&lt;llvm::Constant&gt;(op1);
    auto *c2 = llvm::dyn_cast&lt;llvm::Constant&gt;(op2);
    const bool isNull1 = (c1 &amp;&amp; c1-&gt;isNullValue());
    const bool isNull2 = (c2 &amp;&amp; c2-&gt;isNullValue());
    if (!(isNull1 ^ isNull2))
      return nullptr;
    return isNull1 ? op2 : op1;
  }

</t>
<t tx="ekr.20230509083242.763">  llvm::PreservedAnalyses run(llvm::Loop &amp;loop, llvm::LoopAnalysisManager &amp;am,
                              llvm::LoopStandardAnalysisResults &amp;ar,
                              llvm::LPMUpdater &amp;u) {
    if (auto *exit = loop.getExitingBlock()) {
      if (auto *br = llvm::dyn_cast&lt;llvm::BranchInst&gt;(exit-&gt;getTerminator())) {
        if (!br-&gt;isConditional() || br-&gt;getNumSuccessors() != 2 ||
            loop.contains(br-&gt;getSuccessor(0)) || !loop.contains(br-&gt;getSuccessor(1)))
          return llvm::PreservedAnalyses::all();

        auto *cond = br-&gt;getCondition();
        if (auto *cmp = llvm::dyn_cast&lt;llvm::CmpInst&gt;(cond)) {
          if (cmp-&gt;getPredicate() != llvm::CmpInst::Predicate::ICMP_EQ)
            return llvm::PreservedAnalyses::all();

          if (auto *f = getNonNullOperand(cmp-&gt;getOperand(0), cmp-&gt;getOperand(1))) {
            if (auto *sel = llvm::dyn_cast&lt;llvm::SelectInst&gt;(f)) {
              if (auto *g =
                      getNonNullOperand(sel-&gt;getTrueValue(), sel-&gt;getFalseValue())) {
                // If we can deduce that g is not null, we can replace the condition.
                if (auto *phi = llvm::dyn_cast&lt;llvm::PHINode&gt;(g)) {
                  bool ok = true;
                  for (unsigned i = 0; i &lt; phi-&gt;getNumIncomingValues(); i++) {
                    auto *phiBlock = phi-&gt;getIncomingBlock(i);
                    auto *phiValue = phi-&gt;getIncomingValue(i);

                    if (auto *c = llvm::dyn_cast&lt;llvm::Constant&gt;(phiValue)) {
                      if (c-&gt;isNullValue()) {
                        ok = false;
                        break;
                      }
                    } else {
                      // There is no way for the value to be null if the incoming phi
                      // value is predicated on this exit condition, which checks for a
                      // non-null function pointer.

                      if (phiBlock != exit || phiValue != f) {
                        ok = false;
                        break;
                      }
                    }
                  }
                  if (!ok)
                    return llvm::PreservedAnalyses::all();

                  br-&gt;setCondition(sel-&gt;getCondition());
                  return llvm::PreservedAnalyses::none();
                }
              }
            }
          }
        }
      }
    }
    return llvm::PreservedAnalyses::all();
  }
};

</t>
<t tx="ekr.20230509083242.764">void runLLVMOptimizationPasses(llvm::Module *module, bool debug, bool jit,
                               PluginManager *plugins) {
  applyDebugTransformations(module, debug, jit);

  llvm::LoopAnalysisManager lam;
  llvm::FunctionAnalysisManager fam;
  llvm::CGSCCAnalysisManager cgam;
  llvm::ModuleAnalysisManager mam;
  auto machine = getTargetMachine(module, /*setFunctionAttributes=*/true);
  llvm::PassBuilder pb(machine.get());

  llvm::Triple moduleTriple(module-&gt;getTargetTriple());
  llvm::TargetLibraryInfoImpl tlii(moduleTriple);
  fam.registerPass([&amp;] { return llvm::TargetLibraryAnalysis(tlii); });

  pb.registerModuleAnalyses(mam);
  pb.registerCGSCCAnalyses(cgam);
  pb.registerFunctionAnalyses(fam);
  pb.registerLoopAnalyses(lam);
  pb.crossRegisterProxies(lam, fam, cgam, mam);

  pb.registerLateLoopOptimizationsEPCallback(
      [&amp;](llvm::LoopPassManager &amp;pm, llvm::OptimizationLevel opt) {
        if (opt.isOptimizingForSpeed())
          pm.addPass(CoroBranchSimplifier());
      });

  pb.registerPeepholeEPCallback(
      [&amp;](llvm::FunctionPassManager &amp;pm, llvm::OptimizationLevel opt) {
        if (opt.isOptimizingForSpeed())
          pm.addPass(AllocationRemover());
      });

  if (plugins) {
    for (auto *plugin : *plugins) {
      plugin-&gt;dsl-&gt;addLLVMPasses(&amp;pb, debug);
    }
  }

  if (debug) {
    llvm::ModulePassManager mpm =
        pb.buildO0DefaultPipeline(llvm::OptimizationLevel::O0);
    mpm.run(*module, mam);
  } else {
    llvm::ModulePassManager mpm =
        pb.buildPerModuleDefaultPipeline(llvm::OptimizationLevel::O3);
    mpm.run(*module, mam);
  }

  applyDebugTransformations(module, debug, jit);
}

</t>
<t tx="ekr.20230509083242.765">void verify(llvm::Module *module) {
  const bool broken = llvm::verifyModule(*module, &amp;llvm::errs());
  seqassertn(!broken, "module broken");
}

</t>
<t tx="ekr.20230509083242.766">} // namespace

</t>
<t tx="ekr.20230509083242.767">void optimize(llvm::Module *module, bool debug, bool jit, PluginManager *plugins) {
  verify(module);
  {
    TIME("llvm/opt1");
    runLLVMOptimizationPasses(module, debug, jit, plugins);
  }
  if (!debug) {
    TIME("llvm/opt2");
    runLLVMOptimizationPasses(module, debug, jit, plugins);
  }
  {
    TIME("llvm/gpu");
    applyGPUTransformations(module);
  }
  verify(module);
}

</t>
<t tx="ekr.20230509083242.768">@path C:/Repos/codon/codon/cir/llvm/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/dsl/plugins.h"

namespace codon {
namespace ir {
std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Triple triple, llvm::StringRef cpuStr,
                 llvm::StringRef featuresStr, const llvm::TargetOptions &amp;options,
                 bool pic = false);

std::unique_ptr&lt;llvm::TargetMachine&gt;
getTargetMachine(llvm::Module *module, bool setFunctionAttributes = false,
                 bool pic = false);

void optimize(llvm::Module *module, bool debug, bool jit = false,
              PluginManager *plugins = nullptr);
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.769"></t>
<t tx="ekr.20230509083242.77">def __init__(self, board):
    self.board = board
    self.hash_set = set()
    self.hash = 0
    for square in self.board.squares:
        self.hash ^= square.zobrist_strings[EMPTY]
    self.hash_set.clear()
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509083242.770">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "manager.h"

#include &lt;unordered_set&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/analyze/dataflow/capture.h"
#include "codon/cir/analyze/dataflow/cfg.h"
#include "codon/cir/analyze/dataflow/dominator.h"
#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/analyze/module/global_vars.h"
#include "codon/cir/analyze/module/side_effect.h"
#include "codon/cir/transform/folding/folding.h"
#include "codon/cir/transform/lowering/imperative.h"
#include "codon/cir/transform/lowering/pipeline.h"
#include "codon/cir/transform/manager.h"
#include "codon/cir/transform/parallel/openmp.h"
#include "codon/cir/transform/pass.h"
#include "codon/cir/transform/pythonic/dict.h"
#include "codon/cir/transform/pythonic/generator.h"
#include "codon/cir/transform/pythonic/io.h"
#include "codon/cir/transform/pythonic/list.h"
#include "codon/cir/transform/pythonic/str.h"
#include "codon/util/common.h"

namespace codon {
namespace ir {
namespace transform {

std::string PassManager::KeyManager::getUniqueKey(const std::string &amp;key) {
  // make sure we can't ever produce duplicate "unique'd" keys
  seqassertn(key.find(':') == std::string::npos,
             "pass key '{}' contains invalid character ':'", key);
  auto it = keys.find(key);
  if (it == keys.end()) {
    keys.emplace(key, 1);
    return key;
  } else {
    auto id = ++(it-&gt;second);
    return key + ":" + std::to_string(id);
  }
}

std::string PassManager::registerPass(std::unique_ptr&lt;Pass&gt; pass,
@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.771">                                      const std::string &amp;insertBefore,
                                      std::vector&lt;std::string&gt; reqs,
                                      std::vector&lt;std::string&gt; invalidates) {
  std::string key = pass-&gt;getKey();
  if (isDisabled(key))
    return "";
  key = km.getUniqueKey(key);

  for (const auto &amp;req : reqs) {
    seqassertn(deps.find(req) != deps.end(), "required key '{}' not found", req);
    deps[req].push_back(key);
  }

  passes.insert(std::make_pair(
      key, PassMetadata(std::move(pass), std::move(reqs), std::move(invalidates))));
  passes[key].pass-&gt;setManager(this);
  if (insertBefore.empty()) {
    executionOrder.push_back(key);
  } else {
    auto it = std::find(executionOrder.begin(), executionOrder.end(), insertBefore);
    seqassertn(it != executionOrder.end(), "pass with key '{}' not found in manager",
               insertBefore);
    executionOrder.insert(it, key);
  }
  return key;
}

</t>
<t tx="ekr.20230509083242.772">std::string PassManager::registerAnalysis(std::unique_ptr&lt;analyze::Analysis&gt; analysis,
                                          std::vector&lt;std::string&gt; reqs) {

  std::string key = analysis-&gt;getKey();
  if (isDisabled(key))
    return "";
  key = km.getUniqueKey(key);

  for (const auto &amp;req : reqs) {
    seqassertn(deps.find(req) != deps.end(), "required key '{}' not found", req);
    deps[req].push_back(key);
  }

  analyses.insert(
      std::make_pair(key, AnalysisMetadata(std::move(analysis), std::move(reqs))));
  analyses[key].analysis-&gt;setManager(this);
  deps[key] = {};
  return key;
}

</t>
<t tx="ekr.20230509083242.773">void PassManager::run(Module *module) {
  for (auto &amp;p : executionOrder) {
    runPass(module, p);
  }
}

</t>
<t tx="ekr.20230509083242.774">void PassManager::runPass(Module *module, const std::string &amp;name) {
  auto &amp;meta = passes[name];

  auto run = true;
  auto it = 0;

  while (run) {
    for (auto &amp;dep : meta.reqs) {
      runAnalysis(module, dep);
    }

    Timer timer("  ir pass    : " + meta.pass-&gt;getKey());
    meta.pass-&gt;run(module);
    timer.log();

    for (auto &amp;inv : meta.invalidates)
      invalidate(inv);

    run = meta.pass-&gt;shouldRepeat(++it);
  }
}

</t>
<t tx="ekr.20230509083242.775">void PassManager::runAnalysis(Module *module, const std::string &amp;name) {
  if (results.find(name) != results.end())
    return;

  auto &amp;meta = analyses[name];
  for (auto &amp;dep : meta.reqs) {
    runAnalysis(module, dep);
  }

  Timer timer("  ir analysis: " + meta.analysis-&gt;getKey());
  results[name] = meta.analysis-&gt;run(module);
  timer.log();
}

</t>
<t tx="ekr.20230509083242.776">void PassManager::invalidate(const std::string &amp;key) {
  std::unordered_set&lt;std::string&gt; open = {key};

  while (!open.empty()) {
    std::unordered_set&lt;std::string&gt; newOpen;
    for (const auto &amp;k : open) {
      if (results.find(k) != results.end()) {
        results.erase(k);
        newOpen.insert(deps[k].begin(), deps[k].end());
      }
    }
    open = std::move(newOpen);
  }
}

</t>
<t tx="ekr.20230509083242.777">void PassManager::registerStandardPasses(PassManager::Init init) {
  switch (init) {
  case Init::EMPTY:
    break;
  case Init::DEBUG: {
    registerPass(std::make_unique&lt;lowering::PipelineLowering&gt;());
    registerPass(std::make_unique&lt;lowering::ImperativeForFlowLowering&gt;());
    registerPass(std::make_unique&lt;parallel::OpenMPPass&gt;());
    break;
  }
  case Init::RELEASE:
  case Init::JIT: {
    // Pythonic
    registerPass(std::make_unique&lt;pythonic::DictArithmeticOptimization&gt;());
    registerPass(std::make_unique&lt;pythonic::ListAdditionOptimization&gt;());
    registerPass(std::make_unique&lt;pythonic::StrAdditionOptimization&gt;());
    registerPass(std::make_unique&lt;pythonic::GeneratorArgumentOptimization&gt;());
    registerPass(std::make_unique&lt;pythonic::IOCatOptimization&gt;());

    // lowering
    registerPass(std::make_unique&lt;lowering::PipelineLowering&gt;());
    registerPass(std::make_unique&lt;lowering::ImperativeForFlowLowering&gt;());

    // folding
    auto cfgKey = registerAnalysis(std::make_unique&lt;analyze::dataflow::CFAnalysis&gt;());
    auto rdKey = registerAnalysis(
        std::make_unique&lt;analyze::dataflow::RDAnalysis&gt;(cfgKey), {cfgKey});
    auto domKey = registerAnalysis(
        std::make_unique&lt;analyze::dataflow::DominatorAnalysis&gt;(cfgKey), {cfgKey});
    auto capKey = registerAnalysis(
        std::make_unique&lt;analyze::dataflow::CaptureAnalysis&gt;(rdKey, domKey),
        {rdKey, domKey});
    auto globalKey =
        registerAnalysis(std::make_unique&lt;analyze::module::GlobalVarsAnalyses&gt;());
    auto seKey1 =
        registerAnalysis(std::make_unique&lt;analyze::module::SideEffectAnalysis&gt;(
                             capKey,
                             /*globalAssignmentHasSideEffects=*/true),
                         {capKey});
    auto seKey2 =
        registerAnalysis(std::make_unique&lt;analyze::module::SideEffectAnalysis&gt;(
                             capKey,
                             /*globalAssignmentHasSideEffects=*/false),
                         {capKey});
  @others
    break;
  }
  default:
    seqassertn(false, "unknown PassManager init value");
  }
}

</t>
<t tx="ekr.20230509083242.778">  registerPass(std::make_unique&lt;folding::FoldingPassGroup&gt;(
                   seKey1, rdKey, globalKey, /*repeat=*/5, /*runGlobalDemoton=*/false,
                   pyNumerics),
               /*insertBefore=*/"", {seKey1, rdKey, globalKey},
               {seKey1, rdKey, cfgKey, globalKey, capKey});

    @others
</t>
<t tx="ekr.20230509083242.779">    // parallel
    registerPass(std::make_unique&lt;parallel::OpenMPPass&gt;(), /*insertBefore=*/"", {},
           {cfgKey, globalKey});

    if (init != Init::JIT) {
// Don't demote globals in JIT mode, since they might be used later
// by another user input.
registerPass(std::make_unique&lt;folding::FoldingPassGroup&gt;(
                 seKey2, rdKey, globalKey,
                 /*repeat=*/5,
                 /*runGlobalDemoton=*/true, pyNumerics),
             /*insertBefore=*/"", {seKey2, rdKey, globalKey},
             {seKey2, rdKey, cfgKey, globalKey});
    }
</t>
<t tx="ekr.20230509083242.78">def update(self, square, color):
    self.hash ^= square.zobrist_strings[square.color]
    self.hash ^= square.zobrist_strings[color]

</t>
<t tx="ekr.20230509083242.780">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/analyze/analysis.h"
#include "codon/cir/module.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.781">/// Utility class to run a series of passes.
class PassManager {
private:
@others
private:
  void runPass(Module *module, const std::string &amp;name);
  void registerStandardPasses(Init init);
  void runAnalysis(Module *module, const std::string &amp;name);
  void invalidate(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509083242.782">  /// Manager for keys of passes.
  class KeyManager {
  private:
    /// mapping of raw key to number of occurences
    std::unordered_map&lt;std::string, int&gt; keys;

  public:
    KeyManager() = default;
    /// Returns a unique'd key for a given raw key.
    /// Does so by appending ":&lt;number&gt;" if the key
    /// has been seen.
    /// @param key the raw key
    /// @return the unique'd key
    std::string getUniqueKey(const std::string &amp;key);
  };

</t>
<t tx="ekr.20230509083242.783">  /// Container for pass metadata.
  struct PassMetadata {
    /// pointer to the pass instance
    std::unique_ptr&lt;Pass&gt; pass;
    /// vector of required analyses
    std::vector&lt;std::string&gt; reqs;
    /// vector of invalidated analyses
    std::vector&lt;std::string&gt; invalidates;

    PassMetadata() = default;
    PassMetadata(std::unique_ptr&lt;Pass&gt; pass, std::vector&lt;std::string&gt; reqs,
                 std::vector&lt;std::string&gt; invalidates)
        : pass(std::move(pass)), reqs(std::move(reqs)),
          invalidates(std::move(invalidates)) {}
    PassMetadata(PassMetadata &amp;&amp;) = default;

    PassMetadata &amp;operator=(PassMetadata &amp;&amp;) = default;
  };

  /// Container for analysis metadata.
  struct AnalysisMetadata {
    /// pointer to the analysis instance
    std::unique_ptr&lt;analyze::Analysis&gt; analysis;
    /// vector of required analyses
    std::vector&lt;std::string&gt; reqs;
    /// vector of invalidated analyses
    std::vector&lt;std::string&gt; invalidates;

    AnalysisMetadata() = default;
    AnalysisMetadata(std::unique_ptr&lt;analyze::Analysis&gt; analysis,
                     std::vector&lt;std::string&gt; reqs)
        : analysis(std::move(analysis)), reqs(std::move(reqs)) {}
    AnalysisMetadata(AnalysisMetadata &amp;&amp;) = default;

    AnalysisMetadata &amp;operator=(AnalysisMetadata &amp;&amp;) = default;
  };

  /// key manager to handle duplicate keys (i.e. passes being added twice)
  KeyManager km;

  /// map of keys to passes
  std::unordered_map&lt;std::string, PassMetadata&gt; passes;
  /// map of keys to analyses
  std::unordered_map&lt;std::string, AnalysisMetadata&gt; analyses;
  /// reverse dependency map
  std::unordered_map&lt;std::string, std::vector&lt;std::string&gt;&gt; deps;

  /// execution order of passes
  std::vector&lt;std::string&gt; executionOrder;
  /// map of valid analysis results
  std::unordered_map&lt;std::string, std::unique_ptr&lt;analyze::Result&gt;&gt; results;

  /// passes to avoid registering
  std::vector&lt;std::string&gt; disabled;

  /// whether to use Python (vs. C) numeric semantics in passes
  bool pyNumerics;

  /// true if we are compiling as a Python extension
  bool pyExtension;

public:
  /// PassManager initialization mode.
  enum Init {
    EMPTY,
    DEBUG,
    RELEASE,
    JIT,
  };

  explicit PassManager(Init init, std::vector&lt;std::string&gt; disabled = {},
</t>
<t tx="ekr.20230509083242.784">                       bool pyNumerics = false, bool pyExtension = false)
      : km(), passes(), analyses(), executionOrder(), results(),
        disabled(std::move(disabled)), pyNumerics(pyNumerics),
        pyExtension(pyExtension) {
    registerStandardPasses(init);
  }

</t>
<t tx="ekr.20230509083242.785">  explicit PassManager(bool debug = false, std::vector&lt;std::string&gt; disabled = {},
</t>
<t tx="ekr.20230509083242.786">                       bool pyNumerics = false, bool pyExtension = false)
      : PassManager(debug ? Init::DEBUG : Init::RELEASE, std::move(disabled),
                    pyNumerics, pyExtension) {}

    @others
</t>
<t tx="ekr.20230509083242.787">  /// Checks if the given pass is included in this manager.
  /// @param key the pass key
  /// @return true if manager has the given pass
  bool hasPass(const std::string &amp;key) {
for (auto &amp;pair : passes) {
  if (pair.first == key)
    return true;
}
return false;
  }

</t>
<t tx="ekr.20230509083242.788">  /// Checks if the given analysis is included in this manager.
  /// @param key the analysis key
  /// @return true if manager has the given analysis
  bool hasAnalysis(const std::string &amp;key) {
    for (auto &amp;pair : analyses) {
      if (pair.first == key)
        return true;
    }
    return false;
  }

</t>
<t tx="ekr.20230509083242.789">  /// Registers a pass and appends it to the execution order.
  /// @param pass the pass
  /// @param insertBefore insert pass before the pass with this given key
  /// @param reqs keys of passes that must be run before the current one
  /// @param invalidates keys of passes that are invalidated by the current one
  /// @return unique'd key for the added pass, or empty string if not added
  std::string registerPass(std::unique_ptr&lt;Pass&gt; pass,
                           const std::string &amp;insertBefore = "",
                           std::vector&lt;std::string&gt; reqs = {},
                           std::vector&lt;std::string&gt; invalidates = {});

  /// Registers an analysis.
  /// @param analysis the analysis
  /// @param reqs keys of analyses that must be run before the current one
  /// @return unique'd key for the added analysis, or empty string if not added
  std::string registerAnalysis(std::unique_ptr&lt;analyze::Analysis&gt; analysis,
                               std::vector&lt;std::string&gt; reqs = {});

  /// Run all passes.
  /// @param module the module
  void run(Module *module);

  /// Gets the result of a given analysis.
  /// @param key the (unique'd) analysis key
  /// @return the result
  analyze::Result *getAnalysisResult(const std::string &amp;key) {
    auto it = results.find(key);
    return it != results.end() ? it-&gt;second.get() : nullptr;
  }

</t>
<t tx="ekr.20230509083242.79">def add(self):
    self.hash_set.add(self.hash)

</t>
<t tx="ekr.20230509083242.790">  /// Returns whether a given pass or analysis is disabled.
  /// @param key the (unique'd) pass or analysis key
  /// @return true if the pass or analysis is disabled
  bool isDisabled(const std::string &amp;key) {
    return std::find(disabled.begin(), disabled.end(), key) != disabled.end();
  }

</t>
<t tx="ekr.20230509083242.791">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "pass.h"

#include "codon/cir/transform/manager.h"

namespace codon {
namespace ir {
namespace transform {

analyze::Result *Pass::doGetAnalysis(const std::string &amp;key) {
  return manager ? manager-&gt;getAnalysisResult(key) : nullptr;
}

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.792">void PassGroup::run(Module *module) {
  for (auto &amp;p : passes)
    p-&gt;run(module);
}

</t>
<t tx="ekr.20230509083242.793">void PassGroup::setManager(PassManager *mng) {
  Pass::setManager(mng);
  for (auto &amp;p : passes)
    p-&gt;setManager(mng);
}

</t>
<t tx="ekr.20230509083242.794">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/module.h"
#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {

namespace analyze {
struct Result;
}

namespace transform {

class PassManager;

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.795">/// General pass base class.
class Pass {
private:
  PassManager *manager = nullptr;

public:
  virtual ~Pass() noexcept = default;

  /// @return a unique key for this pass
  virtual std::string getKey() const = 0;

  /// Execute the pass.
  /// @param module the module
  virtual void run(Module *module) = 0;

  /// Determine if pass should repeat.
  /// @param num how many times this pass has already run
  /// @return true if pass should repeat
  virtual bool shouldRepeat(int num) const { return false; }

  /// Sets the manager.
  /// @param mng the new manager
  virtual void setManager(PassManager *mng) { manager = mng; }
@others
private:
  analyze::Result *doGetAnalysis(const std::string &amp;key);
};

</t>
<t tx="ekr.20230509083242.796">  /// Returns the result of a given analysis.
  /// @param key the analysis key
  /// @return the analysis result
  template &lt;typename AnalysisType&gt;
  AnalysisType *getAnalysisResult(const std::string &amp;key) {
    return static_cast&lt;AnalysisType *&gt;(doGetAnalysis(key));
  }

</t>
<t tx="ekr.20230509083242.797">class PassGroup : public Pass {
private:
  int repeat;
  std::vector&lt;std::unique_ptr&lt;Pass&gt;&gt; passes;

public:
  explicit PassGroup(int repeat = 0, std::vector&lt;std::unique_ptr&lt;Pass&gt;&gt; passes = {})
      : Pass(), repeat(repeat), passes(std::move(passes)) {}

  virtual ~PassGroup() noexcept = default;

  void push_back(std::unique_ptr&lt;Pass&gt; p) { passes.push_back(std::move(p)); }

  /// @return default number of times pass should repeat
  int getRepeat() const { return repeat; }

  /// Sets the default number of times pass should repeat.
  /// @param r number of repeats
  void setRepeat(int r) { repeat = r; }

  bool shouldRepeat(int num) const override { return num &lt; repeat; }

  void run(Module *module) override;

  void setManager(PassManager *mng) override;
};

</t>
<t tx="ekr.20230509083242.798">/// Pass that runs a single Operator.
class OperatorPass : public Pass, public util::Operator {
public:
  /// Constructs an operator pass.
  /// @param childrenFirst true if children should be iterated first
  explicit OperatorPass(bool childrenFirst = false) : util::Operator(childrenFirst) {}

@others
};

</t>
<t tx="ekr.20230509083242.799">  void run(Module *module) override {
    reset();
    process(module);
  }
</t>
<t tx="ekr.20230509083242.8">};

</t>
<t tx="ekr.20230509083242.80">def dupe(self):
    return self.hash in self.hash_set


</t>
<t tx="ekr.20230509083242.800">@path C:/Repos/codon/codon/cir/transform/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"
#include "codon/cir/util/visitor.h"

namespace codon {
namespace ir {
namespace transform {

@others
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.801">/// Base for rewrite rules.
class RewriteRule : public util::Visitor {
private:
  Value *result = nullptr;

protected:
  void defaultVisit(Node *) override {}
  void setResult(Value *r) { result = r; }
  void resetResult() { setResult(nullptr); }
  Value *getResult() const { return result; }

public:
  virtual ~RewriteRule() noexcept = default;

  /// Apply the rule.
  /// @param v the value to rewrite
  /// @return nullptr if no rewrite, the replacement otherwise
  Value *apply(Value *v) {
    v-&gt;accept(*this);
    auto *replacement = getResult();
    resetResult();
    return replacement;
  }
};

</t>
<t tx="ekr.20230509083242.802">/// A collection of rewrite rules.
class Rewriter {
private:
  std::unordered_map&lt;std::string, std::unique_ptr&lt;RewriteRule&gt;&gt; rules;
  int numReplacements = 0;

public:
@others
  /// @return the number of replacements
  int getNumReplacements() const { return numReplacements; }

  /// Sets the replacement count to zero.
  void reset() { numReplacements = 0; }
};

</t>
<t tx="ekr.20230509083242.803">  /// Adds a given rewrite rule with the given key.
  /// @param key the rule's key
  /// @param rule the rewrite rule
  void registerRule(const std::string &amp;key, std::unique_ptr&lt;RewriteRule&gt; rule) {
    rules.emplace(std::make_pair(key, std::move(rule)));
  }

</t>
<t tx="ekr.20230509083242.804">  /// Applies all rewrite rules to the given node, and replaces the given
  /// node with the result of the rewrites.
  /// @param v the node to rewrite
  void rewrite(Value *v) {
    Value *result = v;
    for (auto &amp;r : rules) {
      if (auto *rep = r.second-&gt;apply(result)) {
        ++numReplacements;
        result = rep;
      }
    }
    if (v != result)
      v-&gt;replaceAll(result);
  }

</t>
<t tx="ekr.20230509083242.805"></t>
<t tx="ekr.20230509083242.806">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "canonical.h"

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;tuple&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;

#include "codon/cir/analyze/module/side_effect.h"
#include "codon/cir/transform/rewrite.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/matching.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {
namespace {
struct NodeRanker : public util::Operator {
  // Nodes are ranked lexicographically by:
  //   - Whether the node is constant (constants come last)
  //   - Max node depth (deeper nodes first)
  //   - Node hash
  // The hash imposes an arbitrary but well-defined ordering
  // to ensure a single canonical representation for (most)
  // nodes.
  using Rank = std::tuple&lt;int, int, uint64_t&gt;;
  Node *root = nullptr;
  int maxDepth = 0;
  uint64_t hash = 0;

  // boost's hash_combine
  template &lt;class T&gt; void hash_combine(const T &amp;v) {
    std::hash&lt;T&gt; hasher;
    hash ^= hasher(v) + 0x9e3779b9 + (hash &lt;&lt; 6) + (hash &gt;&gt; 2);
  }

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.807">  void preHook(Node *node) {
    if (!root)
      root = node;
    maxDepth = std::max(maxDepth, depth());
    for (auto *v : node-&gt;getUsedVariables()) {
      hash_combine(v-&gt;getName());
    }
    for (auto *v : node-&gt;getUsedTypes()) {
      hash_combine(v-&gt;getName());
    }
  }

</t>
<t tx="ekr.20230509083242.808">  Rank getRank() {
    return std::make_tuple((isA&lt;Const&gt;(root) ? 1 : -1), -maxDepth, hash);
  }
};

NodeRanker::Rank getRank(Node *node) {
  NodeRanker ranker;
  node-&gt;accept(ranker);
  return ranker.getRank();
}

</t>
<t tx="ekr.20230509083242.809">bool isCommutativeOp(Func *fn) {
  return fn &amp;&amp; util::hasAttribute(fn, "std.internal.attributes.commutative");
}

</t>
<t tx="ekr.20230509083242.81">class Board:

    @others
</t>
<t tx="ekr.20230509083242.810">bool isAssociativeOp(Func *fn) {
  return fn &amp;&amp; util::hasAttribute(fn, "std.internal.attributes.associative");
}

</t>
<t tx="ekr.20230509083242.811">bool isDistributiveOp(Func *fn) {
  return fn &amp;&amp; util::hasAttribute(fn, "std.internal.attributes.distributive");
}

</t>
<t tx="ekr.20230509083242.812">bool isInequalityOp(Func *fn) {
  static const std::unordered_set&lt;std::string&gt; ops = {
      Module::EQ_MAGIC_NAME, Module::NE_MAGIC_NAME, Module::LT_MAGIC_NAME,
      Module::LE_MAGIC_NAME, Module::GT_MAGIC_NAME, Module::GE_MAGIC_NAME};
  return fn &amp;&amp; ops.find(fn-&gt;getUnmangledName()) != ops.end();
}

</t>
<t tx="ekr.20230509083242.813">// c + b + a --&gt; a + b + c
struct CanonOpChain : public RewriteRule {
</t>
<t tx="ekr.20230509083242.814">  static void extractAssociativeOpChain(Value *v, const std::string &amp;op,
                                        types::Type *type,
                                        std::vector&lt;Value *&gt; &amp;result) {
    if (util::isCallOf(v, op, {type, type}, type, /*method=*/true)) {
      auto *call = cast&lt;CallInstr&gt;(v);
      extractAssociativeOpChain(call-&gt;front(), op, type, result);
      extractAssociativeOpChain(call-&gt;back(), op, type, result);
    } else {
      result.push_back(v);
    }
  }

</t>
<t tx="ekr.20230509083242.815">  static void orderOperands(std::vector&lt;Value *&gt; &amp;operands) {
    std::vector&lt;std::pair&lt;NodeRanker::Rank, Value *&gt;&gt; rankedOperands;
    for (auto *v : operands) {
      rankedOperands.push_back({getRank(v), v});
    }
    std::sort(rankedOperands.begin(), rankedOperands.end());

    operands.clear();
    for (auto &amp;p : rankedOperands) {
      operands.push_back(std::get&lt;1&gt;(p));
    }
  }

</t>
<t tx="ekr.20230509083242.816">  void visit(CallInstr *v) override {
    auto *fn = util::getFunc(v-&gt;getCallee());
    if (!fn)
      return;

    std::string op = fn-&gt;getUnmangledName();
    types::Type *type = v-&gt;getType();
    const bool isAssociative = isAssociativeOp(fn);
    const bool isCommutative = isCommutativeOp(fn);

    if (util::isCallOf(v, op, {type, type}, type, /*method=*/true)) {
      std::vector&lt;Value *&gt; operands;
      if (isAssociative) {
        extractAssociativeOpChain(v, op, type, operands);
      } else {
        operands.push_back(v-&gt;front());
        operands.push_back(v-&gt;back());
      }
      seqassertn(operands.size() &gt;= 2, "bad call canonicalization");

      if (isCommutative)
        orderOperands(operands);

      Value *newCall = util::call(fn, {operands[0], operands[1]});
      for (auto it = operands.begin() + 2; it != operands.end(); ++it) {
        newCall = util::call(fn, {newCall, *it});
      }

      if (!util::match(v, newCall, /*checkNames=*/false, /*varIdMatch=*/true))
        return setResult(newCall);
    }
  }
</t>
<t tx="ekr.20230509083242.817">};

// b &gt; a --&gt; a &lt; b (etc.)
struct CanonInequality : public RewriteRule {
</t>
<t tx="ekr.20230509083242.818">  void visit(CallInstr *v) override {
    auto *fn = util::getFunc(v-&gt;getCallee());
    if (!fn)
      return;

    std::string op = fn-&gt;getUnmangledName();
    types::Type *type = v-&gt;getType();

    // canonicalize inequalities
    if (v-&gt;numArgs() == 2 &amp;&amp; isInequalityOp(fn)) {
      Value *newCall = nullptr;
      auto *lhs = v-&gt;front();
      auto *rhs = v-&gt;back();
      if (getRank(lhs) &gt; getRank(rhs)) { // are we out of order?
        // re-order
        if (op == Module::EQ_MAGIC_NAME) { // lhs == rhs
          newCall = *rhs == *lhs;
        } else if (op == Module::NE_MAGIC_NAME) { // lhs != rhs
          newCall = *rhs != *lhs;
        } else if (op == Module::LT_MAGIC_NAME) { // lhs &lt; rhs
          newCall = *rhs &gt; *lhs;
        } else if (op == Module::LE_MAGIC_NAME) { // lhs &lt;= rhs
          newCall = *rhs &gt;= *lhs;
        } else if (op == Module::GT_MAGIC_NAME) { // lhs &gt; rhs
          newCall = *rhs &lt; *lhs;
        } else if (op == Module::GE_MAGIC_NAME) { // lhs &gt;= rhs
          newCall = *rhs &lt;= *lhs;
        } else {
          seqassertn(false, "unknown comparison op: {}", op);
        }

        if (newCall &amp;&amp; newCall-&gt;getType()-&gt;is(type) &amp;&amp;
            !util::match(v, newCall, /*checkNames=*/false, /*varIdMatch=*/true))
          return setResult(newCall);
      }
    }
  }
</t>
<t tx="ekr.20230509083242.819">};

// a*x + b*x --&gt; (a + b) * x
struct CanonAddMul : public RewriteRule {
</t>
<t tx="ekr.20230509083242.82">def __init__(self):
    self.squares = [Square(self, pos) for pos in range(SIZE * SIZE)]
    for square in self.squares:
        square.set_neighbours()
    self.reset()

</t>
<t tx="ekr.20230509083242.820">  static bool varMatch(Value *a, Value *b) {
    auto *v1 = cast&lt;VarValue&gt;(a);
    auto *v2 = cast&lt;VarValue&gt;(b);
    return v1 &amp;&amp; v2 &amp;&amp; v1-&gt;getVar()-&gt;getId() == v2-&gt;getVar()-&gt;getId();
  }

</t>
<t tx="ekr.20230509083242.821">  static Func *getOp(Value *v) {
    return isA&lt;CallInstr&gt;(v) ? util::getFunc(cast&lt;CallInstr&gt;(v)-&gt;getCallee()) : nullptr;
  }

</t>
<t tx="ekr.20230509083242.822">  // (a + b) * x, or null if invalid
  static Value *addMul(Value *a, Value *b, Value *x) {
    if (!a || !b || !x)
      return nullptr;

    auto *y = (*a + *b);
    if (!y) {
      y = (*b + *a);
      if (y &amp;&amp; !isCommutativeOp(getOp(y)))
        return nullptr;
    }
    if (!y)
      return nullptr;

    auto *z = (*y) * (*x);
    if (!z) {
      z = (*x) * (*y);
      if (z &amp;&amp; !isCommutativeOp(getOp(z)))
        return nullptr;
    }
    if (!z)
      return nullptr;

    return z;
  }

</t>
<t tx="ekr.20230509083242.823">  void visit(CallInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *fn = util::getFunc(v-&gt;getCallee());
    if (!isCommutativeOp(fn) ||
        !util::isCallOf(v, Module::ADD_MAGIC_NAME, 2, /*output=*/nullptr,
                        /*method=*/true))
      return;

    // decompose the operation
    Value *lhs = v-&gt;front();
    Value *rhs = v-&gt;back();
    Value *lhs1 = nullptr, *lhs2 = nullptr, *rhs1 = nullptr, *rhs2 = nullptr;

    if (util::isCallOf(lhs, Module::MUL_MAGIC_NAME, 2, /*output=*/nullptr,
                       /*method=*/true)) {
      auto *lhsCall = cast&lt;CallInstr&gt;(lhs);
      lhs1 = lhsCall-&gt;front();
      lhs2 = lhsCall-&gt;back();
    } else {
      lhs1 = lhs;
      lhs2 = M-&gt;getInt(1);
    }

    if (util::isCallOf(rhs, Module::MUL_MAGIC_NAME, 2, /*output=*/nullptr,
                       /*method=*/true)) {
      auto *rhsCall = cast&lt;CallInstr&gt;(rhs);
      rhs1 = rhsCall-&gt;front();
      rhs2 = rhsCall-&gt;back();
    } else {
      rhs1 = rhs;
      rhs2 = M-&gt;getInt(1);
    }

    Value *newCall = nullptr;
    if (varMatch(lhs1, rhs1)) {
      newCall = addMul(lhs2, rhs2, lhs1);
    } else if (varMatch(lhs1, rhs2)) {
      newCall = addMul(lhs2, rhs1, lhs1);
    } else if (varMatch(lhs2, rhs1)) {
      newCall = addMul(lhs1, rhs2, lhs2);
    } else if (varMatch(lhs2, rhs2)) {
      newCall = addMul(lhs1, rhs1, lhs2);
    }

    if (newCall &amp;&amp; isDistributiveOp(getOp(newCall)) &amp;&amp;
        newCall-&gt;getType()-&gt;is(v-&gt;getType()) &amp;&amp;
        !util::match(v, newCall, /*checkNames=*/false, /*varIdMatch=*/true))
      return setResult(newCall);
  }
</t>
<t tx="ekr.20230509083242.824">};

// x - c --&gt; x + (-c)
struct CanonConstSub : public RewriteRule {
</t>
<t tx="ekr.20230509083242.825">  void visit(CallInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *type = v-&gt;getType();

    if (!util::isCallOf(v, Module::SUB_MAGIC_NAME, 2, /*output=*/nullptr,
                        /*method=*/true))
      return;

    Value *lhs = v-&gt;front();
    Value *rhs = v-&gt;back();

    if (!lhs-&gt;getType()-&gt;is(rhs-&gt;getType()))
      return;

    Value *newCall = nullptr;
    if (util::isConst&lt;int64_t&gt;(rhs)) {
      auto c = util::getConst&lt;int64_t&gt;(rhs);
      if (c != -(1ull &lt;&lt; 63)) // ensure no overflow
        newCall = *lhs + *(M-&gt;getInt(-c));
    } else if (util::isConst&lt;double&gt;(rhs)) {
      auto c = util::getConst&lt;double&gt;(rhs);
      newCall = *lhs + *(M-&gt;getFloat(-c));
    }

    if (newCall &amp;&amp; newCall-&gt;getType()-&gt;is(type) &amp;&amp;
        !util::match(v, newCall, /*checkNames=*/false, /*varIdMatch=*/true))
      return setResult(newCall);
  }
</t>
<t tx="ekr.20230509083242.826">};
} // namespace

const std::string CanonicalizationPass::KEY = "core-cleanup-canon";

</t>
<t tx="ekr.20230509083242.827">void CanonicalizationPass::run(Module *m) {
  registerStandardRules(m);
  Rewriter::reset();
  OperatorPass::run(m);
}

</t>
<t tx="ekr.20230509083242.828">void CanonicalizationPass::handle(CallInstr *v) {
  auto *r = getAnalysisResult&lt;analyze::module::SideEffectResult&gt;(sideEffectsKey);
  if (!r-&gt;hasSideEffect(v))
    rewrite(v);
}

</t>
<t tx="ekr.20230509083242.829">void CanonicalizationPass::handle(SeriesFlow *v) {
  auto it = v-&gt;begin();
  while (it != v-&gt;end()) {
    if (auto *series = cast&lt;SeriesFlow&gt;(*it)) {
      it = v-&gt;erase(it);
      for (auto *x : *series) {
        it = v-&gt;insert(it, x);
        ++it;
      }
    } else if (auto *flowInstr = cast&lt;FlowInstr&gt;(*it)) {
      it = v-&gt;erase(it);
      // inserting in reverse order causes [flow, value] to be added
      it = v-&gt;insert(it, flowInstr-&gt;getValue());
      it = v-&gt;insert(it, flowInstr-&gt;getFlow());
      // don't increment; re-traverse in case a new series flow added
    } else {
      ++it;
    }
  }
}

</t>
<t tx="ekr.20230509083242.83">def reset(self):
    for square in self.squares:
        square.color = EMPTY
        square.used = False
    self.emptyset = EmptySet(self)
    self.zobrist = ZobristHash(self)
    self.color = BLACK
    self.finished = False
    self.lastmove = -2
    self.history = []
    self.white_dead = 0
    self.black_dead = 0

</t>
<t tx="ekr.20230509083242.830">void CanonicalizationPass::registerStandardRules(Module *m) {
  registerRule("op-chain", std::make_unique&lt;CanonOpChain&gt;());
  registerRule("inequality", std::make_unique&lt;CanonInequality&gt;());
  registerRule("add-mul", std::make_unique&lt;CanonAddMul&gt;());
  registerRule("const-sub", std::make_unique&lt;CanonConstSub&gt;());
}

</t>
<t tx="ekr.20230509083242.831">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"
#include "codon/cir/transform/rewrite.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.832">/// Canonicalization pass that flattens nested series
/// flows, puts operands in a predefined order, etc.
class CanonicalizationPass : public OperatorPass, public Rewriter {
private:
  std::string sideEffectsKey;

public:
  /// Constructs a canonicalization pass
  /// @param sideEffectsKey the side effect analysis' key
  CanonicalizationPass(const std::string &amp;sideEffectsKey)
      : OperatorPass(/*childrenFirst=*/true), sideEffectsKey(sideEffectsKey) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void run(Module *m) override;
  void handle(CallInstr *) override;
  void handle(SeriesFlow *) override;

private:
  void registerStandardRules(Module *m);
};

</t>
<t tx="ekr.20230509083242.833">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "dead_code.h"

#include "codon/cir/analyze/module/side_effect.h"
#include "codon/cir/util/cloning.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {
namespace {
BoolConst *boolConst(Value *v) { return cast&lt;BoolConst&gt;(v); }

IntConst *intConst(Value *v) { return cast&lt;IntConst&gt;(v); }
} // namespace

const std::string DeadCodeCleanupPass::KEY = "core-cleanup-dce";

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.834">void DeadCodeCleanupPass::run(Module *m) {
  numReplacements = 0;
  OperatorPass::run(m);
}

</t>
<t tx="ekr.20230509083242.835">void DeadCodeCleanupPass::handle(SeriesFlow *v) {
  auto *r = getAnalysisResult&lt;analyze::module::SideEffectResult&gt;(sideEffectsKey);
  auto it = v-&gt;begin();
  while (it != v-&gt;end()) {
    if (!r-&gt;hasSideEffect(*it)) {
      LOG_IR("[{}] no side effect, deleting: {}", KEY, **it);
      numReplacements++;
      it = v-&gt;erase(it);
    } else {
      ++it;
    }
  }
}

</t>
<t tx="ekr.20230509083242.836">void DeadCodeCleanupPass::handle(IfFlow *v) {
  auto *cond = boolConst(v-&gt;getCond());
  if (!cond)
    return;

  auto *M = v-&gt;getModule();
  auto condVal = cond-&gt;getVal();

  util::CloneVisitor cv(M);
  if (condVal) {
    doReplacement(v, cv.clone(v-&gt;getTrueBranch()));
  } else if (auto *f = v-&gt;getFalseBranch()) {
    doReplacement(v, cv.clone(f));
  } else {
    doReplacement(v, M-&gt;Nr&lt;SeriesFlow&gt;());
  }
}

</t>
<t tx="ekr.20230509083242.837">void DeadCodeCleanupPass::handle(WhileFlow *v) {
  auto *cond = boolConst(v-&gt;getCond());
  if (!cond)
    return;

  auto *M = v-&gt;getModule();
  auto condVal = cond-&gt;getVal();
  if (!condVal) {
    doReplacement(v, M-&gt;Nr&lt;SeriesFlow&gt;());
  }
}

</t>
<t tx="ekr.20230509083242.838">void DeadCodeCleanupPass::handle(ImperativeForFlow *v) {
  auto *start = intConst(v-&gt;getStart());
  auto *end = intConst(v-&gt;getEnd());
  if (!start || !end)
    return;

  auto stepVal = v-&gt;getStep();
  auto startVal = start-&gt;getVal();
  auto endVal = end-&gt;getVal();

  auto *M = v-&gt;getModule();
  if ((stepVal &lt; 0 &amp;&amp; startVal &lt;= endVal) || (stepVal &gt; 0 &amp;&amp; startVal &gt;= endVal)) {
    doReplacement(v, M-&gt;Nr&lt;SeriesFlow&gt;());
  }
}

</t>
<t tx="ekr.20230509083242.839">void DeadCodeCleanupPass::handle(TernaryInstr *v) {
  auto *cond = boolConst(v-&gt;getCond());
  if (!cond)
    return;

  auto *M = v-&gt;getModule();
  auto condVal = cond-&gt;getVal();

  util::CloneVisitor cv(M);
  if (condVal) {
    doReplacement(v, cv.clone(v-&gt;getTrueValue()));
  } else {
    doReplacement(v, cv.clone(v-&gt;getFalseValue()));
  }
}

</t>
<t tx="ekr.20230509083242.84">def move(self, pos):
    square = self.squares[pos]
    if pos != PASS:
        square.move(self.color)
        self.emptyset.remove(square.pos)
    elif self.lastmove == PASS:
        self.finished = True
    if self.color == BLACK:
        self.color = WHITE
    else:
        self.color = BLACK
    self.lastmove = pos
    self.history.append(pos)

</t>
<t tx="ekr.20230509083242.840">void DeadCodeCleanupPass::doReplacement(Value *og, Value *v) {
  numReplacements++;
  og-&gt;replaceAll(v);
}

</t>
<t tx="ekr.20230509083242.841">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.842">/// Cleanup pass that removes dead code.
class DeadCodeCleanupPass : public OperatorPass {
private:
  std::string sideEffectsKey;
  int numReplacements;

public:
  static const std::string KEY;

  /// Constructs a dead code elimination pass
  /// @param sideEffectsKey the side effect analysis' key
  DeadCodeCleanupPass(std::string sideEffectsKey)
      : OperatorPass(), sideEffectsKey(std::move(sideEffectsKey)), numReplacements(0) {}

  std::string getKey() const override { return KEY; }

  void run(Module *m) override;

  void handle(SeriesFlow *v) override;
  void handle(IfFlow *v) override;
  void handle(WhileFlow *v) override;
  void handle(ImperativeForFlow *v) override;
  void handle(TernaryInstr *v) override;

  /// @return the number of replacements
  int getNumReplacements() const { return numReplacements; }

private:
  void doReplacement(Value *og, Value *v);
};

</t>
<t tx="ekr.20230509083242.843">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "global_demote.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {
namespace {
struct GetUsedGlobals : public util::Operator {
  std::vector&lt;Var *&gt; vars;
@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.844">  void preHook(Node *v) override {
    for (auto *var : v-&gt;getUsedVariables()) {
      if (!isA&lt;Func&gt;(var) &amp;&amp; var-&gt;isGlobal())
        vars.push_back(var);
    }
  }
</t>
<t tx="ekr.20230509083242.845">};
} // namespace

const std::string GlobalDemotionPass::KEY = "core-cleanup-global-demote";

</t>
<t tx="ekr.20230509083242.846">void GlobalDemotionPass::run(Module *M) {
  numDemotions = 0;
  std::unordered_map&lt;Var *, Func *&gt; localGlobals;

  std::vector&lt;Func *&gt; worklist = {M-&gt;getMainFunc()};
  for (auto *var : *M) {
    if (auto *func = cast&lt;Func&gt;(var))
      worklist.push_back(func);
  }

  for (auto *var : worklist) {
    if (auto *func = cast&lt;Func&gt;(var)) {
      GetUsedGlobals globals;
      func-&gt;accept(globals);

      for (auto *g : globals.vars) {
        LOG_IR("[{}] global {} used in {}", KEY, *g, func-&gt;getName());
        auto it = localGlobals.find(g);
        if (it == localGlobals.end()) {
          localGlobals.emplace(g, func);
        } else if (it-&gt;second &amp;&amp; it-&gt;second != func) {
          it-&gt;second = nullptr;
        }
      }
    }
  }

  for (auto it : localGlobals) {
    if (!it.second || it.first-&gt;getId() == M-&gt;getArgVar()-&gt;getId() ||
        it.first-&gt;isExternal())
      continue;
    seqassertn(it.first-&gt;isGlobal(), "var was not global [{}]", it.first-&gt;getSrcInfo());
    it.first-&gt;setGlobal(false);
    if (auto *func = cast&lt;BodiedFunc&gt;(it.second)) {
      func-&gt;push_back(it.first);
      ++numDemotions;
      LOG_IR("[{}] demoted {} to a local of {}", KEY, *it.first, func-&gt;getName());
    }
  }
}

</t>
<t tx="ekr.20230509083242.847">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.848">/// Demotes global variables that are used in only one
/// function to locals of that function.
class GlobalDemotionPass : public Pass {
private:
  /// number of variables we've demoted
  int numDemotions;

public:
  static const std::string KEY;

  /// Constructs a global variable demotion pass
  GlobalDemotionPass() : Pass(), numDemotions(0) {}

  std::string getKey() const override { return KEY; }
  void run(Module *v) override;

  /// @return number of variables we've demoted
  int getNumDemotions() const { return numDemotions; }
};

</t>
<t tx="ekr.20230509083242.849">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "replacer.h"

#include &lt;unordered_set&gt;

#include "codon/cir/types/types.h"
#include "codon/cir/value.h"
#include "codon/cir/var.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

const std::string ReplaceCleanupPass::KEY = "core-cleanup-physical-replace";

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.85">def random_move(self):
    return self.emptyset.random_choice()

</t>
<t tx="ekr.20230509083242.850">void ReplaceCleanupPass::run(Module *module) {
  std::unordered_set&lt;Value *&gt; valuesToDelete;
  std::unordered_set&lt;types::Type *&gt; typesToDelete;
  std::unordered_set&lt;Var *&gt; varsToDelete;

  {
    auto *f = module-&gt;getMainFunc();
    for (auto *c : f-&gt;getUsedValues()) {
      if (c-&gt;hasReplacement()) {
        f-&gt;replaceUsedValue(c, c-&gt;getActual());
        valuesToDelete.insert(c);
      }
    }
    for (auto *t : f-&gt;getUsedTypes()) {
      if (t-&gt;hasReplacement()) {
        f-&gt;replaceUsedType(t, t-&gt;getActual());
        typesToDelete.insert(t);
      }
    }
    for (auto *v : f-&gt;getUsedVariables()) {
      if (v-&gt;hasReplacement()) {
        f-&gt;replaceUsedVariable(v, v-&gt;getActual());
        varsToDelete.insert(v);
      }
    }
  }

  {
    auto *v = module-&gt;getArgVar();
    for (auto *c : v-&gt;getUsedValues()) {
      if (c-&gt;hasReplacement()) {
        v-&gt;replaceUsedValue(c, c-&gt;getActual());
        valuesToDelete.insert(c);
      }
    }
    for (auto *t : v-&gt;getUsedTypes()) {
      if (t-&gt;hasReplacement()) {
        v-&gt;replaceUsedType(t, t-&gt;getActual());
        typesToDelete.insert(t);
      }
    }
    for (auto *v2 : v-&gt;getUsedVariables()) {
      if (v2-&gt;hasReplacement()) {
        v-&gt;replaceUsedVariable(v2, v2-&gt;getActual());
        varsToDelete.insert(v2);
      }
    }
  }

  for (auto it = module-&gt;values_begin(); it != module-&gt;values_end(); ++it) {
    for (auto *c : it-&gt;getUsedValues()) {
      if (c-&gt;hasReplacement()) {
        it-&gt;replaceUsedValue(c, c-&gt;getActual());
        valuesToDelete.insert(c);
      }
    }
    for (auto *t : it-&gt;getUsedTypes()) {
      if (t-&gt;hasReplacement()) {
        it-&gt;replaceUsedType(t, t-&gt;getActual());
        typesToDelete.insert(t);
      }
    }
    for (auto *v : it-&gt;getUsedVariables()) {
      if (v-&gt;hasReplacement()) {
        it-&gt;replaceUsedVariable(v, v-&gt;getActual());
        varsToDelete.insert(v);
      }
    }
  }

  for (auto it = module-&gt;begin(); it != module-&gt;end(); ++it) {
    for (auto *c : it-&gt;getUsedValues()) {
      if (c-&gt;hasReplacement()) {
        it-&gt;replaceUsedValue(c, c-&gt;getActual());
        valuesToDelete.insert(c);
      }
    }
    for (auto *t : it-&gt;getUsedTypes()) {
      if (t-&gt;hasReplacement()) {
        it-&gt;replaceUsedType(t, t-&gt;getActual());
        typesToDelete.insert(t);
      }
    }
    for (auto *v : it-&gt;getUsedVariables()) {
      if (v-&gt;hasReplacement()) {
        it-&gt;replaceUsedVariable(v, v-&gt;getActual());
        varsToDelete.insert(v);
      }
    }
  }

  for (auto it = module-&gt;types_begin(); it != module-&gt;types_end(); ++it) {
    for (auto *c : it-&gt;getUsedValues()) {
      if (c-&gt;hasReplacement()) {
        it-&gt;replaceUsedValue(c, c-&gt;getActual());
        valuesToDelete.insert(c);
      }
    }
    for (auto *t : it-&gt;getUsedTypes()) {
      if (t-&gt;hasReplacement()) {
        it-&gt;replaceUsedType(t, t-&gt;getActual());
        typesToDelete.insert(t);
      }
    }
    for (auto *v : it-&gt;getUsedVariables()) {
      if (v-&gt;hasReplacement()) {
        it-&gt;replaceUsedVariable(v, v-&gt;getActual());
        varsToDelete.insert(v);
      }
    }
  }

  for (auto *v : valuesToDelete)
    module-&gt;remove(v);
  for (auto *v : varsToDelete)
    module-&gt;remove(v);
  for (auto *t : typesToDelete)
    module-&gt;remove(t);
}

</t>
<t tx="ekr.20230509083242.851">@path C:/Repos/codon/codon/cir/transform/cleanup/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace cleanup {

@others
} // namespace cleanup
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.852">/// Cleanup pass that physically replaces nodes.
class ReplaceCleanupPass : public Pass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void run(Module *module) override;
};

</t>
<t tx="ekr.20230509083242.853"></t>
<t tx="ekr.20230509083242.854">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "const_fold.h"

#include &lt;cmath&gt;
#include &lt;utility&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"

#define BINOP(o)                                                                       \
  [](auto x, auto y) -&gt; auto{ return x o y; }
#define UNOP(o)                                                                        \
  [](auto x) -&gt; auto{ return o x; }

namespace codon {
namespace ir {
namespace transform {
namespace folding {
namespace {
@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon

#undef BINOP
#undef UNOP
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.855">auto pyDivmod(int64_t self, int64_t other) {
  auto d = self / other;
  auto m = self - d * other;
  if (m &amp;&amp; ((other ^ m) &lt; 0)) {
    m += other;
    d -= 1;
  }
  return std::make_pair(d, m);
}

</t>
<t tx="ekr.20230509083242.856">template &lt;typename Func, typename Out&gt; class IntFloatBinaryRule : public RewriteRule {
private:
  Func f;
  std::string magic;
  types::Type *out;
  bool excludeRHSZero;

public:
  IntFloatBinaryRule(Func f, std::string magic, types::Type *out,
</t>
<t tx="ekr.20230509083242.857">                     bool excludeRHSZero = false)
      : f(std::move(f)), magic(std::move(magic)), out(out),
        excludeRHSZero(excludeRHSZero) {}

  virtual ~IntFloatBinaryRule() noexcept = default;

    @others
</t>
<t tx="ekr.20230509083242.858">  void visit(CallInstr *v) override {
if (!util::isCallOf(v, magic, 2, /*output=*/nullptr, /*method=*/true))
  return;

auto *leftConst = cast&lt;Const&gt;(v-&gt;front());
auto *rightConst = cast&lt;Const&gt;(v-&gt;back());

if (!leftConst || !rightConst)
  return;

auto *M = v-&gt;getModule();
if (isA&lt;FloatConst&gt;(leftConst) &amp;&amp; isA&lt;IntConst&gt;(rightConst)) {
  auto left = cast&lt;FloatConst&gt;(leftConst)-&gt;getVal();
  auto right = cast&lt;IntConst&gt;(rightConst)-&gt;getVal();
  if (excludeRHSZero &amp;&amp; right == 0)
    return;
  return setResult(M-&gt;template N&lt;TemplatedConst&lt;Out&gt;&gt;(v-&gt;getSrcInfo(),
                                                      f(left, (double)right), out));
} else if (isA&lt;IntConst&gt;(leftConst) &amp;&amp; isA&lt;FloatConst&gt;(rightConst)) {
  auto left = cast&lt;IntConst&gt;(leftConst)-&gt;getVal();
  auto right = cast&lt;FloatConst&gt;(rightConst)-&gt;getVal();
  if (excludeRHSZero &amp;&amp; right == 0.0)
    return;
  return setResult(M-&gt;template N&lt;TemplatedConst&lt;Out&gt;&gt;(v-&gt;getSrcInfo(),
                                                      f((double)left, right), out));
}
  }
</t>
<t tx="ekr.20230509083242.859">};

</t>
<t tx="ekr.20230509083242.86">def useful_fast(self, square):
    if not square.used:
        for neighbour in square.neighbours:
            if neighbour.color == EMPTY:
                return True
    return False

</t>
<t tx="ekr.20230509083242.860">/// Binary rule that requires two constants.
template &lt;typename ConstantType, typename Func, typename OutputType = ConstantType&gt;
@others
</t>
<t tx="ekr.20230509083242.861">class DoubleConstantBinaryRuleExcludeRHSZero
    : public DoubleConstantBinaryRule&lt;ConstantType, Func, OutputType&gt; {
public:
  DoubleConstantBinaryRuleExcludeRHSZero(Func f, std::string magic,
                                         types::Type *inputType,
                                         types::Type *resultType)
      : DoubleConstantBinaryRule&lt;ConstantType, Func, OutputType&gt;(f, magic, inputType,
                                                                 resultType) {}

  virtual ~DoubleConstantBinaryRuleExcludeRHSZero() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509083242.862">  void visit(CallInstr *v) override {
    if (v-&gt;numArgs() == 2) {
      auto *rightConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(v-&gt;back());
      if (rightConst &amp;&amp; rightConst-&gt;getVal() == ConstantType())
        return;
    }
    DoubleConstantBinaryRule&lt;ConstantType, Func, OutputType&gt;::visit(v);
  }
</t>
<t tx="ekr.20230509083242.863">auto id_val(Module *m) {
  return [=](Value *v) -&gt; Value * {
    util::CloneVisitor cv(m);
    return cv.clone(v);
  };
}

</t>
<t tx="ekr.20230509083242.864">int64_t int_pow(int64_t base, int64_t exp) {
  if (exp &lt; 0)
    return 0;
  int64_t result = 1;
  while (true) {
    if (exp &amp; 1) {
      result *= base;
    }
    exp = exp &gt;&gt; 1;
    if (!exp)
      break;
    base = base * base;
  }
  return result;
}

</t>
<t tx="ekr.20230509083242.865">template &lt;typename From, typename To&gt; To convert(From x) { return To(x); }

template &lt;typename... Args&gt; auto intSingleRule(Module *m, Args &amp;&amp;...args) {
  return std::make_unique&lt;SingleConstantCommutativeRule&lt;int64_t&gt;&gt;(
      std::forward&lt;Args&gt;(args)..., m-&gt;getIntType());
}

</t>
<t tx="ekr.20230509083242.866">auto intNoOp(Module *m, std::string magic) {
  return std::make_unique&lt;NoOpRule&gt;(std::move(magic), m-&gt;getIntType());
}

</t>
<t tx="ekr.20230509083242.867">auto intDoubleApplyNoOp(Module *m, std::string magic) {
  return std::make_unique&lt;DoubleApplicationNoOpRule&gt;(std::move(magic), m-&gt;getIntType());
}

</t>
<t tx="ekr.20230509083242.868">template &lt;typename Func&gt; auto intToIntBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRule&lt;int64_t, Func, int64_t&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getIntType(), m-&gt;getIntType());
}

</t>
<t tx="ekr.20230509083242.869">template &lt;typename Func&gt;
auto intToIntBinaryNoZeroRHS(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;
      DoubleConstantBinaryRuleExcludeRHSZero&lt;int64_t, Func, int64_t&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getIntType(), m-&gt;getIntType());
}

</t>
<t tx="ekr.20230509083242.87">def useful(self, pos):
    global TIMESTAMP
    TIMESTAMP += 1
    square = self.squares[pos]
    if self.useful_fast(square):
        return True
    old_hash = self.zobrist.hash
    self.zobrist.update(square, self.color)
    empties = opps = weak_opps = neighs = weak_neighs = 0
    for neighbour in square.neighbours:
        neighcolor = neighbour.color
        if neighcolor == EMPTY:
            empties += 1
            continue
        neighbour_ref = neighbour.find()
        if neighbour_ref.timestamp != TIMESTAMP:
            if neighcolor == self.color:
                neighs += 1
            else:
                opps += 1
            neighbour_ref.timestamp = TIMESTAMP
            neighbour_ref.temp_ledges = neighbour_ref.ledges
        neighbour_ref.temp_ledges -= 1
        if neighbour_ref.temp_ledges == 0:
            if neighcolor == self.color:
                weak_neighs += 1
            else:
                weak_opps += 1
                neighbour_ref.remove(neighbour_ref, update=False)
    dupe = self.zobrist.dupe()
    self.zobrist.hash = old_hash
    strong_neighs = neighs - weak_neighs
    strong_opps = opps - weak_opps
    return not dupe and \
        (empties or weak_opps or (strong_neighs and (strong_opps or weak_neighs)))

</t>
<t tx="ekr.20230509083242.870">template &lt;typename Func&gt; auto intToBoolBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRule&lt;int64_t, Func, bool&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getIntType(), m-&gt;getBoolType());
}

template &lt;typename Func&gt; auto boolToBoolBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRule&lt;bool, Func, bool&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getBoolType(), m-&gt;getBoolType());
}

template &lt;typename Func&gt; auto floatToFloatBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRule&lt;double, Func, double&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getFloatType(), m-&gt;getFloatType());
}

</t>
<t tx="ekr.20230509083242.871">template &lt;typename Func&gt;
auto floatToFloatBinaryNoZeroRHS(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRuleExcludeRHSZero&lt;double, Func, double&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getFloatType(), m-&gt;getFloatType());
}

</t>
<t tx="ekr.20230509083242.872">template &lt;typename Func&gt; auto floatToBoolBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;DoubleConstantBinaryRule&lt;double, Func, bool&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getFloatType(), m-&gt;getBoolType());
}

</t>
<t tx="ekr.20230509083242.873">template &lt;typename Func&gt;
auto intFloatToFloatBinary(Module *m, Func f, std::string magic,
                           bool excludeRHSZero = false) {
  return std::make_unique&lt;IntFloatBinaryRule&lt;Func, double&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getFloatType(), excludeRHSZero);
}

</t>
<t tx="ekr.20230509083242.874">template &lt;typename Func&gt;
auto intFloatToBoolBinary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;IntFloatBinaryRule&lt;Func, bool&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getBoolType());
}

</t>
<t tx="ekr.20230509083242.875">template &lt;typename Func&gt; auto intToIntUnary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;SingleConstantUnaryRule&lt;int64_t, Func&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getIntType(), m-&gt;getIntType());
}

template &lt;typename Func&gt; auto floatToFloatUnary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;SingleConstantUnaryRule&lt;double, Func&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getFloatType(), m-&gt;getFloatType());
}

template &lt;typename Func&gt; auto boolToBoolUnary(Module *m, Func f, std::string magic) {
  return std::make_unique&lt;SingleConstantUnaryRule&lt;bool, Func&gt;&gt;(
      std::move(f), std::move(magic), m-&gt;getBoolType(), m-&gt;getBoolType());
}

</t>
<t tx="ekr.20230509083242.876">auto identityConvert(Module *m, std::string magic, types::Type *type) {
  return std::make_unique&lt;UnaryRule&lt;decltype(id_val(m))&gt;&gt;(id_val(m), std::move(magic),
                                                          type);
}

</t>
<t tx="ekr.20230509083242.877">template &lt;typename From, typename To&gt;
auto typeConvert(Module *m, std::string magic, types::Type *fromType,
                 types::Type *toType) {
  return std::make_unique&lt;
      SingleConstantUnaryRule&lt;From, std::function&lt;decltype(convert&lt;From, To&gt;)&gt;&gt;&gt;(
      convert&lt;From, To&gt;, std::move(magic), fromType, toType);
}
</t>
<t tx="ekr.20230509083242.878">} // namespace

const std::string FoldingPass::KEY = "core-folding-const-fold";

</t>
<t tx="ekr.20230509083242.879">void FoldingPass::run(Module *m) {
  registerStandardRules(m);
  Rewriter::reset();
  OperatorPass::run(m);
}

</t>
<t tx="ekr.20230509083242.88">def useful_moves(self):
    return [pos for pos in self.emptyset.empties if self.useful(pos)]

</t>
<t tx="ekr.20230509083242.880">void FoldingPass::handle(CallInstr *v) { rewrite(v); }

</t>
<t tx="ekr.20230509083242.881">void FoldingPass::registerStandardRules(Module *m) {
  // binary, single constant, int-&gt;int
  using Kind = SingleConstantCommutativeRule&lt;int64_t&gt;::Kind;
  registerRule("int-multiply-by-zero",
               intSingleRule(m, 0, 0, Module::MUL_MAGIC_NAME, Kind::COMMUTATIVE));
  registerRule(
      "int-multiply-by-one",
      intSingleRule(m, 1, id_val(m), Module::MUL_MAGIC_NAME, Kind::COMMUTATIVE));
  registerRule("int-subtract-zero",
               intSingleRule(m, 0, id_val(m), Module::SUB_MAGIC_NAME, Kind::RIGHT));
  registerRule("int-add-zero", intSingleRule(m, 0, id_val(m), Module::ADD_MAGIC_NAME,
                                             Kind::COMMUTATIVE));
  registerRule(
      "int-floor-div-by-one",
      intSingleRule(m, 1, id_val(m), Module::FLOOR_DIV_MAGIC_NAME, Kind::RIGHT));
  registerRule("int-zero-floor-div",
               intSingleRule(m, 0, 0, Module::FLOOR_DIV_MAGIC_NAME, Kind::LEFT));
  registerRule("int-pos", intNoOp(m, Module::POS_MAGIC_NAME));
  registerRule("int-double-neg", intDoubleApplyNoOp(m, Module::NEG_MAGIC_NAME));
  registerRule("int-double-inv", intDoubleApplyNoOp(m, Module::INVERT_MAGIC_NAME));

  @others
  registerRule("float-constant-mul",
               floatToFloatBinary(m, BINOP(*), Module::MUL_MAGIC_NAME));
  registerRule(
      "float-constant-pow",
      floatToFloatBinary(
          m, [](auto a, auto b) { return std::pow(a, b); }, Module::POW_MAGIC_NAME));

  // binary, double constant, float-&gt;bool
  registerRule("float-constant-eq",
               floatToBoolBinary(m, BINOP(==), Module::EQ_MAGIC_NAME));
  registerRule("float-constant-ne",
               floatToBoolBinary(m, BINOP(!=), Module::NE_MAGIC_NAME));
  registerRule("float-constant-gt",
               floatToBoolBinary(m, BINOP(&gt;), Module::GT_MAGIC_NAME));
  registerRule("float-constant-ge",
               floatToBoolBinary(m, BINOP(&gt;=), Module::GE_MAGIC_NAME));
  registerRule("float-constant-lt",
               floatToBoolBinary(m, BINOP(&lt;), Module::LT_MAGIC_NAME));
  registerRule("float-constant-le",
               floatToBoolBinary(m, BINOP(&lt;=), Module::LE_MAGIC_NAME));

  // binary, double constant, int,float-&gt;float
  registerRule("int-float-constant-addition",
               intFloatToFloatBinary(m, BINOP(+), Module::ADD_MAGIC_NAME));
  registerRule("int-float-constant-subtraction",
               intFloatToFloatBinary(m, BINOP(-), Module::SUB_MAGIC_NAME));
  registerRule(
      "int-float-constant-floor-div",
      intFloatToFloatBinary(m, BINOP(/), Module::TRUE_DIV_MAGIC_NAME, pyNumerics));
  registerRule("int-float-constant-mul",
               intFloatToFloatBinary(m, BINOP(*), Module::MUL_MAGIC_NAME));

  // binary, double constant, int,float-&gt;bool
  registerRule("int-float-constant-eq",
               intFloatToBoolBinary(m, BINOP(==), Module::EQ_MAGIC_NAME));
  registerRule("int-float-constant-ne",
               intFloatToBoolBinary(m, BINOP(!=), Module::NE_MAGIC_NAME));
  registerRule("int-float-constant-gt",
               intFloatToBoolBinary(m, BINOP(&gt;), Module::GT_MAGIC_NAME));
  registerRule("int-float-constant-ge",
               intFloatToBoolBinary(m, BINOP(&gt;=), Module::GE_MAGIC_NAME));
  registerRule("int-float-constant-lt",
               intFloatToBoolBinary(m, BINOP(&lt;), Module::LT_MAGIC_NAME));
  registerRule("int-float-constant-le",
               intFloatToBoolBinary(m, BINOP(&lt;=), Module::LE_MAGIC_NAME));

  // type conversions, identity
  registerRule("int-constant-int",
               identityConvert(m, Module::INT_MAGIC_NAME, m-&gt;getIntType()));
  registerRule("float-constant-float",
               identityConvert(m, Module::FLOAT_MAGIC_NAME, m-&gt;getFloatType()));
  registerRule("bool-constant-bool",
               identityConvert(m, Module::BOOL_MAGIC_NAME, m-&gt;getBoolType()));

  // type conversions, distinct
  registerRule("float-constant-int",
               typeConvert&lt;double, int64_t&gt;(m, Module::INT_MAGIC_NAME,
                                            m-&gt;getFloatType(), m-&gt;getIntType()));
  registerRule("bool-constant-int",
               typeConvert&lt;bool, int64_t&gt;(m, Module::INT_MAGIC_NAME, m-&gt;getBoolType(),
                                          m-&gt;getIntType()));
  registerRule("int-constant-float",
               typeConvert&lt;int64_t, double&gt;(m, Module::FLOAT_MAGIC_NAME,
                                            m-&gt;getIntType(), m-&gt;getFloatType()));
  registerRule("bool-constant-float",
               typeConvert&lt;bool, double&gt;(m, Module::FLOAT_MAGIC_NAME, m-&gt;getBoolType(),
                                         m-&gt;getFloatType()));
  registerRule("int-constant-bool",
               typeConvert&lt;int64_t, bool&gt;(m, Module::BOOL_MAGIC_NAME, m-&gt;getIntType(),
                                          m-&gt;getBoolType()));
  registerRule("float-constant-bool",
               typeConvert&lt;double, bool&gt;(m, Module::BOOL_MAGIC_NAME, m-&gt;getFloatType(),
                                         m-&gt;getBoolType()));
}

</t>
<t tx="ekr.20230509083242.882">// binary, double constant, int-&gt;int
registerRule("int-constant-addition",
             intToIntBinary(m, BINOP(+), Module::ADD_MAGIC_NAME));
  @others
</t>
<t tx="ekr.20230509083242.883">  registerRule("int-constant-subtraction",
           intToIntBinary(m, BINOP(-), Module::SUB_MAGIC_NAME));
  if (pyNumerics) {
registerRule("int-constant-floor-div",
             intToIntBinaryNoZeroRHS(
                 m, [](auto x, auto y) -&gt; auto{ return pyDivmod(x, y).first; },
                 Module::FLOOR_DIV_MAGIC_NAME));
  } else {
registerRule("int-constant-floor-div",
             intToIntBinaryNoZeroRHS(m, BINOP(/), Module::FLOOR_DIV_MAGIC_NAME));
  }
</t>
<t tx="ekr.20230509083242.884">registerRule("int-constant-mul", intToIntBinary(m, BINOP(*), Module::MUL_MAGIC_NAME));
</t>
<t tx="ekr.20230509083242.885">registerRule("int-constant-lshift",
             intToIntBinary(m, BINOP(&lt;&lt;), Module::LSHIFT_MAGIC_NAME));
  @others
</t>
<t tx="ekr.20230509083242.886">  registerRule("int-constant-rshift",
           intToIntBinary(m, BINOP(&gt;&gt;), Module::RSHIFT_MAGIC_NAME));
  registerRule("int-constant-pow", intToIntBinary(m, int_pow, Module::POW_MAGIC_NAME));
  registerRule("int-constant-xor", intToIntBinary(m, BINOP(^), Module::XOR_MAGIC_NAME));
  registerRule("int-constant-or", intToIntBinary(m, BINOP(|), Module::OR_MAGIC_NAME));
  registerRule("int-constant-and", intToIntBinary(m, BINOP(&amp;), Module::AND_MAGIC_NAME));
  if (pyNumerics) {
registerRule("int-constant-mod",
             intToIntBinaryNoZeroRHS(
                 m, [](auto x, auto y) -&gt; auto{ return pyDivmod(x, y).second; },
                 Module::MOD_MAGIC_NAME));
  } else {
registerRule("int-constant-mod",
             intToIntBinaryNoZeroRHS(m, BINOP(%), Module::MOD_MAGIC_NAME));
  }

</t>
<t tx="ekr.20230509083242.887">// binary, double constant, int-&gt;bool
registerRule("int-constant-eq", intToBoolBinary(m, BINOP(==), Module::EQ_MAGIC_NAME));
registerRule("int-constant-ne", intToBoolBinary(m, BINOP(!=), Module::NE_MAGIC_NAME));
registerRule("int-constant-gt", intToBoolBinary(m, BINOP(&gt;), Module::GT_MAGIC_NAME));
registerRule("int-constant-ge", intToBoolBinary(m, BINOP(&gt;=), Module::GE_MAGIC_NAME));
registerRule("int-constant-lt", intToBoolBinary(m, BINOP(&lt;), Module::LT_MAGIC_NAME));
registerRule("int-constant-le", intToBoolBinary(m, BINOP(&lt;=), Module::LE_MAGIC_NAME));

// binary, double constant, bool-&gt;bool
registerRule("bool-constant-xor",
             boolToBoolBinary(m, BINOP(^), Module::XOR_MAGIC_NAME));
registerRule("bool-constant-or",
             boolToBoolBinary(m, BINOP(|), Module::OR_MAGIC_NAME));
registerRule("bool-constant-and",
             boolToBoolBinary(m, BINOP(&amp;), Module::AND_MAGIC_NAME));

// unary, single constant, int-&gt;int
registerRule("int-constant-pos", intToIntUnary(m, UNOP(+), Module::POS_MAGIC_NAME));
registerRule("int-constant-neg", intToIntUnary(m, UNOP(-), Module::NEG_MAGIC_NAME));
registerRule("int-constant-inv",
             intToIntUnary(m, UNOP(~), Module::INVERT_MAGIC_NAME));

// unary, singe constant, float-&gt;float
registerRule("float-constant-pos",
             floatToFloatUnary(m, UNOP(+), Module::POS_MAGIC_NAME));
registerRule("float-constant-neg",
             floatToFloatUnary(m, UNOP(-), Module::NEG_MAGIC_NAME));

</t>
<t tx="ekr.20230509083242.888">// unary, single constant, bool-&gt;bool
registerRule("bool-constant-inv",
             boolToBoolUnary(m, UNOP(!), Module::INVERT_MAGIC_NAME));

  @others
</t>
<t tx="ekr.20230509083242.889">  // binary, double constant, float-&gt;float
  registerRule("float-constant-addition",
           floatToFloatBinary(m, BINOP(+), Module::ADD_MAGIC_NAME));
@others
</t>
<t tx="ekr.20230509083242.89">def replay(self, history):
    for pos in history:
        self.move(pos)

</t>
<t tx="ekr.20230509083242.890">  registerRule("float-constant-subtraction",
           floatToFloatBinary(m, BINOP(-), Module::SUB_MAGIC_NAME));
  if (pyNumerics) {
registerRule("float-constant-floor-div",
             floatToFloatBinaryNoZeroRHS(m, BINOP(/), Module::TRUE_DIV_MAGIC_NAME));
  } else {
registerRule("float-constant-floor-div",
             floatToFloatBinary(m, BINOP(/), Module::TRUE_DIV_MAGIC_NAME));
  }
</t>
<t tx="ekr.20230509083242.891">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;unordered_map&gt;

#include "codon/cir/transform/folding/rule.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.892">class FoldingPass : public OperatorPass, public Rewriter {
private:
  bool pyNumerics;

  void registerStandardRules(Module *m);

public:
  /// Constructs a folding pass.
  FoldingPass(bool pyNumerics = false)
      : OperatorPass(/*childrenFirst=*/true), pyNumerics(pyNumerics) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void run(Module *m) override;
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083242.893">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "const_prop.h"

#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/analyze/module/global_vars.h"
#include "codon/cir/util/cloning.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {
namespace {
@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.894">bool okConst(Value *v) {
  return v &amp;&amp; (isA&lt;IntConst&gt;(v) || isA&lt;FloatConst&gt;(v) || isA&lt;BoolConst&gt;(v));
}
</t>
<t tx="ekr.20230509083242.895">} // namespace

const std::string ConstPropPass::KEY = "core-folding-const-prop";

</t>
<t tx="ekr.20230509083242.896">void ConstPropPass::handle(VarValue *v) {
  auto *M = v-&gt;getModule();

  auto *var = v-&gt;getVar();

  Value *replacement;
  if (var-&gt;isGlobal()) {
    auto *r = getAnalysisResult&lt;analyze::module::GlobalVarsResult&gt;(globalVarsKey);
    if (!r)
      return;

    auto it = r-&gt;assignments.find(var-&gt;getId());
    if (it == r-&gt;assignments.end())
      return;

    auto *constDef = M-&gt;getValue(it-&gt;second);
    if (!okConst(constDef))
      return;

    util::CloneVisitor cv(M);
    replacement = cv.clone(constDef);
  } else {
    auto *r = getAnalysisResult&lt;analyze::dataflow::RDResult&gt;(reachingDefKey);
    if (!r)
      return;
    auto *c = r-&gt;cfgResult;

    auto it = r-&gt;results.find(getParentFunc()-&gt;getId());
    auto it2 = c-&gt;graphs.find(getParentFunc()-&gt;getId());
    if (it == r-&gt;results.end() || it2 == c-&gt;graphs.end())
      return;

    auto *rd = it-&gt;second.get();
    auto *cfg = it2-&gt;second.get();

    auto reaching = rd-&gt;getReachingDefinitions(var, v);

    if (reaching.size() != 1)
      return;

    auto def = *reaching.begin();
    if (def == -1)
      return;

    auto *constDef = cfg-&gt;getValue(def);
    if (!okConst(constDef))
      return;

    util::CloneVisitor cv(M);
    replacement = cv.clone(constDef);
  }

  v-&gt;replaceAll(replacement);
}

</t>
<t tx="ekr.20230509083242.897">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.898">/// Constant propagation pass.
class ConstPropPass : public OperatorPass {
private:
  /// Key of the reaching definition analysis
  std::string reachingDefKey;
  /// Key of the global variables analysis
  std::string globalVarsKey;

public:
  static const std::string KEY;

  /// Constructs a constant propagation pass.
  /// @param reachingDefKey the reaching definition analysis' key
  /// @param globalVarsKey global variables analysis' key
  ConstPropPass(const std::string &amp;reachingDefKey, const std::string &amp;globalVarsKey)
      : reachingDefKey(reachingDefKey), globalVarsKey(globalVarsKey) {}

  std::string getKey() const override { return KEY; }
  void handle(VarValue *v) override;
};

</t>
<t tx="ekr.20230509083242.899">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "folding.h"

#include "codon/cir/transform/folding/const_fold.h"
#include "codon/cir/transform/folding/const_prop.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

const std::string FoldingPassGroup::KEY = "core-folding-pass-group";

FoldingPassGroup::FoldingPassGroup(const std::string &amp;sideEffectsPass,
@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.9">int main(int argc, char *argv[]) {
  using clock = std::chrono::high_resolution_clock;
  using std::chrono::duration_cast;
  using std::chrono::milliseconds;

  auto t = clock::now();
  int min_depth = 4;
  int n = std::stoi(argv[1]);
  int max_depth = std::max(min_depth + 2, n);
  int stretch_depth = max_depth + 1;

  std::cout &lt;&lt; "stretch tree of depth " &lt;&lt; stretch_depth
            &lt;&lt; "\t check: " &lt;&lt; make_check({0, stretch_depth}) &lt;&lt; '\n';

  auto long_lived_tree = make_tree(max_depth);
  int mmd = max_depth + min_depth;
  for (int d = min_depth; d &lt; stretch_depth; d += 2) {
    int i = (1 &lt;&lt; (mmd - d));
    int cs = 0;
    ArgChunks iter(i, d);
    while (iter.next()) {
      for (auto &amp;argchunk : iter.chunk) {
        cs += make_check(argchunk);
      }
    }
    std::cout &lt;&lt; i &lt;&lt; "\t trees of depth " &lt;&lt; d &lt;&lt; "\t check: " &lt;&lt; cs &lt;&lt; '\n';
  }
  std::cout &lt;&lt; "long lived tree of depth " &lt;&lt; max_depth
            &lt;&lt; "\t check: " &lt;&lt; check_tree(long_lived_tree) &lt;&lt; '\n';
  std::cout &lt;&lt; (duration_cast&lt;milliseconds&gt;(clock::now() - t).count() / 1e3)
            &lt;&lt; std::endl;
}
</t>
<t tx="ekr.20230509083242.90">def score(self, color):
    if color == WHITE:
        count = KOMI + self.black_dead
    else:
        count = self.white_dead
    for square in self.squares:
        squarecolor = square.color
        if squarecolor == color:
            count += 1
        elif squarecolor == EMPTY:
            surround = 0
            for neighbour in square.neighbours:
                if neighbour.color == color:
                    surround += 1
            if surround == len(square.neighbours):
                count += 1
    return count

</t>
<t tx="ekr.20230509083242.900">                                   const std::string &amp;reachingDefPass,
  @others
</t>
<t tx="ekr.20230509083242.901">                                 const std::string &amp;globalVarPass, int repeat,
@others
</t>
<t tx="ekr.20230509083242.902">                                 bool runGlobalDemotion, bool pyNumerics)
  : PassGroup(repeat) {
auto gdUnique = runGlobalDemotion ? std::make_unique&lt;cleanup::GlobalDemotionPass&gt;()
                                  : std::unique_ptr&lt;cleanup::GlobalDemotionPass&gt;();
auto canonUnique = std::make_unique&lt;cleanup::CanonicalizationPass&gt;(sideEffectsPass);
auto fpUnique = std::make_unique&lt;FoldingPass&gt;(pyNumerics);
auto dceUnique = std::make_unique&lt;cleanup::DeadCodeCleanupPass&gt;(sideEffectsPass);

gd = gdUnique.get();
canon = canonUnique.get();
fp = fpUnique.get();
dce = dceUnique.get();

if (runGlobalDemotion)
  push_back(std::move(gdUnique));
push_back(std::make_unique&lt;ConstPropPass&gt;(reachingDefPass, globalVarPass));
push_back(std::move(canonUnique));
push_back(std::move(fpUnique));
push_back(std::move(dceUnique));
}

</t>
<t tx="ekr.20230509083242.903">bool FoldingPassGroup::shouldRepeat(int num) const {
  return PassGroup::shouldRepeat(num) &amp;&amp;
         ((gd &amp;&amp; gd-&gt;getNumDemotions() != 0) || canon-&gt;getNumReplacements() != 0 ||
          fp-&gt;getNumReplacements() != 0 || dce-&gt;getNumReplacements() != 0);
}

</t>
<t tx="ekr.20230509083242.904">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/cleanup/canonical.h"
#include "codon/cir/transform/cleanup/dead_code.h"
#include "codon/cir/transform/cleanup/global_demote.h"
#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

class FoldingPass;

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.905">/// Group of constant folding passes.
class FoldingPassGroup : public PassGroup {
private:
  cleanup::GlobalDemotionPass *gd;
  cleanup::CanonicalizationPass *canon;
  FoldingPass *fp;
  cleanup::DeadCodeCleanupPass *dce;

public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  /// @param sideEffectsPass the key of the side effects pass
  /// @param reachingDefPass the key of the reaching definitions pass
  /// @param globalVarPass the key of the global variables pass
  /// @param repeat default number of times to repeat the pass
  /// @param runGlobalDemotion whether to demote globals if possible
  /// @param pyNumerics whether to use Python (vs. C) semantics when folding
  FoldingPassGroup(const std::string &amp;sideEffectsPass,
                   const std::string &amp;reachingDefPass, const std::string &amp;globalVarPass,
                   int repeat = 5, bool runGlobalDemotion = true,
                   bool pyNumerics = false);

  bool shouldRepeat(int num) const override;
};

</t>
<t tx="ekr.20230509083242.906">@path C:/Repos/codon/codon/cir/transform/folding/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;utility&gt;

#include "codon/cir/transform/pass.h"
#include "codon/cir/transform/rewrite.h"
#include "codon/cir/util/irtools.h"

namespace codon {
namespace ir {
namespace transform {
namespace folding {

@others
} // namespace folding
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.907">/// Commutative, binary rule that requires a single constant.
template &lt;typename ConstantType&gt;
@others
</t>
<t tx="ekr.20230509083242.908">class SingleConstantCommutativeRule : public RewriteRule {
public:
  using Calculator = std::function&lt;Value *(Value *)&gt;;
  enum Kind { LEFT, RIGHT, COMMUTATIVE };

private:
  /// the value being matched against
  ConstantType val;
  /// the type being matched
  types::Type *type;
  /// the magic method name
  std::string magic;
  /// the calculator
  Calculator calc;
  /// left, right or commutative
  Kind kind;

public:
  /// Constructs a commutative rule.
  /// @param val the matched value
  /// @param newVal the result
  /// @param magic the magic name
  /// @param kind left, right, or commutative
  /// @param type the matched type
  SingleConstantCommutativeRule(ConstantType val, ConstantType newVal,
                                std::string magic, Kind kind, types::Type *type)
      : val(val), type(type), magic(std::move(magic)), kind(kind) {
    calc = [=](Value *v) -&gt; Value * {
      return v-&gt;getModule()-&gt;N&lt;TemplatedConst&lt;ConstantType&gt;&gt;(v-&gt;getSrcInfo(), val,
                                                             type);
    };
  }
  /// Constructs a commutative rule.
  /// @param val the matched value
  /// @param newVal the result
  /// @param magic the magic name
  /// @param calc the calculator
  /// @param kind left, right, or commutative
  /// @param type the matched type
  SingleConstantCommutativeRule(ConstantType val, Calculator calc, std::string magic,
                                Kind kind, types::Type *type)
      : val(val), type(type), magic(std::move(magic)), calc(std::move(calc)),
        kind(kind) {}

  virtual ~SingleConstantCommutativeRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509083242.909">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {type, type}, type, /*method=*/true))
      return;

    auto *left = v-&gt;front();
    auto *right = v-&gt;back();
    auto *leftConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(left);
    auto *rightConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(right);

    if ((kind == Kind::COMMUTATIVE || kind == Kind::LEFT) &amp;&amp; leftConst &amp;&amp;
        leftConst-&gt;getVal() == val)
      return setResult(calc(right));
    if ((kind == Kind::COMMUTATIVE || kind == Kind::RIGHT) &amp;&amp; rightConst &amp;&amp;
        rightConst-&gt;getVal() == val)
      return setResult(calc(left));
  }
</t>
<t tx="ekr.20230509083242.91">def check(self):
    for square in self.squares:
        if square.color == EMPTY:
            continue

        members1 = set([square])
        changed = True
        while changed:
            changed = False
            for member in members1.copy():
                for neighbour in member.neighbours:
                    if neighbour.color == square.color and neighbour not in members1:
                        changed = True
                        members1.add(neighbour)
        ledges1 = 0
        for member in members1:
            for neighbour in member.neighbours:
                if neighbour.color == EMPTY:
                    ledges1 += 1

        root = square.find()

        # print 'members1', square, root, members1
        # print 'ledges1', square, ledges1

        members2 = set()
        for square2 in self.squares:
            if square2.color != EMPTY and square2.find() == root:
                members2.add(square2)

        ledges2 = root.ledges
        # print 'members2', square, root, members1
        # print 'ledges2', square, ledges2

        assert members1 == members2
        assert ledges1 == ledges2, ('ledges differ at %r: %d %d' % (
            square, ledges1, ledges2))

        set(self.emptyset.empties)

        empties2 = set()
        for square in self.squares:
            if square.color == EMPTY:
                empties2.add(square.pos)

</t>
<t tx="ekr.20230509083242.910">/// Binary rule that requires two constants.
template &lt;typename ConstantType, typename Func, typename OutputType = ConstantType&gt;
@others
</t>
<t tx="ekr.20230509083242.911">class DoubleConstantBinaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the output type
  types::Type *resultType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a binary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  /// @param resultType the output type
  DoubleConstantBinaryRule(Func f, std::string magic, types::Type *inputType,
                           types::Type *resultType)
      : f(std::move(f)), inputType(inputType), resultType(resultType),
        magic(std::move(magic)) {}

  virtual ~DoubleConstantBinaryRule() noexcept = default;

@others
private:
  Value *toValue(Value *, Value *v) { return v; }

  Value *toValue(Value *og, OutputType v) {
    return og-&gt;getModule()-&gt;template N&lt;TemplatedConst&lt;OutputType&gt;&gt;(og-&gt;getSrcInfo(), v,
                                                                   resultType);
  }
};

</t>
<t tx="ekr.20230509083242.912">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType, inputType}, resultType, /*method=*/true))
      return;

    auto *left = v-&gt;front();
    auto *right = v-&gt;back();
    auto *leftConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(left);
    auto *rightConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(right);

    if (leftConst &amp;&amp; rightConst)
      return setResult(toValue(v, f(leftConst-&gt;getVal(), rightConst-&gt;getVal())));
  }

</t>
<t tx="ekr.20230509083242.913">/// Unary rule that requires one constant.
template &lt;typename ConstantType, typename Func&gt;
@others
</t>
<t tx="ekr.20230509083242.914">class SingleConstantUnaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the output type
  types::Type *resultType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a unary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  /// @param resultType the output type
  SingleConstantUnaryRule(Func f, std::string magic, types::Type *inputType,
                          types::Type *resultType)
      : f(std::move(f)), inputType(inputType), resultType(resultType),
        magic(std::move(magic)) {}

  virtual ~SingleConstantUnaryRule() noexcept = default;

@others
private:
  Value *toValue(Value *, Value *v) { return v; }

  template &lt;typename NewType&gt; Value *toValue(Value *og, NewType v) {
    return og-&gt;getModule()-&gt;template N&lt;TemplatedConst&lt;NewType&gt;&gt;(og-&gt;getSrcInfo(), v,
                                                                resultType);
  }
};

</t>
<t tx="ekr.20230509083242.915">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, resultType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    auto *argConst = cast&lt;TemplatedConst&lt;ConstantType&gt;&gt;(arg);
    if (argConst)
      return setResult(toValue(v, f(argConst-&gt;getVal())));
  }

</t>
<t tx="ekr.20230509083242.916">/// Unary rule that requires no constant.
template &lt;typename Func&gt; class UnaryRule : public RewriteRule {
private:
  /// the calculator
  Func f;
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a unary rule.
  /// @param f the calculator
  /// @param magic the magic method name
  /// @param inputType the input type
  UnaryRule(Func f, std::string magic, types::Type *inputType)
      : f(std::move(f)), inputType(inputType), magic(std::move(magic)) {}

  virtual ~UnaryRule() noexcept = default;

</t>
<t tx="ekr.20230509083242.917">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(f(arg));
  }
</t>
<t tx="ekr.20230509083242.918">};

</t>
<t tx="ekr.20230509083242.919">/// Rule that eliminates an operation, like "+x".
class NoOpRule : public RewriteRule {
private:
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a no-op rule.
  /// @param magic the magic method name
  /// @param inputType the input type
  NoOpRule(std::string magic, types::Type *inputType)
      : inputType(inputType), magic(std::move(magic)) {}

  virtual ~NoOpRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509083242.92">def __repr__(self):
    result = []
    for y in range(SIZE):
        start = to_pos(0, y)
        result.append(''.join(
            [SHOW[square.color] + ' ' for square in self.squares[start:start + SIZE]]))
    return '\n'.join(result)


</t>
<t tx="ekr.20230509083242.920">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(arg);
  }
</t>
<t tx="ekr.20230509083242.921">/// Rule that eliminates a double-application of an operation, like "-(-x)".
class DoubleApplicationNoOpRule : public RewriteRule {
private:
  /// the input type
  types::Type *inputType;
  /// the magic method name
  std::string magic;

public:
  /// Constructs a double-application no-op rule.
  /// @param magic the magic method name
  /// @param inputType the input type
  DoubleApplicationNoOpRule(std::string magic, types::Type *inputType)
      : inputType(inputType), magic(std::move(magic)) {}

  virtual ~DoubleApplicationNoOpRule() noexcept = default;

@others
};

</t>
<t tx="ekr.20230509083242.922">  void visit(CallInstr *v) override {
    if (!util::isCallOf(v, magic, {inputType}, inputType, /*method=*/true))
      return;

    if (!util::isCallOf(v-&gt;front(), magic, {inputType}, inputType, /*method=*/true))
      return;

    auto *arg = v-&gt;front();
    return setResult(cast&lt;CallInstr&gt;(arg)-&gt;front());
  }
</t>
<t tx="ekr.20230509083242.923"></t>
<t tx="ekr.20230509083242.924">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "imperative.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/matching.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {
namespace {
CallInstr *getRangeIter(Value *iter) {
  auto *M = iter-&gt;getModule();

  auto *iterCall = cast&lt;CallInstr&gt;(iter);
  if (!iterCall || iterCall-&gt;numArgs() != 1)
    return nullptr;

  auto *iterFunc = util::getFunc(iterCall-&gt;getCallee());
  if (!iterFunc || iterFunc-&gt;getUnmangledName() != Module::ITER_MAGIC_NAME)
    return nullptr;

  auto *rangeCall = cast&lt;CallInstr&gt;(iterCall-&gt;front());
  if (!rangeCall)
    return nullptr;

  auto *newRangeFunc = util::getFunc(rangeCall-&gt;getCallee());
  if (!newRangeFunc || newRangeFunc-&gt;getUnmangledName() != Module::NEW_MAGIC_NAME)
    return nullptr;
  auto *parentType = newRangeFunc-&gt;getParentType();
  auto *rangeType = M-&gt;getOrRealizeType("range", {}, "std.internal.types.range");

  if (!parentType || !rangeType || parentType-&gt;getName() != rangeType-&gt;getName())
    return nullptr;

  return rangeCall;
}

Value *getListIter(Value *iter) {
  auto *iterCall = cast&lt;CallInstr&gt;(iter);
  if (!iterCall || iterCall-&gt;numArgs() != 1)
    return nullptr;

  auto *iterFunc = util::getFunc(iterCall-&gt;getCallee());
  if (!iterFunc || iterFunc-&gt;getUnmangledName() != Module::ITER_MAGIC_NAME)
    return nullptr;

  auto *list = iterCall-&gt;front();
  if (list-&gt;getType()-&gt;getName().rfind("std.internal.types.ptr.List[", 0) != 0)
    return nullptr;

  return list;
}
} // namespace

const std::string ImperativeForFlowLowering::KEY = "core-imperative-for-lowering";

@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.925">void ImperativeForFlowLowering::handle(ForFlow *v) {
  auto *M = v-&gt;getModule();
  auto *iter = v-&gt;getIter();
  std::unique_ptr&lt;parallel::OMPSched&gt; sched;
  if (v-&gt;isParallel())
    sched = std::make_unique&lt;parallel::OMPSched&gt;(*v-&gt;getSchedule());

  if (auto *rangeCall = getRangeIter(iter)) {
    auto it = rangeCall-&gt;begin();
    auto argCount = std::distance(it, rangeCall-&gt;end());

    util::CloneVisitor cv(M);

    IntConst *stepConst;
    Value *start;
    Value *end;
    int64_t step = 0;

    switch (argCount) {
    case 1:
      start = M-&gt;getInt(0);
      end = cv.clone(*it);
      step = 1;
      break;
    case 2:
      start = cv.clone(*it++);
      end = cv.clone(*it);
      step = 1;
      break;
    case 3:
      start = cv.clone(*it++);
      end = cv.clone(*it++);
      stepConst = cast&lt;IntConst&gt;(*it);
      if (!stepConst)
        return;
      step = stepConst-&gt;getVal();
      break;
    default:
      seqassertn(false, "unknown range constructor");
    }
    if (step == 0)
      return;

    v-&gt;replaceAll(M-&gt;N&lt;ImperativeForFlow&gt;(v-&gt;getSrcInfo(), start, step, end,
                                          v-&gt;getBody(), v-&gt;getVar(), std::move(sched)));
  } else if (auto *list = getListIter(iter)) {
    // convert:
    //   for a in list:
    //     body
    // into:
    //   v = list
    //   n = v.len
    //   p = v.arr.ptr
    //   imp_for i in range(0, n, 1):
    //     a = p[i]
    //     body
    auto *parent = cast&lt;BodiedFunc&gt;(getParentFunc());
    auto *series = M-&gt;N&lt;SeriesFlow&gt;(v-&gt;getSrcInfo());
    auto *listVar = util::makeVar(list, series, parent)-&gt;getVar();
    auto *lenVal = M-&gt;Nr&lt;ExtractInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(listVar), "len");
    auto *lenVar = util::makeVar(lenVal, series, parent);
    auto *ptrVal = M-&gt;Nr&lt;ExtractInstr&gt;(
        M-&gt;Nr&lt;ExtractInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(listVar), "arr"), "ptr");
    auto *ptrVar = util::makeVar(ptrVal, series, parent);

    auto *body = cast&lt;SeriesFlow&gt;(v-&gt;getBody());
    seqassertn(body, "loop body is not a series flow [{}]", v-&gt;getSrcInfo());
    auto *oldLoopVar = v-&gt;getVar();
    auto *newLoopVar = M-&gt;Nr&lt;Var&gt;(M-&gt;getIntType());
    parent-&gt;push_back(newLoopVar);
    auto *replacement = M-&gt;N&lt;ImperativeForFlow&gt;(
        v-&gt;getSrcInfo(), M-&gt;getInt(0), 1, lenVar, body, newLoopVar, std::move(sched));
    series-&gt;push_back(replacement);
    body-&gt;insert(
        body-&gt;begin(),
        M-&gt;Nr&lt;AssignInstr&gt;(oldLoopVar, (*ptrVar)[*M-&gt;Nr&lt;VarValue&gt;(newLoopVar)]));
    v-&gt;replaceAll(series);
  }
}

</t>
<t tx="ekr.20230509083242.926">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {

@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.927">class ImperativeForFlowLowering : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(ForFlow *v) override;
};

</t>
<t tx="ekr.20230509083242.928">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "pipeline.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/matching.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {
namespace {
Value *callStage(Module *M, PipelineFlow::Stage *stage, Value *last) {
  std::vector&lt;Value *&gt; args;
  for (auto *arg : *stage) {
    args.push_back(arg ? arg : last);
  }
  return M-&gt;N&lt;CallInstr&gt;(stage-&gt;getCallee()-&gt;getSrcInfo(), stage-&gt;getCallee(), args);
}

Value *convertPipelineToForLoopsHelper(Module *M, BodiedFunc *parent,
@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.929">                                       const std::vector&lt;PipelineFlow::Stage *&gt; &amp;stages,
  @others
</t>
<t tx="ekr.20230509083242.93">class UCTNode:

    @others
</t>
<t tx="ekr.20230509083242.930">                                     unsigned idx = 0, Value *last = nullptr) {
if (idx &gt;= stages.size())
  return last;

auto *stage = stages[idx];
if (idx == 0)
  return convertPipelineToForLoopsHelper(M, parent, stages, idx + 1,
                                         stage-&gt;getCallee());

auto *prev = stages[idx - 1];
if (prev-&gt;isGenerator()) {
  auto *var = M-&gt;Nr&lt;Var&gt;(prev-&gt;getOutputElementType());
  parent-&gt;push_back(var);
  auto *body = convertPipelineToForLoopsHelper(
      M, parent, stages, idx + 1, callStage(M, stage, M-&gt;Nr&lt;VarValue&gt;(var)));
  auto *loop = M-&gt;N&lt;ForFlow&gt;(last-&gt;getSrcInfo(), last, util::series(body), var);
  if (stage-&gt;isParallel())
    loop-&gt;setParallel();
  return loop;
} else {
  return convertPipelineToForLoopsHelper(M, parent, stages, idx + 1,
                                         callStage(M, stage, last));
}
}

</t>
<t tx="ekr.20230509083242.931">Value *convertPipelineToForLoops(PipelineFlow *p, BodiedFunc *parent) {
  std::vector&lt;PipelineFlow::Stage *&gt; stages;
  for (auto &amp;stage : *p) {
    stages.push_back(&amp;stage);
  }
  return convertPipelineToForLoopsHelper(p-&gt;getModule(), parent, stages);
}
} // namespace

const std::string PipelineLowering::KEY = "core-pipeline-lowering";

</t>
<t tx="ekr.20230509083242.932">void PipelineLowering::handle(PipelineFlow *v) {
  v-&gt;replaceAll(convertPipelineToForLoops(v, cast&lt;BodiedFunc&gt;(getParentFunc())));
}

</t>
<t tx="ekr.20230509083242.933">@path C:/Repos/codon/codon/cir/transform/lowering/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace lowering {

@others
} // namespace lowering
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.934">/// Converts pipelines to for-loops
class PipelineLowering : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(PipelineFlow *v) override;
};

</t>
<t tx="ekr.20230509083242.935"></t>
<t tx="ekr.20230509083242.936">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "openmp.h"

#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;limits&gt;
#include &lt;unordered_set&gt;

#include "codon/cir/transform/parallel/schedule.h"
#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/outlining.h"

namespace codon {
namespace ir {
namespace transform {
namespace parallel {
namespace {
const std::string ompModule = "std.openmp";
const std::string gpuModule = "std.gpu";
const std::string builtinModule = "std.internal.builtin";

@others
} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.937">void warn(const std::string &amp;msg, const Value *v) {
  auto src = v-&gt;getSrcInfo();
  compilationWarning(msg, src.file, src.line, src.col);
}

</t>
<t tx="ekr.20230509083242.938">struct OMPTypes {
  types::Type *i64 = nullptr;
  types::Type *i32 = nullptr;
  types::Type *i8ptr = nullptr;
  types::Type *i32ptr = nullptr;

  explicit OMPTypes(Module *M) {
    i64 = M-&gt;getIntType();
    i32 = M-&gt;getIntNType(32, /*sign=*/true);
    i8ptr = M-&gt;getPointerType(M-&gt;getByteType());
    i32ptr = M-&gt;getPointerType(i32);
  }
};

Var *getVarFromOutlinedArg(Value *arg) {
  if (auto *val = cast&lt;VarValue&gt;(arg)) {
    return val-&gt;getVar();
  } else if (auto *val = cast&lt;PointerValue&gt;(arg)) {
    return val-&gt;getVar();
  } else {
    seqassertn(false, "unknown outline var");
  }
  return nullptr;
}

Value *ptrFromFunc(Func *func) {
  auto *M = func-&gt;getModule();
  auto *funcType = func-&gt;getType();
  auto *rawMethod = M-&gt;getOrRealizeMethod(funcType, "__raw__", {funcType});
  seqassertn(rawMethod, "cannot find function __raw__ method");
  return util::call(rawMethod, {M-&gt;Nr&lt;VarValue&gt;(func)});
}

// we create the locks lazily to avoid them when they're not needed
struct ReductionLocks {
  Var *mainLock =
      nullptr; // lock used in calls to _reduce_no_wait and _end_reduce_no_wait
  Var *critLock = nullptr; // lock used in reduction critical sections

  Var *createLock(Module *M) {
    auto *lockType = M-&gt;getOrRealizeType("Lock", {}, ompModule);
    seqassertn(lockType, "openmp.Lock type not found");
    auto *var = M-&gt;Nr&lt;Var&gt;(lockType, /*global=*/true);
    static int counter = 1;
    var-&gt;setName(".omp_lock." + std::to_string(counter++));

    // add it to main function so it doesn't get demoted by IR pass
    auto *series = cast&lt;SeriesFlow&gt;(cast&lt;BodiedFunc&gt;(M-&gt;getMainFunc())-&gt;getBody());
    auto *init = (*lockType)();
    seqassertn(init, "could not initialize openmp.Lock");
    series-&gt;insert(series-&gt;begin(), M-&gt;Nr&lt;AssignInstr&gt;(var, init));

    return var;
  }

  Var *getMainLock(Module *M) {
    if (!mainLock)
      mainLock = createLock(M);
    return mainLock;
  }

  Var *getCritLock(Module *M) {
    if (!critLock)
      critLock = createLock(M);
    return critLock;
  }
};

struct Reduction {
  enum Kind {
    NONE,
    ADD,
    MUL,
    AND,
    OR,
    XOR,
    MIN,
    MAX,
  };

  Kind kind = Kind::NONE;
  Var *shared = nullptr;

  types::Type *getType() {
    auto *ptrType = cast&lt;types::PointerType&gt;(shared-&gt;getType());
    seqassertn(ptrType, "expected shared var to be of pointer type");
    return ptrType-&gt;getBase();
  }

  Value *getInitial() {
    if (!*this)
      return nullptr;
    auto *M = shared-&gt;getModule();
    auto *type = getType();

    if (isA&lt;types::IntType&gt;(type)) {
      switch (kind) {
      case Kind::ADD:
        return M-&gt;getInt(0);
      case Kind::MUL:
        return M-&gt;getInt(1);
      case Kind::AND:
        return M-&gt;getInt(~0);
      case Kind::OR:
        return M-&gt;getInt(0);
      case Kind::XOR:
        return M-&gt;getInt(0);
      case Kind::MIN:
        return M-&gt;getInt(std::numeric_limits&lt;int64_t&gt;::max());
      case Kind::MAX:
        return M-&gt;getInt(std::numeric_limits&lt;int64_t&gt;::min());
      default:
        return nullptr;
      }
    } else if (isA&lt;types::FloatType&gt;(type)) {
      switch (kind) {
      case Kind::ADD:
        return M-&gt;getFloat(0.);
      case Kind::MUL:
        return M-&gt;getFloat(1.);
      case Kind::MIN:
        return M-&gt;getFloat(std::numeric_limits&lt;double&gt;::max());
      case Kind::MAX:
        return M-&gt;getFloat(std::numeric_limits&lt;double&gt;::min());
      default:
        return nullptr;
      }
    } else if (isA&lt;types::Float32Type&gt;(type)) {
      auto *f32 = M-&gt;getOrRealizeType("float32");
      float value = 0.0;

      switch (kind) {
      case Kind::ADD:
        value = 0.0;
        break;
      case Kind::MUL:
        value = 1.0;
        break;
      case Kind::MIN:
        value = std::numeric_limits&lt;float&gt;::max();
        break;
      case Kind::MAX:
        value = std::numeric_limits&lt;float&gt;::min();
        break;
      default:
        return nullptr;
      }

      return (*f32)(*M-&gt;getFloat(value));
    }

    auto *init = (*type)();
    if (!init || !init-&gt;getType()-&gt;is(type))
      return nullptr;
    return init;
  }

  Value *generateNonAtomicReduction(Value *ptr, Value *arg) {
    auto *M = ptr-&gt;getModule();
    Value *lhs = util::ptrLoad(ptr);
    Value *result = nullptr;
    switch (kind) {
    case Kind::ADD:
      result = *lhs + *arg;
      break;
    case Kind::MUL:
      result = *lhs * *arg;
      break;
    case Kind::AND:
      result = *lhs &amp; *arg;
      break;
    case Kind::OR:
      result = *lhs | *arg;
      break;
    case Kind::XOR:
      result = *lhs ^ *arg;
      break;
    case Kind::MIN: {
      auto *tup = util::makeTuple({lhs, arg});
      auto *fn = M-&gt;getOrRealizeFunc("min", {tup-&gt;getType()}, {}, builtinModule);
      seqassertn(fn, "min function not found");
      result = util::call(fn, {tup});
      break;
    }
    case Kind::MAX: {
      auto *tup = util::makeTuple({lhs, arg});
      auto *fn = M-&gt;getOrRealizeFunc("max", {tup-&gt;getType()}, {}, builtinModule);
      seqassertn(fn, "max function not found");
      result = util::call(fn, {tup});
      break;
    }
    default:
      return nullptr;
    }
    return util::ptrStore(ptr, result);
  }

  Value *generateAtomicReduction(Value *ptr, Value *arg, Var *loc, Var *gtid,
                                 ReductionLocks &amp;locks) {
    auto *M = ptr-&gt;getModule();
    auto *type = getType();
    std::string func = "";

    if (isA&lt;types::IntType&gt;(type)) {
      switch (kind) {
      case Kind::ADD:
        func = "_atomic_int_add";
        break;
      case Kind::MUL:
        func = "_atomic_int_mul";
        break;
      case Kind::AND:
        func = "_atomic_int_and";
        break;
      case Kind::OR:
        func = "_atomic_int_or";
        break;
      case Kind::XOR:
        func = "_atomic_int_xor";
        break;
      case Kind::MIN:
        func = "_atomic_int_min";
        break;
      case Kind::MAX:
        func = "_atomic_int_max";
        break;
      default:
        break;
      }
    } else if (isA&lt;types::FloatType&gt;(type)) {
      switch (kind) {
      case Kind::ADD:
        func = "_atomic_float_add";
        break;
      case Kind::MUL:
        func = "_atomic_float_mul";
        break;
      case Kind::MIN:
        func = "_atomic_float_min";
        break;
      case Kind::MAX:
        func = "_atomic_float_max";
        break;
      default:
        break;
      }
    } else if (isA&lt;types::Float32Type&gt;(type)) {
      switch (kind) {
      case Kind::ADD:
        func = "_atomic_float32_add";
        break;
      case Kind::MUL:
        func = "_atomic_float32_mul";
        break;
      case Kind::MIN:
        func = "_atomic_float32_min";
        break;
      case Kind::MAX:
        func = "_atomic_float32_max";
        break;
      default:
        break;
      }
    }

    if (!func.empty()) {
      auto *atomicOp =
          M-&gt;getOrRealizeFunc(func, {ptr-&gt;getType(), arg-&gt;getType()}, {}, ompModule);
      seqassertn(atomicOp, "atomic op '{}' not found", func);
      return util::call(atomicOp, {ptr, arg});
    }

    switch (kind) {
    case Kind::ADD:
      func = "__atomic_add__";
      break;
    case Kind::MUL:
      func = "__atomic_mul__";
      break;
    case Kind::AND:
      func = "__atomic_and__";
      break;
    case Kind::OR:
      func = "__atomic_or__";
      break;
    case Kind::XOR:
      func = "__atomic_xor__";
      break;
    case Kind::MIN:
      func = "__atomic_min__";
      break;
    case Kind::MAX:
      func = "__atomic_max__";
      break;
    default:
      break;
    }

    if (!func.empty()) {
      auto *atomicOp =
          M-&gt;getOrRealizeMethod(arg-&gt;getType(), func, {ptr-&gt;getType(), arg-&gt;getType()});
      if (atomicOp)
        return util::call(atomicOp, {ptr, arg});
    }

    seqassertn(loc &amp;&amp; gtid, "loc and/or gtid are null");
    auto *lck = locks.getCritLock(M);
    auto *lckPtrType = M-&gt;getPointerType(lck-&gt;getType());
    auto *critBegin = M-&gt;getOrRealizeFunc("_critical_begin",
                                          {loc-&gt;getType(), gtid-&gt;getType(), lckPtrType},
                                          {}, ompModule);
    seqassertn(critBegin, "critical begin function not found");
    auto *critEnd = M-&gt;getOrRealizeFunc(
        "_critical_end", {loc-&gt;getType(), gtid-&gt;getType(), lckPtrType}, {}, ompModule);
    seqassertn(critEnd, "critical end function not found");

    auto *critEnter =
        util::call(critBegin, {M-&gt;Nr&lt;VarValue&gt;(loc), M-&gt;Nr&lt;VarValue&gt;(gtid),
                               M-&gt;Nr&lt;PointerValue&gt;(lck)});
    auto *operation = generateNonAtomicReduction(ptr, arg);
    auto *critExit = util::call(critEnd, {M-&gt;Nr&lt;VarValue&gt;(loc), M-&gt;Nr&lt;VarValue&gt;(gtid),
                                          M-&gt;Nr&lt;PointerValue&gt;(lck)});
    // make sure the unlock is in a finally-block
    return util::series(critEnter, M-&gt;Nr&lt;TryCatchFlow&gt;(util::series(operation),
                                                       util::series(critExit)));
  }

  operator bool() const { return kind != Kind::NONE; }
};

struct ReductionFunction {
  std::string name;
  Reduction::Kind kind;
  bool method;
};

struct ReductionIdentifier : public util::Operator {
  std::vector&lt;Var *&gt; shareds;
  Var *loopVarArg;
  std::unordered_map&lt;id_t, Reduction&gt; reductions;

  ReductionIdentifier()
      : util::Operator(), shareds(), loopVarArg(nullptr), reductions() {}

  ReductionIdentifier(std::vector&lt;Var *&gt; shareds, Var *loopVarArg)
      : util::Operator(), shareds(std::move(shareds)), loopVarArg(loopVarArg),
        reductions() {}

</t>
<t tx="ekr.20230509083242.939">  bool isShared(Var *shared) {
    if (loopVarArg &amp;&amp; shared-&gt;getId() == loopVarArg-&gt;getId())
      return false;
    for (auto *v : shareds) {
      if (shared-&gt;getId() == v-&gt;getId())
        return true;
    }
    return false;
  }

</t>
<t tx="ekr.20230509083242.94">def __init__(self):
    self.bestchild = None
    self.pos = -1
    self.wins = 0
    self.losses = 0
    self.pos_child = [None for x in range(SIZE * SIZE)]
    self.parent = None

</t>
<t tx="ekr.20230509083242.940">  bool isSharedDeref(Var *shared, Value *v) {
    auto *M = v-&gt;getModule();
    auto *ptrType = cast&lt;types::PointerType&gt;(shared-&gt;getType());
    seqassertn(ptrType, "expected shared var to be of pointer type");
    auto *type = ptrType-&gt;getBase();

    if (util::isCallOf(v, Module::GETITEM_MAGIC_NAME, {ptrType, M-&gt;getIntType()}, type,
                       /*method=*/true)) {
      auto *call = cast&lt;CallInstr&gt;(v);
      auto *var = util::getVar(call-&gt;front());
      return util::isConst&lt;int64_t&gt;(call-&gt;back(), 0) &amp;&amp; var &amp;&amp;
             var-&gt;getId() == shared-&gt;getId();
    }

    return false;
  }

</t>
<t tx="ekr.20230509083242.941">  static void extractAssociativeOpChain(Value *v, const std::string &amp;op,
                                        types::Type *type,
                                        std::vector&lt;Value *&gt; &amp;result) {
    if (util::isCallOf(v, op, {type, type}, type, /*method=*/true)) {
      auto *call = cast&lt;CallInstr&gt;(v);
      extractAssociativeOpChain(call-&gt;front(), op, type, result);
      extractAssociativeOpChain(call-&gt;back(), op, type, result);
    } else {
      result.push_back(v);
    }
  }

</t>
<t tx="ekr.20230509083242.942">  Reduction getReductionFromCall(CallInstr *v) {
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v-&gt;getCallee());
    if (v-&gt;numArgs() != 3 || !func ||
        func-&gt;getUnmangledName() != Module::SETITEM_MAGIC_NAME)
      return {};

    std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
    Value *self = args[0];
    Value *idx = args[1];
    Value *item = args[2];

    Var *shared = util::getVar(self);
    if (!shared || !isShared(shared) || !util::isConst&lt;int64_t&gt;(idx, 0))
      return {};

    auto *ptrType = cast&lt;types::PointerType&gt;(shared-&gt;getType());
    seqassertn(ptrType, "expected shared var to be of pointer type");
    auto *type = ptrType-&gt;getBase();

    // double-check the call
    if (!util::isCallOf(v, Module::SETITEM_MAGIC_NAME,
                        {self-&gt;getType(), idx-&gt;getType(), item-&gt;getType()},
                        M-&gt;getNoneType(), /*method=*/true))
      return {};

</t>
<t tx="ekr.20230509083242.943">    const std::vector&lt;ReductionFunction&gt; reductionFunctions = {
        {Module::ADD_MAGIC_NAME, Reduction::Kind::ADD, true},
        {Module::MUL_MAGIC_NAME, Reduction::Kind::MUL, true},
        {Module::AND_MAGIC_NAME, Reduction::Kind::AND, true},
        {Module::OR_MAGIC_NAME, Reduction::Kind::OR, true},
        {Module::XOR_MAGIC_NAME, Reduction::Kind::XOR, true},
        {"min", Reduction::Kind::MIN, false},
        {"max", Reduction::Kind::MAX, false},
    };

</t>
<t tx="ekr.20230509083242.944">    for (auto &amp;rf : reductionFunctions) {
      if (rf.method) {
        if (!util::isCallOf(item, rf.name, {type, type}, type, /*method=*/true))
          continue;
      } else {
        if (!util::isCallOf(item, rf.name, {M-&gt;getTupleType({type, type})}, type,
                            /*method=*/false))
          continue;
      }

      auto *callRHS = cast&lt;CallInstr&gt;(item);
      Value *deref = nullptr;

      if (rf.method) {
        std::vector&lt;Value *&gt; opChain;
        extractAssociativeOpChain(callRHS, rf.name, callRHS-&gt;front()-&gt;getType(),
                                  opChain);
        if (opChain.size() &lt; 2)
          continue;

        for (auto *val : opChain) {
          if (isSharedDeref(shared, val)) {
            deref = val;
            break;
          }
        }
      } else {
        callRHS = cast&lt;CallInstr&gt;(callRHS-&gt;front()); // this will be Tuple.__new__
        if (!callRHS)
          continue;

        for (auto *val : *callRHS) {
          if (isSharedDeref(shared, val)) {
            deref = val;
            break;
          }
        }
      }

      if (!deref)
        return {};

      Reduction reduction = {rf.kind, shared};
      if (!reduction.getInitial())
        return {};

      return reduction;
    }

    return {};
  }

  Reduction getReduction(Var *shared) {
    auto it = reductions.find(shared-&gt;getId());
    return (it != reductions.end()) ? it-&gt;second : Reduction();
  }

</t>
<t tx="ekr.20230509083242.945">  void handle(CallInstr *v) override {
    if (auto reduction = getReductionFromCall(v)) {
      auto it = reductions.find(reduction.shared-&gt;getId());
      // if we've seen the var before, make sure it's consistent
      // otherwise mark as invalid via an empty reduction
      if (it == reductions.end()) {
        reductions.emplace(reduction.shared-&gt;getId(), reduction);
      } else if (it-&gt;second &amp;&amp; it-&gt;second.kind != reduction.kind) {
        it-&gt;second = {};
      }
    }
  }
</t>
<t tx="ekr.20230509083242.946">};

struct SharedInfo {
  unsigned memb;       // member index in template's `extra` arg
  Var *local;          // the local var we create to store current value
  Reduction reduction; // the reduction we're performing, or empty if none
};

struct LoopTemplateReplacer : public util::Operator {
  BodiedFunc *parent;
  CallInstr *replacement;
  Var *loopVar;

  LoopTemplateReplacer(BodiedFunc *parent, CallInstr *replacement, Var *loopVar)
      : util::Operator(), parent(parent), replacement(replacement), loopVar(loopVar) {}
};

struct ParallelLoopTemplateReplacer : public LoopTemplateReplacer {
  ReductionIdentifier *reds;
  std::vector&lt;SharedInfo&gt; sharedInfo;
  ReductionLocks locks;
  Var *locRef;
  Var *reductionLocRef;
  Var *gtid;

  ParallelLoopTemplateReplacer(BodiedFunc *parent, CallInstr *replacement, Var *loopVar,
                               ReductionIdentifier *reds)
      : LoopTemplateReplacer(parent, replacement, loopVar), reds(reds), sharedInfo(),
        locks(), locRef(nullptr), reductionLocRef(nullptr), gtid(nullptr) {}

</t>
<t tx="ekr.20230509083242.947">  unsigned numReductions() {
    unsigned num = 0;
    for (auto &amp;info : sharedInfo) {
      if (info.reduction)
        num += 1;
    }
    return num;
  }

</t>
<t tx="ekr.20230509083242.948">  Value *getReductionTuple() {
    auto *M = parent-&gt;getModule();
    std::vector&lt;Value *&gt; elements;
    for (auto &amp;info : sharedInfo) {
      if (info.reduction)
        elements.push_back(M-&gt;Nr&lt;PointerValue&gt;(info.local));
    }
    return util::makeTuple(elements, M);
  }

  BodiedFunc *makeReductionFunc() {
    auto *M = parent-&gt;getModule();
    auto *tupleType = getReductionTuple()-&gt;getType();
    auto *argType = M-&gt;getPointerType(tupleType);
    auto *funcType = M-&gt;getFuncType(M-&gt;getNoneType(), {argType, argType});
    auto *reducer = M-&gt;Nr&lt;BodiedFunc&gt;("__omp_reducer");
    reducer-&gt;realize(funcType, {"lhs", "rhs"});

    auto *lhsVar = reducer-&gt;arg_front();
    auto *rhsVar = reducer-&gt;arg_back();
    auto *body = M-&gt;Nr&lt;SeriesFlow&gt;();
    unsigned next = 0;
    for (auto &amp;info : sharedInfo) {
      if (info.reduction) {
        auto *lhs = util::ptrLoad(M-&gt;Nr&lt;VarValue&gt;(lhsVar));
        auto *rhs = util::ptrLoad(M-&gt;Nr&lt;VarValue&gt;(rhsVar));
        auto *lhsElem = util::tupleGet(lhs, next);
        auto *rhsElem = util::tupleGet(rhs, next);
        body-&gt;push_back(
            info.reduction.generateNonAtomicReduction(lhsElem, util::ptrLoad(rhsElem)));
        ++next;
      }
    }
    reducer-&gt;setBody(body);
    return reducer;
  }

</t>
<t tx="ekr.20230509083242.949">  void handle(CallInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v-&gt;getCallee());
    if (!func)
      return;
    auto name = func-&gt;getUnmangledName();

    if (name == "_loop_loc_and_gtid") {
      seqassertn(v-&gt;numArgs() == 3 &amp;&amp;
                     std::all_of(v-&gt;begin(), v-&gt;end(),
                                 [](auto x) { return isA&lt;VarValue&gt;(x); }),
                 "unexpected loop loc and gtid stub");
      std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
      locRef = util::getVar(args[0]);
      reductionLocRef = util::getVar(args[1]);
      gtid = util::getVar(args[2]);
    }

    if (name == "_loop_reductions") {
      seqassertn(reductionLocRef &amp;&amp; gtid, "bad visit order in template");
      seqassertn(v-&gt;numArgs() == 1 &amp;&amp; isA&lt;VarValue&gt;(v-&gt;front()),
                 "unexpected shared updates stub");
      if (numReductions() == 0)
        return;

      auto *M = parent-&gt;getModule();
      auto *extras = util::getVar(v-&gt;front());
      auto *reductionTuple = getReductionTuple();
      auto *reducer = makeReductionFunc();
      auto *lck = locks.getMainLock(M);
      auto *rawReducer = ptrFromFunc(reducer);

      auto *lckPtrType = M-&gt;getPointerType(lck-&gt;getType());
      auto *reduceNoWait = M-&gt;getOrRealizeFunc(
          "_reduce_nowait",
          {reductionLocRef-&gt;getType(), gtid-&gt;getType(), reductionTuple-&gt;getType(),
           rawReducer-&gt;getType(), lckPtrType},
          {}, ompModule);
      seqassertn(reduceNoWait, "reduce nowait function not found");
      auto *reduceNoWaitEnd = M-&gt;getOrRealizeFunc(
          "_end_reduce_nowait",
          {reductionLocRef-&gt;getType(), gtid-&gt;getType(), lckPtrType}, {}, ompModule);
      seqassertn(reduceNoWaitEnd, "end reduce nowait function not found");

      auto *series = M-&gt;Nr&lt;SeriesFlow&gt;();
      auto *tupleVal = util::makeVar(reductionTuple, series, parent);
      auto *reduceCode = util::call(
          reduceNoWait, {M-&gt;Nr&lt;VarValue&gt;(reductionLocRef), M-&gt;Nr&lt;VarValue&gt;(gtid),
                         tupleVal, rawReducer, M-&gt;Nr&lt;PointerValue&gt;(lck)});
      auto *codeVar = util::makeVar(reduceCode, series, parent)-&gt;getVar();
      seqassertn(codeVar-&gt;getType()-&gt;is(M-&gt;getIntType()), "wrong reduce code type");

      auto *sectionNonAtomic = M-&gt;Nr&lt;SeriesFlow&gt;();
      auto *sectionAtomic = M-&gt;Nr&lt;SeriesFlow&gt;();

      for (auto &amp;info : sharedInfo) {
        if (info.reduction) {
          Value *ptr = util::tupleGet(M-&gt;Nr&lt;VarValue&gt;(extras), info.memb);
          Value *arg = M-&gt;Nr&lt;VarValue&gt;(info.local);
          sectionNonAtomic-&gt;push_back(
              info.reduction.generateNonAtomicReduction(ptr, arg));
        }
      }
      sectionNonAtomic-&gt;push_back(util::call(
          reduceNoWaitEnd, {M-&gt;Nr&lt;VarValue&gt;(reductionLocRef), M-&gt;Nr&lt;VarValue&gt;(gtid),
                            M-&gt;Nr&lt;PointerValue&gt;(lck)}));

      for (auto &amp;info : sharedInfo) {
        if (info.reduction) {
          Value *ptr = util::tupleGet(M-&gt;Nr&lt;VarValue&gt;(extras), info.memb);
          Value *arg = M-&gt;Nr&lt;VarValue&gt;(info.local);
          sectionAtomic-&gt;push_back(
              info.reduction.generateAtomicReduction(ptr, arg, locRef, gtid, locks));
        }
      }

      // make: if code == 1 { sectionNonAtomic } elif code == 2 { sectionAtomic }
      auto *theSwitch = M-&gt;Nr&lt;IfFlow&gt;(
          *M-&gt;Nr&lt;VarValue&gt;(codeVar) == *M-&gt;getInt(1), sectionNonAtomic,
          util::series(M-&gt;Nr&lt;IfFlow&gt;(*M-&gt;Nr&lt;VarValue&gt;(codeVar) == *M-&gt;getInt(2),
                                     sectionAtomic)));
      series-&gt;push_back(theSwitch);
      v-&gt;replaceAll(series);
    }
  }
</t>
<t tx="ekr.20230509083242.95">def play(self, board):
    """ uct tree search """
    color = board.color
    node = self
    path = [node]
    while True:
        pos = node.select(board)
        if pos == PASS:
            break
        board.move(pos)
        child = node.pos_child[pos]
        if not child:
            child = node.pos_child[pos] = UCTNode()
            child.unexplored = board.useful_moves()
            child.pos = pos
            child.parent = node
            path.append(child)
            break
        path.append(child)
        node = child
    self.random_playout(board)
    self.update_path(board, color, path)

</t>
<t tx="ekr.20230509083242.950">};

struct ImperativeLoopTemplateReplacer : public ParallelLoopTemplateReplacer {
  OMPSched *sched;
  int64_t step;

  ImperativeLoopTemplateReplacer(BodiedFunc *parent, CallInstr *replacement,
                                 Var *loopVar, ReductionIdentifier *reds,
                                 OMPSched *sched, int64_t step)
      : ParallelLoopTemplateReplacer(parent, replacement, loopVar, reds), sched(sched),
        step(step) {}

</t>
<t tx="ekr.20230509083242.951">  void handle(CallInstr *v) override {
    ParallelLoopTemplateReplacer::handle(v);
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v-&gt;getCallee());
    if (!func)
      return;
    auto name = func-&gt;getUnmangledName();

    if (name == "_loop_step") {
      v-&gt;replaceAll(M-&gt;getInt(step));
    }

    if (name == "_loop_body_stub") {
      seqassertn(replacement, "unexpected double replacement");
      seqassertn(v-&gt;numArgs() == 2 &amp;&amp; isA&lt;VarValue&gt;(v-&gt;front()) &amp;&amp;
                     isA&lt;VarValue&gt;(v-&gt;back()),
                 "unexpected loop body stub");

      auto *outlinedFunc = util::getFunc(replacement-&gt;getCallee());

      // the template passes the new loop var and extra args
      // to the body stub for convenience
      auto *newLoopVar = util::getVar(v-&gt;front());
      auto *extras = util::getVar(v-&gt;back());

      std::vector&lt;Value *&gt; newArgs;
      auto outlinedArgs = outlinedFunc-&gt;arg_begin(); // arg vars of *outlined func*
      unsigned next = 0; // next index in "extra" args tuple, passed to template
      // `arg` is an argument of the original outlined func call
      for (auto *arg : *replacement) {
        if (getVarFromOutlinedArg(arg)-&gt;getId() != loopVar-&gt;getId()) {
          Value *newArg = nullptr;

          // shared vars will be stored in a new var
          if (isA&lt;PointerValue&gt;(arg)) {
            types::Type *base = cast&lt;types::PointerType&gt;(arg-&gt;getType())-&gt;getBase();

            // get extras again since we'll be inserting the new var before extras local
            Var *lastArg = parent-&gt;arg_back(); // ptr to {chunk, start, stop, extras}
            Value *val = util::tupleGet(util::ptrLoad(M-&gt;Nr&lt;VarValue&gt;(lastArg)), 3);
            Value *initVal = util::ptrLoad(util::tupleGet(val, next));

            Reduction reduction = reds-&gt;getReduction(*outlinedArgs);
            if (reduction) {
              initVal = reduction.getInitial();
              seqassertn(initVal &amp;&amp; initVal-&gt;getType()-&gt;is(base),
                         "unknown reduction init value");
            }

            VarValue *newVar = util::makeVar(
                initVal, cast&lt;SeriesFlow&gt;(parent-&gt;getBody()), parent, /*prepend=*/true);
            sharedInfo.push_back({next, newVar-&gt;getVar(), reduction});

            newArg = M-&gt;Nr&lt;PointerValue&gt;(newVar-&gt;getVar());
            ++next;
          } else {
            newArg = util::tupleGet(M-&gt;Nr&lt;VarValue&gt;(extras), next++);
          }

          newArgs.push_back(newArg);
        } else {
          if (isA&lt;VarValue&gt;(arg)) {
            newArgs.push_back(M-&gt;Nr&lt;VarValue&gt;(newLoopVar));
          } else if (isA&lt;PointerValue&gt;(arg)) {
            newArgs.push_back(M-&gt;Nr&lt;PointerValue&gt;(newLoopVar));
          } else {
            seqassertn(false, "unknown outline var");
          }
        }

        ++outlinedArgs;
      }

      v-&gt;replaceAll(util::call(outlinedFunc, newArgs));
      replacement = nullptr;
    }

    if (name == "_loop_shared_updates") {
      // for all non-reduction shareds, set the final values
      // this will be similar to OpenMP's "lastprivate"
      seqassertn(v-&gt;numArgs() == 1 &amp;&amp; isA&lt;VarValue&gt;(v-&gt;front()),
                 "unexpected shared updates stub");
      auto *extras = util::getVar(v-&gt;front());
      auto *series = M-&gt;Nr&lt;SeriesFlow&gt;();

      for (auto &amp;info : sharedInfo) {
        if (info.reduction)
          continue;

        auto *finalValue = M-&gt;Nr&lt;VarValue&gt;(info.local);
        auto *val = M-&gt;Nr&lt;VarValue&gt;(extras);
        auto *origPtr = util::tupleGet(val, info.memb);
        series-&gt;push_back(util::ptrStore(origPtr, finalValue));
      }

      v-&gt;replaceAll(series);
    }

    if (name == "_loop_schedule") {
      v-&gt;replaceAll(M-&gt;getInt(sched-&gt;code));
    }

    if (name == "_loop_ordered") {
      v-&gt;replaceAll(M-&gt;getBool(sched-&gt;ordered));
    }
  }
</t>
<t tx="ekr.20230509083242.952">};

struct TaskLoopReductionVarReplacer : public util::Operator {
  std::vector&lt;Var *&gt; reductionArgs;
  std::vector&lt;std::pair&lt;Var *, Var *&gt;&gt; reductionRemap;
  BodiedFunc *parent;

</t>
<t tx="ekr.20230509083242.953">  void setupReductionRemap() {
    auto *M = parent-&gt;getModule();

    for (auto *var : reductionArgs) {
      auto *newVar = M-&gt;Nr&lt;Var&gt;(var-&gt;getType(), /*global=*/false);
      reductionRemap.emplace_back(var, newVar);
    }
  }

</t>
<t tx="ekr.20230509083242.954">  TaskLoopReductionVarReplacer(std::vector&lt;Var *&gt; reductionArgs, BodiedFunc *parent)
      : util::Operator(), reductionArgs(std::move(reductionArgs)), reductionRemap(),
        parent(parent) {
    setupReductionRemap();
  }

</t>
<t tx="ekr.20230509083242.955">  void preHook(Node *v) override {
    for (auto &amp;p : reductionRemap) {
      v-&gt;replaceUsedVariable(p.first-&gt;getId(), p.second);
    }
  }

</t>
<t tx="ekr.20230509083242.956">  // need to do this as a separate step since otherwise the old variable
  // in the assignment will be replaced, which we don't want
  void finalize() {
    auto *M = parent-&gt;getModule();
    auto *body = cast&lt;SeriesFlow&gt;(parent-&gt;getBody());
    auto *gtid = parent-&gt;arg_back();

    for (auto &amp;p : reductionRemap) {
      auto *taskRedData = M-&gt;getOrRealizeFunc(
          "_taskred_data", {M-&gt;getIntType(), p.first-&gt;getType()}, {}, ompModule);
      seqassertn(taskRedData, "could not find '_taskred_data'");

      auto *assign = M-&gt;Nr&lt;AssignInstr&gt;(
          p.second,
          util::call(taskRedData, {M-&gt;Nr&lt;VarValue&gt;(gtid), M-&gt;Nr&lt;VarValue&gt;(p.first)}));
      body-&gt;insert(body-&gt;begin(), assign);
      parent-&gt;push_back(p.second);
    }
  }
</t>
<t tx="ekr.20230509083242.957">};

struct TaskLoopBodyStubReplacer : public util::Operator {
  CallInstr *replacement;
  std::vector&lt;bool&gt; reduceArgs;

  TaskLoopBodyStubReplacer(CallInstr *replacement, std::vector&lt;bool&gt; reduceArgs)
      : util::Operator(), replacement(replacement), reduceArgs(std::move(reduceArgs)) {}

</t>
<t tx="ekr.20230509083242.958">  void handle(CallInstr *v) override {
    auto *func = util::getFunc(v-&gt;getCallee());
    if (func &amp;&amp; func-&gt;getUnmangledName() == "_task_loop_body_stub") {
      seqassertn(replacement, "unexpected double replacement");
      seqassertn(v-&gt;numArgs() == 3 &amp;&amp; isA&lt;VarValue&gt;(v-&gt;front()) &amp;&amp;
                     isA&lt;VarValue&gt;(v-&gt;back()),
                 "unexpected loop body stub");

      // the template passes gtid, privs and shareds to the body stub for convenience
      std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
      auto *gtid = args[0];
      auto *privatesTuple = args[1];
      auto *sharedsTuple = args[2];
      unsigned privatesNext = 0;
      unsigned sharedsNext = 0;
      std::vector&lt;Value *&gt; newArgs;
    @others
      auto *outlinedFunc = cast&lt;BodiedFunc&gt;(util::getFunc(replacement-&gt;getCallee()));

      if (hasReductions) {
        newArgs.push_back(gtid);

        std::vector&lt;Var *&gt; reductionArgs;
        unsigned i = 0;
        for (auto it = outlinedFunc-&gt;arg_begin(); it != outlinedFunc-&gt;arg_end(); ++it) {
          if (reduceArgs[i++])
            reductionArgs.push_back(*it);
        }
        TaskLoopReductionVarReplacer redrep(reductionArgs, outlinedFunc);
        outlinedFunc-&gt;accept(redrep);
        redrep.finalize();
      }

      v-&gt;replaceAll(util::call(outlinedFunc, newArgs));
      replacement = nullptr;
    }
  }
</t>
<t tx="ekr.20230509083242.959">  bool hasReductions =
      std::any_of(reduceArgs.begin(), reduceArgs.end(), [](bool b) { return b; });

  for (auto *arg : *replacement) {
    if (isA&lt;VarValue&gt;(arg)) {
      newArgs.push_back(util::tupleGet(privatesTuple, privatesNext++));
    } else if (isA&lt;PointerValue&gt;(arg)) {
      newArgs.push_back(util::tupleGet(sharedsTuple, sharedsNext++));
    } else {
      // make sure we're on the last arg, which should be gtid
      // in case of reductions
      seqassertn(hasReductions &amp;&amp; arg == replacement-&gt;back(),
                 "unknown outline var");
    }
  }

</t>
<t tx="ekr.20230509083242.96">def select(self, board):
    """ select move; unexplored children first, then according to uct value """
    if self.unexplored:
        i = random.randrange(len(self.unexplored))
        pos = self.unexplored[i]
        self.unexplored[i] = self.unexplored[len(self.unexplored) - 1]
        self.unexplored.pop()
        return pos
    elif self.bestchild:
        return self.bestchild.pos
    else:
        return PASS

</t>
<t tx="ekr.20230509083242.960">};

struct TaskLoopRoutineStubReplacer : public ParallelLoopTemplateReplacer {
  std::vector&lt;Value *&gt; privates;
  std::vector&lt;Value *&gt; shareds;
  Var *array;  // task reduction input array
  Var *tskgrp; // task group identifier

</t>
<t tx="ekr.20230509083242.961">  void setupSharedInfo(std::vector&lt;Reduction&gt; &amp;sharedRedux) {
    unsigned sharedsNext = 0;
    for (auto *val : shareds) {
      if (getVarFromOutlinedArg(val)-&gt;getId() != loopVar-&gt;getId()) {
        if (auto &amp;reduction = sharedRedux[sharedsNext]) {
          Var *newVar = util::getVar(util::makeVar(
              reduction.getInitial(), cast&lt;SeriesFlow&gt;(parent-&gt;getBody()), parent,
              /*prepend=*/true));
          sharedInfo.push_back({sharedsNext, newVar, reduction});
        }
      }
      ++sharedsNext;
    }
  }

</t>
<t tx="ekr.20230509083242.962">  TaskLoopRoutineStubReplacer(BodiedFunc *parent, CallInstr *replacement, Var *loopVar,
                              ReductionIdentifier *reds, std::vector&lt;Value *&gt; privates,
                              std::vector&lt;Value *&gt; shareds,
                              std::vector&lt;Reduction&gt; sharedRedux)
      : ParallelLoopTemplateReplacer(parent, replacement, loopVar, reds),
        privates(std::move(privates)), shareds(std::move(shareds)), array(nullptr),
        tskgrp(nullptr) {
    setupSharedInfo(sharedRedux);
  }

  BodiedFunc *makeTaskRedInitFunc(Reduction *reduction) {
    auto *M = parent-&gt;getModule();
    auto *argType = M-&gt;getPointerType(reduction-&gt;getType());
    auto *funcType = M-&gt;getFuncType(M-&gt;getNoneType(), {argType, argType});
    auto *initializer = M-&gt;Nr&lt;BodiedFunc&gt;("__red_init");
    initializer-&gt;realize(funcType, {"lhs", "rhs"});

    auto *lhsVar = initializer-&gt;arg_front();
    auto *body = M-&gt;Nr&lt;SeriesFlow&gt;();
    auto *lhsPtr = M-&gt;Nr&lt;VarValue&gt;(lhsVar);
    body-&gt;push_back(util::ptrStore(lhsPtr, reduction-&gt;getInitial()));
    initializer-&gt;setBody(body);
    return initializer;
  }

  BodiedFunc *makeTaskRedCombFunc(Reduction *reduction) {
    auto *M = parent-&gt;getModule();
    auto *argType = M-&gt;getPointerType(reduction-&gt;getType());
    auto *funcType = M-&gt;getFuncType(M-&gt;getNoneType(), {argType, argType});
    auto *reducer = M-&gt;Nr&lt;BodiedFunc&gt;("__red_comb");
    reducer-&gt;realize(funcType, {"lhs", "rhs"});

    auto *lhsVar = reducer-&gt;arg_front();
    auto *rhsVar = reducer-&gt;arg_back();
    auto *body = M-&gt;Nr&lt;SeriesFlow&gt;();
    auto *lhsPtr = M-&gt;Nr&lt;VarValue&gt;(lhsVar);
    auto *rhsPtr = M-&gt;Nr&lt;VarValue&gt;(rhsVar);
    body-&gt;push_back(
        reduction-&gt;generateNonAtomicReduction(lhsPtr, util::ptrLoad(rhsPtr)));
    reducer-&gt;setBody(body);
    return reducer;
  }

  Value *makeTaskRedInput(Reduction *reduction, Value *shar, Value *orig) {
    auto *M = shar-&gt;getModule();
    auto *size = M-&gt;Nr&lt;TypePropertyInstr&gt;(reduction-&gt;getType(),
                                          TypePropertyInstr::Property::SIZEOF);
    auto *init = ptrFromFunc(makeTaskRedInitFunc(reduction));
    auto *comb = ptrFromFunc(makeTaskRedCombFunc(reduction));

    auto *taskRedInputType = M-&gt;getOrRealizeType("TaskReductionInput", {}, ompModule);
    seqassertn(taskRedInputType, "could not find 'TaskReductionInput' type");
    auto *result = taskRedInputType-&gt;construct({shar, orig, size, init, comb});
    seqassertn(result, "bad construction of 'TaskReductionInput' type");
    return result;
  }

</t>
<t tx="ekr.20230509083242.963">  void handle(VarValue *v) override {
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v);
    if (func &amp;&amp; func-&gt;getUnmangledName() == "_routine_stub") {
      std::vector&lt;bool&gt; reduceArgs;
      unsigned sharedsNext = 0;
      unsigned infoNext = 0;

      for (auto *arg : *replacement) {
        if (isA&lt;VarValue&gt;(arg)) {
          reduceArgs.push_back(false);
        } else if (isA&lt;PointerValue&gt;(arg)) {
          if (infoNext &lt; sharedInfo.size() &amp;&amp;
              sharedInfo[infoNext].memb == sharedsNext &amp;&amp;
              sharedInfo[infoNext].reduction) {
            reduceArgs.push_back(true);
            ++infoNext;
          } else {
            reduceArgs.push_back(false);
          }
          ++sharedsNext;
        } else {
          // make sure we're on the last arg, which should be gtid
          // in case of reductions
          seqassertn(numReductions() &gt; 0 &amp;&amp; arg == replacement-&gt;back(),
                     "unknown outline var");
          reduceArgs.push_back(false);
        }
      }

      util::CloneVisitor cv(M);
      auto *newRoutine = cv.forceClone(func);
      TaskLoopBodyStubReplacer rep(replacement, reduceArgs);
      newRoutine-&gt;accept(rep);
      v-&gt;setVar(newRoutine);
    }
  }

</t>
<t tx="ekr.20230509083242.964">  void handle(CallInstr *v) override {
    ParallelLoopTemplateReplacer::handle(v);
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v-&gt;getCallee());
    if (!func)
      return;
    auto name = func-&gt;getUnmangledName();

    if (name == "_taskred_setup") {
      seqassertn(reductionLocRef &amp;&amp; gtid, "bad visit order in template");
      seqassertn(v-&gt;numArgs() == 1 &amp;&amp; isA&lt;VarValue&gt;(v-&gt;front()),
                 "unexpected shared updates stub");
      unsigned numRed = numReductions();
      if (numRed == 0)
        return;

      auto *M = parent-&gt;getModule();
      auto *extras = util::getVar(v-&gt;front());

      // add task reduction inputs
      auto *taskRedInitSeries = M-&gt;Nr&lt;SeriesFlow&gt;();
      auto *taskRedInputType = M-&gt;getOrRealizeType("TaskReductionInput", {}, ompModule);
      seqassertn(taskRedInputType, "could not find 'TaskReductionInput' type");
      auto *irArrayType = M-&gt;getOrRealizeType("TaskReductionInputArray", {}, ompModule);
      seqassertn(irArrayType, "could not find 'TaskReductionInputArray' type");
      auto *taskRedInputsArray = util::makeVar(
          M-&gt;Nr&lt;StackAllocInstr&gt;(irArrayType, numRed), taskRedInitSeries, parent);
      array = util::getVar(taskRedInputsArray);
      auto *taskRedInputsArrayType = taskRedInputsArray-&gt;getType();

      auto *taskRedSetItem = M-&gt;getOrRealizeMethod(
          taskRedInputsArrayType, Module::SETITEM_MAGIC_NAME,
          {taskRedInputsArrayType, M-&gt;getIntType(), taskRedInputType});
      seqassertn(taskRedSetItem,
                 "could not find 'TaskReductionInputArray.__setitem__' method");
      int i = 0;
      for (auto &amp;info : sharedInfo) {
        if (info.reduction) {
          Value *shar = M-&gt;Nr&lt;PointerValue&gt;(info.local);
          Value *orig = util::tupleGet(M-&gt;Nr&lt;VarValue&gt;(extras), info.memb);
          auto *taskRedInput = makeTaskRedInput(&amp;info.reduction, shar, orig);
          taskRedInitSeries-&gt;push_back(util::call(
              taskRedSetItem, {M-&gt;Nr&lt;VarValue&gt;(array), M-&gt;getInt(i++), taskRedInput}));
        }
      }

      auto *arrayPtr = M-&gt;Nr&lt;ExtractInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(array), "ptr");
      auto *taskRedInitFunc =
          M-&gt;getOrRealizeFunc("_taskred_init",
                              {reductionLocRef-&gt;getType(), gtid-&gt;getType(),
                               M-&gt;getIntType(), arrayPtr-&gt;getType()},
                              {}, ompModule);
      seqassertn(taskRedInitFunc, "task red init function not found");
      auto *taskRedInitResult =
          util::makeVar(util::call(taskRedInitFunc, {M-&gt;Nr&lt;VarValue&gt;(reductionLocRef),
                                                     M-&gt;Nr&lt;VarValue&gt;(gtid),
                                                     M-&gt;getInt(numRed), arrayPtr}),
                        taskRedInitSeries, parent);
      tskgrp = util::getVar(taskRedInitResult);
      v-&gt;replaceAll(taskRedInitSeries);
    }

    if (name == "_fix_privates_and_shareds") {
      std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
      seqassertn(args.size() == 3, "invalid _fix_privates_and_shareds call found");
      unsigned numRed = numReductions();
      auto *newLoopVar = args[0];
      auto *privatesTuple = args[1];
      auto *sharedsTuple = args[2];

      unsigned privatesNext = 0;
      unsigned sharedsNext = 0;
      unsigned infoNext = 0;

      bool needNewPrivates = false;
      bool needNewShareds = false;

      std::vector&lt;Value *&gt; newPrivates;
      std::vector&lt;Value *&gt; newShareds;

      for (auto *val : privates) {
        if (numRed &gt; 0 &amp;&amp; val == privates.back()) { // i.e. task group identifier
          seqassertn(tskgrp, "tskgrp var not set");
          newPrivates.push_back(M-&gt;Nr&lt;VarValue&gt;(tskgrp));
          needNewPrivates = true;
        } else if (getVarFromOutlinedArg(val)-&gt;getId() != loopVar-&gt;getId()) {
          newPrivates.push_back(util::tupleGet(privatesTuple, privatesNext));
        } else {
          newPrivates.push_back(newLoopVar);
          needNewPrivates = true;
        }
        ++privatesNext;
      }

      for (auto *val : shareds) {
        if (getVarFromOutlinedArg(val)-&gt;getId() != loopVar-&gt;getId()) {
          if (infoNext &lt; sharedInfo.size() &amp;&amp;
              sharedInfo[infoNext].memb == sharedsNext &amp;&amp;
              sharedInfo[infoNext].reduction) {
            newShareds.push_back(M-&gt;Nr&lt;PointerValue&gt;(sharedInfo[infoNext].local));
            needNewShareds = true;
            ++infoNext;
          } else {
            newShareds.push_back(util::tupleGet(sharedsTuple, sharedsNext));
          }
        } else {
          newShareds.push_back(M-&gt;Nr&lt;PointerValue&gt;(util::getVar(newLoopVar)));
          needNewShareds = true;
        }
        ++sharedsNext;
      }

      privatesTuple = needNewPrivates ? util::makeTuple(newPrivates, M) : privatesTuple;
      sharedsTuple = needNewShareds ? util::makeTuple(newShareds, M) : sharedsTuple;

      Value *result = util::makeTuple({privatesTuple, sharedsTuple}, M);
      v-&gt;replaceAll(result);
    }

    if (name == "_taskred_finish") {
      seqassertn(reductionLocRef &amp;&amp; gtid, "bad visit order in template");
      if (numReductions() == 0)
        return;

      auto *taskRedFini = M-&gt;getOrRealizeFunc(
          "_taskred_fini", {reductionLocRef-&gt;getType(), gtid-&gt;getType()}, {},
          ompModule);
      seqassertn(taskRedFini, "taskred finish function not found not found");
      v-&gt;replaceAll(util::call(
          taskRedFini, {M-&gt;Nr&lt;VarValue&gt;(reductionLocRef), M-&gt;Nr&lt;VarValue&gt;(gtid)}));
    }
  }
</t>
<t tx="ekr.20230509083242.965">};

struct GPULoopBodyStubReplacer : public util::Operator {
  CallInstr *replacement;
  Var *loopVar;
  int64_t step;

  GPULoopBodyStubReplacer(CallInstr *replacement, Var *loopVar, int64_t step)
      : util::Operator(), replacement(replacement), loopVar(loopVar), step(step) {}

</t>
<t tx="ekr.20230509083242.966">  void handle(CallInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *func = util::getFunc(v-&gt;getCallee());
    if (!func)
      return;
    auto name = func-&gt;getUnmangledName();

    if (name == "_gpu_loop_body_stub") {
      seqassertn(replacement, "unexpected double replacement");
      seqassertn(v-&gt;numArgs() == 2, "unexpected loop body stub");

      // the template passes gtid, privs and shareds to the body stub for convenience
      auto *idx = v-&gt;front();
      auto *args = v-&gt;back();
      unsigned next = 0;

      std::vector&lt;Value *&gt; newArgs;
      for (auto *arg : *replacement) {
        // std::cout &lt;&lt; "A: " &lt;&lt; *arg &lt;&lt; std::endl;
        if (getVarFromOutlinedArg(arg)-&gt;getId() == loopVar-&gt;getId()) {
          // std::cout &lt;&lt; "(loop var)" &lt;&lt; std::endl;
          newArgs.push_back(idx);
        } else {
          newArgs.push_back(util::tupleGet(args, next++));
        }
      }

      auto *outlinedFunc = cast&lt;BodiedFunc&gt;(util::getFunc(replacement-&gt;getCallee()));
      v-&gt;replaceAll(util::call(outlinedFunc, newArgs));
      replacement = nullptr;
    }

    if (name == "_loop_step") {
      v-&gt;replaceAll(M-&gt;getInt(step));
    }
  }
</t>
<t tx="ekr.20230509083242.967">};

struct GPULoopTemplateReplacer : public LoopTemplateReplacer {
  int64_t step;

  GPULoopTemplateReplacer(BodiedFunc *parent, CallInstr *replacement, Var *loopVar,
</t>
<t tx="ekr.20230509083242.968">                          int64_t step)
      : LoopTemplateReplacer(parent, replacement, loopVar), step(step) {}

    @others
</t>
<t tx="ekr.20230509083242.969">  void handle(CallInstr *v) override {
auto *M = v-&gt;getModule();
auto *func = util::getFunc(v-&gt;getCallee());
if (!func)
  return;
auto name = func-&gt;getUnmangledName();

if (name == "_loop_step") {
  v-&gt;replaceAll(M-&gt;getInt(step));
}
  }
</t>
<t tx="ekr.20230509083242.97">def random_playout(self, board):
    """ random play until both players pass """
    for x in range(MAXMOVES):  # XXX while not self.finished?
        if board.finished:
            break
        board.move(board.random_move())

</t>
<t tx="ekr.20230509083242.970">};

struct OpenMPTransformData {
  util::OutlineResult outline;
  std::vector&lt;Var *&gt; sharedVars;
  ReductionIdentifier reds;
};

template &lt;typename T&gt; OpenMPTransformData unpar(T *v) {
  v-&gt;setParallel(false);
  return {{}, {}, {}};
}

</t>
<t tx="ekr.20230509083242.971">template &lt;typename T&gt;
OpenMPTransformData setupOpenMPTransform(T *v, BodiedFunc *parent, bool gpu) {
  if (!v-&gt;isParallel())
    return unpar(v);
  auto *M = v-&gt;getModule();
  auto *body = cast&lt;SeriesFlow&gt;(v-&gt;getBody());
  if (!parent || !body)
    return unpar(v);
  auto outline = util::outlineRegion(parent, body, /*allowOutflows=*/false,
                                     /*outlineGlobals=*/true, /*allByValue=*/gpu);
  if (!outline)
    return unpar(v);

  // set up args to pass fork_call
  Var *loopVar = v-&gt;getVar();
  std::vector&lt;Value *&gt; outlineCallArgs(outline.call-&gt;begin(), outline.call-&gt;end());

  // shared argument vars
  std::vector&lt;Var *&gt; sharedVars;
  Var *loopVarArg = nullptr;
  unsigned i = 0;
  for (auto it = outline.func-&gt;arg_begin(); it != outline.func-&gt;arg_end(); ++it) {
    // pick out loop variable to pass to reduction identifier, which will
    // ensure we don't reduce over it
    if (getVarFromOutlinedArg(outlineCallArgs[i])-&gt;getId() == loopVar-&gt;getId())
      loopVarArg = *it;
    if (outline.argKinds[i] == util::OutlineResult::ArgKind::MODIFIED)
      sharedVars.push_back(*it);
    ++i;
  }
  ReductionIdentifier reds(sharedVars, loopVarArg);
  outline.func-&gt;accept(reds);

  return {outline, sharedVars, reds};
}

</t>
<t tx="ekr.20230509083242.972">struct ForkCallData {
  CallInstr *fork = nullptr;
  CallInstr *pushNumThreads = nullptr;
};

ForkCallData createForkCall(Module *M, OMPTypes &amp;types, Value *rawTemplateFunc,
</t>
<t tx="ekr.20230509083242.973">                            const std::vector&lt;Value *&gt; &amp;forkExtraArgs,
                            transform::parallel::OMPSched *sched) {
  ForkCallData result;
  auto *forkExtra = util::makeTuple(forkExtraArgs, M);
  std::vector&lt;types::Type *&gt; forkArgTypes = {types.i8ptr, forkExtra-&gt;getType()};
  auto *forkFunc = M-&gt;getOrRealizeFunc("_fork_call", forkArgTypes, {}, ompModule);
  seqassertn(forkFunc, "fork call function not found");
  result.fork = util::call(forkFunc, {rawTemplateFunc, forkExtra});

  if (sched-&gt;threads &amp;&amp; sched-&gt;threads-&gt;getType()-&gt;is(types.i64)) {
    auto *pushNumThreadsFunc =
        M-&gt;getOrRealizeFunc("_push_num_threads", {types.i64}, {}, ompModule);
    seqassertn(pushNumThreadsFunc, "push num threads func not found");
    result.pushNumThreads = util::call(pushNumThreadsFunc, {sched-&gt;threads});
  }
  return result;
}

</t>
<t tx="ekr.20230509083242.974">struct CollapseResult {
  ImperativeForFlow *collapsed = nullptr;
  SeriesFlow *setup = nullptr;
  std::string error;

  operator bool() const { return collapsed != nullptr; }
};

struct LoopRange {
  ImperativeForFlow *loop;
  Var *start;
  Var *stop;
  int64_t step;
  Var *len;
};

CollapseResult collapseLoop(BodiedFunc *parent, ImperativeForFlow *v, int64_t levels) {
</t>
<t tx="ekr.20230509083242.975">  auto fail = [](const std::string &amp;error) {
    CollapseResult bad;
    bad.error = error;
    return bad;
  };

</t>
<t tx="ekr.20230509083242.976">  auto *M = v-&gt;getModule();
  CollapseResult res;
  if (levels &lt; 1)
    return fail("'collapse' must be at least 1");

  std::vector&lt;ImperativeForFlow *&gt; loopNests = {v};
  ImperativeForFlow *curr = v;

  for (auto i = 0; i &lt; levels - 1; i++) {
    auto *body = cast&lt;SeriesFlow&gt;(curr-&gt;getBody());
    seqassertn(body, "unexpected loop body");
    if (std::distance(body-&gt;begin(), body-&gt;end()) != 1 ||
        !isA&lt;ImperativeForFlow&gt;(body-&gt;front()))
      return fail("loop nest not collapsible");

    curr = cast&lt;ImperativeForFlow&gt;(body-&gt;front());
    loopNests.push_back(curr);
  }

  std::vector&lt;LoopRange&gt; ranges;
  auto *setup = M-&gt;Nr&lt;SeriesFlow&gt;();

  auto *intType = M-&gt;getIntType();
  auto *lenCalc =
      M-&gt;getOrRealizeFunc("_range_len", {intType, intType, intType}, {}, ompModule);
  seqassertn(lenCalc, "range length calculation function not found");

  for (auto *loop : loopNests) {
    LoopRange range;
    range.loop = loop;
    range.start = util::makeVar(loop-&gt;getStart(), setup, parent)-&gt;getVar();
    range.stop = util::makeVar(loop-&gt;getEnd(), setup, parent)-&gt;getVar();
    range.step = loop-&gt;getStep();
    range.len = util::makeVar(util::call(lenCalc, {M-&gt;Nr&lt;VarValue&gt;(range.start),
                                                   M-&gt;Nr&lt;VarValue&gt;(range.stop),
                                                   M-&gt;getInt(range.step)}),
                              setup, parent)
                    -&gt;getVar();
    ranges.push_back(range);
  }

  auto *numIters = M-&gt;getInt(1);
  for (auto &amp;range : ranges) {
    numIters = (*numIters) * (*M-&gt;Nr&lt;VarValue&gt;(range.len));
  }

  auto *collapsedVar = M-&gt;Nr&lt;Var&gt;(M-&gt;getIntType(), /*global=*/false);
  parent-&gt;push_back(collapsedVar);
  auto *body = M-&gt;Nr&lt;SeriesFlow&gt;();
  auto sched = std::make_unique&lt;OMPSched&gt;(*v-&gt;getSchedule());
  sched-&gt;collapse = 0;
  auto *collapsed = M-&gt;Nr&lt;ImperativeForFlow&gt;(M-&gt;getInt(0), 1, numIters, body,
                                             collapsedVar, std::move(sched));

  // reconstruct indices by successive divmods
  Var *lastDiv = nullptr;
  for (auto it = ranges.rbegin(); it != ranges.rend(); ++it) {
    auto *k = lastDiv ? lastDiv : collapsedVar;
    auto *div =
        util::makeVar(*M-&gt;Nr&lt;VarValue&gt;(k) / *M-&gt;Nr&lt;VarValue&gt;(it-&gt;len), body, parent)
            -&gt;getVar();
    auto *mod =
        util::makeVar(*M-&gt;Nr&lt;VarValue&gt;(k) % *M-&gt;Nr&lt;VarValue&gt;(it-&gt;len), body, parent)
            -&gt;getVar();
    auto *i =
        *M-&gt;Nr&lt;VarValue&gt;(it-&gt;start) + *(*M-&gt;Nr&lt;VarValue&gt;(mod) * *M-&gt;getInt(it-&gt;step));
    body-&gt;push_back(M-&gt;Nr&lt;AssignInstr&gt;(it-&gt;loop-&gt;getVar(), i));
    lastDiv = div;
  }

  auto *oldBody = cast&lt;SeriesFlow&gt;(loopNests.back()-&gt;getBody());
  for (auto *x : *oldBody) {
    body-&gt;push_back(x);
  }

  res.collapsed = collapsed;
  res.setup = setup;

  return res;
}
} // namespace

const std::string OpenMPPass::KEY = "core-parallel-openmp";

</t>
<t tx="ekr.20230509083242.977">void OpenMPPass::handle(ForFlow *v) {
  auto data = setupOpenMPTransform(v, cast&lt;BodiedFunc&gt;(getParentFunc()), /*gpu=*/false);
  if (!v-&gt;isParallel())
    return;

  auto &amp;outline = data.outline;
  auto &amp;sharedVars = data.sharedVars;
  auto &amp;reds = data.reds;

  auto *M = v-&gt;getModule();
  auto *loopVar = v-&gt;getVar();
  auto *sched = v-&gt;getSchedule();
  OMPTypes types(M);

  // separate arguments into 'private' and 'shared'
  std::vector&lt;Reduction&gt; sharedRedux; // reductions corresponding to shared vars
  std::vector&lt;Value *&gt; privates, shareds;
  unsigned i = 0;
  for (auto *arg : *outline.call) {
    if (isA&lt;VarValue&gt;(arg)) {
      privates.push_back(arg);
    } else {
      shareds.push_back(arg);
      sharedRedux.push_back(reds.getReduction(sharedVars[i++]));
    }
  }

  util::CloneVisitor cv(M);

  // We need to pass the task group identifier returned from
  // __kmpc_taskred_modifier_init to the task entry, so append
  // it to private data (initially as null void pointer). Also
  // we add an argument to the end of the outlined function for
  // the gtid.
  if (reds.reductions.size() &gt; 0) {
    auto *nullPtr = types.i8ptr-&gt;construct({});
    privates.push_back(nullPtr);

    auto *outlinedFuncType = cast&lt;types::FuncType&gt;(outline.func-&gt;getType());
    std::vector&lt;types::Type *&gt; argTypes(outlinedFuncType-&gt;begin(),
                                        outlinedFuncType-&gt;end());
    argTypes.push_back(M-&gt;getIntType());
    auto *retType = outlinedFuncType-&gt;getReturnType();

    std::vector&lt;Var *&gt; oldArgVars(outline.func-&gt;arg_begin(), outline.func-&gt;arg_end());
    std::vector&lt;std::string&gt; argNames;

    for (auto *var : oldArgVars) {
      argNames.push_back(var-&gt;getName());
    }
    argNames.push_back("gtid");

    auto *newOutlinedFunc = M-&gt;Nr&lt;BodiedFunc&gt;("__outlined_new");
    newOutlinedFunc-&gt;realize(M-&gt;getFuncType(retType, argTypes), argNames);

    std::vector&lt;Var *&gt; newArgVars(newOutlinedFunc-&gt;arg_begin(),
                                  newOutlinedFunc-&gt;arg_end());

    std::unordered_map&lt;id_t, Var *&gt; remaps;
    for (unsigned i = 0; i &lt; oldArgVars.size(); i++) {
      remaps.emplace(oldArgVars[i]-&gt;getId(), newArgVars[i]);
    }
    auto *newBody =
        cast&lt;SeriesFlow&gt;(cv.clone(outline.func-&gt;getBody(), newOutlinedFunc, remaps));
    newOutlinedFunc-&gt;setBody(newBody);

    // update outline struct
    outline.func = newOutlinedFunc;
    outline.call-&gt;setCallee(M-&gt;Nr&lt;VarValue&gt;(newOutlinedFunc));
    outline.call-&gt;insert(outline.call-&gt;end(), M-&gt;getInt(0));
    outline.argKinds.push_back(util::OutlineResult::ArgKind::CONSTANT);
  }

  auto *privatesTuple = util::makeTuple(privates, M);
  auto *sharedsTuple = util::makeTuple(shareds, M);

  // template call
  std::vector&lt;types::Type *&gt; templateFuncArgs = {
      types.i32ptr, types.i32ptr,
      M-&gt;getPointerType(
          M-&gt;getTupleType({v-&gt;getIter()-&gt;getType(), privatesTuple-&gt;getType(),
                           sharedsTuple-&gt;getType()}))};
  auto *templateFunc = M-&gt;getOrRealizeFunc("_task_loop_outline_template",
                                           templateFuncArgs, {}, ompModule);
  seqassertn(templateFunc, "task loop outline template not found");

  templateFunc = cv.forceClone(templateFunc);
  TaskLoopRoutineStubReplacer rep(cast&lt;BodiedFunc&gt;(templateFunc), outline.call, loopVar,
                                  &amp;reds, privates, shareds, sharedRedux);
  templateFunc-&gt;accept(rep);
  auto *rawTemplateFunc = ptrFromFunc(templateFunc);

  std::vector&lt;Value *&gt; forkExtraArgs = {v-&gt;getIter(), privatesTuple, sharedsTuple};

  // fork call
  auto forkData = createForkCall(M, types, rawTemplateFunc, forkExtraArgs, sched);
  if (forkData.pushNumThreads)
    insertBefore(forkData.pushNumThreads);
  v-&gt;replaceAll(forkData.fork);
}

</t>
<t tx="ekr.20230509083242.978">void OpenMPPass::handle(ImperativeForFlow *v) {
  auto *parent = cast&lt;BodiedFunc&gt;(getParentFunc());

  if (v-&gt;isParallel() &amp;&amp; v-&gt;getSchedule()-&gt;collapse != 0) {
    auto levels = v-&gt;getSchedule()-&gt;collapse;
    auto collapse = collapseLoop(parent, v, levels);

    if (collapse) {
      v-&gt;replaceAll(collapse.collapsed);
      v = collapse.collapsed;
      insertBefore(collapse.setup);
    } else if (!collapse.error.empty()) {
      warn("could not collapse loop: " + collapse.error, v);
    }
  }

  auto data =
      setupOpenMPTransform(v, parent, (v-&gt;isParallel() &amp;&amp; v-&gt;getSchedule()-&gt;gpu));
  if (!v-&gt;isParallel())
    return;

  auto &amp;outline = data.outline;
  auto &amp;sharedVars = data.sharedVars;
  auto &amp;reds = data.reds;

  auto *M = v-&gt;getModule();
  auto *loopVar = v-&gt;getVar();
  auto *sched = v-&gt;getSchedule();
  OMPTypes types(M);

  // we disable shared vars for GPU loops
  seqassertn(!(sched-&gt;gpu &amp;&amp; !sharedVars.empty()), "GPU-parallel loop had shared vars");

  // gather extra arguments
  std::vector&lt;Value *&gt; extraArgs;
  std::vector&lt;types::Type *&gt; extraArgTypes;
  for (auto *arg : *outline.call) {
    if (getVarFromOutlinedArg(arg)-&gt;getId() != loopVar-&gt;getId()) {
      extraArgs.push_back(arg);
      extraArgTypes.push_back(arg-&gt;getType());
    }
  }

  // template call
  std::string templateFuncName;
  if (sched-&gt;gpu) {
    templateFuncName = "_gpu_loop_outline_template";
  } else if (sched-&gt;dynamic) {
    templateFuncName = "_dynamic_loop_outline_template";
  } else if (sched-&gt;chunk) {
    templateFuncName = "_static_chunked_loop_outline_template";
  } else {
    templateFuncName = "_static_loop_outline_template";
  }

  if (sched-&gt;gpu) {
    std::unordered_set&lt;id_t&gt; kernels;
    const std::string gpuAttr = "std.gpu.kernel";
    for (auto *var : *M) {
      if (auto *func = cast&lt;BodiedFunc&gt;(var)) {
        if (util::hasAttribute(func, gpuAttr))
          kernels.insert(func-&gt;getId());
      }
    }

    std::vector&lt;types::Type *&gt; templateFuncArgs = {types.i64, types.i64,
                                                   M-&gt;getTupleType(extraArgTypes)};
    static int64_t instance = 0;
    auto *templateFunc = M-&gt;getOrRealizeFunc(templateFuncName, templateFuncArgs,
                                             {instance++}, gpuModule);

    if (!templateFunc) {
      warn("loop not compilable for GPU; ignoring", v);
      v-&gt;setParallel(false);
      return;
    }

    BodiedFunc *kernel = nullptr;
    for (auto *var : *M) {
      if (auto *func = cast&lt;BodiedFunc&gt;(var)) {
        if (util::hasAttribute(func, gpuAttr) &amp;&amp; kernels.count(func-&gt;getId()) == 0) {
          seqassertn(!kernel, "multiple new kernels found after instantiation");
          kernel = func;
        }
      }
    }
    seqassertn(kernel, "no new kernel found");
    GPULoopBodyStubReplacer brep(outline.call, loopVar, v-&gt;getStep());
    kernel-&gt;accept(brep);

    util::CloneVisitor cv(M);
    templateFunc = cast&lt;Func&gt;(cv.forceClone(templateFunc));
    GPULoopTemplateReplacer rep(cast&lt;BodiedFunc&gt;(templateFunc), outline.call, loopVar,
                                v-&gt;getStep());
    templateFunc-&gt;accept(rep);
    v-&gt;replaceAll(util::call(
        templateFunc, {v-&gt;getStart(), v-&gt;getEnd(), util::makeTuple(extraArgs, M)}));
  } else {
    std::vector&lt;types::Type *&gt; templateFuncArgs = {
        types.i32ptr, types.i32ptr,
        M-&gt;getPointerType(M-&gt;getTupleType(
            {types.i64, types.i64, types.i64, M-&gt;getTupleType(extraArgTypes)}))};
    auto *templateFunc =
        M-&gt;getOrRealizeFunc(templateFuncName, templateFuncArgs, {}, ompModule);
    seqassertn(templateFunc, "imperative loop outline template not found");

    util::CloneVisitor cv(M);
    templateFunc = cast&lt;Func&gt;(cv.forceClone(templateFunc));
    ImperativeLoopTemplateReplacer rep(cast&lt;BodiedFunc&gt;(templateFunc), outline.call,
                                       loopVar, &amp;reds, sched, v-&gt;getStep());
    templateFunc-&gt;accept(rep);
    auto *rawTemplateFunc = ptrFromFunc(templateFunc);

    auto *chunk = (sched-&gt;chunk &amp;&amp; sched-&gt;chunk-&gt;getType()-&gt;is(types.i64))
                      ? sched-&gt;chunk
                      : M-&gt;getInt(1);
    std::vector&lt;Value *&gt; forkExtraArgs = {chunk, v-&gt;getStart(), v-&gt;getEnd()};
    for (auto *arg : extraArgs) {
      forkExtraArgs.push_back(arg);
    }

    // fork call
    auto forkData = createForkCall(M, types, rawTemplateFunc, forkExtraArgs, sched);
    if (forkData.pushNumThreads)
      insertBefore(forkData.pushNumThreads);
    v-&gt;replaceAll(forkData.fork);
  }
}

</t>
<t tx="ekr.20230509083242.979">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace parallel {

@others
} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.98">def update_path(self, board, color, path):
    """ update win/loss count along path """
    wins = board.score(BLACK) &gt;= board.score(WHITE)
    for node in path:
        if color == BLACK:
            color = WHITE
        else:
            color = BLACK
        if wins == (color == BLACK):
            node.wins += 1
        else:
            node.losses += 1
        if node.parent:
            node.parent.bestchild = node.parent.best_child()

</t>
<t tx="ekr.20230509083242.980">class OpenMPPass : public OperatorPass {
public:
  /// Constructs an OpenMP pass.
  OpenMPPass() : OperatorPass(/*childrenFirst=*/true) {}

  static const std::string KEY;
  std::string getKey() const override { return KEY; }

  void handle(ForFlow *) override;
  void handle(ImperativeForFlow *) override;
};

</t>
<t tx="ekr.20230509083242.981">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "schedule.h"

#include "codon/cir/cir.h"
#include "codon/cir/util/irtools.h"

#include &lt;cctype&gt;
#include &lt;sstream&gt;

namespace codon {
namespace ir {
namespace transform {
namespace parallel {
namespace {
@others
} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.982">int getScheduleCode(const std::string &amp;schedule = "static", bool chunked = false,
  @others
</t>
<t tx="ekr.20230509083242.983">                  bool ordered = false, bool monotonic = false) {
// codes from "enum sched_type" at
// https://github.com/llvm/llvm-project/blob/main/openmp/runtime/src/kmp.h
int modifier = monotonic ? (1 &lt;&lt; 29) : (1 &lt;&lt; 30);
if (schedule == "static") {
  if (chunked) {
    if (ordered)
      return 65;
    else
      return 33;
  } else {
    if (ordered)
      return 66;
    else
      return 34;
  }
} else if (schedule == "dynamic") {
  return (ordered ? 67 : 35) | modifier;
} else if (schedule == "guided") {
  return (ordered ? 68 : 36) | modifier;
} else if (schedule == "runtime") {
  return (ordered ? 69 : 37) | modifier;
} else if (schedule == "auto") {
  return (ordered ? 70 : 38) | modifier;
}
return getScheduleCode(); // default
}

</t>
<t tx="ekr.20230509083242.984">Value *nullIfNeg(Value *v) {
  if (v &amp;&amp; util::isConst&lt;int64_t&gt;(v) &amp;&amp; util::getConst&lt;int64_t&gt;(v) &lt;= 0)
    return nullptr;
  return v;
}
} // namespace

OMPSched::OMPSched(int code, bool dynamic, Value *threads, Value *chunk, bool ordered,
</t>
<t tx="ekr.20230509083242.985">                   int64_t collapse, bool gpu)
    : code(code), dynamic(dynamic), threads(nullIfNeg(threads)),
      chunk(nullIfNeg(chunk)), ordered(ordered), collapse(collapse), gpu(gpu) {
  if (code &lt; 0)
    this-&gt;code = getScheduleCode();
}

</t>
<t tx="ekr.20230509083242.986">OMPSched::OMPSched(const std::string &amp;schedule, Value *threads, Value *chunk,
</t>
<t tx="ekr.20230509083242.987">                   bool ordered, int64_t collapse, bool gpu)
    : OMPSched(getScheduleCode(schedule, nullIfNeg(chunk) != nullptr, ordered),
               (schedule != "static") || ordered, threads, chunk, ordered, collapse,
               gpu) {}

std::vector&lt;Value *&gt; OMPSched::getUsedValues() const {
  std::vector&lt;Value *&gt; ret;
  if (threads)
    ret.push_back(threads);
  if (chunk)
    ret.push_back(chunk);
  return ret;
}

</t>
<t tx="ekr.20230509083242.988">int OMPSched::replaceUsedValue(id_t id, Value *newValue) {
  auto count = 0;
  if (threads &amp;&amp; threads-&gt;getId() == id) {
    threads = newValue;
    ++count;
  }
  if (chunk &amp;&amp; chunk-&gt;getId() == id) {
    chunk = newValue;
    ++count;
  }
  return count;
}

</t>
<t tx="ekr.20230509083242.989">@path C:/Repos/codon/codon/cir/transform/parallel/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/value.h"

namespace codon {
namespace ir {

class Value;

namespace transform {
namespace parallel {

struct OMPSched {
  int code;
  bool dynamic;
  Value *threads;
  Value *chunk;
  bool ordered;
  int64_t collapse;
  bool gpu;

  explicit OMPSched(int code = -1, bool dynamic = false, Value *threads = nullptr,
                    Value *chunk = nullptr, bool ordered = false, int64_t collapse = 0,
                    bool gpu = false);
  explicit OMPSched(const std::string &amp;code, Value *threads = nullptr,
                    Value *chunk = nullptr, bool ordered = false, int64_t collapse = 0,
                    bool gpu = false);
  OMPSched(const OMPSched &amp;s)
      : code(s.code), dynamic(s.dynamic), threads(s.threads), chunk(s.chunk),
        ordered(s.ordered), collapse(s.collapse), gpu(s.gpu) {}

  std::vector&lt;Value *&gt; getUsedValues() const;
  int replaceUsedValue(id_t id, Value *newValue);
};

} // namespace parallel
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.99">def score(self):
    winrate = self.wins / float(self.wins + self.losses)
    parentvisits = self.parent.wins + self.parent.losses
    if not parentvisits:
        return winrate
    nodevisits = self.wins + self.losses
    return winrate + math.sqrt((math.log(parentvisits)) / (5 * nodevisits))

</t>
<t tx="ekr.20230509083242.990"></t>
<t tx="ekr.20230509083242.991">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "dict.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/matching.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {
namespace {
/// get or __getitem__ call metadata
struct GetCall {
  /// the function, nullptr if not a get call
  Func *func = nullptr;
  /// the dictionary, must not be a call
  Value *dict = nullptr;
  /// the key, must not be a call
  Value *key = nullptr;
  /// the default value, may be null
  Const *dflt = nullptr;
};

/// Identify the call and return its metadata.
/// @param call the call
/// @return the metadata
GetCall analyzeGet(CallInstr *call) {
  // extract the function
  auto *func = util::getFunc(call-&gt;getCallee());
  if (!func)
    return {};

  auto unmangled = func-&gt;getUnmangledName();

  // canonical get/__getitem__ calls have at least two arguments
  auto it = call-&gt;begin();
  auto dist = std::distance(it, call-&gt;end());
  if (dist &lt; 2)
    return {};

  // extract the dictionary and keys
  auto *dict = *it++;
  auto *k = *it++;

  // dictionary and key must not be calls
  if (isA&lt;CallInstr&gt;(dict) || isA&lt;CallInstr&gt;(k))
    return {};

  // get calls have a default
  if (unmangled == "get" &amp;&amp; std::distance(it, call-&gt;end()) == 1) {
    auto *dflt = cast&lt;Const&gt;(*it);
    return {func, dict, k, dflt};
  } else if (unmangled == "__getitem__" &amp;&amp; std::distance(it, call-&gt;end()) == 0) {
    return {func, dict, k, nullptr};
  }

  // call is not correct
  return {};
}
} // namespace

const std::string DictArithmeticOptimization::KEY = "core-pythonic-dict-arithmetic-opt";

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.992">void DictArithmeticOptimization::handle(CallInstr *v) {
  auto *M = v-&gt;getModule();

  // get and check the exterior function (should be a __setitem__ with 3 args)
  auto *setFunc = util::getFunc(v-&gt;getCallee());
  if (setFunc &amp;&amp; setFunc-&gt;getUnmangledName() == "__setitem__" &amp;&amp;
      std::distance(v-&gt;begin(), v-&gt;end()) == 3) {
    auto it = v-&gt;begin();

    // extract all the arguments to the function
    // the dictionary and key must not be calls, and the value must
    // be a call
    auto *dictValue = *it++;
    auto *keyValue = *it++;
    if (isA&lt;CallInstr&gt;(dictValue) || isA&lt;CallInstr&gt;(keyValue))
      return;
    auto *opCall = cast&lt;CallInstr&gt;(*it++);

    // the call must take exactly two arguments
    if (!dictValue || !opCall || std::distance(opCall-&gt;begin(), opCall-&gt;end()) != 2)
      return;

    // grab the function, which needs to be an int or float call for now
    auto *opFunc = util::getFunc(opCall-&gt;getCallee());
    auto *getCall = cast&lt;CallInstr&gt;(opCall-&gt;front());
    if (!opFunc || !getCall)
      return;

    auto *intType = M-&gt;getIntType();
    auto *floatType = M-&gt;getFloatType();
    auto *parentType = opFunc-&gt;getParentType();
    if (!parentType || !(parentType-&gt;is(intType) || parentType-&gt;is(floatType)))
      return;

    // check the first argument
    auto getAnalysis = analyzeGet(getCall);
    if (!getAnalysis.func)
      return;

    // second argument can be any non-null value
    auto *secondValue = opCall-&gt;back();

    // verify that we are dealing with the same dictionary and key
    if (util::match(dictValue, getAnalysis.dict, false, true) &amp;&amp;
        util::match(keyValue, getAnalysis.key, false, true)) {
      util::CloneVisitor cv(M);
      Func *replacementFunc;

      // call non-throwing version if we have a default
      if (getAnalysis.dflt) {
        replacementFunc = M-&gt;getOrRealizeMethod(
            dictValue-&gt;getType(), "__dict_do_op__",
            {dictValue-&gt;getType(), keyValue-&gt;getType(), secondValue-&gt;getType(),
             getAnalysis.dflt-&gt;getType(), opFunc-&gt;getType()});
      } else {
        replacementFunc =
            M-&gt;getOrRealizeMethod(dictValue-&gt;getType(), "__dict_do_op_throws__",
                                  {dictValue-&gt;getType(), keyValue-&gt;getType(),
                                   secondValue-&gt;getType(), opFunc-&gt;getType()});
      }

      if (replacementFunc) {
        std::vector&lt;Value *&gt; args = {cv.clone(dictValue), cv.clone(keyValue),
                                     cv.clone(secondValue)};
        if (getAnalysis.dflt)
          args.push_back(cv.clone(getAnalysis.dflt));

        // sanity check to make sure function is inlined
        if (args.size() !=
            std::distance(replacementFunc-&gt;arg_begin(), replacementFunc-&gt;arg_end()))
          args.push_back(M-&gt;N&lt;VarValue&gt;(v, opFunc));

        v-&gt;replaceAll(util::call(replacementFunc, args));
      }
    }
  }
}

</t>
<t tx="ekr.20230509083242.993">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083242.994">/// Pass to optimize calls of form d[x] = func(d[x], any).
/// This will work on any dictionary-like object that implements _do_op and
/// _do_op_throws as well as getters.
class DictArithmeticOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083242.995">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "generator.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/matching.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {
namespace {
@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1">bool isSum(Func *f) {
  return f &amp;&amp; f-&gt;getName().rfind("std.internal.builtin.sum:", 0) == 0;
}

</t>
<t tx="ekr.20230509083243.10">  void handle(YieldInInstr *v) override { valid = false; }
};

Func *genToSum(BodiedFunc *gen, types::Type *startType, types::Type *outType) {
  if (!gen || !gen-&gt;isGenerator())
    return nullptr;

  auto *M = gen-&gt;getModule();
  auto *fn = M-&gt;Nr&lt;BodiedFunc&gt;("__sum_wrapper");
  auto *genType = cast&lt;types::FuncType&gt;(gen-&gt;getType());
  if (!genType)
    return nullptr;

  std::vector&lt;types::Type *&gt; argTypes(genType-&gt;begin(), genType-&gt;end());
  argTypes.push_back(startType);

  std::vector&lt;std::string&gt; names;
  for (auto it = gen-&gt;arg_begin(); it != gen-&gt;arg_end(); ++it) {
    names.push_back((*it)-&gt;getName());
  }
  names.push_back("start");

  auto *fnType = M-&gt;getFuncType(outType, argTypes);
  fn-&gt;realize(fnType, names);

  std::unordered_map&lt;id_t, Var *&gt; argRemap;
  for (auto it1 = gen-&gt;arg_begin(), it2 = fn-&gt;arg_begin();
       it1 != gen-&gt;arg_end() &amp;&amp; it2 != fn-&gt;arg_end(); ++it1, ++it2) {
    argRemap.emplace((*it1)-&gt;getId(), *it2);
  }

  util::CloneVisitor cv(M);
  auto *body = cast&lt;SeriesFlow&gt;(cv.clone(gen-&gt;getBody(), fn, argRemap));
  fn-&gt;setBody(body);

  Value *init = M-&gt;Nr&lt;VarValue&gt;(fn-&gt;arg_back());
  if (startType-&gt;is(M-&gt;getIntType()) &amp;&amp; outType-&gt;is(M-&gt;getFloatType()))
    init = (*M-&gt;getFloatType())(*init);

  if (!init || !init-&gt;getType()-&gt;is(outType))
    return nullptr;

  auto *accumulator = util::makeVar(init, body, fn, /*prepend=*/true)-&gt;getVar();
  GeneratorSumTransformer xgen(accumulator);
  fn-&gt;accept(xgen);
  body-&gt;push_back(M-&gt;Nr&lt;ReturnInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(accumulator)));

  if (!xgen.valid)
    return nullptr;

  return fn;
}

Func *genToAnyAll(BodiedFunc *gen, bool any) {
  if (!gen || !gen-&gt;isGenerator())
    return nullptr;

  auto *M = gen-&gt;getModule();
  auto *fn = M-&gt;Nr&lt;BodiedFunc&gt;(any ? "__any_wrapper" : "__all_wrapper");
  auto *genType = cast&lt;types::FuncType&gt;(gen-&gt;getType());

  std::vector&lt;types::Type *&gt; argTypes(genType-&gt;begin(), genType-&gt;end());
  std::vector&lt;std::string&gt; names;
  for (auto it = gen-&gt;arg_begin(); it != gen-&gt;arg_end(); ++it) {
    names.push_back((*it)-&gt;getName());
  }

  auto *fnType = M-&gt;getFuncType(M-&gt;getBoolType(), argTypes);
  fn-&gt;realize(fnType, names);

  std::unordered_map&lt;id_t, Var *&gt; argRemap;
  for (auto it1 = gen-&gt;arg_begin(), it2 = fn-&gt;arg_begin();
       it1 != gen-&gt;arg_end() &amp;&amp; it2 != fn-&gt;arg_end(); ++it1, ++it2) {
    argRemap.emplace((*it1)-&gt;getId(), *it2);
  }

  util::CloneVisitor cv(M);
  auto *body = cast&lt;SeriesFlow&gt;(cv.clone(gen-&gt;getBody(), fn, argRemap));
  fn-&gt;setBody(body);

  GeneratorAnyAllTransformer xgen(any);
  fn-&gt;accept(xgen);
  body-&gt;push_back(M-&gt;Nr&lt;ReturnInstr&gt;(M-&gt;getBool(!any)));

  if (!xgen.valid)
    return nullptr;

  return fn;
}
} // namespace

</t>
<t tx="ekr.20230509083243.100">void CloneVisitor::visit(const ForFlow *v) {
  auto *loop = Nt(v, nullptr, nullptr, nullptr,
                  std::unique_ptr&lt;transform::parallel::OMPSched&gt;());
  forceRemap(v, loop);
  loop-&gt;setIter(clone(v-&gt;getIter()));
  loop-&gt;setBody(clone(v-&gt;getBody()));
  loop-&gt;setVar(clone(v-&gt;getVar()));
  if (auto *sched = v-&gt;getSchedule()) {
    auto schedCloned = std::make_unique&lt;transform::parallel::OMPSched&gt;(*sched);
    for (auto *val : sched-&gt;getUsedValues()) {
      schedCloned-&gt;replaceUsedValue(val-&gt;getId(), clone(val));
    }
    loop-&gt;setSchedule(std::move(schedCloned));
  }

  result = loop;
}

</t>
<t tx="ekr.20230509083243.1000">  // Create LLVM stub
  auto lt = makeIRType(realized.get());

  // Realize fields
  std::vector&lt;ir::types::Type *&gt; typeArgs;   // needed for IR
  std::vector&lt;std::string&gt; names;            // needed for IR
  std::map&lt;std::string, SrcInfo&gt; memberInfo; // needed for IR
  for (auto &amp;field : ctx-&gt;cache-&gt;classes[realized-&gt;name].fields) {
    auto ftyp = ctx-&gt;instantiate(field.type, realized);
    if (!realize(ftyp))
      E(Error::TYPE_CANNOT_REALIZE_ATTR, getSrcInfo(), field.name,
        ftyp-&gt;prettyString());
    LOG_REALIZE("- member: {} -&gt; {}: {}", field.name, field.type, ftyp);
    realization-&gt;fields.emplace_back(field.name, ftyp);
    names.emplace_back(field.name);
    typeArgs.emplace_back(makeIRType(ftyp-&gt;getClass().get()));
    memberInfo[field.name] = field.type-&gt;getSrcInfo();
  }

  // Set IR attributes
  if (auto *cls = ir::cast&lt;ir::types::RefType&gt;(lt))
    if (!names.empty()) {
      cls-&gt;getContents()-&gt;realize(typeArgs, names);
      cls-&gt;setAttribute(std::make_unique&lt;ir::MemberAttribute&gt;(memberInfo));
      cls-&gt;getContents()-&gt;setAttribute(
          std::make_unique&lt;ir::MemberAttribute&gt;(memberInfo));
    }

  // Fix for partial types
  if (auto p = type-&gt;getPartial()) {
    auto pt = std::make_shared&lt;PartialType&gt;(realized-&gt;getRecord(), p-&gt;func, p-&gt;known);
    ctx-&gt;addToplevel(pt-&gt;realizedName(),
                     std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Type, pt));
    ctx-&gt;cache-&gt;classes[pt-&gt;name].realizations[pt-&gt;realizedName()] =
        ctx-&gt;cache-&gt;classes[realized-&gt;name].realizations[realized-&gt;realizedTypeName()];
  }

  return realized;
}

types::TypePtr TypecheckVisitor::realizeFunc(types::FuncType *type, bool force) {
  auto &amp;realizations = ctx-&gt;cache-&gt;functions[type-&gt;ast-&gt;name].realizations;
  if (auto r = in(realizations, type-&gt;realizedName())) {
    if (!force) {
      return (*r)-&gt;type;
    }
  }

  if (ctx-&gt;getRealizationDepth() &gt; MAX_REALIZATION_DEPTH) {
    E(Error::MAX_REALIZATION, getSrcInfo(), ctx-&gt;cache-&gt;rev(type-&gt;ast-&gt;name));
  }

  LOG_REALIZE("[realize] fn {} -&gt; {} : base {} ; depth = {}", type-&gt;ast-&gt;name,
              type-&gt;realizedName(), ctx-&gt;getRealizationStackName(),
              ctx-&gt;getRealizationDepth());
  getLogger().level++;
  ctx-&gt;addBlock();
  ctx-&gt;typecheckLevel++;

  // Find function parents
  ctx-&gt;realizationBases.push_back(
      {type-&gt;ast-&gt;name, type-&gt;getFunc(), type-&gt;getRetType()});

  // Clone the generic AST that is to be realized
  auto ast = generateSpecialAst(type);
  addFunctionGenerics(type);

  // Internal functions have no AST that can be realized
  bool hasAst = ast-&gt;suite &amp;&amp; !ast-&gt;attributes.has(Attr::Internal);
  // Add function arguments
  for (size_t i = 0, j = 0; hasAst &amp;&amp; i &lt; ast-&gt;args.size(); i++)
    if (ast-&gt;args[i].status == Param::Normal) {
      std::string varName = ast-&gt;args[i].name;
      trimStars(varName);
      ctx-&gt;add(TypecheckItem::Var, varName,
               std::make_shared&lt;LinkType&gt;(type-&gt;getArgTypes()[j++]));
    }

  // Populate realization table in advance to support recursive realizations
  auto key = type-&gt;realizedName(); // note: the key might change later
  ir::Func *oldIR = nullptr;       // Get it if it was already made (force mode)
  if (auto i = in(realizations, key))
    oldIR = (*i)-&gt;ir;
  auto r = realizations[key] = std::make_shared&lt;Cache::Function::FunctionRealization&gt;();
  r-&gt;type = type-&gt;getFunc();
  r-&gt;ir = oldIR;

  // Realizations should always be visible, so add them to the toplevel
  ctx-&gt;addToplevel(
      key, std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Func, type-&gt;getFunc()));

  if (hasAst) {
    auto oldBlockLevel = ctx-&gt;blockLevel;
    ctx-&gt;blockLevel = 0;
    auto ret = inferTypes(ast-&gt;suite);
    ctx-&gt;blockLevel = oldBlockLevel;

    if (!ret) {
      realizations.erase(key);
      if (!startswith(ast-&gt;name, "._lambda")) {
        // Lambda typecheck failures are "ignored" as they are treated as statements,
        // not functions.
        // TODO: generalize this further.
        // LOG("{}", ast-&gt;suite-&gt;toString(2));
        error("cannot typecheck the program");
      }
      ctx-&gt;realizationBases.pop_back();
      ctx-&gt;popBlock();
      ctx-&gt;typecheckLevel--;
      getLogger().level--;
      return nullptr; // inference must be delayed
    }

    // Use NoneType as the return type when the return type is not specified and
    // function has no return statement
    if (!ast-&gt;ret &amp;&amp; type-&gt;getRetType()-&gt;getUnbound())
      unify(type-&gt;getRetType(), ctx-&gt;getType("NoneType"));
  }
  // Realize the return type
  auto ret = realize(type-&gt;getRetType());
  seqassert(ret, "cannot realize return type '{}'", type-&gt;getRetType());

  std::vector&lt;Param&gt; args;
  for (auto &amp;i : ast-&gt;args) {
    std::string varName = i.name;
    trimStars(varName);
    args.emplace_back(Param{varName, nullptr, nullptr, i.status});
  }
  r-&gt;ast = N&lt;FunctionStmt&gt;(ast-&gt;getSrcInfo(), r-&gt;type-&gt;realizedName(), nullptr, args,
                           ast-&gt;suite);
  r-&gt;ast-&gt;attributes = ast-&gt;attributes;

  if (!in(ctx-&gt;cache-&gt;pendingRealizations,
          make_pair(type-&gt;ast-&gt;name, type-&gt;realizedName()))) {
    if (!r-&gt;ir)
      r-&gt;ir = makeIRFunction(r);
    realizations[type-&gt;realizedName()] = r;
  } else {
    realizations[key] = realizations[type-&gt;realizedName()];
  }
  if (force)
    realizations[type-&gt;realizedName()]-&gt;ast = r-&gt;ast;
  ctx-&gt;addToplevel(type-&gt;realizedName(), std::make_shared&lt;TypecheckItem&gt;(
                                             TypecheckItem::Func, type-&gt;getFunc()));
  ctx-&gt;realizationBases.pop_back();
  ctx-&gt;popBlock();
  ctx-&gt;typecheckLevel--;
  getLogger().level--;

  return type-&gt;getFunc();
}

/// Generate ASTs for all __internal__ functions that deal with vtable generation.
/// Intended to be called once the typechecking is done.
/// TODO: add JIT compatibility.
StmtPtr TypecheckVisitor::prepareVTables() {
  auto rep = "__internal__.class_init_vtables:0";
  // def class_init_vtables():
  //   return __internal__.class_make_n_vtables(&lt;NUM_REALIZATIONS&gt; + 1)
  auto &amp;initAllVT = ctx-&gt;cache-&gt;functions[rep];
  auto suite = N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
      N&lt;IdExpr&gt;("__internal__.class_make_n_vtables:0"), N&lt;IdExpr&gt;("__vtable_size__"))));
  initAllVT.ast-&gt;suite = suite;
  auto typ = initAllVT.realizations.begin()-&gt;second-&gt;type;
  LOG_REALIZE("[poly] {} : {}", typ, *suite);
  typ-&gt;ast = initAllVT.ast.get();
  auto fx = realizeFunc(typ.get(), true);

  rep = "__internal__.class_populate_vtables:0";
  // def class_populate_vtables(p):
  //   for real in &lt;REALIZATIONS&gt;:
  //     if real.vtables:
  //        p.__setitem__(real.ID) = Ptr[cobj](real.vtables.size() + 2)
  //        __internal__.class_set_typeinfo(p[real.ID], real.ID)
  //        for f in real.vtables:
  //          p[real.ID].__setitem__(f.ID, Function[&lt;TYPE_F&gt;](f).__raw__())
  auto &amp;initFn = ctx-&gt;cache-&gt;functions[rep];
  suite = N&lt;SuiteStmt&gt;();
  for (auto &amp;[_, cls] : ctx-&gt;cache-&gt;classes) {
    for (auto &amp;[r, real] : cls.realizations) {
      size_t vtSz = 0;
      for (auto &amp;[base, vtable] : real-&gt;vtables) {
        if (!vtable.ir)
          vtSz += vtable.table.size();
      }
      if (!vtSz)
        continue;
      auto var = initFn.ast-&gt;args[0].name;
      // p.__setitem__(real.ID) = Ptr[cobj](real.vtables.size() + 2)
      suite-&gt;stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(var), "__setitem__"), N&lt;IntExpr&gt;(real-&gt;id),
          N&lt;CallExpr&gt;(NT&lt;InstantiateExpr&gt;(NT&lt;IdExpr&gt;("Ptr"),
                                          std::vector&lt;ExprPtr&gt;{NT&lt;IdExpr&gt;("cobj")}),
                      N&lt;IntExpr&gt;(vtSz + 2)))));
      // __internal__.class_set_typeinfo(p[real.ID], real.ID)
      suite-&gt;stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;IdExpr&gt;("__internal__.class_set_typeinfo:0"),
          N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(var), N&lt;IntExpr&gt;(real-&gt;id)), N&lt;IntExpr&gt;(real-&gt;id))));
      vtSz = 0;
      for (auto &amp;[base, vtable] : real-&gt;vtables) {
        if (!vtable.ir) {
          for (auto &amp;[k, v] : vtable.table) {
            auto &amp;[fn, id] = v;
            std::vector&lt;ExprPtr&gt; ids;
            for (auto &amp;t : fn-&gt;getArgTypes())
              ids.push_back(NT&lt;IdExpr&gt;(t-&gt;realizedName()));
            // p[real.ID].__setitem__(f.ID, Function[&lt;TYPE_F&gt;](f).__raw__())
            LOG_REALIZE("[poly] vtable[{}][{}] = {}", real-&gt;id, vtSz + id, fn);
            suite-&gt;stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
                N&lt;DotExpr&gt;(N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(var), N&lt;IntExpr&gt;(real-&gt;id)),
                           "__setitem__"),
                N&lt;IntExpr&gt;(vtSz + id),
                N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(
                    N&lt;CallExpr&gt;(
                        NT&lt;InstantiateExpr&gt;(
                            NT&lt;IdExpr&gt;("Function"),
                            std::vector&lt;ExprPtr&gt;{
                                NT&lt;InstantiateExpr&gt;(
                                    NT&lt;IdExpr&gt;(format("{}{}", TYPE_TUPLE, ids.size())),
                                    ids),
                                NT&lt;IdExpr&gt;(fn-&gt;getRetType()-&gt;realizedName())}),
                        N&lt;IdExpr&gt;(fn-&gt;realizedName())),
                    "__raw__")))));
          }
          vtSz += vtable.table.size();
        }
      }
    }
  }
  initFn.ast-&gt;suite = suite;
  typ = initFn.realizations.begin()-&gt;second-&gt;type;
  LOG_REALIZE("[poly] {} : {}", typ, suite-&gt;toString(2));
  typ-&gt;ast = initFn.ast.get();
  realizeFunc(typ.get(), true);

  rep = "__internal__.class_set_obj_vtable:0";
  // def class_set_obj_vtable(pf):
  //   pf.__vtable__ = __vtables__[pf.__vtable_id___]
  auto &amp;initObjFns = ctx-&gt;cache-&gt;functions[rep];
  auto oldAst = initObjFns.ast;
  for (auto &amp;[_, real] : initObjFns.realizations) {
    auto t = real-&gt;type;
    auto clsTyp = t-&gt;getArgTypes()[0]-&gt;getClass();
    auto varName = initObjFns.ast-&gt;args[0].name;

    const auto &amp;fields = ctx-&gt;cache-&gt;classes[clsTyp-&gt;name].fields;
    auto suite = N&lt;SuiteStmt&gt;();
    for (auto &amp;f : fields)
      if (startswith(f.name, VAR_VTABLE)) {
        suite-&gt;stmts.push_back(N&lt;AssignMemberStmt&gt;(
            N&lt;IdExpr&gt;(varName), f.name,
            N&lt;IndexExpr&gt;(
                N&lt;IdExpr&gt;("__vtables__"),
                N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(clsTyp-&gt;realizedName()), "__vtable_id__"))));
      }

    LOG_REALIZE("[poly] {} : {}", t, *suite);
    initObjFns.ast-&gt;suite = suite;
    t-&gt;ast = initObjFns.ast.get();
    realizeFunc(t.get(), true);
  }
  initObjFns.ast = oldAst;

  auto &amp;initDist = ctx-&gt;cache-&gt;functions["__internal__.class_base_derived_dist:0"];
  // def class_base_derived_dist(B, D):
  //   return Tuple[&lt;types before B is reached in D&gt;].__elemsize__
  oldAst = initDist.ast;
  for (auto &amp;[_, real] : initDist.realizations) {
    auto t = real-&gt;type;
    auto baseTyp = t-&gt;funcGenerics[0].type-&gt;getClass();
    auto derivedTyp = t-&gt;funcGenerics[1].type-&gt;getClass();

    const auto &amp;fields = ctx-&gt;cache-&gt;classes[derivedTyp-&gt;name].fields;
    auto types = std::vector&lt;ExprPtr&gt;{};
    auto found = false;
    for (auto &amp;f : fields) {
      if (f.name == format("{}.{}", VAR_VTABLE, baseTyp-&gt;name)) {
        found = true;
        break;
      } else {
        auto ft = realize(ctx-&gt;instantiate(f.type, derivedTyp));
        types.push_back(NT&lt;IdExpr&gt;(ft-&gt;realizedName()));
      }
    }
    seqassert(found, "cannot find distance between {} and {}", derivedTyp-&gt;name,
              baseTyp-&gt;name);
    StmtPtr suite = N&lt;ReturnStmt&gt;(
        N&lt;DotExpr&gt;(NT&lt;InstantiateExpr&gt;(
                       NT&lt;IdExpr&gt;(format("{}{}", TYPE_TUPLE, types.size())), types),
                   "__elemsize__"));
    LOG_REALIZE("[poly] {} : {}", t, *suite);
    initDist.ast-&gt;suite = suite;
    t-&gt;ast = initDist.ast.get();
    realizeFunc(t.get(), true);
  }
  initDist.ast = oldAst;

  return nullptr;
}

/// Generate thunks in all derived classes for a given virtual function (must be fully
/// realizable) and the corresponding base class.
/// @return unique thunk ID.
size_t TypecheckVisitor::getRealizationID(types::ClassType *cp, types::FuncType *fp) {
  seqassert(cp-&gt;canRealize() &amp;&amp; fp-&gt;canRealize() &amp;&amp; fp-&gt;getRetType()-&gt;canRealize(),
            "{} not realized", fp-&gt;debugString(1));

</t>
<t tx="ekr.20230509083243.1001">  // TODO: ugly, ugly; surely needs refactoring

  // Function signature for storing thunks
  auto sig = [](types::FuncType *fp) {
    std::vector&lt;std::string&gt; gs;
    for (auto &amp;a : fp-&gt;getArgTypes())
      gs.push_back(a-&gt;realizedName());
    gs.push_back("|");
    for (auto &amp;a : fp-&gt;funcGenerics)
      if (!a.name.empty())
        gs.push_back(a.type-&gt;realizedName());
    return join(gs, ",");
  };

</t>
<t tx="ekr.20230509083243.1002">  // Set up the base class information
  auto baseCls = cp-&gt;name;
  auto fnName = ctx-&gt;cache-&gt;rev(fp-&gt;ast-&gt;name);
  auto key = make_pair(fnName, sig(fp));
  auto &amp;vt = ctx-&gt;cache-&gt;classes[baseCls]
                 .realizations[cp-&gt;realizedName()]
                 -&gt;vtables[cp-&gt;realizedName()];

  // Add or extract thunk ID
  size_t vid;
  if (auto i = in(vt.table, key)) {
    vid = i-&gt;second;
  } else {
    vid = vt.table.size() + 1;
    vt.table[key] = {fp-&gt;getFunc(), vid};
  }

  // Iterate through all derived classes and instantiate the corresponding thunk
  for (auto &amp;[clsName, cls] : ctx-&gt;cache-&gt;classes) {
    bool inMro = false;
    for (auto &amp;m : cls.mro)
      if (m-&gt;type &amp;&amp; m-&gt;type-&gt;getClass() &amp;&amp; m-&gt;type-&gt;getClass()-&gt;name == baseCls) {
        inMro = true;
        break;
      }
    if (clsName != baseCls &amp;&amp; inMro) {
      for (auto &amp;[_, real] : cls.realizations) {
        auto &amp;vtable = real-&gt;vtables[baseCls];

</t>
<t tx="ekr.20230509083243.1003">        auto ct =
            ctx-&gt;instantiate(ctx-&gt;forceFind(clsName)-&gt;type, cp-&gt;getClass())-&gt;getClass();
        std::vector&lt;types::TypePtr&gt; args = fp-&gt;getArgTypes();
        args[0] = ct;
        auto m = findBestMethod(ct, fnName, args);
        if (!m) {
          // Print a nice error message
          std::vector&lt;std::string&gt; a;
          for (auto &amp;t : args)
            a.emplace_back(fmt::format("{}", t-&gt;prettyString()));
          std::string argsNice = fmt::format("({})", fmt::join(a, ", "));
          E(Error::DOT_NO_ATTR_ARGS, getSrcInfo(), ct-&gt;prettyString(), fnName,
            argsNice);
        }

</t>
<t tx="ekr.20230509083243.1004">        std::vector&lt;std::string&gt; ns;
        for (auto &amp;a : args)
          ns.push_back(a-&gt;realizedName());

        // Thunk name: _thunk.&lt;BASE&gt;.&lt;FN&gt;.&lt;ARGS&gt;
        auto thunkName =
            format("_thunk.{}.{}.{}", baseCls, m-&gt;ast-&gt;name, fmt::join(ns, "."));
        if (in(ctx-&gt;cache-&gt;functions, thunkName))
          continue;

        // Thunk contents:
        // def _thunk.&lt;BASE&gt;.&lt;FN&gt;.&lt;ARGS&gt;(self, &lt;ARGS...&gt;):
        //   return &lt;FN&gt;(
        //     __internal__.to_class_ptr(
        //       self.__raw__() - __internal__.class_base_derived_dist(&lt;BASE&gt;,
        //       &lt;DERIVED&gt;), &lt;DERIVED&gt;
        //     ), &lt;ARGS...&gt;)
        std::vector&lt;Param&gt; fnArgs;
        fnArgs.push_back(
            Param{fp-&gt;ast-&gt;args[0].name, N&lt;IdExpr&gt;(cp-&gt;realizedName()), nullptr});
        for (size_t i = 1; i &lt; args.size(); i++)
          fnArgs.push_back(Param{fp-&gt;ast-&gt;args[i].name,
                                 N&lt;IdExpr&gt;(args[i]-&gt;realizedName()), nullptr});
        std::vector&lt;ExprPtr&gt; callArgs;
        callArgs.emplace_back(N&lt;CallExpr&gt;(
            N&lt;IdExpr&gt;("__internal__.to_class_ptr:0"),
            N&lt;BinaryExpr&gt;(
                N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(fp-&gt;ast-&gt;args[0].name), "__raw__")),
                "-",
                N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.class_base_derived_dist:0"),
                            N&lt;IdExpr&gt;(cp-&gt;realizedName()),
                            N&lt;IdExpr&gt;(real-&gt;type-&gt;realizedName()))),
            NT&lt;IdExpr&gt;(real-&gt;type-&gt;realizedName())));
        for (size_t i = 1; i &lt; args.size(); i++)
          callArgs.emplace_back(N&lt;IdExpr&gt;(fp-&gt;ast-&gt;args[i].name));
        auto thunkAst = N&lt;FunctionStmt&gt;(
            thunkName, nullptr, fnArgs,
            N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(m-&gt;ast-&gt;name), callArgs))),
            Attr({"std.internal.attributes.inline", Attr::ForceRealize}));
        auto &amp;thunkFn = ctx-&gt;cache-&gt;functions[thunkAst-&gt;name];
        thunkFn.ast = std::static_pointer_cast&lt;FunctionStmt&gt;(thunkAst-&gt;clone());

        transform(thunkAst);
        prependStmts-&gt;push_back(thunkAst);
        auto ti = ctx-&gt;instantiate(thunkFn.type)-&gt;getFunc();
        auto tm = realizeFunc(ti.get(), true);
        seqassert(tm, "bad thunk {}", thunkFn.type);
        vtable.table[key] = {tm-&gt;getFunc(), vid};
      }
    }
  }
  return vid;
}

/// Make IR node for a realized type.
ir::types::Type *TypecheckVisitor::makeIRType(types::ClassType *t) {
  // Realize if not, and return cached value if it exists
  auto realizedName = t-&gt;realizedTypeName();
  if (!in(ctx-&gt;cache-&gt;classes[t-&gt;name].realizations, realizedName))
    realize(t-&gt;getClass());
  if (auto l = ctx-&gt;cache-&gt;classes[t-&gt;name].realizations[realizedName]-&gt;ir)
    return l;

</t>
<t tx="ekr.20230509083243.1005">  auto forceFindIRType = [&amp;](const TypePtr &amp;tt) {
    auto t = tt-&gt;getClass();
    seqassert(t &amp;&amp; in(ctx-&gt;cache-&gt;classes[t-&gt;name].realizations, t-&gt;realizedTypeName()),
              "{} not realized", tt);
    auto l = ctx-&gt;cache-&gt;classes[t-&gt;name].realizations[t-&gt;realizedTypeName()]-&gt;ir;
    seqassert(l, "no LLVM type for {}", t);
    return l;
  };

</t>
<t tx="ekr.20230509083243.1006">  // Prepare generics and statics
  std::vector&lt;ir::types::Type *&gt; types;
  std::vector&lt;StaticValue *&gt; statics;
  for (auto &amp;m : t-&gt;generics) {
    if (auto s = m.type-&gt;getStatic()) {
      seqassert(s-&gt;expr-&gt;staticValue.evaluated, "static not realized");
      statics.push_back(&amp;(s-&gt;expr-&gt;staticValue));
    } else {
      types.push_back(forceFindIRType(m.type));
    }
  }

  // Get the IR type
  auto *module = ctx-&gt;cache-&gt;module;
  ir::types::Type *handle = nullptr;

  if (t-&gt;name == "bool") {
    handle = module-&gt;getBoolType();
  } else if (t-&gt;name == "byte") {
    handle = module-&gt;getByteType();
  } else if (t-&gt;name == "int") {
    handle = module-&gt;getIntType();
  } else if (t-&gt;name == "float") {
    handle = module-&gt;getFloatType();
  } else if (t-&gt;name == "float32") {
    handle = module-&gt;getFloat32Type();
  } else if (t-&gt;name == "str") {
    handle = module-&gt;getStringType();
  } else if (t-&gt;name == "Int" || t-&gt;name == "UInt") {
    handle = module-&gt;Nr&lt;ir::types::IntNType&gt;(statics[0]-&gt;getInt(), t-&gt;name == "Int");
  } else if (t-&gt;name == "Ptr") {
    seqassert(types.size() == 1 &amp;&amp; statics.empty(), "bad generics/statics");
    handle = module-&gt;unsafeGetPointerType(types[0]);
  } else if (t-&gt;name == "Generator") {
    seqassert(types.size() == 1 &amp;&amp; statics.empty(), "bad generics/statics");
    handle = module-&gt;unsafeGetGeneratorType(types[0]);
  } else if (t-&gt;name == TYPE_OPTIONAL) {
    seqassert(types.size() == 1 &amp;&amp; statics.empty(), "bad generics/statics");
    handle = module-&gt;unsafeGetOptionalType(types[0]);
  } else if (t-&gt;name == "NoneType") {
    seqassert(types.empty() &amp;&amp; statics.empty(), "bad generics/statics");
    auto record =
        ir::cast&lt;ir::types::RecordType&gt;(module-&gt;unsafeGetMemberedType(realizedName));
    record-&gt;realize({}, {});
    handle = record;
  } else if (t-&gt;name == "Union") {
    seqassert(!types.empty() &amp;&amp; statics.empty(), "bad union");
    auto unionTypes = t-&gt;getUnion()-&gt;getRealizationTypes();
    std::vector&lt;ir::types::Type *&gt; unionVec;
    unionVec.reserve(unionTypes.size());
    for (auto &amp;u : unionTypes)
      unionVec.emplace_back(forceFindIRType(u));
    handle = module-&gt;unsafeGetUnionType(unionVec);
  } else if (t-&gt;name == "Function") {
    types.clear();
    for (auto &amp;m : t-&gt;generics[0].type-&gt;getRecord()-&gt;args)
      types.push_back(forceFindIRType(m));
    auto ret = forceFindIRType(t-&gt;generics[1].type);
    handle = module-&gt;unsafeGetFuncType(realizedName, ret, types);
  } else if (t-&gt;name == "std.experimental.simd.Vec") {
    seqassert(types.size() == 1 &amp;&amp; statics.size() == 1, "bad generics/statics");
    handle = module-&gt;unsafeGetVectorType(statics[0]-&gt;getInt(), types[0]);
  } else if (auto tr = t-&gt;getRecord()) {
    std::vector&lt;ir::types::Type *&gt; typeArgs;
    std::vector&lt;std::string&gt; names;
    std::map&lt;std::string, SrcInfo&gt; memberInfo;
    for (int ai = 0; ai &lt; tr-&gt;args.size(); ai++) {
      names.emplace_back(ctx-&gt;cache-&gt;classes[t-&gt;name].fields[ai].name);
      typeArgs.emplace_back(forceFindIRType(tr-&gt;args[ai]));
      memberInfo[ctx-&gt;cache-&gt;classes[t-&gt;name].fields[ai].name] =
          ctx-&gt;cache-&gt;classes[t-&gt;name].fields[ai].type-&gt;getSrcInfo();
    }
    auto record =
        ir::cast&lt;ir::types::RecordType&gt;(module-&gt;unsafeGetMemberedType(realizedName));
    record-&gt;realize(typeArgs, names);
    handle = record;
    handle-&gt;setAttribute(std::make_unique&lt;ir::MemberAttribute&gt;(std::move(memberInfo)));
  } else {
    // Type arguments will be populated afterwards to avoid infinite loop with recursive
    // reference types (e.g., `class X: x: Optional[X]`)
    handle = module-&gt;unsafeGetMemberedType(realizedName, true);
  }
  handle-&gt;setSrcInfo(t-&gt;getSrcInfo());
  handle-&gt;setAstType(
      std::const_pointer_cast&lt;codon::ast::types::Type&gt;(t-&gt;shared_from_this()));
  return ctx-&gt;cache-&gt;classes[t-&gt;name].realizations[realizedName]-&gt;ir = handle;
}

/// Make IR node for a realized function.
ir::Func *TypecheckVisitor::makeIRFunction(
</t>
<t tx="ekr.20230509083243.1007">    const std::shared_ptr&lt;Cache::Function::FunctionRealization&gt; &amp;r) {
  ir::Func *fn = nullptr;
  // Create and store a function IR node and a realized AST for IR passes
  if (r-&gt;ast-&gt;attributes.has(Attr::Internal)) {
    // e.g., __new__, Ptr.__new__, etc.
    fn = ctx-&gt;cache-&gt;module-&gt;Nr&lt;ir::InternalFunc&gt;(r-&gt;type-&gt;ast-&gt;name);
  } else if (r-&gt;ast-&gt;attributes.has(Attr::LLVM)) {
    fn = ctx-&gt;cache-&gt;module-&gt;Nr&lt;ir::LLVMFunc&gt;(r-&gt;type-&gt;realizedName());
  } else if (r-&gt;ast-&gt;attributes.has(Attr::C)) {
    fn = ctx-&gt;cache-&gt;module-&gt;Nr&lt;ir::ExternalFunc&gt;(r-&gt;type-&gt;realizedName());
  } else {
    fn = ctx-&gt;cache-&gt;module-&gt;Nr&lt;ir::BodiedFunc&gt;(r-&gt;type-&gt;realizedName());
  }
  fn-&gt;setUnmangledName(ctx-&gt;cache-&gt;reverseIdentifierLookup[r-&gt;type-&gt;ast-&gt;name]);
  auto parent = r-&gt;type-&gt;funcParent;
  if (!r-&gt;ast-&gt;attributes.parentClass.empty() &amp;&amp;
      !r-&gt;ast-&gt;attributes.has(Attr::Method)) {
    // Hack for non-generic methods
    parent = ctx-&gt;find(r-&gt;ast-&gt;attributes.parentClass)-&gt;type;
  }
  if (parent &amp;&amp; parent-&gt;canRealize()) {
    realize(parent);
    fn-&gt;setParentType(makeIRType(parent-&gt;getClass().get()));
  }
  fn-&gt;setGlobal();
  // Mark this realization as pending (i.e., realized but not translated)
  ctx-&gt;cache-&gt;pendingRealizations.insert({r-&gt;type-&gt;ast-&gt;name, r-&gt;type-&gt;realizedName()});

  seqassert(!r-&gt;type || r-&gt;ast-&gt;args.size() == r-&gt;type-&gt;getArgTypes().size() +
                                                   r-&gt;type-&gt;funcGenerics.size(),
            "type/AST argument mismatch");

  // Populate the IR node
  std::vector&lt;std::string&gt; names;
  std::vector&lt;codon::ir::types::Type *&gt; types;
  for (size_t i = 0, j = 0; i &lt; r-&gt;ast-&gt;args.size(); i++) {
    if (r-&gt;ast-&gt;args[i].status == Param::Normal) {
      if (!r-&gt;type-&gt;getArgTypes()[j]-&gt;getFunc()) {
        types.push_back(makeIRType(r-&gt;type-&gt;getArgTypes()[j]-&gt;getClass().get()));
        names.push_back(ctx-&gt;cache-&gt;reverseIdentifierLookup[r-&gt;ast-&gt;args[i].name]);
      }
      j++;
    }
  }
  if (r-&gt;ast-&gt;hasAttr(Attr::CVarArg)) {
    types.pop_back();
    names.pop_back();
  }
  auto irType = ctx-&gt;cache-&gt;module-&gt;unsafeGetFuncType(
      r-&gt;type-&gt;realizedName(), makeIRType(r-&gt;type-&gt;getRetType()-&gt;getClass().get()),
      types, r-&gt;ast-&gt;hasAttr(Attr::CVarArg));
  irType-&gt;setAstType(r-&gt;type-&gt;getFunc());
  fn-&gt;realize(irType, names);
  return fn;
}

</t>
<t tx="ekr.20230509083243.1008">/// Generate ASTs for dynamically generated functions.
std::shared_ptr&lt;FunctionStmt&gt;
TypecheckVisitor::generateSpecialAst(types::FuncType *type) {
  @others
             type-&gt;getArgTypes()[0]-&gt;getHeterogenousTuple()) {
    // Special case: do not realize auto-generated heterogenous __getitem__
    E(Error::EXPECTED_TYPE, getSrcInfo(), "iterable");
  } else if (startswith(ast-&gt;name, "Function.__call_internal__")) {
    // Special case: Function.__call_internal__
    /// TODO: move to IR one day
    std::vector&lt;StmtPtr&gt; items;
    items.push_back(nullptr);
    std::vector&lt;std::string&gt; ll;
    std::vector&lt;std::string&gt; lla;
    auto &amp;as = type-&gt;getArgTypes()[1]-&gt;getRecord()-&gt;args;
    auto ag = ast-&gt;args[1].name;
    trimStars(ag);
    for (int i = 0; i &lt; as.size(); i++) {
      ll.push_back(format("%{} = extractvalue {{}} %args, {}", i, i));
      items.push_back(N&lt;ExprStmt&gt;(N&lt;IdExpr&gt;(ag)));
    }
    items.push_back(N&lt;ExprStmt&gt;(N&lt;IdExpr&gt;("TR")));
    for (int i = 0; i &lt; as.size(); i++) {
      items.push_back(N&lt;ExprStmt&gt;(N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(ag), N&lt;IntExpr&gt;(i))));
      lla.push_back(format("{{}} %{}", i));
    }
    items.push_back(N&lt;ExprStmt&gt;(N&lt;IdExpr&gt;("TR")));
    ll.push_back(format("%{} = call {{}} %self({})", as.size(), combine2(lla)));
    ll.push_back(format("ret {{}} %{}", as.size()));
    items[0] = N&lt;ExprStmt&gt;(N&lt;StringExpr&gt;(combine2(ll, "\n")));
    ast-&gt;suite = N&lt;SuiteStmt&gt;(items);
  } else if (startswith(ast-&gt;name, "Union.__new__:0")) {
    auto unionType = type-&gt;funcParent-&gt;getUnion();
    seqassert(unionType, "expected union, got {}", type-&gt;funcParent);

    StmtPtr suite = N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
        N&lt;IdExpr&gt;("__internal__.new_union:0"), N&lt;IdExpr&gt;(type-&gt;ast-&gt;args[0].name),
        N&lt;IdExpr&gt;(unionType-&gt;realizedTypeName())));
    ast-&gt;suite = suite;
  } else if (startswith(ast-&gt;name, "__internal__.new_union:0")) {
    // Special case: __internal__.new_union
    // def __internal__.new_union(value, U[T0, ..., TN]):
    //   if isinstance(value, T0):
    //     return __internal__.union_make(0, value, U[T0, ..., TN])
    //   if isinstance(value, Union[T0]):
    //     return __internal__.union_make(
    //       0, __internal__.get_union(value, T0), U[T0, ..., TN])
    //   ... &lt;for all T0...TN&gt; ...
    //   compile_error("invalid union constructor")
    auto unionType = type-&gt;funcGenerics[0].type-&gt;getUnion();
    auto unionTypes = unionType-&gt;getRealizationTypes();

    auto objVar = ast-&gt;args[0].name;
    auto suite = N&lt;SuiteStmt&gt;();
    int tag = 0;
    for (auto &amp;t : unionTypes) {
      suite-&gt;stmts.push_back(N&lt;IfStmt&gt;(
          N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("isinstance"), N&lt;IdExpr&gt;(objVar),
                      NT&lt;IdExpr&gt;(t-&gt;realizedName())),
          N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_make:0"),
                                    N&lt;IntExpr&gt;(tag), N&lt;IdExpr&gt;(objVar),
                                    N&lt;IdExpr&gt;(unionType-&gt;realizedTypeName())))));
      // Check for Union[T]
      suite-&gt;stmts.push_back(N&lt;IfStmt&gt;(
          N&lt;CallExpr&gt;(
              N&lt;IdExpr&gt;("isinstance"), N&lt;IdExpr&gt;(objVar),
              NT&lt;InstantiateExpr&gt;(NT&lt;IdExpr&gt;("Union"),
                                  std::vector&lt;ExprPtr&gt;{NT&lt;IdExpr&gt;(t-&gt;realizedName())})),
          N&lt;ReturnStmt&gt;(
              N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_make:0"), N&lt;IntExpr&gt;(tag),
                          N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.get_union:0"),
                                      N&lt;IdExpr&gt;(objVar), NT&lt;IdExpr&gt;(t-&gt;realizedName())),
                          N&lt;IdExpr&gt;(unionType-&gt;realizedTypeName())))));
      tag++;
    }
    suite-&gt;stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
        N&lt;IdExpr&gt;("compile_error"), N&lt;StringExpr&gt;("invalid union constructor"))));
    ast-&gt;suite = suite;
  } else if (startswith(ast-&gt;name, "__internal__.get_union:0")) {
    // Special case: __internal__.get_union
    // def __internal__.new_union(union: Union[T0,...,TN], T):
    //   if __internal__.union_get_tag(union) == 0:
    //     return __internal__.union_get_data(union, T0)
    //   ... &lt;for all T0...TN&gt;
    //   raise TypeError("getter")
    auto unionType = type-&gt;getArgTypes()[0]-&gt;getUnion();
    auto unionTypes = unionType-&gt;getRealizationTypes();

    auto targetType = type-&gt;funcGenerics[0].type;
    auto selfVar = ast-&gt;args[0].name;
    auto suite = N&lt;SuiteStmt&gt;();
    int tag = 0;
    for (auto t : unionTypes) {
      if (t-&gt;realizedName() == targetType-&gt;realizedName()) {
        suite-&gt;stmts.push_back(N&lt;IfStmt&gt;(
            N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_tag:0"),
                                      N&lt;IdExpr&gt;(selfVar)),
                          "==", N&lt;IntExpr&gt;(tag)),
            N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_data:0"),
                                      N&lt;IdExpr&gt;(selfVar),
                                      NT&lt;IdExpr&gt;(t-&gt;realizedName())))));
      }
      tag++;
    }
    suite-&gt;stmts.push_back(
        N&lt;ThrowStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("std.internal.types.error.TypeError"),
                                 N&lt;StringExpr&gt;("invalid union getter"))));
    ast-&gt;suite = suite;
  } else if (startswith(ast-&gt;name, "__internal__._get_union_method:0")) {
    // def __internal__._get_union_method(union: Union[T0,...,TN], method, *args, **kw):
    //   if __internal__.union_get_tag(union) == 0:
    //     return __internal__.union_get_data(union, T0).method(*args, **kw)
    //   ... &lt;for all T0...TN&gt;
    //   raise TypeError("call")
    auto szt = type-&gt;funcGenerics[0].type-&gt;getStatic();
    auto fnName = szt-&gt;evaluate().getString();
    auto unionType = type-&gt;getArgTypes()[0]-&gt;getUnion();
    auto unionTypes = unionType-&gt;getRealizationTypes();

    auto selfVar = ast-&gt;args[0].name;
    auto suite = N&lt;SuiteStmt&gt;();
    int tag = 0;
    for (auto &amp;t : unionTypes) {
      auto callee =
          N&lt;DotExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_data:0"),
                                 N&lt;IdExpr&gt;(selfVar), NT&lt;IdExpr&gt;(t-&gt;realizedName())),
                     fnName);
      auto args = N&lt;StarExpr&gt;(N&lt;IdExpr&gt;(ast-&gt;args[2].name.substr(1)));
      auto kwargs = N&lt;KeywordStarExpr&gt;(N&lt;IdExpr&gt;(ast-&gt;args[3].name.substr(2)));
      std::vector&lt;CallExpr::Arg&gt; callArgs;
      ExprPtr check =
          N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("hasattr"), NT&lt;IdExpr&gt;(t-&gt;realizedName()),
                      N&lt;StringExpr&gt;(fnName), args-&gt;clone(), kwargs-&gt;clone());
      suite-&gt;stmts.push_back(N&lt;IfStmt&gt;(
          N&lt;BinaryExpr&gt;(
              check, "&amp;&amp;",
              N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_tag:0"),
                                        N&lt;IdExpr&gt;(selfVar)),
                            "==", N&lt;IntExpr&gt;(tag))),
          N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(callee, args, kwargs)))));
      tag++;
    }
    suite-&gt;stmts.push_back(
        N&lt;ThrowStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("std.internal.types.error.TypeError"),
                                 N&lt;StringExpr&gt;("invalid union call"))));
    // suite-&gt;stmts.push_back(N&lt;ReturnStmt&gt;(N&lt;NoneExpr&gt;()));
    unify(type-&gt;getRetType(), ctx-&gt;instantiate(ctx-&gt;getType("Union")));
    ast-&gt;suite = suite;
  } else if (startswith(ast-&gt;name, "__internal__.get_union_first:0")) {
    // def __internal__.get_union_first(union: Union[T0]):
    //   return __internal__.union_get_data(union, T0)
    auto unionType = type-&gt;getArgTypes()[0]-&gt;getUnion();
    auto unionTypes = unionType-&gt;getRealizationTypes();

    auto selfVar = ast-&gt;args[0].name;
    auto suite = N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_data:0"), N&lt;IdExpr&gt;(selfVar),
                    NT&lt;IdExpr&gt;(unionTypes[0]-&gt;realizedName()))));
    ast-&gt;suite = suite;
  }
  return ast;
}

</t>
<t tx="ekr.20230509083243.1009">// Clone the generic AST that is to be realized
auto ast = std::dynamic_pointer_cast&lt;FunctionStmt&gt;(
    clone(ctx-&gt;cache-&gt;functions[type-&gt;ast-&gt;name].ast));

if (ast-&gt;hasAttr("autogenerated") &amp;&amp; endswith(ast-&gt;name, ".__iter__:0") &amp;&amp;
    type-&gt;getArgTypes()[0]-&gt;getHeterogenousTuple()) {
  // Special case: do not realize auto-generated heterogenous __iter__
  E(Error::EXPECTED_TYPE, getSrcInfo(), "iterable");
} else if (ast-&gt;hasAttr("autogenerated") &amp;&amp; endswith(ast-&gt;name, ".__getitem__:0") &amp;&amp;
</t>
<t tx="ekr.20230509083243.101">void CloneVisitor::visit(const ImperativeForFlow *v) {
  auto *loop = Nt(v, nullptr, v-&gt;getStep(), nullptr, nullptr, nullptr,
                  std::unique_ptr&lt;transform::parallel::OMPSched&gt;());
  forceRemap(v, loop);
  loop-&gt;setStart(clone(v-&gt;getStart()));
  loop-&gt;setBody(clone(v-&gt;getBody()));
  loop-&gt;setVar(clone(v-&gt;getVar()));
  loop-&gt;setEnd(clone(v-&gt;getEnd()));
  if (auto *sched = v-&gt;getSchedule()) {
    auto schedCloned = std::make_unique&lt;transform::parallel::OMPSched&gt;(*sched);
    for (auto *val : sched-&gt;getUsedValues()) {
      schedCloned-&gt;replaceUsedValue(val-&gt;getId(), clone(val));
    }
    loop-&gt;setSchedule(std::move(schedCloned));
  }
  result = loop;
}

</t>
<t tx="ekr.20230509083243.1010">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;
namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1011">/// Nothing to typecheck; just call setDone
void TypecheckVisitor::visit(BreakStmt *stmt) {
  stmt-&gt;setDone();
  if (!ctx-&gt;staticLoops.back().empty()) {
    auto a = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(ctx-&gt;staticLoops.back()), N&lt;BoolExpr&gt;(false));
    a-&gt;setUpdate();
    resultStmt = transform(N&lt;SuiteStmt&gt;(a, stmt-&gt;clone()));
  }
}

</t>
<t tx="ekr.20230509083243.1012">/// Nothing to typecheck; just call setDone
void TypecheckVisitor::visit(ContinueStmt *stmt) {
  stmt-&gt;setDone();
  if (!ctx-&gt;staticLoops.back().empty()) {
    resultStmt = N&lt;BreakStmt&gt;();
    resultStmt-&gt;setDone();
  }
}

</t>
<t tx="ekr.20230509083243.1013">/// Typecheck while statements.
void TypecheckVisitor::visit(WhileStmt *stmt) {
  ctx-&gt;staticLoops.push_back(stmt-&gt;gotoVar.empty() ? "" : stmt-&gt;gotoVar);
  transform(stmt-&gt;cond);
  ctx-&gt;blockLevel++;
  transform(stmt-&gt;suite);
  ctx-&gt;blockLevel--;
  ctx-&gt;staticLoops.pop_back();

  if (stmt-&gt;cond-&gt;isDone() &amp;&amp; stmt-&gt;suite-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1014">/// Typecheck for statements. Wrap the iterator expression with `__iter__` if needed.
/// See @c transformHeterogenousTupleFor for iterating heterogenous tuples.
void TypecheckVisitor::visit(ForStmt *stmt) {
  transform(stmt-&gt;decorator);
  transform(stmt-&gt;iter);

  // Extract the iterator type of the for
  auto iterType = stmt-&gt;iter-&gt;getType()-&gt;getClass();
  if (!iterType)
    return; // wait until the iterator is known

  if ((resultStmt = transformStaticForLoop(stmt)))
    return;

  @others
  // Case: iterating a non-generator. Wrap with `__iter__`
  if (iterType-&gt;name != "Generator" &amp;&amp; !stmt-&gt;wrapped) {
    stmt-&gt;iter = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(stmt-&gt;iter, "__iter__")));
    iterType = stmt-&gt;iter-&gt;getType()-&gt;getClass();
    stmt-&gt;wrapped = true;
  }

  auto var = stmt-&gt;var-&gt;getId();
  seqassert(var, "corrupt for variable: {}", stmt-&gt;var);

  // Handle dominated for bindings
  auto changed = in(ctx-&gt;cache-&gt;replacements, var-&gt;value);
  while (auto s = in(ctx-&gt;cache-&gt;replacements, var-&gt;value))
    var-&gt;value = s-&gt;first, changed = s;
  if (changed &amp;&amp; changed-&gt;second) {
    auto u =
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(format("{}.__used__", var-&gt;value)), N&lt;BoolExpr&gt;(true));
    u-&gt;setUpdate();
    stmt-&gt;suite = N&lt;SuiteStmt&gt;(u, stmt-&gt;suite);
  }
  if (changed)
    var-&gt;setAttr(ExprAttr::Dominated);

  // Unify iterator variable and the iterator type
  auto val = ctx-&gt;find(var-&gt;value);
  if (!changed)
    val = ctx-&gt;add(TypecheckItem::Var, var-&gt;value,
                   ctx-&gt;getUnbound(stmt-&gt;var-&gt;getSrcInfo()));
  if (iterType &amp;&amp; iterType-&gt;name != "Generator")
    E(Error::EXPECTED_GENERATOR, stmt-&gt;iter);
  unify(stmt-&gt;var-&gt;type,
        iterType ? unify(val-&gt;type, iterType-&gt;generics[0].type) : val-&gt;type);

  ctx-&gt;staticLoops.push_back("");
  ctx-&gt;blockLevel++;
  transform(stmt-&gt;suite);
  ctx-&gt;blockLevel--;
  ctx-&gt;staticLoops.pop_back();

  if (stmt-&gt;iter-&gt;isDone() &amp;&amp; stmt-&gt;suite-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1015">bool maybeHeterogenous = startswith(iterType-&gt;name, TYPE_TUPLE) ||
                         startswith(iterType-&gt;name, TYPE_KWTUPLE);
if (maybeHeterogenous &amp;&amp; !iterType-&gt;canRealize()) {
  return; // wait until the tuple is fully realizable
} else if (maybeHeterogenous &amp;&amp; iterType-&gt;getHeterogenousTuple()) {
  // Case: iterating a heterogenous tuple
  resultStmt = transformHeterogenousTupleFor(stmt);
  return;
}

</t>
<t tx="ekr.20230509083243.1016">/// Handle heterogeneous tuple iteration.
/// @example
///   `for i in tuple_expr: &lt;suite&gt;` -&gt;
///   ```tuple = tuple_expr
///      for cnt in range(&lt;tuple length&gt;):
///        if cnt == 0:
///          i = t[0]; &lt;suite&gt;
///        if cnt == 1:
///          i = t[1]; &lt;suite&gt; ...```
/// A separate suite is generated  for each tuple member.
StmtPtr TypecheckVisitor::transformHeterogenousTupleFor(ForStmt *stmt) {
  auto block = N&lt;SuiteStmt&gt;();
  // `tuple = &lt;tuple expression&gt;`
  auto tupleVar = ctx-&gt;cache-&gt;getTemporaryVar("tuple");
  block-&gt;stmts.push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(tupleVar), stmt-&gt;iter));

  auto tupleArgs = stmt-&gt;iter-&gt;getType()-&gt;getClass()-&gt;getHeterogenousTuple()-&gt;args;
  auto cntVar = ctx-&gt;cache-&gt;getTemporaryVar("idx");
  std::vector&lt;StmtPtr&gt; forBlock;
  for (size_t ai = 0; ai &lt; tupleArgs.size(); ai++) {
    // `if cnt == ai: (var = tuple[ai]; &lt;suite&gt;)`
    forBlock.push_back(N&lt;IfStmt&gt;(
        N&lt;BinaryExpr&gt;(N&lt;IdExpr&gt;(cntVar), "==", N&lt;IntExpr&gt;(ai)),
        N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(clone(stmt-&gt;var),
                                   N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(tupleVar), N&lt;IntExpr&gt;(ai))),
                     clone(stmt-&gt;suite))));
  }
  // `for cnt in range(tuple_size): ...`
  block-&gt;stmts.push_back(
      N&lt;ForStmt&gt;(N&lt;IdExpr&gt;(cntVar),
                 N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("std.internal.types.range.range"),
                             N&lt;IntExpr&gt;(tupleArgs.size())),
                 N&lt;SuiteStmt&gt;(forBlock)));

  ctx-&gt;blockLevel++;
  transform(block);
  ctx-&gt;blockLevel--;

  return block;
}

/// Handle static for constructs.
/// @example
///   `for i in statictuple(1, x): &lt;suite&gt;` -&gt;
///   ```loop = True
///      while loop:
///        while loop:
///          i: Static[int] = 1; &lt;suite&gt;; break
///        while loop:
///          i = x; &lt;suite&gt;; break
///        loop = False   # also set to False on break
/// A separate suite is generated for each static iteration.
StmtPtr TypecheckVisitor::transformStaticForLoop(ForStmt *stmt) {
  auto var = stmt-&gt;var-&gt;getId()-&gt;value;
  if (!stmt-&gt;iter-&gt;getCall() || !stmt-&gt;iter-&gt;getCall()-&gt;expr-&gt;getId())
    return nullptr;
  auto iter = stmt-&gt;iter-&gt;getCall()-&gt;expr-&gt;getId();
  auto loopVar = ctx-&gt;cache-&gt;getTemporaryVar("loop");

  std::vector&lt;std::string&gt; vars{var};
  auto suiteVec = stmt-&gt;suite-&gt;getSuite();
  auto oldSuite = suiteVec ? suiteVec-&gt;clone() : nullptr;
  for (int validI = 0; suiteVec &amp;&amp; validI &lt; suiteVec-&gt;stmts.size(); validI++) {
    if (auto a = suiteVec-&gt;stmts[validI]-&gt;getAssign())
      if (a-&gt;rhs &amp;&amp; a-&gt;rhs-&gt;getIndex())
        if (a-&gt;rhs-&gt;getIndex()-&gt;expr-&gt;isId(var)) {
          vars.push_back(a-&gt;lhs-&gt;getId()-&gt;value);
          suiteVec-&gt;stmts[validI] = nullptr;
          continue;
        }
    break;
  }
  if (vars.size() &gt; 1)
    vars.erase(vars.begin());
  auto [ok, items] = transformStaticLoopCall(vars, stmt-&gt;iter, [&amp;](StmtPtr assigns) {
    auto brk = N&lt;BreakStmt&gt;();
    brk-&gt;setDone(); // Avoid transforming this one to continue
</t>
<t tx="ekr.20230509083243.1017">    // var [: Static] := expr; suite...
    auto loop = N&lt;WhileStmt&gt;(N&lt;IdExpr&gt;(loopVar),
                             N&lt;SuiteStmt&gt;(assigns, clone(stmt-&gt;suite), brk));
    loop-&gt;gotoVar = loopVar;
    return loop;
  });
  if (!ok) {
    if (oldSuite)
      stmt-&gt;suite = oldSuite;
    return nullptr;
  }

</t>
<t tx="ekr.20230509083243.1018">  // Close the loop
  ctx-&gt;blockLevel++;
  auto a = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(loopVar), N&lt;BoolExpr&gt;(false));
  a-&gt;setUpdate();
  auto block = N&lt;SuiteStmt&gt;();
  for (auto &amp;i : items)
    block-&gt;stmts.push_back(std::dynamic_pointer_cast&lt;Stmt&gt;(i));
  block-&gt;stmts.push_back(a);
</t>
<t tx="ekr.20230509083243.1019">  auto loop =
      transform(N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(loopVar), N&lt;BoolExpr&gt;(true)),
                             N&lt;WhileStmt&gt;(N&lt;IdExpr&gt;(loopVar), block)));
  ctx-&gt;blockLevel--;
  return loop;
}

std::pair&lt;bool, std::vector&lt;std::shared_ptr&lt;codon::SrcObject&gt;&gt;&gt;
TypecheckVisitor::transformStaticLoopCall(
  @others
</t>
<t tx="ekr.20230509083243.102">void CloneVisitor::visit(const TryCatchFlow *v) {
  auto *res = Nt(v, clone(v-&gt;getBody()), clone(v-&gt;getFinally()));
  for (auto &amp;c : *v) {
    res-&gt;emplace_back(clone(c.getHandler()), c.getType(), clone(c.getVar()));
  }
  result = res;
}

</t>
<t tx="ekr.20230509083243.1020">  const std::vector&lt;std::string&gt; &amp;vars, ExprPtr iter,
  std::function&lt;std::shared_ptr&lt;codon::SrcObject&gt;(StmtPtr)&gt; wrap) {
if (!iter-&gt;getCall())
  return {false, {}};
auto fn = iter-&gt;getCall()-&gt;expr-&gt;getId();
if (!fn || vars.empty())
  return {false, {}};

auto stmt = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(vars[0]), nullptr, nullptr);

std::vector&lt;std::shared_ptr&lt;codon::SrcObject&gt;&gt; block;
if (startswith(fn-&gt;value, "statictuple:0")) {
  auto &amp;args = iter-&gt;getCall()-&gt;args[0].value-&gt;getCall()-&gt;args;
  if (vars.size() != 1)
    error("expected one item");
  for (size_t i = 0; i &lt; args.size(); i++) {
    stmt-&gt;rhs = args[i].value;
    if (stmt-&gt;rhs-&gt;isStatic()) {
      stmt-&gt;type = NT&lt;IndexExpr&gt;(
          N&lt;IdExpr&gt;("Static"),
          N&lt;IdExpr&gt;(stmt-&gt;rhs-&gt;staticValue.type == StaticValue::INT ? "int" : "str"));
    } else {
      stmt-&gt;type = nullptr;
    }
    block.push_back(wrap(stmt-&gt;clone()));
  }
} else if (fn &amp;&amp; startswith(fn-&gt;value, "std.internal.types.range.staticrange:0")) {
  if (vars.size() != 1)
    error("expected one item");
@others
      block.push_back(wrap(b));
    }
  } else {
    error("bad call to staticenumerate");
  }
} else {
  return {false, {}};
}
return {true, block};
}

</t>
<t tx="ekr.20230509083243.1021">  int st =
      fn-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type-&gt;getStatic()-&gt;evaluate().getInt();
  @others
</t>
<t tx="ekr.20230509083243.1022">int ed =
    fn-&gt;type-&gt;getFunc()-&gt;funcGenerics[1].type-&gt;getStatic()-&gt;evaluate().getInt();
@others
</t>
<t tx="ekr.20230509083243.1023">int step =
    fn-&gt;type-&gt;getFunc()-&gt;funcGenerics[2].type-&gt;getStatic()-&gt;evaluate().getInt();
if (abs(st - ed) / abs(step) &gt; MAX_STATIC_ITER)
  E(Error::STATIC_RANGE_BOUNDS, fn, MAX_STATIC_ITER, abs(st - ed) / abs(step));
for (int i = st; step &gt; 0 ? i &lt; ed : i &gt; ed; i += step) {
  stmt-&gt;rhs = N&lt;IntExpr&gt;(i);
  stmt-&gt;type = NT&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"), N&lt;IdExpr&gt;("int"));
  block.push_back(wrap(stmt-&gt;clone()));
}
</t>
<t tx="ekr.20230509083243.1024">} else if (fn &amp;&amp; startswith(fn-&gt;value, "std.internal.types.range.staticrange:1")) {
  if (vars.size() != 1)
    error("expected one item");
</t>
<t tx="ekr.20230509083243.1025">  int ed =
      fn-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type-&gt;getStatic()-&gt;evaluate().getInt();
  if (ed &gt; MAX_STATIC_ITER)
    E(Error::STATIC_RANGE_BOUNDS, fn, MAX_STATIC_ITER, ed);
  for (int i = 0; i &lt; ed; i++) {
    stmt-&gt;rhs = N&lt;IntExpr&gt;(i);
    stmt-&gt;type = NT&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"), N&lt;IdExpr&gt;("int"));
    block.push_back(wrap(stmt-&gt;clone()));
  }
</t>
<t tx="ekr.20230509083243.1026">} else if (fn &amp;&amp; startswith(fn-&gt;value, "std.internal.static.fn_overloads")) {
  if (vars.size() != 1)
    error("expected one item");
  if (auto fna = ctx-&gt;getFunctionArgs(fn-&gt;type)) {
    auto [generics, args] = *fna;
    auto typ = generics[0]-&gt;getClass();
    auto name = ctx-&gt;getStaticString(generics[1]);
    seqassert(name, "bad static string");
    if (auto n = in(ctx-&gt;cache-&gt;classes[typ-&gt;name].methods, *name)) {
      auto &amp;mt = ctx-&gt;cache-&gt;overloads[*n];
      for (int mti = int(mt.size()) - 1; mti &gt;= 0; mti--) {
        auto &amp;method = mt[mti];
        if (endswith(method.name, ":dispatch") ||
            !ctx-&gt;cache-&gt;functions[method.name].type)
          continue;
        if (method.age &lt;= ctx-&gt;age) {
          if (typ-&gt;getHeterogenousTuple()) {
            auto &amp;ast = ctx-&gt;cache-&gt;functions[method.name].ast;
            if (ast-&gt;hasAttr("autogenerated") &amp;&amp;
                (endswith(ast-&gt;name, ".__iter__:0") ||
                 endswith(ast-&gt;name, ".__getitem__:0"))) {
              // ignore __getitem__ and other heterogenuous methods
              continue;
            }
          }
          stmt-&gt;rhs = N&lt;IdExpr&gt;(method.name);
          block.push_back(wrap(stmt-&gt;clone()));
        }
      }
    }
  } else {
    error("bad call to fn_overloads");
  }
} else if (fn &amp;&amp; startswith(fn-&gt;value, "std.internal.builtin.staticenumerate")) {
  if (vars.size() != 2)
    error("expected two items");
  if (auto fna = ctx-&gt;getFunctionArgs(fn-&gt;type)) {
    auto [generics, args] = *fna;
    auto typ = args[0]-&gt;getRecord();
    if (!typ)
      error("staticenumerate needs a tuple");
    for (size_t i = 0; i &lt; typ-&gt;args.size(); i++) {
</t>
<t tx="ekr.20230509083243.1027">      auto b = N&lt;SuiteStmt&gt;(
          {N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(vars[0]), N&lt;IntExpr&gt;(i),
                         NT&lt;IndexExpr&gt;(NT&lt;IdExpr&gt;("Static"), NT&lt;IdExpr&gt;("int"))),
           N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(vars[1]),
                         N&lt;IndexExpr&gt;(iter-&gt;getCall()-&gt;args[0].value-&gt;clone(),
                                      N&lt;IntExpr&gt;(i)))});
</t>
<t tx="ekr.20230509083243.1028">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1029">/// Replace unary operators with the appropriate magic calls.
/// Also evaluate static expressions. See @c evaluateStaticUnary for details.
void TypecheckVisitor::visit(UnaryExpr *expr) {
  transform(expr-&gt;expr);

  @others
  if (expr-&gt;op == "!") {
    // `not expr` -&gt; `expr.__bool__().__invert__()`
    resultExpr = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(expr-&gt;expr), "__bool__")), "__invert__")));
  } else {
    std::string magic;
    if (expr-&gt;op == "~")
      magic = "invert";
    else if (expr-&gt;op == "+")
      magic = "pos";
    else if (expr-&gt;op == "-")
      magic = "neg";
    else
      seqassert(false, "invalid unary operator '{}'", expr-&gt;op);
    resultExpr =
        transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(expr-&gt;expr), format("__{}__", magic))));
  }
}

</t>
<t tx="ekr.20230509083243.103">void CloneVisitor::visit(const PipelineFlow *v) {
  std::vector&lt;PipelineFlow::Stage&gt; cloned;
  for (const auto &amp;s : *v) {
    cloned.push_back(clone(s));
  }
  result = Nt(v, std::move(cloned));
}

</t>
<t tx="ekr.20230509083243.1030">static std::unordered_map&lt;StaticValue::Type, std::unordered_set&lt;std::string&gt;&gt;
    staticOps = {{StaticValue::INT, {"-", "+", "!"}}, {StaticValue::STRING, {"@"}}};
// Handle static expressions
if (expr-&gt;expr-&gt;isStatic() &amp;&amp; in(staticOps[expr-&gt;expr-&gt;staticValue.type], expr-&gt;op)) {
  resultExpr = evaluateStaticUnary(expr);
  return;
}

</t>
<t tx="ekr.20230509083243.1031">/// Replace binary operators with the appropriate magic calls.
/// See @c transformBinarySimple , @c transformBinaryIs , @c transformBinaryMagic and
/// @c transformBinaryInplaceMagic for details.
/// Also evaluate static expressions. See @c evaluateStaticBinary for details.
void TypecheckVisitor::visit(BinaryExpr *expr) {
  // Transform lexpr and rexpr. Ignore Nones for now
  if (!(startswith(expr-&gt;op, "is") &amp;&amp; expr-&gt;lexpr-&gt;getNone()))
    transform(expr-&gt;lexpr);
  if (!(startswith(expr-&gt;op, "is") &amp;&amp; expr-&gt;rexpr-&gt;getNone()))
    transform(expr-&gt;rexpr);

  @others
                   {StaticValue::STRING, {"==", "!=", "+"}}};
  if (expr-&gt;lexpr-&gt;isStatic() &amp;&amp; expr-&gt;rexpr-&gt;isStatic() &amp;&amp;
      expr-&gt;lexpr-&gt;staticValue.type == expr-&gt;rexpr-&gt;staticValue.type &amp;&amp;
      in(staticOps[expr-&gt;rexpr-&gt;staticValue.type], expr-&gt;op)) {
    // Handle static expressions
    resultExpr = evaluateStaticBinary(expr);
  } else if (auto e = transformBinarySimple(expr)) {
    // Case: simple binary expressions
    resultExpr = e;
  } else if (expr-&gt;lexpr-&gt;getType()-&gt;getUnbound() ||
             (expr-&gt;op != "is" &amp;&amp; expr-&gt;rexpr-&gt;getType()-&gt;getUnbound())) {
    // Case: types are unknown, so continue later
    unify(expr-&gt;type, ctx-&gt;getUnbound());
    return;
  } else if (expr-&gt;op == "is") {
    // Case: is operator
    resultExpr = transformBinaryIs(expr);
  } else {
    if (auto ei = transformBinaryInplaceMagic(expr, false)) {
      // Case: in-place magic methods
      resultExpr = ei;
    } else if (auto em = transformBinaryMagic(expr)) {
      // Case: normal magic methods
      resultExpr = em;
    } else if (expr-&gt;lexpr-&gt;getType()-&gt;is(TYPE_OPTIONAL)) {
      // Special case: handle optionals if everything else fails.
      // Assumes that optionals have no relevant magics (except for __eq__)
      resultExpr =
          transform(N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), expr-&gt;lexpr),
                                  expr-&gt;op, expr-&gt;rexpr, expr-&gt;inPlace));
    } else {
      // Nothing found: report an error
      E(Error::OP_NO_MAGIC, expr, expr-&gt;op, expr-&gt;lexpr-&gt;type-&gt;prettyString(),
        expr-&gt;rexpr-&gt;type-&gt;prettyString());
    }
  }
}

</t>
<t tx="ekr.20230509083243.1032">static std::unordered_map&lt;StaticValue::Type, std::unordered_set&lt;std::string&gt;&gt;
    staticOps = {{StaticValue::INT,
                  {"&lt;", "&lt;=", "&gt;", "&gt;=", "==", "!=", "&amp;&amp;", "||", "+", "-", "*", "//",
                   "%", "&amp;", "|", "^"}},
</t>
<t tx="ekr.20230509083243.1033">/// Helper function that locates the pipe ellipsis within a collection of (possibly
/// nested) CallExprs.
/// @return  List of CallExprs and their locations within the parent CallExpr
///          needed to access the ellipsis.
/// @example `foo(bar(1, baz(...)))` returns `[{0, baz}, {1, bar}, {0, foo}]`
std::vector&lt;std::pair&lt;size_t, ExprPtr&gt;&gt; findEllipsis(ExprPtr expr) {
  auto call = expr-&gt;getCall();
  if (!call)
    return {};
  for (size_t ai = 0; ai &lt; call-&gt;args.size(); ai++) {
    if (auto el = call-&gt;args[ai].value-&gt;getEllipsis()) {
      if (el-&gt;isPipeArg)
        return {{ai, expr}};
    } else if (call-&gt;args[ai].value-&gt;getCall()) {
      auto v = findEllipsis(call-&gt;args[ai].value);
      if (!v.empty()) {
        v.emplace_back(ai, expr);
        return v;
      }
    }
  }
  return {};
}

</t>
<t tx="ekr.20230509083243.1034">/// Typecheck pipe expressions.
/// Each stage call `foo(x)` without an ellipsis will be transformed to `foo(..., x)`.
/// Stages that are not in the form of CallExpr will be transformed to it (e.g., `foo`
/// -&gt; `foo(...)`).
/// Special care is taken of stages that can expand to multiple stages (e.g., `a |&gt; foo`
/// might become `a |&gt; unwrap |&gt; foo` to satisfy type constraints; see @c wrapExpr for
/// details).
void TypecheckVisitor::visit(PipeExpr *expr) {
  bool hasGenerator = false;

  @others
  // List of output types
  // (e.g., for `a|&gt;b|&gt;c` it is `[type(a), type(a|&gt;b), type(a|&gt;b|&gt;c)]`).
  // Note: the generator types are completely preserved (i.e., not extracted)
  expr-&gt;inTypes.clear();

  // Process the pipeline head
  auto inType = transform(expr-&gt;items[0].expr)-&gt;type; // input type to the next stage
  expr-&gt;inTypes.push_back(inType);
  inType = getIterableType(inType);
  auto done = expr-&gt;items[0].expr-&gt;isDone();
  for (size_t pi = 1; pi &lt; expr-&gt;items.size(); pi++) {
    int inTypePos = -1;                    // ellipsis position
    ExprPtr *ec = &amp;(expr-&gt;items[pi].expr); // a pointer so that we can replace it
    while (auto se = (*ec)-&gt;getStmtExpr()) // handle StmtExpr (e.g., in partial calls)
      ec = &amp;(se-&gt;expr);

    if (auto call = (*ec)-&gt;getCall()) {
      // Case: a call. Find the position of the pipe ellipsis within it
      for (size_t ia = 0; inTypePos == -1 &amp;&amp; ia &lt; call-&gt;args.size(); ia++)
        if (call-&gt;args[ia].value-&gt;getEllipsis()) {
          inTypePos = int(ia);
        }
      // No ellipses found? Prepend it as the first argument
      if (inTypePos == -1) {
        call-&gt;args.insert(call-&gt;args.begin(), {"", N&lt;EllipsisExpr&gt;()});
        inTypePos = 0;
      }
    } else {
      // Case: not a call. Convert it to a call with a single ellipsis
      expr-&gt;items[pi].expr = N&lt;CallExpr&gt;(expr-&gt;items[pi].expr, N&lt;EllipsisExpr&gt;());
      ec = &amp;expr-&gt;items[pi].expr;
      inTypePos = 0;
    }

    // Set the ellipsis type
    auto el = (*ec)-&gt;getCall()-&gt;args[inTypePos].value-&gt;getEllipsis();
    el-&gt;isPipeArg = true;
    // Don't unify unbound inType yet (it might become a generator that needs to be
    // extracted)
    if (inType &amp;&amp; !inType-&gt;getUnbound())
      unify(el-&gt;type, inType);

    // Transform the call. Because a transformation might wrap the ellipsis in layers,
    // make sure to extract these layers and move them to the pipeline.
    // Example: `foo(...)` that is transformed to `foo(unwrap(...))` will become
    // `unwrap(...) |&gt; foo(...)`
    transform(*ec);
    auto layers = findEllipsis(*ec);
    seqassert(!layers.empty(), "can't find the ellipsis");
    if (layers.size() &gt; 1) {
      // Prepend layers
      for (auto &amp;[pos, prepend] : layers) {
        prepend-&gt;getCall()-&gt;args[pos].value = N&lt;EllipsisExpr&gt;(true);
        expr-&gt;items.insert(expr-&gt;items.begin() + pi++, {"|&gt;", prepend});
      }
      // Rewind the loop (yes, the current expression will get transformed again)
      /// TODO: avoid reevaluation
      expr-&gt;items.erase(expr-&gt;items.begin() + pi);
      pi = pi - layers.size() - 1;
      continue;
    }

    if ((*ec)-&gt;type)
      unify(expr-&gt;items[pi].expr-&gt;type, (*ec)-&gt;type);
    expr-&gt;items[pi].expr = *ec;
    inType = expr-&gt;items[pi].expr-&gt;getType();
    if (!realize(inType))
      done = false;
    expr-&gt;inTypes.push_back(inType);

    // Do not extract the generator in the last stage of a pipeline
    if (pi + 1 &lt; expr-&gt;items.size())
      inType = getIterableType(inType);
  }
  unify(expr-&gt;type, (hasGenerator ? ctx-&gt;getType("NoneType") : inType));
  if (done)
    expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1035">// Return T if t is of type `Generator[T]`; otherwise just `type(t)`
auto getIterableType = [&amp;](TypePtr t) {
  if (t-&gt;is("Generator")) {
    hasGenerator = true;
    return t-&gt;getClass()-&gt;generics[0].type;
  }
  return t;
};

</t>
<t tx="ekr.20230509083243.1036">/// Transform index expressions.
/// @example
///   `foo[T]`   -&gt; Instantiate(foo, [T]) if `foo` is a type
///   `tup[1]`   -&gt; `tup.item1` if `tup` is tuple
///   `foo[idx]` -&gt; `foo.__getitem__(idx)`
///   expr.itemN or a sub-tuple if index is static (see transformStaticTupleIndex()),
void TypecheckVisitor::visit(IndexExpr *expr) {
  // Handle `Static[T]` constructs
  if (expr-&gt;expr-&gt;isId("Static")) {
    auto typ = ctx-&gt;getUnbound();
    typ-&gt;isStatic = getStaticGeneric(expr);
    unify(expr-&gt;type, typ);
    expr-&gt;setDone();
    return;
  }

  transform(expr-&gt;expr);
  seqassert(!expr-&gt;expr-&gt;isType(), "index not converted to instantiate");
  auto cls = expr-&gt;expr-&gt;getType()-&gt;getClass();
  if (!cls) {
    // Wait until the type becomes known
    unify(expr-&gt;type, ctx-&gt;getUnbound());
    return;
  }

  // Case: static tuple access
  auto [isTuple, tupleExpr] = transformStaticTupleIndex(cls, expr-&gt;expr, expr-&gt;index);
  if (isTuple) {
    if (!tupleExpr) {
      unify(expr-&gt;type, ctx-&gt;getUnbound());
    } else {
      resultExpr = tupleExpr;
    }
  } else {
    // Case: normal __getitem__
    resultExpr =
        transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, "__getitem__"), expr-&gt;index));
  }
}

</t>
<t tx="ekr.20230509083243.1037">/// Transform an instantiation to canonical realized name.
/// @example
///   Instantiate(foo, [bar]) -&gt; Id("foo[bar]")
void TypecheckVisitor::visit(InstantiateExpr *expr) {
  transformType(expr-&gt;typeExpr);
  TypePtr typ =
      ctx-&gt;instantiate(expr-&gt;typeExpr-&gt;getSrcInfo(), expr-&gt;typeExpr-&gt;getType());
  seqassert(typ-&gt;getClass(), "unknown type: {}", expr-&gt;typeExpr);

  auto &amp;generics = typ-&gt;getClass()-&gt;generics;
  bool isUnion = typ-&gt;getUnion() != nullptr;
  if (!isUnion &amp;&amp; expr-&gt;typeParams.size() != generics.size())
    E(Error::GENERICS_MISMATCH, expr, ctx-&gt;cache-&gt;rev(typ-&gt;getClass()-&gt;name),
      generics.size(), expr-&gt;typeParams.size());

  if (expr-&gt;typeExpr-&gt;isId(TYPE_CALLABLE)) {
    // Case: Callable[...] trait instantiation
    std::vector&lt;TypePtr&gt; types;

    // Callable error checking.
    for (auto &amp;typeParam : expr-&gt;typeParams) {
      transformType(typeParam);
      if (typeParam-&gt;type-&gt;isStaticType())
        E(Error::INST_CALLABLE_STATIC, typeParam);
      types.push_back(typeParam-&gt;type);
    }
    auto typ = ctx-&gt;getUnbound();
    // Set up the Callable trait
    typ-&gt;getLink()-&gt;trait = std::make_shared&lt;CallableTrait&gt;(ctx-&gt;cache, types);
    unify(expr-&gt;type, typ);
  } else if (expr-&gt;typeExpr-&gt;isId(TYPE_TYPEVAR)) {
    // Case: TypeVar[...] trait instantiation
    transformType(expr-&gt;typeParams[0]);
    auto typ = ctx-&gt;getUnbound();
    typ-&gt;getLink()-&gt;trait = std::make_shared&lt;TypeTrait&gt;(expr-&gt;typeParams[0]-&gt;type);
    unify(expr-&gt;type, typ);
  } else {
    for (size_t i = 0; i &lt; expr-&gt;typeParams.size(); i++) {
      transform(expr-&gt;typeParams[i]);
      TypePtr t = nullptr;
      if (expr-&gt;typeParams[i]-&gt;isStatic()) {
        t = Type::makeStatic(ctx-&gt;cache, expr-&gt;typeParams[i]);
      } else {
        if (expr-&gt;typeParams[i]-&gt;getNone()) // `None` -&gt; `NoneType`
          transformType(expr-&gt;typeParams[i]);
        if (!expr-&gt;typeParams[i]-&gt;isType())
          E(Error::EXPECTED_TYPE, expr-&gt;typeParams[i], "type");
        t = ctx-&gt;instantiate(expr-&gt;typeParams[i]-&gt;getSrcInfo(),
                             expr-&gt;typeParams[i]-&gt;getType());
      }
      if (isUnion)
        typ-&gt;getUnion()-&gt;addType(t);
      else
        unify(t, generics[i].type);
    }
    if (isUnion) {
      typ-&gt;getUnion()-&gt;seal();
    }
    unify(expr-&gt;type, typ);
  }
  expr-&gt;markType();

  // If the type is realizable, use the realized name instead of instantiation
  // (e.g. use Id("Ptr[byte]") instead of Instantiate(Ptr, {byte}))
  if (realize(expr-&gt;type)) {
    resultExpr = N&lt;IdExpr&gt;(expr-&gt;type-&gt;realizedName());
    resultExpr-&gt;setType(expr-&gt;type);
    resultExpr-&gt;setDone();
    if (expr-&gt;typeExpr-&gt;isType())
      resultExpr-&gt;markType();
  }
}

</t>
<t tx="ekr.20230509083243.1038">/// Transform a slice expression.
/// @example
///   `start::step` -&gt; `Slice(start, Optional.__new__(), step)`
void TypecheckVisitor::visit(SliceExpr *expr) {
  ExprPtr none = N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(TYPE_OPTIONAL, "__new__"));
  resultExpr = transform(N&lt;CallExpr&gt;(
      N&lt;IdExpr&gt;(TYPE_SLICE), expr-&gt;start ? expr-&gt;start : clone(none),
      expr-&gt;stop ? expr-&gt;stop : clone(none), expr-&gt;step ? expr-&gt;step : clone(none)));
}

</t>
<t tx="ekr.20230509083243.1039">/// Evaluate a static unary expression and return the resulting static expression.
/// If the expression cannot be evaluated yet, return nullptr.
/// Supported operators: (strings) not (ints) not, -, +
ExprPtr TypecheckVisitor::evaluateStaticUnary(UnaryExpr *expr) {
  // Case: static strings
  if (expr-&gt;expr-&gt;staticValue.type == StaticValue::STRING) {
    if (expr-&gt;op == "!") {
      if (expr-&gt;expr-&gt;staticValue.evaluated) {
        bool value = expr-&gt;expr-&gt;staticValue.getString().empty();
        LOG_TYPECHECK("[cond::un] {}: {}", getSrcInfo(), value);
        return transform(N&lt;BoolExpr&gt;(value));
      } else {
        // Cannot be evaluated yet: just set the type
        unify(expr-&gt;type, ctx-&gt;getType("bool"));
        if (!expr-&gt;isStatic())
          expr-&gt;staticValue.type = StaticValue::INT;
      }
    }
    return nullptr;
  }

  // Case: static integers
  if (expr-&gt;op == "-" || expr-&gt;op == "+" || expr-&gt;op == "!") {
    if (expr-&gt;expr-&gt;staticValue.evaluated) {
      int64_t value = expr-&gt;expr-&gt;staticValue.getInt();
      if (expr-&gt;op == "+")
        ;
      else if (expr-&gt;op == "-")
        value = -value;
      else
        value = !bool(value);
      LOG_TYPECHECK("[cond::un] {}: {}", getSrcInfo(), value);
      if (expr-&gt;op == "!")
        return transform(N&lt;BoolExpr&gt;(bool(value)));
      else
        return transform(N&lt;IntExpr&gt;(value));
    } else {
      // Cannot be evaluated yet: just set the type
      unify(expr-&gt;type, ctx-&gt;getType("int"));
      if (!expr-&gt;isStatic())
        expr-&gt;staticValue.type = StaticValue::INT;
    }
  }

  return nullptr;
}

/// Division and modulus implementations.
std::pair&lt;int, int&gt; divMod(const std::shared_ptr&lt;TypeContext&gt; &amp;ctx, int a, int b) {
  if (!b)
    E(Error::STATIC_DIV_ZERO, ctx-&gt;getSrcInfo());
  if (ctx-&gt;cache-&gt;pythonCompat) {
    // Use Python implementation.
    int d = a / b;
    int m = a - d * b;
    if (m &amp;&amp; ((b ^ m) &lt; 0)) {
      m += b;
      d -= 1;
    }
    return {d, m};
  } else {
    // Use C implementation.
    return {a / b, a % b};
  }
}

/// Evaluate a static binary expression and return the resulting static expression.
/// If the expression cannot be evaluated yet, return nullptr.
/// Supported operators: (strings) +, ==, !=
///                      (ints) &lt;, &lt;=, &gt;, &gt;=, ==, !=, and, or, +, -, *, //, %, ^, |, &amp;
ExprPtr TypecheckVisitor::evaluateStaticBinary(BinaryExpr *expr) {
  // Case: static strings
  if (expr-&gt;rexpr-&gt;staticValue.type == StaticValue::STRING) {
    if (expr-&gt;op == "+") {
      // `"a" + "b"` -&gt; `"ab"`
      if (expr-&gt;lexpr-&gt;staticValue.evaluated &amp;&amp; expr-&gt;rexpr-&gt;staticValue.evaluated) {
        auto value =
            expr-&gt;lexpr-&gt;staticValue.getString() + expr-&gt;rexpr-&gt;staticValue.getString();
        LOG_TYPECHECK("[cond::bin] {}: {}", getSrcInfo(), value);
        return transform(N&lt;StringExpr&gt;(value));
      } else {
        // Cannot be evaluated yet: just set the type
        if (!expr-&gt;isStatic())
          expr-&gt;staticValue.type = StaticValue::STRING;
        unify(expr-&gt;type, ctx-&gt;getType("str"));
      }
    } else {
      // `"a" == "b"` -&gt; `False` (also handles `!=`)
      if (expr-&gt;lexpr-&gt;staticValue.evaluated &amp;&amp; expr-&gt;rexpr-&gt;staticValue.evaluated) {
        bool eq = expr-&gt;lexpr-&gt;staticValue.getString() ==
                  expr-&gt;rexpr-&gt;staticValue.getString();
        bool value = expr-&gt;op == "==" ? eq : !eq;
        LOG_TYPECHECK("[cond::bin] {}: {}", getSrcInfo(), value);
        return transform(N&lt;BoolExpr&gt;(value));
      } else {
        // Cannot be evaluated yet: just set the type
        if (!expr-&gt;isStatic())
          expr-&gt;staticValue.type = StaticValue::INT;
        unify(expr-&gt;type, ctx-&gt;getType("bool"));
      }
    }
    return nullptr;
  }

  // Case: static integers
  if (expr-&gt;lexpr-&gt;staticValue.evaluated &amp;&amp; expr-&gt;rexpr-&gt;staticValue.evaluated) {
    int64_t lvalue = expr-&gt;lexpr-&gt;staticValue.getInt();
    int64_t rvalue = expr-&gt;rexpr-&gt;staticValue.getInt();
    if (expr-&gt;op == "&lt;")
      lvalue = lvalue &lt; rvalue;
    else if (expr-&gt;op == "&lt;=")
      lvalue = lvalue &lt;= rvalue;
    else if (expr-&gt;op == "&gt;")
      lvalue = lvalue &gt; rvalue;
    else if (expr-&gt;op == "&gt;=")
      lvalue = lvalue &gt;= rvalue;
    else if (expr-&gt;op == "==")
      lvalue = lvalue == rvalue;
    else if (expr-&gt;op == "!=")
      lvalue = lvalue != rvalue;
    else if (expr-&gt;op == "&amp;&amp;")
      lvalue = lvalue &amp;&amp; rvalue;
    else if (expr-&gt;op == "||")
      lvalue = lvalue || rvalue;
    else if (expr-&gt;op == "+")
      lvalue = lvalue + rvalue;
    else if (expr-&gt;op == "-")
      lvalue = lvalue - rvalue;
    else if (expr-&gt;op == "*")
      lvalue = lvalue * rvalue;
    else if (expr-&gt;op == "^")
      lvalue = lvalue ^ rvalue;
    else if (expr-&gt;op == "&amp;")
      lvalue = lvalue &amp; rvalue;
    else if (expr-&gt;op == "|")
      lvalue = lvalue | rvalue;
    else if (expr-&gt;op == "//")
      lvalue = divMod(ctx, lvalue, rvalue).first;
    else if (expr-&gt;op == "%")
      lvalue = divMod(ctx, lvalue, rvalue).second;
    else
      seqassert(false, "unknown static operator {}", expr-&gt;op);
    LOG_TYPECHECK("[cond::bin] {}: {}", getSrcInfo(), lvalue);
    if (in(std::set&lt;std::string&gt;{"==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;=", "&amp;&amp;", "||"},
           expr-&gt;op))
      return transform(N&lt;BoolExpr&gt;(bool(lvalue)));
    else
      return transform(N&lt;IntExpr&gt;(lvalue));
  } else {
    // Cannot be evaluated yet: just set the type
    if (!expr-&gt;isStatic())
      expr-&gt;staticValue.type = StaticValue::INT;
    unify(expr-&gt;type, ctx-&gt;getType("int"));
  }

  return nullptr;
}

/// Transform a simple binary expression.
/// @example
///   `a and b`    -&gt; `b if a else False`
///   `a or b`     -&gt; `True if a else b`
///   `a in b`     -&gt; `a.__contains__(b)`
///   `a not in b` -&gt; `not (a in b)`
///   `a is not b` -&gt; `not (a is b)`
ExprPtr TypecheckVisitor::transformBinarySimple(BinaryExpr *expr) {
  // Case: simple transformations
  if (expr-&gt;op == "&amp;&amp;") {
    return transform(N&lt;IfExpr&gt;(expr-&gt;lexpr,
                               N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__bool__")),
                               N&lt;BoolExpr&gt;(false)));
  } else if (expr-&gt;op == "||") {
    return transform(N&lt;IfExpr&gt;(expr-&gt;lexpr, N&lt;BoolExpr&gt;(true),
                               N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__bool__"))));
  } else if (expr-&gt;op == "not in") {
    return transform(N&lt;CallExpr&gt;(
        N&lt;DotExpr&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__contains__"), expr-&gt;lexpr),
                   "__invert__")));
  } else if (expr-&gt;op == "in") {
    return transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__contains__"), expr-&gt;lexpr));
  } else if (expr-&gt;op == "is") {
    if (expr-&gt;lexpr-&gt;getNone() &amp;&amp; expr-&gt;rexpr-&gt;getNone())
      return transform(N&lt;BoolExpr&gt;(true));
    else if (expr-&gt;lexpr-&gt;getNone())
      return transform(N&lt;BinaryExpr&gt;(expr-&gt;rexpr, "is", expr-&gt;lexpr));
  } else if (expr-&gt;op == "is not") {
    return transform(N&lt;UnaryExpr&gt;("!", N&lt;BinaryExpr&gt;(expr-&gt;lexpr, "is", expr-&gt;rexpr)));
  }
  return nullptr;
}

/// Transform a binary `is` expression by checking for type equality. Handle special `is
/// None` cses as well. See inside for details.
ExprPtr TypecheckVisitor::transformBinaryIs(BinaryExpr *expr) {
  seqassert(expr-&gt;op == "is", "not an is binary expression");

  // Case: `is None` expressions
  if (expr-&gt;rexpr-&gt;getNone()) {
    if (expr-&gt;lexpr-&gt;getType()-&gt;is("NoneType"))
      return transform(N&lt;BoolExpr&gt;(true));
    if (!expr-&gt;lexpr-&gt;getType()-&gt;is(TYPE_OPTIONAL)) {
      // lhs is not optional: `return False`
      return transform(N&lt;BoolExpr&gt;(false));
    } else {
      // Special case: Optional[Optional[... Optional[NoneType]]...] == NoneType
      auto g = expr-&gt;lexpr-&gt;getType()-&gt;getClass();
      for (; g-&gt;generics[0].type-&gt;is("Optional"); g = g-&gt;generics[0].type-&gt;getClass())
        ;
      if (g-&gt;generics[0].type-&gt;is("NoneType"))
        return transform(N&lt;BoolExpr&gt;(true));

      // lhs is optional: `return lhs.__has__().__invert__()`
      return transform(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;lexpr, "__has__")), "__invert__")));
    }
  }

  // Check the type equality (operand types and __raw__ pointers must match).
  auto lc = realize(expr-&gt;lexpr-&gt;getType());
  auto rc = realize(expr-&gt;rexpr-&gt;getType());
  if (!lc || !rc) {
    // Types not known: return early
    unify(expr-&gt;type, ctx-&gt;getType("bool"));
    return nullptr;
  }
  if (expr-&gt;lexpr-&gt;isType() &amp;&amp; expr-&gt;rexpr-&gt;isType())
    return transform(N&lt;BoolExpr&gt;(lc-&gt;realizedName() == rc-&gt;realizedName()));
  if (!lc-&gt;getRecord() &amp;&amp; !rc-&gt;getRecord()) {
    // Both reference types: `return lhs.__raw__() == rhs.__raw__()`
    return transform(
        N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;lexpr, "__raw__")),
                      "==", N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__raw__"))));
  }
  if (lc-&gt;getClass()-&gt;is(TYPE_OPTIONAL)) {
    // lhs is optional: `return lhs.__is_optional__(rhs)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;lexpr, "__is_optional__"), expr-&gt;rexpr));
  }
  if (rc-&gt;getClass()-&gt;is(TYPE_OPTIONAL)) {
    // rhs is optional: `return rhs.__is_optional__(lhs)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;rexpr, "__is_optional__"), expr-&gt;lexpr));
  }
  if (lc-&gt;realizedName() != rc-&gt;realizedName()) {
    // tuple names do not match: `return False`
    return transform(N&lt;BoolExpr&gt;(false));
  }
  // Same tuple types: `return lhs == rhs`
  return transform(N&lt;BinaryExpr&gt;(expr-&gt;lexpr, "==", expr-&gt;rexpr));
}

/// Return a binary magic opcode for the provided operator.
std::pair&lt;std::string, std::string&gt; TypecheckVisitor::getMagic(const std::string &amp;op) {
</t>
<t tx="ekr.20230509083243.104">void CloneVisitor::visit(const dsl::CustomFlow *v) { result = v-&gt;doClone(*this); }

</t>
<t tx="ekr.20230509083243.1040">  // Table of supported binary operations and the corresponding magic methods.
  static auto magics = std::unordered_map&lt;std::string, std::string&gt;{
      {"+", "add"},     {"-", "sub"},       {"*", "mul"},     {"**", "pow"},
      {"/", "truediv"}, {"//", "floordiv"}, {"@", "matmul"},  {"%", "mod"},
      {"&lt;", "lt"},      {"&lt;=", "le"},       {"&gt;", "gt"},      {"&gt;=", "ge"},
      {"==", "eq"},     {"!=", "ne"},       {"&lt;&lt;", "lshift"}, {"&gt;&gt;", "rshift"},
      {"&amp;", "and"},     {"|", "or"},        {"^", "xor"},
  };
</t>
<t tx="ekr.20230509083243.1041">  auto mi = magics.find(op);
  if (mi == magics.end())
    seqassert(false, "invalid binary operator '{}'", op);

</t>
<t tx="ekr.20230509083243.1042">  static auto rightMagics = std::unordered_map&lt;std::string, std::string&gt;{
      {"&lt;", "gt"}, {"&lt;=", "ge"}, {"&gt;", "lt"}, {"&gt;=", "le"}, {"==", "eq"}, {"!=", "ne"},
  };
</t>
<t tx="ekr.20230509083243.1043">  auto rm = in(rightMagics, op);
  return {mi-&gt;second, rm ? *rm : "r" + mi-&gt;second};
}

/// Transform an in-place binary expression.
/// @example
///   `a op= b` -&gt; `a.__iopmagic__(b)`
/// @param isAtomic if set, use atomic magics if available.
ExprPtr TypecheckVisitor::transformBinaryInplaceMagic(BinaryExpr *expr, bool isAtomic) {
  auto [magic, _] = getMagic(expr-&gt;op);
  auto lt = expr-&gt;lexpr-&gt;getType()-&gt;getClass();
  auto rt = expr-&gt;rexpr-&gt;getType()-&gt;getClass();
  seqassert(lt &amp;&amp; rt, "lhs and rhs types not known");

  FuncTypePtr method = nullptr;

  // Atomic operations: check if `lhs.__atomic_op__(Ptr[lhs], rhs)` exists
  if (isAtomic) {
    auto ptr = ctx-&gt;instantiateGeneric(ctx-&gt;getType("Ptr"), {lt});
    if ((method = findBestMethod(lt, format("__atomic_{}__", magic), {ptr, rt}))) {
      expr-&gt;lexpr = N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__ptr__"), expr-&gt;lexpr);
    }
  }

  // In-place operations: check if `lhs.__iop__(lhs, rhs)` exists
  if (!method &amp;&amp; expr-&gt;inPlace) {
    method = findBestMethod(lt, format("__i{}__", magic), {expr-&gt;lexpr, expr-&gt;rexpr});
  }

  if (method)
    return transform(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(method-&gt;ast-&gt;name), expr-&gt;lexpr, expr-&gt;rexpr));
  return nullptr;
}

/// Transform a magic binary expression.
/// @example
///   `a op b` -&gt; `a.__opmagic__(b)`
ExprPtr TypecheckVisitor::transformBinaryMagic(BinaryExpr *expr) {
  auto [magic, rightMagic] = getMagic(expr-&gt;op);
  auto lt = expr-&gt;lexpr-&gt;getType()-&gt;getClass();
  auto rt = expr-&gt;rexpr-&gt;getType()-&gt;getClass();
  seqassert(lt &amp;&amp; rt, "lhs and rhs types not known");

  if (!lt-&gt;is("pyobj") &amp;&amp; rt-&gt;is("pyobj")) {
    // Special case: `obj op pyobj` -&gt; `rhs.__rmagic__(lhs)` on lhs
    // Assumes that pyobj implements all left and right magics
    auto l = ctx-&gt;cache-&gt;getTemporaryVar("l"), r = ctx-&gt;cache-&gt;getTemporaryVar("r");
    return transform(
        N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(l), expr-&gt;lexpr),
                    N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(r), expr-&gt;rexpr),
                    N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(r), format("__{}__", rightMagic)),
                                N&lt;IdExpr&gt;(l))));
  }
  if (lt-&gt;getUnion()) {
    // Special case: `union op obj` -&gt; `union.__magic__(rhs)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;lexpr, format("__{}__", magic)), expr-&gt;rexpr));
  }

  // Normal operations: check if `lhs.__magic__(lhs, rhs)` exists
  if (auto method =
          findBestMethod(lt, format("__{}__", magic), {expr-&gt;lexpr, expr-&gt;rexpr})) {
    // Normal case: `__magic__(lhs, rhs)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(method-&gt;ast-&gt;name), expr-&gt;lexpr, expr-&gt;rexpr));
  }

  // Right-side magics: check if `rhs.__rmagic__(rhs, lhs)` exists
  if (auto method = findBestMethod(rt, format("__{}__", rightMagic),
                                   {expr-&gt;rexpr, expr-&gt;lexpr})) {
    auto l = ctx-&gt;cache-&gt;getTemporaryVar("l"), r = ctx-&gt;cache-&gt;getTemporaryVar("r");
    return transform(N&lt;StmtExpr&gt;(
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(l), expr-&gt;lexpr),
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(r), expr-&gt;rexpr),
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(method-&gt;ast-&gt;name), N&lt;IdExpr&gt;(r), N&lt;IdExpr&gt;(l))));
  }
  // 145

  return nullptr;
}

/// Given a tuple type and the expression `expr[index]`, check if an `index` is static
/// (integer or slice). If so, statically extract the specified tuple item or a
/// sub-tuple (if the index is a slice).
/// Works only on normal tuples and partial functions.
std::pair&lt;bool, ExprPtr&gt;
TypecheckVisitor::transformStaticTupleIndex(const ClassTypePtr &amp;tuple,
</t>
<t tx="ekr.20230509083243.1044">                                            const ExprPtr &amp;expr, const ExprPtr &amp;index) {
  if (!tuple-&gt;getRecord())
    return {false, nullptr};
  if (!startswith(tuple-&gt;name, TYPE_TUPLE) &amp;&amp; !startswith(tuple-&gt;name, TYPE_KWTUPLE) &amp;&amp;
      !startswith(tuple-&gt;name, TYPE_PARTIAL)) {
    if (tuple-&gt;is(TYPE_OPTIONAL)) {
      if (auto newTuple = tuple-&gt;generics[0].type-&gt;getClass()) {
        return transformStaticTupleIndex(
            newTuple, transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), expr)), index);
      } else {
        return {true, nullptr};
      }
    }
    return {false, nullptr};
  }

  @others
  auto classItem = in(ctx-&gt;cache-&gt;classes, tuple-&gt;name);
  seqassert(classItem, "cannot find class '{}'", tuple-&gt;name);
  auto sz = classItem-&gt;fields.size();
  int64_t start = 0, stop = sz, step = 1;
  if (getInt(&amp;start, index)) {
    // Case: `tuple[int]`
    auto i = translateIndex(start, stop);
    if (i &lt; 0 || i &gt;= stop)
      E(Error::TUPLE_RANGE_BOUNDS, index, stop - 1, i);
    return {true, transform(N&lt;DotExpr&gt;(expr, classItem-&gt;fields[i].name))};
  } else if (auto slice = CAST(index, SliceExpr)) {
    // Case: `tuple[int:int:int]`
    if (!getInt(&amp;start, slice-&gt;start) || !getInt(&amp;stop, slice-&gt;stop) ||
        !getInt(&amp;step, slice-&gt;step))
      return {false, nullptr};

    // Adjust slice indices (Python slicing rules)
    if (slice-&gt;step &amp;&amp; !slice-&gt;start)
      start = step &gt; 0 ? 0 : (sz - 1);
    if (slice-&gt;step &amp;&amp; !slice-&gt;stop)
      stop = step &gt; 0 ? sz : -(sz + 1);
    sliceAdjustIndices(sz, &amp;start, &amp;stop, step);

    // Generate a sub-tuple
    auto var = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("tup"));
    auto ass = N&lt;AssignStmt&gt;(var, expr);
    std::vector&lt;ExprPtr&gt; te;
    for (auto i = start; (step &gt; 0) ? (i &lt; stop) : (i &gt; stop); i += step) {
      if (i &lt; 0 || i &gt;= sz)
        E(Error::TUPLE_RANGE_BOUNDS, index, sz - 1, i);
      te.push_back(N&lt;DotExpr&gt;(clone(var), classItem-&gt;fields[i].name));
    }
    ExprPtr e = transform(N&lt;StmtExpr&gt;(
        std::vector&lt;StmtPtr&gt;{ass},
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(format(TYPE_TUPLE "{}", te.size()), "__new__"), te)));
    return {true, e};
  }

  return {false, nullptr};
}

</t>
<t tx="ekr.20230509083243.1045">// Extract the static integer value from expression
auto getInt = [&amp;](int64_t *o, const ExprPtr &amp;e) {
  if (!e)
    return true;
  auto f = transform(clone(e));
  if (f-&gt;staticValue.type == StaticValue::INT) {
    seqassert(f-&gt;staticValue.evaluated, "{} not evaluated", e);
    *o = f-&gt;staticValue.getInt();
    return true;
  } else if (auto ei = f-&gt;getInt()) {
    *o = *(ei-&gt;intValue);
    return true;
  }
  return false;
};

</t>
<t tx="ekr.20230509083243.1046">/// Follow Python indexing rules for static tuple indices.
/// Taken from https://github.com/python/cpython/blob/main/Objects/sliceobject.c.
int64_t TypecheckVisitor::translateIndex(int64_t idx, int64_t len, bool clamp) {
  if (idx &lt; 0)
    idx += len;
  if (clamp) {
    if (idx &lt; 0)
      idx = 0;
    if (idx &gt; len)
      idx = len;
  } else if (idx &lt; 0 || idx &gt;= len) {
    E(Error::TUPLE_RANGE_BOUNDS, getSrcInfo(), len - 1, idx);
  }
  return idx;
}

</t>
<t tx="ekr.20230509083243.1047">/// Follow Python slice indexing rules for static tuple indices.
/// Taken from https://github.com/python/cpython/blob/main/Objects/sliceobject.c.
/// Quote (sliceobject.c:269): "this is harder to get right than you might think"
int64_t TypecheckVisitor::sliceAdjustIndices(int64_t length, int64_t *start,
  @others
</t>
<t tx="ekr.20230509083243.1048">                                           int64_t *stop, int64_t step) {
if (step == 0)
  E(Error::SLICE_STEP_ZERO, getSrcInfo());

if (*start &lt; 0) {
  *start += length;
  if (*start &lt; 0) {
    *start = (step &lt; 0) ? -1 : 0;
  }
} else if (*start &gt;= length) {
  *start = (step &lt; 0) ? length - 1 : length;
}

if (*stop &lt; 0) {
  *stop += length;
  if (*stop &lt; 0) {
    *stop = (step &lt; 0) ? -1 : 0;
  }
} else if (*stop &gt;= length) {
  *stop = (step &lt; 0) ? length - 1 : length;
}

if (step &lt; 0) {
  if (*stop &lt; *start) {
    return (*start - *stop - 1) / (-step) + 1;
  }
} else {
  if (*start &lt; *stop) {
    return (*stop - *start - 1) / step + 1;
  }
}
return 0;
}

</t>
<t tx="ekr.20230509083243.1049">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "typecheck.h"

#include &lt;memory&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/ctx.h"
#include "codon/parser/visitors/typecheck/ctx.h"
#include &lt;fmt/format.h&gt;

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

StmtPtr TypecheckVisitor::apply(Cache *cache, const StmtPtr &amp;stmts) {
  if (!cache-&gt;typeCtx)
    cache-&gt;typeCtx = std::make_shared&lt;TypeContext&gt;(cache);
  TypecheckVisitor v(cache-&gt;typeCtx);
  auto s = v.inferTypes(clone(stmts), true);
  if (!s) {
    v.error("cannot typecheck the program");
  }
  if (s-&gt;getSuite())
    v.prepareVTables();
  return s;
}

/**************************************************************************************/

TypecheckVisitor::TypecheckVisitor(std::shared_ptr&lt;TypeContext&gt; ctx,
@others
/// Unpack a Tuple or KwTuple expression into (name, type) vector.
/// Name is empty when handling Tuple; otherwise it matches names of KwTuple.
std::shared_ptr&lt;std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt;&gt;
TypecheckVisitor::unpackTupleTypes(ExprPtr expr) {
  auto ret = std::make_shared&lt;std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt;&gt;();
  if (auto tup = expr-&gt;origExpr-&gt;getTuple()) {
    for (auto &amp;a : tup-&gt;items) {
      transform(a);
      if (!a-&gt;getType()-&gt;getClass())
        return nullptr;
      ret-&gt;push_back({"", a-&gt;getType()});
    }
  } else if (auto kw = expr-&gt;origExpr-&gt;getCall()) { // origExpr?
    auto kwCls = in(ctx-&gt;cache-&gt;classes, expr-&gt;getType()-&gt;getClass()-&gt;name);
    seqassert(kwCls, "cannot find {}", expr-&gt;getType()-&gt;getClass()-&gt;name);
    for (size_t i = 0; i &lt; kw-&gt;args.size(); i++) {
      auto &amp;a = kw-&gt;args[i].value;
      transform(a);
      if (!a-&gt;getType()-&gt;getClass())
        return nullptr;
      ret-&gt;push_back({kwCls-&gt;fields[i].name, a-&gt;getType()});
    }
  } else {
    return nullptr;
  }
  return ret;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.105">void CloneVisitor::visit(const IntConst *v) {
  result = Nt(v, v-&gt;getVal(), v-&gt;getType());
}

</t>
<t tx="ekr.20230509083243.1050">                                   const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts)
    : ctx(std::move(ctx)) {
  prependStmts = stmts ? stmts : std::make_shared&lt;std::vector&lt;StmtPtr&gt;&gt;();
}

</t>
<t tx="ekr.20230509083243.1051">/**************************************************************************************/

/// Transform an expression node.
ExprPtr TypecheckVisitor::transform(ExprPtr &amp;expr) {
  if (!expr)
    return nullptr;

  auto typ = expr-&gt;type;
  if (!expr-&gt;done) {
    TypecheckVisitor v(ctx, prependStmts);
    v.setSrcInfo(expr-&gt;getSrcInfo());
    ctx-&gt;pushSrcInfo(expr-&gt;getSrcInfo());
    expr-&gt;accept(v);
    ctx-&gt;popSrcInfo();
    if (v.resultExpr) {
      v.resultExpr-&gt;attributes |= expr-&gt;attributes;
      v.resultExpr-&gt;origExpr = expr;
      expr = v.resultExpr;
    }
    seqassert(expr-&gt;type, "type not set for {}", expr);
    unify(typ, expr-&gt;type);
    if (expr-&gt;done)
      ctx-&gt;changedNodes++;
  }
  realize(typ);
  LOG_TYPECHECK("[expr] {}: {}{}", getSrcInfo(), expr, expr-&gt;isDone() ? "[done]" : "");
  return expr;
}

/// Transform a type expression node.
/// Special case: replace `None` with `NoneType`
/// @throw @c ParserException if a node is not a type (use @c transform instead).
ExprPtr TypecheckVisitor::transformType(ExprPtr &amp;expr) {
  if (expr &amp;&amp; expr-&gt;getNone()) {
    expr = N&lt;IdExpr&gt;(expr-&gt;getSrcInfo(), "NoneType");
    expr-&gt;markType();
  }
  transform(expr);
  if (expr) {
    if (!expr-&gt;isType() &amp;&amp; expr-&gt;isStatic()) {
      expr-&gt;setType(Type::makeStatic(ctx-&gt;cache, expr));
    } else if (!expr-&gt;isType()) {
      E(Error::EXPECTED_TYPE, expr, "type");
    } else {
      expr-&gt;setType(ctx-&gt;instantiate(expr-&gt;getType()));
    }
  }
  return expr;
}

</t>
<t tx="ekr.20230509083243.1052">void TypecheckVisitor::defaultVisit(Expr *e) {
  seqassert(false, "unexpected AST node {}", e-&gt;toString());
}

</t>
<t tx="ekr.20230509083243.1053">/// Transform a statement node.
StmtPtr TypecheckVisitor::transform(StmtPtr &amp;stmt) {
  if (!stmt || stmt-&gt;done)
    return stmt;

  TypecheckVisitor v(ctx);
  v.setSrcInfo(stmt-&gt;getSrcInfo());
  auto oldAge = ctx-&gt;age;
  stmt-&gt;age = ctx-&gt;age = std::max(stmt-&gt;age, oldAge);
  ctx-&gt;pushSrcInfo(stmt-&gt;getSrcInfo());
  stmt-&gt;accept(v);
  ctx-&gt;popSrcInfo();
  ctx-&gt;age = oldAge;
  if (v.resultStmt)
    stmt = v.resultStmt;
  if (!v.prependStmts-&gt;empty()) {
    if (stmt)
      v.prependStmts-&gt;push_back(stmt);
    bool done = true;
    for (auto &amp;s : *(v.prependStmts))
      done &amp;= s-&gt;done;
    stmt = N&lt;SuiteStmt&gt;(*v.prependStmts);
    stmt-&gt;done = done;
  }
  if (stmt-&gt;done)
    ctx-&gt;changedNodes++;
  return stmt;
}

</t>
<t tx="ekr.20230509083243.1054">void TypecheckVisitor::defaultVisit(Stmt *s) {
  seqassert(false, "unexpected AST node {}", s-&gt;toString());
}

</t>
<t tx="ekr.20230509083243.1055">/**************************************************************************************/

</t>
<t tx="ekr.20230509083243.1056">/// Typecheck statement expressions.
void TypecheckVisitor::visit(StmtExpr *expr) {
  auto done = true;
  for (auto &amp;s : expr-&gt;stmts) {
    transform(s);
    done &amp;= s-&gt;isDone();
  }
  transform(expr-&gt;expr);
  unify(expr-&gt;type, expr-&gt;expr-&gt;type);
  if (done &amp;&amp; expr-&gt;expr-&gt;isDone())
    expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1057">/// Typecheck a list of statements.
void TypecheckVisitor::visit(SuiteStmt *stmt) {
  std::vector&lt;StmtPtr&gt; stmts; // for filtering out nullptr statements
  auto done = true;
  for (auto &amp;s : stmt-&gt;stmts) {
    if (ctx-&gt;returnEarly) {
      // If returnEarly is set (e.g., in the function) ignore the rest
      break;
    }
    if (transform(s)) {
      stmts.push_back(s);
      done &amp;= stmts.back()-&gt;isDone();
    }
  }
  stmt-&gt;stmts = stmts;
  if (done)
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1058">/// Typecheck expression statements.
void TypecheckVisitor::visit(ExprStmt *stmt) {
  transform(stmt-&gt;expr);
  if (stmt-&gt;expr-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.1059">void TypecheckVisitor::visit(CommentStmt *stmt) { stmt-&gt;setDone(); }

/**************************************************************************************/

/// Select the best method indicated of an object that matches the given argument
/// types. See @c findMatchingMethods for details.
types::FuncTypePtr
TypecheckVisitor::findBestMethod(const ClassTypePtr &amp;typ, const std::string &amp;member,
</t>
<t tx="ekr.20230509083243.106">void CloneVisitor::visit(const FloatConst *v) {
  result = Nt(v, v-&gt;getVal(), v-&gt;getType());
}

</t>
<t tx="ekr.20230509083243.1060">                                 const std::vector&lt;types::TypePtr&gt; &amp;args) {
  std::vector&lt;CallExpr::Arg&gt; callArgs;
  for (auto &amp;a : args) {
    callArgs.push_back({"", std::make_shared&lt;NoneExpr&gt;()}); // dummy expression
    callArgs.back().value-&gt;setType(a);
  }
  auto methods = ctx-&gt;findMethod(typ-&gt;name, member, false);
  auto m = findMatchingMethods(typ, methods, callArgs);
  return m.empty() ? nullptr : m[0];
}

</t>
<t tx="ekr.20230509083243.1061">/// Select the best method indicated of an object that matches the given argument
/// types. See @c findMatchingMethods for details.
types::FuncTypePtr TypecheckVisitor::findBestMethod(const ClassTypePtr &amp;typ,
</t>
<t tx="ekr.20230509083243.1062">                                                    const std::string &amp;member,
  @others
</t>
<t tx="ekr.20230509083243.1063">                                                  const std::vector&lt;ExprPtr&gt; &amp;args) {
std::vector&lt;CallExpr::Arg&gt; callArgs;
for (auto &amp;a : args)
  callArgs.push_back({"", a});
auto methods = ctx-&gt;findMethod(typ-&gt;name, member, false);
auto m = findMatchingMethods(typ, methods, callArgs);
return m.empty() ? nullptr : m[0];
}

</t>
<t tx="ekr.20230509083243.1064">/// Select the best method indicated of an object that matches the given argument
/// types. See @c findMatchingMethods for details.
types::FuncTypePtr TypecheckVisitor::findBestMethod(
</t>
<t tx="ekr.20230509083243.1065">    const ClassTypePtr &amp;typ, const std::string &amp;member,
  @others
</t>
<t tx="ekr.20230509083243.1066">  const std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt; &amp;args) {
std::vector&lt;CallExpr::Arg&gt; callArgs;
for (auto &amp;[n, a] : args) {
  callArgs.push_back({n, std::make_shared&lt;NoneExpr&gt;()}); // dummy expression
  callArgs.back().value-&gt;setType(a);
}
auto methods = ctx-&gt;findMethod(typ-&gt;name, member, false);
auto m = findMatchingMethods(typ, methods, callArgs);
return m.empty() ? nullptr : m[0];
}

</t>
<t tx="ekr.20230509083243.1067">// Search expression tree for a identifier
class IdSearchVisitor : public CallbackASTVisitor&lt;bool, bool&gt; {
  std::string what;
  bool result;

public:
  IdSearchVisitor(std::string what) : what(std::move(what)), result(false) {}
  @others
};

</t>
<t tx="ekr.20230509083243.1068">bool transform(const std::shared_ptr&lt;Expr&gt; &amp;expr) override {
  if (result)
    return result;
  IdSearchVisitor v(what);
  if (expr)
    expr-&gt;accept(v);
  return v.result;
}
</t>
<t tx="ekr.20230509083243.1069">bool transform(const std::shared_ptr&lt;Stmt&gt; &amp;stmt) override {
  if (result)
    return result;
  IdSearchVisitor v(what);
  if (stmt)
    stmt-&gt;accept(v);
  return v.result;
}
</t>
<t tx="ekr.20230509083243.107">void CloneVisitor::visit(const BoolConst *v) {
  result = Nt(v, v-&gt;getVal(), v-&gt;getType());
}

</t>
<t tx="ekr.20230509083243.1070">void visit(IdExpr *expr) override {
  if (expr-&gt;value == what)
    result = true;
}
</t>
<t tx="ekr.20230509083243.1071">/// Check if a function can be called with the given arguments.
/// See @c reorderNamedArgs for details.
int TypecheckVisitor::canCall(const types::FuncTypePtr &amp;fn,
  @others
</t>
<t tx="ekr.20230509083243.1072">                            const std::vector&lt;CallExpr::Arg&gt; &amp;args) {
std::vector&lt;std::pair&lt;types::TypePtr, size_t&gt;&gt; reordered;
auto niGenerics = fn-&gt;ast-&gt;getNonInferrableGenerics();
@others
  try {
    ExprPtr dummy = std::make_shared&lt;IdExpr&gt;("");
    dummy-&gt;type = argType;
    dummy-&gt;setDone();
    wrapExpr(dummy, expectTyp, fn);
    types::Type::Unification undo;
    if (dummy-&gt;type-&gt;unify(expectTyp.get(), &amp;undo) &gt;= 0) {
      undo.undo();
    } else {
      score = -1;
    }
  } catch (const exc::ParserException &amp;) {
    // Ignore failed wraps
    score = -1;
  }
}
return score;
}

</t>
<t tx="ekr.20230509083243.1073">auto score = ctx-&gt;reorderNamedArgs(
    fn.get(), args,
    [&amp;](int s, int k, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;slots, bool _) {
      for (int si = 0; si &lt; slots.size(); si++) {
        if (fn-&gt;ast-&gt;args[si].status == Param::Generic) {
          if (slots[si].empty()) {
            // is this "real" type?
            if (in(niGenerics, fn-&gt;ast-&gt;args[si].name) &amp;&amp;
                !fn-&gt;ast-&gt;args[si].defaultValue)
              return -1;
            reordered.push_back({nullptr, 0});
          } else {
            reordered.push_back({args[slots[si][0]].value-&gt;type, slots[si][0]});
          }
        } else if (si == s || si == k || slots[si].size() != 1) {
          // Ignore *args, *kwargs and default arguments
          reordered.push_back({nullptr, 0});
        } else {
          reordered.push_back({args[slots[si][0]].value-&gt;type, slots[si][0]});
        }
      }
      return 0;
    },
</t>
<t tx="ekr.20230509083243.1074">    [](error::Error, const SrcInfo &amp;, const std::string &amp;) { return -1; });
for (int ai = 0, mai = 0, gi = 0; score != -1 &amp;&amp; ai &lt; reordered.size(); ai++) {
</t>
<t tx="ekr.20230509083243.1075">  auto expectTyp = fn-&gt;ast-&gt;args[ai].status == Param::Normal
                       ? fn-&gt;getArgTypes()[mai++]
                       : fn-&gt;funcGenerics[gi++].type;
  auto [argType, argTypeIdx] = reordered[ai];
  if (!argType)
    continue;
  if (fn-&gt;ast-&gt;args[ai].status != Param::Normal) {
    // Check if this is a good generic!
    if (expectTyp &amp;&amp; expectTyp-&gt;isStaticType()) {
      if (!args[argTypeIdx].value-&gt;isStatic()) {
        score = -1;
        break;
      } else {
        argType = Type::makeStatic(ctx-&gt;cache, args[argTypeIdx].value);
      }
    } else {
      /// TODO: check if these are real types or if traits are satisfied
      continue;
    }
  }
</t>
<t tx="ekr.20230509083243.1076">/// Select the best method among the provided methods given the list of arguments.
/// See @c reorderNamedArgs for details.
std::vector&lt;types::FuncTypePtr&gt;
TypecheckVisitor::findMatchingMethods(const types::ClassTypePtr &amp;typ,
</t>
<t tx="ekr.20230509083243.1077">                                      const std::vector&lt;types::FuncTypePtr&gt; &amp;methods,
  @others
</t>
<t tx="ekr.20230509083243.1078">                                    const std::vector&lt;CallExpr::Arg&gt; &amp;args) {
// Pick the last method that accepts the given arguments.
std::vector&lt;types::FuncTypePtr&gt; results;
for (const auto &amp;mi : methods) {
  if (!mi)
    continue; // avoid overloads that have not been seen yet
  auto method = ctx-&gt;instantiate(mi, typ)-&gt;getFunc();
  int score = canCall(method, args);
  if (score != -1) {
    results.push_back(mi);
  }
}
return results;
}

</t>
<t tx="ekr.20230509083243.1079">/// Wrap an expression to coerce it to the expected type if the type of the expression
/// does not match it. Also unify types.
/// @example
///   expected `Generator`                -&gt; `expr.__iter__()`
///   expected `float`, got `int`         -&gt; `float(expr)`
///   expected `Optional[T]`, got `T`     -&gt; `Optional(expr)`
///   expected `T`, got `Optional[T]`     -&gt; `unwrap(expr)`
///   expected `Function`, got a function -&gt; partialize function
///   expected `T`, got `Union[T...]`     -&gt; `__internal__.get_union(expr, T)`
///   expected `Union[T...]`, got `T`     -&gt; `__internal__.new_union(expr, Union[T...])`
///   expected base class, got derived    -&gt; downcast to base class
/// @param allowUnwrap allow optional unwrapping.
bool TypecheckVisitor::wrapExpr(ExprPtr &amp;expr, const TypePtr &amp;expectedType,
  @others
</t>
<t tx="ekr.20230509083243.108">void CloneVisitor::visit(const StringConst *v) {
  result = Nt(v, v-&gt;getVal(), v-&gt;getType());
}

</t>
<t tx="ekr.20230509083243.1080">                              const FuncTypePtr &amp;callee, bool allowUnwrap) {
auto expectedClass = expectedType-&gt;getClass();
auto exprClass = expr-&gt;getType()-&gt;getClass();
@others
std::unordered_set&lt;std::string&gt; hints = {"Generator", "float", TYPE_OPTIONAL,
                                         "pyobj"};
if (!exprClass &amp;&amp; expectedClass &amp;&amp; in(hints, expectedClass-&gt;name)) {
  return false; // argument type not yet known.
} else if (expectedClass &amp;&amp; expectedClass-&gt;name == "Generator" &amp;&amp;
           exprClass-&gt;name != expectedClass-&gt;name &amp;&amp; !expr-&gt;getEllipsis()) {
  // Note: do not do this in pipelines (TODO: why?)
  expr = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr, "__iter__")));
} else if (expectedClass &amp;&amp; expectedClass-&gt;name == "float" &amp;&amp;
           exprClass-&gt;name == "int") {
  expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("float"), expr));
} else if (expectedClass &amp;&amp; expectedClass-&gt;name == TYPE_OPTIONAL &amp;&amp;
           exprClass-&gt;name != expectedClass-&gt;name) {
  expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(TYPE_OPTIONAL), expr));
} else if (allowUnwrap &amp;&amp; expectedClass &amp;&amp; exprClass &amp;&amp;
           exprClass-&gt;name == TYPE_OPTIONAL &amp;&amp;
           exprClass-&gt;name != expectedClass-&gt;name) { // unwrap optional
  expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), expr));
} else if (expectedClass &amp;&amp; expectedClass-&gt;name == "pyobj" &amp;&amp;
           exprClass-&gt;name != expectedClass-&gt;name) { // wrap to pyobj
  expr = transform(
      N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("pyobj"), N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr, "__to_py__"))));
} else if (allowUnwrap &amp;&amp; expectedClass &amp;&amp; exprClass &amp;&amp; exprClass-&gt;name == "pyobj" &amp;&amp;
           exprClass-&gt;name != expectedClass-&gt;name) { // unwrap pyobj
  auto texpr = N&lt;IdExpr&gt;(expectedClass-&gt;name);
  texpr-&gt;setType(expectedType);
  expr =
      transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(texpr, "__from_py__"), N&lt;DotExpr&gt;(expr, "p")));
} else if (callee &amp;&amp; exprClass &amp;&amp; expr-&gt;type-&gt;getFunc() &amp;&amp;
           !(expectedClass &amp;&amp; expectedClass-&gt;name == "Function")) {
  // Wrap raw Seq functions into Partial(...) call for easy realization.
  expr = partializeFunction(expr-&gt;type-&gt;getFunc());
} else if (allowUnwrap &amp;&amp; exprClass &amp;&amp; expr-&gt;type-&gt;getUnion() &amp;&amp; expectedClass &amp;&amp;
           !expectedClass-&gt;getUnion()) {
  // Extract union types via __internal__.get_union
  if (auto t = realize(expectedClass)) {
    expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.get_union:0"), expr,
                                 N&lt;IdExpr&gt;(t-&gt;realizedName())));
  } else {
    return false;
  }
} else if (exprClass &amp;&amp; expectedClass &amp;&amp; expectedClass-&gt;getUnion()) {
  // Make union types via __internal__.new_union
  if (!expectedClass-&gt;getUnion()-&gt;isSealed())
    expectedClass-&gt;getUnion()-&gt;addType(exprClass);
  if (auto t = realize(expectedClass)) {
    if (expectedClass-&gt;unify(exprClass.get(), nullptr) == -1)
      expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.new_union:0"), expr,
                                   NT&lt;IdExpr&gt;(t-&gt;realizedName())));
  } else {
    return false;
  }
} else if (exprClass &amp;&amp; expectedClass &amp;&amp; exprClass-&gt;name != expectedClass-&gt;name) {
  // Cast derived classes to base classes
  auto &amp;mros = ctx-&gt;cache-&gt;classes[exprClass-&gt;name].mro;
  for (size_t i = 1; i &lt; mros.size(); i++) {
    auto t = ctx-&gt;instantiate(mros[i]-&gt;type, exprClass);
    if (t-&gt;unify(expectedClass.get(), nullptr) &gt;= 0) {
      if (!expr-&gt;isId("")) {
        expr = castToSuperClass(expr, expectedClass, true);
      } else { // Just checking can this be done
        expr-&gt;type = expectedClass;
      }
      break;
    }
  }
}
return true;
}

</t>
<t tx="ekr.20230509083243.1081">auto doArgWrap =
    !callee || !callee-&gt;ast-&gt;hasAttr("std.internal.attributes.no_argument_wrap");
if (!doArgWrap)
  return true;
@others
</t>
<t tx="ekr.20230509083243.1082">auto doTypeWrap =
    !callee || !callee-&gt;ast-&gt;hasAttr("std.internal.attributes.no_type_wrap");
if (callee &amp;&amp; expr-&gt;isType()) {
  auto c = expr-&gt;type-&gt;getClass();
  if (!c)
    return false;
  if (doTypeWrap) {
    if (c-&gt;getRecord())
      expr = transform(N&lt;CallExpr&gt;(expr, N&lt;EllipsisExpr&gt;()));
    else
      expr = transform(N&lt;CallExpr&gt;(
          N&lt;IdExpr&gt;("__internal__.class_ctr:0"),
          std::vector&lt;CallExpr::Arg&gt;{{"T", expr}, {"", N&lt;EllipsisExpr&gt;()}}));
  }
}

</t>
<t tx="ekr.20230509083243.1083">/// Cast derived class to a base class.
ExprPtr TypecheckVisitor::castToSuperClass(ExprPtr expr, ClassTypePtr superTyp,
</t>
<t tx="ekr.20230509083243.1084">                                           bool isVirtual) {
  ClassTypePtr typ = expr-&gt;type-&gt;getClass();
  for (auto &amp;field : ctx-&gt;cache-&gt;classes[typ-&gt;name].fields) {
    for (auto &amp;parentField : ctx-&gt;cache-&gt;classes[superTyp-&gt;name].fields)
      if (field.name == parentField.name) {
        unify(ctx-&gt;instantiate(field.type, typ),
              ctx-&gt;instantiate(parentField.type, superTyp));
      }
  }
  auto typExpr = N&lt;IdExpr&gt;(superTyp-&gt;name);
  typExpr-&gt;setType(superTyp);
  // `dist = expr.__raw__()`
  ExprPtr dist = N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr, "__raw__"));
  if (isVirtual) {
    // Virtual inheritance: `dist += class_base_derived_dist(super, type(expr))`
    dist =
        N&lt;BinaryExpr&gt;(dist, "+",
                      N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.class_base_derived_dist:0"),
                                  N&lt;IdExpr&gt;(superTyp-&gt;realizedName()),
                                  N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("type"), expr)));
  }
  realize(superTyp);

  // No inheritance: `__internal__.to_class_ptr(dist, T)`
  return transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;("__internal__"), "to_class_ptr"),
                               dist, typExpr));
}

</t>
<t tx="ekr.20230509083243.1085">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

/**
 * Visitor that infers expression types and performs type-guided transformations.
 *
 * -&gt; Note: this stage *modifies* the provided AST. Clone it before simplification
 *    if you need it intact.
 */
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1086">class TypecheckVisitor : public CallbackASTVisitor&lt;ExprPtr, StmtPtr&gt; {
  /// Shared simplification context.
  std::shared_ptr&lt;TypeContext&gt; ctx;
  /// Statements to prepend before the current statement.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; prependStmts;

  /// Each new expression is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  ExprPtr resultExpr;
  /// Each new statement is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  StmtPtr resultStmt;

public:
  static StmtPtr apply(Cache *cache, const StmtPtr &amp;stmts);

public:
  explicit TypecheckVisitor(
      std::shared_ptr&lt;TypeContext&gt; ctx,
      const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts = nullptr);

public: // Convenience transformators
  ExprPtr transform(ExprPtr &amp;e) override;
  ExprPtr transform(const ExprPtr &amp;expr) override {
    auto e = expr;
    return transform(e);
  }
  StmtPtr transform(StmtPtr &amp;s) override;
  StmtPtr transform(const StmtPtr &amp;stmt) override {
    auto s = stmt;
    return transform(s);
  }
  ExprPtr transformType(ExprPtr &amp;expr);
  ExprPtr transformType(const ExprPtr &amp;expr) {
    auto e = expr;
    return transformType(e);
  }

private:
  void defaultVisit(Expr *e) override;
  void defaultVisit(Stmt *s) override;

private: // Node typechecking rules
  /* Basic type expressions (basic.cpp) */
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;

  /* Identifier access expressions (access.cpp) */
  void visit(IdExpr *) override;
  void visit(DotExpr *) override;
  ExprPtr transformDot(DotExpr *, std::vector&lt;CallExpr::Arg&gt; * = nullptr);
  ExprPtr getClassMember(DotExpr *, std::vector&lt;CallExpr::Arg&gt; *);
  types::TypePtr findSpecialMember(const std::string &amp;);
  types::FuncTypePtr getBestOverload(Expr *, std::vector&lt;CallExpr::Arg&gt; *);
  types::FuncTypePtr getDispatch(const std::string &amp;);

  /* Collection and comprehension expressions (collections.cpp) */
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  ExprPtr transformComprehension(const std::string &amp;, const std::string &amp;,
                                 std::vector&lt;ExprPtr&gt; &amp;);

  /* Conditional expression and statements (cond.cpp) */
  void visit(IfExpr *) override;
  void visit(IfStmt *) override;

  /* Operators (op.cpp) */
  void visit(UnaryExpr *) override;
  ExprPtr evaluateStaticUnary(UnaryExpr *);
  void visit(BinaryExpr *) override;
  ExprPtr evaluateStaticBinary(BinaryExpr *);
  ExprPtr transformBinarySimple(BinaryExpr *);
  ExprPtr transformBinaryIs(BinaryExpr *);
  std::pair&lt;std::string, std::string&gt; getMagic(const std::string &amp;);
  ExprPtr transformBinaryInplaceMagic(BinaryExpr *, bool);
  ExprPtr transformBinaryMagic(BinaryExpr *);
  void visit(PipeExpr *) override;
  void visit(IndexExpr *) override;
  std::pair&lt;bool, ExprPtr&gt; transformStaticTupleIndex(const types::ClassTypePtr &amp;,
                                                     const ExprPtr &amp;, const ExprPtr &amp;);
  int64_t translateIndex(int64_t, int64_t, bool = false);
  int64_t sliceAdjustIndices(int64_t, int64_t *, int64_t *, int64_t);
  void visit(InstantiateExpr *) override;
  void visit(SliceExpr *) override;

  /* Calls (call.cpp) */
  /// Holds partial call information for a CallExpr.
  struct PartialCallData {
    bool isPartial = false;                   // true if the call is partial
    std::string var;                          // set if calling a partial type itself
    std::vector&lt;char&gt; known = {};             // mask of known arguments
    ExprPtr args = nullptr, kwArgs = nullptr; // partial *args/**kwargs expressions
  };
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(CallExpr *) override;
  bool transformCallArgs(std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::pair&lt;types::FuncTypePtr, ExprPtr&gt; getCalleeFn(CallExpr *, PartialCallData &amp;);
  ExprPtr callReorderArguments(types::FuncTypePtr, CallExpr *, PartialCallData &amp;);
  bool typecheckCallArgs(const types::FuncTypePtr &amp;, std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::pair&lt;bool, ExprPtr&gt; transformSpecialCall(CallExpr *);
  ExprPtr transformSuperF(CallExpr *expr);
  ExprPtr transformSuper();
  ExprPtr transformPtr(CallExpr *expr);
  ExprPtr transformArray(CallExpr *expr);
  ExprPtr transformIsInstance(CallExpr *expr);
  ExprPtr transformStaticLen(CallExpr *expr);
  ExprPtr transformHasAttr(CallExpr *expr);
  ExprPtr transformGetAttr(CallExpr *expr);
  ExprPtr transformSetAttr(CallExpr *expr);
  ExprPtr transformCompileError(CallExpr *expr);
  ExprPtr transformTupleFn(CallExpr *expr);
  ExprPtr transformTypeFn(CallExpr *expr);
  ExprPtr transformRealizedFn(CallExpr *expr);
  ExprPtr transformStaticPrintFn(CallExpr *expr);
  std::pair&lt;bool, ExprPtr&gt; transformInternalStaticFn(CallExpr *expr);
  std::vector&lt;types::ClassTypePtr&gt; getSuperTypes(const types::ClassTypePtr &amp;cls);
  void addFunctionGenerics(const types::FuncType *t);
  std::string generatePartialStub(const std::vector&lt;char&gt; &amp;mask, types::FuncType *fn);

  /* Assignments (assign.cpp) */
  void visit(AssignStmt *) override;
  void transformUpdate(AssignStmt *);
  void visit(AssignMemberStmt *) override;
  std::pair&lt;bool, ExprPtr&gt; transformInplaceUpdate(AssignStmt *);

  /* Loops (loops.cpp) */
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  StmtPtr transformHeterogenousTupleFor(ForStmt *);
  StmtPtr transformStaticForLoop(ForStmt *);

  /* Errors and exceptions (error.cpp) */
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;

  /* Functions (function.cpp) */
  void visit(YieldExpr *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(FunctionStmt *) override;
  ExprPtr partializeFunction(const types::FuncTypePtr &amp;);
  std::shared_ptr&lt;types::RecordType&gt; getFuncTypeBase(size_t);

  /* Classes (class.cpp) */
  void visit(ClassStmt *) override;
  void parseBaseClasses(ClassStmt *);
  std::string generateTuple(size_t, const std::string &amp; = TYPE_TUPLE,
                            std::vector&lt;std::string&gt; = {}, bool = true);

  /* The rest (typecheck.cpp) */
  void visit(SuiteStmt *) override;
  void visit(ExprStmt *) override;
  void visit(StmtExpr *) override;
  void visit(CommentStmt *stmt) override;

private:
  /* Type inference (infer.cpp) */
  types::TypePtr unify(types::TypePtr &amp;a, const types::TypePtr &amp;b);
  types::TypePtr unify(types::TypePtr &amp;&amp;a, const types::TypePtr &amp;b) {
    auto x = a;
    return unify(x, b);
  }
  StmtPtr inferTypes(StmtPtr, bool isToplevel = false);
  types::TypePtr realize(types::TypePtr);
  types::TypePtr realizeFunc(types::FuncType *, bool = false);
  types::TypePtr realizeType(types::ClassType *);
  std::shared_ptr&lt;FunctionStmt&gt; generateSpecialAst(types::FuncType *);
  size_t getRealizationID(types::ClassType *, types::FuncType *);
  codon::ir::types::Type *makeIRType(types::ClassType *);
  codon::ir::Func *
  makeIRFunction(const std::shared_ptr&lt;Cache::Function::FunctionRealization&gt; &amp;);

private:
  types::FuncTypePtr findBestMethod(const types::ClassTypePtr &amp;typ,
                                    const std::string &amp;member,
                                    const std::vector&lt;types::TypePtr&gt; &amp;args);
  types::FuncTypePtr findBestMethod(const types::ClassTypePtr &amp;typ,
                                    const std::string &amp;member,
                                    const std::vector&lt;ExprPtr&gt; &amp;args);
  types::FuncTypePtr
  findBestMethod(const types::ClassTypePtr &amp;typ, const std::string &amp;member,
                 const std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt; &amp;args);
  int canCall(const types::FuncTypePtr &amp;, const std::vector&lt;CallExpr::Arg&gt; &amp;);
  std::vector&lt;types::FuncTypePtr&gt;
  findMatchingMethods(const types::ClassTypePtr &amp;typ,
                      const std::vector&lt;types::FuncTypePtr&gt; &amp;methods,
                      const std::vector&lt;CallExpr::Arg&gt; &amp;args);
  bool wrapExpr(ExprPtr &amp;expr, const types::TypePtr &amp;expectedType,
                const types::FuncTypePtr &amp;callee = nullptr, bool allowUnwrap = true);
  ExprPtr castToSuperClass(ExprPtr expr, types::ClassTypePtr superTyp, bool = false);
  StmtPtr prepareVTables();

public:
  bool isTuple(const std::string &amp;s) const { return startswith(s, TYPE_TUPLE); }

  friend class Cache;
  friend class types::CallableTrait;
  friend class types::UnionType;

private: // Helpers
  std::shared_ptr&lt;std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt;&gt;
      unpackTupleTypes(ExprPtr);
  std::pair&lt;bool, std::vector&lt;std::shared_ptr&lt;codon::SrcObject&gt;&gt;&gt;
  transformStaticLoopCall(const std::vector&lt;std::string&gt; &amp;, ExprPtr,
                          std::function&lt;std::shared_ptr&lt;codon::SrcObject&gt;(StmtPtr)&gt;);
};

</t>
<t tx="ekr.20230509083243.1087"></t>
<t tx="ekr.20230509083243.1088">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/runtime/lib.h"
#include "llvm/BinaryFormat/Dwarf.h"
#include &lt;backtrace.h&gt;
#include &lt;cassert&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct BacktraceFrame {
  char *function;
  char *filename;
  uintptr_t pc;
  int32_t lineno;
};

struct Backtrace {
  static const size_t LIMIT = 20;
  struct BacktraceFrame *frames;
  size_t count;

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1089">  void push_back(const char *function, const char *filename, uintptr_t pc,
    @others
</t>
<t tx="ekr.20230509083243.109">void CloneVisitor::visit(const dsl::CustomConst *v) { result = v-&gt;doClone(*this); }

</t>
<t tx="ekr.20230509083243.1090">             int32_t lineno) {
if (count &gt;= LIMIT || !function || !filename) {
  return;
} else if (count == 0) {
  frames = (BacktraceFrame *)seq_alloc(LIMIT * sizeof(*frames));
}

size_t functionLen = strlen(function) + 1;
auto *functionDup = (char *)seq_alloc_atomic(functionLen);
memcpy(functionDup, function, functionLen);

size_t filenameLen = strlen(filename) + 1;
auto *filenameDup = (char *)seq_alloc_atomic(filenameLen);
memcpy(filenameDup, filename, filenameLen);

frames[count++] = {functionDup, filenameDup, pc, lineno};
  }

</t>
<t tx="ekr.20230509083243.1091">  void push_back(uintptr_t pc) { push_back("&lt;invalid&gt;", "&lt;invalid&gt;", pc, 0); }

</t>
<t tx="ekr.20230509083243.1092">  void free() {
    for (auto i = 0; i &lt; count; i++) {
      auto *frame = &amp;frames[i];
      seq_free(frame-&gt;function);
      seq_free(frame-&gt;filename);
    }
    seq_free(frames);
    frames = nullptr;
    count = 0;
  }
</t>
<t tx="ekr.20230509083243.1093">};

</t>
<t tx="ekr.20230509083243.1094">void seq_backtrace_error_callback(void *data, const char *msg, int errnum) {
  // printf("seq_backtrace_error_callback: %s (errnum = %d)\n", msg, errnum);
}

</t>
<t tx="ekr.20230509083243.1095">int seq_backtrace_full_callback(void *data, uintptr_t pc, const char *filename,
                                int lineno, const char *function) {
  auto *bt = ((Backtrace *)data);
  bt-&gt;push_back(function, filename, pc, lineno);
  return (bt-&gt;count &lt; Backtrace::LIMIT) ? 0 : 1;
}

</t>
<t tx="ekr.20230509083243.1096">int seq_backtrace_simple_callback(void *data, uintptr_t pc) {
  auto *bt = ((Backtrace *)data);
  bt-&gt;push_back(pc);
  return (bt-&gt;count &lt; Backtrace::LIMIT) ? 0 : 1;
}

</t>
<t tx="ekr.20230509083243.1097">/*
 * This is largely based on
 * llvm/examples/ExceptionDemo/ExceptionDemo.cpp
 */

namespace {
template &lt;typename Type_&gt; static uintptr_t ReadType(const uint8_t *&amp;p) {
  Type_ value;
  memcpy(&amp;value, p, sizeof(Type_));
  p += sizeof(Type_);
  return static_cast&lt;uintptr_t&gt;(value);
}
} // namespace

static int64_t ourBaseFromUnwindOffset;

</t>
<t tx="ekr.20230509083243.1098">static const unsigned char ourBaseExcpClassChars[] = {'o', 'b', 'j', '\0',
                                                      's', 'e', 'q', '\0'};

                                                      @others
</t>
<t tx="ekr.20230509083243.1099">static uint64_t genClass(const unsigned char classChars[], size_t classCharsSize) {
  uint64_t ret = classChars[0];

  for (unsigned i = 1; i &lt; classCharsSize; i++) {
    ret &lt;&lt;= 8;
    ret += classChars[i];
  }

  return ret;
}

</t>
<t tx="ekr.20230509083243.11">const std::string GeneratorArgumentOptimization::KEY =
    "core-pythonic-generator-argument-opt";

  @others
</t>
<t tx="ekr.20230509083243.110">void CloneVisitor::visit(const AssignInstr *v) {
  result = Nt(v, clone(v-&gt;getLhs()), clone(v-&gt;getRhs()));
}

</t>
<t tx="ekr.20230509083243.1100">static uint64_t ourBaseExceptionClass = 0;

struct OurExceptionType_t {
  int type;
};

struct OurBaseException_t {
  OurExceptionType_t type; // Seq exception type
  void *obj;               // Seq exception instance
  Backtrace bt;
  _Unwind_Exception unwindException;
};

typedef struct OurBaseException_t OurException;

struct SeqExcHeader_t {
  seq_str_t type;
  seq_str_t msg;
  seq_str_t func;
  seq_str_t file;
  seq_int_t line;
  seq_int_t col;
  void *python_type;
};

</t>
<t tx="ekr.20230509083243.1101">void seq_exc_init() {
  ourBaseFromUnwindOffset = seq_exc_offset();
  ourBaseExceptionClass = seq_exc_class();
}

</t>
<t tx="ekr.20230509083243.1102">static void seq_delete_exc(_Unwind_Exception *expToDelete) {
  if (!expToDelete || expToDelete-&gt;exception_class != ourBaseExceptionClass)
    return;
  auto *exc = (OurException *)((char *)expToDelete + ourBaseFromUnwindOffset);
  if (seq_flags &amp; SEQ_FLAG_DEBUG) {
    exc-&gt;bt.free();
  }
  seq_free(exc);
}

</t>
<t tx="ekr.20230509083243.1103">static void seq_delete_unwind_exc(_Unwind_Reason_Code reason,
                                  _Unwind_Exception *expToDelete) {
  seq_delete_exc(expToDelete);
}

</t>
<t tx="ekr.20230509083243.1104">static struct backtrace_state *state = nullptr;
static std::mutex stateLock;

SEQ_FUNC void *seq_alloc_exc(int type, void *obj) {
  const size_t size = sizeof(OurException);
  auto *e = (OurException *)memset(seq_alloc(size), 0, size);
  assert(e);
  e-&gt;type.type = type;
  e-&gt;obj = obj;
  e-&gt;unwindException.exception_class = ourBaseExceptionClass;
  e-&gt;unwindException.exception_cleanup = seq_delete_unwind_exc;
  if (seq_flags &amp; SEQ_FLAG_DEBUG) {
    e-&gt;bt.frames = nullptr;
    e-&gt;bt.count = 0;

    if (seq_flags &amp; SEQ_FLAG_STANDALONE) {
      if (!state) {
        stateLock.lock();
        if (!state)
          state =
              backtrace_create_state(/*filename=*/nullptr, /*threaded=*/1,
                                     seq_backtrace_error_callback, /*data=*/nullptr);
        stateLock.unlock();
      }
      backtrace_full(state, /*skip=*/1, seq_backtrace_full_callback,
                     seq_backtrace_error_callback, &amp;e-&gt;bt);
    } else {
      backtrace_simple(/*state=*/nullptr, /*skip=*/1, seq_backtrace_simple_callback,
                       seq_backtrace_error_callback, &amp;e-&gt;bt);
    }
  }
  return &amp;(e-&gt;unwindException);
}

</t>
<t tx="ekr.20230509083243.1105">static void print_from_last_dot(seq_str_t s, std::ostringstream &amp;buf) {
  char *p = s.str;
  int64_t n = s.len;

  for (int64_t i = n - 1; i &gt;= 0; i--) {
    if (p[i] == '.') {
      p += (i + 1);
      n -= (i + 1);
      break;
    }
  }

  buf.write(p, (size_t)n);
}

</t>
<t tx="ekr.20230509083243.1106">static std::function&lt;void(const codon::runtime::JITError &amp;)&gt; jitErrorCallback;

SEQ_FUNC void seq_terminate(void *exc) {
  auto *base = (OurBaseException_t *)((char *)exc + seq_exc_offset());
  void *obj = base-&gt;obj;
  auto *hdr = (SeqExcHeader_t *)obj;

  if (std::string(hdr-&gt;type.str, hdr-&gt;type.len) == "SystemExit") {
    seq_int_t status = *(seq_int_t *)(hdr + 1);
    exit((int)status);
  }

  std::ostringstream buf;
  if (seq_flags &amp; SEQ_FLAG_CAPTURE_OUTPUT)
    buf &lt;&lt; codon::runtime::getCapturedOutput();

  buf &lt;&lt; "\033[1m";
  print_from_last_dot(hdr-&gt;type, buf);
  if (hdr-&gt;msg.len &gt; 0) {
    buf &lt;&lt; ": \033[0m";
    buf.write(hdr-&gt;msg.str, hdr-&gt;msg.len);
  } else {
    buf &lt;&lt; "\033[0m";
  }

  buf &lt;&lt; "\n\n\033[1mRaised from:\033[0m \033[32m";
  buf.write(hdr-&gt;func.str, hdr-&gt;func.len);
  buf &lt;&lt; "\033[0m\n";
  buf.write(hdr-&gt;file.str, hdr-&gt;file.len);
  if (hdr-&gt;line &gt; 0) {
    buf &lt;&lt; ":" &lt;&lt; hdr-&gt;line;
    if (hdr-&gt;col &gt; 0)
      buf &lt;&lt; ":" &lt;&lt; hdr-&gt;col;
  }
  buf &lt;&lt; "\n";

  if ((seq_flags &amp; SEQ_FLAG_DEBUG) &amp;&amp; (seq_flags &amp; SEQ_FLAG_STANDALONE)) {
    auto *bt = &amp;base-&gt;bt;
    if (bt-&gt;count &gt; 0) {
      buf &lt;&lt; "\n\033[1mBacktrace:\033[0m\n";
      for (unsigned i = 0; i &lt; bt-&gt;count; i++) {
        auto *frame = &amp;bt-&gt;frames[i];
        buf &lt;&lt; "  "
            &lt;&lt; codon::runtime::makeBacktraceFrameString(
                   frame-&gt;pc, std::string(frame-&gt;function),
                   std::string(frame-&gt;filename), frame-&gt;lineno)
            &lt;&lt; "\n";
      }
    }
  }

  auto output = buf.str();
  if (seq_flags &amp; SEQ_FLAG_STANDALONE) {
    fwrite(output.data(), 1, output.size(), stderr);
    abort();
  } else {
    auto *bt = &amp;base-&gt;bt;
    std::string msg(hdr-&gt;msg.str, hdr-&gt;msg.len);
    std::string file(hdr-&gt;file.str, hdr-&gt;file.len);
    std::string type(hdr-&gt;type.str, hdr-&gt;type.len);

    std::vector&lt;uintptr_t&gt; backtrace;
    if (seq_flags &amp; SEQ_FLAG_DEBUG) {
      for (unsigned i = 0; i &lt; bt-&gt;count; i++) {
        backtrace.push_back(bt-&gt;frames[i].pc);
      }
    }
    codon::runtime::JITError e(output, msg, type, file, (int)hdr-&gt;line, (int)hdr-&gt;col,
                               backtrace);
    if (jitErrorCallback)
      jitErrorCallback(e);
    else
      throw e;
  }
}

SEQ_FUNC void seq_throw(void *exc) {
  _Unwind_Reason_Code code = _Unwind_RaiseException((_Unwind_Exception *)exc);
  (void)code;
  seq_terminate(exc);
}

</t>
<t tx="ekr.20230509083243.1107">static uintptr_t readULEB128(const uint8_t **data) {
  uintptr_t result = 0;
  uintptr_t shift = 0;
  unsigned char byte;
  const uint8_t *p = *data;

  do {
    byte = *p++;
    result |= (byte &amp; 0x7f) &lt;&lt; shift;
    shift += 7;
  } while (byte &amp; 0x80);

  *data = p;

  return result;
}

</t>
<t tx="ekr.20230509083243.1108">static uintptr_t readSLEB128(const uint8_t **data) {
  uintptr_t result = 0;
  uintptr_t shift = 0;
  unsigned char byte;
  const uint8_t *p = *data;

  do {
    byte = *p++;
    result |= (byte &amp; 0x7f) &lt;&lt; shift;
    shift += 7;
  } while (byte &amp; 0x80);

  *data = p;

  if ((byte &amp; 0x40) &amp;&amp; (shift &lt; (sizeof(result) &lt;&lt; 3))) {
    result |= (~0 &lt;&lt; shift);
  }

  return result;
}

</t>
<t tx="ekr.20230509083243.1109">static unsigned getEncodingSize(uint8_t encoding) {
  if (encoding == llvm::dwarf::DW_EH_PE_omit)
    return 0;

  switch (encoding &amp; 0x0F) {
  case llvm::dwarf::DW_EH_PE_absptr:
    return sizeof(uintptr_t);
  case llvm::dwarf::DW_EH_PE_udata2:
    return sizeof(uint16_t);
  case llvm::dwarf::DW_EH_PE_udata4:
    return sizeof(uint32_t);
  case llvm::dwarf::DW_EH_PE_udata8:
    return sizeof(uint64_t);
  case llvm::dwarf::DW_EH_PE_sdata2:
    return sizeof(int16_t);
  case llvm::dwarf::DW_EH_PE_sdata4:
    return sizeof(int32_t);
  case llvm::dwarf::DW_EH_PE_sdata8:
    return sizeof(int64_t);
  default:
    // not supported
    abort();
  }
}

</t>
<t tx="ekr.20230509083243.111">void CloneVisitor::visit(const ExtractInstr *v) {
  result = Nt(v, clone(v-&gt;getVal()), v-&gt;getField());
}

</t>
<t tx="ekr.20230509083243.1110">static uintptr_t readEncodedPointer(const uint8_t **data, uint8_t encoding) {
  uintptr_t result = 0;
  const uint8_t *p = *data;

  if (encoding == llvm::dwarf::DW_EH_PE_omit)
    return result;

  // first get value
  switch (encoding &amp; 0x0F) {
  case llvm::dwarf::DW_EH_PE_absptr:
    result = ReadType&lt;uintptr_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_uleb128:
    result = readULEB128(&amp;p);
    break;
    // Note: This case has not been tested
  case llvm::dwarf::DW_EH_PE_sleb128:
    result = readSLEB128(&amp;p);
    break;
  case llvm::dwarf::DW_EH_PE_udata2:
    result = ReadType&lt;uint16_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_udata4:
    result = ReadType&lt;uint32_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_udata8:
    result = ReadType&lt;uint64_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_sdata2:
    result = ReadType&lt;int16_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_sdata4:
    result = ReadType&lt;int32_t&gt;(p);
    break;
  case llvm::dwarf::DW_EH_PE_sdata8:
    result = ReadType&lt;int64_t&gt;(p);
    break;
  default:
    // not supported
    abort();
  }

  // then add relative offset
  switch (encoding &amp; 0x70) {
  case llvm::dwarf::DW_EH_PE_absptr:
    // do nothing
    break;
  case llvm::dwarf::DW_EH_PE_pcrel:
    result += (uintptr_t)(*data);
    break;
  case llvm::dwarf::DW_EH_PE_textrel:
  case llvm::dwarf::DW_EH_PE_datarel:
  case llvm::dwarf::DW_EH_PE_funcrel:
  case llvm::dwarf::DW_EH_PE_aligned:
  default:
    // not supported
    abort();
  }

  // then apply indirection
  if (encoding &amp; llvm::dwarf::DW_EH_PE_indirect) {
    result = *((uintptr_t *)result);
  }

  *data = p;

  return result;
}

</t>
<t tx="ekr.20230509083243.1111">static bool handleActionValue(int64_t *resultAction, uint8_t TTypeEncoding,
  @others
</t>
<t tx="ekr.20230509083243.1112">                            const uint8_t *ClassInfo, uintptr_t actionEntry,
                            uint64_t exceptionClass,
                            _Unwind_Exception *exceptionObject) {
bool ret = false;

if (!resultAction || !exceptionObject || (exceptionClass != ourBaseExceptionClass))
  return ret;

auto *excp = (struct OurBaseException_t *)(((char *)exceptionObject) +
                                           ourBaseFromUnwindOffset);
OurExceptionType_t *excpType = &amp;(excp-&gt;type);
seq_int_t type = excpType-&gt;type;

const uint8_t *actionPos = (uint8_t *)actionEntry, *tempActionPos;
int64_t typeOffset = 0, actionOffset;

for (int i = 0;; i++) {
  // Each emitted dwarf action corresponds to a 2 tuple of
  // type info address offset, and action offset to the next
  // emitted action.
  typeOffset = (int64_t)readSLEB128(&amp;actionPos);
  tempActionPos = actionPos;
  actionOffset = (int64_t)readSLEB128(&amp;tempActionPos);

  assert(typeOffset &gt;= 0);

  // Note: A typeOffset == 0 implies that a cleanup llvm.eh.selector
  //       argument has been matched.
  if (typeOffset &gt; 0) {
    unsigned EncSize = getEncodingSize(TTypeEncoding);
    const uint8_t *EntryP = ClassInfo - typeOffset * EncSize;
    uintptr_t P = readEncodedPointer(&amp;EntryP, TTypeEncoding);
    auto *ThisClassInfo = reinterpret_cast&lt;OurExceptionType_t *&gt;(P);
    // type=0 means catch-all
    if (ThisClassInfo-&gt;type == 0 || ThisClassInfo-&gt;type == type) {
      *resultAction = i + 1;
      ret = true;
      break;
    }
  }

  if (!actionOffset)
    break;

  actionPos += actionOffset;
}

return ret;
}

</t>
<t tx="ekr.20230509083243.1113">static _Unwind_Reason_Code handleLsda(int version, const uint8_t *lsda,
                                      _Unwind_Action actions, uint64_t exceptionClass,
                                      _Unwind_Exception *exceptionObject,
                                      _Unwind_Context *context) {
  _Unwind_Reason_Code ret = _URC_CONTINUE_UNWIND;

  if (!lsda)
    return ret;

  // Get the current instruction pointer and offset it before next
  // instruction in the current frame which threw the exception.
  uintptr_t pc = _Unwind_GetIP(context) - 1;

  // Get beginning current frame's code (as defined by the
  // emitted dwarf code)
  uintptr_t funcStart = _Unwind_GetRegionStart(context);
  uintptr_t pcOffset = pc - funcStart;
  const uint8_t *ClassInfo = nullptr;

  // Note: See JITDwarfEmitter::EmitExceptionTable(...) for corresponding
  //       dwarf emission

  // Parse LSDA header.
  uint8_t lpStartEncoding = *lsda++;

  if (lpStartEncoding != llvm::dwarf::DW_EH_PE_omit) {
    readEncodedPointer(&amp;lsda, lpStartEncoding);
  }

  uint8_t ttypeEncoding = *lsda++;
  uintptr_t classInfoOffset;

  if (ttypeEncoding != llvm::dwarf::DW_EH_PE_omit) {
    // Calculate type info locations in emitted dwarf code which
    // were flagged by type info arguments to llvm.eh.selector
    // intrinsic
    classInfoOffset = readULEB128(&amp;lsda);
    ClassInfo = lsda + classInfoOffset;
  }

  // Walk call-site table looking for range that
  // includes current PC.

  uint8_t callSiteEncoding = *lsda++;
  auto callSiteTableLength = (uint32_t)readULEB128(&amp;lsda);
  const uint8_t *callSiteTableStart = lsda;
  const uint8_t *callSiteTableEnd = callSiteTableStart + callSiteTableLength;
  const uint8_t *actionTableStart = callSiteTableEnd;
  const uint8_t *callSitePtr = callSiteTableStart;

  while (callSitePtr &lt; callSiteTableEnd) {
    uintptr_t start = readEncodedPointer(&amp;callSitePtr, callSiteEncoding);
    uintptr_t length = readEncodedPointer(&amp;callSitePtr, callSiteEncoding);
    uintptr_t landingPad = readEncodedPointer(&amp;callSitePtr, callSiteEncoding);

    // Note: Action value
    uintptr_t actionEntry = readULEB128(&amp;callSitePtr);

    if (exceptionClass != ourBaseExceptionClass) {
      // We have been notified of a foreign exception being thrown,
      // and we therefore need to execute cleanup landing pads
      actionEntry = 0;
    }

    if (landingPad == 0) {
      continue; // no landing pad for this entry
    }

    if (actionEntry) {
      actionEntry += (uintptr_t)actionTableStart - 1;
    }

    bool exceptionMatched = false;

    if ((start &lt;= pcOffset) &amp;&amp; (pcOffset &lt; (start + length))) {
      int64_t actionValue = 0;

      if (actionEntry) {
        exceptionMatched =
            handleActionValue(&amp;actionValue, ttypeEncoding, ClassInfo, actionEntry,
                              exceptionClass, exceptionObject);
      }

      if (!(actions &amp; _UA_SEARCH_PHASE)) {
        // Found landing pad for the PC.
        // Set Instruction Pointer to so we re-enter function
        // at landing pad. The landing pad is created by the
        // compiler to take two parameters in registers.
        _Unwind_SetGR(context, __builtin_eh_return_data_regno(0),
                      (uintptr_t)exceptionObject);

        // Note: this virtual register directly corresponds
        //       to the return of the llvm.eh.selector intrinsic
        if (!actionEntry || !exceptionMatched) {
          // We indicate cleanup only
          _Unwind_SetGR(context, __builtin_eh_return_data_regno(1), 0);
        } else {
          // Matched type info index of llvm.eh.selector intrinsic
          // passed here.
          _Unwind_SetGR(context, __builtin_eh_return_data_regno(1),
                        (uintptr_t)actionValue);
        }

        // To execute landing pad set here
        _Unwind_SetIP(context, funcStart + landingPad);
        ret = _URC_INSTALL_CONTEXT;
      } else if (exceptionMatched) {
        ret = _URC_HANDLER_FOUND;
      }

      break;
    }
  }

  return ret;
}

</t>
<t tx="ekr.20230509083243.1114">SEQ_FUNC _Unwind_Reason_Code seq_personality(int version, _Unwind_Action actions,
                                             uint64_t exceptionClass,
                                             _Unwind_Exception *exceptionObject,
                                             _Unwind_Context *context) {
  const auto *lsda = (uint8_t *)_Unwind_GetLanguageSpecificData(context);
  // The real work of the personality function is captured here
  return handleLsda(version, lsda, actions, exceptionClass, exceptionObject, context);
}

SEQ_FUNC int64_t seq_exc_offset() {
  static OurBaseException_t dummy = {};
  return (int64_t)((uintptr_t)&amp;dummy - (uintptr_t) &amp; (dummy.unwindException));
}

SEQ_FUNC uint64_t seq_exc_class() {
  return genClass(ourBaseExcpClassChars, sizeof(ourBaseExcpClassChars));
}

std::string codon::runtime::makeBacktraceFrameString(uintptr_t pc,
</t>
<t tx="ekr.20230509083243.1115">                                                     const std::string &amp;func,
  @others
</t>
<t tx="ekr.20230509083243.1116">                                                   const std::string &amp;file, int line,
@others
</t>
<t tx="ekr.20230509083243.1117">                                                   int col) {
std::ostringstream buf;
buf &lt;&lt; "[\033[33m0x" &lt;&lt; std::hex &lt;&lt; pc &lt;&lt; std::dec &lt;&lt; "\033[0m]";
if (!func.empty()) {
  buf &lt;&lt; " \033[32m" &lt;&lt; func &lt;&lt; "\033[0m";
  if (!file.empty()) {
    buf &lt;&lt; " at \033[36m" &lt;&lt; file &lt;&lt; "\033[0m";
    if (line != 0) {
      buf &lt;&lt; ":\033[33m" &lt;&lt; line &lt;&lt; "\033[0m";
      if (col != 0) {
        buf &lt;&lt; ":\033[33m" &lt;&lt; col &lt;&lt; "\033[0m";
      }
    }
  }
}
return buf.str();
}

</t>
<t tx="ekr.20230509083243.1118">void codon::runtime::setJITErrorCallback(
    std::function&lt;void(const codon::runtime::JITError &amp;)&gt; callback) {
  jitErrorCallback = callback;
}
</t>
<t tx="ekr.20230509083243.1119">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;

#include "lib.h"

#ifdef CODON_GPU

#include "cuda.h"

#define fail(err)                                                                      \
  do {                                                                                 \
    const char *msg;                                                                   \
    cuGetErrorString((err), &amp;msg);                                                     \
    fprintf(stderr, "CUDA error at %s:%d: %s\n", __FILE__, __LINE__, msg);             \
    abort();                                                                           \
  } while (0)

#define check(call)                                                                    \
  do {                                                                                 \
    auto err = (call);                                                                 \
    if (err != CUDA_SUCCESS) {                                                         \
      fail(err);                                                                       \
    }                                                                                  \
  } while (0)

static std::vector&lt;CUmodule&gt; modules;
static CUcontext context;

@others
SEQ_FUNC CUdeviceptr seq_nvptx_device_alloc(seq_int_t size) {
  if (size == 0)
    return {};

  CUdeviceptr devp;
  check(cuMemAlloc(&amp;devp, size));
  return devp;
}

SEQ_FUNC void seq_nvptx_memcpy_h2d(CUdeviceptr devp, char *hostp, seq_int_t size) {
  if (size)
    check(cuMemcpyHtoD(devp, hostp, size));
}

SEQ_FUNC void seq_nvptx_memcpy_d2h(char *hostp, CUdeviceptr devp, seq_int_t size) {
  if (size)
    check(cuMemcpyDtoH(hostp, devp, size));
}

SEQ_FUNC void seq_nvptx_device_free(CUdeviceptr devp) {
  if (devp)
    check(cuMemFree(devp));
}

#endif /* CODON_GPU */
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.112">void CloneVisitor::visit(const InsertInstr *v) {
  result = Nt(v, clone(v-&gt;getLhs()), v-&gt;getField(), clone(v-&gt;getRhs()));
}

</t>
<t tx="ekr.20230509083243.1120">void seq_nvptx_init() {
  CUdevice device;
  check(cuInit(0));
  check(cuDeviceGet(&amp;device, 0));
  check(cuCtxCreate(&amp;context, 0, device));
}

</t>
<t tx="ekr.20230509083243.1121">SEQ_FUNC void seq_nvptx_load_module(const char *filename) {
  CUmodule module;
  check(cuModuleLoad(&amp;module, filename));
  modules.push_back(module);
}

SEQ_FUNC seq_int_t seq_nvptx_device_count() {
  int devCount;
  check(cuDeviceGetCount(&amp;devCount));
  return devCount;
}

SEQ_FUNC seq_str_t seq_nvptx_device_name(CUdevice device) {
  char name[128];
  check(cuDeviceGetName(name, sizeof(name) - 1, device));
  auto sz = static_cast&lt;seq_int_t&gt;(strlen(name));
  auto *p = (char *)seq_alloc_atomic(sz);
  memcpy(p, name, sz);
  return {sz, p};
}

SEQ_FUNC seq_int_t seq_nvptx_device_capability(CUdevice device) {
  int devMajor, devMinor;
  check(cuDeviceComputeCapability(&amp;devMajor, &amp;devMinor, device));
  return ((seq_int_t)devMajor &lt;&lt; 32) | (seq_int_t)devMinor;
}

SEQ_FUNC CUdevice seq_nvptx_device(seq_int_t idx) {
  CUdevice device;
  check(cuDeviceGet(&amp;device, idx));
  return device;
}

</t>
<t tx="ekr.20230509083243.1122">static bool name_char_valid(char c, bool first) {
  bool ok = ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || (c == '_');
  if (!first)
    ok = ok || ('0' &lt;= c &amp;&amp; c &lt;= '9');
  return ok;
}

</t>
<t tx="ekr.20230509083243.1123">SEQ_FUNC CUfunction seq_nvptx_function(seq_str_t name) {
  CUfunction function;
  CUresult result;

  std::vector&lt;char&gt; clean(name.len + 1);
  for (unsigned i = 0; i &lt; name.len; i++) {
    char c = name.str[i];
    clean[i] = (name_char_valid(c, i == 0) ? c : '_');
  }
  clean[name.len] = '\0';

  for (auto it = modules.rbegin(); it != modules.rend(); ++it) {
    result = cuModuleGetFunction(&amp;function, *it, clean.data());
    if (result == CUDA_SUCCESS) {
      return function;
    } else if (result == CUDA_ERROR_NOT_FOUND) {
      continue;
    } else {
      break;
    }
  }

  fail(result);
  return {};
}

SEQ_FUNC void seq_nvptx_invoke(CUfunction f, unsigned int gridDimX,
</t>
<t tx="ekr.20230509083243.1124">                               unsigned int gridDimY, unsigned int gridDimZ,
                               unsigned int blockDimX, unsigned int blockDimY,
                               unsigned int blockDimZ, unsigned int sharedMemBytes,
                               void **kernelParams) {
  check(cuLaunchKernel(f, gridDimX, gridDimY, gridDimZ, blockDimX, blockDimY, blockDimZ,
                       sharedMemBytes, nullptr, kernelParams, nullptr));
}

</t>
<t tx="ekr.20230509083243.1125">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;cassert&gt;
#include &lt;cerrno&gt;
#include &lt;chrono&gt;
#include &lt;climits&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
#include &lt;ctime&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;mutex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;thread&gt;
#include &lt;unistd.h&gt;
#include &lt;unwind.h&gt;
#include &lt;vector&gt;

#define GC_THREADS
#include "codon/runtime/lib.h"
#include &lt;gc.h&gt;

/*
 * General
 */

// OpenMP patch with GC callbacks
typedef int (*gc_setup_callback)(GC_stack_base *);
typedef void (*gc_roots_callback)(void *, void *);
extern "C" void __kmpc_set_gc_callbacks(gc_setup_callback get_stack_base,
                                        gc_setup_callback register_thread,
                                        gc_roots_callback add_roots,
                                        gc_roots_callback del_roots);

void seq_exc_init();

#ifdef CODON_GPU
void seq_nvptx_init();
#endif

int seq_flags;

SEQ_FUNC void seq_init(int flags) {
  GC_INIT();
  GC_set_warn_proc(GC_ignore_warn_proc);
  GC_allow_register_threads();
  __kmpc_set_gc_callbacks(GC_get_stack_base, (gc_setup_callback)GC_register_my_thread,
                          GC_add_roots, GC_remove_roots);
  seq_exc_init();
#ifdef CODON_GPU
  seq_nvptx_init();
#endif
  seq_flags = flags;
}

SEQ_FUNC bool seq_is_macos() {
#ifdef __APPLE__
  return true;
#else
  return false;
#endif
}

SEQ_FUNC seq_int_t seq_pid() { return (seq_int_t)getpid(); }

SEQ_FUNC seq_int_t seq_time() {
  auto duration = std::chrono::system_clock::now().time_since_epoch();
  seq_int_t nanos =
      std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(duration).count();
  return nanos;
}

SEQ_FUNC seq_int_t seq_time_monotonic() {
  auto duration = std::chrono::steady_clock::now().time_since_epoch();
  seq_int_t nanos =
      std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(duration).count();
  return nanos;
}

SEQ_FUNC seq_int_t seq_time_highres() {
  auto duration = std::chrono::high_resolution_clock::now().time_since_epoch();
  seq_int_t nanos =
      std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(duration).count();
  return nanos;
}

@others
template &lt;typename T&gt; std::string default_format(T n) {
  return fmt::format(FMT_STRING("{}"), n);
}

template &lt;&gt; std::string default_format(double n) {
  return fmt::format(FMT_STRING("{:g}"), n);
}

template &lt;typename T&gt; seq_str_t fmt_conv(T n, seq_str_t format, bool *error) {
  *error = false;
  try {
    if (format.len == 0) {
      return string_conv(default_format(n));
    } else {
      std::string fstr(format.str, format.len);
      return string_conv(
          fmt::format(fmt::runtime(fmt::format(FMT_STRING("{{:{}}}"), fstr)), n));
    }
  } catch (const std::runtime_error &amp;f) {
    *error = true;
    return string_conv(f.what());
  }
}

SEQ_FUNC seq_str_t seq_str_int(seq_int_t n, seq_str_t format, bool *error) {
  return fmt_conv&lt;seq_int_t&gt;(n, format, error);
}

SEQ_FUNC seq_str_t seq_str_uint(seq_int_t n, seq_str_t format, bool *error) {
  return fmt_conv&lt;uint64_t&gt;(n, format, error);
}

SEQ_FUNC seq_str_t seq_str_float(double f, seq_str_t format, bool *error) {
  return fmt_conv&lt;double&gt;(f, format, error);
}

SEQ_FUNC seq_str_t seq_str_ptr(void *p, seq_str_t format, bool *error) {
  return fmt_conv(fmt::ptr(p), format, error);
}

SEQ_FUNC seq_str_t seq_str_str(seq_str_t s, seq_str_t format, bool *error) {
  std::string t(s.str, s.len);
  return fmt_conv(t, format, error);
}

/*
 * General I/O
 */

SEQ_FUNC seq_str_t seq_check_errno() {
  if (errno) {
    std::string msg = strerror(errno);
    auto *buf = (char *)seq_alloc_atomic(msg.size());
    memcpy(buf, msg.data(), msg.size());
    return {(seq_int_t)msg.size(), buf};
  }
  return {0, nullptr};
}

SEQ_FUNC void seq_print(seq_str_t str) { seq_print_full(str, stdout); }

static std::ostringstream capture;
static std::mutex captureLock;

SEQ_FUNC void seq_print_full(seq_str_t str, FILE *fo) {
  if ((seq_flags &amp; SEQ_FLAG_CAPTURE_OUTPUT) &amp;&amp; (fo == stdout || fo == stderr)) {
    captureLock.lock();
    capture.write(str.str, str.len);
    captureLock.unlock();
  } else {
    fwrite(str.str, 1, (size_t)str.len, fo);
  }
}

std::string codon::runtime::getCapturedOutput() {
  std::string result = capture.str();
  capture.str("");
  return result;
}

SEQ_FUNC void *seq_stdin() { return stdin; }

SEQ_FUNC void *seq_stdout() { return stdout; }

SEQ_FUNC void *seq_stderr() { return stderr; }

/*
 * Threading
 */

SEQ_FUNC void *seq_lock_new() {
  return (void *)new (seq_alloc_atomic(sizeof(std::timed_mutex))) std::timed_mutex();
}

SEQ_FUNC bool seq_lock_acquire(void *lock, bool block, double timeout) {
  auto *m = (std::timed_mutex *)lock;
  if (timeout &lt; 0.0) {
    if (block) {
      m-&gt;lock();
      return true;
    } else {
      return m-&gt;try_lock();
    }
  } else {
    return m-&gt;try_lock_for(std::chrono::duration&lt;double&gt;(timeout));
  }
}

SEQ_FUNC void seq_lock_release(void *lock) {
  auto *m = (std::timed_mutex *)lock;
  m-&gt;unlock();
}

SEQ_FUNC void *seq_rlock_new() {
  return (void *)new (seq_alloc_atomic(sizeof(std::recursive_timed_mutex)))
      std::recursive_timed_mutex();
}

SEQ_FUNC bool seq_rlock_acquire(void *lock, bool block, double timeout) {
  auto *m = (std::recursive_timed_mutex *)lock;
  if (timeout &lt; 0.0) {
    if (block) {
      m-&gt;lock();
      return true;
    } else {
      return m-&gt;try_lock();
    }
  } else {
    return m-&gt;try_lock_for(std::chrono::duration&lt;double&gt;(timeout));
  }
}

SEQ_FUNC void seq_rlock_release(void *lock) {
  auto *m = (std::recursive_timed_mutex *)lock;
  m-&gt;unlock();
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1126">static void copy_time_c_to_seq(struct tm *x, seq_time_t *output) {
  output-&gt;year = x-&gt;tm_year;
  output-&gt;yday = x-&gt;tm_yday;
  output-&gt;sec = x-&gt;tm_sec;
  output-&gt;min = x-&gt;tm_min;
  output-&gt;hour = x-&gt;tm_hour;
  output-&gt;mday = x-&gt;tm_mday;
  output-&gt;mon = x-&gt;tm_mon;
  output-&gt;wday = x-&gt;tm_wday;
  output-&gt;isdst = x-&gt;tm_isdst;
}

</t>
<t tx="ekr.20230509083243.1127">static void copy_time_seq_to_c(seq_time_t *x, struct tm *output) {
  output-&gt;tm_year = x-&gt;year;
  output-&gt;tm_yday = x-&gt;yday;
  output-&gt;tm_sec = x-&gt;sec;
  output-&gt;tm_min = x-&gt;min;
  output-&gt;tm_hour = x-&gt;hour;
  output-&gt;tm_mday = x-&gt;mday;
  output-&gt;tm_mon = x-&gt;mon;
  output-&gt;tm_wday = x-&gt;wday;
  output-&gt;tm_isdst = x-&gt;isdst;
}

</t>
<t tx="ekr.20230509083243.1128">SEQ_FUNC bool seq_localtime(seq_int_t secs, seq_time_t *output) {
  struct tm result;
  time_t now = (secs &gt;= 0 ? secs : time(nullptr));
  if (now == (time_t)-1 || !localtime_r(&amp;now, &amp;result))
    return false;
  copy_time_c_to_seq(&amp;result, output);
  return true;
}

SEQ_FUNC bool seq_gmtime(seq_int_t secs, seq_time_t *output) {
  struct tm result;
  time_t now = (secs &gt;= 0 ? secs : time(nullptr));
  if (now == (time_t)-1 || !gmtime_r(&amp;now, &amp;result))
    return false;
  copy_time_c_to_seq(&amp;result, output);
  return true;
}

SEQ_FUNC seq_int_t seq_mktime(seq_time_t *time) {
  struct tm result;
  copy_time_seq_to_c(time, &amp;result);
  return mktime(&amp;result);
}

SEQ_FUNC void seq_sleep(double secs) {
  std::this_thread::sleep_for(std::chrono::duration&lt;double, std::ratio&lt;1&gt;&gt;(secs));
}

extern char **environ;
SEQ_FUNC char **seq_env() { return environ; }

/*
 * GC
 */
#define USE_STANDARD_MALLOC 0

SEQ_FUNC void *seq_alloc(size_t n) {
#if USE_STANDARD_MALLOC
  return malloc(n);
#else
  return GC_MALLOC(n);
#endif
}

SEQ_FUNC void *seq_alloc_atomic(size_t n) {
#if USE_STANDARD_MALLOC
  return malloc(n);
#else
  return GC_MALLOC_ATOMIC(n);
#endif
}

SEQ_FUNC void *seq_alloc_uncollectable(size_t n) {
#if USE_STANDARD_MALLOC
  return malloc(n);
#else
  return GC_MALLOC_UNCOLLECTABLE(n);
#endif
}

SEQ_FUNC void *seq_alloc_atomic_uncollectable(size_t n) {
#if USE_STANDARD_MALLOC
  return malloc(n);
#else
  return GC_MALLOC_ATOMIC_UNCOLLECTABLE(n);
#endif
}

SEQ_FUNC void *seq_calloc(size_t m, size_t n) {
#if USE_STANDARD_MALLOC
  return calloc(m, n);
#else
  size_t s = m * n;
  void *p = GC_MALLOC(s);
  memset(p, 0, s);
  return p;
#endif
}

SEQ_FUNC void *seq_calloc_atomic(size_t m, size_t n) {
#if USE_STANDARD_MALLOC
  return calloc(m, n);
#else
  size_t s = m * n;
  void *p = GC_MALLOC_ATOMIC(s);
  memset(p, 0, s);
  return p;
#endif
}

SEQ_FUNC void *seq_realloc(void *p, size_t newsize, size_t oldsize) {
#if USE_STANDARD_MALLOC
  return realloc(p, newsize);
#else
  return GC_REALLOC(p, newsize);
#endif
}

SEQ_FUNC void seq_free(void *p) {
#if USE_STANDARD_MALLOC
  free(p);
#else
  GC_FREE(p);
#endif
}

SEQ_FUNC void seq_register_finalizer(void *p, void (*f)(void *obj, void *data)) {
#if !USE_STANDARD_MALLOC
  GC_REGISTER_FINALIZER(p, f, nullptr, nullptr, nullptr);
#endif
}

SEQ_FUNC void seq_gc_add_roots(void *start, void *end) {
#if !USE_STANDARD_MALLOC
  GC_add_roots(start, end);
#endif
}

SEQ_FUNC void seq_gc_remove_roots(void *start, void *end) {
#if !USE_STANDARD_MALLOC
  GC_remove_roots(start, end);
#endif
}

SEQ_FUNC void seq_gc_clear_roots() {
#if !USE_STANDARD_MALLOC
  GC_clear_roots();
#endif
}

SEQ_FUNC void seq_gc_exclude_static_roots(void *start, void *end) {
#if !USE_STANDARD_MALLOC
  GC_exclude_static_roots(start, end);
#endif
}

/*
 * String conversion
 */
</t>
<t tx="ekr.20230509083243.1129">static seq_str_t string_conv(const std::string &amp;s) {
  auto n = s.size();
  auto *p = (char *)seq_alloc_atomic(n);
  memcpy(p, s.data(), n);
  return {(seq_int_t)n, p};
}

</t>
<t tx="ekr.20230509083243.113">void CloneVisitor::visit(const CallInstr *v) {
  std::vector&lt;Value *&gt; args;
  for (const auto *a : *v)
    args.push_back(clone(a));
  result = Nt(v, clone(v-&gt;getCallee()), std::move(args));
}

</t>
<t tx="ekr.20230509083243.1130">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;functional&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;unwind.h&gt;

#define SEQ_FLAG_DEBUG (1 &lt;&lt; 0)          // compiled/running in debug mode
#define SEQ_FLAG_CAPTURE_OUTPUT (1 &lt;&lt; 1) // capture writes to stdout/stderr
#define SEQ_FLAG_STANDALONE (1 &lt;&lt; 2)     // compiled as a standalone object/binary

#define SEQ_FUNC extern "C"

typedef int64_t seq_int_t;

struct seq_str_t {
  seq_int_t len;
  char *str;
};

struct seq_time_t {
  int16_t year;
  int16_t yday;
  int8_t sec;
  int8_t min;
  int8_t hour;
  int8_t mday;
  int8_t mon;
  int8_t wday;
  int8_t isdst;
};

SEQ_FUNC int seq_flags;

SEQ_FUNC void seq_init(int flags);

SEQ_FUNC bool seq_is_macos();
SEQ_FUNC seq_int_t seq_pid();
SEQ_FUNC seq_int_t seq_time();
SEQ_FUNC seq_int_t seq_time_monotonic();
SEQ_FUNC seq_int_t seq_time_highres();
SEQ_FUNC bool seq_localtime(seq_int_t secs, seq_time_t *output);
SEQ_FUNC bool seq_gmtime(seq_int_t secs, seq_time_t *output);
SEQ_FUNC seq_int_t seq_mktime(seq_time_t *time);
SEQ_FUNC void seq_sleep(double secs);
SEQ_FUNC char **seq_env();
SEQ_FUNC void seq_assert_failed(seq_str_t file, seq_int_t line);

SEQ_FUNC void *seq_alloc(size_t n);
SEQ_FUNC void *seq_alloc_atomic(size_t n);
SEQ_FUNC void *seq_calloc(size_t m, size_t n);
SEQ_FUNC void *seq_calloc_atomic(size_t m, size_t n);
SEQ_FUNC void *seq_realloc(void *p, size_t newsize, size_t oldsize);
SEQ_FUNC void seq_free(void *p);
SEQ_FUNC void seq_register_finalizer(void *p, void (*f)(void *obj, void *data));

SEQ_FUNC void seq_gc_add_roots(void *start, void *end);
SEQ_FUNC void seq_gc_remove_roots(void *start, void *end);
SEQ_FUNC void seq_gc_clear_roots();
SEQ_FUNC void seq_gc_exclude_static_roots(void *start, void *end);

SEQ_FUNC void *seq_alloc_exc(int type, void *obj);
SEQ_FUNC void seq_throw(void *exc);
SEQ_FUNC _Unwind_Reason_Code seq_personality(int version, _Unwind_Action actions,
                                             uint64_t exceptionClass,
                                             _Unwind_Exception *exceptionObject,
                                             _Unwind_Context *context);
SEQ_FUNC int64_t seq_exc_offset();
SEQ_FUNC uint64_t seq_exc_class();

SEQ_FUNC seq_str_t seq_str_int(seq_int_t n, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_uint(seq_int_t n, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_float(double f, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_ptr(void *p, seq_str_t format, bool *error);
SEQ_FUNC seq_str_t seq_str_str(seq_str_t s, seq_str_t format, bool *error);

SEQ_FUNC void *seq_stdin();
SEQ_FUNC void *seq_stdout();
SEQ_FUNC void *seq_stderr();

SEQ_FUNC void seq_print(seq_str_t str);
SEQ_FUNC void seq_print_full(seq_str_t str, FILE *fo);

SEQ_FUNC void *seq_lock_new();
SEQ_FUNC void *seq_lock_new();
SEQ_FUNC bool seq_lock_acquire(void *lock, bool block, double timeout);
SEQ_FUNC void seq_lock_release(void *lock);
SEQ_FUNC void *seq_rlock_new();
SEQ_FUNC bool seq_rlock_acquire(void *lock, bool block, double timeout);
SEQ_FUNC void seq_rlock_release(void *lock);

namespace codon {
namespace runtime {
@others
std::string makeBacktraceFrameString(uintptr_t pc, const std::string &amp;func = "",
                                     const std::string &amp;file = "", int line = 0,
                                     int col = 0);

std::string getCapturedOutput();

void setJITErrorCallback(std::function&lt;void(const JITError &amp;)&gt; callback);
} // namespace runtime
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1131">class JITError : public std::runtime_error {
private:
  std::string output;
  std::string type;
  std::string file;
  int line;
  int col;
  std::vector&lt;uintptr_t&gt; backtrace;

public:
  JITError(const std::string &amp;output, const std::string &amp;what, const std::string &amp;type,
           const std::string &amp;file, int line, int col,
           std::vector&lt;uintptr_t&gt; backtrace = {})
      : std::runtime_error(what), output(output), type(type), file(file), line(line),
        col(col), backtrace(std::move(backtrace)) {}

  std::string getOutput() const { return output; }
  std::string getType() const { return type; }
  std::string getFile() const { return file; }
  int getLine() const { return line; }
  int getCol() const { return col; }
  std::vector&lt;uintptr_t&gt; getBacktrace() const { return backtrace; }
};

</t>
<t tx="ekr.20230509083243.1132">@path C:/Repos/codon/codon/runtime/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/runtime/lib.h"
#include &lt;cstring&gt;
#include &lt;re2/re2.h&gt;
#include &lt;string&gt;
#include &lt;string_view&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

using Regex = re2::RE2;
using re2::StringPiece;

/*
 * Flags -- (!) must match Codon's
 */

#define ASCII (1 &lt;&lt; 0)
#define DEBUG (1 &lt;&lt; 1)
#define IGNORECASE (1 &lt;&lt; 2)
#define LOCALE (1 &lt;&lt; 3)
#define MULTILINE (1 &lt;&lt; 4)
#define DOTALL (1 &lt;&lt; 5)
#define VERBOSE (1 &lt;&lt; 6)

@others
/*
 * Matching
 */

SEQ_FUNC Span *seq_re_match(Regex *re, seq_int_t anchor, seq_str_t s, seq_int_t pos,
                            seq_int_t endpos) {
  const int num_groups = re-&gt;NumberOfCapturingGroups() + 1; // need $0
  std::vector&lt;StringPiece&gt; groups;
  groups.resize(num_groups);

  if (!re-&gt;Match(str2sp(s), pos, endpos, static_cast&lt;Regex::Anchor&gt;(anchor),
                 groups.data(), groups.size())) {
    // Ensure that groups are null before converting to spans!
    for (auto &amp;it : groups) {
      it = StringPiece();
    }
  }

  auto *spans = (Span *)seq_alloc_atomic(num_groups * sizeof(Span));
  unsigned i = 0;
  for (const auto &amp;it : groups) {
    if (it.data() == nullptr) {
      spans[i++] = {-1, -1};
    } else {
      spans[i++] = {static_cast&lt;seq_int_t&gt;(it.data() - s.str),
                    static_cast&lt;seq_int_t&gt;(it.data() - s.str + it.size())};
    }
  }

  return spans;
}

SEQ_FUNC Span seq_re_match_one(Regex *re, seq_int_t anchor, seq_str_t s, seq_int_t pos,
                               seq_int_t endpos) {
  StringPiece m;
  if (!re-&gt;Match(str2sp(s), pos, endpos, static_cast&lt;Regex::Anchor&gt;(anchor), &amp;m, 1))
    return {-1, -1};
  else
    return {static_cast&lt;seq_int_t&gt;(m.data() - s.str),
            static_cast&lt;seq_int_t&gt;(m.data() - s.str + m.size())};
}

/*
 * General functions
 */

SEQ_FUNC seq_str_t seq_re_escape(seq_str_t p) {
  return convert(Regex::QuoteMeta(str2sp(p)));
}

SEQ_FUNC Regex *seq_re_compile(seq_str_t p, seq_int_t flags) { return get(p, flags); }

SEQ_FUNC void seq_re_purge() { cache.clear(); }

/*
 * Pattern methods
 */

SEQ_FUNC seq_int_t seq_re_pattern_groups(Regex *pattern) {
  return pattern-&gt;NumberOfCapturingGroups();
}

SEQ_FUNC seq_int_t seq_re_group_name_to_index(Regex *pattern, seq_str_t name) {
  const auto &amp;mapping = pattern-&gt;NamedCapturingGroups();
  auto it = mapping.find(std::string(name.str, name.len));
  return (it != mapping.end()) ? it-&gt;second : -1;
}

SEQ_FUNC seq_str_t seq_re_group_index_to_name(Regex *pattern, seq_int_t index) {
  const auto &amp;mapping = pattern-&gt;CapturingGroupNames();
  auto it = mapping.find(index);
  seq_str_t empty = {0, nullptr};
  return (it != mapping.end()) ? convert(it-&gt;second) : empty;
}

SEQ_FUNC bool seq_re_check_rewrite_string(Regex *pattern, seq_str_t rewrite,
                                          seq_str_t *error) {
  std::string e;
  bool ans = pattern-&gt;CheckRewriteString(str2sp(rewrite), &amp;e);
  if (!ans)
    *error = convert(e);
  return ans;
}

SEQ_FUNC seq_str_t seq_re_pattern_error(Regex *pattern) {
  if (pattern-&gt;ok())
    return {0, nullptr};
  return convert(pattern-&gt;error());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1133">static inline Regex::Options flags2opt(seq_int_t flags) {
  Regex::Options opt;
  opt.set_log_errors(false);
  opt.set_encoding(Regex::Options::Encoding::EncodingLatin1);

  if (flags &amp; ASCII) {
    // nothing
  }

  if (flags &amp; DEBUG) {
    // nothing
  }

  if (flags &amp; IGNORECASE) {
    opt.set_case_sensitive(false);
  }

  if (flags &amp; LOCALE) {
    // nothing
  }

  if (flags &amp; MULTILINE) {
    opt.set_one_line(false);
  }

  if (flags &amp; DOTALL) {
    opt.set_dot_nl(true);
  }

  if (flags &amp; VERBOSE) {
    // nothing
  }

  return opt;
}

</t>
<t tx="ekr.20230509083243.1134">/*
 * Internal helpers &amp; utilities
 */

struct Span {
  seq_int_t start;
  seq_int_t end;
};

template &lt;typename KV&gt; struct GCMapAllocator : public std::allocator&lt;KV&gt; {
  GCMapAllocator() = default;
  GCMapAllocator(GCMapAllocator&lt;KV&gt; const &amp;) = default;

</t>
<t tx="ekr.20230509083243.1135">  template &lt;typename KV1&gt;
  GCMapAllocator(const GCMapAllocator&lt;KV1&gt;&amp;) noexcept {}

  KV *allocate(std::size_t n) { return (KV *)seq_alloc(n * sizeof(KV)); }

  void deallocate(KV *p, std::size_t n) { seq_free(p); }

  template &lt;typename U&gt; struct rebind {
    using other = GCMapAllocator&lt;U&gt;;
  };
</t>
<t tx="ekr.20230509083243.1136">};

</t>
<t tx="ekr.20230509083243.1137">static inline seq_str_t convert(const std::string &amp;p) {
  seq_int_t n = p.size();
  auto *s = (char *)seq_alloc_atomic(n);
  std::memcpy(s, p.data(), n);
  return {n, s};
}

</t>
<t tx="ekr.20230509083243.1138">static inline StringPiece str2sp(const seq_str_t &amp;s) {
  return StringPiece(s.str, s.len);
}

</t>
<t tx="ekr.20230509083243.1139">using Key = std::pair&lt;seq_str_t, seq_int_t&gt;;

struct KeyEqual {
</t>
<t tx="ekr.20230509083243.114">void CloneVisitor::visit(const StackAllocInstr *v) {
  result = Nt(v, v-&gt;getArrayType(), v-&gt;getCount());
}

</t>
<t tx="ekr.20230509083243.1140">  bool operator()(const Key &amp;a, const Key &amp;b) const {
    return a.second == b.second &amp;&amp; str2sp(a.first) == str2sp(b.first);
  }
</t>
<t tx="ekr.20230509083243.1141">};

struct KeyHash {
  std::size_t operator()(const Key &amp;k) const {
    using sv = std::string_view;
    return std::hash&lt;sv&gt;()(sv(k.first.str, k.first.len)) ^ k.second;
  }
};

</t>
<t tx="ekr.20230509083243.1142">static thread_local std::unordered_map&lt;const Key, Regex, KeyHash, KeyEqual,
                                       GCMapAllocator&lt;std::pair&lt;const Key, Regex&gt;&gt;&gt;
    cache;

  @others
</t>
<t tx="ekr.20230509083243.1143">static inline Regex *get(const seq_str_t &amp;p, seq_int_t flags) {
auto key = std::make_pair(p, flags);
auto it = cache.find(key);
if (it == cache.end()) {
  auto result = cache.emplace(std::piecewise_construct, std::forward_as_tuple(key),
                              std::forward_as_tuple(str2sp(p), flags2opt(flags)));
  return &amp;result.first-&gt;second;
} else {
  return &amp;it-&gt;second;
}
}

</t>
<t tx="ekr.20230509083243.1144"></t>
<t tx="ekr.20230509083243.1145">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "common.h"

#include "llvm/Support/Path.h"
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {
namespace {
@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1146">void compilationMessage(const std::string &amp;header, const std::string &amp;msg,
  @others
</t>
<t tx="ekr.20230509083243.1147">                      const std::string &amp;file, int line, int col, int len,
@others
</t>
<t tx="ekr.20230509083243.1148">                      int errorCode, MessageGroupPos pos) {
auto &amp;out = getLogger().err;
seqassertn(!(file.empty() &amp;&amp; (line &gt; 0 || col &gt; 0)),
           "empty filename with non-zero line/col: file={}, line={}, col={}", file,
           line, col);
seqassertn(!(col &gt; 0 &amp;&amp; line &lt;= 0), "col but no line: file={}, line={}, col={}", file,
           line, col);

switch (pos) {
case MessageGroupPos::NONE:
  break;
case MessageGroupPos::HEAD:
  break;
case MessageGroupPos::MID:
  fmt::print(" ");
  break;
case MessageGroupPos::LAST:
  fmt::print(" ");
  break;
}

fmt::print(out, "\033[1m");
if (!file.empty()) {
  auto f = file.substr(file.rfind('/') + 1);
  fmt::print(out, "{}", f == "-" ? "&lt;stdin&gt;" : f);
}
if (line &gt; 0)
  fmt::print(out, ":{}", line);
if (col &gt; 0)
  fmt::print(out, ":{}", col);
if (len &gt; 0)
  fmt::print(out, "-{}", col + len);
if (!file.empty())
  fmt::print(out, ": ");
fmt::print(out, "{}\033[1m {}\033[0m{}\n", header, msg,
           errorCode != -1
               ? fmt::format(" (see https://exaloop.io/error/{:04d})", errorCode)
               : "");
}

</t>
<t tx="ekr.20230509083243.1149">std::vector&lt;Logger&gt; loggers;
} // namespace

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const codon::SrcInfo &amp;src) {
  out &lt;&lt; llvm::sys::path::filename(src.file).str() &lt;&lt; ":" &lt;&lt; src.line &lt;&lt; ":" &lt;&lt; src.col;
  return out;
}

</t>
<t tx="ekr.20230509083243.115">void CloneVisitor::visit(const TypePropertyInstr *v) {
  result = Nt(v, v-&gt;getInspectType(), v-&gt;getProperty());
}

</t>
<t tx="ekr.20230509083243.1150">void compilationError(const std::string &amp;msg, const std::string &amp;file, int line,
                      int col, int len, int errorCode, bool terminate,
                      MessageGroupPos pos) {
  compilationMessage("\033[1;31merror:\033[0m", msg, file, line, col, len, errorCode,
                     pos);
  if (terminate)
    exit(EXIT_FAILURE);
}

</t>
<t tx="ekr.20230509083243.1151">void compilationWarning(const std::string &amp;msg, const std::string &amp;file, int line,
                        int col, int len, int errorCode, bool terminate,
                        MessageGroupPos pos) {
  compilationMessage("\033[1;33mwarning:\033[0m", msg, file, line, col, len, errorCode,
                     pos);
  if (terminate)
    exit(EXIT_FAILURE);
}

</t>
<t tx="ekr.20230509083243.1152">void Logger::parse(const std::string &amp;s) {
  flags |= s.find('t') != std::string::npos ? FLAG_TIME : 0;
  flags |= s.find('r') != std::string::npos ? FLAG_REALIZE : 0;
  flags |= s.find('T') != std::string::npos ? FLAG_TYPECHECK : 0;
  flags |= s.find('i') != std::string::npos ? FLAG_IR : 0;
  flags |= s.find('l') != std::string::npos ? FLAG_USER : 0;
}
</t>
<t tx="ekr.20230509083243.1153">} // namespace codon

codon::Logger &amp;codon::getLogger() {
  if (loggers.empty())
    loggers.emplace_back();
  return loggers.back();
}

void codon::pushLogger() { loggers.emplace_back(); }

</t>
<t tx="ekr.20230509083243.1154">bool codon::popLogger() {
  if (loggers.empty())
    return false;
  loggers.pop_back();
  return true;
}

</t>
<t tx="ekr.20230509083243.1155">void codon::assertionFailure(const char *expr_str, const char *file, int line,
                             const std::string &amp;msg) {
  auto &amp;out = getLogger().err;
  out &lt;&lt; "Assert failed:\t" &lt;&lt; msg &lt;&lt; "\n"
      &lt;&lt; "Expression:\t" &lt;&lt; expr_str &lt;&lt; "\n"
      &lt;&lt; "Source:\t\t" &lt;&lt; file &lt;&lt; ":" &lt;&lt; line &lt;&lt; "\n";
  abort();
}
</t>
<t tx="ekr.20230509083243.1156">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;chrono&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;
#include &lt;fmt/ranges.h&gt;
#include &lt;fmt/std.h&gt;
#include &lt;iostream&gt;
#include &lt;ostream&gt;

#include "codon/compiler/error.h"
#include "codon/config/config.h"
#include "codon/parser/ast/error.h"

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgnu-zero-variadic-macro-arguments"

#define DBG(c, ...)                                                                    \
  fmt::print(codon::getLogger().log, "{}" c "\n",                                      \
             std::string(2 * codon::getLogger().level, ' '), ##__VA_ARGS__)
#define LOG(c, ...) DBG(c, ##__VA_ARGS__)
#define LOG_TIME(c, ...)                                                               \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_TIME)                           \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_REALIZE(c, ...)                                                            \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_REALIZE)                        \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_TYPECHECK(c, ...)                                                          \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_TYPECHECK)                      \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_IR(c, ...)                                                                 \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_IR)                             \
      DBG(c, ##__VA_ARGS__);                                                           \
  }
#define LOG_USER(c, ...)                                                               \
  {                                                                                    \
    if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER)                           \
      DBG(c, ##__VA_ARGS__);                                                           \
  }

#define TIME(name) codon::Timer __timer(name)

#ifndef NDEBUG
#define seqassertn(expr, msg, ...)                                                     \
  ((expr) ? (void)(0)                                                                  \
          : codon::assertionFailure(#expr, __FILE__, __LINE__,                         \
                                    fmt::format(msg, ##__VA_ARGS__)))
#define seqassert(expr, msg, ...)                                                      \
  ((expr) ? (void)(0)                                                                  \
          : codon::assertionFailure(                                                   \
                #expr, __FILE__, __LINE__,                                             \
                fmt::format(msg " [{}]", ##__VA_ARGS__, getSrcInfo())))
#else
#define seqassertn(expr, msg, ...) ;
#define seqassert(expr, msg, ...) ;
#endif
#pragma clang diagnostic pop

namespace codon {

@others
enum MessageGroupPos {
  NONE = 0,
  HEAD,
  MID,
  LAST,
};

void compilationError(const std::string &amp;msg, const std::string &amp;file = "",
                      int line = 0, int col = 0, int len = 0, int errorCode = -1,
                      bool terminate = true, MessageGroupPos pos = NONE);

void compilationWarning(const std::string &amp;msg, const std::string &amp;file = "",
                        int line = 0, int col = 0, int len = 0, int errorCode = -1,
                        bool terminate = false, MessageGroupPos pos = NONE);

} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::SrcInfo&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1157">void assertionFailure(const char *expr_str, const char *file, int line,
                      const std::string &amp;msg);

struct Logger {
  static constexpr int FLAG_TIME = (1 &lt;&lt; 0);
  static constexpr int FLAG_REALIZE = (1 &lt;&lt; 1);
  static constexpr int FLAG_TYPECHECK = (1 &lt;&lt; 2);
  static constexpr int FLAG_IR = (1 &lt;&lt; 3);
  static constexpr int FLAG_USER = (1 &lt;&lt; 4);

  int flags;
  int level;
  std::ostream &amp;out;
  std::ostream &amp;err;
  std::ostream &amp;log;

  Logger() : flags(0), level(0), out(std::cout), err(std::cerr), log(std::clog) {}

  void parse(const std::string &amp;logs);
};

</t>
<t tx="ekr.20230509083243.1158">Logger &amp;getLogger();
void pushLogger();
bool popLogger();

</t>
<t tx="ekr.20230509083243.1159">class Timer {
private:
  using clock_type = std::chrono::high_resolution_clock;
  std::string name;
  std::chrono::time_point&lt;clock_type&gt; start, end;

public:
  bool logged;

public:
@others
  Timer(std::string name) : name(std::move(name)), start(), end(), logged(false) {
    start = clock_type::now();
  }

  ~Timer() { log(); }
};

</t>
<t tx="ekr.20230509083243.116">void CloneVisitor::visit(const YieldInInstr *v) {
  result = Nt(v, v-&gt;getType(), v-&gt;isSuspending());
}

</t>
<t tx="ekr.20230509083243.1160">  void log() {
    if (!logged) {
      LOG_TIME("[T] {} = {:.3f}", name, elapsed());
      logged = true;
    }
  }

</t>
<t tx="ekr.20230509083243.1161">  double elapsed(std::chrono::time_point&lt;clock_type&gt; end = clock_type::now()) const {
    return std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count() /
           1000.0;
  }

</t>
<t tx="ekr.20230509083243.1162">std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const codon::SrcInfo &amp;src);

struct SrcObject {
private:
  SrcInfo info;

public:
  SrcObject() : info() {}
  SrcObject(const SrcObject &amp;s) { setSrcInfo(s.getSrcInfo()); }

  virtual ~SrcObject() = default;

  SrcInfo getSrcInfo() const { return info; }

  void setSrcInfo(SrcInfo info) { this-&gt;info = std::move(info); }
};
template &lt;class... TA&gt; void E(error::Error e, codon::SrcObject *o, const TA &amp;...args) {
  E(e, o-&gt;getSrcInfo(), args...);
}
</t>
<t tx="ekr.20230509083243.1163">template &lt;class... TA&gt;
void E(error::Error e, const codon::SrcObject &amp;o, const TA &amp;...args) {
  E(e, o.getSrcInfo(), args...);
}
</t>
<t tx="ekr.20230509083243.1164">template &lt;class... TA&gt;
void E(error::Error e, const std::shared_ptr&lt;SrcObject&gt; &amp;o, const TA &amp;...args) {
  E(e, o-&gt;getSrcInfo(), args...);
}

</t>
<t tx="ekr.20230509083243.1165">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/util/jupyter.h"
#include &lt;cstdio&gt;

namespace codon {
@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1166">int startJupyterKernel(const std::string &amp;argv0,
                       const std::vector&lt;std::string&gt; &amp;plugins,
                       const std::string &amp;configPath) {
  fprintf(stderr,
          "Jupyter support not included. Please install Codon Jupyter plugin.\n");
  return EXIT_FAILURE;
}

</t>
<t tx="ekr.20230509083243.1167">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {
int startJupyterKernel(const std::string &amp;argv0,
                       const std::vector&lt;std::string&gt; &amp;plugins,
                       const std::string &amp;configPath);
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1168">@path C:/Repos/codon/codon/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;algorithm&gt;
#include &lt;any&gt;
#include &lt;cassert&gt;
#include &lt;cctype&gt;
#include &lt;cstring&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;initializer_list&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt;
#include &lt;list&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;peglib.h&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#define FMT_HEADER_ONLY
#include &lt;fmt/format.h&gt;

using namespace std;

string escape(const string &amp;str) {
  string r;
  for (unsigned char c : str) {
    switch (c) {
    case '\n':
      r += "\\\\n";
      break;
    case '\r':
      r += "\\\\r";
      break;
    case '\t':
      r += "\\\\t";
      break;
    case '\\':
      r += "\\\\";
      break;
    case '"':
      r += "\\\"";
      break;
    default:
      if (c &lt; 32 || c &gt;= 127)
        r += fmt::format("\\\\x{:x}", c);
      else
        r += c;
    }
  }
  return r;
}
template &lt;typename T&gt;
string join(const T &amp;items, const string &amp;delim = " ", int start = 0, int end = -1) {
  string s;
  if (end == -1)
    end = items.size();
  for (int i = start; i &lt; end; i++)
    s += (i &gt; start ? delim : "") + items[i];
  return s;
}

// const string PREDICATE = ".predicate";
// bool is_predicate(const std::string &amp;name) {
//   return (name.size() &gt; PREDICATE.size() &amp;&amp; name.substr(name.size() -
//   PREDICATE.size()) == PREDICATE);
// }

class PrintVisitor : public peg::Ope::Visitor {
  vector&lt;string&gt; v;

public:
  static string parse(const shared_ptr&lt;peg::Ope&gt; &amp;op) {
    PrintVisitor v;
    op-&gt;accept(v);
    if (v.v.size()) {
      if (v.v[0].empty())
        return fmt::format("P[\"{}\"]", v.v[1]);
      else
        return fmt::format("{}({})", v.v[0], join(v.v, ", ", 1));
    }
    return "-";
  };

private:
  void visit(peg::Sequence &amp;s) override {
    v = {"seq"};
    for (auto &amp;o : s.opes_)
      v.push_back(parse(o));
  }
  void visit(peg::PrioritizedChoice &amp;s) override {
    v = {"cho"};
    for (auto &amp;o : s.opes_)
      v.push_back(parse(o));
  }
  void visit(peg::Repetition &amp;s) override {
    if (s.is_zom())
      v = {"zom", parse(s.ope_)};
    else if (s.min_ == 1 &amp;&amp; s.max_ == std::numeric_limits&lt;size_t&gt;::max())
      v = {"oom", parse(s.ope_)};
    else if (s.min_ == 0 &amp;&amp; s.max_ == 1)
      v = {"opt", parse(s.ope_)};
    else
      v = {"rep", parse(s.ope_), to_string(s.min_), to_string(s.max_)};
  }
  void visit(peg::AndPredicate &amp;s) override { v = {"apd", parse(s.ope_)}; }
  void visit(peg::NotPredicate &amp;s) override { v = {"npd", parse(s.ope_)}; }
  void visit(peg::LiteralString &amp;s) override {
    v = {s.ignore_case_ ? "liti" : "lit", fmt::format("\"{}\"", escape(s.lit_))};
  }
  void visit(peg::CharacterClass &amp;s) override {
    vector&lt;string&gt; sv;
    for (auto &amp;c : s.ranges_)
      sv.push_back(fmt::format("{{0x{:x}, 0x{:x}}}", (int)c.first, (int)c.second));
    v = {s.negated_ ? "ncls" : "cls", "vc{" + join(sv, ",") + "}"};
  }
  void visit(peg::Character &amp;s) override { v = {"chr", fmt::format("'{}'", s.ch_)}; }
  void visit(peg::AnyCharacter &amp;s) override { v = {"dot"}; }
  void visit(peg::Cut &amp;s) override { v = {"cut"}; }
  void visit(peg::Reference &amp;s) override {
    if (s.is_macro_) {
      vector&lt;string&gt; vs;
      for (auto &amp;o : s.args_)
        vs.push_back(parse(o));
      v = {"ref",  "P",    fmt::format("\"{}\"", s.name_),
           "\"\"", "true", "{" + join(vs, ", ") + "}"};
    } else {
      v = {"ref", "P", fmt::format("\"{}\"", s.name_)};
    }
  }
  void visit(peg::TokenBoundary &amp;s) override { v = {"tok", parse(s.ope_)}; }
  void visit(peg::Ignore &amp;s) override { v = {"ign", parse(s.ope_)}; }
  void visit(peg::Recovery &amp;s) override { v = {"rec", parse(s.ope_)}; }
  // infix TODO
};

int main(int argc, char **argv) {
  peg::parser parser;
  fmt::print("Generating grammar from {}\n", argv[1]);
  ifstream ifs(argv[1]);
  string g((istreambuf_iterator&lt;char&gt;(ifs)), istreambuf_iterator&lt;char&gt;());
  ifs.close();

  string start;
  peg::Rules dummy = {};
  if (string(argv[3]) == "codon")
    dummy["NLP"] = peg::usr([](const char *, size_t, peg::SemanticValues &amp;,
                               any &amp;) -&gt; size_t { return -1; });
  bool enablePackratParsing;
  string preamble;
  peg::Log log = [](size_t line, size_t col, const string &amp;msg, const string &amp;rule) {
    cerr &lt;&lt; line &lt;&lt; ":" &lt;&lt; col &lt;&lt; ": " &lt;&lt; msg &lt;&lt; " (" &lt;&lt; rule &lt;&lt; ")\n";
  };
  auto grammar = peg::ParserGenerator::get_instance().perform_core(
      g.c_str(), g.size(), dummy, start, enablePackratParsing, preamble, log);
  assert(grammar);

  string rules, actions, actionFns;
  string action_preamble = "  auto &amp;CTX = any_cast&lt;ParseContext &amp;&gt;(DT);\n";
  string const_action_preamble =
      "  const auto &amp;CTX = any_cast&lt;const ParseContext &amp;&gt;(DT);\n";
  string loc_preamble = "  const auto &amp;LI = VS.line_info();\n"
                        "  auto LOC = codon::SrcInfo(\n"
                        "    VS.path, LI.first + CTX.line_offset,\n"
                        "    LI.second + CTX.col_offset,\n"
                        "    VS.sv().size());\n";

  for (auto &amp;[name, def] : *grammar) {
    auto op = def.get_core_operator();
    if (dummy.find(name) != dummy.end())
      continue;

    rules += fmt::format("  {}P[\"{}\"] &lt;= {};\n", def.ignoreSemanticValue ? "~" : "",
                         name, PrintVisitor::parse(op));
    rules += fmt::format("  P[\"{}\"].name = \"{}\";\n", name, escape(name));
    if (def.is_macro)
      rules += fmt::format("  P[\"{}\"].is_macro = true;\n", name);
    if (!def.enable_memoize)
      rules += fmt::format("  P[\"{}\"].enable_memoize = false;\n", name);
    if (!def.params.empty()) {
      vector&lt;string&gt; params;
      for (auto &amp;p : def.params)
        params.push_back(fmt::format("\"{}\"", escape(p)));
      rules += fmt::format("  P[\"{}\"].params = {{{}}};\n", name, join(params, ", "));
    }

    string code = op-&gt;code;
    if (code.empty()) {
      bool all_empty = true;
      if (auto ope = dynamic_cast&lt;peg::PrioritizedChoice *&gt;(op.get())) {
        for (int i = 0; i &lt; ope-&gt;opes_.size(); i++)
          if (!ope-&gt;opes_[i]-&gt;code.empty()) {
            code +=
                fmt::format("  if (VS.choice() == {}) {}\n", i, ope-&gt;opes_[i]-&gt;code);
            all_empty = false;
          } else {
            code += fmt::format("  if (VS.choice() == {}) return V0;\n", i);
          }
      }
      if (all_empty)
        code = "";
      if (!code.empty())
        code = "{\n" + code + "}";
    }
    if (!code.empty()) {
      code = code.substr(1, code.size() - 2);
      if (code.find("LOC") != std::string::npos)
        code = loc_preamble + code;
      if (code.find("CTX") != std::string::npos)
        code = action_preamble + code;
      actions += fmt::format("P[\"{}\"] = fn_{};\n", name, name);
      actionFns += fmt::format(
          "auto fn_{}(peg::SemanticValues &amp;VS, any &amp;DT) {{\n{}\n}};\n", name, code);
    }
    if (!(code = def.predicate_code).empty()) {
      code = code.substr(1, code.size() - 2);
      if (code.find("LOC") != std::string::npos)
        code = loc_preamble + code;
      if (code.find("CTX") != std::string::npos)
        code = const_action_preamble + code;
      actions += fmt::format("P[\"{}\"].predicate = pred_{};\n", name, name);
      actionFns += fmt::format("auto pred_{}(const peg::SemanticValues &amp;VS, const any "
                               "&amp;DT, std::string &amp;MSG) {{\n{}\n}};\n",
                               name, code);
    }
  };

  FILE *fout = fopen(argv[2], "w");
  fmt::print(fout, "// clang-format off\n");
  fmt::print(fout, "#pragma clang diagnostic push\n");
  fmt::print(fout, "#pragma clang diagnostic ignored \"-Wreturn-type\"\n");
  if (!preamble.empty())
    fmt::print(fout, "{}\n", preamble.substr(1, preamble.size() - 2));
  string rules_preamble = "  using namespace peg;\n"
                          "  using peg::seq;\n"
                          "  using vc = vector&lt;pair&lt;char32_t, char32_t&gt;&gt;;\n";
  fmt::print(fout, "void init_{}_rules(peg::Grammar &amp;P) {{\n{}\n{}\n}}\n", argv[3],
             rules_preamble, rules);
  fmt::print(fout, "{}\n", actionFns);
  fmt::print(fout, "void init_{}_actions(peg::Grammar &amp;P) {{\n  {}\n}}\n", argv[3],
             actions);
  fmt::print(fout, "// clang-format on\n");
  fmt::print(fout, "#pragma clang diagnostic pop\n");
  fclose(fout);

  return 0;
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1169"></t>
<t tx="ekr.20230509083243.117">void CloneVisitor::visit(const TernaryInstr *v) {
  result =
      Nt(v, clone(v-&gt;getCond()), clone(v-&gt;getTrueValue()), clone(v-&gt;getFalseValue()));
}

</t>
<t tx="ekr.20230509083243.1170">@path C:/Repos/codon/docs/
#%%
import json
import itertools
import os
import os.path
import sys
import subprocess as sp
import collections
from pprint import pprint

from sphinxcontrib.napoleon.docstring import GoogleDocstring
from sphinxcontrib.napoleon import Config

napoleon_config=Config(napoleon_use_param=True,napoleon_use_rtype=True)

root=os.path.abspath(sys.argv[1])
print(f"Generating documentation for {root}...")


@others
# 3. Create documentation for each module
for directory,(name,mid) in {(d,m) for d,mm in parsed_modules.items() for m in mm}:
    module=directory.replace('/','.')+f".{name}"

    file,mode=f'stdlib/{directory}/{name}.rst','w'
    if os.path.isdir(f'{root}/{directory}/{name}'):
        continue
    if name=='__init__':
        file,mode=f'stdlib/{directory}/index.rst','a'
    with open(file,mode) as f:
        print(f".. codon:module:: {module}\n",file=f)
        print(f":codon:mod:`{module}`",file=f)
        print("-"*(len(module)+13)+"\n",file=f)
        directory_prefix=directory+'/' if directory!='.' else ''
        print(f"Source code: `{directory_prefix}{name}.codon &lt;https://github.com/exaloop/codon/blob/master/stdlib/{directory}/{name}.codon&gt;`_\n",file=f)
        if 'doc' in j[mid]:
            print(parse_docstr(j[mid]['doc']),file=f)

        for i in j[mid]['children']:
            v=j[i]

            if v['kind']=='class' and v['type']=='extension':
                v['name']=j[v['parent']]['name']
            if v['name'].startswith('_'):
                continue

            if v['kind']=='class':
                if v['name'].endswith('Error'):
                    v["type"]="exception"
                f.write(f'.. codon:{v["type"]}:: {v["name"]}')
                if 'generics' in v and v['generics']:
                    f.write(f'[{",".join(v["generics"])}]')
            elif v['kind']=='function':
                f.write(f'.. codon:function:: {v["name"]}{parse_fn(v)}')
            elif v['kind']=='variable':
                f.write(f'.. codon:data:: {v["name"]}')
            # if v['kind'] == 'class' and v['type'] == 'extension':
            #     f.write(f'**`{getLink(v["parent"])}`**')
            # else:
            # f.write(f'{m}.**`{v["name"]}`**')
            f.write("\n")

            # f.write("\n")
            # if v['kind'] == 'function' and 'attrs' in v and v['attrs']:
            #     f.write("**Attributes:**" + ', '.join(f'`{x}`' for x in v['attrs']))
            #     f.write("\n")
            if 'doc' in v:
                f.write("\n"+parse_docstr(v['doc'])+"\n")
            f.write("\n")

            if v['kind']=='class':
                # if 'args' in v and any(c['name'][0] != '_' for c in v['args']):
                #     f.write('#### Arguments:\n')
                #     for c in v['args']:
                #         if c['name'][0] == '_':
                #             continue
                #         f.write(f'- **`{c["name"]} : `**')
                #         f.write(parse_type(c["type"]) + "\n")
                #         if 'doc' in c:
                #             f.write(parse_docstr(c['doc'], 1) + "\n")
                #         f.write("\n")

                mt=[c for c in v['members'] if j[c]['kind']=='function']

                props=[c for c in mt if 'property' in j[c].get('attrs',[])]
                if props:
                    print('   **Properties:**\n',file=f)
                    for c in props:
                        v=j[c]
                        f.write(f'      .. codon:attribute:: {v["name"]}\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")

                magics=[c for c in mt if len(j[c]['name'])&gt;4 and j[c]['name'].startswith('__') and j[c]['name'].endswith('__')]
                if magics:
                    print('   **Magic methods:**\n',file=f)
                    for c in magics:
                        v=j[c]
                        f.write(f'      .. codon:method:: {v["name"]}{parse_fn(v,True)}\n')
                        f.write('         :noindex:\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")
                methods=[c for c in mt if j[c]['name'][0]!='_' and c not in props]
                if methods:
                    print('   **Methods:**\n',file=f)
                    for c in methods:
                        v=j[c]
                        f.write(f'      .. codon:method:: {v["name"]}{parse_fn(v,True)}\n')
                        if 'doc' in v:
                            f.write("\n"+parse_docstr(v['doc'],4)+"\n\n")
                        f.write("\n")
            f.write("\n\n")

        f.write("\n\n")
print(f" - Done with modules")
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1171"># 1. Call codon -docstr and get a documentation in JSON format
def load_json(directory):
    # Get all codon files in the directory
    files=[]
    for root,_,items in os.walk(directory):
        for f in items:
            if f.endswith('.codon') and "__init_test__.codon" not in f:
                files.append(os.path.abspath(os.path.join(root,f)))
    files='\n'.join(files)
    s=sp.run(['../../build/codon','doc'],stdout=sp.PIPE,input=files.encode('utf-8'))
    if s.returncode!=0:
        raise ValueError('codon failed')
    return json.loads(s.stdout.decode('utf-8'))


</t>
<t tx="ekr.20230509083243.1172">j=load_json(root)
print(f" - Done with codon")
sys.exit(0)
# with open('x.json','w') as f:
#     json.dump(j,f,indent=2)

# 2. Get the list of modules and create the documentation tree
modules={k:v["path"] for k,v in j.items() if v["kind"]=="module"}
prefix=os.path.commonprefix(list(modules.values()))
parsed_modules=collections.defaultdict(set)
os.system("rm -rf stdlib/*")
for mid,module in modules.items():
    while module!=root:
        directory,name=os.path.split(module)
        print(root,mid,module)
        directory=os.path.relpath(directory,root)  # remove the prefix
        os.makedirs(f"stdlib/{directory}",exist_ok=True)
        if name.endswith('.codon'):
            name=name[:-6] # drop suffix
        if name!='__init__':
            parsed_modules[directory].add((name,mid))
        module=os.path.split(module)[0]
for directory,modules in parsed_modules.items():
    module=directory.replace('/','.')
    with open(f'stdlib/{directory}/index.rst','w') as f:
        if module!='.':
            print(f".. codon:module:: {module}\n",file=f)
            print(f"{module}",file=f)
        else:
            print("Standard Library Reference",file=f)
        print(f"========\n",file=f)

        print(".. toctree::\n",file=f)
        for m in sorted(set(m for m,_ in modules)):
            if os.path.isdir(f'{root}/{directory}/{m}'):
                print(f"   {m}/index",file=f)
            else:
                print(f"   {m}",file=f)
print(f" - Done with directory tree")


</t>
<t tx="ekr.20230509083243.1173">def parse_docstr(s,level=1):
    """Parse docstr s and indent it with level spaces"""
    lines=GoogleDocstring(s,napoleon_config).lines()
    if isinstance(lines,str):  # Napoleon failed
        s=s.split('\n')
        while s and s[0]=='':
            s=s[1:]
        while s and s[-1]=='':
            s=s[:-1]
        if not s:
            return ''
        i=0
        indent=len(list(itertools.takewhile(lambda i:i==' ',s[0])))
        lines=[l[indent:] for l in s]
    return '\n'.join(('   '*level)+l for l in lines)


</t>
<t tx="ekr.20230509083243.1174">def parse_type(a):
    """Parse type signature"""
    s=''
    if isinstance(a,list):
        head,tail=a[0],a[1:]
    else:
        head,tail=a,[]
    s+=j[head]["name"] if head[0].isdigit() else head
    if tail:
        for ti,t in enumerate(tail):
            s+="[" if not ti else ", "
            s+=parse_type(t)
        s+="]"
    return s


</t>
<t tx="ekr.20230509083243.1175">def parse_fn(v,skip_self=False,skip_braces=False):
    """Parse function signature after the name"""
    s=""
    if 'generics' in v and v['generics']:
        s+=f'[{", ".join(v["generics"])}]'
    if not skip_braces:
        s+="("
    cnt=0
    for ai,a in enumerate(v['args']):
        if ai==0 and a["name"]=="self" and skip_self:
            continue
        s+="" if not cnt else ", "
        cnt+=1
        s+=f'{a["name"]}'
        if "type" in a:
            s+=" : "+parse_type(a["type"])
        if "default" in a:
            s+=" = "+a["default"]+""
    if not skip_braces:
        s+=')'
    if "ret" in v:
        s+=" -&gt; "+parse_type(v["ret"])
    # if "extern" in v:
    #     s += f" (_{v['extern']} function_)"
    # s += "\n"
    return s


</t>
<t tx="ekr.20230509083243.118">void CloneVisitor::visit(const BreakInstr *v) {
  result = Nt(v, cloneLoop ? clone(v-&gt;getLoop()) : v-&gt;getLoop());
}

</t>
<t tx="ekr.20230509083243.1181"></t>
<t tx="ekr.20230509083243.1182"></t>
<t tx="ekr.20230509083243.1183">@path C:/Repos/codon/extra/python/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

import os
import sys
import shutil
import subprocess
from pathlib import Path
from Cython.Distutils import build_ext
from setuptools import setup
from setuptools.extension import Extension

exec(open("codon/version.py").read())

ext = "dylib" if sys.platform == "darwin" else "so"

codon_path = os.environ.get("CODON_DIR")
if not codon_path:
    c = shutil.which("codon")
    if c:
        codon_path = Path(c).parent / ".."
else:
    codon_path = Path(codon_path)
for path in [
    os.path.expanduser("~") + "/.codon",
    os.getcwd() + "/..",
]:
    path = Path(path)
    if not codon_path and path.exists():
        codon_path = path
        break

if (
    not codon_path
    or not (codon_path / "include" / "codon").exists()
    or not (codon_path / "lib" / "codon").exists()
):
    print(
        "Cannot find Codon.",
        'Please either install Codon (/bin/bash -c "$(curl -fsSL https://exaloop.io/install.sh)"),',
        "or set CODON_DIR if Codon is not in PATH or installed in ~/.codon",
        file=sys.stderr,
    )
    sys.exit(1)
codon_path = codon_path.resolve()
print("Codon: " + str(codon_path))


if sys.platform == "darwin":
    libraries=["codonrt", "codonc"]
    linker_args = ["-Wl,-rpath," + str(codon_path / "lib" / "codon")]
else:
    libraries=["codonrt"]
    linker_args = [
        "-Wl,-rpath=" + str(codon_path / "lib" / "codon"),
        "-Wl,--no-as-needed",
        "-lcodonc",
    ]

    # TODO: handle ABI changes better
    out = subprocess.check_output(["nm", "-g", str(codon_path / "lib" / "codon" / "libcodonc.so")])
    out = [i for i in out.decode(sys.stdout.encoding).split("\n") if "jitExecuteSafe" in i]
    if out and "cxx11" not in out[0]:
        print("CXX11 ABI not detected")
        os.environ["CFLAGS"] = os.environ.get("CFLAGS", "") + " -D_GLIBCXX_USE_CXX11_ABI=0"

jit_extension = Extension(
    "codon.codon_jit",
    sources=["codon/jit.pyx", "codon/jit.pxd"],
    libraries=libraries,
    language="c++",
    extra_compile_args=["-w"],
    extra_link_args=linker_args,
    include_dirs=[str(codon_path / "include")],
    library_dirs=[str(codon_path / "lib" / "codon")],
)

setup(
    name="codon-jit",
    version=__version__,
    install_requires=["cython", "astunparse"],
    python_requires="&gt;=3.6",
    description="Codon JIT decorator",
    url="https://exaloop.io",
    long_description="Please see https://exaloop.io for more details.",
    author="Exaloop Inc.",
    author_email="info@exaloop.io",
    license="Commercial",
    ext_modules=[jit_extension],
    packages=["codon"],
    include_package_data=True,
    cmdclass={
        "build_ext": build_ext,
    },
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1184"></t>
<t tx="ekr.20230509083243.1185">@path C:/Repos/codon/extra/python/codon/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

from argparse import ArgumentError
import ctypes
import inspect
import sys
import os
import functools
import itertools
import ast
import shutil
import astunparse
from pathlib import Path

sys.setdlopenflags(sys.getdlopenflags() | ctypes.RTLD_GLOBAL)

from .codon_jit import JITWrapper, JITError, codon_library

if "CODON_PATH" not in os.environ:
    codon_path = []
    codon_lib_path = codon_library()
    if codon_lib_path:
        codon_path.append(Path(codon_lib_path).parent / "stdlib")
    codon_path.append(
        Path(os.path.expanduser("~")) / ".codon" / "lib" / "codon" / "stdlib"
    )
    for path in codon_path:
        if path.exists():
            os.environ["CODON_PATH"] = str(path.resolve())
            break
    else:
        raise RuntimeError(
            "Cannot locate Codon. Please install Codon or set CODON_PATH."
        )

pod_conversions = {
    type(None): "pyobj",
    int: "int",
    float: "float",
    bool: "bool",
    str: "str",
    complex: "complex",
    slice: "slice",
}

custom_conversions = {}
_error_msgs = set()


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1186">def _common_type(t, debug, sample_size):
    sub, is_optional = None, False
    for i in itertools.islice(t, sample_size):
        if i is None:
            is_optional = True
        else:
            s = _codon_type(i, debug=debug, sample_size=sample_size)
            if sub and sub != s:
                return "pyobj"
            sub = s
    if is_optional and sub and sub != "pyobj":
        sub = "Optional[{}]".format(sub)
    return sub if sub else "pyobj"


</t>
<t tx="ekr.20230509083243.1187">def _codon_type(arg, **kwargs):
    t = type(arg)

    s = pod_conversions.get(t, "")
    if s:
        return s
    if issubclass(t, list):
        return "List[{}]".format(_common_type(arg, **kwargs))
    if issubclass(t, set):
        return "Set[{}]".format(_common_type(arg, **kwargs))
    if issubclass(t, dict):
        return "Dict[{},{}]".format(
            _common_type(arg.keys(), **kwargs), _common_type(arg.values(), **kwargs)
        )
    if issubclass(t, tuple):
        return "Tuple[{}]".format(",".join(_codon_type(a, **kwargs) for a in arg))
    s = custom_conversions.get(t, "")
    if s:
        j = ",".join(_codon_type(getattr(arg, slot), **kwargs) for slot in t.__slots__)
        return "{}[{}]".format(s, j)

    debug = kwargs.get("debug", None)
    if debug:
        msg = "cannot convert " + t.__name__
        if msg not in _error_msgs:
            print("[python]", msg, file=sys.stderr)
            _error_msgs.add(msg)
    return "pyobj"


</t>
<t tx="ekr.20230509083243.1188">def _codon_types(args, **kwargs):
    return tuple(_codon_type(arg, **kwargs) for arg in args)


</t>
<t tx="ekr.20230509083243.1189">def _reset_jit():
    global _jit
    _jit = JITWrapper()
    init_code = (
        "from internal.python import "
        "setup_decorator, PyTuple_GetItem, PyObject_GetAttrString\n"
        "setup_decorator()\n"
    )
    _jit.execute(init_code, "", 0, False)
    return _jit


</t>
<t tx="ekr.20230509083243.119">void CloneVisitor::visit(const ContinueInstr *v) {
  result = Nt(v, cloneLoop ? clone(v-&gt;getLoop()) : v-&gt;getLoop());
}

</t>
<t tx="ekr.20230509083243.1190">_jit = _reset_jit()


</t>
<t tx="ekr.20230509083243.1191">class RewriteFunctionArgs(ast.NodeTransformer):
    @others
</t>
<t tx="ekr.20230509083243.1192">def __init__(self, args):
    self.args = args

</t>
<t tx="ekr.20230509083243.1193">def visit_FunctionDef(self, node):
    for a in self.args:
        node.args.args.append(ast.arg(arg=a, annotation=None))
    return node


</t>
<t tx="ekr.20230509083243.1194">def _obj_to_str(obj, **kwargs) -&gt; str:
    if inspect.isclass(obj):
        lines = inspect.getsourcelines(obj)[0]
        extra_spaces = lines[0].find("class")
        obj_str = "".join(l[extra_spaces:] for l in lines)
    elif callable(obj):
        lines = inspect.getsourcelines(obj)[0]
        extra_spaces = lines[0].find("@")
        obj_str = "".join(l[extra_spaces:] for l in lines[1:])
        if kwargs.get("pyvars", None):
            node = ast.fix_missing_locations(
                RewriteFunctionArgs(kwargs["pyvars"]).visit(ast.parse(obj_str))
            )
            obj_str = astunparse.unparse(node)
    else:
        raise TypeError("Function or class expected, got " + type(obj).__name__)
    return obj_str.replace("_@par", "@par")


</t>
<t tx="ekr.20230509083243.1195">def _obj_name(obj) -&gt; str:
    if inspect.isclass(obj) or callable(obj):
        return obj.__name__
    else:
        raise TypeError("Function or class expected, got " + type(obj).__name__)


</t>
<t tx="ekr.20230509083243.1196">def _parse_decorated(obj, **kwargs):
    return _obj_name(obj), _obj_to_str(obj, **kwargs)


</t>
<t tx="ekr.20230509083243.1197">def convert(t):
    if not hasattr(t, "__slots__"):
        raise JITError("class '{}' does not have '__slots__' attribute".format(str(t)))

    name = t.__name__
    slots = t.__slots__
    code = (
        "@tuple\n"
        "class "
        + name
        + "["
        + ",".join("T{}".format(i) for i in range(len(slots)))
        + "]:\n"
    )
    for i, slot in enumerate(slots):
        code += "    {}: T{}\n".format(slot, i)

    # PyObject_GetAttrString
    code += "    def __from_py__(p: cobj):\n"
    for i, slot in enumerate(slots):
        code += "        a{} = T{}.__from_py__(PyObject_GetAttrString(p, '{}'.ptr))\n".format(
            i, i, slot
        )
    code += "        return {}({})\n".format(
        name, ", ".join("a{}".format(i) for i in range(len(slots)))
    )

    _jit.execute(code, "", 0, False)
    custom_conversions[t] = name
    return t


</t>
<t tx="ekr.20230509083243.1198">def jit(fn=None, debug=None, sample_size=5, pyvars=None):
    if not pyvars:
        pyvars = []
    if not isinstance(pyvars, list):
        raise ArgumentError("pyvars must be a list")

    @others
    if fn:
        return _decorate(fn)
    return _decorate
</t>
<t tx="ekr.20230509083243.1199">def _decorate(f):
    try:
        obj_name, obj_str = _parse_decorated(f, pyvars=pyvars)
        _jit.execute(
            obj_str,
            f.__code__.co_filename,
            f.__code__.co_firstlineno,
            1 if debug else 0,
        )
    except JITError:
        _reset_jit()
        raise

    @functools.wraps(f)
    def wrapped(*args, **kwargs):
        try:
            args = (*args, *kwargs.values())
            types = _codon_types(args, debug=debug, sample_size=sample_size)
            if debug:
                print(
                    "[python] {}({})".format(f.__name__, list(types)),
                    file=sys.stderr,
                )
            return _jit.run_wrapper(
                obj_name, types, f.__module__, pyvars, args, 1 if debug else 0
            )
        except JITError:
            _reset_jit()
            raise

    return wrapped

</t>
<t tx="ekr.20230509083243.12">void GeneratorArgumentOptimization::handle(CallInstr *v) {
auto *M = v-&gt;getModule();
auto *func = util::getFunc(v-&gt;getCallee());

if (isSum(func) &amp;&amp; v-&gt;numArgs() == 2) {
  auto *call = cast&lt;CallInstr&gt;(v-&gt;front());
  if (!call)
    return;

  auto *gen = util::getFunc(call-&gt;getCallee());
  auto *start = v-&gt;back();

  if (auto *fn = genToSum(cast&lt;BodiedFunc&gt;(gen), start-&gt;getType(), v-&gt;getType())) {
    std::vector&lt;Value *&gt; args(call-&gt;begin(), call-&gt;end());
    args.push_back(start);
    v-&gt;replaceAll(util::call(fn, args));
  }
} else {
  bool any = isAny(func), all = isAll(func);
  if (!(any || all) || v-&gt;numArgs() != 1 || !v-&gt;getType()-&gt;is(M-&gt;getBoolType()))
    return;

  auto *call = cast&lt;CallInstr&gt;(v-&gt;front());
  if (!call)
    return;

  auto *gen = util::getFunc(call-&gt;getCallee());

  if (auto *fn = genToAnyAll(cast&lt;BodiedFunc&gt;(gen), any)) {
    std::vector&lt;Value *&gt; args(call-&gt;begin(), call-&gt;end());
    v-&gt;replaceAll(util::call(fn, args));
  }
}
}

</t>
<t tx="ekr.20230509083243.120">void CloneVisitor::visit(const ReturnInstr *v) { result = Nt(v, clone(v-&gt;getValue())); }

</t>
<t tx="ekr.20230509083243.1200">@path C:/Repos/codon/extra/python/codon/
# Copyright (C) 2022 Exaloop Inc. &lt;https://exaloop.io&gt;

__all__ = ["jit", "convert", "JITError"]

from .decorator import jit, convert, JITError
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1201"></t>
<t tx="ekr.20230509083243.1202">@path C:/Repos/codon/jupyter/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "jupyter.h"

#include &lt;codecvt&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;iostream&gt;
#include &lt;locale&gt;
#include &lt;nlohmann/json.hpp&gt;
#include &lt;unistd.h&gt;
#include &lt;xeus/xhelper.hpp&gt;
#include &lt;xeus/xkernel.hpp&gt;
#include &lt;xeus/xkernel_configuration.hpp&gt;
#include &lt;xeus/xserver_zmq.hpp&gt;

#include "codon/compiler/compiler.h"
#include "codon/compiler/error.h"
#include "codon/compiler/jit.h"
#include "codon/config/config.h"
#include "codon/parser/common.h"
#include "codon/util/common.h"

using std::move;
using std::string;

namespace nl = nlohmann;
namespace codon {

CodonJupyter::CodonJupyter(const std::string &amp;argv0,
@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1203">                           const std::vector&lt;std::string&gt; &amp;plugins)
    : argv0(argv0), plugins(plugins) {}

nl::json CodonJupyter::execute_request_impl(int execution_counter, const string &amp;code,
  @others
</t>
<t tx="ekr.20230509083243.1204">                                          bool silent, bool store_history,
                                          nl::json user_expressions,
@others
</t>
<t tx="ekr.20230509083243.1205">                                          bool allow_stdin) {
auto result = jit-&gt;execute(code);
string failed;
llvm::handleAllErrors(
    result.takeError(),
    [&amp;](const codon::error::ParserErrorInfo &amp;e) {
      std::vector&lt;string&gt; backtrace;
      for (auto &amp;msg : e)
        for (auto &amp;s : msg)
          backtrace.push_back(s.getMessage());
      string err = backtrace[0];
      backtrace.erase(backtrace.begin());
      failed = fmt::format("Compile error: {}\nBacktrace:\n{}", err,
                           ast::join(backtrace, "  \n"));
    },
    [&amp;](const codon::error::RuntimeErrorInfo &amp;e) {
      auto backtrace = e.getBacktrace();
      failed = fmt::format("Runtime error: {}\nBacktrace:\n{}", e.getMessage(),
                           ast::join(backtrace, "  \n"));
    });
if (failed.empty()) {
  std::string out = *result;
  nl::json pub_data;
  using std::string_literals::operator""s;
  std::string codonMimeMagic = "\x00\x00__codon/mime__\x00"s;
  if (ast::startswith(out, codonMimeMagic)) {
    std::string mime = "";
    int i = codonMimeMagic.size();
    for (; i &lt; out.size() &amp;&amp; out[i]; i++)
      mime += out[i];
    if (i &lt; out.size() &amp;&amp; !out[i]) {
      i += 1;
    } else {
      mime = "text/plain";
      i = 0;
    }
    pub_data[mime] = out.substr(i);
    LOG("&gt; {}: {}", mime, out.substr(i));
  } else {
    pub_data["text/plain"] = out;
  }
  if (!out.empty())
    publish_execution_result(execution_counter, move(pub_data), nl::json::object());
  return nl::json{{"status", "ok"},
                  {"payload", nl::json::array()},
                  {"user_expressions", nl::json::object()}};
} else {
  publish_stream("stderr", failed);
  return nl::json{{"status", "error"}};
}
}

</t>
<t tx="ekr.20230509083243.1206">void CodonJupyter::configure_impl() {
  jit = std::make_unique&lt;codon::jit::JIT&gt;(argv0, "jupyter");
  jit-&gt;getCompiler()-&gt;getLLVMVisitor()-&gt;setCapture();

  for (const auto &amp;plugin : plugins) {
    // TODO: error handling on plugin init
    bool failed = false;
    llvm::handleAllErrors(jit-&gt;getCompiler()-&gt;load(plugin),
                          [&amp;failed](const codon::error::PluginErrorInfo &amp;e) {
                            codon::compilationError(e.getMessage(), /*file=*/"",
                                                    /*line=*/0, /*col=*/0,
                                                    /*terminate=*/false);
                            failed = true;
                          });
  }
  llvm::cantFail(jit-&gt;init());
}

</t>
<t tx="ekr.20230509083243.1207">nl::json CodonJupyter::complete_request_impl(const string &amp;code, int cursor_pos) {
  return nl::json{{"status", "ok"}};
}

nl::json CodonJupyter::inspect_request_impl(const string &amp;code, int cursor_pos,
</t>
<t tx="ekr.20230509083243.1208">                                            int detail_level) {
  return nl::json{{"status", "ok"}};
}

</t>
<t tx="ekr.20230509083243.1209">nl::json CodonJupyter::is_complete_request_impl(const string &amp;code) {
  return nl::json{{"status", "complete"}};
}

nl::json CodonJupyter::kernel_info_request_impl() {
  return xeus::create_info_reply("", "codon_kernel", CODON_VERSION, "python", "3.7",
                                 "text/x-python", ".codon", "python", "", "",
                                 "Codon Kernel");
}

</t>
<t tx="ekr.20230509083243.121">void CloneVisitor::visit(const YieldInstr *v) {
  result = Nt(v, clone(v-&gt;getValue()), v-&gt;isFinal());
}

</t>
<t tx="ekr.20230509083243.1210">void CodonJupyter::shutdown_request_impl() {}

  @others
</t>
<t tx="ekr.20230509083243.1211">int startJupyterKernel(const std::string &amp;argv0,
@others
</t>
<t tx="ekr.20230509083243.1212">                     const std::vector&lt;std::string&gt; &amp;plugins,
@others
</t>
<t tx="ekr.20230509083243.1213">                     const std::string &amp;configPath) {
xeus::xconfiguration config = xeus::load_configuration(configPath);

auto context = xeus::make_context&lt;zmq::context_t&gt;();
auto interpreter = std::make_unique&lt;CodonJupyter&gt;(argv0, plugins);
xeus::xkernel kernel(config, xeus::get_user_name(), move(context), move(interpreter),
                     xeus::make_xserver_zmq);
kernel.start();

return 0;
}

</t>
<t tx="ekr.20230509083243.1214">@path C:/Repos/codon/jupyter/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once
#include &lt;codon/compiler/jit.h&gt;
#include &lt;nlohmann/json.hpp&gt;
#include &lt;xeus/xinterpreter.hpp&gt;

using xeus::xinterpreter;
namespace nl = nlohmann;

namespace codon {
@others
int startJupyterKernel(const std::string &amp;argv0,
                       const std::vector&lt;std::string&gt; &amp;plugins,
                       const std::string &amp;configPath);

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1215">class CodonJupyter : public xinterpreter {
  std::unique_ptr&lt;codon::jit::JIT&gt; jit;
  std::string argv0;
  std::vector&lt;std::string&gt; plugins;

public:
  CodonJupyter(const std::string &amp;argv0, const std::vector&lt;std::string&gt; &amp;plugins);

private:
  void configure_impl() override;

  nl::json execute_request_impl(int execution_counter, const std::string &amp;code,
                                bool silent, bool store_history,
                                nl::json user_expressions, bool allow_stdin) override;

  nl::json complete_request_impl(const std::string &amp;code, int cursor_pos) override;

  nl::json inspect_request_impl(const std::string &amp;code, int cursor_pos,
                                int detail_level) override;

  nl::json is_complete_request_impl(const std::string &amp;code) override;

  nl::json kernel_info_request_impl() override;

  void shutdown_request_impl() override;
};

</t>
<t tx="ekr.20230509083243.1216"></t>
<t tx="ekr.20230509083243.1217"></t>
<t tx="ekr.20230509083243.1218"></t>
<t tx="ekr.20230509083243.122">void CloneVisitor::visit(const ThrowInstr *v) { result = Nt(v, clone(v-&gt;getValue())); }

</t>
<t tx="ekr.20230509083243.1221"></t>
<t tx="ekr.20230509083243.1222">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Pats of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

def bisect_left(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
) -&gt; int:
    """
    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e &lt; x, and all e in
    a[i:] have e &gt;= x.  So if x already appears in the list, a.insert(x) will
    insert just before the leftmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.

    Default values: lo=0, hi=None
    """
    if lo &lt; 0:
        raise ValueError("lo must be non-negative")
    hi: int = len(a) if hi is None else hi
    while lo &lt; hi:
        mid = (lo + hi) // 2
        if a[mid] &lt; x:
            lo = mid + 1
        else:
            hi = mid
    return lo

def bisect_right(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
) -&gt; int:
    """
    Return the index where to insert item x in list a, assuming a is sorted.

    The return value i is such that all e in a[:i] have e &lt;= x, and all e in
    a[i:] have e &gt; x.  So if x already appears in the list, a.insert(x) will
    insert just after the rightmost x already there.

    Optional args lo (default 0) and hi (default len(a)) bound the
    slice of a to be searched.

    Default values: lo=0, hi=None
    """
    if lo &lt; 0:
        raise ValueError("lo must be non-negative")
    hi: int = len(a) if hi is None else hi
    while lo &lt; hi:
        mid = (lo + hi) // 2
        if x &lt; a[mid]:
            hi = mid
        else:
            lo = mid + 1
    return lo

def insort_left(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
):
    """
    Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the left of the leftmost x.

    Default values: lo=0, hi=None
    For now seq will use len(a) instead of None
    """
    lo = bisect_left(a, x, lo, hi)
    a.insert(lo, x)

def insort_right(
    a: List[T], x: S, lo: int = 0, hi: Optional[int] = None, T: type, S: type
):
    """
    Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the right of the rightmost x.

    Default values: lo=0, hi=None
    For now seq will use len(a) instead of None
    """
    lo = bisect_right(a, x, lo, hi)

    if lo == len(a):
        a.append(x)
    else:
        a.insert(lo, x)

bisect = bisect_right
insort = insort_right
</t>
<t tx="ekr.20230509083243.1223">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import math

e = math.e
pi = math.pi
tau = math.tau
inf = math.inf
nan = math.nan
infj = complex(0.0, inf)
nanj = complex(0.0, nan)

# internal constants
_FLT_RADIX = 2
_M_LN2 = 0.6931471805599453094  # ln(2)
_M_LN10 = 2.302585092994045684  # ln(10)

@pure
@llvm
def _max_float() -&gt; float:
    ret double 0x7FEFFFFFFFFFFFFF

@pure
@llvm
def _min_float() -&gt; float:
    ret double 0x10000000000000

_DBL_MAX = _max_float()
_DBL_MIN = _min_float()
_DBL_MANT_DIG = 53

_CM_LARGE_DOUBLE = _DBL_MAX/4.
_CM_SQRT_LARGE_DOUBLE = math.sqrt(_CM_LARGE_DOUBLE)
_CM_LOG_LARGE_DOUBLE = math.log(_CM_LARGE_DOUBLE)
_CM_SQRT_DBL_MIN = math.sqrt(_DBL_MIN)
_CM_SCALE_UP = (2*(_DBL_MANT_DIG // 2) + 1)
_CM_SCALE_DOWN = (-(_CM_SCALE_UP+1)//2)

# special types
_ST_NINF  = 0  # negative infinity
_ST_NEG   = 1  # negative finite number (nonzero)
_ST_NZERO = 2  # -0.
_ST_PZERO = 3  # +0.
_ST_POS   = 4  # positive finite number (nonzero)
_ST_PINF  = 5  # positive infinity
_ST_NAN   = 6  # Not a Number

def _special_type(d: float):
    if math.isfinite(d):
        if d != 0:
            if math.copysign(1., d) == 1.:
                return _ST_POS
            else:
                return _ST_NEG
        else:
            if math.copysign(1., d) == 1.:
                return _ST_PZERO
            else:
                return _ST_NZERO
    if math.isnan(d):
        return _ST_NAN
    if math.copysign(1., d) == 1.:
        return _ST_PINF
    else:
        return _ST_NINF

def _acos_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(P34,INF), C(P,INF), C(P,INF), C(P,-INF), C(P,-INF), C(P34,-INF), C(N,INF),
         C(P12,INF), C(U,U), C(U,U), C(U,U), C(U,U), C(P12,-INF), C(N,N), C(P12,INF),
         C(U,U), C(P12,0.), C(P12,-0.), C(U,U), C(P12,-INF), C(P12,N), C(P12,INF), C(U,U),
         C(P12,0.), C(P12,-0.), C(U,U), C(P12,-INF), C(P12,N), C(P12,INF), C(U,U), C(U,U),
         C(U,U), C(U,U), C(P12,-INF), C(N,N), C(P14,INF), C(0.,INF), C(0.,INF), C(0.,-INF),
         C(0.,-INF), C(P14,-INF), C(N,INF), C(N,INF), C(N,N), C(N,N), C(N,N), C(N,N),
         C(N,-INF), C(N,N))
    return v

def _acosh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    def C(a,b): return complex(a, b)
    v = (C(INF,-P34), C(INF,-P), C(INF,-P), C(INF,P), C(INF,P), C(INF,P34), C(INF,N),
         C(INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P12),
         C(U,U), C(0.,-P12), C(0.,P12), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U),
         C(0.,-P12), C(0.,P12), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(U,U),
         C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.),
         C(INF,0.), C(INF,P14), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,N),
         C(N,N))
    return v

def _asinh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(-INF,-P14), C(-INF,-0.), C(-INF,-0.), C(-INF,0.), C(-INF,0.), C(-INF,P14), C(-INF,N),
         C(-INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(-INF,P12), C(N,N), C(-INF,-P12), C(U,U),
         C(-0.,-0.), C(-0.,0.), C(U,U), C(-INF,P12), C(N,N), C(INF,-P12), C(U,U), C(0.,-0.),
         C(0.,0.), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(U,U), C(U,U), C(U,U),
         C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.), C(INF,P14),
         C(INF,N), C(INF,N), C(N,N), C(N,-0.), C(N,0.), C(N,N), C(INF,N), C(N,N))
    return v

def _atanh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(-0.,-P12), C(-0.,-P12), C(-0.,-P12), C(-0.,P12), C(-0.,P12), C(-0.,P12), C(-0.,N),
         C(-0.,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(-0.,P12), C(N,N), C(-0.,-P12), C(U,U),
         C(-0.,-0.), C(-0.,0.), C(U,U), C(-0.,P12), C(-0.,N), C(0.,-P12), C(U,U), C(0.,-0.), C(0.,0.),
         C(U,U), C(0.,P12), C(0.,N), C(0.,-P12), C(U,U), C(U,U), C(U,U), C(U,U), C(0.,P12), C(N,N),
         C(0.,-P12), C(0.,-P12), C(0.,-P12), C(0.,P12), C(0.,P12), C(0.,P12), C(0.,N), C(0.,-P12),
         C(N,N), C(N,N), C(N,N), C(N,N), C(0.,P12), C(N,N))
    return v

def _cosh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(INF,N), C(U,U), C(INF,0.), C(INF,-0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U),
         C(U,U), C(U,U), C(N,N), C(N,N), C(N,0.), C(U,U), C(1.,0.), C(1.,-0.), C(U,U), C(N,0.), C(N,0.),
         C(N,0.), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(N,0.), C(N,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N),
         C(N,N), C(N,N), C(N,0.), C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

def _exp_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(0.,0.), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(0.,0.), C(0.,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U),
         C(1.,-0.), C(1.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N),
         C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,-0.),
         C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

def _log_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(INF,-P34), C(INF,-P), C(INF,-P), C(INF,P), C(INF,P), C(INF,P34), C(INF,N), C(INF,-P12), C(U,U),
         C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U), C(-INF,-P), C(-INF,P), C(U,U), C(INF,P12),
         C(N,N), C(INF,-P12), C(U,U), C(-INF,-0.), C(-INF,0.), C(U,U), C(INF,P12), C(N,N), C(INF,-P12), C(U,U),
         C(U,U), C(U,U), C(U,U), C(INF,P12), C(N,N), C(INF,-P14), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.),
         C(INF,P14), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,N), C(N,N))
    return v

def _sinh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(INF,N), C(U,U), C(-INF,-0.), C(-INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U), C(U,U),
        C(U,U), C(N,N), C(N,N), C(0.,N), C(U,U), C(-0.,-0.), C(-0.,0.), C(U,U), C(0.,N), C(0.,N), C(0.,N),
        C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(0.,N), C(0.,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N),
        C(N,N), C(INF,N), C(U,U), C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,-0.),
        C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

def _sqrt_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(INF,-INF), C(0.,-INF), C(0.,-INF), C(0.,INF), C(0.,INF), C(INF,INF), C(N,INF), C(INF,-INF), C(U,U), C(U,U),
         C(U,U), C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(INF,INF), C(N,N),
         C(INF,-INF), C(U,U), C(0.,-0.), C(0.,0.), C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(U,U), C(U,U), C(U,U),
         C(U,U), C(INF,INF), C(N,N), C(INF,-INF), C(INF,-0.), C(INF,-0.), C(INF,0.), C(INF,0.), C(INF,INF), C(INF,N),
         C(INF,-INF), C(N,N), C(N,N), C(N,N), C(N,N), C(INF,INF), C(N,N))
    return v

def _tanh_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(-1.,0.), C(U,U), C(-1.,-0.), C(-1.,0.), C(U,U), C(-1.,0.), C(-1.,0.), C(N,N), C(U,U), C(U,U), C(U,U),
         C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(-0.,-0.), C(-0.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U),
         C(0.,-0.), C(0.,0.), C(U,U), C(N,N), C(N,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N),
         C(1.,0.), C(U,U), C(1.,-0.), C(1.,0.), C(U,U), C(1.,0.), C(1.,0.), C(N,N), C(N,N), C(N,-0.), C(N,0.),
         C(N,N), C(N,N), C(N,N))
    return v

def _rect_special():
    P = pi
    P14 = 0.25*pi
    P12 = 0.5*pi
    P34 = 0.75*pi
    INF = inf  # Py_HUGE_VAL
    N = nan
    U = -9.5426319407711027e33  # unlikely value, used as placeholder
    def C(a,b): return complex(a, b)
    v = (C(INF,N), C(U,U), C(-INF,0.), C(-INF,-0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U),
         C(N,N), C(N,N), C(0.,0.), C(U,U), C(-0.,0.), C(-0.,-0.), C(U,U), C(0.,0.), C(0.,0.), C(0.,0.), C(U,U), C(0.,-0.),
         C(0.,0.), C(U,U), C(0.,0.), C(0.,0.), C(N,N), C(U,U), C(U,U), C(U,U), C(U,U), C(N,N), C(N,N), C(INF,N), C(U,U),
         C(INF,-0.), C(INF,0.), C(U,U), C(INF,N), C(INF,N), C(N,N), C(N,N), C(N,0.), C(N,0.), C(N,N), C(N,N), C(N,N))
    return v

def _is_special(z):
    return (not math.isfinite(z.real)) or (not math.isfinite(z.imag))

def _special_get(z, table):
    t1 = _special_type(z.real)
    t2 = _special_type(z.imag)
    return table[7*t1 + t2]

def _sqrt_impl(z):
    if _is_special(z):
        return _special_get(z, _sqrt_special())

    r_real = 0.
    r_imag = 0.
    if z.real == 0. and z.imag == 0.:
        r_real = 0.
        r_imag = z.imag
        return complex(r_real, r_imag)

    ax = math.fabs(z.real)
    ay = math.fabs(z.imag)
    s = 0.
    if ax &lt; _DBL_MIN and ay &lt; _DBL_MIN and (ax &gt; 0. or ay &gt; 0.):
        # here we catch cases where hypot(ax, ay) is subnormal
        ax = math.ldexp(ax, _CM_SCALE_UP)
        s = math.ldexp(math.sqrt(ax + math.hypot(ax, math.ldexp(ay, _CM_SCALE_UP))), _CM_SCALE_DOWN)
    else:
        ax /= 8.
        s = 2.*math.sqrt(ax + math.hypot(ax, ay/8.))
    d = ay/(2.*s)

    if z.real &gt;= 0.:
        r_real = s
        r_imag = math.copysign(d, z.imag)
    else:
        r_real = d
        r_imag = math.copysign(s, z.imag)
    # errno = 0
    return complex(r_real, r_imag)

def _acos_impl(z):
    if _is_special(z):
        return _special_get(z, _acos_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        # avoid unnecessary overflow for large arguments
        r_real = math.atan2(math.fabs(z.imag), z.real)
        # split into cases to make sure that the branch cut has the
        # correct continuity on systems with unsigned zeros
        if z.real &lt; 0.:
            r_imag = -math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, z.imag)
        else:
            r_imag = math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, -z.imag)
    else:
        s1 = _sqrt_impl(complex(1. - z.real, -z.imag))
        s2 = _sqrt_impl(complex(1. + z.real, z.imag))
        r_real = 2.*math.atan2(s1.real, s2.real)
        r_imag = math.asinh(s2.real*s1.imag - s2.imag*s1.real)
    return complex(r_real, r_imag)

def _acosh_impl(z):
    if _is_special(z):
        return _special_get(z, _acosh_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        # avoid unnecessary overflow for large arguments
        r_real = math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2.
        r_imag = math.atan2(z.imag, z.real)
    else:
        s1 = _sqrt_impl(complex(z.real - 1., z.imag))
        s2 = _sqrt_impl(complex(z.real + 1., z.imag))
        r_real = math.asinh(s1.real*s2.real + s1.imag*s2.imag)
        r_imag = 2.*math.atan2(s1.imag, s2.real)
    return complex(r_real, r_imag)

def _asinh_impl(z):
    if _is_special(z):
        return _special_get(z, _asinh_special())

    r_real = 0.
    r_imag = 0.
    if math.fabs(z.real) &gt; _CM_LARGE_DOUBLE or math.fabs(z.imag) &gt; _CM_LARGE_DOUBLE:
        if z.imag &gt;= 0.:
            r_real = math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, z.real)
        else:
            r_real = -math.copysign(math.log(math.hypot(z.real/2., z.imag/2.)) + _M_LN2*2, -z.real)
        r_imag = math.atan2(z.imag, math.fabs(z.real))
    else:
        s1 = _sqrt_impl(complex(1. + z.imag, -z.real))
        s2 = _sqrt_impl(complex(1. - z.imag, z.real))
        r_real = math.asinh(s1.real*s2.imag - s2.real*s1.imag)
        r_imag = math.atan2(z.imag, s1.real*s2.real - s1.imag*s2.imag)
    return complex(r_real, r_imag)

def _asin_impl(z):
    s = _asinh_impl(complex(-z.imag, z.real))
    r_real = s.imag
    r_imag = -s.real
    return complex(r_real, r_imag)

def _atanh_impl(z):
    if _is_special(z):
        return _special_get(z, _atanh_special())

    # Reduce to case where z.real &gt;= 0., using atanh(z) = -atanh(-z).
    if z.real &lt; 0.:
        return -_atanh_impl(-z)

    r_real = 0.
    r_imag = 0.
    ay = math.fabs(z.imag)
    if z.real &gt; _CM_SQRT_LARGE_DOUBLE or ay &gt; _CM_SQRT_LARGE_DOUBLE:
        # if abs(z) is large then we use the approximation
        # atanh(z) ~ 1/z +/- i*pi/2 (+/- depending on the sign
        # of z.imag)
        h = math.hypot(z.real/2., z.imag/2.)  # safe from overflow
        r_real = z.real/4./h/h
        # the two negations in the next line cancel each other out
        # except when working with unsigned zeros: they're there to
        # ensure that the branch cut has the correct continuity on
        # systems that don't support signed zeros
        r_imag = -math.copysign(pi/2., -z.imag)
        # errno = 0
    elif z.real == 1. and ay &lt; _CM_SQRT_DBL_MIN:
        # C99 standard says:  atanh(1+/-0.) should be inf +/- 0i
        if ay == 0.:
            r_real = inf
            r_imag = z.imag
            # errno = EDOM
        else:
            r_real = -math.log(math.sqrt(ay)/math.sqrt(math.hypot(ay, 2.)))
            r_imag = math.copysign(math.atan2(2., -ay)/2, z.imag)
            # errno = 0
    else:
        r_real = math.log1p(4.*z.real/((1-z.real)*(1-z.real) + ay*ay))/4.
        r_imag = -math.atan2(-2.*z.imag, (1-z.real)*(1+z.real) - ay*ay)/2.
        # errno = 0
    return complex(r_real, r_imag)

def _atan_impl(z):
    s = _atanh_impl(complex(-z.imag, z.real))
    r_real = s.imag
    r_imag = -s.real
    return complex(r_real, r_imag)

def _cosh_impl(z):
    r_real = 0.
    r_imag = 0.
    # special treatment for cosh(+/-inf + iy) if y is not a NaN
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = -math.copysign(inf, math.sin(z.imag))
        else:
            r = _special_get(z, _cosh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; !Py_IS_NAN(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        # deal correctly with cases where cosh(z.real) overflows but
        # cosh(z) does not.
        x_minus_one = z.real - math.copysign(1., z.real)
        r_real = math.cos(z.imag) * math.cosh(x_minus_one) * e
        r_imag = math.sin(z.imag) * math.sinh(x_minus_one) * e
    else:
        r_real = math.cos(z.imag) * math.cosh(z.real)
        r_imag = math.sin(z.imag) * math.sinh(z.real)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

def _cos_impl(z):
    r = _cosh_impl(complex(-z.imag, z.real))
    return r

def _exp_impl(z):
    r_real = 0.
    r_imag = 0.
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = math.copysign(0., math.cos(z.imag))
                r_imag = math.copysign(0., math.sin(z.imag))
        else:
            r = _special_get(z, _exp_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN and not -infinity */
        if (Py_IS_INFINITY(z.imag) &amp;&amp;
            (Py_IS_FINITE(z.real) ||
             (Py_IS_INFINITY(z.real) &amp;&amp; z.real &gt; 0)))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if z.real &gt; _CM_LOG_LARGE_DOUBLE:
        l = math.exp(z.real - 1.)
        r_real = l*math.cos(z.imag)*e
        r_imag = l*math.sin(z.imag)*e
    else:
        l = math.exp(z.real)
        r_real = l*math.cos(z.imag)
        r_imag = l*math.sin(z.imag)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

def _c_log(z):
    if _is_special(z):
        return _special_get(z, _log_special())

    ax = math.fabs(z.real)
    ay = math.fabs(z.imag)

    r_real = 0.
    r_imag = 0.
    if ax &gt; _CM_LARGE_DOUBLE or ay &gt; _CM_LARGE_DOUBLE:
        r_real = math.log(math.hypot(ax/2., ay/2.)) + _M_LN2
    elif ax &lt; _DBL_MIN and ay &lt; _DBL_MIN:
        if ax &gt; 0. or ay &gt; 0.:
            # catch cases where hypot(ax, ay) is subnormal
            r_real = math.log(math.hypot(math.ldexp(ax, _DBL_MANT_DIG), math.ldexp(ay, _DBL_MANT_DIG))) - _DBL_MANT_DIG*_M_LN2
        else:
            # log(+/-0. +/- 0i)
            r_real = -inf
            r_imag = math.atan2(z.imag, z.real)
            # errno = EDOM
            return complex(r_real, r_imag)
    else:
        h = math.hypot(ax, ay)
        if 0.71 &lt;= h &lt;= 1.73:
            am = max(ax, ay)
            an = min(ax, ay)
            r_real = math.log1p((am-1)*(am+1) + an*an)/2.
        else:
            r_real = math.log(h)
    r_imag = math.atan2(z.imag, z.real)
    # errno = 0
    return complex(r_real, r_imag)

def _log10_impl(z):
    s = _c_log(z)
    return complex(s.real / _M_LN10, s.imag / _M_LN10)

def _sinh_impl(z):
    r_real = 0.
    r_imag = 0.
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
            else:
                r_real = -math.copysign(inf, math.cos(z.imag))
                r_imag = math.copysign(inf, math.sin(z.imag))
        else:
            r = _special_get(z, _sinh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if y is +/- infinity and x is not
           a NaN */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; !Py_IS_NAN(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        x_minus_one = z.real - math.copysign(1., z.real)
        r_real = math.cos(z.imag) * math.sinh(x_minus_one) * e
        r_imag = math.sin(z.imag) * math.cosh(x_minus_one) * e
    else:
        r_real = math.cos(z.imag) * math.sinh(z.real)
        r_imag = math.sin(z.imag) * math.cosh(z.real)
    '''
    /* detect overflow, and set errno accordingly */
    if (Py_IS_INFINITY(r.real) || Py_IS_INFINITY(r.imag))
        errno = ERANGE;
    else
        errno = 0;
    '''
    return complex(r_real, r_imag)

def _sin_impl(z):
    s = _sinh_impl(complex(-z.imag, z.real))
    r = complex(s.imag, -s.real)
    return r

def _tanh_impl(z):
    r_real = 0.
    r_imag = 0.
    # special treatment for tanh(+/-inf + iy) if y is finite and
    # nonzero
    if (not math.isfinite(z.real)) or (not math.isfinite(z.imag)):
        if math.isinf(z.real) and math.isfinite(z.imag) and z.imag != 0.:
            if z.real &gt; 0:
                r_real = 1.0
                r_imag = math.copysign(0., 2.*math.sin(z.imag)*math.cos(z.imag))
            else:
                r_real = -1.0
                r_imag = math.copysign(0., 2.*math.sin(z.imag)*math.cos(z.imag))
        else:
            r = _special_get(z, _tanh_special())
            r_real = r.real
            r_imag = r.imag
        '''
        /* need to set errno = EDOM if z.imag is +/-infinity and
           z.real is finite */
        if (Py_IS_INFINITY(z.imag) &amp;&amp; Py_IS_FINITE(z.real))
            errno = EDOM;
        else
            errno = 0;
        '''
        return complex(r_real, r_imag)

    # danger of overflow in 2.*z.imag !
    if math.fabs(z.real) &gt; _CM_LOG_LARGE_DOUBLE:
        r_real = math.copysign(1., z.real)
        r_imag = 4.*math.sin(z.imag)*math.cos(z.imag)*math.exp(-2.*math.fabs(z.real))
    else:
        tx = math.tanh(z.real)
        ty = math.tan(z.imag)
        cx = 1./math.cosh(z.real)
        txty = tx*ty
        denom = 1. + txty*txty
        r_real = tx*(1. + ty*ty)/denom
        r_imag = ((ty/denom)*cx)*cx
    # errno = 0
    return complex(r_real, r_imag)

def _tan_impl(z):
    s = _tanh_impl(complex(-z.imag, z.real))
    r = complex(s.imag, -s.real)
    return r

def phase(x):
    z = complex(x)
    return z._phase()

def polar(x):
    z = complex(x)
    return complex(x)._polar()

def rect(r, phi):
    z_real = 0.
    z_imag = 0.
    if (not math.isfinite(r)) or (not math.isfinite(phi)):
        # if r is +/-infinity and phi is finite but nonzero then
        # result is (+-INF +-INF i), but we need to compute cos(phi)
        # and sin(phi) to figure out the signs.
        if math.isinf(r) and (math.isfinite(phi) and phi != 0.):
            if r &gt; 0:
                z_real = math.copysign(inf, math.cos(phi))
                z_imag = math.copysign(inf, math.sin(phi))
            else:
                z_real = -math.copysign(inf, math.cos(phi))
                z_imag = -math.copysign(inf, math.sin(phi))
        else:
            z = _special_get(complex(r, phi), _rect_special())
            z_real = z.real
            z_imag = z.imag
        '''
        /* need to set errno = EDOM if r is a nonzero number and phi
           is infinite */
        if (r != 0. &amp;&amp; !Py_IS_NAN(r) &amp;&amp; Py_IS_INFINITY(phi))
            errno = EDOM;
        else
            errno = 0;
        '''
    elif phi == 0.0:
        # Workaround for buggy results with phi=-0.0 on OS X 10.8.  See
        # bugs.python.org/issue18513.
        z_real = r
        z_imag = r * phi
        # errno = 0
    else:
        z_real = r * math.cos(phi)
        z_imag = r * math.sin(phi)
        # errno = 0
    return complex(z_real, z_imag)

def exp(x):
    z = complex(x)
    return _exp_impl(z)

def log(x, base = e):
    z = complex(x)
    y = complex(base)
    r = _c_log(z)
    if y == complex(e, 0.0):
        return r
    else:
        return r/_c_log(y)

def log10(x):
    z = complex(x)
    return _log10_impl(z)

def sqrt(x):
    z = complex(x)
    return _sqrt_impl(z)

def asin(x):
    z = complex(x)
    return _asin_impl(z)

def acos(x):
    z = complex(x)
    return _acos_impl(z)

def atan(x):
    z = complex(x)
    return _atan_impl(z)

def sin(x):
    z = complex(x)
    return _sin_impl(z)

def cos(x):
    z = complex(x)
    return _cos_impl(z)

def tan(x):
    z = complex(x)
    return _tan_impl(z)

def asinh(x):
    z = complex(x)
    return _asinh_impl(z)

def acosh(x):
    z = complex(x)
    return _acosh_impl(z)

def atanh(x):
    z = complex(x)
    return _atanh_impl(z)

def sinh(x):
    z = complex(x)
    return _sinh_impl(z)

def cosh(x):
    z = complex(x)
    return _cosh_impl(z)

def tanh(x):
    z = complex(x)
    return _tanh_impl(z)

def isfinite(x):
    z = complex(x)
    return math.isfinite(z.real) and math.isfinite(z.imag)

def isinf(x):
    z = complex(x)
    return math.isinf(z.real) or math.isinf(z.imag)

def isnan(x):
    z = complex(x)
    return math.isnan(z.real) or math.isnan(z.imag)

def isclose(a, b, rel_tol: float = 1e-09, abs_tol: float = 0.0):
    if rel_tol &lt; 0. or abs_tol &lt; 0.:
        raise ValueError("tolerances must be non-negative")

    x = complex(a)
    y = complex(b)

    if x.real == y.real and x.imag == y.imag:
        return True

    if (math.isinf(x.real) or math.isinf(x.imag) or
        math.isinf(y.real) or math.isinf(y.imag)):
        return False

    diff = abs(x - y)
    return (((diff &lt;= rel_tol * abs(y)) or
             (diff &lt;= rel_tol * abs(x))) or
             (diff &lt;= abs_tol))
</t>
<t tx="ekr.20230509083243.1224">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.types.optional import unwrap

class deque:
    _arr: Array[T]
    _head: int
    _tail: int
    _maxlen: int
    T: type

    def __init__(self, arr: Array[T], head: int, tail: int, maxlen: int):
        self._arr = arr
        self._head = head
        self._tail = tail
        self._maxlen = maxlen

    def __init__(self):
        self._arr = Array[T](16)
        self._head = 0
        self._tail = 0
        self._maxlen = -1

    def __init__(self, maxlen: int):
        cap = 1
        while cap &lt; maxlen:
            cap *= 2
        self._arr = Array[T](cap)
        self._head = 0
        self._tail = 0
        self._maxlen = maxlen

    def __init__(self, it: Generator[T]):
        self._arr = Array[T](16)
        self._head = 0
        self._tail = 0
        self._maxlen = -1
        for i in it:
            self.append(i)

    @property
    def maxlen(self) -&gt; int:
        return self._maxlen

    def _double_cap(self):
        p = self._head
        n = len(self._arr)
        r = n - p
        new_cap = n * 2
        new_arr = Array[T](new_cap)
        for i in range(r):
            new_arr[i] = self._arr[p + i]
        for i in range(p):
            new_arr[i + r] = self._arr[i]
        self._arr = new_arr
        self._head = 0
        self._tail = n

    def _check_not_empty(self):
        if not self:
            raise IndexError("pop from an empty deque")

    def __bool__(self) -&gt; bool:
        return self._head != self._tail

    def __len__(self) -&gt; int:
        return (self._tail - self._head) &amp; (len(self._arr) - 1)

    def appendleft(self, x: T):
        self._head = (self._head - 1) &amp; (len(self._arr) - 1)
        self._arr[self._head] = x
        if self._maxlen &gt;= 0 and len(self) &gt; self._maxlen:
            self.pop()
        if self._head == self._tail:
            self._double_cap()

    def append(self, x: T):
        self._arr[self._tail] = x
        self._tail = (self._tail + 1) &amp; (len(self._arr) - 1)
        if self._maxlen &gt;= 0 and len(self) &gt; self._maxlen:
            self.popleft()
        if self._head == self._tail:
            self._double_cap()

    def popleft(self) -&gt; T:
        self._check_not_empty()
        res = self._arr[self._head]
        self._head = (self._head + 1) &amp; (len(self._arr) - 1)
        return res

    def pop(self) -&gt; T:
        self._check_not_empty()
        self._tail = (self._tail - 1) &amp; (len(self._arr) - 1)
        return self._arr[self._tail]

    def clear(self):
        self._head = 0
        self._tail = 0

    def __iter__(self) -&gt; Generator[T]:
        i = self._head
        while i != self._tail:
            yield self._arr[i]
            i = (i + 1) &amp; (len(self._arr) - 1)

    def __contains__(self, x: T) -&gt; bool:
        for i in self:
            if i == x:
                return True
        return False

    def __deepcopy__(self) -&gt; deque[T]:
        return deque(i.__deepcopy__() for i in self)

    def __copy__(self) -&gt; deque[T]:
        return deque[T](self._arr.__copy__(), self._head, self._tail, self._maxlen)

    def copy(self) -&gt; deque[T]:
        return self.__copy__()

    def __repr__(self) -&gt; str:
        return f"deque({repr(List[T](iter(self)))})"

    def _idx_check(self, idx: int, msg: str):
        if self._head == self._tail or idx &gt;= len(self) or idx &lt; 0:
            raise IndexError(msg)

    @property
    def left(self) -&gt; T:
        self._idx_check(0, "list index out of range")
        return self._arr[self._head]

    def __getitem__(self, idx: int) -&gt; T:
        if idx &lt; 0:
            idx += len(self)
        self._idx_check(idx, "list index out of range")
        if self._head &lt;= self._tail:
            return self._arr[self._head + idx]
        elif self._head + idx &lt; len(self._arr):
            return self._arr[self._head + idx]
        else:
            idx -= len(self._arr) - self._head
            assert 0 &lt;= idx &lt; self._tail
            return self._arr[idx]

@tuple
class _CounterItem:
    element: T
    count: int
    T: type

    def __eq__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count == other.count

    def __ne__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count != other.count

    def __lt__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count &lt; other.count

    def __gt__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count &gt; other.count

    def __le__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count &lt;= other.count

    def __ge__(self, other: _CounterItem[T]) -&gt; bool:
        return self.count &gt;= other.count

class Counter(Static[Dict[T, int]]):
    T: type

    def __init__(self, elements: Generator[T]):
        self._init()
        self.update(elements)

    def __init__(self, other: Counter[T]):
        self._init_from(other)

    def __init__(self, other: Dict[T, int]):
        self._init_from(other)

    def elements(self) -&gt; Generator[T]:
        for k, v in self.items():
            for i in range(v):
                yield k

    def most_common(self, n: Optional[int] = None) -&gt; List[Tuple[T, int]]:
        if len(self) == 0:
            return List[_CounterItem](capacity=0)

        if n is None:
            v = List[_CounterItem](capacity=len(self))
            for t in self.items():
                v.append(t)
            v.sort(reverse=True)
            return v
        else:
            from heapq import heapify, heapreplace

            n: int = n

            if n == 1:
                top: Optional[_CounterItem] = None
                for t in self.items():
                    if top is None or t[1] &gt; top.count:
                        top = t
                return [unwrap(top)]

            if n &lt;= 0:
                return List[_CounterItem](capacity=0)

            result = List[_CounterItem](capacity=n)
            for t in self.items():
                if len(result) &lt; n:
                    result.append(t)
                    if len(result) == n:
                        heapify(result)
                else:
                    if result[0] &lt; t:
                        heapreplace(result, t)

            result.sort(reverse=True)
            return result

    def subtract(self, elements: Generator[T]):
        for a in elements:
            self.increment(a, -1)

    def subtract(self, other: Counter[T]):
        for k, v in other.items():
            self.increment(k, -v)

    def subtract(self, other: Dict[T, int]):
        for k, v in other.items():
            self.increment(k, -v)

    def update(self, elements: Generator[T]):
        for a in elements:
            self.increment(a)

    def update(self, other: Counter[T]):
        for k, v in other.items():
            self.increment(k, by=v)

    def update(self, other: Dict[T, int]):
        for k, v in other.items():
            self.increment(k, by=v)

    def update(self):
        pass

    def total(self) -&gt; int:
        m = 0
        for v in self.values():
            m += v
        return m

    def __getitem__(self, key: T) -&gt; int:
        return self.get(key, 0)

    def __delitem__(self, key: T):
        x = self._kh_get(key)
        if x != self._kh_end():
            self._kh_del(x)

    def __eq__(self, other: Counter[T]) -&gt; bool:
        if self.__len__() != other.__len__():
            return False
        for k, v in self.items():
            if k not in other or other[k] != v:
                return False
        return True

    def __ne__(self, other: Counter[T]) -&gt; bool:
        return not (self == other)

    def __copy__(self) -&gt; Counter[T]:
        return Counter[T](self)

    def __iadd__(self, other: Counter[T]) -&gt; Counter[T]:
        for k, v in other.items():
            self.increment(k, by=v)
        self._del_non_positives()
        return self

    def __isub__(self, other: Counter[T]) -&gt; Counter[T]:
        for k, v in other.items():
            self.increment(k, by=-v)
        self._del_non_positives()
        return self

    def __iand__(self, other: Counter[T]) -&gt; Counter[T]:
        for k, v in other.items():
            self[k] = min(self.get(k, 0), v)
        self._del_non_positives()
        return self

    def __ior__(self, other: Counter[T]) -&gt; Counter[T]:
        self._del_non_positives()
        for k, v in other.items():
            self[k] = max(self.get(k, 0), v)
        self._del_non_positives()
        return self

    def __pos__(self) -&gt; Counter[T]:
        result = Counter[T]()
        result.resize(self._n_buckets)
        for k, v in self.items():
            if v &gt; 0:
                result[k] = v
        return result

    def __neg__(self) -&gt; Counter[T]:
        result = Counter[T]()
        result.resize(self._n_buckets)
        for k, v in self.items():
            if v &lt; 0:
                result[k] = -v
        return result

    def __add__(self, other: Counter[T]) -&gt; Counter[T]:
        result = self.__copy__()
        result += other
        return result

    def __sub__(self, other: Counter[T]) -&gt; Counter[T]:
        result = self.__copy__()
        result -= other
        return result

    def __and__(self, other: Counter[T]) -&gt; Counter[T]:
        result = self.__copy__()
        result &amp;= other
        return result

    def __or__(self, other: Counter[T]) -&gt; Counter[T]:
        result = self.__copy__()
        result |= other
        return result

    def __repr__(self):
        return f"Counter({super().__repr__()})"

    def __dict_do_op_throws__(self, key: T, other: Z, op: F, F: type, Z: type):
        self.__dict_do_op__(key, other, 0, op)

    def _del_non_positives(self):
        for k, v in self.items():
            if v &lt;= 0:
                del self[k]

@extend
class Dict:
    def __init__(self: Dict[K, int], other: Counter[K]):
        self._init_from(other)

class defaultdict(Static[Dict[K,V]]):
    default_factory: S
    K: type
    V: type
    S: TypeVar[Callable[[], V]]

    def __init__(self: defaultdict[K, VV, Function[[], V]], VV: TypeVar[V]):
        super().__init__()
        self.default_factory = lambda: VV()

    def __init__(self, f: S):
        super().__init__()
        self.default_factory = f

    def __init__(self: defaultdict[K, VV, Function[[], V]], VV: TypeVar[V], other: Dict[K, V]):
        super().__init__(other)
        self.default_factory = lambda: VV()

    def __init__(self, f: S, other: Dict[K, V]):
        super().__init__(other)
        self.default_factory = f

    def __missing__(self, key: K):
        default_value = self.default_factory()
        self.__setitem__(key, default_value)
        return default_value

    def __getitem__(self, key: K) -&gt; V:
        if key not in self:
            return self.__missing__(key)
        return super().__getitem__(key)

    def __dict_do_op_throws__(self, key: K, other: Z, op: F, F: type, Z: type):
        x = self._kh_get(key)
        if x == self._kh_end():
            self.__missing__(key)
            x = self._kh_get(key)
        self._vals[x] = op(self._vals[x], other)

    def copy(self):
        d = defaultdict[K,V,S](self.default_factory)
        d._init_from(self)
        return d

    def __copy__(self):
        return self.copy()

    def __deepcopy__(self):
        d = defaultdict[K,V,S](self.default_factory)
        for k,v in self.items():
            d[k.__deepcopy__()] = v.__deepcopy__()
        return d

    def __eq__(self, other: defaultdict[K,V,S]) -&gt; bool:
        if self.__len__() != other.__len__():
            return False
        for k, v in self.items():
            if k not in other or other[k] != v:
                return False
        return True

    def __ne__(self, other: defaultdict[K,V,S]) -&gt; bool:
        return not (self == other)

    def __repr__(self):
        return f"defaultdict(&lt;default factory of '{V.__name__}'&gt;, {super().__repr__()})"

@extend
class Dict:
    def __init__(self: Dict[K, V], other: defaultdict[K, V, S], S: type):
        self._init_from(other)

def namedtuple(name: Static[str], args):  # internal
    pass
</t>
<t tx="ekr.20230509083243.1225">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

class Error(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("copy.Error", message)

def copy(x):
	return x.__copy__()

def deepcopy(x):
	return x.__deepcopy__()
</t>
<t tx="ekr.20230509083243.1226">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: (c) 2022 Python Software Foundation. All right reserved.
# - Currently does not support timezones
# - Timedeltas use a pure-microseconds representations for efficiency, meaning they
#   have a smaller range (+/- 292,471.2 years) but should be more than enough for
#   all practical uses
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

from time import localtime
from time import struct_time

#############
# constants #
#############

MINYEAR = 1
MAXYEAR = 9999
MAXORDINAL = 3652059
MAX_DELTA_DAYS = 999999999

_DI4Y = 1461
_DI100Y = 36524
_DI400Y = 146097

_ROUND_HALF_EVEN = 0
_ROUND_CEILING = 1
_ROUND_FLOOR = 2
_ROUND_UP = 3

#############
# utilities #
#############

def _signed_add_overflowed(result: int, i: int, j: int) -&gt; bool:
    return ((result ^ i) &amp; (result ^ j)) &lt; 0

def _divmod(x: int, y: int) -&gt; Tuple[int, int]:
    # assert y &gt; 0
    quo = x // y
    r = x - quo * y
    if r &lt; 0:
        quo -= 1
        r += y
    # assert 0 &lt;= r &lt; y
    return quo, r

def _divide_nearest(m: int, n: int) -&gt; int:
    return m // n  # TODO

def _days_in_monthx(i: int) -&gt; int:
    return (0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)[i]

def _days_before_monthx(i: int) -&gt; int:
    return (0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334)[i]

def _is_leap(year: int) -&gt; bool:
    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)

def _days_in_month(year: int, month: int) -&gt; int:
    # assert 1 &lt;= month &lt;= 12
    if month == 2 and _is_leap(year):
        return 29
    else:
        return _days_in_monthx(month)

def _days_before_month(year: int, month: int) -&gt; int:
    # assert 1 &lt;= month &lt;= 12
    days = _days_before_monthx(month)
    if month &gt; 2 and _is_leap(year):
        days += 1
    return days

def _days_before_year(year: int) -&gt; int:
    y = year - 1
    # assert year &gt;= 1
    return y * 365 + y // 4 - y // 100 + y // 400

def _ord_to_ymd(ordinal: int) -&gt; Tuple[int, int, int]:
    ordinal -= 1
    n400 = ordinal // _DI400Y
    n = ordinal % _DI400Y
    year = n400 * 400 + 1

    n100 = n // _DI100Y
    n = n % _DI100Y

    n4 = n // _DI4Y
    n = n % _DI4Y

    n1 = n // 365
    n = n % 365

    year += n100 * 100 + n4 * 4 + n1
    if n1 == 4 or n100 == 4:
        # assert n == 0
        year -= 1
        return (year, 12, 31)

    leapyear = (n1 == 3) and (n4 != 24 or n100 == 3)
    # assert leapyear == is_leap(year)
    month = (n + 50) &gt;&gt; 5
    preceding = _days_before_monthx(month) + int(month &gt; 2 and leapyear)
    if preceding &gt; n:
        month -= 1
        preceding -= _days_in_month(year, month)
    n -= preceding
    # assert 0 &lt;= n
    # assert n &lt; _days_in_month(year, month)
    day = n + 1
    return (year, month, day)

def _ymd_to_ord(year: int, month: int, day: int) -&gt; int:
    return _days_before_year(year) + _days_before_month(year, month) + day

def _weekday(year: int, month: int, day: int) -&gt; int:
    return (_ymd_to_ord(year, month, day) + 6) % 7

def _iso_week1_monday(year: int) -&gt; int:
    first_day = _ymd_to_ord(year, 1, 1)
    first_weekday = (first_day + 6) % 7
    week1_monday = first_day - first_weekday
    if first_weekday &gt; 3:
        week1_monday += 7
    return week1_monday

def _check_delta_day_range(days: int):
    if not (-MAX_DELTA_DAYS &lt;= days &lt;= MAX_DELTA_DAYS):
        raise OverflowError(f"days={days}; must have magnitude &lt;= {MAX_DELTA_DAYS}")

def _check_date_args(year: int, month: int, day: int):
    if not (MINYEAR &lt;= year &lt;= MAXYEAR):
        raise ValueError(f"year {year} is out of range")
    if not (1 &lt;= month &lt;= 12):
        raise ValueError("month must be in 1..12")
    if not (1 &lt;= day &lt;= _days_in_month(year, month)):
        raise ValueError("day is out of range for month")

def _check_time_args(hour: int, minute: int, second: int, microsecond: int):
    if not (0 &lt;= hour &lt;= 23):
        raise ValueError("hour must be in 0..23")
    if not (0 &lt;= minute &lt;= 59):
        raise ValueError("minute must be in 0..59")
    if not (0 &lt;= second &lt;= 59):
        raise ValueError("second must be in 0..59")
    if not (0 &lt;= microsecond &lt;= 999999):
        raise ValueError("microsecond must be in 0..999999")

def _normalize_pair(hi: int, lo: int, factor: int) -&gt; Tuple[int, int]:
    # assert factor &gt; 0
    if lo &lt; 0 or lo &gt;= factor:
        num_hi, lo = _divmod(lo, factor)
        new_hi = hi + num_hi
        # assert not _signed_add_overflowed(new_hi, hi, num_hi)
        hi = new_hi
    # assert 0 &lt;= lo &lt; factor
    return hi, lo

def _normalize_d_s_us(d: int, s: int, us: int) -&gt; Tuple[int, int, int]:
    if us &lt; 0 or us &gt;= 1000000:
        s, us = _normalize_pair(s, us, 1000000)
    if s &lt; 0 or s &gt;= 24 * 3600:
        d, s = _normalize_pair(d, s, 24 * 3600)
    # assert 0 &lt;= s &lt; 24*3600
    # assert 0 &lt;= us &lt; 1000000
    return d, s, us

def _normalize_y_m_d(y: int, m: int, d: int) -&gt; Tuple[int, int, int]:
    def error():
        raise OverflowError("date value out of range")

    # assert 1 &lt;= m &lt;= 12
    dim = _days_in_month(y, m)
    if d &lt; 1 or d &gt; dim:
        if d == 0:
            m -= 1
            if m &gt; 0:
                d = _days_in_month(y, m)
            else:
                y -= 1
                m = 12
                d = 31
        elif d == dim + 1:
            m += 1
            d = 1
            if m &gt; 12:
                m = 1
                y += 1
        else:
            ordinal = _ymd_to_ord(y, m, 1) + d - 1
            if ordinal &lt; 1 or ordinal &gt; MAXORDINAL:
                error()
            else:
                return _ord_to_ymd(ordinal)
    # assert m &gt; 0
    # assert d &gt; 0
    if not (MINYEAR &lt;= y &lt;= MAXYEAR):
        error()
    return y, m, d

def _normalize_date(year: int, month: int, day: int) -&gt; Tuple[int, int, int]:
    return _normalize_y_m_d(year, month, day)

def _normalize_datetime(
    year: int,
    month: int,
    day: int,
    hour: int,
    minute: int,
    second: int,
    microsecond: int,
) -&gt; Tuple[int, int, int, int, int, int, int]:
    second, microsecond = _normalize_pair(second, microsecond, 1000000)
    minute, second = _normalize_pair(minute, second, 60)
    hour, minute = _normalize_pair(hour, minute, 60)
    day, hour = _normalize_pair(day, hour, 24)
    year, month, day = _normalize_date(year, month, day)
    return year, month, day, hour, minute, second, microsecond


def _parse_digits(digits: str, num_digits: int) -&gt; Tuple[str, int]:
    if len(digits) &lt; num_digits:
        return "", -1
    p = digits.ptr
    var = 0
    for i in range(num_digits):
        tmp = int(p[0]) - 48  # 48 == '0'
        if not (0 &lt;= tmp &lt;= 9):
            return "", -1
        var *= 10
        var += tmp
        p += 1
    return str(p, len(digits) - num_digits), var

def _isoformat_error(s: str):
    raise ValueError(f"Invalid isoformat string: {s}")

def _parse_isoformat_date(dtstr: str) -&gt; Tuple[int, int, int]:
    p = dtstr
    p, year = _parse_digits(p, 4)
    if year &lt; 0:
        _isoformat_error(dtstr)

    if not p or p[0] != "-":
        _isoformat_error(dtstr)
    p = p[1:]

    p, month = _parse_digits(p, 2)
    if month &lt; 0:
        _isoformat_error(dtstr)

    if not p or p[0] != "-":
        _isoformat_error(dtstr)
    p = p[1:]

    p, day = _parse_digits(p, 2)
    if day &lt; 0 or p:
        _isoformat_error(dtstr)

    return year, month, day

def _parse_hh_mm_ss_ff(tstr: str) -&gt; Tuple[int, int, int, int]:
    hour, minute, second, microsecond = 0, 0, 0, 0

    p = tstr
    for i in range(3):
        p, val = _parse_digits(p, 2)
        if val &lt; 0:
            _isoformat_error(tstr)

        if i == 0:
            hour = val
        if i == 1:
            minute = val
        if i == 2:
            second = val

        if not p:
            return hour, minute, second, microsecond
        c = p[0]
        p = p[1:]
        if c == ":":
            continue
        elif c == ".":
            break
        else:
            _isoformat_error(tstr)

    len_remains = len(p)
    if not (len_remains == 6 or len_remains == 3):
        _isoformat_error(tstr)

    p, microsecond = _parse_digits(p, len_remains)
    if microsecond &lt; 0:
        _isoformat_error(tstr)

    if len_remains == 3:
        microsecond *= 1000

    return hour, minute, second, microsecond

def _parse_isoformat_time(dtstr: str) -&gt; Tuple[int, int, int, int, int, int]:
    n = len(dtstr)
    tzinfo_pos = 0
    tzsign = 0
    while tzinfo_pos &lt; n:
        c = dtstr[tzinfo_pos]
        if c == "+":
            tzsign = 1
            break
        if c == "-":
            tzsign = -1
            break
        tzinfo_pos += 1

    hour, minute, second, microsecond = _parse_hh_mm_ss_ff(dtstr[:tzinfo_pos])
    if tzinfo_pos == n:
        return hour, minute, second, microsecond, 0, 0

    tzlen = n - tzinfo_pos
    if not (tzlen == 6 or tzlen == 9 or tzlen == 16):
        _isoformat_error(dtstr)

    tzhour, tzminute, tzsecond, tzmicrosecond = _parse_hh_mm_ss_ff(
        dtstr[tzinfo_pos + 1 :]
    )
    tzoffset = tzsign * ((tzhour * 3600) + (tzminute * 60) + tzsecond)
    tzmicrosecond *= tzsign
    return hour, minute, second, microsecond, tzoffset, tzmicrosecond

def _format_ctime(
    year: int, month: int, day: int, hours: int, minutes: int, seconds: int
) -&gt; str:
    DAY_NAMES = ("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
    MONTH_NAMES = (
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
    )
    wday = _weekday(year, month, day)
    return f"{DAY_NAMES[wday]} {MONTH_NAMES[month - 1]} {str(day).rjust(2)} {str(hours).zfill(2)}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)} {str(year).zfill(4)}"

def _utc_to_seconds(
    year: int, month: int, day: int, hour: int, minute: int, second: int
) -&gt; int:
    if year &lt; MINYEAR or year &gt; MAXYEAR:
        raise ValueError(f"year {year} is out of range")
    ordinal = _ymd_to_ord(year, month, day)
    return ((ordinal * 24 + hour) * 60 + minute) * 60 + second

def _round_half_even(x: float) -&gt; float:
    from math import fabs

    rounded = x.__round__()
    if fabs(x - rounded) == 0.5:
        rounded = 2.0 * (x / 2.0).__round__()
    return rounded

################
# core classes #
################

@tuple
class timedelta:
    min: ClassVar[timedelta] = timedelta._new(-9223372036854775808)
    max: ClassVar[timedelta] = timedelta._new(9223372036854775807)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _microseconds: int

    def _new(microseconds: int) -&gt; timedelta:
        return (microseconds,)

    @inline
    def _accum(sofar: int, leftover: float, num: int, factor: int) -&gt; Tuple[int, float]:
        sofar += num * factor
        return sofar, leftover

    @inline
    def _accum(
        sofar: int, leftover: float, num: float, factor: int
    ) -&gt; Tuple[int, float]:
        from math import modf

        fracpart, intpart = modf(num)
        prod = int(intpart) * factor
        s = sofar + prod

        if fracpart == 0.0:
            return s, leftover
        dnum = factor * fracpart
        fracpart, intpart = modf(dnum)
        y = s + int(intpart)
        return y, leftover + fracpart

    # override default constructor
    def __new__(days: int) -&gt; timedelta:
        return timedelta(days, 0)

    def __new__(
        days: float = 0,
        seconds: float = 0,
        microseconds: float = 0,
        milliseconds: float = 0,
        minutes: float = 0,
        hours: float = 0,
        weeks: float = 0,
    ) -&gt; timedelta:
        us = 0
        leftover = 0.0

        us, leftover = timedelta._accum(us, leftover, days, 24 * 60 * 60 * 1000000)
        us, leftover = timedelta._accum(us, leftover, seconds, 1000000)
        us, leftover = timedelta._accum(us, leftover, microseconds, 1)
        us, leftover = timedelta._accum(us, leftover, milliseconds, 1000)
        us, leftover = timedelta._accum(us, leftover, minutes, 60 * 1000000)
        us, leftover = timedelta._accum(us, leftover, hours, 60 * 60 * 1000000)
        us, leftover = timedelta._accum(us, leftover, weeks, 7 * 24 * 60 * 60 * 1000000)

        if leftover:
            from math import fabs

            whole_us = leftover.__round__()
            if fabs(whole_us - leftover) == 0.5:
                is_odd = us &amp; 1
                whole_us = 2.0 * ((leftover + is_odd) * 0.5).__round__() - is_odd
            us += int(whole_us)

        return (us,)

    @property
    def days(self) -&gt; int:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
        return days

    @property
    def seconds(self) -&gt; int:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
        return seconds

    @property
    def microseconds(self) -&gt; int:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
        return microseconds

    def __repr__(self) -&gt; str:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, self._microseconds)
        if days == 0 and seconds == 0 and microseconds == 0:
            return "timedelta(0)"
        v = []
        if days:
            v.append(f"days={days}")
        if seconds:
            v.append(f"seconds={seconds}")
        if microseconds:
            v.append(f"microseconds={microseconds}")
        return f"timedelta({', '.join(v)})"

    def __str__(self) -&gt; str:
        days, seconds, us = _normalize_d_s_us(0, 0, self._microseconds)
        minutes, seconds = _divmod(seconds, 60)
        hours, minutes = _divmod(minutes, 60)

        if days:
            if us:
                return f"{days} day{'' if days == 1 or days == -1 else 's'}, {hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}.{str(us).zfill(6)}"
            else:
                return f"{days} day{'' if days == 1 or days == -1 else 's'}, {hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}"
        else:
            if us:
                return f"{hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}.{str(us).zfill(6)}"
            else:
                return f"{hours}:{str(minutes).zfill(2)}:{str(seconds).zfill(2)}"

    def __add__(self, other: timedelta) -&gt; timedelta:
        return timedelta._new(self._microseconds + other._microseconds)

    def __sub__(self, other: timedelta) -&gt; timedelta:
        return timedelta._new(self._microseconds - other._microseconds)

    def __mul__(self, other: int) -&gt; timedelta:
        return timedelta._new(self._microseconds * other)

    def __rmul__(self, other: int) -&gt; timedelta:
        return self * other

    def __mul__(self, other: float) -&gt; timedelta:
        return timedelta._new(int(_round_half_even(self._microseconds * other)))

    def __rmul__(self, other: float) -&gt; timedelta:
        return self * other

    def __truediv__(self, other: timedelta) -&gt; float:
        return self._microseconds / other._microseconds

    def __truediv__(self, other: float) -&gt; timedelta:
        return timedelta._new(int(_round_half_even(self._microseconds / other)))

    def __truediv__(self, other: int) -&gt; timedelta:
        return self / float(other)

    def __floordiv__(self, other: timedelta) -&gt; int:
        return int((self._microseconds / other._microseconds).__floor__())

    def __floordiv__(self, other: int) -&gt; timedelta:
        return timedelta._new(self._microseconds // other)

    def __mod__(self, other: timedelta) -&gt; timedelta:
        n = self._microseconds
        M = other._microseconds
        m = self._microseconds % other._microseconds
        return timedelta._new(((n % M) + M) % M)

    def __divmod__(self, other: timedelta) -&gt; Tuple[int, timedelta]:
        return self // other, self % other

    def __pos__(self) -&gt; timedelta:
        return self

    def __neg__(self) -&gt; timedelta:
        return timedelta._new(-self._microseconds)

    def __abs__(self) -&gt; timedelta:
        return timedelta._new(abs(self._microseconds))

    def __eq__(self, other: timedelta) -&gt; bool:
        return self._microseconds == other._microseconds

    def __ne__(self, other: timedelta) -&gt; bool:
        return self._microseconds != other._microseconds

    def __lt__(self, other: timedelta) -&gt; bool:
        return self._microseconds &lt; other._microseconds

    def __le__(self, other: timedelta) -&gt; bool:
        return self._microseconds &lt;= other._microseconds

    def __gt__(self, other: timedelta) -&gt; bool:
        return self._microseconds &gt; other._microseconds

    def __ge__(self, other: timedelta) -&gt; bool:
        return self._microseconds &gt;= other._microseconds

    def __bool__(self) -&gt; bool:
        return bool(self._microseconds)

    def total_seconds(self) -&gt; float:
        return self._microseconds / 1e6

@tuple
class IsoCalendarDate:
    year: int
    week: int
    weekday: int

    def __repr__(self) -&gt; str:
        return f"IsoCalendarDate(year={self.year}, week={self.week}, weekday={self.weekday})"

@tuple
class date:
    min: ClassVar[date] = date(MINYEAR, 1, 1)
    max: ClassVar[date] = date(MAXYEAR, 12, 31)
    resolution: ClassVar[timedelta] = timedelta(days=1)

    _value: UInt[32]

    def __new__(year: int, month: int, day: int) -&gt; date:
        _check_date_args(year, month, day)
        v = (year &lt;&lt; 16) | (month &lt;&lt; 8) | day
        return date(UInt[32](v))

    @property
    def year(self) -&gt; int:
        v = int(self._value)
        return v &gt;&gt; 16

    @property
    def month(self) -&gt; int:
        v = int(self._value)
        return (v &gt;&gt; 8) &amp; 0xFF

    @property
    def day(self) -&gt; int:
        v = int(self._value)
        return v &amp; 0xFF

    def __repr__(self) -&gt; str:
        return f"date(year={self.year}, month={self.month}, day={self.day})"

    def today() -&gt; date:
        from time import time as ttime

        return date.fromtimestamp(ttime())

    def fromtimestamp(timestamp) -&gt; date:
        ts = int(timestamp)
        tm = localtime(ts)
        return date(tm.tm_year, tm.tm_mon, tm.tm_mday)

    def fromordinal(ordinal: int) -&gt; date:
        return date(*_ord_to_ymd(ordinal))

    def fromisoformat(date_string: str) -&gt; date:
        return date(*_parse_isoformat_date(date_string))

    def fromisocalendar(year, week, day) -&gt; date:
        if year &lt; MINYEAR or year &gt; MAXYEAR:
            raise ValueError(f"Year is out of range: {year}")

        if week &lt;= 0 or week &gt;= 53:
            out_of_range = True
            if week == 53:
                first_weekday = _weekday(year, 1, 1)
                if first_weekday == 3 or (first_weekday == 2 and _is_leap(year)):
                    out_of_range = False

            if out_of_range:
                raise ValueError(f"Invalid week: {week}")

        if day &lt;= 0 or day &gt;= 8:
            raise ValueError(f"Invalid day: {day} (range is [1, 7])")

        day_1 = _iso_week1_monday(year)
        month = week
        day_offset = (month - 1) * 7 + day - 1
        return date(*_ord_to_ymd(day_1 + day_offset))

    def __add__(self, other: timedelta) -&gt; date:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, other._microseconds)
        day = self.day + days
        return date(*_normalize_date(self.year, self.month, day))

    def __sub__(self, other: timedelta) -&gt; date:
        days, seconds, microseconds = _normalize_d_s_us(0, 0, other._microseconds)
        day = self.day - days
        return date(*_normalize_date(self.year, self.month, day))

    def __sub__(self, other: date) -&gt; timedelta:
        left_ord = _ymd_to_ord(self.year, self.month, self.day)
        right_ord = _ymd_to_ord(other.year, other.month, other.day)
        return timedelta(days=left_ord - right_ord)

    def __eq__(self, other: date) -&gt; bool:
        return self._value == other._value

    def __ne__(self, other: date) -&gt; bool:
        return self._value != other._value

    def __lt__(self, other: date) -&gt; bool:
        return self._value &lt; other._value

    def __le__(self, other: date) -&gt; bool:
        return self._value &lt;= other._value

    def __gt__(self, other: date) -&gt; bool:
        return self._value &gt; other._value

    def __ge__(self, other: date) -&gt; bool:
        return self._value &gt;= other._value

    def __bool__(self) -&gt; bool:
        return True

    def replace(self, year: int = -1, month: int = -1, day: int = -1) -&gt; date:
        if year == -1:
            year = self.year
        if month == -1:
            month = self.month
        if day == -1:
            day = self.day
        return date(year, month, day)

    def timetuple(self) -&gt; struct_time:
        yday = self.toordinal() - date(self.year, 1, 1).toordinal() + 1
        return struct_time(
            self.year, self.month, self.day, 0, 0, 0, self.weekday(), yday, -1
        )

    def toordinal(self) -&gt; int:
        return _ymd_to_ord(self.year, self.month, self.day)

    def weekday(self) -&gt; int:
        return _weekday(self.year, self.month, self.day)

    def isoweekday(self) -&gt; int:
        return self.weekday() + 1

    def isocalendar(self) -&gt; IsoCalendarDate:
        year = self.year
        week1_monday = _iso_week1_monday(year)
        today = _ymd_to_ord(year, self.month, self.day)
        week, day = _divmod(today - week1_monday, 7)
        if week &lt; 0:
            year -= 1
            week1_monday = _iso_week1_monday(year)
            week, day = _divmod(today - week1_monday, 7)
        elif week &gt;= 52 and today &gt;= _iso_week1_monday(year + 1):
            year += 1
            week = 0
        return IsoCalendarDate(year, week + 1, day + 1)

    def isoformat(self) -&gt; str:
        return f"{str(self.year).zfill(4)}-{str(self.month).zfill(2)}-{str(self.day).zfill(2)}"

    def __str__(self) -&gt; str:
        return self.isoformat()

    def ctime(self) -&gt; str:
        return _format_ctime(self.year, self.month, self.day, 0, 0, 0)

    # strftime() / __format__() not supported

@tuple
class time:
    min: ClassVar[time] = time(0, 0, 0, 0)
    max: ClassVar[time] = time(23, 59, 59, 999999)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _value: int

    def __new__(
        hour: int = 0, minute: int = 0, second: int = 0, microsecond: int = 0
    ) -&gt; time:
        _check_time_args(hour, minute, second, microsecond)
        v = (hour &lt;&lt; 40) | (minute &lt;&lt; 32) | (second &lt;&lt; 24) | microsecond
        return (v,)

    @property
    def hour(self) -&gt; int:
        v = self._value
        return v &gt;&gt; 40

    @property
    def minute(self) -&gt; int:
        v = self._value
        return (v &gt;&gt; 32) &amp; 0xFF

    @property
    def second(self) -&gt; int:
        v = self._value
        return (v &gt;&gt; 24) &amp; 0xFF

    @property
    def microsecond(self) -&gt; int:
        v = self._value
        return v &amp; 0xFFFFFF

    def __repr__(self) -&gt; str:
        h, m, s, us = self.hour, self.minute, self.second, self.microsecond
        v = []
        v.append(f"hour={h}")
        v.append(f"minute={m}")
        if s or us:
            v.append(f"second={s}")
        if us:
            v.append(f"microsecond={us}")
        return f"time({', '.join(v)})"

    def __str__(self) -&gt; str:
        return self.isoformat()

    def __bool__(self) -&gt; bool:
        return True

    def fromisoformat(time_string: str) -&gt; time:
        (
            hour,
            minute,
            second,
            microsecond,
            tzoffset,
            tzmicrosecond,
        ) = _parse_isoformat_time(time_string)
        # TODO: deal with timezone
        return time(hour, minute, second, microsecond)

    def replace(
        self, hour: int = -1, minute: int = -1, second: int = -1, microsecond: int = -1
    ) -&gt; time:
        if hour == -1:
            hour = self.hour
        if second == -1:
            second = self.second
        if minute == -1:
            minute = self.minute
        if microsecond == -1:
            microsecond = self.microsecond
        return time(hour, minute, second, microsecond)

    def isoformat(self, timespec: Static[str] = "auto") -&gt; str:
        hh = str(self.hour).zfill(2)
        mm = str(self.minute).zfill(2)
        ss = str(self.second).zfill(2)
        us = str(self.microsecond).zfill(6)
        ms = str(self.microsecond // 1000).zfill(3)

        if timespec == "auto":
            if self.microsecond:
                return f"{hh}:{mm}:{ss}.{us}"
            else:
                return f"{hh}:{mm}:{ss}"
        elif timespec == "hours":
            return hh
        elif timespec == "minutes":
            return f"{hh}:{mm}"
        elif timespec == "seconds":
            return f"{hh}:{mm}:{ss}"
        elif timespec == "milliseconds":
            return f"{hh}:{mm}:{ss}.{ms}"
        elif timespec == "microseconds":
            return f"{hh}:{mm}:{ss}.{us}"
        else:
            compile_error(
                "invalid timespec; valid ones are 'auto', 'hours', 'minutes', 'seconds', 'milliseconds' and 'microseconds'"
            )

@tuple
class datetime:
    min: ClassVar[datetime] = datetime(MINYEAR, 1, 1)
    max: ClassVar[datetime] = datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999)
    resolution: ClassVar[timedelta] = timedelta(microseconds=1)

    _time: time
    _date: date

    def __new__(
        year: int,
        month: int,
        day: int,
        hour: int = 0,
        minute: int = 0,
        second: int = 0,
        microsecond: int = 0,
    ) -&gt; datetime:
        return datetime(time(hour, minute, second, microsecond), date(year, month, day))

    def date(self) -&gt; date:
        return self._date

    def time(self) -&gt; time:
        return self._time

    @property
    def year(self) -&gt; int:
        return self.date().year

    @property
    def month(self) -&gt; int:
        return self.date().month

    @property
    def day(self) -&gt; int:
        return self.date().day

    @property
    def hour(self) -&gt; int:
        return self.time().hour

    @property
    def minute(self) -&gt; int:
        return self.time().minute

    @property
    def second(self) -&gt; int:
        return self.time().second

    @property
    def microsecond(self) -&gt; int:
        return self.time().microsecond

    def __repr__(self) -&gt; str:
        return f"datetime(year={self.year}, month={self.month}, day={self.day}, hour={self.hour}, minute={self.minute}, second={self.second}, microsecond={self.microsecond})"

    def __str__(self) -&gt; str:
        return self.isoformat(sep=" ")

    def _from_timet_and_us(timet, us) -&gt; datetime:
        tm = localtime(timet)
        year = tm.tm_year
        month = tm.tm_mon
        day = tm.tm_mday
        hour = tm.tm_hour
        minute = tm.tm_min
        second = min(59, tm.tm_sec)
        # TODO: timezone adjustments
        return datetime(year, month, day, hour, minute, second, us)

    def today() -&gt; datetime:
        from time import time as ttime

        return datetime.fromtimestamp(ttime())

    # TODO: support timezone
    def now() -&gt; datetime:
        return datetime.today()

    def utcnow() -&gt; datetime:
        return datetime.now()

    # TODO: support timezone
    def fromtimestamp(timestamp) -&gt; datetime:
        from time import _time_to_timeval, _ROUND_HALF_EVEN

        timet, us = _time_to_timeval(float(timestamp), _ROUND_HALF_EVEN)
        return datetime._from_timet_and_us(timet, us)

    def utcfromtimestamp(timestamp) -&gt; datetime:
        return datetime.fromtimestamp(timestamp)

    def fromordinal(ordinal: int) -&gt; datetime:
        return datetime.combine(date.fromordinal(ordinal), time())

    # TODO: support timezone
    def combine(date: date, time: time) -&gt; datetime:
        return datetime(time, date)

    def fromisoformat(date_string: str) -&gt; datetime:
        time_string = "" if len(date_string) &lt; 10 else date_string[:10]
        year, month, day = _parse_isoformat_date(time_string)
        if len(date_string) == 10:
            return datetime(year=year, month=month, day=day)
        date_string = "" if len(date_string) &lt; 12 else date_string[11:]
        hour, minute, second, microsecond = _parse_hh_mm_ss_ff(date_string)
        return datetime(
            year=year,
            month=month,
            day=day,
            hour=hour,
            minute=minute,
            second=second,
            microsecond=microsecond,
        )

    def fromisocalendar(year: int, week: int, day: int) -&gt; datetime:
        return datetime.combine(date.fromisocalendar(year, week, day), time())

    def __add__(self, other: timedelta) -&gt; datetime:
        td_days, td_seconds, td_microseconds = _normalize_d_s_us(
            0, 0, other._microseconds
        )
        year = self.year
        month = self.month
        day = self.day + td_days
        hour = self.hour
        minute = self.minute
        second = self.second + td_seconds
        microsecond = self.microsecond + td_microseconds
        return datetime(
            *_normalize_datetime(year, month, day, hour, minute, second, microsecond)
        )

    def __sub__(self, other: timedelta) -&gt; datetime:
        td_days, td_seconds, td_microseconds = _normalize_d_s_us(
            0, 0, other._microseconds
        )
        year = self.year
        month = self.month
        day = self.day - td_days
        hour = self.hour
        minute = self.minute
        second = self.second - td_seconds
        microsecond = self.microsecond - td_microseconds
        return datetime(
            *_normalize_datetime(year, month, day, hour, minute, second, microsecond)
        )

    def __sub__(self, other: datetime) -&gt; timedelta:
        delta_d = _ymd_to_ord(self.year, self.month, self.day) - _ymd_to_ord(
            other.year, other.month, other.day
        )
        delta_s = (
            (self.hour - other.hour) * 3600
            + (self.minute - other.minute) * 60
            + (self.second - other.second)
        )
        delta_us = self.microsecond - other.microsecond
        return timedelta(days=delta_d, seconds=delta_s, microseconds=delta_us)

    def __eq__(self, other: datetime) -&gt; bool:
        return self.date() == other.date() and self.time() == other.time()

    def __ne__(self, other: datetime) -&gt; bool:
        return not (self == other)

    def __lt__(self, other: datetime) -&gt; bool:
        return (self.date(), self.time()) &lt; (other.date(), other.time())

    def __le__(self, other: datetime) -&gt; bool:
        return (self.date(), self.time()) &lt;= (other.date(), other.time())

    def __gt__(self, other: datetime) -&gt; bool:
        return (self.date(), self.time()) &gt; (other.date(), other.time())

    def __ge__(self, other: datetime) -&gt; bool:
        return (self.date(), self.time()) &gt;= (other.date(), other.time())

    def __bool__(self) -&gt; bool:
        return True

    def replace(
        self,
        year: int = -1,
        month: int = -1,
        day: int = -1,
        hour: int = -1,
        minute: int = -1,
        second: int = -1,
        microsecond: int = -1,
    ) -&gt; datetime:
        return datetime(
            self.time().replace(hour, minute, second, microsecond),
            self.date().replace(year, month, day),
        )

    def timetuple(self) -&gt; struct_time:
        yday = self.toordinal() - date(self.year, 1, 1).toordinal() + 1
        return struct_time(
            self.year,
            self.month,
            self.day,
            self.hour,
            self.minute,
            self.second,
            self.weekday(),
            yday,
            -1,
        )

    def utctimetuple(self) -&gt; struct_time:
        return self.timetuple()

    def toordinal(self) -&gt; int:
        return self.date().toordinal()

    def timestamp(self) -&gt; float:
        return (self - datetime(1970, 1, 1)).total_seconds()

    def weekday(self) -&gt; int:
        return self.date().weekday()

    def isoweekday(self) -&gt; int:
        return self.date().isoweekday()

    def isocalendar(self) -&gt; IsoCalendarDate:
        return self.date().isocalendar()

    def isoformat(self, sep: str = "T", timespec: Static[str] = "auto") -&gt; str:
        date_part = str(self.date())
        time_part = self.time().isoformat(timespec=timespec)
        return f"{date_part}{sep}{time_part}"

    def ctime(self) -&gt; str:
        date = self.date()
        time = self.time()
        return _format_ctime(
            date.year, date.month, date.day, time.hour, time.minute, time.second
        )

@extend
class timedelta:
    def __add__(self, other: date) -&gt; date:
        return other + self

    def __add__(self, other: datetime) -&gt; datetime:
        return other + self
</t>
<t tx="ekr.20230509083243.1227">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def partial():  # internal
    pass
</t>
<t tx="ekr.20230509083243.1228">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.

"""
Parser for command line options.

This module helps scripts to parse the command line arguments in
sys.argv.  It supports the same conventions as the Unix getopt()
function (including the special meanings of arguments of the form `-'
and `--').  Long options similar to those supported by GNU software
may be used as well via an optional third argument.  This module
provides two functions and an exception:

getopt() -- Parse command line options
gnu_getopt() -- Like getopt(), but allow option and non-option arguments
to be intermixed.
GetoptError -- exception (class) raised with 'opt' attribute, which is the
option involved with the exception.

Adapted from https://raw.githubusercontent.com/python/cpython/2.7/Lib/getopt.py
"""

import os

class GetoptError(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("GetoptError", message)

def long_has_args(opt: str, longopts: List[str]) -&gt; Tuple[bool, str]:
    possibilities = [o for o in longopts if o.startswith(opt)]
    if not possibilities:
        raise GetoptError(f"option --{opt} not recognized")
    # Is there an exact match?
    if opt in possibilities:
        return False, opt
    elif opt + "=" in possibilities:
        return True, opt
    # No exact match, so better be unique.
    if len(possibilities) &gt; 1:
        # XXX since possibilities contains all valid continuations, might be
        # nice to work them into the error msg
        raise GetoptError(f"option --{opt} not a unique prefix")
    assert len(possibilities) == 1
    unique_match = possibilities[0]
    has_arg = unique_match.endswith("=")
    if has_arg:
        unique_match = unique_match[:-1]
    return has_arg, unique_match

def do_longs(
    opts: List[Tuple[str, str]], opt: str, longopts: List[str], args: List[str]
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    optarg = ""
    try:
        i = opt.index("=")
        opt, optarg = opt[:i], opt[i + 1 :]
    except ValueError:
        pass

    has_arg, opt = long_has_args(opt, longopts)
    if has_arg:
        if optarg == "":
            if not args:
                raise GetoptError(f"option --{opt} requires argument")
            optarg, args = args[0], args[1:]
    elif optarg != "":
        raise GetoptError(f"option --{opt} must not have an argument")
    opts.append((f"--{opt}", optarg))
    return opts, args

def short_has_arg(opt: str, shortopts: str) -&gt; bool:
    for i in range(len(shortopts)):
        if opt == shortopts[i] != ":":
            return shortopts.startswith(":", i + 1)
    raise GetoptError(f"option -{opt} not recognized")

def do_shorts(
    opts: List[Tuple[str, str]], optstring: str, shortopts: str, args: List[str]
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    while optstring != "":
        opt, optstring = optstring[0], optstring[1:]
        optarg = ""
        if short_has_arg(opt, shortopts):
            if optstring == "":
                if not args:
                    raise GetoptError(f"option -{opt} requires argument")
                optstring, args = args[0], args[1:]
            optarg, optstring = optstring, ""
        opts.append((f"-{opt}", optarg))
    return opts, args

def getopt(
    args: List[str], shortopts: str, longopts: List[str] = []
) -&gt; Tuple[List[Tuple[str, str]], List[str]]:
    """
    Parses command line options and parameter list.  args is the
    argument list to be parsed, without the leading reference to the
    running program.  Typically, this means "sys.argv[1:]".  shortopts
    is the string of option letters that the script wants to
    recognize, with options that require an argument followed by a
    colon (i.e., the same format that Unix getopt() uses).  If
    specified, longopts is a list of strings with the names of the
    long options which should be supported.  The leading '--'
    characters should not be included in the option name.  Options
    which require an argument should be followed by an equal sign
    ('=').

    The return value consists of two elements: the first is a list of
    (option, value) pairs; the second is the list of program arguments
    left after the option list was stripped (this is a trailing slice
    of the first argument).  Each option-and-value pair returned has
    the option as its first element, prefixed with a hyphen (e.g.,
    '-x'), and the option argument as its second element, or an empty
    string if the option has no argument.  The options occur in the
    list in the same order in which they were found, thus allowing
    multiple occurrences.  Long and short options may be mixed.

    NOTES:
    This function works like the above-mentioned getopt(), except that GNU style scanning
    mode is used by default. This means that option and non-option
    arguments may be intermixed. The getopt() function stops
    processing options as soon as a non-option argument is
    encountered.
    If the first character of the option string is `+', or if the
    environment variable POSIXLY_CORRECT is set, then option
    processing stops as soon as a non-option argument is encountered.
    """

    opts = []
    prog_args = []

    # Allow options after non-option arguments?
    all_options_first = False
    if shortopts.startswith("+"):
        shortopts = shortopts[1:]
        all_options_first = True
    elif "POSIXLY_CORRECT" in os.environ:
        all_options_first = True

    while args:
        if args[0] == "--":
            prog_args += args[1:]
            break

        if args[0][:2] == "--":
            opts, args = do_longs(opts, args[0][2:], longopts, args[1:])
        elif args[0][:1] == "-" and args[0] != "-":
            opts, args = do_shorts(opts, args[0][1:], shortopts, args[1:])
        else:
            if all_options_first:
                prog_args += args
                break
            else:
                prog_args.append(args[0])
                args = args[1:]

    return opts, prog_args
</t>
<t tx="ekr.20230509083243.1229">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import sizeof as _sizeof

@tuple
class Device:
    _device: i32

    def __new__(device: int):
        from C import seq_nvptx_device(int) -&gt; i32
        return Device(seq_nvptx_device(device))

    @staticmethod
    def count():
        from C import seq_nvptx_device_count() -&gt; int
        return seq_nvptx_device_count()

    def __str__(self):
        from C import seq_nvptx_device_name(i32) -&gt; str
        return seq_nvptx_device_name(self._device)

    def __index__(self):
        return int(self._device)

    def __bool__(self):
        return True

    @property
    def compute_capability(self):
        from C import seq_nvptx_device_capability(i32) -&gt; int
        c = seq_nvptx_device_capability(self._device)
        return (c &gt;&gt; 32, c &amp; 0xffffffff)

@tuple
class Memory[T]:
    _ptr: Ptr[byte]

    def _alloc(n: int, T: type):
        from C import seq_nvptx_device_alloc(int) -&gt; Ptr[byte]
        return Memory[T](seq_nvptx_device_alloc(n * _sizeof(T)))

    def _read(self, p: Ptr[T], n: int):
        from C import seq_nvptx_memcpy_d2h(Ptr[byte], Ptr[byte], int)
        seq_nvptx_memcpy_d2h(p.as_byte(), self._ptr, n * _sizeof(T))

    def _write(self, p: Ptr[T], n: int):
        from C import seq_nvptx_memcpy_h2d(Ptr[byte], Ptr[byte], int)
        seq_nvptx_memcpy_h2d(self._ptr, p.as_byte(), n * _sizeof(T))

    def _free(self):
        from C import seq_nvptx_device_free(Ptr[byte])
        seq_nvptx_device_free(self._ptr)

@llvm
def syncthreads() -&gt; None:
    declare void @llvm.nvvm.barrier0()
    call void @llvm.nvvm.barrier0()
    ret {} {}

@tuple
class Dim3:
    _x: u32
    _y: u32
    _z: u32

    def __new__(x: int, y: int, z: int):
        return Dim3(u32(x), u32(y), u32(z))

    @property
    def x(self):
        return int(self._x)

    @property
    def y(self):
        return int(self._y)

    @property
    def z(self):
        return int(self._z)

@tuple
class Thread:
    @property
    def x(self):
        @pure
        @llvm
        def get_x() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
            ret i32 %res

        return int(get_x())

    @property
    def y(self):
        @pure
        @llvm
        def get_y() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.y()
            ret i32 %res

        return int(get_y())

    @property
    def z(self):
        @pure
        @llvm
        def get_z() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.tid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.z()
            ret i32 %res

        return int(get_z())

@tuple
class Block:
    @property
    def x(self):
        @pure
        @llvm
        def get_x() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
            ret i32 %res

        return int(get_x())

    @property
    def y(self):
        @pure
        @llvm
        def get_y() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.y()
            ret i32 %res

        return int(get_y())

    @property
    def z(self):
        @pure
        @llvm
        def get_z() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.z()
            ret i32 %res

        return int(get_z())

    @property
    def dim(self):
        @pure
        @llvm
        def get_x() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
            ret i32 %res

        @pure
        @llvm
        def get_y() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.y()
            ret i32 %res

        @pure
        @llvm
        def get_z() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.z()
            ret i32 %res

        return Dim3(get_x(), get_y(), get_z())

@tuple
class Grid:
    @property
    def dim(self):
        @pure
        @llvm
        def get_x() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.x()
            ret i32 %res

        @pure
        @llvm
        def get_y() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.y()
            ret i32 %res

        @pure
        @llvm
        def get_z() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.nctaid.z()
            ret i32 %res

        return Dim3(get_x(), get_y(), get_z())

@tuple
class Warp:
    def __len__(self):
        @pure
        @llvm
        def get_warpsize() -&gt; u32:
            declare i32 @llvm.nvvm.read.ptx.sreg.warpsize()
            %res = call i32 @llvm.nvvm.read.ptx.sreg.warpsize()
            ret i32 %res

        return int(get_warpsize())

thread = Thread()
block = Block()
grid = Grid()
warp = Warp()

def _catch():
    return (thread, block, grid, warp)

_catch()

@tuple
class AllocCache:
    v: List[Ptr[byte]]

    def add(self, p: Ptr[byte]):
        self.v.append(p)

    def free(self):
        for p in self.v:
            Memory[byte](p)._free()

def _tuple_from_gpu(args, gpu_args):
    if staticlen(args) &gt; 0:
        a = args[0]
        g = gpu_args[0]
        a.__from_gpu__(g)
        _tuple_from_gpu(args[1:], gpu_args[1:])

def kernel(fn):
    from C import seq_nvptx_function(str) -&gt; cobj
    from C import seq_nvptx_invoke(cobj, u32, u32, u32, u32, u32, u32, u32, cobj)

    def canonical_dim(dim):
        if isinstance(dim, NoneType):
            return (1, 1, 1)
        elif isinstance(dim, int):
            return (dim, 1, 1)
        elif isinstance(dim, Tuple[int,int]):
            return (dim[0], dim[1], 1)
        elif isinstance(dim, Tuple[int,int,int]):
            return dim
        elif isinstance(dim, Dim3):
            return (dim.x, dim.y, dim.z)
        else:
            compile_error("bad dimension argument")

    def offsets(t):
        @pure
        @llvm
        def offsetof(t: T, i: Static[int], T: type, S: type) -&gt; int:
            %p = getelementptr {=T}, ptr null, i64 0, i32 {=i}
            %s = ptrtoint ptr %p to i64
            ret i64 %s

        if staticlen(t) == 0:
            return ()
        else:
            T = type(t)
            S = type(t[-1])
            return (*offsets(t[:-1]), offsetof(t, staticlen(t) - 1, T, S))

    def wrapper(*args, grid, block):
        grid = canonical_dim(grid)
        block = canonical_dim(block)
        cache = AllocCache([])
        shared_mem = 0
        gpu_args = tuple(arg.__to_gpu__(cache) for arg in args)
        kernel_ptr = seq_nvptx_function(__realized__(fn, gpu_args).__llvm_name__)
        p = __ptr__(gpu_args).as_byte()
        arg_ptrs = tuple((p + offset) for offset in offsets(gpu_args))
        seq_nvptx_invoke(kernel_ptr, u32(grid[0]), u32(grid[1]), u32(grid[2]), u32(block[0]),
                         u32(block[1]), u32(block[2]), u32(shared_mem), __ptr__(arg_ptrs).as_byte())
        _tuple_from_gpu(args, gpu_args)
        cache.free()

    return wrapper

def _ptr_to_gpu(p: Ptr[T], n: int, cache: AllocCache, index_filter = lambda i: True, T: type):
    from internal.gc import atomic

    if not atomic(T):
        tmp = Ptr[T](n)
        for i in range(n):
            if index_filter(i):
                tmp[i] = p[i].__to_gpu__(cache)
        p = tmp

    mem = Memory._alloc(n, T)
    cache.add(mem._ptr)
    mem._write(p, n)
    return Ptr[T](mem._ptr)

def _ptr_from_gpu(p: Ptr[T], q: Ptr[T], n: int, index_filter = lambda i: True, T: type):
    from internal.gc import atomic

    mem = Memory[T](q.as_byte())
    if not atomic(T):
        tmp = Ptr[T](n)
        mem._read(tmp, n)
        for i in range(n):
            if index_filter(i):
                p[i] = T.__from_gpu_new__(tmp[i])
    else:
        mem._read(p, n)

@pure
@llvm
def _ptr_to_type(p: cobj, T: type) -&gt; T:
    ret ptr %p

def _object_to_gpu(obj: T, cache: AllocCache, T: type):
    s = tuple(obj)
    gpu_mem = Memory._alloc(1, type(s))
    cache.add(gpu_mem._ptr)
    gpu_mem._write(__ptr__(s), 1)
    return _ptr_to_type(gpu_mem._ptr, T)

def _object_from_gpu(obj):
    T = type(obj)
    S = type(tuple(obj))

    tmp = T.__new__()
    p = Ptr[S](tmp.__raw__())
    q = Ptr[S](obj.__raw__())

    mem = Memory[S](q.as_byte())
    mem._read(p, 1)
    return tmp

@tuple
class Pointer[T]:
    _ptr: Ptr[T]
    _len: int

    def __to_gpu__(self, cache: AllocCache):
        return _ptr_to_gpu(self._ptr, self._len, cache)

    def __from_gpu__(self, other: Ptr[T]):
        _ptr_from_gpu(self._ptr, other, self._len)

    def __from_gpu_new__(other: Ptr[T]):
        return other

def raw(v: List[T], T: type):
    return Pointer(v.arr.ptr, len(v))

@extend
class Ptr:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: Ptr[T]):
        pass

    def __from_gpu_new__(other: Ptr[T]):
        return other

@extend
class NoneType:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: NoneType):
        pass

    def __from_gpu_new__(other: NoneType):
        return other

@extend
class int:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: int):
        pass

    def __from_gpu_new__(other: int):
        return other

@extend
class float:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: float):
        pass

    def __from_gpu_new__(other: float):
        return other

@extend
class float32:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: float32):
        pass

    def __from_gpu_new__(other: float32):
        return other

@extend
class bool:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: bool):
        pass

    def __from_gpu_new__(other: bool):
        return other

@extend
class byte:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: byte):
        pass

    def __from_gpu_new__(other: byte):
        return other

@extend
class Int:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: Int[N]):
        pass

    def __from_gpu_new__(other: Int[N]):
        return other

@extend
class UInt:
    def __to_gpu__(self, cache: AllocCache):
        return self

    def __from_gpu__(self, other: UInt[N]):
        pass

    def __from_gpu_new__(other: UInt[N]):
        return other

@extend
class str:
    def __to_gpu__(self, cache: AllocCache):
        n = self.len
        return str(_ptr_to_gpu(self.ptr, n, cache), n)

    def __from_gpu__(self, other: str):
        pass

    def __from_gpu_new__(other: str):
        n = other.len
        p = Ptr[byte](n)
        _ptr_from_gpu(p, other.ptr, n)
        return str(p, n)

@extend
class List:
    @inline
    def __to_gpu__(self, cache: AllocCache):
        mem = List[T].__new__()
        n = self.len
        gpu_ptr = _ptr_to_gpu(self.arr.ptr, n, cache)
        mem.arr = Array[T](gpu_ptr, n)
        mem.len = n
        return _object_to_gpu(mem, cache)

    @inline
    def __from_gpu__(self, other: List[T]):
        mem = _object_from_gpu(other)
        my_cap = self.arr.len
        other_cap = mem.arr.len

        if other_cap &gt; my_cap:
            self._resize(other_cap)

        _ptr_from_gpu(self.arr.ptr, mem.arr.ptr, mem.len)
        self.len = mem.len

    @inline
    def __from_gpu_new__(other: List[T]):
        mem = _object_from_gpu(other)
        arr = Array[T](mem.arr.len)
        _ptr_from_gpu(arr.ptr, mem.arr.ptr, arr.len)
        mem.arr = arr
        return mem

@extend
class DynamicTuple:
    @inline
    def __to_gpu__(self, cache: AllocCache):
        n = self._len
        gpu_ptr = _ptr_to_gpu(self._ptr, n, cache)
        return DynamicTuple(gpu_ptr, n)

    @inline
    def __from_gpu__(self, other: DynamicTuple[T]):
        _ptr_from_gpu(self._ptr, other._ptr, self._len)

    @inline
    def __from_gpu_new__(other: DynamicTuple[T]):
        n = other._len
        p = Ptr[T](n)
        _ptr_from_gpu(p, other._ptr, n)
        return DynamicTuple(p, n)

@extend
class Dict:
    def __to_gpu__(self, cache: AllocCache):
        from internal.khash import __ac_fsize
        mem = Dict[K,V].__new__()
        n = self._n_buckets
        f = __ac_fsize(n) if n else 0

        mem._n_buckets = n
        mem._size = self._size
        mem._n_occupied = self._n_occupied
        mem._upper_bound = self._upper_bound
        mem._flags = _ptr_to_gpu(self._flags, f, cache)
        mem._keys = _ptr_to_gpu(self._keys, n, cache, lambda i: self._kh_exist(i))
        mem._vals = _ptr_to_gpu(self._vals, n, cache, lambda i: self._kh_exist(i))

        return _object_to_gpu(mem, cache)

    def __from_gpu__(self, other: Dict[K,V]):
        from internal.khash import __ac_fsize
        mem = _object_from_gpu(other)
        my_n = self._n_buckets
        n = mem._n_buckets
        f = __ac_fsize(n) if n else 0

        if my_n != n:
            self._flags = Ptr[u32](f)
            self._keys = Ptr[K](n)
            self._vals = Ptr[V](n)

        _ptr_from_gpu(self._flags, mem._flags, f)
        _ptr_from_gpu(self._keys, mem._keys, n, lambda i: self._kh_exist(i))
        _ptr_from_gpu(self._vals, mem._vals, n, lambda i: self._kh_exist(i))

        self._n_buckets = n
        self._size = mem._size
        self._n_occupied = mem._n_occupied
        self._upper_bound = mem._upper_bound

    def __from_gpu_new__(other: Dict[K,V]):
        from internal.khash import __ac_fsize
        mem = _object_from_gpu(other)

        n = mem._n_buckets
        f = __ac_fsize(n) if n else 0
        flags = Ptr[u32](f)
        keys = Ptr[K](n)
        vals = Ptr[V](n)

        _ptr_from_gpu(flags, mem._flags, f)
        mem._flags = flags
        _ptr_from_gpu(keys, mem._keys, n, lambda i: mem._kh_exist(i))
        mem._keys = keys
        _ptr_from_gpu(vals, mem._vals, n, lambda i: mem._kh_exist(i))
        mem._vals = vals
        return mem

@extend
class Set:
    def __to_gpu__(self, cache: AllocCache):
        from internal.khash import __ac_fsize
        mem = Set[K].__new__()
        n = self._n_buckets
        f = __ac_fsize(n) if n else 0

        mem._n_buckets = n
        mem._size = self._size
        mem._n_occupied = self._n_occupied
        mem._upper_bound = self._upper_bound
        mem._flags = _ptr_to_gpu(self._flags, f, cache)
        mem._keys = _ptr_to_gpu(self._keys, n, cache, lambda i: self._kh_exist(i))

        return _object_to_gpu(mem, cache)

    def __from_gpu__(self, other: Set[K]):
        from internal.khash import __ac_fsize
        mem = _object_from_gpu(other)

        my_n = self._n_buckets
        n = mem._n_buckets
        f = __ac_fsize(n) if n else 0

        if my_n != n:
            self._flags = Ptr[u32](f)
            self._keys = Ptr[K](n)

        _ptr_from_gpu(self._flags, mem._flags, f)
        _ptr_from_gpu(self._keys, mem._keys, n, lambda i: self._kh_exist(i))

        self._n_buckets = n
        self._size = mem._size
        self._n_occupied = mem._n_occupied
        self._upper_bound = mem._upper_bound

    def __from_gpu_new__(other: Set[K]):
        from internal.khash import __ac_fsize
        mem = _object_from_gpu(other)

        n = mem._n_buckets
        f = __ac_fsize(n) if n else 0
        flags = Ptr[u32](f)
        keys = Ptr[K](n)

        _ptr_from_gpu(flags, mem._flags, f)
        mem._flags = flags
        _ptr_from_gpu(keys, mem._keys, n, lambda i: mem._kh_exist(i))
        mem._keys = keys
        return mem

@extend
class Optional:
    def __to_gpu__(self, cache: AllocCache):
        if self is None:
            return self
        else:
            return Optional[T](self.__val__().__to_gpu__(cache))

    def __from_gpu__(self, other: Optional[T]):
        if self is not None and other is not None:
            self.__val__().__from_gpu__(other.__val__())

    def __from_gpu_new__(other: Optional[T]):
        if other is None:
            return Optional[T]()
        else:
            return Optional[T](T.__from_gpu_new__(other.__val__()))

@extend
class __internal__:
    def class_to_gpu(obj, cache: AllocCache):
        if isinstance(obj, Tuple):
            return tuple(a.__to_gpu__(cache) for a in obj)
        elif isinstance(obj, ByVal):
            T = type(obj)
            return T(*tuple(a.__to_gpu__(cache) for a in tuple(obj)))
        else:
            T = type(obj)
            S = type(tuple(obj))
            mem = T.__new__()
            Ptr[S](mem.__raw__())[0] = tuple(obj).__to_gpu__(cache)
            return _object_to_gpu(mem, cache)

    def class_from_gpu(obj, other):
        if isinstance(obj, Tuple):
            _tuple_from_gpu(obj, other)
        elif isinstance(obj, ByVal):
            _tuple_from_gpu(tuple(obj), tuple(other))
        else:
            S = type(tuple(obj))
            Ptr[S](obj.__raw__())[0] = S.__from_gpu_new__(tuple(_object_from_gpu(other)))

    def class_from_gpu_new(other):
        if isinstance(other, Tuple):
            return tuple(type(a).__from_gpu_new__(a) for a in other)
        elif isinstance(other, ByVal):
            T = type(other)
            return T(*tuple(type(a).__from_gpu_new__(a) for a in tuple(other)))
        else:
            S = type(tuple(other))
            mem = _object_from_gpu(other)
            Ptr[S](mem.__raw__())[0] = S.__from_gpu_new__(tuple(mem))
            return mem

# @par(gpu=True) support

@pure
@llvm
def _gpu_thread_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.tid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.tid.x()
    ret i32 %res

@pure
@llvm
def _gpu_block_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.ctaid.x()
    ret i32 %res

@pure
@llvm
def _gpu_block_dim_x() -&gt; u32:
    declare i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
    %res = call i32 @llvm.nvvm.read.ptx.sreg.ntid.x()
    ret i32 %res

def _gpu_loop_outline_template(start, stop, args, instance: Static[int]):
    @nonpure
    def _loop_step():
        return 1

    @kernel
    def _kernel_stub(start: int, count: int, args):
        @nonpure
        def _gpu_loop_body_stub(idx, args):
            pass

        @nonpure
        def _dummy_use(n):
            pass

        _dummy_use(instance)
        idx = (int(_gpu_block_dim_x()) * int(_gpu_block_x())) + int(_gpu_thread_x())
        step = _loop_step()
        if idx &lt; count:
            _gpu_loop_body_stub(start + (idx * step), args)

    step = _loop_step()
    loop = range(start, stop, step)

    MAX_BLOCK = 1024
    MAX_GRID = 2147483647
    G = MAX_BLOCK * MAX_GRID
    n = len(loop)

    if n == 0:
        return
    elif n &gt; G:
        raise ValueError(f'loop exceeds GPU iteration limit of {G}')

    block = n
    grid = 1
    if n &gt; MAX_BLOCK:
        block = MAX_BLOCK
        grid = (n // MAX_BLOCK) + (0 if n % MAX_BLOCK == 0 else 1)

    _kernel_stub(start, n, args, grid=grid, block=block)
</t>
<t tx="ekr.20230509083243.123">void CloneVisitor::visit(const FlowInstr *v) {
  result = Nt(v, clone(v-&gt;getFlow()), clone(v-&gt;getValue()));
}

</t>
<t tx="ekr.20230509083243.1230">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.file import gzFile

def open(path: str, mode: str = "r") -&gt; gzFile:
    return gzFile(path, mode)
</t>
<t tx="ekr.20230509083243.1231">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# 'heap' is a heap at all indices &gt;= startpos, except possibly for pos.  pos
# is the index of a leaf with a possibly out-of-order value.  Restore the
# heap invariant.
def _siftdown(heap: List[T], startpos: int, pos: int, T: type):
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos &gt; startpos:
        parentpos = (pos - 1) &gt;&gt; 1
        parent = heap[parentpos]
        if newitem &lt; parent:
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem

def _siftup(heap: List[T], pos: int, T: type):
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]
    # Bubble up the smaller child until hitting a leaf.
    childpos = 2 * pos + 1  # leftmost child position
    while childpos &lt; endpos:
        # Set childpos to index of smaller child.
        rightpos = childpos + 1
        if rightpos &lt; endpos and not heap[childpos] &lt; heap[rightpos]:
            childpos = rightpos
        # Move the smaller child up.
        heap[pos] = heap[childpos]
        pos = childpos
        childpos = 2 * pos + 1
    # The leaf at pos is empty now.  Put newitem there, and bubble it up
    # to its final resting place (by sifting its parents down).
    heap[pos] = newitem
    _siftdown(heap, startpos, pos)

def _siftdown_max(heap: List[T], startpos: int, pos: int, T: type):
    "Maxheap variant of _siftdown"
    newitem = heap[pos]
    # Follow the path to the root, moving parents down until finding a place
    # newitem fits.
    while pos &gt; startpos:
        parentpos = (pos - 1) &gt;&gt; 1
        parent = heap[parentpos]
        if parent &lt; newitem:
            heap[pos] = parent
            pos = parentpos
            continue
        break
    heap[pos] = newitem

def _siftup_max(heap: List[T], pos: int, T: type):
    "Maxheap variant of _siftup"
    endpos = len(heap)
    startpos = pos
    newitem = heap[pos]
    # Bubble up the larger child until hitting a leaf.
    childpos = 2 * pos + 1  # leftmost child position
    while childpos &lt; endpos:
        # Set childpos to index of larger child.
        rightpos = childpos + 1
        if rightpos &lt; endpos and not heap[rightpos] &lt; heap[childpos]:
            childpos = rightpos
        # Move the larger child up.
        heap[pos] = heap[childpos]
        pos = childpos
        childpos = 2 * pos + 1
    # The leaf at pos is empty now.  Put newitem there, and bubble it up
    # to its final resting place (by sifting its parents down).
    heap[pos] = newitem
    _siftdown_max(heap, startpos, pos)

def heappush(heap: List[T], item: T, T: type):
    """Push item onto heap, maintaining the heap invariant."""
    heap.append(item)
    _siftdown(heap, 0, len(heap) - 1)

def heappop(heap: List[T], T: type) -&gt; T:
    """Pop the smallest item off the heap, maintaining the heap invariant."""
    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup(heap, 0)
        return returnitem
    return lastelt

def heapreplace(heap: List[T], item: T, T: type) -&gt; T:
    """
    Pop and return the current smallest value, and add the new item.
    This is more efficient than heappop() followed by heappush(), and can be
    more appropriate when using a fixed-size heap.  Note that the value
    returned may be larger than item!  That constrains reasonable uses of
    this routine unless written as part of a conditional replacement:
    ``if item &gt; heap[0]: item = heapreplace(heap, item)``.
    """
    returnitem = heap[0]  # raises appropriate IndexError if heap is empty
    heap[0] = item
    _siftup(heap, 0)
    return returnitem

def heappushpop(heap: List[T], item: T, T: type) -&gt; T:
    """Fast version of a heappush followed by a heappop."""
    if heap and heap[0] &lt; item:
        item, heap[0] = heap[0], item
        _siftup(heap, 0)
    return item

def heapify(x: List[T], T: type):
    """Transform list into a heap, in-place, in $O(len(x))$ time."""
    n = len(x)
    # Transform bottom-up.  The largest index there's any point to looking at
    # is the largest with a child index in-range, so must have 2*i + 1 &lt; n,
    # or i &lt; (n-1)/2.  If n is even = 2*j, this is (2*j-1)/2 = j-1/2 so
    # j-1 is the largest, which is n//2 - 1.  If n is odd = 2*j+1, this is
    # (2*j+1-1)/2 = j so j-1 is the largest, and that's again n//2-1.
    for i in reversed(range(n // 2)):
        _siftup(x, i)

def _heappop_max(heap: List[T], T: type) -&gt; T:
    """Maxheap version of a heappop."""
    lastelt = heap.pop()  # raises appropriate IndexError if heap is empty
    if heap:
        returnitem = heap[0]
        heap[0] = lastelt
        _siftup_max(heap, 0)
        return returnitem
    return lastelt

def _heapreplace_max(heap: List[T], item: T, T: type) -&gt; T:
    """Maxheap version of a heappop followed by a heappush."""
    returnitem = heap[0]  # raises appropriate IndexError if heap is empty
    heap[0] = item
    _siftup_max(heap, 0)
    return returnitem

def _heapify_max(x: List[T], T: type):
    """Transform list into a maxheap, in-place, in O(len(x)) time."""
    n = len(x)
    for i in reversed(range(n // 2)):
        _siftup_max(x, i)

def nsmallest(n: int, iterable: Generator[T], key=Optional[int](), T: type) -&gt; List[T]:
    """Find the n smallest elements in a dataset.
    Equivalent to:  sorted(iterable, key=key)[:n]
    """
    if n == 1:
        v = List(1)
        for a in iterable:
            if not v:
                v.append(a)
            else:
                if not isinstance(key, Optional):
                    if key(a) &lt; key(v[0]):
                        v[0] = a
                elif a &lt; v[0]:
                    v[0] = a
        return v

    # When key is none, use simpler decoration
    if isinstance(key, Optional):
        it = iter(iterable)
        # put the range(n) first so that zip() doesn't
        # consume one too many elements from the iterator
        result = List(n)
        done = False
        for i in range(n):
            if it.done():
                done = True
                break
            result.append((it.next(), i))
        if not result:
            it.destroy()
            return []
        _heapify_max(result)
        top = result[0][0]
        order = n
        if not done:
            for elem in it:
                if elem &lt; top:
                    _heapreplace_max(result, (elem, order))
                    top, _order = result[0]
                    order += 1
        else:
            it.destroy()
        result.sort()
        return [elem for elem, order in result]
    else:
        # General case, slowest method
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(n):
            if it.done():
                done = True
                break
            elem = it.next()
            result.append((key(elem), i, elem))
        if not result:
            it.destroy()
            return []
        _heapify_max(result)
        top = result[0][0]
        order = n
        if not done:
            for elem in it:
                k = key(elem)
                if k &lt; top:
                    _heapreplace_max(result, (k, order, elem))
                    top, _order, _elem = result[0]
                    order += 1
        else:
            it.destroy()
        result.sort()
        return [elem for k, order, elem in result]

def nlargest(n: int, iterable: Generator[T], key=Optional[int](), T: type) -&gt; List[T]:
    """Find the n largest elements in a dataset.
    Equivalent to:  sorted(iterable, key=key, reverse=True)[:n]
    """
    if n == 1:
        v = List(1)
        for a in iterable:
            if not v:
                v.append(a)
            else:
                if not isinstance(key, Optional):
                    if key(a) &gt; key(v[0]):
                        v[0] = a
                elif a &gt; v[0]:
                    v[0] = a
        return v

    # When key is none, use simpler decoration
    if isinstance(key, Optional):
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(0, -n, -1):
            if it.done():
                done = True
                break
            result.append((it.next(), i))
        if not result:
            it.destroy()
            return []
        heapify(result)
        top = result[0][0]
        order = -n
        if not done:
            for elem in it:
                if top &lt; elem:
                    heapreplace(result, (elem, order))
                    top, _order = result[0]
                    order -= 1
        else:
            it.destroy()
        result.sort()
        return [elem for elem, order in reversed(result)]
    else:
        # General case, slowest method
        it = iter(iterable)
        result = List(n)
        done = False
        for i in range(0, -n, -1):
            if it.done():
                done = True
                break
            elem = it.next()
            result.append((key(elem), i, elem))
        if not result:
            return []
        heapify(result)
        top = result[0][0]
        order = -n
        if not done:
            for elem in it:
                k = key(elem)
                if top &lt; k:
                    heapreplace(result, (k, order, elem))
                    top, _order, _elem = result[0]
                    order -= 1
        else:
            it.destroy()
        result.sort()
        return [elem for k, order, elem in reversed(result)]

@tuple
class _MergeItem:
    value: T
    order: int
    gen: Generator[T]
    key: S
    T: type
    S: type

    def __lt__(self, other):
        if isinstance(self.key, Optional):
            return (self.value, self.order) &lt; (other.value, other.order)
        else:
            return (self.key(self.value), self.order, self.value) &lt; (
                other.key(other.value),
                other.order,
                other.value,
            )

def merge(*iterables, key=Optional[int](), reverse: bool = False):
    items = []

    # TODO: unify types of different compatible functions
    # TODO: lambdas with void?
    def _heapify(x):
        if reverse:
            _heapify_max(x)
        else:
            heapify(x)

    _heappop = lambda x: _heappop_max(x) if reverse else heappop(x)
    _heapreplace = lambda x, s: _heapreplace_max(x, s) if reverse else heapreplace(x, s)
    direction = -1 if reverse else 1

    order = 0
    for it in iterables:
        gen = iter(it)
        if not gen.done():
            items.append(_MergeItem(gen.next(), order * direction, gen, key))
        order += 1
    _heapify(items)
    while len(items) &gt; 1:
        while True:
            # TODO: @tuple unpacking does not work
            value, order, gen = items[0].value, items[0].order, items[0].gen
            yield value
            if gen.done():
                _heappop(items)
                break
            _heapreplace(items, _MergeItem(gen.next(), order, gen, key))
    if items:
        # fast case when only a single iterator remains
        value, order, gen = items[0].value, items[0].order, items[0].gen
        yield value
        yield from gen
</t>
<t tx="ekr.20230509083243.1232">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.types.optional import unwrap

# Infinite iterators

@inline
def count(start: T = 0, step: T = 1, T: type) -&gt; Generator[T]:
    """
    Return a count object whose ``__next__`` method returns consecutive values.
    """
    n = start
    while True:
        yield n
        n += step

@inline
def cycle(iterable: Generator[T], T: type) -&gt; Generator[T]:
    """
    Cycles repeatedly through an iterable.
    """
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
            yield element

@inline
def repeat(object: T, times: Optional[int] = None, T: type) -&gt; Generator[T]:
    """
    Make an iterator that returns a given object over and over again.
    """
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object

# Iterators terminating on the shortest input sequence

@inline
def accumulate(iterable: Generator[T], func=lambda a, b: a + b, initial=0, T: type):
    """
    Make an iterator that returns accumulated sums, or accumulated results
    of other binary functions (specified via the optional func argument).
    """
    total = initial
    yield total
    for element in iterable:
        total = func(total, element)
        yield total

@inline
@overload
def accumulate(iterable: Generator[T], func=lambda a, b: a + b, T: type):
    """
    Make an iterator that returns accumulated sums, or accumulated results
    of other binary functions (specified via the optional func argument).
    """
    total = None
    for element in iterable:
        total = element if total is None else func(unwrap(total), element)
        yield unwrap(total)

@tuple
class chain:
    """
    Make an iterator that returns elements from the first iterable until it is exhausted,
    then proceeds to the next iterable, until all of the iterables are exhausted.
    """

    @inline
    def __new__(*iterables):
        for it in iterables:
            for element in it:
                yield element

    @inline
    def from_iterable(iterables):
        for it in iterables:
            for element in it:
                yield element

@inline
def compress(
    data: Generator[T], selectors: Generator[B], T: type, B: type
) -&gt; Generator[T]:
    """
    Return data elements corresponding to true selector elements.
    Forms a shorter iterator from selected data elements using the selectors to
    choose the data elements.
    """
    for d, s in zip(data, selectors):
        if s:
            yield d

@inline
def dropwhile(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Drop items from the iterable while predicate(item) is true.
    Afterwards, return every element until the iterable is exhausted.
    """
    b = False
    for x in iterable:
        if not b and not predicate(x):
            b = True
        if b:
            yield x

@inline
def filterfalse(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Return those items of iterable for which function(item) is false.
    """
    for x in iterable:
        if not predicate(x):
            yield x

# TODO: fix this once Optional[Callable] lands
@inline
def groupby(iterable, key=Optional[int]()):
    """
    Make an iterator that returns consecutive keys and groups from the iterable.
    """
    currkey = None
    group = []

    for currvalue in iterable:
        k = currvalue if isinstance(key, Optional) else key(currvalue)
        if currkey is None:
            currkey = k
        if k != unwrap(currkey):
            yield unwrap(currkey), group
            currkey = k
            group = []
        group.append(currvalue)
    if currkey is not None:
        yield unwrap(currkey), group

def islice(iterable: Generator[T], stop: Optional[int], T: type) -&gt; Generator[T]:
    """
    Make an iterator that returns selected elements from the iterable.
    """
    if stop is not None and stop.__val__() &lt; 0:
        raise ValueError(
            "Indices for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize."
        )
    i = 0
    for x in iterable:
        if stop is not None and i &gt;= stop.__val__():
            break
        yield x
        i += 1

@overload
def islice(
    iterable: Generator[T],
    start: Optional[int],
    stop: Optional[int],
    step: Optional[int] = None,
    T: type,
) -&gt; Generator[T]:
    """
    Make an iterator that returns selected elements from the iterable.
    """
    from sys import maxsize

    start: int = 0 if start is None else start
    stop: int = maxsize if stop is None else stop
    step: int = 1 if step is None else step
    have_stop = False

    if start &lt; 0 or stop &lt; 0:
        raise ValueError(
            "Indices for islice() must be None or an integer: 0 &lt;= x &lt;= sys.maxsize."
        )
    elif step &lt; 0:
        raise ValueError("Step for islice() must be a positive integer or None.")

    it = range(start, stop, step)
    N = len(it)
    idx = 0
    b = -1

    if N == 0:
        for i, element in zip(range(start), iterable):
            pass
        return

    nexti = it[0]
    for i, element in enumerate(iterable):
        if i == nexti:
            yield element
            idx += 1
            if idx &gt;= N:
                b = i
                break
            nexti = it[idx]

    if b &gt;= 0:
        for i, element in zip(range(b + 1, stop), iterable):
            pass

@inline
def starmap(function, iterable):
    """
    Return an iterator whose values are returned from the function
    evaluated with an argument tuple taken from the given sequence.
    """
    for args in iterable:
        yield function(*args)

@inline
def takewhile(
    predicate: Callable[[T], bool], iterable: Generator[T], T: type
) -&gt; Generator[T]:
    """
    Return successive entries from an iterable as long as the predicate evaluates to true for each entry.
    """
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break

def tee(iterable: Generator[T], n: int = 2, T: type) -&gt; List[Generator[T]]:
    """
    Return n independent iterators from a single iterable.
    """
    from collections import deque

    it = iter(iterable)
    deques = [deque[T]() for i in range(n)]

    def gen(mydeque: deque[T], T: type) -&gt; Generator[T]:
        while True:
            if not mydeque:  # when the local deque is empty
                if it.__done__():
                    return
                it.__resume__()
                if it.__done__():
                    return
                newval = it.next()
                for d in deques:  # load it to all the deques
                    d.append(newval)
            yield mydeque.popleft()

    return [gen(d) for d in deques]

@inline
def zip_longest(*iterables, fillvalue):
    """
    Make an iterator that aggregates elements from each of the iterables.
    If the iterables are of uneven length, missing values are filled-in
    with fillvalue. Iteration continues until the longest iterable is
    exhausted.
    """
    if staticlen(iterables) == 2:
        a = iter(iterables[0])
        b = iter(iterables[1])
        a_done = False
        b_done = False

        while not a.done():
            a_val = a.next()
            b_val = fillvalue
            if not b_done:
                b_done = b.done()
            if not b_done:
                b_val = b.next()
            yield a_val, b_val

        if not b_done:
            while not b.done():
                yield fillvalue, b.next()

        a.destroy()
        b.destroy()
    else:
        iterators = tuple(iter(it) for it in iterables)
        num_active = len(iterators)
        if not num_active:
            return
        while True:
            values = []
            for it in iterators:
                if it.__done__():  # already done
                    values.append(fillvalue)
                elif it.done():  # resume and check
                    num_active -= 1
                    if not num_active:
                        return
                    values.append(fillvalue)
                else:
                    values.append(it.next())
            yield values

@inline
@overload
def zip_longest(*args):
    """
    Make an iterator that aggregates elements from each of the iterables.
    If the iterables are of uneven length, missing values are filled-in
    with fillvalue. Iteration continues until the longest iterable is
    exhausted.
    """

    def get_next(it):
        if it.__done__() or it.done():
            return None
        return it.next()

    iters = tuple(iter(arg) for arg in args)
    while True:
        done_count = 0
        result = tuple(get_next(it) for it in iters)
        all_none = True
        for a in result:
            if a is not None:
                all_none = False
        if all_none:
            return
        yield result
    for it in iters:
        it.destroy()

# Combinatoric iterators

def combinations(pool: Generator[T], r: int, T: type) -&gt; Generator[List[T]]:
    """
    Return successive r-length combinations of elements in the iterable.

    combinations(range(4), 3) --&gt; (0,1,2), (0,1,3), (0,2,3), (1,2,3)
    """

    def combinations_helper(pool: List[T], r: int, T: type) -&gt; Generator[List[T]]:
        n = len(pool)
        if r &gt; n:
            return
        indices = list(range(r))
        yield [pool[i] for i in indices]
        while True:
            b = -1
            for i in reversed(range(r)):
                if indices[i] != i + n - r:
                    b = i
                    break
            if b == -1:
                return
            indices[b] += 1
            for j in range(b + 1, r):
                indices[j] = indices[j - 1] + 1
            yield [pool[i] for i in indices]

    if r &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return combinations_helper(pool, r)
    else:
        return combinations_helper([a for a in pool], r)

def combinations_with_replacement(
    pool: Generator[T], r: int, T: type
) -&gt; Generator[List[T]]:
    """
    Return successive r-length combinations of elements in the iterable
    allowing individual elements to have successive repeats.
    """

    def combinations_with_replacement_helper(
        pool: List[T], r: int, T: type
    ) -&gt; Generator[List[T]]:
        n = len(pool)
        if not n and r:
            return
        indices = [0 for _ in range(r)]
        yield [pool[i] for i in indices]
        while True:
            b = -1
            for i in reversed(range(r)):
                if indices[i] != n - 1:
                    b = i
                    break
            if b == -1:
                return
            newval = indices[b] + 1
            for j in range(r - b):
                indices[b + j] = newval
            yield [pool[i] for i in indices]

    if r &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return combinations_with_replacement_helper(pool, r)
    else:
        return combinations_with_replacement_helper([a for a in pool], r)

def permutations(
    pool: Generator[T], r: Optional[int] = None, T: type
) -&gt; Generator[List[T]]:
    """
    Return successive r-length permutations of elements in the iterable.
    """

    def permutations_helper(
        pool: List[T], r: Optional[int], T: type
    ) -&gt; Generator[List[T]]:
        n = len(pool)
        r: int = r if r is not None else n
        if r &gt; n:
            return

        indices = list(range(n))
        cycles = list(range(n, n - r, -1))
        yield [pool[i] for i in indices[:r]]
        while n:
            b = -1
            for i in reversed(range(r)):
                cycles[i] -= 1
                if cycles[i] == 0:
                    indices = indices[:i] + indices[i + 1 :] + indices[i : i + 1]
                    cycles[i] = n - i
                else:
                    b = i
                    j = cycles[i]
                    indices[i], indices[-j] = indices[-j], indices[i]
                    yield [pool[i] for i in indices[:r]]
                    break
            if b == -1:
                return

    if r is not None and r.__val__() &lt; 0:
        raise ValueError("r must be non-negative")
    if hasattr(pool, "__getitem__") and hasattr(pool, "__len__"):
        return permutations_helper(pool, r)
    else:
        return permutations_helper([a for a in pool], r)

@inline
def product(*args):
    """
    Cartesian product of input iterables.
    """
    if staticlen(args) == 0:
        yield ()
    else:
        for a in args[0]:
            rest = args[1:]
            for b in product(*rest):
                yield (a, *b)

@inline
@overload
def product(*args, repeat: int):
    """
    Cartesian product of input iterables.
    """
    if repeat &lt; 0:
        raise ValueError("repeat argument cannot be negative")
    pools = [list(pool) for _ in range(repeat) for pool in args]
    result = [List[type(pools[0][0])]()]
    for pool in pools:
        result = [x + [y] for x in result for y in pool]
    for prod in result:
        yield prod
</t>
<t tx="ekr.20230509083243.1233">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@pure
@llvm
def _inf() -&gt; float:
    ret double 0x7FF0000000000000

@pure
@llvm
def _nan() -&gt; float:
    ret double 0x7FF8000000000000

e = 2.7182818284590452354
pi = 3.14159265358979323846
tau = 6.28318530717958647693
inf = _inf()
nan = _nan()

def factorial(x: int) -&gt; int:
    _F = (
        1,
        1,
        2,
        6,
        24,
        120,
        720,
        5040,
        40320,
        362880,
        3628800,
        39916800,
        479001600,
        6227020800,
        87178291200,
        1307674368000,
        20922789888000,
        355687428096000,
        6402373705728000,
        121645100408832000,
        2432902008176640000,
    )
    if not (0 &lt;= x &lt;= 20):
        raise ValueError("factorial is only supported for 0 &lt;= x &lt;= 20")
    return _F[x]

def isnan(x: float) -&gt; bool:
    """
    isnan(float) -&gt; bool

    Return True if float arg is a NaN, else False.
    """
    @pure
    @llvm
    def f(x: float) -&gt; bool:
        %y = fcmp uno double %x, 0.000000e+00
        %z = zext i1 %y to i8
        ret i8 %z

    return f(x)

def isinf(x: float) -&gt; bool:
    """
    isinf(float) -&gt; bool:

    Return True if float arg is an INF, else False.
    """
    @pure
    @llvm
    def f(x: float) -&gt; bool:
        declare double @llvm.fabs.f64(double)
        %a = call double @llvm.fabs.f64(double %x)
        %b = fcmp oeq double %a, 0x7FF0000000000000
        %c = zext i1 %b to i8
        ret i8 %c

    return f(x)

def isfinite(x: float) -&gt; bool:
    """
    isfinite(float) -&gt; bool

    Return True if x is neither an infinity nor a NaN,
    and False otherwise.
    """
    return not (isnan(x) or isinf(x))

def _check1(arg: float, r: float, can_overflow: bool = False):
    if __py_numerics__:
        if isnan(r) and not isnan(arg):
            raise ValueError("math domain error")

        if isinf(r) and isfinite(arg):
            if can_overflow:
                raise OverflowError("math range error")
            else:
                raise ValueError("math domain error")

    return r

def _check2(x: float, y: float, r: float, can_overflow: bool = False):
    if __py_numerics__:
        if isnan(r) and not isnan(x) and not isnan(y):
            raise ValueError("math domain error")

        if isinf(r) and isfinite(x) and isfinite(y):
            if can_overflow:
                raise OverflowError("math range error")
            else:
                raise ValueError("math domain error")

    return r

def ceil(x: float) -&gt; float:
    """
    ceil(float) -&gt; float

    Return the ceiling of x as an Integral.
    This is the smallest integer &gt;= x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.ceil.f64(double)
        %y = call double @llvm.ceil.f64(double %x)
        ret double %y

    return f(x)

def floor(x: float) -&gt; float:
    """
    floor(float) -&gt; float

    Return the floor of x as an Integral.
    This is the largest integer &lt;= x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.floor.f64(double)
        %y = call double @llvm.floor.f64(double %x)
        ret double %y

    return f(x)

def fabs(x: float) -&gt; float:
    """
    fabs(float) -&gt; float

    Returns the absolute value of a floating point number.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.fabs.f64(double)
        %y = call double @llvm.fabs.f64(double %x)
        ret double %y

    return f(x)

def fmod(x: float, y: float) -&gt; float:
    """
    fmod(float, float) -&gt; float

    Returns the remainder of x divided by y.
    """
    @pure
    @llvm
    def f(x: float, y: float) -&gt; float:
        %z = frem double %x, %y
        ret double %z

    return f(x, y)

def exp(x: float) -&gt; float:
    """
    exp(float) -&gt; float

    Returns the value of e raised to the xth power.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.exp.f64(double)
        %y = call double @llvm.exp.f64(double %x)
        ret double %y

    return _check1(x, f(x), True)

def expm1(x: float) -&gt; float:
    """
    expm1(float) -&gt; float

    Return e raised to the power x, minus 1. expm1 provides
    a way to compute this quantity to full precision.
    """
    return _check1(x, _C.expm1(x), True)

def ldexp(x: float, i: int) -&gt; float:
    """
    ldexp(float, int) -&gt; float

    Returns x multiplied by 2 raised to the power of exponent.
    """
    return _check1(x, _C.ldexp(x, i32(i)), True)

def log(x: float, base: float = e) -&gt; float:
    """
    log(float) -&gt; float

    Returns the natural logarithm (base-e logarithm) of x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.log.f64(double)
        %y = call double @llvm.log.f64(double %x)
        ret double %y

    if base == e:
        return _check1(x, f(x))
    else:
        return _check1(x, f(x)) / _check1(base, f(base))

def log2(x: float) -&gt; float:
    """
    log2(float) -&gt; float

    Return the base-2 logarithm of x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.log2.f64(double)
        %y = call double @llvm.log2.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def log10(x: float) -&gt; float:
    """
    log10(float) -&gt; float

    Returns the common logarithm (base-10 logarithm) of x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.log10.f64(double)
        %y = call double @llvm.log10.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def degrees(x: float) -&gt; float:
    """
    degrees(float) -&gt; float

    Convert angle x from radians to degrees.
    """
    radToDeg = 180.0 / pi
    return x * radToDeg

def radians(x: float) -&gt; float:
    """
    radians(float) -&gt; float

    Convert angle x from degrees to radians.
    """
    degToRad = pi / 180.0
    return x * degToRad

def sqrt(x: float) -&gt; float:
    """
    sqrt(float) -&gt; float

    Returns the square root of x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.sqrt.f64(double)
        %y = call double @llvm.sqrt.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def pow(x: float, y: float) -&gt; float:
    """
    pow(float, float) -&gt; float

    Returns x raised to the power of y.
    """
    @pure
    @llvm
    def f(x: float, y: float) -&gt; float:
        declare double @llvm.pow.f64(double, double)
        %z = call double @llvm.pow.f64(double %x, double %y)
        ret double %z

    return _check2(x, y, f(x, y), True)

def acos(x: float) -&gt; float:
    """
    acos(float) -&gt; float

    Returns the arc cosine of x in radians.
    """
    return _check1(x, _C.acos(x))

def asin(x: float) -&gt; float:
    """
    asin(float) -&gt; float

    Returns the arc sine of x in radians.
    """
    return _check1(x, _C.asin(x))

def atan(x: float) -&gt; float:
    """
    atan(float) -&gt; float

    Returns the arc tangent of x in radians.
    """
    return _check1(x, _C.atan(x))

def atan2(y: float, x: float) -&gt; float:
    """
    atan2(float, float) -&gt; float

    Returns the arc tangent in radians of y/x based
    on the signs of both values to determine the
    correct quadrant.
    """
    return _check2(x, y, _C.atan2(y, x))

def cos(x: float) -&gt; float:
    """
    cos(float) -&gt; float

    Returns the cosine of a radian angle x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.cos.f64(double)
        %y = call double @llvm.cos.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def sin(x: float) -&gt; float:
    """
    sin(float) -&gt; float

    Returns the sine of a radian angle x.
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.sin.f64(double)
        %y = call double @llvm.sin.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def hypot(x: float, y: float) -&gt; float:
    """
    hypot(float, float) -&gt; float

    Return the Euclidean norm.
    This is the length of the vector from the
    origin to point (x, y).
    """
    return _check2(x, y, _C.hypot(x, y), True)

def tan(x: float) -&gt; float:
    """
    tan(float) -&gt; float

    Return the tangent of a radian angle x.
    """
    return _check1(x, _C.tan(x))

def cosh(x: float) -&gt; float:
    """
    cosh(float) -&gt; float

    Returns the hyperbolic cosine of x.
    """
    return _check1(x, _C.cosh(x), True)

def sinh(x: float) -&gt; float:
    """
    sinh(float) -&gt; float

    Returns the hyperbolic sine of x.
    """
    return _check1(x, _C.sinh(x), True)

def tanh(x: float) -&gt; float:
    """
    tanh(float) -&gt; float

    Returns the hyperbolic tangent of x.
    """
    return _check1(x, _C.tanh(x))

def acosh(x: float) -&gt; float:
    """
    acosh(float) -&gt; float

    Return the inverse hyperbolic cosine of x.
    """
    return _check1(x, _C.acosh(x))

def asinh(x: float) -&gt; float:
    """
    asinh(float) -&gt; float

    Return the inverse hyperbolic sine of x.
    """
    return _check1(x, _C.asinh(x))

def atanh(x: float) -&gt; float:
    """
    atanh(float) -&gt; float

    Return the inverse hyperbolic tangent of x.
    """
    return _check1(x, _C.atanh(x))

def copysign(x: float, y: float) -&gt; float:
    """
    copysign(float, float) -&gt; float

    Return a float with the magnitude (absolute value) of
    x but the sign of y.
    """
    @pure
    @llvm
    def f(x: float, y: float) -&gt; float:
        declare double @llvm.copysign.f64(double, double)
        %z = call double @llvm.copysign.f64(double %x, double %y)
        ret double %z

    return _check2(x, y, f(x, y))

def log1p(x: float) -&gt; float:
    """
    log1p(float) -&gt; float

    Return the natural logarithm of 1+x (base e).
    """
    return _check1(x, _C.log1p(x))

def trunc(x: float) -&gt; float:
    """
    trunc(float) -&gt; float

    Return the Real value x truncated to an Integral
    (usually an integer).
    """
    @pure
    @llvm
    def f(x: float) -&gt; float:
        declare double @llvm.trunc.f64(double)
        %y = call double @llvm.trunc.f64(double %x)
        ret double %y

    return _check1(x, f(x))

def erf(x: float) -&gt; float:
    """
    erf(float) -&gt; float

    Return the error function at x.
    """
    return _check1(x, _C.erf(x))

def erfc(x: float) -&gt; float:
    """
    erfc(float) -&gt; float

    Return the complementary error function at x.
    """
    return _check1(x, _C.erfc(x))

def gamma(x: float) -&gt; float:
    """
    gamma(float) -&gt; float

    Return the Gamma function at x.
    """
    return _check1(x, _C.tgamma(x), True)

def lgamma(x: float) -&gt; float:
    """
    lgamma(float) -&gt; float

    Return the natural logarithm of
    the absolute value of the Gamma function at x.
    """
    return _check1(x, _C.lgamma(x), True)

def remainder(x: float, y: float) -&gt; float:
    """
    remainder(float, float) -&gt; float

    Return the IEEE 754-style remainder of x with respect to y.
    For finite x and finite nonzero y, this is the difference
    x - n*y, where n is the closest integer to the exact value
    of the quotient x / y. If x / y is exactly halfway between
    two consecutive integers, the nearest even integer is used
    for n.
    """
    return _check2(x, y, _C.remainder(x, y))

def gcd(a: float, b: float) -&gt; float:
    """
    gcd(float, float) -&gt; float

    returns greatest common divisor of x and y.
    """
    a = abs(a)
    b = abs(b)
    while a:
        a, b = b % a, a
    return b

@pure
def frexp(x: float) -&gt; Tuple[float, int]:
    """
    frexp(float) -&gt; Tuple[float, int]

    The returned value is the mantissa and the integer pointed
    to by exponent is the exponent. The resultant value is
    x = mantissa * 2 ^ exponent.
    """
    tmp = i32(0)
    res = _C.frexp(float(x), __ptr__(tmp))
    return (res, int(tmp))

@pure
def modf(x: float) -&gt; Tuple[float, float]:
    """
    modf(float) -&gt; Tuple[float, float]

    The returned value is the fraction component (part after
    the decimal), and sets integer to the integer component.
    """
    tmp = 0.0
    res = _C.modf(float(x), __ptr__(tmp))
    return (res, tmp)

def isclose(a: float, b: float, rel_tol: float = 1e-09, abs_tol: float = 0.0) -&gt; bool:
    """
    isclose(float, float) -&gt; bool

    Return True if a is close in value to b, and False otherwise.
    For the values to be considered close, the difference between them
    must be smaller than at least one of the tolerances.
    """

    # short circuit exact equality -- needed to catch two
    # infinities of the same sign. And perhaps speeds things
    # up a bit sometimes.
    if a == b:
        return True

    # This catches the case of two infinities of opposite sign, or
    # one infinity and one finite number. Two infinities of opposite
    # sign would otherwise have an infinite relative tolerance.
    # Two infinities of the same sign are caught by the equality check
    # above.
    if a == inf or b == inf:
        return False

    # NAN is not close to anything, not even itself
    if a == nan or b == nan:
        return False

    # regular computation
    diff = fabs(b - a)

    return ((diff &lt;= fabs(rel_tol * b)) or (diff &lt;= fabs(rel_tol * a))) or (
        diff &lt;= abs_tol
    )

def fsum(seq):
    def _fsum_realloc(p: Ptr[float], ps: Ptr[float], n: int, m: int):
        from internal.gc import realloc, sizeof
        v = Ptr[float]()
        m += m
        if n &lt; m:
            if p == ps:
                v = Ptr[float](m)
                str.memcpy(v.as_byte(), ps.as_byte(), n * sizeof(float))
            else:
                v = Ptr[float](realloc(p.as_byte(), m * sizeof(float), n * sizeof(float)))
        return v, m

    _NUM_PARTIALS: Static[int] = 32
    ps_arr = __array__[float](_NUM_PARTIALS)
    ps = ps_arr.ptr
    p = ps
    n, m = 0, _NUM_PARTIALS
    xsave, special_sum, inf_sum = 0.0, 0.0, 0.0
    hi, yr, lo = 0.0, 0.0, 0.0

    for item in seq:
        x = float(item)
        xsave = x
        i = 0

        for j in range(n):  # for y in partials
            y = p[j]
            if fabs(x) &lt; fabs(y):
                x, y = y, x
            hi = x + y
            yr = hi - x
            lo = y - yr
            if lo != 0.0:
                p[i] = lo
                i += 1
            x = hi

        n = i
        if x != 0.0:
            if not isfinite(x):
                # a nonfinite x could arise either as
                # a result of intermediate overflow, or
                if isfinite(xsave):
                    raise OverflowError("intermediate overflow in fsum")
                if isinf(xsave):
                    inf_sum += xsave
                special_sum += xsave
                # reset partials
                n = 0
            else:
                if n &gt;= m:
                    p, m = _fsum_realloc(p, ps, n, m)
                p[n] = x
                n += 1

    if special_sum != 0.0:
        if isnan(inf_sum):
            raise ValueError("-inf + inf in fsum")
        else:
            return special_sum

    hi = 0.0
    if n &gt; 0:
        hi = p[n - 1]
        n -= 1
        # sum_exact(ps, hi) from the top, stop when the sum becomes inexact
        while n &gt; 0:
            x = hi
            y = p[n - 1]
            n -= 1
            # assert fabs(y) &lt; fabs(x)
            hi = x + y
            yr = hi - x
            lo = y - yr
            if lo != 0.0:
                break

        # Make half-even rounding work across multiple partials.
        # Needed so that sum([1e-16, 1, 1e16]) will round-up the last
        # digit to two instead of down to zero (the 1e-16 makes the 1
        # slightly closer to two).  With a potential 1 ULP rounding
        # error fixed-up, math.fsum() can guarantee commutativity.
        if n &gt; 0 and ((lo &lt; 0.0 and p[n-1] &lt; 0.0) or (lo &gt; 0.0 and p[n-1] &gt; 0.0)):
            y = lo * 2.0
            x = hi + y
            yr = x - hi
            if y == yr:
                hi = x

    return hi

# 32-bit float ops

e32 = float32(e)
pi32 = float32(pi)
tau32 = float32(tau)

inf32 = float32(inf)
nan32 = float32(nan)

@overload
def isnan(x: float32) -&gt; bool:
    """
    isnan(float32) -&gt; bool

    Return True if float arg is a NaN, else False.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; bool:
        %y = fcmp uno float %x, 0.000000e+00
        %z = zext i1 %y to i8
        ret i8 %z

    return f(x)

@overload
def isinf(x: float32) -&gt; bool:
    """
    isinf(float32) -&gt; bool:

    Return True if float arg is an INF, else False.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; bool:
        declare float @llvm.fabs.f32(float)
        %a = call float @llvm.fabs.f32(float %x)
        %b = fcmp oeq float %a, 0x7FF0000000000000
        %c = zext i1 %b to i8
        ret i8 %c

    return f(x)

@overload
def isfinite(x: float32) -&gt; bool:
    """
    isfinite(float32) -&gt; bool

    Return True if x is neither an infinity nor a NaN,
    and False otherwise.
    """
    return not (isnan(x) or isinf(x))

@overload
def ceil(x: float32) -&gt; float32:
    """
    ceil(float32) -&gt; float32

    Return the ceiling of x as an Integral.
    This is the smallest integer &gt;= x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.ceil.f32(float)
        %y = call float @llvm.ceil.f32(float %x)
        ret float %y

    return f(x)

@overload
def floor(x: float32) -&gt; float32:
    """
    floor(float32) -&gt; float32

    Return the floor of x as an Integral.
    This is the largest integer &lt;= x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.floor.f32(float)
        %y = call float @llvm.floor.f32(float %x)
        ret float %y

    return f(x)

@overload
def fabs(x: float32) -&gt; float32:
    """
    fabs(float32) -&gt; float32

    Returns the absolute value of a float32ing point number.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.fabs.f32(float)
        %y = call float @llvm.fabs.f32(float %x)
        ret float %y

    return f(x)

@overload
def fmod(x: float32, y: float32) -&gt; float32:
    """
    fmod(float32, float32) -&gt; float32

    Returns the remainder of x divided by y.
    """
    @pure
    @llvm
    def f(x: float32, y: float32) -&gt; float32:
        %z = frem float %x, %y
        ret float %z

    return f(x, y)

@overload
def exp(x: float32) -&gt; float32:
    """
    exp(float32) -&gt; float32

    Returns the value of e raised to the xth power.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.exp.f32(float)
        %y = call float @llvm.exp.f32(float %x)
        ret float %y

    return f(x)

@overload
def expm1(x: float32) -&gt; float32:
    """
    expm1(float32) -&gt; float32

    Return e raised to the power x, minus 1. expm1 provides
    a way to compute this quantity to full precision.
    """
    return _C.expm1f(x)

@overload
def ldexp(x: float32, i: int) -&gt; float32:
    """
    ldexp(float32, int) -&gt; float32

    Returns x multiplied by 2 raised to the power of exponent.
    """
    return _C.ldexpf(x, i32(i))

@overload
def log(x: float32, base: float32 = e32) -&gt; float32:
    """
    log(float32) -&gt; float32

    Returns the natural logarithm (base-e logarithm) of x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.log.f32(float)
        %y = call float @llvm.log.f32(float %x)
        ret float %y

    if base == e32:
        return f(x)
    else:
        return f(x) / f(base)

@overload
def log2(x: float32) -&gt; float32:
    """
    log2(float32) -&gt; float32

    Return the base-2 logarithm of x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.log2.f32(float)
        %y = call float @llvm.log2.f32(float %x)
        ret float %y

    return f(x)

@overload
def log10(x: float32) -&gt; float32:
    """
    log10(float32) -&gt; float32

    Returns the common logarithm (base-10 logarithm) of x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.log10.f32(float)
        %y = call float @llvm.log10.f32(float %x)
        ret float %y

    return f(x)

@overload
def degrees(x: float32) -&gt; float32:
    """
    degrees(float32) -&gt; float32

    Convert angle x from radians to degrees.
    """
    radToDeg = float32(180.0) / pi32
    return x * radToDeg

@overload
def radians(x: float32) -&gt; float32:
    """
    radians(float32) -&gt; float32

    Convert angle x from degrees to radians.
    """
    degToRad = pi32 / float32(180.0)
    return x * degToRad

@overload
def sqrt(x: float32) -&gt; float32:
    """
    sqrt(float32) -&gt; float32

    Returns the square root of x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.sqrt.f32(float)
        %y = call float @llvm.sqrt.f32(float %x)
        ret float %y

    return f(x)

@overload
def pow(x: float32, y: float32) -&gt; float32:
    """
    pow(float32, float32) -&gt; float32

    Returns x raised to the power of y.
    """
    @pure
    @llvm
    def f(x: float32, y: float32) -&gt; float32:
        declare float @llvm.pow.f32(float, float)
        %z = call float @llvm.pow.f32(float %x, float %y)
        ret float %z

    return f(x, y)

@overload
def acos(x: float32) -&gt; float32:
    """
    acos(float32) -&gt; float32

    Returns the arc cosine of x in radians.
    """
    return _C.acosf(x)

@overload
def asin(x: float32) -&gt; float32:
    """
    asin(float32) -&gt; float32

    Returns the arc sine of x in radians.
    """
    return _C.asinf(x)

@overload
def atan(x: float32) -&gt; float32:
    """
    atan(float32) -&gt; float32

    Returns the arc tangent of x in radians.
    """
    return _C.atanf(x)

@overload
def atan2(y: float32, x: float32) -&gt; float32:
    """
    atan2(float32, float32) -&gt; float32

    Returns the arc tangent in radians of y/x based
    on the signs of both values to determine the
    correct quadrant.
    """
    return _C.atan2f(y, x)

@overload
def cos(x: float32) -&gt; float32:
    """
    cos(float32) -&gt; float32

    Returns the cosine of a radian angle x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.cos.f32(float)
        %y = call float @llvm.cos.f32(float %x)
        ret float %y

    return f(x)

@overload
def sin(x: float32) -&gt; float32:
    """
    sin(float32) -&gt; float32

    Returns the sine of a radian angle x.
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.sin.f32(float)
        %y = call float @llvm.sin.f32(float %x)
        ret float %y

    return f(x)

@overload
def hypot(x: float32, y: float32) -&gt; float32:
    """
    hypot(float32, float32) -&gt; float32

    Return the Euclidean norm.
    This is the length of the vector from the
    origin to point (x, y).
    """
    return _C.hypotf(x, y)

@overload
def tan(x: float32) -&gt; float32:
    """
    tan(float32) -&gt; float32

    Return the tangent of a radian angle x.
    """
    return _C.tanf(x)

@overload
def cosh(x: float32) -&gt; float32:
    """
    cosh(float32) -&gt; float32

    Returns the hyperbolic cosine of x.
    """
    return _C.coshf(x)

@overload
def sinh(x: float32) -&gt; float32:
    """
    sinh(float32) -&gt; float32

    Returns the hyperbolic sine of x.
    """
    return _C.sinhf(x)

@overload
def tanh(x: float32) -&gt; float32:
    """
    tanh(float32) -&gt; float32

    Returns the hyperbolic tangent of x.
    """
    return _C.tanhf(x)

@overload
def acosh(x: float32) -&gt; float32:
    """
    acosh(float32) -&gt; float32

    Return the inverse hyperbolic cosine of x.
    """
    return _C.acoshf(x)

@overload
def asinh(x: float32) -&gt; float32:
    """
    asinh(float32) -&gt; float32

    Return the inverse hyperbolic sine of x.
    """
    return _C.asinhf(x)

@overload
def atanh(x: float32) -&gt; float32:
    """
    atanh(float32) -&gt; float32

    Return the inverse hyperbolic tangent of x.
    """
    return _C.atanhf(x)

@overload
def copysign(x: float32, y: float32) -&gt; float32:
    """
    copysign(float32, float32) -&gt; float32

    Return a float32 with the magnitude (absolute value) of
    x but the sign of y.
    """
    @pure
    @llvm
    def f(x: float32, y: float32) -&gt; float32:
        declare float @llvm.copysign.f32(float, float)
        %z = call float @llvm.copysign.f32(float %x, float %y)
        ret float %z

    return f(x, y)

@overload
def log1p(x: float32) -&gt; float32:
    """
    log1p(float32) -&gt; float32

    Return the natural logarithm of 1+x (base e).
    """
    return _C.log1pf(x)

@overload
def trunc(x: float32) -&gt; float32:
    """
    trunc(float32) -&gt; float32

    Return the Real value x truncated to an Integral
    (usually an integer).
    """
    @pure
    @llvm
    def f(x: float32) -&gt; float32:
        declare float @llvm.trunc.f32(float)
        %y = call float @llvm.trunc.f32(float %x)
        ret float %y

    return f(x)

@overload
def erf(x: float32) -&gt; float32:
    """
    erf(float32) -&gt; float32

    Return the error function at x.
    """
    return _C.erff(x)

@overload
def erfc(x: float32) -&gt; float32:
    """
    erfc(float32) -&gt; float32

    Return the complementary error function at x.
    """
    return _C.erfcf(x)

@overload
def gamma(x: float32) -&gt; float32:
    """
    gamma(float32) -&gt; float32

    Return the Gamma function at x.
    """
    return _C.tgammaf(x)

@overload
def lgamma(x: float32) -&gt; float32:
    """
    lgamma(float32) -&gt; float32

    Return the natural logarithm of
    the absolute value of the Gamma function at x.
    """
    return _C.lgammaf(x)

@overload
def remainder(x: float32, y: float32) -&gt; float32:
    """
    remainder(float32, float32) -&gt; float32

    Return the IEEE 754-style remainder of x with respect to y.
    For finite x and finite nonzero y, this is the difference
    x - n*y, where n is the closest integer to the exact value
    of the quotient x / y. If x / y is exactly halfway between
    two consecutive integers, the nearest even integer is used
    for n.
    """
    return _C.remainderf(x, y)

@overload
def gcd(a: float32, b: float32) -&gt; float32:
    """
    gcd(float32, float32) -&gt; float32

    returns greatest common divisor of x and y.
    """
    a = abs(a)
    b = abs(b)
    while a:
        a, b = b % a, a
    return b

@overload
@pure
def frexp(x: float32) -&gt; Tuple[float32, int]:
    """
    frexp(float32) -&gt; Tuple[float32, int]

    The returned value is the mantissa and the integer pointed
    to by exponent is the exponent. The resultant value is
    x = mantissa * 2 ^ exponent.
    """
    tmp = i32(0)
    res = _C.frexpf(float32(x), __ptr__(tmp))
    return (res, int(tmp))

@overload
@pure
def modf(x: float32) -&gt; Tuple[float32, float32]:
    """
    modf(float32) -&gt; Tuple[float32, float32]

    The returned value is the fraction component (part after
    the decimal), and sets integer to the integer component.
    """
    tmp = float32(0.0)
    res = _C.modff(float32(x), __ptr__(tmp))
    return (res, tmp)

@overload
def isclose(a: float32, b: float32, rel_tol: float32 = float32(1e-09), abs_tol: float32 = float32(0.0)) -&gt; bool:
    """
    isclose(float32, float32) -&gt; bool

    Return True if a is close in value to b, and False otherwise.
    For the values to be considered close, the difference between them
    must be smaller than at least one of the tolerances.
    """

    # short circuit exact equality -- needed to catch two
    # infinities of the same sign. And perhaps speeds things
    # up a bit sometimes.
    if a == b:
        return True

    # This catches the case of two infinities of opposite sign, or
    # one infinity and one finite number. Two infinities of opposite
    # sign would otherwise have an infinite relative tolerance.
    # Two infinities of the same sign are caught by the equality check
    # above.
    if a == inf32 or b == inf32:
        return False

    # NAN is not close to anything, not even itself
    if a == nan32 or b == nan32:
        return False

    # regular computation
    diff = fabs(b - a)

    return ((diff &lt;= fabs(rel_tol * b)) or (diff &lt;= fabs(rel_tol * a))) or (
        diff &lt;= abs_tol
    )
</t>
<t tx="ekr.20230509083243.1234">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# OpenMP interface
# Ref: https://github.com/llvm/llvm-project/tree/main/openmp

Routine = Function[[i32, cobj], i32]

_KMP_IDENT_IMB = 0x01
_KMP_IDENT_KMPC = 0x02
_KMP_IDENT_AUTOPAR = 0x08
_KMP_IDENT_ATOMIC_REDUCE = 0x10
_KMP_IDENT_BARRIER_EXPL = 0x20
_KMP_IDENT_BARRIER_IMPL = 0x0040
_KMP_IDENT_BARRIER_IMPL_MASK = 0x01C0
_KMP_IDENT_BARRIER_IMPL_FOR = 0x0040
_KMP_IDENT_BARRIER_IMPL_SECTIONS = 0x00C0
_KMP_IDENT_BARRIER_IMPL_SINGLE = 0x0140
_KMP_IDENT_BARRIER_IMPL_WORKSHARE = 0x01C0
_KMP_IDENT_WORK_LOOP = 0x200
_KMP_IDENT_WORK_SECTIONS = 0x400
_KMP_IDENT_WORK_DISTRIBUTE = 0x800
_KMP_IDENT_ATOMIC_HINT_MASK = 0xFF0000
_KMP_IDENT_ATOMIC_HINT_UNCONTENDED = 0x010000
_KMP_IDENT_ATOMIC_HINT_CONTENDED = 0x020000
_KMP_IDENT_ATOMIC_HINT_NONSPECULATIVE = 0x040000
_KMP_IDENT_ATOMIC_HINT_SPECULATIVE = 0x080000
_KMP_IDENT_OPENMP_SPEC_VERSION_MASK = 0xFF000000

@tuple
class Lock:
    a1: i32
    a2: i32
    a3: i32
    a4: i32
    a5: i32
    a6: i32
    a7: i32
    a8: i32

    def __new__() -&gt; Lock:
        z = i32(0)
        return Lock(z, z, z, z, z, z, z, z)

@tuple
class Ident:
    reserved_1: i32
    flags: i32
    reserved_2: i32
    reserved_3: i32
    psource: cobj

    def __new__(flags: int = 0, source: str = ";unknown;unknown;0;0;;") -&gt; Ident:
        return Ident(i32(0), i32(flags | _KMP_IDENT_KMPC), i32(0), i32(0), source.ptr)

@tuple
class LRData:
    routine: Routine

@tuple
class Task:
    shareds: cobj
    routine: Routine
    flags: i32
    x: LRData
    y: LRData

@tuple
class TaskWithPrivates:
    task: Task
    data: T
    T: type

@tuple
class TaskReductionInput:
    reduce_shar: cobj
    reduce_orig: cobj
    reduce_size: int
    reduce_init: cobj
    reduce_fini: cobj
    reduce_comb: cobj
    flags: u32

    def __new__(reduce_shar, reduce_orig, reduce_size: int,
                reduce_init: cobj, reduce_comb: cobj):
        return TaskReductionInput(reduce_shar.as_byte(), reduce_orig.as_byte(), reduce_size,
                                  reduce_init, cobj(), reduce_comb, u32(0))

@tuple
class TaskReductionInputArray:
    len: int
    ptr: Ptr[TaskReductionInput]

    def __setitem__(self, idx: int, x: TaskReductionInput):
        self.ptr[idx] = x

_DEFAULT_IDENT = Ident()
_STATIC_LOOP_IDENT = Ident(_KMP_IDENT_WORK_LOOP)
_REDUCTION_IDENT = Ident(_KMP_IDENT_ATOMIC_REDUCE)

def _default_loc():
    return __ptr__(_DEFAULT_IDENT)

_default_loc()

def _static_loop_loc():
    return __ptr__(_STATIC_LOOP_IDENT)

_static_loop_loc()

def _reduction_loc():
    return __ptr__(_REDUCTION_IDENT)

_reduction_loc()

def _critical_begin(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_critical(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_critical(loc_ref, i32(gtid), lck)

def _critical_end(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_end_critical(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_end_critical(loc_ref, i32(gtid), lck)

def _single_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_single(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_single(loc_ref, i32(gtid)))

def _single_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_single(Ptr[Ident], i32)
    __kmpc_end_single(loc_ref, i32(gtid))

def _master_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_master(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_master(loc_ref, i32(gtid)))

def _master_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_master(Ptr[Ident], i32)
    __kmpc_end_master(loc_ref, i32(gtid))

def _ordered_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_ordered(Ptr[Ident], i32) -&gt; i32
    return int(__kmpc_ordered(loc_ref, i32(gtid)))

def _ordered_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_ordered(Ptr[Ident], i32)
    __kmpc_end_ordered(loc_ref, i32(gtid))

def _taskwait(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_omp_taskwait(Ptr[Ident], i32)
    __kmpc_omp_taskwait(loc_ref, i32(gtid))

def _taskgroup_begin(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_taskgroup(Ptr[Ident], i32)
    __kmpc_taskgroup(loc_ref, i32(gtid))

def _taskgroup_end(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_end_taskgroup(Ptr[Ident], i32)
    __kmpc_end_taskgroup(loc_ref, i32(gtid))

def _task_alloc_size(
    size_of_task: int,
    size_of_shareds: int,
):
    from C import __kmpc_omp_task_alloc_size(int, int) -&gt; int
    return __kmpc_omp_task_alloc_size(size_of_task, size_of_shareds)

def _task_alloc(
    loc_ref: Ptr[Ident],
    gtid: int,
    flags: int,
    size_of_task: int,
    size_of_shareds: int,
    task_entry: Routine,
):
    from internal.gc import alloc
    from C import __kmpc_omp_task_alloc(Ptr[Ident], i32, i32, int, int, Routine, cobj) -&gt; cobj

    taskdata = alloc(_task_alloc_size(size_of_task, size_of_shareds))
    return __kmpc_omp_task_alloc(
        loc_ref, i32(gtid), i32(flags), size_of_task, size_of_shareds, task_entry, taskdata
    )

def _task_run(loc_ref: Ptr[Ident], gtid: int, new_task: cobj):
    from C import __kmpc_omp_task(Ptr[Ident], i32, cobj) -&gt; i32
    return int(__kmpc_omp_task(loc_ref, i32(gtid), new_task))

def _barrier(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_barrier(Ptr[Ident], i32)
    __kmpc_barrier(loc_ref, i32(gtid))

def _flush(loc_ref: Ptr[Ident]):
    from C import __kmpc_flush(Ptr[Ident])
    __kmpc_flush(loc_ref)

def flush():
    _flush(_default_loc())

def _static_init(
    loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, incr: int, chunk: int
):
    from C import __kmpc_for_static_init_8(Ptr[Ident], i32, i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int], int, int)
    last = i32(0)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_for_static_init_8(
        loc_ref,
        i32(gtid),
        i32(schedtype),
        __ptr__(last),
        __ptr__(lower),
        __ptr__(upper),
        __ptr__(stride),
        incr,
        chunk,
    )
    return bool(last), range(loop._get(lower), loop._get(upper + 1), loop.step), stride

def _static_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_for_static_fini(Ptr[Ident], i32)
    __kmpc_for_static_fini(loc_ref, i32(gtid))

def _dynamic_init(
    loc_ref: Ptr[Ident], gtid: int, schedtype: int, loop: range, chunk: int
):
    from C import __kmpc_dispatch_init_8(Ptr[Ident], i32, i32, int, int, int, int)
    lower = 0
    upper = len(loop) - 1
    stride = 1
    __kmpc_dispatch_init_8(
        loc_ref, i32(gtid), i32(schedtype), lower, upper, stride, chunk
    )

def _dynamic_next(loc_ref: Ptr[Ident], gtid: int, loop: range):
    from C import __kmpc_dispatch_next_8(Ptr[Ident], i32, Ptr[i32], Ptr[int], Ptr[int], Ptr[int]) -&gt; i32
    last = i32(0)
    lower = 0
    upper = 0
    stride = 0
    more = __kmpc_dispatch_next_8(
        loc_ref,
        i32(gtid),
        __ptr__(last),
        __ptr__(lower),
        __ptr__(upper),
        __ptr__(stride),
    )
    return (
        bool(more),
        bool(last),
        range(loop._get(lower), loop._get(upper + 1), loop.step),
    )

def _dynamic_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_dispatch_fini_8(Ptr[Ident], i32)
    __kmpc_dispatch_fini_8(loc_ref, i32(gtid))

def _reduce(
    loc_ref: Ptr[Ident],
    gtid: int,
    reduce_data: T,
    reduce_func: cobj,
    lck: cobj,
    T: type,
):
    from internal.gc import sizeof

    from C import __kmpc_reduce(Ptr[Ident], i32, i32, int, cobj, cobj, cobj) -&gt; i32
    num_vars = staticlen(reduce_data)
    reduce_size = sizeof(T)
    return int(
        __kmpc_reduce(
            loc_ref,
            i32(gtid),
            i32(num_vars),
            reduce_size,
            __ptr__(reduce_data).as_byte(),
            reduce_func,
            lck,
        )
    )

def _end_reduce(loc_ref: Ptr[Ident], gtid: int, lck: cobj):
    from C import __kmpc_end_reduce(Ptr[Ident], i32, cobj)
    __kmpc_end_reduce(loc_ref, i32(gtid), lck)

def _reduce_nowait(
    loc_ref: Ptr[Ident],
    gtid: int,
    reduce_data: T,
    reduce_func: cobj,
    lck: Ptr[Lock],
    T: type,
):
    from internal.gc import sizeof

    from C import __kmpc_reduce_nowait(Ptr[Ident], i32, i32, int, cobj, cobj, Ptr[Lock]) -&gt; i32
    num_vars = staticlen(reduce_data)
    reduce_size = sizeof(T)
    return int(
        __kmpc_reduce_nowait(
            loc_ref,
            i32(gtid),
            i32(num_vars),
            reduce_size,
            __ptr__(reduce_data).as_byte(),
            reduce_func,
            lck,
        )
    )

def _end_reduce_nowait(loc_ref: Ptr[Ident], gtid: int, lck: Ptr[Lock]):
    from C import __kmpc_end_reduce_nowait(Ptr[Ident], i32, Ptr[Lock])
    __kmpc_end_reduce_nowait(loc_ref, i32(gtid), lck)

def _taskred_init(loc_ref: Ptr[Ident], gtid: int, num: int, data):
    from C import __kmpc_taskred_modifier_init(Ptr[Ident], i32, i32, i32, cobj) -&gt; cobj
    return __kmpc_taskred_modifier_init(loc_ref, i32(gtid), i32(0), i32(num), data.as_byte())

def _taskred_fini(loc_ref: Ptr[Ident], gtid: int):
    from C import __kmpc_task_reduction_modifier_fini(Ptr[Ident], i32, i32)
    __kmpc_task_reduction_modifier_fini(loc_ref, i32(gtid), i32(0))

# add tskgrp arg?
def _taskred_data(gtid: int, data):
    from C import __kmpc_task_reduction_get_th_data(i32, cobj, cobj) -&gt; cobj
    T = type(data)
    return T(__kmpc_task_reduction_get_th_data(i32(gtid), cobj(), data.as_byte()))

def _fork_call(microtask: cobj, args):
    from C import __kmpc_fork_call(Ptr[Ident], i32, cobj, ...)
    loc_ref = _default_loc()  # TODO: pass real loc?
    __kmpc_fork_call(loc_ref, i32(1), microtask, __ptr__(args))

def _static_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @nonpure
    def _loop_step():
        return 1

    @nonpure
    def _loop_loc_and_gtid(
        loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
    ):
        pass

    @nonpure
    def _loop_body_stub(i, args):
        pass

    @nonpure
    def _loop_schedule():
        return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

    @nonpure
    def _loop_shared_updates(args):
        pass

    @nonpure
    def _loop_reductions(args):
        pass

    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    static_loop_loc_ref = _static_loop_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()

    last, subloop, stride = _static_init(
        static_loop_loc_ref, gtid, schedtype=schedule, loop=loop, incr=1, chunk=1
    )
    i = subloop.start
    stop = min(subloop.stop, loop.stop) if step &gt;= 0 else max(subloop.stop, loop.stop)

    while (step &gt;= 0 and i &lt; stop) or (step &lt; 0 and i &gt; stop):
        _loop_body_stub(i, extra)
        i += step
    _static_fini(static_loop_loc_ref, gtid)

    if last:
        _loop_shared_updates(extra)

    _loop_reductions(extra)

def _static_chunked_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @nonpure
    def _loop_step():
        return 1

    @nonpure
    def _loop_loc_and_gtid(
        loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
    ):
        pass

    @nonpure
    def _loop_body_stub(i, args):
        pass

    @nonpure
    def _loop_schedule():
        return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

    @nonpure
    def _loop_shared_updates(args):
        pass

    @nonpure
    def _loop_reductions(args):
        pass

    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    static_loop_loc_ref = _static_loop_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()

    last, subloop, stride = _static_init(
        static_loop_loc_ref, gtid, schedtype=schedule, loop=loop, incr=1, chunk=chunk
    )
    start = subloop.start
    stop = min(subloop.stop, loop.stop) if step &gt;= 0 else max(subloop.stop, loop.stop)

    while (step &gt;= 0 and start &lt; loop.stop) or (step &lt; 0 and start &gt; loop.stop):
        i = start
        while (step &gt;= 0 and i &lt; stop) or (step &lt; 0 and i &gt; stop):
            _loop_body_stub(i, extra)
            i += step

        start += stride * step
        stop += stride * step
        stop = min(stop, loop.stop) if step &gt;= 0 else max(stop, loop.stop)
    _static_fini(static_loop_loc_ref, gtid)

    if last:
        _loop_shared_updates(extra)

    _loop_reductions(extra)

def _dynamic_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    @nonpure
    def _loop_step():
        return 1

    @nonpure
    def _loop_loc_and_gtid(
        loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
    ):
        pass

    @nonpure
    def _loop_body_stub(i, args):
        pass

    @nonpure
    def _loop_schedule():
        return (1 &lt;&lt; 30) | 35  # nonmonotonic, dynamic chunked

    @nonpure
    def _loop_shared_updates(args):
        pass

    @nonpure
    def _loop_reductions(args):
        pass

    @nonpure
    def _loop_ordered():
        return False

    chunk, start, stop, extra = args[0]
    step = _loop_step()
    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)
    loop = range(start, stop, step)
    schedule = _loop_schedule()
    ordered = _loop_ordered()

    _dynamic_init(loc_ref, gtid, schedtype=schedule, loop=loop, chunk=chunk)
    while True:
        more, last, subloop = _dynamic_next(loc_ref, gtid, loop)
        if not more:
            break
        i = subloop.start
        while (step &gt;= 0 and i &lt; subloop.stop) or (step &lt; 0 and i &gt; subloop.stop):
            _loop_body_stub(i, extra)
            i += step
            if ordered:
                _dynamic_fini(loc_ref, gtid)
        if last:
            _loop_shared_updates(extra)

    _loop_reductions(extra)

# P = privates; tuple of types
# S = shareds; tuple of pointers
def _spawn_and_run_task(
    loc_ref: Ptr[Ident], gtid: int, routine: cobj, priv: P, shared: S, P: type, S: type
):
    from internal.gc import sizeof

    TaskThunk = TaskWithPrivates[P]
    flags = 1
    size_of_kmp_task_t = sizeof(TaskThunk)
    size_of_privs = sizeof(P)
    size_of_shareds = sizeof(S)
    loc_ref = _default_loc()

    task = Ptr[TaskThunk](
        _task_alloc(
            loc_ref, gtid, flags, size_of_kmp_task_t, size_of_shareds, Routine(routine)
        )
    )
    if staticlen(shared) != 0:
        shared_ptr = task[0].task.shareds
        str.memcpy(shared_ptr, __ptr__(shared).as_byte(), size_of_shareds)
    if staticlen(priv) != 0:
        priv_ptr = task.as_byte() + sizeof(Task)
        str.memcpy(priv_ptr, __ptr__(priv).as_byte(), size_of_privs)

    _task_run(loc_ref, gtid, task.as_byte())

# Note: this is different than OpenMP's "taskloop" -- this template simply
# spawns a new task for each loop iteration.
def _task_loop_outline_template(gtid_ptr: Ptr[i32], btid_ptr: Ptr[i32], args):
    def _routine_stub(gtid: i32, data: cobj, P: type, S: type):
        @nonpure
        def _task_loop_body_stub(gtid: int, priv, shared):
            pass

        task = Ptr[TaskWithPrivates[P]](data)[0]
        priv = task.data
        gtid64 = int(gtid)
        if staticlen(S()) != 0:
            shared = Ptr[S](task.task.shareds)[0]
            _task_loop_body_stub(gtid64, priv, shared)
        else:
            shared = ()
            _task_loop_body_stub(gtid64, priv, shared)
        return i32(0)

    @nonpure
    def _loop_loc_and_gtid(
        loc_ref: Ptr[Ident], reduction_loc_ref: Ptr[Ident], gtid: int
    ):
        pass

    @nonpure
    def _fix_privates_and_shareds(i, priv, shared):
        return priv, shared

    @nonpure
    def _taskred_setup(args):
        pass

    @nonpure
    def _taskred_finish():
        pass

    @nonpure
    def _loop_reductions(args):
        pass

    iterable, priv, shared = args[0]
    P = type(priv)
    S = type(shared)

    gtid = int(gtid_ptr[0])
    loc_ref = _default_loc()
    reduction_loc_ref = _reduction_loc()
    _loop_loc_and_gtid(loc_ref, reduction_loc_ref, gtid)

    _taskred_setup(shared)

    if _single_begin(loc_ref, gtid) != 0:
        _taskgroup_begin(loc_ref, gtid)
        try:
            for i in iterable:
                priv_fixed, shared_fixed = _fix_privates_and_shareds(i, priv, shared)
                _spawn_and_run_task(
                    loc_ref, gtid, _routine_stub(P=P, S=S, ...).__raw__(), priv_fixed, shared_fixed
                )
        finally:
            _taskgroup_end(loc_ref, gtid)
            _single_end(loc_ref, gtid)

    _taskred_finish()
    _loop_reductions(shared)
    _barrier(loc_ref, gtid)

@pure
def get_num_threads():
    from C import omp_get_num_threads() -&gt; i32
    return int(omp_get_num_threads())

@pure
def get_thread_num():
    from C import omp_get_thread_num() -&gt; i32
    return int(omp_get_thread_num())

@pure
def get_max_threads():
    from C import omp_get_max_threads() -&gt; i32
    return int(omp_get_max_threads())

@pure
def get_num_procs():
    from C import omp_get_num_procs() -&gt; i32
    return int(omp_get_num_procs())

def set_num_threads(num_threads: int):
    from C import omp_set_num_threads(i32)
    omp_set_num_threads(i32(num_threads))

@pure
def in_parallel():
    from C import omp_in_parallel() -&gt; i32
    return bool(omp_in_parallel())

def set_dynamic(dynamic_threads: bool = True):
    from C import omp_set_dynamic(i32)
    omp_set_dynamic(i32(1 if dynamic_threads else 0))

@pure
def get_dynamic():
    from C import omp_get_dynamic() -&gt; i32
    return bool(omp_get_dynamic())

@pure
def get_cancellation():
    from C import omp_get_cancellation() -&gt; i32
    return bool(omp_get_cancellation())

def set_schedule(kind: str, chunk_size: int = 0):
    from C import omp_set_schedule(i32, i32)
    if kind == "static":
        omp_set_schedule(i32(1), i32(chunk_size))
    elif kind == "dynamic":
        omp_set_schedule(i32(2), i32(chunk_size))
    elif kind == "guided":
        omp_set_schedule(i32(3), i32(chunk_size))
    elif kind == "auto":
        if chunk_size != 0:
            raise ValueError("cannot specify chunk size for auto schedule")
        omp_set_schedule(i32(4), i32(chunk_size))
    else:
        raise ValueError(
            "invalid schedule kind; valid ones are: 'static', 'dynamic', 'guided', 'auto'"
        )

@pure
def get_schedule():
    from C import omp_get_schedule(Ptr[i32], Ptr[i32])
    kind_code = i32(0)
    chunk_size = i32(0)
    omp_get_schedule(__ptr__(kind_code), __ptr__(chunk_size))
    idx = int(kind_code)
    kind = (
        ("static", "dynamic", "guided", "auto")[idx - 1] if 1 &lt; idx &lt;= 4 else "unknown"
    )
    return kind, int(chunk_size)

@pure
def get_thread_limit():
    from C import omp_get_thread_limit() -&gt; i32
    return int(omp_get_thread_limit())

def set_max_active_levels(max_levels: int):
    from C import omp_set_max_active_levels(i32)
    omp_set_max_active_levels(i32(max_levels))

@pure
def get_max_active_levels():
    from C import omp_get_max_active_levels() -&gt; i32
    return int(omp_get_max_active_levels())

@pure
def get_level():
    from C import omp_get_level() -&gt; i32
    return int(omp_get_level())

@pure
def get_ancestor_thread_num(level: int):
    from C import omp_get_ancestor_thread_num(i32) -&gt; i32
    return int(omp_get_ancestor_thread_num(i32(level)))

@pure
def get_team_size(level: int):
    from C import omp_get_team_size(i32) -&gt; i32
    return int(omp_get_team_size(i32(level)))

@pure
def get_active_level():
    from C import omp_get_active_level() -&gt; i32
    return int(omp_get_active_level())

@pure
def in_final():
    from C import omp_in_final() -&gt; i32
    return bool(omp_in_final())

@pure
def get_proc_bind():
    from C import omp_get_proc_bind() -&gt; i32
    result = int(omp_get_proc_bind())
    if result &lt; 0 or result &gt; 4:
        return "unknown"
    return ("false", "true", "master", "close", "spread")[result]

def set_default_device(device_num: int):
    from C import omp_set_default_device(i32)
    omp_set_default_device(i32(device_num))

@pure
def get_default_device():
    from C import omp_get_default_device() -&gt; i32
    return int(omp_get_default_device())

@pure
def get_num_devices():
    from C import omp_get_num_devices() -&gt; i32
    return int(omp_get_num_devices())

@pure
def get_num_teams():
    from C import omp_get_num_teams() -&gt; i32
    return int(omp_get_num_teams())

@pure
def get_team_num():
    from C import omp_get_team_num() -&gt; i32
    return int(omp_get_team_num())

@pure
def is_initial_device():
    from C import omp_is_initial_device() -&gt; i32
    return bool(omp_is_initial_device())

@pure
def get_wtime():
    from C import omp_get_wtime() -&gt; float
    return omp_get_wtime()

@pure
def get_wtick():
    from C import omp_get_wtick() -&gt; float
    return omp_get_wtick()

def single(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _single_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _single_end(loc, gtid)

    return _wrapper

def master(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _master_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _master_end(loc, gtid)

    return _wrapper

def ordered(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        if _ordered_begin(loc, gtid) != 0:
            try:
                func(*args, **kwargs)
            finally:
                _ordered_end(loc, gtid)

    return _wrapper

_default_lock = Lock()

def critical(func):
    def _wrapper(*args, **kwargs):
        gtid = get_thread_num()
        loc = _default_loc()
        _critical_begin(loc, gtid, __ptr__(_default_lock))
        try:
            func(*args, **kwargs)
        finally:
            _critical_end(loc, gtid, __ptr__(_default_lock))

    return _wrapper

def _push_num_threads(num_threads: int):
    from C import __kmpc_push_num_threads(Ptr[Ident], i32, i32)
    gtid = get_thread_num()
    loc = _default_loc()
    __kmpc_push_num_threads(loc, i32(gtid), i32(num_threads))

@llvm
def _atomic_int_add(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw add ptr %a, i64 %b monotonic
    ret {} {}

def _atomic_int_mul(a: Ptr[int], b: int):
    from C import __kmpc_atomic_fixed8_mul(Ptr[Ident], i32, Ptr[int], int)
    __kmpc_atomic_fixed8_mul(_default_loc(), i32(0), a, b)

@llvm
def _atomic_int_and(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw and ptr %a, i64 %b monotonic
    ret {} {}

@llvm
def _atomic_int_or(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw or ptr %a, i64 %b monotonic
    ret {} {}

@llvm
def _atomic_int_xor(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw xor ptr %a, i64 %b monotonic
    ret {} {}

@llvm
def _atomic_int_min(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw min ptr %a, i64 %b monotonic
    ret {} {}

@llvm
def _atomic_int_max(a: Ptr[int], b: int) -&gt; None:
    %old = atomicrmw max ptr %a, i64 %b monotonic
    ret {} {}

def _atomic_float_add(a: Ptr[float], b: float) -&gt; None:
    from C import __kmpc_atomic_float8_add(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_add(_default_loc(), i32(0), a, b)

def _atomic_float_mul(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_mul(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_mul(_default_loc(), i32(0), a, b)

def _atomic_float_min(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_min(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_min(_default_loc(), i32(0), a, b)

def _atomic_float_max(a: Ptr[float], b: float):
    from C import __kmpc_atomic_float8_max(Ptr[Ident], i32, Ptr[float], float)
    __kmpc_atomic_float8_max(_default_loc(), i32(0), a, b)

def _atomic_float32_add(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_add(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_add(_default_loc(), i32(0), a, b)

def _atomic_float32_mul(a: Ptr[float32], b: float32):
    from C import __kmpc_atomic_float4_mul(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_mul(_default_loc(), i32(0), a, b)

def _atomic_float32_min(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_min(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_min(_default_loc(), i32(0), a, b)

def _atomic_float32_max(a: Ptr[float32], b: float32) -&gt; None:
    from C import __kmpc_atomic_float4_max(Ptr[Ident], i32, Ptr[float32], float32)
    __kmpc_atomic_float4_max(_default_loc(), i32(0), a, b)

def _range_len(start: int, stop: int, step: int):
    if step &gt; 0 and start &lt; stop:
        return 1 + (stop - 1 - start) // step
    elif step &lt; 0 and start &gt; stop:
        return 1 + (start - 1 - stop) // (-step)
    else:
        return 0

def for_par(
    num_threads: int = -1,
    chunk_size: int = -1,
    schedule: Static[str] = "static",
    ordered: Static[int] = False,
    collapse: Static[int] = 0,
    gpu: Static[int] = False,
):
    pass
</t>
<t tx="ekr.20230509083243.1235">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

lt = lambda a, b: a &lt; b
le = lambda a, b: a &lt;= b
eq = lambda a, b: a == b
ne = lambda a, b: a != b
gt = lambda a, b: a &gt; b
ge = lambda a, b: a &gt;= b
__lt__ = lt
__le__ = le
__eq__ = eq
__ne__ = ne
__gt__ = gt
__ge__ = ge

def not_(a) -&gt; bool:
    if hasattr(a, "__bool__"):
        return not bool(a)
    elif hasattr(a, "__len__"):
        return len(a) == 0
    else:
        compile_error("argument has no __bool__ or __len__ methods")

def truth(a) -&gt; bool:
    return bool(a)

def is_(a, b) -&gt; bool:
    return a is b

def is_not(a, b) -&gt; bool:
    return a is not b

def abs(a):
    return a.__abs__()

__abs__ = abs

def add(a, b):
    return a + b

__add__ = add

def and_(a, b):
    return a &amp; b

__and__ = and_

def floordiv(a, b):
    return a // b

__floordiv__ = floordiv

def index(a):
    return a.__index__()

__index__ = index

def inv(a):
    return ~a

invert = inv
__inv__ = inv
__invert__ = inv

def lshift(a, b):
    return a &lt;&lt; b

__lshift__ = lshift

def mod(a, b):
    return a % b

__mod__ = mod

def mul(a, b):
    return a * b

__mul__ = mul

def matmul(a, b):
    return a @ b

__matmul__ = matmul

def neg(a):
    return -a

__neg__ = neg

def or_(a, b):
    return a | b

__or__ = or_

def pos(a):
    return +a

__pos__ = pos

def pow(a, b):
    return a ** b

__pow__ = pow

def rshift(a, b):
    return a &gt;&gt; b

__rshift__ = rshift

def sub(a, b):
    return a - b

__sub__ = sub

def truediv(a, b):
    return a / b

__truediv__ = truediv

def xor(a, b):
    return a ^ b

__xor__ = xor

def concat(a, b):
    return a + b

__concat__ = concat

def contains(a, b):
    return b in a  # intentionally reversed

__contains__ = contains

def countOf(a, b):
    n = 0
    for x in a:
        if x == b:
            n += 1
    return n

def delitem(a, b):
    del a[b]

__delitem__ = delitem

def getitem(a, b):
    return a[b]

__getitem__ = getitem

def indexOf(a, b):
    n = 0
    for x in a:
        if x == b:
            return n
        n += 1
    raise ValueError(f"sequence.index(x): x not in sequence")

def setitem(a, b, c):
    a[b] = c

__setitem__ = setitem

def length_hint(a, default=0):
    if hasattr(a, "__len__"):
        return len(a)
    elif hasattr(a, "__length_hint__"):
        return a.__length_hint__()
    else:
        return default

def attrgetter(attr: Static[str]):
    def getter(obj):
        return getattr(obj, attr)
    return getter

def itemgetter(*items):
    if staticlen(items) == 1:
        item = items[0]

        def g(obj):
            return obj[item]

        return g
    else:

        def g(obj):
            return tuple(obj[item] for item in items)

        return g

def methodcaller(name: Static[str], *args, **kwargs):
    def caller(obj):
        return getattr(obj, name)(*args, **kwargs)
    return caller

def iadd(a, b):
    a += b
    return a

__iadd__ = iadd

def iand(a, b):
    a &amp;= b
    return a

__iand__ = iand

def iconcat(a, b):
    a += b
    return a

__iconcat__ = iconcat

def ifloordiv(a, b):
    a //= b
    return a

__ifloordiv__ = ifloordiv

def ilshift(a, b):
    a &lt;&lt;= b
    return a

__ilshift__ = ilshift

def imod(a, b):
    a %= b
    return a

__imod__ = imod

def imul(a, b):
    a *= b
    return a

__imul__ = imul

def imatmul(a, b):
    a @= b
    return a

__imatmul__ = imatmul

def ior(a, b):
    a |= b
    return a

__ior__ = ior

def ipow(a, b):
    a **= b
    return a

__ipow__ = ipow

def irshift(a, b):
    a &gt;&gt;= b
    return a

__irshift__ = irshift

def isub(a, b):
    a -= b
    return a

__isub__ = isub

def itruediv(a, b):
    a /= b
    return a

__itruediv__ = itruediv

def ixor(a, b):
    a ^= b
    return a

__ixor__ = ixor
</t>
<t tx="ekr.20230509083243.1236">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.file import _gz_errcheck
from internal.gc import sizeof, atomic

def pickle(x: T, jar: Jar, T: type):
    x.__pickle__(jar)

def unpickle(jar: Jar, T: type) -&gt; T:
    return T.__unpickle__(jar)

def dump(x: T, f, T: type):
    x.__pickle__(f.fp)

def load(f, T: type) -&gt; T:
    return T.__unpickle__(f.fp)

def _write_raw(jar: Jar, p: cobj, n: int):
    LIMIT = 0x7FFFFFFF
    while n &gt; 0:
        b = n if n &lt; LIMIT else LIMIT
        status = int(_C.gzwrite(jar, p, u32(b)))
        if status != b:
            _gz_errcheck(jar)
            raise IOError(f"pickle error: gzwrite returned {status}")
        p += b
        n -= b

def _read_raw(jar: Jar, p: cobj, n: int):
    LIMIT = 0x7FFFFFFF
    while n &gt; 0:
        b = n if n &lt; LIMIT else LIMIT
        status = int(_C.gzread(jar, p, u32(b)))
        if status != b:
            _gz_errcheck(jar)
            raise IOError(f"pickle error: gzread returned {status}")
        p += b
        n -= b

def _write(jar: Jar, x: T, T: type):
    y = __ptr__(x)
    _write_raw(jar, y.as_byte(), sizeof(T))

def _read(jar: Jar, T: type) -&gt; T:
    x = T()
    y = __ptr__(x)
    _read_raw(jar, y.as_byte(), sizeof(T))
    return x

# Extend core types to allow pickling

@extend
class int:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; int:
        return _read(jar, int)

@extend
class Int:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; Int[N]:
        return _read(jar, Int[N])

@extend
class UInt:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; UInt[N]:
        return _read(jar, UInt[N])

@extend
class float:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; float:
        return _read(jar, float)

@extend
class float32:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; float32:
        return _read(jar, float32)

@extend
class bool:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; bool:
        return _read(jar, bool)

@extend
class byte:
    def __pickle__(self, jar: Jar):
        _write(jar, self)

    def __unpickle__(jar: Jar) -&gt; byte:
        return _read(jar, byte)

@extend
class str:
    def __pickle__(self, jar: Jar):
        _write(jar, self.len)
        _write_raw(jar, self.ptr, self.len)

    def __unpickle__(jar: Jar) -&gt; str:
        n = _read(jar, int)
        p = Ptr[byte](n)
        _read_raw(jar, p, n)
        return str(p, n)

@extend
class List:
    def __pickle__(self, jar: Jar):
        n = len(self)
        pickle(n, jar)
        if atomic(T):
            _write_raw(jar, (self.arr.ptr).as_byte(), n * sizeof(T))
        else:
            for i in range(n):
                pickle(self.arr[i], jar)

    def __unpickle__(jar: Jar) -&gt; List[T]:
        n = unpickle(jar, int)
        arr = Array[T](n)
        if atomic(T):
            _read_raw(jar, (arr.ptr).as_byte(), n * sizeof(T))
        else:
            for i in range(n):
                arr[i] = unpickle(jar, T)
        return List[T](arr, n)

@extend
class DynamicTuple:
    def __pickle__(self, jar: Jar):
        n = len(self)
        pickle(n, jar)
        if atomic(T):
            _write_raw(jar, (self._ptr).as_byte(), n * sizeof(T))
        else:
            for i in range(n):
                pickle(self._ptr[i], jar)

    def __unpickle__(jar: Jar) -&gt; DynamicTuple[T]:
        n = unpickle(jar, int)
        p = Ptr[T](n)
        if atomic(T):
            _read_raw(jar, p.as_byte(), n * sizeof(T))
        else:
            for i in range(n):
                p[i] = unpickle(jar, T)
        return DynamicTuple[T](p, n)

@extend
class Dict:
    def __pickle__(self, jar: Jar):
        import internal.khash as khash

        if atomic(K) and atomic(V):
            pickle(self._n_buckets, jar)
            pickle(self._size, jar)
            pickle(self._n_occupied, jar)
            pickle(self._upper_bound, jar)
            fsize = khash.__ac_fsize(self._n_buckets) if self._n_buckets &gt; 0 else 0
            _write_raw(jar, self._flags.as_byte(), fsize * sizeof(u32))
            _write_raw(jar, self._keys.as_byte(), self._n_buckets * sizeof(K))
            _write_raw(jar, self._vals.as_byte(), self._n_buckets * sizeof(V))
        else:
            pickle(self._n_buckets, jar)
            size = len(self)
            pickle(size, jar)

            for k, v in self.items():
                pickle(k, jar)
                pickle(v, jar)

    def __unpickle__(jar: Jar) -&gt; Dict[K, V]:
        import internal.khash as khash

        d = {}
        if atomic(K) and atomic(V):
            n_buckets = unpickle(jar, int)
            size = unpickle(jar, int)
            n_occupied = unpickle(jar, int)
            upper_bound = unpickle(jar, int)
            fsize = khash.__ac_fsize(n_buckets) if n_buckets &gt; 0 else 0
            flags = Ptr[u32](fsize)
            keys = Ptr[K](n_buckets)
            vals = Ptr[V](n_buckets)
            _read_raw(jar, flags.as_byte(), fsize * sizeof(u32))
            _read_raw(jar, keys.as_byte(), n_buckets * sizeof(K))
            _read_raw(jar, vals.as_byte(), n_buckets * sizeof(V))

            d._n_buckets = n_buckets
            d._size = size
            d._n_occupied = n_occupied
            d._upper_bound = upper_bound
            d._flags = flags
            d._keys = keys
            d._vals = vals
        else:
            n_buckets = unpickle(jar, int)
            size = unpickle(jar, int)
            d.resize(n_buckets)
            i = 0
            while i &lt; size:
                k = unpickle(jar, K)
                v = unpickle(jar, V)
                d[k] = v
                i += 1
        return d

@extend
class Set:
    def __pickle__(self, jar: Jar):
        import internal.khash as khash

        if atomic(K):
            pickle(self._n_buckets, jar)
            pickle(self._size, jar)
            pickle(self._n_occupied, jar)
            pickle(self._upper_bound, jar)
            fsize = khash.__ac_fsize(self._n_buckets) if self._n_buckets &gt; 0 else 0
            _write_raw(jar, self._flags.as_byte(), fsize * sizeof(u32))
            _write_raw(jar, self._keys.as_byte(), self._n_buckets * sizeof(K))
        else:
            pickle(self._n_buckets, jar)
            size = len(self)
            pickle(size, jar)

            for k in self:
                pickle(k, jar)

    def __unpickle__(jar: Jar) -&gt; Set[K]:
        import internal.khash as khash

        s = set[K]()
        if atomic(K):
            n_buckets = unpickle(jar, int)
            size = unpickle(jar, int)
            n_occupied = unpickle(jar, int)
            upper_bound = unpickle(jar, int)
            fsize = khash.__ac_fsize(n_buckets) if n_buckets &gt; 0 else 0
            flags = Ptr[u32](fsize)
            keys = Ptr[K](n_buckets)
            _read_raw(jar, flags.as_byte(), fsize * sizeof(u32))
            _read_raw(jar, keys.as_byte(), n_buckets * sizeof(K))

            s._n_buckets = n_buckets
            s._size = size
            s._n_occupied = n_occupied
            s._upper_bound = upper_bound
            s._flags = flags
            s._keys = keys
        else:
            n_buckets = unpickle(jar, int)
            size = unpickle(jar, int)
            s.resize(n_buckets)
            i = 0
            while i &lt; size:
                k = unpickle(jar, K)
                s.add(k)
                i += 1
        return s
</t>
<t tx="ekr.20230509083243.1237">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.python import ensure_initialized

ensure_initialized()
</t>
<t tx="ekr.20230509083243.1238">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import sys
from math import inf as INF, sqrt as _sqrt, acos as _acos, cos as _cos, sin as _sin
from math import log as _log, exp as _exp, pi as _pi, e as _e, ceil as _ceil
from bisect import bisect as _bisect
from time import time as _time

N = 624
M = 397
LOG4 = _log(4.0)
NV_MAGICCONST = 4 * _exp(-0.5) / _sqrt(2.0)
SG_MAGICCONST = 1.0 + _log(4.5)
TWOPI = 2.0 * _pi

MATRIX_A = u32(0x9908b0df)    # constant vector a
UPPER_MASK = u32(0x80000000)  # most significant w-r bits
LOWER_MASK = u32(0x7fffffff)  # least significant r bits

@tuple
class RandomGenerator:
    data: Ptr[u32]

    def __new__():
        return RandomGenerator(Ptr[u32](N + 1))

    @property
    def index(self):
        return int(self.data[0])

    @property
    def state(self):
        return self.data + 1

    def getstate(self):
        from internal.gc import sizeof
        p = Ptr[u32](N + 1)
        str.memcpy(p.as_byte(), self.data.as_byte(), (N + 1) * sizeof(u32))
        return p

    def setstate(self, state):
        from internal.gc import sizeof
        str.memcpy(self.data.as_byte(), state.as_byte(), (N + 1) * sizeof(u32))

    def genrand_int32(self) -&gt; u32:
        mag01 = (u32(0), MATRIX_A)
        mt = self.state

        if self.index &gt;= N:
            kk = 0

            while kk &lt; int(N - M):
                y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK)
                mt[kk] = mt[kk + M] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
                kk += 1

            while kk &lt; int(N - 1):
                y = (mt[kk] &amp; UPPER_MASK) | (mt[kk+1] &amp; LOWER_MASK)
                mt[kk] = mt[kk+(M-N)] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
                kk += 1

            y = (mt[N-1] &amp; UPPER_MASK) | (mt[0] &amp; LOWER_MASK)
            mt[N-1] = mt[M-1] ^ (y &gt;&gt; u32(1)) ^ mag01[int(y &amp; u32(1))]
            self.data[0] = u32(0)

        i = self.index
        y = mt[i]
        self.data[0] = u32(i + 1)
        y ^= (y &gt;&gt; u32(11))
        y ^= (y &lt;&lt; u32(7)) &amp; u32(0x9d2c5680)
        y ^= (y &lt;&lt; u32(15)) &amp; u32(0xefc60000)
        y ^= (y &gt;&gt; u32(18))
        return y

    def genrand_res53(self) -&gt; float:
        a = self.genrand_int32() &gt;&gt; u32(5)
        b = self.genrand_int32() &gt;&gt; u32(6)
        return (int(a) * 67108864.0 + int(b)) * (1.0 / 9007199254740992.0)

    def random(self):
        return self.genrand_res53()

    def init_u32(self, s: u32):
        mt = self.state
        mt[0] = s
        for mti in range(1, N):
            mt[mti] = (u32(1812433253) * (mt[mti-1] ^ (mt[mti-1] &gt;&gt; u32(30))) + u32(mti))
        self.data[0] = u32(N)

    def init_array(self, init_key: Ptr[u32], key_length: int):
        mt = self.state
        self.init_u32(u32(19650218))
        i = 1
        j = 0

        k = N if N &gt; key_length else key_length
        while k:
            mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; u32(30))) * u32(1664525))) + init_key[j] + u32(j)
            i += 1
            j += 1
            if i &gt;= N:
                mt[0] = mt[N - 1]
                i = 1
            if j &gt;= key_length:
                j = 0
            k -= 1

        k = N - 1
        while k:
            mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] &gt;&gt; u32(30))) * u32(1566083941))) - u32(i)
            i += 1
            if i &gt;= N:
                mt[0] = mt[N - 1]
                i = 1
            k -= 1

        mt[0] = u32(0x80000000)

    def init_int(self, s: int):
        init_key = (u32(s &amp; ((1 &lt;&lt; 32) - 1)), u32(s &gt;&gt; 32))
        self.init_array(Ptr[u32](__ptr__(init_key).as_byte()), 2 if init_key[1] else 1)

    def random_seed_time_pid(self):
        now = _C.seq_time() * 1000
        key = __array__[u32](5)
        key[0] = u32(now &amp; 0xFFFFFFFF)
        key[1] = u32(now &gt;&gt; 32)
        key[2] = u32(_C.seq_pid())
        now = _C.seq_time_monotonic()
        key[3] = u32(now &amp; 0xFFFFFFFF)
        key[4] = u32(now &gt;&gt; 32)
        self.init_array(key.ptr, len(key))

    def seed(self, s: int):
        self.init_int(s)

    def seed(self):
        self.random_seed_time_pid()

class Random:
    """
    Random number generator base class used by bound module functions.
    Used to instantiate instances of Random to get generators that don't
    share state.
    Class Random can also be subclassed if you want to use a different basic
    generator of your own devising: in that case, override the following
    methods:  random(), seed(), getstate(), and setstate().
    Optionally, implement a getrandbits() method so that randrange()
    can cover arbitrarily large ranges.
    """
    gen: RandomGenerator  # comment for another error
    gauss_next: Optional[float]

    def __init__(self, seed: Optional[int] = None):
        """
        Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().

        For now x is set to its default None.
        """
        self.gen = RandomGenerator()
        self.seed(seed)

    def seed(self, a: Optional[int]):
        """
        Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If *a* is an int, all bits are used.

        For version 2 (the default), all of the bits are used if *a* is a str,
        bytes, or bytearray.  For version 1 (provided for reproducing random
        sequences from older versions of Python), the algorithm for str and
        bytes generates a narrower range of seeds.
        """
        if a is not None:
            self.gen.seed(abs(a))
        else:
            self.gen.seed()
        self.gauss_next = None

    def getstate(self):
        return self.gen.getstate(), self.gauss_next

    def setstate(self, state):
        gen_state, gauss_next = state
        self.gen.setstate(gen_state)
        self.gauss_next = gauss_next

    def getrandbits(self, k: int) -&gt; int:
        """
        getrandbits(k) -&gt; x
        Generates an int with k random bits.
        """
        if k == 0:
            return 0

        if k &lt; 0:
            raise ValueError("number of bits must be non-negative")

        if k &gt; 64:
            raise ValueError("number of bits cannot be greater than 64")

        if k &lt;= 32:  # Fast path
            r = int(self.gen.genrand_int32())
            m = r &gt;&gt; (32 - k)
            return m

        lo = u64(int(self.gen.genrand_int32()))
        hi = u64(int(self.gen.genrand_int32()))
        mask = ~((u64(1) &lt;&lt; u64(64 - k)) - u64(1))
        hi &amp;= mask
        hi &gt;&gt;= u64(64 - k)
        return int((hi &lt;&lt; u64(32)) | lo)

    def bit_length(self, n: int) -&gt; int:
        """ """
        len = 0
        while n:
            len += 1
            n = int(u64(n) &gt;&gt; u64(1))
        return len

    def _randbelow_with_getrandbits(self, n: int) -&gt; int:
        """
        Return a random int in the range [0,n).  Raises ValueError if n==0.
        """
        getrandbits = self.getrandbits
        k = self.bit_length(n)  # don't use (n-1) here because n can be 1
        r = getrandbits(k)  # 0 &lt;= r &lt; 2**k
        while r &gt;= n:
            r = getrandbits(k)
        return r

    def randrange(self, start: int, stop: int, step: int = 1) -&gt; int:
        """
        Choose a random item from range(start, stop[, step]).

        Return a randomly selected element from range(start, stop, step).
        This is equivalent to choice(range(start, stop, step)), but
        doesnt actually build a range object.

        For now stop == 0 for randrange(stop) where start = stop in our parameter.
        Defaults include: stop = None, step = 1
        for now we will use default value for step.
        """
        if stop == 0:
            if start &gt; 0:
                return self._randbelow_with_getrandbits(start)
            raise ValueError("empty range for randrange()")

        # stop argument supplied.
        width = stop - start
        if step == 1 and width &gt; 0:
            return start + self._randbelow_with_getrandbits(width)
        if step == 1:
            raise ValueError("empty range for randrange()")

        # Non-unit step argument supplied.
        n = INF
        if step &gt; 0:
            n = float((width + step - 1) // step)
        elif step &lt; 0:
            n = float((width + step + 1) // step)
        else:
            raise ValueError("zero step for randrange()")

        if n &lt;= 0:
            raise ValueError("empty range for randrange()")

        return start + step * self._randbelow_with_getrandbits(int(n))

    def randint(self, a: int, b: int):
        """
        Return random integer in range [a, b], including both end points.
        """
        return self.randrange(a, b + 1, 1)

    def random(self) -&gt; float:
        """
        random(self) -&gt; float

        Return the next random floating point number in the range [0.0, 1.0).
        """
        return self.gen.genrand_res53()

    def choice(self, sequence: Generator[T], T: type) -&gt; T:
        """
        Choose a random element from a non-empty sequence.
        """
        i = 0
        l = list(sequence)
        try:
            i = self._randbelow_with_getrandbits(len(l))
        except ValueError:
            raise IndexError("Cannot choose from an empty sequence")
        return l[i]

    def shuffle(self, x):
        """
        Shuffle list x in place, and return None.

        Optional argument random is a 0-argument function returning a
        random float in [0.0, 1.0); if it is the default None, the
        standard random.random will be used.

        For now seq will use random = 0  (None = default)
        """
        random = 0
        if random == 0:
            randbelow = self._randbelow_with_getrandbits
            for i in reversed(range(1, len(x))):
                # pick an element in x[:i+1] with which to exchange x[i]
                j = randbelow(i + 1)
                x[i], x[j] = x[j], x[i]
        else:
            for i in reversed(range(1, len(x))):
                # pick an element in x[:i+1] with which to exchange x[i]
                j = int(self.random() * (i + 1))
                x[i], x[j] = x[j], x[i]

    def uniform(self, a, b) -&gt; float:
        """
        Get a random number in the range [a, b) or [a, b] depending on rounding.
        """
        return a + (b - a) * self.random()

    def triangular(self, low: float, high: float, mode: float) -&gt; float:
        """
        Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        For now we mode to default: mode = None
        default for low and high : low = 0.0, high = 1.0
        """
        # mode = None
        if high == low:
            return low
        u = self.random()
        c = (mode - low) / (high - low)
        if u &gt; c:
            u = 1.0 - u
            c = 1.0 - c
            low, high = high, low
        return low + (high - low) * _sqrt(u * c)

    def gammavariate(self, alpha: float, beta: float) -&gt; float:
        """
        Gamma distribution.  Not the gamma function!

        Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.

        The probability distribution function is:

        ::

                    x ** (alpha - 1) * math.exp(-x / beta)
          pdf(x) =  --------------------------------------
                      math.gamma(alpha) * beta ** alpha
        """
        # alpha &gt; 0, beta &gt; 0, mean is alpha*beta, variance is alpha*beta**2

        # Warning: a few older sources define the gamma distribution in terms
        # of alpha &gt; -1.0
        if alpha &lt;= 0.0 or beta &lt;= 0.0:
            raise ValueError("gammavariate: alpha and beta must be &gt; 0.0")

        if alpha &gt; 1.0:

            # Uses R.C.H. Cheng, "The generation of Gamma
            # variables with non-integral shape parameters",
            # Applied Statistics, (1977), 26, No. 1, p71-74

            ainv = _sqrt(2.0 * alpha - 1.0)
            bbb = alpha - LOG4
            ccc = alpha + ainv

            while 1:
                u1 = self.random()
                if not 1e-7 &lt; u1 &lt; 0.9999999:
                    continue
                u2 = 1.0 - self.random()
                v = _log(u1 / (1.0 - u1)) / ainv
                x = alpha * _exp(v)
                z = u1 * u1 * u2
                r = bbb + ccc * v - x
                if r + SG_MAGICCONST - 4.5 * z &gt;= 0.0 or r &gt;= _log(z):
                    return x * beta

        elif alpha == 1.0:
            # expovariate(1/beta)
            return -_log(1.0 - self.random()) * beta

        else:  # alpha is between 0 and 1 (exclusive)

            # Uses ALGORITHM GS of Statistical Computing - Kennedy &amp; Gentle
            x = 0.0
            while 1:
                u = self.random()
                b = (_e + alpha) / _e
                p = b * u
                if p &lt;= 1.0:
                    x = p ** (1.0 / alpha)
                else:
                    x = -_log((b - p) / alpha)
                u1 = self.random()
                if p &gt; 1.0:
                    if u1 &lt;= x ** (alpha - 1.0):
                        break
                elif u1 &lt;= _exp(-x):
                    break
            return x * beta

    def betavariate(self, alpha: float, beta: float) -&gt; float:
        """
        Beta distribution.
        Conditions on the parameters are alpha &gt; 0 and beta &gt; 0.
        Returned values range between 0 and 1.
        """
        # This version due to Janne Sinkkonen, and matches all the std
        # texts (e.g., Knuth Vol 2 Ed 3 pg 134 "the beta distribution").
        y = self.gammavariate(alpha, 1.0)
        if y == 0:
            return 0.0
        else:
            return y / (y + self.gammavariate(beta, 1.0))

    def expovariate(self, lambd: float) -&gt; float:
        """
        Exponential distribution.

        lambd is 1.0 divided by the desired mean.  It should be
        nonzero.

        Returned values range from 0 to
        positive infinity if lambd is positive, and from negative
        infinity to 0 if lambd is negative.
        """
        if lambd == 0.0:
            raise ZeroDivisionError("Cannot divide by zero")
        # lambd: rate lambd = 1/mean
        # we use 1-random() instead of random() to preclude the
        # possibility of taking the log of zero.
        return -_log(1.0 - self.random()) / lambd

    def gauss(self, mu: float = 0.0, sigma: float = 1.0) -&gt; float:
        """
        Gaussian distribution.

        mu is the mean, and sigma is the standard deviation.  This is
        slightly faster than the normalvariate() function.
        Not thread-safe without a lock around calls.
        """
        z = self.gauss_next
        self.gauss_next = None
        if z is None:
            x2pi = self.random() * TWOPI
            g2rad = _sqrt(-2.0 * _log(1.0 - self.random()))
            z = _cos(x2pi) * g2rad
            self.gauss_next = _sin(x2pi) * g2rad
        return mu + z * sigma

    def paretovariate(self, alpha: float) -&gt; float:
        """
        Pareto distribution.  alpha is the shape parameter."""
        u = 1.0 - self.random()
        return 1.0 / u ** (1.0 / alpha)

    def weibullvariate(self, alpha: float, beta: float) -&gt; float:
        """
        Weibull distribution.

        alpha is the scale parameter and beta is the shape parameter.
        """
        u = 1.0 - self.random()
        return alpha * (-_log(u)) ** (1.0 / beta)

    def normalvariate(self, mu: float = 0.0, sigma: float = 1.0) -&gt; float:
        """
        Normal distribution.

        mu is the mean, and sigma is the standard deviation.
        """
        z = 0.0
        while 1:
            u1 = self.random()
            u2 = 1.0 - self.random()
            z = NV_MAGICCONST * (u1 - 0.5) / u2
            zz = z * z / 4.0
            if zz &lt;= -_log(u2):
                break
        return mu + z * sigma

    def lognormvariate(self, mu: float, sigma: float) -&gt; float:
        """
        Log normal distribution.

        If you take the natural logarithm of this distribution, you'll get a
        normal distribution with mean mu and standard deviation sigma.
        mu can have any value, and sigma must be greater than zero.
        """
        return _exp(self.normalvariate(mu, sigma))

    def vonmisesvariate(self, mu: float, kappa: float) -&gt; float:
        """
        Circular data distribution.

        mu is the mean angle, expressed in radians between 0.0 and 2*pi, and
        kappa is the concentration parameter, which must be greater than or
        equal to zero.  If kappa is equal to zero, this distribution reduces
        to a uniform random angle over the range 0.0 to 2*pi.
        """
        def _mod(a: float, b: float):
            @pure
            @llvm
            def _truediv_float_float(self: float, other: float) -&gt; float:
                %0 = fdiv double %self, %other
                ret double %0

            @pure
            @llvm
            def _mod_float_float(self: float, other: float) -&gt; float:
                %0 = frem double %self, %other
                ret double %0

            mod = _mod_float_float(a, b)
            div = _truediv_float_float(a - mod, b)
            if mod:
                if (b &lt; 0) != (mod &lt; 0):
                    mod += b
                    div -= 1.0
            else:
                mod = (0.0).copysign(b)
            return mod

        z = 0.0
        theta = 0.0

        if kappa &lt;= 1e-6:
            return TWOPI * self.random()

        s = 0.5 / kappa
        r = s + _sqrt(1.0 + s * s)

        while 1:
            u1 = self.random()
            z = _cos(_pi * u1)

            d = z / (r + z)
            u2 = self.random()
            if u2 &lt; 1.0 - d * d or u2 &lt;= (1.0 - d) * _exp(d):
                break

        q = 1.0 / r
        f = (q + z) / (1.0 + q * z)
        u3 = self.random()
        if u3 &gt; 0.5:
            theta = _mod(mu + _acos(f), TWOPI)
        else:
            theta = _mod(mu - _acos(f), TWOPI)

        return theta

    def sample(self, population: List[T], k: int, T: type):
        """
        Chooses k unique random elements from a population sequence or set.

        Returns a new list containing elements from the population while
        leaving the original population unchanged.  The resulting list is
        in selection order so that all sub-slices will also be valid random
        samples.  This allows raffle winners (the sample) to be partitioned
        into grand prize and second place winners (the subslices).

        Members of the population need not be hashable or unique.  If the
        population contains repeats, then each occurrence is a possible
        selection in the sample.

        To choose a sample in a range of integers, use range as an argument.
        This is especially fast and space efficient for sampling from a
        large population:   sample(range(10000000), 60)

        For now seq will deal with only lists.
        """
        randbelow = self._randbelow_with_getrandbits
        n = len(population)
        if not 0 &lt;= k &lt;= n:
            raise ValueError("Sample larger than population or is negative")
        result = [T() for _ in range(k)]
        setsize = 21.0  # size of a small set minus size of an empty list
        if k &gt; 5:
            # Should be _log(k * 3, 4)
            setsize += 4 ** _ceil(_log(float(k * 3)))  # table size for big sets
        if n &lt;= setsize:
            # An n-length list is smaller than a k-length set
            pool = list(population)
            for i in range(k):  # invariant:  non-selected at [0,n-i)
                j = randbelow(n - i)
                result[i] = pool[j]
                pool[j] = pool[n - i - 1]  # move non-selected item into vacancy
        else:
            selected = Set[int]()
            selected_add = selected.add
            for i in range(k):
                j = randbelow(n)
                while j in selected:
                    j = randbelow(n)
                selected_add(j)
                result[i] = population[j]
        return result

    def choices(
        self,
        population,
        weights: Optional[List[int]],
        cum_weights: Optional[List[int]],
        k: int,
    ):
        """
        Return a k sized list of population elements chosen with replacement.

        If the relative weights or cumulative weights are not specified,
        the selections are made with equal probability.

        Since weights and cum_weights is assumed to be positive, we will replace None with [-1].
        """

        def accumulate(weights: List[int]) -&gt; List[int]:
            """
            Calculate cum_weights
            """
            n = len(weights)
            cum_weight = List[int](n)
            accum = 0
            if n &gt; 0:
                for i in range(n):
                    accum += weights[i]
                    cum_weight.append(accum)

            return cum_weight

        n = len(population)
        if cum_weights is None:
            if weights is None:
                return [population[int(self.random() * n)] for i in range(k)]
            cum_weights = accumulate(weights)
        elif weights is not None:
            raise TypeError("Cannot specify both weights and cumulative weights")
        if len(cum_weights) != n:
            raise ValueError("The number of weights does not match the population")

        total = float(cum_weights[-1])  # convert to float
        hi = n - 1
        return [
            population[_bisect(cum_weights, int(self.random() * total), 0, hi)]
            for i in range(k)
        ]

_rnd = Random()

def seed(a: int):
    _rnd.seed(a)

def getrandbits(k: int):
    return _rnd.getrandbits(k)

def randrange(start: int, stop: Optional[int] = None, step: int = 1):
    return _rnd.randrange(start, stop, step) if stop is not None else _rnd.randrange(0, start, step)

def randint(a: int, b: int):
    return _rnd.randint(a, b)

def choice(s):
    return _rnd.choice(s)

def choices(
    population,
    weights: Optional[List[int]] = None,
    cum_weights: Optional[List[int]] = None,
    k: int = 1,
):
    return _rnd.choices(population, weights, cum_weights, k)

def shuffle(s):
    _rnd.shuffle(s)

def sample(population, k: int):
    return _rnd.sample(population, k)

def random():
    return _rnd.random()

def uniform(a, b):
    return _rnd.uniform(a, b)

def triangular(low: float = 0.0, high: float = 1.0, mode: Optional[float] = None):
    return _rnd.triangular(low, high, mode if mode is not None else (low + high) / 2)

def betavariate(alpha: float, beta: float):
    return _rnd.betavariate(alpha, beta)

def expovariate(lambd: float):
    return _rnd.expovariate(lambd)

def gammavariate(alpha: float, beta: float):
    return _rnd.gammavariate(alpha, beta)

def gauss(mu: float, sigma: float):
    return _rnd.gauss(mu, sigma)

def lognormvariate(mu: float, sigma: float):
    return _rnd.lognormvariate(mu, sigma)

def normalvariate(mu: float, sigma: float):
    return _rnd.normalvariate(mu, sigma)

def vonmisesvariate(mu: float, kappa: float):
    return _rnd.vonmisesvariate(mu, kappa)

def paretovariate(alpha: float):
    return _rnd.paretovariate(alpha)

def weibullvariate(alpha: float, beta: float):
    return _rnd.weibullvariate(alpha, beta)
</t>
<t tx="ekr.20230509083243.1239">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Adapted in part from Google's Python re2 wrapper
# https://github.com/google/re2/blob/abseil/python/re2.py

A          = (1 &lt;&lt; 0)
ASCII      = (1 &lt;&lt; 0)
DEBUG      = (1 &lt;&lt; 1)
I          = (1 &lt;&lt; 2)
IGNORECASE = (1 &lt;&lt; 2)
L          = (1 &lt;&lt; 3)
LOCALE     = (1 &lt;&lt; 3)
M          = (1 &lt;&lt; 4)
MULTILINE  = (1 &lt;&lt; 4)
S          = (1 &lt;&lt; 5)
DOTALL     = (1 &lt;&lt; 5)
X          = (1 &lt;&lt; 6)
VERBOSE    = (1 &lt;&lt; 6)

_ANCHOR_NONE  = 0
_ANCHOR_START = 1
_ANCHOR_BOTH  = 2

@tuple
class Span:
    start: int
    end: int

    def __bool__(self):
        return not (self.start == -1 and self.end == -1)

@C
@pure
def seq_re_match(re: cobj,
                 anchor: int,
                 string: str,
                 pos: int,
                 endpos: int) -&gt; Ptr[Span]:
    pass

@C
@pure
def seq_re_match_one(re: cobj,
                     anchor: int,
                     string: str,
                     pos: int,
                     endpos: int) -&gt; Span:
    pass

@C
@pure
def seq_re_pattern_groups(re: cobj) -&gt; int:
    pass

@C
@pure
def seq_re_group_name_to_index(re: cobj, name: str) -&gt; int:
    pass

@C
@pure
def seq_re_group_index_to_name(re: cobj, index: int) -&gt; str:
    pass

@C
@pure
def seq_re_pattern_error(re: cobj) -&gt; str:
    pass

@C
@pure
def seq_re_escape(pattern: str) -&gt; str:
    pass

@C
def seq_re_purge() -&gt; None:
    pass

@C
@pure
def seq_re_compile(pattern: str, flags: int) -&gt; cobj:
    pass

class error(Static[Exception]):
    pattern: str

    def __init__(self, message: str = "", pattern: str = ""):
        super().__init__("re.error", message)
        self.pattern = pattern

    @property
    def msg(self):
        return self.message

@tuple
class Pattern:
    pattern: str
    flags: int
    _re: cobj

def compile(pattern: str, flags: int = 0):
    re = seq_re_compile(pattern, flags)
    err_msg = seq_re_pattern_error(re)
    if err_msg:
        raise error(err_msg, pattern)
    return Pattern(pattern, flags, re)

def search(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).search(string)

def match(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).match(string)

def fullmatch(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).fullmatch(string)

def finditer(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).finditer(string)

def findall(pattern: str, string: str, flags: int = 0):
    return compile(pattern, flags).findall(string)

def split(pattern: str, string: str, maxsplit: int = 0, flags: int = 0):
    return compile(pattern, flags).split(string, maxsplit)

def sub(pattern: str, repl, string: str, count: int = 0, flags: int = 0):
    return compile(pattern, flags).sub(repl, string, count)

def subn(pattern: str, repl, string: str, count: int = 0, flags: int = 0):
    return compile(pattern, flags).subn(repl, string, count)

def escape(pattern: str):
    return seq_re_escape(pattern)

def purge():
    seq_re_purge()

@tuple
class Match:
    _spans: Ptr[Span]
    pos: int
    endpos: int
    re: Pattern
    string: str

    def _get_group_int(self, g: int, n: int):
        if not (0 &lt;= g &lt;= n):
            raise IndexError("no such group")
        return self._spans[g]

    def _get_group_str(self, g: str, n: int):
        return self._get_group_int(seq_re_group_name_to_index(self.re._re, g), n)

    def _get_group(self, g, n: int):
        if isinstance(g, int):
            return self._get_group_int(g, n)
        elif isinstance(g, str):
            return self._get_group_str(g, n)
        else:
            return self._get_group(g.__index__(), n)

    def _span_match(self, span: Span):
        if not span:
            return None
        return self.string._slice(span.start, span.end)

    def _get_match(self, g, n: int):
        span = self._get_group(g, n)
        return self._span_match(span)

    def _group_multi(self, n: int, *args):
        if staticlen(args) == 1:
            return (self._get_match(args[0], n),)
        else:
            return (self._get_match(args[0], n), *self._group_multi(n, *args[1:]))

    def group(self, *args):
        if staticlen(args) == 0:
            return self._get_match(0, 1).__val__()
        elif staticlen(args) == 1:
            return self._get_match(args[0], self.re.groups)
        else:
            return self._group_multi(self.re.groups, *args)

    def __getitem__(self, g):
        return self._get_match(g, self.re.groups)

    def start(self, group = 0):
        return self._get_group(group, self.re.groups).start

    def end(self, group = 0):
        return self._get_group(group, self.re.groups).end

    def span(self, group = 0):
        start, end = self._get_group(group, self.re.groups)
        return start, end

    def _split(template: str):
        backslash = '\\'
        pieces = ['']
        index = template.find(backslash)

        OCTAL = compile(r'\\[0-7][0-7][0-7]')
        GROUP = compile(r'\\[1-9][0-9]?|\\g&lt;\w+&gt;')

        while index != -1:
            piece, template = template[:index], template[index:]
            pieces[-1] += piece

            octal_match = OCTAL.match(template)
            group_match = GROUP.match(template)

            if (not octal_match) and group_match:
                index = group_match.end()
                piece, template = template[:index], template[index:]
                pieces.extend((piece, ''))
            else:
                index = 2
                piece, template = template[:index], template[index:]
                pieces[-1] += piece

            index = template.find(backslash)

        pieces[-1] += template
        return pieces

    def _unescape(s: str):
        r = []
        n = len(s)
        i = 0
        while i &lt; n:
            if s[i] == '\\' and i + 1 &lt; n:
                c = s[i + 1]
                if c == 'a':
                    r.append('\a')
                    i += 1
                elif c == 'b':
                    r.append('\b')
                    i += 1
                elif c == 'f':
                    r.append('\f')
                    i += 1
                elif c == 'n':
                    r.append('\n')
                    i += 1
                elif c == 'r':
                    r.append('\r')
                    i += 1
                elif c == 't':
                    r.append('\t')
                    i += 1
                elif c == 'v':
                    r.append('\v')
                    i += 1
                elif c == '"':
                    r.append('\"')
                    i += 1
                elif c == '\'':
                    r.append('\'')
                    i += 1
                elif c == '\\':
                    r.append('\\')
                    i += 1
                elif '0' &lt;= c &lt;= '7':
                        k = i + 2
                        while k &lt; n and k - i &lt;= 4 and '0' &lt;= s[k] &lt;= '7':
                            k += 1
                        code = int(s[i+1:k], 8)
                        p = Ptr[byte](1)
                        p[0] = byte(code)
                        r.append(str(p, 1))
                        i = k - 1
                elif c.isalpha():
                    raise error(f"bad escape \\{c} at position {i}")
                else:
                    r.append(s[i])
            else:
                r.append(s[i])
            i += 1

        return str.cat(r)

    def expand(self, template: str):
        def get_or_empty(s: Optional[str]):
            return s if s is not None else ''

        pieces = list(Match._split(template))
        INT = compile(r'[+-]?\d+')

        for index, piece in enumerate(pieces):
            if not (index % 2):
                pieces[index] = Match._unescape(piece)
            else:
                if len(piece) &lt;= 3:
                    pieces[index] = get_or_empty(self[int(piece[1:])])
                else:
                    group = piece[3:-1]
                    if INT.fullmatch(group):
                        pieces[index] = get_or_empty(self[int(group)])
                    else:
                        pieces[index] = get_or_empty(self[group])
        return str.cat(pieces)

    @property
    def lastindex(self):
        max_end = -1
        max_group = None
        for group in range(1, self.re.groups + 1):
            end = self._spans[group].end
            if max_end &lt; end:
                max_end = end
                max_group = group
        return max_group

    @property
    def lastgroup(self):
        max_group = self.lastindex
        if max_group is None:
            return None
        return seq_re_group_index_to_name(self.re._re, max_group)

    def groups(self, default: Optional[str] = None):
        def get_or_default(item, default):
            return item if item is not None else default

        n = self.re.groups
        return [get_or_default(self._span_match(self._spans[i]), default)
                for i in range(1, n + 1)]

    def groupdict(self, default: Optional[str] = None):
        d = {}
        for group, index in self.re.groupindex.items():
            item = self[index]
            d[group] = item if item is not None else default
        return d

    def __copy__(self):
        return self

    def __deepcopy__(self):
        return self

    def __bool__(self):
        return True

@extend
class Pattern:
    @property
    def groups(self):
        return seq_re_pattern_groups(self._re)

    @property
    def groupindex(self):
        d = {}
        for i in range(1, self.groups + 1):
            name = seq_re_group_index_to_name(self._re, i)
            if name:
                d[name] = i
        return d

    def _match_one(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
        posx = 0 if pos is None else max(0, min(pos.__val__(), len(string)))
        endposx = len(string) if endpos is None else max(0, min(endpos.__val__(), len(string)))

        if posx &gt; endposx:
            return None

        spans = seq_re_match(self._re, anchor, string, posx, endposx)
        if not spans[0]:
            return None

        return Match(spans, posx, endposx, self, string)

    def _match(self, anchor: int, string: str, pos: Optional[int], endpos: Optional[int]):
        posx = 0 if pos is None else max(0, min(pos.__val__(), len(string)))
        endposx = len(string) if endpos is None else max(0, min(endpos.__val__(), len(string)))

        if posx &gt; endposx:
            return

        while True:
            spans = seq_re_match(self._re, anchor, string, posx, endposx)

            if not spans[0]:
                break

            yield Match(spans, posx, endposx, self, string)

            if posx == endposx:
                break

            elif posx == spans[0][1]:
                # We matched the empty string at pos and would be stuck, so in order
                # to make forward progress, increment the bytes offset.
                posx += 1
            else:
                posx = spans[0][1]

    def search(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_NONE, string, pos, endpos)

    def match(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_START, string, pos, endpos)

    def fullmatch(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match_one(_ANCHOR_BOTH, string, pos, endpos)

    def finditer(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return self._match(_ANCHOR_NONE, string, pos, endpos)

    def findall(self, string: str, pos: Optional[int] = None, endpos: Optional[int] = None):
        return [m.group() for m in self.finditer(string, pos, endpos)]

    def _split(self, cb, string: str, maxsplit: int = 0, T: type = str):
        if maxsplit &lt; 0:
            return [T(string)], 0

        pieces: List[T] = []
        end = 0
        numsplit = 0
        for match in self.finditer(string):
            if (maxsplit &gt; 0 and numsplit &gt;= maxsplit):
                break
            pieces.append(string[end:match.start()])
            pieces.extend(cb(match))
            end = match.end()
            numsplit += 1
        pieces.append(string[end:])
        return pieces, numsplit

    def split(self, string: str, maxsplit: int = 0):
        cb = lambda match: [match[group] for group in range(1, self.groups + 1)]
        pieces, _ = self._split(cb, string, maxsplit, Optional[str])
        return pieces

    def _repl(match, repl):
        if isinstance(repl, str):
            return match.expand(repl)
        else:
            return repl(match)

    def subn(self, repl, string: str, count: int = 0):
        cb = lambda match: [Pattern._repl(match, repl)]
        pieces, numsplit = self._split(cb, string, count, str)
        joined_pieces = str.cat(pieces)
        return joined_pieces, numsplit

    def sub(self, repl, string: str, count: int = 0):
        joined_pieces, _ = self.subn(repl, string, count)
        return joined_pieces

    def __bool__(self):
        return True
</t>
<t tx="ekr.20230509083243.124">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_map&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/visitor.h"

namespace codon {
namespace ir {
namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1240">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from bisect import bisect_right, bisect_left, insort
from collections import deque

DEFAULT_LOAD_FACTOR = 1000

class SortedList:
    _len: int
    _load: int
    _lists: List[List[T]]
    _maxes: List[T]
    _offset: int
    T: type

    def __init__(self):
        self._len = 0
        self._load = DEFAULT_LOAD_FACTOR
        self._lists = []
        self._maxes = []
        self._offset = 0

    def clear(self):
        """
        Remove all values from sorted list.
        Runtime complexity: `O(n)`
        """
        self._len = 0
        self._lists.clear()
        self._maxes.clear()
        self._offset = 0

    @property
    def left(self) -&gt; T:
        if not self._lists:
            raise IndexError("list index out of range")
        return self._lists[0][0]

    def add(self, value: T):
        """
        Add `value` to sorted list.
        Runtime complexity: `O(log(n))` -- approximate.
        &gt;&gt;&gt; sl = SortedList()
        &gt;&gt;&gt; sl.add(3)
        &gt;&gt;&gt; sl.add(1)
        &gt;&gt;&gt; sl.add(2)
        &gt;&gt;&gt; sl
        SortedList([1, 2, 3])
        :param value: value to add to sorted list
        """
        if self._maxes:
            pos = bisect_right(self._maxes, value)
            if pos == len(self._maxes):
                pos -= 1
                self._lists[pos].append(value)
                self._maxes[pos] = value
            else:
                insort(self._lists[pos], value)
            self._expand(pos)
        else:
            self._lists.append([value])
            self._maxes.append(value)
        self._len += 1

    def _expand(self, pos: int):
        """
        Split sublists with length greater than double the load-factor.
        Updates the index when the sublist length is less than double the load
        level. This requires incrementing the nodes in a traversal from the
        leaf node to the root. For an example traversal see
        ``SortedList._loc``.
        """
        if len(self._lists[pos]) &gt; (self._load &lt;&lt; 1):
            _maxes = self._maxes

            _lists_pos = self._lists[pos]
            half = _lists_pos[self._load :]
            del _lists_pos[self._load :]
            _maxes[pos] = _lists_pos[-1]

            self._lists.insert(pos + 1, half)
            _maxes.insert(pos + 1, half[-1])

    def _delete(self, pos: int, idx: int):
        """
        Delete value at the given `(pos, idx)`.
        Combines lists that are less than half the load level.
        Updates the index when the sublist length is more than half the load
        level. This requires decrementing the nodes in a traversal from the
        leaf node to the root. For an example traversal see
        ``SortedList._loc``.
        :param int pos: lists index
        :param int idx: sublist index
        """
        _lists_pos = self._lists[pos]
        del _lists_pos[idx]
        self._len -= 1

        len_lists_pos = len(_lists_pos)

        if len_lists_pos &gt; (self._load &gt;&gt; 1):
            self._maxes[pos] = _lists_pos[-1]
        elif len(self._lists) &gt; 1:
            if not pos:
                pos += 1

            prev = pos - 1
            self._lists[prev].extend(self._lists[pos])
            self._maxes[prev] = self._lists[prev][-1]

            del self._lists[pos]
            del self._maxes[pos]

            self._expand(prev)
        elif len_lists_pos:
            self._maxes[pos] = _lists_pos[-1]
        else:
            del self._lists[pos]
            del self._maxes[pos]

    def __iter__(self) -&gt; Generator[T]:
        for l in self._lists:
            yield from l

    def __len__(self) -&gt; int:
        return self._len

    def __bool__(self) -&gt; bool:
        return self._len &gt; 0
</t>
<t tx="ekr.20230509083243.1241">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import bisect
import random
from math import frexp as _frexp, floor as _floor, fabs as _fabs, erf as _erf
from math import (
    gcd as _gcd,
    exp as _exp,
    log as _log,
    sqrt as _sqrt,
    tau as _tau,
    hypot as _hypot,
)

class StatisticsError(Static[Exception]):
    def __init__(self, message: str = ""):
        super().__init__("StatisticsError", message)

def median(data: List[T], T: type) -&gt; float:
    """
    Return the median (middle value) of numeric data.

    When the number of data points is odd, return the middle data point.
    When the number of data points is even, the median is interpolated by
    taking the average of the two middle values
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    if n % 2 == 1:
        return float(data[n // 2])
    else:
        i = n // 2
        return (data[i - 1] + data[i]) / 2

def median_low(data: List[T], T: type) -&gt; float:
    """
    Return the low median of numeric data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the smaller of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    if n % 2 == 1:
        return float(data[n // 2])
    else:
        return float(data[n // 2 - 1])

def median_high(data: List[T], T: type) -&gt; float:
    """
    Return the high median of data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the larger of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    return float(data[n // 2])

def _find_lteq(a: List[T], x: float, T: type):
    """
    Locate the leftmost value exactly equal to x
    """
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i
    assert False

def _find_rteq(a: List[T], l: int, x: float, T: type):
    """
    Locate the rightmost value exactly equal to x
    """
    i = bisect.bisect_right(a, x, lo=l)
    if i != (len(a) + 1) and a[i - 1] == x:
        return i - 1
    assert False

def median_grouped(data: List[T], interval: S = 1, T: type, S: type = int) -&gt; float:
    """
    Return the 50th percentile (median) of grouped continuous data.
    """
    data = sorted(data)
    n = len(data)
    if n == 0:
        raise StatisticsError("no median for empty data")
    elif n == 1:
        return float(data[0])

    # Find the value at the midpoint.
    x = float(data[n // 2])
    L = x - float(interval) / 2  # The lower limit of the median interval.

    # Find the position of leftmost occurrence of x in data
    l1 = _find_lteq(data, x)
    # Find the position of rightmost occurrence of x in data[l1...len(data)]
    # Assuming always l1 &lt;= l2
    l2 = _find_rteq(data, l1, x)
    cf = l1
    f = l2 - l1 + 1
    return L + interval * (n / 2 - cf) / f

def mode(data: List[T], T: type) -&gt; T:
    """
    Return the most common data point from discrete or nominal data.
    """
    counter = 0
    elem = data[0]

    for i in data:
        curr_frequency = data.count(i)
        if curr_frequency &gt; counter:
            counter = curr_frequency
            elem = i
    return elem

def multimode(data: List[T], T: type):
    """
    Return a list of the most frequently occurring values.

    Will return more than one result if there are multiple modes
    or an empty list if *data* is empty.
    """
    elem = data[0]
    counter = data.count(elem)
    li = sorted(data)
    mulmode = []

    for i in li:
        curr_frequency = data.count(i)
        if curr_frequency &gt; counter:
            mulmode = []
            mulmode.append(i)
            counter = curr_frequency
        elif curr_frequency == counter and i not in mulmode:
            mulmode.append(i)
    return mulmode

def quantiles(
    data: List[T], n: int = 4, method: str = "exclusive", T: type
) -&gt; List[float]:
    """
    Divide *data* into *n* continuous intervals with equal probability.

    Returns a list of (n - 1) cut points separating the intervals.

    Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
    Set *n* to 100 for percentiles which gives the 99 cuts points that
    separate *data* into 100 equal sized groups.

    The *data* can be any iterable containing sample.
    The cut points are linearly interpolated between data points.

    If *method* is set to *inclusive*, *data* is treated as population
    data.  The minimum value is treated as the 0th percentile and the
    maximum value is treated as the 100th percentile.
    """
    if n &lt; 1:
        raise StatisticsError("n must be at least 1")
    data = sorted(data)
    ld = len(data)
    if ld &lt; 2:
        raise StatisticsError("must have at least two data points")

    if method == "inclusive":
        m = ld - 1
        result = []
        for i in range(1, n):
            j = i * m // n
            delta = (i * m) - (j * n)
            interpolated = (data[j] * (n - delta) + data[j + 1] * delta) / n
            result.append(interpolated)
        return result
    if method == "exclusive":
        m = ld + 1
        result = []
        for i in range(1, n):
            j = i * m // n  # rescale i to m/n
            j = 1 if j &lt; 1 else ld - 1 if j &gt; ld - 1 else j  # clamp to 1 .. ld-1
            delta = (i * m) - (j * n)  # exact integer math
            interpolated = (data[j - 1] * (n - delta) + data[j] * delta) / n
            result.append(interpolated)
        return result
    raise ValueError(f"Unknown method: {method}")

def _lcm(x: int, y: int):
    """
    Returns the lowest common multiple between x and y
    """
    greater = 0
    if x &gt; y:
        greater = x
    else:
        greater = y

    while True:
        if greater % x == 0 and greater % y == 0:
            lcm = greater
            return lcm
        greater += 1

def _sum(data: List[float]) -&gt; float:
    """
    Return a high-precision sum of the given numeric data as a fraction,
    together with the type to be converted to and the count of items.

    If optional argument ``start`` is given, it is added to the total.
    If ``data`` is empty, ``start`` (defaulting to 0) is returned.

    TODO/CAVEATS
      - The start argument should default to 0 or 0.0
      - Assumes input is floats
    """
    # Neumaier sum
    # https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements
    # https://www.mat.univie.ac.at/~neum/scan/01.pdf (German)
    s = 0.0
    c = 0.0
    i = 0
    N = len(data)
    while i &lt; N:
        x = data[i]
        t = s + x
        if abs(s) &gt;= abs(x):
            c += (s - t) + x
        else:
            c += (x - t) + s
        s = t
        i += 1
    return s + c

def mean(data: List[float]) -&gt; float:
    """
    Return the sample arithmetic mean of data.

    TODO/CAVEATS
      - Assumes input is floats
      - Does not address NAN or INF
    """
    n = len(data)
    if n &lt; 1:
        raise StatisticsError("mean requires at least one data point")
    total = _sum(data)
    return total / n

'''
def fmean(data: List[float]) -&gt; float:
    """
    Convert data to floats and compute the arithmetic mean.

    TODO/CAVEATS
    @jordan- fsum is not implemented in math.seq yet and the above
             mean(data) deals with only floats. Thus this function is passed for now.
    """
    pass
'''

def geometric_mean(data: List[float]) -&gt; float:
    """
    Convert data to floats and compute the geometric mean.

    Raises a StatisticsError if the input dataset is empty,

    TODO/CAVEATS:
      - Assumes input is a list of floats
      - Uses mean instead of fmean for now
      - Does not handle data that contains a zero, or if it contains a negative value.
    """
    if len(data) &lt; 1:
        raise StatisticsError("geometric mean requires a non-empty dataset")
    return _exp(mean(list(map(_log, data))))

def _fail_neg(values: List[float], errmsg: str):
    """
    Iterate over values, failing if any are less than zero.
    """
    for x in values:
        if x &lt; 0:
            raise StatisticsError(errmsg)
        yield x

def harmonic_mean(data: List[float]) -&gt; float:
    """
    Return the harmonic mean of data.

    The harmonic mean, sometimes called the subcontrary mean, is the
    reciprocal of the arithmetic mean of the reciprocals of the data,
    and is often appropriate when averaging quantities which are rates
    or ratios.
    """
    errmsg = "harmonic mean does not support negative values"
    n = len(data)
    if n &lt; 1:
        raise StatisticsError("harmonic_mean requires at least one data point")

    x = data[0]

    if n == 1:
        return x
    total = 0.0

    li = List[float](n)
    for x in _fail_neg(data, errmsg):
        if x == 0.0:
            return 0.0
        li.append(1 / x)
    total = _sum(li)
    return n / total

def _ss(data: List[float], c: float):
    """
    Return sum of square deviations of sequence data.

    If c is None, the mean is calculated in one pass, and the deviations
    from the mean are calculated in a second pass. Otherwise, deviations are
    calculated from c as given.
    """
    total = _sum([(x - c) ** 2 for x in data])
    total2 = _sum([(x - c) for x in data])

    total -= total2 ** 2 / len(data)
    return total

def pvariance(data: List[float], mu: Optional[float] = None):
    """
    Return the population variance of `data`.

    Should contain atleast one value.
    The optional argument mu, if given, should be the mean of
    the data. If it is missing or None, the mean is automatically calculated.

    TODO/CAVEATS:
      - Assumes input is a list of floats
    """
    if mu is None:
        mu = mean(data)

    n = len(data)
    if n &lt; 1:
        raise StatisticsError("pvariance requires at least one data point")

    ss = _ss(data, mu)
    return ss / n

def pstdev(data: List[float], mu: Optional[float] = None):
    """
    Return the square root of the population variance.
    """
    if mu is None:
        mu = mean(data)
    var = pvariance(data, mu)
    return _sqrt(var)

def variance(data: List[float], xbar: Optional[float] = None):
    """
    Return the sample variance of data.

    Shoulw contain atleast two values.
    The optional argument xbar, if given, should be the mean of
    the data. If it is missing or None, the mean is automatically calculated.
    """
    if xbar is None:
        xbar = mean(data)
    n = len(data)
    if n &lt; 2:
        raise StatisticsError("variance requires at least two data points")
    ss = _ss(data, xbar)
    return ss / (n - 1)

def stdev(data, xbar: Optional[float] = None):
    """
    Return the square root of the sample variance.
    """
    if xbar is None:
        xbar = mean(data)
    var = variance(data, xbar)
    return _sqrt(var)

class NormalDist:
    """
    Normal distribution of a random variable
    """

    PRECISION: float
    _mu: float
    _sigma: float

    def __eq__(self, other: NormalDist):
        return (self._mu - other._mu) &lt; self.PRECISION and (
            self._sigma - other._sigma
        ) &lt; self.PRECISION

    def _init(self, mu: float, sigma: float):
        self.PRECISION = 1e-6
        if sigma &lt; 0.0:
            raise StatisticsError("sigma must be non-negative")
        self._mu = mu
        self._sigma = sigma

    def __init__(self, mu, sigma):
        self._init(float(mu), float(sigma))

    def __init__(self, mu):
        self._init(float(mu), 1.0)

    def __init__(self):
        self._init(0.0, 1.0)

    @property
    def mean(self):
        """
        Arithmetic mean of the normal distribution.
        """
        return self._mu

    @property
    def median(self):
        """
        Return the median of the normal distribution
        """
        return self._mu

    @property
    def mode(self):
        """
        Return the mode of the normal distribution

        The mode is the value x where which the probability density
        function (pdf) takes its maximum value.
        """
        return self._mu

    @property
    def stdev(self):
        """
        Standard deviation of the normal distribution.
        """
        return self._sigma

    @property
    def variance(self):
        """
        Square of the standard deviation.
        """
        return self._sigma ** 2.0

    def pdf(self, x):
        """
        Probability density function.  P(x &lt;= X &lt; x+dx) / dx
        """
        variance = self._sigma ** 2.0
        if not variance:
            raise StatisticsError("pdf() not defined when sigma is zero")
        return _exp((x - self._mu) ** 2.0 / (-2.0 * variance)) / _sqrt(_tau * variance)

    def cdf(self, x):
        """
        Cumulative distribution function.  P(X &lt;= x)
        """
        if not self._sigma:
            raise StatisticsError("cdf() not defined when sigma is zero")
        return 0.5 * (1.0 + _erf((x - self._mu) / (self._sigma * _sqrt(2.0))))

    def _normal_dist_inv_cdf(self, p: float, mu: float, sigma: float):
        """
        Wichura, M.J. (1988). "Algorithm AS241: The Percentage Points of the
        Normal Distribution".  Applied Statistics. Blackwell Publishing. 37
        (3): 477484. doi:10.2307/2347330. JSTOR 2347330.
        """
        q = p - 0.5
        num = 0.0
        den = 0.0
        if _fabs(q) &lt;= 0.425:
            r = 0.180625 - q * q
            # Hash sum: 55.88319_28806_14901_4439
            num = (((((((2.5090809287301226727e+3 * r +
                    3.3430575583588128105e+4) * r +
                    6.7265770927008700853e+4) * r +
                    4.5921953931549871457e+4) * r +
                    1.3731693765509461125e+4) * r +
                    1.9715909503065514427e+3) * r +
                    1.3314166789178437745e+2) * r +
                    3.3871328727963666080e+0) * q
            den = (((((((5.2264952788528545610e+3 * r +
                    2.8729085735721942674e+4) * r +
                    3.9307895800092710610e+4) * r +
                    2.1213794301586595867e+4) * r +
                    5.3941960214247511077e+3) * r +
                    6.8718700749205790830e+2) * r +
                    4.2313330701600911252e+1) * r +
                    1.0)
            x = num / den
            return mu + (x * sigma)
        r = p if q &lt;= 0.0 else 1.0 - p
        r = _sqrt(-_log(r))
        if r &lt;= 5.0:
            r = r - 1.6
            # Hash sum: 49.33206_50330_16102_89036
            num = (((((((7.74545014278341407640e-4 * r +
                    2.27238449892691845833e-2) * r +
                    2.41780725177450611770e-1) * r +
                    1.27045825245236838258e+0) * r +
                    3.64784832476320460504e+0) * r +
                    5.76949722146069140550e+0) * r +
                    4.63033784615654529590e+0) * r +
                    1.42343711074968357734e+0)
            den = (((((((1.05075007164441684324e-9 * r +
                    5.47593808499534494600e-4) * r +
                    1.51986665636164571966e-2) * r +
                    1.48103976427480074590e-1) * r +
                    6.89767334985100004550e-1) * r +
                    1.67638483018380384940e+0) * r +
                    2.05319162663775882187e+0) * r +
                    1.0)
        else:
            r = r - 5.0
            # Hash sum: 47.52583_31754_92896_71629
            num = (((((((2.01033439929228813265e-7 * r +
                    2.71155556874348757815e-5) * r +
                    1.24266094738807843860e-3) * r +
                    2.65321895265761230930e-2) * r +
                    2.96560571828504891230e-1) * r +
                    1.78482653991729133580e+0) * r +
                    5.46378491116411436990e+0) * r +
                    6.65790464350110377720e+0)
            den = (((((((2.04426310338993978564e-15 * r +
                    1.42151175831644588870e-7) * r +
                    1.84631831751005468180e-5) * r +
                    7.86869131145613259100e-4) * r +
                    1.48753612908506148525e-2) * r +
                    1.36929880922735805310e-1) * r +
                    5.99832206555887937690e-1) * r +
                    1.0)
        x = num / den
        if q &lt; 0.0:
            x = -x
        return mu + (x * sigma)

    def inv_cdf(self, p: float):
        """
        Inverse cumulative distribution function.  x : P(X &lt;= x) = p

        Finds the value of the random variable such that the probability of
        the variable being less than or equal to that value equals the given
        probability.
        """
        if p &lt;= 0.0 or p &gt;= 1.0:
            raise StatisticsError("p must be in the range 0.0 &lt; p &lt; 1.0")
        if self._sigma &lt;= 0.0:
            raise StatisticsError("cdf() not defined when sigma at or below zero")
        return self._normal_dist_inv_cdf(p, self._mu, self._sigma)

    def quantiles(self, n: int = 4):
        """
        Divide into *n* continuous intervals with equal probability.

        Returns a list of (n - 1) cut points separating the intervals.

        Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
        Set *n* to 100 for percentiles which gives the 99 cuts points that
        separate the normal distribution into 100 equal sized groups.
        """
        return [self.inv_cdf(float(i) / float(n)) for i in range(1, n)]

    def overlap(self, other: NormalDist) -&gt; float:
        """
        Compute the overlapping coefficient (OVL) between two normal distributions.

        Measures the agreement between two normal probability distributions.
        Returns a value between 0.0 and 1.0 giving the overlapping area in
        the two underlying probability density functions.
        """
        X, Y = self, other

        if (Y._sigma, Y._mu) &lt; (X._sigma, X._mu):  # sort to assure commutativity
            X, Y = Y, X

        X_var, Y_var = X.variance, Y.variance

        if not X_var or not Y_var:
            raise StatisticsError("overlap() not defined when sigma is zero")

        dv = Y_var - X_var
        dm = _fabs(Y._mu - X._mu)

        if not dv:
            return 1.0 - _erf(dm / (2.0 * X._sigma * _sqrt(2.0)))

        a = X._mu * Y_var - Y._mu * X_var
        b = X._sigma * Y._sigma * _sqrt(dm ** 2.0 + dv * _log(Y_var / X_var))
        x1 = (a + b) / dv
        x2 = (a - b) / dv

        return 1.0 - (_fabs(Y.cdf(x1) - X.cdf(x1)) + _fabs(Y.cdf(x2) - X.cdf(x2)))

    def samples(self, n: int):
        """
        Generate *n* samples for a given mean and standard deviation.
        """
        gauss = random.gauss
        return [gauss(self._mu, self._sigma) for i in range(n)]

    def from_samples(data: List[float]):
        """
        Make a normal distribution instance from sample data.
        TODO/CAVEATS:
          - Assumes input is a list of floats
          - Uses mean instead of fmean for now
        """
        xbar = mean(data)
        return NormalDist(xbar, stdev(data, xbar))

    def __add__(x1: NormalDist, x2: NormalDist):
        """
        Add a constant or another NormalDist instance.
        If *other* is a constant, translate mu by the constant,
        leaving sigma unchanged.
        If *other* is a NormalDist, add both the means and the variances.
        Mathematically, this works only if the two distributions are
        independent or if they are jointly normally distributed.
        """
        return NormalDist(x1._mu + x2._mu, _hypot(x1._sigma, x2._sigma))

    def __add__(x1: NormalDist, x2: float):
        """
        Add a constant or another NormalDist instance.
        If *other* is a constant, translate mu by the constant,
        leaving sigma unchanged.
        If *other* is a NormalDist, add both the means and the variances.
        Mathematically, this works only if the two distributions are
        independent or if they are jointly normally distributed.
        """
        return NormalDist(x1._mu + x2, x1._sigma)

    def __sub__(x1: NormalDist, x2: NormalDist):
        """
        Subtract a constant or another NormalDist instance.
        If *other* is a constant, translate by the constant mu,
        leaving sigma unchanged.
        If *other* is a NormalDist, subtract the means and add the variances.
        Mathematically, this works only if the two distributions are
        independent or if they are jointly normally distributed.
        """
        return NormalDist(x1._mu - x2._mu, _hypot(x1._sigma, x2._sigma))

    def __sub__(x1: NormalDist, x2: float):
        """
        Subtract a constant or another NormalDist instance.
        If *other* is a constant, translate by the constant mu,
        leaving sigma unchanged.
        If *other* is a NormalDist, subtract the means and add the variances.
        Mathematically, this works only if the two distributions are
        independent or if they are jointly normally distributed.
        """
        return NormalDist(x1._mu - x2, x1._sigma)

    def __mul__(x1: NormalDist, x2: float):
        """
        Multiply both mu and sigma by a constant.
        Used for rescaling, perhaps to change measurement units.
        Sigma is scaled with the absolute value of the constant.
        """
        return NormalDist(x1._mu * x2, x1._sigma * _fabs(x2))

    def __truediv__(x1: NormalDist, x2: float):
        """
        Divide both mu and sigma by a constant.
        Used for rescaling, perhaps to change measurement units.
        Sigma is scaled with the absolute value of the constant.
        """
        return NormalDist(x1._mu / x2, x1._sigma / _fabs(x2))

    def __pos__(x1: NormalDist):
        return NormalDist(x1._mu, x1._sigma)

    def __neg__(x1: NormalDist):
        return NormalDist(-x1._mu, x1._sigma)

    def __radd__(x1: NormalDist, x2: float):
        return x1 + x2

    def __rsub__(x1: NormalDist, x2: NormalDist):
        return -(x1 - x2)

    def __rmul__(x1: NormalDist, x2: float):
        return x1 * x2

    def __eq__(x1: NormalDist, x2: NormalDist):
        return x1._mu == x2._mu and x1._sigma == x2._sigma

    def __hash__(self):
        return hash((self._mu, self._sigma))

    def __repr__(self):
        return f"NormalDist(mu={self._mu}, sigma={self._sigma})"
</t>
<t tx="ekr.20230509083243.1242">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

ascii_letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
ascii_lowercase = "abcdefghijklmnopqrstuvwxyz"
ascii_uppercase = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

digits = "0123456789"
hexdigits = "0123456789abcdefABCDEF"
octdigits = "01234567"

punctuation = "!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~"
printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~ \t\n\r\x0b\x0c"
whitespace = " \t\n\r\x0b\x0c"
</t>
<t tx="ekr.20230509083243.1243">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

argv = list(__argv__, len(__argv__))

stdin = File(_C.seq_stdin())
stdout = File(_C.seq_stdout())
stderr = File(_C.seq_stderr())

def exit(status: int = 0):
    raise SystemExit(status)

maxsize = 0x7FFFFFFFFFFFFFFF
</t>
<t tx="ekr.20230509083243.1244">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple
class Lock:
    p: cobj

    def __new__() -&gt; Lock:
        return (_C.seq_lock_new(),)

    def acquire(self, block: bool = True, timeout: float = -1.0) -&gt; bool:
        if timeout &gt;= 0.0 and not block:
            raise ValueError("can't specify a timeout for a non-blocking call")
        return _C.seq_lock_acquire(self.p, block, timeout)

    def release(self):
        _C.seq_lock_release(self.p)

    def __enter__(self):
        self.acquire()

    def __exit__(self):
        self.release()

@tuple
class RLock:
    p: cobj

    def __new__() -&gt; RLock:
        return (_C.seq_rlock_new(),)

    def acquire(self, block: bool = True, timeout: float = -1.0) -&gt; bool:
        if timeout &gt;= 0.0 and not block:
            raise ValueError("can't specify a timeout for a non-blocking call")
        return _C.seq_rlock_acquire(self.p, block, timeout)

    def release(self):
        _C.seq_rlock_release(self.p)

    def __enter__(self):
        self.acquire()

    def __exit__(self):
        self.release()

def active_count() -&gt; int:
    from openmp import get_num_threads
    return get_num_threads()

def get_native_id() -&gt; int:
    from openmp import get_thread_num
    return get_thread_num()

def get_ident() -&gt; int:
    return get_native_id() + 1
</t>
<t tx="ekr.20230509083243.1245">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from sys import stderr

def time() -&gt; float:
    return _C.seq_time() / 1e9

def time_ns() -&gt; int:
    return _C.seq_time()

def monotonic() -&gt; float:
    return _C.seq_time_monotonic() / 1e9

def monotonic_ns() -&gt; int:
    return _C.seq_time_monotonic()

def perf_counter() -&gt; float:
    return _C.seq_time_highres() / 1e9

def perf_counter_ns() -&gt; int:
    return _C.seq_time_highres()

def sleep(secs: float):
    if secs &lt; 0:
        raise ValueError("sleep length must be non-negative")
    _C.seq_sleep(secs)

class TimeInterval:
    """
    Utility class for timing Seq code
    """

    start: int
    msg: str

    def __init__(self):
        self.start = _C.seq_time()
        self.msg = ""

    def __enter__(self):
        self.start = _C.seq_time()

    def __exit__(self):
        print(self.report(self.msg), file=stderr)

    def report(self, msg="", memory=False) -&gt; str:
        msg = f"{'Block' if not self.msg else self.msg} took {self.elapsed()}s"
        # if memory:
        # msg = f'{msg} ({_C.memory()} MB)'
        return msg

    def elapsed(self) -&gt; float:
        return float(_C.seq_time() - self.start) / 1e9

    def tick(self, msg, memory=False):
        ret = self.report(msg)
        self.start = _C.seq_time()

def timing(msg: str = "") -&gt; TimeInterval:
    """
    Example usage:

    .. code-block:: python

        from time import timing
        with timing('foo function'):
            foo()  # prints runtime of foo
    """
    return TimeInterval(0, msg)

@tuple
class struct_time:
    _year: i16
    _yday: i16
    _sec: i8
    _min: i8
    _hour: i8
    _mday: i8
    _mon: i8
    _wday: i8
    _isdst: i8

    # (sunday=0) --&gt; (monday=0)
    def _wday_adjust_monday_start(wday: int) -&gt; int:
        x = wday - 1
        if x &lt; 0:
            x = 6
        return x

    # (monday=0) --&gt; (sunday=0)
    def _wday_adjust_sunday_start(wday: int) -&gt; int:
        x = wday + 1
        if x &gt; 6:
            x = 0
        return x

    def __new__(
        year: int,
        mon: int,
        mday: int,
        hour: int,
        min: int,
        sec: int,
        wday: int,
        yday: int,
        isdst: int,
    ) -&gt; struct_time:
        return struct_time(
            i16(year - 1900),
            i16(yday - 1),
            i8(sec),
            i8(min),
            i8(hour),
            i8(mday),
            i8(mon - 1),
            i8(struct_time._wday_adjust_sunday_start(wday)),
            i8(isdst),
        )

    @property
    def tm_year(self) -&gt; int:
        return int(self._year) + 1900

    @property
    def tm_yday(self) -&gt; int:
        return int(self._yday) + 1

    @property
    def tm_sec(self) -&gt; int:
        return int(self._sec)

    @property
    def tm_min(self) -&gt; int:
        return int(self._min)

    @property
    def tm_hour(self) -&gt; int:
        return int(self._hour)

    @property
    def tm_mday(self) -&gt; int:
        return int(self._mday)

    @property
    def tm_mon(self) -&gt; int:
        return int(self._mon) + 1

    @property
    def tm_wday(self) -&gt; int:
        return struct_time._wday_adjust_monday_start(int(self._wday))

    @property
    def tm_isdst(self) -&gt; int:
        return int(self._isdst)


def localtime(secs: int = -1) -&gt; struct_time:
    tm = struct_time()
    worked = _C.seq_localtime(secs, __ptr__(tm).as_byte())
    if not worked:
        raise OSError("localtime failed")
    return tm


def gmtime(secs: int = -1) -&gt; struct_time:
    tm = struct_time()
    worked = _C.seq_gmtime(secs, __ptr__(tm).as_byte())
    if not worked:
        raise OSError("localtime failed")
    return tm


def mktime(t) -&gt; int:
    if isinstance(t, struct_time):
        return _C.seq_mktime(__ptr__(t).as_byte())
    else:
        tm = struct_time(*t)
        return _C.seq_mktime(__ptr__(tm).as_byte())

# pytime.h funcs

_ROUND_HALF_EVEN = 0
_ROUND_CEILING = 1
_ROUND_FLOOR = 2
_ROUND_UP = 3

_MIN = 0x8000000000000000
_MAX = 0x7FFFFFFFFFFFFFFF

def _overflow():
    raise OverflowError("timestamp too large")

def _add(t1: int, t2: int) -&gt; int:
    if t2 &gt; 0 and t1 &gt; _MAX - t2:
        return _MAX
    elif t2 &lt; 0 and t1 &lt; _MIN - t2:
        return _MIN
    else:
        return t1 + t2

def _mul_check_overflow(a: int, b: int) -&gt; bool:
    if b != 0:
        # assert b &gt; 0
        return (a &lt; _MIN // b) or (_MAX // b &lt; a)
    else:
        return False

def _mul(t: int, k: int) -&gt; int:
    # assert k &gt;= 0
    if _mul_check_overflow(t, k):
        return _MAX if t &gt;= 0 else _MIN
    else:
        return t * k

def _muldiv(ticks: int, mul: int, div: int) -&gt; int:
    intpart = ticks / div
    ticks %= div
    remaining = _mul(ticks, mul) // div
    return _add(_mul(intpart, mul), remaining)

def _round_half_even(x: float) -&gt; float:
    from math import fabs

    rounded = x.__round__()
    if fabs(x - rounded) == 0.5:
        rounded = 2.0 * (x / 2.0).__round__()
    return rounded

def _round(x: float, mode: int) -&gt; float:
    d = x
    if mode == _ROUND_HALF_EVEN:
        d = _round_half_even(d)
    elif mode == _ROUND_CEILING:
        d = d.__ceil__()
    elif mode == _ROUND_FLOOR:
        d = d.__floor__()
    elif mode == _ROUND_UP:
        d = d.__ceil__() if d &gt;= 0 else d.__floor__()
    return d

def _double_to_denominator(d: float, idenominator: int, mode: int) -&gt; Tuple[int, int]:
    from math import modf

    denominator = float(idenominator)
    floatpart, intpart = modf(d)

    floatpart *= denominator
    floatpart = _round(floatpart, mode)
    if floatpart &gt;= denominator:
        floatpart -= denominator
        intpart += 1.0
    elif floatpart &lt; 0.0:
        floatpart += denominator
        intpart -= 1.0
    # assert 0.0 &lt;= floatpart &lt; denominator

    if intpart &lt; _MIN or intpart &gt; _MAX:
        _overflow()

    sec = int(intpart)
    numerator = int(floatpart)
    # assert 0 &lt;= numerator &lt; idenominator
    return sec, numerator

def _time_to_timespec(t: float, mode: int) -&gt; Tuple[int, int]:
    return _double_to_denominator(t, 1000000000, mode)

def _time_to_timeval(t: float, mode: int) -&gt; Tuple[int, int]:
    return _double_to_denominator(t, 1000000, mode)
</t>
<t tx="ekr.20230509083243.1246">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# (empty)
</t>
<t tx="ekr.20230509083243.1247">@path C:/Repos/codon/stdlib/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Simplified version of Python's unittest.TestCase to allow
# copy/pasting tests directly from CPython's test suite.

class TestCase:
    def fail(self, standard_message: str, special_message: str = ""):
        print("TEST FAILED:", special_message if special_message else standard_message)

    def assertTrue(self, obj, msg=""):
        if not bool(obj):
            self.fail(f"expected object to be true: {obj}", msg)

    def assertFalse(self, obj, msg=""):
        if bool(obj):
            self.fail(f"expected object to be false: {obj}", msg)

    def assertEqual(self, first, second, msg=""):
        result = first == second
        if not result:
            self.fail(f"expected equality of:\n  1: {first}\n  2: {second}", msg)

    def assertNotEqual(self, first, second, msg=""):
        result = first != second
        if not result:
            self.fail(f"expected inequality of:\n  1: {first}\n  2: {second}", msg)

    def assertSequenceEqual(self, seq1, seq2, msg=""):
        len1 = len(seq1)
        len2 = len(seq2)
        if len1 != len2:
            self.fail(
                f"expected equality of sequences (len1={len1}, len2={len2}):\n  1: {seq1}\n  2: {seq2}",
                msg,
            )

        for i in range(len1):
            a, b = seq1[i], seq2[i]
            if a != b:
                self.fail(
                    f"expected equality of sequences (diff at elem {i}):\n  1: {seq1}\n  2: {seq2}",
                    msg,
                )

    def assertIn(self, member, container, msg=""):
        if member not in container:
            self.fail(f"expected {member} to be in {container}", msg)

    def assertNotIn(self, member, container, msg=""):
        if member in container:
            self.fail(f"expected {member} to not be in {container}", msg)

    def assertIs(self, expr1, expr2, msg=""):
        if expr1 is not expr2:
            self.fail(f"expected {expr1} to be identical to {expr2}", msg)

    def assertIsNot(self, expr1, expr2, msg=""):
        if expr1 is expr2:
            self.fail(f"expected {expr1} to not be identical to {expr2}", msg)

    def assertIsNot(self, expr1, expr2, msg=""):
        if expr1 is expr2:
            self.fail(f"expected {expr1} to not be identical to {expr2}", msg)

    def assertCountEqual(self, first, second, msg=""):
        from collections import Counter

        first_seq, second_seq = list(first), list(second)

        first_counter = Counter(first_seq)
        second_counter = Counter(second_seq)

        if first_counter != second_counter:
            self.fail(f"expected equal counts:\n  1: {first}\n  2: {second}", msg)

    def assertLess(self, a, b, msg=""):
        if not (a &lt; b):
            self.fail(f"expected less-than:\n  1: {a}\n  2: {b}", msg)

    def assertLessEqual(self, a, b, msg=""):
        if not (a &lt;= b):
            self.fail(f"expected less-than-or-equal:\n  1: {a}\n  2: {b}", msg)

    def assertGreater(self, a, b, msg=""):
        if not (a &gt; b):
            self.fail(f"expected greater-than:\n  1: {a}\n  2: {b}", msg)

    def assertGreaterEqual(self, a, b, msg=""):
        if not (a &gt;= b):
            self.fail(f"expected greater-than-or-equal:\n  1: {a}\n  2: {b}", msg)

    def assertIsNone(self, obj, msg=""):
        if obj is not None:
            self.fail(f"expected {obj} to be None", msg)

    def assertIsNotNone(self, obj, msg=""):
        if obj is None:
            self.fail(f"expected {obj} to not be None", msg)

    def assertRaises(self, exception: type, function, *args, **kwargs):
        try:
            function(*args, **kwargs)
        except exception:
            return
        except:
            pass
        self.fail(f"call to function did not raise the given exception")

    def assertAlmostEqual(
        self, first, second, places: int = 0, msg="", delta=None
    ):
        if first == second:
            # shortcut
            return
        if places &lt;= 0 and delta is None:
            raise ValueError("specify delta or places not both")

        standard_msg = ""
        diff = abs(first - second)
        if delta is not None:
            if diff &lt;= delta:
                return
            standard_msg = (
                f"{first} != {second} within {delta} delta ({diff} difference)"
            )
        else:
            if places &lt;= 0:
                places = 7
            if round(diff, places) == 0:
                return
            standard_msg = (
                f"{first} != {second} within {places} places ({diff} difference)"
            )
        self.fail(standard_msg, msg)
</t>
<t tx="ekr.20230509083243.1248"></t>
<t tx="ekr.20230509083243.1249">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def _heapify(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Makes the array a heap from [begin, end).
    """
    root = begin
    left = 2 * begin + 1
    right = 2 * begin + 2

    if left &lt; end and keyf(arr[root]) &lt; keyf(arr[left]):
        root = left

    if right &lt; end and keyf(arr[root]) &lt; keyf(arr[right]):
        root = right

    if root != begin:
        arr[begin], arr[root] = arr[root], arr[begin]
        _heapify(arr, root, end, keyf)

def _heap_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    if end - begin &lt; 2:
        return

    arr = arr.slice(begin, end)
    end -= begin
    begin = 0

    i = end // 2 - 1
    while i &gt;= 0:
        _heapify(arr, i, end, keyf)
        i -= 1

    i = end - 1
    while i &gt;= 0:
        arr[i], arr[0] = arr[0], arr[i]
        _heapify(arr, 0, i, keyf)
        i -= 1

def heap_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Heap Sort
    Sorts the array inplace.
    """
    _heap_sort(collection, 0, size, keyf)

def heap_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Heap Sort
    Sorts the list inplace.
    """
    heap_sort_array(collection.arr, collection.len, keyf)

def heap_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Heap Sort
    Returns a sorted list.
    """
    newlst = collection.__copy__()
    heap_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509083243.125">class CloneVisitor : public ConstVisitor {
private:
  /// the clone context
  std::unordered_map&lt;int, Node *&gt; ctx;
  /// the result
  Node *result;
  /// the module
  Module *module;
  /// true if break/continue loops should be cloned
  bool cloneLoop;

public:
  /// Constructs a clone visitor.
  /// @param module the module
  /// @param cloneLoop true if break/continue loops should be cloned
  explicit CloneVisitor(Module *module, bool cloneLoop = true)
      : ctx(), result(nullptr), module(module), cloneLoop(cloneLoop) {}

  virtual ~CloneVisitor() noexcept = default;

  void visit(const Var *v) override;

  void visit(const BodiedFunc *v) override;
  void visit(const ExternalFunc *v) override;
  void visit(const InternalFunc *v) override;
  void visit(const LLVMFunc *v) override;

  void visit(const VarValue *v) override;
  void visit(const PointerValue *v) override;

  void visit(const SeriesFlow *v) override;
  void visit(const IfFlow *v) override;
  void visit(const WhileFlow *v) override;
  void visit(const ForFlow *v) override;
  void visit(const ImperativeForFlow *v) override;
  void visit(const TryCatchFlow *v) override;
  void visit(const PipelineFlow *v) override;
  void visit(const dsl::CustomFlow *v) override;

  void visit(const IntConst *v) override;
  void visit(const FloatConst *v) override;
  void visit(const BoolConst *v) override;
  void visit(const StringConst *v) override;
  void visit(const dsl::CustomConst *v) override;

  void visit(const AssignInstr *v) override;
  void visit(const ExtractInstr *v) override;
  void visit(const InsertInstr *v) override;
  void visit(const CallInstr *v) override;
  void visit(const StackAllocInstr *v) override;
  void visit(const TypePropertyInstr *v) override;
  void visit(const YieldInInstr *v) override;
  void visit(const TernaryInstr *v) override;
  void visit(const BreakInstr *v) override;
  void visit(const ContinueInstr *v) override;
  void visit(const ReturnInstr *v) override;
  void visit(const YieldInstr *v) override;
  void visit(const ThrowInstr *v) override;
  void visit(const FlowInstr *v) override;
  void visit(const dsl::CustomInstr *v) override;

  /// Clones a value, returning the previous value if other has already been cloned.
  /// @param other the original
  /// @param cloneTo the function to clone locals to, or null if none
  /// @param remaps variable re-mappings
  /// @return the clone
  Value *clone(const Value *other, BodiedFunc *cloneTo = nullptr,
               const std::unordered_map&lt;id_t, Var *&gt; &amp;remaps = {});

  /// Returns the original unless the variable has been force cloned.
  /// @param other the original
  /// @return the original or the previous clone
  Var *clone(const Var *other);

  /// Clones a flow, returning the previous value if other has already been cloned.
  /// @param other the original
  /// @return the clone
  Flow *clone(const Flow *other) {
    return cast&lt;Flow&gt;(clone(static_cast&lt;const Value *&gt;(other)));
  }

  /// Forces a clone. No difference for values but ensures that variables are actually
  /// cloned.
  /// @param other the original
  /// @return the clone
  template &lt;typename NodeType&gt; NodeType *forceClone(const NodeType *other) {
    if (!other)
      return nullptr;

    auto id = other-&gt;getId();
    if (ctx.find(id) == ctx.end()) {
      other-&gt;accept(*this);
      ctx[id] = result;

      for (auto it = other-&gt;attributes_begin(); it != other-&gt;attributes_end(); ++it) {
        const auto *attr = other-&gt;getAttribute(*it);
        if (attr-&gt;needsClone()) {
          ctx[id]-&gt;setAttribute(attr-&gt;forceClone(*this), *it);
        }
      }
    }
    return cast&lt;NodeType&gt;(ctx[id]);
  }

@others
};

</t>
<t tx="ekr.20230509083243.1250">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def _insertion_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    i = begin + 1
    while i &lt; end:
        x = arr[i]
        j = i - 1
        while j &gt;= begin and keyf(x) &lt; keyf(arr[j]):
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = x
        i += 1

def insertion_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Insertion Sort
    Sorts the array inplace.
    """
    _insertion_sort(collection, 0, size, keyf)

def insertion_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Insertion Sort
    Sorts the list inplace.
    """
    insertion_sort_array(collection.arr, collection.len, keyf)

def insertion_sort(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
) -&gt; List[T]:
    """
    Insertion Sort
    Returns the sorted list.
    """
    newlst = collection.__copy__()
    insertion_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509083243.1251">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: https://github.com/orlp/pdqsort
# License:
#    Copyright (c) 2021 Orson Peters &lt;orsonpeters@gmail.com&gt;
#
#    This software is provided 'as-is', without any express or implied warranty. In no event will the
#    authors be held liable for any damages arising from the use of this software.
#
#    Permission is granted to anyone to use this software for any purpose, including commercial
#    applications, and to alter it and redistribute it freely, subject to the following restrictions:
#
#    1. The origin of this software must not be misrepresented; you must not claim that you wrote the
#    original software. If you use this software in a product, an acknowledgment in the product
#    documentation would be appreciated but is not required.
#
#    2. Altered source versions must be plainly marked as such, and must not be misrepresented as
#    being the original software.
#
#    3. This notice may not be removed or altered from any source distribution.

INSERTION_SORT_THRESHOLD = 24
NINTHER_THRESHOLD = 128
PARTIAL_INSERTION_SORT_LIMIT = 8

from algorithms.insertionsort import _insertion_sort
from algorithms.heapsort import _heap_sort

def _floor_log2(n: int) -&gt; int:
    """Returns floor(log2(n))"""
    log = 0
    while True:
        n &gt;&gt;= 1
        if n == 0:
            break
        log += 1
    return log

def _partial_insertion_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; bool:
    if begin == end:
        return True

    limit = 0
    cur = begin + 1
    while cur != end:
        if limit &gt; PARTIAL_INSERTION_SORT_LIMIT:
            return False

        sift = cur
        sift_1 = cur - 1

        if keyf(arr[sift]) &lt; keyf(arr[sift_1]):
            tmp = arr[sift]

            while True:
                arr[sift] = arr[sift_1]
                sift -= 1
                sift_1 -= 1
                if sift == begin or not keyf(tmp) &lt; keyf(arr[sift_1]):
                    break

            arr[sift] = tmp
            limit += cur - sift

        cur += 1

    return True

def _partition_left(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; int:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        last -= 1
        if not keyf(pivot) &lt; keyf(arr[last]):
            break

    if last + 1 == end:
        while first &lt; last:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    else:
        while True:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    while first &lt; last:
        arr[first], arr[last] = arr[last], arr[first]
        while True:
            last -= 1
            if not keyf(pivot) &lt; keyf(arr[last]):
                break
        while True:
            first += 1
            if keyf(pivot) &lt; keyf(arr[first]):
                break

    pivot_pos = last
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return pivot_pos

def _partition_right(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; Tuple[int, int]:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        first += 1
        if not keyf(arr[first]) &lt; keyf(pivot):
            break

    if first - 1 == begin:
        while first &lt; last:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    else:
        while True:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    already_partitioned = 0
    if first &gt;= last:
        already_partitioned = 1

    while first &lt; last:
        arr[first], arr[last] = arr[last], arr[first]

        while True:
            first += 1
            if not keyf(arr[first]) &lt; keyf(pivot):
                break

        while True:
            last -= 1
            if keyf(arr[last]) &lt; keyf(pivot):
                break

    pivot_pos = first - 1
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return (pivot_pos, already_partitioned)

def _sort2(
    arr: Array[T], i: int, j: int, keyf: Callable[[T], S], T: type, S: type
):
    if keyf(arr[j]) &lt; keyf(arr[i]):
        arr[i], arr[j] = arr[j], arr[i]

def _sort3(
    arr: Array[T], i: int, j: int, k: int, keyf: Callable[[T], S], T: type, S: type
):
    _sort2(arr, i, j, keyf)
    _sort2(arr, j, k, keyf)
    _sort2(arr, i, j, keyf)

def _pdq_sort(
    arr: Array[T],
    begin: int,
    end: int,
    keyf: Callable[[T], S],
    bad_allowed: int,
    leftmost: bool,
    T: type,
    S: type,
):
    while True:
        size = end - begin
        if size &lt; INSERTION_SORT_THRESHOLD:
            _insertion_sort(arr, begin, end, keyf)
            return

        size_2 = size // 2
        if size &gt; NINTHER_THRESHOLD:
            _sort3(arr, begin, begin + size_2, end - 1, keyf)
            _sort3(arr, begin + 1, begin + (size_2 - 1), end - 2, keyf)
            _sort3(arr, begin + 2, begin + (size_2 + 1), end - 3, keyf)
            _sort3(
                arr, begin + (size_2 - 1), begin + size_2, begin + (size_2 + 1), keyf
            )
            arr[begin], arr[begin + size_2] = arr[begin + size_2], arr[begin]
        else:
            _sort3(arr, begin + size_2, begin, end - 1, keyf)

        if not leftmost and not keyf(arr[begin - 1]) &lt; keyf(arr[begin]):
            begin = _partition_left(arr, begin, end, keyf) + 1
            continue

        part_result = _partition_right(arr, begin, end, keyf)
        pivot_pos = part_result[0]
        already_partitioned = part_result[1] == 1

        l_size = pivot_pos - begin
        r_size = end - (pivot_pos + 1)
        highly_unbalanced = (l_size &lt; (size // 8)) or (r_size &lt; (size // 8))

        if highly_unbalanced:
            bad_allowed -= 1
            if bad_allowed == 0:
                _heap_sort(arr, begin, end, keyf)
                return

            if l_size &gt;= INSERTION_SORT_THRESHOLD:
                arr[begin], arr[begin + l_size // 4] = (
                    arr[begin + l_size // 4],
                    arr[begin],
                )
                arr[pivot_pos - 1], arr[pivot_pos - l_size // 4] = (
                    arr[pivot_pos - l_size // 4],
                    arr[pivot_pos - 1],
                )

                if l_size &gt; NINTHER_THRESHOLD:
                    arr[begin + 1], arr[begin + (l_size // 4 + 1)] = (
                        arr[begin + (l_size // 4 + 1)],
                        arr[begin + 1],
                    )
                    arr[begin + 2], arr[begin + (l_size // 4 + 2)] = (
                        arr[begin + (l_size // 4 + 2)],
                        arr[begin + 2],
                    )
                    arr[pivot_pos - 2], arr[pivot_pos - (l_size // 4 + 1)] = (
                        arr[pivot_pos - (l_size // 4 + 1)],
                        arr[pivot_pos - 2],
                    )
                    arr[pivot_pos - 3], arr[pivot_pos - (l_size // 4 + 2)] = (
                        arr[pivot_pos - (l_size // 4 + 2)],
                        arr[pivot_pos - 3],
                    )

            if r_size &gt;= INSERTION_SORT_THRESHOLD:
                arr[pivot_pos + 1], arr[pivot_pos + (1 + r_size // 4)] = (
                    arr[pivot_pos + (1 + r_size // 4)],
                    arr[pivot_pos + 1],
                )
                arr[end - 1], arr[end - r_size // 4] = (
                    arr[end - r_size // 4],
                    arr[end - 1],
                )

                if r_size &gt; NINTHER_THRESHOLD:
                    arr[pivot_pos + 2], arr[pivot_pos + (2 + r_size // 4)] = (
                        arr[pivot_pos + (2 + r_size // 4)],
                        arr[pivot_pos + 2],
                    )
                    arr[pivot_pos + 3], arr[pivot_pos + (3 + r_size // 4)] = (
                        arr[pivot_pos + (3 + r_size // 4)],
                        arr[pivot_pos + 3],
                    )
                    arr[end - 2], arr[end - (1 + r_size // 4)] = (
                        arr[end - (1 + r_size // 4)],
                        arr[end - 2],
                    )
                    arr[end - 3], arr[end - (2 + r_size // 4)] = (
                        arr[end - (2 + r_size // 4)],
                        arr[end - 3],
                    )

        else:
            if (
                already_partitioned
                and _partial_insertion_sort(arr, begin, pivot_pos, keyf)
                and _partial_insertion_sort(arr, pivot_pos + 1, end, keyf)
            ):
                return

        _pdq_sort(arr, begin, pivot_pos, keyf, bad_allowed, leftmost)
        begin = pivot_pos + 1
        leftmost = False

def pdq_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the array inplace.
    """
    _pdq_sort(collection, 0, size, keyf, _floor_log2(size), True)

def pdq_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the list inplace.
    """
    pdq_sort_array(collection.arr, collection.len, keyf)

def pdq_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Returns a sorted list.
    """
    newlst = collection.__copy__()
    pdq_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509083243.1252">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Parts of this file: https://github.com/orlp/pdqsort
# License:
#    Copyright (c) 2021 Orson Peters &lt;orsonpeters@gmail.com&gt;
#
#    This software is provided 'as-is', without any express or implied warranty. In no event will the
#    authors be held liable for any damages arising from the use of this software.
#
#    Permission is granted to anyone to use this software for any purpose, including commercial
#    applications, and to alter it and redistribute it freely, subject to the following restrictions:
#
#    1. The origin of this software must not be misrepresented; you must not claim that you wrote the
#    original software. If you use this software in a product, an acknowledgment in the product
#    documentation would be appreciated but is not required.
#
#    2. Altered source versions must be plainly marked as such, and must not be misrepresented as
#    being the original software.
#
#    3. This notice may not be removed or altered from any source distribution.

def _med3(
    a: int, b: int, c: int, d: Array[T], k: Callable[[T], S], T: type, S: type
) -&gt; int:
    if k(d[a]) &lt; k(d[b]):
        return b if (k(d[b]) &lt; k(d[c])) else (c if k(d[a]) &lt; k(d[c]) else a)
    else:
        return (
            b
            if not (k(d[b]) &lt; k(d[c]) or k(d[b]) == k(d[c]))
            else (c if not (k(d[a]) &lt; k(d[c]) or k(d[a]) == k(d[c])) else a)
        )

def _swap(i: int, j: int, a: Array[T], T: type):
    a[i], a[j] = a[j], a[i]

def _vecswap(i: int, j: int, n: int, a: Array[T], T: type):
    while n &gt; 0:
        _swap(i, j, a)
        i += 1
        j += 1
        n -= 1

def _qsort(
    arr: Array[T], frm: int, cnt: int, key: Callable[[T], S], T: type, S: type
):
    if cnt &lt;= 7:
        i = frm + 1
        while i &lt; frm + cnt:
            j = i
            while j &gt; frm and not (
                key(arr[j - 1]) &lt; key(arr[j]) or key(arr[j - 1]) == key(arr[j])
            ):
                _swap(j, j - 1, arr)
                j -= 1
            i += 1
        return

    mid = cnt // 2
    lo = frm
    hi = frm + cnt - 1

    if cnt &gt; 40:
        s = cnt // 8
        lo = _med3(lo, lo + s, lo + 2 * s, arr, key)
        mid = _med3(mid - s, mid, mid + s, arr, key)
        hi = _med3(hi - 2 * s, hi - s, hi, arr, key)
    mid = _med3(lo, mid, hi, arr, key)

    _swap(frm, mid, arr)
    a = frm
    b = a
    c = frm + cnt - 1
    d = c

    while True:
        while b &lt;= c and (
            key(arr[b]) &lt; key(arr[frm]) or key(arr[b]) == key(arr[frm])
        ):
            if key(arr[b]) == key(arr[frm]):
                _swap(a, b, arr)
                a += 1
            b += 1

        while c &gt;= b and not key(arr[c]) &lt; key(arr[frm]):
            if key(arr[c]) == key(arr[frm]):
                _swap(c, d, arr)
                d -= 1
            c -= 1

        if b &gt; c:
            break
        _swap(b, c, arr)
        b += 1
        c -= 1

    hi = frm + cnt
    span = min(a - frm, b - a)
    _vecswap(frm, b - span, span, arr)

    span = min(d - c, hi - d - 1)
    _vecswap(b, hi - span, span, arr)

    span = b - a
    if span &gt; 1:
        _qsort(arr, frm, span, key)

    span = d - c
    if span &gt; 1:
        _qsort(arr, hi - span, span, key)

def qsort_array(
    collection: Array[T], size: int, key: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the array inplace.
    """
    _qsort(collection, 0, size, key)

def qsort_inplace(
    collection: List[T], key: Callable[[T], S], T: type, S: type
):
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Sorts the list inplace.
    """
    qsort_array(collection.arr, collection.len, key)

def qsort(collection: List[T], key: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    """
    Pattern-defeating Quicksort
    By Orson Peters, published at https://github.com/orlp/pdqsort

    Returns a sorted list.
    """
    collection = collection[:]
    qsort_inplace(collection, key)
    return collection
</t>
<t tx="ekr.20230509083243.1253">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Implementation of vectorized Rabin-Karp string search.
# See http://0x80.pl/articles/simd-strfind.html for
# details. These implementations are modified to not
# perform any out-of-bounds memory accesses.

@pure
@llvm
def cttz(n: UInt[N], N: Static[int]) -&gt; UInt[N]:
    declare i{=N} @llvm.cttz.i{=N}(i{=N}, i1)
    %0 = call i{=N} @llvm.cttz.i{=N}(i{=N} %n, i1 true)
    ret i{=N} %0

@pure
@llvm
def ctlz(n: UInt[N], N: Static[int]) -&gt; UInt[N]:
    declare i{=N} @llvm.ctlz.i{=N}(i{=N}, i1)
    %0 = call i{=N} @llvm.ctlz.i{=N}(i{=N} %n, i1 true)
    ret i{=N} %0

@pure
@llvm
def forward_mask(s: Ptr[byte], n: int, needle: Ptr[byte], k: int, i: int, firstb: byte, lastb: byte) -&gt; u16:
    %first0 = insertelement &lt;16 x i8&gt; undef, i8 %firstb, i64 0
    %first = shufflevector &lt;16 x i8&gt; %first0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %last0 = insertelement &lt;16 x i8&gt; undef, i8 %lastb, i64 0
    %last = shufflevector &lt;16 x i8&gt; %last0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %offset0 = add i64 %i, %k
    %offset = sub i64 %offset0, 1
    %ptr_first = getelementptr inbounds i8, ptr %s, i64 %i
    %ptr_last = getelementptr inbounds i8, ptr %s, i64 %offset
    %block_first = load &lt;16 x i8&gt;, ptr %ptr_first, align 1
    %block_last = load &lt;16 x i8&gt;, ptr %ptr_last, align 1
    %eq_first = icmp eq &lt;16 x i8&gt; %first, %block_first
    %eq_last = icmp eq &lt;16 x i8&gt; %last, %block_last
    %mask0 = and &lt;16 x i1&gt; %eq_first, %eq_last
    %mask = bitcast &lt;16 x i1&gt; %mask0 to i16
    ret i16 %mask

@pure
@llvm
def backward_mask(s: Ptr[byte], n: int, needle: Ptr[byte], k: int, i: int, firstb: byte, lastb: byte) -&gt; u16:
    %j0 = sub i64 %i, 16
    %j = add i64 %j0, 1
    %first0 = insertelement &lt;16 x i8&gt; undef, i8 %firstb, i64 0
    %first = shufflevector &lt;16 x i8&gt; %first0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %last0 = insertelement &lt;16 x i8&gt; undef, i8 %lastb, i64 0
    %last = shufflevector &lt;16 x i8&gt; %last0, &lt;16 x i8&gt; poison, &lt;16 x i32&gt; zeroinitializer
    %offset0 = sub i64 %j, %k
    %offset = add i64 %offset0, 1
    %ptr_first = getelementptr inbounds i8, ptr %s, i64 %offset
    %ptr_last = getelementptr inbounds i8, ptr %s, i64 %j
    %block_first = load &lt;16 x i8&gt;, ptr %ptr_first, align 1
    %block_last = load &lt;16 x i8&gt;, ptr %ptr_last, align 1
    %eq_first = icmp eq &lt;16 x i8&gt; %last, %block_last
    %eq_last = icmp eq &lt;16 x i8&gt; %first, %block_first
    %mask0 = and &lt;16 x i1&gt; %eq_first, %eq_last
    %mask = bitcast &lt;16 x i1&gt; %mask0 to i16
    ret i16 %mask

def forward_find(s: Ptr[byte], n: int, needle: Ptr[byte], k: int):
    if k == 0:
        return 0

    if n &lt; k:
        return -1

    if k == 1:
        p = _C.memchr(s, i32(int(needle[0])), n)
        return p - s if p else -1

    firstb = needle[0]
    lastb = needle[k - 1]
    i = 0

    while i + k + 16 - 1 &lt;= n:
        mask = forward_mask(s, n, needle, k, i, firstb, lastb)
        while mask:
            bitpos = int(cttz(mask))
            if _C.memcmp(s + i + bitpos + 1, needle + 1, k - 2) == i32(0):
                return i + bitpos
            mask = mask &amp; (mask - u16(1))
        i += 16

    # unrolled by hand
    while True:
        j = i + 0
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 1
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 2
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 3
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 4
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 5
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 6
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 7
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 8
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 9
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 10
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 11
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 12
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 13
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 14
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        j = i + 15
        if j + k &lt;= n:
            if firstb == s[j] and lastb == s[j + k - 1] and _C.memcmp(s + j + 1, needle + 1, k - 2) == i32(0):
                return j
        else:
            break

        break

    return -1

def backward_find(s: Ptr[byte], n: int, needle: Ptr[byte], k: int):
    if k == 0:
        return n

    if n &lt; k:
        return -1

    if k == 1:
        i = n - 1
        while i &gt;= 0:
            if s[i] == needle[0]:
                return i
            i -= 1
        return -1

    firstb = needle[0]
    lastb = needle[k - 1]
    i = n - 1

    while i - (k - 1) - (16 - 1) &gt;= 0:
        mask = backward_mask(s, n, needle, k, i, firstb, lastb)
        while mask:
            bitpos = int(ctlz(mask))
            if _C.memcmp(s + i - (k - 1) - bitpos + 1, needle + 1, k - 2) == i32(0):
                return i - (k - 1) - bitpos
            mask &amp;= ~(u16(1) &lt;&lt; u16(16 - 1 - bitpos))
        i -= 16

    # unrolled by hand
    while True:
        j = i - 0
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 1
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 2
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 3
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 4
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 5
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 6
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 7
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 8
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 9
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i + 10
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 11
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 12
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 13
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 14
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        j = i - 15
        if j - k + 1 &gt;= 0:
            if lastb == s[j] and firstb == s[j - k + 1] and _C.memcmp(s + j - k + 2, needle + 1, k - 2) == i32(0):
                return j - k + 1
        else:
            break

        break

    return -1

def find(haystack: str, needle: str):
    return forward_find(haystack.ptr, haystack.len, needle.ptr, needle.len)

def rfind(haystack: str, needle: str):
    return backward_find(haystack.ptr, haystack.len, needle.ptr, needle.len)

def count(haystack: str, needle: str):
    occ = 0
    tmp = haystack.ptr
    n = haystack.len
    k = needle.len

    if k == 0:
        return n + 1

    while True:
        pos = forward_find(tmp, n - (tmp - haystack.ptr), needle.ptr, k)
        if pos == -1:
            break
        tmp += pos + k
        occ += 1
    return occ

def count_with_max(haystack: str, needle: str, maxcount: int):
    occ = 0
    tmp = haystack.ptr
    n = haystack.len
    k = needle.len

    if maxcount == 0:
        return 0

    if k == 0:
        return n + 1 if n + 1 &lt; maxcount else maxcount

    while True:
        pos = forward_find(tmp, n - (tmp - haystack.ptr), needle.ptr, k)
        if pos == -1:
            break
        tmp += pos + k
        occ += 1
        if occ == maxcount:
            return occ
    return occ
</t>
<t tx="ekr.20230509083243.1254">@path C:/Repos/codon/stdlib/algorithms/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Pats of this file: (c) 2022 Python Software Foundation. All right reserved.
# License:
#    1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
#    the Individual or Organization ("Licensee") accessing and otherwise using Python
#    3.10.2 software in source or binary form and its associated documentation.
#
#    2. Subject to the terms and conditions of this License Agreement, PSF hereby
#    grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
#    analyze, test, perform and/or display publicly, prepare derivative works,
#    distribute, and otherwise use Python 3.10.2 alone or in any derivative
#    version, provided, however, that PSF's License Agreement and PSF's notice of
#    copyright, i.e., "Copyright  2001-2022 Python Software Foundation; All Rights
#    Reserved" are retained in Python 3.10.2 alone or in any derivative version
#    prepared by Licensee.
#
#    3. In the event Licensee prepares a derivative work that is based on or
#    incorporates Python 3.10.2 or any part thereof, and wants to make the
#    derivative work available to others as provided herein, then Licensee hereby
#    agrees to include in any such work a brief summary of the changes made to Python
#    3.10.2.
#
#    4. PSF is making Python 3.10.2 available to Licensee on an "AS IS" basis.
#    PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
#    EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
#    WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
#    USE OF PYTHON 3.10.2 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.
#
#    5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.10.2
#    FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
#    MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.10.2, OR ANY DERIVATIVE
#    THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.
#
#    6. This License Agreement will automatically terminate upon a material breach of
#    its terms and conditions.
#
#    7. Nothing in this License Agreement shall be deemed to create any relationship
#    of agency, partnership, or joint venture between PSF and Licensee.  This License
#    Agreement does not grant permission to use PSF trademarks or trade name in a
#    trademark sense to endorse or promote products or services of Licensee, or any
#    third party.
#
#    8. By copying, installing or otherwise using Python 3.10.2, Licensee agrees
#    to be bound by the terms and conditions of this License Agreement.
#
# Timsort by Tim Peters, published at https://github.com/python/cpython/blob/master/Objects/listobject.c#L2187

BLOCK_SIZE = 64
CACHELINE_SIZE = 64
MIN_GALLOP = 7

from algorithms.insertionsort import _insertion_sort

def _count_run(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
) -&gt; Tuple[int, int]:
    """
    Returns the # of elements in the next run and if the run is "inorder" or "reversed"
    """
    inorder = 1

    if end - begin == 1:
        return 1, inorder

    n = 2
    i = begin + 1
    if keyf(arr[i - 1]) &gt;= keyf(arr[i]):
        inorder = 0
        i += 1
        while i &lt; end:
            if keyf(arr[i - 1]) &lt; keyf(arr[i]):
                break
            i += 1
            n += 1

    else:
        i += 1
        while i &lt; end:
            if keyf(arr[i - 1]) &gt;= keyf(arr[i]):
                break
            i += 1
            n += 1

    return n, inorder

def _merge_compute_minrun(n: int) -&gt; int:
    """
    Computes the minrun for Timsort
    """
    r = 0
    while n &gt;= 64:
        r |= n &amp; 1
        n &gt;&gt;= 1
    return n + r

def _reverse_sortslice(arr: Array[T], begin: int, end: int, T: type):
    if end - begin &lt; 2:
        return
    arr[begin], arr[end - 1] = arr[end - 1], arr[begin]
    _reverse_sortslice(arr, begin + 1, end - 1)

def _modified_comp(
    a: T, b: T, keyf: Callable[[T], S], left: bool, T: type, S: type
) -&gt; bool:
    """
    Abstracts the left or right compare in gallop
    """
    if left:
        return keyf(b) &gt;= keyf(a)
    else:
        return keyf(a) &lt; keyf(b)

def _gallop(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    hint: int,
    left: bool,
    T: type,
    S: type,
) -&gt; int:
    """
    Gallop for Timsort
    """

    key = arr[0]  # just to initialize k
    if left:
        key = arr[b[0] + b[1] - 1]
    else:
        key = arr[b[0]]

    curr = a[0] + hint
    ofs, lastofs = 1, 0

    if _modified_comp(key, arr[curr], keyf, left):
        # Gallop left
        maxofs = hint + 1

        while ofs &lt; maxofs:
            if _modified_comp(key, arr[curr - ofs], keyf, left):
                lastofs = ofs
                ofs = (ofs &lt;&lt; 1) + 1
            else:
                break

        if ofs &gt; maxofs:
            ofs = maxofs

        ofs, lastofs = hint - lastofs, hint - ofs

    else:
        # Gallop right
        maxofs = a[1] - hint

        while ofs &lt; maxofs:
            if _modified_comp(key, arr[curr + ofs], keyf, left):
                break
            lastofs = ofs
            ofs = (ofs &lt;&lt; 1) + 1

        if ofs &gt; maxofs:
            ofs = maxofs

        lastofs += hint
        ofs += hint

    lastofs += 1
    while lastofs &lt; ofs:
        m = lastofs + ((ofs - lastofs) &gt;&gt; 1)
        if _modified_comp(key, arr[a[0] + m], keyf, left):
            ofs = m
        else:
            lastofs = m + 1

    return ofs

def _merge_with_gallop(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    min_gallop = MIN_GALLOP

    combined = Array[T](a[1] + b[1])
    a_copy = combined.slice(0, a[1])
    b_copy = combined.slice(a[1], len(combined))

    j = 0
    for i in range(a[0], a[0] + a[1]):
        combined[j] = arr[i]
        j += 1
    for i in range(b[0], b[0] + b[1]):
        combined[j] = arr[i]
        j += 1

    i, j, k = 0, 0, a[0]

    while i &lt; len(a_copy) and j &lt; len(b_copy):
        acount, bcount = 0, 0

        while i &lt; len(a_copy) and j &lt; len(b_copy):
            if keyf(b_copy[j]) &lt; keyf(a_copy[i]):
                arr[k] = b_copy[j]
                acount = 0
                bcount += 1
                j += 1
                k += 1
                if bcount &gt;= min_gallop:
                    break
            else:
                arr[k] = a_copy[i]
                acount += 1
                bcount = 0
                i += 1
                k += 1
                if acount &gt;= min_gallop:
                    break

        if i == len(a_copy) or j == len(b_copy):
            break

        min_gallop += 1

        while i &lt; len(a_copy) and j &lt; len(b_copy):
            if min_gallop &gt; 1:
                min_gallop -= 1

            acount = _gallop(
                combined, (0, len(a_copy)), (len(a_copy), len(b_copy)), keyf, i, False
            )
            if acount:
                while i &lt; acount:
                    arr[k] = a_copy[i]
                    i += 1
                    k += 1
                arr[k] = b_copy[j]
                j += 1
                k += 1

            if i == len(a_copy) or j == len(b_copy):
                break

            b_end = _gallop(
                combined, (len(a_copy), len(b_copy)), (0, len(a_copy)), keyf, j, True
            )
            bcount = len(b_copy) - b_end
            if bcount:
                while j &lt; b_end:
                    arr[k] = b_copy[j]
                    j += 1
                    k += 1
                arr[k] = a_copy[i]
                i += 1
                k += 1

            if acount &lt; MIN_GALLOP and bcount &lt; MIN_GALLOP:
                break

        min_gallop += 1

    while i &lt; len(a_copy):
        arr[k] = a_copy[i]
        i += 1
        k += 1

    while j &lt; len(b_copy):
        arr[k] = b_copy[j]
        j += 1
        k += 1

def _merge_at(
    arr: Array[T],
    a: Tuple[int, int],
    b: Tuple[int, int],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    start_a, len_a = a
    start_b, len_b = b

    # Where does b start in a?
    k = _gallop(arr, a, b, keyf, 0, False)
    start_a, len_a = start_a + k, len_a - k
    if len_a == 0:
        return

    # Where does a end in b?
    len_b = _gallop(arr, b, a, keyf, len_b - 1, True)
    if len_b == 0:
        return

    _merge_with_gallop(arr, (start_a, len_a), (start_b, len_b), keyf)

def _merge_collapse(
    arr: Array[T],
    stack: List[Tuple[int, int]],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    if len(stack) &lt;= 1:
        return

    while len(stack) &gt; 2:
        X = stack[-3]
        Y = stack[-2]
        Z = stack[-1]

        if X[1] &gt; Y[1] + Z[1] and Y[1] &gt; Z[1]:
            break

        C = stack.pop()
        B = stack.pop()
        A = stack.pop()

        if A[1] &lt;= B[1] + C[1]:
            if A[1] &lt; C[1]:
                _merge_at(arr, A, B, keyf)
                stack.append((A[0], A[1] + B[1]))
                stack.append(C)
            else:
                _merge_at(arr, B, C, keyf)
                stack.append(A)
                stack.append((B[0], B[1] + C[1]))

        else:
            _merge_at(arr, B, C, keyf)
            stack.append(A)
            stack.append((B[0], B[1] + C[1]))

    if len(stack) == 2:
        X = stack[-2]
        Y = stack[-1]

        if X[1] &lt;= Y[1]:
            C = stack.pop()
            B = stack.pop()
            _merge_at(arr, B, C, keyf)
            stack.append((B[0], B[1] + C[1]))
            return

def _final_merge(
    arr: Array[T],
    stack: List[Tuple[int, int]],
    keyf: Callable[[T], S],
    T: type,
    S: type,
):
    while len(stack) &gt; 1:
        C = stack.pop()
        B = stack.pop()
        _merge_at(arr, B, C, keyf)
        stack.append((B[0], B[1] + C[1]))

def _tim_sort(
    arr: Array[T], begin: int, end: int, keyf: Callable[[T], S], T: type, S: type
):
    if end - begin &lt; 2:
        return

    merge_pending = List[Tuple[int, int]]()
    minrun = _merge_compute_minrun(end - begin)
    i = begin
    while i &lt; end:
        n, inorder = _count_run(arr, i, end, keyf)
        if not inorder:
            _reverse_sortslice(arr, i, i + n)

        if n &lt; minrun:
            force = min(minrun, end - i)
            _insertion_sort(arr, i, i + force, keyf)
            n = force

        merge_pending.append((i, n))
        _merge_collapse(arr, merge_pending, keyf)
        i += n

    _final_merge(arr, merge_pending, keyf)

def tim_sort_array(
    collection: Array[T], size: int, keyf: Callable[[T], S], T: type, S: type
):
    _tim_sort(collection, 0, size, keyf)

def tim_sort_inplace(
    collection: List[T], keyf: Callable[[T], S], T: type, S: type
):
    tim_sort_array(collection.arr, collection.len, keyf)

def tim_sort(collection: List[T], keyf: Callable[[T], S], T: type, S: type) -&gt; List[T]:
    newlst = list(collection)
    tim_sort_inplace(newlst, keyf)
    return newlst
</t>
<t tx="ekr.20230509083243.1255"></t>
<t tx="ekr.20230509083243.1256">@path C:/Repos/codon/stdlib/experimental/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple(container=False)  # disallow default __getitem__
class Vec[T, N: Static[int]]:
    ZERO_16x8i = Vec[u8,16](u8(0))
    FF_16x8i = Vec[u8,16](u8(0xff))
    ZERO_32x8i = Vec[u8,32](u8(0))
    FF_32x8i = Vec[u8,32](u8(0xff))

    @llvm
    def _mm_set1_epi8(val: u8) -&gt; Vec[u8, 16]:
        %0 = insertelement &lt;16 x i8&gt; undef, i8 %val, i32 0
        %1 = shufflevector &lt;16 x i8&gt; %0, &lt;16 x i8&gt; undef, &lt;16 x i32&gt; zeroinitializer
        ret &lt;16 x i8&gt; %1

    @llvm
    def _mm256_set1_epi8(val: u8) -&gt; Vec[u8, 32]:
        %0 = insertelement &lt;32 x i8&gt; undef, i8 %val, i32 0
        %1 = shufflevector &lt;32 x i8&gt; %0, &lt;32 x i8&gt; undef, &lt;32 x i32&gt; zeroinitializer
        ret &lt;32 x i8&gt; %1

    @llvm
    def _mm_loadu_si128(data) -&gt; Vec[u8, 16]:
        %0 = bitcast i8* %data to &lt;16 x i8&gt;*
        %1 = load &lt;16 x i8&gt;, &lt;16 x i8&gt;* %0, align 1
        ret &lt;16 x i8&gt; %1

    @llvm
    def _mm256_loadu_si256(data) -&gt; Vec[u8, 32]:
        %0 = bitcast i8* %data to &lt;32 x i8&gt;*
        %1 = load &lt;32 x i8&gt;, &lt;32 x i8&gt;* %0, align 1
        ret &lt;32 x i8&gt; %1

    @llvm
    def _mm256_set1_ps(val: f32) -&gt; Vec[f32, 8]:
        %0 = insertelement &lt;8 x float&gt; undef, float %val, i32 0
        %1 = shufflevector &lt;8 x float&gt; %0, &lt;8 x float&gt; undef, &lt;8 x i32&gt; zeroinitializer
        ret &lt;8 x float&gt; %1

    @llvm
    def _mm512_set1_ps(val: f32) -&gt; Vec[f32, 16]:
        %0 = insertelement &lt;16 x float&gt; undef, float %val, i32 0
        %1 = shufflevector &lt;16 x float&gt; %0, &lt;16 x float&gt; undef, &lt;16 x i32&gt; zeroinitializer
        ret &lt;16 x float&gt; %1

    @llvm
    def _mm256_loadu_ps(data: Ptr[f32]) -&gt; Vec[f32, 8]:
        %0 = bitcast float* %data to &lt;8 x float&gt;*
        %1 = load &lt;8 x float&gt;, &lt;8 x float&gt;* %0
        ret &lt;8 x float&gt; %1

    @llvm
    def _mm512_loadu_ps(data: Ptr[f32]) -&gt; Vec[f32, 16]:
        %0 = bitcast float* %data to &lt;16 x float&gt;*
        %1 = load &lt;16 x float&gt;, &lt;16 x float&gt;* %0
        ret &lt;16 x float&gt; %1

    @llvm
    def _mm256_cvtepi8_epi32(vec: Vec[u8, 16]) -&gt; Vec[u32, 8]:
        %0 = shufflevector &lt;16 x i8&gt; %vec, &lt;16 x i8&gt; undef, &lt;8 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7&gt;
        %1 = sext &lt;8 x i8&gt; %0 to &lt;8 x i32&gt;
        ret &lt;8 x i32&gt; %1

    @llvm
    def _mm512_cvtepi8_epi64(vec: Vec[u8, 32]) -&gt; Vec[u32, 16]:
        %0 = shufflevector &lt;32 x i8&gt; %vec, &lt;32 x i8&gt; undef, &lt;16 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15&gt;
        %1 = sext &lt;16 x i8&gt; %0 to &lt;16 x i32&gt;
        ret &lt;16 x i32&gt; %1

    @llvm
    def _mm256_castsi256_ps(vec: Vec[u32, 8]) -&gt; Vec[f32, 8]:
        %0 = bitcast &lt;8 x i32&gt; %vec to &lt;8 x float&gt;
        ret &lt;8 x float&gt; %0

    @llvm
    def _mm512_castsi512_ps(vec: Vec[u32, 16]) -&gt; Vec[f32, 16]:
        %0 = bitcast &lt;16 x i32&gt; %vec to &lt;16 x float&gt;
        ret &lt;16 x float&gt; %0

    def __new__(x, T: type, N: Static[int]) -&gt; Vec[T, N]:
        if isinstance(T, u8) and N == 16:
            if isinstance(x, u8) or isinstance(x, byte): # TODO: u8&lt;-&gt;byte
                return Vec._mm_set1_epi8(x)
            if isinstance(x, Ptr[u8]) or isinstance(x, Ptr[byte]):
                return Vec._mm_loadu_si128(x)
            if isinstance(x, str):
                return Vec._mm_loadu_si128(x.ptr)
        if isinstance(T, u8) and N == 32:
            if isinstance(x, u8) or isinstance(x, byte): # TODO: u8&lt;-&gt;byte
                return Vec._mm256_set1_epi8(x)
            if isinstance(x, Ptr[u8]) or isinstance(x, Ptr[byte]):
                return Vec._mm256_loadu_si256(x)
            if isinstance(x, str):
                return Vec._mm256_loadu_si256(x.ptr)
        if isinstance(T, f32) and N == 8:
            if isinstance(x, f32):
                return Vec._mm256_set1_ps(x)
            if isinstance(x, Ptr[f32]):  # TODO: multi-elif does NOT work with statics [why?!]
                return Vec._mm256_loadu_ps(x)
            if isinstance(x, List[f32]):
                return Vec._mm256_loadu_ps(x.arr.ptr)
            if isinstance(x, Vec[u8, 16]):
                return Vec._mm256_castsi256_ps(Vec._mm256_cvtepi8_epi32(x))
        if isinstance(T, f32) and N == 16:
            if isinstance(x, f32):
                return Vec._mm512_set1_ps(x)
            if isinstance(x, Ptr[f32]):  # TODO: multi-elif does NOT work with statics [why?!]
                return Vec._mm512_loadu_ps(x)
            if isinstance(x, List[f32]):
                return Vec._mm512_loadu_ps(x.arr.ptr)
            if isinstance(x, Vec[u8, 32]):
                return Vec._mm512_castsi512_ps(Vec._mm512_cvtepi8_epi64(x))
        compile_error("invalid SIMD vector constructor")

    def __new__(x: str, offset: int = 0) -&gt; Vec[u8, N]:
        return Vec(x.ptr + offset, u8, N)

    def __new__(x: List[T], offset: int = 0) -&gt; Vec[T, N]:
        return Vec(x.arr.ptr + offset, T, N)

    def __new__(x) -&gt; Vec[T, N]:
        return Vec(x, T, N)

    @llvm
    def _mm_cmpeq_epi8(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        %0 = icmp eq &lt;16 x i8&gt; %x, %y
        %1 = sext &lt;16 x i1&gt; %0 to &lt;16 x i8&gt;
        ret &lt;16 x i8&gt; %1

    def __eq__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        return Vec._mm_cmpeq_epi8(self, other)

    @llvm
    def _mm256_cmpeq_epi8(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        %0 = icmp eq &lt;32 x i8&gt; %x, %y
        %1 = sext &lt;32 x i1&gt; %0 to &lt;32 x i8&gt;
        ret &lt;32 x i8&gt; %1

    def __eq__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        return Vec._mm256_cmpeq_epi8(self, other)

    @llvm
    def _mm_andnot_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        %0 = xor &lt;16 x i8&gt; %x, &lt;i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1&gt;
        %1 = and &lt;16 x i8&gt; %y, %0
        ret &lt;16 x i8&gt; %1

    def __ne__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        return Vec._mm_andnot_si128((self == other), Vec.FF_16x8i)

    @llvm
    def _mm256_andnot_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        %0 = xor &lt;32 x i8&gt; %x, &lt;i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1, i8 -1&gt;
        %1 = and &lt;32 x i8&gt; %y, %0
        ret &lt;32 x i8&gt; %1

    def __ne__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        return Vec._mm256_andnot_si256((self == other), Vec.FF_32x8i)

    def __eq__(self: Vec[u8, 16], other: bool) -&gt; Vec[u8, 16]:
        if not other:
            return Vec._mm_andnot_si128(self, Vec.FF_16x8i)
        else:
            return Vec._mm_andnot_si128(self, Vec.ZERO_16x8i)

    def __eq__(self: Vec[u8, 32], other: bool) -&gt; Vec[u8, 32]:
        if not other:
            return Vec._mm256_andnot_si256(self, Vec.FF_32x8i)
        else:
            return Vec._mm256_andnot_si256(self, Vec.ZERO_32x8i)

    @llvm
    def _mm_and_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        %0 = and &lt;16 x i8&gt; %x, %y
        ret &lt;16 x i8&gt; %0

    def __and__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        return Vec._mm_and_si128(self, other)

    @llvm
    def _mm_and_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        %0 = and &lt;32 x i8&gt; %x, %y
        ret &lt;32 x i8&gt; %0

    def __and__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        return Vec._mm_and_si256(self, other)

    @llvm
    def _mm256_and_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        %0 = bitcast &lt;8 x float&gt; %x to &lt;8 x i32&gt;
        %1 = bitcast &lt;8 x float&gt; %y to &lt;8 x i32&gt;
        %2 = and &lt;8 x i32&gt; %0, %1
        %3 = bitcast &lt;8 x i32&gt; %2 to &lt;8 x float&gt;
        ret &lt;8 x float&gt; %3

    def __and__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        return Vec._mm256_and_ps(self, other)

    @llvm
    def _mm512_and_ps(x: Vec[f32, 16], y: Vec[f32, 16]) -&gt; Vec[f32, 16]:
        %0 = bitcast &lt;16 x float&gt; %x to &lt;16 x i32&gt;
        %1 = bitcast &lt;16 x float&gt; %y to &lt;16 x i32&gt;
        %2 = and &lt;16 x i32&gt; %0, %1
        %3 = bitcast &lt;16 x i32&gt; %2 to &lt;16 x float&gt;
        ret &lt;16 x float&gt; %3

    def __and__(self: Vec[f32, 16], other: Vec[f32, 16]) -&gt; Vec[f32, 16]:
        return Vec._mm512_and_ps(self, other)

    @llvm
    def _mm_or_si128(x: Vec[u8, 16], y: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        %0 = or &lt;16 x i8&gt; %x, %y
        ret &lt;16 x i8&gt; %0

    def __or__(self: Vec[u8, 16], other: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        return Vec._mm_or_si128(self, other)

    @llvm
    def _mm_or_si256(x: Vec[u8, 32], y: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        %0 = or &lt;32 x i8&gt; %x, %y
        ret &lt;32 x i8&gt; %0

    def __or__(self: Vec[u8, 32], other: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        return Vec._mm_or_si256(self, other)

    @llvm
    def _mm256_or_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        %0 = bitcast &lt;8 x float&gt; %x to &lt;8 x i32&gt;
        %1 = bitcast &lt;8 x float&gt; %y to &lt;8 x i32&gt;
        %2 = or &lt;8 x i32&gt; %0, %1
        %3 = bitcast &lt;8 x i32&gt; %2 to &lt;8 x float&gt;
        ret &lt;8 x float&gt; %3

    def __or__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        return Vec._mm256_or_ps(self, other)

    @llvm
    def _mm512_or_ps(x: Vec[f32, 16], y: Vec[f32, 16]) -&gt; Vec[f32, 16]:
        %0 = bitcast &lt;16 x float&gt; %x to &lt;16 x i32&gt;
        %1 = bitcast &lt;16 x float&gt; %y to &lt;16 x i32&gt;
        %2 = or &lt;16 x i32&gt; %0, %1
        %3 = bitcast &lt;16 x i32&gt; %2 to &lt;16 x float&gt;
        ret &lt;16 x float&gt; %3

    def __or__(self: Vec[f32, 16], other: Vec[f32, 16]) -&gt; Vec[f32, 16]:
        return Vec._mm512_or_ps(self, other)

    @llvm
    def _mm_bsrli_si128_8(vec: Vec[u8, 16]) -&gt; Vec[u8, 16]:
        %0 = shufflevector &lt;16 x i8&gt; %vec, &lt;16 x i8&gt; zeroinitializer, &lt;16 x i32&gt; &lt;i32 8, i32 9, i32 10, i32 11, i32 12, i32 13, i32 14, i32 15, i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23&gt;
        ret &lt;16 x i8&gt; %0

    @llvm
    def _mm256_add_ps(x: Vec[f32, 8], y: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        %0 = fadd &lt;8 x float&gt; %x, %y
        ret &lt;8 x float&gt; %0

    def __add__(self: Vec[f32, 8], other: Vec[f32, 8]) -&gt; Vec[f32, 8]:
        return Vec._mm256_add_ps(self, other)

    def __rshift__(self: Vec[u8, 16], shift: Static[int]) -&gt; Vec[u8, 16]:
        if shift == 0:
            return self
        elif shift == 8:
            return Vec._mm_bsrli_si128_8(self)
        else:
            compile_error("invalid bitshift")

    @llvm
    def _mm_bsrli_256(vec: Vec[u8, 32]) -&gt; Vec[u8, 32]:
        %0 = shufflevector &lt;32 x i8&gt; %vec, &lt;32 x i8&gt; zeroinitializer, &lt;32 x i32&gt; &lt;i32 16, i32 17, i32 18, i32 19, i32 20, i32 21, i32 22, i32 23, i32 24, i32 25, i32 26, i32 27, i32 28, i32 29, i32 30, i32 31, i32 32, i32 33, i32 34, i32 35, i32 36, i32 37, i32 38, i32 39, i32 40, i32 41, i32 42, i32 43, i32 44, i32 45, i32 46, i32 47&gt;
        ret &lt;32 x i8&gt; %0

    def __rshift__(self: Vec[u8, 32], shift: Static[int]) -&gt; Vec[u8, 32]:
        if shift == 0:
            return self
        elif shift == 16:
            return Vec._mm_bsrli_256(self)
        else:
            compile_error("invalid bitshift")

    # @llvm  # https://stackoverflow.com/questions/6996764/fastest-way-to-do-horizontal-sse-vector-sum-or-other-reduction
    # def sum(self: Vec[f32, 8]) -&gt; f32:
    #     %0 = shufflevector &lt;8 x float&gt; %self, &lt;8 x float&gt; undef, &lt;4 x i32&gt; &lt;i32 0, i32 1, i32 2, i32 3&gt;
    #     %1 = shufflevector &lt;8 x float&gt; %self, &lt;8 x float&gt; poison, &lt;4 x i32&gt; &lt;i32 4, i32 5, i32 6, i32 7&gt;
    #     %2 = fadd &lt;4 x float&gt; %0, %1
    #     %3 = shufflevector &lt;4 x float&gt; %2, &lt;4 x float&gt; undef, &lt;4 x i32&gt; &lt;i32 1, i32 undef, i32 3, i32 undef&gt;
    #     %4 = fadd &lt;4 x float&gt; %2, %3
    #     %5 = shufflevector &lt;4 x float&gt; %4, &lt;4 x float&gt; poison, &lt;4 x i32&gt; &lt;i32 2, i32 undef, i32 undef, i32 undef&gt;
    #     %6 = fadd &lt;4 x float&gt; %4, %5
    #     %7 = extractelement &lt;4 x float&gt; %6, i32 0
    #     ret float %7

    def sum(self: Vec[f32, 8], x: f32 = f32(0.0)) -&gt; f32:
        return x + self[0] + self[1] + self[2] + self[3] + self[4] + self[5] + self[6] + self[7]

    @llvm
    def __getitem__(self, n: Static[int]) -&gt; T:
        %0 = extractelement &lt;{=N} x {=T}&gt; %self, i32 {=n}
        ret {=T} %0

    def __repr__(self):
        if N == 8:
            return f"&lt;{self[0]}, {self[1]}, {self[2]}, {self[3]}, {self[4]}, {self[5]}, {self[6]}, {self[7]}&gt;"
        elif N == 16:
            return f"&lt;{self[0]}, {self[1]}, {self[2]}, {self[3]}, {self[4]}, {self[5]}, {self[6]}, {self[7]}, {self[8]}, {self[9]}, {self[10]}, {self[11]}, {self[12]}, {self[13]}, {self[14]}, {self[15]}&gt;"
        else:
            return "?"

    def scatter(self: Vec[T, N]) -&gt; List[T]:
        return [self[i] for i in staticrange(N)]


u8x16 = Vec[u8, 16]
u8x32 = Vec[u8, 32]
f32x8 = Vec[f32, 8]
</t>
<t tx="ekr.20230509083243.1257"></t>
<t tx="ekr.20230509083243.1258">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@__attribute__
def test():
    pass

@__attribute__
def export():
    pass

@__attribute__
def inline():
    pass

@__attribute__
def noinline():
    pass

@__attribute__
def pure():
    pass

@__attribute__
def nonpure():
    pass

@__attribute__
def no_side_effect():
    pass

@__attribute__
def nocapture():
    pass

@__attribute__
def pycapture():
    pass

@__attribute__
def derives():
    pass

@__attribute__
def self_captures():
    pass

@__attribute__
def commutative():
    pass

@__attribute__
def associative():
    pass

@__attribute__
def distributive():
    pass

@__attribute__
def realize_without_self():
    pass

@__attribute__
def virtual():
    pass

@__attribute__
def no_argument_wrap():
    pass

@__attribute__
def no_type_wrap():
    pass
</t>
<t tx="ekr.20230509083243.1259">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

class object:
    def __init__(self):
        pass

    def __repr__(self) -&gt; str:
        return f"&lt;{self.__class__.__name__} object at {self.__raw__()}&gt;"

def id(x) -&gt; int:
    if isinstance(x, ByRef):
        return int(x.__raw__())
    else:
        return 0

_stdout = _C.seq_stdout()

def print(*args, sep: str = " ", end: str = "\n", file=_stdout, flush: bool = False):
    """
    Print args to the text stream file.
    """
    fp = cobj()
    if isinstance(file, cobj):
        fp = file
    else:
        fp = file.fp
    i = 0
    for a in args:
        if i and sep:
            _C.seq_print_full(sep, fp)
        _C.seq_print_full(str(a), fp)
        i += 1
    _C.seq_print_full(end, fp)
    if flush:
        _C.fflush(fp)

@extend
class __internal__:
    def prn(*args):
        print(*args)

def min(*args):
    if staticlen(args) == 0:
        raise ValueError("empty sequence")
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        x = args[0].__iter__()
        if not x.done():
            s = x.next()
            while not x.done():
                i = x.next()
                if i &lt; s:
                    s = i
            x.destroy()
            return s
        else:
            x.destroy()
        raise ValueError("empty sequence")
    elif staticlen(args) == 2:
        a, b = args
        return a if a &lt;= b else b
    else:
        m = args[0]
        for i in args:
            if i &lt; m:
                m = i
        return m

def max(*args):
    if staticlen(args) == 0:
        raise ValueError("empty sequence")
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        x = args[0].__iter__()
        if not x.done():
            s = x.next()
            while not x.done():
                i = x.next()
                if i &gt; s:
                    s = i
            x.destroy()
            return s
        else:
            x.destroy()
        raise ValueError("empty sequence")
    elif staticlen(args) == 2:
        a, b = args
        return a if a &gt;= b else b
    else:
        m = args[0]
        for i in args:
            if i &gt; m:
                m = i
        return m

def len(x) -&gt; int:
    """
    Return the length of x
    """
    return x.__len__()

def iter(x):
    """
    Return an iterator for the given object
    """
    return x.__iter__()

def abs(x):
    """
    Return the absolute value of x
    """
    return x.__abs__()

def hash(x) -&gt; int:
    """
    Returns hashed value only for immutable objects
    """
    return x.__hash__()

def ord(s: str) -&gt; int:
    """
    Return an integer representing the Unicode code point of s
    """
    if len(s) != 1:
        raise TypeError(
            f"ord() expected a character, but string of length {len(s)} found"
        )
    return int(s.ptr[0])

def divmod(a, b):
    if hasattr(a, "__divmod__"):
        return a.__divmod__(b)
    else:
        return (a // b, a % b)

def chr(i: int) -&gt; str:
    """
    Return a string representing a character whose Unicode
    code point is an integer
    """
    p = cobj(1)
    p[0] = byte(i)
    return str(p, 1)

def next(g: Generator[T], default: Optional[T] = None, T: type) -&gt; T:
    """
    Return the next item from g
    """
    if g.done():
        if default is not None:
            return default.__val__()
        else:
            raise StopIteration()
    return g.next()

def any(x: Generator[T], T: type) -&gt; bool:
    """
    Returns True if any item in x is true,
    False otherwise
    """
    for a in x:
        if a:
            return True
    return False

def all(x: Generator[T], T: type) -&gt; bool:
    """
    Returns True when all elements in x are true,
    False otherwise
    """
    for a in x:
        if not a:
            return False
    return True

def zip(*args):
    """
    Returns a zip object, which is an iterator of tuples
    that aggregates elements based on the iterables passed
    """
    if staticlen(args) == 0:
        yield from List[int]()
    else:
        iters = tuple(iter(i) for i in args)
        done = False
        while not done:
            for i in iters:
                if i.done():
                    done = True
            if not done:
                yield tuple(i.next() for i in iters)
        for i in iters:
            i.destroy()

def filter(f: Callable[[T], bool], x: Generator[T], T: type) -&gt; Generator[T]:
    """
    Returns all a from the iterable x that are filtered by f
    """
    for a in x:
        if f(a):
            yield a

def map(f, *args):
    """
    Applies a function on all a in x and returns map object
    """
    if staticlen(args) == 0:
        compile_error("map() expects at least one iterator")
    elif staticlen(args) == 1:
        for a in args[0]:
            yield f(a)
    else:
        for a in zip(*args):
            yield f(*a)

def enumerate(x, start: int = 0):
    """
    Creates a tuple containing a count (from start which defaults
    to 0) and the values obtained from iterating over x
    """
    i = start
    for a in x:
        yield (i, a)
        i += 1

def staticenumerate(tup):
    i = -1
    return tuple(((i := i + 1), t) for t in tup)
    i

def echo(x):
    """
    Print and return argument
    """
    print x
    return x

def reversed(x):
    """
    Return an iterator that accesses x in the reverse order
    """
    if hasattr(x, "__reversed__"):
        return x.__reversed__()
    else:
        i = x.__len__() - 1
        while i &gt;= 0:
            yield x[i]
            i -= 1

def round(x, n=0):
    """
    Return the x rounded off to the given
    n digits after the decimal point.
    """
    nx = float.__pow__(10.0, n)
    return float.__round__(x * nx) / nx

def _sum_start(x, start):
    if isinstance(x.__iter__(), Generator[float]) and isinstance(start, int):
        return float(start)
    else:
        return start

def sum(x, start=0):
    """
    Return the sum of the items added together from x
    """
    s = _sum_start(x, start)

    for a in x:
        # don't use += to avoid calling iadd
        if isinstance(a, bool):
            s = s + (1 if a else 0)
        else:
            s = s + a

    return s

def repr(x):
    """Return the string representation of x"""
    return x.__repr__()

def _int_format(a: int, base: int, prefix: str = ""):
    assert base == 2 or base == 8 or base == 10 or base == 16
    chars = "0123456789abcdef-"

    b = a
    digits = 0
    while b != 0:
        digits += 1
        b //= base

    sz = digits + (1 if a &lt;= 0 else 0) + len(prefix)
    p = Ptr[byte](sz)
    q = p

    if a &lt; 0:
        q[0] = chars[-1].ptr[0]
        q += 1

    if prefix:
        str.memcpy(q, prefix.ptr, len(prefix))
        q += len(prefix)

    if digits != 0:
        b = a
        q += digits - 1
        i = 1
        while b != 0:
            i += 1
            q[0] = chars.ptr[abs(b % base)]
            q += -1
            b //= base
    else:
        q[0] = chars.ptr[0]

    return str(p, sz)

def bin(n):
    return _int_format(n.__index__(), 2, "0b")

def oct(n):
    return _int_format(n.__index__(), 8, "0o")

def hex(n):
    return _int_format(n.__index__(), 16, "0x")

def pow(base: float, exp: float):
    return base ** exp

@overload
def pow(base: int, exp: int, mod: Optional[int] = None):
    if exp &lt; 0:
        raise ValueError("pow() negative int exponent not supported")

    if mod is not None:
        if mod == 0:
            raise ValueError("pow() 3rd argument cannot be 0")
        base %= mod

    result = 1
    while exp &gt; 0:
        if exp &amp; 1:
            x = result * base
            result = x % mod if mod is not None else x
        y = base * base
        base = y % mod if mod is not None else y
        exp &gt;&gt;= 1
    return result % mod if mod is not None else result

@extend
class int:
    def _from_str(s: str, base: int):
        from internal.gc import alloc_atomic, free

        if base &lt; 0 or base &gt; 36 or base == 1:
            raise ValueError("int() base must be &gt;= 2 and &lt;= 36, or 0")

        s0 = s
        s = s.strip()
        buf = __array__[byte](32)
        n = len(s)
        need_dyn_alloc = n &gt;= len(buf)

        p = alloc_atomic(n + 1) if need_dyn_alloc else buf.ptr
        str.memcpy(p, s.ptr, n)
        p[n] = byte(0)

        end = cobj()
        result = _C.strtoll(p, __ptr__(end), i32(base))

        if need_dyn_alloc:
            free(p)

        if n == 0 or end != p + n:
            raise ValueError(
                f"invalid literal for int() with base {base}: {s0.__repr__()}"
            )

        return result

@extend
class float:
    def _from_str(s: str) -&gt; float:
        s0 = s
        s = s.strip()
        buf = __array__[byte](32)
        n = len(s)
        need_dyn_alloc = n &gt;= len(buf)

        p = alloc_atomic(n + 1) if need_dyn_alloc else buf.ptr
        str.memcpy(p, s.ptr, n)
        p[n] = byte(0)

        end = cobj()
        result = _C.strtod(p, __ptr__(end))

        if need_dyn_alloc:
            free(p)

        if n == 0 or end != p + n:
            raise ValueError(f"could not convert string to float: {s0.__repr__()}")

        return result

def _jit_display(x, s: Static[str], bundle: Set[str] = Set[str]()):
    if isinstance(x, None):
        return
    if hasattr(x, "_repr_mimebundle_") and s == "jupyter":
        d = x._repr_mimebundle_(bundle)
        # TODO: pick appropriate mime
        mime = next(d.keys()) # just pick first
        print(f"\x00\x00__codon/mime__\x00{mime}\x00{d[mime]}", end='')
    elif hasattr(x, "__repr__"):
        print(x.__repr__(), end='')
    elif hasattr(x, "__str__"):
        print(x.__str__(), end='')
</t>
<t tx="ekr.20230509083243.126">  /// Remaps a clone.
  /// @param original the original
  /// @param newVal the clone
  template &lt;typename NodeType&gt;
  void forceRemap(const NodeType *original, const NodeType *newVal) {
    ctx[original-&gt;getId()] = const_cast&lt;NodeType *&gt;(newVal);
  }

</t>
<t tx="ekr.20230509083243.1260">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@__internal__
class __internal__:
    pass

@tuple
@__internal__
@__notuple__
class bool:
    pass

@tuple
@__internal__
@__notuple__
class byte:
    pass

@tuple
@__internal__
@__notuple__
class int:
    MAX = 9223372036854775807
    pass

@tuple
@__internal__
@__notuple__
class float:
    MIN_10_EXP = -307
    pass

@tuple
@__internal__
@__notuple__
class float32:
    MIN_10_EXP = -37
    pass

@tuple
@__internal__
class NoneType:
    pass

@tuple
@__internal__
class type:
    pass

@tuple
@__internal__
@__notuple__
class Function[T, TR]:
    pass

@tuple
@__internal__
class Callable[T, TR]:
    pass

@tuple
@__internal__
@__notuple__
class Ptr[T]:
    pass
cobj = Ptr[byte]

@tuple
@__internal__
@__notuple__
class Generator[T]:
    pass

@tuple
@__internal__
@__notuple__
class Optional:
    T: type = NoneType

@tuple
@__internal__
@__notuple__
class Int[N: Static[int]]:
    pass

@tuple
@__internal__
@__notuple__
class UInt[N: Static[int]]:
    pass

@__internal__
class pyobj:
    p: Ptr[byte]

@tuple
@__internal__
class str:
    ptr: Ptr[byte]
    len: int

@tuple
@__internal__
class Array:
    len: int
    ptr: Ptr[T]
    T: type

@extend
class type:
    def __new__(obj):
        pass
function = Function

@__internal__
class Ref[T]:
    pass

@tuple
@__internal__
@__notuple__
class Union[TU]:
    # compiler-generated
    def __new__(val):
        TU

# dummy
@__internal__
class TypeVar[T]: pass
@__internal__
class ByVal: pass
@__internal__
class ByRef: pass
@__internal__
class Tuple: pass

@__internal__
class ClassVar[T]:
    pass

@__internal__
@tuple
class CVar[T]:
    def __new__(name: Static[str]) -&gt; T:
        return T()

@tuple
@__internal__
class __array__:
    T: type
    def __new__(sz: Static[int]) -&gt; Array[T]:
        pass

def __ptr__(var):
    pass

def staticlen(obj):
    pass

def compile_error(msg: Static[str]):
    pass

def isinstance(obj, what):
    pass

@__attribute__
def overload():
    pass

def hasattr(obj, attr: Static[str], *args, **kwargs):
    """Special handling"""
    pass

@overload
def hasattr(obj, attr: Static[str]):
    pass

def getattr(obj, attr: Static[str]):
    pass

def setattr(obj, attr: Static[str], what):
    pass

def tuple(iterable):
    pass

def super():
    pass

def superf(*args):
    """Special handling"""
    pass

def __realized__(fn, args):
    pass

def statictuple(*args):
    return args
</t>
<t tx="ekr.20230509083243.1261">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# runtime functions
from C import seq_print(str)
from C import seq_print_full(str, cobj)

@nocapture
@C
def seq_str_int(a: int, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

@nocapture
@C
def seq_str_uint(a: int, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

@nocapture
@C
def seq_str_float(a: float, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

@nocapture
@C
def seq_str_str(a: str, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

@nocapture
@C
def seq_str_ptr(a: cobj, fmt: str, error: Ptr[bool]) -&gt; str:
    pass

@pure
@C
def seq_strdup(a: cobj) -&gt; str:
    pass

@pure
@C
def seq_stdin() -&gt; cobj:
    pass

@pure
@C
def seq_stdout() -&gt; cobj:
    pass

@pure
@C
def seq_stderr() -&gt; cobj:
    pass

@no_side_effect
@C
def seq_env() -&gt; Ptr[cobj]:
    pass

@no_side_effect
@C
def seq_time() -&gt; int:
    pass

@no_side_effect
@C
def seq_time_monotonic() -&gt; int:
    pass

@no_side_effect
@C
def seq_time_highres() -&gt; int:
    pass

@no_side_effect
@C
def seq_localtime(a: int, b: cobj) -&gt; bool:
    pass

@no_side_effect
@C
def seq_gmtime(a: int, b: cobj) -&gt; bool:
    pass

@pure
@C
def seq_mktime(a: cobj) -&gt; int:
    pass

from C import seq_sleep(float)

@pure
@C
def seq_pid() -&gt; int:
    pass

@pure
@C
def seq_lock_new() -&gt; cobj:
    pass

@nocapture
@C
def seq_lock_acquire(a: cobj, b: bool, c: float) -&gt; bool:
    pass

@nocapture
@C
def seq_lock_release(a: cobj) -&gt; None:
    pass

@pure
@C
def seq_rlock_new() -&gt; cobj:
    pass

@nocapture
@C
def seq_rlock_acquire(a: cobj, b: bool, c: float) -&gt; bool:
    pass

@nocapture
@C
def seq_rlock_release(a: cobj) -&gt; None:
    pass

@pure
@C
def seq_i32_to_float(a: i32) -&gt; float:
    pass

# &lt;ctype.h&gt;
@pure
@C
def isdigit(a: i32) -&gt; i32:
    pass

@pure
@C
def isspace(a: i32) -&gt; i32:
    pass

@pure
@C
def isupper(a: i32) -&gt; i32:
    pass

@pure
@C
def islower(a: i32) -&gt; i32:
    pass

@pure
@C
def toupper(a: i32) -&gt; i32:
    pass

@pure
@C
def tolower(a: i32) -&gt; i32:
    pass

@pure
@C
def isalnum(a: i32) -&gt; i32:
    pass

@pure
@C
def isalpha(a: i32) -&gt; i32:
    pass

# &lt;math.h&gt;
@pure
@C
def ceil(a: float) -&gt; float:
    pass

@pure
@C
def floor(a: float) -&gt; float:
    pass

@pure
@C
def fabs(a: float) -&gt; float:
    pass

@pure
@C
def fmod(a: float, b: float) -&gt; float:
    pass

@pure
@C
def exp(a: float) -&gt; float:
    pass

@pure
@C
def expm1(a: float) -&gt; float:
    pass

@pure
@C
def ldexp(a: float, b: i32) -&gt; float:
    pass

@pure
@C
def log(a: float) -&gt; float:
    pass

@pure
@C
def log2(a: float) -&gt; float:
    pass

@pure
@C
def log10(a: float) -&gt; float:
    pass

@pure
@C
def sqrt(a: float) -&gt; float:
    pass

@pure
@C
def pow(a: float, b: float) -&gt; float:
    pass

@pure
@C
def round(a: float) -&gt; float:
    pass

@pure
@C
def acos(a: float) -&gt; float:
    pass

@pure
@C
def asin(a: float) -&gt; float:
    pass

@pure
@C
def atan(a: float) -&gt; float:
    pass

@pure
@C
def atan2(a: float, b: float) -&gt; float:
    pass

@pure
@C
def cos(a: float) -&gt; float:
    pass

@pure
@C
def sin(a: float) -&gt; float:
    pass

@pure
@C
def tan(a: float) -&gt; float:
    pass

@pure
@C
def cosh(a: float) -&gt; float:
    pass

@pure
@C
def sinh(a: float) -&gt; float:
    pass

@pure
@C
def tanh(a: float) -&gt; float:
    pass

@pure
@C
def acosh(a: float) -&gt; float:
    pass

@pure
@C
def asinh(a: float) -&gt; float:
    pass

@pure
@C
def atanh(a: float) -&gt; float:
    pass

@pure
@C
def copysign(a: float, b: float) -&gt; float:
    pass

@pure
@C
def log1p(a: float) -&gt; float:
    pass

@pure
@C
def trunc(a: float) -&gt; float:
    pass

@pure
@C
def log2(a: float) -&gt; float:
    pass

@pure
@C
def erf(a: float) -&gt; float:
    pass

@pure
@C
def erfc(a: float) -&gt; float:
    pass

@pure
@C
def tgamma(a: float) -&gt; float:
    pass

@pure
@C
def lgamma(a: float) -&gt; float:
    pass

@pure
@C
def remainder(a: float, b: float) -&gt; float:
    pass

@pure
@C
def hypot(a: float, b: float) -&gt; float:
    pass

@nocapture
@C
def frexp(a: float, b: Ptr[Int[32]]) -&gt; float:
    pass

@nocapture
@C
def modf(a: float, b: Ptr[float]) -&gt; float:
    pass

@pure
@C
def ceilf(a: float32) -&gt; float32:
    pass

@pure
@C
def floorf(a: float32) -&gt; float32:
    pass

@pure
@C
def fabsf(a: float32) -&gt; float32:
    pass

@pure
@C
def fmodf(a: float32, b: float32) -&gt; float32:
    pass

@pure
@C
def expf(a: float32) -&gt; float32:
    pass

@pure
@C
def expm1f(a: float32) -&gt; float32:
    pass

@pure
@C
def ldexpf(a: float32, b: i32) -&gt; float32:
    pass

@pure
@C
def logf(a: float32) -&gt; float32:
    pass

@pure
@C
def log2f(a: float32) -&gt; float32:
    pass

@pure
@C
def log10f(a: float32) -&gt; float32:
    pass

@pure
@C
def sqrtf(a: float32) -&gt; float32:
    pass

@pure
@C
def powf(a: float32, b: float32) -&gt; float32:
    pass

@pure
@C
def roundf(a: float32) -&gt; float32:
    pass

@pure
@C
def acosf(a: float32) -&gt; float32:
    pass

@pure
@C
def asinf(a: float32) -&gt; float32:
    pass

@pure
@C
def atanf(a: float32) -&gt; float32:
    pass

@pure
@C
def atan2f(a: float32, b: float32) -&gt; float32:
    pass

@pure
@C
def cosf(a: float32) -&gt; float32:
    pass

@pure
@C
def sinf(a: float32) -&gt; float32:
    pass

@pure
@C
def tanf(a: float32) -&gt; float32:
    pass

@pure
@C
def coshf(a: float32) -&gt; float32:
    pass

@pure
@C
def sinhf(a: float32) -&gt; float32:
    pass

@pure
@C
def tanhf(a: float32) -&gt; float32:
    pass

@pure
@C
def acoshf(a: float32) -&gt; float32:
    pass

@pure
@C
def asinhf(a: float32) -&gt; float32:
    pass

@pure
@C
def atanhf(a: float32) -&gt; float32:
    pass

@pure
@C
def copysignf(a: float32, b: float32) -&gt; float32:
    pass

@pure
@C
def log1pf(a: float32) -&gt; float32:
    pass

@pure
@C
def truncf(a: float32) -&gt; float32:
    pass

@pure
@C
def log2f(a: float32) -&gt; float32:
    pass

@pure
@C
def erff(a: float32) -&gt; float32:
    pass

@pure
@C
def erfcf(a: float32) -&gt; float32:
    pass

@pure
@C
def tgammaf(a: float32) -&gt; float32:
    pass

@pure
@C
def lgammaf(a: float32) -&gt; float32:
    pass

@pure
@C
def remainderf(a: float32, b: float32) -&gt; float32:
    pass

@pure
@C
def hypotf(a: float32, b: float32) -&gt; float32:
    pass

@nocapture
@C
def frexpf(a: float32, b: Ptr[Int[32]]) -&gt; float32:
    pass

@nocapture
@C
def modff(a: float32, b: Ptr[float32]) -&gt; float32:
    pass

# &lt;stdio.h&gt;
@pure
@C
def ferror(a: cobj) -&gt; i32:
    pass

@nocapture
@C
def fgetc(a: cobj) -&gt; i32:
    pass

@nocapture
@C
def fopen(a: cobj, b: cobj) -&gt; cobj:
    pass

@nocapture
@C
def fdopen(a: int, b: cobj) -&gt; cobj:
    pass

@nocapture
@C
def fclose(a: cobj) -&gt; int:
    pass

@nocapture
@C
def fread(a: cobj, b: int, c: int, d: cobj) -&gt; int:
    pass

@nocapture
@C
def fwrite(a: cobj, b: int, c: int, d: cobj) -&gt; int:
    pass

@nocapture
@C
def ftell(a: cobj) -&gt; int:
    pass

@nocapture
@C
def fseek(a: cobj, b: int, c: i32) -&gt; i32:
    pass

@nocapture
@C
def fgets(a: cobj, b: int, c: cobj) -&gt; cobj:
    pass

@nocapture
@C
def fflush(a: cobj) -&gt; None:
    pass

@nocapture
@C
def getline(a: Ptr[cobj], b: Ptr[int], c: cobj) -&gt; int:
    pass

# &lt;stdlib.h&gt;
from C import exit(int)

@nocapture
@C
def system(a: cobj) -&gt; int:
    pass

@nocapture
@C
def free(a: cobj) -&gt; None:
    pass

@pure
@C
def atoi(a: cobj) -&gt; int:
    pass

@nocapture
@C
def strtoll(a: cobj, b: Ptr[cobj], c: i32) -&gt; int:
    pass

@nocapture
@C
def strtod(a: cobj, b: Ptr[cobj]) -&gt; float:
    pass

# &lt;zlib.h&gt;
@nocapture
@C
def gzopen(a: cobj, b: cobj) -&gt; cobj:
    pass

@nocapture
@C
def gzerror(a: cobj, b: Ptr[i32]) -&gt; cobj:
    pass

@nocapture
@C
def gzgetc(a: cobj) -&gt; i32:
    pass

@nocapture
@C
def gzgets(a: cobj, b: cobj, c: i32) -&gt; cobj:
    pass

@nocapture
@C
def gzclose(a: cobj) -&gt; int:
    pass

@nocapture
@C
def gzread(a: cobj, b: cobj, c: u32) -&gt; i32:
    pass

@nocapture
@C
def gzwrite(a: cobj, b: cobj, c: u32) -&gt; i32:
    pass

@nocapture
@C
def gztell(a: cobj) -&gt; int:
    pass

@nocapture
@C
def gzseek(a: cobj, b: int, c: i32) -&gt; int:
    pass

@nocapture
@C
def gzflush(a: cobj, b: i32) -&gt; i32:
    pass

# &lt;string.h&gt;
@pure
@C
def memcmp(lhs: Ptr[byte], rhs: Ptr[byte], count: int) -&gt; i32:
    pass

@pure
@C
def memchr(p: Ptr[byte], ch: i32, count: int) -&gt; Ptr[byte]:
    pass
</t>
<t tx="ekr.20230509083243.1262">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@pure
@C
def seq_is_macos() -&gt; bool:
    pass

# &lt;dlfcn.h&gt;
from C import dlerror() -&gt; cobj as c_dlerror
from C import dlopen(cobj, int) -&gt; cobj as c_dlopen
from C import dlsym(cobj, cobj) -&gt; cobj as c_dlsym
from C import dlclose(cobj) -&gt; i32 as c_dlclose

RTLD_NOW = 2
RTLD_GLOBAL = 8 if seq_is_macos() else 256
RTLD_LOCAL = 0 if seq_is_macos() else 256

def dlext() -&gt; str:
    if seq_is_macos():
        return "dylib"
    else:
        return "so"

@pure
def dlerror() -&gt; str:
    return str.from_ptr(c_dlerror())

def dlopen(name: str, flag: int = RTLD_NOW | RTLD_GLOBAL) -&gt; cobj:
    h = c_dlopen(cobj() if name == "" else name.c_str(), flag)
    if h == cobj():
        raise CError(dlerror())
    return h

def dlsym(lib, name: str, Fn: type) -&gt; Fn:
    h = cobj()
    if isinstance(lib, str):
        h = dlopen(lib)
    else:
        h = lib
    fn = c_dlsym(h, name.c_str())
    if fn == cobj():
        raise CError(dlerror())
    return Fn(fn)

def dlclose(handle: cobj):
    if c_dlclose(handle) != i32(0):
        raise CError(dlerror())
</t>
<t tx="ekr.20230509083243.1263">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import realloc, free

class File:
    sz: int
    buf: Ptr[byte]
    fp: cobj

    def __init__(self, fp: cobj):
        self.fp = fp
        self._reset()

    def __init__(self, path: str, mode: str):
        self.fp = _C.fopen(path.c_str(), mode.c_str())
        if not self.fp:
            raise IOError(f"file {path} could not be opened")
        self._reset()

    def _errcheck(self, msg: str):
        err = int(_C.ferror(self.fp))
        if err:
            raise IOError(f"file I/O error: {msg}")

    def __enter__(self):
        pass

    def __exit__(self):
        self.close()

    def __iter__(self) -&gt; Generator[str]:
        for a in self._iter():
            yield a.__ptrcopy__()

    def readlines(self) -&gt; List[str]:
        return [l for l in self]

    def write(self, s: str):
        self._ensure_open()
        _C.fwrite(s.ptr, 1, len(s), self.fp)
        self._errcheck("error in write")

    def __file_write_gen__(self, g: Generator[T], T: type):
        for s in g:
            self.write(str(s))

    def read(self, sz: int = -1) -&gt; str:
        self._ensure_open()
        if sz &lt; 0:
            SEEK_SET = 0
            SEEK_END = 2
            cur = _C.ftell(self.fp)
            _C.fseek(self.fp, 0, i32(SEEK_END))
            sz = _C.ftell(self.fp) - cur
            _C.fseek(self.fp, cur, i32(SEEK_SET))
        buf = Ptr[byte](sz)
        ret = _C.fread(buf, 1, sz, self.fp)
        self._errcheck("error in read")
        return str(buf, ret)

    def tell(self) -&gt; int:
        self._ensure_open()
        ret = _C.ftell(self.fp)
        self._errcheck("error in tell")
        return ret

    def seek(self, offset: int, whence: int):
        self._ensure_open()
        _C.fseek(self.fp, offset, i32(whence))
        self._errcheck("error in seek")

    def flush(self):
        self._ensure_open()
        _C.fflush(self.fp)

    def close(self):
        if self.fp:
            _C.fclose(self.fp)
            self.fp = cobj()
        if self.buf:
            _C.free(self.buf)
            self._reset()

    def _ensure_open(self):
        if not self.fp:
            raise IOError("I/O operation on closed file")

    def _reset(self):
        self.buf = Ptr[byte]()
        self.sz = 0

    def _iter(self) -&gt; Generator[str]:
        self._ensure_open()
        while True:
            rd = _C.getline(
                Ptr[Ptr[byte]](self.__raw__() + 8), Ptr[int](self.__raw__()), self.fp
            )
            if rd != -1:
                yield str(self.buf, rd)
            else:
                break

    def _iter_trim_newline(self) -&gt; Generator[str]:
        self._ensure_open()
        while True:
            rd = _C.getline(
                Ptr[Ptr[byte]](self.__raw__() + 8), Ptr[int](self.__raw__()), self.fp
            )
            if rd != -1:
                if self.buf[rd - 1] == byte(10):
                    rd -= 1
                yield str(self.buf, rd)
            else:
                break

def _gz_errcheck(stream: cobj):
    errnum = i32(0)
    msg = _C.gzerror(stream, __ptr__(errnum))
    if msg and msg[0]:
        raise IOError(f"zlib error: {str(msg, _C.strlen(msg))}")

class gzFile:
    sz: int
    buf: Ptr[byte]
    fp: cobj

    def __init__(self, fp: cobj):
        self.fp = fp
        self._reset()

    def __init__(self, path: str, mode: str):
        self.fp = _C.gzopen(path.c_str(), mode.c_str())
        if not self.fp:
            raise IOError(f"file {path} could not be opened")
        self._reset()

    def _getline(self) -&gt; int:
        if not self.buf:
            self.sz = 128
            self.buf = Ptr[byte](self.sz)

        offset = 0
        while True:
            if not _C.gzgets(self.fp, self.buf + offset, i32(self.sz - offset)):
                _gz_errcheck(self.fp)
                if offset == 0:
                    return -1
                break

            offset += _C.strlen(self.buf + offset)

            if self.buf[offset - 1] == byte(10):  # '\n'
                break

            oldsz = self.sz
            self.sz *= 2
            self.buf = realloc(self.buf, self.sz, oldsz)

        return offset

    def __iter__(self) -&gt; Generator[str]:
        for a in self._iter():
            yield a.__ptrcopy__()

    def __enter__(self):
        pass

    def __exit__(self):
        self.close()

    def close(self):
        if self.fp:
            _C.gzclose(self.fp)
            self.fp = cobj()
        if self.buf:
            free(self.buf)
            self._reset()

    def readlines(self) -&gt; List[str]:
        return [l for l in self]

    def write(self, s: str):
        self._ensure_open()
        _C.gzwrite(self.fp, s.ptr, u32(len(s)))
        _gz_errcheck(self.fp)

    def __file_write_gen__(self, g: Generator[T], T: type):
        for s in g:
            self.write(str(s))

    def read(self, sz: int = -1) -&gt; str:
        self._ensure_open()
        if sz &lt; 0:
            buf = _strbuf()
            for a in self._iter():
                buf.append(a)
            return buf.__str__()
        buf = Ptr[byte](sz)
        ret = _C.gzread(self.fp, buf, u32(sz))
        _gz_errcheck(self.fp)
        return str(buf, int(ret))

    def tell(self) -&gt; int:
        self._ensure_open()
        ret = _C.gztell(self.fp)
        _gz_errcheck(self.fp)
        return ret

    def seek(self, offset: int, whence: int):
        self._ensure_open()
        _C.gzseek(self.fp, offset, i32(whence))
        _gz_errcheck(self.fp)

    def flush(self):
        Z_FINISH = 4
        self._ensure_open()
        _C.gzflush(self.fp, i32(Z_FINISH))
        _gz_errcheck(self.fp)

    def _iter(self) -&gt; Generator[str]:
        self._ensure_open()
        while True:
            rd = self._getline()
            if rd != -1:
                yield str(self.buf, rd)
            else:
                break

    def _iter_trim_newline(self) -&gt; Generator[str]:
        self._ensure_open()
        while True:
            rd = self._getline()
            if rd != -1:
                if self.buf[rd - 1] == byte(10):
                    rd -= 1
                yield str(self.buf, rd)
            else:
                break

    def _ensure_open(self):
        if not self.fp:
            raise IOError("I/O operation on closed file")

    def _reset(self):
        self.buf = cobj()
        self.sz = 0

def open(path: str, mode: str = "r") -&gt; File:
    return File(path, mode)

def gzopen(path: str, mode: str = "r") -&gt; gzFile:
    return gzFile(path, mode)

def is_binary(path: str) -&gt; bool:
    # https://stackoverflow.com/questions/898669/how-can-i-detect-if-a-file-is-binary-non-text-in-python/7392391#7392391
    # Can get both false positive and false negatives, but still is a
    # clever approach that works for the large majority of files
    textchars = {7, 8, 9, 10, 12, 13, 27} | set(iter(range(0x20, 0x100))) - {0x7F}
    with open(path, "rb") as f:
        header = f.read(1024)
        return any(ord(c) not in textchars for c in header)
</t>
<t tx="ekr.20230509083243.1264">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def _format_error(ret: str):
	raise ValueError(f"invalid format specifier: {ret}")

@extend
class int:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_int(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

@extend
class Int:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_int(self.__int__(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

@extend
class UInt:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_uint(self.__int__(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

@extend
class float:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_float(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret if ret != "-nan" else "nan"

@extend
class str:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_str(self, format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

@extend
class Ptr:
    def __format__(self, format_spec: str) -&gt; str:
        err = False
        ret = _C.seq_str_ptr(self.as_byte(), format_spec, __ptr__(err))
        if format_spec and err:
            _format_error(ret)
        return ret

def _divmod_10(dividend, N: Static[int]):
    T = type(dividend)
    zero, one = T(0), T(1)
    neg = dividend &lt; zero
    dvd = dividend.__abs__()

    remainder = 0
    quotient = zero

    # Euclidean division
    for bit_idx in range(N - 1, -1, -1):
        mask = int((dvd &amp; (one &lt;&lt; T(bit_idx))) != zero)
        remainder = (remainder &lt;&lt; 1) + mask
        if remainder &gt;= 10:
            quotient = (quotient &lt;&lt; one) + one
            remainder -= 10
        else:
            quotient = quotient &lt;&lt; one

    if neg:
        quotient = -quotient
        remainder = -remainder

    return quotient, remainder

@extend
class Int:
    def __str__(self) -&gt; str:
        if N &lt;= 64:
            return str(int(self))

        if not self:
            return '0'

        s = _strbuf()
        d = self

        if d &gt;= Int[N](0):
            while True:
                d, m = _divmod_10(d, N)
                b = byte(48 + m)  # 48 == ord('0')
                s.append(str(__ptr__(b), 1))
                if not d:
                    break
        else:
            while True:
                d, m = _divmod_10(d, N)
                b = byte(48 - m)  # 48 == ord('0')
                s.append(str(__ptr__(b), 1))

                if not d:
                    break
            s.append('-')

        s.reverse()
        return s.__str__()

@extend
class UInt:
    def __str__(self) -&gt; str:
        if N &lt;= 64:
            return self.__format__("")

        s = _strbuf()
        d = self

        while True:
            d, m = _divmod_10(d, N)
            b = byte(48 + int(m))  # 48 == ord('0')
            s.append(str(__ptr__(b), 1))
            if not d:
                break

        s.reverse()
        return s.__str__()
</t>
<t tx="ekr.20230509083243.1265">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# Primarily for internal use. Regular users should not use this module.

@pure
@C
def seq_alloc(a: int) -&gt; cobj:
    pass

@pure
@C
def seq_alloc_atomic(a: int) -&gt; cobj:
    pass

@pure
@C
def seq_alloc_uncollectable(a: int) -&gt; cobj:
    pass

@pure
@C
def seq_alloc_atomic_uncollectable(a: int) -&gt; cobj:
    pass

@nocapture
@derives
@C
def seq_realloc(p: cobj, newsize: int, oldsize: int) -&gt; cobj:
    pass

@nocapture
@C
def seq_free(p: cobj) -&gt; None:
    pass

@nocapture
@C
def seq_register_finalizer(p: cobj, f: cobj) -&gt; None:
    pass

@nocapture
@C
def seq_gc_add_roots(p: cobj, q: cobj) -&gt; None:
    pass

@nocapture
@C
def seq_gc_remove_roots(p: cobj, q: cobj) -&gt; None:
    pass

@C
def seq_gc_clear_roots() -&gt; None:
    pass

@nocapture
@C
def seq_gc_exclude_static_roots(p: cobj, q: cobj) -&gt; None:
    pass

def sizeof(T: type):
    return T.__elemsize__

def atomic(T: type):
    return T.__atomic__

def alloc(sz: int):
    return seq_alloc(sz)

# Allocates a block of memory via GC, where the
# caller guarantees that this block will not store
# pointers to other GC-allocated data.
def alloc_atomic(sz: int):
    return seq_alloc_atomic(sz)

# Allocates a block of memory via GC that is scanned,
# but not collected itself. Should be free'd explicitly.
def alloc_uncollectable(sz: int):
    return seq_alloc_uncollectable(sz)

# Allocates a block of memory via GC that is scanned,
# but not collected itself. Should be free'd explicitly.
def alloc_atomic_uncollectable(sz: int):
    return seq_alloc_atomic_uncollectable(sz)

def realloc(p: cobj, newsz: int, oldsz: int):
    return seq_realloc(p, newsz, oldsz)

def free(p: cobj):
    seq_free(p)

def add_roots(start: cobj, end: cobj):
    seq_gc_add_roots(start, end)

def remove_roots(start: cobj, end: cobj):
    seq_gc_remove_roots(start, end)

def clear_roots():
    seq_gc_clear_roots()

def exclude_static_roots(start: cobj, end: cobj):
    seq_gc_exclude_static_roots(start, end)

def register_finalizer(p):
    if hasattr(p, "__del__"):

        def f(x: cobj, data: cobj, T: type):
            Ptr[T](__ptr__(x).as_byte())[0].__del__()

        seq_register_finalizer(p.__raw__(), f(T=type(p), ...).__raw__())

def construct_ref[T](args) -&gt; T:
    p = T.__new__()
    p.__init__(*args)
    return p
</t>
<t tx="ekr.20230509083243.1266">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import (
    alloc, alloc_atomic, alloc_uncollectable, alloc_atomic_uncollectable,
    free, atomic, sizeof, register_finalizer
)

__vtable_size__ = 0

@extend
class __internal__:
    def yield_final(val):
        pass
    def yield_in_no_suspend(T: type) -&gt; T:
        pass

    @pure
    @derives
    @llvm
    def class_raw(obj) -&gt; Ptr[byte]:
        ret ptr %obj

    def class_alloc(T: type) -&gt; T:
        """Allocates a new reference (class) type"""
        sz = sizeof(tuple(T))
        p = alloc_atomic(sz) if T.__contents_atomic__ else alloc(sz)
        register_finalizer(p)
        return __internal__.to_class_ptr(p, T)

    def class_new(T: type) -&gt; T:
        """Create a new reference (class) type"""
        pf = __internal__.class_alloc(T)
        __internal__.class_set_obj_vtable(pf)
        return pf

    def class_ctr(T: type, *args, **kwargs) -&gt; T:
        """Shorthand for `t = T.__new__(); t.__init__(*args, **kwargs); t`"""
        return T(*args, **kwargs)

    def class_set_obj_vtable(pf: T, T: type) -&gt; None:
        """
        Initialize a vtable of a T() object. Compiler generated.
        Corresponds to:
            pf.__vtable__ = __vtables__[pf.__vtable_id___]
        """
        pass

    def class_init_vtables() -&gt; Ptr[Ptr[cobj]]:
        """
        Create a global vtable. Compiler generated.
        Corresponds to:
            return __internal__.class_make_n_vtables(&lt;number of class realizations&gt;)
        """
        pass

    def class_make_n_vtables(sz: int) -&gt; Ptr[Ptr[cobj]]:
        """Create a global vtable."""
        p = Ptr[Ptr[cobj]](alloc_atomic_uncollectable(sz * sizeof(Ptr[cobj])))
        __internal__.class_populate_vtables(p)
        return p

    def class_populate_vtables(p: Ptr[Ptr[cobj]]) -&gt; None:
        """
        Populate content of vtables. Compiler generated.
        Corresponds to:
            for each realized class C:
                p.__setitem__(&lt;C's realization ID&gt;, Ptr[cobj](&lt;C's vtable size&gt; + 1))
                __internal__.class_set_typeinfo(p[&lt;C's realization ID&gt;], &lt;C's realization ID&gt;)
                for each fn F in C's vtable:
                    p[&lt;C's realization ID&gt;].__setitem__(&lt;F's vtable ID&gt;, Function(&lt;instantiated F&gt;).__raw__())
        """
        pass

    def class_set_typeinfo(p: Ptr[cobj], typeinfo: T, T: type) -&gt; None:
        i = Ptr[T](1)
        i[0] = typeinfo
        p[0] = i.as_byte()

    def class_get_typeinfo(p) -&gt; int:
        c = Ptr[Ptr[cobj]](p.__raw__())
        vt = c[0]
        return Ptr[int](vt[0])[0]

    @inline
    def class_base_derived_dist(B: type, D: type) -&gt; int:
        """Calculates the byte distance of base class B and derived class D. Compiler generated."""
        return 0

    def class_copy(obj: T, T: type) -&gt; T:
        p = __internal__.class_alloc(T)
        str.memcpy(p.__raw__(), obj.__raw__(), sizeof(tuple(T)))
        return p

    def class_super(obj: D, B: type, D: type) -&gt; B:
        pf = __internal__.to_class_ptr(obj.__raw__() + __internal__.class_base_derived_dist(B, D), B)
        pn = __internal__.class_copy(pf)
        # Replace vtables
        __internal__.class_set_obj_vtable(pn)  # replace vtables to point to its vtables!
        return pn

    # Unions

    @llvm
    def union_set_tag(tag: byte, U: type) -&gt; U:
        %0 = insertvalue {=U} undef, i8 %tag, 0
        ret {=U} %0

    @llvm
    def union_get_data_ptr(ptr: Ptr[U], U: type, T: type) -&gt; Ptr[T]:
        %0 = getelementptr inbounds {=U}, ptr %ptr, i64 0, i32 1
        ret ptr %0

    @llvm
    def union_get_tag(u: U, U: type) -&gt; byte:
        %0 = extractvalue {=U} %u, 0
        ret i8 %0

    def union_get_data(u, T: type) -&gt; T:
        return __internal__.union_get_data_ptr(__ptr__(u), T=T)[0]

    def union_make(tag: int, value, U: type) -&gt; U:
        u = __internal__.union_set_tag(byte(tag), U)
        __internal__.union_get_data_ptr(__ptr__(u), T=type(value))[0] = value
        return u

    def new_union(value, U: type) -&gt; U:
        pass

    def get_union(union, T: type) -&gt; T:
        pass

    def get_union_first(union):
        pass

    def _get_union_method(union, method: Static[str], *args, **kwargs):
        pass

    def get_union_method(union, method: Static[str], *args, **kwargs):
        t = __internal__._get_union_method(union, method, *args, **kwargs)
        if staticlen(t) == 1:
            return __internal__.get_union_first(t)
        return t

    # Tuples

    @pure
    @derives
    @llvm
    def _tuple_getitem_llvm(t: T, idx: int, T: type, E: type) -&gt; E:
        %x = alloca {=T}
        store {=T} %t, ptr %x
        %p = getelementptr {=E}, ptr %x, i64 %idx
        %v = load {=E}, ptr %p
        ret {=E} %v

    def tuple_fix_index(idx: int, len: int) -&gt; int:
        if idx &lt; 0:
            idx += len
        if idx &lt; 0 or idx &gt;= len:
            raise IndexError(f"tuple index {idx} out of range 0..{len}")
        return idx

    def tuple_getitem(t: T, idx: int, T: type, E: type) -&gt; E:
        return __internal__._tuple_getitem_llvm(
            t, __internal__.tuple_fix_index(idx, staticlen(t)), T, E
        )

    def tuple_add(t, i):
        if isinstance(i, Tuple):
            return (*t, *i)
        else:
            compile_error("can only concatenate tuple to tuple")

    def tuple_mul(t, i: Static[int]):
        if i &lt; 1:
            return ()
        elif i == 1:
            return t
        else:
            return (*(__internal__.tuple_mul(t, i - 1)), *t)

    # ...

    @pure
    @derives
    @llvm
    def fn_new(p: Ptr[byte], T: type) -&gt; T:
        ret ptr %p

    @pure
    @derives
    @llvm
    def fn_raw(fn: T, T: type) -&gt; Ptr[byte]:
        ret ptr %fn

    @pure
    @llvm
    def int_sext(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
        %0 = sext i{=F} %what to i{=T}
        ret i{=T} %0

    @pure
    @llvm
    def int_zext(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
        %0 = zext i{=F} %what to i{=T}
        ret i{=T} %0

    @pure
    @llvm
    def int_trunc(what, F: Static[int], T: Static[int]) -&gt; Int[T]:
        %0 = trunc i{=F} %what to i{=T}
        ret i{=T} %0

    def seq_assert(file: str, line: int, msg: str) -&gt; AssertionError:
        s = f": {msg}" if msg else ""
        s = f"Assert failed{s} ({file}:{line.__repr__()})"
        return AssertionError(s)

    def seq_assert_test(file: str, line: int, msg: str):
        from C import seq_print(str)
        s = f": {msg}" if msg else ""
        s = f"\033[1;31mTEST FAILED:\033[0m {file} (line {line}){s}\n"
        seq_print(s)

    def check_errno(prefix: str):
        @pure
        @C
        def seq_check_errno() -&gt; str:
            pass

        msg = seq_check_errno()
        if msg:
            raise OSError(prefix + msg)

    @pure
    @llvm
    def opt_tuple_new(T: type) -&gt; Optional[T]:
        ret { i1, {=T} } { i1 false, {=T} undef }

    @pure
    @llvm
    def opt_ref_new(T: type) -&gt; Optional[T]:
        ret ptr null

    @pure
    @derives
    @llvm
    def opt_tuple_new_arg(what: T, T: type) -&gt; Optional[T]:
        %0 = insertvalue { i1, {=T} } { i1 true, {=T} undef }, {=T} %what, 1
        ret { i1, {=T} } %0

    @pure
    @derives
    @llvm
    def opt_ref_new_arg(what: T, T: type) -&gt; Optional[T]:
        ret ptr %what

    @pure
    @llvm
    def opt_tuple_bool(what: Optional[T], T: type) -&gt; bool:
        %0 = extractvalue { i1, {=T} } %what, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def opt_ref_bool(what: Optional[T], T: type) -&gt; bool:
        %0 = icmp ne ptr %what, null
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @derives
    @llvm
    def opt_tuple_invert(what: Optional[T], T: type) -&gt; T:
        %0 = extractvalue { i1, {=T} } %what, 1
        ret {=T} %0

    @pure
    @derives
    @llvm
    def opt_ref_invert(what: Optional[T], T: type) -&gt; T:
        ret ptr %what

    @pure
    @derives
    @llvm
    def to_class_ptr(p: Ptr[byte], T: type) -&gt; T:
        ret ptr %p

    def _tuple_offsetof(x, field: Static[int]) -&gt; int:
        @pure
        @llvm
        def _llvm_offsetof(T: type, idx: Static[int], TE: type) -&gt; int:
            %a = alloca {=T}
            %b = getelementptr inbounds {=T}, ptr %a, i64 0, i32 {=idx}
            %base = ptrtoint ptr %a to i64
            %elem = ptrtoint ptr %b to i64
            %offset = sub i64 %elem, %base
            ret i64 %offset

        return _llvm_offsetof(type(x), field, type(x[field]))

    def raw_type_str(p: Ptr[byte], name: str) -&gt; str:
        pstr = p.__repr__()
        # '&lt;[name] at [pstr]&gt;'
        total = 1 + name.len + 4 + pstr.len + 1
        buf = Ptr[byte](total)
        where = 0
        buf[where] = byte(60)  # '&lt;'
        where += 1
        str.memcpy(buf + where, name.ptr, name.len)
        where += name.len
        buf[where] = byte(32)  # ' '
        where += 1
        buf[where] = byte(97)  # 'a'
        where += 1
        buf[where] = byte(116)  # 't'
        where += 1
        buf[where] = byte(32)  # ' '
        where += 1
        str.memcpy(buf + where, pstr.ptr, pstr.len)
        where += pstr.len
        buf[where] = byte(62)  # '&gt;'
        free(pstr.ptr)
        return str(buf, total)

    def tuple_str(strs: Ptr[str], names: Ptr[str], n: int) -&gt; str:
        total = 2  # one for each of '(' and ')'
        i = 0
        while i &lt; n:
            total += strs[i].len
            if names[i].len:
                total += names[i].len + 2  # extra : and space
            if i &lt; n - 1:
                total += 2  # ", "
            i += 1
        buf = Ptr[byte](total)
        where = 0
        buf[where] = byte(40)  # '('
        where += 1
        i = 0
        while i &lt; n:
            s = names[i]
            l = s.len
            if l:
                str.memcpy(buf + where, s.ptr, l)
                where += l
                buf[where] = byte(58)  # ':'
                where += 1
                buf[where] = byte(32)  # ' '
                where += 1
            s = strs[i]
            l = s.len
            str.memcpy(buf + where, s.ptr, l)
            where += l
            if i &lt; n - 1:
                buf[where] = byte(44)  # ','
                where += 1
                buf[where] = byte(32)  # ' '
                where += 1
            i += 1
        buf[where] = byte(41)  # ')'
        return str(buf, total)

    def undef(v, s):
        if not v:
            raise NameError(f"variable '{s}' not yet defined")

    @__hidden__
    def set_header(e, func, file, line, col):
        if not isinstance(e, BaseException):
            compile_error("exceptions must derive from BaseException")

        e.func = func
        e.file = file
        e.line = line
        e.col = col
        return e

    # TODO: keep this commented until static for lands
    # @pure
    # @llvm
    # def __raw__(self) -&gt; Ptr[byte]:
    #     ret i8* %self
    # def __iter__(self):
    #     for _, i in self.__static_list__:
    #         yield i
    # def __contains__(self, what):
    #     for _, i in self.__static_list__:
    #         if isinstance(what, type(i)):
    #             if what == i:
    #                 return True
    #     return False
    # def __eq__(self, obj) -&gt; bool:
    #     for ii, i in self.__static_list__:
    #         if not i == obj.__static_list__[ii]:
    #             return False
    #     return True
    # def __ne__(self, obj) -&gt; bool:
    #     return not self == obj
    # def __lt__(self, obj) -&gt; bool:
    #     for ii, i in self.__static_list__:
    #         if i &lt; obj.__static_list__[ii]:
    #             return True
    #         elif not i == obj.__static_list__[ii]:
    #             return False
    #     return False
    # def __le__(self, obj) -&gt; bool:
    #     return self &lt; obj or self == obj
    # def __ge__(self, obj) -&gt; bool:
    #     return not self &lt; obj
    # def __gt__(self, obj) -&gt; bool:
    #     return not self &lt; obj and not self == obj
    # def __hash__(self) -&gt; int:
    #     seed = 0
    #     for _, i in self.__static_list__:
    #         seed = seed ^ ((i.__hash__() + 2654435769) + ((seed &lt;&lt; 6) + (seed &gt;&gt; 2)))
    #     return seed
    # def __pickle__(self, dest: Ptr[byte]) -&gt; None:
    #     for _, i in self.__static_list__:
    #         i.__pickle__(dest)
    # # __unpickle
    # def __len__(self):
    #     return staticlen(self)
    # def __to_py__(self) -&gt; cobj:
    #     o = pyobj._tuple_new(staticlen(self))
    #     for ii, i in self.__static_list__:
    #         pyobj._tuple_set(o, ii + 1, i.__to_py__())
    #     return o
    # # __from_py__
    # def __repr__(self) -&gt; str:
    #     a = __array__[str](staticlen(self))
    #     n = __array__[str](staticlen(self))
    #     for ii, i in self.__static_list__:
    #         a.__setitem__(ii, i.__repr__())
    #         n.__setitem__(ii, i.__static_name__)
    #     return __internal__.tuple_str(a.ptr, n.ptr, staticlen(self))
    # def __dict__(self) -&gt; str:
    #     d = List[str](staticlen(self))
    #     for _, i in self.__static_list__:
    #         d.append(i.__static_name)
    #     return d
    # def __add__(self, obj):
    #     return (*self, *obj)

@dataclass(init=True)
@tuple
class Import:
    name: str
    file: str

    def __repr__(self) -&gt; str:
        return f"&lt;module '{self.name}' from '{self.file}'&gt;"

@extend
class Function:
    @pure
    @llvm
    def __new__(what: Ptr[byte]) -&gt; Function[T, TR]:
        ret ptr %what

    def __new__(what: Function[T, TR]) -&gt; Function[T, TR]:
       return what

    @pure
    @llvm
    def __raw__(self) -&gt; Ptr[byte]:
        ret ptr %self

    def __repr__(self) -&gt; str:
       return __internal__.raw_type_str(self.__raw__(), "function")

    @llvm
    def __call_internal__(self: Function[T, TR], args: T) -&gt; TR:
        noop  # compiler will populate this one

    def __call__(self, *args) -&gt; TR:
        return Function.__call_internal__(self, args)

__vtables__ = __internal__.class_init_vtables()
def _____(): __vtables__  # make it global!


@tuple
class PyObject:
    refcnt: int
    pytype: Ptr[byte]


@tuple
class PyWrapper[T]:
    head: PyObject
    data: T
</t>
<t tx="ekr.20230509083243.1267">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def __ac_isempty(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 2

def __ac_isdel(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 1

def __ac_iseither(flag: Ptr[u32], i: int) -&gt; int:
    return int(flag[i &gt;&gt; 4] &gt;&gt; u32((i &amp; 0xF) &lt;&lt; 1)) &amp; 3

def __ac_set_isdel_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(1 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

def __ac_set_isempty_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(2 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

def __ac_set_isboth_false(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] &amp;= u32(~(3 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1)))

def __ac_set_isdel_true(flag: Ptr[u32], i: int):
    flag[i &gt;&gt; 4] |= u32(1 &lt;&lt; ((i &amp; 0xF) &lt;&lt; 1))

def __ac_fsize(m) -&gt; int:
    return 1 if m &lt; 16 else m &gt;&gt; 4
</t>
<t tx="ekr.20230509083243.1268">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@pure
@llvm
def _floordiv_int_float(self: int, other: float) -&gt; float:
    declare double @llvm.floor.f64(double)
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    %2 = call double @llvm.floor.f64(double %1)
    ret double %2

@pure
@llvm
def _floordiv_int_int(self: int, other: int) -&gt; int:
    %0 = sdiv i64 %self, %other
    ret i64 %0

@pure
@llvm
def _truediv_int_float(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = fdiv double %0, %other
    ret double %1

@pure
@llvm
def _truediv_int_int(self: int, other: int) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = sitofp i64 %other to double
    %2 = fdiv double %0, %1
    ret double %2

@pure
@llvm
def _mod_int_float(self: int, other: float) -&gt; float:
    %0 = sitofp i64 %self to double
    %1 = frem double %0, %other
    ret double %1

@pure
@llvm
def _mod_int_int(self: int, other: int) -&gt; int:
    %0 = srem i64 %self, %other
    ret i64 %0

@pure
@llvm
def _truediv_float_float(self: float, other: float) -&gt; float:
    %0 = fdiv double %self, %other
    ret double %0

@pure
@llvm
def _mod_float_float(self: float, other: float) -&gt; float:
    %0 = frem double %self, %other
    ret double %0

def _divmod_int_int(self: int, other: int):
    d = _floordiv_int_int(self, other)
    m = self - d * other
    if m and ((other ^ m) &lt; 0):
        m += other
        d -= 1
    return (d, m)

def _divmod_float_float(self: float, other: float):
    mod = _mod_float_float(self, other)
    div = _truediv_float_float(self - mod, other)
    if mod:
        if (other &lt; 0) != (mod &lt; 0):
            mod += other
            div -= 1.0
    else:
        mod = (0.0).copysign(other)

    floordiv = 0.0
    if div:
        floordiv = div.__floor__()
        if div - floordiv &gt; 0.5:
            floordiv += 1.0
    else:
        floordiv = (0.0).copysign(self / other)

    return (floordiv, mod)

@extend
class int:
    def __floordiv__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float floor division by zero")
        return _divmod_float_float(float(self), other)[0]

    def __floordiv__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("integer division or modulo by zero")
        return _divmod_int_int(self, other)[0]

    def __truediv__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float division by zero")
        return _truediv_int_float(self, other)

    def __truediv__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("division by zero")
        return _truediv_int_int(self, other)

    def __mod__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float modulo")
        return _divmod_float_float(self, other)[1]

    def __mod__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("integer division or modulo by zero")
        return _divmod_int_int(self, other)[1]

    def __divmod__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float divmod()")
        return _divmod_float_float(float(self), other)

    def __divmod__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("integer division or modulo by zero")
        return _divmod_int_int(self, other)

@extend
class float:
    def __floordiv__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float floor division by zero")
        return _divmod_float_float(self, other)[0]

    def __floordiv__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("float floor division by zero")
        return _divmod_float_float(self, float(other))[0]

    def __truediv__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float division by zero")
        return _truediv_float_float(self, other)

    def __truediv__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("float division by zero")
        return _truediv_float_float(self, float(other))

    def __mod__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float modulo")
        return _divmod_float_float(self, other)[1]

    def __mod__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("float modulo")
        return _divmod_float_float(self, float(other))[1]

    def __divmod__(self, other: float):
        if other == 0.0:
            raise ZeroDivisionError("float divmod()")
        return _divmod_float_float(self, other)

    def __divmod__(self, other: int):
        if other == 0:
            raise ZeroDivisionError("float divmod()")
        return _divmod_float_float(self, float(other))
</t>
<t tx="ekr.20230509083243.1269">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import os

from internal.dlopen import *

# general
Py_DecRef = Function[[cobj], NoneType](cobj())
Py_IncRef = Function[[cobj], NoneType](cobj())
Py_Initialize = Function[[], NoneType](cobj())
PyImport_AddModule = Function[[cobj], cobj](cobj())
PyImport_AddModuleObject = Function[[cobj], cobj](cobj())
PyImport_ImportModule = Function[[cobj], cobj](cobj())
PyRun_SimpleString = Function[[cobj], NoneType](cobj())
PyEval_GetGlobals = Function[[], cobj](cobj())
PyEval_GetBuiltins = Function[[], cobj](cobj())

# conversions
PyLong_AsLong = Function[[cobj], int](cobj())
PyLong_FromLong = Function[[int], cobj](cobj())
PyFloat_AsDouble = Function[[cobj], float](cobj())
PyFloat_FromDouble = Function[[float], cobj](cobj())
PyBool_FromLong = Function[[int], cobj](cobj())
PyBytes_AsString = Function[[cobj], cobj](cobj())
PyList_New = Function[[int], cobj](cobj())
PyList_Size = Function[[cobj], int](cobj())
PyList_GetItem = Function[[cobj, int], cobj](cobj())
PyList_SetItem = Function[[cobj, int, cobj], cobj](cobj())
PyDict_New = Function[[], cobj](cobj())
PyDict_Next = Function[[cobj, Ptr[int], Ptr[cobj], Ptr[cobj]], int](cobj())
PyDict_GetItem = Function[[cobj, cobj], cobj](cobj())
PyDict_GetItemString = Function[[cobj, cobj], cobj](cobj())
PyDict_SetItem = Function[[cobj, cobj, cobj], cobj](cobj())
PyDict_Size = Function[[cobj], int](cobj())
PySet_Add = Function[[cobj, cobj], cobj](cobj())
PySet_New = Function[[cobj], cobj](cobj())
PyTuple_New = Function[[int], cobj](cobj())
PyTuple_Size = Function[[cobj], int](cobj())
PyTuple_GetItem = Function[[cobj, int], cobj](cobj())
PyTuple_SetItem = Function[[cobj, int, cobj], NoneType](cobj())
PyUnicode_AsEncodedString = Function[[cobj, cobj, cobj], cobj](cobj())
PyUnicode_DecodeFSDefaultAndSize = Function[[cobj, int], cobj](cobj())
PyUnicode_FromString = Function[[cobj], cobj](cobj())
PyComplex_FromDoubles = Function[[float, float], cobj](cobj())
PyComplex_RealAsDouble = Function[[cobj], float](cobj())
PyComplex_ImagAsDouble = Function[[cobj], float](cobj())
PyIter_Next = Function[[cobj], cobj](cobj())
PySlice_New = Function[[cobj, cobj, cobj], cobj](cobj())
PySlice_Unpack = Function[[cobj, Ptr[int], Ptr[int], Ptr[int]], int](cobj())

# number
PyNumber_Add = Function[[cobj, cobj], cobj](cobj())
PyNumber_Subtract = Function[[cobj, cobj], cobj](cobj())
PyNumber_Multiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_MatrixMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_FloorDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_TrueDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_Remainder = Function[[cobj, cobj], cobj](cobj())
PyNumber_Divmod = Function[[cobj, cobj], cobj](cobj())
PyNumber_Power = Function[[cobj, cobj, cobj], cobj](cobj())
PyNumber_Negative = Function[[cobj], cobj](cobj())
PyNumber_Positive = Function[[cobj], cobj](cobj())
PyNumber_Absolute = Function[[cobj], cobj](cobj())
PyNumber_Invert = Function[[cobj], cobj](cobj())
PyNumber_Lshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_Rshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_And = Function[[cobj, cobj], cobj](cobj())
PyNumber_Xor = Function[[cobj, cobj], cobj](cobj())
PyNumber_Or = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceAdd = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceSubtract = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceMatrixMultiply = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceFloorDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceTrueDivide = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceRemainder = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlacePower = Function[[cobj, cobj, cobj], cobj](cobj())
PyNumber_InPlaceLshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceRshift = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceAnd = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceXor = Function[[cobj, cobj], cobj](cobj())
PyNumber_InPlaceOr = Function[[cobj, cobj], cobj](cobj())
PyNumber_Long = Function[[cobj], cobj](cobj())
PyNumber_Float = Function[[cobj], cobj](cobj())
PyNumber_Index = Function[[cobj], cobj](cobj())

# object
PyObject_Call = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_GetAttr = Function[[cobj, cobj], cobj](cobj())
PyObject_GetAttrString = Function[[cobj, cobj], cobj](cobj())
PyObject_GetIter = Function[[cobj], cobj](cobj())
PyObject_HasAttrString = Function[[cobj, cobj], int](cobj())
PyObject_IsTrue = Function[[cobj], int](cobj())
PyObject_Length = Function[[cobj], int](cobj())
PyObject_LengthHint = Function[[cobj, int], int](cobj())
PyObject_SetAttrString = Function[[cobj, cobj, cobj], cobj](cobj())
PyObject_Str = Function[[cobj], cobj](cobj())
PyObject_Repr = Function[[cobj], cobj](cobj())
PyObject_Hash = Function[[cobj], int](cobj())
PyObject_GetItem = Function[[cobj, cobj], cobj](cobj())
PyObject_SetItem = Function[[cobj, cobj, cobj], int](cobj())
PyObject_DelItem = Function[[cobj, cobj], int](cobj())
PyObject_RichCompare = Function[[cobj, cobj, i32], cobj](cobj())
PyObject_IsInstance = Function[[cobj, cobj], i32](cobj())

# error handling
PyErr_Fetch = Function[[Ptr[cobj], Ptr[cobj], Ptr[cobj]], NoneType](cobj())
PyErr_NormalizeException = Function[[Ptr[cobj], Ptr[cobj], Ptr[cobj]], NoneType](cobj())
PyErr_SetString = Function[[cobj, cobj], NoneType](cobj())

# constants
Py_None = cobj()
Py_True = cobj()
Py_False = cobj()
Py_Ellipsis = cobj()
Py_NotImplemented = cobj()
Py_LT = 0
Py_LE = 1
Py_EQ = 2
Py_NE = 3
Py_GT = 4
Py_GE = 5

# types
PyLong_Type = cobj()
PyFloat_Type = cobj()
PyBool_Type = cobj()
PyUnicode_Type = cobj()
PyComplex_Type = cobj()
PyList_Type = cobj()
PyDict_Type = cobj()
PySet_Type = cobj()
PyTuple_Type = cobj()
PySlice_Type = cobj()

# exceptions
PyExc_BaseException = cobj()
PyExc_Exception = cobj()
PyExc_NameError = cobj()
PyExc_OSError = cobj()
PyExc_IOError = cobj()
PyExc_ValueError = cobj()
PyExc_LookupError = cobj()
PyExc_IndexError = cobj()
PyExc_KeyError = cobj()
PyExc_TypeError = cobj()
PyExc_ArithmeticError = cobj()
PyExc_ZeroDivisionError = cobj()
PyExc_OverflowError = cobj()
PyExc_AttributeError = cobj()
PyExc_RuntimeError = cobj()
PyExc_NotImplementedError = cobj()
PyExc_StopIteration = cobj()
PyExc_AssertionError = cobj()
PyExc_SystemExit = cobj()

_PY_MODULE_CACHE = Dict[str, pyobj]()

_PY_INIT = """
import io

clsf = None
clsa = None
plt = None
try:
    import matplotlib.figure
    import matplotlib.pyplot
    plt = matplotlib.pyplot
    clsf = matplotlib.figure.Figure
    clsa = matplotlib.artist.Artist
except ModuleNotFoundError:
    pass

def __codon_repr__(fig):
    if clsf and isinstance(fig, clsf):
        stream = io.StringIO()
        fig.savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif clsa and isinstance(fig, list) and all(
        isinstance(i, clsa) for i in fig
    ):
        stream = io.StringIO()
        plt.gcf().savefig(stream, format="svg")
        return 'image/svg+xml', stream.getvalue()
    elif hasattr(fig, "_repr_html_"):
        return 'text/html', fig._repr_html_()
    else:
        return 'text/plain', fig.__repr__()
"""

_PY_INITIALIZED = False

def init_handles_dlopen(py_handle: cobj):
    global Py_DecRef
    global Py_IncRef
    global Py_Initialize
    global PyImport_AddModule
    global PyImport_AddModuleObject
    global PyImport_ImportModule
    global PyRun_SimpleString
    global PyEval_GetGlobals
    global PyEval_GetBuiltins
    global PyLong_AsLong
    global PyLong_FromLong
    global PyFloat_AsDouble
    global PyFloat_FromDouble
    global PyBool_FromLong
    global PyBytes_AsString
    global PyList_New
    global PyList_Size
    global PyList_GetItem
    global PyList_SetItem
    global PyDict_New
    global PyDict_Next
    global PyDict_GetItem
    global PyDict_GetItemString
    global PyDict_SetItem
    global PyDict_Size
    global PySet_Add
    global PySet_New
    global PyTuple_New
    global PyTuple_Size
    global PyTuple_GetItem
    global PyTuple_SetItem
    global PyUnicode_AsEncodedString
    global PyUnicode_DecodeFSDefaultAndSize
    global PyUnicode_FromString
    global PyComplex_FromDoubles
    global PyComplex_RealAsDouble
    global PyComplex_ImagAsDouble
    global PyIter_Next
    global PySlice_New
    global PySlice_Unpack
    global PyNumber_Add
    global PyNumber_Subtract
    global PyNumber_Multiply
    global PyNumber_MatrixMultiply
    global PyNumber_FloorDivide
    global PyNumber_TrueDivide
    global PyNumber_Remainder
    global PyNumber_Divmod
    global PyNumber_Power
    global PyNumber_Negative
    global PyNumber_Positive
    global PyNumber_Absolute
    global PyNumber_Invert
    global PyNumber_Lshift
    global PyNumber_Rshift
    global PyNumber_And
    global PyNumber_Xor
    global PyNumber_Or
    global PyNumber_InPlaceAdd
    global PyNumber_InPlaceSubtract
    global PyNumber_InPlaceMultiply
    global PyNumber_InPlaceMatrixMultiply
    global PyNumber_InPlaceFloorDivide
    global PyNumber_InPlaceTrueDivide
    global PyNumber_InPlaceRemainder
    global PyNumber_InPlacePower
    global PyNumber_InPlaceLshift
    global PyNumber_InPlaceRshift
    global PyNumber_InPlaceAnd
    global PyNumber_InPlaceXor
    global PyNumber_InPlaceOr
    global PyNumber_Long
    global PyNumber_Float
    global PyNumber_Index
    global PyObject_Call
    global PyObject_GetAttr
    global PyObject_GetAttrString
    global PyObject_GetIter
    global PyObject_HasAttrString
    global PyObject_IsTrue
    global PyObject_Length
    global PyObject_LengthHint
    global PyObject_SetAttrString
    global PyObject_Str
    global PyObject_Repr
    global PyObject_Hash
    global PyObject_GetItem
    global PyObject_SetItem
    global PyObject_DelItem
    global PyObject_RichCompare
    global PyObject_IsInstance
    global PyErr_Fetch
    global PyErr_NormalizeException
    global PyErr_SetString
    global Py_None
    global Py_True
    global Py_False
    global Py_Ellipsis
    global Py_NotImplemented
    global PyLong_Type
    global PyFloat_Type
    global PyBool_Type
    global PyUnicode_Type
    global PyComplex_Type
    global PyList_Type
    global PyDict_Type
    global PySet_Type
    global PyTuple_Type
    global PySlice_Type
    global PyExc_BaseException
    global PyExc_Exception
    global PyExc_NameError
    global PyExc_OSError
    global PyExc_IOError
    global PyExc_ValueError
    global PyExc_LookupError
    global PyExc_IndexError
    global PyExc_KeyError
    global PyExc_TypeError
    global PyExc_ArithmeticError
    global PyExc_ZeroDivisionError
    global PyExc_OverflowError
    global PyExc_AttributeError
    global PyExc_RuntimeError
    global PyExc_NotImplementedError
    global PyExc_StopIteration
    global PyExc_AssertionError
    global PyExc_SystemExit

    Py_DecRef = dlsym(py_handle, "Py_DecRef")
    Py_IncRef = dlsym(py_handle, "Py_IncRef")
    Py_Initialize = dlsym(py_handle, "Py_Initialize")
    PyImport_AddModule = dlsym(py_handle, "PyImport_AddModule")
    PyImport_AddModuleObject = dlsym(py_handle, "PyImport_AddModuleObject")
    PyImport_ImportModule = dlsym(py_handle, "PyImport_ImportModule")
    PyRun_SimpleString = dlsym(py_handle, "PyRun_SimpleString")
    PyEval_GetGlobals = dlsym(py_handle, "PyEval_GetGlobals")
    PyEval_GetBuiltins = dlsym(py_handle, "PyEval_GetBuiltins")
    PyLong_AsLong = dlsym(py_handle, "PyLong_AsLong")
    PyLong_FromLong = dlsym(py_handle, "PyLong_FromLong")
    PyFloat_AsDouble = dlsym(py_handle, "PyFloat_AsDouble")
    PyFloat_FromDouble = dlsym(py_handle, "PyFloat_FromDouble")
    PyBool_FromLong = dlsym(py_handle, "PyBool_FromLong")
    PyBytes_AsString = dlsym(py_handle, "PyBytes_AsString")
    PyList_New = dlsym(py_handle, "PyList_New")
    PyList_Size = dlsym(py_handle, "PyList_Size")
    PyList_GetItem = dlsym(py_handle, "PyList_GetItem")
    PyList_SetItem = dlsym(py_handle, "PyList_SetItem")
    PyDict_New = dlsym(py_handle, "PyDict_New")
    PyDict_Next = dlsym(py_handle, "PyDict_Next")
    PyDict_GetItem = dlsym(py_handle, "PyDict_GetItem")
    PyDict_GetItemString = dlsym(py_handle, "PyDict_GetItemString")
    PyDict_SetItem = dlsym(py_handle, "PyDict_SetItem")
    PyDict_Size = dlsym(py_handle, "PyDict_Size")
    PySet_Add = dlsym(py_handle, "PySet_Add")
    PySet_New = dlsym(py_handle, "PySet_New")
    PyTuple_New = dlsym(py_handle, "PyTuple_New")
    PyTuple_Size = dlsym(py_handle, "PyTuple_Size")
    PyTuple_GetItem = dlsym(py_handle, "PyTuple_GetItem")
    PyTuple_SetItem = dlsym(py_handle, "PyTuple_SetItem")
    PyUnicode_AsEncodedString = dlsym(py_handle, "PyUnicode_AsEncodedString")
    PyUnicode_DecodeFSDefaultAndSize = dlsym(py_handle, "PyUnicode_DecodeFSDefaultAndSize")
    PyUnicode_FromString = dlsym(py_handle, "PyUnicode_FromString")
    PyComplex_FromDoubles = dlsym(py_handle, "PyComplex_FromDoubles")
    PyComplex_RealAsDouble = dlsym(py_handle, "PyComplex_RealAsDouble")
    PyComplex_ImagAsDouble = dlsym(py_handle, "PyComplex_ImagAsDouble")
    PyIter_Next = dlsym(py_handle, "PyIter_Next")
    PySlice_New = dlsym(py_handle, "PySlice_New")
    PySlice_Unpack = dlsym(py_handle, "PySlice_Unpack")
    PyNumber_Add = dlsym(py_handle, "PyNumber_Add")
    PyNumber_Subtract = dlsym(py_handle, "PyNumber_Subtract")
    PyNumber_Multiply = dlsym(py_handle, "PyNumber_Multiply")
    PyNumber_MatrixMultiply = dlsym(py_handle, "PyNumber_MatrixMultiply")
    PyNumber_FloorDivide = dlsym(py_handle, "PyNumber_FloorDivide")
    PyNumber_TrueDivide = dlsym(py_handle, "PyNumber_TrueDivide")
    PyNumber_Remainder = dlsym(py_handle, "PyNumber_Remainder")
    PyNumber_Divmod = dlsym(py_handle, "PyNumber_Divmod")
    PyNumber_Power = dlsym(py_handle, "PyNumber_Power")
    PyNumber_Negative = dlsym(py_handle, "PyNumber_Negative")
    PyNumber_Positive = dlsym(py_handle, "PyNumber_Positive")
    PyNumber_Absolute = dlsym(py_handle, "PyNumber_Absolute")
    PyNumber_Invert = dlsym(py_handle, "PyNumber_Invert")
    PyNumber_Lshift = dlsym(py_handle, "PyNumber_Lshift")
    PyNumber_Rshift = dlsym(py_handle, "PyNumber_Rshift")
    PyNumber_And = dlsym(py_handle, "PyNumber_And")
    PyNumber_Xor = dlsym(py_handle, "PyNumber_Xor")
    PyNumber_Or = dlsym(py_handle, "PyNumber_Or")
    PyNumber_InPlaceAdd = dlsym(py_handle, "PyNumber_InPlaceAdd")
    PyNumber_InPlaceSubtract = dlsym(py_handle, "PyNumber_InPlaceSubtract")
    PyNumber_InPlaceMultiply = dlsym(py_handle, "PyNumber_InPlaceMultiply")
    PyNumber_InPlaceMatrixMultiply = dlsym(py_handle, "PyNumber_InPlaceMatrixMultiply")
    PyNumber_InPlaceFloorDivide = dlsym(py_handle, "PyNumber_InPlaceFloorDivide")
    PyNumber_InPlaceTrueDivide = dlsym(py_handle, "PyNumber_InPlaceTrueDivide")
    PyNumber_InPlaceRemainder = dlsym(py_handle, "PyNumber_InPlaceRemainder")
    PyNumber_InPlacePower = dlsym(py_handle, "PyNumber_InPlacePower")
    PyNumber_InPlaceLshift = dlsym(py_handle, "PyNumber_InPlaceLshift")
    PyNumber_InPlaceRshift = dlsym(py_handle, "PyNumber_InPlaceRshift")
    PyNumber_InPlaceAnd = dlsym(py_handle, "PyNumber_InPlaceAnd")
    PyNumber_InPlaceXor = dlsym(py_handle, "PyNumber_InPlaceXor")
    PyNumber_InPlaceOr = dlsym(py_handle, "PyNumber_InPlaceOr")
    PyNumber_Long = dlsym(py_handle, "PyNumber_Long")
    PyNumber_Float = dlsym(py_handle, "PyNumber_Float")
    PyNumber_Index = dlsym(py_handle, "PyNumber_Index")
    PyObject_Call = dlsym(py_handle, "PyObject_Call")
    PyObject_GetAttr = dlsym(py_handle, "PyObject_GetAttr")
    PyObject_GetAttrString = dlsym(py_handle, "PyObject_GetAttrString")
    PyObject_GetIter = dlsym(py_handle, "PyObject_GetIter")
    PyObject_HasAttrString = dlsym(py_handle, "PyObject_HasAttrString")
    PyObject_IsTrue = dlsym(py_handle, "PyObject_IsTrue")
    PyObject_Length = dlsym(py_handle, "PyObject_Length")
    PyObject_LengthHint = dlsym(py_handle, "PyObject_LengthHint")
    PyObject_SetAttrString = dlsym(py_handle, "PyObject_SetAttrString")
    PyObject_Str = dlsym(py_handle, "PyObject_Str")
    PyObject_Repr = dlsym(py_handle, "PyObject_Repr")
    PyObject_Hash = dlsym(py_handle, "PyObject_Hash")
    PyObject_GetItem = dlsym(py_handle, "PyObject_GetItem")
    PyObject_SetItem = dlsym(py_handle, "PyObject_SetItem")
    PyObject_DelItem = dlsym(py_handle, "PyObject_DelItem")
    PyObject_RichCompare = dlsym(py_handle, "PyObject_RichCompare")
    PyObject_IsInstance = dlsym(py_handle, "PyObject_IsInstance")
    PyErr_Fetch = dlsym(py_handle, "PyErr_Fetch")
    PyErr_NormalizeException = dlsym(py_handle, "PyErr_NormalizeException")
    PyErr_SetString = dlsym(py_handle, "PyErr_SetString")
    Py_None = dlsym(py_handle, "_Py_NoneStruct")
    Py_True = dlsym(py_handle, "_Py_TrueStruct")
    Py_False = dlsym(py_handle, "_Py_FalseStruct")
    Py_Ellipsis = dlsym(py_handle, "_Py_EllipsisObject")
    Py_NotImplemented = dlsym(py_handle, "_Py_NotImplementedStruct")
    PyLong_Type = dlsym(py_handle, "PyLong_Type")
    PyFloat_Type = dlsym(py_handle, "PyFloat_Type")
    PyBool_Type = dlsym(py_handle, "PyBool_Type")
    PyUnicode_Type = dlsym(py_handle, "PyUnicode_Type")
    PyComplex_Type = dlsym(py_handle, "PyComplex_Type")
    PyList_Type = dlsym(py_handle, "PyList_Type")
    PyDict_Type = dlsym(py_handle, "PyDict_Type")
    PySet_Type = dlsym(py_handle, "PySet_Type")
    PyTuple_Type = dlsym(py_handle, "PyTuple_Type")
    PySlice_Type = dlsym(py_handle, "PySlice_Type")
    PyExc_BaseException = Ptr[cobj](dlsym(py_handle, "PyExc_BaseException"))[0]
    PyExc_Exception = Ptr[cobj](dlsym(py_handle, "PyExc_Exception"))[0]
    PyExc_NameError = Ptr[cobj](dlsym(py_handle, "PyExc_NameError"))[0]
    PyExc_OSError = Ptr[cobj](dlsym(py_handle, "PyExc_OSError"))[0]
    PyExc_IOError = Ptr[cobj](dlsym(py_handle, "PyExc_IOError"))[0]
    PyExc_ValueError = Ptr[cobj](dlsym(py_handle, "PyExc_ValueError"))[0]
    PyExc_LookupError = Ptr[cobj](dlsym(py_handle, "PyExc_LookupError"))[0]
    PyExc_IndexError = Ptr[cobj](dlsym(py_handle, "PyExc_IndexError"))[0]
    PyExc_KeyError = Ptr[cobj](dlsym(py_handle, "PyExc_KeyError"))[0]
    PyExc_TypeError = Ptr[cobj](dlsym(py_handle, "PyExc_TypeError"))[0]
    PyExc_ArithmeticError = Ptr[cobj](dlsym(py_handle, "PyExc_ArithmeticError"))[0]
    PyExc_ZeroDivisionError = Ptr[cobj](dlsym(py_handle, "PyExc_ZeroDivisionError"))[0]
    PyExc_OverflowError = Ptr[cobj](dlsym(py_handle, "PyExc_OverflowError"))[0]
    PyExc_AttributeError = Ptr[cobj](dlsym(py_handle, "PyExc_AttributeError"))[0]
    PyExc_RuntimeError = Ptr[cobj](dlsym(py_handle, "PyExc_RuntimeError"))[0]
    PyExc_NotImplementedError = Ptr[cobj](dlsym(py_handle, "PyExc_NotImplementedError"))[0]
    PyExc_StopIteration = Ptr[cobj](dlsym(py_handle, "PyExc_StopIteration"))[0]
    PyExc_AssertionError = Ptr[cobj](dlsym(py_handle, "PyExc_AssertionError"))[0]
    PyExc_SystemExit = Ptr[cobj](dlsym(py_handle, "PyExc_SystemExit"))[0]

def init_handles_static():
    from C import Py_DecRef(cobj) as _Py_DecRef
    from C import Py_IncRef(cobj) as _Py_IncRef
    from C import Py_Initialize() as _Py_Initialize
    from C import PyImport_AddModule(cobj) -&gt; cobj as _PyImport_AddModule
    from C import PyImport_AddModuleObject(cobj) -&gt; cobj as _PyImport_AddModuleObject
    from C import PyImport_ImportModule(cobj) -&gt; cobj as _PyImport_ImportModule
    from C import PyRun_SimpleString(cobj) as _PyRun_SimpleString
    from C import PyEval_GetGlobals() -&gt; cobj as _PyEval_GetGlobals
    from C import PyEval_GetBuiltins() -&gt; cobj as _PyEval_GetBuiltins
    from C import PyLong_AsLong(cobj) -&gt; int as _PyLong_AsLong
    from C import PyLong_FromLong(int) -&gt; cobj as _PyLong_FromLong
    from C import PyFloat_AsDouble(cobj) -&gt; float as _PyFloat_AsDouble
    from C import PyFloat_FromDouble(float) -&gt; cobj as _PyFloat_FromDouble
    from C import PyBool_FromLong(int) -&gt; cobj as _PyBool_FromLong
    from C import PyBytes_AsString(cobj) -&gt; cobj as _PyBytes_AsString
    from C import PyList_New(int) -&gt; cobj as _PyList_New
    from C import PyList_Size(cobj) -&gt; int as _PyList_Size
    from C import PyList_GetItem(cobj, int) -&gt; cobj as _PyList_GetItem
    from C import PyList_SetItem(cobj, int, cobj) -&gt; cobj as _PyList_SetItem
    from C import PyDict_New() -&gt; cobj as _PyDict_New
    from C import PyDict_Next(cobj, Ptr[int], Ptr[cobj], Ptr[cobj]) -&gt; int as _PyDict_Next
    from C import PyDict_GetItem(cobj, cobj) -&gt; cobj as _PyDict_GetItem
    from C import PyDict_GetItemString(cobj, cobj) -&gt; cobj as _PyDict_GetItemString
    from C import PyDict_SetItem(cobj, cobj, cobj) -&gt; cobj as _PyDict_SetItem
    from C import PyDict_Size(cobj) -&gt; int as _PyDict_Size
    from C import PySet_Add(cobj, cobj) -&gt; cobj as _PySet_Add
    from C import PySet_New(cobj) -&gt; cobj as _PySet_New
    from C import PyTuple_New(int) -&gt; cobj as _PyTuple_New
    from C import PyTuple_Size(cobj) -&gt; int as _PyTuple_Size
    from C import PyTuple_GetItem(cobj, int) -&gt; cobj as _PyTuple_GetItem
    from C import PyTuple_SetItem(cobj, int, cobj) as _PyTuple_SetItem
    from C import PyUnicode_AsEncodedString(cobj, cobj, cobj) -&gt; cobj as _PyUnicode_AsEncodedString
    from C import PyUnicode_DecodeFSDefaultAndSize(cobj, int) -&gt; cobj as _PyUnicode_DecodeFSDefaultAndSize
    from C import PyUnicode_FromString(cobj) -&gt; cobj as _PyUnicode_FromString
    from C import PyComplex_FromDoubles(float, float) -&gt; cobj as _PyComplex_FromDoubles
    from C import PyComplex_RealAsDouble(cobj) -&gt; float as _PyComplex_RealAsDouble
    from C import PyComplex_ImagAsDouble(cobj) -&gt; float as _PyComplex_ImagAsDouble
    from C import PyIter_Next(cobj) -&gt; cobj as _PyIter_Next
    from C import PySlice_New(cobj, cobj, cobj) -&gt; cobj as _PySlice_New
    from C import PySlice_Unpack(cobj, Ptr[int], Ptr[int], Ptr[int]) -&gt; int as _PySlice_Unpack
    from C import PyNumber_Add(cobj, cobj) -&gt; cobj as _PyNumber_Add
    from C import PyNumber_Subtract(cobj, cobj) -&gt; cobj as _PyNumber_Subtract
    from C import PyNumber_Multiply(cobj, cobj) -&gt; cobj as _PyNumber_Multiply
    from C import PyNumber_MatrixMultiply(cobj, cobj) -&gt; cobj as _PyNumber_MatrixMultiply
    from C import PyNumber_FloorDivide(cobj, cobj) -&gt; cobj as _PyNumber_FloorDivide
    from C import PyNumber_TrueDivide(cobj, cobj) -&gt; cobj as _PyNumber_TrueDivide
    from C import PyNumber_Remainder(cobj, cobj) -&gt; cobj as _PyNumber_Remainder
    from C import PyNumber_Divmod(cobj, cobj) -&gt; cobj as _PyNumber_Divmod
    from C import PyNumber_Power(cobj, cobj, cobj) -&gt; cobj as _PyNumber_Power
    from C import PyNumber_Negative(cobj) -&gt; cobj as _PyNumber_Negative
    from C import PyNumber_Positive(cobj) -&gt; cobj as _PyNumber_Positive
    from C import PyNumber_Absolute(cobj) -&gt; cobj as _PyNumber_Absolute
    from C import PyNumber_Invert(cobj) -&gt; cobj as _PyNumber_Invert
    from C import PyNumber_Lshift(cobj, cobj) -&gt; cobj as _PyNumber_Lshift
    from C import PyNumber_Rshift(cobj, cobj) -&gt; cobj as _PyNumber_Rshift
    from C import PyNumber_And(cobj, cobj) -&gt; cobj as _PyNumber_And
    from C import PyNumber_Xor(cobj, cobj) -&gt; cobj as _PyNumber_Xor
    from C import PyNumber_Or(cobj, cobj) -&gt; cobj as _PyNumber_Or
    from C import PyNumber_InPlaceAdd(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceAdd
    from C import PyNumber_InPlaceSubtract(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceSubtract
    from C import PyNumber_InPlaceMultiply(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceMultiply
    from C import PyNumber_InPlaceMatrixMultiply(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceMatrixMultiply
    from C import PyNumber_InPlaceFloorDivide(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceFloorDivide
    from C import PyNumber_InPlaceTrueDivide(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceTrueDivide
    from C import PyNumber_InPlaceRemainder(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceRemainder
    from C import PyNumber_InPlacePower(cobj, cobj, cobj) -&gt; cobj as _PyNumber_InPlacePower
    from C import PyNumber_InPlaceLshift(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceLshift
    from C import PyNumber_InPlaceRshift(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceRshift
    from C import PyNumber_InPlaceAnd(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceAnd
    from C import PyNumber_InPlaceXor(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceXor
    from C import PyNumber_InPlaceOr(cobj, cobj) -&gt; cobj as _PyNumber_InPlaceOr
    from C import PyNumber_Long(cobj) -&gt; cobj as _PyNumber_Long
    from C import PyNumber_Float(cobj) -&gt; cobj as _PyNumber_Float
    from C import PyNumber_Index(cobj) -&gt; cobj as _PyNumber_Index
    from C import PyObject_Call(cobj, cobj, cobj) -&gt; cobj as _PyObject_Call
    from C import PyObject_GetAttr(cobj, cobj) -&gt; cobj as _PyObject_GetAttr
    from C import PyObject_GetAttrString(cobj, cobj) -&gt; cobj as _PyObject_GetAttrString
    from C import PyObject_GetIter(cobj) -&gt; cobj as _PyObject_GetIter
    from C import PyObject_HasAttrString(cobj, cobj) -&gt; int as _PyObject_HasAttrString
    from C import PyObject_IsTrue(cobj) -&gt; int as _PyObject_IsTrue
    from C import PyObject_Length(cobj) -&gt; int as _PyObject_Length
    from C import PyObject_LengthHint(cobj, int) -&gt; int as _PyObject_LengthHint
    from C import PyObject_SetAttrString(cobj, cobj, cobj) -&gt; cobj as _PyObject_SetAttrString
    from C import PyObject_Str(cobj) -&gt; cobj as _PyObject_Str
    from C import PyObject_Repr(cobj) -&gt; cobj as _PyObject_Repr
    from C import PyObject_Hash(cobj) -&gt; int as _PyObject_Hash
    from C import PyObject_GetItem(cobj, cobj) -&gt; cobj as _PyObject_GetItem
    from C import PyObject_SetItem(cobj, cobj, cobj) -&gt; int as _PyObject_SetItem
    from C import PyObject_DelItem(cobj, cobj) -&gt; int as _PyObject_DelItem
    from C import PyObject_RichCompare(cobj, cobj, i32) -&gt; cobj as _PyObject_RichCompare
    from C import PyObject_IsInstance(cobj, cobj) -&gt; i32 as _PyObject_IsInstance
    from C import PyErr_Fetch(Ptr[cobj], Ptr[cobj], Ptr[cobj]) as _PyErr_Fetch
    from C import PyErr_NormalizeException(Ptr[cobj], Ptr[cobj], Ptr[cobj]) as _PyErr_NormalizeException
    from C import PyErr_SetString(cobj, cobj) as _PyErr_SetString
    from C import _Py_NoneStruct: cobj
    from C import _Py_TrueStruct: cobj
    from C import _Py_FalseStruct: cobj
    from C import _Py_EllipsisObject: cobj
    from C import _Py_NotImplementedStruct: cobj
    from C import PyLong_Type: cobj as _PyLong_Type
    from C import PyFloat_Type: cobj as _PyFloat_Type
    from C import PyBool_Type: cobj as _PyBool_Type
    from C import PyUnicode_Type: cobj as _PyUnicode_Type
    from C import PyComplex_Type: cobj as _PyComplex_Type
    from C import PyList_Type: cobj as _PyList_Type
    from C import PyDict_Type: cobj as _PyDict_Type
    from C import PySet_Type: cobj as _PySet_Type
    from C import PyTuple_Type: cobj as _PyTuple_Type
    from C import PySlice_Type: cobj as _PySlice_Type
    from C import PyExc_BaseException: cobj as _PyExc_BaseException
    from C import PyExc_Exception: cobj as _PyExc_Exception
    from C import PyExc_NameError: cobj as _PyExc_NameError
    from C import PyExc_OSError: cobj as _PyExc_OSError
    from C import PyExc_IOError: cobj as _PyExc_IOError
    from C import PyExc_ValueError: cobj as _PyExc_ValueError
    from C import PyExc_LookupError: cobj as _PyExc_LookupError
    from C import PyExc_IndexError: cobj as _PyExc_IndexError
    from C import PyExc_KeyError: cobj as _PyExc_KeyError
    from C import PyExc_TypeError: cobj as _PyExc_TypeError
    from C import PyExc_ArithmeticError: cobj as _PyExc_ArithmeticError
    from C import PyExc_ZeroDivisionError: cobj as _PyExc_ZeroDivisionError
    from C import PyExc_OverflowError: cobj as _PyExc_OverflowError
    from C import PyExc_AttributeError: cobj as _PyExc_AttributeError
    from C import PyExc_RuntimeError: cobj as _PyExc_RuntimeError
    from C import PyExc_NotImplementedError: cobj as _PyExc_NotImplementedError
    from C import PyExc_StopIteration: cobj as _PyExc_StopIteration
    from C import PyExc_AssertionError: cobj as _PyExc_AssertionError
    from C import PyExc_SystemExit: cobj as _PyExc_SystemExit

    global Py_DecRef
    global Py_IncRef
    global Py_Initialize
    global PyImport_AddModule
    global PyImport_AddModuleObject
    global PyImport_ImportModule
    global PyRun_SimpleString
    global PyEval_GetGlobals
    global PyEval_GetBuiltins
    global PyLong_AsLong
    global PyLong_FromLong
    global PyFloat_AsDouble
    global PyFloat_FromDouble
    global PyBool_FromLong
    global PyBytes_AsString
    global PyList_New
    global PyList_Size
    global PyList_GetItem
    global PyList_SetItem
    global PyDict_New
    global PyDict_Next
    global PyDict_GetItem
    global PyDict_GetItemString
    global PyDict_SetItem
    global PyDict_Size
    global PySet_Add
    global PySet_New
    global PyTuple_New
    global PyTuple_Size
    global PyTuple_GetItem
    global PyTuple_SetItem
    global PyUnicode_AsEncodedString
    global PyUnicode_DecodeFSDefaultAndSize
    global PyUnicode_FromString
    global PyComplex_FromDoubles
    global PyComplex_RealAsDouble
    global PyComplex_ImagAsDouble
    global PyIter_Next
    global PySlice_New
    global PySlice_Unpack
    global PyNumber_Add
    global PyNumber_Subtract
    global PyNumber_Multiply
    global PyNumber_MatrixMultiply
    global PyNumber_FloorDivide
    global PyNumber_TrueDivide
    global PyNumber_Remainder
    global PyNumber_Divmod
    global PyNumber_Power
    global PyNumber_Negative
    global PyNumber_Positive
    global PyNumber_Absolute
    global PyNumber_Invert
    global PyNumber_Lshift
    global PyNumber_Rshift
    global PyNumber_And
    global PyNumber_Xor
    global PyNumber_Or
    global PyNumber_InPlaceAdd
    global PyNumber_InPlaceSubtract
    global PyNumber_InPlaceMultiply
    global PyNumber_InPlaceMatrixMultiply
    global PyNumber_InPlaceFloorDivide
    global PyNumber_InPlaceTrueDivide
    global PyNumber_InPlaceRemainder
    global PyNumber_InPlacePower
    global PyNumber_InPlaceLshift
    global PyNumber_InPlaceRshift
    global PyNumber_InPlaceAnd
    global PyNumber_InPlaceXor
    global PyNumber_InPlaceOr
    global PyNumber_Long
    global PyNumber_Float
    global PyNumber_Index
    global PyObject_Call
    global PyObject_GetAttr
    global PyObject_GetAttrString
    global PyObject_GetIter
    global PyObject_HasAttrString
    global PyObject_IsTrue
    global PyObject_Length
    global PyObject_LengthHint
    global PyObject_SetAttrString
    global PyObject_Str
    global PyObject_Repr
    global PyObject_Hash
    global PyObject_GetItem
    global PyObject_SetItem
    global PyObject_DelItem
    global PyObject_RichCompare
    global PyObject_IsInstance
    global PyErr_Fetch
    global PyErr_NormalizeException
    global PyErr_SetString
    global Py_None
    global Py_True
    global Py_False
    global Py_Ellipsis
    global Py_NotImplemented
    global PyLong_Type
    global PyFloat_Type
    global PyBool_Type
    global PyUnicode_Type
    global PyComplex_Type
    global PyList_Type
    global PyDict_Type
    global PySet_Type
    global PyTuple_Type
    global PySlice_Type
    global PyExc_BaseException
    global PyExc_Exception
    global PyExc_NameError
    global PyExc_OSError
    global PyExc_IOError
    global PyExc_ValueError
    global PyExc_LookupError
    global PyExc_IndexError
    global PyExc_KeyError
    global PyExc_TypeError
    global PyExc_ArithmeticError
    global PyExc_ZeroDivisionError
    global PyExc_OverflowError
    global PyExc_AttributeError
    global PyExc_RuntimeError
    global PyExc_NotImplementedError
    global PyExc_StopIteration
    global PyExc_AssertionError
    global PyExc_SystemExit

    Py_DecRef = _Py_DecRef
    Py_IncRef = _Py_IncRef
    Py_Initialize = _Py_Initialize
    PyImport_AddModule = _PyImport_AddModule
    PyImport_AddModuleObject = _PyImport_AddModuleObject
    PyImport_ImportModule = _PyImport_ImportModule
    PyRun_SimpleString = _PyRun_SimpleString
    PyEval_GetGlobals = _PyEval_GetGlobals
    PyEval_GetBuiltins = _PyEval_GetBuiltins
    PyLong_AsLong = _PyLong_AsLong
    PyLong_FromLong = _PyLong_FromLong
    PyFloat_AsDouble = _PyFloat_AsDouble
    PyFloat_FromDouble = _PyFloat_FromDouble
    PyBool_FromLong = _PyBool_FromLong
    PyBytes_AsString = _PyBytes_AsString
    PyList_New = _PyList_New
    PyList_Size = _PyList_Size
    PyList_GetItem = _PyList_GetItem
    PyList_SetItem = _PyList_SetItem
    PyDict_New = _PyDict_New
    PyDict_Next = _PyDict_Next
    PyDict_GetItem = _PyDict_GetItem
    PyDict_GetItemString = _PyDict_GetItemString
    PyDict_SetItem = _PyDict_SetItem
    PyDict_Size = _PyDict_Size
    PySet_Add = _PySet_Add
    PySet_New = _PySet_New
    PyTuple_New = _PyTuple_New
    PyTuple_Size = _PyTuple_Size
    PyTuple_GetItem = _PyTuple_GetItem
    PyTuple_SetItem = _PyTuple_SetItem
    PyUnicode_AsEncodedString = _PyUnicode_AsEncodedString
    PyUnicode_DecodeFSDefaultAndSize = _PyUnicode_DecodeFSDefaultAndSize
    PyUnicode_FromString = _PyUnicode_FromString
    PyComplex_FromDoubles = _PyComplex_FromDoubles
    PyComplex_RealAsDouble = _PyComplex_RealAsDouble
    PyComplex_ImagAsDouble = _PyComplex_ImagAsDouble
    PyIter_Next = _PyIter_Next
    PySlice_New = _PySlice_New
    PySlice_Unpack = _PySlice_Unpack
    PyNumber_Add = _PyNumber_Add
    PyNumber_Subtract = _PyNumber_Subtract
    PyNumber_Multiply = _PyNumber_Multiply
    PyNumber_MatrixMultiply = _PyNumber_MatrixMultiply
    PyNumber_FloorDivide = _PyNumber_FloorDivide
    PyNumber_TrueDivide = _PyNumber_TrueDivide
    PyNumber_Remainder = _PyNumber_Remainder
    PyNumber_Divmod = _PyNumber_Divmod
    PyNumber_Power = _PyNumber_Power
    PyNumber_Negative = _PyNumber_Negative
    PyNumber_Positive = _PyNumber_Positive
    PyNumber_Absolute = _PyNumber_Absolute
    PyNumber_Invert = _PyNumber_Invert
    PyNumber_Lshift = _PyNumber_Lshift
    PyNumber_Rshift = _PyNumber_Rshift
    PyNumber_And = _PyNumber_And
    PyNumber_Xor = _PyNumber_Xor
    PyNumber_Or = _PyNumber_Or
    PyNumber_InPlaceAdd = _PyNumber_InPlaceAdd
    PyNumber_InPlaceSubtract = _PyNumber_InPlaceSubtract
    PyNumber_InPlaceMultiply = _PyNumber_InPlaceMultiply
    PyNumber_InPlaceMatrixMultiply = _PyNumber_InPlaceMatrixMultiply
    PyNumber_InPlaceFloorDivide = _PyNumber_InPlaceFloorDivide
    PyNumber_InPlaceTrueDivide = _PyNumber_InPlaceTrueDivide
    PyNumber_InPlaceRemainder = _PyNumber_InPlaceRemainder
    PyNumber_InPlacePower = _PyNumber_InPlacePower
    PyNumber_InPlaceLshift = _PyNumber_InPlaceLshift
    PyNumber_InPlaceRshift = _PyNumber_InPlaceRshift
    PyNumber_InPlaceAnd = _PyNumber_InPlaceAnd
    PyNumber_InPlaceXor = _PyNumber_InPlaceXor
    PyNumber_InPlaceOr = _PyNumber_InPlaceOr
    PyNumber_Long = _PyNumber_Long
    PyNumber_Float = _PyNumber_Float
    PyNumber_Index = _PyNumber_Index
    PyObject_Call = _PyObject_Call
    PyObject_GetAttr = _PyObject_GetAttr
    PyObject_GetAttrString = _PyObject_GetAttrString
    PyObject_GetIter = _PyObject_GetIter
    PyObject_HasAttrString = _PyObject_HasAttrString
    PyObject_IsTrue = _PyObject_IsTrue
    PyObject_Length = _PyObject_Length
    PyObject_LengthHint = _PyObject_LengthHint
    PyObject_SetAttrString = _PyObject_SetAttrString
    PyObject_Str = _PyObject_Str
    PyObject_Repr = _PyObject_Repr
    PyObject_Hash = _PyObject_Hash
    PyObject_GetItem = _PyObject_GetItem
    PyObject_SetItem = _PyObject_SetItem
    PyObject_DelItem = _PyObject_DelItem
    PyObject_RichCompare = _PyObject_RichCompare
    PyObject_IsInstance = _PyObject_IsInstance
    PyErr_Fetch = _PyErr_Fetch
    PyErr_NormalizeException = _PyErr_NormalizeException
    PyErr_SetString = _PyErr_SetString
    Py_None = __ptr__(_Py_NoneStruct).as_byte()
    Py_True = __ptr__(_Py_TrueStruct).as_byte()
    Py_False = __ptr__(_Py_FalseStruct).as_byte()
    Py_Ellipsis = __ptr__(_Py_EllipsisObject).as_byte()
    Py_NotImplemented = __ptr__(_Py_NotImplementedStruct).as_byte()
    PyLong_Type = __ptr__(_PyLong_Type).as_byte()
    PyFloat_Type = __ptr__(_PyFloat_Type).as_byte()
    PyBool_Type = __ptr__(_PyBool_Type).as_byte()
    PyUnicode_Type = __ptr__(_PyUnicode_Type).as_byte()
    PyComplex_Type = __ptr__(_PyComplex_Type).as_byte()
    PyList_Type = __ptr__(_PyList_Type).as_byte()
    PyDict_Type = __ptr__(_PyDict_Type).as_byte()
    PySet_Type = __ptr__(_PySet_Type).as_byte()
    PyTuple_Type = __ptr__(_PyTuple_Type).as_byte()
    PySlice_Type = __ptr__(_PySlice_Type).as_byte()
    PyExc_BaseException = _PyExc_BaseException
    PyExc_Exception = _PyExc_Exception
    PyExc_NameError = _PyExc_NameError
    PyExc_OSError = _PyExc_OSError
    PyExc_IOError = _PyExc_IOError
    PyExc_ValueError = _PyExc_ValueError
    PyExc_LookupError = _PyExc_LookupError
    PyExc_IndexError = _PyExc_IndexError
    PyExc_KeyError = _PyExc_KeyError
    PyExc_TypeError = _PyExc_TypeError
    PyExc_ArithmeticError = _PyExc_ArithmeticError
    PyExc_ZeroDivisionError = _PyExc_ZeroDivisionError
    PyExc_OverflowError = _PyExc_OverflowError
    PyExc_AttributeError = _PyExc_AttributeError
    PyExc_RuntimeError = _PyExc_RuntimeError
    PyExc_NotImplementedError = _PyExc_NotImplementedError
    PyExc_StopIteration = _PyExc_StopIteration
    PyExc_AssertionError = _PyExc_AssertionError
    PyExc_SystemExit = _PyExc_SystemExit

def init_error_py_types():
    BaseException._pytype = PyExc_BaseException
    Exception._pytype = PyExc_Exception
    NameError._pytype = PyExc_NameError
    OSError._pytype = PyExc_OSError
    IOError._pytype = PyExc_IOError
    ValueError._pytype = PyExc_ValueError
    LookupError._pytype = PyExc_LookupError
    IndexError._pytype = PyExc_IndexError
    KeyError._pytype = PyExc_KeyError
    TypeError._pytype = PyExc_TypeError
    ArithmeticError._pytype = PyExc_ArithmeticError
    ZeroDivisionError._pytype = PyExc_ZeroDivisionError
    OverflowError._pytype = PyExc_OverflowError
    AttributeError._pytype = PyExc_AttributeError
    RuntimeError._pytype = PyExc_RuntimeError
    NotImplementedError._pytype = PyExc_NotImplementedError
    StopIteration._pytype = PyExc_StopIteration
    AssertionError._pytype = PyExc_AssertionError
    SystemExit._pytype = PyExc_SystemExit

def setup_python(python_loaded: bool):
    global _PY_INITIALIZED
    if _PY_INITIALIZED:
        return

    py_handle = cobj()
    if python_loaded:
        py_handle = dlopen("", RTLD_LOCAL | RTLD_NOW)
    else:
        LD = os.getenv("CODON_PYTHON", default="libpython." + dlext())
        py_handle = dlopen(LD, RTLD_LOCAL | RTLD_NOW)

    init_handles_dlopen(py_handle)
    init_error_py_types()

    if not python_loaded:
        Py_Initialize()

    _PY_INITIALIZED = True

def ensure_initialized(python_loaded: bool = False):
    if __py_extension__:
        init_handles_static()
        init_error_py_types()
    else:
        setup_python(python_loaded)
        PyRun_SimpleString(_PY_INIT.c_str())

def setup_decorator():
    setup_python(True)

@tuple
class _PyArg_Parser:
    initialized: i32
    format: cobj
    keywords: Ptr[cobj]
    fname: cobj
    custom_msg: cobj
    pos: i32
    min: i32
    max: i32
    kwtuple: cobj
    next: cobj

    def __new__(fname: cobj, keywords: Ptr[cobj], format: cobj):
        z = i32(0)
        o = cobj()
        return _PyArg_Parser(z, format, keywords, fname, o, z, z, z, o, o)

@extend
class pyobj:
    @__internal__
    def __new__() -&gt; pyobj:
        pass

    def __raw__(self) -&gt; Ptr[byte]:
        return __internal__.class_raw(self)

    def __init__(self, p: Ptr[byte], steal: bool = False):
        self.p = p
        if not steal:
            self.incref()

    def __del__(self):
        self.decref()

    def _getattr(self, name: str) -&gt; pyobj:
        return pyobj(pyobj.exc_wrap(PyObject_GetAttrString(self.p, name.c_str())), steal=True)

    def __add__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Add(self.p, other.__to_py__())), steal=True)

    def __radd__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Add(other.__to_py__(), self.p)), steal=True)

    def __sub__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Subtract(self.p, other.__to_py__())), steal=True)

    def __rsub__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Subtract(other.__to_py__(), self.p)), steal=True)

    def __mul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Multiply(self.p, other.__to_py__())), steal=True)

    def __rmul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Multiply(other.__to_py__(), self.p)), steal=True)

    def __matmul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_MatrixMultiply(self.p, other.__to_py__())), steal=True)

    def __rmatmul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_MatrixMultiply(other.__to_py__(), self.p)), steal=True)

    def __floordiv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_FloorDivide(self.p, other.__to_py__())), steal=True)

    def __rfloordiv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_FloorDivide(other.__to_py__(), self.p)), steal=True)

    def __truediv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_TrueDivide(self.p, other.__to_py__())), steal=True)

    def __rtruediv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_TrueDivide(other.__to_py__(), self.p)), steal=True)

    def __mod__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Remainder(self.p, other.__to_py__())), steal=True)

    def __rmod__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Remainder(other.__to_py__(), self.p)), steal=True)

    def __divmod__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Divmod(self.p, other.__to_py__())), steal=True)

    def __rdivmod__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Divmod(other.__to_py__(), self.p)), steal=True)

    def __pow__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Power(self.p, other.__to_py__(), Py_None)), steal=True)

    def __rpow__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Power(other.__to_py__(), self.p, Py_None)), steal=True)

    def __neg__(self):
        return pyobj(pyobj.exc_wrap(PyNumber_Negative(self.p)), steal=True)

    def __pos__(self):
        return pyobj(pyobj.exc_wrap(PyNumber_Positive(self.p)), steal=True)

    def __invert__(self):
        return pyobj(pyobj.exc_wrap(PyNumber_Invert(self.p)), steal=True)

    def __lshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Lshift(self.p, other.__to_py__())), steal=True)

    def __rlshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Lshift(other.__to_py__(), self.p)), steal=True)

    def __rshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Rshift(self.p, other.__to_py__())), steal=True)

    def __rrshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Rshift(other.__to_py__(), self.p)), steal=True)

    def __and__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_And(self.p, other.__to_py__())), steal=True)

    def __rand__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_And(other.__to_py__(), self.p)), steal=True)

    def __xor__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Xor(self.p, other.__to_py__())), steal=True)

    def __rxor__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Xor(other.__to_py__(), self.p)), steal=True)

    def __or__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Or(self.p, other.__to_py__())), steal=True)

    def __ror__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_Or(other.__to_py__(), self.p)), steal=True)

    def __iadd__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceAdd(self.p, other.__to_py__())), steal=True)

    def __isub__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceSubtract(self.p, other.__to_py__())), steal=True)

    def __imul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceMultiply(self.p, other.__to_py__())), steal=True)

    def __imatmul__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceMatrixMultiply(self.p, other.__to_py__())), steal=True)

    def __ifloordiv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceFloorDivide(self.p, other.__to_py__())), steal=True)

    def __itruediv__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceTrueDivide(self.p, other.__to_py__())), steal=True)

    def __imod__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceRemainder(self.p, other.__to_py__())), steal=True)

    def __ipow__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlacePower(self.p, other.__to_py__(), Py_None)), steal=True)

    def __ilshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceLshift(self.p, other.__to_py__())), steal=True)

    def __irshift__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceRshift(self.p, other.__to_py__())), steal=True)

    def __iand__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceAnd(self.p, other.__to_py__())), steal=True)

    def __ixor__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceXor(self.p, other.__to_py__())), steal=True)

    def __ior__(self, other):
        return pyobj(pyobj.exc_wrap(PyNumber_InPlaceOr(self.p, other.__to_py__())), steal=True)

    def __int__(self):
        o = pyobj.exc_wrap(PyNumber_Long(self.p))
        x = int.__from_py__(o)
        pyobj.decref(o)
        return x

    def __float__(self):
        o = pyobj.exc_wrap(PyNumber_Float(self.p))
        x = float.__from_py__(o)
        pyobj.decref(o)
        return x

    def __index__(self):
        o = pyobj.exc_wrap(PyNumber_Index(self.p))
        x = int.__from_py__(o)
        pyobj.decref(o)
        return x

    def __len__(self) -&gt; int:
        return pyobj.exc_wrap(PyObject_Length(self.p))

    def __length_hint__(self) -&gt; int:
        return pyobj.exc_wrap(PyObject_LengthHint(self.p))

    def __getitem__(self, key):
        return pyobj(pyobj.exc_wrap(PyObject_GetItem(self.p, key.__to_py__())), steal=True)

    def __setitem__(self, key, v):
        pyobj.exc_wrap(PyObject_SetItem(self.p, key.__to_py__(), v.__to_py__()))

    def __delitem__(self, key):
        return pyobj.exc_wrap(PyObject_DelItem(self.p, key.__to_py__()))

    def __lt__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_LT))), steal=True)

    def __le__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_LE))), steal=True)

    def __eq__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_EQ))), steal=True)

    def __ne__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_NE))), steal=True)

    def __gt__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_GT))), steal=True)

    def __ge__(self, other):
        return pyobj(pyobj.exc_wrap(PyObject_RichCompare(self.p, other.__to_py__(), i32(Py_GE))), steal=True)

    def __to_py__(self) -&gt; cobj:
        return self.p

    def __from_py__(p: cobj) -&gt; pyobj:
        return pyobj(p)

    def __str__(self) -&gt; str:
        o = pyobj.exc_wrap(PyObject_Str(self.p))
        return pyobj.exc_wrap(str.__from_py__(o))

    def __repr__(self) -&gt; str:
        o = pyobj.exc_wrap(PyObject_Repr(self.p))
        return pyobj.exc_wrap(str.__from_py__(o))

    def __hash__(self) -&gt; int:
        return pyobj.exc_wrap(PyObject_Hash(self.p))

    def __iter__(self) -&gt; Generator[pyobj]:
        it = PyObject_GetIter(self.p)
        if not it:
            raise TypeError("Python object is not iterable")
        try:
            while i := PyIter_Next(it):
                yield pyobj(pyobj.exc_wrap(i), steal=True)
        finally:
            pyobj.decref(it)
        pyobj.exc_check()

    def to_str(self, errors: str, empty: str = "") -&gt; str:
        return pyobj.to_str(self.p, errors, empty)

    def to_str(p: cobj, errors: str, empty: str = "") -&gt; str:
        obj = PyUnicode_AsEncodedString(p, "utf-8".c_str(), errors.c_str())
        if obj == cobj():
            return empty
        bts = PyBytes_AsString(obj)
        res = str.from_ptr(bts)
        pyobj.decref(obj)
        return res

    def exc_check():
        ptype, pvalue, ptraceback = cobj(), cobj(), cobj()
        PyErr_Fetch(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
        PyErr_NormalizeException(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
        if ptype != cobj():
            py_msg = PyObject_Str(pvalue) if pvalue != cobj() else pvalue
            msg = pyobj.to_str(py_msg, "ignore", "&lt;empty Python message&gt;")

            pyobj.decref(ptype)
            pyobj.decref(ptraceback)
            pyobj.decref(py_msg)

            # pyobj.decref(pvalue)
            raise PyError(msg, pyobj(pvalue))

    def exc_wrap(_retval: T, T: type) -&gt; T:
        pyobj.exc_check()
        return _retval

    def incref(self):
        Py_IncRef(self.p)
        return self

    def incref(ptr: Ptr[byte]):
        Py_IncRef(ptr)

    def decref(self):
        Py_DecRef(self.p)
        return self

    def decref(ptr: Ptr[byte]):
        Py_DecRef(ptr)

    def __call__(self, *args, **kwargs):
        args_py = args.__to_py__()
        kws_py = cobj()
        if staticlen(kwargs) &gt; 0:
            names = iter(kwargs.__dict__())
            kws = {next(names): pyobj(i.__to_py__(), steal=True) for i in kwargs}
            kws_py = kws.__to_py__()
        return pyobj(pyobj.exc_wrap(PyObject_Call(self.p, args_py, kws_py)), steal=True)

    def _tuple_new(length: int):
        return pyobj.exc_wrap(PyTuple_New(length))

    def _tuple_size(p: cobj):
        return pyobj.exc_wrap(PyTuple_Size(p))

    def _tuple_set(p: cobj, idx: int, val: cobj):
        PyTuple_SetItem(p, idx, val)
        pyobj.exc_check()

    def _tuple_get(p: cobj, idx: int) -&gt; cobj:
        return pyobj.exc_wrap(PyTuple_GetItem(p, idx))

    def _import(name: str) -&gt; pyobj:
        ensure_initialized()
        if name in _PY_MODULE_CACHE:
            return _PY_MODULE_CACHE[name]
        m = pyobj(pyobj.exc_wrap(PyImport_ImportModule(name.c_str())), steal=True)
        _PY_MODULE_CACHE[name] = m
        return m

    def _exec(code: str):
        ensure_initialized()
        PyRun_SimpleString(code.c_str())

    def _globals() -&gt; pyobj:
        p = PyEval_GetGlobals()
        if p == cobj():
            Py_IncRef(Py_None)
            return pyobj(Py_None)
        return pyobj(p)

    def _builtins() -&gt; pyobj:
        return pyobj(PyEval_GetBuiltins())

    def _get_module(name: str) -&gt; pyobj:
        p = pyobj(pyobj.exc_wrap(PyImport_AddModule(name.c_str())))
        return p

    def _main_module() -&gt; pyobj:
        return pyobj._get_module("__main__")

    def _repr_mimebundle_(self, bundle=Set[str]()) -&gt; Dict[str, str]:
        fn = pyobj._main_module()._getattr("__codon_repr__")
        assert fn.p != cobj(), "cannot find python.__codon_repr__"
        mime, txt = Tuple[str, str].__from_py__(fn.__call__(self).p)
        return {mime: txt}

    def __bool__(self):
        return bool(pyobj.exc_wrap(PyObject_IsTrue(self.p) == 1))

def _get_identifier(typ: str) -&gt; pyobj:
    t = pyobj._builtins()[typ]
    if t.p == cobj():
        t = pyobj._main_module()[typ]
    return t

def _isinstance(what: pyobj, typ: pyobj) -&gt; bool:
    return bool(pyobj.exc_wrap(PyObject_IsInstance(what.p, typ.p)))

@tuple
class _PyObject_Struct:
    refcnt: int
    pytype: cobj

def _conversion_error(name: Static[str]):
    raise PyError("conversion error: Python object did not have type '" + name + "'")

def _ensure_type(o: cobj, t: cobj, name: Static[str]):
    if Ptr[_PyObject_Struct](o)[0].pytype != t:
        _conversion_error(name)


# Type conversions

@extend
class NoneType:
    def __to_py__(self) -&gt; cobj:
        Py_IncRef(Py_None)
        return Py_None

    def __from_py__(x: cobj) -&gt; None:
        if x != Py_None:
            _conversion_error("NoneType")
        return

@extend
class int:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyLong_FromLong(self))

    def __from_py__(i: cobj) -&gt; int:
        _ensure_type(i, PyLong_Type, "int")
        return PyLong_AsLong(i)

@extend
class float:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyFloat_FromDouble(self))

    def __from_py__(d: cobj) -&gt; float:
        return pyobj.exc_wrap(PyFloat_AsDouble(d))

@extend
class bool:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyBool_FromLong(int(self)))

    def __from_py__(b: cobj) -&gt; bool:
        _ensure_type(b, PyBool_Type, "bool")
        return PyObject_IsTrue(b) != 0

@extend
class byte:
    def __to_py__(self) -&gt; cobj:
        return str.__to_py__(str(__ptr__(self), 1))

    def __from_py__(c: cobj) -&gt; byte:
        return str.__from_py__(c).ptr[0]

@extend
class str:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyUnicode_DecodeFSDefaultAndSize(self.ptr, self.len))

    def __from_py__(s: cobj) -&gt; str:
        return pyobj.exc_wrap(pyobj.to_str(s, "strict"))

@extend
class complex:
    def __to_py__(self) -&gt; cobj:
        return pyobj.exc_wrap(PyComplex_FromDoubles(self.real, self.imag))

    def __from_py__(c: cobj) -&gt; complex:
        _ensure_type(c, PyComplex_Type, "complex")
        real = PyComplex_RealAsDouble(c)
        imag = PyComplex_ImagAsDouble(c)
        return complex(real, imag)

@extend
class List:
    def __to_py__(self) -&gt; cobj:
        pylist = PyList_New(len(self))
        pyobj.exc_check()
        idx = 0
        for a in self:
            PyList_SetItem(pylist, idx, a.__to_py__())
            pyobj.exc_check()
            idx += 1
        return pylist

    def __from_py__(v: cobj) -&gt; List[T]:
        _ensure_type(v, PyList_Type, "list")
        n = PyList_Size(v)
        t = List[T](n)
        for i in range(n):
            elem = PyList_GetItem(v, i)
            t.append(T.__from_py__(elem))
        return t

@extend
class Dict:
    def __to_py__(self) -&gt; cobj:
        pydict = PyDict_New()
        pyobj.exc_check()
        for k, v in self.items():
            PyDict_SetItem(pydict, k.__to_py__(), v.__to_py__())
            pyobj.exc_check()
        return pydict

    def __from_py__(d: cobj) -&gt; Dict[K, V]:
        _ensure_type(d, PyDict_Type, "dict")
        b = dict[K, V]()
        pos = 0
        k_ptr = cobj()
        v_ptr = cobj()
        while PyDict_Next(d, __ptr__(pos), __ptr__(k_ptr), __ptr__(v_ptr)):
            k = K.__from_py__(k_ptr)
            v = V.__from_py__(v_ptr)
            b[k] = v
        return b

@extend
class Set:
    def __to_py__(self) -&gt; cobj:
        pyset = PySet_New(cobj())
        pyobj.exc_check()
        for a in self:
            PySet_Add(pyset, a.__to_py__())
            pyobj.exc_check()
        return pyset

    def __from_py__(s: cobj) -&gt; Set[K]:
        _ensure_type(s, PySet_Type, "set")
        b = set[K]()
        s_iter = PyObject_GetIter(s)
        while True:
            k_ptr = pyobj.exc_wrap(PyIter_Next(s_iter))
            if not k_ptr:
                break
            k = K.__from_py__(k_ptr)
            pyobj.decref(k_ptr)
            b.add(k)
        pyobj.decref(s_iter)
        return b

@extend
class DynamicTuple:
    def __to_py__(self) -&gt; cobj:
        pytup = PyTuple_New(len(self))
        i = 0
        for a in self:
            PyTuple_SetItem(pytup, i, a.__to_py__())
            pyobj.exc_check()
            i += 1
        return pytup

    def __from_py__(t: cobj) -&gt; DynamicTuple[T]:
        _ensure_type(t, PyTuple_Type, "tuple")
        n = PyTuple_Size(t)
        p = Ptr[T](n)
        for i in range(n):
            p[i] = T.__from_py__(PyTuple_GetItem(t, i))
        return DynamicTuple(p, n)

@extend
class Slice:
    def __to_py__(self) -&gt; cobj:
        start = self.start
        stop = self.stop
        step = self.step
        start_py = start.__to_py__() if start is not None else cobj()
        stop_py = stop.__to_py__() if stop is not None else cobj()
        step_py = step.__to_py__() if step is not None else cobj()
        return PySlice_New(start_py, stop_py, step_py)

    def __from_py__(s: cobj) -&gt; Slice:
        _ensure_type(s, PySlice_Type, "slice")
        start = 0
        stop = 0
        step = 0
        PySlice_Unpack(s, __ptr__(start), __ptr__(stop), __ptr__(step))
        return Slice(Optional(start), Optional(stop), Optional(step))

@extend
class Optional:
    def __to_py__(self) -&gt; cobj:
        if self is None:
            return Py_None
        else:
            return self.__val__().__to_py__()

    def __from_py__(o: cobj) -&gt; Optional[T]:
        if o == Py_None:
            return Optional[T]()
        else:
            return Optional[T](T.__from_py__(o))


__pyenv__: Optional[pyobj] = None
def _____(): __pyenv__  # make it global!


import internal.static as _S


class _PyWrapError(Static[PyError]):
    def __init__(self, message: str, pytype: pyobj = pyobj(cobj(), steal=True)):
        super().__init__("_PyWrapError", message)
        self.pytype = pytype

    def __init__(self, e: PyError):
        self.__init__("_PyWrapError", e.message, e.pytype)


class _PyWrap:
    def _dispatch_error(F: Static[str]):
        raise TypeError("could not find callable method '" + F + "' for given arguments")

    def _wrap(args, T: type, F: Static[str], map):
        for fn in _S.fn_overloads(T, F):
            a = _PyWrap._args_from_py(fn, args)
            if a is None:
                continue
            if _S.fn_can_call(fn, *a):
                try:
                    return map(fn, a)
                except PyError as e:
                    pass
        _PyWrap._dispatch_error(F)

    def _wrap_unary(obj: cobj, T: type, F: Static[str]) -&gt; cobj:
        return _PyWrap._wrap(
            (obj,), T=T, F=F,
            map=lambda f, a: f(*a).__to_py__()
        )

    def _args_from_py(fn, args):
        def err(fail: Ptr[bool], T: type = NoneType) -&gt; T:
            fail[0] = True
            # auto-return zero-initialized T

        def get_arg(F, p, k, fail: Ptr[bool], i: Static[int]):
            if _S.fn_arg_has_type(F, i):
                return _S.fn_arg_get_type(F, i).__from_py__(p[i]) if p[i] != cobj() else (
                    _S.fn_get_default(F, i) if _S.fn_has_default(F, i)
                    else err(fail, _S.fn_arg_get_type(F, i))
                )
            else:
                return pyobj(p[i], steal=False) if p[i] != cobj() else (
                    _S.fn_get_default(F, i) if _S.fn_has_default(F, i) else err(fail)
                )

        fail = False
        pargs = Ptr[cobj](__ptr__(args).as_byte())
        try:
            ta = tuple(get_arg(fn, pargs, k, __ptr__(fail), i) for i, k in staticenumerate(_S.fn_args(fn)))
            if fail:
                return None
            return _S.fn_wrap_call_args(fn, *ta)
        except PyError:
            return None

    def _reorder_args(fn, self: cobj, args: cobj, kwargs: cobj, M: Static[int] = 1):
        nargs = PyTuple_Size(args)
        nkwargs = PyDict_Size(kwargs) if kwargs != cobj() else 0

        args_ordered = tuple(cobj() for _ in _S.fn_args(fn))
        pargs = Ptr[cobj](__ptr__(args_ordered).as_byte())

        if nargs + nkwargs + M &gt; len(args_ordered):
            return None

        if M:
            pargs[0] = self

        for i in range(nargs):
            pargs[i + M] = PyTuple_GetItem(args, i)

        kwused = 0
        for i, k in staticenumerate(_S.fn_args(fn)):
            if i &lt; nargs + M:
                continue

            p = PyDict_GetItemString(kwargs, k.ptr) if nkwargs else cobj()
            if p != cobj():
                pargs[i] = p
                kwused += 1

        if kwused != nkwargs:
            return None

        return _PyWrap._args_from_py(fn, args_ordered)

    def _reorder_args_fastcall(
        fn, self: cobj, args: Ptr[cobj], nargs: int,
        kwds: Ptr[str], nkw: int, M: Static[int] = 1
    ):
        args_ordered = tuple(cobj() for _ in _S.fn_args(fn))
        pargs = Ptr[cobj](__ptr__(args_ordered).as_byte())

        if nargs + M &gt; len(args_ordered):
            return None

        if M:
            pargs[0] = self

        for i in range(nargs):
            pargs[i + M] = args[i]

        for i in range(nargs, nargs + nkw):
            kw = kwds[i - nargs]
            o = args[i]

            found = False
            j = M
            for i, k in staticenumerate(_S.fn_args(fn)):
                if M and i == 0:
                    continue
                if kw == k:
                    if not pargs[j]:
                        pargs[j] = o
                    else:
                        return None
                    found = True
                    break
                j += 1
            if not found:
                return None

        return _PyWrap._args_from_py(fn, args_ordered)

    def wrap_magic_abs(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__abs__")

    def wrap_magic_pos(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__pos__")

    def wrap_magic_neg(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__neg__")

    def wrap_magic_invert(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__invert__")

    def wrap_magic_int(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__int__")

    def wrap_magic_float(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__float__")

    def wrap_magic_index(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__index__")

    def wrap_magic_repr(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__repr__")

    def wrap_magic_str(obj: cobj, T: type):
        return _PyWrap._wrap_unary(obj, T, "__str__")

    def _wrap_binary(obj: cobj, obj2: cobj, T: type, F: Static[str]) -&gt; cobj:
        return _PyWrap._wrap(
            (obj, obj2), T=T, F=F,
            map=lambda f, a: f(*a).__to_py__()
        )

    def wrap_magic_add(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__add__")

    def wrap_magic_radd(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__radd__")

    def wrap_magic_iadd(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__iadd__")

    def wrap_magic_sub(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__sub__")

    def wrap_magic_rsub(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rsub__")

    def wrap_magic_isub(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__isub__")

    def wrap_magic_mul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__mul__")

    def wrap_magic_rmul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rmul__")

    def wrap_magic_imul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__imul__")

    def wrap_magic_mod(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__mod__")

    def wrap_magic_rmod(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rmod__")

    def wrap_magic_imod(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__imod__")

    def wrap_magic_divmod(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__divmod__")

    def wrap_magic_rdivmod(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rdivmod__")

    def wrap_magic_lshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__lshift__")

    def wrap_magic_rlshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rlshift__")

    def wrap_magic_ilshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ilshift__")

    def wrap_magic_rshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rshift__")

    def wrap_magic_rrshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rrshift__")

    def wrap_magic_irshift(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__irshift__")

    def wrap_magic_and(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__and__")

    def wrap_magic_rand(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rand__")

    def wrap_magic_iand(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__iand__")

    def wrap_magic_xor(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__xor__")

    def wrap_magic_rxor(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rxor__")

    def wrap_magic_ixor(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ixor__")

    def wrap_magic_or(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__or__")

    def wrap_magic_ror(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ror__")

    def wrap_magic_ior(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ior__")

    def wrap_magic_floordiv(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__floordiv__")

    def wrap_magic_ifloordiv(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ifloordiv__")

    def wrap_magic_truediv(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__truediv__")

    def wrap_magic_itruediv(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__itruediv__")

    def wrap_magic_matmul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__matmul__")

    def wrap_magic_rmatmul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rmatmul__")

    def wrap_magic_imatmul(obj: cobj, obj2: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__imatmul__")

    def wrap_magic_pow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__pow__")

    def wrap_magic_rpow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__rpow__")

    def wrap_magic_ipow(obj: cobj, obj2: cobj, obj3: cobj, T: type):
        return _PyWrap._wrap_binary(obj, obj2, T, "__ipow__")

    def _wrap_hash(obj: cobj, T: type, F: Static[str]) -&gt; i64:
        return _PyWrap._wrap(
            (obj,), T=T, F=F,
            map=lambda f, a: f(*a)
        )

    def wrap_magic_len(obj: cobj, T: type):
        return _PyWrap._wrap_hash(obj, T, "__len__")

    def wrap_magic_hash(obj: cobj, T: type):
        return _PyWrap._wrap_hash(obj, T, "__hash__")

    def wrap_magic_bool(obj: cobj, T: type) -&gt; i32:
        return _PyWrap._wrap(
            (obj,), T=T, F="__bool__",
            map=lambda f, a: i32(1) if f(*a) else i32(0)
        )

    def wrap_magic_del(obj: cobj, T: type):
        _PyWrap._wrap(
            (obj,), T=T, F="__del__",
            map=lambda f, a: f(*a)
        )

    def wrap_magic_contains(obj: cobj, arg: cobj, T: type) -&gt; i32:
        return _PyWrap._wrap(
            (obj, arg,), T=T, F="__contains__",
            map=lambda f, a: i32(1) if f(*a) else i32(0)
        )

    def wrap_magic_init(obj: cobj, args: cobj, kwargs: cobj, T: type) -&gt; i32:
        if isinstance(T, ByRef):
            F: Static[str] = "__init__"
            for fn in _S.fn_overloads(T, F):
                a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=1)
                if a is not None and _S.fn_can_call(fn, *a):
                    fn(*a)
                    return i32(0)
            _PyWrap._dispatch_error(F)
        else:
            F: Static[str] = "__new__"
            for fn in _S.fn_overloads(T, F):
                a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=0)
                if a is not None and _S.fn_can_call(fn, *a):
                    x = fn(*a)
                    p = Ptr[PyObject](obj) + 1
                    Ptr[T](p.as_byte())[0] = x
                    return i32(0)
            _PyWrap._dispatch_error(F)

    def wrap_magic_call(obj: cobj, args: cobj, kwargs: cobj, T: type) -&gt; cobj:
        F: Static[str] = "__call__"
        for fn in _S.fn_overloads(T, F):
            a = _PyWrap._reorder_args(fn, obj, args, kwargs, M=1)
            if a is not None and _S.fn_can_call(fn, *a):
                return fn(*a).__to_py__()
        _PyWrap._dispatch_error(F)

    def _wrap_cmp(obj: cobj, other: cobj, T: type, F: Static[str]) -&gt; cobj:
        return _PyWrap._wrap(
            (obj, other), T=T, F=F,
            map=lambda f, a: f(*a).__to_py__()
        )

    def wrap_magic_lt(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__lt__")

    def wrap_magic_le(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__le__")

    def wrap_magic_eq(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__eq__")

    def wrap_magic_ne(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__ne__")

    def wrap_magic_gt(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__gt__")

    def wrap_magic_ge(obj: cobj, other: cobj, T: type):
        return _PyWrap._wrap_cmp(obj, other, T, "__ge__")

    def wrap_cmp(obj: cobj, other: cobj, op: i32, C: type) -&gt; cobj:
        if hasattr(C, "__lt__") and op == 0i32:
            return _PyWrap.wrap_magic_lt(obj, other, C)
        elif hasattr(C, "__le__") and op == 1i32:
            return _PyWrap.wrap_magic_le(obj, other, C)
        elif hasattr(C, "__eq__") and op == 2i32:
            return _PyWrap.wrap_magic_eq(obj, other, C)
        elif hasattr(C, "__ne__") and op == 3i32:
            return _PyWrap.wrap_magic_ne(obj, other, C)
        elif hasattr(C, "__gt__") and op == 4i32:
            return _PyWrap.wrap_magic_gt(obj, other, C)
        elif hasattr(C, "__ge__") and op == 5i32:
            return _PyWrap.wrap_magic_ge(obj, other, C)
        else:
            Py_IncRef(Py_NotImplemented)
            return Py_NotImplemented

    def wrap_magic_getitem(obj: cobj, idx: cobj, T: type):
        return _PyWrap._wrap(
            (obj, idx), T=T, F="__getitem__",
            map=lambda f, a: f(*a).__to_py__()
        )

    def wrap_magic_setitem(obj: cobj, idx: cobj, val: cobj, T: type) -&gt; i32:
        if val == cobj():
            _PyWrap._wrap(
                (obj, idx), T=T, F="__delitem__",
                map=lambda f, a: f(*a)
            )
        else:
            _PyWrap._wrap(
                (obj, idx, val), T=T, F="__setitem__",
                map=lambda f, a: f(*a)
            )
        return i32(0)

    class IterWrap:
        _gen: cobj
        T: type

        def _init(obj: cobj, T: type) -&gt; cobj:
            return _PyWrap.IterWrap(T.__from_py__(obj)).__to_py__()

        @realize_without_self
        def __init__(self, it: T):
            self._gen = it.__iter__().__raw__()

        def _iter(obj: cobj) -&gt; cobj:
            T  # need separate fn for each instantiation
            p = Ptr[PyObject](obj)
            o = p[0]
            p[0] = PyObject(o.refcnt + 1, o.pytype)
            return obj

        def _iternext(self: cobj) -&gt; cobj:
            pt = _PyWrap.IterWrap[T].__from_py__(self)
            if pt._gen == cobj():
                return cobj()

            gt = type(T().__iter__())(pt._gen)
            if gt.done():
                pt._gen = cobj()
                return cobj()
            else:
                return gt.next().__to_py__()

        def __to_py__(self):
            return _PyWrap.wrap_to_py(self)

        def __from_py__(obj: cobj):
            return _PyWrap.wrap_from_py(obj, _PyWrap.IterWrap[T])

    def wrap_magic_iter(obj: cobj, T: type) -&gt; cobj:
        return _PyWrap.IterWrap._init(obj, T)

    def wrap_multiple(
        obj: cobj, args: Ptr[cobj], nargs: int, _kwds: cobj, T: type, F: Static[str],
        M: Static[int] = 1
    ):
        kwds = Ptr[str]()
        nkw = 0
        if _kwds:
            nkw = PyTuple_Size(_kwds)
            kwds = Ptr[str](nkw)
            for i in range(nkw):
                kwds[i] = str.__from_py__(PyTuple_GetItem(_kwds, i))

        for fn in _S.fn_overloads(T, F):
            a = _PyWrap._reorder_args_fastcall(fn, obj, args, nargs, kwds, nkw, M)
            if a is not None and _S.fn_can_call(fn, *a):
                return fn(*a).__to_py__()

        _PyWrap._dispatch_error(F)

    def wrap_get(obj: cobj, closure: cobj, T: type, S: Static[str]):
        return getattr(T.__from_py__(obj), S).__to_py__()

    def wrap_set(obj: cobj, what: cobj, closure: cobj, T: type, S: Static[str]) -&gt; i32:
        t = T.__from_py__(obj)
        val = type(getattr(t, S)).__from_py__(what)
        setattr(t, S, val)
        return i32(0)

    def py_type(T: type) -&gt; cobj:
        return cobj()

    def wrap_to_py(o) -&gt; cobj:
        O = type(o)
        P = PyWrapper[O]
        sz = sizeof(P)
        pytype = _PyWrap.py_type(O)
        mem = alloc_atomic_uncollectable(sz) if atomic(O) else alloc_uncollectable(sz)
        obj = Ptr[P](mem.as_byte())
        obj[0] = PyWrapper(PyObject(1, pytype), o)
        return obj.as_byte()

    def wrap_from_py(o: cobj, T: type) -&gt; T:
        obj = Ptr[PyWrapper[T]](o)[0]
        pytype = _PyWrap.py_type(T)
        if obj.head.pytype != pytype:
            _conversion_error(T.__name__)
        return obj.data
</t>
<t tx="ekr.20230509083243.127">  PipelineFlow::Stage clone(const PipelineFlow::Stage &amp;other) {
    std::vector&lt;Value *&gt; args;
    for (const auto *a : other)
      args.push_back(clone(a));
    return {clone(other.getCallee()), std::move(args), other.isGenerator(),
            other.isParallel()};
  }

private:
</t>
<t tx="ekr.20230509083243.1270">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from algorithms.pdqsort import pdq_sort_inplace
from algorithms.insertionsort import insertion_sort_inplace
from algorithms.heapsort import heap_sort_inplace
from algorithms.qsort import qsort_inplace
from algorithms.timsort import tim_sort_inplace

def sorted(
    v: Generator[T],
    key=Optional[int](),
    reverse: bool = False,
    algorithm: Static[str] = "auto",
    T: type,
) -&gt; List[T]:
    """
    Return a sorted list of the elements in v
    """
    newlist = [a for a in v]
    if not isinstance(key, Optional):
        newlist.sort(key, reverse, algorithm)
    else:
        newlist.sort(reverse=reverse, algorithm=algorithm)
    return newlist

def _is_pdq_compatible(x):
    if (isinstance(x, int) or
        isinstance(x, float) or
        isinstance(x, bool) or
        isinstance(x, byte) or
        isinstance(x, str) or
        isinstance(x, Int) or
        isinstance(x, UInt)):
        return True
    elif isinstance(x, Tuple):
        for a in x:
            if not _is_pdq_compatible(a):
                return False
        return True
    else:
        return False

def _sort_list(
    self: List[T], key: Callable[[T], S], algorithm: Static[str], T: type, S: type
):
    if algorithm == "tim" or algorithm == "auto":
        tim_sort_inplace(self, key)
    elif algorithm == "pdq":
        pdq_sort_inplace(self, key)
    elif algorithm == "insertion":
        insertion_sort_inplace(self, key)
    elif algorithm == "heap":
        heap_sort_inplace(self, key)
    elif algorithm == "quick":
        qsort_inplace(self, key)
    else:
        compile_error("invalid sort algorithm")

@extend
class List:
    def sort(
        self,
        key=Optional[int](),
        reverse: bool = False,
        algorithm: Static[str] = "auto",
    ):
        if isinstance(key, Optional):
            if algorithm == "auto":
                # Python uses Timsort in all cases, but if we
                # know stability does not matter (i.e. sorting
                # primitive type with no key), we will use
                # faster PDQ instead. PDQ is ~50% faster than
                # Timsort for sorting 1B 64-bit ints.
                if self:
                    if _is_pdq_compatible(self[0]):
                        pdq_sort_inplace(self, lambda x: x)
                    else:
                        tim_sort_inplace(self, lambda x: x)
            else:
                _sort_list(self, lambda x: x, algorithm)
        else:
            _sort_list(self, key, algorithm)
        if reverse:
            self.reverse()
</t>
<t tx="ekr.20230509083243.1271">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Methods for static reflection. Implemented within call.cpp and/or loops.cpp.
# !! Not intended for public use !!

def fn_overloads(T: type, F: Static[str]):
    pass

def fn_args(F):  # function: (i, name)
    pass

def fn_arg_has_type(F, i: Static[int]):
    pass

def fn_arg_get_type(F, i: Static[int]):
    pass

def fn_can_call(F, *args, **kwargs):
    pass

def fn_wrap_call_args(F, *args, **kwargs):
    pass

def fn_has_default(F, i: Static[int]):
    pass

def fn_get_default(F, i: Static[int]):
    pass

def class_args(T: type):
    pass

@no_type_wrap
def static_print(*args):
    pass
</t>
<t tx="ekr.20230509083243.1272">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

_MAX: Static[int] = 0x7FFFFFFFFFFFFFFF

@extend
class str:
    # Magic methods

    def __hash__(self) -&gt; int:
        h = 0
        p, n = self.ptr, self.len
        i = 0
        while i &lt; n:
            h = 31 * h + int(p[i])
            i += 1
        return h

    def __lt__(self, other: str) -&gt; bool:
        return self._cmp(other) &lt; 0

    def __le__(self, other: str) -&gt; bool:
        return self._cmp(other) &lt;= 0

    def __gt__(self, other: str) -&gt; bool:
        return self._cmp(other) &gt; 0

    def __ge__(self, other: str) -&gt; bool:
        return self._cmp(other) &gt;= 0

    def __repr__(self) -&gt; str:
        v = _strbuf(len(self) + 2)

        q, qe = "'", "\\'"
        found_single = False
        found_double = False
        for c in self:
            if c == "'":
                found_single = True
            elif c == '"':
                found_double = True

        if found_single and not found_double:
            q, qe = '"', '\\"'

        v.append(q)
        for c in self:
            d = c
            if c == "\n":
                d = "\\n"
            elif c == "\r":
                d = "\\r"
            elif c == "\t":
                d = "\\t"
            elif c == "\\":
                d = "\\\\"
            elif c == q:
                d = qe
            else:
                b = int(c.ptr[0])
                if not (32 &lt;= b &lt;= 126):
                    h = "0123456789abcdef"
                    v.append("\\x")
                    v.append(h[b // 16])
                    v.append(h[b % 16])
                    d = ""
            if d:
                v.append(d)
        v.append(q)
        return v.__str__()

    def __getitem__(self, idx: int) -&gt; str:
        if idx &lt; 0:
            idx += len(self)
        if not (0 &lt;= idx &lt; len(self)):
            raise IndexError("string index out of range")
        return str(self.ptr + idx, 1)

    def __getitem__(self, s: Slice) -&gt; str:
        if s.start is None and s.stop is None and s.step is None:
            return self.__copy__()
        elif s.step is None:
            start, stop, step, length = s.adjust_indices(len(self))
            return str(self.ptr + start, length)
        else:
            start, stop, step, length = s.adjust_indices(len(self))
            return self._make_from_range(start, stop, step, length)

    def _make_from_range(self, start: int, stop: int, step: int, length: int) -&gt; str:
        p = Ptr[byte](length)
        j = 0
        for i in range(start, stop, step):
            p[j] = self.ptr[i]
            j += 1
        return str(p, length)

    def __iter__(self) -&gt; Generator[str]:
        i = 0
        n = len(self)
        while i &lt; n:
            yield str(self.ptr + i, 1)
            i += 1

    def __reversed__(self) -&gt; Generator[str]:
        i = len(self) - 1
        while i &gt;= 0:
            yield str(self.ptr + i, 1)
            i -= 1

    def __mul__(self, x: int) -&gt; str:
        total = x * self.len
        p = Ptr[byte](total)
        n = 0
        for _ in range(x):
            str.memcpy(p + n, self.ptr, self.len)
            n += self.len
        return str(p, total)

    def _cmp(self, other: str) -&gt; int:
        n = min(self.len, other.len)
        i = 0
        while i &lt; n:
            c1 = self.ptr[i]
            c2 = other.ptr[i]
            if c1 != c2:
                return int(c1) - int(c2)
            i += 1
        return self.len - other.len

import algorithms.strings as algorithms

@extend
class str:
    def __contains__(self, pattern: str) -&gt; bool:
        return self.find(pattern) &gt;= 0

    # Helper methods

    def _isdigit(a: byte) -&gt; bool:
        return _C.isdigit(i32(int(a))) != i32(0)

    def _isspace(a: byte) -&gt; bool:
        return _C.isspace(i32(int(a))) != i32(0)

    def _isupper(a: byte) -&gt; bool:
        return _C.isupper(i32(int(a))) != i32(0)

    def _islower(a: byte) -&gt; bool:
        return _C.islower(i32(int(a))) != i32(0)

    def _isalpha(a: byte) -&gt; bool:
        return _C.isalpha(i32(int(a))) != i32(0)

    def _isalnum(a: byte) -&gt; bool:
        return _C.isalnum(i32(int(a))) != i32(0)

    def _toupper(a: byte) -&gt; byte:
        return byte(int(_C.toupper(i32(int(a)))))

    def _tolower(a: byte) -&gt; byte:
        return byte(int(_C.tolower(i32(int(a)))))

    def _slice(self, i: int, j: int) -&gt; str:
        return str(self.ptr + i, j - i)

    def _at(self, i: int) -&gt; str:
        return str(self.ptr + i, 1)

    def join(self, l: Generator[str]) -&gt; str:
        buf = _strbuf()
        if len(self) == 0:
            for a in l:
                buf.append(a)
        else:
            first = True
            for a in l:
                if first:
                    first = False
                else:
                    buf.append(self)
                buf.append(a)
        return buf.__str__()

    def join(self, l: List[str]) -&gt; str:
        if len(l) == 0:
            return ""
        if len(l) == 1:
            return l[0]
        if len(self) == 0:
            return str.cat(l)

        # compute length
        n = 0
        i = 0
        while i &lt; len(l):
            n += len(l[i])
            if i &lt; len(l) - 1:
                n += len(self)
            i += 1

        # copy to new buffer
        p = Ptr[byte](n)
        r = 0
        i = 0
        while i &lt; len(l):
            str.memcpy(p + r, l[i].ptr, len(l[i]))
            r += len(l[i])
            if i &lt; len(l) - 1:
                str.memcpy(p + r, self.ptr, len(self))
                r += len(self)
            i += 1

        return str(p, n)

    def isdigit(self) -&gt; bool:
        """
        str.isdigit() -&gt; bool

        Return True if all characters in str are digits
        and there is at least one character in str, False otherwise.
        """
        if len(self) == 0:
            return False

        for i in range(len(self)):
            if not str._isdigit(self.ptr[i]):
                return False
        return True

    def islower(self) -&gt; bool:
        """
        str.islower() -&gt; bool

        Return True if all cased characters in str are lowercase and there is
        at least one cased character in str, False otherwise.
        """
        cased = False

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return str._islower(self.ptr[0])

        for i in range(len(self)):
            if str._isupper(self.ptr[i]):
                return False
            elif not cased and str._islower(self.ptr[i]):
                cased = True
        return cased

    def isupper(self) -&gt; bool:
        """
        str.isupper() -&gt; bool

        Return True if all cased characters in str are uppercase and there is
        at least one cased character in str, False otherwise.
        """
        cased = False

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return str._isupper(self.ptr[0])

        for i in range(len(self)):
            if str._islower(self.ptr[i]):
                return False
            elif not cased and str._isupper(self.ptr[i]):
                cased = True
        return cased

    def isalnum(self) -&gt; bool:
        """
        str.isalnum() -&gt; bool

        Return True if all characters in str are alphanumeric
        and there is at least one character in str, False otherwise.
        """
        if len(self) == 0:
            return False

        for i in range(len(self)):
            if not str._isalnum(self.ptr[i]):
                return False
        return True

    def isalpha(self) -&gt; bool:
        """
        str.isalpha() -&gt; bool

        Return True if all characters in str are alphabetic
        and there is at least one character in str, False otherwise.
        """
        if len(self) == 0:
            return False

        for i in range(len(self)):
            if not str._isalpha(self.ptr[i]):
                return False
        return True

    def isspace(self) -&gt; bool:
        """
        str.isspace() -&gt; bool

        Return True if all characters in str are whitespace
        and there is at least one character in str, False otherwise.
        """
        if len(self) == 0:
            return False

        for i in range(len(self)):
            if not str._isspace(self.ptr[i]):
                return False
        return True

    def istitle(self) -&gt; bool:
        """
        str.istitle() -&gt; bool

        Return True if str is a titlecased string and there is at least one
        character in str, i.e. uppercase characters may only follow uncased
        characters and lowercase characters only cased ones. Return False
        otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return str._isupper(self.ptr[0])

        cased = False
        prev_is_cased = False
        for i in range(len(self)):
            if str._isupper(self.ptr[i]):
                if prev_is_cased:
                    return False
                prev_is_cased = True
                cased = True
            elif str._islower(self.ptr[i]):
                if not prev_is_cased:
                    return False
                prev_is_cased = True
                cased = True
            else:
                prev_is_cased = False
        return cased

    def capitalize(self) -&gt; str:
        """
        str.capitalize() -&gt; copy of str

        Return a copy of str with only its first character capitalized (ASCII)
        and the rest lower-cased.
        """
        n = len(self)
        if n &gt; 0:
            p = Ptr[byte](n)
            p[0] = str._toupper(self.ptr[0])
            for i in range(1, n):
                p[i] = str._tolower(self.ptr[i])
            return str(p, n)
        return ""

    def isdecimal(self) -&gt; bool:
        """
        str.isdecimal() -&gt; bool

        Return True if str is a decimal string, False otherwise.
        str is a decimal string if all characters in str are decimal and
        there is at least one character in str.
        """
        if len(self) == 0:
            return False

        for i in range(len(self)):
            # test ascii values 48-57 == 0-9
            if not (48 &lt;= int(self.ptr[i]) &lt;= 57):
                return False
        return True

    def lower(self) -&gt; str:
        """
        str.lower() -&gt; copy of str

        Return a copy of str with all ASCII characters converted to lowercase.
        """
        # Empty string
        n = len(self)
        if n == 0:
            return ""
        p = Ptr[byte](n)
        for i in range(n):
            p[i] = str._tolower(self.ptr[i])
        return str(p, n)

    def upper(self) -&gt; str:
        """
        str.upper() -&gt; copy of str

        Return a copy of str with all ASCII characters converted to uppercase.
        """
        # Empty string
        n = len(self)
        if n == 0:
            return ""
        p = Ptr[byte](n)
        for i in range(n):
            p[i] = str._toupper(self.ptr[i])
        return str(p, n)

    def isascii(self) -&gt; bool:
        """
        str.isascii() -&gt; bool

        Return True if str is empty or all characters in str are ASCII,
        False otherwise.
        """
        for i in range(len(self)):
            if int(self.ptr[i]) &gt;= 128:
                return False
        return True

    def casefold(self) -&gt; str:
        """
        str.casefold() -&gt; copy of str

        Return a version of the string suitable for caseless comparisons.

        Unlike Python, casefold() deals with just ASCII characters.
        """
        return self.lower()

    def swapcase(self) -&gt; str:
        """
        str.swapcase() -&gt; copy of str

        Return a copy of str with uppercase ASCII characters converted
        to lowercase ASCII and vice versa.
        """
        # Empty string
        n = len(self)
        if n == 0:
            return ""
        p = Ptr[byte](n)
        for i in range(n):
            if str._islower(self.ptr[i]):
                p[i] = str._toupper(self.ptr[i])
            elif str._isupper(self.ptr[i]):
                p[i] = str._tolower(self.ptr[i])
            else:
                p[i] = self.ptr[i]
        return str(p, n)

    def title(self) -&gt; str:
        """
        str.title() -&gt; copy of str

        Return a titlecased version of str, i.e. ASCII words start with uppercase
        characters, all remaining cased characters have lowercase.
        """
        prev_is_cased = False

        n = len(self)
        if n == 0:
            return ""

        p = Ptr[byte](n)
        for i in range(n):
            if str._islower(self.ptr[i]):
                # lowercase to uppercase
                if not prev_is_cased:
                    p[i] = str._toupper(self.ptr[i])
                else:
                    p[i] = self.ptr[i]
                prev_is_cased = True
            elif str._isupper(self.ptr[i]):
                # uppercase to lowercase
                if prev_is_cased:
                    p[i] = str._tolower(self.ptr[i])
                else:
                    p[i] = self.ptr[i]
                prev_is_cased = True
            else:
                p[i] = self.ptr[i]
                prev_is_cased = False
        return str(p, n)

    def isnumeric(self) -&gt; bool:
        """
        str.isdecimal() -&gt; bool

        Return True if the string is a numeric string, False otherwise.
        A string is numeric if all characters in the string are numeric
        and there is at least one character in the string.

        Unlike Python, isnumeric() deals with just ASCII characters.
        """
        return self.isdecimal()

    def _build(*args):
        total = 0
        for t in args:
            if isinstance(t, str):
                total += len(t)
            else:
                total += len(t[0]) * t[1]
        p = Ptr[byte](total)
        i = 0

        for t in args:
            if isinstance(t, str):
                str.memcpy(p + i, t.ptr, t.len)
                i += t.len
            else:
                s, n = t
                for _ in range(n):
                    str.memcpy(p + i, s.ptr, s.len)
                    i += s.len

        return str(p, total)

    def ljust(self, width: int, fillchar: str = " ") -&gt; str:
        """
        ljust(width[, fillchar]) -&gt; string

        Return a left-justified string of length width.

        Padding is done using the specified fill character (default is a space).
        """
        if len(fillchar) != 1:
            raise ValueError("The fill character must be exactly one character long")
        if width &lt;= len(self):
            return self
        return str._build(self, (fillchar, width - len(self)))

    def rjust(self, width: int, fillchar: str = " ") -&gt; str:
        """
        rjust(width[, fillchar]) -&gt; string

        Return a right-justified string of length width.

        Padding is done using the specified fill character (default is a space).
        """
        if len(fillchar) != 1:
            raise ValueError("The fill character must be exactly one character long")
        if width &lt;= len(self):
            return self
        return str._build((fillchar, width - len(self)), self)

    def center(self, width: int, fillchar: str = " ") -&gt; str:
        """
        str.center(width[, fillchar]) -&gt; string

        Return str centered in a string of length width. Padding is
        done using the specified fill character (default is a space)
        """
        if len(fillchar) != 1:
            raise ValueError("The fill character must be exactly one character long")
        if width &lt;= len(self):
            return self

        pad = width - len(self)
        left_pad = pad // 2
        right_pad = width - len(self) - left_pad
        return str._build((fillchar, left_pad), self, (fillchar, right_pad))

    def zfill(self, width: int) -&gt; str:
        """
        str.zfill(width) -&gt; string

        Pad a numeric string str with zeros on the left, to fill a field
        of the specified width.  The string str is never truncated.
        """
        if len(self) &gt;= width:
            return self

        plus = byte(43)   # +
        minus = byte(45)  # -
        zero = byte(48)   # 0

        zf = self.rjust(width, '0')
        fill = width - len(self)
        p = zf.ptr

        if p[fill] == plus or p[fill] == minus:
            p[0] = p[fill]
            p[fill] = zero

        return zf

    def count(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
        """
        str.count(sub[, start[, end]]) -&gt; int

        Return the number of occurrences of subsection sub in
        bytes str[start:end].  Optional arguments start and end are interpreted
        as in slice notation.
        """
        end: int = end if end is not None else len(self)
        start, end = self._correct_indices(start, end)
        if end - start &lt; len(sub):
            return 0
        return algorithms.count(self._slice(start, end), sub)

    def find(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
        """
        str.find(sub [,start [,end]]) -&gt; int

        Return the lowest index in str where substring sub is found,
        such that sub is contained within str[start:end].  Optional
        arguments start and end are interpreted as in slice notation.

        Return -1 on failure.
        """
        end: int = end if end is not None else len(self)
        start, end = self._correct_indices(start, end)
        if end - start &lt; len(sub):
            return -1
        pos = algorithms.find(self._slice(start, end), sub)
        return pos if pos &lt; 0 else pos + start

    def rfind(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
        """
        str.rfind(sub [,start [,end]]) -&gt; int

        Return the highest index in str where substring sub is found,
        such that sub is contained within str[start:end].  Optional
        arguments start and end are interpreted as in slice notation.

        Return -1 on failure.
        """
        end: int = end if end is not None else len(self)
        start, end = self._correct_indices(start, end)
        if end - start &lt; len(sub):
            return -1
        pos = algorithms.rfind(self._slice(start, end), sub)
        return pos if pos &lt; 0 else pos + start

    def isidentifier(self) -&gt; bool:
        """
        str.isidentifier() -&gt; bool

        Return True if the string is a valid identifier, False otherwise.
        Unlike Python, isidentifier() deals with just ASCII characters.
        """
        # empty string
        if len(self) == 0:
            return False

        # is not a letter or _
        first = self._at(0)
        if not first.isalpha():
            if first != "_":
                return False

        if first.isalpha() or first == "_":
            for i in range(1, len(self)):
                ith = self._at(i)
                if not ith.isalpha():
                    if not ith.isdecimal():
                        if ith != "_":
                            return False

        return True

    def isprintable(self) -&gt; bool:
        """
        str.isprintable() -&gt; bool

        Return True if the string is printable or empty, False otherwise.
        Unlike Python, isprintable() deals with just ASCII characters.
        """
        for i in range(len(self)):
            if not (31 &lt; int(self.ptr[i]) &lt; 128):
                return False
        return True

    def _has_char(self, chars: str) -&gt; bool:
        s = self._at(0)
        if chars:
            for c in chars:
                if s == c:
                    return True
            return False
        else:
            return s.isspace()

    def lstrip(self, chars: str = "") -&gt; str:
        """
        str.lstrip([chars]) -&gt; string

        Return a copy of the string str with leading whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, lstrip() deals with just ASCII characters.
        """
        i = 0
        while i &lt; len(self) and self._at(i)._has_char(chars):
            i += 1
        return self._slice(i, len(self))

    def rstrip(self, chars: str = "") -&gt; str:
        """
        str.rstrip([chars]) -&gt; string

        Return a copy of the string str with trailing whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, rstrip() deals with just ASCII characters.
        """
        i = len(self) - 1
        while i &gt;= 0 and self._at(i)._has_char(chars):
            i -= 1
        return self._slice(0, i + 1)

    def strip(self, chars: str = "") -&gt; str:
        """
        str.strip([chars]) -&gt; string

        Return a copy of the string str with leading and trailing
        whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, strip() deals with just ASCII characters.
        """
        return self.lstrip(chars).rstrip(chars)

    def partition(self, sep: str) -&gt; Tuple[str, str, str]:
        """
        Search for the separator sep in str, and return the part before it,
        the separator itself, and the part after it.  If the separator is not
        found, return str and two empty strings.
        """
        if not sep:
            raise ValueError("empty separator")
        pos = algorithms.find(self, sep)
        if pos &lt; 0:
            return self, "", ""
        return self._slice(0, pos), sep, self._slice(pos + len(sep), len(self))

    def rpartition(self, sep: str) -&gt; Tuple[str, str, str]: # XXX
        """
        Search for the separator sep in str, starting at the end of str, and return
        the part before it, the separator itself, and the part after it.  If the
        separator is not found, return two empty strings and str.
        """
        if not sep:
            raise ValueError("empty separator")
        pos = algorithms.rfind(self, sep)
        if pos &lt; 0:
            return "", "", self
        return self._slice(0, pos), sep, self._slice(pos + len(sep), len(self))

    def split(self, sep: Optional[str] = None, maxsplit: int = -1) -&gt; List[str]:
        """
        str.split([sep [,maxsplit]]) -&gt; list of strings

        Return a list of the words in the string str, using sep as the
        delimiter string.  If maxsplit is given, at most maxsplit
        splits are done. If sep is not specified, any
        whitespace string is a separator and empty strings are removed
        from the result.
        """
        if sep is None:
            return self._split_whitespace(
                maxsplit if maxsplit &gt;= 0 else _MAX
            )
        sep: str = sep

        if len(sep) == 0:
            raise ValueError("empty separator")

        # special case for length-1 pattern
        if len(sep) == 1:
            return self._split_char(sep.ptr[0], maxsplit if maxsplit &gt;= 0 else _MAX)

        MAX_PREALLOC = 12
        maxsplit = maxsplit if maxsplit &gt;= 0 else _MAX
        prealloc_size = MAX_PREALLOC if maxsplit &gt;= MAX_PREALLOC else maxsplit + 1
        v = List[str](capacity=prealloc_size)
        i = 0
        j = 0
        n = len(self)

        while maxsplit &gt; 0:
            maxsplit -= 1
            pos = algorithms.find(self._slice(i, n), sep)
            if pos &lt; 0:
                break
            j = i + pos
            v.append(self._slice(i, j))
            i = j + len(sep)

        v.append(self._slice(i, n))
        return v

    def rsplit(self, sep: Optional[str] = None, maxsplit: int = -1) -&gt; List[str]:
        """
        str.rsplit([sep [,maxsplit]]) -&gt; list of strings

        Return a list of the words in the string str, using sep as the
        delimiter string, starting at the end of the string and working
        to the front.  If maxsplit is given, at most maxsplit splits are
        done. If sep is not specified, any whitespace string
        is a separator.
        """
        if sep is None:
            return self._rsplit_whitespace(
                maxsplit if maxsplit &gt;= 0 else _MAX
            )
        sep: str = sep

        if len(sep) == 0:
            raise ValueError("empty separator")

        # special case for length-1 pattern
        if len(sep) == 1:
            return self._rsplit_char(sep.ptr[0], maxsplit if maxsplit &gt;= 0 else _MAX)

        MAX_PREALLOC = 12
        maxsplit = maxsplit if maxsplit &gt;= 0 else _MAX
        prealloc_size = MAX_PREALLOC if maxsplit &gt;= MAX_PREALLOC else maxsplit + 1
        v = List[str](capacity=prealloc_size)
        i = 0
        j = len(self)
        n = j

        while maxsplit &gt; 0:
            maxsplit -= 1
            pos = algorithms.rfind(self._slice(0, j), sep)
            if pos &lt; 0:
                break
            v.append(self._slice(pos + len(sep), j))
            j = pos

        v.append(self._slice(0, j))
        v.reverse()
        return v

    def splitlines(self, keepends: bool = False) -&gt; List[str]:
        """
        str.splitlines([keepends]) -&gt; list of strings

        Return a list of the lines in str, breaking at line boundaries.
        Line breaks are not included in the resulting list unless keepends
        is given and true.
        """
        v = []
        i = 0
        j = 0
        n = len(self)

        break_r = byte(13)  # \r
        break_n = byte(10)  # \n

        while i &lt; n:
            while i &lt; n and not (self.ptr[i] == break_r or self.ptr[i] == break_n):
                i += 1

            eol = i
            if i &lt; n:
                if self.ptr[i] == break_r and i + 1 &lt; n and self.ptr[i + 1] == break_n:
                    i += 2
                else:
                    i += 1
                if keepends:
                    eol = i

            if j == 0 and eol == n:
                v.append(self)
                break

            v.append(self._slice(j, eol))
            j = i

        return v

    def startswith(
        self, prefix: str, start: int = 0, end: Optional[int] = None
    ) -&gt; bool:
        """
        str.startswith(prefix[, start[, end]]) -&gt; bool

        Return True if str starts with the specified prefix, False otherwise.
        With optional start, test str beginning at that position.
        With optional end, stop comparing str at that position.
        """
        end: int = end if end is not None else len(self)
        if end &lt; 0:
            end += len(self)
        elif start &lt; 0:
            start += len(self)

        # length prefix is longer than range of string being compared to
        if start + len(prefix) &gt; len(self):
            return False

        # length of prefix is longer than range of string[start:end]
        if end - start &lt; len(prefix):
            return False

        # prefix is an empty string
        if not prefix:
            return True

        return prefix == self._slice(start, start + len(prefix))

    def endswith(self, suffix: str, start: int = 0, end: Optional[int] = None) -&gt; bool:
        """
        str.endswith(prefix[, start[, end]]) -&gt; bool

        Return True if str ends with the specified suffix, False otherwise.
        With optional start, test str beginning at that position.
        With optional end, stop comparing str at that position.
        """
        end: int = end if end is not None else len(self)
        if end &lt; 0:
            end += len(self)
        elif start &lt; 0:
            start += len(self)
        if end &gt; len(self):
            end = len(self)

        # length prefix is longer than range of string being compared to
        if end - start &lt; len(suffix) or start &gt; len(self):
            return False

        if end - len(suffix) &gt; start:
            start = end - len(suffix)

        # length of prefix is longer than range of string[start:end]
        if end - start &lt; len(suffix):
            return False

        # prefix is an empty string
        if not suffix:
            return True

        return suffix == self._slice(start, start + len(suffix))

    def index(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
        """
        str.index(sub [,start [,end]]) -&gt; int

        Like str.find() but raise ValueError when the substring is not found.
        """
        i = self.find(sub, start, end)
        if i == -1:
            raise ValueError("substring not found")
        else:
            return i

    def rindex(self, sub: str, start: int = 0, end: Optional[int] = None) -&gt; int:
        """
        str.index(sub [,start [,end]]) -&gt; int

        Like str.find() but raise ValueError when the substring is not found.
        """
        i = self.rfind(sub, start, end)
        if i == -1:
            raise ValueError("substring not found")
        else:
            return i

    def replace(self, old: str, new: str, maxcount: int = -1) -&gt; str:
        """
        str.replace(old, new[, count]) -&gt; string

        Return a copy of string str with all occurrences of substring
        old replaced by new.  If the optional argument maxcount is
        given, only the first maxcount occurrences are replaced.
        """
        return self._replace(old, new, maxcount)

    def expandtabs(self, tabsize: int = 8) -&gt; str:
        """
        str.expandtabs([tabsize]) -&gt; string

        Return a copy of str where all tab characters are expanded using spaces.
        If tabsize is not given, a tab size of 8 characters is assumed.
        """
        i = 0
        j = 0
        p = self.ptr
        e = p + len(self)

        break_r = byte(13)  # \r
        break_n = byte(10)  # \n
        tab = byte(9)       # \t
        space = byte(32)    # ' '

        def overflow():
            raise OverflowError("result too long")

        while p &lt; e:
            if p[0] == tab:
                if tabsize &gt; 0:
                    incr = tabsize - (j % tabsize)
                    if j &gt; _MAX - incr:
                        overflow()
                    j += incr
            else:
                if j &gt; _MAX - 1:
                    overflow()
                j += 1
                if p[0] == break_n or p[0] == break_r:
                    if i &gt; _MAX - j:
                        overflow()
                    i += j
                    j = 0
            p += 1

        if i &gt; _MAX - j:
            overflow()

        u_len = i + j
        u = Ptr[byte](u_len)
        j = 0
        q = u
        p = self.ptr

        while p &lt; e:
            if p[0] == tab:
                if tabsize &gt; 0:
                    i = tabsize - (j % tabsize)
                    j += i
                    while True:
                        k = i
                        i -= 1
                        if k == 0:
                            break
                        q[0] = space
                        q += 1
            else:
                j += 1
                q[0] = p[0]
                q += 1
                if p[0] == break_n or p[0] == break_r:
                    j = 0
            p += 1

        return str(u, u_len)

    def translate(self, map) -&gt; str:
        """
        Return a copy with each character mapped by the given translation table.
        """
        n = len(self)
        m = 0

        for i in range(n):
            key = int(self.ptr[i])
            if key in map:
                val = map[key]
                if val is not None:
                    m += len(val)
            else:
                m += 1

        p = Ptr[byte](m)
        q = p

        for i in range(n):
            key = int(self.ptr[i])
            if key in map:
                val = map[key]
                if val is not None:
                    str.memcpy(q, val.ptr, len(val))
                    q += len(val)
            else:
                q[0] = self.ptr[i]
                q += 1

        return str(p, m)


    # Internal helpers

    def _correct_indices(self, start: int, end: int) -&gt; Tuple[int, int]:
        n = len(self)

        if end &gt; n:
            end = n
        elif end &lt; 0:
            end += n
            if end &lt; 0:
                end = 0

        if start &lt; 0:
            start += n
            if start &lt; 0:
                start = 0

        return (start, end)

    def _split_whitespace(self, maxcount: int) -&gt; List[str]:
        PREALLOC_MAX = 12
        l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

        str_len = len(self)
        i = 0
        j = 0
        while maxcount &gt; 0:
            maxcount -= 1
            while i &lt; str_len and str._isspace(self.ptr[i]):
                i += 1
            if i == str_len:
                break
            j = i
            i += 1
            while i &lt; str_len and not str._isspace(self.ptr[i]):
                i += 1
            l.append(self._slice(j, i))

        if i &lt; str_len:
            while i &lt; str_len and str._isspace(self.ptr[i]):
                i += 1
            if i != str_len:
                l.append(self._slice(i, str_len))

        return l

    def _rsplit_whitespace(self, maxcount: int) -&gt; List[str]:
        PREALLOC_MAX = 12
        l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

        str_len = len(self)
        i = str_len - 1
        j = str_len - 1
        while maxcount &gt; 0:
            maxcount -= 1
            while i &gt;= 0 and str._isspace(self.ptr[i]):
                i -= 1
            if i &lt; 0:
                break
            j = i
            i -= 1
            while i &gt;= 0 and not str._isspace(self.ptr[i]):
                i -= 1
            l.append(self._slice(i + 1, j + 1))

        if i &gt;= 0:
            while i &gt;= 0 and str._isspace(self.ptr[i]):
                i -= 1
            if i &gt;= 0:
                l.append(self._slice(0, i + 1))

        l.reverse()
        return l

    def _split_char(self, char: byte, maxcount: int) -&gt; List[str]:
        PREALLOC_MAX = 12
        l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

        str_len = len(self)
        i = 0
        j = 0

        while i &lt; str_len and maxcount &gt; 0:
            if self.ptr[i] == char:
                l.append(self._slice(j, i))
                j = i + 1
                maxcount -= 1
            i += 1

        l.append(self._slice(j, str_len))
        return l

    def _rsplit_char(self, char: byte, maxcount: int) -&gt; List[str]:
        PREALLOC_MAX = 12
        l = List[str](PREALLOC_MAX if maxcount &gt;= PREALLOC_MAX else maxcount + 1)

        str_len = len(self)
        i = str_len - 1
        j = str_len - 1

        while i &gt;= 0 and maxcount &gt; 0:
            if self.ptr[i] == char:
                l.append(self._slice(i + 1, j + 1))
                j = i - 1
                maxcount -= 1
            i -= 1

        l.append(self._slice(0, j + 1))
        l.reverse()
        return l

    def _findchar(self, c: byte):
        return _C.memchr(self.ptr, i32(int(c)), len(self))

    def _countchar(self, c: byte, maxcount: int):
        count = 0
        start = self.ptr
        end = start + len(self)

        while True:
            start = str(start, end - start)._findchar(c)
            if not start:
                break
            count += 1
            if count &gt;= maxcount:
                break
            start += 1
        return count

    def _replace_interleave(self, to: str, maxcount: int):
        self_s = self.ptr
        self_len = len(self)
        to_len = len(to)
        to_s = to.ptr
        count = 0
        i = 0

        if maxcount &lt;= self_len:
            count = maxcount
        else:
            count = self_len + 1

        # assert count &gt; 0
        if to_len &gt; (_MAX - self_len) // count:
            raise OverflowError("replace bytes is too long")

        result_len = count * to_len + self_len
        result_s = Ptr[byte](result_len)
        result_s0 = result_s

        if to_len &gt; 1:
            str.memcpy(result_s, to_s, to_len)
            result_s += to_len
            count -= 1

            while i &lt; count:
                result_s[0] = self_s[0]
                result_s += 1
                self_s += 1
                str.memcpy(result_s, to_s, to_len)
                result_s += to_len
                i += 1
        else:
            result_s[0] = to_s[0]
            result_s += to_len
            count -= 1

            while i &lt; count:
                result_s[0] = self_s[0]
                result_s += 1
                self_s += 1
                result_s[0] = to_s[0]
                result_s += to_len
                i += 1

        str.memcpy(result_s, self_s, self_len - i)
        return str(result_s0, result_len)

    def _replace_delete_single_character(self, from_c: byte, maxcount: int):
        self_len = len(self)
        self_s = self.ptr

        count = self._countchar(from_c, maxcount)
        if count == 0:
            return self

        result_len = self_len - count
        # assert result_len &gt;= 0
        result_s = Ptr[byte](result_len)
        result_s0 = result_s

        start = self_s
        end = self_s + self_len
        while count &gt; 0:
            count -= 1
            nxt = str(start, end - start)._findchar(from_c)
            if not nxt:
                break
            str.memcpy(result_s, start, nxt - start)
            result_s += nxt - start
            start = nxt + 1

        str.memcpy(result_s, start, end - start)
        return str(result_s0, result_len)

    def _replace_delete_substring(self, from_s: str, maxcount: int):
        self_len = len(self)
        self_s = self.ptr
        from_len = len(from_s)

        count = algorithms.count_with_max(self, from_s, maxcount)
        if count == 0:
            return self

        result_len = self_len - (count * from_len)
        # assert result_len &gt;= 0
        result_s = Ptr[byte](result_len)
        result_s0 = result_s

        start = self_s
        end = self_s + self_len
        while count &gt; 0:
            count -= 1
            offset = algorithms.find(str(start, end - start), from_s)
            if offset == -1:
                break
            nxt = start + offset
            str.memcpy(result_s, start, nxt - start)
            result_s += nxt - start
            start = nxt + from_len

        str.memcpy(result_s, start, end - start)
        return str(result_s0, result_len)

    def _replace_single_character_in_place(self, from_c: byte, to_c: byte, maxcount: int):
        self_s = self.ptr
        self_len = len(self)

        nxt = self._findchar(from_c)
        if not nxt:
            return self

        result_s = Ptr[byte](self_len)
        str.memcpy(result_s, self_s, self_len)

        start = result_s + (nxt - self_s)
        start[0] = to_c
        start += 1
        end = result_s + self_len
        maxcount -= 1

        while maxcount &gt; 0:
            maxcount -= 1
            nxt = str(start, end - start)._findchar(from_c)
            if not nxt:
                break
            nxt[0] = to_c
            start = nxt + 1

        return str(result_s, self_len)

    def _replace_substring_in_place(self, from_s: str, to: str, maxcount: int):
        self_s = self.ptr
        self_len = len(self)
        from_len = len(from_s)
        to_s = to.ptr

        offset = algorithms.find(self, from_s)
        if offset == -1:
            return self

        result_s = Ptr[byte](self_len)
        str.memcpy(result_s, self_s, self_len)

        start = result_s + offset
        str.memcpy(start, to_s, from_len)
        start += from_len
        end = result_s + self_len
        maxcount -= 1

        while maxcount &gt; 0:
            maxcount -= 1
            offset = algorithms.find(str(start, end - start), from_s)
            if offset == -1:
                break
            str.memcpy(start + offset, to_s, from_len)
            start += offset + from_len

        return str(result_s, self_len)

    def _replace_single_character(self, from_c: byte, to_s: str, maxcount: int):
        self_s = self.ptr
        self_len = len(self)
        to_len = len(to_s)

        count = self._countchar(from_c, maxcount)
        if count == 0:
            return self

        # assert count &gt; 0
        if to_len - 1 &gt; (_MAX - self_len) // count:
            raise OverflowError("replace bytes is too long")

        result_len = self_len + count * (to_len - 1)
        result_s = Ptr[byte](result_len)
        result_s0 = result_s

        start = self_s
        end = self_s + self_len
        while count &gt; 0:
            count -= 1
            nxt = str(start, end - start)._findchar(from_c)
            if not nxt:
                break

            if nxt == start:
                str.memcpy(result_s, to_s.ptr, to_len)
                result_s += to_len
                start += 1
            else:
                str.memcpy(result_s, start, nxt - start)
                result_s += (nxt - start)
                str.memcpy(result_s, to_s.ptr, to_len)
                result_s += to_len
                start = nxt + 1

        str.memcpy(result_s, start, end - start)
        return str(result_s0, result_len)

    def _replace_substring(self, from_s: str, to_s: str, maxcount: int):
        self_s = self.ptr
        self_len = len(self)
        from_len = len(from_s)
        to_len = len(to_s)

        count = algorithms.count_with_max(self, from_s, maxcount)
        if count == 0:
            return self

        # assert count &gt; 0
        if to_len - from_len &gt; (_MAX - self_len) // count:
            raise OverflowError("replace bytes is too long")

        result_len = self_len + count * (to_len - from_len)
        result_s = Ptr[byte](result_len)
        result_s0 = result_s

        start = self_s
        end = self_s + self_len
        while count &gt; 0:
            count -= 1
            offset = algorithms.find(str(start, end - start), from_s)
            if offset == -1:
                break

            nxt = start + offset
            if nxt == start:
                str.memcpy(result_s, to_s.ptr, to_len)
                result_s += to_len
                start += from_len
            else:
                str.memcpy(result_s, start, nxt - start)
                result_s += (nxt - start)
                str.memcpy(result_s, to_s.ptr, to_len)
                result_s += to_len
                start = nxt + from_len

        str.memcpy(result_s, start, end - start)
        return str(result_s0, result_len)

    def _replace(self, from_s: str, to_s: str, maxcount: int):
        self_len = len(self)
        from_len = len(from_s)
        to_len = len(to_s)

        if self_len &lt; from_len:
            return self

        if maxcount &lt; 0:
            maxcount = _MAX
        elif maxcount == 0:
            return self

        if from_len == 0:
            if to_len == 0:
                return self
            return self._replace_interleave(to_s, maxcount)

        if to_len == 0:
            if from_len == 1:
                return self._replace_delete_single_character(from_s.ptr[0], maxcount)
            return self._replace_delete_substring(from_s, maxcount)

        if from_len == to_len:
            if from_len == 1:
                return self._replace_single_character_in_place(from_s.ptr[0], to_s.ptr[0], maxcount)
            return self._replace_substring_in_place(from_s, to_s, maxcount)

        if from_len == 1:
            return self._replace_single_character(from_s.ptr[0], to_s, maxcount)
        else:
            return self._replace_substring(from_s, to_s, maxcount)
</t>
<t tx="ekr.20230509083243.1273">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Core library

from internal.core import *
from internal.attributes import *
from internal.types.ptr import *
from internal.types.str import *
from internal.types.int import *
from internal.types.bool import *
from internal.types.array import *
from internal.types.error import *
from internal.types.intn import *
from internal.types.float import *
from internal.types.byte import *
from internal.types.generator import *
from internal.types.optional import *
from internal.types.slice import *
from internal.types.range import *
from internal.internal import *
from internal.types.strbuf import strbuf as _strbuf
from internal.types.collections.list import *
import internal.c_stubs as _C
from internal.format import *

def next(g: Generator[T], default: Optional[T] = None, T: type) -&gt; T:
    if g.done():
        if default:
            return unwrap(default)
        else:
            raise StopIteration()
    return g.next()

from C import seq_print_full(str, cobj)

class Set:
    items: List[T]
    T: type

    def __init__(self):
        self.items = []

    def __iter__(self) -&gt; Generator[T]:
        yield from self.items

    def add(self, what: T):
        if what not in self.items:
            self.items.append(what)

    def __repr__(self) -&gt; str:
        s = self.items.__repr__()
        s.ptr[0] = "{".ptr[0]
        s.ptr[s.len - 1] = "}".ptr[0]
        return s

class Dict:
    keys: List[K]
    values: List[V]
    K: type
    V: type

    def __init__(self):
        self.keys = []
        self.values = []

    def __iter__(self) -&gt; Generator[K]:
        yield from self.keys

    def items(self) -&gt; Generator[Tuple[K, V]]:
        for i in range(self.keys.len):
            yield (self.keys[i], self.values[i])

    def __contains__(self, key: K) -&gt; bool:
        return self.keys.index(key) != -1

    def __getitem__(self, key: K) -&gt; V:
        i = self.keys.index(key)
        return self.values[i]

    def __setitem__(self, key: K, val: V):
        i = self.keys.index(key)
        if i != -1:
            self.values[i] = val
        else:
            self.keys.append(key)
            self.values.append(val)

    def __len__(self) -&gt; int:
        return self.keys.len

    def __repr__(self) -&gt; str:
        n = self.__len__()
        if n == 0:
            return "{}"
        else:
            lst = []
            lst.append("{")
            first = True
            for k, v in self.items():
                if not first:
                    lst.append(", ")
                else:
                    first = False
                lst.append(k.__repr__())
                lst.append(": ")
                lst.append(v.__repr__())
            lst.append("}")
            return str.cat(lst)

@extend
class str:
    def __getitem__(self, idx: int) -&gt; str:
        if idx &lt; 0:
            idx += self.len
        if not (0 &lt;= idx &lt; self.len):
            raise IndexError("string index out of range")
        return str(self.ptr + idx, 1)

    def __getitem__(self, s: Slice) -&gt; str:
        if s.start is None and s.stop is None and s.step is None:
            return self.__copy__()
        elif s.step is None:
            start, stop, step, length = s.adjust_indices(self.len)
            return str(self.ptr + start, length)
        else:
            raise ValueError("nope")

    def strip(self):
        if self.__len__() == 0:
            return ""

        i = 0
        while i &lt; self.__len__() and _C.isspace(i32(int(self.ptr[i]))):
            i += 1

        j = self.__len__() - 1
        while j &gt;= 0 and _C.isspace(i32(int(self.ptr[j]))):
            j -= 1
        j += 1

        if j &lt;= i:
            return ""

        return str(self.ptr + i, j - i)

    def __repr__(self) -&gt; str:
        return f"'{self}'"

from internal.builtin import *

from openmp import Ident as __OMPIdent, for_par
from internal.dlopen import dlsym as _dlsym
</t>
<t tx="ekr.20230509083243.1274">@path C:/Repos/codon/stdlib/internal/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Core library

from internal.attributes import *
from internal.static import static_print as __static_print__
from internal.types.ptr import *
from internal.types.str import *
from internal.types.int import *
from internal.types.bool import *
from internal.types.array import *
from internal.types.error import *
from internal.types.intn import *
from internal.types.float import *
from internal.types.byte import *
from internal.types.generator import *
from internal.types.optional import *
from internal.types.slice import *
from internal.types.range import *
from internal.types.complex import *
from internal.internal import *

__argv__ = Array[str](0)

from internal.types.strbuf import strbuf as _strbuf
from internal.types.collections.list import *
from internal.types.collections.set import *
from internal.types.collections.dict import *
from internal.types.collections.tuple import *

# Extended core library

import internal.c_stubs as _C
from internal.format import *
from internal.builtin import *
from internal.builtin import _jit_display
from internal.str import *

from internal.sort import sorted

from openmp import Ident as __OMPIdent, for_par
from gpu import _gpu_loop_outline_template
from internal.file import File, gzFile, open, gzopen
from pickle import pickle, unpickle
from internal.dlopen import dlsym as _dlsym
import internal.python

if __py_numerics__:
    import internal.pynumerics
if __py_extension__:
    internal.python.ensure_initialized()
</t>
<t tx="ekr.20230509083243.1275"></t>
<t tx="ekr.20230509083243.1276">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.gc import sizeof

@extend
class Array:
    def __new__(ptr: Ptr[T], sz: int) -&gt; Array[T]:
        return (sz, ptr)

    def __new__(sz: int) -&gt; Array[T]:
        return (sz, Ptr[T](sz))

    def __copy__(self) -&gt; Array[T]:
        p = Ptr[T](self.len)
        str.memcpy(p.as_byte(), self.ptr.as_byte(), self.len * sizeof(T))
        return (self.len, p)

    def __deepcopy__(self) -&gt; Array[T]:
        p = Ptr[T](self.len)
        i = 0
        while i &lt; self.len:
            p[i] = self.ptr[i].__deepcopy__()
            i += 1
        return (self.len, p)

    def __len__(self) -&gt; int:
        return self.len

    def __bool__(self) -&gt; bool:
        return bool(self.len)

    def __getitem__(self, index: int) -&gt; T:
        return self.ptr[index]

    def __setitem__(self, index: int, what: T):
        self.ptr[index] = what

    def slice(self, s: int, e: int) -&gt; Array[T]:
        return (e - s, self.ptr + s)

array = Array
</t>
<t tx="ekr.20230509083243.1277">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative

@extend
class bool:
    def __new__() -&gt; bool:
        return False

    def __new__(what) -&gt; bool:
        return what.__bool__()

    def __repr__(self) -&gt; str:
        return "True" if self else "False"

    def __copy__(self) -&gt; bool:
        return self

    def __deepcopy__(self) -&gt; bool:
        return self

    def __bool__(self) -&gt; bool:
        return self

    def __hash__(self) -&gt; int:
        return int(self)

    @pure
    @llvm
    def __invert__(self) -&gt; bool:
        %0 = trunc i8 %self to i1
        %1 = xor i1 %0, true
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __eq__(self, other: bool) -&gt; bool:
        %0 = icmp eq i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ne__(self, other: bool) -&gt; bool:
        %0 = icmp ne i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __lt__(self, other: bool) -&gt; bool:
        %0 = icmp ult i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __gt__(self, other: bool) -&gt; bool:
        %0 = icmp ugt i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __le__(self, other: bool) -&gt; bool:
        %0 = icmp ule i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ge__(self, other: bool) -&gt; bool:
        %0 = icmp uge i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @commutative
    @associative
    @llvm
    def __and__(self, other: bool) -&gt; bool:
        %0 = and i8 %self, %other
        ret i8 %0

    @pure
    @commutative
    @associative
    @llvm
    def __or__(self, other: bool) -&gt; bool:
        %0 = or i8 %self, %other
        ret i8 %0

    @pure
    @commutative
    @associative
    @llvm
    def __xor__(self, other: bool) -&gt; bool:
        %0 = xor i8 %self, %other
        ret i8 %0

    @pure
    @llvm
    def __int__(self) -&gt; int:
        %0 = zext i8 %self to i64
        ret i64 %0

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %0 = uitofp i8 %self to double
        ret double %0
</t>
<t tx="ekr.20230509083243.1278">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@extend
class byte:
    @pure
    @llvm
    def __new__() -&gt; byte:
        ret i8 0

    def __new__(b: byte) -&gt; byte:
        return b

    def __new__(s: str) -&gt; byte:
        if s.__len__() != 1:
            raise ValueError("str length must be 1 in byte constructor")
        return s.ptr[0]

    @pure
    @llvm
    def __new__(i: int) -&gt; byte:
        %0 = trunc i64 %i to i8
        ret i8 %0

    def __copy__(self) -&gt; byte:
        return self

    def __deepcopy__(self) -&gt; byte:
        return self

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = icmp ne i8 %self, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __eq__(self, other: byte) -&gt; bool:
        %0 = icmp eq i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __eq__(self, other: int) -&gt; bool:
        return self == byte(other)

    @pure
    @llvm
    def __ne__(self, other: byte) -&gt; bool:
        %0 = icmp ne i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __lt__(self, other: byte) -&gt; bool:
        %0 = icmp ult i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __gt__(self, other: byte) -&gt; bool:
        %0 = icmp ugt i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __le__(self, other: byte) -&gt; bool:
        %0 = icmp ule i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ge__(self, other: byte) -&gt; bool:
        %0 = icmp uge i8 %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __str__(self) -&gt; str:
        p = Ptr[byte](1)
        p[0] = self
        return str(p, 1)

    def __repr__(self) -&gt; str:
        return f"byte({str(__ptr__(self), 1).__repr__()})"

    @pure
    @llvm
    def __int__(self) -&gt; int:
        %0 = zext i8 %self to i64
        ret i64 %0

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %0 = uitofp i8 %self to double
        ret double %0
</t>
<t tx="ekr.20230509083243.1279">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple
class complex64:
    real: float32
    imag: float32

@tuple
class complex:
    real: float
    imag: float

    def __new__() -&gt; complex:
        return (0.0, 0.0)

    def __new__(other):
        return other.__complex__()

    def __new__(real, imag) -&gt; complex:
        return (float(real), float(imag))

    def __complex__(self) -&gt; complex:
        return self

    def __bool__(self) -&gt; bool:
        return self.real != 0.0 and self.imag != 0.0

    def __pos__(self) -&gt; complex:
        return self

    def __neg__(self) -&gt; complex:
        return complex(-self.real, -self.imag)

    def __abs__(self) -&gt; float:
        @pure
        @C
        def hypot(a: float, b: float) -&gt; float:
            pass

        return hypot(self.real, self.imag)

    def __copy__(self) -&gt; complex:
        return self

    def __hash__(self) -&gt; int:
        return self.real.__hash__() + self.imag.__hash__() * 1000003

    def __add__(self, other) -&gt; complex:
        return self + complex(other)

    def __sub__(self, other) -&gt; complex:
        return self - complex(other)

    def __mul__(self, other) -&gt; complex:
        return self * complex(other)

    def __truediv__(self, other) -&gt; complex:
        return self / complex(other)

    def __eq__(self, other) -&gt; bool:
        return self == complex(other)

    def __ne__(self, other) -&gt; bool:
        return self != complex(other)

    def __pow__(self, other) -&gt; complex:
        return self ** complex(other)

    def __radd__(self, other) -&gt; complex:
        return complex(other) + self

    def __rsub__(self, other) -&gt; complex:
        return complex(other) - self

    def __rmul__(self, other) -&gt; complex:
        return complex(other) * self

    def __rtruediv__(self, other) -&gt; complex:
        return complex(other) / self

    def __rpow__(self, other) -&gt; complex:
        return complex(other) ** self

    def __add__(self, other: complex) -&gt; complex:
        return complex(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other: complex) -&gt; complex:
        return complex(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other: complex) -&gt; complex:
        a = (self.real * other.real) - (self.imag * other.imag)
        b = (self.real * other.imag) + (self.imag * other.real)
        return complex(a, b)

    def __truediv__(self, other: complex) -&gt; complex:
        a = self
        b = other
        abs_breal = (-b.real) if b.real &lt; 0 else b.real
        abs_bimag = (-b.imag) if b.imag &lt; 0 else b.imag

        if abs_breal &gt;= abs_bimag:
            # divide tops and bottom by b.real
            if abs_breal == 0.0:
                # errno = EDOM
                return complex(0.0, 0.0)
            else:
                ratio = b.imag / b.real
                denom = b.real + b.imag * ratio
                return complex(
                    (a.real + a.imag * ratio) / denom, (a.imag - a.real * ratio) / denom
                )
        elif abs_bimag &gt;= abs_breal:
            # divide tops and bottom by b.imag
            ratio = b.real / b.imag
            denom = b.real * ratio + b.imag
            # assert b.imag != 0.0
            return complex(
                (a.real * ratio + a.imag) / denom, (a.imag * ratio - a.real) / denom
            )
        else:
            nan = 0.0 / 0.0
            return complex(nan, nan)

    def __eq__(self, other: complex) -&gt; bool:
        return self.real == other.real and self.imag == other.imag

    def __ne__(self, other: complex) -&gt; bool:
        return not (self == other)

    def __pow__(self, other: int) -&gt; complex:
        def powu(x: complex, n: int) -&gt; complex:
            mask = 1
            r = complex(1.0, 0.0)
            p = x
            while mask &gt; 0 and n &gt;= mask:
                if n &amp; mask:
                    r = r * p
                mask &lt;&lt;= 1
                p = p * p
            return r

        if other &gt; 0:
            return powu(self, other)
        else:
            return complex(1.0, 0.0) / powu(self, -other)

    def __pow__(self, other: complex) -&gt; complex:
        @pure
        @C
        def hypot(a: float, b: float) -&gt; float:
            pass

        @pure
        @C
        def atan2(a: float, b: float) -&gt; float:
            pass

        @pure
        @llvm
        def exp(x: float) -&gt; float:
            declare double @llvm.exp.f64(double)
            %y = call double @llvm.exp.f64(double %x)
            ret double %y

        @pure
        @llvm
        def pow(x: float, y: float) -&gt; float:
            declare double @llvm.pow.f64(double, double)
            %z = call double @llvm.pow.f64(double %x, double %y)
            ret double %z

        @pure
        @llvm
        def log(x: float) -&gt; float:
            declare double @llvm.log.f64(double)
            %y = call double @llvm.log.f64(double %x)
            ret double %y

        @pure
        @llvm
        def sin(x: float) -&gt; float:
            declare double @llvm.sin.f64(double)
            %y = call double @llvm.sin.f64(double %x)
            ret double %y

        @pure
        @llvm
        def cos(x: float) -&gt; float:
            declare double @llvm.cos.f64(double)
            %y = call double @llvm.cos.f64(double %x)
            ret double %y

        if other.real == 0.0 and other.imag == 0.0:
            return complex(1.0, 0.0)
        elif self.real == 0.0 and self.imag == 0.0:
            # if other.imag != 0. or other.real &lt; 0.: errno = EDOM
            return complex(0.0, 0.0)
        else:
            vabs = hypot(self.real, self.imag)
            len = pow(vabs, other.real)
            at = atan2(self.imag, self.real)
            phase = at * other.real
            if other.imag != 0.0:
                len /= exp(at * other.imag)
                phase += other.imag * log(vabs)
            return complex(len * cos(phase), len * sin(phase))

    def __repr__(self) -&gt; str:
        @pure
        @llvm
        def copysign(x: float, y: float) -&gt; float:
            declare double @llvm.copysign.f64(double, double)
            %z = call double @llvm.copysign.f64(double %x, double %y)
            ret double %z

        @pure
        @llvm
        def fabs(x: float) -&gt; float:
            declare double @llvm.fabs.f64(double)
            %y = call double @llvm.fabs.f64(double %x)
            ret double %y

        if self.real == 0.0 and copysign(1.0, self.real) == 1.0:
            return f"{self.imag}j"
        else:
            sign = "+"
            if self.imag &lt; 0.0 or (
                self.imag == 0.0 and copysign(1.0, self.imag) == -1.0
            ):
                sign = "-"
            return f"({self.real}{sign}{fabs(self.imag)}j)"

    def conjugate(self) -&gt; complex:
        return complex(self.real, -self.imag)

    # helpers
    def _phase(self) -&gt; float:
        @pure
        @C
        def atan2(a: float, b: float) -&gt; float:
            pass

        return atan2(self.imag, self.real)

    def _polar(self) -&gt; Tuple[float, float]:
        return (self.__abs__(), self._phase())

    @pure
    @llvm
    def _exp(x: float) -&gt; float:
        declare double @llvm.exp.f64(double)
        %y = call double @llvm.exp.f64(double %x)
        ret double %y

    @pure
    @llvm
    def _sqrt(x: float) -&gt; float:
        declare double @llvm.sqrt.f64(double)
        %y = call double @llvm.sqrt.f64(double %x)
        ret double %y

    @pure
    @llvm
    def _cos(x: float) -&gt; float:
        declare double @llvm.cos.f64(double)
        %y = call double @llvm.cos.f64(double %x)
        ret double %y

    @pure
    @llvm
    def _sin(x: float) -&gt; float:
        declare double @llvm.sin.f64(double)
        %y = call double @llvm.sin.f64(double %x)
        ret double %y

    @pure
    @llvm
    def _log(x: float) -&gt; float:
        declare double @llvm.log.f64(double)
        %y = call double @llvm.log.f64(double %x)
        ret double %y

@extend
class int:
    def __suffix_j__(x: int) -&gt; complex:
        return complex(0, x)

@extend
class float:
    def __suffix_j__(x: float) -&gt; complex:
        return complex(0, x)

f32 = float32

@extend
class complex64:
    def __new__() -&gt; complex64:
        return (f32(0.0), f32(0.0))

    def __new__(other):
        return complex64(other.__complex__())

    def __new__(other: complex) -&gt; complex64:
        return (f32(other.real), f32(other.imag))

    def __new__(real, imag) -&gt; complex64:
        return (f32(float(real)), f32(float(imag)))

    def __complex__(self) -&gt; complex:
        return complex(float(self.real), float(self.imag))

    def __bool__(self) -&gt; bool:
        return self.real != f32(0.0) and self.imag != f32(0.0)

    def __pos__(self) -&gt; complex64:
        return self

    def __neg__(self) -&gt; complex64:
        return complex64(-self.real, -self.imag)

    def __abs__(self) -&gt; f32:
        @pure
        @C
        def hypotf(a: f32, b: f32) -&gt; f32:
            pass

        return hypotf(self.real, self.imag)

    def __copy__(self) -&gt; complex64:
        return self

    def __hash__(self) -&gt; int:
        return self.real.__hash__() + self.imag.__hash__() * 1000003

    def __add__(self, other) -&gt; complex64:
        return self + complex64(other)

    def __sub__(self, other) -&gt; complex64:
        return self - complex64(other)

    def __mul__(self, other) -&gt; complex64:
        return self * complex64(other)

    def __truediv__(self, other) -&gt; complex64:
        return self / complex64(other)

    def __eq__(self, other) -&gt; bool:
        return self == complex64(other)

    def __ne__(self, other) -&gt; bool:
        return self != complex64(other)

    def __pow__(self, other) -&gt; complex64:
        return self ** complex64(other)

    def __radd__(self, other) -&gt; complex64:
        return complex64(other) + self

    def __rsub__(self, other) -&gt; complex64:
        return complex64(other) - self

    def __rmul__(self, other) -&gt; complex64:
        return complex64(other) * self

    def __rtruediv__(self, other) -&gt; complex64:
        return complex64(other) / self

    def __rpow__(self, other) -&gt; complex64:
        return complex64(other) ** self

    def __add__(self, other: complex64) -&gt; complex64:
        return complex64(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other: complex64) -&gt; complex64:
        return complex64(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other: complex64) -&gt; complex64:
        a = (self.real * other.real) - (self.imag * other.imag)
        b = (self.real * other.imag) + (self.imag * other.real)
        return complex64(a, b)

    def __truediv__(self, other: complex64) -&gt; complex64:
        a = self
        b = other
        abs_breal = (-b.real) if b.real &lt; f32(0) else b.real
        abs_bimag = (-b.imag) if b.imag &lt; f32(0) else b.imag

        if abs_breal &gt;= abs_bimag:
            # divide tops and bottom by b.real
            if abs_breal == f32(0.0):
                # errno = EDOM
                return complex64(0.0, 0.0)
            else:
                ratio = b.imag / b.real
                denom = b.real + b.imag * ratio
                return complex64(
                    (a.real + a.imag * ratio) / denom, (a.imag - a.real * ratio) / denom
                )
        elif abs_bimag &gt;= abs_breal:
            # divide tops and bottom by b.imag
            ratio = b.real / b.imag
            denom = b.real * ratio + b.imag
            # assert b.imag != 0.0
            return complex64(
                (a.real * ratio + a.imag) / denom, (a.imag * ratio - a.real) / denom
            )
        else:
            nan = 0.0 / 0.0
            return complex64(nan, nan)

    def __eq__(self, other: complex64) -&gt; bool:
        return self.real == other.real and self.imag == other.imag

    def __ne__(self, other: complex64) -&gt; bool:
        return not (self == other)

    def __pow__(self, other: int) -&gt; complex64:
        def powu(x: complex64, n: int) -&gt; complex64:
            mask = 1
            r = complex64(1.0, 0.0)
            p = x
            while mask &gt; 0 and n &gt;= mask:
                if n &amp; mask:
                    r = r * p
                mask &lt;&lt;= 1
                p = p * p
            return r

        if other &gt; 0:
            return powu(self, other)
        else:
            return complex64(1.0, 0.0) / powu(self, -other)

    def __pow__(self, other: complex64) -&gt; complex64:
        @pure
        @C
        def hypotf(a: f32, b: f32) -&gt; f32:
            pass

        @pure
        @C
        def atan2f(a: f32, b: f32) -&gt; f32:
            pass

        @pure
        @llvm
        def exp(x: f32) -&gt; f32:
            declare float @llvm.exp.f32(float)
            %y = call float @llvm.exp.f32(float %x)
            ret float %y

        @pure
        @llvm
        def pow(x: f32, y: f32) -&gt; f32:
            declare float @llvm.pow.f32(float, float)
            %z = call float @llvm.pow.f32(float %x, float %y)
            ret float %z

        @pure
        @llvm
        def log(x: f32) -&gt; f32:
            declare float @llvm.log.f32(float)
            %y = call float @llvm.log.f32(float %x)
            ret float %y

        @pure
        @llvm
        def sin(x: f32) -&gt; f32:
            declare float @llvm.sin.f32(float)
            %y = call float @llvm.sin.f32(float %x)
            ret float %y

        @pure
        @llvm
        def cos(x: f32) -&gt; f32:
            declare float @llvm.cos.f32(float)
            %y = call float @llvm.cos.f32(float %x)
            ret float %y

        if other.real == f32(0.0) and other.imag == f32(0.0):
            return complex64(1.0, 0.0)
        elif self.real == f32(0.0) and self.imag == f32(0.0):
            # if other.imag != 0. or other.real &lt; 0.: errno = EDOM
            return complex64(0.0, 0.0)
        else:
            vabs = hypotf(self.real, self.imag)
            len = pow(vabs, other.real)
            at = atan2f(self.imag, self.real)
            phase = at * other.real
            if other.imag != f32(0.0):
                len /= exp(at * other.imag)
                phase += other.imag * log(vabs)
            return complex64(len * cos(phase), len * sin(phase))

    def __repr__(self) -&gt; str:
        @pure
        @llvm
        def copysign(x: f32, y: f32) -&gt; f32:
            declare float @llvm.copysign.f32(float, float)
            %z = call float @llvm.copysign.f32(float %x, float %y)
            ret float %z

        @pure
        @llvm
        def fabs(x: f32) -&gt; f32:
            declare float @llvm.fabs.f32(float)
            %y = call float @llvm.fabs.f32(float %x)
            ret float %y

        if self.real == f32(0.0) and copysign(f32(1.0), self.real) == f32(1.0):
            return f"complex64({self.imag}j)"
        else:
            sign = "+"
            if self.imag &lt; f32(0.0) or (
                self.imag == f32(0.0) and copysign(f32(1.0), self.imag) == f32(-1.0)
            ):
                sign = "-"
            return f"complex64({self.real}{sign}{fabs(self.imag)}j)"

    def conjugate(self) -&gt; complex64:
        return complex64(self.real, -self.imag)

    # helpers
    def _phase(self) -&gt; f32:
        @pure
        @C
        def atan2f(a: f32, b: f32) -&gt; f32:
            pass

        return atan2f(self.imag, self.real)

    def _polar(self) -&gt; Tuple[f32, f32]:
        return (self.__abs__(), self._phase())

    @pure
    @llvm
    def _exp(x: f32) -&gt; f32:
        declare float @llvm.exp.f32(float)
        %y = call float @llvm.exp.f32(float %x)
        ret float %y

    @pure
    @llvm
    def _sqrt(x: f32) -&gt; f32:
        declare float @llvm.sqrt.f32(float)
        %y = call float @llvm.sqrt.f32(float %x)
        ret float %y

    @pure
    @llvm
    def _cos(x: f32) -&gt; f32:
        declare float @llvm.cos.f32(float)
        %y = call float @llvm.cos.f32(float %x)
        ret float %y

    @pure
    @llvm
    def _sin(x: f32) -&gt; f32:
        declare float @llvm.sin.f32(float)
        %y = call float @llvm.sin.f32(float %x)
        ret float %y

    @pure
    @llvm
    def _log(x: f32) -&gt; f32:
        declare float @llvm.log.f32(float)
        %y = call float @llvm.log.f32(float %x)
        ret float %y
</t>
<t tx="ekr.20230509083243.128">  template &lt;typename NodeType, typename... Args&gt;
  NodeType *Nt(const NodeType *source, Args... args) {
    return module-&gt;N&lt;NodeType&gt;(source, std::forward&lt;Args&gt;(args)..., source-&gt;getName());
  }
</t>
<t tx="ekr.20230509083243.1280">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

# Warning(!): This type must be consistent with the exception
# header type defined in runtime/exc.cpp.
class BaseException:
    _pytype: ClassVar[cobj] = cobj()
    typename: str
    message: str
    func: str
    file: str
    line: int
    col: int
    python_type: cobj

    def __init__(self, typename: str, message: str = ""):
        self.typename = typename
        self.message = message
        self.func = ""
        self.file = ""
        self.line = 0
        self.col = 0
        self.python_type = BaseException._pytype

    def __str__(self):
        return self.message

    def __repr__(self):
        return f'{self.typename}({self.message.__repr__()})'

class Exception(Static[BaseException]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, msg: str = ""):
        super().__init__(typename, msg)
        if (hasattr(self.__class__, "_pytype")):
            self.python_type = self.__class__._pytype

class NameError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("NameError", message)
        self.python_type = self.__class__._pytype

class OSError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("OSError", message)
        self.python_type = self.__class__._pytype

class IOError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("IOError", message)
        self.python_type = self.__class__._pytype

class ValueError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("ValueError", message)
        self.python_type = self.__class__._pytype

class LookupError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, msg: str = ""):
        super().__init__("LookupError", msg)
        self.python_type = self.__class__._pytype

class IndexError(Static[LookupError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("IndexError", message)
        self.python_type = self.__class__._pytype

class KeyError(Static[LookupError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("KeyError", message)
        self.python_type = self.__class__._pytype

class CError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("CError", message)
        self.python_type = self.__class__._pytype

class PyError(Static[Exception]):
    pytype: pyobj

    def __init__(self, message: str, pytype: pyobj = pyobj(cobj(), steal=True)):
        super().__init__("PyError", message)
        self.pytype = pytype

class TypeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("TypeError", message)
        self.python_type = self.__class__._pytype

class ArithmeticError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, msg: str = ""):
        super().__init__("ArithmeticError", msg)
        self.python_type = self.__class__._pytype

class ZeroDivisionError(Static[ArithmeticError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, message: str = ""):
        super().__init__("ZeroDivisionError", message)
        self.python_type = self.__class__._pytype

class OverflowError(Static[ArithmeticError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("OverflowError", message)
        self.python_type = self.__class__._pytype

class AttributeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("AttributeError", message)
        self.python_type = self.__class__._pytype

class RuntimeError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, typename: str, message: str = ""):
        super().__init__(typename, message)
        self.python_type = self.__class__._pytype
    def __init__(self, message: str = ""):
        super().__init__("RuntimeError", message)
        self.python_type = self.__class__._pytype

class NotImplementedError(Static[RuntimeError]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("NotImplementedError", message)
        self.python_type = self.__class__._pytype

class StopIteration(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("StopIteration", message)
        self.python_type = self.__class__._pytype

class AssertionError(Static[Exception]):
    _pytype: ClassVar[cobj] = cobj()
    def __init__(self, message: str = ""):
        super().__init__("AssertionError", message)
        self.python_type = self.__class__._pytype

class SystemExit(Static[BaseException]):
    _pytype: ClassVar[cobj] = cobj()
    _status: int

    def __init__(self, message: str = "", status: int = 0):
        super().__init__("SystemExit", message)
        self._status = status
        self.python_type = self.__class__._pytype

    def __init__(self, status: int):
        self.__init__("", status)

    @property
    def status(self):
        return self._status
</t>
<t tx="ekr.20230509083243.1281">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative
from internal.gc import alloc_atomic, free
from internal.types.complex import complex

@extend
class float:
    def __new__() -&gt; float:
        return 0.0

    def __new__(what) -&gt; float:
        # do not overload! (needed to avoid pyobj conversion)
        if isinstance(what, str) or isinstance(what, Optional[str]):
            return float._from_str(what)
        else:
            return what.__float__()

    def __repr__(self) -&gt; str:
        return self.__format__("")

    def __copy__(self) -&gt; float:
        return self

    def __deepcopy__(self) -&gt; float:
        return self

    @pure
    @llvm
    def __int__(self) -&gt; int:
        %0 = fptosi double %self to i64
        ret i64 %0

    def __float__(self) -&gt; float:
        return self

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = fcmp one double %self, 0.000000e+00
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __complex__(self) -&gt; complex:
        return complex(self, 0.0)

    def __pos__(self) -&gt; float:
        return self

    @pure
    @llvm
    def __neg__(self) -&gt; float:
        %0 = fneg double %self
        ret double %0

    @pure
    @commutative
    @llvm
    def __add__(a: float, b: float) -&gt; float:
        %tmp = fadd double %a, %b
        ret double %tmp

    @pure
    @llvm
    def __sub__(a: float, b: float) -&gt; float:
        %tmp = fsub double %a, %b
        ret double %tmp

    @pure
    @commutative
    @llvm
    def __mul__(a: float, b: float) -&gt; float:
        %tmp = fmul double %a, %b
        ret double %tmp

    def __floordiv__(self, other: float) -&gt; float:
        return self.__truediv__(other).__floor__()

    @pure
    @llvm
    def __truediv__(a: float, b: float) -&gt; float:
        %tmp = fdiv double %a, %b
        ret double %tmp

    @pure
    @llvm
    def __mod__(a: float, b: float) -&gt; float:
        %tmp = frem double %a, %b
        ret double %tmp

    def __divmod__(self, other: float) -&gt; Tuple[float, float]:
        mod = self % other
        div = (self - mod) / other
        if mod:
            if (other &lt; 0) != (mod &lt; 0):
                mod += other
                div -= 1.0
        else:
            mod = (0.0).copysign(other)

        floordiv = 0.0
        if div:
            floordiv = div.__floor__()
            if div - floordiv &gt; 0.5:
                floordiv += 1.0
        else:
            floordiv = (0.0).copysign(self / other)

        return (floordiv, mod)

    @pure
    @llvm
    def __eq__(a: float, b: float) -&gt; bool:
        %tmp = fcmp oeq double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ne__(a: float, b: float) -&gt; bool:
        entry:
            %tmp = fcmp one double %a, %b
            %res = zext i1 %tmp to i8
            ret i8 %res

    @pure
    @llvm
    def __lt__(a: float, b: float) -&gt; bool:
        %tmp = fcmp olt double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __gt__(a: float, b: float) -&gt; bool:
        %tmp = fcmp ogt double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __le__(a: float, b: float) -&gt; bool:
        %tmp = fcmp ole double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ge__(a: float, b: float) -&gt; bool:
        %tmp = fcmp oge double %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def sqrt(a: float) -&gt; float:
        declare double @llvm.sqrt.f64(double %a)
        %tmp = call double @llvm.sqrt.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def sin(a: float) -&gt; float:
        declare double @llvm.sin.f64(double %a)
        %tmp = call double @llvm.sin.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def cos(a: float) -&gt; float:
        declare double @llvm.cos.f64(double %a)
        %tmp = call double @llvm.cos.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def exp(a: float) -&gt; float:
        declare double @llvm.exp.f64(double %a)
        %tmp = call double @llvm.exp.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def exp2(a: float) -&gt; float:
        declare double @llvm.exp2.f64(double %a)
        %tmp = call double @llvm.exp2.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def log(a: float) -&gt; float:
        declare double @llvm.log.f64(double %a)
        %tmp = call double @llvm.log.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def log10(a: float) -&gt; float:
        declare double @llvm.log10.f64(double %a)
        %tmp = call double @llvm.log10.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def log2(a: float) -&gt; float:
        declare double @llvm.log2.f64(double %a)
        %tmp = call double @llvm.log2.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __abs__(a: float) -&gt; float:
        declare double @llvm.fabs.f64(double %a)
        %tmp = call double @llvm.fabs.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __floor__(a: float) -&gt; float:
        declare double @llvm.floor.f64(double %a)
        %tmp = call double @llvm.floor.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __ceil__(a: float) -&gt; float:
        declare double @llvm.ceil.f64(double %a)
        %tmp = call double @llvm.ceil.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __trunc__(a: float) -&gt; float:
        declare double @llvm.trunc.f64(double %a)
        %tmp = call double @llvm.trunc.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def rint(a: float) -&gt; float:
        declare double @llvm.rint.f64(double %a)
        %tmp = call double @llvm.rint.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def nearbyint(a: float) -&gt; float:
        declare double @llvm.nearbyint.f64(double %a)
        %tmp = call double @llvm.nearbyint.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __round__(a: float) -&gt; float:
        declare double @llvm.round.f64(double %a)
        %tmp = call double @llvm.round.f64(double %a)
        ret double %tmp

    @pure
    @llvm
    def __pow__(a: float, b: float) -&gt; float:
        declare double @llvm.pow.f64(double %a, double %b)
        %tmp = call double @llvm.pow.f64(double %a, double %b)
        ret double %tmp

    @pure
    @llvm
    def min(a: float, b: float) -&gt; float:
        declare double @llvm.minnum.f64(double %a, double %b)
        %tmp = call double @llvm.minnum.f64(double %a, double %b)
        ret double %tmp

    @pure
    @llvm
    def max(a: float, b: float) -&gt; float:
        declare double @llvm.maxnum.f64(double %a, double %b)
        %tmp = call double @llvm.maxnum.f64(double %a, double %b)
        ret double %tmp

    @pure
    @llvm
    def copysign(a: float, b: float) -&gt; float:
        declare double @llvm.copysign.f64(double %a, double %b)
        %tmp = call double @llvm.copysign.f64(double %a, double %b)
        ret double %tmp

    @pure
    @llvm
    def fma(a: float, b: float, c: float) -&gt; float:
        declare double @llvm.fma.f64(double %a, double %b, double %c)
        %tmp = call double @llvm.fma.f64(double %a, double %b, double %c)
        ret double %tmp

    @nocapture
    @llvm
    def __atomic_xchg__(d: Ptr[float], b: float) -&gt; None:
        %tmp = atomicrmw xchg ptr %d, double %b seq_cst
        ret {} {}

    @nocapture
    @llvm
    def __atomic_add__(d: Ptr[float], b: float) -&gt; float:
        0:
        %1 = load atomic i64, ptr %d monotonic, align 8
        %2 = bitcast i64 %1 to double
        %3 = fadd double %2, %b
        %4 = bitcast double %3 to i64
        %5 = cmpxchg weak ptr %d, i64 %1, i64 %4 seq_cst monotonic, align 8
        %6 = extractvalue { i64, i1 } %5, 1
        br i1 %6, label %15, label %7
        7:                                                ; preds = %0, %7
        %8 = phi { i64, i1 } [ %13, %7 ], [ %5, %0 ]
        %9 = extractvalue { i64, i1 } %8, 0
        %10 = bitcast i64 %9 to double
        %11 = fadd double %10, %b
        %12 = bitcast double %11 to i64
        %13 = cmpxchg weak ptr %d, i64 %9, i64 %12 seq_cst monotonic, align 8
        %14 = extractvalue { i64, i1 } %13, 1
        br i1 %14, label %15, label %7
        15:                                               ; preds = %7, %0
        %16 = phi double [ %2, %0 ], [ %10, %7 ]
        ret double %16

    @nocapture
    @llvm
    def __atomic_sub__(d: Ptr[float], b: float) -&gt; float:
        0:
        %1 = load atomic i64, ptr %d monotonic, align 8
        %2 = bitcast i64 %1 to double
        %3 = fsub double %2, %b
        %4 = bitcast double %3 to i64
        %5 = cmpxchg weak ptr %d, i64 %1, i64 %4 seq_cst monotonic, align 8
        %6 = extractvalue { i64, i1 } %5, 1
        br i1 %6, label %15, label %7
        7:                                                ; preds = %0, %7
        %8 = phi { i64, i1 } [ %13, %7 ], [ %5, %0 ]
        %9 = extractvalue { i64, i1 } %8, 0
        %10 = bitcast i64 %9 to double
        %11 = fsub double %10, %b
        %12 = bitcast double %11 to i64
        %13 = cmpxchg weak ptr %d, i64 %9, i64 %12 seq_cst monotonic, align 8
        %14 = extractvalue { i64, i1 } %13, 1
        br i1 %14, label %15, label %7
        15:                                               ; preds = %7, %0
        %16 = phi double [ %2, %0 ], [ %10, %7 ]
        ret double %16

    def __hash__(self) -&gt; int:
        @nocapture
        @C
        def frexp(a: float, b: Ptr[Int[32]]) -&gt; float: pass

        HASH_BITS = 61
        HASH_MODULUS = (1 &lt;&lt; HASH_BITS) - 1
        HASH_INF = 314159
        HASH_NAN = 0
        INF = 1.0 / 0.0
        NAN = 0.0 / 0.0
        v = self

        if v == INF or v == -INF:
            return HASH_INF if v &gt; 0 else -HASH_INF
        if v == NAN:
            return HASH_NAN

        _e = i32(0)
        m = frexp(v, __ptr__(_e))
        e = int(_e)

        sign = 1
        if m &lt; 0:
            sign = -1
            m = -m

        x = 0
        while m:
            x = ((x &lt;&lt; 28) &amp; HASH_MODULUS) | x &gt;&gt; (HASH_BITS - 28)
            m *= 268435456.0  # 2**28
            e -= 28
            y = int(m)
            m -= y
            x += y
            if x &gt;= HASH_MODULUS:
                x -= HASH_MODULUS

        e = e % HASH_BITS if e &gt;= 0 else HASH_BITS - 1 - ((-1 - e) % HASH_BITS)
        x = ((x &lt;&lt; e) &amp; HASH_MODULUS) | x &gt;&gt; (HASH_BITS - e)

        x = x * sign
        if x == -1:
            x = -2
        return x

    def __match__(self, i: float) -&gt; bool:
        return self == i

    @property
    def real(self) -&gt; float:
        return self

    @property
    def imag(self) -&gt; float:
        return 0.0

@extend
class float32:
    @pure
    @llvm
    def __new__(self: float) -&gt; float32:
        %0 = fptrunc double %self to float
        ret float %0

    def __new__(what: float32) -&gt; float32:
        return what

    def __new__() -&gt; float32:
        return float32.__new__(0.0)

    def __repr__(self) -&gt; str:
        return self.__float__().__repr__()

    def __format__(self, format_spec: str) -&gt; str:
        return self.__float__().__format(format_spec)

    def __copy__(self) -&gt; float32:
        return self

    def __deepcopy__(self) -&gt; float32:
        return self

    @pure
    @llvm
    def __int__(self) -&gt; int:
        %0 = fptosi float %self to i64
        ret i64 %0

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %0 = fpext float %self to double
        ret double %0

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = fcmp one float %self, 0.000000e+00
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __pos__(self) -&gt; float32:
        return self

    @pure
    @llvm
    def __neg__(self) -&gt; float32:
        %0 = fneg float %self
        ret float %0

    @pure
    @commutative
    @llvm
    def __add__(a: float32, b: float32) -&gt; float32:
        %tmp = fadd float %a, %b
        ret float %tmp

    @pure
    @llvm
    def __sub__(a: float32, b: float32) -&gt; float32:
        %tmp = fsub float %a, %b
        ret float %tmp

    @pure
    @commutative
    @llvm
    def __mul__(a: float32, b: float32) -&gt; float32:
        %tmp = fmul float %a, %b
        ret float %tmp

    def __floordiv__(self, other: float32) -&gt; float:
        return self.__truediv__(other).__floor__()

    @pure
    @llvm
    def __truediv__(a: float32, b: float32) -&gt; float32:
        %tmp = fdiv float %a, %b
        ret float %tmp

    @pure
    @llvm
    def __mod__(a: float32, b: float32) -&gt; float32:
        %tmp = frem float %a, %b
        ret float %tmp

    def __divmod__(self, other: float32) -&gt; Tuple[float32, float32]:
        mod = self % other
        div = (self - mod) / other
        if mod:
            if (other &lt; 0) != (mod &lt; 0):
                mod += other
                div -= 1.0
        else:
            mod = (0.0).copysign(other)

        floordiv = 0.0
        if div:
            floordiv = div.__floor__()
            if div - floordiv &gt; 0.5:
                floordiv += 1.0
        else:
            floordiv = (0.0).copysign(self / other)

        return (floordiv, mod)

    @pure
    @llvm
    def __eq__(a: float32, b: float32) -&gt; bool:
        %tmp = fcmp oeq float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ne__(a: float32, b: float32) -&gt; bool:
        entry:
            %tmp = fcmp one float %a, %b
            %res = zext i1 %tmp to i8
            ret i8 %res

    @pure
    @llvm
    def __lt__(a: float32, b: float32) -&gt; bool:
        %tmp = fcmp olt float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __gt__(a: float32, b: float32) -&gt; bool:
        %tmp = fcmp ogt float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __le__(a: float32, b: float32) -&gt; bool:
        %tmp = fcmp ole float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ge__(a: float32, b: float32) -&gt; bool:
        %tmp = fcmp oge float %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def sqrt(a: float32) -&gt; float32:
        declare float @llvm.sqrt.f32(float %a)
        %tmp = call float @llvm.sqrt.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def sin(a: float32) -&gt; float32:
        declare float @llvm.sin.f32(float %a)
        %tmp = call float @llvm.sin.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def cos(a: float32) -&gt; float32:
        declare float @llvm.cos.f32(float %a)
        %tmp = call float @llvm.cos.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def exp(a: float32) -&gt; float32:
        declare float @llvm.exp.f32(float %a)
        %tmp = call float @llvm.exp.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def exp2(a: float32) -&gt; float32:
        declare float @llvm.exp2.f32(float %a)
        %tmp = call float @llvm.exp2.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def log(a: float32) -&gt; float32:
        declare float @llvm.log.f32(float %a)
        %tmp = call float @llvm.log.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def log10(a: float32) -&gt; float32:
        declare float @llvm.log10.f32(float %a)
        %tmp = call float @llvm.log10.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def log2(a: float32) -&gt; float32:
        declare float @llvm.log2.f32(float %a)
        %tmp = call float @llvm.log2.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __abs__(a: float32) -&gt; float32:
        declare float @llvm.fabs.f32(float %a)
        %tmp = call float @llvm.fabs.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __floor__(a: float32) -&gt; float32:
        declare float @llvm.floor.f32(float %a)
        %tmp = call float @llvm.floor.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __ceil__(a: float32) -&gt; float32:
        declare float @llvm.ceil.f32(float %a)
        %tmp = call float @llvm.ceil.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __trunc__(a: float32) -&gt; float32:
        declare float @llvm.trunc.f32(float %a)
        %tmp = call float @llvm.trunc.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def rint(a: float32) -&gt; float32:
        declare float @llvm.rint.f32(float %a)
        %tmp = call float @llvm.rint.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def nearbyint(a: float32) -&gt; float32:
        declare float @llvm.nearbyint.f32(float %a)
        %tmp = call float @llvm.nearbyint.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __round__(a: float32) -&gt; float32:
        declare float @llvm.round.f32(float %a)
        %tmp = call float @llvm.round.f32(float %a)
        ret float %tmp

    @pure
    @llvm
    def __pow__(a: float32, b: float32) -&gt; float32:
        declare float @llvm.pow.f32(float %a, float %b)
        %tmp = call float @llvm.pow.f32(float %a, float %b)
        ret float %tmp

    @pure
    @llvm
    def min(a: float32, b: float32) -&gt; float32:
        declare float @llvm.minnum.f32(float %a, float %b)
        %tmp = call float @llvm.minnum.f32(float %a, float %b)
        ret float %tmp

    @pure
    @llvm
    def max(a: float32, b: float32) -&gt; float32:
        declare float @llvm.maxnum.f32(float %a, float %b)
        %tmp = call float @llvm.maxnum.f32(float %a, float %b)
        ret float %tmp

    @pure
    @llvm
    def copysign(a: float32, b: float32) -&gt; float32:
        declare float @llvm.copysign.f32(float %a, float %b)
        %tmp = call float @llvm.copysign.f32(float %a, float %b)
        ret float %tmp

    @pure
    @llvm
    def fma(a: float32, b: float32, c: float32) -&gt; float32:
        declare float @llvm.fma.f32(float %a, float %b, float %c)
        %tmp = call float @llvm.fma.f32(float %a, float %b, float %c)
        ret float %tmp

    @nocapture
    @llvm
    def __atomic_xchg__(d: Ptr[float32], b: float32) -&gt; None:
        %tmp = atomicrmw xchg ptr %d, float %b seq_cst
        ret {} {}

    @nocapture
    @llvm
    def __atomic_add__(d: Ptr[float32], b: float32) -&gt; float32:
        0:
        %1 = load atomic i32, ptr %d monotonic, align 4
        %2 = bitcast i32 %1 to float
        %3 = fadd float %2, %b
        %4 = bitcast float %3 to i32
        %5 = cmpxchg weak ptr %d, i32 %1, i32 %4 seq_cst monotonic, align 4
        %6 = extractvalue { i32, i1 } %5, 1
        br i1 %6, label %15, label %7
        7:                                                ; preds = %0, %7
        %8 = phi { i32, i1 } [ %13, %7 ], [ %5, %0 ]
        %9 = extractvalue { i32, i1 } %8, 0
        %10 = bitcast i32 %9 to float
        %11 = fadd float %10, %b
        %12 = bitcast float %11 to i32
        %13 = cmpxchg weak ptr %d, i32 %9, i32 %12 seq_cst monotonic, align 4
        %14 = extractvalue { i32, i1 } %13, 1
        br i1 %14, label %15, label %7
        15:                                               ; preds = %7, %0
        %16 = phi float [ %2, %0 ], [ %10, %7 ]
        ret float %16

    @nocapture
    @llvm
    def __atomic_sub__(d: Ptr[float32], b: float32) -&gt; float32:
        0:
        %1 = load atomic i32, ptr %d monotonic, align 4
        %2 = bitcast i32 %1 to float
        %3 = fsub float %2, %b
        %4 = bitcast float %3 to i32
        %5 = cmpxchg weak ptr %d, i32 %1, i32 %4 seq_cst monotonic, align 4
        %6 = extractvalue { i32, i1 } %5, 1
        br i1 %6, label %15, label %7
        7:                                                ; preds = %0, %7
        %8 = phi { i32, i1 } [ %13, %7 ], [ %5, %0 ]
        %9 = extractvalue { i32, i1 } %8, 0
        %10 = bitcast i32 %9 to float
        %11 = fsub float %10, %b
        %12 = bitcast float %11 to i32
        %13 = cmpxchg weak ptr %d, i32 %9, i32 %12 seq_cst monotonic, align 4
        %14 = extractvalue { i32, i1 } %13, 1
        br i1 %14, label %15, label %7
        15:                                               ; preds = %7, %0
        %16 = phi float [ %2, %0 ], [ %10, %7 ]
        ret float %16

    def __hash__(self) -&gt; int:
        return self.__float__().__hash__()

    def __match__(self, i: float32) -&gt; bool:
        return self == i

@extend
class float:
    def __suffix_f32__(double) -&gt; float32:
        return float32.__new__(double)

f32 = float32
</t>
<t tx="ekr.20230509083243.1282">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@extend
class Generator:
    @__internal__
    def __promise__(self) -&gt; Ptr[T]:
        pass

    def done(self) -&gt; bool:
        self.__resume__()
        return self.__done__()

    def next(self: Generator[T]) -&gt; T:
        if isinstance(T, None):
            pass
        else:
            return self.__promise__()[0]

    def __iter__(self) -&gt; Generator[T]:
        return self

    @pure
    @llvm
    def __raw__(self) -&gt; Ptr[byte]:
        ret ptr %self

    @pure
    @derives
    @llvm
    def __new__(ptr: cobj) -&gt; Generator[T]:
        ret ptr %ptr

    @pure
    @llvm
    def __done__(self) -&gt; bool:
        declare i1 @llvm.coro.done(ptr nocapture readonly)
        %0 = call i1 @llvm.coro.done(ptr %self)
        %1 = zext i1 %0 to i8
        ret i8 %1

    @nocapture
    @llvm
    def __resume__(self) -&gt; None:
        declare void @llvm.coro.resume(ptr)
        call void @llvm.coro.resume(ptr %self)
        ret {} {}

    def __repr__(self) -&gt; str:
        return __internal__.raw_type_str(self.__raw__(), "generator")

    def send(self, what: T) -&gt; T:
        p = self.__promise__()
        p[0] = what
        self.__resume__()
        return p[0]

    @nocapture
    @llvm
    def destroy(self) -&gt; None:
        declare void @llvm.coro.destroy(ptr)
        call void @llvm.coro.destroy(ptr %self)
        ret {} {}

generator = Generator
</t>
<t tx="ekr.20230509083243.1283">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative, distributive
from internal.types.complex import complex

@extend
class int:
    @pure
    @llvm
    def __new__() -&gt; int:
        ret i64 0

    def __new__(s: str, base: int) -&gt; int:
        return int._from_str(s, base)

    def __new__(what) -&gt; int:
        # do not overload! (needed to avoid pyobj conversion)
        if isinstance(what, str) or isinstance(what, Optional[str]):
            return int._from_str(what, 10)
        else:
            return what.__int__()

    def __int__(self) -&gt; int:
        return self

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %tmp = sitofp i64 %self to double
        ret double %tmp

    def __complex__(self) -&gt; complex:
        return complex(float(self), 0.0)

    def __index__(self) -&gt; int:
        return self

    def __repr__(self) -&gt; str:
        return self.__format__("")

    def __copy__(self) -&gt; int:
        return self

    def __deepcopy__(self) -&gt; int:
        return self

    def __hash__(self) -&gt; int:
        return self

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = icmp ne i64 %self, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __pos__(self) -&gt; int:
        return self

    def __neg__(self) -&gt; int:
        return 0 - self

    @pure
    @llvm
    def __abs__(self) -&gt; int:
        declare i64 @llvm.abs.i64(i64, i1)
        %0 = call i64 @llvm.abs.i64(i64 %self, i1 false)
        ret i64 %0

    @pure
    @llvm
    def __lshift__(self, other: int) -&gt; int:
        %0 = shl i64 %self, %other
        ret i64 %0

    @pure
    @llvm
    def __rshift__(self, other: int) -&gt; int:
        %0 = ashr i64 %self, %other
        ret i64 %0

    @pure
    @commutative
    @llvm
    def __add__(self, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fadd double %0, %other
        ret double %1

    @pure
    @commutative
    @associative
    @llvm
    def __add__(self, b: int) -&gt; int:
        %tmp = add i64 %self, %b
        ret i64 %tmp

    @pure
    @llvm
    def __sub__(self, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fsub double %0, %other
        ret double %1

    @pure
    @llvm
    def __sub__(self, b: int) -&gt; int:
        %tmp = sub i64 %self, %b
        ret i64 %tmp

    @pure
    @commutative
    @llvm
    def __mul__(self, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fmul double %0, %other
        ret double %1

    @pure
    @commutative
    @associative
    @distributive
    @llvm
    def __mul__(self, b: int) -&gt; int:
        %tmp = mul i64 %self, %b
        ret i64 %tmp

    @pure
    @llvm
    def __floordiv__(self, other: float) -&gt; float:
        declare double @llvm.floor.f64(double)
        %0 = sitofp i64 %self to double
        %1 = fdiv double %0, %other
        %2 = call double @llvm.floor.f64(double %1)
        ret double %2

    @pure
    @llvm
    def __floordiv__(self, b: int) -&gt; int:
        %tmp = sdiv i64 %self, %b
        ret i64 %tmp

    @pure
    @llvm
    def __truediv__(self, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fdiv double %0, %other
        ret double %1

    @pure
    @llvm
    def __truediv__(self, other: int) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = sitofp i64 %other to double
        %2 = fdiv double %0, %1
        ret double %2

    @pure
    @llvm
    def __mod__(self, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = frem double %0, %other
        ret double %1

    @pure
    @llvm
    def __mod__(a: int, b: int) -&gt; int:
        %tmp = srem i64 %a, %b
        ret i64 %tmp

    def __divmod__(self, other: float) -&gt; Tuple[float, float]:
        return float(self).__divmod__(other)

    def __divmod__(self, other: int) -&gt; Tuple[int, int]:
        d = self // other
        m = self - d * other
        if m and ((other ^ m) &lt; 0):
            m += other
            d -= 1
        return (d, m)

    @pure
    @llvm
    def __invert__(a: int) -&gt; int:
        %tmp = xor i64 %a, -1
        ret i64 %tmp

    @pure
    @commutative
    @associative
    @llvm
    def __and__(a: int, b: int) -&gt; int:
        %tmp = and i64 %a, %b
        ret i64 %tmp

    @pure
    @commutative
    @associative
    @llvm
    def __or__(a: int, b: int) -&gt; int:
        %tmp = or i64 %a, %b
        ret i64 %tmp

    @pure
    @commutative
    @associative
    @llvm
    def __xor__(a: int, b: int) -&gt; int:
        %tmp = xor i64 %a, %b
        ret i64 %tmp

    @pure
    @llvm
    def __bitreverse__(a: int) -&gt; int:
        declare i64 @llvm.bitreverse.i64(i64 %a)
        %tmp = call i64 @llvm.bitreverse.i64(i64 %a)
        ret i64 %tmp

    @pure
    @llvm
    def __bswap__(a: int) -&gt; int:
        declare i64 @llvm.bswap.i64(i64 %a)
        %tmp = call i64 @llvm.bswap.i64(i64 %a)
        ret i64 %tmp

    @pure
    @llvm
    def __ctpop__(a: int) -&gt; int:
        declare i64 @llvm.ctpop.i64(i64 %a)
        %tmp = call i64 @llvm.ctpop.i64(i64 %a)
        ret i64 %tmp

    @pure
    @llvm
    def __ctlz__(a: int) -&gt; int:
        declare i64 @llvm.ctlz.i64(i64 %a, i1 %is_zero_undef)
        %tmp = call i64 @llvm.ctlz.i64(i64 %a, i1 false)
        ret i64 %tmp

    @pure
    @llvm
    def __cttz__(a: int) -&gt; int:
        declare i64 @llvm.cttz.i64(i64 %a, i1 %is_zero_undef)
        %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
        ret i64 %tmp

    @pure
    @llvm
    def __eq__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp oeq double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __eq__(a: int, b: int) -&gt; bool:
        %tmp = icmp eq i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ne__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp one double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __ne__(a: int, b: int) -&gt; bool:
        %tmp = icmp ne i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __lt__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp olt double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __lt__(a: int, b: int) -&gt; bool:
        %tmp = icmp slt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __gt__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp ogt double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __gt__(a: int, b: int) -&gt; bool:
        %tmp = icmp sgt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __le__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp ole double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __le__(a: int, b: int) -&gt; bool:
        %tmp = icmp sle i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @pure
    @llvm
    def __ge__(self, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp oge double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @pure
    @llvm
    def __ge__(a: int, b: int) -&gt; bool:
        %tmp = icmp sge i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    def __pow__(self, exp: float) -&gt; float:
        return float(self) ** exp

    def __pow__(self, exp: int) -&gt; int:
        if exp &lt; 0:
            return 0
        result = 1
        while True:
            if exp &amp; 1:
                result *= self
            exp &gt;&gt;= 1
            if not exp:
                break
            self *= self
        return result

    def popcnt(self) -&gt; int:
        return Int[64](self).popcnt()

    @nocapture
    @llvm
    def __atomic_xchg__(d: Ptr[int], b: int) -&gt; None:
        %tmp = atomicrmw xchg ptr %d, i64 %b seq_cst
        ret {} {}

    @nocapture
    @llvm
    def __atomic_add__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw add ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_sub__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw sub ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_and__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw and ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_nand__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw nand ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_or__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw or ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_xor__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw xor ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_min__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw min ptr %d, i64 %b seq_cst
        ret i64 %tmp

    @nocapture
    @llvm
    def __atomic_max__(d: Ptr[int], b: int) -&gt; int:
        %tmp = atomicrmw max ptr %d, i64 %b seq_cst
        ret i64 %tmp

    def __match__(self, i: int) -&gt; bool:
        return self == i

    @property
    def real(self) -&gt; int:
        return self

    @property
    def imag(self) -&gt; int:
        return 0
</t>
<t tx="ekr.20230509083243.1284">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

from internal.attributes import commutative, associative, distributive

def check_N(N: Static[int]):
    if N &lt;= 0:
        compile_error("N must be greater than 0")
    pass

@extend
class Int:
    def __new__() -&gt; Int[N]:
        check_N(N)
        return Int[N](0)

    def __new__(what: Int[N]) -&gt; Int[N]:
        check_N(N)
        return what

    def __new__(what: int) -&gt; Int[N]:
        check_N(N)
        if N &lt; 64:
            return __internal__.int_trunc(what, 64, N)
        elif N == 64:
            return what
        else:
            return __internal__.int_sext(what, 64, N)

    @pure
    @llvm
    def __new__(what: UInt[N]) -&gt; Int[N]:
        ret i{=N} %what

    def __new__(what: str) -&gt; Int[N]:
        check_N(N)
        ret = Int[N]()
        i = 0
        sign = Int[N](1)
        if i &lt; what.len and what.ptr[0] == byte(45):
            sign = Int[N](-1)
            i += 1
        while i &lt; what.len:
            if what.ptr[i] &lt; byte(48) or what.ptr[i] &gt;= byte(58):
                raise ValueError("Invalid integer string")
            ret = ret * Int[N](10) + Int[N](int(what.ptr[i]) - 48)
            i += 1
        return sign * ret

    def __int__(self) -&gt; int:
        if N &gt; 64:
            return __internal__.int_trunc(self, N, 64)
        elif N == 64:
            return self
        else:
            return __internal__.int_sext(self, N, 64)

    def __index__(self) -&gt; int:
        return int(self)

    def __copy__(self) -&gt; Int[N]:
        return self

    def __deepcopy__(self) -&gt; Int[N]:
        return self

    def __hash__(self) -&gt; int:
        return int(self)

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %0 = sitofp i{=N} %self to double
        ret double %0

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = icmp ne i{=N} %self, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __pos__(self) -&gt; Int[N]:
        return self

    @pure
    @llvm
    def __neg__(self) -&gt; Int[N]:
        %0 = sub i{=N} 0, %self
        ret i{=N} %0

    @pure
    @llvm
    def __invert__(self) -&gt; Int[N]:
        %0 = xor i{=N} %self, -1
        ret i{=N} %0

    @pure
    @llvm
    def __abs__(self) -&gt; Int[N]:
        declare i{=N} @llvm.abs.i{=N}(i{=N}, i1)
        %0 = call i{=N} @llvm.abs.i{=N}(i{=N} %self, i1 false)
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @llvm
    def __add__(self, other: Int[N]) -&gt; Int[N]:
        %0 = add i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __sub__(self, other: Int[N]) -&gt; Int[N]:
        %0 = sub i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @distributive
    @llvm
    def __mul__(self, other: Int[N]) -&gt; Int[N]:
        %0 = mul i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def _floordiv(self, other: Int[N]) -&gt; Int[N]:
        %0 = sdiv i{=N} %self, %other
        ret i{=N} %0
    def __floordiv__(self, other: Int[N]) -&gt; Int[N]:
        if N &gt; 128:
            compile_error("division is not supported on Int[N] when N &gt; 128")
        return self._floordiv(other)

    @pure
    @llvm
    def __truediv__(self, other: Int[N]) -&gt; float:
        %0 = sitofp i{=N} %self to double
        %1 = sitofp i{=N} %other to double
        %2 = fdiv double %0, %1
        ret double %2

    @pure
    @llvm
    def _mod(self, other: Int[N]) -&gt; Int[N]:
        %0 = srem i{=N} %self, %other
        ret i{=N} %0
    def __mod__(self, other: Int[N]) -&gt; Int[N]:
        if N &gt; 128:
            compile_error("modulus is not supported on Int[N] when N &gt; 128")
        return self._mod(other)

    def __divmod__(self, other: Int[N]) -&gt; Tuple[Int[N], Int[N]]:
        d = self // other
        m = self - d * other
        if m and ((other ^ m) &lt; Int[N](0)):
            m += other
            d -= Int[N](1)
        return (d, m)

    @pure
    @llvm
    def __lshift__(self, other: Int[N]) -&gt; Int[N]:
        %0 = shl i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __rshift__(self, other: Int[N]) -&gt; Int[N]:
        %0 = ashr i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __eq__(self, other: Int[N]) -&gt; bool:
        %0 = icmp eq i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ne__(self, other: Int[N]) -&gt; bool:
        %0 = icmp ne i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __lt__(self, other: Int[N]) -&gt; bool:
        %0 = icmp slt i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __gt__(self, other: Int[N]) -&gt; bool:
        %0 = icmp sgt i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __le__(self, other: Int[N]) -&gt; bool:
        %0 = icmp sle i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ge__(self, other: Int[N]) -&gt; bool:
        %0 = icmp sge i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @commutative
    @associative
    @llvm
    def __and__(self, other: Int[N]) -&gt; Int[N]:
        %0 = and i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @llvm
    def __or__(self, other: Int[N]) -&gt; Int[N]:
        %0 = or i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @llvm
    def __xor__(self, other: Int[N]) -&gt; Int[N]:
        %0 = xor i{=N} %self, %other
        ret i{=N} %0

    def __pow__(self, exp: Int[N]) -&gt; Int[N]:
        zero = Int[N](0)
        one = Int[N](1)

        if exp &lt; zero:
            return zero
        result = one
        while True:
            if exp &amp; one:
                result *= self
            exp &gt;&gt;= one
            if not exp:
                break
            self *= self
        return result

    def __repr__(self) -&gt; str:
        return f"Int[{N}]({self.__str__()})"

    @pure
    @llvm
    def _popcnt(self) -&gt; Int[N]:
        declare i{=N} @llvm.ctpop.i{=N}(i{=N})
        %0 = call i{=N} @llvm.ctpop.i{=N}(i{=N} %self)
        ret i{=N} %0

    def popcnt(self) -&gt; int:
        return int(self._popcnt())

    def len() -&gt; int:
        return N


@extend
class UInt:
    def __new__() -&gt; UInt[N]:
        check_N(N)
        return UInt[N](0)

    def __new__(what: UInt[N]) -&gt; UInt[N]:
        check_N(N)
        return what

    def __new__(what: int) -&gt; UInt[N]:
        check_N(N)
        if N &lt; 64:
            return UInt[N](__internal__.int_trunc(what, 64, N))
        elif N == 64:
            return UInt[N](Int[N](what))
        else:
            return UInt[N](__internal__.int_sext(what, 64, N))

    @pure
    @llvm
    def __new__(what: Int[N]) -&gt; UInt[N]:
        ret i{=N} %what

    def __new__(what: str) -&gt; UInt[N]:
        check_N(N)
        return UInt[N](Int[N](what))

    def __int__(self) -&gt; int:
        if N &gt; 64:
            return __internal__.int_trunc(self, N, 64)
        elif N == 64:
            return Int[64](self)
        else:
            return __internal__.int_zext(self, N, 64)

    def __index__(self) -&gt; int:
        return int(self)

    def __copy__(self) -&gt; UInt[N]:
        return self

    def __deepcopy__(self) -&gt; UInt[N]:
        return self

    def __hash__(self) -&gt; int:
        return int(self)

    @pure
    @llvm
    def __float__(self) -&gt; float:
        %0 = uitofp i{=N} %self to double
        ret double %0

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = icmp ne i{=N} %self, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __pos__(self) -&gt; UInt[N]:
        return self

    @pure
    @llvm
    def __neg__(self) -&gt; UInt[N]:
        %0 = sub i{=N} 0, %self
        ret i{=N} %0

    @pure
    @llvm
    def __invert__(self) -&gt; UInt[N]:
        %0 = xor i{=N} %self, -1
        ret i{=N} %0

    def __abs__(self) -&gt; UInt[N]:
        return self

    @pure
    @commutative
    @associative
    @llvm
    def __add__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = add i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __sub__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = sub i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @distributive
    @llvm
    def __mul__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = mul i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def _floordiv(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = udiv i{=N} %self, %other
        ret i{=N} %0
    def __floordiv__(self, other: UInt[N]) -&gt; UInt[N]:
        if N &gt; 128:
            compile_error("division is not supported on UInt[N] when N &gt; 128")
        return self._floordiv(other)

    @pure
    @llvm
    def __truediv__(self, other: UInt[N]) -&gt; float:
        %0 = uitofp i{=N} %self to double
        %1 = uitofp i{=N} %other to double
        %2 = fdiv double %0, %1
        ret double %2

    @pure
    @llvm
    def _mod(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = urem i{=N} %self, %other
        ret i{=N} %0
    def __mod__(self, other: UInt[N]) -&gt; UInt[N]:
        if N &gt; 128:
            compile_error("modulus is not supported on UInt[N] when N &gt; 128")
        return self._mod(other)

    def __divmod__(self, other: UInt[N]) -&gt; Tuple[UInt[N], UInt[N]]:
        return (self // other, self % other)

    @pure
    @llvm
    def __lshift__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = shl i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __rshift__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = lshr i{=N} %self, %other
        ret i{=N} %0

    @pure
    @llvm
    def __eq__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp eq i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ne__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp ne i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __lt__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp ult i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __gt__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp ugt i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __le__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp ule i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ge__(self, other: UInt[N]) -&gt; bool:
        %0 = icmp uge i{=N} %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @commutative
    @associative
    @llvm
    def __and__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = and i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @llvm
    def __or__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = or i{=N} %self, %other
        ret i{=N} %0

    @pure
    @commutative
    @associative
    @llvm
    def __xor__(self, other: UInt[N]) -&gt; UInt[N]:
        %0 = xor i{=N} %self, %other
        ret i{=N} %0

    def __pow__(self, exp: UInt[N]) -&gt; UInt[N]:
        zero = UInt[N](0)
        one = UInt[N](1)

        if exp &lt; zero:
            return zero
        result = one
        while True:
            if exp &amp; one:
                result *= self
            exp &gt;&gt;= one
            if not exp:
                break
            self *= self
        return result

    def __repr__(self) -&gt; str:
        return f"UInt[{N}]({self.__str__()})"

    def popcnt(self) -&gt; int:
        return int(Int[N](self)._popcnt())

    def len() -&gt; int:
        return N

i8 = Int[8]
i16 = Int[16]
i32 = Int[32]
i64 = Int[64]
u8 = UInt[8]
u16 = UInt[16]
u32 = UInt[32]
u64 = UInt[64]
</t>
<t tx="ekr.20230509083243.1285">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@extend
class Optional:
    def __new__() -&gt; Optional[T]:
        if isinstance(T, ByVal):
            return __internal__.opt_tuple_new(T)
        else:
            return __internal__.opt_ref_new(T)

    def __new__(what: T) -&gt; Optional[T]:
        if isinstance(T, ByVal):
            return __internal__.opt_tuple_new_arg(what, T)
        else:
            return __internal__.opt_ref_new_arg(what, T)

    def __has__(self) -&gt; bool:
        if isinstance(T, ByVal):
            return __internal__.opt_tuple_bool(self, T)
        else:
            return __internal__.opt_ref_bool(self, T)

    def __val__(self) -&gt; T:
        if isinstance(T, ByVal):
            return __internal__.opt_tuple_invert(self, T)
        else:
            return __internal__.opt_ref_invert(self, T)

    def __val_or__(self, default: T):
        if self.__has__():
            return self.__val__()
        return default

    def __bool__(self) -&gt; bool:
        if not self.__has__():
            return False
        if hasattr(self.__val__(), "__bool__"):
            return self.__val__().__bool__()
        else:
            return True

    def __eq__(self, other: T) -&gt; bool:
        if self is None:
            return False
        return self.__val__() == other

    def __eq__(self, other: Optional[T]) -&gt; bool:
        if (self is None) or (other is None):
            return (self is None) and (other is None)
        return self.__val__() == other.__val__()

    def __ne__(self, other: T) -&gt; bool:
        if self is None:
            return True
        return self.__val__() != other

    def __ne__(self, other: Optional[T]) -&gt; bool:
        if (self is None) or (other is None):
            return not ((self is None) and (other is None))
        return self.__val__() != other.__val__()

    def __str__(self) -&gt; str:
        return "None" if self is None else str(self.__val__())

    def __repr__(self) -&gt; str:
        return "None" if self is None else self.__val__().__repr__()

    def __is_optional__(self, other: Optional[T]) -&gt; bool:
        self_has = self.__has__()
        other_has = other.__has__()
        if (not self_has) or (not other_has):
            return (not self_has) and (not other_has)
        return self.__val__() is other.__val__()

optional = Optional

def unwrap(opt: Optional[T], T: type) -&gt; T:
    if opt.__has__():
        return opt.__val__()
    raise ValueError("optional is None")
</t>
<t tx="ekr.20230509083243.1286">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@extend
class Ptr:
    @pure
    @llvm
    def __new__() -&gt; Ptr[T]:
        ret ptr null

    @__internal__
    def __new__(sz: int) -&gt; Ptr[T]:
        pass

    @pure
    @derives
    @llvm
    def __new__(other: Ptr[T]) -&gt; Ptr[T]:
        ret ptr %other

    @pure
    @derives
    @llvm
    def __new__(other: Ptr[byte]) -&gt; Ptr[T]:
        ret ptr %other

    @pure
    @llvm
    def __int__(self) -&gt; int:
        %0 = ptrtoint ptr %self to i64
        ret i64 %0

    @pure
    @llvm
    def __copy__(self) -&gt; Ptr[T]:
        ret ptr %self

    @pure
    @llvm
    def __bool__(self) -&gt; bool:
        %0 = icmp ne ptr %self, null
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @derives
    @llvm
    def __getitem__(self, index: int) -&gt; T:
        %0 = getelementptr {=T}, ptr %self, i64 %index
        %1 = load {=T}, ptr %0
        ret {=T} %1

    @self_captures
    @llvm
    def __setitem__(self, index: int, what: T) -&gt; None:
        %0 = getelementptr {=T}, ptr %self, i64 %index
        store {=T} %what, ptr %0
        ret {} {}

    @pure
    @derives
    @llvm
    def __add__(self, other: int) -&gt; Ptr[T]:
        %0 = getelementptr {=T}, ptr %self, i64 %other
        ret ptr %0

    @pure
    @llvm
    def __sub__(self, other: Ptr[T]) -&gt; int:
        %0 = ptrtoint ptr %self to i64
        %1 = ptrtoint ptr %other to i64
        %2 = sub i64 %0, %1
        %3 = sdiv exact i64 %2, ptrtoint (ptr getelementptr ({=T}, {=T}* null, i32 1) to i64)
        ret i64 %3

    @pure
    @derives
    @llvm
    def __sub__(self, other: int) -&gt; Ptr[T]:
        %0 = sub i64 0, %other
        %1 = getelementptr {=T}, {=T}* %self, i64 %0
        ret {=T}* %1

    @pure
    @llvm
    def __eq__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp eq ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ne__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp ne ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __lt__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp slt ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __gt__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp sgt ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __le__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp sle ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @pure
    @llvm
    def __ge__(self, other: Ptr[T]) -&gt; bool:
        %0 = icmp sge ptr %self, %other
        %1 = zext i1 %0 to i8
        ret i8 %1

    @nocapture
    @llvm
    def __prefetch_r0__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 0, i32 0, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_r1__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 0, i32 1, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_r2__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 0, i32 2, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_r3__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 0, i32 3, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_w0__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 1, i32 0, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_w1__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 1, i32 1, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_w2__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 1, i32 2, i32 1)
        ret {} {}

    @nocapture
    @llvm
    def __prefetch_w3__(self) -&gt; None:
        declare void @llvm.prefetch(ptr nocapture readonly, i32, i32, i32)
        call void @llvm.prefetch(ptr %self, i32 1, i32 3, i32 1)
        ret {} {}

    @pure
    @derives
    @llvm
    def as_byte(self) -&gt; Ptr[byte]:
        ret ptr %self

    def __repr__(self) -&gt; str:
        return self.__format__("")

ptr = Ptr
Jar = Ptr[byte]

# Forward declarations
class List:
    len: int
    arr: Array[T]
    T: type

@extend
class NoneType:
    def __new__() -&gt; NoneType:
        return ()

    def __eq__(self, other: NoneType):
        return True

    def __ne__(self, other: NoneType):
        return False

    def __bool__(self) -&gt; bool:
        return False

    def __repr__(self) -&gt; str:
        return "None"
</t>
<t tx="ekr.20230509083243.1287">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple
class range:
    start: int
    stop: int
    step: int

    # Magic methods

    def __new__(start: int, stop: int, step: int) -&gt; range:
        if step == 0:
            raise ValueError("range() step argument must not be zero")
        return (start, stop, step)

    def __new__(start: int, stop: int) -&gt; range:
        return (start, stop, 1)

    def __new__(stop: int) -&gt; range:
        return (0, stop, 1)

    def _get(self, idx: int) -&gt; int:
        return self.start + (idx * self.step)

    def __getitem__(self, idx: int) -&gt; int:
        n = self.__len__()
        if idx &lt; 0:
            idx += n
        if idx &lt; 0 or idx &gt;= n:
            raise IndexError("range object index out of range")
        return self._get(idx)

    def __getitem__(self, s: Slice) -&gt; range:
        if s.start is None and s.stop is None and s.step is None:
            return self
        else:
            start, stop, step, length = s.adjust_indices(self.__len__())
            substep = self.step * step
            substart = self._get(start)
            substop = self._get(stop)
            return range(substart, substop, substep)

    def __contains__(self, idx: int) -&gt; bool:
        start, stop, step = self.start, self.stop, self.step
        if (step &gt; 0 and not (start &lt;= idx &lt; stop)) or (
            step &lt; 0 and not (stop &lt; idx &lt;= start)
        ):
            return False
        return (idx - start) % step == 0

    def _index(self, n: int) -&gt; int:
        return (n - self.start) // self.step

    def index(self, n: int) -&gt; int:
        if n in self:
            return self._index(n)
        else:
            raise ValueError(str(n) + " is not in range")

    def count(self, n: int) -&gt; int:
        return int(n in self)

    def __iter__(self) -&gt; Generator[int]:
        start, stop, step = self.start, self.stop, self.step
        i = start
        if step &gt; 0:
            while i &lt; stop:
                yield i
                i += step
        else:
            while i &gt; stop:
                yield i
                i += step

    def __len__(self) -&gt; int:
        start, stop, step = self.start, self.stop, self.step
        if step &gt; 0 and start &lt; stop:
            return 1 + (stop - 1 - start) // step
        elif step &lt; 0 and start &gt; stop:
            return 1 + (start - 1 - stop) // (-step)
        else:
            return 0

    def __bool__(self) -&gt; bool:
        return self.__len__() &gt; 0

    def __reversed__(self) -&gt; Generator[int]:
        start, stop, step = self.start, self.stop, self.step
        n = self.__len__()
        return range(start + (n - 1) * step, start - step, -step).__iter__()

    def __repr__(self) -&gt; str:
        if self.step == 1:
            return f"range({self.start}, {self.stop})"
        else:
            return f"range({self.start}, {self.stop}, {self.step})"

@overload
def staticrange(start: Static[int], stop: Static[int], step: Static[int] = 1):
    return range(start, stop, step)

@overload
def staticrange(stop: Static[int]):
    return range(0, stop, 1)
</t>
<t tx="ekr.20230509083243.1288">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple
class Slice:
    start: Optional[int]
    stop: Optional[int]
    step: Optional[int]

    def adjust_indices(self, length: int) -&gt; Tuple[int, int, int, int]:
        step: int = self.step if self.step is not None else 1
        start: int = 0
        stop: int = 0
        if step == 0:
            raise ValueError("slice step cannot be zero")
        if step &gt; 0:
            start = self.start if self.start is not None else 0
            stop = self.stop if self.stop is not None else length
        else:
            start = self.start if self.start is not None else length - 1
            stop = self.stop if self.stop is not None else -(length + 1)

        return Slice.adjust_indices_helper(length, start, stop, step)

    def adjust_indices_helper(
        length: int, start: int, stop: int, step: int
    ) -&gt; Tuple[int, int, int, int]:
        if start &lt; 0:
            start += length
            if start &lt; 0:
                start = -1 if step &lt; 0 else 0
        elif start &gt;= length:
            start = length - 1 if step &lt; 0 else length

        if stop &lt; 0:
            stop += length
            if stop &lt; 0:
                stop = -1 if step &lt; 0 else 0
        elif stop &gt;= length:
            stop = length - 1 if step &lt; 0 else length

        if step &lt; 0:
            if stop &lt; start:
                return start, stop, step, (start - stop - 1) // (-step) + 1
        else:
            if start &lt; stop:
                return start, stop, step, (stop - start - 1) // step + 1

        return start, stop, step, 0

    def __repr__(self):
        return f"slice({self.start}, {self.stop}, {self.step})"

slice = Slice
</t>
<t tx="ekr.20230509083243.1289">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@pure
@C
def strlen(a: cobj) -&gt; int:
    pass

@extend
class str:
    @__internal__
    def __new__(l: int, p: Ptr[byte]) -&gt; str:
        pass

    def __new__(p: Ptr[byte], l: int) -&gt; str:
        return str(l, p)

    def __new__() -&gt; str:
        return str(Ptr[byte](), 0)

    def __new__(what) -&gt; str:
        if hasattr(what, "__str__"):
            return what.__str__()
        else:
            return what.__repr__()

    def __str__(what: str) -&gt; str:
        return what

    def __len__(self) -&gt; int:
        return self.len

    def __bool__(self) -&gt; bool:
        return self.len != 0

    def __copy__(self) -&gt; str:
        return self

    def __deepcopy__(self) -&gt; str:
        return self

    def __ptrcopy__(self) -&gt; str:
        n = self.len
        p = cobj(n)
        str.memcpy(p, self.ptr, n)
        return str(p, n)

    @llvm
    def memcpy(dest: Ptr[byte], src: Ptr[byte], len: int) -&gt; None:
        declare void @llvm.memcpy.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 %align, i1 %isvolatile)
        call void @llvm.memcpy.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 0, i1 false)
        ret {} {}

    @llvm
    def memmove(dest: Ptr[byte], src: Ptr[byte], len: int) -&gt; None:
        declare void @llvm.memmove.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 %align, i1 %isvolatile)
        call void @llvm.memmove.p0i8.p0i8.i64(ptr %dest, ptr %src, i64 %len, i32 0, i1 false)
        ret {} {}

    @llvm
    def memset(dest: Ptr[byte], val: byte, len: int) -&gt; None:
        declare void @llvm.memset.p0i8.i64(ptr %dest, i8 %val, i64 %len, i32 %align, i1 %isvolatile)
        call void @llvm.memset.p0i8.i64(ptr %dest, i8 %val, i64 %len, i32 0, i1 false)
        ret {} {}

    def __add__(self, other: str) -&gt; str:
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = Ptr[byte](len3)
        str.memcpy(p, self.ptr, len1)
        str.memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

    def c_str(self) -&gt; cobj:
        n = self.__len__()
        p = cobj(n + 1)
        str.memcpy(p, self.ptr, n)
        p[n] = byte(0)
        return p

    def from_ptr(t: cobj) -&gt; str:
        n = strlen(t)
        p = Ptr[byte](n)
        str.memcpy(p, t, n)
        return str(p, n)

    def __eq__(self, other: str) -&gt; bool:
        if self.len != other.len:
            return False
        i = 0
        while i &lt; self.len:
            if self.ptr[i] != other.ptr[i]:
                return False
            i += 1
        return True

    def __match__(self, other: str) -&gt; bool:
        return self.__eq__(other)

    def __ne__(self, other: str) -&gt; bool:
        return not self.__eq__(other)

    def cat(*args) -&gt; str:
        total = 0
        if (
            staticlen(args) == 1
            and hasattr(args[0], "__iter__")
            and hasattr(args[0], "__len__")
        ):
            for s in args[0]:
                if not isinstance(s, str):
                    compile_error("not a string")
                total += s.len
            p = cobj(total)
            n = 0
            for s in args[0]:
                str.memcpy(p + n, s.ptr, s.len)
                n += s.len
            return str(p, total)
        elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
            sz = 10
            p = cobj(sz)
            n = 0
            for s in args[0]:
                if not isinstance(s, str):
                    compile_error("not a string")
                if n + s.len &gt; sz:
                    sz = 1 + 3 * (n + s.len) // 2
                    pp = cobj(sz)
                    str.memcpy(pp, p, n)
                    p = pp
                str.memcpy(p + n, s.ptr, s.len)
                n += s.len
            return str(p, n)
        else:
            total = 0
            for i in args:
                if not isinstance(i, str):
                    compile_error("not a string")
                total += i.len
            p = cobj(total)
            n = 0
            for i in args:
                str.memcpy(p + n, i.ptr, i.len)
                n += i.len
            return str(p, total)
</t>
<t tx="ekr.20230509083243.129">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;vector&gt;

namespace codon {
namespace ir {
namespace util {

/// Base for CIR visitor contexts.
template &lt;typename Frame&gt; class CIRContext {
private:
  std::vector&lt;Frame&gt; frames;

public:
  /// Emplaces a frame onto the stack.
  /// @param args a parameter pack of the arguments
  template &lt;typename... Args&gt; void emplaceFrame(Args... args) {
    frames.emplace_back(args...);
  }
@others
  /// @return all frames
  std::vector&lt;Frame&gt; &amp;getFrames() { return frames; }
  /// @return the current frame
  Frame &amp;getFrame() { return frames.back(); }
  /// Pops a frame.
  void popFrame() { return frames.pop_back(); }
};

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.1290">@path C:/Repos/codon/stdlib/internal/types/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

class strbuf:
    data: Ptr[byte]
    n: int
    m: int

    def __init__(self, capacity: int = 16):
        self.data = Ptr[byte](capacity)
        self.n = 0
        self.m = capacity

    def append(self, s: str):
        from internal.gc import realloc
        adding = s.__len__()
        needed = self.n + adding
        if needed &gt; self.m:
            m = self.m
            while m &lt; needed:
                m *= 2
            self.data = realloc(self.data, m, self.m)
            self.m = m
        str.memcpy(self.data + self.n, s.ptr, adding)
        self.n = needed

    def reverse(self):
        a = 0
        b = self.n - 1
        p = self.data
        while a &lt; b:
            p[a], p[b] = p[b], p[a]
            a += 1
            b -= 1

    def __str__(self):
        return str(self.data, self.n)
</t>
<t tx="ekr.20230509083243.1291"></t>
<t tx="ekr.20230509083243.1292">@path C:/Repos/codon/stdlib/internal/types/collections/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# dict implementation based on klib's khash

import internal.khash as khash
import internal.gc as gc

def _dict_hash(key) -&gt; int:
    k = key.__hash__()
    return (k &gt;&gt; 33) ^ k ^ (k &lt;&lt; 11)

class Dict:
    _n_buckets: int
    _size: int
    _n_occupied: int
    _upper_bound: int

    _flags: Ptr[u32]
    _keys: Ptr[K]
    _vals: Ptr[V]

    K: type
    V: type

    # Magic methods

    def _init(self):
        self._n_buckets = 0
        self._size = 0
        self._n_occupied = 0
        self._upper_bound = 0
        self._flags = Ptr[u32]()
        self._keys = Ptr[K]()
        self._vals = Ptr[V]()

    def _init_from(self, other):
        n = other._n_buckets

        if n == 0:
            self._init()
            return

        f = khash.__ac_fsize(n)
        self._n_buckets = n
        self._size = other._size
        self._n_occupied = other._n_occupied
        self._upper_bound = other._upper_bound

        flags_copy = Ptr[u32](f)
        keys_copy = Ptr[K](n)
        vals_copy = Ptr[V](n)
        str.memcpy(flags_copy.as_byte(), other._flags.as_byte(), f * gc.sizeof(u32))
        str.memcpy(keys_copy.as_byte(), other._keys.as_byte(), n * gc.sizeof(K))
        str.memcpy(vals_copy.as_byte(), other._vals.as_byte(), n * gc.sizeof(V))

        self._flags = flags_copy
        self._keys = keys_copy
        self._vals = vals_copy

    def __init__(self):
        self._init()

    def __init__(self, g: Generator[Tuple[K, V]]):
        self._init()
        for k, v in g:
            self[k] = v

    def __init__(self, other: Dict[K, V]):
        self._init_from(other)

    def __getitem__(self, key: K) -&gt; V:
        x = self._kh_get(key)
        if x != self._kh_end():
            return self._vals[x]
        raise KeyError(str(key))

    def __setitem__(self, key: K, val: V):
        ret, x = self._kh_put(key)
        self._vals[x] = val

    def __delitem__(self, key: K):
        x = self._kh_get(key)
        if x != self._kh_end():
            self._kh_del(x)
        else:
            raise KeyError(str(key))

    def __contains__(self, key: K) -&gt; bool:
        return self._kh_get(key) != self._kh_end()

    def __eq__(self, other: Dict[K, V]) -&gt; bool:
        if self.__len__() != other.__len__():
            return False
        for k, v in self.items():
            if k not in other or other[k] != v:
                return False
        return True

    def __ne__(self, other: Dict[K, V]) -&gt; bool:
        return not (self == other)

    def __iter__(self) -&gt; Generator[K]:
        return self.keys()

    def __len__(self) -&gt; int:
        return self._size

    def __or__(self, other):
        new = self.__copy__()
        new.update(other)
        return new

    def __ior__(self, other):
        self.update(other)
        return self

    def __copy__(self):
        if self.__len__() == 0:
            return Dict[K, V]()
        n = self._n_buckets
        f = khash.__ac_fsize(n)
        flags_copy = Ptr[u32](f)
        keys_copy = Ptr[K](n)
        vals_copy = Ptr[V](n)
        str.memcpy(flags_copy.as_byte(), self._flags.as_byte(), f * gc.sizeof(u32))
        str.memcpy(keys_copy.as_byte(), self._keys.as_byte(), n * gc.sizeof(K))
        str.memcpy(vals_copy.as_byte(), self._vals.as_byte(), n * gc.sizeof(V))
        return Dict[K, V](
            n,
            self._size,
            self._n_occupied,
            self._upper_bound,
            flags_copy,
            keys_copy,
            vals_copy,
        )

    def __deepcopy__(self) -&gt; Dict[K, V]:
        return {k.__deepcopy__(): v.__deepcopy__() for k, v in self.items()}

    def __repr__(self) -&gt; str:
        n = self.__len__()
        if n == 0:
            return "{}"
        else:
            buf = _strbuf()
            buf.append("{")
            first = True
            for k, v in self.items():
                if not first:
                    buf.append(", ")
                else:
                    first = False
                buf.append(k.__repr__())
                buf.append(": ")
                buf.append(v.__repr__())
            buf.append("}")
            return buf.__str__()

    # Helper methods

    def resize(self, new_n_buckets: int):
        self._kh_resize(new_n_buckets)

    def get(self, key: K, s: V) -&gt; V:
        x = self._kh_get(key)
        return self._vals[x] if x != self._kh_end() else s

    def setdefault(self, key: K, val: V) -&gt; V:
        ret, x = self._kh_put(key)
        if ret != 0:  # i.e. key not present
            self._vals[x] = val
            return val
        return self._vals[x]

    def increment(self, key: K, by: T = 1, T: type):
        ret, x = self._kh_put(key)
        if ret != 0:  # i.e. key not present
            self._vals[x] = by
        else:
            self._vals[x] += by

    def __dict_do_op_throws__(self, key: K, other: Z, op: F, F: type, Z: type):
        x = self._kh_get(key)
        if x == self._kh_end():
            raise KeyError(str(key))
        else:
            self._vals[x] = op(self._vals[x], other)

    def __dict_do_op__(self, key: K, other: Z, dflt: V, op: F, F: type, Z: type):
        ret, x = self._kh_put(key)
        self._vals[x] = op(dflt if ret != 0 else self._vals[x], other)

    def update(self, other):
        if isinstance(other, Dict[K, V]):
            for k, v in other.items():
                self[k] = v
        else:
            for k, v in other:
                self[k] = v

    def pop(self, key: K) -&gt; V:
        x = self._kh_get(key)
        if x != self._kh_end():
            v = self._vals[x]
            self._kh_del(x)
            return v
        raise KeyError(str(key))

    def popitem(self) -&gt; Tuple[K, V]:
        for k in self:
            return (k, self.pop(k))
        raise KeyError("dictionary is empty")

    def clear(self):
        self._kh_clear()

    def items(self) -&gt; Generator[Tuple[K, V]]:
        i = self._kh_begin()
        while i &lt; self._kh_end():
            if self._kh_exist(i):
                yield self._keys[i], self._vals[i]
            i += 1

    def keys(self) -&gt; Generator[K]:
        for k, v in self.items():
            yield k

    def values(self) -&gt; Generator[V]:
        for k, v in self.items():
            yield v

    def copy(self):
        return self.__copy__()

    def fromkeys(ks: Generator[K], v: V, K: type, V: type) -&gt; Dict[K, V]:
        return {k: v for k in ks}

    # Internal helpers

    def _kh_clear(self):
        if self._flags:
            i = 0
            n = khash.__ac_fsize(self._n_buckets)
            while i &lt; n:
                self._flags[i] = u32(0xAAAAAAAA)
                i += 1
            self._size = 0
            self._n_occupied = 0

    def _kh_get(self, key: K) -&gt; int:
        if self._n_buckets:
            step = 0
            mask = self._n_buckets - 1
            k = _dict_hash(key)
            i = k &amp; mask
            last = i
            while not khash.__ac_isempty(self._flags, i) and (
                khash.__ac_isdel(self._flags, i) or self._keys[i] != key
            ):
                step += 1
                i = (i + step) &amp; mask
                if i == last:
                    return self._n_buckets
            return self._n_buckets if khash.__ac_iseither(self._flags, i) else i
        else:
            return 0

    def _kh_resize(self, new_n_buckets: int):
        HASH_UPPER = 0.77
        new_flags = Ptr[u32]()
        j = 1

        # round up to next power of 2
        new_n_buckets -= 1
        new_n_buckets |= new_n_buckets &gt;&gt; 1
        new_n_buckets |= new_n_buckets &gt;&gt; 2
        new_n_buckets |= new_n_buckets &gt;&gt; 4
        new_n_buckets |= new_n_buckets &gt;&gt; 8
        new_n_buckets |= new_n_buckets &gt;&gt; 16
        new_n_buckets |= new_n_buckets &gt;&gt; 32
        new_n_buckets += 1

        if new_n_buckets &lt; 4:
            new_n_buckets = 4

        if self._size &gt;= int(new_n_buckets * HASH_UPPER + 0.5):
            j = 0
        else:
            fsize = khash.__ac_fsize(new_n_buckets)
            new_flags = Ptr[u32](fsize)
            i = 0
            while i &lt; fsize:
                new_flags[i] = u32(0xAAAAAAAA)
                i += 1

            if self._n_buckets &lt; new_n_buckets:
                self._keys = Ptr[K](
                    gc.realloc(self._keys.as_byte(),
                               new_n_buckets * gc.sizeof(K),
                               self._n_buckets * gc.sizeof(K))
                )
                self._vals = Ptr[V](
                    gc.realloc(self._vals.as_byte(),
                               new_n_buckets * gc.sizeof(V),
                               self._n_buckets * gc.sizeof(V))
                )

        if j:
            j = 0
            while j != self._n_buckets:
                if khash.__ac_iseither(self._flags, j) == 0:
                    key = self._keys[j]
                    val = self._vals[j]
                    new_mask = new_n_buckets - 1
                    khash.__ac_set_isdel_true(self._flags, j)

                    while True:
                        step = 0
                        k = _dict_hash(key)
                        i = k &amp; new_mask

                        while not khash.__ac_isempty(new_flags, i):
                            step += 1
                            i = (i + step) &amp; new_mask

                        khash.__ac_set_isempty_false(new_flags, i)
                        if (
                            i &lt; self._n_buckets
                            and khash.__ac_iseither(self._flags, i) == 0
                        ):
                            self._keys[i], key = key, self._keys[i]
                            self._vals[i], val = val, self._vals[i]
                            khash.__ac_set_isdel_true(self._flags, i)
                        else:
                            self._keys[i] = key
                            self._vals[i] = val
                            break
                j += 1

            if self._n_buckets &gt; new_n_buckets:
                self._keys = Ptr[K](
                    gc.realloc(self._keys.as_byte(),
                               new_n_buckets * gc.sizeof(K),
                               self._n_buckets * gc.sizeof(K))
                )
                self._vals = Ptr[V](
                    gc.realloc(self._vals.as_byte(),
                               new_n_buckets * gc.sizeof(V),
                               self._n_buckets * gc.sizeof(V))
                )

            self._flags = new_flags
            self._n_buckets = new_n_buckets
            self._n_occupied = self._size
            self._upper_bound = int(self._n_buckets * HASH_UPPER + 0.5)

    def _kh_put(self, key: K) -&gt; Tuple[int, int]:
        if self._n_occupied &gt;= self._upper_bound:
            if self._n_buckets &gt; (self._size &lt;&lt; 1):
                self._kh_resize(self._n_buckets - 1)
            else:
                self._kh_resize(self._n_buckets + 1)

        mask = self._n_buckets - 1
        step = 0
        site = self._n_buckets
        x = site
        k = _dict_hash(key)
        i = k &amp; mask
        if khash.__ac_isempty(self._flags, i):
            x = i
        else:
            last = i
            while not khash.__ac_isempty(self._flags, i) and (
                khash.__ac_isdel(self._flags, i) or self._keys[i] != key
            ):
                if khash.__ac_isdel(self._flags, i):
                    site = i
                step += 1
                i = (i + step) &amp; mask
                if i == last:
                    x = site
                    break

            if x == self._n_buckets:
                if khash.__ac_isempty(self._flags, i) and site != self._n_buckets:
                    x = site
                else:
                    x = i

        ret = 0
        if khash.__ac_isempty(self._flags, x):
            self._keys[x] = key
            khash.__ac_set_isboth_false(self._flags, x)
            self._size += 1
            self._n_occupied += 1
            ret = 1
        elif khash.__ac_isdel(self._flags, x):
            self._keys[x] = key
            khash.__ac_set_isboth_false(self._flags, x)
            self._size += 1
            ret = 2

        return (ret, x)

    def _kh_del(self, x: int):
        if x != self._n_buckets and not khash.__ac_iseither(self._flags, x):
            khash.__ac_set_isdel_true(self._flags, x)
            self._size -= 1

    def _kh_begin(self) -&gt; int:
        return 0

    def _kh_end(self) -&gt; int:
        return self._n_buckets

    def _kh_exist(self, x: int) -&gt; bool:
        return not khash.__ac_iseither(self._flags, x)

dict = Dict
</t>
<t tx="ekr.20230509083243.1293">@path C:/Repos/codon/stdlib/internal/types/collections/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

import internal.gc as gc

@extend
class List:
    def __init__(self):
        self.arr = Array[T](10)
        self.len = 0

    def __init__(self, it: Generator[T]):
        self.arr = Array[T](10)
        self.len = 0
        for i in it:
            self.append(i)

    def __init__(self, other: List[T]):
        self.arr = Array[T](other.len)
        self.len = 0
        for i in other:
            self.append(i)

    def __init__(self, capacity: int):
        self.arr = Array[T](capacity)
        self.len = 0

    def __init__(self, arr: Array[T], len: int):
        self.arr = arr
        self.len = len

    def _get(self, idx: int):
        return self.arr.ptr[idx]

    def _set(self, idx: int, val: T):
        self.arr.ptr[idx] = val

    def __len__(self) -&gt; int:
        return self.len

    def __bool__(self) -&gt; bool:
        return self.__len__() &gt; 0

    def __getitem__(self, idx: int) -&gt; T:
        if idx &lt; 0:
            idx += self.__len__()
        self._idx_check(idx, "list index out of range")
        return self._get(idx)

    def __setitem__(self, idx: int, val: T):
        if idx &lt; 0:
            idx += self.__len__()
        self._idx_check(idx, "list assignment index out of range")
        self._set(idx, val)

    def __delitem__(self, idx: int):
        if idx &lt; 0:
            idx += self.__len__()
        self._idx_check(idx, "list assignment index out of range")
        while idx &lt; self.len - 1:
            self._set(idx, self._get(idx + 1))
            idx += 1
        self.len -= 1

    def __eq__(self, other: List[T]) -&gt; bool:
        if self.__len__() != other.__len__():
            return False
        for i in range(self.__len__()):
            if self._get(i) != other._get(i):
                return False
        return True

    def __ne__(self, other: List[T]) -&gt; bool:
        return not (self == other)

    def __getitem__(self, s: Slice) -&gt; List[T]:
        if s.start is None and s.stop is None and s.step is None:
            return self.__copy__()
        if s.step is None:
            start, stop, step, length = s.adjust_indices(self.__len__())
            return List[T](self._copy_arr(start, stop, length), length)
        else:
            start, stop, step, length = s.adjust_indices(self.__len__())
            other = List[T](length)
            for i in range(start, stop, step):
                other.append(self._get(i))
            return other

    def __setitem__(self, s: Slice, other):
        if s.start is None and s.stop is None and s.step is None:
            self.clear()
            for a in other:
                self.append(a)
            return

        start, stop, step, length = s.adjust_indices(self.__len__())
        if s.step is None or step == 1:
            if isinstance(other, List[T]):
                if other is self:
                    other = other.__copy__()
                self._assign_slice(start, stop, other.arr.ptr, other.__len__())
            else:
                items = [a for a in other]
                self._assign_slice(start, stop, items.arr.ptr, items.__len__())
        else:
            if (step &lt; 0 and start &lt; stop) or (step &gt; 0 and start &gt; stop):
                stop = start

            seq: Optional[List[T]] = None
            if isinstance(other, List[T]):
                if other is self:
                    seq = other.__copy__()
                else:
                    seq = other
            else:
                seq = [a for a in other]

            seq_len = seq.__len__()
            if seq_len != length:
                raise ValueError(
                    f"attempt to assign sequence of size {seq_len} to extended slice of size {length}"
                )

            if length == 0:
                return

            cur = start
            i = 0
            while i &lt; length:
                self._set(cur, seq._get(i))
                cur += step
                i += 1

    def __delitem__(self, s: Slice):
        if s.start is None and s.stop is None and s.step is None:
            self.clear()
        else:
            start, stop, step, length = s.adjust_indices(self.__len__())
            if s.step is None or step == 1:
                self._assign_slice(start, stop, Ptr[T](), 0)
            else:
                if length &lt; 0:
                    return

                if step &lt; 0:
                    stop = start + 1
                    start = stop + step * (length - 1) - 1
                    step = -step

                cur = start
                i = 0
                while cur &lt; stop:
                    lim = step - 1
                    if cur + step &gt; self.__len__():
                        lim = self.__len__() - cur - 1
                    str.memmove(
                        (self.arr.ptr + (cur - i)).as_byte(),
                        (self.arr.ptr + (cur + 1)).as_byte(),
                        lim * gc.sizeof(T),
                    )
                    cur += step
                    i += 1

                cur = start + length * step
                if cur &lt; self.__len__():
                    str.memmove(
                        (self.arr.ptr + (cur - length)).as_byte(),
                        (self.arr.ptr + cur).as_byte(),
                        (self.__len__() - cur) * gc.sizeof(T),
                    )

                self.len -= length
                # self._resize(self.__len__())

    def __contains__(self, x: T) -&gt; bool:
        for a in self:
            if a == x:
                return True
        return False

    def __copy__(self) -&gt; List[T]:
        return List[T](self.arr.__copy__(), self.len)

    def __deepcopy__(self) -&gt; List[T]:
        return [l.__deepcopy__() for l in self]

    def __iter__(self) -&gt; Generator[T]:
        i = 0
        N = self.len
        p = self.arr.ptr
        while i &lt; N:
            yield p[i]
            i += 1

    def __reversed__(self) -&gt; Generator[T]:
        i = self.len - 1
        while i &gt;= 0:
            yield self._get(i)
            i -= 1

    def __add__(self, other: List[T]) -&gt; List[T]:
        n = self.len + other.len
        v = List[T](n)
        v.len = n
        p = v.arr.ptr
        str.memcpy(p.as_byte(),
                   self.arr.ptr.as_byte(),
                   self.len * gc.sizeof(T))
        str.memcpy((p + self.len).as_byte(),
                   other.arr.ptr.as_byte(),
                   other.len * gc.sizeof(T))
        return v

    def __iadd__(self, other: List[T]) -&gt; List[T]:
        n = self.len + other.len
        if self.arr.len &lt; n:
            self._resize(n)
        str.memcpy((self.arr.ptr + self.len).as_byte(),
                   other.arr.ptr.as_byte(),
                   other.len * gc.sizeof(T))
        self.len = n
        return self

    def __mul__(self, n: int) -&gt; List[T]:
        if n &lt;= 0:
            return List[T]()

        new_len = self.len * n
        v = List[T](new_len)
        i = 0
        while i &lt; n:
            j = 0
            while j &lt; self.len:
                v.append(self._get(j))
                j += 1
            i += 1
        return v

    def __rmul__(self, n: int) -&gt; List[T]:
        return self.__mul__(n)

    def __imul__(self, n: int) -&gt; List[T]:
        if n == 1:
            return self

        if n &lt;= 0:
            self.clear()
            return self

        len0 = self.__len__()
        new_cap = n * len0
        if self.arr.len &lt; new_cap:
            p = Ptr[T](gc.realloc(self.arr.ptr.as_byte(),
                                  new_cap * gc.sizeof(T),
                                  self.arr.len * gc.sizeof(T)))
            self.arr = Array[T](p, new_cap)

        idx = len0
        i = 0
        while i &lt; n - 1:
            j = 0
            while j &lt; len0:
                self._set(idx, self._get(j))
                idx += 1
                j += 1
            i += 1

        self.len = new_cap
        return self

    def __repr__(self) -&gt; str:
        n = self.__len__()
        if n == 0:
            return "[]"
        else:
            buf = _strbuf()
            buf.append("[")
            buf.append(self._get(0).__repr__())
            for i in range(1, n):
                buf.append(", ")
                buf.append(self._get(i).__repr__())
            buf.append("]")
            return buf.__str__()

    # Helper functions

    def append(self, x: T):
        self._resize_if_full()
        self._set(self.len, x)
        self.len += 1

    def extend(self, itr: Generator[T]):
        for a in itr:
            self.append(a)

    def insert(self, idx: int, x: T):
        n = self.__len__()
        if idx &lt; 0:
            idx += n
            if idx &lt; 0:
                idx = 0
        if idx &gt; n:
            idx = n
        self._resize_if_full()
        i = n
        while i &gt; idx:
            self._set(i, self._get(i - 1))
            i -= 1
        self._set(idx, x)
        self.len += 1

    def pop(self, idx: int = -1) -&gt; T:
        if self.__len__() == 0:
            raise IndexError("pop from empty list")
        if idx &lt; 0:
            idx += self.__len__()
        self._idx_check(idx, "pop index out of range")
        x = self._get(idx)
        del self[idx]
        return x

    def remove(self, x: T) -&gt; bool:
        i = 0
        for a in self:
            if a == x:
                del self[i]
                return True
            i += 1
        return False

    def clear(self):
        self.len = 0

    def index(self, x: T) -&gt; int:
        i = 0
        for a in self:
            if a == x:
                return i
            i += 1
        return -1

    def count(self, x: T) -&gt; int:
        count = 0
        for a in self:
            if a == x:
                count += 1
        return count

    def reverse(self):
        i = 0
        while i &lt; self.len // 2:
            j = self.len - i - 1
            x = self._get(i)
            self._set(i, self._get(j))
            self._set(j, x)
            i += 1

    def copy(self) -&gt; List[T]:
        return self.__copy__()

    # Internal helpers

    def _idx_check(self, idx: int, msg: str):
        if idx &gt;= self.len or idx &lt; 0:
            raise IndexError(msg)

    def _resize(self, new_cap: int):
        p = Ptr[T](gc.realloc(self.arr.ptr.as_byte(),
                              new_cap * gc.sizeof(T),
                              self.arr.len * gc.sizeof(T)))
        self.arr = Array[T](p, new_cap)

    def _resize_if_full(self):
        if self.len == self.arr.len:
            new_cap = (1 + 3 * self.len) // 2
            self._resize(new_cap)

    def __hash__(self) -&gt; int:
        # https://www.boost.org/doc/libs/1_35_0/doc/html/boost/hash_combine_id241013.html
        seed = 0
        for v in self:
            seed ^= v.__hash__() + 0x9E3779B9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2)
        return seed

    def _assign_slice(self, ilow: int, ihigh: int, v: Ptr[T], n: int):
        a = self
        L = a.len

        if ilow &lt; 0:
            ilow = 0
        elif ilow &gt; L:
            ilow = L

        if ihigh &lt; ilow:
            ihigh = ilow
        elif ihigh &gt; L:
            ihigh = L

        norig = ihigh - ilow
        assert norig &gt;= 0
        d = n - norig
        if L + d == 0:
            a.clear()
            return

        if d &lt; 0:
            tail = L - ihigh
            str.memmove(
                (a.arr.ptr + (ihigh + d)).as_byte(),
                (a.arr.ptr + ihigh).as_byte(),
                tail * gc.sizeof(T),
            )
            a._resize(L + d)
        elif d &gt; 0:
            k = L
            a._resize(k + d)
            str.memmove(
                (a.arr.ptr + (ihigh + d)).as_byte(),
                (a.arr.ptr + ihigh).as_byte(),
                (k - ihigh) * gc.sizeof(T),
            )

        k = 0
        while k &lt; n:
            a._set(ilow, v[k])
            k += 1
            ilow += 1
        a.len += d

    def _copy_arr(self, start: int, stop: int, length: int) -&gt; Array[T]:
        if length &lt;= 0:
            return Array[T](Ptr[T](), 0)
        return self.arr.slice(start, stop).__copy__()

    def _cmp(self, other: List[T]):
        n1 = self.__len__()
        n2 = other.__len__()
        nmin = n1 if n1 &lt; n2 else n2
        for i in range(nmin):
            a = self._get(i)
            b = other._get(i)

            if a &lt; b:
                return -1
            elif a == b:
                continue
            else:
                return 1
        if n1 &lt; n2:
            return -1
        elif n1 == n2:
            return 0
        else:
            return 1

    def __lt__(self, other: List[T]):
        return self._cmp(other) &lt; 0

    def __gt__(self, other: List[T]):
        return self._cmp(other) &gt; 0

    def __le__(self, other: List[T]):
        return self._cmp(other) &lt;= 0

    def __ge__(self, other: List[T]):
        return self._cmp(other) &gt;= 0

    # list addition optimization helpers

    def _list_add_opt_default_len(v: List[T]):
        return v.__len__()

    def _list_add_opt_default_append(ans: List[T], v: List[T]):
        from internal.gc import sizeof
        n = v.__len__()
        str.memcpy((ans.arr.ptr + ans.len).as_byte(), v.arr.ptr.as_byte(), n * sizeof(T))
        ans.len += n

    def _list_add_opt_slice_len(v: List[T], s: Slice):
        if s.start is None and s.stop is None and s.step is None:
            return v.__len__()
        start, stop, step, length = s.adjust_indices(v.__len__())
        return length

    def _list_add_opt_slice_append(ans: List[T], v: List[T], s: Slice):
        from internal.gc import sizeof
        if s.start is None and s.stop is None and s.step is None:
            n = v.__len__()
            str.memcpy((ans.arr.ptr + ans.len).as_byte(), v.arr.ptr.as_byte(), n * sizeof(T))
            ans.len += n
        elif s.step is None:
            start, stop, step, length = s.adjust_indices(v.__len__())
            n = stop - start
            str.memcpy((ans.arr.ptr + ans.len).as_byte(), (v.arr.ptr + start).as_byte(), n * sizeof(T))
            ans.len += n
        else:
            start, stop, step, length = s.adjust_indices(v.__len__())
            for i in range(start, stop, step):
                ans.arr.ptr[ans.len] = v._get(i)
                ans.len += 1

    def _list_add_opt_literal_append(ans: List[T], elem: T):
        ans.arr.ptr[ans.len] = elem
        ans.len += 1

    def _list_add_opt_opt_new(capacity: int):
        return List[T](capacity=capacity)

list = List
</t>
<t tx="ekr.20230509083243.1294">@path C:/Repos/codon/stdlib/internal/types/collections/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;
# set implementation based on klib's khash

from internal.attributes import commutative, associative
import internal.khash as khash
import internal.gc as gc

def _set_hash(key) -&gt; int:
    k = key.__hash__()
    return (k &gt;&gt; 33) ^ k ^ (k &lt;&lt; 11)

class Set:
    _n_buckets: int
    _size: int
    _n_occupied: int
    _upper_bound: int

    _flags: Ptr[u32]
    _keys: Ptr[K]

    K: type

    # Magic methods
    def _init(self):
        self._n_buckets = 0
        self._size = 0
        self._n_occupied = 0
        self._upper_bound = 0
        self._flags = Ptr[u32]()
        self._keys = Ptr[K]()

    def __init__(self):
        self._init()

    def __init__(self, g: Generator[K]):
        self._init()
        for a in g:
            self.add(a)

    def __sub__(self, other: Set[K]) -&gt; Set[K]:
        return self.difference(other)

    def __isub__(self, other: Set[K]) -&gt; Set[K]:
        self.difference_update(other)
        return self

    @commutative
    @associative
    def __and__(self, other: Set[K]) -&gt; Set[K]:
        return self.intersection(other)

    def __iand__(self, other: Set[K]) -&gt; Set[K]:
        self.intersection_update(other)
        return self

    @commutative
    @associative
    def __or__(self, other: Set[K]) -&gt; Set[K]:
        return self.union(other)

    def __ior__(self, other: Set[K]) -&gt; Set[K]:
        for a in other:
            self.add(a)
        return self

    @commutative
    @associative
    def __xor__(self, other: Set[K]) -&gt; Set[K]:
        return self.symmetric_difference(other)

    def __ixor__(self, other: Set[K]) -&gt; Set[K]:
        self.symmetric_difference_update(other)
        return self

    def __contains__(self, key: K) -&gt; bool:
        return self._kh_get(key) != self._kh_end()

    def __eq__(self, other: Set[K]) -&gt; bool:
        if self.__len__() != other.__len__():
            return False
        for k in self:
            if k not in other:
                return False
        return True

    def __ne__(self, other: Set[K]) -&gt; bool:
        return not (self == other)

    def __le__(self, other: Set[K]) -&gt; bool:
        return self.issubset(other)

    def __ge__(self, other: Set[K]) -&gt; bool:
        return self.issuperset(other)

    def __lt__(self, other: Set[K]) -&gt; bool:
        return self != other and self &lt;= other

    def __gt__(self, other: Set[K]) -&gt; bool:
        return self != other and self &gt;= other

    def __iter__(self) -&gt; Generator[K]:
        i = self._kh_begin()
        while i &lt; self._kh_end():
            if self._kh_exist(i):
                yield self._keys[i]
            i += 1

    def __len__(self) -&gt; int:
        return self._size

    def __bool__(self) -&gt; bool:
        return self.__len__() != 0

    def __copy__(self) -&gt; Set[K]:
        if self.__len__() == 0:
            return Set[K]()
        n = self._n_buckets
        f = khash.__ac_fsize(n)
        flags_copy = Ptr[u32](f)
        keys_copy = Ptr[K](n)
        str.memcpy(flags_copy.as_byte(), self._flags.as_byte(), f * gc.sizeof(u32))
        str.memcpy(keys_copy.as_byte(), self._keys.as_byte(), n * gc.sizeof(K))
        return Set[K](
            n, self._size, self._n_occupied, self._upper_bound, flags_copy, keys_copy
        )

    def __deepcopy__(self) -&gt; Set[K]:
        return {s.__deepcopy__() for s in self}

    def __repr__(self) -&gt; str:
        n = self.__len__()
        if n == 0:
            return "set()"
        else:
            buf = _strbuf()
            buf.append("{")
            first = True
            for k in self:
                if not first:
                    buf.append(", ")
                else:
                    first = False
                buf.append(k.__repr__())
            buf.append("}")
            return buf.__str__()

    # Helper methods

    def resize(self, new_n_buckets: int):
        self._kh_resize(new_n_buckets)

    def add(self, key: K):
        self._kh_put(key)

    def update(self, other: Generator[K]):
        for k in other:
            self.add(k)

    def remove(self, key: K):
        x = self._kh_get(key)
        if x != self._kh_end():
            self._kh_del(x)
        else:
            raise KeyError(str(key))

    def pop(self) -&gt; K:
        if self.__len__() == 0:
            raise ValueError("empty set")
        for a in self:
            self.remove(a)
            return a

    def discard(self, key: K):
        x = self._kh_get(key)
        if x != self._kh_end():
            self._kh_del(x)

    def difference(self, other: Set[K]) -&gt; Set[K]:
        s = Set[K]()
        for a in self:
            if a not in other:
                s.add(a)
        return s

    def difference_update(self, other: Set[K]):
        for a in other:
            self.discard(a)

    def intersection(self, other: Set[K]) -&gt; Set[K]:
        if other.__len__() &lt; self.__len__():
            self, other = other, self
        s = Set[K]()
        for a in self:
            if a in other:
                s.add(a)
        return s

    def intersection_update(self, other: Set[K]):
        for a in self:
            if a not in other:
                self.discard(a)

    def symmetric_difference(self, other: Set[K]) -&gt; Set[K]:
        s = Set[K]()
        for a in self:
            if a not in other:
                s.add(a)
        for a in other:
            if a not in self:
                s.add(a)
        return s

    def symmetric_difference_update(self, other: Set[K]):
        for a in other:
            if a in self:
                self.discard(a)
        for a in self:
            if a in other:
                self.discard(a)

    def union(self, other: Set[K]) -&gt; Set[K]:
        s = Set[K]()
        s.resize(
            self._n_buckets if self._n_buckets &gt;= other._n_buckets else other._n_buckets
        )
        for a in self:
            s.add(a)
        for a in other:
            s.add(a)
        return s

    def isdisjoint(self, other: Set[K]) -&gt; bool:
        if other.__len__() &lt; self.__len__():
            self, other = other, self
        for a in self:
            if a in other:
                return False
        return True

    def issubset(self, other: Set[K]) -&gt; bool:
        if other.__len__() &lt; self.__len__():
            return False
        for a in self:
            if a not in other:
                return False
        return True

    def issuperset(self, other: Set[K]) -&gt; bool:
        return other.issubset(self)

    def clear(self):
        self._kh_clear()

    def copy(self) -&gt; Set[K]:
        return self.__copy__()

    # Internal helpers

    def _kh_clear(self):
        if self._flags:
            i = 0
            n = khash.__ac_fsize(self._n_buckets)
            while i &lt; n:
                self._flags[i] = u32(0xAAAAAAAA)
                i += 1
            self._size = 0
            self._n_occupied = 0

    def _kh_get(self, key: K) -&gt; int:
        if self._n_buckets:
            step = 0
            mask = self._n_buckets - 1
            k = _set_hash(key)
            i = k &amp; mask
            last = i
            while not khash.__ac_isempty(self._flags, i) and (
                khash.__ac_isdel(self._flags, i) or self._keys[i] != key
            ):
                step += 1
                i = (i + step) &amp; mask
                if i == last:
                    return self._n_buckets
            return self._n_buckets if khash.__ac_iseither(self._flags, i) else i
        else:
            return 0

    def _kh_resize(self, new_n_buckets: int):
        HASH_UPPER = 0.77
        new_flags = Ptr[u32]()
        j = 1

        # round up to next power of 2
        new_n_buckets -= 1
        new_n_buckets |= new_n_buckets &gt;&gt; 1
        new_n_buckets |= new_n_buckets &gt;&gt; 2
        new_n_buckets |= new_n_buckets &gt;&gt; 4
        new_n_buckets |= new_n_buckets &gt;&gt; 8
        new_n_buckets |= new_n_buckets &gt;&gt; 16
        new_n_buckets |= new_n_buckets &gt;&gt; 32
        new_n_buckets += 1

        if new_n_buckets &lt; 4:
            new_n_buckets = 4

        if self._size &gt;= int(new_n_buckets * HASH_UPPER + 0.5):
            j = 0
        else:
            fsize = khash.__ac_fsize(new_n_buckets)
            new_flags = Ptr[u32](fsize)
            i = 0
            while i &lt; fsize:
                new_flags[i] = u32(0xAAAAAAAA)
                i += 1

            if self._n_buckets &lt; new_n_buckets:
                self._keys = Ptr[K](
                    gc.realloc(self._keys.as_byte(),
                               new_n_buckets * gc.sizeof(K),
                               self._n_buckets * gc.sizeof(K))
                )

        if j:
            j = 0
            while j != self._n_buckets:
                if khash.__ac_iseither(self._flags, j) == 0:
                    key = self._keys[j]
                    new_mask = new_n_buckets - 1
                    khash.__ac_set_isdel_true(self._flags, j)

                    while True:
                        step = 0
                        k = _set_hash(key)
                        i = k &amp; new_mask

                        while not khash.__ac_isempty(new_flags, i):
                            step += 1
                            i = (i + step) &amp; new_mask

                        khash.__ac_set_isempty_false(new_flags, i)
                        if (
                            i &lt; self._n_buckets
                            and khash.__ac_iseither(self._flags, i) == 0
                        ):
                            self._keys[i], key = key, self._keys[i]
                            khash.__ac_set_isdel_true(self._flags, i)
                        else:
                            self._keys[i] = key
                            break
                j += 1

            if self._n_buckets &gt; new_n_buckets:
                self._keys = Ptr[K](
                    gc.realloc(self._keys.as_byte(),
                               new_n_buckets * gc.sizeof(K),
                               self._n_buckets * gc.sizeof(K))
                )

            self._flags = new_flags
            self._n_buckets = new_n_buckets
            self._n_occupied = self._size
            self._upper_bound = int(self._n_buckets * HASH_UPPER + 0.5)

    def _kh_put(self, key: K) -&gt; Tuple[int, int]:
        if self._n_occupied &gt;= self._upper_bound:
            if self._n_buckets &gt; (self._size &lt;&lt; 1):
                self._kh_resize(self._n_buckets - 1)
            else:
                self._kh_resize(self._n_buckets + 1)

        mask = self._n_buckets - 1
        step = 0
        site = self._n_buckets
        x = site
        k = _set_hash(key)
        i = k &amp; mask
        if khash.__ac_isempty(self._flags, i):
            x = i
        else:
            last = i
            while not khash.__ac_isempty(self._flags, i) and (
                khash.__ac_isdel(self._flags, i) or self._keys[i] != key
            ):
                if khash.__ac_isdel(self._flags, i):
                    site = i
                step += 1
                i = (i + step) &amp; mask
                if i == last:
                    x = site
                    break

            if x == self._n_buckets:
                if khash.__ac_isempty(self._flags, i) and site != self._n_buckets:
                    x = site
                else:
                    x = i

        ret = 0
        if khash.__ac_isempty(self._flags, x):
            self._keys[x] = key
            khash.__ac_set_isboth_false(self._flags, x)
            self._size += 1
            self._n_occupied += 1
            ret = 1
        elif khash.__ac_isdel(self._flags, x):
            self._keys[x] = key
            khash.__ac_set_isboth_false(self._flags, x)
            self._size += 1
            ret = 2

        return (ret, x)

    def _kh_del(self, x: int):
        if x != self._n_buckets and not khash.__ac_iseither(self._flags, x):
            khash.__ac_set_isdel_true(self._flags, x)
            self._size -= 1

    def _kh_begin(self) -&gt; int:
        return 0

    def _kh_end(self) -&gt; int:
        return self._n_buckets

    def _kh_exist(self, x: int) -&gt; bool:
        return not khash.__ac_iseither(self._flags, x)

set = Set
</t>
<t tx="ekr.20230509083243.1295">@path C:/Repos/codon/stdlib/internal/types/collections/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

@tuple
class DynamicTuple:
    _ptr: Ptr[T]
    _len: int
    T: type

    def __new__(x: List[T]):
        from internal.gc import sizeof
        n = x.__len__()
        p = Ptr[T](n)
        str.memcpy(p.as_byte(), x.arr.ptr.as_byte(), n * sizeof(T))
        return DynamicTuple(p, n)

    def __new__(x: Generator[T]):
        from internal.gc import realloc, sizeof
        n = 0
        m = 0
        if hasattr(x, "__len__"):
            m = x.__len__()
        elif hasattr(x, "__length_hint__"):
            m = x.__length_hint__()
        else:
            m = 10
        p = Ptr[T](m)
        for a in x:
            if n == m:
                new_m = (1 + 3*m) // 2
                p = Ptr[T](realloc(p.as_byte(), new_m * sizeof(T), m * sizeof(T)))
                m = new_m
            p[n] = a
            n += 1

        return DynamicTuple(p, n)

    def __new__():
        return DynamicTuple(Ptr[T](), 0)

    def __len__(self):
        return self._len

    def __bool__(self):
        return self._len &gt; 0

    def _ensure_tuple(x):
        if not isinstance(x, Tuple):
            compile_error("expected tuple type")

    def __eq__(self, other):
        DynamicTuple._ensure_tuple(other)

        p = self._ptr
        n = self._len

        if staticlen(other) == 0:
            return n == 0

        if n != staticlen(other):
            return False

        for i in range(n):
            if p[i] != other[i]:
                return False

        return True

    def __eq__(self, other: DynamicTuple[T]):
        p = self._ptr
        n = self._len
        q = other._ptr
        m = other._len

        if n != m:
            return False

        for i in range(n):
            if p[i] != q[i]:
                return False

        return True

    def __ne__(self, other):
        DynamicTuple._ensure_tuple(other)
        return not (self == other)

    def __ne__(self, other: DynamicTuple[T]):
        return not (self == other)

    def _cmp(self, other):
        DynamicTuple._ensure_tuple(other)
        p = self._ptr
        n = self._len

        if staticlen(other) == 0:
            return (1 if n &gt; 0 else 0)

        m = staticlen(other)

        for i in range(n if n &lt; m else m):
            a = p[i]
            b = other[i]

            if a &lt; b:
                return -1
            elif a == b:
                pass
            else:
                return 1

        if n &lt; m:
            return -1
        elif n == m:
            return 0
        else:
            return 1

    def _cmp(self, other: DynamicTuple[T]):
        p = self._ptr
        n = self._len
        q = other._ptr
        m = other._len

        for i in range(n if n &lt; m else m):
            a = p[i]
            b = q[i]

            if a &lt; b:
                return -1
            elif a == b:
                pass
            else:
                return 1

        if n &lt; m:
            return -1
        elif n == m:
            return 0
        else:
            return 1

    def __lt__(self, other):
        return self._cmp(other) &lt; 0

    def __gt__(self, other):
        return self._cmp(other) &gt; 0

    def __le__(self, other):
        return self._cmp(other) &lt;= 0

    def __ge__(self, other):
        return self._cmp(other) &gt;= 0

    def __lt__(self, other: DynamicTuple[T]):
        return self._cmp(other) &lt; 0

    def __gt__(self, other: DynamicTuple[T]):
        return self._cmp(other) &gt; 0

    def __le__(self, other: DynamicTuple[T]):
        return self._cmp(other) &lt;= 0

    def __ge__(self, other: DynamicTuple[T]):
        return self._cmp(other) &gt;= 0

    def __hash__(self):
        p = self._ptr
        n = self._len
        seed = 0
        for i in range(n):
            seed = seed ^ ((p[i].__hash__() + 2654435769) + ((seed &lt;&lt; 6) + (seed &gt;&gt; 2)))
        return seed

    def __iter__(self):
        p = self._ptr
        n = self._len
        for i in range(n):
            yield p[i]

    def __contains__(self, item: T):
        p = self._ptr
        n = self._len
        for i in range(n):
            if p[i] == item:
                return True
        return False

    def __getitem__(self, idx: int):
        p = self._ptr
        n = self._len
        if idx &lt; 0:
            idx += n
        if idx &lt; 0 or idx &gt;= n:
            raise IndexError(f"tuple index {idx} out of range 0..{n}")
        return p[idx]

    def __getitem__(self, s: Slice):
        p = self._ptr
        n = self._len

        if s.start is None and s.stop is None and s.step is None:
            return self
        if s.step is None:
            start, stop, step, length = s.adjust_indices(n)
            return DynamicTuple(p + start, length)
        else:
            start, stop, step, length = s.adjust_indices(n)
            q = Ptr[T](length)
            n = 0
            for i in range(start, stop, step):
                q[n] = self[i]
                n += 1
            return DynamicTuple(q, length)

    def __repr__(self):
        return f"({', '.join(a.__repr__() for a in self)})"
</t>
<t tx="ekr.20230509083243.1296"></t>
<t tx="ekr.20230509083243.1297">@path C:/Repos/codon/stdlib/os/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def splitext(p: str) -&gt; Tuple[str, str]:
    """
    Split the extension from a pathname.
    Extension is everything from the last dot to the end, ignoring
    leading dots.  Returns "(root, ext)"; ext may be empty."""
    sep = "/"
    extsep = "."

    sepIndex = p.rfind(sep)
    dotIndex = p.rfind(extsep)
    if dotIndex &gt; sepIndex:
        # skip all leading dots
        filenameIndex = sepIndex + 1
        while filenameIndex &lt; dotIndex:
            if p[filenameIndex : filenameIndex + 1] != extsep:
                return p[:dotIndex], p[dotIndex:]
            filenameIndex += 1
    return p, p[:0]
</t>
<t tx="ekr.20230509083243.1298">@path C:/Repos/codon/stdlib/os/
@language unknown_language
# Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

def system(cmd: str) -&gt; int:
    return _C.system(cmd.c_str())

SEEK_SET = 0
SEEK_CUR = 1
SEEK_END = 2

@tuple
class EnvMap:
    _map: Dict[str, str]

    def __new__() -&gt; EnvMap:
        return (Dict[str, str](),)

    def _init_if_needed(self):
        if len(self._map) == 0:
            env = _C.seq_env()
            p = env[0]
            i = 0
            while p:
                s = str.from_ptr(p)
                if s:
                    j = 0
                    found = False
                    while j &lt; len(s):
                        if s[j] == "=":
                            found = True
                            break
                        j += 1
                    k = s[0:j] if found else s
                    v = s[j + 1 :] if found else ""
                    self._map[k] = v
                i += 1
                p = env[i]

    def __getitem__(self, key: str) -&gt; str:
        self._init_if_needed()
        return self._map[key]

    def __repr__(self) -&gt; str:
        self._init_if_needed()
        return repr(self._map)

    def __contains__(self, key: str) -&gt; bool:
        self._init_if_needed()
        return key in self._map

    def __iter__(self) -&gt; Generator[Tuple[str, str]]:
        self._init_if_needed()
        return self._map.items()

environ = EnvMap()

def getenv(key: str, default: str = "") -&gt; str:
    return environ[key] if key in environ else default

def mkdir(name: str, mode: int = 0x1FF) -&gt; int:
    # TODO: use errno
    from C import mkdir(cobj, int) -&gt; int
    ret = mkdir(name.ptr, mode)
    if ret != 0:
        raise OSError("mkdir failed")
</t>
<t tx="ekr.20230509083243.1299"></t>
<t tx="ekr.20230509083243.13">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.130">  /// Replaces a frame.
  /// @param newFrame the new frame
  void replaceFrame(Frame newFrame) {
    frames.pop_back();
    frames.push_back(newFrame);
  }
</t>
<t tx="ekr.20230509083243.1300">@path C:/Repos/codon/test/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;algorithm&gt;
#include &lt;cstdio&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;fstream&gt;
#include &lt;gc.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;tuple&gt;
#include &lt;unistd.h&gt;
#include &lt;vector&gt;

#include "codon/cir/analyze/dataflow/capture.h"
#include "codon/cir/analyze/dataflow/reaching.h"
#include "codon/cir/util/inlining.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/operator.h"
#include "codon/cir/util/outlining.h"
#include "codon/compiler/compiler.h"
#include "codon/compiler/error.h"
#include "codon/parser/common.h"
#include "codon/util/common.h"

#include "gtest/gtest.h"

using namespace codon;
using namespace std;

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.131">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;algorithm&gt;
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;
#include &lt;sstream&gt;
#include &lt;unordered_set&gt;

#include "codon/cir/util/format.h"
#include "codon/cir/util/visitor.h"

namespace codon {
namespace ir {
namespace util {

struct NodeFormatter {
  const types::Type *type = nullptr;
  const Value *value = nullptr;
  const Var *var = nullptr;
  bool canShowFull = false;

  std::unordered_set&lt;id_t&gt; &amp;seenNodes;
  std::unordered_set&lt;std::string&gt; &amp;seenTypes;

  NodeFormatter(const types::Type *type, std::unordered_set&lt;id_t&gt; &amp;seenNodes,
                std::unordered_set&lt;std::string&gt; &amp;seenTypes)
      : type(type), seenNodes(seenNodes), seenTypes(seenTypes) {}

  NodeFormatter(const Value *value, std::unordered_set&lt;id_t&gt; &amp;seenNodes,
                std::unordered_set&lt;std::string&gt; &amp;seenTypes)
      : value(value), seenNodes(seenNodes), seenTypes(seenTypes) {}
  NodeFormatter(const Var *var, std::unordered_set&lt;id_t&gt; &amp;seenNodes,
                std::unordered_set&lt;std::string&gt; &amp;seenTypes)
      : var(var), seenNodes(seenNodes), seenTypes(seenTypes) {}

  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const NodeFormatter &amp;n);
};

namespace {
std::string escapeString(const std::string &amp;str) {
  std::stringstream escaped;
  for (char c : str) {
    switch (c) {
    case '\a':
      escaped &lt;&lt; "\\a";
      break;
    case '\b':
      escaped &lt;&lt; "\\b";
      break;
    case '\f':
      escaped &lt;&lt; "\\f";
      break;
    case '\n':
      escaped &lt;&lt; "\\n";
      break;
    case '\r':
      escaped &lt;&lt; "\\r";
      break;
    case '\t':
      escaped &lt;&lt; "\\t";
      break;
    case '\v':
      escaped &lt;&lt; "\\v";
      break;
    case '\\':
      escaped &lt;&lt; "\\\\";
      break;
    case '\'':
      escaped &lt;&lt; "\\'";
      break;
    case '\"':
      escaped &lt;&lt; "\\\"";
      break;
    case '\?':
      escaped &lt;&lt; "\\\?";
      break;
    default:
      escaped &lt;&lt; c;
    }
  }
  return escaped.str();
}

class FormatVisitor : util::ConstVisitor {
private:
  std::ostream &amp;os;
  std::unordered_set&lt;id_t&gt; &amp;seenNodes;
  std::unordered_set&lt;std::string&gt; &amp;seenTypes;

public:
  FormatVisitor(std::ostream &amp;os, std::unordered_set&lt;id_t&gt; &amp;seenNodes,
                std::unordered_set&lt;std::string&gt; &amp;seenTypes)
      : os(os), seenNodes(seenNodes), seenTypes(seenTypes) {}
  virtual ~FormatVisitor() noexcept = default;

  void visit(const Module *v) override {
    auto types = makeFormatters(v-&gt;types_begin(), v-&gt;types_end(), true);
    auto vars = makeFormatters(v-&gt;begin(), v-&gt;end(), true);
    fmt::print(os, FMT_STRING("(module\n(argv {})\n(types {})\n(vars {})\n{})"),
               makeFormatter(v-&gt;getArgVar(), true),
               fmt::join(types.begin(), types.end(), "\n"),
               fmt::join(vars.begin(), vars.end(), "\n"),
               makeFormatter(v-&gt;getMainFunc(), true));
  }

  void defaultVisit(const Node *) override { os &lt;&lt; "(unknown_node)"; }

  void visit(const Var *v) override {
    fmt::print(os, FMT_STRING("(var '\"{}\" {} (global {}) (external {}))"),
               v-&gt;referenceString(), makeFormatter(v-&gt;getType()), v-&gt;isGlobal(),
               v-&gt;isExternal());
  }

  void visit(const BodiedFunc *v) override {
    auto args = makeFormatters(v-&gt;arg_begin(), v-&gt;arg_end(), true);
    auto symbols = makeFormatters(v-&gt;begin(), v-&gt;end(), true);
    fmt::print(os, FMT_STRING("(bodied_func '\"{}\" {}\n(args {})\n(vars {})\n{})"),
               v-&gt;referenceString(), makeFormatter(v-&gt;getType()),
               fmt::join(args.begin(), args.end(), " "),
               fmt::join(symbols.begin(), symbols.end(), " "),
               makeFormatter(v-&gt;getBody()));
  }
  void visit(const ExternalFunc *v) override {
    fmt::print(os, FMT_STRING("(external_func '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getType()));
  }
  void visit(const InternalFunc *v) override {
    fmt::print(os, FMT_STRING("(internal_func '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getType()));
  }
  void visit(const LLVMFunc *v) override {
    std::vector&lt;std::string&gt; literals;

    for (auto it = v-&gt;literal_begin(); it != v-&gt;literal_end(); ++it) {
      const auto &amp;l = *it;
      if (l.isStatic()) {
        literals.push_back(fmt::format(FMT_STRING("(static {})"), l.getStaticValue()));
      } else if (l.isStaticStr()) {
        literals.push_back(
            fmt::format(FMT_STRING("(static \"{}\")"), l.getStaticStringValue()));
      } else {
        literals.push_back(
            fmt::format(FMT_STRING("(type {})"), makeFormatter(l.getTypeValue())));
      }
    }

    fmt::print(os,
               FMT_STRING("(llvm_func '\"{}\" {}\n(decls \"{}\")\n"
                          "\"{}\"\n(literals {}))"),
               v-&gt;referenceString(), makeFormatter(v-&gt;getType()),
               escapeString(v-&gt;getLLVMDeclarations()), escapeString(v-&gt;getLLVMBody()),
               fmt::join(literals.begin(), literals.end(), "\n"));
  }

  void visit(const VarValue *v) override {
    fmt::print(os, FMT_STRING("'\"{}\""), v-&gt;getVar()-&gt;referenceString());
  }
  void visit(const PointerValue *v) override {
    fmt::print(os, FMT_STRING("(ptr '\"{}\")"), v-&gt;getVar()-&gt;referenceString());
  }

  void visit(const SeriesFlow *v) override {
    auto series = makeFormatters(v-&gt;begin(), v-&gt;end());
    fmt::print(os, FMT_STRING("(series\n{}\n)"),
               fmt::join(series.begin(), series.end(), "\n"));
  }
  void visit(const IfFlow *v) override {
    fmt::print(os, FMT_STRING("(if {}\n{}\n{}\n)"), makeFormatter(v-&gt;getCond()),
               makeFormatter(v-&gt;getTrueBranch()), makeFormatter(v-&gt;getFalseBranch()));
  }
  void visit(const WhileFlow *v) override {
    fmt::print(os, FMT_STRING("(while {}\n{}\n)"), makeFormatter(v-&gt;getCond()),
               makeFormatter(v-&gt;getBody()));
  }
  void visit(const ForFlow *v) override {
    fmt::print(os, FMT_STRING("({}for {}\n{}\n{}\n)"), v-&gt;isParallel() ? "par_" : "",
               makeFormatter(v-&gt;getIter()), makeFormatter(v-&gt;getVar()),
               makeFormatter(v-&gt;getBody()));
  }
  void visit(const ImperativeForFlow *v) override {
    fmt::print(os, FMT_STRING("({}imp_for {}\n{}\n{}\n{}\n{}\n)"),
               v-&gt;isParallel() ? "par_" : "", makeFormatter(v-&gt;getStart()),
               v-&gt;getStep(), makeFormatter(v-&gt;getEnd()), makeFormatter(v-&gt;getVar()),
               makeFormatter(v-&gt;getBody()));
  }
  void visit(const TryCatchFlow *v) override {
    std::vector&lt;std::string&gt; catches;

    for (auto &amp;c : *v) {
      catches.push_back(
          fmt::format(FMT_STRING("(catch {} {}\n{}\n)"), makeFormatter(c.getType()),
                      makeFormatter(c.getVar()), makeFormatter(c.getHandler())));
    }

    fmt::print(os, FMT_STRING("(try {}\n{}\n(finally\n{}\n)\n)"),
               makeFormatter(v-&gt;getBody()),
               fmt::join(catches.begin(), catches.end(), "\n"),
               makeFormatter(v-&gt;getFinally()));
  }
  void visit(const PipelineFlow *v) override {
    std::vector&lt;std::string&gt; stages;
    for (const auto &amp;s : *v) {
      auto args = makeFormatters(s.begin(), s.end());
      stages.push_back(fmt::format(
          FMT_STRING("(stage {} {}\n(generator {})\n(parallel {}))"),
          makeFormatter(s.getCallee()), fmt::join(args.begin(), args.end(), "\n"),
          s.isGenerator(), s.isParallel()));
    }
    fmt::print(os, FMT_STRING("(pipeline {})"),
               fmt::join(stages.begin(), stages.end(), "\n"));
  }
  void visit(const dsl::CustomFlow *v) override { v-&gt;doFormat(os); }

  void visit(const IntConst *v) override {
    fmt::print(os, FMT_STRING("{}"), v-&gt;getVal());
  }
  void visit(const FloatConst *v) override {
    fmt::print(os, FMT_STRING("{}"), v-&gt;getVal());
  }
  void visit(const BoolConst *v) override {
    fmt::print(os, FMT_STRING("{}"), v-&gt;getVal());
  }
  void visit(const StringConst *v) override {
    fmt::print(os, FMT_STRING("\"{}\""), escapeString(v-&gt;getVal()));
  }
  void visit(const dsl::CustomConst *v) override { v-&gt;doFormat(os); }

  void visit(const AssignInstr *v) override {
    fmt::print(os, FMT_STRING("(assign {} {})"), makeFormatter(v-&gt;getLhs()),
               makeFormatter(v-&gt;getRhs()));
  }
  void visit(const ExtractInstr *v) override {
    fmt::print(os, FMT_STRING("(extract {} \"{}\")"), makeFormatter(v-&gt;getVal()),
               v-&gt;getField());
  }
  void visit(const InsertInstr *v) override {
    fmt::print(os, FMT_STRING("(insert {} \"{}\" {})"), makeFormatter(v-&gt;getLhs()),
               v-&gt;getField(), makeFormatter(v-&gt;getRhs()));
  }
  void visit(const CallInstr *v) override {
    auto args = makeFormatters(v-&gt;begin(), v-&gt;end());
    fmt::print(os, FMT_STRING("(call {}\n{}\n)"), makeFormatter(v-&gt;getCallee()),
               fmt::join(args.begin(), args.end(), "\n"));
  }
  void visit(const StackAllocInstr *v) override {
    fmt::print(os, FMT_STRING("(stack_alloc {} {})"), makeFormatter(v-&gt;getArrayType()),
               v-&gt;getCount());
  }
  void visit(const TypePropertyInstr *v) override {
    std::string property;
    if (v-&gt;getProperty() == TypePropertyInstr::Property::IS_ATOMIC) {
      property = "atomic";
    } else if (v-&gt;getProperty() == TypePropertyInstr::Property::SIZEOF) {
      property = "sizeof";
    } else {
      property = "unknown";
    }
    fmt::print(os, FMT_STRING("(property {} {})"), property,
               makeFormatter(v-&gt;getInspectType()));
  }
  void visit(const YieldInInstr *v) override {
    fmt::print(os, FMT_STRING("(yield_in {})"), makeFormatter(v-&gt;getType()));
  }
  void visit(const TernaryInstr *v) override {
    fmt::print(os, FMT_STRING("(select {}\n{}\n{}\n)"), makeFormatter(v-&gt;getCond()),
               makeFormatter(v-&gt;getTrueValue()), makeFormatter(v-&gt;getFalseValue()));
  }
  void visit(const BreakInstr *v) override {
    os &lt;&lt; "(break " &lt;&lt; (v-&gt;getLoop() ? v-&gt;getLoop()-&gt;getId() : -1) &lt;&lt; ')';
  }
  void visit(const ContinueInstr *v) override {
    os &lt;&lt; "(continue " &lt;&lt; (v-&gt;getLoop() ? v-&gt;getLoop()-&gt;getId() : -1) &lt;&lt; ')';
  }
  void visit(const ReturnInstr *v) override {
    fmt::print(os, FMT_STRING("(return {})"), makeFormatter(v-&gt;getValue()));
  }
  void visit(const YieldInstr *v) override {
    fmt::print(os, FMT_STRING("(yield {})"), makeFormatter(v-&gt;getValue()));
  }
  void visit(const ThrowInstr *v) override {
    fmt::print(os, FMT_STRING("(throw {})"), makeFormatter(v-&gt;getValue()));
  }
  void visit(const FlowInstr *v) override {
    fmt::print(os, FMT_STRING("(flow {} {})"), makeFormatter(v-&gt;getFlow()),
               makeFormatter(v-&gt;getValue()));
  }
  void visit(const dsl::CustomInstr *v) override { v-&gt;doFormat(os); }

  void visit(const types::IntType *v) override {
    fmt::print(os, FMT_STRING("(int '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::FloatType *v) override {
    fmt::print(os, FMT_STRING("(float '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::Float32Type *v) override {
    fmt::print(os, FMT_STRING("(float32 '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::BoolType *v) override {
    fmt::print(os, FMT_STRING("(bool '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::ByteType *v) override {
    fmt::print(os, FMT_STRING("(byte '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::VoidType *v) override {
    fmt::print(os, FMT_STRING("(void '\"{}\")"), v-&gt;referenceString());
  }
  void visit(const types::RecordType *v) override {
    std::vector&lt;std::string&gt; fields;
    std::vector&lt;NodeFormatter&gt; formatters;
    for (const auto &amp;m : *v) {
      fields.push_back(fmt::format(FMT_STRING("(\"{}\" {})"), m.getName(),
                                   makeFormatter(m.getType())));
    }

    fmt::print(os, FMT_STRING("(record '\"{}\" {})"), v-&gt;referenceString(),
               fmt::join(fields.begin(), fields.end(), " "));
  }
  void visit(const types::RefType *v) override {
    fmt::print(os, FMT_STRING("(ref '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getContents()));
  }
  void visit(const types::FuncType *v) override {
    auto args = makeFormatters(v-&gt;begin(), v-&gt;end());
    fmt::print(os, FMT_STRING("(func '\"{}\" {}{} {})"), v-&gt;referenceString(),
               fmt::join(args.begin(), args.end(), " "),
               (v-&gt;isVariadic() ? " ..." : ""), makeFormatter(v-&gt;getReturnType()));
  }
  void visit(const types::OptionalType *v) override {
    fmt::print(os, FMT_STRING("(optional '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getBase()));
  }
  void visit(const types::PointerType *v) override {
    fmt::print(os, FMT_STRING("(pointer '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getBase()));
  }
  void visit(const types::GeneratorType *v) override {
    fmt::print(os, FMT_STRING("(generator '\"{}\" {})"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getBase()));
  }
  void visit(const types::IntNType *v) override {
    fmt::print(os, FMT_STRING("(intn '\"{}\" {} (signed {}))"), v-&gt;referenceString(),
               v-&gt;getLen(), v-&gt;isSigned());
  }
  void visit(const types::VectorType *v) override {
    fmt::print(os, FMT_STRING("(vector '\"{}\" {} (count {}))"), v-&gt;referenceString(),
               makeFormatter(v-&gt;getBase()), v-&gt;getCount());
  }
  void visit(const types::UnionType *v) override {
    auto types = makeFormatters(v-&gt;begin(), v-&gt;end());
    fmt::print(os, FMT_STRING("(union '\"{}\" {})"), v-&gt;referenceString(),
               fmt::join(types.begin(), types.end(), " "));
  }
  void visit(const dsl::types::CustomType *v) override { v-&gt;doFormat(os); }

  void format(const Node *n) {
    if (n)
      n-&gt;accept(*this);
    else
      os &lt;&lt; "(null)";
  }

  void format(const types::Type *t, bool canShowFull = false) {
    if (t) {
      if (seenTypes.find(t-&gt;getName()) != seenTypes.end() || !canShowFull)
        fmt::print(os, FMT_STRING("(type '\"{}\")"), t-&gt;referenceString());
      else {
        seenTypes.insert(t-&gt;getName());
        t-&gt;accept(*this);
      }
    } else
      os &lt;&lt; "(null)";
  }

  void format(const Value *t) {
    if (t) {
      if (seenNodes.find(t-&gt;getId()) != seenNodes.end())
        fmt::print(os, FMT_STRING("(value '\"{}\")"), t-&gt;referenceString());
      else {
        seenNodes.insert(t-&gt;getId());
        t-&gt;accept(*this);
      }

    } else
      os &lt;&lt; "(null)";
  }

  void format(const Var *t, bool canShowFull = false) {
    if (t) {
      if (seenNodes.find(t-&gt;getId()) != seenNodes.end() || !canShowFull)
        fmt::print(os, FMT_STRING("(var '\"{}\")"), t-&gt;referenceString());
      else {
        seenNodes.insert(t-&gt;getId());
        t-&gt;accept(*this);
      }
    } else
      os &lt;&lt; "(null)";
  }

private:
  NodeFormatter makeFormatter(const types::Type *node, bool canShowFull = false) {
    auto ret = NodeFormatter(node, seenNodes, seenTypes);
    ret.canShowFull = canShowFull;
    return ret;
  }
  NodeFormatter makeFormatter(const Value *node) {
    return NodeFormatter(node, seenNodes, seenTypes);
  }
  NodeFormatter makeFormatter(const Var *node, bool canShowFull = false) {
    auto ret = NodeFormatter(node, seenNodes, seenTypes);
    ret.canShowFull = canShowFull;
    return ret;
  }

  template &lt;typename It&gt; std::vector&lt;NodeFormatter&gt; makeFormatters(It begin, It end) {
    std::vector&lt;NodeFormatter&gt; ret;
    while (begin != end) {
      ret.push_back(makeFormatter(*begin));
      ++begin;
    }
    return ret;
  }
  template &lt;typename It&gt;
  std::vector&lt;NodeFormatter&gt; makeFormatters(It begin, It end, bool canShowFull) {
    std::vector&lt;NodeFormatter&gt; ret;
    while (begin != end) {
      ret.push_back(makeFormatter(*begin, canShowFull));
      ++begin;
    }
    return ret;
  }
};
} // namespace

std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const NodeFormatter &amp;n) {
  FormatVisitor fv(os, n.seenNodes, n.seenTypes);
  if (n.type)
    fv.format(n.type, n.canShowFull);
  else if (n.value)
    fv.format(n.value);
  else
    fv.format(n.var, n.canShowFull);
  return os;
}

std::string format(const Node *node) {
  std::stringstream ss;
  format(ss, node);
  return ss.str();
}

std::ostream &amp;format(std::ostream &amp;os, const Node *node) {
  std::unordered_set&lt;id_t&gt; seenNodes;
  std::unordered_set&lt;std::string&gt; seenTypes;

  FormatVisitor fv(os, seenNodes, seenTypes);
  fv.format(node);

  return os;
}

} // namespace util
} // namespace ir
} // namespace codon

template &lt;&gt;
struct fmt::formatter&lt;codon::ir::util::NodeFormatter&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.132">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iostream&gt;

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Formats an IR node.
/// @param node the node
/// @return the formatted node
std::string format(const Node *node);

/// Formats an IR node to an IO stream.
/// @param os the output stream
/// @param node the node
/// @return the resulting output stream
std::ostream &amp;format(std::ostream &amp;os, const Node *node);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.133">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "inlining.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {
namespace util {

namespace {

@others
} // namespace

InlineResult inlineFunction(Func *func, std::vector&lt;Value *&gt; args, bool aggressive,
                            codon::SrcInfo info) {
  auto *bodied = cast&lt;BodiedFunc&gt;(func);
  if (!bodied)
    return {nullptr, {}};
  auto *fType = cast&lt;types::FuncType&gt;(bodied-&gt;getType());
  if (!fType || args.size() != std::distance(bodied-&gt;arg_begin(), bodied-&gt;arg_end()))
    return {nullptr, {}};
  auto *M = bodied-&gt;getModule();

  util::CloneVisitor cv(M);
  auto *newFlow = M-&gt;N&lt;SeriesFlow&gt;(info, bodied-&gt;getName() + "_inlined");

  std::vector&lt;Var *&gt; newVars;
  auto arg_it = bodied-&gt;arg_begin();
  for (auto i = 0; i &lt; args.size(); ++i) {
    newVars.push_back(cv.forceClone(*arg_it++));
    newFlow-&gt;push_back(M-&gt;N&lt;AssignInstr&gt;(info, newVars.back(), cv.clone(args[i])));
  }
  for (auto *v : *bodied) {
    newVars.push_back(cv.forceClone(v));
  }
  Var *retVal = nullptr;
  if (!fType-&gt;getReturnType()-&gt;is(M-&gt;getVoidType()) &amp;&amp;
      !fType-&gt;getReturnType()-&gt;is(M-&gt;getNoneType())) {
    retVal = M-&gt;N&lt;Var&gt;(info, fType-&gt;getReturnType());
    newVars.push_back(retVal);
  }

  Flow *clonedBody = cv.clone(bodied-&gt;getBody());

  ReturnVerifier rv;
  rv.process(clonedBody);

  if (!aggressive &amp;&amp; rv.needLoop)
    return {nullptr, {}};

  WhileFlow *implicit = nullptr;
  if (rv.needLoop) {
    auto *loopBody = M-&gt;N&lt;SeriesFlow&gt;(info);
    implicit = M-&gt;N&lt;WhileFlow&gt;(info, M-&gt;getBool(true), loopBody);
    loopBody-&gt;push_back(clonedBody);
    if (!retVal)
      loopBody-&gt;push_back(M-&gt;N&lt;BreakInstr&gt;(info, implicit));
  }

  ReturnReplacer rr(implicit, retVal, rv.needLoop, cv);
  rr.process(clonedBody);

  newFlow-&gt;push_back(implicit ? implicit : clonedBody);

  if (retVal) {
    return {M-&gt;N&lt;FlowInstr&gt;(info, newFlow, M-&gt;N&lt;VarValue&gt;(info, retVal)),
            std::move(newVars)};
  }
  return {newFlow, std::move(newVars)};
}

InlineResult inlineCall(CallInstr *v, bool aggressive) {
  return inlineFunction(util::getFunc(v-&gt;getCallee()),
                        std::vector&lt;Value *&gt;(v-&gt;begin(), v-&gt;end()), aggressive,
                        v-&gt;getSrcInfo());
}

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.134">class ReturnVerifier : public util::Operator {
public:
  bool needLoop = false;

@others
};

</t>
<t tx="ekr.20230509083243.135">  void handle(ReturnInstr *v) {
    if (needLoop) {
      return;
    }

    auto it = parent_begin();
    if (it == parent_end()) {
      needLoop = true;
      return;
    }

    SeriesFlow *prev = nullptr;
    while (it != parent_end()) {
      Value *v = cast&lt;Value&gt;(*it++);
      auto *cur = cast&lt;SeriesFlow&gt;(v);
      if (!cur || (prev &amp;&amp; prev-&gt;back()-&gt;getId() != cur-&gt;getId())) {
        needLoop = true;
        return;
      }
      prev = cur;
    }
    needLoop = prev-&gt;back()-&gt;getId() != v-&gt;getId();
  }
</t>
<t tx="ekr.20230509083243.136">class ReturnReplacer : public util::Operator {
private:
  Value *implicitLoop;
  Var *var;
  bool aggressive;
  util::CloneVisitor &amp;cv;

public:
  ReturnReplacer(Value *implicitLoop, Var *var, bool aggressive, util::CloneVisitor &amp;cv)
      : implicitLoop(implicitLoop), var(var), aggressive(aggressive), cv(cv) {}

@others
};

</t>
<t tx="ekr.20230509083243.137">  void handle(ReturnInstr *v) {
    auto *M = v-&gt;getModule();
    auto *rep = M-&gt;N&lt;SeriesFlow&gt;(v);
    if (var) {
      rep-&gt;push_back(M-&gt;N&lt;AssignInstr&gt;(v, var, cv.clone(v-&gt;getValue())));
    }
    if (aggressive)
      rep-&gt;push_back(M-&gt;N&lt;BreakInstr&gt;(v, implicitLoop));

    v-&gt;replaceAll(rep);
  }
</t>
<t tx="ekr.20230509083243.138">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Result of an inlining operation.
struct InlineResult {
  /// the result, either a SeriesFlow or FlowInstr
  Value *result;
  /// variables added by the inlining
  std::vector&lt;Var *&gt; newVars;

  operator bool() const { return bool(result); }
};

/// Inline the given function with the supplied arguments.
/// @param func the function
/// @param args the arguments
/// @param callInfo the call information
/// @param aggressive true if should inline complex functions
/// @return the inlined result, nullptr if unsuccessful
InlineResult inlineFunction(Func *func, std::vector&lt;Value *&gt; args,
                            bool aggressive = false, codon::SrcInfo callInfo = {});

/// Inline the given call.
/// @param v the instruction
/// @param aggressive true if should inline complex functions
/// @return the inlined result, nullptr if unsuccessful
InlineResult inlineCall(CallInstr *v, bool aggressive = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.139">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "irtools.h"

#include &lt;iterator&gt;

namespace codon {
namespace ir {
namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.14">/// Pass to optimize passing a generator to some built-in functions
/// like sum(), any() or all(), which will be converted to regular
/// for-loops.
class GeneratorArgumentOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083243.140">bool hasAttribute(const Func *func, const std::string &amp;attribute) {
  if (auto *attr = func-&gt;getAttribute&lt;KeyValueAttribute&gt;()) {
    return attr-&gt;has(attribute);
  }
  return false;
}

</t>
<t tx="ekr.20230509083243.141">bool isStdlibFunc(const Func *func, const std::string &amp;submodule) {
  if (auto *attr = func-&gt;getAttribute&lt;KeyValueAttribute&gt;()) {
    std::string module = attr-&gt;get(".module");
    return module.rfind("std::" + submodule, 0) == 0;
  }
  return false;
}

</t>
<t tx="ekr.20230509083243.142">CallInstr *call(Func *func, const std::vector&lt;Value *&gt; &amp;args) {
  auto *M = func-&gt;getModule();
  return M-&gt;Nr&lt;CallInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(func), args);
}

</t>
<t tx="ekr.20230509083243.143">bool isCallOf(const Value *value, const std::string &amp;name,
  @others
</t>
<t tx="ekr.20230509083243.144">            const std::vector&lt;types::Type *&gt; &amp;inputs, types::Type *output,
@others
</t>
<t tx="ekr.20230509083243.145">            bool method) {
if (auto *call = cast&lt;CallInstr&gt;(value)) {
  auto *fn = getFunc(call-&gt;getCallee());
  if (!fn || fn-&gt;getUnmangledName() != name || call-&gt;numArgs() != inputs.size())
    return false;

  unsigned i = 0;
  for (auto *arg : *call) {
    if (!arg-&gt;getType()-&gt;is(inputs[i++]))
      return false;
  }

  if (output &amp;&amp; !value-&gt;getType()-&gt;is(output))
    return false;

  if (method &amp;&amp;
      (inputs.empty() || !fn-&gt;getParentType() || !fn-&gt;getParentType()-&gt;is(inputs[0])))
    return false;

  return true;
}

return false;
}

</t>
<t tx="ekr.20230509083243.146">bool isCallOf(const Value *value, const std::string &amp;name, int numArgs,
              types::Type *output, bool method) {
  if (auto *call = cast&lt;CallInstr&gt;(value)) {
    auto *fn = getFunc(call-&gt;getCallee());
    if (!fn || fn-&gt;getUnmangledName() != name ||
        (numArgs &gt;= 0 &amp;&amp; call-&gt;numArgs() != numArgs))
      return false;

    if (output &amp;&amp; !value-&gt;getType()-&gt;is(output))
      return false;

    if (method &amp;&amp; (!fn-&gt;getParentType() || call-&gt;numArgs() == 0 ||
                   !call-&gt;front()-&gt;getType()-&gt;is(fn-&gt;getParentType())))
      return false;

    return true;
  }

  return false;
}

</t>
<t tx="ekr.20230509083243.147">bool isMagicMethodCall(const Value *value) {
  if (auto *call = cast&lt;CallInstr&gt;(value)) {
    auto *fn = getFunc(call-&gt;getCallee());
    if (!fn || !fn-&gt;getParentType() || call-&gt;numArgs() == 0 ||
        !call-&gt;front()-&gt;getType()-&gt;is(fn-&gt;getParentType()))
      return false;

    auto name = fn-&gt;getUnmangledName();
    auto size = name.size();
    if (size &lt; 5 || !(name[0] == '_' &amp;&amp; name[1] == '_' &amp;&amp; name[size - 1] == '_' &amp;&amp;
                      name[size - 2] == '_'))
      return false;

    return true;
  }

  return false;
}

</t>
<t tx="ekr.20230509083243.148">Value *makeTuple(const std::vector&lt;Value *&gt; &amp;args, Module *M) {
  if (!M) {
    seqassertn(!args.empty(), "unknown module for empty tuple construction");
    M = args[0]-&gt;getModule();
  }

  std::vector&lt;types::Type *&gt; types;
  for (auto *arg : args) {
    types.push_back(arg-&gt;getType());
  }
  auto *tupleType = M-&gt;getTupleType(types);
  auto *newFunc = M-&gt;getOrRealizeMethod(tupleType, "__new__", types);
  seqassertn(newFunc, "could not realize {} new function", *tupleType);
  return M-&gt;Nr&lt;CallInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(newFunc), args);
}

VarValue *makeVar(Value *x, SeriesFlow *flow, BodiedFunc *parent, bool prepend) {
  const bool global = (parent == nullptr);
  auto *M = x-&gt;getModule();
  auto *v = M-&gt;Nr&lt;Var&gt;(x-&gt;getType(), global);
  if (global) {
    static int counter = 1;
    v-&gt;setName(".anon_global." + std::to_string(counter++));
  }
  auto *a = M-&gt;Nr&lt;AssignInstr&gt;(v, x);
  if (prepend) {
    flow-&gt;insert(flow-&gt;begin(), a);
  } else {
    flow-&gt;push_back(a);
  }
  if (!global) {
    parent-&gt;push_back(v);
  }
  return M-&gt;Nr&lt;VarValue&gt;(v);
}

Value *alloc(types::Type *type, Value *count) {
  auto *M = type-&gt;getModule();
  auto *ptrType = M-&gt;getPointerType(type);
  return (*ptrType)(*count);
}

Value *alloc(types::Type *type, int64_t count) {
  auto *M = type-&gt;getModule();
  return alloc(type, M-&gt;getInt(count));
}

Var *getVar(Value *x) {
  if (auto *v = cast&lt;VarValue&gt;(x)) {
    if (auto *var = cast&lt;Var&gt;(v-&gt;getVar())) {
      if (!isA&lt;Func&gt;(var)) {
        return var;
      }
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.149">const Var *getVar(const Value *x) {
  if (auto *v = cast&lt;VarValue&gt;(x)) {
    if (auto *var = cast&lt;Var&gt;(v-&gt;getVar())) {
      if (!isA&lt;Func&gt;(var)) {
        return var;
      }
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.15">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "io.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {
namespace {
@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.150">Func *getFunc(Value *x) {
  if (auto *v = cast&lt;VarValue&gt;(x)) {
    if (auto *func = cast&lt;Func&gt;(v-&gt;getVar())) {
      return func;
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.151">const Func *getFunc(const Value *x) {
  if (auto *v = cast&lt;VarValue&gt;(x)) {
    if (auto *func = cast&lt;Func&gt;(v-&gt;getVar())) {
      return func;
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.152">Value *ptrLoad(Value *ptr) {
  auto *M = ptr-&gt;getModule();
  auto *deref = (*ptr)[*M-&gt;getInt(0)];
  seqassertn(deref, "pointer getitem not found [{}]", ptr-&gt;getSrcInfo());
  return deref;
}

Value *ptrStore(Value *ptr, Value *val) {
  auto *M = ptr-&gt;getModule();
  auto *setitem =
      M-&gt;getOrRealizeMethod(ptr-&gt;getType(), Module::SETITEM_MAGIC_NAME,
                            {ptr-&gt;getType(), M-&gt;getIntType(), val-&gt;getType()});
  seqassertn(setitem, "pointer setitem not found [{}]", ptr-&gt;getSrcInfo());
  return call(setitem, {ptr, M-&gt;getInt(0), val});
}

Value *tupleGet(Value *tuple, unsigned index) {
  auto *M = tuple-&gt;getModule();
  return M-&gt;Nr&lt;ExtractInstr&gt;(tuple, "item" + std::to_string(index + 1));
}

Value *tupleStore(Value *tuple, unsigned index, Value *val) {
  auto *M = tuple-&gt;getModule();
  auto *type = cast&lt;types::RecordType&gt;(tuple-&gt;getType());
  seqassertn(type, "argument is not a tuple [{}]", tuple-&gt;getSrcInfo());
  std::vector&lt;Value *&gt; newElements;
  for (unsigned i = 0; i &lt; std::distance(type-&gt;begin(), type-&gt;end()); i++) {
    newElements.push_back(i == index ? val : tupleGet(tuple, i));
  }
  return makeTuple(newElements, M);
}

BodiedFunc *getStdlibFunc(Value *x, const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.153">                          const std::string &amp;submodule) {
  if (auto *f = getFunc(x)) {
    if (auto *g = cast&lt;BodiedFunc&gt;(f)) {
      if (isStdlibFunc(g, submodule) &amp;&amp; g-&gt;getUnmangledName() == name) {
        return g;
      }
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.154">const BodiedFunc *getStdlibFunc(const Value *x, const std::string &amp;name,
  @others
</t>
<t tx="ekr.20230509083243.155">                              const std::string &amp;submodule) {
if (auto *f = getFunc(x)) {
  if (auto *g = cast&lt;BodiedFunc&gt;(f)) {
    if (isStdlibFunc(g, submodule) &amp;&amp; g-&gt;getUnmangledName() == name) {
      return g;
    }
  }
}
return nullptr;
}

</t>
<t tx="ekr.20230509083243.156">types::Type *getReturnType(const Func *func) {
  return cast&lt;types::FuncType&gt;(func-&gt;getType())-&gt;getReturnType();
}

</t>
<t tx="ekr.20230509083243.157">void setReturnType(Func *func, types::Type *rType) {
  auto *M = func-&gt;getModule();
  auto *t = cast&lt;types::FuncType&gt;(func-&gt;getType());
  seqassertn(t, "{} is not a function type [{}]", *func-&gt;getType(), func-&gt;getSrcInfo());
  std::vector&lt;types::Type *&gt; argTypes(t-&gt;begin(), t-&gt;end());
  func-&gt;setType(M-&gt;getFuncType(rType, argTypes));
}

</t>
<t tx="ekr.20230509083243.158">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Checks whether a function has a given attribute.
/// @param func the function
/// @param attribute the attribute name
/// @return true if the function has the given attribute
bool hasAttribute(const Func *func, const std::string &amp;attribute);

/// Checks whether a function comes from the standard library, and
/// optionally a specific module therein.
/// @param func the function
/// @param submodule module name (e.g. "std::bio"), or empty if
///                  no module check is required
/// @return true if the function is from the standard library in
///         the given module
bool isStdlibFunc(const Func *func, const std::string &amp;submodule = "");

/// Calls a function.
/// @param func the function
/// @param args vector of call arguments
/// @return call instruction with the given function and arguments
CallInstr *call(Func *func, const std::vector&lt;Value *&gt; &amp;args);

/// Checks if a value represents a call of a particular function.
/// @param value the value to check
/// @param name the function's (unmangled) name
/// @param inputs vector of input types
/// @param output output type, null for no check
/// @param method true to ensure this call is a method call
/// @return true if value is a call matching all parameters above
bool isCallOf(const Value *value, const std::string &amp;name,
              const std::vector&lt;types::Type *&gt; &amp;inputs, types::Type *output = nullptr,
              bool method = false);

/// Checks if a value represents a call of a particular function.
/// @param value the value to check
/// @param name the function's (unmangled) name
/// @param numArgs argument count, negative for no check
/// @param output output type, null for no check
/// @param method true to ensure this call is a method call
/// @return true if value is a call matching all parameters above
bool isCallOf(const Value *value, const std::string &amp;name, int numArgs = -1,
              types::Type *output = nullptr, bool method = false);

/// Checks if a value represents a call to a magic method.
/// Magic method names start and end in "__" (two underscores).
/// @param value the value to check
/// @return true if value is a magic method call
bool isMagicMethodCall(const Value *value);

/// Constructs a new tuple.
/// @param args vector of tuple contents
/// @param M the module; inferred from elements if null
/// @return value represents a tuple with the given contents
Value *makeTuple(const std::vector&lt;Value *&gt; &amp;args, Module *M = nullptr);

/// Constructs and assigns a new variable.
/// @param x the value to assign to the new variable
/// @param flow series flow in which to assign the new variable
/// @param parent function to add the new variable to, or null for global variable
/// @param prepend true to insert assignment at start of block
/// @return value containing the new variable
VarValue *makeVar(Value *x, SeriesFlow *flow, BodiedFunc *parent, bool prepend = false);

/// Dynamically allocates memory for the given type with the given
/// number of elements.
/// @param type the type
/// @param count integer value representing the number of elements
/// @return value representing a pointer to the allocated memory
Value *alloc(types::Type *type, Value *count);

/// Dynamically allocates memory for the given type with the given
/// number of elements.
/// @param type the type
/// @param count the number of elements
/// @return value representing a pointer to the allocated memory
Value *alloc(types::Type *type, int64_t count);

/// Builds a new series flow with the given contents. Returns
/// null if no contents are provided.
/// @param args contents of the series flow
/// @return new series flow
template &lt;typename... Args&gt; SeriesFlow *series(Args... args) {
  std::vector&lt;Value *&gt; vals = {args...};
  if (vals.empty())
    return nullptr;
  auto *series = vals[0]-&gt;getModule()-&gt;Nr&lt;SeriesFlow&gt;();
  for (auto *val : vals) {
    series-&gt;push_back(val);
  }
  return series;
}

/// Checks whether the given value is a constant of the given
/// type. Note that standard "int" corresponds to the C type
/// "int64_t", which should be used here.
/// @param x the value to check
/// @return true if the value is constant
template &lt;typename T&gt; bool isConst(const Value *x) { return isA&lt;TemplatedConst&lt;T&gt;&gt;(x); }

/// Checks whether the given value is a constant of the given
/// type, and that is has a particular value. Note that standard
/// "int" corresponds to the C type "int64_t", which should be used here.
/// @param x the value to check
/// @param value constant value to compare to
/// @return true if the value is constant with the given value
template &lt;typename T&gt; bool isConst(const Value *x, const T &amp;value) {
  if (auto *c = cast&lt;TemplatedConst&lt;T&gt;&gt;(x)) {
    return c-&gt;getVal() == value;
  }
  return false;
}

/// Returns the constant represented by a given value. Raises an assertion
/// error if the given value is not constant. Note that standard
/// "int" corresponds to the C type "int64_t", which should be used here.
/// @param x the (constant) value
/// @return the constant represented by the given value
template &lt;typename T&gt; T getConst(const Value *x) {
  auto *c = cast&lt;TemplatedConst&lt;T&gt;&gt;(x);
  seqassertn(c, "{} is not a constant [{}]", *x, x-&gt;getSrcInfo());
  return c-&gt;getVal();
}

/// Gets a variable from a value.
/// @param x the value
/// @return the variable represented by the given value, or null if none
Var *getVar(Value *x);

/// Gets a variable from a value.
/// @param x the value
/// @return the variable represented by the given value, or null if none
const Var *getVar(const Value *x);

/// Gets a function from a value.
/// @param x the value
/// @return the function represented by the given value, or null if none
Func *getFunc(Value *x);

/// Gets a function from a value.
/// @param x the value
/// @return the function represented by the given value, or null if none
const Func *getFunc(const Value *x);

/// Loads value from a pointer.
/// @param ptr the pointer
/// @return the value pointed to by the argument
Value *ptrLoad(Value *ptr);

/// Stores a value into a pointer.
/// @param ptr the pointer
/// @param val the value to store
/// @return "__setitem__" call representing the store
Value *ptrStore(Value *ptr, Value *val);

/// Gets value from a tuple at the given index.
/// @param tuple the tuple
/// @param index the 0-based index
/// @return tuple element at the given index
Value *tupleGet(Value *tuple, unsigned index);

/// Stores value in a tuple at the given index. Since tuples are immutable,
/// a new instance is returned with the appropriate element replaced.
/// @param tuple the tuple
/// @param index the 0-based index
/// @param val the value to store
/// @return new tuple instance with the given value inserted
Value *tupleStore(Value *tuple, unsigned index, Value *val);

/// Gets a bodied standard library function from a value.
/// @param x the value
/// @param name name of the function
/// @param submodule optional module to check
/// @return the standard library function (with the given name, from the given
/// submodule) represented by the given value, or null if none
BodiedFunc *getStdlibFunc(Value *x, const std::string &amp;name,
                          const std::string &amp;submodule = "");

/// Gets a bodied standard library function from a value.
/// @param x the value
/// @param name name of the function
/// @param submodule optional module to check
/// @return the standard library function (with the given name, from the given
/// submodule) represented by the given value, or null if none
const BodiedFunc *getStdlibFunc(const Value *x, const std::string &amp;name,
                                const std::string &amp;submodule = "");

/// Gets the return type of a function.
/// @param func the function
/// @return the return type of the given function
types::Type *getReturnType(const Func *func);

/// Sets the return type of a function. Argument types remain unchanged.
/// @param func the function
/// @param rType the new return type
void setReturnType(Func *func, types::Type *rType);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.159">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;iterator&gt;
#include &lt;memory&gt;
#include &lt;type_traits&gt;

namespace codon {
namespace ir {
namespace util {

@others
/// Creates an adaptor that dereferences values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto dereference_adaptor(It it) {
  auto f = [](const auto &amp;v) -&gt; auto &amp; { return *v; };
  auto m = [](const auto &amp;v) -&gt; auto{ return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the address of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto raw_ptr_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; auto * { return v.get(); };
  auto m = [](auto &amp;v) -&gt; auto * { return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the const address of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto const_raw_ptr_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; const auto * { return v.get(); };
  auto m = [](auto &amp;v) -&gt; const auto * { return v.get(); };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the keys of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto map_key_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; auto &amp; { return v.first; };
  auto m = [](auto &amp;v) -&gt; auto &amp; { return v.first; };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

/// Creates an adaptor that gets the const keys of its values.
/// @param it the internal iterator
/// @return the adaptor
template &lt;typename It&gt; auto const_map_key_adaptor(It it) {
  auto f = [](auto &amp;v) -&gt; const auto &amp; { return v.first; };
  auto m = [](auto &amp;v) -&gt; const auto &amp; { return v.first; };
  return function_iterator_adaptor&lt;It, decltype(f), decltype(m)&gt;(it, std::move(f),
                                                                 std::move(m));
}

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.16">void optimizePrint(CallInstr *v) {
  auto *M = v-&gt;getModule();

  auto *inner = cast&lt;CallInstr&gt;(v-&gt;front());
  if (!inner)
    return;
  auto *innerFunc = util::getFunc(inner-&gt;getCallee());
  if (!innerFunc || innerFunc-&gt;getUnmangledName() != "__new__" ||
      std::distance(inner-&gt;begin(), inner-&gt;end()) != 1)
    return;

  auto *cat = cast&lt;CallInstr&gt;(inner-&gt;front());
  if (!cat)
    return;
  auto *catFunc = util::getFunc(cat-&gt;getCallee());
  if (!catFunc || catFunc-&gt;getUnmangledName() != "cat")
    return;

  auto *realCat =
      M-&gt;getOrRealizeMethod(M-&gt;getStringType(), "cat", {cat-&gt;front()-&gt;getType()});
  if (realCat-&gt;getId() != catFunc-&gt;getId())
    return;

  util::CloneVisitor cv(M);
  std::vector&lt;Value *&gt; args;
  std::vector&lt;types::Type *&gt; types;
  for (auto *printArg : *v) {
    args.push_back(cv.clone(printArg));
    types.push_back(printArg-&gt;getType());
  }
  args[0] = cv.clone(cat-&gt;front());
  types[0] = args[0]-&gt;getType();
  args[1] = M-&gt;getString("");

  auto *replacement = M-&gt;getOrRealizeFunc("print", types, {}, "std.internal.builtin");
  if (!replacement)
    return;

  v-&gt;replaceAll(util::call(replacement, args));
}

</t>
<t tx="ekr.20230509083243.160">/// Iterator wrapper that applies a function to the iterator.
template &lt;typename It, typename DereferenceFunc, typename MemberFunc&gt;
struct function_iterator_adaptor {
  It internal;
  DereferenceFunc d;
  MemberFunc m;

  using iterator_category = std::input_iterator_tag;
  using value_type = typename std::remove_reference&lt;decltype(d(*internal))&gt;::type;
  using reference = void;
  using pointer = void;
  using difference_type = typename std::iterator_traits&lt;It&gt;::difference_type;

  /// Constructs an adaptor.
  /// @param internal the internal iterator
  /// @param d the dereference function
  /// @param m the member access function
  function_iterator_adaptor(It internal, DereferenceFunc &amp;&amp;d, MemberFunc &amp;&amp;m)
      : internal(std::move(internal)), d(std::move(d)), m(std::move(m)) {}

  decltype(auto) operator*() { return d(*internal); }
  decltype(auto) operator-&gt;() { return m(*internal); }

  function_iterator_adaptor &amp;operator++() {
    internal++;
    return *this;
  }
  function_iterator_adaptor operator++(int) {
    function_iterator_adaptor&lt;It, DereferenceFunc, MemberFunc&gt; copy(*this);
    internal++;
    return copy;
  }

  @others
};

</t>
<t tx="ekr.20230509083243.161">template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;
bool operator==(const function_iterator_adaptor&lt;OtherIt, OtherDereferenceFunc,
                                                OtherMemberFunc&gt; &amp;other) const {
  return other.internal == internal;
}

</t>
<t tx="ekr.20230509083243.162">template &lt;typename OtherIt, typename OtherDereferenceFunc, typename OtherMemberFunc&gt;
bool operator!=(const function_iterator_adaptor&lt;OtherIt, OtherDereferenceFunc,
                                                OtherMemberFunc&gt; &amp;other) const {
  return other.internal != internal;
}
</t>
<t tx="ekr.20230509083243.163">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "matching.h"

#include &lt;algorithm&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/visitor.h"

#define VISIT(x)                                                                       \
@others
} // namespace util
} // namespace ir
} // namespace codon

#undef VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.164">  void visit(const x *v) override {                                                    \
    if (matchAny || dynamic_cast&lt;const util::Any *&gt;(v)) {                              \
      result = true;                                                                   \
      matchAny = true;                                                                 \
    } else if (!nodeId) {                                                              \
      nodeId = &amp;x::NodeId;                                                             \
      other = v;                                                                       \
    } else if (nodeId != &amp;x::NodeId ||                                                 \
               (!checkName &amp;&amp; v-&gt;getName() != other-&gt;getName()))                       \
      result = false;                                                                  \
    else                                                                               \
      handle(v, static_cast&lt;const x *&gt;(other));                                        \
  }

</t>
<t tx="ekr.20230509083243.165">namespace codon {
namespace ir {
namespace util {
namespace {
</t>
<t tx="ekr.20230509083243.166">class MatchVisitor : public util::ConstVisitor {
private:
  bool matchAny = false;
  bool checkName;
  const char *nodeId = nullptr;
  bool result = false;
  const Node *other = nullptr;
  bool varIdMatch;

public:
  explicit MatchVisitor(bool checkName = false, bool varIdMatch = false)
      : checkName(checkName), varIdMatch(varIdMatch) {}

  VISIT(Var);
  void handle(const Var *x, const Var *y) { result = compareVars(x, y); }

  VISIT(Func);
@others
};
</t>
<t tx="ekr.20230509083243.167">  void handle(const Func *x, const Func *y) {}
  VISIT(BodiedFunc);
  void handle(const BodiedFunc *x, const BodiedFunc *y) {
    result = compareFuncs(x, y) &amp;&amp;
             std::equal(x-&gt;begin(), x-&gt;end(), y-&gt;begin(), y-&gt;end(),
                        [this](auto *x, auto *y) { return process(x, y); }) &amp;&amp;
             process(x-&gt;getBody(), y-&gt;getBody()) &amp;&amp; x-&gt;isJIT() == y-&gt;isJIT();
  }
</t>
<t tx="ekr.20230509083243.168">  VISIT(ExternalFunc);
</t>
<t tx="ekr.20230509083243.169">  void handle(const ExternalFunc *x, const ExternalFunc *y) {
    result = x-&gt;getUnmangledName() == y-&gt;getUnmangledName() &amp;&amp; compareFuncs(x, y);
  }
</t>
<t tx="ekr.20230509083243.17">void optimizeWrite(CallInstr *v) {
  auto *M = v-&gt;getModule();

  auto it = v-&gt;begin();
  auto *file = *it++;

  auto *cat = cast&lt;CallInstr&gt;(*it++);
  if (!cat)
    return;
  auto *catFunc = util::getFunc(cat-&gt;getCallee());
  if (!catFunc || catFunc-&gt;getUnmangledName() != "cat")
    return;

  auto *realCat =
      M-&gt;getOrRealizeMethod(M-&gt;getStringType(), "cat", {cat-&gt;front()-&gt;getType()});
  if (realCat-&gt;getId() != catFunc-&gt;getId())
    return;

  util::CloneVisitor cv(M);
  auto *iter = cv.clone(cat-&gt;front())-&gt;iter();
  if (!iter)
    return;

  std::vector&lt;Value *&gt; args = {cv.clone(file), iter};

  auto *replacement = M-&gt;getOrRealizeMethod(file-&gt;getType(), "__file_write_gen__",
                                            {args[0]-&gt;getType(), args[1]-&gt;getType()});
  if (!replacement)
    return;

  v-&gt;replaceAll(util::call(replacement, args));
}
</t>
<t tx="ekr.20230509083243.170">  VISIT(InternalFunc);
</t>
<t tx="ekr.20230509083243.171">  void handle(const InternalFunc *x, const InternalFunc *y) {
    result = x-&gt;getParentType() == y-&gt;getParentType() &amp;&amp; compareFuncs(x, y);
  }
</t>
<t tx="ekr.20230509083243.172">  VISIT(LLVMFunc);
</t>
<t tx="ekr.20230509083243.173">  void handle(const LLVMFunc *x, const LLVMFunc *y) {
    result = std::equal(x-&gt;literal_begin(), x-&gt;literal_end(), y-&gt;literal_begin(),
                        y-&gt;literal_end(),
                        [this](auto &amp;x, auto &amp;y) {
                          if (x.isStatic() &amp;&amp; y.isStatic())
                            return x.getStaticValue() == y.getStaticValue();
                          else if (x.isStaticStr() &amp;&amp; y.isStaticStr())
                            return x.getStaticStringValue() == y.getStaticStringValue();
                          else if (x.isType() &amp;&amp; y.isType())
                            return process(x.getTypeValue(), y.getTypeValue());
                          return false;
                        }) &amp;&amp;
             x-&gt;getLLVMDeclarations() == y-&gt;getLLVMDeclarations() &amp;&amp;
             x-&gt;getLLVMBody() == y-&gt;getLLVMBody() &amp;&amp; compareFuncs(x, y);
  }

</t>
<t tx="ekr.20230509083243.174">  VISIT(Value);
</t>
<t tx="ekr.20230509083243.175">  void handle(const Value *x, const Value *y) {}
  VISIT(VarValue);
  void handle(const VarValue *x, const VarValue *y) {
    result = compareVars(x-&gt;getVar(), y-&gt;getVar());
  }
</t>
<t tx="ekr.20230509083243.176">  VISIT(PointerValue);
</t>
<t tx="ekr.20230509083243.177">  void handle(const PointerValue *x, const PointerValue *y) {
    result = compareVars(x-&gt;getVar(), y-&gt;getVar());
  }

</t>
<t tx="ekr.20230509083243.178">  VISIT(Flow);
</t>
<t tx="ekr.20230509083243.179">  void handle(const Flow *x, const Flow *y) {}
  VISIT(SeriesFlow);
  void handle(const SeriesFlow *x, const SeriesFlow *y) {
    result = std::equal(x-&gt;begin(), x-&gt;end(), y-&gt;begin(), y-&gt;end(),
                        [this](auto *x, auto *y) { return process(x, y); });
  }
</t>
<t tx="ekr.20230509083243.18">} // namespace

const std::string IOCatOptimization::KEY = "core-pythonic-io-cat-opt";

</t>
<t tx="ekr.20230509083243.180">  VISIT(IfFlow);
</t>
<t tx="ekr.20230509083243.181">  void handle(const IfFlow *x, const IfFlow *y) {
    result = process(x-&gt;getCond(), y-&gt;getCond()) &amp;&amp;
             process(x-&gt;getTrueBranch(), y-&gt;getTrueBranch()) &amp;&amp;
             process(x-&gt;getFalseBranch(), y-&gt;getFalseBranch());
  }

</t>
<t tx="ekr.20230509083243.182">  VISIT(WhileFlow);
</t>
<t tx="ekr.20230509083243.183">  void handle(const WhileFlow *x, const WhileFlow *y) {
    result = process(x-&gt;getCond(), y-&gt;getCond()) &amp;&amp; process(x-&gt;getBody(), y-&gt;getBody());
  }
</t>
<t tx="ekr.20230509083243.184">  VISIT(ForFlow);
</t>
<t tx="ekr.20230509083243.185">  void handle(const ForFlow *x, const ForFlow *y) {
    result = process(x-&gt;getIter(), y-&gt;getIter()) &amp;&amp;
             process(x-&gt;getBody(), y-&gt;getBody()) &amp;&amp; process(x-&gt;getVar(), y-&gt;getVar());
  }
</t>
<t tx="ekr.20230509083243.186">  VISIT(ImperativeForFlow);
</t>
<t tx="ekr.20230509083243.187">  void handle(const ImperativeForFlow *x, const ImperativeForFlow *y) {
    result = process(x-&gt;getVar(), y-&gt;getVar()) &amp;&amp; process(x-&gt;getBody(), y-&gt;getBody()) &amp;&amp;
             process(x-&gt;getStart(), y-&gt;getStart()) &amp;&amp; x-&gt;getStep() == y-&gt;getStep() &amp;&amp;
             process(x-&gt;getEnd(), y-&gt;getEnd());
  }
</t>
<t tx="ekr.20230509083243.188">  VISIT(TryCatchFlow);
</t>
<t tx="ekr.20230509083243.189">  void handle(const TryCatchFlow *x, const TryCatchFlow *y) {
    result = result &amp;&amp; process(x-&gt;getFinally(), y-&gt;getFinally()) &amp;&amp;
             process(x-&gt;getBody(), y-&gt;getBody()) &amp;&amp;
             std::equal(x-&gt;begin(), x-&gt;end(), y-&gt;begin(), y-&gt;end(),
                        [this](auto &amp;x, auto &amp;y) {
                          return process(x.getHandler(), y.getHandler()) &amp;&amp;
                                 process(x.getType(), y.getType()) &amp;&amp;
                                 process(x.getVar(), y.getVar());
                        });
  }
</t>
<t tx="ekr.20230509083243.19">void IOCatOptimization::handle(CallInstr *v) {
  if (util::getStdlibFunc(v-&gt;getCallee(), "print")) {
    optimizePrint(v);
  } else if (auto *f = cast&lt;Func&gt;(util::getFunc(v-&gt;getCallee()))) {
    if (f-&gt;getUnmangledName() == "write")
      optimizeWrite(v);
  }
}

</t>
<t tx="ekr.20230509083243.190">  VISIT(PipelineFlow);
</t>
<t tx="ekr.20230509083243.191">  void handle(const PipelineFlow *x, const PipelineFlow *y) {
    result = std::equal(
        x-&gt;begin(), x-&gt;end(), y-&gt;begin(), y-&gt;end(), [this](auto &amp;x, auto &amp;y) {
          return process(x.getCallee(), y.getCallee()) &amp;&amp;
                 std::equal(x.begin(), x.end(), y.begin(), y.end(),
                            [this](auto *x, auto *y) { return process(x, y); }) &amp;&amp;
                 x.isGenerator() == y.isGenerator() &amp;&amp; x.isParallel() == y.isParallel();
        });
  }
</t>
<t tx="ekr.20230509083243.192">  VISIT(dsl::CustomFlow);
</t>
<t tx="ekr.20230509083243.193">  void handle(const dsl::CustomFlow *x, const dsl::CustomFlow *y) {
    result = x-&gt;match(y);
  }

</t>
<t tx="ekr.20230509083243.194">  VISIT(IntConst);
</t>
<t tx="ekr.20230509083243.195">  void handle(const IntConst *x, const IntConst *y) {
    result = process(x-&gt;getType(), y-&gt;getType()) &amp;&amp; x-&gt;getVal() == y-&gt;getVal();
  }
</t>
<t tx="ekr.20230509083243.196">  VISIT(FloatConst);
</t>
<t tx="ekr.20230509083243.197">  void handle(const FloatConst *x, const FloatConst *y) {
    result = process(x-&gt;getType(), y-&gt;getType()) &amp;&amp; x-&gt;getVal() == y-&gt;getVal();
  }
</t>
<t tx="ekr.20230509083243.198">  VISIT(BoolConst);
</t>
<t tx="ekr.20230509083243.199">  void handle(const BoolConst *x, const BoolConst *y) {
    result = process(x-&gt;getType(), y-&gt;getType()) &amp;&amp; x-&gt;getVal() == y-&gt;getVal();
  }
</t>
<t tx="ekr.20230509083243.2">bool isAny(Func *f) {
  return f &amp;&amp; f-&gt;getName().rfind("std.internal.builtin.any:", 0) == 0;
}

</t>
<t tx="ekr.20230509083243.20">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.200">  VISIT(StringConst);
</t>
<t tx="ekr.20230509083243.201">  void handle(const StringConst *x, const StringConst *y) {
    result = process(x-&gt;getType(), y-&gt;getType()) &amp;&amp; x-&gt;getVal() == y-&gt;getVal();
  }
</t>
<t tx="ekr.20230509083243.202">  VISIT(dsl::CustomConst);
</t>
<t tx="ekr.20230509083243.203">  void handle(const dsl::CustomConst *x, const dsl::CustomConst *y) {
    result = x-&gt;match(y);
  }

</t>
<t tx="ekr.20230509083243.204">  VISIT(AssignInstr);
</t>
<t tx="ekr.20230509083243.205">  void handle(const AssignInstr *x, const AssignInstr *y) {
    result = process(x-&gt;getLhs(), y-&gt;getLhs()) &amp;&amp; process(x-&gt;getRhs(), y-&gt;getRhs());
  }
</t>
<t tx="ekr.20230509083243.206">  VISIT(ExtractInstr);
</t>
<t tx="ekr.20230509083243.207">  void handle(const ExtractInstr *x, const ExtractInstr *y) {
    result = process(x-&gt;getVal(), y-&gt;getVal()) &amp;&amp; x-&gt;getField() == y-&gt;getField();
  }
</t>
<t tx="ekr.20230509083243.208">  VISIT(InsertInstr);
</t>
<t tx="ekr.20230509083243.209">  void handle(const InsertInstr *x, const InsertInstr *y) {
    result = process(x-&gt;getLhs(), y-&gt;getLhs()) &amp;&amp; x-&gt;getField() == y-&gt;getField() &amp;&amp;
             process(x-&gt;getRhs(), y-&gt;getRhs());
  }
</t>
<t tx="ekr.20230509083243.21">/// Pass to optimize print str.cat(...) or file.write(str.cat(...)).
class IOCatOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083243.210">  VISIT(CallInstr);
</t>
<t tx="ekr.20230509083243.211">  void handle(const CallInstr *x, const CallInstr *y) {
    result = process(x-&gt;getCallee(), y-&gt;getCallee()) &amp;&amp;
             std::equal(x-&gt;begin(), x-&gt;end(), y-&gt;begin(), y-&gt;end(),
                        [this](auto *x, auto *y) { return process(x, y); });
  }
</t>
<t tx="ekr.20230509083243.212">  VISIT(StackAllocInstr);
</t>
<t tx="ekr.20230509083243.213">  void handle(const StackAllocInstr *x, const StackAllocInstr *y) {
    result = x-&gt;getCount() == y-&gt;getCount() &amp;&amp; process(x-&gt;getType(), y-&gt;getType());
  }
</t>
<t tx="ekr.20230509083243.214">  VISIT(TypePropertyInstr);
</t>
<t tx="ekr.20230509083243.215">  void handle(const TypePropertyInstr *x, const TypePropertyInstr *y) {
    result = x-&gt;getProperty() == y-&gt;getProperty() &amp;&amp;
             process(x-&gt;getInspectType(), y-&gt;getInspectType());
  }
</t>
<t tx="ekr.20230509083243.216">  VISIT(YieldInInstr);
</t>
<t tx="ekr.20230509083243.217">  void handle(const YieldInInstr *x, const YieldInInstr *y) {
    result = process(x-&gt;getType(), y-&gt;getType());
  }
</t>
<t tx="ekr.20230509083243.218">  VISIT(TernaryInstr);
</t>
<t tx="ekr.20230509083243.219">  void handle(const TernaryInstr *x, const TernaryInstr *y) {
    result = process(x-&gt;getCond(), y-&gt;getCond()) &amp;&amp;
             process(x-&gt;getTrueValue(), y-&gt;getTrueValue()) &amp;&amp;
             process(x-&gt;getFalseValue(), y-&gt;getFalseValue());
  }
</t>
<t tx="ekr.20230509083243.22">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "list.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {
namespace {

static const std::string LIST = "std.internal.types.ptr.List";
static const std::string SLICE = "std.internal.types.slice.Slice";

bool isList(Value *v) { return v-&gt;getType()-&gt;getName().rfind(LIST + "[", 0) == 0; }
bool isSlice(Value *v) { return v-&gt;getType()-&gt;getName() == SLICE; }

// The following "handlers" account for the possible sub-expressions we might
// see when optimizing list1 + list2 + ... listN. Currently, we optimize:
//   - Slices: x[a:b:c] (avoid constructing the temporary sliced list)
//   - Literals: [a, b, c] (just append elements directly)
//   - Default: &lt;any list expr&gt; (append by iterating over the list)
// It is easy to handle new sub-expression types by adding new handlers.
// There are three stages in the optimized code:
//   - Setup: assign all the relevant expressions to variables, making
//            sure they're evaluated in the same order as before
//   - Count: figure out the total length of the resulting list
//   - Create: initialize a new list with the appropriate capacity and
//             append all the elements
// The handlers have virtual functions to generate IR for each of these steps.

struct ElementHandler {
  std::vector&lt;Var *&gt; vars;

  ElementHandler() : vars() {}
  virtual ~ElementHandler() {}
  virtual void setup(SeriesFlow *block, BodiedFunc *parent) = 0;
  virtual Value *length(Module *M) = 0;
  virtual Value *append(Value *result) = 0;

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.220">  VISIT(BreakInstr);
</t>
<t tx="ekr.20230509083243.221">  void handle(const BreakInstr *x, const BreakInstr *y) {
    result = process(x-&gt;getLoop(), y-&gt;getLoop());
  }
</t>
<t tx="ekr.20230509083243.222">  VISIT(ContinueInstr);
</t>
<t tx="ekr.20230509083243.223">  void handle(const ContinueInstr *x, const ContinueInstr *y) {
    result = process(x-&gt;getLoop(), y-&gt;getLoop());
  }
</t>
<t tx="ekr.20230509083243.224">  VISIT(ReturnInstr);
</t>
<t tx="ekr.20230509083243.225">  void handle(const ReturnInstr *x, const ReturnInstr *y) {
    result = process(x-&gt;getValue(), y-&gt;getValue());
  }
</t>
<t tx="ekr.20230509083243.226">  VISIT(YieldInstr);
</t>
<t tx="ekr.20230509083243.227">  void handle(const YieldInstr *x, const YieldInstr *y) {
    result = process(x-&gt;getValue(), y-&gt;getValue());
  }
</t>
<t tx="ekr.20230509083243.228">  VISIT(ThrowInstr);
</t>
<t tx="ekr.20230509083243.229">  void handle(const ThrowInstr *x, const ThrowInstr *y) {
    result = process(x-&gt;getValue(), y-&gt;getValue());
  }
</t>
<t tx="ekr.20230509083243.23">  void doSetup(const std::vector&lt;Value *&gt; &amp;values, SeriesFlow *block,
               BodiedFunc *parent) {
    for (auto *v : values) {
      vars.push_back(util::makeVar(v, block, parent)-&gt;getVar());
    }
  }

</t>
<t tx="ekr.20230509083243.230">  VISIT(FlowInstr);
</t>
<t tx="ekr.20230509083243.231">  void handle(const FlowInstr *x, const FlowInstr *y) {
    result =
        process(x-&gt;getFlow(), y-&gt;getFlow()) &amp;&amp; process(x-&gt;getValue(), y-&gt;getValue());
  }
</t>
<t tx="ekr.20230509083243.232">  VISIT(dsl::CustomInstr);
</t>
<t tx="ekr.20230509083243.233">  void handle(const dsl::CustomInstr *x, const dsl::CustomInstr *y) {
    result = x-&gt;match(y);
  }

</t>
<t tx="ekr.20230509083243.234">  bool process(const Node *x, const Node *y) const {
    if (!x &amp;&amp; !y)
      return true;
    else if ((!x &amp;&amp; y) || (x &amp;&amp; !y))
      return false;

    auto *tx = cast&lt;types::Type&gt;(x);
    auto *ty = cast&lt;types::Type&gt;(y);
    if (tx || ty)
      return tx &amp;&amp; ty &amp;&amp; tx-&gt;is(const_cast&lt;types::Type *&gt;(ty));

    MatchVisitor v(checkName);
    x-&gt;accept(v);
    y-&gt;accept(v);

    return v.result;
  }

</t>
<t tx="ekr.20230509083243.235">private:
</t>
<t tx="ekr.20230509083243.236">  bool compareVars(const Var *x, const Var *y) const {
    return process(x-&gt;getType(), y-&gt;getType()) &amp;&amp;
           (!varIdMatch || x-&gt;getId() == y-&gt;getId());
  }

</t>
<t tx="ekr.20230509083243.237">  bool compareFuncs(const Func *x, const Func *y) const {
    if (!compareVars(x, y))
      return false;

    if (!std::equal(x-&gt;arg_begin(), x-&gt;arg_end(), y-&gt;arg_begin(), y-&gt;arg_end(),
                    [this](auto *x, auto *y) { return process(x, y); }))
      return false;

    return true;
  }
</t>
<t tx="ekr.20230509083243.238">} // namespace

const char AnyValue::NodeId = 0;

const char AnyFlow::NodeId = 0;

const char AnyVar::NodeId = 0;

const char AnyFunc::NodeId = 0;

</t>
<t tx="ekr.20230509083243.239">bool match(Node *a, Node *b, bool checkNames, bool varIdMatch) {
  return MatchVisitor(checkNames).process(a, b);
}

</t>
<t tx="ekr.20230509083243.24">  static std::unique_ptr&lt;ElementHandler&gt; get(Value *v, types::Type *ty);
};

struct DefaultHandler : public ElementHandler {
  Value *element;

  DefaultHandler(Value *element) : ElementHandler(), element(element) {}

</t>
<t tx="ekr.20230509083243.240">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// Base class for IR nodes that match anything.
class Any {};

@others
/// Checks if IR nodes match.
/// @param a the first IR node
/// @param b the second IR node
/// @param checkNames whether or not to check the node names
/// @param varIdMatch whether or not variable ids must match
/// @return true if the nodes are equal
bool match(Node *a, Node *b, bool checkNames = false, bool varIdMatch = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.241">/// Any value.
class AnyValue : public AcceptorExtend&lt;AnyValue, Value&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;

private:
  types::Type *doGetType() const override { return getModule()-&gt;getVoidType(); }
};

</t>
<t tx="ekr.20230509083243.242">/// Any flow.
class AnyFlow : public AcceptorExtend&lt;AnyFlow, Flow&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509083243.243">/// Any variable.
class AnyVar : public AcceptorExtend&lt;AnyVar, Var&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;
};

</t>
<t tx="ekr.20230509083243.244">/// Any function.
class AnyFunc : public AcceptorExtend&lt;AnyFunc, Func&gt;, public Any {
public:
  static const char NodeId;
  using AcceptorExtend::AcceptorExtend;

  AnyFunc() : AcceptorExtend() { setUnmangledName("any"); }
};

</t>
<t tx="ekr.20230509083243.245">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;unordered_set&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/visitor.h"

#define LAMBDA_VISIT(x)                                                                \
  virtual void handle(codon::ir::x *v) {}                                              \
@others
} // namespace util
} // namespace ir
} // namespace codon

#undef LAMBDA_VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.246">  void visit(codon::ir::x *v) override {                                               \
    if (childrenFirst)                                                                 \
      processChildren(v);                                                              \
    preHook(v);                                                                        \
    handle(v);                                                                         \
    postHook(v);                                                                       \
    if (!childrenFirst)                                                                \
      processChildren(v);                                                              \
  }

</t>
<t tx="ekr.20230509083243.247">namespace codon {
namespace ir {
namespace util {

</t>
<t tx="ekr.20230509083243.248">/// Pass that visits all values in a module.
class Operator : public Visitor {
private:
  /// IDs of previously visited nodes
  std::unordered_set&lt;id_t&gt; seen;
  /// stack of IR nodes being visited
  std::vector&lt;Node *&gt; nodeStack;
  /// stack of iterators
  std::vector&lt;decltype(SeriesFlow().begin())&gt; itStack;
  /// true if should visit children first
  bool childrenFirst;

protected:
  void defaultVisit(Node *) override {}

public:
  /// Constructs an operator.
  /// @param childrenFirst true if children should be visited first
  explicit Operator(bool childrenFirst = false) : childrenFirst(childrenFirst) {}

  virtual ~Operator() noexcept = default;

  /// This function is applied to all nodes before handling the node
  /// itself. It provides a way to write one function that gets
  /// applied to every visited node.
  /// @param node the node
  virtual void preHook(Node *node) {}
  /// This function is applied to all nodes after handling the node
  /// itself. It provides a way to write one function that gets
  /// applied to every visited node.
  /// @param node the node
  virtual void postHook(Node *node) {}

@others
};

</t>
<t tx="ekr.20230509083243.249">  void visit(Module *m) override {
    nodeStack.push_back(m);
    nodeStack.push_back(m-&gt;getMainFunc());
    process(m-&gt;getMainFunc());
    nodeStack.pop_back();
    for (auto *s : *m) {
      nodeStack.push_back(s);
      process(s);
      nodeStack.pop_back();
    }
    nodeStack.pop_back();
  }

</t>
<t tx="ekr.20230509083243.25">  void setup(SeriesFlow *block, BodiedFunc *parent) override {
    doSetup({element}, block, parent);
  }

</t>
<t tx="ekr.20230509083243.250">  void visit(BodiedFunc *f) override {
    if (f-&gt;getBody()) {
      seen.insert(f-&gt;getBody()-&gt;getId());
      process(f-&gt;getBody());
    }
  }

</t>
<t tx="ekr.20230509083243.251">  LAMBDA_VISIT(VarValue);
  LAMBDA_VISIT(PointerValue);

</t>
<t tx="ekr.20230509083243.252">  void visit(codon::ir::SeriesFlow *v) override {
    if (childrenFirst)
      processSeriesFlowChildren(v);
    preHook(v);
    handle(v);
    postHook(v);
    if (!childrenFirst)
      processSeriesFlowChildren(v);
  }

</t>
<t tx="ekr.20230509083243.253">  virtual void handle(codon::ir::SeriesFlow *v) {}
  LAMBDA_VISIT(IfFlow);
  LAMBDA_VISIT(WhileFlow);
  LAMBDA_VISIT(ForFlow);
  LAMBDA_VISIT(ImperativeForFlow);
  LAMBDA_VISIT(TryCatchFlow);
  LAMBDA_VISIT(PipelineFlow);
  LAMBDA_VISIT(dsl::CustomFlow);

  LAMBDA_VISIT(TemplatedConst&lt;int64_t&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;double&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;bool&gt;);
  LAMBDA_VISIT(TemplatedConst&lt;std::string&gt;);
  LAMBDA_VISIT(dsl::CustomConst);

  LAMBDA_VISIT(Instr);
  LAMBDA_VISIT(AssignInstr);
  LAMBDA_VISIT(ExtractInstr);
  LAMBDA_VISIT(InsertInstr);
  LAMBDA_VISIT(CallInstr);
  LAMBDA_VISIT(StackAllocInstr);
  LAMBDA_VISIT(TypePropertyInstr);
  LAMBDA_VISIT(YieldInInstr);
  LAMBDA_VISIT(TernaryInstr);
  LAMBDA_VISIT(BreakInstr);
  LAMBDA_VISIT(ContinueInstr);
  LAMBDA_VISIT(ReturnInstr);
  LAMBDA_VISIT(YieldInstr);
  LAMBDA_VISIT(ThrowInstr);
  LAMBDA_VISIT(FlowInstr);
  LAMBDA_VISIT(dsl::CustomInstr);

  template &lt;typename Node&gt; void process(Node *v) { v-&gt;accept(*this); }

  /// Return the parent of the current node.
  /// @param level the number of levels up from the current node
  template &lt;typename Desired = Node&gt; Desired *getParent(int level = 0) {
    return cast&lt;Desired&gt;(nodeStack[nodeStack.size() - level - 1]);
  }
  /// @return current depth in the tree
  int depth() const { return nodeStack.size(); }

  /// @tparam Desired the desired type
  /// @return the last encountered example of the desired type
  template &lt;typename Desired&gt; Desired *findLast() {
    for (auto it = nodeStack.rbegin(); it != nodeStack.rend(); ++it) {
      if (auto *v = cast&lt;Desired&gt;(*it))
        return v;
    }
    return nullptr;
  }
  /// @return the last encountered function
  Func *getParentFunc() { return findLast&lt;Func&gt;(); }

  /// @return an iterator to the first parent
  auto parent_begin() const { return nodeStack.begin(); }
  /// @return an iterator beyond the last parent
  auto parent_end() const { return nodeStack.end(); }

  /// @param v the value
  /// @return whether we have visited ("seen") the given value
  bool saw(const Value *v) const { return seen.find(v-&gt;getId()) != seen.end(); }
  /// Avoid visiting the given value in the future.
  /// @param v the value
  void see(const Value *v) { seen.insert(v-&gt;getId()); }

</t>
<t tx="ekr.20230509083243.254">  /// Inserts the new value before the current position in the last seen SeriesFlow.
  /// @param v the new value
  auto insertBefore(Value *v) {
    return findLast&lt;SeriesFlow&gt;()-&gt;insert(itStack.back(), v);
  }
</t>
<t tx="ekr.20230509083243.255">  /// Inserts the new value after the current position in the last seen SeriesFlow.
  /// @param v the new value, which is marked seen
  auto insertAfter(Value *v) {
    auto newPos = itStack.back();
    ++newPos;
    see(v);

    return findLast&lt;SeriesFlow&gt;()-&gt;insert(newPos, v);
  }

</t>
<t tx="ekr.20230509083243.256">  /// Resets the operator.
  void reset() {
    seen.clear();
    nodeStack.clear();
    itStack.clear();
  }

</t>
<t tx="ekr.20230509083243.257">private:
</t>
<t tx="ekr.20230509083243.258">  void processChildren(Value *v) {
    nodeStack.push_back(v);
    for (auto *c : v-&gt;getUsedValues()) {
      if (saw(c))
        continue;
      see(c);
      process(c);
    }
    nodeStack.pop_back();
  }

</t>
<t tx="ekr.20230509083243.259">  void processSeriesFlowChildren(codon::ir::SeriesFlow *v) {
    nodeStack.push_back(v);
    for (auto it = v-&gt;begin(); it != v-&gt;end(); ++it) {
      itStack.push_back(it);
      process(*it);
      itStack.pop_back();
    }
    nodeStack.pop_back();
  }
</t>
<t tx="ekr.20230509083243.26">  Value *length(Module *M) override {
    auto *e = M-&gt;Nr&lt;VarValue&gt;(vars[0]);
    auto *ty = element-&gt;getType();
    auto *fn = M-&gt;getOrRealizeMethod(ty, "_list_add_opt_default_len", {ty});
    seqassertn(fn, "could not find default list length helper");
    return util::call(fn, {e});
  }

  Value *append(Value *result) override {
    auto *M = result-&gt;getModule();
    auto *e = M-&gt;Nr&lt;VarValue&gt;(vars[0]);
    auto *ty = result-&gt;getType();
    auto *fn = M-&gt;getOrRealizeMethod(ty, "_list_add_opt_default_append", {ty, ty});
    seqassertn(fn, "could not find default list append helper");
    return util::call(fn, {result, e});
  }

</t>
<t tx="ekr.20230509083243.260">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "outlining.h"

#include &lt;iterator&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {
namespace util {
namespace {
struct OutlineReplacer : public Operator {
  std::unordered_set&lt;id_t&gt; &amp;modVars;
  std::vector&lt;std::pair&lt;Var *, Var *&gt;&gt; &amp;remap;
  std::vector&lt;Value *&gt; &amp;outFlows;
  CloneVisitor cv;

  OutlineReplacer(Module *M, std::unordered_set&lt;id_t&gt; &amp;modVars,
                  std::vector&lt;std::pair&lt;Var *, Var *&gt;&gt; &amp;remap,
                  std::vector&lt;Value *&gt; &amp;outFlows)
      : Operator(), modVars(modVars), remap(remap), outFlows(outFlows), cv(M, false) {}

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.261">  // Replace all used vars based on remapping.
  void postHook(Node *node) override {
    for (auto &amp;pair : remap) {
      node-&gt;replaceUsedVariable(std::get&lt;0&gt;(pair), std::get&lt;1&gt;(pair));
    }
  }

</t>
<t tx="ekr.20230509083243.262">  Var *mappedVar(Var *v) {
    for (auto &amp;pair : remap) {
      if (std::get&lt;0&gt;(pair)-&gt;getId() == v-&gt;getId())
        return std::get&lt;1&gt;(pair);
    }
    return nullptr;
  }

  // A return in the outlined func, or a break/continue that references a
  // non-outlined loop, will return a status code that tells the call site
  // what action to perform.
  template &lt;typename InstrType&gt; void replaceOutFlowWithReturn(InstrType *v) {
    auto *M = v-&gt;getModule();
    for (unsigned i = 0; i &lt; outFlows.size(); i++) {
      if (outFlows[i]-&gt;getId() == v-&gt;getId()) {
        auto *copy = cv.clone(v);
        v-&gt;replaceAll(M-&gt;template Nr&lt;ReturnInstr&gt;(M-&gt;getInt(i + 1)));
        outFlows[i] = copy;
        break;
      }
    }
  }

  void handle(ReturnInstr *v) override { replaceOutFlowWithReturn(v); }

  void handle(BreakInstr *v) override { replaceOutFlowWithReturn(v); }

  void handle(ContinueInstr *v) override { replaceOutFlowWithReturn(v); }

</t>
<t tx="ekr.20230509083243.263">  // If passed by pointer (i.e. a "mod var"), change variable reference to
  // a pointer dereference.
  void handle(VarValue *v) override {
    auto *M = v-&gt;getModule();
    if (modVars.count(v-&gt;getVar()-&gt;getId()) &gt; 0) {
      // var -&gt; pointer dereference
      auto *deref = util::ptrLoad(M-&gt;Nr&lt;VarValue&gt;(mappedVar(v-&gt;getVar())));
      saw(deref);
      v-&gt;replaceAll(deref);
    }
  }

</t>
<t tx="ekr.20230509083243.264">  // If passed by pointer (i.e. a "mod var"), change pointer value to just
  // be the var itself.
  void handle(PointerValue *v) override {
    auto *M = v-&gt;getModule();
    if (modVars.count(v-&gt;getVar()-&gt;getId()) &gt; 0) {
      // pointer -&gt; var
      auto *ref = M-&gt;Nr&lt;VarValue&gt;(mappedVar(v-&gt;getVar()));
      saw(ref);
      v-&gt;replaceAll(ref);
    }
  }

</t>
<t tx="ekr.20230509083243.265">  // If passed by pointer (i.e. a "mod var"), change assignment to store
  // in the pointer.
  void handle(AssignInstr *v) override {
    auto *M = v-&gt;getModule();
    if (modVars.count(v-&gt;getLhs()-&gt;getId()) &gt; 0) {
      // store in pointer
      Var *newVar = mappedVar(v-&gt;getLhs());
      auto *setitem = util::ptrStore(M-&gt;Nr&lt;VarValue&gt;(newVar), v-&gt;getRhs());
      saw(setitem);
      v-&gt;replaceAll(setitem);
    }
  }
</t>
<t tx="ekr.20230509083243.266">};

struct Outliner : public Operator {
  BodiedFunc *parent;
  SeriesFlow *flowRegion;
  decltype(flowRegion-&gt;begin()) begin, end;
  bool outlineGlobals;              // whether to outline globals that are modified
  bool allByValue;                  // outline all vars by value (can change semantics)
  bool inRegion;                    // are we in the outlined region?
  bool invalid;                     // if we can't outline for whatever reason
  std::unordered_set&lt;id_t&gt; inVars;  // vars used inside region
  std::unordered_set&lt;id_t&gt; outVars; // vars used outside region
  std::unordered_set&lt;id_t&gt;
      modifiedInVars; // vars modified (assigned or address'd) in region
  std::unordered_set&lt;id_t&gt; globalsToOutline; // modified global vars to outline
  std::unordered_set&lt;id_t&gt; inLoops;          // loops contained in region
  std::vector&lt;Value *&gt;
      outFlows; // control flows that need to be handled externally (e.g. return)

  Outliner(BodiedFunc *parent, SeriesFlow *flowRegion,
           decltype(flowRegion-&gt;begin()) begin, decltype(flowRegion-&gt;begin()) end,
</t>
<t tx="ekr.20230509083243.267">           bool outlineGlobals, bool allByValue)
      : Operator(), parent(parent), flowRegion(flowRegion), begin(begin), end(end),
        outlineGlobals(outlineGlobals), allByValue(allByValue), inRegion(false),
        invalid(false), inVars(), outVars(), modifiedInVars(), globalsToOutline(),
        inLoops(), outFlows() {}

    @others
</t>
<t tx="ekr.20230509083243.268">  bool isEnclosingLoopInRegion(id_t loopId = -1) {
int d = depth();
for (int i = 0; i &lt; d; i++) {
  Flow *v = getParent&lt;WhileFlow&gt;(i);
  if (!v)
    v = getParent&lt;ForFlow&gt;(i);
  if (!v)
    v = getParent&lt;ImperativeForFlow&gt;(i);

  if (v &amp;&amp; (loopId == -1 || loopId == v-&gt;getId()))
    return inLoops.count(v-&gt;getId()) &gt; 0;
}
return false;
  }

</t>
<t tx="ekr.20230509083243.269">  void handle(WhileFlow *v) override {
    if (inRegion)
      inLoops.insert(v-&gt;getId());
  }

</t>
<t tx="ekr.20230509083243.27">  static std::unique_ptr&lt;ElementHandler&gt; get(Value *v, types::Type *ty) {
    if (!v-&gt;getType()-&gt;is(ty))
      return {};
    return std::make_unique&lt;DefaultHandler&gt;(v);
  }
</t>
<t tx="ekr.20230509083243.270">  void handle(ForFlow *v) override {
    if (inRegion)
      inLoops.insert(v-&gt;getId());
  }

</t>
<t tx="ekr.20230509083243.271">  void handle(ImperativeForFlow *v) override {
    if (inRegion)
      inLoops.insert(v-&gt;getId());
  }

</t>
<t tx="ekr.20230509083243.272">  void handle(ReturnInstr *v) override {
    if (inRegion)
      outFlows.push_back(v);
  }

</t>
<t tx="ekr.20230509083243.273">  void handle(BreakInstr *v) override {
    auto *loop = v-&gt;getLoop();
    if (inRegion &amp;&amp; !isEnclosingLoopInRegion(loop ? loop-&gt;getId() : -1))
      outFlows.push_back(v);
  }

</t>
<t tx="ekr.20230509083243.274">  void handle(ContinueInstr *v) override {
    auto *loop = v-&gt;getLoop();
    if (inRegion &amp;&amp; !isEnclosingLoopInRegion(loop ? loop-&gt;getId() : -1))
      outFlows.push_back(v);
  }

</t>
<t tx="ekr.20230509083243.275">  void handle(YieldInstr *v) override {
    if (inRegion)
      invalid = true;
  }

</t>
<t tx="ekr.20230509083243.276">  void handle(YieldInInstr *v) override {
    if (inRegion)
      invalid = true;
  }

</t>
<t tx="ekr.20230509083243.277">  void handle(StackAllocInstr *v) override {
    if (inRegion)
      invalid = true;
  }

</t>
<t tx="ekr.20230509083243.278">  void handle(AssignInstr *v) override {
    if (inRegion) {
      auto *var = v-&gt;getLhs();
      modifiedInVars.insert(var-&gt;getId());
      if (outlineGlobals &amp;&amp; var-&gt;isGlobal())
        globalsToOutline.insert(var-&gt;getId());
    }
  }

</t>
<t tx="ekr.20230509083243.279">  void handle(PointerValue *v) override {
    if (inRegion) {
      auto *var = v-&gt;getVar();
      modifiedInVars.insert(var-&gt;getId());
      if (outlineGlobals &amp;&amp; var-&gt;isGlobal())
        globalsToOutline.insert(var-&gt;getId());
    }
  }

</t>
<t tx="ekr.20230509083243.28">};

struct SliceHandler : public ElementHandler {
  Value *element;
  Value *slice;

  SliceHandler(Value *element, Value *slice)
      : ElementHandler(), element(element), slice(slice) {}

</t>
<t tx="ekr.20230509083243.280">  void visit(SeriesFlow *v) override {
    if (v-&gt;getId() != flowRegion-&gt;getId())
      return Operator::visit(v);

    auto it = flowRegion-&gt;begin();
    for (; it != begin; ++it) {
      (*it)-&gt;accept(*this);
    }

    inRegion = true;

    for (; it != end; ++it) {
      (*it)-&gt;accept(*this);
    }

    inRegion = false;

    for (; it != flowRegion-&gt;end(); ++it) {
      (*it)-&gt;accept(*this);
    }
  }

</t>
<t tx="ekr.20230509083243.281">  void visit(BodiedFunc *v) override {
    for (auto it = v-&gt;arg_begin(); it != v-&gt;arg_end(); ++it) {
      outVars.insert((*it)-&gt;getId());
    }
    Operator::visit(v);
  }

</t>
<t tx="ekr.20230509083243.282">  void preHook(Node *node) override {
    auto vars = node-&gt;getUsedVariables();
    auto &amp;set = (inRegion ? inVars : outVars);
    for (auto *var : vars) {
      if (!var-&gt;isGlobal())
        set.insert(var-&gt;getId());
      else if (inRegion &amp;&amp; allByValue &amp;&amp; !isA&lt;Func&gt;(var))
        globalsToOutline.insert(var-&gt;getId());
    }
  }

</t>
<t tx="ekr.20230509083243.283">  // private = used in region AND NOT used outside region
  std::unordered_set&lt;id_t&gt; getPrivateVars() {
    std::unordered_set&lt;id_t&gt; privateVars;
    for (auto id : inVars) {
      if (outVars.count(id) == 0)
        privateVars.insert(id);
    }
    return privateVars;
  }

  // shared = used in region AND used outside region
  std::unordered_set&lt;id_t&gt; getSharedVars() {
    std::unordered_set&lt;id_t&gt; sharedVars;
    for (auto id : inVars) {
      if (outVars.count(id) &gt; 0)
        sharedVars.insert(id);
    }
    return sharedVars;
  }

  // mod = shared AND modified in region
  std::unordered_set&lt;id_t&gt; getModVars() {
    if (allByValue)
      return {};

    std::unordered_set&lt;id_t&gt; modVars, shared = getSharedVars();
    for (auto id : modifiedInVars) {
      if (globalsToOutline.count(id) &gt; 0 || shared.count(id) &gt; 0)
        modVars.insert(id);
    }
    return modVars;
  }

  OutlineResult outline(bool allowOutflows = true) {
    if (invalid)
      return {};

    auto *M = flowRegion-&gt;getModule();
    std::vector&lt;std::pair&lt;Var *, Var *&gt;&gt; remap; // mapping of old vars to new func vars
    std::vector&lt;types::Type *&gt; argTypes;        // arg types of new func
    std::vector&lt;std::string&gt; argNames;          // arg names of new func
    std::vector&lt;OutlineResult::ArgKind&gt; argKinds; // arg information given back to user

    // Figure out arguments and outlined function type:
    //   - Private variables can be made local to the new function
    //   - Shared variables will be passed as arguments
    //   - Modified+shared variables will be passed as pointers
    unsigned idx = 0;
    auto shared = getSharedVars();
    shared.insert(globalsToOutline.begin(), globalsToOutline.end());
    auto mod = getModVars();
    for (auto id : shared) {
      Var *var = M-&gt;getVar(id);
      seqassertn(var, "unknown var id [{}]", var-&gt;getSrcInfo());
      remap.emplace_back(var, nullptr);
      const bool isMod = (mod.count(id) &gt; 0);
      types::Type *type = isMod ? M-&gt;getPointerType(var-&gt;getType()) : var-&gt;getType();
      argTypes.push_back(type);
      argNames.push_back(var-&gt;getName());
      argKinds.push_back(isMod ? OutlineResult::ArgKind::MODIFIED
                               : OutlineResult::ArgKind::CONSTANT);
    }

    // Check if we need to handle control flow externally.
    // If so, function will return an int code indicating control.
    const bool callIndicatesControl = !outFlows.empty();
    if (callIndicatesControl &amp;&amp; !allowOutflows)
      return {};
    auto *funcType = M-&gt;getFuncType(
        callIndicatesControl ? M-&gt;getIntType() : M-&gt;getNoneType(), argTypes);
    auto *outlinedFunc = M-&gt;Nr&lt;BodiedFunc&gt;("__outlined");
    outlinedFunc-&gt;realize(funcType, argNames);

    // Insert function arguments in variable remappings.
    idx = 0;
    for (auto it = outlinedFunc-&gt;arg_begin(); it != outlinedFunc-&gt;arg_end(); ++it) {
      remap[idx] = {std::get&lt;0&gt;(remap[idx]), *it};
      ++idx;
    }

    // Make private vars locals of the new function.
    for (auto id : getPrivateVars()) {
      Var *var = M-&gt;getVar(id);
      seqassertn(var, "unknown var id [{}]", var-&gt;getSrcInfo());
      Var *newVar = M-&gt;N&lt;Var&gt;(var-&gt;getSrcInfo(), var-&gt;getType(), /*global=*/false,
                              /*external=*/false, var-&gt;getName());
      remap.emplace_back(var, newVar);
      outlinedFunc-&gt;push_back(newVar);
    }

    // Delete outlined region from parent function and insert into outlined function.
    auto *body = M-&gt;N&lt;SeriesFlow&gt;((*begin)-&gt;getSrcInfo());
    auto it = begin;
    while (it != end) {
      body-&gt;push_back(*it);
      it = flowRegion-&gt;erase(it);
    }
    outlinedFunc-&gt;setBody(body);

    // Replace vars and externally-handled flows.
    OutlineReplacer outRep(M, mod, remap, outFlows);
    body-&gt;accept(outRep);

    // Determine arguments for call to outlined function.
    std::vector&lt;Value *&gt; args;
    for (unsigned i = 0; i &lt; shared.size(); i++) {
      Var *var = std::get&lt;0&gt;(remap[i]);
      Value *arg = (mod.count(var-&gt;getId()) &gt; 0)
                       ? static_cast&lt;Value *&gt;(M-&gt;Nr&lt;PointerValue&gt;(var))
                       : M-&gt;Nr&lt;VarValue&gt;(var);
      args.push_back(arg);
    }
    auto *outlinedCall = call(outlinedFunc, args);

    // Check if we need external control-flow handling.
    if (callIndicatesControl) {
      auto *codeVar = M-&gt;Nr&lt;Var&gt;(M-&gt;getIntType()); // result of outlined func call
      parent-&gt;push_back(codeVar);
      it = flowRegion-&gt;insert(it, M-&gt;Nr&lt;AssignInstr&gt;(codeVar, outlinedCall));
      // Check each return code of the function. 0 means normal return; do nothing.
      for (unsigned i = 0; i &lt; outFlows.size(); i++) {
        // Generate "if (result == code) { action }".
        auto *codeVal = M-&gt;getInt(i + 1); // 1-based by convention
        auto *codeCheck = (*codeVal == *M-&gt;Nr&lt;VarValue&gt;(codeVar));
        auto *codeBody = series(outFlows[i]);
        auto *codeIf = M-&gt;Nr&lt;IfFlow&gt;(codeCheck, codeBody);
        ++it;
        it = flowRegion-&gt;insert(it, codeIf);
      }
    } else {
      it = flowRegion-&gt;insert(it, outlinedCall);
    }

    return {outlinedFunc, outlinedCall, argKinds, static_cast&lt;int&gt;(outFlows.size())};
  }
};

} // namespace

OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series,
                            decltype(series-&gt;begin()) begin,
                            decltype(series-&gt;end()) end, bool allowOutflows,
</t>
<t tx="ekr.20230509083243.284">                            bool outlineGlobals, bool allByValue) {
  if (begin == end)
    return {};
  Outliner outliner(parent, series, begin, end, outlineGlobals, allByValue);
  parent-&gt;accept(outliner);
  return outliner.outline(allowOutflows);
}

</t>
<t tx="ekr.20230509083243.285">OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series, bool allowOutflows,
</t>
<t tx="ekr.20230509083243.286">                            bool outlineGlobals, bool allByValue) {
  return outlineRegion(parent, series, series-&gt;begin(), series-&gt;end(), allowOutflows,
                       outlineGlobals, allByValue);
}

</t>
<t tx="ekr.20230509083243.287">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

/// The result of an outlining operation.
struct OutlineResult {
  /// Information about an argument of an outlined function.
  enum ArgKind {
    CONSTANT, ///&lt; Argument is not modified by outlined function
    MODIFIED, ///&lt; Argument is modified and passed by pointer
  };

  /// The outlined function
  BodiedFunc *func = nullptr;

  /// The call to the outlined function
  CallInstr *call = nullptr;

  /// Information about each argument of the outlined function.
  /// "CONSTANT" arguments are passed by value; "MODIFIED"
  /// arguments are passed by pointer and written to by the
  /// outlined function. The size of this vector is the same
  /// as the number of arguments of the outlined function; each
  /// entry corresponds to one of those arguments.
  std::vector&lt;ArgKind&gt; argKinds;

  /// Number of externally-handled control flows.
  /// For example, an outlined function that contains a "break"
  /// of a non-outlined loop will return an integer code that
  /// tells the callee to perform this break. A series of
  /// if-statements are added to the call site to check the
  /// returned code and perform the correct action. This value
  /// is the number of if-statements generated. If it is zero,
  /// the function returns void and no such checks are done.
  int numOutFlows = 0;

  operator bool() const { return bool(func); }
};

/// Outlines a region of IR delineated by begin and end iterators
/// on a particular series flow. The outlined code will be replaced
/// by a call to the outlined function, and possibly extra logic if
/// control flow needs to be handled.
/// @param parent the function containing the series flow
/// @param series the series flow on which outlining will happen
/// @param begin start of outlining
/// @param end end of outlining (non-inclusive like standard iterators)
/// @param allowOutflows allow outlining regions with "out-flows"
/// @param outlineGlobals outline globals as arguments to outlined function
/// @param allByValue pass all outlined vars by value (can change semantics)
/// @return the result of outlining
OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series,
                            decltype(series-&gt;begin()) begin,
                            decltype(series-&gt;end()) end, bool allowOutflows = true,
                            bool outlineGlobals = false, bool allByValue = false);

/// Outlines a series flow from its parent function. The outlined code
/// will be replaced by a call to the outlined function, and possibly
/// extra logic if control flow needs to be handled.
/// @param parent the function containing the series flow
/// @param series the series flow on which outlining will happen
/// @param allowOutflows allow outlining regions with "out-flows"
/// @param outlineGlobals outline globals as arguments to outlined function
/// @param allByValue pass all outlined vars by value (can change semantics)
/// @return the result of outlining
OutlineResult outlineRegion(BodiedFunc *parent, SeriesFlow *series,
                            bool allowOutflows = true, bool outlineGlobals = false,
                            bool allByValue = false);

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.288">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;vector&gt;

namespace codon {
namespace ir {
namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.289">/// Utility function to strip parameter packs.
/// @param dst the destination vector
/// @param first the value
template &lt;typename Desired&gt;
void stripPack(std::vector&lt;Desired *&gt; &amp;dst, Desired &amp;first) {
  dst.push_back(&amp;first);
}

</t>
<t tx="ekr.20230509083243.29">  void setup(SeriesFlow *block, BodiedFunc *parent) override {
    doSetup({element, slice}, block, parent);
  }

</t>
<t tx="ekr.20230509083243.290">/// Utility function to strip parameter packs.
/// @param dst the destination vector
template &lt;typename Desired&gt; void stripPack(std::vector&lt;Desired *&gt; &amp;dst) {}

</t>
<t tx="ekr.20230509083243.291">/// Utility function to strip parameter packs.
/// @param dst the destination vector
/// @param first the value
/// @param args the argument pack
template &lt;typename Desired, typename... Args&gt;
  @others
</t>
<t tx="ekr.20230509083243.292">void stripPack(std::vector&lt;Desired *&gt; &amp;dst, Desired &amp;first, Args &amp;&amp;...args) {
dst.push_back(&amp;first);
stripPack&lt;Desired&gt;(dst, std::forward&lt;Args&gt;(args)...);
}

</t>
<t tx="ekr.20230509083243.293">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "side_effect.h"

namespace codon {
namespace ir {
namespace util {

const std::string NON_PURE_ATTR = "std.internal.attributes.nonpure";
const std::string PURE_ATTR = "std.internal.attributes.pure";
const std::string NO_SIDE_EFFECT_ATTR = "std.internal.attributes.no_side_effect";
const std::string NO_CAPTURE_ATTR = "std.internal.attributes.nocapture";
const std::string DERIVES_ATTR = "std.internal.attributes.derives";
const std::string SELF_CAPTURES_ATTR = "std.internal.attributes.self_captures";

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.294">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;

namespace codon {
namespace ir {
namespace util {

/// Function side effect status. "Pure" functions by definition give the same
/// output for the same inputs and have no side effects. "No side effect"
/// functions have no side effects, but can give different outputs for the
/// same input (e.g. time() is one such function). "No capture" functions do
/// not capture any of their arguments; note that capturing an argument is
/// considered a side effect. Therefore, we have pure &lt; no_side_effect &lt;
/// no_capture &lt; unknown, where "&lt;" denotes subset. The enum values are also
/// ordered in this way, which is relied on by the implementation.
enum SideEffectStatus {
  PURE = 0,
  NO_SIDE_EFFECT,
  NO_CAPTURE,
  UNKNOWN,
};

extern const std::string NON_PURE_ATTR;
extern const std::string PURE_ATTR;
extern const std::string NO_SIDE_EFFECT_ATTR;
extern const std::string NO_CAPTURE_ATTR;
extern const std::string DERIVES_ATTR;
extern const std::string SELF_CAPTURES_ATTR;

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.295">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "visitor.h"

#include "codon/cir/cir.h"

namespace codon {
namespace ir {
namespace util {

void Visitor::visit(Module *x) { defaultVisit(x); }
void Visitor::visit(Var *x) { defaultVisit(x); }
void Visitor::visit(Func *x) { defaultVisit(x); }
void Visitor::visit(BodiedFunc *x) { defaultVisit(x); }
void Visitor::visit(ExternalFunc *x) { defaultVisit(x); }
void Visitor::visit(InternalFunc *x) { defaultVisit(x); }
void Visitor::visit(LLVMFunc *x) { defaultVisit(x); }
void Visitor::visit(Value *x) { defaultVisit(x); }
void Visitor::visit(VarValue *x) { defaultVisit(x); }
void Visitor::visit(PointerValue *x) { defaultVisit(x); }
void Visitor::visit(Flow *x) { defaultVisit(x); }
void Visitor::visit(SeriesFlow *x) { defaultVisit(x); }
void Visitor::visit(IfFlow *x) { defaultVisit(x); }
void Visitor::visit(WhileFlow *x) { defaultVisit(x); }
void Visitor::visit(ForFlow *x) { defaultVisit(x); }
void Visitor::visit(ImperativeForFlow *x) { defaultVisit(x); }
void Visitor::visit(TryCatchFlow *x) { defaultVisit(x); }
void Visitor::visit(PipelineFlow *x) { defaultVisit(x); }
void Visitor::visit(dsl::CustomFlow *x) { defaultVisit(x); }
void Visitor::visit(Const *x) { defaultVisit(x); }
void Visitor::visit(TemplatedConst&lt;int64_t&gt; *x) { defaultVisit(x); }
void Visitor::visit(TemplatedConst&lt;double&gt; *x) { defaultVisit(x); }
void Visitor::visit(TemplatedConst&lt;bool&gt; *x) { defaultVisit(x); }
void Visitor::visit(TemplatedConst&lt;std::string&gt; *x) { defaultVisit(x); }
void Visitor::visit(dsl::CustomConst *x) { defaultVisit(x); }
void Visitor::visit(Instr *x) { defaultVisit(x); }
void Visitor::visit(AssignInstr *x) { defaultVisit(x); }
void Visitor::visit(ExtractInstr *x) { defaultVisit(x); }
void Visitor::visit(InsertInstr *x) { defaultVisit(x); }
void Visitor::visit(CallInstr *x) { defaultVisit(x); }
void Visitor::visit(StackAllocInstr *x) { defaultVisit(x); }
void Visitor::visit(YieldInInstr *x) { defaultVisit(x); }
void Visitor::visit(TernaryInstr *x) { defaultVisit(x); }
void Visitor::visit(BreakInstr *x) { defaultVisit(x); }
void Visitor::visit(ContinueInstr *x) { defaultVisit(x); }
void Visitor::visit(ReturnInstr *x) { defaultVisit(x); }
void Visitor::visit(TypePropertyInstr *x) { defaultVisit(x); }
void Visitor::visit(YieldInstr *x) { defaultVisit(x); }
void Visitor::visit(ThrowInstr *x) { defaultVisit(x); }
void Visitor::visit(FlowInstr *x) { defaultVisit(x); }
void Visitor::visit(dsl::CustomInstr *x) { defaultVisit(x); }
void Visitor::visit(types::Type *x) { defaultVisit(x); }
void Visitor::visit(types::PrimitiveType *x) { defaultVisit(x); }
void Visitor::visit(types::IntType *x) { defaultVisit(x); }
void Visitor::visit(types::FloatType *x) { defaultVisit(x); }
void Visitor::visit(types::Float32Type *x) { defaultVisit(x); }
void Visitor::visit(types::BoolType *x) { defaultVisit(x); }
void Visitor::visit(types::ByteType *x) { defaultVisit(x); }
void Visitor::visit(types::VoidType *x) { defaultVisit(x); }
void Visitor::visit(types::RecordType *x) { defaultVisit(x); }
void Visitor::visit(types::RefType *x) { defaultVisit(x); }
void Visitor::visit(types::FuncType *x) { defaultVisit(x); }
void Visitor::visit(types::OptionalType *x) { defaultVisit(x); }
void Visitor::visit(types::PointerType *x) { defaultVisit(x); }
void Visitor::visit(types::GeneratorType *x) { defaultVisit(x); }
void Visitor::visit(types::IntNType *x) { defaultVisit(x); }
void Visitor::visit(types::VectorType *x) { defaultVisit(x); }
void Visitor::visit(types::UnionType *x) { defaultVisit(x); }
void Visitor::visit(dsl::types::CustomType *x) { defaultVisit(x); }

void ConstVisitor::visit(const Module *x) { defaultVisit(x); }
void ConstVisitor::visit(const Var *x) { defaultVisit(x); }
void ConstVisitor::visit(const Func *x) { defaultVisit(x); }
void ConstVisitor::visit(const BodiedFunc *x) { defaultVisit(x); }
void ConstVisitor::visit(const ExternalFunc *x) { defaultVisit(x); }
void ConstVisitor::visit(const InternalFunc *x) { defaultVisit(x); }
void ConstVisitor::visit(const LLVMFunc *x) { defaultVisit(x); }
void ConstVisitor::visit(const Value *x) { defaultVisit(x); }
void ConstVisitor::visit(const VarValue *x) { defaultVisit(x); }
void ConstVisitor::visit(const PointerValue *x) { defaultVisit(x); }
void ConstVisitor::visit(const Flow *x) { defaultVisit(x); }
void ConstVisitor::visit(const SeriesFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const IfFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const WhileFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const ForFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const ImperativeForFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const TryCatchFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const PipelineFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const dsl::CustomFlow *x) { defaultVisit(x); }
void ConstVisitor::visit(const Const *x) { defaultVisit(x); }
void ConstVisitor::visit(const TemplatedConst&lt;int64_t&gt; *x) { defaultVisit(x); }
void ConstVisitor::visit(const TemplatedConst&lt;double&gt; *x) { defaultVisit(x); }
void ConstVisitor::visit(const TemplatedConst&lt;bool&gt; *x) { defaultVisit(x); }
void ConstVisitor::visit(const TemplatedConst&lt;std::string&gt; *x) { defaultVisit(x); }
void ConstVisitor::visit(const dsl::CustomConst *x) { defaultVisit(x); }
void ConstVisitor::visit(const Instr *x) { defaultVisit(x); }
void ConstVisitor::visit(const AssignInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const ExtractInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const InsertInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const CallInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const StackAllocInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const YieldInInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const TernaryInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const BreakInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const ContinueInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const ReturnInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const TypePropertyInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const YieldInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const ThrowInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const FlowInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const dsl::CustomInstr *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::Type *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::PrimitiveType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::IntType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::FloatType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::Float32Type *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::BoolType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::ByteType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::VoidType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::RecordType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::RefType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::FuncType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::OptionalType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::PointerType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::GeneratorType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::IntNType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::VectorType *x) { defaultVisit(x); }
void ConstVisitor::visit(const types::UnionType *x) { defaultVisit(x); }
void ConstVisitor::visit(const dsl::types::CustomType *x) { defaultVisit(x); }

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.296">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;

#define VISIT(x) virtual void visit(codon::ir::x *)
#define CONST_VISIT(x) virtual void visit(const codon::ir::x *)

namespace codon {
namespace ir {
class Node;

namespace types {
class Type;
class PrimitiveType;
class IntType;
class FloatType;
class Float32Type;
class BoolType;
class ByteType;
class VoidType;
class RecordType;
class RefType;
class FuncType;
class OptionalType;
class PointerType;
class GeneratorType;
class IntNType;
class VectorType;
class UnionType;
} // namespace types

namespace dsl {

namespace types {
class CustomType;
}

class CustomConst;
class CustomFlow;
class CustomInstr;
} // namespace dsl

class Module;

class Var;

class Func;
class BodiedFunc;
class ExternalFunc;
class InternalFunc;
class LLVMFunc;

class Value;
class VarValue;
class PointerValue;

class Flow;
class SeriesFlow;
class IfFlow;
class WhileFlow;
class ForFlow;
class ImperativeForFlow;
class TryCatchFlow;
class PipelineFlow;

class Const;

template &lt;typename ValueType&gt; class TemplatedConst;

class Instr;
class AssignInstr;
class ExtractInstr;
class InsertInstr;
class CallInstr;
class StackAllocInstr;
class TypePropertyInstr;
class YieldInInstr;
class TernaryInstr;
class BreakInstr;
class ContinueInstr;
class ReturnInstr;
class YieldInstr;
class ThrowInstr;
class FlowInstr;

namespace util {

@others
} // namespace util
} // namespace ir
} // namespace codon

#undef VISIT
#undef CONST_VISIT
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.297">/// Base for CIR visitors
class Visitor {
protected:
  virtual void defaultVisit(codon::ir::Node *) {
    throw std::runtime_error("cannot visit node");
  }

public:
  virtual ~Visitor() noexcept = default;

  VISIT(Module);

  VISIT(Var);

  VISIT(Func);
  VISIT(BodiedFunc);
  VISIT(ExternalFunc);
  VISIT(InternalFunc);
  VISIT(LLVMFunc);

  VISIT(Value);
  VISIT(VarValue);
  VISIT(PointerValue);

  VISIT(Flow);
  VISIT(SeriesFlow);
  VISIT(IfFlow);
  VISIT(WhileFlow);
  VISIT(ForFlow);
  VISIT(ImperativeForFlow);
  VISIT(TryCatchFlow);
  VISIT(PipelineFlow);
  VISIT(dsl::CustomFlow);

  VISIT(Const);
  VISIT(TemplatedConst&lt;int64_t&gt;);
  VISIT(TemplatedConst&lt;double&gt;);
  VISIT(TemplatedConst&lt;bool&gt;);
  VISIT(TemplatedConst&lt;std::string&gt;);
  VISIT(dsl::CustomConst);

  VISIT(Instr);
  VISIT(AssignInstr);
  VISIT(ExtractInstr);
  VISIT(InsertInstr);
  VISIT(CallInstr);
  VISIT(StackAllocInstr);
  VISIT(TypePropertyInstr);
  VISIT(YieldInInstr);
  VISIT(TernaryInstr);
  VISIT(BreakInstr);
  VISIT(ContinueInstr);
  VISIT(ReturnInstr);
  VISIT(YieldInstr);
  VISIT(ThrowInstr);
  VISIT(FlowInstr);
  VISIT(dsl::CustomInstr);

  VISIT(types::Type);
  VISIT(types::PrimitiveType);
  VISIT(types::IntType);
  VISIT(types::FloatType);
  VISIT(types::Float32Type);
  VISIT(types::BoolType);
  VISIT(types::ByteType);
  VISIT(types::VoidType);
  VISIT(types::RecordType);
  VISIT(types::RefType);
  VISIT(types::FuncType);
  VISIT(types::OptionalType);
  VISIT(types::PointerType);
  VISIT(types::GeneratorType);
  VISIT(types::IntNType);
  VISIT(types::VectorType);
  VISIT(types::UnionType);
  VISIT(dsl::types::CustomType);
};

</t>
<t tx="ekr.20230509083243.298">class ConstVisitor {
protected:
  virtual void defaultVisit(const codon::ir::Node *) {
    throw std::runtime_error("cannot visit const node");
  }

public:
  virtual ~ConstVisitor() noexcept = default;

  CONST_VISIT(Module);

  CONST_VISIT(Var);

  CONST_VISIT(Func);
  CONST_VISIT(BodiedFunc);
  CONST_VISIT(ExternalFunc);
  CONST_VISIT(InternalFunc);
  CONST_VISIT(LLVMFunc);

  CONST_VISIT(Value);
  CONST_VISIT(VarValue);
  CONST_VISIT(PointerValue);

  CONST_VISIT(Flow);
  CONST_VISIT(SeriesFlow);
  CONST_VISIT(IfFlow);
  CONST_VISIT(WhileFlow);
  CONST_VISIT(ForFlow);
  CONST_VISIT(ImperativeForFlow);
  CONST_VISIT(TryCatchFlow);
  CONST_VISIT(PipelineFlow);
  CONST_VISIT(dsl::CustomFlow);

  CONST_VISIT(Const);
  CONST_VISIT(TemplatedConst&lt;int64_t&gt;);
  CONST_VISIT(TemplatedConst&lt;double&gt;);
  CONST_VISIT(TemplatedConst&lt;bool&gt;);
  CONST_VISIT(TemplatedConst&lt;std::string&gt;);
  CONST_VISIT(dsl::CustomConst);

  CONST_VISIT(Instr);
  CONST_VISIT(AssignInstr);
  CONST_VISIT(ExtractInstr);
  CONST_VISIT(InsertInstr);
  CONST_VISIT(CallInstr);
  CONST_VISIT(StackAllocInstr);
  CONST_VISIT(TypePropertyInstr);
  CONST_VISIT(YieldInInstr);
  CONST_VISIT(TernaryInstr);
  CONST_VISIT(BreakInstr);
  CONST_VISIT(ContinueInstr);
  CONST_VISIT(ReturnInstr);
  CONST_VISIT(YieldInstr);
  CONST_VISIT(ThrowInstr);
  CONST_VISIT(FlowInstr);
  CONST_VISIT(dsl::CustomInstr);

  CONST_VISIT(types::Type);
  CONST_VISIT(types::PrimitiveType);
  CONST_VISIT(types::IntType);
  CONST_VISIT(types::FloatType);
  CONST_VISIT(types::Float32Type);
  CONST_VISIT(types::BoolType);
  CONST_VISIT(types::ByteType);
  CONST_VISIT(types::VoidType);
  CONST_VISIT(types::RecordType);
  CONST_VISIT(types::RefType);
  CONST_VISIT(types::FuncType);
  CONST_VISIT(types::OptionalType);
  CONST_VISIT(types::PointerType);
  CONST_VISIT(types::GeneratorType);
  CONST_VISIT(types::IntNType);
  CONST_VISIT(types::VectorType);
  CONST_VISIT(types::UnionType);
  CONST_VISIT(dsl::types::CustomType);
};

</t>
<t tx="ekr.20230509083243.299"></t>
<t tx="ekr.20230509083243.3">bool isAll(Func *f) {
  return f &amp;&amp; f-&gt;getName().rfind("std.internal.builtin.all:", 0) == 0;
}

</t>
<t tx="ekr.20230509083243.30">  Value *length(Module *M) override {
    auto *e = M-&gt;Nr&lt;VarValue&gt;(vars[0]);
    auto *s = M-&gt;Nr&lt;VarValue&gt;(vars[1]);
    auto *ty = element-&gt;getType();
    auto *fn =
        M-&gt;getOrRealizeMethod(ty, "_list_add_opt_slice_len", {ty, slice-&gt;getType()});
    seqassertn(fn, "could not find slice list length helper");
    return util::call(fn, {e, s});
  }

  Value *append(Value *result) override {
    auto *M = result-&gt;getModule();
    auto *e = M-&gt;Nr&lt;VarValue&gt;(vars[0]);
    auto *s = M-&gt;Nr&lt;VarValue&gt;(vars[1]);
    auto *ty = result-&gt;getType();
    auto *fn = M-&gt;getOrRealizeMethod(ty, "_list_add_opt_slice_append",
                                     {ty, ty, slice-&gt;getType()});
    seqassertn(fn, "could not find slice list append helper");
    return util::call(fn, {result, e, s});
  }

</t>
<t tx="ekr.20230509083243.300">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "compiler.h"

#include "codon/compiler/error.h"
#include "codon/parser/cache.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/doc/doc.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/translate/translate.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

extern double totalPeg;

namespace codon {
namespace {
ir::transform::PassManager::Init getPassManagerInit(Compiler::Mode mode, bool isTest) {
  using ir::transform::PassManager;
  switch (mode) {
  case Compiler::Mode::DEBUG:
    return isTest ? PassManager::Init::RELEASE : PassManager::Init::DEBUG;
  case Compiler::Mode::RELEASE:
    return PassManager::Init::RELEASE;
  case Compiler::Mode::JIT:
    return PassManager::Init::JIT;
  default:
    return PassManager::Init::EMPTY;
  }
}
} // namespace

Compiler::Compiler(const std::string &amp;argv0, Compiler::Mode mode,
@others
llvm::Error Compiler::compile() {
  pm-&gt;run(module.get());
  if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER) {
    auto fo = fopen("_dump_ir_opt.sexp", "w");
    fmt::print(fo, "{}\n", *module);
    fclose(fo);
  }
  llvisitor-&gt;visit(module.get());
  if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER) {
    auto fo = fopen("_dump_llvm.ll", "w");
    std::string str;
    llvm::raw_string_ostream os(str);
    os &lt;&lt; *(llvisitor-&gt;getModule());
    os.flush();
    fmt::print(fo, "{}\n", str);
    fclose(fo);
  }
  return llvm::Error::success();
}

llvm::Expected&lt;std::string&gt; Compiler::docgen(const std::vector&lt;std::string&gt; &amp;files) {
  try {
    auto j = ast::DocVisitor::apply(argv0, files);
    return j-&gt;toString();
  } catch (exc::ParserException &amp;e) {
    return llvm::make_error&lt;error::ParserErrorInfo&gt;(e);
  }
}

std::unordered_map&lt;std::string, std::string&gt; Compiler::getEarlyDefines() {
  std::unordered_map&lt;std::string, std::string&gt; earlyDefines;
  earlyDefines.emplace("__debug__", debug ? "1" : "0");
  earlyDefines.emplace("__py_numerics__", pyNumerics ? "1" : "0");
  earlyDefines.emplace("__py_extension__", pyExtension ? "1" : "0");
  earlyDefines.emplace("__apple__",
#if __APPLE__
                       "1"
#else
                       "0"
#endif
  );
  return earlyDefines;
}

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.301">                   const std::vector&lt;std::string&gt; &amp;disabledPasses, bool isTest,
  @others
</t>
<t tx="ekr.20230509083243.302">                 bool pyNumerics, bool pyExtension)
  : argv0(argv0), debug(mode == Mode::DEBUG), pyNumerics(pyNumerics),
    pyExtension(pyExtension), input(), plm(std::make_unique&lt;PluginManager&gt;(argv0)),
    cache(std::make_unique&lt;ast::Cache&gt;(argv0)),
    module(std::make_unique&lt;ir::Module&gt;()),
    pm(std::make_unique&lt;ir::transform::PassManager&gt;(
        getPassManagerInit(mode, isTest), disabledPasses, pyNumerics, pyExtension)),
    llvisitor(std::make_unique&lt;ir::LLVMVisitor&gt;()) {
cache-&gt;module = module.get();
cache-&gt;pythonExt = pyExtension;
cache-&gt;pythonCompat = pyNumerics;
module-&gt;setCache(cache.get());
llvisitor-&gt;setDebug(debug);
llvisitor-&gt;setPluginManager(plm.get());
}

</t>
<t tx="ekr.20230509083243.303">llvm::Error Compiler::load(const std::string &amp;plugin) {
  auto result = plm-&gt;load(plugin);
  if (auto err = result.takeError())
    return err;

  auto *p = *result;
  if (!p-&gt;info.stdlibPath.empty()) {
    cache-&gt;pluginImportPaths.push_back(p-&gt;info.stdlibPath);
  }
  for (auto &amp;kw : p-&gt;dsl-&gt;getExprKeywords()) {
    cache-&gt;customExprStmts[kw.keyword] = kw.callback;
  }
  for (auto &amp;kw : p-&gt;dsl-&gt;getBlockKeywords()) {
    cache-&gt;customBlockStmts[kw.keyword] = {kw.hasExpr, kw.callback};
  }
  p-&gt;dsl-&gt;addIRPasses(pm.get(), debug);
  return llvm::Error::success();
}

llvm::Error
Compiler::parse(bool isCode, const std::string &amp;file, const std::string &amp;code,
</t>
<t tx="ekr.20230509083243.304">                int startLine, int testFlags,
  @others
</t>
<t tx="ekr.20230509083243.305">              const std::unordered_map&lt;std::string, std::string&gt; &amp;defines) {
input = file;
std::string abspath = (file != "-") ? ast::getAbsolutePath(file) : file;
try {
  ast::StmtPtr codeStmt = isCode
                              ? ast::parseCode(cache.get(), abspath, code, startLine)
                              : ast::parseFile(cache.get(), abspath);

  cache-&gt;module0 = file;

  Timer t2("simplify");
  t2.logged = true;
@others
  Timer t4("translate");
  ast::TranslateVisitor::apply(cache.get(), std::move(typechecked));
  t4.log();
} catch (const exc::ParserException &amp;exc) {
  std::vector&lt;error::Message&gt; messages;
  if (exc.messages.empty()) {
    for (auto &amp;e : cache-&gt;errors) {
      for (unsigned i = 0; i &lt; e.messages.size(); i++) {
        if (!e.messages[i].empty())
          messages.emplace_back(e.messages[i], e.locations[i].file,
                                e.locations[i].line, e.locations[i].col,
                                e.locations[i].len, e.errorCode);
      }
    }
    return llvm::make_error&lt;error::ParserErrorInfo&gt;(messages);
  } else {
    return llvm::make_error&lt;error::ParserErrorInfo&gt;(exc);
  }
}
module-&gt;setSrcInfo({abspath, 0, 0, 0});
if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER) {
  auto fo = fopen("_dump_ir.sexp", "w");
  fmt::print(fo, "{}\n", *module);
  fclose(fo);
}
return llvm::Error::success();
}

</t>
<t tx="ekr.20230509083243.306">  auto transformed =
      ast::SimplifyVisitor::apply(cache.get(), std::move(codeStmt), abspath, defines,
                                  getEarlyDefines(), (testFlags &gt; 1));
  LOG_TIME("[T] parse = {:.1f}", totalPeg);
  LOG_TIME("[T] simplify = {:.1f}", t2.elapsed() - totalPeg);

  if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER) {
    auto fo = fopen("_dump_simplify.sexp", "w");
    fmt::print(fo, "{}\n", transformed-&gt;toString(0));
    fclose(fo);
  }

</t>
<t tx="ekr.20230509083243.307">  Timer t3("typecheck");
</t>
<t tx="ekr.20230509083243.308">  auto typechecked =
      ast::TypecheckVisitor::apply(cache.get(), std::move(transformed));
  t3.log();
  if (codon::getLogger().flags &amp; codon::Logger::FLAG_USER) {
    auto fo = fopen("_dump_typecheck.sexp", "w");
    fmt::print(fo, "{}\n", typechecked-&gt;toString(0));
    for (auto &amp;f : cache-&gt;functions)
      for (auto &amp;r : f.second.realizations)
        fmt::print(fo, "{}\n", r.second-&gt;ast-&gt;toString(0));
    fclose(fo);
  }

</t>
<t tx="ekr.20230509083243.309">llvm::Error
Compiler::parseFile(const std::string &amp;file, int testFlags,
</t>
<t tx="ekr.20230509083243.31">  static std::unique_ptr&lt;ElementHandler&gt; get(Value *v, types::Type *ty) {
    if (!v-&gt;getType()-&gt;is(ty))
      return {};

    if (auto *c = cast&lt;CallInstr&gt;(v)) {
      auto *func = util::getFunc(c-&gt;getCallee());
      if (func &amp;&amp; func-&gt;getUnmangledName() == Module::GETITEM_MAGIC_NAME &amp;&amp;
          std::distance(c-&gt;begin(), c-&gt;end()) == 2 &amp;&amp; isList(c-&gt;front()) &amp;&amp;
          isSlice(c-&gt;back())) {
        return std::make_unique&lt;SliceHandler&gt;(c-&gt;front(), c-&gt;back());
      }
    }

    return {};
  }
</t>
<t tx="ekr.20230509083243.310">                    const std::unordered_map&lt;std::string, std::string&gt; &amp;defines) {
  return parse(/*isCode=*/false, file, /*code=*/"", /*startLine=*/0, testFlags,
               defines);
}

</t>
<t tx="ekr.20230509083243.311">llvm::Error
Compiler::parseCode(const std::string &amp;file, const std::string &amp;code, int startLine,
</t>
<t tx="ekr.20230509083243.312">                    int testFlags,
                    const std::unordered_map&lt;std::string, std::string&gt; &amp;defines) {
  return parse(/*isCode=*/true, file, code, startLine, testFlags, defines);
}

</t>
<t tx="ekr.20230509083243.313">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvisitor.h"
#include "codon/cir/module.h"
#include "codon/cir/transform/manager.h"
#include "codon/compiler/error.h"
#include "codon/dsl/plugins.h"
#include "codon/parser/cache.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.314">class Compiler {
public:
  enum Mode {
    DEBUG,
    RELEASE,
    JIT,
  };

private:
  std::string argv0;
  bool debug;
  bool pyNumerics;
  bool pyExtension;
  std::string input;
  std::unique_ptr&lt;PluginManager&gt; plm;
  std::unique_ptr&lt;ast::Cache&gt; cache;
  std::unique_ptr&lt;ir::Module&gt; module;
  std::unique_ptr&lt;ir::transform::PassManager&gt; pm;
  std::unique_ptr&lt;ir::LLVMVisitor&gt; llvisitor;

  llvm::Error parse(bool isCode, const std::string &amp;file, const std::string &amp;code,
                    int startLine, int testFlags,
                    const std::unordered_map&lt;std::string, std::string&gt; &amp;defines);

public:
  Compiler(const std::string &amp;argv0, Mode mode,
           const std::vector&lt;std::string&gt; &amp;disabledPasses = {}, bool isTest = false,
           bool pyNumerics = false, bool pyExtension = false);

  explicit Compiler(const std::string &amp;argv0, bool debug = false,
                    const std::vector&lt;std::string&gt; &amp;disabledPasses = {},
                    bool isTest = false, bool pyNumerics = false,
                    bool pyExtension = false)
      : Compiler(argv0, debug ? Mode::DEBUG : Mode::RELEASE, disabledPasses, isTest,
                 pyNumerics, pyExtension) {}

  std::string getInput() const { return input; }
  PluginManager *getPluginManager() const { return plm.get(); }
  ast::Cache *getCache() const { return cache.get(); }
  ir::Module *getModule() const { return module.get(); }
  ir::transform::PassManager *getPassManager() const { return pm.get(); }
  ir::LLVMVisitor *getLLVMVisitor() const { return llvisitor.get(); }

  llvm::Error load(const std::string &amp;plugin);
  llvm::Error
  parseFile(const std::string &amp;file, int testFlags = 0,
            const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {});
  llvm::Error
  parseCode(const std::string &amp;file, const std::string &amp;code, int startLine = 0,
            int testFlags = 0,
            const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {});
  llvm::Error compile();
  llvm::Expected&lt;std::string&gt; docgen(const std::vector&lt;std::string&gt; &amp;files);

  std::unordered_map&lt;std::string, std::string&gt; getEarlyDefines();
};

</t>
<t tx="ekr.20230509083243.315">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "debug_listener.h"

#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;sstream&gt;

#include "codon/runtime/lib.h"

namespace codon {
namespace {
std::string
makeBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace,
              std::function&lt;llvm::Expected&lt;std::string&gt;(uintptr_t)&gt; backtraceCallback) {
  std::ostringstream buf;
  buf &lt;&lt; "\033[1mBacktrace:\033[0m\n";
  for (auto pc : backtrace) {
    auto line = backtraceCallback(pc);
    if (!line)
      break;
    if (!line-&gt;empty())
      buf &lt;&lt; "  " &lt;&lt; *line &lt;&lt; "\n";
  }
  return buf.str();
}
} // namespace

@others
llvm::Expected&lt;llvm::DILineInfo&gt; DebugPlugin::symbolize(uintptr_t pc) {
  for (const auto &amp;entry : registeredObjs) {
    for (const auto &amp;info : entry.second) {
      const auto *o = info-&gt;object.get();
      for (const auto &amp;sec : o-&gt;sections()) {
        if (sec.isText()) {
          uintptr_t start =
              info-&gt;sectionLoadAddresses.lookup(llvm::cantFail(sec.getName()));
          uintptr_t stop = start + sec.getSize();
          if (start &lt;= pc &amp;&amp; pc &lt; stop) {
            llvm::symbolize::LLVMSymbolizer sym;
            return sym.symbolizeCode(
                *o, {pc - start, llvm::object::SectionedAddress::UndefSection});
          }
        }
      }
    }
  }
  return llvm::DILineInfo();
}

llvm::Expected&lt;std::string&gt; DebugPlugin::getPrettyBacktrace(uintptr_t pc) {
  auto invalid = [](const std::string &amp;name) { return name == "&lt;invalid&gt;"; };
  auto src = symbolize(pc);
  if (auto err = src.takeError())
    return std::move(err);
  if (invalid(src-&gt;FunctionName) || invalid(src-&gt;FileName))
    return "";
  return runtime::makeBacktraceFrameString(pc, src-&gt;FunctionName, src-&gt;FileName,
                                           src-&gt;Line, src-&gt;Column);
}

std::string DebugPlugin::getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace) {
  return makeBacktrace(backtrace, [&amp;](uintptr_t pc) { return getPrettyBacktrace(pc); });
}

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.316">void DebugListener::notifyObjectLoaded(ObjectKey key,
  @others
</t>
<t tx="ekr.20230509083243.317">                                     const llvm::object::ObjectFile &amp;obj,
@others
</t>
<t tx="ekr.20230509083243.318">                                     const llvm::RuntimeDyld::LoadedObjectInfo &amp;L) {
uintptr_t start = 0, stop = 0;
for (const auto &amp;sec : obj.sections()) {
  if (sec.isText()) {
    start = L.getSectionLoadAddress(sec);
    stop = start + sec.getSize();
    break;
  }
}
auto buf = llvm::MemoryBuffer::getMemBufferCopy(obj.getData(), obj.getFileName());
auto newObj = llvm::cantFail(
    llvm::object::ObjectFile::createObjectFile(buf-&gt;getMemBufferRef()));
objects.emplace_back(key, std::move(newObj), std::move(buf), start, stop);
}

</t>
<t tx="ekr.20230509083243.319">void DebugListener::notifyFreeingObject(ObjectKey key) {
  @others
</t>
<t tx="ekr.20230509083243.32">};

struct LiteralHandler : public ElementHandler {
  std::vector&lt;Value *&gt; elements;

  LiteralHandler(std::vector&lt;Value *&gt; elements)
      : ElementHandler(), elements(std::move(elements)) {}

</t>
<t tx="ekr.20230509083243.320">objects.erase(
    std::remove_if(objects.begin(), objects.end(),
                   [key](const ObjectInfo &amp;o) { return key == o.getKey(); }),
    objects.end());
}

</t>
<t tx="ekr.20230509083243.321">llvm::Expected&lt;llvm::DILineInfo&gt; DebugListener::symbolize(uintptr_t pc) {
  for (const auto &amp;o : objects) {
    if (o.contains(pc)) {
      llvm::symbolize::LLVMSymbolizer sym;
      return sym.symbolizeCode(
          o.getObject(),
          {pc - o.getStart(), llvm::object::SectionedAddress::UndefSection});
    }
  }
  return llvm::DILineInfo();
}

llvm::Expected&lt;std::string&gt; DebugListener::getPrettyBacktrace(uintptr_t pc) {
  auto invalid = [](const std::string &amp;name) { return name == "&lt;invalid&gt;"; };
  auto src = symbolize(pc);
  if (auto err = src.takeError())
    return std::move(err);
  if (invalid(src-&gt;FunctionName) || invalid(src-&gt;FileName))
    return "";
  return runtime::makeBacktraceFrameString(pc, src-&gt;FunctionName, src-&gt;FileName,
                                           src-&gt;Line, src-&gt;Column);
}

std::string DebugListener::getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace) {
  return makeBacktrace(backtrace, [&amp;](uintptr_t pc) { return getPrettyBacktrace(pc); });
}

</t>
<t tx="ekr.20230509083243.322">void DebugPlugin::notifyMaterializing(llvm::orc::MaterializationResponsibility &amp;mr,
                                      llvm::jitlink::LinkGraph &amp;graph,
                                      llvm::jitlink::JITLinkContext &amp;ctx,
                                      llvm::MemoryBufferRef inputObject) {
  @others
}

</t>
<t tx="ekr.20230509083243.323">auto newBuf =
    llvm::MemoryBuffer::getMemBufferCopy(inputObject.getBuffer(), graph.getName());
  @others
</t>
<t tx="ekr.20230509083243.324">  auto newObj = llvm::cantFail(
  llvm::object::ObjectFile::createObjectFile(newBuf-&gt;getMemBufferRef()));

  {
std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
assert(pendingObjs.count(&amp;mr) == 0);
pendingObjs[&amp;mr] = std::unique_ptr&lt;JITObjectInfo&gt;(
    new JITObjectInfo{std::move(newBuf), std::move(newObj), {}});
  }
</t>
<t tx="ekr.20230509083243.325">llvm::Error DebugPlugin::notifyEmitted(llvm::orc::MaterializationResponsibility &amp;mr) {
  {
    std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
    auto it = pendingObjs.find(&amp;mr);
    if (it == pendingObjs.end())
      return llvm::Error::success();

    auto newInfo = pendingObjs[&amp;mr].get();
</t>
<t tx="ekr.20230509083243.326">    auto getLoadAddress = [newInfo](const llvm::StringRef &amp;name) -&gt; uint64_t {
      auto result = newInfo-&gt;sectionLoadAddresses.find(name);
      if (result == newInfo-&gt;sectionLoadAddresses.end())
        return 0;
      return result-&gt;second;
    };

</t>
<t tx="ekr.20230509083243.327">    // register(*newInfo-&gt;Object, getLoadAddress, nullptr)
  }

  llvm::cantFail(mr.withResourceKeyDo([&amp;](llvm::orc::ResourceKey key) {
    std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
    registeredObjs[key].push_back(std::move(pendingObjs[&amp;mr]));
    pendingObjs.erase(&amp;mr);
  }));

  return llvm::Error::success();
}

llvm::Error DebugPlugin::notifyFailed(llvm::orc::MaterializationResponsibility &amp;mr) {
  std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
  pendingObjs.erase(&amp;mr);
  return llvm::Error::success();
}

llvm::Error DebugPlugin::notifyRemovingResources(llvm::orc::ResourceKey key) {
  std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
  registeredObjs.erase(key);
  return llvm::Error::success();
}

</t>
<t tx="ekr.20230509083243.328">void DebugPlugin::notifyTransferringResources(llvm::orc::ResourceKey dstKey,
                                              llvm::orc::ResourceKey srcKey) {
  std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
  auto it = registeredObjs.find(srcKey);
  if (it != registeredObjs.end()) {
    for (std::unique_ptr&lt;JITObjectInfo&gt; &amp;info : it-&gt;second)
      registeredObjs[dstKey].push_back(std::move(info));
    registeredObjs.erase(it);
  }
}

</t>
<t tx="ekr.20230509083243.329">void DebugPlugin::modifyPassConfig(llvm::orc::MaterializationResponsibility &amp;mr,
                                   llvm::jitlink::LinkGraph &amp;graph,
                                   llvm::jitlink::PassConfiguration &amp;config) {
  std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
  auto it = pendingObjs.find(&amp;mr);
  if (it == pendingObjs.end())
    return;

  JITObjectInfo &amp;info = *it-&gt;second;
  config.PostAllocationPasses.push_back(
      [&amp;info, this](llvm::jitlink::LinkGraph &amp;graph) -&gt; llvm::Error {
        std::lock_guard&lt;std::mutex&gt; lock(pluginMutex);
        for (const llvm::jitlink::Section &amp;sec : graph.sections()) {
#if defined(__APPLE__) &amp;&amp; defined(__MACH__)
          size_t secPos = sec.getName().find(',');
          if (secPos &gt;= 16 || (sec.getName().size() - (secPos + 1) &gt; 16))
            continue;
          auto secName = sec.getName().substr(secPos + 1);
#else
          auto secName = sec.getName();
#endif
          info.sectionLoadAddresses[secName] =
              llvm::jitlink::SectionRange(sec).getStart().getValue();
        }
        return llvm::Error::success();
      });
}

</t>
<t tx="ekr.20230509083243.33">  void setup(SeriesFlow *block, BodiedFunc *parent) override {
    doSetup(elements, block, parent);
  }

</t>
<t tx="ekr.20230509083243.330">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.331">/// Debug info tracker for MCJIT.
class DebugListener : public llvm::JITEventListener {
public:
@others
private:
  std::vector&lt;ObjectInfo&gt; objects;

  void notifyObjectLoaded(ObjectKey key, const llvm::object::ObjectFile &amp;obj,
                          const llvm::RuntimeDyld::LoadedObjectInfo &amp;L) override;
  void notifyFreeingObject(ObjectKey key) override;

public:
  DebugListener() : llvm::JITEventListener(), objects() {}

  llvm::Expected&lt;llvm::DILineInfo&gt; symbolize(uintptr_t pc);
  llvm::Expected&lt;std::string&gt; getPrettyBacktrace(uintptr_t pc);
  std::string getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace);
};

</t>
<t tx="ekr.20230509083243.332">  class ObjectInfo {
  private:
    ObjectKey key;
    std::unique_ptr&lt;llvm::object::ObjectFile&gt; object;
    std::unique_ptr&lt;llvm::MemoryBuffer&gt; buffer;
    uintptr_t start;
    uintptr_t stop;

  public:
    ObjectInfo(ObjectKey key, std::unique_ptr&lt;llvm::object::ObjectFile&gt; object,
               std::unique_ptr&lt;llvm::MemoryBuffer&gt; buffer, uintptr_t start,
               uintptr_t stop)
        : key(key), object(std::move(object)), buffer(std::move(buffer)), start(start),
          stop(stop) {}

    ObjectKey getKey() const { return key; }
    const llvm::object::ObjectFile &amp;getObject() const { return *object; }
    uintptr_t getStart() const { return start; }
    uintptr_t getStop() const { return stop; }
    bool contains(uintptr_t pc) const { return start &lt;= pc &amp;&amp; pc &lt; stop; }
  };

</t>
<t tx="ekr.20230509083243.333">/// Debug info tracker for JITLink. Adapted from Julia's implementation:
/// https://github.com/JuliaLang/julia/blob/master/src/jitlayers.cpp
class DebugPlugin : public llvm::orc::ObjectLinkingLayer::Plugin {
  struct JITObjectInfo {
    std::unique_ptr&lt;llvm::MemoryBuffer&gt; backingBuffer;
    std::unique_ptr&lt;llvm::object::ObjectFile&gt; object;
    llvm::StringMap&lt;uint64_t&gt; sectionLoadAddresses;
  };

  std::mutex pluginMutex;
  std::map&lt;llvm::orc::MaterializationResponsibility *, std::unique_ptr&lt;JITObjectInfo&gt;&gt;
      pendingObjs;
  std::map&lt;llvm::orc::ResourceKey, std::vector&lt;std::unique_ptr&lt;JITObjectInfo&gt;&gt;&gt;
      registeredObjs;

public:
  void notifyMaterializing(llvm::orc::MaterializationResponsibility &amp;mr,
                           llvm::jitlink::LinkGraph &amp;graph,
                           llvm::jitlink::JITLinkContext &amp;ctx,
                           llvm::MemoryBufferRef inputObject) override;
  llvm::Error notifyEmitted(llvm::orc::MaterializationResponsibility &amp;mr) override;
  llvm::Error notifyFailed(llvm::orc::MaterializationResponsibility &amp;mr) override;
  llvm::Error notifyRemovingResources(llvm::orc::ResourceKey key) override;
  void notifyTransferringResources(llvm::orc::ResourceKey dstKey,
                                   llvm::orc::ResourceKey srcKey) override;
  void modifyPassConfig(llvm::orc::MaterializationResponsibility &amp;mr,
                        llvm::jitlink::LinkGraph &amp;,
                        llvm::jitlink::PassConfiguration &amp;config) override;

  llvm::Expected&lt;llvm::DILineInfo&gt; symbolize(uintptr_t pc);
  llvm::Expected&lt;std::string&gt; getPrettyBacktrace(uintptr_t pc);
  std::string getPrettyBacktrace(const std::vector&lt;uintptr_t&gt; &amp;backtrace);
};

</t>
<t tx="ekr.20230509083243.334">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "engine.h"

#include "codon/cir/llvm/optimize.h"
#include "codon/compiler/memory_manager.h"

namespace codon {
namespace jit {

@others
Engine::Engine(std::unique_ptr&lt;llvm::orc::ExecutionSession&gt; sess,
               std::unique_ptr&lt;llvm::orc::EPCIndirectionUtils&gt; epciu,
               llvm::orc::JITTargetMachineBuilder jtmb, llvm::DataLayout layout)
    : sess(std::move(sess)), epciu(std::move(epciu)), layout(std::move(layout)),
      mangle(*this-&gt;sess, this-&gt;layout),
      objectLayer(*this-&gt;sess,
                  []() { return std::make_unique&lt;BoehmGCMemoryManager&gt;(); }),
      compileLayer(*this-&gt;sess, objectLayer,
                   std::make_unique&lt;llvm::orc::ConcurrentIRCompiler&gt;(std::move(jtmb))),
      optimizeLayer(*this-&gt;sess, compileLayer, optimizeModule),
      codLayer(*this-&gt;sess, optimizeLayer, this-&gt;epciu-&gt;getLazyCallThroughManager(),
               [this] { return this-&gt;epciu-&gt;createIndirectStubsManager(); }),
      mainJD(this-&gt;sess-&gt;createBareJITDylib("&lt;main&gt;")),
      dbListener(std::make_unique&lt;DebugListener&gt;()) {
  mainJD.addGenerator(
      llvm::cantFail(llvm::orc::DynamicLibrarySearchGenerator::GetForCurrentProcess(
          layout.getGlobalPrefix())));
  objectLayer.setAutoClaimResponsibilityForObjectSymbols(true);
  objectLayer.registerJITEventListener(*dbListener);
}

Engine::~Engine() {
  if (auto err = sess-&gt;endSession())
    sess-&gt;reportError(std::move(err));
  if (auto err = epciu-&gt;cleanup())
    sess-&gt;reportError(std::move(err));
}

llvm::Expected&lt;std::unique_ptr&lt;Engine&gt;&gt; Engine::create() {
  auto epc = llvm::orc::SelfExecutorProcessControl::Create();
  if (!epc)
    return epc.takeError();

  auto sess = std::make_unique&lt;llvm::orc::ExecutionSession&gt;(std::move(*epc));

  auto epciu =
      llvm::orc::EPCIndirectionUtils::Create(sess-&gt;getExecutorProcessControl());
  if (!epciu)
    return epciu.takeError();

  (*epciu)-&gt;createLazyCallThroughManager(
      *sess, llvm::pointerToJITTargetAddress(&amp;handleLazyCallThroughError));

  if (auto err = llvm::orc::setUpInProcessLCTMReentryViaEPCIU(**epciu))
    return std::move(err);

  llvm::orc::JITTargetMachineBuilder jtmb(
      sess-&gt;getExecutorProcessControl().getTargetTriple());

  auto layout = jtmb.getDefaultDataLayoutForTarget();
  if (!layout)
    return layout.takeError();

  return std::make_unique&lt;Engine&gt;(std::move(sess), std::move(*epciu), std::move(jtmb),
                                  std::move(*layout));
}

llvm::Error Engine::addModule(llvm::orc::ThreadSafeModule module,
                              llvm::orc::ResourceTrackerSP rt) {
  if (!rt)
    rt = mainJD.getDefaultResourceTracker();

  return optimizeLayer.add(rt, std::move(module));
}

llvm::Expected&lt;llvm::JITEvaluatedSymbol&gt; Engine::lookup(llvm::StringRef name) {
  return sess-&gt;lookup({&amp;mainJD}, mangle(name.str()));
}

} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.335">void Engine::handleLazyCallThroughError() {
  llvm::errs() &lt;&lt; "LazyCallThrough error: Could not find function body";
  exit(1);
}

</t>
<t tx="ekr.20230509083243.336">llvm::Expected&lt;llvm::orc::ThreadSafeModule&gt;
Engine::optimizeModule(llvm::orc::ThreadSafeModule module,
</t>
<t tx="ekr.20230509083243.337">                       const llvm::orc::MaterializationResponsibility &amp;R) {
  module.withModuleDo([](llvm::Module &amp;module) {
    ir::optimize(&amp;module, /*debug=*/false, /*jit=*/true);
  });
  return std::move(module);
}

</t>
<t tx="ekr.20230509083243.338">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"
#include "codon/compiler/debug_listener.h"

namespace codon {
namespace jit {

@others
} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.339">class Engine {
private:
  std::unique_ptr&lt;llvm::orc::ExecutionSession&gt; sess;
  std::unique_ptr&lt;llvm::orc::EPCIndirectionUtils&gt; epciu;

  llvm::DataLayout layout;
  llvm::orc::MangleAndInterner mangle;

  llvm::orc::RTDyldObjectLinkingLayer objectLayer;
  llvm::orc::IRCompileLayer compileLayer;
  llvm::orc::IRTransformLayer optimizeLayer;
  llvm::orc::CompileOnDemandLayer codLayer;

  llvm::orc::JITDylib &amp;mainJD;

  std::unique_ptr&lt;DebugListener&gt; dbListener;

  static void handleLazyCallThroughError();

  static llvm::Expected&lt;llvm::orc::ThreadSafeModule&gt;
  optimizeModule(llvm::orc::ThreadSafeModule module,
                 const llvm::orc::MaterializationResponsibility &amp;R);

public:
  Engine(std::unique_ptr&lt;llvm::orc::ExecutionSession&gt; sess,
         std::unique_ptr&lt;llvm::orc::EPCIndirectionUtils&gt; epciu,
         llvm::orc::JITTargetMachineBuilder jtmb, llvm::DataLayout layout);

  ~Engine();

  static llvm::Expected&lt;std::unique_ptr&lt;Engine&gt;&gt; create();

  const llvm::DataLayout &amp;getDataLayout() const { return layout; }

  llvm::orc::JITDylib &amp;getMainJITDylib() { return mainJD; }

  DebugListener *getDebugListener() const { return dbListener.get(); }

  llvm::Error addModule(llvm::orc::ThreadSafeModule module,
                        llvm::orc::ResourceTrackerSP rt = nullptr);

  llvm::Expected&lt;llvm::JITEvaluatedSymbol&gt; lookup(llvm::StringRef name);
};

</t>
<t tx="ekr.20230509083243.34">  Value *length(Module *M) override { return M-&gt;getInt(elements.size()); }

  Value *append(Value *result) override {
    auto *M = result-&gt;getModule();
    auto *ty = result-&gt;getType();
    auto *block = M-&gt;Nr&lt;SeriesFlow&gt;();
    if (vars.empty())
      return block;
    auto *fn = M-&gt;getOrRealizeMethod(ty, "_list_add_opt_literal_append",
                                     {ty, elements[0]-&gt;getType()});
    seqassertn(fn, "could not find literal list append helper");
    for (auto *var : vars) {
      block-&gt;push_back(util::call(fn, {result, M-&gt;Nr&lt;VarValue&gt;(var)}));
    }
    return block;
  }

</t>
<t tx="ekr.20230509083243.340">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "error.h"

namespace codon {
namespace error {

char ParserErrorInfo::ID = 0;

char RuntimeErrorInfo::ID = 0;

char PluginErrorInfo::ID = 0;

char IOErrorInfo::ID = 0;

void raise_error(const char *format) { throw exc::ParserException(format); }

@others
} // namespace error
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.341">void raise_error(int e, const ::codon::SrcInfo &amp;info, const char *format) {
  throw exc::ParserException(e, format, info);
}

</t>
<t tx="ekr.20230509083243.342">void raise_error(int e, const ::codon::SrcInfo &amp;info, const std::string &amp;format) {
  throw exc::ParserException(e, format, info);
}

</t>
<t tx="ekr.20230509083243.343">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/error.h"
#include "llvm/Support/Error.h"
#include &lt;fmt/format.h&gt;

namespace codon {
namespace error {

@others
} // namespace error
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.344">class Message {
private:
  std::string msg;
  std::string file;
  int line = 0;
  int col = 0;
  int len = 0;
  int errorCode = -1;

public:
  explicit Message(const std::string &amp;msg, const std::string &amp;file = "", int line = 0,
@others
};

</t>
<t tx="ekr.20230509083243.345">                   int col = 0, int len = 0, int errorCode = -1)
      : msg(msg), file(file), line(line), col(col), len(len), errorCode(-1) {}

  std::string getMessage() const { return msg; }
  std::string getFile() const { return file; }
  int getLine() const { return line; }
  int getColumn() const { return col; }
  int getLength() const { return len; }
  int getErrorCode() const { return errorCode; }

    @others
</t>
<t tx="ekr.20230509083243.346">  void log(llvm::raw_ostream &amp;out) const {
if (!getFile().empty()) {
  out &lt;&lt; getFile();
  if (getLine() != 0) {
    out &lt;&lt; ":" &lt;&lt; getLine();
    if (getColumn() != 0) {
      out &lt;&lt; ":" &lt;&lt; getColumn();
    }
  }
  out &lt;&lt; ": ";
}
out &lt;&lt; getMessage();
  }
</t>
<t tx="ekr.20230509083243.347">class ParserErrorInfo : public llvm::ErrorInfo&lt;ParserErrorInfo&gt; {
private:
  std::vector&lt;std::vector&lt;Message&gt;&gt; messages;

public:
  explicit ParserErrorInfo(const std::vector&lt;Message&gt; &amp;m) : messages() {
    for (auto &amp;msg : m) {
      messages.push_back({msg});
    }
  }
  explicit ParserErrorInfo(const exc::ParserException &amp;e) : messages() {
    std::vector&lt;Message&gt; group;
    for (unsigned i = 0; i &lt; e.messages.size(); i++) {
      if (!e.messages[i].empty())
        group.emplace_back(e.messages[i], e.locations[i].file, e.locations[i].line,
                           e.locations[i].col, e.locations[i].len);
    }
    messages.push_back(group);
  }

  auto begin() { return messages.begin(); }
  auto end() { return messages.end(); }
  auto begin() const { return messages.begin(); }
  auto end() const { return messages.end(); }

@others
  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509083243.348">  void log(llvm::raw_ostream &amp;out) const override {
    for (auto &amp;group : messages) {
      for (auto &amp;msg : group) {
        msg.log(out);
        out &lt;&lt; "\n";
      }
    }
  }

</t>
<t tx="ekr.20230509083243.349">class RuntimeErrorInfo : public llvm::ErrorInfo&lt;RuntimeErrorInfo&gt; {
private:
  std::string output;
  std::string type;
  Message message;
  std::vector&lt;std::string&gt; backtrace;

public:
  RuntimeErrorInfo(const std::string &amp;output, const std::string &amp;type,
                   const std::string &amp;msg, const std::string &amp;file = "", int line = 0,
                   int col = 0, std::vector&lt;std::string&gt; backtrace = {})
      : output(output), type(type), message(msg, file, line, col),
        backtrace(std::move(backtrace)) {}

  std::string getOutput() const { return output; }
  std::string getType() const { return type; }
  std::string getMessage() const { return message.getMessage(); }
  std::string getFile() const { return message.getFile(); }
  int getLine() const { return message.getLine(); }
  int getColumn() const { return message.getColumn(); }
  std::vector&lt;std::string&gt; getBacktrace() const { return backtrace; }

@others
  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509083243.35">  static std::unique_ptr&lt;ElementHandler&gt; get(Value *v, types::Type *ty) {
    if (!v-&gt;getType()-&gt;is(ty))
      return {};

    if (auto *attr = v-&gt;getAttribute&lt;ListLiteralAttribute&gt;()) {
      std::vector&lt;Value *&gt; elements;
      for (auto &amp;element : attr-&gt;elements) {
        if (element.star)
          return {};
        elements.push_back(element.value);
      }
      return std::make_unique&lt;LiteralHandler&gt;(std::move(elements));
    }

    return {};
  }
</t>
<t tx="ekr.20230509083243.350">  void log(llvm::raw_ostream &amp;out) const override {
    out &lt;&lt; type &lt;&lt; ": ";
    message.log(out);
  }

</t>
<t tx="ekr.20230509083243.351">class PluginErrorInfo : public llvm::ErrorInfo&lt;PluginErrorInfo&gt; {
private:
  std::string message;

public:
  explicit PluginErrorInfo(const std::string &amp;message) : message(message) {}

  std::string getMessage() const { return message; }

  void log(llvm::raw_ostream &amp;out) const override { out &lt;&lt; message; }

  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509083243.352">class IOErrorInfo : public llvm::ErrorInfo&lt;IOErrorInfo&gt; {
private:
  std::string message;

public:
  explicit IOErrorInfo(const std::string &amp;message) : message(message) {}

  std::string getMessage() const { return message; }

  void log(llvm::raw_ostream &amp;out) const override { out &lt;&lt; message; }

  std::error_code convertToErrorCode() const override {
    return llvm::inconvertibleErrorCode();
  }

  static char ID;
};

</t>
<t tx="ekr.20230509083243.353">enum Error {
  CALL_NAME_ORDER,
  CALL_NAME_STAR,
  CALL_ELLIPSIS,
  IMPORT_IDENTIFIER,
  IMPORT_FN,
  FN_LLVM,
  FN_LAST_KWARG,
  FN_MULTIPLE_ARGS,
  FN_DEFAULT_STARARG,
  FN_ARG_TWICE,
  FN_DEFAULT,
  FN_C_DEFAULT,
  FN_C_TYPE,
  FN_SINGLE_DECORATOR,
  CLASS_EXTENSION,
  CLASS_MISSING_TYPE,
  CLASS_ARG_TWICE,
  CLASS_BAD_DECORATOR,
  CLASS_MULTIPLE_DECORATORS,
  CLASS_SINGLE_DECORATOR,
  CLASS_CONFLICT_DECORATOR,
  CLASS_NONSTATIC_DECORATOR,
  CLASS_BAD_DECORATOR_ARG,
  ID_NOT_FOUND,
  ID_CANNOT_CAPTURE,
  ID_INVALID_BIND,
  UNION_TOO_BIG,
  COMPILER_NO_FILE,
  COMPILER_NO_STDLIB,
  ID_NONLOCAL,
  IMPORT_NO_MODULE,
  IMPORT_NO_NAME,
  DEL_NOT_ALLOWED,
  DEL_INVALID,
  ASSIGN_INVALID,
  ASSIGN_LOCAL_REFERENCE,
  ASSIGN_MULTI_STAR,
  INT_RANGE,
  FLOAT_RANGE,
  STR_FSTRING_BALANCE_EXTRA,
  STR_FSTRING_BALANCE_MISSING,
  CALL_NO_TYPE,
  CALL_TUPLE_COMPREHENSION,
  CALL_NAMEDTUPLE,
  CALL_PARTIAL,
  EXPECTED_TOPLEVEL,
  CLASS_ID_NOT_FOUND,
  CLASS_INVALID_BIND,
  CLASS_NO_INHERIT,
  CLASS_TUPLE_INHERIT,
  CLASS_BAD_MRO,
  CLASS_BAD_ATTR,
  MATCH_MULTI_ELLIPSIS,
  FN_OUTSIDE_ERROR,
  FN_GLOBAL_ASSIGNED,
  FN_GLOBAL_NOT_FOUND,
  FN_NO_DECORATORS,
  FN_BAD_LLVM,
  FN_REALIZE_BUILTIN,
  EXPECTED_LOOP,
  LOOP_DECORATOR,
  BAD_STATIC_TYPE,
  EXPECTED_TYPE,
  UNEXPECTED_TYPE,
  DOT_NO_ATTR,
  DOT_NO_ATTR_ARGS,
  FN_NO_ATTR_ARGS,
  EXPECTED_STATIC,
  EXPECTED_STATIC_SPECIFIED,
  ASSIGN_UNEXPECTED_STATIC,
  ASSIGN_UNEXPECTED_FROZEN,
  CALL_BAD_UNPACK,
  CALL_BAD_ITER,
  CALL_BAD_KWUNPACK,
  CALL_REPEATED_NAME,
  CALL_RECURSIVE_DEFAULT,
  CALL_SUPERF,
  CALL_SUPER_PARENT,
  CALL_PTR_VAR,
  EXPECTED_TUPLE,
  CALL_REALIZED_FN,
  CALL_ARGS_MANY,
  CALL_ARGS_INVALID,
  CALL_ARGS_MISSING,
  GENERICS_MISMATCH,
  EXPECTED_GENERATOR,
  STATIC_RANGE_BOUNDS,
  TUPLE_RANGE_BOUNDS,
  STATIC_DIV_ZERO,
  SLICE_STEP_ZERO,
  OP_NO_MAGIC,
  INST_CALLABLE_STATIC,
  TYPE_CANNOT_REALIZE_ATTR,
  TYPE_UNIFY,
  TYPE_FAILED,
  MAX_REALIZATION,
  CUSTOM,
  __END__
};

template &lt;class... TA&gt; std::string Emsg(Error e, const TA &amp;...args) {
  switch (e) {
  /// Validations
  case Error::CALL_NAME_ORDER:
    return fmt::format("positional argument follows keyword argument");
  case Error::CALL_NAME_STAR:
    return fmt::format("cannot use starred expression here");
  case Error::CALL_ELLIPSIS:
    return fmt::format("multiple ellipsis expressions");
  case Error::IMPORT_IDENTIFIER:
    return fmt::format("expected identifier");
  case Error::IMPORT_FN:
    return fmt::format(
        "function signatures only allowed when importing C or Python functions");
  case Error::FN_LLVM:
    return fmt::format("return types required for LLVM and C functions");
  case Error::FN_LAST_KWARG:
    return fmt::format("kwargs must be the last argument");
  case Error::FN_MULTIPLE_ARGS:
    return fmt::format("multiple star arguments provided");
  case Error::FN_DEFAULT_STARARG:
    return fmt::format("star arguments cannot have default values");
  case Error::FN_ARG_TWICE:
    return fmt::format("duplicate argument '{}' in function definition", args...);
  case Error::FN_DEFAULT:
    return fmt::format("non-default argument '{}' follows default argument", args...);
  case Error::FN_C_DEFAULT:
    return fmt::format(
        "argument '{}' within C function definition cannot have default value",
        args...);
  case Error::FN_C_TYPE:
    return fmt::format(
        "argument '{}' within C function definition requires type annotation", args...);
  case Error::FN_SINGLE_DECORATOR:
    return fmt::format("cannot combine '@{}' with other attributes or decorators",
                       args...);
  case Error::CLASS_EXTENSION:
    return fmt::format("class extensions cannot define data attributes and generics or "
                       "inherit other classes");
  case Error::CLASS_MISSING_TYPE:
    return fmt::format("type required for data attribute '{}'", args...);
  case Error::CLASS_ARG_TWICE:
    return fmt::format("duplicate data attribute '{}' in class definition", args...);
  case Error::CLASS_BAD_DECORATOR:
    return fmt::format("unsupported class decorator");
  case Error::CLASS_MULTIPLE_DECORATORS:
    return fmt::format("duplicate decorator '@{}' in class definition", args...);
  case Error::CLASS_SINGLE_DECORATOR:
    return fmt::format("cannot combine '@{}' with other attributes or decorators",
                       args...);
  case Error::CLASS_CONFLICT_DECORATOR:
    return fmt::format("cannot combine '@{}' with '@{}'", args...);
  case Error::CLASS_NONSTATIC_DECORATOR:
    return fmt::format("class decorator arguments must be compile-time static values");
  case Error::CLASS_BAD_DECORATOR_ARG:
    return fmt::format("class decorator got unexpected argument");
  /// Simplification
  case Error::ID_NOT_FOUND:
    return fmt::format("name '{}' is not defined", args...);
  case Error::ID_CANNOT_CAPTURE:
    return fmt::format("name '{}' cannot be captured", args...);
  case Error::ID_NONLOCAL:
    return fmt::format("no binding for nonlocal '{}' found", args...);
  case Error::ID_INVALID_BIND:
    return fmt::format("cannot bind '{}' to global or nonlocal name", args...);
  case Error::IMPORT_NO_MODULE:
    return fmt::format("no module named '{}'", args...);
  case Error::IMPORT_NO_NAME:
    return fmt::format("cannot import name '{}' from '{}'", args...);
  case Error::DEL_NOT_ALLOWED:
    return fmt::format("name '{}' cannot be deleted", args...);
  case Error::DEL_INVALID:
    return fmt::format("cannot delete given expression", args...);
  case Error::ASSIGN_INVALID:
    return fmt::format("cannot assign to given expression");
  case Error::ASSIGN_LOCAL_REFERENCE:
    return fmt::format("local variable '{}' referenced before assignment", args...);
  case Error::ASSIGN_MULTI_STAR:
    return fmt::format("multiple starred expressions in assignment");
  case Error::INT_RANGE:
    return fmt::format("integer '{}' cannot fit into 64-bit integer", args...);
  case Error::FLOAT_RANGE:
    return fmt::format("float '{}' cannot fit into 64-bit float", args...);
  case Error::STR_FSTRING_BALANCE_EXTRA:
    return fmt::format("expecting '}}' in f-string");
  case Error::STR_FSTRING_BALANCE_MISSING:
    return fmt::format("single '}}' is not allowed in f-string");
  case Error::CALL_NO_TYPE:
    return fmt::format("cannot use type() in type signatures", args...);
  case Error::CALL_TUPLE_COMPREHENSION:
    return fmt::format(
        "tuple constructor does not accept nested or conditioned comprehensions",
        args...);
  case Error::CALL_NAMEDTUPLE:
    return fmt::format("namedtuple() takes 2 static arguments", args...);
  case Error::CALL_PARTIAL:
    return fmt::format("partial() takes 1 or more arguments", args...);
  case Error::EXPECTED_TOPLEVEL:
    return fmt::format("{} must be a top-level statement", args...);
  case Error::CLASS_ID_NOT_FOUND:
    // Note that type aliases are not valid class names
    return fmt::format("class name '{}' is not defined", args...);
  case Error::CLASS_INVALID_BIND:
    return fmt::format("cannot bind '{}' to class or function", args...);
  case Error::CLASS_NO_INHERIT:
    return fmt::format("{} classes cannot inherit other classes", args...);
  case Error::CLASS_TUPLE_INHERIT:
    return fmt::format("reference classes cannot inherit tuple classes");
  case Error::CLASS_BAD_MRO:
    return fmt::format("inconsistent class hierarchy");
  case Error::CLASS_BAD_ATTR:
    return fmt::format("unexpected expression in class definition");
  case Error::MATCH_MULTI_ELLIPSIS:
    return fmt::format("multiple ellipses in a pattern");
  case Error::FN_OUTSIDE_ERROR:
    return fmt::format("'{}' outside function", args...);
  case Error::FN_GLOBAL_ASSIGNED:
    return fmt::format("name '{}' is assigned to before global declaration", args...);
  case Error::FN_GLOBAL_NOT_FOUND:
    return fmt::format("no binding for {} '{}' found", args...);
  case Error::FN_NO_DECORATORS:
    return fmt::format("class methods cannot be decorated", args...);
  case Error::FN_BAD_LLVM:
    return fmt::format("invalid LLVM code");
  case Error::FN_REALIZE_BUILTIN:
    return fmt::format("builtin, exported and external functions cannot be generic");
  case Error::EXPECTED_LOOP:
    return fmt::format("'{}' outside loop", args...);
  case Error::LOOP_DECORATOR:
    return fmt::format("invalid loop decorator");
  case Error::BAD_STATIC_TYPE:
    return fmt::format(
        "expected 'int' or 'str' (only integers and strings can be static)");
  case Error::EXPECTED_TYPE:
    return fmt::format("expected {} expression", args...);
  case Error::UNEXPECTED_TYPE:
    return fmt::format("unexpected {} expression", args...);

  /// Typechecking
  case Error::UNION_TOO_BIG:
    return fmt::format(
        "union exceeded its maximum capacity (contains more than {} types)");
  case Error::DOT_NO_ATTR:
    return fmt::format("'{}' object has no attribute '{}'", args...);
  case Error::DOT_NO_ATTR_ARGS:
    return fmt::format("'{}' object has no method '{}' with arguments {}", args...);
  case Error::FN_NO_ATTR_ARGS:
    return fmt::format("no function '{}' with arguments {}", args...);
  case Error::EXPECTED_STATIC:
    return fmt::format("expected static expression");
  case Error::EXPECTED_STATIC_SPECIFIED:
    return fmt::format("expected static {} expression", args...);
  case Error::ASSIGN_UNEXPECTED_STATIC:
    return fmt::format("cannot modify static expressions");
  case Error::ASSIGN_UNEXPECTED_FROZEN:
    return fmt::format("cannot modify tuple attributes");
  case Error::CALL_BAD_UNPACK:
    return fmt::format("argument after * must be a tuple, not '{}'", args...);
  case Error::CALL_BAD_ITER:
    return fmt::format("iterable must be a tuple, not '{}'", args...);
  case Error::CALL_BAD_KWUNPACK:
    return fmt::format("argument after ** must be a named tuple, not '{}'", args...);
  case Error::CALL_REPEATED_NAME:
    return fmt::format("keyword argument repeated: {}", args...);
  case Error::CALL_RECURSIVE_DEFAULT:
    return fmt::format("argument '{}' has recursive default value", args...);
  case Error::CALL_SUPERF:
    return fmt::format("no superf methods found");
  case Error::CALL_SUPER_PARENT:
    return fmt::format("no super methods found");
  case Error::CALL_PTR_VAR:
    return fmt::format("__ptr__() only takes identifiers as arguments");
  case Error::EXPECTED_TUPLE:
    return fmt::format("expected tuple type");
  case Error::CALL_REALIZED_FN:
    return fmt::format("__realized__() only takes functions as a first argument");
  case Error::CALL_ARGS_MANY:
    return fmt::format("{}() takes {} arguments ({} given)", args...);
  case Error::CALL_ARGS_INVALID:
    return fmt::format("'{}' is an invalid keyword argument for {}()", args...);
  case Error::CALL_ARGS_MISSING:
    return fmt::format("{}() missing 1 required positional argument: '{}'", args...);
  case Error::GENERICS_MISMATCH:
    return fmt::format("{} takes {} generics ({} given)", args...);
  case Error::EXPECTED_GENERATOR:
    return fmt::format("expected iterable expression");
  case Error::STATIC_RANGE_BOUNDS:
    return fmt::format("staticrange too large (expected 0..{}, got instead {})",
                       args...);
  case Error::TUPLE_RANGE_BOUNDS:
    return fmt::format("tuple index out of range (expected 0..{}, got instead {})",
                       args...);
  case Error::STATIC_DIV_ZERO:
    return fmt::format("static division by zero");
  case Error::SLICE_STEP_ZERO:
    return fmt::format("slice step cannot be zero");
  case Error::OP_NO_MAGIC:
    return fmt::format("unsupported operand type(s) for {}: '{}' and '{}'", args...);
  case Error::INST_CALLABLE_STATIC:
    return fmt::format("Callable cannot take static types");

  case Error::TYPE_CANNOT_REALIZE_ATTR:
    return fmt::format("type of attribute '{}' of object '{}' cannot be inferred",
                       args...);
  case Error::TYPE_UNIFY:
    return fmt::format("'{}' does not match expected type '{}'", args...);
  case Error::TYPE_FAILED:
    return fmt::format(
        "cannot infer the complete type of an expression (inferred only '{}')",
        args...);

  case Error::COMPILER_NO_FILE:
    return fmt::format("cannot open file '{}' for parsing", args...);
  case Error::COMPILER_NO_STDLIB:
    return fmt::format("cannot locate standard library");
  case Error::MAX_REALIZATION:
    return fmt::format(
        "maximum realization depth reached during the realization of '{}'", args...);
  case Error::CUSTOM:
    return fmt::format("{}", args...);

  default:
    assert(false);
  }
}

/// Raise a parsing error.
void raise_error(const char *format);
/// Raise a parsing error at a source location p.
void raise_error(int e, const codon::SrcInfo &amp;info, const char *format);
void raise_error(int e, const codon::SrcInfo &amp;info, const std::string &amp;format);

</t>
<t tx="ekr.20230509083243.354">template &lt;class... TA&gt;
void E(Error e, const codon::SrcInfo &amp;o = codon::SrcInfo(), const TA &amp;...args) {
  auto msg = Emsg(e, args...);
  raise_error((int)e, o, msg);
}

</t>
<t tx="ekr.20230509083243.355">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "jit.h"

#include &lt;sstream&gt;

#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/doc/doc.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/translate/translate.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon {
namespace jit {
namespace {
typedef int MainFunc(int, char **);
typedef void InputFunc();
typedef void *PyWrapperFunc(void *);

const std::string JIT_FILENAME = "&lt;jit&gt;";
} // namespace

JIT::JIT(const std::string &amp;argv0, const std::string &amp;mode)
    : compiler(std::make_unique&lt;Compiler&gt;(argv0, Compiler::Mode::JIT)), engine(),
      pydata(std::make_unique&lt;PythonData&gt;()), mode(mode) {
  if (auto e = Engine::create()) {
    engine = std::move(e.get());
  } else {
    engine = {};
    seqassertn(false, "JIT engine creation error");
  }
  compiler-&gt;getLLVMVisitor()-&gt;setJIT(true);
}

llvm::Error JIT::init() {
  auto *cache = compiler-&gt;getCache();
  auto *module = compiler-&gt;getModule();
  auto *pm = compiler-&gt;getPassManager();
  auto *llvisitor = compiler-&gt;getLLVMVisitor();

  auto transformed =
      ast::SimplifyVisitor::apply(cache, std::make_shared&lt;ast::SuiteStmt&gt;(),
                                  JIT_FILENAME, {}, compiler-&gt;getEarlyDefines());

  auto typechecked = ast::TypecheckVisitor::apply(cache, std::move(transformed));
  ast::TranslateVisitor::apply(cache, std::move(typechecked));
  cache-&gt;isJit = true; // we still need main(), so set isJit after it has been set
  module-&gt;setSrcInfo({JIT_FILENAME, 0, 0, 0});

  pm-&gt;run(module);
  module-&gt;accept(*llvisitor);
  auto pair = llvisitor-&gt;takeModule(module);

  if (auto err = engine-&gt;addModule({std::move(pair.first), std::move(pair.second)}))
    return err;

  auto func = engine-&gt;lookup("main");
  if (auto err = func.takeError())
    return err;

  auto *main = (MainFunc *)func-&gt;getAddress();
  (*main)(0, nullptr);
  return llvm::Error::success();
}

llvm::Error JIT::compile(const ir::Func *input) {
  auto *module = compiler-&gt;getModule();
  auto *pm = compiler-&gt;getPassManager();
  auto *llvisitor = compiler-&gt;getLLVMVisitor();

  Timer t1("jit/ir");
  pm-&gt;run(module);
  t1.log();

  Timer t2("jit/llvm");
  auto pair = llvisitor-&gt;takeModule(module);
  t2.log();

  Timer t3("jit/engine");
  if (auto err = engine-&gt;addModule({std::move(pair.first), std::move(pair.second)}))
    return std::move(err);
  t3.log();

  return llvm::Error::success();
}

llvm::Expected&lt;ir::Func *&gt; JIT::compile(const std::string &amp;code,
@others
std::string getJITLibrary() { return ast::library_path(); }

} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.356">                                        const std::string &amp;file, int line) {
  auto *cache = compiler-&gt;getCache();
  ast::StmtPtr node = ast::parseCode(cache, file.empty() ? JIT_FILENAME : file, code,
                                     /*startLine=*/line);

  auto sctx = cache-&gt;imports[MAIN_IMPORT].ctx;
  auto preamble = std::make_shared&lt;std::vector&lt;ast::StmtPtr&gt;&gt;();

  ast::Cache bCache = *cache;
  ast::SimplifyContext bSimplify = *sctx;
  ast::SimplifyContext stdlibSimplify = *(cache-&gt;imports[STDLIB_IMPORT].ctx);
  ast::TypeContext bType = *(cache-&gt;typeCtx);
  ast::TranslateContext bTranslate = *(cache-&gt;codegenCtx);
  try {
    auto *e = node-&gt;getSuite() ? node-&gt;getSuite()-&gt;lastInBlock() : &amp;node;
    if (e)
      if (auto ex = const_cast&lt;ast::ExprStmt *&gt;((*e)-&gt;getExpr())) {
        *e = std::make_shared&lt;ast::ExprStmt&gt;(std::make_shared&lt;ast::CallExpr&gt;(
            std::make_shared&lt;ast::IdExpr&gt;("_jit_display"), ex-&gt;expr-&gt;clone(),
            std::make_shared&lt;ast::StringExpr&gt;(mode)));
      }
    auto s = ast::SimplifyVisitor(sctx, preamble).transform(node);
    if (!cache-&gt;errors.empty())
      throw exc::ParserException();
    auto simplified = std::make_shared&lt;ast::SuiteStmt&gt;();
    for (auto &amp;s : *preamble)
      simplified-&gt;stmts.push_back(s);
    simplified-&gt;stmts.push_back(s);
    // TODO: unroll on errors...

    auto *cache = compiler-&gt;getCache();
    auto typechecked = ast::TypecheckVisitor::apply(cache, simplified);

    // add newly realized functions
    std::vector&lt;ast::StmtPtr&gt; v;
    std::vector&lt;ir::Func **&gt; frs;
    v.push_back(typechecked);
    for (auto &amp;p : cache-&gt;pendingRealizations) {
      v.push_back(cache-&gt;functions[p.first].ast);
      frs.push_back(&amp;cache-&gt;functions[p.first].realizations[p.second]-&gt;ir);
    }
  @others
    for (auto &amp;f : cache-&gt;functions)
      for (auto &amp;r : f.second.realizations)
        if (!(in(bCache.functions, f.first) &amp;&amp;
              in(bCache.functions[f.first].realizations, r.first)) &amp;&amp;
            r.second-&gt;ir) {
          cache-&gt;module-&gt;remove(r.second-&gt;ir);
        }
    *cache = bCache;
    *(cache-&gt;imports[MAIN_IMPORT].ctx) = bSimplify;
    *(cache-&gt;imports[STDLIB_IMPORT].ctx) = stdlibSimplify;
    *(cache-&gt;typeCtx) = bType;
    *(cache-&gt;codegenCtx) = bTranslate;

    if (exc.messages.empty())
      return llvm::make_error&lt;error::ParserErrorInfo&gt;(messages);
    else
      return llvm::make_error&lt;error::ParserErrorInfo&gt;(exc);
  }
}

</t>
<t tx="ekr.20230509083243.357">  auto func =
      ast::TranslateVisitor::apply(cache, std::make_shared&lt;ast::SuiteStmt&gt;(v));
  cache-&gt;jitCell++;

  return func;
} catch (const exc::ParserException &amp;exc) {
  std::vector&lt;error::Message&gt; messages;
  if (exc.messages.empty()) {
    for (auto &amp;e : cache-&gt;errors) {
      for (unsigned i = 0; i &lt; e.messages.size(); i++) {
        if (!e.messages[i].empty())
          messages.emplace_back(e.messages[i], e.locations[i].file,
                                e.locations[i].line, e.locations[i].col,
                                e.locations[i].len, e.errorCode);
      }
    }
  }

</t>
<t tx="ekr.20230509083243.358">llvm::Expected&lt;void *&gt; JIT::address(const ir::Func *input) {
  if (auto err = compile(input))
    return std::move(err);

  const std::string name = ir::LLVMVisitor::getNameForFunction(input);
  auto func = engine-&gt;lookup(name);
  if (auto err = func.takeError())
    return std::move(err);

  return (void *)func-&gt;getAddress();
}

llvm::Expected&lt;std::string&gt; JIT::run(const ir::Func *input) {
  auto result = address(input);
  if (auto err = result.takeError())
    return std::move(err);

  auto *repl = (InputFunc *)result.get();
  try {
    (*repl)();
  } catch (const runtime::JITError &amp;e) {
    return handleJITError(e);
  }
  return runtime::getCapturedOutput();
}

llvm::Expected&lt;std::string&gt;
JIT::execute(const std::string &amp;code, const std::string &amp;file, int line, bool debug) {
  if (debug)
    fmt::print(stderr, "[codon::jit::execute] code:\n{}-----\n", code);
  auto result = compile(code, file, line);
  if (auto err = result.takeError())
    return std::move(err);
  if (auto err = compile(result.get()))
    return std::move(err);
  return run(result.get());
}

llvm::Error JIT::handleJITError(const runtime::JITError &amp;e) {
  std::vector&lt;std::string&gt; backtrace;
  for (auto pc : e.getBacktrace()) {
    auto line = engine-&gt;getDebugListener()-&gt;getPrettyBacktrace(pc);
    if (line &amp;&amp; !line-&gt;empty())
      backtrace.push_back(*line);
  }
  return llvm::make_error&lt;error::RuntimeErrorInfo&gt;(e.getOutput(), e.getType(), e.what(),
                                                   e.getFile(), e.getLine(), e.getCol(),
                                                   backtrace);
}

namespace {
std::string buildKey(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;types) {
  std::stringstream key;
  key &lt;&lt; name;
  for (const auto &amp;t : types) {
    key &lt;&lt; "|" &lt;&lt; t;
  }
  return key.str();
}

std::string buildPythonWrapper(const std::string &amp;name, const std::string &amp;wrapname,
</t>
<t tx="ekr.20230509083243.359">                               const std::vector&lt;std::string&gt; &amp;types,
  @others
</t>
<t tx="ekr.20230509083243.36">};

std::unique_ptr&lt;ElementHandler&gt; ElementHandler::get(Value *v, types::Type *ty) {
  if (auto h = SliceHandler::get(v, ty))
    return std::move(h);

  if (auto h = LiteralHandler::get(v, ty))
    return std::move(h);

  return DefaultHandler::get(v, ty);
}

struct InspectionResult {
  bool valid = true;
  std::vector&lt;Value *&gt; args;
};

</t>
<t tx="ekr.20230509083243.360">                             const std::string &amp;pyModule,
@others
</t>
<t tx="ekr.20230509083243.361">                             const std::vector&lt;std::string&gt; &amp;pyVars) {
std::stringstream wrap;
wrap &lt;&lt; "@export\n";
wrap &lt;&lt; "def " &lt;&lt; wrapname &lt;&lt; "(args: cobj) -&gt; cobj:\n";
for (unsigned i = 0; i &lt; types.size(); i++) {
  wrap &lt;&lt; "    "
       &lt;&lt; "a" &lt;&lt; i &lt;&lt; " = " &lt;&lt; types[i] &lt;&lt; ".__from_py__(PyTuple_GetItem(args, " &lt;&lt; i
       &lt;&lt; "))\n";
}
for (unsigned i = 0; i &lt; pyVars.size(); i++) {
  wrap &lt;&lt; "    "
       &lt;&lt; "py" &lt;&lt; i &lt;&lt; " = pyobj._get_module(\"" &lt;&lt; pyModule &lt;&lt; "\")._getattr(\""
       &lt;&lt; pyVars[i] &lt;&lt; "\")\n";
}
wrap &lt;&lt; "    return " &lt;&lt; name &lt;&lt; "(";
for (unsigned i = 0; i &lt; types.size(); i++) {
  if (i &gt; 0)
    wrap &lt;&lt; ", ";
  wrap &lt;&lt; "a" &lt;&lt; i;
}
for (unsigned i = 0; i &lt; pyVars.size(); i++) {
  wrap &lt;&lt; ", "
       &lt;&lt; "py" &lt;&lt; i;
}
wrap &lt;&lt; ").__to_py__()\n";

return wrap.str();
}
</t>
<t tx="ekr.20230509083243.362">} // namespace

JIT::PythonData::PythonData() : cobj(nullptr), cache() {}

ir::types::Type *JIT::PythonData::getCObjType(ir::Module *M) {
  if (cobj)
    return cobj;
  cobj = M-&gt;getPointerType(M-&gt;getByteType());
  return cobj;
}

JITResult JIT::executeSafe(const std::string &amp;code, const std::string &amp;file, int line,
</t>
<t tx="ekr.20230509083243.363">                           bool debug) {
  auto result = execute(code, file, line, debug);
  if (auto err = result.takeError()) {
    auto errorInfo = llvm::toString(std::move(err));
    return JITResult::error(errorInfo);
  }
  return JITResult::success(nullptr);
}

</t>
<t tx="ekr.20230509083243.364">JITResult JIT::executePython(const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.365">                             const std::vector&lt;std::string&gt; &amp;types,
  @others
</t>
<t tx="ekr.20230509083243.366">                           const std::string &amp;pyModule,
@others
</t>
<t tx="ekr.20230509083243.367">                           const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
@others
</t>
<t tx="ekr.20230509083243.368">                           bool debug) {
auto key = buildKey(name, types);
auto &amp;cache = pydata-&gt;cache;
auto it = cache.find(key);
PyWrapperFunc *wrap;

if (it != cache.end()) {
  auto *wrapper = it-&gt;second;
  const std::string name = ir::LLVMVisitor::getNameForFunction(wrapper);
  auto func = llvm::cantFail(engine-&gt;lookup(name));
  wrap = (PyWrapperFunc *)func.getAddress();
} else {
  static int idx = 0;
  auto wrapname = "__codon_wrapped__" + name + "_" + std::to_string(idx++);
  auto wrapper = buildPythonWrapper(name, wrapname, types, pyModule, pyVars);
  if (debug)
    fmt::print(stderr, "[codon::jit::executePython] wrapper:\n{}-----\n", wrapper);
  if (auto err = compile(wrapper).takeError()) {
    auto errorInfo = llvm::toString(std::move(err));
    return JITResult::error(errorInfo);
  }

  auto *M = compiler-&gt;getModule();
  auto *func = M-&gt;getOrRealizeFunc(wrapname, {pydata-&gt;getCObjType(M)});
  seqassertn(func, "could not access wrapper func '{}'", wrapname);
  cache.emplace(key, func);

  auto result = address(func);
  if (auto err = result.takeError()) {
    auto errorInfo = llvm::toString(std::move(err));
    return JITResult::error(errorInfo);
  }
  wrap = (PyWrapperFunc *)result.get();
}

try {
  auto *ans = (*wrap)(arg);
  return JITResult::success(ans);
} catch (const runtime::JITError &amp;e) {
  auto err = handleJITError(e);
  auto errorInfo = llvm::toString(std::move(err));
  return JITResult::error(errorInfo);
}
}

</t>
<t tx="ekr.20230509083243.369">JIT *jitInit(const std::string &amp;name) {
  auto jit = new JIT(name);
  llvm::cantFail(jit-&gt;init());
  return jit;
}

JITResult jitExecutePython(JIT *jit, const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.37">void inspect(Value *v, InspectionResult &amp;r) {
  // check if add first then go from there
  if (isList(v)) {
    if (auto *c = cast&lt;CallInstr&gt;(v)) {
      auto *func = util::getFunc(c-&gt;getCallee());
      if (func &amp;&amp; func-&gt;getUnmangledName() == Module::ADD_MAGIC_NAME &amp;&amp;
          c-&gt;numArgs() == 2 &amp;&amp; isList(c-&gt;front()) &amp;&amp; isList(c-&gt;back())) {
        inspect(c-&gt;front(), r);
        inspect(c-&gt;back(), r);
        return;
      }
    }
    r.args.push_back(v);
  } else {
    r.valid = false;
  }
}

</t>
<t tx="ekr.20230509083243.370">                           const std::vector&lt;std::string&gt; &amp;types,
                           const std::string &amp;pyModule,
                           const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
                           bool debug) {
  return jit-&gt;executePython(name, types, pyModule, pyVars, arg, debug);
}

</t>
<t tx="ekr.20230509083243.371">JITResult jitExecuteSafe(JIT *jit, const std::string &amp;code, const std::string &amp;file,
</t>
<t tx="ekr.20230509083243.372">                         int line, bool debug) {
  return jit-&gt;executeSafe(code, file, line, debug);
}

</t>
<t tx="ekr.20230509083243.373">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvisitor.h"
#include "codon/cir/transform/manager.h"
#include "codon/cir/var.h"
#include "codon/compiler/compiler.h"
#include "codon/compiler/engine.h"
#include "codon/compiler/error.h"
#include "codon/parser/cache.h"
#include "codon/runtime/lib.h"

#include "codon/compiler/jit_extern.h"

namespace codon {
namespace jit {

@others
} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.374">class JIT {
public:
  struct PythonData {
    ir::types::Type *cobj;
    std::unordered_map&lt;std::string, ir::Func *&gt; cache;

    PythonData();
    ir::types::Type *getCObjType(ir::Module *M);
  };

private:
  std::unique_ptr&lt;Compiler&gt; compiler;
  std::unique_ptr&lt;Engine&gt; engine;
  std::unique_ptr&lt;PythonData&gt; pydata;
  std::string mode;

public:
  explicit JIT(const std::string &amp;argv0, const std::string &amp;mode = "");

  Compiler *getCompiler() const { return compiler.get(); }
  Engine *getEngine() const { return engine.get(); }

  // General
  llvm::Error init();
  llvm::Error compile(const ir::Func *input);
  llvm::Expected&lt;ir::Func *&gt; compile(const std::string &amp;code,
                                     const std::string &amp;file = "", int line = 0);
  llvm::Expected&lt;void *&gt; address(const ir::Func *input);
  llvm::Expected&lt;std::string&gt; run(const ir::Func *input);
  llvm::Expected&lt;std::string&gt; execute(const std::string &amp;code,
                                      const std::string &amp;file = "", int line = 0,
                                      bool debug = false);

  // Python
  llvm::Expected&lt;void *&gt; runPythonWrapper(const ir::Func *wrapper, void *arg);
  llvm::Expected&lt;ir::Func *&gt; getWrapperFunc(const std::string &amp;name,
                                            const std::vector&lt;std::string&gt; &amp;types);
  JITResult executePython(const std::string &amp;name,
                          const std::vector&lt;std::string&gt; &amp;types,
                          const std::string &amp;pyModule,
                          const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
                          bool debug);
  JITResult executeSafe(const std::string &amp;code, const std::string &amp;file, int line,
                        bool debug);

  // Errors
  llvm::Error handleJITError(const runtime::JITError &amp;e);
};

</t>
<t tx="ekr.20230509083243.375">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {
namespace jit {

class JIT;

struct JITResult {
  void *result;
  std::string message;

  operator bool() const { return message.empty(); }
  static JITResult success(void *result) { return {result, ""}; }
  static JITResult error(const std::string &amp;message) { return {nullptr, message}; }
};

JIT *jitInit(const std::string &amp;name);

JITResult jitExecutePython(JIT *jit, const std::string &amp;name,
                           const std::vector&lt;std::string&gt; &amp;types,
                           const std::string &amp;pyModule,
                           const std::vector&lt;std::string&gt; &amp;pyVars, void *arg,
                           bool debug);

JITResult jitExecuteSafe(JIT *jit, const std::string &amp;code, const std::string &amp;file,
                         int line, bool debug);

std::string getJITLibrary();

} // namespace jit
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.376">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "memory_manager.h"

#include "codon/runtime/lib.h"

namespace codon {

BoehmGCMemoryManager::BoehmGCMemoryManager() : SectionMemoryManager(), roots() {}

uint8_t *BoehmGCMemoryManager::allocateDataSection(uintptr_t size, unsigned alignment,
@others
llvm::jitlink::JITLinkMemoryManager::FinalizedAlloc
BoehmGCJITLinkMemoryManager::createFinalizedAlloc(
    llvm::sys::MemoryBlock StandardSegments,
    std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt; DeallocActions) {
  std::lock_guard&lt;std::mutex&gt; Lock(FinalizedAllocsMutex);
  auto *FA = FinalizedAllocInfos.Allocate&lt;FinalizedAllocInfo&gt;();
  new (FA) FinalizedAllocInfo({std::move(StandardSegments), std::move(DeallocActions)});
  return FinalizedAlloc(llvm::orc::ExecutorAddr::fromPtr(FA));
}

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.377">                                                   unsigned sectionID,
                                                   llvm::StringRef sectionName,
  @others
</t>
<t tx="ekr.20230509083243.378">                                                 bool isReadOnly) {
auto *result = SectionMemoryManager::allocateDataSection(size, alignment, sectionID,
                                                         sectionName, isReadOnly);
void *start = result;
void *end = result + size;
seq_gc_add_roots(start, end);
roots.emplace_back(start, end);
return result;
}

</t>
<t tx="ekr.20230509083243.379">BoehmGCMemoryManager::~BoehmGCMemoryManager() {
  for (const auto &amp;root : roots) {
    seq_gc_remove_roots(root.first, root.second);
  }
}

</t>
<t tx="ekr.20230509083243.38">Value *optimize(BodiedFunc *parent, InspectionResult &amp;r) {
  if (!r.valid || r.args.size() &lt;= 1)
    return nullptr;

  auto *M = parent-&gt;getModule();
  auto *ty = r.args[0]-&gt;getType();
  util::CloneVisitor cv(M);
  std::vector&lt;std::unique_ptr&lt;ElementHandler&gt;&gt; handlers;

  for (auto *v : r.args) {
    handlers.push_back(ElementHandler::get(cv.clone(v), ty));
  }

  auto *opt = M-&gt;Nr&lt;SeriesFlow&gt;();
  auto *len = util::makeVar(M-&gt;getInt(0), opt, parent)-&gt;getVar();

  for (auto &amp;h : handlers) {
    h-&gt;setup(opt, parent);
  }

  for (auto &amp;h : handlers) {
    opt-&gt;push_back(M-&gt;Nr&lt;AssignInstr&gt;(len, *M-&gt;Nr&lt;VarValue&gt;(len) + *h-&gt;length(M)));
  }

  auto *fn = M-&gt;getOrRealizeMethod(ty, "_list_add_opt_opt_new", {M-&gt;getIntType()});
  seqassertn(fn, "could not find list new helper");
  auto *result =
      util::makeVar(util::call(fn, {M-&gt;Nr&lt;VarValue&gt;(len)}), opt, parent)-&gt;getVar();

  for (auto &amp;h : handlers) {
    opt-&gt;push_back(h-&gt;append(M-&gt;Nr&lt;VarValue&gt;(result)));
  }

  return M-&gt;Nr&lt;FlowInstr&gt;(opt, M-&gt;Nr&lt;VarValue&gt;(result));
}
} // namespace

const std::string ListAdditionOptimization::KEY = "core-pythonic-list-addition-opt";

</t>
<t tx="ekr.20230509083243.380">class BoehmGCJITLinkMemoryManager::IPInFlightAlloc
    : public llvm::jitlink::JITLinkMemoryManager::InFlightAlloc {
public:
  IPInFlightAlloc(BoehmGCJITLinkMemoryManager &amp;MemMgr, llvm::jitlink::LinkGraph &amp;G,
                  llvm::jitlink::BasicLayout BL,
                  llvm::sys::MemoryBlock StandardSegments,
                  llvm::sys::MemoryBlock FinalizationSegments)
      : MemMgr(MemMgr), G(G), BL(std::move(BL)),
        StandardSegments(std::move(StandardSegments)),
        FinalizationSegments(std::move(FinalizationSegments)) {}

@others
private:
  llvm::Error applyProtections() {
    for (auto &amp;KV : BL.segments()) {
      const auto &amp;AG = KV.first;
      auto &amp;Seg = KV.second;

      auto Prot = toSysMemoryProtectionFlags(AG.getMemProt());

      uint64_t SegSize =
          llvm::alignTo(Seg.ContentSize + Seg.ZeroFillSize, MemMgr.PageSize);
      llvm::sys::MemoryBlock MB(Seg.WorkingMem, SegSize);
      if (auto EC = llvm::sys::Memory::protectMappedMemory(MB, Prot))
        return llvm::errorCodeToError(EC);
      if (Prot &amp; llvm::sys::Memory::MF_EXEC)
        llvm::sys::Memory::InvalidateInstructionCache(MB.base(), MB.allocatedSize());
    }
    return llvm::Error::success();
  }

  BoehmGCJITLinkMemoryManager &amp;MemMgr;
  llvm::jitlink::LinkGraph &amp;G;
  llvm::jitlink::BasicLayout BL;
  llvm::sys::MemoryBlock StandardSegments;
  llvm::sys::MemoryBlock FinalizationSegments;
};

</t>
<t tx="ekr.20230509083243.381">  void finalize(OnFinalizedFunction OnFinalized) override {

    // Apply memory protections to all segments.
    if (auto Err = applyProtections()) {
      OnFinalized(std::move(Err));
      return;
    }

    // Run finalization actions.
    auto DeallocActions = runFinalizeActions(G.allocActions());
    if (!DeallocActions) {
      OnFinalized(DeallocActions.takeError());
      return;
    }

    // Release the finalize segments slab.
    if (auto EC = llvm::sys::Memory::releaseMappedMemory(FinalizationSegments)) {
      OnFinalized(llvm::errorCodeToError(EC));
      return;
    }

    // Continue with finalized allocation.
    OnFinalized(MemMgr.createFinalizedAlloc(std::move(StandardSegments),
                                            std::move(*DeallocActions)));
  }

</t>
<t tx="ekr.20230509083243.382">  void abandon(OnAbandonedFunction OnAbandoned) override {
    llvm::Error Err = llvm::Error::success();
    if (auto EC = llvm::sys::Memory::releaseMappedMemory(FinalizationSegments))
      Err = llvm::joinErrors(std::move(Err), llvm::errorCodeToError(EC));
    if (auto EC = llvm::sys::Memory::releaseMappedMemory(StandardSegments))
      Err = llvm::joinErrors(std::move(Err), llvm::errorCodeToError(EC));
    OnAbandoned(std::move(Err));
  }

</t>
<t tx="ekr.20230509083243.383">llvm::Expected&lt;std::unique_ptr&lt;BoehmGCJITLinkMemoryManager&gt;&gt;
BoehmGCJITLinkMemoryManager::Create() {
  if (auto PageSize = llvm::sys::Process::getPageSize())
    return std::make_unique&lt;BoehmGCJITLinkMemoryManager&gt;(*PageSize);
  else
    return PageSize.takeError();
}

</t>
<t tx="ekr.20230509083243.384">void BoehmGCJITLinkMemoryManager::allocate(const llvm::jitlink::JITLinkDylib *JD,
                                           llvm::jitlink::LinkGraph &amp;G,
                                           OnAllocatedFunction OnAllocated) {

  // FIXME: Just check this once on startup.
  if (!llvm::isPowerOf2_64((uint64_t)PageSize)) {
    OnAllocated(llvm::make_error&lt;llvm::StringError&gt;("Page size is not a power of 2",
                                                    llvm::inconvertibleErrorCode()));
    return;
  }

  llvm::jitlink::BasicLayout BL(G);

  /// Scan the request and calculate the group and total sizes.
  /// Check that segment size is no larger than a page.
  auto SegsSizes = BL.getContiguousPageBasedLayoutSizes(PageSize);
  if (!SegsSizes) {
    OnAllocated(SegsSizes.takeError());
    return;
  }

  /// Check that the total size requested (including zero fill) is not larger
  /// than a size_t.
  if (SegsSizes-&gt;total() &gt; std::numeric_limits&lt;size_t&gt;::max()) {
    OnAllocated(llvm::make_error&lt;llvm::jitlink::JITLinkError&gt;(
        "Total requested size " + llvm::formatv("{0:x}", SegsSizes-&gt;total()) +
        " for graph " + G.getName() + " exceeds address space"));
    return;
  }

  // Allocate one slab for the whole thing (to make sure everything is
  // in-range), then partition into standard and finalization blocks.
  //
  // FIXME: Make two separate allocations in the future to reduce
  // fragmentation: finalization segments will usually be a single page, and
  // standard segments are likely to be more than one page. Where multiple
  // allocations are in-flight at once (likely) the current approach will leave
  // a lot of single-page holes.
  llvm::sys::MemoryBlock Slab;
  llvm::sys::MemoryBlock StandardSegsMem;
  llvm::sys::MemoryBlock FinalizeSegsMem;
  {
  @others
  }

  if (auto Err = BL.apply()) {
    OnAllocated(std::move(Err));
    return;
  }

  OnAllocated(std::make_unique&lt;IPInFlightAlloc&gt;(
      *this, G, std::move(BL), std::move(StandardSegsMem), std::move(FinalizeSegsMem)));
}

</t>
<t tx="ekr.20230509083243.385">  const llvm::sys::Memory::ProtectionFlags ReadWrite =
    @others
</t>
<t tx="ekr.20230509083243.386">  static_cast&lt;llvm::sys::Memory::ProtectionFlags&gt;(llvm::sys::Memory::MF_READ |
                                                  llvm::sys::Memory::MF_WRITE);

    std::error_code EC;
    Slab = llvm::sys::Memory::allocateMappedMemory(SegsSizes-&gt;total(), nullptr,
                                             ReadWrite, EC);

    if (EC) {
OnAllocated(llvm::errorCodeToError(EC));
return;
    }

</t>
<t tx="ekr.20230509083243.387">  // Zero-fill the whole slab up-front.
  memset(Slab.base(), 0, Slab.allocatedSize());

  StandardSegsMem = {Slab.base(), static_cast&lt;size_t&gt;(SegsSizes-&gt;StandardSegs)};
  FinalizeSegsMem = {(void *)((char *)Slab.base() + SegsSizes-&gt;StandardSegs),
                     static_cast&lt;size_t&gt;(SegsSizes-&gt;FinalizeSegs)};
}

auto NextStandardSegAddr = llvm::orc::ExecutorAddr::fromPtr(StandardSegsMem.base());
auto NextFinalizeSegAddr = llvm::orc::ExecutorAddr::fromPtr(FinalizeSegsMem.base());

// Build ProtMap, assign addresses.
for (auto &amp;KV : BL.segments()) {
  auto &amp;AG = KV.first;
  auto &amp;Seg = KV.second;

  auto &amp;SegAddr =
      (AG.getMemDeallocPolicy() == llvm::jitlink::MemDeallocPolicy::Standard)
          ? NextStandardSegAddr
          : NextFinalizeSegAddr;

  Seg.WorkingMem = SegAddr.toPtr&lt;char *&gt;();
  Seg.Addr = SegAddr;

  SegAddr += llvm::alignTo(Seg.ContentSize + Seg.ZeroFillSize, PageSize);

  if (static_cast&lt;int&gt;(AG.getMemProt()) &amp;
</t>
<t tx="ekr.20230509083243.388">      static_cast&lt;int&gt;(llvm::jitlink::MemProt::Write)) {
    seq_gc_add_roots((void *)Seg.Addr.getValue(), (void *)SegAddr.getValue());
  }
</t>
<t tx="ekr.20230509083243.389">void BoehmGCJITLinkMemoryManager::deallocate(std::vector&lt;FinalizedAlloc&gt; Allocs,
                                             OnDeallocatedFunction OnDeallocated) {
  std::vector&lt;llvm::sys::MemoryBlock&gt; StandardSegmentsList;
  std::vector&lt;std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt;&gt; DeallocActionsList;

  {
    std::lock_guard&lt;std::mutex&gt; Lock(FinalizedAllocsMutex);
    for (auto &amp;Alloc : Allocs) {
      auto *FA = Alloc.release().toPtr&lt;FinalizedAllocInfo *&gt;();
      StandardSegmentsList.push_back(std::move(FA-&gt;StandardSegments));
      if (!FA-&gt;DeallocActions.empty())
        DeallocActionsList.push_back(std::move(FA-&gt;DeallocActions));
      FA-&gt;~FinalizedAllocInfo();
      FinalizedAllocInfos.Deallocate(FA);
    }
  }

  llvm::Error DeallocErr = llvm::Error::success();

  while (!DeallocActionsList.empty()) {
    auto &amp;DeallocActions = DeallocActionsList.back();
    auto &amp;StandardSegments = StandardSegmentsList.back();

    /// Run any deallocate calls.
    while (!DeallocActions.empty()) {
      if (auto Err = DeallocActions.back().runWithSPSRetErrorMerged())
        DeallocErr = llvm::joinErrors(std::move(DeallocErr), std::move(Err));
      DeallocActions.pop_back();
    }

    /// Release the standard segments slab.
    if (auto EC = llvm::sys::Memory::releaseMappedMemory(StandardSegments))
      DeallocErr = llvm::joinErrors(std::move(DeallocErr), llvm::errorCodeToError(EC));

    DeallocActionsList.pop_back();
    StandardSegmentsList.pop_back();
  }

  OnDeallocated(std::move(DeallocErr));
}

</t>
<t tx="ekr.20230509083243.39">void ListAdditionOptimization::handle(CallInstr *v) {
  auto *M = v-&gt;getModule();

  auto *f = util::getFunc(v-&gt;getCallee());
  if (!f || f-&gt;getUnmangledName() != Module::ADD_MAGIC_NAME)
    return;

  InspectionResult r;
  inspect(v, r);
  auto *parent = cast&lt;BodiedFunc&gt;(getParentFunc());
  if (auto *opt = optimize(parent, r))
    v-&gt;replaceAll(opt);
}

</t>
<t tx="ekr.20230509083243.390">@path C:/Repos/codon/codon/compiler/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;mutex&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/llvm/llvm.h"

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.391">/// Simple extension of LLVM's SectionMemoryManager which catches data section
/// allocations and registers them with the GC. This allows the GC to know not
/// to collect globals even in JIT mode.
class BoehmGCMemoryManager : public llvm::SectionMemoryManager {
private:
  /// Vector of (start, end) address pairs registered with GC.
  std::vector&lt;std::pair&lt;void *, void *&gt;&gt; roots;
  uint8_t *allocateDataSection(uintptr_t size, unsigned alignment, unsigned sectionID,
                               llvm::StringRef sectionName, bool isReadOnly) override;

public:
  BoehmGCMemoryManager();
  ~BoehmGCMemoryManager() override;
};

</t>
<t tx="ekr.20230509083243.392">/// Basically a copy of LLVM's jitlink::InProcessMemoryManager that registers
/// relevant allocated sections with the GC. TODO: Avoid copying this entire
/// class if/when there's an API to perform the registration externally.
class BoehmGCJITLinkMemoryManager : public llvm::jitlink::JITLinkMemoryManager {
public:
  class IPInFlightAlloc;

  /// Attempts to auto-detect the host page size.
  static llvm::Expected&lt;std::unique_ptr&lt;BoehmGCJITLinkMemoryManager&gt;&gt; Create();

  /// Create an instance using the given page size.
  BoehmGCJITLinkMemoryManager(uint64_t PageSize) : PageSize(PageSize) {}

  void allocate(const llvm::jitlink::JITLinkDylib *JD, llvm::jitlink::LinkGraph &amp;G,
                OnAllocatedFunction OnAllocated) override;

  // Use overloads from base class.
  using llvm::jitlink::JITLinkMemoryManager::allocate;

@others
  FinalizedAlloc createFinalizedAlloc(
      llvm::sys::MemoryBlock StandardSegments,
      std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt; DeallocActions);

  uint64_t PageSize;
  std::mutex FinalizedAllocsMutex;
  llvm::RecyclingAllocator&lt;llvm::BumpPtrAllocator, FinalizedAllocInfo&gt;
      FinalizedAllocInfos;
};

</t>
<t tx="ekr.20230509083243.393">  void deallocate(std::vector&lt;FinalizedAlloc&gt; Alloc,
                  OnDeallocatedFunction OnDeallocated) override;

  // Use overloads from base class.
  using llvm::jitlink::JITLinkMemoryManager::deallocate;

private:
  // FIXME: Use an in-place array instead of a vector for DeallocActions.
  //        There shouldn't need to be a heap alloc for this.
  struct FinalizedAllocInfo {
    llvm::sys::MemoryBlock StandardSegments;
    std::vector&lt;llvm::orc::shared::WrapperFunctionCall&gt; DeallocActions;
  };

</t>
<t tx="ekr.20230509083243.395"></t>
<t tx="ekr.20230509083243.396">@path C:/Repos/codon/codon/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/cir.h"
#include "codon/cir/transform/manager.h"
#include "codon/cir/transform/pass.h"
#include "codon/parser/cache.h"
#include "llvm/Passes/PassBuilder.h"
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace codon {

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.397">/// Base class for DSL plugins. Plugins will return an instance of
/// a child of this class, which defines various characteristics of
/// the DSL, like keywords and IR passes.
class DSL {
public:
  /// General information about this plugin.
  struct Info {
    /// Extension name
    std::string name;
    /// Extension description
    std::string description;
    /// Extension version
    std::string version;
    /// Extension URL
    std::string url;
    /// Supported Codon versions (semver range)
    std::string supported;
    /// Plugin stdlib path
    std::string stdlibPath;
    /// Plugin dynamic library path
    std::string dylibPath;
    /// Linker arguments (to replace "-l dylibPath" if present)
    std::vector&lt;std::string&gt; linkArgs;
  };

  using KeywordCallback =
      std::function&lt;ast::StmtPtr(ast::SimplifyVisitor *, ast::CustomStmt *)&gt;;

  struct ExprKeyword {
    std::string keyword;
    KeywordCallback callback;
  };

  struct BlockKeyword {
    std::string keyword;
    KeywordCallback callback;
    bool hasExpr;
  };

  virtual ~DSL() noexcept = default;

  /// Registers this DSL's IR passes with the given pass manager.
  /// @param pm the pass manager to add the passes to
  /// @param debug true if compiling in debug mode
  virtual void addIRPasses(ir::transform::PassManager *pm, bool debug) {}

  /// Registers this DSL's LLVM passes with the given pass builder.
  /// @param pb the pass builder to add the passes to
  /// @param debug true if compiling in debug mode
  virtual void addLLVMPasses(llvm::PassBuilder *pb, bool debug) {}

  /// Returns a vector of "expression keywords", defined as keywords of
  /// the form "keyword &lt;expr&gt;".
  /// @return this DSL's expression keywords
  virtual std::vector&lt;ExprKeyword&gt; getExprKeywords() { return {}; }

  /// Returns a vector of "block keywords", defined as keywords of the
  /// form "keyword &lt;expr&gt;: &lt;block of code&gt;".
  /// @return this DSL's block keywords
  virtual std::vector&lt;BlockKeyword&gt; getBlockKeywords() { return {}; }
};

</t>
<t tx="ekr.20230509083243.398">@path C:/Repos/codon/codon/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "plugins.h"

#include &lt;cstdlib&gt;
#include &lt;semver.hpp&gt;
#include &lt;toml++/toml.h&gt;

#include "codon/parser/common.h"
#include "codon/util/common.h"
#include "llvm/ADT/SmallString.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"

namespace codon {
namespace {
llvm::Expected&lt;Plugin *&gt; pluginError(const std::string &amp;msg) {
  return llvm::make_error&lt;error::PluginErrorInfo&gt;(msg);
}

typedef std::unique_ptr&lt;DSL&gt; LoadFunc();
} // namespace

llvm::Expected&lt;Plugin *&gt; PluginManager::load(const std::string &amp;path) {
#if __APPLE__
  const std::string libExt = "dylib";
#else
  const std::string libExt = "so";
#endif

  const std::string config = "plugin.toml";

  llvm::SmallString&lt;128&gt; tomlPath(path);
  llvm::sys::path::append(tomlPath, config);
  if (!llvm::sys::fs::exists(tomlPath)) {
    // try default install path
    tomlPath = llvm::SmallString&lt;128&gt;(
        llvm::sys::path::parent_path(ast::executable_path(argv0.c_str())));
    llvm::sys::path::append(tomlPath, "../lib/codon/plugins", path, config);
  }

  toml::parse_result tml;
  try {
    tml = toml::parse_file(tomlPath.str());
  } catch (const toml::parse_error &amp;e) {
    return pluginError(
        fmt::format("[toml::parse_file(\"{}\")] {}", tomlPath.str(), e.what()));
  }
  auto about = tml["about"];
  auto library = tml["library"];

  std::string cppLib = library["cpp"].value_or("");
  std::string dylibPath;
  if (!cppLib.empty()) {
    llvm::SmallString&lt;128&gt; p = llvm::sys::path::parent_path(tomlPath);
    llvm::sys::path::append(p, cppLib + "." + libExt);
    dylibPath = p.str();
  }

  auto link = library["link"];
  std::vector&lt;std::string&gt; linkArgs;
  if (auto arr = link.as_array()) {
    arr-&gt;for_each([&amp;linkArgs](auto &amp;&amp;el) {
      std::string l = el.value_or("");
      if (!l.empty())
        linkArgs.push_back(l);
    });
  } else {
    std::string l = link.value_or("");
    if (!l.empty())
      linkArgs.push_back(l);
  }
  for (auto &amp;l : linkArgs)
    l = fmt::format(l, fmt::arg("root", llvm::sys::path::parent_path(tomlPath)));

  std::string codonLib = library["codon"].value_or("");
  std::string stdlibPath;
  if (!codonLib.empty()) {
    llvm::SmallString&lt;128&gt; p = llvm::sys::path::parent_path(tomlPath);
    llvm::sys::path::append(p, codonLib);
    stdlibPath = p.str();
  }

  DSL::Info info = {about["name"].value_or(""),
                    about["description"].value_or(""),
                    about["version"].value_or(""),
                    about["url"].value_or(""),
                    about["supported"].value_or(""),
                    stdlibPath,
                    dylibPath,
                    linkArgs};

  bool versionOk = false;
  try {
    versionOk = semver::range::satisfies(
        semver::version(CODON_VERSION_MAJOR, CODON_VERSION_MINOR, CODON_VERSION_PATCH),
        info.supported);
  } catch (const std::invalid_argument &amp;e) {
    return pluginError(fmt::format("[semver::range::satisfies(..., \"{}\")] {}",
                                   info.supported, e.what()));
  }
  if (!versionOk)
    return pluginError(fmt::format("unsupported version {} (supported: {})",
                                   CODON_VERSION, info.supported));

  if (!dylibPath.empty()) {
    std::string libLoadErrorMsg;
    auto handle = llvm::sys::DynamicLibrary::getPermanentLibrary(dylibPath.c_str(),
                                                                 &amp;libLoadErrorMsg);
    if (!handle.isValid())
      return pluginError(fmt::format(
          "[llvm::sys::DynamicLibrary::getPermanentLibrary(\"{}\", ...)] {}", dylibPath,
          libLoadErrorMsg));

    auto *entry = (LoadFunc *)handle.getAddressOfSymbol("load");
    if (!entry)
      return pluginError(
          fmt::format("could not find 'load' in plugin shared library: {}", dylibPath));

    auto dsl = (*entry)();
    plugins.push_back(std::make_unique&lt;Plugin&gt;(std::move(dsl), info, handle));
  } else {
    plugins.push_back(std::make_unique&lt;Plugin&gt;(std::make_unique&lt;DSL&gt;(), info,
                                               llvm::sys::DynamicLibrary()));
  }
  return plugins.back().get();
}

} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.399">@path C:/Repos/codon/codon/dsl/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;functional&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/util/iterators.h"
#include "codon/compiler/error.h"
#include "codon/dsl/dsl.h"
#include "llvm/Support/DynamicLibrary.h"

namespace codon {

/// Plugin metadata
struct Plugin {
  /// the associated DSL
  std::unique_ptr&lt;DSL&gt; dsl;
  /// plugin information
  DSL::Info info;
  /// library handle
  llvm::sys::DynamicLibrary handle;

  Plugin(std::unique_ptr&lt;DSL&gt; dsl, DSL::Info info, llvm::sys::DynamicLibrary handle)
      : dsl(std::move(dsl)), info(std::move(info)), handle(std::move(handle)) {}
};

@others
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.4">// Replaces yields with updates to the accumulator variable.
struct GeneratorSumTransformer : public util::Operator {
  Var *accumulator;
  bool valid;

  explicit GeneratorSumTransformer(Var *accumulator)
      : util::Operator(), accumulator(accumulator), valid(true) {}

</t>
<t tx="ekr.20230509083243.40">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.400">/// Manager for loading, applying and unloading plugins.
class PluginManager {
private:
  /// Codon executable location
  std::string argv0;
  /// vector of loaded plugins
  std::vector&lt;std::unique_ptr&lt;Plugin&gt;&gt; plugins;

public:
  /// Constructs a plugin manager
  PluginManager(const std::string &amp;argv0) : argv0(argv0), plugins() {}

  /// @return iterator to the first plugin
  auto begin() { return ir::util::raw_ptr_adaptor(plugins.begin()); }
  /// @return iterator beyond the last plugin
  auto end() { return ir::util::raw_ptr_adaptor(plugins.end()); }
  /// @return const iterator to the first plugin
  auto begin() const { return ir::util::const_raw_ptr_adaptor(plugins.begin()); }
  /// @return const iterator beyond the last plugin
  auto end() const { return ir::util::const_raw_ptr_adaptor(plugins.end()); }

  /// Loads the plugin at the given load path.
  /// @param path path to plugin directory containing "plugin.toml" file
  /// @return plugin pointer if successful, plugin error otherwise
  llvm::Expected&lt;Plugin *&gt; load(const std::string &amp;path);
};

</t>
<t tx="ekr.20230509083243.401"></t>
<t tx="ekr.20230509083243.402">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/parser/ast/error.h"
#include "codon/parser/ast/expr.h"
#include "codon/parser/ast/stmt.h"
#include "codon/parser/ast/types.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.403">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "cache.h"

#include &lt;chrono&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/pyextension.h"
#include "codon/cir/util/irtools.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/translate/translate.h"
#include "codon/parser/visitors/typecheck/ctx.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast {

Cache::Cache(std::string argv0)
    : generatedSrcInfoCount(0), unboundCount(256), varCount(0), age(0),
      argv0(std::move(argv0)), typeCtx(nullptr), codegenCtx(nullptr), isJit(false),
      jitCell(0), pythonExt(false), pyModule(nullptr) {}

std::string Cache::getTemporaryVar(const std::string &amp;prefix, char sigil) {
  return fmt::format("{}{}_{}", sigil ? fmt::format("{}_", sigil) : "", prefix,
                     ++varCount);
}

std::string Cache::rev(const std::string &amp;s) {
  auto i = reverseIdentifierLookup.find(s);
  if (i != reverseIdentifierLookup.end())
    return i-&gt;second;
  seqassertn(false, "'{}' has no non-canonical name", s);
  return "";
}

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.404">void Cache::addGlobal(const std::string &amp;name, ir::Var *var) {
  if (!in(globals, name)) {
    // LOG("[global] {}", name);
    globals[name] = var;
  }
}

</t>
<t tx="ekr.20230509083243.405">SrcInfo Cache::generateSrcInfo() {
  return {FILE_GENERATED, generatedSrcInfoCount, generatedSrcInfoCount++, 0};
}

std::string Cache::getContent(const SrcInfo &amp;info) {
  auto i = imports.find(info.file);
  if (i == imports.end())
    return "";
  int line = info.line - 1;
  if (line &lt; 0 || line &gt;= i-&gt;second.content.size())
    return "";
  auto s = i-&gt;second.content[line];
  int col = info.col - 1;
  if (col &lt; 0 || col &gt;= s.size())
    return "";
  int len = info.len;
  return s.substr(col, len);
}

types::ClassTypePtr Cache::findClass(const std::string &amp;name) const {
  auto f = typeCtx-&gt;find(name);
  if (f &amp;&amp; f-&gt;kind == TypecheckItem::Type)
    return f-&gt;type-&gt;getClass();
  return nullptr;
}

types::FuncTypePtr Cache::findFunction(const std::string &amp;name) const {
  auto f = typeCtx-&gt;find(name);
  if (f &amp;&amp; f-&gt;type &amp;&amp; f-&gt;kind == TypecheckItem::Func)
    return f-&gt;type-&gt;getFunc();
  f = typeCtx-&gt;find(name + ":0");
  if (f &amp;&amp; f-&gt;type &amp;&amp; f-&gt;kind == TypecheckItem::Func)
    return f-&gt;type-&gt;getFunc();
  return nullptr;
}

types::FuncTypePtr Cache::findMethod(types::ClassType *typ, const std::string &amp;member,
</t>
<t tx="ekr.20230509083243.406">                                     const std::vector&lt;types::TypePtr&gt; &amp;args) {
  auto e = std::make_shared&lt;IdExpr&gt;(typ-&gt;name);
  e-&gt;type = typ-&gt;getClass();
  seqassertn(e-&gt;type, "not a class");
  int oldAge = typeCtx-&gt;age;
  typeCtx-&gt;age = 99999;
  auto f = TypecheckVisitor(typeCtx).findBestMethod(e-&gt;type-&gt;getClass(), member, args);
  typeCtx-&gt;age = oldAge;
  return f;
}

</t>
<t tx="ekr.20230509083243.407">ir::types::Type *Cache::realizeType(types::ClassTypePtr type,
</t>
<t tx="ekr.20230509083243.408">                                    const std::vector&lt;types::TypePtr&gt; &amp;generics) {
  auto e = std::make_shared&lt;IdExpr&gt;(type-&gt;name);
  e-&gt;type = type;
  type = typeCtx-&gt;instantiateGeneric(type, generics)-&gt;getClass();
  auto tv = TypecheckVisitor(typeCtx);
  if (auto rtv = tv.realize(type)) {
    return classes[rtv-&gt;getClass()-&gt;name]
        .realizations[rtv-&gt;getClass()-&gt;realizedTypeName()]
        -&gt;ir;
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.409">ir::Func *Cache::realizeFunction(types::FuncTypePtr type,
</t>
<t tx="ekr.20230509083243.41">/// Pass to optimize list1 + list2 + ...
/// Also handles list slices and list literals efficiently.
class ListAdditionOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083243.410">                                 const std::vector&lt;types::TypePtr&gt; &amp;args,
  @others
</t>
<t tx="ekr.20230509083243.411">                               const std::vector&lt;types::TypePtr&gt; &amp;generics,
@others
</t>
<t tx="ekr.20230509083243.412">                               const types::ClassTypePtr &amp;parentClass) {
auto e = std::make_shared&lt;IdExpr&gt;(type-&gt;ast-&gt;name);
e-&gt;type = type;
type = typeCtx-&gt;instantiate(type, parentClass)-&gt;getFunc();
if (args.size() != type-&gt;getArgTypes().size() + 1)
  return nullptr;
types::Type::Unification undo;
if (type-&gt;getRetType()-&gt;unify(args[0].get(), &amp;undo) &lt; 0) {
  undo.undo();
  return nullptr;
}
for (int gi = 1; gi &lt; args.size(); gi++) {
  undo = types::Type::Unification();
  if (type-&gt;getArgTypes()[gi - 1]-&gt;unify(args[gi].get(), &amp;undo) &lt; 0) {
    undo.undo();
    return nullptr;
  }
}
if (!generics.empty()) {
  if (generics.size() != type-&gt;funcGenerics.size())
    return nullptr;
  for (int gi = 0; gi &lt; generics.size(); gi++) {
    undo = types::Type::Unification();
    if (type-&gt;funcGenerics[gi].type-&gt;unify(generics[gi].get(), &amp;undo) &lt; 0) {
      undo.undo();
      return nullptr;
    }
  }
}
int oldAge = typeCtx-&gt;age;
typeCtx-&gt;age = 99999;
auto tv = TypecheckVisitor(typeCtx);
ir::Func *f = nullptr;
if (auto rtv = tv.realize(type)) {
  auto pr = pendingRealizations; // copy it as it might be modified
  for (auto &amp;fn : pr)
    TranslateVisitor(codegenCtx).transform(functions[fn.first].ast-&gt;clone());
  f = functions[rtv-&gt;getFunc()-&gt;ast-&gt;name].realizations[rtv-&gt;realizedName()]-&gt;ir;
}
typeCtx-&gt;age = oldAge;
return f;
}

</t>
<t tx="ekr.20230509083243.413">ir::types::Type *Cache::makeTuple(const std::vector&lt;types::TypePtr&gt; &amp;types) {
  auto tv = TypecheckVisitor(typeCtx);
  auto name = tv.generateTuple(types.size());
  auto t = typeCtx-&gt;find(name);
  seqassertn(t &amp;&amp; t-&gt;type, "cannot find {}", name);
  return realizeType(t-&gt;type-&gt;getClass(), types);
}

ir::types::Type *Cache::makeFunction(const std::vector&lt;types::TypePtr&gt; &amp;types) {
  auto tv = TypecheckVisitor(typeCtx);
  seqassertn(!types.empty(), "types must have at least one argument");

  auto tup = tv.generateTuple(types.size() - 1);
  const auto &amp;ret = types[0];
</t>
<t tx="ekr.20230509083243.414">  auto argType = typeCtx-&gt;instantiateGeneric(
      typeCtx-&gt;find(tup)-&gt;type,
      std::vector&lt;types::TypePtr&gt;(types.begin() + 1, types.end()));
  auto t = typeCtx-&gt;find("Function");
  seqassertn(t &amp;&amp; t-&gt;type, "cannot find 'Function'");
  return realizeType(t-&gt;type-&gt;getClass(), {argType, ret});
}

ir::types::Type *Cache::makeUnion(const std::vector&lt;types::TypePtr&gt; &amp;types) {
  auto tv = TypecheckVisitor(typeCtx);

  auto tup = tv.generateTuple(types.size());
  auto argType = typeCtx-&gt;instantiateGeneric(typeCtx-&gt;find(tup)-&gt;type, types);
  auto t = typeCtx-&gt;find("Union");
  seqassertn(t &amp;&amp; t-&gt;type, "cannot find 'Union'");
  return realizeType(t-&gt;type-&gt;getClass(), {argType});
}

</t>
<t tx="ekr.20230509083243.415">void Cache::parseCode(const std::string &amp;code) {
  auto node = ast::parseCode(this, "&lt;internal&gt;", code, /*startLine=*/0);
  auto sctx = imports[MAIN_IMPORT].ctx;
  node = ast::SimplifyVisitor::apply(sctx, node, "&lt;internal&gt;", 99999);
  node = ast::TypecheckVisitor::apply(this, node);
  ast::TranslateVisitor(codegenCtx).transform(node);
}

</t>
<t tx="ekr.20230509083243.416">std::vector&lt;ExprPtr&gt; Cache::mergeC3(std::vector&lt;std::vector&lt;ExprPtr&gt;&gt; &amp;seqs) {
  // Reference: https://www.python.org/download/releases/2.3/mro/
  std::vector&lt;ExprPtr&gt; result;
  for (size_t i = 0;; i++) {
    bool found = false;
    ExprPtr cand = nullptr;
    for (auto &amp;seq : seqs) {
      if (seq.empty())
        continue;
      found = true;
      bool nothead = false;
      for (auto &amp;s : seqs)
        if (!s.empty()) {
          bool in = false;
          for (size_t j = 1; j &lt; s.size(); j++) {
            if ((in |= (seq[0]-&gt;getTypeName() == s[j]-&gt;getTypeName())))
              break;
          }
          if (in) {
            nothead = true;
            break;
          }
        }
      if (!nothead) {
        cand = seq[0];
        break;
      }
    }
    if (!found)
      return result;
    if (!cand)
      return {};
    result.push_back(clone(cand));
    for (auto &amp;s : seqs)
      if (!s.empty() &amp;&amp; cand-&gt;getTypeName() == s[0]-&gt;getTypeName()) {
        s.erase(s.begin());
      }
  }
  return result;
}

/**
 * Generate Python bindings for Cython-like access.
 *
 * TODO: this function is total mess. Needs refactoring.
 */
</t>
<t tx="ekr.20230509083243.417">void Cache::populatePythonModule() {
  if (!pythonExt)
    return;

  LOG_USER("[py] ====== module generation =======");

#define N std::make_shared

  if (!pyModule)
    pyModule = std::make_shared&lt;ir::PyModule&gt;();
  using namespace ast;

  int oldAge = typeCtx-&gt;age;
  typeCtx-&gt;age = 99999;

  @others
      if (auto ir = realizeIR(functions[fnName].type, generics)) {
        LOG_USER("[py] {}: {}", "toplevel", fn);
        pyModule-&gt;functions.push_back(ir::PyFunction{rev(fn), f.ast-&gt;getDocstr(), ir,
                                                     ir::PyFunction::Type::TOPLEVEL,
                                                     int(f.ast-&gt;args.size())});
        pyModule-&gt;functions.back().keywords = true;
      }
    }
  }

  // Handle pending realizations!
  auto pr = pendingRealizations; // copy it as it might be modified
  for (auto &amp;fn : pr)
    TranslateVisitor(codegenCtx).transform(functions[fn.first].ast-&gt;clone());
  typeCtx-&gt;age = oldAge;
}

</t>
<t tx="ekr.20230509083243.418">auto realizeIR = [&amp;](const types::FuncTypePtr &amp;fn,
  @others
</t>
<t tx="ekr.20230509083243.419">                   const std::vector&lt;types::TypePtr&gt; &amp;generics = {}) -&gt; ir::Func * {
auto fnType = typeCtx-&gt;instantiate(fn);
types::Type::Unification u;
for (size_t i = 0; i &lt; generics.size(); i++)
  fnType-&gt;getFunc()-&gt;funcGenerics[i].type-&gt;unify(generics[i].get(), &amp;u);
fnType = TypecheckVisitor(typeCtx).realize(fnType);
if (!fnType)
  return nullptr;

auto pr = pendingRealizations; // copy it as it might be modified
for (auto &amp;fn : pr)
  TranslateVisitor(codegenCtx).transform(functions[fn.first].ast-&gt;clone());
return functions[fn-&gt;ast-&gt;name].realizations[fnType-&gt;realizedName()]-&gt;ir;
  };

</t>
<t tx="ekr.20230509083243.42">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "str.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/cloning.h"
#include "codon/cir/util/irtools.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {
namespace {
struct InspectionResult {
  bool valid = true;
  std::vector&lt;Value *&gt; args;
};

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.420">const std::string pyWrap = "std.internal.python._PyWrap";
auto clss = classes; // needs copy as below fns can mutate this
for (const auto &amp;[cn, c] : clss) {
  if (c.module.empty()) {
    if (!in(c.methods, "__to_py__") || !in(c.methods, "__from_py__"))
      continue;

    LOG_USER("[py] Cythonizing {}", cn);
    ir::PyType py{rev(cn), c.ast-&gt;getDocstr()};

    auto tc = typeCtx-&gt;forceFind(cn)-&gt;type;
    if (!tc-&gt;canRealize())
      compilationError(fmt::format("cannot realize '{}' for Python export", rev(cn)));
    tc = TypecheckVisitor(typeCtx).realize(tc);
    seqassertn(tc, "cannot realize '{}'", cn);

    // 1. Replace to_py / from_py with _PyWrap.wrap_to_py/from_py
    if (auto ofnn = in(c.methods, "__to_py__")) {
      auto fnn = overloads[*ofnn].begin()-&gt;name; // default first overload!
      auto &amp;fna = functions[fnn].ast;
      fna-&gt;getFunction()-&gt;suite = N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;IdExpr&gt;(pyWrap + ".wrap_to_py:0"), N&lt;IdExpr&gt;(fna-&gt;args[0].name)));
    }
    if (auto ofnn = in(c.methods, "__from_py__")) {
      auto fnn = overloads[*ofnn].begin()-&gt;name; // default first overload!
      auto &amp;fna = functions[fnn].ast;
      fna-&gt;getFunction()-&gt;suite =
          N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(pyWrap + ".wrap_from_py:0"),
                                    N&lt;IdExpr&gt;(fna-&gt;args[0].name), N&lt;IdExpr&gt;(cn)));
    }
    for (auto &amp;n : std::vector&lt;std::string&gt;{"__from_py__", "__to_py__"}) {
      auto fnn = overloads[*in(c.methods, n)].begin()-&gt;name;
      ir::Func *oldIR = nullptr;
      if (!functions[fnn].realizations.empty())
        oldIR = functions[fnn].realizations.begin()-&gt;second-&gt;ir;
      functions[fnn].realizations.clear();
      auto tf = TypecheckVisitor(typeCtx).realize(functions[fnn].type);
      seqassertn(tf, "cannot re-realize '{}'", fnn);
      if (oldIR) {
        std::vector&lt;ir::Value *&gt; args;
        for (auto it = oldIR-&gt;arg_begin(); it != oldIR-&gt;arg_end(); ++it) {
          args.push_back(module-&gt;Nr&lt;ir::VarValue&gt;(*it));
        }
        ir::cast&lt;ir::BodiedFunc&gt;(oldIR)-&gt;setBody(ir::util::series(
            ir::util::call(functions[fnn].realizations.begin()-&gt;second-&gt;ir, args)));
      }
    }
    for (auto &amp;[rn, r] : functions[pyWrap + ".py_type:0"].realizations) {
      if (r-&gt;type-&gt;funcGenerics[0].type-&gt;unify(tc.get(), nullptr) &gt;= 0) {
        py.typePtrHook = r-&gt;ir;
        break;
      }
    }

    // 2. Handle methods
    auto methods = c.methods;
    for (const auto &amp;[n, ofnn] : methods) {
      auto canonicalName = overloads[ofnn].back().name;
      if (overloads[ofnn].size() == 1 &amp;&amp;
          functions[canonicalName].ast-&gt;hasAttr("autogenerated"))
        continue;
      auto fna = functions[canonicalName].ast;
      bool isMethod = fna-&gt;hasAttr(Attr::Method);
      bool isProperty = fna-&gt;hasAttr(Attr::Property);

      std::string call = pyWrap + ".wrap_multiple";
      bool isMagic = false;
      if (startswith(n, "__") &amp;&amp; endswith(n, "__")) {
        auto m = n.substr(2, n.size() - 4);
        if (m == "new" &amp;&amp; c.ast-&gt;hasAttr(Attr::Tuple))
          m = "init";
        if (auto i = in(classes[pyWrap].methods, "wrap_magic_" + m)) {
          call = *i;
          isMagic = true;
        }
      }
      if (isProperty)
        call = pyWrap + ".wrap_get";

      auto fnName = call + ":0";
      seqassertn(in(functions, fnName), "bad name");
      auto generics = std::vector&lt;types::TypePtr&gt;{tc};
      if (isProperty) {
        generics.push_back(
            std::make_shared&lt;types::StaticType&gt;(this, rev(canonicalName)));
      } else if (!isMagic) {
        generics.push_back(std::make_shared&lt;types::StaticType&gt;(this, n));
        generics.push_back(std::make_shared&lt;types::StaticType&gt;(this, (int)isMethod));
      }
      auto f = realizeIR(functions[fnName].type, generics);
      if (!f)
        continue;

      LOG_USER("[py] {} -&gt; {} ({}; {})", n, call, isMethod, isProperty);
      if (isProperty) {
        py.getset.push_back({rev(canonicalName), "", f, nullptr});
      } else if (n == "__repr__") {
        py.repr = f;
      } else if (n == "__add__") {
        py.add = f;
      } else if (n == "__iadd__") {
        py.iadd = f;
      } else if (n == "__sub__") {
        py.sub = f;
      } else if (n == "__isub__") {
        py.isub = f;
      } else if (n == "__mul__") {
        py.mul = f;
      } else if (n == "__imul__") {
        py.imul = f;
      } else if (n == "__mod__") {
        py.mod = f;
      } else if (n == "__imod__") {
        py.imod = f;
      } else if (n == "__divmod__") {
        py.divmod = f;
      } else if (n == "__pow__") {
        py.pow = f;
      } else if (n == "__ipow__") {
        py.ipow = f;
      } else if (n == "__neg__") {
        py.neg = f;
      } else if (n == "__pos__") {
        py.pos = f;
      } else if (n == "__abs__") {
        py.abs = f;
      } else if (n == "__bool__") {
        py.bool_ = f;
      } else if (n == "__invert__") {
        py.invert = f;
      } else if (n == "__lshift__") {
        py.lshift = f;
      } else if (n == "__ilshift__") {
        py.ilshift = f;
      } else if (n == "__rshift__") {
        py.rshift = f;
      } else if (n == "__irshift__") {
        py.irshift = f;
      } else if (n == "__and__") {
        py.and_ = f;
      } else if (n == "__iand__") {
        py.iand = f;
      } else if (n == "__xor__") {
        py.xor_ = f;
      } else if (n == "__ixor__") {
        py.ixor = f;
      } else if (n == "__or__") {
        py.or_ = f;
      } else if (n == "__ior__") {
        py.ior = f;
      } else if (n == "__int__") {
        py.int_ = f;
      } else if (n == "__float__") {
        py.float_ = f;
      } else if (n == "__floordiv__") {
        py.floordiv = f;
      } else if (n == "__ifloordiv__") {
        py.ifloordiv = f;
      } else if (n == "__truediv__") {
        py.truediv = f;
      } else if (n == "__itruediv__") {
        py.itruediv = f;
      } else if (n == "__index__") {
        py.index = f;
      } else if (n == "__matmul__") {
        py.matmul = f;
      } else if (n == "__imatmul__") {
        py.imatmul = f;
      } else if (n == "__len__") {
        py.len = f;
      } else if (n == "__getitem__") {
        py.getitem = f;
      } else if (n == "__setitem__") {
        py.setitem = f;
      } else if (n == "__contains__") {
        py.contains = f;
      } else if (n == "__hash__") {
        py.hash = f;
      } else if (n == "__call__") {
        py.call = f;
      } else if (n == "__str__") {
        py.str = f;
      } else if (n == "__iter__") {
        py.iter = f;
      } else if (n == "__del__") {
        py.del = f;
      } else if (n == "__init__" || (c.ast-&gt;hasAttr(Attr::Tuple) &amp;&amp; n == "__new__")) {
        py.init = f;
      } else {
        py.methods.push_back(ir::PyFunction{
            n, fna-&gt;getDocstr(), f,
            fna-&gt;hasAttr(Attr::Method) ? ir::PyFunction::Type::METHOD
                                       : ir::PyFunction::Type::CLASS,
            // always use FASTCALL for now; works even for 0- or 1- arg methods
            2});
        py.methods.back().keywords = true;
      }
    }

    for (auto &amp;m : py.methods) {
      if (in(std::set&lt;std::string&gt;{"__lt__", "__le__", "__eq__", "__ne__", "__gt__",
                                   "__ge__"},
             m.name)) {
        py.cmp = realizeIR(
            typeCtx-&gt;forceFind(pyWrap + ".wrap_cmp:0")-&gt;type-&gt;getFunc(), {tc});
        break;
      }
    }

    if (c.realizations.size() != 1)
      compilationError(fmt::format("cannot pythonize generic class '{}'", cn));
    auto &amp;r = c.realizations.begin()-&gt;second;
    py.type = realizeType(r-&gt;type);
    for (auto &amp;[mn, mt] : r-&gt;fields) {
</t>
<t tx="ekr.20230509083243.421">      /// TODO: handle PyMember for tuples
      // Generate getters &amp; setters
      auto generics = std::vector&lt;types::TypePtr&gt;{
          tc, std::make_shared&lt;types::StaticType&gt;(this, mn)};
      auto gf = realizeIR(functions[pyWrap + ".wrap_get:0"].type, generics);
</t>
<t tx="ekr.20230509083243.422">      ir::Func *sf = nullptr;
      if (!c.ast-&gt;hasAttr(Attr::Tuple))
        sf = realizeIR(functions[pyWrap + ".wrap_set:0"].type, generics);
      py.getset.push_back({mn, "", gf, sf});
      LOG_USER("[py] {}: {} . {}", "member", cn, mn);
    }
    pyModule-&gt;types.push_back(py);
  }
}

// Handle __iternext__ wrappers
auto cin = "_PyWrap.IterWrap";
for (auto &amp;[cn, cr] : classes[cin].realizations) {
  LOG_USER("[py] iterfn: {}", cn);
  ir::PyType py{cn, ""};
  auto tc = cr-&gt;type;
  for (auto &amp;[rn, r] : functions[pyWrap + ".py_type:0"].realizations) {
    if (r-&gt;type-&gt;funcGenerics[0].type-&gt;unify(tc.get(), nullptr) &gt;= 0) {
      py.typePtrHook = r-&gt;ir;
      break;
    }
  }

  auto &amp;methods = classes[cin].methods;
  for (auto &amp;n : std::vector&lt;std::string&gt;{"_iter", "_iternext"}) {
    auto fnn = overloads[methods[n]].begin()-&gt;name;
    auto &amp;fna = functions[fnn];
    auto ft = typeCtx-&gt;instantiate(fna.type, tc-&gt;getClass());
    auto rtv = TypecheckVisitor(typeCtx).realize(ft);
    auto f =
        functions[rtv-&gt;getFunc()-&gt;ast-&gt;name].realizations[rtv-&gt;realizedName()]-&gt;ir;
    if (n == "_iter")
      py.iter = f;
    else
      py.iternext = f;
  }
  py.type = cr-&gt;ir;
  pyModule-&gt;types.push_back(py);
}
#undef N

auto fns = functions; // needs copy as below fns can mutate this
for (const auto &amp;[fn, f] : fns) {
  if (f.isToplevel) {
    std::string call = pyWrap + ".wrap_multiple";
    auto fnName = call + ":0";
    seqassertn(in(functions, fnName), "bad name");
</t>
<t tx="ekr.20230509083243.423">    auto generics = std::vector&lt;types::TypePtr&gt;{
        typeCtx-&gt;forceFind(".toplevel")-&gt;type,
        std::make_shared&lt;types::StaticType&gt;(this, rev(f.ast-&gt;name)),
        std::make_shared&lt;types::StaticType&gt;(this, 0)};
</t>
<t tx="ekr.20230509083243.424">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;map&gt;
#include &lt;ostream&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/cir/pyextension.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

#define FILE_GENERATED "&lt;generated&gt;"
#define MODULE_MAIN "__main__"
#define MAIN_IMPORT ""
#define STDLIB_IMPORT ":stdlib:"
#define STDLIB_INTERNAL_MODULE "internal"

#define TYPE_TUPLE "Tuple.N"
#define TYPE_KWTUPLE "KwTuple.N"
#define TYPE_TYPEVAR "TypeVar"
#define TYPE_CALLABLE "Callable"
#define TYPE_PARTIAL "Partial.N"
#define TYPE_OPTIONAL "Optional"
#define TYPE_SLICE "std.internal.types.slice.Slice"
#define FN_UNWRAP "std.internal.types.optional.unwrap"
#define VAR_ARGV "__argv__"
#define VAR_VTABLE ".__vtable__"

#define MAX_INT_WIDTH 10000
#define MAX_REALIZATION_DEPTH 200
#define MAX_STATIC_ITER 1024

namespace codon::ast {

/// Forward declarations
struct SimplifyContext;
class SimplifyVisitor;
struct TypeContext;
struct TranslateContext;

/**
 * Cache encapsulation that holds data structures shared across various transformation
 * stages (AST transformation, type checking etc.). The subsequent stages (e.g. type
 * checking) assumes that previous stages populated this structure correctly.
 * Implemented to avoid bunch of global objects.
 */
struct Cache : public std::enable_shared_from_this&lt;Cache&gt; {
  /// Stores a count for each identifier (name) seen in the code.
  /// Used to generate unique identifier for each name in the code (e.g. Foo -&gt; Foo.2).
  std::unordered_map&lt;std::string, int&gt; identifierCount;
  /// Maps a unique identifier back to the original name in the code
  /// (e.g. Foo.2 -&gt; Foo).
  std::unordered_map&lt;std::string, std::string&gt; reverseIdentifierLookup;
  /// Number of code-generated source code positions. Used to generate the next unique
  /// source-code position information.
  int generatedSrcInfoCount;
  /// Number of unbound variables so far. Used to generate the next unique unbound
  /// identifier.
  int unboundCount;
  /// Number of auto-generated variables so far. Used to generate the next unique
  /// variable name in getTemporaryVar() below.
  int varCount;
  /// Stores the count of imported files. Used to track class method ages
  /// and to prevent using extended methods before they were seen.
  int age;

  /// Holds module import data.
  struct Import {
    /// Absolute filename of an import.
    std::string filename;
    /// Import simplify context.
    std::shared_ptr&lt;SimplifyContext&gt; ctx;
    /// Unique import variable for checking already loaded imports.
    std::string importVar;
    /// File content (line:col indexable)
    std::vector&lt;std::string&gt; content;
    /// Relative module name (e.g., `foo.bar`)
    std::string moduleName;
  };

  /// Absolute path of seqc executable (if available).
  std::string argv0;
  /// Absolute path of the entry-point module (if available).
  std::string module0;
  /// IR module.
  ir::Module *module = nullptr;

  /// Table of imported files that maps an absolute filename to a Import structure.
  /// By convention, the key of the Codon's standard library is "".
  std::unordered_map&lt;std::string, Import&gt; imports;

  /// Set of unique (canonical) global identifiers for marking such variables as global
  /// in code-generation step and in JIT.
  std::map&lt;std::string, ir::Var *&gt; globals;

  /// Stores class data for each class (type) in the source code.
  struct Class {
    /// Generic (unrealized) class template AST.
    std::shared_ptr&lt;ClassStmt&gt; ast;
    /// Non-simplified AST. Used for base class instantiation.
    std::shared_ptr&lt;ClassStmt&gt; originalAst;

    /// Class method lookup table. Each non-canonical name points
    /// to a root function name of a corresponding method.
    std::unordered_map&lt;std::string, std::string&gt; methods;

    /// A class field (member).
    struct ClassField {
      /// Field name.
      std::string name;
      /// A corresponding generic field type.
      types::TypePtr type;
    };
    /// A list of class' ClassField instances. List is needed (instead of map) because
    /// the order of the fields matters.
    std::vector&lt;ClassField&gt; fields;

    /// Dictionary of class variables: a name maps to a canonical name.
    std::unordered_map&lt;std::string, std::string&gt; classVars;

    /// A class realization.
    struct ClassRealization {
      /// Realized class type.
      types::ClassTypePtr type;
      /// A list of field names and realization's realized field types.
      std::vector&lt;std::pair&lt;std::string, types::TypePtr&gt;&gt; fields;
      /// IR type pointer.
      codon::ir::types::Type *ir = nullptr;

      /// Realization vtable.
      struct VTable {
        // Maps {base, thunk signature} to {thunk realization, thunk ID}
        std::map&lt;std::pair&lt;std::string, std::string&gt;,
                 std::pair&lt;types::FuncTypePtr, size_t&gt;&gt;
            table;
        codon::ir::Var *ir = nullptr;
      };
      /// All vtables (for each base class)
      std::unordered_map&lt;std::string, VTable&gt; vtables;
      /// Realization ID
      size_t id = 0;
    };
    /// Realization lookup table that maps a realized class name to the corresponding
    /// ClassRealization instance.
    std::unordered_map&lt;std::string, std::shared_ptr&lt;ClassRealization&gt;&gt; realizations;

    /// List of virtual method names
    std::unordered_set&lt;std::string&gt; virtuals;
    /// MRO
    std::vector&lt;ExprPtr&gt; mro;

    /// List of statically inherited classes.
    std::vector&lt;std::string&gt; staticParentClasses;

    /// Module information
    std::string module;

    Class() : ast(nullptr), originalAst(nullptr) {}
  };
  /// Class lookup table that maps a canonical class identifier to the corresponding
  /// Class instance.
  std::unordered_map&lt;std::string, Class&gt; classes;
  size_t classRealizationCnt = 0;

  struct Function {
    /// Generic (unrealized) function template AST.
    std::shared_ptr&lt;FunctionStmt&gt; ast;
    /// Non-simplified AST.
    std::shared_ptr&lt;FunctionStmt&gt; origAst;

    /// A function realization.
    struct FunctionRealization {
      /// Realized function type.
      types::FuncTypePtr type;
      /// Realized function AST (stored here for later realization in code generations
      /// stage).
      std::shared_ptr&lt;FunctionStmt&gt; ast;
      /// IR function pointer.
      ir::Func *ir;
    };
    /// Realization lookup table that maps a realized function name to the corresponding
    /// FunctionRealization instance.
    std::unordered_map&lt;std::string, std::shared_ptr&lt;FunctionRealization&gt;&gt; realizations;

    /// Unrealized function type.
    types::FuncTypePtr type;

    /// Module information
    std::string rootName = "";
    bool isToplevel = false;

    Function()
        : ast(nullptr), origAst(nullptr), type(nullptr), rootName(""),
          isToplevel(false) {}
  };
  /// Function lookup table that maps a canonical function identifier to the
  /// corresponding Function instance.
  std::unordered_map&lt;std::string, Function&gt; functions;

  struct Overload {
    /// Canonical name of an overload (e.g. Foo.__init__.1).
    std::string name;
    /// Overload age (how many class extension were seen before a method definition).
    /// Used to prevent the usage of an overload before it was defined in the code.
    /// TODO: I have no recollection of how this was supposed to work. Most likely
    /// it does not work at all...
    int age;
  };
  /// Maps a "root" name of each function to the list of names of the function
  /// overloads.
  std::unordered_map&lt;std::string, std::vector&lt;Overload&gt;&gt; overloads;

  /// Pointer to the later contexts needed for IR API access.
  std::shared_ptr&lt;TypeContext&gt; typeCtx;
  std::shared_ptr&lt;TranslateContext&gt; codegenCtx;
  /// Set of function realizations that are to be translated to IR.
  std::set&lt;std::pair&lt;std::string, std::string&gt;&gt; pendingRealizations;
  /// Mapping of partial record names to function pointers and corresponding masks.
  std::unordered_map&lt;std::string, std::pair&lt;types::FuncTypePtr, std::vector&lt;char&gt;&gt;&gt;
      partials;

  /// Custom operators
  std::unordered_map&lt;std::string,
                     std::pair&lt;bool, std::function&lt;StmtPtr(ast::SimplifyVisitor *,
                                                           ast::CustomStmt *)&gt;&gt;&gt;
      customBlockStmts;
  std::unordered_map&lt;std::string,
                     std::function&lt;StmtPtr(ast::SimplifyVisitor *, ast::CustomStmt *)&gt;&gt;
      customExprStmts;

  /// Plugin-added import paths
  std::vector&lt;std::string&gt; pluginImportPaths;

  /// Set if the Codon is running in JIT mode.
  bool isJit;
  int jitCell;

  std::unordered_map&lt;std::string, std::pair&lt;std::string, bool&gt;&gt; replacements;
  std::unordered_map&lt;std::string, int&gt; generatedTuples;
  std::vector&lt;exc::ParserException&gt; errors;

  /// Set if Codon operates in Python compatibility mode (e.g., with Python numerics)
  bool pythonCompat = false;
  /// Set if Codon operates in Python extension mode
  bool pythonExt = false;

public:
  explicit Cache(std::string argv0 = "");

  /// Return a uniquely named temporary variable of a format
  /// "{sigil}_{prefix}{counter}". A sigil should be a non-lexable symbol.
  std::string getTemporaryVar(const std::string &amp;prefix = "", char sigil = '.');
  /// Get the non-canonical version of a canonical name.
  std::string rev(const std::string &amp;s);

  /// Generate a unique SrcInfo for internally generated AST nodes.
  SrcInfo generateSrcInfo();
  /// Get file contents at the given location.
  std::string getContent(const SrcInfo &amp;info);
  /// Register a global identifier.
  void addGlobal(const std::string &amp;name, ir::Var *var = nullptr);

  /// Realization API.

  /// Find a class with a given canonical name and return a matching types::Type pointer
  /// or a nullptr if a class is not found.
  /// Returns an _uninstantiated_ type.
  types::ClassTypePtr findClass(const std::string &amp;name) const;
  /// Find a function with a given canonical name and return a matching types::Type
  /// pointer or a nullptr if a function is not found.
  /// Returns an _uninstantiated_ type.
  types::FuncTypePtr findFunction(const std::string &amp;name) const;
  /// Find the canonical name of a class method.
  std::string getMethod(const types::ClassTypePtr &amp;typ, const std::string &amp;member) {
    if (auto m = in(classes, typ-&gt;name)) {
      if (auto t = in(m-&gt;methods, member))
        return *t;
    }
    seqassertn(false, "cannot find '{}' in '{}'", member, typ-&gt;toString());
    return "";
  }
  /// Find the class method in a given class type that best matches the given arguments.
  /// Returns an _uninstantiated_ type.
  types::FuncTypePtr findMethod(types::ClassType *typ, const std::string &amp;member,
                                const std::vector&lt;types::TypePtr&gt; &amp;args);

  /// Given a class type and the matching generic vector, instantiate the type and
  /// realize it.
  ir::types::Type *realizeType(types::ClassTypePtr type,
                               const std::vector&lt;types::TypePtr&gt; &amp;generics = {});
  /// Given a function type and function arguments, instantiate the type and
  /// realize it. The first argument is the function return type.
  /// You can also pass function generics if a function has one (e.g. T in def
  /// foo[T](...)). If a generic is used as an argument, it will be auto-deduced. Pass
  /// only if a generic cannot be deduced from the provided args.
  ir::Func *realizeFunction(types::FuncTypePtr type,
                            const std::vector&lt;types::TypePtr&gt; &amp;args,
                            const std::vector&lt;types::TypePtr&gt; &amp;generics = {},
                            const types::ClassTypePtr &amp;parentClass = nullptr);

  ir::types::Type *makeTuple(const std::vector&lt;types::TypePtr&gt; &amp;types);
  ir::types::Type *makeFunction(const std::vector&lt;types::TypePtr&gt; &amp;types);
  ir::types::Type *makeUnion(const std::vector&lt;types::TypePtr&gt; &amp;types);

  void parseCode(const std::string &amp;code);

  static std::vector&lt;ExprPtr&gt; mergeC3(std::vector&lt;std::vector&lt;ExprPtr&gt;&gt; &amp;);

  std::shared_ptr&lt;ir::PyModule&gt; pyModule = nullptr;
  void populatePythonModule();
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.425">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "common.h"

#include &lt;cinttypes&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"
#include &lt;fmt/format.h&gt;

namespace codon::ast {

/// String and collection utilities

std::vector&lt;std::string&gt; split(const std::string &amp;s, char delim) {
  std::vector&lt;std::string&gt; items;
  std::string item;
  std::istringstream iss(s);
  while (std::getline(iss, item, delim))
    items.push_back(item);
  return items;
}
// clang-format off
std::string escape(const std::string &amp;str) {
  std::string r;
  r.reserve(str.size());
  for (unsigned char c : str) {
    switch (c) {
    case '\a': r += "\\a"; break;
    case '\b': r += "\\b"; break;
    case '\f': r += "\\f"; break;
    case '\n': r += "\\n"; break;
    case '\r': r += "\\r"; break;
    case '\t': r += "\\t"; break;
    case '\v': r += "\\v"; break;
    case '\'': r += "\\'"; break;
    case '\\': r += "\\\\"; break;
    default:
      if (c &lt; 32 || c &gt;= 127)
        r += fmt::format("\\x{:x}", c);
      else
        r += c;
    }
  }
  return r;
}
std::string unescape(const std::string &amp;str) {
  std::string r;
  r.reserve(str.size());
  for (int i = 0; i &lt; str.size(); i++) {
    if (str[i] == '\\' &amp;&amp; i + 1 &lt; str.size())
      switch(str[i + 1]) {
      case 'a': r += '\a'; i++; break;
      case 'b': r += '\b'; i++; break;
      case 'f': r += '\f'; i++; break;
      case 'n': r += '\n'; i++; break;
      case 'r': r += '\r'; i++; break;
      case 't': r += '\t'; i++; break;
      case 'v': r += '\v'; i++; break;
      case '"': r += '\"'; i++; break;
      case '\'': r += '\''; i++; break;
      case '\\': r += '\\'; i++; break;
      case 'x': {
        if (i + 3 &gt; str.size())
          throw std::invalid_argument("invalid \\x code");
        size_t pos = 0;
        auto code = std::stoi(str.substr(i + 2, 2), &amp;pos, 16);
        r += char(code);
        i += pos + 1;
        break;
      }
      default:
        if (str[i + 1] &gt;= '0' &amp;&amp; str[i + 1] &lt;= '7') {
          size_t pos = 0;
          auto code = std::stoi(str.substr(i + 1, 3), &amp;pos, 8);
          r += char(code);
          i += pos;
        } else {
          r += str[i];
        }
      }
    else
      r += str[i];
  }
  return r;
}
// clang-format on
std::string escapeFStringBraces(const std::string &amp;str, int start, int len) {
  std::string t;
  t.reserve(len);
  for (int i = start; i &lt; start + len; i++)
    if (str[i] == '{')
      t += "{{";
    else if (str[i] == '}')
      t += "}}";
    else
      t += str[i];
  return t;
}
int findStar(const std::string &amp;s) {
  int i = 0;
  for (; i &lt; s.size(); i++)
    if (s[i] == ' ' || s[i] == ')')
      break;
  return i;
}
size_t startswith(const std::string &amp;str, const std::string &amp;prefix) {
  return (str.size() &gt;= prefix.size() &amp;&amp; str.substr(0, prefix.size()) == prefix)
             ? prefix.size()
             : 0;
}
size_t endswith(const std::string &amp;str, const std::string &amp;suffix) {
  return (str.size() &gt;= suffix.size() &amp;&amp;
          str.substr(str.size() - suffix.size()) == suffix)
             ? suffix.size()
             : 0;
}
void ltrim(std::string &amp;str) {
  str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](unsigned char ch) {
              return !std::isspace(ch);
            }));
}
void rtrim(std::string &amp;str) {
  /// https://stackoverflow.com/questions/216823/whats-the-best-way-to-trim-stdstring
  str.erase(std::find_if(str.rbegin(), str.rend(),
                         [](unsigned char ch) { return !std::isspace(ch); })
                .base(),
            str.end());
}
int trimStars(std::string &amp;str) {
  int stars = 0;
  for (; stars &lt; str.size() &amp;&amp; str[stars] == '*'; stars++)
    ;
  str = str.substr(stars);
  return stars;
}
bool isdigit(const std::string &amp;str) {
  return std::all_of(str.begin(), str.end(), ::isdigit);
}

/// Path utilities

std::string executable_path(const char *argv0) {
  void *p = (void *)(intptr_t)executable_path;
  return llvm::sys::fs::getMainExecutable(argv0, p);
}

// Adapted from https://github.com/gpakosz/whereami/blob/master/src/whereami.c (MIT)
#ifdef __APPLE__
#include &lt;dlfcn.h&gt;
#include &lt;mach-o/dyld.h&gt;
#endif
std::string library_path() {
  std::string result;
#ifdef __APPLE__
  char buffer[PATH_MAX];
  for (;;) {
    Dl_info info;
    if (dladdr(__builtin_extract_return_addr(__builtin_return_address(0)), &amp;info)) {
      char *resolved = realpath(info.dli_fname, buffer);
      if (!resolved)
        break;
      result = std::string(resolved);
    }
    break;
  }
#else
  for (int r = 0; r &lt; 5; r++) {
    FILE *maps = fopen("/proc/self/maps", "r");
    if (!maps)
      break;

    for (;;) {
      char buffer[PATH_MAX &lt; 1024 ? 1024 : PATH_MAX];
      uint64_t low, high;
      char perms[5];
      uint64_t offset;
      uint32_t major, minor;
      char path[PATH_MAX];
      uint32_t inode;

      if (!fgets(buffer, sizeof(buffer), maps))
        break;

      if (sscanf(buffer, "%" PRIx64 "-%" PRIx64 " %s %" PRIx64 " %x:%x %u %s\n", &amp;low,
                 &amp;high, perms, &amp;offset, &amp;major, &amp;minor, &amp;inode, path) == 8) {
        uint64_t addr =
            (uintptr_t)(__builtin_extract_return_addr(__builtin_return_address(0)));
        if (low &lt;= addr &amp;&amp; addr &lt;= high) {
          char *resolved = realpath(path, buffer);
          if (resolved)
            result = std::string(resolved);
          break;
        }
      }
    }
    fclose(maps);
    if (!result.empty())
      break;
  }
#endif

  return result;
}

namespace {

bool addPath(std::vector&lt;std::string&gt; &amp;paths, const std::string &amp;path) {
  if (llvm::sys::fs::exists(path)) {
    paths.push_back(getAbsolutePath(path));
    return true;
  }
  return false;
}

std::vector&lt;std::string&gt; getStdLibPaths(const std::string &amp;argv0,
                                        const std::vector&lt;std::string&gt; &amp;plugins) {
  std::vector&lt;std::string&gt; paths;
  if (auto c = getenv("CODON_PATH")) {
    addPath(paths, c);
  }
  if (!argv0.empty()) {
    auto base = executable_path(argv0.c_str());
    for (auto loci : {"../lib/codon/stdlib", "../stdlib", "stdlib"}) {
      auto path = llvm::SmallString&lt;128&gt;(llvm::sys::path::parent_path(base));
      llvm::sys::path::append(path, loci);
      addPath(paths, std::string(path));
    }
  }
  for (auto &amp;path : plugins) {
    addPath(paths, path);
  }
  return paths;
}

ImportFile getRoot(const std::string argv0, const std::vector&lt;std::string&gt; &amp;plugins,
                   const std::string &amp;module0Root, const std::string &amp;s) {
  bool isStdLib = false;
  std::string root;
  for (auto &amp;p : getStdLibPaths(argv0, plugins))
    if (startswith(s, p)) {
      root = p;
      isStdLib = true;
      break;
    }
  if (!isStdLib &amp;&amp; startswith(s, module0Root))
    root = module0Root;
  std::string ext = ".codon";
  if (!((root.empty() || startswith(s, root)) &amp;&amp; endswith(s, ext)))
    ext = ".py";
  seqassertn((root.empty() || startswith(s, root)) &amp;&amp; endswith(s, ext),
             "bad path substitution: {}, {}", s, root);
  auto module = s.substr(root.size() + 1, s.size() - root.size() - ext.size() - 1);
  std::replace(module.begin(), module.end(), '/', '.');
  return ImportFile{(!isStdLib &amp;&amp; root == module0Root) ? ImportFile::PACKAGE
                                                       : ImportFile::STDLIB,
                    s, module};
}
} // namespace

std::string getAbsolutePath(const std::string &amp;path) {
  char *c = realpath(path.c_str(), nullptr);
  if (!c)
    return path;
  std::string result(c);
  free(c);
  return result;
}

std::shared_ptr&lt;ImportFile&gt; getImportFile(const std::string &amp;argv0,
                                          const std::string &amp;what,
                                          const std::string &amp;relativeTo,
                                          bool forceStdlib, const std::string &amp;module0,
                                          const std::vector&lt;std::string&gt; &amp;plugins) {
  std::vector&lt;std::string&gt; paths;
  if (what != "&lt;jit&gt;") {
    auto parentRelativeTo = llvm::sys::path::parent_path(relativeTo);
    if (!forceStdlib) {
      auto path = llvm::SmallString&lt;128&gt;(parentRelativeTo);
      llvm::sys::path::append(path, what);
      llvm::sys::path::replace_extension(path, "codon");
      addPath(paths, std::string(path));
      path = llvm::SmallString&lt;128&gt;(parentRelativeTo);
      llvm::sys::path::append(path, what, "__init__.codon");
      addPath(paths, std::string(path));

      path = llvm::SmallString&lt;128&gt;(parentRelativeTo);
      llvm::sys::path::append(path, what);
      llvm::sys::path::replace_extension(path, "py");
      addPath(paths, std::string(path));
      path = llvm::SmallString&lt;128&gt;(parentRelativeTo);
      llvm::sys::path::append(path, what, "__init__.py");
      addPath(paths, std::string(path));
    }
  }
  for (auto &amp;p : getStdLibPaths(argv0, plugins)) {
    auto path = llvm::SmallString&lt;128&gt;(p);
    llvm::sys::path::append(path, what);
    llvm::sys::path::replace_extension(path, "codon");
    addPath(paths, std::string(path));
    path = llvm::SmallString&lt;128&gt;(p);
    llvm::sys::path::append(path, what, "__init__.codon");
    addPath(paths, std::string(path));
  }

  auto module0Root = llvm::sys::path::parent_path(getAbsolutePath(module0)).str();
  return paths.empty() ? nullptr
                       : std::make_shared&lt;ImportFile&gt;(
                             getRoot(argv0, plugins, module0Root, paths[0]));
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.426">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/util/common.h"

#define CAST(s, T) dynamic_cast&lt;T *&gt;(s.get())

namespace codon {

namespace ast {

/// String and collection utilities

/// Split a delimiter-separated string into a vector of strings.
std::vector&lt;std::string&gt; split(const std::string &amp;str, char delim);
/// Escape a C string (replace \n with \\n etc.).
std::string escape(const std::string &amp;str);
/// Unescape a C string (replace \\n with \n etc.).
std::string unescape(const std::string &amp;str);
/// Escape an F-string braces (replace { and } with {{ and }}).
std::string escapeFStringBraces(const std::string &amp;str, int start, int len);
int findStar(const std::string &amp;s);
/// True if a string str starts with a prefix.
size_t startswith(const std::string &amp;str, const std::string &amp;prefix);
/// True if a string str ends with a suffix.
size_t endswith(const std::string &amp;str, const std::string &amp;suffix);
/// Trims whitespace at the beginning of the string.
void ltrim(std::string &amp;str);
/// Trims whitespace at the end of the string.
void rtrim(std::string &amp;str);
/// Removes leading stars in front of the string and returns the number of such stars.
int trimStars(std::string &amp;str);
/// True if a string only contains digits.
bool isdigit(const std::string &amp;str);
@others
/// @return vector c transformed by the function f.
template &lt;typename T, typename F&gt; auto vmap(const std::vector&lt;T&gt; &amp;c, F &amp;&amp;f) {
  std::vector&lt;typename std::result_of&lt;F(const T &amp;)&gt;::type&gt; ret;
  std::transform(std::begin(c), std::end(c), std::inserter(ret, std::end(ret)), f);
  return ret;
}

/// AST utilities

/// Clones a pointer even if it is a nullptr.
template &lt;typename T&gt; auto clone(const std::shared_ptr&lt;T&gt; &amp;t) {
  return t ? t-&gt;clone() : nullptr;
}

/// Clones a vector of cloneable pointer objects.
template &lt;typename T&gt; std::vector&lt;T&gt; clone(const std::vector&lt;T&gt; &amp;t) {
  std::vector&lt;T&gt; v;
  for (auto &amp;i : t)
    v.push_back(clone(i));
  return v;
}

/// Clones a vector of cloneable objects.
template &lt;typename T&gt; std::vector&lt;T&gt; clone_nop(const std::vector&lt;T&gt; &amp;t) {
  std::vector&lt;T&gt; v;
  for (auto &amp;i : t)
    v.push_back(i.clone());
  return v;
}

/// Path utilities

/// @return The absolute canonical path of a given path.
std::string getAbsolutePath(const std::string &amp;path);

/// Detect an absolute path of the current executable (whose argv0 is known).
/// @return Absolute executable path or argv0 if one cannot be found.
std::string executable_path(const char *argv0);
/// Detect an absolute path of the current libcodonc.
/// @return Absolute executable path or argv0 if one cannot be found.
std::string library_path();

struct ImportFile {
  enum Status { STDLIB, PACKAGE };
  Status status;
  /// Absolute path of an import.
  std::string path;
  /// Module name (e.g. foo.bar.baz).
  std::string module;
};
/// Find an import file what given an executable path (argv0) either in the standard
/// library or relative to a file relativeTo. Set forceStdlib for searching only the
/// standard library.
std::shared_ptr&lt;ImportFile&gt; getImportFile(const std::string &amp;argv0,
                                          const std::string &amp;what,
                                          const std::string &amp;relativeTo,
                                          bool forceStdlib = false,
                                          const std::string &amp;module0 = "",
                                          const std::vector&lt;std::string&gt; &amp;plugins = {});

} // namespace ast
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.427">/// Combine items separated by a delimiter into a string.
template &lt;typename T&gt;
std::string join(const T &amp;items, const std::string &amp;delim = " ", size_t start = 0,
                 size_t end = (1ull &lt;&lt; 31)) {
  std::string s;
  if (end &gt; items.size())
    end = items.size();
  for (int i = start; i &lt; end; i++)
    s += (i &gt; start ? delim : "") + items[i];
  return s;
}
</t>
<t tx="ekr.20230509083243.428">/// Combine items separated by a delimiter into a string.
template &lt;typename T&gt;
std::string combine(const std::vector&lt;T&gt; &amp;items, const std::string &amp;delim = " ") {
  std::string s;
  for (int i = 0; i &lt; items.size(); i++)
    if (items[i])
      s += (i ? delim : "") + items[i]-&gt;toString();
  return s;
}
</t>
<t tx="ekr.20230509083243.429">template &lt;typename T&gt;
std::string combine2(const std::vector&lt;T&gt; &amp;items, const std::string &amp;delim = ",",
  @others
</t>
<t tx="ekr.20230509083243.43">bool isString(Value *v) {
  auto *M = v-&gt;getModule();
  return v-&gt;getType()-&gt;is(M-&gt;getStringType());
}

</t>
<t tx="ekr.20230509083243.430">                   int start = 0, int end = -1) {
std::string s;
if (end == -1)
  end = items.size();
for (int i = start; i &lt; end; i++)
  s += (i ? delim : "") + fmt::format("{}", items[i]);
return s;
}
</t>
<t tx="ekr.20230509083243.431">/// @return True if an item is found in a vector vec.
template &lt;typename T, typename U&gt;
const T *in(const std::vector&lt;T&gt; &amp;vec, const U &amp;item, size_t start = 0) {
  auto f = std::find(vec.begin() + start, vec.end(), item);
  return f != vec.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509083243.432">/// @return True if an item is found in a set s.
template &lt;typename T, typename U&gt; const T *in(const std::set&lt;T&gt; &amp;s, const U &amp;item) {
  auto f = s.find(item);
  return f != s.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509083243.433">/// @return True if an item is found in an unordered_set s.
template &lt;typename T, typename U&gt;
const T *in(const std::unordered_set&lt;T&gt; &amp;s, const U &amp;item) {
  auto f = s.find(item);
  return f != s.end() ? &amp;(*f) : nullptr;
}
</t>
<t tx="ekr.20230509083243.434">/// @return True if an item is found in a map m.
template &lt;typename K, typename V, typename U&gt;
const V *in(const std::map&lt;K, V&gt; &amp;m, const U &amp;item) {
  auto f = m.find(item);
  return f != m.end() ? &amp;(f-&gt;second) : nullptr;
}
</t>
<t tx="ekr.20230509083243.435">/// @return True if an item is found in an unordered_map m.
template &lt;typename K, typename V, typename U&gt;
const V *in(const std::unordered_map&lt;K, V&gt; &amp;m, const U &amp;item) {
  auto f = m.find(item);
  return f != m.end() ? &amp;(f-&gt;second) : nullptr;
}
</t>
<t tx="ekr.20230509083243.436">@path C:/Repos/codon/codon/parser/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;deque&gt;
#include &lt;list&gt;
#include &lt;memory&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"

namespace codon::ast {

/**
 * A variable table (transformation context).
 * Base class that holds a list of existing identifiers and their block hierarchy.
 * @tparam T Variable type.
 */
template &lt;typename T&gt; class Context : public std::enable_shared_from_this&lt;Context&lt;T&gt;&gt; {
public:
  using Item = std::shared_ptr&lt;T&gt;;

protected:
  using Map = std::unordered_map&lt;std::string, std::list&lt;Item&gt;&gt;;
  /// Maps a identifier to a stack of objects that share the same identifier.
  /// Each object is represented by a nesting level and a pointer to that object.
  /// Top of the stack is the current block; the bottom is the outer-most block.
  /// Stack is represented as std::deque to allow iteration and access to the outer-most
  /// block.
  Map map;
  /// Stack of blocks and their corresponding identifiers. Top of the stack is the
  /// current block.
  std::deque&lt;std::list&lt;std::string&gt;&gt; stack;

private:
  /// Set of current context flags.
  std::unordered_set&lt;std::string&gt; flags;
  /// The absolute path of the current module.
  std::string filename;
  /// SrcInfo stack used for obtaining source information of the current expression.
  std::vector&lt;SrcInfo&gt; srcInfos;

public:
  explicit Context(std::string filename) : filename(std::move(filename)) {
    /// Add a top-level block to the stack.
    stack.push_front(std::list&lt;std::string&gt;());
  }
  virtual ~Context() = default;

  /// Add an object to the top of the stack.
  virtual void add(const std::string &amp;name, const Item &amp;var) {
    seqassertn(!name.empty(), "adding an empty identifier");
    map[name].push_front(var);
    stack.front().push_back(name);
  }
@others
public:
  /* SrcInfo helpers */
  void pushSrcInfo(SrcInfo s) { srcInfos.emplace_back(std::move(s)); }
  void popSrcInfo() { srcInfos.pop_back(); }
  SrcInfo getSrcInfo() const { return srcInfos.back(); }
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.437">  /// Remove the top-most object with a given identifier.
  void remove(const std::string &amp;name) {
    removeFromMap(name);
    for (auto &amp;s : stack) {
      auto i = std::find(s.begin(), s.end(), name);
      if (i != s.end()) {
        s.erase(i);
        return;
      }
    }
  }
</t>
<t tx="ekr.20230509083243.438">  /// Return a top-most object with a given identifier or nullptr if it does not exist.
  virtual Item find(const std::string &amp;name) const {
    auto it = map.find(name);
    return it != map.end() ? it-&gt;second.front() : nullptr;
  }
  /// Add a new block (i.e. adds a stack level).
  virtual void addBlock() { stack.push_front(std::list&lt;std::string&gt;()); }
  /// Remove the top-most block and all variables it holds.
  virtual void popBlock() {
    for (auto &amp;name : stack.front())
      removeFromMap(name);
    stack.pop_front();
  }

  /// The absolute path of a current module.
  std::string getFilename() const { return filename; }
  /// Sets the absolute path of a current module.
  void setFilename(std::string file) { filename = std::move(file); }

  /// Convenience functions to allow range-based for loops over a context.
  typename Map::iterator begin() { return map.begin(); }
  typename Map::iterator end() { return map.end(); }

  /// Pretty-prints the current context state.
  virtual void dump() {}

private:
</t>
<t tx="ekr.20230509083243.439">  /// Remove an identifier from the map only.
  void removeFromMap(const std::string &amp;name) {
    auto i = map.find(name);
    if (i == map.end())
      return;
    seqassertn(i-&gt;second.size(), "identifier {} not found in the map", name);
    i-&gt;second.pop_front();
    if (!i-&gt;second.size())
      map.erase(name);
  }

</t>
<t tx="ekr.20230509083243.44">void inspect(Value *v, InspectionResult &amp;r) {
  // check if add first then go from there
  if (isString(v)) {
    if (auto *c = cast&lt;CallInstr&gt;(v)) {
      auto *func = util::getFunc(c-&gt;getCallee());
      if (func &amp;&amp; func-&gt;getUnmangledName() == Module::ADD_MAGIC_NAME &amp;&amp;
          c-&gt;numArgs() == 2 &amp;&amp; isString(c-&gt;front()) &amp;&amp; isString(c-&gt;back())) {
        inspect(c-&gt;front(), r);
        inspect(c-&gt;back(), r);
        return;
      }
    }
    r.args.push_back(v);
  } else {
    r.valid = false;
  }
}
</t>
<t tx="ekr.20230509083243.440"></t>
<t tx="ekr.20230509083243.441">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;stdexcept&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

/**
 * WARNING: do not include anything else in this file, especially format.h
 * peglib.h uses this file. However, it is not compatible with format.h
 * (and possibly some other includes). Their inclusion will result in a succesful
 * compilation but extremely weird behaviour and hard-to-debug crashes (it seems that
 * some parts of peglib conflict with format.h in a weird way---further investigation
 * needed).
 */

namespace codon {
struct SrcInfo {
  std::string file;
  int line;
  int col;
  int len;
  int id; /// used to differentiate different instances

  SrcInfo(std::string file, int line, int col, int len)
      : file(std::move(file)), line(line), col(col), len(len), id(0) {
    static int nextId = 0;
    id = nextId++;
  };

  SrcInfo() : SrcInfo("", 0, 0, 0) {}

  bool operator==(const SrcInfo &amp;src) const { return id == src.id; }
};

} // namespace codon

namespace codon::exc {

/**
 * Parser error exception.
 * Used for parsing, transformation and type-checking errors.
 */
@others
} // namespace codon::exc
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.442">class ParserException : public std::runtime_error {
public:
  /// These vectors (stacks) store an error stack-trace.
  std::vector&lt;SrcInfo&gt; locations;
  std::vector&lt;std::string&gt; messages;
  int errorCode = -1;

public:
  ParserException(int errorCode, const std::string &amp;msg, const SrcInfo &amp;info) noexcept
      : std::runtime_error(msg), errorCode(errorCode) {
    messages.push_back(msg);
    locations.push_back(info);
  }
  ParserException() noexcept : std::runtime_error("") {}
  ParserException(int errorCode, const std::string &amp;msg) noexcept
      : ParserException(errorCode, msg, {}) {}
  explicit ParserException(const std::string &amp;msg) noexcept
      : ParserException(-1, msg, {}) {}
  ParserException(const ParserException &amp;e) noexcept
      : std::runtime_error(e), locations(e.locations), messages(e.messages),
        errorCode(e.errorCode){};

@others
};

</t>
<t tx="ekr.20230509083243.443">  /// Add an error message to the current stack trace
  void trackRealize(const std::string &amp;msg, const SrcInfo &amp;info) {
    locations.push_back(info);
    messages.push_back("during the realization of " + msg);
  }

</t>
<t tx="ekr.20230509083243.444">  /// Add an error message to the current stack trace
  void track(const std::string &amp;msg, const SrcInfo &amp;info) {
    locations.push_back(info);
    messages.push_back(msg);
  }
</t>
<t tx="ekr.20230509083243.445">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "expr.h"

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/visitors/visitor.h"

#define ACCEPT_IMPL(T, X)                                                              \
  ExprPtr T::clone() const { return std::make_shared&lt;T&gt;(*this); }                      \
  void T::accept(X &amp;visitor) { visitor.visit(this); }

using fmt::format;
using namespace codon::error;

namespace codon::ast {

Expr::Expr()
    : type(nullptr), isTypeExpr(false), staticValue(StaticValue::NOT_STATIC),
      done(false), attributes(0), origExpr(nullptr) {}
@others
std::string CallExpr::toString() const {
  std::string s;
  for (auto &amp;i : args)
    if (i.name.empty())
      s += " " + i.value-&gt;toString();
    else
      s += format("({}{})", i.value-&gt;toString(),
                  i.name.empty() ? "" : format(" #:name '{}", i.name));
  return wrapType(format("call {} {}", expr-&gt;toString(), s));
}
ACCEPT_IMPL(CallExpr, ASTVisitor);

DotExpr::DotExpr(ExprPtr expr, std::string member)
    : Expr(), expr(std::move(expr)), member(std::move(member)) {}
DotExpr::DotExpr(const std::string &amp;left, std::string member)
    : Expr(), expr(std::make_shared&lt;IdExpr&gt;(left)), member(std::move(member)) {}
DotExpr::DotExpr(const DotExpr &amp;expr)
    : Expr(expr), expr(ast::clone(expr.expr)), member(expr.member) {}
std::string DotExpr::toString() const {
  return wrapType(format("dot {} '{}", expr-&gt;toString(), member));
}
ACCEPT_IMPL(DotExpr, ASTVisitor);

SliceExpr::SliceExpr(ExprPtr start, ExprPtr stop, ExprPtr step)
    : Expr(), start(std::move(start)), stop(std::move(stop)), step(std::move(step)) {}
SliceExpr::SliceExpr(const SliceExpr &amp;expr)
    : Expr(expr), start(ast::clone(expr.start)), stop(ast::clone(expr.stop)),
      step(ast::clone(expr.step)) {}
std::string SliceExpr::toString() const {
  return wrapType(format("slice{}{}{}",
                         start ? format(" #:start {}", start-&gt;toString()) : "",
                         stop ? format(" #:end {}", stop-&gt;toString()) : "",
                         step ? format(" #:step {}", step-&gt;toString()) : ""));
}
ACCEPT_IMPL(SliceExpr, ASTVisitor);

EllipsisExpr::EllipsisExpr(bool isPipeArg) : Expr(), isPipeArg(isPipeArg) {}
std::string EllipsisExpr::toString() const {
  return wrapType(format("ellipsis{}", isPipeArg ? " #:pipe" : ""));
}
ACCEPT_IMPL(EllipsisExpr, ASTVisitor);

LambdaExpr::LambdaExpr(std::vector&lt;std::string&gt; vars, ExprPtr expr)
    : Expr(), vars(std::move(vars)), expr(std::move(expr)) {}
LambdaExpr::LambdaExpr(const LambdaExpr &amp;expr)
    : Expr(expr), vars(expr.vars), expr(ast::clone(expr.expr)) {}
std::string LambdaExpr::toString() const {
  return wrapType(format("lambda ({}) {}", join(vars, " "), expr-&gt;toString()));
}
ACCEPT_IMPL(LambdaExpr, ASTVisitor);

YieldExpr::YieldExpr() : Expr() {}
std::string YieldExpr::toString() const { return "yield-expr"; }
ACCEPT_IMPL(YieldExpr, ASTVisitor);

AssignExpr::AssignExpr(ExprPtr var, ExprPtr expr)
    : Expr(), var(std::move(var)), expr(std::move(expr)) {}
AssignExpr::AssignExpr(const AssignExpr &amp;expr)
    : Expr(expr), var(ast::clone(expr.var)), expr(ast::clone(expr.expr)) {}
std::string AssignExpr::toString() const {
  return wrapType(format("assign-expr '{} {}", var-&gt;toString(), expr-&gt;toString()));
}
ACCEPT_IMPL(AssignExpr, ASTVisitor);

RangeExpr::RangeExpr(ExprPtr start, ExprPtr stop)
    : Expr(), start(std::move(start)), stop(std::move(stop)) {}
RangeExpr::RangeExpr(const RangeExpr &amp;expr)
    : Expr(expr), start(ast::clone(expr.start)), stop(ast::clone(expr.stop)) {}
std::string RangeExpr::toString() const {
  return wrapType(format("range {} {}", start-&gt;toString(), stop-&gt;toString()));
}
ACCEPT_IMPL(RangeExpr, ASTVisitor);

StmtExpr::StmtExpr(std::vector&lt;std::shared_ptr&lt;Stmt&gt;&gt; stmts, ExprPtr expr)
    : Expr(), stmts(std::move(stmts)), expr(std::move(expr)) {}
StmtExpr::StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, ExprPtr expr)
    : Expr(), expr(std::move(expr)) {
  stmts.push_back(std::move(stmt));
}
StmtExpr::StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, std::shared_ptr&lt;Stmt&gt; stmt2,
                   ExprPtr expr)
    : Expr(), expr(std::move(expr)) {
  stmts.push_back(std::move(stmt));
  stmts.push_back(std::move(stmt2));
}
StmtExpr::StmtExpr(const StmtExpr &amp;expr)
    : Expr(expr), stmts(ast::clone(expr.stmts)), expr(ast::clone(expr.expr)) {}
std::string StmtExpr::toString() const {
  return wrapType(format("stmt-expr ({}) {}", combine(stmts, " "), expr-&gt;toString()));
}
ACCEPT_IMPL(StmtExpr, ASTVisitor);

InstantiateExpr::InstantiateExpr(ExprPtr typeExpr, std::vector&lt;ExprPtr&gt; typeParams)
    : Expr(), typeExpr(std::move(typeExpr)), typeParams(std::move(typeParams)) {}
InstantiateExpr::InstantiateExpr(ExprPtr typeExpr, ExprPtr typeParam)
    : Expr(), typeExpr(std::move(typeExpr)) {
  typeParams.push_back(std::move(typeParam));
}
InstantiateExpr::InstantiateExpr(const InstantiateExpr &amp;expr)
    : Expr(expr), typeExpr(ast::clone(expr.typeExpr)),
      typeParams(ast::clone(expr.typeParams)) {}
std::string InstantiateExpr::toString() const {
  return wrapType(
      format("instantiate {} {}", typeExpr-&gt;toString(), combine(typeParams)));
}
ACCEPT_IMPL(InstantiateExpr, ASTVisitor);

StaticValue::Type getStaticGeneric(Expr *e) {
  if (e &amp;&amp; e-&gt;getIndex() &amp;&amp; e-&gt;getIndex()-&gt;expr-&gt;isId("Static")) {
    if (e-&gt;getIndex()-&gt;index &amp;&amp; e-&gt;getIndex()-&gt;index-&gt;isId("str"))
      return StaticValue::Type::STRING;
    if (e-&gt;getIndex()-&gt;index &amp;&amp; e-&gt;getIndex()-&gt;index-&gt;isId("int"))
      return StaticValue::Type::INT;
    return StaticValue::Type::NOT_SUPPORTED;
  }
  return StaticValue::Type::NOT_STATIC;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.446">void Expr::validate() const {}
types::TypePtr Expr::getType() const { return type; }
void Expr::setType(types::TypePtr t) { this-&gt;type = std::move(t); }
bool Expr::isType() const { return isTypeExpr; }
void Expr::markType() { isTypeExpr = true; }
std::string Expr::wrapType(const std::string &amp;sexpr) const {
  auto is = sexpr;
  if (done)
    is.insert(findStar(is), "*");
  auto s = format("({}{})", is, type ? format(" #:type \"{}\"", type-&gt;toString()) : "");
  // if (hasAttr(ExprAttr::SequenceItem)) s += "%";
  return s;
}
</t>
<t tx="ekr.20230509083243.447">bool Expr::isStatic() const { return staticValue.type != StaticValue::NOT_STATIC; }
bool Expr::hasAttr(int attr) const { return (attributes &amp; (1 &lt;&lt; attr)); }
void Expr::setAttr(int attr) { attributes |= (1 &lt;&lt; attr); }
std::string Expr::getTypeName() {
  if (getId()) {
    return getId()-&gt;value;
  } else {
    auto i = dynamic_cast&lt;InstantiateExpr *&gt;(this);
    seqassertn(i &amp;&amp; i-&gt;typeExpr-&gt;getId(), "bad MRO");
    return i-&gt;typeExpr-&gt;getId()-&gt;value;
  }
}

StaticValue::StaticValue(StaticValue::Type t) : value(), type(t), evaluated(false) {}
StaticValue::StaticValue(int64_t i) : value(i), type(INT), evaluated(true) {}
StaticValue::StaticValue(std::string s)
    : value(std::move(s)), type(STRING), evaluated(true) {}
</t>
<t tx="ekr.20230509083243.448">bool StaticValue::operator==(const StaticValue &amp;s) const {
  if (type != s.type || s.evaluated != evaluated)
    return false;
  return !s.evaluated || value == s.value;
}
</t>
<t tx="ekr.20230509083243.449">std::string StaticValue::toString() const {
  if (type == StaticValue::NOT_STATIC)
    return "";
  if (!evaluated)
    return type == StaticValue::STRING ? "str" : "int";
  return type == StaticValue::STRING ? "'" + escape(std::get&lt;std::string&gt;(value)) + "'"
                                     : std::to_string(std::get&lt;int64_t&gt;(value));
}
</t>
<t tx="ekr.20230509083243.45">} // namespace

const std::string StrAdditionOptimization::KEY = "core-pythonic-str-addition-opt";

</t>
<t tx="ekr.20230509083243.450">int64_t StaticValue::getInt() const {
  seqassertn(type == StaticValue::INT, "not an int");
  return std::get&lt;int64_t&gt;(value);
}
</t>
<t tx="ekr.20230509083243.451">std::string StaticValue::getString() const {
  seqassertn(type == StaticValue::STRING, "not a string");
  return std::get&lt;std::string&gt;(value);
}

Param::Param(std::string name, ExprPtr type, ExprPtr defaultValue, int status)
    : name(std::move(name)), type(std::move(type)),
      defaultValue(std::move(defaultValue)) {
  if (status == 0 &amp;&amp; this-&gt;type &amp;&amp;
      (this-&gt;type-&gt;isId("type") || this-&gt;type-&gt;isId(TYPE_TYPEVAR) ||
       (this-&gt;type-&gt;getIndex() &amp;&amp; this-&gt;type-&gt;getIndex()-&gt;expr-&gt;isId(TYPE_TYPEVAR)) ||
       getStaticGeneric(this-&gt;type.get())))
    this-&gt;status = Generic;
  else
    this-&gt;status = (status == 0 ? Normal : (status == 1 ? Generic : HiddenGeneric));
}
Param::Param(const SrcInfo &amp;info, std::string name, ExprPtr type, ExprPtr defaultValue,
</t>
<t tx="ekr.20230509083243.452">             int status)
    : Param(name, type, defaultValue, status) {
  setSrcInfo(info);
}
</t>
<t tx="ekr.20230509083243.453">std::string Param::toString() const {
  return format("({}{}{}{})", name, type ? " #:type " + type-&gt;toString() : "",
                defaultValue ? " #:default " + defaultValue-&gt;toString() : "",
                status != Param::Normal ? " #:generic" : "");
}
Param Param::clone() const {
  return Param(name, ast::clone(type), ast::clone(defaultValue), status);
}

NoneExpr::NoneExpr() : Expr() {}
std::string NoneExpr::toString() const { return wrapType("none"); }
ACCEPT_IMPL(NoneExpr, ASTVisitor);

BoolExpr::BoolExpr(bool value) : Expr(), value(value) {
  staticValue = StaticValue(value);
}
std::string BoolExpr::toString() const {
  return wrapType(format("bool {}", int(value)));
}
ACCEPT_IMPL(BoolExpr, ASTVisitor);

IntExpr::IntExpr(int64_t intValue) : Expr(), value(std::to_string(intValue)) {
  this-&gt;intValue = std::make_unique&lt;int64_t&gt;(intValue);
  staticValue = StaticValue(intValue);
}
IntExpr::IntExpr(const std::string &amp;value, std::string suffix)
    : Expr(), value(), suffix(std::move(suffix)) {
  for (auto c : value)
    if (c != '_')
      this-&gt;value += c;
  try {
    if (startswith(this-&gt;value, "0b") || startswith(this-&gt;value, "0B"))
</t>
<t tx="ekr.20230509083243.454">      intValue =
          std::make_unique&lt;int64_t&gt;(std::stoull(this-&gt;value.substr(2), nullptr, 2));
    else
      intValue = std::make_unique&lt;int64_t&gt;(std::stoull(this-&gt;value, nullptr, 0));
  } catch (std::out_of_range &amp;) {
    intValue = nullptr;
  }
}
IntExpr::IntExpr(const IntExpr &amp;expr)
    : Expr(expr), value(expr.value), suffix(expr.suffix) {
  intValue = expr.intValue ? std::make_unique&lt;int64_t&gt;(*(expr.intValue)) : nullptr;
}
</t>
<t tx="ekr.20230509083243.455">std::string IntExpr::toString() const {
  return wrapType(format("int {}{}", value,
                         suffix.empty() ? "" : format(" #:suffix \"{}\"", suffix)));
}
ACCEPT_IMPL(IntExpr, ASTVisitor);

FloatExpr::FloatExpr(double floatValue)
    : Expr(), value(fmt::format("{:g}", floatValue)) {
  this-&gt;floatValue = std::make_unique&lt;double&gt;(floatValue);
}
FloatExpr::FloatExpr(const std::string &amp;value, std::string suffix)
    : Expr(), value(value), suffix(std::move(suffix)) {
  try {
    floatValue = std::make_unique&lt;double&gt;(std::stod(value));
  } catch (std::out_of_range &amp;) {
    floatValue = nullptr;
  }
}
FloatExpr::FloatExpr(const FloatExpr &amp;expr)
    : Expr(expr), value(expr.value), suffix(expr.suffix) {
  floatValue = expr.floatValue ? std::make_unique&lt;double&gt;(*(expr.floatValue)) : nullptr;
}
std::string FloatExpr::toString() const {
  return wrapType(format("float {}{}", value,
                         suffix.empty() ? "" : format(" #:suffix \"{}\"", suffix)));
}
ACCEPT_IMPL(FloatExpr, ASTVisitor);

StringExpr::StringExpr(std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; s)
    : Expr(), strings(std::move(s)) {
  if (strings.size() == 1 &amp;&amp; strings.back().second.empty())
    staticValue = StaticValue(strings.back().first);
}
StringExpr::StringExpr(std::string value, std::string prefix)
    : StringExpr(std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;{{value, prefix}}) {}
std::string StringExpr::toString() const {
  std::vector&lt;std::string&gt; s;
  for (auto &amp;vp : strings)
    s.push_back(format("\"{}\"{}", escape(vp.first),
                       vp.second.empty() ? "" : format(" #:prefix \"{}\"", vp.second)));
  return wrapType(format("string ({})", join(s)));
}
std::string StringExpr::getValue() const {
  seqassert(!strings.empty(), "invalid StringExpr");
  return strings[0].first;
}
ACCEPT_IMPL(StringExpr, ASTVisitor);

IdExpr::IdExpr(std::string value) : Expr(), value(std::move(value)) {}
std::string IdExpr::toString() const {
  return !type ? format("'{}", value) : wrapType(format("'{}", value));
}
ACCEPT_IMPL(IdExpr, ASTVisitor);

StarExpr::StarExpr(ExprPtr what) : Expr(), what(std::move(what)) {}
StarExpr::StarExpr(const StarExpr &amp;expr) : Expr(expr), what(ast::clone(expr.what)) {}
std::string StarExpr::toString() const {
  return wrapType(format("star {}", what-&gt;toString()));
}
ACCEPT_IMPL(StarExpr, ASTVisitor);

KeywordStarExpr::KeywordStarExpr(ExprPtr what) : Expr(), what(std::move(what)) {}
KeywordStarExpr::KeywordStarExpr(const KeywordStarExpr &amp;expr)
    : Expr(expr), what(ast::clone(expr.what)) {}
std::string KeywordStarExpr::toString() const {
  return wrapType(format("kwstar {}", what-&gt;toString()));
}
ACCEPT_IMPL(KeywordStarExpr, ASTVisitor);

TupleExpr::TupleExpr(std::vector&lt;ExprPtr&gt; items) : Expr(), items(std::move(items)) {}
TupleExpr::TupleExpr(const TupleExpr &amp;expr)
    : Expr(expr), items(ast::clone(expr.items)) {}
std::string TupleExpr::toString() const {
  return wrapType(format("tuple {}", combine(items)));
}
ACCEPT_IMPL(TupleExpr, ASTVisitor);

ListExpr::ListExpr(std::vector&lt;ExprPtr&gt; items) : Expr(), items(std::move(items)) {}
ListExpr::ListExpr(const ListExpr &amp;expr) : Expr(expr), items(ast::clone(expr.items)) {}
std::string ListExpr::toString() const {
  return wrapType(!items.empty() ? format("list {}", combine(items)) : "list");
}
ACCEPT_IMPL(ListExpr, ASTVisitor);

SetExpr::SetExpr(std::vector&lt;ExprPtr&gt; items) : Expr(), items(std::move(items)) {}
SetExpr::SetExpr(const SetExpr &amp;expr) : Expr(expr), items(ast::clone(expr.items)) {}
std::string SetExpr::toString() const {
  return wrapType(!items.empty() ? format("set {}", combine(items)) : "set");
}
ACCEPT_IMPL(SetExpr, ASTVisitor);

DictExpr::DictExpr(std::vector&lt;ExprPtr&gt; items) : Expr(), items(std::move(items)) {
  for (auto &amp;i : items) {
    auto t = i-&gt;getTuple();
    seqassertn(t &amp;&amp; t-&gt;items.size() == 2, "dictionary items are invalid");
  }
}
DictExpr::DictExpr(const DictExpr &amp;expr) : Expr(expr), items(ast::clone(expr.items)) {}
std::string DictExpr::toString() const {
  return wrapType(!items.empty() ? format("dict {}", combine(items)) : "set");
}
ACCEPT_IMPL(DictExpr, ASTVisitor);

GeneratorBody GeneratorBody::clone() const {
  return {ast::clone(vars), ast::clone(gen), ast::clone(conds)};
}

GeneratorExpr::GeneratorExpr(GeneratorExpr::GeneratorKind kind, ExprPtr expr,
                             std::vector&lt;GeneratorBody&gt; loops)
    : Expr(), kind(kind), expr(std::move(expr)), loops(std::move(loops)) {}
GeneratorExpr::GeneratorExpr(const GeneratorExpr &amp;expr)
    : Expr(expr), kind(expr.kind), expr(ast::clone(expr.expr)),
      loops(ast::clone_nop(expr.loops)) {}
std::string GeneratorExpr::toString() const {
  std::string prefix;
  if (kind == GeneratorKind::ListGenerator)
    prefix = "list-";
  if (kind == GeneratorKind::SetGenerator)
    prefix = "set-";
  std::string s;
  for (auto &amp;i : loops) {
    std::string q;
    for (auto &amp;k : i.conds)
      q += format(" (if {})", k-&gt;toString());
    s += format(" (for {} {}{})", i.vars-&gt;toString(), i.gen-&gt;toString(), q);
  }
  return wrapType(format("{}gen {}{}", prefix, expr-&gt;toString(), s));
}
ACCEPT_IMPL(GeneratorExpr, ASTVisitor);

DictGeneratorExpr::DictGeneratorExpr(ExprPtr key, ExprPtr expr,
                                     std::vector&lt;GeneratorBody&gt; loops)
    : Expr(), key(std::move(key)), expr(std::move(expr)), loops(std::move(loops)) {}
DictGeneratorExpr::DictGeneratorExpr(const DictGeneratorExpr &amp;expr)
    : Expr(expr), key(ast::clone(expr.key)), expr(ast::clone(expr.expr)),
      loops(ast::clone_nop(expr.loops)) {}
std::string DictGeneratorExpr::toString() const {
  std::string s;
  for (auto &amp;i : loops) {
    std::string q;
    for (auto &amp;k : i.conds)
      q += format("( if {})", k-&gt;toString());
    s += format(" (for {} {}{})", i.vars-&gt;toString(), i.gen-&gt;toString(), q);
  }
  return wrapType(format("dict-gen {} {}{}", key-&gt;toString(), expr-&gt;toString(), s));
}
ACCEPT_IMPL(DictGeneratorExpr, ASTVisitor);

IfExpr::IfExpr(ExprPtr cond, ExprPtr ifexpr, ExprPtr elsexpr)
    : Expr(), cond(std::move(cond)), ifexpr(std::move(ifexpr)),
      elsexpr(std::move(elsexpr)) {}
IfExpr::IfExpr(const IfExpr &amp;expr)
    : Expr(expr), cond(ast::clone(expr.cond)), ifexpr(ast::clone(expr.ifexpr)),
      elsexpr(ast::clone(expr.elsexpr)) {}
std::string IfExpr::toString() const {
  return wrapType(format("if-expr {} {} {}", cond-&gt;toString(), ifexpr-&gt;toString(),
                         elsexpr-&gt;toString()));
}
ACCEPT_IMPL(IfExpr, ASTVisitor);

UnaryExpr::UnaryExpr(std::string op, ExprPtr expr)
    : Expr(), op(std::move(op)), expr(std::move(expr)) {}
UnaryExpr::UnaryExpr(const UnaryExpr &amp;expr)
    : Expr(expr), op(expr.op), expr(ast::clone(expr.expr)) {}
std::string UnaryExpr::toString() const {
  return wrapType(format("unary \"{}\" {}", op, expr-&gt;toString()));
}
ACCEPT_IMPL(UnaryExpr, ASTVisitor);

BinaryExpr::BinaryExpr(ExprPtr lexpr, std::string op, ExprPtr rexpr, bool inPlace)
    : Expr(), op(std::move(op)), lexpr(std::move(lexpr)), rexpr(std::move(rexpr)),
      inPlace(inPlace) {}
BinaryExpr::BinaryExpr(const BinaryExpr &amp;expr)
    : Expr(expr), op(expr.op), lexpr(ast::clone(expr.lexpr)),
      rexpr(ast::clone(expr.rexpr)), inPlace(expr.inPlace) {}
std::string BinaryExpr::toString() const {
  return wrapType(format("binary \"{}\" {} {}{}", op, lexpr-&gt;toString(),
                         rexpr-&gt;toString(), inPlace ? " #:in-place" : ""));
}
ACCEPT_IMPL(BinaryExpr, ASTVisitor);

ChainBinaryExpr::ChainBinaryExpr(std::vector&lt;std::pair&lt;std::string, ExprPtr&gt;&gt; exprs)
    : Expr(), exprs(std::move(exprs)) {}
ChainBinaryExpr::ChainBinaryExpr(const ChainBinaryExpr &amp;expr) : Expr(expr) {
  for (auto &amp;e : expr.exprs)
    exprs.emplace_back(make_pair(e.first, ast::clone(e.second)));
}
std::string ChainBinaryExpr::toString() const {
  std::vector&lt;std::string&gt; s;
  for (auto &amp;i : exprs)
    s.push_back(format("({} \"{}\")", i.first, i.second-&gt;toString()));
  return wrapType(format("chain {}", join(s, " ")));
}
ACCEPT_IMPL(ChainBinaryExpr, ASTVisitor);

PipeExpr::Pipe PipeExpr::Pipe::clone() const { return {op, ast::clone(expr)}; }

PipeExpr::PipeExpr(std::vector&lt;PipeExpr::Pipe&gt; items)
    : Expr(), items(std::move(items)) {
  for (auto &amp;i : this-&gt;items) {
    if (auto call = i.expr-&gt;getCall()) {
      for (auto &amp;a : call-&gt;args)
        if (auto el = a.value-&gt;getEllipsis())
          el-&gt;isPipeArg = true;
    }
  }
}
PipeExpr::PipeExpr(const PipeExpr &amp;expr)
    : Expr(expr), items(ast::clone_nop(expr.items)), inTypes(expr.inTypes) {}
</t>
<t tx="ekr.20230509083243.456">void PipeExpr::validate() const {}
std::string PipeExpr::toString() const {
  std::vector&lt;std::string&gt; s;
  for (auto &amp;i : items)
    s.push_back(format("({} \"{}\")", i.expr-&gt;toString(), i.op));
  return wrapType(format("pipe {}", join(s, " ")));
}
</t>
<t tx="ekr.20230509083243.457">ACCEPT_IMPL(PipeExpr, ASTVisitor);

IndexExpr::IndexExpr(ExprPtr expr, ExprPtr index)
    : Expr(), expr(std::move(expr)), index(std::move(index)) {}
IndexExpr::IndexExpr(const IndexExpr &amp;expr)
    : Expr(expr), expr(ast::clone(expr.expr)), index(ast::clone(expr.index)) {}
std::string IndexExpr::toString() const {
  return wrapType(format("index {} {}", expr-&gt;toString(), index-&gt;toString()));
}
ACCEPT_IMPL(IndexExpr, ASTVisitor);

CallExpr::Arg CallExpr::Arg::clone() const { return {name, ast::clone(value)}; }
CallExpr::Arg::Arg(const SrcInfo &amp;info, const std::string &amp;name, ExprPtr value)
    : name(name), value(value) {
  setSrcInfo(info);
}
CallExpr::Arg::Arg(const std::string &amp;name, ExprPtr value) : name(name), value(value) {
  if (value)
    setSrcInfo(value-&gt;getSrcInfo());
}
CallExpr::Arg::Arg(ExprPtr value) : CallExpr::Arg("", value) {}

CallExpr::CallExpr(const CallExpr &amp;expr)
    : Expr(expr), expr(ast::clone(expr.expr)), args(ast::clone_nop(expr.args)),
      ordered(expr.ordered) {}
CallExpr::CallExpr(ExprPtr expr, std::vector&lt;CallExpr::Arg&gt; args)
    : Expr(), expr(std::move(expr)), args(std::move(args)), ordered(false) {
  validate();
}
CallExpr::CallExpr(ExprPtr expr, std::vector&lt;ExprPtr&gt; args)
    : expr(std::move(expr)), ordered(false) {
  for (auto &amp;a : args)
    if (a)
      this-&gt;args.push_back({"", std::move(a)});
  validate();
}
</t>
<t tx="ekr.20230509083243.458">void CallExpr::validate() const {
  bool namesStarted = false, foundEllipsis = false;
  for (auto &amp;a : args) {
    if (a.name.empty() &amp;&amp; namesStarted &amp;&amp;
        !(CAST(a.value, KeywordStarExpr) || a.value-&gt;getEllipsis()))
      E(Error::CALL_NAME_ORDER, a.value);
    if (!a.name.empty() &amp;&amp; (a.value-&gt;getStar() || CAST(a.value, KeywordStarExpr)))
      E(Error::CALL_NAME_STAR, a.value);
    if (a.value-&gt;getEllipsis() &amp;&amp; foundEllipsis)
      E(Error::CALL_ELLIPSIS, a.value);
    foundEllipsis |= bool(a.value-&gt;getEllipsis());
    namesStarted |= !a.name.empty();
  }
}
</t>
<t tx="ekr.20230509083243.459">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;variant&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types.h"
#include "codon/parser/common.h"

namespace codon::ast {

#define ACCEPT(X)                                                                      \
  ExprPtr clone() const override;                                                      \
  void accept(X &amp;visitor) override

// Forward declarations
struct ASTVisitor;
struct BinaryExpr;
struct CallExpr;
struct DotExpr;
struct EllipsisExpr;
struct IdExpr;
struct IfExpr;
struct IndexExpr;
struct IntExpr;
struct ListExpr;
struct NoneExpr;
struct StarExpr;
struct StmtExpr;
struct StringExpr;
struct TupleExpr;
struct UnaryExpr;
struct Stmt;

struct StaticValue {
  std::variant&lt;int64_t, std::string&gt; value;
  enum Type { NOT_STATIC = 0, STRING = 1, INT = 2, NOT_SUPPORTED = 3 } type;
  bool evaluated;

  explicit StaticValue(Type);
  // Static(bool);
  explicit StaticValue(int64_t);
  explicit StaticValue(std::string);
  bool operator==(const StaticValue &amp;s) const;
  std::string toString() const;
  int64_t getInt() const;
  std::string getString() const;
};

/**
 * A Seq AST expression.
 * Each AST expression is intended to be instantiated as a shared_ptr.
 */
struct Expr : public codon::SrcObject {
  using base_type = Expr;

  // private:
  /// Type of the expression. nullptr by default.
  types::TypePtr type;
  /// Flag that indicates if an expression describes a type (e.g. int or list[T]).
  /// Used by transformation and type-checking stages.
  bool isTypeExpr;
  /// Flag that indicates if an expression is a compile-time static expression.
  /// Such expression is of a form:
  ///   an integer (IntExpr) without any suffix that is within i64 range
  ///   a static generic
  ///   [-,not] a
  ///   a [+,-,*,//,%,and,or,==,!=,&lt;,&lt;=,&gt;,&gt;=] b
  ///     (note: and/or will NOT short-circuit)
  ///   a if cond else b
  ///     (note: cond is static, and is true if non-zero, false otherwise).
  ///     (note: both branches will be evaluated).
  StaticValue staticValue;
  /// Flag that indicates if all types in an expression are inferred (i.e. if a
  /// type-checking procedure was successful).
  bool done;

  /// Set of attributes.
  int attributes;

  /// Original (pre-transformation) expression
  std::shared_ptr&lt;Expr&gt; origExpr;

public:
  Expr();
  Expr(const Expr &amp;expr) = default;

  /// Convert a node to an S-expression.
  virtual std::string toString() const = 0;
  /// Validate a node. Throw ParseASTException if a node is not valid.
  void validate() const;
  /// Deep copy a node.
  virtual std::shared_ptr&lt;Expr&gt; clone() const = 0;
  /// Accept an AST visitor.
  virtual void accept(ASTVisitor &amp;visitor) = 0;

  /// Get a node type.
  /// @return Type pointer or a nullptr if a type is not set.
  types::TypePtr getType() const;
  /// Set a node type.
  void setType(types::TypePtr type);
  /// @return true if a node describes a type expression.
  bool isType() const;
  /// Marks a node as a type expression.
  void markType();
  /// True if a node is static expression.
  bool isStatic() const;

  /// Allow pretty-printing to C++ streams.
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Expr &amp;expr) {
    return out &lt;&lt; expr.toString();
  }

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual bool isId(const std::string &amp;val) const { return false; }
  virtual BinaryExpr *getBinary() { return nullptr; }
  virtual CallExpr *getCall() { return nullptr; }
  virtual DotExpr *getDot() { return nullptr; }
  virtual EllipsisExpr *getEllipsis() { return nullptr; }
  virtual IdExpr *getId() { return nullptr; }
  virtual IfExpr *getIf() { return nullptr; }
  virtual IndexExpr *getIndex() { return nullptr; }
  virtual IntExpr *getInt() { return nullptr; }
  virtual ListExpr *getList() { return nullptr; }
  virtual NoneExpr *getNone() { return nullptr; }
  virtual StarExpr *getStar() { return nullptr; }
  virtual StmtExpr *getStmtExpr() { return nullptr; }
  virtual StringExpr *getString() { return nullptr; }
  virtual TupleExpr *getTuple() { return nullptr; }
  virtual UnaryExpr *getUnary() { return nullptr; }

  /// Attribute helpers
  bool hasAttr(int attr) const;
  void setAttr(int attr);

  bool isDone() const { return done; }
  void setDone() { done = true; }

  /// @return Type name for IdExprs or instantiations.
  std::string getTypeName();

protected:
  /// Add a type to S-expression string.
  std::string wrapType(const std::string &amp;sexpr) const;
};
using ExprPtr = std::shared_ptr&lt;Expr&gt;;

/// Function signature parameter helper node (name: type = defaultValue).
struct Param : public codon::SrcObject {
  std::string name;
  ExprPtr type;
  ExprPtr defaultValue;
  enum {
    Normal,
    Generic,
    HiddenGeneric
  } status; // 1 for normal generic, 2 for hidden generic

  explicit Param(std::string name = "", ExprPtr type = nullptr,
                 ExprPtr defaultValue = nullptr, int generic = 0);
  explicit Param(const SrcInfo &amp;info, std::string name = "", ExprPtr type = nullptr,
                 ExprPtr defaultValue = nullptr, int generic = 0);

  std::string toString() const;
  Param clone() const;
};

/// None expression.
/// @li None
struct NoneExpr : public Expr {
  NoneExpr();
  NoneExpr(const NoneExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  NoneExpr *getNone() override { return this; }
};

/// Bool expression (value).
/// @li True
struct BoolExpr : public Expr {
  bool value;

  explicit BoolExpr(bool value);
  BoolExpr(const BoolExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Int expression (value.suffix).
/// @li 12
/// @li 13u
/// @li 000_010b
struct IntExpr : public Expr {
  /// Expression value is stored as a string that is parsed during the simplify stage.
  std::string value;
  /// Number suffix (e.g. "u" for "123u").
  std::string suffix;

  /// Parsed value and sign for "normal" 64-bit integers.
  std::unique_ptr&lt;int64_t&gt; intValue;

  explicit IntExpr(int64_t intValue);
  explicit IntExpr(const std::string &amp;value, std::string suffix = "");
  IntExpr(const IntExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IntExpr *getInt() override { return this; }
};

/// Float expression (value.suffix).
/// @li 12.1
/// @li 13.15z
/// @li e-12
struct FloatExpr : public Expr {
  /// Expression value is stored as a string that is parsed during the simplify stage.
  std::string value;
  /// Number suffix (e.g. "u" for "123u").
  std::string suffix;

  /// Parsed value for 64-bit floats.
  std::unique_ptr&lt;double&gt; floatValue;

  explicit FloatExpr(double floatValue);
  explicit FloatExpr(const std::string &amp;value, std::string suffix = "");
  FloatExpr(const FloatExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// String expression (prefix"value").
/// @li s'ACGT'
/// @li "fff"
struct StringExpr : public Expr {
  // Vector of {value, prefix} strings.
  std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; strings;

  explicit StringExpr(std::string value, std::string prefix = "");
  explicit StringExpr(std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; strings);
  StringExpr(const StringExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StringExpr *getString() override { return this; }
  std::string getValue() const;
};

/// Identifier expression (value).
struct IdExpr : public Expr {
  std::string value;

  explicit IdExpr(std::string value);
  IdExpr(const IdExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  bool isId(const std::string &amp;val) const override { return this-&gt;value == val; }
  IdExpr *getId() override { return this; }
};

/// Star (unpacking) expression (*what).
/// @li *args
struct StarExpr : public Expr {
  ExprPtr what;

  explicit StarExpr(ExprPtr what);
  StarExpr(const StarExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StarExpr *getStar() override { return this; }
};

/// KeywordStar (unpacking) expression (**what).
/// @li **kwargs
struct KeywordStarExpr : public Expr {
  ExprPtr what;

  explicit KeywordStarExpr(ExprPtr what);
  KeywordStarExpr(const KeywordStarExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Tuple expression ((items...)).
/// @li (1, a)
struct TupleExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit TupleExpr(std::vector&lt;ExprPtr&gt; items = {});
  TupleExpr(const TupleExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  TupleExpr *getTuple() override { return this; }
};

/// List expression ([items...]).
/// @li [1, 2]
struct ListExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit ListExpr(std::vector&lt;ExprPtr&gt; items);
  ListExpr(const ListExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  ListExpr *getList() override { return this; }
};

/// Set expression ({items...}).
/// @li {1, 2}
struct SetExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit SetExpr(std::vector&lt;ExprPtr&gt; items);
  SetExpr(const SetExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Dictionary expression ({(key: value)...}).
/// Each (key, value) pair is stored as a TupleExpr.
/// @li {'s': 1, 't': 2}
struct DictExpr : public Expr {
  std::vector&lt;ExprPtr&gt; items;

  explicit DictExpr(std::vector&lt;ExprPtr&gt; items);
  DictExpr(const DictExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Generator body node helper [for vars in gen (if conds)...].
/// @li for i in lst if a if b
struct GeneratorBody {
  ExprPtr vars;
  ExprPtr gen;
  std::vector&lt;ExprPtr&gt; conds;

  GeneratorBody clone() const;
};

/// Generator or comprehension expression [(expr (loops...))].
/// @li [i for i in j]
/// @li (f + 1 for j in k if j for f in j)
struct GeneratorExpr : public Expr {
  /// Generator kind: normal generator, list comprehension, set comprehension.
  enum GeneratorKind { Generator, ListGenerator, SetGenerator };

  GeneratorKind kind;
  ExprPtr expr;
  std::vector&lt;GeneratorBody&gt; loops;

  GeneratorExpr(GeneratorKind kind, ExprPtr expr, std::vector&lt;GeneratorBody&gt; loops);
  GeneratorExpr(const GeneratorExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Dictionary comprehension expression [{key: expr (loops...)}].
/// @li {i: j for i, j in z.items()}
struct DictGeneratorExpr : public Expr {
  ExprPtr key, expr;
  std::vector&lt;GeneratorBody&gt; loops;

  DictGeneratorExpr(ExprPtr key, ExprPtr expr, std::vector&lt;GeneratorBody&gt; loops);
  DictGeneratorExpr(const DictGeneratorExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Conditional expression [cond if ifexpr else elsexpr].
/// @li 1 if a else 2
struct IfExpr : public Expr {
  ExprPtr cond, ifexpr, elsexpr;

  IfExpr(ExprPtr cond, ExprPtr ifexpr, ExprPtr elsexpr);
  IfExpr(const IfExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IfExpr *getIf() override { return this; }
};

/// Unary expression [op expr].
/// @li -56
struct UnaryExpr : public Expr {
  std::string op;
  ExprPtr expr;

  UnaryExpr(std::string op, ExprPtr expr);
  UnaryExpr(const UnaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  UnaryExpr *getUnary() override { return this; }
};

/// Binary expression [lexpr op rexpr].
/// @li 1 + 2
/// @li 3 or 4
struct BinaryExpr : public Expr {
  std::string op;
  ExprPtr lexpr, rexpr;

  /// True if an expression modifies lhs in-place (e.g. a += b).
  bool inPlace;

  BinaryExpr(ExprPtr lexpr, std::string op, ExprPtr rexpr, bool inPlace = false);
  BinaryExpr(const BinaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  BinaryExpr *getBinary() override { return this; }
};

/// Chained binary expression.
/// @li 1 &lt;= x &lt;= 2
struct ChainBinaryExpr : public Expr {
  std::vector&lt;std::pair&lt;std::string, ExprPtr&gt;&gt; exprs;

  ChainBinaryExpr(std::vector&lt;std::pair&lt;std::string, ExprPtr&gt;&gt; exprs);
  ChainBinaryExpr(const ChainBinaryExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Pipe expression [(op expr)...].
/// op is either "" (only the first item), "|&gt;" or "||&gt;".
/// @li a |&gt; b ||&gt; c
struct PipeExpr : public Expr {
  struct Pipe {
    std::string op;
    ExprPtr expr;

    Pipe clone() const;
  };

  std::vector&lt;Pipe&gt; items;
  /// Output type of a "prefix" pipe ending at the index position.
  /// Example: for a |&gt; b |&gt; c, inTypes[1] is typeof(a |&gt; b).
  std::vector&lt;types::TypePtr&gt; inTypes;

  explicit PipeExpr(std::vector&lt;Pipe&gt; items);
  PipeExpr(const PipeExpr &amp;expr);

  std::string toString() const override;
  void validate() const;
  ACCEPT(ASTVisitor);
};

/// Index expression (expr[index]).
/// @li a[5]
struct IndexExpr : public Expr {
  ExprPtr expr, index;

  IndexExpr(ExprPtr expr, ExprPtr index);
  IndexExpr(const IndexExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  IndexExpr *getIndex() override { return this; }
};

/// Call expression (expr((name=value)...)).
/// @li a(1, b=2)
struct CallExpr : public Expr {
  /// Each argument can have a name (e.g. foo(1, b=5))
  struct Arg : public codon::SrcObject {
    std::string name;
    ExprPtr value;

    Arg clone() const;

    Arg(const SrcInfo &amp;info, const std::string &amp;name, ExprPtr value);
    Arg(const std::string &amp;name, ExprPtr value);
    Arg(ExprPtr value);
  };

  ExprPtr expr;
  std::vector&lt;Arg&gt; args;
  /// True if type-checker has processed and re-ordered args.
  bool ordered;

  CallExpr(ExprPtr expr, std::vector&lt;Arg&gt; args = {});
  /// Convenience constructors
  CallExpr(ExprPtr expr, std::vector&lt;ExprPtr&gt; args);
  template &lt;typename... Ts&gt;
  CallExpr(ExprPtr expr, ExprPtr arg, Ts... args)
      : CallExpr(expr, std::vector&lt;ExprPtr&gt;{arg, args...}) {}
  CallExpr(const CallExpr &amp;expr);

  void validate() const;
  std::string toString() const override;
  ACCEPT(ASTVisitor);

  CallExpr *getCall() override { return this; }
};

/// Dot (access) expression (expr.member).
/// @li a.b
struct DotExpr : public Expr {
  ExprPtr expr;
  std::string member;

  DotExpr(ExprPtr expr, std::string member);
  /// Convenience constructor.
  DotExpr(const std::string &amp;left, std::string member);
  DotExpr(const DotExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  DotExpr *getDot() override { return this; }
};

/// Slice expression (st:stop:step).
/// @li 1:10:3
/// @li s::-1
/// @li :::
struct SliceExpr : public Expr {
  /// Any of these can be nullptr to account for partial slices.
  ExprPtr start, stop, step;

  SliceExpr(ExprPtr start, ExprPtr stop, ExprPtr step);
  SliceExpr(const SliceExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Ellipsis expression.
/// @li ...
struct EllipsisExpr : public Expr {
  /// True if this is a target partial argument within a PipeExpr.
  /// If true, this node will be handled differently during the type-checking stage.
  bool isPipeArg;

  explicit EllipsisExpr(bool isPipeArg = false);
  EllipsisExpr(const EllipsisExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  EllipsisExpr *getEllipsis() override { return this; }
};

/// Lambda expression (lambda (vars)...: expr).
/// @li lambda a, b: a + b
struct LambdaExpr : public Expr {
  std::vector&lt;std::string&gt; vars;
  ExprPtr expr;

  LambdaExpr(std::vector&lt;std::string&gt; vars, ExprPtr expr);
  LambdaExpr(const LambdaExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Yield (send to generator) expression.
/// @li (yield)
struct YieldExpr : public Expr {
  YieldExpr();
  YieldExpr(const YieldExpr &amp;expr) = default;

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Assignment (walrus) expression (var := expr).
/// @li a := 5 + 3
struct AssignExpr : public Expr {
  ExprPtr var, expr;

  AssignExpr(ExprPtr var, ExprPtr expr);
  AssignExpr(const AssignExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// Range expression (start ... end).
/// Used only in match-case statements.
/// @li 1 ... 2
struct RangeExpr : public Expr {
  ExprPtr start, stop;

  RangeExpr(ExprPtr start, ExprPtr stop);
  RangeExpr(const RangeExpr &amp;);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

/// The following nodes are created after the simplify stage.

/// Statement expression (stmts...; expr).
/// Statements are evaluated only if the expression is evaluated
/// (to support short-circuiting).
/// @li (a = 1; b = 2; a + b)
struct StmtExpr : public Expr {
  std::vector&lt;std::shared_ptr&lt;Stmt&gt;&gt; stmts;
  ExprPtr expr;

  StmtExpr(std::vector&lt;std::shared_ptr&lt;Stmt&gt;&gt; stmts, ExprPtr expr);
  StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, ExprPtr expr);
  StmtExpr(std::shared_ptr&lt;Stmt&gt; stmt, std::shared_ptr&lt;Stmt&gt; stmt2, ExprPtr expr);
  StmtExpr(const StmtExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);

  StmtExpr *getStmtExpr() override { return this; }
};

/// Static tuple indexing expression (expr[index]).
/// @li (1, 2, 3)[2]
struct InstantiateExpr : Expr {
  ExprPtr typeExpr;
  std::vector&lt;ExprPtr&gt; typeParams;

  InstantiateExpr(ExprPtr typeExpr, std::vector&lt;ExprPtr&gt; typeParams);
  /// Convenience constructor for a single type parameter.
  InstantiateExpr(ExprPtr typeExpr, ExprPtr typeParam);
  InstantiateExpr(const InstantiateExpr &amp;expr);

  std::string toString() const override;
  ACCEPT(ASTVisitor);
};

#undef ACCEPT

enum ExprAttr {
  SequenceItem,
  StarSequenceItem,
  List,
  Set,
  Dict,
  Partial,
  Dominated,
  StarArgument,
  KwStarArgument,
  OrderedCall,
  ExternVar,
  __LAST__
};

StaticValue::Type getStaticGeneric(Expr *e);

} // namespace codon::ast

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.46">void StrAdditionOptimization::handle(CallInstr *v) {
  auto *M = v-&gt;getModule();

  auto *f = util::getFunc(v-&gt;getCallee());
  if (!f || f-&gt;getUnmangledName() != Module::ADD_MAGIC_NAME)
    return;

  InspectionResult r;
  inspect(v, r);

  if (r.valid &amp;&amp; r.args.size() &gt; 2) {
    std::vector&lt;Value *&gt; args;
    util::CloneVisitor cv(M);

    for (auto *arg : r.args) {
      args.push_back(cv.clone(arg));
    }

    auto *arg = util::makeTuple(args, M);
    args = {arg};
    auto *replacementFunc =
        M-&gt;getOrRealizeMethod(M-&gt;getStringType(), "cat", {arg-&gt;getType()});
    seqassertn(replacementFunc, "could not find cat function [{}]", v-&gt;getSrcInfo());
    v-&gt;replaceAll(util::call(replacementFunc, args));
  }
}

</t>
<t tx="ekr.20230509083243.460">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::Expr, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509083243.461">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::CallExpr::Arg&gt; : fmt::formatter&lt;std::string_view&gt; {
@others
};

</t>
<t tx="ekr.20230509083243.462">template &lt;typename FormatContext&gt;
auto format(const codon::ast::CallExpr::Arg &amp;p, FormatContext &amp;ctx) const
    -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "({}{})",
                        p.name.empty() ? "" : fmt::format("{} = ", p.name), p.value);
}
</t>
<t tx="ekr.20230509083243.463">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::Param&gt; : fmt::formatter&lt;std::string_view&gt; {
  template &lt;typename FormatContext&gt;
  auto format(const codon::ast::Param &amp;p, FormatContext &amp;ctx) const
      -&gt; decltype(ctx.out()) {
    return fmt::format_to(ctx.out(), "{}", p.toString());
  }
};

</t>
<t tx="ekr.20230509083243.464">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;
           std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::Expr&gt;&gt;::value, char&gt;&gt;
    : fmt::formatter&lt;std::string_view&gt; {
  @others
};
</t>
<t tx="ekr.20230509083243.465">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;toString() : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509083243.466">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "stmt.h"

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/cache.h"
#include "codon/parser/visitors/visitor.h"

#define ACCEPT_IMPL(T, X)                                                              \
  StmtPtr T::clone() const { return std::make_shared&lt;T&gt;(*this); }                      \
  void T::accept(X &amp;visitor) { visitor.visit(this); }

using fmt::format;
using namespace codon::error;

const int INDENT_SIZE = 2;

namespace codon::ast {

Stmt::Stmt() : done(false), age(-1) {}
Stmt::Stmt(const codon::SrcInfo &amp;s) : done(false), age(-1) { setSrcInfo(s); }
std::string Stmt::toString() const { return toString(-1); }
@others
std::string ClassStmt::getDocstr() {
  if (auto s = suite-&gt;firstInBlock()) {
    if (auto e = s-&gt;getExpr()) {
      if (auto ss = e-&gt;expr-&gt;getString())
        return ss-&gt;getValue();
    }
  }
  return "";
}

YieldFromStmt::YieldFromStmt(ExprPtr expr) : Stmt(), expr(std::move(expr)) {}
YieldFromStmt::YieldFromStmt(const YieldFromStmt &amp;stmt)
    : Stmt(stmt), expr(ast::clone(stmt.expr)) {}
std::string YieldFromStmt::toString(int) const {
  return format("(yield-from {})", expr-&gt;toString());
}
ACCEPT_IMPL(YieldFromStmt, ASTVisitor);

WithStmt::WithStmt(std::vector&lt;ExprPtr&gt; items, std::vector&lt;std::string&gt; vars,
                   StmtPtr suite)
    : Stmt(), items(std::move(items)), vars(std::move(vars)), suite(std::move(suite)) {
  seqassert(this-&gt;items.size() == this-&gt;vars.size(), "vector size mismatch");
}
WithStmt::WithStmt(std::vector&lt;std::pair&lt;ExprPtr, ExprPtr&gt;&gt; itemVarPairs, StmtPtr suite)
    : Stmt(), suite(std::move(suite)) {
  for (auto &amp;i : itemVarPairs) {
    items.push_back(std::move(i.first));
    if (i.second) {
      if (!i.second-&gt;getId())
        throw;
      vars.push_back(i.second-&gt;getId()-&gt;value);
    } else {
      vars.emplace_back();
    }
  }
}
WithStmt::WithStmt(const WithStmt &amp;stmt)
    : Stmt(stmt), items(ast::clone(stmt.items)), vars(stmt.vars),
      suite(ast::clone(stmt.suite)) {}
std::string WithStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::vector&lt;std::string&gt; as;
  as.reserve(items.size());
  for (int i = 0; i &lt; items.size(); i++) {
    as.push_back(!vars[i].empty()
                     ? format("({} #:var '{})", items[i]-&gt;toString(), vars[i])
                     : items[i]-&gt;toString());
  }
  return format("(with ({}){}{})", join(as, " "), pad,
                suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1));
}
ACCEPT_IMPL(WithStmt, ASTVisitor);

CustomStmt::CustomStmt(std::string keyword, ExprPtr expr, StmtPtr suite)
    : Stmt(), keyword(std::move(keyword)), expr(std::move(expr)),
      suite(std::move(suite)) {}
CustomStmt::CustomStmt(const CustomStmt &amp;stmt)
    : Stmt(stmt), keyword(stmt.keyword), expr(ast::clone(stmt.expr)),
      suite(ast::clone(stmt.suite)) {}
std::string CustomStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  return format("(custom-{} {}{}{})", keyword,
                expr ? format(" #:expr {}", expr-&gt;toString()) : "", pad,
                suite ? suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1) : "");
}
ACCEPT_IMPL(CustomStmt, ASTVisitor);

AssignMemberStmt::AssignMemberStmt(ExprPtr lhs, std::string member, ExprPtr rhs)
    : Stmt(), lhs(std::move(lhs)), member(std::move(member)), rhs(std::move(rhs)) {}
AssignMemberStmt::AssignMemberStmt(const AssignMemberStmt &amp;stmt)
    : Stmt(stmt), lhs(ast::clone(stmt.lhs)), member(stmt.member),
      rhs(ast::clone(stmt.rhs)) {}
std::string AssignMemberStmt::toString(int) const {
  return format("(assign-member {} {} {})", lhs-&gt;toString(), member, rhs-&gt;toString());
}
ACCEPT_IMPL(AssignMemberStmt, ASTVisitor);

CommentStmt::CommentStmt(std::string comment) : Stmt(), comment(std::move(comment)) {}
std::string CommentStmt::toString(int) const {
  return format("(comment \"{}\")", comment);
}
ACCEPT_IMPL(CommentStmt, ASTVisitor);

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.467">void Stmt::validate() const {}

SuiteStmt::SuiteStmt(std::vector&lt;StmtPtr&gt; stmts) : Stmt() {
  for (auto &amp;s : stmts)
    flatten(std::move(s), this-&gt;stmts);
}
</t>
<t tx="ekr.20230509083243.468">SuiteStmt::SuiteStmt(const SuiteStmt &amp;stmt)
    : Stmt(stmt), stmts(ast::clone(stmt.stmts)) {}
std::string SuiteStmt::toString(int indent) const {
  std::string pad = indent &gt;= 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::string s;
  for (int i = 0; i &lt; stmts.size(); i++)
    if (stmts[i]) {
      auto is = stmts[i]-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1);
      if (stmts[i]-&gt;done)
        is.insert(findStar(is), "*");
      s += (i ? pad : "") + is;
    }
  return format("(suite{})", s.empty() ? s : " " + pad + s);
}
ACCEPT_IMPL(SuiteStmt, ASTVisitor);
</t>
<t tx="ekr.20230509083243.469">void SuiteStmt::flatten(const StmtPtr &amp;s, std::vector&lt;StmtPtr&gt; &amp;stmts) {
  if (!s)
    return;
  if (!s-&gt;getSuite()) {
    stmts.push_back(s);
  } else {
    for (auto &amp;ss : s-&gt;getSuite()-&gt;stmts)
      stmts.push_back(ss);
  }
}
</t>
<t tx="ekr.20230509083243.47">@path C:/Repos/codon/codon/cir/transform/pythonic/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/cir/transform/pass.h"

namespace codon {
namespace ir {
namespace transform {
namespace pythonic {

@others
} // namespace pythonic
} // namespace transform
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.470">StmtPtr *SuiteStmt::lastInBlock() {
  if (stmts.empty())
    return nullptr;
  if (auto s = stmts.back()-&gt;getSuite()) {
    auto l = s-&gt;lastInBlock();
    if (l)
      return l;
  }
  return &amp;(stmts.back());
}

std::string BreakStmt::toString(int) const { return "(break)"; }
ACCEPT_IMPL(BreakStmt, ASTVisitor);

std::string ContinueStmt::toString(int) const { return "(continue)"; }
ACCEPT_IMPL(ContinueStmt, ASTVisitor);

ExprStmt::ExprStmt(ExprPtr expr) : Stmt(), expr(std::move(expr)) {}
ExprStmt::ExprStmt(const ExprStmt &amp;stmt) : Stmt(stmt), expr(ast::clone(stmt.expr)) {}
std::string ExprStmt::toString(int) const {
  return format("(expr {})", expr-&gt;toString());
}
ACCEPT_IMPL(ExprStmt, ASTVisitor);

AssignStmt::AssignStmt(ExprPtr lhs, ExprPtr rhs, ExprPtr type)
    : Stmt(), lhs(std::move(lhs)), rhs(std::move(rhs)), type(std::move(type)),
      update(Assign) {}
AssignStmt::AssignStmt(const AssignStmt &amp;stmt)
    : Stmt(stmt), lhs(ast::clone(stmt.lhs)), rhs(ast::clone(stmt.rhs)),
      type(ast::clone(stmt.type)), update(stmt.update) {}
std::string AssignStmt::toString(int) const {
  return format("({} {}{}{})", update != Assign ? "update" : "assign", lhs-&gt;toString(),
                rhs ? " " + rhs-&gt;toString() : "",
                type ? format(" #:type {}", type-&gt;toString()) : "");
}
ACCEPT_IMPL(AssignStmt, ASTVisitor);

DelStmt::DelStmt(ExprPtr expr) : Stmt(), expr(std::move(expr)) {}
DelStmt::DelStmt(const DelStmt &amp;stmt) : Stmt(stmt), expr(ast::clone(stmt.expr)) {}
std::string DelStmt::toString(int) const {
  return format("(del {})", expr-&gt;toString());
}
ACCEPT_IMPL(DelStmt, ASTVisitor);

PrintStmt::PrintStmt(std::vector&lt;ExprPtr&gt; items, bool isInline)
    : Stmt(), items(std::move(items)), isInline(isInline) {}
PrintStmt::PrintStmt(const PrintStmt &amp;stmt)
    : Stmt(stmt), items(ast::clone(stmt.items)), isInline(stmt.isInline) {}
std::string PrintStmt::toString(int) const {
  return format("(print {}{})", isInline ? "#:inline " : "", combine(items));
}
ACCEPT_IMPL(PrintStmt, ASTVisitor);

ReturnStmt::ReturnStmt(ExprPtr expr) : Stmt(), expr(std::move(expr)) {}
ReturnStmt::ReturnStmt(const ReturnStmt &amp;stmt)
    : Stmt(stmt), expr(ast::clone(stmt.expr)) {}
std::string ReturnStmt::toString(int) const {
  return expr ? format("(return {})", expr-&gt;toString()) : "(return)";
}
ACCEPT_IMPL(ReturnStmt, ASTVisitor);

YieldStmt::YieldStmt(ExprPtr expr) : Stmt(), expr(std::move(expr)) {}
YieldStmt::YieldStmt(const YieldStmt &amp;stmt) : Stmt(stmt), expr(ast::clone(stmt.expr)) {}
std::string YieldStmt::toString(int) const {
  return expr ? format("(yield {})", expr-&gt;toString()) : "(yield)";
}
ACCEPT_IMPL(YieldStmt, ASTVisitor);

AssertStmt::AssertStmt(ExprPtr expr, ExprPtr message)
    : Stmt(), expr(std::move(expr)), message(std::move(message)) {}
AssertStmt::AssertStmt(const AssertStmt &amp;stmt)
    : Stmt(stmt), expr(ast::clone(stmt.expr)), message(ast::clone(stmt.message)) {}
std::string AssertStmt::toString(int) const {
  return format("(assert {}{})", expr-&gt;toString(), message ? message-&gt;toString() : "");
}
ACCEPT_IMPL(AssertStmt, ASTVisitor);

WhileStmt::WhileStmt(ExprPtr cond, StmtPtr suite, StmtPtr elseSuite)
    : Stmt(), cond(std::move(cond)), suite(std::move(suite)),
      elseSuite(std::move(elseSuite)) {}
WhileStmt::WhileStmt(const WhileStmt &amp;stmt)
    : Stmt(stmt), cond(ast::clone(stmt.cond)), suite(ast::clone(stmt.suite)),
      elseSuite(ast::clone(stmt.elseSuite)) {}
std::string WhileStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  if (elseSuite &amp;&amp; elseSuite-&gt;firstInBlock())
    return format("(while-else {}{}{}{}{})", cond-&gt;toString(), pad,
                  suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1), pad,
                  elseSuite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1));
  else
    return format("(while {}{}{})", cond-&gt;toString(), pad,
                  suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1));
}
ACCEPT_IMPL(WhileStmt, ASTVisitor);

ForStmt::ForStmt(ExprPtr var, ExprPtr iter, StmtPtr suite, StmtPtr elseSuite,
                 ExprPtr decorator, std::vector&lt;CallExpr::Arg&gt; ompArgs)
    : Stmt(), var(std::move(var)), iter(std::move(iter)), suite(std::move(suite)),
      elseSuite(std::move(elseSuite)), decorator(std::move(decorator)),
      ompArgs(std::move(ompArgs)), wrapped(false) {}
ForStmt::ForStmt(const ForStmt &amp;stmt)
    : Stmt(stmt), var(ast::clone(stmt.var)), iter(ast::clone(stmt.iter)),
      suite(ast::clone(stmt.suite)), elseSuite(ast::clone(stmt.elseSuite)),
      decorator(ast::clone(stmt.decorator)), ompArgs(ast::clone_nop(stmt.ompArgs)),
      wrapped(stmt.wrapped) {}
std::string ForStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::string attr;
  if (decorator)
    attr += " " + decorator-&gt;toString();
  if (!attr.empty())
    attr = " #:attr" + attr;
  if (elseSuite &amp;&amp; elseSuite-&gt;firstInBlock())
    return format("(for-else {} {}{}{}{}{}{})", var-&gt;toString(), iter-&gt;toString(), attr,
                  pad, suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1), pad,
                  elseSuite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1));
  else
    return format("(for {} {}{}{}{})", var-&gt;toString(), iter-&gt;toString(), attr, pad,
                  suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1));
}
ACCEPT_IMPL(ForStmt, ASTVisitor);

IfStmt::IfStmt(ExprPtr cond, StmtPtr ifSuite, StmtPtr elseSuite)
    : Stmt(), cond(std::move(cond)), ifSuite(std::move(ifSuite)),
      elseSuite(std::move(elseSuite)) {}
IfStmt::IfStmt(const IfStmt &amp;stmt)
    : Stmt(stmt), cond(ast::clone(stmt.cond)), ifSuite(ast::clone(stmt.ifSuite)),
      elseSuite(ast::clone(stmt.elseSuite)) {}
std::string IfStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  return format("(if {}{}{}{})", cond-&gt;toString(), pad,
                ifSuite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1),
                elseSuite
                    ? pad + elseSuite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1)
                    : "");
}
ACCEPT_IMPL(IfStmt, ASTVisitor);

MatchStmt::MatchCase MatchStmt::MatchCase::clone() const {
  return {ast::clone(pattern), ast::clone(guard), ast::clone(suite)};
}

MatchStmt::MatchStmt(ExprPtr what, std::vector&lt;MatchStmt::MatchCase&gt; cases)
    : Stmt(), what(std::move(what)), cases(std::move(cases)) {}
MatchStmt::MatchStmt(const MatchStmt &amp;stmt)
    : Stmt(stmt), what(ast::clone(stmt.what)), cases(ast::clone_nop(stmt.cases)) {}
std::string MatchStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::string padExtra = indent &gt; 0 ? std::string(INDENT_SIZE, ' ') : "";
  std::vector&lt;std::string&gt; s;
  for (auto &amp;c : cases)
    s.push_back(format("(case {}{}{}{})", c.pattern-&gt;toString(),
                       c.guard ? " #:guard " + c.guard-&gt;toString() : "", pad + padExtra,
                       c.suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1 * 2)));
  return format("(match {}{}{})", what-&gt;toString(), pad, join(s, pad));
}
ACCEPT_IMPL(MatchStmt, ASTVisitor);

ImportStmt::ImportStmt(ExprPtr from, ExprPtr what, std::vector&lt;Param&gt; args, ExprPtr ret,
                       std::string as, size_t dots, bool isFunction)
    : Stmt(), from(std::move(from)), what(std::move(what)), as(std::move(as)),
      dots(dots), args(std::move(args)), ret(std::move(ret)), isFunction(isFunction) {
  validate();
}
ImportStmt::ImportStmt(const ImportStmt &amp;stmt)
    : Stmt(stmt), from(ast::clone(stmt.from)), what(ast::clone(stmt.what)), as(stmt.as),
      dots(stmt.dots), args(ast::clone_nop(stmt.args)), ret(ast::clone(stmt.ret)),
      isFunction(stmt.isFunction) {}
std::string ImportStmt::toString(int) const {
  std::vector&lt;std::string&gt; va;
  for (auto &amp;a : args)
    va.push_back(a.toString());
  return format("(import {}{}{}{}{}{})", from-&gt;toString(),
                as.empty() ? "" : format(" #:as '{}", as),
                what ? format(" #:what {}", what-&gt;toString()) : "",
                dots ? format(" #:dots {}", dots) : "",
                va.empty() ? "" : format(" #:args ({})", join(va)),
                ret ? format(" #:ret {}", ret-&gt;toString()) : "");
}
</t>
<t tx="ekr.20230509083243.471">void ImportStmt::validate() const {
  if (from) {
    Expr *e = from.get();
    while (auto d = e-&gt;getDot())
      e = d-&gt;expr.get();
    if (!from-&gt;isId("C") &amp;&amp; !from-&gt;isId("python")) {
      if (!e-&gt;getId())
        E(Error::IMPORT_IDENTIFIER, e);
      if (!args.empty())
        E(Error::IMPORT_FN, args[0]);
      if (ret)
        E(Error::IMPORT_FN, ret);
      if (what &amp;&amp; !what-&gt;getId())
        E(Error::IMPORT_IDENTIFIER, what);
    }
    if (!isFunction &amp;&amp; !args.empty())
      E(Error::IMPORT_FN, args[0]);
  }
}
</t>
<t tx="ekr.20230509083243.472">ACCEPT_IMPL(ImportStmt, ASTVisitor);

TryStmt::Catch TryStmt::Catch::clone() const {
  return {var, ast::clone(exc), ast::clone(suite)};
}

TryStmt::TryStmt(StmtPtr suite, std::vector&lt;Catch&gt; catches, StmtPtr finally)
    : Stmt(), suite(std::move(suite)), catches(std::move(catches)),
      finally(std::move(finally)) {}
TryStmt::TryStmt(const TryStmt &amp;stmt)
    : Stmt(stmt), suite(ast::clone(stmt.suite)), catches(ast::clone_nop(stmt.catches)),
      finally(ast::clone(stmt.finally)) {}
std::string TryStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::string padExtra = indent &gt; 0 ? std::string(INDENT_SIZE, ' ') : "";
  std::vector&lt;std::string&gt; s;
  for (auto &amp;i : catches)
    s.push_back(
        format("(catch {}{}{}{})", !i.var.empty() ? format("#:var '{}", i.var) : "",
               i.exc ? format(" #:exc {}", i.exc-&gt;toString()) : "", pad + padExtra,
               i.suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1 * 2)));
  return format(
      "(try{}{}{}{}{})", pad, suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1),
      pad, join(s, pad),
      finally ? format("{}{}", pad,
                       finally-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1))
              : "");
}
ACCEPT_IMPL(TryStmt, ASTVisitor);

ThrowStmt::ThrowStmt(ExprPtr expr, bool transformed)
    : Stmt(), expr(std::move(expr)), transformed(transformed) {}
ThrowStmt::ThrowStmt(const ThrowStmt &amp;stmt)
    : Stmt(stmt), expr(ast::clone(stmt.expr)), transformed(stmt.transformed) {}
std::string ThrowStmt::toString(int) const {
  return format("(throw{})", expr ? " " + expr-&gt;toString() : "");
}
ACCEPT_IMPL(ThrowStmt, ASTVisitor);

GlobalStmt::GlobalStmt(std::string var, bool nonLocal)
    : Stmt(), var(std::move(var)), nonLocal(nonLocal) {}
std::string GlobalStmt::toString(int) const {
  return format("({} '{})", nonLocal ? "nonlocal" : "global", var);
}
ACCEPT_IMPL(GlobalStmt, ASTVisitor);

Attr::Attr(const std::vector&lt;std::string&gt; &amp;attrs)
    : module(), parentClass(), isAttribute(false) {
  for (auto &amp;a : attrs)
    set(a);
}
void Attr::set(const std::string &amp;attr) { customAttr.insert(attr); }
void Attr::unset(const std::string &amp;attr) { customAttr.erase(attr); }
bool Attr::has(const std::string &amp;attr) const { return in(customAttr, attr); }

const std::string Attr::LLVM = "llvm";
const std::string Attr::Python = "python";
const std::string Attr::Atomic = "atomic";
const std::string Attr::Property = "property";
const std::string Attr::StaticMethod = "staticmethod";
const std::string Attr::Attribute = "__attribute__";
const std::string Attr::Internal = "__internal__";
const std::string Attr::ForceRealize = "__force__";
const std::string Attr::RealizeWithoutSelf =
    "std.internal.attributes.realize_without_self";
const std::string Attr::HiddenFromUser = "__hidden__";
const std::string Attr::C = "C";
const std::string Attr::CVarArg = ".__vararg__";
const std::string Attr::Method = ".__method__";
const std::string Attr::Capture = ".__capture__";
const std::string Attr::HasSelf = ".__hasself__";
const std::string Attr::Extend = "extend";
const std::string Attr::Tuple = "tuple";
const std::string Attr::Test = "std.internal.attributes.test";
const std::string Attr::Overload = "overload";
const std::string Attr::Export = "std.internal.attributes.export";

FunctionStmt::FunctionStmt(std::string name, ExprPtr ret, std::vector&lt;Param&gt; args,
                           StmtPtr suite, Attr attributes,
                           std::vector&lt;ExprPtr&gt; decorators)
    : Stmt(), name(std::move(name)), ret(std::move(ret)), args(std::move(args)),
      suite(std::move(suite)), attributes(std::move(attributes)),
      decorators(std::move(decorators)) {
  parseDecorators();
}
FunctionStmt::FunctionStmt(const FunctionStmt &amp;stmt)
    : Stmt(stmt), name(stmt.name), ret(ast::clone(stmt.ret)),
      args(ast::clone_nop(stmt.args)), suite(ast::clone(stmt.suite)),
      attributes(stmt.attributes), decorators(ast::clone(stmt.decorators)) {}
std::string FunctionStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::vector&lt;std::string&gt; as;
  for (auto &amp;a : args)
    as.push_back(a.toString());
  std::vector&lt;std::string&gt; dec, attr;
  for (auto &amp;a : decorators)
    if (a)
      dec.push_back(format("(dec {})", a-&gt;toString()));
  for (auto &amp;a : attributes.customAttr)
    attr.push_back(format("'{}'", a));
  return format("(fn '{} ({}){}{}{}{}{})", name, join(as, " "),
                ret ? " #:ret " + ret-&gt;toString() : "",
                dec.empty() ? "" : format(" (dec {})", join(dec, " ")),
                attr.empty() ? "" : format(" (attr {})", join(attr, " ")), pad,
                suite ? suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1)
                      : "(suite)");
}
</t>
<t tx="ekr.20230509083243.473">void FunctionStmt::validate() const {
  if (!ret &amp;&amp; (attributes.has(Attr::LLVM) || attributes.has(Attr::C)))
    E(Error::FN_LLVM, getSrcInfo());

  std::unordered_set&lt;std::string&gt; seenArgs;
  bool defaultsStarted = false, hasStarArg = false, hasKwArg = false;
  for (size_t ia = 0; ia &lt; args.size(); ia++) {
    auto &amp;a = args[ia];
    auto n = a.name;
    int stars = trimStars(n);
    if (stars == 2) {
      if (hasKwArg)
        E(Error::FN_MULTIPLE_ARGS, a);
      if (a.defaultValue)
        E(Error::FN_DEFAULT_STARARG, a.defaultValue);
      if (ia != args.size() - 1)
        E(Error::FN_LAST_KWARG, a);
      hasKwArg = true;
    } else if (stars == 1) {
      if (hasStarArg)
        E(Error::FN_MULTIPLE_ARGS, a);
      if (a.defaultValue)
        E(Error::FN_DEFAULT_STARARG, a.defaultValue);
      hasStarArg = true;
    }
    if (in(seenArgs, n))
      E(Error::FN_ARG_TWICE, a, n);
    seenArgs.insert(n);
    if (!a.defaultValue &amp;&amp; defaultsStarted &amp;&amp; !stars &amp;&amp; a.status == Param::Normal)
      E(Error::FN_DEFAULT, a, n);
    defaultsStarted |= bool(a.defaultValue);
    if (attributes.has(Attr::C)) {
      if (a.defaultValue)
        E(Error::FN_C_DEFAULT, a.defaultValue, n);
      if (stars != 1 &amp;&amp; !a.type)
        E(Error::FN_C_TYPE, a, n);
    }
  }
}
</t>
<t tx="ekr.20230509083243.474">ACCEPT_IMPL(FunctionStmt, ASTVisitor);
std::string FunctionStmt::signature() const {
  std::vector&lt;std::string&gt; s;
  for (auto &amp;a : args)
    s.push_back(a.type ? a.type-&gt;toString() : "-");
  return format("{}", join(s, ":"));
}
</t>
<t tx="ekr.20230509083243.475">bool FunctionStmt::hasAttr(const std::string &amp;attr) const {
  return attributes.has(attr);
}
</t>
<t tx="ekr.20230509083243.476">void FunctionStmt::parseDecorators() {
  std::vector&lt;ExprPtr&gt; newDecorators;
  for (auto &amp;d : decorators) {
    if (d-&gt;isId(Attr::Attribute)) {
      if (decorators.size() != 1)
        E(Error::FN_SINGLE_DECORATOR, decorators[1], Attr::Attribute);
      attributes.isAttribute = true;
    } else if (d-&gt;isId(Attr::LLVM)) {
      attributes.set(Attr::LLVM);
    } else if (d-&gt;isId(Attr::Python)) {
      if (decorators.size() != 1)
        E(Error::FN_SINGLE_DECORATOR, decorators[1], Attr::Python);
      attributes.set(Attr::Python);
    } else if (d-&gt;isId(Attr::Internal)) {
      attributes.set(Attr::Internal);
    } else if (d-&gt;isId(Attr::HiddenFromUser)) {
      attributes.set(Attr::HiddenFromUser);
    } else if (d-&gt;isId(Attr::Atomic)) {
      attributes.set(Attr::Atomic);
    } else if (d-&gt;isId(Attr::Property)) {
      attributes.set(Attr::Property);
    } else if (d-&gt;isId(Attr::StaticMethod)) {
      attributes.set(Attr::StaticMethod);
    } else if (d-&gt;isId(Attr::ForceRealize)) {
      attributes.set(Attr::ForceRealize);
    } else if (d-&gt;isId(Attr::C)) {
      attributes.set(Attr::C);
    } else {
      newDecorators.emplace_back(d);
    }
  }
  if (attributes.has(Attr::C)) {
    for (auto &amp;a : args) {
      if (a.name.size() &gt; 1 &amp;&amp; a.name[0] == '*' &amp;&amp; a.name[1] != '*')
        attributes.set(Attr::CVarArg);
    }
  }
  if (!args.empty() &amp;&amp; !args[0].type &amp;&amp; args[0].name == "self") {
    attributes.set(Attr::HasSelf);
  }
  decorators = newDecorators;
  validate();
}
</t>
<t tx="ekr.20230509083243.477">size_t FunctionStmt::getStarArgs() const {
  size_t i = 0;
  while (i &lt; args.size()) {
    if (startswith(args[i].name, "*") &amp;&amp; !startswith(args[i].name, "**"))
      break;
    i++;
  }
  return i;
}
size_t FunctionStmt::getKwStarArgs() const {
  size_t i = 0;
  while (i &lt; args.size()) {
    if (startswith(args[i].name, "**"))
      break;
    i++;
  }
  return i;
}
std::string FunctionStmt::getDocstr() {
  if (auto s = suite-&gt;firstInBlock()) {
    if (auto e = s-&gt;getExpr()) {
      if (auto ss = e-&gt;expr-&gt;getString())
        return ss-&gt;getValue();
    }
  }
  return "";
}

</t>
<t tx="ekr.20230509083243.478">// Search expression tree for a identifier
class IdSearchVisitor : public CallbackASTVisitor&lt;bool, bool&gt; {
  std::string what;
  bool result;

public:
  IdSearchVisitor(std::string what) : what(std::move(what)), result(false) {}
  @others
};

</t>
<t tx="ekr.20230509083243.479">bool transform(const std::shared_ptr&lt;Expr&gt; &amp;expr) override {
  if (result)
    return result;
  IdSearchVisitor v(what);
  if (expr)
    expr-&gt;accept(v);
  return result = v.result;
}
</t>
<t tx="ekr.20230509083243.48">/// Pass to optimize str1 + str2 + ...
class StrAdditionOptimization : public OperatorPass {
public:
  static const std::string KEY;
  std::string getKey() const override { return KEY; }
  void handle(CallInstr *v) override;
};

</t>
<t tx="ekr.20230509083243.480">bool transform(const std::shared_ptr&lt;Stmt&gt; &amp;stmt) override {
  if (result)
    return result;
  IdSearchVisitor v(what);
  if (stmt)
    stmt-&gt;accept(v);
  return result = v.result;
}
</t>
<t tx="ekr.20230509083243.481">void visit(IdExpr *expr) override {
  if (expr-&gt;value == what)
    result = true;
}
</t>
<t tx="ekr.20230509083243.482">/// Check if a function can be called with the given arguments.
/// See @c reorderNamedArgs for details.
std::unordered_set&lt;std::string&gt; FunctionStmt::getNonInferrableGenerics() {
  std::unordered_set&lt;std::string&gt; nonInferrableGenerics;
  for (auto &amp;a : args) {
    if (a.status == Param::Generic &amp;&amp; !a.defaultValue) {
      bool inferrable = false;
      for (auto &amp;b : args)
        if (b.type &amp;&amp; IdSearchVisitor(a.name).transform(b.type)) {
          inferrable = true;
          break;
        }
      if (ret &amp;&amp; IdSearchVisitor(a.name).transform(ret))
        inferrable = true;
      if (!inferrable)
        nonInferrableGenerics.insert(a.name);
    }
  }
  return nonInferrableGenerics;
}

ClassStmt::ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite,
                     std::vector&lt;ExprPtr&gt; decorators, std::vector&lt;ExprPtr&gt; baseClasses,
                     std::vector&lt;ExprPtr&gt; staticBaseClasses)
    : Stmt(), name(std::move(name)), args(std::move(args)), suite(std::move(suite)),
      decorators(std::move(decorators)),
</t>
<t tx="ekr.20230509083243.483">      staticBaseClasses(std::move(staticBaseClasses)) {
  for (auto &amp;b : baseClasses) {
    if (b-&gt;getIndex() &amp;&amp; b-&gt;getIndex()-&gt;expr-&gt;isId("Static")) {
      this-&gt;staticBaseClasses.push_back(b-&gt;getIndex()-&gt;index);
    } else {
      this-&gt;baseClasses.push_back(b);
    }
  }
  parseDecorators();
}
</t>
<t tx="ekr.20230509083243.484">ClassStmt::ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite,
                     Attr attr)
    : Stmt(), name(std::move(name)), args(std::move(args)), suite(std::move(suite)),
      attributes(std::move(attr)) {
  validate();
}
ClassStmt::ClassStmt(const ClassStmt &amp;stmt)
    : Stmt(stmt), name(stmt.name), args(ast::clone_nop(stmt.args)),
      suite(ast::clone(stmt.suite)), attributes(stmt.attributes),
      decorators(ast::clone(stmt.decorators)),
      baseClasses(ast::clone(stmt.baseClasses)),
</t>
<t tx="ekr.20230509083243.485">      staticBaseClasses(ast::clone(stmt.staticBaseClasses)) {}
std::string ClassStmt::toString(int indent) const {
  std::string pad = indent &gt; 0 ? ("\n" + std::string(indent + INDENT_SIZE, ' ')) : " ";
  std::vector&lt;std::string&gt; bases;
  for (auto &amp;b : baseClasses)
    bases.push_back(b-&gt;toString());
  for (auto &amp;b : staticBaseClasses)
    bases.push_back(fmt::format("(static {})", b-&gt;toString()));
  std::string as;
  for (int i = 0; i &lt; args.size(); i++)
    as += (i ? pad : "") + args[i].toString();
  std::vector&lt;std::string&gt; attr;
  for (auto &amp;a : decorators)
    attr.push_back(format("(dec {})", a-&gt;toString()));
  return format("(class '{}{}{}{}{}{})", name,
                bases.empty() ? "" : format(" (bases {})", join(bases, " ")),
                attr.empty() ? "" : format(" (attr {})", join(attr, " ")),
                as.empty() ? as : pad + as, pad,
                suite ? suite-&gt;toString(indent &gt;= 0 ? indent + INDENT_SIZE : -1)
                      : "(suite)");
}
</t>
<t tx="ekr.20230509083243.486">void ClassStmt::validate() const {
  std::unordered_set&lt;std::string&gt; seen;
  if (attributes.has(Attr::Extend) &amp;&amp; !args.empty())
    E(Error::CLASS_EXTENSION, args[0]);
  if (attributes.has(Attr::Extend) &amp;&amp;
      !(baseClasses.empty() &amp;&amp; staticBaseClasses.empty()))
    E(Error::CLASS_EXTENSION,
      baseClasses.empty() ? staticBaseClasses[0] : baseClasses[0]);
  for (auto &amp;a : args) {
    if (!a.type &amp;&amp; !a.defaultValue)
      E(Error::CLASS_MISSING_TYPE, a, a.name);
    if (in(seen, a.name))
      E(Error::CLASS_ARG_TWICE, a, a.name);
    seen.insert(a.name);
  }
}
</t>
<t tx="ekr.20230509083243.487">ACCEPT_IMPL(ClassStmt, ASTVisitor);
bool ClassStmt::isRecord() const { return hasAttr(Attr::Tuple); }
bool ClassStmt::hasAttr(const std::string &amp;attr) const { return attributes.has(attr); }
</t>
<t tx="ekr.20230509083243.488">void ClassStmt::parseDecorators() {
  // @tuple(init=, repr=, eq=, order=, hash=, pickle=, container=, python=, add=,
  // internal=...)
  // @dataclass(...)
  // @extend

  std::map&lt;std::string, bool&gt; tupleMagics = {
      {"new", true},           {"repr", false},    {"hash", false},
      {"eq", false},           {"ne", false},      {"lt", false},
      {"le", false},           {"gt", false},      {"ge", false},
      {"pickle", true},        {"unpickle", true}, {"to_py", false},
      {"from_py", false},      {"iter", false},    {"getitem", false},
      {"len", false},          {"to_gpu", false},  {"from_gpu", false},
      {"from_gpu_new", false}, {"tuplesize", true}};

  for (auto &amp;d : decorators) {
    if (d-&gt;isId("deduce")) {
      attributes.customAttr.insert("deduce");
    } else if (d-&gt;isId("__notuple__")) {
      attributes.customAttr.insert("__notuple__");
    } else if (auto c = d-&gt;getCall()) {
      if (c-&gt;expr-&gt;isId(Attr::Tuple)) {
        attributes.set(Attr::Tuple);
        for (auto &amp;m : tupleMagics)
          m.second = true;
      } else if (!c-&gt;expr-&gt;isId("dataclass")) {
        E(Error::CLASS_BAD_DECORATOR, c-&gt;expr);
      } else if (attributes.has(Attr::Tuple)) {
        E(Error::CLASS_CONFLICT_DECORATOR, c, "dataclass", Attr::Tuple);
      }
      for (auto &amp;a : c-&gt;args) {
        auto b = CAST(a.value, BoolExpr);
        if (!b)
          E(Error::CLASS_NONSTATIC_DECORATOR, a);
        char val = char(b-&gt;value);
        if (a.name == "init") {
          tupleMagics["new"] = val;
        } else if (a.name == "repr") {
          tupleMagics["repr"] = val;
        } else if (a.name == "eq") {
          tupleMagics["eq"] = tupleMagics["ne"] = val;
        } else if (a.name == "order") {
          tupleMagics["lt"] = tupleMagics["le"] = tupleMagics["gt"] =
              tupleMagics["ge"] = val;
        } else if (a.name == "hash") {
          tupleMagics["hash"] = val;
        } else if (a.name == "pickle") {
          tupleMagics["pickle"] = tupleMagics["unpickle"] = val;
        } else if (a.name == "python") {
          tupleMagics["to_py"] = tupleMagics["from_py"] = val;
        } else if (a.name == "gpu") {
          tupleMagics["to_gpu"] = tupleMagics["from_gpu"] =
              tupleMagics["from_gpu_new"] = val;
        } else if (a.name == "container") {
          tupleMagics["iter"] = tupleMagics["getitem"] = val;
        } else {
          E(Error::CLASS_BAD_DECORATOR_ARG, a);
        }
      }
    } else if (d-&gt;isId(Attr::Tuple)) {
      if (attributes.has(Attr::Tuple))
        E(Error::CLASS_MULTIPLE_DECORATORS, d, Attr::Tuple);
      attributes.set(Attr::Tuple);
      for (auto &amp;m : tupleMagics) {
        m.second = true;
      }
    } else if (d-&gt;isId(Attr::Extend)) {
      attributes.set(Attr::Extend);
      if (decorators.size() != 1)
        E(Error::CLASS_SINGLE_DECORATOR, decorators[decorators[0] == d], Attr::Extend);
    } else if (d-&gt;isId(Attr::Internal)) {
      attributes.set(Attr::Internal);
    } else {
      E(Error::CLASS_BAD_DECORATOR, d);
    }
  }
  if (startswith(name, TYPE_TUPLE))
    tupleMagics["contains"] = true;
  if (attributes.has("deduce"))
    tupleMagics["new"] = false;
  if (!attributes.has(Attr::Tuple)) {
    tupleMagics["init"] = tupleMagics["new"];
    tupleMagics["new"] = tupleMagics["raw"] = true;
    tupleMagics["len"] = false;
  }
  if (startswith(name, TYPE_TUPLE)) {
    tupleMagics["add"] = true;
    tupleMagics["mul"] = true;
  } else {
    tupleMagics["dict"] = true;
  }
  // Internal classes do not get any auto-generated members.
  attributes.magics.clear();
  if (!attributes.has(Attr::Internal)) {
    for (auto &amp;m : tupleMagics)
      if (m.second)
        attributes.magics.insert(m.first);
  }

  validate();
}
</t>
<t tx="ekr.20230509083243.489">bool ClassStmt::isClassVar(const Param &amp;p) {
  if (!p.defaultValue)
    return false;
  if (!p.type)
    return true;
  if (auto i = p.type-&gt;getIndex())
    return i-&gt;expr-&gt;isId("ClassVar");
  return false;
}
</t>
<t tx="ekr.20230509083243.49"></t>
<t tx="ekr.20230509083243.490">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/expr.h"
#include "codon/parser/ast/types.h"
#include "codon/parser/common.h"

namespace codon::ast {

#define ACCEPT(X)                                                                      \
  using Stmt::toString;                                                                \
  StmtPtr clone() const override;                                                      \
  void accept(X &amp;visitor) override

// Forward declarations
struct ASTVisitor;
struct AssignStmt;
struct ClassStmt;
struct ExprStmt;
struct SuiteStmt;
struct FunctionStmt;

/**
 * A Seq AST statement.
 * Each AST statement is intended to be instantiated as a shared_ptr.
 */
struct Stmt : public codon::SrcObject {
  using base_type = Stmt;

  /// Flag that indicates if all types in a statement are inferred (i.e. if a
  /// type-checking procedure was successful).
  bool done;
  /// Statement age.
  int age;

public:
  Stmt();
  Stmt(const Stmt &amp;s) = default;
  explicit Stmt(const codon::SrcInfo &amp;s);

  /// Convert a node to an S-expression.
  std::string toString() const;
  virtual std::string toString(int indent) const = 0;
  /// Validate a node. Throw ParseASTException if a node is not valid.
  void validate() const;
  /// Deep copy a node.
  virtual std::shared_ptr&lt;Stmt&gt; clone() const = 0;
  /// Accept an AST visitor.
  virtual void accept(ASTVisitor &amp;) = 0;

  /// Allow pretty-printing to C++ streams.
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const Stmt &amp;stmt) {
    return out &lt;&lt; stmt.toString();
  }

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual AssignStmt *getAssign() { return nullptr; }
  virtual ClassStmt *getClass() { return nullptr; }
  virtual ExprStmt *getExpr() { return nullptr; }
  virtual SuiteStmt *getSuite() { return nullptr; }
  virtual FunctionStmt *getFunction() { return nullptr; }

  /// @return the first statement in a suite; if a statement is not a suite, returns the
  /// statement itself
  virtual Stmt *firstInBlock() { return this; }

  bool isDone() const { return done; }
  void setDone() { done = true; }
};
using StmtPtr = std::shared_ptr&lt;Stmt&gt;;

/// Suite (block of statements) statement (stmt...).
/// @li a = 5; foo(1)
struct SuiteStmt : public Stmt {
  using Stmt::Stmt;

  std::vector&lt;StmtPtr&gt; stmts;

  /// These constructors flattens the provided statement vector (see flatten() below).
  explicit SuiteStmt(std::vector&lt;StmtPtr&gt; stmts = {});
@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.491">  /// Convenience constructor
  template &lt;typename... Ts&gt;
  SuiteStmt(StmtPtr stmt, Ts... stmts) : stmts({stmt, stmts...}) {}
  SuiteStmt(const SuiteStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  SuiteStmt *getSuite() override { return this; }
  Stmt *firstInBlock() override {
    return stmts.empty() ? nullptr : stmts[0]-&gt;firstInBlock();
  }
</t>
<t tx="ekr.20230509083243.492">  StmtPtr *lastInBlock();

  /// Flatten all nested SuiteStmt objects that do not own a block in the statement
  /// vector. This is shallow flattening.
  static void flatten(const StmtPtr &amp;s, std::vector&lt;StmtPtr&gt; &amp;stmts);
};

/// Break statement.
/// @li break
struct BreakStmt : public Stmt {
  BreakStmt() = default;
  BreakStmt(const BreakStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Continue statement.
/// @li continue
struct ContinueStmt : public Stmt {
  ContinueStmt() = default;
  ContinueStmt(const ContinueStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Expression statement (expr).
/// @li 3 + foo()
struct ExprStmt : public Stmt {
  ExprPtr expr;

  explicit ExprStmt(ExprPtr expr);
  ExprStmt(const ExprStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  ExprStmt *getExpr() override { return this; }
};

/// Assignment statement (lhs: type = rhs).
/// @li a = 5
/// @li a: Optional[int] = 5
/// @li a, b, c = 5, *z
struct AssignStmt : public Stmt {
  ExprPtr lhs, rhs, type;

  AssignStmt(ExprPtr lhs, ExprPtr rhs, ExprPtr type = nullptr);
  AssignStmt(const AssignStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);

  AssignStmt *getAssign() override { return this; }

  bool isUpdate() const { return update != Assign; }
  bool isAtomicUpdate() const { return update == UpdateAtomic; }
  void setUpdate() { update = Update; }
  void setAtomicUpdate() { update = UpdateAtomic; }

private:
  enum { Assign, Update, UpdateAtomic } update;
};

/// Deletion statement (del expr).
/// @li del a
/// @li del a[5]
struct DelStmt : public Stmt {
  ExprPtr expr;

  explicit DelStmt(ExprPtr expr);
  DelStmt(const DelStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Print statement (print expr).
/// @li print a, b
struct PrintStmt : public Stmt {
  std::vector&lt;ExprPtr&gt; items;
  /// True if there is a dangling comma after print: print a,
  bool isInline;

  explicit PrintStmt(std::vector&lt;ExprPtr&gt; items, bool isInline);
  PrintStmt(const PrintStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Return statement (return expr).
/// @li return
/// @li return a
struct ReturnStmt : public Stmt {
  /// nullptr if this is an empty return/yield statements.
  ExprPtr expr;

  explicit ReturnStmt(ExprPtr expr = nullptr);
  ReturnStmt(const ReturnStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Yield statement (yield expr).
/// @li yield
/// @li yield a
struct YieldStmt : public Stmt {
  /// nullptr if this is an empty return/yield statements.
  ExprPtr expr;

  explicit YieldStmt(ExprPtr expr = nullptr);
  YieldStmt(const YieldStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Assert statement (assert expr).
/// @li assert a
/// @li assert a, "Message"
struct AssertStmt : public Stmt {
  ExprPtr expr;
  /// nullptr if there is no message.
  ExprPtr message;

  explicit AssertStmt(ExprPtr expr, ExprPtr message = nullptr);
  AssertStmt(const AssertStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// While loop statement (while cond: suite; else: elseSuite).
/// @li while True: print
/// @li while True: break
///          else: print
struct WhileStmt : public Stmt {
  ExprPtr cond;
  StmtPtr suite;
  /// nullptr if there is no else suite.
  StmtPtr elseSuite;
  /// Set if a while loop is used to emulate goto statement
  /// (as `while gotoVar: ...`).
  std::string gotoVar = "";

  WhileStmt(ExprPtr cond, StmtPtr suite, StmtPtr elseSuite = nullptr);
  WhileStmt(const WhileStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// For loop statement (for var in iter: suite; else elseSuite).
/// @li for a, b in c: print
/// @li for i in j: break
///          else: print
struct ForStmt : public Stmt {
  ExprPtr var;
  ExprPtr iter;
  StmtPtr suite;
  StmtPtr elseSuite;
  ExprPtr decorator;
  std::vector&lt;CallExpr::Arg&gt; ompArgs;

  /// Indicates if iter was wrapped with __iter__() call.
  bool wrapped;

  ForStmt(ExprPtr var, ExprPtr iter, StmtPtr suite, StmtPtr elseSuite = nullptr,
          ExprPtr decorator = nullptr, std::vector&lt;CallExpr::Arg&gt; ompArgs = {});
  ForStmt(const ForStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// If block statement (if cond: suite; (elif cond: suite)...).
/// @li if a: foo()
/// @li if a: foo()
///          elif b: bar()
/// @li if a: foo()
///          elif b: bar()
///          else: baz()
struct IfStmt : public Stmt {
  ExprPtr cond;
  /// elseSuite can be nullptr (if no else is found).
  StmtPtr ifSuite, elseSuite;

  IfStmt(ExprPtr cond, StmtPtr ifSuite, StmtPtr elseSuite = nullptr);
  IfStmt(const IfStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Match statement (match what: (case pattern: case)...).
/// @li match a:
///          case 1: print
///          case _: pass
struct MatchStmt : public Stmt {
  struct MatchCase {
    ExprPtr pattern;
    ExprPtr guard;
    StmtPtr suite;

    MatchCase clone() const;
  };
  ExprPtr what;
  std::vector&lt;MatchCase&gt; cases;

  MatchStmt(ExprPtr what, std::vector&lt;MatchCase&gt; cases);
  MatchStmt(const MatchStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Import statement.
/// This node describes various kinds of import statements:
///  - from from import what (as as)
///  - import what (as as)
///  - from c import what(args...) (-&gt; ret) (as as)
///  - from .(dots...)from import what (as as)
/// @li import a
/// @li from b import a
/// @li from ...b import a as ai
/// @li from c import foo(int) -&gt; int as bar
/// @li from python.numpy import array
/// @li from python import numpy.array(int) -&gt; int as na
struct ImportStmt : public Stmt {
  ExprPtr from, what;
  std::string as;
  /// Number of dots in a relative import (e.g. dots is 3 for "from ...foo").
  size_t dots;
  /// Function argument types for C imports.
  std::vector&lt;Param&gt; args;
  /// Function return type for C imports.
  ExprPtr ret;
  /// Set if this is a function C import (not variable import)
  bool isFunction;

  ImportStmt(ExprPtr from, ExprPtr what, std::vector&lt;Param&gt; args = {},
             ExprPtr ret = nullptr, std::string as = "", size_t dots = 0,
             bool isFunction = true);
  ImportStmt(const ImportStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);
};

/// Try-catch statement (try: suite; (catch var (as exc): suite)...; finally: finally).
/// @li: try: a
///           catch e: pass
///           catch e as Exc: pass
///           catch: pass
///           finally: print
struct TryStmt : public Stmt {
  struct Catch {
    /// empty string if a catch is unnamed.
    std::string var;
    /// nullptr if there is no explicit exception type.
    ExprPtr exc;
    StmtPtr suite;

    Catch clone() const;
  };

  StmtPtr suite;
  std::vector&lt;Catch&gt; catches;
  /// nullptr if there is no finally block.
  StmtPtr finally;

  TryStmt(StmtPtr suite, std::vector&lt;Catch&gt; catches, StmtPtr finally = nullptr);
  TryStmt(const TryStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Throw statement (raise expr).
/// @li: raise a
struct ThrowStmt : public Stmt {
  ExprPtr expr;
  // True if a statement was transformed during type-checking stage
  // (to avoid setting up ExcHeader multiple times).
  bool transformed;

  explicit ThrowStmt(ExprPtr expr, bool transformed = false);
  ThrowStmt(const ThrowStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Global variable statement (global var).
/// @li: global a
struct GlobalStmt : public Stmt {
  std::string var;
  bool nonLocal;

  explicit GlobalStmt(std::string var, bool nonLocal = false);
  GlobalStmt(const GlobalStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

struct Attr {
  // Toplevel attributes
  const static std::string LLVM;
  const static std::string Python;
  const static std::string Atomic;
  const static std::string Property;
  const static std::string StaticMethod;
  const static std::string Attribute;
  const static std::string C;
  // Internal attributes
  const static std::string Internal;
  const static std::string HiddenFromUser;
  const static std::string ForceRealize;
  const static std::string RealizeWithoutSelf; // not internal
  // Compiler-generated attributes
  const static std::string CVarArg;
  const static std::string Method;
  const static std::string Capture;
  const static std::string HasSelf;
  // Class attributes
  const static std::string Extend;
  const static std::string Tuple;
  // Standard library attributes
  const static std::string Test;
  const static std::string Overload;
  const static std::string Export;
  // Function module
  std::string module;
  // Parent class (set for methods only)
  std::string parentClass;
  // True if a function is decorated with __attribute__
  bool isAttribute;

  std::set&lt;std::string&gt; magics;

  // Set of attributes
  std::set&lt;std::string&gt; customAttr;

  explicit Attr(const std::vector&lt;std::string&gt; &amp;attrs = std::vector&lt;std::string&gt;());
  void set(const std::string &amp;attr);
  void unset(const std::string &amp;attr);
  bool has(const std::string &amp;attr) const;
};

/// Function statement (@(attributes...) def name[funcs...](args...) -&gt; ret: suite).
/// @li: @decorator
///           def foo[T=int, U: int](a, b: int = 0) -&gt; list[T]: pass
struct FunctionStmt : public Stmt {
  std::string name;
  /// nullptr if return type is not specified.
  ExprPtr ret;
  std::vector&lt;Param&gt; args;
  StmtPtr suite;
  Attr attributes;
  std::vector&lt;ExprPtr&gt; decorators;

  FunctionStmt(std::string name, ExprPtr ret, std::vector&lt;Param&gt; args, StmtPtr suite,
               Attr attributes = Attr(), std::vector&lt;ExprPtr&gt; decorators = {});
  FunctionStmt(const FunctionStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);

  /// @return a function signature that consists of generics and arguments in a
  /// S-expression form.
  /// @li (T U (int 0))
  std::string signature() const;
  bool hasAttr(const std::string &amp;attr) const;
  void parseDecorators();

  size_t getStarArgs() const;
  size_t getKwStarArgs() const;

  FunctionStmt *getFunction() override { return this; }
  std::string getDocstr();
  std::unordered_set&lt;std::string&gt; getNonInferrableGenerics();
};

/// Class statement (@(attributes...) class name[generics...]: args... ; suite).
/// @li: @type
///           class F[T]:
///              m: T
///              def __new__() -&gt; F[T]: ...
struct ClassStmt : public Stmt {
  std::string name;
  std::vector&lt;Param&gt; args;
  StmtPtr suite;
  Attr attributes;
  std::vector&lt;ExprPtr&gt; decorators;
  std::vector&lt;ExprPtr&gt; baseClasses;
  std::vector&lt;ExprPtr&gt; staticBaseClasses;

  ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite,
            std::vector&lt;ExprPtr&gt; decorators = {}, std::vector&lt;ExprPtr&gt; baseClasses = {},
            std::vector&lt;ExprPtr&gt; staticBaseClasses = {});
  ClassStmt(std::string name, std::vector&lt;Param&gt; args, StmtPtr suite, Attr attr);
  ClassStmt(const ClassStmt &amp;stmt);

  std::string toString(int indent) const override;
  void validate() const;
  ACCEPT(ASTVisitor);

  /// @return true if a class is a tuple-like record (e.g. has a "@tuple" attribute)
  bool isRecord() const;
  bool hasAttr(const std::string &amp;attr) const;

  ClassStmt *getClass() override { return this; }

  void parseDecorators();
  static bool isClassVar(const Param &amp;p);
  std::string getDocstr();
};

/// Yield-from statement (yield from expr).
/// @li: yield from it
struct YieldFromStmt : public Stmt {
  ExprPtr expr;

  explicit YieldFromStmt(ExprPtr expr);
  YieldFromStmt(const YieldFromStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// With statement (with (item as var)...: suite).
/// @li: with foo(), bar() as b: pass
struct WithStmt : public Stmt {
  std::vector&lt;ExprPtr&gt; items;
  /// empty string if a corresponding item is unnamed
  std::vector&lt;std::string&gt; vars;
  StmtPtr suite;

  WithStmt(std::vector&lt;ExprPtr&gt; items, std::vector&lt;std::string&gt; vars, StmtPtr suite);
  WithStmt(std::vector&lt;std::pair&lt;ExprPtr, ExprPtr&gt;&gt; items, StmtPtr suite);
  WithStmt(const WithStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Custom block statement (foo: ...).
/// @li: pt_tree: pass
struct CustomStmt : public Stmt {
  std::string keyword;
  ExprPtr expr;
  StmtPtr suite;

  CustomStmt(std::string keyword, ExprPtr expr, StmtPtr suite);
  CustomStmt(const CustomStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// The following nodes are created after the simplify stage.

/// Member assignment statement (lhs.member = rhs).
/// @li: a.x = b
struct AssignMemberStmt : public Stmt {
  ExprPtr lhs;
  std::string member;
  ExprPtr rhs;

  AssignMemberStmt(ExprPtr lhs, std::string member, ExprPtr rhs);
  AssignMemberStmt(const AssignMemberStmt &amp;stmt);

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

/// Comment statement (# comment).
/// Currently used only for pretty-printing.
struct CommentStmt : public Stmt {
  std::string comment;

  explicit CommentStmt(std::string comment);
  CommentStmt(const CommentStmt &amp;stmt) = default;

  std::string toString(int indent) const override;
  ACCEPT(ASTVisitor);
};

#undef ACCEPT

} // namespace codon::ast

</t>
<t tx="ekr.20230509083243.493">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::Stmt, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509083243.494">template &lt;typename T&gt;
struct fmt::formatter&lt;
  T, std::enable_if_t&lt;
         std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::Stmt&gt;&gt;::value, char&gt;&gt;
  : fmt::formatter&lt;std::string_view&gt; {
@others
};
</t>
<t tx="ekr.20230509083243.495">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "{}", p ? p-&gt;toString() : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509083243.496">@path C:/Repos/codon/codon/parser/ast/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include "codon/parser/ast/types/class.h"
#include "codon/parser/ast/types/function.h"
#include "codon/parser/ast/types/link.h"
#include "codon/parser/ast/types/static.h"
#include "codon/parser/ast/types/traits.h"
#include "codon/parser/ast/types/type.h"
#include "codon/parser/ast/types/union.h"
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.497"></t>
<t tx="ekr.20230509083243.498">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

ClassType::ClassType(Cache *cache, std::string name, std::string niceName,
                     std::vector&lt;Generic&gt; generics, std::vector&lt;Generic&gt; hiddenGenerics)
    : Type(cache), name(move(name)), niceName(move(niceName)), generics(move(generics)),
      hiddenGenerics(move(hiddenGenerics)) {}
ClassType::ClassType(const ClassTypePtr &amp;base)
    : Type(base), name(base-&gt;name), niceName(base-&gt;niceName), generics(base-&gt;generics),
      hiddenGenerics(base-&gt;hiddenGenerics) {}

@others
std::string RecordType::debugString(char mode) const {
  return fmt::format("{}", this-&gt;ClassType::debugString(mode));
}

std::shared_ptr&lt;RecordType&gt; RecordType::getHeterogenousTuple() {
  seqassert(canRealize(), "{} not realizable", toString());
  if (args.size() &gt; 1) {
    std::string first = args[0]-&gt;realizedName();
    for (int i = 1; i &lt; args.size(); i++)
      if (args[i]-&gt;realizedName() != first)
        return getRecord();
  }
  return nullptr;
}

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.499">int ClassType::unify(Type *typ, Unification *us) {
  if (auto tc = typ-&gt;getClass()) {
    // Check names.
    if (name != tc-&gt;name)
      return -1;
    // Check generics.
    int s1 = 3, s = 0;
    if (generics.size() != tc-&gt;generics.size())
      return -1;
    for (int i = 0; i &lt; generics.size(); i++) {
      if ((s = generics[i].type-&gt;unify(tc-&gt;generics[i].type.get(), us)) == -1)
        return -1;
      s1 += s;
    }
    return s1;
  } else if (auto tl = typ-&gt;getLink()) {
    return tl-&gt;unify(this, us);
  } else {
    return -1;
  }
}

</t>
<t tx="ekr.20230509083243.5">  void handle(YieldInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *val = v-&gt;getValue();
    if (!val) {
      valid = false;
      return;
    }

    Value *rhs = val;
    if (val-&gt;getType()-&gt;is(M-&gt;getBoolType())) {
      rhs = M-&gt;Nr&lt;TernaryInstr&gt;(rhs, M-&gt;getInt(1), M-&gt;getInt(0));
    }

    Value *add = *M-&gt;Nr&lt;VarValue&gt;(accumulator) + *rhs;
    if (!add || !add-&gt;getType()-&gt;is(accumulator-&gt;getType())) {
      valid = false;
      return;
    }

    auto *assign = M-&gt;Nr&lt;AssignInstr&gt;(accumulator, add);
    v-&gt;replaceAll(assign);
  }

</t>
<t tx="ekr.20230509083243.50">@path C:/Repos/codon/codon/cir/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "types.h"

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;utility&gt;

#include "codon/cir/module.h"
#include "codon/cir/util/irtools.h"
#include "codon/cir/util/iterators.h"
#include "codon/cir/util/visitor.h"
#include "codon/cir/value.h"
#include "codon/parser/cache.h"
#include &lt;fmt/format.h&gt;

namespace codon {
namespace ir {
namespace types {
namespace {
std::vector&lt;codon::ast::types::TypePtr&gt;
extractTypes(const std::vector&lt;codon::ast::types::ClassType::Generic&gt; &amp;gens) {
  std::vector&lt;codon::ast::types::TypePtr&gt; ret;
  for (auto &amp;g : gens)
    ret.push_back(g.type);
  return ret;
}
} // namespace

const char Type::NodeId = 0;

std::vector&lt;Generic&gt; Type::doGetGenerics() const {
  if (!astType)
    return {};

  std::vector&lt;Generic&gt; ret;
  for (auto &amp;g : astType-&gt;getClass()-&gt;generics) {
    if (auto cls = g.type-&gt;getClass())
      ret.emplace_back(
          getModule()-&gt;getCache()-&gt;realizeType(cls, extractTypes(cls-&gt;generics)));
    else {
      seqassertn(g.type-&gt;getStatic()-&gt;expr-&gt;staticValue.type == ast::StaticValue::INT,
                 "IR only supports int statics [{}]", g.type-&gt;getSrcInfo());
      ret.emplace_back(g.type-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt());
    }
  }

  return ret;
}

Value *Type::doConstruct(std::vector&lt;Value *&gt; args) {
  auto *module = getModule();
  std::vector&lt;Type *&gt; argTypes;
  for (auto *a : args)
    argTypes.push_back(a-&gt;getType());

  auto *fn = module-&gt;getOrRealizeMethod(this, Module::NEW_MAGIC_NAME, argTypes);
  if (!fn)
    return nullptr;

  return module-&gt;Nr&lt;CallInstr&gt;(module-&gt;Nr&lt;VarValue&gt;(fn), args);
}

const char PrimitiveType::NodeId = 0;

const char IntType::NodeId = 0;

const char FloatType::NodeId = 0;

const char Float32Type::NodeId = 0;

const char BoolType::NodeId = 0;

const char ByteType::NodeId = 0;

const char VoidType::NodeId = 0;

const char MemberedType::NodeId = 0;

const char RecordType::NodeId = 0;

RecordType::RecordType(std::string name, std::vector&lt;Type *&gt; fieldTypes,
                       std::vector&lt;std::string&gt; fieldNames)
    : AcceptorExtend(std::move(name)) {
  for (auto i = 0; i &lt; fieldTypes.size(); ++i) {
    fields.emplace_back(fieldNames[i], fieldTypes[i]);
  }
}

RecordType::RecordType(std::string name, std::vector&lt;Type *&gt; mTypes)
    : AcceptorExtend(std::move(name)) {
  for (int i = 0; i &lt; mTypes.size(); ++i) {
    fields.emplace_back(std::to_string(i + 1), mTypes[i]);
  }
}

std::vector&lt;Type *&gt; RecordType::doGetUsedTypes() const {
  std::vector&lt;Type *&gt; ret;
  for (auto &amp;f : fields)
    ret.push_back(const_cast&lt;Type *&gt;(f.getType()));
  return ret;
}

Type *RecordType::getMemberType(const std::string &amp;n) const {
@others
Value *RefType::doConstruct(std::vector&lt;Value *&gt; args) {
  auto *module = getModule();
  auto *argsTuple = util::makeTuple(args, module);
  auto *constructFn = module-&gt;getOrRealizeFunc("construct_ref", {argsTuple-&gt;getType()},
                                               {this}, "std.internal.gc");
  if (!constructFn)
    return nullptr;

  std::vector&lt;Value *&gt; callArgs = {argsTuple};
  return module-&gt;Nr&lt;CallInstr&gt;(module-&gt;Nr&lt;VarValue&gt;(constructFn), callArgs);
}

const char FuncType::NodeId = 0;

std::vector&lt;Generic&gt; FuncType::doGetGenerics() const {
  auto t = getAstType();
  if (!t)
    return {};
  auto astType = t-&gt;getFunc();
  if (!astType)
    return {};

  std::vector&lt;Generic&gt; ret;
  for (auto &amp;g : astType-&gt;funcGenerics) {
    if (auto cls = g.type-&gt;getClass())
      ret.emplace_back(
          getModule()-&gt;getCache()-&gt;realizeType(cls, extractTypes(cls-&gt;generics)));
    else {
      seqassertn(g.type-&gt;getStatic()-&gt;expr-&gt;staticValue.type == ast::StaticValue::INT,
                 "IR only supports int statics [{}]", getSrcInfo());
      ret.emplace_back(g.type-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt());
    }
  }

  return ret;
}

std::vector&lt;Type *&gt; FuncType::doGetUsedTypes() const {
  auto ret = argTypes;
  ret.push_back(rType);
  return ret;
}

const char DerivedType::NodeId = 0;

const char PointerType::NodeId = 0;

std::string PointerType::getInstanceName(Type *base) {
  return fmt::format(FMT_STRING("Pointer[{}]"), base-&gt;referenceString());
}

const char OptionalType::NodeId = 0;

std::string OptionalType::getInstanceName(Type *base) {
  return fmt::format(FMT_STRING("Optional[{}]"), base-&gt;referenceString());
}

const char GeneratorType::NodeId = 0;

std::string GeneratorType::getInstanceName(Type *base) {
  return fmt::format(FMT_STRING("Generator[{}]"), base-&gt;referenceString());
}

const char IntNType::NodeId = 0;

std::string IntNType::getInstanceName(unsigned int len, bool sign) {
  return fmt::format(FMT_STRING("{}Int{}"), sign ? "" : "U", len);
}

const char VectorType::NodeId = 0;

std::string VectorType::getInstanceName(unsigned int count, PrimitiveType *base) {
  return fmt::format(FMT_STRING("Vector[{}, {}]"), count, base-&gt;referenceString());
}

const char UnionType::NodeId = 0;

std::string UnionType::getInstanceName(const std::vector&lt;types::Type *&gt; &amp;types) {
  std::vector&lt;std::string&gt; names;
  for (auto *type : types) {
    names.push_back(type-&gt;referenceString());
  }
  return fmt::format(FMT_STRING("Union[{}]"),
                     fmt::join(names.begin(), names.end(), ", "));
}

} // namespace types
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.500">TypePtr ClassType::generalize(int atLevel) {
  auto g = generics, hg = hiddenGenerics;
  for (auto &amp;t : g)
    t.type = t.type ? t.type-&gt;generalize(atLevel) : nullptr;
  for (auto &amp;t : hg)
    t.type = t.type ? t.type-&gt;generalize(atLevel) : nullptr;
  auto c = std::make_shared&lt;ClassType&gt;(cache, name, niceName, g, hg);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

TypePtr ClassType::instantiate(int atLevel, int *unboundCount,
                               std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto g = generics, hg = hiddenGenerics;
  for (auto &amp;t : g)
    t.type = t.type ? t.type-&gt;instantiate(atLevel, unboundCount, cache) : nullptr;
  for (auto &amp;t : hg)
    t.type = t.type ? t.type-&gt;instantiate(atLevel, unboundCount, cache) : nullptr;
  auto c = std::make_shared&lt;ClassType&gt;(this-&gt;cache, name, niceName, g, hg);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

std::vector&lt;TypePtr&gt; ClassType::getUnbounds() const {
  std::vector&lt;TypePtr&gt; u;
  for (auto &amp;t : generics)
    if (t.type) {
      auto tu = t.type-&gt;getUnbounds();
      u.insert(u.begin(), tu.begin(), tu.end());
    }
  for (auto &amp;t : hiddenGenerics)
    if (t.type) {
      auto tu = t.type-&gt;getUnbounds();
      u.insert(u.begin(), tu.begin(), tu.end());
    }
  return u;
}

</t>
<t tx="ekr.20230509083243.501">bool ClassType::canRealize() const {
  return std::all_of(generics.begin(), generics.end(),
                     [](auto &amp;t) { return !t.type || t.type-&gt;canRealize(); }) &amp;&amp;
         std::all_of(hiddenGenerics.begin(), hiddenGenerics.end(),
                     [](auto &amp;t) { return !t.type || t.type-&gt;canRealize(); });
}

</t>
<t tx="ekr.20230509083243.502">bool ClassType::isInstantiated() const {
  return std::all_of(generics.begin(), generics.end(),
                     [](auto &amp;t) { return !t.type || t.type-&gt;isInstantiated(); }) &amp;&amp;
         std::all_of(hiddenGenerics.begin(), hiddenGenerics.end(),
                     [](auto &amp;t) { return !t.type || t.type-&gt;isInstantiated(); });
}

</t>
<t tx="ekr.20230509083243.503">std::string ClassType::debugString(char mode) const {
  std::vector&lt;std::string&gt; gs;
  for (auto &amp;a : generics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;debugString(mode));
  if ((mode == 2) &amp;&amp; !hiddenGenerics.empty()) {
    for (auto &amp;a : hiddenGenerics)
      if (!a.name.empty())
        gs.push_back("-" + a.type-&gt;debugString(mode));
  }
  // Special formatting for Functions and Tuples
  auto n = mode == 0 ? niceName : name;
  if (startswith(n, TYPE_TUPLE))
    n = "Tuple";
  return fmt::format("{}{}", n, gs.empty() ? "" : fmt::format("[{}]", join(gs, ",")));
}

std::string ClassType::realizedName() const {
  if (!_rn.empty())
    return _rn;

  std::vector&lt;std::string&gt; gs;
  for (auto &amp;a : generics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;realizedName());
  std::string s = join(gs, ",");
  if (canRealize())
</t>
<t tx="ekr.20230509083243.504">    const_cast&lt;ClassType *&gt;(this)-&gt;_rn =
        fmt::format("{}{}", name, s.empty() ? "" : fmt::format("[{}]", s));
  return _rn;
}

std::string ClassType::realizedTypeName() const {
  return this-&gt;ClassType::realizedName();
}

</t>
<t tx="ekr.20230509083243.505">RecordType::RecordType(Cache *cache, std::string name, std::string niceName,
                       std::vector&lt;Generic&gt; generics, std::vector&lt;TypePtr&gt; args,
</t>
<t tx="ekr.20230509083243.506">                       bool noTuple)
    : ClassType(cache, std::move(name), std::move(niceName), std::move(generics)),
      args(std::move(args)), noTuple(false) {}

RecordType::RecordType(const ClassTypePtr &amp;base, std::vector&lt;TypePtr&gt; args,
  @others
</t>
<t tx="ekr.20230509083243.507">                     bool noTuple)
  : ClassType(base), args(std::move(args)), noTuple(noTuple) {}

@others
</t>
<t tx="ekr.20230509083243.508">int RecordType::unify(Type *typ, Unification *us) {
if (auto tr = typ-&gt;getRecord()) {
  // Handle int &lt;-&gt; Int[64]
  if (name == "int" &amp;&amp; tr-&gt;name == "Int")
    return tr-&gt;unify(this, us);
  if (tr-&gt;name == "int" &amp;&amp; name == "Int") {
    auto t64 = std::make_shared&lt;StaticType&gt;(cache, 64);
    return generics[0].type-&gt;unify(t64.get(), us);
  }

  int s1 = 2, s = 0;
  if (args.size() != tr-&gt;args.size())
    return -1;
  for (int i = 0; i &lt; args.size(); i++) {
    if ((s = args[i]-&gt;unify(tr-&gt;args[i].get(), us)) != -1)
      s1 += s;
    else
      return -1;
  }
  // Handle Tuple&lt;-&gt;@tuple: when unifying tuples, only record members matter.
  if (startswith(name, TYPE_TUPLE) || startswith(tr-&gt;name, TYPE_TUPLE)) {
    if (!args.empty() || (!noTuple &amp;&amp; !tr-&gt;noTuple)) // prevent POD&lt;-&gt;() unification
      return s1 + int(name == tr-&gt;name);
    else
      return -1;
  }
  return this-&gt;ClassType::unify(tr.get(), us);
} else if (auto t = typ-&gt;getLink()) {
  return t-&gt;unify(this, us);
} else {
  return -1;
}
}

</t>
<t tx="ekr.20230509083243.509">TypePtr RecordType::generalize(int atLevel) {
  auto c = std::static_pointer_cast&lt;ClassType&gt;(this-&gt;ClassType::generalize(atLevel));
  auto a = args;
  for (auto &amp;t : a)
    t = t-&gt;generalize(atLevel);
  return std::make_shared&lt;RecordType&gt;(c, a, noTuple);
}

TypePtr RecordType::instantiate(int atLevel, int *unboundCount,
                                std::unordered_map&lt;int, TypePtr&gt; *cache) {
</t>
<t tx="ekr.20230509083243.51">  auto it = std::find_if(fields.begin(), fields.end(),
                         [n](auto &amp;x) { return x.getName() == n; });
  return it-&gt;getType();
}

  @others
</t>
<t tx="ekr.20230509083243.510">  auto c = std::static_pointer_cast&lt;ClassType&gt;(
      this-&gt;ClassType::instantiate(atLevel, unboundCount, cache));
  auto a = args;
  for (auto &amp;t : a)
    t = t-&gt;instantiate(atLevel, unboundCount, cache);
  return std::make_shared&lt;RecordType&gt;(c, a, noTuple);
}

std::vector&lt;TypePtr&gt; RecordType::getUnbounds() const {
  std::vector&lt;TypePtr&gt; u;
  for (auto &amp;a : args) {
    auto tu = a-&gt;getUnbounds();
    u.insert(u.begin(), tu.begin(), tu.end());
  }
  auto tu = this-&gt;ClassType::getUnbounds();
  u.insert(u.begin(), tu.begin(), tu.end());
  return u;
}

</t>
<t tx="ekr.20230509083243.511">bool RecordType::canRealize() const {
  return std::all_of(args.begin(), args.end(),
                     [](auto &amp;a) { return a-&gt;canRealize(); }) &amp;&amp;
         this-&gt;ClassType::canRealize();
}

</t>
<t tx="ekr.20230509083243.512">bool RecordType::isInstantiated() const {
  return std::all_of(args.begin(), args.end(),
                     [](auto &amp;a) { return a-&gt;isInstantiated(); }) &amp;&amp;
         this-&gt;ClassType::isInstantiated();
}

</t>
<t tx="ekr.20230509083243.513">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

/**
 * A generic class reference type. All Seq types inherit from this class.
 */
struct ClassType : public Type {
  /**
   * A generic type declaration.
   * Each generic is defined by its unique ID.
   */
  struct Generic {
    // Generic name.
    std::string name;
    // Name used for pretty-printing.
    std::string niceName;
    // Unique generic ID.
    int id;
    // Pointer to realized type (or generic LinkType).
    TypePtr type;

    Generic(std::string name, std::string niceName, TypePtr type, int id)
        : name(std::move(name)), niceName(std::move(niceName)), id(id),
          type(std::move(type)) {}
  };

  /// Canonical type name.
  std::string name;
  /// Name used for pretty-printing.
  std::string niceName;
  /// List of generics, if present.
  std::vector&lt;Generic&gt; generics;

  std::vector&lt;Generic&gt; hiddenGenerics;

  std::string _rn;

  explicit ClassType(Cache *cache, std::string name, std::string niceName,
                     std::vector&lt;Generic&gt; generics = {},
                     std::vector&lt;Generic&gt; hiddenGenerics = {});
  explicit ClassType(const std::shared_ptr&lt;ClassType&gt; &amp;base);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;
  /// Convenience function to get the name of realized type
  /// (needed if a subclass realizes something else as well).
  virtual std::string realizedTypeName() const;
  std::shared_ptr&lt;ClassType&gt; getClass() override {
    return std::static_pointer_cast&lt;ClassType&gt;(shared_from_this());
  }
};
using ClassTypePtr = std::shared_ptr&lt;ClassType&gt;;

/**
 * A generic class tuple (record) type. All Seq tuples inherit from this class.
 */
struct RecordType : public ClassType {
  /// List of tuple arguments.
  std::vector&lt;TypePtr&gt; args;
  bool noTuple;

  explicit RecordType(
      Cache *cache, std::string name, std::string niceName,
      std::vector&lt;ClassType::Generic&gt; generics = std::vector&lt;ClassType::Generic&gt;(),
      std::vector&lt;TypePtr&gt; args = std::vector&lt;TypePtr&gt;(), bool noTuple = false);
  RecordType(const ClassTypePtr &amp;base, std::vector&lt;TypePtr&gt; args, bool noTuple = false);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;

  std::shared_ptr&lt;RecordType&gt; getRecord() override {
    return std::static_pointer_cast&lt;RecordType&gt;(shared_from_this());
  }
  std::shared_ptr&lt;RecordType&gt; getHeterogenousTuple() override;
};

} // namespace codon::ast::types

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.514">template &lt;&gt;
struct fmt::formatter&lt;codon::ast::types::ClassType::Generic&gt;
    : fmt::formatter&lt;std::string_view&gt; {
  @others
};
</t>
<t tx="ekr.20230509083243.515">template &lt;typename FormatContext&gt;
auto format(const codon::ast::types::ClassType::Generic &amp;p, FormatContext &amp;ctx) const
    -&gt; decltype(ctx.out()) {
  return fmt::format_to(ctx.out(), "({}{})",
                        p.name.empty() ? "" : fmt::format("{} = ", p.name), p.type);
}
</t>
<t tx="ekr.20230509083243.516">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

FuncType::FuncType(const std::shared_ptr&lt;RecordType&gt; &amp;baseType, FunctionStmt *ast,
                   std::vector&lt;Generic&gt; funcGenerics, TypePtr funcParent)
    : RecordType(*baseType), ast(ast), funcGenerics(std::move(funcGenerics)),
      funcParent(std::move(funcParent)) {}

@others
std::string PartialType::realizedName() const {
  std::vector&lt;std::string&gt; gs;
  gs.push_back(func-&gt;ast-&gt;name);
  for (auto &amp;a : generics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;realizedName());
  std::string s = join(gs, ",");
  return fmt::format("{}{}", name, s.empty() ? "" : fmt::format("[{}]", s));
}

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.517">int FuncType::unify(Type *typ, Unification *us) {
  if (this == typ)
    return 0;
  int s1 = 2, s = 0;
  if (auto t = typ-&gt;getFunc()) {
    // Check if names and parents match.
    if (ast-&gt;name != t-&gt;ast-&gt;name || (bool(funcParent) ^ bool(t-&gt;funcParent)))
      return -1;
    if (funcParent &amp;&amp; (s = funcParent-&gt;unify(t-&gt;funcParent.get(), us)) == -1)
      return -1;
    s1 += s;
    // Check if function generics match.
    seqassert(funcGenerics.size() == t-&gt;funcGenerics.size(),
              "generic size mismatch for {}", ast-&gt;name);
    for (int i = 0; i &lt; funcGenerics.size(); i++) {
      if ((s = funcGenerics[i].type-&gt;unify(t-&gt;funcGenerics[i].type.get(), us)) == -1)
        return -1;
      s1 += s;
    }
  }
  s = this-&gt;RecordType::unify(typ, us);
  return s == -1 ? s : s1 + s;
}

</t>
<t tx="ekr.20230509083243.518">TypePtr FuncType::generalize(int atLevel) {
  auto g = funcGenerics;
  for (auto &amp;t : g)
    t.type = t.type ? t.type-&gt;generalize(atLevel) : nullptr;
  auto p = funcParent ? funcParent-&gt;generalize(atLevel) : nullptr;
  return std::make_shared&lt;FuncType&gt;(
      std::static_pointer_cast&lt;RecordType&gt;(this-&gt;RecordType::generalize(atLevel)), ast,
      g, p);
}

TypePtr FuncType::instantiate(int atLevel, int *unboundCount,
                              std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto g = funcGenerics;
  for (auto &amp;t : g)
    if (t.type) {
      t.type = t.type-&gt;instantiate(atLevel, unboundCount, cache);
      if (cache &amp;&amp; cache-&gt;find(t.id) == cache-&gt;end())
        (*cache)[t.id] = t.type;
    }
  auto p = funcParent ? funcParent-&gt;instantiate(atLevel, unboundCount, cache) : nullptr;
  return std::make_shared&lt;FuncType&gt;(
      std::static_pointer_cast&lt;RecordType&gt;(
          this-&gt;RecordType::instantiate(atLevel, unboundCount, cache)),
      ast, g, p);
}

std::vector&lt;TypePtr&gt; FuncType::getUnbounds() const {
  std::vector&lt;TypePtr&gt; u;
  for (auto &amp;t : funcGenerics)
    if (t.type) {
      auto tu = t.type-&gt;getUnbounds();
      u.insert(u.begin(), tu.begin(), tu.end());
    }
  if (funcParent) {
    auto tu = funcParent-&gt;getUnbounds();
    u.insert(u.begin(), tu.begin(), tu.end());
  }
  // Important: return type unbounds are not important, so skip them.
  for (auto &amp;a : getArgTypes()) {
    auto tu = a-&gt;getUnbounds();
    u.insert(u.begin(), tu.begin(), tu.end());
  }
  return u;
}

</t>
<t tx="ekr.20230509083243.519">bool FuncType::canRealize() const {
  // Important: return type does not have to be realized.
  bool skipSelf = ast-&gt;hasAttr(Attr::RealizeWithoutSelf);

  auto args = getArgTypes();
  for (int ai = skipSelf; ai &lt; args.size(); ai++)
    if (!args[ai]-&gt;getFunc() &amp;&amp; !args[ai]-&gt;canRealize())
      return false;
  bool generics = std::all_of(funcGenerics.begin(), funcGenerics.end(),
                              [](auto &amp;a) { return !a.type || a.type-&gt;canRealize(); });
  if (!skipSelf)
    generics &amp;= (!funcParent || funcParent-&gt;canRealize());
  return generics;
}

</t>
<t tx="ekr.20230509083243.52">int RecordType::getMemberIndex(const std::string &amp;n) const {
auto it = std::find_if(fields.begin(), fields.end(),
                       [n](auto &amp;x) { return x.getName() == n; });
int index = std::distance(fields.begin(), it);
return (index &lt; fields.size()) ? index : -1;
}

</t>
<t tx="ekr.20230509083243.520">bool FuncType::isInstantiated() const {
  @others
</t>
<t tx="ekr.20230509083243.521">TypePtr removed = nullptr;
auto retType = getRetType();
if (retType-&gt;getFunc() &amp;&amp; retType-&gt;getFunc()-&gt;funcParent.get() == this) {
  removed = retType-&gt;getFunc()-&gt;funcParent;
  retType-&gt;getFunc()-&gt;funcParent = nullptr;
}
</t>
<t tx="ekr.20230509083243.522">  auto res = std::all_of(funcGenerics.begin(), funcGenerics.end(),
                         [](auto &amp;a) { return !a.type || a.type-&gt;isInstantiated(); }) &amp;&amp;
             (!funcParent || funcParent-&gt;isInstantiated()) &amp;&amp;
             this-&gt;RecordType::isInstantiated();
  if (removed)
    retType-&gt;getFunc()-&gt;funcParent = removed;
  return res;
}

std::string FuncType::debugString(char mode) const {
  std::vector&lt;std::string&gt; gs;
  for (auto &amp;a : funcGenerics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;debugString(mode));
  std::string s = join(gs, ",");
  std::vector&lt;std::string&gt; as;
  // Important: return type does not have to be realized.
  if (mode == 2)
    as.push_back(getRetType()-&gt;debugString(mode));
  for (auto &amp;a : getArgTypes())
    as.push_back(a-&gt;debugString(mode));
  std::string a = join(as, ",");
  s = s.empty() ? a : join(std::vector&lt;std::string&gt;{a, s}, ",");

  auto fnname = ast-&gt;name;
  if (mode == 0) {
    fnname = cache-&gt;rev(ast-&gt;name);
    // if (funcParent)
    // fnname = fmt::format("{}.{}", funcParent-&gt;debugString(mode), fnname);
  }
  return fmt::format("{}{}", fnname, s.empty() ? "" : fmt::format("[{}]", s));
}

</t>
<t tx="ekr.20230509083243.523">std::string FuncType::realizedName() const {
  std::vector&lt;std::string&gt; gs;
  for (auto &amp;a : funcGenerics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;realizedName());
  std::string s = join(gs, ",");
  std::vector&lt;std::string&gt; as;
  // Important: return type does not have to be realized.
  for (auto &amp;a : getArgTypes())
    as.push_back(a-&gt;getFunc() ? a-&gt;getFunc()-&gt;realizedName() : a-&gt;realizedName());
  std::string a = join(as, ",");
  s = s.empty() ? a : join(std::vector&lt;std::string&gt;{a, s}, ",");
  return fmt::format("{}{}{}", funcParent ? funcParent-&gt;realizedName() + ":" : "",
                     ast-&gt;name, s.empty() ? "" : fmt::format("[{}]", s));
}

PartialType::PartialType(const std::shared_ptr&lt;RecordType&gt; &amp;baseType,
                         std::shared_ptr&lt;FuncType&gt; func, std::vector&lt;char&gt; known)
    : RecordType(*baseType), func(std::move(func)), known(std::move(known)) {}

</t>
<t tx="ekr.20230509083243.524">int PartialType::unify(Type *typ, Unification *us) {
  return this-&gt;RecordType::unify(typ, us);
}

</t>
<t tx="ekr.20230509083243.525">TypePtr PartialType::generalize(int atLevel) {
  return std::make_shared&lt;PartialType&gt;(
      std::static_pointer_cast&lt;RecordType&gt;(this-&gt;RecordType::generalize(atLevel)), func,
      known);
}

TypePtr PartialType::instantiate(int atLevel, int *unboundCount,
                                 std::unordered_map&lt;int, TypePtr&gt; *cache) {
</t>
<t tx="ekr.20230509083243.526">  auto rec = std::static_pointer_cast&lt;RecordType&gt;(
      this-&gt;RecordType::instantiate(atLevel, unboundCount, cache));
  return std::make_shared&lt;PartialType&gt;(rec, func, known);
}

std::string PartialType::debugString(char mode) const {
  std::vector&lt;std::string&gt; gs;
  for (auto &amp;a : generics)
    if (!a.name.empty())
      gs.push_back(a.type-&gt;debugString(mode));
  std::vector&lt;std::string&gt; as;
  int i = 0, gi = 0;
  for (; i &lt; known.size(); i++)
    if (func-&gt;ast-&gt;args[i].status == Param::Normal) {
      if (!known[i])
        as.emplace_back("...");
      else
        as.emplace_back(gs[gi++]);
    }
  auto fnname = func-&gt;ast-&gt;name;
  if (mode == 0) {
    fnname = cache-&gt;rev(func-&gt;ast-&gt;name);
    // if (func-&gt;funcParent)
    // fnname = fmt::format("{}.{}", func-&gt;funcParent-&gt;debugString(mode), fnname);
  } else if (mode == 2) {
    fnname = func-&gt;debugString(mode);
  }
  return fmt::format("{}[{}{}]", fnname, join(as, ","),
                     mode == 2 ? fmt::format(";{}", join(gs, ",")) : "");
}

</t>
<t tx="ekr.20230509083243.527">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"
#include "codon/parser/ast/types/type.h"

namespace codon::ast {
struct FunctionStmt;
}

namespace codon::ast::types {

/**
 * A generic type that represents a Seq function instantiation.
 * It inherits RecordType that realizes Callable[...].
 *
 *  This is not a function pointer (Function[...]) type.
 */
struct FuncType : public RecordType {
  /// Canonical AST node.
  FunctionStmt *ast;
  /// Function generics (e.g. T in def foo[T](...)).
  std::vector&lt;ClassType::Generic&gt; funcGenerics;
  /// Enclosing class or a function.
  TypePtr funcParent;

public:
  FuncType(
      const std::shared_ptr&lt;RecordType&gt; &amp;baseType, FunctionStmt *ast,
      std::vector&lt;ClassType::Generic&gt; funcGenerics = std::vector&lt;ClassType::Generic&gt;(),
      TypePtr funcParent = nullptr);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  std::shared_ptr&lt;FuncType&gt; getFunc() override {
    return std::static_pointer_cast&lt;FuncType&gt;(shared_from_this());
  }

  std::vector&lt;TypePtr&gt; &amp;getArgTypes() const {
    return generics[0].type-&gt;getRecord()-&gt;args;
  }
  TypePtr getRetType() const { return generics[1].type; }
};
using FuncTypePtr = std::shared_ptr&lt;FuncType&gt;;

/**
 * A generic type that represents a partial Seq function instantiation.
 * It inherits RecordType that realizes Tuple[...].
 *
 * Note: partials only work on Seq functions. Function pointer partials
 *       will become a partials of Function.__call__ Seq function.
 */
struct PartialType : public RecordType {
  /// Seq function that is being partialized. Always generic (not instantiated).
  FuncTypePtr func;
  /// Arguments that are already provided (1 for known argument, 0 for expecting).
  std::vector&lt;char&gt; known;

public:
  PartialType(const std::shared_ptr&lt;RecordType&gt; &amp;baseType,
              std::shared_ptr&lt;FuncType&gt; func, std::vector&lt;char&gt; known);

public:
  int unify(Type *typ, Unification *us) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

  std::string debugString(char mode) const override;
  std::string realizedName() const override;

public:
  std::shared_ptr&lt;PartialType&gt; getPartial() override {
    return std::static_pointer_cast&lt;PartialType&gt;(shared_from_this());
  }
};
using PartialTypePtr = std::shared_ptr&lt;PartialType&gt;;

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.528">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/link.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

LinkType::LinkType(Cache *cache, Kind kind, int id, int level, TypePtr type,
@others
} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.529">                   char isStatic, std::shared_ptr&lt;Trait&gt; trait, TypePtr defaultType,
                   std::string genericName)
    : Type(cache), kind(kind), id(id), level(level), type(std::move(type)),
      isStatic(isStatic), trait(std::move(trait)), genericName(std::move(genericName)),
      defaultType(std::move(defaultType)) {
  seqassert((this-&gt;type &amp;&amp; kind == Link) || (!this-&gt;type &amp;&amp; kind == Generic) ||
                (!this-&gt;type &amp;&amp; kind == Unbound),
            "inconsistent link state");
}

</t>
<t tx="ekr.20230509083243.53">void RecordType::realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) {
  @others
</t>
<t tx="ekr.20230509083243.530">LinkType::LinkType(TypePtr type)
    : Type(type), kind(Link), id(0), level(0), type(std::move(type)), isStatic(0),
      trait(nullptr), defaultType(nullptr) {
  seqassert(this-&gt;type, "link to nullptr");
}

</t>
<t tx="ekr.20230509083243.531">int LinkType::unify(Type *typ, Unification *undo) {
  if (kind == Link) {
    // Case 1: Just follow the link
    return type-&gt;unify(typ, undo);
  } else if (kind == Generic) {
    // Case 2: Generic types cannot be unified.
    return -1;
  } else {
    // Case 3: Unbound unification
    if (isStaticType() != typ-&gt;isStaticType())
      return -1;
    if (auto ts = typ-&gt;getStatic()) {
      if (ts-&gt;expr-&gt;getId())
        return unify(ts-&gt;generics[0].type.get(), undo);
    }
    if (auto t = typ-&gt;getLink()) {
      if (t-&gt;kind == Link)
        return t-&gt;type-&gt;unify(this, undo);
      else if (t-&gt;kind == Generic)
        return -1;
      else {
        if (id == t-&gt;id) {
          // Identical unbound types get a score of 1
          return 1;
        } else if (id &lt; t-&gt;id) {
          // Always merge a newer type into the older type (e.g. keep the types with
          // lower IDs around).
          return t-&gt;unify(this, undo);
        }
      }
    }
    // Ensure that we do not have recursive unification! (e.g. unify ?1 with list[?1])
    if (occurs(typ, undo))
      return -1;

    if (trait &amp;&amp; trait-&gt;unify(typ, undo) == -1)
      return -1;

    //  Unification: destructive part.
    seqassert(!type, "type has been already unified or is in inconsistent state");
    if (undo) {
      LOG_TYPECHECK("[unify] {} := {}", id, typ-&gt;debugString(2));
      // Link current type to typ and ensure that this modification is recorded in undo.
      undo-&gt;linked.push_back(this);
      kind = Link;
      seqassert(!typ-&gt;getLink() || typ-&gt;getLink()-&gt;kind != Unbound ||
                    typ-&gt;getLink()-&gt;id &lt;= id,
                "type unification is not consistent");
      type = typ-&gt;follow();
      if (auto t = type-&gt;getLink())
        if (trait &amp;&amp; t-&gt;kind == Unbound &amp;&amp; !t-&gt;trait) {
          undo-&gt;traits.push_back(t.get());
          t-&gt;trait = trait;
        }
    }
    return 0;
  }
}

</t>
<t tx="ekr.20230509083243.532">TypePtr LinkType::generalize(int atLevel) {
  if (kind == Generic) {
    return shared_from_this();
  } else if (kind == Unbound) {
    if (level &gt;= atLevel)
      return std::make_shared&lt;LinkType&gt;(
          cache, Generic, id, 0, nullptr, isStatic,
          trait ? std::static_pointer_cast&lt;Trait&gt;(trait-&gt;generalize(atLevel)) : nullptr,
          defaultType ? defaultType-&gt;generalize(atLevel) : nullptr, genericName);
    else
      return shared_from_this();
  } else {
    seqassert(type, "link is null");
    return type-&gt;generalize(atLevel);
  }
}

TypePtr LinkType::instantiate(int atLevel, int *unboundCount,
                              std::unordered_map&lt;int, TypePtr&gt; *cache) {
  if (kind == Generic) {
    if (cache &amp;&amp; cache-&gt;find(id) != cache-&gt;end())
      return (*cache)[id];
    auto t = std::make_shared&lt;LinkType&gt;(
        this-&gt;cache, Unbound, unboundCount ? (*unboundCount)++ : id, atLevel, nullptr,
        isStatic,
        trait ? std::static_pointer_cast&lt;Trait&gt;(
                    trait-&gt;instantiate(atLevel, unboundCount, cache))
              : nullptr,
        defaultType ? defaultType-&gt;instantiate(atLevel, unboundCount, cache) : nullptr,
        genericName);
    if (cache)
      (*cache)[id] = t;
    return t;
  } else if (kind == Unbound) {
    return shared_from_this();
  } else {
    seqassert(type, "link is null");
    return type-&gt;instantiate(atLevel, unboundCount, cache);
  }
}

TypePtr LinkType::follow() {
  if (kind == Link)
    return type-&gt;follow();
  else
    return shared_from_this();
}

std::vector&lt;TypePtr&gt; LinkType::getUnbounds() const {
  if (kind == Unbound)
    return {std::const_pointer_cast&lt;Type&gt;(shared_from_this())};
  else if (kind == Link)
    return type-&gt;getUnbounds();
  return {};
}

</t>
<t tx="ekr.20230509083243.533">bool LinkType::canRealize() const {
  if (kind != Link)
    return false;
  else
    return type-&gt;canRealize();
}

</t>
<t tx="ekr.20230509083243.534">bool LinkType::isInstantiated() const { return kind == Link &amp;&amp; type-&gt;isInstantiated(); }

std::string LinkType::debugString(char mode) const {
  if (kind == Unbound || kind == Generic) {
    if (mode == 2) {
      return fmt::format("{}{}{}", kind == Unbound ? '?' : '#', id,
                         trait ? ":" + trait-&gt;debugString(mode) : "");
    }
    if (trait)
      return trait-&gt;debugString(mode);
    return (genericName.empty() ? (mode ? "?" : "&lt;unknown type&gt;") : genericName);
  }
  return type-&gt;debugString(mode);
}

std::string LinkType::realizedName() const {
  if (kind == Unbound || kind == Generic)
    return "?";
  seqassert(kind == Link, "unexpected generic link");
  return type-&gt;realizedName();
}

std::shared_ptr&lt;LinkType&gt; LinkType::getLink() {
  return std::static_pointer_cast&lt;LinkType&gt;(shared_from_this());
}

std::shared_ptr&lt;FuncType&gt; LinkType::getFunc() {
  return kind == Link ? type-&gt;getFunc() : nullptr;
}

std::shared_ptr&lt;PartialType&gt; LinkType::getPartial() {
  return kind == Link ? type-&gt;getPartial() : nullptr;
}

std::shared_ptr&lt;ClassType&gt; LinkType::getClass() {
  return kind == Link ? type-&gt;getClass() : nullptr;
}

std::shared_ptr&lt;RecordType&gt; LinkType::getRecord() {
  return kind == Link ? type-&gt;getRecord() : nullptr;
}

std::shared_ptr&lt;StaticType&gt; LinkType::getStatic() {
  return kind == Link ? type-&gt;getStatic() : nullptr;
}

std::shared_ptr&lt;UnionType&gt; LinkType::getUnion() {
  return kind == Link ? type-&gt;getUnion() : nullptr;
}

std::shared_ptr&lt;LinkType&gt; LinkType::getUnbound() {
  if (kind == Unbound)
    return std::static_pointer_cast&lt;LinkType&gt;(shared_from_this());
  if (kind == Link)
    return type-&gt;getUnbound();
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.535">bool LinkType::occurs(Type *typ, Type::Unification *undo) {
  if (auto tl = typ-&gt;getLink()) {
    if (tl-&gt;kind == Unbound) {
      if (tl-&gt;id == id)
        return true;
      if (tl-&gt;trait &amp;&amp; occurs(tl-&gt;trait.get(), undo))
        return true;
      if (undo &amp;&amp; tl-&gt;level &gt; level) {
        undo-&gt;leveled.emplace_back(make_pair(tl.get(), tl-&gt;level));
        tl-&gt;level = level;
      }
      return false;
    } else if (tl-&gt;kind == Link) {
      return occurs(tl-&gt;type.get(), undo);
    } else {
      return false;
    }
  } else if (auto ts = typ-&gt;getStatic()) {
    for (auto &amp;g : ts-&gt;generics)
      if (g.type &amp;&amp; occurs(g.type.get(), undo))
        return true;
    return false;
  }
  if (auto tc = typ-&gt;getClass()) {
    for (auto &amp;g : tc-&gt;generics)
      if (g.type &amp;&amp; occurs(g.type.get(), undo))
        return true;
    if (auto tr = typ-&gt;getRecord())
      for (auto &amp;t : tr-&gt;args)
        if (occurs(t.get(), undo))
          return true;
    return false;
  } else {
    return false;
  }
}

</t>
<t tx="ekr.20230509083243.536">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/traits.h"
#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

struct LinkType : public Type {
  /// Enumeration describing the current state.
  enum Kind { Unbound, Generic, Link } kind;
  /// The unique identifier of an unbound or generic type.
  int id;
  /// The type-checking level of an unbound type.
  int level;
  /// The type to which LinkType points to. nullptr if unknown (unbound or generic).
  TypePtr type;
  /// &gt;0 if a type is a static type (e.g. N in Int[N: int]); 0 otherwise.
  char isStatic;
  /// Optional trait that unbound type requires prior to unification.
  std::shared_ptr&lt;Trait&gt; trait;
  /// The generic name of a generic type, if applicable. Used for pretty-printing.
  std::string genericName;
  /// Type that will be used if an unbound is not resolved.
  TypePtr defaultType;

public:
  LinkType(Cache *cache, Kind kind, int id, int level = 0, TypePtr type = nullptr,
           char isStatic = 0, std::shared_ptr&lt;Trait&gt; trait = nullptr,
           TypePtr defaultType = nullptr, std::string genericName = "");
  /// Convenience constructor for linked types.
  explicit LinkType(TypePtr type);

public:
  int unify(Type *typ, Unification *undodo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  TypePtr follow() override;
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  std::shared_ptr&lt;LinkType&gt; getLink() override;
  std::shared_ptr&lt;FuncType&gt; getFunc() override;
  std::shared_ptr&lt;PartialType&gt; getPartial() override;
  std::shared_ptr&lt;ClassType&gt; getClass() override;
  std::shared_ptr&lt;RecordType&gt; getRecord() override;
  std::shared_ptr&lt;StaticType&gt; getStatic() override;
  std::shared_ptr&lt;UnionType&gt; getUnion() override;
  std::shared_ptr&lt;LinkType&gt; getUnbound() override;

private:
  /// Checks if a current (unbound) type occurs within a given type.
  /// Needed to prevent a recursive unification (e.g. ?1 with list[?1]).
  bool occurs(Type *typ, Type::Unification *undo);
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.537">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/ast/types/static.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

StaticType::StaticType(Cache *cache, const std::shared_ptr&lt;Expr&gt; &amp;e)
    : Type(cache), expr(e-&gt;clone()) {
  if (!expr-&gt;isStatic() || !expr-&gt;staticValue.evaluated) {
    std::unordered_set&lt;std::string&gt; seen;
    parseExpr(expr, seen);
  }
}

StaticType::StaticType(Cache *cache, std::vector&lt;ClassType::Generic&gt; generics,
@others
} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.538">                       const std::shared_ptr&lt;Expr&gt; &amp;e)
    : Type(cache), generics(std::move(generics)), expr(e-&gt;clone()) {}

StaticType::StaticType(Cache *cache, int64_t i)
    : Type(cache), expr(std::make_shared&lt;IntExpr&gt;(i)) {}

StaticType::StaticType(Cache *cache, const std::string &amp;s)
    : Type(cache), expr(std::make_shared&lt;StringExpr&gt;(s)) {}

  @others
</t>
<t tx="ekr.20230509083243.539">int StaticType::unify(Type *typ, Unification *us) {
if (auto t = typ-&gt;getStatic()) {
  if (canRealize())
    expr-&gt;staticValue = evaluate();
  if (t-&gt;canRealize())
    t-&gt;expr-&gt;staticValue = t-&gt;evaluate();
  // Check if both types are already evaluated.
  if (expr-&gt;staticValue.type != t-&gt;expr-&gt;staticValue.type)
    return -1;
  if (expr-&gt;staticValue.evaluated &amp;&amp; t-&gt;expr-&gt;staticValue.evaluated)
    return expr-&gt;staticValue == t-&gt;expr-&gt;staticValue ? 2 : -1;
  else if (expr-&gt;staticValue.evaluated &amp;&amp; !t-&gt;expr-&gt;staticValue.evaluated)
    return typ-&gt;unify(this, us);

  // Right now, *this is not evaluated
  // Let us see can we unify it with other _if_ it is a simple IdExpr?
  if (expr-&gt;getId() &amp;&amp; t-&gt;expr-&gt;staticValue.evaluated) {
    return generics[0].type-&gt;unify(typ, us);
  }

  // At this point, *this is a complex expression (e.g. A+1).
  seqassert(!generics.empty(), "unevaluated simple expression");
  if (generics.size() != t-&gt;generics.size())
    return -1;

  int s1 = 2, s = 0;
  if (!(expr-&gt;getId() &amp;&amp; t-&gt;expr-&gt;getId()) &amp;&amp; expr-&gt;toString() != t-&gt;expr-&gt;toString())
    return -1;
  for (int i = 0; i &lt; generics.size(); i++) {
    if ((s = generics[i].type-&gt;unify(t-&gt;generics[i].type.get(), us)) == -1)
      return -1;
    s1 += s;
  }
  return s1;
} else if (auto tl = typ-&gt;getLink()) {
  return tl-&gt;unify(this, us);
}
return -1;
}

</t>
<t tx="ekr.20230509083243.54">fields.clear();
for (auto i = 0; i &lt; mTypes.size(); ++i) {
  fields.emplace_back(mNames[i], mTypes[i]);
}
}

</t>
<t tx="ekr.20230509083243.540">TypePtr StaticType::generalize(int atLevel) {
  auto e = generics;
  for (auto &amp;t : e)
    t.type = t.type ? t.type-&gt;generalize(atLevel) : nullptr;
  auto c = std::make_shared&lt;StaticType&gt;(cache, e, expr);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

TypePtr StaticType::instantiate(int atLevel, int *unboundCount,
                                std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto e = generics;
  for (auto &amp;t : e)
    t.type = t.type ? t.type-&gt;instantiate(atLevel, unboundCount, cache) : nullptr;
  auto c = std::make_shared&lt;StaticType&gt;(this-&gt;cache, e, expr);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

std::vector&lt;TypePtr&gt; StaticType::getUnbounds() const {
  std::vector&lt;TypePtr&gt; u;
  for (auto &amp;t : generics)
    if (t.type) {
      auto tu = t.type-&gt;getUnbounds();
      u.insert(u.begin(), tu.begin(), tu.end());
    }
  return u;
}

</t>
<t tx="ekr.20230509083243.541">bool StaticType::canRealize() const {
  if (!expr-&gt;staticValue.evaluated)
    for (auto &amp;t : generics)
      if (t.type &amp;&amp; !t.type-&gt;canRealize())
        return false;
  return true;
}

</t>
<t tx="ekr.20230509083243.542">bool StaticType::isInstantiated() const { return expr-&gt;staticValue.evaluated; }

std::string StaticType::debugString(char mode) const {
  if (expr-&gt;staticValue.evaluated)
    return expr-&gt;staticValue.toString();
  if (mode == 2) {
    std::vector&lt;std::string&gt; s;
    for (auto &amp;g : generics)
      s.push_back(g.type-&gt;debugString(mode));
    return fmt::format("Static[{};{}]", join(s, ","), expr-&gt;toString());
  } else {
    return fmt::format("Static[{}]", FormatVisitor::apply(expr));
  }
}

std::string StaticType::realizedName() const {
  seqassert(canRealize(), "cannot realize {}", toString());
  std::vector&lt;std::string&gt; deps;
  for (auto &amp;e : generics)
    deps.push_back(e.type-&gt;realizedName());
  if (!expr-&gt;staticValue.evaluated) // If not already evaluated, evaluate!
    const_cast&lt;StaticType *&gt;(this)-&gt;expr-&gt;staticValue = evaluate();
  seqassert(expr-&gt;staticValue.evaluated, "static value not evaluated");
  return expr-&gt;staticValue.toString();
}

StaticValue StaticType::evaluate() const {
  if (expr-&gt;staticValue.evaluated)
    return expr-&gt;staticValue;
  cache-&gt;typeCtx-&gt;addBlock();
  for (auto &amp;g : generics)
    cache-&gt;typeCtx-&gt;add(TypecheckItem::Type, g.name, g.type);
  auto en = TypecheckVisitor(cache-&gt;typeCtx).transform(expr-&gt;clone());
  seqassert(en-&gt;isStatic() &amp;&amp; en-&gt;staticValue.evaluated, "{} cannot be evaluated", en);
  cache-&gt;typeCtx-&gt;popBlock();
  return en-&gt;staticValue;
}

</t>
<t tx="ekr.20230509083243.543">void StaticType::parseExpr(const ExprPtr &amp;e, std::unordered_set&lt;std::string&gt; &amp;seen) {
  e-&gt;type = nullptr;
  if (auto ei = e-&gt;getId()) {
    if (!in(seen, ei-&gt;value)) {
      auto val = cache-&gt;typeCtx-&gt;find(ei-&gt;value);
      seqassert(val &amp;&amp; val-&gt;type-&gt;isStaticType(), "invalid static expression");
      auto genTyp = val-&gt;type-&gt;follow();
      auto id = genTyp-&gt;getLink() ? genTyp-&gt;getLink()-&gt;id
                : genTyp-&gt;getStatic()-&gt;generics.empty()
                    ? 0
                    : genTyp-&gt;getStatic()-&gt;generics[0].id;
      generics.emplace_back(ClassType::Generic(
          ei-&gt;value, cache-&gt;typeCtx-&gt;cache-&gt;reverseIdentifierLookup[ei-&gt;value], genTyp,
          id));
      seen.insert(ei-&gt;value);
    }
  } else if (auto eu = e-&gt;getUnary()) {
    parseExpr(eu-&gt;expr, seen);
  } else if (auto eb = e-&gt;getBinary()) {
    parseExpr(eb-&gt;lexpr, seen);
    parseExpr(eb-&gt;rexpr, seen);
  } else if (auto ef = e-&gt;getIf()) {
    parseExpr(ef-&gt;cond, seen);
    parseExpr(ef-&gt;ifexpr, seen);
    parseExpr(ef-&gt;elsexpr, seen);
  }
}

</t>
<t tx="ekr.20230509083243.544">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"

namespace codon::ast {
struct StaticValue;
}

namespace codon::ast::types {

/**
 * A static integer type (e.g. N in def foo[N: int]). Usually an integer, but can point
 * to a static expression.
 */
struct StaticType : public Type {
  /// List of static variables that a type depends on
  /// (e.g. for A+B+2, generics are {A, B}).
  std::vector&lt;ClassType::Generic&gt; generics;
  /// A static expression that needs to be evaluated.
  /// Can be nullptr if there is no expression.
  std::shared_ptr&lt;Expr&gt; expr;

  StaticType(Cache *cache, std::vector&lt;ClassType::Generic&gt; generics,
             const std::shared_ptr&lt;Expr&gt; &amp;expr);
  /// Convenience function that parses expr and populates static type generics.
  StaticType(Cache *cache, const std::shared_ptr&lt;Expr&gt; &amp;expr);
  /// Convenience function for static types whose evaluation is already known.
  explicit StaticType(Cache *cache, int64_t i);
  explicit StaticType(Cache *cache, const std::string &amp;s);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  std::vector&lt;TypePtr&gt; getUnbounds() const override;
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;

  StaticValue evaluate() const;
  std::shared_ptr&lt;StaticType&gt; getStatic() override {
    return std::static_pointer_cast&lt;StaticType&gt;(shared_from_this());
  }

private:
  void parseExpr(const std::shared_ptr&lt;Expr&gt; &amp;e, std::unordered_set&lt;std::string&gt; &amp;seen);
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.545">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

Trait::Trait(const std::shared_ptr&lt;Type&gt; &amp;type) : Type(type) {}

Trait::Trait(Cache *cache) : Type(cache) {}

bool Trait::canRealize() const { return false; }

bool Trait::isInstantiated() const { return false; }

std::string Trait::realizedName() const { return ""; }

CallableTrait::CallableTrait(Cache *cache, std::vector&lt;TypePtr&gt; args)
    : Trait(cache), args(move(args)) {}

@others
TypePtr CallableTrait::generalize(int atLevel) {
  auto g = args;
  for (auto &amp;t : g)
    t = t ? t-&gt;generalize(atLevel) : nullptr;
  auto c = std::make_shared&lt;CallableTrait&gt;(cache, g);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

TypePtr CallableTrait::instantiate(int atLevel, int *unboundCount,
                                   std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto g = args;
  for (auto &amp;t : g)
    t = t ? t-&gt;instantiate(atLevel, unboundCount, cache) : nullptr;
  auto c = std::make_shared&lt;CallableTrait&gt;(this-&gt;cache, g);
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

std::string CallableTrait::debugString(char mode) const {
  auto s = args[0]-&gt;debugString(mode);
  return fmt::format("Callable[{},{}]", startswith(s, "Tuple") ? s.substr(5) : s,
                     args[1]-&gt;debugString(mode));
}

TypeTrait::TypeTrait(TypePtr typ) : Trait(typ), type(std::move(typ)) {}

int TypeTrait::unify(Type *typ, Unification *us) { return typ-&gt;unify(type.get(), us); }

TypePtr TypeTrait::generalize(int atLevel) {
  auto c = std::make_shared&lt;TypeTrait&gt;(type-&gt;generalize(atLevel));
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

TypePtr TypeTrait::instantiate(int atLevel, int *unboundCount,
                               std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto c = std::make_shared&lt;TypeTrait&gt;(type-&gt;instantiate(atLevel, unboundCount, cache));
  c-&gt;setSrcInfo(getSrcInfo());
  return c;
}

std::string TypeTrait::debugString(char mode) const {
  return fmt::format("Trait[{}]", type-&gt;debugString(mode));
}

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.546">int CallableTrait::unify(Type *typ, Unification *us) {
  if (auto tr = typ-&gt;getRecord()) {
    if (tr-&gt;name == "NoneType")
      return 1;
    if (tr-&gt;name != "Function" &amp;&amp; !tr-&gt;getPartial())
      return -1;
    if (args.empty())
      return 1;

    std::vector&lt;char&gt; known;
    auto trFun = tr;
    if (auto pt = tr-&gt;getPartial()) {
      int ic = 0;
      std::unordered_map&lt;int, TypePtr&gt; c;
      trFun = pt-&gt;func-&gt;instantiate(0, &amp;ic, &amp;c)-&gt;getRecord();
      known = pt-&gt;known;
    } else {
      known = std::vector&lt;char&gt;(tr-&gt;generics[0].type-&gt;getRecord()-&gt;args.size(), 0);
    }

    auto &amp;inArgs = args[0]-&gt;getRecord()-&gt;args;
    auto &amp;trInArgs = trFun-&gt;generics[0].type-&gt;getRecord()-&gt;args;
    auto trAst = trFun-&gt;getFunc() ? trFun-&gt;getFunc()-&gt;ast : nullptr;
    size_t star = trInArgs.size(), kwStar = trInArgs.size();
    size_t total = 0;
    if (trAst) {
      star = trAst-&gt;getStarArgs();
      kwStar = trAst-&gt;getKwStarArgs();
      if (kwStar &lt; trAst-&gt;args.size() &amp;&amp; star &gt;= trInArgs.size())
        star -= 1;
      size_t preStar = 0;
      for (size_t fi = 0; fi &lt; trAst-&gt;args.size(); fi++) {
        if (fi != kwStar &amp;&amp; !known[fi] &amp;&amp; trAst-&gt;args[fi].status == Param::Normal) {
          total++;
          if (fi &lt; star)
            preStar++;
        }
      }
      if (preStar &lt; total) {
        if (inArgs.size() &lt; preStar)
          return -1;
      } else if (inArgs.size() != total) {
        return -1;
      }
    } else {
      total = star = trInArgs.size();
      if (inArgs.size() != total)
        return -1;
    }
    size_t i = 0;
    for (size_t fi = 0; i &lt; inArgs.size() &amp;&amp; fi &lt; star; fi++) {
      if (!known[fi] &amp;&amp; trAst-&gt;args[fi].status == Param::Normal) {
        if (inArgs[i++]-&gt;unify(trInArgs[fi].get(), us) == -1)
          return -1;
      }
    }
    // NOTE: *args / **kwargs types will be typecheck when the function is called
    if (auto pf = trFun-&gt;getFunc()) {
      // Make sure to set types of *args/**kwargs so that the function that
      // is being unified with Callable[] can be realized

      if (star &lt; trInArgs.size() - (kwStar &lt; trInArgs.size())) {
        std::vector&lt;TypePtr&gt; starArgTypes;
        if (auto tp = tr-&gt;getPartial()) {
          auto ts = tp-&gt;args[tp-&gt;args.size() - 2]-&gt;getRecord();
          seqassert(ts, "bad partial *args/**kwargs");
          starArgTypes = ts-&gt;args;
        }
        starArgTypes.insert(starArgTypes.end(), inArgs.begin() + i, inArgs.end());

        auto tv = TypecheckVisitor(cache-&gt;typeCtx);
        auto name = tv.generateTuple(starArgTypes.size());
        auto t = cache-&gt;typeCtx-&gt;forceFind(name)-&gt;type;
        t = cache-&gt;typeCtx-&gt;instantiateGeneric(t, starArgTypes)-&gt;getClass();
        if (t-&gt;unify(trInArgs[star].get(), us) == -1)
          return -1;
      }
      if (kwStar &lt; trInArgs.size()) {
        std::vector&lt;std::string&gt; names;
        std::vector&lt;TypePtr&gt; starArgTypes;
        if (auto tp = tr-&gt;getPartial()) {
          auto ts = tp-&gt;args.back()-&gt;getRecord();
          seqassert(ts, "bad partial *args/**kwargs");
          auto &amp;ff = cache-&gt;classes[ts-&gt;name].fields;
          for (size_t i = 0; i &lt; ts-&gt;args.size(); i++) {
            names.emplace_back(ff[i].name);
            starArgTypes.emplace_back(ts-&gt;args[i]);
          }
        }
        auto tv = TypecheckVisitor(cache-&gt;typeCtx);
        auto name = tv.generateTuple(starArgTypes.size(), TYPE_KWTUPLE, names);
        auto t = cache-&gt;typeCtx-&gt;forceFind(name)-&gt;type;
        t = cache-&gt;typeCtx-&gt;instantiateGeneric(t, starArgTypes)-&gt;getClass();
        if (t-&gt;unify(trInArgs[kwStar].get(), us) == -1)
          return -1;
      }

      if (us &amp;&amp; pf-&gt;canRealize()) {
        // Realize if possible to allow deduction of return type
        auto rf = TypecheckVisitor(cache-&gt;typeCtx).realize(pf);
        pf-&gt;unify(rf.get(), us);
      }
      if (args[1]-&gt;unify(pf-&gt;getRetType().get(), us) == -1)
        return -1;
    }
    return 1;
  } else if (auto tl = typ-&gt;getLink()) {
    if (tl-&gt;kind == LinkType::Link)
      return unify(tl-&gt;type.get(), us);
    if (tl-&gt;kind == LinkType::Unbound) {
      if (tl-&gt;trait) {
        auto tt = dynamic_cast&lt;CallableTrait *&gt;(tl-&gt;trait.get());
        if (!tt || tt-&gt;args.size() != args.size())
          return -1;
        for (int i = 0; i &lt; args.size(); i++)
          if (args[i]-&gt;unify(tt-&gt;args[i].get(), us) == -1)
            return -1;
      }
      return 1;
    }
  }
  return -1;
}

</t>
<t tx="ekr.20230509083243.547">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/type.h"

namespace codon::ast::types {

struct Trait : public Type {
  bool canRealize() const override;
  bool isInstantiated() const override;
  std::string realizedName() const override;

protected:
  explicit Trait(const std::shared_ptr&lt;Type&gt; &amp;);
  explicit Trait(Cache *);
};

struct CallableTrait : public Trait {
  std::vector&lt;TypePtr&gt; args; // tuple with arg types, ret type

public:
  explicit CallableTrait(Cache *cache, std::vector&lt;TypePtr&gt; args);
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;
  std::string debugString(char mode) const override;
};

struct TypeTrait : public Trait {
  TypePtr type;

public:
  explicit TypeTrait(TypePtr type);
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;
  std::string debugString(char mode) const override;
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.548">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/type.h"
#include "codon/parser/visitors/format/format.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

@others
std::shared_ptr&lt;StaticType&gt; Type::makeStatic(Cache *cache, const ExprPtr &amp;expr) {
  return std::make_shared&lt;StaticType&gt;(cache, expr);
}

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.549">/// Undo a destructive unification.
void Type::Unification::undo() {
  for (size_t i = linked.size(); i-- &gt; 0;) {
    linked[i]-&gt;kind = LinkType::Unbound;
    linked[i]-&gt;type = nullptr;
  }
  for (size_t i = leveled.size(); i-- &gt; 0;) {
    seqassertn(leveled[i].first-&gt;kind == LinkType::Unbound, "not unbound [{}]",
               leveled[i].first-&gt;getSrcInfo());
    leveled[i].first-&gt;level = leveled[i].second;
  }
  for (auto &amp;t : traits)
    t-&gt;trait = nullptr;
}

</t>
<t tx="ekr.20230509083243.55">const char RefType::NodeId = 0;

</t>
<t tx="ekr.20230509083243.550">Type::Type(const std::shared_ptr&lt;Type&gt; &amp;typ) : cache(typ-&gt;cache) {
  setSrcInfo(typ-&gt;getSrcInfo());
}

Type::Type(Cache *cache, const SrcInfo &amp;info) : cache(cache) { setSrcInfo(info); }

TypePtr Type::follow() { return shared_from_this(); }

std::vector&lt;std::shared_ptr&lt;Type&gt;&gt; Type::getUnbounds() const { return {}; }

std::string Type::toString() const { return debugString(1); }

std::string Type::prettyString() const { return debugString(0); }

bool Type::is(const std::string &amp;s) { return getClass() &amp;&amp; getClass()-&gt;name == s; }

</t>
<t tx="ekr.20230509083243.551">char Type::isStaticType() {
  auto t = follow();
  if (auto s = t-&gt;getStatic())
    return char(s-&gt;expr-&gt;staticValue.type);
  if (auto l = t-&gt;getLink())
    return l-&gt;isStatic;
  return false;
}

</t>
<t tx="ekr.20230509083243.552">TypePtr Type::makeType(Cache *cache, const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.553">                       const std::string &amp;niceName, bool isRecord) {
  if (name == "Union")
    return std::make_shared&lt;UnionType&gt;(cache);
  if (isRecord)
    return std::make_shared&lt;RecordType&gt;(cache, name, niceName);
  return std::make_shared&lt;ClassType&gt;(cache, name, niceName);
}

</t>
<t tx="ekr.20230509083243.554">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/common.h"

namespace codon::ast {
struct Cache;
struct Expr;
} // namespace codon::ast

namespace codon::ast::types {

/// Forward declarations
struct FuncType;
struct ClassType;
struct LinkType;
struct RecordType;
struct PartialType;
struct StaticType;
struct UnionType;

/**
 * An abstract type class that describes methods needed for the type inference.
 * (Hindley-Milner's Algorithm W inference; see
 * https://github.com/tomprimozic/type-systems).
 *
 * Type instances are mutable and each type is intended to be instantiated and
 * manipulated as a shared_ptr.
 */
struct Type : public codon::SrcObject, public std::enable_shared_from_this&lt;Type&gt; {
  /// A structure that keeps the list of unification steps that can be undone later.
  /// Needed because the unify() is destructive.
  struct Unification {
    /// List of unbound types that have been changed.
    std::vector&lt;LinkType *&gt; linked;
    /// List of unbound types whose level has been changed.
    std::vector&lt;std::pair&lt;LinkType *, int&gt;&gt; leveled;
    /// List of assigned traits.
    std::vector&lt;LinkType *&gt; traits;
    /// List of pointers that are owned by unification process
    /// (to avoid memory issues with undoing).
    std::vector&lt;std::shared_ptr&lt;Type&gt;&gt; ownedTypes;

  public:
    /// Undo the unification step.
    void undo();
  };

public:
  /// Unifies a given type with the current type.
  /// @param typ A given type.
  /// @param undo A reference to Unification structure to track the unification steps
  ///             and allow later undoing of the unification procedure.
  /// @return Unification score: -1 for failure, anything &gt;= 0 for success.
  ///         Higher score translates to a "better" unification.
  ///  Destructive operation if undo is not null!
  ///    (both the current and a given type are modified).
  virtual int unify(Type *typ, Unification *undo) = 0;
  /// Generalize all unbound types whose level is below the provided level.
  /// This method replaces all unbound types with a generic types (e.g. ?1 -&gt; T1).
  /// Note that the generalized type keeps the unbound type's ID.
  virtual std::shared_ptr&lt;Type&gt; generalize(int atLevel) = 0;
  /// Instantiate all generic types. Inverse of generalize(): it replaces all
  /// generic types with new unbound types (e.g. T1 -&gt; ?1234).
  /// Note that the instantiated type has a distinct and unique ID.
  /// @param level Level of the instantiation.
  /// @param unboundCount A reference of the unbound counter to ensure that no two
  ///                     unbound types share the same ID.
  /// @param cache A reference to a lookup table to ensure that all instances of a
  ///              generic point to the same unbound type (e.g. dict[T, list[T]] should
  ///              be instantiated as dict[?1, list[?1]]).
  virtual std::shared_ptr&lt;Type&gt;
  instantiate(int atLevel, int *unboundCount,
              std::unordered_map&lt;int, std::shared_ptr&lt;Type&gt;&gt; *cache) = 0;

public:
  /// Get the final type (follow through all LinkType links).
  /// For example, for (a-&gt;b-&gt;c-&gt;d) it returns d.
  virtual std::shared_ptr&lt;Type&gt; follow();
  /// Obtain the list of internal unbound types.
  virtual std::vector&lt;std::shared_ptr&lt;Type&gt;&gt; getUnbounds() const;
  /// True if a type is realizable.
  virtual bool canRealize() const = 0;
  /// True if a type is completely instantiated (has no unbounds or generics).
  virtual bool isInstantiated() const = 0;
  /// Pretty-print facility.
  std::string toString() const;
  /// Pretty-print facility.
  std::string prettyString() const;
  /// Pretty-print facility. mode is [0: pretty, 1: llvm, 2: debug]
  virtual std::string debugString(char mode) const = 0;
  /// Print the realization string.
  /// Similar to toString, but does not print the data unnecessary for realization
  /// (e.g. the function return type).
  virtual std::string realizedName() const = 0;

  /// Convenience virtual functions to avoid unnecessary dynamic_cast calls.
  virtual std::shared_ptr&lt;FuncType&gt; getFunc() { return nullptr; }
  virtual std::shared_ptr&lt;PartialType&gt; getPartial() { return nullptr; }
  virtual std::shared_ptr&lt;ClassType&gt; getClass() { return nullptr; }
  virtual std::shared_ptr&lt;RecordType&gt; getRecord() { return nullptr; }
  virtual std::shared_ptr&lt;LinkType&gt; getLink() { return nullptr; }
  virtual std::shared_ptr&lt;LinkType&gt; getUnbound() { return nullptr; }
  virtual std::shared_ptr&lt;StaticType&gt; getStatic() { return nullptr; }
  virtual std::shared_ptr&lt;UnionType&gt; getUnion() { return nullptr; }
  virtual std::shared_ptr&lt;RecordType&gt; getHeterogenousTuple() { return nullptr; }

  virtual bool is(const std::string &amp;s);
  char isStaticType();

public:
  static std::shared_ptr&lt;Type&gt; makeType(Cache *, const std::string &amp;,
                                        const std::string &amp;, bool = false);
  static std::shared_ptr&lt;StaticType&gt; makeStatic(Cache *, const std::shared_ptr&lt;Expr&gt; &amp;);

protected:
  Cache *cache;
  explicit Type(const std::shared_ptr&lt;Type&gt; &amp;);
  explicit Type(Cache *, const SrcInfo &amp; = SrcInfo());
};
using TypePtr = std::shared_ptr&lt;Type&gt;;

} // namespace codon::ast::types

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.555">template &lt;typename T&gt;
struct fmt::formatter&lt;
    T, std::enable_if_t&lt;std::is_base_of&lt;codon::ast::types::Type, T&gt;::value, char&gt;&gt;
    : fmt::ostream_formatter {};

  @others
</t>
<t tx="ekr.20230509083243.556">template &lt;typename T&gt;
struct fmt::formatter&lt;
  T,
  std::enable_if_t&lt;
      std::is_convertible&lt;T, std::shared_ptr&lt;codon::ast::types::Type&gt;&gt;::value, char&gt;&gt;
  : fmt::formatter&lt;std::string_view&gt; {
char presentation = 'd';

@others
};
</t>
<t tx="ekr.20230509083243.557">constexpr auto parse(format_parse_context &amp;ctx) -&gt; decltype(ctx.begin()) {
  auto it = ctx.begin(), end = ctx.end();
  if (it != end &amp;&amp; (*it == 'p' || *it == 'd' || *it == 'D'))
    presentation = *it++;
  return it;
}

</t>
<t tx="ekr.20230509083243.558">template &lt;typename FormatContext&gt;
auto format(const T &amp;p, FormatContext &amp;ctx) const -&gt; decltype(ctx.out()) {
  if (presentation == 'p')
    return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(0) : "&lt;nullptr&gt;");
  else if (presentation == 'd')
    return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(1) : "&lt;nullptr&gt;");
  else
    return fmt::format_to(ctx.out(), "{}", p ? p-&gt;debugString(2) : "&lt;nullptr&gt;");
}
</t>
<t tx="ekr.20230509083243.559">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

namespace codon::ast::types {

UnionType::UnionType(Cache *cache) : RecordType(cache, "Union", "Union") {
  for (size_t i = 0; i &lt; 256; i++)
    pendingTypes.emplace_back(
        std::make_shared&lt;LinkType&gt;(cache, LinkType::Generic, i, 0, nullptr));
}

UnionType::UnionType(Cache *cache, const std::vector&lt;ClassType::Generic&gt; &amp;generics,
@others
} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.56">bool RefType::doIsContentAtomic() const {
  auto *contents = getContents();
  return !std::any_of(contents-&gt;begin(), contents-&gt;end(), [](auto &amp;field) {
    return field.getName().rfind(".__vtable__", 0) != 0 &amp;&amp; !field.getType()-&gt;isAtomic();
  });
}

</t>
<t tx="ekr.20230509083243.560">                     const std::vector&lt;TypePtr&gt; &amp;pendingTypes)
    : RecordType(cache, "Union", "Union", generics), pendingTypes(pendingTypes) {}

  @others
</t>
<t tx="ekr.20230509083243.561">int UnionType::unify(Type *typ, Unification *us) {
if (typ-&gt;getUnion()) {
  auto tr = typ-&gt;getUnion();
  if (!isSealed() &amp;&amp; !tr-&gt;isSealed()) {
    for (size_t i = 0; i &lt; pendingTypes.size(); i++)
      if (pendingTypes[i]-&gt;unify(tr-&gt;pendingTypes[i].get(), us) == -1)
        return -1;
    return RecordType::unify(typ, us);
  } else if (!isSealed()) {
    return tr-&gt;unify(this, us);
  } else if (!tr-&gt;isSealed()) {
    if (tr-&gt;pendingTypes[0]-&gt;getLink() &amp;&amp;
        tr-&gt;pendingTypes[0]-&gt;getLink()-&gt;kind == LinkType::Unbound)
      return RecordType::unify(tr.get(), us);
    return -1;
  }
  // Do not hard-unify if we have unbounds
  if (!canRealize() || !tr-&gt;canRealize())
    return 0;

  auto u1 = getRealizationTypes();
  auto u2 = tr-&gt;getRealizationTypes();
  if (u1.size() != u2.size())
    return -1;
  int s1 = 2, s = 0;
  for (size_t i = 0; i &lt; u1.size(); i++) {
    if ((s = u1[i]-&gt;unify(u2[i].get(), us)) == -1)
      return -1;
    s1 += s;
  }
  return s1;
} else if (auto tl = typ-&gt;getLink()) {
  return tl-&gt;unify(this, us);
}
return -1;
}

</t>
<t tx="ekr.20230509083243.562">TypePtr UnionType::generalize(int atLevel) {
  auto r = RecordType::generalize(atLevel);
  auto p = pendingTypes;
  for (auto &amp;t : p)
    t = t-&gt;generalize(atLevel);
  auto t = std::make_shared&lt;UnionType&gt;(cache, r-&gt;getClass()-&gt;generics, p);
  t-&gt;setSrcInfo(getSrcInfo());
  return t;
}

TypePtr UnionType::instantiate(int atLevel, int *unboundCount,
                               std::unordered_map&lt;int, TypePtr&gt; *cache) {
  auto r = RecordType::instantiate(atLevel, unboundCount, cache);
  auto p = pendingTypes;
  for (auto &amp;t : p)
    t = t-&gt;instantiate(atLevel, unboundCount, cache);
  auto t = std::make_shared&lt;UnionType&gt;(this-&gt;cache, r-&gt;getClass()-&gt;generics, p);
  t-&gt;setSrcInfo(getSrcInfo());
  return t;
}

std::string UnionType::debugString(char mode) const {
  if (mode == 2)
    return this-&gt;RecordType::debugString(mode);
  if (!generics[0].type-&gt;getRecord())
    return this-&gt;RecordType::debugString(mode);

  std::set&lt;std::string&gt; gss;
  for (auto &amp;a : generics[0].type-&gt;getRecord()-&gt;args)
    gss.insert(a-&gt;debugString(mode));
  std::string s;
  for (auto &amp;i : gss)
    s += "," + i;
  return fmt::format("{}{}", name, s.empty() ? "" : fmt::format("[{}]", s.substr(1)));
}

bool UnionType::canRealize() const { return isSealed() &amp;&amp; RecordType::canRealize(); }

std::string UnionType::realizedName() const {
  seqassert(canRealize(), "cannot realize {}", toString());
  std::set&lt;std::string&gt; gss;
  for (auto &amp;a : generics[0].type-&gt;getRecord()-&gt;args)
    gss.insert(a-&gt;realizedName());
  std::string s;
  for (auto &amp;i : gss)
    s += "," + i;
  return fmt::format("{}{}", name, s.empty() ? "" : fmt::format("[{}]", s.substr(1)));
}

std::string UnionType::realizedTypeName() const { return realizedName(); }

</t>
<t tx="ekr.20230509083243.563">void UnionType::addType(TypePtr typ) {
  seqassert(!isSealed(), "union already sealed");
  if (this == typ.get())
    return;
  if (auto tu = typ-&gt;getUnion()) {
    if (tu-&gt;isSealed()) {
      for (auto &amp;t : tu-&gt;generics[0].type-&gt;getRecord()-&gt;args)
        addType(t);
    } else {
      for (auto &amp;t : tu-&gt;pendingTypes) {
        if (t-&gt;getLink() &amp;&amp; t-&gt;getLink()-&gt;kind == LinkType::Unbound)
          break;
        else
          addType(t);
      }
    }
  } else {
    // Find first pending generic to which we can attach this!
    Unification us;
    for (auto &amp;t : pendingTypes)
      if (auto l = t-&gt;getLink()) {
        if (l-&gt;kind == LinkType::Unbound) {
          t-&gt;unify(typ.get(), &amp;us);
          return;
        }
      }
    E(error::Error::UNION_TOO_BIG, this);
  }
}

</t>
<t tx="ekr.20230509083243.564">bool UnionType::isSealed() const { return generics[0].type-&gt;getRecord() != nullptr; }

</t>
<t tx="ekr.20230509083243.565">void UnionType::seal() {
  seqassert(!isSealed(), "union already sealed");
  auto tv = TypecheckVisitor(cache-&gt;typeCtx);

  size_t i;
  for (i = 0; i &lt; pendingTypes.size(); i++)
    if (pendingTypes[i]-&gt;getLink() &amp;&amp;
        pendingTypes[i]-&gt;getLink()-&gt;kind == LinkType::Unbound)
      break;
  std::vector&lt;TypePtr&gt; typeSet(pendingTypes.begin(), pendingTypes.begin() + i);
  auto name = tv.generateTuple(typeSet.size());
  auto t = cache-&gt;typeCtx-&gt;instantiateGeneric(
      cache-&gt;typeCtx-&gt;forceFind(name)-&gt;type-&gt;getClass(), typeSet);
  Unification us;
  generics[0].type-&gt;unify(t.get(), &amp;us);
}

</t>
<t tx="ekr.20230509083243.566">std::vector&lt;types::TypePtr&gt; UnionType::getRealizationTypes() {
  seqassert(canRealize(), "cannot realize {}", debugString(1));
  std::map&lt;std::string, types::TypePtr&gt; unionTypes;
  for (auto &amp;u : generics[0].type-&gt;getRecord()-&gt;args)
    unionTypes[u-&gt;realizedName()] = u;
  std::vector&lt;types::TypePtr&gt; r;
  r.reserve(unionTypes.size());
  for (auto &amp;[_, t] : unionTypes)
    r.emplace_back(t);
  return r;
}

</t>
<t tx="ekr.20230509083243.567">@path C:/Repos/codon/codon/parser/ast/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast/types/class.h"

namespace codon::ast::types {

struct UnionType : public RecordType {
  std::vector&lt;TypePtr&gt; pendingTypes;

  explicit UnionType(Cache *cache);
  UnionType(Cache *, const std::vector&lt;ClassType::Generic&gt; &amp;,
            const std::vector&lt;TypePtr&gt; &amp;);

public:
  int unify(Type *typ, Unification *undo) override;
  TypePtr generalize(int atLevel) override;
  TypePtr instantiate(int atLevel, int *unboundCount,
                      std::unordered_map&lt;int, TypePtr&gt; *cache) override;

public:
  bool canRealize() const override;
  std::string debugString(char mode) const override;
  std::string realizedName() const override;
  std::string realizedTypeName() const override;
  bool isSealed() const;

  std::shared_ptr&lt;UnionType&gt; getUnion() override {
    return std::static_pointer_cast&lt;UnionType&gt;(shared_from_this());
  }

  void addType(TypePtr typ);
  void seal();
  std::vector&lt;types::TypePtr&gt; getRealizationTypes();
};

} // namespace codon::ast::types
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.568"></t>
<t tx="ekr.20230509083243.569">@path C:/Repos/codon/codon/parser/peg/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "peg.h"

#include &lt;any&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;peglib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/rules.h"
#include "codon/parser/visitors/format/format.h"

double totalPeg = 0.0;

namespace codon::ast {

static std::shared_ptr&lt;peg::Grammar&gt; grammar(nullptr);
static std::shared_ptr&lt;peg::Grammar&gt; ompGrammar(nullptr);

std::shared_ptr&lt;peg::Grammar&gt; initParser() {
  auto g = std::make_shared&lt;peg::Grammar&gt;();
  init_codon_rules(*g);
  init_codon_actions(*g);
  ~(*g)["NLP"] &lt;=
      peg::usr([](const char *s, size_t n, peg::SemanticValues &amp;, std::any &amp;dt) {
        auto e = (n &gt;= 1 &amp;&amp; s[0] == '\\' ? 1 : -1);
        if (std::any_cast&lt;ParseContext &amp;&gt;(dt).parens &amp;&amp; e == -1)
          e = 0;
        return e;
      });
  for (auto &amp;x : *g) {
    auto v = peg::LinkReferences(*g, x.second.params);
    x.second.accept(v);
  }
  (*g)["program"].enablePackratParsing = true;
  (*g)["fstring"].enablePackratParsing = true;
  for (auto &amp;rule : std::vector&lt;std::string&gt;{
           "arguments", "slices", "genexp", "parentheses", "star_parens", "generics",
           "with_parens_item", "params", "from_as_parens", "from_params"}) {
    (*g)[rule].enter = [](const peg::Context &amp;, const char *, size_t, std::any &amp;dt) {
      std::any_cast&lt;ParseContext &amp;&gt;(dt).parens++;
    };
    (*g)[rule.c_str()].leave = [](const peg::Context &amp;, const char *, size_t, size_t,
                                  std::any &amp;, std::any &amp;dt) {
      std::any_cast&lt;ParseContext &amp;&gt;(dt).parens--;
    };
  }
  return g;
}

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.57">@path C:/Repos/codon/codon/cir/types/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;algorithm&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/cir/base.h"
#include "codon/cir/util/packs.h"
#include "codon/cir/util/visitor.h"
#include "codon/parser/ast.h"
#include &lt;fmt/format.h&gt;
#include &lt;fmt/ostream.h&gt;

namespace codon {
namespace ir {

class Value;

namespace types {

class Type;

@others
} // namespace types
} // namespace ir
} // namespace codon

template &lt;&gt; struct fmt::formatter&lt;codon::ir::types::Type&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.570">template &lt;typename T&gt;
T parseCode(Cache *cache, const std::string &amp;file, const std::string &amp;code,
  @others
</t>
<t tx="ekr.20230509083243.571">          int line_offset, int col_offset, const std::string &amp;rule) {
Timer t("");
t.logged = true;
// Initialize
if (!grammar)
  grammar = initParser();

std::vector&lt;std::tuple&lt;size_t, size_t, std::string&gt;&gt; errors;
@others
return result;
}

</t>
<t tx="ekr.20230509083243.572">auto log = [&amp;](size_t line, size_t col, const std::string &amp;msg, const std::string &amp;) {
  size_t ed = msg.size();
  if (startswith(msg, "syntax error, unexpected")) {
    auto i = msg.find(", expecting");
    if (i != std::string::npos)
      ed = i;
  }
  errors.emplace_back(line, col, msg.substr(0, ed));
};
</t>
<t tx="ekr.20230509083243.573">T result;
auto ctx = std::make_any&lt;ParseContext&gt;(cache, 0, line_offset, col_offset);
</t>
<t tx="ekr.20230509083243.574">auto r = (*grammar)[rule].parse_and_get_value(code.c_str(), code.size(), ctx, result,
                                              file.c_str(), log);
auto ret = r.ret &amp;&amp; r.len == code.size();
if (!ret)
  r.error_info.output_log(log, code.c_str(), code.size());
totalPeg += t.elapsed();
exc::ParserException ex;
if (!errors.empty()) {
  for (auto &amp;e : errors)
    ex.track(fmt::format("{}", std::get&lt;2&gt;(e)),
             SrcInfo(file, std::get&lt;0&gt;(e), std::get&lt;1&gt;(e), 0));
  throw ex;
  return T();
}
</t>
<t tx="ekr.20230509083243.575">StmtPtr parseCode(Cache *cache, const std::string &amp;file, const std::string &amp;code,
</t>
<t tx="ekr.20230509083243.576">                  int line_offset) {
  return parseCode&lt;StmtPtr&gt;(cache, file, code + "\n", line_offset, 0, "program");
}

</t>
<t tx="ekr.20230509083243.577">std::pair&lt;ExprPtr, std::string&gt; parseExpr(Cache *cache, const std::string &amp;code,
</t>
<t tx="ekr.20230509083243.578">                                          const codon::SrcInfo &amp;offset) {
  auto newCode = code;
  ltrim(newCode);
  rtrim(newCode);
</t>
<t tx="ekr.20230509083243.579">  auto e = parseCode&lt;std::pair&lt;ExprPtr, std::string&gt;&gt;(
      cache, offset.file, newCode, offset.line, offset.col, "fstring");
  return e;
}

StmtPtr parseFile(Cache *cache, const std::string &amp;file) {
  std::vector&lt;std::string&gt; lines;
  std::string code;
  if (file == "-") {
    for (std::string line; getline(std::cin, line);) {
      lines.push_back(line);
      code += line + "\n";
    }
  } else {
    std::ifstream fin(file);
    if (!fin)
      E(error::Error::COMPILER_NO_FILE, SrcInfo(), file);
    for (std::string line; getline(fin, line);) {
      lines.push_back(line);
      code += line + "\n";
    }
    fin.close();
  }

  cache-&gt;imports[file].content = lines;
  auto result = parseCode(cache, file, code);
  // For debugging purposes:
  // LOG("peg/{} :=  {}", file, result);
  return result;
}

</t>
<t tx="ekr.20230509083243.58">class Generic {
private:
  union {
    int64_t staticValue;
    char *staticStringValue;
    types::Type *typeValue;
  } value;
  enum { STATIC, STATIC_STR, TYPE } tag;

public:
  Generic(int64_t staticValue) : value(), tag(STATIC) {
    value.staticValue = staticValue;
  }
  Generic(const std::string &amp;staticValue) : value(), tag(STATIC_STR) {
    value.staticStringValue = new char[staticValue.size() + 1];
    strncpy(value.staticStringValue, staticValue.data(), staticValue.size());
    value.staticStringValue[staticValue.size()] = 0;
  }
  Generic(types::Type *typeValue) : value(), tag(TYPE) { value.typeValue = typeValue; }
  Generic(const types::Generic &amp;) = default;
  ~Generic() {
    // if (tag == STATIC_STR)
    //   delete[] value.staticStringValue;
  }

  /// @return true if the generic is a type
  bool isType() const { return tag == TYPE; }
  /// @return true if the generic is static
  bool isStatic() const { return tag == STATIC; }
  /// @return true if the generic is static
  bool isStaticStr() const { return tag == STATIC_STR; }

  /// @return the static value
  int64_t getStaticValue() const { return value.staticValue; }
  /// @return the static string value
  std::string getStaticStringValue() const { return value.staticStringValue; }
  /// @return the type value
  types::Type *getTypeValue() const { return value.typeValue; }
};

</t>
<t tx="ekr.20230509083243.580">std::shared_ptr&lt;peg::Grammar&gt; initOpenMPParser() {
  auto g = std::make_shared&lt;peg::Grammar&gt;();
  init_omp_rules(*g);
  init_omp_actions(*g);
  for (auto &amp;x : *g) {
    auto v = peg::LinkReferences(*g, x.second.params);
    x.second.accept(v);
  }
  (*g)["pragma"].enablePackratParsing = true;
  return g;
}

std::vector&lt;CallExpr::Arg&gt; parseOpenMP(Cache *cache, const std::string &amp;code,
</t>
<t tx="ekr.20230509083243.581">                                       const codon::SrcInfo &amp;loc) {
  if (!ompGrammar)
    ompGrammar = initOpenMPParser();

  std::vector&lt;std::tuple&lt;size_t, size_t, std::string&gt;&gt; errors;
  @others
  return result;
}

</t>
<t tx="ekr.20230509083243.582">auto log = [&amp;](size_t line, size_t col, const std::string &amp;msg, const std::string &amp;) {
  errors.emplace_back(line, col, msg);
};
</t>
<t tx="ekr.20230509083243.583">std::vector&lt;CallExpr::Arg&gt; result;
auto ctx = std::make_any&lt;ParseContext&gt;(cache, 0, 0, 0);
</t>
<t tx="ekr.20230509083243.584">auto r = (*ompGrammar)["pragma"].parse_and_get_value(code.c_str(), code.size(), ctx,
                                                     result, "", log);
auto ret = r.ret &amp;&amp; r.len == code.size();
if (!ret)
  r.error_info.output_log(log, code.c_str(), code.size());
exc::ParserException ex;
if (!errors.empty()) {
  ex.track(fmt::format("openmp {}", std::get&lt;2&gt;(errors[0])), loc);
  throw ex;
}
</t>
<t tx="ekr.20230509083243.585">@path C:/Repos/codon/codon/parser/peg/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/util/common.h"

namespace codon::ast {

/// Parse a Seq code block with the appropriate file and position offsets.
StmtPtr parseCode(Cache *cache, const std::string &amp;file, const std::string &amp;code,
                  int line_offset = 0);
/// Parse a Seq code expression.
/// @return pair of ExprPtr and a string indicating format specification
/// (empty if not available).
std::pair&lt;ExprPtr, std::string&gt; parseExpr(Cache *cache, const std::string &amp;code,
                                          const codon::SrcInfo &amp;offset);
/// Parse a Seq file.
StmtPtr parseFile(Cache *cache, const std::string &amp;file);

/// Parse a OpenMP clause.
std::vector&lt;CallExpr::Arg&gt; parseOpenMP(Cache *cache, const std::string &amp;code,
                                       const codon::SrcInfo &amp;loc);

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.586">@path C:/Repos/codon/codon/parser/peg/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;any&gt;
#include &lt;cstdio&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;peglib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"

namespace codon::ast {

struct ParseContext {
  Cache *cache;
  std::stack&lt;int&gt; indent;
  int parens;
  int line_offset, col_offset;
  ParseContext(Cache *cache, int parens = 0, int line_offset = 0, int col_offset = 0)
      : cache(cache), parens(parens), line_offset(line_offset), col_offset(col_offset) {
  }

@others
};

} // namespace codon::ast

void init_codon_rules(peg::Grammar &amp;);
void init_codon_actions(peg::Grammar &amp;);
void init_omp_rules(peg::Grammar &amp;);
void init_omp_actions(peg::Grammar &amp;);
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.587">  bool hasCustomStmtKeyword(const std::string &amp;kwd, bool hasExpr) const {
    auto i = cache-&gt;customBlockStmts.find(kwd);
    if (i != cache-&gt;customBlockStmts.end())
      return i-&gt;second.first == hasExpr;
    return false;
  }
</t>
<t tx="ekr.20230509083243.588">  bool hasCustomExprStmt(const std::string &amp;kwd) const {
    return in(cache-&gt;customExprStmts, kwd);
  }
</t>
<t tx="ekr.20230509083243.589"></t>
<t tx="ekr.20230509083243.59">/// Type from which other CIR types derive. Generally types are immutable.
class Type : public ReplaceableNodeBase&lt;Type&gt; {
private:
  ast::types::TypePtr astType;

public:
  static const char NodeId;

  using ReplaceableNodeBase::ReplaceableNodeBase;

  virtual ~Type() noexcept = default;

  std::vector&lt;Type *&gt; getUsedTypes() const final {
    return getActual()-&gt;doGetUsedTypes();
  }
@others
  using Node::replaceUsedType;

  /// @param other another type
  /// @return true if this type is equal to the argument type
  bool is(types::Type *other) const { return getName() == other-&gt;getName(); }

  /// A type is "atomic" iff it contains no pointers to dynamically
  /// allocated memory. Atomic types do not need to be scanned during
  /// garbage collection.
  /// @return true if the type is atomic
  bool isAtomic() const { return getActual()-&gt;doIsAtomic(); }

  /// Checks if the contents (i.e. within an allocated block of memory)
  /// of a type are atomic. Currently only meaningful for reference types.
  /// @return true if the type's content is atomic
  bool isContentAtomic() const { return getActual()-&gt;doIsContentAtomic(); }

  /// @return the ast type
  ast::types::TypePtr getAstType() const { return getActual()-&gt;astType; }
  /// Sets the ast type. Should not generally be used.
  /// @param t the new type
  void setAstType(ast::types::TypePtr t) { getActual()-&gt;astType = std::move(t); }

  /// @return the generics used in the type
  std::vector&lt;Generic&gt; getGenerics() const { return getActual()-&gt;doGetGenerics(); }

  /// Constructs an instance of the type given the supplied args.
  /// @param args the arguments
  /// @return the new value
  Value *construct(std::vector&lt;Value *&gt; args) {
    return getActual()-&gt;doConstruct(std::move(args));
  }
  template &lt;typename... Args&gt; Value *operator()(Args &amp;&amp;...args) {
    std::vector&lt;Value *&gt; dst;
    util::stripPack(dst, std::forward&lt;Args&gt;(args)...);
    return construct(dst);
  }

private:
  virtual std::vector&lt;Generic&gt; doGetGenerics() const;

  virtual std::vector&lt;Type *&gt; doGetUsedTypes() const { return {}; }
  virtual bool doIsAtomic() const = 0;
  virtual bool doIsContentAtomic() const { return true; }

  virtual Value *doConstruct(std::vector&lt;Value *&gt; args);
};

</t>
<t tx="ekr.20230509083243.590">@path C:/Repos/codon/codon/parser/visitors/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "visitor.h"

#include "codon/parser/ast.h"

namespace codon::ast {

void ASTVisitor::defaultVisit(Expr *expr) {}
void ASTVisitor::defaultVisit(Stmt *stmt) {}

void ASTVisitor::visit(NoneExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(BoolExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(IntExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(FloatExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(StringExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(IdExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(StarExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(KeywordStarExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(TupleExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(ListExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(SetExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(DictExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(GeneratorExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(DictGeneratorExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(IfExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(UnaryExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(BinaryExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(ChainBinaryExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(PipeExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(IndexExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(CallExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(DotExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(SliceExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(EllipsisExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(LambdaExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(YieldExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(AssignExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(RangeExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(InstantiateExpr *expr) { defaultVisit(expr); }
void ASTVisitor::visit(StmtExpr *expr) { defaultVisit(expr); }

void ASTVisitor::visit(SuiteStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(BreakStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ContinueStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ExprStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(AssignStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(AssignMemberStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(DelStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(PrintStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ReturnStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(YieldStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(AssertStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(WhileStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ForStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(IfStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(MatchStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ImportStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(TryStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(GlobalStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ThrowStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(FunctionStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(ClassStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(YieldFromStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(WithStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(CustomStmt *stmt) { defaultVisit(stmt); }
void ASTVisitor::visit(CommentStmt *stmt) { defaultVisit(stmt); }

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.591">@path C:/Repos/codon/codon/parser/visitors/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/compiler/error.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"

namespace codon::ast {

/**
 * Base Seq AST visitor.
 * Each visit() by default calls an appropriate defaultVisit().
 */
struct ASTVisitor {
protected:
  /// Default expression node visitor if a particular visitor is not overloaded.
  virtual void defaultVisit(Expr *expr);
  /// Default statement node visitor if a particular visitor is not overloaded.
  virtual void defaultVisit(Stmt *stmt);

public:
  virtual void visit(NoneExpr *);
  virtual void visit(BoolExpr *);
  virtual void visit(IntExpr *);
  virtual void visit(FloatExpr *);
  virtual void visit(StringExpr *);
  virtual void visit(IdExpr *);
  virtual void visit(StarExpr *);
  virtual void visit(KeywordStarExpr *);
  virtual void visit(TupleExpr *);
  virtual void visit(ListExpr *);
  virtual void visit(SetExpr *);
  virtual void visit(DictExpr *);
  virtual void visit(GeneratorExpr *);
  virtual void visit(DictGeneratorExpr *);
  virtual void visit(IfExpr *);
  virtual void visit(UnaryExpr *);
  virtual void visit(BinaryExpr *);
  virtual void visit(ChainBinaryExpr *);
  virtual void visit(PipeExpr *);
  virtual void visit(IndexExpr *);
  virtual void visit(CallExpr *);
  virtual void visit(DotExpr *);
  virtual void visit(SliceExpr *);
  virtual void visit(EllipsisExpr *);
  virtual void visit(LambdaExpr *);
  virtual void visit(YieldExpr *);
  virtual void visit(AssignExpr *);
  virtual void visit(RangeExpr *);
  virtual void visit(InstantiateExpr *);
  virtual void visit(StmtExpr *);

  virtual void visit(AssignMemberStmt *);
  virtual void visit(SuiteStmt *);
  virtual void visit(BreakStmt *);
  virtual void visit(ContinueStmt *);
  virtual void visit(ExprStmt *);
  virtual void visit(AssignStmt *);
  virtual void visit(DelStmt *);
  virtual void visit(PrintStmt *);
  virtual void visit(ReturnStmt *);
  virtual void visit(YieldStmt *);
  virtual void visit(AssertStmt *);
  virtual void visit(WhileStmt *);
  virtual void visit(ForStmt *);
  virtual void visit(IfStmt *);
  virtual void visit(MatchStmt *);
  virtual void visit(ImportStmt *);
  virtual void visit(TryStmt *);
  virtual void visit(GlobalStmt *);
  virtual void visit(ThrowStmt *);
  virtual void visit(FunctionStmt *);
  virtual void visit(ClassStmt *);
  virtual void visit(YieldFromStmt *);
  virtual void visit(WithStmt *);
  virtual void visit(CustomStmt *);
  virtual void visit(CommentStmt *);
};

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.592">template &lt;typename TE, typename TS&gt;
/**
 * Callback AST visitor.
 * This visitor extends base ASTVisitor and stores node's source location (SrcObject).
 * Function simplify() will visit a node and return the appropriate transformation. As
 * each node type (expression or statement) might return a different type,
 * this visitor is generic for each different return type.
 */
struct CallbackASTVisitor : public ASTVisitor, public SrcObject {
  virtual TE transform(const std::shared_ptr&lt;Expr&gt; &amp;expr) = 0;
  virtual TE transform(std::shared_ptr&lt;Expr&gt; &amp;expr) {
    return transform(static_cast&lt;const std::shared_ptr&lt;Expr&gt; &amp;&gt;(expr));
  }
  virtual TS transform(const std::shared_ptr&lt;Stmt&gt; &amp;stmt) = 0;
  virtual TS transform(std::shared_ptr&lt;Stmt&gt; &amp;stmt) {
    return transform(static_cast&lt;const std::shared_ptr&lt;Stmt&gt; &amp;&gt;(stmt));
  }

  /// Convenience method that transforms a vector of nodes.
  template &lt;typename T&gt; auto transform(const std::vector&lt;T&gt; &amp;ts) {
    std::vector&lt;T&gt; r;
    for (auto &amp;e : ts)
      r.push_back(transform(e));
    return r;
  }

  /// Convenience method that constructs a clone of a node.
  template &lt;typename Tn&gt; auto N(const Tn &amp;ptr) { return std::make_shared&lt;Tn&gt;(ptr); }
  /// Convenience method that constructs a node.
  /// @param s source location.
  template &lt;typename Tn, typename... Ts&gt; auto N(codon::SrcInfo s, Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(s);
    return t;
  }
  /// Convenience method that constructs a node with the visitor's source location.
  template &lt;typename Tn, typename... Ts&gt; auto N(Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(getSrcInfo());
    return t;
  }
  template &lt;typename Tn, typename... Ts&gt; auto NT(Ts &amp;&amp;...args) {
    auto t = std::make_shared&lt;Tn&gt;(std::forward&lt;Ts&gt;(args)...);
    t-&gt;setSrcInfo(getSrcInfo());
    t-&gt;markType();
    return t;
  }

  /// Convenience method that raises an error at the current source location.
  template &lt;typename... TArgs&gt; void error(const char *format, TArgs &amp;&amp;...args) {
    error::raise_error(-1, getSrcInfo(), fmt::format(format, args...).c_str());
  }

  @others
};

</t>
<t tx="ekr.20230509083243.593">/// Convenience method that raises an error at the source location of p.
template &lt;typename T, typename... TArgs&gt;
void error(const T &amp;p, const char *format, TArgs &amp;&amp;...args) {
  error::raise_error(-1, p-&gt;getSrcInfo(), fmt::format(format, args...).c_str());
}

</t>
<t tx="ekr.20230509083243.594">/// Convenience method that raises an internal error.
template &lt;typename T, typename... TArgs&gt;
void internalError(const char *format, TArgs &amp;&amp;...args) {
  throw exc::ParserException(
      fmt::format("INTERNAL: {}", fmt::format(format, args...), getSrcInfo()));
}

</t>
<t tx="ekr.20230509083243.595">public:
</t>
<t tx="ekr.20230509083243.596">void visit(NoneExpr *expr) override {}
  @others
</t>
<t tx="ekr.20230509083243.597">  void visit(BoolExpr *expr) override {}
@others
</t>
<t tx="ekr.20230509083243.598">  void visit(IntExpr *expr) override {}
@others
</t>
<t tx="ekr.20230509083243.599">  void visit(FloatExpr *expr) override {}
  void visit(StringExpr *expr) override {}
  void visit(IdExpr *expr) override {}
  void visit(StarExpr *expr) override { transform(expr-&gt;what); }
  void visit(KeywordStarExpr *expr) override { transform(expr-&gt;what); }
  void visit(TupleExpr *expr) override {
for (auto &amp;i : expr-&gt;items)
  transform(i);
  }
</t>
<t tx="ekr.20230509083243.6">  void handle(ReturnInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *newReturn = M-&gt;Nr&lt;ReturnInstr&gt;(M-&gt;Nr&lt;VarValue&gt;(accumulator));
    see(newReturn);
    v-&gt;replaceAll(util::series(v-&gt;getValue(), newReturn));
  }

</t>
<t tx="ekr.20230509083243.60">  int replaceUsedType(const std::string &amp;name, Type *newType) final {
    seqassertn(false, "types not replaceable");
    return -1;
  }
</t>
<t tx="ekr.20230509083243.600">void visit(ListExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509083243.601">void visit(SetExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509083243.602">void visit(DictExpr *expr) override {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}
</t>
<t tx="ekr.20230509083243.603">void visit(GeneratorExpr *expr) override {
  transform(expr-&gt;expr);
  for (auto &amp;l : expr-&gt;loops) {
    transform(l.vars);
    transform(l.gen);
    for (auto &amp;c : l.conds)
      transform(c);
  }
}
</t>
<t tx="ekr.20230509083243.604">void visit(DictGeneratorExpr *expr) override {
  transform(expr-&gt;key);
  transform(expr-&gt;expr);
  for (auto &amp;l : expr-&gt;loops) {
    transform(l.vars);
    transform(l.gen);
    for (auto &amp;c : l.conds)
      transform(c);
  }
}
</t>
<t tx="ekr.20230509083243.605">void visit(IfExpr *expr) override {
  transform(expr-&gt;cond);
  transform(expr-&gt;ifexpr);
  transform(expr-&gt;elsexpr);
}
</t>
<t tx="ekr.20230509083243.606">void visit(UnaryExpr *expr) override { transform(expr-&gt;expr); }
</t>
<t tx="ekr.20230509083243.607">void visit(BinaryExpr *expr) override {
  transform(expr-&gt;lexpr);
  transform(expr-&gt;rexpr);
}
</t>
<t tx="ekr.20230509083243.608">void visit(ChainBinaryExpr *expr) override {
  for (auto &amp;e : expr-&gt;exprs)
    transform(e.second);
}
</t>
<t tx="ekr.20230509083243.609">void visit(PipeExpr *expr) override {
  for (auto &amp;e : expr-&gt;items)
    transform(e.expr);
}
</t>
<t tx="ekr.20230509083243.61">/// Type from which primitive atomic types derive.
class PrimitiveType : public AcceptorExtend&lt;PrimitiveType, Type&gt; {
public:
  static const char NodeId;

  using AcceptorExtend::AcceptorExtend;

private:
  bool doIsAtomic() const final { return true; }
};

</t>
<t tx="ekr.20230509083243.610">void visit(IndexExpr *expr) override {
  transform(expr-&gt;expr);
  transform(expr-&gt;index);
}
</t>
<t tx="ekr.20230509083243.611">void visit(CallExpr *expr) override {
  transform(expr-&gt;expr);
  for (auto &amp;a : expr-&gt;args)
    transform(a.value);
}
</t>
<t tx="ekr.20230509083243.612">void visit(DotExpr *expr) override { transform(expr-&gt;expr); }
</t>
<t tx="ekr.20230509083243.613">void visit(SliceExpr *expr) override {
  transform(expr-&gt;start);
  transform(expr-&gt;stop);
  transform(expr-&gt;step);
}
</t>
<t tx="ekr.20230509083243.614">void visit(EllipsisExpr *expr) override {}
void visit(LambdaExpr *expr) override { transform(expr-&gt;expr); }
void visit(YieldExpr *expr) override {}
void visit(AssignExpr *expr) override {
  transform(expr-&gt;var);
  transform(expr-&gt;expr);
}
</t>
<t tx="ekr.20230509083243.615">void visit(RangeExpr *expr) override {
  transform(expr-&gt;start);
  transform(expr-&gt;stop);
}
</t>
<t tx="ekr.20230509083243.616">void visit(InstantiateExpr *expr) override {
  transform(expr-&gt;typeExpr);
  for (auto &amp;e : expr-&gt;typeParams)
    transform(e);
}
</t>
<t tx="ekr.20230509083243.617">void visit(StmtExpr *expr) override {
  for (auto &amp;s : expr-&gt;stmts)
    transform(s);
  transform(expr-&gt;expr);
}
</t>
<t tx="ekr.20230509083243.618">void visit(SuiteStmt *stmt) override {
  for (auto &amp;s : stmt-&gt;stmts)
    transform(s);
}
</t>
<t tx="ekr.20230509083243.619">void visit(BreakStmt *stmt) override {}
void visit(ContinueStmt *stmt) override {}
void visit(ExprStmt *stmt) override { transform(stmt-&gt;expr); }
void visit(AssignStmt *stmt) override {
  transform(stmt-&gt;lhs);
  transform(stmt-&gt;rhs);
  transform(stmt-&gt;type);
}
</t>
<t tx="ekr.20230509083243.62">/// Int type (64-bit signed integer)
class IntType : public AcceptorExtend&lt;IntType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs an int type.
  IntType() : AcceptorExtend("int") {}
};

</t>
<t tx="ekr.20230509083243.620">void visit(AssignMemberStmt *stmt) override {
  transform(stmt-&gt;lhs);
  transform(stmt-&gt;rhs);
}
</t>
<t tx="ekr.20230509083243.621">void visit(DelStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509083243.622">void visit(PrintStmt *stmt) override {
  for (auto &amp;e : stmt-&gt;items)
    transform(e);
}
</t>
<t tx="ekr.20230509083243.623">void visit(ReturnStmt *stmt) override { transform(stmt-&gt;expr); }
void visit(YieldStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509083243.624">void visit(AssertStmt *stmt) override {
  transform(stmt-&gt;expr);
  transform(stmt-&gt;message);
}
</t>
<t tx="ekr.20230509083243.625">void visit(WhileStmt *stmt) override {
  transform(stmt-&gt;cond);
  transform(stmt-&gt;suite);
  transform(stmt-&gt;elseSuite);
}
</t>
<t tx="ekr.20230509083243.626">void visit(ForStmt *stmt) override {
  transform(stmt-&gt;var);
  transform(stmt-&gt;iter);
  transform(stmt-&gt;suite);
  transform(stmt-&gt;elseSuite);
  transform(stmt-&gt;decorator);
  for (auto &amp;a : stmt-&gt;ompArgs)
    transform(a.value);
}
</t>
<t tx="ekr.20230509083243.627">void visit(IfStmt *stmt) override {
  transform(stmt-&gt;cond);
  transform(stmt-&gt;ifSuite);
  transform(stmt-&gt;elseSuite);
}
</t>
<t tx="ekr.20230509083243.628">void visit(MatchStmt *stmt) override {
  transform(stmt-&gt;what);
  for (auto &amp;m : stmt-&gt;cases) {
    transform(m.pattern);
    transform(m.guard);
    transform(m.suite);
  }
}
</t>
<t tx="ekr.20230509083243.629">void visit(ImportStmt *stmt) override {
  transform(stmt-&gt;from);
  transform(stmt-&gt;what);
  for (auto &amp;a : stmt-&gt;args) {
    transform(a.type);
    transform(a.defaultValue);
  }
  transform(stmt-&gt;ret);
}
</t>
<t tx="ekr.20230509083243.63">/// Float type (64-bit double)
class FloatType : public AcceptorExtend&lt;FloatType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a float type.
  FloatType() : AcceptorExtend("float") {}
};

</t>
<t tx="ekr.20230509083243.630">void visit(TryStmt *stmt) override {
  transform(stmt-&gt;suite);
  for (auto &amp;a : stmt-&gt;catches) {
    transform(a.exc);
    transform(a.suite);
  }
  transform(stmt-&gt;finally);
}
</t>
<t tx="ekr.20230509083243.631">void visit(GlobalStmt *stmt) override {}
void visit(ThrowStmt *stmt) override { transform(stmt-&gt;expr); }
  @others
</t>
<t tx="ekr.20230509083243.632">  void visit(FunctionStmt *stmt) override {
transform(stmt-&gt;ret);
for (auto &amp;a : stmt-&gt;args) {
  transform(a.type);
  transform(a.defaultValue);
}
transform(stmt-&gt;suite);
for (auto &amp;d : stmt-&gt;decorators)
  transform(d);
  }
</t>
<t tx="ekr.20230509083243.633">void visit(ClassStmt *stmt) override {
  for (auto &amp;a : stmt-&gt;args) {
    transform(a.type);
    transform(a.defaultValue);
  }
  transform(stmt-&gt;suite);
  for (auto &amp;d : stmt-&gt;decorators)
    transform(d);
  for (auto &amp;d : stmt-&gt;baseClasses)
    transform(d);
  for (auto &amp;d : stmt-&gt;staticBaseClasses)
    transform(d);
}
</t>
<t tx="ekr.20230509083243.634">void visit(YieldFromStmt *stmt) override { transform(stmt-&gt;expr); }
</t>
<t tx="ekr.20230509083243.635">void visit(WithStmt *stmt) override {
  for (auto &amp;a : stmt-&gt;items)
    transform(a);
  transform(stmt-&gt;suite);
}
</t>
<t tx="ekr.20230509083243.636">void visit(CustomStmt *stmt) override {
  transform(stmt-&gt;expr);
  transform(stmt-&gt;suite);
}
</t>
<t tx="ekr.20230509083243.637"></t>
<t tx="ekr.20230509083243.638">@path C:/Repos/codon/codon/parser/visitors/doc/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "doc.h"

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/format/format.h"

using fmt::format;

namespace codon::ast {

// clang-format off
std::string json_escape(const std::string &amp;str) {
  std::string r;
  r.reserve(str.size());
  for (unsigned char c : str) {
    switch (c) {
    case '\b': r += "\\b"; break;
    case '\f': r += "\\f"; break;
    case '\n': r += "\\n"; break;
    case '\r': r += "\\r"; break;
    case '\t': r += "\\t"; break;
    case '\\': r += "\\\\"; break;
    case '"': r += "\\\""; break;
    default: r += c;
    }
  }
  return r;
}
// clang-format on

json::json() : list(false) {}
json::json(const std::string &amp;s) : list(false) { values[s] = nullptr; }
json::json(const std::string &amp;s, const std::string &amp;v) : list(false) {
  values[s] = std::make_shared&lt;json&gt;(v);
}
json::json(const std::vector&lt;std::shared_ptr&lt;json&gt;&gt; &amp;vs) : list(true) {
  for (int i = 0; i &lt; vs.size(); i++)
    values[std::to_string(i)] = vs[i];
}
json::json(const std::vector&lt;std::string&gt; &amp;vs) : list(true) {
  for (int i = 0; i &lt; vs.size(); i++)
    values[std::to_string(i)] = std::make_shared&lt;json&gt;(vs[i]);
}
json::json(const std::unordered_map&lt;std::string, std::string&gt; &amp;vs) : list(false) {
  for (auto &amp;v : vs)
    values[v.first] = std::make_shared&lt;json&gt;(v.second);
}

std::string json::toString() {
  std::vector&lt;std::string&gt; s;
  if (values.empty()) {
    return "{}";
  } else if (values.size() == 1 &amp;&amp; !values.begin()-&gt;second) {
    return fmt::format("\"{}\"", json_escape(values.begin()-&gt;first));
  } else if (list) {
    for (int i = 0; i &lt; values.size(); i++)
      s.push_back(values[std::to_string(i)]-&gt;toString());
    return fmt::format("[ {} ]", join(s, ", "));
  } else {
    for (auto &amp;v : values)
      s.push_back(
          fmt::format("\"{}\": {}", json_escape(v.first), v.second-&gt;toString()));
    return fmt::format("{{ {} }}", join(s, ", "));
  }
}

std::shared_ptr&lt;json&gt; json::get(const std::string &amp;s) {
  auto i = values.find(s);
  seqassertn(i != values.end(), "cannot find {}", s);
  return i-&gt;second;
}

std::shared_ptr&lt;json&gt; json::set(const std::string &amp;s, const std::string &amp;value) {
  return values[s] = std::make_shared&lt;json&gt;(value);
}
std::shared_ptr&lt;json&gt; json::set(const std::string &amp;s,
                                const std::shared_ptr&lt;json&gt; &amp;value) {
  return values[s] = value;
}

std::shared_ptr&lt;json&gt; DocVisitor::apply(const std::string &amp;argv0,
                                        const std::vector&lt;std::string&gt; &amp;files) {
  auto shared = std::make_shared&lt;DocShared&gt;();
  shared-&gt;argv0 = argv0;
  auto cache = std::make_unique&lt;ast::Cache&gt;(argv0);
  shared-&gt;cache = cache.get();

  auto stdlib = getImportFile(argv0, "internal", "", true, "");
  auto ast = ast::parseFile(shared-&gt;cache, stdlib-&gt;path);
  shared-&gt;modules[""] = std::make_shared&lt;DocContext&gt;(shared);
  shared-&gt;modules[""]-&gt;setFilename(stdlib-&gt;path);
  shared-&gt;j = std::make_shared&lt;json&gt;();
  for (auto &amp;s : std::vector&lt;std::string&gt;{"byte", "float", "bool", "int", "str",
                                          "pyobj", "Ptr", "Function", "Generator",
                                          "Tuple", "Int", "UInt", TYPE_OPTIONAL,
                                          "Callable", "NoneType", "__internal__"}) {
    shared-&gt;j-&gt;set(std::to_string(shared-&gt;itemID),
                   std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
                       {"kind", "class"}, {"name", s}, {"type", "type"}}));
    if (s == "Ptr" || s == "Generator" || s == TYPE_OPTIONAL)
      shared-&gt;generics[shared-&gt;itemID] = {"T"};
    if (s == "Int" || s == "UInt")
      shared-&gt;generics[shared-&gt;itemID] = {"N"};
    shared-&gt;modules[""]-&gt;add(s, std::make_shared&lt;int&gt;(shared-&gt;itemID++));
  }

  DocVisitor(shared-&gt;modules[""]).transformModule(std::move(ast));
  auto ctx = std::make_shared&lt;DocContext&gt;(shared);

  for (auto &amp;f : files) {
    auto path = getAbsolutePath(f);
    ctx-&gt;setFilename(path);
    ast = ast::parseFile(shared-&gt;cache, path);
    DocVisitor(ctx).transformModule(std::move(ast));
  }

  shared-&gt;cache = nullptr;
  return shared-&gt;j;
}

std::shared_ptr&lt;int&gt; DocContext::find(const std::string &amp;s) const {
  auto i = Context&lt;int&gt;::find(s);
  if (!i &amp;&amp; this != shared-&gt;modules[""].get())
    return shared-&gt;modules[""]-&gt;find(s);
  return i;
}

std::string getDocstr(const StmtPtr &amp;s) {
  if (auto se = s-&gt;getExpr())
    if (auto e = se-&gt;expr-&gt;getString())
      return e-&gt;getValue();
  return "";
}

std::vector&lt;StmtPtr&gt; DocVisitor::flatten(StmtPtr stmt, std::string *docstr, bool deep) {
  std::vector&lt;StmtPtr&gt; stmts;
  if (auto s = stmt-&gt;getSuite()) {
    for (int i = 0; i &lt; (deep ? s-&gt;stmts.size() : 1); i++) {
      for (auto &amp;x : flatten(std::move(s-&gt;stmts[i]), i ? nullptr : docstr, deep))
        stmts.push_back(std::move(x));
    }
  } else {
    if (docstr)
      *docstr = getDocstr(stmt);
    stmts.push_back(std::move(stmt));
  }
  return stmts;
}

std::shared_ptr&lt;json&gt; DocVisitor::transform(const ExprPtr &amp;expr) {
  DocVisitor v(ctx);
  v.setSrcInfo(expr-&gt;getSrcInfo());
  v.resultExpr = std::make_shared&lt;json&gt;();
  expr-&gt;accept(v);
  return v.resultExpr;
}

std::string DocVisitor::transform(const StmtPtr &amp;stmt) {
  DocVisitor v(ctx);
  v.setSrcInfo(stmt-&gt;getSrcInfo());
  stmt-&gt;accept(v);
  return v.resultStmt;
}

void DocVisitor::transformModule(StmtPtr stmt) {
  std::vector&lt;std::string&gt; children;
  std::string docstr;

  auto flat = flatten(std::move(stmt), &amp;docstr);
  for (int i = 0; i &lt; flat.size(); i++) {
    auto &amp;s = flat[i];
    auto id = transform(s);
    if (id.empty())
      continue;
    if (i &lt; (flat.size() - 1) &amp;&amp; CAST(s, AssignStmt)) {
      auto ds = getDocstr(flat[i + 1]);
      if (!ds.empty())
        ctx-&gt;shared-&gt;j-&gt;get(id)-&gt;set("doc", ds);
    }
    children.push_back(id);
  }

  auto id = std::to_string(ctx-&gt;shared-&gt;itemID++);
  auto ja = ctx-&gt;shared-&gt;j-&gt;set(
      id, std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
              {"kind", "module"}, {"path", ctx-&gt;getFilename()}}));
  ja-&gt;set("children", std::make_shared&lt;json&gt;(children));
  if (!docstr.empty())
    ja-&gt;set("doc", docstr);
}

void DocVisitor::visit(IntExpr *expr) {
  resultExpr = std::make_shared&lt;json&gt;(expr-&gt;value);
}

void DocVisitor::visit(IdExpr *expr) {
  auto i = ctx-&gt;find(expr-&gt;value);
  if (!i)
    error("unknown identifier {}", expr-&gt;value);
  resultExpr = std::make_shared&lt;json&gt;(*i ? std::to_string(*i) : expr-&gt;value);
}

void DocVisitor::visit(IndexExpr *expr) {
  std::vector&lt;std::shared_ptr&lt;json&gt;&gt; v;
  v.push_back(transform(expr-&gt;expr));
  if (auto tp = CAST(expr-&gt;index, TupleExpr)) {
    if (auto l = tp-&gt;items[0]-&gt;getList()) {
      for (auto &amp;e : l-&gt;items)
        v.push_back(transform(e));
      v.push_back(transform(tp-&gt;items[1]));
    } else
      for (auto &amp;e : tp-&gt;items)
        v.push_back(transform(e));
  } else {
    v.push_back(transform(expr-&gt;index));
  }
  resultExpr = std::make_shared&lt;json&gt;(v);
}

bool isValidName(const std::string &amp;s) {
  if (s.empty())
    return false;
  if (s.size() &gt; 4 &amp;&amp; s.substr(0, 2) == "__" &amp;&amp; s.substr(s.size() - 2) == "__")
    return true;
  return s[0] != '_';
}

void DocVisitor::visit(FunctionStmt *stmt) {
  int id = ctx-&gt;shared-&gt;itemID++;
  ctx-&gt;add(stmt-&gt;name, std::make_shared&lt;int&gt;(id));
  auto j = std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
      {"kind", "function"}, {"name", stmt-&gt;name}});
  j-&gt;set("pos", jsonify(stmt-&gt;getSrcInfo()));

  std::vector&lt;std::shared_ptr&lt;json&gt;&gt; args;
  std::vector&lt;std::string&gt; generics;
  for (auto &amp;a : stmt-&gt;args)
    if (a.status != Param::Normal) {
      ctx-&gt;add(a.name, std::make_shared&lt;int&gt;(0));
      generics.push_back(a.name);
      a.status = Param::Generic;
    }
  for (auto &amp;a : stmt-&gt;args)
    if (a.status != Param::Normal) {
      auto j = std::make_shared&lt;json&gt;();
      j-&gt;set("name", a.name);
      if (a.type)
        j-&gt;set("type", transform(a.type));
      if (a.defaultValue) {
        j-&gt;set("default", FormatVisitor::apply(a.defaultValue));
      }
      args.push_back(j);
    }
  j-&gt;set("generics", std::make_shared&lt;json&gt;(generics));
  bool isLLVM = false;
  for (auto &amp;d : stmt-&gt;decorators)
    if (auto e = d-&gt;getId()) {
      j-&gt;set("attrs", std::make_shared&lt;json&gt;(e-&gt;value, ""));
      isLLVM |= (e-&gt;value == "llvm");
    }
  if (stmt-&gt;ret)
    j-&gt;set("return", transform(stmt-&gt;ret));
  j-&gt;set("args", std::make_shared&lt;json&gt;(args));
  std::string docstr;
  flatten(std::move(stmt-&gt;suite), &amp;docstr);
  for (auto &amp;g : generics)
    ctx-&gt;remove(g);
  if (!docstr.empty() &amp;&amp; !isLLVM)
    j-&gt;set("doc", docstr);
  ctx-&gt;shared-&gt;j-&gt;set(std::to_string(id), j);
  resultStmt = std::to_string(id);
}

void DocVisitor::visit(ClassStmt *stmt) {
  std::vector&lt;std::string&gt; generics;
  auto j = std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
      {"name", stmt-&gt;name},
      {"kind", "class"},
      {"type", stmt-&gt;isRecord() ? "type" : "class"}});
  int id = ctx-&gt;shared-&gt;itemID++;

  bool isExtend = false;
  for (auto &amp;d : stmt-&gt;decorators)
    if (auto e = d-&gt;getId())
      isExtend |= (e-&gt;value == "extend");

  if (isExtend) {
    j-&gt;set("type", "extension");
    auto i = ctx-&gt;find(stmt-&gt;name);
    j-&gt;set("parent", std::to_string(*i));
    generics = ctx-&gt;shared-&gt;generics[*i];
  } else {
    ctx-&gt;add(stmt-&gt;name, std::make_shared&lt;int&gt;(id));
  }

  std::vector&lt;std::shared_ptr&lt;json&gt;&gt; args;
  for (auto &amp;a : stmt-&gt;args)
    if (a.status != Param::Normal) {
      a.status = Param::Generic;
      generics.push_back(a.name);
    }
  ctx-&gt;shared-&gt;generics[id] = generics;
  for (auto &amp;g : generics)
    ctx-&gt;add(g, std::make_shared&lt;int&gt;(0));
  for (auto &amp;a : stmt-&gt;args)
    if (a.status != Param::Normal) {
      auto ja = std::make_shared&lt;json&gt;();
      ja-&gt;set("name", a.name);
      if (a.type)
        ja-&gt;set("type", transform(a.type));
      args.push_back(ja);
    }
  j-&gt;set("generics", std::make_shared&lt;json&gt;(generics));
  j-&gt;set("args", std::make_shared&lt;json&gt;(args));
  j-&gt;set("pos", jsonify(stmt-&gt;getSrcInfo()));

  std::string docstr;
  std::vector&lt;std::string&gt; members;
  for (auto &amp;f : flatten(std::move(stmt-&gt;suite), &amp;docstr)) {
    if (auto ff = CAST(f, FunctionStmt)) {
      auto i = transform(f);
      if (i != "")
        members.push_back(i);
      if (isValidName(ff-&gt;name))
        ctx-&gt;remove(ff-&gt;name);
    }
  }
  for (auto &amp;g : generics)
    ctx-&gt;remove(g);
  j-&gt;set("members", std::make_shared&lt;json&gt;(members));
  if (!docstr.empty())
    j-&gt;set("doc", docstr);
  ctx-&gt;shared-&gt;j-&gt;set(std::to_string(id), j);
  resultStmt = std::to_string(id);
}

std::shared_ptr&lt;json&gt; DocVisitor::jsonify(const codon::SrcInfo &amp;s) {
  return std::make_shared&lt;json&gt;(
      std::vector&lt;std::string&gt;{std::to_string(s.line), std::to_string(s.len)});
}

void DocVisitor::visit(ImportStmt *stmt) {
  if (stmt-&gt;from-&gt;isId("C") || stmt-&gt;from-&gt;isId("python")) {
    int id = ctx-&gt;shared-&gt;itemID++;
    std::string name, lib;
    if (auto i = stmt-&gt;what-&gt;getId())
      name = i-&gt;value;
    else if (auto d = stmt-&gt;what-&gt;getDot())
      name = d-&gt;member, lib = FormatVisitor::apply(d-&gt;expr);
    else
      seqassert(false, "invalid C import statement");
    ctx-&gt;add(name, std::make_shared&lt;int&gt;(id));
    name = stmt-&gt;as.empty() ? name : stmt-&gt;as;

    auto j = std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
        {"name", name}, {"kind", "function"}, {"extern", stmt-&gt;from-&gt;getId()-&gt;value}});
    j-&gt;set("pos", jsonify(stmt-&gt;getSrcInfo()));
    std::vector&lt;std::shared_ptr&lt;json&gt;&gt; args;
    if (stmt-&gt;ret)
      j-&gt;set("return", transform(stmt-&gt;ret));
    for (auto &amp;a : stmt-&gt;args) {
      auto ja = std::make_shared&lt;json&gt;();
      ja-&gt;set("name", a.name);
      ja-&gt;set("type", transform(a.type));
      args.push_back(ja);
    }
    j-&gt;set("dylib", lib);
    j-&gt;set("args", std::make_shared&lt;json&gt;(args));
    ctx-&gt;shared-&gt;j-&gt;set(std::to_string(id), j);
    resultStmt = std::to_string(id);
    return;
  }

  std::vector&lt;std::string&gt; dirs; // Path components
  Expr *e = stmt-&gt;from.get();
  while (auto d = e-&gt;getDot()) {
    dirs.push_back(d-&gt;member);
    e = d-&gt;expr.get();
  }
  if (!e-&gt;getId() || !stmt-&gt;args.empty() || stmt-&gt;ret ||
      (stmt-&gt;what &amp;&amp; !stmt-&gt;what-&gt;getId()))
    error("invalid import statement");
  // We have an empty stmt-&gt;from in "from .. import".
  if (!e-&gt;getId()-&gt;value.empty())
    dirs.push_back(e-&gt;getId()-&gt;value);
  // Handle dots (e.g. .. in from ..m import x).
  seqassert(stmt-&gt;dots &gt;= 0, "negative dots in ImportStmt");
  for (int i = 0; i &lt; stmt-&gt;dots - 1; i++)
    dirs.emplace_back("..");
  std::string path;
  for (int i = int(dirs.size()) - 1; i &gt;= 0; i--)
    path += dirs[i] + (i ? "/" : "");
  // Fetch the import!
  auto file = getImportFile(ctx-&gt;shared-&gt;argv0, path, ctx-&gt;getFilename());
  if (!file)
    error(stmt, "cannot locate import '{}'", path);

  auto ictx = ctx;
  auto it = ctx-&gt;shared-&gt;modules.find(file-&gt;path);
  if (it == ctx-&gt;shared-&gt;modules.end()) {
    ictx = std::make_shared&lt;DocContext&gt;(ctx-&gt;shared);
    ictx-&gt;setFilename(file-&gt;path);
    auto tmp = parseFile(ctx-&gt;shared-&gt;cache, file-&gt;path);
    DocVisitor(ictx).transformModule(std::move(tmp));
  } else {
    ictx = it-&gt;second;
  }

  if (!stmt-&gt;what) {
    // TODO: implement this corner case
  } else if (stmt-&gt;what-&gt;isId("*")) {
    for (auto &amp;i : *ictx)
      ctx-&gt;add(i.first, i.second.front());
  } else {
    auto i = stmt-&gt;what-&gt;getId();
    if (auto c = ictx-&gt;find(i-&gt;value))
      ctx-&gt;add(stmt-&gt;as.empty() ? i-&gt;value : stmt-&gt;as, c);
    else
      error(stmt, "symbol '{}' not found in {}", i-&gt;value, file-&gt;path);
  }
}

void DocVisitor::visit(AssignStmt *stmt) {
  auto e = CAST(stmt-&gt;lhs, IdExpr);
  if (!e)
    return;
  int id = ctx-&gt;shared-&gt;itemID++;
  ctx-&gt;add(e-&gt;value, std::make_shared&lt;int&gt;(id));
  auto j = std::make_shared&lt;json&gt;(std::unordered_map&lt;std::string, std::string&gt;{
      {"name", e-&gt;value}, {"kind", "variable"}});
  j-&gt;set("pos", jsonify(stmt-&gt;getSrcInfo()));
  ctx-&gt;shared-&gt;j-&gt;set(std::to_string(id), j);
  resultStmt = std::to_string(id);
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.639">@path C:/Repos/codon/codon/parser/visitors/doc/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

struct json {
  // values={str -&gt; null} -&gt; string value
  // values={i -&gt; json} -&gt; list (if list=true)
  // values={...} -&gt; dictionary
  std::unordered_map&lt;std::string, std::shared_ptr&lt;json&gt;&gt; values;
  bool list;

  json();
  json(const std::string &amp;s);
  json(const std::string &amp;s, const std::string &amp;v);
  json(const std::vector&lt;std::shared_ptr&lt;json&gt;&gt; &amp;vs);
  json(const std::vector&lt;std::string&gt; &amp;vs);
  json(const std::unordered_map&lt;std::string, std::string&gt; &amp;vs);
  std::string toString();
  std::shared_ptr&lt;json&gt; get(const std::string &amp;s);
  std::shared_ptr&lt;json&gt; set(const std::string &amp;s, const std::string &amp;value);
  std::shared_ptr&lt;json&gt; set(const std::string &amp;s, const std::shared_ptr&lt;json&gt; &amp;value);
};

struct DocContext;
struct DocShared {
  int itemID = 1;
  std::shared_ptr&lt;json&gt; j;
  std::unordered_map&lt;std::string, std::shared_ptr&lt;DocContext&gt;&gt; modules;
  std::string argv0;
  Cache *cache = nullptr;
  std::unordered_map&lt;int, std::vector&lt;std::string&gt;&gt; generics;
  DocShared() {}
};

struct DocContext : public Context&lt;int&gt; {
  std::shared_ptr&lt;DocShared&gt; shared;
  explicit DocContext(std::shared_ptr&lt;DocShared&gt; shared)
      : Context&lt;int&gt;(""), shared(std::move(shared)) {}
  std::shared_ptr&lt;int&gt; find(const std::string &amp;s) const override;
};

struct DocVisitor : public CallbackASTVisitor&lt;std::shared_ptr&lt;json&gt;, std::string&gt; {
  std::shared_ptr&lt;DocContext&gt; ctx;
  std::shared_ptr&lt;json&gt; resultExpr;
  std::string resultStmt;

public:
  explicit DocVisitor(std::shared_ptr&lt;DocContext&gt; ctx) : ctx(std::move(ctx)) {}
  static std::shared_ptr&lt;json&gt; apply(const std::string &amp;argv0,
                                     const std::vector&lt;std::string&gt; &amp;files);

  std::shared_ptr&lt;json&gt; transform(const ExprPtr &amp;e) override;
  std::string transform(const StmtPtr &amp;e) override;

  void transformModule(StmtPtr stmt);
  std::shared_ptr&lt;json&gt; jsonify(const codon::SrcInfo &amp;s);
  std::vector&lt;StmtPtr&gt; flatten(StmtPtr stmt, std::string *docstr = nullptr,
                               bool deep = true);

public:
  void visit(IntExpr *) override;
  void visit(IdExpr *) override;
  void visit(IndexExpr *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  void visit(AssignStmt *) override;
  void visit(ImportStmt *) override;
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.64">/// Float32 type (32-bit float)
class Float32Type : public AcceptorExtend&lt;Float32Type, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a float32 type.
  Float32Type() : AcceptorExtend("float32") {}
};

</t>
<t tx="ekr.20230509083243.640"></t>
<t tx="ekr.20230509083243.641">@path C:/Repos/codon/codon/parser/visitors/format/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/visitors/format/format.h"

using fmt::format;

namespace codon {
namespace ast {

FormatVisitor::FormatVisitor(bool html, Cache *cache)
    : renderType(false), renderHTML(html), indent(0), cache(cache) {
  if (renderHTML) {
    header = "&lt;html&gt;&lt;head&gt;&lt;link rel=stylesheet href=code.css/&gt;&lt;/head&gt;\n&lt;body&gt;";
    header += "&lt;div class=code&gt;\n";
    footer = "\n&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;";
    nl = "&lt;hr&gt;";
    typeStart = "&lt;type&gt;";
    typeEnd = "&lt;/type&gt;";
    nodeStart = "&lt;node&gt;";
    nodeEnd = "&lt;/node&gt;";
    exprStart = "&lt;expr&gt;";
    exprEnd = "&lt;/expr&gt;";
    commentStart = "&lt;b&gt;";
    commentEnd = "&lt;/b&gt;";
    keywordStart = "&lt;b class=comment&gt;";
    keywordEnd = "&lt;/b&gt;";
    space = "&amp;nbsp";
    renderType = true;
  } else {
    space = " ";
  }
}

std::string FormatVisitor::transform(const ExprPtr &amp;expr) {
  return transform(expr.get());
}

std::string FormatVisitor::transform(const Expr *expr) {
  FormatVisitor v(renderHTML, cache);
  if (expr)
    const_cast&lt;Expr *&gt;(expr)-&gt;accept(v);
  return v.result;
}

std::string FormatVisitor::transform(const StmtPtr &amp;stmt) {
  return transform(stmt.get(), 0);
}

std::string FormatVisitor::transform(Stmt *stmt, int indent) {
  FormatVisitor v(renderHTML, cache);
  v.indent = this-&gt;indent + indent;
  if (stmt)
    stmt-&gt;accept(v);
  return (stmt &amp;&amp; stmt-&gt;getSuite() ? "" : pad(indent)) + v.result + newline();
}

std::string FormatVisitor::pad(int indent) const {
  std::string s;
  for (int i = 0; i &lt; (this-&gt;indent + indent) * 2; i++)
    s += space;
  return s;
}

std::string FormatVisitor::newline() const { return nl + "\n"; }

std::string FormatVisitor::keyword(const std::string &amp;s) const {
  return fmt::format("{}{}{}", keywordStart, s, keywordEnd);
}

/*************************************************************************************/

void FormatVisitor::visit(NoneExpr *expr) { result = renderExpr(expr, "None"); }

@others
void FormatVisitor::visit(WithStmt *stmt) {}

} // namespace ast
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.642">void FormatVisitor::visit(BoolExpr *expr) {
  result = renderExpr(expr, "{}", expr-&gt;value ? "True" : "False");
}

</t>
<t tx="ekr.20230509083243.643">void FormatVisitor::visit(IntExpr *expr) {
  result = renderExpr(expr, "{}{}", expr-&gt;value, expr-&gt;suffix);
}

</t>
<t tx="ekr.20230509083243.644">void FormatVisitor::visit(FloatExpr *expr) {
  result = renderExpr(expr, "{}{}", expr-&gt;value, expr-&gt;suffix);
}

</t>
<t tx="ekr.20230509083243.645">void FormatVisitor::visit(StringExpr *expr) {
  result = renderExpr(expr, "\"{}\"", escape(expr-&gt;getValue()));
}

</t>
<t tx="ekr.20230509083243.646">void FormatVisitor::visit(IdExpr *expr) {
  result = renderExpr(expr, "{}", expr-&gt;value);
}

</t>
<t tx="ekr.20230509083243.647">void FormatVisitor::visit(StarExpr *expr) {
  result = renderExpr(expr, "*{}", transform(expr-&gt;what));
}

</t>
<t tx="ekr.20230509083243.648">void FormatVisitor::visit(KeywordStarExpr *expr) {
  result = renderExpr(expr, "**{}", transform(expr-&gt;what));
}

</t>
<t tx="ekr.20230509083243.649">void FormatVisitor::visit(TupleExpr *expr) {
  result = renderExpr(expr, "({})", transform(expr-&gt;items));
}

</t>
<t tx="ekr.20230509083243.65">/// Bool type (8-bit unsigned integer; either 0 or 1)
class BoolType : public AcceptorExtend&lt;BoolType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a bool type.
  BoolType() : AcceptorExtend("bool") {}
};

</t>
<t tx="ekr.20230509083243.650">void FormatVisitor::visit(ListExpr *expr) {
  result = renderExpr(expr, "[{}]", transform(expr-&gt;items));
}

</t>
<t tx="ekr.20230509083243.651">void FormatVisitor::visit(InstantiateExpr *expr) {
  result = renderExpr(expr, "{}[{}]", transform(expr-&gt;typeExpr),
                      transform(expr-&gt;typeParams));
}

</t>
<t tx="ekr.20230509083243.652">void FormatVisitor::visit(SetExpr *expr) {
  result = renderExpr(expr, "{{{}}}", transform(expr-&gt;items));
}

</t>
<t tx="ekr.20230509083243.653">void FormatVisitor::visit(DictExpr *expr) {
  std::vector&lt;std::string&gt; s;
  for (auto &amp;i : expr-&gt;items)
    s.push_back(fmt::format("{}: {}", transform(i-&gt;getTuple()-&gt;items[0]),
                            transform(i-&gt;getTuple()-&gt;items[1])));
  result = renderExpr(expr, "{{{}}}", join(s, ", "));
}

</t>
<t tx="ekr.20230509083243.654">void FormatVisitor::visit(GeneratorExpr *expr) {
  std::string s;
  for (auto &amp;i : expr-&gt;loops) {
    std::string cond;
    for (auto &amp;k : i.conds)
      cond += fmt::format(" if {}", transform(k));
    s += fmt::format("for {} in {}{}", i.vars-&gt;toString(), i.gen-&gt;toString(), cond);
  }
  if (expr-&gt;kind == GeneratorExpr::ListGenerator)
    result = renderExpr(expr, "[{} {}]", transform(expr-&gt;expr), s);
  else if (expr-&gt;kind == GeneratorExpr::SetGenerator)
    result = renderExpr(expr, "{{{} {}}}", transform(expr-&gt;expr), s);
  else
    result = renderExpr(expr, "({} {})", transform(expr-&gt;expr), s);
}

</t>
<t tx="ekr.20230509083243.655">void FormatVisitor::visit(DictGeneratorExpr *expr) {
  std::string s;
  for (auto &amp;i : expr-&gt;loops) {
    std::string cond;
    for (auto &amp;k : i.conds)
      cond += fmt::format(" if {}", transform(k));

    s += fmt::format("for {} in {}{}", i.vars-&gt;toString(), i.gen-&gt;toString(), cond);
  }
  result =
      renderExpr(expr, "{{{}: {} {}}}", transform(expr-&gt;key), transform(expr-&gt;expr), s);
}

</t>
<t tx="ekr.20230509083243.656">void FormatVisitor::visit(IfExpr *expr) {
  result = renderExpr(expr, "{} if {} else {}", transform(expr-&gt;ifexpr),
                      transform(expr-&gt;cond), transform(expr-&gt;elsexpr));
}

</t>
<t tx="ekr.20230509083243.657">void FormatVisitor::visit(UnaryExpr *expr) {
  result = renderExpr(expr, "{}{}", expr-&gt;op, transform(expr-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.658">void FormatVisitor::visit(BinaryExpr *expr) {
  result = renderExpr(expr, "({} {} {})", transform(expr-&gt;lexpr), expr-&gt;op,
                      transform(expr-&gt;rexpr));
}

</t>
<t tx="ekr.20230509083243.659">void FormatVisitor::visit(PipeExpr *expr) {
  std::vector&lt;std::string&gt; items;
  for (auto &amp;l : expr-&gt;items) {
    if (!items.size())
      items.push_back(transform(l.expr));
    else
      items.push_back(l.op + " " + transform(l.expr));
  }
  result = renderExpr(expr, "({})", join(items, " "));
}

</t>
<t tx="ekr.20230509083243.66">/// Byte type (8-bit unsigned integer)
class ByteType : public AcceptorExtend&lt;ByteType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a byte type.
  ByteType() : AcceptorExtend("byte") {}
};

</t>
<t tx="ekr.20230509083243.660">void FormatVisitor::visit(IndexExpr *expr) {
  result = renderExpr(expr, "{}[{}]", transform(expr-&gt;expr), transform(expr-&gt;index));
}

</t>
<t tx="ekr.20230509083243.661">void FormatVisitor::visit(CallExpr *expr) {
  std::vector&lt;std::string&gt; args;
  for (auto &amp;i : expr-&gt;args) {
    if (i.name == "")
      args.push_back(transform(i.value));
    else
      args.push_back(fmt::format("{}: {}", i.name, transform(i.value)));
  }
  result = renderExpr(expr, "{}({})", transform(expr-&gt;expr), join(args, ", "));
}

</t>
<t tx="ekr.20230509083243.662">void FormatVisitor::visit(DotExpr *expr) {
  result = renderExpr(expr, "{} . {}", transform(expr-&gt;expr), expr-&gt;member);
}

</t>
<t tx="ekr.20230509083243.663">void FormatVisitor::visit(SliceExpr *expr) {
  std::string s;
  if (expr-&gt;start)
    s += transform(expr-&gt;start);
  s += ":";
  if (expr-&gt;stop)
    s += transform(expr-&gt;stop);
  s += ":";
  if (expr-&gt;step)
    s += transform(expr-&gt;step);
  result = renderExpr(expr, "{}", s);
}

</t>
<t tx="ekr.20230509083243.664">void FormatVisitor::visit(EllipsisExpr *expr) { result = renderExpr(expr, "..."); }

</t>
<t tx="ekr.20230509083243.665">void FormatVisitor::visit(LambdaExpr *expr) {
  result = renderExpr(expr, "{} {}: {}", keyword("lambda"), join(expr-&gt;vars, ", "),
                      transform(expr-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.666">void FormatVisitor::visit(YieldExpr *expr) { result = renderExpr(expr, "(yield)"); }

</t>
<t tx="ekr.20230509083243.667">void FormatVisitor::visit(StmtExpr *expr) {
  std::string s;
  for (int i = 0; i &lt; expr-&gt;stmts.size(); i++)
    s += format("{}{}", pad(2), transform(expr-&gt;stmts[i].get(), 2));
  result = renderExpr(expr, "({}{}{}{}{})", newline(), s, newline(), pad(2),
                      transform(expr-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.668">void FormatVisitor::visit(AssignExpr *expr) {
  result = renderExpr(expr, "({} := {})", transform(expr-&gt;var), transform(expr-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.669">void FormatVisitor::visit(SuiteStmt *stmt) {
  for (int i = 0; i &lt; stmt-&gt;stmts.size(); i++)
    result += transform(stmt-&gt;stmts[i]);
}

</t>
<t tx="ekr.20230509083243.67">/// Void type
class VoidType : public AcceptorExtend&lt;VoidType, PrimitiveType&gt; {
public:
  static const char NodeId;

  /// Constructs a void type.
  VoidType() : AcceptorExtend("void") {}
};

</t>
<t tx="ekr.20230509083243.670">void FormatVisitor::visit(BreakStmt *stmt) { result = keyword("break"); }

void FormatVisitor::visit(ContinueStmt *stmt) { result = keyword("continue"); }

void FormatVisitor::visit(ExprStmt *stmt) { result = transform(stmt-&gt;expr); }

</t>
<t tx="ekr.20230509083243.671">void FormatVisitor::visit(AssignStmt *stmt) {
  if (stmt-&gt;type) {
    result = fmt::format("{}: {} = {}", transform(stmt-&gt;lhs), transform(stmt-&gt;type),
                         transform(stmt-&gt;rhs));
  } else {
    result = fmt::format("{} = {}", transform(stmt-&gt;lhs), transform(stmt-&gt;rhs));
  }
}

</t>
<t tx="ekr.20230509083243.672">void FormatVisitor::visit(AssignMemberStmt *stmt) {
  result = fmt::format("{}.{} = {}", transform(stmt-&gt;lhs), stmt-&gt;member,
                       transform(stmt-&gt;rhs));
}

</t>
<t tx="ekr.20230509083243.673">void FormatVisitor::visit(DelStmt *stmt) {
  result = fmt::format("{} {}", keyword("del"), transform(stmt-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.674">void FormatVisitor::visit(PrintStmt *stmt) {
  result = fmt::format("{} {}", keyword("print"), transform(stmt-&gt;items));
}

</t>
<t tx="ekr.20230509083243.675">void FormatVisitor::visit(ReturnStmt *stmt) {
  result = fmt::format("{}{}", keyword("return"),
                       stmt-&gt;expr ? " " + transform(stmt-&gt;expr) : "");
}

</t>
<t tx="ekr.20230509083243.676">void FormatVisitor::visit(YieldStmt *stmt) {
  result = fmt::format("{}{}", keyword("yield"),
                       stmt-&gt;expr ? " " + transform(stmt-&gt;expr) : "");
}

</t>
<t tx="ekr.20230509083243.677">void FormatVisitor::visit(AssertStmt *stmt) {
  result = fmt::format("{} {}", keyword("assert"), transform(stmt-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.678">void FormatVisitor::visit(WhileStmt *stmt) {
  result = fmt::format("{} {}:{}{}", keyword("while"), transform(stmt-&gt;cond), newline(),
                       transform(stmt-&gt;suite.get(), 1));
}

</t>
<t tx="ekr.20230509083243.679">void FormatVisitor::visit(ForStmt *stmt) {
  result = fmt::format("{} {} {} {}:{}{}", keyword("for"), transform(stmt-&gt;var),
                       keyword("in"), transform(stmt-&gt;iter), newline(),
                       transform(stmt-&gt;suite.get(), 1));
}

</t>
<t tx="ekr.20230509083243.68">/// Type from which membered types derive.
class MemberedType : public AcceptorExtend&lt;MemberedType, Type&gt; {
public:
  static const char NodeId;

@others
  using const_iterator = std::vector&lt;Field&gt;::const_iterator;
  using const_reference = std::vector&lt;Field&gt;::const_reference;

  /// Constructs a membered type.
  /// @param name the type's name
  explicit MemberedType(std::string name) : AcceptorExtend(std::move(name)) {}

  /// Gets a field type by name.
  /// @param name the field's name
  /// @return the type if it exists
  virtual Type *getMemberType(const std::string &amp;name) const = 0;
  /// Gets the index of a field by name.
  /// @param name the field's name
  /// @return 0-based field index, or -1 if not found
  virtual int getMemberIndex(const std::string &amp;name) const = 0;

  /// @return iterator to the first field
  virtual const_iterator begin() const = 0;
  /// @return iterator beyond the last field
  virtual const_iterator end() const = 0;
  /// @return a reference to the first field
  virtual const_reference front() const = 0;
  /// @return a reference to the last field
  virtual const_reference back() const = 0;

  /// Changes the body of the membered type.
  /// @param mTypes the new body
  /// @param mNames the new names
  virtual void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) = 0;
};

</t>
<t tx="ekr.20230509083243.680">void FormatVisitor::visit(IfStmt *stmt) {
  result = fmt::format("{} {}:{}{}{}", keyword("if"), transform(stmt-&gt;cond), newline(),
                       transform(stmt-&gt;ifSuite.get(), 1),
                       stmt-&gt;elseSuite ? format("{}:{}{}", keyword("else"), newline(),
                                                transform(stmt-&gt;elseSuite.get(), 1))
                                       : "");
}

</t>
<t tx="ekr.20230509083243.681">void FormatVisitor::visit(MatchStmt *stmt) {
  std::string s;
  for (auto &amp;c : stmt-&gt;cases)
    s += fmt::format("{}{}{}{}:{}{}", pad(1), keyword("case"), transform(c.pattern),
                     c.guard ? " " + (keyword("case") + " " + transform(c.guard)) : "",
                     newline(), transform(c.suite.get(), 2));
  result =
      fmt::format("{} {}:{}{}", keyword("match"), transform(stmt-&gt;what), newline(), s);
}

</t>
<t tx="ekr.20230509083243.682">void FormatVisitor::visit(ImportStmt *stmt) {
  auto as = stmt-&gt;as.empty() ? "" : fmt::format(" {} {} ", keyword("as"), stmt-&gt;as);
  if (!stmt-&gt;what)
    result += fmt::format("{} {}{}", keyword("import"), transform(stmt-&gt;from), as);
  else
    result += fmt::format("{} {} {} {}{}", keyword("from"), transform(stmt-&gt;from),
                          keyword("import"), transform(stmt-&gt;what), as);
}

</t>
<t tx="ekr.20230509083243.683">void FormatVisitor::visit(TryStmt *stmt) {
  std::vector&lt;std::string&gt; catches;
  for (auto &amp;c : stmt-&gt;catches) {
    catches.push_back(
        fmt::format("{} {}{}:{}{}", keyword("catch"), transform(c.exc),
                    c.var == "" ? "" : fmt::format("{} {}", keyword("as"), c.var),
                    newline(), transform(c.suite.get(), 1)));
  }
  result =
      fmt::format("{}:{}{}{}{}", keyword("try"), newline(),
                  transform(stmt-&gt;suite.get(), 1), fmt::join(catches, ""),
                  stmt-&gt;finally ? fmt::format("{}:{}{}", keyword("finally"), newline(),
                                              transform(stmt-&gt;finally.get(), 1))
                                : "");
}

</t>
<t tx="ekr.20230509083243.684">void FormatVisitor::visit(GlobalStmt *stmt) {
  result = fmt::format("{} {}", keyword("global"), stmt-&gt;var);
}

</t>
<t tx="ekr.20230509083243.685">void FormatVisitor::visit(ThrowStmt *stmt) {
  result = fmt::format("{} {}", keyword("raise"), transform(stmt-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.686">void FormatVisitor::visit(FunctionStmt *fstmt) {
  if (cache) {
    if (in(cache-&gt;functions, fstmt-&gt;name)) {
      if (!cache-&gt;functions[fstmt-&gt;name].realizations.empty()) {
        for (auto &amp;real : cache-&gt;functions[fstmt-&gt;name].realizations) {
          if (real.first != fstmt-&gt;name) {
            result += transform(real.second-&gt;ast.get(), 0);
          }
        }
        return;
      }
      fstmt = cache-&gt;functions[fstmt-&gt;name].ast.get();
    }
  }
  //  if (cache &amp;&amp; cache-&gt;functions.find(fstmt-&gt;name) != cache-&gt;realizationAsts.end())
  //  {
  //    fstmt = (const FunctionStmt *)(cache-&gt;realizationAsts[fstmt-&gt;name].get());
  //  } else if (cache &amp;&amp; cache-&gt;functions[fstmt-&gt;name].realizations.size()) {
  //    for (auto &amp;real : cache-&gt;functions[fstmt-&gt;name].realizations)
  //      result += transform(real.second.ast);
  //    return;
  //  } else if (cache) {
  //    fstmt = cache-&gt;functions[fstmt-&gt;name].ast.get();
  //  }

  std::vector&lt;std::string&gt; attrs;
  for (auto &amp;a : fstmt-&gt;decorators)
    attrs.push_back(fmt::format("@{}", transform(a)));
  if (!fstmt-&gt;attributes.module.empty())
    attrs.push_back(fmt::format("@module:{}", fstmt-&gt;attributes.parentClass));
  if (!fstmt-&gt;attributes.parentClass.empty())
    attrs.push_back(fmt::format("@parent:{}", fstmt-&gt;attributes.parentClass));
  std::vector&lt;std::string&gt; args;
  for (auto &amp;a : fstmt-&gt;args)
    args.push_back(fmt::format(
        "{}{}{}", a.name, a.type ? fmt::format(": {}", transform(a.type)) : "",
        a.defaultValue ? fmt::format(" = {}", transform(a.defaultValue)) : ""));
  auto body = transform(fstmt-&gt;suite.get(), 1);
  auto name = fmt::format("{}{}{}", typeStart, fstmt-&gt;name, typeEnd);
  name = fmt::format("{}{}{}", exprStart, name, exprEnd);
  result += fmt::format(
      "{}{} {}({}){}:{}{}",
      attrs.size() ? join(attrs, newline() + pad()) + newline() + pad() : "",
      keyword("def"), name, fmt::join(args, ", "),
      fstmt-&gt;ret ? fmt::format(" -&gt; {}", transform(fstmt-&gt;ret)) : "", newline(),
      body.empty() ? fmt::format("{}", keyword("pass")) : body);
}

</t>
<t tx="ekr.20230509083243.687">void FormatVisitor::visit(ClassStmt *stmt) {
  std::vector&lt;std::string&gt; attrs;

  if (!stmt-&gt;attributes.has(Attr::Extend))
    attrs.push_back("@extend");
  if (!stmt-&gt;attributes.has(Attr::Tuple))
    attrs.push_back("@tuple");
  std::vector&lt;std::string&gt; args;
  std::string key = stmt-&gt;isRecord() ? "type" : "class";
  for (auto &amp;a : stmt-&gt;args)
    args.push_back(fmt::format("{}: {}", a.name, transform(a.type)));
  result = fmt::format("{}{} {}({})",
                       attrs.size() ? join(attrs, newline() + pad()) + newline() + pad()
                                    : "",
                       keyword(key), stmt-&gt;name, fmt::join(args, ", "));
  if (stmt-&gt;suite)
    result += fmt::format(":{}{}", newline(), transform(stmt-&gt;suite.get(), 1));
}

</t>
<t tx="ekr.20230509083243.688">void FormatVisitor::visit(YieldFromStmt *stmt) {
  result = fmt::format("{} {}", keyword("yield from"), transform(stmt-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.689">@path C:/Repos/codon/codon/parser/visitors/format/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;ostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/visitor.h"

namespace codon {
namespace ast {

@others
} // namespace ast
} // namespace codon

template &lt;&gt;
struct fmt::formatter&lt;codon::ast::FormatVisitor&gt; : fmt::ostream_formatter {};
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.69">  /// Object that represents a field in a membered type.
  class Field {
  private:
    /// the field's name
    std::string name;
    /// the field's type
    Type *type;

  public:
    /// Constructs a field.
    /// @param name the field's name
    /// @param type the field's type
    Field(std::string name, Type *type) : name(std::move(name)), type(type) {}

    /// @return the field's name
    const std::string &amp;getName() const { return name; }
    /// @return the field type
    Type *getType() const { return type; }
  };

</t>
<t tx="ekr.20230509083243.690">class FormatVisitor : public CallbackASTVisitor&lt;std::string, std::string&gt; {
  std::string result;
  std::string space;
  bool renderType, renderHTML;
  int indent;

  std::string header, footer, nl;
  std::string typeStart, typeEnd;
  std::string nodeStart, nodeEnd;
  std::string exprStart, exprEnd;
  std::string commentStart, commentEnd;
  std::string keywordStart, keywordEnd;

  Cache *cache;

private:
  template &lt;typename T, typename... Ts&gt; std::string renderExpr(T &amp;&amp;t, Ts &amp;&amp;...args) {
    std::string s;
    return fmt::format("{}{}{}{}{}{}", exprStart, s, nodeStart, fmt::format(args...),
                       nodeEnd, exprEnd);
  }
  template &lt;typename... Ts&gt; std::string renderComment(Ts &amp;&amp;...args) {
    return fmt::format("{}{}{}", commentStart, fmt::format(args...), commentEnd);
  }
  std::string pad(int indent = 0) const;
  std::string newline() const;
  std::string keyword(const std::string &amp;s) const;

public:
  FormatVisitor(bool html, Cache *cache = nullptr);
  std::string transform(const ExprPtr &amp;e) override;
  std::string transform(const Expr *expr);
  std::string transform(const StmtPtr &amp;stmt) override;
  std::string transform(Stmt *stmt, int indent);

  @others
  void defaultVisit(Expr *e) override { error("cannot format {}", *e); }
  void defaultVisit(Stmt *e) override { error("cannot format {}", *e); }

public:
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;
  void visit(IdExpr *) override;
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *) override;
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  void visit(DictGeneratorExpr *) override;
  void visit(InstantiateExpr *expr) override;
  void visit(IfExpr *) override;
  void visit(UnaryExpr *) override;
  void visit(BinaryExpr *) override;
  void visit(PipeExpr *) override;
  void visit(IndexExpr *) override;
  void visit(CallExpr *) override;
  void visit(DotExpr *) override;
  void visit(SliceExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(LambdaExpr *) override;
  void visit(YieldExpr *) override;
  void visit(StmtExpr *expr) override;
  void visit(AssignExpr *expr) override;

  void visit(SuiteStmt *) override;
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(ExprStmt *) override;
  void visit(AssignStmt *) override;
  void visit(AssignMemberStmt *) override;
  void visit(DelStmt *) override;
  void visit(PrintStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(AssertStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  void visit(IfStmt *) override;
  void visit(MatchStmt *) override;
  void visit(ImportStmt *) override;
  void visit(TryStmt *) override;
  void visit(GlobalStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  void visit(YieldFromStmt *) override;
  void visit(WithStmt *) override;

public:
  friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;out, const FormatVisitor &amp;c) {
    return out &lt;&lt; c.result;
  }

  using CallbackASTVisitor&lt;std::string, std::string&gt;::transform;
  template &lt;typename T&gt; std::string transform(const std::vector&lt;T&gt; &amp;ts) {
    std::vector&lt;std::string&gt; r;
    for (auto &amp;e : ts)
      r.push_back(transform(e));
    return fmt::format("{}", fmt::join(r, ", "));
  }
};

</t>
<t tx="ekr.20230509083243.691">template &lt;typename T&gt;
static std::string apply(const T &amp;stmt, Cache *cache = nullptr, bool html = false,
                         bool init = false) {
  auto t = FormatVisitor(html, cache);
  return fmt::format("{}{}{}", t.header, t.transform(stmt), t.footer);
}

</t>
<t tx="ekr.20230509083243.692"></t>
<t tx="ekr.20230509083243.693">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
/// Check if a access chain (a.b.c.d...) contains an import or class prefix.
std::pair&lt;size_t, SimplifyContext::Item&gt;
SimplifyVisitor::getImport(const std::vector&lt;std::string&gt; &amp;chain) {
  size_t importEnd = 0;
  std::string importName;

  // Find the longest prefix that corresponds to the existing import
  // (e.g., `a.b.c.d` -&gt; `a.b.c` if there is `import a.b.c`)
  SimplifyContext::Item val = nullptr;
  for (auto i = chain.size(); i-- &gt; 0;) {
    val = ctx-&gt;find(join(chain, "/", 0, i + 1));
    if (val &amp;&amp; val-&gt;isImport()) {
      importName = val-&gt;importPath, importEnd = i + 1;
      break;
    }
  }

  if (importEnd != chain.size()) { // false when a.b.c points to import itself
    // Find the longest prefix that corresponds to the existing class
    // (e.g., `a.b.c` -&gt; `a.b` if there is `class a: class b:`)
    std::string itemName;
    size_t itemEnd = 0;
    auto fctx = importName.empty() ? ctx : ctx-&gt;cache-&gt;imports[importName].ctx;
    for (auto i = chain.size(); i-- &gt; importEnd;) {
      if (fctx-&gt;getModule() == "std.python" &amp;&amp; importEnd &lt; chain.size()) {
        // Special case: importing from Python.
        // Fake SimplifyItem that indicates std.python access
        val = std::make_shared&lt;SimplifyItem&gt;(SimplifyItem::Var, "", "",
                                             fctx-&gt;getModule(), std::vector&lt;int&gt;{});
        return {importEnd, val};
      } else {
        val = fctx-&gt;find(join(chain, ".", importEnd, i + 1));
        if (val &amp;&amp; (importName.empty() || val-&gt;isType() || !val-&gt;isConditional())) {
          itemName = val-&gt;canonicalName, itemEnd = i + 1;
          break;
        }
      }
    }
    if (itemName.empty() &amp;&amp; importName.empty()) {
      if (ctx-&gt;getBase()-&gt;pyCaptures)
        return {1, nullptr};
      E(Error::IMPORT_NO_MODULE, getSrcInfo(), chain[importEnd]);
    }
    if (itemName.empty())
      E(Error::IMPORT_NO_NAME, getSrcInfo(), chain[importEnd],
        ctx-&gt;cache-&gt;imports[importName].moduleName);
    importEnd = itemEnd;
  }
  return {importEnd, val};
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.694">void SimplifyVisitor::visit(IdExpr *expr) {
  if (startswith(expr-&gt;value, TYPE_TUPLE)) {
    expr-&gt;markType();
    return;
  }
  auto val = ctx-&gt;findDominatingBinding(expr-&gt;value);

  if (!val &amp;&amp; ctx-&gt;getBase()-&gt;pyCaptures) {
    ctx-&gt;getBase()-&gt;pyCaptures-&gt;insert(expr-&gt;value);
    resultExpr = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("__pyenv__"), N&lt;StringExpr&gt;(expr-&gt;value));
    return;
  } else if (!val) {
    E(Error::ID_NOT_FOUND, expr, expr-&gt;value);
  }

  // If we are accessing an outside variable, capture it or raise an error
  auto captured = checkCapture(val);
  if (captured)
    val = ctx-&gt;forceFind(expr-&gt;value);

  // Track loop variables to dominate them later. Example:
  // x = 1
  // while True:
  //   if x &gt; 10: break
  //   x = x + 1  # x must be dominated after the loop to ensure that it gets updated
  if (auto loop = ctx-&gt;getBase()-&gt;getLoop()) {
    bool inside = val-&gt;scope.size() &gt;= loop-&gt;scope.size() &amp;&amp;
                  val-&gt;scope[loop-&gt;scope.size() - 1] == loop-&gt;scope.back();
    if (!inside)
      loop-&gt;seenVars.insert(expr-&gt;value);
  }

  // Replace the variable with its canonical name
  expr-&gt;value = val-&gt;canonicalName;

  // Mark global as "seen" to prevent later creation of local variables
  // with the same name. Example:
  // x = 1
  // def foo():
  //   print(x)  # mark x as seen
  //   x = 2     # so that this is an error
  if (!val-&gt;isGeneric() &amp;&amp; ctx-&gt;isOuter(val) &amp;&amp;
      !in(ctx-&gt;seenGlobalIdentifiers[ctx-&gt;getBaseName()],
          ctx-&gt;cache-&gt;rev(val-&gt;canonicalName))) {
    ctx-&gt;seenGlobalIdentifiers[ctx-&gt;getBaseName()]
                              [ctx-&gt;cache-&gt;rev(val-&gt;canonicalName)] = expr-&gt;clone();
  }

  // Flag the expression as a type expression if it points to a class or a generic
  if (val-&gt;isType())
    expr-&gt;markType();

  // Variable binding check for variables that are defined within conditional blocks
  if (!val-&gt;accessChecked.empty()) {
    bool checked = false;
    for (auto &amp;a : val-&gt;accessChecked) {
      if (a.size() &lt;= ctx-&gt;scope.blocks.size() &amp;&amp;
          a[a.size() - 1] == ctx-&gt;scope.blocks[a.size() - 1]) {
        checked = true;
        break;
      }
    }
    if (!checked) {
  @others
    }
  }
}

</t>
<t tx="ekr.20230509083243.695">    // Prepend access with __internal__.undef([var]__used__, "[var name]")
    auto checkStmt = N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
        N&lt;DotExpr&gt;("__internal__", "undef"),
        N&lt;IdExpr&gt;(fmt::format("{}.__used__", val-&gt;canonicalName)),
        N&lt;StringExpr&gt;(ctx-&gt;cache-&gt;reverseIdentifierLookup[val-&gt;canonicalName])));
    if (!ctx-&gt;isConditionalExpr) {
      // If the expression is not conditional, we can just do the check once
      prependStmts-&gt;push_back(checkStmt);
      val-&gt;accessChecked.push_back(ctx-&gt;scope.blocks);
    } else {
      // Otherwise, this check must be always called
      resultExpr = N&lt;StmtExpr&gt;(checkStmt, N&lt;IdExpr&gt;(*expr));
    }
</t>
<t tx="ekr.20230509083243.696">/// Flatten imports.
/// @example
///   `a.b.c`      -&gt; canonical name of `c` in `a.b` if `a.b` is an import
///   `a.B.c`      -&gt; canonical name of `c` in class `a.B`
///   `python.foo` -&gt; internal.python._get_identifier("foo")
/// Other cases are handled during the type checking.
void SimplifyVisitor::visit(DotExpr *expr) {
  // First flatten the imports:
  // transform Dot(Dot(a, b), c...) to {a, b, c, ...}
  std::vector&lt;std::string&gt; chain;
  Expr *root = expr;
  for (; root-&gt;getDot(); root = root-&gt;getDot()-&gt;expr.get())
    chain.push_back(root-&gt;getDot()-&gt;member);

  if (auto id = root-&gt;getId()) {
    // Case: a.bar.baz
    chain.push_back(id-&gt;value);
    std::reverse(chain.begin(), chain.end());
    auto p = getImport(chain);

    if (!p.second) {
      seqassert(ctx-&gt;getBase()-&gt;pyCaptures, "unexpected py capture");
      ctx-&gt;getBase()-&gt;pyCaptures-&gt;insert(chain[0]);
      resultExpr = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("__pyenv__"), N&lt;StringExpr&gt;(chain[0]));
    } else if (p.second-&gt;getModule() == "std.python") {
      resultExpr = transform(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;("internal"), "python"), "_get_identifier"),
          N&lt;StringExpr&gt;(chain[p.first++])));
    } else if (p.second-&gt;getModule() == ctx-&gt;getModule() &amp;&amp; p.first == 1) {
      resultExpr = transform(N&lt;IdExpr&gt;(chain[0]), true);
    } else {
      resultExpr = N&lt;IdExpr&gt;(p.second-&gt;canonicalName);
      if (p.second-&gt;isType() &amp;&amp; p.first == chain.size())
        resultExpr-&gt;markType();
    }
    for (auto i = p.first; i &lt; chain.size(); i++)
      resultExpr = N&lt;DotExpr&gt;(resultExpr, chain[i]);
  } else {
    // Case: a[x].foo.bar
    transform(expr-&gt;expr, true);
  }
}

</t>
<t tx="ekr.20230509083243.697">/// Access identifiers from outside of the current function/class scope.
/// Either use them as-is (globals), capture them if allowed (nonlocals),
/// or raise an error.
bool SimplifyVisitor::checkCapture(const SimplifyContext::Item &amp;val) {
  if (!ctx-&gt;isOuter(val))
    return false;
  if ((val-&gt;isType() &amp;&amp; !val-&gt;isGeneric()) || val-&gt;isFunc())
    return false;

  // Ensure that outer variables can be captured (i.e., do not cross no-capture
  // boundary). Example:
  // def foo():
  //   x = 1
  //   class T:      # &lt;- boundary (classes cannot capture locals)
  //     t: int = x  # x cannot be accessed
  //     def bar():  # &lt;- another boundary
  //                 # (class methods cannot capture locals except class generics)
  //       print(x)  # x cannot be accessed
  bool crossCaptureBoundary = false;
  bool localGeneric = val-&gt;isGeneric() &amp;&amp; val-&gt;getBaseName() == ctx-&gt;getBaseName();
  @others
  // Mark methods (class functions that access class generics)
  if (parentClassGeneric)
    ctx-&gt;getBase()-&gt;attributes-&gt;set(Attr::Method);

  // Ignore generics
  if (parentClassGeneric || localGeneric)
    return false;

  // Case: a global variable that has not been marked with `global` statement
  if (val-&gt;isVar() &amp;&amp; val-&gt;getBaseName().empty() &amp;&amp; val-&gt;scope.size() == 1) {
    val-&gt;noShadow = true;
    if (!val-&gt;isStatic())
      ctx-&gt;cache-&gt;addGlobal(val-&gt;canonicalName);
    return false;
  }

  // Check if a real variable (not a static) is defined outside the current scope
  if (crossCaptureBoundary)
    E(Error::ID_CANNOT_CAPTURE, getSrcInfo(), ctx-&gt;cache-&gt;rev(val-&gt;canonicalName));

  // Case: a nonlocal variable that has not been marked with `nonlocal` statement
  //       and capturing is enabled
  auto captures = ctx-&gt;getBase()-&gt;captures;
  if (captures &amp;&amp; !in(*captures, val-&gt;canonicalName)) {
    // Captures are transformed to function arguments; generate new name for that
    // argument
    ExprPtr typ = nullptr;
    if (val-&gt;isType())
      typ = N&lt;IdExpr&gt;("type");
    if (auto st = val-&gt;isStatic())
      typ = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"),
                         N&lt;IdExpr&gt;(st == StaticValue::INT ? "int" : "str"));
    auto [newName, _] = (*captures)[val-&gt;canonicalName] = {
        ctx-&gt;generateCanonicalName(val-&gt;canonicalName), typ};
    ctx-&gt;cache-&gt;reverseIdentifierLookup[newName] = newName;
    // Add newly generated argument to the context
    std::shared_ptr&lt;SimplifyItem&gt; newVal = nullptr;
    if (val-&gt;isType())
      newVal = ctx-&gt;addType(ctx-&gt;cache-&gt;rev(val-&gt;canonicalName), newName, getSrcInfo());
    else
      newVal = ctx-&gt;addVar(ctx-&gt;cache-&gt;rev(val-&gt;canonicalName), newName, getSrcInfo());
    newVal-&gt;baseName = ctx-&gt;getBaseName();
    newVal-&gt;noShadow = true;
    newVal-&gt;scope = ctx-&gt;getBase()-&gt;scope;
    return true;
  }

  // Case: a nonlocal variable that has not been marked with `nonlocal` statement
  //       and capturing is *not* enabled
  E(Error::ID_NONLOCAL, getSrcInfo(), ctx-&gt;cache-&gt;rev(val-&gt;canonicalName));
  return false;
}

</t>
<t tx="ekr.20230509083243.698">bool parentClassGeneric =
    val-&gt;isGeneric() &amp;&amp; !ctx-&gt;getBase()-&gt;isType() &amp;&amp;
    (ctx-&gt;bases.size() &gt; 1 &amp;&amp; ctx-&gt;bases[ctx-&gt;bases.size() - 2].isType() &amp;&amp;
     ctx-&gt;bases[ctx-&gt;bases.size() - 2].name == val-&gt;getBaseName());
auto i = ctx-&gt;bases.size();
for (; i-- &gt; 0;) {
  if (ctx-&gt;bases[i].name == val-&gt;getBaseName())
    break;
  if (!localGeneric &amp;&amp; !parentClassGeneric &amp;&amp; !ctx-&gt;bases[i].captures)
    crossCaptureBoundary = true;
}

</t>
<t tx="ekr.20230509083243.699">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.7">  void handle(YieldInInstr *v) override { valid = false; }
};

// Replaces yields with conditional returns of the any/all answer.
struct GeneratorAnyAllTransformer : public util::Operator {
  bool any; // true=any, false=all
  bool valid;

  explicit GeneratorAnyAllTransformer(bool any)
      : util::Operator(), any(any), valid(true) {}

</t>
<t tx="ekr.20230509083243.70">/// Membered type equivalent to C structs/C++ PODs
class RecordType : public AcceptorExtend&lt;RecordType, MemberedType&gt; {
private:
  std::vector&lt;Field&gt; fields;

public:
  static const char NodeId;

  /// Constructs a record type.
  /// @param name the type's name
  /// @param fieldTypes the member types
  /// @param fieldNames the member names
  RecordType(std::string name, std::vector&lt;Type *&gt; fieldTypes,
             std::vector&lt;std::string&gt; fieldNames);
  /// Constructs a record type. The field's names are "1", "2"...
  /// @param name the type's name
  /// @param mTypes a vector of member types
  RecordType(std::string name, std::vector&lt;Type *&gt; mTypes);
  /// Constructs an empty record type.
  /// @param name the name
  explicit RecordType(std::string name) : AcceptorExtend(std::move(name)) {}

  Type *getMemberType(const std::string &amp;n) const override;
  int getMemberIndex(const std::string &amp;n) const override;

  const_iterator begin() const override { return fields.begin(); }
  const_iterator end() const override { return fields.end(); }
  const_reference front() const override { return fields.front(); }
  const_reference back() const override { return fields.back(); }

  void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) override;

private:
  std::vector&lt;Type *&gt; doGetUsedTypes() const override;

@others
};

</t>
<t tx="ekr.20230509083243.700">/// Transform walrus (assignment) expression.
/// @example
///   `(expr := var)` -&gt; `var = expr; var`
void SimplifyVisitor::visit(AssignExpr *expr) {
  seqassert(expr-&gt;var-&gt;getId(), "only simple assignment expression are supported");
  StmtPtr s = N&lt;AssignStmt&gt;(clone(expr-&gt;var), expr-&gt;expr);
  auto avoidDomination = false; // walruses always leak
  std::swap(avoidDomination, ctx-&gt;avoidDomination);
  if (ctx-&gt;isConditionalExpr) {
    // Make sure to transform both suite _AND_ the expression in the same scope
    ctx-&gt;enterConditionalBlock();
    transform(s);
    transform(expr-&gt;var);
    SuiteStmt *suite = s-&gt;getSuite();
    if (!suite) {
      s = N&lt;SuiteStmt&gt;(s);
      suite = s-&gt;getSuite();
    }
    ctx-&gt;leaveConditionalBlock(&amp;suite-&gt;stmts);
  } else {
    s = transform(s);
    transform(expr-&gt;var);
  }
  std::swap(avoidDomination, ctx-&gt;avoidDomination);
  resultExpr = N&lt;StmtExpr&gt;(std::vector&lt;StmtPtr&gt;{s}, expr-&gt;var);
}

</t>
<t tx="ekr.20230509083243.701">/// Unpack assignments.
/// See @c transformAssignment and @c unpackAssignments for more details.
void SimplifyVisitor::visit(AssignStmt *stmt) {
  std::vector&lt;StmtPtr&gt; stmts;
  if (stmt-&gt;rhs &amp;&amp; stmt-&gt;rhs-&gt;getBinary() &amp;&amp; stmt-&gt;rhs-&gt;getBinary()-&gt;inPlace) {
    // Update case: a += b
    seqassert(!stmt-&gt;type, "invalid AssignStmt {}", stmt-&gt;toString());
    stmts.push_back(transformAssignment(stmt-&gt;lhs, stmt-&gt;rhs, nullptr, true));
  } else if (stmt-&gt;type) {
    // Type case: `a: T = b, c` (no unpacking)
    stmts.push_back(transformAssignment(stmt-&gt;lhs, stmt-&gt;rhs, stmt-&gt;type));
  } else {
    // Normal case
    unpackAssignments(stmt-&gt;lhs, stmt-&gt;rhs, stmts);
  }
  resultStmt = stmts.size() == 1 ? stmts[0] : N&lt;SuiteStmt&gt;(stmts);
}

</t>
<t tx="ekr.20230509083243.702">/// Transform deletions.
/// @example
///   `del a`    -&gt; `a = type(a)()` and remove `a` from the context
///   `del a[x]` -&gt; `a.__delitem__(x)`
void SimplifyVisitor::visit(DelStmt *stmt) {
  if (auto idx = stmt-&gt;expr-&gt;getIndex()) {
    resultStmt = N&lt;ExprStmt&gt;(
        transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(idx-&gt;expr, "__delitem__"), idx-&gt;index)));
  } else if (auto ei = stmt-&gt;expr-&gt;getId()) {
    // Assign `a` to `type(a)()` to mark it for deletion
    resultStmt = N&lt;AssignStmt&gt;(
        transform(clone(stmt-&gt;expr)),
        transform(N&lt;CallExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("type"), clone(stmt-&gt;expr)))));
    resultStmt-&gt;getAssign()-&gt;setUpdate();

    // Allow deletion *only* if the binding is dominated
    auto val = ctx-&gt;find(ei-&gt;value);
    if (!val)
      E(Error::ID_NOT_FOUND, ei, ei-&gt;value);
    if (ctx-&gt;scope.blocks != val-&gt;scope)
      E(Error::DEL_NOT_ALLOWED, ei, ei-&gt;value);
    ctx-&gt;remove(ei-&gt;value);
  } else {
    E(Error::DEL_INVALID, stmt);
  }
}

</t>
<t tx="ekr.20230509083243.703">/// Transform simple assignments.
/// @example
///   `a[x] = b`    -&gt; `a.__setitem__(x, b)`
///   `a.x = b`     -&gt; @c AssignMemberStmt
///   `a: type` = b -&gt; @c AssignStmt
///   `a = b`       -&gt; @c AssignStmt or @c UpdateStmt (see below)
StmtPtr SimplifyVisitor::transformAssignment(ExprPtr lhs, ExprPtr rhs, ExprPtr type,
</t>
<t tx="ekr.20230509083243.704">                                             bool mustExist) {
  if (auto idx = lhs-&gt;getIndex()) {
    // Case: a[x] = b
    seqassert(!type, "unexpected type annotation");
    return transform(N&lt;ExprStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(idx-&gt;expr, "__setitem__"), idx-&gt;index, rhs)));
  }

  if (auto dot = lhs-&gt;getDot()) {
    // Case: a.x = b
    seqassert(!type, "unexpected type annotation");
    transform(dot-&gt;expr, true);
    // If we are deducing class members, check if we can deduce a member from this
    // assignment
    auto deduced = ctx-&gt;getClassBase() ? ctx-&gt;getClassBase()-&gt;deducedMembers : nullptr;
    if (deduced &amp;&amp; dot-&gt;expr-&gt;isId(ctx-&gt;getBase()-&gt;selfName) &amp;&amp;
        !in(*deduced, dot-&gt;member))
      deduced-&gt;push_back(dot-&gt;member);
    return N&lt;AssignMemberStmt&gt;(dot-&gt;expr, dot-&gt;member, transform(rhs));
  }

  // Case: a (: t) = b
  auto e = lhs-&gt;getId();
  if (!e)
    E(Error::ASSIGN_INVALID, lhs);

  // Disable creation of local variables that share the name with some global if such
  // global was already accessed within the current scope. Example:
  // x = 1
  // def foo():
  //   print(x)  # x is seen here
  //   x = 2     # this should error
  if (in(ctx-&gt;seenGlobalIdentifiers[ctx-&gt;getBaseName()], e-&gt;value))
    E(Error::ASSIGN_LOCAL_REFERENCE,
      ctx-&gt;seenGlobalIdentifiers[ctx-&gt;getBaseName()][e-&gt;value], e-&gt;value);

  auto val = ctx-&gt;find(e-&gt;value);
  // Make sure that existing values that cannot be shadowed (e.g. imported globals) are
  // only updated
  mustExist |= val &amp;&amp; val-&gt;noShadow &amp;&amp; !ctx-&gt;isOuter(val);
  if (mustExist) {
    val = ctx-&gt;findDominatingBinding(e-&gt;value);
    if (val &amp;&amp; val-&gt;isVar() &amp;&amp; !ctx-&gt;isOuter(val)) {
      auto s = N&lt;AssignStmt&gt;(transform(lhs, false), transform(rhs));
      if (ctx-&gt;getBase()-&gt;attributes &amp;&amp; ctx-&gt;getBase()-&gt;attributes-&gt;has(Attr::Atomic))
        s-&gt;setAtomicUpdate();
      else
        s-&gt;setUpdate();
      return s;
    } else {
      E(Error::ASSIGN_LOCAL_REFERENCE, e, e-&gt;value);
    }
  }

  transform(rhs, true);
  transformType(type, false);

  // Generate new canonical variable name for this assignment and add it to the context
  auto canonical = ctx-&gt;generateCanonicalName(e-&gt;value);
  auto assign = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(canonical), rhs, type);
  val = nullptr;
  if (rhs &amp;&amp; rhs-&gt;isType()) {
    val = ctx-&gt;addType(e-&gt;value, canonical, lhs-&gt;getSrcInfo());
  } else {
    val = ctx-&gt;addVar(e-&gt;value, canonical, lhs-&gt;getSrcInfo());
    if (auto st = getStaticGeneric(type.get()))
      val-&gt;staticType = st;
    if (ctx-&gt;avoidDomination)
      val-&gt;avoidDomination = true;
  }
  // Clean up seen tags if shadowing a name
  ctx-&gt;seenGlobalIdentifiers[ctx-&gt;getBaseName()].erase(e-&gt;value);

  // Register all toplevel variables as global in JIT mode
  bool isGlobal = (ctx-&gt;cache-&gt;isJit &amp;&amp; val-&gt;isGlobal() &amp;&amp; !val-&gt;isGeneric()) ||
                  (canonical == VAR_ARGV);
  if (isGlobal &amp;&amp; !val-&gt;isGeneric())
    ctx-&gt;cache-&gt;addGlobal(canonical);

  return assign;
}

</t>
<t tx="ekr.20230509083243.705">/// Unpack an assignment expression `lhs = rhs` into a list of simple assignment
/// expressions (e.g., `a = b`, `a.x = b`, or `a[x] = b`).
/// Handle Python unpacking rules.
/// @example
///   `(a, b) = c`     -&gt; `a = c[0]; b = c[1]`
///   `a, b = c`       -&gt; `a = c[0]; b = c[1]`
///   `[a, *x, b] = c` -&gt; `a = c[0]; x = c[1:-1]; b = c[-1]`.
/// Non-trivial right-hand expressions are first stored in a temporary variable.
/// @example
///   `a, b = c, d + foo()` -&gt; `assign = (c, d + foo); a = assign[0]; b = assign[1]`.
/// Each assignment is unpacked recursively to allow cases like `a, (b, c) = d`.
void SimplifyVisitor::unpackAssignments(const ExprPtr &amp;lhs, ExprPtr rhs,
                                        std::vector&lt;StmtPtr&gt; &amp;stmts) {
  std::vector&lt;ExprPtr&gt; leftSide;
  if (auto et = lhs-&gt;getTuple()) {
    // Case: (a, b) = ...
    for (auto &amp;i : et-&gt;items)
      leftSide.push_back(i);
  } else if (auto el = lhs-&gt;getList()) {
    // Case: [a, b] = ...
    for (auto &amp;i : el-&gt;items)
      leftSide.push_back(i);
  } else {
    // Case: simple assignment (a = b, a.x = b, or a[x] = b)
    stmts.push_back(transformAssignment(clone(lhs), clone(rhs)));
    return;
  }

  // Prepare the right-side expression
  auto srcPos = rhs-&gt;getSrcInfo();
  if (!rhs-&gt;getId()) {
    // Store any non-trivial right-side expression into a variable
    auto var = ctx-&gt;cache-&gt;getTemporaryVar("assign");
    ExprPtr newRhs = N&lt;IdExpr&gt;(srcPos, var);
    stmts.push_back(transformAssignment(newRhs, clone(rhs)));
    rhs = newRhs;
  }

  // Process assignments until the fist StarExpr (if any)
  size_t st = 0;
  for (; st &lt; leftSide.size(); st++) {
    if (leftSide[st]-&gt;getStar())
      break;
    // Transformation: `leftSide_st = rhs[st]` where `st` is static integer
    auto rightSide = N&lt;IndexExpr&gt;(srcPos, clone(rhs), N&lt;IntExpr&gt;(srcPos, st));
    // Recursively process the assignment because of cases like `(a, (b, c)) = d)`
    unpackAssignments(leftSide[st], rightSide, stmts);
  }
  // Process StarExpr (if any) and the assignments that follow it
  if (st &lt; leftSide.size() &amp;&amp; leftSide[st]-&gt;getStar()) {
    // StarExpr becomes SliceExpr (e.g., `b` in `(a, *b, c) = d` becomes `d[1:-2]`)
    auto rightSide = N&lt;IndexExpr&gt;(
        srcPos, clone(rhs),
        N&lt;SliceExpr&gt;(srcPos, N&lt;IntExpr&gt;(srcPos, st),
                     // this slice is either [st:] or [st:-lhs_len + st + 1]
                     leftSide.size() == st + 1
                         ? nullptr
                         : N&lt;IntExpr&gt;(srcPos, -leftSide.size() + st + 1),
                     nullptr));
    unpackAssignments(leftSide[st]-&gt;getStar()-&gt;what, rightSide, stmts);
    st += 1;
    // Process remaining assignments. They will use negative indices (-1, -2 etc.)
    // because we do not know how big is StarExpr
    for (; st &lt; leftSide.size(); st++) {
      if (leftSide[st]-&gt;getStar())
        E(Error::ASSIGN_MULTI_STAR, leftSide[st]);
      rightSide = N&lt;IndexExpr&gt;(srcPos, clone(rhs),
                               N&lt;IntExpr&gt;(srcPos, -int(leftSide.size() - st)));
      unpackAssignments(leftSide[st], rightSide, stmts);
    }
  }
}

</t>
<t tx="ekr.20230509083243.706">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

/// See @c transformInt
void SimplifyVisitor::visit(IntExpr *expr) { resultExpr = transformInt(expr); }

/// See @c transformFloat
void SimplifyVisitor::visit(FloatExpr *expr) { resultExpr = transformFloat(expr); }

@others
/**************************************************************************************/

/// Parse various integer representations depending on the integer suffix.
/// @example
///   `123u`   -&gt; `UInt[64](123)`
///   `123i56` -&gt; `Int[56](123)`
///   `123pf`  -&gt; `int.__suffix_pf__(123)`
ExprPtr SimplifyVisitor::transformInt(IntExpr *expr) {
  if (!expr-&gt;intValue) {
    /// TODO: currently assumes that ints are always 64-bit.
    /// Should use str constructors if available for ints with a suffix instead.
    E(Error::INT_RANGE, expr, expr-&gt;value);
  }

  /// Handle fixed-width integers: suffixValue is a pointer to NN if the suffix
  /// is `uNNN` or `iNNN`.
  std::unique_ptr&lt;int16_t&gt; suffixValue = nullptr;
  if (expr-&gt;suffix.size() &gt; 1 &amp;&amp; (expr-&gt;suffix[0] == 'u' || expr-&gt;suffix[0] == 'i') &amp;&amp;
      isdigit(expr-&gt;suffix.substr(1))) {
    try {
      suffixValue = std::make_unique&lt;int16_t&gt;(std::stoi(expr-&gt;suffix.substr(1)));
    } catch (...) {
    }
    if (suffixValue &amp;&amp; *suffixValue &gt; MAX_INT_WIDTH)
      suffixValue = nullptr;
  }

  if (expr-&gt;suffix.empty()) {
    // A normal integer (int64_t)
    return N&lt;IntExpr&gt;(*(expr-&gt;intValue));
  } else if (expr-&gt;suffix == "u") {
    // Unsigned integer: call `UInt[64](value)`
    return transform(N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("UInt"), N&lt;IntExpr&gt;(64)),
                                 N&lt;IntExpr&gt;(*(expr-&gt;intValue))));
  } else if (suffixValue) {
    // Fixed-width numbers (with `uNNN` and `iNNN` suffixes):
    // call `UInt[NNN](value)` or `Int[NNN](value)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(expr-&gt;suffix[0] == 'u' ? "UInt" : "Int"),
                                 N&lt;IntExpr&gt;(*suffixValue)),
                    N&lt;IntExpr&gt;(*(expr-&gt;intValue))));
  } else {
    // Custom suffix: call `int.__suffix_[suffix]__(value)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("int", format("__suffix_{}__", expr-&gt;suffix)),
                    N&lt;IntExpr&gt;(*(expr-&gt;intValue))));
  }
}

/// Parse various float representations depending on the suffix.
/// @example
///   `123.4pf` -&gt; `float.__suffix_pf__(123.4)`
ExprPtr SimplifyVisitor::transformFloat(FloatExpr *expr) {
  if (!expr-&gt;floatValue) {
    /// TODO: currently assumes that floats are always 64-bit.
    /// Should use str constructors if available for floats with suffix instead.
    E(Error::FLOAT_RANGE, expr, expr-&gt;value);
  }

  if (expr-&gt;suffix.empty()) {
    /// A normal float (double)
    return N&lt;FloatExpr&gt;(*(expr-&gt;floatValue));
  } else {
    // Custom suffix: call `float.__suffix_[suffix]__(value)`
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("float", format("__suffix_{}__", expr-&gt;suffix)),
                    N&lt;FloatExpr&gt;(*(expr-&gt;floatValue))));
  }
}

/// Parse a Python-like f-string into a concatenation:
///   `f"foo {x+1} bar"` -&gt; `str.cat("foo ", str(x+1), " bar")`
/// Supports "{x=}" specifier (that prints the raw expression as well):
///   `f"{x+1=}"` -&gt; `str.cat("x+1=", str(x+1))`
ExprPtr SimplifyVisitor::transformFString(const std::string &amp;value) {
  // Strings to be concatenated
  std::vector&lt;ExprPtr&gt; items;
  int braceCount = 0, braceStart = 0;
  for (int i = 0; i &lt; value.size(); i++) {
    if (value[i] == '{') {
      if (braceStart &lt; i)
        items.push_back(N&lt;StringExpr&gt;(value.substr(braceStart, i - braceStart)));
      if (!braceCount)
        braceStart = i + 1;
      braceCount++;
    } else if (value[i] == '}') {
      braceCount--;
      if (!braceCount) {
        std::string code = value.substr(braceStart, i - braceStart);
        auto offset = getSrcInfo();
        offset.col += i;
        if (!code.empty() &amp;&amp; code.back() == '=') {
          // Special case: f"{x=}"
          code = code.substr(0, code.size() - 1);
          items.push_back(N&lt;StringExpr&gt;(fmt::format("{}=", code)));
        }
        auto [expr, format] = parseExpr(ctx-&gt;cache, code, offset);
        if (!format.empty()) {
          items.push_back(
              N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr, "__format__"), N&lt;StringExpr&gt;(format)));
        } else {
          // Every expression is wrapped within `str`
          items.push_back(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("str"), expr));
        }
      }
      braceStart = i + 1;
    }
  }
  if (braceCount &gt; 0)
    E(Error::STR_FSTRING_BALANCE_EXTRA, getSrcInfo());
  if (braceCount &lt; 0)
    E(Error::STR_FSTRING_BALANCE_MISSING, getSrcInfo());
  if (braceStart != value.size())
    items.push_back(N&lt;StringExpr&gt;(value.substr(braceStart, value.size() - braceStart)));
  return transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("str", "cat"), items));
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.707">/// Concatenate string sequence (e.g., `"a" "b" "c"`) into a single string.
/// Parse f-strings and custom prefix strings.
/// Also see @c transformFString
void SimplifyVisitor::visit(StringExpr *expr) {
  std::vector&lt;ExprPtr&gt; exprs;
  std::vector&lt;std::string&gt; concat;
  for (auto &amp;p : expr-&gt;strings) {
    if (p.second == "f" || p.second == "F") {
      /// Transform an F-string
      exprs.push_back(transformFString(p.first));
    } else if (!p.second.empty()) {
      /// Custom prefix strings:
      /// call `str.__prefix_[prefix]__(str, [static length of str])`
      exprs.push_back(
          transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("str", format("__prefix_{}__", p.second)),
                                N&lt;StringExpr&gt;(p.first), N&lt;IntExpr&gt;(p.first.size()))));
    } else {
      exprs.push_back(N&lt;StringExpr&gt;(p.first));
      concat.push_back(p.first);
    }
  }
  if (concat.size() == expr-&gt;strings.size()) {
    /// Simple case: statically concatenate a sequence of strings without any prefix
    expr-&gt;strings = {{combine2(concat, ""), ""}};
  } else if (exprs.size() == 1) {
    /// Simple case: only one string in a sequence
    resultExpr = std::move(exprs[0]);
  } else {
    /// Complex case: call `str.cat(str1, ...)`
    resultExpr = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("str", "cat"), exprs));
  }
}

</t>
<t tx="ekr.20230509083243.708">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
/// Transform `tuple(i for i in tup)` into a GeneratorExpr that will be handled during
/// the type checking.
ExprPtr
SimplifyVisitor::transformTupleGenerator(const std::vector&lt;CallExpr::Arg&gt; &amp;args) {
  GeneratorExpr *g = nullptr;
  // We currently allow only a simple iterations over tuples
  if (args.size() != 1 || !(g = CAST(args[0].value, GeneratorExpr)) ||
      g-&gt;kind != GeneratorExpr::Generator || g-&gt;loops.size() != 1 ||
      !g-&gt;loops[0].conds.empty())
    E(Error::CALL_TUPLE_COMPREHENSION, args[0].value);
  auto var = clone(g-&gt;loops[0].vars);
  auto ex = clone(g-&gt;expr);

  ctx-&gt;enterConditionalBlock();
  ctx-&gt;getBase()-&gt;loops.push_back({"", ctx-&gt;scope.blocks, {}});
  if (auto i = var-&gt;getId()) {
    ctx-&gt;addVar(i-&gt;value, ctx-&gt;generateCanonicalName(i-&gt;value), var-&gt;getSrcInfo());
    var = transform(var);
    ex = transform(ex);
  } else {
    std::string varName = ctx-&gt;cache-&gt;getTemporaryVar("for");
    ctx-&gt;addVar(varName, varName, var-&gt;getSrcInfo());
    var = N&lt;IdExpr&gt;(varName);
    auto head = transform(N&lt;AssignStmt&gt;(clone(g-&gt;loops[0].vars), clone(var)));
    ex = N&lt;StmtExpr&gt;(head, transform(ex));
  }
  ctx-&gt;leaveConditionalBlock();
  // Dominate loop variables
  for (auto &amp;var : ctx-&gt;getBase()-&gt;getLoop()-&gt;seenVars)
    ctx-&gt;findDominatingBinding(var);
  ctx-&gt;getBase()-&gt;loops.pop_back();
  return N&lt;GeneratorExpr&gt;(
      GeneratorExpr::Generator, ex,
      std::vector&lt;GeneratorBody&gt;{{var, transform(g-&gt;loops[0].gen), {}}});
}

/// Transform named tuples.
/// @example
///   `namedtuple("NT", ["a", ("b", int)])` -&gt; ```@tuple
///                                               class NT[T1]:
///                                                 a: T1
///                                                 b: int```
ExprPtr SimplifyVisitor::transformNamedTuple(const std::vector&lt;CallExpr::Arg&gt; &amp;args) {
  // Ensure that namedtuple call is valid
  if (args.size() != 2 || !args[0].value-&gt;getString() || !args[1].value-&gt;getList())
    E(Error::CALL_NAMEDTUPLE, getSrcInfo());

  // Construct the class statement
  std::vector&lt;Param&gt; generics, params;
  int ti = 1;
  for (auto &amp;i : args[1].value-&gt;getList()-&gt;items) {
    if (auto s = i-&gt;getString()) {
      generics.emplace_back(Param{format("T{}", ti), N&lt;IdExpr&gt;("type"), nullptr, true});
      params.emplace_back(
          Param{s-&gt;getValue(), N&lt;IdExpr&gt;(format("T{}", ti++)), nullptr});
    } else if (i-&gt;getTuple() &amp;&amp; i-&gt;getTuple()-&gt;items.size() == 2 &amp;&amp;
               i-&gt;getTuple()-&gt;items[0]-&gt;getString()) {
      params.emplace_back(Param{i-&gt;getTuple()-&gt;items[0]-&gt;getString()-&gt;getValue(),
                                transformType(i-&gt;getTuple()-&gt;items[1]), nullptr});
    } else {
      E(Error::CALL_NAMEDTUPLE, i);
    }
  }
  for (auto &amp;g : generics)
    params.push_back(g);
  auto name = args[0].value-&gt;getString()-&gt;getValue();
  prependStmts-&gt;push_back(transform(
      N&lt;ClassStmt&gt;(name, params, nullptr, std::vector&lt;ExprPtr&gt;{N&lt;IdExpr&gt;("tuple")})));
  return transformType(N&lt;IdExpr&gt;(name));
}

/// Transform partial calls (Python syntax).
/// @example
///   `partial(foo, 1, a=2)` -&gt; `foo(1, a=2, ...)`
ExprPtr SimplifyVisitor::transformFunctoolsPartial(std::vector&lt;CallExpr::Arg&gt; args) {
  if (args.empty())
    E(Error::CALL_PARTIAL, getSrcInfo());
  auto name = clone(args[0].value);
  args.erase(args.begin());
  args.push_back({"", N&lt;EllipsisExpr&gt;()});
  return transform(N&lt;CallExpr&gt;(name, args));
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.709">/// Transform print statement.
/// @example
///   `print a, b` -&gt; `print(a, b)`
///   `print a, b,` -&gt; `print(a, b, end=' ')`
void SimplifyVisitor::visit(PrintStmt *stmt) {
  std::vector&lt;CallExpr::Arg&gt; args;
  for (auto &amp;i : stmt-&gt;items)
    args.push_back({"", transform(i)});
  if (stmt-&gt;isInline)
    args.push_back({"end", N&lt;StringExpr&gt;(" ")});
  resultStmt = N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(transform(N&lt;IdExpr&gt;("print")), args));
}

</t>
<t tx="ekr.20230509083243.71">  bool doIsAtomic() const override {
    return !std::any_of(fields.begin(), fields.end(),
                        [](auto &amp;field) { return !field.getType()-&gt;isAtomic(); });
  }
</t>
<t tx="ekr.20230509083243.710">/// Transform calls. The real stuff happens during the type checking.
/// Here just perform some sanity checks and transform some special calls
/// (see @c transformSpecialCall for details).
void SimplifyVisitor::visit(CallExpr *expr) {
  transform(expr-&gt;expr, true);
  if ((resultExpr = transformSpecialCall(expr-&gt;expr, expr-&gt;args)))
    return;

  for (auto &amp;i : expr-&gt;args) {
    if (auto el = i.value-&gt;getEllipsis()) {
      if (el-&gt;isPipeArg || &amp;(i) == &amp;(expr-&gt;args.back()))
        continue;
    }
    transform(i.value, true);
  }
}

</t>
<t tx="ekr.20230509083243.711">/// Simplify the following special call expressions:
///   `tuple(i for i in tup)`      (tuple generators)
///   `std.collections.namedtuple` (sugar for @tuple class)
///   `std.functools.partial`      (sugar for partial calls)
/// Check validity of `type()` call. See below for more details.
ExprPtr SimplifyVisitor::transformSpecialCall(const ExprPtr &amp;callee,
</t>
<t tx="ekr.20230509083243.712">                                              const std::vector&lt;CallExpr::Arg&gt; &amp;args) {
  if (callee-&gt;isId("tuple") &amp;&amp; args.size() == 1 &amp;&amp;
      CAST(args.front().value, GeneratorExpr)) {
    // tuple(i for i in j)
    return transformTupleGenerator(args);
  } else if (callee-&gt;isId("type") &amp;&amp; !ctx-&gt;allowTypeOf) {
    // type(i)
    E(Error::CALL_NO_TYPE, getSrcInfo());
  } else if (callee-&gt;isId("std.collections.namedtuple")) {
    // namedtuple('Foo', ['x', 'y'])
    return transformNamedTuple(args);
  } else if (callee-&gt;isId("std.functools.partial")) {
    // partial(foo, a=5)
    return transformFunctoolsPartial(args);
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.713">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.714">/// Transform class and type definitions, as well as extensions.
/// See below for details.
void SimplifyVisitor::visit(ClassStmt *stmt) {
  // Get root name
  std::string name = stmt-&gt;name;

  // Generate/find class' canonical name (unique ID) and AST
  std::string canonicalName;
  std::vector&lt;Param&gt; &amp;argsToParse = stmt-&gt;args;

  @others
  } catch (const exc::ParserException &amp;) {
    if (!stmt-&gt;attributes.has(Attr::Tuple))
      ctx-&gt;remove(name);
    ctx-&gt;cache-&gt;classes.erase(name);
    throw;
  }
  for (auto &amp;i : addLater)
    ctx-&gt;add(ctx-&gt;cache-&gt;rev(i-&gt;canonicalName), i);

  // Extensions are not needed as the cache is already populated
  if (!stmt-&gt;attributes.has(Attr::Extend)) {
    auto c = ctx-&gt;cache-&gt;classes[canonicalName].ast;
    seqassert(c, "not a class AST for {}", canonicalName);
    clsStmts.push_back(c);
  }

  clsStmts.insert(clsStmts.end(), fnStmts.begin(), fnStmts.end());
  for (auto &amp;a : varStmts) {
    // Transform class variables here to allow self-references
    if (auto assign = a-&gt;getAssign()) {
      transform(assign-&gt;rhs);
      transformType(assign-&gt;type);
    }
    clsStmts.push_back(a);
  }
  resultStmt = N&lt;SuiteStmt&gt;(clsStmts);
}

</t>
<t tx="ekr.20230509083243.715">// classItem will be added later when the scope is different
auto classItem = std::make_shared&lt;SimplifyItem&gt;(SimplifyItem::Type, "", "",
                                                ctx-&gt;getModule(), ctx-&gt;scope.blocks);
classItem-&gt;setSrcInfo(stmt-&gt;getSrcInfo());
if (!stmt-&gt;attributes.has(Attr::Extend)) {
  classItem-&gt;canonicalName = canonicalName =
      ctx-&gt;generateCanonicalName(name, !stmt-&gt;attributes.has(Attr::Internal));
  // Reference types are added to the context here.
  // Tuple types are added after class contents are parsed to prevent
  // recursive record types (note: these are allowed for reference types)
  if (!stmt-&gt;attributes.has(Attr::Tuple)) {
    ctx-&gt;add(name, classItem);
    ctx-&gt;addAlwaysVisible(classItem);
  }
} else {
  // Find the canonical name and AST of the class that is to be extended
  if (!ctx-&gt;isGlobal() || ctx-&gt;isConditional())
    E(Error::EXPECTED_TOPLEVEL, getSrcInfo(), "class extension");
  auto val = ctx-&gt;find(name);
  if (!val || !val-&gt;isType())
    E(Error::CLASS_ID_NOT_FOUND, getSrcInfo(), name);
  canonicalName = val-&gt;canonicalName;
  const auto &amp;astIter = ctx-&gt;cache-&gt;classes.find(canonicalName);
  if (astIter == ctx-&gt;cache-&gt;classes.end()) {
    E(Error::CLASS_ID_NOT_FOUND, getSrcInfo(), name);
  } else {
    argsToParse = astIter-&gt;second.ast-&gt;args;
  }
}

</t>
<t tx="ekr.20230509083243.716">std::vector&lt;StmtPtr&gt; clsStmts; // Will be filled later!
std::vector&lt;StmtPtr&gt; varStmts; // Will be filled later!
std::vector&lt;StmtPtr&gt; fnStmts;  // Will be filled later!
std::vector&lt;SimplifyContext::Item&gt; addLater;
try {
  // Add the class base
  SimplifyContext::BaseGuard br(ctx.get(), canonicalName);

  // Parse and add class generics
  std::vector&lt;Param&gt; args;
  std::pair&lt;StmtPtr, FunctionStmt *&gt; autoDeducedInit{nullptr, nullptr};
  if (stmt-&gt;attributes.has("deduce") &amp;&amp; args.empty()) {
    // Auto-detect generics and fields
    autoDeducedInit = autoDeduceMembers(stmt, args);
  } else {
    // Add all generics before parent classes, fields and methods
    for (auto &amp;a : argsToParse) {
      if (a.status != Param::Generic)
        continue;
      std::string genName, varName;
      if (stmt-&gt;attributes.has(Attr::Extend))
        varName = a.name, genName = ctx-&gt;cache-&gt;rev(a.name);
      else
        varName = ctx-&gt;generateCanonicalName(a.name), genName = a.name;
      if (auto st = getStaticGeneric(a.type.get())) {
        auto val = ctx-&gt;addVar(genName, varName, a.type-&gt;getSrcInfo());
        val-&gt;generic = true;
        val-&gt;staticType = st;
      } else {
        ctx-&gt;addType(genName, varName, a.type-&gt;getSrcInfo())-&gt;generic = true;
      }
      args.emplace_back(Param{varName, transformType(clone(a.type), false),
                              transformType(clone(a.defaultValue), false), a.status});
    }
  }

  // Form class type node (e.g. `Foo`, or `Foo[T, U]` for generic classes)
  ExprPtr typeAst = N&lt;IdExpr&gt;(name), transformedTypeAst = NT&lt;IdExpr&gt;(canonicalName);
  for (auto &amp;a : args) {
    if (a.status == Param::Generic) {
      if (!typeAst-&gt;getIndex()) {
        typeAst = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(name), N&lt;TupleExpr&gt;());
        transformedTypeAst =
            NT&lt;InstantiateExpr&gt;(NT&lt;IdExpr&gt;(canonicalName), std::vector&lt;ExprPtr&gt;{});
      }
      typeAst-&gt;getIndex()-&gt;index-&gt;getTuple()-&gt;items.push_back(N&lt;IdExpr&gt;(a.name));
      CAST(transformedTypeAst, InstantiateExpr)
          -&gt;typeParams.push_back(transform(N&lt;IdExpr&gt;(a.name), true));
    }
  }

  // Collect classes (and their fields) that are to be statically inherited
  std::vector&lt;ClassStmt *&gt; staticBaseASTs, baseASTs;
  if (!stmt-&gt;attributes.has(Attr::Extend)) {
    staticBaseASTs = parseBaseClasses(stmt-&gt;staticBaseClasses, args, stmt-&gt;attributes,
                                      canonicalName);
    if (ctx-&gt;cache-&gt;isJit &amp;&amp; !stmt-&gt;baseClasses.empty())
      E(Error::CUSTOM, stmt-&gt;baseClasses[0],
        "inheritance is not yet supported in JIT mode");
    parseBaseClasses(stmt-&gt;baseClasses, args, stmt-&gt;attributes, canonicalName,
                     transformedTypeAst);
  }

  // A ClassStmt will be separated into class variable assignments, method-free
  // ClassStmts (that include nested classes) and method FunctionStmts
  transformNestedClasses(stmt, clsStmts, varStmts, fnStmts);

  // Collect class fields
  for (auto &amp;a : argsToParse) {
    if (a.status == Param::Normal) {
      if (!ClassStmt::isClassVar(a)) {
        args.emplace_back(Param{a.name, transformType(clone(a.type), false),
                                transform(clone(a.defaultValue), true)});
      } else if (!stmt-&gt;attributes.has(Attr::Extend)) {
        // Handle class variables. Transform them later to allow self-references
        auto name = format("{}.{}", canonicalName, a.name);
        preamble-&gt;push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(name), nullptr, nullptr));
        ctx-&gt;cache-&gt;addGlobal(name);
        auto assign = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(name), a.defaultValue,
                                    a.type ? a.type-&gt;getIndex()-&gt;index : nullptr);
        assign-&gt;setUpdate();
        varStmts.push_back(assign);
        ctx-&gt;cache-&gt;classes[canonicalName].classVars[a.name] = name;
      }
    }
  }

  // ASTs for member arguments to be used for populating magic methods
  std::vector&lt;Param&gt; memberArgs;
  for (auto &amp;a : args) {
    if (a.status == Param::Normal)
      memberArgs.push_back(a.clone());
  }

  // Ensure that all fields and class variables are registered
  if (!stmt-&gt;attributes.has(Attr::Extend)) {
    for (size_t ai = 0; ai &lt; args.size();) {
      if (args[ai].status == Param::Normal)
        ctx-&gt;cache-&gt;classes[canonicalName].fields.push_back({args[ai].name, nullptr});
      ai++;
    }
  }

  // Parse class members (arguments) and methods
  if (!stmt-&gt;attributes.has(Attr::Extend)) {
    // Now that we are done with arguments, add record type to the context
    if (stmt-&gt;attributes.has(Attr::Tuple)) {
      // Ensure that class binding does not shadow anything.
      // Class bindings cannot be dominated either
      auto v = ctx-&gt;find(name);
      if (v &amp;&amp; v-&gt;noShadow)
        E(Error::CLASS_INVALID_BIND, stmt, name);
      ctx-&gt;add(name, classItem);
      ctx-&gt;addAlwaysVisible(classItem);
    }
    // Create a cached AST.
    stmt-&gt;attributes.module =
        format("{}{}", ctx-&gt;moduleName.status == ImportFile::STDLIB ? "std::" : "::",
               ctx-&gt;moduleName.module);
    ctx-&gt;cache-&gt;classes[canonicalName].ast =
        N&lt;ClassStmt&gt;(canonicalName, args, N&lt;SuiteStmt&gt;(), stmt-&gt;attributes);
    ctx-&gt;cache-&gt;classes[canonicalName].ast-&gt;baseClasses = stmt-&gt;baseClasses;
    for (auto &amp;b : staticBaseASTs)
      ctx-&gt;cache-&gt;classes[canonicalName].staticParentClasses.emplace_back(b-&gt;name);
    ctx-&gt;cache-&gt;classes[canonicalName].ast-&gt;validate();
    ctx-&gt;cache-&gt;classes[canonicalName].module = ctx-&gt;getModule();

    // Codegen default magic methods
    for (auto &amp;m : stmt-&gt;attributes.magics) {
      fnStmts.push_back(transform(
          codegenMagic(m, typeAst, memberArgs, stmt-&gt;attributes.has(Attr::Tuple))));
    }
    // Add inherited methods
    for (auto &amp;base : staticBaseASTs) {
      for (auto &amp;mm : ctx-&gt;cache-&gt;classes[base-&gt;name].methods)
        for (auto &amp;mf : ctx-&gt;cache-&gt;overloads[mm.second]) {
          auto f = ctx-&gt;cache-&gt;functions[mf.name].ast;
          if (!f-&gt;attributes.has("autogenerated")) {
            std::string rootName;
            auto &amp;mts = ctx-&gt;cache-&gt;classes[ctx-&gt;getBase()-&gt;name].methods;
            auto it = mts.find(ctx-&gt;cache-&gt;rev(f-&gt;name));
            if (it != mts.end())
              rootName = it-&gt;second;
            else
              rootName = ctx-&gt;generateCanonicalName(ctx-&gt;cache-&gt;rev(f-&gt;name), true);
            auto newCanonicalName =
                format("{}:{}", rootName, ctx-&gt;cache-&gt;overloads[rootName].size());
            ctx-&gt;cache-&gt;overloads[rootName].push_back(
                {newCanonicalName, ctx-&gt;cache-&gt;age});
            ctx-&gt;cache-&gt;reverseIdentifierLookup[newCanonicalName] =
                ctx-&gt;cache-&gt;rev(f-&gt;name);
            auto nf = std::dynamic_pointer_cast&lt;FunctionStmt&gt;(f-&gt;clone());
            nf-&gt;name = newCanonicalName;
            nf-&gt;attributes.parentClass = ctx-&gt;getBase()-&gt;name;
            ctx-&gt;cache-&gt;functions[newCanonicalName].ast = nf;
            ctx-&gt;cache-&gt;classes[ctx-&gt;getBase()-&gt;name]
                .methods[ctx-&gt;cache-&gt;rev(f-&gt;name)] = rootName;
            fnStmts.push_back(nf);
          }
        }
    }
    // Add auto-deduced __init__ (if available)
    if (autoDeducedInit.first)
      fnStmts.push_back(autoDeducedInit.first);
  }
  // Add class methods
  for (const auto &amp;sp : getClassMethods(stmt-&gt;suite))
    if (sp &amp;&amp; sp-&gt;getFunction()) {
      if (sp.get() != autoDeducedInit.second)
        fnStmts.push_back(transform(sp));
    }

  // After popping context block, record types and nested classes will disappear.
  // Store their references and re-add them to the context after popping
  addLater.reserve(clsStmts.size() + 1);
  for (auto &amp;c : clsStmts)
    addLater.push_back(ctx-&gt;find(c-&gt;getClass()-&gt;name));
  if (stmt-&gt;attributes.has(Attr::Tuple))
    addLater.push_back(ctx-&gt;forceFind(name));

</t>
<t tx="ekr.20230509083243.717">  // Mark functions as virtual:
  auto banned =
      std::set&lt;std::string&gt;{"__init__", "__new__", "__raw__", "__tuplesize__"};
  for (auto &amp;m : ctx-&gt;cache-&gt;classes[canonicalName].methods) {
    auto method = m.first;
    for (size_t mi = 1; mi &lt; ctx-&gt;cache-&gt;classes[canonicalName].mro.size(); mi++) {
      // ... in the current class
      auto b = ctx-&gt;cache-&gt;classes[canonicalName].mro[mi]-&gt;getTypeName();
      if (in(ctx-&gt;cache-&gt;classes[b].methods, method) &amp;&amp; !in(banned, method)) {
        ctx-&gt;cache-&gt;classes[canonicalName].virtuals.insert(method);
      }
    }
    for (auto &amp;v : ctx-&gt;cache-&gt;classes[canonicalName].virtuals) {
      for (size_t mi = 1; mi &lt; ctx-&gt;cache-&gt;classes[canonicalName].mro.size(); mi++) {
        // ... and in parent classes
        auto b = ctx-&gt;cache-&gt;classes[canonicalName].mro[mi]-&gt;getTypeName();
        ctx-&gt;cache-&gt;classes[b].virtuals.insert(v);
      }
    }
  }
</t>
<t tx="ekr.20230509083243.718">/// Parse statically inherited classes.
/// Returns a list of their ASTs. Also updates the class fields.
/// @param args Class fields that are to be updated with base classes' fields.
/// @param typeAst Transformed AST for base class type (e.g., `A[T]`).
///                Only set when dealing with dynamic polymorphism.
std::vector&lt;ClassStmt *&gt; SimplifyVisitor::parseBaseClasses(
    std::vector&lt;ExprPtr&gt; &amp;baseClasses, std::vector&lt;Param&gt; &amp;args, const Attr &amp;attr,
</t>
<t tx="ekr.20230509083243.719">    const std::string &amp;canonicalName, const ExprPtr &amp;typeAst) {
  std::vector&lt;ClassStmt *&gt; asts;

  // MAJOR TODO: fix MRO it to work with generic classes (maybe replacements? IDK...)
  std::vector&lt;std::vector&lt;ExprPtr&gt;&gt; mro{{typeAst}};
  std::vector&lt;ExprPtr&gt; parentClasses;
  for (auto &amp;cls : baseClasses) {
    std::string name;
    std::vector&lt;ExprPtr&gt; subs;

    // Get the base class and generic replacements (e.g., if there is Bar[T],
    // Bar in Foo(Bar[int]) will have `T = int`)
    transformType(cls);
    if (auto i = cls-&gt;getId()) {
      name = i-&gt;value;
    } else if (auto e = CAST(cls, InstantiateExpr)) {
      if (auto ei = e-&gt;typeExpr-&gt;getId()) {
        name = ei-&gt;value;
        subs = e-&gt;typeParams;
      }
    }

    auto cachedCls = const_cast&lt;Cache::Class *&gt;(in(ctx-&gt;cache-&gt;classes, name));
    if (!cachedCls)
      E(Error::CLASS_ID_NOT_FOUND, getSrcInfo(), ctx-&gt;cache-&gt;rev(name));
    asts.push_back(cachedCls-&gt;ast.get());
    parentClasses.push_back(clone(cls));
    mro.push_back(cachedCls-&gt;mro);

    // Sanity checks
    if (attr.has(Attr::Tuple) &amp;&amp; typeAst)
      E(Error::CLASS_NO_INHERIT, getSrcInfo(), "tuple");
    if (!attr.has(Attr::Tuple) &amp;&amp; asts.back()-&gt;attributes.has(Attr::Tuple))
      E(Error::CLASS_TUPLE_INHERIT, getSrcInfo());
    if (asts.back()-&gt;attributes.has(Attr::Internal))
      E(Error::CLASS_NO_INHERIT, getSrcInfo(), "internal");

    // Add __vtable__ to parent classes if it is not there already
    auto var = format("{}.{}", VAR_VTABLE, name);
    if (typeAst &amp;&amp; (cachedCls-&gt;fields.empty() || cachedCls-&gt;fields[0].name != var)) {
      // LOG("[virtual] vtable({}) := {}", name, var);
      cachedCls-&gt;fields.insert(cachedCls-&gt;fields.begin(), {var, nullptr});
      cachedCls-&gt;ast-&gt;args.insert(
          cachedCls-&gt;ast-&gt;args.begin(),
          Param{var, transformType(N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Ptr"), N&lt;IdExpr&gt;("cobj"))),
                nullptr});
    }

    // Add generics first
    int nGenerics = 0;
    for (auto &amp;a : asts.back()-&gt;args)
      nGenerics += a.status == Param::Generic;
    int si = 0;
    for (auto &amp;a : asts.back()-&gt;args) {
      if (a.status == Param::Generic) {
        if (si == subs.size())
          E(Error::GENERICS_MISMATCH, cls, ctx-&gt;cache-&gt;rev(asts.back()-&gt;name),
            nGenerics, subs.size());
        args.emplace_back(Param{a.name, a.type, transformType(subs[si++], false),
                                Param::HiddenGeneric});
      } else if (a.status == Param::HiddenGeneric) {
        args.emplace_back(a);
      }
      if (a.status != Param::Normal) {
        if (auto st = getStaticGeneric(a.type.get())) {
          auto val = ctx-&gt;addVar(a.name, a.name, a.type-&gt;getSrcInfo());
          val-&gt;generic = true;
          val-&gt;staticType = st;
        } else {
          ctx-&gt;addType(a.name, a.name, a.type-&gt;getSrcInfo())-&gt;generic = true;
        }
      }
    }
    if (si != subs.size())
      E(Error::GENERICS_MISMATCH, cls, ctx-&gt;cache-&gt;rev(asts.back()-&gt;name), nGenerics,
        subs.size());
  }
  // Add normal fields
  for (auto &amp;ast : asts) {
    for (auto &amp;a : ast-&gt;args) {
      if (a.status == Param::Normal &amp;&amp; !ClassStmt::isClassVar(a)) {
        auto name = a.name;
        if (startswith(name, VAR_VTABLE)) { // prevent clashing names
          int i = 0;
          for (auto &amp;aa : args)
            i += bool(startswith(aa.name, a.name));
          if (i)
            name = format("{}#{}", name, i);
        }
        args.emplace_back(Param{name, a.type, a.defaultValue});
      }
    }
  }
  if (typeAst) {
    if (!parentClasses.empty())
      mro.push_back(parentClasses);
    ctx-&gt;cache-&gt;classes[canonicalName].mro = Cache::mergeC3(mro);
    if (ctx-&gt;cache-&gt;classes[canonicalName].mro.empty()) {
      E(Error::CLASS_BAD_MRO, getSrcInfo());
    } else if (ctx-&gt;cache-&gt;classes[canonicalName].mro.size() &gt; 1) {
      // LOG("[mro] {} -&gt; {}", canonicalName, ctx-&gt;cache-&gt;classes[canonicalName].mro);
    }
  }
  return asts;
}

</t>
<t tx="ekr.20230509083243.72">/// Membered type that is passed by reference. Similar to Python classes.
class RefType : public AcceptorExtend&lt;RefType, MemberedType&gt; {
private:
  /// the internal contents of the type
  Type *contents;

public:
  static const char NodeId;

  /// Constructs a reference type.
  /// @param name the type's name
  /// @param contents the type's contents
  RefType(std::string name, RecordType *contents)
      : AcceptorExtend(std::move(name)), contents(contents) {}

  Type *getMemberType(const std::string &amp;n) const override {
    return getContents()-&gt;getMemberType(n);
  }
@others
private:
  std::vector&lt;Type *&gt; doGetUsedTypes() const override { return {contents}; }

  bool doIsAtomic() const override { return false; }

  bool doIsContentAtomic() const override;

  Value *doConstruct(std::vector&lt;Value *&gt; args) override;
};

</t>
<t tx="ekr.20230509083243.720">/// Find the first __init__ with self parameter and use it to deduce class members.
/// Each deduced member will be treated as generic.
/// @example
///   ```@deduce
///      class Foo:
///        def __init__(self):
///          self.x, self.y = 1, 2```
///   will result in
///   ```class Foo[T1, T2]:
///        x: T1
///        y: T2```
/// @return the transformed init and the pointer to the original function.
std::pair&lt;StmtPtr, FunctionStmt *&gt;
SimplifyVisitor::autoDeduceMembers(ClassStmt *stmt, std::vector&lt;Param&gt; &amp;args) {
  std::pair&lt;StmtPtr, FunctionStmt *&gt; init{nullptr, nullptr};
  for (const auto &amp;sp : getClassMethods(stmt-&gt;suite))
    if (sp &amp;&amp; sp-&gt;getFunction()) {
      auto f = sp-&gt;getFunction();
      if (f-&gt;name == "__init__" &amp;&amp; !f-&gt;args.empty() &amp;&amp; f-&gt;args[0].name == "self") {
        // Set up deducedMembers that will be populated during AssignStmt evaluation
        ctx-&gt;getBase()-&gt;deducedMembers = std::make_shared&lt;std::vector&lt;std::string&gt;&gt;();
        auto transformed = transform(sp);
        transformed-&gt;getFunction()-&gt;attributes.set(Attr::RealizeWithoutSelf);
        ctx-&gt;cache-&gt;functions[transformed-&gt;getFunction()-&gt;name].ast-&gt;attributes.set(
            Attr::RealizeWithoutSelf);
        int i = 0;
        // Once done, add arguments
        for (auto &amp;m : *(ctx-&gt;getBase()-&gt;deducedMembers)) {
          auto varName = ctx-&gt;generateCanonicalName(format("T{}", ++i));
          auto memberName = ctx-&gt;cache-&gt;rev(varName);
          ctx-&gt;addType(memberName, varName, stmt-&gt;getSrcInfo())-&gt;generic = true;
          args.emplace_back(Param{varName, N&lt;IdExpr&gt;("type"), nullptr, Param::Generic});
          args.emplace_back(Param{m, N&lt;IdExpr&gt;(varName)});
        }
        ctx-&gt;getBase()-&gt;deducedMembers = nullptr;
        return {transformed, f};
      }
    }
  return {nullptr, nullptr};
}

/// Return a list of all statements within a given class suite.
/// Checks each suite recursively, and assumes that each statement is either
/// a function, a class or a docstring.
std::vector&lt;StmtPtr&gt; SimplifyVisitor::getClassMethods(const StmtPtr &amp;s) {
  std::vector&lt;StmtPtr&gt; v;
  if (!s)
    return v;
  if (auto sp = s-&gt;getSuite()) {
    for (const auto &amp;ss : sp-&gt;stmts)
      for (const auto &amp;u : getClassMethods(ss))
        v.push_back(u);
  } else if (s-&gt;getExpr() &amp;&amp; s-&gt;getExpr()-&gt;expr-&gt;getString()) {
    /// Those are doc-strings, ignore them.
  } else if (!s-&gt;getFunction() &amp;&amp; !s-&gt;getClass()) {
    E(Error::CLASS_BAD_ATTR, s);
  } else {
    v.push_back(s);
  }
  return v;
}

</t>
<t tx="ekr.20230509083243.721">/// Extract nested classes and transform them before the main class.
void SimplifyVisitor::transformNestedClasses(ClassStmt *stmt,
                                             std::vector&lt;StmtPtr&gt; &amp;clsStmts,
                                             std::vector&lt;StmtPtr&gt; &amp;varStmts,
                                             std::vector&lt;StmtPtr&gt; &amp;fnStmts) {
  for (const auto &amp;sp : getClassMethods(stmt-&gt;suite))
    if (sp &amp;&amp; sp-&gt;getClass()) {
      auto origName = sp-&gt;getClass()-&gt;name;
      // If class B is nested within A, it's name is always A.B, never B itself.
      // Ensure that parent class name is appended
      auto parentName = stmt-&gt;name;
      sp-&gt;getClass()-&gt;name = fmt::format("{}.{}", parentName, origName);
      auto tsp = transform(sp);
      std::string name;
      if (tsp-&gt;getSuite()) {
        for (auto &amp;s : tsp-&gt;getSuite()-&gt;stmts)
          if (auto c = s-&gt;getClass()) {
            clsStmts.push_back(s);
            name = c-&gt;name;
          } else if (auto a = s-&gt;getAssign()) {
            varStmts.push_back(s);
          } else {
            fnStmts.push_back(s);
          }
        ctx-&gt;add(origName, ctx-&gt;forceFind(name));
      }
    }
}

</t>
<t tx="ekr.20230509083243.722">/// Generate a magic method `__op__` for each magic `op`
/// described by @param typExpr and its arguments.
/// Currently generate:
/// @li Constructors: __new__, __init__
/// @li Utilities: __raw__, __hash__, __repr__
/// @li Iteration: __iter__, __getitem__, __len__, __contains__
/// @li Comparisons: __eq__, __ne__, __lt__, __le__, __gt__, __ge__
/// @li Pickling: __pickle__, __unpickle__
/// @li Python: __to_py__, __from_py__
/// TODO: move to Codon as much as possible
StmtPtr SimplifyVisitor::codegenMagic(const std::string &amp;op, const ExprPtr &amp;typExpr,
</t>
<t tx="ekr.20230509083243.723">                                      const std::vector&lt;Param&gt; &amp;allArgs,
@others
</t>
<t tx="ekr.20230509083243.724">                                      bool isRecord) {
#define I(s) N&lt;IdExpr&gt;(s)
  seqassert(typExpr, "typExpr is null");
  ExprPtr ret;
  std::vector&lt;Param&gt; fargs;
  std::vector&lt;StmtPtr&gt; stmts;
  Attr attr;
  attr.set("autogenerated");

  std::vector&lt;Param&gt; args;
  for (auto &amp;a : allArgs)
    if (!startswith(a.name, VAR_VTABLE))
      args.push_back(a);

  if (op == "new") {
    // Classes: @internal def __new__() -&gt; T
    // Tuples: @internal def __new__(a1: T1, ..., aN: TN) -&gt; T
    ret = typExpr-&gt;clone();
    if (isRecord) {
      for (auto &amp;a : args)
        fargs.emplace_back(
            Param{a.name, clone(a.type),
                  a.defaultValue ? clone(a.defaultValue) : N&lt;CallExpr&gt;(clone(a.type))});
      attr.set(Attr::Internal);
    } else {
      stmts.emplace_back(N&lt;ReturnStmt&gt;(
          N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "class_new"), typExpr-&gt;clone())));
    }
  } else if (op == "init") {
    // Classes: def __init__(self: T, a1: T1, ..., aN: TN) -&gt; void:
    //            self.aI = aI ...
    ret = I("NoneType");
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    for (auto &amp;a : args) {
      stmts.push_back(N&lt;AssignStmt&gt;(N&lt;DotExpr&gt;(I("self"), a.name), I(a.name)));
      fargs.emplace_back(
          Param{a.name, clone(a.type),
                a.defaultValue ? clone(a.defaultValue) : N&lt;CallExpr&gt;(clone(a.type))});
    }
  } else if (op == "raw") {
    // Classes: def __raw__(self: T) -&gt; Ptr[byte]:
    //            return __internal__.class_raw(self)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = N&lt;IndexExpr&gt;(I("Ptr"), I("byte"));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "class_raw"), I("self"))));
  } else if (op == "getitem") {
    // Tuples: def __getitem__(self: T, index: int) -&gt; T1:
    //           return __internal__.tuple_getitem[T, T1](self, index)
    //         (error during a realizeFunc() method if T is a heterogeneous tuple)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"index", I("int")});
    ret = !args.empty() ? clone(args[0].type) : I("NoneType");
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "tuple_getitem"), I("self"),
                    I("index"), typExpr-&gt;clone(), ret-&gt;clone())));
  } else if (op == "iter") {
    // Tuples: def __iter__(self: T) -&gt; Generator[T]:
    //           yield self.aI ...
    //         (error during a realizeFunc() method if T is a heterogeneous tuple)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = N&lt;IndexExpr&gt;(I("Generator"), !args.empty() ? clone(args[0].type) : I("int"));
    for (auto &amp;a : args)
      stmts.emplace_back(N&lt;YieldStmt&gt;(N&lt;DotExpr&gt;("self", a.name)));
    if (args.empty()) // Hack for empty tuple: yield from List[int]()
      stmts.emplace_back(
          N&lt;YieldFromStmt&gt;(N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(I("List"), I("int")))));
  } else if (op == "contains") {
    // Tuples: def __contains__(self: T, what) -&gt; bool:
    //            if isinstance(what, T1): if what == self.a1: return True ...
    //            return False
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"what", nullptr});
    ret = I("bool");
    for (auto &amp;a : args)
      stmts.push_back(N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(I("isinstance"), I("what"), clone(a.type)),
                                N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("what"), "__eq__"),
                                                      N&lt;DotExpr&gt;(I("self"), a.name)),
                                          N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(true)))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(false)));
  } else if (op == "eq") {
    // def __eq__(self: T, other: T) -&gt; bool:
    //   if not self.arg1.__eq__(other.arg1): return False ...
    //   return True
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = I("bool");
    for (auto &amp;a : args)
      stmts.push_back(N&lt;IfStmt&gt;(
          N&lt;UnaryExpr&gt;("!",
                       N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), a.name), "__eq__"),
                                   N&lt;DotExpr&gt;(I("other"), a.name))),
          N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(false))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(true)));
  } else if (op == "ne") {
    // def __ne__(self: T, other: T) -&gt; bool:
    //   if self.arg1.__ne__(other.arg1): return True ...
    //   return False
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = I("bool");
    for (auto &amp;a : args)
      stmts.emplace_back(
          N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), a.name), "__ne__"),
                                N&lt;DotExpr&gt;(I("other"), a.name)),
                    N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(true))));
    stmts.push_back(N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(false)));
  } else if (op == "lt" || op == "gt") {
    // def __lt__(self: T, other: T) -&gt; bool:  (same for __gt__)
    //   if self.arg1.__lt__(other.arg1): return True
    //   elif self.arg1.__eq__(other.arg1):
    //      ... (arg2, ...) ...
    //   return False
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = I("bool");
    std::vector&lt;StmtPtr&gt; *v = &amp;stmts;
    for (size_t i = 0; i + 1 &lt; args.size(); i++) {
      v-&gt;emplace_back(N&lt;IfStmt&gt;(
          N&lt;CallExpr&gt;(
              N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name), format("__{}__", op)),
              N&lt;DotExpr&gt;(I("other"), args[i].name)),
          N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(true)),
          N&lt;IfStmt&gt;(
              N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name), "__eq__"),
                          N&lt;DotExpr&gt;(I("other"), args[i].name)),
              N&lt;SuiteStmt&gt;())));
      v = &amp;((SuiteStmt *)(((IfStmt *)(((IfStmt *)(v-&gt;back().get()))-&gt;elseSuite.get()))
                              -&gt;ifSuite)
                .get())
               -&gt;stmts;
    }
    if (!args.empty())
      v-&gt;emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args.back().name), format("__{}__", op)),
          N&lt;DotExpr&gt;(I("other"), args.back().name))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(false)));
  } else if (op == "le" || op == "ge") {
    // def __le__(self: T, other: T) -&gt; bool:  (same for __ge__)
    //   if not self.arg1.__le__(other.arg1): return False
    //   elif self.arg1.__eq__(other.arg1):
    //      ... (arg2, ...) ...
    //   return True
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = I("bool");
    std::vector&lt;StmtPtr&gt; *v = &amp;stmts;
    for (size_t i = 0; i + 1 &lt; args.size(); i++) {
      v-&gt;emplace_back(N&lt;IfStmt&gt;(
          N&lt;UnaryExpr&gt;("!", N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name),
                                                   format("__{}__", op)),
                                        N&lt;DotExpr&gt;(I("other"), args[i].name))),
          N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(false)),
          N&lt;IfStmt&gt;(
              N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name), "__eq__"),
                          N&lt;DotExpr&gt;(I("other"), args[i].name)),
              N&lt;SuiteStmt&gt;())));
      v = &amp;((SuiteStmt *)(((IfStmt *)(((IfStmt *)(v-&gt;back().get()))-&gt;elseSuite.get()))
                              -&gt;ifSuite)
                .get())
               -&gt;stmts;
    }
    if (!args.empty())
      v-&gt;emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args.back().name), format("__{}__", op)),
          N&lt;DotExpr&gt;(I("other"), args.back().name))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;BoolExpr&gt;(true)));
  } else if (op == "hash") {
    // def __hash__(self: T) -&gt; int:
    //   seed = 0
    //   seed = (
    //     seed ^ ((self.arg1.__hash__() + 2654435769) + ((seed &lt;&lt; 6) + (seed &gt;&gt; 2)))
    //   ) ...
    //   return seed
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = I("int");
    stmts.emplace_back(N&lt;AssignStmt&gt;(I("seed"), N&lt;IntExpr&gt;(0)));
    for (auto &amp;a : args)
      stmts.push_back(N&lt;AssignStmt&gt;(
          I("seed"),
          N&lt;BinaryExpr&gt;(
              I("seed"), "^",
              N&lt;BinaryExpr&gt;(
                  N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), a.name),
                                                       "__hash__")),
                                "+", N&lt;IntExpr&gt;(0x9e3779b9)),
                  "+",
                  N&lt;BinaryExpr&gt;(N&lt;BinaryExpr&gt;(I("seed"), "&lt;&lt;", N&lt;IntExpr&gt;(6)), "+",
                                N&lt;BinaryExpr&gt;(I("seed"), "&gt;&gt;", N&lt;IntExpr&gt;(2)))))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(I("seed")));
  } else if (op == "pickle") {
    // def __pickle__(self: T, dest: Ptr[byte]) -&gt; void:
    //   self.arg1.__pickle__(dest) ...
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"dest", N&lt;IndexExpr&gt;(I("Ptr"), I("byte"))});
    ret = I("NoneType");
    for (auto &amp;a : args)
      stmts.emplace_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), a.name), "__pickle__"), I("dest"))));
  } else if (op == "unpickle") {
    // def __unpickle__(src: Ptr[byte]) -&gt; T:
    //   return T(T1.__unpickle__(src),...)
    fargs.emplace_back(Param{"src", N&lt;IndexExpr&gt;(I("Ptr"), I("byte"))});
    ret = typExpr-&gt;clone();
    std::vector&lt;ExprPtr&gt; ar;
    ar.reserve(args.size());
    for (auto &amp;a : args)
      ar.emplace_back(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(a.type), "__unpickle__"), I("src")));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(typExpr-&gt;clone(), ar)));
  } else if (op == "len") {
    // def __len__(self: T) -&gt; int:
    //   return N (number of args)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = I("int");
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;IntExpr&gt;(args.size())));
  } else if (op == "to_py") {
    // def __to_py__(self: T) -&gt; cobj:
    //   o = pyobj._tuple_new(N)  (number of args)
    //   pyobj._tuple_set(o, 1, self.arg1.__to_py__()) ...
    //   return o
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = I("cobj");
    stmts.emplace_back(
        N&lt;AssignStmt&gt;(I("o"), N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("pyobj"), "_tuple_new"),
                                          N&lt;IntExpr&gt;(args.size()))));
    for (int i = 0; i &lt; args.size(); i++)
      stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(I("pyobj"), "_tuple_set"), I("o"), N&lt;IntExpr&gt;(i),
          N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name), "__to_py__")))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(I("o")));
  } else if (op == "from_py") {
    // def __from_py__(src: cobj) -&gt; T:
    //   return T(T1.__from_py__(pyobj._tuple_get(src, 1)), ...)
    fargs.emplace_back(Param{"src", I("cobj")});
    ret = typExpr-&gt;clone();
    std::vector&lt;ExprPtr&gt; ar;
    ar.reserve(args.size());
    for (int i = 0; i &lt; args.size(); i++)
      ar.push_back(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(clone(args[i].type), "__from_py__"),
          N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("pyobj"), "_tuple_get"), I("src"), N&lt;IntExpr&gt;(i))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(typExpr-&gt;clone(), ar)));
  } else if (op == "to_gpu") {
    // def __to_gpu__(self: T, cache) -&gt; T:
    //   return __internal__.class_to_gpu(self, cache)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"cache"});
    ret = typExpr-&gt;clone();
    stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
        N&lt;DotExpr&gt;(I("__internal__"), "class_to_gpu"), I("self"), I("cache"))));
  } else if (op == "from_gpu") {
    // def __from_gpu__(self: T, other: T) -&gt; None:
    //   __internal__.class_from_gpu(self, other)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = I("NoneType");
    stmts.emplace_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
        N&lt;DotExpr&gt;(I("__internal__"), "class_from_gpu"), I("self"), I("other"))));
  } else if (op == "from_gpu_new") {
    // def __from_gpu_new__(other: T) -&gt; T:
    //   return __internal__.class_from_gpu_new(other)
    fargs.emplace_back(Param{"other", typExpr-&gt;clone()});
    ret = typExpr-&gt;clone();
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "class_from_gpu_new"), I("other"))));
  } else if (op == "repr") {
    // def __repr__(self: T) -&gt; str:
    //   a = __array__[str](N)  (number of args)
    //   n = __array__[str](N)  (number of args)
    //   a.__setitem__(0, self.arg1.__repr__()) ...
    //   n.__setitem__(0, "arg1") ...  (if not a Tuple.N; otherwise "")
    //   return __internal__.tuple_str(a.ptr, n.ptr, N)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    ret = I("str");
    if (!args.empty()) {
      stmts.emplace_back(
          N&lt;AssignStmt&gt;(I("a"), N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(I("__array__"), I("str")),
                                            N&lt;IntExpr&gt;(args.size()))));
      stmts.emplace_back(
          N&lt;AssignStmt&gt;(I("n"), N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(I("__array__"), I("str")),
                                            N&lt;IntExpr&gt;(args.size()))));
      for (int i = 0; i &lt; args.size(); i++) {
        stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
            N&lt;DotExpr&gt;(I("a"), "__setitem__"), N&lt;IntExpr&gt;(i),
            N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;DotExpr&gt;(I("self"), args[i].name), "__repr__")))));

        auto name = typExpr-&gt;getIndex() ? typExpr-&gt;getIndex()-&gt;expr-&gt;getId() : nullptr;
        stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(
            N&lt;DotExpr&gt;(I("n"), "__setitem__"), N&lt;IntExpr&gt;(i),
            N&lt;StringExpr&gt;(
                name &amp;&amp; startswith(name-&gt;value, TYPE_TUPLE) ? "" : args[i].name))));
      }
      stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(I("__internal__"), "tuple_str"), N&lt;DotExpr&gt;(I("a"), "ptr"),
          N&lt;DotExpr&gt;(I("n"), "ptr"), N&lt;IntExpr&gt;(args.size()))));
    } else {
      stmts.emplace_back(N&lt;ReturnStmt&gt;(N&lt;StringExpr&gt;("()")));
    }
  } else if (op == "dict") {
    // def __dict__(self: T):
    //   d = List[str](N)
    //   d.append('arg1')  ...
    //   return d
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    stmts.emplace_back(
        N&lt;AssignStmt&gt;(I("d"), N&lt;CallExpr&gt;(N&lt;IndexExpr&gt;(I("List"), I("str")),
                                          N&lt;IntExpr&gt;(args.size()))));
    for (auto &amp;a : args)
      stmts.push_back(N&lt;ExprStmt&gt;(
          N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("d"), "append"), N&lt;StringExpr&gt;(a.name))));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(I("d")));
  } else if (op == "add") {
    // def __add__(self, tup):
    //   return __internal__.tuple_add(self, tup)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"tup", nullptr});
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "tuple_add"), I("self"), I("tup"))));
  } else if (op == "mul") {
    // def __mul__(self, i: Static[int]):
    //   return __internal__.tuple_add(self, tup)
    fargs.emplace_back(Param{"self", typExpr-&gt;clone()});
    fargs.emplace_back(Param{"i", N&lt;IndexExpr&gt;(I("Static"), I("int"))});
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(I("__internal__"), "tuple_mul"), I("self"), I("i"))));
  } else if (op == "tuplesize") {
    // def __tuplesize__() -&gt; int:
    //   return Tuple[arg_types...].__elemsize__
    ret = I("int");
    std::vector&lt;ExprPtr&gt; items;
    for (auto &amp;a : allArgs)
      items.push_back(clone(a.type));
    stmts.emplace_back(N&lt;ReturnStmt&gt;(
        N&lt;DotExpr&gt;(N&lt;IndexExpr&gt;(I("Tuple"), N&lt;TupleExpr&gt;(items)), "__elemsize__")));
  } else {
    seqassert(false, "invalid magic {}", op);
  }
#undef I
  auto t = std::make_shared&lt;FunctionStmt&gt;(format("__{}__", op), ret, fargs,
                                          N&lt;SuiteStmt&gt;(stmts), attr);
  t-&gt;setSrcInfo(ctx-&gt;cache-&gt;generateSrcInfo());
  return t;
}

</t>
<t tx="ekr.20230509083243.725">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;

namespace codon::ast {

@others
/// Transforms a list of @c GeneratorBody loops to the corresponding set of for loops.
/// @example
///   `for i in j if a for k in i if a if b` -&gt;
///   `for i in j: if a: for k in i: if a: if b: [prev]`
/// @param prev (out-argument): A pointer to the innermost block (suite) where the
///                             comprehension (or generator) expression should reside
StmtPtr SimplifyVisitor::transformGeneratorBody(const std::vector&lt;GeneratorBody&gt; &amp;loops,
                                                SuiteStmt *&amp;prev) {
  StmtPtr suite = N&lt;SuiteStmt&gt;(), newSuite = nullptr;
  prev = dynamic_cast&lt;SuiteStmt *&gt;(suite.get());
  for (auto &amp;l : loops) {
    newSuite = N&lt;SuiteStmt&gt;();
    auto nextPrev = dynamic_cast&lt;SuiteStmt *&gt;(newSuite.get());

    auto forStmt = N&lt;ForStmt&gt;(l.vars-&gt;clone(), l.gen-&gt;clone(), newSuite);
    prev-&gt;stmts.push_back(forStmt);
    prev = nextPrev;
    for (auto &amp;cond : l.conds) {
      newSuite = N&lt;SuiteStmt&gt;();
      nextPrev = dynamic_cast&lt;SuiteStmt *&gt;(newSuite.get());
      prev-&gt;stmts.push_back(N&lt;IfStmt&gt;(cond-&gt;clone(), newSuite));
      prev = nextPrev;
    }
  }
  return suite;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.726">/// Simple transformation.
/// The rest will be handled during the type-checking stage.
void SimplifyVisitor::visit(TupleExpr *expr) {
  for (auto &amp;i : expr-&gt;items)
    transform(i, true); // types needed for some constructs (e.g., isinstance)
}

</t>
<t tx="ekr.20230509083243.727">/// Simple transformation.
/// The rest will be handled during the type-checking stage.
void SimplifyVisitor::visit(ListExpr *expr) {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}

</t>
<t tx="ekr.20230509083243.728">/// Simple transformation.
/// The rest will be handled during the type-checking stage.
void SimplifyVisitor::visit(SetExpr *expr) {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}

</t>
<t tx="ekr.20230509083243.729">/// Simple transformation.
/// The rest will be handled during the type-checking stage.
void SimplifyVisitor::visit(DictExpr *expr) {
  for (auto &amp;i : expr-&gt;items)
    transform(i);
}

</t>
<t tx="ekr.20230509083243.73">  int getMemberIndex(const std::string &amp;n) const override {
    return getContents()-&gt;getMemberIndex(n);
  }

</t>
<t tx="ekr.20230509083243.730">/// Transform a collection comprehension to the corresponding statement expression.
/// @example (lists and sets):
///   `[i+a for i in j if a]` -&gt; ```gen = List()
///                                 for i in j: if a: gen.append(i+a)```
/// Generators are transformed to lambda calls.
/// @example
///   `(i+a for i in j if a)` -&gt; ```def _lambda(j, a):
///                                   for i in j: yield i+a
///                                 _lambda(j, a).__iter__()```
void SimplifyVisitor::visit(GeneratorExpr *expr) {
  std::vector&lt;StmtPtr&gt; stmts;

  auto loops = clone_nop(expr-&gt;loops); // Clone as loops will be modified

  @others
  } else if (expr-&gt;kind == GeneratorExpr::SetGenerator) {
    // Set comprehensions
    stmts.push_back(
        transform(N&lt;AssignStmt&gt;(clone(var), N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("Set")))));
    prev-&gt;stmts.push_back(
        N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), "add"), clone(expr-&gt;expr))));
    stmts.push_back(transform(suite));
    resultExpr = N&lt;StmtExpr&gt;(stmts, transform(var));
  } else {
    // Generators: converted to lambda functions that yield the target expression
    prev-&gt;stmts.push_back(N&lt;YieldStmt&gt;(clone(expr-&gt;expr)));
    stmts.push_back(suite);

    auto anon = makeAnonFn(stmts);
    if (auto call = anon-&gt;getCall()) {
      seqassert(!call-&gt;args.empty() &amp;&amp; call-&gt;args.back().value-&gt;getEllipsis(),
                "bad lambda: {}", *call);
      call-&gt;args.pop_back();
    } else {
      anon = N&lt;CallExpr&gt;(anon);
    }
    resultExpr = anon;
  }
  std::swap(avoidDomination, ctx-&gt;avoidDomination);
}

</t>
<t tx="ekr.20230509083243.731">// List comprehension optimization:
// Use `iter.__len__()` when creating list if there is a single for loop
// without any if conditions in the comprehension
bool canOptimize = expr-&gt;kind == GeneratorExpr::ListGenerator &amp;&amp; loops.size() == 1 &amp;&amp;
                   loops[0].conds.empty();
if (canOptimize) {
  auto iter = transform(loops[0].gen);
  IdExpr *id;
  if (iter-&gt;getCall() &amp;&amp; (id = iter-&gt;getCall()-&gt;expr-&gt;getId())) {
    // Turn off this optimization for static items
    canOptimize &amp;= !startswith(id-&gt;value, "std.internal.types.range.staticrange");
    canOptimize &amp;= !startswith(id-&gt;value, "statictuple");
  }
}

</t>
<t tx="ekr.20230509083243.732">SuiteStmt *prev = nullptr;
auto avoidDomination = true;
std::swap(avoidDomination, ctx-&gt;avoidDomination);
auto suite = transformGeneratorBody(loops, prev);
ExprPtr var = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("gen"));
if (expr-&gt;kind == GeneratorExpr::ListGenerator) {
  // List comprehensions
  std::vector&lt;ExprPtr&gt; args;
  prev-&gt;stmts.push_back(
      N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), "append"), clone(expr-&gt;expr))));
</t>
<t tx="ekr.20230509083243.733">  auto noOptStmt =
      N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(clone(var), N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("List"))), suite);
  if (canOptimize) {
    seqassert(suite-&gt;getSuite() &amp;&amp; !suite-&gt;getSuite()-&gt;stmts.empty() &amp;&amp;
                  CAST(suite-&gt;getSuite()-&gt;stmts[0], ForStmt),
              "bad comprehension transformation");
    auto optimizeVar = ctx-&gt;cache-&gt;getTemporaryVar("i");
    auto optSuite = clone(suite);
    CAST(optSuite-&gt;getSuite()-&gt;stmts[0], ForStmt)-&gt;iter = N&lt;IdExpr&gt;(optimizeVar);

    auto optStmt = N&lt;SuiteStmt&gt;(
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(optimizeVar), clone(expr-&gt;loops[0].gen)),
        N&lt;AssignStmt&gt;(
            clone(var),
            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("List"),
                        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(optimizeVar), "__len__")))),
        optSuite);
    resultExpr = transform(
        N&lt;IfExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("hasattr"), clone(expr-&gt;loops[0].gen),
                              N&lt;StringExpr&gt;("__len__")),
                  N&lt;StmtExpr&gt;(optStmt, clone(var)), N&lt;StmtExpr&gt;(noOptStmt, var)));
  } else {
    resultExpr = transform(N&lt;StmtExpr&gt;(noOptStmt, var));
  }
</t>
<t tx="ekr.20230509083243.734">/// Transform a dictionary comprehension to the corresponding statement expression.
/// @example
///   `{i+a: j+1 for i in j if a}` -&gt; ```gen = Dict()
///                                      for i in j: if a: gen.__setitem__(i+a, j+1)```
void SimplifyVisitor::visit(DictGeneratorExpr *expr) {
  SuiteStmt *prev = nullptr;
  auto avoidDomination = true;
  std::swap(avoidDomination, ctx-&gt;avoidDomination);
  auto suite = transformGeneratorBody(expr-&gt;loops, prev);

  std::vector&lt;StmtPtr&gt; stmts;
  ExprPtr var = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("gen"));
  stmts.push_back(transform(N&lt;AssignStmt&gt;(clone(var), N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("Dict")))));
  prev-&gt;stmts.push_back(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), "__setitem__"),
                                                clone(expr-&gt;key), clone(expr-&gt;expr))));
  stmts.push_back(transform(suite));
  resultExpr = N&lt;StmtExpr&gt;(stmts, transform(var));
  std::swap(avoidDomination, ctx-&gt;avoidDomination);
}

</t>
<t tx="ekr.20230509083243.735">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
  // See the above examples for transformation details
  if (pattern-&gt;getInt() || CAST(pattern, BoolExpr)) {
    // Bool and int patterns
    return N&lt;IfStmt&gt;(isinstance(var, CAST(pattern, BoolExpr) ? "bool" : "int"),
                     N&lt;IfStmt&gt;(N&lt;BinaryExpr&gt;(var-&gt;clone(), "==", pattern), suite));
  } else if (auto er = CAST(pattern, RangeExpr)) {
    // Range pattern
    return N&lt;IfStmt&gt;(
        isinstance(var, "int"),
        N&lt;IfStmt&gt;(
            N&lt;BinaryExpr&gt;(var-&gt;clone(), "&gt;=", clone(er-&gt;start)),
            N&lt;IfStmt&gt;(N&lt;BinaryExpr&gt;(var-&gt;clone(), "&lt;=", clone(er-&gt;stop)), suite)));
  } else if (auto et = pattern-&gt;getTuple()) {
    // Tuple pattern
    for (auto it = et-&gt;items.size(); it-- &gt; 0;) {
      suite = transformPattern(N&lt;IndexExpr&gt;(var-&gt;clone(), N&lt;IntExpr&gt;(it)),
                               clone(et-&gt;items[it]), suite);
    }
    return N&lt;IfStmt&gt;(
        isinstance(var, "Tuple"),
        N&lt;IfStmt&gt;(N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("staticlen"), clone(var)),
                                "==", N&lt;IntExpr&gt;(et-&gt;items.size())),
                  suite));
  } else if (auto el = pattern-&gt;getList()) {
    // List pattern
    auto ellipsis = findEllipsis(el-&gt;items), sz = el-&gt;items.size();
    std::string op;
    if (ellipsis == el-&gt;items.size()) {
      op = "==";
    } else {
      op = "&gt;=", sz -= 1;
    }
    for (auto it = el-&gt;items.size(); it-- &gt; ellipsis + 1;) {
      suite = transformPattern(
          N&lt;IndexExpr&gt;(var-&gt;clone(), N&lt;IntExpr&gt;(it - el-&gt;items.size())),
          clone(el-&gt;items[it]), suite);
    }
    for (auto it = ellipsis; it-- &gt; 0;) {
      suite = transformPattern(N&lt;IndexExpr&gt;(var-&gt;clone(), N&lt;IntExpr&gt;(it)),
                               clone(el-&gt;items[it]), suite);
    }
    return N&lt;IfStmt&gt;(isinstance(var, "List"),
                     N&lt;IfStmt&gt;(N&lt;BinaryExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("len"), clone(var)),
                                             op, N&lt;IntExpr&gt;(sz)),
                               suite));
  } else if (auto eb = pattern-&gt;getBinary()) {
    // Or pattern
    if (eb-&gt;op == "|") {
      return N&lt;SuiteStmt&gt;(transformPattern(clone(var), clone(eb-&gt;lexpr), clone(suite)),
                          transformPattern(clone(var), clone(eb-&gt;rexpr), suite));
    }
  } else if (auto ea = CAST(pattern, AssignExpr)) {
    // Bound pattern
    seqassert(ea-&gt;var-&gt;getId(), "only simple assignment expressions are supported");
    return N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(clone(ea-&gt;var), clone(var)),
                        transformPattern(clone(var), clone(ea-&gt;expr), clone(suite)));
  } else if (auto ei = pattern-&gt;getId()) {
    // Wildcard pattern
    if (ei-&gt;value != "_") {
      return N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(clone(pattern), clone(var)), suite);
    } else {
      return suite;
    }
  }
  pattern = transform(pattern); // transform to check for pattern errors
  // Fallback (`__match__`) pattern
  return N&lt;IfStmt&gt;(
      N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("hasattr"), var-&gt;clone(), N&lt;StringExpr&gt;("__match__"),
                  N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("type"), pattern-&gt;clone())),
      N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(var-&gt;clone(), "__match__"), pattern), suite));
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.736">void SimplifyVisitor::visit(IfExpr *expr) {
  // C++ call order is not defined; make sure to transform the conditional first
  transform(expr-&gt;cond);
  auto tmp = ctx-&gt;isConditionalExpr;
  // Ensure that ifexpr and elsexpr are set as a potential short-circuit expressions.
  // Needed to ensure that variables defined within these expressions are properly
  // checked for their existence afterwards
  // (e.g., `x` will be created within `a if cond else (x := b)`
  // only if `cond` is not true)
  ctx-&gt;isConditionalExpr = true;
  transform(expr-&gt;ifexpr);
  transform(expr-&gt;elsexpr);
  ctx-&gt;isConditionalExpr = tmp;
}

</t>
<t tx="ekr.20230509083243.737">void SimplifyVisitor::visit(IfStmt *stmt) {
  seqassert(stmt-&gt;cond, "invalid if statement");
  transform(stmt-&gt;cond);
  // Ensure that conditional suites are marked and transformed in their own scope
  transformConditionalScope(stmt-&gt;ifSuite);
  transformConditionalScope(stmt-&gt;elseSuite);
}

</t>
<t tx="ekr.20230509083243.738">/// Simplify match statement by transforming it into a series of conditional statements.
/// @example
///   ```match e:
///        case pattern1: ...
///        case pattern2 if guard: ...
///        ...``` -&gt;
///   ```_match = e
///      while True:  # used to simulate goto statement with break
///        [pattern1 transformation]: (...; break)
///        [pattern2 transformation]: if guard: (...; break)
///        ...
///        break  # exit the loop no matter what```
/// The first pattern that matches the given expression will be used; other patterns
/// will not be used (i.e., there is no fall-through). See @c transformPattern for
/// pattern transformations
void SimplifyVisitor::visit(MatchStmt *stmt) {
  auto var = ctx-&gt;cache-&gt;getTemporaryVar("match");
  auto result = N&lt;SuiteStmt&gt;();
  result-&gt;stmts.push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var), clone(stmt-&gt;what)));
  for (auto &amp;c : stmt-&gt;cases) {
    ctx-&gt;enterConditionalBlock();
    StmtPtr suite = N&lt;SuiteStmt&gt;(clone(c.suite), N&lt;BreakStmt&gt;());
    if (c.guard)
      suite = N&lt;IfStmt&gt;(clone(c.guard), suite);
    result-&gt;stmts.push_back(transformPattern(N&lt;IdExpr&gt;(var), clone(c.pattern), suite));
    ctx-&gt;leaveConditionalBlock();
  }
  // Make sure to break even if there is no case _ to prevent infinite loop
  result-&gt;stmts.push_back(N&lt;BreakStmt&gt;());
  resultStmt = transform(N&lt;WhileStmt&gt;(N&lt;BoolExpr&gt;(true), result));
}

</t>
<t tx="ekr.20230509083243.739">/// Transform a match pattern into a series of if statements.
/// @example
///   `case True`          -&gt; `if isinstance(var, "bool"): if var == True`
///   `case 1`             -&gt; `if isinstance(var, "int"): if var == 1`
///   `case 1...3`         -&gt; ```if isinstance(var, "int"):
///                                if var &gt;= 1: if var &lt;= 3```
///   `case (1, pat)`      -&gt; ```if isinstance(var, "Tuple"): if staticlen(var) == 2:
///                                 if match(var[0], 1): if match(var[1], pat)```
///   `case [1, ..., pat]` -&gt; ```if isinstance(var, "List"): if len(var) &gt;= 2:
///                                 if match(var[0], 1): if match(var[-1], pat)```
///   `case 1 or pat`      -&gt; `if match(var, 1): if match(var, pat)`
///                           (note: pattern suite is cloned for each `or`)
///   `case (x := pat)`    -&gt; `(x = var; if match(var, pat))`
///   `case x`             -&gt; `(x := var)`
///                           (only when `x` is not '_')
///   `case expr`          -&gt; `if hasattr(typeof(var), "__match__"): if
///   var.__match__(foo())`
///                           (any expression that does not fit above patterns)
StmtPtr SimplifyVisitor::transformPattern(const ExprPtr &amp;var, ExprPtr pattern,
                                          StmtPtr suite) {
</t>
<t tx="ekr.20230509083243.74">  const_iterator begin() const override { return getContents()-&gt;begin(); }
  const_iterator end() const override { return getContents()-&gt;end(); }
  const_reference front() const override { return getContents()-&gt;front(); }
  const_reference back() const override { return getContents()-&gt;back(); }

  /// @return the reference type's contents
  RecordType *getContents() const { return cast&lt;RecordType&gt;(contents); }
  /// Sets the reference type's contents. Should not generally be used.
  /// @param t the new contents
  void setContents(RecordType *t) { contents = t; }

</t>
<t tx="ekr.20230509083243.740">  // Convenience function to generate `isinstance(e, typ)` calls
  auto isinstance = [&amp;](const ExprPtr &amp;e, const std::string &amp;typ) -&gt; ExprPtr {
    return N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("isinstance"), e-&gt;clone(), N&lt;IdExpr&gt;(typ));
  };
</t>
<t tx="ekr.20230509083243.741">  // Convenience function to find the index of an ellipsis within a list pattern
  auto findEllipsis = [&amp;](const std::vector&lt;ExprPtr&gt; &amp;items) {
    size_t i = items.size();
    for (auto it = 0; it &lt; items.size(); it++)
      if (items[it]-&gt;getEllipsis()) {
        if (i != items.size())
          E(Error::MATCH_MULTI_ELLIPSIS, items[it], "multiple ellipses in pattern");
        i = it;
      }
    return i;
  };

</t>
<t tx="ekr.20230509083243.742">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "ctx.h"

#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;

#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

SimplifyContext::SimplifyContext(std::string filename, Cache *cache)
    : Context&lt;SimplifyItem&gt;(move(filename)), cache(cache),
      isStdlibLoading(false), moduleName{ImportFile::PACKAGE, "", ""},
      isConditionalExpr(false), allowTypeOf(true) {
  bases.emplace_back(Base(""));
  scope.blocks.push_back(scope.counter = 0);
}

SimplifyContext::Base::Base(std::string name, Attr *attributes)
    : name(move(name)), attributes(attributes), deducedMembers(nullptr), selfName(),
      captures(nullptr), pyCaptures(nullptr) {}

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.743">void SimplifyContext::add(const std::string &amp;name, const SimplifyContext::Item &amp;var) {
  auto v = find(name);
  if (v &amp;&amp; v-&gt;noShadow)
    E(Error::ID_INVALID_BIND, getSrcInfo(), name);
  Context&lt;SimplifyItem&gt;::add(name, var);
}

</t>
<t tx="ekr.20230509083243.744">SimplifyContext::Item SimplifyContext::addVar(const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.745">                                              const std::string &amp;canonicalName,
  @others
</t>
<t tx="ekr.20230509083243.746">                                            const SrcInfo &amp;srcInfo) {
seqassert(!canonicalName.empty(), "empty canonical name for '{}'", name);
auto t = std::make_shared&lt;SimplifyItem&gt;(SimplifyItem::Var, getBaseName(),
                                        canonicalName, getModule(), scope.blocks);
t-&gt;setSrcInfo(srcInfo);
Context&lt;SimplifyItem&gt;::add(name, t);
Context&lt;SimplifyItem&gt;::add(canonicalName, t);
return t;
</t>
<t tx="ekr.20230509083243.747">}

SimplifyContext::Item SimplifyContext::addType(const std::string &amp;name,
  @others
</t>
<t tx="ekr.20230509083243.748">                                             const std::string &amp;canonicalName,
@others
</t>
<t tx="ekr.20230509083243.749">                                             const SrcInfo &amp;srcInfo) {
seqassert(!canonicalName.empty(), "empty canonical name for '{}'", name);
auto t = std::make_shared&lt;SimplifyItem&gt;(SimplifyItem::Type, getBaseName(),
                                        canonicalName, getModule(), scope.blocks);
t-&gt;setSrcInfo(srcInfo);
Context&lt;SimplifyItem&gt;::add(name, t);
Context&lt;SimplifyItem&gt;::add(canonicalName, t);
return t;
</t>
<t tx="ekr.20230509083243.75">  void realize(std::vector&lt;Type *&gt; mTypes, std::vector&lt;std::string&gt; mNames) override {
    getContents()-&gt;realize(std::move(mTypes), std::move(mNames));
  }

</t>
<t tx="ekr.20230509083243.750">}

SimplifyContext::Item SimplifyContext::addFunc(const std::string &amp;name,
  @others
</t>
<t tx="ekr.20230509083243.751">                                             const std::string &amp;canonicalName,
@others
</t>
<t tx="ekr.20230509083243.752">                                             const SrcInfo &amp;srcInfo) {
seqassert(!canonicalName.empty(), "empty canonical name for '{}'", name);
</t>
<t tx="ekr.20230509083243.753">  auto t = std::make_shared&lt;SimplifyItem&gt;(SimplifyItem::Func, getBaseName(),
                                          canonicalName, getModule(), scope.blocks);
  t-&gt;setSrcInfo(srcInfo);
  Context&lt;SimplifyItem&gt;::add(name, t);
  Context&lt;SimplifyItem&gt;::add(canonicalName, t);
  return t;
}

SimplifyContext::Item
SimplifyContext::addAlwaysVisible(const SimplifyContext::Item &amp;item) {
  @others
  return i;
}

</t>
<t tx="ekr.20230509083243.754">auto i = std::make_shared&lt;SimplifyItem&gt;(item-&gt;kind, item-&gt;baseName,
                                        item-&gt;canonicalName, item-&gt;moduleName,
                                        std::vector&lt;int&gt;{0}, item-&gt;importPath);
auto stdlib = cache-&gt;imports[STDLIB_IMPORT].ctx;
if (!stdlib-&gt;find(i-&gt;canonicalName)) {
  stdlib-&gt;add(i-&gt;canonicalName, i);
}
</t>
<t tx="ekr.20230509083243.755">SimplifyContext::Item SimplifyContext::find(const std::string &amp;name) const {
  auto t = Context&lt;SimplifyItem&gt;::find(name);
  if (t)
    return t;

  // Item is not found in the current module. Time to look in the standard library!
  // Note: the standard library items cannot be dominated.
  auto stdlib = cache-&gt;imports[STDLIB_IMPORT].ctx;
  if (stdlib.get() != this)
    t = stdlib-&gt;find(name);
  return t;
}

SimplifyContext::Item SimplifyContext::forceFind(const std::string &amp;name) const {
  auto f = find(name);
  seqassert(f, "cannot find '{}'", name);
  return f;
}

SimplifyContext::Item SimplifyContext::findDominatingBinding(const std::string &amp;name) {
  auto it = map.find(name);
  if (it == map.end())
    return find(name);
  seqassert(!it-&gt;second.empty(), "corrupted SimplifyContext ({})", name);

  // The item is found. Let's see is it accessible now.

  std::string canonicalName;
  auto lastGood = it-&gt;second.begin();
  bool isOutside = (*lastGood)-&gt;getBaseName() != getBaseName();
  int prefix = int(scope.blocks.size());
  // Iterate through all bindings with the given name and find the closest binding that
  // dominates the current scope.
  for (auto i = it-&gt;second.begin(); i != it-&gt;second.end(); i++) {
    // Find the longest block prefix between the binding and the current scope.
    int p = std::min(prefix, int((*i)-&gt;scope.size()));
    while (p &gt;= 0 &amp;&amp; (*i)-&gt;scope[p - 1] != scope.blocks[p - 1])
      p--;
    // We reached the toplevel. Break.
    if (p &lt; 0)
      break;
    // We went outside the function scope. Break.
    if (!isOutside &amp;&amp; (*i)-&gt;getBaseName() != getBaseName())
      break;
    prefix = p;
    lastGood = i;
    // The binding completely dominates the current scope. Break.
    if ((*i)-&gt;scope.size() &lt;= scope.blocks.size() &amp;&amp;
        (*i)-&gt;scope.back() == scope.blocks[(*i)-&gt;scope.size() - 1])
      break;
  }
  seqassert(lastGood != it-&gt;second.end(), "corrupted scoping ({})", name);
  if (lastGood != it-&gt;second.begin() &amp;&amp; !(*lastGood)-&gt;isVar())
    E(Error::CLASS_INVALID_BIND, getSrcInfo(), name);

  bool hasUsed = false;
  if ((*lastGood)-&gt;scope.size() == prefix) {
    // The current scope is dominated by a binding. Use that binding.
    canonicalName = (*lastGood)-&gt;canonicalName;
  } else {
    // The current scope is potentially reachable by multiple bindings that are
    // not dominated by a common binding. Create such binding in the scope that
    // dominates (covers) all of them.
    canonicalName = generateCanonicalName(name);
    auto item = std::make_shared&lt;SimplifyItem&gt;(
        (*lastGood)-&gt;kind, (*lastGood)-&gt;baseName, canonicalName,
        (*lastGood)-&gt;moduleName,
        std::vector&lt;int&gt;(scope.blocks.begin(), scope.blocks.begin() + prefix),
        (*lastGood)-&gt;importPath);
    item-&gt;accessChecked = {(*lastGood)-&gt;scope};
    lastGood = it-&gt;second.insert(++lastGood, item);
    // Make sure to prepend a binding declaration: `var` and `var__used__ = False`
    // to the dominating scope.
    scope.stmts[scope.blocks[prefix - 1]].push_back(std::make_unique&lt;AssignStmt&gt;(
        std::make_unique&lt;IdExpr&gt;(canonicalName), nullptr, nullptr));
    scope.stmts[scope.blocks[prefix - 1]].push_back(std::make_unique&lt;AssignStmt&gt;(
        std::make_unique&lt;IdExpr&gt;(fmt::format("{}.__used__", canonicalName)),
        std::make_unique&lt;BoolExpr&gt;(false), nullptr));
    // Reached the toplevel? Register the binding as global.
    if (prefix == 1) {
      cache-&gt;addGlobal(canonicalName);
      cache-&gt;addGlobal(fmt::format("{}.__used__", canonicalName));
    }
    hasUsed = true;
  }
  // Remove all bindings after the dominant binding.
  for (auto i = it-&gt;second.begin(); i != it-&gt;second.end(); i++) {
    if (i == lastGood)
      break;
    if (!(*i)-&gt;canDominate())
      continue;
    // These bindings (and their canonical identifiers) will be replaced by the
    // dominating binding during the type checking pass.
    cache-&gt;replacements[(*i)-&gt;canonicalName] = {canonicalName, hasUsed};
    cache-&gt;replacements[format("{}.__used__", (*i)-&gt;canonicalName)] = {
        format("{}.__used__", canonicalName), false};
    seqassert((*i)-&gt;canonicalName != canonicalName, "invalid replacement at {}: {}",
              getSrcInfo(), canonicalName);
    auto it = std::find(stack.front().begin(), stack.front().end(), name);
    if (it != stack.front().end())
      stack.front().erase(it);
  }
  it-&gt;second.erase(it-&gt;second.begin(), lastGood);
  return it-&gt;second.front();
}

std::string SimplifyContext::getBaseName() const { return bases.back().name; }

std::string SimplifyContext::getModule() const {
  std::string base = moduleName.status == ImportFile::STDLIB ? "std." : "";
  base += moduleName.module;
  if (auto sz = startswith(base, "__main__"))
    base = base.substr(sz);
  return base;
}

void SimplifyContext::dump() { dump(0); }

std::string SimplifyContext::generateCanonicalName(const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.756">                                                   bool includeBase,
  @others
</t>
<t tx="ekr.20230509083243.757">                                                 bool zeroId) const {
std::string newName = name;
bool alreadyGenerated = name.find('.') != std::string::npos;
if (includeBase &amp;&amp; !alreadyGenerated) {
  std::string base = getBaseName();
  if (base.empty())
    base = getModule();
  if (base == "std.internal.core")
    base = "";
  newName = (base.empty() ? "" : (base + ".")) + newName;
}
auto num = cache-&gt;identifierCount[newName]++;
if (num)
  newName = format("{}.{}", newName, num);
if (name != newName &amp;&amp; !zeroId)
  cache-&gt;identifierCount[newName]++;
cache-&gt;reverseIdentifierLookup[newName] = name;
return newName;
}

</t>
<t tx="ekr.20230509083243.758">void SimplifyContext::enterConditionalBlock() {
  scope.blocks.push_back(++scope.counter);
}

</t>
<t tx="ekr.20230509083243.759">void SimplifyContext::leaveConditionalBlock(std::vector&lt;StmtPtr&gt; *stmts) {
  if (stmts &amp;&amp; in(scope.stmts, scope.blocks.back()))
    stmts-&gt;insert(stmts-&gt;begin(), scope.stmts[scope.blocks.back()].begin(),
                  scope.stmts[scope.blocks.back()].end());
  scope.blocks.pop_back();
}

</t>
<t tx="ekr.20230509083243.76">/// Type associated with a CIR function.
class FuncType : public AcceptorExtend&lt;FuncType, Type&gt; {
public:
  using const_iterator = std::vector&lt;Type *&gt;::const_iterator;
  using const_reference = std::vector&lt;Type *&gt;::const_reference;

private:
  /// return type
  Type *rType;
  /// argument types
  std::vector&lt;Type *&gt; argTypes;
  /// whether the function is variadic (e.g. "printf" in C)
  bool variadic;

public:
  static const char NodeId;

  /// Constructs a function type.
  /// @param rType the function's return type
  /// @param argTypes the function's arg types
  FuncType(std::string name, Type *rType, std::vector&lt;Type *&gt; argTypes,
           bool variadic = false)
      : AcceptorExtend(std::move(name)), rType(rType), argTypes(std::move(argTypes)),
        variadic(variadic) {}

  /// @return the function's return type
  Type *getReturnType() const { return rType; }
  /// @return true if the function is variadic
  bool isVariadic() const { return variadic; }

  /// @return iterator to the first argument
  const_iterator begin() const { return argTypes.begin(); }
  /// @return iterator beyond the last argument
  const_iterator end() const { return argTypes.end(); }
  /// @return a reference to the first argument
  const_reference front() const { return argTypes.front(); }
  /// @return a reference to the last argument
  const_reference back() const { return argTypes.back(); }

private:
  std::vector&lt;Generic&gt; doGetGenerics() const override;

  std::vector&lt;Type *&gt; doGetUsedTypes() const override;

  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509083243.760">bool SimplifyContext::isGlobal() const { return bases.size() == 1; }

bool SimplifyContext::isConditional() const { return scope.blocks.size() &gt; 1; }

SimplifyContext::Base *SimplifyContext::getBase() {
  return bases.empty() ? nullptr : &amp;(bases.back());
}

</t>
<t tx="ekr.20230509083243.761">bool SimplifyContext::inFunction() const {
  return !isGlobal() &amp;&amp; !bases.back().isType();
}

</t>
<t tx="ekr.20230509083243.762">bool SimplifyContext::inClass() const { return !isGlobal() &amp;&amp; bases.back().isType(); }

</t>
<t tx="ekr.20230509083243.763">bool SimplifyContext::isOuter(const Item &amp;val) const {
  return getBaseName() != val-&gt;getBaseName() || getModule() != val-&gt;getModule();
}

</t>
<t tx="ekr.20230509083243.764">SimplifyContext::Base *SimplifyContext::getClassBase() {
  if (bases.size() &gt;= 2 &amp;&amp; bases[bases.size() - 2].isType())
    return &amp;(bases[bases.size() - 2]);
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.765">void SimplifyContext::dump(int pad) {
  @others
}

</t>
<t tx="ekr.20230509083243.766">auto ordered =
    std::map&lt;std::string, decltype(map)::mapped_type&gt;(map.begin(), map.end());
LOG("location: {}", getSrcInfo());
LOG("module:   {}", getModule());
LOG("base:     {}", getBaseName());
LOG("scope:    {}", fmt::join(scope.blocks, ","));
for (auto &amp;s : stack.front())
  LOG("-&gt; {}", s);
for (auto &amp;i : ordered) {
  std::string s;
  bool f = true;
  for (auto &amp;t : i.second) {
    LOG("{}{} {} {:40} {:30} {}", std::string(pad * 2, ' '),
        !f ? std::string(40, ' ') : format("{:.&lt;40}", i.first),
        (t-&gt;isFunc() ? "F" : (t-&gt;isType() ? "T" : (t-&gt;isImport() ? "I" : "V"))),
        t-&gt;canonicalName, t-&gt;getBaseName(), combine2(t-&gt;scope, ","));
    f = false;
  }
}
</t>
<t tx="ekr.20230509083243.767">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;deque&gt;
#include &lt;memory&gt;
#include &lt;set&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * Simplification context identifier.
 * Can be either a function, a class (type), or a variable.
 */
struct SimplifyItem : public SrcObject {
  /// Type of the identifier
  enum Kind { Func, Type, Var } kind;
  /// Base name (e.g., foo.bar.baz)
  std::string baseName;
  /// Unique identifier (canonical name)
  std::string canonicalName;
  /// Full module name
  std::string moduleName;
  /// Full scope information
  std::vector&lt;int&gt; scope;
  /// Non-empty string if a variable is import variable
  std::string importPath;
  /// List of scopes where the identifier is accessible
  /// without __used__ check
  std::vector&lt;std::vector&lt;int&gt;&gt; accessChecked;
  /// Set if an identifier cannot be shadowed
  /// (e.g., global-marked variables)
  bool noShadow = false;
  /// Set if an identifier is a class or a function generic
  bool generic = false;
  /// Set if an identifier is a static variable.
  char staticType = 0;
  /// Set if an identifier should not be dominated
  /// (e.g., a loop variable in a comprehension).
  bool avoidDomination = false;

public:
  SimplifyItem(Kind kind, std::string baseName, std::string canonicalName,
               std::string moduleName, std::vector&lt;int&gt; scope,
               std::string importPath = "")
      : kind(kind), baseName(std::move(baseName)),
        canonicalName(std::move(canonicalName)), moduleName(std::move(moduleName)),
        scope(std::move(scope)), importPath(std::move(importPath)) {}

  /* Convenience getters */
  std::string getBaseName() const { return baseName; }
  std::string getModule() const { return moduleName; }
  bool isVar() const { return kind == Var; }
  bool isFunc() const { return kind == Func; }
  bool isType() const { return kind == Type; }
  bool isImport() const { return !importPath.empty(); }
  bool isGlobal() const { return scope.size() == 1 &amp;&amp; baseName.empty(); }
  /// True if an identifier is within a conditional block
  /// (i.e., a block that might not be executed during the runtime)
  bool isConditional() const { return scope.size() &gt; 1; }
  bool isGeneric() const { return generic; }
  char isStatic() const { return staticType; }
  /// True if an identifier is a loop variable in a comprehension
  bool canDominate() const { return !avoidDomination; }
};

/** Context class that tracks identifiers during the simplification. **/
struct SimplifyContext : public Context&lt;SimplifyItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;

  /// Holds the information about current scope.
  /// A scope is defined as a stack of conditional blocks
  /// (i.e., blocks that might not get executed during the runtime).
  /// Used mainly to support Python's variable scoping rules.
  struct {
    /// Scope counter. Each conditional block gets a new scope ID.
    int counter;
    /// Current hierarchy of conditional blocks.
    std::vector&lt;int&gt; blocks;
    /// List of statements that are to be prepended to a block
    /// after its transformation.
    std::map&lt;int, std::vector&lt;StmtPtr&gt;&gt; stmts;
  } scope;

  /// Holds the information about current base.
  /// A base is defined as a function or a class block.
  struct Base {
    /// Canonical name of a function or a class that owns this base.
    std::string name;
    /// Tracks function attributes (e.g. if it has @atomic or @test attributes).
    /// Only set for functions.
    Attr *attributes;
    /// Set if the base is class base and if class is marked with @deduce.
    /// Stores the list of class fields in the order of traversal.
    std::shared_ptr&lt;std::vector&lt;std::string&gt;&gt; deducedMembers;
    /// Canonical name of `self` parameter that is used to deduce class fields
    /// (e.g., self in self.foo).
    std::string selfName;
    /// Map of captured identifiers (i.e., identifiers not defined in a function).
    /// Captured (canonical) identifiers are mapped to the new canonical names
    /// (representing the canonical function argument names that are appended to the
    /// function after processing) and their types (indicating if they are a type, a
    /// static or a variable).
    std::unordered_map&lt;std::string, std::pair&lt;std::string, ExprPtr&gt;&gt; *captures;

    /// Map of identifiers that are to be fetched from Python.
    std::unordered_set&lt;std::string&gt; *pyCaptures;

    /// Scope that defines the base.
    std::vector&lt;int&gt; scope;

    /// A stack of nested loops enclosing the current statement used for transforming
    /// "break" statement in loop-else constructs. Each loop is defined by a "break"
    /// variable created while parsing a loop-else construct. If a loop has no else
    /// block, the corresponding loop variable is empty.
    struct Loop {
      std::string breakVar;
      std::vector&lt;int&gt; scope;
      /// List of variables "seen" before their assignment within a loop.
      /// Used to dominate variables that are updated within a loop.
      std::unordered_set&lt;std::string&gt; seenVars;
    };
    std::vector&lt;Loop&gt; loops;

  public:
    explicit Base(std::string name, Attr *attributes = nullptr);
    Loop *getLoop() { return loops.empty() ? nullptr : &amp;(loops.back()); }
    bool isType() const { return attributes == nullptr; }
  };
  /// Current base stack (the last enclosing base is the last base in the stack).
  std::vector&lt;Base&gt; bases;

  struct BaseGuard {
    SimplifyContext *holder;
    BaseGuard(SimplifyContext *holder, const std::string &amp;name) : holder(holder) {
      holder-&gt;bases.emplace_back(Base(name));
      holder-&gt;bases.back().scope = holder-&gt;scope.blocks;
      holder-&gt;addBlock();
    }
    ~BaseGuard() {
      holder-&gt;bases.pop_back();
      holder-&gt;popBlock();
    }
  };

  /// Set of seen global identifiers used to prevent later creation of local variables
  /// with the same name.
  std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, ExprPtr&gt;&gt;
      seenGlobalIdentifiers;

  /// Set if the standard library is currently being loaded.
  bool isStdlibLoading;
  /// Current module. The default module is named `__main__`.
  ImportFile moduleName;
  /// Tracks if we are in a dependent part of a short-circuiting expression (e.g. b in a
  /// and b) to disallow assignment expressions there.
  bool isConditionalExpr;
  /// Allow type() expressions. Currently used to disallow type() in class
  /// and function definitions.
  bool allowTypeOf;
  /// Set if all assignments should not be dominated later on.
  bool avoidDomination = false;

public:
  SimplifyContext(std::string filename, Cache *cache);

  void add(const std::string &amp;name, const Item &amp;var) override;
  /// Convenience method for adding an object to the context.
  Item addVar(const std::string &amp;name, const std::string &amp;canonicalName,
              const SrcInfo &amp;srcInfo = SrcInfo());
  Item addType(const std::string &amp;name, const std::string &amp;canonicalName,
               const SrcInfo &amp;srcInfo = SrcInfo());
  Item addFunc(const std::string &amp;name, const std::string &amp;canonicalName,
               const SrcInfo &amp;srcInfo = SrcInfo());
  /// Add the item to the standard library module, thus ensuring its visibility from all
  /// modules.
  Item addAlwaysVisible(const Item &amp;item);

  /// Get an item from the context. If the item does not exist, nullptr is returned.
  Item find(const std::string &amp;name) const override;
  /// Get an item that exists in the context. If the item does not exist, assertion is
  /// raised.
  Item forceFind(const std::string &amp;name) const;
  /// Get an item from the context. Perform domination analysis for accessing items
  /// defined in the conditional blocks (i.e., Python scoping).
  Item findDominatingBinding(const std::string &amp;name);

  /// Return a canonical name of the current base.
  /// An empty string represents the toplevel base.
  std::string getBaseName() const;
  /// Return the current module.
  std::string getModule() const;
  /// Pretty-print the current context state.
  void dump() override;

  /// Generate a unique identifier (name) for a given string.
  std::string generateCanonicalName(const std::string &amp;name, bool includeBase = false,
                                    bool zeroId = false) const;
  /// Enter a conditional block.
  void enterConditionalBlock();
  /// Leave a conditional block. Populate stmts (if set) with the declarations of newly
  /// added identifiers that dominate the children blocks.
  void leaveConditionalBlock(std::vector&lt;StmtPtr&gt; *stmts = nullptr);
  /// True if we are at the toplevel.
  bool isGlobal() const;
  /// True if we are within a conditional block.
  bool isConditional() const;
  /// Get the current base.
  Base *getBase();
  /// True if the current base is function.
  bool inFunction() const;
  /// True if the current base is class.
  bool inClass() const;
  /// True if an item is defined outside of the current base or a module.
  bool isOuter(const Item &amp;val) const;
  /// Get the enclosing class base (or nullptr if such does not exist).
  Base *getClassBase();

private:
  /// Pretty-print the current context state.
  void dump(int pad);
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.768">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;

namespace codon::ast {

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.769">/// Transform asserts.
/// @example
///   `assert foo()` -&gt;
///   `if not foo(): raise __internal__.seq_assert([file], [line], "")`
///   `assert foo(), msg` -&gt;
///   `if not foo(): raise __internal__.seq_assert([file], [line], str(msg))`
/// Use `seq_assert_test` instead of `seq_assert` and do not raise anything during unit
/// testing (i.e., when the enclosing function is marked with `@test`).
void SimplifyVisitor::visit(AssertStmt *stmt) {
  ExprPtr msg = N&lt;StringExpr&gt;("");
  if (stmt-&gt;message)
    msg = N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("str"), clone(stmt-&gt;message));
  @others
}

</t>
<t tx="ekr.20230509083243.77">/// Base for simple derived types.
class DerivedType : public AcceptorExtend&lt;DerivedType, Type&gt; {
private:
  /// the base type
  Type *base;

public:
  static const char NodeId;

  /// Constructs a derived type.
  /// @param name the type's name
  /// @param base the type's base
  explicit DerivedType(std::string name, Type *base)
      : AcceptorExtend(std::move(name)), base(base) {}

  /// @return the type's base
  Type *getBase() const { return base; }

private:
  bool doIsAtomic() const override { return base-&gt;isAtomic(); }

  std::vector&lt;Type *&gt; doGetUsedTypes() const override { return {base}; }
};

</t>
<t tx="ekr.20230509083243.770">auto test = ctx-&gt;inFunction() &amp;&amp; (ctx-&gt;getBase()-&gt;attributes &amp;&amp;
                                  ctx-&gt;getBase()-&gt;attributes-&gt;has(Attr::Test));
  @others
</t>
<t tx="ekr.20230509083243.771">  auto ex = N&lt;CallExpr&gt;(
  N&lt;DotExpr&gt;("__internal__", test ? "seq_assert_test" : "seq_assert"),
  N&lt;StringExpr&gt;(stmt-&gt;getSrcInfo().file), N&lt;IntExpr&gt;(stmt-&gt;getSrcInfo().line), msg);
  auto cond = N&lt;UnaryExpr&gt;("!", clone(stmt-&gt;expr));
  if (test) {
resultStmt = transform(N&lt;IfStmt&gt;(cond, N&lt;ExprStmt&gt;(ex)));
  } else {
resultStmt = transform(N&lt;IfStmt&gt;(cond, N&lt;ThrowStmt&gt;(ex)));
  }
</t>
<t tx="ekr.20230509083243.772">void SimplifyVisitor::visit(TryStmt *stmt) {
  transformConditionalScope(stmt-&gt;suite);
  for (auto &amp;c : stmt-&gt;catches) {
    ctx-&gt;enterConditionalBlock();
    if (!c.var.empty()) {
      c.var = ctx-&gt;generateCanonicalName(c.var);
      ctx-&gt;addVar(ctx-&gt;cache-&gt;rev(c.var), c.var, c.suite-&gt;getSrcInfo());
    }
    transform(c.exc, true);
    transformConditionalScope(c.suite);
    ctx-&gt;leaveConditionalBlock();
  }
  transformConditionalScope(stmt-&gt;finally);
}

</t>
<t tx="ekr.20230509083243.773">void SimplifyVisitor::visit(ThrowStmt *stmt) { transform(stmt-&gt;expr); }

</t>
<t tx="ekr.20230509083243.774">/// Transform with statements.
/// @example
///   `with foo(), bar() as a: ...` -&gt;
///   ```tmp = foo()
///      tmp.__enter__()
///      try:
///        a = bar()
///        a.__enter__()
///        try:
///          ...
///        finally:
///          a.__exit__()
///      finally:
///        tmp.__exit__()```
void SimplifyVisitor::visit(WithStmt *stmt) {
  seqassert(!stmt-&gt;items.empty(), "stmt-&gt;items is empty");
  std::vector&lt;StmtPtr&gt; content;
  for (auto i = stmt-&gt;items.size(); i-- &gt; 0;) {
    std::string var =
        stmt-&gt;vars[i].empty() ? ctx-&gt;cache-&gt;getTemporaryVar("with") : stmt-&gt;vars[i];
    content = std::vector&lt;StmtPtr&gt;{
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var), clone(stmt-&gt;items[i])),
        N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(var, "__enter__"))),
        N&lt;TryStmt&gt;(
            !content.empty() ? N&lt;SuiteStmt&gt;(content) : clone(stmt-&gt;suite),
            std::vector&lt;TryStmt::Catch&gt;{},
            N&lt;SuiteStmt&gt;(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(var, "__exit__")))))};
  }
  resultStmt = transform(N&lt;SuiteStmt&gt;(content));
}

</t>
<t tx="ekr.20230509083243.775">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
/// Transform LLVM functions.
/// @example
///   ```@llvm
///      def foo(x: int) -&gt; float:
///        [code]
///   ``` -&gt; ```
///      def foo(x: int) -&gt; float:
///        StringExpr("[code]")
///        SuiteStmt(referenced_types)
///   ```
/// As LLVM code can reference types and static expressions in `{=expr}` blocks,
/// all block expression will be stored in the `referenced_types` suite.
/// "[code]" is transformed accordingly: each `{=expr}` block will
/// be replaced with `{}` so that @c fmt::format can fill the gaps.
/// Note that any brace (`{` or `}`) that is not part of a block is
/// escaped (e.g. `{` -&gt; `{{` and `}` -&gt; `}}`) so that @c fmt::format can process them.
StmtPtr SimplifyVisitor::transformLLVMDefinition(Stmt *codeStmt) {
  seqassert(codeStmt &amp;&amp; codeStmt-&gt;getExpr() &amp;&amp; codeStmt-&gt;getExpr()-&gt;expr-&gt;getString(),
            "invalid LLVM definition");

  auto code = codeStmt-&gt;getExpr()-&gt;expr-&gt;getString()-&gt;getValue();
  std::vector&lt;StmtPtr&gt; items;
  auto se = N&lt;StringExpr&gt;("");
  std::string finalCode = se-&gt;getValue();
  items.push_back(N&lt;ExprStmt&gt;(se));

  // Parse LLVM code and look for expression blocks that start with `{=`
  int braceCount = 0, braceStart = 0;
  for (int i = 0; i &lt; code.size(); i++) {
    if (i &lt; code.size() - 1 &amp;&amp; code[i] == '{' &amp;&amp; code[i + 1] == '=') {
      if (braceStart &lt; i)
        finalCode += escapeFStringBraces(code, braceStart, i - braceStart) + '{';
      if (!braceCount) {
        braceStart = i + 2;
        braceCount++;
      } else {
        E(Error::FN_BAD_LLVM, getSrcInfo());
      }
    } else if (braceCount &amp;&amp; code[i] == '}') {
      braceCount--;
      std::string exprCode = code.substr(braceStart, i - braceStart);
      auto offset = getSrcInfo();
      offset.col += i;
      auto expr = transform(parseExpr(ctx-&gt;cache, exprCode, offset).first, true);
      items.push_back(N&lt;ExprStmt&gt;(expr));
      braceStart = i + 1;
      finalCode += '}';
    }
  }
  if (braceCount)
    E(Error::FN_BAD_LLVM, getSrcInfo());
  if (braceStart != code.size())
    finalCode += escapeFStringBraces(code, braceStart, int(code.size()) - braceStart);
  se-&gt;strings[0].first = finalCode;
  return N&lt;SuiteStmt&gt;(items);
}

/// Fetch a decorator canonical name. The first pair member indicates if a decorator is
/// actually an attribute (a function with `@__attribute__`).
std::pair&lt;bool, std::string&gt; SimplifyVisitor::getDecorator(const ExprPtr &amp;e) {
  auto dt = transform(clone(e));
  auto id = dt-&gt;getCall() ? dt-&gt;getCall()-&gt;expr : dt;
  if (id &amp;&amp; id-&gt;getId()) {
    auto ci = ctx-&gt;find(id-&gt;getId()-&gt;value);
    if (ci &amp;&amp; ci-&gt;isFunc()) {
      if (ctx-&gt;cache-&gt;overloads[ci-&gt;canonicalName].size() == 1) {
        return {ctx-&gt;cache-&gt;functions[ctx-&gt;cache-&gt;overloads[ci-&gt;canonicalName][0].name]
                    .ast-&gt;attributes.isAttribute,
                ci-&gt;canonicalName};
      }
    }
  }
  return {false, ""};
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.776">/// Ensure that `(yield)` is in a function.
void SimplifyVisitor::visit(YieldExpr *expr) {
  if (!ctx-&gt;inFunction())
    E(Error::FN_OUTSIDE_ERROR, expr, "yield");
}

</t>
<t tx="ekr.20230509083243.777">/// Transform lambdas. Capture outer expressions.
/// @example
///   `lambda a, b: a+b+c` -&gt; ```def fn(a, b, c):
///                                return a+b+c
///                              fn(c=c, ...)```
/// See @c makeAnonFn
void SimplifyVisitor::visit(LambdaExpr *expr) {
  resultExpr =
      makeAnonFn(std::vector&lt;StmtPtr&gt;{N&lt;ReturnStmt&gt;(clone(expr-&gt;expr))}, expr-&gt;vars);
}

</t>
<t tx="ekr.20230509083243.778">/// Ensure that `return` is in a function.
void SimplifyVisitor::visit(ReturnStmt *stmt) {
  if (!ctx-&gt;inFunction())
    E(Error::FN_OUTSIDE_ERROR, stmt, "return");
  transform(stmt-&gt;expr);
}

</t>
<t tx="ekr.20230509083243.779">/// Ensure that `yield` is in a function.
void SimplifyVisitor::visit(YieldStmt *stmt) {
  if (!ctx-&gt;inFunction())
    E(Error::FN_OUTSIDE_ERROR, stmt, "yield");
  transform(stmt-&gt;expr);
}

</t>
<t tx="ekr.20230509083243.78">/// Type of a pointer to another CIR type
class PointerType : public AcceptorExtend&lt;PointerType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs a pointer type.
  /// @param base the type's base
  explicit PointerType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509083243.780">/// Transform `yield from` statements.
/// @example
///   `yield from a` -&gt; `for var in a: yield var`
void SimplifyVisitor::visit(YieldFromStmt *stmt) {
  auto var = ctx-&gt;cache-&gt;getTemporaryVar("yield");
  resultStmt =
      transform(N&lt;ForStmt&gt;(N&lt;IdExpr&gt;(var), stmt-&gt;expr, N&lt;YieldStmt&gt;(N&lt;IdExpr&gt;(var))));
}

</t>
<t tx="ekr.20230509083243.781">/// Process `global` statements. Remove them upon completion.
void SimplifyVisitor::visit(GlobalStmt *stmt) {
  if (!ctx-&gt;inFunction())
    E(Error::FN_OUTSIDE_ERROR, stmt, stmt-&gt;nonLocal ? "nonlocal" : "global");

  // Dominate the binding
  auto val = ctx-&gt;findDominatingBinding(stmt-&gt;var);
  if (!val || !val-&gt;isVar())
    E(Error::ID_NOT_FOUND, stmt, stmt-&gt;var);
  if (val-&gt;getBaseName() == ctx-&gt;getBaseName())
    E(Error::FN_GLOBAL_ASSIGNED, stmt, stmt-&gt;var);

  // Check global/nonlocal distinction
  if (!stmt-&gt;nonLocal &amp;&amp; !val-&gt;getBaseName().empty())
    E(Error::FN_GLOBAL_NOT_FOUND, stmt, "global", stmt-&gt;var);
  else if (stmt-&gt;nonLocal &amp;&amp; val-&gt;getBaseName().empty())
    E(Error::FN_GLOBAL_NOT_FOUND, stmt, "nonlocal", stmt-&gt;var);
  seqassert(!val-&gt;canonicalName.empty(), "'{}' does not have a canonical name",
            stmt-&gt;var);

  // Register as global if needed
  ctx-&gt;cache-&gt;addGlobal(val-&gt;canonicalName);

  val = ctx-&gt;addVar(stmt-&gt;var, val-&gt;canonicalName, stmt-&gt;getSrcInfo());
  val-&gt;baseName = ctx-&gt;getBaseName();
  // Globals/nonlocals cannot be shadowed in children scopes (as in Python)
  val-&gt;noShadow = true;
  // Erase the statement
  resultStmt = N&lt;SuiteStmt&gt;();
}

</t>
<t tx="ekr.20230509083243.782">/// Validate and transform function definitions.
/// Handle overloads, class methods, default arguments etc.
/// Also capture variables if necessary and apply decorators.
/// @example
///   ```a = 5
///      @dec
///      def foo(b):
///        return a+b
///   ``` -&gt; ```
///      a = 5
///      def foo(b, a_cap):
///        return a_cap+b
///      foo = dec(foo(a_cap=a, ...))
///   ```
/// For Python and LLVM definition transformations, see
/// @c transformPythonDefinition and @c transformLLVMDefinition
void SimplifyVisitor::visit(FunctionStmt *stmt) {
  if (stmt-&gt;attributes.has(Attr::Python)) {
    // Handle Python block
    resultStmt = transformPythonDefinition(stmt-&gt;name, stmt-&gt;args, stmt-&gt;ret.get(),
                                           stmt-&gt;suite-&gt;firstInBlock());
    return;
  }

  // Parse attributes
  for (auto i = stmt-&gt;decorators.size(); i-- &gt; 0;) {
    auto [isAttr, attrName] = getDecorator(stmt-&gt;decorators[i]);
    if (!attrName.empty()) {
      stmt-&gt;attributes.set(attrName);
      if (isAttr)
        stmt-&gt;decorators[i] = nullptr; // remove it from further consideration
    }
  }

  bool isClassMember = ctx-&gt;inClass(), isEnclosedFunc = ctx-&gt;inFunction();
  if (stmt-&gt;attributes.has(Attr::ForceRealize) &amp;&amp; (!ctx-&gt;isGlobal() || isClassMember))
    E(Error::EXPECTED_TOPLEVEL, getSrcInfo(), "builtin function");

  // All overloads share the same canonical name except for the number at the
  // end (e.g., `foo.1:0`, `foo.1:1` etc.)
  std::string rootName;
  if (isClassMember) {
    // Case 1: method overload
    if (auto n = in(ctx-&gt;cache-&gt;classes[ctx-&gt;getBase()-&gt;name].methods, stmt-&gt;name))
      rootName = *n;
  } else if (stmt-&gt;attributes.has(Attr::Overload)) {
    // Case 2: function overload
    if (auto c = ctx-&gt;find(stmt-&gt;name)) {
      if (c-&gt;isFunc() &amp;&amp; c-&gt;getModule() == ctx-&gt;getModule() &amp;&amp;
          c-&gt;getBaseName() == ctx-&gt;getBaseName())
        rootName = c-&gt;canonicalName;
    }
  }
  if (rootName.empty())
    rootName = ctx-&gt;generateCanonicalName(stmt-&gt;name, true);
  @others
  std::vector&lt;Param&gt; args;
  StmtPtr suite = nullptr;
  ExprPtr ret = nullptr;
  std::unordered_map&lt;std::string, std::pair&lt;std::string, ExprPtr&gt;&gt; captures;
  std::unordered_set&lt;std::string&gt; pyCaptures;
  {
    // Set up the base
    SimplifyContext::BaseGuard br(ctx.get(), canonicalName);
    ctx-&gt;getBase()-&gt;attributes = &amp;(stmt-&gt;attributes);

    // Parse arguments and add them to the context
    for (auto &amp;a : stmt-&gt;args) {
      std::string varName = a.name;
      int stars = trimStars(varName);
      auto name = ctx-&gt;generateCanonicalName(varName);

      // Mark as method if the first argument is self
      if (isClassMember &amp;&amp; stmt-&gt;attributes.has(Attr::HasSelf) &amp;&amp; a.name == "self") {
        ctx-&gt;getBase()-&gt;selfName = name;
        stmt-&gt;attributes.set(Attr::Method);
      }

      // Handle default values
      auto defaultValue = a.defaultValue;
      if (a.type &amp;&amp; defaultValue &amp;&amp; defaultValue-&gt;getNone()) {
        // Special case: `arg: Callable = None` -&gt; `arg: Callable = NoneType()`
        if (a.type-&gt;getIndex() &amp;&amp; a.type-&gt;getIndex()-&gt;expr-&gt;isId(TYPE_CALLABLE))
          defaultValue = N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("NoneType"));
        // Special case: `arg: type = None` -&gt; `arg: type = NoneType`
        if (a.type-&gt;isId("type") || a.type-&gt;isId(TYPE_TYPEVAR))
          defaultValue = N&lt;IdExpr&gt;("NoneType");
      }
      /// TODO: Uncomment for Python-style defaults
      // if (defaultValue) {
      //   auto defaultValueCanonicalName =
      //       ctx-&gt;generateCanonicalName(format("{}.{}", canonicalName, name));
      //   prependStmts-&gt;push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(defaultValueCanonicalName),
      //     defaultValue));
      //   defaultValue = N&lt;IdExpr&gt;(defaultValueCanonicalName);
      // }
      args.emplace_back(
          Param{std::string(stars, '*') + name, a.type, defaultValue, a.status});

      // Add generics to the context
      if (a.status != Param::Normal) {
        if (auto st = getStaticGeneric(a.type.get())) {
          auto val = ctx-&gt;addVar(varName, name, stmt-&gt;getSrcInfo());
          val-&gt;generic = true;
          val-&gt;staticType = st;
        } else {
          ctx-&gt;addType(varName, name, stmt-&gt;getSrcInfo())-&gt;generic = true;
        }
      }
    }

    // Parse arguments to the context. Needs to be done after adding generics
    // to support cases like `foo(a: T, T: type)`
    for (auto &amp;a : args) {
      a.type = transformType(a.type, false);
      a.defaultValue = transform(a.defaultValue, true);
    }
    // Add non-generic arguments to the context. Delayed to prevent cases like
    // `def foo(a, b=a)`
    for (auto &amp;a : args) {
      if (a.status == Param::Normal) {
        std::string canName = a.name;
        trimStars(canName);
        ctx-&gt;addVar(ctx-&gt;cache-&gt;rev(canName), canName, stmt-&gt;getSrcInfo());
      }
    }

    // Parse the return type
    ret = transformType(stmt-&gt;ret, false);

    // Parse function body
    if (!stmt-&gt;attributes.has(Attr::Internal) &amp;&amp; !stmt-&gt;attributes.has(Attr::C)) {
      if (stmt-&gt;attributes.has(Attr::LLVM)) {
        suite = transformLLVMDefinition(stmt-&gt;suite-&gt;firstInBlock());
      } else if (stmt-&gt;attributes.has(Attr::C)) {
        // Do nothing
      } else {
        if ((isEnclosedFunc || stmt-&gt;attributes.has(Attr::Capture)) &amp;&amp; !isClassMember)
          ctx-&gt;getBase()-&gt;captures = &amp;captures;
        if (stmt-&gt;attributes.has("std.internal.attributes.pycapture"))
          ctx-&gt;getBase()-&gt;pyCaptures = &amp;pyCaptures;
        suite = SimplifyVisitor(ctx, preamble).transformConditionalScope(stmt-&gt;suite);
      }
    }
  }
  stmt-&gt;attributes.module =
      format("{}{}", ctx-&gt;moduleName.status == ImportFile::STDLIB ? "std::" : "::",
             ctx-&gt;moduleName.module);
  ctx-&gt;cache-&gt;overloads[rootName].push_back({canonicalName, ctx-&gt;cache-&gt;age});

  // Special method handling
  if (isClassMember) {
    // Set the enclosing class name
    stmt-&gt;attributes.parentClass = ctx-&gt;getBase()-&gt;name;
    // Add the method to the class' method list
    ctx-&gt;cache-&gt;classes[ctx-&gt;getBase()-&gt;name].methods[stmt-&gt;name] = rootName;
  } else {
    // Hack so that we can later use same helpers for class overloads
    ctx-&gt;cache-&gt;classes[".toplevel"].methods[stmt-&gt;name] = rootName;
  }

  // Handle captures. Add additional argument to the function for every capture.
  // Make sure to account for **kwargs if present
  std::vector&lt;CallExpr::Arg&gt; partialArgs;
  if (!captures.empty()) {
    Param kw;
    if (!args.empty() &amp;&amp; startswith(args.back().name, "**")) {
      kw = args.back();
      args.pop_back();
    }
    for (auto &amp;c : captures) {
      args.emplace_back(Param{c.second.first, c.second.second, nullptr});
      partialArgs.push_back({c.second.first, N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;rev(c.first))});
    }
    if (!kw.name.empty())
      args.push_back(kw);
    partialArgs.push_back({"", N&lt;EllipsisExpr&gt;()});
  }
  // Make function AST and cache it for later realization
  auto f = N&lt;FunctionStmt&gt;(canonicalName, ret, args, suite, stmt-&gt;attributes);
  ctx-&gt;cache-&gt;functions[canonicalName].ast = f;
  ctx-&gt;cache-&gt;functions[canonicalName].origAst =
      std::static_pointer_cast&lt;FunctionStmt&gt;(stmt-&gt;clone());
  ctx-&gt;cache-&gt;functions[canonicalName].isToplevel =
      ctx-&gt;getModule().empty() &amp;&amp; ctx-&gt;isGlobal();
  ctx-&gt;cache-&gt;functions[canonicalName].rootName = rootName;

  // Expression to be used if function binding is modified by captures or decorators
  ExprPtr finalExpr = nullptr;
  // If there are captures, replace `fn` with `fn(cap1=cap1, cap2=cap2, ...)`
  if (!captures.empty()) {
    finalExpr = N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(stmt-&gt;name), partialArgs);
    // Add updated self reference in case function is recursive!
    auto pa = partialArgs;
    for (auto &amp;a : pa) {
      if (!a.name.empty())
        a.value = N&lt;IdExpr&gt;(a.name);
      else
        a.value = clone(a.value);
    }
    f-&gt;suite = N&lt;SuiteStmt&gt;(
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(rootName), N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(rootName), pa)),
        suite);
  }

  // Parse remaining decorators
  for (auto i = stmt-&gt;decorators.size(); i-- &gt; 0;) {
    if (stmt-&gt;decorators[i]) {
      if (isClassMember)
        E(Error::FN_NO_DECORATORS, stmt-&gt;decorators[i]);
      // Replace each decorator with `decorator(finalExpr)` in the reverse order
      finalExpr = N&lt;CallExpr&gt;(stmt-&gt;decorators[i],
                              finalExpr ? finalExpr : N&lt;IdExpr&gt;(stmt-&gt;name));
    }
  }

  if (finalExpr) {
    resultStmt =
        N&lt;SuiteStmt&gt;(f, transform(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(stmt-&gt;name), finalExpr)));
  } else {
    resultStmt = f;
  }
}

</t>
<t tx="ekr.20230509083243.783">// Append overload number to the name
auto canonicalName =
    format("{}:{}", rootName, ctx-&gt;cache-&gt;overloads[rootName].size());
ctx-&gt;cache-&gt;reverseIdentifierLookup[canonicalName] = stmt-&gt;name;

// Ensure that function binding does not shadow anything.
// Function bindings cannot be dominated either
if (!isClassMember) {
  auto funcVal = ctx-&gt;find(stmt-&gt;name);
  if (funcVal &amp;&amp; funcVal-&gt;noShadow)
    E(Error::CLASS_INVALID_BIND, stmt, stmt-&gt;name);
  funcVal = ctx-&gt;addFunc(stmt-&gt;name, rootName, stmt-&gt;getSrcInfo());
  ctx-&gt;addAlwaysVisible(funcVal);
}

</t>
<t tx="ekr.20230509083243.784">/// Make a capturing anonymous function with the provided suite and argument names.
/// The resulting function will be added before the current statement.
/// Return an expression that can call this function (an @c IdExpr or a partial call).
ExprPtr SimplifyVisitor::makeAnonFn(std::vector&lt;StmtPtr&gt; suite,
</t>
<t tx="ekr.20230509083243.785">                                    const std::vector&lt;std::string&gt; &amp;argNames) {
  std::vector&lt;Param&gt; params;
  std::string name = ctx-&gt;cache-&gt;getTemporaryVar("lambda");
  params.reserve(argNames.size());
  for (auto &amp;s : argNames)
    params.emplace_back(Param(s));
  @others
}

</t>
<t tx="ekr.20230509083243.786">auto f = transform(N&lt;FunctionStmt&gt;(name, nullptr, params, N&lt;SuiteStmt&gt;(move(suite)),
                                   Attr({Attr::Capture})));
if (auto fs = f-&gt;getSuite()) {
  seqassert(fs-&gt;stmts.size() == 2 &amp;&amp; fs-&gt;stmts[0]-&gt;getFunction(),
            "invalid function transform");
  prependStmts-&gt;push_back(fs-&gt;stmts[0]);
  for (StmtPtr s = fs-&gt;stmts[1]; s;) {
    if (auto suite = s-&gt;getSuite()) {
      // Suites can only occur when captures are inserted for a partial call
      // argument.
      seqassert(suite-&gt;stmts.size() == 2, "invalid function transform");
      prependStmts-&gt;push_back(suite-&gt;stmts[0]);
      s = suite-&gt;stmts[1];
    } else if (auto assign = s-&gt;getAssign()) {
      return assign-&gt;rhs;
    } else {
      seqassert(false, "invalid function transform");
    }
  }
  return nullptr; // should fail an assert before
} else {
  prependStmts-&gt;push_back(f);
  return transform(N&lt;IdExpr&gt;(name));
}
</t>
<t tx="ekr.20230509083243.787">/// Transform Python code blocks.
/// @example
///   ```@python
///      def foo(x: int, y) -&gt; int:
///        [code]
///   ``` -&gt; ```
///      pyobj._exec("def foo(x, y): [code]")
///      from python import __main__.foo(int, _) -&gt; int
///   ```
StmtPtr SimplifyVisitor::transformPythonDefinition(const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.788">                                                   const std::vector&lt;Param&gt; &amp;args,
  @others
</t>
<t tx="ekr.20230509083243.789">                                                 const Expr *ret, Stmt *codeStmt) {
seqassert(codeStmt &amp;&amp; codeStmt-&gt;getExpr() &amp;&amp; codeStmt-&gt;getExpr()-&gt;expr-&gt;getString(),
          "invalid Python definition");

auto code = codeStmt-&gt;getExpr()-&gt;expr-&gt;getString()-&gt;getValue();
std::vector&lt;std::string&gt; pyargs;
pyargs.reserve(args.size());
for (const auto &amp;a : args)
  pyargs.emplace_back(a.name);
code = format("def {}({}):\n{}\n", name, join(pyargs, ", "), code);
return transform(N&lt;SuiteStmt&gt;(
    N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("pyobj", "_exec"), N&lt;StringExpr&gt;(code))),
    N&lt;ImportStmt&gt;(N&lt;IdExpr&gt;("python"), N&lt;DotExpr&gt;("__main__", name), clone_nop(args),
                  ret ? ret-&gt;clone() : N&lt;IdExpr&gt;("pyobj"))));
}

</t>
<t tx="ekr.20230509083243.79">/// Type of an optional containing another CIR type
class OptionalType : public AcceptorExtend&lt;OptionalType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs an optional type.
  /// @param base the type's base
  explicit OptionalType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return getBase()-&gt;isAtomic(); }
};

</t>
<t tx="ekr.20230509083243.790">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
    processToplevelStmt(comment);
    if (auto st = n-&gt;getSuite()) {
      for (auto &amp;ss : st-&gt;stmts)
        if (ss)
          processToplevelStmt(ss);
    } else {
      processToplevelStmt(n);
    }

    // Create import function manually with ForceRealize
    ctx-&gt;cache-&gt;functions[importVar + ":0"].ast =
        N&lt;FunctionStmt&gt;(importVar + ":0", nullptr, std::vector&lt;Param&gt;{},
                        N&lt;SuiteStmt&gt;(stmts), Attr({Attr::ForceRealize}));
    preamble-&gt;push_back(ctx-&gt;cache-&gt;functions[importVar + ":0"].ast-&gt;clone());
    ctx-&gt;cache-&gt;overloads[importVar].push_back({importVar + ":0", ctx-&gt;cache-&gt;age});
  }
  return nullptr;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.791">/// Import and parse a new module into its own context.
/// Also handle special imports ( see @c transformSpecialImport ).
/// To simulate Python's dynamic import logic and import stuff only once,
/// each import statement is guarded as follows:
///   if not _import_N_done:
///     _import_N()
///     _import_N_done = True
/// See @c transformNewImport and below for more details.
void SimplifyVisitor::visit(ImportStmt *stmt) {
  seqassert(!ctx-&gt;inClass(), "imports within a class");
  if ((resultStmt = transformSpecialImport(stmt)))
    return;

  // Fetch the import
  auto components = getImportPath(stmt-&gt;from.get(), stmt-&gt;dots);
  auto path = combine2(components, "/");
  @others
  // If the file has not been seen before, load it into cache
  if (ctx-&gt;cache-&gt;imports.find(file-&gt;path) == ctx-&gt;cache-&gt;imports.end())
    resultStmt = transformNewImport(*file);

  const auto &amp;import = ctx-&gt;cache-&gt;imports[file-&gt;path];
  std::string importVar = import.importVar;
  std::string importDoneVar = importVar + "_done";

  // Construct `if _import_done.__invert__(): (_import(); _import_done = True)`.
  // Do not do this during the standard library loading (we assume that standard library
  // imports are "clean" and do not need guards). Note that the importVar is empty if
  // the import has been loaded during the standard library loading.
  if (!ctx-&gt;isStdlibLoading &amp;&amp; !importVar.empty()) {
    auto u = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(importDoneVar), N&lt;BoolExpr&gt;(true));
    u-&gt;setUpdate();
    resultStmt =
        N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(importDoneVar, "__invert__")),
                  N&lt;SuiteStmt&gt;(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(importVar))), u));
  }

  // Import requested identifiers from the import's scope to the current scope
  if (!stmt-&gt;what) {
    // Case: import foo
    auto name = stmt-&gt;as.empty() ? path : stmt-&gt;as;
    auto var = importVar + "_var";
    // Construct `import_var = Import([module], [path])` (for printing imports etc.)
    resultStmt = N&lt;SuiteStmt&gt;(
        resultStmt, transform(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var),
                                            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("Import"),
                                                        N&lt;StringExpr&gt;(file-&gt;module),
                                                        N&lt;StringExpr&gt;(file-&gt;path)),
                                            N&lt;IdExpr&gt;("Import"))));
    ctx-&gt;addVar(name, var, stmt-&gt;getSrcInfo())-&gt;importPath = file-&gt;path;
  } else if (stmt-&gt;what-&gt;isId("*")) {
    // Case: from foo import *
    seqassert(stmt-&gt;as.empty(), "renamed star-import");
    // Just copy all symbols from import's context here.
    for (auto &amp;i : *(import.ctx)) {
      if ((!startswith(i.first, "_") ||
           (ctx-&gt;isStdlibLoading &amp;&amp; startswith(i.first, "__")))) {
        // Ignore all identifiers that start with `_` but not those that start with
        // `__` while the standard library is being loaded
        auto c = i.second.front();
        if (c-&gt;isConditional() &amp;&amp; i.first.find('.') == std::string::npos) {
          c = import.ctx-&gt;findDominatingBinding(i.first);
        }
        // Imports should ignore  noShadow property
        ctx-&gt;Context&lt;SimplifyItem&gt;::add(i.first, c);
      }
    }
  } else {
    // Case 3: from foo import bar
    auto i = stmt-&gt;what-&gt;getId();
    seqassert(i, "not a valid import what expression");
    auto c = import.ctx-&gt;find(i-&gt;value);
    // Make sure that we are importing an existing global symbol
    if (!c)
      E(Error::IMPORT_NO_NAME, i, i-&gt;value, file-&gt;module);
    if (c-&gt;isConditional())
      c = import.ctx-&gt;findDominatingBinding(i-&gt;value);
    // Imports should ignore  noShadow property
    ctx-&gt;Context&lt;SimplifyItem&gt;::add(stmt-&gt;as.empty() ? i-&gt;value : stmt-&gt;as, c);
  }

  if (!resultStmt) {
    resultStmt = N&lt;SuiteStmt&gt;(); // erase it
  }
}

</t>
<t tx="ekr.20230509083243.792">auto file = getImportFile(ctx-&gt;cache-&gt;argv0, path, ctx-&gt;getFilename(), false,
                          ctx-&gt;cache-&gt;module0, ctx-&gt;cache-&gt;pluginImportPaths);
if (!file) {
  std::string s(stmt-&gt;dots, '.');
  for (size_t i = 0; i &lt; components.size(); i++)
    if (components[i] == "..") {
      continue;
    } else if (!s.empty() &amp;&amp; s.back() != '.') {
      s += "." + components[i];
    } else {
      s += components[i];
    }
  E(Error::IMPORT_NO_MODULE, stmt-&gt;from, s);
}

</t>
<t tx="ekr.20230509083243.793">/// Transform special `from C` and `from python` imports.
/// See @c transformCImport, @c transformCDLLImport and @c transformPythonImport
StmtPtr SimplifyVisitor::transformSpecialImport(ImportStmt *stmt) {
  if (stmt-&gt;from &amp;&amp; stmt-&gt;from-&gt;isId("C") &amp;&amp; stmt-&gt;what-&gt;getId() &amp;&amp; stmt-&gt;isFunction) {
    // C function imports
    return transformCImport(stmt-&gt;what-&gt;getId()-&gt;value, stmt-&gt;args, stmt-&gt;ret.get(),
                            stmt-&gt;as);
  }
  if (stmt-&gt;from &amp;&amp; stmt-&gt;from-&gt;isId("C") &amp;&amp; stmt-&gt;what-&gt;getId()) {
    // C variable imports
    return transformCVarImport(stmt-&gt;what-&gt;getId()-&gt;value, stmt-&gt;ret.get(), stmt-&gt;as);
  } else if (stmt-&gt;from &amp;&amp; stmt-&gt;from-&gt;isId("C") &amp;&amp; stmt-&gt;what-&gt;getDot()) {
    // dylib C imports
    return transformCDLLImport(stmt-&gt;what-&gt;getDot()-&gt;expr.get(),
                               stmt-&gt;what-&gt;getDot()-&gt;member, stmt-&gt;args,
                               stmt-&gt;ret.get(), stmt-&gt;as, stmt-&gt;isFunction);
  } else if (stmt-&gt;from &amp;&amp; stmt-&gt;from-&gt;isId("python") &amp;&amp; stmt-&gt;what) {
    // Python imports
    return transformPythonImport(stmt-&gt;what.get(), stmt-&gt;args, stmt-&gt;ret.get(),
                                 stmt-&gt;as);
  }
  return nullptr;
}

/// Transform Dot(Dot(a, b), c...) into "{a, b, c, ...}".
/// Useful for getting import paths.
std::vector&lt;std::string&gt; SimplifyVisitor::getImportPath(Expr *from, size_t dots) {
  std::vector&lt;std::string&gt; components; // Path components
  if (from) {
    for (; from-&gt;getDot(); from = from-&gt;getDot()-&gt;expr.get())
      components.push_back(from-&gt;getDot()-&gt;member);
    seqassert(from-&gt;getId(), "invalid import statement");
    components.push_back(from-&gt;getId()-&gt;value);
  }

  // Handle dots (i.e., `..` in `from ..m import x`)
  for (size_t i = 1; i &lt; dots; i++)
    components.emplace_back("..");
  std::reverse(components.begin(), components.end());
  return components;
}

/// Transform a C function import.
/// @example
///   `from C import foo(int) -&gt; float as f` -&gt;
///   ```@.c
///      def foo(a1: int) -&gt; float:
///        pass
///      f = foo # if altName is provided```
/// No return type implies void return type. *args is treated as C VAR_ARGS.
StmtPtr SimplifyVisitor::transformCImport(const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.794">                                          const std::vector&lt;Param&gt; &amp;args,
  @others
</t>
<t tx="ekr.20230509083243.795">                                        const Expr *ret, const std::string &amp;altName) {
std::vector&lt;Param&gt; fnArgs;
auto attr = Attr({Attr::C});
for (size_t ai = 0; ai &lt; args.size(); ai++) {
  seqassert(args[ai].name.empty(), "unexpected argument name");
  seqassert(!args[ai].defaultValue, "unexpected default argument");
  seqassert(args[ai].type, "missing type");
  if (args[ai].type-&gt;getEllipsis() &amp;&amp; ai + 1 == args.size()) {
    // C VAR_ARGS support
    attr.set(Attr::CVarArg);
    fnArgs.emplace_back(Param{"*args", nullptr, nullptr});
  } else {
    fnArgs.emplace_back(
        Param{args[ai].name.empty() ? format("a{}", ai) : args[ai].name,
              args[ai].type-&gt;clone(), nullptr});
  }
}
ctx-&gt;generateCanonicalName(name); // avoid canonicalName == name
StmtPtr f = N&lt;FunctionStmt&gt;(name, ret ? ret-&gt;clone() : N&lt;IdExpr&gt;("NoneType"), fnArgs,
                            nullptr, attr);
f = transform(f); // Already in the preamble
if (!altName.empty()) {
  auto val = ctx-&gt;forceFind(name);
  ctx-&gt;add(altName, val);
  ctx-&gt;remove(name);
}
return f;
}

</t>
<t tx="ekr.20230509083243.796">/// Transform a C variable import.
/// @example
///   `from C import foo: int as f` -&gt;
///   ```f: int = "foo"```
StmtPtr SimplifyVisitor::transformCVarImport(const std::string &amp;name, const Expr *type,
</t>
<t tx="ekr.20230509083243.797">                                             const std::string &amp;altName) {
  auto canonical = ctx-&gt;generateCanonicalName(name);
  auto val = ctx-&gt;addVar(altName.empty() ? name : altName, canonical);
  val-&gt;noShadow = true;
  auto s = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(canonical), nullptr, transformType(type-&gt;clone()));
  s-&gt;lhs-&gt;setAttr(ExprAttr::ExternVar);
  return s;
}

</t>
<t tx="ekr.20230509083243.798">/// Transform a dynamic C import.
/// @example
///   `from C import lib.foo(int) -&gt; float as f` -&gt;
///   `f = _dlsym(lib, "foo", Fn=Function[[int], float]); f`
/// No return type implies void return type.
StmtPtr SimplifyVisitor::transformCDLLImport(const Expr *dylib, const std::string &amp;name,
</t>
<t tx="ekr.20230509083243.799">                                             const std::vector&lt;Param&gt; &amp;args,
  @others
</t>
<t tx="ekr.20230509083243.8">  void handle(YieldInstr *v) override {
    auto *M = v-&gt;getModule();
    auto *val = v-&gt;getValue();
    auto *valBool = val ? (*M-&gt;getBoolType())(*val) : nullptr;
    if (!valBool) {
      valid = false;
      return;
    } else if (!any) {
      valBool = M-&gt;Nr&lt;TernaryInstr&gt;(valBool, M-&gt;getBool(false), M-&gt;getBool(true));
    }

    auto *newReturn = M-&gt;Nr&lt;ReturnInstr&gt;(M-&gt;getBool(any));
    see(newReturn);
    auto *rep = M-&gt;Nr&lt;IfFlow&gt;(valBool, util::series(newReturn));
    v-&gt;replaceAll(rep);
  }

</t>
<t tx="ekr.20230509083243.80">/// Type of a generator yielding another CIR type
class GeneratorType : public AcceptorExtend&lt;GeneratorType, DerivedType&gt; {
public:
  static const char NodeId;

  /// Constructs a generator type.
  /// @param base the type's base
  explicit GeneratorType(Type *base) : AcceptorExtend(getInstanceName(base), base) {}

  static std::string getInstanceName(Type *base);

private:
  bool doIsAtomic() const override { return false; }
};

</t>
<t tx="ekr.20230509083243.800">                                           const Expr *ret,
@others
</t>
<t tx="ekr.20230509083243.801">                                           const std::string &amp;altName,
@others
</t>
<t tx="ekr.20230509083243.802">                                           bool isFunction) {
ExprPtr type = nullptr;
if (isFunction) {
  std::vector&lt;ExprPtr&gt; fnArgs{N&lt;ListExpr&gt;(std::vector&lt;ExprPtr&gt;{}),
                              ret ? ret-&gt;clone() : N&lt;IdExpr&gt;("NoneType")};
  for (const auto &amp;a : args) {
    seqassert(a.name.empty(), "unexpected argument name");
    seqassert(!a.defaultValue, "unexpected default argument");
    seqassert(a.type, "missing type");
    fnArgs[0]-&gt;getList()-&gt;items.emplace_back(clone(a.type));
  }

  type = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Function"), N&lt;TupleExpr&gt;(fnArgs));
} else {
  type = ret-&gt;clone();
}

return transform(N&lt;AssignStmt&gt;(
    N&lt;IdExpr&gt;(altName.empty() ? name : altName),
    N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("_dlsym"),
                std::vector&lt;CallExpr::Arg&gt;{CallExpr::Arg(dylib-&gt;clone()),
                                           CallExpr::Arg(N&lt;StringExpr&gt;(name)),
                                           {"Fn", type}})));
}

</t>
<t tx="ekr.20230509083243.803">/// Transform a Python module and function imports.
/// @example
///   `from python import module as f` -&gt; `f = pyobj._import("module")`
///   `from python import lib.foo(int) -&gt; float as f` -&gt;
///   ```def f(a0: int) -&gt; float:
///        f = pyobj._import("lib")._getattr("foo")
///        return float.__from_py__(f(a0))```
/// If a return type is nullptr, the function just returns f (raw pyobj).
StmtPtr SimplifyVisitor::transformPythonImport(Expr *what,
</t>
<t tx="ekr.20230509083243.804">                                               const std::vector&lt;Param&gt; &amp;args,
                                               Expr *ret, const std::string &amp;altName) {
  // Get a module name (e.g., os.path)
  auto components = getImportPath(what);

  if (!ret &amp;&amp; args.empty()) {
    // Simple import: `from python import foo.bar` -&gt; `bar = pyobj._import("foo.bar")`
    return transform(
        N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(altName.empty() ? components.back() : altName),
                      N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("pyobj", "_import"),
                                  N&lt;StringExpr&gt;(combine2(components, ".")))));
  }

  // Python function import:
  // `from python import foo.bar(int) -&gt; float` -&gt;
  // ```def bar(a1: int) -&gt; float:
  //      f = pyobj._import("foo")._getattr("bar")
  //      return float.__from_py__(f(a1))```

  // f = pyobj._import("foo")._getattr("bar")
  auto call = N&lt;AssignStmt&gt;(
      N&lt;IdExpr&gt;("f"),
      N&lt;CallExpr&gt;(
          N&lt;DotExpr&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;("pyobj", "_import"),
                                 N&lt;StringExpr&gt;(combine2(components, ".", 0,
                                                        int(components.size()) - 1))),
                     "_getattr"),
          N&lt;StringExpr&gt;(components.back())));
  // f(a1, ...)
  std::vector&lt;Param&gt; params;
  std::vector&lt;ExprPtr&gt; callArgs;
  for (int i = 0; i &lt; args.size(); i++) {
    params.emplace_back(Param{format("a{}", i), clone(args[i].type), nullptr});
    callArgs.emplace_back(N&lt;IdExpr&gt;(format("a{}", i)));
  }
  // `return ret.__from_py__(f(a1, ...))`
  auto retType = (ret &amp;&amp; !ret-&gt;getNone()) ? ret-&gt;clone() : N&lt;IdExpr&gt;("NoneType");
  auto retExpr = N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(retType-&gt;clone(), "__from_py__"),
                             N&lt;DotExpr&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("f"), callArgs), "p"));
  auto retStmt = N&lt;ReturnStmt&gt;(retExpr);
  // Create a function
  return transform(N&lt;FunctionStmt&gt;(altName.empty() ? components.back() : altName,
                                   retType, params, N&lt;SuiteStmt&gt;(call, retStmt)));
}

</t>
<t tx="ekr.20230509083243.805">/// Import a new file into its own context and wrap its top-level statements into a
/// function to support Python-like runtime import loading.
/// @example
///   ```_import_[I]_done = False
///      def _import_[I]():
///        global [imported global variables]...
///        __name__ = [I]
///        [imported top-level statements]```
StmtPtr SimplifyVisitor::transformNewImport(const ImportFile &amp;file) {
  // Use a clean context to parse a new file
  if (ctx-&gt;cache-&gt;age)
    ctx-&gt;cache-&gt;age++;
  auto ictx = std::make_shared&lt;SimplifyContext&gt;(file.path, ctx-&gt;cache);
  ictx-&gt;isStdlibLoading = ctx-&gt;isStdlibLoading;
  ictx-&gt;moduleName = file;
  auto import = ctx-&gt;cache-&gt;imports.insert({file.path, {file.path, ictx}}).first;
  import-&gt;second.moduleName = file.module;

  // __name__ = [import name]
  StmtPtr n =
      N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;("__name__"), N&lt;StringExpr&gt;(ictx-&gt;moduleName.module));
  if (ictx-&gt;moduleName.module == "internal.core") {
    // str is not defined when loading internal.core; __name__ is not needed anyway
    n = nullptr;
  }
  n = N&lt;SuiteStmt&gt;(n, parseFile(ctx-&gt;cache, file.path));
  n = SimplifyVisitor(ictx, preamble).transform(n);
  if (!ctx-&gt;cache-&gt;errors.empty())
    throw exc::ParserException();
  // Add comment to the top of import for easier dump inspection
  auto comment = N&lt;CommentStmt&gt;(format("import: {} at {}", file.module, file.path));
  if (ctx-&gt;isStdlibLoading) {
    // When loading the standard library, imports are not wrapped.
    // We assume that the standard library has no recursive imports and that all
    // statements are executed before the user-provided code.
    return N&lt;SuiteStmt&gt;(comment, n);
  } else {
    // Generate import identifier
    std::string importVar = import-&gt;second.importVar =
        ctx-&gt;cache-&gt;getTemporaryVar(format("import_{}", file.module));
    std::string importDoneVar;

    // `import_[I]_done = False` (set to True upon successful import)
    preamble-&gt;push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(importDoneVar = importVar + "_done"),
                                      N&lt;BoolExpr&gt;(false)));
    ctx-&gt;cache-&gt;addGlobal(importDoneVar);

    // Wrap all imported top-level statements into a function.
    // Make sure to register the global variables and set their assignments as updates.
    // Note: signatures/classes/functions are not wrapped
    std::vector&lt;StmtPtr&gt; stmts;
</t>
<t tx="ekr.20230509083243.806">    auto processToplevelStmt = [&amp;](const StmtPtr &amp;s) {
      // Process toplevel statement
      if (auto a = s-&gt;getAssign()) {
        if (!a-&gt;isUpdate() &amp;&amp; a-&gt;lhs-&gt;getId()) {
          // Global `a = ...`
          auto val = ictx-&gt;forceFind(a-&gt;lhs-&gt;getId()-&gt;value);
          if (val-&gt;isVar() &amp;&amp; val-&gt;isGlobal())
            ctx-&gt;cache-&gt;addGlobal(val-&gt;canonicalName);
        }
      }
      stmts.push_back(s);
    };
</t>
<t tx="ekr.20230509083243.807">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

@others
/// Transform and check for OpenMP decorator.
/// @example
///   `@par(num_threads=2, openmp="schedule(static)")` -&gt;
///   `for_par(num_threads=2, schedule="static")`
ExprPtr SimplifyVisitor::transformForDecorator(const ExprPtr &amp;decorator) {
  if (!decorator)
    return nullptr;
  ExprPtr callee = decorator;
  if (auto c = callee-&gt;getCall())
    callee = c-&gt;expr;
  if (!callee || !callee-&gt;isId("par"))
    E(Error::LOOP_DECORATOR, decorator);
  std::vector&lt;CallExpr::Arg&gt; args;
  std::string openmp;
  std::vector&lt;CallExpr::Arg&gt; omp;
  if (auto c = decorator-&gt;getCall())
    for (auto &amp;a : c-&gt;args) {
      if (a.name == "openmp" ||
          (a.name.empty() &amp;&amp; openmp.empty() &amp;&amp; a.value-&gt;getString())) {
        omp = parseOpenMP(ctx-&gt;cache, a.value-&gt;getString()-&gt;getValue(),
                          a.value-&gt;getSrcInfo());
      } else {
        args.push_back({a.name, transform(a.value)});
      }
    }
  for (auto &amp;a : omp)
    args.push_back({a.name, transform(a.value)});
  return N&lt;CallExpr&gt;(transform(N&lt;IdExpr&gt;("for_par")), args);
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.808">/// Ensure that `continue` is in a loop
void SimplifyVisitor::visit(ContinueStmt *stmt) {
  if (!ctx-&gt;getBase()-&gt;getLoop())
    E(Error::EXPECTED_LOOP, stmt, "continue");
}

</t>
<t tx="ekr.20230509083243.809">/// Ensure that `break` is in a loop.
/// Transform if a loop break variable is available
/// (e.g., a break within loop-else block).
/// @example
///   `break` -&gt; `no_break = False; break`
void SimplifyVisitor::visit(BreakStmt *stmt) {
  if (!ctx-&gt;getBase()-&gt;getLoop())
    E(Error::EXPECTED_LOOP, stmt, "break");
  if (!ctx-&gt;getBase()-&gt;getLoop()-&gt;breakVar.empty()) {
    resultStmt = N&lt;SuiteStmt&gt;(
        transform(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(ctx-&gt;getBase()-&gt;getLoop()-&gt;breakVar),
                                N&lt;BoolExpr&gt;(false))),
        N&lt;BreakStmt&gt;());
  }
}

</t>
<t tx="ekr.20230509083243.81">/// Type of a variably sized integer
class IntNType : public AcceptorExtend&lt;IntNType, PrimitiveType&gt; {
private:
  /// length of the integer
  unsigned len;
  /// whether the variable is signed
  bool sign;

public:
  static const char NodeId;

  static const unsigned MAX_LEN = 2048;

  /// Constructs a variably sized integer type.
  /// @param len the length of the integer
  /// @param sign true if signed, false otherwise
  IntNType(unsigned len, bool sign)
      : AcceptorExtend(getInstanceName(len, sign)), len(len), sign(sign) {}

  /// @return the length of the integer
  unsigned getLen() const { return len; }
  /// @return true if signed
  bool isSigned() const { return sign; }

  /// @return the name of the opposite signed corresponding type
  std::string oppositeSignName() const { return getInstanceName(len, !sign); }

  static std::string getInstanceName(unsigned len, bool sign);
};

</t>
<t tx="ekr.20230509083243.810">/// Transform a while loop.
/// @example
///   `while cond: ...`           -&gt;  `while cond.__bool__(): ...`
///   `while cond: ... else: ...` -&gt; ```no_break = True
///                                     while cond.__bool__():
///                                       ...
///                                     if no_break: ...```
void SimplifyVisitor::visit(WhileStmt *stmt) {
  // Check for while-else clause
  std::string breakVar;
  if (stmt-&gt;elseSuite &amp;&amp; stmt-&gt;elseSuite-&gt;firstInBlock()) {
    // no_break = True
    breakVar = ctx-&gt;cache-&gt;getTemporaryVar("no_break");
    prependStmts-&gt;push_back(
        transform(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(breakVar), N&lt;BoolExpr&gt;(true))));
  }

  ctx-&gt;enterConditionalBlock();
  ctx-&gt;getBase()-&gt;loops.push_back({breakVar, ctx-&gt;scope.blocks, {}});
  stmt-&gt;cond = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(stmt-&gt;cond, "__bool__")));
  transformConditionalScope(stmt-&gt;suite);

  // Complete while-else clause
  if (stmt-&gt;elseSuite &amp;&amp; stmt-&gt;elseSuite-&gt;firstInBlock()) {
    resultStmt = N&lt;SuiteStmt&gt;(N&lt;WhileStmt&gt;(*stmt),
                              N&lt;IfStmt&gt;(transform(N&lt;IdExpr&gt;(breakVar)),
                                        transformConditionalScope(stmt-&gt;elseSuite)));
  }

  ctx-&gt;leaveConditionalBlock();
  // Dominate loop variables
  for (auto &amp;var : ctx-&gt;getBase()-&gt;getLoop()-&gt;seenVars) {
    ctx-&gt;findDominatingBinding(var);
  }
  ctx-&gt;getBase()-&gt;loops.pop_back();
}

</t>
<t tx="ekr.20230509083243.811">/// Transform for loop.
/// @example
///   `for i, j in it: ...`        -&gt; ```for tmp in it:
///                                        i, j = tmp
///                                        ...```
///   `for i in it: ... else: ...` -&gt; ```no_break = True
///                                      for i in it: ...
///                                      if no_break: ...```
void SimplifyVisitor::visit(ForStmt *stmt) {
  stmt-&gt;decorator = transformForDecorator(stmt-&gt;decorator);

  std::string breakVar;
  // Needs in-advance transformation to prevent name clashes with the iterator variable
  stmt-&gt;iter = transform(stmt-&gt;iter);

  // Check for for-else clause
  StmtPtr assign = nullptr;
  if (stmt-&gt;elseSuite &amp;&amp; stmt-&gt;elseSuite-&gt;firstInBlock()) {
    breakVar = ctx-&gt;cache-&gt;getTemporaryVar("no_break");
    assign = transform(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(breakVar), N&lt;BoolExpr&gt;(true)));
  }

  ctx-&gt;enterConditionalBlock();
  ctx-&gt;getBase()-&gt;loops.push_back({breakVar, ctx-&gt;scope.blocks, {}});
  std::string varName;
  if (auto i = stmt-&gt;var-&gt;getId()) {
    auto val = ctx-&gt;addVar(i-&gt;value, varName = ctx-&gt;generateCanonicalName(i-&gt;value),
                           stmt-&gt;var-&gt;getSrcInfo());
    val-&gt;avoidDomination = ctx-&gt;avoidDomination;
    transform(stmt-&gt;var);
    stmt-&gt;suite = transform(N&lt;SuiteStmt&gt;(stmt-&gt;suite));
  } else {
    varName = ctx-&gt;cache-&gt;getTemporaryVar("for");
    auto val = ctx-&gt;addVar(varName, varName, stmt-&gt;var-&gt;getSrcInfo());
    auto var = N&lt;IdExpr&gt;(varName);
    std::vector&lt;StmtPtr&gt; stmts;
    // Add for_var = [for variables]
    stmts.push_back(N&lt;AssignStmt&gt;(stmt-&gt;var, clone(var)));
    stmt-&gt;var = var;
    stmts.push_back(stmt-&gt;suite);
    stmt-&gt;suite = transform(N&lt;SuiteStmt&gt;(stmts));
  }

  // Complete while-else clause
  if (stmt-&gt;elseSuite &amp;&amp; stmt-&gt;elseSuite-&gt;firstInBlock()) {
    resultStmt = N&lt;SuiteStmt&gt;(assign, N&lt;ForStmt&gt;(*stmt),
                              N&lt;IfStmt&gt;(transform(N&lt;IdExpr&gt;(breakVar)),
                                        transformConditionalScope(stmt-&gt;elseSuite)));
  }

  ctx-&gt;leaveConditionalBlock(&amp;(stmt-&gt;suite-&gt;getSuite()-&gt;stmts));
  // Dominate loop variables
  for (auto &amp;var : ctx-&gt;getBase()-&gt;getLoop()-&gt;seenVars)
    ctx-&gt;findDominatingBinding(var);
  ctx-&gt;getBase()-&gt;loops.pop_back();
}

</t>
<t tx="ekr.20230509083243.812">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

void SimplifyVisitor::visit(UnaryExpr *expr) { transform(expr-&gt;expr); }

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.813">/// Transform binary expressions with a few special considerations.
/// The real stuff happens during the type checking.
void SimplifyVisitor::visit(BinaryExpr *expr) {
  // Special case: `is` can take type as well
  transform(expr-&gt;lexpr, startswith(expr-&gt;op, "is"));
  auto tmp = ctx-&gt;isConditionalExpr;
  // The second operand of the and/or expression is conditional
  ctx-&gt;isConditionalExpr = expr-&gt;op == "&amp;&amp;" || expr-&gt;op == "||";
  transform(expr-&gt;rexpr, startswith(expr-&gt;op, "is"));
  ctx-&gt;isConditionalExpr = tmp;
}

</t>
<t tx="ekr.20230509083243.814">/// Transform chain binary expression.
/// @example
///   `a &lt;= b &lt;= c` -&gt; `(a &lt;= (chain := b)) and (chain &lt;= c)`
/// The assignment above ensures that all expressions are executed only once.
void SimplifyVisitor::visit(ChainBinaryExpr *expr) {
  seqassert(expr-&gt;exprs.size() &gt;= 2, "not enough expressions in ChainBinaryExpr");
  std::vector&lt;ExprPtr&gt; items;
  std::string prev;
  for (int i = 1; i &lt; expr-&gt;exprs.size(); i++) {
    auto l = prev.empty() ? clone(expr-&gt;exprs[i - 1].second) : N&lt;IdExpr&gt;(prev);
    prev = ctx-&gt;generateCanonicalName("chain");
    auto r =
        (i + 1 == expr-&gt;exprs.size())
            ? clone(expr-&gt;exprs[i].second)
            : N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(prev), clone(expr-&gt;exprs[i].second)),
                          N&lt;IdExpr&gt;(prev));
    items.emplace_back(N&lt;BinaryExpr&gt;(l, expr-&gt;exprs[i].first, r));
  }

  ExprPtr final = items.back();
  for (auto i = items.size() - 1; i-- &gt; 0;)
    final = N&lt;BinaryExpr&gt;(items[i], "&amp;&amp;", final);
  resultExpr = transform(final);
}

</t>
<t tx="ekr.20230509083243.815">/// Transform index into an instantiation @c InstantiateExpr if possible.
/// Generate tuple class `Tuple.N` for `Tuple[T1, ... TN]` (and `tuple[...]`).
/// The rest is handled during the type checking.
void SimplifyVisitor::visit(IndexExpr *expr) {
  if (expr-&gt;expr-&gt;isId("tuple") || expr-&gt;expr-&gt;isId("Tuple")) {
    // Special case: tuples. Change to Tuple.N
    auto t = expr-&gt;index-&gt;getTuple();
    expr-&gt;expr = NT&lt;IdExpr&gt;(format(TYPE_TUPLE "{}", t ? t-&gt;items.size() : 1));
  } else if (expr-&gt;expr-&gt;isId("Static")) {
    // Special case: static types. Ensure that static is supported
    if (!expr-&gt;index-&gt;isId("int") &amp;&amp; !expr-&gt;index-&gt;isId("str"))
      E(Error::BAD_STATIC_TYPE, expr-&gt;index);
    expr-&gt;markType();
    return;
  } else {
    transform(expr-&gt;expr, true);
  }

  // IndexExpr[i1, ..., iN] is internally represented as
  // IndexExpr[TupleExpr[i1, ..., iN]] for N &gt; 1
  std::vector&lt;ExprPtr&gt; items;
  bool isTuple = expr-&gt;index-&gt;getTuple();
  if (auto t = expr-&gt;index-&gt;getTuple()) {
    items = t-&gt;items;
  } else {
    items.push_back(expr-&gt;index);
  }
  for (auto &amp;i : items) {
    if (i-&gt;getList() &amp;&amp; expr-&gt;expr-&gt;isType()) {
      // Special case: `A[[A, B], C]` -&gt; `A[Tuple[A, B], C]` (e.g., in
      // `Function[...]`)
      i = N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Tuple"), N&lt;TupleExpr&gt;(i-&gt;getList()-&gt;items));
    }
    transform(i, true);
  }
  if (expr-&gt;expr-&gt;isType()) {
    resultExpr = N&lt;InstantiateExpr&gt;(expr-&gt;expr, items);
    resultExpr-&gt;markType();
  } else {
    expr-&gt;index = (!isTuple &amp;&amp; items.size() == 1) ? items[0] : N&lt;TupleExpr&gt;(items);
  }
}

</t>
<t tx="ekr.20230509083243.816">/// Already transformed. Sometimes needed again
/// for identifier analysis.
void SimplifyVisitor::visit(InstantiateExpr *expr) {
  transformType(expr-&gt;typeExpr);
  for (auto &amp;tp : expr-&gt;typeParams)
    transform(tp, true);
}

</t>
<t tx="ekr.20230509083243.817">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "simplify.h"

#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/peg/peg.h"
#include "codon/parser/visitors/simplify/ctx.h"

using fmt::format;
using namespace codon::error;
namespace codon::ast {

using namespace types;

/// Simplify an AST node. Load standard library if needed.
/// @param cache     Pointer to the shared cache ( @c Cache )
/// @param file      Filename to be used for error reporting
/// @param barebones Use the bare-bones standard library for faster testing
/// @param defines   User-defined static values (typically passed as `codon run -DX=Y`).
///                  Each value is passed as a string.
StmtPtr
SimplifyVisitor::apply(Cache *cache, const StmtPtr &amp;node, const std::string &amp;file,
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.818">                       const std::unordered_map&lt;std::string, std::string&gt; &amp;defines,
  @others
</t>
<t tx="ekr.20230509083243.819">                     const std::unordered_map&lt;std::string, std::string&gt; &amp;earlyDefines,
@others
</t>
<t tx="ekr.20230509083243.82">/// Type of a vector of primitives
class VectorType : public AcceptorExtend&lt;VectorType, PrimitiveType&gt; {
private:
  /// number of elements
  unsigned count;
  /// base type
  PrimitiveType *base;

public:
  static const char NodeId;

  /// Constructs a vector type.
  /// @param count the number of elements
  /// @param base the base type
  VectorType(unsigned count, PrimitiveType *base)
      : AcceptorExtend(getInstanceName(count, base)), count(count), base(base) {}

  /// @return the count of the vector
  unsigned getCount() const { return count; }
  /// @return the base type of the vector
  PrimitiveType *getBase() const { return base; }

  static std::string getInstanceName(unsigned count, PrimitiveType *base);
};

</t>
<t tx="ekr.20230509083243.820">                     bool barebones) {
auto preamble = std::make_shared&lt;std::vector&lt;StmtPtr&gt;&gt;();
seqassertn(cache-&gt;module, "cache's module is not set");

#define N std::make_shared
// Load standard library if it has not been loaded
if (!in(cache-&gt;imports, STDLIB_IMPORT)) {
  // Load the internal.__init__
  auto stdlib = std::make_shared&lt;SimplifyContext&gt;(STDLIB_IMPORT, cache);
@others
  stdlib-&gt;setFilename(stdlibPath-&gt;path);
  cache-&gt;imports[STDLIB_IMPORT] = {stdlibPath-&gt;path, stdlib};
  stdlib-&gt;isStdlibLoading = true;
  stdlib-&gt;moduleName = {ImportFile::STDLIB, stdlibPath-&gt;path, "__init__"};
  // Load the standard library
  stdlib-&gt;setFilename(stdlibPath-&gt;path);
  // Core definitions
  preamble-&gt;push_back(SimplifyVisitor(stdlib, preamble)
                          .transform(parseCode(stdlib-&gt;cache, stdlibPath-&gt;path,
                                               "from internal.core import *")));
  for (auto &amp;d : earlyDefines) {
    // Load early compile-time defines (for standard library)
    preamble-&gt;push_back(
        SimplifyVisitor(stdlib, preamble)
            .transform(
                N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(d.first), N&lt;IntExpr&gt;(d.second),
                              N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"), N&lt;IdExpr&gt;("int")))));
  }
  preamble-&gt;push_back(SimplifyVisitor(stdlib, preamble)
                          .transform(parseFile(stdlib-&gt;cache, stdlibPath-&gt;path)));
  stdlib-&gt;isStdlibLoading = false;

  // The whole standard library has the age of zero to allow back-references
  cache-&gt;age++;
}

// Set up the context and the cache
auto ctx = std::make_shared&lt;SimplifyContext&gt;(file, cache);
cache-&gt;imports[file].filename = file;
cache-&gt;imports[file].ctx = ctx;
cache-&gt;imports[MAIN_IMPORT] = {file, ctx};
ctx-&gt;setFilename(file);
ctx-&gt;moduleName = {ImportFile::PACKAGE, file, MODULE_MAIN};

// Prepare the code
auto suite = N&lt;SuiteStmt&gt;();
suite-&gt;stmts.push_back(N&lt;ClassStmt&gt;(".toplevel", std::vector&lt;Param&gt;{}, nullptr,
                                    std::vector&lt;ExprPtr&gt;{N&lt;IdExpr&gt;(Attr::Internal)}));
for (auto &amp;d : defines) {
  // Load compile-time defines (e.g., codon run -DFOO=1 ...)
  suite-&gt;stmts.push_back(
      N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(d.first), N&lt;IntExpr&gt;(d.second),
                    N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"), N&lt;IdExpr&gt;("int"))));
}
// Set up __name__
suite-&gt;stmts.push_back(
    N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;("__name__"), N&lt;StringExpr&gt;(MODULE_MAIN)));
suite-&gt;stmts.push_back(node);
auto n = SimplifyVisitor(ctx, preamble).transform(suite);

suite = N&lt;SuiteStmt&gt;();
suite-&gt;stmts.push_back(N&lt;SuiteStmt&gt;(*preamble));
// Add dominated assignment declarations
if (in(ctx-&gt;scope.stmts, ctx-&gt;scope.blocks.back()))
  suite-&gt;stmts.insert(suite-&gt;stmts.end(),
                      ctx-&gt;scope.stmts[ctx-&gt;scope.blocks.back()].begin(),
                      ctx-&gt;scope.stmts[ctx-&gt;scope.blocks.back()].end());
suite-&gt;stmts.push_back(n);
#undef N

if (!ctx-&gt;cache-&gt;errors.empty())
  throw exc::ParserException();

return suite;
}

</t>
<t tx="ekr.20230509083243.821">  auto stdlibPath =
      getImportFile(cache-&gt;argv0, STDLIB_INTERNAL_MODULE, "", true, cache-&gt;module0);
  const std::string initFile = "__init__.codon";
  if (!stdlibPath || !endswith(stdlibPath-&gt;path, initFile))
    E(Error::COMPILER_NO_STDLIB);

  /// Use __init_test__ for faster testing (e.g., #%% name,barebones)
  /// TODO: get rid of it one day...
  if (barebones) {
    stdlibPath-&gt;path =
        stdlibPath-&gt;path.substr(0, stdlibPath-&gt;path.size() - initFile.size()) +
        "__init_test__.codon";
  }
</t>
<t tx="ekr.20230509083243.822">/// Simplify an AST node. Assumes that the standard library is loaded.
StmtPtr SimplifyVisitor::apply(const std::shared_ptr&lt;SimplifyContext&gt; &amp;ctx,
</t>
<t tx="ekr.20230509083243.823">                               const StmtPtr &amp;node, const std::string &amp;file,
  @others
</t>
<t tx="ekr.20230509083243.824">                             int atAge) {
std::vector&lt;StmtPtr&gt; stmts;
int oldAge = ctx-&gt;cache-&gt;age;
if (atAge != -1)
  ctx-&gt;cache-&gt;age = atAge;
auto preamble = std::make_shared&lt;std::vector&lt;StmtPtr&gt;&gt;();
stmts.emplace_back(SimplifyVisitor(ctx, preamble).transform(node));
if (!ctx-&gt;cache-&gt;errors.empty())
  throw exc::ParserException();

if (atAge != -1)
  ctx-&gt;cache-&gt;age = oldAge;
auto suite = std::make_shared&lt;SuiteStmt&gt;();
for (auto &amp;s : *preamble)
  suite-&gt;stmts.push_back(s);
for (auto &amp;s : stmts)
  suite-&gt;stmts.push_back(s);
return suite;
}

</t>
<t tx="ekr.20230509083243.825">/**************************************************************************************/

SimplifyVisitor::SimplifyVisitor(std::shared_ptr&lt;SimplifyContext&gt; ctx,
                                 std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; preamble,
</t>
<t tx="ekr.20230509083243.826">                                 const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts)
    : ctx(std::move(ctx)), preamble(std::move(preamble)) {
  prependStmts = stmts ? stmts : std::make_shared&lt;std::vector&lt;StmtPtr&gt;&gt;();
}

</t>
<t tx="ekr.20230509083243.827">/**************************************************************************************/

ExprPtr SimplifyVisitor::transform(ExprPtr &amp;expr) { return transform(expr, false); }

/// Transform an expression node.
/// @throw @c ParserException if a node is a type and @param allowTypes is not set
///        (use @c transformType instead).
ExprPtr SimplifyVisitor::transform(ExprPtr &amp;expr, bool allowTypes) {
  if (!expr)
    return nullptr;
  SimplifyVisitor v(ctx, preamble);
  v.prependStmts = prependStmts;
  v.setSrcInfo(expr-&gt;getSrcInfo());
  ctx-&gt;pushSrcInfo(expr-&gt;getSrcInfo());
  expr-&gt;accept(v);
  ctx-&gt;popSrcInfo();
  if (v.resultExpr) {
    v.resultExpr-&gt;attributes |= expr-&gt;attributes;
    expr = v.resultExpr;
  }
  if (!allowTypes &amp;&amp; expr &amp;&amp; expr-&gt;isType())
    E(Error::UNEXPECTED_TYPE, expr, "type");
  return expr;
}

/// Transform a type expression node.
/// @param allowTypeOf Set if `type()` expressions are allowed. Usually disallowed in
///                    class/function definitions.
/// @throw @c ParserException if a node is not a type (use @c transform instead).
ExprPtr SimplifyVisitor::transformType(ExprPtr &amp;expr, bool allowTypeOf) {
  auto oldTypeOf = ctx-&gt;allowTypeOf;
  ctx-&gt;allowTypeOf = allowTypeOf;
  transform(expr, true);
  if (expr &amp;&amp; expr-&gt;getNone())
    expr-&gt;markType();
  ctx-&gt;allowTypeOf = oldTypeOf;
  if (expr &amp;&amp; !expr-&gt;isType())
    E(Error::EXPECTED_TYPE, expr, "type");
  return expr;
}

/// Transform a statement node.
StmtPtr SimplifyVisitor::transform(StmtPtr &amp;stmt) {
  if (!stmt)
    return nullptr;

  SimplifyVisitor v(ctx, preamble);
  v.setSrcInfo(stmt-&gt;getSrcInfo());
  ctx-&gt;pushSrcInfo(stmt-&gt;getSrcInfo());
  try {
    stmt-&gt;accept(v);
  } catch (const exc::ParserException &amp;e) {
    ctx-&gt;cache-&gt;errors.push_back(e);
    // throw;
  }
  ctx-&gt;popSrcInfo();
  if (v.resultStmt)
    stmt = v.resultStmt;
  stmt-&gt;age = ctx-&gt;cache-&gt;age;
  if (!v.prependStmts-&gt;empty()) {
    // Handle prepends
    if (stmt)
      v.prependStmts-&gt;push_back(stmt);
    stmt = N&lt;SuiteStmt&gt;(*v.prependStmts);
    stmt-&gt;age = ctx-&gt;cache-&gt;age;
  }
  return stmt;
}

/// Transform a statement in conditional scope.
/// Because variables and forward declarations within conditional scopes can be
/// added later after the domination analysis, ensure that all such declarations
/// are prepended.
StmtPtr SimplifyVisitor::transformConditionalScope(StmtPtr &amp;stmt) {
  if (stmt) {
    ctx-&gt;enterConditionalBlock();
    transform(stmt);
    SuiteStmt *suite = stmt-&gt;getSuite();
    if (!suite) {
      stmt = N&lt;SuiteStmt&gt;(stmt);
      suite = stmt-&gt;getSuite();
    }
    ctx-&gt;leaveConditionalBlock(&amp;suite-&gt;stmts);
    return stmt;
  }
  return stmt = nullptr;
}

/**************************************************************************************/

</t>
<t tx="ekr.20230509083243.828">void SimplifyVisitor::visit(StmtExpr *expr) {
  for (auto &amp;s : expr-&gt;stmts)
    transform(s);
  transform(expr-&gt;expr);
}

</t>
<t tx="ekr.20230509083243.829">void SimplifyVisitor::visit(StarExpr *expr) { transform(expr-&gt;what); }

void SimplifyVisitor::visit(KeywordStarExpr *expr) { transform(expr-&gt;what); }

</t>
<t tx="ekr.20230509083243.83">class UnionType : public AcceptorExtend&lt;UnionType, Type&gt; {
private:
  /// alternative types
  std::vector&lt;types::Type *&gt; types;

public:
  static const char NodeId;

  using const_iterator = std::vector&lt;types::Type *&gt;::const_iterator;
  using const_reference = std::vector&lt;types::Type *&gt;::const_reference;

  /// Constructs a UnionType.
  /// @param types the alternative types (must be sorted by caller)
  explicit UnionType(std::vector&lt;types::Type *&gt; types)
      : AcceptorExtend(), types(std::move(types)) {}

  const_iterator begin() const { return types.begin(); }
  const_iterator end() const { return types.end(); }
  const_reference front() const { return types.front(); }
  const_reference back() const { return types.back(); }

  static std::string getInstanceName(const std::vector&lt;types::Type *&gt; &amp;types);

private:
  std::vector&lt;types::Type *&gt; doGetUsedTypes() const override { return types; }

@others
};

</t>
<t tx="ekr.20230509083243.830">/// Manually handled in @c CallExpr
void SimplifyVisitor::visit(EllipsisExpr *expr) {
  E(Error::UNEXPECTED_TYPE, expr, "ellipsis");
}

</t>
<t tx="ekr.20230509083243.831">/// Only allowed in @c MatchStmt
void SimplifyVisitor::visit(RangeExpr *expr) {
  E(Error::UNEXPECTED_TYPE, expr, "range");
}

</t>
<t tx="ekr.20230509083243.832">/// Handled during the type checking
void SimplifyVisitor::visit(SliceExpr *expr) {
  transform(expr-&gt;start);
  transform(expr-&gt;stop);
  transform(expr-&gt;step);
}

</t>
<t tx="ekr.20230509083243.833">void SimplifyVisitor::visit(SuiteStmt *stmt) {
  for (auto &amp;s : stmt-&gt;stmts)
    transform(s);
  resultStmt = N&lt;SuiteStmt&gt;(stmt-&gt;stmts); // needed for flattening
}

</t>
<t tx="ekr.20230509083243.834">void SimplifyVisitor::visit(ExprStmt *stmt) { transform(stmt-&gt;expr, true); }

</t>
<t tx="ekr.20230509083243.835">void SimplifyVisitor::visit(CustomStmt *stmt) {
  if (stmt-&gt;suite) {
    auto fn = ctx-&gt;cache-&gt;customBlockStmts.find(stmt-&gt;keyword);
    seqassert(fn != ctx-&gt;cache-&gt;customBlockStmts.end(), "unknown keyword {}",
              stmt-&gt;keyword);
    resultStmt = fn-&gt;second.second(this, stmt);
  } else {
    auto fn = ctx-&gt;cache-&gt;customExprStmts.find(stmt-&gt;keyword);
    seqassert(fn != ctx-&gt;cache-&gt;customExprStmts.end(), "unknown keyword {}",
              stmt-&gt;keyword);
    resultStmt = fn-&gt;second(this, stmt);
  }
}

</t>
<t tx="ekr.20230509083243.836">@path C:/Repos/codon/codon/parser/visitors/simplify/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

/**
 * Visitor that implements the initial AST simplification transformation.
 * In this stage. the following steps are done:
 *  - All imports are flattened resulting in a single self-containing
 *    (and fairly large) AST
 *  - All identifiers are normalized (no two distinct objects share the same name)
 *  - Variadic classes (e.g., Tuple.N) are generated
 *  - Any AST node that can be trivially expressed as a set of "simpler" nodes
 *    type is simplified. If a transformation requires a type information,
 *    it is done during the type checking.
 *
 * -&gt; Note: this stage *modifies* the provided AST. Clone it before simplification
 *    if you need it intact.
 */
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.837">class SimplifyVisitor : public CallbackASTVisitor&lt;ExprPtr, StmtPtr&gt; {
  /// Shared simplification context.
  std::shared_ptr&lt;SimplifyContext&gt; ctx;
  /// Preamble contains definition statements shared across all visitors
  /// in all modules. It is executed before simplified statements.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; preamble;
  /// Statements to prepend before the current statement.
  std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; prependStmts;

  /// Each new expression is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  ExprPtr resultExpr;
  /// Each new statement is stored here (as @c visit does not return anything) and
  /// later returned by a @c transform call.
  StmtPtr resultStmt;

public:
  static StmtPtr
  apply(Cache *cache, const StmtPtr &amp;node, const std::string &amp;file,
        const std::unordered_map&lt;std::string, std::string&gt; &amp;defines = {},
        const std::unordered_map&lt;std::string, std::string&gt; &amp;earlyDefines = {},
        bool barebones = false);
  static StmtPtr apply(const std::shared_ptr&lt;SimplifyContext&gt; &amp;cache,
                       const StmtPtr &amp;node, const std::string &amp;file, int atAge = -1);

public:
  explicit SimplifyVisitor(
      std::shared_ptr&lt;SimplifyContext&gt; ctx,
      std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; preamble,
      const std::shared_ptr&lt;std::vector&lt;StmtPtr&gt;&gt; &amp;stmts = nullptr);

public: // Convenience transformators
  ExprPtr transform(ExprPtr &amp;expr) override;
  ExprPtr transform(const ExprPtr &amp;expr) override {
    auto e = expr;
    return transform(e);
  }
  ExprPtr transform(ExprPtr &amp;expr, bool allowTypes);
  ExprPtr transform(ExprPtr &amp;&amp;expr, bool allowTypes) {
    return transform(expr, allowTypes);
  }
  ExprPtr transformType(ExprPtr &amp;expr, bool allowTypeOf = true);
  ExprPtr transformType(ExprPtr &amp;&amp;expr, bool allowTypeOf = true) {
    return transformType(expr, allowTypeOf);
  }
  StmtPtr transform(StmtPtr &amp;stmt) override;
  StmtPtr transform(const StmtPtr &amp;stmt) override {
    auto s = stmt;
    return transform(s);
  }
  StmtPtr transformConditionalScope(StmtPtr &amp;stmt);

private: // Node simplification rules
  /* Basic type expressions (basic.cpp) */
  void visit(IntExpr *) override;
  ExprPtr transformInt(IntExpr *);
  void visit(FloatExpr *) override;
  ExprPtr transformFloat(FloatExpr *);
  void visit(StringExpr *) override;
  ExprPtr transformFString(const std::string &amp;);

  /* Identifier access expressions (access.cpp) */
  void visit(IdExpr *) override;
  bool checkCapture(const SimplifyContext::Item &amp;);
  void visit(DotExpr *) override;
  std::pair&lt;size_t, SimplifyContext::Item&gt; getImport(const std::vector&lt;std::string&gt; &amp;);

  /* Collection and comprehension expressions (collections.cpp) */
  void visit(TupleExpr *) override;
  void visit(ListExpr *) override;
  void visit(SetExpr *) override;
  void visit(DictExpr *) override;
  void visit(GeneratorExpr *) override;
  void visit(DictGeneratorExpr *) override;
  StmtPtr transformGeneratorBody(const std::vector&lt;GeneratorBody&gt; &amp;, SuiteStmt *&amp;);

  /* Conditional expression and statements (cond.cpp) */
  void visit(IfExpr *) override;
  void visit(IfStmt *) override;
  void visit(MatchStmt *) override;
  StmtPtr transformPattern(const ExprPtr &amp;, ExprPtr, StmtPtr);

  /* Operators (op.cpp) */
  void visit(UnaryExpr *) override;
  void visit(BinaryExpr *) override;
  void visit(ChainBinaryExpr *) override;
  void visit(IndexExpr *) override;
  void visit(InstantiateExpr *) override;

  /* Calls (call.cpp) */
  void visit(PrintStmt *) override;
  void visit(CallExpr *) override;
  ExprPtr transformSpecialCall(const ExprPtr &amp;, const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformTupleGenerator(const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformNamedTuple(const std::vector&lt;CallExpr::Arg&gt; &amp;);
  ExprPtr transformFunctoolsPartial(std::vector&lt;CallExpr::Arg&gt;);

  /* Assignments (assign.cpp) */
  void visit(AssignExpr *) override;
  void visit(AssignStmt *) override;
  StmtPtr transformAssignment(ExprPtr, ExprPtr, ExprPtr = nullptr, bool = false);
  void unpackAssignments(const ExprPtr &amp;, ExprPtr, std::vector&lt;StmtPtr&gt; &amp;);
  void visit(DelStmt *) override;

  /* Imports (import.cpp) */
  void visit(ImportStmt *) override;
  StmtPtr transformSpecialImport(ImportStmt *);
  std::vector&lt;std::string&gt; getImportPath(Expr *, size_t = 0);
  StmtPtr transformCImport(const std::string &amp;, const std::vector&lt;Param&gt; &amp;,
                           const Expr *, const std::string &amp;);
  StmtPtr transformCVarImport(const std::string &amp;, const Expr *, const std::string &amp;);
  StmtPtr transformCDLLImport(const Expr *, const std::string &amp;,
                              const std::vector&lt;Param&gt; &amp;, const Expr *,
                              const std::string &amp;, bool);
  StmtPtr transformPythonImport(Expr *, const std::vector&lt;Param&gt; &amp;, Expr *,
                                const std::string &amp;);
  StmtPtr transformNewImport(const ImportFile &amp;);

  /* Loops (loops.cpp) */
  void visit(ContinueStmt *) override;
  void visit(BreakStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  ExprPtr transformForDecorator(const ExprPtr &amp;);

  /* Errors and exceptions (error.cpp) */
  void visit(AssertStmt *) override;
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(WithStmt *) override;

  /* Functions (function.cpp) */
  void visit(YieldExpr *) override;
  void visit(LambdaExpr *) override;
  void visit(GlobalStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(YieldFromStmt *) override;
  void visit(FunctionStmt *) override;
  ExprPtr makeAnonFn(std::vector&lt;StmtPtr&gt;, const std::vector&lt;std::string&gt; &amp; = {});
  StmtPtr transformPythonDefinition(const std::string &amp;, const std::vector&lt;Param&gt; &amp;,
                                    const Expr *, Stmt *);
  StmtPtr transformLLVMDefinition(Stmt *);
  std::pair&lt;bool, std::string&gt; getDecorator(const ExprPtr &amp;);

  /* Classes (class.cpp) */
  void visit(ClassStmt *) override;
  std::vector&lt;ClassStmt *&gt; parseBaseClasses(std::vector&lt;ExprPtr&gt; &amp;,
                                            std::vector&lt;Param&gt; &amp;, const Attr &amp;,
                                            const std::string &amp;,
                                            const ExprPtr &amp; = nullptr);
  std::pair&lt;StmtPtr, FunctionStmt *&gt; autoDeduceMembers(ClassStmt *,
                                                       std::vector&lt;Param&gt; &amp;);
  std::vector&lt;StmtPtr&gt; getClassMethods(const StmtPtr &amp;s);
  void transformNestedClasses(ClassStmt *, std::vector&lt;StmtPtr&gt; &amp;,
                              std::vector&lt;StmtPtr&gt; &amp;, std::vector&lt;StmtPtr&gt; &amp;);
  StmtPtr codegenMagic(const std::string &amp;, const ExprPtr &amp;, const std::vector&lt;Param&gt; &amp;,
                       bool);

  /* The rest (simplify.cpp) */
  void visit(StmtExpr *) override;
  void visit(StarExpr *) override;
  void visit(KeywordStarExpr *expr) override;
  void visit(RangeExpr *) override;
  void visit(SliceExpr *) override;
  void visit(EllipsisExpr *) override;
  void visit(SuiteStmt *) override;
  void visit(ExprStmt *) override;
  void visit(CustomStmt *) override;
};

</t>
<t tx="ekr.20230509083243.838"></t>
<t tx="ekr.20230509083243.839">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "translate.h"

#include &lt;memory&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include "codon/cir/transform/parallel/schedule.h"
#include "codon/cir/util/cloning.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/translate/translate_ctx.h"

using codon::ir::cast;
using codon::ir::transform::parallel::OMPSched;
using fmt::format;

namespace codon::ast {

TranslateVisitor::TranslateVisitor(std::shared_ptr&lt;TranslateContext&gt; ctx)
    : ctx(std::move(ctx)), result(nullptr) {}

ir::Func *TranslateVisitor::apply(Cache *cache, const StmtPtr &amp;stmts) {
  ir::BodiedFunc *main = nullptr;
  if (cache-&gt;isJit) {
    auto fnName = format("_jit_{}", cache-&gt;jitCell);
    main = cache-&gt;module-&gt;Nr&lt;ir::BodiedFunc&gt;(fnName);
    main-&gt;setSrcInfo({"&lt;jit&gt;", 0, 0, 0});
    main-&gt;setGlobal();
    auto irType = cache-&gt;module-&gt;unsafeGetFuncType(
        fnName, cache-&gt;classes["NoneType"].realizations["NoneType"]-&gt;ir, {}, false);
    main-&gt;realize(irType, {});
    main-&gt;setJIT();
  } else {
    main = cast&lt;ir::BodiedFunc&gt;(cache-&gt;module-&gt;getMainFunc());
    auto path = getAbsolutePath(cache-&gt;module0);
    main-&gt;setSrcInfo({path, 0, 0, 0});
  }

  auto block = cache-&gt;module-&gt;Nr&lt;ir::SeriesFlow&gt;("body");
  main-&gt;setBody(block);

  if (!cache-&gt;codegenCtx)
    cache-&gt;codegenCtx = std::make_shared&lt;TranslateContext&gt;(cache);
  cache-&gt;codegenCtx-&gt;bases = {main};
  cache-&gt;codegenCtx-&gt;series = {block};

  for (auto &amp;g : cache-&gt;globals)
    if (!g.second) {
      g.second = g.first == VAR_ARGV ? cache-&gt;codegenCtx-&gt;getModule()-&gt;getArgVar()
                                     : cache-&gt;codegenCtx-&gt;getModule()-&gt;N&lt;ir::Var&gt;(
                                           SrcInfo(), nullptr, true, false, g.first);
      cache-&gt;codegenCtx-&gt;add(TranslateItem::Var, g.first, g.second);
    }

  TranslateVisitor(cache-&gt;codegenCtx).transform(stmts);
  cache-&gt;populatePythonModule();
  return main;
}

/************************************************************************************/

ir::Value *TranslateVisitor::transform(const ExprPtr &amp;expr) {
  TranslateVisitor v(ctx);
  v.setSrcInfo(expr-&gt;getSrcInfo());

  types::PartialType *p = nullptr;
  if (expr-&gt;attributes) {
    if (expr-&gt;hasAttr(ExprAttr::List) || expr-&gt;hasAttr(ExprAttr::Set) ||
        expr-&gt;hasAttr(ExprAttr::Dict) || expr-&gt;hasAttr(ExprAttr::Partial)) {
      ctx-&gt;seqItems.emplace_back();
    }
    if (expr-&gt;hasAttr(ExprAttr::Partial))
      p = expr-&gt;type-&gt;getPartial().get();
  }

  expr-&gt;accept(v);
  ir::Value *ir = v.result;

  if (expr-&gt;attributes) {
    if (expr-&gt;hasAttr(ExprAttr::List) || expr-&gt;hasAttr(ExprAttr::Set)) {
      std::vector&lt;ir::LiteralElement&gt; v;
      for (auto &amp;p : ctx-&gt;seqItems.back()) {
        seqassert(p.first &lt;= ExprAttr::StarSequenceItem, "invalid list/set element");
        v.push_back(
            ir::LiteralElement{p.second, p.first == ExprAttr::StarSequenceItem});
      }
      if (expr-&gt;hasAttr(ExprAttr::List))
        ir-&gt;setAttribute(std::make_unique&lt;ir::ListLiteralAttribute&gt;(v));
      else
        ir-&gt;setAttribute(std::make_unique&lt;ir::SetLiteralAttribute&gt;(v));
      ctx-&gt;seqItems.pop_back();
    }
    if (expr-&gt;hasAttr(ExprAttr::Dict)) {
      std::vector&lt;ir::DictLiteralAttribute::KeyValuePair&gt; v;
      for (int pi = 0; pi &lt; ctx-&gt;seqItems.back().size(); pi++) {
        auto &amp;p = ctx-&gt;seqItems.back()[pi];
        if (p.first == ExprAttr::StarSequenceItem) {
          v.push_back({p.second, nullptr});
        } else {
          seqassert(p.first == ExprAttr::SequenceItem &amp;&amp;
                        pi + 1 &lt; ctx-&gt;seqItems.back().size() &amp;&amp;
                        ctx-&gt;seqItems.back()[pi + 1].first == ExprAttr::SequenceItem,
                    "invalid dict element");
          v.push_back({p.second, ctx-&gt;seqItems.back()[pi + 1].second});
          pi++;
        }
      }
      ir-&gt;setAttribute(std::make_unique&lt;ir::DictLiteralAttribute&gt;(v));
      ctx-&gt;seqItems.pop_back();
    }
    if (expr-&gt;hasAttr(ExprAttr::Partial)) {
      std::vector&lt;ir::Value *&gt; v;
      seqassert(p, "invalid partial element");
      int j = 0;
      for (int i = 0; i &lt; p-&gt;known.size(); i++) {
        if (p-&gt;known[i] &amp;&amp; p-&gt;func-&gt;ast-&gt;args[i].status == Param::Normal) {
          seqassert(j &lt; ctx-&gt;seqItems.back().size() &amp;&amp;
                        ctx-&gt;seqItems.back()[j].first == ExprAttr::SequenceItem,
                    "invalid partial element");
          v.push_back(ctx-&gt;seqItems.back()[j++].second);
        } else if (p-&gt;func-&gt;ast-&gt;args[i].status == Param::Normal) {
          v.push_back({nullptr});
        }
      }
      ir-&gt;setAttribute(
          std::make_unique&lt;ir::PartialFunctionAttribute&gt;(p-&gt;func-&gt;ast-&gt;name, v));
      ctx-&gt;seqItems.pop_back();
    }
    if (expr-&gt;hasAttr(ExprAttr::SequenceItem)) {
      ctx-&gt;seqItems.back().push_back({ExprAttr::SequenceItem, ir});
    }
    if (expr-&gt;hasAttr(ExprAttr::StarSequenceItem)) {
      ctx-&gt;seqItems.back().push_back({ExprAttr::StarSequenceItem, ir});
    }
  }

  return ir;
}

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.84">  bool doIsAtomic() const override {
    return !std::any_of(types.begin(), types.end(),
                        [](auto *type) { return !type-&gt;isAtomic(); });
  }
</t>
<t tx="ekr.20230509083243.840">void TranslateVisitor::defaultVisit(Expr *n) {
  seqassert(false, "invalid node {}", n-&gt;toString());
}

</t>
<t tx="ekr.20230509083243.841">void TranslateVisitor::visit(NoneExpr *expr) {
  auto f = expr-&gt;type-&gt;realizedName() + ":Optional.__new__:0";
  auto val = ctx-&gt;find(f);
  seqassert(val, "cannot find '{}'", f);
  result = make&lt;ir::CallInstr&gt;(expr, make&lt;ir::VarValue&gt;(expr, val-&gt;getFunc()),
                               std::vector&lt;ir::Value *&gt;{});
}

</t>
<t tx="ekr.20230509083243.842">void TranslateVisitor::visit(BoolExpr *expr) {
  result = make&lt;ir::BoolConst&gt;(expr, expr-&gt;value, getType(expr-&gt;getType()));
}

</t>
<t tx="ekr.20230509083243.843">void TranslateVisitor::visit(IntExpr *expr) {
  result = make&lt;ir::IntConst&gt;(expr, *(expr-&gt;intValue), getType(expr-&gt;getType()));
}

</t>
<t tx="ekr.20230509083243.844">void TranslateVisitor::visit(FloatExpr *expr) {
  result = make&lt;ir::FloatConst&gt;(expr, *(expr-&gt;floatValue), getType(expr-&gt;getType()));
}

</t>
<t tx="ekr.20230509083243.845">void TranslateVisitor::visit(StringExpr *expr) {
  result = make&lt;ir::StringConst&gt;(expr, expr-&gt;getValue(), getType(expr-&gt;getType()));
}

</t>
<t tx="ekr.20230509083243.846">void TranslateVisitor::visit(IdExpr *expr) {
  auto val = ctx-&gt;find(expr-&gt;value);
  seqassert(val, "cannot find '{}'", expr-&gt;value);
  if (expr-&gt;value == "__vtable_size__")
    result = make&lt;ir::IntConst&gt;(expr, ctx-&gt;cache-&gt;classRealizationCnt + 2,
                                getType(expr-&gt;getType()));
  else if (auto *v = val-&gt;getVar())
    result = make&lt;ir::VarValue&gt;(expr, v);
  else if (auto *f = val-&gt;getFunc())
    result = make&lt;ir::VarValue&gt;(expr, f);
}

</t>
<t tx="ekr.20230509083243.847">void TranslateVisitor::visit(IfExpr *expr) {
  auto cond = transform(expr-&gt;cond);
  auto ifexpr = transform(expr-&gt;ifexpr);
  auto elsexpr = transform(expr-&gt;elsexpr);
  result = make&lt;ir::TernaryInstr&gt;(expr, cond, ifexpr, elsexpr);
}

</t>
<t tx="ekr.20230509083243.848">void TranslateVisitor::visit(CallExpr *expr) {
  if (expr-&gt;expr-&gt;isId("__ptr__")) {
    seqassert(expr-&gt;args[0].value-&gt;getId(), "expected IdExpr, got {}",
              expr-&gt;args[0].value);
    auto val = ctx-&gt;find(expr-&gt;args[0].value-&gt;getId()-&gt;value);
    seqassert(val &amp;&amp; val-&gt;getVar(), "{} is not a variable",
              expr-&gt;args[0].value-&gt;getId()-&gt;value);
    result = make&lt;ir::PointerValue&gt;(expr, val-&gt;getVar());
    return;
  } else if (expr-&gt;expr-&gt;isId("__array__.__new__:0")) {
    auto fnt = expr-&gt;expr-&gt;type-&gt;getFunc();
    auto szt = fnt-&gt;funcGenerics[0].type-&gt;getStatic();
    auto sz = szt-&gt;evaluate().getInt();
    auto typ = fnt-&gt;funcParent-&gt;getClass()-&gt;generics[0].type;

    auto *arrayType = ctx-&gt;getModule()-&gt;unsafeGetArrayType(getType(typ));
    arrayType-&gt;setAstType(expr-&gt;getType());
    result = make&lt;ir::StackAllocInstr&gt;(expr, arrayType, sz);
    return;
  } else if (expr-&gt;expr-&gt;getId() &amp;&amp; startswith(expr-&gt;expr-&gt;getId()-&gt;value,
                                               "__internal__.yield_in_no_suspend:0")) {
    result = make&lt;ir::YieldInInstr&gt;(expr, getType(expr-&gt;getType()), false);
    return;
  }

  auto ft = expr-&gt;expr-&gt;type-&gt;getFunc();
  seqassert(ft, "not calling function: {}", ft);
  auto callee = transform(expr-&gt;expr);
  bool isVariadic = ft-&gt;ast-&gt;hasAttr(Attr::CVarArg);
  std::vector&lt;ir::Value *&gt; items;
  for (int i = 0; i &lt; expr-&gt;args.size(); i++) {
    seqassert(!expr-&gt;args[i].value-&gt;getEllipsis(), "ellipsis not elided");
    if (i + 1 == expr-&gt;args.size() &amp;&amp; isVariadic) {
      auto call = expr-&gt;args[i].value-&gt;getCall();
      seqassert(call &amp;&amp; call-&gt;expr-&gt;getId() &amp;&amp;
                    startswith(call-&gt;expr-&gt;getId()-&gt;value, TYPE_TUPLE),
                "expected *args tuple");
      for (auto &amp;arg : call-&gt;args)
        items.emplace_back(transform(arg.value));
    } else {
      items.emplace_back(transform(expr-&gt;args[i].value));
    }
  }
  result = make&lt;ir::CallInstr&gt;(expr, callee, std::move(items));
}

</t>
<t tx="ekr.20230509083243.849">void TranslateVisitor::visit(DotExpr *expr) {
  if (expr-&gt;member == "__atomic__" || expr-&gt;member == "__elemsize__" ||
      expr-&gt;member == "__contents_atomic__") {
    seqassert(expr-&gt;expr-&gt;getId(), "expected IdExpr, got {}", expr-&gt;expr);
    auto type = ctx-&gt;find(expr-&gt;expr-&gt;getId()-&gt;value)-&gt;getType();
    seqassert(type, "{} is not a type", expr-&gt;expr-&gt;getId()-&gt;value);
    result = make&lt;ir::TypePropertyInstr&gt;(
        expr, type,
        expr-&gt;member == "__atomic__"
            ? ir::TypePropertyInstr::Property::IS_ATOMIC
            : (expr-&gt;member == "__contents_atomic__"
                   ? ir::TypePropertyInstr::Property::IS_CONTENT_ATOMIC
                   : ir::TypePropertyInstr::Property::SIZEOF));
  } else {
    result = make&lt;ir::ExtractInstr&gt;(expr, transform(expr-&gt;expr), expr-&gt;member);
  }
}

</t>
<t tx="ekr.20230509083243.85"></t>
<t tx="ekr.20230509083243.850">void TranslateVisitor::visit(YieldExpr *expr) {
  result = make&lt;ir::YieldInInstr&gt;(expr, getType(expr-&gt;getType()));
}

</t>
<t tx="ekr.20230509083243.851">void TranslateVisitor::visit(PipeExpr *expr) {
  @others
  std::vector&lt;ir::PipelineFlow::Stage&gt; stages;
  auto *firstStage = transform(expr-&gt;items[0].expr);
  auto firstIsGen = isGen(firstStage);
  stages.emplace_back(firstStage, std::vector&lt;ir::Value *&gt;(), firstIsGen, false);

  // Pipeline without generators (just function call sugar)
  auto simplePipeline = !firstIsGen;
  for (auto i = 1; i &lt; expr-&gt;items.size(); i++) {
    auto call = expr-&gt;items[i].expr-&gt;getCall();
    seqassert(call, "{} is not a call", expr-&gt;items[i].expr);

    auto fn = transform(call-&gt;expr);
    if (i + 1 != expr-&gt;items.size())
      simplePipeline &amp;= !isGen(fn);

    std::vector&lt;ir::Value *&gt; args;
    for (auto &amp;a : call-&gt;args)
      args.emplace_back(a.value-&gt;getEllipsis() ? nullptr : transform(a.value));
    stages.emplace_back(fn, args, isGen(fn), false);
  }

  if (simplePipeline) {
    // Transform a |&gt; b |&gt; c to c(b(a))
    ir::util::CloneVisitor cv(ctx-&gt;getModule());
    result = cv.clone(stages[0].getCallee());
    for (auto i = 1; i &lt; stages.size(); ++i) {
      std::vector&lt;ir::Value *&gt; newArgs;
      for (auto arg : stages[i])
        newArgs.push_back(arg ? cv.clone(arg) : result);
      result = make&lt;ir::CallInstr&gt;(expr, cv.clone(stages[i].getCallee()), newArgs);
    }
  } else {
    for (int i = 0; i &lt; expr-&gt;items.size(); i++)
      if (expr-&gt;items[i].op == "||&gt;")
        stages[i].setParallel();
    // This is a statement in IR.
    ctx-&gt;getSeries()-&gt;push_back(make&lt;ir::PipelineFlow&gt;(expr, stages));
  }
}

</t>
<t tx="ekr.20230509083243.852">auto isGen = [](const ir::Value *v) -&gt; bool {
  auto *type = v-&gt;getType();
  if (ir::isA&lt;ir::types::GeneratorType&gt;(type))
    return true;
  else if (auto *fn = cast&lt;ir::types::FuncType&gt;(type)) {
    return ir::isA&lt;ir::types::GeneratorType&gt;(fn-&gt;getReturnType());
  }
  return false;
};

</t>
<t tx="ekr.20230509083243.853">void TranslateVisitor::visit(StmtExpr *expr) {
  auto *bodySeries = make&lt;ir::SeriesFlow&gt;(expr, "body");
  ctx-&gt;addSeries(bodySeries);
  for (auto &amp;s : expr-&gt;stmts)
    transform(s);
  ctx-&gt;popSeries();
  result = make&lt;ir::FlowInstr&gt;(expr, bodySeries, transform(expr-&gt;expr));
}

</t>
<t tx="ekr.20230509083243.854">/************************************************************************************/

ir::Value *TranslateVisitor::transform(const StmtPtr &amp;stmt) {
  TranslateVisitor v(ctx);
  v.setSrcInfo(stmt-&gt;getSrcInfo());
  stmt-&gt;accept(v);
  if (v.result)
    ctx-&gt;getSeries()-&gt;push_back(v.result);
  return v.result;
}

</t>
<t tx="ekr.20230509083243.855">void TranslateVisitor::defaultVisit(Stmt *n) {
  seqassert(false, "invalid node {}", n-&gt;toString());
}

</t>
<t tx="ekr.20230509083243.856">void TranslateVisitor::visit(SuiteStmt *stmt) {
  for (auto &amp;s : stmt-&gt;stmts)
    transform(s);
}

</t>
<t tx="ekr.20230509083243.857">void TranslateVisitor::visit(BreakStmt *stmt) { result = make&lt;ir::BreakInstr&gt;(stmt); }

</t>
<t tx="ekr.20230509083243.858">void TranslateVisitor::visit(ContinueStmt *stmt) {
  result = make&lt;ir::ContinueInstr&gt;(stmt);
}

</t>
<t tx="ekr.20230509083243.859">void TranslateVisitor::visit(ExprStmt *stmt) {
  if (stmt-&gt;expr-&gt;getCall() &amp;&amp;
      stmt-&gt;expr-&gt;getCall()-&gt;expr-&gt;isId("__internal__.yield_final:0")) {
    result = make&lt;ir::YieldInstr&gt;(stmt, transform(stmt-&gt;expr-&gt;getCall()-&gt;args[0].value),
                                  true);
    ctx-&gt;getBase()-&gt;setGenerator();
  } else {
    result = transform(stmt-&gt;expr);
  }
}

</t>
<t tx="ekr.20230509083243.86">@path C:/Repos/codon/codon/cir/util/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "cloning.h"

#include "codon/cir/util/operator.h"

namespace codon {
namespace ir {
namespace util {
namespace {
struct GatherLocals : public util::Operator {
  std::vector&lt;Var *&gt; locals;
@others
void CloneVisitor::visit(const dsl::CustomInstr *v) { result = v-&gt;doClone(*this); }

} // namespace util
} // namespace ir
} // namespace codon
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.860">void TranslateVisitor::visit(AssignStmt *stmt) {
  if (stmt-&gt;lhs &amp;&amp; stmt-&gt;lhs-&gt;isId(VAR_ARGV))
    return;

  if (stmt-&gt;isUpdate()) {
    seqassert(stmt-&gt;lhs-&gt;getId(), "expected IdExpr, got {}", stmt-&gt;lhs);
    auto val = ctx-&gt;find(stmt-&gt;lhs-&gt;getId()-&gt;value);
    seqassert(val &amp;&amp; val-&gt;getVar(), "{} is not a variable", stmt-&gt;lhs-&gt;getId()-&gt;value);
    result = make&lt;ir::AssignInstr&gt;(stmt, val-&gt;getVar(), transform(stmt-&gt;rhs));
    return;
  }

  seqassert(stmt-&gt;lhs-&gt;getId(), "expected IdExpr, got {}", stmt-&gt;lhs);
  auto var = stmt-&gt;lhs-&gt;getId()-&gt;value;
  if (!stmt-&gt;rhs || (!stmt-&gt;rhs-&gt;isType() &amp;&amp; stmt-&gt;rhs-&gt;type)) {
    auto isGlobal = in(ctx-&gt;cache-&gt;globals, var);
    ir::Var *v = nullptr;

    if (isGlobal) {
      seqassert(ctx-&gt;find(var) &amp;&amp; ctx-&gt;find(var)-&gt;getVar(), "cannot find global '{}'",
                var);
      v = ctx-&gt;find(var)-&gt;getVar();
      v-&gt;setSrcInfo(stmt-&gt;getSrcInfo());
      v-&gt;setType(getType((stmt-&gt;rhs ? stmt-&gt;rhs : stmt-&gt;lhs)-&gt;getType()));
    } else {
      v = make&lt;ir::Var&gt;(stmt, getType((stmt-&gt;rhs ? stmt-&gt;rhs : stmt-&gt;lhs)-&gt;getType()),
                        false, false, var);
      ctx-&gt;getBase()-&gt;push_back(v);
      ctx-&gt;add(TranslateItem::Var, var, v);
    }
    // Check if it is a C variable
    if (stmt-&gt;lhs-&gt;hasAttr(ExprAttr::ExternVar)) {
      v-&gt;setExternal();
      v-&gt;setName(ctx-&gt;cache-&gt;rev(var));
      v-&gt;setGlobal();
      return;
    }

    if (stmt-&gt;rhs)
      result = make&lt;ir::AssignInstr&gt;(stmt, v, transform(stmt-&gt;rhs));
  }
}

</t>
<t tx="ekr.20230509083243.861">void TranslateVisitor::visit(AssignMemberStmt *stmt) {
  result = make&lt;ir::InsertInstr&gt;(stmt, transform(stmt-&gt;lhs), stmt-&gt;member,
                                 transform(stmt-&gt;rhs));
}

</t>
<t tx="ekr.20230509083243.862">void TranslateVisitor::visit(ReturnStmt *stmt) {
  result = make&lt;ir::ReturnInstr&gt;(stmt, stmt-&gt;expr ? transform(stmt-&gt;expr) : nullptr);
}

</t>
<t tx="ekr.20230509083243.863">void TranslateVisitor::visit(YieldStmt *stmt) {
  result = make&lt;ir::YieldInstr&gt;(stmt, stmt-&gt;expr ? transform(stmt-&gt;expr) : nullptr);
  ctx-&gt;getBase()-&gt;setGenerator();
}

</t>
<t tx="ekr.20230509083243.864">void TranslateVisitor::visit(WhileStmt *stmt) {
  auto loop = make&lt;ir::WhileFlow&gt;(stmt, transform(stmt-&gt;cond),
                                  make&lt;ir::SeriesFlow&gt;(stmt, "body"));
  ctx-&gt;addSeries(cast&lt;ir::SeriesFlow&gt;(loop-&gt;getBody()));
  transform(stmt-&gt;suite);
  ctx-&gt;popSeries();
  result = loop;
}

</t>
<t tx="ekr.20230509083243.865">void TranslateVisitor::visit(ForStmt *stmt) {
  @others
</t>
<t tx="ekr.20230509083243.866">std::unique_ptr&lt;OMPSched&gt; os = nullptr;
if (stmt-&gt;decorator) {
  os = std::make_unique&lt;OMPSched&gt;();
  auto c = stmt-&gt;decorator-&gt;getCall();
  seqassert(c, "for par is not a call: {}", stmt-&gt;decorator);
  auto fc = c-&gt;expr-&gt;getType()-&gt;getFunc();
  seqassert(fc &amp;&amp; fc-&gt;ast-&gt;name == "std.openmp.for_par:0",
            "for par is not a function");
  auto schedule =
      fc-&gt;funcGenerics[0].type-&gt;getStatic()-&gt;expr-&gt;staticValue.getString();
  bool ordered = fc-&gt;funcGenerics[1].type-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt();
  auto threads = transform(c-&gt;args[0].value);
  auto chunk = transform(c-&gt;args[1].value);
@others
ctx-&gt;getBase()-&gt;push_back(var);
auto bodySeries = make&lt;ir::SeriesFlow&gt;(stmt, "body");

auto loop = make&lt;ir::ForFlow&gt;(stmt, transform(stmt-&gt;iter), bodySeries, var);
if (os)
  loop-&gt;setSchedule(std::move(os));
ctx-&gt;add(TranslateItem::Var, varName, var);
ctx-&gt;addSeries(cast&lt;ir::SeriesFlow&gt;(loop-&gt;getBody()));
transform(stmt-&gt;suite);
ctx-&gt;popSeries();
result = loop;
}

</t>
<t tx="ekr.20230509083243.867">  int64_t collapse =
      fc-&gt;funcGenerics[2].type-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt();
  bool gpu = fc-&gt;funcGenerics[3].type-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt();
  os = std::make_unique&lt;OMPSched&gt;(schedule, threads, chunk, ordered, collapse, gpu);
}

seqassert(stmt-&gt;var-&gt;getId(), "expected IdExpr, got {}", stmt-&gt;var);
auto varName = stmt-&gt;var-&gt;getId()-&gt;value;
ir::Var *var = nullptr;
if (!ctx-&gt;find(varName) || !stmt-&gt;var-&gt;hasAttr(ExprAttr::Dominated)) {
  var = make&lt;ir::Var&gt;(stmt, getType(stmt-&gt;var-&gt;getType()), false, false, varName);
} else {
  var = ctx-&gt;find(varName)-&gt;getVar();
}
</t>
<t tx="ekr.20230509083243.868">void TranslateVisitor::visit(IfStmt *stmt) {
  auto cond = transform(stmt-&gt;cond);
  auto trueSeries = make&lt;ir::SeriesFlow&gt;(stmt, "ifstmt_true");
  ctx-&gt;addSeries(trueSeries);
  transform(stmt-&gt;ifSuite);
  ctx-&gt;popSeries();

  ir::SeriesFlow *falseSeries = nullptr;
  if (stmt-&gt;elseSuite) {
    falseSeries = make&lt;ir::SeriesFlow&gt;(stmt, "ifstmt_false");
    ctx-&gt;addSeries(falseSeries);
    transform(stmt-&gt;elseSuite);
    ctx-&gt;popSeries();
  }
  result = make&lt;ir::IfFlow&gt;(stmt, cond, trueSeries, falseSeries);
}

</t>
<t tx="ekr.20230509083243.869">void TranslateVisitor::visit(TryStmt *stmt) {
  auto *bodySeries = make&lt;ir::SeriesFlow&gt;(stmt, "body");
  ctx-&gt;addSeries(bodySeries);
  transform(stmt-&gt;suite);
  ctx-&gt;popSeries();

  auto finallySeries = make&lt;ir::SeriesFlow&gt;(stmt, "finally");
  if (stmt-&gt;finally) {
    ctx-&gt;addSeries(finallySeries);
    transform(stmt-&gt;finally);
    ctx-&gt;popSeries();
  }

  auto *tc = make&lt;ir::TryCatchFlow&gt;(stmt, bodySeries, finallySeries);
  for (auto &amp;c : stmt-&gt;catches) {
    auto *catchBody = make&lt;ir::SeriesFlow&gt;(stmt, "catch");
    auto *excType = c.exc ? getType(c.exc-&gt;getType()) : nullptr;
    ir::Var *catchVar = nullptr;
    if (!c.var.empty()) {
      if (!ctx-&gt;find(c.var) || !c.exc-&gt;hasAttr(ExprAttr::Dominated)) {
        catchVar = make&lt;ir::Var&gt;(stmt, excType, false, false, c.var);
      } else {
        catchVar = ctx-&gt;find(c.var)-&gt;getVar();
      }
      ctx-&gt;add(TranslateItem::Var, c.var, catchVar);
      ctx-&gt;getBase()-&gt;push_back(catchVar);
    }
    ctx-&gt;addSeries(catchBody);
    transform(c.suite);
    ctx-&gt;popSeries();
    tc-&gt;push_back(ir::TryCatchFlow::Catch(catchBody, excType, catchVar));
  }
  result = tc;
}

</t>
<t tx="ekr.20230509083243.87">  void preHook(Node *node) override {
    for (auto *v : node-&gt;getUsedVariables()) {
      if (!v-&gt;isGlobal())
        locals.push_back(v);
    }
  }
</t>
<t tx="ekr.20230509083243.870">void TranslateVisitor::visit(ThrowStmt *stmt) {
  result = make&lt;ir::ThrowInstr&gt;(stmt, stmt-&gt;expr ? transform(stmt-&gt;expr) : nullptr);
}

</t>
<t tx="ekr.20230509083243.871">void TranslateVisitor::visit(FunctionStmt *stmt) {
  // Process all realizations.
  for (auto &amp;real : ctx-&gt;cache-&gt;functions[stmt-&gt;name].realizations) {
    if (!in(ctx-&gt;cache-&gt;pendingRealizations, make_pair(stmt-&gt;name, real.first)))
      continue;
    ctx-&gt;cache-&gt;pendingRealizations.erase(make_pair(stmt-&gt;name, real.first));

    LOG_TYPECHECK("[translate] generating fn {}", real.first);
    real.second-&gt;ir-&gt;setSrcInfo(getSrcInfo());
    const auto &amp;ast = real.second-&gt;ast;
    seqassert(ast, "AST not set for {}", real.first);
    if (!stmt-&gt;attributes.has(Attr::LLVM))
      transformFunction(real.second-&gt;type.get(), ast.get(), real.second-&gt;ir);
    else
      transformLLVMFunction(real.second-&gt;type.get(), ast.get(), real.second-&gt;ir);
  }
}

</t>
<t tx="ekr.20230509083243.872">void TranslateVisitor::visit(ClassStmt *stmt) {
  // Nothing to see here, as all type handles are already generated.
  // Methods will be handled by FunctionStmt visitor.
}

</t>
<t tx="ekr.20230509083243.873">/************************************************************************************/

codon::ir::types::Type *TranslateVisitor::getType(const types::TypePtr &amp;t) {
  seqassert(t &amp;&amp; t-&gt;getClass(), "{} is not a class", t);
  std::string name = t-&gt;getClass()-&gt;realizedTypeName();
  auto i = ctx-&gt;find(name);
  seqassert(i, "type {} not realized", t);
  return i-&gt;getType();
}

</t>
<t tx="ekr.20230509083243.874">void TranslateVisitor::transformFunction(types::FuncType *type, FunctionStmt *ast,
                                         ir::Func *func) {
  std::vector&lt;std::string&gt; names;
  std::vector&lt;int&gt; indices;
  for (int i = 0, j = 0; i &lt; ast-&gt;args.size(); i++)
    if (ast-&gt;args[i].status == Param::Normal) {
      if (!type-&gt;getArgTypes()[j]-&gt;getFunc()) {
        names.push_back(ctx-&gt;cache-&gt;reverseIdentifierLookup[ast-&gt;args[i].name]);
        indices.push_back(i);
      }
      j++;
    }
  if (ast-&gt;hasAttr(Attr::CVarArg)) {
    names.pop_back();
    indices.pop_back();
  }
  // TODO: refactor IR attribute API
  std::map&lt;std::string, std::string&gt; attr;
  attr[".module"] = ast-&gt;attributes.module;
  for (auto &amp;a : ast-&gt;attributes.customAttr) {
    attr[a] = "";
  }
  func-&gt;setAttribute(std::make_unique&lt;ir::KeyValueAttribute&gt;(attr));
  for (int i = 0; i &lt; names.size(); i++)
    func-&gt;getArgVar(names[i])-&gt;setSrcInfo(ast-&gt;args[indices[i]].getSrcInfo());
  // func-&gt;setUnmangledName(ctx-&gt;cache-&gt;reverseIdentifierLookup[type-&gt;ast-&gt;name]);
  if (!ast-&gt;attributes.has(Attr::C) &amp;&amp; !ast-&gt;attributes.has(Attr::Internal)) {
    ctx-&gt;addBlock();
    for (auto i = 0; i &lt; names.size(); i++)
      ctx-&gt;add(TranslateItem::Var, ast-&gt;args[indices[i]].name,
               func-&gt;getArgVar(names[i]));
    auto body = make&lt;ir::SeriesFlow&gt;(ast, "body");
    ctx-&gt;bases.push_back(cast&lt;ir::BodiedFunc&gt;(func));
    ctx-&gt;addSeries(body);
    transform(ast-&gt;suite);
    ctx-&gt;popSeries();
    ctx-&gt;bases.pop_back();
    cast&lt;ir::BodiedFunc&gt;(func)-&gt;setBody(body);
    ctx-&gt;popBlock();
  }
}

</t>
<t tx="ekr.20230509083243.875">void TranslateVisitor::transformLLVMFunction(types::FuncType *type, FunctionStmt *ast,
                                             ir::Func *func) {
  std::vector&lt;std::string&gt; names;
  std::vector&lt;int&gt; indices;
  for (int i = 0, j = 1; i &lt; ast-&gt;args.size(); i++)
    if (ast-&gt;args[i].status == Param::Normal) {
      names.push_back(ctx-&gt;cache-&gt;reverseIdentifierLookup[ast-&gt;args[i].name]);
      indices.push_back(i);
      j++;
    }
  auto f = cast&lt;ir::LLVMFunc&gt;(func);
  // TODO: refactor IR attribute API
  std::map&lt;std::string, std::string&gt; attr;
  attr[".module"] = ast-&gt;attributes.module;
  for (auto &amp;a : ast-&gt;attributes.customAttr)
    attr[a] = "";
  func-&gt;setAttribute(std::make_unique&lt;ir::KeyValueAttribute&gt;(attr));
  for (int i = 0; i &lt; names.size(); i++)
    func-&gt;getArgVar(names[i])-&gt;setSrcInfo(ast-&gt;args[indices[i]].getSrcInfo());

  seqassert(ast-&gt;suite-&gt;firstInBlock() &amp;&amp; ast-&gt;suite-&gt;firstInBlock()-&gt;getExpr() &amp;&amp;
                ast-&gt;suite-&gt;firstInBlock()-&gt;getExpr()-&gt;expr-&gt;getString(),
            "LLVM function does not begin with a string");
  std::istringstream sin(
      ast-&gt;suite-&gt;firstInBlock()-&gt;getExpr()-&gt;expr-&gt;getString()-&gt;getValue());
  std::vector&lt;ir::types::Generic&gt; literals;
  auto &amp;ss = ast-&gt;suite-&gt;getSuite()-&gt;stmts;
  for (int i = 1; i &lt; ss.size(); i++) {
    if (auto *ei = ss[i]-&gt;getExpr()-&gt;expr-&gt;getInt()) { // static integer expression
      literals.emplace_back(*(ei-&gt;intValue));
    } else if (auto *es = ss[i]-&gt;getExpr()-&gt;expr-&gt;getString()) { // static string
      literals.emplace_back(es-&gt;getValue());
    } else {
      seqassert(ss[i]-&gt;getExpr()-&gt;expr-&gt;getType(), "invalid LLVM type argument: {}",
                ss[i]-&gt;getExpr()-&gt;toString());
      literals.emplace_back(getType(ss[i]-&gt;getExpr()-&gt;expr-&gt;getType()));
    }
  }
  bool isDeclare = true;
  std::string declare;
  std::vector&lt;std::string&gt; lines;
  for (std::string l; getline(sin, l);) {
    std::string lp = l;
    ltrim(lp);
    rtrim(lp);
    // Extract declares and constants.
    if (isDeclare &amp;&amp; !startswith(lp, "declare ")) {
      bool isConst = lp.find("private constant") != std::string::npos;
      if (!isConst) {
        isDeclare = false;
        if (!lp.empty() &amp;&amp; lp.back() != ':')
          lines.emplace_back("entry:");
      }
    }
    if (isDeclare)
      declare += lp + "\n";
    else
      lines.emplace_back(l);
  }
  f-&gt;setLLVMBody(join(lines, "\n"));
  f-&gt;setLLVMDeclarations(declare);
  f-&gt;setLLVMLiterals(literals);
  // func-&gt;setUnmangledName(ctx-&gt;cache-&gt;reverseIdentifierLookup[type-&gt;ast-&gt;name]);
}

</t>
<t tx="ekr.20230509083243.876">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/translate/translate_ctx.h"
#include "codon/parser/visitors/visitor.h"

namespace codon::ast {

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.877">class TranslateVisitor : public CallbackASTVisitor&lt;ir::Value *, ir::Value *&gt; {
  std::shared_ptr&lt;TranslateContext&gt; ctx;
  ir::Value *result;

public:
  explicit TranslateVisitor(std::shared_ptr&lt;TranslateContext&gt; ctx);
  static codon::ir::Func *apply(Cache *cache, const StmtPtr &amp;stmts);

  ir::Value *transform(const ExprPtr &amp;expr) override;
  ir::Value *transform(const StmtPtr &amp;stmt) override;

private:
  void defaultVisit(Expr *expr) override;
  void defaultVisit(Stmt *expr) override;

public:
  void visit(NoneExpr *) override;
  void visit(BoolExpr *) override;
  void visit(IntExpr *) override;
  void visit(FloatExpr *) override;
  void visit(StringExpr *) override;
  void visit(IdExpr *) override;
  void visit(IfExpr *) override;
  void visit(CallExpr *) override;
  void visit(DotExpr *) override;
  void visit(YieldExpr *) override;
  void visit(StmtExpr *) override;
  void visit(PipeExpr *) override;

  void visit(SuiteStmt *) override;
  void visit(BreakStmt *) override;
  void visit(ContinueStmt *) override;
  void visit(ExprStmt *) override;
  void visit(AssignStmt *) override;
  void visit(AssignMemberStmt *) override;
  void visit(ReturnStmt *) override;
  void visit(YieldStmt *) override;
  void visit(WhileStmt *) override;
  void visit(ForStmt *) override;
  void visit(IfStmt *) override;
  void visit(TryStmt *) override;
  void visit(ThrowStmt *) override;
  void visit(FunctionStmt *) override;
  void visit(ClassStmt *) override;
  @others
};

</t>
<t tx="ekr.20230509083243.878">void visit(CommentStmt *) override {}

private:
ir::types::Type *getType(const types::TypePtr &amp;t);

void transformFunction(types::FuncType *type, FunctionStmt *ast, ir::Func *func);
void transformLLVMFunction(types::FuncType *type, FunctionStmt *ast, ir::Func *func);

template &lt;typename ValueType, typename... Args&gt; ValueType *make(Args &amp;&amp;...args) {
  auto *ret = ctx-&gt;getModule()-&gt;N&lt;ValueType&gt;(std::forward&lt;Args&gt;(args)...);
  return ret;
}
</t>
<t tx="ekr.20230509083243.879">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "translate_ctx.h"

#include &lt;memory&gt;
#include &lt;vector&gt;

#include "codon/parser/common.h"
#include "codon/parser/ctx.h"
#include "codon/parser/visitors/translate/translate.h"
#include "codon/parser/visitors/typecheck/ctx.h"

namespace codon::ast {

TranslateContext::TranslateContext(Cache *cache)
    : Context&lt;TranslateItem&gt;(""), cache(cache) {}

std::shared_ptr&lt;TranslateItem&gt; TranslateContext::find(const std::string &amp;name) const {
  if (auto t = Context&lt;TranslateItem&gt;::find(name))
    return t;
  std::shared_ptr&lt;TranslateItem&gt; ret = nullptr;
  auto tt = cache-&gt;typeCtx-&gt;find(name);
  if (tt &amp;&amp; tt-&gt;isType() &amp;&amp; tt-&gt;type-&gt;canRealize()) {
    ret = std::make_shared&lt;TranslateItem&gt;(TranslateItem::Type, bases[0]);
    seqassertn(in(cache-&gt;classes, tt-&gt;type-&gt;getClass()-&gt;name) &amp;&amp;
                   in(cache-&gt;classes[tt-&gt;type-&gt;getClass()-&gt;name].realizations, name),
               "cannot find type realization {}", name);
    ret-&gt;handle.type =
        cache-&gt;classes[tt-&gt;type-&gt;getClass()-&gt;name].realizations[name]-&gt;ir;
  } else if (tt &amp;&amp; tt-&gt;type-&gt;getFunc() &amp;&amp; tt-&gt;type-&gt;canRealize()) {
    ret = std::make_shared&lt;TranslateItem&gt;(TranslateItem::Func, bases[0]);
    seqassertn(
        in(cache-&gt;functions, tt-&gt;type-&gt;getFunc()-&gt;ast-&gt;name) &amp;&amp;
            in(cache-&gt;functions[tt-&gt;type-&gt;getFunc()-&gt;ast-&gt;name].realizations, name),
        "cannot find type realization {}", name);
    ret-&gt;handle.func =
        cache-&gt;functions[tt-&gt;type-&gt;getFunc()-&gt;ast-&gt;name].realizations[name]-&gt;ir;
  }
  return ret;
}

std::shared_ptr&lt;TranslateItem&gt;
TranslateContext::forceFind(const std::string &amp;name) const {
  auto i = find(name);
  seqassertn(i, "cannot find '{}'", name);
  return i;
}

std::shared_ptr&lt;TranslateItem&gt;
TranslateContext::add(TranslateItem::Kind kind, const std::string &amp;name, void *type) {
  auto it = std::make_shared&lt;TranslateItem&gt;(kind, getBase());
  if (kind == TranslateItem::Var)
    it-&gt;handle.var = (ir::Var *)type;
  else if (kind == TranslateItem::Func)
    it-&gt;handle.func = (ir::Func *)type;
  else
    it-&gt;handle.type = (ir::types::Type *)type;
  add(name, it);
  return it;
}

void TranslateContext::addSeries(codon::ir::SeriesFlow *s) { series.push_back(s); }
void TranslateContext::popSeries() { series.pop_back(); }

codon::ir::Module *TranslateContext::getModule() const {
  return dynamic_cast&lt;codon::ir::Module *&gt;(bases[0]-&gt;getModule());
}
codon::ir::BodiedFunc *TranslateContext::getBase() const { return bases.back(); }
codon::ir::SeriesFlow *TranslateContext::getSeries() const { return series.back(); }

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.88">};
} // namespace

Value *CloneVisitor::clone(const Value *other, BodiedFunc *cloneTo,
</t>
<t tx="ekr.20230509083243.880">@path C:/Repos/codon/codon/parser/visitors/translate/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

#include "codon/cir/cir.h"
#include "codon/cir/types/types.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * IR context object description.
 * This represents an identifier that can be either a function, a class (type), or a
 * variable.
 */
struct TranslateItem {
  enum Kind { Func, Type, Var } kind;
  /// IR handle.
  union {
    codon::ir::Var *var;
    codon::ir::Func *func;
    codon::ir::types::Type *type;
  } handle;
  /// Base function pointer.
  codon::ir::BodiedFunc *base;

  TranslateItem(Kind k, codon::ir::BodiedFunc *base)
      : kind(k), handle{nullptr}, base(base) {}
  const codon::ir::BodiedFunc *getBase() const { return base; }
  codon::ir::Func *getFunc() const { return kind == Func ? handle.func : nullptr; }
  codon::ir::types::Type *getType() const {
    return kind == Type ? handle.type : nullptr;
  }
  codon::ir::Var *getVar() const { return kind == Var ? handle.var : nullptr; }
};

/**
 * A variable table (context) for the IR translation stage.
 */
struct TranslateContext : public Context&lt;TranslateItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;
  /// Stack of function bases.
  std::vector&lt;codon::ir::BodiedFunc *&gt; bases;
  /// Stack of IR series (blocks).
  std::vector&lt;codon::ir::SeriesFlow *&gt; series;
  /// Stack of sequence items for attribute initialization.
  std::vector&lt;std::vector&lt;std::pair&lt;ExprAttr, ir::Value *&gt;&gt;&gt; seqItems;

public:
  TranslateContext(Cache *cache);

  using Context&lt;TranslateItem&gt;::add;
  /// Convenience method for adding an object to the context.
  std::shared_ptr&lt;TranslateItem&gt; add(TranslateItem::Kind kind, const std::string &amp;name,
                                     void *type);
  std::shared_ptr&lt;TranslateItem&gt; find(const std::string &amp;name) const override;
  std::shared_ptr&lt;TranslateItem&gt; forceFind(const std::string &amp;name) const;

  /// Convenience method for adding a series.
  void addSeries(codon::ir::SeriesFlow *s);
  void popSeries();

public:
  codon::ir::Module *getModule() const;
  codon::ir::BodiedFunc *getBase() const;
  codon::ir::SeriesFlow *getSeries() const;
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.881"></t>
<t tx="ekr.20230509083243.882">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

@others
    methodArgs = std::make_unique&lt;std::vector&lt;CallExpr::Arg&gt;&gt;();
    for (auto &amp;a : *args)
      methodArgs-&gt;push_back(a);
  } else {
    // Partially deduced type thus far
    auto typeSoFar = expr-&gt;getType() ? expr-&gt;getType()-&gt;getClass() : nullptr;
    if (typeSoFar &amp;&amp; typeSoFar-&gt;getFunc()) {
      // Case: arguments available from the previous type checking round
      methodArgs = std::make_unique&lt;std::vector&lt;CallExpr::Arg&gt;&gt;();
      if (expr-&gt;getDot() &amp;&amp; !expr-&gt;getDot()-&gt;expr-&gt;isType()) { // Add `self`
        auto n = N&lt;NoneExpr&gt;();
        n-&gt;setType(expr-&gt;getDot()-&gt;expr-&gt;type);
        methodArgs-&gt;push_back({"", n});
      }
      for (auto &amp;a : typeSoFar-&gt;getFunc()-&gt;getArgTypes()) {
        auto n = N&lt;NoneExpr&gt;();
        n-&gt;setType(a);
        methodArgs-&gt;push_back({"", n});
      }
    }
  }

  if (methodArgs) {
    FuncTypePtr bestMethod = nullptr;
    // Use the provided arguments to select the best method
    if (auto dot = expr-&gt;getDot()) {
      // Case: method overloads (DotExpr)
      auto methods =
          ctx-&gt;findMethod(dot-&gt;expr-&gt;type-&gt;getClass()-&gt;name, dot-&gt;member, false);
      auto m = findMatchingMethods(dot-&gt;expr-&gt;type-&gt;getClass(), methods, *methodArgs);
      bestMethod = m.empty() ? nullptr : m[0];
    } else if (auto id = expr-&gt;getId()) {
      // Case: function overloads (IdExpr)
      std::vector&lt;types::FuncTypePtr&gt; methods;
      for (auto &amp;m : ctx-&gt;cache-&gt;overloads[id-&gt;value])
        if (!endswith(m.name, ":dispatch"))
          methods.push_back(ctx-&gt;cache-&gt;functions[m.name].type);
      std::reverse(methods.begin(), methods.end());
      auto m = findMatchingMethods(nullptr, methods, *methodArgs);
      bestMethod = m.empty() ? nullptr : m[0];
    }
    if (bestMethod)
      return bestMethod;
  } else {
    // If overload is ambiguous, route through a dispatch function
    std::string name;
    if (auto dot = expr-&gt;getDot()) {
      name = ctx-&gt;cache-&gt;getMethod(dot-&gt;expr-&gt;type-&gt;getClass(), dot-&gt;member);
    } else {
      name = expr-&gt;getId()-&gt;value;
    }
    return getDispatch(name);
  }

  // Print a nice error message
  std::string argsNice;
  if (methodArgs) {
    std::vector&lt;std::string&gt; a;
    for (auto &amp;t : *methodArgs)
      a.emplace_back(fmt::format("{}", t.value-&gt;type-&gt;prettyString()));
    argsNice = fmt::format("({})", fmt::join(a, ", "));
  }

  if (auto dot = expr-&gt;getDot()) {
    E(Error::DOT_NO_ATTR_ARGS, expr, dot-&gt;expr-&gt;type-&gt;prettyString(), dot-&gt;member,
      argsNice);
  } else {
    E(Error::FN_NO_ATTR_ARGS, expr, ctx-&gt;cache-&gt;rev(expr-&gt;getId()-&gt;value), argsNice);
  }

  return nullptr;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.883">/// Typecheck identifiers. If an identifier is a static variable, evaluate it and
/// replace it with its value (e.g., a @c IntExpr ). Also ensure that the identifier of
/// a generic function or a type is fully qualified (e.g., replace `Ptr` with
/// `Ptr[byte]`).
/// For tuple identifiers, generate appropriate class. See @c generateTuple for
/// details.
void TypecheckVisitor::visit(IdExpr *expr) {
  // Generate tuple stubs if needed
  if (isTuple(expr-&gt;value))
    generateTuple(std::stoi(expr-&gt;value.substr(sizeof(TYPE_TUPLE) - 1)));

  // Replace identifiers that have been superseded by domination analysis during the
  // simplification
  while (auto s = in(ctx-&gt;cache-&gt;replacements, expr-&gt;value))
    expr-&gt;value = s-&gt;first;

  auto val = ctx-&gt;find(expr-&gt;value);
  if (!val) {
    // Handle overloads
    if (in(ctx-&gt;cache-&gt;overloads, expr-&gt;value))
      val = ctx-&gt;forceFind(getDispatch(expr-&gt;value)-&gt;ast-&gt;name);
    seqassert(val, "cannot find '{}'", expr-&gt;value);
  }
  unify(expr-&gt;type, ctx-&gt;instantiate(val-&gt;type));

  if (val-&gt;type-&gt;isStaticType()) {
    // Evaluate static expression if possible
    expr-&gt;staticValue.type = StaticValue::Type(val-&gt;type-&gt;isStaticType());
    auto s = val-&gt;type-&gt;getStatic();
    seqassert(!expr-&gt;staticValue.evaluated, "expected unevaluated expression: {}",
              expr-&gt;toString());
    if (s &amp;&amp; s-&gt;expr-&gt;staticValue.evaluated) {
      // Replace the identifier with static expression
      if (s-&gt;expr-&gt;staticValue.type == StaticValue::STRING)
        resultExpr = transform(N&lt;StringExpr&gt;(s-&gt;expr-&gt;staticValue.getString()));
      else
        resultExpr = transform(N&lt;IntExpr&gt;(s-&gt;expr-&gt;staticValue.getInt()));
    }
    return;
  }

  if (val-&gt;isType())
    expr-&gt;markType();

  // Realize a type or a function if possible and replace the identifier with the fully
  // typed identifier (e.g., `foo` -&gt; `foo[int]`)
  if (realize(expr-&gt;type)) {
    if (!val-&gt;isVar())
      expr-&gt;value = expr-&gt;type-&gt;realizedName();
    expr-&gt;setDone();
  }
}

</t>
<t tx="ekr.20230509083243.884">/// See @c transformDot for details.
void TypecheckVisitor::visit(DotExpr *expr) {
  // Make sure to unify the current type with the transformed type
  if ((resultExpr = transformDot(expr)))
    unify(expr-&gt;type, resultExpr-&gt;type);
  if (!expr-&gt;type)
    unify(expr-&gt;type, ctx-&gt;getUnbound());
}

</t>
<t tx="ekr.20230509083243.885">/// Find an overload dispatch function for a given overload. If it does not exist and
/// there is more than one overload, generate it. Dispatch functions ensure that a
/// function call is being routed to the correct overload even when dealing with partial
/// functions and decorators.
/// @example This is how dispatch looks like:
///   ```def foo:dispatch(*args, **kwargs):
///        return foo(*args, **kwargs)```
types::FuncTypePtr TypecheckVisitor::getDispatch(const std::string &amp;fn) {
  auto &amp;overloads = ctx-&gt;cache-&gt;overloads[fn];

  // Single overload: just return it
  if (overloads.size() == 1)
    return ctx-&gt;forceFind(overloads.front().name)-&gt;type-&gt;getFunc();

  // Check if dispatch exists
  for (auto &amp;m : overloads)
    if (endswith(ctx-&gt;cache-&gt;functions[m.name].ast-&gt;name, ":dispatch"))
      return ctx-&gt;cache-&gt;functions[m.name].type;

  // Dispatch does not exist. Generate it
  auto name = fn + ":dispatch";
  ExprPtr root; // Root function name used for calling
  auto a = ctx-&gt;cache-&gt;functions[overloads[0].name].ast;
  if (!a-&gt;attributes.parentClass.empty())
    root = N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(a-&gt;attributes.parentClass),
                      ctx-&gt;cache-&gt;reverseIdentifierLookup[fn]);
  else
    root = N&lt;IdExpr&gt;(fn);
  root = N&lt;CallExpr&gt;(root, N&lt;StarExpr&gt;(N&lt;IdExpr&gt;("args")),
                     N&lt;KeywordStarExpr&gt;(N&lt;IdExpr&gt;("kwargs")));
  auto ast = N&lt;FunctionStmt&gt;(
      name, nullptr, std::vector&lt;Param&gt;{Param("*args"), Param("**kwargs")},
      N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(root)), Attr({"autogenerated"}));
  ctx-&gt;cache-&gt;reverseIdentifierLookup[name] = ctx-&gt;cache-&gt;reverseIdentifierLookup[fn];

  auto baseType = getFuncTypeBase(2);
  auto typ = std::make_shared&lt;FuncType&gt;(baseType, ast.get());
  typ = std::static_pointer_cast&lt;FuncType&gt;(typ-&gt;generalize(ctx-&gt;typecheckLevel - 1));
  ctx-&gt;add(TypecheckItem::Func, name, typ);

  overloads.insert(overloads.begin(), {name, 0});
  ctx-&gt;cache-&gt;functions[name].ast = ast;
  ctx-&gt;cache-&gt;functions[name].type = typ;
  prependStmts-&gt;push_back(ast);
  return typ;
}

/// Transform a dot expression. Select the best method overload if possible.
/// @param args (optional) list of class method arguments used to select the best
///             overload. nullptr if not available.
/// @example
///   `obj.__class__`   -&gt; `type(obj)`
///   `cls.__name__`    -&gt; `"class"` (same for functions)
///   `obj.method`      -&gt; `cls.method(obj, ...)` or
///                        `cls.method(obj)` if method has `@property` attribute
///   @c getClassMember examples:
///   `obj.GENERIC`     -&gt; `GENERIC` (IdExpr with generic/static value)
///   `optional.member` -&gt; `unwrap(optional).member`
///   `pyobj.member`    -&gt; `pyobj._getattr("member")`
/// @return nullptr if no transformation was made
/// See @c getClassMember and @c getBestOverload
ExprPtr TypecheckVisitor::transformDot(DotExpr *expr,
                                       std::vector&lt;CallExpr::Arg&gt; *args) {
  // Special case: obj.__class__
  if (expr-&gt;member == "__class__") {
    /// TODO: prevent cls.__class__ and type(cls)
    return transformType(NT&lt;CallExpr&gt;(NT&lt;IdExpr&gt;("type"), expr-&gt;expr));
  }

  transform(expr-&gt;expr);

  // Special case: fn.__name__
  // Should go before cls.__name__ to allow printing generic functions
  if (expr-&gt;expr-&gt;type-&gt;getFunc() &amp;&amp; expr-&gt;member == "__name__") {
    return transform(N&lt;StringExpr&gt;(expr-&gt;expr-&gt;type-&gt;prettyString()));
  }
  // Special case: fn.__llvm_name__ or obj.__llvm_name__
  if (expr-&gt;member == "__llvm_name__") {
    if (realize(expr-&gt;expr-&gt;type))
      return transform(N&lt;StringExpr&gt;(expr-&gt;expr-&gt;type-&gt;realizedName()));
    return nullptr;
  }
  // Special case: cls.__name__
  if (expr-&gt;expr-&gt;isType() &amp;&amp; expr-&gt;member == "__name__") {
    if (realize(expr-&gt;expr-&gt;type))
      return transform(N&lt;StringExpr&gt;(expr-&gt;expr-&gt;type-&gt;prettyString()));
    return nullptr;
  }
  // Special case: expr.__is_static__
  if (expr-&gt;member == "__is_static__") {
    if (expr-&gt;expr-&gt;isDone())
      return transform(N&lt;BoolExpr&gt;(expr-&gt;expr-&gt;isStatic()));
    return nullptr;
  }
  // Special case: cls.__vtable_id__
  if (expr-&gt;expr-&gt;isType() &amp;&amp; expr-&gt;member == "__vtable_id__") {
    if (auto c = realize(expr-&gt;expr-&gt;type))
      return transform(N&lt;IntExpr&gt;(ctx-&gt;cache-&gt;classes[c-&gt;getClass()-&gt;name]
                                      .realizations[c-&gt;getClass()-&gt;realizedTypeName()]
                                      -&gt;id));
    return nullptr;
  }

  // Ensure that the type is known (otherwise wait until it becomes known)
  auto typ = expr-&gt;expr-&gt;getType()-&gt;getClass();
  if (!typ)
    return nullptr;

  // Check if this is a method or member access
  if (ctx-&gt;findMethod(typ-&gt;name, expr-&gt;member).empty())
    return getClassMember(expr, args);
  auto bestMethod = getBestOverload(expr, args);

  if (args) {
    unify(expr-&gt;type, ctx-&gt;instantiate(bestMethod, typ));

    // Handle virtual calls
    auto vtableName = format("{}.{}", VAR_VTABLE, typ-&gt;name);
    // A function is deemed virtual if it is marked as such and if a base class has a
    // vtable
    bool isVirtual = in(ctx-&gt;cache-&gt;classes[typ-&gt;name].virtuals, expr-&gt;member);
    isVirtual &amp;= ctx-&gt;findMember(typ-&gt;name, vtableName) != nullptr;
    isVirtual &amp;= !expr-&gt;expr-&gt;isType();
    if (isVirtual &amp;&amp; !bestMethod-&gt;ast-&gt;attributes.has(Attr::StaticMethod) &amp;&amp;
        !bestMethod-&gt;ast-&gt;attributes.has(Attr::Property)) {
      // Special case: route the call through a vtable
      if (realize(expr-&gt;type)) {
        auto fn = expr-&gt;type-&gt;getFunc();
        auto vid = getRealizationID(typ.get(), fn.get());

        // Function[Tuple[TArg1, TArg2, ...], TRet]
        std::vector&lt;ExprPtr&gt; ids;
        for (auto &amp;t : fn-&gt;getArgTypes())
          ids.push_back(NT&lt;IdExpr&gt;(t-&gt;realizedName()));
        auto name = generateTuple(ids.size());
</t>
<t tx="ekr.20230509083243.886">        auto fnType = NT&lt;InstantiateExpr&gt;(
            NT&lt;IdExpr&gt;("Function"),
            std::vector&lt;ExprPtr&gt;{NT&lt;InstantiateExpr&gt;(NT&lt;IdExpr&gt;(name), ids),
                                 NT&lt;IdExpr&gt;(fn-&gt;getRetType()-&gt;realizedName())});
</t>
<t tx="ekr.20230509083243.887">        // Function[Tuple[TArg1, TArg2, ...], TRet](expr.__vtable__T[VIRTUAL_ID])
        auto e = N&lt;CallExpr&gt;(
            fnType, N&lt;IndexExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, vtableName), N&lt;IntExpr&gt;(vid)));
        return transform(e);
      }
    }
  }

  // Check if a method is a static or an instance method and transform accordingly
  if (expr-&gt;expr-&gt;isType() || args) {
    // Static access: `cls.method`
    ExprPtr e = N&lt;IdExpr&gt;(bestMethod-&gt;ast-&gt;name);
    unify(e-&gt;type, unify(expr-&gt;type, ctx-&gt;instantiate(bestMethod, typ)));
    return transform(e); // Realize if needed
  } else {
    // Instance access: `obj.method`
    // Transform y.method to a partial call `type(obj).method(args, ...)`
    std::vector&lt;ExprPtr&gt; methodArgs;
    // Do not add self if a method is marked with @staticmethod
    if (!bestMethod-&gt;ast-&gt;attributes.has(Attr::StaticMethod))
      methodArgs.push_back(expr-&gt;expr);
    // If a method is marked with @property, just call it directly
    if (!bestMethod-&gt;ast-&gt;attributes.has(Attr::Property))
      methodArgs.push_back(N&lt;EllipsisExpr&gt;());
    auto e = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(bestMethod-&gt;ast-&gt;name), methodArgs));
    unify(expr-&gt;type, e-&gt;type);
    return e;
  }
</t>
<t tx="ekr.20230509083243.888">}

/// Select the requested class member.
/// @param args (optional) list of class method arguments used to select the best
///             overload if the member is optional. nullptr if not available.
/// @example
///   `obj.GENERIC`     -&gt; `GENERIC` (IdExpr with generic/static value)
///   `optional.member` -&gt; `unwrap(optional).member`
///   `pyobj.member`    -&gt; `pyobj._getattr("member")`
ExprPtr TypecheckVisitor::getClassMember(DotExpr *expr,
                                         std::vector&lt;CallExpr::Arg&gt; *args) {
  auto typ = expr-&gt;expr-&gt;getType()-&gt;getClass();
  seqassert(typ, "not a class");

  // Case: object member access (`obj.member`)
  if (!expr-&gt;expr-&gt;isType()) {
    if (auto member = ctx-&gt;findMember(typ-&gt;name, expr-&gt;member)) {
      unify(expr-&gt;type, ctx-&gt;instantiate(member, typ));
      if (expr-&gt;expr-&gt;isDone() &amp;&amp; realize(expr-&gt;type))
        expr-&gt;setDone();
      return nullptr;
    }
  }

  // Case: class variable (`Cls.var`)
  if (auto cls = in(ctx-&gt;cache-&gt;classes, typ-&gt;name))
    if (auto var = in(cls-&gt;classVars, expr-&gt;member)) {
      return transform(N&lt;IdExpr&gt;(*var));
    }

  // Case: special members
  if (auto mtyp = findSpecialMember(expr-&gt;member)) {
    unify(expr-&gt;type, mtyp);
    if (expr-&gt;expr-&gt;isDone() &amp;&amp; realize(expr-&gt;type))
      expr-&gt;setDone();
    return nullptr;
  }

  // Case: object generic access (`obj.T`)
  TypePtr generic = nullptr;
  for (auto &amp;g : typ-&gt;generics)
    if (ctx-&gt;cache-&gt;reverseIdentifierLookup[g.name] == expr-&gt;member) {
      generic = g.type;
      break;
    }
  if (generic) {
    unify(expr-&gt;type, generic);
    if (!generic-&gt;isStaticType()) {
      expr-&gt;markType();
    } else {
      expr-&gt;staticValue.type = StaticValue::Type(generic-&gt;isStaticType());
    }
    if (realize(expr-&gt;type)) {
      if (!generic-&gt;isStaticType()) {
        return transform(N&lt;IdExpr&gt;(generic-&gt;realizedName()));
      } else if (generic-&gt;getStatic()-&gt;expr-&gt;staticValue.type == StaticValue::STRING) {
        expr-&gt;type = nullptr; // to prevent unify(T, Static[T]) error
        return transform(
            N&lt;StringExpr&gt;(generic-&gt;getStatic()-&gt;expr-&gt;staticValue.getString()));
      } else {
        expr-&gt;type = nullptr; // to prevent unify(T, Static[T]) error
        return transform(N&lt;IntExpr&gt;(generic-&gt;getStatic()-&gt;expr-&gt;staticValue.getInt()));
      }
    }
    return nullptr;
  }

  // Case: transform `optional.member` to `unwrap(optional).member`
  if (typ-&gt;is(TYPE_OPTIONAL)) {
</t>
<t tx="ekr.20230509083243.889">    auto dot = N&lt;DotExpr&gt;(transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), expr-&gt;expr)),
                          expr-&gt;member);
    dot-&gt;setType(ctx-&gt;getUnbound()); // as dot is not transformed
    if (auto d = transformDot(dot.get(), args))
      return d;
    return dot;
  }

  // Case: transform `pyobj.member` to `pyobj._getattr("member")`
  if (typ-&gt;is("pyobj")) {
    return transform(
        N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, "_getattr"), N&lt;StringExpr&gt;(expr-&gt;member)));
  }

</t>
<t tx="ekr.20230509083243.89">                           const std::unordered_map&lt;id_t, Var *&gt; &amp;remaps) {
  if (!other)
    return nullptr;

  if (cloneTo) {
    auto *M = cloneTo-&gt;getModule();
    GatherLocals gl;
    const_cast&lt;Value *&gt;(other)-&gt;accept(gl);
    for (auto *v : gl.locals) {
      auto it = remaps.find(v-&gt;getId());
      if (it != remaps.end()) {
        forceRemap(v, it-&gt;second);
      } else {
        auto *clonedVar =
            M-&gt;N&lt;Var&gt;(v, v-&gt;getType(), v-&gt;isGlobal(), v-&gt;isExternal(), v-&gt;getName());
        cloneTo-&gt;push_back(clonedVar);
        forceRemap(v, clonedVar);
      }
    }
  } else {
    auto *M = other-&gt;getModule();
    for (const auto &amp;e : remaps) {
      forceRemap(M-&gt;getVar(e.first), e.second);
    }
  }

  auto id = other-&gt;getId();
  if (ctx.find(id) == ctx.end()) {
    other-&gt;accept(*this);
    ctx[id] = result;

    for (auto it = other-&gt;attributes_begin(); it != other-&gt;attributes_end(); ++it) {
      const auto *attr = other-&gt;getAttribute(*it);
      if (attr-&gt;needsClone()) {
        ctx[id]-&gt;setAttribute(attr-&gt;clone(*this), *it);
      }
    }
  }
  return cast&lt;Value&gt;(ctx[id]);
}

</t>
<t tx="ekr.20230509083243.890">  // Case: transform `union.m` to `__internal__.get_union_method(union, "m", ...)`
  if (typ-&gt;getUnion()) {
    return transform(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.get_union_method:0"),
                    std::vector&lt;CallExpr::Arg&gt;{{"union", expr-&gt;expr},
                                               {"method", N&lt;StringExpr&gt;(expr-&gt;member)},
                                               {"", N&lt;EllipsisExpr&gt;()}}));
  }

  // For debugging purposes: ctx-&gt;findMethod(typ-&gt;name, expr-&gt;member);
  E(Error::DOT_NO_ATTR, expr, typ-&gt;prettyString(), expr-&gt;member);
  return nullptr;
}

TypePtr TypecheckVisitor::findSpecialMember(const std::string &amp;member) {
  if (member == "__elemsize__")
    return ctx-&gt;getType("int");
  if (member == "__atomic__")
    return ctx-&gt;getType("bool");
  if (member == "__contents_atomic__")
    return ctx-&gt;getType("bool");
  if (member == "__name__")
    return ctx-&gt;getType("str");
  return nullptr;
}

/// Select the best overloaded function or method.
/// @param expr    a DotExpr (for methods) or an IdExpr (for overloaded functions)
/// @param methods List of available methods.
/// @param args    (optional) list of class method arguments used to select the best
///                overload if the member is optional. nullptr if not available.
FuncTypePtr TypecheckVisitor::getBestOverload(Expr *expr,
                                              std::vector&lt;CallExpr::Arg&gt; *args) {
  // Prepare the list of method arguments if possible
  std::unique_ptr&lt;std::vector&lt;CallExpr::Arg&gt;&gt; methodArgs;

  if (args) {
    // Case: method overloads (DotExpr)
    bool addSelf = true;
    if (auto dot = expr-&gt;getDot()) {
</t>
<t tx="ekr.20230509083243.891">      auto methods =
          ctx-&gt;findMethod(dot-&gt;expr-&gt;type-&gt;getClass()-&gt;name, dot-&gt;member, false);
      if (!methods.empty() &amp;&amp; methods.front()-&gt;ast-&gt;attributes.has(Attr::StaticMethod))
        addSelf = false;
    }

    // Case: arguments explicitly provided (by CallExpr)
    if (addSelf &amp;&amp; expr-&gt;getDot() &amp;&amp; !expr-&gt;getDot()-&gt;expr-&gt;isType()) {
      // Add `self` as the first argument
      args-&gt;insert(args-&gt;begin(), {"", expr-&gt;getDot()-&gt;expr});
    }
</t>
<t tx="ekr.20230509083243.892">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

@others
    }
  }

  return {false, nullptr};
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.893">/// Transform assignments. Handle dominated assignments, forward declarations, static
/// assignments and type/function aliases.
/// See @c wrapExpr for more examples.
void TypecheckVisitor::visit(AssignStmt *stmt) {
  // Update statements are handled by @c visitUpdate
  if (stmt-&gt;isUpdate()) {
    transformUpdate(stmt);
    return;
  }

  seqassert(stmt-&gt;lhs-&gt;getId(), "invalid AssignStmt {}", stmt-&gt;lhs);
  std::string lhs = stmt-&gt;lhs-&gt;getId()-&gt;value;

  // Special case: this assignment has been dominated and is not a true assignment but
  //               an update of the dominating binding.
  if (auto changed = in(ctx-&gt;cache-&gt;replacements, lhs)) {
    while (auto s = in(ctx-&gt;cache-&gt;replacements, lhs))
      lhs = changed-&gt;first, changed = s;
    if (stmt-&gt;rhs &amp;&amp; changed-&gt;second) {
      // Mark the dominating binding as used: `var.__used__ = True`
      auto u =
          N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(fmt::format("{}.__used__", lhs)), N&lt;BoolExpr&gt;(true));
      u-&gt;setUpdate();
      prependStmts-&gt;push_back(transform(u));
    } else if (changed-&gt;second &amp;&amp; !stmt-&gt;rhs) {
      // This assignment was a declaration only. Just mark the dominating binding as
      // used: `var.__used__ = True`
      stmt-&gt;lhs = N&lt;IdExpr&gt;(fmt::format("{}.__used__", lhs));
      stmt-&gt;rhs = N&lt;BoolExpr&gt;(true);
    }
    seqassert(stmt-&gt;rhs, "bad domination statement: '{}'", stmt-&gt;toString());
    // Change this to the update and follow the update logic
    stmt-&gt;setUpdate();
    transformUpdate(stmt);
    return;
  }

  transform(stmt-&gt;rhs);
  transformType(stmt-&gt;type);
  if (!stmt-&gt;rhs) {
    // Forward declarations (e.g., dominating bindings, C imports etc.).
    // The type is unknown and will be deduced later
    unify(stmt-&gt;lhs-&gt;type, ctx-&gt;getUnbound(stmt-&gt;lhs-&gt;getSrcInfo()));
    if (stmt-&gt;type) {
      unify(stmt-&gt;lhs-&gt;type,
            ctx-&gt;instantiate(stmt-&gt;type-&gt;getSrcInfo(), stmt-&gt;type-&gt;getType()));
    }
    ctx-&gt;add(TypecheckItem::Var, lhs, stmt-&gt;lhs-&gt;type);
    if (realize(stmt-&gt;lhs-&gt;type))
      stmt-&gt;setDone();
  } else if (stmt-&gt;type &amp;&amp; stmt-&gt;type-&gt;getType()-&gt;isStaticType()) {
    // Static assignments (e.g., `x: Static[int] = 5`)
    if (!stmt-&gt;rhs-&gt;isStatic())
      E(Error::EXPECTED_STATIC, stmt-&gt;rhs);
    seqassert(stmt-&gt;rhs-&gt;staticValue.evaluated, "static not evaluated");
    unify(stmt-&gt;lhs-&gt;type,
          unify(stmt-&gt;type-&gt;type, Type::makeStatic(ctx-&gt;cache, stmt-&gt;rhs)));
    auto val = ctx-&gt;add(TypecheckItem::Var, lhs, stmt-&gt;lhs-&gt;type);
    if (in(ctx-&gt;cache-&gt;globals, lhs)) {
      // Make globals always visible!
      ctx-&gt;addToplevel(lhs, val);
    }
    if (realize(stmt-&gt;lhs-&gt;type))
      stmt-&gt;setDone();
  } else {
    // Normal assignments
    unify(stmt-&gt;lhs-&gt;type, ctx-&gt;getUnbound());
    if (stmt-&gt;type) {
      unify(stmt-&gt;lhs-&gt;type,
            ctx-&gt;instantiate(stmt-&gt;type-&gt;getSrcInfo(), stmt-&gt;type-&gt;getType()));
    }
    // Check if we can wrap the expression (e.g., `a: float = 3` -&gt; `a = float(3)`)
    if (wrapExpr(stmt-&gt;rhs, stmt-&gt;lhs-&gt;getType()))
      unify(stmt-&gt;lhs-&gt;type, stmt-&gt;rhs-&gt;type);
    auto type = stmt-&gt;lhs-&gt;getType();
    auto kind = TypecheckItem::Var;
    if (stmt-&gt;rhs-&gt;isType())
      kind = TypecheckItem::Type;
    else if (type-&gt;getFunc())
      kind = TypecheckItem::Func;
  @others
               kind == TypecheckItem::Type) {
      // Make import toplevel type aliases (e.g., `a = Ptr[byte]`) visible
      ctx-&gt;addToplevel(lhs, val);
    } else {
      ctx-&gt;add(lhs, val);
    }

    if (stmt-&gt;lhs-&gt;getId() &amp;&amp; kind != TypecheckItem::Var) {
      // Special case: type/function renames
      stmt-&gt;rhs-&gt;type = nullptr;
      stmt-&gt;setDone();
    } else if (stmt-&gt;rhs-&gt;isDone() &amp;&amp; realize(stmt-&gt;lhs-&gt;type)) {
      stmt-&gt;setDone();
    }
  }
}

</t>
<t tx="ekr.20230509083243.894">  // Generalize non-variable types. That way we can support cases like:
  // `a = foo(x, ...); a(1); a('s')`
  auto val = std::make_shared&lt;TypecheckItem&gt;(
      kind,
      kind != TypecheckItem::Var ? type-&gt;generalize(ctx-&gt;typecheckLevel - 1) : type);

  if (in(ctx-&gt;cache-&gt;globals, lhs)) {
    // Make globals always visible!
    ctx-&gt;addToplevel(lhs, val);
    if (kind != TypecheckItem::Var)
      ctx-&gt;cache-&gt;globals.erase(lhs);
  } else if (startswith(ctx-&gt;getRealizationBase()-&gt;name, "._import_") &amp;&amp;
</t>
<t tx="ekr.20230509083243.895">/// Transform binding updates. Special handling is done for atomic or in-place
/// statements (e.g., `a += b`).
/// See @c transformInplaceUpdate and @c wrapExpr for details.
void TypecheckVisitor::transformUpdate(AssignStmt *stmt) {
  transform(stmt-&gt;lhs);
  if (stmt-&gt;lhs-&gt;isStatic())
    E(Error::ASSIGN_UNEXPECTED_STATIC, stmt-&gt;lhs);

  // Check inplace updates
  auto [inPlace, inPlaceExpr] = transformInplaceUpdate(stmt);
  if (inPlace) {
    if (inPlaceExpr) {
      resultStmt = N&lt;ExprStmt&gt;(inPlaceExpr);
      if (inPlaceExpr-&gt;isDone())
        resultStmt-&gt;setDone();
    }
    return;
  }

  transform(stmt-&gt;rhs);
  // Case: wrap expressions if needed (e.g. floats or optionals)
  if (wrapExpr(stmt-&gt;rhs, stmt-&gt;lhs-&gt;getType()))
    unify(stmt-&gt;rhs-&gt;type, stmt-&gt;lhs-&gt;type);
  if (stmt-&gt;rhs-&gt;done &amp;&amp; realize(stmt-&gt;lhs-&gt;type))
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.896">/// Typecheck instance member assignments (e.g., `a.b = c`) and handle optional
/// instances. Disallow tuple updates.
/// @example
///   `opt.foo = bar` -&gt; `unwrap(opt).foo = wrap(bar)`
/// See @c wrapExpr for more examples.
void TypecheckVisitor::visit(AssignMemberStmt *stmt) {
  transform(stmt-&gt;lhs);

  if (auto lhsClass = stmt-&gt;lhs-&gt;getType()-&gt;getClass()) {
    auto member = ctx-&gt;findMember(lhsClass-&gt;name, stmt-&gt;member);

    if (!member &amp;&amp; stmt-&gt;lhs-&gt;isType()) {
      // Case: class variables
      if (auto cls = in(ctx-&gt;cache-&gt;classes, lhsClass-&gt;name))
        if (auto var = in(cls-&gt;classVars, stmt-&gt;member)) {
          auto a = N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(*var), transform(stmt-&gt;rhs));
          a-&gt;setUpdate();
          resultStmt = transform(a);
          return;
        }
    }
    if (!member &amp;&amp; lhsClass-&gt;is(TYPE_OPTIONAL)) {
      // Unwrap optional and look up there
      resultStmt = transform(N&lt;AssignMemberStmt&gt;(
          N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), stmt-&gt;lhs), stmt-&gt;member, stmt-&gt;rhs));
      return;
    }

    if (!member)
      E(Error::DOT_NO_ATTR, stmt-&gt;lhs, lhsClass-&gt;prettyString(), stmt-&gt;member);
    if (lhsClass-&gt;getRecord())
      E(Error::ASSIGN_UNEXPECTED_FROZEN, stmt-&gt;lhs);

    transform(stmt-&gt;rhs);
    auto typ = ctx-&gt;instantiate(stmt-&gt;lhs-&gt;getSrcInfo(), member, lhsClass);
    if (!wrapExpr(stmt-&gt;rhs, typ))
      return;
    unify(stmt-&gt;rhs-&gt;type, typ);
    if (stmt-&gt;rhs-&gt;isDone())
      stmt-&gt;setDone();
  }
}

</t>
<t tx="ekr.20230509083243.897">/// Transform in-place and atomic updates.
/// @example
///   `a += b` -&gt; `a.__iadd__(a, b)` if `__iadd__` exists
///   Atomic operations (when the needed magics are available):
///   `a = b`         -&gt; `type(a).__atomic_xchg__(__ptr__(a), b)`
///   `a += b`        -&gt; `type(a).__atomic_add__(__ptr__(a), b)`
///   `a = min(a, b)` -&gt; `type(a).__atomic_min__(__ptr__(a), b)` (same for `max`)
/// @return a tuple indicating whether (1) the update statement can be replaced with an
///         expression, and (2) the replacement expression.
std::pair&lt;bool, ExprPtr&gt; TypecheckVisitor::transformInplaceUpdate(AssignStmt *stmt) {
  // Case: in-place updates (e.g., `a += b`).
  // They are stored as `Update(a, Binary(a + b, inPlace=true))`
  auto bin = stmt-&gt;rhs-&gt;getBinary();
  if (bin &amp;&amp; bin-&gt;inPlace) {
    transform(bin-&gt;lexpr);
    transform(bin-&gt;rexpr);
    if (bin-&gt;lexpr-&gt;type-&gt;getClass() &amp;&amp; bin-&gt;rexpr-&gt;type-&gt;getClass()) {
      if (auto transformed = transformBinaryInplaceMagic(bin, stmt-&gt;isAtomicUpdate())) {
        unify(stmt-&gt;rhs-&gt;type, transformed-&gt;type);
        return {true, transformed};
      } else if (!stmt-&gt;isAtomicUpdate()) {
        // If atomic, call normal magic and then use __atomic_xchg__ below
        return {false, nullptr};
      }
    } else { // Not yet completed
      unify(stmt-&gt;lhs-&gt;type, unify(stmt-&gt;rhs-&gt;type, ctx-&gt;getUnbound()));
      return {true, nullptr};
    }
  }

  // Case: atomic min/max operations.
  // Note: check only `a = min(a, b)`; does NOT check `a = min(b, a)`
  auto lhsClass = stmt-&gt;lhs-&gt;getType()-&gt;getClass();
  auto call = stmt-&gt;rhs-&gt;getCall();
  if (stmt-&gt;isAtomicUpdate() &amp;&amp; call &amp;&amp; stmt-&gt;lhs-&gt;getId() &amp;&amp;
      (call-&gt;expr-&gt;isId("min") || call-&gt;expr-&gt;isId("max")) &amp;&amp; call-&gt;args.size() == 2 &amp;&amp;
      call-&gt;args[0].value-&gt;isId(std::string(stmt-&gt;lhs-&gt;getId()-&gt;value))) {
</t>
<t tx="ekr.20230509083243.898">    // `type(a).__atomic_min__(__ptr__(a), b)`
    auto ptrTyp = ctx-&gt;instantiateGeneric(stmt-&gt;lhs-&gt;getSrcInfo(), ctx-&gt;getType("Ptr"),
                                          {lhsClass});
    call-&gt;args[1].value = transform(call-&gt;args[1].value);
    auto rhsTyp = call-&gt;args[1].value-&gt;getType()-&gt;getClass();
    if (auto method = findBestMethod(
            lhsClass, format("__atomic_{}__", call-&gt;expr-&gt;getId()-&gt;value),
            {ptrTyp, rhsTyp})) {
      return {true, transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(method-&gt;ast-&gt;name),
                                          N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__ptr__"), stmt-&gt;lhs),
                                          call-&gt;args[1].value))};
    }
</t>
<t tx="ekr.20230509083243.899">  }

  // Case: atomic assignments
  if (stmt-&gt;isAtomicUpdate() &amp;&amp; lhsClass) {
    // `type(a).__atomic_xchg__(__ptr__(a), b)`
    transform(stmt-&gt;rhs);
    if (auto rhsClass = stmt-&gt;rhs-&gt;getType()-&gt;getClass()) {
</t>
<t tx="ekr.20230509083243.9">  void handle(ReturnInstr *v) override {
    if (saw(v))
      return;
    auto *M = v-&gt;getModule();
    auto *newReturn = M-&gt;Nr&lt;ReturnInstr&gt;(M-&gt;getBool(!any));
    see(newReturn);
    v-&gt;replaceAll(util::series(v-&gt;getValue(), newReturn));
  }

</t>
<t tx="ekr.20230509083243.90">Var *CloneVisitor::clone(const Var *other) {
  if (!other)
    return nullptr;
  auto id = other-&gt;getId();
  if (ctx.find(id) != ctx.end())
    return cast&lt;Var&gt;(ctx[id]);

  return const_cast&lt;Var *&gt;(other);
}

</t>
<t tx="ekr.20230509083243.900">      auto ptrType = ctx-&gt;instantiateGeneric(stmt-&gt;lhs-&gt;getSrcInfo(),
                                             ctx-&gt;getType("Ptr"), {lhsClass});
      if (auto m = findBestMethod(lhsClass, "__atomic_xchg__", {ptrType, rhsClass})) {
        return {true,
                N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(m-&gt;ast-&gt;name),
                            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__ptr__"), stmt-&gt;lhs), stmt-&gt;rhs)};
      }
</t>
<t tx="ekr.20230509083243.901">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.902">/// Set type to `Optional[?]`
void TypecheckVisitor::visit(NoneExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;instantiate(ctx-&gt;getType(TYPE_OPTIONAL)));
  if (realize(expr-&gt;type)) {
    // Realize the appropriate `Optional.__new__` for the translation stage
    auto cls = expr-&gt;type-&gt;getClass();
    auto f = ctx-&gt;forceFind(TYPE_OPTIONAL ".__new__:0")-&gt;type;
    auto t = realize(ctx-&gt;instantiate(f, cls)-&gt;getFunc());
    expr-&gt;setDone();
  }
}

</t>
<t tx="ekr.20230509083243.903">/// Set type to `bool`
void TypecheckVisitor::visit(BoolExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getType("bool"));
  expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.904">/// Set type to `int`
void TypecheckVisitor::visit(IntExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getType("int"));
  expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.905">/// Set type to `float`
void TypecheckVisitor::visit(FloatExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getType("float"));
  expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.906">/// Set type to `str`
void TypecheckVisitor::visit(StringExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getType("str"));
  expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.907">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;
namespace codon::ast {

using namespace types;

@others
/// Generate a partial type `Partial.N&lt;mask&gt;` for a given function.
/// @param mask a 0-1 vector whose size matches the number of function arguments.
///             1 indicates that the argument has been provided and is cached within
///             the partial object.
/// @example
///   ```@tuple
///      class Partial.N101[T0, T2]:
///        item0: T0  # the first cached argument
///        item2: T2  # the third cached argument
std::string TypecheckVisitor::generatePartialStub(const std::vector&lt;char&gt; &amp;mask,
                                                  types::FuncType *fn) {
  std::string strMask(mask.size(), '1');
  int tupleSize = 0, genericSize = 0;
  for (size_t i = 0; i &lt; mask.size(); i++) {
    if (!mask[i])
      strMask[i] = '0';
    else if (fn-&gt;ast-&gt;args[i].status == Param::Normal)
      tupleSize++;
    else
      genericSize++;
  }
  auto typeName = format(TYPE_PARTIAL "{}.{}", strMask, fn-&gt;toString());
  if (!ctx-&gt;find(typeName)) {
    ctx-&gt;cache-&gt;partials[typeName] = {fn-&gt;generalize(0)-&gt;getFunc(), mask};
    generateTuple(tupleSize + 2, typeName, {}, false);
  }
  return typeName;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.908">/// Just ensure that this expression is not independent of CallExpr where it is handled.
void TypecheckVisitor::visit(StarExpr *expr) {
  E(Error::UNEXPECTED_TYPE, expr, "star");
}

</t>
<t tx="ekr.20230509083243.909">/// Just ensure that this expression is not independent of CallExpr where it is handled.
void TypecheckVisitor::visit(KeywordStarExpr *expr) {
  E(Error::UNEXPECTED_TYPE, expr, "kwstar");
}

</t>
<t tx="ekr.20230509083243.91">void CloneVisitor::visit(const Var *v) {
  result =
      module-&gt;N&lt;Var&gt;(v, v-&gt;getType(), v-&gt;isGlobal(), v-&gt;isExternal(), v-&gt;getName());
}

</t>
<t tx="ekr.20230509083243.910">/// Typechecks an ellipsis. Ellipses are typically replaced during the typechecking; the
/// only remaining ellipses are those that belong to PipeExprs.
void TypecheckVisitor::visit(EllipsisExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getUnbound());
  if (expr-&gt;isPipeArg &amp;&amp; realize(expr-&gt;type))
    expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.911">/// Typecheck a call expression. This is the most complex expression to typecheck.
/// @example
///   `fn(1, 2, x=3, y=4)` -&gt; `func(a=1, x=3, args=(2,), kwargs=KwArgs(y=4), T=int)`
///   `fn(arg1, ...)`      -&gt; `(_v = Partial.N10(arg1); _v)`
/// See @c transformCallArgs , @c getCalleeFn , @c callReorderArguments ,
///     @c typecheckCallArgs , @c transformSpecialCall and @c wrapExpr for more details.
void TypecheckVisitor::visit(CallExpr *expr) {
  // Transform and expand arguments. Return early if it cannot be done yet
  if (!transformCallArgs(expr-&gt;args))
    return;

  // Check if this call is partial call
  PartialCallData part{!expr-&gt;args.empty() &amp;&amp; expr-&gt;args.back().value-&gt;getEllipsis() &amp;&amp;
                       !expr-&gt;args.back().value-&gt;getEllipsis()-&gt;isPipeArg &amp;&amp;
                       expr-&gt;args.back().name.empty()};
  // Transform the callee
  if (!part.isPartial) {
    // Intercept method calls (e.g. `obj.method`) for faster compilation (because it
    // avoids partial calls). This intercept passes the call arguments to
    // @c transformDot to select the best overload as well
    if (auto dot = expr-&gt;expr-&gt;getDot()) {
      // Pick the best method overload
      if (auto edt = transformDot(dot, &amp;expr-&gt;args))
        expr-&gt;expr = edt;
    } else if (auto id = expr-&gt;expr-&gt;getId()) {
      // Pick the best function overload
      auto overloads = in(ctx-&gt;cache-&gt;overloads, id-&gt;value);
      if (overloads &amp;&amp; overloads-&gt;size() &gt; 1) {
        if (auto bestMethod = getBestOverload(id, &amp;expr-&gt;args)) {
          auto t = id-&gt;type;
          expr-&gt;expr = N&lt;IdExpr&gt;(bestMethod-&gt;ast-&gt;name);
          expr-&gt;expr-&gt;setType(unify(t, ctx-&gt;instantiate(bestMethod)));
        }
      }
    }
  }
  transform(expr-&gt;expr);
  auto [calleeFn, newExpr] = getCalleeFn(expr, part);
  if ((resultExpr = newExpr))
    return;
  if (!calleeFn)
    return;

  // Handle named and default arguments
  if ((resultExpr = callReorderArguments(calleeFn, expr, part)))
    return;

  // Handle special calls
  auto [isSpecial, specialExpr] = transformSpecialCall(expr);
  if (isSpecial) {
    resultExpr = specialExpr;
    return;
  }

  // Typecheck arguments with the function signature
  bool done = typecheckCallArgs(calleeFn, expr-&gt;args);
  if (!part.isPartial &amp;&amp; realize(calleeFn)) {
    // Previous unifications can qualify existing identifiers.
    // Transform again to get the full identifier
    transform(expr-&gt;expr);
  }
  done &amp;= expr-&gt;expr-&gt;isDone();

  // Emit the final call
  if (part.isPartial) {
    // Case: partial call. `calleeFn(args...)` -&gt; `Partial.N&lt;known&gt;.&lt;fn&gt;(args...)`
    auto partialTypeName = generatePartialStub(part.known, calleeFn-&gt;getFunc().get());
    std::vector&lt;ExprPtr&gt; newArgs;
    for (auto &amp;r : expr-&gt;args)
      if (!r.value-&gt;getEllipsis()) {
        newArgs.push_back(r.value);
        newArgs.back()-&gt;setAttr(ExprAttr::SequenceItem);
      }
    newArgs.push_back(part.args);
    newArgs.push_back(part.kwArgs);

    std::string var = ctx-&gt;cache-&gt;getTemporaryVar("part");
    ExprPtr call = nullptr;
    if (!part.var.empty()) {
      // Callee is already a partial call
      auto stmts = expr-&gt;expr-&gt;getStmtExpr()-&gt;stmts;
      stmts.push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var),
                                    N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(partialTypeName), newArgs)));
      call = N&lt;StmtExpr&gt;(stmts, N&lt;IdExpr&gt;(var));
    } else {
      // New partial call: `(part = Partial.N&lt;known&gt;.&lt;fn&gt;(stored_args...); part)`
      call =
          N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var),
                                    N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(partialTypeName), newArgs)),
                      N&lt;IdExpr&gt;(var));
    }
    call-&gt;setAttr(ExprAttr::Partial);
    resultExpr = transform(call);
  } else {
    // Case: normal function call
    unify(expr-&gt;type, calleeFn-&gt;getRetType());
    if (done)
      expr-&gt;setDone();
  }
}

</t>
<t tx="ekr.20230509083243.912">/// Transform call arguments. Expand *args and **kwargs to the list of @c CallExpr::Arg
/// objects.
/// @return false if expansion could not be completed; true otherwise
bool TypecheckVisitor::transformCallArgs(std::vector&lt;CallExpr::Arg&gt; &amp;args) {
  for (auto ai = 0; ai &lt; args.size();) {
    if (auto star = args[ai].value-&gt;getStar()) {
      // Case: *args expansion
      transform(star-&gt;what);
      auto typ = star-&gt;what-&gt;type-&gt;getClass();
      while (typ &amp;&amp; typ-&gt;is(TYPE_OPTIONAL)) {
        star-&gt;what = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), star-&gt;what));
        typ = star-&gt;what-&gt;type-&gt;getClass();
      }
      if (!typ) // Process later
        return false;
      if (!typ-&gt;getRecord())
        E(Error::CALL_BAD_UNPACK, args[ai], typ-&gt;prettyString());
      auto &amp;fields = ctx-&gt;cache-&gt;classes[typ-&gt;name].fields;
      for (size_t i = 0; i &lt; typ-&gt;getRecord()-&gt;args.size(); i++, ai++) {
        args.insert(args.begin() + ai,
                    {"", transform(N&lt;DotExpr&gt;(clone(star-&gt;what), fields[i].name))});
      }
      args.erase(args.begin() + ai);
    } else if (auto kwstar = CAST(args[ai].value, KeywordStarExpr)) {
      // Case: **kwargs expansion
      kwstar-&gt;what = transform(kwstar-&gt;what);
      auto typ = kwstar-&gt;what-&gt;type-&gt;getClass();
      while (typ &amp;&amp; typ-&gt;is(TYPE_OPTIONAL)) {
        kwstar-&gt;what = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), kwstar-&gt;what));
        typ = kwstar-&gt;what-&gt;type-&gt;getClass();
      }
      if (!typ)
        return false;
      if (!typ-&gt;getRecord() || startswith(typ-&gt;name, TYPE_TUPLE))
        E(Error::CALL_BAD_KWUNPACK, args[ai], typ-&gt;prettyString());
      auto &amp;fields = ctx-&gt;cache-&gt;classes[typ-&gt;name].fields;
      for (size_t i = 0; i &lt; typ-&gt;getRecord()-&gt;args.size(); i++, ai++) {
        args.insert(args.begin() + ai,
                    {fields[i].name,
                     transform(N&lt;DotExpr&gt;(clone(kwstar-&gt;what), fields[i].name))});
      }
      args.erase(args.begin() + ai);
    } else {
      // Case: normal argument (no expansion)
      transform(args[ai++].value);
    }
  }

  // Check if some argument names are reused after the expansion
  std::set&lt;std::string&gt; seen;
  for (auto &amp;a : args)
    if (!a.name.empty()) {
      if (in(seen, a.name))
        E(Error::CALL_REPEATED_NAME, a, a.name);
      seen.insert(a.name);
    }

  return true;
}

</t>
<t tx="ekr.20230509083243.913">/// Extract the @c FuncType that represents the function to be called by the callee.
/// Also handle special callees: constructors and partial functions.
/// @return a pair with the callee's @c FuncType and the replacement expression
///         (when needed; otherwise nullptr).
std::pair&lt;FuncTypePtr, ExprPtr&gt; TypecheckVisitor::getCalleeFn(CallExpr *expr,
                                                              PartialCallData &amp;part) {
  auto callee = expr-&gt;expr-&gt;type-&gt;getClass();
  if (!callee) {
    // Case: unknown callee, wait until it becomes known
    unify(expr-&gt;type, ctx-&gt;getUnbound());
    return {nullptr, nullptr};
  }

  if (expr-&gt;expr-&gt;isType() &amp;&amp; callee-&gt;getRecord()) {
    // Case: tuple constructor. Transform to: `T.__new__(args)`
    return {nullptr,
            transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, "__new__"), expr-&gt;args))};
  }

  if (expr-&gt;expr-&gt;isType()) {
    // Case: reference type constructor. Transform to
    // `ctr = T.__new__(); v.__init__(args)`
    ExprPtr var = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("ctr"));
    auto clsName = expr-&gt;expr-&gt;type-&gt;getClass()-&gt;name;
</t>
<t tx="ekr.20230509083243.914">    auto newInit =
        N&lt;AssignStmt&gt;(clone(var), N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, "__new__")));
    auto e = N&lt;StmtExpr&gt;(N&lt;SuiteStmt&gt;(newInit), clone(var));
    @others
</t>
<t tx="ekr.20230509083243.915">auto init =
    N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), "__init__"), expr-&gt;args));
e-&gt;stmts.emplace_back(init);
return {nullptr, transform(e)};
  }

  auto calleeFn = callee-&gt;getFunc();
  if (auto partType = callee-&gt;getPartial()) {
// Case: calling partial object `p`. Transform roughly to
// `part = callee; partial_fn(*part.args, args...)`
ExprPtr var = N&lt;IdExpr&gt;(part.var = ctx-&gt;cache-&gt;getTemporaryVar("partcall"));
expr-&gt;expr = transform(N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(clone(var), expr-&gt;expr),
                                   N&lt;IdExpr&gt;(partType-&gt;func-&gt;ast-&gt;name)));

// Ensure that we got a function
calleeFn = expr-&gt;expr-&gt;type-&gt;getFunc();
seqassert(calleeFn, "not a function: {}", expr-&gt;expr-&gt;type);

// Unify partial generics with types known thus far
for (size_t i = 0, j = 0, k = 0; i &lt; partType-&gt;known.size(); i++)
  if (partType-&gt;func-&gt;ast-&gt;args[i].status == Param::Generic) {
    if (partType-&gt;known[i])
      unify(calleeFn-&gt;funcGenerics[j].type,
            ctx-&gt;instantiate(partType-&gt;func-&gt;funcGenerics[j].type));
    j++;
  } else if (partType-&gt;known[i]) {
    unify(calleeFn-&gt;getArgTypes()[i - j], partType-&gt;generics[k].type);
    k++;
  }
part.known = partType-&gt;known;
return {calleeFn, nullptr};
  } else if (!callee-&gt;getFunc()) {
// Case: callee is not a function. Try __call__ method instead
return {nullptr,
        transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;expr, "__call__"), expr-&gt;args))};
  }
</t>
<t tx="ekr.20230509083243.916">  return {calleeFn, nullptr};
}

/// Reorder the call arguments to match the signature order. Ensure that every @c
/// CallExpr::Arg has a set name. Form *args/**kwargs tuples if needed, and use partial
/// and default values where needed.
/// @example
///   `foo(1, 2, baz=3, baf=4)` -&gt; `foo(a=1, baz=2, args=(3, ), kwargs=KwArgs(baf=4))`
ExprPtr TypecheckVisitor::callReorderArguments(FuncTypePtr calleeFn, CallExpr *expr,
                                               PartialCallData &amp;part) {
  std::vector&lt;CallExpr::Arg&gt; args; // stores ordered and processed arguments
  std::vector&lt;ExprPtr&gt; typeArgs;   // stores type and static arguments (e.g., `T: type`)
  auto newMask = std::vector&lt;char&gt;(calleeFn-&gt;ast-&gt;args.size(), 1);

</t>
<t tx="ekr.20230509083243.917">  // Extract pi-th partial argument from a partial object
  auto getPartialArg = [&amp;](size_t pi) {
    auto id = transform(N&lt;IdExpr&gt;(part.var));
    // Manually call @c transformStaticTupleIndex to avoid spurious InstantiateExpr
    auto ex = transformStaticTupleIndex(id-&gt;type-&gt;getClass(), id, N&lt;IntExpr&gt;(pi));
    seqassert(ex.first &amp;&amp; ex.second, "partial indexing failed: {}", id-&gt;type);
    return ex.second;
  };

</t>
<t tx="ekr.20230509083243.918">  // Handle reordered arguments (see @c reorderNamedArgs for details)
  bool partial = false;
</t>
<t tx="ekr.20230509083243.919">  auto reorderFn = [&amp;](int starArgIndex, int kwstarArgIndex,
    @others
</t>
<t tx="ekr.20230509083243.92">void CloneVisitor::visit(const BodiedFunc *v) {
  auto *res = Nt(v);
  std::vector&lt;std::string&gt; argNames;

  for (auto it = v-&gt;arg_begin(); it != v-&gt;arg_end(); ++it)
    argNames.push_back((*it)-&gt;getName());
  for (const auto *var : *v) {
    auto *newVar = forceClone(var);
    res-&gt;push_back(newVar);
  }
  res-&gt;setUnmangledName(v-&gt;getUnmangledName());
  res-&gt;setGenerator(v-&gt;isGenerator());
  res-&gt;realize(cast&lt;types::FuncType&gt;(v-&gt;getType()), argNames);

  auto argIt1 = v-&gt;arg_begin();
  auto argIt2 = res-&gt;arg_begin();
  while (argIt1 != v-&gt;arg_end()) {
    forceRemap(*argIt1, *argIt2);
    ++argIt1;
    ++argIt2;
  }

  // body might reference this!
  forceRemap(v, res);

  if (v-&gt;getBody())
    res-&gt;setBody(clone(v-&gt;getBody()));
  res-&gt;setJIT(v-&gt;isJIT());
  result = res;
}

</t>
<t tx="ekr.20230509083243.920">                   const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;slots, bool _partial) {
partial = _partial;
ctx-&gt;addBlock(); // add function generics to typecheck default arguments
addFunctionGenerics(calleeFn-&gt;getFunc().get());
for (size_t si = 0, pi = 0; si &lt; slots.size(); si++) {
  // Get the argument name to be used later
  auto rn = calleeFn-&gt;ast-&gt;args[si].name;
  trimStars(rn);
  auto realName = ctx-&gt;cache-&gt;rev(rn);

  if (calleeFn-&gt;ast-&gt;args[si].status == Param::Generic) {
    // Case: generic arguments. Populate typeArgs
    typeArgs.push_back(slots[si].empty() ? nullptr
                                         : expr-&gt;args[slots[si][0]].value);
    newMask[si] = slots[si].empty() ? 0 : 1;
  } else if (si == starArgIndex &amp;&amp;
             !(slots[si].size() == 1 &amp;&amp;
               expr-&gt;args[slots[si][0]].value-&gt;hasAttr(ExprAttr::StarArgument))) {
    // Case: *args. Build the tuple that holds them all
    std::vector&lt;ExprPtr&gt; extra;
    if (!part.known.empty())
      extra.push_back(N&lt;StarExpr&gt;(getPartialArg(-2)));
    for (auto &amp;e : slots[si]) {
      extra.push_back(expr-&gt;args[e].value);
    }
    ExprPtr e = N&lt;TupleExpr&gt;(extra);
    e-&gt;setAttr(ExprAttr::StarArgument);
    if (!expr-&gt;expr-&gt;isId("hasattr:0"))
      e = transform(e);
    if (partial) {
      part.args = e;
      args.push_back({realName, transform(N&lt;EllipsisExpr&gt;())});
      newMask[si] = 0;
    } else {
      args.push_back({realName, e});
    }
  } else if (si == kwstarArgIndex &amp;&amp;
             !(slots[si].size() == 1 &amp;&amp;
               expr-&gt;args[slots[si][0]].value-&gt;hasAttr(ExprAttr::KwStarArgument))) {
    // Case: **kwargs. Build the named tuple that holds them all
    std::vector&lt;std::string&gt; names;
    std::vector&lt;CallExpr::Arg&gt; values;
    if (!part.known.empty()) {
      auto e = getPartialArg(-1);
      auto t = e-&gt;getType()-&gt;getRecord();
      seqassert(t &amp;&amp; startswith(t-&gt;name, TYPE_KWTUPLE), "{} not a kwtuple", e);
      auto &amp;ff = ctx-&gt;cache-&gt;classes[t-&gt;name].fields;
      for (int i = 0; i &lt; t-&gt;getRecord()-&gt;args.size(); i++) {
        names.emplace_back(ff[i].name);
        values.emplace_back(
            CallExpr::Arg(transform(N&lt;DotExpr&gt;(clone(e), ff[i].name))));
      }
    }
    for (auto &amp;e : slots[si]) {
      names.emplace_back(expr-&gt;args[e].name);
      values.emplace_back(CallExpr::Arg(expr-&gt;args[e].value));
    }
    auto kwName = generateTuple(names.size(), TYPE_KWTUPLE, names);
    auto e = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(kwName), values));
    e-&gt;setAttr(ExprAttr::KwStarArgument);
    if (partial) {
      part.kwArgs = e;
      args.push_back({realName, transform(N&lt;EllipsisExpr&gt;())});
      newMask[si] = 0;
    } else {
      args.push_back({realName, e});
    }
  } else if (slots[si].empty()) {
    // Case: no argument. Check if the arguments is provided by the partial type (if
    // calling it) or if a default argument can be used
    if (!part.known.empty() &amp;&amp; part.known[si]) {
      args.push_back({realName, getPartialArg(pi++)});
    } else if (partial) {
      args.push_back({realName, transform(N&lt;EllipsisExpr&gt;())});
      newMask[si] = 0;
    } else {
      auto es = calleeFn-&gt;ast-&gt;args[si].defaultValue-&gt;toString();
      if (in(ctx-&gt;defaultCallDepth, es))
        E(Error::CALL_RECURSIVE_DEFAULT, expr,
          ctx-&gt;cache-&gt;rev(calleeFn-&gt;ast-&gt;args[si].name));
      ctx-&gt;defaultCallDepth.insert(es);
      args.push_back(
          {realName, transform(clone(calleeFn-&gt;ast-&gt;args[si].defaultValue))});
      ctx-&gt;defaultCallDepth.erase(es);
    }
  } else {
    // Case: argument provided
    seqassert(slots[si].size() == 1, "call transformation failed");
    args.push_back({realName, expr-&gt;args[slots[si][0]].value});
  }
}
ctx-&gt;popBlock();
return 0;
  };

</t>
<t tx="ekr.20230509083243.921">  // Reorder arguments if needed
  part.args = part.kwArgs = nullptr; // Stores partial *args/**kwargs expression
  if (expr-&gt;hasAttr(ExprAttr::OrderedCall) || expr-&gt;expr-&gt;isId("superf")) {
    args = expr-&gt;args;
  } else {
    ctx-&gt;reorderNamedArgs(
        calleeFn.get(), expr-&gt;args, reorderFn,
        [&amp;](error::Error e, const SrcInfo &amp;o, const std::string &amp;errorMsg) {
          error::raise_error(e, o, errorMsg);
          return -1;
        },
        part.known);
  }

  // Populate partial data
  if (part.args != nullptr)
    part.args-&gt;setAttr(ExprAttr::SequenceItem);
  if (part.kwArgs != nullptr)
    part.kwArgs-&gt;setAttr(ExprAttr::SequenceItem);
  if (part.isPartial) {
    expr-&gt;args.pop_back();
    if (!part.args)
      part.args = transform(N&lt;TupleExpr&gt;()); // use ()
    if (!part.kwArgs) {
      auto kwName = generateTuple(0, TYPE_KWTUPLE, {});
      part.kwArgs = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(kwName))); // use KwTuple()
    }
  }

  // Unify function type generics with the provided generics
  seqassert((expr-&gt;hasAttr(ExprAttr::OrderedCall) &amp;&amp; typeArgs.empty()) ||
                (!expr-&gt;hasAttr(ExprAttr::OrderedCall) &amp;&amp;
                 typeArgs.size() == calleeFn-&gt;funcGenerics.size()),
            "bad vector sizes");
  if (!calleeFn-&gt;funcGenerics.empty()) {
    auto niGenerics = calleeFn-&gt;ast-&gt;getNonInferrableGenerics();
    for (size_t si = 0;
         !expr-&gt;hasAttr(ExprAttr::OrderedCall) &amp;&amp; si &lt; calleeFn-&gt;funcGenerics.size();
         si++) {
      if (typeArgs[si]) {
        auto typ = typeArgs[si]-&gt;type;
        if (calleeFn-&gt;funcGenerics[si].type-&gt;isStaticType()) {
          if (!typeArgs[si]-&gt;isStatic()) {
            E(Error::EXPECTED_STATIC, typeArgs[si]);
          }
          typ = Type::makeStatic(ctx-&gt;cache, typeArgs[si]);
        }
        unify(typ, calleeFn-&gt;funcGenerics[si].type);
      } else {
        if (calleeFn-&gt;funcGenerics[si].type-&gt;getUnbound() &amp;&amp;
            !calleeFn-&gt;ast-&gt;args[si].defaultValue &amp;&amp; !partial &amp;&amp;
            in(niGenerics, calleeFn-&gt;funcGenerics[si].name)) {
          error("generic '{}' not provided", calleeFn-&gt;funcGenerics[si].niceName);
        }
      }
    }
  }

  // Special case: function instantiation (e.g., `foo(T=int)`)
  auto cnt = 0;
  for (auto &amp;t : typeArgs)
    if (t)
      cnt++;
  if (part.isPartial &amp;&amp; cnt &amp;&amp; cnt == expr-&gt;args.size()) {
    transform(expr-&gt;expr); // transform again because it might have been changed
    unify(expr-&gt;type, expr-&gt;expr-&gt;getType());
    // Return the callee with the corrected type and do not go further
    return expr-&gt;expr;
  }

  expr-&gt;args = args;
  expr-&gt;setAttr(ExprAttr::OrderedCall);
  part.known = newMask;
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.922">/// Unify the call arguments' types with the function declaration signatures.
/// Also apply argument transformations to ensure the type compatibility and handle
/// default generics.
/// @example
///   `foo(1, 2)` -&gt; `foo(1, Optional(2), T=int)`
bool TypecheckVisitor::typecheckCallArgs(const FuncTypePtr &amp;calleeFn,
                                         std::vector&lt;CallExpr::Arg&gt; &amp;args) {
  bool wrappingDone = true;          // tracks whether all arguments are wrapped
  std::vector&lt;TypePtr&gt; replacements; // list of replacement arguments
  for (size_t si = 0; si &lt; calleeFn-&gt;getArgTypes().size(); si++) {
    if (startswith(calleeFn-&gt;ast-&gt;args[si].name, "*") &amp;&amp; calleeFn-&gt;ast-&gt;args[si].type &amp;&amp;
        args[si].value-&gt;getCall()) {
      // Special case: `*args: type` and `**kwargs: type`
      auto typ = transform(clone(calleeFn-&gt;ast-&gt;args[si].type))-&gt;type;
      for (auto &amp;ca : args[si].value-&gt;getCall()-&gt;args) {
        if (wrapExpr(ca.value, typ, calleeFn)) {
          unify(ca.value-&gt;type, typ);
        } else {
          wrappingDone = false;
        }
      }
      auto name = args[si].value-&gt;type-&gt;getClass()-&gt;name;
      args[si].value =
          transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(name), args[si].value-&gt;getCall()-&gt;args));
      replacements.push_back(args[si].value-&gt;type);
    } else {
      if (wrapExpr(args[si].value, calleeFn-&gt;getArgTypes()[si], calleeFn)) {
        unify(args[si].value-&gt;type, calleeFn-&gt;getArgTypes()[si]);
      } else {
        wrappingDone = false;
      }
      replacements.push_back(!calleeFn-&gt;getArgTypes()[si]-&gt;getClass()
                                 ? args[si].value-&gt;type
                                 : calleeFn-&gt;getArgTypes()[si]);
    }
  }

  // Realize arguments
  bool done = true;
  for (auto &amp;a : args) {
    // Previous unifications can qualify existing identifiers.
    // Transform again to get the full identifier
    if (realize(a.value-&gt;type))
      transform(a.value);
    done &amp;= a.value-&gt;isDone();
  }

  // Handle default generics
  for (size_t i = 0, j = 0; wrappingDone &amp;&amp; i &lt; calleeFn-&gt;ast-&gt;args.size(); i++)
    if (calleeFn-&gt;ast-&gt;args[i].status == Param::Generic) {
      if (calleeFn-&gt;ast-&gt;args[i].defaultValue &amp;&amp;
          calleeFn-&gt;funcGenerics[j].type-&gt;getUnbound()) {
        ctx-&gt;addBlock(); // add function generics to typecheck default arguments
        addFunctionGenerics(calleeFn-&gt;getFunc().get());
        auto def = transform(clone(calleeFn-&gt;ast-&gt;args[i].defaultValue));
        ctx-&gt;popBlock();
        unify(calleeFn-&gt;funcGenerics[j].type,
              def-&gt;isStatic() ? Type::makeStatic(ctx-&gt;cache, def) : def-&gt;getType());
      }
      j++;
    }

  // Replace the arguments
  for (size_t si = 0; si &lt; replacements.size(); si++) {
    if (replacements[si])
      calleeFn-&gt;getArgTypes()[si] = replacements[si];
  }

  return done;
}

</t>
<t tx="ekr.20230509083243.923">/// Transform and typecheck the following special call expressions:
///   `superf(fn)`
///   `super()`
///   `__ptr__(var)`
///   `__array__[int](sz)`
///   `isinstance(obj, type)`
///   `staticlen(tup)`
///   `hasattr(obj, "attr")`
///   `getattr(obj, "attr")`
///   `type(obj)`
///   `compile_err("msg")`
/// See below for more details.
std::pair&lt;bool, ExprPtr&gt; TypecheckVisitor::transformSpecialCall(CallExpr *expr) {
  if (!expr-&gt;expr-&gt;getId())
    return {false, nullptr};
  auto val = expr-&gt;expr-&gt;getId()-&gt;value;
  if (val == "superf") {
    return {true, transformSuperF(expr)};
  } else if (val == "super:0") {
    return {true, transformSuper()};
  } else if (val == "__ptr__") {
    return {true, transformPtr(expr)};
  } else if (val == "__array__.__new__:0") {
    return {true, transformArray(expr)};
  } else if (val == "isinstance") {
    return {true, transformIsInstance(expr)};
  } else if (val == "staticlen") {
    return {true, transformStaticLen(expr)};
  } else if (startswith(val, "hasattr:")) {
    return {true, transformHasAttr(expr)};
  } else if (val == "getattr") {
    return {true, transformGetAttr(expr)};
  } else if (val == "setattr") {
    return {true, transformSetAttr(expr)};
  } else if (val == "type.__new__:0") {
    return {true, transformTypeFn(expr)};
  } else if (val == "compile_error") {
    return {true, transformCompileError(expr)};
  } else if (val == "tuple") {
    return {true, transformTupleFn(expr)};
  } else if (val == "__realized__") {
    return {true, transformRealizedFn(expr)};
  } else if (val == "std.internal.static.static_print") {
    return {false, transformStaticPrintFn(expr)};
  } else {
    return transformInternalStaticFn(expr);
  }
}

/// Typecheck superf method. This method provides the access to the previous matching
/// overload.
/// @example
///   ```class cls:
///        def foo(): print('foo 1')
///        def foo():
///          superf()  # access the previous foo
///          print('foo 2')
///      cls.foo()```
///   prints "foo 1" followed by "foo 2"
ExprPtr TypecheckVisitor::transformSuperF(CallExpr *expr) {
  auto func = ctx-&gt;getRealizationBase()-&gt;type-&gt;getFunc();

  // Find list of matching superf methods
  std::vector&lt;types::FuncTypePtr&gt; supers;
  if (!func-&gt;ast-&gt;attributes.parentClass.empty() &amp;&amp;
      !endswith(func-&gt;ast-&gt;name, ":dispatch")) {
    auto p = ctx-&gt;find(func-&gt;ast-&gt;attributes.parentClass)-&gt;type;
    if (p &amp;&amp; p-&gt;getClass()) {
      if (auto c = in(ctx-&gt;cache-&gt;classes, p-&gt;getClass()-&gt;name)) {
        if (auto m = in(c-&gt;methods, ctx-&gt;cache-&gt;rev(func-&gt;ast-&gt;name))) {
          for (auto &amp;overload : ctx-&gt;cache-&gt;overloads[*m]) {
            if (endswith(overload.name, ":dispatch"))
              continue;
            if (overload.name == func-&gt;ast-&gt;name)
              break;
            supers.emplace_back(ctx-&gt;cache-&gt;functions[overload.name].type);
          }
        }
      }
      std::reverse(supers.begin(), supers.end());
    }
  }
  if (supers.empty())
    E(Error::CALL_SUPERF, expr);
</t>
<t tx="ekr.20230509083243.924">  auto m = findMatchingMethods(
      func-&gt;funcParent ? func-&gt;funcParent-&gt;getClass() : nullptr, supers, expr-&gt;args);
  if (m.empty())
    E(Error::CALL_SUPERF, expr);
  return transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(m[0]-&gt;ast-&gt;name), expr-&gt;args));
}

/// Typecheck and transform super method. Replace it with the current self object cast
/// to the first inherited type.
/// TODO: only an empty super() is currently supported.
ExprPtr TypecheckVisitor::transformSuper() {
  if (!ctx-&gt;getRealizationBase()-&gt;type)
    E(Error::CALL_SUPER_PARENT, getSrcInfo());
  auto funcTyp = ctx-&gt;getRealizationBase()-&gt;type-&gt;getFunc();
  if (!funcTyp || !funcTyp-&gt;ast-&gt;hasAttr(Attr::Method))
    E(Error::CALL_SUPER_PARENT, getSrcInfo());
  if (funcTyp-&gt;getArgTypes().empty())
    E(Error::CALL_SUPER_PARENT, getSrcInfo());

  ClassTypePtr typ = funcTyp-&gt;getArgTypes()[0]-&gt;getClass();
  auto cands = ctx-&gt;cache-&gt;classes[typ-&gt;name].staticParentClasses;
  if (cands.empty()) {
    // Dynamic inheritance: use MRO
    // TODO: maybe super() should be split into two separate functions...
    auto vCands = ctx-&gt;cache-&gt;classes[typ-&gt;name].mro;
    if (vCands.size() &lt; 2)
      E(Error::CALL_SUPER_PARENT, getSrcInfo());

    auto superTyp = ctx-&gt;instantiate(vCands[1]-&gt;type, typ)-&gt;getClass();
    auto self = N&lt;IdExpr&gt;(funcTyp-&gt;ast-&gt;args[0].name);
    self-&gt;type = typ;

    auto typExpr = N&lt;IdExpr&gt;(superTyp-&gt;name);
    typExpr-&gt;setType(superTyp);
    return transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;("__internal__"), "class_super"),
                                 self, typExpr));
  }

  auto name = cands.front(); // the first inherited type
  auto superTyp = ctx-&gt;instantiate(ctx-&gt;forceFind(name)-&gt;type)-&gt;getClass();
  if (typ-&gt;getRecord()) {
    // Case: tuple types. Return `tuple(obj.args...)`
    std::vector&lt;ExprPtr&gt; members;
    for (auto &amp;field : ctx-&gt;cache-&gt;classes[name].fields)
      members.push_back(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(funcTyp-&gt;ast-&gt;args[0].name), field.name));
    ExprPtr e = transform(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(format(TYPE_TUPLE "{}", members.size())), members));
    e-&gt;type = unify(superTyp, e-&gt;type); // see super_tuple test for this line
    return e;
  } else {
    // Case: reference types. Return `__internal__.to_class_ptr(self.__raw__(), T)`
    auto self = N&lt;IdExpr&gt;(funcTyp-&gt;ast-&gt;args[0].name);
    self-&gt;type = typ;
    return castToSuperClass(self, superTyp);
  }
}

</t>
<t tx="ekr.20230509083243.925">/// Typecheck __ptr__ method. This method creates a pointer to an object. Ensure that
/// the argument is a variable binding.
ExprPtr TypecheckVisitor::transformPtr(CallExpr *expr) {
  auto id = expr-&gt;args[0].value-&gt;getId();
  auto val = id ? ctx-&gt;find(id-&gt;value) : nullptr;
  if (!val || val-&gt;kind != TypecheckItem::Var)
    E(Error::CALL_PTR_VAR, expr-&gt;args[0]);

  transform(expr-&gt;args[0].value);
  unify(expr-&gt;type,
        ctx-&gt;instantiateGeneric(ctx-&gt;getType("Ptr"), {expr-&gt;args[0].value-&gt;type}));
  if (expr-&gt;args[0].value-&gt;isDone())
    expr-&gt;setDone();
  return nullptr;
}

/// Typecheck __array__ method. This method creates a stack-allocated array via alloca.
ExprPtr TypecheckVisitor::transformArray(CallExpr *expr) {
  auto arrTyp = expr-&gt;expr-&gt;type-&gt;getFunc();
  unify(expr-&gt;type,
        ctx-&gt;instantiateGeneric(ctx-&gt;getType("Array"),
                                {arrTyp-&gt;funcParent-&gt;getClass()-&gt;generics[0].type}));
  if (realize(expr-&gt;type))
    expr-&gt;setDone();
  return nullptr;
}

/// Transform isinstance method to a static boolean expression.
/// Special cases:
///   `isinstance(obj, ByVal)` is True if `type(obj)` is a tuple type
///   `isinstance(obj, ByRef)` is True if `type(obj)` is a reference type
ExprPtr TypecheckVisitor::transformIsInstance(CallExpr *expr) {
  expr-&gt;setType(unify(expr-&gt;type, ctx-&gt;getType("bool")));
  transform(expr-&gt;args[0].value);
  auto typ = expr-&gt;args[0].value-&gt;type-&gt;getClass();
  if (!typ || !typ-&gt;canRealize())
    return nullptr;

  transform(expr-&gt;args[0].value); // transform again to realize it

  auto &amp;typExpr = expr-&gt;args[1].value;
  if (auto c = typExpr-&gt;getCall()) {
    // Handle `isinstance(obj, (type1, type2, ...))`
    if (typExpr-&gt;origExpr &amp;&amp; typExpr-&gt;origExpr-&gt;getTuple()) {
      ExprPtr result = transform(N&lt;BoolExpr&gt;(false));
      for (auto &amp;i : typExpr-&gt;origExpr-&gt;getTuple()-&gt;items) {
        result = transform(N&lt;BinaryExpr&gt;(
            result, "||",
            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("isinstance"), expr-&gt;args[0].value, i)));
      }
      return result;
    }
  }

  expr-&gt;staticValue.type = StaticValue::INT;
  if (typExpr-&gt;isId("Tuple") || typExpr-&gt;isId("tuple")) {
    return transform(N&lt;BoolExpr&gt;(startswith(typ-&gt;name, TYPE_TUPLE)));
  } else if (typExpr-&gt;isId("ByVal")) {
    return transform(N&lt;BoolExpr&gt;(typ-&gt;getRecord() != nullptr));
  } else if (typExpr-&gt;isId("ByRef")) {
    return transform(N&lt;BoolExpr&gt;(typ-&gt;getRecord() == nullptr));
  } else if (!typExpr-&gt;type-&gt;getUnion() &amp;&amp; typ-&gt;getUnion()) {
    auto unionTypes = typ-&gt;getUnion()-&gt;getRealizationTypes();
    int tag = -1;
    for (size_t ui = 0; ui &lt; unionTypes.size(); ui++) {
      if (typExpr-&gt;type-&gt;unify(unionTypes[ui].get(), nullptr) &gt;= 0) {
        tag = ui;
        break;
      }
    }
    if (tag == -1)
      return transform(N&lt;BoolExpr&gt;(false));
    return transform(N&lt;BinaryExpr&gt;(
        N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("__internal__.union_get_tag:0"), expr-&gt;args[0].value),
        "==", N&lt;IntExpr&gt;(tag)));
  } else if (typExpr-&gt;type-&gt;is("pyobj") &amp;&amp; !typExpr-&gt;isType()) {
    if (typ-&gt;is("pyobj")) {
      expr-&gt;staticValue.type = StaticValue::NOT_STATIC;
      return transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("std.internal.python._isinstance:0"),
                                   expr-&gt;args[0].value, expr-&gt;args[1].value));
    } else {
      return transform(N&lt;BoolExpr&gt;(false));
    }
  }

  transformType(typExpr);

  // Check super types (i.e., statically inherited) as well
  for (auto &amp;tx : getSuperTypes(typ-&gt;getClass())) {
    if (tx-&gt;unify(typExpr-&gt;type.get(), nullptr) &gt;= 0)
      return transform(N&lt;BoolExpr&gt;(true));
  }
  return transform(N&lt;BoolExpr&gt;(false));
}

/// Transform staticlen method to a static integer expression. This method supports only
/// static strings and tuple types.
ExprPtr TypecheckVisitor::transformStaticLen(CallExpr *expr) {
  expr-&gt;staticValue.type = StaticValue::INT;
  transform(expr-&gt;args[0].value);
  auto typ = expr-&gt;args[0].value-&gt;getType();

  if (auto s = typ-&gt;getStatic()) {
    // Case: staticlen on static strings
    if (s-&gt;expr-&gt;staticValue.type != StaticValue::STRING)
      E(Error::EXPECTED_STATIC_SPECIFIED, expr-&gt;args[0].value, "string");
    if (!s-&gt;expr-&gt;staticValue.evaluated)
      return nullptr;
    return transform(N&lt;IntExpr&gt;(s-&gt;expr-&gt;staticValue.getString().size()));
  }
  if (!typ-&gt;getClass())
    return nullptr;
  if (typ-&gt;getUnion()) {
    if (realize(typ))
      return transform(N&lt;IntExpr&gt;(typ-&gt;getUnion()-&gt;getRealizationTypes().size()));
    return nullptr;
  }
  if (!typ-&gt;getRecord())
    E(Error::EXPECTED_TUPLE, expr-&gt;args[0].value);
  return transform(N&lt;IntExpr&gt;(typ-&gt;getRecord()-&gt;args.size()));
}

/// Transform hasattr method to a static boolean expression.
/// This method also supports additional argument types that are used to check
/// for a matching overload (not available in Python).
ExprPtr TypecheckVisitor::transformHasAttr(CallExpr *expr) {
  expr-&gt;staticValue.type = StaticValue::INT;
  auto typ = expr-&gt;args[0].value-&gt;getType()-&gt;getClass();
  if (!typ)
    return nullptr;

</t>
<t tx="ekr.20230509083243.926">  auto member = expr-&gt;expr-&gt;type-&gt;getFunc()
                    -&gt;funcGenerics[0]
                    .type-&gt;getStatic()
                    -&gt;evaluate()
                    .getString();
  std::vector&lt;std::pair&lt;std::string, TypePtr&gt;&gt; args{{"", typ}};
  if (expr-&gt;expr-&gt;isId("hasattr:0")) {
    // Case: the first hasattr overload allows passing argument types via *args
    auto tup = expr-&gt;args[1].value-&gt;getTuple();
    seqassert(tup, "not a tuple");
    for (auto &amp;a : tup-&gt;items) {
      transform(a);
      if (!a-&gt;getType()-&gt;getClass())
        return nullptr;
      args.push_back({"", a-&gt;getType()});
    }
    auto kwtup = expr-&gt;args[2].value-&gt;origExpr-&gt;getCall();
    seqassert(expr-&gt;args[2].value-&gt;origExpr &amp;&amp; expr-&gt;args[2].value-&gt;origExpr-&gt;getCall(),
              "expected call: {}", expr-&gt;args[2].value-&gt;origExpr);
    auto kw = expr-&gt;args[2].value-&gt;origExpr-&gt;getCall();
    @others
  }

</t>
<t tx="ekr.20230509083243.927">auto kwCls =
    in(ctx-&gt;cache-&gt;classes, expr-&gt;args[2].value-&gt;getType()-&gt;getClass()-&gt;name);
seqassert(kwCls, "cannot find {}",
          expr-&gt;args[2].value-&gt;getType()-&gt;getClass()-&gt;name);
for (size_t i = 0; i &lt; kw-&gt;args.size(); i++) {
  auto &amp;a = kw-&gt;args[i].value;
  transform(a);
  if (!a-&gt;getType()-&gt;getClass())
    return nullptr;
  args.push_back({kwCls-&gt;fields[i].name, a-&gt;getType()});
}
</t>
<t tx="ekr.20230509083243.928">  bool exists = !ctx-&gt;findMethod(typ-&gt;getClass()-&gt;name, member).empty() ||
                ctx-&gt;findMember(typ-&gt;getClass()-&gt;name, member);
  if (exists &amp;&amp; args.size() &gt; 1)
    exists &amp;= findBestMethod(typ, member, args) != nullptr;
  return transform(N&lt;BoolExpr&gt;(exists));
}

/// Transform getattr method to a DotExpr.
ExprPtr TypecheckVisitor::transformGetAttr(CallExpr *expr) {
  auto funcTyp = expr-&gt;expr-&gt;type-&gt;getFunc();
  auto staticTyp = funcTyp-&gt;funcGenerics[0].type-&gt;getStatic();
  if (!staticTyp-&gt;canRealize())
    return nullptr;
  return transform(N&lt;DotExpr&gt;(expr-&gt;args[0].value, staticTyp-&gt;evaluate().getString()));
}

</t>
<t tx="ekr.20230509083243.929">/// Transform setattr method to a AssignMemberStmt.
ExprPtr TypecheckVisitor::transformSetAttr(CallExpr *expr) {
  auto funcTyp = expr-&gt;expr-&gt;type-&gt;getFunc();
  auto staticTyp = funcTyp-&gt;funcGenerics[0].type-&gt;getStatic();
  if (!staticTyp-&gt;canRealize())
    return nullptr;
  return transform(N&lt;StmtExpr&gt;(N&lt;AssignMemberStmt&gt;(expr-&gt;args[0].value,
</t>
<t tx="ekr.20230509083243.93">void CloneVisitor::visit(const ExternalFunc *v) {
  auto *res = Nt(v);
  std::vector&lt;std::string&gt; argNames;
  for (auto it = v-&gt;arg_begin(); it != v-&gt;arg_end(); ++it)
    argNames.push_back((*it)-&gt;getName());
  res-&gt;setUnmangledName(v-&gt;getUnmangledName());
  res-&gt;setGenerator(v-&gt;isGenerator());
  res-&gt;realize(cast&lt;types::FuncType&gt;(v-&gt;getType()), argNames);

  auto argIt1 = v-&gt;arg_begin();
  auto argIt2 = res-&gt;arg_begin();
  while (argIt1 != v-&gt;arg_end()) {
    forceRemap(*argIt1, *argIt2);
    ++argIt1;
    ++argIt2;
  }

  result = res;
}

</t>
<t tx="ekr.20230509083243.930">                                                   staticTyp-&gt;evaluate().getString(),
                                                   expr-&gt;args[1].value),
                               N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("NoneType"))));
}

/// Raise a compiler error.
ExprPtr TypecheckVisitor::transformCompileError(CallExpr *expr) {
  auto funcTyp = expr-&gt;expr-&gt;type-&gt;getFunc();
  auto staticTyp = funcTyp-&gt;funcGenerics[0].type-&gt;getStatic();
  if (staticTyp-&gt;canRealize())
    E(Error::CUSTOM, expr, staticTyp-&gt;evaluate().getString());
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.931">/// Convert a class to a tuple.
ExprPtr TypecheckVisitor::transformTupleFn(CallExpr *expr) {
  auto cls = expr-&gt;args.front().value-&gt;type-&gt;getClass();
  if (!cls)
    return nullptr;

  // tuple(ClassType) is a tuple type that corresponds to a class
  if (expr-&gt;args.front().value-&gt;isType()) {
    if (!realize(cls))
      return expr-&gt;clone();

    std::vector&lt;ExprPtr&gt; items;
    auto tn = generateTuple(ctx-&gt;cache-&gt;classes[cls-&gt;name].fields.size());
    for (auto &amp;ft : ctx-&gt;cache-&gt;classes[cls-&gt;name].fields) {
      auto t = ctx-&gt;instantiate(ft.type, cls);
      auto rt = realize(t);
      seqassert(rt, "cannot realize '{}' in {}", t, ft.name);
      items.push_back(NT&lt;IdExpr&gt;(t-&gt;realizedName()));
    }
    auto e = transform(NT&lt;InstantiateExpr&gt;(N&lt;IdExpr&gt;(tn), items));
    return e;
  }

  std::vector&lt;ExprPtr&gt; args;
  args.reserve(ctx-&gt;cache-&gt;classes[cls-&gt;name].fields.size());
  std::string var = ctx-&gt;cache-&gt;getTemporaryVar("tup");
  for (auto &amp;field : ctx-&gt;cache-&gt;classes[cls-&gt;name].fields)
    args.emplace_back(N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(var), field.name));

  return transform(N&lt;StmtExpr&gt;(
      N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var), expr-&gt;args.front().value),
      N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(format("{}{}", TYPE_TUPLE, args.size())), args)));
}

/// Transform type function to a type IdExpr identifier.
ExprPtr TypecheckVisitor::transformTypeFn(CallExpr *expr) {
  expr-&gt;markType();
  transform(expr-&gt;args[0].value);

  unify(expr-&gt;type, expr-&gt;args[0].value-&gt;getType());

  if (!realize(expr-&gt;type))
    return nullptr;

  auto e = NT&lt;IdExpr&gt;(expr-&gt;type-&gt;realizedName());
  e-&gt;setType(expr-&gt;type);
  e-&gt;setDone();
  return e;
}

/// Transform __realized__ function to a fully realized type identifier.
ExprPtr TypecheckVisitor::transformRealizedFn(CallExpr *expr) {
</t>
<t tx="ekr.20230509083243.932">  auto call =
      transform(N&lt;CallExpr&gt;(expr-&gt;args[0].value, N&lt;StarExpr&gt;(expr-&gt;args[1].value)));
  if (!call-&gt;getCall()-&gt;expr-&gt;type-&gt;getFunc())
    E(Error::CALL_REALIZED_FN, expr-&gt;args[0].value);
  if (auto f = realize(call-&gt;getCall()-&gt;expr-&gt;type)) {
    auto e = N&lt;IdExpr&gt;(f-&gt;getFunc()-&gt;realizedName());
    e-&gt;setType(f);
    e-&gt;setDone();
    return e;
  }
</t>
<t tx="ekr.20230509083243.933">  return nullptr;
}

/// Transform __static_print__ function to a fully realized type identifier.
ExprPtr TypecheckVisitor::transformStaticPrintFn(CallExpr *expr) {
  auto &amp;args = expr-&gt;args[0].value-&gt;getCall()-&gt;args;
  for (size_t i = 0; i &lt; args.size(); i++) {
    realize(args[i].value-&gt;type);
    fmt::print(stderr, "[static_print] {}: {} := {}{}\n", getSrcInfo(),
               FormatVisitor::apply(args[i].value),
               args[i].value-&gt;type ? args[i].value-&gt;type-&gt;debugString(1) : "-",
               args[i].value-&gt;isStatic() ? " [static]" : "");
  }
  return nullptr;
}

// Transform internal.static calls
std::pair&lt;bool, ExprPtr&gt; TypecheckVisitor::transformInternalStaticFn(CallExpr *expr) {
  if (expr-&gt;expr-&gt;isId("std.internal.static.fn_can_call")) {
    expr-&gt;staticValue.type = StaticValue::INT;
    auto typ = expr-&gt;args[0].value-&gt;getType()-&gt;getClass();
    if (!typ)
      return {true, nullptr};

    auto fn = expr-&gt;args[0].value-&gt;type-&gt;getFunc();
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());

    auto inargs = unpackTupleTypes(expr-&gt;args[1].value);
    auto kwargs = unpackTupleTypes(expr-&gt;args[2].value);
    seqassert(inargs &amp;&amp; kwargs, "bad call to fn_can_call");

    std::vector&lt;CallExpr::Arg&gt; callArgs;
    for (auto &amp;a : *inargs) {
      callArgs.push_back({a.first, std::make_shared&lt;NoneExpr&gt;()}); // dummy expression
      callArgs.back().value-&gt;setType(a.second);
    }
    for (auto &amp;a : *kwargs) {
      callArgs.push_back({a.first, std::make_shared&lt;NoneExpr&gt;()}); // dummy expression
      callArgs.back().value-&gt;setType(a.second);
    }
    return {true, transform(N&lt;BoolExpr&gt;(canCall(fn, callArgs) &gt;= 0))};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_arg_has_type")) {
    expr-&gt;staticValue.type = StaticValue::INT;
    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());
    auto idx = ctx-&gt;getStaticInt(expr-&gt;expr-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type);
    seqassert(idx, "expected a static integer");
    auto &amp;args = fn-&gt;getArgTypes();
    return {true, transform(N&lt;BoolExpr&gt;(*idx &gt;= 0 &amp;&amp; *idx &lt; args.size() &amp;&amp;
                                        args[*idx]-&gt;canRealize()))};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_arg_get_type")) {
    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());
    auto idx = ctx-&gt;getStaticInt(expr-&gt;expr-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type);
    seqassert(idx, "expected a static integer");
    auto &amp;args = fn-&gt;getArgTypes();
    if (*idx &lt; 0 || *idx &gt;= args.size() || !args[*idx]-&gt;canRealize())
      error("argument does not have type");
    return {true, transform(NT&lt;IdExpr&gt;(args[*idx]-&gt;realizedName()))};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_args")) {
    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());
    std::vector&lt;ExprPtr&gt; v;
    for (size_t i = 0; i &lt; fn-&gt;ast-&gt;args.size(); i++) {
      auto n = fn-&gt;ast-&gt;args[i].name;
      trimStars(n);
      n = ctx-&gt;cache-&gt;rev(n);
      v.push_back(N&lt;StringExpr&gt;(n));
    }
    return {true, transform(N&lt;TupleExpr&gt;(v))};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_has_default")) {
    expr-&gt;staticValue.type = StaticValue::INT;
    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());
    auto idx = ctx-&gt;getStaticInt(expr-&gt;expr-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type);
    seqassert(idx, "expected a static integer");
    auto &amp;args = fn-&gt;ast-&gt;args;
    if (*idx &lt; 0 || *idx &gt;= args.size())
      error("argument out of bounds");
    return {true, transform(N&lt;IntExpr&gt;(args[*idx].defaultValue != nullptr))};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_get_default")) {
    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());
    auto idx = ctx-&gt;getStaticInt(expr-&gt;expr-&gt;type-&gt;getFunc()-&gt;funcGenerics[0].type);
    seqassert(idx, "expected a static integer");
    auto &amp;args = fn-&gt;ast-&gt;args;
    if (*idx &lt; 0 || *idx &gt;= args.size())
      error("argument out of bounds");
    return {true, transform(args[*idx].defaultValue)};
  } else if (expr-&gt;expr-&gt;isId("std.internal.static.fn_wrap_call_args")) {
    auto typ = expr-&gt;args[0].value-&gt;getType()-&gt;getClass();
    if (!typ)
      return {true, nullptr};

    auto fn = ctx-&gt;extractFunction(expr-&gt;args[0].value-&gt;type);
    if (!fn)
      error("expected a function, got '{}'", expr-&gt;args[0].value-&gt;type-&gt;prettyString());

    std::vector&lt;CallExpr::Arg&gt; callArgs;
    if (auto tup = expr-&gt;args[1].value-&gt;origExpr-&gt;getTuple()) {
      for (auto &amp;a : tup-&gt;items) {
        callArgs.push_back({"", a});
      }
    }
    if (auto kw = expr-&gt;args[1].value-&gt;origExpr-&gt;getCall()) {
      auto kwCls = in(ctx-&gt;cache-&gt;classes, expr-&gt;getType()-&gt;getClass()-&gt;name);
      seqassert(kwCls, "cannot find {}", expr-&gt;getType()-&gt;getClass()-&gt;name);
      for (size_t i = 0; i &lt; kw-&gt;args.size(); i++) {
        callArgs.push_back({kwCls-&gt;fields[i].name, kw-&gt;args[i].value});
      }
    }
    auto zzz = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(fn-&gt;ast-&gt;name), callArgs));
    if (!zzz-&gt;isDone())
      return {true, nullptr};

    std::vector&lt;ExprPtr&gt; tupArgs;
    for (auto &amp;a : zzz-&gt;getCall()-&gt;args)
      tupArgs.push_back(a.value);
    return {true, transform(N&lt;TupleExpr&gt;(tupArgs))};
  } else {
    return {false, nullptr};
  }
}

/// Get the list that describes the inheritance hierarchy of a given type.
/// The first type in the list is the most recently inherited type.
std::vector&lt;ClassTypePtr&gt; TypecheckVisitor::getSuperTypes(const ClassTypePtr &amp;cls) {
  std::vector&lt;ClassTypePtr&gt; result;
  if (!cls)
    return result;

  result.push_back(cls);
  for (auto &amp;name : ctx-&gt;cache-&gt;classes[cls-&gt;name].staticParentClasses) {
    auto parentTyp = ctx-&gt;instantiate(ctx-&gt;forceFind(name)-&gt;type)-&gt;getClass();
    for (auto &amp;field : ctx-&gt;cache-&gt;classes[cls-&gt;name].fields) {
      for (auto &amp;parentField : ctx-&gt;cache-&gt;classes[name].fields)
        if (field.name == parentField.name) {
          unify(ctx-&gt;instantiate(field.type, cls),
                ctx-&gt;instantiate(parentField.type, parentTyp));
          break;
        }
    }
    for (auto &amp;t : getSuperTypes(parentTyp))
      result.push_back(t);
  }
  return result;
}

</t>
<t tx="ekr.20230509083243.934">/// Find all generics on which a function depends on and add them to the current
/// context.
void TypecheckVisitor::addFunctionGenerics(const FuncType *t) {
  for (auto parent = t-&gt;funcParent; parent;) {
    if (auto f = parent-&gt;getFunc()) {
      // Add parent function generics
      for (auto &amp;g : f-&gt;funcGenerics) {
        // LOG("   -&gt; {} := {}", g.name, g.type-&gt;debugString(true));
        ctx-&gt;add(TypecheckItem::Type, g.name, g.type);
      }
      parent = f-&gt;funcParent;
    } else {
      // Add parent class generics
      seqassert(parent-&gt;getClass(), "not a class: {}", parent);
      for (auto &amp;g : parent-&gt;getClass()-&gt;generics) {
        // LOG("   =&gt; {} := {}", g.name, g.type-&gt;debugString(true));
        ctx-&gt;add(TypecheckItem::Type, g.name, g.type);
      }
      for (auto &amp;g : parent-&gt;getClass()-&gt;hiddenGenerics) {
        // LOG("   :&gt; {} := {}", g.name, g.type-&gt;debugString(true));
        ctx-&gt;add(TypecheckItem::Type, g.name, g.type);
      }
      break;
    }
  }
  // Add function generics
  for (auto &amp;g : t-&gt;funcGenerics) {
    // LOG("   &gt;&gt; {} := {}", g.name, g.type-&gt;debugString(true));
    ctx-&gt;add(TypecheckItem::Type, g.name, g.type);
  }
}

</t>
<t tx="ekr.20230509083243.935">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.936">/// Parse a class (type) declaration and add a (generic) type to the context.
void TypecheckVisitor::visit(ClassStmt *stmt) {
  // Extensions are not possible after the simplification
  seqassert(!stmt-&gt;attributes.has(Attr::Extend), "invalid extension '{}'", stmt-&gt;name);
  // Type should be constructed only once
  stmt-&gt;setDone();

  @others
  typ-&gt;setSrcInfo(stmt-&gt;getSrcInfo());
  // Classes should always be visible, so add them to the toplevel
  ctx-&gt;addToplevel(stmt-&gt;name,
                   std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Type, typ));

  // Handle generics
  for (const auto &amp;a : stmt-&gt;args) {
    if (a.status != Param::Normal) {
      // Generic and static types
      auto generic = ctx-&gt;getUnbound();
      generic-&gt;isStatic = getStaticGeneric(a.type.get());
      auto typId = generic-&gt;id;
      generic-&gt;getLink()-&gt;genericName = ctx-&gt;cache-&gt;rev(a.name);
      if (a.defaultValue) {
        auto defType = transformType(clone(a.defaultValue));
        if (a.status == Param::Generic) {
          generic-&gt;defaultType = defType-&gt;type;
        } else {
          // Hidden generics can be outright replaced (e.g., `T=int`).
          // Unify them immediately.
          unify(defType-&gt;type, generic);
        }
      }
      if (auto ti = CAST(a.type, InstantiateExpr)) {
        // Parse TraitVar
        seqassert(ti-&gt;typeExpr-&gt;isId(TYPE_TYPEVAR), "not a TypeVar instantiation");
        auto l = transformType(ti-&gt;typeParams[0])-&gt;type;
        if (l-&gt;getLink() &amp;&amp; l-&gt;getLink()-&gt;trait)
          generic-&gt;getLink()-&gt;trait = l-&gt;getLink()-&gt;trait;
        else
          generic-&gt;getLink()-&gt;trait = std::make_shared&lt;types::TypeTrait&gt;(l);
      }
      ctx-&gt;add(TypecheckItem::Type, a.name, generic);
      ClassType::Generic g{a.name, ctx-&gt;cache-&gt;rev(a.name),
                           generic-&gt;generalize(ctx-&gt;typecheckLevel), typId};
      if (a.status == Param::Generic) {
        typ-&gt;generics.push_back(g);
      } else {
        typ-&gt;hiddenGenerics.push_back(g);
      }
    }
  }

  // Handle class members
  ctx-&gt;typecheckLevel++; // to avoid unifying generics early
  auto &amp;fields = ctx-&gt;cache-&gt;classes[stmt-&gt;name].fields;
  for (auto ai = 0, aj = 0; ai &lt; stmt-&gt;args.size(); ai++)
    if (stmt-&gt;args[ai].status == Param::Normal) {
      fields[aj].type = transformType(stmt-&gt;args[ai].type)
                            -&gt;getType()
                            -&gt;generalize(ctx-&gt;typecheckLevel - 1);
      fields[aj].type-&gt;setSrcInfo(stmt-&gt;args[ai].type-&gt;getSrcInfo());
      if (stmt-&gt;isRecord())
        typ-&gt;getRecord()-&gt;args.push_back(fields[aj].type);
      aj++;
    }
  ctx-&gt;typecheckLevel--;

  // Handle MRO
  for (auto &amp;m : ctx-&gt;cache-&gt;classes[stmt-&gt;name].mro) {
    m = transformType(m);
  }

  // Generalize generics and remove them from the context
  for (const auto &amp;g : stmt-&gt;args)
    if (g.status != Param::Normal) {
      auto generic = ctx-&gt;forceFind(g.name)-&gt;type;
      if (g.status == Param::Generic) {
        // Generalize generics. Hidden generics are linked to the class generics so
        // ignore them
        seqassert(generic &amp;&amp; generic-&gt;getLink() &amp;&amp;
                      generic-&gt;getLink()-&gt;kind != types::LinkType::Link,
                  "generic has been unified");
        generic-&gt;getLink()-&gt;kind = LinkType::Generic;
      }
      ctx-&gt;remove(g.name);
    }

  // Debug information
  LOG_REALIZE("[class] {} -&gt; {}", stmt-&gt;name, typ);
  for (auto &amp;m : ctx-&gt;cache-&gt;classes[stmt-&gt;name].fields)
    LOG_REALIZE("       - member: {}: {}", m.name, m.type);
}

</t>
<t tx="ekr.20230509083243.937">// Generate the type and add it to the context
auto typ = Type::makeType(ctx-&gt;cache, stmt-&gt;name, ctx-&gt;cache-&gt;rev(stmt-&gt;name),
                          stmt-&gt;isRecord())
               -&gt;getClass();
if (stmt-&gt;isRecord() &amp;&amp; stmt-&gt;hasAttr("__notuple__"))
  typ-&gt;getRecord()-&gt;noTuple = true;
if (stmt-&gt;isRecord() &amp;&amp; startswith(stmt-&gt;name, TYPE_PARTIAL)) {
  // Special handling of partial types (e.g., `Partial.0001.foo`)
  if (auto p = in(ctx-&gt;cache-&gt;partials, stmt-&gt;name))
    typ = std::make_shared&lt;PartialType&gt;(typ-&gt;getRecord(), p-&gt;first, p-&gt;second);
}
</t>
<t tx="ekr.20230509083243.938">/// Generate a tuple class `Tuple.N[T1,...,TN]`.
/// @param len       Tuple length (`N`)
/// @param name      Tuple name. `Tuple` by default.
///                  Can be something else (e.g., `KwTuple`)
/// @param names     Member names. By default `item1`...`itemN`.
/// @param hasSuffix Set if the tuple name should have `.N` suffix.
std::string TypecheckVisitor::generateTuple(size_t len, const std::string &amp;name,
                                            std::vector&lt;std::string&gt; names,
</t>
<t tx="ekr.20230509083243.939">                                            bool hasSuffix) {
  auto key = join(names, ";");
  std::string suffix;
  if (!names.empty()) {
    // Each set of names generates different tuple (i.e., `KwArgs[foo, bar]` is not the
    // same as `KwArgs[bar, baz]`). Cache the names and use an integer for each name
    // combination.
    if (!in(ctx-&gt;cache-&gt;generatedTuples, key))
      ctx-&gt;cache-&gt;generatedTuples[key] = int(ctx-&gt;cache-&gt;generatedTuples.size());
    suffix = format("_{}", ctx-&gt;cache-&gt;generatedTuples[key]);
  } else {
    for (size_t i = 1; i &lt;= len; i++)
      names.push_back(format("item{}", i));
  }

  auto typeName = format("{}{}", name, hasSuffix ? format("{}{}", len, suffix) : "");
  if (!ctx-&gt;find(typeName)) {
    // Generate the appropriate ClassStmt
    std::vector&lt;Param&gt; args;
    for (size_t i = 0; i &lt; len; i++)
      args.emplace_back(Param(names[i], N&lt;IdExpr&gt;(format("T{}", i + 1)), nullptr));
    for (size_t i = 0; i &lt; len; i++)
      args.emplace_back(Param(format("T{}", i + 1), N&lt;IdExpr&gt;("type"), nullptr, true));
    StmtPtr stmt = N&lt;ClassStmt&gt;(ctx-&gt;cache-&gt;generateSrcInfo(), typeName, args, nullptr,
                                std::vector&lt;ExprPtr&gt;{N&lt;IdExpr&gt;("tuple")});

  @others
            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("getattr"), N&lt;IdExpr&gt;("self"), N&lt;IdExpr&gt;("key")))));
    if (startswith(typeName, TYPE_KWTUPLE))
      stmt-&gt;getClass()-&gt;suite = getItem;

    // Simplify in the standard library context and type check
    stmt = SimplifyVisitor::apply(ctx-&gt;cache-&gt;imports[STDLIB_IMPORT].ctx, stmt,
                                  FILE_GENERATED, 0);
    stmt = TypecheckVisitor(ctx).transform(stmt);
    prependStmts-&gt;push_back(stmt);
  }
  return typeName;
}

</t>
<t tx="ekr.20230509083243.94">void CloneVisitor::visit(const InternalFunc *v) {
  auto *res = Nt(v);
  std::vector&lt;std::string&gt; argNames;
  for (auto it = v-&gt;arg_begin(); it != v-&gt;arg_end(); ++it)
    argNames.push_back((*it)-&gt;getName());
  res-&gt;setUnmangledName(v-&gt;getUnmangledName());
  res-&gt;setGenerator(v-&gt;isGenerator());
  res-&gt;realize(cast&lt;types::FuncType&gt;(v-&gt;getType()), argNames);

  auto argIt1 = v-&gt;arg_begin();
  auto argIt2 = res-&gt;arg_begin();
  while (argIt1 != v-&gt;arg_end()) {
    forceRemap(*argIt1, *argIt2);
    ++argIt1;
    ++argIt2;
  }

  res-&gt;setParentType(v-&gt;getParentType());
  result = res;
}

</t>
<t tx="ekr.20230509083243.940">  // Add getItem for KwArgs:
  //   `def __getitem__(self, key: Static[str]): return getattr(self, key)`
  auto getItem = N&lt;FunctionStmt&gt;(
      "__getitem__", nullptr,
      std::vector&lt;Param&gt;{Param{"self"}, Param{"key", N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;("Static"),
                                                                  N&lt;IdExpr&gt;("str"))}},
      N&lt;SuiteStmt&gt;(N&lt;ReturnStmt&gt;(
</t>
<t tx="ekr.20230509083243.941">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/parser/ast.h"
#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.942">/// Transform a list `[a1, ..., aN]` to the corresponding statement expression.
/// See @c transformComprehension
void TypecheckVisitor::visit(ListExpr *expr) {
  expr-&gt;setType(ctx-&gt;getUnbound());
  if ((resultExpr = transformComprehension("std.internal.types.ptr.List", "append",
                                           expr-&gt;items))) {
    resultExpr-&gt;setAttr(ExprAttr::List);
  }
}

</t>
<t tx="ekr.20230509083243.943">/// Transform a set `{a1, ..., aN}` to the corresponding statement expression.
/// See @c transformComprehension
void TypecheckVisitor::visit(SetExpr *expr) {
  expr-&gt;setType(ctx-&gt;getUnbound());
  auto name = ctx-&gt;cache-&gt;imports[STDLIB_IMPORT].ctx-&gt;forceFind("Set");
  if ((resultExpr = transformComprehension(name-&gt;canonicalName, "add", expr-&gt;items))) {
    resultExpr-&gt;setAttr(ExprAttr::Set);
  }
}

</t>
<t tx="ekr.20230509083243.944">/// Transform a dictionary `{k1: v1, ..., kN: vN}` to a corresponding statement
/// expression. See @c transformComprehension
void TypecheckVisitor::visit(DictExpr *expr) {
  expr-&gt;setType(ctx-&gt;getUnbound());
  auto name = ctx-&gt;cache-&gt;imports[STDLIB_IMPORT].ctx-&gt;forceFind("Dict");
  if ((resultExpr =
           transformComprehension(name-&gt;canonicalName, "__setitem__", expr-&gt;items))) {
    resultExpr-&gt;setAttr(ExprAttr::Dict);
  }
}

</t>
<t tx="ekr.20230509083243.945">/// Transform a collection of type `type` to a statement expression:
///   `[a1, ..., aN]` -&gt; `cont = [type](); (cont.[fn](a1); ...); cont`
/// Any star-expression within the collection will be expanded:
///   `[a, *b]` -&gt; `cont.[fn](a); for i in b: cont.[fn](i)`.
/// @example
///   `[a, *b, c]`  -&gt; ```cont = List(3)
///                       cont.append(a)
///                       for i in b: cont.append(i)
///                       cont.append(c)```
///   `{a, *b, c}`  -&gt; ```cont = Set()
///                       cont.add(a)
///                       for i in b: cont.add(i)
///                       cont.add(c)```
///   `{a: 1, **d}` -&gt; ```cont = Dict()
///                       cont.__setitem__((a, 1))
///                       for i in b.items(): cont.__setitem__((i[0], i[i]))```
ExprPtr TypecheckVisitor::transformComprehension(const std::string &amp;type,
</t>
<t tx="ekr.20230509083243.946">                                                 const std::string &amp;fn,
                                                 std::vector&lt;ExprPtr&gt; &amp;items) {
  @others
  TypePtr collectionTyp = ctx-&gt;getUnbound();
  bool done = true;
  bool isDict = endswith(type, "Dict");
  for (auto &amp;i : items) {
    ClassTypePtr typ = nullptr;
    if (!isDict &amp;&amp; i-&gt;getStar()) {
      auto star = i-&gt;getStar();
      star-&gt;what = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(star-&gt;what, "__iter__")));
      if (star-&gt;what-&gt;type-&gt;is("Generator"))
        typ = star-&gt;what-&gt;type-&gt;getClass()-&gt;generics[0].type-&gt;getClass();
    } else if (isDict &amp;&amp; CAST(i, KeywordStarExpr)) {
      auto star = CAST(i, KeywordStarExpr);
      star-&gt;what = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(star-&gt;what, "items")));
      if (star-&gt;what-&gt;type-&gt;is("Generator"))
        typ = star-&gt;what-&gt;type-&gt;getClass()-&gt;generics[0].type-&gt;getClass();
    } else {
      i = transform(i);
      typ = i-&gt;type-&gt;getClass();
    }
    if (!typ) {
      done = false;
      continue;
    }
    if (!collectionTyp-&gt;getClass()) {
      unify(collectionTyp, typ);
    } else if (!isDict) {
      if (auto t = superTyp(collectionTyp-&gt;getClass(), typ))
        collectionTyp = t;
    } else {
      seqassert(collectionTyp-&gt;getRecord() &amp;&amp;
                    collectionTyp-&gt;getRecord()-&gt;args.size() == 2,
                "bad dict");
      auto tname = generateTuple(2);
      auto tt = unify(typ, ctx-&gt;instantiate(ctx-&gt;getType(tname)))-&gt;getRecord();
      auto nt = collectionTyp-&gt;getRecord()-&gt;args;
      for (int di = 0; di &lt; 2; di++) {
        if (!nt[di]-&gt;getClass())
          unify(nt[di], tt-&gt;args[di]);
        else if (auto dt = superTyp(nt[di]-&gt;getClass(), tt-&gt;args[di]-&gt;getClass()))
          nt[di] = dt;
      }
      collectionTyp = ctx-&gt;instantiateGeneric(ctx-&gt;getType(tname), nt);
    }
  }
  if (!done)
    return nullptr;
  std::vector&lt;StmtPtr&gt; stmts;
  ExprPtr var = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("cont"));

  std::vector&lt;ExprPtr&gt; constructorArgs{};
  if (endswith(type, "List") &amp;&amp; !items.empty()) {
    // Optimization: pre-allocate the list with the exact number of elements
    constructorArgs.push_back(N&lt;IntExpr&gt;(items.size()));
  }
  auto t = NT&lt;IdExpr&gt;(type);
  if (isDict &amp;&amp; collectionTyp-&gt;getRecord()) {
    t-&gt;setType(
        ctx-&gt;instantiateGeneric(ctx-&gt;getType(type), collectionTyp-&gt;getRecord()-&gt;args));
  } else if (isDict) {
    t-&gt;setType(ctx-&gt;instantiate(ctx-&gt;getType(type)));
  } else {
    t-&gt;setType(ctx-&gt;instantiateGeneric(ctx-&gt;getType(type), {collectionTyp}));
  }
  stmts.push_back(
      transform(N&lt;AssignStmt&gt;(clone(var), N&lt;CallExpr&gt;(t, constructorArgs))));
  for (const auto &amp;it : items) {
    if (!isDict &amp;&amp; it-&gt;getStar()) {
      // Unpack star-expression by iterating over it
      // `*star` -&gt; `for i in star: cont.[fn](i)`
      auto star = it-&gt;getStar();
      ExprPtr forVar = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("i"));
      star-&gt;what-&gt;setAttr(ExprAttr::StarSequenceItem);
      stmts.push_back(transform(N&lt;ForStmt&gt;(
          clone(forVar), star-&gt;what,
          N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), fn), clone(forVar))))));
    } else if (isDict &amp;&amp; CAST(it, KeywordStarExpr)) {
      // Expand kwstar-expression by iterating over it: see the example above
      auto star = CAST(it, KeywordStarExpr);
      ExprPtr forVar = N&lt;IdExpr&gt;(ctx-&gt;cache-&gt;getTemporaryVar("it"));
      star-&gt;what-&gt;setAttr(ExprAttr::StarSequenceItem);
      stmts.push_back(transform(N&lt;ForStmt&gt;(
          clone(forVar), star-&gt;what,
          N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), fn),
                                  N&lt;IndexExpr&gt;(clone(forVar), N&lt;IntExpr&gt;(0)),
                                  N&lt;IndexExpr&gt;(clone(forVar), N&lt;IntExpr&gt;(1)))))));
    } else {
      it-&gt;setAttr(ExprAttr::SequenceItem);
      if (isDict) {
        stmts.push_back(transform(N&lt;ExprStmt&gt;(
            N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), fn), N&lt;IndexExpr&gt;(it, N&lt;IntExpr&gt;(0)),
                        N&lt;IndexExpr&gt;(it, N&lt;IntExpr&gt;(1))))));
      } else {
        stmts.push_back(
            transform(N&lt;ExprStmt&gt;(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(clone(var), fn), it))));
      }
    }
  }
  return transform(N&lt;StmtExpr&gt;(stmts, var));
}

</t>
<t tx="ekr.20230509083243.947">// Deduce the super type of the collection--- in other words, the least common
// ancestor of all types in the collection. For example, `type([1, 1.2]) == type([1.2,
// 1]) == float` because float is an "ancestor" of int.
auto superTyp = [&amp;](const ClassTypePtr &amp;collectionCls,
  @others
</t>
<t tx="ekr.20230509083243.948">                  const ClassTypePtr &amp;ti) -&gt; ClassTypePtr {
if (!collectionCls)
  return ti;
if (collectionCls-&gt;is("int") &amp;&amp; ti-&gt;is("float")) {
  // Rule: int derives from float
  return ti;
} else if (collectionCls-&gt;name != TYPE_OPTIONAL &amp;&amp; ti-&gt;name == TYPE_OPTIONAL) {
  // Rule: T derives from Optional[T]
  return ctx-&gt;instantiateGeneric(ctx-&gt;getType("Optional"), {collectionCls})
      -&gt;getClass();
} else if (!collectionCls-&gt;is("pyobj") &amp;&amp; ti-&gt;is("pyobj")) {
  // Rule: anything derives from pyobj
  return ti;
} else if (collectionCls-&gt;name != ti-&gt;name) {
  // Rule: subclass derives from superclass
  auto &amp;mros = ctx-&gt;cache-&gt;classes[collectionCls-&gt;name].mro;
  for (size_t i = 1; i &lt; mros.size(); i++) {
    auto t = ctx-&gt;instantiate(mros[i]-&gt;type, collectionCls);
    if (t-&gt;unify(ti.get(), nullptr) &gt;= 0) {
      return ti;
      break;
    }
  }
}
return nullptr;
  };

</t>
<t tx="ekr.20230509083243.949">/// Transform tuples.
/// Generate tuple classes (e.g., `Tuple.N`) if not available.
/// @example
///   `(a1, ..., aN)` -&gt; `Tuple.N.__new__(a1, ..., aN)`
void TypecheckVisitor::visit(TupleExpr *expr) {
  expr-&gt;setType(ctx-&gt;getUnbound());
  for (int ai = 0; ai &lt; expr-&gt;items.size(); ai++)
    if (auto star = expr-&gt;items[ai]-&gt;getStar()) {
      // Case: unpack star expressions (e.g., `*arg` -&gt; `arg.item1, arg.item2, ...`)
      transform(star-&gt;what);
      auto typ = star-&gt;what-&gt;type-&gt;getClass();
      while (typ &amp;&amp; typ-&gt;is(TYPE_OPTIONAL)) {
        star-&gt;what = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(FN_UNWRAP), star-&gt;what));
        typ = star-&gt;what-&gt;type-&gt;getClass();
      }
      if (!typ)
        return; // continue later when the type becomes known
      if (!typ-&gt;getRecord())
        E(Error::CALL_BAD_UNPACK, star, typ-&gt;prettyString());
      auto &amp;ff = ctx-&gt;cache-&gt;classes[typ-&gt;name].fields;
      for (int i = 0; i &lt; typ-&gt;getRecord()-&gt;args.size(); i++, ai++) {
        expr-&gt;items.insert(expr-&gt;items.begin() + ai,
                           transform(N&lt;DotExpr&gt;(clone(star-&gt;what), ff[i].name)));
      }
      // Remove the star
      expr-&gt;items.erase(expr-&gt;items.begin() + ai);
      ai--;
    } else {
      expr-&gt;items[ai] = transform(expr-&gt;items[ai]);
    }
  auto tupleName = generateTuple(expr-&gt;items.size());
  resultExpr =
      transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(tupleName, "__new__"), clone(expr-&gt;items)));
  unify(expr-&gt;type, resultExpr-&gt;type);
}

</t>
<t tx="ekr.20230509083243.95">void CloneVisitor::visit(const LLVMFunc *v) {
  auto *res = Nt(v);
  std::vector&lt;std::string&gt; argNames;
  for (auto it = v-&gt;arg_begin(); it != v-&gt;arg_end(); ++it)
    argNames.push_back((*it)-&gt;getName());
  res-&gt;setUnmangledName(v-&gt;getUnmangledName());
  res-&gt;setGenerator(v-&gt;isGenerator());
  res-&gt;realize(cast&lt;types::FuncType&gt;(v-&gt;getType()), argNames);

  auto argIt1 = v-&gt;arg_begin();
  auto argIt2 = res-&gt;arg_begin();
  while (argIt1 != v-&gt;arg_end()) {
    forceRemap(*argIt1, *argIt2);
    ++argIt1;
    ++argIt2;
  }

  res-&gt;setLLVMBody(v-&gt;getLLVMBody());
  res-&gt;setLLVMDeclarations(v-&gt;getLLVMDeclarations());
  res-&gt;setLLVMLiterals(
      std::vector&lt;types::Generic&gt;(v-&gt;literal_begin(), v-&gt;literal_end()));
  result = res;
}

</t>
<t tx="ekr.20230509083243.950">/// Transform a tuple generator expression.
/// @example
///   `tuple(expr for i in tuple_generator)` -&gt; `Tuple.N.__new__(expr...)`
void TypecheckVisitor::visit(GeneratorExpr *expr) {
  seqassert(expr-&gt;kind == GeneratorExpr::Generator &amp;&amp; expr-&gt;loops.size() == 1 &amp;&amp;
                expr-&gt;loops[0].conds.empty(),
            "invalid tuple generator");

  unify(expr-&gt;type, ctx-&gt;getUnbound());

  auto gen = transform(expr-&gt;loops[0].gen);
  if (!gen-&gt;type-&gt;canRealize())
    return; // Wait until the iterator can be realized

  auto block = N&lt;SuiteStmt&gt;();
  // `tuple = tuple_generator`
  auto tupleVar = ctx-&gt;cache-&gt;getTemporaryVar("tuple");
  block-&gt;stmts.push_back(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(tupleVar), gen));

  seqassert(expr-&gt;loops[0].vars-&gt;getId(), "tuple() not simplified");
  std::vector&lt;std::string&gt; vars{expr-&gt;loops[0].vars-&gt;getId()-&gt;value};
  @others
  if (vars.size() &gt; 1)
    vars.erase(vars.begin());
  auto [ok, staticItems] =
      transformStaticLoopCall(vars, expr-&gt;loops[0].gen, [&amp;](StmtPtr wrap) {
        return N&lt;StmtExpr&gt;(wrap, clone(expr-&gt;expr));
      });
  if (ok) {
    std::vector&lt;ExprPtr&gt; tupleItems;
    for (auto &amp;i : staticItems)
      tupleItems.push_back(std::dynamic_pointer_cast&lt;Expr&gt;(i));
    resultExpr = transform(N&lt;StmtExpr&gt;(block, N&lt;TupleExpr&gt;(tupleItems)));
    return;
  } else if (oldSuite) {
    expr-&gt;expr-&gt;getStmtExpr()-&gt;stmts[0] = oldSuite;
  }

  auto tuple = gen-&gt;type-&gt;getRecord();
  if (!tuple ||
      !(startswith(tuple-&gt;name, TYPE_TUPLE) || startswith(tuple-&gt;name, TYPE_KWTUPLE)))
    E(Error::CALL_BAD_ITER, gen, gen-&gt;type-&gt;prettyString());

  // `a := tuple[i]; expr...` for each i
  std::vector&lt;ExprPtr&gt; items;
  items.reserve(tuple-&gt;args.size());
  for (int ai = 0; ai &lt; tuple-&gt;args.size(); ai++) {
    items.emplace_back(
        N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(clone(expr-&gt;loops[0].vars),
                                  N&lt;IndexExpr&gt;(N&lt;IdExpr&gt;(tupleVar), N&lt;IntExpr&gt;(ai))),
                    clone(expr-&gt;expr)));
  }

  // `((a := tuple[0]; expr), (a := tuple[1]; expr), ...)`
  resultExpr = transform(N&lt;StmtExpr&gt;(block, N&lt;TupleExpr&gt;(items)));
}

</t>
<t tx="ekr.20230509083243.951">auto suiteVec = expr-&gt;expr-&gt;getStmtExpr()
                    ? expr-&gt;expr-&gt;getStmtExpr()-&gt;stmts[0]-&gt;getSuite()
                    : nullptr;
auto oldSuite = suiteVec ? suiteVec-&gt;clone() : nullptr;
for (int validI = 0; suiteVec &amp;&amp; validI &lt; suiteVec-&gt;stmts.size(); validI++) {
  if (auto a = suiteVec-&gt;stmts[validI]-&gt;getAssign())
    if (a-&gt;rhs &amp;&amp; a-&gt;rhs-&gt;getIndex())
      if (a-&gt;rhs-&gt;getIndex()-&gt;expr-&gt;isId(vars[0])) {
        vars.push_back(a-&gt;lhs-&gt;getId()-&gt;value);
        suiteVec-&gt;stmts[validI] = nullptr;
        continue;
      }
  break;
}
</t>
<t tx="ekr.20230509083243.952">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.953">/// Call `ready` and `notReady` depending whether the provided static expression can be
/// evaluated or not.
template &lt;typename TT, typename TF&gt;
  @others
</t>
<t tx="ekr.20230509083243.954">auto evaluateStaticCondition(const ExprPtr &amp;cond, TT ready, TF notReady) {
seqassertn(cond-&gt;isStatic(), "not a static condition");
if (cond-&gt;staticValue.evaluated) {
  bool isTrue = false;
  if (cond-&gt;staticValue.type == StaticValue::STRING)
    isTrue = !cond-&gt;staticValue.getString().empty();
  else
    isTrue = cond-&gt;staticValue.getInt();
  return ready(isTrue);
} else {
  return notReady();
}
}

</t>
<t tx="ekr.20230509083243.955">/// Typecheck if expressions. Evaluate static if blocks if possible.
/// Also wrap the condition with `__bool__()` if needed and wrap both conditional
/// expressions. See @c wrapExpr for more details.
void TypecheckVisitor::visit(IfExpr *expr) {
  transform(expr-&gt;cond);

  // Static if evaluation
  if (expr-&gt;cond-&gt;isStatic()) {
    resultExpr = evaluateStaticCondition(
        expr-&gt;cond,
        [&amp;](bool isTrue) {
          LOG_TYPECHECK("[static::cond] {}: {}", getSrcInfo(), isTrue);
          return transform(isTrue ? expr-&gt;ifexpr : expr-&gt;elsexpr);
        },
        [&amp;]() -&gt; ExprPtr {
          // Check if both subexpressions are static; if so, this if expression is also
          // static and should be marked as such
          auto i = transform(clone(expr-&gt;ifexpr));
          auto e = transform(clone(expr-&gt;elsexpr));
          if (i-&gt;isStatic() &amp;&amp; e-&gt;isStatic()) {
            expr-&gt;staticValue.type = i-&gt;staticValue.type;
            unify(expr-&gt;type,
                  ctx-&gt;getType(expr-&gt;staticValue.type == StaticValue::INT ? "int"
                                                                          : "str"));
          }
          return nullptr;
        });
    if (resultExpr)
      unify(expr-&gt;type, resultExpr-&gt;getType());
    else
      unify(expr-&gt;type, ctx-&gt;getUnbound());
    return;
  }

  transform(expr-&gt;ifexpr);
  transform(expr-&gt;elsexpr);
  // Add __bool__ wrapper
  while (expr-&gt;cond-&gt;type-&gt;getClass() &amp;&amp; !expr-&gt;cond-&gt;type-&gt;is("bool"))
    expr-&gt;cond = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(expr-&gt;cond, "__bool__")));
  // Add wrappers and unify both sides
  wrapExpr(expr-&gt;elsexpr, expr-&gt;ifexpr-&gt;getType(), nullptr, /*allowUnwrap*/ false);
  wrapExpr(expr-&gt;ifexpr, expr-&gt;elsexpr-&gt;getType(), nullptr, /*allowUnwrap*/ false);
  unify(expr-&gt;type, expr-&gt;ifexpr-&gt;getType());
  unify(expr-&gt;type, expr-&gt;elsexpr-&gt;getType());

  if (expr-&gt;cond-&gt;isDone() &amp;&amp; expr-&gt;ifexpr-&gt;isDone() &amp;&amp; expr-&gt;elsexpr-&gt;isDone())
    expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.956">/// Typecheck if statements. Evaluate static if blocks if possible.
/// Also wrap the condition with `__bool__()` if needed.
/// See @c wrapExpr for more details.
void TypecheckVisitor::visit(IfStmt *stmt) {
  transform(stmt-&gt;cond);

  // Static if evaluation
  if (stmt-&gt;cond-&gt;isStatic()) {
    resultStmt = evaluateStaticCondition(
        stmt-&gt;cond,
        [&amp;](bool isTrue) {
          LOG_TYPECHECK("[static::cond] {}: {}", getSrcInfo(), isTrue);
          auto t = transform(isTrue ? stmt-&gt;ifSuite : stmt-&gt;elseSuite);
          return t ? t : transform(N&lt;SuiteStmt&gt;());
        },
        [&amp;]() -&gt; StmtPtr { return nullptr; });
    return;
  }

  while (stmt-&gt;cond-&gt;type-&gt;getClass() &amp;&amp; !stmt-&gt;cond-&gt;type-&gt;is("bool"))
    stmt-&gt;cond = transform(N&lt;CallExpr&gt;(N&lt;DotExpr&gt;(stmt-&gt;cond, "__bool__")));
  ctx-&gt;blockLevel++;
  transform(stmt-&gt;ifSuite);
  transform(stmt-&gt;elseSuite);
  ctx-&gt;blockLevel--;

  if (stmt-&gt;cond-&gt;isDone() &amp;&amp; (!stmt-&gt;ifSuite || stmt-&gt;ifSuite-&gt;isDone()) &amp;&amp;
      (!stmt-&gt;elseSuite || stmt-&gt;elseSuite-&gt;isDone()))
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.957">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "ctx.h"

#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;unordered_map&gt;
#include &lt;vector&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/format/format.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

TypeContext::TypeContext(Cache *cache)
    : Context&lt;TypecheckItem&gt;(""), cache(cache), typecheckLevel(0), age(0),
      blockLevel(0), returnEarly(false), changedNodes(0) {
  realizationBases.push_back({"", nullptr, nullptr});
  pushSrcInfo(cache-&gt;generateSrcInfo()); // Always have srcInfo() around
}

std::shared_ptr&lt;TypecheckItem&gt; TypeContext::add(TypecheckItem::Kind kind,
@others
std::shared_ptr&lt;int64_t&gt; TypeContext::getStaticInt(types::TypePtr t) {
  if (auto s = t-&gt;getStatic()) {
    auto r = s-&gt;evaluate();
    if (r.type == StaticValue::INT)
      return std::make_shared&lt;int64_t&gt;(r.getInt());
  }
  return nullptr;
}

types::FuncTypePtr TypeContext::extractFunction(types::TypePtr t) {
  if (auto f = t-&gt;getFunc())
    return f;
  if (auto p = t-&gt;getPartial())
    return p-&gt;func;
  return nullptr;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.958">                                                const std::string &amp;name,
                                                const types::TypePtr &amp;type) {
  auto t = std::make_shared&lt;TypecheckItem&gt;(kind, type);
  add(name, t);
  return t;
}

</t>
<t tx="ekr.20230509083243.959">std::shared_ptr&lt;TypecheckItem&gt; TypeContext::find(const std::string &amp;name) const {
  if (auto t = Context&lt;TypecheckItem&gt;::find(name))
    return t;
  if (in(cache-&gt;globals, name))
    return std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Var, getUnbound());
  return nullptr;
}

std::shared_ptr&lt;TypecheckItem&gt; TypeContext::forceFind(const std::string &amp;name) const {
  auto t = find(name);
  seqassert(t, "cannot find '{}'", name);
  return t;
}

types::TypePtr TypeContext::getType(const std::string &amp;name) const {
  return forceFind(name)-&gt;type;
}

TypeContext::RealizationBase *TypeContext::getRealizationBase() {
  return &amp;(realizationBases.back());
}

size_t TypeContext::getRealizationDepth() const { return realizationBases.size(); }

std::string TypeContext::getRealizationStackName() const {
  if (realizationBases.empty())
    return "";
  std::vector&lt;std::string&gt; s;
  for (auto &amp;b : realizationBases)
    if (b.type)
      s.push_back(b.type-&gt;realizedName());
  return join(s, ":");
}

std::shared_ptr&lt;types::LinkType&gt; TypeContext::getUnbound(const SrcInfo &amp;srcInfo,
</t>
<t tx="ekr.20230509083243.96">void CloneVisitor::visit(const VarValue *v) { result = Nt(v, clone(v-&gt;getVar())); }

void CloneVisitor::visit(const PointerValue *v) { result = Nt(v, clone(v-&gt;getVar())); }

</t>
<t tx="ekr.20230509083243.960">                                                         int level) const {
</t>
<t tx="ekr.20230509083243.961">  auto typ = std::make_shared&lt;types::LinkType&gt;(cache, types::LinkType::Unbound,
                                               cache-&gt;unboundCount++, level, nullptr);
  typ-&gt;setSrcInfo(srcInfo);
  return typ;
}

std::shared_ptr&lt;types::LinkType&gt; TypeContext::getUnbound(const SrcInfo &amp;srcInfo) const {
  return getUnbound(srcInfo, typecheckLevel);
}

</t>
<t tx="ekr.20230509083243.962">std::shared_ptr&lt;types::LinkType&gt; TypeContext::getUnbound() const {
  return getUnbound(getSrcInfo(), typecheckLevel);
}

types::TypePtr TypeContext::instantiate(const SrcInfo &amp;srcInfo,
</t>
<t tx="ekr.20230509083243.963">                                        const types::TypePtr &amp;type,
  @others
</t>
<t tx="ekr.20230509083243.964">                                      const types::ClassTypePtr &amp;generics) {
seqassert(type, "type is null");
std::unordered_map&lt;int, types::TypePtr&gt; genericCache;
if (generics) {
  for (auto &amp;g : generics-&gt;generics)
    if (g.type &amp;&amp;
        !(g.type-&gt;getLink() &amp;&amp; g.type-&gt;getLink()-&gt;kind == types::LinkType::Generic)) {
      genericCache[g.id] = g.type;
    }
}
auto t = type-&gt;instantiate(typecheckLevel, &amp;(cache-&gt;unboundCount), &amp;genericCache);
for (auto &amp;i : genericCache) {
  if (auto l = i.second-&gt;getLink()) {
    i.second-&gt;setSrcInfo(srcInfo);
    if (l-&gt;defaultType)
      pendingDefaults.insert(i.second);
  }
}
if (t-&gt;getUnion() &amp;&amp; !t-&gt;getUnion()-&gt;isSealed()) {
  t-&gt;setSrcInfo(srcInfo);
  pendingDefaults.insert(t);
}
return t;
}

</t>
<t tx="ekr.20230509083243.965">types::TypePtr
TypeContext::instantiateGeneric(const SrcInfo &amp;srcInfo, const types::TypePtr &amp;root,
</t>
<t tx="ekr.20230509083243.966">                                const std::vector&lt;types::TypePtr&gt; &amp;generics) {
  auto c = root-&gt;getClass();
  seqassert(c, "root class is null");
  // dummy generic type
  auto g = std::make_shared&lt;types::ClassType&gt;(cache, "", "");
  if (generics.size() != c-&gt;generics.size()) {
    E(Error::GENERICS_MISMATCH, srcInfo, cache-&gt;rev(c-&gt;name), c-&gt;generics.size(),
      generics.size());
  }
  for (int i = 0; i &lt; c-&gt;generics.size(); i++) {
    seqassert(c-&gt;generics[i].type, "generic is null");
    g-&gt;generics.emplace_back("", "", generics[i], c-&gt;generics[i].id);
  }
  return instantiate(srcInfo, root, g);
}

</t>
<t tx="ekr.20230509083243.967">std::vector&lt;types::FuncTypePtr&gt; TypeContext::findMethod(const std::string &amp;typeName,
</t>
<t tx="ekr.20230509083243.968">                                                        const std::string &amp;method,
  @others
</t>
<t tx="ekr.20230509083243.969">                                                      bool hideShadowed) const {
std::vector&lt;types::FuncTypePtr&gt; vv;
std::unordered_set&lt;std::string&gt; signatureLoci;

@others
if (auto cls = in(cache-&gt;classes, typeName)) {
  for (auto &amp;pt : cls-&gt;mro) {
    if (auto pc = pt-&gt;type-&gt;getClass()) {
      auto mc = in(cache-&gt;classes, pc-&gt;name);
      seqassert(mc, "class '{}' not found", pc-&gt;name);
      populate(*mc);
    }
  }
}
return vv;
}

</t>
<t tx="ekr.20230509083243.97">void CloneVisitor::visit(const SeriesFlow *v) {
  auto *res = Nt(v);
  for (auto *c : *v)
    res-&gt;push_back(clone(c));
  result = res;
}

</t>
<t tx="ekr.20230509083243.970">auto populate = [&amp;](const auto &amp;cls) {
  auto t = in(cls.methods, method);
  if (!t)
    return;
  auto mt = cache-&gt;overloads[*t];
  for (int mti = int(mt.size()) - 1; mti &gt;= 0; mti--) {
    auto &amp;method = mt[mti];
    if (endswith(method.name, ":dispatch") || !cache-&gt;functions[method.name].type)
      continue;
    if (method.age &lt;= age) {
      if (hideShadowed) {
        auto sig = cache-&gt;functions[method.name].ast-&gt;signature();
        if (!in(signatureLoci, sig)) {
          signatureLoci.insert(sig);
          vv.emplace_back(cache-&gt;functions[method.name].type);
        }
      } else {
        vv.emplace_back(cache-&gt;functions[method.name].type);
      }
    }
  }
};
</t>
<t tx="ekr.20230509083243.971">types::TypePtr TypeContext::findMember(const std::string &amp;typeName,
</t>
<t tx="ekr.20230509083243.972">                                       const std::string &amp;member) const {
  if (auto cls = in(cache-&gt;classes, typeName)) {
    for (auto &amp;pt : cls-&gt;mro) {
      if (auto pc = pt-&gt;type-&gt;getClass()) {
        auto mc = in(cache-&gt;classes, pc-&gt;name);
        seqassert(mc, "class '{}' not found", pc-&gt;name);
        for (auto &amp;mm : mc-&gt;fields) {
          if (mm.name == member)
            return mm.type;
        }
      }
    }
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.973">int TypeContext::reorderNamedArgs(types::FuncType *func,
  @others
</t>
<t tx="ekr.20230509083243.974">                                const std::vector&lt;CallExpr::Arg&gt; &amp;args,
@others
</t>
<t tx="ekr.20230509083243.975">                                const ReorderDoneFn &amp;onDone,
@others
</t>
<t tx="ekr.20230509083243.976">                                const ReorderErrorFn &amp;onError,
@others
</t>
<t tx="ekr.20230509083243.977">                                const std::vector&lt;char&gt; &amp;known) {
// See https://docs.python.org/3.6/reference/expressions.html#calls for details.
// Final score:
//  - +1 for each matched argument
//  -  0 for *args/**kwargs/default arguments
//  - -1 for failed match
int score = 0;

@others
// 1. Assign positional arguments to slots
// Each slot contains a list of arg's indices
std::vector&lt;std::vector&lt;int&gt;&gt; slots(func-&gt;ast-&gt;args.size());
seqassert(known.empty() || func-&gt;ast-&gt;args.size() == known.size(),
          "bad 'known' string");
std::vector&lt;int&gt; extra;
std::map&lt;std::string, int&gt; namedArgs,
    extraNamedArgs; // keep the map--- we need it sorted!
for (int ai = 0, si = 0; ai &lt; args.size() - partial; ai++) {
  if (args[ai].name.empty()) {
    while (!known.empty() &amp;&amp; si &lt; slots.size() &amp;&amp; known[si])
      si++;
    if (si &lt; slots.size() &amp;&amp; (starArgIndex == -1 || si &lt; starArgIndex))
      slots[si++] = {ai};
    else
      extra.emplace_back(ai);
  } else {
    namedArgs[args[ai].name] = ai;
  }
}
score += 2 * int(slots.size() - func-&gt;funcGenerics.size());

for (auto ai : std::vector&lt;int&gt;{std::max(starArgIndex, kwstarArgIndex),
                                std::min(starArgIndex, kwstarArgIndex)})
  if (ai != -1 &amp;&amp; !slots[ai].empty()) {
    extra.insert(extra.begin(), ai);
    slots[ai].clear();
  }

// 2. Assign named arguments to slots
if (!namedArgs.empty()) {
  std::map&lt;std::string, int&gt; slotNames;
  for (int i = 0; i &lt; func-&gt;ast-&gt;args.size(); i++)
    if (known.empty() || !known[i]) {
      slotNames[cache-&gt;reverseIdentifierLookup[func-&gt;ast-&gt;args[i].name]] = i;
    }
  for (auto &amp;n : namedArgs) {
    if (!in(slotNames, n.first))
      extraNamedArgs[n.first] = n.second;
    else if (slots[slotNames[n.first]].empty())
      slots[slotNames[n.first]].push_back(n.second);
    else
      return onError(Error::CALL_REPEATED_NAME, args[n.second].value-&gt;getSrcInfo(),
                     Emsg(Error::CALL_REPEATED_NAME, n.first));
  }
}

// 3. Fill in *args, if present
if (!extra.empty() &amp;&amp; starArgIndex == -1)
  return onError(Error::CALL_ARGS_MANY, getSrcInfo(),
                 Emsg(Error::CALL_ARGS_MANY, cache-&gt;rev(func-&gt;ast-&gt;name),
                      func-&gt;ast-&gt;args.size(), args.size() - partial));

if (starArgIndex != -1)
  slots[starArgIndex] = extra;

// 4. Fill in **kwargs, if present
if (!extraNamedArgs.empty() &amp;&amp; kwstarArgIndex == -1)
  return onError(Error::CALL_ARGS_INVALID,
                 args[extraNamedArgs.begin()-&gt;second].value-&gt;getSrcInfo(),
                 Emsg(Error::CALL_ARGS_INVALID, extraNamedArgs.begin()-&gt;first,
                      cache-&gt;rev(func-&gt;ast-&gt;name)));
if (kwstarArgIndex != -1)
  for (auto &amp;e : extraNamedArgs)
    slots[kwstarArgIndex].push_back(e.second);

// 5. Fill in the default arguments
for (auto i = 0; i &lt; func-&gt;ast-&gt;args.size(); i++)
  if (slots[i].empty() &amp;&amp; i != starArgIndex &amp;&amp; i != kwstarArgIndex) {
    if (func-&gt;ast-&gt;args[i].status == Param::Normal &amp;&amp;
        (func-&gt;ast-&gt;args[i].defaultValue || (!known.empty() &amp;&amp; known[i])))
      score -= 2;
    else if (!partial &amp;&amp; func-&gt;ast-&gt;args[i].status == Param::Normal)
      return onError(Error::CALL_ARGS_MISSING, getSrcInfo(),
                     Emsg(Error::CALL_ARGS_MISSING, cache-&gt;rev(func-&gt;ast-&gt;name),
                          cache-&gt;reverseIdentifierLookup[func-&gt;ast-&gt;args[i].name]));
  }
return score + onDone(starArgIndex, kwstarArgIndex, slots, partial);
}

</t>
<t tx="ekr.20230509083243.978">// 0. Find *args and **kwargs
// True if there is a trailing ellipsis (full partial: fn(all_args, ...))
bool partial = !args.empty() &amp;&amp; args.back().value-&gt;getEllipsis() &amp;&amp;
               !args.back().value-&gt;getEllipsis()-&gt;isPipeArg &amp;&amp;
               args.back().name.empty();

int starArgIndex = -1, kwstarArgIndex = -1;
for (int i = 0; i &lt; func-&gt;ast-&gt;args.size(); i++) {
  if (startswith(func-&gt;ast-&gt;args[i].name, "**"))
    kwstarArgIndex = i, score -= 2;
  else if (startswith(func-&gt;ast-&gt;args[i].name, "*"))
    starArgIndex = i, score -= 2;
}

</t>
<t tx="ekr.20230509083243.979">void TypeContext::dump(int pad) {
  @others
}

</t>
<t tx="ekr.20230509083243.98">void CloneVisitor::visit(const IfFlow *v) {
  result =
      Nt(v, clone(v-&gt;getCond()), clone(v-&gt;getTrueBranch()), clone(v-&gt;getFalseBranch()));
}

</t>
<t tx="ekr.20230509083243.980">auto ordered =
    std::map&lt;std::string, decltype(map)::mapped_type&gt;(map.begin(), map.end());
LOG("base: {}", getRealizationStackName());
for (auto &amp;i : ordered) {
  std::string s;
  auto t = i.second.front();
  LOG("{}{:.&lt;25} {}", std::string(pad * 2, ' '), i.first, t-&gt;type);
}
</t>
<t tx="ekr.20230509083243.981">std::string TypeContext::debugInfo() {
  return fmt::format("[{}:i{}@{}]", getRealizationBase()-&gt;name,
                     getRealizationBase()-&gt;iteration, getSrcInfo());
}

std::shared_ptr&lt;std::pair&lt;std::vector&lt;types::TypePtr&gt;, std::vector&lt;types::TypePtr&gt;&gt;&gt;
TypeContext::getFunctionArgs(types::TypePtr t) {
  if (!t-&gt;getFunc())
    return nullptr;
  auto fn = t-&gt;getFunc();
</t>
<t tx="ekr.20230509083243.982">  auto ret = std::make_shared&lt;
      std::pair&lt;std::vector&lt;types::TypePtr&gt;, std::vector&lt;types::TypePtr&gt;&gt;&gt;();
  for (auto &amp;t : fn-&gt;funcGenerics)
    ret-&gt;first.push_back(t.type);
  for (auto &amp;t : fn-&gt;generics[0].type-&gt;getRecord()-&gt;args)
    ret-&gt;second.push_back(t);
  return ret;
}

std::shared_ptr&lt;std::string&gt; TypeContext::getStaticString(types::TypePtr t) {
  if (auto s = t-&gt;getStatic()) {
    auto r = s-&gt;evaluate();
    if (r.type == StaticValue::STRING)
      return std::make_shared&lt;std::string&gt;(r.getString());
  }
  return nullptr;
}

</t>
<t tx="ekr.20230509083243.983">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#pragma once

#include &lt;memory&gt;
#include &lt;stack&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

#include "codon/parser/cache.h"
#include "codon/parser/common.h"
#include "codon/parser/ctx.h"

namespace codon::ast {

/**
 * Typecheck context identifier.
 * Can be either a function, a class (type), or a variable.
 */
struct TypecheckItem {
  /// Identifier kind
  enum Kind { Func, Type, Var } kind;
  /// Type
  types::TypePtr type;

  TypecheckItem(Kind k, types::TypePtr type) : kind(k), type(std::move(type)) {}

  /* Convenience getters */
  bool isType() const { return kind == Type; }
  bool isVar() const { return kind == Var; }
};

/** Context class that tracks identifiers during the typechecking. **/
struct TypeContext : public Context&lt;TypecheckItem&gt; {
  /// A pointer to the shared cache.
  Cache *cache;

  /// A realization base definition. Each function realization defines a new base scope.
  /// Used to properly realize enclosed functions and to prevent mess with mutually
  /// recursive enclosed functions.
  struct RealizationBase {
    /// Function name
    std::string name;
    /// Function type
    types::TypePtr type;
    /// The return type of currently realized function
    types::TypePtr returnType = nullptr;
    /// Typechecking iteration
    int iteration = 0;
  };
  std::vector&lt;RealizationBase&gt; realizationBases;

  /// The current type-checking level (for type instantiation and generalization).
  int typecheckLevel;
  std::set&lt;types::TypePtr&gt; pendingDefaults;
  int changedNodes;

  /// The age of the currently parsed statement.
  int age;
  /// Number of nested realizations. Used to prevent infinite instantiations.
  int realizationDepth;
  /// Nested default argument calls. Used to prevent infinite CallExpr chains
  /// (e.g. class A: def __init__(a: A = A())).
  std::set&lt;std::string&gt; defaultCallDepth;

  /// Number of nested blocks (0 for toplevel)
  int blockLevel;
  /// True if an early return is found (anything afterwards won't be typechecked)
  bool returnEarly;
  /// Stack of static loop control variables (used to emulate goto statements).
  std::vector&lt;std::string&gt; staticLoops;

public:
  explicit TypeContext(Cache *cache);

  using Context&lt;TypecheckItem&gt;::add;
  /// Convenience method for adding an object to the context.
  std::shared_ptr&lt;TypecheckItem&gt; add(TypecheckItem::Kind kind, const std::string &amp;name,
                                     const types::TypePtr &amp;type = nullptr);
  std::shared_ptr&lt;TypecheckItem&gt;
  addToplevel(const std::string &amp;name, const std::shared_ptr&lt;TypecheckItem&gt; &amp;item) {
    map[name].push_front(item);
    return item;
  }
  std::shared_ptr&lt;TypecheckItem&gt; find(const std::string &amp;name) const override;
  /// Find an internal type. Assumes that it exists.
  std::shared_ptr&lt;TypecheckItem&gt; forceFind(const std::string &amp;name) const;
  types::TypePtr getType(const std::string &amp;name) const;

  /// Pretty-print the current context state.
  void dump() override { dump(0); }

public:
  /// Get the current realization depth (i.e., the number of nested realizations).
  size_t getRealizationDepth() const;
  /// Get the current base.
  RealizationBase *getRealizationBase();
  /// Get the name of the current realization stack (e.g., `fn1:fn2:...`).
  std::string getRealizationStackName() const;

public:
  /// Create an unbound type with the provided typechecking level.
  std::shared_ptr&lt;types::LinkType&gt; getUnbound(const SrcInfo &amp;info, int level) const;
  std::shared_ptr&lt;types::LinkType&gt; getUnbound(const SrcInfo &amp;info) const;
  std::shared_ptr&lt;types::LinkType&gt; getUnbound() const;

  /// Call `type-&gt;instantiate`.
  /// Prepare the generic instantiation table with the given generics parameter.
  /// Example: when instantiating List[T].foo, generics=List[int].foo will ensure that
  ///          T=int.
  /// @param expr Expression that needs the type. Used to set type's srcInfo.
  /// @param setActive If True, add unbounds to activeUnbounds.
  types::TypePtr instantiate(const SrcInfo &amp;info, const types::TypePtr &amp;type,
                             const types::ClassTypePtr &amp;generics = nullptr);
  types::TypePtr instantiate(types::TypePtr type,
@others
  /// Returns the list of generic methods that correspond to typeName.method.
  std::vector&lt;types::FuncTypePtr&gt; findMethod(const std::string &amp;typeName,
                                             const std::string &amp;method,
                                             bool hideShadowed = true) const;
  /// Returns the generic type of typeName.member, if it exists (nullptr otherwise).
  /// Special cases: __elemsize__ and __atomic__.
  types::TypePtr findMember(const std::string &amp;typeName,
                            const std::string &amp;member) const;

  using ReorderDoneFn =
      std::function&lt;int(int, int, const std::vector&lt;std::vector&lt;int&gt;&gt; &amp;, bool)&gt;;
  using ReorderErrorFn = std::function&lt;int(error::Error, const SrcInfo &amp;, std::string)&gt;;
  /// Reorders a given vector or named arguments (consisting of names and the
  /// corresponding types) according to the signature of a given function.
  /// Returns the reordered vector and an associated reordering score (missing
  /// default arguments' score is half of the present arguments).
  /// Score is -1 if the given arguments cannot be reordered.
  /// @param known Bitmask that indicated if an argument is already provided
  ///              (partial function) or not.
  int reorderNamedArgs(types::FuncType *func, const std::vector&lt;CallExpr::Arg&gt; &amp;args,
                       const ReorderDoneFn &amp;onDone, const ReorderErrorFn &amp;onError,
                       const std::vector&lt;char&gt; &amp;known = std::vector&lt;char&gt;());

private:
  /// Pretty-print the current context state.
  void dump(int pad);
  /// Pretty-print the current realization context.
  std::string debugInfo();

public:
  std::shared_ptr&lt;std::pair&lt;std::vector&lt;types::TypePtr&gt;, std::vector&lt;types::TypePtr&gt;&gt;&gt;
  getFunctionArgs(types::TypePtr t);
  std::shared_ptr&lt;std::string&gt; getStaticString(types::TypePtr t);
  std::shared_ptr&lt;int64_t&gt; getStaticInt(types::TypePtr t);
  types::FuncTypePtr extractFunction(types::TypePtr t);
};

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.984">                             const types::ClassTypePtr &amp;generics = nullptr) {
    return instantiate(getSrcInfo(), std::move(type), generics);
  }

</t>
<t tx="ekr.20230509083243.985">  /// Instantiate the generic type root with the provided generics.
  /// @param expr Expression that needs the type. Used to set type's srcInfo.
  types::TypePtr instantiateGeneric(const SrcInfo &amp;info, const types::TypePtr &amp;root,
                                    const std::vector&lt;types::TypePtr&gt; &amp;generics);
  types::TypePtr instantiateGeneric(types::TypePtr root,
</t>
<t tx="ekr.20230509083243.986">                                    const std::vector&lt;types::TypePtr&gt; &amp;generics) {
    return instantiateGeneric(getSrcInfo(), std::move(root), generics);
  }

</t>
<t tx="ekr.20230509083243.987">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;

namespace codon::ast {

using namespace types;

@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.988">/// Typecheck try-except statements. Handle Python exceptions separately.
/// @example
///   ```try: ...
///      except python.Error as e: ...
///      except PyExc as f: ...
///      except ValueError as g: ...
///   ``` -&gt; ```
///      try: ...
///      except ValueError as g: ...                   # ValueError
///      except PyExc as exc:
///        while True:
///          if isinstance(exc.pytype, python.Error):  # python.Error
///            e = exc.pytype; ...; break
///          f = exc; ...; break                       # PyExc
///          raise```
void TypecheckVisitor::visit(TryStmt *stmt) {
  ctx-&gt;blockLevel++;
  transform(stmt-&gt;suite);
  ctx-&gt;blockLevel--;

  std::vector&lt;TryStmt::Catch&gt; catches;
  auto pyVar = ctx-&gt;cache-&gt;getTemporaryVar("pyexc");
  auto pyCatchStmt = N&lt;WhileStmt&gt;(N&lt;BoolExpr&gt;(true), N&lt;SuiteStmt&gt;());

  auto done = stmt-&gt;suite-&gt;isDone();
  for (auto &amp;c : stmt-&gt;catches) {
    transform(c.exc);
    if (c.exc &amp;&amp; c.exc-&gt;type-&gt;is("pyobj")) {
      // Transform python.Error exceptions
      if (!c.var.empty()) {
        c.suite = N&lt;SuiteStmt&gt;(
            N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(c.var), N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(pyVar), "pytype")),
            c.suite);
      }
      c.suite =
          N&lt;IfStmt&gt;(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("isinstance"),
                                N&lt;DotExpr&gt;(N&lt;IdExpr&gt;(pyVar), "pytype"), clone(c.exc)),
                    N&lt;SuiteStmt&gt;(c.suite, N&lt;BreakStmt&gt;()), nullptr);
      pyCatchStmt-&gt;suite-&gt;getSuite()-&gt;stmts.push_back(c.suite);
    } else if (c.exc &amp;&amp; c.exc-&gt;type-&gt;is("std.internal.types.error.PyError")) {
      // Transform PyExc exceptions
      if (!c.var.empty()) {
        c.suite =
            N&lt;SuiteStmt&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(c.var), N&lt;IdExpr&gt;(pyVar)), c.suite);
      }
      c.suite = N&lt;SuiteStmt&gt;(c.suite, N&lt;BreakStmt&gt;());
      pyCatchStmt-&gt;suite-&gt;getSuite()-&gt;stmts.push_back(c.suite);
    } else {
      // Handle all other exceptions
      transformType(c.exc);
      if (!c.var.empty()) {
        // Handle dominated except bindings
        auto changed = in(ctx-&gt;cache-&gt;replacements, c.var);
        while (auto s = in(ctx-&gt;cache-&gt;replacements, c.var))
          c.var = s-&gt;first, changed = s;
        if (changed &amp;&amp; changed-&gt;second) {
          auto update =
              N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(format("{}.__used__", c.var)), N&lt;BoolExpr&gt;(true));
          update-&gt;setUpdate();
          c.suite = N&lt;SuiteStmt&gt;(update, c.suite);
        }
        if (changed)
          c.exc-&gt;setAttr(ExprAttr::Dominated);
        auto val = ctx-&gt;find(c.var);
        if (!changed)
          val = ctx-&gt;add(TypecheckItem::Var, c.var, c.exc-&gt;getType());
        unify(val-&gt;type, c.exc-&gt;getType());
      }
      ctx-&gt;blockLevel++;
      transform(c.suite);
      ctx-&gt;blockLevel--;
      done &amp;= (!c.exc || c.exc-&gt;isDone()) &amp;&amp; c.suite-&gt;isDone();
      catches.push_back(c);
    }
  }
  if (!pyCatchStmt-&gt;suite-&gt;getSuite()-&gt;stmts.empty()) {
    // Process PyError catches
    auto exc = NT&lt;IdExpr&gt;("std.internal.types.error.PyError");
    pyCatchStmt-&gt;suite-&gt;getSuite()-&gt;stmts.push_back(N&lt;ThrowStmt&gt;(nullptr));
    TryStmt::Catch c{pyVar, transformType(exc), pyCatchStmt};

    auto val = ctx-&gt;add(TypecheckItem::Var, pyVar, c.exc-&gt;getType());
    unify(val-&gt;type, c.exc-&gt;getType());
    ctx-&gt;blockLevel++;
    transform(c.suite);
    ctx-&gt;blockLevel--;
    done &amp;= (!c.exc || c.exc-&gt;isDone()) &amp;&amp; c.suite-&gt;isDone();
    catches.push_back(c);
  }
  stmt-&gt;catches = catches;
  if (stmt-&gt;finally) {
    ctx-&gt;blockLevel++;
    transform(stmt-&gt;finally);
    ctx-&gt;blockLevel--;
    done &amp;= stmt-&gt;finally-&gt;isDone();
  }

  if (done)
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.989">/// Transform `raise` statements.
/// @example
///   `raise exc` -&gt; ```raise __internal__.set_header(exc, "fn", "file", line, col)```
void TypecheckVisitor::visit(ThrowStmt *stmt) {
  if (!stmt-&gt;expr) {
    stmt-&gt;setDone();
    return;
  }

  transform(stmt-&gt;expr);

  if (!(stmt-&gt;expr-&gt;getCall() &amp;&amp;
        stmt-&gt;expr-&gt;getCall()-&gt;expr-&gt;isId("__internal__.set_header:0"))) {
    stmt-&gt;expr = transform(N&lt;CallExpr&gt;(
        N&lt;DotExpr&gt;(N&lt;IdExpr&gt;("__internal__"), "set_header"), stmt-&gt;expr,
        N&lt;StringExpr&gt;(ctx-&gt;getRealizationBase()-&gt;name),
        N&lt;StringExpr&gt;(stmt-&gt;getSrcInfo().file), N&lt;IntExpr&gt;(stmt-&gt;getSrcInfo().line),
        N&lt;IntExpr&gt;(stmt-&gt;getSrcInfo().col)));
  }
  if (stmt-&gt;expr-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.99">void CloneVisitor::visit(const WhileFlow *v) {
  auto *loop = Nt(v, nullptr, nullptr);
  forceRemap(v, loop);
  loop-&gt;setCond(clone(v-&gt;getCond()));
  loop-&gt;setBody(clone(v-&gt;getBody()));
  result = loop;
}

</t>
<t tx="ekr.20230509083243.990">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;string&gt;
#include &lt;tuple&gt;

#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

namespace codon::ast {

using namespace types;

@others
/// Make an empty partial call `fn(...)` for a given function.
ExprPtr TypecheckVisitor::partializeFunction(const types::FuncTypePtr &amp;fn) {
  // Create function mask
  std::vector&lt;char&gt; mask(fn-&gt;ast-&gt;args.size(), 0);
  for (int i = 0, j = 0; i &lt; fn-&gt;ast-&gt;args.size(); i++)
    if (fn-&gt;ast-&gt;args[i].status == Param::Generic) {
      if (!fn-&gt;funcGenerics[j].type-&gt;getUnbound())
        mask[i] = 1;
      j++;
    }

  // Generate partial class
  auto partialTypeName = generatePartialStub(mask, fn.get());
  std::string var = ctx-&gt;cache-&gt;getTemporaryVar("partial");
  // Generate kwtuple for potential **kwargs
  auto kwName = generateTuple(0, TYPE_KWTUPLE, {});
  // `partial = Partial.MASK((), KwTuple())`
  // (`()` for *args and `KwTuple()` for **kwargs)
  ExprPtr call =
      N&lt;StmtExpr&gt;(N&lt;AssignStmt&gt;(N&lt;IdExpr&gt;(var),
                                N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(partialTypeName), N&lt;TupleExpr&gt;(),
                                            N&lt;CallExpr&gt;(N&lt;IdExpr&gt;(kwName)))),
                  N&lt;IdExpr&gt;(var));
  call-&gt;setAttr(ExprAttr::Partial);
  transform(call);
  seqassert(call-&gt;type-&gt;getPartial(), "expected partial type");
  return call;
}

/// Generate and return `Function[Tuple.N[args...], ret]` type
std::shared_ptr&lt;RecordType&gt; TypecheckVisitor::getFuncTypeBase(size_t nargs) {
  auto baseType = ctx-&gt;instantiate(ctx-&gt;forceFind("Function")-&gt;type)-&gt;getRecord();
  unify(baseType-&gt;generics[0].type,
        ctx-&gt;instantiate(ctx-&gt;forceFind(generateTuple(nargs))-&gt;type)-&gt;getRecord());
  return baseType;
}

} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.991">/// Unify the function return type with `Generator[?]`.
/// The unbound type will be deduced from return/yield statements.
void TypecheckVisitor::visit(YieldExpr *expr) {
  unify(expr-&gt;type, ctx-&gt;getUnbound());
  unify(ctx-&gt;getRealizationBase()-&gt;returnType,
        ctx-&gt;instantiateGeneric(ctx-&gt;getType("Generator"), {expr-&gt;type}));
  if (realize(expr-&gt;type))
    expr-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.992">/// Typecheck return statements. Empty return is transformed to `return NoneType()`.
/// Also partialize functions if they are being returned.
/// See @c wrapExpr for more details.
void TypecheckVisitor::visit(ReturnStmt *stmt) {
  if (transform(stmt-&gt;expr)) {
    // Wrap expression to match the return type
    if (!ctx-&gt;getRealizationBase()-&gt;returnType-&gt;getUnbound())
      if (!wrapExpr(stmt-&gt;expr, ctx-&gt;getRealizationBase()-&gt;returnType)) {
        return;
      }

    // Special case: partialize functions if we are returning them
    if (stmt-&gt;expr-&gt;getType()-&gt;getFunc() &amp;&amp;
        !(ctx-&gt;getRealizationBase()-&gt;returnType-&gt;getClass() &amp;&amp;
          ctx-&gt;getRealizationBase()-&gt;returnType-&gt;is("Function"))) {
      stmt-&gt;expr = partializeFunction(stmt-&gt;expr-&gt;type-&gt;getFunc());
    }

    unify(ctx-&gt;getRealizationBase()-&gt;returnType, stmt-&gt;expr-&gt;type);
  } else {
    // Just set the expr for the translation stage. However, do not unify the return
    // type! This might be a `return` in a generator.
    stmt-&gt;expr = transform(N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("NoneType")));
  }

  // If we are not within conditional block, ignore later statements in this function.
  // Useful with static if statements.
  if (!ctx-&gt;blockLevel)
    ctx-&gt;returnEarly = true;

  if (stmt-&gt;expr-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.993">/// Typecheck yield statements. Empty yields assume `NoneType`.
void TypecheckVisitor::visit(YieldStmt *stmt) {
  stmt-&gt;expr = transform(stmt-&gt;expr ? stmt-&gt;expr : N&lt;CallExpr&gt;(N&lt;IdExpr&gt;("NoneType")));
  unify(ctx-&gt;getRealizationBase()-&gt;returnType,
        ctx-&gt;instantiateGeneric(ctx-&gt;getType("Generator"), {stmt-&gt;expr-&gt;type}));

  if (stmt-&gt;expr-&gt;isDone())
    stmt-&gt;setDone();
}

</t>
<t tx="ekr.20230509083243.994">/// Parse a function stub and create a corresponding generic function type.
/// Also realize built-ins and extern C functions.
void TypecheckVisitor::visit(FunctionStmt *stmt) {
  // Function should be constructed only once
  stmt-&gt;setDone();

  // Handle generics
  bool isClassMember = !stmt-&gt;attributes.parentClass.empty();
  auto explicits = std::vector&lt;ClassType::Generic&gt;();
  for (const auto &amp;a : stmt-&gt;args) {
    if (a.status == Param::Generic) {
      // Generic and static types
      auto generic = ctx-&gt;getUnbound();
      generic-&gt;isStatic = getStaticGeneric(a.type.get());
      auto typId = generic-&gt;getLink()-&gt;id;
      generic-&gt;genericName = ctx-&gt;cache-&gt;rev(a.name);
      if (a.defaultValue) {
        auto defType = transformType(clone(a.defaultValue));
        generic-&gt;defaultType = defType-&gt;type;
      }
      ctx-&gt;add(TypecheckItem::Type, a.name, generic);
      explicits.emplace_back(a.name, ctx-&gt;cache-&gt;rev(a.name),
                             generic-&gt;generalize(ctx-&gt;typecheckLevel), typId);
    }
  }

  // Prepare list of all generic types
  std::vector&lt;TypePtr&gt; generics;
  ClassTypePtr parentClass = nullptr;
  if (isClassMember &amp;&amp; stmt-&gt;attributes.has(Attr::Method)) {
    // Get class generics (e.g., T for `class Cls[T]: def foo:`)
    auto parentClassAST = ctx-&gt;cache-&gt;classes[stmt-&gt;attributes.parentClass].ast.get();
    parentClass = ctx-&gt;forceFind(stmt-&gt;attributes.parentClass)-&gt;type-&gt;getClass();
    parentClass =
        parentClass-&gt;instantiate(ctx-&gt;typecheckLevel - 1, nullptr, nullptr)-&gt;getClass();
    seqassert(parentClass, "parent class not set");
    for (int i = 0, j = 0, k = 0; i &lt; parentClassAST-&gt;args.size(); i++) {
      if (parentClassAST-&gt;args[i].status != Param::Normal) {
        generics.push_back(parentClassAST-&gt;args[i].status == Param::Generic
                               ? parentClass-&gt;generics[j++].type
                               : parentClass-&gt;hiddenGenerics[k++].type);
        ctx-&gt;add(TypecheckItem::Type, parentClassAST-&gt;args[i].name, generics.back());
      }
    }
  }
  // Add function generics
  for (const auto &amp;i : explicits)
    generics.push_back(ctx-&gt;find(i.name)-&gt;type);

  // Handle function arguments
  // Base type: `Function[[args,...], ret]`
  auto baseType = getFuncTypeBase(stmt-&gt;args.size() - explicits.size());
  ctx-&gt;typecheckLevel++;
  if (stmt-&gt;ret) {
    unify(baseType-&gt;generics[1].type, transformType(stmt-&gt;ret)-&gt;getType());
  } else {
    generics.push_back(unify(baseType-&gt;generics[1].type, ctx-&gt;getUnbound()));
  }
  // Unify base type generics with argument types
  auto argType = baseType-&gt;generics[0].type-&gt;getRecord();
  for (int ai = 0, aj = 0; ai &lt; stmt-&gt;args.size(); ai++) {
    if (stmt-&gt;args[ai].status == Param::Normal &amp;&amp; !stmt-&gt;args[ai].type) {
      if (parentClass &amp;&amp; ai == 0 &amp;&amp; ctx-&gt;cache-&gt;rev(stmt-&gt;args[ai].name) == "self") {
        // Special case: self in methods
        unify(argType-&gt;args[aj], parentClass);
      } else {
        unify(argType-&gt;args[aj], ctx-&gt;getUnbound());
      }
      generics.push_back(argType-&gt;args[aj++]);
    } else if (stmt-&gt;args[ai].status == Param::Normal &amp;&amp;
               startswith(stmt-&gt;args[ai].name, "*")) {
      // Special case: `*args: type` and `**kwargs: type`. Do not add this type to the
      // signature (as the real type is `Tuple[type, ...]`); it will be used during call
      // typechecking
      unify(argType-&gt;args[aj], ctx-&gt;getUnbound());
      generics.push_back(argType-&gt;args[aj++]);
    } else if (stmt-&gt;args[ai].status == Param::Normal) {
      unify(argType-&gt;args[aj], transformType(stmt-&gt;args[ai].type)-&gt;getType());
      generics.push_back(argType-&gt;args[aj++]);
    }
  }
  ctx-&gt;typecheckLevel--;

  // Generalize generics and remove them from the context
  for (const auto &amp;g : generics) {
    for (auto &amp;u : g-&gt;getUnbounds())
      if (u-&gt;getUnbound())
        u-&gt;getUnbound()-&gt;kind = LinkType::Generic;
  }

  @others
    seqassert(found, "cannot find matching class method for {}", stmt-&gt;name);
  }

  // Update the visited table
  // Functions should always be visible, so add them to the toplevel
  ctx-&gt;addToplevel(stmt-&gt;name,
                   std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Func, funcTyp));
  ctx-&gt;cache-&gt;functions[stmt-&gt;name].type = funcTyp;

  // Ensure that functions with @C, @force_realize, and @export attributes can be
  // realized
  if (stmt-&gt;attributes.has(Attr::ForceRealize) || stmt-&gt;attributes.has(Attr::Export) ||
      (stmt-&gt;attributes.has(Attr::C) &amp;&amp; !stmt-&gt;attributes.has(Attr::CVarArg))) {
    if (!funcTyp-&gt;canRealize())
      E(Error::FN_REALIZE_BUILTIN, stmt);
  }

  // Debug information
  LOG_REALIZE("[stmt] added func {}: {}", stmt-&gt;name, funcTyp);
}

</t>
<t tx="ekr.20230509083243.995">// Construct the type
auto funcTyp = std::make_shared&lt;FuncType&gt;(
    baseType, ctx-&gt;cache-&gt;functions[stmt-&gt;name].ast.get(), explicits);

funcTyp-&gt;setSrcInfo(getSrcInfo());
if (isClassMember &amp;&amp; stmt-&gt;attributes.has(Attr::Method)) {
  funcTyp-&gt;funcParent = ctx-&gt;find(stmt-&gt;attributes.parentClass)-&gt;type;
}
</t>
<t tx="ekr.20230509083243.996">funcTyp =
    std::static_pointer_cast&lt;FuncType&gt;(funcTyp-&gt;generalize(ctx-&gt;typecheckLevel));

// If this is a class method, update the method lookup table
if (isClassMember) {
</t>
<t tx="ekr.20230509083243.997">  auto m =
      ctx-&gt;cache-&gt;getMethod(ctx-&gt;find(stmt-&gt;attributes.parentClass)-&gt;type-&gt;getClass(),
                            ctx-&gt;cache-&gt;rev(stmt-&gt;name));
  bool found = false;
  for (auto &amp;i : ctx-&gt;cache-&gt;overloads[m])
    if (i.name == stmt-&gt;name) {
      ctx-&gt;cache-&gt;functions[i.name].type = funcTyp;
      found = true;
      break;
    }
</t>
<t tx="ekr.20230509083243.998">@path C:/Repos/codon/codon/parser/visitors/typecheck/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;limits&gt;
#include &lt;map&gt;
#include &lt;memory&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;
#include &lt;vector&gt;

#include "codon/cir/types/types.h"
#include "codon/parser/ast.h"
#include "codon/parser/common.h"
#include "codon/parser/visitors/simplify/simplify.h"
#include "codon/parser/visitors/typecheck/typecheck.h"

using fmt::format;
using namespace codon::error;

const int MAX_TYPECHECK_ITER = 1000;

namespace codon::ast {

using namespace types;

/// Unify types a (passed by reference) and b.
/// Destructive operation as it modifies both a and b. If types cannot be unified, raise
/// an error.
/// @param a Type (by reference)
/// @param b Type
/// @return a
TypePtr TypecheckVisitor::unify(TypePtr &amp;a, const TypePtr &amp;b) {
  if (!a)
    return a = b;
  seqassert(b, "rhs is nullptr");
  types::Type::Unification undo;
  if (a-&gt;unify(b.get(), &amp;undo) &gt;= 0) {
    return a;
  } else {
    undo.undo();
  }
  a-&gt;unify(b.get(), &amp;undo);
  E(Error::TYPE_UNIFY, getSrcInfo(), a-&gt;prettyString(), b-&gt;prettyString());
  return nullptr;
}

/// Infer all types within a StmtPtr. Implements the LTS-DI typechecking.
/// @param isToplevel set if typechecking the program toplevel.
StmtPtr TypecheckVisitor::inferTypes(StmtPtr result, bool isToplevel) {
  if (!result)
    return nullptr;

  for (ctx-&gt;getRealizationBase()-&gt;iteration = 1;;
       ctx-&gt;getRealizationBase()-&gt;iteration++) {
    LOG_TYPECHECK("[iter] {} :: {}", ctx-&gt;getRealizationBase()-&gt;name,
                  ctx-&gt;getRealizationBase()-&gt;iteration);
    if (ctx-&gt;getRealizationBase()-&gt;iteration &gt;= MAX_TYPECHECK_ITER)
      error(result, "cannot typecheck '{}' in reasonable time",
            ctx-&gt;cache-&gt;rev(ctx-&gt;getRealizationBase()-&gt;name));

    // Keep iterating until:
    //   (1) success: the statement is marked as done; or
    //   (2) failure: no expression or statements were marked as done during an
    //                iteration (i.e., changedNodes is zero)
    ctx-&gt;typecheckLevel++;
    auto changedNodes = ctx-&gt;changedNodes;
    ctx-&gt;changedNodes = 0;
    auto returnEarly = ctx-&gt;returnEarly;
    ctx-&gt;returnEarly = false;
    TypecheckVisitor(ctx).transform(result);
    std::swap(ctx-&gt;changedNodes, changedNodes);
    std::swap(ctx-&gt;returnEarly, returnEarly);
    ctx-&gt;typecheckLevel--;

    if (ctx-&gt;getRealizationBase()-&gt;iteration == 1 &amp;&amp; isToplevel) {
      // Realize all @force_realize functions
      for (auto &amp;f : ctx-&gt;cache-&gt;functions) {
        auto &amp;attr = f.second.ast-&gt;attributes;
        if (f.second.type &amp;&amp; f.second.realizations.empty() &amp;&amp;
            (attr.has(Attr::ForceRealize) || attr.has(Attr::Export) ||
             (attr.has(Attr::C) &amp;&amp; !attr.has(Attr::CVarArg)))) {
          seqassert(f.second.type-&gt;canRealize(), "cannot realize {}", f.first);
          realize(ctx-&gt;instantiate(f.second.type)-&gt;getFunc());
          seqassert(!f.second.realizations.empty(), "cannot realize {}", f.first);
        }
      }
    }

    if (result-&gt;isDone()) {
      break;
    } else if (changedNodes) {
      continue;
    } else {
      // Special case: nothing was changed, however there are unbound types that have
      // default values (e.g., generics with default values). Unify those types with
      // their default values and then run another round to see if anything changed.
      bool anotherRound = false;
      // Special case: return type might have default as well (e.g., Union)
      if (ctx-&gt;getRealizationBase()-&gt;returnType)
        ctx-&gt;pendingDefaults.insert(ctx-&gt;getRealizationBase()-&gt;returnType);
      for (auto &amp;unbound : ctx-&gt;pendingDefaults) {
        if (auto tu = unbound-&gt;getUnion()) {
          // Seal all dynamic unions after the iteration is over
          if (!tu-&gt;isSealed()) {
            tu-&gt;seal();
            anotherRound = true;
          }
        } else if (auto u = unbound-&gt;getLink()) {
          types::Type::Unification undo;
          if (u-&gt;defaultType &amp;&amp; u-&gt;unify(u-&gt;defaultType.get(), &amp;undo) &gt;= 0)
            anotherRound = true;
        }
      }
      ctx-&gt;pendingDefaults.clear();
      if (anotherRound)
        continue;

      // Nothing helps. Return nullptr.
      return nullptr;
    }
  }

  return result;
}

/// Realize a type and create IR type stub. If type is a function type, also realize the
/// underlying function and generate IR function stub.
/// @return realized type or nullptr if the type cannot be realized
types::TypePtr TypecheckVisitor::realize(types::TypePtr typ) {
  if (!typ || !typ-&gt;canRealize()) {
    return nullptr;
  }

  if (typ-&gt;getStatic()) {
    // Nothing to realize here
    return typ;
  }

  try {
    if (auto f = typ-&gt;getFunc()) {
      if (auto ret = realizeFunc(f.get())) {
        // Realize Function[..] type as well
        realizeType(ret-&gt;getClass().get());
        return unify(ret, typ); // Needed for return type unification
      }
    } else if (auto c = typ-&gt;getClass()) {
      auto t = realizeType(c.get());
      if (auto p = typ-&gt;getPartial()) {
        // Ensure that the partial type is preserved
        t = std::make_shared&lt;PartialType&gt;(t-&gt;getRecord(), p-&gt;func, p-&gt;known);
      }
      if (t) {
        return unify(t, typ);
      }
    }
  } catch (exc::ParserException &amp;e) {
    if (e.errorCode == Error::MAX_REALIZATION)
      throw;
    if (auto f = typ-&gt;getFunc()) {
      if (f-&gt;ast-&gt;attributes.has(Attr::HiddenFromUser)) {
        e.locations.back() = getSrcInfo();
      } else {
        std::vector&lt;std::string&gt; args;
        for (size_t i = 0, ai = 0, gi = 0; i &lt; f-&gt;ast-&gt;args.size(); i++) {
          auto an = f-&gt;ast-&gt;args[i].name;
          auto ns = trimStars(an);
          args.push_back(fmt::format("{}{}: {}", std::string(ns, '*'),
                                     ctx-&gt;cache-&gt;rev(an),
                                     f-&gt;ast-&gt;args[i].status == Param::Generic
                                         ? f-&gt;funcGenerics[gi++].type-&gt;prettyString()
                                         : f-&gt;getArgTypes()[ai++]-&gt;prettyString()));
        }
        auto name = f-&gt;ast-&gt;name;
        std::string name_args;
        if (startswith(name, "._import_")) {
          name = name.substr(9);
          auto p = name.rfind('_');
          if (p != std::string::npos)
            name = name.substr(0, p);
          name = "&lt;import " + name + "&gt;";
        } else {
          name = ctx-&gt;cache-&gt;rev(f-&gt;ast-&gt;name);
          name_args = fmt::format("({})", fmt::join(args, ", "));
        }
        e.trackRealize(fmt::format("{}{}", name, name_args), getSrcInfo());
      }

    } else {
      e.trackRealize(typ-&gt;prettyString(), getSrcInfo());
    }
    throw;
  }
  return nullptr;
}

/// Realize a type and create IR type stub.
/// @return realized type or nullptr if the type cannot be realized
types::TypePtr TypecheckVisitor::realizeType(types::ClassType *type) {
  if (!type || !type-&gt;canRealize())
    return nullptr;

  // Check if the type fields are all initialized
  // (sometimes that's not the case: e.g., `class X: x: List[X]`)
  for (auto &amp;field : ctx-&gt;cache-&gt;classes[type-&gt;name].fields) {
    if (!field.type)
      return nullptr;
  }

  // Check if the type was already realized
  if (auto r =
          in(ctx-&gt;cache-&gt;classes[type-&gt;name].realizations, type-&gt;realizedTypeName())) {
    return (*r)-&gt;type-&gt;getClass();
  }

  auto realized = type-&gt;getClass();
  if (type-&gt;getFunc()) {
    // Just realize the function stub
    realized = std::make_shared&lt;RecordType&gt;(realized, type-&gt;getFunc()-&gt;args);
  }

  // Realize generics
  for (auto &amp;e : realized-&gt;generics) {
    if (!realize(e.type))
      return nullptr;
  }

  LOG_REALIZE("[realize] ty {} -&gt; {}", realized-&gt;name, realized-&gt;realizedTypeName());

  // Realizations should always be visible, so add them to the toplevel
  ctx-&gt;addToplevel(realized-&gt;realizedTypeName(),
                   std::make_shared&lt;TypecheckItem&gt;(TypecheckItem::Type, realized));
@others
} // namespace codon::ast
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083243.999">  auto realization =
      ctx-&gt;cache-&gt;classes[realized-&gt;name].realizations[realized-&gt;realizedTypeName()] =
          std::make_shared&lt;Cache::Class::ClassRealization&gt;();
  realization-&gt;type = realized;
  realization-&gt;id = ctx-&gt;cache-&gt;classRealizationCnt++;

  // Realize tuple arguments
  if (auto tr = realized-&gt;getRecord()) {
    for (auto &amp;a : tr-&gt;args)
      realize(a);
  }

</t>
<t tx="ekr.20230509083244.1">class TestOutliner : public ir::transform::OperatorPass {
  int successes = 0;
  int failures = 0;
  ir::ReturnInstr *successesReturn = nullptr;
  ir::ReturnInstr *failuresReturn = nullptr;

  const std::string KEY = "test-outliner-pass";
  std::string getKey() const override { return KEY; }

  @others
};

</t>
<t tx="ekr.20230509083244.10">  void run(ir::Module *m) override {
    using namespace codon::ir;
    auto *capResult =
        getAnalysisResult&lt;ir::analyze::dataflow::CaptureResult&gt;(capAnalysisKey);
    for (auto *var : *m) {
      if (auto *f = cast&lt;Func&gt;(var)) {
        PartitionArgsByEscape pabe;
        f-&gt;accept(pabe);
        auto expected = pabe.expected;
        if (expected.empty())
          continue;

        auto it = capResult-&gt;results.find(f-&gt;getId());
        seqassertn(it != capResult-&gt;results.end(),
                   "function not found in capture results");
        auto received = it-&gt;second;
        seqassertn(expected.size() == received.size(),
                   "size mismatch in capture results");

        for (unsigned i = 0; i &lt; expected.size(); i++) {
          auto exp = expected[i];
          auto got = received[i];
          std::sort(exp.argCaptures.begin(), exp.argCaptures.end());
          std::sort(got.argCaptures.begin(), got.argCaptures.end());

</t>
<t tx="ekr.20230509083244.100">def __hash__(self):
    return hash((self.a, self.b, self.c))

</t>
<t tx="ekr.20230509083244.101">@codon.jit
def total(self):
    return self.a + self.b + self.c

</t>
<t tx="ekr.20230509083244.102">def test_convertible():
    assert Foo(10).total() == 1110

</t>
<t tx="ekr.20230509083244.103">def test_many():
    @others
    assert sum(1 for i in range(100000, 200000) if is_prime(i)) == 8392

</t>
<t tx="ekr.20230509083244.104">@codon.jit
def is_prime(n):
    if n &lt;= 1:
        return False
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

</t>
<t tx="ekr.20230509083244.105">def test_roundtrip():
    @others
    for _ in range(5):
        assert roundtrip(None) == None
        assert roundtrip(42) == 42
        assert roundtrip(3.14) == 3.14
        assert roundtrip(False) == False
        assert roundtrip(True) == True
        assert roundtrip('hello') == 'hello'
        assert roundtrip('') == ''
        assert roundtrip(2+3j) == 2+3j
        assert roundtrip(slice(1,2,3)) == slice(1,2,3)
        assert roundtrip([11,22,33]) == [11,22,33]
        assert roundtrip([[[42]]]) == [[[42]]]
        assert roundtrip({11,22,33}) == {11,22,33}
        assert roundtrip({11: 'one', 22: 'two', 33: 'three'}) == {11: 'one', 22: 'two', 33: 'three'}
        assert roundtrip((11,22,33)) == (11,22,33)
        assert Foo(roundtrip(Foo(123))[0]) == Foo(123)
        assert roundtrip(roundtrip) is roundtrip

</t>
<t tx="ekr.20230509083244.106">@codon.jit
def roundtrip(x):
    return x

</t>
<t tx="ekr.20230509083244.107">def test_return_type():
    @others
    r = run()
    assert type(r) == tuple
    assert type(r[0]) == int
    assert type(r[1]) == str
    assert type(r[2]) == float
    assert type(r[3]) == list
    assert len(r[3]) == 3
    assert type(r[3][0]) == int
    assert type(r[4]) == dict
    assert len(r[4].items()) == 2
    assert type(next(iter(r[4].keys()))) == str
    assert type(next(iter(r[4].values()))) == int

</t>
<t tx="ekr.20230509083244.108">@codon.jit
def run() -&gt; Tuple[int, str, float, List[int], Dict[str, int]]:
    return (1, "str", 2.45, [1, 2, 3], {"a": 1, "b": 2})

</t>
<t tx="ekr.20230509083244.109">def test_param_types():
    @others
    r = run(1, (2, 3), [4, 5, 6], dict(a=7, b=8, c=9))
    assert type(r) == int
    assert r == 45

</t>
<t tx="ekr.20230509083244.11">          bool good = (exp.returnCaptures == got.returnCaptures) &amp;&amp;
                      (exp.externCaptures == got.externCaptures) &amp;&amp;
                      (exp.argCaptures == got.argCaptures);
          pabe.calls[i]-&gt;replaceAll(m-&gt;getBool(good));
        }
      }
    }
  }
};

vector&lt;string&gt; splitLines(const string &amp;output) {
  vector&lt;string&gt; result;
  string line;
  istringstream stream(output);
  const char delim = '\n';

  while (getline(stream, line, delim))
    result.push_back(line);

  return result;
}

</t>
<t tx="ekr.20230509083244.110">@codon.jit
def run(a: int, b: Tuple[int, int], c: List[int], d: Dict[str, int]) -&gt; int:
    s = 0
    for v in [a, *b, *c, *d.values()]:
        s += v
    return s

</t>
<t tx="ekr.20230509083244.111">def test_error_handling():
    @others
    try:
        type_error()
    except codon.JITError:
        pass
    except:
        assert False
    else:
        assert False

</t>
<t tx="ekr.20230509083244.112">@codon.jit
def type_error():
    return 1 + '1'

</t>
<t tx="ekr.20230509083244.113">test_convertible()
test_many()
test_roundtrip()
test_return_type()
test_param_types()
test_error_handling()


</t>
<t tx="ekr.20230509083244.114">@codon.jit
def foo(y):
    return f"{y.__class__.__name__}; {y}"


</t>
<t tx="ekr.20230509083244.115">@codon.jit(debug=True)
def foo2(y):
    return f"{y.__class__.__name__}; {y}"

</t>
<t tx="ekr.20230509083244.116">class Foo:
    def __init__(self):
        self.x = 1

</t>
<t tx="ekr.20230509083244.117">@codon.jit
def a(x):
    return x+1

</t>
<t tx="ekr.20230509083244.118">def b(x, z):
    y = a(x)
    return y * z

</t>
<t tx="ekr.20230509083244.119">@codon.jit(pyvars=['b'])
def c(x, y):
    n = b(x,y) ** a(1)
    return n

</t>
<t tx="ekr.20230509083244.12">static pair&lt;bool, string&gt; findExpectOnLine(const string &amp;line) {
  for (auto EXPECT_STR : vector&lt;pair&lt;bool, string&gt;&gt;{
           {false, "# EXPECT: "}, {false, "#: "}, {true, "#! "}}) {
    size_t pos = line.find(EXPECT_STR.second);
    if (pos != string::npos)
      return {EXPECT_STR.first, line.substr(pos + EXPECT_STR.second.length())};
  }
  return {false, ""};
}

</t>
<t tx="ekr.20230509083244.120">def test_cross_calls():
    assert foo([None, 1]) == "List[Optional[int]]; [None, 1]"
    assert foo([1, None, 1]) == "List[Optional[int]]; [1, None, 1]"
    assert foo([1, None, 1.2]) == "List[pyobj]; [1, None, 1.2]"
    assert foo({None: 1}) == "Dict[pyobj,int]; {None: 1}"
    assert foo2([None, Foo()]).startswith("List[pyobj]; [None, &lt;__main__.Foo object at")

    assert a(3) == 4
    assert b(3, 4) == 16
    assert round(c(5, 6.1), 2) == 1339.56

</t>
<t tx="ekr.20230509083244.121">@path C:/Repos/codon/test/python/
import sys, sysconfig, os, distutils.sysconfig as du_sysconfig, itertools

@others
print(get_python_library('{}.{}'.format(sys.version_info[0], sys.version_info[1])))
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083244.122">def get_python_library(python_version):
    """Get path to the python library associated with the current python
    interpreter. Adapted from https://github.com/scikit-build/scikit-build/blob/master/skbuild/cmaker.py#L272"""
    # determine direct path to libpython
    python_library = sysconfig.get_config_var('LIBRARY')

    # if static (or nonexistent), try to find a suitable dynamic libpython
    if (not python_library or os.path.splitext(python_library)[1][-2:] == '.a'):

        candidate_lib_prefixes = ['', 'lib']

        candidate_implementations = ['python']
        if hasattr(sys, "pypy_version_info"):
            candidate_implementations = ['pypy-c', 'pypy3-c']

        candidate_extensions = ['.lib', '.so', '.a']
        if sysconfig.get_config_var('WITH_DYLD'):
            candidate_extensions.insert(0, '.dylib')

        candidate_versions = [python_version]
        if python_version:
            candidate_versions.append('')
            candidate_versions.insert(
                0, "".join(python_version.split(".")[:2]))

        abiflags = getattr(sys, 'abiflags', '')
        candidate_abiflags = [abiflags]
        if abiflags:
            candidate_abiflags.append('')

        # Ensure the value injected by virtualenv is
        # returned on windows.
        # Because calling `sysconfig.get_config_var('multiarchsubdir')`
        # returns an empty string on Linux, `du_sysconfig` is only used to
        # get the value of `LIBDIR`.
        libdir = du_sysconfig.get_config_var('LIBDIR')
        if sysconfig.get_config_var('MULTIARCH'):
            masd = sysconfig.get_config_var('multiarchsubdir')
            if masd:
                if masd.startswith(os.sep):
                    masd = masd[len(os.sep):]
                libdir = os.path.join(libdir, masd)

        if libdir is None:
            libdir = os.path.abspath(os.path.join(
                sysconfig.get_config_var('LIBDEST'), "..", "libs"))

        candidates = [
            os.path.join (sysconfig.get_config_var('LIBPL'), sysconfig.get_config_var('LDLIBRARY'))
        ] + [
            os.path.join(
                libdir,
                ''.join((pre, impl, ver, abi, ext))
            )
            for (pre, impl, ext, ver, abi) in itertools.product(
                candidate_lib_prefixes,
                candidate_implementations,
                candidate_extensions,
                candidate_versions,
                candidate_abiflags
            )
        ]

        for candidate in candidates:
            if os.path.exists(candidate):
                # we found a (likely alternate) libpython
                python_library = candidate
                break

    # TODO(opadron): what happens if we don't find a libpython?

    return python_library

</t>
<t tx="ekr.20230509083244.123">@path C:/Repos/codon/test/python/
@language unknown_language
print('Hello from Codon')

def f1(a: float = 1.11, b: float = 2.22):
    return (a, b)

def f2():
    return ({1: 'one'}, {2}, [3])

def f3(x):
    return x * 2

def f4(x):
    return x

@overload
def f4(a: float = 1.11, b: float = 2.22):
    return f1(a=a, b=b)

@overload
def f4():
    return ['f4()']

@overload
def f4(x: str):
    return x, x

def f5():
    pass

@dataclass(python=True)
class Vec:
    a: float
    b: float
    tag: str
    n: ClassVar[int] = 0
    d: ClassVar[int] = 0

    def __init__(self, a: float, b: float, tag: str):
        self.a = a
        self.b = b
        self.tag = tag

    def __init__(self, a: float = 0.0, b: float = 0.0):
        self.__init__(a, b, 'v' + str(Vec.n))
        Vec.n += 1

    def foo(self, a: float = 1.11, b: float = 2.22):
        return (self.a, a, b)

    def bar(self):
        return self

    def baz(a: float = 1.11, b: float = 2.22):
        return (a, b)

    def nop():
        return 'nop'

    @property
    def c(self):
        return self.a + self.b

    def __str__(self):
        return f'{self.tag}: &lt;{self.a}, {self.b}&gt;'

    def __repr__(self):
        return f'Vec({self.a}, {self.b}, {repr(self.tag)})'

    def __add__(self, other: Vec):
        return Vec(self.a + other.a, self.b + other.b, f'({self.tag}+{other.tag})')

    def __iadd__(self, other: Vec):
        self.a += other.a
        self.b += other.b
        self.tag = f'({self.tag}+={other.tag})'
        return self

    def __add__(self, x: float):
        return Vec(self.a + x, self.b + x, f'({self.tag}+{x})')

    def __iadd__(self, x: float):
        self.a += x
        self.b += x
        self.tag = f'({self.tag}+={x})'
        return self

    def __add__(self, x: int):
        return Vec(self.a + x, self.b + x, f'({self.tag}++{x})')

    def __sub__(self, other: Vec):
        return Vec(self.a - other.a, self.b - other.b, f'({self.tag}-{other.tag})')

    def __isub__(self, other: Vec):
        self.a -= other.a
        self.b -= other.b
        self.tag = f'({self.tag}-={other.tag})'
        return self

    def __mul__(self, x: float):
        return Vec(self.a * x, self.b * x, f'({self.tag}*{x})')

    def __imul__(self, x: float):
        self.a *= x
        self.b *= x
        self.tag = f'({self.tag}*={x})'
        return self

    def __mod__(self, x: float):
        return Vec(self.a % x, self.b % x, f'({self.tag}%{x})')

    def __imod__(self, x: float):
        self.a %= x
        self.b %= x
        self.tag = f'({self.tag}%={x})'
        return self

    def __divmod__(self, x: float):
        raise ArithmeticError('no divmod')
        # return self.a / x, self.a % x

    def __pow__(self, x: float):
        return Vec(self.a ** x, self.b ** x, f'({self.tag}**{x})')

    def __ipow__(self, x: float):
        self.a **= x
        self.b **= x
        self.tag = f'({self.tag}**={x})'
        return self

    def __neg__(self):
        return Vec(-self.a, -self.b, f'(-{self.tag})')

    def __pos__(self):
        return Vec(self.a, self.b, f'(+{self.tag})')

    def __abs__(self):
        import math
        return math.hypot(self.a, self.b)

    def __bool__(self):
        return bool(self.a) and bool(self.b)

    def __invert__(self):
        return Vec(-self.a - 1, -self.b - 1, f'(~{self.tag})')

    def __lshift__(self, x: int):
        y = 1 &lt;&lt; x
        return Vec(self.a * y, self.b * y, f'({self.tag}&lt;&lt;{x})')

    def __ilshift__(self, x: int):
        y = 1 &lt;&lt; x
        self.a *= y
        self.b *= y
        self.tag = f'({self.tag}&lt;&lt;={x})'
        return self

    def __rshift__(self, x: int):
        y = 1 &lt;&lt; x
        return Vec(self.a / y, self.b / y, f'({self.tag}&gt;&gt;{x})')

    def __irshift__(self, x: int):
        y = 1 &lt;&lt; x
        self.a /= y
        self.b /= y
        self.tag = f'({self.tag}&gt;&gt;={x})'
        return self

    def __and__(self, x: int):
        return Vec(int(self.a) &amp; x, int(self.b) &amp; x, f'({self.tag}&amp;{x})')

    def __iand__(self, x: int):
        self.a = int(self.a) &amp; x
        self.b = int(self.b) &amp; x
        self.tag = f'({self.tag}&amp;={x})'
        return self

    def __or__(self, x: int):
        return Vec(int(self.a) | x, int(self.b) | x, f'({self.tag}|{x})')

    def __ior__(self, x: int):
        self.a = int(self.a) | x
        self.b = int(self.b) | x
        self.tag = f'({self.tag}|={x})'
        return self

    def __xor__(self, x: int):
        return Vec(int(self.a) ^ x, int(self.b) ^ x, f'({self.tag}^{x})')

    def __ixor__(self, x: int):
        self.a = int(self.a) ^ x
        self.b = int(self.b) ^ x
        self.tag = f'({self.tag}^={x})'
        return self

    #def __int__(self):
    #    return int(self.b)

    #def __float__(self):
    #    return self.b

    #def __index__(self):
    #    return int(self.a)

    def __floordiv__(self, x: float):
        return Vec(self.a // x, self.b // x, f'({self.tag}//{x})')

    def __ifloordiv__(self, x: float):
        self.a //= x
        self.b //= x
        self.tag = f'({self.tag}//={x})'
        return self

    def __truediv__(self, x: float):
        return Vec(self.a / x, self.b / x, f'({self.tag}/{x})')

    def __itruediv__(self, x: float):
        self.a /= x
        self.b /= x
        self.tag = f'({self.tag}/={x})'
        return self

    def __matmul__(self, other: Vec):
        return (self.a * other.a) + (self.b * other.b)

    def __imatmul__(self, x: float):
        self.a *= x
        self.b *= x
        self.tag = f'({self.tag}@={x})'
        return self

    def __len__(self):
        return len(self.tag)

    def __getitem__(self, idx: int):
        if idx == 0:
            return self.a
        elif idx == 1:
            return self.b
        elif idx == 11:
            return self.a + self.b
        else:
            raise KeyError('bad vec key ' + str(idx))

    def __setitem__(self, idx: int, val: float):
        if idx == 0:
            self.a = val
        elif idx == 1:
            self.b = val
        elif idx == 11:
            self.a = val
            self.b = val
        else:
            raise KeyError('bad vec key ' + str(idx) + ' with val ' + str(val))

    def __delitem__(self, idx: int):
        self[idx] = 0.0

    def __contains__(self, val: float):
        return self.a == val or self.b == val

    def __contains__(self, val: str):
        return self.tag == val

    def __hash__(self):
        return int(self.a + self.b)

    def __call__(self, a: float = 1.11, b: float = 2.22):
        return self.foo(a=a, b=b)

    def __call__(self, x: str):
        return (self.a, self.b, x)

    def __call__(self):
        return Vec(self.a, self.b, f'({self.tag}())')

    def __iter__(self):
        for c in self.tag:
            yield c

    def __eq__(self, other: Vec):
        return self.a == other.a and self.b == other.b

    def __eq__(self, x: float):
        return self.a == x and self.b == x

    def __ne__(self, other: Vec):
        return self.a != other.a or self.b != other.b

    def __lt__(self, other: Vec):
        return abs(self) &lt; abs(other)

    def __le__(self, other: Vec):
        return abs(self) &lt;= abs(other)

    def __gt__(self, other: Vec):
        return abs(self) &gt; abs(other)

    def __ge__(self, other: Vec):
        return abs(self) &gt;= abs(other)

    def __del__(self):
        Vec.d += 1

    def nd():
        return Vec.d

def f6(x: float, t: str):
    return Vec(x, x, t)

def reset():
    Vec.n = 0

def par_sum(n: int):
    m = 0
    @par(num_threads=4)
    for i in range(n):
        m += 3*i + 7
    return m

@tuple
class Foo:
    a: List[str]
    x: Dict[str, int]

    def __new__(a: List[str]) -&gt; Foo:
        return (a, {s: i for i, s in enumerate(a)})

    def __iter__(self):
        return iter(self.a)

    def __repr__(self):
        return f'Foo({self.a}, {self.x})'

    def hello(self):
        return 'x'

    def __int__(self):
        return 42

    def __float__(self):
        return 3.14

    def __index__(self):
        return 99
</t>
<t tx="ekr.20230509083244.124">@path C:/Repos/codon/test/python/
@language unknown_language
print('Hello from Codon 2')

@tuple
class Vec:
    a: float
    b: float
    tag: str
    n: ClassVar[int] = 0
    d: ClassVar[int] = 0

    def __new__(a: float, b: float, tag: str) -&gt; Vec:
        return (a, b, tag)

    def __new__(a: float = 0.0, b: float = 0.0):
        v = Vec(a, b, 'v' + str(Vec.n))
        Vec.n += 1
        return v

    def foo(self, a: float = 1.11, b: float = 2.22):
        return (self.a, a, b)

    def bar(self):
        return self

    def baz(a: float = 1.11, b: float = 2.22):
        return (a, b)

    def nop():
        return 'nop'

    @property
    def c(self):
        return self.a + self.b

    def __str__(self):
        return f'{self.tag}: &lt;{self.a}, {self.b}&gt;'

    def __repr__(self):
        return f'Vec({self.a}, {self.b}, {repr(self.tag)})'

    def __add__(self, other: Vec):
        return Vec(self.a + other.a, self.b + other.b, f'({self.tag}+{other.tag})')

    def __iadd__(self, other: Vec):
        a, b = self.a, self.b
        a += other.a
        b += other.b
        tag = f'({self.tag}+={other.tag})'
        return Vec(a, b, tag)

    def __add__(self, x: float):
        return Vec(self.a + x, self.b + x, f'({self.tag}+{x})')

    def __iadd__(self, x: float):
        a, b = self.a, self.b
        a += x
        b += x
        tag = f'({self.tag}+={x})'
        return Vec(a, b, tag)

    def __add__(self, x: int):
        return Vec(self.a + x, self.b + x, f'({self.tag}++{x})')

    def __sub__(self, other: Vec):
        return Vec(self.a - other.a, self.b - other.b, f'({self.tag}-{other.tag})')

    def __isub__(self, other: Vec):
        a, b = self.a, self.b
        a -= other.a
        b -= other.b
        tag = f'({self.tag}-={other.tag})'
        return Vec(a, b, tag)

    def __mul__(self, x: float):
        return Vec(self.a * x, self.b * x, f'({self.tag}*{x})')

    def __imul__(self, x: float):
        a, b = self.a, self.b
        a *= x
        b *= x
        tag = f'({self.tag}*={x})'
        return Vec(a, b, tag)

    def __mod__(self, x: float):
        return Vec(self.a % x, self.b % x, f'({self.tag}%{x})')

    def __imod__(self, x: float):
        a, b = self.a, self.b
        a %= x
        b %= x
        tag = f'({self.tag}%={x})'
        return Vec(a, b, tag)

    def __divmod__(self, x: float):
        raise ArithmeticError('no divmod')
        # return self.a / x, self.a % x

    def __pow__(self, x: float):
        return Vec(self.a ** x, self.b ** x, f'({self.tag}**{x})')

    def __ipow__(self, x: float):
        a, b = self.a, self.b
        a **= x
        b **= x
        tag = f'({self.tag}**={x})'
        return Vec(a, b, tag)

    def __neg__(self):
        return Vec(-self.a, -self.b, f'(-{self.tag})')

    def __pos__(self):
        return Vec(self.a, self.b, f'(+{self.tag})')

    def __abs__(self):
        import math
        return math.hypot(self.a, self.b)

    def __bool__(self):
        return bool(self.a) and bool(self.b)

    def __invert__(self):
        return Vec(-self.a - 1, -self.b - 1, f'(~{self.tag})')

    def __lshift__(self, x: int):
        y = 1 &lt;&lt; x
        return Vec(self.a * y, self.b * y, f'({self.tag}&lt;&lt;{x})')

    def __ilshift__(self, x: int):
        a, b = self.a, self.b
        y = 1 &lt;&lt; x
        a *= y
        b *= y
        tag = f'({self.tag}&lt;&lt;={x})'
        return Vec(a, b, tag)

    def __rshift__(self, x: int):
        y = 1 &lt;&lt; x
        return Vec(self.a / y, self.b / y, f'({self.tag}&gt;&gt;{x})')

    def __irshift__(self, x: int):
        a, b = self.a, self.b
        y = 1 &lt;&lt; x
        a /= y
        b /= y
        tag = f'({self.tag}&gt;&gt;={x})'
        return Vec(a, b, tag)

    def __and__(self, x: int):
        return Vec(int(self.a) &amp; x, int(self.b) &amp; x, f'({self.tag}&amp;{x})')

    def __iand__(self, x: int):
        a, b = self.a, self.b
        a = int(self.a) &amp; x
        b = int(self.b) &amp; x
        tag = f'({self.tag}&amp;={x})'
        return Vec(a, b, tag)

    def __or__(self, x: int):
        return Vec(int(self.a) | x, int(self.b) | x, f'({self.tag}|{x})')

    def __ior__(self, x: int):
        a, b = self.a, self.b
        a = int(self.a) | x
        b = int(self.b) | x
        tag = f'({self.tag}|={x})'
        return Vec(a, b, tag)

    def __xor__(self, x: int):
        return Vec(int(self.a) ^ x, int(self.b) ^ x, f'({self.tag}^{x})')

    def __ixor__(self, x: int):
        a, b = self.a, self.b
        a = int(self.a) ^ x
        b = int(self.b) ^ x
        tag = f'({self.tag}^={x})'
        return Vec(a, b, tag)

    #def __int__(self):
    #    return int(self.b)

    #def __float__(self):
    #    return self.b

    #def __index__(self):
    #    return int(self.a)

    def __floordiv__(self, x: float):
        return Vec(self.a // x, self.b // x, f'({self.tag}//{x})')

    def __ifloordiv__(self, x: float):
        a, b = self.a, self.b
        a //= x
        b //= x
        tag = f'({self.tag}//={x})'
        return Vec(a, b, tag)

    def __truediv__(self, x: float):
        return Vec(self.a / x, self.b / x, f'({self.tag}/{x})')

    def __itruediv__(self, x: float):
        a, b = self.a, self.b
        a /= x
        b /= x
        tag = f'({self.tag}/={x})'
        return Vec(a, b, tag)

    def __matmul__(self, other: Vec):
        return (self.a * other.a) + (self.b * other.b)

    def __imatmul__(self, x: float):
        a, b = self.a, self.b
        a *= x
        b *= x
        tag = f'({self.tag}@={x})'
        return Vec(a, b, tag)

    def __len__(self):
        return len(self.tag)

    def __getitem__(self, idx: int):
        if idx == 0:
            return self.a
        elif idx == 1:
            return self.b
        elif idx == 11:
            return self.a + self.b
        else:
            raise KeyError('bad vec key ' + str(idx))

    def __contains__(self, val: float):
        return self.a == val or self.b == val

    def __contains__(self, val: str):
        return self.tag == val

    def __hash__(self):
        return int(self.a + self.b)

    def __call__(self, a: float = 1.11, b: float = 2.22):
        return self.foo(a=a, b=b)

    def __call__(self, x: str):
        return (self.a, self.b, x)

    def __call__(self):
        return Vec(self.a, self.b, f'({self.tag}())')

    def __iter__(self):
        for c in self.tag:
            yield c

    def __eq__(self, other: Vec):
        return self.a == other.a and self.b == other.b

    def __eq__(self, x: float):
        return self.a == x and self.b == x

    def __ne__(self, other: Vec):
        return self.a != other.a or self.b != other.b

    def __lt__(self, other: Vec):
        return abs(self) &lt; abs(other)

    def __le__(self, other: Vec):
        return abs(self) &lt;= abs(other)

    def __gt__(self, other: Vec):
        return abs(self) &gt; abs(other)

    def __ge__(self, other: Vec):
        return abs(self) &gt;= abs(other)

    def __del__(self):
        Vec.d += 1

    def nd():
        return Vec.d

def reset():
    Vec.n = 0

def par_sum(n: int):
    m = 0
    @par(num_threads=4)
    for i in range(n):
        m += 3*i + 7
    return m
</t>
<t tx="ekr.20230509083244.125">@path C:/Repos/codon/test/python/
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083244.126">def multiply(a,b):
    return a*b

</t>
<t tx="ekr.20230509083244.127">def print_args(a,b,c,d,e):
    t = (a,b,c,d,e)
    if t != ((4, 5), {'a': 3.14, 'b': 2.123}, True, {'ACGT'}, [['abc'], ['1.1', '2.2'], []]):
        raise ValueError('TEST FAILED!')
    return ({'a': 3.14, 'b': 2.123}, (222, 3.14))

</t>
<t tx="ekr.20230509083244.128">def print_args_var(a,b,c=1,*args,**kwargs):
    return 'a={}, b={}, c={}, args={}, kwargs={}'.format(a, b, c, args, kwargs)

</t>
<t tx="ekr.20230509083244.129">def throw_exc():
    raise ValueError('foo')
    return 0
</t>
<t tx="ekr.20230509083244.13">static pair&lt;vector&lt;string&gt;, bool&gt; findExpects(const string &amp;filename, bool isCode) {
  vector&lt;string&gt; result;
  bool isError = false;
  string line;
  if (!isCode) {
    ifstream file(filename);
    if (!file.good()) {
      cerr &lt;&lt; "error: could not open " &lt;&lt; filename &lt;&lt; endl;
      exit(EXIT_FAILURE);
    }

    while (getline(file, line)) {
      auto expect = findExpectOnLine(line);
      if (!expect.second.empty()) {
        result.push_back(expect.second);
        isError |= expect.first;
      }
    }
    file.close();
  } else {
    istringstream file(filename);
    while (getline(file, line)) {
      auto expect = findExpectOnLine(line);
      if (!expect.second.empty()) {
        result.push_back(expect.second);
        isError |= expect.first;
      }
    }
  }
  return {result, isError};
}

</t>
<t tx="ekr.20230509083244.130">@path C:/Repos/codon/test/python/
@language unknown_language
import python

@test
def test_basic():
    from python import mymodule
    assert str(mymodule.multiply(3, 4)) == '12'
test_basic()

@test
def test_pybridge():
    @python
    def test_pydef(n: int) -&gt; str:
        return ''.join(map(str, range(n)))
    assert test_pydef(5) == '01234'
test_pybridge()

from python import mymodule
@test
def test_conversions():
    T = tuple[dict[str,float],tuple[int,float]]
    t = mymodule.print_args(
        (4,5),
        {'a': 3.14, 'b': 2.123},
        True,
        {'ACGT'},
        [['abc'], ['1.1', '2.2'], list[str]()]
    )
    assert T.__from_py__(t.p) == ({'a': 3.14, 'b': 2.123}, (222, 3.14))
test_conversions()

@test
def test_pythrow():
    from python import mymodule.throw_exc() -&gt; None as te
    try:
        te()
    except PyError as e:
        assert python.type(e.pytype)._getattr('__name__') + ":" + e.message == "ValueError:foo"
        return
    assert False
test_pythrow()

@test
def test_pyargs():
    from python import mymodule
    assert str(mymodule.print_args_var(1, 2, 3)) == "a=1, b=2, c=3, args=(), kwargs={}"
    assert str(mymodule.print_args_var(1, z=5, b=2)) == "a=1, b=2, c=1, args=(), kwargs={'z': 5}"
    assert str(mymodule.print_args_var(1, *(1,2,3,4,5), z=5)) == "a=1, b=1, c=2, args=(3, 4, 5), kwargs={'z': 5}"
test_pyargs()

@test
def test_roundtrip(x: T, T: type):
    assert T.__from_py__(x.__to_py__()) == x

test_roundtrip(42)
test_roundtrip(3.14)
test_roundtrip(True)
test_roundtrip(False)
test_roundtrip(byte(99))
test_roundtrip('hello world')
test_roundtrip('')
test_roundtrip(List[int]())
test_roundtrip([11, 22, 33])
test_roundtrip(Set[int]())
test_roundtrip({11, 22, 33})
test_roundtrip(Dict[str,int]())
test_roundtrip({'aa': 11, 'bb': 22, 'cc': 33})
test_roundtrip((11, 1.1, '11', [1, 1], {1}, {1: 1}))
test_roundtrip(())
test_roundtrip(DynamicTuple((111, 222, 333, 444)))
test_roundtrip(DynamicTuple('hello world'))
test_roundtrip(DynamicTuple[int]())
test_roundtrip(DynamicTuple[str]())
test_roundtrip(Optional(0))
test_roundtrip(Optional(111))
test_roundtrip(Optional[int]())
test_roundtrip(None)

@test
def test_ops():
    from python import numpy as np
    a = np.array([1, 3])
    assert str(a + 1) == '[2 4]'
    assert str(a - 1) == '[0 2]'
    assert str(a * 2) == '[2 6]'
    assert str(a @ a) == '10'
    assert str(a // 2) == '[0 1]'
    assert str(a / 2) == '[0.5 1.5]'
    assert str(a % 2) == '[1 1]'
    assert str(a ** 2) == '[1 9]'
    assert str(-a) == '[-1 -3]'
    assert str(+a) == '[1 3]'
    assert str(~a) == '[-2 -4]'
    assert str(a &lt;&lt; 1) == '[2 6]'
    assert str(a &gt;&gt; 1) == '[0 1]'
    assert str(a &amp; 2) == '[0 2]'
    assert str(a ^ 2) == '[3 1]'
    assert str(a | 2) == '[3 3]'

    assert str(a &lt; 3) == '[ True False]'
    assert str(a &lt;= 3) == '[ True  True]'
    assert str(a == 3) == '[False  True]'
    assert str(a != 3) == '[ True False]'
    assert str(a &gt; 3) == '[False False]'
    assert str(a &gt;= 3) == '[False  True]'

    assert str(1 + a) == '[2 4]'
    assert str(1 - a) == '[ 0 -2]'
    assert str(2 * a) == '[2 6]'
    assert str(1 // a) == '[1 0]'
    assert str(2 &amp; a) == '[0 2]'
    assert str(2 ^ a) == '[3 1]'
    assert str(2 | a) == '[3 3]'
    n = a[0]
    assert str(10 // n) == '10'
    assert str(10 / n) == '10.0'
    assert str(10 % n) == '0'
    assert str(10 ** n) == '10'
    assert str(4 &lt;&lt; n) == '8'
    assert str(4 &gt;&gt; n) == '2'

    assert str(3 &lt; a) == '[False False]'
    assert str(3 &lt;= a) == '[False  True]'
    assert str(3 == a) == '[False  True]'
    assert str(3 != a) == '[ True False]'
    assert str(3 &gt; a) == '[ True False]'
    assert str(3 &gt;= a) == '[ True  True]'

    a = np.array([1, 3])
    b = a
    a += 1
    assert str(b) == '[2 4]'

    a = np.array([1, 3])
    b = a
    a -= 1
    assert str(b) == '[0 2]'

    a = np.array([1, 3])
    b = a
    a //= 2
    assert str(b) == '[0 1]'

    a = np.array([1.0, 3.0])
    b = a
    a /= 2
    assert str(b) == '[0.5 1.5]'

    a = np.array([1, 3])
    b = a
    a %= 2
    assert str(b) == '[1 1]'

    a = np.array([1, 3])
    b = a
    a **= 2
    assert str(b) == '[1 9]'

    a = np.array([1, 3])
    b = a
    a &lt;&lt;= 1
    assert str(b) == '[2 6]'

    a = np.array([1, 3])
    b = a
    a &gt;&gt;= 1
    assert str(b) == '[0 1]'

    a = np.array([1, 3])
    b = a
    a &amp;= 2
    assert str(b) == '[0 2]'

    a = np.array([1, 3])
    b = a
    a ^= 2
    assert str(b) == '[3 1]'

    a = np.array([1, 3])
    b = a
    a |= 2
    assert str(b) == '[3 3]'

    a = np.array([1, 3])
    n = a[-1]
    assert str(n) == '3'
    assert int(n) == 3
    assert float(n) == 3.0
    from operator import index
    assert index(n) == 3
    assert hash(n) == 3
    assert len(a) == 2
    v = list(iter(a))
    assert len(v) == 2 and v[0] == 1 and v[1] == 3
    a[-1] = 99
    assert repr(a) == 'array([ 1, 99])'
    assert bool(a[0]) == True
    assert bool(a[0] - 1) == False

test_ops()
</t>
<t tx="ekr.20230509083244.131">@path C:/Repos/codon/test/python/
import myext as m
import myext2 as m2

@others
for _ in range(3000):
    test_codon_extensions(m)
    test_codon_extensions(m2)

assert saw_fun
assert saw_set
assert saw_foo
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083244.132">def equal(v, a, b, tag):
    ok = (v.a == a and v.b == b and v.tag == tag)
    if not ok:
        print('GOT:', v.a, v.b, v.tag)
        print('EXP:', a, b, tag)
    return ok

</t>
<t tx="ekr.20230509083244.133">saw_fun = False
saw_set = False
saw_foo = False

</t>
<t tx="ekr.20230509083244.134">def test_codon_extensions(m):
    m.reset()

    # functions #
    #############

    global saw_fun

    if hasattr(m, 'f1'):
        assert m.f1(2.2, 3.3) == (2.2, 3.3)
        assert m.f1(2.2, 3.3) == (2.2, 3.3)
        assert m.f1(3.3) == (3.3, 2.22)
        assert m.f1() == (1.11, 2.22)
        assert m.f1(a=2.2, b=3.3) == (2.2, 3.3)
        assert m.f1(2.2, b=3.3) == (2.2, 3.3)
        assert m.f1(b=3.3, a=2.2) == (2.2, 3.3)
        assert m.f1(a=2.2) == (2.2, 2.22)
        assert m.f1(b=3.3) == (1.11, 3.3)

        try:
            m.f1(1.1, 2.2, 3.3)
        except:
            pass
        else:
            assert False

        try:
            m.f1(z=1)
        except:
            pass
        else:
            assert False

        assert m.f2() == ({1: 'one'}, {2}, [3])

        try:
            m.f2(1)
        except:
            pass
        else:
            assert False

        try:
            m.f2(z=1, y=5)
        except:
            pass
        else:
            assert False

        assert m.f3(42) == 84
        assert m.f3(1.5) == 3.0
        assert m.f3('x') == 'xx'

        try:
            m.f3(1, 2)
        except:
            pass
        else:
            assert False

        try:
            m.f3(a=1, b=2)
        except:
            pass
        else:
            assert False

        assert m.f4() == ['f4()']
        assert m.f4(2.2, 3.3) == (2.2, 3.3)
        assert m.f4(3.3) == (3.3, 2.22)
        assert m.f4(a=2.2, b=3.3) == (2.2, 3.3)
        assert m.f4(2.2, b=3.3) == (2.2, 3.3)
        assert m.f4(b=3.3, a=2.2) == (2.2, 3.3)
        assert m.f4(a=2.2) == (2.2, 2.22)
        assert m.f4(b=3.3) == (1.11, 3.3)
        assert m.f4('foo') == ('foo', 'foo')
        assert m.f4({1}) == {1}
        assert m.f5() is None
        assert equal(m.f6(1.9, 't'), 1.9, 1.9, 't')

        saw_fun = True

    # constructors #
    ################

    x = m.Vec(3.14, 4.2, 'x')
    y = m.Vec(100, 1000, tag='y')
    z = m.Vec(b=2.2, a=1.1)
    s = m.Vec(10)
    t = m.Vec(b=11)
    r = m.Vec(3, 4)

    assert equal(x, 3.14, 4.2, 'x')
    assert equal(y, 100, 1000, 'y')
    assert equal(z, 1.1, 2.2, 'v0')
    assert equal(s, 10, 0.0, 'v1')
    assert equal(t, 0.0, 11, 'v2')

    try:
        m.Vec(tag=10, a=1, b=2)
    except:
        pass
    else:
        assert False

    # to-str #
    ##########

    assert str(x) == 'x: &lt;3.14, 4.2&gt;'
    assert repr(x) == "Vec(3.14, 4.2, 'x')"

    # methods #
    ###########

    assert x.foo(2.2, 3.3) == (3.14, 2.2, 3.3)
    assert y.foo(3.3) == (100, 3.3, 2.22)
    assert z.foo() == (1.1, 1.11, 2.22)
    assert x.foo(a=2.2, b=3.3) == (3.14, 2.2, 3.3)
    assert x.foo(2.2, b=3.3) == (3.14, 2.2, 3.3)
    assert x.foo(b=3.3, a=2.2) == (3.14, 2.2, 3.3)
    assert x.foo(a=2.2) == (3.14, 2.2, 2.22)
    assert x.foo(b=3.3) == (3.14, 1.11, 3.3)

    try:
        x.foo(1, a=1)
    except:
        pass
    else:
        assert False

    try:
        x.foo(1, 2, b=2)
    except:
        pass
    else:
        assert False

    try:
        x.foo(1, z=2)
    except:
        pass
    else:
        assert False

    assert equal(x.bar(), 3.14, 4.2, 'x')
    assert equal(y.bar(), 100, 1000, 'y')
    assert equal(z.bar(), 1.1, 2.2, 'v0')
    assert equal(s.bar(), 10, 0.0, 'v1')
    assert equal(t.bar(), 0.0, 11, 'v2')

    try:
        x.bar(1)
    except:
        pass
    else:
        assert False

    try:
        x.bar(z=1)
    except:
        pass
    else:
        assert False

    assert m.Vec.baz(2.2, 3.3) == (2.2, 3.3)
    assert x.baz(2.2, 3.3) == (2.2, 3.3)
    assert m.Vec.baz(3.3) == (3.3, 2.22)
    assert m.Vec.baz() == (1.11, 2.22)
    assert m.Vec.baz(a=2.2, b=3.3) == (2.2, 3.3)
    assert m.Vec.baz(2.2, b=3.3) == (2.2, 3.3)
    assert m.Vec.baz(b=3.3, a=2.2) == (2.2, 3.3)
    assert m.Vec.baz(a=2.2) == (2.2, 2.22)
    assert m.Vec.baz(b=3.3) == (1.11, 3.3)

    try:
        m.Vec.baz(1, a=1)
    except:
        pass
    else:
        assert False

    try:
        m.Vec.baz(1, 2, b=2)
    except:
        pass
    else:
        assert False

    assert m.Vec.nop() == 'nop'
    assert x.nop() == 'nop'
    assert y.c == 1100

    # fields #
    ##########

    if hasattr(t, '__setitem__'):
        t.a = 99
        assert equal(t, 99, 11, 'v2')
        t.tag = 't'
        assert equal(t, 99, 11, 't')

    # magics #
    ##########

    assert equal(+y, 100, 1000, '(+y)')
    assert equal(-y, -100, -1000, '(-y)')
    assert equal(~y, -101, -1001, '(~y)')
    assert abs(r) == 5.0
    assert bool(y)
    assert not bool(m.Vec())
    assert len(x) == 1
    assert len(x + y) == 5
    assert hash(y) == 1100

    assert equal(x + y, 103.14, 1004.2, '(x+y)')
    try:
        x + 'x'
    except:
        pass
    else:
        assert False
    assert equal(x + y + y, 203.14, 2004.2, '((x+y)+y)')
    assert equal(y + 50.5, 150.5, 1050.5, '(y+50.5)')
    assert equal(y + 50, 150, 1050, '(y++50)')
    # assert equal(50.5 + y, 150.5, 1050.5, '(y+50.5)')  # support for r-magics?
    assert equal(y - x, 96.86, 995.8, '(y-x)')
    assert equal(y * 3.5, 350.0, 3500.0, '(y*3.5)')
    assert equal(y // 3, 33, 333, '(y//3)')
    assert equal(y / 2.5, 40.0, 400.0, '(y/2.5)')
    try:
        divmod(y, 1)
    except ArithmeticError as e:
        assert str(e) == 'no divmod'
    else:
        assert False
    assert equal(y % 7, 2, 6, '(y%7)')
    assert equal(y ** 2, 10000, 1000000, '(y**2)')
    assert equal(y &lt;&lt; 1, 200, 2000, '(y&lt;&lt;1)')
    assert equal(y &gt;&gt; 2, 25, 250, '(y&gt;&gt;2)')
    assert equal(y &amp; 77, 68, 72, '(y&amp;77)')
    assert equal(y | 77, 109, 1005, '(y|77)')
    assert equal(y ^ 77, 41, 933, '(y^77)')
    assert y @ r == 4300

    @others
    for n in (0, 1, 10, 33, 999, 1237):
        assert m.par_sum(n) == par_sum_check(n)

</t>
<t tx="ekr.20230509083244.135">def dup(v):
    return m.Vec(v.a, v.b, v.tag + '1')

</t>
<t tx="ekr.20230509083244.136">y1 = dup(y)
y1 += x
assert equal(y1, 103.14, 1004.2, '(y1+=x)')

y1 = dup(y)
y1 += 1.5
assert equal(y1, 101.5, 1001.5, '(y1+=1.5)')

y1 = dup(y)
y1 -= x
assert equal(y1, 96.86, 995.8, '(y1-=x)')

y1 = dup(y)
y1 *= 3.5
assert equal(y1, 350.0, 3500.0, '(y1*=3.5)')

y1 = dup(y)
y1 //= 3
assert equal(y1, 33, 333, '(y1//=3)')

y1 = dup(y)
y1 /= 2.5
assert equal(y1, 40.0, 400.0, '(y1/=2.5)')

y1 = dup(y)
y1 %= 7
assert equal(y1, 2, 6, '(y1%=7)')

y1 = dup(y)
y1 **= 2
assert equal(y1, 10000, 1000000, '(y1**=2)')

y1 = dup(y)
y1 &lt;&lt;= 1
assert equal(y1, 200, 2000, '(y1&lt;&lt;=1)')

y1 = dup(y)
y1 &gt;&gt;= 2
assert equal(y1, 25, 250, '(y1&gt;&gt;=2)')

y1 = dup(y)
y1 &amp;= 77
assert equal(y1, 68, 72, '(y1&amp;=77)')

y1 = dup(y)
y1 |= 77
assert equal(y1, 109, 1005, '(y1|=77)')

y1 = dup(y)
y1 ^= 77
assert equal(y1, 41, 933, '(y1^=77)')

y1 = dup(y)
y1 @= 3.5
assert equal(y1, 350.0, 3500.0, '(y1@=3.5)')

assert equal(y(), 100, 1000, '(y())')
assert x(2.2, 3.3) == (3.14, 2.2, 3.3)
assert y(3.3) == (100, 3.3, 2.22)
assert x(a=2.2, b=3.3) == (3.14, 2.2, 3.3)
assert x(2.2, b=3.3) == (3.14, 2.2, 3.3)
assert x(b=3.3, a=2.2) == (3.14, 2.2, 3.3)
assert x(a=2.2) == (3.14, 2.2, 2.22)
assert x(b=3.3) == (3.14, 1.11, 3.3)
assert y('foo') == (100.0, 1000.0, 'foo')

assert x == x
assert x != y
assert r == m.Vec(3, 4, '?')
assert x &lt; y
assert y &gt; x
assert x &lt;= y
assert y &gt;= x
assert y &lt;= y
assert x &gt;= x

assert list(iter(x)) == ['x']
assert list(iter(x+y+y)) == list('((x+y)+y)')

assert 100 in y
assert 1000 in y
assert 100.5 not in y
assert 'y' in y
assert 'x' not in y

assert y[0] == 100
assert y[1] == 1000
assert y[11] == 1100
try:
    y[-1]
except KeyError as e:
    assert str(e) == "'bad vec key -1'"
else:
    assert False

global saw_set
if hasattr(y, '__setitem__'):
    y[0] = 99.9
    assert equal(y, 99.9, 1000, 'y')
    y[1] = -42.6
    assert equal(y, 99.9, -42.6, 'y')
    y[11] = 7.7
    assert equal(y, 7.7, 7.7, 'y')
    try:
        y[2] = 1.2
    except KeyError as e:
        assert str(e) == "'bad vec key 2 with val 1.2'"
    else:
        assert False

    del y[1]
    assert equal(y, 7.7, 0.0, 'y')

    saw_set = True

assert m.Vec.nd() &gt; 0

# tuple classes #
#################
global saw_foo
if hasattr(m, 'Foo'):
    x = m.Foo(list('hello'))
    assert x.a == list('hello')
    assert x.x == {s: i for i, s in enumerate('hello')}
    assert x.hello() == 'x'

    try:
        x.a = ['bye']
    except AttributeError:
        pass
    else:
        assert False

    assert int(x) == 42
    assert float(x) == 3.14
    assert x.__index__() == 99
    saw_foo = True

</t>
<t tx="ekr.20230509083244.137"># Codon-specific #
##################
def par_sum_check(n):
    m = 0
    for i in range(n):
        m += 3*i + 7
    return m

</t>
<t tx="ekr.20230509083244.138">@path C:/Repos/codon/test/python/
import os
import sys
import shutil

from pathlib import Path
from setuptools import setup, Extension
from setuptools.command.build_ext import build_ext


codon_path = os.environ.get("CODON_DIR")
if not codon_path:
    c = shutil.which("codon")
    if c:
        codon_path = Path(c).parent / ".."
else:
    codon_path = Path(codon_path)
for path in [
    os.path.expanduser("~") + "/.codon",
    os.getcwd() + "/..",
]:
    path = Path(path)
    if not codon_path and path.exists():
        codon_path = path
        break

if (
    not codon_path
    or not (codon_path / "include" / "codon").exists()
    or not (codon_path / "lib" / "codon").exists()
):
    print(
        "Cannot find Codon.",
        'Please either install Codon (/bin/bash -c "$(curl -fsSL https://exaloop.io/install.sh)"),',
        "or set CODON_DIR if Codon is not in PATH or installed in ~/.codon",
        file=sys.stderr,
    )
    sys.exit(1)
codon_path = codon_path.resolve()
print("Codon: " + str(codon_path))


@others
setup(
    name='myext',
    version='0.1',
    packages=['myext'],
    ext_modules=[
        CodonExtension('myext', 'myextension.codon'),
    ],
    cmdclass={'build_ext': BuildCodonExt}
)

setup(
    name='myext2',
    version='0.1',
    packages=['myext2'],
    ext_modules=[
        CodonExtension('myext2', 'myextension2.codon'),
    ],
    cmdclass={'build_ext': BuildCodonExt}
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083244.139">class CodonExtension(Extension):
    def __init__(self, name, source):
        self.source = source
        super().__init__(name, sources=[], language='c')

</t>
<t tx="ekr.20230509083244.14">string argv0;

</t>
<t tx="ekr.20230509083244.140">class BuildCodonExt(build_ext):
    @others
</t>
<t tx="ekr.20230509083244.141">def build_extensions(self):
    pass

</t>
<t tx="ekr.20230509083244.142">def run(self):
    inplace, self.inplace = self.inplace, False
    super().run()
    for ext in self.extensions:
        self.build_codon(ext)
    if inplace:
        self.copy_extensions_to_source()

</t>
<t tx="ekr.20230509083244.143">def build_codon(self, ext):
    extension_path = Path(self.get_ext_fullpath(ext.name))
    build_dir = Path(self.build_temp)
    os.makedirs(build_dir, exist_ok=True)
    os.makedirs(extension_path.parent.absolute(), exist_ok=True)

    optimization = '-debug' if self.debug else '-release'
    self.spawn([
        str(codon_path / "bin" / "codon"), 'build', optimization, "--relocation-model=pic",
        '-pyext', '-o', str(extension_path) + ".o", '-module', ext.name, ext.source])

    print('--&gt;', extension_path)
    ext.runtime_library_dirs = [str(codon_path / "lib" / "codon")]
    self.compiler.link_shared_object(
        [str(extension_path) + ".o"],
        str(extension_path),
        libraries=["codonrt"],
        library_dirs=ext.runtime_library_dirs,
        runtime_library_dirs=ext.runtime_library_dirs,
        extra_preargs=['-Wl,-rpath,@loader_path'],
        # export_symbols=self.get_export_symbols(ext),
        debug=self.debug,
        build_temp=self.build_temp,
    )
    self.distribution.codon_lib = extension_path

</t>
<t tx="ekr.20230509083244.145"></t>
<t tx="ekr.20230509083244.146">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import bisect
import sys

li = [1, 3, 4, 4, 4, 6, 7]
lst = [10, 20, 30, 40, 50]

str = ["a", "b", "b", "c", "d"]


@test
def bisect_left():
    assert bisect.bisect_left(li, 4, 0, len(li)) == 2
    assert bisect.bisect_left(li, 4) == 2
    assert bisect.bisect_left(str, "b", 0, len(str)) == 1
    assert bisect.bisect_left(lst, 25, 1, 3) == 2

    # precomputed cases
    assert bisect.bisect_left(List[int](), 1, 0, 0) == 0
    assert bisect.bisect_left([1], 0, 0, 1) == 0
    assert bisect.bisect_left([1], 1, 0, 1) == 0
    assert bisect.bisect_left([1], 2, 0, 1) == 1
    assert bisect.bisect_left([1, 1], 0, 0, 2) == 0
    assert bisect.bisect_left([1, 1], 1, 0, 2) == 0
    assert bisect.bisect_left([1, 1], 2, 0, 2) == 2
    assert bisect.bisect_left([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect_left([1, 1, 1], 1, 0, 3) == 0
    assert bisect.bisect_left([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect_left([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 1, 1], 1, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect_left([1, 2], 0, 0, 2) == 0
    assert bisect.bisect_left([1, 2], 1, 0, 2) == 0
    assert bisect.bisect_left([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect_left([1, 2], 2, 0, 2) == 1
    assert bisect.bisect_left([1, 2], 3, 0, 2) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 2, 2], 1, 0, 4) == 0
    assert bisect.bisect_left([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 2, 0, 4) == 2
    assert bisect.bisect_left([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect_left([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect_left([1, 2, 3], 1, 0, 3) == 0
    assert bisect.bisect_left([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect_left([1, 2, 3], 2, 0, 3) == 1
    assert bisect.bisect_left([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect_left([1, 2, 3], 3, 0, 3) == 2
    assert bisect.bisect_left([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 0
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 1
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 3
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 6
    assert bisect.bisect_left([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


@test
def bisect_right():
    assert bisect.bisect_right(li, 4, 0, len(li)) == 5
    assert bisect.bisect_right(li, 4) == 5
    assert bisect.bisect_right(str, "b", 0, len(str)) == 3
    assert bisect.bisect_right(lst, 25, 1, 3) == 2

    # precomputed casesrightrt bisect.bisect_right(List[int](), 1, 0, 0) == 0
    assert bisect.bisect_right([1], 0, 0, 1) == 0
    assert bisect.bisect_right([1], 1, 0, 1) == 1
    assert bisect.bisect_right([1], 2, 0, 1) == 1
    assert bisect.bisect_right([1, 1], 0, 0, 2) == 0
    assert bisect.bisect_right([1, 1], 1, 0, 2) == 2
    assert bisect.bisect_right([1, 1], 2, 0, 2) == 2
    assert bisect.bisect_right([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect_right([1, 1, 1], 1, 0, 3) == 3
    assert bisect.bisect_right([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect_right([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect_right([1, 1, 1, 1], 1, 0, 4) == 4
    assert bisect.bisect_right([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect_right([1, 2], 0, 0, 2) == 0
    assert bisect.bisect_right([1, 2], 1, 0, 2) == 1
    assert bisect.bisect_right([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect_right([1, 2], 2, 0, 2) == 2
    assert bisect.bisect_right([1, 2], 3, 0, 2) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect_right([1, 1, 2, 2], 1, 0, 4) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect_right([1, 1, 2, 2], 2, 0, 4) == 4
    assert bisect.bisect_right([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect_right([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect_right([1, 2, 3], 1, 0, 3) == 1
    assert bisect.bisect_right([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect_right([1, 2, 3], 2, 0, 3) == 2
    assert bisect.bisect_right([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect_right([1, 2, 3], 3, 0, 3) == 3
    assert bisect.bisect_right([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 1
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 6
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 10
    assert bisect.bisect_right([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


@test
def bisect1():
    assert bisect.bisect(li, 4, 0, len(li)) == 5
    assert bisect.bisect(str, "b", 0, len(str)) == 3
    assert bisect.bisect(lst, 25, 1, 3) == 2

    # precomputed casesrightrt bisect.bisect_right(List[int](), 1, 0, 0) == 0
    assert bisect.bisect([1], 0, 0, 1) == 0
    assert bisect.bisect([1], 1, 0, 1) == 1
    assert bisect.bisect([1], 2, 0, 1) == 1
    assert bisect.bisect([1, 1], 0, 0, 2) == 0
    assert bisect.bisect([1, 1], 1, 0, 2) == 2
    assert bisect.bisect([1, 1], 2, 0, 2) == 2
    assert bisect.bisect([1, 1, 1], 0, 0, 3) == 0
    assert bisect.bisect([1, 1, 1], 1, 0, 3) == 3
    assert bisect.bisect([1, 1, 1], 2, 0, 3) == 3
    assert bisect.bisect([1, 1, 1, 1], 0, 0, 4) == 0
    assert bisect.bisect([1, 1, 1, 1], 1, 0, 4) == 4
    assert bisect.bisect([1, 1, 1, 1], 2, 0, 4) == 4
    assert bisect.bisect([1, 2], 0, 0, 2) == 0
    assert bisect.bisect([1, 2], 1, 0, 2) == 1
    assert bisect.bisect([1, 2], 1.5, 0, 2) == 1
    assert bisect.bisect([1, 2], 2, 0, 2) == 2
    assert bisect.bisect([1, 2], 3, 0, 2) == 2
    assert bisect.bisect([1, 1, 2, 2], 0, 0, 4) == 0
    assert bisect.bisect([1, 1, 2, 2], 1, 0, 4) == 2
    assert bisect.bisect([1, 1, 2, 2], 1.5, 0, 4) == 2
    assert bisect.bisect([1, 1, 2, 2], 2, 0, 4) == 4
    assert bisect.bisect([1, 1, 2, 2], 3, 0, 4) == 4
    assert bisect.bisect([1, 2, 3], 0, 0, 3) == 0
    assert bisect.bisect([1, 2, 3], 1, 0, 3) == 1
    assert bisect.bisect([1, 2, 3], 1.5, 0, 3) == 1
    assert bisect.bisect([1, 2, 3], 2, 0, 3) == 2
    assert bisect.bisect([1, 2, 3], 2.5, 0, 3) == 2
    assert bisect.bisect([1, 2, 3], 3, 0, 3) == 3
    assert bisect.bisect([1, 2, 3], 4, 0, 3) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 0, 0, 10) == 0
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1, 0, 10) == 1
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 1.5, 0, 10) == 1
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2, 0, 10) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2.5, 0, 10) == 3
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3, 0, 10) == 6
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 3.5, 0, 10) == 6
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 4, 0, 10) == 10
    assert bisect.bisect([1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 5, 0, 10) == 10


@test
def insort_left():
    bisect.insort_left(li, 5)
    assert li == [1, 3, 4, 4, 4, 5, 6, 7]


@test
def insort_right():
    li = [1, 3, 4, 4, 4, 6, 7]
    bisect.insort_right(li, 0, 0, len(li))
    assert li == [0, 1, 3, 4, 4, 4, 6, 7]
    bisect.insort_right(li, 10)
    assert li == [0, 1, 3, 4, 4, 4, 6, 7, 10]


@test
def insort():
    li = [1, 3, 4, 4, 4, 6, 7]
    bisect.insort(li, 0, 0, len(li))
    assert li == [0, 1, 3, 4, 4, 4, 6, 7]
    bisect.insort(li, 10)
    assert li == [0, 1, 3, 4, 4, 4, 6, 7, 10]


bisect_left()
bisect_right()
bisect1()
insort_left()
insort_right()
insort()
</t>
<t tx="ekr.20230509083244.147">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import math
import cmath

INF = float("inf")
NAN = float("nan")


def float_identical(x, y):
    if math.isnan(x) or math.isnan(y):
        if math.isnan(x) and math.isnan(y):
            return True
    elif x == y:
        if x != 0.0:
            return True
        # both zero; check that signs match
        elif math.copysign(1.0, x) == math.copysign(1.0, y):
            return True
        else:
            return False
    return False


def complex_identical(x, y):
    return float_identical(x.real, y.real) and float_identical(x.imag, y.imag)


###########
# complex #
###########

ZERO_DIVISION = (
    (1 + 1j, 0 + 0j),
    (1 + 1j, 0.0 + 0j),
    (1 + 1j, 0 + 0j),
    (1.0 + 0j, 0 + 0j),
    (1 + 0j, 0 + 0j),
)


def close_abs(x, y, eps=1e-9):
    """Return true iff floats x and y "are close"."""
    # put the one with larger magnitude second
    if abs(x) &gt; abs(y):
        x, y = y, x
    if y == 0:
        return abs(x) &lt; eps
    if x == 0:
        return abs(y) &lt; eps
    # check that relative difference &lt; eps
    return abs((x - y) / y) &lt; eps


def close_complex(x, y, eps=1e-9):
    a = complex(x)
    b = complex(y)
    return close_abs(a.real, b.real, eps) and close_abs(a.imag, b.imag, eps)


def check_div(x, y):
    """Compute complex z=x*y, and check that z/x==y and z/y==x."""
    z = x * y
    if x != 0:
        q = z / x
        if not close_complex(q, y):
            return False
        q = z.__truediv__(x)
        if not close_complex(q, y):
            return False
    if y != 0:
        q = z / y
        if not close_complex(q, x):
            return False
        q = z.__truediv__(y)
        if not close_complex(q, x):
            return False
    return True


@test
def test_truediv():
    from random import random

    simple_real = [float(i) for i in range(-5, 6)]
    simple_complex = [complex(x, y) for x in simple_real for y in simple_real]
    for x in simple_complex:
        for y in simple_complex:
            assert check_div(x, y)

    # A naive complex division algorithm (such as in 2.0) is very prone to
    # nonsense errors for these (overflows and underflows).
    assert check_div(complex(1e200, 1e200), 1 + 0j)
    assert check_div(complex(1e-200, 1e-200), 1 + 0j)

    # Just for fun.
    for i in range(100):
        check_div(complex(random(), random()), complex(random(), random()))

    assert close_complex(complex.__truediv__(2 + 0j, 1 + 1j), 1 - 1j)

    for denom_real, denom_imag in [(0.0, NAN), (NAN, 0.0), (NAN, NAN)]:
        z = complex(0, 0) / complex(denom_real, denom_imag)
        assert math.isnan(z.real)
        assert math.isnan(z.imag)


test_truediv()


@test
def test_richcompare():
    assert not complex.__eq__(1 + 1j, 1 &lt;&lt; 10000)
    assert complex.__eq__(1 + 1j, 1 + 1j)
    assert not complex.__eq__(1 + 1j, 2 + 2j)
    assert not complex.__ne__(1 + 1j, 1 + 1j)
    assert complex.__ne__(1 + 1j, 2 + 2j), True
    for i in range(1, 100):
        f = i / 100.0
        assert complex.__eq__(f + 0j, f)
        assert not complex.__ne__(f + 0j, f)
        assert not complex.__eq__(complex(f, f), f)
        assert complex.__ne__(complex(f, f), f)

    import operator

    assert operator.eq(1 + 1j, 1 + 1j) == True
    assert operator.eq(1 + 1j, 2 + 2j) == False
    assert operator.ne(1 + 1j, 1 + 1j) == False
    assert operator.ne(1 + 1j, 2 + 2j) == True


test_richcompare()


@test
def test_pow():
    def pow(a, b):
        return a ** b

    assert close_complex(pow(1 + 1j, 0 + 0j), 1.0)
    assert close_complex(pow(0 + 0j, 2 + 0j), 0.0)
    assert close_complex(pow(1j, -1), 1 / (1j))
    assert close_complex(pow(1j, 200), 1)

    a = 3.33 + 4.43j
    assert a ** (0j) == 1
    assert a ** (0.0 + 0.0j) == 1

    assert (3j) ** (0j) == 1
    assert (3j) ** 0 == 1

    # The following is used to exercise certain code paths
    assert a ** 105 == a ** 105
    assert a ** -105 == a ** -105
    assert a ** -30 == a ** -30

    assert (0.0j) ** 0 == 1


test_pow()


@test
def test_conjugate():
    assert close_complex(complex(5.3, 9.8).conjugate(), 5.3 - 9.8j)


test_conjugate()


@test
def test_cabs():
    nums = [complex(x / 3.0, y / 7.0) for x in range(-9, 9) for y in range(-9, 9)]
    for num in nums:
        assert close_complex((num.real ** 2 + num.imag ** 2) ** 0.5, abs(num))


test_cabs()


@test
def test_negative_zero_repr_str():
    def test(v, expected):
        return str(v) == expected

    assert test(complex(0.0, 1.0), "1j")
    assert test(complex(-0.0, 1.0), "(-0+1j)")
    assert test(complex(0.0, -1.0), "-1j")
    assert test(complex(-0.0, -1.0), "(-0-1j)")

    assert test(complex(0.0, 0.0), "0j")
    assert test(complex(0.0, -0.0), "-0j")
    assert test(complex(-0.0, 0.0), "(-0+0j)")
    assert test(complex(-0.0, -0.0), "(-0-0j)")


test_negative_zero_repr_str()

#########
# cmath #
#########

complex_zeros = [complex(x, y) for x in [0.0, -0.0] for y in [0.0, -0.0]]
complex_infinities = [
    complex(x, y)
    for x, y in [
        (INF, 0.0),  # 1st quadrant
        (INF, 2.3),
        (INF, INF),
        (2.3, INF),
        (0.0, INF),
        (-0.0, INF),  # 2nd quadrant
        (-2.3, INF),
        (-INF, INF),
        (-INF, 2.3),
        (-INF, 0.0),
        (-INF, -0.0),  # 3rd quadrant
        (-INF, -2.3),
        (-INF, -INF),
        (-2.3, -INF),
        (-0.0, -INF),
        (0.0, -INF),  # 4th quadrant
        (2.3, -INF),
        (INF, -INF),
        (INF, -2.3),
        (INF, -0.0),
    ]
]
complex_nans = [
    complex(x, y)
    for x, y in [
        (NAN, -INF),
        (NAN, -2.3),
        (NAN, -0.0),
        (NAN, 0.0),
        (NAN, 2.3),
        (NAN, INF),
        (-INF, NAN),
        (-2.3, NAN),
        (-0.0, NAN),
        (0.0, NAN),
        (2.3, NAN),
        (INF, NAN),
    ]
]


@llvm
@pure
def small() -&gt; float:
    ret double 4.940660e-323


def almost_equal(a, b, rel_err=2e-15, abs_err=small()):
    if math.isnan(a):
        if math.isnan(b):
            return True
        return False

    if math.isinf(a):
        if a == b:
            return True
        return False

    if not a and not b:
        if math.copysign(1.0, a) != math.copysign(1.0, b):
            return False

    absolute_error = abs(b - a)
    if absolute_error &lt;= max(abs_err, rel_err * abs(a)):
        return True
    return False


@test
def test_constants():
    e_expected = 2.71828182845904523536
    pi_expected = 3.14159265358979323846
    assert math.isclose(cmath.pi, pi_expected)
    assert math.isclose(cmath.e, e_expected)


test_constants()


@test
def test_infinity_and_nan_constants():
    assert cmath.inf.real == math.inf
    assert cmath.inf.imag == 0.0
    assert cmath.infj.real == 0.0
    assert cmath.infj.imag == math.inf

    assert math.isnan(cmath.nan.real)
    assert cmath.nan.imag == 0.0
    assert cmath.nanj.real == 0.0
    assert math.isnan(cmath.nanj.imag)

    assert str(cmath.inf) == "inf"
    assert str(cmath.infj) == "infj"
    assert str(cmath.nan) == "nan"
    assert str(cmath.nanj) == "nanj"


test_infinity_and_nan_constants()


@test
def test_user_object():
    class MyComplexOS:
        value: T
        T: type

        def __init__(self, value: T):
            self.value = value

        def __complex__(self):
            return self.value

    x = MyComplexOS(4.2)
    assert cmath.acos(x) == cmath.acos(x.value)
    assert cmath.acosh(x) == cmath.acosh(x.value)
    assert cmath.asin(x) == cmath.asin(x.value)
    assert cmath.asinh(x) == cmath.asinh(x.value)
    assert cmath.atan(x) == cmath.atan(x.value)
    assert cmath.atanh(x) == cmath.atanh(x.value)
    assert cmath.cos(x) == cmath.cos(x.value)
    assert cmath.cosh(x) == cmath.cosh(x.value)
    assert cmath.exp(x) == cmath.exp(x.value)
    assert cmath.log(x) == cmath.log(x.value)
    assert cmath.log10(x) == cmath.log10(x.value)
    assert cmath.sin(x) == cmath.sin(x.value)
    assert cmath.sinh(x) == cmath.sinh(x.value)
    assert cmath.sqrt(x) == cmath.sqrt(x.value)
    assert cmath.tan(x) == cmath.tan(x.value)
    assert cmath.tanh(x) == cmath.tanh(x.value)


test_user_object()


@test
def test_input_type():
    x = 42
    y = float(x)
    assert cmath.acos(x) == cmath.acos(y)
    assert cmath.acosh(x) == cmath.acosh(y)
    assert cmath.asin(x) == cmath.asin(y)
    assert cmath.asinh(x) == cmath.asinh(y)
    assert cmath.atan(x) == cmath.atan(y)
    assert cmath.atanh(x) == cmath.atanh(y)
    assert cmath.cos(x) == cmath.cos(y)
    assert cmath.cosh(x) == cmath.cosh(y)
    assert cmath.exp(x) == cmath.exp(y)
    assert cmath.log(x) == cmath.log(y)
    assert cmath.log10(x) == cmath.log10(y)
    assert cmath.sin(x) == cmath.sin(y)
    assert cmath.sinh(x) == cmath.sinh(y)
    assert cmath.sqrt(x) == cmath.sqrt(y)
    assert cmath.tan(x) == cmath.tan(y)
    assert cmath.tanh(x) == cmath.tanh(y)


test_input_type()


@test
def test_cmath_matches_math():
    test_values = [0.01, 0.1, 0.2, 0.5, 0.9, 0.99]
    unit_interval = test_values + [-x for x in test_values] + [0.0, 1.0, -1.0]
    positive = test_values + [1.0] + [1.0 / x for x in test_values]
    nonnegative = [0.0] + positive
    real_line = [0.0] + positive + [-x for x in positive]

    test_functions = {
        "acos": unit_interval,
        "asin": unit_interval,
        "atan": real_line,
        "cos": real_line,
        "cosh": real_line,
        "exp": real_line,
        "log": positive,
        "log10": positive,
        "sin": real_line,
        "sinh": real_line,
        "sqrt": nonnegative,
        "tan": real_line,
        "tanh": real_line,
    }

    for v in test_functions["acos"]:
        z = cmath.acos(v)
        assert almost_equal(z.real, math.acos(v))
        assert z.imag == 0.0

    for v in test_functions["asin"]:
        z = cmath.asin(v)
        assert almost_equal(z.real, math.asin(v))
        assert z.imag == 0.0

    for v in test_functions["atan"]:
        z = cmath.atan(v)
        assert almost_equal(z.real, math.atan(v))
        assert z.imag == 0.0

    for v in test_functions["cos"]:
        z = cmath.cos(v)
        assert almost_equal(z.real, math.cos(v))
        assert z.imag == 0.0

    for v in test_functions["cosh"]:
        z = cmath.cosh(v)
        assert almost_equal(z.real, math.cosh(v))
        assert z.imag == 0.0

    for v in test_functions["exp"]:
        z = cmath.exp(v)
        assert almost_equal(z.real, math.exp(v))
        assert z.imag == 0.0

    for v in test_functions["log"]:
        z = cmath.log(v)
        assert almost_equal(z.real, math.log(v))
        assert z.imag == 0.0

    for v in test_functions["log10"]:
        z = cmath.log10(v)
        assert almost_equal(z.real, math.log10(v))
        assert z.imag == 0.0

    for v in test_functions["sin"]:
        z = cmath.sin(v)
        assert almost_equal(z.real, math.sin(v))
        assert z.imag == 0.0

    for v in test_functions["sinh"]:
        z = cmath.sinh(v)
        assert almost_equal(z.real, math.sinh(v))
        assert z.imag == 0.0

    for v in test_functions["sqrt"]:
        z = cmath.sqrt(v)
        assert almost_equal(z.real, math.sqrt(v))
        assert z.imag == 0.0

    for v in test_functions["tan"]:
        z = cmath.tan(v)
        assert almost_equal(z.real, math.tan(v))
        assert z.imag == 0.0

    for v in test_functions["tanh"]:
        z = cmath.tanh(v)
        assert almost_equal(z.real, math.tanh(v))
        assert z.imag == 0.0

    for base in [0.5, 2.0, 10.0]:
        for v in positive:
            z = cmath.log(v, base)
            s = math.log(v, base)
            # added 'or z.real == s' since Codon version gives -0 vs. +0 in one test
            assert almost_equal(z.real, math.log(v, base)) or z.real == s
            assert z.imag == 0.0


test_cmath_matches_math()


@test
def test_polar():
    def check(arg, expected):
        got = cmath.polar(arg)
        return all(almost_equal(e, g) for e, g in zip(expected, got))

    pi = cmath.pi
    assert check(0, (0.0, 0.0))
    assert check(1, (1.0, 0.0))
    assert check(-1, (1.0, pi))
    assert check(1j, (1.0, pi / 2))
    assert check(-3j, (3.0, -pi / 2))
    inf = float("inf")
    assert check(complex(inf, 0), (inf, 0.0))
    assert check(complex(-inf, 0), (inf, pi))
    assert check(complex(3, inf), (inf, pi / 2))
    assert check(complex(5, -inf), (inf, -pi / 2))
    assert check(complex(inf, inf), (inf, pi / 4))
    assert check(complex(inf, -inf), (inf, -pi / 4))
    assert check(complex(-inf, inf), (inf, 3 * pi / 4))
    assert check(complex(-inf, -inf), (inf, -3 * pi / 4))
    nan = float("nan")
    assert check(complex(nan, 0), (nan, nan))
    assert check(complex(0, nan), (nan, nan))
    assert check(complex(nan, nan), (nan, nan))
    assert check(complex(inf, nan), (inf, nan))
    assert check(complex(-inf, nan), (inf, nan))
    assert check(complex(nan, inf), (inf, nan))
    assert check(complex(nan, -inf), (inf, nan))


test_polar()


@test
def test_phase():
    from cmath import phase, pi

    assert almost_equal(phase(0), 0.0)
    assert almost_equal(phase(1.0), 0.0)
    assert almost_equal(phase(-1.0), pi)
    assert almost_equal(phase(-1.0 + 1e-300j), pi)
    assert almost_equal(phase(-1.0 - 1e-300j), -pi)
    assert almost_equal(phase(1j), pi / 2)
    assert almost_equal(phase(-1j), -pi / 2)

    # zeros
    assert phase(complex(0.0, 0.0)) == 0.0
    assert phase(complex(0.0, -0.0)) == -0.0
    assert phase(complex(-0.0, 0.0)) == pi
    assert phase(complex(-0.0, -0.0)) == -pi

    # infinities
    assert almost_equal(phase(complex(-INF, -0.0)), -pi)
    assert almost_equal(phase(complex(-INF, -2.3)), -pi)
    assert almost_equal(phase(complex(-INF, -INF)), -0.75 * pi)
    assert almost_equal(phase(complex(-2.3, -INF)), -pi / 2)
    assert almost_equal(phase(complex(-0.0, -INF)), -pi / 2)
    assert almost_equal(phase(complex(0.0, -INF)), -pi / 2)
    assert almost_equal(phase(complex(2.3, -INF)), -pi / 2)
    assert almost_equal(phase(complex(INF, -INF)), -pi / 4)
    assert phase(complex(INF, -2.3)) == -0.0
    assert phase(complex(INF, -0.0)) == -0.0
    assert phase(complex(INF, 0.0)) == 0.0
    assert phase(complex(INF, 2.3)) == 0.0
    assert almost_equal(phase(complex(INF, INF)), pi / 4)
    assert almost_equal(phase(complex(2.3, INF)), pi / 2)
    assert almost_equal(phase(complex(0.0, INF)), pi / 2)
    assert almost_equal(phase(complex(-0.0, INF)), pi / 2)
    assert almost_equal(phase(complex(-2.3, INF)), pi / 2)
    assert almost_equal(phase(complex(-INF, INF)), 0.75 * pi)
    assert almost_equal(phase(complex(-INF, 2.3)), pi)
    assert almost_equal(phase(complex(-INF, 0.0)), pi)

    # real or imaginary part NaN
    for z in complex_nans:
        assert math.isnan(phase(z))


test_phase()


@test
def test_abs():
    # zeros
    for z in complex_zeros:
        assert abs(z) == 0.0

    # infinities
    for z in complex_infinities:
        assert abs(z) == INF

    # real or imaginary part NaN
    assert abs(complex(NAN, -INF)) == INF
    assert math.isnan(abs(complex(NAN, -2.3)))
    assert math.isnan(abs(complex(NAN, -0.0)))
    assert math.isnan(abs(complex(NAN, 0.0)))
    assert math.isnan(abs(complex(NAN, 2.3)))
    assert abs(complex(NAN, INF)) == INF
    assert abs(complex(-INF, NAN)) == INF
    assert math.isnan(abs(complex(-2.3, NAN)))
    assert math.isnan(abs(complex(-0.0, NAN)))
    assert math.isnan(abs(complex(0.0, NAN)))
    assert math.isnan(abs(complex(2.3, NAN)))
    assert abs(complex(INF, NAN)) == INF
    assert math.isnan(abs(complex(NAN, NAN)))


test_abs()


def c_equal(a, b):
    eps = 1e-7
    if abs(a.real - b[0]) &gt; eps or abs(a.imag - b[1]) &gt; eps:
        return False
    return True


@test
def test_rect():
    from cmath import rect, pi

    assert c_equal(rect(0, 0), (0, 0))
    assert c_equal(rect(1, 0), (1.0, 0))
    assert c_equal(rect(1, -pi), (-1.0, 0))
    assert c_equal(rect(1, pi / 2), (0, 1.0))
    assert c_equal(rect(1, -pi / 2), (0, -1.0))


test_rect()


@test
def test_isfinite():
    real_vals = [float("-inf"), -2.3, -0.0, 0.0, 2.3, float("inf"), float("nan")]
    for x in real_vals:
        for y in real_vals:
            z = complex(x, y)
            assert cmath.isfinite(z) == (math.isfinite(x) and math.isfinite(y))


test_isfinite()


@test
def test_isnan():
    assert not cmath.isnan(1)
    assert not cmath.isnan(1j)
    assert not cmath.isnan(INF)
    assert cmath.isnan(NAN)
    assert cmath.isnan(complex(NAN, 0))
    assert cmath.isnan(complex(0, NAN))
    assert cmath.isnan(complex(NAN, NAN))
    assert cmath.isnan(complex(NAN, INF))
    assert cmath.isnan(complex(INF, NAN))


test_isnan()


@test
def test_isinf():
    assert not cmath.isinf(1)
    assert not cmath.isinf(1j)
    assert not cmath.isinf(NAN)
    assert cmath.isinf(INF)
    assert cmath.isinf(complex(INF, 0))
    assert cmath.isinf(complex(0, INF))
    assert cmath.isinf(complex(INF, INF))
    assert cmath.isinf(complex(NAN, INF))
    assert cmath.isinf(complex(INF, NAN))


test_isinf()


@test
def test_tanh_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.tanh(z), z)


test_tanh_sign()


@test
def test_atan_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.atan(z), z)


test_atan_sign()


@test
def test_atanh_sign():
    for z in complex_zeros:
        assert complex_identical(cmath.atanh(z), z)


test_atanh_sign()


@test
def test_is_close():
    # test complex values that are close to within 12 decimal places
    complex_examples = [
        (1.0 + 1.0j, 1.000000000001 + 1.0j),
        (1.0 + 1.0j, 1.0 + 1.000000000001j),
        (-1.0 + 1.0j, -1.000000000001 + 1.0j),
        (1.0 - 1.0j, 1.0 - 0.999999999999j),
    ]

    for a, b in complex_examples:
        assert cmath.isclose(a, b, rel_tol=1e-12)
        assert not cmath.isclose(a, b, rel_tol=1e-13)

    # test values near zero that are near to within three decimal places
    near_zero_examples = [
        (0.001j, 0),
        (0.001 + 0j, 0),
        (0.001 + 0.001j, 0),
        (-0.001 + 0.001j, 0),
        (0.001 - 0.001j, 0),
        (-0.001 - 0.001j, 0),
    ]

    for a, b in near_zero_examples:
        assert cmath.isclose(a, b, abs_tol=1.5e-03)
        assert not cmath.isclose(a, b, abs_tol=0.5e-03)

    assert cmath.isclose(0.001 - 0.001j, 0.001 + 0.001j, abs_tol=2e-03)
    assert not cmath.isclose(0.001 - 0.001j, 0.001 + 0.001j, abs_tol=1e-03)


test_is_close()


@test
def test_cmath_testcases():
    def check(exp, got, flags):
        def close(a, b):
            if math.isnan(a):
                return math.isnan(b)
            elif math.isnan(b):
                return math.isnan(a)
            return math.isclose(a, b, rel_tol=1e-10, abs_tol=1e-15)

        x1 = exp.real
        y1 = exp.imag

        x2 = got.real
        y2 = got.imag

        if "ignore-real-sign" in flags:
            x1 = math.fabs(x1)
            x2 = math.fabs(x2)

        if "ignore-imag-sign" in flags:
            y1 = math.fabs(y1)
            y2 = math.fabs(y2)

        return close(x1, x2) and close(y1, y2)

    def run_test(test):
        v = test.split()
        if not v:
            return True
        name = v[0]
        func = v[1]
        inp = complex(float(v[2]), float(v[3]))
        exp = complex(float(v[5]), float(v[6]))
        flags = v[7:]

        got = complex()
        if func == "rect":
            got = cmath.rect(inp.real, inp.imag)
        elif func == "polar":
            got = complex(*cmath.polar(inp))
        elif func == "exp":
            got = cmath.exp(inp)
        elif func == "log":
            got = cmath.log(inp)
        elif func == "log10":
            got = cmath.log10(inp)
        elif func == "sqrt":
            got = cmath.sqrt(inp)
        elif func == "acos":
            got = cmath.acos(inp)
        elif func == "asin":
            got = cmath.asin(inp)
        elif func == "atan":
            got = cmath.atan(inp)
        elif func == "cos":
            got = cmath.cos(inp)
        elif func == "sin":
            got = cmath.sin(inp)
        elif func == "tan":
            got = cmath.tan(inp)
        elif func == "acosh":
            got = cmath.acosh(inp)
        elif func == "asinh":
            got = cmath.asinh(inp)
        elif func == "atanh":
            got = cmath.atanh(inp)
        elif func == "cosh":
            got = cmath.cosh(inp)
        elif func == "sinh":
            got = cmath.sinh(inp)
        elif func == "tanh":
            got = cmath.tanh(inp)
        else:
            assert False, f"ERROR: unknown function: {func}"

        if not check(exp, got, flags):
            print(f"{name} {func} {inp=} {got=} {exp=} {flags=}")
            return False
        return True

    tests = []
    with open("test/stdlib/cmath_testcases.txt") as f:
        for line in f:
            line = line.strip()
            if not line.startswith("--"):
                tests.append(line)

    for test in tests:
        assert run_test(test)


test_cmath_testcases()


@test
def test_complex64():
    c64 = complex64
    z = c64(.5 + .5j)
    assert c64() == z * 0
    assert z + 1 == c64(1.5, .5)
    assert bool(z) == True
    assert bool(0 * z) == False
    assert +z == z
    assert -z == c64(-.5 - .5j)
    assert abs(z) == float32(0.7071067811865476)
    assert z + 1 == c64(1.5 + .5j)
    assert 1j + z == c64(.5 + 1.5j)
    assert z * 2 == c64(1 + 1j)
    assert 2j * z == c64(-1 + 1j)
    assert z / .5 == c64(1 + 1j)
    assert 1j / z == c64(1 + 1j)
    assert z ** 2 == c64(.5j)
    y = 1j ** z
    assert math.isclose(float(y.real), 0.32239694194483454)
    assert math.isclose(float(y.imag), 0.32239694194483454)
    assert z != -z
    assert z != 0
    assert z.real == float32(.5)
    assert (z + 1j).imag == float32(1.5)
    assert z.conjugate() == c64(.5 - .5j)
    assert z.__copy__() == z
    assert hash(z)
    assert c64(complex(z)) == z

test_complex64()
</t>
<t tx="ekr.20230509083244.148">@path C:/Repos/codon/test/stdlib/
@language unknown_language
from datetime import *
from unittest import TestCase
from operator import lt, le, gt, ge, eq, ne, truediv, floordiv, mod


class TestTimeDelta(Static[TestCase]):
    def test_constructor(self):
        eq = self.assertEqual
        td = timedelta

        # Check keyword args to constructor
        eq(
            td(),
            td(
                weeks=0,
                days=0,
                hours=0,
                minutes=0,
                seconds=0,
                milliseconds=0,
                microseconds=0,
            ),
        )
        eq(td(1), td(days=1))
        eq(td(0, 1), td(seconds=1))
        eq(td(0, 0, 1), td(microseconds=1))
        eq(td(weeks=1), td(days=7))
        eq(td(days=1), td(hours=24))
        eq(td(hours=1), td(minutes=60))
        eq(td(minutes=1), td(seconds=60))
        eq(td(seconds=1), td(milliseconds=1000))
        eq(td(milliseconds=1), td(microseconds=1000))

        # Check float args to constructor
        eq(td(weeks=1.0 / 7), td(days=1))
        eq(td(days=1.0 / 24), td(hours=1))
        eq(td(hours=1.0 / 60), td(minutes=1))
        eq(td(minutes=1.0 / 60), td(seconds=1))
        eq(td(seconds=0.001), td(milliseconds=1))
        eq(td(milliseconds=0.001), td(microseconds=1))

    def test_computations(self):
        eq = self.assertEqual
        td = timedelta

        a = td(7)  # One week
        b = td(0, 60)  # One minute
        c = td(0, 0, 1000)  # One millisecond
        eq(a + b + c, td(7, 60, 1000))
        eq(a - b, td(6, 24 * 3600 - 60))
        # eq(b.__rsub__(a), td(6, 24*3600 - 60))
        eq(-a, td(-7))
        eq(+a, td(7))
        eq(-b, td(-1, 24 * 3600 - 60))
        eq(-c, td(-1, 24 * 3600 - 1, 999000))
        eq(abs(a), a)
        eq(abs(-a), a)
        eq(td(6, 24 * 3600), a)
        eq(td(0, 0, 60 * 1000000), b)
        eq(a * 10, td(70))
        eq(a * 10, 10 * a)
        eq(a * 10, 10 * a)
        eq(b * 10, td(0, 600))
        eq(10 * b, td(0, 600))
        eq(b * 10, td(0, 600))
        eq(c * 10, td(0, 0, 10000))
        eq(10 * c, td(0, 0, 10000))
        eq(c * 10, td(0, 0, 10000))
        eq(a * -1, -a)
        eq(b * -2, -b - b)
        eq(c * -2, -c + -c)
        eq(b * (60 * 24), (b * 60) * 24)
        eq(b * (60 * 24), (60 * b) * 24)
        eq(c * 1000, td(0, 1))
        eq(1000 * c, td(0, 1))
        eq(a // 7, td(1))
        eq(b // 10, td(0, 6))
        eq(c // 1000, td(0, 0, 1))
        eq(a // 10, td(0, 7 * 24 * 360))
        eq(a // 3600000, td(0, 0, 7 * 24 * 1000))
        eq(a / 0.5, td(14))
        eq(b / 0.5, td(0, 120))
        eq(a / 7, td(1))
        eq(b / 10, td(0, 6))
        eq(c / 1000, td(0, 0, 1))
        eq(a / 10, td(0, 7 * 24 * 360))
        eq(a / 3600000, td(0, 0, 7 * 24 * 1000))

        # Multiplication by float
        us = td(microseconds=1)
        eq((3 * us) * 0.5, 2 * us)
        eq((5 * us) * 0.5, 2 * us)
        eq(0.5 * (3 * us), 2 * us)
        eq(0.5 * (5 * us), 2 * us)
        eq((-3 * us) * 0.5, -2 * us)
        eq((-5 * us) * 0.5, -2 * us)

        # TODO: check Python's Issue #23521 and possibly
        # incorporate the same fix here. For now a couple
        # tests are disabled.

        # Issue #23521
        eq(td(seconds=1) * 0.123456, td(microseconds=123456))
        # eq(td(seconds=1) * 0.6112295, td(microseconds=611229))

        # Division by int and float
        eq((3 * us) / 2, 2 * us)
        eq((5 * us) / 2, 2 * us)
        eq((-3 * us) / 2.0, -2 * us)
        eq((-5 * us) / 2.0, -2 * us)
        eq((3 * us) / -2, -2 * us)
        eq((5 * us) / -2, -2 * us)
        eq((3 * us) / -2.0, -2 * us)
        eq((5 * us) / -2.0, -2 * us)
        for i in range(-10, 10):
            eq((i * us / 3) // us, round(i / 3))
        for i in range(-10, 10):
            eq((i * us / -3) // us, round(i / -3))

        # Issue #23521
        # eq(td(seconds=1) / (1 / 0.6112295), td(microseconds=611229))

        # Issue #11576
        eq(td(999999999, 86399, 999999) - td(999999999, 86399, 999998), td(0, 0, 1))
        eq(td(999999999, 1, 1) - td(999999999, 1, 0), td(0, 0, 1))

    """
    def test_disallowed_special(self):
        a = timedelta(42)
        NAN = 0. / 0.
        self.assertRaises(ValueError, a.__mul__, NAN)
        self.assertRaises(ValueError, a.__truediv__, NAN)
    """

    def test_basic_attributes(self):
        days, seconds, us = 1, 7, 31
        td = timedelta(days, seconds, us)
        self.assertEqual(td.days, days)
        self.assertEqual(td.seconds, seconds)
        self.assertEqual(td.microseconds, us)

    def test_total_seconds(self):
        td = timedelta(days=365)
        self.assertEqual(td.total_seconds(), 31536000.0)
        for total_seconds in [123456.789012, -123456.789012, 0.123456, 0, 1e6]:
            td = timedelta(seconds=total_seconds)
            self.assertEqual(td.total_seconds(), total_seconds)
        # Issue8644: Test that td.total_seconds() has the same
        # accuracy as td / timedelta(seconds=1).
        for ms in [-1, -2, -123]:
            td = timedelta(microseconds=ms)
            self.assertEqual(td.total_seconds(), td / timedelta(seconds=1))

    def test_carries(self):
        t1 = timedelta(
            days=100,
            weeks=-7,
            hours=-24 * (100 - 49),
            minutes=-3,
            seconds=12,
            microseconds=(3 * 60 - 12) * 1e6 + 1,
        )
        t2 = timedelta(microseconds=1)
        self.assertEqual(t1, t2)

    def test_hash_equality(self):
        t1 = timedelta(
            days=100,
            weeks=-7,
            hours=-24 * (100 - 49),
            minutes=-3,
            seconds=12,
            microseconds=(3 * 60 - 12) * 1000000,
        )
        t2 = timedelta()
        self.assertEqual(hash(t1), hash(t2))

        t1 += timedelta(weeks=7)
        t2 += timedelta(days=7 * 7)
        self.assertEqual(t1, t2)
        self.assertEqual(hash(t1), hash(t2))

        d = {t1: 1}
        d[t2] = 2
        self.assertEqual(len(d), 1)
        self.assertEqual(d[t1], 2)

    def test_compare(self):
        t1 = timedelta(2, 3, 4)
        t2 = timedelta(2, 3, 4)
        self.assertEqual(t1, t2)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t1 &gt;= t2)
        self.assertFalse(t1 != t2)
        self.assertFalse(t1 &lt; t2)
        self.assertFalse(t1 &gt; t2)

        for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
            t2 = timedelta(*args)  # this is larger than t1
            self.assertTrue(t1 &lt; t2)
            self.assertTrue(t2 &gt; t1)
            self.assertTrue(t1 &lt;= t2)
            self.assertTrue(t2 &gt;= t1)
            self.assertTrue(t1 != t2)
            self.assertTrue(t2 != t1)
            self.assertFalse(t1 == t2)
            self.assertFalse(t2 == t1)
            self.assertFalse(t1 &gt; t2)
            self.assertFalse(t2 &lt; t1)
            self.assertFalse(t1 &gt;= t2)
            self.assertFalse(t2 &lt;= t1)

    def test_str(self):
        td = timedelta
        eq = self.assertEqual

        eq(str(td(1)), "1 day, 0:00:00")
        eq(str(td(-1)), "-1 day, 0:00:00")
        eq(str(td(2)), "2 days, 0:00:00")
        eq(str(td(-2)), "-2 days, 0:00:00")

        eq(str(td(hours=12, minutes=58, seconds=59)), "12:58:59")
        eq(str(td(hours=2, minutes=3, seconds=4)), "2:03:04")
        eq(str(td(weeks=-30, hours=23, minutes=12, seconds=34)), "-210 days, 23:12:34")

        eq(str(td(milliseconds=1)), "0:00:00.001000")
        eq(str(td(microseconds=3)), "0:00:00.000003")

        # Codon's timedelta has a smaller range than Python's
        # since it uses a pure microseconds representation, so
        # below case is not supported.
        """
        eq(str(td(days=999999999, hours=23, minutes=59, seconds=59,
                   microseconds=999999)),
           "999999999 days, 23:59:59.999999")
        """

    def test_repr(self):
        td = timedelta
        self.assertEqual(repr(td(1)), "timedelta(days=1)")
        self.assertEqual(repr(td(10, 2)), "timedelta(days=10, seconds=2)")
        self.assertEqual(
            repr(td(-10, 2, 400000)),
            "timedelta(days=-10, seconds=2, microseconds=400000)",
        )
        self.assertEqual(repr(td(seconds=60)), "timedelta(seconds=60)")
        self.assertEqual(repr(td()), "timedelta(0)")
        self.assertEqual(repr(td(microseconds=100)), "timedelta(microseconds=100)")
        self.assertEqual(
            repr(td(days=1, microseconds=100)), "timedelta(days=1, microseconds=100)"
        )
        self.assertEqual(
            repr(td(seconds=1, microseconds=100)),
            "timedelta(seconds=1, microseconds=100)",
        )

    def test_resolution_info(self):
        self.assertTrue(timedelta.max &gt; timedelta.min)
        #self.assertEqual(timedelta.min, timedelta(-999999999))
        #self.assertEqual(timedelta.max, timedelta(999999999, 24*3600-1, 1e6-1))
        self.assertEqual(timedelta.resolution, timedelta(0, 0, 1))

    """
    def test_overflow(self):
        tiny = timedelta(microseconds=1)  # timedelta.resolution

        td = timedelta.min + tiny
        td -= tiny  # no problem
        self.assertRaises(OverflowError, td.__sub__, tiny)
        self.assertRaises(OverflowError, td.__add__, -tiny)

        td = timedelta.max - tiny
        td += tiny  # no problem
        self.assertRaises(OverflowError, td.__add__, tiny)
        self.assertRaises(OverflowError, td.__sub__, -tiny)

        self.assertRaises(OverflowError, lambda: -timedelta.max)

        day = timedelta(1)
        self.assertRaises(OverflowError, day.__mul__, 10**9)
        self.assertRaises(OverflowError, day.__mul__, 1e9)
        self.assertRaises(OverflowError, day.__truediv__, 1e-20)
        self.assertRaises(OverflowError, day.__truediv__, 1e-10)
        self.assertRaises(OverflowError, day.__truediv__, 9e-10)

    def _test_overflow_special(self):
        day = timedelta(1)
        INF = 1. / 0.
        self.assertRaises(OverflowError, day.__mul__, INF)
        self.assertRaises(OverflowError, day.__mul__, -INF)
    """

    def test_microsecond_rounding(self):
        td = timedelta
        eq = self.assertEqual

        # Single-field rounding.
        eq(td(milliseconds=0.4 / 1000), td(0))  # rounds to 0
        eq(td(milliseconds=-0.4 / 1000), td(0))  # rounds to 0
        eq(td(milliseconds=0.5 / 1000), td(microseconds=0))
        eq(td(milliseconds=-0.5 / 1000), td(microseconds=-0))
        eq(td(milliseconds=0.6 / 1000), td(microseconds=1))
        eq(td(milliseconds=-0.6 / 1000), td(microseconds=-1))
        eq(td(milliseconds=1.5 / 1000), td(microseconds=2))
        eq(td(milliseconds=-1.5 / 1000), td(microseconds=-2))
        eq(td(seconds=0.5 / 10 ** 6), td(microseconds=0))
        eq(td(seconds=-0.5 / 10 ** 6), td(microseconds=-0))
        eq(td(seconds=1 / 2 ** 7), td(microseconds=7812))
        eq(td(seconds=-1 / 2 ** 7), td(microseconds=-7812))

        # Rounding due to contributions from more than one field.
        us_per_hour = 3600e6
        us_per_day = us_per_hour * 24
        eq(td(days=0.4 / us_per_day), td(0))
        eq(td(hours=0.2 / us_per_hour), td(0))
        eq(td(days=0.4 / us_per_day, hours=0.2 / us_per_hour), td(microseconds=1))

        eq(td(days=-0.4 / us_per_day), td(0))
        eq(td(hours=-0.2 / us_per_hour), td(0))
        eq(td(days=-0.4 / us_per_day, hours=-0.2 / us_per_hour), td(microseconds=-1))

        # Test for a patch in Issue 8860
        eq(td(microseconds=0.5), 0.5 * td(microseconds=1.0))
        resolution = td(microseconds=1)  # td.resolution
        eq(td(microseconds=0.5) // resolution, 0.5 * resolution // resolution)

    def test_massive_normalization(self):
        td = timedelta(microseconds=-1)
        self.assertEqual(
            (td.days, td.seconds, td.microseconds), (-1, 24 * 3600 - 1, 999999)
        )

    def test_bool(self):
        self.assertTrue(timedelta(1))
        self.assertTrue(timedelta(0, 1))
        self.assertTrue(timedelta(0, 0, 1))
        self.assertTrue(timedelta(microseconds=1))
        self.assertFalse(timedelta(0))

    def test_division(self):
        t = timedelta(hours=1, minutes=24, seconds=19)
        second = timedelta(seconds=1)
        self.assertEqual(t / second, 5059.0)
        self.assertEqual(t // second, 5059)

        t = timedelta(minutes=2, seconds=30)
        minute = timedelta(minutes=1)
        self.assertEqual(t / minute, 2.5)
        self.assertEqual(t // minute, 2)

        zerotd = timedelta(0)
        # self.assertRaises(ZeroDivisionError, truediv, t, zerotd)
        # self.assertRaises(ZeroDivisionError, floordiv, t, zerotd)

    def test_remainder(self):
        t = timedelta(minutes=2, seconds=30)
        minute = timedelta(minutes=1)
        r = t % minute
        self.assertEqual(r, timedelta(seconds=30))

        t = timedelta(minutes=-2, seconds=30)
        r = t % minute
        self.assertEqual(r, timedelta(seconds=30))

        zerotd = timedelta(0)
        # self.assertRaises(ZeroDivisionError, mod, t, zerotd)

    def test_divmod(self):
        t = timedelta(minutes=2, seconds=30)
        minute = timedelta(minutes=1)
        q, r = divmod(t, minute)
        self.assertEqual(q, 2)
        self.assertEqual(r, timedelta(seconds=30))

        t = timedelta(minutes=-2, seconds=30)
        q, r = divmod(t, minute)
        self.assertEqual(q, -2)
        self.assertEqual(r, timedelta(seconds=30))

        zerotd = timedelta(0)
        # self.assertRaises(ZeroDivisionError, divmod, t, zerotd)


class TestDateOnly(Static[TestCase]):
    def test_delta_non_days_ignored(self):
        dt = date(2000, 1, 2)
        delta = timedelta(days=1, hours=2, minutes=3, seconds=4, microseconds=5)
        days = timedelta(delta.days)
        self.assertEqual(days, timedelta(1))

        dt2 = dt + delta
        self.assertEqual(dt2, dt + days)

        dt2 = delta + dt
        self.assertEqual(dt2, dt + days)

        dt2 = dt - delta
        self.assertEqual(dt2, dt - days)

        delta = -delta
        days = timedelta(delta.days)
        self.assertEqual(days, timedelta(-2))

        dt2 = dt + delta
        self.assertEqual(dt2, dt + days)

        dt2 = delta + dt
        self.assertEqual(dt2, dt + days)

        dt2 = dt - delta
        self.assertEqual(dt2, dt - days)


class TestDate(Static[TestCase]):
    theclass: type

    def test_basic_attributes(self):
        dt = self.theclass(2002, 3, 1)
        self.assertEqual(dt.year, 2002)
        self.assertEqual(dt.month, 3)
        self.assertEqual(dt.day, 1)

    def test_ordinal_conversions(self):
        # Check some fixed values.
        for y, m, d, n in [
            (1, 1, 1, 1),  # calendar origin
            (1, 12, 31, 365),
            (2, 1, 1, 366),
            # first example from "Calendrical Calculations"
            (1945, 11, 12, 710347),
        ]:
            dt = self.theclass(y, m, d)
            self.assertEqual(n, dt.toordinal())
            fromord = self.theclass.fromordinal(n)
            self.assertEqual(dt, fromord)
            if hasattr(fromord, "hour"):
                # if we're checking something fancier than a date, verify
                # the extra fields have been zeroed out
                self.assertEqual(fromord.hour, 0)
                self.assertEqual(fromord.minute, 0)
                self.assertEqual(fromord.second, 0)
                self.assertEqual(fromord.microsecond, 0)

        # Check first and last days of year spottily across the whole
        # range of years supported.
        for year in range(MINYEAR, MAXYEAR + 1, 7):
            # Verify (year, 1, 1) -&gt; ordinal -&gt; y, m, d is identity.
            d = self.theclass(year, 1, 1)
            n = d.toordinal()
            d2 = self.theclass.fromordinal(n)
            self.assertEqual(d, d2)
            # Verify that moving back a day gets to the end of year-1.
            if year &gt; 1:
                d = self.theclass.fromordinal(n - 1)
                d2 = self.theclass(year - 1, 12, 31)
                self.assertEqual(d, d2)
                self.assertEqual(d2.toordinal(), n - 1)

        # Test every day in a leap-year and a non-leap year.
        dim = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        for year, isleap in (2000, True), (2002, False):
            n = self.theclass(year, 1, 1).toordinal()
            for month, maxday in zip(range(1, 13), dim):
                if month == 2 and isleap:
                    maxday += 1
                for day in range(1, maxday + 1):
                    d = self.theclass(year, month, day)
                    self.assertEqual(d.toordinal(), n)
                    self.assertEqual(d, self.theclass.fromordinal(n))
                    n += 1

    """
    def test_extreme_ordinals(self):
        a = self.theclass.min
        a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
        aord = a.toordinal()
        b = a.fromordinal(aord)
        self.assertEqual(a, b)

        self.assertRaises(ValueError, lambda: a.fromordinal(aord - 1))

        b = a + timedelta(days=1)
        self.assertEqual(b.toordinal(), aord + 1)
        self.assertEqual(b, self.theclass.fromordinal(aord + 1))

        a = self.theclass.max
        a = self.theclass(a.year, a.month, a.day)  # get rid of time parts
        aord = a.toordinal()
        b = a.fromordinal(aord)
        self.assertEqual(a, b)

        self.assertRaises(ValueError, lambda: a.fromordinal(aord + 1))

        b = a - timedelta(days=1)
        self.assertEqual(b.toordinal(), aord - 1)
        self.assertEqual(b, self.theclass.fromordinal(aord - 1))
    """

    def test_bad_constructor_arguments(self):
        # bad years
        self.theclass(MINYEAR, 1, 1)  # no exception
        self.theclass(MAXYEAR, 1, 1)  # no exception

        def make(theclass, a, b, c):
            return self.theclass(a, b, c)

        self.assertRaises(ValueError, make(self.theclass, ...), MINYEAR - 1, 1, 1)
        self.assertRaises(ValueError, make(self.theclass, ...), MAXYEAR + 1, 1, 1)
        # bad months
        self.theclass(2000, 1, 1)  # no exception
        self.theclass(2000, 12, 1)  # no exception
        self.assertRaises(ValueError, make(self.theclass, ...), 2000, 0, 1)
        self.assertRaises(ValueError, make(self.theclass, ...), 2000, 13, 1)
        # bad days
        self.theclass(2000, 2, 29)  # no exception
        self.theclass(2004, 2, 29)  # no exception
        self.theclass(2400, 2, 29)  # no exception
        self.assertRaises(ValueError, make(self.theclass, ...), 2000, 2, 30)
        self.assertRaises(ValueError, make(self.theclass, ...), 2001, 2, 29)
        self.assertRaises(ValueError, make(self.theclass, ...), 2100, 2, 29)
        self.assertRaises(ValueError, make(self.theclass, ...), 1900, 2, 29)
        self.assertRaises(ValueError, make(self.theclass, ...), 2000, 1, 0)
        self.assertRaises(ValueError, make(self.theclass, ...), 2000, 1, 32)

    def test_hash_equality(self):
        d = self.theclass(2000, 12, 31)
        # same thing
        e = self.theclass(2000, 12, 31)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

        d = self.theclass(2001, 1, 1)
        # same thing
        e = self.theclass(2001, 1, 1)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

    def test_computations(self):
        a = self.theclass(2002, 1, 31)
        b = self.theclass(1956, 1, 31)
        c = self.theclass(2001, 2, 1)

        diff = a - b
        self.assertEqual(diff.days, 46 * 365 + len(range(1956, 2002, 4)))
        self.assertEqual(diff.seconds, 0)
        self.assertEqual(diff.microseconds, 0)

        day = timedelta(1)
        week = timedelta(7)
        a = self.theclass(2002, 3, 2)
        self.assertEqual(a + day, self.theclass(2002, 3, 3))
        self.assertEqual(day + a, self.theclass(2002, 3, 3))
        self.assertEqual(a - day, self.theclass(2002, 3, 1))
        self.assertEqual(-day + a, self.theclass(2002, 3, 1))
        self.assertEqual(a + week, self.theclass(2002, 3, 9))
        self.assertEqual(a - week, self.theclass(2002, 2, 23))
        self.assertEqual(a + 52 * week, self.theclass(2003, 3, 1))
        self.assertEqual(a - 52 * week, self.theclass(2001, 3, 3))
        self.assertEqual((a + week) - a, week)
        self.assertEqual((a + day) - a, day)
        self.assertEqual((a - week) - a, -week)
        self.assertEqual((a - day) - a, -day)
        self.assertEqual(a - (a + week), -week)
        self.assertEqual(a - (a + day), -day)
        self.assertEqual(a - (a - week), week)
        self.assertEqual(a - (a - day), day)
        self.assertEqual(c - (c - day), day)

        """
        # Add/sub ints or floats should be illegal
        for i in 1, 1.0:
            self.assertRaises(TypeError, lambda: a+i)
            self.assertRaises(TypeError, lambda: a-i)
            self.assertRaises(TypeError, lambda: i+a)
            self.assertRaises(TypeError, lambda: i-a)

        # delta - date is senseless.
        self.assertRaises(TypeError, lambda: day - a)
        # mixing date and (delta or date) via * or // is senseless
        self.assertRaises(TypeError, lambda: day * a)
        self.assertRaises(TypeError, lambda: a * day)
        self.assertRaises(TypeError, lambda: day // a)
        self.assertRaises(TypeError, lambda: a // day)
        self.assertRaises(TypeError, lambda: a * a)
        self.assertRaises(TypeError, lambda: a // a)
        # date + date is senseless
        self.assertRaises(TypeError, lambda: a + a)
        """

    """
    def test_overflow(self):
        tiny = self.theclass.resolution

        for delta in [tiny, timedelta(1), timedelta(2)]:
            dt = self.theclass.min + delta
            dt -= delta  # no problem
            self.assertRaises(OverflowError, dt.__sub__, delta)
            self.assertRaises(OverflowError, dt.__add__, -delta)

            dt = self.theclass.max - delta
            dt += delta  # no problem
            self.assertRaises(OverflowError, dt.__add__, delta)
            self.assertRaises(OverflowError, dt.__sub__, -delta)
    """

    def test_fromtimestamp(self):
        import time

        # Try an arbitrary fixed value.
        year, month, day = 1999, 9, 19
        ts = time.mktime((year, month, day, 0, 0, 0, 0, 0, -1))
        d = self.theclass.fromtimestamp(ts)
        self.assertEqual(d.year, year)
        self.assertEqual(d.month, month)
        self.assertEqual(d.day, day)

    def test_today(self):
        import time

        # We claim that today() is like fromtimestamp(time.time()), so
        # prove it.
        today = self.theclass.today()
        todayagain = today

        for dummy in range(3):
            today = self.theclass.today()
            ts = time.time()
            todayagain = self.theclass.fromtimestamp(ts)
            if today == todayagain:
                break
            # There are several legit reasons that could fail:
            # 1. It recently became midnight, between the today() and the
            #    time() calls.
            # 2. The platform time() has such fine resolution that we'll
            #    never get the same value twice.
            # 3. The platform time() has poor resolution, and we just
            #    happened to call today() right before a resolution quantum
            #    boundary.
            # 4. The system clock got fiddled between calls.
            # In any case, wait a little while and try again.
            time.sleep(0.1)

        # It worked or it didn't.  If it didn't, assume it's reason #2, and
        # let the test pass if they're within half a second of each other.
        if today != todayagain:
            self.assertAlmostEqual(todayagain, today, delta=timedelta(seconds=0.5))

    def test_weekday(self):
        for i in range(7):
            # March 4, 2002 is a Monday
            self.assertEqual(self.theclass(2002, 3, 4 + i).weekday(), i)
            self.assertEqual(self.theclass(2002, 3, 4 + i).isoweekday(), i + 1)
            # January 2, 1956 is a Monday
            self.assertEqual(self.theclass(1956, 1, 2 + i).weekday(), i)
            self.assertEqual(self.theclass(1956, 1, 2 + i).isoweekday(), i + 1)

    def test_isocalendar(self):
        # Check examples from
        # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
        week_mondays = [
            ((2003, 12, 22), (2003, 52, 1)),
            ((2003, 12, 29), (2004, 1, 1)),
            ((2004, 1, 5), (2004, 2, 1)),
            ((2009, 12, 21), (2009, 52, 1)),
            ((2009, 12, 28), (2009, 53, 1)),
            ((2010, 1, 4), (2010, 1, 1)),
        ]

        test_cases = []
        for cal_date, iso_date in week_mondays:
            base_date = self.theclass(*cal_date)
            # Adds one test case for every day of the specified weeks
            for i in range(7):
                new_date = base_date + timedelta(i)
                new_iso = iso_date[0:2] + (iso_date[2] + i,)
                test_cases.append((new_date, new_iso))

        for d, exp_iso in test_cases:
            self.assertEqual(d.isocalendar(), exp_iso)

            # Check that the tuple contents are accessible by field name
            t = d.isocalendar()
            self.assertEqual((t.year, t.week, t.weekday), exp_iso)

    def test_iso_long_years(self):
        # Calculate long ISO years and compare to table from
        # http://www.phys.uu.nl/~vgent/calendar/isocalendar.htm
        ISO_LONG_YEARS_TABLE = """
              4   32   60   88
              9   37   65   93
             15   43   71   99
             20   48   76
             26   54   82
            105  133  161  189
            111  139  167  195
            116  144  172
            122  150  178
            128  156  184
            201  229  257  285
            207  235  263  291
            212  240  268  296
            218  246  274
            224  252  280
            303  331  359  387
            308  336  364  392
            314  342  370  398
            320  348  376
            325  353  381
        """
        iso_long_years = sorted(map(int, ISO_LONG_YEARS_TABLE.split()))
        L = []
        for i in range(400):
            d = self.theclass(2000 + i, 12, 31).isocalendar()
            d1 = self.theclass(1600 + i, 12, 31).isocalendar()
            self.assertEqual((d.week, d.weekday), (d1.week, d1.weekday))
            if d.week == 53:
                L.append(i)
        self.assertEqual(L, iso_long_years)

    def test_isoformat(self):
        t = self.theclass(2, 3, 2)
        self.assertEqual(t.isoformat(), "0002-03-02")

    def test_ctime(self):
        t = self.theclass(2002, 3, 2)
        self.assertEqual(t.ctime(), "Sat Mar  2 00:00:00 2002")

    def test_resolution_info(self):
        self.assertTrue(self.theclass.max &gt; self.theclass.min)

    """
    def test_extreme_timedelta(self):
        big = self.theclass.max - self.theclass.min
        # 3652058 days, 23 hours, 59 minutes, 59 seconds, 999999 microseconds
        n = (big.days*24*3600 + big.seconds)*1000000 + big.microseconds
        # n == 315537897599999999 ~= 2**58.13
        justasbig = timedelta(0, 0, n)
        self.assertEqual(big, justasbig)
        self.assertEqual(self.theclass.min + big, self.theclass.max)
        self.assertEqual(self.theclass.max - big, self.theclass.min)
    """

    def test_timetuple(self):
        from time import struct_time

        for i in range(7):
            # January 2, 1956 is a Monday (0)
            d = self.theclass(1956, 1, 2 + i)
            t = d.timetuple()
            self.assertEqual(t, struct_time(1956, 1, 2 + i, 0, 0, 0, i, 2 + i, -1))
            # February 1, 1956 is a Wednesday (2)
            d = self.theclass(1956, 2, 1 + i)
            t = d.timetuple()
            self.assertEqual(
                t, struct_time(1956, 2, 1 + i, 0, 0, 0, (2 + i) % 7, 32 + i, -1)
            )
            # March 1, 1956 is a Thursday (3), and is the 31+29+1 = 61st day
            # of the year.
            d = self.theclass(1956, 3, 1 + i)
            t = d.timetuple()
            self.assertEqual(
                t, struct_time(1956, 3, 1 + i, 0, 0, 0, (3 + i) % 7, 61 + i, -1)
            )
            self.assertEqual(t.tm_year, 1956)
            self.assertEqual(t.tm_mon, 3)
            self.assertEqual(t.tm_mday, 1 + i)
            self.assertEqual(t.tm_hour, 0)
            self.assertEqual(t.tm_min, 0)
            self.assertEqual(t.tm_sec, 0)
            self.assertEqual(t.tm_wday, (3 + i) % 7)
            self.assertEqual(t.tm_yday, 61 + i)
            self.assertEqual(t.tm_isdst, -1)

    def test_compare(self):
        t1 = self.theclass(2, 3, 4)
        t2 = self.theclass(2, 3, 4)
        self.assertEqual(t1, t2)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t1 &gt;= t2)
        self.assertFalse(t1 != t2)
        self.assertFalse(t1 &lt; t2)
        self.assertFalse(t1 &gt; t2)

        for args in (3, 3, 3), (2, 4, 4), (2, 3, 5):
            t2 = self.theclass(*args)  # this is larger than t1
            self.assertTrue(t1 &lt; t2)
            self.assertTrue(t2 &gt; t1)
            self.assertTrue(t1 &lt;= t2)
            self.assertTrue(t2 &gt;= t1)
            self.assertTrue(t1 != t2)
            self.assertTrue(t2 != t1)
            self.assertFalse(t1 == t2)
            self.assertFalse(t2 == t1)
            self.assertFalse(t1 &gt; t2)
            self.assertFalse(t2 &lt; t1)
            self.assertFalse(t1 &gt;= t2)
            self.assertFalse(t2 &lt;= t1)

        """
        for badarg in OTHERSTUFF:
            self.assertEqual(t1 == badarg, False)
            self.assertEqual(t1 != badarg, True)
            self.assertEqual(badarg == t1, False)
            self.assertEqual(badarg != t1, True)

            self.assertRaises(TypeError, lambda: t1 &lt; badarg)
            self.assertRaises(TypeError, lambda: t1 &gt; badarg)
            self.assertRaises(TypeError, lambda: t1 &gt;= badarg)
            self.assertRaises(TypeError, lambda: badarg &lt;= t1)
            self.assertRaises(TypeError, lambda: badarg &lt; t1)
            self.assertRaises(TypeError, lambda: badarg &gt; t1)
            self.assertRaises(TypeError, lambda: badarg &gt;= t1)
        """

    def test_bool(self):
        # All dates are considered true.
        # self.assertTrue(self.theclass.min)
        # self.assertTrue(self.theclass.max)
        self.assertTrue(self.theclass(1, 1, 1))

    def test_replace(self):
        cls = self.theclass
        args = (1, 2, 3)
        base = cls(*args)
        self.assertEqual(base, base.replace())
        self.assertEqual(base.replace(year=2), cls(2, 2, 3))
        self.assertEqual(base.replace(month=3), cls(1, 3, 3))
        self.assertEqual(base.replace(day=4), cls(1, 2, 4))

        # Out of bounds.
        base = cls(2000, 2, 29)
        self.assertRaises(ValueError, base.replace, year=2001)

    def test_fromisoformat(self):
        # Test that isoformat() is reversible
        base_dates = [
            (1, 1, 1),
            (1000, 2, 14),
            (1900, 1, 1),
            (2000, 2, 29),
            (2004, 11, 12),
            (2004, 4, 3),
            (2017, 5, 30),
        ]

        for dt_tuple in base_dates:
            dt = self.theclass(*dt_tuple)
            dt_str = dt.isoformat()
            dt_rt = self.theclass.fromisoformat(dt.isoformat())
            self.assertEqual(dt, dt_rt)

    def test_fromisoformat_fails(self):
        # Test that fromisoformat() fails on invalid values
        bad_strs = [
            "",  # Empty string
            "\ud800",  # bpo-34454: Surrogate code point
            "009-03-04",  # Not 10 characters
            "123456789",  # Not a date
            "200a-12-04",  # Invalid character in year
            "2009-1a-04",  # Invalid character in month
            "2009-12-0a",  # Invalid character in day
            "2009-01-32",  # Invalid day
            "2009-02-29",  # Invalid leap day
            "20090228",  # Valid ISO8601 output not from isoformat()
            "2009\ud80002\ud80028",  # Separators are surrogate codepoints
        ]

        for bad_str in bad_strs:
            self.assertRaises(ValueError, self.theclass.fromisoformat, bad_str)

    def test_fromisocalendar(self):
        # For each test case, assert that fromisocalendar is the
        # inverse of the isocalendar function
        dates = [
            (2016, 4, 3),
            (2005, 1, 2),  # (2004, 53, 7)
            (2008, 12, 30),  # (2009, 1, 2)
            (2010, 1, 2),  # (2009, 53, 6)
            (2009, 12, 31),  # (2009, 53, 4)
            (1900, 1, 1),  # Unusual non-leap year (year % 100 == 0)
            (1900, 12, 31),
            (2000, 1, 1),  # Unusual leap year (year % 400 == 0)
            (2000, 12, 31),
            (2004, 1, 1),  # Leap year
            (2004, 12, 31),
            (1, 1, 1),
            (9999, 12, 31),
            (MINYEAR, 1, 1),
            (MAXYEAR, 12, 31),
        ]

        for datecomps in dates:
            dobj = self.theclass(*datecomps)
            isocal = dobj.isocalendar()

            d_roundtrip = self.theclass.fromisocalendar(*isocal)

            self.assertEqual(dobj, d_roundtrip)

    def test_fromisocalendar_value_errors(self):
        isocals = [
            (2019, 0, 1),
            (2019, -1, 1),
            (2019, 54, 1),
            (2019, 1, 0),
            (2019, 1, -1),
            (2019, 1, 8),
            (2019, 53, 1),
            (10000, 1, 1),
            (0, 1, 1),
            (9999999, 1, 1),
            (2 &lt;&lt; 32, 1, 1),
            (2019, 2 &lt;&lt; 32, 1),
            (2019, 1, 2 &lt;&lt; 32),
        ]

        for isocal in isocals:
            self.assertRaises(ValueError, self.theclass.fromisocalendar, *isocal)


class TestDateTime(Static[TestDate[theclass]]):
    theclass: type

    def test_basic_attributes(self):
        dt = self.theclass(2002, 3, 1, 12, 0)
        self.assertEqual(dt.year, 2002)
        self.assertEqual(dt.month, 3)
        self.assertEqual(dt.day, 1)
        self.assertEqual(dt.hour, 12)
        self.assertEqual(dt.minute, 0)
        self.assertEqual(dt.second, 0)
        self.assertEqual(dt.microsecond, 0)

    def test_basic_attributes_nonzero(self):
        # Make sure all attributes are non-zero so bugs in
        # bit-shifting access show up.
        dt = self.theclass(2002, 3, 1, 12, 59, 59, 8000)
        self.assertEqual(dt.year, 2002)
        self.assertEqual(dt.month, 3)
        self.assertEqual(dt.day, 1)
        self.assertEqual(dt.hour, 12)
        self.assertEqual(dt.minute, 59)
        self.assertEqual(dt.second, 59)
        self.assertEqual(dt.microsecond, 8000)

    def test_isoformat(self):
        t = self.theclass(1, 2, 3, 4, 5, 1, 123)
        self.assertEqual(t.isoformat(), "0001-02-03T04:05:01.000123")
        self.assertEqual(t.isoformat("T"), "0001-02-03T04:05:01.000123")
        self.assertEqual(t.isoformat(" "), "0001-02-03 04:05:01.000123")
        self.assertEqual(t.isoformat("\x00"), "0001-02-03\x0004:05:01.000123")
        # bpo-34482: Check that surrogates are handled properly.
        self.assertEqual(t.isoformat("\ud800"), "0001-02-03\ud80004:05:01.000123")
        self.assertEqual(t.isoformat(timespec="hours"), "0001-02-03T04")
        self.assertEqual(t.isoformat(timespec="minutes"), "0001-02-03T04:05")
        self.assertEqual(t.isoformat(timespec="seconds"), "0001-02-03T04:05:01")
        self.assertEqual(
            t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.000"
        )
        self.assertEqual(
            t.isoformat(timespec="microseconds"), "0001-02-03T04:05:01.000123"
        )
        self.assertEqual(t.isoformat(timespec="auto"), "0001-02-03T04:05:01.000123")
        self.assertEqual(t.isoformat(sep=" ", timespec="minutes"), "0001-02-03 04:05")
        # str is ISO format with the separator forced to a blank.
        self.assertEqual(str(t), "0001-02-03 04:05:01.000123")

        # t = self.theclass(1, 2, 3, 4, 5, 1, 999500, tzinfo=timezone.utc)
        # self.assertEqual(t.isoformat(timespec='milliseconds'), "0001-02-03T04:05:01.999+00:00")

        t = self.theclass(1, 2, 3, 4, 5, 1, 999500)
        self.assertEqual(
            t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.999"
        )

        t = self.theclass(1, 2, 3, 4, 5, 1)
        self.assertEqual(t.isoformat(timespec="auto"), "0001-02-03T04:05:01")
        self.assertEqual(
            t.isoformat(timespec="milliseconds"), "0001-02-03T04:05:01.000"
        )
        self.assertEqual(
            t.isoformat(timespec="microseconds"), "0001-02-03T04:05:01.000000"
        )

        t = self.theclass(2, 3, 2)
        self.assertEqual(t.isoformat(), "0002-03-02T00:00:00")
        self.assertEqual(t.isoformat("T"), "0002-03-02T00:00:00")
        self.assertEqual(t.isoformat(" "), "0002-03-02 00:00:00")
        # str is ISO format with the separator forced to a blank.
        self.assertEqual(str(t), "0002-03-02 00:00:00")
        # ISO format with timezone
        # tz = FixedOffset(timedelta(seconds=16), 'XXX')
        # t = self.theclass(2, 3, 2, tzinfo=tz)
        # self.assertEqual(t.isoformat(), "0002-03-02T00:00:00+00:00:16")

    """
    def test_isoformat_timezone(self):
        tzoffsets = [
            ('05:00', timedelta(hours=5)),
            ('02:00', timedelta(hours=2)),
            ('06:27', timedelta(hours=6, minutes=27)),
            ('12:32:30', timedelta(hours=12, minutes=32, seconds=30)),
            ('02:04:09.123456', timedelta(hours=2, minutes=4, seconds=9, microseconds=123456))
        ]

        tzinfos = [
            ('', None),
            ('+00:00', timezone.utc),
            ('+00:00', timezone(timedelta(0))),
        ]

        tzinfos += [
            (prefix + expected, timezone(sign * td))
            for expected, td in tzoffsets
            for prefix, sign in [('-', -1), ('+', 1)]
        ]

        dt_base = self.theclass(2016, 4, 1, 12, 37, 9)
        exp_base = '2016-04-01T12:37:09'

        for exp_tz, tzi in tzinfos:
            dt = dt_base.replace(tzinfo=tzi)
            exp = exp_base + exp_tz
            with self.subTest(tzi=tzi):
                assert dt.isoformat() == exp
    """

    """
    def test_more_ctime(self):
        # Test fields that TestDate doesn't touch.
        import time

        t = self.theclass(2002, 3, 2, 18, 3, 5, 123)
        self.assertEqual(t.ctime(), "Sat Mar  2 18:03:05 2002")
        # Oops!  The next line fails on Win2K under MSVC 6, so it's commented
        # out.  The difference is that t.ctime() produces " 2" for the day,
        # but platform ctime() produces "02" for the day.  According to
        # C99, t.ctime() is correct here.
        # self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))

        # So test a case where that difference doesn't matter.
        t = self.theclass(2002, 3, 22, 18, 3, 5, 123)
        self.assertEqual(t.ctime(), time.ctime(time.mktime(t.timetuple())))
    """

    def test_tz_independent_comparing(self):
        dt1 = self.theclass(2002, 3, 1, 9, 0, 0)
        dt2 = self.theclass(2002, 3, 1, 10, 0, 0)
        dt3 = self.theclass(2002, 3, 1, 9, 0, 0)
        self.assertEqual(dt1, dt3)
        self.assertTrue(dt2 &gt; dt3)

        # Make sure comparison doesn't forget microseconds, and isn't done
        # via comparing a float timestamp (an IEEE double doesn't have enough
        # precision to span microsecond resolution across years 1 through 9999,
        # so comparing via timestamp necessarily calls some distinct values
        # equal).
        dt1 = self.theclass(MAXYEAR, 12, 31, 23, 59, 59, 999998)
        us = timedelta(microseconds=1)
        dt2 = dt1 + us
        self.assertEqual(dt2 - dt1, us)
        self.assertTrue(dt1 &lt; dt2)

    def test_bad_constructor_arguments(self):
        # bad years
        self.theclass(MINYEAR, 1, 1)  # no exception
        self.theclass(MAXYEAR, 1, 1)  # no exception

        make_dt1 = lambda a, b, c: self.theclass(a, b, c)
        make_dt2 = lambda a, b, c, d: self.theclass(a, b, c, d)
        make_dt3 = lambda a, b, c, d, e: self.theclass(a, b, c, d, e)
        make_dt4 = lambda a, b, c, d, e, f: self.theclass(a, b, c, d, e, f)
        make_dt5 = lambda a, b, c, d, e, f, g: self.theclass(a, b, c, d, e, f, g)

        self.assertRaises(ValueError, make_dt1, MINYEAR - 1, 1, 1)
        self.assertRaises(ValueError, make_dt1, MAXYEAR + 1, 1, 1)
        # bad months
        self.theclass(2000, 1, 1)  # no exception
        self.theclass(2000, 12, 1)  # no exception
        self.assertRaises(ValueError, make_dt1, 2000, 0, 1)
        self.assertRaises(ValueError, make_dt1, 2000, 13, 1)
        # bad days
        self.theclass(2000, 2, 29)  # no exception
        self.theclass(2004, 2, 29)  # no exception
        self.theclass(2400, 2, 29)  # no exception
        self.assertRaises(ValueError, make_dt1, 2000, 2, 30)
        self.assertRaises(ValueError, make_dt1, 2001, 2, 29)
        self.assertRaises(ValueError, make_dt1, 2100, 2, 29)
        self.assertRaises(ValueError, make_dt1, 1900, 2, 29)
        self.assertRaises(ValueError, make_dt1, 2000, 1, 0)
        self.assertRaises(ValueError, make_dt1, 2000, 1, 32)
        # bad hours
        self.theclass(2000, 1, 31, 0)  # no exception
        self.theclass(2000, 1, 31, 23)  # no exception
        self.assertRaises(ValueError, make_dt2, 2000, 1, 31, -1)
        self.assertRaises(ValueError, make_dt2, 2000, 1, 31, 24)
        # bad minutes
        self.theclass(2000, 1, 31, 23, 0)  # no exception
        self.theclass(2000, 1, 31, 23, 59)  # no exception
        self.assertRaises(ValueError, make_dt3, 2000, 1, 31, 23, -1)
        self.assertRaises(ValueError, make_dt3, 2000, 1, 31, 23, 60)
        # bad seconds
        self.theclass(2000, 1, 31, 23, 59, 0)  # no exception
        self.theclass(2000, 1, 31, 23, 59, 59)  # no exception
        self.assertRaises(ValueError, make_dt4, 2000, 1, 31, 23, 59, -1)
        self.assertRaises(ValueError, make_dt4, 2000, 1, 31, 23, 59, 60)
        # bad microseconds
        self.theclass(2000, 1, 31, 23, 59, 59, 0)  # no exception
        self.theclass(2000, 1, 31, 23, 59, 59, 999999)  # no exception
        self.assertRaises(ValueError, make_dt5, 2000, 1, 31, 23, 59, 59, -1)
        self.assertRaises(ValueError, make_dt5, 2000, 1, 31, 23, 59, 59, 1000000)
        """
        # bad fold
        self.assertRaises(ValueError, self.theclass,
                          2000, 1, 31, fold=-1)
        self.assertRaises(ValueError, self.theclass,
                          2000, 1, 31, fold=2)
        # Positional fold:
        self.assertRaises(TypeError, self.theclass,
                          2000, 1, 31, 23, 59, 59, 0, None, 1)
        """

    def test_hash_equality(self):
        d = self.theclass(2000, 12, 31, 23, 30, 17)
        e = self.theclass(2000, 12, 31, 23, 30, 17)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

        d = self.theclass(2001, 1, 1, 0, 5, 17)
        e = self.theclass(2001, 1, 1, 0, 5, 17)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

    def test_computations(self):
        a = self.theclass(2002, 1, 31)
        b = self.theclass(1956, 1, 31)
        diff = a - b
        self.assertEqual(diff.days, 46 * 365 + len(range(1956, 2002, 4)))
        self.assertEqual(diff.seconds, 0)
        self.assertEqual(diff.microseconds, 0)
        a = self.theclass(2002, 3, 2, 17, 6)
        millisec = timedelta(0, 0, 1000)
        hour = timedelta(0, 3600)
        day = timedelta(1)
        week = timedelta(7)
        self.assertEqual(a + hour, self.theclass(2002, 3, 2, 18, 6))
        self.assertEqual(hour + a, self.theclass(2002, 3, 2, 18, 6))
        self.assertEqual(a + 10 * hour, self.theclass(2002, 3, 3, 3, 6))
        self.assertEqual(a - hour, self.theclass(2002, 3, 2, 16, 6))
        self.assertEqual(-hour + a, self.theclass(2002, 3, 2, 16, 6))
        self.assertEqual(a - hour, a + -hour)
        self.assertEqual(a - 20 * hour, self.theclass(2002, 3, 1, 21, 6))
        self.assertEqual(a + day, self.theclass(2002, 3, 3, 17, 6))
        self.assertEqual(a - day, self.theclass(2002, 3, 1, 17, 6))
        self.assertEqual(a + week, self.theclass(2002, 3, 9, 17, 6))
        self.assertEqual(a - week, self.theclass(2002, 2, 23, 17, 6))
        self.assertEqual(a + 52 * week, self.theclass(2003, 3, 1, 17, 6))
        self.assertEqual(a - 52 * week, self.theclass(2001, 3, 3, 17, 6))
        self.assertEqual((a + week) - a, week)
        self.assertEqual((a + day) - a, day)
        self.assertEqual((a + hour) - a, hour)
        self.assertEqual((a + millisec) - a, millisec)
        self.assertEqual((a - week) - a, -week)
        self.assertEqual((a - day) - a, -day)
        self.assertEqual((a - hour) - a, -hour)
        self.assertEqual((a - millisec) - a, -millisec)
        self.assertEqual(a - (a + week), -week)
        self.assertEqual(a - (a + day), -day)
        self.assertEqual(a - (a + hour), -hour)
        self.assertEqual(a - (a + millisec), -millisec)
        self.assertEqual(a - (a - week), week)
        self.assertEqual(a - (a - day), day)
        self.assertEqual(a - (a - hour), hour)
        self.assertEqual(a - (a - millisec), millisec)
        self.assertEqual(
            a + (week + day + hour + millisec),
            self.theclass(2002, 3, 10, 18, 6, 0, 1000),
        )
        self.assertEqual(
            a + (week + day + hour + millisec), (((a + week) + day) + hour) + millisec
        )
        self.assertEqual(
            a - (week + day + hour + millisec),
            self.theclass(2002, 2, 22, 16, 5, 59, 999000),
        )
        self.assertEqual(
            a - (week + day + hour + millisec), (((a - week) - day) - hour) - millisec
        )
        """
        # Add/sub ints or floats should be illegal
        for i in 1, 1.0:
            self.assertRaises(TypeError, lambda: a+i)
            self.assertRaises(TypeError, lambda: a-i)
            self.assertRaises(TypeError, lambda: i+a)
            self.assertRaises(TypeError, lambda: i-a)

        # delta - datetime is senseless.
        self.assertRaises(TypeError, lambda: day - a)
        # mixing datetime and (delta or datetime) via * or // is senseless
        self.assertRaises(TypeError, lambda: day * a)
        self.assertRaises(TypeError, lambda: a * day)
        self.assertRaises(TypeError, lambda: day // a)
        self.assertRaises(TypeError, lambda: a // day)
        self.assertRaises(TypeError, lambda: a * a)
        self.assertRaises(TypeError, lambda: a // a)
        # datetime + datetime is senseless
        self.assertRaises(TypeError, lambda: a + a)
        """

    def test_more_compare(self):
        # The test_compare() inherited from TestDate covers the error cases.
        # We just want to test lexicographic ordering on the members datetime
        # has that date lacks.
        args = (2000, 11, 29, 20, 58, 16, 999998)
        newargsx = [
            (2001, 11, 29, 20, 58, 16, 999998),
            (2000, 12, 29, 20, 58, 16, 999998),
            (2000, 11, 30, 20, 58, 16, 999998),
            (2000, 11, 29, 21, 58, 16, 999998),
            (2000, 11, 29, 20, 59, 16, 999998),
            (2000, 11, 29, 20, 58, 17, 999998),
            (2000, 11, 29, 20, 58, 16, 999999),
        ]
        t1 = self.theclass(*args)
        t2 = self.theclass(*args)
        self.assertEqual(t1, t2)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t1 &gt;= t2)
        self.assertFalse(t1 != t2)
        self.assertFalse(t1 &lt; t2)
        self.assertFalse(t1 &gt; t2)

        for i in range(len(args)):
            newargs = newargsx[i]
            t2 = self.theclass(*newargs)  # this is larger than t1
            self.assertTrue(t1 &lt; t2)
            self.assertTrue(t2 &gt; t1)
            self.assertTrue(t1 &lt;= t2)
            self.assertTrue(t2 &gt;= t1)
            self.assertTrue(t1 != t2)
            self.assertTrue(t2 != t1)
            self.assertFalse(t1 == t2)
            self.assertFalse(t2 == t1)
            self.assertFalse(t1 &gt; t2)
            self.assertFalse(t2 &lt; t1)
            self.assertFalse(t1 &gt;= t2)
            self.assertFalse(t2 &lt;= t1)

    # A helper for timestamp constructor tests.
    def verify_field_equality(self, expected, got):
        self.assertEqual(expected.tm_year, got.year)
        self.assertEqual(expected.tm_mon, got.month)
        self.assertEqual(expected.tm_mday, got.day)
        self.assertEqual(expected.tm_hour, got.hour)
        self.assertEqual(expected.tm_min, got.minute)
        self.assertEqual(expected.tm_sec, got.second)

    def test_fromtimestamp(self):
        import time

        ts = time.time()
        expected = time.localtime(int(ts))
        got = self.theclass.fromtimestamp(ts)
        self.verify_field_equality(expected, got)

    """
    def test_utcfromtimestamp(self):
        import time

        ts = time.time()
        expected = time.gmtime(int(ts))
        got = self.theclass.utcfromtimestamp(ts)
        self.verify_field_equality(expected, got)
    """

    def test_timestamp_naive(self):
        """
        t = self.theclass(1970, 1, 1)
        self.assertEqual(t.timestamp(), 18000.0)
        t = self.theclass(1970, 1, 1, 1, 2, 3, 4)
        self.assertEqual(t.timestamp(),
                         18000.0 + 3600 + 2*60 + 3 + 4*1e-6)
        """

        t = self.theclass(1970, 1, 1)
        self.assertEqual(t.timestamp(), 0)
        t = self.theclass(1970, 1, 1, 1, 2, 3, 4)
        self.assertEqual(t.timestamp(), 3600 + 2 * 60 + 3 + 4 * 1e-6)

        """
        # Missing hour
        t0 = self.theclass(2012, 3, 11, 2, 30)
        t1 = t0.replace(fold=1)
        self.assertEqual(self.theclass.fromtimestamp(t1.timestamp()),
                         t0 - timedelta(hours=1))
        self.assertEqual(self.theclass.fromtimestamp(t0.timestamp()),
                         t1 + timedelta(hours=1))
        # Ambiguous hour defaults to DST
        t = self.theclass(2012, 11, 4, 1, 30)
        self.assertEqual(self.theclass.fromtimestamp(t.timestamp()), t)

        # Timestamp may raise an overflow error on some platforms
        # XXX: Do we care to support the first and last year?
        for t in [self.theclass(2,1,1), self.theclass(9998,12,12)]:
            s = None
            try:
                s = t.timestamp()
            except OverflowError:
                continue

            self.assertEqual(self.theclass.fromtimestamp(s), t)
        """

    """
    def test_timestamp_aware(self):
        t = self.theclass(1970, 1, 1, tzinfo=timezone.utc)
        self.assertEqual(t.timestamp(), 0.0)
        t = self.theclass(1970, 1, 1, 1, 2, 3, 4, tzinfo=timezone.utc)
        self.assertEqual(t.timestamp(),
                         3600 + 2*60 + 3 + 4*1e-6)
        t = self.theclass(1970, 1, 1, 1, 2, 3, 4,
                          tzinfo=timezone(timedelta(hours=-5), 'EST'))
        self.assertEqual(t.timestamp(),
                         18000 + 3600 + 2*60 + 3 + 4*1e-6)
    """
    """
    def test_microsecond_rounding(self):
        for fts in (self.theclass.fromtimestamp,
                    self.theclass.utcfromtimestamp):
            zero = fts(0)
            self.assertEqual(zero.second, 0)
            self.assertEqual(zero.microsecond, 0)
            one = fts(1e-6)
            minus_one = fts(-1e-6)

            self.assertEqual(minus_one.second, 59)
            self.assertEqual(minus_one.microsecond, 999999)

            t = fts(-1e-8)
            self.assertEqual(t, zero)
            t = fts(-9e-7)
            self.assertEqual(t, minus_one)
            t = fts(-1e-7)
            self.assertEqual(t, zero)
            t = fts(-1/2**7)
            self.assertEqual(t.second, 59)
            self.assertEqual(t.microsecond, 992188)

            t = fts(1e-7)
            self.assertEqual(t, zero)
            t = fts(9e-7)
            self.assertEqual(t, one)
            t = fts(0.99999949)
            self.assertEqual(t.second, 0)
            self.assertEqual(t.microsecond, 999999)
            t = fts(0.9999999)
            self.assertEqual(t.second, 1)
            self.assertEqual(t.microsecond, 0)
            t = fts(1/2**7)
            self.assertEqual(t.second, 0)
            self.assertEqual(t.microsecond, 7812)
    """
    """
    def test_timestamp_limits(self):
        # minimum timestamp
        min_dt = self.theclass.min.replace(tzinfo=timezone.utc)
        min_ts = min_dt.timestamp()
        try:
            # date 0001-01-01 00:00:00+00:00: timestamp=-62135596800
            self.assertEqual(self.theclass.fromtimestamp(min_ts, tz=timezone.utc),
                             min_dt)
        except (OverflowError, OSError) as exc:
            # the date 0001-01-01 doesn't fit into 32-bit time_t,
            # or platform doesn't support such very old date
            self.skipTest(str(exc))

        # maximum timestamp: set seconds to zero to avoid rounding issues
        max_dt = self.theclass.max.replace(tzinfo=timezone.utc,
                                           second=0, microsecond=0)
        max_ts = max_dt.timestamp()
        # date 9999-12-31 23:59:00+00:00: timestamp 253402300740
        self.assertEqual(self.theclass.fromtimestamp(max_ts, tz=timezone.utc),
                         max_dt)

        # number of seconds greater than 1 year: make sure that the new date
        # is not valid in datetime.datetime limits
        delta = 3600 * 24 * 400

        # too small
        ts = min_ts - delta
        # converting a Python int to C time_t can raise a OverflowError,
        # especially on 32-bit platforms.
        self.assertRaises(ValueError, self.theclass.fromtimestamp, ts)
        self.assertRaises(ValueError, self.theclass.utcfromtimestamp, ts)

        # too big
        ts = max_dt.timestamp() + delta
        self.assertRaises(ValueError, self.theclass.fromtimestamp, ts)
        self.assertRaises(ValueError, self.theclass.utcfromtimestamp, ts)
    """

    def test_negative_float_fromtimestamp(self):
        # The result is tz-dependent; at least test that this doesn't
        # fail (like it did before bug 1646728 was fixed).
        self.theclass.fromtimestamp(-1.05)

    """
    def test_negative_float_utcfromtimestamp(self):
        d = self.theclass.utcfromtimestamp(-1.05)
        self.assertEqual(d, self.theclass(1969, 12, 31, 23, 59, 58, 950000))
    """

    def test_utcnow(self):
        import time

        # Call it a success if utcnow() and utcfromtimestamp() are within
        # a second of each other.
        from_timestamp = None
        from_now = None
        tolerance = timedelta(seconds=1)
        for dummy in range(3):
            from_now = self.theclass.utcnow()
            from_timestamp = self.theclass.utcfromtimestamp(time.time())
            if abs(from_timestamp.__val__() - from_now.__val__()) &lt;= tolerance:
                break
            # Else try again a few times.
        self.assertLessEqual(abs(from_timestamp.__val__() - from_now.__val__()), tolerance)

    def test_extract(self):
        dt = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
        self.assertEqual(dt.date(), date(2002, 3, 4))
        self.assertEqual(dt.time(), time(18, 45, 3, 1234))

    def test_combine(self):
        d = date(2002, 3, 4)
        t = time(18, 45, 3, 1234)
        expected = self.theclass(2002, 3, 4, 18, 45, 3, 1234)
        combine = self.theclass.combine
        dt = combine(d, t)
        self.assertEqual(dt, expected)

        dt = combine(time=t, date=d)
        self.assertEqual(dt, expected)

        self.assertEqual(d, dt.date())
        self.assertEqual(t, dt.time())
        self.assertEqual(dt, combine(dt.date(), dt.time()))

        """
        self.assertRaises(TypeError, combine) # need an arg
        self.assertRaises(TypeError, combine, d) # need two args
        self.assertRaises(TypeError, combine, t, d) # args reversed
        self.assertRaises(TypeError, combine, d, t, 1) # wrong tzinfo type
        self.assertRaises(TypeError, combine, d, t, 1, 2)  # too many args
        self.assertRaises(TypeError, combine, "date", "time") # wrong types
        self.assertRaises(TypeError, combine, d, "time") # wrong type
        self.assertRaises(TypeError, combine, "date", t) # wrong type

        # tzinfo= argument
        dt = combine(d, t, timezone.utc)
        self.assertIs(dt.tzinfo, timezone.utc)
        dt = combine(d, t, tzinfo=timezone.utc)
        self.assertIs(dt.tzinfo, timezone.utc)
        t = time()
        dt = combine(dt, t)
        self.assertEqual(dt.date(), d)
        self.assertEqual(dt.time(), t)
        """

    def test_replace(self):
        cls = self.theclass
        args = (1, 2, 3, 4, 5, 6, 7)
        base = cls(*args)
        self.assertEqual(base, base.replace())

        self.assertEqual(base.replace(year=2), cls(2, 2, 3, 4, 5, 6, 7))
        self.assertEqual(base.replace(month=3), cls(1, 3, 3, 4, 5, 6, 7))
        self.assertEqual(base.replace(day=4), cls(1, 2, 4, 4, 5, 6, 7))
        self.assertEqual(base.replace(hour=5), cls(1, 2, 3, 5, 5, 6, 7))
        self.assertEqual(base.replace(minute=6), cls(1, 2, 3, 4, 6, 6, 7))
        self.assertEqual(base.replace(second=7), cls(1, 2, 3, 4, 5, 7, 7))
        self.assertEqual(base.replace(microsecond=8), cls(1, 2, 3, 4, 5, 6, 8))
        # Out of bounds.
        base = cls(2000, 2, 29)
        self.assertRaises(ValueError, lambda: base.replace(year=2001))

    """
    def test_astimezone(self):
        dt = self.theclass.now()
        f = FixedOffset(44, "0044")
        dt_utc = dt.replace(tzinfo=timezone(timedelta(hours=-4), 'EDT'))
        self.assertEqual(dt.astimezone(), dt_utc) # naive
        self.assertRaises(TypeError, dt.astimezone, f, f) # too many args
        self.assertRaises(TypeError, dt.astimezone, dt) # arg wrong type
        dt_f = dt.replace(tzinfo=f) + timedelta(hours=4, minutes=44)
        self.assertEqual(dt.astimezone(f), dt_f) # naive
        self.assertEqual(dt.astimezone(tz=f), dt_f) # naive

        class Bogus(tzinfo):
            def utcoffset(self, dt): return None
            def dst(self, dt): return timedelta(0)
        bog = Bogus()
        self.assertRaises(ValueError, dt.astimezone, bog)   # naive
        self.assertEqual(dt.replace(tzinfo=bog).astimezone(f), dt_f)

        class AlsoBogus(tzinfo):
            def utcoffset(self, dt): return timedelta(0)
            def dst(self, dt): return None
        alsobog = AlsoBogus()
        self.assertRaises(ValueError, dt.astimezone, alsobog) # also naive

        class Broken(tzinfo):
            def utcoffset(self, dt): return 1
            def dst(self, dt): return 1
        broken = Broken()
        dt_broken = dt.replace(tzinfo=broken)
        with self.assertRaises(TypeError):
            dt_broken.astimezone()
    """

    def test_fromisoformat_datetime(self):
        # Test that isoformat() is reversible
        base_dates = [(1, 1, 1), (1900, 1, 1), (2004, 11, 12), (2017, 5, 30)]

        base_times = [
            (0, 0, 0, 0),
            (0, 0, 0, 241000),
            (0, 0, 0, 234567),
            (12, 30, 45, 234567),
        ]

        separators = [" ", "T"]

        dts = [
            self.theclass(*date_tuple, *time_tuple)
            for date_tuple in base_dates
            for time_tuple in base_times
        ]

        for dt in dts:
            for sep in separators:
                dtstr = dt.isoformat(sep=sep)
                dt_rt = self.theclass.fromisoformat(dtstr)
                self.assertEqual(dt, dt_rt)

    def test_fromisoformat_separators(self):
        separators = [" ", "T"]

        for sep in separators:
            dt = self.theclass(2018, 1, 31, 23, 59, 47, 124789)
            dtstr = dt.isoformat(sep=sep)

            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

    def test_fromisoformat_ambiguous(self):
        # Test strings like 2018-01-31+12:15 (where +12:15 is not a time zone)
        separators = ["+", "-"]
        for sep in separators:
            dt = self.theclass(2018, 1, 31, 12, 15)
            dtstr = dt.isoformat(sep=sep)

            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

    def test_fromisoformat_timespecs(self):
        datetime_bases = [(2009, 12, 4, 8, 17, 45, 123456), (2009, 12, 4, 8, 17, 45, 0)]

        timespecs = ["hours", "minutes", "seconds", "milliseconds", "microseconds"]

        for dt_tuple in datetime_bases:
            dt = self.theclass(*(dt_tuple[0:4]))
            dtstr = dt.isoformat(timespec="hours")
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

            dt = self.theclass(*(dt_tuple[0:5]))
            dtstr = dt.isoformat(timespec="minutes")
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

            dt = self.theclass(*(dt_tuple[0:6]))
            dtstr = dt.isoformat(timespec="seconds")
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

            new_microseconds = 1000 * (dt_tuple[6] // 1000)
            dt_tuple2 = (*dt_tuple[0:6], new_microseconds)
            dt = self.theclass(*(dt_tuple2[0:7]))
            dtstr = dt.isoformat(timespec="milliseconds")
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

            dt = self.theclass(*(dt_tuple[0:8]))
            dtstr = dt.isoformat(timespec="microseconds")
            dt_rt = self.theclass.fromisoformat(dtstr)
            self.assertEqual(dt, dt_rt)

    def test_fromisoformat_fails_datetime(self):
        # Test that fromisoformat() fails on invalid values
        bad_strs = [
            "",  # Empty string
            "\ud800",  # bpo-34454: Surrogate code point
            "2009.04-19T03",  # Wrong first separator
            "2009-04.19T03",  # Wrong second separator
            "2009-04-19T0a",  # Invalid hours
            "2009-04-19T03:1a:45",  # Invalid minutes
            "2009-04-19T03:15:4a",  # Invalid seconds
            "2009-04-19T03;15:45",  # Bad first time separator
            "2009-04-19T03:15;45",  # Bad second time separator
            "2009-04-19T03:15:4500:00",  # Bad time zone separator
            "2009-04-19T03:15:45.2345",  # Too many digits for milliseconds
            "2009-04-19T03:15:45.1234567",  # Too many digits for microseconds
            "2009-04-19T03:15:45.123456+24:30",  # Invalid time zone offset
            "2009-04-19T03:15:45.123456-24:30",  # Invalid negative offset
            "2009-04-1012:15",  # Too many unicode separators
            "2009-04\ud80010T12:15",  # Surrogate char in date
            "2009-04-10T12\ud80015",  # Surrogate char in time
            "2009-04-19T1",  # Incomplete hours
            "2009-04-19T12:3",  # Incomplete minutes
            "2009-04-19T12:30:4",  # Incomplete seconds
            "2009-04-19T12:",  # Ends with time separator
            "2009-04-19T12:30:",  # Ends with time separator
            "2009-04-19T12:30:45.",  # Ends with time separator
            "2009-04-19T12:30:45.123456+",  # Ends with timzone separator
            "2009-04-19T12:30:45.123456-",  # Ends with timzone separator
            "2009-04-19T12:30:45.123456-05:00a",  # Extra text
            "2009-04-19T12:30:45.123-05:00a",  # Extra text
            "2009-04-19T12:30:45-05:00a",  # Extra text
        ]

        for bad_str in bad_strs:
            self.assertRaises(ValueError, self.theclass.fromisoformat, bad_str)


class TestTime(Static[TestCase]):
    theclass: type = time

    def test_basic_attributes(self):
        t = self.theclass(12, 0)
        self.assertEqual(t.hour, 12)
        self.assertEqual(t.minute, 0)
        self.assertEqual(t.second, 0)
        self.assertEqual(t.microsecond, 0)

    def test_basic_attributes_nonzero(self):
        # Make sure all attributes are non-zero so bugs in
        # bit-shifting access show up.
        t = self.theclass(12, 59, 59, 8000)
        self.assertEqual(t.hour, 12)
        self.assertEqual(t.minute, 59)
        self.assertEqual(t.second, 59)
        self.assertEqual(t.microsecond, 8000)

    def test_comparing(self):
        args = (1, 2, 3, 4)
        newargsx = [(2, 2, 3, 4), (1, 3, 3, 4), (1, 2, 4, 4), (1, 2, 3, 5)]
        t1 = self.theclass(*args)
        t2 = self.theclass(*args)
        self.assertEqual(t1, t2)
        self.assertTrue(t1 &lt;= t2)
        self.assertTrue(t1 &gt;= t2)
        self.assertFalse(t1 != t2)
        self.assertFalse(t1 &lt; t2)
        self.assertFalse(t1 &gt; t2)

        for i in range(len(args)):
            newargs = newargsx[i]
            t2 = self.theclass(*newargs)  # this is larger than t1
            self.assertTrue(t1 &lt; t2)
            self.assertTrue(t2 &gt; t1)
            self.assertTrue(t1 &lt;= t2)
            self.assertTrue(t2 &gt;= t1)
            self.assertTrue(t1 != t2)
            self.assertTrue(t2 != t1)
            self.assertFalse(t1 == t2)
            self.assertFalse(t2 == t1)
            self.assertFalse(t1 &gt; t2)
            self.assertFalse(t2 &lt; t1)
            self.assertFalse(t1 &gt;= t2)
            self.assertFalse(t2 &lt;= t1)

        """
        for badarg in OTHERSTUFF:
            self.assertEqual(t1 == badarg, False)
            self.assertEqual(t1 != badarg, True)
            self.assertEqual(badarg == t1, False)
            self.assertEqual(badarg != t1, True)

            self.assertRaises(TypeError, lambda: t1 &lt;= badarg)
            self.assertRaises(TypeError, lambda: t1 &lt; badarg)
            self.assertRaises(TypeError, lambda: t1 &gt; badarg)
            self.assertRaises(TypeError, lambda: t1 &gt;= badarg)
            self.assertRaises(TypeError, lambda: badarg &lt;= t1)
            self.assertRaises(TypeError, lambda: badarg &lt; t1)
            self.assertRaises(TypeError, lambda: badarg &gt; t1)
            self.assertRaises(TypeError, lambda: badarg &gt;= t1)
        """

    def test_bad_constructor_arguments(self):
        # bad hours
        self.theclass(0, 0)  # no exception
        self.theclass(23, 0)  # no exception

        make_time1 = lambda a, b: self.theclass(a, b)
        make_time2 = lambda a, b, c: self.theclass(a, b, c)
        make_time3 = lambda a, b, c, d: self.theclass(a, b, c, d)

        self.assertRaises(ValueError, make_time1, -1, 0)
        self.assertRaises(ValueError, make_time1, 24, 0)
        # bad minutes
        self.theclass(23, 0)  # no exception
        self.theclass(23, 59)  # no exception
        self.assertRaises(ValueError, make_time1, 23, -1)
        self.assertRaises(ValueError, make_time1, 23, 60)
        # bad seconds
        self.theclass(23, 59, 0)  # no exception
        self.theclass(23, 59, 59)  # no exception
        self.assertRaises(ValueError, make_time2, 23, 59, -1)
        self.assertRaises(ValueError, make_time2, 23, 59, 60)
        # bad microseconds
        self.theclass(23, 59, 59, 0)  # no exception
        self.theclass(23, 59, 59, 999999)  # no exception
        self.assertRaises(ValueError, make_time3, 23, 59, 59, -1)
        self.assertRaises(ValueError, make_time3, 23, 59, 59, 1000000)

    def test_hash_equality(self):
        d = self.theclass(23, 30, 17)
        e = self.theclass(23, 30, 17)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

        d = self.theclass(0, 5, 17)
        e = self.theclass(0, 5, 17)
        self.assertEqual(d, e)
        self.assertEqual(hash(d), hash(e))

        dic = {d: 1}
        dic[e] = 2
        self.assertEqual(len(dic), 1)
        self.assertEqual(dic[d], 2)
        self.assertEqual(dic[e], 2)

    def test_isoformat(self):
        t = self.theclass(4, 5, 1, 123)
        self.assertEqual(t.isoformat(), "04:05:01.000123")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass()
        self.assertEqual(t.isoformat(), "00:00:00")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=1)
        self.assertEqual(t.isoformat(), "00:00:00.000001")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=10)
        self.assertEqual(t.isoformat(), "00:00:00.000010")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=100)
        self.assertEqual(t.isoformat(), "00:00:00.000100")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=1000)
        self.assertEqual(t.isoformat(), "00:00:00.001000")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=10000)
        self.assertEqual(t.isoformat(), "00:00:00.010000")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(microsecond=100000)
        self.assertEqual(t.isoformat(), "00:00:00.100000")
        self.assertEqual(t.isoformat(), str(t))

        t = self.theclass(hour=12, minute=34, second=56, microsecond=123456)
        self.assertEqual(t.isoformat(timespec="hours"), "12")
        self.assertEqual(t.isoformat(timespec="minutes"), "12:34")
        self.assertEqual(t.isoformat(timespec="seconds"), "12:34:56")
        self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.123")
        self.assertEqual(t.isoformat(timespec="microseconds"), "12:34:56.123456")
        self.assertEqual(t.isoformat(timespec="auto"), "12:34:56.123456")

        t = self.theclass(hour=12, minute=34, second=56, microsecond=999500)
        self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.999")

        t = self.theclass(hour=12, minute=34, second=56, microsecond=0)
        self.assertEqual(t.isoformat(timespec="milliseconds"), "12:34:56.000")
        self.assertEqual(t.isoformat(timespec="microseconds"), "12:34:56.000000")
        self.assertEqual(t.isoformat(timespec="auto"), "12:34:56")

    def test_str(self):
        self.assertEqual(str(self.theclass(1, 2, 3, 4)), "01:02:03.000004")
        self.assertEqual(str(self.theclass(10, 2, 3, 4000)), "10:02:03.004000")
        self.assertEqual(str(self.theclass(0, 2, 3, 400000)), "00:02:03.400000")
        self.assertEqual(str(self.theclass(12, 2, 3, 0)), "12:02:03")
        self.assertEqual(str(self.theclass(23, 15, 0, 0)), "23:15:00")

    def test_repr(self):
        self.assertEqual(
            repr(self.theclass(1, 2, 3, 4)),
            "time(hour=1, minute=2, second=3, microsecond=4)",
        )
        self.assertEqual(
            repr(self.theclass(10, 2, 3, 4000)),
            "time(hour=10, minute=2, second=3, microsecond=4000)",
        )
        self.assertEqual(
            repr(self.theclass(0, 2, 3, 400000)),
            "time(hour=0, minute=2, second=3, microsecond=400000)",
        )
        self.assertEqual(
            repr(self.theclass(12, 2, 3, 0)), "time(hour=12, minute=2, second=3)"
        )
        self.assertEqual(repr(self.theclass(23, 15, 0, 0)), "time(hour=23, minute=15)")

    def test_resolution_info(self):
        self.assertTrue(self.theclass.max &gt; self.theclass.min)

    def test_bool(self):
        # time is always True.
        cls = self.theclass
        self.assertTrue(cls(1))
        self.assertTrue(cls(0, 1))
        self.assertTrue(cls(0, 0, 1))
        self.assertTrue(cls(0, 0, 0, 1))
        self.assertTrue(cls(0))
        self.assertTrue(cls())

    def test_replace(self):
        cls = self.theclass
        args = (1, 2, 3, 4)
        base = cls(*args)
        self.assertEqual(base, base.replace())

        self.assertEqual(base.replace(hour=5), cls(5, 2, 3, 4))
        self.assertEqual(base.replace(minute=6), cls(1, 6, 3, 4))
        self.assertEqual(base.replace(second=7), cls(1, 2, 7, 4))
        self.assertEqual(base.replace(microsecond=8), cls(1, 2, 3, 8))

        # Out of bounds.
        base = cls(1)
        self.assertRaises(ValueError, lambda: base.replace(hour=24))
        self.assertRaises(
            ValueError, lambda: base.replace(minute=-2)
        )  # minute=-1 indicates default; changed to -2 for test
        self.assertRaises(ValueError, lambda: base.replace(second=100))
        self.assertRaises(ValueError, lambda: base.replace(microsecond=1000000))


case_td = TestTimeDelta()
case_td.test_computations()
case_td.test_constructor()
case_td.test_resolution_info()
case_td.test_basic_attributes()
case_td.test_total_seconds()
case_td.test_carries()
case_td.test_hash_equality()
case_td.test_compare()
case_td.test_str()
case_td.test_repr()
case_td.test_microsecond_rounding()
case_td.test_massive_normalization()
case_td.test_bool()
case_td.test_division()
case_td.test_remainder()
case_td.test_divmod()

case_do = TestDateOnly()
case_do.test_delta_non_days_ignored()

case_dx = TestDate[date]()
case_dx.test_basic_attributes()
case_dx.test_ordinal_conversions()
# case_dx.test_extreme_ordinals()
case_dx.test_bad_constructor_arguments()
case_dx.test_hash_equality()
case_dx.test_computations()
case_dx.test_fromtimestamp()
case_dx.test_today()
case_dx.test_weekday()
case_dx.test_isocalendar()
case_dx.test_iso_long_years()
case_dx.test_isoformat()
case_dx.test_ctime()
case_dx.test_timetuple()
case_dx.test_compare()
case_dx.test_replace()
case_dx.test_fromisoformat()
case_dx.test_fromisoformat_fails()
case_dx.test_fromisocalendar()
case_dx.test_fromisocalendar_value_errors()

case_dt = TestDateTime[datetime]()
case_dt.test_ordinal_conversions()
case_dt.test_today()
case_dt.test_weekday()
case_dt.test_isocalendar()
case_dt.test_iso_long_years()
case_dt.test_ctime()
case_dt.test_timetuple()
case_dt.test_compare()
case_dt.test_fromisoformat()
case_dt.test_fromisoformat_fails()
case_dt.test_fromisocalendar_value_errors()
# ---
case_dt.test_basic_attributes()
case_dt.test_basic_attributes_nonzero()
case_dt.test_isoformat()
# case_dt.test_more_ctime()
case_dt.test_tz_independent_comparing()
case_dt.test_bad_constructor_arguments()
case_dt.test_hash_equality()
case_dt.test_computations()
case_dt.test_more_compare()
case_dt.test_fromtimestamp()
# case_dt.test_utcfromtimestamp()
case_dt.test_timestamp_naive()
# case_dt.test_microsecond_rounding()
# case_dt.test_timestamp_limits()
case_dt.test_negative_float_fromtimestamp()
# case_dt.test_negative_float_utcfromtimestamp()
case_dt.test_utcnow()
case_dt.test_extract()
case_dt.test_combine()
case_dt.test_replace()
case_dt.test_fromisoformat_datetime()
case_dt.test_fromisoformat_separators()
case_dt.test_fromisoformat_ambiguous()
case_dt.test_fromisoformat_timespecs()
case_dt.test_fromisoformat_fails_datetime()

case_tx = TestTime()
case_tx.test_basic_attributes()
case_tx.test_basic_attributes_nonzero()
case_tx.test_comparing()
case_tx.test_bad_constructor_arguments()
case_tx.test_hash_equality()
case_tx.test_isoformat()
case_tx.test_str()
case_tx.test_repr()
case_tx.test_resolution_info()
case_tx.test_bool()
case_tx.test_replace()

@test
def test_constants():
    assert str(timedelta.min) == '-106751992 days, 19:59:05.224192'  # note: diff w/ Python
    assert str(timedelta.max) == '106751991 days, 4:00:54.775807'    # note: diff w/ Python
    assert str(timedelta.resolution) == '0:00:00.000001'

    assert str(date.min) == '0001-01-01'
    assert str(date.max) == '9999-12-31'
    assert str(date.resolution) == '1 day, 0:00:00'

    assert str(time.min) == '00:00:00'
    assert str(time.max) == '23:59:59.999999'
    assert str(time.resolution) == '0:00:00.000001'

    assert str(datetime.min) == '0001-01-01 00:00:00'
    assert str(datetime.max) == '9999-12-31 23:59:59.999999'
    assert str(datetime.resolution) == '0:00:00.000001'
test_constants()
</t>
<t tx="ekr.20230509083244.149">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import heapq
from random import random, randrange


@test
def check_invariant(heap):
    # Check the heap invariant.
    for pos, item in enumerate(heap):
        if pos:  # pos 0 has no parent
            parentpos = (pos - 1) &gt;&gt; 1
            assert heap[parentpos] &lt;= item


@test
def test_heapify():
    for size in list(range(30)) + [20000]:
        heap = [random() for dummy in range(size)]
        heapq.heapify(heap)
        check_invariant(heap)


@test
def test_naive_nbest():
    data = [randrange(2000) for i in range(1000)]
    heap = []
    for item in data:
        heapq.heappush(heap, item)
        if len(heap) &gt; 10:
            heapq.heappop(heap)
    heap.sort()
    assert heap == sorted(data)[-10:]


def heapiter(heap):
    # An iterator returning a heap's elements, smallest-first.
    while heap:
        yield heapq.heappop(heap)


@test
def test_nbest():
    # Less-naive "N-best" algorithm, much faster (if len(data) is big
    # enough &lt;wink&gt;) than sorting all of data.  However, if we had a max
    # heap instead of a min heap, it could go faster still via
    # heapify'ing all of data (linear time), then doing 10 heappops
    # (10 log-time steps).
    data = [randrange(2000) for i in range(1000)]
    heap = data[:10]
    heapq.heapify(heap)
    for item in data[10:]:
        if item &gt; heap[0]:  # this gets rarer the longer we run
            heapq.heapreplace(heap, item)
    assert list(heapiter(heap)) == sorted(data)[-10:]


@test
def test_nbest_with_pushpop():
    data = [randrange(2000) for i in range(1000)]
    heap = data[:10]
    heapq.heapify(heap)
    for item in data[10:]:
        heapq.heappushpop(heap, item)
    assert list(heapiter(heap)) == sorted(data)[-10:]
    assert heapq.heappushpop(List[str](), "x") == "x"


@test
def test_heappushpop():
    h = List[int]()
    x = heapq.heappushpop(h, 10)
    assert (h, x) == (List[int](), 10)

    h = [10]
    x = heapq.heappushpop(h, 9)
    assert (h, x) == ([10], 9)

    h = [10]
    x = heapq.heappushpop(h, 11)
    assert (h, x) == ([11], 10)


@test
def test_heappop_max():
    # _heapop_max has an optimization for one-item lists which isn't
    # covered in other tests, so test that case explicitly here
    h = [3, 2]
    assert heapq._heappop_max(h) == 3
    assert heapq._heappop_max(h) == 2


@test
def test_heapsort():
    # Exercise everything with repeated heapsort checks
    for trial in range(100):
        size = randrange(50)
        data = [randrange(25) for i in range(size)]
        heap = None
        if trial &amp; 1:  # Half of the time, use heapify
            heap = data[:]
            heapq.heapify(heap)
        else:  # The rest of the time, use heappush
            heap = []
            for item in data:
                heapq.heappush(heap, item)
        heap_sorted = [heapq.heappop(heap) for i in range(size)]
        assert heap_sorted == sorted(data)


"""
def test_merge(self):
    inputs = []
    for i in range(randrange(25)):
        row = []
        for j in range(randrange(100)):
            tup = choice('ABC'), randrange(-500, 500)
            row.append(tup)
        inputs.append(row)

    for key in [None, itemgetter(0), itemgetter(1), itemgetter(1, 0)]:
        for reverse in [False, True]:
            seqs = []
            for seq in inputs:
                seqs.append(sorted(seq, key=key, reverse=reverse))
            self.assertEqual(sorted(chain(*inputs), key=key, reverse=reverse),
                             list(heapq.merge(*seqs, key=key, reverse=reverse)))
            self.assertEqual(list(heapq.merge()), [])

def test_empty_merges(self):
    # Merging two empty lists (with or without a key) should produce
    # another empty list.
    self.assertEqual(list(heapq.merge([], [])), [])
    self.assertEqual(list(heapq.merge([], [], key=lambda: 6)), [])

def test_merge_does_not_suppress_index_error(self):
    # Issue 19018: Heapq.merge suppresses IndexError from user generator
    def iterable():
        s = list(range(10))
        for i in range(20):
            yield s[i]       # IndexError when i &gt; 10
    with self.assertRaises(IndexError):
        list(heapq.merge(iterable(), iterable()))

def test_merge_stability(self):
    class Int(int):
        pass
    inputs = [[], [], [], []]
    for i in range(20000):
        stream = randrange(4)
        x = randrange(500)
        obj = Int(x)
        obj.pair = (x, stream)
        inputs[stream].append(obj)
    for stream in inputs:
        stream.sort()
    result = [i.pair for i in heapq.merge(*inputs)]
    self.assertEqual(result, sorted(result))
"""


def mykey(x: Tuple[int, int]):
    return (x[0] * 547 % 2000, x[1] * 547 % 2000)


@test
def test_nsmallest():
    data = [(randrange(2000), i) for i in range(1000)]
    for n in (10,):
        assert list(heapq.nsmallest(n, data)) == sorted(data)[: min(n, len(data))]
        assert (
            list(heapq.nsmallest(n, data, key=mykey))
            == sorted(data, key=mykey)[: min(n, len(data))]
        )
        assert list(heapq.nsmallest(n, data)) == sorted(data)[: min(n, len(data))]


@test
def test_nlargest():
    data = [(randrange(2000), i) for i in range(1000)]
    for n in (0, 1, 2, 10, 100, 400, 999, 1000, 1100):
        assert list(heapq.nlargest(n, data)) == sorted(data)[::-1][: min(n, len(data))]
        assert (
            list(heapq.nlargest(n, data, key=mykey))
            == sorted(data, key=mykey)[::-1][: min(n, len(data))]
        )
        assert list(heapq.nlargest(n, data)) == sorted(data)[::-1][: min(n, len(data))]


@test
def test_comparison_operator():
    def hsort(data: List[float], T: type):
        data2 = [T(x) for x in data]
        heapq.heapify(data2)
        return [heapq.heappop(data2).x for i in range(len(data))]

    class LT:
        x: float

        def __init__(self, x: float):
            self.x = x

        def __lt__(self, other: LT):
            return self.x &gt; other.x

    data = [random() for i in range(100)]
    target = list(reversed(sorted(data)))
    assert hsort(data, LT) == target


@test
def test_merge():
    assert [0, 1, 2, 3, 4, 5, 5, 7, 8, 10, 15, 20, 25] == list(heapq.merge([1, 3, 5, 7], [0, 2, 4, 8], [5, 10, 15, 20], List[int](), [25]))
    assert ['dog', 'cat', 'fish', 'horse', 'kangaroo'] == list(heapq.merge(['dog', 'horse'], ['cat', 'fish', 'kangaroo'], key=len))

    assert [25, 20, 15, 10, 8, 7, 5, 5, 4, 3, 2, 1, 0] == list(heapq.merge([7, 5, 3, 1], [8, 4, 2, 0], [20, 15, 10, 5], List[int](), [25], reverse=True))
    assert ['kangaroo', 'horse', 'fish', 'dog', 'cat'] == list(heapq.merge(['horse', 'dog'], ['kangaroo', 'fish', 'cat'], key=len, reverse=True))


test_heapify()
test_naive_nbest()
test_nsmallest()
test_nlargest()
test_nbest()
test_nbest_with_pushpop()
test_heappushpop()
test_heappop_max()
test_heapsort()
# test_comparison_operator()
test_merge()
</t>
<t tx="ekr.20230509083244.15">class SeqTest : public testing::TestWithParam&lt;
                    tuple&lt;string /*filename*/, bool /*debug*/, string /* case name */,
                          string /* case code */, int /* case line */,
                          bool /* barebones stdlib */, bool /* Python numerics */&gt;&gt; {
  vector&lt;char&gt; buf;
  int out_pipe[2];
  pid_t pid;

public:
  SeqTest() : buf(65536), out_pipe(), pid() {}
  string getFilename(const string &amp;basename) {
    return string(TEST_DIR) + "/" + basename;
  }
  @others
  string result() { return string(buf.data()); }
};
</t>
<t tx="ekr.20230509083244.150">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import itertools
from itertools import *
import math


def lzip(*args):
    return list(zip(*args))


def onearg(x):
    "Test function of one argument"
    return 2 * x


def errfunc(*args):
    "Test function that raises an error"
    raise ValueError()


def gen3():
    "Non-restartable source sequence"
    for i in (0, 1, 2):
        yield i


def isEven(x):
    "Test predicate"
    return x % 2 == 0


def isOdd(x):
    "Test predicate"
    return x % 2 == 1


def tupleize(*args):
    return args


def irange(n):
    for i in range(n):
        yield i


def take(n, seq):
    "Convenience function for partially consuming a long of infinite iterable"
    return list(islice(seq, n))


def testR(r):
    return r[0]


def testR2(r):
    return r[2]


def underten(x):
    return x &lt; 10


@test
def test_combinations():
    assert list(itertools.combinations("ABCD", 2)) == [
        ["A", "B"],
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    test_intermediate = itertools.combinations("ABCD", 2)
    next(test_intermediate)
    assert list(test_intermediate) == [
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    assert list(itertools.combinations(range(4), 3)) == [
        [0, 1, 2],
        [0, 1, 3],
        [0, 2, 3],
        [1, 2, 3],
    ]
    test_intermediate = itertools.combinations(range(4), 3)
    next(test_intermediate)
    assert list(test_intermediate) == [[0, 1, 3], [0, 2, 3], [1, 2, 3]]


@test
def test_combinations_with_replacement():
    assert list(itertools.combinations_with_replacement(range(3), 3)) == [
        [0, 0, 0],
        [0, 0, 1],
        [0, 0, 2],
        [0, 1, 1],
        [0, 1, 2],
        [0, 2, 2],
        [1, 1, 1],
        [1, 1, 2],
        [1, 2, 2],
        [2, 2, 2],
    ]
    assert list(itertools.combinations_with_replacement("ABC", 2)) == [
        ["A", "A"],
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]
    test_intermediate = itertools.combinations_with_replacement("ABC", 2)
    next(test_intermediate)
    assert list(test_intermediate) == [
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]


@test
def test_islice():
    ra100 = range(100)
    ra = range(10)
    assert list(itertools.islice(iter("ABCDEFG"), 0, 2, 1)) == ["A", "B"]
    assert list(itertools.islice(iter(ra100), 10, 20, 3)) == [10, 13, 16, 19]
    assert list(itertools.islice(iter(ra100), 10, 3, 20)) == []
    assert list(itertools.islice(iter(ra100), 10, 20, 1)) == [
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
    ]
    assert list(itertools.islice(iter(ra100), 10, 10, 1)) == []
    assert list(itertools.islice(iter(ra100), 10, 3, 1)) == []
    # stop=len(iterable)
    assert list(itertools.islice(iter(ra), 0, 10, 1)) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    assert list(itertools.islice(iter(ra), 2, 10, 1)) == [2, 3, 4, 5, 6, 7, 8, 9]
    assert list(itertools.islice(iter(ra), 1, 10, 2)) == [1, 3, 5, 7, 9]
    try:
        list(itertools.islice(iter(ra), -5, 10, 1))
        assert False
    except ValueError:
        pass


@test
def test_count():
    # infinite loop here
    assert take(3, itertools.count(3.25, 1.0)) == [3.25, 4.25, 5.25]
    assert take(3, zip("abc", itertools.count(3.25, 1.0))) == [
        ("a", 3.25),
        ("b", 4.25),
        ("c", 5.25),
    ]
    assert take(2, zip("abc", itertools.count(-1.0, 1.0))) == [("a", -1.0), ("b", 0.0)]
    assert take(2, zip("abc", itertools.count(-3.0, 1.0))) == [("a", -3.0), ("b", -2.0)]


@test
def test_repeat():
    assert list(itertools.repeat("a", 3)) == ["a", "a", "a"]
    assert list(itertools.repeat(1, 10)) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    assert list(itertools.repeat("a", -1)) == []
    assert len(list(itertools.repeat("a", 0))) == 0


@test
def test_cycle():
    assert take(10, zip("zzzzzzzzzzz", itertools.cycle(iter("abc")))) == [
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
        ("z", "b"),
        ("z", "c"),
        ("z", "a"),
    ]
    assert take(10, zip("zzzzzzzzzzz", itertools.cycle(["a", "b"]))) == [
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
        ("z", "a"),
        ("z", "b"),
    ]


@test
def test_compress():
    assert list(itertools.compress("ABCDEF", [1, 0, 1, 0, 1, 1])) == [
        "A",
        "C",
        "E",
        "F",
    ]
    assert list(itertools.compress("ABCDEF", [1, 1, 1, 1, 1, 1])) == [
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
    ]
    assert list(itertools.compress("ABCDEF", [1, 0, 1])) == ["A", "C"]
    assert list(itertools.compress("ABC", [0, 1, 1, 1, 1, 1])) == ["B", "C"]


@test
def test_dropwhile():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(itertools.dropwhile(underten, data)) == [20, 2, 4, 6, 8]


@test
def test_takewhile():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(itertools.takewhile(underten, data)) == [1, 3, 5]


@test
def test_filterfalse():
    assert list(itertools.filterfalse(isEven, range(10))) == [1, 3, 5, 7, 9]
    assert list(itertools.filterfalse(lambda x: bool(x), [0, 1, 0, 2, 0])) == [0, 0, 0]


@test
def test_permutations():
    assert list(itertools.permutations(range(3), 2)) == [
        [0, 1],
        [0, 2],
        [1, 0],
        [1, 2],
        [2, 0],
        [2, 1],
    ]

    for n in range(3):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(itertools.permutations(values, r))
            if r &gt; n:  # right number of perms
                assert len(result) == 0
            # factorial is not yet implemented in math
            # else: fact(n) / fact(n - r)


@test
def test_accumulate():
    # addition
    assert list(itertools.accumulate(range(10), int.__add__, initial=0)) == [
        0,
        0,
        1,
        3,
        6,
        10,
        15,
        21,
        28,
        36,
        45,
    ]
    assert list(itertools.accumulate([7], int.__add__, initial=0)) == [
        0,
        7,
    ]  # iterable of length 1
    assert list(itertools.accumulate(range(10), int.__add__)) == [
        0,
        1,
        3,
        6,
        10,
        15,
        21,
        28,
        36,
        45,
    ]
    assert list(itertools.accumulate([7], int.__add__)) == [7]  # iterable of length 1
    assert list(itertools.accumulate("abc", str.__add__, initial="")) == [
        "",
        "a",
        "ab",
        "abc",
    ]
    assert list(itertools.accumulate([""], str.__add__, initial=str(0))) == ["0", "0"]
    # multiply
    assert list(itertools.accumulate(range(10), int.__mul__, initial=0)) == [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
    ]
    assert list(itertools.accumulate([1, 2, 3, 4, 5], int.__mul__, initial=1)) == [
        1,
        1,
        2,
        6,
        24,
        120,
    ]
    assert list(itertools.accumulate([7], int.__mul__)) == [7]
    # pass


@test
def test_chain():
    assert list(itertools.chain("abc", "def")) == ["a", "b", "c", "d", "e", "f"]
    assert list(itertools.chain("abc")) == ["a", "b", "c"]
    assert list(itertools.chain("a", "b", "c")) == ["a", "b", "c"]
    assert list(itertools.chain(["abc", "def"])) == ["abc", "def"]
    assert list(itertools.chain(["abc"])) == ["abc"]
    assert list(itertools.chain(["a", "b", "c"])) == ["a", "b", "c"]


@test
def test_starmap():
    assert list(itertools.starmap(math.pow, [(2.0, 5.0), (3.0, 2.0), (10.0, 3.0)])) == [
        32.0,
        9.0,
        1000.0,
    ]
    assert list(itertools.starmap(math.pow, [(0.0, 1.0), (1.0, 2.0), (2.0, 3.0)])) == [
        0.0 ** 1.0,
        1.0 ** 2.0,
        2.0 ** 3.0,
    ]


@test
def test_groupby():
    def key_str(s: str):
        return s

    assert list(itertools.groupby(iter("AAAABBBCCDAABBC"), key_str)) == [
        ("A", ["A", "A", "A", "A"]),
        ("B", ["B", "B", "B"]),
        ("C", ["C", "C"]),
        ("D", ["D"]),
        ("A", ["A", "A"]),
        ("B", ["B", "B"]),
        ("C", ["C"]),
    ]


@test
def test_zip_longest():
    assert list(itertools.zip_longest("ABCDE", "12345", fillvalue="-")) == [
        ("A", "1"),
        ("B", "2"),
        ("C", "3"),
        ("D", "4"),
        ("E", "5"),
    ]
    assert list(itertools.zip_longest("ABCDE", "123", fillvalue="-")) == [
        ("A", "1"),
        ("B", "2"),
        ("C", "3"),
        ("D", "-"),
        ("E", "-"),
    ]
    assert list(itertools.zip_longest("123", "ABCDE", fillvalue="-")) == [
        ("1", "A"),
        ("2", "B"),
        ("3", "C"),
        ("-", "D"),
        ("-", "E"),
    ]
    assert list(itertools.zip_longest("", "ABCDE", fillvalue="-")) == [
        ("-", "A"),
        ("-", "B"),
        ("-", "C"),
        ("-", "D"),
        ("-", "E"),
    ]
    assert list(itertools.zip_longest("ABCDE", "", fillvalue="-")) == [
        ("A", "-"),
        ("B", "-"),
        ("C", "-"),
        ("D", "-"),
        ("E", "-"),
    ]
    assert not list(itertools.zip_longest("", "", fillvalue="-"))


@test
def test_zip_test():
    assert list(zip()) == []
    assert list(zip((1, 2))) == [(1,), (2,)]
    assert list(zip([1, 2], ["a", "b"], (False, True))) == [
        (1, "a", False),
        (2, "b", True),
    ]


test_combinations()
test_combinations_with_replacement()
test_islice()
test_count()
test_repeat()
test_cycle()
test_compress()
test_dropwhile()
test_takewhile()
test_filterfalse()
test_permutations()
test_accumulate()
test_chain()
test_starmap()
test_groupby()
test_zip_longest()
test_zip_test()


# Updated tests lifted from CPython test suite


@test
def test_accumulate_from_cpython():
    assert list(accumulate(range(10))) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
    assert list(accumulate(iterable=range(10))) == [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]
    assert list(accumulate("abc")) == ["a", "ab", "abc"]
    assert list(accumulate(List[float]())) == []
    assert list(accumulate([7])) == [7]

    s = [2, 8, 9, 5, 7, 0, 3, 4, 1, 6]
    assert list(accumulate(s, min)) == [2, 2, 2, 2, 2, 0, 0, 0, 0, 0]
    assert list(accumulate(s, max)) == [2, 8, 9, 9, 9, 9, 9, 9, 9, 9]
    mul = lambda a, b: a * b
    assert list(accumulate(s, mul)) == [2, 16, 144, 720, 5040, 0, 0, 0, 0, 0]

    # assert list(accumulate([10, 5, 1], initial=None)) == [10, 15, 16]
    assert list(accumulate([10, 5, 1], initial=100)) == [100, 110, 115, 116]
    assert list(accumulate([10, 5, 1], initial=100.5)) == [100.5, 110.5, 115.5, 116.5]
    assert list(accumulate(List[int](), initial=100)) == [100]


test_accumulate_from_cpython()


@test
def test_chain_from_cpython():
    assert list(chain("abc", "def")) == list("abcdef")
    assert list(chain("abc")) == list("abc")
    assert list(chain("")) == []
    assert list(take(4, chain("abc", "def"))) == list("abcd")


test_chain_from_cpython()


@test
def test_chain_from_iterable_from_cpython():
    assert list(chain.from_iterable(["abc", "def"])) == list("abcdef")
    assert list(chain.from_iterable(["abc"])) == list("abc")
    assert list(chain.from_iterable([""])) == []
    assert take(4, chain.from_iterable(["abc", "def"])) == list("abcd")


test_chain_from_iterable_from_cpython()


@test
def test_combinations_from_cpython():
    from math import factorial as fact

    err = False
    try:
        list(combinations("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(combinations("abc", 32)) == []  # r &gt; n
    assert list(combinations("ABCD", 2)) == [
        ["A", "B"],
        ["A", "C"],
        ["A", "D"],
        ["B", "C"],
        ["B", "D"],
        ["C", "D"],
    ]
    assert list(combinations(range(4), 3)) == [
        [0, 1, 2],
        [0, 1, 3],
        [0, 2, 3],
        [1, 2, 3],
    ]

    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(combinations(values, r))

            assert len(result) == (0 if r &gt; n else fact(n) // fact(r) // fact(n - r))
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                     # lexicographic order
            for c in result:
                assert len(c) == r  # r-length combinations
                assert len(set(c)) == r  # no duplicate elements
                assert list(c) == sorted(c)  # keep original ordering
                assert all(e in values for e in c)  # elements taken from input iterable
                assert list(c) == [
                    e for e in values if e in c
                ]  # comb is a subsequence of the input iterable


test_combinations_from_cpython()


@test
def test_combinations_with_replacement_from_cpython():
    cwr = combinations_with_replacement
    err = False
    try:
        list(cwr("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(cwr("ABC", 2)) == [
        ["A", "A"],
        ["A", "B"],
        ["A", "C"],
        ["B", "B"],
        ["B", "C"],
        ["C", "C"],
    ]

    def numcombs(n, r):
        from math import factorial as fact

        if not n:
            return 0 if r else 1
        return fact(n + r - 1) // fact(r) // fact(n - 1)

    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(cwr(values, r))
            regular_combs = list(combinations(values, r))

            assert len(result) == numcombs(n, r)
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                     # lexicographic order

            if n == 0 or r &lt;= 1:
                assert result == regular_combs  # cases that should be identical
            else:
                assert set(result) &gt;= set(regular_combs)

            for c in result:
                assert len(c) == r  # r-length combinations
                noruns = [k for k, v in groupby(c)]  # combo without consecutive repeats
                assert len(noruns) == len(
                    set(noruns)
                )  # no repeats other than consecutive
                assert list(c) == sorted(c)  # keep original ordering
                assert all(e in values for e in c)  # elements taken from input iterable
                assert noruns == [
                    e for e in values if e in c
                ]  # comb is a subsequence of the input iterable


test_combinations_with_replacement_from_cpython()


@test
def test_permutations_from_cpython():
    from math import factorial as fact

    err = False
    try:
        list(permutations("abc", -2))
        assert False
    except ValueError:
        err = True
    assert err

    assert list(permutations("abc", 32)) == []
    assert list(permutations(range(3), 2)) == [
        [0, 1],
        [0, 2],
        [1, 0],
        [1, 2],
        [2, 0],
        [2, 1],
    ]

    for n in range(7):
        values = [5 * x - 12 for x in range(n)]
        for r in range(n + 2):
            result = list(permutations(values, r))
            assert len(result) == (
                0 if r &gt; n else fact(n) // fact(n - r)
            )  # right number of perms
            assert len(result) == len(set(result))  # no repeats
            # assert result == sorted(result)                # lexicographic order
            for p in result:
                assert len(p) == r  # r-length permutations
                assert len(set(p)) == r  # no duplicate elements
                assert all(e in values for e in p)  # elements taken from input iterable

            if r == n:
                assert result == list(permutations(values, None))  # test r as None
                assert result == list(permutations(values))  # test default r


test_permutations_from_cpython()


@extend
class List:
    def __lt__(self, other: List[T]):
        if len(self) != len(other):
            return len(self) &lt; len(other)
        for a, b in zip(self, other):
            if a &lt; b:
                return True
            if a &gt; b:
                return False
        return False

    def __le__(self, other: List[T]):
        if len(self) != len(other):
            return len(self) &lt; len(other)
        for a, b in zip(self, other):
            if a &lt; b:
                return True
            if a &gt; b:
                return False
        return True

    def __gt__(self, other: List[T]):
        if len(self) != len(other):
            return len(self) &lt; len(other)
        for a, b in zip(self, other):
            if a &gt; b:
                return True
            if a &lt; b:
                return False
        return False

    def __ge__(self, other: List[T]):
        if len(self) != len(other):
            return len(self) &lt; len(other)
        for a, b in zip(self, other):
            if a &gt; b:
                return True
            if a &lt; b:
                return False
        return True


@test
def test_combinatorics_from_cpython():
    # Test relationships between product(), permutations(),
    # combinations() and combinations_with_replacement().
    from math import factorial as fact

    for n in range(6):
        s = "ABCDEFG"[:n]
        for r in range(8):
            prod = list(product(s, repeat=r))
            cwr = list(combinations_with_replacement(s, r))
            perm = list(permutations(s, r))
            comb = list(combinations(s, r))

            # Check size
            assert len(prod) == n ** r
            assert len(cwr) == (
                (fact(n + r - 1) // fact(r) // fact(n - 1)) if n else (0 if r else 1)
            )
            assert len(perm) == (0 if r &gt; n else fact(n) // fact(n - r))
            assert len(comb) == (0 if r &gt; n else fact(n) // fact(r) // fact(n - r))

            # Check lexicographic order without repeated tuples
            assert prod == sorted(set(prod))
            assert cwr == sorted(set(cwr))
            assert perm == sorted(set(perm))
            assert comb == sorted(set(comb))

            # Check interrelationships
            assert cwr == [
                t for t in prod if sorted(t) == list(t)
            ]  # cwr: prods which are sorted
            assert perm == [
                t for t in prod if len(set(t)) == r
            ]  # perm: prods with no dups
            assert comb == [
                t for t in perm if sorted(t) == list(t)
            ]  # comb: perms that are sorted
            assert comb == [
                t for t in cwr if len(set(t)) == r
            ]  # comb: cwrs without dups
            assert comb == list(
                filter(set(cwr).__contains__, perm)
            )  # comb: perm that is a cwr
            assert comb == list(
                filter(set(perm).__contains__, cwr)
            )  # comb: cwr that is a perm
            assert comb == sorted(set(cwr) &amp; set(perm))  # comb: both a cwr and a perm


test_combinatorics_from_cpython()


@test
def test_compress_from_cpython():
    assert list(compress(data="ABCDEF", selectors=[1, 0, 1, 0, 1, 1])) == list("ACEF")
    assert list(compress("ABCDEF", [1, 0, 1, 0, 1, 1])) == list("ACEF")
    assert list(compress("ABCDEF", [0, 0, 0, 0, 0, 0])) == list("")
    assert list(compress("ABCDEF", [1, 1, 1, 1, 1, 1])) == list("ABCDEF")
    assert list(compress("ABCDEF", [1, 0, 1])) == list("AC")
    assert list(compress("ABC", [0, 1, 1, 1, 1, 1])) == list("BC")
    n = 10000
    data = chain.from_iterable(repeat(range(6), n))
    selectors = chain.from_iterable(repeat((0, 1)))
    assert list(compress(data, selectors)) == [1, 3, 5] * n


test_compress_from_cpython()


@test
def test_count_from_cpython():
    assert lzip("abc", count()) == [("a", 0), ("b", 1), ("c", 2)]
    assert lzip("abc", count(3)) == [("a", 3), ("b", 4), ("c", 5)]
    assert take(2, lzip("abc", count(3))) == [("a", 3), ("b", 4)]
    assert take(2, zip("abc", count(-1))) == [("a", -1), ("b", 0)]
    assert take(2, zip("abc", count(-3))) == [("a", -3), ("b", -2)]
    assert take(3, count(3.25)) == [3.25, 4.25, 5.25]


test_count_from_cpython()


@test
def test_count_with_stride_from_cpython():
    assert lzip("abc", count(2, 3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert lzip("abc", count(start=2, step=3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert lzip("abc", count(step=-1)) == [("a", 0), ("b", -1), ("c", -2)]
    assert lzip("abc", count(2, 0)) == [("a", 2), ("b", 2), ("c", 2)]
    assert lzip("abc", count(2, 1)) == [("a", 2), ("b", 3), ("c", 4)]
    assert lzip("abc", count(2, 3)) == [("a", 2), ("b", 5), ("c", 8)]
    assert take(3, count(2.0, 1.25)) == [2.0, 3.25, 4.5]


test_count_with_stride_from_cpython()


@test
def test_cycle_from_cpython():
    assert take(10, cycle("abc")) == list("abcabcabca")
    assert list(cycle("")) == []
    assert list(islice(cycle(gen3()), 10)) == [0, 1, 2, 0, 1, 2, 0, 1, 2, 0]


test_cycle_from_cpython()


@test
def test_groupby_from_cpython():
    # Check whether it accepts arguments correctly
    assert [] == list(groupby(List[int]()))
    assert [] == list(groupby(List[int](), key=lambda a: a))
    # Check normal input
    if 1:
        s = [
            (0, 10, 20),
            (0, 11, 21),
            (0, 12, 21),
            (1, 13, 21),
            (1, 14, 22),
            (2, 15, 22),
            (3, 16, 23),
            (3, 17, 23),
        ]

        if 1:
            dup = []
            for k, g in groupby(s, lambda r: r[0]):
                for elem in g:
                    assert k == elem[0]
                    dup.append(elem)
            assert s == dup

        # Check nested case
        if 1:
            dup = []
            for k, g in groupby(s, testR):
                for ik, ig in groupby(g, testR2):
                    for elem in ig:
                        assert k == elem[0]
                        assert ik == elem[2]
                        dup.append(elem)
            assert s == dup

        # Check case where inner iterator is not used
        keys = [k for k, g in groupby(s, testR)]
        expectedkeys = set([r[0] for r in s])
        assert set(keys) == expectedkeys
        assert len(keys) == len(expectedkeys)

    if 1:
        # Exercise pipes and filters style
        s = "abracadabra"
        if 1:
            # sort s | uniq
            r = [k for k, g in groupby(sorted(s))]
            assert r == ["a", "b", "c", "d", "r"]
        if 1:
            # sort s | uniq -d
            r = [k for k, g in groupby(sorted(s)) if list(islice(g, 1, 2))]
            assert r == ["a", "b", "r"]
        if 1:
            # sort s | uniq -c
            r = [(len(list(g)), k) for k, g in groupby(sorted(s))]
            assert r == [(5, "a"), (2, "b"), (1, "c"), (1, "d"), (2, "r")]
        if 1:
            # sort s | uniq -c | sort -rn | head -3
            r = sorted(
                [(len(list(g)), k) for k, g in groupby(sorted(s))], reverse=True
            )[:3]
            assert r == [(5, "a"), (2, "r"), (2, "b")]


test_groupby_from_cpython()


@test
def test_filter_from_cpython():
    assert list(filter(isEven, range(6))) == [0, 2, 4]
    # assert list(filter(None, [0,1,0,2,0])) == [1,2]  # TODO
    assert list(filter(lambda x: bool(x), [0, 1, 0, 2, 0])) == [1, 2]
    assert take(4, filter(isEven, count())) == [0, 2, 4, 6]


test_filter_from_cpython()


@test
def test_filterfalse_from_cpython():
    assert list(filterfalse(isEven, range(6))) == [1, 3, 5]
    # assert list(filter(None, [0,1,0,2,0])) == [0,0,0]  # TODO
    assert list(filterfalse(lambda x: bool(x), [0, 1, 0, 2, 0])) == [0, 0, 0]
    assert take(4, filterfalse(isEven, count())) == [1, 3, 5, 7]


test_filterfalse_from_cpython()


@test
def test_zip_from_cpython():
    ans = [(x, y) for x, y in zip("abc", count())]
    assert ans == [("a", 0), ("b", 1), ("c", 2)]
    assert list(zip("abc", range(6))) == lzip("abc", range(6))
    assert list(zip("abcdef", range(3))) == lzip("abcdef", range(3))
    assert take(3, zip("abcdef", count())) == lzip("abcdef", range(3))
    assert list(zip("abcdef")) == lzip("abcdef")
    assert list(zip()) == lzip()
    assert [pair for pair in zip("abc", "def")] == lzip("abc", "def")


test_zip_from_cpython()


@test
def test_ziplongest_from_cpython():
    for args in (
        (range(1000), range(2000, 2100), range(3000, 3050)),
        (range(1000), range(0), range(3000, 3050), range(1200), range(1500)),
        (range(1000), range(0), range(3000, 3050), range(1200), range(1500), range(0)),
    ):
        target = [
            tuple(arg[i] if i &lt; len(arg) else None for arg in args)
            for i in range(max(map(len, args)))
        ]
        assert str(list(zip_longest(*args))) == str(target)
        target2 = [
            [(-999 if e is None else e.__val__()) for e in t] for t in target
        ]  # Replace None fills with 'X'
        assert list(zip_longest(*args, fillvalue=-999)) == target2

    assert (
        str(list(zip_longest("abc", range(6))))
        == "[('a', 0), ('b', 1), ('c', 2), (None, 3), (None, 4), (None, 5)]"
    )
    assert (
        str(list(zip_longest(range(6), "abc")))
        == "[(0, 'a'), (1, 'b'), (2, 'c'), (3, None), (4, None), (5, None)]"
    )


test_ziplongest_from_cpython()


@test
def test_product_from_cpython():
    for args, result in (
        # ((), [()]),                     # zero iterables  # TODO
        (("ab",), [("a",), ("b",)]),  # one iterable
        (
            (range(2), range(3)),
            [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2)],
        ),  # two iterables
        (
            (range(0), range(2), range(3)),
            List[Tuple[int, int, int]](),
        ),  # first iterable with zero length
        (
            (range(2), range(0), range(3)),
            List[Tuple[int, int, int]](),
        ),  # middle iterable with zero length
        (
            (range(2), range(3), range(0)),
            List[Tuple[int, int, int]](),
        ),  # last iterable with zero length
    ):
        assert list(product(*args)) == result

    assert (
        len(list(product(range(7), range(7), range(7), range(7), range(7), range(7))))
        == 7 ** 6
    )


test_product_from_cpython()


@test
def test_repeat_from_cpython():
    assert list(repeat(object="a", times=3)) == ["a", "a", "a"]
    assert lzip(range(3), repeat("a")) == [(0, "a"), (1, "a"), (2, "a")]
    assert list(repeat("a", 3)) == ["a", "a", "a"]
    assert take(3, repeat("a")) == ["a", "a", "a"]
    assert list(repeat("a", 0)) == []
    assert list(repeat("a", -3)) == []


test_repeat_from_cpython()


@test
def test_map_from_cpython():
    power = lambda a, b: a ** b
    assert list(map(power, range(3), range(1, 7))) == [0 ** 1, 1 ** 2, 2 ** 3]
    assert list(map(tupleize, "abc", range(5))) == [("a", 0), ("b", 1), ("c", 2)]
    assert list(map(tupleize, "abc", count())) == [("a", 0), ("b", 1), ("c", 2)]
    assert take(2, map(tupleize, "abc", count())) == [("a", 0), ("b", 1)]
    assert list(map(tupleize, List[int]())) == []


test_map_from_cpython()


@test
def test_starmap_from_cpython():
    power = lambda a, b: a ** b
    assert list(starmap(power, zip(range(3), range(1, 7)))) == [0 ** 1, 1 ** 2, 2 ** 3]
    assert take(3, starmap(power, zip(count(), count(1)))) == [0 ** 1, 1 ** 2, 2 ** 3]
    # assert list(starmap(tupleize, List[int]())) == []  # TODO
    assert list(starmap(power, [(4, 5)])) == [4 ** 5]


test_starmap_from_cpython()


@test
def test_islice_from_cpython():
    for args in (  # islice(args) should agree with range(args)
        (10, 20, 3),
        (10, 3, 20),
        (10, 20),
        (10, 10),
        (10, 3),
        (20,),
    ):
        assert list(islice(range(100), *args)) == list(range(*args))

    for args, tgtargs in (  # Stop when seqn is exhausted
        ((10, 110, 3), ((10, 100, 3))),
        ((10, 110), ((10, 100))),
        ((110,), (100,)),
    ):
        assert list(islice(range(100), *args)) == list(range(*tgtargs))

    # Test stop=None
    assert list(islice(range(10), None)) == list(range(10))
    assert list(islice(range(10), None, None)) == list(range(10))
    assert list(islice(range(10), None, None, None)) == list(range(10))
    assert list(islice(range(10), 2, None)) == list(range(2, 10))
    assert list(islice(range(10), 1, None, 2)) == list(range(1, 10, 2))


test_islice_from_cpython()


@test
def test_takewhile_from_cpython():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(takewhile(underten, data)) == [1, 3, 5]
    assert list(takewhile(underten, List[int]())) == []
    t = takewhile(lambda x: bool(x), [1, 1, 1, 0, 0, 0])
    assert list(t) == [1, 1, 1]


test_takewhile_from_cpython()


@test
def test_dropwhile_from_cpython():
    data = [1, 3, 5, 20, 2, 4, 6, 8]
    assert list(dropwhile(underten, data)) == [20, 2, 4, 6, 8]
    assert list(dropwhile(underten, List[int]())) == []


test_dropwhile_from_cpython()


@test
def test_tee_from_cpython():
    import random

    n = 200

    a, b = tee(List[int]())  # test empty iterator
    assert list(a) == []
    assert list(b) == []

    a, b = tee(irange(n))  # test 100% interleaved
    assert lzip(a, b) == lzip(range(n), range(n))

    a, b = tee(irange(n))  # test 0% interleaved
    assert list(a) == list(range(n))
    assert list(b) == list(range(n))

    a, b = tee(irange(n))  # test dealloc of leading iterator
    for i in range(100):
        assert next(a) == i
    assert list(b) == list(range(n))

    a, b = tee(irange(n))  # test dealloc of trailing iterator
    for i in range(100):
        assert next(a) == i
    assert list(a) == list(range(100, n))

    for j in range(5):  # test randomly interleaved
        order = [0] * n + [1] * n
        random.shuffle(order)
        lists = ([], [])
        its = tee(irange(n))
        for i in order:
            value = next(its[i])
            lists[i].append(value)
        assert lists[0] == list(range(n))
        assert lists[1] == list(range(n))

    # test long-lagged and multi-way split
    a, b, c = tee(range(2000), 3)
    for i in range(100):
        assert next(a) == i
    assert list(b) == list(range(2000))
    assert [next(c), next(c)] == list(range(2))
    assert list(a) == list(range(100, 2000))
    assert list(c) == list(range(2, 2000))


test_tee_from_cpython()
</t>
<t tx="ekr.20230509083244.151">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import math

NAN = math.nan
INF = math.inf
NINF = -math.inf


def close(a: float, b: float, epsilon: float = 1e-7):
    return abs(a - b) &lt;= epsilon


@test
def test_isnan():
    assert math.isnan(float("nan")) == True
    assert math.isnan(4.0) == False


@test
def test_isinf():
    assert math.isinf(float("inf")) == True
    assert math.isinf(7.0) == False


@test
def test_isfinite():
    assert math.isfinite(1.4) == True
    assert math.isfinite(0.0) == True
    assert math.isfinite(NAN) == False
    assert math.isfinite(INF) == False
    assert math.isfinite(NINF) == False


@test
def test_ceil():
    assert math.ceil(3.3) == 4
    assert math.ceil(0.5) == 1
    assert math.ceil(1.0) == 1
    assert math.ceil(1.5) == 2
    assert math.ceil(-0.5) == 0
    assert math.ceil(-1.0) == -1
    assert math.ceil(-1.5) == -1


@test
def test_floor():
    assert math.floor(3.3) == 3
    assert math.floor(0.5) == 0
    assert math.floor(1.0) == 1
    assert math.floor(1.5) == 1
    assert math.floor(-0.5) == -1
    assert math.floor(-1.0) == -1
    assert math.floor(-1.5) == -2


@test
def test_fabs():
    assert math.fabs(-1.0) == 1
    assert math.fabs(0.0) == 0
    assert math.fabs(1.0) == 1


@test
def test_fmod():
    assert math.fmod(10.0, 1.0) == 0.0
    assert math.fmod(10.0, 0.5) == 0.0
    assert math.fmod(10.0, 1.5) == 1.0
    assert math.fmod(-10.0, 1.0) == -0.0
    assert math.fmod(-10.0, 0.5) == -0.0
    assert math.fmod(-10.0, 1.5) == -1.0


@test
def test_exp():
    assert math.exp(0.0) == 1
    assert math.exp(-1.0) == 1 / math.e
    assert math.exp(1.0) == math.e


@test
def test_expm1():
    assert math.expm1(0.0) == 0
    assert close(math.expm1(1.0), 1.7182818284590453)
    assert close(math.expm1(3.0), 19.085536923187668)
    assert close(math.expm1(5.0), 147.4131591025766)
    assert math.expm1(INF) == INF
    assert math.expm1(NINF) == -1
    assert math.isnan(math.expm1(NAN)) == True


@test
def test_ldexp():
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, 1) == 2.0
    assert math.ldexp(1.0, -1) == 0.5
    assert math.ldexp(-1.0, 1) == -2.0
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, -1000000) == 0.0
    assert math.ldexp(-1.0, -1000000) == -0.0
    assert math.ldexp(INF, 30) == INF
    assert math.ldexp(NINF, -213) == NINF
    assert math.isnan(math.ldexp(NAN, 0)) == True


@test
def test_log():
    assert math.log(1.0 / math.e) == -1
    assert math.log(1.0) == 0
    assert math.log(math.e) == 1


@test
def test_log2():
    assert math.log2(1.0) == 0.0
    assert math.log2(2.0) == 1.0
    assert math.log2(4.0) == 2.0
    assert math.log2(2.0 ** 1023) == 1023.0
    assert math.isnan(math.log2(-1.5)) == True
    assert math.isnan(math.log2(NINF)) == True
    assert math.isnan(math.log2(NAN)) == True


@test
def test_log10():
    assert math.log10(0.1) == -1
    assert math.log10(1.0) == 0
    assert math.log10(10.0) == 1
    assert math.log10(10000.0) == 4


@test
def test_degrees():
    assert math.degrees(math.pi) == 180.0
    assert math.degrees(math.pi / 2) == 90.0
    assert math.degrees(-math.pi / 4) == -45.0
    assert math.degrees(0.0) == 0.0


@test
def test_radians():
    assert math.radians(180.0) == math.pi
    assert math.radians(90.0) == math.pi / 2
    assert math.radians(-45.0) == -math.pi / 4
    assert math.radians(0.0) == 0.0


@test
def test_sqrt():
    assert math.sqrt(4.0) == 2
    assert math.sqrt(0.0) == 0
    assert math.sqrt(1.0) == 1
    assert math.isnan(math.sqrt(-1.0)) == True


@test
def test_pow():
    assert math.pow(0.0, 1.0) == 0
    assert math.pow(1.0, 0.0) == 1
    assert math.pow(2.0, 1.0) == 2
    assert math.pow(2.0, -1.0) == 0.5
    assert math.pow(-0.0, 3.0) == -0.0
    assert math.pow(-0.0, 2.3) == 0.0
    assert math.pow(-0.0, 0.0) == 1
    assert math.pow(-0.0, -0.0) == 1
    assert math.pow(-2.0, 2.0) == 4.0
    assert math.pow(-2.0, 3.0) == -8.0
    assert math.pow(-2.0, -3.0) == -0.125
    assert math.pow(INF, 1.0) == INF
    assert math.pow(NINF, 1.0) == NINF
    assert math.pow(1.0, INF) == 1
    assert math.pow(1.0, NINF) == 1
    assert math.isnan(math.pow(NAN, 1.0)) == True
    assert math.isnan(math.pow(2.0, NAN)) == True
    assert math.isnan(math.pow(0.0, NAN)) == True
    assert math.pow(1.0, NAN) == 1


@test
def test_acos():
    assert math.acos(-1.0) == math.pi
    assert math.acos(0.0) == math.pi / 2
    assert math.acos(1.0) == 0
    assert math.isnan(math.acos(NAN)) == True


@test
def test_asin():
    assert math.asin(-1.0) == -math.pi / 2
    assert math.asin(0.0) == 0
    assert math.asin(1.0) == math.pi / 2
    assert math.isnan(math.asin(NAN)) == True


@test
def test_atan():
    assert math.atan(-1.0) == -math.pi / 4
    assert math.atan(0.0) == 0
    assert math.atan(1.0) == math.pi / 4
    assert math.atan(INF) == math.pi / 2
    assert math.atan(NINF) == -math.pi / 2
    assert math.isnan(math.atan(NAN)) == True


@test
def test_atan2():
    assert math.atan2(-1.0, 0.0) == -math.pi / 2
    assert math.atan2(-1.0, 1.0) == -math.pi / 4
    assert math.atan2(0.0, 1.0) == 0
    assert math.atan2(1.0, 1.0) == math.pi / 4
    assert math.atan2(1.0, 0.0) == math.pi / 2
    assert math.atan2(-0.0, 0.0) == -0
    assert math.atan2(-0.0, 2.3) == -0
    assert math.atan2(0.0, -2.3) == math.pi
    assert math.atan2(INF, NINF) == math.pi * 3 / 4
    assert math.atan2(INF, 2.3) == math.pi / 2
    assert math.isnan(math.atan2(NAN, 0.0)) == True


@test
def test_cos():
    assert math.cos(0.0) == 1
    assert close(math.cos(math.pi / 2), 6.123233995736766e-17)
    assert close(math.cos(-math.pi / 2), 6.123233995736766e-17)
    assert math.cos(math.pi) == -1
    assert math.isnan(math.cos(INF)) == True
    assert math.isnan(math.cos(NINF)) == True
    assert math.isnan(math.cos(NAN)) == True


@test
def test_sin():
    assert math.sin(0.0) == 0
    assert math.sin(math.pi / 2) == 1
    assert math.sin(-math.pi / 2) == -1
    assert math.isnan(math.sin(INF)) == True
    assert math.isnan(math.sin(NINF)) == True
    assert math.isnan(math.sin(NAN)) == True


@test
def test_hypot():
    assert math.hypot(12.0, 5.0) == 13
    assert math.hypot(12.0 / 32.0, 5.0 / 32) == 13 / 32
    assert math.hypot(0.0, 0.0) == 0
    assert math.hypot(-3.0, 4.0) == 5
    assert math.hypot(3.0, 4.0) == 5


@test
def test_tan():
    assert math.tan(0.0) == 0
    assert close(math.tan(math.pi / 4), 0.9999999999999999)
    assert close(math.tan(-math.pi / 4), -0.9999999999999999)
    assert math.isnan(math.tan(INF)) == True
    assert math.isnan(math.tan(NINF)) == True
    assert math.isnan(math.tan(NAN)) == True


@test
def test_cosh():
    assert math.cosh(0.0) == 1
    assert math.cosh(2.0) - 2 * math.cosh(1.0) ** 2 == -1
    assert math.cosh(INF) == INF
    assert math.cosh(NINF) == INF
    assert math.isnan(math.cosh(NAN)) == True


@test
def test_sinh():
    assert math.sinh(0.0) == 0
    assert math.sinh(1.0) + math.sinh(-1.0) == 0
    assert math.sinh(INF) == INF
    assert math.sinh(NINF) == NINF
    assert math.isnan(math.sinh(NAN)) == True


@test
def test_tanh():
    assert math.tanh(0.0) == 0
    assert math.tanh(1.0) + math.tanh(-1.0) == 0
    assert math.tanh(INF) == 1
    assert math.tanh(NINF) == -1
    assert math.isnan(math.tanh(NAN)) == True


@test
def test_acosh():
    assert math.acosh(1.0) == 0
    assert close(math.acosh(2.0), 1.3169578969248166)
    assert math.acosh(INF) == INF
    assert math.isnan(math.acosh(NAN)) == True
    assert math.isnan(math.acosh(-1.0)) == True


@test
def test_asinh():
    assert math.asinh(0.0) == 0
    assert close(math.asinh(1.0), 0.881373587019543)
    assert close(math.asinh(-1.0), -0.881373587019543)
    assert math.asinh(INF) == INF
    assert math.isnan(math.asinh(NAN)) == True
    assert math.asinh(NINF) == NINF


@test
def test_atanh():
    assert math.atanh(0.0) == 0
    assert close(math.atanh(0.5), 0.5493061443340549)
    assert close(math.atanh(-0.5), -0.5493061443340549)
    assert math.isnan(math.atanh(INF)) == True
    assert math.isnan(math.atanh(NAN)) == True
    assert math.isnan(math.atanh(NINF)) == True


@test
def test_copysign():
    assert math.copysign(1.0, -0.0) == -1
    assert math.copysign(1.0, 42.0) == 1
    assert math.copysign(1.0, -42.0) == -1
    assert math.copysign(3.0, 0.0) == 3
    assert math.copysign(INF, 0.0) == INF
    assert math.copysign(INF, -0.0) == NINF
    assert math.copysign(NINF, 0.0) == INF
    assert math.copysign(NINF, -0.0) == NINF
    assert math.copysign(1.0, INF) == 1
    assert math.copysign(1.0, NINF) == -1
    assert math.copysign(INF, INF) == INF
    assert math.copysign(INF, NINF) == NINF
    assert math.copysign(NINF, INF) == INF
    assert math.copysign(NINF, NINF) == NINF
    assert math.isnan(math.copysign(NAN, 1.0)) == True
    assert math.isnan(math.copysign(NAN, INF)) == True
    assert math.isnan(math.copysign(NAN, NINF)) == True
    assert math.isnan(math.copysign(NAN, NAN)) == True


@test
def test_log1p():
    assert close(math.log1p(2.0), 1.0986122886681098)
    assert close(math.log1p(2.0 ** 90), 62.383246250395075)
    assert close(math.log1p(2.0 ** 300), 207.94415416798358)
    assert math.log1p(INF) == INF
    assert math.log1p(-1.0) == NINF


@test
def test_trunc():
    assert math.trunc(1.0) == 1
    assert math.trunc(-1.0) == -1
    assert math.trunc(1.5) == 1
    assert math.trunc(-1.5) == -1
    assert math.trunc(1.99999999) == 1
    assert math.trunc(-1.99999999) == -1
    assert math.trunc(0.99999999) == 0
    assert math.trunc(-100.999) == -100


@test
def test_erf():
    assert close(math.erf(1.0), 0.8427007929497148)
    assert math.erf(0.0) == 0
    assert close(math.erf(3.0), 0.9999779095030015)
    assert math.erf(256.0) == 1.0
    assert math.erf(INF) == 1.0
    assert math.erf(NINF) == -1.0
    assert math.isnan(math.erf(NAN)) == True


@test
def test_erfc():
    assert math.erfc(0.0) == 1.0
    assert close(math.erfc(1.0), 0.15729920705028516)
    assert close(math.erfc(2.0), 0.0046777349810472645)
    assert close(math.erfc(-1.0), 1.8427007929497148)
    assert math.erfc(INF) == 0.0
    assert math.erfc(NINF) == 2.0
    assert math.isnan(math.erfc(NAN)) == True


@test
def test_gamma():
    assert close(math.gamma(6.0), 120.0)
    assert close(math.gamma(1.0), 1.0)
    assert close(math.gamma(2.0), 1.0)
    assert close(math.gamma(3.0), 2.0)
    assert math.isnan(math.gamma(-1.0)) == True
    assert math.gamma(INF) == INF
    assert math.isnan(math.gamma(NINF)) == True
    assert math.isnan(math.gamma(NAN)) == True


@test
def test_lgamma():
    assert math.lgamma(1.0) == 0.0
    assert math.lgamma(2.0) == 0.0
    assert math.lgamma(-1.0) == INF
    assert math.lgamma(INF) == INF
    assert math.lgamma(NINF) == INF
    assert math.isnan(math.lgamma(NAN)) == True


@test
def test_remainder():
    assert math.remainder(2.0, 2.0) == 0.0
    assert math.remainder(-4.0, 1.0) == -0.0
    assert close(math.remainder(-3.8, 1.0), 0.20000000000000018)
    assert close(math.remainder(3.8, 1.0), -0.20000000000000018)
    assert math.isnan(math.remainder(INF, 1.0)) == True
    assert math.isnan(math.remainder(NINF, 1.0)) == True
    assert math.isnan(math.remainder(NAN, 1.0)) == True


@test
def test_gcd():
    assert math.gcd(0.0, 0.0) == 0
    assert math.gcd(1.0, 0.0) == 1
    assert math.gcd(-1.0, 0.0) == 1
    assert math.gcd(0.0, -1.0) == 1
    assert math.gcd(0.0, 1.0) == 1
    assert math.gcd(7.0, 1.0) == 1
    assert math.gcd(7.0, -1.0) == 1
    assert math.gcd(-23.0, 15.0) == 1
    assert math.gcd(120.0, 84.0) == 12
    assert math.gcd(84.0, -120.0) == 12


@test
def test_frexp():
    assert math.frexp(-2.0) == (-0.5, 2)
    assert math.frexp(-1.0) == (-0.5, 1)
    assert math.frexp(0.0) == (0.0, 0)
    assert math.frexp(1.0) == (0.5, 1)
    assert math.frexp(2.0) == (0.5, 2)
    assert math.frexp(INF)[0] == INF
    assert math.frexp(NINF)[0] == NINF
    assert math.isnan(math.frexp(NAN)[0]) == True


@test
def test_modf():
    assert math.modf(1.5) == (0.5, 1.0)
    assert math.modf(-1.5) == (-0.5, -1.0)
    assert math.modf(math.inf) == (0.0, INF)
    assert math.modf(-math.inf) == (-0.0, NINF)
    modf_nan = math.modf(NAN)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


@test
def test_isclose():
    assert math.isclose(1.0 + 1.0, 1.000000000001 + 1.0) == True
    assert math.isclose(2.90909324093284, 2.909093240932844234234234234) == True
    assert math.isclose(2.90909324093284, 2.9) == False
    assert math.isclose(2.90909324093284, 2.90909324) == True
    assert math.isclose(2.90909324, 2.90909325) == False
    assert math.isclose(NAN, 2.9) == False
    assert math.isclose(2.9, NAN) == False
    assert math.isclose(INF, INF) == True
    assert math.isclose(NINF, NINF) == True
    assert math.isclose(NINF, INF) == False
    assert math.isclose(INF, NINF) == False


@test
def test_fsum():
    assert math.fsum((42,)) == 42.0
    assert math.fsum((1,2,3)) == 6.0
    assert math.fsum((1,2,-3)) == 0.0
    assert math.fsum(()) == 0.0
    assert math.fsum([.1] * 10) == 1.0

    mant_dig = 53
    etiny = -1074

    def sum_exact(p):
        n = len(p)
        hi = 0.0
        if n &gt; 0:
            hi = p[n-1]
            n -= 1
            while n &gt; 0:
                x = hi
                y = p[n-1]
                n -= 1
                hi = x + y
                yr = hi - x
                lo = y - yr
                if lo != 0.0:
                    break

            if n &gt; 0 and ((lo &lt; 0 and p[n-1] &lt; 0) or (lo &gt; 0 and p[n-1] &gt; 0)):
                y = lo * 2
                x = hi + y
                yr = x - hi
                if y == yr:
                    hi = x
        return hi

    def msum(iterable):
        "Full precision summation using multiple floats for intermediate values"
        # Rounded x+y stored in hi with the round-off stored in lo.  Together
        # hi+lo are exactly equal to x+y.  The inner loop applies hi/lo summation
        # to each partial so that the list of partial sums remains exact.
        # Depends on IEEE-754 arithmetic guarantees.  See proof of correctness at:
        # www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps

        partials = []               # sorted, non-overlapping partial sums
        for x in iterable:
            i = 0
            for y in partials:
                if abs(x) &lt; abs(y):
                    x, y = y, x
                hi = x + y
                lo = y - (hi - x)
                if lo:
                    partials[i] = lo
                    i += 1
                x = hi
            partials[i:] = [x]
        return sum_exact(partials)

    @pure
    @llvm
    def float1() -&gt; float:
        ret double 0x401DF11F45F4E61A

    @pure
    @llvm
    def float2() -&gt; float:
        ret double 0xBFE62A2AF1BD3624

    @pure
    @llvm
    def float3() -&gt; float:
        ret double 0x7C95555555555555

    test_values = [
        ([], 0.0),
        ([0.0], 0.0),
        ([1e100, 1.0, -1e100, 1e-100, 1e50, -1.0, -1e50], 1e-100),
        ([2.0**53, -0.5, -2.0**-54], 2.0**53-1.0),
        ([2.0**53, 1.0, 2.0**-100], 2.0**53+2.0),
        ([2.0**53+10.0, 1.0, 2.0**-100], 2.0**53+12.0),
        ([2.0**53-4.0, 0.5, 2.0**-54], 2.0**53-3.0),
        ([1./n for n in range(1, 1001)], float1()),
        ([(-1.)**n/n for n in range(1, 1001)], float2()),
        ([1e16, 1., 1e-16], 10000000000000002.0),
        ([1e16-2., 1.-2.**-53, -(1e16-2.), -(1.-2.**-53)], 0.0),
        # exercise code for resizing partials array
        ([2.**n - 2.**(n+50) + 2.**(n+52) for n in range(-1074, 972, 2)] +
         [-2.**1022],
         float3()),
        ]

    # Telescoping sum, with exact differences (due to Sterbenz)
    terms = [1.7**i for i in range(1001)]
    test_values.append((
        [terms[i+1] - terms[i] for i in range(1000)] + [-terms[1000]],
        -terms[0]
    ))

    for i, (vals, expected) in enumerate(test_values):
        try:
            actual = math.fsum(vals)
        except OverflowError:
            # self.fail("test %d failed: got OverflowError, expected %r "
            #           "for math.fsum(%.100r)" % (i, expected, vals))
            assert False
        except ValueError:
            # self.fail("test %d failed: got ValueError, expected %r "
            #           "for math.fsum(%.100r)" % (i, expected, vals))
            assert False

        assert actual == expected

    from random import random, gauss, shuffle
    for j in range(10000):
        vals = [7, 1e100, -7, -1e100, -9e-20, 8e-20] * 10
        s = 0.
        for i in range(200):
            v = gauss(0, random()) ** 7 - s
            s += v
            vals.append(v)
        shuffle(vals)
        assert msum(vals) == math.fsum(vals)


test_isnan()
test_isinf()
test_isfinite()
test_ceil()
test_floor()
test_fabs()
test_fmod()
test_exp()
test_expm1()
test_ldexp()
test_log()
test_log2()
test_log10()
test_degrees()
test_radians()
test_sqrt()
test_pow()
test_acos()
test_asin()
test_atan()
test_atan2()
test_cos()
test_sin()
test_hypot()
test_tan()
test_cosh()
test_sinh()
test_tanh()
test_acosh()
test_asinh()
test_atanh()
test_copysign()
test_log1p()
test_trunc()
test_erf()
test_erfc()
test_gamma()
test_lgamma()
test_remainder()
test_gcd()
test_frexp()
test_modf()
test_isclose()
test_fsum()


# 32-bit float ops

NAN32 = math.nan32
INF32 = math.inf32
NINF32 = -math.inf32


def close32(a: float32, b: float32, epsilon: float32 = 1e-5f32):
    return abs(a - b) &lt;= epsilon


@test
def test_float32_isnan():
    assert math.isnan(float32(float("nan"))) == True
    assert math.isnan(4.0f32) == False


@test
def test_float32_isinf():
    assert math.isinf(float32(float("inf"))) == True
    assert math.isinf(7.0f32) == False


@test
def test_float32_isfinite():
    assert math.isfinite(1.4f32) == True
    assert math.isfinite(0.0f32) == True
    assert math.isfinite(NAN32) == False
    assert math.isfinite(INF32) == False
    assert math.isfinite(NINF32) == False


@test
def test_float32_ceil():
    assert math.ceil(3.3f32) == 4.0f32
    assert math.ceil(0.5f32) == 1.0f32
    assert math.ceil(1.0f32) == 1.0f32
    assert math.ceil(1.5f32) == 2.0f32
    assert math.ceil(-0.5f32) == 0.0f32
    assert math.ceil(-1.0f32) == -1.0f32
    assert math.ceil(-1.5f32) == -1.0f32


@test
def test_float32_floor():
    assert math.floor(3.3f32) == 3.0f32
    assert math.floor(0.5f32) == 0.0f32
    assert math.floor(1.0f32) == 1.0f32
    assert math.floor(1.5f32) == 1.0f32
    assert math.floor(-0.5f32) == -1.0f32
    assert math.floor(-1.0f32) == -1.0f32
    assert math.floor(-1.5f32) == -2.0f32


@test
def test_float32_fabs():
    assert math.fabs(-1.0f32) == 1.0f32
    assert math.fabs(0.0f32) == 0.0f32
    assert math.fabs(1.0f32) == 1.0f32


@test
def test_float32_fmod():
    assert math.fmod(10.0f32, 1.0f32) == 0.0f32
    assert math.fmod(10.0f32, 0.5f32) == 0.0f32
    assert math.fmod(10.0f32, 1.5f32) == 1.0f32
    assert math.fmod(-10.0f32, 1.0f32) == -0.0f32
    assert math.fmod(-10.0f32, 0.5f32) == -0.0f32
    assert math.fmod(-10.0f32, 1.5f32) == -1.0f32


@test
def test_float32_exp():
    assert math.exp(0.0f32) == 1.0f32
    assert math.exp(-1.0f32) == 1.0f32 / math.e32
    assert math.exp(1.0f32) == math.e32


@test
def test_float32_expm1():
    assert math.expm1(0.0f32) == 0.0f32
    assert close32(math.expm1(1.0f32), 1.7182818284590453f32)
    assert close32(math.expm1(3.0f32), 19.085536923187668f32)
    assert close32(math.expm1(5.0f32), 147.4131591025766f32)
    assert math.expm1(INF32) == INF32
    assert math.expm1(NINF32) == -1.0f32
    assert math.isnan(math.expm1(NAN32)) == True


@test
def test_float32_ldexp():
    assert math.ldexp(0.0f32, 1) == 0.0f32
    assert math.ldexp(1.0f32, 1) == 2.0f32
    assert math.ldexp(1.0f32, -1) == 0.5f32
    assert math.ldexp(-1.0f32, 1) == -2.0f32
    assert math.ldexp(0.0f32, 1) == 0.0f32
    assert math.ldexp(1.0f32, -1000000) == 0.0f32
    assert math.ldexp(-1.0f32, -1000000) == -0.0f32
    assert math.ldexp(INF32, 30) == INF32
    assert math.ldexp(NINF32, -213) == NINF32
    assert math.isnan(math.ldexp(NAN32, 0)) == True


@test
def test_float32_log():
    assert math.log(1.0f32 / math.e32) == -1.0f32
    assert math.log(1.0f32) == 0.0f32
    assert close32(math.log(math.e32), 1.0f32)


@test
def test_float32_log2():
    assert math.log2(1.0f32) == 0.0f32
    assert math.log2(2.0f32) == 1.0f32
    assert math.log2(4.0f32) == 2.0f32
    assert math.log2(2.0f32 ** 50.0f32) == 50.0f32
    assert math.isnan(math.log2(-1.5f32)) == True
    assert math.isnan(math.log2(NINF32)) == True
    assert math.isnan(math.log2(NAN32)) == True


@test
def test_float32_log10():
    assert math.log10(0.1f32) == -1.0f32
    assert math.log10(1.0f32) == 0.0f32
    assert math.log10(10.0f32) == 1.0f32
    assert math.log10(10000.0f32) == 4.0f32


@test
def test_float32_degrees():
    assert math.degrees(math.pi32) == 180.0f32
    assert math.degrees(math.pi32 / 2.0f32) == 90.0f32
    assert math.degrees(-math.pi32 / 4.0f32) == -45.0f32
    assert math.degrees(0.0f32) == 0.0f32


@test
def test_float32_radians():
    assert math.radians(180.0f32) == math.pi32
    assert math.radians(90.0f32) == math.pi32 / 2.0f32
    assert math.radians(-45.0f32) == -math.pi32 / 4.0f32
    assert math.radians(0.0f32) == 0.0f32


@test
def test_float32_sqrt():
    assert math.sqrt(4.0f32) == 2.0f32
    assert math.sqrt(0.0f32) == 0.0f32
    assert math.sqrt(1.0f32) == 1.0f32
    assert math.isnan(math.sqrt(-1.0f32)) == True


@test
def test_float32_pow():
    assert math.pow(0.0f32, 1.0f32) == 0.0f32
    assert math.pow(1.0f32, 0.0f32) == 1.0f32
    assert math.pow(2.0f32, 1.0f32) == 2.0f32
    assert math.pow(2.0f32, -1.0f32) == 0.5f32
    assert math.pow(-0.0f32, 3.0f32) == -0.0f32
    assert math.pow(-0.0f32, 2.3f32) == 0.0f32
    assert math.pow(-0.0f32, 0.0f32) == 1.0f32
    assert math.pow(-0.0f32, -0.0f32) == 1.0f32
    assert math.pow(-2.0f32, 2.0f32) == 4.0f32
    assert math.pow(-2.0f32, 3.0f32) == -8.0f32
    assert math.pow(-2.0f32, -3.0f32) == -0.125f32
    assert math.pow(INF32, 1.0f32) == INF32
    assert math.pow(NINF32, 1.0f32) == NINF32
    assert math.pow(1.0f32, INF32) == 1.0f32
    assert math.pow(1.0f32, NINF32) == 1.0f32
    assert math.isnan(math.pow(NAN32, 1.0f32)) == True
    assert math.isnan(math.pow(2.0f32, NAN32)) == True
    assert math.isnan(math.pow(0.0f32, NAN32)) == True
    assert math.pow(1.0f32, NAN32) == 1.0f32


@test
def test_float32_acos():
    assert close32(math.acos(-1.0f32), math.pi32)
    assert close32(math.acos(0.0f32), math.pi32 / 2.0f32)
    assert math.acos(1.0f32) == 0.0f32
    assert math.isnan(math.acos(NAN32)) == True


@test
def test_float32_asin():
    assert close32(math.asin(-1.0f32), -math.pi32 / 2.0f32)
    assert math.asin(0.0f32) == 0.0f32
    assert close32(math.asin(1.0f32), math.pi32 / 2.0f32)
    assert math.isnan(math.asin(NAN32)) == True


@test
def test_float32_atan():
    assert math.atan(-1.0f32) == -math.pi32 / 4.0f32
    assert math.atan(0.0f32) == 0.0f32
    assert close32(math.atan(1.0f32), math.pi32 / 4.0f32)
    assert close32(math.atan(INF32), math.pi32 / 2.0f32)
    assert close32(math.atan(NINF32), -math.pi32 / 2.0f32)
    assert math.isnan(math.atan(NAN32)) == True


@test
def test_float32_atan2():
    assert math.atan2(-1.0f32, 0.0f32) == -math.pi32 / 2.0f32
    assert math.atan2(-1.0f32, 1.0f32) == -math.pi32 / 4.0f32
    assert math.atan2(0.0f32, 1.0f32) == 0.0f32
    assert math.atan2(1.0f32, 1.0f32) == math.pi32 / 4.0f32
    assert math.atan2(1.0f32, 0.0f32) == math.pi32 / 2.0f32
    assert math.atan2(-0.0f32, 0.0f32) == -0.0f32
    assert math.atan2(-0.0f32, 2.3f32) == -0.0f32
    assert close32(math.atan2(0.0f32, -2.3f32), math.pi32)
    assert math.atan2(INF32, NINF32) == math.pi32 * 3.0f32 / 4.0f32
    assert math.atan2(INF32, 2.3f32) == math.pi32 / 2.0f32
    assert math.isnan(math.atan2(NAN32, 0.0f32)) == True


@test
def test_float32_cos():
    assert math.cos(0.0f32) == 1.0f32
    assert close32(math.cos(math.pi32 / 2.0f32), 6.123233995736766e-17f32)
    assert close32(math.cos(-math.pi32 / 2.0f32), 6.123233995736766e-17f32)
    assert math.cos(math.pi32) == -1.0f32
    assert math.isnan(math.cos(INF32)) == True
    assert math.isnan(math.cos(NINF32)) == True
    assert math.isnan(math.cos(NAN32)) == True


@test
def test_float32_sin():
    assert math.sin(0.0f32) == 0.0f32
    assert math.sin(math.pi32 / 2.0f32) == 1.0f32
    assert math.sin(-math.pi32 / 2.0f32) == -1.0f32
    assert math.isnan(math.sin(INF32)) == True
    assert math.isnan(math.sin(NINF32)) == True
    assert math.isnan(math.sin(NAN32)) == True


@test
def test_float32_hypot():
    assert math.hypot(12.0f32, 5.0f32) == 13.0f32
    assert math.hypot(12.0f32 / 32.0f32, 5.0f32 / 32.0f32) == 13.0f32 / 32.0f32
    assert math.hypot(0.0f32, 0.0f32) == 0.0f32
    assert math.hypot(-3.0f32, 4.0f32) == 5.0f32
    assert math.hypot(3.0f32, 4.0f32) == 5.0f32


@test
def test_float32_tan():
    assert math.tan(0.0f32) == 0.0f32
    assert close32(math.tan(math.pi32 / 4.0f32), 0.9999999999999999f32)
    assert close32(math.tan(-math.pi32 / 4.0f32), -0.9999999999999999f32)
    assert math.isnan(math.tan(INF32)) == True
    assert math.isnan(math.tan(NINF32)) == True
    assert math.isnan(math.tan(NAN32)) == True


@test
def test_float32_cosh():
    assert math.cosh(0.0f32) == 1.0f32
    assert close32(math.cosh(2.0f32) - 2.0f32 * math.cosh(1.0f32) ** 2.0f32, -1.0f32)
    assert math.cosh(INF32) == INF32
    assert math.cosh(NINF32) == INF32
    assert math.isnan(math.cosh(NAN32)) == True


@test
def test_float32_sinh():
    assert math.sinh(0.0f32) == 0.0f32
    assert math.sinh(1.0f32) + math.sinh(-1.0f32) == 0.0f32
    assert math.sinh(INF32) == INF32
    assert math.sinh(NINF32) == NINF32
    assert math.isnan(math.sinh(NAN32)) == True


@test
def test_float32_tanh():
    assert math.tanh(0.0f32) == 0.0f32
    assert math.tanh(1.0f32) + math.tanh(-1.0f32) == 0.0f32
    assert math.tanh(INF32) == 1.0f32
    assert math.tanh(NINF32) == -1.0f32
    assert math.isnan(math.tanh(NAN32)) == True


@test
def test_float32_acosh():
    assert math.acosh(1.0f32) == 0.0f32
    assert close32(math.acosh(2.0f32), 1.3169578969248166f32)
    assert math.acosh(INF32) == INF32
    assert math.isnan(math.acosh(NAN32)) == True
    assert math.isnan(math.acosh(-1.0f32)) == True


@test
def test_float32_asinh():
    assert math.asinh(0.0f32) == 0.0f32
    assert close32(math.asinh(1.0f32), 0.881373587019543f32)
    assert close32(math.asinh(-1.0f32), -0.881373587019543f32)
    assert math.asinh(INF32) == INF32
    assert math.isnan(math.asinh(NAN32)) == True
    assert math.asinh(NINF32) == NINF32


@test
def test_float32_atanh():
    assert math.atanh(0.0f32) == 0.0f32
    assert close32(math.atanh(0.5f32), 0.5493061443340549f32)
    assert close32(math.atanh(-0.5f32), -0.5493061443340549f32)
    assert math.isnan(math.atanh(INF32)) == True
    assert math.isnan(math.atanh(NAN32)) == True
    assert math.isnan(math.atanh(NINF32)) == True


@test
def test_float32_copysign():
    assert math.copysign(1.0f32, -0.0f32) == -1.0f32
    assert math.copysign(1.0f32, 42.0f32) == 1.0f32
    assert math.copysign(1.0f32, -42.0f32) == -1.0f32
    assert math.copysign(3.0f32, 0.0f32) == 3.0f32
    assert math.copysign(INF32, 0.0f32) == INF32
    assert math.copysign(INF32, -0.0f32) == NINF32
    assert math.copysign(NINF32, 0.0f32) == INF32
    assert math.copysign(NINF32, -0.0f32) == NINF32
    assert math.copysign(1.0f32, INF32) == 1.0f32
    assert math.copysign(1.0f32, NINF32) == -1.0f32
    assert math.copysign(INF32, INF32) == INF32
    assert math.copysign(INF32, NINF32) == NINF32
    assert math.copysign(NINF32, INF32) == INF32
    assert math.copysign(NINF32, NINF32) == NINF32
    assert math.isnan(math.copysign(NAN32, 1.0f32)) == True
    assert math.isnan(math.copysign(NAN32, INF32)) == True
    assert math.isnan(math.copysign(NAN32, NINF32)) == True
    assert math.isnan(math.copysign(NAN32, NAN32)) == True


@test
def test_float32_log1p():
    assert close32(math.log1p(2.0f32), 1.0986122886681098f32)
    assert close32(math.log1p(2.0f32 ** 90.0f32), 62.383246250395075f32)
    assert math.log1p(INF32) == INF32
    assert math.log1p(-1.0f32) == NINF32


@test
def test_float32_trunc():
    assert math.trunc(1.0f32) == 1.0f32
    assert math.trunc(-1.0f32) == -1.0f32
    assert math.trunc(1.5f32) == 1.0f32
    assert math.trunc(-1.5f32) == -1.0f32
    assert math.trunc(1.99999f32) == 1.0f32
    assert math.trunc(-1.99999f32) == -1.0f32
    assert math.trunc(0.99999f32) == 0.0f32
    assert math.trunc(-100.999f32) == -100.0f32


@test
def test_float32_erf():
    assert close32(math.erf(1.0f32), 0.8427007929497148f32)
    assert math.erf(0.0f32) == 0.0f32
    assert close32(math.erf(3.0f32), 0.9999779095030015f32)
    assert math.erf(256.0f32) == 1.0f32
    assert math.erf(INF32) == 1.0f32
    assert math.erf(NINF32) == -1.0f32
    assert math.isnan(math.erf(NAN32)) == True


@test
def test_float32_erfc():
    assert math.erfc(0.0f32) == 1.0f32
    assert close32(math.erfc(1.0f32), 0.15729920705028516f32)
    assert close32(math.erfc(2.0f32), 0.0046777349810472645f32)
    assert close32(math.erfc(-1.0f32), 1.8427007929497148f32)
    assert math.erfc(INF32) == 0.0f32
    assert math.erfc(NINF32) == 2.0f32
    assert math.isnan(math.erfc(NAN32)) == True


@test
def test_float32_gamma():
    assert close32(math.gamma(6.0f32), 120.0f32)
    assert close32(math.gamma(1.0f32), 1.0f32)
    assert close32(math.gamma(2.0f32), 1.0f32)
    assert close32(math.gamma(3.0f32), 2.0f32)
    assert math.isnan(math.gamma(-1.0f32)) == True
    assert math.gamma(INF32) == INF32
    assert math.isnan(math.gamma(NINF32)) == True
    assert math.isnan(math.gamma(NAN32)) == True


@test
def test_float32_lgamma():
    assert math.lgamma(1.0f32) == 0.0f32
    assert math.lgamma(2.0f32) == 0.0f32
    assert math.lgamma(-1.0f32) == INF32
    assert math.lgamma(INF32) == INF32
    assert math.lgamma(NINF32) == INF32
    assert math.isnan(math.lgamma(NAN32)) == True


@test
def test_float32_remainder():
    assert math.remainder(2.0f32, 2.0f32) == 0.0f32
    assert math.remainder(-4.0f32, 1.0f32) == -0.0f32
    assert close32(math.remainder(-3.8f32, 1.0f32), 0.20000000000000018f32)
    assert close32(math.remainder(3.8f32, 1.0f32), -0.20000000000000018f32)
    assert math.isnan(math.remainder(INF32, 1.0f32)) == True
    assert math.isnan(math.remainder(NINF32, 1.0f32)) == True
    assert math.isnan(math.remainder(NAN32, 1.0f32)) == True


@test
def test_float32_gcd():
    assert math.gcd(0.0f32, 0.0f32) == 0.0f32
    assert math.gcd(1.0f32, 0.0f32) == 1.0f32
    assert math.gcd(-1.0f32, 0.0f32) == 1.0f32
    assert math.gcd(0.0f32, -1.0f32) == 1.0f32
    assert math.gcd(0.0f32, 1.0f32) == 1.0f32
    assert math.gcd(7.0f32, 1.0f32) == 1.0f32
    assert math.gcd(7.0f32, -1.0f32) == 1.0f32
    assert math.gcd(-23.0f32, 15.0f32) == 1.0f32
    assert math.gcd(120.0f32, 84.0f32) == 12.0f32
    assert math.gcd(84.0f32, -120.0f32) == 12.0f32


@test
def test_float32_frexp():
    assert math.frexp(-2.0f32) == (-0.5f32, 2)
    assert math.frexp(-1.0f32) == (-0.5f32, 1)
    assert math.frexp(0.0f32) == (0.0f32, 0)
    assert math.frexp(1.0f32) == (0.5f32, 1)
    assert math.frexp(2.0f32) == (0.5f32, 2)
    assert math.frexp(INF32)[0] == INF32
    assert math.frexp(NINF32)[0] == NINF32
    assert math.isnan(math.frexp(NAN32)[0]) == True


@test
def test_float32_modf():
    assert math.modf(1.5f32) == (0.5f32, 1.0f32)
    assert math.modf(-1.5f32) == (-0.5f32, -1.0f32)
    assert math.modf(math.inf32) == (0.0f32, INF32)
    assert math.modf(-math.inf32) == (-0.0f32, NINF32)
    modf_nan = math.modf(NAN32)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


@test
def test_float32_isclose():
    assert math.isclose(1.0f32 + 1.0f32, 1.000000000001f32 + 1.0f32) == True
    assert math.isclose(2.90909324093284f32, 2.909093240932844234234234234f32) == True
    assert math.isclose(2.90909324093284f32, 2.9f32) == False
    assert math.isclose(2.90909324093284f32, 2.90909324f32) == True
    assert math.isclose(2.909094f32, 2.909095f32) == False
    assert math.isclose(NAN32, 2.9f32) == False
    assert math.isclose(2.9f32, NAN32) == False
    assert math.isclose(INF32, INF32) == True
    assert math.isclose(NINF32, NINF32) == True
    assert math.isclose(NINF32, INF32) == False
    assert math.isclose(INF32, NINF32) == False


test_float32_isnan()
test_float32_isinf()
test_float32_isfinite()
test_float32_ceil()
test_float32_floor()
test_float32_fabs()
test_float32_fmod()
test_float32_exp()
test_float32_expm1()
test_float32_ldexp()
test_float32_log()
test_float32_log2()
test_float32_log10()
test_float32_degrees()
test_float32_radians()
test_float32_sqrt()
test_float32_pow()
test_float32_acos()
test_float32_asin()
test_float32_atan()
test_float32_atan2()
test_float32_cos()
test_float32_sin()
test_float32_hypot()
test_float32_tan()
test_float32_cosh()
test_float32_sinh()
test_float32_tanh()
test_float32_acosh()
test_float32_asinh()
test_float32_atanh()
test_float32_copysign()
test_float32_log1p()
test_float32_trunc()
test_float32_erf()
test_float32_erfc()
test_float32_gamma()
test_float32_lgamma()
test_float32_remainder()
test_float32_gcd()
test_float32_frexp()
test_float32_modf()
test_float32_isclose()
</t>
<t tx="ekr.20230509083244.152">@path C:/Repos/codon/test/stdlib/
@language unknown_language
from operator import *
import operator


def apply1(f, x, expected):
    return f(x) == expected


def apply2(f, lhs, rhs, expected):
    return f(lhs, rhs) == expected


n_eq = 0
n_ne = 0
n_lt = 0
n_le = 0
n_gt = 0
n_ge = 0

n_len = 0
n_bool = 0

n_abs = 0
n_pos = 0
n_neg = 0
n_inv = 0
n_index = 0

n_add = 0
n_sub = 0
n_mul = 0
n_matmul = 0
n_truediv = 0
n_floordiv = 0
n_mod = 0
n_pow = 0
n_and = 0
n_or = 0
n_xor = 0
n_lshift = 0
n_rshift = 0

n_iadd = 0
n_isub = 0
n_imul = 0
n_imatmul = 0
n_itruediv = 0
n_ifloordiv = 0
n_imod = 0
n_ipow = 0
n_iand = 0
n_ior = 0
n_ixor = 0
n_ilshift = 0
n_irshift = 0


class C:
    def __eq__(self, other: C):
        global n_eq
        n_eq += 1
        return False

    def __ne__(self, other: C):
        global n_ne
        n_ne += 1
        return False

    def __lt__(self, other: C):
        global n_lt
        n_lt += 1
        return False

    def __le__(self, other: C):
        global n_le
        n_le += 1
        return False

    def __gt__(self, other: C):
        global n_gt
        n_gt += 1
        return False

    def __ge__(self, other: C):
        global n_ge
        n_ge += 1
        return False

    def __len__(self):
        global n_len
        n_len += 1
        return 42

    def __bool__(self):
        global n_bool
        n_bool += 1
        return True

    def __abs__(self):
        global n_abs
        n_abs += 1
        return "abs"

    def __pos__(self):
        global n_pos
        n_pos += 1
        return "pos"

    def __neg__(self):
        global n_neg
        n_neg += 1
        return "neg"

    def __invert__(self):
        global n_inv
        n_inv += 1
        return "inv"

    def __index__(self):
        global n_index
        n_index += 1
        return "index"

    def __add__(self, other: C):
        global n_add
        n_add += 1
        return "add"

    def __sub__(self, other: C):
        global n_sub
        n_sub += 1
        return "sub"

    def __mul__(self, other: C):
        global n_mul
        n_mul += 1
        return "mul"

    def __matmul__(self, other: C):
        global n_matmul
        n_matmul += 1
        return "matmul"

    def __truediv__(self, other: C):
        global n_truediv
        n_truediv += 1
        return "truediv"

    def __floordiv__(self, other: C):
        global n_floordiv
        n_floordiv += 1
        return "floordiv"

    def __mod__(self, other: C):
        global n_mod
        n_mod += 1
        return "mod"

    def __pow__(self, other: C):
        global n_pow
        n_pow += 1
        return "pow"

    def __and__(self, other: C):
        global n_and
        n_and += 1
        return "and"

    def __or__(self, other: C):
        global n_or
        n_or += 1
        return "or"

    def __xor__(self, other: C):
        global n_xor
        n_xor += 1
        return "xor"

    def __lshift__(self, other: C):
        global n_lshift
        n_lshift += 1
        return "lshift"

    def __rshift__(self, other: C):
        global n_rshift
        n_rshift += 1
        return "rshift"

    def __iadd__(self, other: C):
        global n_iadd
        n_iadd += 1
        return self

    def __isub__(self, other: C):
        global n_isub
        n_isub += 1
        return self

    def __imul__(self, other: C):
        global n_imul
        n_imul += 1
        return self

    def __imatmul__(self, other: C):
        global n_imatmul
        n_imatmul += 1
        return self

    def __itruediv__(self, other: C):
        global n_itruediv
        n_itruediv += 1
        return self

    def __ifloordiv__(self, other: C):
        global n_ifloordiv
        n_ifloordiv += 1
        return self

    def __imod__(self, other: C):
        global n_imod
        n_imod += 1
        return self

    def __ipow__(self, other: C):
        global n_ipow
        n_ipow += 1
        return self

    def __iand__(self, other: C):
        global n_iand
        n_iand += 1
        return self

    def __ior__(self, other: C):
        global n_ior
        n_ior += 1
        return self

    def __ixor__(self, other: C):
        global n_ixor
        n_ixor += 1
        return self

    def __ilshift__(self, other: C):
        global n_ilshift
        n_ilshift += 1
        return self

    def __irshift__(self, other: C):
        global n_irshift
        n_irshift += 1
        return "rshift"


@test
def test_comparisons():
    assert apply2(eq, 1, 2, False)
    assert apply2(eq, 2, 1, False)
    assert apply2(eq, 1, 1, True)
    assert apply2(eq, 1, 1.1, False)

    assert apply2(operator.__eq__, 1, 2, False)
    assert apply2(operator.__eq__, 2, 1, False)
    assert apply2(operator.__eq__, 1, 1, True)
    assert apply2(operator.__eq__, 1, 1.1, False)

    assert apply2(ne, 1, 2, True)
    assert apply2(ne, 2, 1, True)
    assert apply2(ne, 1, 1, False)
    assert apply2(ne, 1, 1.1, True)

    assert apply2(operator.__ne__, 1, 2, True)
    assert apply2(operator.__ne__, 2, 1, True)
    assert apply2(operator.__ne__, 1, 1, False)
    assert apply2(operator.__ne__, 1, 1.1, True)

    assert apply2(lt, 1, 2, True)
    assert apply2(lt, 2, 1, False)
    assert apply2(lt, 1, 1, False)
    assert apply2(lt, 1, 1.1, True)

    assert apply2(operator.__lt__, 1, 2, True)
    assert apply2(operator.__lt__, 2, 1, False)
    assert apply2(operator.__lt__, 1, 1, False)
    assert apply2(operator.__lt__, 1, 1.1, True)

    assert apply2(le, 1, 2, True)
    assert apply2(le, 2, 1, False)
    assert apply2(le, 1, 1, True)
    assert apply2(le, 1, 1.1, True)

    assert apply2(operator.__le__, 1, 2, True)
    assert apply2(operator.__le__, 2, 1, False)
    assert apply2(operator.__le__, 1, 1, True)
    assert apply2(operator.__le__, 1, 1.1, True)

    assert apply2(gt, 1, 2, False)
    assert apply2(gt, 2, 1, True)
    assert apply2(gt, 1, 1, False)
    assert apply2(gt, 1, 1.1, False)

    assert apply2(operator.__gt__, 1, 2, False)
    assert apply2(operator.__gt__, 2, 1, True)
    assert apply2(operator.__gt__, 1, 1, False)
    assert apply2(operator.__gt__, 1, 1.1, False)

    assert apply2(ge, 1, 2, False)
    assert apply2(ge, 2, 1, True)
    assert apply2(ge, 1, 1, True)
    assert apply2(ge, 1, 1.1, False)

    assert apply2(operator.__ge__, 1, 2, False)
    assert apply2(operator.__ge__, 2, 1, True)
    assert apply2(operator.__ge__, 1, 1, True)
    assert apply2(operator.__ge__, 1, 1.1, False)

    assert apply2(eq, C(), C(), False)
    assert n_eq == 1
    assert apply2(ne, C(), C(), False)
    assert n_ne == 1
    assert apply2(lt, C(), C(), False)
    assert n_lt == 1
    assert apply2(le, C(), C(), False)
    assert n_le == 1
    assert apply2(gt, C(), C(), False)
    assert n_gt == 1
    assert apply2(ge, C(), C(), False)
    assert n_ge == 1

    assert apply2(operator.__eq__, C(), C(), False)
    assert n_eq == 2
    assert apply2(operator.__ne__, C(), C(), False)
    assert n_ne == 2
    assert apply2(operator.__lt__, C(), C(), False)
    assert n_lt == 2
    assert apply2(operator.__le__, C(), C(), False)
    assert n_le == 2
    assert apply2(operator.__gt__, C(), C(), False)
    assert n_gt == 2
    assert apply2(operator.__ge__, C(), C(), False)
    assert n_ge == 2


test_comparisons()


class A1:
    def __bool__(self):
        return True

    def __len__(self):
        return 0


class A2:
    def __len__(self):
        return 42


@test
def test_truthiness():
    assert truth(1)
    assert not truth(0)
    assert not_(False)
    assert not not_(True)
    assert not not_(A1())
    assert not not_(A2())

    a = A1()
    b = A1()

    assert is_(a, a)
    assert not is_(a, b)
    assert is_not(a, b)
    assert not is_not(a, a)

    assert truth(C())
    assert n_bool == 1


test_truthiness()


@test
def test_ops():
    x = C()
    y = C()

    assert abs(x) == "abs"
    assert n_abs == 1
    assert operator.__abs__(x) == "abs"
    assert n_abs == 2

    assert pos(x) == "pos"
    assert n_pos == 1
    assert operator.__pos__(x) == "pos"
    assert n_pos == 2

    assert neg(x) == "neg"
    assert n_neg == 1
    assert operator.__neg__(x) == "neg"
    assert n_neg == 2

    assert inv(x) == "inv"
    assert n_inv == 1
    assert operator.__inv__(x) == "inv"
    assert n_inv == 2
    assert invert(x) == "inv"
    assert n_inv == 3
    assert operator.__invert__(x) == "inv"
    assert n_inv == 4

    assert index(x) == "index"
    assert n_index == 1
    assert operator.__index__(x) == "index"
    assert n_index == 2

    assert add(x, y) == "add"
    assert n_add == 1
    assert operator.__add__(x, y) == "add"
    assert n_add == 2

    assert iadd(x, y) is x
    assert n_iadd == 1
    assert operator.__iadd__(x, y) is x
    assert n_iadd == 2

    assert sub(x, y) == "sub"
    assert n_sub == 1
    assert operator.__sub__(x, y) == "sub"
    assert n_sub == 2

    assert isub(x, y) is x
    assert n_isub == 1
    assert operator.__isub__(x, y) is x
    assert n_isub == 2

    assert mul(x, y) == "mul"
    assert n_mul == 1
    assert operator.__mul__(x, y) == "mul"
    assert n_mul == 2

    assert imul(x, y) is x
    assert n_imul == 1
    assert operator.__imul__(x, y) is x
    assert n_imul == 2

    assert matmul(x, y) == "matmul"
    assert n_matmul == 1
    assert operator.__matmul__(x, y) == "matmul"
    assert n_matmul == 2

    assert imatmul(x, y) is x
    assert n_imatmul == 1
    assert operator.__imatmul__(x, y) is x
    assert n_imatmul == 2

    assert truediv(x, y) == "truediv"
    assert n_truediv == 1
    assert operator.__truediv__(x, y) == "truediv"
    assert n_truediv == 2

    assert itruediv(x, y) is x
    assert n_itruediv == 1
    assert operator.__itruediv__(x, y) is x
    assert n_itruediv == 2

    assert floordiv(x, y) == "floordiv"
    assert n_floordiv == 1
    assert operator.__floordiv__(x, y) == "floordiv"
    assert n_floordiv == 2

    assert ifloordiv(x, y) is x
    assert n_ifloordiv == 1
    assert operator.__ifloordiv__(x, y) is x
    assert n_ifloordiv == 2

    assert mod(x, y) == "mod"
    assert n_mod == 1
    assert operator.__mod__(x, y) == "mod"
    assert n_mod == 2

    assert imod(x, y) is x
    assert n_imod == 1
    assert operator.__imod__(x, y) is x
    assert n_imod == 2

    assert pow(x, y) == "pow"
    assert n_pow == 1
    assert operator.__pow__(x, y) == "pow"
    assert n_pow == 2

    assert ipow(x, y) is x
    assert n_ipow == 1
    assert operator.__ipow__(x, y) is x
    assert n_ipow == 2

    assert and_(x, y) == "and"
    assert n_and == 1
    assert operator.__and__(x, y) == "and"
    assert n_and == 2

    assert iand(x, y) is x
    assert n_iand == 1
    assert operator.__iand__(x, y) is x
    assert n_iand == 2

    assert or_(x, y) == "or"
    assert n_or == 1
    assert operator.__or__(x, y) == "or"
    assert n_or == 2

    assert ior(x, y) is x
    assert n_ior == 1
    assert operator.__ior__(x, y) is x
    assert n_ior == 2

    assert xor(x, y) == "xor"
    assert n_xor == 1
    assert operator.__xor__(x, y) == "xor"
    assert n_xor == 2

    assert ixor(x, y) is x
    assert n_ixor == 1
    assert operator.__ixor__(x, y) is x
    assert n_ixor == 2

    assert lshift(x, y) == "lshift"
    assert n_lshift == 1
    assert operator.__lshift__(x, y) == "lshift"
    assert n_lshift == 2

    assert ilshift(x, y) is x
    assert n_ilshift == 1
    assert operator.__ilshift__(x, y) is x
    assert n_ilshift == 2

    assert rshift(x, y) == "rshift"
    assert n_rshift == 1
    assert operator.__rshift__(x, y) == "rshift"
    assert n_rshift == 2

    assert irshift(x, y) is x
    assert n_irshift == 1
    assert operator.__irshift__(x, y) is x
    assert n_irshift == 2


test_ops()


class B1:
    def __length_hint__(self):
        return 101


class B2:
    def __length_hint__(self):
        return 202

    def __len__(self):
        return 303


class B3:
    pass


@test
def test_sequence_ops():
    assert concat([1, 2], [3, 4]) == [1, 2, 3, 4]
    assert operator.__concat__([1, 2], [3, 4]) == [1, 2, 3, 4]
    assert contains([1, 2, 3], 2)
    assert not contains([1, 2, 3], 0)
    assert operator.__contains__([1, 2, 3], 2)
    assert not operator.__contains__([1, 2, 3], 0)
    assert countOf([1, 2, 1, 1], 1) == 3

    v = [1, 2, 3]
    assert getitem(v, 1) == 2
    delitem(v, 1)
    assert v == [1, 3]
    setitem(v, 1, 99)
    assert v == [1, 99]

    assert length_hint(B1()) == 101
    assert length_hint(B2()) == 303
    assert length_hint(B3()) == 0
    assert length_hint(B3(), default=404) == 404

    assert itemgetter(-1)([11, 22, 33]) == 33
    assert itemgetter(-1, -2, -3)([11, 22, 33]) == (33, 22, 11)


test_sequence_ops()


class C:
    foo: int

    def __init__(self, foo):
        self.foo = foo

    def bar(self, k, m, n):
        return self.foo + k + m*100 + n*1000


@test
def test_getter_ops():
    v = ['a']
    operator.attrgetter('append')(v)('hello')
    operator.methodcaller('append', 'goodbye')(v)
    assert v == ['a', 'hello', 'goodbye']

    c = C(10)
    assert operator.attrgetter('foo')(c) == 10
    assert operator.methodcaller('bar', 9, n=7, m=3)(c) == 7319


test_getter_ops()
</t>
<t tx="ekr.20230509083244.153">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import random as R
import time
import sys
from copy import copy

seed = int(time.time())
# sys.stderr.write('seed: ' + str(seed) + '\n')
R.seed(seed)


@test
def test_rnd_result(name, results, invariant):
    print(name)
    for a in results:
        assert invariant(a)


test_rnd_result(
    "randrange", [R.randrange(10) for _ in range(100)], range(10).__contains__
)
test_rnd_result(
    "randrange", [R.randrange(5, 20) for _ in range(100)], range(5, 20).__contains__
)
test_rnd_result(
    "randrange",
    [R.randrange(9, 99, 3) for _ in range(100)],
    range(9, 99, 3).__contains__,
)
test_rnd_result(
    "randint", [R.randint(5, 20) for _ in range(100)], range(5, 20 + 1).__contains__
)

population = list("ABCDEFGHIJKLMNOP")
test_rnd_result(
    "choice", [R.choice(population) for _ in range(100)], population.__contains__
)
test_rnd_result(
    "choice", [R.choice(population) for _ in range(100)], population.__contains__
)
test_rnd_result("choices", R.choices(population), population.__contains__)
test_rnd_result("choices", R.choices(population, k=100), population.__contains__)


@test
def test_shuffle(v):
    s = copy(v)
    R.shuffle(s)
    assert sorted(v) == sorted(s)


test_shuffle(list(range(100)))


@test
def test_sample(n: int, k: int):
    s = R.sample(list(range(n)), k=k)
    assert len(s) == k
    assert len(set(s)) == len(s)
    for a in s:
        assert a in range(n)


test_sample(100, 5)
test_sample(100, 100)
test_sample(100, 0)


from python import random as Rpy

@test
def test_vs_python(*args, seed, method: Static[str], T: type = float):
    print(seed, method, args)
    R1 = R.Random(seed)
    R2 = Rpy.Random(seed)

    N = 50
    A1 = [T(getattr(R1, method)(*args)) for _ in range(N)]
    A2 = [T.__from_py__(getattr(R2, method)(*args).p) for _ in range(N)]
    assert A1 == A2

test_vs_python(-10, 10, seed=22, method='randrange', T=int)
test_vs_python(-10, 10, 3, seed=33, method='randrange', T=int)
test_vs_python(-10, 10, seed=44, method='randint', T=int)
test_vs_python(20, seed=55, method='getrandbits', T=int)
test_vs_python(32, seed=55, method='getrandbits', T=int)
test_vs_python(40, seed=55, method='getrandbits', T=int)
test_vs_python(63, seed=55, method='getrandbits', T=int)
test_vs_python(seed=0, method='random')
test_vs_python(-12.5, 101.2, seed=1, method='uniform')
test_vs_python(-13, 5.5, 0, seed=2, method='triangular')
#test_vs_python(1.0, 2, seed=3, method='betavariate')  # different in older Python versions
test_vs_python(0.3, seed=4, method='expovariate')
#test_vs_python(1.0, 2, seed=5, method='gammavariate')  # different in older Python versions
test_vs_python(1.0, 2.0, seed=-101, method='gauss')
test_vs_python(1.0, 2.0, seed=-102, method='lognormvariate')
test_vs_python(1.0, 2.0, seed=-103, method='normalvariate')
test_vs_python(1.0, 2.0, seed=0xffffffff, method='vonmisesvariate')
test_vs_python(1.0, seed=0xffffffff-1, method='paretovariate')
test_vs_python(1.0, 2.0, seed=0, method='weibullvariate')


@test
def test_state():
    r = R.Random(1234)
    state = r.getstate()
    N = 100
    A1 = [r.random() for _ in range(N)]
    B1 = [r.gauss() for _ in range(N)]
    r.setstate(state)
    A2 = [r.random() for _ in range(N)]
    B2 = [r.gauss() for _ in range(N)]
    r.seed(1234)
    A3 = [r.random() for _ in range(N)]
    B3 = [r.gauss() for _ in range(N)]

    assert A1 == A2 == A3
    assert B1 == B2 == B3

test_state()
</t>
<t tx="ekr.20230509083244.154">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import re
import string

@test
def test_search_star_plus():
    assert re.search('x*', 'axx').span(0) == (0, 0)
    assert re.search('x*', 'axx').span() == (0, 0)
    assert re.search('x+', 'axx').span(0) == (1, 3)
    assert re.search('x+', 'axx').span() == (1, 3)
    assert re.search('x', 'aaa') is None
    assert re.match('a*', 'xxx').span(0) == (0, 0)
    assert re.match('a*', 'xxx').span() == (0, 0)
    assert re.match('x*', 'xxxa').span(0) == (0, 3)
    assert re.match('x*', 'xxxa').span() == (0, 3)
    assert re.match('a+', 'xxx') is None
test_search_star_plus()

@test
def test_branching():
    """Test Branching
    Test expressions using the OR ('|') operator."""
    assert re.match('(ab|ba)', 'ab').span() == (0, 2)
    assert re.match('(ab|ba)', 'ba').span() == (0, 2)
    assert re.match('(abc|bac|ca|cb)', 'abc').span() == (0, 3)
    assert re.match('(abc|bac|ca|cb)', 'bac').span() == (0, 3)
    assert re.match('(abc|bac|ca|cb)', 'ca').span() == (0, 2)
    assert re.match('(abc|bac|ca|cb)', 'cb').span() == (0, 2)
    assert re.match('((a)|(b)|(c))', 'a').span() == (0, 1)
    assert re.match('((a)|(b)|(c))', 'b').span() == (0, 1)
    assert re.match('((a)|(b)|(c))', 'c').span() == (0, 1)
test_branching()

@test
def test_basic_re_sub():
    def bump_num(matchobj):
        int_value = int(matchobj.group(0))
        return str(int_value + 1)

    assert re.sub('y', 'a', 'xyz') == 'xaz'

    assert re.sub("(?i)b+", "x", "bbbb BBBB") == 'x x'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y') == '9.3 -3 24x100y'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y', 3) == '9.3 -3 23x99y'
    assert re.sub(r'\d+', bump_num, '08.2 -2 23x99y', count=3) == '9.3 -3 23x99y'

    assert re.sub('.', lambda m: r"\n", 'x') == '\\n'
    assert re.sub('.', r"\n", 'x') == '\n'

    s = r"\1\1"
    assert re.sub('(.)', s, 'x') == 'xx'
    assert re.sub('(.)', s.replace('\\', r'\\'), 'x') == s
    assert re.sub('(.)', lambda m: s, 'x') == s

    assert re.sub('(?P&lt;a&gt;x)', r'\g&lt;a&gt;\g&lt;a&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;a&gt;x)', r'\g&lt;a&gt;\g&lt;1&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;unk&gt;x)', r'\g&lt;unk&gt;\g&lt;unk&gt;', 'xx') == 'xxxx'
    assert re.sub('(?P&lt;unk&gt;x)', r'\g&lt;1&gt;\g&lt;1&gt;', 'xx') == 'xxxx'
    assert re.sub('()x', r'\g&lt;0&gt;\g&lt;0&gt;', 'xx') == 'xxxx'

    assert re.sub('a', r'\t\n\v\r\f\a\b', 'a') == '\t\n\v\r\f\a\b'
    assert re.sub('a', '\t\n\v\r\f\a\b', 'a') == '\t\n\v\r\f\a\b'
    assert re.sub('a', '\t\n\v\r\f\a\b', 'a') == (chr(9)+chr(10)+chr(11)+chr(13)+chr(12)+chr(7)+chr(8))
    for c in 'cdehijklmopqsuwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ':
        try:
            re.sub('a', '\\' + c, 'a')
            assert False
        except re.error:
            pass
    assert re.sub(r'^\s*', 'X', 'test') == 'Xtest'
test_basic_re_sub()

@test
def test_bug_449964():
    assert re.sub(r'(?P&lt;unk&gt;x)', r'\g&lt;1&gt;\g&lt;1&gt;\b', 'xx') == 'xx\bxx\b'
test_bug_449964()

@test
def test_bug_449000():
    # Test for sub() on escaped characters
    assert re.sub(r'\r\n', r'\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
    assert re.sub('\r\n', r'\n', 'abc\r\ndef\r\n') =='abc\ndef\n'
    assert re.sub(r'\r\n', '\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
    assert re.sub('\r\n', '\n', 'abc\r\ndef\r\n') == 'abc\ndef\n'
test_bug_449000()

@test
def test_sub_template_numeric_escape():
    # bug 776311 and friends
    assert re.sub('x', r'\0', 'x') == '\0'
    assert re.sub('x', r'\000', 'x') == '\000'
    assert re.sub('x', r'\001', 'x') == '\001'
    assert re.sub('x', r'\008', 'x') == '\0' + '8'
    assert re.sub('x', r'\009', 'x') == '\0' + '9'
    assert re.sub('x', r'\111', 'x') == '\111'
    assert re.sub('x', r'\117', 'x') == '\117'
    assert re.sub('x', r'\377', 'x') == '\377'

    assert re.sub('x', r'\1111', 'x'), '\1111'
    assert re.sub('x', r'\1111', 'x'), '\111' + '1'

    assert re.sub('x', r'\00', 'x') == '\x00'
    assert re.sub('x', r'\07', 'x') == '\x07'
    assert re.sub('x', r'\08', 'x') == '\0' + '8'
    assert re.sub('x', r'\09', 'x') == '\0' + '9'
    assert re.sub('x', r'\0a', 'x') == '\0' + 'a'

    '''
    self.checkTemplateError('x', r'\400', 'x',
                            r'octal escape value \400 outside of '
                            r'range 0-0o377', 0)
    self.checkTemplateError('x', r'\777', 'x',
                            r'octal escape value \777 outside of '
                            r'range 0-0o377', 0)

    self.checkTemplateError('x', r'\1', 'x', 'invalid group reference 1', 1)
    self.checkTemplateError('x', r'\8', 'x', 'invalid group reference 8', 1)
    self.checkTemplateError('x', r'\9', 'x', 'invalid group reference 9', 1)
    self.checkTemplateError('x', r'\11', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\18', 'x', 'invalid group reference 18', 1)
    self.checkTemplateError('x', r'\1a', 'x', 'invalid group reference 1', 1)
    self.checkTemplateError('x', r'\90', 'x', 'invalid group reference 90', 1)
    self.checkTemplateError('x', r'\99', 'x', 'invalid group reference 99', 1)
    self.checkTemplateError('x', r'\118', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\11a', 'x', 'invalid group reference 11', 1)
    self.checkTemplateError('x', r'\181', 'x', 'invalid group reference 18', 1)
    self.checkTemplateError('x', r'\800', 'x', 'invalid group reference 80', 1)
    self.checkTemplateError('x', r'\8', '', 'invalid group reference 8', 1)
    '''

    assert re.sub('(((((((((((x)))))))))))', r'\11', 'x') == 'x'
    assert re.sub('((((((((((y))))))))))(.)', r'\118', 'xyz') == 'xz8'
    assert re.sub('((((((((((y))))))))))(.)', r'\11a', 'xyz') == 'xza'
test_sub_template_numeric_escape()

@test
def test_qualified_re_sub():
    assert re.sub('a', 'b', 'aaaaa') == 'bbbbb'
    assert re.sub('a', 'b', 'aaaaa', 1) == 'baaaa'
    assert re.sub('a', 'b', 'aaaaa', count=1) == 'baaaa'
test_qualified_re_sub()

@test
def test_bug_114660():
    assert re.sub(r'(\S)\s+(\S)', r'\1 \2', 'hello  there') == 'hello there'
test_bug_114660()

@test
def test_symbolic_refs():
    assert re.sub('(?P&lt;a&gt;x)|(?P&lt;b&gt;y)', r'\g&lt;b&gt;', 'xx') == ''
    assert re.sub('(?P&lt;a&gt;x)|(?P&lt;b&gt;y)', r'\2', 'xx') == ''
    # Support &gt; 100 groups.
    pat = '|'.join(f'x(?P&lt;a{i}&gt;{hex(i)[2:]})y' for i in range(1, 200 + 1))
    assert re.sub(pat, r'\g&lt;200&gt;', 'xc8yzxc8y') == 'c8zc8'
test_symbolic_refs()

@test
def test_re_subn():
    assert re.subn("(?i)b+", "x", "bbbb BBBB") == ('x x', 2)
    assert re.subn("b+", "x", "bbbb BBBB") == ('x BBBB', 1)
    assert re.subn("b+", "x", "xyz") == ('xyz', 0)
    assert re.subn("b*", "x", "xyz") == ('xxxyxzx', 4)
    assert re.subn("b*", "x", "xyz", 2) == ('xxxyz', 2)
    assert re.subn("b*", "x", "xyz", count=2) == ('xxxyz', 2)
test_re_subn()

# TODO: Current version does not allow None == None,
#       so use this as a workaround.
def cmp_opt(x, y):
    if x is None:
        return y is None
    elif y is None:
        return x is None
    else:
        return unwrap(x) == unwrap(y)

def cmp_list(a, b):
    if len(a) != len(b):
        return False

    for i in range(len(a)):
        if not cmp_opt(a[i], b[i]):
            return False

    return True

def cmp_tuple(a, b):
    if staticlen(a) != staticlen(b):
        return False
    elif staticlen(a) == 0:
        return True
    else:
        if not cmp_opt(a[0], b[0]):
            return False
        return cmp_tuple(a[1:], b[1:])

@test
def test_re_split():
    assert cmp_list(re.split(":", ":a:b::c"), ['', 'a', 'b', '', 'c'])
    assert cmp_list(re.split(":+", ":a:b::c"), ['', 'a', 'b', 'c'])
    assert cmp_list(re.split("(:+)", ":a:b::c"), ['', ':', 'a', ':', 'b', '::', 'c'])

    assert cmp_list(re.split("(?::+)", ":a:b::c"), ['', 'a', 'b', 'c'])
    assert cmp_list(re.split("(:)+", ":a:b::c"), ['', ':', 'a', ':', 'b', ':', 'c'])
    assert cmp_list(re.split("([b:]+)", ":a:b::c"), ['', ':', 'a', ':b::', 'c'])
    assert cmp_list(re.split("(b)|(:+)", ":a:b::c"), [None, '', None, ':', 'a', None, ':', '', 'b', None, '', None, '::', 'c'][1:])
    assert cmp_list(re.split("(?:b)|(?::+)", ":a:b::c"), ['', 'a', '', '', 'c'])

    for sep, expected in [
        (':*', [None, '', '', 'a', '', 'b', '', 'c', ''][1:]),
        ('(?::*)', [None, '', '', 'a', '', 'b', '', 'c', ''][1:]),
        ('(:*)', [None, '', ':', '', '', 'a', ':', '', '', 'b', '::', '', '', 'c', '', ''][1:]),
        ('(:)*', [None, '', ':', '', None, 'a', ':', '', None, 'b', ':', '', None, 'c', None, ''][1:]),
    ]:
        assert cmp_list(re.split(sep, ':a:b::c'), expected)

    for sep, expected in [
        ('', ['', ':', 'a', ':', 'b', ':', ':', 'c', '']),
        # (r'\b', [':', 'a', ':', 'b', '::', 'c', '']),  # TODO: this fails; re2 difference maybe?
    ]:
        assert cmp_list(re.split(sep, ':a:b::c'), expected)
test_re_split()

@test
def test_qualified_re_split():
    assert cmp_list(re.split(":", ":a:b::c", 2), ['', 'a', 'b::c'])
    assert cmp_list(re.split(":", ":a:b::c", maxsplit=2), ['', 'a', 'b::c'])
    assert cmp_list(re.split(':', 'a:b:c:d', maxsplit=2), ['a', 'b', 'c:d'])
    assert cmp_list(re.split("(:)", ":a:b::c", maxsplit=2), ['', ':', 'a', ':', 'b::c'])
    assert cmp_list(re.split("(:+)", ":a:b::c", maxsplit=2), ['', ':', 'a', ':', 'b::c'])
    assert cmp_list(re.split("(:*)", ":a:b::c", maxsplit=2), ['', ':', '', '', 'a:b::c'])
test_qualified_re_split()

@test
def test_re_findall():
    assert re.findall(":+", "abc") == []
    assert re.findall(":+", "a:b::c:::d") == [":", "::", ":::"]
    assert re.findall("(:+)", "a:b::c:::d") == [":", "::", ":::"]
    # (!) Note: this is different in Codon, as we always return the full match even
    #           if there are capturing groups.
    assert re.findall("(:)(:*)", "a:b::c:::d") == [":", "::", ":::"]

    x = "\xe0"
    xx = x * 2
    xxx = x * 3
    string = f"a{x}b{xx}c{xxx}d"
    assert re.findall(f"{x}+", string) == [x, xx, xxx]
    assert re.findall(f"({x}+)", string) == [x, xx, xxx]
    # (!) Note: same as above.
    assert re.findall(f"({x})({x}*)", string) == [x, xx, xxx]
test_re_findall()

@test
def test_re_match():
    assert cmp_list(re.match('a', 'a').groups(), List[Optional[str]]())
    assert cmp_list(re.match('(a)', 'a').groups(), [None, 'a',][1:])
    assert re.match('(a)', 'a').group(0).__val__() == 'a'
    assert re.match('(a)', 'a').group(1).__val__() == 'a'
    assert re.match('(a)', 'a').group(1, 1) == (Optional('a'), Optional('a'))
    assert cmp_list(re.match('\xe0', '\xe0').groups(), List[Optional[str]]())
    assert cmp_list(re.match('(\xe0)', '\xe0').groups(), ['\xe0'])
    assert unwrap(re.match('(\xe0)', '\xe0').group(0)) == '\xe0'
    assert unwrap(re.match('(\xe0)', '\xe0').group(1)) == '\xe0'
    assert re.match('(\xe0)', '\xe0').group(1, 1) == (Optional('\xe0'), Optional('\xe0'))

    pat = re.compile('((a)|(b))(c)?')
    assert cmp_list(pat.match('a').groups(), [None, 'a', 'a', None, None][1:])
    assert cmp_list(pat.match('b').groups(), [None, 'b', None, 'b', None][1:])
    assert cmp_list(pat.match('ac').groups(), [None, 'a', 'a', None, 'c'][1:])
    assert cmp_list(pat.match('bc').groups(), [None, 'b', None, 'b', 'c'][1:])
    assert cmp_list(pat.match('bc').groups(""), [None, 'b', "", 'b', 'c'][1:])

    pat = re.compile('(?:(?P&lt;a1&gt;a)|(?P&lt;b2&gt;b))(?P&lt;c3&gt;c)?')
    assert cmp_tuple(pat.match('a').group(1, 2, 3), (Optional('a'), Optional[str](), Optional[str]()))
    assert cmp_tuple(pat.match('b').group('a1', 'b2', 'c3'), (Optional[str](), Optional('b'), Optional[str]()))
    assert cmp_tuple(pat.match('ac').group(1, 'b2', 3), (Optional('a'), Optional[str](), Optional('c')))
test_re_match()

def raises(exception: type, function, *args, **kwargs):
    try:
        function(*args, **kwargs)
    except exception:
        return True
    except:
        pass
    return False

@test
def test_group():
    class Index:
        value: int
        def __init__(self, value):
            self.value = value
        def __index__(self):
            return self.value
    # A single group
    m = re.match('(a)(b)', 'ab')
    assert m.group() == 'ab'
    assert unwrap(m.group(0)) == 'ab'
    assert unwrap(m.group(1)) == 'a'
    assert unwrap(m.group(Index(1))) == 'a'
    assert raises(IndexError, m.group, -1)
    assert raises(IndexError, m.group, 3)
    assert raises(IndexError, m.group, 1&lt;&lt;1000)
    assert raises(IndexError, m.group, Index(1&lt;&lt;1000))
    assert raises(IndexError, m.group, 'x')
    # Multiple groups
    assert cmp_tuple(m.group(2, 1), ('b', 'a'))
    assert cmp_tuple(m.group(Index(2), Index(1)), ('b', 'a'))
test_group()

@test
def test_match_getitem():
    pat = re.compile('(?:(?P&lt;a1&gt;a)|(?P&lt;b2&gt;b))(?P&lt;c3&gt;c)?')

    m = pat.match('a')
    assert unwrap(m['a1']) == 'a'
    assert m['b2'] is None
    assert m['c3'] is None
    assert unwrap(m[0]) == 'a'
    assert unwrap(m[1]) == 'a'
    assert m[2] is None
    assert m[3] is None

    assert raises(IndexError, lambda i: m[i], 'X')
    assert raises(IndexError, lambda i: m[i], -1)
    assert raises(IndexError, lambda i: m[i], 4)

    m = pat.match('ac')
    assert unwrap(m['a1']) == 'a'
    assert m['b2'] is None
    assert unwrap(m['c3']) == 'c'
    assert unwrap(m[0]) == 'ac'
    assert unwrap(m[1]) == 'a'
    assert m[2] is None
    assert unwrap(m[3]) == 'c'
test_match_getitem()

@test
def test_re_fullmatch():
    assert re.fullmatch(r"a", "a").span() == (0, 1)
    assert re.fullmatch(r"a|ab", "ab").span() == (0, 2)
    assert re.fullmatch("\xe0|\xe0\xdf", "\xe0\xdf").span() == (0, 2)

    assert re.fullmatch(r".*?$", "abc").span() == (0, 3)
    assert re.fullmatch(r".*?", "abc").span() == (0, 3)
    assert re.fullmatch(r"a.*?b", "ab").span() == (0, 2)
    assert re.fullmatch(r"a.*?b", "abb").span() == (0, 3)
    assert re.fullmatch(r"a.*?b", "axxb").span() == (0, 4)
    assert re.fullmatch(r"a+", "ab") is None
    assert re.fullmatch(r"abc$", "abc\n") is None
    assert re.fullmatch(r"(?m)abc$", "abc\n") is None

    assert re.compile(r"bc").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
    # TODO: following fails; $ does not respect endpos in re2?
    #assert re.compile(r".*?$").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
    assert re.compile(r".*?").fullmatch("abcd", pos=1, endpos=3).span() == (1, 3)
test_re_fullmatch()

@test
def test_finditer():
    iter = re.finditer(r":+", "a:b::c:::d")
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", 1, 10)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", pos=1, endpos=10)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", endpos=10, pos=1)
    assert cmp_list([item.group(0) for item in iter], [":", "::", ":::"])

    pat = re.compile(r":+")
    iter = pat.finditer("a:b::c:::d", pos=3, endpos=8)
    assert cmp_list([item.group(0) for item in iter], ["::", "::"])
test_finditer()

@test
def test_constants():
    assert re.I == re.IGNORECASE
    assert re.L == re.LOCALE
    assert re.M == re.MULTILINE
    assert re.S == re.DOTALL
    assert re.X == re.VERBOSE
test_constants()

@test
def test_anyall():
    assert unwrap(re.match("a.b", "a\nb", re.DOTALL).group(0)) == "a\nb"
    assert unwrap(re.match("a.*b", "a\n\nb", re.DOTALL).group(0)) == "a\n\nb"
test_anyall()

@test
def test_groupdict():
    d = re.match('(?P&lt;first&gt;first) (?P&lt;second&gt;second)', 'first second').groupdict()
    assert len(d) == 2 and unwrap(d['first']) == 'first' and unwrap(d['second']) == 'second'
test_groupdict()

@test
def test_expand():
    assert re.match("(?P&lt;first&gt;first) (?P&lt;second&gt;second)", "first second").expand(r"\2 \1 \g&lt;second&gt; \g&lt;first&gt;") == "second first second first"
    assert re.match("(?P&lt;first&gt;first)|(?P&lt;second&gt;second)", "first").expand(r"\2 \g&lt;second&gt;") == " "
test_expand()

@test
def test_getattr():
    assert re.compile("(?i)(a)(b)").pattern == "(?i)(a)(b)"
    # TODO: Codon does not support flags like this
    # self.assertEqual(re.compile("(?i)(a)(b)").flags, re.I | re.U)
    assert re.compile("(?i)(a)(b)").groups == 2
    assert re.compile("(?i)(a)(b)").groupindex == {}
    assert re.compile("(?i)(?P&lt;first&gt;a)(?P&lt;other&gt;b)").groupindex == {'first': 1, 'other': 2}

    assert re.match("(a)", "a").pos == 0
    assert re.match("(a)", "a").endpos == 1
    assert re.match("(a)", "a").string == "a"
    assert re.match("(a)", "a").re
test_getattr()

def check_match(pattern, text, match: Optional[str] = None, span: Optional[re.Span] = None, matcher = re.fullmatch):
    if match is None and span is None:
        # the pattern matches the whole text
        match = text
        span = (0, len(text))
    elif match is None or span is None:
        raise ValueError('If match is not None, span should be specified '
                         '(and vice versa).')
    m = matcher(pattern, text)
    return bool(m) and m.group() == match and m.span() == span

LITERAL_CHARS = string.ascii_letters + string.digits

@test
def test_re_escape():
    p = ''.join(chr(i) for i in range(256))
    for c in p:
        assert check_match(re.escape(c), c)
        assert check_match('[' + re.escape(c) + ']', c)
    assert check_match(re.escape(p), p)
    for c in '-.]{}':
        assert re.escape(c)[:1] == '\\'
    literal_chars = LITERAL_CHARS
    assert re.escape(literal_chars) == literal_chars
test_re_escape()
</t>
<t tx="ekr.20230509083244.155">@path C:/Repos/codon/test/stdlib/
@language unknown_language
from algorithms.qsort import qsort_inplace
from algorithms.heapsort import heap_sort_inplace
from algorithms.pdqsort import pdq_sort_inplace
from algorithms.timsort import tim_sort_inplace
from time import time


def key(n: int):
    return -n


def gen_list(n: int):
    import random

    v = List[int](n)
    for _ in range(n):
        v.append(random.randint(0, 10000))
    return v


def copy_to(a, b):
    b.clear()
    for i in a:
        b.append(i)


@test
def ensure_sorted(v):
    for i in range(len(v) - 1):
        assert key(v[i]) &lt;= key(v[i + 1])


v0 = gen_list(100)
v1 = List[int](len(v0))


def test_sort1(name, sort):
    copy_to(v0, v1)
    t0 = time()
    sort(v1, key)
    t1 = time()
    print name, t1 - t0
    ensure_sorted(v1)


test_sort1("qsort   :", qsort_inplace)
test_sort1("heapsort:", heap_sort_inplace)
test_sort1("pdqsort :", pdq_sort_inplace)
test_sort1("timsort :", tim_sort_inplace)


@test
def test_sort2(name, sort):
    from random import shuffle

    fail = False
    print name
    for N in (0, 1, 10, 100, 1000, 10000):  # , 100000): # too slow; maybe add later?
        print N
        for i in range(1000):
            v = list(range(N))
            shuffle(v)
            sort(v, key)
            if v != list(reversed(range(N))):
                fail = True
    assert not fail


test_sort2("qsort   :", qsort_inplace)
test_sort2("heapsort:", heap_sort_inplace)
test_sort2("pdqsort :", pdq_sort_inplace)
test_sort2("timsort :", tim_sort_inplace)

# test standard sort routines
@test
def test_standard_sort():
    copy_to(v0, v1)
    v2 = sorted(v1)
    for i in range(len(v2) - 1):
        assert v2[i] &lt;= v2[i + 1]

    v2 = sorted(v1, key=key)
    for i in range(len(v2) - 1):
        assert key(v2[i]) &lt;= key(v2[i + 1])

    v2.sort()
    for i in range(len(v2) - 1):
        assert v2[i] &lt;= v2[i + 1]

    v2.sort(key=key)
    for i in range(len(v2) - 1):
        assert key(v2[i]) &lt;= key(v2[i + 1])


test_standard_sort()
</t>
<t tx="ekr.20230509083244.156">@path C:/Repos/codon/test/stdlib/
@language unknown_language
import statistics
import math


@test
def med():
    # Test median with even nuber of int data points.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median(data) == 3.5

    # Test median with an odd number of int data points.
    data = [1, 2, 3, 4, 5, 6, 9]
    assert statistics.median(data) == 4

    # Test median works with an odd number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7]
    assert statistics.median(fdata) == 3 / 7

    # Test median works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median(fdata) == 1 / 2

    # Test median works with an odd number of Decimals.
    ddata = [2.5, 3.1, 4.2, 5.7, 5.8]
    assert statistics.median(ddata) == 4.2


med()


@test
def med_low():
    # Test median_low with an even number of ints.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median_low(data) == 3

    # Test median_low works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median_low(fdata) == 3 / 7

    # Test median_low works with an even number of Decimals.
    ddata = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
    assert statistics.median_low(ddata) == 3.3


med_low()


@test
def med_high():
    # Test median_high with an even number of ints.
    data = [1, 2, 3, 4, 5, 6]
    assert statistics.median_high(data) == 4

    # Test median_high works with an even number of Fractions.
    fdata = [1 / 7, 2 / 7, 3 / 7, 4 / 7, 5 / 7, 6 / 7]
    assert statistics.median_high(fdata) == 4 / 7

    # Test median_high works with an even number of Decimals.
    ddata = [1.1, 2.2, 3.3, 4.4, 5.5, 6.6]
    assert statistics.median_high(ddata) == 4.4


med_high()


@test
def med_grouped():
    # Test median_grouped with repeated median values.
    data = [12, 13, 14, 14, 14, 15, 15]
    assert statistics.median_grouped(data) == 14

    data = [12, 13, 14, 14, 14, 14, 15]
    assert statistics.median_grouped(data) == 13.875

    data = [5, 10, 10, 15, 20, 20, 20, 20, 25, 25, 30]
    assert statistics.median_grouped(data, 5) == 19.375

    # Test median_grouped with repeated median values.
    data = [2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6]
    assert statistics.median_grouped(data) == 4.5

    data = [3, 4, 4, 4, 5, 5, 5, 5, 6, 6]
    assert statistics.median_grouped(data) == 4.75

    # Test median_grouped with repeated single values.
    ddata = [3.2]
    assert statistics.median_grouped(ddata) == 3.2

    # Test median_grouped works with an odd number of Fractions.
    fdata = [5 / 4, 9 / 4, 13 / 4, 13 / 4, 17 / 4]
    assert statistics.median_grouped(fdata) == 3.0

    # Test median_grouped works with an even number of Fractions.
    fdata = [5 / 4, 9 / 4, 13 / 4, 13 / 4, 17 / 4, 17 / 4]
    assert statistics.median_grouped(fdata) == 3.25

    # Test median_grouped works with an odd number of Decimals.
    ddata = [5.5, 6.5, 6.5, 7.5, 8.5]
    assert statistics.median_grouped(ddata) == 6.75

    # Test median_grouped works with an even number of Decimals.
    ddata = [5.5, 5.5, 6.5, 6.5, 7.5, 8.5]
    assert statistics.median_grouped(ddata) == 6.5


med_grouped()


@test
def test_mode():
    data = [12, 13, 14, 14, 14, 15, 15]
    assert statistics.mode(data) == 14

    data = list(range(20, 50, 3))
    assert statistics.mode(data) == 20

    # Test mode with nominal data.
    ndata = ["a", "b", "c", "b", "d", "b"]
    assert statistics.mode(ndata) == "b"

    ndata = ["fe", "fi", "fo", "fum", "fi", "fi"]
    assert statistics.mode(ndata) == "fi"

    # Test mode with bimodal data.
    data = [1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9]
    assert statistics.mode(data) == 2

    # Test mode when data points are all unique.
    data = list(range(10))
    assert statistics.mode(data) == 0


test_mode()


@test
def test_multimode():
    data = [1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 6, 6, 6, 7, 8, 9, 9]
    assert statistics.multimode(data) == [2, 6]

    ndata = ["a", "a", "b", "b", "b", "b", "b", "b", "b", "b", "c", "c"]
    assert statistics.multimode(ndata) == ["b"]

    ndata = [
        "a",
        "a",
        "b",
        "b",
        "b",
        "b",
        "c",
        "c",
        "d",
        "d",
        "d",
        "d",
        "e",
        "e",
        "f",
        "f",
        "f",
        "f",
        "g",
        "g",
    ]
    assert statistics.multimode(ndata) == ["b", "d", "f"]


test_multimode()


@test
def test_quantiles():
    for n in range(2, 10):
        data = [10.0] * n
        assert statistics.quantiles(data) == [10.0, 10.0, 10.0]
        assert statistics.quantiles(data, method="inclusive") == [10.0, 10.0, 10.0]

    data = [100, 200, 400, 800]
    for n, expected in [
        (2, [300.0]),
        (3, [200.0, 400.0]),
        (4, [175.0, 300.0, 500.0]),
        (5, [160.0, 240.0, 360.0, 560.0]),
        (6, [150.0, 200.0, 300.0, 400.0, 600.0]),
        (8, [137.5, 175.0, 225.0, 300.0, 375.0, 500.0, 650.0]),
        (10, [130.0, 160.0, 190.0, 240.0, 300.0, 360.0, 440.0, 560.0, 680.0]),
        (12, [125.0, 150.0, 175.0, 200.0, 250.0, 300.0, 350.0, 400.0, 500.0, 600.0, 700.0]),
        (15, [120.0, 140.0, 160.0, 180.0, 200.0, 240.0, 280.0, 320.0, 360.0, 400.0, 480.0, 560.0, 640.0, 720.0])
    ]:
        assert statistics.quantiles(data, n=n, method="inclusive") == expected


test_quantiles()


@test
def test_mean():
    data = [100.0, 200.0, 400.0, 800.0]
    assert statistics.mean(data) == 375.0

    data = [17.25, 19.75, 20.0, 21.5, 21.75, 23.25, 25.125, 27.5]
    assert statistics.mean(data) == 22.015625

    data = [
        0.0,
        1.0,
        2.0,
        3.0,
        3.0,
        3.0,
        4.0,
        5.0,
        5.0,
        6.0,
        7.0,
        7.0,
        7.0,
        7.0,
        8.0,
        9.0,
    ]
    assert statistics.mean(data) == 4.8125


test_mean()


@test
def test_geometric_mean():
    PRECISION = 1e-6

    data = [54.0, 24.0, 36.0]
    assert math.fabs(statistics.geometric_mean(data) - 36) &lt; PRECISION

    data = [4.0, 9.0]
    assert math.fabs(statistics.geometric_mean(data) - 6) &lt; PRECISION

    data = [17.625]
    assert math.fabs(statistics.geometric_mean(data) - 17.625) &lt; PRECISION

    data = [3.5, 4.0, 5.25]
    assert math.fabs(statistics.geometric_mean(data) - 4.18886) &lt; PRECISION


test_geometric_mean()


@test
def test_harmonic_mean():
    data = [1.0, 0.0, 2.0]
    assert statistics.harmonic_mean(data) == 0

    data = [2.0, 4.0, 4.0, 8.0, 16.0, 16.0]
    assert statistics.harmonic_mean(data) == 6 * 4 / 5

    data = [1 / 8, 1 / 4, 1 / 4, 1 / 2, 1 / 2]
    assert statistics.harmonic_mean(data) == 1 / 4

    for x in range(1, 101):
        assert statistics.harmonic_mean([float(x)]) == float(x)


test_harmonic_mean()


@test
def test_pvariance():
    data = [float(i) for i in range(10000)]
    assert statistics.pvariance(data) == (10000 ** 2 - 1) / 12

    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.pvariance(data) == 22.5

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.pvariance(data) == 3 / 8


test_pvariance()


@test
def test_pstdev():
    data = [float(i) for i in range(10000)]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))

    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.pstdev(data) == math.sqrt(statistics.pvariance(data))


test_pstdev()


@test
def test_variance():
    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.variance(data) == 30.0

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.variance(data) == 1 / 2


test_variance()


@test
def test_stdev():
    data = [4.0, 7.0, 13.0, 16.0]
    assert statistics.stdev(data) == math.sqrt(statistics.variance(data))

    data = [1 / 4, 1 / 4, 3 / 4, 7 / 4]
    assert statistics.stdev(data) == math.sqrt(statistics.variance(data))


test_stdev()


@test
def test_mean_NormalDist():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.mean == 10000.0


test_mean_NormalDist()


@test
def test_stdev():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.stdev == 3.0


test_stdev()


@test
def test_variance():
    X = statistics.NormalDist(10000.0, 3.0)
    assert X.variance == 9.0


test_variance()


@test
def test_pdf():
    PRECISION = 1e-6
    X = statistics.NormalDist(100.0, 15.0)

    # verify peak around center
    assert X.pdf(99.0) &lt; X.pdf(100.0)
    assert X.pdf(101.0) &lt; X.pdf(100.0)

    for i in range(50):
        assert (
            math.fabs((X.pdf(100.0 - float(i)) - X.pdf(100.0 + float(i)))) &lt; PRECISION
        )


test_pdf()


@test
def test_cdf():
    X = statistics.NormalDist(100.0, 15.0)
    # Verify center (should be exact)
    assert X.cdf(100.0) == 0.50


test_cdf()


@test
def test_inv_cdf():
    PRECISION = 1e-6
    iq = statistics.NormalDist(100.0, 15.0)
    assert iq.inv_cdf(0.50) == iq.mean

    # One hundred ever smaller probabilities to test tails out to
    # extreme probabilities: 1 / 2**50 and (2**50-1) / 2 ** 50
    for e in range(1, 51):
        p = 2.0 ** (-e)
        assert math.fabs(iq.cdf(iq.inv_cdf(p)) - p) &lt; PRECISION
        p = 1.0 - p
        assert math.fabs(iq.cdf(iq.inv_cdf(p)) - p) &lt; PRECISION


test_inv_cdf()


@test
def test_ND_quartiles():
    PRECISION = 1e-6
    Z = statistics.NormalDist(0.0, 1.0)
    for n, expected in [
        (2, [0.0]),
        (3, [-0.430727, 0.430727]),
        (4, [-0.67449, 0.0, 0.67449]),
    ]:
        actual = Z.quantiles(n)
        for i in range(len(expected)):
            assert math.fabs(actual[i] - expected[i]) &lt; PRECISION


test_ND_quartiles()


@test
def test_overlap():
    PRECISION = 1e-5
    for X1, X2, published_result in [
        (statistics.NormalDist(0.0, 2.0), statistics.NormalDist(1.0, 2.0), 0.80258),
        (statistics.NormalDist(0.0, 1.0), statistics.NormalDist(1.0, 2.0), 0.60993),
    ]:
        assert math.fabs(X1.overlap(X2) - published_result) &lt; PRECISION
        assert math.fabs(X2.overlap(X1) - published_result) &lt; PRECISION


test_overlap()


@test
def test_samples():
    mu, sigma = 10000.0, 3.0
    X = statistics.NormalDist(mu, sigma)
    n = 1000
    data = X.samples(n)
    assert len(data) == n


test_samples()


@test
def test_from_samples():
    data = [96.0, 107.0, 90.0, 92.0, 110.0]
    ND = statistics.NormalDist.from_samples(data)
    assert ND == statistics.NormalDist(99.0, 9.0)


test_from_samples()
</t>
<t tx="ekr.20230509083244.157">@path C:/Repos/codon/test/stdlib/
@language unknown_language
@test
def test_isdigit():
    assert "0".isdigit() == True
    assert "".isdigit() == False
    assert "a".isdigit() == False
    assert "2829357".isdigit() == True
    assert "kshfkjhe".isdigit() == False
    assert "9735g385497".isdigit() == False


@test
def test_islower():
    assert "".islower() == False
    assert "a".islower() == True
    assert "A".islower() == False
    assert "5".islower() == False
    assert "ahuiuej".islower() == True
    assert "AhUiUeJ".islower() == False
    assert "9735g385497".islower() == True
    assert "9735G385497".islower() == False


@test
def test_isupper():
    assert "".isupper() == False
    assert "a".isupper() == False
    assert "A".isupper() == True
    assert "5".isupper() == False
    assert ".J, U-I".isupper() == True
    assert "AHUIUEJ".isupper() == True
    assert "AhUiUeJ".isupper() == False
    assert "9735g385497".isupper() == False
    assert "9735G385497".isupper() == True


@test
def test_isalnum():
    assert "".isalnum() == False
    assert "a".isalnum() == True
    assert "5".isalnum() == True
    assert ",".isalnum() == False
    assert "H6".isalnum() == True
    assert ".J, U-I".isalnum() == False
    assert "A4kki83UE".isalnum() == True
    assert "AhUiUeJ".isalnum() == True
    assert "973 g38597".isalnum() == False
    assert "9735G3-5497".isalnum() == False


@test
def test_isalpha():
    assert "".isalpha() == False
    assert "a".isalpha() == True
    assert "5".isalpha() == False
    assert ",".isalpha() == False
    assert "Hh".isalpha() == True
    assert ".J, U-I".isalpha() == False
    assert "A4kki83UE".isalpha() == False
    assert "AhUiUeJ".isalpha() == True
    assert "973 g38597".isalpha() == False
    assert "9735G3-5497".isalpha() == False


@test
def test_isspace():
    assert "".isspace() == False
    assert " ".isspace() == True
    assert "5 ".isspace() == False
    assert "\t\n\r ".isspace() == True
    assert "\t ".isspace() == True
    assert "\t\ngh\r ".isspace() == False
    assert "A4kki 3UE".isspace() == False


@test
def test_istitle():
    assert "".istitle() == False
    assert " ".istitle() == False
    assert "I ".istitle() == True
    assert "IH".istitle() == False
    assert "Ih".istitle() == True
    assert "Hter Hewri".istitle() == True
    assert "Kweiur oiejf".istitle() == False


@test
def test_capitalize():
    assert " hello ".capitalize() == " hello "
    assert "Hello ".capitalize() == "Hello "
    assert "hello ".capitalize() == "Hello "
    assert "aaaa".capitalize() == "Aaaa"
    assert "AaAa".capitalize() == "Aaaa"


@test
def test_isdecimal():
    assert "".isdecimal() == False
    assert "a".isdecimal() == False
    assert "0".isdecimal() == True
    assert "\xbc".isdecimal() == False
    assert "0123456789".isdecimal() == True
    assert "0123456789a".isdecimal() == False


@test
def test_lower():
    assert "HeLLo".lower() == "hello"
    assert "hello".lower() == "hello"
    assert "HELLO".lower() == "hello"
    assert "HEL _ LO".lower() == "hel _ lo"


@test
def test_upper():
    assert "HeLLo".upper() == "HELLO"
    assert "hello".upper() == "HELLO"
    assert "HELLO".upper() == "HELLO"
    assert "HEL _ LO".upper() == "HEL _ LO"


@test
def test_isascii():
    assert "".isascii() == True
    assert "\x00".isascii() == True
    assert "\x7f".isascii() == True
    assert "\x00\x7f".isascii() == True
    assert "\x80".isascii() == False
    assert "".isascii() == False
    assert "\xe9".isascii() == False


@test
def test_casefold():
    assert "".casefold() == ""
    assert "HeLLo".casefold() == "hello"
    assert "hello".casefold() == "hello"
    assert "HELLO".casefold() == "hello"
    assert "HEL _ LO".casefold() == "hel _ lo"


@test
def test_swapcase():
    assert "".swapcase() == ""
    assert "HeLLo cOmpUteRs".swapcase() == "hEllO CoMPuTErS"
    assert "H.e_L,L-o cOmpUteRs".swapcase() == "h.E_l,l-O CoMPuTErS"


@test
def test_title():
    assert "".title() == ""
    assert " hello ".title() == " Hello "
    assert "hello ".title() == "Hello "
    assert "Hello ".title() == "Hello "
    assert "fOrMaT thIs aS titLe String".title() == "Format This As Title String"
    assert "fOrMaT,thIs-aS*titLe;String".title() == "Format,This-As*Title;String"
    assert "getInt".title() == "Getint"


@test
def test_isnumeric():
    assert "".isdecimal() == False
    assert "a".isdecimal() == False
    assert "0".isdecimal() == True
    assert "\xbc".isdecimal() == False
    assert "0123456789".isdecimal() == True
    assert "0123456789a".isdecimal() == False


@test
def test_ljust():
    assert "abc".ljust(10, " ") == "abc       "
    assert "abc".ljust(6, " ") == "abc   "
    assert "abc".ljust(3, " ") == "abc"
    assert "abc".ljust(2, " ") == "abc"
    assert "abc".ljust(10, "*") == "abc*******"


@test
def test_rjust():
    assert "abc".rjust(10, " ") == "       abc"
    assert "abc".rjust(6, " ") == "   abc"
    assert "abc".rjust(3, " ") == "abc"
    assert "abc".rjust(2, " ") == "abc"
    assert "abc".rjust(10, "*") == "*******abc"


@test
def test_center():
    assert "abc".center(10, " ") == "   abc    "
    assert "abc".center(6, " ") == " abc  "
    assert "abc".center(3, " ") == "abc"
    assert "abc".center(2, " ") == "abc"
    assert "abc".center(10, "*") == "***abc****"


@test
def test_zfill():
    assert "123".zfill(2) == "123"
    assert "123".zfill(3) == "123"
    assert "123".zfill(4) == "0123"
    assert "+123".zfill(3) == "+123"
    assert "+123".zfill(4) == "+123"
    assert "+123".zfill(5) == "+0123"
    assert "-123".zfill(3) == "-123"
    assert "-123".zfill(4) == "-123"
    assert "-123".zfill(5) == "-0123"
    assert "".zfill(3) == "000"
    assert "34".zfill(1) == "34"
    assert "34".zfill(4) == "0034"
    assert "1+2".zfill(5) == "001+2"
    assert "+".zfill(10) == "+000000000"
    assert "-".zfill(10) == "-000000000"


@test
def test_count():
    assert "aaa".count("a", 0, len("aaa")) == 3
    assert "aaa".count("b", 0, len("aaa")) == 0
    assert "aaa".count("a", 1, len("aaa")) == 2
    assert "aaa".count("a", 10, len("aaa")) == 0
    assert "aaa".count("a", -1, len("aaa")) == 1
    assert "aaa".count("a", 0, 1) == 1
    assert "aaa".count("a", 0, 10) == 3
    assert "aaa".count("a", 0, -1) == 2
    assert "aaa".count("aa") == 1
    assert "ababa".count("aba") == 1
    assert "abababa".count("aba") == 2
    assert "abababa".count("abab") == 1


@test
def test_find():
    assert "abcdefghiabc".find("abc", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".find("abc") == 0
    assert "abcdefghiabc".find("abc", 1, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".find("def", 4, len("abcdefghiabc")) == -1
    assert "abcdefghiabc".find("abcdef", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".find("abcdef") == 0
    assert "abcdefghiabc".find("hiabc", 1, len("abcdefghiabc")) == 7
    assert "abcdefghiabc".find("defgh", 4, len("abcdefghiabc")) == -1
    assert "rrarrrrrrrrra".find("a", 0, len("rrarrrrrrrrra")) == 2
    assert "rrarrrrrrrrra".find("a", 4, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".find("a", 4, 6) == -1
    assert "abc".find("", 0, len("abc")) == 0
    assert "abc".find("", 3, len("abc")) == 3
    assert "abc".find("", 4, len("abc")) == -1


@test
def test_rfind():
    assert "abcdefghiabc".rfind("abc", 0, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".rfind("", 0, len("abcdefghiabc")) == 12
    assert "abcdefghiabc".rfind("abcd", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".rfind("abcz", 0, len("abcdefghiabc")) == -1
    assert "abcdefghiabc".rfind("abc") == 9
    assert "abcdefghiabc".rfind("") == 12
    assert "abcdefghiabc".rfind("abcd") == 0
    assert "abcdefghiabc".rfind("abcz") == -1
    assert "rrarrrrrrrrra".rfind("a", 0, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rfind("a", 4, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rfind("a", 4, 6) == -1
    assert "abc".rfind("", 0, len("abc")) == 3
    assert "abc".rfind("", 3, len("abc")) == 3
    assert "abc".rfind("", 4, len("abc")) == -1


@test
def test_isidentifier():
    assert "a".isidentifier() == True
    assert "Z".isidentifier() == True
    assert "_".isidentifier() == True
    assert "b0".isidentifier() == True
    assert "bc".isidentifier() == True
    assert "b_".isidentifier() == True
    assert " ".isidentifier() == False
    assert "3t".isidentifier() == False
    assert "_gth_45".isidentifier() == True


@test
def test_isprintable():
    assert "".isprintable() == True
    assert '"'.isprintable() == True
    assert "'".isprintable() == True
    assert " ".isprintable() == True
    assert "abcdef".isprintable() == True
    assert "0123456789".isprintable() == True
    assert "ABCDEFGHIJKLMNOPQRSTUVWXYZ".isprintable() == True
    assert "abcdefghijklmnopqrstuvwxyz".isprintable() == True
    assert "!#$%&amp;()*+,-./:;?@[\\]^_`{|}~".isprintable() == True
    assert "abcdef\n".isprintable() == False


@test
def test_lstrip():
    assert "".lstrip() == ""
    assert "   ".lstrip() == ""
    assert "   hello   ".lstrip("") == "hello   "
    assert " \t\n\rabc \t\n\r".lstrip("") == "abc \t\n\r"
    assert "xyzzyhelloxyzzy".lstrip("xyz") == "helloxyzzy"


@test
def test_rstrip():
    assert "".rstrip() == ""
    assert "   ".rstrip() == ""
    assert "   hello   ".rstrip("") == "   hello"
    assert " \t\n\rabc \t\n\r".rstrip("") == " \t\n\rabc"
    assert "xyzzyhelloxyzzy".rstrip("xyz") == "xyzzyhello"


@test
def test_strip():
    assert "".strip() == ""
    assert "   ".strip() == ""
    assert "   hello   ".strip("") == "hello"
    assert "   hello   ".strip() == "hello"
    assert " \t\n\rabc \t\n\r".strip() == "abc"
    assert "xyzzyhelloxyzzy".strip("xyz") == "hello"
    assert "hello".strip("xyz") == "hello"
    assert "mississippi".strip("mississippi") == ""
    assert "mississippi".strip("i") == "mississipp"


@test
def test_partition():
    assert "hello".partition("l") == ("he", "l", "lo")
    assert "this is the partition method".partition("ti") == (
        "this is the par",
        "ti",
        "tion method",
    )
    assert "http://www.seq.org".partition("://") == ("http", "://", "www.seq.org")
    assert "http://www.seq.org".partition("?") == ("http://www.seq.org", "", "")
    assert "http://www.seq.org".partition("http://") == ("", "http://", "www.seq.org")
    assert "http://www.seq.org".partition("org") == ("http://www.seq.", "org", "")


@test
def test_rpartition():
    assert "hello".rpartition("l") == ("hel", "l", "o")
    assert "this is the rpartition method".rpartition("ti") == (
        "this is the rparti",
        "ti",
        "on method",
    )
    assert "http://www.seq.org".rpartition("://") == ("http", "://", "www.seq.org")
    assert "http://www.seq.org".rpartition("?") == ("", "", "http://www.seq.org")
    assert "http://www.seq.org".rpartition("http://") == ("", "http://", "www.seq.org")
    assert "http://www.seq.org".rpartition("org") == ("http://www.seq.", "org", "")


@test
def test_split():
    assert "  h    l \t\n l   o ".split() == ["h", "l", "l", "o"]
    assert "  h    l \t\n l   o ".split(None, 2) == ["h", "l", "l   o "]
    assert "  h    l \t\n l   o ".split(None, 0) == ["h    l \t\n l   o "]
    assert not "".split()
    assert not "   ".split()
    assert "h l l o".split(" ", -1) == ["h", "l", "l", "o"]
    assert "a|b|c|d".split("|", -1) == ["a", "b", "c", "d"]
    assert "h l l o".split(" ") == ["h", "l", "l", "o"]
    assert "a|b|c|d".split("|") == ["a", "b", "c", "d"]
    assert "a|b|c|d".split("|", 0) == ["a|b|c|d"]
    assert "abcd".split("|", -1) == ["abcd"]
    assert "".split("|", -1) == [""]
    assert "endcase |".split("|", -1) == ["endcase ", ""]
    assert "| startcase".split("|", -1) == ["", " startcase"]
    assert "|bothcase|".split("|", -1) == ["", "bothcase", ""]
    assert "abbbc".split("bb", -1) == ["a", "bc"]
    assert "aaa".split("aaa", -1) == ["", ""]
    assert "aaa".split("aaa", 0) == ["aaa"]
    assert "abbaab".split("ba", -1) == ["ab", "ab"]
    assert "aa".split("aaa", -1) == ["aa"]
    assert "Abbobbbobb".split("bbobb", -1) == ["A", "bobb"]
    assert "AbbobbBbbobb".split("bbobb", -1) == ["A", "B", ""]
    assert ("a|" * 20)[:-1].split("|", -1) == ["a"] * 20
    assert ("a|" * 20)[:-1].split("|", 15) == ["a"] * 15 + ["a|a|a|a|a"]
    assert "a|b|c|d".split("|", 1) == ["a", "b|c|d"]
    assert "a|b|c|d".split("|", 2) == ["a", "b", "c|d"]
    assert "a|b|c|d".split("|", 3) == ["a", "b", "c", "d"]
    assert "a|b|c|d".split("|", 4) == ["a", "b", "c", "d"]
    assert "a||b||c||d".split("|", 2) == ["a", "", "b||c||d"]


@test
def test_rsplit():
    assert "  h    l \t\n l   o ".rsplit() == ["h", "l", "l", "o"]
    assert "  h    l \t\n l   o ".rsplit(None, 2) == ["  h    l", "l", "o"]
    assert "  h    l \t\n l   o ".rsplit(None, 0) == ["  h    l \t\n l   o"]
    assert not "".rsplit()
    assert not "   ".rsplit()
    assert "a|b|c|d".rsplit("|", -1) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|") == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 1) == ["a|b|c", "d"]
    assert "a|b|c|d".rsplit("|", 2) == ["a|b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 3) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 4) == ["a", "b", "c", "d"]
    assert "a|b|c|d".rsplit("|", 0) == ["a|b|c|d"]
    assert "a||b||c||d".rsplit("|", 2) == ["a||b||c", "", "d"]
    assert "abcd".rsplit("|", -1) == ["abcd"]
    assert "".rsplit("|", -1) == [""]
    assert "endcase |".rsplit("|", -1) == ["endcase ", ""]
    assert "| startcase".rsplit("|", -1) == ["", " startcase"]
    assert "|bothcase|".rsplit("|", -1) == ["", "bothcase", ""]
    # assert 'a\x00\x00b\x00c\x00d'.rsplit('\x00', -1)
    assert "abbbc".rsplit("bb", -1) == ["ab", "c"]
    assert "aaa".rsplit("aaa", -1) == ["", ""]
    assert "aaa".rsplit("aaa", 0) == ["aaa"]
    assert "abbaab".rsplit("ba", -1) == ["ab", "ab"]
    assert "aa".rsplit("aaa", -1) == ["aa"]
    assert "bbobbbobbA".rsplit("bbobb", -1) == ["bbob", "A"]
    assert "bbobbBbbobbA".rsplit("bbobb", -1) == ["", "B", "A"]
    assert ("aBLAH" * 20)[:-4].rsplit("BLAH", -1) == ["a"] * 20
    assert ("a|" * 20)[:-1].rsplit("|", 15) == ["a|a|a|a|a"] + ["a"] * 15
    assert "a||b||c||d".rsplit("|", 2) == ["a||b||c", "", "d"]


@test
def test_splitlines():
    assert "\n\nasdf\nsadf\nsdf\n".splitlines(False) == ["", "", "asdf", "sadf", "sdf"]
    assert "\n\nasdf\nsadf\nsdf\n".splitlines() == ["", "", "asdf", "sadf", "sdf"]
    assert "abc\ndef\n\rghi".splitlines(False) == ["abc", "def", "", "ghi"]
    assert "abc\ndef\n\r\nghi".splitlines(False) == ["abc", "def", "", "ghi"]
    assert "abc\ndef\r\nghi".splitlines(False) == ["abc", "def", "ghi"]
    assert "abc\ndef\r\nghi\n".splitlines(False) == ["abc", "def", "ghi"]
    assert "abc\ndef\r\nghi\n\r".splitlines(False) == ["abc", "def", "ghi", ""]
    assert "\nabc\ndef\r\nghi\n\r".splitlines(False) == ["", "abc", "def", "ghi", ""]
    assert "\nabc\ndef\r\nghi\n\r".splitlines(True) == [
        "\n",
        "abc\n",
        "def\r\n",
        "ghi\n",
        "\r",
    ]
    assert "abc\ndef\r\nghi\n".splitlines(True) == ["abc\n", "def\r\n", "ghi\n"]


@test
def test_startswith():
    assert "hello".startswith("he", 0, len("hello")) == True
    assert "hello".startswith("hello", 0, len("hello")) == True
    assert "hello".startswith("hello world", 0, len("hello")) == False
    assert "hello".startswith("", 0, len("hello")) == True
    assert "hello".startswith("ello", 0, len("hello")) == False
    assert "hello".startswith("he") == True
    assert "hello".startswith("hello") == True
    assert "hello".startswith("hello world") == False
    assert "hello".startswith("") == True
    assert "hello".startswith("ello") == False
    assert "hello".startswith("ello", 1, len("hello")) == True
    assert "hello".startswith("o", 4, len("hello")) == True
    assert "hello".startswith("o", 5, len("hello")) == False
    assert "hello".startswith("lo", 3, len("hello")) == True
    assert "hello".startswith("", 5, len("hello")) == True
    assert "hello".startswith("lo", 6, len("hello")) == False
    assert "helloworld".startswith("lowo", 3, len("helloworld")) == True
    assert "helloworld".startswith("lowo", 3, 7) == True
    assert "helloworld".startswith("lowo", 3, 6) == False
    assert "".startswith("", 0, 1) == True
    assert "".startswith("", 0, 0) == True
    assert "".startswith("", 1, 0) == False
    assert "hello".startswith("he", 0, -1) == True
    assert "hello".startswith("hello", 0, -1) == False
    assert "hello".startswith("he", 0, -3) == True
    assert "hello".startswith("ello", -4, len("hello")) == True
    assert "hello".startswith("ello", -5, len("hello")) == False
    assert "hello".startswith("", -3, -3) == True
    assert "hello".startswith("o", -1, len("hello")) == True


@test
def test_endswith():
    assert "hello".endswith("lo", 0, len("hello")) == True
    assert "hello".endswith("he", 0, len("hello")) == False
    assert "hello".endswith("", 0, len("hello")) == True
    assert "hello".endswith("hello world", 0, len("hello")) == False
    assert "hello".endswith("lo") == True
    assert "hello".endswith("he") == False
    assert "hello".endswith("") == True
    assert "hello".endswith("hello world") == False
    assert "helloworld".endswith("worl", 0, len("hello")) == False
    assert "helloworld".endswith("worl", 3, 9) == True
    assert "helloworld".endswith("world", 3, 12) == True
    assert "helloworld".endswith("lowo", 1, 7) == True
    assert "helloworld".endswith("lowo", 2, 7) == True
    assert "helloworld".endswith("lowo", 3, 7) == True
    assert "helloworld".endswith("lowo", 4, 7) == False
    assert "helloworld".endswith("lowo", 3, 8) == False
    assert "ab".endswith("ab", 0, 1) == False
    assert "ab".endswith("ab", 0, 0) == False
    assert "".endswith("", 0, 1) == True
    assert "".endswith("", 0, 0) == True
    assert "".endswith("", 1, 0) == False
    assert "hello".endswith("lo", -2, len("hello")) == True
    assert "hello".endswith("he", -2, len("hello")) == False
    assert "hello".endswith("", -3, -3) == True
    assert "helloworld".endswith("worl", -6, len("helloworld")) == False
    assert "helloworld".endswith("worl", -5, -1) == True
    assert "helloworld".endswith("worl", -5, 9) == True
    assert "helloworld".endswith("world", -7, 12) == True
    assert "helloworld".endswith("lowo", -99, -3) == True
    assert "helloworld".endswith("lowo", -8, -3) == True
    assert "helloworld".endswith("lowo", -7, -3) == True
    assert "helloworld".endswith("lowo", 3, -4) == False
    assert "helloworld".endswith("lowo", -8, -2) == False


@test
def test_index():
    assert "abcdefghiabc".index("abc", 0, len("abcdefghiabc")) == 0
    assert "abcdefghiabc".index("abc") == 0
    assert "abcdefghiabc".index("abc", 1, len("abcdefghiabc")) == 9
    assert "abc".index("", 0, len("abc")) == 0
    assert "abc".index("", 3, len("abc")) == 3
    assert "rrarrrrrrrrra".index("a", 0, len("rrarrrrrrrrra")) == 2
    assert "rrarrrrrrrrra".index("a", 4, len("rrarrrrrrrrra")) == 12
    try:
        "abcdefghiabc".index("def", 4, len("abcdefghiabc"))
        assert False
    except ValueError:
        pass


@test
def test_rindex():
    assert "abcdefghiabc".rindex("", 0, len("abcdefghiabc")) == 12
    assert "abcdefghiabc".rindex("") == 12
    assert "abcdefghiabc".rindex("def", 0, len("abcdefghiabc")) == 3
    assert "abcdefghiabc".rindex("abc", 0, len("abcdefghiabc")) == 9
    assert "abcdefghiabc".rindex("abc", 0, -1) == 0
    assert "rrarrrrrrrrra".rindex("a", 0, len("rrarrrrrrrrra")) == 12
    assert "rrarrrrrrrrra".rindex("a", 4, len("rrarrrrrrrrra")) == 12
    try:
        "rrarrrrrrrrra".rindex("a", 4, 6)
        assert False
    except ValueError:
        pass


@test
def test_replace():
    # interleave-- default will be len(str) + 1
    assert "A".replace("", "", len("A") + 1) == "A"
    assert "A".replace("", "*", len("A") + 1) == "*A*"
    assert "A".replace("", "*1", len("A") + 1) == "*1A*1"
    assert "A".replace("", "*-#", len("A") + 1) == "*-#A*-#"
    assert "AA".replace("", "*-", len("AA") + 1) == "*-A*-A*-"
    assert "AA".replace("", "*-", -1) == "*-A*-A*-"
    assert "AA".replace("", "*-") == "*-A*-A*-"
    assert "AA".replace("", "*-", 4) == "*-A*-A*-"
    assert "AA".replace("", "*-", 3) == "*-A*-A*-"
    assert "AA".replace("", "*-", 2) == "*-A*-A"
    assert "AA".replace("", "*-", 1) == "*-AA"
    assert "AA".replace("", "*-", 0) == "AA"

    # substring deletion
    assert "A".replace("A", "", len("A") + 1) == ""
    assert "AAA".replace("A", "", len("AAA") + 1) == ""
    assert "AAA".replace("A", "", -1) == ""
    assert "AAA".replace("A", "") == ""
    assert "AAA".replace("A", "", 4) == ""
    assert "AAA".replace("A", "", 3) == ""
    assert "AAA".replace("A", "", 2) == "A"
    assert "AAA".replace("A", "", 1) == "AA"
    assert "AAA".replace("A", "", 0) == "AAA"
    assert "ABACADA".replace("A", "", len("ABACADA") + 1) == "BCD"
    assert "ABACADA".replace("A", "", -1) == "BCD"
    assert "ABACADA".replace("A", "", 5) == "BCD"
    assert "ABACADA".replace("A", "", 4) == "BCD"
    assert "ABACADA".replace("A", "", 3) == "BCDA"
    assert "ABACADA".replace("A", "", 2) == "BCADA"
    assert "ABACADA".replace("A", "", 1) == "BACADA"
    assert "ABACADA".replace("A", "", 0) == "ABACADA"
    assert "ABCAD".replace("A", "", len("ABCAD") + 1) == "BCD"
    assert "ABCADAA".replace("A", "", len("ABCADAA") + 1) == "BCD"
    assert "BCD".replace("A", "", len("BCD") + 1) == "BCD"
    assert ("^" + ("A" * 1000) + "^").replace("A", "", 999) == "^A^"
    assert "the".replace("the", "", len("the") + 1) == ""
    assert "theater".replace("the", "", len("theater") + 1) == "ater"
    assert "thethe".replace("the", "", len("thethe") + 1) == ""
    assert "thethethethe".replace("the", "", len("thethethethe") + 1) == ""
    assert "theatheatheathea".replace("the", "", len("theatheatheathea") + 1) == "aaaa"
    assert "that".replace("the", "", len("that") + 1) == "that"
    assert (
        "here and there".replace("the", "", len("here and there") + 1) == "here and re"
    )
    assert (
        "here and there and there".replace(
            "the", "", len("here and there and there") + 1
        )
        == "here and re and re"
    )
    assert "here and there and there".replace("the", "", -1) == "here and re and re"
    assert "here and there and there".replace("the", "", 3) == "here and re and re"
    assert "here and there and there".replace("the", "", 2) == "here and re and re"
    assert "here and there and there".replace("the", "", 1) == "here and re and there"
    assert (
        "here and there and there".replace("the", "", 0) == "here and there and there"
    )

    # substring replace in place
    assert (
        "Who goes there?".replace("o", "o", len("Who goes there?") + 1)
        == "Who goes there?"
    )
    assert (
        "Who goes there?".replace("o", "O", len("Who goes there?") + 1)
        == "WhO gOes there?"
    )
    assert "Who goes there?".replace("o", "O", -1) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 3) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 2) == "WhO gOes there?"
    assert "Who goes there?".replace("o", "O", 1) == "WhO goes there?"
    assert "Who goes there?".replace("o", "O", 0) == "Who goes there?"
    assert (
        "Who goes there?".replace("a", "q", len("Who goes there?") + 1)
        == "Who goes there?"
    )
    assert (
        "Who goes there?".replace("W", "w", len("Who goes there?") + 1)
        == "who goes there?"
    )
    assert (
        "WWho goes there?WW".replace("W", "w", len("WWho goes there?WW") + 1)
        == "wwho goes there?ww"
    )
    assert (
        "Who goes there?".replace("?", "!", len("Who goes there?") + 1)
        == "Who goes there!"
    )
    assert (
        "This is a tissue".replace("is", "**", len("This is a tissue") + 1)
        == "Th** ** a t**sue"
    )
    assert "This is a tissue".replace("is", "**", -1) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 4) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 3) == "Th** ** a t**sue"
    assert "This is a tissue".replace("is", "**", 2) == "Th** ** a tissue"
    assert "This is a tissue".replace("is", "**", 1) == "Th** is a tissue"
    assert "This is a tissue".replace("is", "**", 0) == "This is a tissue"
    assert "Reykjavik".replace("k", "KK", len("Reykjavik") + 1) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", -1) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", 2) == "ReyKKjaviKK"
    assert "Reykjavik".replace("k", "KK", 1) == "ReyKKjavik"
    assert "Reykjavik".replace("k", "KK", 0) == "Reykjavik"
    assert "A.B.C.".replace(".", "----", len("A.B.C.") + 1) == "A----B----C----"
    assert (
        "spam, spam, eggs and spam".replace(
            "spam", "ham", len("spam, spam, eggs and spam") + 1
        )
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", -1)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 4)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 3)
        == "ham, ham, eggs and ham"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 2)
        == "ham, ham, eggs and spam"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 1)
        == "ham, spam, eggs and spam"
    )
    assert (
        "spam, spam, eggs and spam".replace("spam", "ham", 0)
        == "spam, spam, eggs and spam"
    )


@test
def test_expandtabs():
    assert "abc\rab\tdef\ng\thi".expandtabs(8) == "abc\rab      def\ng       hi"
    assert "abc\rab\tdef\ng\thi".expandtabs(8) == "abc\rab      def\ng       hi"
    assert "abc\rab\tdef\ng\thi".expandtabs(4) == "abc\rab  def\ng   hi"
    assert "abc\r\nab\tdef\ng\thi".expandtabs(8) == "abc\r\nab      def\ng       hi"
    assert "abc\r\nab\tdef\ng\thi".expandtabs(4) == "abc\r\nab  def\ng   hi"
    assert "abc\r\nab\r\ndef\ng\r\nhi".expandtabs(4) == "abc\r\nab\r\ndef\ng\r\nhi"
    assert " \ta\n\tb".expandtabs(1) == "  a\n b"
    assert "\tdndhd\ty\ty\tyu\t".expandtabs(3) == "   dndhd y  y  yu "


@test
def test_translate():
    assert "I yor ge".translate({ord("g"): "w", ord("y"): "f"}) == "I for we"
    assert "abababc".translate({ord("a"): ""}) == "bbbc"
    assert "abababc".translate({ord("a"): "", ord("b"): "i"}) == "iiic"
    assert "abababc".translate({ord("a"): "", ord("b"): "i", ord("c"): "x"}) == "iiix"
    assert "abababc".translate({ord("a"): "", ord("b"): ""}) == "c"
    assert "xzx".translate({ord("z"): "yy"}) == "xyyx"
    assert "aaabbbccc".translate({ord("b"): Optional("XY"), ord("c"): None, ord("a"): Optional("")}) == "XYXYXY"

@test
def test_repr():
    assert repr("") == "''"
    assert repr("hello") == "'hello'"
    assert repr("     ") == "'     '"
    assert repr("\r\a\n\t") == "'\\r\\a\\n\\t'"


@test
def test_fstr():
    assert f"{2+2}" == "4"
    n = 42
    assert f"{n}{n}xx{n}" == "4242xx42"
    assert f"{n=}" == "n=42"
    assert f"hello {n=} world" == "hello n=42 world"


@test
def test_slice(
    s="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
    indices=(0, 1, 3, 41, 0xFFFFFFFFFFF, -1, -2, -37),
):
    for start in indices:
        for stop in indices:
            for step in indices[1:]:
                L = list(s)[start:stop:step]
                assert s[start:stop:step] == "".join(L)


@test
def test_join():
    assert "".join(str(a) for a in range(0)) == ""
    assert "".join(List[str]()) == ""
    assert "a".join(str(a) for a in range(0)) == ""
    assert "a".join(List[str]()) == ""
    assert "ab".join(str(a) for a in range(999, 1000)) == "999"
    assert "ab".join(["999"]) == "999"
    assert "xyz".join(str(a) for a in range(5)) == "0xyz1xyz2xyz3xyz4"
    assert "xyz".join(["00", "1", "22", "3", "44"]) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(iter(["00", "1", "22", "3", "44"])) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(["00", "1", "22", "3", "44"]) == "00xyz1xyz22xyz3xyz44"
    assert "xyz".join(iter(["00", "", "22", "3", ""])) == "00xyzxyz22xyz3xyz"


@test
def test_repr():
    s = (
        "\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
        "\x1a\x1b\x1c\x1d\x1e\x1f !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefg"
        "hijklmnopqrstuvwxyz{|}~\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91"
        "\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xff"
    )
    assert repr(s) == (
        "'\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\t\\n\\x0b\\x0c\\r\\x0e\\x0f\\x10\\x11"
        "\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\"#$%&amp;\\'()*+,"
        "-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\"
        "x7f\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\\x90"
        "\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\\xa0\\xff'"
    )
    assert repr("") == "''"
    assert repr('"') == "'\"'"
    assert repr("'") == '"\'"'
    assert repr("\"'") == "'\"\\''"


test_isdigit()
test_islower()
test_isupper()
test_isalnum()
test_isalpha()
test_isspace()
test_istitle()
test_capitalize()
test_isdecimal()
test_lower()
test_upper()
test_isascii()
test_casefold()
test_swapcase()
test_title()
test_isnumeric()
test_ljust()
test_rjust()
test_center()
test_zfill()
test_count()
test_find()
test_rfind()
test_isidentifier()
test_isprintable()
test_lstrip()
test_rstrip()
test_strip()
test_partition()
test_rpartition()
test_split()
test_rsplit()
test_splitlines()
test_startswith()
test_endswith()
test_index()
test_rindex()
test_replace()
test_expandtabs()
test_translate()
test_repr()
test_fstr()
test_slice()
test_join()
test_repr()
</t>
<t tx="ekr.20230509083244.158"></t>
<t tx="ekr.20230509083244.159">@path C:/Repos/codon/test/transform/
@language unknown_language
@tuple
class Vec[T]:
    x: T
    y: T

    @pure
    def __abs__(self):
        return ((self.x * self.x) + (self.y * self.y)) ** 0.5

    @pure
    @commutative
    @associative
    def __add__(self, other: Vec[T]):
        print 'vec add', self, other
        return Vec[T](self.x + other.x, self.y + other.y)

    @pure
    @commutative
    @associative
    def __add__(self, other: T):
        print 'vec add', self, other
        return Vec[T](self.x + other, self.y + other)

    @pure
    def __sub__(self, other: Vec[T]):
        print 'vec sub', self, other
        return Vec[T](self.x - other.x, self.y - other.y)

    @pure
    def __sub__(self, other: T):
        print 'vec sub', self, other
        return Vec[T](self.x - other, self.y - other)

    @pure
    @commutative
    @associative
    @distributive
    def __mul__(self, other: Vec[T]):
        print 'vec mul', self, other
        return Vec[T](self.x * other.x, self.y * other.y)

    @pure
    @commutative
    @associative
    @distributive
    def __mul__(self, other: T):
        print 'vec mul', self, other
        return Vec[T](self.x * other, self.y * other)

    @pure
    @commutative
    def __eq__(self, other: Vec[T]):
        print 'vec eq', self, other
        return abs(self) == abs(other)

    @pure
    @commutative
    def __ne__(self, other: Vec[T]):
        print 'vec ne', self, other
        return abs(self) != abs(other)

    @pure
    def __lt__(self, other: Vec[T]):
        print 'vec lt', self, other
        return abs(self) &lt; abs(other)

    @pure
    def __le__(self, other: Vec[T]):
        print 'vec le', self, other
        return abs(self) &lt;= abs(other)

    @pure
    def __gt__(self, other: Vec[T]):
        print 'vec gt', self, other
        return abs(self) &gt; abs(other)

    @pure
    def __ge__(self, other: Vec[T]):
        print 'vec ge', self, other
        return abs(self) &gt;= abs(other)

@test
def test_op_chain_canon():
    @pure
    def f(a): return a

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = a + f(b)  # -&gt; f(b) + a
    assert (c.x, c.y) == (4, 6)
    # EXPECT: vec add (x: 3, y: 4) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = Vec(5, 6)
    d = f(a + f(b) + f(f(c)))  # -&gt; f(f(f(c)) + f(b) + a)
    assert (d.x, d.y) == (9, 12)
    # EXPECT: vec add (x: 5, y: 6) (x: 3, y: 4)
    # EXPECT: vec add (x: 8, y: 10) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = Vec(5, 6)
    d = f(a + (f(b) + f(f(c))))  # -&gt; f(f(f(c)) + f(b) + a)
    assert (d.x, d.y) == (9, 12)
    # EXPECT: vec add (x: 5, y: 6) (x: 3, y: 4)
    # EXPECT: vec add (x: 8, y: 10) (x: 1, y: 2)

    a = Vec(1, 2)
    b = Vec(3, 4)
    c = a - f(b)  # -&gt; no change
    assert (c.x, c.y) == (-2, -2)
    # EXPECT: vec sub (x: 1, y: 2) (x: 3, y: 4)

    # don't canon float ops
    assert f(1e100) + f(f(-1e100)) + f(f(f(1.))) == 1.
test_op_chain_canon()

class C:
    n: int

    def __lt__(self: C, other: C):
        return self.n &lt; other.n

@test
def test_inequality_canon():
    @pure
    def f(a): return a

    a = Vec(1,1)
    b = Vec(2,2)

    assert not (f(a) == b)
    assert f(a) != b
    assert f(a) &lt; b
    assert f(a) &lt;= b
    assert not (f(a) &gt; b)
    assert not (f(a) &gt;= b)
    # EXPECT: vec eq (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec ne (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec lt (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec le (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec gt (x: 1, y: 1) (x: 2, y: 2)
    # EXPECT: vec ge (x: 1, y: 1) (x: 2, y: 2)

    assert not (a == f(b))
    assert a != f(b)
    assert a &lt; f(b)
    assert a &lt;= f(b)
    assert not (a &gt; f(b))
    assert not (a &gt;= f(b))
    # EXPECT: vec eq (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec ne (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec gt (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec ge (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec lt (x: 2, y: 2) (x: 1, y: 1)
    # EXPECT: vec le (x: 2, y: 2) (x: 1, y: 1)

    c1 = C(1)
    c2 = C(2)
    # ensure we don't use missing ops
    assert c1 &lt; f(c2)
test_inequality_canon()

@test
def test_add_mul_canon():
    @pure
    def f(a): return a

    a = Vec(1,1)
    b = Vec(2,2)
    c = Vec(3,3)
    d = (a*f(b) + c*a)  # -&gt; (f(b) + c) * a
    assert (d.x, d.y) == (5, 5)
    # EXPECT: vec add (x: 2, y: 2) (x: 3, y: 3)
    # EXPECT: vec mul (x: 5, y: 5) (x: 1, y: 1)

    d = (a + c*a)  # -&gt; (c + 1) * a
    assert (d.x, d.y) == (4, 4)
    # EXPECT: vec add (x: 3, y: 3) 1
    # EXPECT: vec mul (x: 4, y: 4) (x: 1, y: 1)

    d = (c*a + a)  # -&gt; (c + 1) * a
    assert (d.x, d.y) == (4, 4)
    # EXPECT: vec add (x: 3, y: 3) 1
    # EXPECT: vec mul (x: 4, y: 4) (x: 1, y: 1)

    a = Vec(1,1)
    b = a + a + a + a + a
    assert (b.x, b.y) == (5, 5)
    # EXPECT: vec mul (x: 1, y: 1) 5

    a = Vec(1,1)
    b = a + a*2 + a*3 + a*4 + a*5
    assert (b.x, b.y) == (15, 15)
    # EXPECT: vec mul (x: 1, y: 1) 15

    x = f(100.)  # don't distribute float ops
    assert (x * 0.1) + (x * 0.2) == 30.
test_add_mul_canon()
</t>
<t tx="ekr.20230509083244.16">int runInChildProcess() {
  assert(pipe(out_pipe) != -1);
  pid = fork();
  GC_atfork_prepare();
  assert(pid != -1);

  if (pid == 0) {
    GC_atfork_child();
    dup2(out_pipe[1], STDOUT_FILENO);
    close(out_pipe[0]);
    close(out_pipe[1]);

    auto file = getFilename(get&lt;0&gt;(GetParam()));
    bool debug = get&lt;1&gt;(GetParam());
    auto code = get&lt;3&gt;(GetParam());
    auto startLine = get&lt;4&gt;(GetParam());
    int testFlags = 1 + get&lt;5&gt;(GetParam());
    bool pyNumerics = get&lt;6&gt;(GetParam());

  @others
                     {capKey});

    llvm::cantFail(compiler-&gt;compile());
    compiler-&gt;getLLVMVisitor()-&gt;run({file});
    fflush(stdout);
    exit(EXIT_SUCCESS);
  } else {
    GC_atfork_parent();
    int status = -1;
    close(out_pipe[1]);
    assert(waitpid(pid, &amp;status, 0) == pid);
    read(out_pipe[0], buf.data(), buf.size() - 1);
    close(out_pipe[0]);
    return status;
  }
  return -1;
}
</t>
<t tx="ekr.20230509083244.160">@path C:/Repos/codon/test/transform/
@language unknown_language
class DummyDict[K, V]:
    def __getitem__(self, k: K):
        raise ValueError('failed')
        return V()
    def get(self, k: K, d: V):
        raise ValueError('failed')
        return V()
    def __setitem__(self, k: K, v: V):
        assert False
    def __dict_do_op_throws__[F, Z](self, key: K, other: Z, op: F):
        pass
    def __dict_do_op__[F, Z](self, key: K, other: Z, dflt: V, op: F):
        pass

class WrappedDict[K, V]:
    d: Dict[K,V]
    do_op_throws_count: int
    do_op_count: int

    def __init__(self):
        self.d = {}
        self.do_op_throws_count = 0
        self.do_op_count = 0
    def __getitem__(self, k: K):
        return self.d.__getitem__(k)
    def get(self, k: K, d: V):
        return self.d.get(k, d)
    def __setitem__(self, k: K, v: V):
        self.d.__setitem__(k, v)
    def setdefault(self, k: K, v: V):
        return self.d.setdefault(k, v)

    def __dict_do_op_throws__[F, Z](self, key: K, other: Z, op: F):
        self.do_op_throws_count += 1
        self.d.__dict_do_op_throws__(key, other, op)
    def __dict_do_op__[F, Z](self, key: K, other: Z, dflt: V, op: F):
        self.do_op_count += 1
        self.d.__dict_do_op__(key, other, dflt, op)

@test
def test_dict_op():
    x = DummyDict[int, int]()
    x[1] = x[1] + 1
    x[1] = x.get(1, 1) + 1
test_dict_op()

@test
def test_dict_do_not_op():
    x = DummyDict[int, int]()
    try:
        x[1] = x[2] + 1
    except ValueError:
        return
    assert False
test_dict_do_not_op()

@test
def test_wrapped_dict():
    def my_op(a, b):
        return a * b
    def my_op_throws(a, b):
        raise ValueError('my_op_throws')
        return a * b

    x = WrappedDict[str, float]()
    x['a'] = x.get('a', 0.0) + 1.0        # invokes opt (do_op_count)
    x['a'] = x['a'] * 2                   # invokes opt (do_op_throws_count)
    x['b'] = x.setdefault('b', 4.5) + 99  # no opt (no getitem/get)
    x['a'] += x['b']                      # invokes opt (do_op_throws_count)
    x['b'] = my_op(x['b'], 2.0)           # no opt (not a int/float method)
    foo = x['a']
    x['a'] = x['b'] + foo                 # no opt (different keys)

    try:
        x['c'] += 1.0                     # invokes opt (do_op_throws_count)
        assert False
    except KeyError:
        pass

    try:
        x['d'] = my_op_throws(x['d'], 2.0)  # no opt (not a int/float method)
        assert False
    except KeyError:
        pass

    try:
        x['d'] = my_op_throws(x.get('d', 111.0), 2.0)  # no opt (not a int/float method)
        assert False
    except ValueError:
        pass

    assert x.do_op_throws_count == 3
    assert x.do_op_count == 1
    assert x.d == {'a': 312.5, 'b': 207}
test_wrapped_dict()
</t>
<t tx="ekr.20230509083244.161">@path C:/Repos/codon/test/transform/
@language unknown_language
# entry point for validator
@nonpure
def expect_capture(return_captures: bool, extern_captures: bool, arg_captures):
    return False

g = [0]
h = ''

@nonpure
def make_sure_globals_arent_optd_out():
    g.append(1)
    print(h)

make_sure_globals_arent_optd_out()

@test
def test_1(a):
    global g
    g = a
    assert expect_capture(False, True, ())  # a
test_1([42])

@test
def test_2(a, b, c):
    x = c
    b[0] = a
    y = x
    assert expect_capture(False, False, (1,))  # a
    assert expect_capture(False, False, ())    # b
    assert expect_capture(False, False, ())    # c
test_2([42], [[1]], ['x'])

@test
def test_3(a):
    global g
    x = [1]
    p = __ptr__(x)
    p[0] = a
    q = p
    g = p[0]
    assert expect_capture(False, True, ())  # a
test_3([42])

@test
def test_4(a):
    global g
    v = [a]
    g = v[0]
    assert expect_capture(False, True, ())  # a
test_4([42])

@test
def test_5(a):
    global g
    v = [a]
    for i in v:
        g = i
    assert expect_capture(False, True, ())  # a
test_5([42])

@test
def test_6(a, b, c):
    a[0] = b
    c[0] = a
    assert expect_capture(False, False, (2,))    # a
    assert expect_capture(False, False, (0, 2))  # b
    assert expect_capture(False, False, ())      # c
test_6([[0]], [42], [[[0]]])

@test
def test_7(a, b, c):
    assert expect_capture(True, False, ())   # a
    assert expect_capture(False, False, ())  # b
    assert expect_capture(True, False, ())   # c
    return a if b else c
test_7([11], g, [22])

class X:
    v: List[List[int]]

@test
def test_8(a):
    x = X([])
    x.v.append(a)
    assert expect_capture(True, False, ())  # a
    return x
test_8([42])

@test
def test_9(a):
    a = [0]
    assert expect_capture(False, False, ())  # a
    return a
test_9([42])

@test
def test_10(a, b):
    if b:
        a = [0]
    assert expect_capture(True, False, ())   # a
    assert expect_capture(False, False, ())  # b
    return a
test_10([42], [99])

@test
def test_11(a):
    global g
    g = a
    assert expect_capture(True, True, ())  # a
    return g
test_11([42])

@test
def test_12(a, b):
    global g
    b[0] = a
    x = {2: b}
    y = [x]
    z = {'z': y}
    g = z['z'][0][2][0]
    assert expect_capture(True, True, (1,))  # a
    assert expect_capture(True, True, (0,))  # b
    return z
test_12([42], [[0]])

@test
def test_13(a, n):
    if n &gt; 0:
        test_13(a, n - 1)
    assert expect_capture(True, True, ())    # a
    assert expect_capture(False, False, ())  # b
    return a
test_13([42], 3)

@test
def test_14(a):
    def assign_global(a):
        global g
        g = a

    assign_global(a)
    assert expect_capture(True, True, ())  # a
    return g
test_14([42])

class A:
    a: Optional[A]

@test
def test_15(a, b):
    a.a = b
    b.a = a
    assert expect_capture(False, False, (1,))  # a
    assert expect_capture(False, False, (0,))  # b
test_15(A(None), A(None))

@test
def test_16(a, b):
    a.a = b
    b.a = a
    assert expect_capture(True, False, (1,))  # a
    assert expect_capture(True, False, (0,))  # b
    return a
test_16(A(None), A(None))

@test
def test_17(a):
    global h
    h = a[1:-1]
    assert expect_capture(True, True, ())  # a
    return a[2:-2]
test_17('hello world')

@test
def test_18(a, b):
    if a:
        x = (b, b)
        raise ValueError(x[len(b)])
    assert expect_capture(False, False, ())  # a
    assert expect_capture(False, True, ())   # b
test_18([0 for _ in range(0)], 'b')

def assign1(x, y):
    x[0] = y

@test
def test_19(a, b, cond, elem):
    assign1(a if cond else b, elem)
    assert expect_capture(False, False, ())     # a
    assert expect_capture(True, False, ())      # b
    assert expect_capture(False, False, ())     # cond
    assert expect_capture(True, False, (0, 1))  # elem
    return b
test_19(['a'], ['b'], [True], 'x')

@test
def test_20(x):
    a = ['']
    p = a
    p[0] = x
    assert expect_capture(True, False, ())  # x
    return a
test_20('x')

@test
def test_21(x):
    a = ''
    p = __ptr__(a)
    p[0] = x
    assert expect_capture(True, False, ())  # x
    return a
test_21('x')

class A:
    a: List[str]

@test
def test_22(x):
    a = ['']
    p = A([])
    p.a = a
    p.a[0] = x
    assert expect_capture(True, False, ())  # x
    return a
test_22('x')

def assign(p, a):
    p.a = a

def test_23(x):
    a = ['']
    p = A([])
    assign(p, a)
    p.a[0] = x
    assert expect_capture(True, False, ())  # x
    return a
test_23('x')

class S:
    s: str

@test
def test_24(a, b, cond):
    q = S('')
    if cond:
        q = a
    q.s = b
    assert expect_capture(False, False, ())    # a
    assert expect_capture(False, False, (0,))  # b
    assert expect_capture(False, False, ())    # cond
test_24(S('s'), 'b', True)

@test
def test_25(a, b, v):
    q = S('')
    for i in v:
        if i:
            q = a
        else:
            q = S('q')
    q.s = b
    assert expect_capture(False, False, ())    # a
    assert expect_capture(False, False, (0,))  # b
    assert expect_capture(False, False, ())    # v
test_25(S('s'), 'b', [0,1,0,1])

@test
def test_26(a, b, v):
    q = S('')
    for i in v:
        if i:
            q = a
        else:
            q.s = b
    return q
    assert expect_capture(True, False, ())    # a
    assert expect_capture(True, False, (0,))  # b
    assert expect_capture(False, False, ())   # v
    return q
test_26(S('s'), 'b', [0,1,0,1])

@test
def test_27(x):
    a = ''
    p = __ptr__(a)
    q = __ptr__(p)
    q[0][0] = x
    assert expect_capture(True, False, ())  # x
    return a
test_27('x')
</t>
<t tx="ekr.20230509083244.162">@path C:/Repos/codon/test/transform/
@language unknown_language
OP_COUNT = 0

@llvm
def inc(a: int) -&gt; int:
    %tmp = add i64 %a, 1
    ret i64 %tmp

class I:
    @llvm
    def __float__(self: int) -&gt; float:
        %tmp = sitofp i64 %self to double
        ret double %tmp

    @llvm
    def __bool__(self: int) -&gt; bool:
        %0 = icmp ne i64 %self, 0
        %1 = zext i1 %0 to i8
        ret i8 %1

    def __pos__(self: int) -&gt; int:
        return self

    def __neg__(self: int) -&gt; int:
        return I.__sub__(0, self)

    @llvm
    def __abs__(self: int) -&gt; int:
        %0 = icmp sgt i64 %self, 0
        %1 = sub i64 0, %self
        %2 = select i1 %0, i64 %self, i64 %1
        ret i64 %2

    @llvm
    def __lshift__(self: int, other: int) -&gt; int:
        %0 = shl i64 %self, %other
        ret i64 %0

    @llvm
    def __rshift__(self: int, other: int) -&gt; int:
        %0 = ashr i64 %self, %other
        ret i64 %0

    @llvm
    def __add__(self: int, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fadd double %0, %other
        ret double %1

    @llvm
    def __add__(self: int, b: int) -&gt; int:
        %tmp = add i64 %self, %b
        ret i64 %tmp

    @llvm
    def __sub__(self: int, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fsub double %0, %other
        ret double %1

    @llvm
    def __sub__(self: int, b: int) -&gt; int:
        %tmp = sub i64 %self, %b
        ret i64 %tmp

    @llvm
    def __mul__(self: int, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fmul double %0, %other
        ret double %1

    @llvm
    def __mul__(self: int, b: int) -&gt; int:
        %tmp = mul i64 %self, %b
        ret i64 %tmp

    @llvm
    def __floordiv__(self: int, other: float) -&gt; float:
        declare double @llvm.floor.f64(double)
        %0 = sitofp i64 %self to double
        %1 = fdiv double %0, %other
        %2 = call double @llvm.floor.f64(double %1)
        ret double %2

    @llvm
    def __floordiv__(self: int, b: int) -&gt; int:
        %tmp = sdiv i64 %self, %b
        ret i64 %tmp

    @llvm
    def __truediv__(self: int, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = fdiv double %0, %other
        ret double %1

    @llvm
    def __truediv__(self: int, other: int) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = sitofp i64 %other to double
        %2 = fdiv double %0, %1
        ret double %2

    @llvm
    def __mod__(self: int, other: float) -&gt; float:
        %0 = sitofp i64 %self to double
        %1 = frem double %0, %other
        ret double %1

    @llvm
    def __mod__(a: int, b: int) -&gt; int:
        %tmp = srem i64 %a, %b
        ret i64 %tmp

    @llvm
    def __invert__(a: int) -&gt; int:
        %tmp = xor i64 %a, -1
        ret i64 %tmp

    @llvm
    def __and__(a: int, b: int) -&gt; int:
        %tmp = and i64 %a, %b
        ret i64 %tmp

    @llvm
    def __or__(a: int, b: int) -&gt; int:
        %tmp = or i64 %a, %b
        ret i64 %tmp

    @llvm
    def __xor__(a: int, b: int) -&gt; int:
        %tmp = xor i64 %a, %b
        ret i64 %tmp

    @llvm
    def __shr__(a: int, b: int) -&gt; int:
        %tmp = ashr i64 %a, %b
        ret i64 %tmp

    @llvm
    def __shl__(a: int, b: int) -&gt; int:
        %tmp = shl i64 %a, %b
        ret i64 %tmp

    @llvm
    def __bitreverse__(a: int) -&gt; int:
        declare i64 @llvm.bitreverse.i64(i64 %a)
        %tmp = call i64 @llvm.bitreverse.i64(i64 %a)
        ret i64 %tmp

    @llvm
    def __bswap__(a: int) -&gt; int:
        declare i64 @llvm.bswap.i64(i64 %a)
        %tmp = call i64 @llvm.bswap.i64(i64 %a)
        ret i64 %tmp

    @llvm
    def __ctpop__(a: int) -&gt; int:
        declare i64 @llvm.ctpop.i64(i64 %a)
        %tmp = call i64 @llvm.ctpop.i64(i64 %a)
        ret i64 %tmp

    @llvm
    def __ctlz__(a: int) -&gt; int:
        declare i64 @llvm.ctlz.i64(i64 %a, i1 %is_zero_undef)
        %tmp = call i64 @llvm.ctlz.i64(i64 %a, i1 false)
        ret i64 %tmp

    @llvm
    def __cttz__(a: int) -&gt; int:
        declare i64 @llvm.cttz.i64(i64 %a, i1 %is_zero_undef)
        %tmp = call i64 @llvm.cttz.i64(i64 %a, i1 false)
        ret i64 %tmp

    @llvm
    def __eq__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp oeq double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __eq__(a: int, b: int) -&gt; bool:
        %tmp = icmp eq i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @llvm
    def __ne__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp one double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __ne__(a: int, b: int) -&gt; bool:
        %tmp = icmp ne i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @llvm
    def __lt__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp olt double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __lt__(a: int, b: int) -&gt; bool:
        %tmp = icmp slt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @llvm
    def __gt__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp ogt double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __gt__(a: int, b: int) -&gt; bool:
        %tmp = icmp sgt i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @llvm
    def __le__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp ole double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __le__(a: int, b: int) -&gt; bool:
        %tmp = icmp sle i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    @llvm
    def __ge__(self: int, b: float) -&gt; bool:
        %0 = sitofp i64 %self to double
        %1 = fcmp oge double %0, %b
        %2 = zext i1 %1 to i8
        ret i8 %2

    @llvm
    def __ge__(a: int, b: int) -&gt; bool:
        %tmp = icmp sge i64 %a, %b
        %res = zext i1 %tmp to i8
        ret i8 %res

    def __pow__(self: int, exp: float):
        return float(self) ** exp

    def __pow__(self: int, exp: int):
        if exp &lt; 0:
            return 0
        result = 1
        while True:
            if exp &amp; 1:
                result *= self
            exp &gt;&gt;= 1
            if not exp:
                break
            self *= self
        return result

@extend
class int:
    def __int__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return self

    def __float__(self) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__float__(self)

    def __bool__(self) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__bool__(self)

    def __pos__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return self

    def __neg__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__neg__(self)

    def __lshift__(self, other: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__lshift__(self, other)

    def __rshift__(self, other: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__rshift__(self, other)

    def __add__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__add__(self, other)

    def __add__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__add__(self, b)

    def __sub__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__sub__(self, other)

    def __sub__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__sub__(self, b)

    def __mul__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__mul__(self, other)

    def __mul__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__mul__(self, b)

    def __floordiv__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__floordiv__(self, other)

    def __floordiv__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__floordiv__(self, b)

    def __truediv__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__truediv__(self, other)

    def __truediv__(self, other: int) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__truediv__(self, other)

    def __mod__(self, other: float) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__mod__(self, other)

    def __mod__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__mod__(self, b)

    def __invert__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__invert__(self)

    def __and__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__and__(self, b)

    def __or__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__or__(self, b)

    def __xor__(self, b: int) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__xor__(self, b)

    def __eq__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__eq__(self, b)

    def __eq__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__eq__(self, b)

    def __ne__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__ne__(self, b)

    def __ne__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__ne__(self, b)

    def __lt__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__lt__(self, b)

    def __lt__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__lt__(self, b)

    def __gt__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__gt__(self, b)

    def __gt__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__gt__(self, b)

    def __le__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__le__(self, b)

    def __le__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__le__(self, b)

    def __ge__(self, b: float) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__ge__(self, b)

    def __ge__(self, b: int) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__ge__(self, b)

    def __pow__(self, exp: float):
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__pow__(self, exp)

    def __pow__(self, exp: int):
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return I.__pow__(self, exp)


class F:
    @llvm
    def __int__(self: float) -&gt; int:
        %0 = fptosi double %self to i64
        ret i64 %0

    def __float__(self: float):
        return self

    @llvm
    def __bool__(self: float) -&gt; bool:
        %0 = fcmp one double %self, 0.000000e+00
        %1 = zext i1 %0 to i8
        ret i8 %1

@extend
class float:
    def __int__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return F.__int__(self)

    def __float__(self) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return self

    def __bool__(self) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return F.__bool__(self)

@extend
class bool:
    def __int__(self) -&gt; int:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return 1 if self else 0

    def __float__(self) -&gt; float:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return 1. if self else 0.

    def __bool__(self) -&gt; bool:
        global OP_COUNT
        OP_COUNT = inc(OP_COUNT)
        return self

def eq(a: int, b: int) -&gt; bool:
    return I.__eq__(a, b)

@noinline
def foo(x):
  return x

@test
def test_int_simple_fold():
    op_count = OP_COUNT
    x = 1
    y = x + 2
    z = x + 3
    assert eq(foo(x + 1), 2)
    assert eq(foo(y * 2), 6)
    assert eq(foo(z // 3), 1)
    assert eq(foo(x &gt;&gt; 2), 0)
    assert eq(foo(x &lt;&lt; y), 8)
    assert eq(foo(x | y), 3)
    assert eq(foo(z &amp; z), 4)
    assert not foo(x &gt; y)
    assert foo(y &lt; z)
    assert not foo(x &gt;= z)
    assert foo(x &lt;= 2)
    assert foo(x == 1)
    assert foo(x != 2)
    assert eq(foo(y ** 3), 27)
    assert eq(foo(y ** 0), 1)
    assert eq(foo(y ** -1), 0)
    assert eq(op_count, OP_COUNT)
test_int_simple_fold()

@test
def test_ternary_fold():
    op_count = OP_COUNT
    x = 1
    y = x * 2
    assert (x + 1 if x != 0 else -1) &gt; 0
    assert (x + 1 if x == 0 else -1) &lt; 0
    assert eq(op_count, OP_COUNT)
test_ternary_fold()

@test
def test_try_catch_fold():
    op_count = OP_COUNT
    x = 0
    y = x + 1
    try:
        x = 1
    finally:
        x = 4
    assert x == 4
    assert eq(op_count, OP_COUNT)
test_try_catch_fold()

@test
def test_while_fold():
    op_count = OP_COUNT
    x = 0
    y = 1
    while (x != 0):
        y = 2
    assert y + 1 == 2
    assert eq(op_count, OP_COUNT)
test_while_fold()

@test
def test_imperative_for_fold():
    op_count = OP_COUNT
    foo = 2
    y = 1
    for i in range(foo, 2):
        y = foo - 1
    assert y == 1
    assert eq(op_count, OP_COUNT)
test_imperative_for_fold()

@test
def test_long_fold():
    op_count = OP_COUNT
    x = 3
    assert eq(foo(x + x + x + x + x + x + x + x + x + x + x + x), 36)
    assert eq(op_count, OP_COUNT)
test_long_fold()

@test
def test_conversions():
    op_count = OP_COUNT
    n = 42
    b = True
    x = 3.14

    assert eq(foo(n.__int__()), n)
    assert foo(n.__float__()) == 42.0
    assert foo(n.__bool__())

    assert eq(foo(b.__int__()), 1)
    assert foo(b.__float__()) == 1.0
    assert foo(b.__bool__())

    assert eq(foo(x.__int__()), 3)
    assert foo(x.__float__()) == x
    assert foo(x.__bool__())
    assert eq(op_count, OP_COUNT)
test_conversions()

@test
def test_no_ops():
    def v(): return 42
    op_count = OP_COUNT
    n = v()
    assert eq(+n, n)
    assert eq(-(-n), n)
    assert eq(~(~n), n)
    assert eq(op_count, OP_COUNT)
test_no_ops()

@test
def test_algebraic_simplification():
    def v(): return 42
    op_count = OP_COUNT
    n = v()
    assert eq(0*n, 0)
    assert eq(n*0, 0)
    assert eq(n*1, n)
    assert eq(1*n, n)
    assert eq(n+0, n)
    assert eq(0+n, n)
    assert eq(n-0, n)
    assert eq(0//n, 0)
    assert eq(op_count, OP_COUNT)
test_algebraic_simplification()

n = 42
@test
def test_global_fold():
    op_count = OP_COUNT
    m = 1
    assert eq(n + m, 43)
    assert eq(op_count, OP_COUNT)
test_global_fold()

# make sure globals fold properly with demotion
op_count1 = OP_COUNT
a = foo(42)
a = 42
b = a + 10
c = b
op_count2 = OP_COUNT

@test
def test_global_fold_non_const():
    op_count = OP_COUNT
    assert c == 52
    assert op_count1 == op_count2
test_global_fold_non_const()

some_global = 42
@test
def test_side_effect_analysis():
    @pure
    @test
    def foo():
        assert False
        return some_global

    def bar():
        a = 1
        b = 2
        c = 3
        return foo()

    def baz():
        global some_global
        some_global += 1
        return some_global

    def fab():
        return baz()

    foo()
    x = foo()
    bar()
    y = bar()
    assert baz() == 43
    baz()
    assert some_global == 44
    assert fab() == 45
    fab()
    assert some_global == 46
test_side_effect_analysis()
</t>
<t tx="ekr.20230509083244.163">@path C:/Repos/codon/test/transform/
@language unknown_language
@extend
class range:
    def __iter__(self):
        yield 999

@test
def test_for_lowering():
    from random import randint
    x = 10
    v = []
    for i in range(x):
        v.append(i)
    assert v == [0,1,2,3,4,5,6,7,8,9]

    v = []
    for i in range(x - 11, x//10):
        v.append(i)
    assert v == [-1, 0]

    v = []
    for i in range(x, -x):
        v.append(i)
    assert v == []

    v = []
    for i in range(x//3, -x//3, -2):
        v.append(i)
    assert v == [3, 1, -1]

    v = []
    for i in range(-1, 7, 3):
        v.append(i)
    assert v == [-1, 2, 5]

    v = []
    for i in range(0, 1, randint(1,1)):  # no lowering for non-const step
        v.append(i)
    assert v == [999]

    v = []
    try:
        for i in range(0, 1, 0):  # no lowering for zero step
            v.append(i)
        v.append(-1)
    except:
        v.append(-2)
    assert v == [-2]

    v = []
    for i in range(5):
        if i == 1:
            continue
        if i == 3:
            break
        v.append(i)
    assert v == [0, 2]

test_for_lowering()
</t>
<t tx="ekr.20230509083244.164">@path C:/Repos/codon/test/transform/
@language unknown_language
v = 1
v = 2

def inline_me_aggressive_simple():
  return 1

def inline_me_aggressive_complex():
  while True:
    if v == 1:
      return 1
    return 2

def inline_me_aggressive_args(x):
  return x + 1

def inline_me_simple():
  return 1

def inline_me_complex():
  while True:
    if v == 1:
      return 1
    return 2

def inline_me_args(x):
  return x + 1

@test
def inlining_test():
  assert inline_me_simple() == -1
  assert inline_me_complex() == 2
  assert inline_me_args(2) == -3
  assert inline_me_aggressive_simple() == -1
  assert inline_me_aggressive_complex() == -2
  assert inline_me_aggressive_args(2) == -3

inlining_test()

def inline_me_aggressive_nested_while_finally(n):
    while n != 0:
        try:
            while n != 0:
                if n == 42:
                    n -= 1
                    continue
                try:
                    if n &gt; 0:
                        continue
                    else:
                        break
                finally:
                    return -1
            return -2
        finally:
            return n + 1

def inline_test_nested_while_finally():
    a = 42
    checkpoint1 = False
    checkpoint2 = False
    checkpoint3 = False
    try:
        while a != 4:
            try:
                a = inline_me_aggressive_nested_while_finally(a)
                checkpoint1 = True
                assert a == -42
            finally:
                a = 4
            checkpoint2 = True
            assert a == 4
    finally:
        checkpoint3 = True
        assert a == 4
        a = 5
    assert a == 5
    assert checkpoint1
    assert checkpoint2
    assert checkpoint3

inline_test_nested_while_finally()
</t>
<t tx="ekr.20230509083244.165">@path C:/Repos/codon/test/transform/
@language unknown_language
class DummyFile:
    write_count: int = 0
    write_gen_count: int = 0

    def write(self, s: str):
        self.write_count += 1
    def __file_write_gen__(self, g):
        self.write_gen_count += 1

@test
def test_file_io():
    f = DummyFile()
    f.write('')                                     # opt not applied
    f.write('hello world')                          # opt not applied
    f.write(str.cat("hello ", "world"))             # opt applied
    a, b, c = 3.14, 'xyz', 42
    f.write(f'hello {a} world {b=} abc {a+c} zzz')  # opt applied
    f.write(f'hello world')                         # opt applied
    assert f.write_count == 2
    assert f.write_gen_count == 3
test_file_io()

@test
def test_print():
    from sys import stdout
    print('hello world')               # EXPECT: hello world
    print(str.cat("hello ", "world"))  # EXPECT: hello world
    a, b, c = 3.14, 'xyz', 42
    print(f'hello {a} world {b=} abc {a+c} zzz', file=stdout, sep='x')  # EXPECT: hello 3.14 world b=xyz abc 45.14 zzz
    print(f'hello', f'world', sep='x')  # EXPECT: helloxworld
test_print()
</t>
<t tx="ekr.20230509083244.166">@path C:/Repos/codon/test/transform/
@language unknown_language
import gpu

@test
def test_hello_world():
    @gpu.kernel
    def kernel(a, b, c):
        i = gpu.thread.x
        c[i] = a[i] + b[i]

    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]
    kernel(a, b, c, grid=1, block=16)

    assert c == [3*i for i in range(16)]

@test
def test_raw():
    @gpu.kernel
    def kernel(a, b, c):
        i = gpu.thread.x
        c[i] = a[i] + b[i]

    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]
    kernel(gpu.raw(a), gpu.raw(b), gpu.raw(c), grid=1, block=16)

    assert c == [3*i for i in range(16)]

@test
def test_conversions():
    @gpu.kernel
    def kernel(x, v):
        v[0] = x

    def check(x):
        T = type(x)
        v = [T()]
        kernel(x, v, grid=1, block=1)
        return v == [x]

    assert check(None)
    assert check(42)
    assert check(3.14)
    assert check(f32(2.718))
    assert check(byte(99))
    assert check(Int[128](123123))
    assert check(UInt[128](321321))
    assert check(Optional[int]())
    assert check(Optional(111))
    assert check((1, 2, 3))
    assert check(([1], [2], [3]))
    # assert check(())  # TODO: PTX can't handle this; why?
    assert check(DynamicTuple((1, 2, 3)))
    assert check(DynamicTuple(([1], [2], [3])))
    assert check(DynamicTuple[int]())
    assert check(DynamicTuple[List[List[List[str]]]]())
    assert check('hello world')
    assert check([1, 2, 3])
    assert check([[1], [2], [3]])
    assert check({1: [1.1], 2: [2.2]})
    assert check({'a', 'b', 'c'})
    assert check(Optional([1, 2, 3]))

@test
def test_user_classes():
    @dataclass(gpu=True, eq=True)
    class A:
       x: int
       y: List[int]

    @tuple
    class B:
        x: int
        y: List[int]

    @gpu.kernel
    def kernel(a, b, c):
        a.x += b.x + c[0]
        c[1][0][0] = 9999
        a.y[0] = c[0] + 1
        b.y[0] = c[0] + 2

    a = A(42, [-1])
    b = B(100, [-2])
    c = (1000, [[-1]])
    kernel(a, b, c, grid=1, block=1)

    assert a == A(1142, [1001])
    assert b == B(100, [1002])
    assert c == (1000, [[9999]])

    @gpu.kernel
    def kernel2(a, b, c):
        a[0].x += b[0].x + c[0][0]
        c[0][1][0][0] = 9999
        a[0].y[0] = c[0][0] + 1
        b[0].y[0] = c[0][0] + 2

    a = [A(42, [-1])]
    b = [B(100, [-2])]
    c = [(1000, [[-1]])]
    kernel2(a, b, c, grid=1, block=1)

    assert a == [A(1142, [1001])]
    assert b == [B(100, [1002])]
    assert c == [(1000, [[9999]])]

@test
def test_intrinsics():
    @gpu.kernel
    def kernel(v):
        block_id = (gpu.block.x + gpu.block.y*gpu.grid.dim.x +
                    gpu.block.z*gpu.grid.dim.x*gpu.grid.dim.y)
        thread_id = (block_id*gpu.block.dim.x*gpu.block.dim.y*gpu.block.dim.z +
                     gpu.thread.z*gpu.block.dim.x*gpu.block.dim.y +
                     gpu.thread.y*gpu.block.dim.x +
                     gpu.thread.x)
        v[thread_id] = thread_id
        gpu.syncthreads()

    grid = gpu.Dim3(3, 4, 5)
    block = gpu.Dim3(6, 7, 8)
    N = grid.x * grid.y * grid.z * block.x * block.y * block.z
    v = [0 for _ in range(N)]
    kernel(v, grid=grid, block=block)
    assert v == list(range(N))

@test
def test_matmul():
    A = [[12, 7, 3],
         [4, 5, 6],
         [7, 8, 9]]

    B = [[5, 8, 1, 2],
         [6, 7, 3, 0],
         [4, 5, 9, 1]]

    def mmz(A, B):
        return [[0]*len(B[0]) for _ in range(len(A))]

    def matmul(A, B):
        result = mmz(A, B)
        for i in range(len(A)):
            for j in range(len(B[0])):
                for k in range(len(B)):
                    result[i][j] += A[i][k] * B[k][j]
        return result

    expected = matmul(A, B)

    @gpu.kernel
    def kernel(A, B, result):
        i = gpu.thread.x
        j = gpu.thread.y
        result[i][j] = sum(A[i][k]*B[k][j] for k in range(len(A[0])))

    result = mmz(A, B)
    kernel(A, B, result, grid=1, block=(len(result), len(result[0])))
    assert result == expected

MAX    = 1000  # maximum Mandelbrot iterations
N      = 256   # width and height of image

@test
def test_mandelbrot():
    pixels = [0 for _ in range(N * N)]

    def scale(x, a, b):
        return a + (x/N)*(b - a)

    expected = [0 for _ in range(N * N)]
    for i in range(N):
        for j in range(N):
            c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
            z = 0j
            iteration = 0

            while abs(z) &lt;= 2 and iteration &lt; MAX:
                z = z**2 + c
                iteration += 1

            expected[N*i + j] = int(255 * iteration/MAX)

    @gpu.kernel
    def kernel(pixels):
        idx = (gpu.block.x * gpu.block.dim.x) + gpu.thread.x
        i, j = divmod(idx, N)
        c = complex(scale(j, -2.00, 0.47), scale(i, -1.12, 1.12))
        z = 0j
        iteration = 0

        while abs(z) &lt;= 2 and iteration &lt; MAX:
            z = z**2 + c
            iteration += 1

        pixels[idx] = int(255 * iteration/MAX)

    kernel(pixels, grid=(N*N)//1024, block=1024)
    assert pixels == expected

@test
def test_kitchen_sink():
    @gpu.kernel
    def kernel(x):
        i = gpu.thread.x
        d = {1: 2.1, 2: 3.5, 3: 4.2}
        s = {4, 5, 6}
        z = sum(
            d.get(x[i], j) + (j if i in s else -j)
            for j in range(i)
        )
        x[i] = int(z)

    x = [i for i in range(16)]
    kernel(x, grid=1, block=16)
    assert x == [0, 2, 6, 9, 12, 20, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0]

@test
def test_auto_par():
    a = [i for i in range(16)]
    b = [2*i for i in range(16)]
    c = [0 for _ in range(16)]

    @par(gpu=True)
    for i in range(16):
        c[i] = a[i] + b[i]

    assert c == [3*i for i in range(16)]

    @par(gpu=True)
    for i in range(16):
        c[i] += a[i] + b[i]

    assert c == [6*i for i in range(16)]

    N = 200
    Z = 42
    x = [0] * (N*N)
    y = [0] * (N*N)

    for i in range(2, N - 1, 3):
        for j in range(3, N, 2):
            x[i*N + j] = i + j + Z

    @par(gpu=True, collapse=2)
    for i in range(2, N - 1, 3):
        for j in range(3, N, 2):
            y[i*N + j] = i + j + Z

    assert x == y

    @par(gpu=True)
    for i in range(1):
        pass

test_hello_world()
test_raw()
test_conversions()
test_user_classes()
test_intrinsics()
test_matmul()
test_mandelbrot()
test_kitchen_sink()
test_auto_par()
</t>
<t tx="ekr.20230509083244.167">@path C:/Repos/codon/test/transform/
@language unknown_language
add_count = 0

@extend
class List:
    def __add__(self, other: List[T]) -&gt; List[T]:
        global add_count
        add_count += 1
        n = self.len + other.len
        v = List[T](n)
        v.len = n
        p = v.arr.ptr
        str.memcpy(p.as_byte(),
                   self.arr.ptr.as_byte(),
                   self.len * gc.sizeof(T))
        str.memcpy((p + self.len).as_byte(),
                   other.arr.ptr.as_byte(),
                   other.len * gc.sizeof(T))
        return v

@test
def test_list_optimization():
    add_count0 = add_count
    A = list(range(3))
    B = list(range(10))
    assert [0] + [1] == [0, 1]
    assert A + B == [0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    assert (A + B[:] + B[7:] + B[:3] + B[3:7] + B[7:3:-1] + A[::-1] + [11, 22, 33] ==
            [0, 1, 2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 2, 1, 0, 11, 22, 33])

    def f(a, tag, order):
        order.append(tag)
        return a

    order = []
    X = (f([1, 2], 'a', order) +
         [f(3, 'b', order), f(4, 'c', order)] +
         f(list(range(10)), 'd', order)[f(5, 'e', order):f(2, 'f', order):f(-1, 'g', order)])
    assert X == [1, 2, 3, 4, 5, 4, 3]
    assert order == ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    assert add_count == add_count0

test_list_optimization()
</t>
<t tx="ekr.20230509083244.168">@path C:/Repos/codon/test/transform/
@language unknown_language
import openmp as omp
import threading as thr

lock = thr.Lock()

@tuple
class A:
    n: int

    def __new__() -&gt; A:
        return A(0)

    def __add__(self, other: A):
        return A(self.n + other.n)

    def __atomic_add__(a: Ptr[A], other: A):
        with lock:
            a[0] = A(a[0].n + other.n)

@test
def test_omp_api():
    thr.active_count()
    thr.get_native_id()
    omp.set_num_threads(4)
    omp.get_num_threads()
    omp.get_max_threads()
    omp.get_thread_num()
    omp.get_num_procs()
    omp.in_parallel()
    omp.set_dynamic(False)
    omp.get_dynamic()
    omp.get_cancellation()
    omp.set_schedule('static', 10)
    omp.get_schedule()
    omp.get_thread_limit()
    omp.set_max_active_levels(1)
    omp.get_max_active_levels()
    omp.get_level()
    omp.get_ancestor_thread_num(0)
    omp.get_team_size(0)
    omp.get_active_level()
    omp.in_final()
    omp.get_proc_bind()
    omp.set_default_device(0)
    omp.get_default_device()
    omp.get_num_devices()
    omp.get_num_teams()
    omp.get_team_num()
    omp.is_initial_device()
    omp.get_wtime()
    omp.get_wtick()

@test
def test_omp_schedules():
    omp.set_num_threads(4)
    N = 10001

    x = list(range(N))
    y = [0] * N
    @par
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static')
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    chunk = 13
    @par(schedule='static', chunk_size=chunk)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N-1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='static', chunk_size=N+1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic')
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    chunk = 17
    @par(schedule='dynamic', chunk_size=chunk)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N-1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

    x = list(range(N))
    y = [0] * N
    @par(schedule='dynamic', chunk_size=N+1)
    for i in range(N):
        y[i] = x[i] ** 2
    assert all(y[i] == x[i]**2 for i in range(N))

@test
def test_omp_ranges():
    nt = 4
    lock = thr.Lock()
    seen = set()

    @omp.critical
    def add(seen, i):
        seen.add(i)

    @par
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(chunk_size=12)
    for i in range(3, 123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(chunk_size=12)
    for i in range(-3, -123, 7):
        add(seen, i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(chunk_size=12, num_threads=nt)
    for i in range(-3, -123, -7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(chunk_size=10000)
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(chunk_size=10000)
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(chunk_size=10000, num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(schedule='dynamic', num_threads=nt)
    for i in range(-3, -123, -7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12)
    for i in range(3, 123, 7):
        add(seen, i)
    assert seen == set(range(3, 123, 7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12)
    for i in range(-3, -123, 7):
        with lock:
            seen.add(i)
    assert seen == set(range(-3, -123, 7))
    seen.clear()

    @par(schedule='dynamic', chunk_size=12, num_threads=nt)
    for i in range(-3, -123, -7):
        add(seen, i)
    assert seen == set(range(-3, -123, -7))
    seen.clear()

my_global = 42

class Vector:
    x: float
    y: float

    def __init__(self):
        self.x = 0.0
        self.y = 0.0

    def __add__(self, other: Vector):
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):
        return f'&lt;{self.x}, {self.y}&gt;'

@test
def test_omp_reductions():
    def expected(N, a, op):
        for i in range(N):
            a = op(a, type(a)(i))
        return a

    from math import inf
    omp.set_num_threads(4)
    N = 10001
    L = list(range(N))

    # static
    a = 0
    @par
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par
    for i in L:
        a *= i
    assert a == expected(N, 1, int.__mul__)

    a = 0
    @par
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # static chunked
    a = 0
    @par(chunk_size=3)
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par(chunk_size=3)
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par(chunk_size=3)
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par(chunk_size=3)
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par(chunk_size=3)
    for i in L[1:10]:
        a *= i
    assert a == 1*2*3*4*5*6*7*8*9

    a = 0
    @par(chunk_size=3)
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par(chunk_size=3)
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par(chunk_size=3)
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # dynamic
    a = 0
    @par(schedule='dynamic')
    for i in L:
        a += i
    assert a == expected(N, 0, int.__add__)

    a = 0
    @par(schedule='dynamic')
    for i in L:
        a |= i
    assert a == expected(N, 0, int.__or__)

    a = 0
    @par(schedule='dynamic')
    for i in L:
        a ^= i
    assert a == expected(N, 0, int.__xor__)

    a = 0xffffffff
    @par(schedule='dynamic')
    for i in L:
        a &amp;= i
    assert a == expected(N, 0xffffffff, int.__and__)

    a = 1
    @par(schedule='dynamic')
    for i in L[1:10]:
        a *= i
    assert a == 1*2*3*4*5*6*7*8*9

    a = 0
    @par(schedule='dynamic')
    for i in L:
        b = N+1 if i == N//2 else i
        a = max(a, b)
    assert a == N+1

    a = 0
    @par(schedule='dynamic')
    for i in L:
        b = -1 if i == N//2 else i
        a = min(a, b)
    assert a == -1

    x = A(0)
    @par(schedule='dynamic')
    for i in L:
        x += A(i)
    assert x.n == expected(N, 0, int.__add__)

    # floats
    c = 0.
    @par
    for i in L:
        c += float(i)
    assert c == expected(N, 0., float.__add__)

    c = 1.
    @par
    for i in L[1:10]:
        c *= float(i)
    assert c == float(1*2*3*4*5*6*7*8*9)

    c = 0.
    @par
    for i in L:
        b = float(N+1 if i == N//2 else i)
        c = max(b, c)
    assert c == float(N+1)

    c = 0.
    @par
    for i in L:
        b = float(-1 if i == N//2 else i)
        c = min(b, c)
    assert c == -1.

    # float32s
    c = f32(0.)
    # this one can give different results due to
    # non-commutativity of floats; so limit to 1001
    @par
    for i in L[1:1001]:
        c += f32(i)
    assert c == sum((f32(i) for i in range(1001)), f32(0))

    c = f32(1.)
    @par
    for i in L[1:10]:
        c *= f32(i)
    assert c == f32(1*2*3*4*5*6*7*8*9)

    c = f32(0.)
    @par
    for i in L:
        b = f32(N+1 if i == N//2 else i)
        c = max(b, c)
    assert c == f32(N+1)

    c = f32(0.)
    @par
    for i in L:
        b = f32(-1 if i == N//2 else i)
        c = min(b, c)
    assert c == f32(-1.)

    x_add = 10.
    x_min = inf
    x_max = -inf
    @par
    for i in L:
        x_i = float(i)
        x_add += x_i
        x_min = min(x_min, x_i)
        x_max = max(x_i, x_max)
    assert x_add == expected(N, 10., float.__add__)
    assert x_min == expected(N, inf, min)
    assert x_max == expected(N, -inf, max)

    x_mul = 2.
    @par
    for i in L[:10]:
        x_i = float(i)
        x_mul *= x_i
    assert x_mul == expected(10, 2., float.__mul__)

    # multiple reductions
    global my_global
    g = my_global
    a = 0
    b = 0
    @par(schedule='dynamic', num_threads=3)
    for i in L:
        a += i
        b ^= i
        my_global += i
    assert a == expected(N, 0, int.__add__)
    assert b == expected(N, 0, int.__xor__)
    assert my_global == g + expected(N, 0, int.__add__)

    # custom reductions
    vectors = [Vector(i, i) for i in range(10)]
    v = Vector()
    @par
    for vv in vectors:
        v += vv
    assert v.x == 45.0
    assert v.y == 45.0

another_global = 0
@test
def test_omp_critical():
    @omp.critical
    def foo(i):
        global another_global
        another_global += i

    @omp.critical
    def bar(i):
        global another_global
        another_global += i

    global another_global
    for n in (99999, 100000, 100001):
        another_global = 0
        @par(schedule='dynamic')
        for i in range(n):
            foo(i)
            bar(i)
        assert another_global == 2*sum(range(n))

@test
def test_omp_non_imperative():
    def squares(N):
        for i in range(N):
            yield i*i

    N = 10001
    v = [0] * N

    @par
    for i,s in enumerate(squares(N)):
        v[i] = s

    assert all(s == i*i for i,s in enumerate(v))

test_generator_based_loops_global = 0.7

@test
def test_omp_non_imperative_reductions():
    def squares(n):
        for i in range(n):
            yield i*i

    @omp.critical
    def add(v, x):
        v.add(x)

    @nonpure
    def foo(x):
        return x

    global test_generator_based_loops_global
    N = 1001

    # no reductions
    v = set()
    @par
    for i in squares(N):
        x = i - 1
        add(v, x)
    assert v == {i**2 - 1 for i in range(N)}

    # one reduction
    a = 0
    @par
    for i in squares(N):
        a += i
    assert a == 333833500

    # kitchen sink
    a = 7
    b = 0
    c = 0.5
    d = foo(0)
    e = foo(1)
    f = foo(-1)
    g = -1
    h = Vector(1.5, 1.25)
    @par
    for i in squares(N):
        x = foo(i) + d
        y = foo(x) + e + f
        a = x + a + d
        b ^= y - d
        c += x + d
        test_generator_based_loops_global += y - d
        f = foo(-1)
        g = max(i, g)
        h += Vector(i, i)
    assert a == 333833507
    assert b == 332752
    assert c == 333833500.5
    assert test_generator_based_loops_global == 333833500.7
    assert g == (N - 1) ** 2
    assert h.x == 333833501.5
    assert h.y == 333833501.25

@test
def test_omp_transform(a, b, c):
    a0, b0, c0 = a, b, c
    d = a + b + c
    v = list(range(int(d*d)))
    ids = set()

    @par('schedule(static, 5) num_threads(3) ordered')
    for i in v:
        a += type(a)(i)
        z = i * i
        c = type(c)(z)
        b += type(b)(z)
        with lock:
            ids.add(omp.get_thread_num())

    for i in v:
        a0 += type(a0)(i)
        z = i * i
        c0 = type(c0)(z)
        b0 += type(b0)(z)

    assert ids == {0, 1, 2}
    assert int(a) == int(a0)
    assert abs(b - b0) &lt; b/1e6
    assert c == v[-1] ** 2

@test
def test_omp_nested():
    def squares(n):
        for i in range(n):
            yield i*i

    N = 100
    v = []

    v.clear()
    @par
    for i in range(N):
        @par
        for j in range(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in range(N) for j in range(i)}

    v.clear()
    @par
    for i in range(N):
        @par
        for j in squares(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in range(N) for j in squares(i)}

    v.clear()
    @par
    for i in squares(N):
        @par
        for j in range(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in squares(N) for j in range(i)}

    v.clear()
    @par
    for i in squares(N):
        @par
        for j in squares(i):
            with lock:
                v.append(i + j)
    assert set(v) == {i + j for i in squares(N) for j in squares(i)}

@test
def test_omp_corner_cases():
    def squares(n):
        for i in range(n):
            yield i*i

    @nonpure
    def foo(x):
        return x

    v = list(range(10))

    @par
    for i in range(10):
        pass

    @par
    for i in v:
        pass

    @par(num_threads=2)
    for i in range(10):
        pass

    @par(schedule='dynamic')
    for i in range(10):
        pass

    @par(num_threads=2, schedule='dynamic')
    for i in range(10):
        pass

    @par
    for i in squares(10):
        pass

    @par(num_threads=2)
    for i in squares(10):
        pass

    @par
    for i in range(10):
        foo(i)

    @par
    for i in squares(10):
        foo(i)

    @par
    for i in range(10):
        a = foo(i)

    @par
    for i in squares(10):
        a = foo(i)

    @par
    for i in range(10):
        i += i

    @par
    for i in squares(10):
        i += i

@test
def test_omp_collapse():
    # trivial
    A0 = []
    B0 = []

    for i in range(10):
        A0.append(i)

    @par(num_threads=4, collapse=1)
    for i in range(10):
        with lock:
            B0.append(i)

    assert sorted(A0) == sorted(B0)

    # basic
    A1 = []
    B1 = []

    for i in range(10):
        for j in range(10):
            A1.append((i,j))

    @par(num_threads=4, collapse=2)
    for i in range(10):
        for j in range(10):
            with lock:
                B1.append((i,j))

    assert sorted(A1) == sorted(B1)

    # deep
    A2 = []
    B2 = []

    for a in range(3):
        for b in range(4):
            for c in range(5):
                for d in range(6):
                    A2.append((a,b,c,d))

    @par(num_threads=4, collapse=4)
    for a in range(3):
        for b in range(4):
            for c in range(5):
                for d in range(6):
                    with lock:
                        B2.append((a,b,c,d))

    assert sorted(A2) == sorted(B2)

    # ranges 1
    A3 = []
    B3 = []

    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    A3.append((a,b,c,d))

    @par(num_threads=4, collapse=4)
    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    with lock:
                        B3.append((a,b,c,d))

    assert sorted(A3) == sorted(B3)

    # ranges 2
    A4 = []
    B4 = []

    for i in range(10):
        for j in range(7,-5,-2):
            for k in range(-5,10,3):
                A4.append((i,j,k))

    @par(num_threads=4, collapse=3)
    for i in range(10):
        for j in range(7,-5,-2):
            for k in range(-5,10,3):
                with lock:
                    B4.append((i,j,k))

    assert sorted(A4) == sorted(B4)

    # zero
    B5 = []

    @noinline
    def zstart():
        return 5

    @noinline
    def zstop():
        return -5

    start = zstart()
    stop = zstop()

    @par(num_threads=4, collapse=3)
    for i in range(10):
        for j in range(start, stop, 1):
            for k in range(-5,10,3):
                with lock:
                    B5.append((i,j,k))

    assert len(B5) == 0

    # order
    A6 = []
    B6 = []

    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    A6.append((a,b,c,d))

    @par(num_threads=1, collapse=4)
    for a in range(-5,5,2):
        for b in range(5,-7,-2):
            for c in range(0,17,3):
                for d in range(5):
                    B6.append((a,b,c,d))  # no lock since threads=1

    assert A6 == B6

test_omp_api()
test_omp_schedules()
test_omp_ranges()
test_omp_reductions()
test_omp_critical()
test_omp_non_imperative()
test_omp_non_imperative_reductions()
test_omp_transform(111, 222, 333)
test_omp_transform(111.1, 222.2, 333.3)
test_omp_nested()
test_omp_corner_cases()
test_omp_collapse()
</t>
<t tx="ekr.20230509083244.169">@path C:/Repos/codon/test/transform/
@language unknown_language
@nonpure
def __outline_begin__():
    pass

@nonpure
def __outline_end__():
    pass

@nonpure
def __outline_successes__():
    return 0

@nonpure
def __outline_failures__():
    return 0

# use this to avoid const-folding
def N(n):
    return n

@test
def test_basic_outline():
    __outline_begin__()
    print 'hello world'
    __outline_end__()
test_basic_outline()
# EXPECT: hello world

@test
def test_private_vars_outline(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    print a + 1
    a = N(99)
    __outline_end__()
    b = N(13)
test_private_vars_outline('x')
# EXPECT: 43

@test
def test_shared_vars_outline(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    print a + b + x
    a = N(99)
    y = N(-42)
    __outline_end__()
    b = N(13)
    print a
    print b
    print y
test_shared_vars_outline(100)
# EXPECT: 152
# EXPECT: 99
# EXPECT: 13
# EXPECT: -42

f = 'f'
@test
def test_shared_vars_with_mod_outline(x):
    global f
    b = N(10)
    f = 'o'
    __outline_begin__()
    for i in range(1):
        a = N(42)
        print a + b + x
        a = N(99)
        x = N(-5)
        f = str(i)
    __outline_end__()
    b = N(13)
    print b, x
test_shared_vars_with_mod_outline(100)
print f
# EXPECT: 152
# EXPECT: 13 -5
# EXPECT: 0

g = 'g'
@test
def test_out_flow_return_outline(x):
    global g
    b = N(10)
    g = 'o'
    __outline_begin__()
    for i in range(1):
        a = N(42)
        print a + b + x
        a = N(99)
        x = N(-5)
        g = str(i)
        return a
        break
    __outline_end__()
    assert False
test_out_flow_return_outline(100)
print g
# EXPECT: 152
# EXPECT: 0

h = 'h'
@test
def test_out_flow_break_continue_outline(x):
    global h
    b = N(10)
    h = 'o'
    for i in range(3):
        __outline_begin__()
        if i == 0:
            continue
        if i == 2:
            break
        for j in range(2):
            if j == 0:
                continue

            a = N(42)
            print a + b + x + j
            a = N(99)
            x = N(-5)
            h = str(i)
            break
        __outline_end__()
    b = N(13)
    print b, x
test_out_flow_break_continue_outline(100)
print h
# EXPECT: 153
# EXPECT: 13 -5
# EXPECT: 1

@test
def test_generator_return_outline(x):
    for i in range(x):
        yield i
        __outline_begin__()
        if i == 2:
            continue
        if i == 4:
            return
        __outline_end__()
        yield i
print list(test_generator_return_outline(10))
# EXPECT: [0, 0, 1, 1, 2, 3, 3, 4]

@test
def test_normal_return_outline(x):
    for i in range(x):
        yield i
        __outline_begin__()
        if i == 2:
            continue
        if i == 4:
            return
        __outline_end__()
        yield i
print list(test_normal_return_outline(1))
# EXPECT: [0, 0]

@test
def test_invalid_outline_yield(x):
    b = N(10)
    __outline_begin__()
    a = N(42)
    yield a + b + x
    a = N(99)
    __outline_end__()
    b = N(13)
test_invalid_outline_yield(-123)

@test
def test_invalid_outline_yield_in(x):
    b = N(10)
    __outline_begin__()
    a = (yield) + b
    yield b
    __outline_end__()
    b = N(13)
test_invalid_outline_yield_in(-123)

@test
def test_invalid_outline_stack_alloc():
    __outline_begin__()
    a = __array__[int](1)
    a[0] = 42
    __outline_end__()
    print a[0]
test_invalid_outline_stack_alloc()
# EXPECT: 42

print __outline_successes__()
print __outline_failures__()
# EXPECT: 8
# EXPECT: 3
</t>
<t tx="ekr.20230509083244.17">  auto compiler = std::make_unique&lt;Compiler&gt;(
      argv0, debug, /*disabledPasses=*/std::vector&lt;std::string&gt;{}, /*isTest=*/true,
      pyNumerics);
  compiler-&gt;getLLVMVisitor()-&gt;setStandalone(
      true); // make sure we abort() on runtime error
  llvm::handleAllErrors(code.empty()
                            ? compiler-&gt;parseFile(file, testFlags)
                            : compiler-&gt;parseCode(file, code, startLine, testFlags),
                        [](const error::ParserErrorInfo &amp;e) {
                          for (auto &amp;group : e) {
                            for (auto &amp;msg : group) {
                              getLogger().level = 0;
                              printf("%s\n", msg.getMessage().c_str());
                            }
                          }
                          fflush(stdout);
                          exit(EXIT_FAILURE);
                        });

</t>
<t tx="ekr.20230509083244.170">@path C:/Repos/codon/test/transform/
@language unknown_language
cat_count = 0

# c/p from str.seq
def old_cat(*args):
    total = 0
    if staticlen(args) == 1 and hasattr(args[0], "__iter__") and hasattr(args[0], "__len__"):
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            total += s.len
        p = cobj(total)
        n = 0
        for s in args[0]:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)
    elif staticlen(args) == 1 and hasattr(args[0], "__iter__"):
        sz = 10
        p = cobj(sz)
        n = 0
        for s in args[0]:
            if not isinstance(s, str):
                compile_error("not a string")
            if n + s.len &gt; sz:
                sz = 1 + 3 * (n + s.len) // 2
                pp = cobj(sz)
                str.memcpy(pp, p, n)
                p = pp
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, n)
    else:
        total = 0
        for i in args:
            if not isinstance(i, str):
                compile_error("not a string")
            total += i.len
        p = cobj(total)
        n = 0
        for i in args:
            str.memcpy(p + n, i.ptr, i.len)
            n += i.len
        return str(p, total)

@extend
class str:
    def cat(*args):
        global cat_count
        cat_count += 1
        return old_cat(*args)

@test
def test_str_optimization():
    assert 'hello ' + 'world' == "hello world"  # no opt: just adding 2 strs
    assert cat_count == 0
    # assert 'a' + 'b' + 'c' == 'abc' # superseded by string statics
    # assert cat_count == 1
    assert 'a' * 2 == 'aa'  # no opt: mul instead of add
    assert cat_count == 0
    # assert 'a' + ('b' + 'c') == 'abc'
    # assert cat_count == 2
    # assert 'a' + ('b' + ('c' + 'd')) == 'abcd'
    # assert cat_count == 3

    a = 'a'
    b = 'b'
    c = 'c'
    assert (a*2 + b*3 + c*4) == 'aabbbcccc'
    assert cat_count == 1
test_str_optimization()
</t>
<t tx="ekr.20230509083244.18">  auto *pm = compiler-&gt;getPassManager();
  pm-&gt;registerPass(std::make_unique&lt;TestOutliner&gt;());
  pm-&gt;registerPass(std::make_unique&lt;TestInliner&gt;());
</t>
<t tx="ekr.20230509083244.19">  auto capKey =
      pm-&gt;registerAnalysis(std::make_unique&lt;ir::analyze::dataflow::CaptureAnalysis&gt;(
                               ir::analyze::dataflow::RDAnalysis::KEY,
                               ir::analyze::dataflow::DominatorAnalysis::KEY),
                           {ir::analyze::dataflow::RDAnalysis::KEY,
                            ir::analyze::dataflow::DominatorAnalysis::KEY});
  pm-&gt;registerPass(std::make_unique&lt;EscapeValidator&gt;(capKey), /*insertBefore=*/"",
</t>
<t tx="ekr.20230509083244.2">void handle(ir::SeriesFlow *v) override {
  auto *M = v-&gt;getModule();
  auto begin = v-&gt;begin(), end = v-&gt;end();
  bool sawBegin = false, sawEnd = false;
  for (auto it = v-&gt;begin(); it != v-&gt;end(); ++it) {
    if (ir::util::isCallOf(*it, "__outline_begin__") &amp;&amp; !sawBegin) {
      begin = it;
      sawBegin = true;
    } else if (ir::util::isCallOf(*it, "__outline_end__") &amp;&amp; !sawEnd) {
      end = it;
      sawEnd = true;
    }
  }
  if (sawBegin &amp;&amp; sawEnd) {
    auto result = ir::util::outlineRegion(ir::cast&lt;ir::BodiedFunc&gt;(getParentFunc()),
                                          v, begin, end);
    ++(result ? successes : failures);
    if (successesReturn)
      successesReturn-&gt;setValue(M-&gt;getInt(successes));
    if (failuresReturn)
      failuresReturn-&gt;setValue(M-&gt;getInt(failures));
  }
}

</t>
<t tx="ekr.20230509083244.20">static string
getTestNameFromParam(const testing::TestParamInfo&lt;SeqTest::ParamType&gt; &amp;info) {
  const string basename = get&lt;0&gt;(info.param);
  const bool debug = get&lt;1&gt;(info.param);

  // normalize basename
  // size_t found1 = basename.find('/');
  // size_t found2 = basename.find('.');
  // assert(found1 != string::npos);
  // assert(found2 != string::npos);
  // assert(found2 &gt; found1);
  // string normname = basename.substr(found1 + 1, found2 - found1 - 1);
  string normname = basename;
  replace(normname.begin(), normname.end(), '/', '_');
  replace(normname.begin(), normname.end(), '.', '_');
  return normname + (debug ? "_debug" : "");
}
</t>
<t tx="ekr.20230509083244.21">static string
getTypeTestNameFromParam(const testing::TestParamInfo&lt;SeqTest::ParamType&gt; &amp;info) {
  return getTestNameFromParam(info) + "_" + get&lt;2&gt;(info.param);
}
</t>
<t tx="ekr.20230509083244.22">TEST_P(SeqTest, Run) {
  const string file = get&lt;0&gt;(GetParam());
  int status;
  bool isCase = !get&lt;2&gt;(GetParam()).empty();
  if (!isCase)
    status = runInChildProcess();
  else
    status = runInChildProcess();
  ASSERT_TRUE(WIFEXITED(status));

  string output = result();

  auto expects = findExpects(!isCase ? getFilename(file) : get&lt;3&gt;(GetParam()), isCase);
  if (WEXITSTATUS(status) != int(expects.second))
    fprintf(stderr, "%s\n", output.c_str());
  ASSERT_EQ(WEXITSTATUS(status), int(expects.second));
  const bool assertsFailed = output.find("TEST FAILED") != string::npos;
  EXPECT_FALSE(assertsFailed);
  if (assertsFailed)
    std::cerr &lt;&lt; output &lt;&lt; std::endl;

  if (!expects.first.empty()) {
    vector&lt;string&gt; results = splitLines(output);
    for (unsigned i = 0; i &lt; min(results.size(), expects.first.size()); i++)
      if (expects.second)
        EXPECT_EQ(results[i], expects.first[i]);
      else
        EXPECT_EQ(results[i], expects.first[i]);
    EXPECT_EQ(results.size(), expects.first.size());
  }
}
</t>
<t tx="ekr.20230509083244.23">auto getTypeTests(const vector&lt;string&gt; &amp;files) {
  vector&lt;tuple&lt;string, bool, string, string, int, bool, bool&gt;&gt; cases;
  for (auto &amp;f : files) {
    bool barebones = false;
    string l;
    ifstream fin(string(TEST_DIR) + "/" + f);
    string code, testName;
    int test = 0;
    int codeLine = 0;
    int line = 0;
    while (getline(fin, l)) {
      if (l.substr(0, 3) == "#%%") {
        if (line)
          cases.emplace_back(make_tuple(f, true, to_string(line) + "_" + testName, code,
                                        codeLine, barebones, false));
        auto t = ast::split(l.substr(4), ',');
        barebones = (t.size() &gt; 1 &amp;&amp; t[1] == "barebones");
        testName = t[0];
        code = l + "\n";
        codeLine = line;
        test++;
      } else {
        code += l + "\n";
      }
      line++;
    }
    if (line)
      cases.emplace_back(make_tuple(f, true, to_string(line) + "_" + testName, code,
                                    codeLine, barebones, false));
  }
  return cases;
}

</t>
<t tx="ekr.20230509083244.24">// clang-format off
INSTANTIATE_TEST_SUITE_P(
    TypeTests, SeqTest,
    testing::ValuesIn(getTypeTests({
      "parser/simplify_expr.codon",
      "parser/simplify_stmt.codon",
      "parser/typecheck_expr.codon",
      "parser/typecheck_stmt.codon",
      "parser/types.codon",
      "parser/llvm.codon"
    })),
    getTypeTestNameFromParam);

INSTANTIATE_TEST_SUITE_P(
    CoreTests, SeqTest,
    testing::Combine(
      testing::Values(
        "core/helloworld.codon",
        "core/arithmetic.codon",
        "core/parser.codon",
        "core/generics.codon",
        "core/generators.codon",
        "core/exceptions.codon",
        "core/containers.codon",
        "core/trees.codon",
        "core/range.codon",
        "core/bltin.codon",
        "core/arguments.codon",
        "core/match.codon",
        "core/serialization.codon",
        "core/pipeline.codon",
        "core/empty.codon"
      ),
      testing::Values(true, false),
      testing::Values(""),
      testing::Values(""),
      testing::Values(0),
      testing::Values(false),
      testing::Values(false)
    ),
    getTestNameFromParam);

INSTANTIATE_TEST_SUITE_P(
    NumericsTests, SeqTest,
    testing::Combine(
      testing::Values(
        "core/numerics.codon"
      ),
      testing::Values(true, false),
      testing::Values(""),
      testing::Values(""),
      testing::Values(0),
      testing::Values(false),
      testing::Values(true)
    ),
    getTestNameFromParam);

INSTANTIATE_TEST_SUITE_P(
    StdlibTests, SeqTest,
    testing::Combine(
      testing::Values(
        "stdlib/str_test.codon",
        "stdlib/re_test.codon",
        "stdlib/math_test.codon",
        "stdlib/cmath_test.codon",
        "stdlib/datetime_test.codon",
        "stdlib/itertools_test.codon",
        "stdlib/bisect_test.codon",
        "stdlib/random_test.codon",
        "stdlib/statistics_test.codon",
        "stdlib/sort_test.codon",
        "stdlib/heapq_test.codon",
        "stdlib/operator_test.codon",
        "python/pybridge.codon"
      ),
      testing::Values(true, false),
      testing::Values(""),
      testing::Values(""),
      testing::Values(0),
      testing::Values(false),
      testing::Values(false)
    ),
    getTestNameFromParam);

INSTANTIATE_TEST_SUITE_P(
    OptTests, SeqTest,
    testing::Combine(
        testing::Values(
            "transform/canonical.codon",
            "transform/dict_opt.codon",
            "transform/escapes.codon",
            "transform/folding.codon",
            "transform/for_lowering.codon",
            "transform/io_opt.codon",
            "transform/inlining.codon",
            "transform/list_opt.codon",
            "transform/omp.codon",
            "transform/outlining.codon",
            "transform/str_opt.codon"
        ),
        testing::Values(true, false),
        testing::Values(""),
        testing::Values(""),
        testing::Values(0),
        testing::Values(false),
        testing::Values(false)
    ),
    getTestNameFromParam);

</t>
<t tx="ekr.20230509083244.25">// clang-format on

int main(int argc, char *argv[]) {
  argv0 = ast::executable_path(argv[0]);
  testing::InitGoogleTest(&amp;argc, argv);
  return RUN_ALL_TESTS();
}
</t>
<t tx="ekr.20230509083244.26">@path C:/Repos/codon/test/
// Copyright (C) 2022-2023 Exaloop Inc. &lt;https://exaloop.io&gt;

#include &lt;algorithm&gt;
#include &lt;dirent.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;fstream&gt;
#include &lt;gc.h&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;tuple&gt;
#include &lt;unistd.h&gt;
#include &lt;vector&gt;

#include "codon/parser/common.h"
#include "codon/util/common.h"
#include "gtest/gtest.h"

TEST(TypeCoreTest, TestName) { ; }
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.27"></t>
<t tx="ekr.20230509083244.28">@path C:/Repos/codon/test/app/
@language unknown_language
from sys import argv
print(','.join(argv[1:]))
</t>
<t tx="ekr.20230509083244.29">@path C:/Repos/codon/test/app/
@language unknown_language
print('hello')
</t>
<t tx="ekr.20230509083244.3">void handle(ir::ReturnInstr *v) override {
  @others
</t>
<t tx="ekr.20230509083244.30">@path C:/Repos/codon/test/app/
@language unknown_language
import sys
sys.exit(42)
</t>
<t tx="ekr.20230509083244.31">@path C:/Repos/codon/test/app/
@language unknown_language
a = ['a', 'b', 'c']

@export
def foo(n: int):
    print(''.join(a) * n)
</t>
<t tx="ekr.20230509083244.32">@path C:/Repos/codon/test/app/
extern void foo(long);
int main(void) { foo(3); }
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.33"></t>
<t tx="ekr.20230509083244.34">@path C:/Repos/codon/test/cir/
#include "test.h"

#include &lt;algorithm&gt;

namespace {
@others
TEST_F(CIRCoreTest, NodeNoReplacementAttributes) {
  auto *node = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  ASSERT_FALSE(node-&gt;hasReplacement());
  ASSERT_FALSE(node-&gt;hasAttribute&lt;KeyValueAttribute&gt;());

  ASSERT_TRUE(node-&gt;hasAttribute&lt;SrcInfoAttribute&gt;());
  ASSERT_TRUE(node-&gt;getAttribute&lt;SrcInfoAttribute&gt;());
  ASSERT_EQ(1, std::distance(node-&gt;attributes_begin(), node-&gt;attributes_end()));
}

TEST_F(CIRCoreTest, NodeReplacementRTTI) {
  Value *node = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  ASSERT_TRUE(node);
  ASSERT_FALSE(node-&gt;hasReplacement());
  ASSERT_TRUE(isA&lt;IntConst&gt;(node));

  node-&gt;replaceAll(module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType()));
  ASSERT_TRUE(node-&gt;hasReplacement());
  ASSERT_FALSE(isA&lt;IntConst&gt;(node));
  ASSERT_TRUE(isA&lt;BoolConst&gt;(node));
  ASSERT_TRUE(cast&lt;BoolConst&gt;(node));
}

TEST_F(CIRCoreTest, NodeReplacementDelegates) {
  auto NODE_NAME = "foo";

  Value *originalNode = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  Value *newNode = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType(), NODE_NAME);
  newNode-&gt;setAttribute(std::make_unique&lt;KeyValueAttribute&gt;());

  ASSERT_EQ(0, originalNode-&gt;getName().size());
  ASSERT_EQ(1, std::distance(originalNode-&gt;attributes_begin(),
                             originalNode-&gt;attributes_end()));

  originalNode-&gt;replaceAll(newNode);
  ASSERT_EQ(NODE_NAME, originalNode-&gt;getName());
  ASSERT_EQ(2, std::distance(originalNode-&gt;attributes_begin(),
                             originalNode-&gt;attributes_end()));

  TestVisitor v;
  originalNode-&gt;accept(v);
  newNode-&gt;accept(v);

  ConstTestVisitor v2;
  originalNode-&gt;accept(v2);
  newNode-&gt;accept(v2);
}

TEST_F(CIRCoreTest, NodeNonReplaceableFails) {
  Value *originalNode = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  originalNode-&gt;setReplaceable(false);
  ASSERT_DEATH(originalNode-&gt;replaceAll(originalNode), "");
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.35">class TestVisitor : public codon::ir::util::Visitor {
public:
  void visit(codon::ir::IntConst *) override { FAIL(); }
  void visit(codon::ir::BoolConst *) override {}
};

</t>
<t tx="ekr.20230509083244.36">class ConstTestVisitor : public codon::ir::util::ConstVisitor {
public:
  void visit(const codon::ir::IntConst *) override { FAIL(); }
</t>
<t tx="ekr.20230509083244.37">  void visit(const codon::ir::BoolConst *) override {}
};

} // namespace

using namespace codon::ir;

TEST_F(CIRCoreTest, NodeNoReplacementRTTI) {
  auto *derived = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  ASSERT_TRUE(derived);
  ASSERT_FALSE(derived-&gt;hasReplacement());
  auto *base = cast&lt;Value&gt;(derived);
  ASSERT_TRUE(base);
  ASSERT_TRUE(isA&lt;IntConst&gt;(base));
  ASSERT_TRUE(isA&lt;Const&gt;(base));
  ASSERT_TRUE(isA&lt;Value&gt;(base));
  ASSERT_FALSE(isA&lt;Flow&gt;(base));

  const auto *constBase = base;
  ASSERT_TRUE(isA&lt;Const&gt;(constBase));
  ASSERT_TRUE(cast&lt;Const&gt;(constBase));
}

</t>
<t tx="ekr.20230509083244.38">@path C:/Repos/codon/test/cir/
#include "test.h"

#include &lt;fmt/format.h&gt;
#include &lt;sstream&gt;

using namespace codon::ir;

TEST_F(CIRCoreTest, ConstTypeQueryAndReplace) {
  auto *node = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  ASSERT_EQ(module-&gt;getIntType(), node-&gt;getType());

  auto usedTypes = node-&gt;getUsedTypes();
  ASSERT_EQ(1, usedTypes.size());
  ASSERT_EQ(module-&gt;getIntType(), usedTypes[0]);
  ASSERT_EQ(1, node-&gt;replaceUsedType(module-&gt;getIntType(), module-&gt;getIntType()));
}

TEST_F(CIRCoreTest, ConstCloning) {
  auto VALUE = 1;
  auto *node = module-&gt;Nr&lt;IntConst&gt;(VALUE, module-&gt;getIntType());
  auto *clone = cast&lt;IntConst&gt;(cv-&gt;clone(node));

  ASSERT_TRUE(clone);
  ASSERT_EQ(VALUE, clone-&gt;getVal());
  ASSERT_EQ(module-&gt;getIntType(), clone-&gt;getType());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.39">@path C:/Repos/codon/test/cir/
#include "test.h"

#include &lt;algorithm&gt;
#include &lt;vector&gt;

#include "codon/cir/util/matching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, SeriesFlowInsertionEraseAndIterators) {
  auto FIRST_VALUE = 2;
  auto SECOND_VALUE = 1;

  auto *f = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(SECOND_VALUE, module-&gt;getIntType()));
  f-&gt;insert(f-&gt;begin(), module-&gt;Nr&lt;IntConst&gt;(FIRST_VALUE, module-&gt;getIntType()));

  std::vector&lt;Value *&gt; contents(f-&gt;begin(), f-&gt;end());

  ASSERT_EQ(2, contents.size());
  ASSERT_EQ(FIRST_VALUE, cast&lt;IntConst&gt;(contents[0])-&gt;getVal());
  ASSERT_EQ(SECOND_VALUE, cast&lt;IntConst&gt;(contents[1])-&gt;getVal());

  f-&gt;erase(f-&gt;begin());
  ASSERT_EQ(SECOND_VALUE, cast&lt;IntConst&gt;(*f-&gt;begin())-&gt;getVal());
}

TEST_F(CIRCoreTest, SeriesFlowQueryAndReplace) {
  auto FIRST_VALUE = 2;
  auto SECOND_VALUE = 1;

  auto *f = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(SECOND_VALUE, module-&gt;getIntType()));
  f-&gt;insert(f-&gt;begin(), module-&gt;Nr&lt;IntConst&gt;(FIRST_VALUE, module-&gt;getIntType()));

  std::vector&lt;Value *&gt; contents(f-&gt;begin(), f-&gt;end());
  auto used = f-&gt;getUsedValues();

  ASSERT_TRUE(std::equal(used.begin(), used.end(), contents.begin(), contents.end()));
  ASSERT_EQ(0, f-&gt;getUsedTypes().size());
  ASSERT_EQ(0, f-&gt;getUsedVariables().size());

  ASSERT_EQ(1, f-&gt;replaceUsedValue(contents[0], contents[1]));
}

TEST_F(CIRCoreTest, SeriesFlowCloning) {
  auto FIRST_VALUE = 2;
  auto SECOND_VALUE = 1;

  auto *f = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(SECOND_VALUE, module-&gt;getIntType()));
  f-&gt;insert(f-&gt;begin(), module-&gt;Nr&lt;IntConst&gt;(FIRST_VALUE, module-&gt;getIntType()));

  ASSERT_TRUE(util::match(f, cv-&gt;clone(f)));
}

TEST_F(CIRCoreTest, WhileFlowQueryAndReplace) {
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *f = module-&gt;Nr&lt;WhileFlow&gt;(cond, body);

  ASSERT_EQ(cond, f-&gt;getCond());
  ASSERT_EQ(body, f-&gt;getBody());

  std::vector&lt;Value *&gt; usedValues = {cond, body};
  auto queried = f-&gt;getUsedValues();
  ASSERT_TRUE(
      std::equal(usedValues.begin(), usedValues.end(), queried.begin(), queried.end()));
  ASSERT_EQ(0, f-&gt;getUsedTypes().size());
  ASSERT_EQ(0, f-&gt;getUsedVariables().size());

  ASSERT_EQ(
      1, f-&gt;replaceUsedValue(cond, module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())));
  ASSERT_EQ(1, f-&gt;replaceUsedValue(body, module-&gt;Nr&lt;SeriesFlow&gt;()));
  ASSERT_DEATH(f-&gt;replaceUsedValue(f-&gt;getBody(),
                                   module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())),
               "");
  queried = f-&gt;getUsedValues();
  ASSERT_FALSE(
      std::equal(usedValues.begin(), usedValues.end(), queried.begin(), queried.end()));
}

TEST_F(CIRCoreTest, WhileFlowCloning) {
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *f = module-&gt;Nr&lt;WhileFlow&gt;(cond, body);
  ASSERT_TRUE(util::match(f, cv-&gt;clone(f)));
}

TEST_F(CIRCoreTest, ForFlowQueryAndReplace) {
  auto *iter = module-&gt;Nr&lt;StringConst&gt;("hi", module-&gt;getStringType());
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getStringType(), false, "x");
  auto *f = module-&gt;Nr&lt;ForFlow&gt;(iter, body, var);

  ASSERT_EQ(iter, f-&gt;getIter());
  ASSERT_EQ(body, f-&gt;getBody());
  ASSERT_EQ(var, f-&gt;getVar());

  std::vector&lt;Value *&gt; usedValues = {iter, body};
  auto qVal = f-&gt;getUsedValues();
  ASSERT_TRUE(
      std::equal(usedValues.begin(), usedValues.end(), qVal.begin(), qVal.end()));
  ASSERT_EQ(0, f-&gt;getUsedTypes().size());

  std::vector&lt;Var *&gt; usedVars = {var};
  auto qVar = f-&gt;getUsedVariables();
  ASSERT_TRUE(std::equal(usedVars.begin(), usedVars.end(), qVar.begin(), qVar.end()));

  ASSERT_EQ(1, f-&gt;replaceUsedValue(
                   iter, module-&gt;Nr&lt;StringConst&gt;("hi", module-&gt;getStringType())));
  ASSERT_EQ(1, f-&gt;replaceUsedValue(body, module-&gt;Nr&lt;SeriesFlow&gt;()));
  qVal = f-&gt;getUsedValues();
  ASSERT_FALSE(
      std::equal(usedValues.begin(), usedValues.end(), qVal.begin(), qVal.end()));

  ASSERT_EQ(1, f-&gt;replaceUsedVariable(
                   var, module-&gt;Nr&lt;Var&gt;(module-&gt;getStringType(), false, "x")));
  ASSERT_NE(var, f-&gt;getVar());
}

TEST_F(CIRCoreTest, ForFlowCloning) {
  auto *iter = module-&gt;Nr&lt;StringConst&gt;("hi", module-&gt;getStringType());
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getStringType(), false, "x");
  auto *f = module-&gt;Nr&lt;ForFlow&gt;(iter, body, var);

  ASSERT_TRUE(util::match(f, cv-&gt;clone(f)));
}

TEST_F(CIRCoreTest, IfFlowQueryAndReplace) {
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *tBody = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *fBody = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *f = module-&gt;Nr&lt;IfFlow&gt;(cond, tBody, fBody);

  ASSERT_EQ(cond, f-&gt;getCond());
  ASSERT_EQ(tBody, f-&gt;getTrueBranch());
  ASSERT_EQ(fBody, f-&gt;getFalseBranch());

  std::vector&lt;Value *&gt; usedValues = {cond, tBody, fBody};
  auto qVal = f-&gt;getUsedValues();
  ASSERT_TRUE(
      std::equal(usedValues.begin(), usedValues.end(), qVal.begin(), qVal.end()));
  ASSERT_EQ(0, f-&gt;getUsedTypes().size());
  ASSERT_EQ(0, f-&gt;getUsedVariables().size());

  usedValues.pop_back();
  f-&gt;setFalseBranch(nullptr);
  qVal = f-&gt;getUsedValues();
  ASSERT_TRUE(
      std::equal(usedValues.begin(), usedValues.end(), qVal.begin(), qVal.end()));
  f-&gt;setFalseBranch(fBody);

  ASSERT_EQ(
      1, f-&gt;replaceUsedValue(cond, module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())));
  ASSERT_EQ(1, f-&gt;replaceUsedValue(tBody, module-&gt;Nr&lt;SeriesFlow&gt;()));
  ASSERT_EQ(1, f-&gt;replaceUsedValue(fBody, module-&gt;Nr&lt;SeriesFlow&gt;()));

  ASSERT_DEATH(f-&gt;replaceUsedValue(f-&gt;getTrueBranch(),
                                   module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())),
               "");
  ASSERT_DEATH(f-&gt;replaceUsedValue(f-&gt;getFalseBranch(),
                                   module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())),
               "");

  qVal = f-&gt;getUsedValues();
  ASSERT_FALSE(
      std::equal(usedValues.begin(), usedValues.end(), qVal.begin(), qVal.end()));
}

TEST_F(CIRCoreTest, IfFlowCloning) {
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *tBody = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *fBody = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *f = module-&gt;Nr&lt;IfFlow&gt;(cond, tBody, fBody);

  ASSERT_TRUE(util::match(f, cv-&gt;clone(f)));
}

TEST_F(CIRCoreTest, TryCatchFlowSingleCatchQueryAndReplace) {
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *finally = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *f = module-&gt;Nr&lt;TryCatchFlow&gt;(body, finally);
  auto *handler = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());

  f-&gt;emplace_back(handler, module-&gt;getIntType(), var);

  ASSERT_EQ(1, f-&gt;replaceUsedVariable(var, module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType())));
  ASSERT_EQ(1, f-&gt;replaceUsedType(module-&gt;getIntType(), module-&gt;getFloatType()));
  ASSERT_EQ(1, f-&gt;replaceUsedValue(handler, module-&gt;Nr&lt;SeriesFlow&gt;()));
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.4">auto *M = v-&gt;getModule();
if (getParentFunc()-&gt;getUnmangledName() == "__outline_successes__") {
  v-&gt;setValue(M-&gt;getInt(successes));
  successesReturn = v;
}
if (getParentFunc()-&gt;getUnmangledName() == "__outline_failures__") {
  v-&gt;setValue(M-&gt;getInt(failures));
  failuresReturn = v;
}
  }
</t>
<t tx="ekr.20230509083244.40">@path C:/Repos/codon/test/cir/
#include "test.h"

#include &lt;algorithm&gt;

#include "codon/cir/util/matching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, FuncRealizationAndVarInsertionEraseAndIterators) {
  auto *fn = module-&gt;Nr&lt;BodiedFunc&gt;();
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

  auto *fnType = module-&gt;unsafeGetFuncType("**test_type**", module-&gt;getIntType(),
                                           {module-&gt;getIntType()});
  std::vector&lt;std::string&gt; names = {"foo"};
  fn-&gt;realize(cast&lt;types::FuncType&gt;(fnType), names);
  ASSERT_TRUE(fn-&gt;isGlobal());

  ASSERT_EQ(1, std::distance(fn-&gt;arg_begin(), fn-&gt;arg_end()));
  ASSERT_EQ(module-&gt;getIntType(), fn-&gt;arg_front()-&gt;getType());

  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType(), false, "hi");
  fn-&gt;push_back(var);
  ASSERT_EQ(1, std::distance(fn-&gt;begin(), fn-&gt;end()));
  fn-&gt;erase(fn-&gt;begin());
  ASSERT_EQ(0, std::distance(fn-&gt;begin(), fn-&gt;end()));
  fn-&gt;insert(fn-&gt;begin(), var);
  ASSERT_EQ(1, std::distance(fn-&gt;begin(), fn-&gt;end()));
  ASSERT_EQ(module-&gt;getIntType(), fn-&gt;front()-&gt;getType());
}

TEST_F(CIRCoreTest, BodiedFuncQueryAndReplace) {
  auto *fn = module-&gt;Nr&lt;BodiedFunc&gt;();
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
  fn-&gt;setJIT();
  ASSERT_TRUE(fn-&gt;isJIT());

  auto *body = fn-&gt;getBody();
  ASSERT_FALSE(body);
  ASSERT_EQ(0, fn-&gt;getUsedValues().size());

  body = module-&gt;Nr&lt;SeriesFlow&gt;();
  fn-&gt;setBody(body);
  ASSERT_EQ(body, fn-&gt;getBody());

  auto used = fn-&gt;getUsedValues();
  ASSERT_EQ(1, used.size());
  ASSERT_EQ(body, used[0]);

  ASSERT_EQ(1, fn-&gt;replaceUsedValue(body, module-&gt;Nr&lt;SeriesFlow&gt;()));
  ASSERT_DEATH(fn-&gt;replaceUsedValue(fn-&gt;getBody(), module-&gt;Nr&lt;VarValue&gt;(nullptr)), "");
  ASSERT_NE(fn-&gt;getBody(), body);
}

TEST_F(CIRCoreTest, BodiedFuncUnmangledName) {
  auto *fn = module-&gt;Nr&lt;BodiedFunc&gt;("Int.foo");
  fn-&gt;setUnmangledName("foo");
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
  ASSERT_EQ("foo", fn-&gt;getUnmangledName());
}

TEST_F(CIRCoreTest, BodiedFuncCloning) {
  auto *fn = module-&gt;Nr&lt;BodiedFunc&gt;("fn");
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

  fn-&gt;setJIT();
  fn-&gt;setBody(module-&gt;Nr&lt;SeriesFlow&gt;());
  ASSERT_TRUE(util::match(fn, cv-&gt;clone(fn)));
}

TEST_F(CIRCoreTest, ExternalFuncUnmangledNameAndCloning) {
  auto *fn = module-&gt;Nr&lt;ExternalFunc&gt;("fn");
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

  fn-&gt;setUnmangledName("foo");
  ASSERT_EQ("foo", fn-&gt;getUnmangledName());
  ASSERT_TRUE(util::match(fn, cv-&gt;clone(fn)));
}

TEST_F(CIRCoreTest, InternalFuncParentTypeUnmangledNameAndCloning) {
  auto *fn = module-&gt;Nr&lt;InternalFunc&gt;("fn.1");
  fn-&gt;setUnmangledName("fn");
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

  fn-&gt;setParentType(module-&gt;getIntType());
  ASSERT_EQ("fn", fn-&gt;getUnmangledName());
  ASSERT_EQ(fn-&gt;getParentType(), module-&gt;getIntType());
  ASSERT_TRUE(util::match(fn, cv-&gt;clone(fn)));
}

TEST_F(CIRCoreTest, LLVMFuncUnmangledNameQueryAndReplace) {
  auto *fn = module-&gt;Nr&lt;LLVMFunc&gt;("fn");
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

  fn-&gt;setLLVMBody("body");
  fn-&gt;setLLVMDeclarations("decl");

  std::vector&lt;types::Generic&gt; literals = {types::Generic(1),
                                          types::Generic(module-&gt;getIntType())};
  fn-&gt;setLLVMLiterals(literals);

  ASSERT_EQ("body", fn-&gt;getLLVMBody());
  ASSERT_EQ("decl", fn-&gt;getLLVMDeclarations());

  ASSERT_EQ(1, fn-&gt;replaceUsedType(module-&gt;getIntType(), module-&gt;getFloatType()));
  ASSERT_EQ(module-&gt;getFloatType(), fn-&gt;literal_back().getTypeValue());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.41">@path C:/Repos/codon/test/cir/
#include "test.h"

#include "codon/cir/util/matching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, AssignInstrQueryAndReplace) {
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;AssignInstr&gt;(var, val);

  ASSERT_EQ(var, instr-&gt;getLhs());
  ASSERT_EQ(val, instr-&gt;getRhs());

  auto usedVals = instr-&gt;getUsedValues();
  ASSERT_EQ(1, usedVals.size());
  ASSERT_EQ(val, usedVals[0]);

  auto usedVars = instr-&gt;getUsedVariables();
  ASSERT_EQ(1, usedVars.size());
  ASSERT_EQ(var, usedVars[0]);

  ASSERT_EQ(
      1, instr-&gt;replaceUsedValue(val, module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType())));
  ASSERT_EQ(1, instr-&gt;replaceUsedVariable(var, module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType())));
}

TEST_F(CIRCoreTest, AssignInstrCloning) {
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;AssignInstr&gt;(var, val);

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, ExtractInstrQueryAndReplace) {
  auto FIELD = "foo";
  auto *type = cast&lt;types::RecordType&gt;(module-&gt;unsafeGetMemberedType("**internal**"));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *val = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *instr = module-&gt;Nr&lt;ExtractInstr&gt;(val, FIELD);

  ASSERT_EQ(FIELD, instr-&gt;getField());
  ASSERT_EQ(val, instr-&gt;getVal());
  ASSERT_EQ(type-&gt;getMemberType(FIELD), instr-&gt;getType());

  auto usedVals = instr-&gt;getUsedValues();
  ASSERT_EQ(1, usedVals.size());
  ASSERT_EQ(val, usedVals[0]);

  ASSERT_EQ(1, instr-&gt;replaceUsedValue(val, module-&gt;Nr&lt;VarValue&gt;(var)));
}

TEST_F(CIRCoreTest, ExtractInstrCloning) {
  auto FIELD = "foo";
  auto *type = cast&lt;types::RecordType&gt;(module-&gt;unsafeGetMemberedType("**internal**"));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *val = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *instr = module-&gt;Nr&lt;ExtractInstr&gt;(val, FIELD);

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, InsertInstrQueryAndReplace) {
  auto FIELD = "foo";
  auto *type =
      cast&lt;types::RefType&gt;(module-&gt;unsafeGetMemberedType("**internal**", true));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *lhs = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *rhs = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;InsertInstr&gt;(lhs, FIELD, rhs);

  ASSERT_EQ(type, instr-&gt;getType());

  auto usedVals = instr-&gt;getUsedValues();
  ASSERT_EQ(2, usedVals.size());

  ASSERT_EQ(1, instr-&gt;replaceUsedValue(lhs, module-&gt;Nr&lt;VarValue&gt;(var)));
  ASSERT_EQ(
      1, instr-&gt;replaceUsedValue(rhs, module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType())));
}

TEST_F(CIRCoreTest, InsertInstrCloning) {
  auto FIELD = "foo";
  auto *type =
      cast&lt;types::RefType&gt;(module-&gt;unsafeGetMemberedType("**internal**", true));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *lhs = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *rhs = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;InsertInstr&gt;(lhs, FIELD, rhs);

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, CallInstrQueryAndReplace) {
  auto *type = cast&lt;types::FuncType&gt;(module-&gt;unsafeGetDummyFuncType());
  auto *func = module-&gt;Nr&lt;BodiedFunc&gt;();
  func-&gt;realize(type, {});
  auto *funcVal = module-&gt;Nr&lt;VarValue&gt;(func);
  auto *instr = module-&gt;Nr&lt;CallInstr&gt;(funcVal);

  ASSERT_EQ(funcVal, instr-&gt;getCallee());
  ASSERT_EQ(type-&gt;getReturnType(), instr-&gt;getType());

  auto usedVals = instr-&gt;getUsedValues();
  ASSERT_EQ(1, usedVals.size());
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(funcVal, module-&gt;Nr&lt;VarValue&gt;(func)));
}

TEST_F(CIRCoreTest, CallInstrCloning) {
  auto *type = module-&gt;unsafeGetDummyFuncType();
  auto *func = module-&gt;Nr&lt;BodiedFunc&gt;();
  func-&gt;realize(type, {});
  auto *funcVal = module-&gt;Nr&lt;VarValue&gt;(func);
  auto *instr = module-&gt;Nr&lt;CallInstr&gt;(funcVal);

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, StackAllocInstrQueryAndReplace) {
  auto COUNT = 1;

  auto *arrayType = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;StackAllocInstr&gt;(arrayType, COUNT);

  ASSERT_EQ(COUNT, instr-&gt;getCount());
  ASSERT_EQ(arrayType, instr-&gt;getType());

  auto usedTypes = instr-&gt;getUsedTypes();
  ASSERT_EQ(1, usedTypes.size());
  ASSERT_EQ(arrayType, usedTypes[0]);

  ASSERT_EQ(1, instr-&gt;replaceUsedType(
                   arrayType, module-&gt;unsafeGetArrayType(module-&gt;getFloatType())));
}

TEST_F(CIRCoreTest, StackAllocInstrCloning) {
  auto COUNT = 1;
  auto *arrayType = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;StackAllocInstr&gt;(arrayType, COUNT);
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, TypePropertyInstrQueryAndReplace) {
  auto *type = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr =
      module-&gt;Nr&lt;TypePropertyInstr&gt;(type, TypePropertyInstr::Property::IS_ATOMIC);

  ASSERT_EQ(type, instr-&gt;getInspectType());
  ASSERT_EQ(TypePropertyInstr::Property::IS_ATOMIC, instr-&gt;getProperty());
  ASSERT_EQ(module-&gt;getBoolType(), instr-&gt;getType());

  instr-&gt;setProperty(TypePropertyInstr::Property::SIZEOF);
  ASSERT_EQ(module-&gt;getIntType(), instr-&gt;getType());

  auto usedTypes = instr-&gt;getUsedTypes();
  ASSERT_EQ(1, usedTypes.size());
  ASSERT_EQ(type, usedTypes[0]);

  ASSERT_EQ(1, instr-&gt;replaceUsedType(
                   type, module-&gt;unsafeGetArrayType(module-&gt;getFloatType())));
}

TEST_F(CIRCoreTest, TypePropertyInstrCloning) {
  auto *type = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr =
      module-&gt;Nr&lt;TypePropertyInstr&gt;(type, TypePropertyInstr::Property::IS_ATOMIC);
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, YieldInInstrQueryAndReplace) {
  auto *type = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;YieldInInstr&gt;(type);

  ASSERT_EQ(type, instr-&gt;getType());

  auto usedTypes = instr-&gt;getUsedTypes();
  ASSERT_EQ(1, usedTypes.size());
  ASSERT_EQ(type, usedTypes[0]);

  ASSERT_EQ(1, instr-&gt;replaceUsedType(
                   type, module-&gt;unsafeGetArrayType(module-&gt;getFloatType())));
}

TEST_F(CIRCoreTest, YieldInInstrCloning) {
  auto *type = module-&gt;unsafeGetArrayType(module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;YieldInInstr&gt;(type);
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, TernaryInstrQueryAndReplace) {
  auto *trueValue = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *falseValue = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType());
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *instr = module-&gt;Nr&lt;TernaryInstr&gt;(cond, trueValue, falseValue);

  ASSERT_EQ(trueValue, instr-&gt;getTrueValue());
  ASSERT_EQ(falseValue, instr-&gt;getFalseValue());
  ASSERT_EQ(cond, instr-&gt;getCond());

  ASSERT_EQ(3, instr-&gt;getUsedValues().size());

  ASSERT_EQ(1, instr-&gt;replaceUsedValue(
                   cond, module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())));
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(
                   trueValue, module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())));
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(
                   falseValue, module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType())));
}

TEST_F(CIRCoreTest, TernaryInstrCloning) {
  auto *trueValue = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *falseValue = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType());
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *instr = module-&gt;Nr&lt;TernaryInstr&gt;(cond, trueValue, falseValue);

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, ContinueInstrQueryReplaceAndCloning) {
  auto *instr = module-&gt;Nr&lt;ContinueInstr&gt;();
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, BreakInstrQueryReplaceAndCloning) {
  auto *instr = module-&gt;Nr&lt;BreakInstr&gt;();
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, ReturnInstrQueryReplaceAndCloning) {
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;ReturnInstr&gt;(val);
  ASSERT_EQ(val, instr-&gt;getValue());

  ASSERT_EQ(1, instr-&gt;getUsedValues().size());
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(val, nullptr));
  ASSERT_EQ(0, instr-&gt;getUsedValues().size());

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, YieldInstrQueryReplaceAndCloning) {
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;YieldInstr&gt;(val);
  ASSERT_EQ(val, instr-&gt;getValue());

  ASSERT_EQ(1, instr-&gt;getUsedValues().size());
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(val, nullptr));
  ASSERT_EQ(0, instr-&gt;getUsedValues().size());

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, ThrowInstrQueryReplaceAndCloning) {
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;ThrowInstr&gt;(val);
  ASSERT_EQ(val, instr-&gt;getValue());

  ASSERT_EQ(1, instr-&gt;getUsedValues().size());
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(val, nullptr));
  ASSERT_EQ(0, instr-&gt;getUsedValues().size());

  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}

TEST_F(CIRCoreTest, FlowInstrQueryAndReplace) {
  auto *flow = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;FlowInstr&gt;(flow, val);

  ASSERT_EQ(module-&gt;getIntType(), instr-&gt;getType());
  ASSERT_EQ(val, instr-&gt;getValue());
  ASSERT_EQ(flow, instr-&gt;getFlow());

  ASSERT_EQ(2, instr-&gt;getUsedValues().size());
  ASSERT_EQ(
      1, instr-&gt;replaceUsedValue(val, module-&gt;Nr&lt;IntConst&gt;(2, module-&gt;getIntType())));
  ASSERT_EQ(1, instr-&gt;replaceUsedValue(flow, module-&gt;Nr&lt;SeriesFlow&gt;()));
}

TEST_F(CIRCoreTest, FlowInstrCloning) {
  auto *flow = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *instr = module-&gt;Nr&lt;FlowInstr&gt;(flow, val);
  ASSERT_TRUE(util::match(instr, cv-&gt;clone(instr)));
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.42">@path C:/Repos/codon/test/cir/
#include "test.h"

#include "codon/cir/util/matching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, ModuleNodeBuildingRemovalAndIterators) {
  {
    auto n1 = module-&gt;Nr&lt;types::OptionalType&gt;(module-&gt;getIntType());
    ASSERT_EQ(n1-&gt;getModule(), module.get());
    auto numTypes = std::distance(module-&gt;types_begin(), module-&gt;types_end());
    ASSERT_TRUE(std::find(module-&gt;types_begin(), module-&gt;types_end(), n1) !=
                module-&gt;types_end());
    module-&gt;remove(n1);
    ASSERT_EQ(numTypes - 1, std::distance(module-&gt;types_begin(), module-&gt;types_end()));
  }
  {
    auto n1 = module-&gt;N&lt;IntConst&gt;(codon::SrcInfo{}, 1, module-&gt;getIntType());
    ASSERT_EQ(n1-&gt;getModule(), module.get());
    auto numVals = std::distance(module-&gt;values_begin(), module-&gt;values_end());
    ASSERT_TRUE(std::find(module-&gt;values_begin(), module-&gt;values_end(), n1) !=
                module-&gt;values_end());
    module-&gt;remove(n1);
    ASSERT_EQ(numVals - 1, std::distance(module-&gt;values_begin(), module-&gt;values_end()));
  }
  {
    auto n1 = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
    ASSERT_EQ(n1-&gt;getModule(), module.get());
    auto numVars = std::distance(module-&gt;begin(), module-&gt;end());
    ASSERT_TRUE(std::find(module-&gt;begin(), module-&gt;end(), n1) != module-&gt;end());
    module-&gt;remove(n1);
    ASSERT_EQ(numVars - 1, std::distance(module-&gt;begin(), module-&gt;end()));
  }
}

TEST_F(CIRCoreTest, ModuleMainFunctionAndArgVar) {
  auto *main = module-&gt;getMainFunc();
  ASSERT_TRUE(main);
  auto *mainType = cast&lt;types::FuncType&gt;(main-&gt;getType());
  ASSERT_TRUE(mainType);
  ASSERT_TRUE(util::match(mainType-&gt;getReturnType(), module-&gt;getVoidType()));
  ASSERT_EQ(0, std::distance(mainType-&gt;begin(), mainType-&gt;end()));
  ASSERT_FALSE(main-&gt;isReplaceable());

  auto *argVar = module-&gt;getArgVar();
  ASSERT_TRUE(argVar);
  ASSERT_TRUE(util::match(argVar-&gt;getType(),
                          module-&gt;unsafeGetArrayType(module-&gt;getStringType())));
  ASSERT_FALSE(argVar-&gt;isReplaceable());
}

TEST_F(CIRCoreTest, ModuleTypeGetAndLookup) {
  auto TYPE_NAME = "**test_type**";
  auto *newType = module-&gt;unsafeGetMemberedType(TYPE_NAME);
  ASSERT_TRUE(isA&lt;types::RecordType&gt;(newType));
  ASSERT_EQ(newType, module-&gt;getType(TYPE_NAME));
  module-&gt;remove(newType);

  newType = module-&gt;unsafeGetMemberedType(TYPE_NAME, true);
  ASSERT_TRUE(isA&lt;types::RefType&gt;(newType));
  ASSERT_EQ(newType, module-&gt;getType(TYPE_NAME));
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.43">@path C:/Repos/codon/test/cir/
#include &lt;algorithm&gt;

#include "codon/cir/cir.h"
#include "codon/cir/util/cloning.h"
#include "gtest/gtest.h"

@others
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.44">class CIRCoreTest : public testing::Test {
protected:
  std::unique_ptr&lt;codon::ir::Module&gt; module;
  std::unique_ptr&lt;codon::ir::util::CloneVisitor&gt; cv;

@others
};
</t>
<t tx="ekr.20230509083244.45">  void SetUp() override {
    codon::ir::IdMixin::resetId();
    module = std::make_unique&lt;codon::ir::Module&gt;("test");
    cv = std::make_unique&lt;codon::ir::util::CloneVisitor&gt;(module.get());
  }
</t>
<t tx="ekr.20230509083244.46">@path C:/Repos/codon/test/cir/
#include "test.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, ValueQueryMethodsDelegate) {
  Value *original = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType(), "foo");
  auto originalRef = original-&gt;referenceString();

  auto *fn = module-&gt;Nr&lt;BodiedFunc&gt;();
  fn-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
  Value *replacement = module-&gt;Nr&lt;VarValue&gt;(fn, "baz");
  original-&gt;replaceAll(replacement);

  ASSERT_NE(originalRef, original-&gt;referenceString());
  ASSERT_EQ(original-&gt;referenceString(), replacement-&gt;referenceString());

  ASSERT_EQ(1, original-&gt;getUsedVariables().size());

  replacement = module-&gt;Nr&lt;CallInstr&gt;(replacement);
  original-&gt;replaceAll(replacement);
  ASSERT_EQ(0, original-&gt;getUsedVariables().size());
  ASSERT_EQ(1, original-&gt;getUsedValues().size());
  ASSERT_EQ(module-&gt;getVoidType(), original-&gt;getType());

  replacement = module-&gt;Nr&lt;TypePropertyInstr&gt;(module-&gt;getIntType(),
                                              TypePropertyInstr::Property::SIZEOF);
  original-&gt;replaceAll(replacement);
  ASSERT_EQ(0, original-&gt;getUsedVariables().size());
  ASSERT_EQ(0, original-&gt;getUsedValues().size());
  ASSERT_EQ(1, original-&gt;getUsedTypes().size());
}

TEST_F(CIRCoreTest, ValueReplaceMethodsDelegate) {
  Value *original = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType(), "foo");
  auto originalRef = original-&gt;referenceString();
  auto originalId = original-&gt;getId();
  auto *var = module-&gt;Nr&lt;BodiedFunc&gt;();
  Value *replacement = module-&gt;Nr&lt;VarValue&gt;(var, "baz");
  original-&gt;replaceAll(replacement);

  ASSERT_EQ(1, original-&gt;replaceUsedVariable(var, var));

  auto *val = replacement;
  replacement = module-&gt;Nr&lt;CallInstr&gt;(replacement);
  original-&gt;replaceAll(replacement);
  ASSERT_EQ(1, original-&gt;replaceUsedValue(val, val));

  replacement = module-&gt;Nr&lt;TypePropertyInstr&gt;(module-&gt;getIntType(),
                                              TypePropertyInstr::Property::SIZEOF);
  original-&gt;replaceAll(replacement);
  ASSERT_EQ(1, original-&gt;replaceUsedType(module-&gt;getIntType(), module-&gt;getFloatType()));

  ASSERT_NE(originalId, original-&gt;getId());
  ASSERT_EQ(original-&gt;getId(), replacement-&gt;getId());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.47">@path C:/Repos/codon/test/cir/
#include "test.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, VarQueryMethodsDelegate) {
  Var *original = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  Var *replacement = module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType());
  original-&gt;replaceAll(replacement);

  ASSERT_EQ(module-&gt;getFloatType(), original-&gt;getType());
  ASSERT_EQ(module-&gt;getFloatType(), original-&gt;getUsedTypes().back());
}

TEST_F(CIRCoreTest, VarReplaceMethodsDelegate) {
  Var *original = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  Var *replacement = module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType());

  auto originalId = original-&gt;getId();
  original-&gt;replaceAll(replacement);

  ASSERT_EQ(1, original-&gt;replaceUsedType(module-&gt;getFloatType(), module-&gt;getIntType()));
  ASSERT_NE(originalId, original-&gt;getId());
  ASSERT_EQ(original-&gt;getId(), replacement-&gt;getId());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.48"></t>
<t tx="ekr.20230509083244.49">@path C:/Repos/codon/test/cir/analyze/
#include "test.h"

#include "codon/cir/analyze/dataflow/cfg.h"
#include "codon/cir/analyze/dataflow/dominator.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, DominatorAnalysisSimple) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *start = module-&gt;getBool(false);
  auto *end = module-&gt;getBool(false);

  b-&gt;push_back(start);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::DominatorInspector dom(c.get());
  dom.analyze();

  ASSERT_TRUE(dom.isDominated(end, start));
  ASSERT_FALSE(dom.isDominated(start, end));
}

TEST_F(CIRCoreTest, DominatorAnalysisTernary) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *start = module-&gt;getBool(false);
  auto *middle = module-&gt;getBool(false);
  auto *end =
      module-&gt;Nr&lt;TernaryInstr&gt;(module-&gt;getBool(true), middle, module-&gt;getBool(true));

  b-&gt;push_back(start);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::DominatorInspector dom(c.get());
  dom.analyze();

  ASSERT_TRUE(dom.isDominated(end, start));
  ASSERT_TRUE(dom.isDominated(middle, start));
  ASSERT_FALSE(dom.isDominated(start, end));
  ASSERT_FALSE(dom.isDominated(end, middle));
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.5">class TestInliner : public ir::transform::OperatorPass {
  const std::string KEY = "test-inliner-pass";
  std::string getKey() const override { return KEY; }

  @others
};

</t>
<t tx="ekr.20230509083244.50">@path C:/Repos/codon/test/cir/analyze/
#include "test.h"

#include "codon/cir/analyze/dataflow/cfg.h"
#include "codon/cir/analyze/dataflow/reaching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, RDAnalysisSimple) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *first = module-&gt;getInt(1);
  auto *second = module-&gt;getInt(2);

  auto *start = module-&gt;getBool(false);
  auto *firstAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, first);
  auto *secondAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, second);
  auto *end = module-&gt;getBool(false);

  b-&gt;push_back(start);
  b-&gt;push_back(firstAssign);
  b-&gt;push_back(secondAssign);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::RDInspector rd(c.get());
  rd.analyze();

  auto startRd = rd.getReachingDefinitions(v, start);
  auto firstRd = rd.getReachingDefinitions(v, firstAssign);
  auto secondRd = rd.getReachingDefinitions(v, secondAssign);
  auto endRd = rd.getReachingDefinitions(v, end);
  auto firstRhsRd = rd.getReachingDefinitions(v, first);
  auto secondRhsRd = rd.getReachingDefinitions(v, second);

  ASSERT_EQ(0, startRd.size());
  ASSERT_EQ(1, firstRd.size());
  ASSERT_EQ(1, secondRd.size());
  ASSERT_EQ(1, endRd.size());
  ASSERT_EQ(0, firstRhsRd.size());
  ASSERT_EQ(1, secondRhsRd.size());

  ASSERT_EQ(first-&gt;getId(), *firstRd.begin());
  ASSERT_EQ(second-&gt;getId(), *secondRd.begin());
  ASSERT_EQ(second-&gt;getId(), *endRd.begin());
}

TEST_F(CIRCoreTest, RDAnalysisIfConditional) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");

  auto *trueBranch = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *falseBranch = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *ifFlow = module-&gt;Nr&lt;IfFlow&gt;(module-&gt;getBool(false), trueBranch, falseBranch);
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *first = module-&gt;getInt(1);
  auto *second = module-&gt;getInt(2);

  auto *start = module-&gt;getBool(false);
  auto *firstAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, first);
  auto *secondAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, second);
  auto *end = module-&gt;getBool(false);

  b-&gt;push_back(start);
  b-&gt;push_back(ifFlow);
  trueBranch-&gt;push_back(firstAssign);
  falseBranch-&gt;push_back(secondAssign);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::RDInspector rd(c.get());
  rd.analyze();

  auto startRd = rd.getReachingDefinitions(v, start);
  auto endRd = rd.getReachingDefinitions(v, end);

  ASSERT_EQ(0, startRd.size());
  ASSERT_EQ(2, endRd.size());
  ASSERT_TRUE(endRd.find(first-&gt;getId()) != endRd.end());
  ASSERT_TRUE(endRd.find(second-&gt;getId()) != endRd.end());
}

TEST_F(CIRCoreTest, RDAnalysisTryCatch) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");

  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *except = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *finally = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *tc = module-&gt;Nr&lt;TryCatchFlow&gt;(body, finally);
  tc-&gt;emplace_back(except, nullptr);
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *first = module-&gt;getInt(1);
  auto *second = module-&gt;getInt(2);
  auto *third = module-&gt;getInt(3);

  auto *initial = module-&gt;getInt(0);
  auto *zeroAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, initial);
  auto *start = module-&gt;getBool(false);
  auto *firstAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, first);
  auto *secondAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, second);
  auto *middle = module-&gt;getBool(false);
  auto *thirdAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, third);
  auto *end = module-&gt;getBool(false);

  b-&gt;push_back(start);
  b-&gt;push_back(zeroAssign);
  b-&gt;push_back(tc);
  body-&gt;push_back(firstAssign);
  except-&gt;push_back(thirdAssign);
  finally-&gt;push_back(middle);
  finally-&gt;push_back(secondAssign);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::RDInspector rd(c.get());
  rd.analyze();

  auto startRd = rd.getReachingDefinitions(v, start);
  auto middleRd = rd.getReachingDefinitions(v, middle);
  auto endRd = rd.getReachingDefinitions(v, end);

  ASSERT_EQ(0, startRd.size());
  ASSERT_EQ(1, endRd.size());
  ASSERT_TRUE(endRd.find(second-&gt;getId()) != endRd.end());
  ASSERT_TRUE(middleRd.find(first-&gt;getId()) != endRd.end());
  ASSERT_TRUE(middleRd.find(third-&gt;getId()) != endRd.end());
  ASSERT_TRUE(middleRd.find(initial-&gt;getId()) != endRd.end());
}

TEST_F(CIRCoreTest, RDAnalysisWhileLoop) {
  auto *f = module-&gt;Nr&lt;BodiedFunc&gt;("test_f");

  auto *loopBody = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *whileFlow = module-&gt;Nr&lt;WhileFlow&gt;(module-&gt;getBool(false), loopBody);
  auto *b = module-&gt;Nr&lt;SeriesFlow&gt;();
  f-&gt;setBody(b);

  auto *v = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  f-&gt;push_back(v);

  auto *first = module-&gt;getInt(1);
  auto *second = module-&gt;getInt(2);

  auto *start = module-&gt;getBool(false);
  auto *firstAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, first);
  auto *secondAssign = module-&gt;Nr&lt;AssignInstr&gt;(v, second);
  auto *end = module-&gt;getBool(false);

  b-&gt;push_back(start);
  b-&gt;push_back(firstAssign);
  b-&gt;push_back(whileFlow);
  loopBody-&gt;push_back(secondAssign);
  b-&gt;push_back(end);

  auto c = analyze::dataflow::buildCFGraph(f);
  analyze::dataflow::RDInspector rd(c.get());
  rd.analyze();

  auto startRd = rd.getReachingDefinitions(v, start);
  auto endRd = rd.getReachingDefinitions(v, end);

  ASSERT_EQ(0, startRd.size());
  ASSERT_EQ(2, endRd.size());
  ASSERT_TRUE(endRd.find(first-&gt;getId()) != endRd.end());
  ASSERT_TRUE(endRd.find(second-&gt;getId()) != endRd.end());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.51"></t>
<t tx="ekr.20230509083244.52">@path C:/Repos/codon/test/cir/transform/
#include "test.h"

#include "codon/cir/transform/manager.h"
#include "codon/cir/transform/pass.h"

using namespace codon::ir;

std::string ANALYSIS_KEY = "**test_analysis**";
std::string PASS_KEY = "**test_pass**";

class DummyResult : public analyze::Result {};

@others
int DummyPass::runCounter = 0;

TEST_F(CIRCoreTest, PassManagerNoInvalidations) {
  int counter = 0;

  auto manager =
      std::make_unique&lt;transform::PassManager&gt;(transform::PassManager::Init::EMPTY);
  manager-&gt;registerAnalysis(std::make_unique&lt;DummyAnalysis&gt;(counter));
  manager-&gt;registerPass(std::make_unique&lt;DummyPass&gt;(counter, ANALYSIS_KEY), "",
                        {ANALYSIS_KEY});
  manager-&gt;run(module.get());

  ASSERT_EQ(0, DummyAnalysis::runCounter);
  ASSERT_EQ(1, DummyPass::runCounter);
}

TEST_F(CIRCoreTest, PassManagerInvalidations) {
  int counter = 0;

  auto manager =
      std::make_unique&lt;transform::PassManager&gt;(transform::PassManager::Init::EMPTY);
  manager-&gt;registerAnalysis(std::make_unique&lt;DummyAnalysis&gt;(counter));
  manager-&gt;registerPass(std::make_unique&lt;DummyPass&gt;(counter, ANALYSIS_KEY), "",
                        {ANALYSIS_KEY}, {ANALYSIS_KEY});
  manager-&gt;registerPass(std::make_unique&lt;DummyPass&gt;(counter, ANALYSIS_KEY), "",
                        {ANALYSIS_KEY});

  manager-&gt;run(module.get());

  ASSERT_EQ(2, DummyAnalysis::runCounter);
  ASSERT_EQ(3, DummyPass::runCounter);
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.53">class DummyAnalysis : public analyze::Analysis {
private:
  int &amp;counter;

public:
  static int runCounter;

  explicit DummyAnalysis(int &amp;counter) : counter(counter) {}

  std::string getKey() const override { return ANALYSIS_KEY; }

  std::unique_ptr&lt;analyze::Result&gt; run(const Module *) override {
    runCounter = counter++;
    return std::make_unique&lt;DummyResult&gt;();
  }
};

</t>
<t tx="ekr.20230509083244.54">int DummyAnalysis::runCounter = 0;

</t>
<t tx="ekr.20230509083244.55">class DummyPass : public transform::Pass {
private:
  int &amp;counter;
  std::string required;

public:
  static int runCounter;

  explicit DummyPass(int &amp;counter, std::string required)
      : counter(counter), required(std::move(required)) {}

  std::string getKey() const override { return PASS_KEY; }

@others
};

</t>
<t tx="ekr.20230509083244.56">  void run(Module *) override {
    runCounter = counter++;
    ASSERT_TRUE(getAnalysisResult&lt;DummyResult&gt;(required));
  }
</t>
<t tx="ekr.20230509083244.57"></t>
<t tx="ekr.20230509083244.58">@path C:/Repos/codon/test/cir/types/
#include "test.h"

#include &lt;algorithm&gt;

using namespace codon::ir;

TEST_F(CIRCoreTest, RecordTypeQuery) {
  auto MEMBER_NAME = "1";
  auto *type = module-&gt;Nr&lt;types::RecordType&gt;(
      "foo", std::vector&lt;types::Type *&gt;{module-&gt;getIntType()});

  ASSERT_EQ(module-&gt;getIntType(), type-&gt;getMemberType(MEMBER_NAME));
  ASSERT_EQ(0, type-&gt;getMemberIndex(MEMBER_NAME));

  ASSERT_EQ(1, std::distance(type-&gt;begin(), type-&gt;end()));
  ASSERT_EQ(module-&gt;getIntType(), type-&gt;front().getType());

  MEMBER_NAME = "baz";
  type-&gt;realize({module-&gt;getIntType()}, {MEMBER_NAME});

  ASSERT_TRUE(type-&gt;isAtomic());

  ASSERT_EQ(1, type-&gt;getUsedTypes().size());
  ASSERT_EQ(module-&gt;getIntType(), type-&gt;getUsedTypes()[0]);
}

TEST_F(CIRCoreTest, RefTypeQuery) {
  auto MEMBER_NAME = "1";
  auto *contents = module-&gt;Nr&lt;types::RecordType&gt;(
      "foo", std::vector&lt;types::Type *&gt;{module-&gt;getIntType()});
  auto *type = module-&gt;Nr&lt;types::RefType&gt;("baz", contents);

  ASSERT_EQ(module-&gt;getIntType(), type-&gt;getMemberType(MEMBER_NAME));
  ASSERT_EQ(0, type-&gt;getMemberIndex(MEMBER_NAME));

  ASSERT_EQ(1, std::distance(type-&gt;begin(), type-&gt;end()));
  ASSERT_EQ(module-&gt;getIntType(), type-&gt;front().getType());

  MEMBER_NAME = "baz";
  type-&gt;realize({module-&gt;getIntType()}, {MEMBER_NAME});

  ASSERT_FALSE(type-&gt;isAtomic());

  ASSERT_EQ(1, type-&gt;getUsedTypes().size());
  ASSERT_EQ(contents, type-&gt;getUsedTypes()[0]);
}

TEST_F(CIRCoreTest, FuncTypeQuery) {
  auto *type = module-&gt;Nr&lt;types::FuncType&gt;(
      "foo", module-&gt;getIntType(), std::vector&lt;types::Type *&gt;{module-&gt;getFloatType()});

  ASSERT_EQ(1, std::distance(type-&gt;begin(), type-&gt;end()));
  ASSERT_EQ(module-&gt;getFloatType(), type-&gt;front());

  ASSERT_EQ(2, type-&gt;getUsedTypes().size());
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.59"></t>
<t tx="ekr.20230509083244.6">void handle(ir::CallInstr *v) override {
  auto *M = v-&gt;getModule();
  auto *f = ir::cast&lt;ir::BodiedFunc&gt;(ir::util::getFunc(v-&gt;getCallee()));
  auto *neg = M-&gt;getOrRealizeMethod(M-&gt;getIntType(), ir::Module::NEG_MAGIC_NAME,
                                    {M-&gt;getIntType()});
  if (!f)
    return;
  auto name = f-&gt;getUnmangledName();
  if (name.find("inline_me") != std::string::npos) {
    auto aggressive = name.find("aggressive") != std::string::npos;
    auto res = ir::util::inlineCall(v, aggressive);
    if (!res)
      return;
    for (auto *var : res.newVars)
      ir::cast&lt;ir::BodiedFunc&gt;(getParentFunc())-&gt;push_back(var);
    v-&gt;replaceAll(ir::util::call(neg, {res.result}));
  }
}
</t>
<t tx="ekr.20230509083244.60">@path C:/Repos/codon/test/cir/util/
#include "test.h"

#include "codon/cir/util/matching.h"

using namespace codon::ir;

TEST_F(CIRCoreTest, MatchingEquivalentVar) {
  auto *first = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *second = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *third = module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType());
  ASSERT_TRUE(util::match(first, second));
  ASSERT_FALSE(util::match(first, third));
}

TEST_F(CIRCoreTest, MatchingNonEquivalentVar) {
  auto *first = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *second = module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType());
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingEquivalentFunc) {
  {
    auto *first = module-&gt;Nr&lt;BodiedFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;BodiedFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    first-&gt;setJIT();
    second-&gt;setJIT();

    ASSERT_TRUE(util::match(first, second));
  }
  {
    auto *first = module-&gt;Nr&lt;ExternalFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;ExternalFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    first-&gt;setUnmangledName("baz");
    second-&gt;setUnmangledName("baz");

    ASSERT_TRUE(util::match(first, second));
  }
  {
    auto *first = module-&gt;Nr&lt;LLVMFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;LLVMFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    ASSERT_TRUE(util::match(first, second));
  }
}

TEST_F(CIRCoreTest, MatchingNonEquivalentFunc) {
  {
    auto *first = module-&gt;Nr&lt;BodiedFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;BodiedFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    first-&gt;setJIT();

    ASSERT_FALSE(util::match(first, second));
  }
  {
    auto *first = module-&gt;Nr&lt;ExternalFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;ExternalFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    first-&gt;setUnmangledName("baz");
    second-&gt;setUnmangledName("bar");

    ASSERT_FALSE(util::match(first, second));
  }
  {
    auto *first = module-&gt;Nr&lt;LLVMFunc&gt;();
    first-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});
    auto *second = module-&gt;Nr&lt;LLVMFunc&gt;();
    second-&gt;realize(module-&gt;unsafeGetDummyFuncType(), {});

    first-&gt;setLLVMLiterals({types::Generic(1)});

    ASSERT_FALSE(util::match(first, second));
  }
}

TEST_F(CIRCoreTest, MatchingAnyValue) {
  auto *first = module-&gt;Nr&lt;VarValue&gt;(module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType()));
  ASSERT_TRUE(util::match(first, module-&gt;Nr&lt;util::AnyValue&gt;()));
}

TEST_F(CIRCoreTest, MatchingVarValue) {
  auto *first = module-&gt;Nr&lt;VarValue&gt;(module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType()));
  auto *second = module-&gt;Nr&lt;VarValue&gt;(module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType()));
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVar(module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType()));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingPointerValue) {
  auto *first = module-&gt;Nr&lt;PointerValue&gt;(module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType()));
  auto *second = module-&gt;Nr&lt;PointerValue&gt;(module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType()));
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVar(module-&gt;Nr&lt;Var&gt;(module-&gt;getFloatType()));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingSeriesFlow) {
  auto *first = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *second = module-&gt;Nr&lt;SeriesFlow&gt;();

  first-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType()));
  second-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType()));
  ASSERT_TRUE(util::match(first, second));
  second-&gt;push_back(module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType()));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingIfFlow) {
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *tVal = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *first = module-&gt;Nr&lt;IfFlow&gt;(cond, tVal);
  auto *second = module-&gt;Nr&lt;IfFlow&gt;(cv-&gt;clone(cond), cast&lt;Flow&gt;(cv-&gt;clone(tVal)));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setFalseBranch(cast&lt;Flow&gt;(cv-&gt;clone(tVal)));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingForFlow) {
  auto *body = module-&gt;Nr&lt;SeriesFlow&gt;();
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *iter = module-&gt;Nr&lt;StringConst&gt;("hello", module-&gt;getStringType());
  auto *first = module-&gt;Nr&lt;ForFlow&gt;(iter, body, var);
  auto *second =
      module-&gt;Nr&lt;ForFlow&gt;(cv-&gt;clone(iter), cast&lt;Flow&gt;(cv-&gt;clone(body)), cv-&gt;clone(var));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setIter(module-&gt;Nr&lt;StringConst&gt;("foo", module-&gt;getStringType()));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingIntConst) {
  auto *first = module-&gt;Nr&lt;IntConst&gt;(0, module-&gt;getIntType());
  auto *second = module-&gt;Nr&lt;IntConst&gt;(0, module-&gt;getIntType());
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVal(2);
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingFloatConst) {
  auto *first = module-&gt;Nr&lt;FloatConst&gt;(0.0, module-&gt;getFloatType());
  auto *second = module-&gt;Nr&lt;FloatConst&gt;(0.0, module-&gt;getFloatType());
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVal(2.0);
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingBoolConst) {
  auto *first = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType());
  auto *second = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType());
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVal(true);
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingStringConst) {
  auto *first = module-&gt;Nr&lt;StringConst&gt;("hi", module-&gt;getStringType());
  auto *second = module-&gt;Nr&lt;StringConst&gt;("hi", module-&gt;getStringType());
  ASSERT_TRUE(util::match(first, second));
  first-&gt;setVal("bye");
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingAssignInstr) {
  auto *var = module-&gt;Nr&lt;Var&gt;(module-&gt;getIntType());
  auto *val = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *first = module-&gt;Nr&lt;AssignInstr&gt;(var, val);
  auto *second = module-&gt;Nr&lt;AssignInstr&gt;(cv-&gt;clone(var), cv-&gt;clone(val));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setRhs(module-&gt;Nr&lt;IntConst&gt;(5, module-&gt;getIntType()));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingExtractInstr) {
  auto FIELD = "foo";
  auto *type = cast&lt;types::RecordType&gt;(module-&gt;unsafeGetMemberedType("**internal**"));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *val = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *first = module-&gt;Nr&lt;ExtractInstr&gt;(val, FIELD);
  auto *second = module-&gt;Nr&lt;ExtractInstr&gt;(cv-&gt;clone(val), FIELD);

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setField("");
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingInsertInstr) {
  auto FIELD = "foo";
  auto *type = cast&lt;types::RecordType&gt;(module-&gt;unsafeGetMemberedType("**internal**"));
  type-&gt;realize({module-&gt;getIntType()}, {FIELD});
  auto *var = module-&gt;Nr&lt;Var&gt;(type);
  auto *val = module-&gt;Nr&lt;VarValue&gt;(var);
  auto *toInsert = module-&gt;Nr&lt;IntConst&gt;(1, module-&gt;getIntType());
  auto *first = module-&gt;Nr&lt;InsertInstr&gt;(val, FIELD, toInsert);
  auto *second = module-&gt;Nr&lt;InsertInstr&gt;(cv-&gt;clone(val), FIELD, cv-&gt;clone(toInsert));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setField("");
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingCallInstr) {
  auto *type = module-&gt;unsafeGetDummyFuncType();
  auto *func = module-&gt;Nr&lt;BodiedFunc&gt;();
  func-&gt;realize(type, {});
  auto *func2 = module-&gt;Nr&lt;BodiedFunc&gt;();
  func2-&gt;realize(module-&gt;unsafeGetFuncType("baz", module-&gt;getIntType(), {}), {});

  auto *funcVal = module-&gt;Nr&lt;VarValue&gt;(func);
  auto *first = module-&gt;Nr&lt;CallInstr&gt;(funcVal);
  auto *second = module-&gt;Nr&lt;CallInstr&gt;(cv-&gt;clone(funcVal));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setCallee(module-&gt;Nr&lt;VarValue&gt;(func2));
  ASSERT_FALSE(util::match(first, second));
}

TEST_F(CIRCoreTest, MatchingTernaryInstr) {
  auto *trueValue = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());
  auto *falseValue = module-&gt;Nr&lt;BoolConst&gt;(false, module-&gt;getBoolType());
  auto *cond = module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType());

  auto *first = module-&gt;Nr&lt;TernaryInstr&gt;(cond, trueValue, falseValue);
  auto *second = module-&gt;Nr&lt;TernaryInstr&gt;(cv-&gt;clone(cond), cv-&gt;clone(trueValue),
                                          cv-&gt;clone(falseValue));

  ASSERT_TRUE(util::match(first, second));
  second-&gt;setFalseValue(module-&gt;Nr&lt;BoolConst&gt;(true, module-&gt;getBoolType()));
  ASSERT_FALSE(util::match(first, second));
}
@language c
@tabwidth -4
</t>
<t tx="ekr.20230509083244.61"></t>
<t tx="ekr.20230509083244.62">@path C:/Repos/codon/test/core/
@language unknown_language
@test
def t1():
    def baz(x, y, z = 3):
        return x, y, z
    assert baz(1, 2, 3) == (1, 2, 3)
    assert baz(1, 3) == (1, 3, 3)
    assert baz(z = 'z', y = 'y', x = 'x') == ('x', 'y', 'z')
    assert baz(y = 'y', x = 'x') == ('x', 'y', 3)
    assert baz('x', y = 'y') == ('x', 'y', 3)
t1()

class A:
    def foo(self: A, x = 3, y = 'hello'):
        return x, y

@test
def t2():
    assert A().foo(y = 3.14, x = 42) == (42, 3.14)
t2()

def g[T](a: T, b: optional[T] = None):
    b: T = b if b else T()
    return a, b

@test
def t3():
    assert g(99, 4242) == (99, 4242)
    assert g(99) == (99, 0)
    assert (None |&gt; g(a=1, b=...)) == (1, 0)
t3()

def _unwrap(opt: Optional[T], T: type) -&gt; T:
    return opt

def foo(x: int, y: int, z: optional[list[float]]):
    xs = str(x)
    ys = str(y)
    zs = str(_unwrap(z)) if z else 'None'
    return xs, ys, zs

@test
def t4():
    assert foo(1, 2, [3.14]) == ('1', '2', '[3.14]')
    assert foo(77, 99, None) == ('77', '99', 'None')
t4()

class A:
    def __init__(self: A):
        pass

    def foo(x: int, y: int, z: optional[list[float]]):
        xs = str(x)
        ys = str(y)
        zs = str(_unwrap(z)) if z else 'None'
        return xs, ys, zs

    # TODO: def bar[S](self: A, x: S, y: S, z: optional[type(S() + 0.0)] = None)
    def bar[S](self: A, x: S, y: S, z: optional[S] = None):
        xs = str(x)
        ys = str(y)
        zs = str(_unwrap(z)) if z else 'None'
        return xs, ys, zs

@test
def t5():
    assert A.foo(1, 2, [3.14]) == ('1', '2', '[3.14]')
    assert A.foo(77, 99, None) == ('77', '99', 'None')

    assert A().bar(1.0, 2.0, 3.14) == ('1', '2', '3.14')
    assert A().bar(77, 99, None) == ('77', '99', 'None')
    assert A().bar(77, 99) == ('77', '99', 'None')

    assert (1 |&gt; foo(2, [3.14])) == ('1', '2', '[3.14]')
    assert (1 |&gt; foo(77, ..., None)) == ('77', '1', 'None')
    assert (None |&gt; foo(-5, -1, ...)) == ('-5', '-1', 'None')
    assert ([1.23] |&gt; foo(-5, -1, ...)) == ('-5', '-1', '[1.23]')
t5()

# test auto-iter
@test
def t6():
    assert list('abc') == ['a', 'b', 'c']

    def it1[T](v: generator[T]):
        return list(v)

    def it2[T](v: T):
        return list(v)

    def it3[T](v: generator[T] = 'xyz'):
        return list(v)

    assert it1([1, 2, 3]) == [1, 2, 3]
    assert it2(iter([1.1, 2.2, 3.3])) == [1.1, 2.2, 3.3]
    assert it3() == ['x', 'y', 'z']
t6()

class B[T]:
    a: T
    b: tuple[int,int,int]

    def __init__(self: B[T], y: T):
        self.a = y
        self.b = 0, 0, 0

    def __init__(self: B[T], y: T, foo: int):
        self.a = y
        self.b = foo, 1, 0

    def __init__(self: B[T], x: list[T], a: int, b: int, c: int):
        self.a = x[0]
        self.b = a, b, c

    def __init__(self: B[T], a: T, b: T):
        self.a, self.b = a + b, (-1, -1, -1)

    @property
    def val(self: B[T]):
        return self.a, self.b

@test
def test_named_construct1(_):
    assert B(10).val == (10, (0, 0, 0))
    assert B(y=-10).val == (-10, (0, 0, 0))
    assert B[bool](y=False).val == (False, (0, 0, 0))
    assert B(b=2, x=[3.14], c=3, a=1).val == (3.14, (1, 2, 3))
    assert B(x=[3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert B([3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert B([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert B[float]([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert B([3.14], 1, 2, c=3).val == (3.14, (1, 2, 3))
    assert B(foo=42, y='hello').val == ('hello', (42, 1, 0))
    assert B(a='a', b='b').val == ('ab', (-1, -1, -1))
    assert B(b='b', a='a').val == ('ab', (-1, -1, -1))
test_named_construct1(0)

@tuple
class C:
    a: float
    b: tuple[int,int,int]

    def __new__(y: float) -&gt; C:
        return (y, (0, 0, 0))

    def __new__(y: float, foo: int) -&gt; C:
        return (y, (foo, 1, 0))

    def __new__(x: list[float], a: int, b: int, c: int) -&gt; C:
        return (x[0], (a, b, c))

    def __new__(a: int, b: int):
        return (a, b)

    @property
    def val(self: C):
        return self.a, self.b

@test
def test_named_construct2(_):
    assert C(10.0).val == (10.0, (0, 0, 0))
    assert C(y=-10.0).val == (-10.0, (0, 0, 0))
    assert C(b=2, x=[3.14], c=3, a=1).val == (3.14, (1, 2, 3))
    assert C(x=[3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert C([3.14], b=2, c=3, a=1).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, b=2, c=3).val == (3.14, (1, 2, 3))
    assert C([3.14], 1, 2, c=3).val == (3.14, (1, 2, 3))
    assert C(foo=42, y=-4.2).val == (-4.2, (42, 1, 0))
    assert C(a=111, b=222) == (111, 222)
    assert C(b=222, a=111) == (111, 222)
test_named_construct2(0)
</t>
<t tx="ekr.20230509083244.63">@path C:/Repos/codon/test/core/
@language unknown_language
@test
def t1():
    assert 2 + 2 == 4
    assert 3.14 * 2 == 6.28
    assert 2 + 3*2 == 8
    assert 1.0/0 == float('inf')
    assert str(0.0/0) == 'nan'

    assert 5 // 2 == 2
    assert 5 / 2 == 2.5
    assert 5.0 // 2.0 == 2
    assert 5.0 / 2.0 == 2.5
    assert 5 // 2.0 == 2
    assert 5 / 2.0 == 2.5
    assert 5.0 // 2 == 2
    assert 5.0 / 2 == 2.5
    assert int(Int[128](5) // Int[128](2)) == 2
    assert Int[128](5) / Int[128](2) == 2.5
t1()

@test
def test_popcnt():
    assert (42).popcnt() == 3
    assert (123).popcnt() == 6
    assert (0).popcnt() == 0
    assert int.popcnt(-1) == 64
    assert u8(-1).popcnt() == 8
    assert (UInt[1024](0xfffffffffffffff3) * UInt[1024](0xfffffffffffffff3)).popcnt() == 4
    assert UInt[128](-1).popcnt() == 128
test_popcnt()

@test
def test_conversions():
    # int -&gt; int, float, bool, str
    assert int(-42) == -42
    assert float(-42) == -42.0
    assert bool(0) == False
    assert bool(-1) == bool(1) == True
    assert str(-42) == '-42'

    # float -&gt; int, float, bool, str
    assert int(-4.2) == -4
    assert int(4.2) == 4
    assert float(-4.2) == -4.2
    assert bool(0.0) == False
    assert bool(-0.1) == bool(0.1) == True
    assert str(-4.2) == '-4.2'

    # bool -&gt; int, float, bool, str
    assert int(False) == 0
    assert int(True) == 1
    assert float(False) == 0.0
    assert float(True) == 1.0
    assert bool(False) == False
    assert bool(True) == True
    assert str(False) == 'False'
    assert str(True) == 'True'

    # byte -&gt; int, float, bool, str
    assert int(byte(42)) == 42
    assert float(byte(42)) == 42.0
    assert bool(byte(0)) == False
    assert bool(byte(42)) == True
    assert str(byte(42)) == '*'

    # intN -&gt; int, float, bool, str | N &lt; 64
    assert int(i32(-42)) == -42
    assert float(i32(-42)) == -42.0
    assert bool(i32(0)) == False
    assert bool(i32(-1)) == bool(i32(1)) == True
    assert str(i32(-42)) == '-42'

    # intN -&gt; int, float, bool, str | N == 64
    assert int(Int[64](-42)) == -42
    assert float(Int[64](-42)) == -42.0
    assert bool(Int[64](0)) == False
    assert bool(Int[64](-1)) == bool(Int[64](1)) == True
    assert str(Int[64](-42)) == '-42'

    # intN -&gt; int, float, bool, str | N &gt; 64
    assert int(Int[80](-42)) == -42
    assert float(Int[80](-42)) == -42.0
    assert bool(Int[80](0)) == False
    assert bool(Int[80](-1)) == bool(Int[80](1)) == True
    assert str(Int[80](-42)) == '-42'

    # uintN -&gt; int, float, bool, str | N &lt; 64
    assert int(u32(42)) == 42
    assert float(u32(42)) == 42.0
    assert bool(u32(0)) == False
    assert bool(u32(42)) == True
    assert str(u32(42)) == '42'

    # uintN -&gt; int, float, bool, str | N == 64
    assert int(UInt[64](42)) == 42
    assert float(UInt[64](42)) == 42.0
    assert bool(UInt[64](0)) == False
    assert bool(UInt[64](42)) == True
    assert str(UInt[64](42)) == '42'

    # uintN -&gt; int, float, bool, str | N &gt; 64
    assert int(UInt[80](42)) == 42
    assert float(UInt[80](42)) == 42.0
    assert bool(UInt[80](0)) == False
    assert bool(Int[80](42)) == True
    assert str(Int[80](42)) == '42'
test_conversions()

@test
def test_int_pow():
    @nonpure
    def f(n):
        return n

    assert f(3) ** f(2) == 9
    assert f(27) ** f(7) == 10460353203
    assert f(-27) ** f(7) == -10460353203
    assert f(-27) ** f(6) == 387420489
    assert f(1) ** f(0) == 1
    assert f(1) ** f(1000) == 1
    assert f(0) ** f(3) == 0
    assert f(0) ** f(0) == 1

    T1 = Int[512]
    assert f(T1(3)) ** f(T1(2)) == T1(9)
    assert f(T1(27)) ** f(T1(7)) == T1(10460353203)
    assert f(T1(-27)) ** f(T1(7)) == T1(-10460353203)
    assert f(T1(-27)) ** f(T1(6)) == T1(387420489)
    assert f(T1(1)) ** f(T1(0)) == T1(1)
    assert f(T1(1)) ** f(T1(1000)) == T1(1)
    assert f(T1(0)) ** f(T1(3)) == T1(0)
    assert f(T1(0)) ** f(T1(0)) == T1(1)
    assert str(f(T1(31)) ** f(T1(31))) == '17069174130723235958610643029059314756044734431'
    assert str(f(T1(-31)) ** f(T1(31))) == '-17069174130723235958610643029059314756044734431'

    T2 = UInt[200]
    assert f(T2(3)) ** f(T2(2)) == T2(9)
    assert f(T2(27)) ** f(T2(7)) == T2(10460353203)
    assert f(T2(1)) ** f(T2(0)) == T2(1)
    assert f(T2(1)) ** f(T2(1000)) == T2(1)
    assert f(T2(0)) ** f(T2(3)) == T2(0)
    assert f(T2(0)) ** f(T2(0)) == T2(1)
    assert str(f(T2(31)) ** f(T2(31))) == '17069174130723235958610643029059314756044734431'
test_int_pow()
</t>
<t tx="ekr.20230509083244.64">@path C:/Repos/codon/test/core/
@language unknown_language
# Python-specific

@test
def test_min_max():
    assert max(2, 1, 1, 1, 1) == 2
    assert max(1, 2, 1, 1, 1) == 2
    assert max(1, 1, 2, 1, 1) == 2
    assert max(1, 1, 1, 2, 1) == 2
    assert max(1, 1, 1, 1, 2) == 2
    assert max(2, 1, 1, 1) == 2
    assert max(1, 2, 1, 1) == 2
    assert max(1, 1, 2, 1) == 2
    assert max(1, 1, 1, 2) == 2
    assert max(2, 1, 1) == 2
    assert max(1, 2, 1) == 2
    assert max(1, 1, 2) == 2
    assert max(2, 1) == 2
    assert max(1, 2) == 2

    assert min(2, 1, 1, 1, 1) == 1
    assert min(1, 2, 1, 1, 1) == 1
    assert min(1, 1, 2, 1, 1) == 1
    assert min(1, 1, 1, 2, 1) == 1
    assert min(1, 1, 1, 1, 2) == 1
    assert min(2, 1, 1, 1) == 1
    assert min(1, 2, 1, 1) == 1
    assert min(1, 1, 2, 1) == 1
    assert min(1, 1, 1, 2) == 1
    assert min(2, 1, 1) == 1
    assert min(1, 2, 1) == 1
    assert min(1, 1, 2) == 1
    assert min(2, 1) == 1
    assert min(1, 2) == 1

    assert max(0, 1, 1, 1, 1) == 1
    assert max(1, 0, 1, 1, 1) == 1
    assert max(1, 1, 0, 1, 1) == 1
    assert max(1, 1, 1, 0, 1) == 1
    assert max(1, 1, 1, 1, 0) == 1
    assert max(0, 1, 1, 1) == 1
    assert max(1, 0, 1, 1) == 1
    assert max(1, 1, 0, 1) == 1
    assert max(1, 1, 1, 0) == 1
    assert max(0, 1, 1) == 1
    assert max(1, 0, 1) == 1
    assert max(1, 1, 0) == 1
    assert max(0, 1) == 1
    assert max(1, 0) == 1

    assert min(0, 1, 1, 1, 1) == 0
    assert min(1, 0, 1, 1, 1) == 0
    assert min(1, 1, 0, 1, 1) == 0
    assert min(1, 1, 1, 0, 1) == 0
    assert min(1, 1, 1, 1, 0) == 0
    assert min(0, 1, 1, 1) == 0
    assert min(1, 0, 1, 1) == 0
    assert min(1, 1, 0, 1) == 0
    assert min(1, 1, 1, 0) == 0
    assert min(0, 1, 1) == 0
    assert min(1, 0, 1) == 0
    assert min(1, 1, 0) == 0
    assert min(0, 1) == 0
    assert min(1, 0) == 0

    assert min(a*a for a in range(3)) == 0
    assert max(a*a for a in range(3)) == 4
    assert min([0, 2, -1]) == -1
    assert max([0, 2, -1]) == 2

@test
def test_map_filter():
    assert list(map(lambda i: i+1, (i*2 for i in range(5)))) == [1, 3, 5, 7, 9]
    assert list(map(lambda i: i+1, (i*2 for i in range(0)))) == []
    assert list(map(lambda i: i//2, map(lambda i: i-1, map(lambda i: i+1, (i*2 for i in range(5)))))) == [0, 1, 2, 3, 4]
    def f(x: int) -&gt; int:
        return x - 1
    def g(x: int) -&gt; int:
        return x + 1
    assert list(map(f, map(g, (i*2 for i in range(5))))) == [0, 2, 4, 6, 8]

    def h(x: list[int]):
        return x
    assert h(list(map(lambda i: i-1, map(lambda i: i+1, range(5))))) == [0, 1, 2, 3, 4]

    assert list(filter(lambda i: i % 2 == 0, range(5))) == [0, 2, 4]
    assert list(filter(lambda i: i % 2 == 1, filter(lambda i: i % 2 == 0, range(5)))) == []

    assert list(filter(lambda i: i%2 == 0, map(lambda i: i*i, range(10)))) == [0, 4, 16, 36, 64]

@test
def test_gen_builtins():
    assert sum([1, 2, 3]) == 6
    assert sum([1, 2, 3], 0.5) == 6.5
    assert sum([True, False, True, False, True], 0.5) == 3.5
    assert sum(List[float]()) == 0
    assert sum(i/2 for i in range(10)) == 22.5

    def g1():
        yield 1.5
        yield 2.5
        return
        yield 3.5

    assert sum(g1(), 10) == 14.0

    def g2():
        yield True
        yield False
        yield True

    assert sum(g2()) == 2

    class A:
        iadd_count = 0
        n: int

        def __init__(self, n):
            self.n = n

        def __add__(self, other):
            return A(self.n + other.n)

        def __iadd__(self, other):
            A.iadd_count += 1
            self.n += other.n
            return self

    assert sum((A(i) for i in range(5)), A(100)).n == 110
    assert A.iadd_count == 0

    def g3(a, b):
        for i in range(10):
            yield a
        yield b

    assert all([True, True])
    assert all(i for i in range(0))
    assert not all([True, False])
    assert all(List[str]())
    assert all(g3(True, True))
    assert not all(g3(True, False))
    assert not all(g3(False, True))
    assert not all(g3(False, False))

    assert any([True, True])
    assert not any(i for i in range(0))
    assert not any([False, False])
    assert not any(List[bool]())
    assert any(g3(True, True))
    assert any(g3(True, False))
    assert any(g3(False, True))
    assert not any(g3(False, False))

@test
def test_int_format():
    n = 0
    assert (str(n), bin(n), oct(n), hex(n)) == ('0', '0b0', '0o0', '0x0')

    n = -1
    assert (str(n), bin(n), oct(n), hex(n)) == ('-1', '-0b1', '-0o1', '-0x1')

    n = 12345
    assert (str(n), bin(n), oct(n), hex(n)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    n = -12345
    assert (str(n), bin(n), oct(n), hex(n)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    # this one is different than Python due to 64-bit ints
    n = 0x8000000000000000
    assert (str(n), bin(n), oct(n), hex(n)) == ('-9223372036854775808', '-0b1000000000000000000000000000000000000000000000000000000000000000', '-0o1000000000000000000000', '-0x8000000000000000')

    n = 0x7fffffffffffffff
    assert (str(n), bin(n), oct(n), hex(n)) == ('9223372036854775807', '0b111111111111111111111111111111111111111111111111111111111111111', '0o777777777777777777777', '0x7fffffffffffffff')

    m = i32(0)
    assert (str(m), bin(m), oct(m), hex(m)) == ('0', '0b0', '0o0', '0x0')

    m = i32(-1)
    assert (str(m), bin(m), oct(m), hex(m)) == ('-1', '-0b1', '-0o1', '-0x1')

    m = i32(12345)
    assert (str(m), bin(m), oct(m), hex(m)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    m = i32(-12345)
    assert (str(m), bin(m), oct(m), hex(m)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    k = Int[128](0)
    assert (str(k), bin(k), oct(k), hex(k)) == ('0', '0b0', '0o0', '0x0')

    k = Int[128](-1)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-1', '-0b1', '-0o1', '-0x1')

    k = Int[128](12345)
    assert (str(k), bin(k), oct(k), hex(k)) == ('12345', '0b11000000111001', '0o30071', '0x3039')

    k = Int[128](-12345)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-12345', '-0b11000000111001', '-0o30071', '-0x3039')

    # this one is different than Python due to 64-bit ints
    k = Int[128](0x8000000000000000)
    assert (str(k), bin(k), oct(k), hex(k)) == ('-9223372036854775808', '-0b1000000000000000000000000000000000000000000000000000000000000000', '-0o1000000000000000000000', '-0x8000000000000000')

    k = Int[128](0x7fffffffffffffff)
    assert (str(k), bin(k), oct(k), hex(k)) == ('9223372036854775807', '0b111111111111111111111111111111111111111111111111111111111111111', '0o777777777777777777777', '0x7fffffffffffffff')

class A:
    def __len__(self):
        return 42
    def __getitem__(self, idx):
        return idx

@test
def test_reversed():
    assert list(reversed([1,2,3])) == [3,2,1]
    assert list(reversed('abc')) == ['c','b','a']
    assert list(reversed('')) == []
    assert list(reversed(A())) == list(reversed(range(42)))

@test
def test_divmod():
    import sys, math
    assert divmod(12, 7) == (1, 5)
    assert divmod(-12, 7) == (-2, 2)
    assert divmod(12, -7) == (-2, -2)
    assert divmod(-12, -7) == (1, -5)

    assert divmod(i32(12), i32(7)) == (i32(1), i32(5))
    assert divmod(i32(-12), i32(7)) == (i32(-2), i32(2))
    assert divmod(i32(12), i32(-7)) == (i32(-2), i32(-2))
    assert divmod(i32(-12), i32(-7)) == (i32(1), i32(-5))

    assert divmod(u32(12), u32(7)) == (u32(1), u32(5))

    i128 = Int[128]
    assert divmod(i128(12), i128(7)) == (i128(1), i128(5))
    assert divmod(i128(-12), i128(7)) == (i128(-2), i128(2))
    assert divmod(i128(12), i128(-7)) == (i128(-2), i128(-2))
    assert divmod(i128(-12), i128(-7)) == (i128(1), i128(-5))

    class X:
        n: int
        def __floordiv__(self, other: X):
            return X(self.n // other.n)
        def __mod__(self, other: X):
            return X(self.n % other.n)
        def __eq__(self, other: X):
            return self.n == other.n
        def __nq__(self, other: X):
            return self.n != other.n
    assert divmod(X(12), X(7)) == (X(1), X(5))

    # following is invalid in our case due to 64-bit ints
    # print divmod(-sys.maxsize-1, -1), (sys.maxsize+1, 0)

    for num, denom, exp_result in [ (3.25, 1.0, (3.0, 0.25)),
                                    (-3.25, 1.0, (-4.0, 0.75)),
                                    (3.25, -1.0, (-4.0, -0.75)),
                                    (-3.25, -1.0, (3.0, -0.25))]:
        result = divmod(num, denom)
        assert math.isclose(result[0], exp_result[0])
        assert math.isclose(result[1], exp_result[1])

@test
def test_pow():
    assert pow(3, 4) == 81
    assert pow(-3, 3) == -27
    assert pow(1, 0) == 1
    assert pow(-1, 0) == 1
    assert pow(0, 0) == 1
    assert pow(12, 12, 42) == 36
    assert pow(1234, 4321, 99) == 46
    assert pow(9999, 9999, 2) == 1
    assert pow(0, 0, 1) == 0

    try:
        pow(1, -1, 2)
        assert False
    except ValueError as e:
        assert 'negative' in str(e)

    try:
        pow(1, 1, 0)
        assert False
    except ValueError as e:
        assert 'cannot be 0' in str(e)

    assert pow(1.5, 2) == 2.25
    assert pow(9, 0.5) == 3.0
    assert pow(2.0, -1.0) == 0.5

@test
def test_num_from_str():
    assert int('0') == 0
    assert int('010') == 10
    assert int('3\n') == 3
    assert int('\r\t\n 42\r\t\n ') == 42
    assert int('0101', 2) == 5
    assert int('-0101', 2) == -5
    assert int('0111', 8) == 73
    assert int('-0111', 8) == -73
    assert int('-0xabc', 16) == -2748
    assert int('0xabc', 16) == 2748
    assert int('-0xabc', 16) == -2748
    assert int('111', 0) == 111
    assert int('-111', 0) == -111
    assert int('-0xabc', 0) == -2748
    assert int('0xabc', 0) == 2748
    assert int('-0xabc', 0) == -2748

    try:
        int('  10  a')
        assert False
    except ValueError as e:
        assert str(e) == "invalid literal for int() with base 10: '  10  a'"

    try:
        int('')
        assert False
    except ValueError as e:
        assert str(e) == "invalid literal for int() with base 10: ''"

    assert float('0') == 0
    assert float('3.14') == 3.14
    assert float('3\n') == 3
    assert float('\r\t\n -4.2\r\t\n ') == -4.2

    try:
        float('  3.14  a')
        assert False
    except ValueError as e:
        assert str(e) == "could not convert string to float: '  3.14  a'"

    try:
        float('')
        assert False
    except ValueError as e:
        assert str(e) == "could not convert string to float: ''"

@test
def test_files(open_fn):
    path = 'build/testfile.txt'
    f = open_fn(path, 'w')
    f.write('hello\nworld\n')
    f.close()

    with open_fn(path) as f:
        assert [line for line in f] == ['hello\n', 'world\n']

    with open_fn(path) as f:
        assert f.read(3) == 'hel'
        assert f.read() == 'lo\nworld\n'
        f.seek(0, 0)
        assert f.tell() == 0
        assert f.read() == 'hello\nworld\n'

    try:
        f.tell()
        assert False
    except IOError:
        pass

    try:
        f.seek(0, 0)
        assert False
    except IOError:
        pass

    try:
        f.flush()
        assert False
    except IOError:
        pass

    f = open_fn(path, 'a')
    f.write('goodbye')
    f.flush()
    f.close()

    with open_fn(path) as f:
        assert [line for line in f] == ['hello\n', 'world\n', 'goodbye']

    with open_fn(path) as f:
        assert f.read(3) == 'hel'
        assert f.read() == 'lo\nworld\ngoodbye'

test_min_max()
test_map_filter()
test_gen_builtins()
test_int_format()
test_reversed()
test_divmod()
test_pow()
test_num_from_str()
test_files(open)
import gzip
test_files(gzip.open)


# Codon-specific

@pure
@llvm
def zext(x: int, T: type) -&gt; T:
    %0 = zext i64 %x to {=T}
    ret {=T} %0

@test
def test_narrow_int_str(T: type):
    z = T(0)
    o = T(1)
    a = T(42)
    b = T(-9)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(-o) == '-1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '42'
    assert str(b) == '-9'
    assert repr(a) == f'Int[{T.N}](42)'

@test
def test_narrow_uint_str(T: type):
    z = T(0)
    o = T(1)
    a = T(42)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '42'

    if T.N == 32:
        assert str(T(0xffffffff)) == '4294967295'

    if T.N == 64:
        assert str(T(0xffffffffffffffff)) == '18446744073709551615'

    assert repr(a) == f'UInt[{T.N}](42)'

@test
def test_wide_int_str(T: type):
    z = T(0)
    o = T(1)
    a = T(0xf23ff2341234)
    b = T(-77777)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(-o) == '-1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '266356460360244'
    assert str(b) == '-77777'
    assert str(a * a) == '70945763975638233282255739536'
    assert str(b * b) == '6049261729'
    assert str(a * b) == '-20716406417438697588'

    n = zext(0x7fffffffffffffff, T)
    m = zext(0xffffffffffffffff, T)
    s = T(64)
    assert str((n &lt;&lt; s) | m) == '170141183460469231731687303715884105727'
    if T.N == 128:
        assert str(T(1) &lt;&lt; T(127)) == '-170141183460469231731687303715884105728'
    if T.N &gt; 500:
        assert str(a * a * a * a * a * a * a * a) == '25334123245849102734940743817373556303530349383588924760280652082676453679304226528003335153202090430651964934127616'
        assert str(a * a * a * a * a * a * a * a * b) == '-1970412103692405663415486231883863088619679984007395801080348277034326537815244826668515398210598987424817876681643589632'

    assert repr(a) == f'Int[{T.N}](266356460360244)'
    assert repr(a * b) == f'Int[{T.N}](-20716406417438697588)'

@test
def test_wide_uint_str(T: type):
    z = T(0)
    o = T(1)
    a = T(0xf23ff2341234)

    assert str(z) == '0'
    assert str(-z) == '0'
    assert str(o) == '1'
    assert str(o + o + o) == '3'
    assert str((o + o + o + o) * (o + o + o)) == '12'
    assert str(a) == '266356460360244'
    assert str(a * a) == '70945763975638233282255739536'

    n = zext(0xffffffffffffffff, T)
    s = T(64)
    assert str((n &lt;&lt; s) | n) == '340282366920938463463374607431768211455'
    assert str((n &lt;&lt; s) | (n - T(1))) == '340282366920938463463374607431768211454'
    if T.N &gt; 500:
        assert str(a * a * a * a * a * a * a * a) == '25334123245849102734940743817373556303530349383588924760280652082676453679304226528003335153202090430651964934127616'

    assert repr(a) == f'UInt[{T.N}](266356460360244)'
    assert repr(a * a) == f'UInt[{T.N}](70945763975638233282255739536)'

test_narrow_int_str(Int[7])
test_narrow_int_str(Int[8])
test_narrow_int_str(Int[10])
test_narrow_int_str(Int[16])
test_narrow_int_str(Int[32])
test_narrow_int_str(Int[60])
test_narrow_int_str(Int[63])
test_narrow_int_str(Int[64])

test_narrow_uint_str(UInt[7])
test_narrow_uint_str(UInt[8])
test_narrow_uint_str(UInt[10])
test_narrow_uint_str(UInt[16])
test_narrow_uint_str(UInt[32])
test_narrow_uint_str(UInt[60])
test_narrow_uint_str(UInt[63])
test_narrow_uint_str(UInt[64])

test_wide_int_str(Int[128])
test_wide_int_str(Int[200])
test_wide_int_str(Int[256])
test_wide_int_str(Int[512])
test_wide_int_str(Int[1024])
test_wide_int_str(Int[2048])
test_wide_int_str(Int[4096])

test_wide_uint_str(UInt[128])
test_wide_uint_str(UInt[200])
test_wide_uint_str(UInt[256])
test_wide_uint_str(UInt[512])
test_wide_uint_str(UInt[1024])
test_wide_uint_str(UInt[2048])
test_wide_uint_str(UInt[4096])
</t>
<t tx="ekr.20230509083244.65">@path C:/Repos/codon/test/core/
@language unknown_language
from copy import copy, deepcopy

@tuple
class A:
    a: int
    b: float

    def __getitem__(self: A, n: int):
        return 1

    def __getitem__(self: A, x: Slice):
        if x.start is None and x.stop is None:
            return -1
        if x.start is None:
            return 2
        elif x.stop is None:
            return 3
        else:
            return self.a

@test
def test_tuple():
    def test_in():
        for i in range(10):
            yield i, i in (4, 9, 10, -1, 3, 1), i in (7,)
    assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]

    def test_cmp[T](a: T, b: T):
        yield 'EQ', a == b
        yield 'NE', a != b
        yield 'LT', a &lt; b
        yield 'GT', a &gt; b
        yield 'LE', a &lt;= b
        yield 'GE', a &gt;= b

    assert list(test_cmp((1,2), (1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp((1,2,2), (1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp((1,2,-1), (1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp((), ())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    t = (1,2,3)
    assert (t[0], t[1], t[2]) == (1, 2, 3)
    assert (t[-1], t[-2], t[-3]) == (3, 2, 1)
    assert t[1:3] == (2, 3)
    assert t[-3:1] == (1,)
    assert t[-10:2] == (1, 2)
    assert t[0:] == (1, 2, 3)
    assert t[-2:] == (2, 3)
    assert t[3:] == ()
    assert t[:-1] == (1, 2)
    assert t[:1] == (1,)
    assert t[:] == (1, 2, 3)
    assert t[::] == (1, 2, 3)
    assert t[1::1] == (2, 3)
    assert t[:2:1] == (1, 2)
    assert t[::2] == (1, 3)
    assert t[::-1] == (3, 2, 1)
    assert t[0:3:-1] == ()
    assert t[3:0:-1] == (3, 2)

    a = A(42, 3.14)
    assert a[0] == 1
    assert a[:1] == 2
    assert a[0:] == 3
    assert a[0:1] == 42
    assert a[:] == -1
test_tuple()

@test
def test_dyn_tuple():
    def D(*args):
        return DynamicTuple(args)

    def test_in():
        for i in range(10):
            yield i, i in D(4, 9, 10, -1, 3, 1), i in D(7)
    assert list(test_in()) == [(0, False, False), (1, True, False), (2, False, False), (3, True, False), (4, True, False), (5, False, False), (6, False, False), (7, False, True), (8, False, False), (9, True, False)]

    def test_cmp(a, b):
        yield 'EQ', a == b
        yield 'NE', a != b
        yield 'LT', a &lt; b
        yield 'GT', a &gt; b
        yield 'LE', a &lt;= b
        yield 'GE', a &gt;= b

    assert list(test_cmp(D(1,2), D(1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp(D(1,2,2), D(1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp(D(1,2,-1), D(1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(DynamicTuple[int](), DynamicTuple[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    assert list(test_cmp((1,2), D(1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp((1,2,2), D(1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp((1,2,-1), D(1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp((), DynamicTuple[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    assert list(test_cmp(D(1,2), (1,2))) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp(D(1,2,2), (1,2,3))) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp(D(1,2,-1), (1,0,1))) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(DynamicTuple[int](), ())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]

    t = D(1,2,3)
    assert D(t[0], t[1], t[2]) == D(1, 2, 3)
    assert D(t[-1], t[-2], t[-3]) == D(3, 2, 1)
    assert t[1:3] == D(2, 3)
    assert t[-3:1] == D(1,)
    assert t[-10:2] == D(1, 2)
    assert t[0:] == D(1, 2, 3)
    assert t[-2:] == D(2, 3)
    assert t[3:] == DynamicTuple[int]()
    assert t[:-1] == D(1, 2)
    assert t[:1] == D(1)
    assert t[:] == D(1, 2, 3)
    assert t[::] == D(1, 2, 3)
    assert t[1::1] == D(2, 3)
    assert t[:2:1] == D(1, 2)
    assert t[::2] == D(1, 3)
    assert t[::-1] == D(3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == D(3, 2)

    assert D(t[0], t[1], t[2]) == (1, 2, 3)
    assert D(t[-1], t[-2], t[-3]) == (3, 2, 1)
    assert t[1:3] == (2, 3)
    assert t[-3:1] == (1,)
    assert t[-10:2] == (1, 2)
    assert t[0:] == (1, 2, 3)
    assert t[-2:] == (2, 3)
    assert t[3:] == ()
    assert t[:-1] == (1, 2)
    assert t[:1] == (1,)
    assert t[:] == (1, 2, 3)
    assert t[::] == (1, 2, 3)
    assert t[1::1] == (2, 3)
    assert t[:2:1] == (1, 2)
    assert t[::2] == (1, 3)
    assert t[::-1] == (3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == (3, 2)

    t = (1,2,3)
    assert (t[0], t[1], t[2]) == D(1, 2, 3)
    assert (t[-1], t[-2], t[-3]) == D(3, 2, 1)
    assert t[1:3] == D(2, 3)
    assert t[-3:1] == D(1,)
    assert t[-10:2] == D(1, 2)
    assert t[0:] == D(1, 2, 3)
    assert t[-2:] == D(2, 3)
    assert t[3:] == DynamicTuple[int]()
    assert t[:-1] == D(1, 2)
    assert t[:1] == D(1)
    assert t[:] == D(1, 2, 3)
    assert t[::] == D(1, 2, 3)
    assert t[1::1] == D(2, 3)
    assert t[:2:1] == D(1, 2)
    assert t[::2] == D(1, 3)
    assert t[::-1] == D(3, 2, 1)
    assert t[0:3:-1] == DynamicTuple[int]()
    assert t[3:0:-1] == D(3, 2)

    assert hash(D(1,2,3,4,5)) == hash((1,2,3,4,5))

    assert (1, 2) + (3,) == (1, 2, 3)
    assert (1,) + (2, 3) == (1, 2, 3)
    assert (1, 2) + () == (1, 2)
    assert () + () == ()
    assert () + (1, 2) == (1, 2)
    assert (1,) + (2,) == (1, 2)
    assert (1, 2) * 3 == (1, 2, 1, 2, 1, 2)
    assert () * 99 == ()
    assert (1, 2, 3, 4) * 1 == (1, 2, 3, 4)
    assert (1, 2) * 0 == ()
    assert (1, 2) * (-1) == ()
    assert () * -1 == ()
test_dyn_tuple()

@test
def test_list():
    l1 = [i+1 for i in range(100)]
    assert len(l1) == 100
    l1 = l1[98:]
    l2 = [1, 2] * 2

    assert [a for a in l1] == [99, 100]
    assert [a for a in l2] == [1, 2, 1, 2]
    assert 2 * [1, 2] == l2

    l1 = [i*2 for i in range(3)]
    l1.insert(0, 99)
    l1[0] += 1
    del l1[1]
    assert [a for a in l1[0:3]] == [100, 2, 4]

    l3 = [1, 2, 3]
    assert l3.remove(2) == True
    assert l3.remove(2) == False
    assert l3 == [1, 3]
    assert list[int]().remove(0) == False

    # l4 = [5, 1, 4, 2, 1, -10, 10, 100, -100]
    # assert sorted(l4) == [-100, -10, 1, 1, 2, 4, 5, 10, 100]
    #l4.sort()
    #assert l4 == [-100, -10, 1, 1, 2, 4, 5, 10, 100]
    #assert str(sorted(list[int]())) == "[]"

    l5 = [11, 22, 33, 44]
    del l5[-1]
    assert l5 == [11, 22, 33]
    l5.insert(-1, 55)
    l5.insert(1000, 66)
    l5.insert(-100, 77)
    assert l5 == [77, 11, 22, 55, 33, 66]
    l5 = [11, 22, 55, 33]
    assert l5 + [1,2,3] == [11, 22, 55, 33, 1, 2, 3]
    l5 += [1,2,3]
    assert l5 == [11, 22, 55, 33, 1, 2, 3]
    assert l5.pop() == 3
    assert l5 * 2 == [11, 22, 55, 33, 1, 2, 11, 22, 55, 33, 1, 2]
    l5 *= 2
    assert l5 == [11, 22, 55, 33, 1, 2, 11, 22, 55, 33, 1, 2]
    assert l5.index(33) == 3
    l5 *= 0
    assert len(l5) == 0

    l6 = []
    l6.extend('abc')
    l6.extend(['xyz'])
    l6.extend('')
    assert l6 == ['a', 'b', 'c', 'xyz']

    assert List[int]().copy() == List[int]()
    assert [1,2,3].copy() == [1,2,3]

    def test_cmp[T](a: T, b: T):
        yield 'EQ', a == b
        yield 'NE', a != b
        yield 'LT', a &lt; b
        yield 'GT', a &gt; b
        yield 'LE', a &lt;= b
        yield 'GE', a &gt;= b

    assert list(test_cmp([1,2], [1,2])) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp([1,2,2], [1,2,3])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [1,0,1])) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(List[int](), List[int]())) == [('EQ', True), ('NE', False), ('LT', False), ('GT', False), ('LE', True), ('GE', True)]
    assert list(test_cmp([1], List[int]())) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]
    assert list(test_cmp(List[int](), [1])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [2])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1], [1,2,-1,3])) == [('EQ', False), ('NE', True), ('LT', True), ('GT', False), ('LE', True), ('GE', False)]
    assert list(test_cmp([1,2,-1,3], [1,2,-1])) == [('EQ', False), ('NE', True), ('LT', False), ('GT', True), ('LE', False), ('GE', True)]

    assert str([1] + [2] + [] + [3]) == '[1, 2, 3]'
    assert ['a', 'b'] + ['x', 'y', 'z'] == ['a', 'b'] + ['x', 'y', 'z']
    assert [(1,1), (2,2)] + [] == [(1,1), (2,2)]
    assert [] + [(1,1), (2,2)] == [(1,1), (2,2)]
    assert List[int]() + List[int]() == List[int]()
    l7 = [3.14, 2.5]
    l7 += [9.99, -1.0]
    assert l7 == [3.14, 2.5, 9.99, -1.0]
    l8 = []
    l8 += [11, 22, 33]
    assert l8 == [11, 22, 33]
    l8 = [11, 22, 33]
    l8 += []
    assert l8 == [11, 22, 33]
    l8 = List[int]()
    l8 += List[int]()
    assert l8 == List[int]()

    assert list(reversed(list('abc'))) == ['c', 'b', 'a']
    assert list(list('abc')[::-1]) == ['c', 'b', 'a']
    assert list(reversed(List[str]())) == List[str]()
test_list()

@test
def test_setslice():
    l = [0, 1]
    a = l

    for i in range(-3, 4):
        a[:i] = l[:i]
        assert a == l
        a2 = a[:]
        a2[:i] = a[:i]
        assert a2 == a
        a[i:] = l[i:]
        assert a == l
        a2 = a[:]
        a2[i:] = a[i:]
        assert a2 == a
        for j in range(-3, 4):
            a[i:j] = l[i:j]
            assert a == l
            a2 = a[:]
            a2[i:j] = a[i:j]
            assert a2 == a

    a2 = a[:]
    aa2 = a2[:]
    aa2[:0] = [-2, -1]
    assert aa2 == [-2, -1, 0, 1]
    aa2[0:] = list[int]()
    assert aa2 == list[int]()

    a = [1, 2, 3, 4, 5]
    a[:-1] = a
    assert a == [1, 2, 3, 4, 5, 5]
    a = [1, 2, 3, 4, 5]
    a[1:] = a
    assert a == [1, 1, 2, 3, 4, 5]
    a = [1, 2, 3, 4, 5]
    a[1:-1] = a
    assert a == [1, 1, 2, 3, 4, 5, 5]

    a = list[int]()
    a[:] = list(range(10))
    assert a == list(range(10))

    a = list(range(20))
    try:
        a[0:10:0] = [1,2,3]
        assert False
    except ValueError:
        pass

    try:
        a[0:10:2] = [1,2]
        assert False
    except ValueError:
        pass

    a[2:10:3] = [1,2,3]
    assert a == [0, 1, 1, 3, 4, 2, 6, 7, 3, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
test_setslice()

@test
def test_delslice():
    a = [0, 1]
    del a[1:2]
    del a[0:1]
    assert a == list[int]()

    a = [0, 1]
    del a[1:2]
    del a[0:1]
    assert a == list[int]()

    a = [0, 1]
    del a[-2:-1]
    assert a == [1]

    a = [0, 1]
    del a[-2:-1]
    assert a == [1]

    a = [0, 1]
    del a[1:]
    del a[:1]
    assert a == list[int]()

    a = [0, 1]
    del a[1:]
    del a[:1]
    assert a == list[int]()

    a = [0, 1]
    del a[-1:]
    assert a == [0]

    a = [0, 1]
    del a[-1:]
    assert a == [0]

    a = [0,1]
    del a[:]
    assert a == list[int]()
test_delslice()

@test
def test_extendedslicing():
    a = [0,1,2,3,4]
    del a[::2]
    assert a == [1,3]

    a = list(range(5))
    del a[1::2]
    assert a == [0,2,4]

    a = list(range(5))
    del a[1::-2]
    assert a == [0,2,3,4]

    a = list(range(10))
    del a[::1000]
    assert a == [1, 2, 3, 4, 5, 6, 7, 8, 9]

    a = list(range(10))
    a[::2] = [-1]*5
    assert a == [-1, 1, -1, 3, -1, 5, -1, 7, -1, 9]

    a = list(range(10))
    a[::-4] = [10]*3
    assert a == [0, 10, 2, 3, 4, 10, 6, 7, 8 ,10]

    a = list(range(4))
    a[::-1] = a
    assert a == [3, 2, 1, 0]

    a = list(range(10))
    b = a[:]
    c = a[:]
    a[2:3] = [222, 333]
    b[2:3] = [222, 333]
    c[2:3:] = [222, 333]
    assert a == b
    assert a == c

    a = list(range(10))
    a[::2] = (0, 1, 2, 3, 4)
    assert a == [0, 1, 1, 3, 2, 5, 3, 7, 4, 9]

    assert repr(['x', 'y', 'z']) == "['x', 'y', 'z']"
    assert repr(List[int]()) == '[]'
test_extendedslicing()

@test
def test_set():
    s1 = {a for a in range(100)}
    assert len(s1) == 100
    s1 = {a%8 for a in range(100)}
    for a in range(8):
        assert a in s1
    for a in range(8,100):
        assert a not in s1

    assert 5 in s1
    s1.remove(5)
    assert 5 not in s1
    assert len(s1) == 7

    s1 = {1,2,3,4}
    s2 = {2,3,4,5}
    s3 = set[int]()

    assert (s1 | s2) == {1, 2, 3, 4, 5}
    assert (s1 &amp; s2) == {4, 2, 3}
    assert (s1 ^ s2) == {1, 5}
    assert (s1 | s3) == {1, 2, 3, 4}
    assert (s1 &amp; s3) == set[int]()
    assert (s1 ^ s3) == {1, 2, 3, 4}
    assert (s1 - s2) == {1}
    assert (s2 - s1) == {5}
    assert (s3 - s1 - s2) == set[int]()
    assert (s1 &gt; s2) == False
    assert (s1 &lt; s2) == False
    assert (s3 &lt;= s1) == True
    assert (s2 &gt;= s1) == False
    assert ((s1 | s2) &gt; s1) == True

    s1c = copy(s1)
    s2c = copy(s2)
    s3c = copy(s3)

    assert s1c == {1, 2, 3, 4}
    s1c &amp;= s2c
    assert s1c == {2, 3, 4}
    s1c -= s3c
    assert s1c == {2, 3, 4}
    s1c ^= s1c
    assert s1c == set[int]()
    s1c |= s2c
    assert s1c == {2, 3, 4, 5}
    assert s1 == {1, 2, 3, 4}

    s1 = {1, 2, 3, 999999}
    s2 = {1, 2, 3, 999999}
    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    v = s1.pop()
    assert v in s2
    s2.remove(v)

    try:
        s1.pop()
        assert False
    except ValueError:
        pass

    assert repr({(1,2)}) == '{(1, 2)}'
    assert repr(Set[int]()) == 'set()'
test_set()

@test
def test_dict():
    d1 = copy({a: a*a for a in range(100)})
    assert len(d1) == 100
    d1 = {a: a*a for a in range(5)}
    assert len(copy(dict[int,int]())) == 0

    assert [d1.get(a, -1) for a in range(6)] == [0, 1, 4, 9, 16, -1]

    assert 2 in d1
    del d1[2]
    assert 2 not in d1
    d1[2] = 44
    assert 2 in d1
    assert d1.get(2, -1) == 44
    assert d1[3] == 9

    del d1[3]
    del d1[4]

    assert [k for k in d1] == [0, 1, 2]
    assert [t for t in d1.items()] == [(0, 0), (1, 1), (2, 44)]

    d2 = {'x': 10, 'y': 0}
    d2.increment('x')
    d2.increment('y', by=-1)
    d2.increment('z', by=2)
    assert d2['x'] == 11
    assert d2['y'] == -1
    assert d2['z'] == 2
    assert d2 == {'x': 11, 'y': -1, 'z': 2}

    d3 = {1: 2, 42: 42}
    d4 = {1: 5, 2: 9}
    assert d3 | d4 == {1: 5, 42: 42, 2: 9}
    d3 |= d4
    assert d3 == {1: 5, 42: 42, 2: 9}

    assert repr({1: ['x']}) == "{1: ['x']}"
    assert repr(Dict[int,int]()) == '{}'
test_dict()

@test
def test_deque():
    from collections import deque

    dq = deque[int]()
    dq.append(1)
    dq.append(2)
    dq.append(3)
    dq.appendleft(11)
    dq.appendleft(22)
    assert str(dq) == 'deque([22, 11, 1, 2, 3])'
    assert bool(dq) == True

    # test cap increase:
    dq.clear()
    assert bool(dq) == False
    for i in range(20):
        dq.append(i)
        dq.appendleft(i)
    assert str(dq) == 'deque([19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])'
    assert len(dq) == 40

    for i in range(19):
        dq.pop()
        dq.popleft()
    assert str(dq) == 'deque([0, 0])'
    for a in dq:
        assert a == 0

    assert (0 in dq) == True
    assert (1 in dq) == False
    assert str(copy(dq)) == 'deque([0, 0])'

    # test maxlen:
    dq = deque[int](5)
    for i in range(100):
        dq.append(i)
    assert str(dq) == 'deque([95, 96, 97, 98, 99])'

    for i in range(5):
        dq.append(i)
    assert str(dq) == 'deque([0, 1, 2, 3, 4])'
test_deque()

@test
def test_counter():
    from collections import Counter

    # main
    c = Counter('abcaba')
    assert c == Counter({'a':3 , 'b': 2, 'c': 1})
    assert len(c) == 3
    assert sum(c.values()) == 6
    assert set(c.values()) == {1, 2, 3}
    assert set(c.keys()) == {'a','b','c'}
    assert set(c.items()) == {('a',3), ('b',2), ('c',1)}
    assert c['b'] == 2
    assert c['z'] == 0
    assert c.__contains__('b')
    assert not c.__contains__('z')
    assert c.get('b', 10) == 2
    assert c.get('z', 10) == 10
    assert c == {'a':3 , 'b': 2, 'c': 1}
    assert c.most_common() == [('a', 3), ('b', 2), ('c', 1)]
    for i in range(5):
        assert c.most_common(i) == [('a', 3), ('b', 2), ('c', 1)][:i]

    c['a'] += 1         # increment an existing value
    c['b'] -= 2         # sub existing value to zero
    del c['c']          # remove an entry
    del c['c']          # make sure that del doesn't raise KeyError
    c['d'] -= 2         # sub from a missing value
    c['e'] = -5         # directly assign a missing value
    c['f'] += 4         # add to a missing value

    assert dict(c) == {'a':4, 'b':0, 'd':-2, 'e':-5, 'f':4}
    assert c.pop('f') == 4
    assert 'f' not in c
    for i in range(3):
        elem, cnt = c.popitem()
        assert elem not in c
    c.clear()
    assert c == {}
    c.update({'a':5, 'b':3})
    c.update({'c': 1})
    c.update(Counter('a' * 50 + 'b' * 30))
    c.update()
    c.update('a' * 500 + 'b' * 300)
    c.update('cdc')
    assert c == {'a':555, 'b':333, 'c':3, 'd':1}

    assert c.setdefault('d',5) == 1
    assert c['d'] == 1
    assert c.setdefault('e', 5) == 5
    assert c['e'] == 5


    # total
    c = Counter({'a':10, 'b':5, 'c':0})
    assert c.total() == 15


    # conversions
    s = 'she sells sea shells by the sea shore'
    assert sorted(Counter(s).elements()) == sorted(s)
    assert sorted(Counter(s)) == sorted(set(s))
    assert dict(Counter(s)) == dict(Counter(s).items())
    assert set(Counter(s)) == set(s)


    # in invariant
    c = Counter({'a':10, 'b':-2, 'c':0})
    for elem in c:
        assert elem in c


    # multiset
    c = Counter({'a':10, 'b':-2, 'c':0}) + Counter()
    assert dict(c) == {'a':10}

    from random import randrange, randint
    elements = 'abcd'
    for i in range(1000):
        # test random pairs of multisets
        p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        p.update({'e':1, 'f':-1, 'g':0})
        q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        q.update({'h':1, 'i':-1, 'j':0})

        result = p + q
        for x in elements:
            assert max(0, p[x] + q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p - q
        for x in elements:
            assert max(0, p[x] - q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p | q
        for x in elements:
            assert max(0, p[x], q[x]) == result[x]
        assert all(x&gt;0 for x in result.values())

        result = p &amp; q
        for x in elements:
            assert max(0, min(p[x], q[x])) == result[x]
        assert all(x&gt;0 for x in result.values())

    elements = 'abcdef'
    for i in range(100):
        # verify that random multisets with no repeats are exactly like sets
        p = Counter(dict((elem, randrange(0, 2)) for elem in elements))
        q = Counter(dict((elem, randrange(0, 2)) for elem in elements))

        counter_result = p - q
        set_result = set(p.elements()) - set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)

        counter_result = p | q
        set_result = set(p.elements()) | set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)

        counter_result = p &amp; q
        set_result = set(p.elements()) &amp; set(q.elements())
        assert counter_result == dict.fromkeys(set_result, 1)


    # in-place
    elements = 'abcd'
    for i in range(1000):
        # test random pairs of multisets
        p = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        p.update({'e':1, 'f':-1, 'g':0})
        q = Counter(dict((elem, randrange(-2,4)) for elem in elements))
        q.update({'h':1, 'i':-1, 'j':0})

        c = p.copy()
        c_id = id(c)
        regular_result = c + q
        inplace_result = c.__iadd__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c - q
        inplace_result = c.__isub__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c | q
        inplace_result = c.__ior__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id

        c = p.copy()
        c_id = id(c)
        regular_result = c &amp; q
        inplace_result = c.__iand__(q)
        assert inplace_result == regular_result
        assert id(inplace_result) == c_id


    # subtract
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15,'g':40})
    c.subtract({'a':1, 'b':2, 'c':-3, 'd':10, 'e':20, 'f':30, 'h':-50})
    assert c == Counter({'a':-6, 'b':-2, 'c':8, 'd':0, 'e':-5, 'f':-30, 'g':40, 'h':50})
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15,'g':40})
    c.subtract(Counter({'a':1, 'b':2, 'c':-3, 'd':10, 'e':20, 'f':30, 'h':-50}))
    assert c == Counter({'a':-6, 'b':-2, 'c':8, 'd':0, 'e':-5, 'f':-30, 'g':40, 'h':50})

    c = Counter('aaabbcd')
    c.subtract('aaaabbcce')
    assert c == Counter({'a':-1, 'b':0, 'c':-1, 'd':1, 'e':-1})

    c = Counter()
    c.subtract({'self':42})
    assert list(c.items()) == [('self', -42)]
    c = Counter()
    c.subtract({'iterable':42})
    assert list(c.items()) == [('iterable', -42)]


    # unary
    c = Counter({'a':-5, 'b':0, 'c':5, 'd':10, 'e':15, 'g':40})
    assert dict(+c) == {'c':5, 'd':10, 'e':15, 'g':40}
    assert dict(-c) == {'a':5}


    # equality
    assert Counter({'a':3, 'b':2}) == Counter('ababa')
    assert Counter({'a':3, 'b':2}) != Counter('babab')


    # most common
    c = Counter({v:k for k,v in enumerate('hgfedcba')})
    q = [(v,k) for k,v in enumerate('hgfedcba')][::-1]
    assert c.most_common() == q
    for i in range(10):
        assert c.most_common(i) == q[:i]

    for limit in range(100):
        for samples in range(100):
            for most_common in range(100):
                data = [randint(0, limit) for _ in range(samples)]
                d = Counter(data)
                exp = sorted(d.values(), reverse=True)[:most_common]
                got = [v for k,v in d.most_common(most_common)]
                assert exp == got

    for limit in range(100):
        for samples in range(100):
            data = [randint(0, limit) for _ in range(samples)]
            d = Counter(data)
            exp = sorted(d.values(), reverse=True)
            got = [v for k,v in d.most_common()]
            assert exp == got

    assert repr(Counter('abcabc')) == "Counter({'a': 2, 'b': 2, 'c': 2})"
test_counter()

@test
def test_defaultdict():
    from collections import defaultdict

    # basic
    #d1 = defaultdict()
    #self.assertEqual(d1.default_factory, None)
    #d1.default_factory = list
    d1 = defaultdict(list)
    d1[12].append(42)
    assert d1 == {12: [42]}
    d1[12].append(24)
    assert d1 == {12: [42, 24]}
    d1[13]
    d1[14]
    assert d1 == {12: [42, 24], 13: [], 14: []}
    assert d1[12] is not d1[13] is not d1[14]
    #d2 = defaultdict(list, foo=1, bar=2)
    #self.assertEqual(d2.default_factory, list)
    #self.assertEqual(d2, {"foo": 1, "bar": 2})
    #self.assertEqual(d2["foo"], 1)
    #self.assertEqual(d2["bar"], 2)
    #self.assertEqual(d2[42], [])
    #self.assertIn("foo", d2)
    #self.assertIn("foo", d2.keys())
    #self.assertIn("bar", d2)
    #self.assertIn("bar", d2.keys())
    #self.assertIn(42, d2)
    #self.assertIn(42, d2.keys())
    #self.assertNotIn(12, d2)
    #self.assertNotIn(12, d2.keys())
    #d2.default_factory = None
    #self.assertEqual(d2.default_factory, None)
    #try:
    #    d2[15]
    #except KeyError as err:
    #    self.assertEqual(err.args, (15,))
    #else:
    #    self.fail("d2[15] didn't raise KeyError")
    #self.assertRaises(TypeError, defaultdict, 1)

    # missing
    #d1 = defaultdict()
    #self.assertRaises(KeyError, d1.__missing__, 42)
    #d1.default_factory = list
    #d1 = defaultdict(list)
    assert d1.__missing__(42) == []

    # repr
    d1 = defaultdict(lambda: 0)
    #self.assertEqual(d1.default_factory, None)
    #self.assertEqual(repr(d1), "defaultdict(None, {})")
    #self.assertEqual(eval(repr(d1)), d1)
    d1[11] = 41
    assert repr(d1) == "defaultdict(&lt;default factory of 'int'&gt;, {11: 41})"
    d2 = defaultdict(lambda: 0)  # TODO: use 'int' when it's fixed...
    #self.assertEqual(d2.default_factory, int)
    d2[12] = 42
    assert repr(d2) == "defaultdict(&lt;default factory of 'int'&gt;, {12: 42})"
    def foo(): return 43
    d3 = defaultdict(foo)
    #self.assertTrue(d3.default_factory is foo)
    d3[13]
    assert repr(d3) == "defaultdict(&lt;default factory of 'int'&gt;, {13: 43})"


    # copy
    d1 = defaultdict(list)
    d2 = d1.copy()
    #self.assertEqual(type(d2), defaultdict)
    #self.assertEqual(d2.default_factory, None)
    assert d2 == {}
    #d1.default_factory = list
    #d3 = d1.copy()
    #self.assertEqual(type(d3), defaultdict)
    #self.assertEqual(d3.default_factory, list)
    #self.assertEqual(d3, {})
    d1[42].append(0)
    #d4 = d1.copy()
    #assert d4 == {42: [0]}
    #d4[12]
    #assert d4 == {42: [], 12: []}

    # Issue 6637: Copy fails for empty default dict
    #d = defaultdict()
    #d['a'] = 42
    #e = d.copy()
    #assert e['a'] == 42


    # shallow copy
    foobar = list
    d1 = defaultdict(foobar)
    d1[1] += [1]
    d2 = copy(d1)
    #self.assertEqual(d2.default_factory, foobar)
    assert d2 == d1
    #d1.default_factory = list
    d2 = copy(d1)
    #self.assertEqual(d2.default_factory, list)
    assert d2 == d1

    # deep copy
    d1 = defaultdict(foobar)
    d1[1].append(1)
    d2 = deepcopy(d1)
    #self.assertEqual(d2.default_factory, foobar)
    assert d2 == d1
    assert d1[1] is not d2[1]
    #d1.default_factory = list
    d2 = deepcopy(d1)
    #self.assertEqual(d2.default_factory, list)
    assert d2 == d1

    # KeyError without factory
    #d1 = defaultdict()
    #try:
    #    d1[(1,)]
    #except KeyError as err:
    #    self.assertEqual(err.args[0], (1,))
    #else:
    #    self.fail("expected KeyError")

    # pickling
    #d = defaultdict(int)
    #d[1]
    #for proto in range(pickle.HIGHEST_PROTOCOL + 1):
    #    s = pickle.dumps(d, proto)
    #    o = pickle.loads(s)
    #    self.assertEqual(d, o)

    # union
    i = defaultdict(int, {1: 1, 2: 2})
    s = defaultdict(int, {0: 0, 1: 111})

    i_s = i | s
    #self.assertIs(i_s.default_factory, int)
    assert i_s == {1: 111, 2: 2, 0: 0}
    assert sorted(i_s) == [0, 1, 2]

    s_i = s | i
    #self.assertIs(s_i.default_factory, str)
    assert s_i == {0: 0, 1: 1, 2: 2}
    assert sorted(s_i) == [0, 1, 2]

    i_ds = i | dict(s)
    #self.assertIs(i_ds.default_factory, int)
    assert i_ds == {1: 111, 2: 2, 0: 0}
    assert sorted(i_ds) == [0, 1, 2]

    ds_i = dict(s) | i
    #self.assertIs(ds_i.default_factory, int)
    assert ds_i == {0: 0, 1: 1, 2: 2}
    assert sorted(ds_i) == [0, 1, 2]

    # We inherit a fine |= from dict, so just a few sanity checks here:
    i |= list(s.items())
    #self.assertIs(i.default_factory, int)
    assert i == {1: 111, 2: 2, 0: 0}
    assert sorted(i), [1, 2, 0]

    # general
    s = 'mississippi'
    d = defaultdict(int)
    for k in s:
        d[k] += 1
    assert sorted(d.items()) == [('i', 4), ('m', 1), ('p', 2), ('s', 4)]

    s = 'mississippi'
    d = defaultdict(int)
    for k in s:
        d[k] = d.get(k, 0) + 1
    assert sorted(d.items()) == [('i', 4), ('m', 1), ('p', 2), ('s', 4)]

    s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)]
    d = defaultdict(list)
    for k, v in s:
        d[k].append(v)
    assert sorted(d.items()) == [('blue', [2, 4]), ('red', [1]), ('yellow', [1, 3])]

    def constant_factory(value):
        return lambda: value

    d = defaultdict(constant_factory('&lt;missing&gt;'))
    assert d[10] == '&lt;missing&gt;'
test_defaultdict()
</t>
<t tx="ekr.20230509083244.67">@path C:/Repos/codon/test/core/
@language unknown_language
class Exc1(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('Exc1', msg)

    def show(self):
        print self.message

class Exc2(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('Exc2', msg)

    def show(self):
        print self.message

class A(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('A', msg)

class B(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('B', msg)

class C(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('C', msg)

class D(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('D', msg)

class E(Static[Exception]):
    def __init__(self, msg: str):
        super().__init__('E', msg)

def foo1(x):
    if x:
        raise Exc1('e1')
    else:
        raise Exc2('e2')

def foo2(x):
    foo1(x)

def foo(x):
    foo2(x)

def square(x):
    return x * x

def bar(x):
    try:
        print 'try'
        foo(x)
        print 'error'
    except Exc1 as e:
        print 'catch Exc1 1'
        print e.message
        print 'catch Exc1 2'
    except Exc2 as e:
        print 'catch Exc2 1'
        print e.message
        print 'catch Exc2 2'
    finally:
        print 'finally'
    print 'done'

def baz(x):
    try:
        print 'try 1'
        square(x)
        print 'try 2'
    except Exc1 as e:
        print 'catch Exc1 1'
        print e.message
        print 'catch Exc1 2'
    except Exc2 as e:
        print 'catch Exc2 1'
        print e.message
        print 'catch Exc2 2'
    finally:
        print 'finally'
    print 'done'

def baz1(x):
    try:
        print 'try 1.1'
        foo(x)
        print 'try 1.2'
    except Exc1 as e:
        print 'catch Exc1 1.1'
        print e.message
        print 'catch Exc1 1.2'
    finally:
        print 'finally 1'
    print 'done 1'

def baz2(x):
    try:
        print 'try 2.1'
        baz1(x)
        print 'try 2.2'
    except:
        print 'catch Exc2'
    finally:
        print 'finally 2'
    print 'done 2'

def nest1(b):
    if b:
        raise C('C')
    else:
        raise E('E')

def nest2(b):
    try:
        try:
            try:
                try:
                    nest1(b)
                except A:
                    print 'A'
                finally:
                    print 'f A'
            except B:
                print 'B'
            finally:
                print 'f B'
        except C as c:
            print c.message
        finally:
            print 'f C'
    except D:
        print 'D'
    finally:
        print 'f D'

def nest3(b):
    try:
        nest2(b)
    except:
        print 'except'
    finally:
        print 'done'

def finally_return(x):
    try:
        try:
            return 'A'
        finally:
            if x &lt; 5:
                return 'B'
    finally:
        if x &gt; 10:
            return 'C'

def finally_return_void():
    try:
        try:
            print 'A'
            return
        finally:
            print 'B'
            return
    finally:
        print 'C'

def finally_break_continue1():
    try:
        for i in range(3):
            try:
                continue
            finally:
                print i
                continue
            print 'X'
    finally:
        print 'f'

def finally_break_continue2():
    try:
        for i in range(5):
            try:
                if i == 4:
                    continue

                for j in range(i):
                    try:
                        try:
                            if j == 3:
                                break
                            elif j == 1:
                                continue
                            print j
                        finally:
                            print 'f1'
                    finally:
                        print 'f2'
                        if j == 4:
                            break
            finally:
                print 'f3'
    finally:
        print 'f4'

def finally_break_continue3(n):
    while n != 0:
        print 'A'
        try:
            while n != 0:
                print 'B'
                if n == 42:
                    print 'C'
                    n -= 1
                    continue
                try:
                    print 'D'
                    if n &gt; 0:
                        print 'E'
                        continue
                    else:
                        print 'F'
                        break
                finally:
                    print('G')
                    return -1
            print 'H'
            return -2
        finally:
            print 'I'
            return n + 1

def test_try_with_loop1(_):
    try:
        print 'A'
        while True:
            print 'B'
            try:
                print 'C'
                raise ValueError()
                assert False
            except ValueError:
                print 'D'
                break
    finally:
        print 'E'

def test_try_with_loop2(_):
    try:
        print 'A'
        while True:
            print 'B'
            try:
                print 'C'
                raise ValueError()
                assert False
            except:
                print 'D'
                break
    finally:
        print 'E'

def test_try_with_loop3(_):
    try:
        try:
            print 'A'
            while True:
                print 'B'
                try:
                    print 'C'
                    raise ValueError()
                    assert False
                except IOError:
                    print 'D'
                    break
        finally:
            print 'E'
    except:
        print 'F'
    finally:
        print 'G'

def test_try_with_loop4(_):
    try:
        try:
            print 'A'
            while True:
                print 'B'
                try:
                    print 'C'
                    raise ValueError()
                    assert False
                except:
                    print 'D'
                    raise IOError()
                    break
        finally:
            print 'E'
    except:
        print 'F'
    finally:
        print 'G'

# EXPECT: try
# EXPECT: catch Exc1 1
# EXPECT: e1
# EXPECT: catch Exc1 2
# EXPECT: finally
# EXPECT: done
bar(True)

# EXPECT: try
# EXPECT: catch Exc2 1
# EXPECT: e2
# EXPECT: catch Exc2 2
# EXPECT: finally
# EXPECT: done
bar(0)

# EXPECT: try 1
# EXPECT: try 2
# EXPECT: finally
# EXPECT: done
baz(3.14)

# EXPECT: try 2.1
# EXPECT: try 1.1
# EXPECT: catch Exc1 1.1
# EXPECT: e1
# EXPECT: catch Exc1 1.2
# EXPECT: finally 1
# EXPECT: done 1
# EXPECT: try 2.2
# EXPECT: finally 2
# EXPECT: done 2
baz2(1)

# EXPECT: try 2.1
# EXPECT: try 1.1
# EXPECT: finally 1
# EXPECT: catch Exc2
# EXPECT: finally 2
# EXPECT: done 2
baz2(0)

# EXPECT: f A
# EXPECT: f B
# EXPECT: C
# EXPECT: f C
# EXPECT: f D
# EXPECT: done
nest3(True)

# EXPECT: f A
# EXPECT: f B
# EXPECT: f C
# EXPECT: f D
# EXPECT: except
# EXPECT: done
nest3(0)

print finally_return(3.14)  # EXPECT: B
print finally_return(7)     # EXPECT: A
print finally_return(11)    # EXPECT: C

# EXPECT: A
# EXPECT: B
# EXPECT: C
finally_return_void()

# EXPECT: 0
# EXPECT: 1
# EXPECT: 2
# EXPECT: f
finally_break_continue1()

# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: 0
# EXPECT: f1
# EXPECT: f2
# EXPECT: f1
# EXPECT: f2
# EXPECT: 2
# EXPECT: f1
# EXPECT: f2
# EXPECT: f3
# EXPECT: f3
# EXPECT: f4
finally_break_continue2()

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: B
# EXPECT: D
# EXPECT: E
# EXPECT: G
# EXPECT: I
# EXPECT: 42
print finally_break_continue3(42)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
test_try_with_loop1(0)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
test_try_with_loop2(0.0)

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: E
# EXPECT: F
# EXPECT: G
test_try_with_loop3('')

# EXPECT: A
# EXPECT: B
# EXPECT: C
# EXPECT: D
# EXPECT: E
# EXPECT: F
# EXPECT: G
test_try_with_loop4(False)

class Foo:
    i: int
    def __enter__(self: Foo):
        print '&gt; foo! ' + str(self.i)
    def __exit__(self: Foo):
        print '&lt; foo! ' + str(self.i)
    def foo(self: Foo):
        print 'woof'

class Bar:
    s: str
    def __enter__(self: Bar):
        print '&gt; bar! ' + self.s
    def __exit__(self: Bar):
        print '&lt; bar! ' + self.s
    def bar(self: Bar):
        print 'meow'

def test_with():
    with Foo(0) as f:
        f.foo()
    with Foo(1) as f, Bar('s') as b:
        f.foo()
        b.bar()
    with Foo(2), Bar('t') as q:
        print 'eeh'
        q.bar()

# EXPECT: &gt; foo! 0
# EXPECT: woof
# EXPECT: &lt; foo! 0
# EXPECT: &gt; foo! 1
# EXPECT: &gt; bar! s
# EXPECT: woof
# EXPECT: meow
# EXPECT: &lt; bar! s
# EXPECT: &lt; foo! 1
# EXPECT: &gt; foo! 2
# EXPECT: &gt; bar! t
# EXPECT: eeh
# EXPECT: meow
# EXPECT: &lt; bar! t
# EXPECT: &lt; foo! 2
test_with()


class PropClass:
    x: int

    @property
    def foo(self: PropClass):
        raise IOError('foo')

def test_property_exceptions():
    try:
        PropClass(42).foo
        print 'X'
    except IOError as e:
        print e.message

# EXPECT: foo
test_property_exceptions()

def test_empty_raise():
    def foo(b):
        if b:
            raise ValueError('A')
        else:
            raise IOError('B')

    def bar(b):
        try:
            foo(b)
            print('X')
        except IOError as e:
            print(e)
            raise
        except:
            raise

    def baz(b):
        try:
            bar(b)
        except ValueError as e:
            print(e)
            raise

    for b in (False, True):
        try:
            baz(b)
        except:
            print('C')

# EXPECT: B
# EXPECT: C
# EXPECT: A
# EXPECT: C
test_empty_raise()
</t>
<t tx="ekr.20230509083244.68">@path C:/Repos/codon/test/core/
@language unknown_language
v = range(5)
print len(v)  # EXPECT: 5
print 2 in v  # EXPECT: True
print 5 in v  # EXPECT: False
print [a for a in v]  # EXPECT: [0, 1, 2, 3, 4]
print list(reversed(v))  # EXPECT: [4, 3, 2, 1, 0]
print bool(v)  # EXPECT: True

v = range(10, 2, -3)
print len(v)  # EXPECT: 3
print 13 in v  # EXPECT: False
print 10 in v  # EXPECT: True
print 7 in v  # EXPECT: True
print 4 in v  # EXPECT: True
print 1 in v  # EXPECT: False
print [a for a in v]  # EXPECT: [10, 7, 4]
print list(reversed(v))  # EXPECT: [4, 7, 10]
print bool(v)  # EXPECT: True

v = range(10, 2, 3)
print len(v)  # EXPECT: 0
print 13 in v  # EXPECT: False
print 10 in v  # EXPECT: False
print 7 in v  # EXPECT: False
print 4 in v  # EXPECT: False
print 1 in v  # EXPECT: False
print [a for a in v]  # EXPECT: []
print list(reversed(v))  # EXPECT: []
print bool(v)  # EXPECT: False

def perms[T](elements: list[T]):
    if len(elements) &lt;=1:
        yield elements
    else:
        for perm in perms(elements[1:]):
            for i in range(len(elements)):
                yield perm[:i] + elements[0:1] + perm[i:]

for a in perms([1,2,3,4]):
    print a

# EXPECT: [1, 2, 3, 4]
# EXPECT: [2, 1, 3, 4]
# EXPECT: [2, 3, 1, 4]
# EXPECT: [2, 3, 4, 1]
# EXPECT: [1, 3, 2, 4]
# EXPECT: [3, 1, 2, 4]
# EXPECT: [3, 2, 1, 4]
# EXPECT: [3, 2, 4, 1]
# EXPECT: [1, 3, 4, 2]
# EXPECT: [3, 1, 4, 2]
# EXPECT: [3, 4, 1, 2]
# EXPECT: [3, 4, 2, 1]
# EXPECT: [1, 2, 4, 3]
# EXPECT: [2, 1, 4, 3]
# EXPECT: [2, 4, 1, 3]
# EXPECT: [2, 4, 3, 1]
# EXPECT: [1, 4, 2, 3]
# EXPECT: [4, 1, 2, 3]
# EXPECT: [4, 2, 1, 3]
# EXPECT: [4, 2, 3, 1]
# EXPECT: [1, 4, 3, 2]
# EXPECT: [4, 1, 3, 2]
# EXPECT: [4, 3, 1, 2]
# EXPECT: [4, 3, 2, 1]


def mysum[T](start: T):
    m = start
    while True:
        a = (yield)
        if a == -1:
            break
        m += a
    yield m

iadder = mysum(0)
next(iadder)
for i in range(10):
    iadder.send(i)
print(iadder.send(-1))  # EXPECT: 45

fadder = mysum(0.0)
next(fadder)
for i in range(10):
    fadder.send(float(i))
print(fadder.send(-1.0))  # EXPECT: 45


@test
def test_generator_in_finally():
    def foo(n):
        if not n:
            raise ValueError('not n')
        return n

    b = False
    try:
        try:
            a = 1
            x = 2
            z = 0
            for a in (foo(i) * x for i in [a,2,3,4,z,5] * x):
                pass
        finally:
            b = True
    except ValueError as e:
        assert e.message == 'not n'
    assert b
test_generator_in_finally()
</t>
<t tx="ekr.20230509083244.69">@path C:/Repos/codon/test/core/
@language unknown_language
class A[TA,TB,TC]:
    a: TA
    b: TB
    c: TC

    def dump(a, b, c):
        print a, b, c

    # non-generic method:
    def m0(self: A[TA,TB,TC], a: int):
        print a

    # basic generics:
    def m1[X](self: A[TA,TB,TC], other: A[X,X,X]):
        print other.a, other.b, other.c

    # non-generic method referencing outer generics:
    def m2(a: TA, b: TB, c: TC):
        A.dump(a, b, c)

    # generic args:
    def m3(self, other):
        return self.a

    # lots of nesting:
    def m4[TD](self: A[TA,TB,TC], d: TD):
        def m5[TA,TB,TC,TD,TE](a: TA, b: TB, c: TC, d: TD, e: TE):
            print a, b, c, d, e
        m5(self.a, self.b, self.c, d, d)

    # instantiating the type:
    def m5(self):
        x = A(self.a, self.b, self.c)
        A.dump(x.a, x.b, x.c)

    # deeply nested generic type:
    def m6[T](v: array[array[array[T]]]):
        return v[0][0][0]

# explicit realization:
def m7(T: type, S: type):
    print "works"

class B1[T]:
    a: T
    def foo[S](self: S) -&gt; B1[int]:
        return B1[int](111)

class B2[T]:
    a: T
    def foo[S](self: B2[S]):
        return B2[int](222)

a1 = A(42, 3.14, "hello")
a2 = A(1, 2, 3)
b1 = B1[bool](True).foo()
b2 = B2[str]("x").foo()

v1 = array[array[array[str]]](1)
v2 = array[array[str]](1)
v3 = array[str](1)
v1[0] = v2
v2[0] = v3
v3[0] = "world"
f = a2.m0

a1.m1(a2)                           # EXPECT: 1 2 3
A[int,float,str].m2(1, 1.0, "one")  # EXPECT: 1 1 one
A[int,int,int].m2(11, 22, 33)       # EXPECT: 11 22 33
print a1.m3(a2)                     # EXPECT: 42
print a1.m3(a2)                     # EXPECT: 42
print a2.m3(a1)                     # EXPECT: 1
a1.m4(True)                         # EXPECT: 42 3.14 hello True True
a1.m4([1])                          # EXPECT: 42 3.14 hello [1] [1]
a2.m4("x")                          # EXPECT: 1 2 3 x x
a1.m5()                             # EXPECT: 42 3.14 hello
a2.m5()                             # EXPECT: 1 2 3
print A.m6(v1)                      # EXPECT: world
m7(str,float)                       # EXPECT: works
m7(str,float)                       # EXPECT: works
m7(float,str)                       # EXPECT: works
f(99)                               # EXPECT: 99
print b1.foo().a                    # EXPECT: 111
print b2.foo().a                    # EXPECT: 222


# recursive generics with different inner type parameter
def foo(a):
    if not a:
        foo(True)
    print a
# EXPECT: True
# EXPECT: 0
foo(0)

def bar(a):
    def baz(x):
        if not x:
            bar(True)
        print(x)
    baz(a)
# EXPECT: True
# EXPECT: 0
bar(0)
</t>
<t tx="ekr.20230509083244.7">struct PartitionArgsByEscape : public ir::util::Operator {
  std::vector&lt;ir::analyze::dataflow::CaptureInfo&gt; expected;
  std::vector&lt;ir::Value *&gt; calls;

</t>
<t tx="ekr.20230509083244.70">@path C:/Repos/codon/test/core/
@language unknown_language
print "hello world"  # EXPECT: hello world
</t>
<t tx="ekr.20230509083244.71">@path C:/Repos/codon/test/core/
@language unknown_language
from core.llvm import *

@test
def test_int_llvm_ops():
    assert add_int(42, 99) == 141
    assert add_int(-10, 10) == 0
    assert sub_int(12, 6) == 6
    assert sub_int(5, -5) == 10
    assert mul_int(22, 33) == 726
    assert mul_int(-3, 3) == -9
    assert div_int(10, 2) == 5
    assert div_int(10, 3) == 3
    assert div_int(10, -3) == -3
    assert mod_int(10, 2) == 0
    assert mod_int(10, 3) == 1

    assert eq_int(42, 42)
    assert not eq_int(10, -10)
    assert ne_int(0, 1)
    assert not ne_int(-3, -3)

    assert lt_int(2, 3)
    assert not lt_int(3, 2)
    assert not lt_int(3, 3)

    assert not gt_int(2, 3)
    assert gt_int(3, 2)
    assert not gt_int(3, 3)

    assert le_int(2, 3)
    assert not le_int(3, 2)
    assert le_int(3, 3)

    assert not ge_int(2, 3)
    assert ge_int(3, 2)
    assert ge_int(3, 3)

    assert inv_int(0b1010) == -11
    assert and_int(0b1010, 0b1101) == 0b1000
    assert or_int(0b1010, 0b1101) == 0b1111
    assert xor_int(0b1010, 0b1101) == 0b0111
    assert shr_int(0b1010, 3) == 0b1
    assert shl_int(0b1010, 3) == 0b1010000

    assert bitreverse_int(0b0111110111010110001001001000001010001000110001010110001101001101) == 0b1011001011000110101000110001000101000001001001000110101110111110
    assert bitreverse_int(0) == 0
    assert bitreverse_int(0xffffffffffffffff) == 0xffffffffffffffff
    assert ctpop_int(0x7dd6248288c5634d) == 29
    assert ctpop_int(0) == 0
    assert ctpop_int(0xffffffffffffffff) == 64
    assert bswap_int(0x7dd6248288c5634d) == 0x4d63c5888224d67d
    assert bswap_int(0) == 0
    assert bswap_int(0xffffffffffffffff) == 0xffffffffffffffff
    assert ctlz_int(0b0001110111010110001001001000001010001000110001010110001101001101) == 3
    assert ctlz_int(0b0011110111010110001001001000001010001000110001010110001101001101) == 2
    assert ctlz_int(0b0111110111010110001001001000001010001000110001010110001101001101) == 1
    assert ctlz_int(0b1111110111010110001001001000001010001000110001010110001101001101) == 0
    assert ctlz_int(0) == 64
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001000) == 3
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001100) == 2
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001110) == 1
    assert cttz_int(0b0001110111010110001001001000001010001000110001010110001101001111) == 0
    assert cttz_int(0) == 64

@test
def test_float_llvm_ops():
    def approx_eq(a: float, b: float, thresh: float = 1e-10):
        return -thresh &lt;= a - b &lt;= thresh
    PI = 3.1415926535897932384626433832795028841971693993751058209749445923078164062
    E = 2.718281828459045235360287471352662497757247093699959574966967627724076630353

    assert add_float(42., 99.) == 141.
    assert add_float(-10., 10.) == 0.
    assert sub_float(12., 6.) == 6.
    assert sub_float(5., -5.) == 10.
    assert mul_float(22., 33.) == 726.
    assert mul_float(-3., 3.) == -9.
    assert div_float(10., 2.) == 5.
    assert div_float(10., 4.) == 2.5
    assert div_float(10., -2.5) == -4.
    assert mod_float(10., 2.) == 0.
    assert mod_float(10., 3.) == 1.

    assert eq_float(42., 42.)
    assert not eq_float(10., -10.)
    assert ne_float(0., 1.)
    assert not ne_float(-3., -3.)

    assert lt_float(2., 3.)
    assert not lt_float(3., 2.)
    assert not lt_float(3., 3.)

    assert not gt_float(2., 3.)
    assert gt_float(3., 2.)
    assert not gt_float(3., 3.)

    assert le_float(2., 3.)
    assert not le_float(3., 2.)
    assert le_float(3., 3.)

    assert not ge_float(2., 3.)
    assert ge_float(3., 2.)
    assert ge_float(3., 3.)

    assert pow_float(10., 2.) == 100.
    assert sqrt_float(100.) == 10.
    assert sin_float(0.0) == 0.
    assert sin_float(PI/2) == 1.
    assert approx_eq(sin_float(PI), 0.)
    assert cos_float(0.0) == 1.
    assert approx_eq(cos_float(PI/2), 0.)
    assert cos_float(PI) == -1.
    assert exp_float(0.) == 1.
    assert exp_float(1.) == E
    assert exp2_float(0.) == 1.
    assert exp2_float(1.) == 2.
    assert log_float(1.) == 0.
    assert log_float(E) == 1.
    assert log10_float(1.) == 0.
    assert log10_float(10.) == 1.
    assert log2_float(1.) == 0.
    assert log2_float(2.) == 1.
    assert abs_float(1.5) == 1.5
    assert abs_float(-1.5) == 1.5
    assert pow_float(1., 0.) == 1.
    assert pow_float(3., 2.) == 9.
    assert pow_float(2., -2.) == 0.25
    assert pow_float(-2., 2.) == 4.
    assert min_float(1., 1.) == 1.
    assert min_float(-1., 1.) == -1.
    assert min_float(3., 2.) == 2.
    assert max_float(1., 1.) == 1.
    assert max_float(-1., 1.) == 1.
    assert max_float(3., 2.) == 3.
    assert copysign_float(100., 1.234) == 100.
    assert copysign_float(100., -1.234) == -100.
    assert copysign_float(-100., 1.234) == 100.
    assert copysign_float(-100., -1.234) == -100.
    assert fma_float(2., 3., 4.) == 10.

    assert floor_float(1.5) == 1.
    assert ceil_float(1.5) == 2.
    assert trunc_float(-1.5) == -1.
    assert rint_float(1.8) == 2.
    assert rint_float(1.3) == 1.
    assert nearbyint_float(2.3) == 2.
    assert nearbyint_float(-3.8) == -4.
    assert round_float(2.3) == 2.
    assert round_float(-2.3) == -2.

@test
def test_conversion_llvm_ops():
    assert int_to_float(42) == 42.0
    assert int_to_float(-100) == -100.0
    assert float_to_int(3.14) == 3
    assert float_to_int(-3.14) == -3

@test
def test_str_llvm_ops():
    N = 10
    p = ptr[byte](N)
    for i in range(N):
        p[i] = byte(i + 1)

    q = ptr[byte](N)
    for i in range(N):
        q[i] = byte(0)

    memcpy(q, p, N)
    for i in range(10):
        assert q[i] == byte(i + 1)

    memmove(p + 1, p, N - 1)
    assert p[1] == p[0]
    for i in range(1, N):
        assert p[i] == byte(i)

    memset(p, byte(42), N)
    for i in range(N):
        assert p[i] == byte(42)

test_int_llvm_ops()
test_float_llvm_ops()
test_conversion_llvm_ops()
test_str_llvm_ops()
</t>
<t tx="ekr.20230509083244.72">@path C:/Repos/codon/test/core/
@language unknown_language
@test
def test_bool_match():
    T, F = True, False

    b = False
    match T:
        case True:
            b = True
        case False:
            assert False
        case _:
            assert False
    assert b

    b = False
    match F:
        case True:
            assert False
        case False:
            b = True
        case _:
            assert False
    assert b
test_bool_match()

@test
def test_str_match():
    s = 'abc'
    t = 'xyz'
    e = ''

    b = False
    match s:
        case '':
            assert False
        case 'abc':
            b = True
        case _:
            assert False
    assert b

    b = False
    match e:
        case '':
            b = True
        case 'abc':
            assert False
        case _:
            assert False
    assert b

    b = False
    match t:
        case '':
            assert False
        case 'abc':
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case '':
            assert False
        case x if len(x) &gt;= 3:
            b = True
        case _:
            assert False
    assert b
test_str_match()

@test
def test_tuple_match():
    t = (42, 99)
    r = (12, 12)

    b = False
    match t:
        case (0, 0):
            assert False
        case (42, 99):
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (42, 0):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (0, 99):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, _) if a == 42:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, bb) if 40 &lt; a &lt; bb &lt; 100:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (a, bb) if a == bb:
            assert False
        case _:
            b = True
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (a, bb) if a == bb:
            b = True
        case _:
            assert False
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (41 ... 43, 98 ... 100):
            b = True
        case _:
            assert False
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (41 ... 43, 98 ... 100):
            assert False
        case _:
            b = True
    assert b

    b = False
    match t:
        case (0, 0):
            assert False
        case (41 ... 43, 99 | 10) | (11 ... 13, 11 ... 13) | (-1, -1):
            b = True
        case _:
            assert False
    assert b

    b = False
    match r:
        case (0, 0):
            assert False
        case (-1, -1) | (41 ... 43, 10 | 99) | (12 | 11, 9 | 11 ... 13):
            b = True
        case _:
            assert False
    assert b
test_tuple_match()

@test
def test_int_match():
    n = 42
    m = -99

    b = False
    match n:
        case 0:
            assert False
        case 1:
            assert False
        case _:
            b = True
    assert b

    b = False
    match n:
        case 0:
            assert False
        case 42:
            b = True
        case 99:
            assert False
        case _:
            assert False
    assert b

    b = False
    match n:
        case 0:
            assert False
        case 1:
            assert False
        case _:
            b = True
    assert b

    b = False
    match m:
        case 0:
            assert False
        case 42:
            assert False
        case -99:
            b = True
        case _:
            assert False
    assert b

    b = False
    match m:
        case 0 ... 10:
            assert False
        case 12 ... 42:
            assert False
        case 42:
            assert False
        case _:
            b = True
    assert b

    b = False
    match n:
        case 0 ... 10:
            assert False
        case 42 ... 100:
            b = True
        case 42:
            assert False
        case _:
            assert False
    assert b

    b = False
    match n:
        case t if t &lt; 10:
            assert False
        case t if 41 &lt; t &lt; 43:
            b = True
        case _:
            assert False
    assert b
test_int_match()

@test
def test_list_match():
    v = [1, 2, 3, 4, 5]
    e = list[int]()

    b = False
    match v:
        case []:
            assert False
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            b = True
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case []:
            b = True
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case [...]:
            b = True
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match e:
        case [_]:
            assert False
        case [1, 2, 3, 4]:
            assert False
        case [1, 2, 3, 4, 5]:
            assert False
        case [1, 2, 3, 4, 5, 6]:
            assert False
        case _:
            b = True
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, ..., 4]:
            assert False
        case [1, ..., 5]:
            b = True
        case [1, ..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [_, ..., 4]:
            assert False
        case [_, ..., 5]:
            b = True
        case [_, ..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [5]:
        case []:
            assert False
        case [_, ..., 4]:
            assert False
        case [_, ..., 5]:
            assert False
        case [_, ..., 6]:
            assert False
        case _:
            b = True
    assert b

    b = False
    match v:
        case []:
            assert False
        case [..., 4]:
            assert False
        case [..., 5]:
            b = True
        case [..., 6]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, ...]:
            b = True
        case [2, ...]:
            assert False
        case [3, ...]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [2, ..., a, bb] if (a,bb) == (4,5):
            assert False
        case [1, ..., a, bb] if (a,bb) == (4,5):
            b = True
        case [3, ..., a, bb] if (a,bb) == (4,5):
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [2, ..., a, _, bb] if (a,bb) == (3,5):
            assert False
        case [1, ..., a, _, bb] if (a,bb) == (3,5):
            b = True
        case [3, ..., a, _, bb] if (a,bb) == (3,5):
            assert False
        case _:
            assert False
    assert b

    b = False
    match v:
        case []:
            assert False
        case [1, _, 3, _, 5]:
            b = True
        case [_, _]:
            assert False
        case [_]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [[v]]:
        case [[[]]]:
            assert False
        case [[[..., 4]]]:
            assert False
        case [[[..., 5]]]:
            b = True
        case [[[..., 6]]]:
            assert False
        case _:
            assert False
    assert b

    b = False
    match [[v]]:
        case [[[]]]:
            assert False
        case [[[1, _, 3, _, 5]]]:
            b = True
        case [[[_, _]]]:
            assert False
        case [[[_]]]:
            assert False
        case _:
            assert False
    assert b
test_list_match()
</t>
<t tx="ekr.20230509083244.73">@path C:/Repos/codon/test/core/
@language unknown_language
import operator as op
import math

NAN = math.nan
INF = math.inf
NINF = -math.inf

@test
def test_py_numerics_int():
    one = 1
    iz = 0
    fz = 0.0
    n = 0

    # through function (not optimized / pre-evaluated)
    assert op.floordiv(-5, 2) == -3
    assert op.floordiv(-5, 2.0) == -3.0
    assert op.truediv(-5, 2) == -2.5
    assert op.truediv(-5, 2.0) == -2.5
    assert op.mod(-10, 3) == 2
    assert op.mod(-1, 0.3) == 0.19999999999999996
    assert divmod(-10, 3) == (-4, 2)
    assert divmod(-1, 0.3) == (-4.0, 0.19999999999999996)

    # with vars (evaluated in IR)
    a = -5
    b = 2
    c = 2.0
    d = -10
    e = 3
    f = -1
    g = 0.3
    assert a // b == -3
    assert a // c == -3.0
    assert a / b == -2.5
    assert a / c == -2.5
    assert d % e == 2
    assert f % g == 0.19999999999999996

    # constant (evaluated statically by parser)
    assert -5 // 2 == -3
    assert -10 % 3 == 2

    # errors
    try:
        print(one // fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one // iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(one / fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one / iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'division by zero'
        n += 1

    try:
        print(one % fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(one % iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(divmod(one, iz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'integer division or modulo by zero'
        n += 1

    try:
        print(divmod(one, fz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    assert n == 8

@test
def test_py_numerics_float():
    one = 1.0
    iz = 0
    fz = 0.0
    n = 0

    # through function (not optimized / pre-evaluated)
    assert op.floordiv(-5.6, 2) == -3.0
    assert op.floordiv(-5.6, 2.0) == -3.0
    assert op.truediv(-5.6, 2) == -2.8
    assert op.truediv(-5.6, 2.0) == -2.8
    assert op.mod(-10.0, 3) == 2.0
    assert op.mod(-1.0, 0.3) == 0.19999999999999996
    assert divmod(-10.0, 3) == (-4.0, 2.0)
    assert divmod(-1.0, 0.3) == (-4.0, 0.19999999999999996)

    # with vars (evaluated in IR)
    a = -5.6
    b = 2
    c = 2.0
    d = -10.0
    e = 3
    f = -1.0
    g = 0.3
    assert a // b == -3
    assert a // c == -3.0
    assert a / b == -2.8
    assert a / c == -2.8
    assert d % e == 2
    assert f % g == 0.19999999999999996

    try:
        print(one // fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one // iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float floor division by zero'
        n += 1

    try:
        print(one / fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one / iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float division by zero'
        n += 1

    try:
        print(one % fz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(one % iz)
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float modulo'
        n += 1

    try:
        print(divmod(one, iz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    try:
        print(divmod(one, fz))
        assert False
    except ZeroDivisionError as e:
        assert str(e) == 'float divmod()'
        n += 1

    assert n == 8


import math

NAN = math.nan
INF = math.inf
NINF = -math.inf


def close(a: float, b: float, epsilon: float = 1e-7):
    return abs(a - b) &lt;= epsilon


@test
def test_isnan():
    assert math.isnan(float("nan")) == True
    assert math.isnan(4.0) == False


@test
def test_isinf():
    assert math.isinf(float("inf")) == True
    assert math.isinf(7.0) == False


@test
def test_isfinite():
    assert math.isfinite(1.4) == True
    assert math.isfinite(0.0) == True
    assert math.isfinite(NAN) == False
    assert math.isfinite(INF) == False
    assert math.isfinite(NINF) == False


@test
def test_ceil():
    assert math.ceil(3.3) == 4
    assert math.ceil(0.5) == 1
    assert math.ceil(1.0) == 1
    assert math.ceil(1.5) == 2
    assert math.ceil(-0.5) == 0
    assert math.ceil(-1.0) == -1
    assert math.ceil(-1.5) == -1


@test
def test_floor():
    assert math.floor(3.3) == 3
    assert math.floor(0.5) == 0
    assert math.floor(1.0) == 1
    assert math.floor(1.5) == 1
    assert math.floor(-0.5) == -1
    assert math.floor(-1.0) == -1
    assert math.floor(-1.5) == -2


@test
def test_fabs():
    assert math.fabs(-1.0) == 1
    assert math.fabs(0.0) == 0
    assert math.fabs(1.0) == 1


@test
def test_fmod():
    assert math.fmod(10.0, 1.0) == 0.0
    assert math.fmod(10.0, 0.5) == 0.0
    assert math.fmod(10.0, 1.5) == 1.0
    assert math.fmod(-10.0, 1.0) == -0.0
    assert math.fmod(-10.0, 0.5) == -0.0
    assert math.fmod(-10.0, 1.5) == -1.0


@test
def test_exp():
    assert math.exp(0.0) == 1
    assert math.exp(-1.0) == 1 / math.e
    assert math.exp(1.0) == math.e


@test
def test_expm1():
    assert math.expm1(0.0) == 0
    assert close(math.expm1(1.0), 1.7182818284590453)
    assert close(math.expm1(3.0), 19.085536923187668)
    assert close(math.expm1(5.0), 147.4131591025766)
    assert math.expm1(INF) == INF
    assert math.expm1(NINF) == -1
    assert math.isnan(math.expm1(NAN)) == True


@test
def test_ldexp():
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, 1) == 2.0
    assert math.ldexp(1.0, -1) == 0.5
    assert math.ldexp(-1.0, 1) == -2.0
    assert math.ldexp(0.0, 1) == 0.0
    assert math.ldexp(1.0, -1000000) == 0.0
    assert math.ldexp(-1.0, -1000000) == -0.0
    assert math.ldexp(INF, 30) == INF
    assert math.ldexp(NINF, -213) == NINF
    assert math.isnan(math.ldexp(NAN, 0)) == True


@test
def test_log():
    assert math.log(1.0 / math.e) == -1
    assert math.log(1.0) == 0
    assert math.log(math.e) == 1


@test
def test_log2():
    assert math.log2(1.0) == 0.0
    assert math.log2(2.0) == 1.0
    assert math.log2(4.0) == 2.0
    assert math.log2(2.0 ** 1023) == 1023.0
    try:
        math.log2(-1.5)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    try:
        math.log2(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.log2(NAN)) == True


@test
def test_log10():
    assert math.log10(0.1) == -1
    assert math.log10(1.0) == 0
    assert math.log10(10.0) == 1
    assert math.log10(10000.0) == 4


@test
def test_degrees():
    assert math.degrees(math.pi) == 180.0
    assert math.degrees(math.pi / 2) == 90.0
    assert math.degrees(-math.pi / 4) == -45.0
    assert math.degrees(0.0) == 0.0


@test
def test_radians():
    assert math.radians(180.0) == math.pi
    assert math.radians(90.0) == math.pi / 2
    assert math.radians(-45.0) == -math.pi / 4
    assert math.radians(0.0) == 0.0


@test
def test_sqrt():
    assert math.sqrt(4.0) == 2
    assert math.sqrt(0.0) == 0
    assert math.sqrt(1.0) == 1
    try:
        math.sqrt(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


@test
def test_pow():
    assert math.pow(0.0, 1.0) == 0
    assert math.pow(1.0, 0.0) == 1
    assert math.pow(2.0, 1.0) == 2
    assert math.pow(2.0, -1.0) == 0.5
    assert math.pow(-0.0, 3.0) == -0.0
    assert math.pow(-0.0, 2.3) == 0.0
    assert math.pow(-0.0, 0.0) == 1
    assert math.pow(-0.0, -0.0) == 1
    assert math.pow(-2.0, 2.0) == 4.0
    assert math.pow(-2.0, 3.0) == -8.0
    assert math.pow(-2.0, -3.0) == -0.125
    assert math.pow(INF, 1.0) == INF
    assert math.pow(NINF, 1.0) == NINF
    assert math.pow(1.0, INF) == 1
    assert math.pow(1.0, NINF) == 1
    assert math.isnan(math.pow(NAN, 1.0)) == True
    assert math.isnan(math.pow(2.0, NAN)) == True
    assert math.isnan(math.pow(0.0, NAN)) == True
    assert math.pow(1.0, NAN) == 1
    try:
        math.pow(10.0, 400.0)
        assert False
    except OverflowError as e:
        assert str(e) == 'math range error'


@test
def test_acos():
    assert math.acos(-1.0) == math.pi
    assert math.acos(0.0) == math.pi / 2
    assert math.acos(1.0) == 0
    assert math.isnan(math.acos(NAN)) == True


@test
def test_asin():
    assert math.asin(-1.0) == -math.pi / 2
    assert math.asin(0.0) == 0
    assert math.asin(1.0) == math.pi / 2
    assert math.isnan(math.asin(NAN)) == True


@test
def test_atan():
    assert math.atan(-1.0) == -math.pi / 4
    assert math.atan(0.0) == 0
    assert math.atan(1.0) == math.pi / 4
    assert math.atan(INF) == math.pi / 2
    assert math.atan(NINF) == -math.pi / 2
    assert math.isnan(math.atan(NAN)) == True


@test
def test_atan2():
    assert math.atan2(-1.0, 0.0) == -math.pi / 2
    assert math.atan2(-1.0, 1.0) == -math.pi / 4
    assert math.atan2(0.0, 1.0) == 0
    assert math.atan2(1.0, 1.0) == math.pi / 4
    assert math.atan2(1.0, 0.0) == math.pi / 2
    assert math.atan2(-0.0, 0.0) == -0
    assert math.atan2(-0.0, 2.3) == -0
    assert math.atan2(0.0, -2.3) == math.pi
    assert math.atan2(INF, NINF) == math.pi * 3 / 4
    assert math.atan2(INF, 2.3) == math.pi / 2
    assert math.isnan(math.atan2(NAN, 0.0)) == True


@test
def test_cos():
    assert math.cos(0.0) == 1
    assert close(math.cos(math.pi / 2), 6.123233995736766e-17)
    assert close(math.cos(-math.pi / 2), 6.123233995736766e-17)
    assert math.cos(math.pi) == -1

    try:
        math.cos(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.cos(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.cos(NAN)) == True


@test
def test_sin():
    assert math.sin(0.0) == 0
    assert math.sin(math.pi / 2) == 1
    assert math.sin(-math.pi / 2) == -1

    try:
        math.sin(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.sin(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.sin(NAN)) == True


@test
def test_hypot():
    assert math.hypot(12.0, 5.0) == 13
    assert math.hypot(12.0 / 32.0, 5.0 / 32) == 13 / 32
    assert math.hypot(0.0, 0.0) == 0
    assert math.hypot(-3.0, 4.0) == 5
    assert math.hypot(3.0, 4.0) == 5


@test
def test_tan():
    assert math.tan(0.0) == 0
    assert close(math.tan(math.pi / 4), 0.9999999999999999)
    assert close(math.tan(-math.pi / 4), -0.9999999999999999)

    try:
        math.tan(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.tan(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.tan(NAN)) == True


@test
def test_cosh():
    assert math.cosh(0.0) == 1
    assert math.cosh(2.0) - 2 * math.cosh(1.0) ** 2 == -1
    assert math.cosh(INF) == INF
    assert math.cosh(NINF) == INF
    assert math.isnan(math.cosh(NAN)) == True


@test
def test_sinh():
    assert math.sinh(0.0) == 0
    assert math.sinh(1.0) + math.sinh(-1.0) == 0
    assert math.sinh(INF) == INF
    assert math.sinh(NINF) == NINF
    assert math.isnan(math.sinh(NAN)) == True


@test
def test_tanh():
    assert math.tanh(0.0) == 0
    assert math.tanh(1.0) + math.tanh(-1.0) == 0
    assert math.tanh(INF) == 1
    assert math.tanh(NINF) == -1
    assert math.isnan(math.tanh(NAN)) == True


@test
def test_acosh():
    assert math.acosh(1.0) == 0
    assert close(math.acosh(2.0), 1.3169578969248166)
    assert math.acosh(INF) == INF
    assert math.isnan(math.acosh(NAN)) == True
    try:
        math.acosh(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


@test
def test_asinh():
    assert math.asinh(0.0) == 0
    assert close(math.asinh(1.0), 0.881373587019543)
    assert close(math.asinh(-1.0), -0.881373587019543)
    assert math.asinh(INF) == INF
    assert math.isnan(math.asinh(NAN)) == True
    assert math.asinh(NINF) == NINF


@test
def test_atanh():
    assert math.atanh(0.0) == 0
    assert close(math.atanh(0.5), 0.5493061443340549)
    assert close(math.atanh(-0.5), -0.5493061443340549)

    try:
        math.atanh(INF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    try:
        math.atanh(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'

    assert math.isnan(math.atanh(NAN)) == True


@test
def test_copysign():
    assert math.copysign(1.0, -0.0) == -1
    assert math.copysign(1.0, 42.0) == 1
    assert math.copysign(1.0, -42.0) == -1
    assert math.copysign(3.0, 0.0) == 3
    assert math.copysign(INF, 0.0) == INF
    assert math.copysign(INF, -0.0) == NINF
    assert math.copysign(NINF, 0.0) == INF
    assert math.copysign(NINF, -0.0) == NINF
    assert math.copysign(1.0, INF) == 1
    assert math.copysign(1.0, NINF) == -1
    assert math.copysign(INF, INF) == INF
    assert math.copysign(INF, NINF) == NINF
    assert math.copysign(NINF, INF) == INF
    assert math.copysign(NINF, NINF) == NINF
    assert math.isnan(math.copysign(NAN, 1.0)) == True
    assert math.isnan(math.copysign(NAN, INF)) == True
    assert math.isnan(math.copysign(NAN, NINF)) == True
    assert math.isnan(math.copysign(NAN, NAN)) == True


@test
def test_log1p():
    assert close(math.log1p(2.0), 1.0986122886681098)
    assert close(math.log1p(2.0 ** 90), 62.383246250395075)
    assert close(math.log1p(2.0 ** 300), 207.94415416798358)
    assert math.log1p(INF) == INF
    try:
        math.log1p(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'


@test
def test_trunc():
    assert math.trunc(1.0) == 1
    assert math.trunc(-1.0) == -1
    assert math.trunc(1.5) == 1
    assert math.trunc(-1.5) == -1
    assert math.trunc(1.99999999) == 1
    assert math.trunc(-1.99999999) == -1
    assert math.trunc(0.99999999) == 0
    assert math.trunc(-100.999) == -100


@test
def test_erf():
    assert close(math.erf(1.0), 0.8427007929497148)
    assert math.erf(0.0) == 0
    assert close(math.erf(3.0), 0.9999779095030015)
    assert math.erf(256.0) == 1.0
    assert math.erf(INF) == 1.0
    assert math.erf(NINF) == -1.0
    assert math.isnan(math.erf(NAN)) == True


@test
def test_erfc():
    assert math.erfc(0.0) == 1.0
    assert close(math.erfc(1.0), 0.15729920705028516)
    assert close(math.erfc(2.0), 0.0046777349810472645)
    assert close(math.erfc(-1.0), 1.8427007929497148)
    assert math.erfc(INF) == 0.0
    assert math.erfc(NINF) == 2.0
    assert math.isnan(math.erfc(NAN)) == True


@test
def test_gamma():
    assert close(math.gamma(6.0), 120.0)
    assert close(math.gamma(1.0), 1.0)
    assert close(math.gamma(2.0), 1.0)
    assert close(math.gamma(3.0), 2.0)
    try:
        math.gamma(-1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.gamma(INF) == INF
    try:
        math.gamma(NINF)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.gamma(NAN)) == True


@test
def test_lgamma():
    assert math.lgamma(1.0) == 0.0
    assert math.lgamma(2.0) == 0.0
    #assert math.lgamma(-1.0) == INF  # Python's custom lgamma gives math domain error
    assert math.lgamma(INF) == INF
    assert math.lgamma(NINF) == INF
    assert math.isnan(math.lgamma(NAN)) == True


@test
def test_remainder():
    assert math.remainder(2.0, 2.0) == 0.0
    assert math.remainder(-4.0, 1.0) == -0.0
    assert close(math.remainder(-3.8, 1.0), 0.20000000000000018)
    assert close(math.remainder(3.8, 1.0), -0.20000000000000018)
    try:
        math.remainder(INF, 1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    try:
        math.remainder(NINF, 1.0)
        assert False
    except ValueError as e:
        assert str(e) == 'math domain error'
    assert math.isnan(math.remainder(NAN, 1.0)) == True


@test
def test_gcd():
    assert math.gcd(0.0, 0.0) == 0
    assert math.gcd(1.0, 0.0) == 1
    assert math.gcd(-1.0, 0.0) == 1
    assert math.gcd(0.0, -1.0) == 1
    assert math.gcd(0.0, 1.0) == 1
    assert math.gcd(7.0, 1.0) == 1
    assert math.gcd(7.0, -1.0) == 1
    assert math.gcd(-23.0, 15.0) == 1
    assert math.gcd(120.0, 84.0) == 12
    assert math.gcd(84.0, -120.0) == 12


@test
def test_frexp():
    assert math.frexp(-2.0) == (-0.5, 2)
    assert math.frexp(-1.0) == (-0.5, 1)
    assert math.frexp(0.0) == (0.0, 0)
    assert math.frexp(1.0) == (0.5, 1)
    assert math.frexp(2.0) == (0.5, 2)
    assert math.frexp(INF)[0] == INF
    assert math.frexp(NINF)[0] == NINF
    assert math.isnan(math.frexp(NAN)[0]) == True


@test
def test_modf():
    assert math.modf(1.5) == (0.5, 1.0)
    assert math.modf(-1.5) == (-0.5, -1.0)
    assert math.modf(math.inf) == (0.0, INF)
    assert math.modf(-math.inf) == (-0.0, NINF)
    modf_nan = math.modf(NAN)
    assert math.isnan(modf_nan[0]) == True
    assert math.isnan(modf_nan[1]) == True


@test
def test_isclose():
    assert math.isclose(1.0 + 1.0, 1.000000000001 + 1.0) == True
    assert math.isclose(2.90909324093284, 2.909093240932844234234234234) == True
    assert math.isclose(2.90909324093284, 2.9) == False
    assert math.isclose(2.90909324093284, 2.90909324) == True
    assert math.isclose(2.90909324, 2.90909325) == False
    assert math.isclose(NAN, 2.9) == False
    assert math.isclose(2.9, NAN) == False
    assert math.isclose(INF, INF) == True
    assert math.isclose(NINF, NINF) == True
    assert math.isclose(NINF, INF) == False
    assert math.isclose(INF, NINF) == False

test_py_numerics_int()
test_py_numerics_float()

test_isnan()
test_isinf()
test_isfinite()
test_ceil()
test_floor()
test_fabs()
test_fmod()
test_exp()
test_expm1()
test_ldexp()
test_log()
test_log2()
test_log10()
test_degrees()
test_radians()
test_sqrt()
test_pow()
test_acos()
test_asin()
test_atan()
test_atan2()
test_cos()
test_sin()
test_hypot()
test_tan()
test_cosh()
test_sinh()
test_tanh()
test_acosh()
test_asinh()
test_atanh()
test_copysign()
test_log1p()
test_trunc()
test_erf()
test_erfc()
test_gamma()
test_lgamma()
test_remainder()
test_gcd()
test_frexp()
test_modf()
test_isclose()
</t>
<t tx="ekr.20230509083244.74">@path C:/Repos/codon/test/core/
@language unknown_language
x, y = 1, 2
print x, y # EXPECT: 1 2
(x, y) = (3, 4)
print x, y # EXPECT: 3 4
x, y = (1, 2)
print x, y # EXPECT: 1 2
(x, y) = 3, 4
print x, y # EXPECT: 3 4
(x, y) = [3, 4]
print x, y # EXPECT: 3 4
[x, y] = [1, 2]
print x, y # EXPECT: 1 2

# TODO generator/range slices?
# a, b, *tx, c, d = range(10)
# print a, b, tx, c, d # 0 1 [2, 3, 4, 5, 6, 7] 8 9

l = list(iter(range(10)))
[a, b, *lx, c, d] = l
print a, b, lx, c, d # EXPECT: 0 1 [2, 3, 4, 5, 6, 7] 8 9
a, b, *lx = l
print a, b, lx # EXPECT: 0 1 [2, 3, 4, 5, 6, 7, 8, 9]
*lx, a, b = l
print lx, a, b # EXPECT: [0, 1, 2, 3, 4, 5, 6, 7] 8 9

*xz, a, b = (1, 2, 3, 4, 5)
print xz, a, b # EXPECT: (1, 2, 3) 4 5


# *x = range(5) # ERR
(*ex,) = [1, 2, 3]
print ex # EXPECT: [1, 2, 3]

# https://stackoverflow.com/questions/6967632/unpacking-extended-unpacking-and-nested-extended-unpacking

sa, sb = 'XY'
print sa, sb # EXPECT: X Y
(sa, sb), sc = 'XY', 'Z'
print sa, sb, sc # EXPECT: X Y Z
# (sa, sb), sc = 'XYZ' # ERROR:

sa, *la = 'X'
print sa, la, 1 # EXPECT: X  1

sa, *la = 'XYZ'
print sa, la # EXPECT: X YZ

# a, *b, c, *d = 1,2,3,4,5             # ERROR -- two starred expressions in assignment

(xa,xb), *xc, xd = [1,2],'this'
print xa, xb, xc, xd # EXPECT: 1 2 () this

(a, b), (sc, *sl) = [1,2], 'this'
print a, b, sc, sl # EXPECT: 1 2 t his



# // a, b, *x, c, d = y
#   // (^) = y
#   // [^] = y
#   // *a = y NO ; *a, = y YES
#   // (a, b), c = d, e
#   // *(a, *b), c = this
#   // a = *iterable


# # Issue #116
# def foo():
#     a = 42
#     def bar():
#         print a  # &lt;-- this should be a parser error; 'a' has to be global
#     bar()
# foo() # ERROR: identifier 'a' not found
</t>
<t tx="ekr.20230509083244.75">@path C:/Repos/codon/test/core/
@language unknown_language
from threading import Lock, RLock

n = 0
f = 0.0
g = f32(0.0)

@atomic
def inc(_):
    global n, f, g
    n += 1
    f += 1.0
    g += f32(1.0)
    return 0

@atomic
def dec(_):
    global n, f, g
    n -= 1
    f -= 1.0
    g -= f32(1.0)
    return 0

lock = Lock()
def inc_lock(_):
    global n
    with lock:
        n += 1
    return 0

def dec_lock(_):
    global n
    with lock:
        n -= 1
    return 0

rlock = RLock()
def inc_rlock(_):
    global n
    with rlock:
        n += 1
    return 0

def dec_rlock(_):
    global n
    with rlock:
        n -= 1
    return 0

def foo(_):
    yield 0

@test
def test_parallel_pipe(m: int):
    global n, f
    n, f = 0, 0.0
    range(m) |&gt; iter ||&gt; inc
    assert n == m
    assert f == float(m)
    assert g == f32(m)
    range(m) |&gt; iter ||&gt; dec
    assert n == 0
    assert f == 0.0
    assert g == f32(0.0)
    range(m) |&gt; iter ||&gt; inc |&gt; dec
    assert n == 0
    assert f == 0.0
    assert g == f32(0.0)

    n = 0
    range(m) |&gt; iter ||&gt; inc_lock
    assert n == m
    range(m) |&gt; iter ||&gt; dec_lock
    assert n == 0
    range(m) |&gt; iter ||&gt; inc_lock |&gt; dec_lock
    assert n == 0

    n = 0
    range(m) |&gt; iter ||&gt; inc_rlock
    assert n == m
    range(m) |&gt; iter ||&gt; dec_rlock
    assert n == 0
    range(m) |&gt; iter ||&gt; inc_rlock |&gt; dec_rlock
    assert n == 0

@test
def test_nested_parallel_pipe(m: int):
    global n
    n = 0
    range(m) |&gt; iter ||&gt; inc |&gt; foo ||&gt; dec
    assert n == 0

test_parallel_pipe(0)
test_parallel_pipe(1)
test_parallel_pipe(10)
test_parallel_pipe(10000)

test_nested_parallel_pipe(0)
test_nested_parallel_pipe(1)
test_nested_parallel_pipe(10)
test_nested_parallel_pipe(10000)
</t>
<t tx="ekr.20230509083244.76">@path C:/Repos/codon/test/core/
@language unknown_language
# test adapted from https://github.com/python/cpython/blob/master/Lib/test/test_range.py

@test
def test_range():
    assert list(range(3)) == [0, 1, 2]
    assert list(range(1, 5)) == [1, 2, 3, 4]
    assert list(range(0)) == list[int]()
    assert list(range(-3)) == list[int]()
    assert list(range(1, 10, 3)) == [1, 4, 7]
    assert list(range(5, -5, -3)) == [5, 2, -1, -4]

    a = 10
    b = 100
    c = 50

    assert list(range(a, a+2)) == [a, a+1]
    assert list(range(a+2, a, -1)) == [a+2, a+1]
    assert list(range(a+4, a, -2)) == [a+4, a+2]

    s = list(range(a, b, c))
    assert a in s
    assert b not in s
    assert len(s) == 2

    s = list(range(b, a, -c))
    assert b in s
    assert a not in s
    assert len(s) == 2

    s = list(range(-a, -b, -c))
    assert -a in s
    assert -b not in s
    assert len(s) == 2

    val_err = False
    try:
        range(1, 2, 0)
    except ValueError:
        val_err = True
    assert val_err

@test
def test_index():
    u = range(2)
    assert u.index(0) == 0
    assert u.index(1) == 1
    val_err = False
    try:
        u.index(2)
    except ValueError:
        val_err = True
    assert val_err

    u = range(-2, 3)
    assert u.count(0) == 1
    assert u.index(0) == 2

    a = range(-2, 3)
    assert a.index(0) == 2

    assert range(1, 10, 3).index(4) == 1
    assert range(1, -10, -3).index(-5) == 2

@test
def test_count():
    assert range(3).count(-1) == 0
    assert range(3).count(0) == 1
    assert range(3).count(1) == 1
    assert range(3).count(2) == 1
    assert range(3).count(3) == 0
    assert range(3).index(1) == 1
    assert range(7, 0, -2).count(5) == 1
    assert range(7, 0, -2).count(-2) == 0
    assert range(7, 0, -1).count(0) == 0
    assert range(7, 0, -1).count(1) == 1

@test
def test_repr():
    assert str(range(1)) == 'range(0, 1)'
    assert str(range(1, 2)) == 'range(1, 2)'
    assert str(range(1, 2, 3)) == 'range(1, 2, 3)'

@test
def test_strided_limits():
    r = range(0, 101, 2)
    assert 0 in r
    assert 1 not in r
    assert 2 in r
    assert 99 not in r
    assert 100 in r
    assert 101 not in r

    r = range(0, -20, -1)
    assert 0 in r
    assert -1 in r
    assert -19 in r
    assert -20 not in r

    r = range(0, -20, -2)
    assert -18 in r
    assert -19 not in r
    assert -20 not in r

@test
def test_empty():
    r = range(0)
    assert 0 not in r
    assert 1 not in r

    r = range(0, -10)
    assert 0 not in r
    assert -1 not in r
    assert 1 not in r

@test
def test_slice():
    r = range(10)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(0)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(1, 9, 3)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

    r = range(8, 0, -3)
    assert list(r[:2]) == list(r)[:2]
    assert list(r[0:2]) == list(r)[0:2]
    assert list(r[0:20]) == list(r)[0:20]
    assert list(r[:20]) == list(r)[:20]
    assert list(r[1:2]) == list(r)[1:2]
    assert list(r[20:30]) == list(r)[20:30]
    assert list(r[-30:-20]) == list(r)[-30:-20]
    assert list(r[-1:100:2]) == list(r)[-1:100:2]
    assert list(r[0:-1]) == list(r)[0:-1]
    assert list(r[-1:-3:-1]) == list(r)[-1:-3:-1]

@test
def test_contains():
    r = range(10)
    assert 0 in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

    r = range(9, -1, -1)
    assert 0 in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

    r = range(0, 10, 2)
    assert 0 in r
    assert 1 not in r
    assert 5 not in r
    assert -1 not in r
    assert 10 not in r

    r = range(9, -1, -2)
    assert 0 not in r
    assert 1 in r
    assert 5 in r
    assert -1 not in r
    assert 10 not in r

@test
def test_reverse_iteration():
    for r in [range(10),
              range(0),
              range(1, 9, 3),
              range(8, 0, -3),
              ]:
        assert list(reversed(r)) == list(r)[::-1]

test_range()
test_index()
test_count()
test_repr()
test_strided_limits()
test_empty()
test_slice()
test_contains()
test_reverse_iteration()
</t>
<t tx="ekr.20230509083244.77">@path C:/Repos/codon/test/core/
@language unknown_language
import pickle
from copy import copy

@tuple
class MyType:
    a: i32
    b: str
    c: float

class A:
    a: int
    v: list[str]

    def __eq__(self: A, other: A):
        return self.a == other.a and self.v == other.v

    def __ne__(self: A, other: A):
        return not (self == other)

    def __hash__(self: A):
        return self.a

    def __copy__(self: A):
        return A(self.a, copy(self.v))

@test
def test_pickle[T](x: T):
    import gzip
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, T)
    jar.close()

    assert x == y

@test
def test_non_atomic_list_pickle[T](x: list[list[T]]):
    import gzip
    copy = [copy(a) for a in x]
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for v in x:
        v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, list[list[T]])
    jar.close()

    assert y == copy

@test
def test_non_atomic_dict_pickle[T](x: dict[str, list[T]]):
    import gzip
    copy = {k: copy(v) for k,v in x.items()}
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for v in x.values():
        v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, dict[str, list[T]])
    jar.close()

    assert y == copy

@test
def test_non_atomic_set_pickle(x: set[A]):
    import gzip
    copy = {copy(a) for a in x}
    path = 'build/testjar.bin'
    jar = gzip.open(path, 'wb')
    pickle.dump(x, jar)
    jar.close()

    for a in x:
        a.v.clear()

    jar = gzopen(path, 'rb')
    y = pickle.load(jar, set[A])
    jar.close()

    assert y == copy

test_pickle(42)
test_pickle(3.14)
test_pickle(True)
test_pickle(byte(90))
test_pickle(UInt[123](123123123))
test_pickle(Int[123](-123123123))
test_pickle([11, 22, 33, 44])
test_pickle({11, 22, 33, 44})
test_pickle({11: 1.1, 22: 2.2, 33: 3.3, 44: 4.4})
test_pickle('hello world')
test_pickle('')
test_pickle(MyType(i32(-1001), 'xyz', 5.55))
test_pickle((A(1, ['x', 'abc', '1.1.1.1']), 42, A(1000, ['foo'])))
test_pickle(['ACGTAAGG', 'TATCTGTT'])
test_pickle(list[Int[8]]())
test_pickle({'ACGTAAGG', 'CATTTTTA'})
test_pickle({'ACGTAAGG'})
test_pickle({'ACGTAAGG', 'TTTTGGTT'})
test_pickle(set[Int[8]]())
test_pickle({'ACGTAAGG': 99, 'TTATTCTT': 42})
test_pickle(dict[Int[8],Int[8]]())
test_pickle({'ACGTAAGG': 'ACGTAAGG'})
test_pickle((42, 3.14, True, byte(90), 'ACGTAAGG', 'ACGTAAGG'))
test_pickle(DynamicTuple((111, 222, 333, 444)))
test_pickle(DynamicTuple('hello world'))
test_pickle(DynamicTuple[int]())
test_pickle(DynamicTuple[str]())
test_pickle({i32(42): [[{'ACG', 'ACGTAGCG', 'ACGTAGCG'}, {'ACG', 'ACGTAGCG', 'ACGTAGCG'}], list[set[str]](), [set[str]()], [{''}, {'', 'GCGC'}]]})

test_non_atomic_list_pickle([[3,2,1], [-1,-2,-3], [111,999,888,777], list[int]()])
test_non_atomic_dict_pickle({'first': [3,2,1], 'second': [-1,-2,-3], 'third': [111,999,888,777], 'fourth:': list[int]()})
test_non_atomic_set_pickle({A(42, ['fourty', 'two']), A(0, list[str]()), A(-99, ['negative', 'ninety', 'nine'])})
</t>
<t tx="ekr.20230509083244.78">@path C:/Repos/codon/test/core/
@language unknown_language
MANUAL_TEST = False

def print_test[T](a: list[T], b: list[T]):
    if not MANUAL_TEST:
        print(a)
        return

    if len(a) != len(b):
        print(f"FAILED: length of a ({len(a)}) is not length of b ({len(b)})")
        return

    if len(a) == 0:
        print("PASSED")
        return

    for i in range(len(a)):
        if a[i] != b[i]:
            print(f"FAILED: element {i} of a is {a[i]} and is not equal to the element in b {b[i]}")
            return

    print("PASSED")

### Comparison Functions ###

def compare_less(x: int, y: int) -&gt; bool:
    return x &lt; y

def compare_greater(x: int, y: int) -&gt; bool:
    return x &gt; y

def compare_string(x: str, y: str) -&gt; bool:
    return x &lt; y

def compare_dict(x: dict[str,int], y: dict[str,int]) -&gt; bool:
    return x["key"] &lt; y["key"]

### Basic Sort Tests ###
print_test(insertion_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(insertion_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(insertion_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(insertion_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(insertion_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(heap_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(heap_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(heap_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(heap_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(heap_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(pdq_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(pdq_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(pdq_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(pdq_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(pdq_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]

print_test(tim_sort(list[int](), compare_less), list[int]()) # EXPECT: []
print_test(tim_sort([1, 2, 3], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(tim_sort([3, 2, 1], compare_less), [1, 2, 3]) # EXPECT: [1, 2, 3]
print_test(tim_sort([3, 2, 1], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(tim_sort([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]


### Sort Different Types ###
words = ['The', 'quick', 'Brown', 'fox', 'Jumped', 'over', 'The', 'lazy', 'Dog']
dicts = [{"key": 5}, {"key": 9}, {"key": 1}]

print_test(insertion_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(insertion_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(insertion_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(heap_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(heap_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(heap_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(pdq_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(pdq_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(pdq_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

print_test(tim_sort(list[str](), compare_string), list[str]()) # EXPECT: []
print_test(tim_sort(words, compare_string), ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']) # EXPECT: ['Brown', 'Dog', 'Jumped', 'The', 'The', 'fox', 'lazy', 'over', 'quick']
print_test(tim_sort(dicts, compare_dict), [{"key": 1}, {"key": 5}, {"key": 9}]) # EXPECT: [{"key": 1}, {"key": 5}, {"key": 9}]

### Sort longer lists ###
ordered = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
ordered_r = [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
unordered = [98, 57, 39, 5, 70, 80, 93, 65, 96, 43, 99, 18, 26, 1, 46, 94, 55, 37, 95, 32, 49, 2, 24, 14, 9, 53, 64, 62, 16, 33, 77, 35, 69, 19, 44, 51, 76, 66, 52, 83, 38, 3, 20, 54, 100, 7, 6, 17, 84, 73, 58, 10, 11, 40, 15, 12, 68, 45, 81, 78, 30, 97, 13, 82, 79, 27, 22, 90, 74, 41, 29, 56, 50, 92, 71, 89, 72, 8, 91, 88, 23, 4, 59, 63, 36, 47, 86, 61, 25, 67, 34, 75, 85, 87, 31, 60, 42, 21, 28, 48]

print_test(insertion_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(insertion_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(insertion_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(heap_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(heap_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(heap_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(pdq_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(pdq_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(pdq_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

print_test(tim_sort(ordered, compare_greater), [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) # EXPECT: [100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
print_test(tim_sort(ordered_r, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
print_test(tim_sort(unordered, compare_less), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) # EXPECT: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]

### Testing Stability ###

@test
def test_stable():
    data_list = [{'key': 58, 'key2': 1}, {'key': 37, 'key2': 1}, {'key': 41, 'key2': 1}, {'key': 91, 'key2': 1}, {'key': 8, 'key2': 1}, {'key': 15, 'key2': 1}, {'key': 28, 'key2': 1}, {'key': 45, 'key2': 1}, {'key': 84, 'key2': 1}, {'key': 94, 'key2': 1}, {'key': 75, 'key2': 1}, {'key': 70, 'key2': 1}, {'key': 64, 'key2': 1}, {'key': 17, 'key2': 1}, {'key': 47, 'key2': 1}, {'key': 11, 'key2': 1}, {'key': 97, 'key2': 1}, {'key': 19, 'key2': 1}, {'key': 92, 'key2': 1}, {'key': 82, 'key2': 1}, {'key': 7, 'key2': 1}, {'key': 77, 'key2': 1}, {'key': 69, 'key2': 1}, {'key': 87, 'key2': 1}, {'key': 72, 'key2': 1}, {'key': 48, 'key2': 1}, {'key': 35, 'key2': 1}, {'key': 26, 'key2': 1}, {'key': 60, 'key2': 1}, {'key': 78, 'key2': 1}, {'key': 67, 'key2': 1}, {'key': 12, 'key2': 1}, {'key': 9, 'key2': 1}, {'key': 79, 'key2': 1}, {'key': 38, 'key2': 1}, {'key': 88, 'key2': 1}, {'key': 86, 'key2': 1}, {'key': 3, 'key2': 1}, {'key': 30, 'key2': 1}, {'key': 89, 'key2': 1}, {'key': 2, 'key2': 1}, {'key': 40, 'key2': 1}, {'key': 81, 'key2': 1}, {'key': 39, 'key2': 1}, {'key': 99, 'key2': 1}, {'key': 5, 'key2': 1}, {'key': 90, 'key2': 1}, {'key': 18, 'key2': 1}, {'key': 1, 'key2': 1}, {'key': 68, 'key2': 1}, {'key': 98, 'key2': 1}, {'key': 27, 'key2': 1}, {'key': 33, 'key2': 1}, {'key': 49, 'key2': 1}, {'key': 62, 'key2': 1}, {'key': 63, 'key2': 1}, {'key': 55, 'key2': 1}, {'key': 71, 'key2': 1}, {'key': 73, 'key2': 1}, {'key': 93, 'key2': 1}, {'key': 57, 'key2': 1}, {'key': 32, 'key2': 1}, {'key': 10, 'key2': 1}, {'key': 23, 'key2': 1}, {'key': 0, 'key2': 1}, {'key': 61, 'key2': 1}, {'key': 95, 'key2': 1}, {'key': 66, 'key2': 1}, {'key': 80, 'key2': 1}, {'key': 4, 'key2': 1}, {'key': 53, 'key2': 1}, {'key': 83, 'key2': 1}, {'key': 21, 'key2': 1}, {'key': 96, 'key2': 1}, {'key': 34, 'key2': 1}, {'key': 25, 'key2': 1}, {'key': 51, 'key2': 1}, {'key': 31, 'key2': 1}, {'key': 44, 'key2': 1}, {'key': 50, 'key2': 1}, {'key': 22, 'key2': 1}, {'key': 36, 'key2': 1}, {'key': 76, 'key2': 1}, {'key': 59, 'key2': 1}, {'key': 14, 'key2': 1}, {'key': 20, 'key2': 1}, {'key': 74, 'key2': 1}, {'key': 13, 'key2': 1}, {'key': 85, 'key2': 1}, {'key': 24, 'key2': 1}, {'key': 56, 'key2': 1}, {'key': 42, 'key2': 1}, {'key': 6, 'key2': 1}, {'key': 16, 'key2': 1}, {'key': 29, 'key2': 1}, {'key': 52, 'key2': 1}, {'key': 54, 'key2': 1}, {'key': 43, 'key2': 1}, {'key': 65, 'key2': 1}, {'key': 46, 'key2': 1}, {'key': 59, 'key2': 2}, {'key': 52, 'key2': 2}, {'key': 8, 'key2': 2}, {'key': 82, 'key2': 2}, {'key': 98, 'key2': 2}, {'key': 67, 'key2': 2}, {'key': 78, 'key2': 2}, {'key': 12, 'key2': 2}, {'key': 60, 'key2': 2}, {'key': 18, 'key2': 2}, {'key': 72, 'key2': 2}, {'key': 80, 'key2': 2}, {'key': 9, 'key2': 2}, {'key': 35, 'key2': 2}, {'key': 90, 'key2': 2}, {'key': 85, 'key2': 2}, {'key': 38, 'key2': 2}, {'key': 64, 'key2': 2}, {'key': 6, 'key2': 2}, {'key': 41, 'key2': 2}, {'key': 10, 'key2': 2}, {'key': 94, 'key2': 2}, {'key': 7, 'key2': 2}, {'key': 21, 'key2': 2}, {'key': 29, 'key2': 2}, {'key': 20, 'key2': 2}, {'key': 44, 'key2': 2}, {'key': 55, 'key2': 2}, {'key': 69, 'key2': 2}, {'key': 2, 'key2': 2}, {'key': 26, 'key2': 2}, {'key': 62, 'key2': 2}, {'key': 45, 'key2': 2}, {'key': 14, 'key2': 2}, {'key': 63, 'key2': 2}, {'key': 47, 'key2': 2}, {'key': 22, 'key2': 2}, {'key': 74, 'key2': 2}, {'key': 56, 'key2': 2}, {'key': 70, 'key2': 2}, {'key': 79, 'key2': 2}, {'key': 68, 'key2': 2}, {'key': 13, 'key2': 2}, {'key': 76, 'key2': 2}, {'key': 58, 'key2': 2}, {'key': 99, 'key2': 2}, {'key': 61, 'key2': 2}, {'key': 5, 'key2': 2}, {'key': 96, 'key2': 2}, {'key': 0, 'key2': 2}, {'key': 81, 'key2': 2}, {'key': 87, 'key2': 2}, {'key': 57, 'key2': 2}, {'key': 40, 'key2': 2}, {'key': 3, 'key2': 2}, {'key': 33, 'key2': 2}, {'key': 15, 'key2': 2}, {'key': 77, 'key2': 2}, {'key': 1, 'key2': 2}, {'key': 24, 'key2': 2}, {'key': 27, 'key2': 2}, {'key': 86, 'key2': 2}, {'key': 25, 'key2': 2}, {'key': 88, 'key2': 2}, {'key': 51, 'key2': 2}, {'key': 16, 'key2': 2}, {'key': 32, 'key2': 2}, {'key': 97, 'key2': 2}, {'key': 28, 'key2': 2}, {'key': 23, 'key2': 2}, {'key': 54, 'key2': 2}, {'key': 31, 'key2': 2}, {'key': 65, 'key2': 2}, {'key': 46, 'key2': 2}, {'key': 50, 'key2': 2}, {'key': 17, 'key2': 2}, {'key': 89, 'key2': 2}, {'key': 39, 'key2': 2}, {'key': 95, 'key2': 2}, {'key': 84, 'key2': 2}, {'key': 92, 'key2': 2}, {'key': 93, 'key2': 2}, {'key': 75, 'key2': 2}, {'key': 34, 'key2': 2}, {'key': 36, 'key2': 2}, {'key': 43, 'key2': 2}, {'key': 30, 'key2': 2}, {'key': 71, 'key2': 2}, {'key': 66, 'key2': 2}, {'key': 4, 'key2': 2}, {'key': 42, 'key2': 2}, {'key': 19, 'key2': 2}, {'key': 37, 'key2': 2}, {'key': 53, 'key2': 2}, {'key': 49, 'key2': 2}, {'key': 73, 'key2': 2}, {'key': 91, 'key2': 2}, {'key': 11, 'key2': 2}, {'key': 48, 'key2': 2}, {'key': 83, 'key2': 2}]
    sorted_list = [{'key': 0, 'key2': 1}, {'key': 0, 'key2': 2}, {'key': 1, 'key2': 1}, {'key': 1, 'key2': 2}, {'key': 2, 'key2': 1}, {'key': 2, 'key2': 2}, {'key': 3, 'key2': 1}, {'key': 3, 'key2': 2}, {'key': 4, 'key2': 1}, {'key': 4, 'key2': 2}, {'key': 5, 'key2': 1}, {'key': 5, 'key2': 2}, {'key': 6, 'key2': 1}, {'key': 6, 'key2': 2}, {'key': 7, 'key2': 1}, {'key': 7, 'key2': 2}, {'key': 8, 'key2': 1}, {'key': 8, 'key2': 2}, {'key': 9, 'key2': 1}, {'key': 9, 'key2': 2}, {'key': 10, 'key2': 1}, {'key': 10, 'key2': 2}, {'key': 11, 'key2': 1}, {'key': 11, 'key2': 2}, {'key': 12, 'key2': 1}, {'key': 12, 'key2': 2}, {'key': 13, 'key2': 1}, {'key': 13, 'key2': 2}, {'key': 14, 'key2': 1}, {'key': 14, 'key2': 2}, {'key': 15, 'key2': 1}, {'key': 15, 'key2': 2}, {'key': 16, 'key2': 1}, {'key': 16, 'key2': 2}, {'key': 17, 'key2': 1}, {'key': 17, 'key2': 2}, {'key': 18, 'key2': 1}, {'key': 18, 'key2': 2}, {'key': 19, 'key2': 1}, {'key': 19, 'key2': 2}, {'key': 20, 'key2': 1}, {'key': 20, 'key2': 2}, {'key': 21, 'key2': 1}, {'key': 21, 'key2': 2}, {'key': 22, 'key2': 1}, {'key': 22, 'key2': 2}, {'key': 23, 'key2': 1}, {'key': 23, 'key2': 2}, {'key': 24, 'key2': 1}, {'key': 24, 'key2': 2}, {'key': 25, 'key2': 1}, {'key': 25, 'key2': 2}, {'key': 26, 'key2': 1}, {'key': 26, 'key2': 2}, {'key': 27, 'key2': 1}, {'key': 27, 'key2': 2}, {'key': 28, 'key2': 1}, {'key': 28, 'key2': 2}, {'key': 29, 'key2': 1}, {'key': 29, 'key2': 2}, {'key': 30, 'key2': 1}, {'key': 30, 'key2': 2}, {'key': 31, 'key2': 1}, {'key': 31, 'key2': 2}, {'key': 32, 'key2': 1}, {'key': 32, 'key2': 2}, {'key': 33, 'key2': 1}, {'key': 33, 'key2': 2}, {'key': 34, 'key2': 1}, {'key': 34, 'key2': 2}, {'key': 35, 'key2': 1}, {'key': 35, 'key2': 2}, {'key': 36, 'key2': 1}, {'key': 36, 'key2': 2}, {'key': 37, 'key2': 1}, {'key': 37, 'key2': 2}, {'key': 38, 'key2': 1}, {'key': 38, 'key2': 2}, {'key': 39, 'key2': 1}, {'key': 39, 'key2': 2}, {'key': 40, 'key2': 1}, {'key': 40, 'key2': 2}, {'key': 41, 'key2': 1}, {'key': 41, 'key2': 2}, {'key': 42, 'key2': 1}, {'key': 42, 'key2': 2}, {'key': 43, 'key2': 1}, {'key': 43, 'key2': 2}, {'key': 44, 'key2': 1}, {'key': 44, 'key2': 2}, {'key': 45, 'key2': 1}, {'key': 45, 'key2': 2}, {'key': 46, 'key2': 1}, {'key': 46, 'key2': 2}, {'key': 47, 'key2': 1}, {'key': 47, 'key2': 2}, {'key': 48, 'key2': 1}, {'key': 48, 'key2': 2}, {'key': 49, 'key2': 1}, {'key': 49, 'key2': 2}, {'key': 50, 'key2': 1}, {'key': 50, 'key2': 2}, {'key': 51, 'key2': 1}, {'key': 51, 'key2': 2}, {'key': 52, 'key2': 1}, {'key': 52, 'key2': 2}, {'key': 53, 'key2': 1}, {'key': 53, 'key2': 2}, {'key': 54, 'key2': 1}, {'key': 54, 'key2': 2}, {'key': 55, 'key2': 1}, {'key': 55, 'key2': 2}, {'key': 56, 'key2': 1}, {'key': 56, 'key2': 2}, {'key': 57, 'key2': 1}, {'key': 57, 'key2': 2}, {'key': 58, 'key2': 1}, {'key': 58, 'key2': 2}, {'key': 59, 'key2': 1}, {'key': 59, 'key2': 2}, {'key': 60, 'key2': 1}, {'key': 60, 'key2': 2}, {'key': 61, 'key2': 1}, {'key': 61, 'key2': 2}, {'key': 62, 'key2': 1}, {'key': 62, 'key2': 2}, {'key': 63, 'key2': 1}, {'key': 63, 'key2': 2}, {'key': 64, 'key2': 1}, {'key': 64, 'key2': 2}, {'key': 65, 'key2': 1}, {'key': 65, 'key2': 2}, {'key': 66, 'key2': 1}, {'key': 66, 'key2': 2}, {'key': 67, 'key2': 1}, {'key': 67, 'key2': 2}, {'key': 68, 'key2': 1}, {'key': 68, 'key2': 2}, {'key': 69, 'key2': 1}, {'key': 69, 'key2': 2}, {'key': 70, 'key2': 1}, {'key': 70, 'key2': 2}, {'key': 71, 'key2': 1}, {'key': 71, 'key2': 2}, {'key': 72, 'key2': 1}, {'key': 72, 'key2': 2}, {'key': 73, 'key2': 1}, {'key': 73, 'key2': 2}, {'key': 74, 'key2': 1}, {'key': 74, 'key2': 2}, {'key': 75, 'key2': 1}, {'key': 75, 'key2': 2}, {'key': 76, 'key2': 1}, {'key': 76, 'key2': 2}, {'key': 77, 'key2': 1}, {'key': 77, 'key2': 2}, {'key': 78, 'key2': 1}, {'key': 78, 'key2': 2}, {'key': 79, 'key2': 1}, {'key': 79, 'key2': 2}, {'key': 80, 'key2': 1}, {'key': 80, 'key2': 2}, {'key': 81, 'key2': 1}, {'key': 81, 'key2': 2}, {'key': 82, 'key2': 1}, {'key': 82, 'key2': 2}, {'key': 83, 'key2': 1}, {'key': 83, 'key2': 2}, {'key': 84, 'key2': 1}, {'key': 84, 'key2': 2}, {'key': 85, 'key2': 1}, {'key': 85, 'key2': 2}, {'key': 86, 'key2': 1}, {'key': 86, 'key2': 2}, {'key': 87, 'key2': 1}, {'key': 87, 'key2': 2}, {'key': 88, 'key2': 1}, {'key': 88, 'key2': 2}, {'key': 89, 'key2': 1}, {'key': 89, 'key2': 2}, {'key': 90, 'key2': 1}, {'key': 90, 'key2': 2}, {'key': 91, 'key2': 1}, {'key': 91, 'key2': 2}, {'key': 92, 'key2': 1}, {'key': 92, 'key2': 2}, {'key': 93, 'key2': 1}, {'key': 93, 'key2': 2}, {'key': 94, 'key2': 1}, {'key': 94, 'key2': 2}, {'key': 95, 'key2': 1}, {'key': 95, 'key2': 2}, {'key': 96, 'key2': 1}, {'key': 96, 'key2': 2}, {'key': 97, 'key2': 1}, {'key': 97, 'key2': 2}, {'key': 98, 'key2': 1}, {'key': 98, 'key2': 2}, {'key': 99, 'key2': 1}, {'key': 99, 'key2': 2}]
    assert tim_sort(data_list, compare_dict) == sorted_list

### Stdlib sort tests ###
print_test(sorted(list[int](), compare_less, reverse=True), list[int]()) # EXPECT: []
print_test(sorted([3, 2, 1], reverse=True), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(sorted([1, 2, 3], compare_greater), [3, 2, 1]) # EXPECT: [3, 2, 1]
print_test(sorted([1, 2, 3], compare_greater, reverse=True), [1, 2, 3]) # EXPECT: [1, 2, 3]

</t>
<t tx="ekr.20230509083244.79">@path C:/Repos/codon/test/core/
@language unknown_language
import sys

def max(a, b):
    return a if a&gt;=b else b

class AVLNode[K,V]:
    key: K
    value: V
    parent: Optional[AVLNode[K,V]]
    left: Optional[AVLNode[K,V]]
    right: Optional[AVLNode[K,V]]
    height: int

    def __init__(self: AVLNode[K,V], parent: Optional[AVLNode[K,V]], k: K, v: V):
        self.key = k
        self.value = v
        self.parent = parent
        self.left = None
        self.right = None
        self.height = -1

    def find(self, k):
        if k &lt; self.key:
            if self.left is None:
                return None
            else:
                return self.left.find(k)
        elif k == self.key:
            return self
        else:
            if self.right is None:
                return None
            else:
                return self.right.find(k)

    def find_min(self):
        current: Optional[AVLNode[K, V]] = self
        while current.left is not None:
            current = current.left
        return current

    def next_larger(self):
        if self.right is not None:
            return self.right.find_min()
        current: Optional[AVLNode[K, V]] = self
        while current.parent is not None and current is current.parent.right:
            current = current.parent
        return current.parent

    def insert(self, node):
        if node is None:
            return
        if node.key &lt; self.key:
            if self.left is None:
                node.parent = self
                self.left = node
            else:
                self.left.insert(node)
        else:
            if self.right is None:
                node.parent = self
                self.right = node
            else:
                self.right.insert(node)

    def delete(self):
        if self.left is None or self.right is None:
            if self is self.parent.left:
                self.parent.left = self.left if self.left else self.right
                if self.parent.left is not None:
                    self.parent.left.parent = self.parent
            else:
                self.parent.right = self.left if self.left else self.right
                if self.parent.right is not None:
                    self.parent.right.parent = self.parent
            return self
        else:
            s = self.next_larger()
            self.key, s.key = s.key, self.key
            return s.delete()

    def __iter__(self: AVLNode[K,V]):
        if self.left:
            for i in self.left:
                yield i
        yield self
        if self.right:
            for i in self.right:
                yield i

def height(node):
    if node is None:
        return -1
    else:
        return node.height

def update_height(node):
    node.height = max(height(node.left), height(node.right)) + 1

class AVL[K,V]:
    root: Optional[AVLNode[K,V]]

    def __init__(self: AVL[K,V]):
        self.root = None

    def find(self, k):
        if not self.root:
            return None
        return self.root.find(k)

    def find_min(self):
        if not self.root:
            return None
        return self.root.find_min()

    def next_larger(self, k):
        node = self.find(k)
        return node.next_larger() if node else None

    def left_rotate(self, x):
        y = x.right
        y.parent = x.parent
        if y.parent is None:
            self.root = y
        else:
            if y.parent.left is x:
                y.parent.left = y
            elif y.parent.right is x:
                y.parent.right = y
        x.right = y.left
        if x.right is not None:
            x.right.parent = x
        y.left = x
        x.parent = y
        update_height(x)
        update_height(y)

    def right_rotate(self, x):
        y = x.left
        y.parent = x.parent
        if y.parent is None:
            self.root = y
        else:
            if y.parent.left is x:
                y.parent.left = y
            elif y.parent.right is x:
                y.parent.right = y
        x.left = y.right
        if x.left is not None:
            x.left.parent = x
        y.right = x
        x.parent = y
        update_height(x)
        update_height(y)

    def rebalance(self, node: Optional[AVLNode[K, V]]):
        while node is not None:
            update_height(node)
            if height(node.left) &gt;= 2 + height(node.right):
                if height(node.left.left) &gt;= height(node.left.right):
                    self.right_rotate(node)
                else:
                    self.left_rotate(node.left)
                    self.right_rotate(node)
            elif height(node.right) &gt;= 2 + height(node.left):
                if height(node.right.right) &gt;= height(node.right.left):
                    self.left_rotate(node)
                else:
                    self.right_rotate(node.right)
                    self.left_rotate(node)
            node = node.parent

    def insert(self, k, v):
        node = AVLNode[K,V](None, k, v)
        if self.root is None:
            # The root's parent is None.
            self.root = node
        else:
            self.root.insert(node)
        self.rebalance(node)

    def delete(self, k):
        node = self.find(k)
        if node is None:
            return
        deleted = None
        if node is self.root:
            pseudoroot = AVLNode[K,V](None, 0, 0)
            pseudoroot.left = self.root
            self.root.parent = pseudoroot
            deleted = self.root.delete()
            self.root = pseudoroot.left
            if self.root is not None:
                self.root.parent = None
        else:
            deleted = node.delete()
        self.rebalance(deleted.parent)

    def __setitem__(self: AVL[K,V], k: K, v: V):
        self.insert(k, v)

    def __getitem__(self: AVL[K,V], k: K):
        nd = self.find(k)
        if not nd:
            print 'whoops', k, 'not found'
            sys.exit(1)
        return nd.value

    def __delitem__(self: AVL[K,V], k: K):
        self.delete(k)

    def __contains__(self: AVL[K,V], k: K):
        return self.find(k) is not None

    def __iter__(self: AVL[K,V]):
        if self.root:
            for i in self.root:
                yield i.key, i.value

d1 = AVL[int,int]()
for a in range(5):
    d1[a] = a*a

# EXPECT: 0
# EXPECT: 1
# EXPECT: 4
# EXPECT: 9
# EXPECT: 16
for a in range(5):
    print d1[a]

print 2 in d1  # EXPECT: True
del d1[2]
print 2 in d1  # EXPECT: False
d1[2] = 44
print 2 in d1  # EXPECT: True
print d1[2]    # EXPECT: 44

del d1[3]
del d1[4]

# EXPECT: 0 0
# EXPECT: 1 1
# EXPECT: 2 44
for t in d1:
    print t[0], t[1]
</t>
<t tx="ekr.20230509083244.8">  void handle(ir::CallInstr *v) override {
    using namespace codon::ir;
    if (auto *f = cast&lt;Func&gt;(util::getFunc(v-&gt;getCallee()))) {
      if (f-&gt;getUnmangledName() == "expect_capture") {
        // Format is:
        //   - Return captures (bool)
        //   - Extern captures (bool)
        //   - Captured arg indices (int tuple)
        std::vector&lt;Value *&gt; args(v-&gt;begin(), v-&gt;end());
        seqassertn(args.size() == 3, "bad escape-test call (size)");
        seqassertn(isA&lt;BoolConst&gt;(args[0]) &amp;&amp; isA&lt;BoolConst&gt;(args[1]),
                   "bad escape-test call (arg types)");

        ir::analyze::dataflow::CaptureInfo info;
        info.returnCaptures = cast&lt;BoolConst&gt;(args[0])-&gt;getVal();
        info.externCaptures = cast&lt;BoolConst&gt;(args[1])-&gt;getVal();
        auto *tuple = cast&lt;CallInstr&gt;(args[2]);
        seqassertn(tuple,
                   "last escape-test call argument should be a const tuple literal");

        for (auto *arg : *tuple) {
          seqassertn(isA&lt;IntConst&gt;(arg), "final args should be int");
          info.argCaptures.push_back(cast&lt;IntConst&gt;(arg)-&gt;getVal());
        }

        expected.push_back(info);
        calls.push_back(v);
      }
    }
  }
</t>
<t tx="ekr.20230509083244.80"></t>
<t tx="ekr.20230509083244.81">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% ptr,barebones
import internal.gc as gc
print gc.sizeof(Ptr[int]) #: 8
print gc.atomic(Ptr[int]) #: False
y = Ptr[int](1)
y[0] = 11
print y[0] #: 11
_y = y.as_byte()
print int(_y[0]) #: 11
y = Ptr[int](5)
y[0] = 1; y[1] = 2; y[2] = 3; y[3] = 4; y[4] = 5
z = Ptr[int](y)
print y[1], z[2] #: 2 3
z = Ptr[int](y.as_byte())
print y[1], z[2] #: 2 3
print z.__bool__() #: True
z.__int__() # big number...
zz = z.__copy__() # this is not a deep copy!
zz[2] = 10
print z[2], zz[2] #: 10 10
print y.__getitem__(1) #: 2
y.__setitem__(1, 3)
print y[1] #: 3
print y.__add__(1)[0] #: 3
print (y + 3).__sub__(y + 1) #: 2
print y.__eq__(z) #: True
print y.__eq__(zz) #: True
print y.as_byte().__eq__('abc'.ptr) #: False
print y.__ne__(z) #: False
print y.__lt__(y+1) #: True
print y.__gt__(y+1) #: False
print (y+1).__le__(y) #: False
print y.__ge__(y) #: True
y.__prefetch_r0__()
y.__prefetch_r1__()
y.__prefetch_r2__()
y.__prefetch_r3__()
y.__prefetch_w0__()
y.__prefetch_w1__()
y.__prefetch_w2__()
y.__prefetch_w3__()

#%% int,barebones
a = int()
b = int(5)
c = int(True)
d = int(byte(1))
e = int(1.1)
print a, b, c, d, e #: 0 5 1 1 1
print a.__repr__() #: 0
print b.__copy__() #: 5
print b.__hash__() #: 5
print a.__bool__(), b.__bool__() #: False True
print a.__pos__() #: 0
print b.__neg__() #: -5
print (-b).__abs__() #: 5
print c.__truediv__(5) #: 0.2
print b.__lshift__(1) #: 10
print b.__rshift__(1) #: 2
print b.__truediv__(5.15) #: 0.970874
print a.__add__(1) #: 1
print a.__add__(1.1) #: 1.1
print a.__sub__(1) #: -1
print a.__sub__(1.1) #: -1.1
print b.__mul__(1) #: 5
print b.__mul__(1.1) #: 5.5
print b.__floordiv__(2) #: 2
print b.__floordiv__(1.1) #: 4
print b.__mod__(2) #: 1
print b.__mod__(1.1) #: 0.6
print a.__eq__(1) #: False
print a.__eq__(1.1) #: False
print a.__ne__(1) #: True
print a.__ne__(1.1) #: True
print a.__lt__(1) #: True
print a.__lt__(1.1) #: True
print a.__le__(1) #: True
print a.__le__(1.1) #: True
print a.__gt__(1) #: False
print a.__gt__(1.1) #: False
print a.__ge__(1) #: False
print a.__ge__(1.1) #: False

#%% uint,barebones
au = Int[123](15)
a = UInt[123]()
b = UInt[123](a)
a = UInt[123](15)
a = UInt[123](au)
print a.__copy__() #: 15
print a.__hash__() #: 15
print a.__bool__() #: True
print a.__pos__() #: 15
print a.__neg__() #: 10633823966279326983230456482242756593
print a.__invert__() #: 10633823966279326983230456482242756592
m = UInt[123](4)
print a.__add__(m), a.__sub__(m), a.__mul__(m), a.__floordiv__(m), a.__truediv__(m) #: 19 11 60 3 3.75
print a.__mod__(m), a.__lshift__(m), a.__rshift__(m) #: 3 240 0
print a.__eq__(m), a.__ne__(m), a.__lt__(m), a.__gt__(m), a.__le__(m), a.__ge__(m) #: False True False True False True
print a.__and__(m), a.__or__(m), a.__xor__(m) #: 4 15 11
print a, a.popcnt() #: 15 4
ac = Int[128](5)
bc = Int[32](5)
print ac, bc, int(ac), int(bc) #: 5 5 5 5

print int(Int[12](12)) #: 12
print int(Int[122](12)) #: 12
print int(Int[64](12)) #: 12
print int(UInt[12](12)) #: 12
print int(UInt[122](12)) #: 12
print int(UInt[64](12)) #: 12

print Int[32](212) #: 212
print Int[64](212) #: 212
print Int[66](212) #: 212
print UInt[32](112) #: 112
print UInt[64](112) #: 112
print UInt[66](112) #: 112


#%% float,barebones
z = float.__new__()
z = 5.5
print z.__repr__() #: 5.5
print z.__copy__() #: 5.5
print z.__bool__(), z.__pos__(), z.__neg__() #: True 5.5 -5.5
f = 1.3
print z.__floordiv__(f), z.__floordiv__(2) #: 4 2
print z.__truediv__(f), z.__truediv__(2) #: 4.23077 2.75
print z.__pow__(2.2), z.__pow__(2) #: 42.54 30.25
print z.__add__(2) #: 7.5
print z.__sub__(2) #: 3.5
print z.__mul__(2) #: 11
print z.__truediv__(2) #: 2.75
print z.__mod__(2) #: 1.5
print z.__eq__(2) #: False
print z.__ne__(2) #: True
print z.__lt__(2) #: False
print z.__gt__(2) #: True
print z.__le__(2) #: False
print z.__ge__(2) #: True

#%% bool,barebones
z = bool.__new__()
print z.__repr__() #: False
print z.__copy__() #: False
print z.__bool__(), z.__invert__() #: False True
print z.__eq__(True) #: False
print z.__ne__(True) #: True
print z.__lt__(True) #: True
print z.__gt__(True) #: False
print z.__le__(True) #: True
print z.__ge__(True) #: False
print z.__and__(True), z.__or__(True), z.__xor__(True) #: False True True

#%% byte,barebones
z = byte.__new__()
z = byte(65)
print z.__repr__() #: byte('A')
print z.__bool__() #: True
print z.__eq__(byte(5)) #: False
print z.__ne__(byte(5)) #: True
print z.__lt__(byte(5)) #: False
print z.__gt__(byte(5)) #: True
print z.__le__(byte(5)) #: False
print z.__ge__(byte(5)) #: True

#%% array,barebones
a = Array[float](5)
pa = Ptr[float](3)
z = Array[float](pa, 3)
z.__copy__()
print z.__len__() #: 3
print z.__bool__() #: True
z.__setitem__(0, 1.0)
z.__setitem__(1, 2.0)
z.__setitem__(2, 3.0)
print z.__getitem__(1) #: 2
print z.slice(0, 2).len #: 2

#%% optional,barebones
a = Optional[float]()
print bool(a) #: False
a = Optional[float](0.0)
print bool(a) #: False
a = Optional[float](5.5)
print a.__bool__(), a.__val__() #: True 5.5

#%% generator,barebones
def foo():
    yield 1
    yield 2
    yield 3
z = foo()
y = z.__iter__()
print str(y.__raw__())[:2] #: 0x
print y.__done__() #: False
print y.__promise__()[0] #: 0
y.__resume__()
print y.__repr__()[:16] #: &lt;generator at 0x
print y.next() #: 1
print y.done() #: False
y.send(1)
y.destroy()
print y.done() #: True
</t>
<t tx="ekr.20230509083244.82">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% none,barebones
@extend
class Optional:
    def __repr__(self):
        return 'OPTIONAL: ' + ('-' if self is None else self.__val__().__repr__())
    def __str__(self):
        return 'OPTIONAL: ' + ('-' if self is None else self.__val__().__repr__())

a = None
print a #: OPTIONAL: -
if True:
    a = 5
print a #: OPTIONAL: 5

#%% bool,barebones
print True, False #: True False

#%% int,barebones
print 0b0000_1111 #: 15
print 0B101 #: 5
print 3 #: 3
print 18_446_744_073_709_551_000 #: -616
print 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111 #: -1
print 0b11111111_11111111_11111111_11111111_11111111_11111111_11111111_11111111u #: 18446744073709551615
print 18_446_744_073_709_551_000u #: 18446744073709551000
print 65i7 #: -63
print -1u7 #: 127

@extend
class int:
    def __suffix_test__(s):
        return 'TEST: ' + str(s)
print 123_456test #: TEST: 123456

#%% int_error,barebones
print 1844674407_3709551999 #! integer '18446744073709551999' cannot fit into 64-bit integer

#%% float,barebones
print 5.15 #: 5.15
print 2e2 #: 200
print 2.e-2 #: 0.02

#%% float_suffix,barebones
@extend
class float:
    def __suffix_zoo__(x):
        return str(x) + '_zoo'

print 1.2e-1zoo #: 0.12_zoo

#%% string,barebones
print 'kthxbai', "kthxbai" #: kthxbai kthxbai
print """hi
hello""", '''hai
hallo'''
#: hi
#: hello hai
#: hallo

#%% fstring,barebones
a, b = 1, 2
print f"string {a}" #: string 1
print F"{b} string" #: 2 string
print f"str {a+b} end" #: str 3 end
print f"str {a+b=}" #: str a+b=3
c = f'and this is {a} followed by {b}'
print c, f'{b}{a}', f'. {1+a=} .. {b} ...' #: and this is 1 followed by 2 21 . 1+a=2 .. 2 ...

#%% fstring_error,barebones
f"a{b + 3}}" #! single '}' is not allowed in f-string

#%% fstring_error_2,barebones
f"a{{b + 3}" #! expecting '}' in f-string

#%% prefix_str,barebones
@extend
class str:
    def __prefix_pfx__[N: Static[int]](s: str):
        return 'PFX ' + s
print pfx'HELLO' #: PFX HELLO

@extend
class str:
    def __prefix_pxf__(s: str, N: Static[int]):
        return 'PXF ' + s + " " + str(N)
print pxf'HELLO' #: PXF HELLO 5

#%% raw_str,barebones
print 'a\\b' #: a\b
print r'a\tb' #: a\tb
print R'\n\r\t\\' #: \n\r\t\\

#%% id_fstring_error,barebones
f"a{b + 3}" #! name 'b' is not defined

#%% id_access,barebones
def foo():
    a = 5
    def bar():
        print a
    bar()  #: 5
    a = 4
    bar()  #: 5
foo()

z = {}
def fox():
    a = 5
    def goo():
        z['x'] = 'y'
        print a
    return goo
fox()()
print z
#: 5
#: {'x': 'y'}


#%% star_err,barebones
a = (1, 2, 3)
z = *a #! unexpected star expression

#%% list,barebones
a = [4, 5, 6]
print a #: [4, 5, 6]
b = [1, 2, 3, *a]
print b #: [1, 2, 3, 4, 5, 6]

#%% set,barebones
gs = {1.12}
print gs #: {1.12}
fs = {1, 2, 3, 1, 2, 3}
gs.add(1.12)
gs.add(1.13)
print fs, gs #: {1, 2, 3} {1.12, 1.13}
print {*fs, 5, *fs} #: {1, 2, 3, 5}

#%% dict,barebones
gd = {1: 'jedan', 2: 'dva', 2: 'two', 3: 'tri'}
fd = {}
fd['jedan'] = 1
fd['dva'] = 2
print gd, fd #: {1: 'jedan', 2: 'two', 3: 'tri'} {'jedan': 1, 'dva': 2}

#%% comprehension,barebones
l = [(i, j, f'i{i}/{j}')
     for i in range(50) if i % 2 == 0 if i % 3 == 0
     for j in range(2) if j == 1]
print l #: [(0, 1, 'i0/1'), (6, 1, 'i6/1'), (12, 1, 'i12/1'), (18, 1, 'i18/1'), (24, 1, 'i24/1'), (30, 1, 'i30/1'), (36, 1, 'i36/1'), (42, 1, 'i42/1'), (48, 1, 'i48/1')]

s = {i%3 for i in range(20)}
print s #: {0, 1, 2}

d = {i: j for i in range(10) if i &lt; 1 for j in range(10)}
print d  #: {0: 9}

x = {t: lambda x: x * t for t in range(5)}
print(x[3](10))  #: 30

#%% comprehension_opt,barebones
@extend
class List:
    def __init__(self, cap: int):
        print 'optimize', cap
        self.arr = Array[T](cap)
        self.len = 0
def foo():
    yield 0
    yield 1
    yield 2
print [i for i in range(3)] #: optimize 3
#: [0, 1, 2]
print [i for i in foo()] #: [0, 1, 2]
print [i for i in range(3) if i%2 == 0] #: [0, 2]
print [i + j for i in range(1) for j in range(1)] #: [0]
print {i for i in range(3)} #: {0, 1, 2}

#%% generator,barebones
z = 3
g = (e for e in range(20) if e % z == 1)
print str(g)[:13] #: &lt;generator at
print list(g) #: [1, 4, 7, 10, 13, 16, 19]

g1 = (a for a in range(3))
print list(g1) #: [0, 1, 2]
g2 = (a for a in range(z + 1))
print list(g2) #: [0, 1, 2, 3]

def nest(z):
    g1 = (a for a in range(3))
    print list(g1) #: [0, 1, 2]
    g2 = (a for a in range(z + 1))
    print list(g2) #: [0, 1, 2, 3, 4]
nest(4)

#%% cond,barebones
a = 5
print (1 &lt;= a &lt;= 10), (1 &gt;= a &gt;= -5) #: True False

#%% if,barebones
c = 5
a = 1 if c &lt; 5 else 2
b = -(1 if c else 2)
print a, b #: 2 -1

#%% unary,barebones
a, b = False, 1
print not a, not b, ~b, +b, -b, -(+(-b)) #: True False -2 1 -1 1

#%% binary,barebones
x, y = 1, 0
c = [1, 2, 3]

print x and y, x or y #: False True
print x in c, x not in c #: True False
print c is c, c is not c #: True False

z: Optional[int] = None
print z is None, None is z, None is not z, None is None #: True True False True

#%% chain_binary,barebones
def foo():
    print 'foo'
    return 15
a = b = c = foo() #: foo
print a, b, c #: 15 15 15

x = y = []
x.append(1)
print x, y #: [1] [1]

print 1 &lt;= foo() &lt;= 10 #: foo
#: False
print 15 &gt;= foo()+1 &lt; 30 &gt; 20 &gt; foo()
#: foo
#: False
print 15 &gt;= foo()-1 &lt; 30 &gt; 20 &gt; foo()
#: foo
#: foo
#: True

print True == (b == 15) #: True

#%% pipe_error,barebones
def b(a, b, c, d):
    pass
1 |&gt; b(1, ..., 2, ...)  #! multiple ellipsis expressions

#%% index_normal,barebones
t: tuple[int, int] = (1, 2)
print t #: (1, 2)

tt: Tuple[int] = (1, )
print tt #: (1)

def foo(i: int) -&gt; int:
    return i + 1
f: Callable[[int], int] = foo
print f(1) #: 2
fx: function[[int], int] = foo
print fx(2) #: 3
fxx: Function[[int], int] = foo
print fxx(3) #: 4

#%% index_special,barebones
class Foo:
    def __getitem__(self, foo):
        print foo
f = Foo()
f[0,0] #: (0, 0)
f[0,:] #: (0, slice(None, None, None))
f[:,:] #: (slice(None, None, None), slice(None, None, None))
f[:,0] #: (slice(None, None, None), 0)

#%% index_error,barebones
Ptr[9.99] #! expected type expression

#%% index_error_b,barebones
Ptr['s'] #! ''s'' does not match expected type 'T'

#%% index_error_static,barebones
Ptr[1] #! '1' does not match expected type 'T'

#%% index_error_2,barebones
Ptr[int, 's'] #! Ptr takes 1 generics (2 given)

#%% index_error_3,barebones
Ptr[1, 's'] #! Ptr takes 1 generics (2 given)

#%% call_ptr,barebones
v = 5
p = __ptr__(v)
print p[0] #: 5

#%% call_ptr_error,barebones
__ptr__(1) #! __ptr__() only takes identifiers as arguments

#%% call_ptr_error_3,barebones
v = 1
__ptr__(v, 1) #! __ptr__() takes 1 arguments (2 given)

#%% call_array,barebones
a = __array__[int](2)
a[0] = a[1] = 5
print a[0], a[1] #: 5 5

#%% call_array_error,barebones
a = __array__[int](2, 3) #! '__array__[int]' object has no method '__new__' with arguments (int, int)

#%% call_err_1,barebones
seq_print(1, name="56", 2) #! positional argument follows keyword argument

#%% call_err_2,barebones
x = (1, 2)
seq_print(1, name=*x) #! syntax error, unexpected '*'

#%% call_err_3,barebones
x = (1, 2)
seq_print(1, name=**x) #! syntax error, unexpected '*'

#%% call_collections
from collections import namedtuple as nt

ee = nt('Foo', ['x', 'y'])
f = ee(1, 2)
print f #: (x: 1, y: 2)

ee = nt('FooX', [('x', str), 'y'])
fd = ee('s', 2)
print fd #: (x: 's', y: 2)

#%% call_partial_functools
from functools import partial
def foo(x, y, z):
    print x,y,z
f1 = partial(foo, 1, z=3)
f1(2) #: 1 2 3
f2 = partial(foo, y=2)
f2(1, 2) #: 1 2 2

#%% ellipsis_err,barebones
... #! unexpected ellipsis expression

#%% lambda,barebones
l = lambda a, b: a + b
print l(1, 2) #: 3

e = 5
lp = lambda x: x + e
print lp(1) #: 6

e = 7
print lp(2) #: 9

def foo[T](a: T, l: Callable[[T], T]):
    return l(a)
print foo(4, lp) #: 11

def foox(a, l):
    return l(a)
print foox(4, lp) #: 11

#%% nested_lambda,barebones
def foo():
    print list(a*a for a in range(3))
foo()  #: [0, 1, 4]

#%% walrus,barebones
def foo(x):
    return x * x
if x := foo(4):
    pass
if (x := foo(4)) and False:
    print 'Nope'
print x #: 16

a = [y := foo(1), y+1, y+2]
print a #: [1, 2, 3]

print {y: b for y in [1,2,3] if (b := (y - 1))} #: {2: 1, 3: 2}
print list(b for y in [1,2,3] if (b := (y // 3))) #: [1]

#%% walrus_update,barebones
def foo(x):
    return x * x
x = 5
if x := foo(4):
    pass
print x #: 16

#%% walrus_cond_1,barebones
def foo(x):
    return x * x
if False or (x := foo(4)):
    pass
print(x) #: 16

y = (z := foo(5)) if True else 0
print(z) #: 25

#%% walrus_err,barebones
def foo(x):
    return x * x
if False and (x := foo(4)):
    pass
try:
    print(x)
except NameError:
    print("Error") #: Error

t = True
y = 0 if t else (z := foo(4))
try:
    print(z)
except NameError:
    print("Error") #: Error

#%% range_err,barebones
1 ... 3 #! unexpected range expression

#%% callable_error,barebones
def foo(x: Callable[[]]): pass  #! Callable takes 2 generics (1 given)

#%% unpack_specials,barebones
x, = 1,
print x  #: 1

a = (2, 3)
b = (1, *a[1:])
print a, b  #: (2, 3) (1, 3)

#%% nonlocal,barebones
def goo(ww):
  z = 0
  def foo(x):
    f = 10
    def bar(y):
      nonlocal z
      f = x + y
      z += y
      print('goo.foo.bar', f, z)
    bar(5)
    print('goo.foo', f)
    return bar
  b = foo(10)
  print('goo', z)
  return b
b = goo('s')
# goo.foo.bar 15 5
# goo.foo 10
# goo 5
b(11)
# goo.foo.bar 21 16
b(12)
# goo.foo.bar 22 28
b = goo(1)  # test another instantiation
# goo.foo.bar 15 5
# goo.foo 10
# goo 5
b(11)
# goo.foo.bar 21 16
b(13)
# goo.foo.bar 23 29

#%% nonlocal_error,barebones
def goo():
  z = 0
  def foo():
    z += 1
goo()  #! local variable 'z' referenced before assignment

#%% new_scoping,barebones
try:
    if True and (x := (True or (y := 1 + 2))):
        pass
    try:
        print(x)  #: True
        print(y)
    except NameError:
        print("Error")  #: Error
    print(x) #: True
    if len("s") &gt; 0:
        print(x)  #: True
        print(y)
    print(y)  # TODO: test for __used__ usage
    print(y)  # (right now manual inspection is needed)
except NameError as e:
    print(e.message)  #: variable 'y' not yet defined

t = True
y = 0 if t else (xx := 1)
try:
    print(xx)
except NameError:
    print("Error")  #: Error

#%% new_scoping_weird,barebones
def foo():
    if len("s") == 3:
        x = 3
    def bar(y):
        print(x+y)
    x=5
    return bar
try:
    f = foo()
    f(5)
except NameError:
    print('error') #: error
    # TODO: Python works here.
    # Need to capture these vars conditionally?

#%% new_scoping_loops_try,barebones
for i in range(10):
    pass
print(i) #: 9

j = 6
for j in range(0):
    pass
print(j) #: 6

for j in range(1):
    pass
print(j) #: 0

z = 6
for z in []:
    pass
print(z) #: 6

for z in [1, 2]:
    pass
print(z) #: 2

try:
    raise ValueError("hi")
except ValueError as e:
    pass
print(e.message) #: hi

try:
    pass
except ValueError as f:
    pass
try:
    print(f.message)
except NameError:
    print('error') #: error
</t>
<t tx="ekr.20230509083244.83">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% pass,barebones
pass

#%% continue_error,barebones
continue #! 'continue' outside loop

#%% break_error,barebones
break #! 'break' outside loop

#%% assign,barebones
a = 1
print a #: 1
a = 2
print a #: 2

x, y = 1, 2
print x, y #: 1 2
(x, y) = (3, 4)
print x, y #: 3 4
x, y = (1, 2)
print x, y #: 1 2
(x, y) = 3, 4
print x, y #: 3 4
(x, y) = [3, 4]
print x, y #: 3 4
[x, y] = [1, 2]
print x, y #: 1 2
[x, y] = (4, 3)
print x, y #: 4 3

l = list(iter(range(10)))
[a, b, *lx, c, d] = l
print a, b, lx, c, d #: 0 1 [2, 3, 4, 5, 6, 7] 8 9
a, b, *lx = l
print a, b, lx #: 0 1 [2, 3, 4, 5, 6, 7, 8, 9]
*lx, a, b = l
print lx, a, b #: [0, 1, 2, 3, 4, 5, 6, 7] 8 9
*xz, a, b = (1, 2, 3, 4, 5)
print xz, a, b #: (1, 2, 3) 4 5
(*ex,) = [1, 2, 3]
print ex #: [1, 2, 3]

#%% assign_str,barebones
sa, sb = 'XY'
print sa, sb #: X Y
(sa, sb), sc = 'XY', 'Z'
print sa, sb, sc #: X Y Z
sa, *la = 'X'
print sa, la, 1 #: X  1
sa, *la = 'XYZ'
print sa, la #: X YZ
(xa,xb), *xc, xd = [1,2],'this'
print xa, xb, xc, xd #: 1 2 () this
(a, b), (sc, *sl) = [1,2], 'this'
print a, b, sc, sl #: 1 2 t his

#%% assign_index_dot,barebones
class Foo:
    a: int
    def __setitem__(self, i: int, t: int):
        self.a += i * t
f = Foo()
f.a = 5
print f.a #: 5
f[3] = 5
print f.a #: 20
f[1] = -8
print f.a #: 12

#%% assign_err_1,barebones
a, *b, c, *d = 1,2,3,4,5 #! multiple starred expressions in assignment

#%% assign_err_2,barebones
a = [1, 2, 3]
a[1]: int = 3 #! syntax error, unexpected ':'

#%% assign_err_3,barebones
a = 5
a.x: int = 3 #! syntax error, unexpected ':'

#%% assign_err_4,barebones
*x = range(5) #! cannot assign to given expression

#%% assign_err_5,barebones
try:
    (sa, sb), sc = 'XYZ'
except IndexError:
    print "assign failed" #: assign failed

#%% assign_comprehension,barebones
g = ((b, a, c) for a, *b, c in ['ABC','DEEEEF','FHGIJ'])
x, *q, y = list(g) # TODO: auto-unroll as in Python
print x, y, q #: ('B', 'A', 'C') ('HGI', 'F', 'J') [('EEEE', 'D', 'F')]

#%% assign_shadow,barebones
a = 5
print a #: 5
a : str = 's'
print a #: s

#%% assign_err_must_exist,barebones
a = 1
def foo():
    a += 2 #! local variable 'a' referenced before assignment

#%% assign_rename,barebones
y = int
z = y(5)
print z #: 5

def foo(x): return x + 1
x = foo
print x(1) #: 2

#%% assign_err_6,barebones
x = bar #! name 'bar' is not defined

#%% assign_err_7,barebones
foo() += bar #! cannot assign to given expression

#%% assign_update_eq,barebones
a = 5
a += 3
print a #: 8
a -= 1
print a #: 7

class Foo:
    a: int
    def __add__(self, i: int):
        print 'add!'
        return Foo(self.a + i)
    def __iadd__(self, i: int):
        print 'iadd!'
        self.a += i
        return self
    def __str__(self):
        return str(self.a)
f = Foo(3)
print f + 2 #: add!
#: 5
f += 6 #: iadd!
print f #: 9

#%% del,barebones
a = 5
del a
print a #! name 'a' is not defined

#%% del_index,barebones
y = [1, 2]
del y[0]
print y #: [2]

#%% del_error,barebones
a = [1]
del a.ptr #! cannot delete given expression

#%% assert,barebones
assert True
assert True, "blah"

try:
    assert False
except AssertionError as e:
    print e.message[:15], e.message[-24:] #: Assert failed ( simplify_stmt.codon:164)

try:
    assert False, f"hehe {1}"
except AssertionError as e:
    print e.message[:23], e.message[-24:] #: Assert failed: hehe 1 ( simplify_stmt.codon:169)

#%% print,barebones
print 1,
print 1, 2  #: 1 1 2

print 1, 2  #: 1 2
print(3, "4", sep="-", end=" !\n") #: 3-4 !

print(1, 2) #: 1 2
print (1, 2) #: (1, 2)

def foo(i, j):
    return i + j
print 3 |&gt; foo(1)  #: 4

#%% return_fail,barebones
return #! 'return' outside function

#%% yield_fail,barebones
yield 5 #! 'yield' outside function

#%% yield_fail_2,barebones
(yield) #! 'yield' outside function

#%% while_else,barebones
a = 1
while a:
    print a #: 1
    a -= 1
else:
    print 'else' #: else
a = 1
while a:
    print a #: 1
    a -= 1
else not break:
    print 'else' #: else
while True:
    print 'infinite' #: infinite
    break
else:
    print 'nope'

#%% for_assignment,barebones
l = [[1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11]]
for a, *m, b in l:
    print a + b, len(m)
#: 5 2
#: 14 3
#: 21 0

#%% for_else,barebones
for i in [1]:
    print i #: 1
else:
    print 'else' #: else
for i in [1]:
    print i #: 1
else not break:
    print 'else' #: else
for i in [1]:
    print i #: 1
    break
else:
    print 'nope'

best = 4
for s in [3, 4, 5]:
    for i in [s]:
        if s &gt;= best:
            print('b:', best)
            break
    else:
        print('s:', s)
        best = s
#: s: 3
#: b: 3
#: b: 3

#%% match
def foo(x):
    match x:
        case 1:
            print 'int'
        case 2 ... 10:
            print 'range'
        case 'ACGT':
            print 'string'
        case (a, 1):
            print 'tuple_wild', a
        case []:
            print 'list'
        case [[]]:
            print 'list list'
        case [1, 2]:
            print 'list 2'
        case [1, z, ...] if z &lt; 5:
            print 'list 3', z
        case [1, _, ..., zz] | (1, zz):
            print 'list 4', zz
        case (1 ... 10, s := ('ACGT', 1 ... 4)):
            print 'complex', s
        case _:
            print 'else'
foo(1) #: int
foo(5) #: range
foo('ACGT') #: string
foo((9, 1)) #: tuple_wild 9
foo(List[int]()) #: list
foo([List[int]()]) #: list list
foo([1, 2]) #: list 2
foo([1, 3]) #: list 3 3
foo([1, 5]) #: else
foo([1, 5, 10]) #: list 4 10
foo((1, 33)) #: list 4 33
foo((9, ('ACGT', 3))) #: complex ('ACGT', 3)
foo(range(10)) #: else

#%% match_err_1,barebones
match [1, 2]:
    case [1, ..., 2, ..., 3]: pass
#! multiple ellipses in a pattern

#%% match_err_2,barebones
match [1, 2]:
    case 1 | ...: pass
#! unexpected ellipsis expression

#%% global,barebones
a = 1
def foo():
    global a
    a += 1
print a,
foo()
print a  #: 1 2

#%% global_err,barebones
a = 1
global a #! 'global' outside function

#%% global_err_2,barebones
def foo():
    global b #! name 'b' is not defined

#%% global_err_3,barebones
def foo():
    b = 1
    def bar():
        global b #! no binding for global 'b' found

#%% global_err_4,barebones
a = 1
def foo():
    a += 1
foo()  #! local variable 'a' referenced before assignment

#%% global_ref,barebones
a = [1]
def foo():
    a.append(2)
foo()
print a #: [1, 2]

#%% yield_from,barebones
def foo():
    yield from range(3)
    yield from range(10, 13)
    yield -1
print list(foo())  #: [0, 1, 2, 10, 11, 12, -1]

#%% with,barebones
class Foo:
    i: int
    def __enter__(self: Foo):
        print '&gt; foo! ' + str(self.i)
    def __exit__(self: Foo):
        print '&lt; foo! ' + str(self.i)
    def foo(self: Foo):
        print 'woof'
class Bar:
    s: str
    def __enter__(self: Bar):
        print '&gt; bar! ' + self.s
    def __exit__(self: Bar):
        print '&lt; bar! ' + self.s
    def bar(self: Bar):
        print 'meow'
with Foo(0) as f:
#: &gt; foo! 0
    f.foo()  #: woof
#: &lt; foo! 0
with Foo(1) as f, Bar('s') as b:
#: &gt; foo! 1
#: &gt; bar! s
    f.foo()  #: woof
    b.bar()  #: meow
#: &lt; bar! s
#: &lt; foo! 1
with Foo(2), Bar('t') as q:
#: &gt; foo! 2
#: &gt; bar! t
    print 'eeh'  #: eeh
    q.bar()  #: meow
#: &lt; bar! t
#: &lt; foo! 2

#%% import_c,barebones
from C import sqrt(float) -&gt; float
print sqrt(4.0) #: 2

from C import puts(cobj)
puts("hello".ptr) #: hello

from C import atoi(cobj) -&gt; int as s2i
print s2i("11".ptr) #: 11

@C
def log(x: float) -&gt; float:
    pass
print log(5.5)  #: 1.70475

from C import seq_flags: Int[32] as e
# debug | standalone == 5
print e  #: 5

#%% import_c_shadow_error,barebones
# Issue #45
from C import sqrt(float) -&gt; float as foo
sqrt(100.0)  #! name 'sqrt' is not defined


#%% import_c_dylib,barebones
from internal.dlopen import dlext
RT = "./libcodonrt." + dlext()
if RT[-3:] == ".so":
    RT = "build/" + RT[2:]
from C import RT.seq_str_int(int, str, Ptr[bool]) -&gt; str as sp
p = False
print sp(65, "", __ptr__(p))  #: 65

#%% import_c_dylib_error,barebones
from C import "".seq_print(str) as sp
sp("hi!") #! syntax error, unexpected '"'

#%% import,barebones
zoo, _zoo = 1, 1
print zoo, _zoo, __name__  #: 1 1 __main__

import a  #: a
a.foo() #: a.foo

from a import foo, bar as b
foo() #: a.foo
b() #: a.bar

print str(a)[:9], str(a)[-18:] #: &lt;module ' a/__init__.codon'&gt;

import a.b
print a.b.c #: a.b.c
a.b.har() #: a.b.har a.b.__init__ a.b.c

print a.b.A.B.b_foo().__add__(1) #: a.b.A.B.b_foo()
#: 2

print str(a.b)[:9], str(a.b)[-20:] #: &lt;module ' a/b/__init__.codon'&gt;
print Int[a.b.stt].__class__.__name__  #: Int[5]

from a.b import *
har() #: a.b.har a.b.__init__ a.b.c
a.b.har() #: a.b.har a.b.__init__ a.b.c
fx() #: a.foo
print(stt, Int[stt].__class__.__name__)  #: 5 Int[5]

from a import *
print zoo, _zoo, __name__  #: 5 1 __main__

f = Foo(Ptr[B]())
print f.__class__.__name__, f.t.__class__.__name__  #: Foo Ptr[B]

a.ha()  #: B

print par  #: x

#%% import_order,barebones
def foo():
    import a
    a.foo()
def bar():
    import a
    a.bar()

bar() #: a
#: a.bar
foo() #: a.foo

#%% import_class
import sys
print str(sys)[:20]  #: &lt;module 'sys' from '
print sys.maxsize  #: 9223372036854775807

#%% import_rec,barebones
from a.b.rec1 import bar
#: import rec1
#: import rec2
#: done rec2
#: rec2.x
#: done rec1
bar()
#: rec1.bar

#%% import_rec_err,barebones
from a.b.rec1_err import bar
#! cannot import name 'bar' from 'a.b.rec1_err'
#! name 'bar' is not defined
# TODO: get rid of this!
#! no module named 'rec2_err'

#%% import_err_1,barebones
class Foo:
    import bar #! unexpected expression in class definition

#%% import_err_2,barebones
import "".a.b.c #! syntax error, unexpected '"'

#%% import_err_3,barebones
from a.b import foo() #! function signatures only allowed when importing C or Python functions

#%% import_err_4,barebones
from a.b.c import hai.hey #! expected identifier

#%% import_err_4_x,barebones
import whatever #! no module named 'whatever'

#%% import_err_5,barebones
import a.b
print a.b.x #! cannot import name 'x' from 'a.b.__init__'

#%% import_err_6,barebones
from a.b import whatever #! cannot import name 'whatever' from 'a.b.__init__'

#%% function_err_0,barebones
def foo(a, b, a):
    pass #! duplicate argument 'a' in function definition

#%% function_err_0b,barebones
def foo(a, b=1, c):
    pass #! non-default argument 'c' follows default argument

#%% function_err_0b_ok,barebones
def foo(a, b=1, *c):
    pass

#%% function_err_0c,barebones
def foo(a, b=1, *c, *d):
    pass #! multiple star arguments provided

#%% function_err_0e,barebones
def foo(a, b=1, *c = 1):
    pass #! star arguments cannot have default values

#%% function_err_0f,barebones
def foo(a, b=1, **c, **kwargs):
    pass #! kwargs must be the last argument

#%% function_err_0h,barebones
def foo(a, b=1, **c = 1):
    pass #! star arguments cannot have default values

#%% function_err_0i,barebones
def foo(a, **c, d):
    pass #! kwargs must be the last argument

#%% function_err_1,barebones
def foo():
    @__force__
    def bar(): pass #! builtin function must be a top-level statement

#%% function_err_2,barebones
def f[T: Static[float]]():
    pass
#! expected 'int' or 'str' (only integers and strings can be static)

#%% function_err_3,barebones
def f(a, b=a):
    pass
#! name 'a' is not defined

#%% function_llvm_err_1,barebones
@llvm
def foo():
    blah
#! return types required for LLVM and C functions

#%% function_llvm_err_2,barebones
@llvm
def foo() -&gt; int:
    a{={=}}
#! invalid LLVM code

#%% function_llvm_err_4,barebones
a = 5
@llvm
def foo() -&gt; int:
    a{=a
#! invalid LLVM code

#%% function_self,barebones
class Foo:
    def foo(self):
        return 'F'
f = Foo()
print f.foo() #: F

#%% function_self_err,barebones
class Foo:
    def foo(self):
        return 'F'
Foo.foo(1) #! 'Foo' object has no method 'foo' with arguments (int)

#%% function_nested,barebones
def foo(v):
    value = v
    def bar():
        return value
    return bar
baz = foo(2)
print baz() #: 2

def f(x):
    a=1
    def g(y):
        return a+y
    return g(x)
print f(5) #: 6

#%% nested_generic_static,barebones
def foo():
    N: Static[int] = 5
    Z: Static[int] = 15
    T = Int[Z]
    def bar():
        x = __array__[T](N)
        print(x.__class__.__name__)
    return bar
foo()()  #: Array[Int[15]]

def f[T]():
    def g():
        return T()
    return g()
print f(int) #: 0

#%% class_err_1,barebones
@extend
@foo
class Foo:
    pass
#! cannot combine '@extend' with other attributes or decorators

#%% class_err_1b,barebones
size_t = i32
@extend
class size_t:
    pass
#! class name 'size_t' is not defined

#%% class_err_2,barebones
def foo():
    @extend
    class Foo:
        pass
#! class extension must be a top-level statement

#%% class_nested,barebones
class Foo:
    foo: int
    class Bar:
        bar: int
        b: Optional[Foo.Bar]
        c: Optional[int]
        class Moo:
            # TODO: allow nested class reference to the upclass
            # x: Foo.Bar
            x: int
y = Foo(1)
z = Foo.Bar(2, None, 4)
m = Foo.Bar.Moo(5)
print y.foo #: 1
print z.bar, z.b.__bool__(), z.c, m.x  #: 2 False 4 5

#%% class_nested_2,barebones
@tuple
class Foo:
    @tuple
    class Bar:
        x: int
    x: int
    b: Bar
    c: Foo.Bar
f = Foo(5, Foo.Bar(6), Foo.Bar(7))
print(f) #: (x: 5, b: (x: 6), c: (x: 7))

#%% class_nested_err,barebones
class Foo:
    class Bar:
        b: Ptr[Bar]
#! name 'Bar' is not defined

#%% class_err_4,barebones
@extend
class Foo:
    pass
#! class name 'Foo' is not defined

#%% class_err_5,barebones
class Foo[T, U]:
    pass
@extend
class Foo[T]:
    pass
#! class extensions cannot define data attributes and generics or inherit other classes

#%% class_err_7,barebones
class Foo:
    a: int
    a: int
#! duplicate data attribute 'a' in class definition

#%% class_err_tuple_no_recursive,barebones
@tuple
class Foo:
    a: Foo
#! name 'Foo' is not defined

#%% class_err_8,barebones
class Foo:
    while True: pass
#! unexpected expression in class definition

#%% class_err_9,barebones
class F[T: Static[float]]:
    pass
#! expected 'int' or 'str' (only integers and strings can be static)

#%% class_err_10,barebones
def foo[T]():
    class A:
        x: T
#! name 'T' cannot be captured

#%% class_err_11,barebones
def foo(x):
    class A:
        def bar():
            print x
#! name 'x' cannot be captured

#%% class_err_12,barebones
def foo(x):
    T = type(x)
    class A:
        def bar():
            print T()
#! name 'T' cannot be captured

#%% recursive_class,barebones
class Node[T]:
    data: T
    children: List[Node[T]]
    def __init__(self, data: T):
        self.data = data
        self.children = []
print Node(2).data #: 2

class Node2:
    data: int
    children: List[Node2]
    def __init__(self, data: int):
        self.data = data
        self.children = []
print Node2(3).data #: 3

#%% class_auto_init,barebones
class X[T]:
    a: int = 4
    b: int
    c: T
    d: str = 'oops'
    def __str__(self):
        return f'X({self.a},{self.b},{self.c},{self.d})'
x = X[float]()
print x #: X(4,0,0,oops)
y = X(c='darius',a=5)
print y #: X(5,0,darius,oops)

#%% magic,barebones
@tuple
class Foo:
    x: int
    y: int
a, b = Foo(1, 2), Foo(1, 3)
print a, b #: (x: 1, y: 2) (x: 1, y: 3)
print a.__len__() #: 2
print a.__hash__(), b.__hash__() #: 175247769363 175247769360
print a == a, a == b #: True False
print a != a, a != b #: False True
print a &lt; a, a &lt; b, b &lt; a #: False True False
print a &lt;= a, a &lt;= b, b &lt;= a #: True True False
print a &gt; a, a &gt; b, b &gt; a #: False False True
print a &gt;= a, a &gt;= b, b &gt;= a #: True False True
print a.__getitem__(1)  #: 2
print list(a.__iter__()) #: [1, 2]

#%% magic_class,barebones
@dataclass(eq=True, order=True)
class Foo:
    x: int
    y: int
    def __str__(self): return f'{self.x}_{self.y}'
a, b = Foo(1, 2), Foo(1, 3)
print a, b #: 1_2 1_3
print a == a, a == b #: True False
print a != a, a != b #: False True
print a &lt; a, a &lt; b, b &lt; a #: False True False
print a &lt;= a, a &lt;= b, b &lt;= a #: True True False
print a &gt; a, a &gt; b, b &gt; a #: False False True
print a &gt;= a, a &gt;= b, b &gt;= a #: True False True

# Right magic test
class X:
    x: int
class Y:
    y: int
    def __eq__(self, o: X): return self.y == o.x
    def __ne__(self, o: X): return self.y != o.x
    def __le__(self, o: X): return self.y &lt;= o.x
    def __lt__(self, o: X): return self.y &lt;  o.x
    def __ge__(self, o: X): return self.y &gt;= o.x
    def __gt__(self, o: X): return self.y &gt;  o.x
    def __add__(self, o: X):  return self.y + o.x + 1
    def __radd__(self, o: X): return self.y + o.x + 2
print Y(1) == X(1), Y(1) != X(1)  #: True False
print X(1) == Y(1), X(1) != Y(1)  #: True False
print Y(1) &lt;= X(2), Y(1) &lt; X(2)  #: True True
print X(1) &lt;= Y(2), X(1) &lt; Y(2)  #: True True
print Y(1) &gt;= X(2), Y(1) &gt; X(2)  #: False False
print X(1) &gt;= Y(2), X(1) &gt; Y(2)  #: False False
print X(1) + Y(2)  #: 5
print Y(1) + X(2)  #: 4


class A:
    def __radd__(self, n: int):
        return 0
def f():
    print('f')
    return 1
def g():
    print('g')
    return A()
f() + g()
#: f
#: g

#%% magic_2,barebones
@tuple
class Foo:
    pass
a, b = Foo(), Foo()
print a, b #: () ()
print a.__len__() #: 0
print a.__hash__(), b.__hash__() #: 0 0
print a == a, a == b #: True True
print a != a, a != b #: False False
print a &lt; a, a &lt; b, b &lt; a #: False False False
print a &lt;= a, a &lt;= b, b &lt;= a #: True True True
print a &gt; a, a &gt; b, b &gt; a #: False False False
print a &gt;= a, a &gt;= b, b &gt;= a #: True True True

# TODO: pickle / to_py / from_py

#%% magic_contains,barebones
sponge = (1, 'z', 1.55, 'q', 48556)
print 1.1 in sponge #: False
print 'q' in sponge #: True
print True in sponge #: False

bob = (1, 2, 3)
print 1.1 in sponge #: False
print 1 in sponge #: True
print 0 in sponge #: False

#%% magic_err_2,barebones
@tuple
class Foo:
    pass
try:
    print Foo().__getitem__(1)
except IndexError:
    print 'error'  #: error

#%% magic_empty_tuple,barebones
@tuple
class Foo:
    pass
print list(Foo().__iter__())  #: []

#%% magic_err_4,barebones
@tuple(eq=False)
class Foo:
    x: int
Foo(1).__eq__(Foo(1)) #! 'Foo' object has no attribute '__eq__'

#%% magic_err_5,barebones
@tuple(pickle=False)
class Foo:
    x: int
p = Ptr[byte]()
Foo(1).__pickle__(p) #! 'Foo' object has no attribute '__pickle__'

#%% magic_err_6,barebones
@tuple(container=False)
class Foo:
    x: int
Foo(1).__getitem__(0) #! 'Foo' object has no attribute '__getitem__'

#%% magic_err_7,barebones
@tuple(python=False)
class Foo:
    x: int
p = Ptr[byte]()
Foo(1).__to_py__(p) #! 'Foo' object has no attribute '__to_py__'

#%% python
from python import os
print os.name  #: posix

from python import datetime
z = datetime.datetime.utcfromtimestamp(0)
print z  #: 1970-01-01 00:00:00

#%% python_numpy
from python import numpy as np
a = np.arange(9).reshape(3, 3)
print a
#: [[0 1 2]
#:  [3 4 5]
#:  [6 7 8]]
print a.dtype.name  #: int64
print np.transpose(a)
#: [[0 3 6]
#:  [1 4 7]
#:  [2 5 8]]
n = np.array([[1, 2], [3, 4]])
print n[0], n[0][0] + 1 #: [1 2] 2

a = np.array([1,2,3])
print(a + 1) #: [2 3 4]
print(a - 1) #: [0 1 2]
print(1 - a) #: [ 0 -1 -2]

#%% python_import_fn
from python import re.split(str, str) -&gt; List[str] as rs
print rs(r'\W+', 'Words, words, words.')  #: ['Words', 'words', 'words', '']

#%% python_import_fn_2
from python import os.system(str) -&gt; int
system("echo 'hello!'")  #: hello!

#%% python_pydef
@python
def test_pydef(n) -&gt; str:
    return ''.join(map(str,range(n)))
print test_pydef(5)  #: 01234

#%% python_pydef_nested
def foo():
    @python
    def pyfoo():
        return 1
    print pyfoo() #: 1
    if True:
        @python
        def pyfoo2():
            return 2
        print pyfoo2() #: 2
    pass
    @python
    def pyfoo3():
        if 1:
            return 3
    return str(pyfoo3())
print foo() #: 3

#%% python_pyobj
@python
def foofn() -&gt; Dict[pyobj, pyobj]:
    return {"str": "hai", "int": 1}

foo = foofn()
print(sorted(foo.items(), key=lambda x: str(x)), foo.__class__.__name__)
#: [('int', 1), ('str', 'hai')] Dict[pyobj,pyobj]
foo["codon"] = 5.15
print(sorted(foo.items(), key=lambda x: str(x)), foo["codon"].__class__.__name__, foo.__class__.__name__)
#: [('codon', 5.15), ('int', 1), ('str', 'hai')] pyobj Dict[pyobj,pyobj]

a = {1: "s", 2: "t"}
a[3] = foo["str"]
print(sorted(a.items()))  #: [(1, 's'), (2, 't'), (3, 'hai')]


#%% python_isinstance
import python

@python
def foo():
    return 1

z = foo()
print(z.__class__.__name__)  #: pyobj

print isinstance(z, pyobj)  #: True
print isinstance(z, int)  #: False
print isinstance(z, python.int)  #: True
print isinstance(z, python.ValueError)  #: False

print isinstance(z, (int, str, python.int))  #: True
print isinstance(z, (int, str, python.AttributeError))  #: False

try:
    foo().x
except python.ValueError:
    pass
except python.AttributeError as e:
    print('caught', e, e.__class__.__name__) #: caught 'int' object has no attribute 'x' pyobj


#%% python_exceptions
import python

@python
def foo():
    return 1

try:
    foo().x
except python.AttributeError as f:
    print 'py.Att', f  #: py.Att 'int' object has no attribute 'x'
except ValueError:
    print 'Val'
except PyError as e:
    print 'PyError', e
try:
    foo().x
except python.ValueError as f:
    print 'py.Att', f
except ValueError:
    print 'Val'
except PyError as e:
    print 'PyError', e  #: PyError 'int' object has no attribute 'x'
try:
    raise ValueError("ho")
except python.ValueError as f:
    print 'py.Att', f
except ValueError:
    print 'Val'  #: Val
except PyError as e:
    print 'PyError', e


#%% typeof_definition_error,barebones
a = 1
class X:
    b: type(a) #! cannot use type() in type signatures

#%% typeof_definition_error_2,barebones
def foo(a)-&gt;type(a): pass #! cannot use type() in type signatures

#%% typeof_definition_error_3,barebones
a=1
b: type(a) = 1 #! cannot use type() in type signatures

#%% assign_underscore,barebones
_ = 5
_ = 's'

#%% inherit_class_4,barebones
class defdict[K,V](Static[Dict[K,V]]):
    fx: Function[[],V]
    def __init__(self, d: Dict[K,V], fx: Function[[], V]):
        self.__init__()
        for k,v in d.items(): self[k] = v
        self.fx = fx
    def __getitem__(self, key: K) -&gt; V:
        if key in self:
            return self.values[self.keys.index(key)]
        else:
            self[key] = self.fx()
            return self[key]
z = defdict({'ha':1}, lambda: -1)
print z
print z['he']
print z
#: {'ha': 1}
#: -1
#: {'ha': 1, 'he': -1}

class Foo:
    x: int
    def foo(self):
        return f'foo {self.x}'
class Bar[T]:
    y: T
    def bar(self):
        return f'bar {self.y}/{self.y.__class__.__name__}'
class FooBarBaz[T](Static[Foo], Static[Bar[T]]):
    def baz(self):
        return f'baz! {self.foo()} {self.bar()}'
print FooBarBaz[str]().foo() #: foo 0
print FooBarBaz[float]().bar() #: bar 0/float
print FooBarBaz[str]().baz() #: baz! foo 0 bar /str

#%% inherit_class_err_5,barebones
class defdict(Static[Dict[str,float]]):
    def __init__(self, d: Dict[str, float]):
        self.__init__(d.items())
z = defdict()
z[1.1] #! 'defdict' object has no method '__getitem__' with arguments (defdict, float)

#%% inherit_tuple,barebones
class Foo:
    a: int
    b: str
    def __init__(self, a: int):
        self.a, self.b = a, 'yoo'
@tuple
class FooTup(Static[Foo]): pass

f = Foo(5)
print f.a, f.b #: 5 yoo
fp = FooTup(6, 's')
print fp #: (a: 6, b: 's')

#%% inherit_class_err_1,barebones
class defdict(Static[Array[int]]):
    pass #! reference classes cannot inherit tuple classes

#%% inherit_class_err_2,barebones
@tuple
class defdict(Static[int]):
    pass #! internal classes cannot inherit other classes

#%% inherit_class_err_3,barebones
class defdict(Static[Dict[int, float, float]]):
    pass #! Dict takes 2 generics (3 given)

#%% inherit_class_err_4,barebones
class Foo:
    x: int
class Bar:
    x: float
class FooBar(Static[Foo], Static[Bar]):
    pass #! duplicate data attribute 'x' in class definition

#%% keyword_prefix,barebones
def foo(return_, pass_, yield_, break_, continue_, print_, assert_):
    return_.append(1)
    pass_.append(2)
    yield_.append(3)
    break_.append(4)
    continue_.append(5)
    print_.append(6)
    assert_.append(7)
    return return_, pass_, yield_, break_, continue_, print_, assert_
print foo([1], [1], [1], [1], [1], [1], [1])
#: ([1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7])


#%% class_deduce,barebones
@deduce
class Foo:
    def __init__(self, x):
        self.x = [x]
        self.y = 1, x

f = Foo(1)
print(f.x, f.y, f.__class__.__name__) #: [1] (1, 1) Foo[List[int],Tuple[int,int]]

f: Foo = Foo('s')
print(f.x, f.y, f.__class__.__name__) #: ['s'] (1, 's') Foo[List[str],Tuple[int,str]]

@deduce
class Bar:
    def __init__(self, y):
        self.y = Foo(y)

b = Bar(3.1)
print(b.y.x, b.__class__.__name__) #: [3.1] Bar[Foo[List[float],Tuple[int,float]]]

#%% multi_error,barebones
a = 55
print z  #! name 'z' is not defined
print(a, q, w)  #! name 'q' is not defined
print quit  #! name 'quit' is not defined

#%% class_var,barebones
class Foo:
    cx = 15
    x: int = 10
    cy: ClassVar[str] = "ho"
    class Bar:
        bx = 1.1
print(Foo.cx)  #: 15
f = Foo()
print(Foo.cy, f.cy)  #: ho ho
print(Foo.Bar.bx)  #: 1.1

Foo.cx = 10
print(Foo.cx)  #: 10

def x():
    class Foo:
        i = 0
        f = Foo()
        def __init__(self):
            Foo.i += 1
        def __repr__(self):
            return 'heh-cls'
    Foo(), Foo(), Foo()
    print Foo.f, Foo.i  #: heh-cls 4
    return Foo()
f = x()
print f.f, f.i  #: heh-cls 5

@tuple
class Fot:
    f = Fot()
    def __repr__(self):
        return 'heh-tup'
print Fot.f  #: heh-tup


#%% dot_access_error,barebones
class Foo:
    x: int = 1
Foo.x #! 'Foo' object has no attribute 'x'

#%% scoping_same_name,barebones
def match(pattern: str, string: str, flags: int = 0):
    pass

def match(match):
    if True:
        match = 0
    match

match(1)

#%% loop_domination,barebones
for i in range(2):
    try: dat = 1
    except: pass
    print(dat)
#: 1
#: 1

def comprehension_test(x):
    for n in range(3):
        print('&gt;', n)
    l = ['1', '2', str(x)]
    x = [n for n in l]
    print(x, n)
comprehension_test(5)
#: &gt; 0
#: &gt; 1
#: &gt; 2
#: ['1', '2', '5'] 2


#%% block_unroll,barebones
# Ensure that block unrolling is done in RAII manner on error
def foo():
    while True:
        def magic(a: x):
            return
        print b
foo()
#! name 'x' is not defined
#! name 'b' is not defined

#%% capture_recursive,barebones
def f(x: int) -&gt; int:
    z = 2 * x
    def g(y: int) -&gt; int:
        if y == 0:
            return 1
        else:
            return g(y - 1) * z
    return g(4)
print(f(3))  #: 1296
</t>
<t tx="ekr.20230509083244.84">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% bool,barebones
a = True
print a.__class__.__name__ #: bool

#%% int,barebones
i = 15
print i.__class__.__name__ #: int

#%% float,barebones
a = 1.11
print a.__class__.__name__ #: float

#%% str,barebones
a = 'hi'
print a.__class__.__name__ #: str

#%% none_unbound,barebones
a = None

#%% list_unbound,barebones
a = []
#! cannot typecheck the program


#%% id_static,barebones
def foo[N: Static[int]]():
    print N
foo(5) #: 5

def fox(N: Static[int]):
    print N
fox(6) #: 6

#%% if,barebones
y = 1 if True else 2
print y.__class__.__name__ #: int

a = None
b = 5
z = a if bool(True) else b # needs bool to prevent static evaluation
print z, z.__class__.__name__ #: None Optional[int]

zz = 1.11 if True else None
print zz, zz.__class__.__name__ #: 1.11 float

#%% binary,barebones
@extend
class float:
    def __add__(self, i: int): print 'add'; return 0
    def __sub__(self, i: int): print 'sub'; return 0
    def __mul__(self, i: int): print 'mul'; return 0
    def __pow__(self, i: int): print 'pow'; return 0
    def __truediv__(self, i: int): print 'truediv'; return 0
    def __floordiv__(self, i: int): print 'div'; return 0
    def __matmul__(self, i: int): print 'matmul'; return 0
    def __mod__(self, i: int): print 'mod'; return 0
    def __lt__(self, i: int): print 'lt'; return 0
    def __le__(self, i: int): print 'le'; return 0
    def __gt__(self, i: int): print 'gt'; return 0
    def __ge__(self, i: int): print 'ge'; return 0
    def __eq__(self, i: int): print 'eq'; return 0
    def __ne__(self, i: int): print 'ne'; return 0
    def __lshift__(self, i: int): print 'lshift'; return 0
    def __rshift__(self, i: int): print 'rshift'; return 0
    def __and__(self, i: int): print 'and'; return 0
    def __or__(self, i: int): print 'or'; return 0
    def __xor__(self, i: int): print 'xor'; return 0
# double assignment to disable propagation
def f(x): return x
a = f(1.0)
a = f(5.0)
a + f(1) #: add
# wrap in function to disable canonicalization
a - f(1) #: sub
a * f(2) #: mul
a ** f(2) #: pow
a // f(2) #: div
a / f(2) #: truediv
a @ f(1) #: matmul
a % f(1) #: mod
a &lt; f(1) #: lt
a &lt;= f(1) #: le
a &gt; f(1) #: gt
a &gt;= f(1) #: ge
a == f(1) #: eq
a != f(1) #: ne
a &lt;&lt; f(1) #: lshift
a &gt;&gt; f(1) #: rshift
a &amp; f(1) #: and
a | f(1) #: or
a ^ f(1) #: xor

#%% binary_rmagic,barebones
class Foo[T]:
    def __add__(self, other: T):
        print 'add'
        return self
    def __radd__(self, other: T):
        print 'radd'
        return self
foo = Foo[int]()
foo + 1 #: add
1 + foo #: radd

#%% binary_short_circuit,barebones
def moo():
    print 'moo'
    return True
print True or moo() #: True
print moo() or True #: moo
#: True
print False and moo() #: False
print moo() and False #: moo
#: False

#%% binary_is,barebones
print 5 is None #: False
print None is None #: True
print (None if bool(True) else 1) is None #: True
print (None if bool(False) else 1) is None #: False

print 5 is 5.0 #: False
print 5 is 6 #: False
print 5 is 5 #: True
print 5 is 1.12 #: False
class Foo:
    a: int
x = Foo(1)
y = Foo(1)
z = x
print x is x, x is y, x is z, z is x, z is y #: True False True True False

a, b, c, d = Optional(5), Optional[int](), Optional(5), Optional(4)
print a is a, a is b, b is b, a is c, a is d #: True False True True False
aa, bb, cc, dd = Optional(Foo(1)), Optional[Foo](), Optional(Foo(1)), Optional(Foo(2))
print aa is aa, aa is bb, bb is bb, aa is cc, aa is dd #: True False True False False


#%% pipe,barebones
def foo(a, b):
    return a+b
bar = lambda c, d: c+d
def hai(e):
    while e &gt; 0:
        yield e
        e -= 2
def echo(s):
    print s
foo(1,2) |&gt; bar(4) |&gt; echo  #: 7
foo(1,2) |&gt; bar(4) |&gt; hai |&gt; echo
#: 7
#: 5
#: 3
#: 1

#%% pipe_prepend,barebones
def foo(a: Optional[int]):
    print a
    return 1
5 |&gt; foo #: 5
None |&gt; foo #: None
print (None |&gt; foo).__class__.__name__ #: int

def foo2(a: int):
    print a
    return 1
Optional(5) |&gt; foo2 #: 5
try:
    Optional[int]() |&gt; foo2
except ValueError as e:
    print e.message #: optional is None

#%% pipe_prepend_error,barebones
def foo2(a: int):
    print a
    return 1
try:
    None |&gt; foo2
except ValueError:
    print 'exception' #: exception
# Explanation: None can also be Optional[Generator[int]]
# We cannot decide if this is a generator to be unrolled in a pipe,
# or just an argument to be passed to a function.
# So this will default to NoneType at the end.

#%% instantiate_err,barebones
def foo[N]():
    return N()
foo(int, float)  #! foo() takes 1 arguments (2 given)

#%% instantiate_err_2,barebones
def foo[N, T]():
    return N()
foo(int)  #! generic 'T' not provided

#%% instantiate_err_3,barebones
Ptr[int, float]()  #! Ptr takes 1 generics (2 given)

#%% slice,barebones
z = [1, 2, 3, 4, 5]
y = (1, 'foo', True)
print z[2], y[1]  #: 3 foo
print z[:1], z[1:], z[1:3], z[:4:2], z[::-1]  #: [1] [2, 3, 4, 5] [2, 3] [1, 3] [5, 4, 3, 2, 1]

#%% static_index,barebones
a = (1, '2s', 3.3)
print a[1] #: 2s
print a[0:2], a[:2], a[1:] #: (1, '2s') (1, '2s') ('2s', 3.3)
print a[0:3:2], a[-1:] #: (1, 3.3) (3.3)

#%% static_index_side,barebones
def foo(a):
    print(a)
    return a

print (foo(2), foo(1))[::-1]
#: 2
#: 1
#: (1, 2)
print (foo(1), foo(2), foo(3), foo(4))[2]
#: 1
#: 2
#: 3
#: 4
#: 3

#%% static_index_lenient,barebones
a = (1, 2)
print a[3:5] #: ()

#%% static_index_err,barebones
a = (1, 2)
a[5] #! tuple index out of range (expected 0..1, got instead 5)

#%% static_index_err_2,barebones
a = (1, 2)
a[-3] #! tuple index out of range (expected 0..1, got instead -1)

#%% index_func_instantiate,barebones
class X:
    def foo[T](self, x: T):
        print x.__class__.__name__, x
x = X()
x.foo(5, int) #: int 5

#%% index,barebones
l = [1, 2, 3]
print l[2] #: 3

#%% index_two_rounds,barebones
l = []
print l[::-1] #: []
l.append(('str', 1, True, 5.15))
print l, l.__class__.__name__ #: [('str', 1, True, 5.15)] List[Tuple[str,int,bool,float]]

#%% dot_case_1,barebones
a = []
print a[0].loop()  #! 'int' object has no attribute 'loop'
a.append(5)

#%% dot_case_2,barebones
a = Optional(0)
print a.__bool__() #: False
print a.__add__(1) #: 1

#%% dot_case_4,barebones
a = [5]
print a.len #: 1

#%% dot_case_4_err,barebones
a = [5]
a.foo #! 'List[int]' object has no attribute 'foo'

#%% dot_case_6,barebones
# Did heavy changes to this testcase because
# of the automatic optional wraps/unwraps and promotions
class Foo:
    def bar(self, a):
        print 'generic', a, a.__class__.__name__
    def bar(self, a: Optional[float]):
        print 'optional', a
    def bar(self, a: int):
        print 'normal', a
f = Foo()
f.bar(1) #: normal 1
f.bar(1.1) #: optional 1.1
f.bar(Optional('s')) #: generic s Optional[str]
f.bar('hehe') #: generic hehe str


#%% dot_case_6b,barebones
class Foo:
    def bar(self, a, b):
        print '1', a, b
    def bar(self, a, b: str):
        print '2', a, b
    def bar(self, a: str, b):
        print '3', a, b
f = Foo()
# Take the newest highest scoring method
f.bar('s', 't') #: 3 s t
f.bar(1, 't') #: 2 1 t
f.bar('s', 1) #: 3 s 1
f.bar(1, 2) #: 1 1 2

#%% dot,barebones
class Foo:
    def clsmethod():
        print 'foo'
    def method(self, a):
        print a
Foo.clsmethod() #: foo
Foo.method(Foo(), 1) #: 1
m1 = Foo.method
m1(Foo(), 's') #: s
m2 = Foo().method
m2(1.1) #: 1.1

#%% dot_error_static,barebones
class Foo:
    def clsmethod():
        print 'foo'
    def method(self, a):
        print a
Foo().clsmethod() #! 'Foo' object has no method 'clsmethod' with arguments (Foo)

#%% call,barebones
def foo(a, b, c='hi'):
    print 'foo', a, b, c
    return 1
class Foo:
    def __init__(self):
        print 'Foo.__init__'
    def foo(self, a):
        print 'Foo.foo', a
        return 's'
    def bar[T](self, a: T):
        print 'Foo.bar', a
        return a.__class__.__name__
    def __call__(self, y):
        print 'Foo.__call__'
        return foo(2, y)

foo(1, 2.2, True) #: foo 1 2.2 True
foo(1, 2.2) #: foo 1 2.2 hi
foo(b=2.2, a=1) #: foo 1 2.2 hi
foo(b=2.2, c=12u, a=1) #: foo 1 2.2 12

f = Foo() #: Foo.__init__
print f.foo(a=5) #: Foo.foo 5
#: s
print f.bar(a=1, T=int) #: Foo.bar 1
#: int
print Foo.bar(Foo(), 1.1, T=float) #: Foo.__init__
#: Foo.bar 1.1
#: float
print Foo.bar(Foo(), 's') #: Foo.__init__
#: Foo.bar s
#: str
print f('hahaha') #: Foo.__call__
#: foo 2 hahaha hi
#: 1

@tuple
class Moo:
    moo: int
    def __new__(i: int) -&gt; Moo:
        print 'Moo.__new__'
        return (i,)
print Moo(1) #: Moo.__new__
#: (moo: 1)

#%% call_err_2,barebones
class A:
    a: A
a = A() #! argument 'a' has recursive default value

#%% call_err_3,barebones
class G[T]:
    t: T
class A:
    ga: G[A]
a = A() #! argument 'ga' has recursive default value

#%% call_err_4,barebones
seq_print_full(1, name="56", name=2) #! keyword argument repeated: name

#%% call_partial,barebones
def foo(i, j, k):
    return i + j + k
print foo(1.1, 2.2, 3.3)  #: 6.6
p = foo(6, ...)
print p.__class__.__name__ #: foo[int,...,...]
print p(2, 1)  #: 9
print p(k=3, j=6) #: 15
q = p(k=1, ...)
print q(3)  #: 10
qq = q(2, ...)
print qq()  #: 9
#
add_two = foo(3, k=-1, ...)
print add_two(42)  #: 44
print 3 |&gt; foo(1, 2)  #: 6
print 42 |&gt; add_two  #: 44
#
def moo(a, b, c=3):
    print a, b, c
m = moo(b=2, ...)
print m.__class__.__name__ #: moo[...,int,...]
m('s', 1.1) #: s 2 1.1
# #
n = m(c=2.2, ...)
print n.__class__.__name__ #: moo[...,int,float]
n('x') #: x 2 2.2
print n('y').__class__.__name__ #: NoneType

def ff(a, b, c):
    return a, b, c
print ff(1.1, 2, True).__class__.__name__ #: Tuple[float,int,bool]
print ff(1.1, ...)(2, True).__class__.__name__ #: Tuple[float,int,bool]
y = ff(1.1, ...)(c=True, ...)
print y.__class__.__name__ #: ff[float,...,bool]
print ff(1.1, ...)(2, ...)(True).__class__.__name__ #: Tuple[float,int,bool]
print y('hei').__class__.__name__ #: Tuple[float,str,bool]
z = ff(1.1, ...)(c='s', ...)
print z.__class__.__name__ #: ff[float,...,str]

def fx(*args, **kw):
    print(args, kw)
f1 = fx(1, x=1, ...)
f2 = f1(2, y=2, ...)
f3 = f2(3, z=3, ...)
f3()
#: (1, 2, 3) (x: 1, y: 2, z: 3)

#%% call_arguments_partial,barebones
def doo[R, T](a: Callable[[T], R], b: Generator[T], c: Optional[T], d: T):
    print R.__class__.__name__, T.__class__.__name__
    print a.__class__.__name__[:8], b.__class__.__name__
    for i in b:
        print a(i)
    print c, c.__class__.__name__
    print d, d.__class__.__name__

l = [1, 2, 3]
doo(b=l, d=Optional(5), c=l[0], a=lambda x: x+1)
#: int int
#: ._lambda Generator[int]
#: 2
#: 3
#: 4
#: 1 Optional[int]
#: 5 int

l = [1]
def adder(a, b): return a+b
doo(b=l, d=Optional(5), c=l[0], a=adder(b=4, ...))
#: int int
#: adder[.. Generator[int]
#: 5
#: 1 Optional[int]
#: 5 int

#%% call_partial_star,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
p = foo(...)
p(1, z=5) #: 1 () (z: 5)
p('s', zh=65) #: s () (zh: 65)
q = p(zh=43, ...)
q(1) #: 1 () (zh: 43)
r = q(5, 38, ...)
r() #: 5 (38) (zh: 43)
r(1, a=1) #: 5 (38, 1) (zh: 43, a: 1)

#%% call_args_kwargs_type,barebones
def foo(*args: float, **kwargs: int):
    print(args, kwargs, args.__class__.__name__)

foo(1, f=1)  #: (1) (f: 1) Tuple[float]
foo(1, 2.1, 3, z=2)  #: (1, 2.1, 3) (z: 2) Tuple[float,float,float]

def sum(x: Generator[int]):
    a = 0
    for i in x:
        a += i
    return a

def sum_gens(*x: Generator[int]) -&gt; int:
    a = 0
    for i in x:
        a += sum(i)
    return a
print sum_gens([1, 2, 3])  #: 6
print sum_gens({1, 2, 3})  #: 6
print sum_gens(iter([1, 2, 3]))  #: 6

#%% call_kwargs,barebones
def kwhatever(**kwargs):
    print 'k', kwargs
def whatever(*args):
    print 'a', args
def foo(a, b, c=1, *args, **kwargs):
    print a, b, c, args, kwargs
    whatever(a, b, *args, c)
    kwhatever(x=1, **kwargs)
foo(1, 2, 3, 4, 5, arg1='s', kwa=2)
#: 1 2 3 (4, 5) (arg1: 's', kwa: 2)
#: a (1, 2, 4, 5, 3)
#: k (arg1: 's', kwa: 2, x: 1)
foo(1, 2)
#: 1 2 1 () ()
#: a (1, 2, 1)
#: k (x: 1)
foo(1, 2, 3)
#: 1 2 3 () ()
#: a (1, 2, 3)
#: k (x: 1)
foo(1, 2, 3, 4)
#: 1 2 3 (4) ()
#: a (1, 2, 4, 3)
#: k (x: 1)
foo(1, 2, zamboni=3)
#: 1 2 1 () (zamboni: 3)
#: a (1, 2, 1)
#: k (x: 1, zamboni: 3)

#%% call_unpack,barebones
def foo(*args, **kwargs):
    print args, kwargs

@tuple
class Foo:
    x: int = 5
    y: bool = True

t = (1, 's')
f = Foo(6)
foo(*t, **f) #: (1, 's') (x: 6, y: True)
foo(*(1,2)) #: (1, 2) ()
foo(3, f) #: (3, (x: 6, y: True)) ()
foo(k = 3, **f) #: () (k: 3, x: 6, y: True)

#%% call_partial_args_kwargs,barebones
def foo(*args):
    print(args)
a = foo(1, 2, ...)
b = a(3, 4, ...)
c = b(5, ...)
c('zooooo')
#: (1, 2, 3, 4, 5, 'zooooo')

def fox(*args, **kwargs):
    print(args, kwargs)
xa = fox(1, 2, x=5, ...)
xb = xa(3, 4, q=6, ...)
xc = xb(5, ...)
xd = xc(z=5.1, ...)
xd('zooooo', w='lele')
#: (1, 2, 3, 4, 5, 'zooooo') (x: 5, q: 6, z: 5.1, w: 'lele')

class Foo:
    i: int
    def __str__(self):
        return f'#{self.i}'
    def foo(self, a):
        return f'{self}:generic'
    def foo(self, a: float):
        return f'{self}:float'
    def foo(self, a: int):
        return f'{self}:int'
f = Foo(4)

def pacman(x, f):
    print f(x, '5')
    print f(x, 2.1)
    print f(x, 4)
pacman(f, Foo.foo)
#: #4:generic
#: #4:float
#: #4:int

def macman(f):
    print f('5')
    print f(2.1)
    print f(4)
macman(f.foo)
#: #4:generic
#: #4:float
#: #4:int

class Fox:
    i: int
    def __str__(self):
        return f'#{self.i}'
    def foo(self, a, b):
        return f'{self}:generic b={b}'
    def foo(self, a: float, c):
        return f'{self}:float, c={c}'
    def foo(self, a: int):
        return f'{self}:int'
    def foo(self, a: int, z, q):
        return f'{self}:int z={z} q={q}'
ff = Fox(5)
def maxman(f):
    print f('5', b=1)
    print f(2.1, 3)
    print f(4)
    print f(5, 1, q=3)
maxman(ff.foo)
#: #5:generic b=1
#: #5:float, c=3
#: #5:int
#: #5:int z=1 q=3


#%% call_static,barebones
print isinstance(1, int), isinstance(2.2, float), isinstance(3, bool)
#: True True False
print isinstance((1, 2), Tuple), isinstance((1, 2), Tuple[int, int]), isinstance((1, 2), Tuple[float, int])
#: True True False
print isinstance([1, 2], List), isinstance([1, 2], List[int]), isinstance([1, 2], List[float])
#: True True False
print isinstance({1, 2}, List), isinstance({1, 2}, Set[float])
#: False False
print isinstance(Optional(5), Optional[int]), isinstance(Optional(), Optional)
#: True True
print isinstance(Optional(), Optional[int]), isinstance(Optional('s'), Optional[int])
#: False False
print isinstance(None, Optional), isinstance(None, Optional[int])
#: True False
print isinstance(None, Optional[NoneType])
#: True
print isinstance({1, 2}, List)
#: False

print staticlen((1, 2, 3)), staticlen((1, )), staticlen('hehe')
#: 3 1 2

print hasattr([1, 2], "__getitem__")
#: True
print hasattr(type([1, 2]), "__getitem__")
#: True
print hasattr(int, "__getitem__")
#: False
print hasattr([1, 2], "__getitem__", str)
#: False

#%% isinstance_inheritance,barebones
class AX[T]:
    a: T
    def __init__(self, a: T):
        self.a = a
class Side:
    def __init__(self):
        pass
class BX[T,U](Static[AX[T]], Static[Side]):
    b: U
    def __init__(self, a: T, b: U):
        super().__init__(a)
        self.b = b
class CX[T,U](Static[BX[T,U]]):
    c: int
    def __init__(self, a: T, b: U):
        super().__init__(a, b)
        self.c = 1
c = CX('a', False)
print isinstance(c, CX), isinstance(c, BX), isinstance(c, AX), isinstance(c, Side)
#: True True True True
print isinstance(c, BX[str, bool]), isinstance(c, BX[str, str]), isinstance(c, AX[int])
#: True False False

#%% staticlen_err,barebones
print staticlen([1, 2]) #! expected tuple type

#%% compile_error,barebones
compile_error("woo-hoo") #! woo-hoo

#%% stack_alloc,barebones
a = __array__[int](2)
print a.__class__.__name__ #: Array[int]

#%% typeof,barebones
a = 5
z = []
z.append(6)
print z.__class__.__name__, z, type(1.1).__class__.__name__  #: List[int] [6] float

#%% ptr,barebones
v = 5
c = __ptr__(v)
print c.__class__.__name__ #: Ptr[int]

#%% yieldexpr,barebones
def mysum(start):
    m = start
    while True:
        a = (yield)
        print a.__class__.__name__ #: int
        if a == -1:
            break
        m += a
    yield m
iadder = mysum(0)
next(iadder)
for i in range(10):
    iadder.send(i)
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
#: int
print iadder.send(-1)  #: 45

#%% function_typecheck_level,barebones
def foo(x):
    def bar(z):  # bar has a parent foo(), however its unbounds must not be generalized!
        print z
    bar(x)
    bar('x')
foo(1)
#: 1
#: x
foo('s')
#: s
#: x

#%% tuple_generator,barebones
a = (1, 2)
b = ('f', 'g')
print a, b #: (1, 2) ('f', 'g')
c = (*a, True, *b)
print c #: (1, 2, True, 'f', 'g')
print a + b + c #: (1, 2, 'f', 'g', 1, 2, True, 'f', 'g')
print () + (1, ) + ('a', 'b') #: (1, 'a', 'b')

t = tuple(i+1 for i in (1,2,3))
print t #: (2, 3, 4)
print tuple((j, i) for i, j in ((1, 'a'), (2, 'b'), (3, 'c')))
#: (('a', 1), ('b', 2), ('c', 3))

#%% tuple_fn,barebones
@tuple
class unpackable_plain:
  a: int
  b: str

u = unpackable_plain(1, 'str')
a, b = tuple(u)
print a, b #: 1 str

@tuple
class unpackable_gen:
  a: int
  b: T
  T: type

u2 = unpackable_gen(1, 'str')
a2, b2 = tuple(u2)
print a2,b2  #: 1 str

class plain:
  a: int
  b: str

c = plain(3, 'heh')
z = tuple(c)
print z, z.__class__.__name__  #: (3, 'heh') Tuple[int,str]

#%% static_unify,barebones
def foo(x: Callable[[1,2], 3]): pass  #! '1' does not match expected type 'T1'

#%% static_unify_2,barebones
def foo(x: List[1]): pass  #! '1' does not match expected type 'T'

#%% super,barebones
class A[T]:
    a: T
    def __init__(self, t: T):
        self.a = t
    def foo(self):
        return f'A:{self.a}'
class B(Static[A[str]]):
    b: int
    def __init__(self):
        super().__init__('s')
        self.b = 6
    def baz(self):
        return f'{super().foo()}::{self.b}'
b = B()
print b.foo() #: A:s
print b.baz() #: A:s::6

class AX[T]:
    a: T
    def __init__(self, a: T):
        self.a = a
    def foo(self):
        return f'[AX:{self.a}]'
class BX[T,U](Static[AX[T]]):
    b: U
    def __init__(self, a: T, b: U):
        print super().__class__.__name__
        super().__init__(a)
        self.b = b
    def foo(self):
        return f'[BX:{super().foo()}:{self.b}]'
class CX[T,U](Static[BX[T,U]]):
    c: int
    def __init__(self, a: T, b: U):
        print super().__class__.__name__
        super().__init__(a, b)
        self.c = 1
    def foo(self):
        return f'CX:{super().foo()}:{self.c}'
c = CX('a', False)
print c.__class__.__name__, c.foo()
#: BX[str,bool]
#: AX[str]
#: CX[str,bool] CX:[BX:[AX:a]:False]:1

#%% super_vtable_2
class Base:
    def test(self):
        print('base.test')
class A(Base):
    def test(self):
        super().test()
        Base.test(self)
        print('a.test')
a = A()
a.test()
def moo(x: Base):
    x.test()
moo(a)
Base.test(a)
#: base.test
#: base.test
#: a.test
#: base.test
#: base.test
#: a.test
#: base.test

#%% super_tuple,barebones
@tuple
class A[T]:
    a: T
    x: int
    def __new__(a: T) -&gt; A[T]:
        return (a, 1)
    def foo(self):
        return f'A:{self.a}'
@tuple
class B(Static[A[str]]):
    b: int
    def __new__() -&gt; B:
        return (*(A('s')), 6)
    def baz(self):
        return f'{super().foo()}::{self.b}'

b = B()
print b.foo() #: A:s
print b.baz() #: A:s::6


#%% super_error,barebones
class A:
    def __init__(self):
        super().__init__()
a = A()
#! no super methods found
#! during the realization of __init__(self: A)

#%% super_error_2,barebones
super().foo(1) #! no super methods found
</t>
<t tx="ekr.20230509083244.85">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% expr,barebones
a = 5; b = 3
print a, b  #: 5 3

#%% assign_optional,barebones
a = None
print a  #: None
a = 5
print a  #: 5

b: Optional[float] = Optional[float](6.5)
c: Optional[float] = 5.5
print b, c #: 6.5 5.5

#%% assign_type_alias,barebones
I = int
print I(5) #: 5

L = Dict[int, str]
l = L()
print l #: {}
l[5] = 'haha'
print l #: {5: 'haha'}

#%% assign_type_annotation,barebones
a: List[int] = []
print a  #: []

#%% assign_type_err,barebones
a = 5
if 1:
    a = 3.3  #! 'float' does not match expected type 'int'
a

#%% assign_atomic,barebones
i = 1
f = 1.1

@llvm
def xchg(d: Ptr[int], b: int) -&gt; None:
    %tmp = atomicrmw xchg i64* %d, i64 %b seq_cst
    ret {} {}
@llvm
def aadd(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw add i64* %d, i64 %b seq_cst
    ret i64 %tmp
@llvm
def amin(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw min i64* %d, i64 %b seq_cst
    ret i64 %tmp
@llvm
def amax(d: Ptr[int], b: int) -&gt; int:
    %tmp = atomicrmw max i64* %d, i64 %b seq_cst
    ret i64 %tmp
def min(a, b): return a if a &lt; b else b
def max(a, b): return a if a &gt; b else b

@extend
class int:
    def __atomic_xchg__(self: Ptr[int], i: int):
        print 'atomic:', self[0], '&lt;-', i
        xchg(self, i)
    def __atomic_add__(self: Ptr[int], i: int):
        print 'atomic:', self[0], '+=', i
        return aadd(self, i)
    def __atomic_min__(self: Ptr[int], b: int):
        print 'atomic:', self[0], '&lt;?=', b
        return amin(self, b)
    def __atomic_max__(self: Ptr[int], b: int):
        print 'atomic:', self[0], '&gt;?=', b
        return amax(self, b)

@atomic
def foo(x):
    global i, f

    i += 1 #: atomic: 1 += 1
    print i #: 2
    i //= 2 #: atomic: 2 &lt;- 1
    print i #: 1
    i = 3 #: atomic: 1 &lt;- 3
    print i #: 3
    i = min(i, 10) #: atomic: 3 &lt;?= 10
    print i #: 3
    i = max(i, 10) #: atomic: 3 &gt;?= 10
    print i #: 10
    i = max(20, i) #: atomic: 10 &lt;- 20
    print i #: 20

    f += 1.1
    f = 3.3
    f = max(f, 5.5)
foo(1)
print i, f #: 20 5.5

#%% assign_atomic_real
i = 1
f = 1.1
@atomic
def foo(x):
    global i, f

    i += 1
    print i #: 2
    i //= 2
    print i #: 1
    i = 3
    print i #: 3
    i = min(i, 10)
    print i #: 3
    i = max(i, 10)
    print i #: 10

    f += 1.1
    f = 3.3
    f = max(f, 5.5)
foo(1)
print i, f #: 10 5.5

#%% assign_member,barebones
class Foo:
    x: Optional[int]
f = Foo()
print f.x #: None
f.x = 5
print f.x #: 5

fo = Optional(Foo())
fo.x = 6
print fo.x #: 6

#%% assign_member_err_1,barebones
class Foo:
    x: Optional[int]
Foo().y = 5 #! 'Foo' object has no attribute 'y'

#%% assign_member_err_2,barebones
@tuple
class Foo:
    x: Optional[int]
Foo().x = 5 #! cannot modify tuple attributes

#%% return,barebones
def foo():
    return 1
print foo()  #: 1

def bar():
    print 2
    return
    print 1
bar()  #: 2

#%% yield,barebones
def foo():
    yield 1
print [i for i in foo()], str(foo())[:16]  #: [1] &lt;generator at 0x

#%% yield_void,barebones
def foo():
    yield
    print 1
y = foo()
print y.done()  #: False
y.next()  #: 1
# TODO: next() should work here!
print y.done()  #: True

#%% yield_return,barebones
def foo():
    yield 1
    return
    yield 2
print list(foo())  #: [1]

#%% while,barebones
a = 3
while a:
    print a
    a -= 1
#: 3
#: 2
#: 1

#%% for_break_continue,barebones
for i in range(10):
    if i % 2 == 0:
        continue
    print i
    if i &gt;= 5:
        break
#: 1
#: 3
#: 5

#%% for_error,barebones
for i in 1:
    pass
#! 'int' object has no attribute '__iter__'

#%% for_void,barebones
def foo(): yield
for i in foo():
    print i.__class__.__name__  #: NoneType

#%% if,barebones
for a, b in [(1, 2), (3, 3), (5, 4)]:
    if a &gt; b:
        print '1',
    elif a == b:
        print '=',
    else:
        print '2',
print '_'  #: 2 = 1 _

if 1:
    print '1' #: 1

#%% static_if,barebones
def foo(x, N: Static[int]):
    if isinstance(x, int):
        return x + 1
    elif isinstance(x, float):
        return x.__pow__(.5)
    elif isinstance(x, Tuple[int, str]):
        return f'foo: {x[1]}'
    elif isinstance(x, Tuple) and (N &gt;= 3 or staticlen(x) &gt; 2):
        return x[2:]
    elif hasattr(x, '__len__'):
        return 'len ' + str(x.__len__())
    else:
        compile_error('invalid type')
print foo(N=1, x=1) #: 2
print foo(N=1, x=2.0) #: 1.41421
print foo(N=1, x=(1, 'bar')) #: foo: bar
print foo(N=1, x=(1, 2)) #: len 2
print foo(N=3, x=(1, 2)) #: ()
print foo(N=1, x=(1, 2, 3)) #: (3)

#%% try_throw,barebones
class MyError(Static[Exception]):
    def __init__(self, message: str):
        super().__init__('MyError', message)
try:
    raise MyError("hello!")
except MyError as e:
    print str(e)  #: hello!
try:
    raise OSError("hello os!")
# TODO: except (MyError, OSError) as e:
#     print str(e)
except MyError:
    print "my"
except OSError as o:
    print "os", o.typename, len(o.message), o.file[-20:], o.line
    #: os OSError 9 typecheck_stmt.codon 249
finally:
    print "whoa"  #: whoa

# Test function name
def foo():
    raise MyError("foo!")
try:
    foo()
except MyError as e:
    print e.typename, e.message #: MyError foo!

#%% throw_error,barebones
raise 'hello'
#! exceptions must derive from BaseException

#%% function_builtin_error,barebones
@__force__
def foo(x):
    pass
#! builtin, exported and external functions cannot be generic

#%% extend,barebones
@extend
class int:
    def run_lola_run(self):
        while self &gt; 0:
            yield self
            self -= 1
print list((5).run_lola_run())  #: [5, 4, 3, 2, 1]


#%% early_return,barebones
def foo(x):
    print  x-1
    return
    print len(x)
foo(5) #: 4

def foo2(x):
    if isinstance(x, int):
        print  x+1
        return
    print len(x)
foo2(1) #: 2
foo2('s') #: 1

#%% superf,barebones
class Foo:
    def foo(a):
        # superf(a)
        print 'foo-1', a
    def foo(a: int):
        superf(a)
        print 'foo-2', a
    def foo(a: str):
        superf(a)
        print 'foo-3', a
    def foo(a):
        superf(a)
        print 'foo-4', a
Foo.foo(1)
#: foo-1 1
#: foo-2 1
#: foo-4 1

class Bear:
    def woof(x):
        return f'bear woof {x}'
@extend
class Bear:
    def woof(x):
        return superf(x) + f' bear w--f {x}'
print Bear.woof('!')
#: bear woof ! bear w--f !

class PolarBear(Static[Bear]):
    def woof():
        return 'polar ' + superf('@')
print PolarBear.woof()
#: polar bear woof @ bear w--f @

#%% superf_error,barebones
class Foo:
    def foo(a):
        superf(a)
        print 'foo-1', a
Foo.foo(1)
#! no superf methods found
#! during the realization of foo(a: int)

#%% staticmethod,barebones
class Foo:
    def __repr__(self):
        return 'Foo'
    def m(self):
        print 'm', self
    @staticmethod
    def sm(i):
        print 'sm', i
Foo.sm(1)  #: sm 1
Foo().sm(2)  #: sm 2
Foo().m()  #: m Foo
</t>
<t tx="ekr.20230509083244.86">@path C:/Repos/codon/test/parser/
@language unknown_language
#%% basic,barebones
a = 5
b: float = 6.16
c: optional[str] = None
print a, b, c  #: 5 6.16 None

#%% late_unify,barebones
a = []
a.append(1)
print a  #: [1]
print [1]+[1]  #: [1, 1]

#%% late_unify_2,barebones
class XX[T]:
    y: T
a = XX()
def f(i: int) -&gt; int:
    return i
print a.y.__class__.__name__ #: int
f(a.y)
print a.__class__.__name__ #: XX[int]
print XX[bool].__class__.__name__ #: XX[bool]

#%% nested_generic,barebones
x = Array[Array[int]](0)
f = Optional[Optional[Optional[int]]](Optional[Optional[int]](Optional[int](5)))
print x.len, f  #: 0 5

#%% map_unify
def map[T,S](l: List[T], f: Callable[[T], S]):
    return [f(x) for x in l]
e = 1
print map([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]

def map2(l, f):
    return [f(x) for x in l]
print map2([1, 2, 3], lambda x: x+e)  #: [2, 3, 4]

#%% nested,barebones
def m4[TD](a: int, d: TD):
    def m5[TD,TE](a: int, d: TD, e: TE):
        print a, d, e
    m5(a, d, 1.12)
m4(1, 's')  #: 1 s 1.12
m4(1, True)  #: 1 True 1.12

#%% nested_class,barebones
class A[TA]:
    a: TA
    # lots of nesting:
    def m4[TD](self: A[TA], d: TD):
        def m5[TA,TD,TE](a: TA, d: TD, e: TE):
            print a, d, e
        m5(self.a, d, d)
ax = A(42)
ax.m4(1)  #: 42 1 1

#%% static_fn,barebones
class A[TA]:
    a: TA
    def dump(a, b, c):
        print a, b, c
    def m2():
        A.dump(1, 2, 's')
    def __str__(self):
        return 'A'
A.dump(1, 2, 3)  #: 1 2 3
A[int].m2()  #: 1 2 s
A.m2()  #: 1 2 s
c = A[str]('s')
c.dump('y', 1.1)  #: A y 1.1

#%% static_fn_overload,barebones
def foo(x: Static[int]):
    print('int', x)

@overload
def foo(x: Static[str]):
    print('str', x)

foo(10)
#: int 10
foo('s')
#: str s

#%% realization_big
class A[TA,TB,TC]:
    a: TA
    b: TB
    c: TC

    def dump(a, b, c):
        print a, b, c

    # non-generic method:
    def m0(self: A[TA,TB,TC], a: int):
        print a

    # basic generics:
    def m1[X](self: A[TA,TB,TC], other: A[X,X,X]):
        print other.a, other.b, other.c

    # non-generic method referencing outer generics:
    def m2(a: TA, b: TB, c: TC):
        A.dump(a, b, c)

    # generic args:
    def m3(self, other):
        return self.a

    # lots of nesting:
    def m4[TD](self: A[TA,TB,TC], d: TD):
        def m5[TA,TB,TC,TD,TE](a: TA, b: TB, c: TC, d: TD, e: TE):
            print a, b, c, d, e
        m5(self.a, self.b, self.c, d, d)

    # instantiating the type:
    def m5(self):
        x = A(self.a, self.b, self.c)
        A.dump(x.a, x.b, x.c)

    # deeply nested generic type:
    def m6[T](v: array[array[array[T]]]):
        return v[0][0][0]
a1 = A(42, 3.14, "hello")
a2 = A(1, 2, 3)
a1.m1(a2)                           #: 1 2 3
A[int,float,str].m2(1, 1.0, "one")  #: 1 1 one
A[int,int,int].m2(11, 22, 33)       #: 11 22 33
print a1.m3(a2)                     #: 42
print a1.m3(a2)                     #: 42
print a2.m3(a1)                     #: 1
a1.m4(True)                         #: 42 3.14 hello True True
a1.m4([1])                          #: 42 3.14 hello [1] [1]
a2.m4("x")                          #: 1 2 3 x x
a1.m5()                             #: 42 3.14 hello
a2.m5()                             #: 1 2 3

v1 = array[array[array[str]]](1)
v2 = array[array[str]](1)
v3 = array[str](1)
v1[0] = v2
v2[0] = v3
v3[0] = "world"
print A.m6(v1)                      #: world

f = a2.m0
f(99)                               #: 99

#%% realization_small,barebones
class B1[T]:
    a: T
    def foo[S](self: S) -&gt; B1[int]:
        return B1[int](111)
b1 = B1[bool](True).foo()
print b1.foo().a                    #: 111

class B2[T]:
    a: T
    def foo[S](self: B2[S]):
        return B2[int](222)
b2 = B2[str]("x").foo()
print b2.foo().a                    #: 222

# explicit realization:
def m7[T,S]():
    print "works"
m7(str,float)                       #: works
m7(str,float)                       #: works
m7(float,str)                       #: works

#%% recursive,barebones
def foo(a):
    if not a:
        foo(True)
    print a
foo(0)
#: True
#: 0

def bar(a):
    def baz(x):
        if not x:
            bar(True)
        print (x)
    baz(a)
bar(0)
#: True
#: 0

def rec2(x, y):
    if x:
        return rec2(y, x)
    else:
        return 1.0
print rec2(1, False).__class__.__name__ #: float

def pq(x):
    return True
def rec3(x, y):
    if pq(x):
        return rec3(y, x)
    else:
        return y
print rec3('x', 's').__class__.__name__  #: str

# Nested mutually recursive function
def f[T](x: T) -&gt; T:
    def g[T](z):
        return z(T())
    return g(f, T=T)
print f(1.2).__class__.__name__ #: float
print f('s').__class__.__name__ #: str

def f2[T](x: T):
    return f2(x - 1, T) if x else 1
print f2(1) #: 1
print f2(1.1).__class__.__name__ #: int


#%% recursive_error,barebones
def pq(x):
    return True
def rec3(x, y): #- ('a, 'b) -&gt; 'b
    if pq(x):
        return rec3(y, x)
    else:
        return y
rec3(1, 's')
#! 'int' does not match expected type 'str'
#! during the realization of rec3(x: int, y: str)

#%% instantiate_function_2,barebones
def fx[T](x: T) -&gt; T:
    def g[T](z):
        return z(T())
    return g(fx, T)
print fx(1.1).__class__.__name__, fx(1).__class__.__name__ #: float int

#%% optionals,barebones
y = None
print y  #: None
y = 5
print y  #: 5

def foo(x: optional[int], y: int):
    print 'foo', x, y
foo(y, 6)  #: foo 5 6
foo(5, 6)  #: foo 5 6
foo(5, y)  #: foo 5 5
y = None
try:
    foo(5, y)
except ValueError:
    print 'unwrap failed'  #: unwrap failed

class Cls:
    x: int
c = None
for i in range(2):
    if c: c.x += 1  # check for unwrap() dot access
    c = Cls(1)
print(c.x)  #: 1

#%% optional_methods,barebones
@extend
class int:
    def x(self):
        print 'x()!', self

y = None
z = 1 if y else None
print z  #: None

y = 6
z = 1 + y if y else None
print z  #: 7
z.x()  #: x()! 7
if 1: # otherwise compiler won't compile z.x() later
    z = None
try:
    z.x()
except ValueError:
    print 'unwrap failed'  #: unwrap failed

print Optional(1) + Optional(2)  #: 3
print Optional(1) + 3  #: 4
print 1 + Optional(1)  #: 2

#%% optional_tuple,barebones
a = None
if True:
    a = ('x', 's')
print(a)  #: ('x', 's')
print(*a, (1, *a))  #: x s (1, 'x', 's')
x,y=a
print(x,y,[*a]) #: x s ['x', 's']

#%% global_none,barebones
a, b = None, None
def foo():
    global a, b
    a = [1, 2]
    b = 3
print a, b,
foo()
print a, b #: None None [1, 2] 3

#%% default_type_none
class Test:
    value: int
    def __init__(self, value: int):
        self.value = value
    def __repr__(self):
        return str(self.value)
def key_func(k: Test):
    return k.value
print sorted([Test(1), Test(3), Test(2)], key=key_func)  #: [1, 2, 3]
print sorted([Test(1), Test(3), Test(2)], key=lambda x: x.value)  #: [1, 2, 3]
print sorted([1, 3, 2])  #: [1, 2, 3]

#%% nested_map
print list(map(lambda i: i-2, map(lambda i: i+1, range(5))))
#: [-1, 0, 1, 2, 3]

def h(x: list[int]):
    return x
print h(list(map(lambda i: i-1, map(lambda i: i+2, range(5)))))
#: [1, 2, 3, 4, 5]

#%% func_unify_error,barebones
def foo(x:int):
    print x
z = 1 &amp; foo #! unsupported operand type(s) for &amp;: 'int' and 'foo[int]'

#%% tuple_type_late,barebones
coords = []
for i in range(2):
    coords.append( ('c', i, []) )
coords[0][2].append((1, 's'))
print(coords)  #: [('c', 0, [(1, 's')]), ('c', 1, [])]

#%% void,barebones
def foo():
    print 'foo'
def bar(x):
    print 'bar', x.__class__.__name__
a = foo()  #: foo
bar(a)  #: bar NoneType

def x():
  pass
b = lambda: x()
b()
x() if True else x()

#%% void_2,barebones
def foo():
    i = 0
    while i &lt; 10:
        print i  #: 0
        yield
        i += 10
a = list(foo())
print(a)  #: [None]

#%% instantiate_swap,barebones
class Foo[T, U]:
    t: T
    u: U
    def __init__(self):
        self.t = T()
        self.u = U()
    def __str__(self):
        return f'{self.t} {self.u}'
print Foo[int, bool](), Foo[bool, int]() #: 0 False False 0

#%% static,barebones
class Num[N_: Static[int]]:
    def __str__(self):
        return f'[{N_}]'
    def __init__(self):
        pass
def foo[N: Static[int]]():
    print Num[N*2]()
foo(3) #: [6]

class XX[N_: Static[int]]:
    a: Num[N_*2]
    def __init__(self):
        self.a = Num()
y = XX[5]()
print y.a, y.__class__.__name__, y.a.__class__.__name__ #: [10] XX[5] Num[10]

@tuple
class FooBar[N: Static[int]]:
    x: Int[N]
z = FooBar(i32(5))
print z, z.__class__.__name__, z.x.__class__.__name__ #: (x: Int[32](5)) FooBar[32] Int[32]

@tuple
class Foo[N: Static[int]]:
    x: Int[2*N]
    def __new__(x: Int[2*N]) -&gt; Foo[N]:
        return (x,)
foo = Foo[10](Int[20](0))
print foo.__class__.__name__, foo.x.__class__.__name__ #: Foo[10] Int[20]

#%% static_2,barebones
class Num[N: Static[int]]:
    def __str__(self):
        return f'~{N}'
    def __init__(self):
        pass
class Foo[T, A: Static[int], B: Static[int]]:
    a: Num[A+B]
    b: Num[A-B]
    c: Num[A if A &gt; 3 else B]
    t: T
    def __init__(self):
        self.a = Num()
        self.b = Num()
        self.c = Num()
        self.t = T()
    def __str__(self):
        return f'&lt;{self.a} {self.b} {self.c} :: {self.t}&gt;'
print Foo[int, 3, 4](), Foo[int, 5, 4]()
#: &lt;~7 ~-1 ~4 :: 0&gt; &lt;~9 ~1 ~5 :: 0&gt;

#%% static_int,barebones
def foo(n: Static[int]):
    print n

a: Static[int] = 5
foo(a &lt; 1)   #: 0
foo(a &lt;= 1)  #: 0
foo(a &gt; 1)   #: 1
foo(a &gt;= 1)  #: 1
foo(a == 1)  #: 0
foo(a != 1)  #: 1
foo(a and 1) #: 1
foo(a or 1)  #: 1
foo(a + 1)   #: 6
foo(a - 1)   #: 4
foo(a * 1)   #: 5
foo(a // 2)  #: 2
foo(a % 2)   #: 1
foo(a &amp; 2)   #: 0
foo(a | 2)   #: 7
foo(a ^ 1)   #: 4

#%% static_str,barebones
class X:
    s: Static[str]
    i: Int[1 + (s == "abc")]
    def __init__(self: X[s], s: Static[str]):
        i = Int[1+(s=="abc")]()
        print s, self.s, self.i.__class__.__name__
def foo(x: Static[str], y: Static[str]):
    print x+y
z: Static[str] = "woo"
foo("he", z)  #: hewoo
X(s='lolo') #: lolo lolo Int[1]
X('abc') #: abc abc Int[2]

#%% static_getitem
print Int[staticlen("ee")].__class__.__name__ #: Int[2]

y = [1, 2]
print getattr(y, "len") #: 2
print y.len #: 2
getattr(y, 'append')(1)
print y #: [1, 2, 1]

@extend
class Dict:
    def __getitem2__(self, attr: Static[str]):
        if hasattr(self, attr):
            return getattr(self, attr)
        else:
            return self[attr]
    def __getitem1__(self, attr: Static[int]):
        return self[attr]

d = {'s': 3.19}
print d.__getitem2__('_upper_bound') #: 3
print d.__getitem2__('s') #: 3.19
e = {1: 3.33}
print e.__getitem1__(1) #: 3.33

#%% static_fail,barebones
def test(i: Int[32]):
    print int(i)
test(Int[5](1)) #! 'Int[5]' does not match expected type 'Int[32]'

#%% static_fail_2,barebones
zi = Int[32](6)
def test3[N](i: Int[N]):
    print int(i)
test3(zi) #! 'N' does not match expected type 'N'
# TODO: nicer error message!

#%% static_fail_3,barebones
zi = Int[32](6)
def test3[N: Static[int]](i: Int[N]):
    print int(i)
test3(1, int) #! expected static expression
# TODO: nicer error message!

#%% nested_fn_generic,barebones
def f(x):
    def g(y):
        return y
    return g(x)
print f(5), f('s') #: 5 s

def f2[U](x: U, y):
    def g[T, U](x: T, y: U):
        return (x, y)
    return g(y, x)
x, y = 1, 'haha'
print f2(x, y).__class__.__name__ #: Tuple[str,int]
print f2('aa', 1.1, U=str).__class__.__name__ #: Tuple[float,str]

#%% nested_fn_generic_error,barebones
def f[U](x: U, y): # ('u, 'a) -&gt; tuple['a, 'u]
    def g[T, U](x: T, y: U): # ('t, 'u) -&gt; tuple['t, 'u]
        return (x, y)
    return g(y, x)
print f(1.1, 1, int).__class__.__name__ #! 'float' does not match expected type 'int'

#%% fn_realization,barebones
def ff[T](x: T, y: tuple[T]):
      print ff(T=str,...).__class__.__name__ #: ff[str,Tuple[str],str]
      return x
x = ff(1, (1,))
print x, x.__class__.__name__ #: 1 int
# print f.__class__.__name__  # TODO ERRORS

def fg[T](x:T):
    def g[T](y):
        z = T()
        return z
    print fg(T=str,...).__class__.__name__  #: fg[str,str]
    print g(1, T).__class__.__name__ #: int
fg(1)
print fg(1).__class__.__name__ #: NoneType

def f[T](x: T):
    print f(x, T).__class__.__name__  #: int
    print f(x).__class__.__name__      #: int
    print f(x, int).__class__.__name__ #: int
    return x
print f(1), f(1).__class__.__name__ #: 1 int
print f(1, int).__class__.__name__ #: int

#%% fn_realization_error,barebones
def f[T](x: T):
    print f(x, int).__class__.__name__
    return x
f('s')
#! 'str' does not match expected type 'int'
#! during the realization of f(x: str, T: str)

#%% nested_class_error,barebones
class X:
    def foo(self, x):
        return x
    class Y:
        def bar(self, x):
            return x
y = X.Y()
y.foo(1) #! 'X.Y' object has no attribute 'foo'

#%% nested_deep_class,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)

print A.B.C[bool].foo(W=str, ...).__class__.__name__ #: foo[bool,bool,bool,str,str]
print A.B.C.foo(1,1,1,True) #: (1, 1, 1, True)
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')
print A.B.C.foo('x', 'x', 'x', 'x') #: ('x', 'x', 'x', 'x')

x = A.B.C[bool]()
print x.__class__.__name__ #: A.B.C[bool]

#%% nested_deep_class_error,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)

print A.B.C[str].foo(1,1,1,True) #! 'A.B.C[str]' object has no method 'foo' with arguments (int, int, int, bool)

#%% nested_deep_class_error_2,barebones
class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def foo[W](t: V, u: V, v: V, w: W):
                return (t, u, v, w)
print A.B[int].C[float].foo(1,1,1,True) #! 'A.B[int]' object has no attribute 'C'

#%% nested_class_function,barebones
def f(x):
    def g(y):
        return y
    a = g(1)
    b = g('s')
    c = g(x)
    return a, b, c
print f(1.1).__class__.__name__ #: Tuple[int,str,float]
print f(False).__class__.__name__ #: Tuple[int,str,bool]

class A[T]:
    a: T
    class B[U]:
        b: U
        class C[V]:
            c: V
            def f(x):
                def g(y):
                    return y
                a = g(1)
                b = g('s')
                c = g(x)
                return a, b, c
print A.B.C.f(1.1).__class__.__name__ #: Tuple[int,str,float]
print A.B.C[Optional[int]].f(False).__class__.__name__ #: Tuple[int,str,bool]

#%% rec_class_1,barebones
class A:
    y: A
    def __init__(self): pass  # necessary to prevent recursive instantiation!
x = A()
print x.__class__.__name__, x.y.__class__.__name__ #: A A

#%% rec_class_2,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
a = A[int]()
print a.__class__.__name__, a.b.__class__.__name__, a.c.__class__.__name__, a.b.b.__class__.__name__, a.b.c.__class__.__name__
#: A[int] A[int] A[str] A[int] A[str]
print a.c.b.__class__.__name__, a.c.c.__class__.__name__, a.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.b.__class__.__name__
#: A[str] A[str] A[int]

#%% rec_class_3,barebones
class X:
    x: int
    rec: X
    def __init__(self): pass
    def foo(x: X, y: int):
        return y
    class Y:
        y: int
        def bar(self, y):
            print y
            return self.y
x, y = X(), X.Y()
print x.__class__.__name__, y.__class__.__name__
#: X X.Y
print X.foo(x, 4), x.foo(5)
#: 4 5
print y.bar(1), y.bar('s'), X.Y.bar(y, True)
#: 1
#: s
#: True
#: 0 0 0

#%% rec_class_4,barebones
class A[T]:
    a: T
    b: A[T]
    c: A[str]
    def __init__(self): pass
class B[T]:
    a: T
    b: A[T]
    c: B[T]
    def __init__(self): pass
    class Nest1[U]:
        n: U
    class Nest2[T, U]:
        m: T
        n: U
b = B[float]()
print b.__class__.__name__, b.a.__class__.__name__, b.b.__class__.__name__, b.c.__class__.__name__, b.c.b.c.a.__class__.__name__
#: B[float] float A[float] B[float] str

n1 = B.Nest1[int]()
print n1.n, n1.__class__.__name__, n1.n.__class__.__name__ #: 0 B.Nest1[int] int

n1: B.Nest2 = B.Nest2[float, int]()
print (n1.m, n1.n), n1.__class__.__name__, n1.m.__class__.__name__, n1.n.__class__.__name__ #: (0, 0) B.Nest2[float,int] float int

#%% func_arg_instantiate,barebones
class A[T]:
    y: T
    def foo(self, y: T):
        self.y = y
        return y
    def bar(self, y):
        return y
a = A()
print a.__class__.__name__ #: A[int]
a.y = 5
print a.__class__.__name__ #: A[int]

b = A()
print b.foo(5) #: 5
print b.__class__.__name__, b.y #: A[int] 5
print b.bar('s'), b.bar('s').__class__.__name__ #: s str
print b.bar(5), b.bar(5).__class__.__name__ #: 5 int

aa = A()
print aa.foo('s') #: s
print aa.__class__.__name__, aa.y, aa.bar(5.1).__class__.__name__ #: A[str] s float

#%% no_func_arg_instantiate_err,barebones
# TODO: allow unbound self?
class A[T]:
    y: T
    def foo(self, y): self.y = y
a = A()
a.foo(1) #! cannot typecheck the program

#%% return_deduction,barebones
def fun[T, R](x, y: T) -&gt; R:
   	def ffi[T, R, Z](x: T, y: R, z: Z):
   		return (x, y, z)
   	yy = ffi(False, byte(2), 's', T=bool, Z=str, R=R)
   	yz = ffi(1, byte(2), 's', T=int, Z=str, R=R)
   	return byte(1)
print fun(2, 1.1, float, byte).__class__.__name__ #: byte

#%% return_auto_deduction_err,barebones
def fun[T, R](x, y: T) -&gt; R:
   	return byte(1)
print fun(2, 1.1).__class__.__name__ #! cannot typecheck the program

#%% random
# shuffle used to fail before for some reason (sth about unbound variables)...
def foo():
    from random import shuffle
    v = list(range(10))
    shuffle(v)
    print sorted(v) #: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
foo()

#%% function_type,barebones
class F:
    f: Function[[int], int]
    g: function[[int], None]
    x: int
def foo(x: int):
    return x+1
def goo(x: int):
    print x+2
f = F(foo, goo, 2)
print f.f(f.x) #: 3
f.g(f.x) #: 4

def hoo(z):
    print z+3
f.g = hoo
f.g(f.x)  #: 5

def hai(x, y, z):
    print f'hai({x},{y},{z})'
fn = Function[[int, int, int], None](hai)
fn(1, 2, 3) #: hai(1,2,3)
print str(fn)[:12] #: &lt;function at
z = fn(2, 3, ...)
z(3) #: hai(2,3,3)

#%% int_float,barebones
l = [1., 2, 3, 4]
print l, l.__class__.__name__ #: [1, 2, 3, 4] List[float]

#%% forward_fn,barebones
def test(name, sort, key):
    v1 = [1, 2, 3, 4]
    sp = sort(v1, key)
    print name, sp
def foo(l, f):
    return [f(i) for i in l]
test('hi', foo, lambda x: x+1) #: hi [2, 3, 4, 5]

def foof(l: List[int], x, f: Callable[[int], int]):
    return [f(i)+x for i in l]
test('qsort', foof(x=3, ...), lambda x: x+1) #: qsort [5, 6, 7, 8]

#%% class_fn_access,barebones
class X[T]:
    def foo[U](self, x: T, y: U):
        return (x+x, y+y)
y = X[X[int]]()
print y.__class__.__name__ #: X[X[int]]
print X[float].foo(U=int, ...).__class__.__name__ #: foo[X[float],float,int,int]
print X[int]().foo(1, 's') #: (2, 'ss')

#%% class_partial_access,barebones
class X[T]:
    def foo[U](self, x, y: U):
        return (x+x, y+y)
y = X[X[int]]()
# TODO: should this even be the case?
# print y.foo(U=float,...).__class__.__name__  -&gt;  X.foo[X[X[int]],...,...]
print y.foo(1, 2.2, float) #: (2, 4.4)

#%% forward,barebones
def foo(f, x):
    f(x, type(x))
    print f.__class__.__name__
def bar[T](x):
    print x, T.__class__.__name__
foo(bar, 1)
#: 1 int
#: bar[...]
foo(bar(...), 's')
#: s str
#: bar[...]
z = bar
z('s', int)
#: s int
z(1, T=str)
#: 1 str

zz = bar(T=int,...)
zz(1)
#: 1 int

#%% forward_error,barebones
def foo(f, x):
    f(x, type(x))
    print f.__class__.__name__
def bar[T](x):
    print x, T.__class__.__name__
foo(bar(T=int,...), 1)
#! bar() takes 2 arguments (2 given)
#! during the realization of foo(f: bar[...], x: int)
# TODO fix this error message

#%% sort_partial
def foo(x, y):
    return y**x
print sorted([1,2,3,4,5], key=foo(y=2, ...))
print sorted([1,2,3,4,5], key=foo(y=-2, ...))
#: [1, 2, 3, 4, 5]
#: [5, 3, 1, 2, 4]

#%% mutually_recursive_error,barebones
def bl(x):
    return True
def frec(x, y):
    def grec(x, y):
        return frec(y, x)
    return grec(x, y) if bl(y) else 2
print frec(1, 2).__class__.__name__, frec('s', 1).__class__.__name__
#! 'NoneType' does not match expected type 'int'
#! during the realization of frec(x: int, y: int)

#%% return_fn,barebones
def retfn(a):
    def inner(b, *args, **kwargs):
        print a, b, args, kwargs
    print inner.__class__.__name__ #: inner[...,...,int,...]
    return inner(15, ...)
f = retfn(1)
print f.__class__.__name__ #: inner[int,...,int,...]
f(2,3,foo='bar') #: 1 15 (2, 3) (foo: 'bar')

#%% decorator_manual,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
    return 1
def dec(fn, a):
    print 'decorating', fn.__class__.__name__ #: decorating foo[...,...,...]
    def inner(*args, **kwargs):
        print 'decorator', args, kwargs #: decorator (5.5, 's') (z: True)
        return fn(a, *args, **kwargs)
    return inner(...)
ff = dec(foo(...), 10)
print ff(5.5, 's', z=True)
#: 10 (5.5, 's') (z: True)
#: 1


#%% decorator,barebones
def foo(x, *args, **kwargs):
    print x, args, kwargs
    return 1
def dec(a):
    def f(fn):
        print 'decorating', fn.__class__.__name__
        def inner(*args, **kwargs):
            print 'decorator', args, kwargs
            return fn(a, *args, **kwargs)
        return inner
    return f
ff = dec(10)(foo)
print ff(5.5, 's', z=True)
#: decorating foo[...,...,...]
#: decorator (5.5, 's') (z: True)
#: 10 (5.5, 's') (z: True)
#: 1

@dec(a=5)
def zoo(e, b, *args):
    return f'zoo: {e}, {b}, {args}'
print zoo(2, 3)
print zoo('s', 3)
#: decorating zoo[...,...,...]
#: decorator (2, 3) ()
#: zoo: 5, 2, (3)
#: decorator ('s', 3) ()
#: zoo: 5, s, (3)

def mydecorator(func):
    def inner():
        print("before")
        func()
        print("after")
    return inner
@mydecorator
def foo2():
    print("foo")
foo2()
#: before
#: foo
#: after

def timeme(func):
    def inner(*args, **kwargs):
        begin = 1
        end = func(*args, **kwargs) - begin
        print('time needed for', func.__class__.__name__, 'is', end)
    return inner
@timeme
def factorial(num):
    n = 1
    for i in range(1,num + 1):
        n *= i
    print(n)
    return n
factorial(10)
#: 3628800
#: time needed for factorial[...] is 3628799

def dx1(func):
    def inner():
        x = func()
        return x * x
    return inner
def dx2(func):
    def inner():
        x = func()
        return 2 * x
    return inner
@dx1
@dx2
def num():
    return 10
print(num()) #: 400

def dy1(func):
    def inner(*a, **kw):
        x = func(*a, **kw)
        return x * x
    return inner
def dy2(func):
    def inner(*a, **kw):
        x = func(*a, **kw)
        return 2 * x
    return inner
@dy1
@dy2
def num2(a, b):
    return a+b
print(num2(10, 20)) #: 3600

#%% hetero_iter,barebones
e = (1, 2, 3, 'foo', 5, 'bar', 6)
for i in e:
    if isinstance(i, int):
        if i == 1: continue
    if isinstance(i, str):
        if i == 'bar': break
    print i

#%% type_loc,barebones
a = 1
T = type(a)
print T.__class__.__name__  #: int

#%% empty_tuple,barebones
T = type(())  # only errors with empty tuple type
p = Ptr[T](cobj())
print p.__class__.__name__  #: Ptr[Tuple]

print [a for a in ()]  #: []

def foo(*args):
    return [a for a in args]
args, result = ((), [()])
print list(foo(*args))  #: []
print result  #: [()]


#%% type_error_reporting
# TODO: improve this certainly
def tee(iterable, n=2):
    from collections import deque
    it = iter(iterable)
    deques = [deque() for i in range(n)]
    def gen(mydeque):
        while True:
            if not mydeque:             # when the local deque is empty
                if it.done():
                    return
                newval = it.next()
                for d in deques:        # load it to all the deques
                    d.append(newval)
            yield mydeque.popleft()
    return list(gen(d) for d in deques)
it = [1,2,3,4]
a, b = tee(it)
#! cannot typecheck the program
#! during the realization of tee(iterable: List[int], n: int)

#%% new_syntax,barebones
def foo[T,U](x: type, y, z: Static[int] = 10):
    print T.__class__.__name__, U.__class__.__name__, x.__class__.__name__, y.__class__.__name__, Int[z+1].__class__.__name__
    return List[x]()
print foo(T=int,U=str,...).__class__.__name__ #: foo[T1,x,z,int,str]
print foo(T=int,U=str,z=5,x=bool,...).__class__.__name__ #: foo[T1,bool,5,int,str]
print foo(float,3,T=int,U=str,z=5).__class__.__name__ #: List[float]
foo(float,1,10,str,int) #: str int float int Int[11]


class Foo[T,U: Static[int]]:
    a: T
    b: Static[int]
    c: Int[U]
    d: type
    e: List[d]
    f: UInt[b]
print Foo[5,int,float,6].__class__.__name__ #: Foo[5,int,float,6]
print Foo(1.1, 10i32, [False], 10u66).__class__.__name__ #: Foo[66,bool,float,32]


def foo2[N: Static[int]]():
    print Int[N].__class__.__name__, N
x: Static[int] = 5
y: Static[int] = 105 - x * 2
foo2(y-x) #: Int[90] 90

if 1.1+2.2 &gt; 0:
    z: Static[int] = 88
    print z #: 88
print x #: 5
x : Static[int] = 3
print x #: 3

def fox(N: Static[int] = 4):
    print Int[N].__class__.__name__, N
fox(5) #: Int[5] 5
fox() #: Int[4] 4

#%% new_syntax_err,barebones
class Foo[T,U: Static[int]]:
    a: T
    b: Static[int]
    c: Int[U]
    d: type
    e: List[d]
    f: UInt[b]
print Foo[float,6].__class__.__name__ #! Foo takes 4 generics (2 given)

#%% partial_star_pipe_args,barebones
iter(['A', 'C']) |&gt; print
#: A
#: C
iter(range(4)) |&gt; print('x', ..., 1)
#: x 0 1
#: x 1 1
#: x 2 1
#: x 3 1

#%% type_arg_transform,barebones
print list(map(str, range(5)))
#: ['0', '1', '2', '3', '4']


#%% traits,barebones
def t[T](x: T, key: Optional[Callable[[T], S]] = None, S: type = NoneType):
    if isinstance(S, NoneType):
        return x
    else:
        return (key.__val__())(x)
print t(5) #: 5
print t(6, lambda x: f'#{x}') #: #6

z: Callable[[int],int] = lambda x: x+1
print z(5) #: 6

def foo[T](x: T, func: Optional[Callable[[], T]] = None) -&gt; T:
    return x
print foo(1) #: 1

#%% trait_callable
foo = [1,2,11]
print(sorted(foo, key=str))
#: [1, 11, 2]

foo = {1: "a", 2: "a", 11: "c"}
print(sorted(foo.items(), key=str))
#: [(1, 'a'), (11, 'c'), (2, 'a')]

def call(f: Callable[[int,int], Tuple[str,int]]):
    print(f(1, 2))

def foo(*x): return f"{x}_{x.__class__.__name__}",1
call(foo)
#: ('(1, 2)_Tuple[int,int]', 1)

def foo(a:int, *b: float): return f"{a}_{b}", a+b[0]
call(foo)
#: ('1_(2)', 3)

def call(f: Callable[[int,int],str]):
    print(f(1, 2))
def foo(a: int, *b: int, **kw): return f"{a}_{b}_{kw}"
call(foo(zzz=1.1, ...))
#: 1_(2)_(zzz: 1.1)

#%% traits_error,barebones
def t[T](x: T, key: Optional[Callable[[T], S]] = None, S: type = NoneType):
    if isinstance(S, NoneType):
        return x
    else:
        return (key.__val__())(x)
print t(6, Optional(1)) #! 'Optional[int]' does not match expected type 'Optional[Callable[[int],S]]'

#%% traits_error_2,barebones
z: Callable[[int],int] = 4 #! 'Callable[[int],int]' does not match expected type 'int'

#%% assign_wrappers,barebones
a = 1.5
print a #: 1.5
if 1:
    a = 1
print a, a.__class__.__name__ #: 1 float

a: Optional[int] = None
if 1:
    a = 5
print a.__class__.__name__, a #: Optional[int] 5

b = 5
c = Optional(6)
if 1:
    b = c
print b.__class__.__name__, c.__class__.__name__, b, c #: int Optional[int] 6 6

z: Generator[int] = [1, 2]
print z.__class__.__name__ #: Generator[int]

zx: float = 1
print zx.__class__.__name__, zx #: float 1

def test(v: Optional[int]):
    v: int = v if v is not None else 3
    print v.__class__.__name__
test(5) #: int
test(None) #: int

#%% methodcaller,barebones
def foo():
    def bar(a, b):
        print 'bar', a, b
    return bar
foo()(1, 2) #: bar 1 2

def methodcaller(foo: Static[str]):
    def caller(foo: Static[str], obj, *args, **kwargs):
        if isinstance(getattr(obj, foo)(*args, **kwargs), None):
            getattr(obj, foo)(*args, **kwargs)
        else:
            return getattr(obj, foo)(*args, **kwargs)
    return caller(foo=foo, ...)
v = [1]
methodcaller('append')(v, 42)
print v #: [1, 42]
print methodcaller('index')(v, 42) #: 1

#%% fn_overloads,barebones
def foo(x):
    return 1, x

print(foo(''))  #: (1, '')

@overload
def foo(x, y):
    def foo(x, y):
        return f'{x}_{y}'
    return 2, foo(x, y)

@overload
def foo(x):
    if x == '':
        return 3, 0
    return 3, 1 + foo(x[1:])[1]

print foo('hi') #: (3, 2)
print foo('hi', 1) #: (2, 'hi_1')

#%% fn_shadow,barebones
def foo(x):
    return 1, x
print foo('hi') #: (1, 'hi')

def foo(x):
    return 2, x
print foo('hi') #: (2, 'hi')

#%% fn_overloads_error,barebones
def foo(x):
    return 1, x
@overload
def foo(x, y):
    return 2, x, y
foo('hooooooooy!', 1, 2) #! no function 'foo' with arguments (str, int, int)

#%% c_void_return,barebones
from C import seq_print(str)
x = seq_print("not ")
print x  #: not None


#%% static_for,barebones
def foo(i: Static[int]):
    print('static', i, Int[i].__class__.__name__)

for i in statictuple(1, 2, 3, 4, 5):
    foo(i)
    if i == 3: break
#: static 1 Int[1]
#: static 2 Int[2]
#: static 3 Int[3]
for i in staticrange(9, 4, -2):
    foo(i)
    if i == 3:
        break
#: static 9 Int[9]
#: static 7 Int[7]
#: static 5 Int[5]
for i in statictuple("x", 1, 3.3, 2):
    print(i)
#: x
#: 1
#: 3.3
#: 2

print tuple(Int[i+10](i) for i in statictuple(1, 2, 3)).__class__.__name__
#: Tuple[Int[11],Int[12],Int[13]]

for i in staticrange(0, 10):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[1]
#: xyz Int[3]
#: xyz Int[5]
#: xyz Int[7]
#: whoa

for i in staticrange(15):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[1]
#: xyz Int[3]
#: xyz Int[5]
#: xyz Int[7]
#: whoa

print tuple(Int[i-10](i) for i in staticrange(30,33)).__class__.__name__
#: Tuple[Int[20],Int[21],Int[22]]

for i in statictuple(0, 2, 4, 7, 11, 12, 13):
    if i % 2 == 0: continue
    if i &gt; 8: break
    print('xyz', Int[i].__class__.__name__)
print('whoa')
#: xyz Int[7]
#: whoa

for i in staticrange(10):  # TODO: large values are too slow!
    pass
print('done')
#: done

tt = (5, 'x', 3.14, False, [1, 2])
for i, j in staticenumerate(tt):
    print(foo(i * 2 + 1), j)
#: static 1 Int[1]
#: None 5
#: static 3 Int[3]
#: None x
#: static 5 Int[5]
#: None 3.14
#: static 7 Int[7]
#: None False
#: static 9 Int[9]
#: None [1, 2]

print tuple((Int[i+1](i), j) for i, j in staticenumerate(tt)).__class__.__name__
#: Tuple[Tuple[Int[1],int],Tuple[Int[2],str],Tuple[Int[3],float],Tuple[Int[4],bool],Tuple[Int[5],List[int]]]

#%% static_range_error,barebones
for i in staticrange(1000, -2000, -2):
    pass
#! staticrange too large (expected 0..1024, got instead 1500)

#%% trait_defdict
class dd(Static[Dict[K,V]]):
    fn: S
    K: type
    V: type
    S: TypeVar[Callable[[], V]]

    def __init__(self: dd[K, VV, Function[[], V]], VV: TypeVar[V]):
        self.fn = lambda: VV()

    def __init__(self, f: S):
        self.fn = f

    def __getitem__(self, key: K) -&gt; V:
        if key not in self:
            self.__setitem__(key, self.fn())
        return super().__getitem__(key)


x = dd(list)
x[1] = [1, 2]
print(x[2])
#: []
print(x)
#: {1: [1, 2], 2: []}

z = 5
y = dd(lambda: z+1)
y.update({'a': 5})
print(y['b'])
#: 6
z = 6
print(y['c'])
#: 7
print(y)
#: {'a': 5, 'b': 6, 'c': 7}

xx = dd(lambda: 'empty')
xx.update({1: 's', 2: 'b'})
print(xx[1], xx[44])
#: s empty
print(xx)
#: {44: 'empty', 1: 's', 2: 'b'}

s = 'mississippi'
d = dd(int)
for k in s:
    d[k] = d["x" + k]
print(sorted(d.items()))
#: [('i', 0), ('m', 0), ('p', 0), ('s', 0), ('xi', 0), ('xm', 0), ('xp', 0), ('xs', 0)]


#%% kwargs_getattr,barebones
def foo(**kwargs):
    print kwargs['foo'], kwargs['bar']

foo(foo=1, bar='s')
#: 1 s



#%% union_types,barebones
def foo_int(x: int):
    print(f'{x} {x.__class__.__name__}')
def foo_str(x: str):
    print(f'{x} {x.__class__.__name__}')
def foo(x):
    print(f'{x} {int(__internal__.union_get_tag(x))} {x.__class__.__name__}')

a: Union[int, str] = 5
foo_int(a)  #: 5 int
foo(a)  #: 5 0 Union[int,str]
print(staticlen(a))  #: 2
print(staticlen(Union[int, int]), staticlen(Tuple[int, float, int]))  #: 1 3

@extend
class str:
    def __add__(self, i: int):
        return int(self) + i

a += 6  ## this is U.__new__(a.__getter__(__add__)(59))
b = a + 59
print(a, b, a.__class__.__name__, b.__class__.__name__)  #: 11 70 Union[int,str] int

if True:
    a = 'hello'
    foo_str(a)  #: hello str
    foo(a)  #: 'hello' 1 Union[int,str]
    # b = a[1:3]
    # print(b)
print(a)  #: 'hello'

a: Union[Union[Union[str], int], Union[int, int, str]] = 9
foo(a)  #: 9 0 Union[int,str]

def ret(x):
    z : Union = x
    if x &lt; 1: z = 1
    elif x &lt; 10: z = False
    else: z = 'oops'
    return z
r = ret(2)
print(r, r.__class__.__name__)  #: False Union[bool,int,str]
r = ret(33.3)
print(r, r.__class__.__name__)  #: 'oops' Union[bool,float,int,str]

def ret2(x) -&gt; Union:
    if x &lt; 1: return 1
    elif x &lt; 10: return 2.2
    else: return ['oops']
r = ret2(20)
print(r, r.__class__.__name__)  #: ['oops'] Union[List[str],float,int]

class A:
    x: int
    def foo(self):
        return f"A: {self.x}"
class B:
    y: str
    def foo(self):
        return f"B: {self.y}"
x : Union[A,B] = A(5)  # TODO: just Union does not work :/
print(x.foo())  #: A: 5
if True:
    x = B("bee")
print(x.foo())  #: B: bee

def do(x: A):
    print('do', x.x)
try:
    do(x)
except TypeError:
    print('error') #: error

def do2(x: B):
    print('do2', x.y)
do2(x)  #: do2 bee

z: Union[int, str] = 1
print isinstance(z, int), isinstance(z, str), isinstance(z, float), isinstance(z, Union[int, float]), isinstance(z, Union[int, str])
#: True False False False True

print isinstance(z, Union[int]), isinstance(z, Union[int, float, str])
#: False False

if True:
    z = 's'
print isinstance(z, int), isinstance(z, str), isinstance(z, float), isinstance(z, Union[int, float]), isinstance(z, Union[int, str])
#: False True False False True

class A:
    def foo(self): return 1
class B:
    def foo(self): return 's'
class C:
    def foo(self): return [True, False]
x : Union[A,B,C] = A()
print x.foo(), x.foo().__class__.__name__
#: 1 Union[List[bool],int,str]

xx = Union[int, str](0)
print(xx)  #: 0

#%% union_error,barebones
a: Union[int, str] = 123
print(123 == a)  #: True
print(a == 123)  #: True
try:
    a = "foo"
    print(a == 123)
except TypeError:
    print("oops", a)  #: oops 'foo'


#%% generator_capture_nonglobal,barebones
# Issue #49
def foo(iter):
    print(iter.__class__.__name__, list(iter))

for x in range(2):
    foo(1 for _ in range(x))
#: Generator[int] []
#: Generator[int] [1]
for x in range(2):
    for y in range(x):
        foo('z' for _ in range(y))
#: Generator[str] []

#%% nonlocal_capture_loop,barebones
# Issue #51
def kernel(fn):
    def wrapper(*args, grid, block):
        print(grid, block, fn(*args))
    return wrapper
def test_mandelbrot():
    MAX    = 10  # maximum Mandelbrot iterations
    N      = 2   # width and height of image
    pixels = [0 for _ in range(N)]
    def scale(x, a, b):
        return a + (x/N)*(b - a)
    @kernel
    def k(pixels):
        i = 0
        while i &lt; MAX: i += 1  # this is needed for test to make sense
        return (MAX, N, pixels, scale(N, -2, 0.4))
    k(pixels, grid=(N*N)//1024, block=1024)
test_mandelbrot()  #: 0 1024 (10, 2, [0, 0], 0.4)

#%% delayed_lambda_realization,barebones
x = []
for i in range(2):
    print(all(x[j] &lt; 0 for j in range(i)))
    x.append(i)
#: True
#: False

#%% constructor_passing
class A:
    s: str
    def __init__(self, x):
        self.s = str(x)[::-1]
    def __lt__(self, o): return self.s &lt; o.s
    def __eq__(self, o): return self.s == o.s
    def __ge__(self, o): return self.s &gt;= o.s
foo = [1,2,11,30]
print(sorted(foo, key=str))
#: [1, 11, 2, 30]
print(sorted(foo, key=A))
#: [30, 1, 11, 2]


#%% polymorphism,barebones
class A:
    a: int
    def foo(self, a: int): return (f'A({self.a})', a)
    def bar(self): return 'A.bar'
    def aaz(self): return 'A.aaz'
class B(A):
    b: int
    def foo(self, a): return (f'B({self.a},{self.b})', a + self.b)
    def bar(self): return 'B.bar'
    def baz(self): return 'B.baz'
class M[T]:
    m: T
    def moo(self): return (f'M_{T.__class__.__name__}', self.m)
class X(B,M[int]):
    def foo(self, a): return (f'X({self.a},{self.b},{self.m})', a + self.b + self.m)
    def bar(self): return 'X.bar'

def foo(i):
    x = i.foo(1)
    y = i.bar()
    z = i.aaz()
    print(*x, y, z)
a = A(1)
l = [a, B(2,3), X(2,3,-1)]
for i in l: foo(i)
#: A(1) 1 A.bar A.aaz
#: B(2,3) 4 B.bar A.aaz
#: X(2,3,-1) 3 X.bar A.aaz

def moo(m: M):
    print(m.moo())
moo(M[float](5.5))
moo(X(1,2,3))
#: ('M_float', 5.5)
#: ('M_int', 3)


class A[T]:
    def __init__(self):
        print("init A", T.__class__.__name__)
class Ho:
    def __init__(self):
        print("init Ho")
# TODO: this throws and error: B[U](U)
class B[U](A[U], Ho):
    def __init__(self):
        super().__init__()
        print("init B", U.__class__.__name__)
B[Ho]()
#: init A Ho
#: init B Ho


class Vehicle:
    def drive(self):
        return "I'm driving a vehicle"

class Car(Vehicle):
    def drive(self):
        return "I'm driving a car"

class Truck(Vehicle):
    def drive(self):
        return "I'm driving a truck"

class SUV(Car, Truck):
    def drive(self):
        return "I'm driving an SUV"

suv = SUV()
def moo(s):
    print(s.drive())
moo(suv)
moo(Truck())
moo(Car())
moo(Vehicle())
#: I'm driving an SUV
#: I'm driving a truck
#: I'm driving a car
#: I'm driving a vehicle


#%% polymorphism_error_1,barebones
class M[T]:
    m: T
class X(M[int]):
    pass
l = [M[float](1.1), X(2)]
#! 'List[M[float]]' object has no method 'append' with arguments (List[M[float]], X)

#%% polymorphism_2
class Expr:
    def __init__(self):
        pass
    def eval(self):
        raise ValueError('invalid expr')
        return 0.0
    def __str__(self):
        return "Expr"
class Const(Expr):
    x: float
    def __init__(self, x):
        self.x=x
    def __str__(self):
        return f"{self.x}"
    def eval(self):
        return self.x
class Add(Expr):
    lhs: Expr
    rhs: Expr
    def __init__(self, lhs, rhs):
        self.lhs=lhs
        self.rhs=rhs
        # print(f'ctr: {self}')
    def eval(self):
        return self.lhs.eval()+self.rhs.eval()
    def __str__(self):
        return f"({self.lhs}) + ({self.rhs})"
class Mul(Expr):
    lhs: Expr
    rhs: Expr
    def __init__(self, lhs, rhs):
        self.lhs=lhs
        self.rhs=rhs
    def eval(self):
        return self.lhs.eval()*self.rhs.eval()
    def __str__(self):
        return f"({self.lhs}) * ({self.rhs})"

c1 = Const(5)
c2 = Const(4)
m = Add(c1, c2)
c3 = Const(2)
a : Expr = Mul(m, c3)
print(f'{a} = {a.eval()}')
#: ((5) + (4)) * (2) = 18

from random import random, seed
seed(137)
def random_expr(depth) -&gt; Expr:
    if depth&lt;=0:
        return Const(int(random()*42.0))
    else:
        lhs=random_expr(depth-1)
        rhs=random_expr(depth-1)
        ctorid = int(random()*3)
        if ctorid==0:
            return Mul(lhs,rhs)
        else:
            return Add(lhs,rhs)
for i in range(11):
    print(random_expr(i).eval())
#: 17
#: 71
#: 1760
#: 118440
#: 94442
#: 8.02435e+15
#: 1.07463e+13
#: 1.43017e+19
#: 2.40292e+34
#: 6.1307e+28
#: 5.16611e+49


#%% collection_common_type,barebones
l = [1, 2, 3]
print(l, l.__class__.__name__)
#: [1, 2, 3] List[int]

l = [1.1, 2, 3]
print(l, l.__class__.__name__)
#: [1.1, 2, 3] List[float]

l = [1, 2, 3.3]
print(l, l.__class__.__name__)
#: [1, 2, 3.3] List[float]

l = [1, None]
print(l, l.__class__.__name__)
#: [1, None] List[Optional[int]]

l = [None, 2.2]
print(l, l.__class__.__name__)
#: [None, 2.2] List[Optional[float]]

class A:
    def __repr__(self): return 'A'
class B(A):
    def __repr__(self): return 'B'
class C(B):
    def __repr__(self): return 'C'
class D(A):
    def __repr__(self): return 'D'

l = [A(), B(), C(), D()]
print(l, l.__class__.__name__)
#: [A, B, C, D] List[A]

l = [D(), C(), B(), A()]
print(l, l.__class__.__name__)
#: [D, C, B, A] List[A]

l = [C(), B()]
print(l, l.__class__.__name__)
#: [C, B] List[B]

l = [C(), A(), B()]
print(l, l.__class__.__name__)
#: [C, A, B] List[A]

l = [None, *[1, 2], None]
print(l, l.__class__.__name__)
#: [None, 1, 2, None] List[Optional[int]]

# l = [C(), D(), B()] # does not work (correct behaviour)
# print(l, l.__class__.__name__)

d = {1: None, 2.2: 's'}
print(d, d.__class__.__name__)
#: {1: None, 2.2: 's'} Dict[float,Optional[str]]

#%% polymorphism_3
import operator

class Expr:
    def eval(self):
        return 0

class Const(Expr):
    value: int

    def __init__(self, value):
        self.value = value

    def eval(self):
        return self.value

class BinOp(Expr):
    lhs: Expr
    rhs: Expr

    def __init__(self, lhs, rhs):
        self.lhs = lhs
        self.rhs = rhs

    def eval_from_fn(self, fn):
        return fn(self.lhs.eval(), self.rhs.eval())

class Add(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.add)

class Sub(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.sub)

class Mul(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.mul)

class Div(BinOp):
    def eval(self):
        return self.eval_from_fn(operator.floordiv)

# TODO: remove Expr requirement
expr : Expr = Mul(Const(3), Add(Const(10), Const(5)))
print(expr.eval()) #: 45


#%% polymorphism_4
class A(object):
    a: int
    def __init__(self, a: int):
        self.a = a

    def test_a(self, n: int):
        print("test_a:A", n)

    def test(self, n: int):
        print("test:A", n)

    def test2(self, n: int):
        print("test2:A", n)

class B(A):
    b: int
    def __init__(self, a: int, b: int):
        super().__init__(a)
        self.b = b

    def test(self, n: int):
        print("test:B", n)

    def test2(self, n: int):
        print("test2:B", n)

class C(B):
    pass

b = B(1, 2)
b.test_a(1)
b.test(1)
#: test_a:A 1
#: test:B 1

a: A = b
a.test(1)
a.test2(2)
#: test:B 1
#: test2:B 2


#%% no_generic,barebones
def foo(a, b: Static[int]):
    pass
foo(5)  #! generic 'b' not provided


#%% no_generic_2,barebones
def f(a, b, T: type):
    print(a, b)
f(1, 2)  #! generic 'T' not provided
</t>
<t tx="ekr.20230509083244.87"></t>
<t tx="ekr.20230509083244.88">@path C:/Repos/codon/test/parser/a/
@language unknown_language
def foo():
    print 'a.foo'
def bar():
    print 'a.bar'
print 'a'

zoo = 5
_zoo = 3

class B:
    pass
C = B
tt = Ptr[B]
@tuple
class Foo:
    t: tt

def ha():
    c = C()
    print(c.__class__.__name__)


par = 'y'
if len('x') == 1:
    par = 'x'
</t>
<t tx="ekr.20230509083244.89"></t>
<t tx="ekr.20230509083244.9">};

struct EscapeValidator : public ir::transform::Pass {
  const std::string KEY = "test-escape-validator-pass";
  std::string getKey() const override { return KEY; }

  std::string capAnalysisKey;

  explicit EscapeValidator(const std::string &amp;capAnalysisKey)
      : ir::transform::Pass(), capAnalysisKey(capAnalysisKey) {}

</t>
<t tx="ekr.20230509083244.90">@path C:/Repos/codon/test/parser/a/b/
@language unknown_language
print 'import rec1'

var = 'x'

import rec2
rec2.foo()

def bar():
    print 'rec1.bar'

print 'done rec1'
</t>
<t tx="ekr.20230509083244.91">@path C:/Repos/codon/test/parser/a/b/
@language unknown_language
print 'import rec1'

import rec2_err
rec2_err.foo()

def bar():
    print 'rec1.bar'
</t>
<t tx="ekr.20230509083244.92">@path C:/Repos/codon/test/parser/a/b/
@language unknown_language
print 'import rec2'

from .rec1 import var

def foo():
    print 'rec2.' + var

print 'done rec2'
</t>
<t tx="ekr.20230509083244.93">@path C:/Repos/codon/test/parser/a/b/
@language unknown_language
print 'import rec2'

from .rec1_err import bar
bar()

def foo():
    print 'rec2.foo'
</t>
<t tx="ekr.20230509083244.94">@path C:/Repos/codon/test/parser/a/b/
@language unknown_language
c = 'a.b.c'
def har():
    print 'a.b.har', __name__[-12:], c

from .. import foo as fx

class A:
    class B:
        def b_foo():
            print 'a.b.A.B.b_foo()'
            return 1

stt: Static[int] = 5
</t>
<t tx="ekr.20230509083244.95"></t>
<t tx="ekr.20230509083244.96">@path C:/Repos/codon/test/python/
from typing import Dict, List, Tuple

import codon

@others
test_cross_calls()
@language python
@tabwidth -4
</t>
<t tx="ekr.20230509083244.97">@codon.convert
class Foo:
    __slots__ = 'a', 'b', 'c'

    @others
</t>
<t tx="ekr.20230509083244.98">def __init__(self, n):
    self.a = n
    self.b = n**2
    self.c = n**3

</t>
<t tx="ekr.20230509083244.99">def __eq__(self, other):
    return (self.a == other.a and
            self.b == other.b and
            self.c == other.c)

</t>
<t tx="ekr.20230509083458.1"></t>
<t tx="ekr.20230509083532.1">True: run flake8 on each saved file, but only if it has been changed.</t>
</tnodes>
</leo_file>
