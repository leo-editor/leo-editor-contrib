<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20240308084847.1"><vh> Recursive import script</vh>
<v t="ekr.20240308084847.2"><vh>&lt;&lt; rust dir_list &gt;&gt;</vh></v>
</v>
<v t="ekr.20240308085046.1"><vh>top level</vh>
<v t="ekr.20240308084832.3"><vh>__init__.py</vh></v>
<v t="ekr.20240308084832.4"><vh>__main__.py</vh>
<v t="ekr.20240308084832.5"><vh>function: main</vh></v>
</v>
<v t="ekr.20240308084832.6"><vh>build.py</vh>
<v t="ekr.20240308084832.7"><vh>function: get_extension</vh></v>
<v t="ekr.20240308084832.8"><vh>function: setup_mypycify_vars</vh></v>
<v t="ekr.20240308084832.9"><vh>function: fail</vh></v>
<v t="ekr.20240308084832.10"><vh>function: emit_messages</vh></v>
<v t="ekr.20240308084832.11"><vh>function: get_mypy_config</vh></v>
<v t="ekr.20240308084832.12"><vh>function: generate_c_extension_shim</vh></v>
<v t="ekr.20240308084832.13"><vh>function: group_name</vh></v>
<v t="ekr.20240308084832.14"><vh>function: include_dir</vh></v>
<v t="ekr.20240308084832.15"><vh>function: generate_c</vh></v>
<v t="ekr.20240308084832.16"><vh>function: build_using_shared_lib</vh></v>
<v t="ekr.20240308084832.17"><vh>function: build_single_module</vh></v>
<v t="ekr.20240308084832.18"><vh>function: write_file</vh></v>
<v t="ekr.20240308084832.19"><vh>function: construct_groups</vh></v>
<v t="ekr.20240308084832.20"><vh>function: get_header_deps</vh></v>
<v t="ekr.20240308084832.21"><vh>function: mypyc_build</vh></v>
<v t="ekr.20240308084832.22"><vh>function: mypycify</vh></v>
</v>
<v t="ekr.20240308084832.23"><vh>common.py</vh>
<v t="ekr.20240308084832.24"><vh>function: shared_lib_name</vh></v>
<v t="ekr.20240308084832.25"><vh>function: short_name</vh></v>
<v t="ekr.20240308084832.26"><vh>function: use_vectorcall</vh></v>
<v t="ekr.20240308084832.27"><vh>function: use_method_vectorcall</vh></v>
<v t="ekr.20240308084832.28"><vh>function: get_id_from_name</vh></v>
<v t="ekr.20240308084832.29"><vh>function: short_id_from_name</vh></v>
<v t="ekr.20240308084832.30"><vh>function: bitmap_name</vh></v>
</v>
<v t="ekr.20240308084832.31"><vh>crash.py</vh>
<v t="ekr.20240308084832.32"><vh>function: catch_errors</vh></v>
<v t="ekr.20240308084832.33"><vh>function: crash_report</vh></v>
</v>
<v t="ekr.20240308084832.34"><vh>errors.py</vh>
<v t="ekr.20240308084832.35"><vh>class Errors</vh>
<v t="ekr.20240308084832.36"><vh>Errors.__init__</vh></v>
<v t="ekr.20240308084832.37"><vh>Errors.error</vh></v>
<v t="ekr.20240308084832.38"><vh>Errors.note</vh></v>
<v t="ekr.20240308084832.39"><vh>Errors.warning</vh></v>
<v t="ekr.20240308084832.40"><vh>Errors.new_messages</vh></v>
<v t="ekr.20240308084832.41"><vh>Errors.flush_errors</vh></v>
</v>
</v>
<v t="ekr.20240308084832.42"><vh>namegen.py</vh>
<v t="ekr.20240308084832.43"><vh>class NameGenerator</vh>
<v t="ekr.20240308084832.44"><vh>NameGenerator.__init__</vh></v>
<v t="ekr.20240308084832.45"><vh>NameGenerator.private_name</vh></v>
</v>
<v t="ekr.20240308084832.46"><vh>function: exported_name</vh></v>
<v t="ekr.20240308084832.47"><vh>function: make_module_translation_map</vh></v>
<v t="ekr.20240308084832.48"><vh>function: candidate_suffixes</vh></v>
</v>
<v t="ekr.20240308084832.49"><vh>options.py</vh>
<v t="ekr.20240308084832.50"><vh>class CompilerOptions</vh>
<v t="ekr.20240308084832.51"><vh>CompilerOptions.__init__</vh></v>
</v>
</v>
<v t="ekr.20240308084832.52"><vh>rt_subtype.py</vh>
<v t="ekr.20240308084832.53"><vh>function: is_runtime_subtype</vh></v>
<v t="ekr.20240308084832.54"><vh>class RTSubtypeVisitor</vh>
<v t="ekr.20240308084832.55"><vh>RTSubtypeVisitor.__init__</vh></v>
<v t="ekr.20240308084832.56"><vh>RTSubtypeVisitor.visit_rinstance</vh></v>
<v t="ekr.20240308084832.57"><vh>RTSubtypeVisitor.visit_runion</vh></v>
<v t="ekr.20240308084832.58"><vh>RTSubtypeVisitor.visit_rprimitive</vh></v>
<v t="ekr.20240308084832.59"><vh>RTSubtypeVisitor.visit_rtuple</vh></v>
<v t="ekr.20240308084832.60"><vh>RTSubtypeVisitor.visit_rstruct</vh></v>
<v t="ekr.20240308084832.61"><vh>RTSubtypeVisitor.visit_rarray</vh></v>
<v t="ekr.20240308084832.62"><vh>RTSubtypeVisitor.visit_rvoid</vh></v>
</v>
</v>
<v t="ekr.20240308084832.63"><vh>sametype.py</vh>
<v t="ekr.20240308084832.64"><vh>function: is_same_type</vh></v>
<v t="ekr.20240308084832.65"><vh>function: is_same_signature</vh></v>
<v t="ekr.20240308084832.66"><vh>function: is_same_method_signature</vh></v>
<v t="ekr.20240308084832.67"><vh>class SameTypeVisitor</vh>
<v t="ekr.20240308084832.68"><vh>SameTypeVisitor.__init__</vh></v>
<v t="ekr.20240308084832.69"><vh>SameTypeVisitor.visit_rinstance</vh></v>
<v t="ekr.20240308084832.70"><vh>SameTypeVisitor.visit_runion</vh></v>
<v t="ekr.20240308084832.71"><vh>SameTypeVisitor.visit_rprimitive</vh></v>
<v t="ekr.20240308084832.72"><vh>SameTypeVisitor.visit_rtuple</vh></v>
<v t="ekr.20240308084832.73"><vh>SameTypeVisitor.visit_rstruct</vh></v>
<v t="ekr.20240308084832.74"><vh>SameTypeVisitor.visit_rarray</vh></v>
<v t="ekr.20240308084832.75"><vh>SameTypeVisitor.visit_rvoid</vh></v>
</v>
</v>
<v t="ekr.20240308084832.76"><vh>subtype.py</vh>
<v t="ekr.20240308084832.77"><vh>function: is_subtype</vh></v>
<v t="ekr.20240308084832.78"><vh>class SubtypeVisitor</vh>
<v t="ekr.20240308084832.79"><vh>SubtypeVisitor.__init__</vh></v>
<v t="ekr.20240308084832.80"><vh>SubtypeVisitor.visit_rinstance</vh></v>
<v t="ekr.20240308084832.81"><vh>SubtypeVisitor.visit_runion</vh></v>
<v t="ekr.20240308084832.82"><vh>SubtypeVisitor.visit_rprimitive</vh></v>
<v t="ekr.20240308084832.83"><vh>SubtypeVisitor.visit_rtuple</vh></v>
<v t="ekr.20240308084832.84"><vh>SubtypeVisitor.visit_rstruct</vh></v>
<v t="ekr.20240308084832.85"><vh>SubtypeVisitor.visit_rarray</vh></v>
<v t="ekr.20240308084832.86"><vh>SubtypeVisitor.visit_rvoid</vh></v>
</v>
</v>
</v>
<v t="ekr.20240308084832.87"><vh>analysis</vh>
<v t="ekr.20240308084832.88"><vh>analysis/__init__.py</vh></v>
<v t="ekr.20240308084832.89"><vh>analysis/attrdefined.py</vh>
<v t="ekr.20240308084832.90"><vh>function: analyze_always_defined_attrs</vh></v>
<v t="ekr.20240308084832.91"><vh>function: analyze_always_defined_attrs_in_class</vh></v>
<v t="ekr.20240308084832.92"><vh>function: find_always_defined_attributes</vh></v>
<v t="ekr.20240308084832.93"><vh>function: find_sometimes_defined_attributes</vh></v>
<v t="ekr.20240308084832.94"><vh>function: mark_attr_initialiation_ops</vh></v>
<v t="ekr.20240308084832.95"><vh>function: attributes_initialized_by_init_call</vh></v>
<v t="ekr.20240308084832.96"><vh>function: attributes_maybe_initialized_by_init_call</vh></v>
<v t="ekr.20240308084832.97"><vh>class AttributeMaybeDefinedVisitor</vh>
<v t="ekr.20240308084832.98"><vh>AttributeMaybeDefinedVisitor.__init__</vh></v>
<v t="ekr.20240308084832.99"><vh>AttributeMaybeDefinedVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.100"><vh>AttributeMaybeDefinedVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.101"><vh>AttributeMaybeDefinedVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.102"><vh>AttributeMaybeDefinedVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.103"><vh>AttributeMaybeDefinedVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.104"><vh>AttributeMaybeDefinedVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.105"><vh>AttributeMaybeDefinedVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.106"><vh>function: analyze_maybe_defined_attrs_in_init</vh></v>
<v t="ekr.20240308084832.107"><vh>class AttributeMaybeUndefinedVisitor</vh>
<v t="ekr.20240308084832.108"><vh>AttributeMaybeUndefinedVisitor.__init__</vh></v>
<v t="ekr.20240308084832.109"><vh>AttributeMaybeUndefinedVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.110"><vh>AttributeMaybeUndefinedVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.111"><vh>AttributeMaybeUndefinedVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.112"><vh>AttributeMaybeUndefinedVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.113"><vh>AttributeMaybeUndefinedVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.114"><vh>AttributeMaybeUndefinedVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.115"><vh>AttributeMaybeUndefinedVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.116"><vh>function: analyze_maybe_undefined_attrs_in_init</vh></v>
<v t="ekr.20240308084832.117"><vh>function: update_always_defined_attrs_using_subclasses</vh></v>
<v t="ekr.20240308084832.118"><vh>function: detect_undefined_bitmap</vh></v>
</v>
<v t="ekr.20240308084832.119"><vh>analysis/blockfreq.py</vh>
<v t="ekr.20240308084832.120"><vh>function: frequently_executed_blocks</vh></v>
</v>
<v t="ekr.20240308084832.121"><vh>analysis/dataflow.py</vh>
<v t="ekr.20240308084832.122"><vh>class CFG</vh>
<v t="ekr.20240308084832.123"><vh>CFG.__init__</vh></v>
<v t="ekr.20240308084832.124"><vh>CFG.__str__</vh></v>
</v>
<v t="ekr.20240308084832.125"><vh>function: get_cfg</vh></v>
<v t="ekr.20240308084832.126"><vh>function: get_real_target</vh></v>
<v t="ekr.20240308084832.127"><vh>function: cleanup_cfg</vh></v>
<v t="ekr.20240308084832.128"><vh>class AnalysisResult</vh>
<v t="ekr.20240308084832.129"><vh>AnalysisResult.__init__</vh></v>
<v t="ekr.20240308084832.130"><vh>AnalysisResult.__str__</vh></v>
</v>
<v t="ekr.20240308084832.131"><vh>class BaseAnalysisVisitor</vh>
<v t="ekr.20240308084832.132"><vh>BaseAnalysisVisitor.visit_goto</vh></v>
<v t="ekr.20240308084832.133"><vh>BaseAnalysisVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.134"><vh>BaseAnalysisVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.135"><vh>BaseAnalysisVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.136"><vh>BaseAnalysisVisitor.visit_set_mem</vh></v>
<v t="ekr.20240308084832.137"><vh>BaseAnalysisVisitor.visit_call</vh></v>
<v t="ekr.20240308084832.138"><vh>BaseAnalysisVisitor.visit_method_call</vh></v>
<v t="ekr.20240308084832.139"><vh>BaseAnalysisVisitor.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.140"><vh>BaseAnalysisVisitor.visit_load_literal</vh></v>
<v t="ekr.20240308084832.141"><vh>BaseAnalysisVisitor.visit_get_attr</vh></v>
<v t="ekr.20240308084832.142"><vh>BaseAnalysisVisitor.visit_set_attr</vh></v>
<v t="ekr.20240308084832.143"><vh>BaseAnalysisVisitor.visit_load_static</vh></v>
<v t="ekr.20240308084832.144"><vh>BaseAnalysisVisitor.visit_init_static</vh></v>
<v t="ekr.20240308084832.145"><vh>BaseAnalysisVisitor.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.146"><vh>BaseAnalysisVisitor.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.147"><vh>BaseAnalysisVisitor.visit_box</vh></v>
<v t="ekr.20240308084832.148"><vh>BaseAnalysisVisitor.visit_unbox</vh></v>
<v t="ekr.20240308084832.149"><vh>BaseAnalysisVisitor.visit_cast</vh></v>
<v t="ekr.20240308084832.150"><vh>BaseAnalysisVisitor.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.151"><vh>BaseAnalysisVisitor.visit_call_c</vh></v>
<v t="ekr.20240308084832.152"><vh>BaseAnalysisVisitor.visit_truncate</vh></v>
<v t="ekr.20240308084832.153"><vh>BaseAnalysisVisitor.visit_extend</vh></v>
<v t="ekr.20240308084832.154"><vh>BaseAnalysisVisitor.visit_load_global</vh></v>
<v t="ekr.20240308084832.155"><vh>BaseAnalysisVisitor.visit_int_op</vh></v>
<v t="ekr.20240308084832.156"><vh>BaseAnalysisVisitor.visit_float_op</vh></v>
<v t="ekr.20240308084832.157"><vh>BaseAnalysisVisitor.visit_float_neg</vh></v>
<v t="ekr.20240308084832.158"><vh>BaseAnalysisVisitor.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.159"><vh>BaseAnalysisVisitor.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.160"><vh>BaseAnalysisVisitor.visit_load_mem</vh></v>
<v t="ekr.20240308084832.161"><vh>BaseAnalysisVisitor.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.162"><vh>BaseAnalysisVisitor.visit_load_address</vh></v>
<v t="ekr.20240308084832.163"><vh>BaseAnalysisVisitor.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.164"><vh>BaseAnalysisVisitor.visit_unborrow</vh></v>
</v>
<v t="ekr.20240308084832.165"><vh>class DefinedVisitor</vh>
<v t="ekr.20240308084832.166"><vh>DefinedVisitor.__init__</vh></v>
<v t="ekr.20240308084832.167"><vh>DefinedVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.168"><vh>DefinedVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.169"><vh>DefinedVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.170"><vh>DefinedVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.171"><vh>DefinedVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.172"><vh>DefinedVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.173"><vh>DefinedVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.174"><vh>function: analyze_maybe_defined_regs</vh></v>
<v t="ekr.20240308084832.175"><vh>function: analyze_must_defined_regs</vh></v>
<v t="ekr.20240308084832.176"><vh>class BorrowedArgumentsVisitor</vh>
<v t="ekr.20240308084832.177"><vh>BorrowedArgumentsVisitor.__init__</vh></v>
<v t="ekr.20240308084832.178"><vh>BorrowedArgumentsVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.179"><vh>BorrowedArgumentsVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.180"><vh>BorrowedArgumentsVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.181"><vh>BorrowedArgumentsVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.182"><vh>BorrowedArgumentsVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.183"><vh>BorrowedArgumentsVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.184"><vh>BorrowedArgumentsVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.185"><vh>function: analyze_borrowed_arguments</vh></v>
<v t="ekr.20240308084832.186"><vh>class UndefinedVisitor</vh>
<v t="ekr.20240308084832.187"><vh>UndefinedVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.188"><vh>UndefinedVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.189"><vh>UndefinedVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.190"><vh>UndefinedVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.191"><vh>UndefinedVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.192"><vh>UndefinedVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.193"><vh>UndefinedVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.194"><vh>function: analyze_undefined_regs</vh></v>
<v t="ekr.20240308084832.195"><vh>function: non_trivial_sources</vh></v>
<v t="ekr.20240308084832.196"><vh>class LivenessVisitor</vh>
<v t="ekr.20240308084832.197"><vh>LivenessVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.198"><vh>LivenessVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.199"><vh>LivenessVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.200"><vh>LivenessVisitor.visit_register_op</vh></v>
<v t="ekr.20240308084832.201"><vh>LivenessVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.202"><vh>LivenessVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.203"><vh>LivenessVisitor.visit_set_mem</vh></v>
</v>
<v t="ekr.20240308084832.204"><vh>function: analyze_live_regs</vh></v>
<v t="ekr.20240308084832.205"><vh>function: run_analysis</vh></v>
</v>
<v t="ekr.20240308084832.206"><vh>analysis/ircheck.py</vh>
<v t="ekr.20240308084832.207"><vh>class FnError</vh>
<v t="ekr.20240308084832.208"><vh>FnError.__init__</vh></v>
<v t="ekr.20240308084832.209"><vh>FnError.__eq__</vh></v>
<v t="ekr.20240308084832.210"><vh>FnError.__repr__</vh></v>
</v>
<v t="ekr.20240308084832.211"><vh>function: check_func_ir</vh></v>
<v t="ekr.20240308084832.212"><vh>class IrCheckException</vh></v>
<v t="ekr.20240308084832.213"><vh>function: assert_func_ir_valid</vh></v>
<v t="ekr.20240308084832.214"><vh>function: check_op_sources_valid</vh></v>
<v t="ekr.20240308084832.215"><vh>function: can_coerce_to</vh></v>
<v t="ekr.20240308084832.216"><vh>class OpChecker</vh>
<v t="ekr.20240308084832.217"><vh>OpChecker.__init__</vh></v>
<v t="ekr.20240308084832.218"><vh>OpChecker.fail</vh></v>
<v t="ekr.20240308084832.219"><vh>OpChecker.check_control_op_targets</vh></v>
<v t="ekr.20240308084832.220"><vh>OpChecker.check_type_coercion</vh></v>
<v t="ekr.20240308084832.221"><vh>OpChecker.check_compatibility</vh></v>
<v t="ekr.20240308084832.222"><vh>OpChecker.expect_float</vh></v>
<v t="ekr.20240308084832.223"><vh>OpChecker.expect_non_float</vh></v>
<v t="ekr.20240308084832.224"><vh>OpChecker.visit_goto</vh></v>
<v t="ekr.20240308084832.225"><vh>OpChecker.visit_branch</vh></v>
<v t="ekr.20240308084832.226"><vh>OpChecker.visit_return</vh></v>
<v t="ekr.20240308084832.227"><vh>OpChecker.visit_unreachable</vh></v>
<v t="ekr.20240308084832.228"><vh>OpChecker.visit_assign</vh></v>
<v t="ekr.20240308084832.229"><vh>OpChecker.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.230"><vh>OpChecker.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.231"><vh>OpChecker.check_tuple_items_valid_literals</vh></v>
<v t="ekr.20240308084832.232"><vh>OpChecker.check_frozenset_items_valid_literals</vh></v>
<v t="ekr.20240308084832.233"><vh>OpChecker.visit_load_literal</vh></v>
<v t="ekr.20240308084832.234"><vh>OpChecker.visit_get_attr</vh></v>
<v t="ekr.20240308084832.235"><vh>OpChecker.visit_set_attr</vh></v>
<v t="ekr.20240308084832.236"><vh>OpChecker.visit_load_static</vh></v>
<v t="ekr.20240308084832.237"><vh>OpChecker.visit_init_static</vh></v>
<v t="ekr.20240308084832.238"><vh>OpChecker.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.239"><vh>OpChecker.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.240"><vh>OpChecker.visit_inc_ref</vh></v>
<v t="ekr.20240308084832.241"><vh>OpChecker.visit_dec_ref</vh></v>
<v t="ekr.20240308084832.242"><vh>OpChecker.visit_call</vh></v>
<v t="ekr.20240308084832.243"><vh>OpChecker.visit_method_call</vh></v>
<v t="ekr.20240308084832.244"><vh>OpChecker.visit_cast</vh></v>
<v t="ekr.20240308084832.245"><vh>OpChecker.visit_box</vh></v>
<v t="ekr.20240308084832.246"><vh>OpChecker.visit_unbox</vh></v>
<v t="ekr.20240308084832.247"><vh>OpChecker.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.248"><vh>OpChecker.visit_call_c</vh></v>
<v t="ekr.20240308084832.249"><vh>OpChecker.visit_truncate</vh></v>
<v t="ekr.20240308084832.250"><vh>OpChecker.visit_extend</vh></v>
<v t="ekr.20240308084832.251"><vh>OpChecker.visit_load_global</vh></v>
<v t="ekr.20240308084832.252"><vh>OpChecker.visit_int_op</vh></v>
<v t="ekr.20240308084832.253"><vh>OpChecker.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.254"><vh>OpChecker.visit_float_op</vh></v>
<v t="ekr.20240308084832.255"><vh>OpChecker.visit_float_neg</vh></v>
<v t="ekr.20240308084832.256"><vh>OpChecker.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.257"><vh>OpChecker.visit_load_mem</vh></v>
<v t="ekr.20240308084832.258"><vh>OpChecker.visit_set_mem</vh></v>
<v t="ekr.20240308084832.259"><vh>OpChecker.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.260"><vh>OpChecker.visit_load_address</vh></v>
<v t="ekr.20240308084832.261"><vh>OpChecker.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.262"><vh>OpChecker.visit_unborrow</vh></v>
</v>
</v>
<v t="ekr.20240308084832.263"><vh>analysis/selfleaks.py</vh>
<v t="ekr.20240308084832.264"><vh>class SelfLeakedVisitor</vh>
<v t="ekr.20240308084832.265"><vh>SelfLeakedVisitor.__init__</vh></v>
<v t="ekr.20240308084832.266"><vh>SelfLeakedVisitor.visit_goto</vh></v>
<v t="ekr.20240308084832.267"><vh>SelfLeakedVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.268"><vh>SelfLeakedVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.269"><vh>SelfLeakedVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.270"><vh>SelfLeakedVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.271"><vh>SelfLeakedVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.272"><vh>SelfLeakedVisitor.visit_set_mem</vh></v>
<v t="ekr.20240308084832.273"><vh>SelfLeakedVisitor.visit_call</vh></v>
<v t="ekr.20240308084832.274"><vh>SelfLeakedVisitor.visit_method_call</vh></v>
<v t="ekr.20240308084832.275"><vh>SelfLeakedVisitor.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.276"><vh>SelfLeakedVisitor.visit_load_literal</vh></v>
<v t="ekr.20240308084832.277"><vh>SelfLeakedVisitor.visit_get_attr</vh></v>
<v t="ekr.20240308084832.278"><vh>SelfLeakedVisitor.visit_set_attr</vh></v>
<v t="ekr.20240308084832.279"><vh>SelfLeakedVisitor.visit_load_static</vh></v>
<v t="ekr.20240308084832.280"><vh>SelfLeakedVisitor.visit_init_static</vh></v>
<v t="ekr.20240308084832.281"><vh>SelfLeakedVisitor.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.282"><vh>SelfLeakedVisitor.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.283"><vh>SelfLeakedVisitor.visit_box</vh></v>
<v t="ekr.20240308084832.284"><vh>SelfLeakedVisitor.visit_unbox</vh></v>
<v t="ekr.20240308084832.285"><vh>SelfLeakedVisitor.visit_cast</vh></v>
<v t="ekr.20240308084832.286"><vh>SelfLeakedVisitor.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.287"><vh>SelfLeakedVisitor.visit_call_c</vh></v>
<v t="ekr.20240308084832.288"><vh>SelfLeakedVisitor.visit_truncate</vh></v>
<v t="ekr.20240308084832.289"><vh>SelfLeakedVisitor.visit_extend</vh></v>
<v t="ekr.20240308084832.290"><vh>SelfLeakedVisitor.visit_load_global</vh></v>
<v t="ekr.20240308084832.291"><vh>SelfLeakedVisitor.visit_int_op</vh></v>
<v t="ekr.20240308084832.292"><vh>SelfLeakedVisitor.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.293"><vh>SelfLeakedVisitor.visit_float_op</vh></v>
<v t="ekr.20240308084832.294"><vh>SelfLeakedVisitor.visit_float_neg</vh></v>
<v t="ekr.20240308084832.295"><vh>SelfLeakedVisitor.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.296"><vh>SelfLeakedVisitor.visit_load_mem</vh></v>
<v t="ekr.20240308084832.297"><vh>SelfLeakedVisitor.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.298"><vh>SelfLeakedVisitor.visit_load_address</vh></v>
<v t="ekr.20240308084832.299"><vh>SelfLeakedVisitor.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.300"><vh>SelfLeakedVisitor.visit_unborrow</vh></v>
<v t="ekr.20240308084832.301"><vh>SelfLeakedVisitor.check_register_op</vh></v>
</v>
<v t="ekr.20240308084832.302"><vh>function: analyze_self_leaks</vh></v>
</v>
</v>
<v t="ekr.20240308084832.303"><vh>codegen</vh>
<v t="ekr.20240308084832.304"><vh>codegen/__init__.py</vh></v>
<v t="ekr.20240308084832.305"><vh>codegen/cstring.py</vh>
<v t="ekr.20240308084832.306"><vh>function: encode_bytes_as_c_string</vh></v>
<v t="ekr.20240308084832.307"><vh>function: c_string_initializer</vh></v>
</v>
<v t="ekr.20240308084832.308"><vh>codegen/emit.py</vh>
<v t="ekr.20240308084832.309"><vh>class HeaderDeclaration</vh>
<v t="ekr.20240308084832.310"><vh>HeaderDeclaration.__init__</vh></v>
</v>
<v t="ekr.20240308084832.311"><vh>class EmitterContext</vh>
<v t="ekr.20240308084832.312"><vh>EmitterContext.__init__</vh></v>
</v>
<v t="ekr.20240308084832.313"><vh>class ErrorHandler</vh></v>
<v t="ekr.20240308084832.314"><vh>class AssignHandler</vh></v>
<v t="ekr.20240308084832.315"><vh>class GotoHandler</vh>
<v t="ekr.20240308084832.316"><vh>GotoHandler.__init__</vh></v>
</v>
<v t="ekr.20240308084832.317"><vh>class TracebackAndGotoHandler</vh>
<v t="ekr.20240308084832.318"><vh>TracebackAndGotoHandler.__init__</vh></v>
</v>
<v t="ekr.20240308084832.319"><vh>class ReturnHandler</vh>
<v t="ekr.20240308084832.320"><vh>ReturnHandler.__init__</vh></v>
</v>
<v t="ekr.20240308084832.321"><vh>class Emitter</vh>
<v t="ekr.20240308084832.322"><vh>Emitter.__init__</vh></v>
<v t="ekr.20240308084832.323"><vh>Emitter.indent</vh></v>
<v t="ekr.20240308084832.324"><vh>Emitter.dedent</vh></v>
<v t="ekr.20240308084832.325"><vh>Emitter.label</vh></v>
<v t="ekr.20240308084832.326"><vh>Emitter.reg</vh></v>
<v t="ekr.20240308084832.327"><vh>Emitter.attr</vh></v>
<v t="ekr.20240308084832.328"><vh>Emitter.object_annotation</vh></v>
<v t="ekr.20240308084832.329"><vh>Emitter.emit_line</vh></v>
<v t="ekr.20240308084832.330"><vh>Emitter.emit_lines</vh></v>
<v t="ekr.20240308084832.331"><vh>Emitter.emit_label</vh></v>
<v t="ekr.20240308084832.332"><vh>Emitter.emit_from_emitter</vh></v>
<v t="ekr.20240308084832.333"><vh>Emitter.emit_printf</vh></v>
<v t="ekr.20240308084832.334"><vh>Emitter.temp_name</vh></v>
<v t="ekr.20240308084832.335"><vh>Emitter.new_label</vh></v>
<v t="ekr.20240308084832.336"><vh>Emitter.get_module_group_prefix</vh></v>
<v t="ekr.20240308084832.337"><vh>Emitter.get_group_prefix</vh></v>
<v t="ekr.20240308084832.338"><vh>Emitter.static_name</vh></v>
<v t="ekr.20240308084832.339"><vh>Emitter.type_struct_name</vh></v>
<v t="ekr.20240308084832.340"><vh>Emitter.ctype</vh></v>
<v t="ekr.20240308084832.341"><vh>Emitter.ctype_spaced</vh></v>
<v t="ekr.20240308084832.342"><vh>Emitter.c_undefined_value</vh></v>
<v t="ekr.20240308084832.343"><vh>Emitter.c_error_value</vh></v>
<v t="ekr.20240308084832.344"><vh>Emitter.native_function_name</vh></v>
<v t="ekr.20240308084832.345"><vh>Emitter.tuple_c_declaration</vh></v>
<v t="ekr.20240308084832.346"><vh>Emitter.bitmap_field</vh></v>
<v t="ekr.20240308084832.347"><vh>Emitter.attr_bitmap_expr</vh></v>
<v t="ekr.20240308084832.348"><vh>Emitter.emit_attr_bitmap_set</vh></v>
<v t="ekr.20240308084832.349"><vh>Emitter.emit_attr_bitmap_clear</vh></v>
<v t="ekr.20240308084832.350"><vh>Emitter._emit_attr_bitmap_update</vh></v>
<v t="ekr.20240308084832.351"><vh>Emitter.use_vectorcall</vh></v>
<v t="ekr.20240308084832.352"><vh>Emitter.emit_undefined_attr_check</vh></v>
<v t="ekr.20240308084832.353"><vh>Emitter.error_value_check</vh></v>
<v t="ekr.20240308084832.354"><vh>Emitter.tuple_undefined_check_cond</vh></v>
<v t="ekr.20240308084832.355"><vh>Emitter.tuple_undefined_value</vh></v>
<v t="ekr.20240308084832.356"><vh>Emitter.c_initializer_undefined_value</vh></v>
<v t="ekr.20240308084832.357"><vh>Emitter.declare_tuple_struct</vh></v>
<v t="ekr.20240308084832.358"><vh>Emitter.emit_inc_ref</vh></v>
<v t="ekr.20240308084832.359"><vh>Emitter.emit_dec_ref</vh></v>
<v t="ekr.20240308084832.360"><vh>Emitter.pretty_name</vh></v>
<v t="ekr.20240308084832.361"><vh>Emitter.emit_cast</vh></v>
<v t="ekr.20240308084832.362"><vh>Emitter.emit_cast_error_handler</vh></v>
<v t="ekr.20240308084832.363"><vh>Emitter.emit_union_cast</vh></v>
<v t="ekr.20240308084832.364"><vh>Emitter.emit_tuple_cast</vh></v>
<v t="ekr.20240308084832.365"><vh>Emitter.emit_arg_check</vh></v>
<v t="ekr.20240308084832.366"><vh>Emitter.emit_unbox</vh></v>
<v t="ekr.20240308084832.367"><vh>Emitter.emit_box</vh></v>
<v t="ekr.20240308084832.368"><vh>Emitter.emit_error_check</vh></v>
<v t="ekr.20240308084832.369"><vh>Emitter.emit_gc_visit</vh></v>
<v t="ekr.20240308084832.370"><vh>Emitter.emit_gc_clear</vh></v>
<v t="ekr.20240308084832.371"><vh>Emitter.emit_traceback</vh></v>
<v t="ekr.20240308084832.372"><vh>Emitter.emit_type_error_traceback</vh></v>
<v t="ekr.20240308084832.373"><vh>Emitter._emit_traceback</vh></v>
<v t="ekr.20240308084832.374"><vh>Emitter.emit_unbox_failure_with_overlapping_error_value</vh></v>
</v>
<v t="ekr.20240308084832.375"><vh>function: c_array_initializer</vh></v>
</v>
<v t="ekr.20240308084832.376"><vh>codegen/emitclass.py</vh>
<v t="ekr.20240308084832.377"><vh>function: native_slot</vh></v>
<v t="ekr.20240308084832.378"><vh>function: wrapper_slot</vh></v>
<v t="ekr.20240308084832.379"><vh>function: generate_call_wrapper</vh></v>
<v t="ekr.20240308084832.380"><vh>function: slot_key</vh></v>
<v t="ekr.20240308084832.381"><vh>function: generate_slots</vh></v>
<v t="ekr.20240308084832.382"><vh>function: generate_class_type_decl</vh></v>
<v t="ekr.20240308084832.383"><vh>function: generate_class</vh></v>
<v t="ekr.20240308084832.384"><vh>function: getter_name</vh></v>
<v t="ekr.20240308084832.385"><vh>function: setter_name</vh></v>
<v t="ekr.20240308084832.386"><vh>function: generate_object_struct</vh></v>
<v t="ekr.20240308084832.387"><vh>function: generate_vtables</vh></v>
<v t="ekr.20240308084832.388"><vh>function: generate_offset_table</vh></v>
<v t="ekr.20240308084832.389"><vh>function: generate_vtable</vh></v>
<v t="ekr.20240308084832.390"><vh>function: generate_setup_for_class</vh></v>
<v t="ekr.20240308084832.391"><vh>function: generate_constructor_for_class</vh></v>
<v t="ekr.20240308084832.392"><vh>function: generate_init_for_class</vh></v>
<v t="ekr.20240308084832.393"><vh>function: generate_new_for_class</vh></v>
<v t="ekr.20240308084832.394"><vh>function: generate_new_for_trait</vh></v>
<v t="ekr.20240308084832.395"><vh>function: generate_traverse_for_class</vh></v>
<v t="ekr.20240308084832.396"><vh>function: generate_clear_for_class</vh></v>
<v t="ekr.20240308084832.397"><vh>function: generate_dealloc_for_class</vh></v>
<v t="ekr.20240308084832.398"><vh>function: generate_methods_table</vh></v>
<v t="ekr.20240308084832.399"><vh>function: generate_side_table_for_class</vh></v>
<v t="ekr.20240308084832.400"><vh>function: generate_getseter_declarations</vh></v>
<v t="ekr.20240308084832.401"><vh>function: generate_getseters_table</vh></v>
<v t="ekr.20240308084832.402"><vh>function: generate_getseters</vh></v>
<v t="ekr.20240308084832.403"><vh>function: generate_getter</vh></v>
<v t="ekr.20240308084832.404"><vh>function: generate_setter</vh></v>
<v t="ekr.20240308084832.405"><vh>function: generate_readonly_getter</vh></v>
<v t="ekr.20240308084832.406"><vh>function: generate_property_setter</vh></v>
<v t="ekr.20240308084832.407"><vh>function: has_managed_dict</vh></v>
</v>
<v t="ekr.20240308084832.408"><vh>codegen/emitfunc.py</vh>
<v t="ekr.20240308084832.409"><vh>function: native_function_type</vh></v>
<v t="ekr.20240308084832.410"><vh>function: native_function_header</vh></v>
<v t="ekr.20240308084832.411"><vh>function: generate_native_function</vh></v>
<v t="ekr.20240308084832.412"><vh>class FunctionEmitterVisitor</vh>
<v t="ekr.20240308084832.413"><vh>FunctionEmitterVisitor.__init__</vh></v>
<v t="ekr.20240308084832.414"><vh>FunctionEmitterVisitor.temp_name</vh></v>
<v t="ekr.20240308084832.415"><vh>FunctionEmitterVisitor.visit_goto</vh></v>
<v t="ekr.20240308084832.416"><vh>FunctionEmitterVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.417"><vh>FunctionEmitterVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.418"><vh>FunctionEmitterVisitor.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.419"><vh>FunctionEmitterVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.420"><vh>FunctionEmitterVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.421"><vh>FunctionEmitterVisitor.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.422"><vh>FunctionEmitterVisitor.visit_load_literal</vh></v>
<v t="ekr.20240308084832.423"><vh>FunctionEmitterVisitor.get_attr_expr</vh></v>
<v t="ekr.20240308084832.424"><vh>FunctionEmitterVisitor.visit_get_attr</vh></v>
<v t="ekr.20240308084832.425"><vh>FunctionEmitterVisitor.next_branch</vh></v>
<v t="ekr.20240308084832.426"><vh>FunctionEmitterVisitor.visit_set_attr</vh></v>
<v t="ekr.20240308084832.427"><vh>FunctionEmitterVisitor.visit_load_static</vh></v>
<v t="ekr.20240308084832.428"><vh>FunctionEmitterVisitor.visit_init_static</vh></v>
<v t="ekr.20240308084832.429"><vh>FunctionEmitterVisitor.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.430"><vh>FunctionEmitterVisitor.get_dest_assign</vh></v>
<v t="ekr.20240308084832.431"><vh>FunctionEmitterVisitor.visit_call</vh></v>
<v t="ekr.20240308084832.432"><vh>FunctionEmitterVisitor.visit_method_call</vh></v>
<v t="ekr.20240308084832.433"><vh>FunctionEmitterVisitor.visit_inc_ref</vh></v>
<v t="ekr.20240308084832.434"><vh>FunctionEmitterVisitor.visit_dec_ref</vh></v>
<v t="ekr.20240308084832.435"><vh>FunctionEmitterVisitor.visit_box</vh></v>
<v t="ekr.20240308084832.436"><vh>FunctionEmitterVisitor.visit_cast</vh></v>
<v t="ekr.20240308084832.437"><vh>FunctionEmitterVisitor.visit_unbox</vh></v>
<v t="ekr.20240308084832.438"><vh>FunctionEmitterVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.439"><vh>FunctionEmitterVisitor.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.440"><vh>FunctionEmitterVisitor.visit_call_c</vh></v>
<v t="ekr.20240308084832.441"><vh>FunctionEmitterVisitor.visit_truncate</vh></v>
<v t="ekr.20240308084832.442"><vh>FunctionEmitterVisitor.visit_extend</vh></v>
<v t="ekr.20240308084832.443"><vh>FunctionEmitterVisitor.visit_load_global</vh></v>
<v t="ekr.20240308084832.444"><vh>FunctionEmitterVisitor.visit_int_op</vh></v>
<v t="ekr.20240308084832.445"><vh>FunctionEmitterVisitor.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.446"><vh>FunctionEmitterVisitor.visit_float_op</vh></v>
<v t="ekr.20240308084832.447"><vh>FunctionEmitterVisitor.visit_float_neg</vh></v>
<v t="ekr.20240308084832.448"><vh>FunctionEmitterVisitor.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.449"><vh>FunctionEmitterVisitor.visit_load_mem</vh></v>
<v t="ekr.20240308084832.450"><vh>FunctionEmitterVisitor.visit_set_mem</vh></v>
<v t="ekr.20240308084832.451"><vh>FunctionEmitterVisitor.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.452"><vh>FunctionEmitterVisitor.visit_load_address</vh></v>
<v t="ekr.20240308084832.453"><vh>FunctionEmitterVisitor.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.454"><vh>FunctionEmitterVisitor.visit_unborrow</vh></v>
<v t="ekr.20240308084832.455"><vh>FunctionEmitterVisitor.label</vh></v>
<v t="ekr.20240308084832.456"><vh>FunctionEmitterVisitor.reg</vh></v>
<v t="ekr.20240308084832.457"><vh>FunctionEmitterVisitor.ctype</vh></v>
<v t="ekr.20240308084832.458"><vh>FunctionEmitterVisitor.c_error_value</vh></v>
<v t="ekr.20240308084832.459"><vh>FunctionEmitterVisitor.c_undefined_value</vh></v>
<v t="ekr.20240308084832.460"><vh>FunctionEmitterVisitor.emit_line</vh></v>
<v t="ekr.20240308084832.461"><vh>FunctionEmitterVisitor.emit_lines</vh></v>
<v t="ekr.20240308084832.462"><vh>FunctionEmitterVisitor.emit_inc_ref</vh></v>
<v t="ekr.20240308084832.463"><vh>FunctionEmitterVisitor.emit_dec_ref</vh></v>
<v t="ekr.20240308084832.464"><vh>FunctionEmitterVisitor.emit_declaration</vh></v>
<v t="ekr.20240308084832.465"><vh>FunctionEmitterVisitor.emit_traceback</vh></v>
<v t="ekr.20240308084832.466"><vh>FunctionEmitterVisitor.emit_attribute_error</vh></v>
<v t="ekr.20240308084832.467"><vh>FunctionEmitterVisitor.emit_signed_int_cast</vh></v>
<v t="ekr.20240308084832.468"><vh>FunctionEmitterVisitor.emit_unsigned_int_cast</vh></v>
</v>
</v>
<v t="ekr.20240308084832.469"><vh>codegen/emitmodule.py</vh>
<v t="ekr.20240308084832.470"><vh>class MarkedDeclaration</vh>
<v t="ekr.20240308084832.471"><vh>MarkedDeclaration.__init__</vh></v>
</v>
<v t="ekr.20240308084832.472"><vh>class MypycPlugin</vh>
<v t="ekr.20240308084832.473"><vh>MypycPlugin.__init__</vh></v>
<v t="ekr.20240308084832.474"><vh>MypycPlugin.report_config_data</vh></v>
<v t="ekr.20240308084832.475"><vh>MypycPlugin.get_additional_deps</vh></v>
</v>
<v t="ekr.20240308084832.476"><vh>function: parse_and_typecheck</vh></v>
<v t="ekr.20240308084832.477"><vh>function: compile_scc_to_ir</vh></v>
<v t="ekr.20240308084832.478"><vh>function: compile_modules_to_ir</vh></v>
<v t="ekr.20240308084832.479"><vh>function: compile_ir_to_c</vh></v>
<v t="ekr.20240308084832.480"><vh>function: get_ir_cache_name</vh></v>
<v t="ekr.20240308084832.481"><vh>function: get_state_ir_cache_name</vh></v>
<v t="ekr.20240308084832.482"><vh>function: write_cache</vh></v>
<v t="ekr.20240308084832.483"><vh>function: load_scc_from_cache</vh></v>
<v t="ekr.20240308084832.484"><vh>function: compile_modules_to_c</vh></v>
<v t="ekr.20240308084832.485"><vh>function: generate_function_declaration</vh></v>
<v t="ekr.20240308084832.486"><vh>function: pointerize</vh></v>
<v t="ekr.20240308084832.487"><vh>function: group_dir</vh></v>
<v t="ekr.20240308084832.488"><vh>class GroupGenerator</vh>
<v t="ekr.20240308084832.489"><vh>GroupGenerator.__init__</vh></v>
<v t="ekr.20240308084832.490"><vh>GroupGenerator.group_suffix</vh></v>
<v t="ekr.20240308084832.491"><vh>GroupGenerator.short_group_suffix</vh></v>
<v t="ekr.20240308084832.492"><vh>GroupGenerator.generate_c_for_modules</vh></v>
<v t="ekr.20240308084832.493"><vh>GroupGenerator.generate_literal_tables</vh></v>
<v t="ekr.20240308084832.494"><vh>GroupGenerator.generate_export_table</vh></v>
<v t="ekr.20240308084832.495"><vh>GroupGenerator.generate_shared_lib_init</vh></v>
<v t="ekr.20240308084832.496"><vh>GroupGenerator.generate_globals_init</vh></v>
<v t="ekr.20240308084832.497"><vh>GroupGenerator.generate_module_def</vh></v>
<v t="ekr.20240308084832.498"><vh>GroupGenerator.generate_top_level_call</vh></v>
<v t="ekr.20240308084832.499"><vh>GroupGenerator.toposort_declarations</vh></v>
<v t="ekr.20240308084832.500"><vh>GroupGenerator.declare_global</vh></v>
<v t="ekr.20240308084832.501"><vh>GroupGenerator.declare_internal_globals</vh></v>
<v t="ekr.20240308084832.502"><vh>GroupGenerator.module_internal_static_name</vh></v>
<v t="ekr.20240308084832.503"><vh>GroupGenerator.declare_module</vh></v>
<v t="ekr.20240308084832.504"><vh>GroupGenerator.declare_imports</vh></v>
<v t="ekr.20240308084832.505"><vh>GroupGenerator.declare_finals</vh></v>
<v t="ekr.20240308084832.506"><vh>GroupGenerator.final_definition</vh></v>
<v t="ekr.20240308084832.507"><vh>GroupGenerator.declare_static_pyobject</vh></v>
</v>
<v t="ekr.20240308084832.508"><vh>function: sort_classes</vh></v>
<v t="ekr.20240308084832.509"><vh>function: toposort</vh></v>
<v t="ekr.20240308084832.510"><vh>function: is_fastcall_supported</vh></v>
<v t="ekr.20240308084832.511"><vh>function: collect_literals</vh></v>
<v t="ekr.20240308084832.512"><vh>function: c_string_array_initializer</vh></v>
</v>
<v t="ekr.20240308084832.513"><vh>codegen/emitwrapper.py</vh>
<v t="ekr.20240308084832.514"><vh>function: wrapper_function_header</vh></v>
<v t="ekr.20240308084832.515"><vh>function: generate_traceback_code</vh></v>
<v t="ekr.20240308084832.516"><vh>function: make_arg_groups</vh></v>
<v t="ekr.20240308084832.517"><vh>function: reorder_arg_groups</vh></v>
<v t="ekr.20240308084832.518"><vh>function: make_static_kwlist</vh></v>
<v t="ekr.20240308084832.519"><vh>function: make_format_string</vh></v>
<v t="ekr.20240308084832.520"><vh>function: generate_wrapper_function</vh></v>
<v t="ekr.20240308084832.521"><vh>function: legacy_wrapper_function_header</vh></v>
<v t="ekr.20240308084832.522"><vh>function: generate_legacy_wrapper_function</vh></v>
<v t="ekr.20240308084832.523"><vh>function: generate_dunder_wrapper</vh></v>
<v t="ekr.20240308084832.524"><vh>function: generate_ipow_wrapper</vh></v>
<v t="ekr.20240308084832.525"><vh>function: generate_bin_op_wrapper</vh></v>
<v t="ekr.20240308084832.526"><vh>function: generate_bin_op_forward_only_wrapper</vh></v>
<v t="ekr.20240308084832.527"><vh>function: generate_bin_op_reverse_only_wrapper</vh></v>
<v t="ekr.20240308084832.528"><vh>function: generate_bin_op_both_wrappers</vh></v>
<v t="ekr.20240308084832.529"><vh>function: generate_bin_op_reverse_dunder_call</vh></v>
<v t="ekr.20240308084832.530"><vh>function: handle_third_pow_argument</vh></v>
<v t="ekr.20240308084832.531"><vh>function: generate_richcompare_wrapper</vh></v>
<v t="ekr.20240308084832.532"><vh>function: generate_get_wrapper</vh></v>
<v t="ekr.20240308084832.533"><vh>function: generate_hash_wrapper</vh></v>
<v t="ekr.20240308084832.534"><vh>function: generate_len_wrapper</vh></v>
<v t="ekr.20240308084832.535"><vh>function: generate_bool_wrapper</vh></v>
<v t="ekr.20240308084832.536"><vh>function: generate_del_item_wrapper</vh></v>
<v t="ekr.20240308084832.537"><vh>function: generate_set_del_item_wrapper</vh></v>
<v t="ekr.20240308084832.538"><vh>function: generate_set_del_item_wrapper_inner</vh></v>
<v t="ekr.20240308084832.539"><vh>function: generate_contains_wrapper</vh></v>
<v t="ekr.20240308084832.540"><vh>function: generate_wrapper_core</vh></v>
<v t="ekr.20240308084832.541"><vh>function: generate_arg_check</vh></v>
<v t="ekr.20240308084832.542"><vh>class WrapperGenerator</vh>
<v t="ekr.20240308084832.543"><vh>WrapperGenerator.__init__</vh></v>
<v t="ekr.20240308084832.544"><vh>WrapperGenerator.set_target</vh></v>
<v t="ekr.20240308084832.545"><vh>WrapperGenerator.wrapper_name</vh></v>
<v t="ekr.20240308084832.546"><vh>WrapperGenerator.use_goto</vh></v>
<v t="ekr.20240308084832.547"><vh>WrapperGenerator.emit_header</vh></v>
<v t="ekr.20240308084832.548"><vh>WrapperGenerator.emit_arg_processing</vh></v>
<v t="ekr.20240308084832.549"><vh>WrapperGenerator.emit_call</vh></v>
<v t="ekr.20240308084832.550"><vh>WrapperGenerator.error</vh></v>
<v t="ekr.20240308084832.551"><vh>WrapperGenerator.emit_error_handling</vh></v>
<v t="ekr.20240308084832.552"><vh>WrapperGenerator.finish</vh></v>
</v>
</v>
<v t="ekr.20240308084832.553"><vh>codegen/literals.py</vh>
<v t="ekr.20240308084832.554"><vh>function: _is_literal_value</vh></v>
<v t="ekr.20240308084832.555"><vh>class Literals</vh>
<v t="ekr.20240308084832.556"><vh>Literals.__init__</vh></v>
<v t="ekr.20240308084832.557"><vh>Literals.record_literal</vh></v>
<v t="ekr.20240308084832.558"><vh>Literals.literal_index</vh></v>
<v t="ekr.20240308084832.559"><vh>Literals.num_literals</vh></v>
<v t="ekr.20240308084832.560"><vh>Literals.encoded_str_values</vh></v>
<v t="ekr.20240308084832.561"><vh>Literals.encoded_int_values</vh></v>
<v t="ekr.20240308084832.562"><vh>Literals.encoded_bytes_values</vh></v>
<v t="ekr.20240308084832.563"><vh>Literals.encoded_float_values</vh></v>
<v t="ekr.20240308084832.564"><vh>Literals.encoded_complex_values</vh></v>
<v t="ekr.20240308084832.565"><vh>Literals.encoded_tuple_values</vh></v>
<v t="ekr.20240308084832.566"><vh>Literals.encoded_frozenset_values</vh></v>
<v t="ekr.20240308084832.567"><vh>Literals._encode_collection_values</vh></v>
</v>
<v t="ekr.20240308084832.568"><vh>function: _encode_str_values</vh></v>
<v t="ekr.20240308084832.569"><vh>function: _encode_bytes_values</vh></v>
<v t="ekr.20240308084832.570"><vh>function: format_int</vh></v>
<v t="ekr.20240308084832.571"><vh>function: format_str_literal</vh></v>
<v t="ekr.20240308084832.572"><vh>function: _encode_int_values</vh></v>
<v t="ekr.20240308084832.573"><vh>function: float_to_c</vh></v>
<v t="ekr.20240308084832.574"><vh>function: _encode_float_values</vh></v>
<v t="ekr.20240308084832.575"><vh>function: _encode_complex_values</vh></v>
</v>
</v>
<v t="ekr.20240308084832.576"><vh>doc</vh>
<v t="ekr.20240308084832.577"><vh>doc/conf.py</vh></v>
</v>
<v t="ekr.20240308084832.578"><vh>external</vh>
<v t="ekr.20240308084832.579"><vh>external/googletest</vh>
<v t="ekr.20240308084832.580"><vh>external/googletest/include</vh>
<v t="ekr.20240308084832.581"><vh>external/googletest/include/gtest</vh></v>
</v>
</v>
</v>
<v t="ekr.20240308084832.582"><vh>ir</vh>
<v t="ekr.20240308084832.583"><vh>ir/__init__.py</vh></v>
<v t="ekr.20240308084832.584"><vh>ir/class_ir.py</vh>
<v t="ekr.20240308084832.585"><vh>class VTableMethod</vh></v>
<v t="ekr.20240308084832.586"><vh>class ClassIR</vh>
<v t="ekr.20240308084832.587"><vh>ClassIR.__init__</vh></v>
<v t="ekr.20240308084832.588"><vh>ClassIR.__repr__</vh></v>
<v t="ekr.20240308084832.589"><vh>ClassIR.fullname</vh></v>
<v t="ekr.20240308084832.590"><vh>ClassIR.real_base</vh></v>
<v t="ekr.20240308084832.591"><vh>ClassIR.vtable_entry</vh></v>
<v t="ekr.20240308084832.592"><vh>ClassIR.attr_details</vh></v>
<v t="ekr.20240308084832.593"><vh>ClassIR.attr_type</vh></v>
<v t="ekr.20240308084832.594"><vh>ClassIR.method_decl</vh></v>
<v t="ekr.20240308084832.595"><vh>ClassIR.method_sig</vh></v>
<v t="ekr.20240308084832.596"><vh>ClassIR.has_method</vh></v>
<v t="ekr.20240308084832.597"><vh>ClassIR.is_method_final</vh></v>
<v t="ekr.20240308084832.598"><vh>ClassIR.has_attr</vh></v>
<v t="ekr.20240308084832.599"><vh>ClassIR.is_deletable</vh></v>
<v t="ekr.20240308084832.600"><vh>ClassIR.is_always_defined</vh></v>
<v t="ekr.20240308084832.601"><vh>ClassIR.name_prefix</vh></v>
<v t="ekr.20240308084832.602"><vh>ClassIR.struct_name</vh></v>
<v t="ekr.20240308084832.603"><vh>ClassIR.get_method_and_class</vh></v>
<v t="ekr.20240308084832.604"><vh>ClassIR.get_method</vh></v>
<v t="ekr.20240308084832.605"><vh>ClassIR.has_method_decl</vh></v>
<v t="ekr.20240308084832.606"><vh>ClassIR.has_no_subclasses</vh></v>
<v t="ekr.20240308084832.607"><vh>ClassIR.subclasses</vh></v>
<v t="ekr.20240308084832.608"><vh>ClassIR.concrete_subclasses</vh></v>
<v t="ekr.20240308084832.609"><vh>ClassIR.is_serializable</vh></v>
<v t="ekr.20240308084832.610"><vh>ClassIR.serialize</vh></v>
<v t="ekr.20240308084832.611"><vh>ClassIR.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.612"><vh>class NonExtClassInfo</vh>
<v t="ekr.20240308084832.613"><vh>NonExtClassInfo.__init__</vh></v>
</v>
<v t="ekr.20240308084832.614"><vh>function: serialize_vtable_entry</vh></v>
<v t="ekr.20240308084832.615"><vh>function: serialize_vtable</vh></v>
<v t="ekr.20240308084832.616"><vh>function: deserialize_vtable_entry</vh></v>
<v t="ekr.20240308084832.617"><vh>function: deserialize_vtable</vh></v>
<v t="ekr.20240308084832.618"><vh>function: all_concrete_classes</vh></v>
</v>
<v t="ekr.20240308084832.619"><vh>ir/func_ir.py</vh>
<v t="ekr.20240308084832.620"><vh>class RuntimeArg</vh>
<v t="ekr.20240308084832.621"><vh>RuntimeArg.__init__</vh></v>
<v t="ekr.20240308084832.622"><vh>RuntimeArg.optional</vh></v>
<v t="ekr.20240308084832.623"><vh>RuntimeArg.__repr__</vh></v>
<v t="ekr.20240308084832.624"><vh>RuntimeArg.serialize</vh></v>
<v t="ekr.20240308084832.625"><vh>RuntimeArg.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.626"><vh>class FuncSignature</vh>
<v t="ekr.20240308084832.627"><vh>FuncSignature.__init__</vh></v>
<v t="ekr.20240308084832.628"><vh>FuncSignature.real_args</vh></v>
<v t="ekr.20240308084832.629"><vh>FuncSignature.bound_sig</vh></v>
<v t="ekr.20240308084832.630"><vh>FuncSignature.__repr__</vh></v>
<v t="ekr.20240308084832.631"><vh>FuncSignature.serialize</vh></v>
<v t="ekr.20240308084832.632"><vh>FuncSignature.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.633"><vh>function: num_bitmap_args</vh></v>
<v t="ekr.20240308084832.634"><vh>class FuncDecl</vh>
<v t="ekr.20240308084832.635"><vh>FuncDecl.__init__</vh></v>
<v t="ekr.20240308084832.636"><vh>FuncDecl.line</vh></v>
<v t="ekr.20240308084832.637"><vh>FuncDecl.line</vh></v>
<v t="ekr.20240308084832.638"><vh>FuncDecl.id</vh></v>
<v t="ekr.20240308084832.639"><vh>FuncDecl.compute_shortname</vh></v>
<v t="ekr.20240308084832.640"><vh>FuncDecl.shortname</vh></v>
<v t="ekr.20240308084832.641"><vh>FuncDecl.fullname</vh></v>
<v t="ekr.20240308084832.642"><vh>FuncDecl.cname</vh></v>
<v t="ekr.20240308084832.643"><vh>FuncDecl.serialize</vh></v>
<v t="ekr.20240308084832.644"><vh>FuncDecl.get_id_from_json</vh></v>
<v t="ekr.20240308084832.645"><vh>FuncDecl.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.646"><vh>class FuncIR</vh>
<v t="ekr.20240308084832.647"><vh>FuncIR.__init__</vh></v>
<v t="ekr.20240308084832.648"><vh>FuncIR.line</vh></v>
<v t="ekr.20240308084832.649"><vh>FuncIR.args</vh></v>
<v t="ekr.20240308084832.650"><vh>FuncIR.ret_type</vh></v>
<v t="ekr.20240308084832.651"><vh>FuncIR.class_name</vh></v>
<v t="ekr.20240308084832.652"><vh>FuncIR.sig</vh></v>
<v t="ekr.20240308084832.653"><vh>FuncIR.name</vh></v>
<v t="ekr.20240308084832.654"><vh>FuncIR.fullname</vh></v>
<v t="ekr.20240308084832.655"><vh>FuncIR.id</vh></v>
<v t="ekr.20240308084832.656"><vh>FuncIR.cname</vh></v>
<v t="ekr.20240308084832.657"><vh>FuncIR.__repr__</vh></v>
<v t="ekr.20240308084832.658"><vh>FuncIR.serialize</vh></v>
<v t="ekr.20240308084832.659"><vh>FuncIR.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.660"><vh>function: all_values</vh></v>
<v t="ekr.20240308084832.661"><vh>function: all_values_full</vh></v>
</v>
<v t="ekr.20240308084832.662"><vh>ir/module_ir.py</vh>
<v t="ekr.20240308084832.663"><vh>class ModuleIR</vh>
<v t="ekr.20240308084832.664"><vh>ModuleIR.__init__</vh></v>
<v t="ekr.20240308084832.665"><vh>ModuleIR.serialize</vh></v>
<v t="ekr.20240308084832.666"><vh>ModuleIR.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.667"><vh>function: deserialize_modules</vh></v>
</v>
<v t="ekr.20240308084832.668"><vh>ir/ops.py</vh>
<v t="ekr.20240308084832.669"><vh>class BasicBlock</vh>
<v t="ekr.20240308084832.670"><vh>BasicBlock.__init__</vh></v>
<v t="ekr.20240308084832.671"><vh>BasicBlock.terminated</vh></v>
<v t="ekr.20240308084832.672"><vh>BasicBlock.terminator</vh></v>
</v>
<v t="ekr.20240308084832.673"><vh>class Value</vh>
<v t="ekr.20240308084832.674"><vh>Value.is_void</vh></v>
</v>
<v t="ekr.20240308084832.675"><vh>class Register</vh>
<v t="ekr.20240308084832.676"><vh>Register.__init__</vh></v>
<v t="ekr.20240308084832.677"><vh>Register.is_void</vh></v>
<v t="ekr.20240308084832.678"><vh>Register.__repr__</vh></v>
</v>
<v t="ekr.20240308084832.679"><vh>class Integer</vh>
<v t="ekr.20240308084832.680"><vh>Integer.__init__</vh></v>
<v t="ekr.20240308084832.681"><vh>Integer.numeric_value</vh></v>
</v>
<v t="ekr.20240308084832.682"><vh>class Float</vh>
<v t="ekr.20240308084832.683"><vh>Float.__init__</vh></v>
</v>
<v t="ekr.20240308084832.684"><vh>class Op</vh>
<v t="ekr.20240308084832.685"><vh>Op.__init__</vh></v>
<v t="ekr.20240308084832.686"><vh>Op.can_raise</vh></v>
<v t="ekr.20240308084832.687"><vh>Op.sources</vh></v>
<v t="ekr.20240308084832.688"><vh>Op.stolen</vh></v>
<v t="ekr.20240308084832.689"><vh>Op.unique_sources</vh></v>
<v t="ekr.20240308084832.690"><vh>Op.accept</vh></v>
</v>
<v t="ekr.20240308084832.691"><vh>class BaseAssign</vh>
<v t="ekr.20240308084832.692"><vh>BaseAssign.__init__</vh></v>
</v>
<v t="ekr.20240308084832.693"><vh>class Assign</vh>
<v t="ekr.20240308084832.694"><vh>Assign.__init__</vh></v>
<v t="ekr.20240308084832.695"><vh>Assign.sources</vh></v>
<v t="ekr.20240308084832.696"><vh>Assign.stolen</vh></v>
<v t="ekr.20240308084832.697"><vh>Assign.accept</vh></v>
</v>
<v t="ekr.20240308084832.698"><vh>class AssignMulti</vh>
<v t="ekr.20240308084832.699"><vh>AssignMulti.__init__</vh></v>
<v t="ekr.20240308084832.700"><vh>AssignMulti.sources</vh></v>
<v t="ekr.20240308084832.701"><vh>AssignMulti.stolen</vh></v>
<v t="ekr.20240308084832.702"><vh>AssignMulti.accept</vh></v>
</v>
<v t="ekr.20240308084832.703"><vh>class ControlOp</vh>
<v t="ekr.20240308084832.704"><vh>ControlOp.targets</vh></v>
<v t="ekr.20240308084832.705"><vh>ControlOp.set_target</vh></v>
</v>
<v t="ekr.20240308084832.706"><vh>class Goto</vh>
<v t="ekr.20240308084832.707"><vh>Goto.__init__</vh></v>
<v t="ekr.20240308084832.708"><vh>Goto.targets</vh></v>
<v t="ekr.20240308084832.709"><vh>Goto.set_target</vh></v>
<v t="ekr.20240308084832.710"><vh>Goto.__repr__</vh></v>
<v t="ekr.20240308084832.711"><vh>Goto.sources</vh></v>
<v t="ekr.20240308084832.712"><vh>Goto.accept</vh></v>
</v>
<v t="ekr.20240308084832.713"><vh>class Branch</vh>
<v t="ekr.20240308084832.714"><vh>Branch.__init__</vh></v>
<v t="ekr.20240308084832.715"><vh>Branch.targets</vh></v>
<v t="ekr.20240308084832.716"><vh>Branch.set_target</vh></v>
<v t="ekr.20240308084832.717"><vh>Branch.sources</vh></v>
<v t="ekr.20240308084832.718"><vh>Branch.invert</vh></v>
<v t="ekr.20240308084832.719"><vh>Branch.accept</vh></v>
</v>
<v t="ekr.20240308084832.720"><vh>class Return</vh>
<v t="ekr.20240308084832.721"><vh>Return.__init__</vh></v>
<v t="ekr.20240308084832.722"><vh>Return.sources</vh></v>
<v t="ekr.20240308084832.723"><vh>Return.stolen</vh></v>
<v t="ekr.20240308084832.724"><vh>Return.accept</vh></v>
</v>
<v t="ekr.20240308084832.725"><vh>class Unreachable</vh>
<v t="ekr.20240308084832.726"><vh>Unreachable.__init__</vh></v>
<v t="ekr.20240308084832.727"><vh>Unreachable.sources</vh></v>
<v t="ekr.20240308084832.728"><vh>Unreachable.accept</vh></v>
</v>
<v t="ekr.20240308084832.729"><vh>class RegisterOp</vh>
<v t="ekr.20240308084832.730"><vh>RegisterOp.__init__</vh></v>
<v t="ekr.20240308084832.731"><vh>RegisterOp.can_raise</vh></v>
</v>
<v t="ekr.20240308084832.732"><vh>class IncRef</vh>
<v t="ekr.20240308084832.733"><vh>IncRef.__init__</vh></v>
<v t="ekr.20240308084832.734"><vh>IncRef.sources</vh></v>
<v t="ekr.20240308084832.735"><vh>IncRef.accept</vh></v>
</v>
<v t="ekr.20240308084832.736"><vh>class DecRef</vh>
<v t="ekr.20240308084832.737"><vh>DecRef.__init__</vh></v>
<v t="ekr.20240308084832.738"><vh>DecRef.__repr__</vh></v>
<v t="ekr.20240308084832.739"><vh>DecRef.sources</vh></v>
<v t="ekr.20240308084832.740"><vh>DecRef.accept</vh></v>
</v>
<v t="ekr.20240308084832.741"><vh>class Call</vh>
<v t="ekr.20240308084832.742"><vh>Call.__init__</vh></v>
<v t="ekr.20240308084832.743"><vh>Call.sources</vh></v>
<v t="ekr.20240308084832.744"><vh>Call.accept</vh></v>
</v>
<v t="ekr.20240308084832.745"><vh>class MethodCall</vh>
<v t="ekr.20240308084832.746"><vh>MethodCall.__init__</vh></v>
<v t="ekr.20240308084832.747"><vh>MethodCall.sources</vh></v>
<v t="ekr.20240308084832.748"><vh>MethodCall.accept</vh></v>
</v>
<v t="ekr.20240308084832.749"><vh>class LoadErrorValue</vh>
<v t="ekr.20240308084832.750"><vh>LoadErrorValue.__init__</vh></v>
<v t="ekr.20240308084832.751"><vh>LoadErrorValue.sources</vh></v>
<v t="ekr.20240308084832.752"><vh>LoadErrorValue.accept</vh></v>
</v>
<v t="ekr.20240308084832.753"><vh>class LoadLiteral</vh>
<v t="ekr.20240308084832.754"><vh>LoadLiteral.__init__</vh></v>
<v t="ekr.20240308084832.755"><vh>LoadLiteral.sources</vh></v>
<v t="ekr.20240308084832.756"><vh>LoadLiteral.accept</vh></v>
</v>
<v t="ekr.20240308084832.757"><vh>class GetAttr</vh>
<v t="ekr.20240308084832.758"><vh>GetAttr.__init__</vh></v>
<v t="ekr.20240308084832.759"><vh>GetAttr.sources</vh></v>
<v t="ekr.20240308084832.760"><vh>GetAttr.accept</vh></v>
</v>
<v t="ekr.20240308084832.761"><vh>class SetAttr</vh>
<v t="ekr.20240308084832.762"><vh>SetAttr.__init__</vh></v>
<v t="ekr.20240308084832.763"><vh>SetAttr.mark_as_initializer</vh></v>
<v t="ekr.20240308084832.764"><vh>SetAttr.sources</vh></v>
<v t="ekr.20240308084832.765"><vh>SetAttr.stolen</vh></v>
<v t="ekr.20240308084832.766"><vh>SetAttr.accept</vh></v>
</v>
<v t="ekr.20240308084832.767"><vh>class LoadStatic</vh>
<v t="ekr.20240308084832.768"><vh>LoadStatic.__init__</vh></v>
<v t="ekr.20240308084832.769"><vh>LoadStatic.sources</vh></v>
<v t="ekr.20240308084832.770"><vh>LoadStatic.accept</vh></v>
</v>
<v t="ekr.20240308084832.771"><vh>class InitStatic</vh>
<v t="ekr.20240308084832.772"><vh>InitStatic.__init__</vh></v>
<v t="ekr.20240308084832.773"><vh>InitStatic.sources</vh></v>
<v t="ekr.20240308084832.774"><vh>InitStatic.accept</vh></v>
</v>
<v t="ekr.20240308084832.775"><vh>class TupleSet</vh>
<v t="ekr.20240308084832.776"><vh>TupleSet.__init__</vh></v>
<v t="ekr.20240308084832.777"><vh>TupleSet.sources</vh></v>
<v t="ekr.20240308084832.778"><vh>TupleSet.stolen</vh></v>
<v t="ekr.20240308084832.779"><vh>TupleSet.accept</vh></v>
</v>
<v t="ekr.20240308084832.780"><vh>class TupleGet</vh>
<v t="ekr.20240308084832.781"><vh>TupleGet.__init__</vh></v>
<v t="ekr.20240308084832.782"><vh>TupleGet.sources</vh></v>
<v t="ekr.20240308084832.783"><vh>TupleGet.accept</vh></v>
</v>
<v t="ekr.20240308084832.784"><vh>class Cast</vh>
<v t="ekr.20240308084832.785"><vh>Cast.__init__</vh></v>
<v t="ekr.20240308084832.786"><vh>Cast.sources</vh></v>
<v t="ekr.20240308084832.787"><vh>Cast.stolen</vh></v>
<v t="ekr.20240308084832.788"><vh>Cast.accept</vh></v>
</v>
<v t="ekr.20240308084832.789"><vh>class Box</vh>
<v t="ekr.20240308084832.790"><vh>Box.__init__</vh></v>
<v t="ekr.20240308084832.791"><vh>Box.sources</vh></v>
<v t="ekr.20240308084832.792"><vh>Box.stolen</vh></v>
<v t="ekr.20240308084832.793"><vh>Box.accept</vh></v>
</v>
<v t="ekr.20240308084832.794"><vh>class Unbox</vh>
<v t="ekr.20240308084832.795"><vh>Unbox.__init__</vh></v>
<v t="ekr.20240308084832.796"><vh>Unbox.sources</vh></v>
<v t="ekr.20240308084832.797"><vh>Unbox.accept</vh></v>
</v>
<v t="ekr.20240308084832.798"><vh>class RaiseStandardError</vh>
<v t="ekr.20240308084832.799"><vh>RaiseStandardError.__init__</vh></v>
<v t="ekr.20240308084832.800"><vh>RaiseStandardError.sources</vh></v>
<v t="ekr.20240308084832.801"><vh>RaiseStandardError.accept</vh></v>
</v>
<v t="ekr.20240308084832.802"><vh>class CallC</vh>
<v t="ekr.20240308084832.803"><vh>CallC.__init__</vh></v>
<v t="ekr.20240308084832.804"><vh>CallC.sources</vh></v>
<v t="ekr.20240308084832.805"><vh>CallC.stolen</vh></v>
<v t="ekr.20240308084832.806"><vh>CallC.accept</vh></v>
</v>
<v t="ekr.20240308084832.807"><vh>class Truncate</vh>
<v t="ekr.20240308084832.808"><vh>Truncate.__init__</vh></v>
<v t="ekr.20240308084832.809"><vh>Truncate.sources</vh></v>
<v t="ekr.20240308084832.810"><vh>Truncate.stolen</vh></v>
<v t="ekr.20240308084832.811"><vh>Truncate.accept</vh></v>
</v>
<v t="ekr.20240308084832.812"><vh>class Extend</vh>
<v t="ekr.20240308084832.813"><vh>Extend.__init__</vh></v>
<v t="ekr.20240308084832.814"><vh>Extend.sources</vh></v>
<v t="ekr.20240308084832.815"><vh>Extend.stolen</vh></v>
<v t="ekr.20240308084832.816"><vh>Extend.accept</vh></v>
</v>
<v t="ekr.20240308084832.817"><vh>class LoadGlobal</vh>
<v t="ekr.20240308084832.818"><vh>LoadGlobal.__init__</vh></v>
<v t="ekr.20240308084832.819"><vh>LoadGlobal.sources</vh></v>
<v t="ekr.20240308084832.820"><vh>LoadGlobal.accept</vh></v>
</v>
<v t="ekr.20240308084832.821"><vh>class IntOp</vh>
<v t="ekr.20240308084832.822"><vh>IntOp.__init__</vh></v>
<v t="ekr.20240308084832.823"><vh>IntOp.sources</vh></v>
<v t="ekr.20240308084832.824"><vh>IntOp.accept</vh></v>
</v>
<v t="ekr.20240308084832.825"><vh>class ComparisonOp</vh>
<v t="ekr.20240308084832.826"><vh>ComparisonOp.__init__</vh></v>
<v t="ekr.20240308084832.827"><vh>ComparisonOp.sources</vh></v>
<v t="ekr.20240308084832.828"><vh>ComparisonOp.accept</vh></v>
</v>
<v t="ekr.20240308084832.829"><vh>class FloatOp</vh>
<v t="ekr.20240308084832.830"><vh>FloatOp.__init__</vh></v>
<v t="ekr.20240308084832.831"><vh>FloatOp.sources</vh></v>
<v t="ekr.20240308084832.832"><vh>FloatOp.accept</vh></v>
</v>
<v t="ekr.20240308084832.833"><vh>class FloatNeg</vh>
<v t="ekr.20240308084832.834"><vh>FloatNeg.__init__</vh></v>
<v t="ekr.20240308084832.835"><vh>FloatNeg.sources</vh></v>
<v t="ekr.20240308084832.836"><vh>FloatNeg.accept</vh></v>
</v>
<v t="ekr.20240308084832.837"><vh>class FloatComparisonOp</vh>
<v t="ekr.20240308084832.838"><vh>FloatComparisonOp.__init__</vh></v>
<v t="ekr.20240308084832.839"><vh>FloatComparisonOp.sources</vh></v>
<v t="ekr.20240308084832.840"><vh>FloatComparisonOp.accept</vh></v>
</v>
<v t="ekr.20240308084832.841"><vh>class LoadMem</vh>
<v t="ekr.20240308084832.842"><vh>LoadMem.__init__</vh></v>
<v t="ekr.20240308084832.843"><vh>LoadMem.sources</vh></v>
<v t="ekr.20240308084832.844"><vh>LoadMem.accept</vh></v>
</v>
<v t="ekr.20240308084832.845"><vh>class SetMem</vh>
<v t="ekr.20240308084832.846"><vh>SetMem.__init__</vh></v>
<v t="ekr.20240308084832.847"><vh>SetMem.sources</vh></v>
<v t="ekr.20240308084832.848"><vh>SetMem.stolen</vh></v>
<v t="ekr.20240308084832.849"><vh>SetMem.accept</vh></v>
</v>
<v t="ekr.20240308084832.850"><vh>class GetElementPtr</vh>
<v t="ekr.20240308084832.851"><vh>GetElementPtr.__init__</vh></v>
<v t="ekr.20240308084832.852"><vh>GetElementPtr.sources</vh></v>
<v t="ekr.20240308084832.853"><vh>GetElementPtr.accept</vh></v>
</v>
<v t="ekr.20240308084832.854"><vh>class LoadAddress</vh>
<v t="ekr.20240308084832.855"><vh>LoadAddress.__init__</vh></v>
<v t="ekr.20240308084832.856"><vh>LoadAddress.sources</vh></v>
<v t="ekr.20240308084832.857"><vh>LoadAddress.accept</vh></v>
</v>
<v t="ekr.20240308084832.858"><vh>class KeepAlive</vh>
<v t="ekr.20240308084832.859"><vh>KeepAlive.__init__</vh></v>
<v t="ekr.20240308084832.860"><vh>KeepAlive.sources</vh></v>
<v t="ekr.20240308084832.861"><vh>KeepAlive.stolen</vh></v>
<v t="ekr.20240308084832.862"><vh>KeepAlive.accept</vh></v>
</v>
<v t="ekr.20240308084832.863"><vh>class Unborrow</vh>
<v t="ekr.20240308084832.864"><vh>Unborrow.__init__</vh></v>
<v t="ekr.20240308084832.865"><vh>Unborrow.sources</vh></v>
<v t="ekr.20240308084832.866"><vh>Unborrow.stolen</vh></v>
<v t="ekr.20240308084832.867"><vh>Unborrow.accept</vh></v>
</v>
<v t="ekr.20240308084832.868"><vh>class OpVisitor</vh>
<v t="ekr.20240308084832.869"><vh>OpVisitor.visit_goto</vh></v>
<v t="ekr.20240308084832.870"><vh>OpVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.871"><vh>OpVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.872"><vh>OpVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.873"><vh>OpVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.874"><vh>OpVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.875"><vh>OpVisitor.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.876"><vh>OpVisitor.visit_load_literal</vh></v>
<v t="ekr.20240308084832.877"><vh>OpVisitor.visit_get_attr</vh></v>
<v t="ekr.20240308084832.878"><vh>OpVisitor.visit_set_attr</vh></v>
<v t="ekr.20240308084832.879"><vh>OpVisitor.visit_load_static</vh></v>
<v t="ekr.20240308084832.880"><vh>OpVisitor.visit_init_static</vh></v>
<v t="ekr.20240308084832.881"><vh>OpVisitor.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.882"><vh>OpVisitor.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.883"><vh>OpVisitor.visit_inc_ref</vh></v>
<v t="ekr.20240308084832.884"><vh>OpVisitor.visit_dec_ref</vh></v>
<v t="ekr.20240308084832.885"><vh>OpVisitor.visit_call</vh></v>
<v t="ekr.20240308084832.886"><vh>OpVisitor.visit_method_call</vh></v>
<v t="ekr.20240308084832.887"><vh>OpVisitor.visit_cast</vh></v>
<v t="ekr.20240308084832.888"><vh>OpVisitor.visit_box</vh></v>
<v t="ekr.20240308084832.889"><vh>OpVisitor.visit_unbox</vh></v>
<v t="ekr.20240308084832.890"><vh>OpVisitor.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.891"><vh>OpVisitor.visit_call_c</vh></v>
<v t="ekr.20240308084832.892"><vh>OpVisitor.visit_truncate</vh></v>
<v t="ekr.20240308084832.893"><vh>OpVisitor.visit_extend</vh></v>
<v t="ekr.20240308084832.894"><vh>OpVisitor.visit_load_global</vh></v>
<v t="ekr.20240308084832.895"><vh>OpVisitor.visit_int_op</vh></v>
<v t="ekr.20240308084832.896"><vh>OpVisitor.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.897"><vh>OpVisitor.visit_float_op</vh></v>
<v t="ekr.20240308084832.898"><vh>OpVisitor.visit_float_neg</vh></v>
<v t="ekr.20240308084832.899"><vh>OpVisitor.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.900"><vh>OpVisitor.visit_load_mem</vh></v>
<v t="ekr.20240308084832.901"><vh>OpVisitor.visit_set_mem</vh></v>
<v t="ekr.20240308084832.902"><vh>OpVisitor.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.903"><vh>OpVisitor.visit_load_address</vh></v>
<v t="ekr.20240308084832.904"><vh>OpVisitor.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.905"><vh>OpVisitor.visit_unborrow</vh></v>
</v>
<v t="ekr.20240308084832.906"><vh>class DeserMaps</vh></v>
</v>
<v t="ekr.20240308084832.907"><vh>ir/pprint.py</vh>
<v t="ekr.20240308084832.908"><vh>class IRPrettyPrintVisitor</vh>
<v t="ekr.20240308084832.909"><vh>IRPrettyPrintVisitor.__init__</vh></v>
<v t="ekr.20240308084832.910"><vh>IRPrettyPrintVisitor.visit_goto</vh></v>
<v t="ekr.20240308084832.911"><vh>IRPrettyPrintVisitor.visit_branch</vh></v>
<v t="ekr.20240308084832.912"><vh>IRPrettyPrintVisitor.visit_return</vh></v>
<v t="ekr.20240308084832.913"><vh>IRPrettyPrintVisitor.visit_unreachable</vh></v>
<v t="ekr.20240308084832.914"><vh>IRPrettyPrintVisitor.visit_assign</vh></v>
<v t="ekr.20240308084832.915"><vh>IRPrettyPrintVisitor.visit_assign_multi</vh></v>
<v t="ekr.20240308084832.916"><vh>IRPrettyPrintVisitor.visit_load_error_value</vh></v>
<v t="ekr.20240308084832.917"><vh>IRPrettyPrintVisitor.visit_load_literal</vh></v>
<v t="ekr.20240308084832.918"><vh>IRPrettyPrintVisitor.visit_get_attr</vh></v>
<v t="ekr.20240308084832.919"><vh>IRPrettyPrintVisitor.borrow_prefix</vh></v>
<v t="ekr.20240308084832.920"><vh>IRPrettyPrintVisitor.visit_set_attr</vh></v>
<v t="ekr.20240308084832.921"><vh>IRPrettyPrintVisitor.visit_load_static</vh></v>
<v t="ekr.20240308084832.922"><vh>IRPrettyPrintVisitor.visit_init_static</vh></v>
<v t="ekr.20240308084832.923"><vh>IRPrettyPrintVisitor.visit_tuple_get</vh></v>
<v t="ekr.20240308084832.924"><vh>IRPrettyPrintVisitor.visit_tuple_set</vh></v>
<v t="ekr.20240308084832.925"><vh>IRPrettyPrintVisitor.visit_inc_ref</vh></v>
<v t="ekr.20240308084832.926"><vh>IRPrettyPrintVisitor.visit_dec_ref</vh></v>
<v t="ekr.20240308084832.927"><vh>IRPrettyPrintVisitor.visit_call</vh></v>
<v t="ekr.20240308084832.928"><vh>IRPrettyPrintVisitor.visit_method_call</vh></v>
<v t="ekr.20240308084832.929"><vh>IRPrettyPrintVisitor.visit_cast</vh></v>
<v t="ekr.20240308084832.930"><vh>IRPrettyPrintVisitor.visit_box</vh></v>
<v t="ekr.20240308084832.931"><vh>IRPrettyPrintVisitor.visit_unbox</vh></v>
<v t="ekr.20240308084832.932"><vh>IRPrettyPrintVisitor.visit_raise_standard_error</vh></v>
<v t="ekr.20240308084832.933"><vh>IRPrettyPrintVisitor.visit_call_c</vh></v>
<v t="ekr.20240308084832.934"><vh>IRPrettyPrintVisitor.visit_truncate</vh></v>
<v t="ekr.20240308084832.935"><vh>IRPrettyPrintVisitor.visit_extend</vh></v>
<v t="ekr.20240308084832.936"><vh>IRPrettyPrintVisitor.visit_load_global</vh></v>
<v t="ekr.20240308084832.937"><vh>IRPrettyPrintVisitor.visit_int_op</vh></v>
<v t="ekr.20240308084832.938"><vh>IRPrettyPrintVisitor.visit_comparison_op</vh></v>
<v t="ekr.20240308084832.939"><vh>IRPrettyPrintVisitor.visit_float_op</vh></v>
<v t="ekr.20240308084832.940"><vh>IRPrettyPrintVisitor.visit_float_neg</vh></v>
<v t="ekr.20240308084832.941"><vh>IRPrettyPrintVisitor.visit_float_comparison_op</vh></v>
<v t="ekr.20240308084832.942"><vh>IRPrettyPrintVisitor.visit_load_mem</vh></v>
<v t="ekr.20240308084832.943"><vh>IRPrettyPrintVisitor.visit_set_mem</vh></v>
<v t="ekr.20240308084832.944"><vh>IRPrettyPrintVisitor.visit_get_element_ptr</vh></v>
<v t="ekr.20240308084832.945"><vh>IRPrettyPrintVisitor.visit_load_address</vh></v>
<v t="ekr.20240308084832.946"><vh>IRPrettyPrintVisitor.visit_keep_alive</vh></v>
<v t="ekr.20240308084832.947"><vh>IRPrettyPrintVisitor.visit_unborrow</vh></v>
<v t="ekr.20240308084832.948"><vh>IRPrettyPrintVisitor.format</vh></v>
</v>
<v t="ekr.20240308084832.949"><vh>function: format_registers</vh></v>
<v t="ekr.20240308084832.950"><vh>function: format_blocks</vh></v>
<v t="ekr.20240308084832.951"><vh>function: format_func</vh></v>
<v t="ekr.20240308084832.952"><vh>function: format_modules</vh></v>
<v t="ekr.20240308084832.953"><vh>function: generate_names_for_ir</vh></v>
</v>
<v t="ekr.20240308084832.954"><vh>ir/rtypes.py</vh>
<v t="ekr.20240308084832.955"><vh>class RType</vh>
<v t="ekr.20240308084832.956"><vh>RType.accept</vh></v>
<v t="ekr.20240308084832.957"><vh>RType.short_name</vh></v>
<v t="ekr.20240308084832.958"><vh>RType.__str__</vh></v>
<v t="ekr.20240308084832.959"><vh>RType.__repr__</vh></v>
<v t="ekr.20240308084832.960"><vh>RType.serialize</vh></v>
</v>
<v t="ekr.20240308084832.961"><vh>function: deserialize_type</vh></v>
<v t="ekr.20240308084832.962"><vh>class RTypeVisitor</vh>
<v t="ekr.20240308084832.963"><vh>RTypeVisitor.visit_rprimitive</vh></v>
<v t="ekr.20240308084832.964"><vh>RTypeVisitor.visit_rinstance</vh></v>
<v t="ekr.20240308084832.965"><vh>RTypeVisitor.visit_runion</vh></v>
<v t="ekr.20240308084832.966"><vh>RTypeVisitor.visit_rtuple</vh></v>
<v t="ekr.20240308084832.967"><vh>RTypeVisitor.visit_rstruct</vh></v>
<v t="ekr.20240308084832.968"><vh>RTypeVisitor.visit_rarray</vh></v>
<v t="ekr.20240308084832.969"><vh>RTypeVisitor.visit_rvoid</vh></v>
</v>
<v t="ekr.20240308084832.970"><vh>class RVoid</vh>
<v t="ekr.20240308084832.971"><vh>RVoid.accept</vh></v>
<v t="ekr.20240308084832.972"><vh>RVoid.serialize</vh></v>
<v t="ekr.20240308084832.973"><vh>RVoid.__eq__</vh></v>
<v t="ekr.20240308084832.974"><vh>RVoid.__hash__</vh></v>
</v>
<v t="ekr.20240308084832.975"><vh>class RPrimitive</vh>
<v t="ekr.20240308084832.976"><vh>RPrimitive.__init__</vh></v>
<v t="ekr.20240308084832.977"><vh>RPrimitive.accept</vh></v>
<v t="ekr.20240308084832.978"><vh>RPrimitive.serialize</vh></v>
<v t="ekr.20240308084832.979"><vh>RPrimitive.__repr__</vh></v>
<v t="ekr.20240308084832.980"><vh>RPrimitive.__eq__</vh></v>
<v t="ekr.20240308084832.981"><vh>RPrimitive.__hash__</vh></v>
</v>
<v t="ekr.20240308084832.982"><vh>function: is_tagged</vh></v>
<v t="ekr.20240308084832.983"><vh>function: is_int_rprimitive</vh></v>
<v t="ekr.20240308084832.984"><vh>function: is_short_int_rprimitive</vh></v>
<v t="ekr.20240308084832.985"><vh>function: is_int16_rprimitive</vh></v>
<v t="ekr.20240308084832.986"><vh>function: is_int32_rprimitive</vh></v>
<v t="ekr.20240308084832.987"><vh>function: is_int64_rprimitive</vh></v>
<v t="ekr.20240308084832.988"><vh>function: is_fixed_width_rtype</vh></v>
<v t="ekr.20240308084832.989"><vh>function: is_uint8_rprimitive</vh></v>
<v t="ekr.20240308084832.990"><vh>function: is_uint32_rprimitive</vh></v>
<v t="ekr.20240308084832.991"><vh>function: is_uint64_rprimitive</vh></v>
<v t="ekr.20240308084832.992"><vh>function: is_c_py_ssize_t_rprimitive</vh></v>
<v t="ekr.20240308084832.993"><vh>function: is_pointer_rprimitive</vh></v>
<v t="ekr.20240308084832.994"><vh>function: is_float_rprimitive</vh></v>
<v t="ekr.20240308084832.995"><vh>function: is_bool_rprimitive</vh></v>
<v t="ekr.20240308084832.996"><vh>function: is_bit_rprimitive</vh></v>
<v t="ekr.20240308084832.997"><vh>function: is_object_rprimitive</vh></v>
<v t="ekr.20240308084832.998"><vh>function: is_none_rprimitive</vh></v>
<v t="ekr.20240308084832.999"><vh>function: is_list_rprimitive</vh></v>
<v t="ekr.20240308084832.1000"><vh>function: is_dict_rprimitive</vh></v>
<v t="ekr.20240308084832.1001"><vh>function: is_set_rprimitive</vh></v>
<v t="ekr.20240308084832.1002"><vh>function: is_str_rprimitive</vh></v>
<v t="ekr.20240308084832.1003"><vh>function: is_bytes_rprimitive</vh></v>
<v t="ekr.20240308084832.1004"><vh>function: is_tuple_rprimitive</vh></v>
<v t="ekr.20240308084832.1005"><vh>function: is_range_rprimitive</vh></v>
<v t="ekr.20240308084832.1006"><vh>function: is_sequence_rprimitive</vh></v>
<v t="ekr.20240308084832.1007"><vh>class TupleNameVisitor</vh>
<v t="ekr.20240308084832.1008"><vh>TupleNameVisitor.visit_rinstance</vh></v>
<v t="ekr.20240308084832.1009"><vh>TupleNameVisitor.visit_runion</vh></v>
<v t="ekr.20240308084832.1010"><vh>TupleNameVisitor.visit_rprimitive</vh></v>
<v t="ekr.20240308084832.1011"><vh>TupleNameVisitor.visit_rtuple</vh></v>
<v t="ekr.20240308084832.1012"><vh>TupleNameVisitor.visit_rstruct</vh></v>
<v t="ekr.20240308084832.1013"><vh>TupleNameVisitor.visit_rarray</vh></v>
<v t="ekr.20240308084832.1014"><vh>TupleNameVisitor.visit_rvoid</vh></v>
</v>
<v t="ekr.20240308084832.1015"><vh>class RTuple</vh>
<v t="ekr.20240308084832.1016"><vh>RTuple.__init__</vh></v>
<v t="ekr.20240308084832.1017"><vh>RTuple.accept</vh></v>
<v t="ekr.20240308084832.1018"><vh>RTuple.__str__</vh></v>
<v t="ekr.20240308084832.1019"><vh>RTuple.__repr__</vh></v>
<v t="ekr.20240308084832.1020"><vh>RTuple.__eq__</vh></v>
<v t="ekr.20240308084832.1021"><vh>RTuple.__hash__</vh></v>
<v t="ekr.20240308084832.1022"><vh>RTuple.serialize</vh></v>
<v t="ekr.20240308084832.1023"><vh>RTuple.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.1024"><vh>function: compute_rtype_alignment</vh></v>
<v t="ekr.20240308084832.1025"><vh>function: compute_rtype_size</vh></v>
<v t="ekr.20240308084832.1026"><vh>function: compute_aligned_offsets_and_size</vh></v>
<v t="ekr.20240308084832.1027"><vh>class RStruct</vh>
<v t="ekr.20240308084832.1028"><vh>RStruct.__init__</vh></v>
<v t="ekr.20240308084832.1029"><vh>RStruct.accept</vh></v>
<v t="ekr.20240308084832.1030"><vh>RStruct.__str__</vh></v>
<v t="ekr.20240308084832.1031"><vh>RStruct.__repr__</vh></v>
<v t="ekr.20240308084832.1032"><vh>RStruct.__eq__</vh></v>
<v t="ekr.20240308084832.1033"><vh>RStruct.__hash__</vh></v>
<v t="ekr.20240308084832.1034"><vh>RStruct.serialize</vh></v>
<v t="ekr.20240308084832.1035"><vh>RStruct.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.1036"><vh>class RInstance</vh>
<v t="ekr.20240308084832.1037"><vh>RInstance.__init__</vh></v>
<v t="ekr.20240308084832.1038"><vh>RInstance.accept</vh></v>
<v t="ekr.20240308084832.1039"><vh>RInstance.struct_name</vh></v>
<v t="ekr.20240308084832.1040"><vh>RInstance.getter_index</vh></v>
<v t="ekr.20240308084832.1041"><vh>RInstance.setter_index</vh></v>
<v t="ekr.20240308084832.1042"><vh>RInstance.method_index</vh></v>
<v t="ekr.20240308084832.1043"><vh>RInstance.attr_type</vh></v>
<v t="ekr.20240308084832.1044"><vh>RInstance.__repr__</vh></v>
<v t="ekr.20240308084832.1045"><vh>RInstance.__eq__</vh></v>
<v t="ekr.20240308084832.1046"><vh>RInstance.__hash__</vh></v>
<v t="ekr.20240308084832.1047"><vh>RInstance.serialize</vh></v>
</v>
<v t="ekr.20240308084832.1048"><vh>class RUnion</vh>
<v t="ekr.20240308084832.1049"><vh>RUnion.__init__</vh></v>
<v t="ekr.20240308084832.1050"><vh>RUnion.make_simplified_union</vh></v>
<v t="ekr.20240308084832.1051"><vh>RUnion.accept</vh></v>
<v t="ekr.20240308084832.1052"><vh>RUnion.__repr__</vh></v>
<v t="ekr.20240308084832.1053"><vh>RUnion.__str__</vh></v>
<v t="ekr.20240308084832.1054"><vh>RUnion.__eq__</vh></v>
<v t="ekr.20240308084832.1055"><vh>RUnion.__hash__</vh></v>
<v t="ekr.20240308084832.1056"><vh>RUnion.serialize</vh></v>
<v t="ekr.20240308084832.1057"><vh>RUnion.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.1058"><vh>function: flatten_nested_unions</vh></v>
<v t="ekr.20240308084832.1059"><vh>function: optional_value_type</vh></v>
<v t="ekr.20240308084832.1060"><vh>function: is_optional_type</vh></v>
<v t="ekr.20240308084832.1061"><vh>class RArray</vh>
<v t="ekr.20240308084832.1062"><vh>RArray.__init__</vh></v>
<v t="ekr.20240308084832.1063"><vh>RArray.accept</vh></v>
<v t="ekr.20240308084832.1064"><vh>RArray.__str__</vh></v>
<v t="ekr.20240308084832.1065"><vh>RArray.__repr__</vh></v>
<v t="ekr.20240308084832.1066"><vh>RArray.__eq__</vh></v>
<v t="ekr.20240308084832.1067"><vh>RArray.__hash__</vh></v>
<v t="ekr.20240308084832.1068"><vh>RArray.serialize</vh></v>
<v t="ekr.20240308084832.1069"><vh>RArray.deserialize</vh></v>
</v>
<v t="ekr.20240308084832.1070"><vh>function: check_native_int_range</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1071"><vh>irbuild</vh>
<v t="ekr.20240308084832.1072"><vh>irbuild/__init__.py</vh></v>
<v t="ekr.20240308084832.1073"><vh>irbuild/ast_helpers.py</vh>
<v t="ekr.20240308084832.1074"><vh>function: process_conditional</vh></v>
<v t="ekr.20240308084832.1075"><vh>function: maybe_process_conditional_comparison</vh></v>
<v t="ekr.20240308084832.1076"><vh>function: is_borrow_friendly_expr</vh></v>
</v>
<v t="ekr.20240308084832.1077"><vh>irbuild/builder.py</vh>
<v t="ekr.20240308084832.1078"><vh>class IRVisitor</vh></v>
<v t="ekr.20240308084832.1079"><vh>class UnsupportedException</vh></v>
<v t="ekr.20240308084832.1080"><vh>class IRBuilder</vh>
<v t="ekr.20240308084832.1081"><vh>IRBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1082"><vh>IRBuilder.set_module</vh></v>
<v t="ekr.20240308084832.1083"><vh>IRBuilder.accept</vh></v>
<v t="ekr.20240308084832.1084"><vh>IRBuilder.accept</vh></v>
<v t="ekr.20240308084832.1085"><vh>IRBuilder.accept</vh></v>
<v t="ekr.20240308084832.1086"><vh>IRBuilder.flush_keep_alives</vh></v>
<v t="ekr.20240308084832.1087"><vh>IRBuilder.add</vh></v>
<v t="ekr.20240308084832.1088"><vh>IRBuilder.goto</vh></v>
<v t="ekr.20240308084832.1089"><vh>IRBuilder.activate_block</vh></v>
<v t="ekr.20240308084832.1090"><vh>IRBuilder.goto_and_activate</vh></v>
<v t="ekr.20240308084832.1091"><vh>IRBuilder.self</vh></v>
<v t="ekr.20240308084832.1092"><vh>IRBuilder.py_get_attr</vh></v>
<v t="ekr.20240308084832.1093"><vh>IRBuilder.load_str</vh></v>
<v t="ekr.20240308084832.1094"><vh>IRBuilder.load_bytes_from_str_literal</vh></v>
<v t="ekr.20240308084832.1095"><vh>IRBuilder.load_int</vh></v>
<v t="ekr.20240308084832.1096"><vh>IRBuilder.load_float</vh></v>
<v t="ekr.20240308084832.1097"><vh>IRBuilder.unary_op</vh></v>
<v t="ekr.20240308084832.1098"><vh>IRBuilder.binary_op</vh></v>
<v t="ekr.20240308084832.1099"><vh>IRBuilder.coerce</vh></v>
<v t="ekr.20240308084832.1100"><vh>IRBuilder.none_object</vh></v>
<v t="ekr.20240308084832.1101"><vh>IRBuilder.none</vh></v>
<v t="ekr.20240308084832.1102"><vh>IRBuilder.true</vh></v>
<v t="ekr.20240308084832.1103"><vh>IRBuilder.false</vh></v>
<v t="ekr.20240308084832.1104"><vh>IRBuilder.new_list_op</vh></v>
<v t="ekr.20240308084832.1105"><vh>IRBuilder.new_set_op</vh></v>
<v t="ekr.20240308084832.1106"><vh>IRBuilder.translate_is_op</vh></v>
<v t="ekr.20240308084832.1107"><vh>IRBuilder.py_call</vh></v>
<v t="ekr.20240308084832.1108"><vh>IRBuilder.add_bool_branch</vh></v>
<v t="ekr.20240308084832.1109"><vh>IRBuilder.load_native_type_object</vh></v>
<v t="ekr.20240308084832.1110"><vh>IRBuilder.gen_method_call</vh></v>
<v t="ekr.20240308084832.1111"><vh>IRBuilder.load_module</vh></v>
<v t="ekr.20240308084832.1112"><vh>IRBuilder.call_c</vh></v>
<v t="ekr.20240308084832.1113"><vh>IRBuilder.int_op</vh></v>
<v t="ekr.20240308084832.1114"><vh>IRBuilder.compare_tagged</vh></v>
<v t="ekr.20240308084832.1115"><vh>IRBuilder.compare_tuples</vh></v>
<v t="ekr.20240308084832.1116"><vh>IRBuilder.builtin_len</vh></v>
<v t="ekr.20240308084832.1117"><vh>IRBuilder.new_tuple</vh></v>
<v t="ekr.20240308084832.1118"><vh>IRBuilder.add_to_non_ext_dict</vh></v>
<v t="ekr.20240308084832.1119"><vh>IRBuilder.gen_import</vh></v>
<v t="ekr.20240308084832.1120"><vh>IRBuilder.check_if_module_loaded</vh></v>
<v t="ekr.20240308084832.1121"><vh>IRBuilder.get_module</vh></v>
<v t="ekr.20240308084832.1122"><vh>IRBuilder.get_module_attr</vh></v>
<v t="ekr.20240308084832.1123"><vh>IRBuilder.assign_if_null</vh></v>
<v t="ekr.20240308084832.1124"><vh>IRBuilder.assign_if_bitmap_unset</vh></v>
<v t="ekr.20240308084832.1125"><vh>IRBuilder.maybe_add_implicit_return</vh></v>
<v t="ekr.20240308084832.1126"><vh>IRBuilder.add_implicit_return</vh></v>
<v t="ekr.20240308084832.1127"><vh>IRBuilder.add_implicit_unreachable</vh></v>
<v t="ekr.20240308084832.1128"><vh>IRBuilder.disallow_class_assignments</vh></v>
<v t="ekr.20240308084832.1129"><vh>IRBuilder.non_function_scope</vh></v>
<v t="ekr.20240308084832.1130"><vh>IRBuilder.top_level_fn_info</vh></v>
<v t="ekr.20240308084832.1131"><vh>IRBuilder.init_final_static</vh></v>
<v t="ekr.20240308084832.1132"><vh>IRBuilder.load_final_static</vh></v>
<v t="ekr.20240308084832.1133"><vh>IRBuilder.load_literal_value</vh></v>
<v t="ekr.20240308084832.1134"><vh>IRBuilder.get_assignment_target</vh></v>
<v t="ekr.20240308084832.1135"><vh>IRBuilder.read</vh></v>
<v t="ekr.20240308084832.1136"><vh>IRBuilder.assign</vh></v>
<v t="ekr.20240308084832.1137"><vh>IRBuilder.coerce_rvalue</vh></v>
<v t="ekr.20240308084832.1138"><vh>IRBuilder.process_sequence_assignment</vh></v>
<v t="ekr.20240308084832.1139"><vh>IRBuilder.process_iterator_tuple_assignment_helper</vh></v>
<v t="ekr.20240308084832.1140"><vh>IRBuilder.process_iterator_tuple_assignment</vh></v>
<v t="ekr.20240308084832.1141"><vh>IRBuilder.push_loop_stack</vh></v>
<v t="ekr.20240308084832.1142"><vh>IRBuilder.pop_loop_stack</vh></v>
<v t="ekr.20240308084832.1143"><vh>IRBuilder.make_spill_target</vh></v>
<v t="ekr.20240308084832.1144"><vh>IRBuilder.spill</vh></v>
<v t="ekr.20240308084832.1145"><vh>IRBuilder.maybe_spill</vh></v>
<v t="ekr.20240308084832.1146"><vh>IRBuilder.maybe_spill_assignable</vh></v>
<v t="ekr.20240308084832.1147"><vh>IRBuilder.extract_int</vh></v>
<v t="ekr.20240308084832.1148"><vh>IRBuilder.get_sequence_type</vh></v>
<v t="ekr.20240308084832.1149"><vh>IRBuilder.get_sequence_type_from_type</vh></v>
<v t="ekr.20240308084832.1150"><vh>IRBuilder.get_dict_base_type</vh></v>
<v t="ekr.20240308084832.1151"><vh>IRBuilder.get_dict_key_type</vh></v>
<v t="ekr.20240308084832.1152"><vh>IRBuilder.get_dict_value_type</vh></v>
<v t="ekr.20240308084832.1153"><vh>IRBuilder.get_dict_item_type</vh></v>
<v t="ekr.20240308084832.1154"><vh>IRBuilder._analyze_iterable_item_type</vh></v>
<v t="ekr.20240308084832.1155"><vh>IRBuilder.is_native_module</vh></v>
<v t="ekr.20240308084832.1156"><vh>IRBuilder.is_native_ref_expr</vh></v>
<v t="ekr.20240308084832.1157"><vh>IRBuilder.is_native_module_ref_expr</vh></v>
<v t="ekr.20240308084832.1158"><vh>IRBuilder.is_synthetic_type</vh></v>
<v t="ekr.20240308084832.1159"><vh>IRBuilder.get_final_ref</vh></v>
<v t="ekr.20240308084832.1160"><vh>IRBuilder.emit_load_final</vh></v>
<v t="ekr.20240308084832.1161"><vh>IRBuilder.is_module_member_expr</vh></v>
<v t="ekr.20240308084832.1162"><vh>IRBuilder.call_refexpr_with_args</vh></v>
<v t="ekr.20240308084832.1163"><vh>IRBuilder.shortcircuit_expr</vh></v>
<v t="ekr.20240308084832.1164"><vh>IRBuilder.flatten_classes</vh></v>
<v t="ekr.20240308084832.1165"><vh>IRBuilder.enter</vh></v>
<v t="ekr.20240308084832.1166"><vh>IRBuilder.leave</vh></v>
<v t="ekr.20240308084832.1167"><vh>IRBuilder.enter_method</vh></v>
<v t="ekr.20240308084832.1168"><vh>IRBuilder.add_argument</vh></v>
<v t="ekr.20240308084832.1169"><vh>IRBuilder.lookup</vh></v>
<v t="ekr.20240308084832.1170"><vh>IRBuilder.add_local</vh></v>
<v t="ekr.20240308084832.1171"><vh>IRBuilder.add_local_reg</vh></v>
<v t="ekr.20240308084832.1172"><vh>IRBuilder.add_self_to_env</vh></v>
<v t="ekr.20240308084832.1173"><vh>IRBuilder.add_target</vh></v>
<v t="ekr.20240308084832.1174"><vh>IRBuilder.type_to_rtype</vh></v>
<v t="ekr.20240308084832.1175"><vh>IRBuilder.node_type</vh></v>
<v t="ekr.20240308084832.1176"><vh>IRBuilder.add_var_to_env_class</vh></v>
<v t="ekr.20240308084832.1177"><vh>IRBuilder.is_builtin_ref_expr</vh></v>
<v t="ekr.20240308084832.1178"><vh>IRBuilder.load_global</vh></v>
<v t="ekr.20240308084832.1179"><vh>IRBuilder.load_global_str</vh></v>
<v t="ekr.20240308084832.1180"><vh>IRBuilder.load_globals_dict</vh></v>
<v t="ekr.20240308084832.1181"><vh>IRBuilder.load_module_attr_by_fullname</vh></v>
<v t="ekr.20240308084832.1182"><vh>IRBuilder.is_native_attr_ref</vh></v>
<v t="ekr.20240308084832.1183"><vh>IRBuilder.mark_block_unreachable</vh></v>
<v t="ekr.20240308084832.1184"><vh>IRBuilder.catch_errors</vh></v>
<v t="ekr.20240308084832.1185"><vh>IRBuilder.warning</vh></v>
<v t="ekr.20240308084832.1186"><vh>IRBuilder.error</vh></v>
<v t="ekr.20240308084832.1187"><vh>IRBuilder.note</vh></v>
<v t="ekr.20240308084832.1188"><vh>IRBuilder.add_function</vh></v>
</v>
<v t="ekr.20240308084832.1189"><vh>function: gen_arg_defaults</vh></v>
<v t="ekr.20240308084832.1190"><vh>function: remangle_redefinition_name</vh></v>
<v t="ekr.20240308084832.1191"><vh>function: get_call_target_fullname</vh></v>
</v>
<v t="ekr.20240308084832.1192"><vh>irbuild/callable_class.py</vh>
<v t="ekr.20240308084832.1193"><vh>function: setup_callable_class</vh></v>
<v t="ekr.20240308084832.1194"><vh>function: add_call_to_callable_class</vh></v>
<v t="ekr.20240308084832.1195"><vh>function: add_get_to_callable_class</vh></v>
<v t="ekr.20240308084832.1196"><vh>function: instantiate_callable_class</vh></v>
</v>
<v t="ekr.20240308084832.1197"><vh>irbuild/classdef.py</vh>
<v t="ekr.20240308084832.1198"><vh>function: transform_class_def</vh></v>
<v t="ekr.20240308084832.1199"><vh>class ClassBuilder</vh>
<v t="ekr.20240308084832.1200"><vh>ClassBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1201"><vh>ClassBuilder.add_method</vh></v>
<v t="ekr.20240308084832.1202"><vh>ClassBuilder.add_attr</vh></v>
<v t="ekr.20240308084832.1203"><vh>ClassBuilder.finalize</vh></v>
</v>
<v t="ekr.20240308084832.1204"><vh>class NonExtClassBuilder</vh>
<v t="ekr.20240308084832.1205"><vh>NonExtClassBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1206"><vh>NonExtClassBuilder.create_non_ext_info</vh></v>
<v t="ekr.20240308084832.1207"><vh>NonExtClassBuilder.add_method</vh></v>
<v t="ekr.20240308084832.1208"><vh>NonExtClassBuilder.add_attr</vh></v>
<v t="ekr.20240308084832.1209"><vh>NonExtClassBuilder.finalize</vh></v>
</v>
<v t="ekr.20240308084832.1210"><vh>class ExtClassBuilder</vh>
<v t="ekr.20240308084832.1211"><vh>ExtClassBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1212"><vh>ExtClassBuilder.skip_attr_default</vh></v>
<v t="ekr.20240308084832.1213"><vh>ExtClassBuilder.add_method</vh></v>
<v t="ekr.20240308084832.1214"><vh>ExtClassBuilder.add_attr</vh></v>
<v t="ekr.20240308084832.1215"><vh>ExtClassBuilder.finalize</vh></v>
</v>
<v t="ekr.20240308084832.1216"><vh>class DataClassBuilder</vh>
<v t="ekr.20240308084832.1217"><vh>DataClassBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1218"><vh>DataClassBuilder.create_non_ext_info</vh></v>
<v t="ekr.20240308084832.1219"><vh>DataClassBuilder.skip_attr_default</vh></v>
<v t="ekr.20240308084832.1220"><vh>DataClassBuilder.get_type_annotation</vh></v>
<v t="ekr.20240308084832.1221"><vh>DataClassBuilder.add_attr</vh></v>
<v t="ekr.20240308084832.1222"><vh>DataClassBuilder.finalize</vh></v>
</v>
<v t="ekr.20240308084832.1223"><vh>class AttrsClassBuilder</vh>
<v t="ekr.20240308084832.1224"><vh>AttrsClassBuilder.skip_attr_default</vh></v>
<v t="ekr.20240308084832.1225"><vh>AttrsClassBuilder.get_type_annotation</vh></v>
</v>
<v t="ekr.20240308084832.1226"><vh>function: allocate_class</vh></v>
<v t="ekr.20240308084832.1227"><vh>function: populate_non_ext_bases</vh></v>
<v t="ekr.20240308084832.1228"><vh>function: find_non_ext_metaclass</vh></v>
<v t="ekr.20240308084832.1229"><vh>function: setup_non_ext_dict</vh></v>
<v t="ekr.20240308084832.1230"><vh>function: add_non_ext_class_attr_ann</vh></v>
<v t="ekr.20240308084832.1231"><vh>function: add_non_ext_class_attr</vh></v>
<v t="ekr.20240308084832.1232"><vh>function: find_attr_initializers</vh></v>
<v t="ekr.20240308084832.1233"><vh>function: generate_attr_defaults_init</vh></v>
<v t="ekr.20240308084832.1234"><vh>function: check_deletable_declaration</vh></v>
<v t="ekr.20240308084832.1235"><vh>function: create_ne_from_eq</vh></v>
<v t="ekr.20240308084832.1236"><vh>function: gen_glue_ne_method</vh></v>
<v t="ekr.20240308084832.1237"><vh>function: load_non_ext_class</vh></v>
<v t="ekr.20240308084832.1238"><vh>function: load_decorated_class</vh></v>
<v t="ekr.20240308084832.1239"><vh>function: cache_class_attrs</vh></v>
<v t="ekr.20240308084832.1240"><vh>function: create_mypyc_attrs_tuple</vh></v>
<v t="ekr.20240308084832.1241"><vh>function: add_dunders_to_non_ext_dict</vh></v>
</v>
<v t="ekr.20240308084832.1242"><vh>irbuild/constant_fold.py</vh>
<v t="ekr.20240308084832.1243"><vh>function: constant_fold_expr</vh></v>
<v t="ekr.20240308084832.1244"><vh>function: constant_fold_binary_op_extended</vh></v>
</v>
<v t="ekr.20240308084832.1245"><vh>irbuild/context.py</vh>
<v t="ekr.20240308084832.1246"><vh>class FuncInfo</vh>
<v t="ekr.20240308084832.1247"><vh>FuncInfo.__init__</vh></v>
<v t="ekr.20240308084832.1248"><vh>FuncInfo.namespaced_name</vh></v>
<v t="ekr.20240308084832.1249"><vh>FuncInfo.is_generator</vh></v>
<v t="ekr.20240308084832.1250"><vh>FuncInfo.is_coroutine</vh></v>
<v t="ekr.20240308084832.1251"><vh>FuncInfo.callable_class</vh></v>
<v t="ekr.20240308084832.1252"><vh>FuncInfo.callable_class</vh></v>
<v t="ekr.20240308084832.1253"><vh>FuncInfo.env_class</vh></v>
<v t="ekr.20240308084832.1254"><vh>FuncInfo.env_class</vh></v>
<v t="ekr.20240308084832.1255"><vh>FuncInfo.generator_class</vh></v>
<v t="ekr.20240308084832.1256"><vh>FuncInfo.generator_class</vh></v>
<v t="ekr.20240308084832.1257"><vh>FuncInfo.curr_env_reg</vh></v>
</v>
<v t="ekr.20240308084832.1258"><vh>class ImplicitClass</vh>
<v t="ekr.20240308084832.1259"><vh>ImplicitClass.__init__</vh></v>
<v t="ekr.20240308084832.1260"><vh>ImplicitClass.self_reg</vh></v>
<v t="ekr.20240308084832.1261"><vh>ImplicitClass.self_reg</vh></v>
<v t="ekr.20240308084832.1262"><vh>ImplicitClass.curr_env_reg</vh></v>
<v t="ekr.20240308084832.1263"><vh>ImplicitClass.curr_env_reg</vh></v>
<v t="ekr.20240308084832.1264"><vh>ImplicitClass.prev_env_reg</vh></v>
<v t="ekr.20240308084832.1265"><vh>ImplicitClass.prev_env_reg</vh></v>
</v>
<v t="ekr.20240308084832.1266"><vh>class GeneratorClass</vh>
<v t="ekr.20240308084832.1267"><vh>GeneratorClass.__init__</vh></v>
<v t="ekr.20240308084832.1268"><vh>GeneratorClass.next_label_reg</vh></v>
<v t="ekr.20240308084832.1269"><vh>GeneratorClass.next_label_reg</vh></v>
<v t="ekr.20240308084832.1270"><vh>GeneratorClass.next_label_target</vh></v>
<v t="ekr.20240308084832.1271"><vh>GeneratorClass.next_label_target</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1272"><vh>irbuild/env_class.py</vh>
<v t="ekr.20240308084832.1273"><vh>function: setup_env_class</vh></v>
<v t="ekr.20240308084832.1274"><vh>function: finalize_env_class</vh></v>
<v t="ekr.20240308084832.1275"><vh>function: instantiate_env_class</vh></v>
<v t="ekr.20240308084832.1276"><vh>function: load_env_registers</vh></v>
<v t="ekr.20240308084832.1277"><vh>function: load_outer_env</vh></v>
<v t="ekr.20240308084832.1278"><vh>function: load_outer_envs</vh></v>
<v t="ekr.20240308084832.1279"><vh>function: num_bitmap_args</vh></v>
<v t="ekr.20240308084832.1280"><vh>function: add_args_to_env</vh></v>
<v t="ekr.20240308084832.1281"><vh>function: setup_func_for_recursive_call</vh></v>
<v t="ekr.20240308084832.1282"><vh>function: is_free_variable</vh></v>
</v>
<v t="ekr.20240308084832.1283"><vh>irbuild/expression.py</vh>
<v t="ekr.20240308084832.1284"><vh>function: transform_name_expr</vh></v>
<v t="ekr.20240308084832.1285"><vh>function: transform_member_expr</vh></v>
<v t="ekr.20240308084832.1286"><vh>function: check_instance_attribute_access_through_class</vh></v>
<v t="ekr.20240308084832.1287"><vh>function: transform_super_expr</vh></v>
<v t="ekr.20240308084832.1288"><vh>function: transform_call_expr</vh></v>
<v t="ekr.20240308084832.1289"><vh>function: translate_call</vh></v>
<v t="ekr.20240308084832.1290"><vh>function: translate_refexpr_call</vh></v>
<v t="ekr.20240308084832.1291"><vh>function: translate_method_call</vh></v>
<v t="ekr.20240308084832.1292"><vh>function: call_classmethod</vh></v>
<v t="ekr.20240308084832.1293"><vh>function: translate_super_method_call</vh></v>
<v t="ekr.20240308084832.1294"><vh>function: translate_cast_expr</vh></v>
<v t="ekr.20240308084832.1295"><vh>function: transform_unary_expr</vh></v>
<v t="ekr.20240308084832.1296"><vh>function: transform_op_expr</vh></v>
<v t="ekr.20240308084832.1297"><vh>function: try_optimize_int_floor_divide</vh></v>
<v t="ekr.20240308084832.1298"><vh>function: transform_index_expr</vh></v>
<v t="ekr.20240308084832.1299"><vh>function: try_constant_fold</vh></v>
<v t="ekr.20240308084832.1300"><vh>function: try_gen_slice_op</vh></v>
<v t="ekr.20240308084832.1301"><vh>function: transform_conditional_expr</vh></v>
<v t="ekr.20240308084832.1302"><vh>function: set_literal_values</vh></v>
<v t="ekr.20240308084832.1303"><vh>function: precompute_set_literal</vh></v>
<v t="ekr.20240308084832.1304"><vh>function: transform_comparison_expr</vh></v>
<v t="ekr.20240308084832.1305"><vh>function: translate_is_none</vh></v>
<v t="ekr.20240308084832.1306"><vh>function: transform_basic_comparison</vh></v>
<v t="ekr.20240308084832.1307"><vh>function: translate_printf_style_formatting</vh></v>
<v t="ekr.20240308084832.1308"><vh>function: transform_int_expr</vh></v>
<v t="ekr.20240308084832.1309"><vh>function: transform_float_expr</vh></v>
<v t="ekr.20240308084832.1310"><vh>function: transform_complex_expr</vh></v>
<v t="ekr.20240308084832.1311"><vh>function: transform_str_expr</vh></v>
<v t="ekr.20240308084832.1312"><vh>function: transform_bytes_expr</vh></v>
<v t="ekr.20240308084832.1313"><vh>function: transform_ellipsis</vh></v>
<v t="ekr.20240308084832.1314"><vh>function: transform_list_expr</vh></v>
<v t="ekr.20240308084832.1315"><vh>function: _visit_list_display</vh></v>
<v t="ekr.20240308084832.1316"><vh>function: transform_tuple_expr</vh></v>
<v t="ekr.20240308084832.1317"><vh>function: _visit_tuple_display</vh></v>
<v t="ekr.20240308084832.1318"><vh>function: transform_dict_expr</vh></v>
<v t="ekr.20240308084832.1319"><vh>function: transform_set_expr</vh></v>
<v t="ekr.20240308084832.1320"><vh>function: _visit_display</vh></v>
<v t="ekr.20240308084832.1321"><vh>function: transform_list_comprehension</vh></v>
<v t="ekr.20240308084832.1322"><vh>function: transform_set_comprehension</vh></v>
<v t="ekr.20240308084832.1323"><vh>function: transform_dictionary_comprehension</vh></v>
<v t="ekr.20240308084832.1324"><vh>function: transform_slice_expr</vh></v>
<v t="ekr.20240308084832.1325"><vh>function: transform_generator_expr</vh></v>
<v t="ekr.20240308084832.1326"><vh>function: transform_assignment_expr</vh></v>
<v t="ekr.20240308084832.1327"><vh>function: transform_math_literal</vh></v>
</v>
<v t="ekr.20240308084832.1328"><vh>irbuild/for_helpers.py</vh>
<v t="ekr.20240308084832.1329"><vh>function: for_loop_helper</vh></v>
<v t="ekr.20240308084832.1330"><vh>function: for_loop_helper_with_index</vh></v>
<v t="ekr.20240308084832.1331"><vh>function: sequence_from_generator_preallocate_helper</vh></v>
<v t="ekr.20240308084832.1332"><vh>function: translate_list_comprehension</vh></v>
<v t="ekr.20240308084832.1333"><vh>function: translate_set_comprehension</vh></v>
<v t="ekr.20240308084832.1334"><vh>function: comprehension_helper</vh></v>
<v t="ekr.20240308084832.1335"><vh>function: is_range_ref</vh></v>
<v t="ekr.20240308084832.1336"><vh>function: make_for_loop_generator</vh></v>
<v t="ekr.20240308084832.1337"><vh>class ForGenerator</vh>
<v t="ekr.20240308084832.1338"><vh>ForGenerator.__init__</vh></v>
<v t="ekr.20240308084832.1339"><vh>ForGenerator.need_cleanup</vh></v>
<v t="ekr.20240308084832.1340"><vh>ForGenerator.add_cleanup</vh></v>
<v t="ekr.20240308084832.1341"><vh>ForGenerator.gen_condition</vh></v>
<v t="ekr.20240308084832.1342"><vh>ForGenerator.begin_body</vh></v>
<v t="ekr.20240308084832.1343"><vh>ForGenerator.gen_step</vh></v>
<v t="ekr.20240308084832.1344"><vh>ForGenerator.gen_cleanup</vh></v>
<v t="ekr.20240308084832.1345"><vh>ForGenerator.load_len</vh></v>
</v>
<v t="ekr.20240308084832.1346"><vh>class ForIterable</vh>
<v t="ekr.20240308084832.1347"><vh>ForIterable.need_cleanup</vh></v>
<v t="ekr.20240308084832.1348"><vh>ForIterable.init</vh></v>
<v t="ekr.20240308084832.1349"><vh>ForIterable.gen_condition</vh></v>
<v t="ekr.20240308084832.1350"><vh>ForIterable.begin_body</vh></v>
<v t="ekr.20240308084832.1351"><vh>ForIterable.gen_step</vh></v>
<v t="ekr.20240308084832.1352"><vh>ForIterable.gen_cleanup</vh></v>
</v>
<v t="ekr.20240308084832.1353"><vh>class ForAsyncIterable</vh>
<v t="ekr.20240308084832.1354"><vh>ForAsyncIterable.init</vh></v>
<v t="ekr.20240308084832.1355"><vh>ForAsyncIterable.gen_condition</vh></v>
<v t="ekr.20240308084832.1356"><vh>ForAsyncIterable.begin_body</vh></v>
<v t="ekr.20240308084832.1357"><vh>ForAsyncIterable.gen_step</vh></v>
</v>
<v t="ekr.20240308084832.1358"><vh>function: unsafe_index</vh></v>
<v t="ekr.20240308084832.1359"><vh>class ForSequence</vh>
<v t="ekr.20240308084832.1360"><vh>ForSequence.init</vh></v>
<v t="ekr.20240308084832.1361"><vh>ForSequence.gen_condition</vh></v>
<v t="ekr.20240308084832.1362"><vh>ForSequence.begin_body</vh></v>
<v t="ekr.20240308084832.1363"><vh>ForSequence.gen_step</vh></v>
</v>
<v t="ekr.20240308084832.1364"><vh>class ForDictionaryCommon</vh>
<v t="ekr.20240308084832.1365"><vh>ForDictionaryCommon.need_cleanup</vh></v>
<v t="ekr.20240308084832.1366"><vh>ForDictionaryCommon.init</vh></v>
<v t="ekr.20240308084832.1367"><vh>ForDictionaryCommon.gen_condition</vh></v>
<v t="ekr.20240308084832.1368"><vh>ForDictionaryCommon.gen_step</vh></v>
<v t="ekr.20240308084832.1369"><vh>ForDictionaryCommon.gen_cleanup</vh></v>
</v>
<v t="ekr.20240308084832.1370"><vh>class ForDictionaryKeys</vh>
<v t="ekr.20240308084832.1371"><vh>ForDictionaryKeys.begin_body</vh></v>
</v>
<v t="ekr.20240308084832.1372"><vh>class ForDictionaryValues</vh>
<v t="ekr.20240308084832.1373"><vh>ForDictionaryValues.begin_body</vh></v>
</v>
<v t="ekr.20240308084832.1374"><vh>class ForDictionaryItems</vh>
<v t="ekr.20240308084832.1375"><vh>ForDictionaryItems.begin_body</vh></v>
</v>
<v t="ekr.20240308084832.1376"><vh>class ForRange</vh>
<v t="ekr.20240308084832.1377"><vh>ForRange.init</vh></v>
<v t="ekr.20240308084832.1378"><vh>ForRange.gen_condition</vh></v>
<v t="ekr.20240308084832.1379"><vh>ForRange.gen_step</vh></v>
</v>
<v t="ekr.20240308084832.1380"><vh>class ForInfiniteCounter</vh>
<v t="ekr.20240308084832.1381"><vh>ForInfiniteCounter.init</vh></v>
<v t="ekr.20240308084832.1382"><vh>ForInfiniteCounter.gen_step</vh></v>
</v>
<v t="ekr.20240308084832.1383"><vh>class ForEnumerate</vh>
<v t="ekr.20240308084832.1384"><vh>ForEnumerate.need_cleanup</vh></v>
<v t="ekr.20240308084832.1385"><vh>ForEnumerate.init</vh></v>
<v t="ekr.20240308084832.1386"><vh>ForEnumerate.gen_condition</vh></v>
<v t="ekr.20240308084832.1387"><vh>ForEnumerate.begin_body</vh></v>
<v t="ekr.20240308084832.1388"><vh>ForEnumerate.gen_step</vh></v>
<v t="ekr.20240308084832.1389"><vh>ForEnumerate.gen_cleanup</vh></v>
</v>
<v t="ekr.20240308084832.1390"><vh>class ForZip</vh>
<v t="ekr.20240308084832.1391"><vh>ForZip.need_cleanup</vh></v>
<v t="ekr.20240308084832.1392"><vh>ForZip.init</vh></v>
<v t="ekr.20240308084832.1393"><vh>ForZip.gen_condition</vh></v>
<v t="ekr.20240308084832.1394"><vh>ForZip.begin_body</vh></v>
<v t="ekr.20240308084832.1395"><vh>ForZip.gen_step</vh></v>
<v t="ekr.20240308084832.1396"><vh>ForZip.gen_cleanup</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1397"><vh>irbuild/format_str_tokenizer.py</vh>
<v t="ekr.20240308084832.1398"><vh>class FormatOp</vh></v>
<v t="ekr.20240308084832.1399"><vh>function: generate_format_ops</vh></v>
<v t="ekr.20240308084832.1400"><vh>function: tokenizer_printf_style</vh></v>
<v t="ekr.20240308084832.1401"><vh>function: tokenizer_format_call</vh></v>
<v t="ekr.20240308084832.1402"><vh>function: convert_format_expr_to_str</vh></v>
<v t="ekr.20240308084832.1403"><vh>function: join_formatted_strings</vh></v>
<v t="ekr.20240308084832.1404"><vh>function: convert_format_expr_to_bytes</vh></v>
<v t="ekr.20240308084832.1405"><vh>function: join_formatted_bytes</vh></v>
</v>
<v t="ekr.20240308084832.1406"><vh>irbuild/function.py</vh>
<v t="ekr.20240308084832.1407"><vh>function: transform_func_def</vh></v>
<v t="ekr.20240308084832.1408"><vh>function: transform_overloaded_func_def</vh></v>
<v t="ekr.20240308084832.1409"><vh>function: transform_decorator</vh></v>
<v t="ekr.20240308084832.1410"><vh>function: transform_lambda_expr</vh></v>
<v t="ekr.20240308084832.1411"><vh>function: gen_func_item</vh></v>
<v t="ekr.20240308084832.1412"><vh>function: has_nested_func_self_reference</vh></v>
<v t="ekr.20240308084832.1413"><vh>function: gen_func_ir</vh></v>
<v t="ekr.20240308084832.1414"><vh>function: handle_ext_method</vh></v>
<v t="ekr.20240308084832.1415"><vh>function: handle_non_ext_method</vh></v>
<v t="ekr.20240308084832.1416"><vh>function: calculate_arg_defaults</vh></v>
<v t="ekr.20240308084832.1417"><vh>function: gen_func_ns</vh></v>
<v t="ekr.20240308084832.1418"><vh>function: load_decorated_func</vh></v>
<v t="ekr.20240308084832.1419"><vh>function: is_decorated</vh></v>
<v t="ekr.20240308084832.1420"><vh>function: gen_glue</vh></v>
<v t="ekr.20240308084832.1421"><vh>class ArgInfo</vh></v>
<v t="ekr.20240308084832.1422"><vh>function: get_args</vh></v>
<v t="ekr.20240308084832.1423"><vh>function: gen_glue_method</vh></v>
<v t="ekr.20240308084832.1424"><vh>function: check_native_override</vh></v>
<v t="ekr.20240308084832.1425"><vh>function: gen_glue_property</vh></v>
<v t="ekr.20240308084832.1426"><vh>function: get_func_target</vh></v>
<v t="ekr.20240308084832.1427"><vh>function: load_type</vh></v>
<v t="ekr.20240308084832.1428"><vh>function: load_func</vh></v>
<v t="ekr.20240308084832.1429"><vh>function: generate_singledispatch_dispatch_function</vh></v>
<v t="ekr.20240308084832.1430"><vh>function: gen_calls_to_correct_impl</vh></v>
<v t="ekr.20240308084832.1431"><vh>function: gen_dispatch_func_ir</vh></v>
<v t="ekr.20240308084832.1432"><vh>function: generate_dispatch_glue_native_function</vh></v>
<v t="ekr.20240308084832.1433"><vh>function: generate_singledispatch_callable_class_ctor</vh></v>
<v t="ekr.20240308084832.1434"><vh>function: add_register_method_to_callable_class</vh></v>
<v t="ekr.20240308084832.1435"><vh>function: load_singledispatch_registry</vh></v>
<v t="ekr.20240308084832.1436"><vh>function: singledispatch_main_func_name</vh></v>
<v t="ekr.20240308084832.1437"><vh>function: get_registry_identifier</vh></v>
<v t="ekr.20240308084832.1438"><vh>function: maybe_insert_into_registry_dict</vh></v>
<v t="ekr.20240308084832.1439"><vh>function: get_native_impl_ids</vh></v>
<v t="ekr.20240308084832.1440"><vh>function: gen_property_getter_ir</vh></v>
<v t="ekr.20240308084832.1441"><vh>function: gen_property_setter_ir</vh></v>
</v>
<v t="ekr.20240308084832.1442"><vh>irbuild/generator.py</vh>
<v t="ekr.20240308084832.1443"><vh>function: gen_generator_func</vh></v>
<v t="ekr.20240308084832.1444"><vh>function: instantiate_generator_class</vh></v>
<v t="ekr.20240308084832.1445"><vh>function: setup_generator_class</vh></v>
<v t="ekr.20240308084832.1446"><vh>function: create_switch_for_generator_class</vh></v>
<v t="ekr.20240308084832.1447"><vh>function: populate_switch_for_generator_class</vh></v>
<v t="ekr.20240308084832.1448"><vh>function: add_raise_exception_blocks_to_generator_class</vh></v>
<v t="ekr.20240308084832.1449"><vh>function: add_methods_to_generator_class</vh></v>
<v t="ekr.20240308084832.1450"><vh>function: add_helper_to_generator_class</vh></v>
<v t="ekr.20240308084832.1451"><vh>function: add_iter_to_generator_class</vh></v>
<v t="ekr.20240308084832.1452"><vh>function: add_next_to_generator_class</vh></v>
<v t="ekr.20240308084832.1453"><vh>function: add_send_to_generator_class</vh></v>
<v t="ekr.20240308084832.1454"><vh>function: add_throw_to_generator_class</vh></v>
<v t="ekr.20240308084832.1455"><vh>function: add_close_to_generator_class</vh></v>
<v t="ekr.20240308084832.1456"><vh>function: add_await_to_generator_class</vh></v>
<v t="ekr.20240308084832.1457"><vh>function: setup_env_for_generator_class</vh></v>
</v>
<v t="ekr.20240308084832.1458"><vh>irbuild/ll_builder.py</vh>
<v t="ekr.20240308084832.1459"><vh>class LowLevelIRBuilder</vh>
<v t="ekr.20240308084832.1460"><vh>LowLevelIRBuilder.__init__</vh></v>
<v t="ekr.20240308084832.1461"><vh>LowLevelIRBuilder.set_module</vh></v>
<v t="ekr.20240308084832.1462"><vh>LowLevelIRBuilder.add</vh></v>
<v t="ekr.20240308084832.1463"><vh>LowLevelIRBuilder.goto</vh></v>
<v t="ekr.20240308084832.1464"><vh>LowLevelIRBuilder.activate_block</vh></v>
<v t="ekr.20240308084832.1465"><vh>LowLevelIRBuilder.goto_and_activate</vh></v>
<v t="ekr.20240308084832.1466"><vh>LowLevelIRBuilder.keep_alive</vh></v>
<v t="ekr.20240308084832.1467"><vh>LowLevelIRBuilder.push_error_handler</vh></v>
<v t="ekr.20240308084832.1468"><vh>LowLevelIRBuilder.pop_error_handler</vh></v>
<v t="ekr.20240308084832.1469"><vh>LowLevelIRBuilder.self</vh></v>
<v t="ekr.20240308084832.1470"><vh>LowLevelIRBuilder.flush_keep_alives</vh></v>
<v t="ekr.20240308084832.1471"><vh>LowLevelIRBuilder.box</vh></v>
<v t="ekr.20240308084832.1472"><vh>LowLevelIRBuilder.unbox_or_cast</vh></v>
<v t="ekr.20240308084832.1473"><vh>LowLevelIRBuilder.coerce</vh></v>
<v t="ekr.20240308084832.1474"><vh>LowLevelIRBuilder.coerce_int_to_fixed_width</vh></v>
<v t="ekr.20240308084832.1475"><vh>LowLevelIRBuilder.coerce_short_int_to_fixed_width</vh></v>
<v t="ekr.20240308084832.1476"><vh>LowLevelIRBuilder.coerce_fixed_width_to_int</vh></v>
<v t="ekr.20240308084832.1477"><vh>LowLevelIRBuilder.coerce_nullable</vh></v>
<v t="ekr.20240308084832.1478"><vh>LowLevelIRBuilder.get_attr</vh></v>
<v t="ekr.20240308084832.1479"><vh>LowLevelIRBuilder.union_get_attr</vh></v>
<v t="ekr.20240308084832.1480"><vh>LowLevelIRBuilder.py_get_attr</vh></v>
<v t="ekr.20240308084832.1481"><vh>LowLevelIRBuilder.isinstance_helper</vh></v>
<v t="ekr.20240308084832.1482"><vh>LowLevelIRBuilder.get_type_of_obj</vh></v>
<v t="ekr.20240308084832.1483"><vh>LowLevelIRBuilder.type_is_op</vh></v>
<v t="ekr.20240308084832.1484"><vh>LowLevelIRBuilder.isinstance_native</vh></v>
<v t="ekr.20240308084832.1485"><vh>LowLevelIRBuilder._construct_varargs</vh></v>
<v t="ekr.20240308084832.1486"><vh>LowLevelIRBuilder.py_call</vh></v>
<v t="ekr.20240308084832.1487"><vh>LowLevelIRBuilder._py_vector_call</vh></v>
<v t="ekr.20240308084832.1488"><vh>LowLevelIRBuilder._vectorcall_keywords</vh></v>
<v t="ekr.20240308084832.1489"><vh>LowLevelIRBuilder.py_method_call</vh></v>
<v t="ekr.20240308084832.1490"><vh>LowLevelIRBuilder._py_vector_method_call</vh></v>
<v t="ekr.20240308084832.1491"><vh>LowLevelIRBuilder.call</vh></v>
<v t="ekr.20240308084832.1492"><vh>LowLevelIRBuilder.native_args_to_positional</vh></v>
<v t="ekr.20240308084832.1493"><vh>LowLevelIRBuilder.gen_method_call</vh></v>
<v t="ekr.20240308084832.1494"><vh>LowLevelIRBuilder.union_method_call</vh></v>
<v t="ekr.20240308084832.1495"><vh>LowLevelIRBuilder.none</vh></v>
<v t="ekr.20240308084832.1496"><vh>LowLevelIRBuilder.true</vh></v>
<v t="ekr.20240308084832.1497"><vh>LowLevelIRBuilder.false</vh></v>
<v t="ekr.20240308084832.1498"><vh>LowLevelIRBuilder.none_object</vh></v>
<v t="ekr.20240308084832.1499"><vh>LowLevelIRBuilder.load_int</vh></v>
<v t="ekr.20240308084832.1500"><vh>LowLevelIRBuilder.load_float</vh></v>
<v t="ekr.20240308084832.1501"><vh>LowLevelIRBuilder.load_str</vh></v>
<v t="ekr.20240308084832.1502"><vh>LowLevelIRBuilder.load_bytes</vh></v>
<v t="ekr.20240308084832.1503"><vh>LowLevelIRBuilder.load_complex</vh></v>
<v t="ekr.20240308084832.1504"><vh>LowLevelIRBuilder.load_static_checked</vh></v>
<v t="ekr.20240308084832.1505"><vh>LowLevelIRBuilder.load_module</vh></v>
<v t="ekr.20240308084832.1506"><vh>LowLevelIRBuilder.get_native_type</vh></v>
<v t="ekr.20240308084832.1507"><vh>LowLevelIRBuilder.load_native_type_object</vh></v>
<v t="ekr.20240308084832.1508"><vh>LowLevelIRBuilder.binary_op</vh></v>
<v t="ekr.20240308084832.1509"><vh>LowLevelIRBuilder.check_tagged_short_int</vh></v>
<v t="ekr.20240308084832.1510"><vh>LowLevelIRBuilder.compare_tagged</vh></v>
<v t="ekr.20240308084832.1511"><vh>LowLevelIRBuilder.compare_tagged_condition</vh></v>
<v t="ekr.20240308084832.1512"><vh>LowLevelIRBuilder.compare_strings</vh></v>
<v t="ekr.20240308084832.1513"><vh>LowLevelIRBuilder.compare_bytes</vh></v>
<v t="ekr.20240308084832.1514"><vh>LowLevelIRBuilder.compare_tuples</vh></v>
<v t="ekr.20240308084832.1515"><vh>LowLevelIRBuilder.translate_instance_contains</vh></v>
<v t="ekr.20240308084832.1516"><vh>LowLevelIRBuilder.bool_bitwise_op</vh></v>
<v t="ekr.20240308084832.1517"><vh>LowLevelIRBuilder.bool_comparison_op</vh></v>
<v t="ekr.20240308084832.1518"><vh>LowLevelIRBuilder.unary_not</vh></v>
<v t="ekr.20240308084832.1519"><vh>LowLevelIRBuilder.unary_op</vh></v>
<v t="ekr.20240308084832.1520"><vh>LowLevelIRBuilder.make_dict</vh></v>
<v t="ekr.20240308084832.1521"><vh>LowLevelIRBuilder.new_list_op_with_length</vh></v>
<v t="ekr.20240308084832.1522"><vh>LowLevelIRBuilder.new_list_op</vh></v>
<v t="ekr.20240308084832.1523"><vh>LowLevelIRBuilder.new_set_op</vh></v>
<v t="ekr.20240308084832.1524"><vh>LowLevelIRBuilder.setup_rarray</vh></v>
<v t="ekr.20240308084832.1525"><vh>LowLevelIRBuilder.shortcircuit_helper</vh></v>
<v t="ekr.20240308084832.1526"><vh>LowLevelIRBuilder.bool_value</vh></v>
<v t="ekr.20240308084832.1527"><vh>LowLevelIRBuilder.add_bool_branch</vh></v>
<v t="ekr.20240308084832.1528"><vh>LowLevelIRBuilder.call_c</vh></v>
<v t="ekr.20240308084832.1529"><vh>LowLevelIRBuilder.matching_call_c</vh></v>
<v t="ekr.20240308084832.1530"><vh>LowLevelIRBuilder.int_op</vh></v>
<v t="ekr.20240308084832.1531"><vh>LowLevelIRBuilder.float_op</vh></v>
<v t="ekr.20240308084832.1532"><vh>LowLevelIRBuilder.float_mod</vh></v>
<v t="ekr.20240308084832.1533"><vh>LowLevelIRBuilder.compare_floats</vh></v>
<v t="ekr.20240308084832.1534"><vh>LowLevelIRBuilder.fixed_width_int_op</vh></v>
<v t="ekr.20240308084832.1535"><vh>LowLevelIRBuilder.check_for_zero_division</vh></v>
<v t="ekr.20240308084832.1536"><vh>LowLevelIRBuilder.inline_fixed_width_divide</vh></v>
<v t="ekr.20240308084832.1537"><vh>LowLevelIRBuilder.inline_fixed_width_mod</vh></v>
<v t="ekr.20240308084832.1538"><vh>LowLevelIRBuilder.is_same_native_int_signs</vh></v>
<v t="ekr.20240308084832.1539"><vh>LowLevelIRBuilder.is_same_float_signs</vh></v>
<v t="ekr.20240308084832.1540"><vh>LowLevelIRBuilder.comparison_op</vh></v>
<v t="ekr.20240308084832.1541"><vh>LowLevelIRBuilder.builtin_len</vh></v>
<v t="ekr.20240308084832.1542"><vh>LowLevelIRBuilder.new_tuple</vh></v>
<v t="ekr.20240308084832.1543"><vh>LowLevelIRBuilder.new_tuple_with_length</vh></v>
<v t="ekr.20240308084832.1544"><vh>LowLevelIRBuilder.int_to_float</vh></v>
<v t="ekr.20240308084832.1545"><vh>LowLevelIRBuilder.decompose_union_helper</vh></v>
<v t="ekr.20240308084832.1546"><vh>LowLevelIRBuilder.translate_special_method_call</vh></v>
<v t="ekr.20240308084832.1547"><vh>LowLevelIRBuilder.translate_eq_cmp</vh></v>
<v t="ekr.20240308084832.1548"><vh>LowLevelIRBuilder.translate_is_op</vh></v>
<v t="ekr.20240308084832.1549"><vh>LowLevelIRBuilder._create_dict</vh></v>
<v t="ekr.20240308084832.1550"><vh>LowLevelIRBuilder.error</vh></v>
</v>
<v t="ekr.20240308084832.1551"><vh>function: num_positional_args</vh></v>
</v>
<v t="ekr.20240308084832.1552"><vh>irbuild/main.py</vh>
<v t="ekr.20240308084832.1553"><vh>function: build_ir</vh></v>
<v t="ekr.20240308084832.1554"><vh>function: transform_mypy_file</vh></v>
</v>
<v t="ekr.20240308084832.1555"><vh>irbuild/mapper.py</vh>
<v t="ekr.20240308084832.1556"><vh>class Mapper</vh>
<v t="ekr.20240308084832.1557"><vh>Mapper.__init__</vh></v>
<v t="ekr.20240308084832.1558"><vh>Mapper.type_to_rtype</vh></v>
<v t="ekr.20240308084832.1559"><vh>Mapper.get_arg_rtype</vh></v>
<v t="ekr.20240308084832.1560"><vh>Mapper.fdef_to_sig</vh></v>
<v t="ekr.20240308084832.1561"><vh>Mapper.is_native_module</vh></v>
<v t="ekr.20240308084832.1562"><vh>Mapper.is_native_ref_expr</vh></v>
<v t="ekr.20240308084832.1563"><vh>Mapper.is_native_module_ref_expr</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1564"><vh>irbuild/match.py</vh>
<v t="ekr.20240308084832.1565"><vh>class MatchVisitor</vh>
<v t="ekr.20240308084832.1566"><vh>MatchVisitor.__init__</vh></v>
<v t="ekr.20240308084832.1567"><vh>MatchVisitor.build_match_body</vh></v>
<v t="ekr.20240308084832.1568"><vh>MatchVisitor.visit_match_stmt</vh></v>
<v t="ekr.20240308084832.1569"><vh>MatchVisitor.visit_value_pattern</vh></v>
<v t="ekr.20240308084832.1570"><vh>MatchVisitor.visit_or_pattern</vh></v>
<v t="ekr.20240308084832.1571"><vh>MatchVisitor.visit_class_pattern</vh></v>
<v t="ekr.20240308084832.1572"><vh>MatchVisitor.visit_as_pattern</vh></v>
<v t="ekr.20240308084832.1573"><vh>MatchVisitor.visit_singleton_pattern</vh></v>
<v t="ekr.20240308084832.1574"><vh>MatchVisitor.visit_mapping_pattern</vh></v>
<v t="ekr.20240308084832.1575"><vh>MatchVisitor.visit_sequence_pattern</vh></v>
<v t="ekr.20240308084832.1576"><vh>MatchVisitor.bind_as_pattern</vh></v>
<v t="ekr.20240308084832.1577"><vh>MatchVisitor.enter_subpattern</vh></v>
</v>
<v t="ekr.20240308084832.1578"><vh>function: prep_sequence_pattern</vh></v>
</v>
<v t="ekr.20240308084832.1579"><vh>irbuild/nonlocalcontrol.py</vh>
<v t="ekr.20240308084832.1580"><vh>class NonlocalControl</vh>
<v t="ekr.20240308084832.1581"><vh>NonlocalControl.gen_break</vh></v>
<v t="ekr.20240308084832.1582"><vh>NonlocalControl.gen_continue</vh></v>
<v t="ekr.20240308084832.1583"><vh>NonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1584"><vh>class BaseNonlocalControl</vh>
<v t="ekr.20240308084832.1585"><vh>BaseNonlocalControl.gen_break</vh></v>
<v t="ekr.20240308084832.1586"><vh>BaseNonlocalControl.gen_continue</vh></v>
<v t="ekr.20240308084832.1587"><vh>BaseNonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1588"><vh>class LoopNonlocalControl</vh>
<v t="ekr.20240308084832.1589"><vh>LoopNonlocalControl.__init__</vh></v>
<v t="ekr.20240308084832.1590"><vh>LoopNonlocalControl.gen_break</vh></v>
<v t="ekr.20240308084832.1591"><vh>LoopNonlocalControl.gen_continue</vh></v>
<v t="ekr.20240308084832.1592"><vh>LoopNonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1593"><vh>class GeneratorNonlocalControl</vh>
<v t="ekr.20240308084832.1594"><vh>GeneratorNonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1595"><vh>class CleanupNonlocalControl</vh>
<v t="ekr.20240308084832.1596"><vh>CleanupNonlocalControl.__init__</vh></v>
<v t="ekr.20240308084832.1597"><vh>CleanupNonlocalControl.gen_cleanup</vh></v>
<v t="ekr.20240308084832.1598"><vh>CleanupNonlocalControl.gen_break</vh></v>
<v t="ekr.20240308084832.1599"><vh>CleanupNonlocalControl.gen_continue</vh></v>
<v t="ekr.20240308084832.1600"><vh>CleanupNonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1601"><vh>class TryFinallyNonlocalControl</vh>
<v t="ekr.20240308084832.1602"><vh>TryFinallyNonlocalControl.__init__</vh></v>
<v t="ekr.20240308084832.1603"><vh>TryFinallyNonlocalControl.gen_break</vh></v>
<v t="ekr.20240308084832.1604"><vh>TryFinallyNonlocalControl.gen_continue</vh></v>
<v t="ekr.20240308084832.1605"><vh>TryFinallyNonlocalControl.gen_return</vh></v>
</v>
<v t="ekr.20240308084832.1606"><vh>class ExceptNonlocalControl</vh>
<v t="ekr.20240308084832.1607"><vh>ExceptNonlocalControl.__init__</vh></v>
<v t="ekr.20240308084832.1608"><vh>ExceptNonlocalControl.gen_cleanup</vh></v>
</v>
<v t="ekr.20240308084832.1609"><vh>class FinallyNonlocalControl</vh>
<v t="ekr.20240308084832.1610"><vh>FinallyNonlocalControl.__init__</vh></v>
<v t="ekr.20240308084832.1611"><vh>FinallyNonlocalControl.gen_cleanup</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1612"><vh>irbuild/prebuildvisitor.py</vh>
<v t="ekr.20240308084832.1613"><vh>class PreBuildVisitor</vh>
<v t="ekr.20240308084832.1614"><vh>PreBuildVisitor.__init__</vh></v>
<v t="ekr.20240308084832.1615"><vh>PreBuildVisitor.visit</vh></v>
<v t="ekr.20240308084832.1616"><vh>PreBuildVisitor.visit_block</vh></v>
<v t="ekr.20240308084832.1617"><vh>PreBuildVisitor.visit_decorator</vh></v>
<v t="ekr.20240308084832.1618"><vh>PreBuildVisitor.visit_func_def</vh></v>
<v t="ekr.20240308084832.1619"><vh>PreBuildVisitor.visit_lambda_expr</vh></v>
<v t="ekr.20240308084832.1620"><vh>PreBuildVisitor.visit_func</vh></v>
<v t="ekr.20240308084832.1621"><vh>PreBuildVisitor.visit_import</vh></v>
<v t="ekr.20240308084832.1622"><vh>PreBuildVisitor.visit_name_expr</vh></v>
<v t="ekr.20240308084832.1623"><vh>PreBuildVisitor.visit_var</vh></v>
<v t="ekr.20240308084832.1624"><vh>PreBuildVisitor.visit_symbol_node</vh></v>
<v t="ekr.20240308084832.1625"><vh>PreBuildVisitor.is_parent</vh></v>
<v t="ekr.20240308084832.1626"><vh>PreBuildVisitor.add_free_variable</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1627"><vh>irbuild/prepare.py</vh>
<v t="ekr.20240308084832.1628"><vh>function: build_type_map</vh></v>
<v t="ekr.20240308084832.1629"><vh>function: is_from_module</vh></v>
<v t="ekr.20240308084832.1630"><vh>function: load_type_map</vh></v>
<v t="ekr.20240308084832.1631"><vh>function: get_module_func_defs</vh></v>
<v t="ekr.20240308084832.1632"><vh>function: prepare_func_def</vh></v>
<v t="ekr.20240308084832.1633"><vh>function: prepare_method_def</vh></v>
<v t="ekr.20240308084832.1634"><vh>function: is_valid_multipart_property_def</vh></v>
<v t="ekr.20240308084832.1635"><vh>function: can_subclass_builtin</vh></v>
<v t="ekr.20240308084832.1636"><vh>function: prepare_class_def</vh></v>
<v t="ekr.20240308084832.1637"><vh>function: prepare_methods_and_attributes</vh></v>
<v t="ekr.20240308084832.1638"><vh>function: prepare_implicit_property_accessors</vh></v>
<v t="ekr.20240308084832.1639"><vh>function: add_property_methods_for_attribute_if_needed</vh></v>
<v t="ekr.20240308084832.1640"><vh>function: add_getter_declaration</vh></v>
<v t="ekr.20240308084832.1641"><vh>function: add_setter_declaration</vh></v>
<v t="ekr.20240308084832.1642"><vh>function: prepare_init_method</vh></v>
<v t="ekr.20240308084832.1643"><vh>function: prepare_non_ext_class_def</vh></v>
<v t="ekr.20240308084832.1644"><vh>class SingledispatchInfo</vh></v>
<v t="ekr.20240308084832.1645"><vh>function: find_singledispatch_register_impls</vh></v>
<v t="ekr.20240308084832.1646"><vh>class SingledispatchVisitor</vh>
<v t="ekr.20240308084832.1647"><vh>SingledispatchVisitor.__init__</vh></v>
<v t="ekr.20240308084832.1648"><vh>SingledispatchVisitor.visit_decorator</vh></v>
</v>
<v t="ekr.20240308084832.1649"><vh>class RegisteredImpl</vh></v>
<v t="ekr.20240308084832.1650"><vh>function: get_singledispatch_register_call_info</vh></v>
<v t="ekr.20240308084832.1651"><vh>function: registered_impl_from_possible_register_call</vh></v>
</v>
<v t="ekr.20240308084832.1652"><vh>irbuild/specialize.py</vh>
<v t="ekr.20240308084832.1653"><vh>function: _apply_specialization</vh></v>
<v t="ekr.20240308084832.1654"><vh>function: apply_function_specialization</vh></v>
<v t="ekr.20240308084832.1655"><vh>function: apply_method_specialization</vh></v>
<v t="ekr.20240308084832.1656"><vh>function: specialize_function</vh></v>
<v t="ekr.20240308084832.1657"><vh>function: translate_globals</vh></v>
<v t="ekr.20240308084832.1658"><vh>function: translate_builtins_with_unary_dunder</vh></v>
<v t="ekr.20240308084832.1659"><vh>function: translate_len</vh></v>
<v t="ekr.20240308084832.1660"><vh>function: dict_methods_fast_path</vh></v>
<v t="ekr.20240308084832.1661"><vh>function: translate_list_from_generator_call</vh></v>
<v t="ekr.20240308084832.1662"><vh>function: translate_tuple_from_generator_call</vh></v>
<v t="ekr.20240308084832.1663"><vh>function: translate_set_from_generator_call</vh></v>
<v t="ekr.20240308084832.1664"><vh>function: faster_min_max</vh></v>
<v t="ekr.20240308084832.1665"><vh>function: translate_safe_generator_call</vh></v>
<v t="ekr.20240308084832.1666"><vh>function: translate_any_call</vh></v>
<v t="ekr.20240308084832.1667"><vh>function: translate_all_call</vh></v>
<v t="ekr.20240308084832.1668"><vh>function: any_all_helper</vh></v>
<v t="ekr.20240308084832.1669"><vh>function: translate_sum_call</vh></v>
<v t="ekr.20240308084832.1670"><vh>function: translate_dataclasses_field_call</vh></v>
<v t="ekr.20240308084832.1671"><vh>function: translate_next_call</vh></v>
<v t="ekr.20240308084832.1672"><vh>function: translate_isinstance</vh></v>
<v t="ekr.20240308084832.1673"><vh>function: translate_dict_setdefault</vh></v>
<v t="ekr.20240308084832.1674"><vh>function: translate_str_format</vh></v>
<v t="ekr.20240308084832.1675"><vh>function: translate_fstring</vh></v>
<v t="ekr.20240308084832.1676"><vh>function: translate_i64</vh></v>
<v t="ekr.20240308084832.1677"><vh>function: translate_i32</vh></v>
<v t="ekr.20240308084832.1678"><vh>function: translate_i16</vh></v>
<v t="ekr.20240308084832.1679"><vh>function: translate_u8</vh></v>
<v t="ekr.20240308084832.1680"><vh>function: truncate_literal</vh></v>
<v t="ekr.20240308084832.1681"><vh>function: translate_int</vh></v>
<v t="ekr.20240308084832.1682"><vh>function: translate_bool</vh></v>
<v t="ekr.20240308084832.1683"><vh>function: translate_float</vh></v>
</v>
<v t="ekr.20240308084832.1684"><vh>irbuild/statement.py</vh>
<v t="ekr.20240308084832.1685"><vh>function: transform_block</vh></v>
<v t="ekr.20240308084832.1686"><vh>function: transform_expression_stmt</vh></v>
<v t="ekr.20240308084832.1687"><vh>function: transform_return_stmt</vh></v>
<v t="ekr.20240308084832.1688"><vh>function: transform_assignment_stmt</vh></v>
<v t="ekr.20240308084832.1689"><vh>function: is_simple_lvalue</vh></v>
<v t="ekr.20240308084832.1690"><vh>function: transform_operator_assignment_stmt</vh></v>
<v t="ekr.20240308084832.1691"><vh>function: import_globals_id_and_name</vh></v>
<v t="ekr.20240308084832.1692"><vh>function: transform_import</vh></v>
<v t="ekr.20240308084832.1693"><vh>function: transform_import_from</vh></v>
<v t="ekr.20240308084832.1694"><vh>function: transform_import_all</vh></v>
<v t="ekr.20240308084832.1695"><vh>function: transform_if_stmt</vh></v>
<v t="ekr.20240308084832.1696"><vh>function: transform_while_stmt</vh></v>
<v t="ekr.20240308084832.1697"><vh>function: transform_for_stmt</vh></v>
<v t="ekr.20240308084832.1698"><vh>function: transform_break_stmt</vh></v>
<v t="ekr.20240308084832.1699"><vh>function: transform_continue_stmt</vh></v>
<v t="ekr.20240308084832.1700"><vh>function: transform_raise_stmt</vh></v>
<v t="ekr.20240308084832.1701"><vh>function: transform_try_except</vh></v>
<v t="ekr.20240308084832.1702"><vh>function: transform_try_except_stmt</vh></v>
<v t="ekr.20240308084832.1703"><vh>function: try_finally_try</vh></v>
<v t="ekr.20240308084832.1704"><vh>function: try_finally_entry_blocks</vh></v>
<v t="ekr.20240308084832.1705"><vh>function: try_finally_body</vh></v>
<v t="ekr.20240308084832.1706"><vh>function: try_finally_resolve_control</vh></v>
<v t="ekr.20240308084832.1707"><vh>function: transform_try_finally_stmt</vh></v>
<v t="ekr.20240308084832.1708"><vh>function: transform_try_stmt</vh></v>
<v t="ekr.20240308084832.1709"><vh>function: get_sys_exc_info</vh></v>
<v t="ekr.20240308084832.1710"><vh>function: transform_with</vh></v>
<v t="ekr.20240308084832.1711"><vh>function: transform_with_stmt</vh></v>
<v t="ekr.20240308084832.1712"><vh>function: transform_assert_stmt</vh></v>
<v t="ekr.20240308084832.1713"><vh>function: transform_del_stmt</vh></v>
<v t="ekr.20240308084832.1714"><vh>function: transform_del_item</vh></v>
<v t="ekr.20240308084832.1715"><vh>function: emit_yield</vh></v>
<v t="ekr.20240308084832.1716"><vh>function: emit_yield_from_or_await</vh></v>
<v t="ekr.20240308084832.1717"><vh>function: emit_await</vh></v>
<v t="ekr.20240308084832.1718"><vh>function: transform_yield_expr</vh></v>
<v t="ekr.20240308084832.1719"><vh>function: transform_yield_from_expr</vh></v>
<v t="ekr.20240308084832.1720"><vh>function: transform_await_expr</vh></v>
<v t="ekr.20240308084832.1721"><vh>function: transform_match_stmt</vh></v>
</v>
<v t="ekr.20240308084832.1722"><vh>irbuild/targets.py</vh>
<v t="ekr.20240308084832.1723"><vh>class AssignmentTarget</vh></v>
<v t="ekr.20240308084832.1724"><vh>class AssignmentTargetRegister</vh>
<v t="ekr.20240308084832.1725"><vh>AssignmentTargetRegister.__init__</vh></v>
</v>
<v t="ekr.20240308084832.1726"><vh>class AssignmentTargetIndex</vh>
<v t="ekr.20240308084832.1727"><vh>AssignmentTargetIndex.__init__</vh></v>
</v>
<v t="ekr.20240308084832.1728"><vh>class AssignmentTargetAttr</vh>
<v t="ekr.20240308084832.1729"><vh>AssignmentTargetAttr.__init__</vh></v>
</v>
<v t="ekr.20240308084832.1730"><vh>class AssignmentTargetTuple</vh>
<v t="ekr.20240308084832.1731"><vh>AssignmentTargetTuple.__init__</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1732"><vh>irbuild/util.py</vh>
<v t="ekr.20240308084832.1733"><vh>function: is_trait_decorator</vh></v>
<v t="ekr.20240308084832.1734"><vh>function: is_trait</vh></v>
<v t="ekr.20240308084832.1735"><vh>function: dataclass_decorator_type</vh></v>
<v t="ekr.20240308084832.1736"><vh>function: is_dataclass_decorator</vh></v>
<v t="ekr.20240308084832.1737"><vh>function: is_dataclass</vh></v>
<v t="ekr.20240308084832.1738"><vh>function: dataclass_type</vh></v>
<v t="ekr.20240308084832.1739"><vh>function: get_mypyc_attr_literal</vh></v>
<v t="ekr.20240308084832.1740"><vh>function: get_mypyc_attr_call</vh></v>
<v t="ekr.20240308084832.1741"><vh>function: get_mypyc_attrs</vh></v>
<v t="ekr.20240308084832.1742"><vh>function: is_extension_class</vh></v>
<v t="ekr.20240308084832.1743"><vh>function: get_func_def</vh></v>
<v t="ekr.20240308084832.1744"><vh>function: concrete_arg_kind</vh></v>
<v t="ekr.20240308084832.1745"><vh>function: is_constant</vh></v>
<v t="ekr.20240308084832.1746"><vh>function: bytes_from_str</vh></v>
</v>
<v t="ekr.20240308084832.1747"><vh>irbuild/visitor.py</vh>
<v t="ekr.20240308084832.1748"><vh>class IRBuilderVisitor</vh>
<v t="ekr.20240308084832.1749"><vh>IRBuilderVisitor.visit_mypy_file</vh></v>
<v t="ekr.20240308084832.1750"><vh>IRBuilderVisitor.visit_class_def</vh></v>
<v t="ekr.20240308084832.1751"><vh>IRBuilderVisitor.visit_import</vh></v>
<v t="ekr.20240308084832.1752"><vh>IRBuilderVisitor.visit_import_from</vh></v>
<v t="ekr.20240308084832.1753"><vh>IRBuilderVisitor.visit_import_all</vh></v>
<v t="ekr.20240308084832.1754"><vh>IRBuilderVisitor.visit_func_def</vh></v>
<v t="ekr.20240308084832.1755"><vh>IRBuilderVisitor.visit_overloaded_func_def</vh></v>
<v t="ekr.20240308084832.1756"><vh>IRBuilderVisitor.visit_decorator</vh></v>
<v t="ekr.20240308084832.1757"><vh>IRBuilderVisitor.visit_block</vh></v>
<v t="ekr.20240308084832.1758"><vh>IRBuilderVisitor.visit_expression_stmt</vh></v>
<v t="ekr.20240308084832.1759"><vh>IRBuilderVisitor.visit_return_stmt</vh></v>
<v t="ekr.20240308084832.1760"><vh>IRBuilderVisitor.visit_assignment_stmt</vh></v>
<v t="ekr.20240308084832.1761"><vh>IRBuilderVisitor.visit_operator_assignment_stmt</vh></v>
<v t="ekr.20240308084832.1762"><vh>IRBuilderVisitor.visit_if_stmt</vh></v>
<v t="ekr.20240308084832.1763"><vh>IRBuilderVisitor.visit_while_stmt</vh></v>
<v t="ekr.20240308084832.1764"><vh>IRBuilderVisitor.visit_for_stmt</vh></v>
<v t="ekr.20240308084832.1765"><vh>IRBuilderVisitor.visit_break_stmt</vh></v>
<v t="ekr.20240308084832.1766"><vh>IRBuilderVisitor.visit_continue_stmt</vh></v>
<v t="ekr.20240308084832.1767"><vh>IRBuilderVisitor.visit_raise_stmt</vh></v>
<v t="ekr.20240308084832.1768"><vh>IRBuilderVisitor.visit_try_stmt</vh></v>
<v t="ekr.20240308084832.1769"><vh>IRBuilderVisitor.visit_with_stmt</vh></v>
<v t="ekr.20240308084832.1770"><vh>IRBuilderVisitor.visit_pass_stmt</vh></v>
<v t="ekr.20240308084832.1771"><vh>IRBuilderVisitor.visit_assert_stmt</vh></v>
<v t="ekr.20240308084832.1772"><vh>IRBuilderVisitor.visit_del_stmt</vh></v>
<v t="ekr.20240308084832.1773"><vh>IRBuilderVisitor.visit_global_decl</vh></v>
<v t="ekr.20240308084832.1774"><vh>IRBuilderVisitor.visit_nonlocal_decl</vh></v>
<v t="ekr.20240308084832.1775"><vh>IRBuilderVisitor.visit_match_stmt</vh></v>
<v t="ekr.20240308084832.1776"><vh>IRBuilderVisitor.visit_name_expr</vh></v>
<v t="ekr.20240308084832.1777"><vh>IRBuilderVisitor.visit_member_expr</vh></v>
<v t="ekr.20240308084832.1778"><vh>IRBuilderVisitor.visit_super_expr</vh></v>
<v t="ekr.20240308084832.1779"><vh>IRBuilderVisitor.visit_call_expr</vh></v>
<v t="ekr.20240308084832.1780"><vh>IRBuilderVisitor.visit_unary_expr</vh></v>
<v t="ekr.20240308084832.1781"><vh>IRBuilderVisitor.visit_op_expr</vh></v>
<v t="ekr.20240308084832.1782"><vh>IRBuilderVisitor.visit_index_expr</vh></v>
<v t="ekr.20240308084832.1783"><vh>IRBuilderVisitor.visit_conditional_expr</vh></v>
<v t="ekr.20240308084832.1784"><vh>IRBuilderVisitor.visit_comparison_expr</vh></v>
<v t="ekr.20240308084832.1785"><vh>IRBuilderVisitor.visit_int_expr</vh></v>
<v t="ekr.20240308084832.1786"><vh>IRBuilderVisitor.visit_float_expr</vh></v>
<v t="ekr.20240308084832.1787"><vh>IRBuilderVisitor.visit_complex_expr</vh></v>
<v t="ekr.20240308084832.1788"><vh>IRBuilderVisitor.visit_str_expr</vh></v>
<v t="ekr.20240308084832.1789"><vh>IRBuilderVisitor.visit_bytes_expr</vh></v>
<v t="ekr.20240308084832.1790"><vh>IRBuilderVisitor.visit_ellipsis</vh></v>
<v t="ekr.20240308084832.1791"><vh>IRBuilderVisitor.visit_list_expr</vh></v>
<v t="ekr.20240308084832.1792"><vh>IRBuilderVisitor.visit_tuple_expr</vh></v>
<v t="ekr.20240308084832.1793"><vh>IRBuilderVisitor.visit_dict_expr</vh></v>
<v t="ekr.20240308084832.1794"><vh>IRBuilderVisitor.visit_set_expr</vh></v>
<v t="ekr.20240308084832.1795"><vh>IRBuilderVisitor.visit_list_comprehension</vh></v>
<v t="ekr.20240308084832.1796"><vh>IRBuilderVisitor.visit_set_comprehension</vh></v>
<v t="ekr.20240308084832.1797"><vh>IRBuilderVisitor.visit_dictionary_comprehension</vh></v>
<v t="ekr.20240308084832.1798"><vh>IRBuilderVisitor.visit_slice_expr</vh></v>
<v t="ekr.20240308084832.1799"><vh>IRBuilderVisitor.visit_generator_expr</vh></v>
<v t="ekr.20240308084832.1800"><vh>IRBuilderVisitor.visit_lambda_expr</vh></v>
<v t="ekr.20240308084832.1801"><vh>IRBuilderVisitor.visit_yield_expr</vh></v>
<v t="ekr.20240308084832.1802"><vh>IRBuilderVisitor.visit_yield_from_expr</vh></v>
<v t="ekr.20240308084832.1803"><vh>IRBuilderVisitor.visit_await_expr</vh></v>
<v t="ekr.20240308084832.1804"><vh>IRBuilderVisitor.visit_assignment_expr</vh></v>
<v t="ekr.20240308084832.1805"><vh>IRBuilderVisitor.visit_enum_call_expr</vh></v>
<v t="ekr.20240308084832.1806"><vh>IRBuilderVisitor.visit__promote_expr</vh></v>
<v t="ekr.20240308084832.1807"><vh>IRBuilderVisitor.visit_namedtuple_expr</vh></v>
<v t="ekr.20240308084832.1808"><vh>IRBuilderVisitor.visit_newtype_expr</vh></v>
<v t="ekr.20240308084832.1809"><vh>IRBuilderVisitor.visit_temp_node</vh></v>
<v t="ekr.20240308084832.1810"><vh>IRBuilderVisitor.visit_type_alias_expr</vh></v>
<v t="ekr.20240308084832.1811"><vh>IRBuilderVisitor.visit_type_application</vh></v>
<v t="ekr.20240308084832.1812"><vh>IRBuilderVisitor.visit_type_var_expr</vh></v>
<v t="ekr.20240308084832.1813"><vh>IRBuilderVisitor.visit_paramspec_expr</vh></v>
<v t="ekr.20240308084832.1814"><vh>IRBuilderVisitor.visit_type_var_tuple_expr</vh></v>
<v t="ekr.20240308084832.1815"><vh>IRBuilderVisitor.visit_typeddict_expr</vh></v>
<v t="ekr.20240308084832.1816"><vh>IRBuilderVisitor.visit_reveal_expr</vh></v>
<v t="ekr.20240308084832.1817"><vh>IRBuilderVisitor.visit_var</vh></v>
<v t="ekr.20240308084832.1818"><vh>IRBuilderVisitor.visit_cast_expr</vh></v>
<v t="ekr.20240308084832.1819"><vh>IRBuilderVisitor.visit_assert_type_expr</vh></v>
<v t="ekr.20240308084832.1820"><vh>IRBuilderVisitor.visit_star_expr</vh></v>
<v t="ekr.20240308084832.1821"><vh>IRBuilderVisitor.bail</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1822"><vh>irbuild/vtable.py</vh>
<v t="ekr.20240308084832.1823"><vh>function: compute_vtable</vh></v>
<v t="ekr.20240308084832.1824"><vh>function: specialize_parent_vtable</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1825"><vh>lib-rt</vh>
<v t="ekr.20240308084832.1826"><vh>lib-rt/setup.py</vh>
<v t="ekr.20240308084832.1827"><vh>class build_ext_custom</vh>
<v t="ekr.20240308084832.1828"><vh>build_ext_custom.get_library_names</vh></v>
<v t="ekr.20240308084832.1829"><vh>build_ext_custom.run</vh></v>
</v>
</v>
</v>
<v t="ekr.20240308084832.1830"><vh>primitives</vh>
<v t="ekr.20240308084832.1831"><vh>primitives/__init__.py</vh></v>
<v t="ekr.20240308084832.1832"><vh>primitives/bytes_ops.py</vh></v>
<v t="ekr.20240308084832.1833"><vh>primitives/dict_ops.py</vh></v>
<v t="ekr.20240308084832.1834"><vh>primitives/exc_ops.py</vh></v>
<v t="ekr.20240308084832.1835"><vh>primitives/float_ops.py</vh></v>
<v t="ekr.20240308084832.1836"><vh>primitives/generic_ops.py</vh></v>
<v t="ekr.20240308084832.1837"><vh>primitives/int_ops.py</vh>
<v t="ekr.20240308084832.1838"><vh>function: int_binary_op</vh></v>
<v t="ekr.20240308084832.1839"><vh>function: int_unary_op</vh></v>
<v t="ekr.20240308084832.1840"><vh>class IntComparisonOpDescription</vh></v>
</v>
<v t="ekr.20240308084832.1841"><vh>primitives/list_ops.py</vh></v>
<v t="ekr.20240308084832.1842"><vh>primitives/misc_ops.py</vh></v>
<v t="ekr.20240308084832.1843"><vh>primitives/registry.py</vh>
<v t="ekr.20240308084832.1844"><vh>class CFunctionDescription</vh></v>
<v t="ekr.20240308084832.1845"><vh>class LoadAddressDescription</vh></v>
<v t="ekr.20240308084832.1846"><vh>function: method_op</vh></v>
<v t="ekr.20240308084832.1847"><vh>function: function_op</vh></v>
<v t="ekr.20240308084832.1848"><vh>function: binary_op</vh></v>
<v t="ekr.20240308084832.1849"><vh>function: custom_op</vh></v>
<v t="ekr.20240308084832.1850"><vh>function: unary_op</vh></v>
<v t="ekr.20240308084832.1851"><vh>function: load_address_op</vh></v>
</v>
<v t="ekr.20240308084832.1852"><vh>primitives/set_ops.py</vh></v>
<v t="ekr.20240308084832.1853"><vh>primitives/str_ops.py</vh></v>
<v t="ekr.20240308084832.1854"><vh>primitives/tuple_ops.py</vh></v>
</v>
<v t="ekr.20240308084832.1855"><vh>test</vh>
<v t="ekr.20240308084832.1856"><vh>test/__init__.py</vh></v>
<v t="ekr.20240308084832.1857"><vh>test/config.py</vh></v>
<v t="ekr.20240308084832.1858"><vh>test/test_alwaysdefined.py</vh>
<v t="ekr.20240308084832.1859"><vh>class TestAlwaysDefined</vh>
<v t="ekr.20240308084832.1860"><vh>TestAlwaysDefined.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1861"><vh>test/test_analysis.py</vh>
<v t="ekr.20240308084832.1862"><vh>class TestAnalysis</vh>
<v t="ekr.20240308084832.1863"><vh>TestAnalysis.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1864"><vh>test/test_cheader.py</vh>
<v t="ekr.20240308084832.1865"><vh>class TestHeaderInclusion</vh>
<v t="ekr.20240308084832.1866"><vh>TestHeaderInclusion.test_primitives_included_in_header</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1867"><vh>test/test_commandline.py</vh>
<v t="ekr.20240308084832.1868"><vh>class TestCommandLine</vh>
<v t="ekr.20240308084832.1869"><vh>TestCommandLine.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1870"><vh>test/test_emit.py</vh>
<v t="ekr.20240308084832.1871"><vh>class TestEmitter</vh>
<v t="ekr.20240308084832.1872"><vh>TestEmitter.setUp</vh></v>
<v t="ekr.20240308084832.1873"><vh>TestEmitter.test_label</vh></v>
<v t="ekr.20240308084832.1874"><vh>TestEmitter.test_reg</vh></v>
<v t="ekr.20240308084832.1875"><vh>TestEmitter.test_object_annotation</vh></v>
<v t="ekr.20240308084832.1876"><vh>TestEmitter.test_emit_line</vh></v>
<v t="ekr.20240308084832.1877"><vh>TestEmitter.test_emit_undefined_value_for_simple_type</vh></v>
<v t="ekr.20240308084832.1878"><vh>TestEmitter.test_emit_undefined_value_for_tuple</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1879"><vh>test/test_emitclass.py</vh>
<v t="ekr.20240308084832.1880"><vh>class TestEmitClass</vh>
<v t="ekr.20240308084832.1881"><vh>TestEmitClass.test_slot_key</vh></v>
<v t="ekr.20240308084832.1882"><vh>TestEmitClass.test_setter_name</vh></v>
<v t="ekr.20240308084832.1883"><vh>TestEmitClass.test_getter_name</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1884"><vh>test/test_emitfunc.py</vh>
<v t="ekr.20240308084832.1885"><vh>class TestFunctionEmitterVisitor</vh>
<v t="ekr.20240308084832.1886"><vh>TestFunctionEmitterVisitor.setUp</vh></v>
<v t="ekr.20240308084832.1887"><vh>TestFunctionEmitterVisitor.test_goto</vh></v>
<v t="ekr.20240308084832.1888"><vh>TestFunctionEmitterVisitor.test_goto_next_block</vh></v>
<v t="ekr.20240308084832.1889"><vh>TestFunctionEmitterVisitor.test_return</vh></v>
<v t="ekr.20240308084832.1890"><vh>TestFunctionEmitterVisitor.test_integer</vh></v>
<v t="ekr.20240308084832.1891"><vh>TestFunctionEmitterVisitor.test_tuple_get</vh></v>
<v t="ekr.20240308084832.1892"><vh>TestFunctionEmitterVisitor.test_load_None</vh></v>
<v t="ekr.20240308084832.1893"><vh>TestFunctionEmitterVisitor.test_assign_int</vh></v>
<v t="ekr.20240308084832.1894"><vh>TestFunctionEmitterVisitor.test_int_add</vh></v>
<v t="ekr.20240308084832.1895"><vh>TestFunctionEmitterVisitor.test_int_sub</vh></v>
<v t="ekr.20240308084832.1896"><vh>TestFunctionEmitterVisitor.test_int_neg</vh></v>
<v t="ekr.20240308084832.1897"><vh>TestFunctionEmitterVisitor.test_branch</vh></v>
</v>
<v t="ekr.20240308084832.1898"><vh>function: test_branch_no_else</vh></v>
<v t="ekr.20240308084832.1899"><vh>function: test_branch_no_else_negated</vh></v>
<v t="ekr.20240308084832.1900"><vh>function: test_branch_is_error</vh></v>
<v t="ekr.20240308084832.1901"><vh>function: test_branch_is_error_next_block</vh></v>
<v t="ekr.20240308084832.1902"><vh>function: test_branch_rare</vh></v>
<v t="ekr.20240308084832.1903"><vh>function: test_call</vh></v>
<v t="ekr.20240308084832.1904"><vh>function: test_call_two_args</vh></v>
<v t="ekr.20240308084832.1905"><vh>function: test_inc_ref</vh></v>
<v t="ekr.20240308084832.1906"><vh>function: test_dec_ref</vh></v>
<v t="ekr.20240308084832.1907"><vh>function: test_inc_ref_int</vh></v>
<v t="ekr.20240308084832.1908"><vh>function: test_dec_ref_int</vh></v>
<v t="ekr.20240308084832.1909"><vh>function: test_dec_ref_tuple</vh></v>
<v t="ekr.20240308084832.1910"><vh>function: test_dec_ref_tuple_nested</vh></v>
<v t="ekr.20240308084832.1911"><vh>function: test_list_get_item</vh></v>
<v t="ekr.20240308084832.1912"><vh>function: test_list_set_item</vh></v>
<v t="ekr.20240308084832.1913"><vh>function: test_box_int</vh></v>
<v t="ekr.20240308084832.1914"><vh>function: test_unbox_int</vh></v>
<v t="ekr.20240308084832.1915"><vh>function: test_box_i64</vh></v>
<v t="ekr.20240308084832.1916"><vh>function: test_unbox_i64</vh></v>
<v t="ekr.20240308084832.1917"><vh>function: test_list_append</vh></v>
<v t="ekr.20240308084832.1918"><vh>function: test_get_attr</vh></v>
<v t="ekr.20240308084832.1919"><vh>function: test_get_attr_non_refcounted</vh></v>
<v t="ekr.20240308084832.1920"><vh>function: test_get_attr_merged</vh></v>
<v t="ekr.20240308084832.1921"><vh>function: test_get_attr_with_bitmap</vh></v>
<v t="ekr.20240308084832.1922"><vh>function: test_set_attr</vh></v>
<v t="ekr.20240308084832.1923"><vh>function: test_set_attr_non_refcounted</vh></v>
<v t="ekr.20240308084832.1924"><vh>function: test_set_attr_no_error</vh></v>
<v t="ekr.20240308084832.1925"><vh>function: test_set_attr_non_refcounted_no_error</vh></v>
<v t="ekr.20240308084832.1926"><vh>function: test_set_attr_with_bitmap</vh></v>
<v t="ekr.20240308084832.1927"><vh>function: test_set_attr_init_with_bitmap</vh></v>
<v t="ekr.20240308084832.1928"><vh>function: test_dict_get_item</vh></v>
<v t="ekr.20240308084832.1929"><vh>function: test_dict_set_item</vh></v>
<v t="ekr.20240308084832.1930"><vh>function: test_dict_update</vh></v>
<v t="ekr.20240308084832.1931"><vh>function: test_new_dict</vh></v>
<v t="ekr.20240308084832.1932"><vh>function: test_dict_contains</vh></v>
<v t="ekr.20240308084832.1933"><vh>function: test_int_op</vh></v>
<v t="ekr.20240308084832.1934"><vh>function: test_comparison_op</vh></v>
<v t="ekr.20240308084832.1935"><vh>function: test_load_mem</vh></v>
<v t="ekr.20240308084832.1936"><vh>function: test_set_mem</vh></v>
<v t="ekr.20240308084832.1937"><vh>function: test_get_element_ptr</vh></v>
<v t="ekr.20240308084832.1938"><vh>function: test_load_address</vh></v>
<v t="ekr.20240308084832.1939"><vh>function: test_assign_multi</vh></v>
<v t="ekr.20240308084832.1940"><vh>function: test_long_unsigned</vh></v>
<v t="ekr.20240308084832.1941"><vh>function: test_long_signed</vh></v>
<v t="ekr.20240308084832.1942"><vh>function: test_cast_and_branch_merge</vh></v>
<v t="ekr.20240308084832.1943"><vh>function: test_cast_and_branch_no_merge_1</vh></v>
<v t="ekr.20240308084832.1944"><vh>function: test_cast_and_branch_no_merge_2</vh></v>
<v t="ekr.20240308084832.1945"><vh>function: test_cast_and_branch_no_merge_3</vh></v>
<v t="ekr.20240308084832.1946"><vh>function: test_cast_and_branch_no_merge_4</vh></v>
<v t="ekr.20240308084832.1947"><vh>function: test_extend</vh></v>
<v t="ekr.20240308084832.1948"><vh>function: assert_emit</vh></v>
<v t="ekr.20240308084832.1949"><vh>function: assert_emit_binary_op</vh></v>
<v t="ekr.20240308084832.1950"><vh>class TestGenerateFunction</vh>
<v t="ekr.20240308084832.1951"><vh>TestGenerateFunction.setUp</vh></v>
<v t="ekr.20240308084832.1952"><vh>TestGenerateFunction.test_simple</vh></v>
<v t="ekr.20240308084832.1953"><vh>TestGenerateFunction.test_register</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1954"><vh>test/test_emitwrapper.py</vh>
<v t="ekr.20240308084832.1955"><vh>class TestArgCheck</vh>
<v t="ekr.20240308084832.1956"><vh>TestArgCheck.setUp</vh></v>
<v t="ekr.20240308084832.1957"><vh>TestArgCheck.test_check_list</vh></v>
<v t="ekr.20240308084832.1958"><vh>TestArgCheck.test_check_int</vh></v>
<v t="ekr.20240308084832.1959"><vh>TestArgCheck.assert_lines</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1960"><vh>test/test_exceptions.py</vh>
<v t="ekr.20240308084832.1961"><vh>class TestExceptionTransform</vh>
<v t="ekr.20240308084832.1962"><vh>TestExceptionTransform.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1963"><vh>test/test_external.py</vh>
<v t="ekr.20240308084832.1964"><vh>class TestExternal</vh>
<v t="ekr.20240308084832.1965"><vh>TestExternal.test_c_unit_test</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1966"><vh>test/test_irbuild.py</vh>
<v t="ekr.20240308084832.1967"><vh>class TestGenOps</vh>
<v t="ekr.20240308084832.1968"><vh>TestGenOps.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1969"><vh>test/test_ircheck.py</vh>
<v t="ekr.20240308084832.1970"><vh>function: assert_has_error</vh></v>
<v t="ekr.20240308084832.1971"><vh>function: assert_no_errors</vh></v>
<v t="ekr.20240308084832.1972"><vh>class TestIrcheck</vh>
<v t="ekr.20240308084832.1973"><vh>TestIrcheck.setUp</vh></v>
<v t="ekr.20240308084832.1974"><vh>TestIrcheck.basic_block</vh></v>
<v t="ekr.20240308084832.1975"><vh>TestIrcheck.func_decl</vh></v>
<v t="ekr.20240308084832.1976"><vh>TestIrcheck.test_valid_fn</vh></v>
<v t="ekr.20240308084832.1977"><vh>TestIrcheck.test_block_not_terminated_empty_block</vh></v>
<v t="ekr.20240308084832.1978"><vh>TestIrcheck.test_valid_goto</vh></v>
<v t="ekr.20240308084832.1979"><vh>TestIrcheck.test_invalid_goto</vh></v>
<v t="ekr.20240308084832.1980"><vh>TestIrcheck.test_invalid_register_source</vh></v>
<v t="ekr.20240308084832.1981"><vh>TestIrcheck.test_invalid_op_source</vh></v>
<v t="ekr.20240308084832.1982"><vh>TestIrcheck.test_invalid_return_type</vh></v>
<v t="ekr.20240308084832.1983"><vh>TestIrcheck.test_invalid_assign</vh></v>
<v t="ekr.20240308084832.1984"><vh>TestIrcheck.test_can_coerce_to</vh></v>
<v t="ekr.20240308084832.1985"><vh>TestIrcheck.test_duplicate_op</vh></v>
<v t="ekr.20240308084832.1986"><vh>TestIrcheck.test_pprint</vh></v>
<v t="ekr.20240308084832.1987"><vh>TestIrcheck.test_load_address_declares_register</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1988"><vh>test/test_literals.py</vh>
<v t="ekr.20240308084832.1989"><vh>class TestLiterals</vh>
<v t="ekr.20240308084832.1990"><vh>TestLiterals.test_format_str_literal</vh></v>
<v t="ekr.20240308084832.1991"><vh>TestLiterals.test_encode_str_values</vh></v>
<v t="ekr.20240308084832.1992"><vh>TestLiterals.test_encode_bytes_values</vh></v>
<v t="ekr.20240308084832.1993"><vh>TestLiterals.test_encode_int_values</vh></v>
<v t="ekr.20240308084832.1994"><vh>TestLiterals.test_simple_literal_index</vh></v>
<v t="ekr.20240308084832.1995"><vh>TestLiterals.test_tuple_literal</vh></v>
</v>
</v>
<v t="ekr.20240308084832.1996"><vh>test/test_namegen.py</vh>
<v t="ekr.20240308084832.1997"><vh>class TestNameGen</vh>
<v t="ekr.20240308084832.1998"><vh>TestNameGen.test_candidate_suffixes</vh></v>
<v t="ekr.20240308084832.1999"><vh>TestNameGen.test_exported_name</vh></v>
<v t="ekr.20240308084832.2000"><vh>TestNameGen.test_make_module_translation_map</vh></v>
<v t="ekr.20240308084832.2001"><vh>TestNameGen.test_name_generator</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2002"><vh>test/test_pprint.py</vh>
<v t="ekr.20240308084832.2003"><vh>function: register</vh></v>
<v t="ekr.20240308084832.2004"><vh>function: make_block</vh></v>
<v t="ekr.20240308084832.2005"><vh>class TestGenerateNames</vh>
<v t="ekr.20240308084832.2006"><vh>TestGenerateNames.test_empty</vh></v>
<v t="ekr.20240308084832.2007"><vh>TestGenerateNames.test_arg</vh></v>
<v t="ekr.20240308084832.2008"><vh>TestGenerateNames.test_int_op</vh></v>
<v t="ekr.20240308084832.2009"><vh>TestGenerateNames.test_assign</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2010"><vh>test/test_rarray.py</vh>
<v t="ekr.20240308084832.2011"><vh>class TestRArray</vh>
<v t="ekr.20240308084832.2012"><vh>TestRArray.test_basics</vh></v>
<v t="ekr.20240308084832.2013"><vh>TestRArray.test_str_conversion</vh></v>
<v t="ekr.20240308084832.2014"><vh>TestRArray.test_eq</vh></v>
<v t="ekr.20240308084832.2015"><vh>TestRArray.test_hash</vh></v>
<v t="ekr.20240308084832.2016"><vh>TestRArray.test_alignment</vh></v>
<v t="ekr.20240308084832.2017"><vh>TestRArray.test_size</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2018"><vh>test/test_refcount.py</vh>
<v t="ekr.20240308084832.2019"><vh>class TestRefCountTransform</vh>
<v t="ekr.20240308084832.2020"><vh>TestRefCountTransform.run_case</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2021"><vh>test/test_run.py</vh>
<v t="ekr.20240308084832.2022"><vh>function: run_setup</vh></v>
<v t="ekr.20240308084832.2023"><vh>function: chdir_manager</vh></v>
<v t="ekr.20240308084832.2024"><vh>class TestRun</vh>
<v t="ekr.20240308084832.2025"><vh>TestRun.run_case</vh></v>
<v t="ekr.20240308084832.2026"><vh>TestRun.run_case_inner</vh></v>
<v t="ekr.20240308084832.2027"><vh>TestRun.run_case_step</vh></v>
<v t="ekr.20240308084832.2028"><vh>TestRun.get_separate</vh></v>
</v>
<v t="ekr.20240308084832.2029"><vh>class TestRunMultiFile</vh></v>
<v t="ekr.20240308084832.2030"><vh>class TestRunSeparate</vh></v>
<v t="ekr.20240308084832.2031"><vh>function: fix_native_line_number</vh></v>
</v>
<v t="ekr.20240308084832.2032"><vh>test/test_serialization.py</vh>
<v t="ekr.20240308084832.2033"><vh>function: get_dict</vh></v>
<v t="ekr.20240308084832.2034"><vh>function: get_function_dict</vh></v>
<v t="ekr.20240308084832.2035"><vh>function: assert_blobs_same</vh></v>
<v t="ekr.20240308084832.2036"><vh>function: assert_modules_same</vh></v>
<v t="ekr.20240308084832.2037"><vh>function: check_serialization_roundtrip</vh></v>
</v>
<v t="ekr.20240308084832.2038"><vh>test/test_struct.py</vh>
<v t="ekr.20240308084832.2039"><vh>class TestStruct</vh>
<v t="ekr.20240308084832.2040"><vh>TestStruct.test_struct_offsets</vh></v>
<v t="ekr.20240308084832.2041"><vh>TestStruct.test_struct_str</vh></v>
<v t="ekr.20240308084832.2042"><vh>TestStruct.test_runtime_subtype</vh></v>
<v t="ekr.20240308084832.2043"><vh>TestStruct.test_eq_and_hash</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2044"><vh>test/test_tuplename.py</vh>
<v t="ekr.20240308084832.2045"><vh>class TestTupleNames</vh>
<v t="ekr.20240308084832.2046"><vh>TestTupleNames.setUp</vh></v>
<v t="ekr.20240308084832.2047"><vh>TestTupleNames.test_names</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2048"><vh>test/test_typeops.py</vh>
<v t="ekr.20240308084832.2049"><vh>class TestSubtype</vh>
<v t="ekr.20240308084832.2050"><vh>TestSubtype.test_bit</vh></v>
<v t="ekr.20240308084832.2051"><vh>TestSubtype.test_bool</vh></v>
<v t="ekr.20240308084832.2052"><vh>TestSubtype.test_int64</vh></v>
<v t="ekr.20240308084832.2053"><vh>TestSubtype.test_int32</vh></v>
<v t="ekr.20240308084832.2054"><vh>TestSubtype.test_int16</vh></v>
</v>
<v t="ekr.20240308084832.2055"><vh>class TestRuntimeSubtype</vh>
<v t="ekr.20240308084832.2056"><vh>TestRuntimeSubtype.test_bit</vh></v>
<v t="ekr.20240308084832.2057"><vh>TestRuntimeSubtype.test_bool</vh></v>
<v t="ekr.20240308084832.2058"><vh>TestRuntimeSubtype.test_union</vh></v>
</v>
<v t="ekr.20240308084832.2059"><vh>class TestUnionSimplification</vh>
<v t="ekr.20240308084832.2060"><vh>TestUnionSimplification.test_simple_type_result</vh></v>
<v t="ekr.20240308084832.2061"><vh>TestUnionSimplification.test_remove_duplicate</vh></v>
<v t="ekr.20240308084832.2062"><vh>TestUnionSimplification.test_cannot_simplify</vh></v>
<v t="ekr.20240308084832.2063"><vh>TestUnionSimplification.test_nested</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2064"><vh>test/testutil.py</vh>
<v t="ekr.20240308084832.2065"><vh>class MypycDataSuite</vh></v>
<v t="ekr.20240308084832.2066"><vh>function: builtins_wrapper</vh></v>
<v t="ekr.20240308084832.2067"><vh>function: use_custom_builtins</vh></v>
<v t="ekr.20240308084832.2068"><vh>function: perform_test</vh></v>
<v t="ekr.20240308084832.2069"><vh>function: build_ir_for_single_file</vh></v>
<v t="ekr.20240308084832.2070"><vh>function: build_ir_for_single_file2</vh></v>
<v t="ekr.20240308084832.2071"><vh>function: update_testcase_output</vh></v>
<v t="ekr.20240308084832.2072"><vh>function: assert_test_output</vh></v>
<v t="ekr.20240308084832.2073"><vh>function: get_func_names</vh></v>
<v t="ekr.20240308084832.2074"><vh>function: remove_comment_lines</vh></v>
<v t="ekr.20240308084832.2075"><vh>function: print_with_line_numbers</vh></v>
<v t="ekr.20240308084832.2076"><vh>function: heading</vh></v>
<v t="ekr.20240308084832.2077"><vh>function: show_c</vh></v>
<v t="ekr.20240308084832.2078"><vh>function: fudge_dir_mtimes</vh></v>
<v t="ekr.20240308084832.2079"><vh>function: replace_word_size</vh></v>
<v t="ekr.20240308084832.2080"><vh>function: infer_ir_build_options_from_test_name</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2081"><vh>test-data</vh>
<v t="ekr.20240308084832.2082"><vh>test-data/driver</vh>
<v t="ekr.20240308084832.2083"><vh>test-data/driver/driver.py</vh>
<v t="ekr.20240308084832.2084"><vh>function: extract_line</vh></v>
</v>
</v>
<v t="ekr.20240308084832.2085"><vh>test-data/fixtures</vh>
<v t="ekr.20240308084832.2086"><vh>test-data/fixtures/ir.py</vh>
<v t="ekr.20240308084832.2087"><vh>class __SupportsAbs</vh>
<v t="ekr.20240308084832.2088"><vh>__SupportsAbs.__abs__</vh></v>
</v>
<v t="ekr.20240308084832.2089"><vh>class __SupportsDivMod</vh>
<v t="ekr.20240308084832.2090"><vh>__SupportsDivMod.__divmod__</vh></v>
</v>
<v t="ekr.20240308084832.2091"><vh>class __SupportsRDivMod</vh>
<v t="ekr.20240308084832.2092"><vh>__SupportsRDivMod.__rdivmod__</vh></v>
</v>
<v t="ekr.20240308084832.2093"><vh>class __SupportsPow2</vh>
<v t="ekr.20240308084832.2094"><vh>__SupportsPow2.__pow__</vh></v>
</v>
<v t="ekr.20240308084832.2095"><vh>class __SupportsPow3NoneOnly</vh>
<v t="ekr.20240308084832.2096"><vh>__SupportsPow3NoneOnly.__pow__</vh></v>
</v>
<v t="ekr.20240308084832.2097"><vh>class __SupportsPow3</vh>
<v t="ekr.20240308084832.2098"><vh>__SupportsPow3.__pow__</vh></v>
</v>
<v t="ekr.20240308084832.2099"><vh>class object</vh>
<v t="ekr.20240308084832.2100"><vh>object.__init__</vh></v>
<v t="ekr.20240308084832.2101"><vh>object.__eq__</vh></v>
<v t="ekr.20240308084832.2102"><vh>object.__ne__</vh></v>
</v>
<v t="ekr.20240308084832.2103"><vh>class type</vh>
<v t="ekr.20240308084832.2104"><vh>type.__init__</vh></v>
</v>
<v t="ekr.20240308084832.2105"><vh>class ellipsis</vh></v>
<v t="ekr.20240308084832.2106"><vh>class int</vh>
<v t="ekr.20240308084832.2107"><vh>int.__init__</vh></v>
<v t="ekr.20240308084832.2108"><vh>int.__init__</vh></v>
<v t="ekr.20240308084832.2109"><vh>int.__add__</vh></v>
<v t="ekr.20240308084832.2110"><vh>int.__sub__</vh></v>
<v t="ekr.20240308084832.2111"><vh>int.__mul__</vh></v>
<v t="ekr.20240308084832.2112"><vh>int.__pow__</vh></v>
<v t="ekr.20240308084832.2113"><vh>int.__floordiv__</vh></v>
<v t="ekr.20240308084832.2114"><vh>int.__truediv__</vh></v>
<v t="ekr.20240308084832.2115"><vh>int.__mod__</vh></v>
<v t="ekr.20240308084832.2116"><vh>int.__divmod__</vh></v>
<v t="ekr.20240308084832.2117"><vh>int.__neg__</vh></v>
<v t="ekr.20240308084832.2118"><vh>int.__pos__</vh></v>
<v t="ekr.20240308084832.2119"><vh>int.__abs__</vh></v>
<v t="ekr.20240308084832.2120"><vh>int.__invert__</vh></v>
<v t="ekr.20240308084832.2121"><vh>int.__and__</vh></v>
<v t="ekr.20240308084832.2122"><vh>int.__or__</vh></v>
<v t="ekr.20240308084832.2123"><vh>int.__xor__</vh></v>
<v t="ekr.20240308084832.2124"><vh>int.__lshift__</vh></v>
<v t="ekr.20240308084832.2125"><vh>int.__rshift__</vh></v>
<v t="ekr.20240308084832.2126"><vh>int.__eq__</vh></v>
<v t="ekr.20240308084832.2127"><vh>int.__ne__</vh></v>
<v t="ekr.20240308084832.2128"><vh>int.__lt__</vh></v>
<v t="ekr.20240308084832.2129"><vh>int.__gt__</vh></v>
<v t="ekr.20240308084832.2130"><vh>int.__le__</vh></v>
<v t="ekr.20240308084832.2131"><vh>int.__ge__</vh></v>
</v>
<v t="ekr.20240308084832.2132"><vh>class str</vh>
<v t="ekr.20240308084832.2133"><vh>str.__init__</vh></v>
<v t="ekr.20240308084832.2134"><vh>str.__init__</vh></v>
<v t="ekr.20240308084832.2135"><vh>str.__add__</vh></v>
<v t="ekr.20240308084832.2136"><vh>str.__mul__</vh></v>
<v t="ekr.20240308084832.2137"><vh>str.__rmul__</vh></v>
<v t="ekr.20240308084832.2138"><vh>str.__eq__</vh></v>
<v t="ekr.20240308084832.2139"><vh>str.__ne__</vh></v>
<v t="ekr.20240308084832.2140"><vh>str.__lt__</vh></v>
<v t="ekr.20240308084832.2141"><vh>str.__le__</vh></v>
<v t="ekr.20240308084832.2142"><vh>str.__gt__</vh></v>
<v t="ekr.20240308084832.2143"><vh>str.__ge__</vh></v>
<v t="ekr.20240308084832.2144"><vh>str.__getitem__</vh></v>
<v t="ekr.20240308084832.2145"><vh>str.__getitem__</vh></v>
<v t="ekr.20240308084832.2146"><vh>str.__contains__</vh></v>
<v t="ekr.20240308084832.2147"><vh>str.__iter__</vh></v>
<v t="ekr.20240308084832.2148"><vh>str.split</vh></v>
<v t="ekr.20240308084832.2149"><vh>str.strip</vh></v>
<v t="ekr.20240308084832.2150"><vh>str.join</vh></v>
<v t="ekr.20240308084832.2151"><vh>str.format</vh></v>
<v t="ekr.20240308084832.2152"><vh>str.upper</vh></v>
<v t="ekr.20240308084832.2153"><vh>str.startswith</vh></v>
<v t="ekr.20240308084832.2154"><vh>str.endswith</vh></v>
<v t="ekr.20240308084832.2155"><vh>str.replace</vh></v>
<v t="ekr.20240308084832.2156"><vh>str.encode</vh></v>
</v>
<v t="ekr.20240308084832.2157"><vh>class float</vh>
<v t="ekr.20240308084832.2158"><vh>float.__init__</vh></v>
<v t="ekr.20240308084832.2159"><vh>float.__add__</vh></v>
<v t="ekr.20240308084832.2160"><vh>float.__radd__</vh></v>
<v t="ekr.20240308084832.2161"><vh>float.__sub__</vh></v>
<v t="ekr.20240308084832.2162"><vh>float.__rsub__</vh></v>
<v t="ekr.20240308084832.2163"><vh>float.__mul__</vh></v>
<v t="ekr.20240308084832.2164"><vh>float.__truediv__</vh></v>
<v t="ekr.20240308084832.2165"><vh>float.__floordiv__</vh></v>
<v t="ekr.20240308084832.2166"><vh>float.__mod__</vh></v>
<v t="ekr.20240308084832.2167"><vh>float.__pow__</vh></v>
<v t="ekr.20240308084832.2168"><vh>float.__neg__</vh></v>
<v t="ekr.20240308084832.2169"><vh>float.__pos__</vh></v>
<v t="ekr.20240308084832.2170"><vh>float.__abs__</vh></v>
<v t="ekr.20240308084832.2171"><vh>float.__invert__</vh></v>
<v t="ekr.20240308084832.2172"><vh>float.__eq__</vh></v>
<v t="ekr.20240308084832.2173"><vh>float.__ne__</vh></v>
<v t="ekr.20240308084832.2174"><vh>float.__lt__</vh></v>
<v t="ekr.20240308084832.2175"><vh>float.__le__</vh></v>
<v t="ekr.20240308084832.2176"><vh>float.__gt__</vh></v>
<v t="ekr.20240308084832.2177"><vh>float.__ge__</vh></v>
</v>
<v t="ekr.20240308084832.2178"><vh>class complex</vh>
<v t="ekr.20240308084832.2179"><vh>complex.__init__</vh></v>
<v t="ekr.20240308084832.2180"><vh>complex.__add__</vh></v>
<v t="ekr.20240308084832.2181"><vh>complex.__radd__</vh></v>
<v t="ekr.20240308084832.2182"><vh>complex.__sub__</vh></v>
<v t="ekr.20240308084832.2183"><vh>complex.__rsub__</vh></v>
<v t="ekr.20240308084832.2184"><vh>complex.__mul__</vh></v>
<v t="ekr.20240308084832.2185"><vh>complex.__truediv__</vh></v>
<v t="ekr.20240308084832.2186"><vh>complex.__neg__</vh></v>
</v>
<v t="ekr.20240308084832.2187"><vh>class bytes</vh>
<v t="ekr.20240308084832.2188"><vh>bytes.__init__</vh></v>
<v t="ekr.20240308084832.2189"><vh>bytes.__init__</vh></v>
<v t="ekr.20240308084832.2190"><vh>bytes.__add__</vh></v>
<v t="ekr.20240308084832.2191"><vh>bytes.__mul__</vh></v>
<v t="ekr.20240308084832.2192"><vh>bytes.__rmul__</vh></v>
<v t="ekr.20240308084832.2193"><vh>bytes.__eq__</vh></v>
<v t="ekr.20240308084832.2194"><vh>bytes.__ne__</vh></v>
<v t="ekr.20240308084832.2195"><vh>bytes.__getitem__</vh></v>
<v t="ekr.20240308084832.2196"><vh>bytes.__getitem__</vh></v>
<v t="ekr.20240308084832.2197"><vh>bytes.join</vh></v>
<v t="ekr.20240308084832.2198"><vh>bytes.decode</vh></v>
</v>
<v t="ekr.20240308084832.2199"><vh>class bytearray</vh>
<v t="ekr.20240308084832.2200"><vh>bytearray.__init__</vh></v>
<v t="ekr.20240308084832.2201"><vh>bytearray.__init__</vh></v>
<v t="ekr.20240308084832.2202"><vh>bytearray.__init__</vh></v>
<v t="ekr.20240308084832.2203"><vh>bytearray.__add__</vh></v>
<v t="ekr.20240308084832.2204"><vh>bytearray.__setitem__</vh></v>
<v t="ekr.20240308084832.2205"><vh>bytearray.__getitem__</vh></v>
<v t="ekr.20240308084832.2206"><vh>bytearray.decode</vh></v>
</v>
<v t="ekr.20240308084832.2207"><vh>class bool</vh>
<v t="ekr.20240308084832.2208"><vh>bool.__init__</vh></v>
<v t="ekr.20240308084832.2209"><vh>bool.__and__</vh></v>
<v t="ekr.20240308084832.2210"><vh>bool.__and__</vh></v>
<v t="ekr.20240308084832.2211"><vh>bool.__or__</vh></v>
<v t="ekr.20240308084832.2212"><vh>bool.__or__</vh></v>
<v t="ekr.20240308084832.2213"><vh>bool.__xor__</vh></v>
<v t="ekr.20240308084832.2214"><vh>bool.__xor__</vh></v>
</v>
<v t="ekr.20240308084832.2215"><vh>class tuple</vh>
<v t="ekr.20240308084832.2216"><vh>tuple.__init__</vh></v>
<v t="ekr.20240308084832.2217"><vh>tuple.__getitem__</vh></v>
<v t="ekr.20240308084832.2218"><vh>tuple.__getitem__</vh></v>
<v t="ekr.20240308084832.2219"><vh>tuple.__len__</vh></v>
<v t="ekr.20240308084832.2220"><vh>tuple.__iter__</vh></v>
<v t="ekr.20240308084832.2221"><vh>tuple.__contains__</vh></v>
</v>
<v t="ekr.20240308084832.2222"><vh>class function</vh></v>
<v t="ekr.20240308084832.2223"><vh>class list</vh>
<v t="ekr.20240308084832.2224"><vh>list.__init__</vh></v>
<v t="ekr.20240308084832.2225"><vh>list.__getitem__</vh></v>
<v t="ekr.20240308084832.2226"><vh>list.__getitem__</vh></v>
<v t="ekr.20240308084832.2227"><vh>list.__setitem__</vh></v>
<v t="ekr.20240308084832.2228"><vh>list.__delitem__</vh></v>
<v t="ekr.20240308084832.2229"><vh>list.__mul__</vh></v>
<v t="ekr.20240308084832.2230"><vh>list.__rmul__</vh></v>
<v t="ekr.20240308084832.2231"><vh>list.__iter__</vh></v>
<v t="ekr.20240308084832.2232"><vh>list.__len__</vh></v>
<v t="ekr.20240308084832.2233"><vh>list.__contains__</vh></v>
<v t="ekr.20240308084832.2234"><vh>list.__add__</vh></v>
<v t="ekr.20240308084832.2235"><vh>list.append</vh></v>
<v t="ekr.20240308084832.2236"><vh>list.pop</vh></v>
<v t="ekr.20240308084832.2237"><vh>list.count</vh></v>
<v t="ekr.20240308084832.2238"><vh>list.extend</vh></v>
<v t="ekr.20240308084832.2239"><vh>list.insert</vh></v>
<v t="ekr.20240308084832.2240"><vh>list.sort</vh></v>
<v t="ekr.20240308084832.2241"><vh>list.reverse</vh></v>
<v t="ekr.20240308084832.2242"><vh>list.remove</vh></v>
<v t="ekr.20240308084832.2243"><vh>list.index</vh></v>
</v>
<v t="ekr.20240308084832.2244"><vh>class dict</vh>
<v t="ekr.20240308084832.2245"><vh>dict.__init__</vh></v>
<v t="ekr.20240308084832.2246"><vh>dict.__init__</vh></v>
<v t="ekr.20240308084832.2247"><vh>dict.__init__</vh></v>
<v t="ekr.20240308084832.2248"><vh>dict.__getitem__</vh></v>
<v t="ekr.20240308084832.2249"><vh>dict.__setitem__</vh></v>
<v t="ekr.20240308084832.2250"><vh>dict.__delitem__</vh></v>
<v t="ekr.20240308084832.2251"><vh>dict.__contains__</vh></v>
<v t="ekr.20240308084832.2252"><vh>dict.__iter__</vh></v>
<v t="ekr.20240308084832.2253"><vh>dict.__len__</vh></v>
<v t="ekr.20240308084832.2254"><vh>dict.update</vh></v>
<v t="ekr.20240308084832.2255"><vh>dict.update</vh></v>
<v t="ekr.20240308084832.2256"><vh>dict.update</vh></v>
<v t="ekr.20240308084832.2257"><vh>dict.pop</vh></v>
<v t="ekr.20240308084832.2258"><vh>dict.keys</vh></v>
<v t="ekr.20240308084832.2259"><vh>dict.values</vh></v>
<v t="ekr.20240308084832.2260"><vh>dict.items</vh></v>
<v t="ekr.20240308084832.2261"><vh>dict.clear</vh></v>
<v t="ekr.20240308084832.2262"><vh>dict.copy</vh></v>
<v t="ekr.20240308084832.2263"><vh>dict.setdefault</vh></v>
</v>
<v t="ekr.20240308084832.2264"><vh>class set</vh>
<v t="ekr.20240308084832.2265"><vh>set.__init__</vh></v>
<v t="ekr.20240308084832.2266"><vh>set.__iter__</vh></v>
<v t="ekr.20240308084832.2267"><vh>set.__len__</vh></v>
<v t="ekr.20240308084832.2268"><vh>set.add</vh></v>
<v t="ekr.20240308084832.2269"><vh>set.remove</vh></v>
<v t="ekr.20240308084832.2270"><vh>set.discard</vh></v>
<v t="ekr.20240308084832.2271"><vh>set.clear</vh></v>
<v t="ekr.20240308084832.2272"><vh>set.pop</vh></v>
<v t="ekr.20240308084832.2273"><vh>set.update</vh></v>
<v t="ekr.20240308084832.2274"><vh>set.__or__</vh></v>
<v t="ekr.20240308084832.2275"><vh>set.__xor__</vh></v>
</v>
<v t="ekr.20240308084832.2276"><vh>class frozenset</vh>
<v t="ekr.20240308084832.2277"><vh>frozenset.__init__</vh></v>
<v t="ekr.20240308084832.2278"><vh>frozenset.__iter__</vh></v>
<v t="ekr.20240308084832.2279"><vh>frozenset.__len__</vh></v>
<v t="ekr.20240308084832.2280"><vh>frozenset.__or__</vh></v>
<v t="ekr.20240308084832.2281"><vh>frozenset.__xor__</vh></v>
</v>
<v t="ekr.20240308084832.2282"><vh>class slice</vh></v>
<v t="ekr.20240308084832.2283"><vh>class range</vh>
<v t="ekr.20240308084832.2284"><vh>range.__init__</vh></v>
<v t="ekr.20240308084832.2285"><vh>range.__iter__</vh></v>
<v t="ekr.20240308084832.2286"><vh>range.__len__</vh></v>
<v t="ekr.20240308084832.2287"><vh>range.__next__</vh></v>
</v>
<v t="ekr.20240308084832.2288"><vh>class property</vh>
<v t="ekr.20240308084832.2289"><vh>property.__init__</vh></v>
<v t="ekr.20240308084832.2290"><vh>property.getter</vh></v>
<v t="ekr.20240308084832.2291"><vh>property.setter</vh></v>
<v t="ekr.20240308084832.2292"><vh>property.deleter</vh></v>
<v t="ekr.20240308084832.2293"><vh>property.__get__</vh></v>
<v t="ekr.20240308084832.2294"><vh>property.__set__</vh></v>
<v t="ekr.20240308084832.2295"><vh>property.__delete__</vh></v>
<v t="ekr.20240308084832.2296"><vh>property.fget</vh></v>
<v t="ekr.20240308084832.2297"><vh>property.fset</vh></v>
<v t="ekr.20240308084832.2298"><vh>property.fdel</vh></v>
</v>
<v t="ekr.20240308084832.2299"><vh>class BaseException</vh></v>
<v t="ekr.20240308084832.2300"><vh>class Exception</vh>
<v t="ekr.20240308084832.2301"><vh>Exception.__init__</vh></v>
</v>
<v t="ekr.20240308084832.2302"><vh>class Warning</vh></v>
<v t="ekr.20240308084832.2303"><vh>class UserWarning</vh></v>
<v t="ekr.20240308084832.2304"><vh>class TypeError</vh></v>
<v t="ekr.20240308084832.2305"><vh>class ValueError</vh></v>
<v t="ekr.20240308084832.2306"><vh>class AttributeError</vh></v>
<v t="ekr.20240308084832.2307"><vh>class ImportError</vh></v>
<v t="ekr.20240308084832.2308"><vh>class NameError</vh></v>
<v t="ekr.20240308084832.2309"><vh>class UnboundLocalError</vh></v>
<v t="ekr.20240308084832.2310"><vh>class LookupError</vh></v>
<v t="ekr.20240308084832.2311"><vh>class KeyError</vh></v>
<v t="ekr.20240308084832.2312"><vh>class IndexError</vh></v>
<v t="ekr.20240308084832.2313"><vh>class RuntimeError</vh></v>
<v t="ekr.20240308084832.2314"><vh>class UnicodeEncodeError</vh></v>
<v t="ekr.20240308084832.2315"><vh>class UnicodeDecodeError</vh></v>
<v t="ekr.20240308084832.2316"><vh>class NotImplementedError</vh></v>
<v t="ekr.20240308084832.2317"><vh>class StopIteration</vh></v>
<v t="ekr.20240308084832.2318"><vh>class ArithmeticError</vh></v>
<v t="ekr.20240308084832.2319"><vh>class ZeroDivisionError</vh></v>
<v t="ekr.20240308084832.2320"><vh>class OverflowError</vh></v>
<v t="ekr.20240308084832.2321"><vh>class GeneratorExit</vh></v>
<v t="ekr.20240308084832.2322"><vh>function: any</vh></v>
<v t="ekr.20240308084832.2323"><vh>function: all</vh></v>
<v t="ekr.20240308084832.2324"><vh>function: sum</vh></v>
<v t="ekr.20240308084832.2325"><vh>function: reversed</vh></v>
<v t="ekr.20240308084832.2326"><vh>function: id</vh></v>
<v t="ekr.20240308084832.2327"><vh>function: len</vh></v>
<v t="ekr.20240308084832.2328"><vh>function: print</vh></v>
<v t="ekr.20240308084832.2329"><vh>function: isinstance</vh></v>
<v t="ekr.20240308084832.2330"><vh>function: iter</vh></v>
<v t="ekr.20240308084832.2331"><vh>function: next</vh></v>
<v t="ekr.20240308084832.2332"><vh>function: next</vh></v>
<v t="ekr.20240308084832.2333"><vh>function: hash</vh></v>
<v t="ekr.20240308084832.2334"><vh>function: globals</vh></v>
<v t="ekr.20240308084832.2335"><vh>function: getattr</vh></v>
<v t="ekr.20240308084832.2336"><vh>function: setattr</vh></v>
<v t="ekr.20240308084832.2337"><vh>function: enumerate</vh></v>
<v t="ekr.20240308084832.2338"><vh>function: zip</vh></v>
<v t="ekr.20240308084832.2339"><vh>function: zip</vh></v>
<v t="ekr.20240308084832.2340"><vh>function: eval</vh></v>
<v t="ekr.20240308084832.2341"><vh>function: abs</vh></v>
<v t="ekr.20240308084832.2342"><vh>function: divmod</vh></v>
<v t="ekr.20240308084832.2343"><vh>function: divmod</vh></v>
<v t="ekr.20240308084832.2344"><vh>function: pow</vh></v>
<v t="ekr.20240308084832.2345"><vh>function: pow</vh></v>
<v t="ekr.20240308084832.2346"><vh>function: pow</vh></v>
<v t="ekr.20240308084832.2347"><vh>function: exit</vh></v>
<v t="ekr.20240308084832.2348"><vh>function: min</vh></v>
<v t="ekr.20240308084832.2349"><vh>function: max</vh></v>
<v t="ekr.20240308084832.2350"><vh>function: repr</vh></v>
<v t="ekr.20240308084832.2351"><vh>function: ascii</vh></v>
<v t="ekr.20240308084832.2352"><vh>function: ord</vh></v>
<v t="ekr.20240308084832.2353"><vh>function: chr</vh></v>
<v t="ekr.20240308084832.2354"><vh>class classmethod</vh></v>
<v t="ekr.20240308084832.2355"><vh>class staticmethod</vh></v>
</v>
<v t="ekr.20240308084832.2356"><vh>test-data/fixtures/testutil.py</vh>
<v t="ekr.20240308084832.2357"><vh>function: assertRaises</vh></v>
<v t="ekr.20240308084832.2358"><vh>function: assertDomainError</vh></v>
<v t="ekr.20240308084832.2359"><vh>function: assertMathRangeError</vh></v>
<v t="ekr.20240308084832.2360"><vh>function: run_generator</vh></v>
<v t="ekr.20240308084832.2361"><vh>class async_val</vh>
<v t="ekr.20240308084832.2362"><vh>async_val.__init__</vh></v>
<v t="ekr.20240308084832.2363"><vh>async_val.__await__</vh></v>
</v>
<v t="ekr.20240308084832.2364"><vh>function: make_python_function</vh></v>
</v>
</v>
</v>
<v t="ekr.20240308084832.2365"><vh>transform</vh>
<v t="ekr.20240308084832.2366"><vh>transform/__init__.py</vh></v>
<v t="ekr.20240308084832.2367"><vh>transform/exceptions.py</vh>
<v t="ekr.20240308084832.2368"><vh>function: insert_exception_handling</vh></v>
<v t="ekr.20240308084832.2369"><vh>function: add_default_handler_block</vh></v>
<v t="ekr.20240308084832.2370"><vh>function: split_blocks_at_errors</vh></v>
<v t="ekr.20240308084832.2371"><vh>function: primitive_call</vh></v>
<v t="ekr.20240308084832.2372"><vh>function: adjust_error_kinds</vh></v>
<v t="ekr.20240308084832.2373"><vh>function: insert_overlapping_error_value_check</vh></v>
</v>
<v t="ekr.20240308084832.2374"><vh>transform/refcount.py</vh>
<v t="ekr.20240308084832.2375"><vh>function: insert_ref_count_opcodes</vh></v>
<v t="ekr.20240308084832.2376"><vh>function: is_maybe_undefined</vh></v>
<v t="ekr.20240308084832.2377"><vh>function: maybe_append_dec_ref</vh></v>
<v t="ekr.20240308084832.2378"><vh>function: maybe_append_inc_ref</vh></v>
<v t="ekr.20240308084832.2379"><vh>function: transform_block</vh></v>
<v t="ekr.20240308084832.2380"><vh>function: insert_branch_inc_and_decrefs</vh></v>
<v t="ekr.20240308084832.2381"><vh>function: after_branch_decrefs</vh></v>
<v t="ekr.20240308084832.2382"><vh>function: after_branch_increfs</vh></v>
<v t="ekr.20240308084832.2383"><vh>function: add_block</vh></v>
<v t="ekr.20240308084832.2384"><vh>function: make_value_ordering</vh></v>
</v>
<v t="ekr.20240308084832.2385"><vh>transform/uninit.py</vh>
<v t="ekr.20240308084832.2386"><vh>function: insert_uninit_checks</vh></v>
<v t="ekr.20240308084832.2387"><vh>function: split_blocks_at_uninits</vh></v>
<v t="ekr.20240308084832.2388"><vh>function: check_for_uninit_using_bitmap</vh></v>
<v t="ekr.20240308084832.2389"><vh>function: update_register_assignments_to_set_bitmap</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20240308084832.10">def emit_messages(options: Options, messages: list[str], dt: float, serious: bool = False) -&gt; None:
    # ... you know, just in case.
    if options.junit_xml:
        py_version = f"{options.python_version[0]}_{options.python_version[1]}"
        write_junit_xml(
            dt,
            serious,
            {None: messages} if messages else {},
            options.junit_xml,
            py_version,
            options.platform,
        )
    if messages:
        print("\n".join(messages))
</t>
<t tx="ekr.20240308084832.100">def visit_return(self, op: Return) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1000">def is_dict_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.dict"
</t>
<t tx="ekr.20240308084832.1001">def is_set_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.set"
</t>
<t tx="ekr.20240308084832.1002">def is_str_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.str"
</t>
<t tx="ekr.20240308084832.1003">def is_bytes_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.bytes"
</t>
<t tx="ekr.20240308084832.1004">def is_tuple_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.tuple"
</t>
<t tx="ekr.20240308084832.1005">def is_range_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.range"
</t>
<t tx="ekr.20240308084832.1006">def is_sequence_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and (
        is_list_rprimitive(rtype) or is_tuple_rprimitive(rtype) or is_str_rprimitive(rtype)
    )
</t>
<t tx="ekr.20240308084832.1007">class TupleNameVisitor(RTypeVisitor[str]):
    """Produce a tuple name based on the concrete representations of types."""
    @others
</t>
<t tx="ekr.20240308084832.1008">def visit_rinstance(self, t: RInstance) -&gt; str:
    return "O"
</t>
<t tx="ekr.20240308084832.1009">def visit_runion(self, t: RUnion) -&gt; str:
    return "O"
</t>
<t tx="ekr.20240308084832.101">def visit_unreachable(self, op: Unreachable) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1010">def visit_rprimitive(self, t: RPrimitive) -&gt; str:
    if t._ctype == "CPyTagged":
        return "I"
    elif t._ctype == "char":
        return "C"
    elif t._ctype == "int64_t":
        return "8"  # "8 byte integer"
    elif t._ctype == "int32_t":
        return "4"  # "4 byte integer"
    elif t._ctype == "int16_t":
        return "2"  # "2 byte integer"
    elif t._ctype == "uint8_t":
        return "U1"  # "1 byte unsigned integer"
    elif t._ctype == "double":
        return "F"
    assert not t.is_unboxed, f"{t} unexpected unboxed type"
    return "O"
</t>
<t tx="ekr.20240308084832.1011">def visit_rtuple(self, t: RTuple) -&gt; str:
    parts = [elem.accept(self) for elem in t.types]
    return "T{}{}".format(len(parts), "".join(parts))
</t>
<t tx="ekr.20240308084832.1012">def visit_rstruct(self, t: RStruct) -&gt; str:
    assert False, "RStruct not supported in tuple"
</t>
<t tx="ekr.20240308084832.1013">def visit_rarray(self, t: RArray) -&gt; str:
    assert False, "RArray not supported in tuple"
</t>
<t tx="ekr.20240308084832.1014">def visit_rvoid(self, t: RVoid) -&gt; str:
    assert False, "rvoid in tuple?"
</t>
<t tx="ekr.20240308084832.1015">class RTuple(RType):
    """Fixed-length unboxed tuple (represented as a C struct).
    
    These are used to represent mypy TupleType values (fixed-length
    Python tuples). Since this is unboxed, the identity of a tuple
    object is not preserved within compiled code. If the identity of a
    tuple is important, or there is a need to have multiple references
    to a single tuple object, a variable-length tuple should be used
    (tuple_rprimitive or Tuple[T, ...]  with explicit '...'), as they
    are boxed.
    
    These aren't immutable. However, user code won't be able to mutate
    individual tuple items.
    """
    @others
</t>
<t tx="ekr.20240308084832.1016">is_unboxed = True

def __init__(self, types: list[RType]) -&gt; None:
    self.name = "tuple"
    self.types = tuple(types)
    self.is_refcounted = any(t.is_refcounted for t in self.types)
    # Generate a unique id which is used in naming corresponding C identifiers.
    # This is necessary since C does not have anonymous structural type equivalence
    # in the same way python can just assign a Tuple[int, bool] to a Tuple[int, bool].
    self.unique_id = self.accept(TupleNameVisitor())
    # Nominally the max c length is 31 chars, but I'm not honestly worried about this.
    self.struct_name = f"tuple_{self.unique_id}"
    self._ctype = f"{self.struct_name}"
    self.error_overlap = all(t.error_overlap for t in self.types) and bool(self.types)
</t>
<t tx="ekr.20240308084832.1017">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rtuple(self)
</t>
<t tx="ekr.20240308084832.1018">def __str__(self) -&gt; str:
    return "tuple[%s]" % ", ".join(str(typ) for typ in self.types)
</t>
<t tx="ekr.20240308084832.1019">def __repr__(self) -&gt; str:
    return "&lt;RTuple %s&gt;" % ", ".join(repr(typ) for typ in self.types)
</t>
<t tx="ekr.20240308084832.102">def visit_register_op(self, op: RegisterOp) -&gt; tuple[set[str], set[str]]:
    if isinstance(op, SetAttr) and op.obj is self.self_reg:
        return {op.attr}, set()
    if isinstance(op, Call) and op.fn.class_name and op.fn.name == "__init__":
        return attributes_maybe_initialized_by_init_call(op), set()
    return set(), set()
</t>
<t tx="ekr.20240308084832.1020">def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, RTuple) and self.types == other.types
</t>
<t tx="ekr.20240308084832.1021">def __hash__(self) -&gt; int:
    return hash((self.name, self.types))
</t>
<t tx="ekr.20240308084832.1022">def serialize(self) -&gt; JsonDict:
    types = [x.serialize() for x in self.types]
    return {".class": "RTuple", "types": types}
</t>
<t tx="ekr.20240308084832.1023">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; RTuple:
    types = [deserialize_type(t, ctx) for t in data["types"]]
    return RTuple(types)
</t>
<t tx="ekr.20240308084832.1024"># Exception tuple: (exception class, exception instance, traceback object)
exc_rtuple = RTuple([object_rprimitive, object_rprimitive, object_rprimitive])

# Dictionary iterator tuple: (should continue, internal offset, key, value)
# See mypyc.irbuild.for_helpers.ForDictionaryCommon for more details.
dict_next_rtuple_pair = RTuple(
    [bool_rprimitive, short_int_rprimitive, object_rprimitive, object_rprimitive]
)
# Same as above but just for key or value.
dict_next_rtuple_single = RTuple([bool_rprimitive, short_int_rprimitive, object_rprimitive])


def compute_rtype_alignment(typ: RType) -&gt; int:
    """Compute alignment of a given type based on platform alignment rule"""
    platform_alignment = PLATFORM_SIZE
    if isinstance(typ, RPrimitive):
        return typ.size
    elif isinstance(typ, RInstance):
        return platform_alignment
    elif isinstance(typ, RUnion):
        return platform_alignment
    elif isinstance(typ, RArray):
        return compute_rtype_alignment(typ.item_type)
    else:
        if isinstance(typ, RTuple):
            items = list(typ.types)
        elif isinstance(typ, RStruct):
            items = typ.types
        else:
            assert False, "invalid rtype for computing alignment"
        max_alignment = max(compute_rtype_alignment(item) for item in items)
        return max_alignment
</t>
<t tx="ekr.20240308084832.1025">def compute_rtype_size(typ: RType) -&gt; int:
    """Compute unaligned size of rtype"""
    if isinstance(typ, RPrimitive):
        return typ.size
    elif isinstance(typ, RTuple):
        return compute_aligned_offsets_and_size(list(typ.types))[1]
    elif isinstance(typ, RUnion):
        return PLATFORM_SIZE
    elif isinstance(typ, RStruct):
        return compute_aligned_offsets_and_size(typ.types)[1]
    elif isinstance(typ, RInstance):
        return PLATFORM_SIZE
    elif isinstance(typ, RArray):
        alignment = compute_rtype_alignment(typ)
        aligned_size = (compute_rtype_size(typ.item_type) + (alignment - 1)) &amp; ~(alignment - 1)
        return aligned_size * typ.length
    else:
        assert False, "invalid rtype for computing size"
</t>
<t tx="ekr.20240308084832.1026">def compute_aligned_offsets_and_size(types: list[RType]) -&gt; tuple[list[int], int]:
    """Compute offsets and total size of a list of types after alignment

    Note that the types argument are types of values that are stored
    sequentially with platform default alignment.
    """
    unaligned_sizes = [compute_rtype_size(typ) for typ in types]
    alignments = [compute_rtype_alignment(typ) for typ in types]

    current_offset = 0
    offsets = []
    final_size = 0
    for i in range(len(unaligned_sizes)):
        offsets.append(current_offset)
        if i + 1 &lt; len(unaligned_sizes):
            cur_size = unaligned_sizes[i]
            current_offset += cur_size
            next_alignment = alignments[i + 1]
            # compute aligned offset,
            # check https://en.wikipedia.org/wiki/Data_structure_alignment for more information
            current_offset = (current_offset + (next_alignment - 1)) &amp; -next_alignment
        else:
            struct_alignment = max(alignments)
            final_size = current_offset + unaligned_sizes[i]
            final_size = (final_size + (struct_alignment - 1)) &amp; -struct_alignment
    return offsets, final_size
</t>
<t tx="ekr.20240308084832.1027">class RStruct(RType):
    """C struct type"""
    @others
</t>
<t tx="ekr.20240308084832.1028">def __init__(self, name: str, names: list[str], types: list[RType]) -&gt; None:
    self.name = name
    self.names = names
    self.types = types
    # generate dummy names
    if len(self.names) &lt; len(self.types):
        for i in range(len(self.types) - len(self.names)):
            self.names.append("_item" + str(i))
    self.offsets, self.size = compute_aligned_offsets_and_size(types)
    self._ctype = name
</t>
<t tx="ekr.20240308084832.1029">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rstruct(self)
</t>
<t tx="ekr.20240308084832.103">def visit_assign(self, op: Assign) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1030">def __str__(self) -&gt; str:
    # if not tuple(unnamed structs)
    return "{}{{{}}}".format(
        self.name,
        ", ".join(name + ":" + str(typ) for name, typ in zip(self.names, self.types)),
    )
</t>
<t tx="ekr.20240308084832.1031">def __repr__(self) -&gt; str:
    return "&lt;RStruct {}{{{}}}&gt;".format(
        self.name,
        ", ".join(name + ":" + repr(typ) for name, typ in zip(self.names, self.types)),
    )
</t>
<t tx="ekr.20240308084832.1032">def __eq__(self, other: object) -&gt; bool:
    return (
        isinstance(other, RStruct)
        and self.name == other.name
        and self.names == other.names
        and self.types == other.types
    )
</t>
<t tx="ekr.20240308084832.1033">def __hash__(self) -&gt; int:
    return hash((self.name, tuple(self.names), tuple(self.types)))
</t>
<t tx="ekr.20240308084832.1034">def serialize(self) -&gt; JsonDict:
    assert False
</t>
<t tx="ekr.20240308084832.1035">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; RStruct:
    assert False
</t>
<t tx="ekr.20240308084832.1036">class RInstance(RType):
    """Instance of user-defined class (compiled to C extension class).
    
    The runtime representation is 'PyObject *', and these are always
    boxed and thus reference-counted.
    
    These support fast method calls and fast attribute access using
    vtables, and they usually use a dict-free, struct-based
    representation of attributes. Method calls and attribute access
    can skip the vtable if we know that there is no overriding.
    
    These are also sometimes called 'native' types, since these have
    the most efficient representation and ops (along with certain
    RPrimitive types and RTuple).
    """
    @others
</t>
<t tx="ekr.20240308084832.1037">is_unboxed = False

def __init__(self, class_ir: ClassIR) -&gt; None:
    # name is used for formatting the name in messages and debug output
    # so we want the fullname for precision.
    self.name = class_ir.fullname
    self.class_ir = class_ir
    self._ctype = "PyObject *"
</t>
<t tx="ekr.20240308084832.1038">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rinstance(self)
</t>
<t tx="ekr.20240308084832.1039">def struct_name(self, names: NameGenerator) -&gt; str:
    return self.class_ir.struct_name(names)
</t>
<t tx="ekr.20240308084832.104">def visit_assign_multi(self, op: AssignMulti) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1040">def getter_index(self, name: str) -&gt; int:
    return self.class_ir.vtable_entry(name)
</t>
<t tx="ekr.20240308084832.1041">def setter_index(self, name: str) -&gt; int:
    return self.getter_index(name) + 1
</t>
<t tx="ekr.20240308084832.1042">def method_index(self, name: str) -&gt; int:
    return self.class_ir.vtable_entry(name)
</t>
<t tx="ekr.20240308084832.1043">def attr_type(self, name: str) -&gt; RType:
    return self.class_ir.attr_type(name)
</t>
<t tx="ekr.20240308084832.1044">def __repr__(self) -&gt; str:
    return "&lt;RInstance %s&gt;" % self.name
</t>
<t tx="ekr.20240308084832.1045">def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, RInstance) and other.name == self.name
</t>
<t tx="ekr.20240308084832.1046">def __hash__(self) -&gt; int:
    return hash(self.name)
</t>
<t tx="ekr.20240308084832.1047">def serialize(self) -&gt; str:
    return self.name
</t>
<t tx="ekr.20240308084832.1048">class RUnion(RType):
    """union[x, ..., y]"""
    @others
</t>
<t tx="ekr.20240308084832.1049">is_unboxed = False

def __init__(self, items: list[RType]) -&gt; None:
    self.name = "union"
    self.items = items
    self.items_set = frozenset(items)
    self._ctype = "PyObject *"
</t>
<t tx="ekr.20240308084832.105">def visit_set_mem(self, op: SetMem) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1050">@staticmethod
def make_simplified_union(items: list[RType]) -&gt; RType:
    """Return a normalized union that covers the given items.

    Flatten nested unions and remove duplicate items.

    Overlapping items are *not* simplified. For example,
    [object, str] will not be simplified.
    """
    items = flatten_nested_unions(items)
    assert items

    unique_items = dict.fromkeys(items)
    if len(unique_items) &gt; 1:
        return RUnion(list(unique_items))
    else:
        return next(iter(unique_items))
</t>
<t tx="ekr.20240308084832.1051">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_runion(self)
</t>
<t tx="ekr.20240308084832.1052">def __repr__(self) -&gt; str:
    return "&lt;RUnion %s&gt;" % ", ".join(str(item) for item in self.items)
</t>
<t tx="ekr.20240308084832.1053">def __str__(self) -&gt; str:
    return "union[%s]" % ", ".join(str(item) for item in self.items)
</t>
<t tx="ekr.20240308084832.1054"># We compare based on the set because order in a union doesn't matter
def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, RUnion) and self.items_set == other.items_set
</t>
<t tx="ekr.20240308084832.1055">def __hash__(self) -&gt; int:
    return hash(("union", self.items_set))
</t>
<t tx="ekr.20240308084832.1056">def serialize(self) -&gt; JsonDict:
    types = [x.serialize() for x in self.items]
    return {".class": "RUnion", "types": types}
</t>
<t tx="ekr.20240308084832.1057">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; RUnion:
    types = [deserialize_type(t, ctx) for t in data["types"]]
    return RUnion(types)
</t>
<t tx="ekr.20240308084832.1058">def flatten_nested_unions(types: list[RType]) -&gt; list[RType]:
    if not any(isinstance(t, RUnion) for t in types):
        return types  # Fast path

    flat_items: list[RType] = []
    for t in types:
        if isinstance(t, RUnion):
            flat_items.extend(flatten_nested_unions(t.items))
        else:
            flat_items.append(t)
    return flat_items
</t>
<t tx="ekr.20240308084832.1059">def optional_value_type(rtype: RType) -&gt; RType | None:
    """If rtype is the union of none_rprimitive and another type X, return X.

    Otherwise return None.
    """
    if isinstance(rtype, RUnion) and len(rtype.items) == 2:
        if rtype.items[0] == none_rprimitive:
            return rtype.items[1]
        elif rtype.items[1] == none_rprimitive:
            return rtype.items[0]
    return None
</t>
<t tx="ekr.20240308084832.106">def analyze_maybe_defined_attrs_in_init(
    blocks: list[BasicBlock], self_reg: Register, attrs_with_defaults: set[str], cfg: CFG
) -&gt; AnalysisResult[str]:
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=AttributeMaybeDefinedVisitor(self_reg),
        initial=attrs_with_defaults,
        backward=False,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.1060">def is_optional_type(rtype: RType) -&gt; bool:
    """Is rtype an optional type with exactly two union items?"""
    return optional_value_type(rtype) is not None
</t>
<t tx="ekr.20240308084832.1061">class RArray(RType):
    """Fixed-length C array type (for example, int[5]).
    
    Note that the implementation is a bit limited, and these can basically
    be only used for local variables that are initialized in one location.
    """
    @others
</t>
<t tx="ekr.20240308084832.1062">def __init__(self, item_type: RType, length: int) -&gt; None:
    self.item_type = item_type
    # Number of items
    self.length = length
    self.is_refcounted = False
</t>
<t tx="ekr.20240308084832.1063">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rarray(self)
</t>
<t tx="ekr.20240308084832.1064">def __str__(self) -&gt; str:
    return f"{self.item_type}[{self.length}]"
</t>
<t tx="ekr.20240308084832.1065">def __repr__(self) -&gt; str:
    return f"&lt;RArray {self.item_type!r}[{self.length}]&gt;"
</t>
<t tx="ekr.20240308084832.1066">def __eq__(self, other: object) -&gt; bool:
    return (
        isinstance(other, RArray)
        and self.item_type == other.item_type
        and self.length == other.length
    )
</t>
<t tx="ekr.20240308084832.1067">def __hash__(self) -&gt; int:
    return hash((self.item_type, self.length))
</t>
<t tx="ekr.20240308084832.1068">def serialize(self) -&gt; JsonDict:
    assert False
</t>
<t tx="ekr.20240308084832.1069">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; RArray:
    assert False
</t>
<t tx="ekr.20240308084832.107">class AttributeMaybeUndefinedVisitor(BaseAnalysisVisitor[str]):
    """Find attributes that may be undefined via some code path.
    
    Consider initializations in class body, assignments to 'self.x'
    and calls to base class '__init__'.
    """
    @others
</t>
<t tx="ekr.20240308084832.1070">PyObject = RStruct(
    name="PyObject",
    names=["ob_refcnt", "ob_type"],
    types=[c_pyssize_t_rprimitive, pointer_rprimitive],
)

PyVarObject = RStruct(
    name="PyVarObject", names=["ob_base", "ob_size"], types=[PyObject, c_pyssize_t_rprimitive]
)

setentry = RStruct(
    name="setentry", names=["key", "hash"], types=[pointer_rprimitive, c_pyssize_t_rprimitive]
)

smalltable = RStruct(name="smalltable", names=[], types=[setentry] * 8)

PySetObject = RStruct(
    name="PySetObject",
    names=[
        "ob_base",
        "fill",
        "used",
        "mask",
        "table",
        "hash",
        "finger",
        "smalltable",
        "weakreflist",
    ],
    types=[
        PyObject,
        c_pyssize_t_rprimitive,
        c_pyssize_t_rprimitive,
        c_pyssize_t_rprimitive,
        pointer_rprimitive,
        c_pyssize_t_rprimitive,
        c_pyssize_t_rprimitive,
        smalltable,
        pointer_rprimitive,
    ],
)

PyListObject = RStruct(
    name="PyListObject",
    names=["ob_base", "ob_item", "allocated"],
    types=[PyVarObject, pointer_rprimitive, c_pyssize_t_rprimitive],
)


def check_native_int_range(rtype: RPrimitive, n: int) -&gt; bool:
    """Is n within the range of a native, fixed-width int type?

    Assume the type is a fixed-width int type.
    """
    if not rtype.is_signed:
        return 0 &lt;= n &lt; (1 &lt;&lt; (8 * rtype.size))
    else:
        limit = 1 &lt;&lt; (rtype.size * 8 - 1)
        return -limit &lt;= n &lt; limit
</t>
<t tx="ekr.20240308084832.1071"></t>
<t tx="ekr.20240308084832.1072">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1073">"""IRBuilder AST transform helpers shared between expressions and statements.

Shared code that is tightly coupled to mypy ASTs can be put here instead of
making mypyc.irbuild.builder larger.
"""

from __future__ import annotations

from mypy.nodes import (
    LDEF,
    BytesExpr,
    ComparisonExpr,
    Expression,
    FloatExpr,
    IntExpr,
    MemberExpr,
    NameExpr,
    OpExpr,
    StrExpr,
    UnaryExpr,
    Var,
)
from mypyc.ir.ops import BasicBlock
from mypyc.ir.rtypes import is_fixed_width_rtype, is_tagged
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.constant_fold import constant_fold_expr


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1074">def process_conditional(
    self: IRBuilder, e: Expression, true: BasicBlock, false: BasicBlock
) -&gt; None:
    if isinstance(e, OpExpr) and e.op in ["and", "or"]:
        if e.op == "and":
            # Short circuit 'and' in a conditional context.
            new = BasicBlock()
            process_conditional(self, e.left, new, false)
            self.activate_block(new)
            process_conditional(self, e.right, true, false)
        else:
            # Short circuit 'or' in a conditional context.
            new = BasicBlock()
            process_conditional(self, e.left, true, new)
            self.activate_block(new)
            process_conditional(self, e.right, true, false)
    elif isinstance(e, UnaryExpr) and e.op == "not":
        process_conditional(self, e.expr, false, true)
    else:
        res = maybe_process_conditional_comparison(self, e, true, false)
        if res:
            return
        # Catch-all for arbitrary expressions.
        reg = self.accept(e)
        self.add_bool_branch(reg, true, false)
</t>
<t tx="ekr.20240308084832.1075">def maybe_process_conditional_comparison(
    self: IRBuilder, e: Expression, true: BasicBlock, false: BasicBlock
) -&gt; bool:
    """Transform simple tagged integer comparisons in a conditional context.

    Return True if the operation is supported (and was transformed). Otherwise,
    do nothing and return False.

    Args:
        e: Arbitrary expression
        true: Branch target if comparison is true
        false: Branch target if comparison is false
    """
    if not isinstance(e, ComparisonExpr) or len(e.operands) != 2:
        return False
    ltype = self.node_type(e.operands[0])
    rtype = self.node_type(e.operands[1])
    if not (
        (is_tagged(ltype) or is_fixed_width_rtype(ltype))
        and (is_tagged(rtype) or is_fixed_width_rtype(rtype))
    ):
        return False
    op = e.operators[0]
    if op not in ("==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;="):
        return False
    left_expr = e.operands[0]
    right_expr = e.operands[1]
    borrow_left = is_borrow_friendly_expr(self, right_expr)
    left = self.accept(left_expr, can_borrow=borrow_left)
    right = self.accept(right_expr, can_borrow=True)
    if is_fixed_width_rtype(ltype) or is_fixed_width_rtype(rtype):
        if not is_fixed_width_rtype(ltype):
            left = self.coerce(left, rtype, e.line)
        elif not is_fixed_width_rtype(rtype):
            right = self.coerce(right, ltype, e.line)
        reg = self.binary_op(left, right, op, e.line)
        self.builder.flush_keep_alives()
        self.add_bool_branch(reg, true, false)
    else:
        # "left op right" for two tagged integers
        self.builder.compare_tagged_condition(left, right, op, true, false, e.line)
    return True
</t>
<t tx="ekr.20240308084832.1076">def is_borrow_friendly_expr(self: IRBuilder, expr: Expression) -&gt; bool:
    """Can the result of the expression borrowed temporarily?

    Borrowing means keeping a reference without incrementing the reference count.
    """
    if isinstance(expr, (IntExpr, FloatExpr, StrExpr, BytesExpr)):
        # Literals are immortal and can always be borrowed
        return True
    if (
        isinstance(expr, (UnaryExpr, OpExpr, NameExpr, MemberExpr))
        and constant_fold_expr(self, expr) is not None
    ):
        # Literal expressions are similar to literals
        return True
    if isinstance(expr, NameExpr):
        if isinstance(expr.node, Var) and expr.kind == LDEF:
            # Local variable reference can be borrowed
            return True
    if isinstance(expr, MemberExpr) and self.is_native_attr_ref(expr):
        return True
    return False
</t>
<t tx="ekr.20240308084832.1077">"""Builder class used to transform a mypy AST to the IR form.

The IRBuilder class maintains transformation state and provides access
to various helpers used to implement the transform.

The top-level transform control logic is in mypyc.irbuild.main.

mypyc.irbuild.visitor.IRBuilderVisitor is used to dispatch based on mypy
AST node type to code that actually does the bulk of the work. For
example, expressions are transformed in mypyc.irbuild.expression and
functions are transformed in mypyc.irbuild.function.
"""
from __future__ import annotations

from contextlib import contextmanager
from typing import Any, Callable, Final, Iterator, Sequence, Union
from typing_extensions import overload

from mypy.build import Graph
from mypy.maptype import map_instance_to_supertype
from mypy.nodes import (
    ARG_NAMED,
    ARG_POS,
    GDEF,
    LDEF,
    ArgKind,
    CallExpr,
    Decorator,
    Expression,
    FuncDef,
    IndexExpr,
    IntExpr,
    Lvalue,
    MemberExpr,
    MypyFile,
    NameExpr,
    OpExpr,
    OverloadedFuncDef,
    RefExpr,
    StarExpr,
    Statement,
    SymbolNode,
    TupleExpr,
    TypeAlias,
    TypeInfo,
    UnaryExpr,
    Var,
)
from mypy.types import (
    AnyType,
    DeletedType,
    Instance,
    ProperType,
    TupleType,
    Type,
    TypedDictType,
    TypeOfAny,
    UninhabitedType,
    UnionType,
    get_proper_type,
)
from mypy.util import split_target
from mypy.visitor import ExpressionVisitor, StatementVisitor
from mypyc.common import BITMAP_BITS, SELF_NAME, TEMP_ATTR_NAME
from mypyc.crash import catch_errors
from mypyc.errors import Errors
from mypyc.ir.class_ir import ClassIR, NonExtClassInfo
from mypyc.ir.func_ir import INVALID_FUNC_DEF, FuncDecl, FuncIR, FuncSignature, RuntimeArg
from mypyc.ir.ops import (
    NAMESPACE_MODULE,
    Assign,
    BasicBlock,
    Branch,
    ComparisonOp,
    GetAttr,
    InitStatic,
    Integer,
    IntOp,
    LoadStatic,
    Op,
    RaiseStandardError,
    Register,
    SetAttr,
    TupleGet,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import (
    RInstance,
    RTuple,
    RType,
    RUnion,
    bitmap_rprimitive,
    c_pyssize_t_rprimitive,
    dict_rprimitive,
    int_rprimitive,
    is_float_rprimitive,
    is_list_rprimitive,
    is_none_rprimitive,
    is_object_rprimitive,
    is_tagged,
    is_tuple_rprimitive,
    none_rprimitive,
    object_rprimitive,
    str_rprimitive,
)
from mypyc.irbuild.context import FuncInfo, ImplicitClass
from mypyc.irbuild.ll_builder import LowLevelIRBuilder
from mypyc.irbuild.mapper import Mapper
from mypyc.irbuild.nonlocalcontrol import (
    BaseNonlocalControl,
    GeneratorNonlocalControl,
    LoopNonlocalControl,
    NonlocalControl,
)
from mypyc.irbuild.prebuildvisitor import PreBuildVisitor
from mypyc.irbuild.prepare import RegisterImplInfo
from mypyc.irbuild.targets import (
    AssignmentTarget,
    AssignmentTargetAttr,
    AssignmentTargetIndex,
    AssignmentTargetRegister,
    AssignmentTargetTuple,
)
from mypyc.irbuild.util import bytes_from_str, is_constant
from mypyc.options import CompilerOptions
from mypyc.primitives.dict_ops import dict_get_item_op, dict_set_item_op
from mypyc.primitives.generic_ops import iter_op, next_op, py_setattr_op
from mypyc.primitives.list_ops import list_get_item_unsafe_op, list_pop_last, to_list
from mypyc.primitives.misc_ops import check_unpack_count_op, get_module_dict_op, import_op
from mypyc.primitives.registry import CFunctionDescription, function_ops

# These int binary operations can borrow their operands safely, since the
# primitives take this into consideration.
int_borrow_friendly_op: Final = {"+", "-", "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;="}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1078">class IRVisitor(ExpressionVisitor[Value], StatementVisitor[None]):
    pass
</t>
<t tx="ekr.20240308084832.1079">class UnsupportedException(Exception):
    pass
</t>
<t tx="ekr.20240308084832.108">def __init__(self, self_reg: Register) -&gt; None:
    self.self_reg = self_reg
</t>
<t tx="ekr.20240308084832.1080">SymbolTarget = Union[AssignmentTargetRegister, AssignmentTargetAttr]


class IRBuilder:
    @others
</t>
<t tx="ekr.20240308084832.1081">def __init__(
    self,
    current_module: str,
    types: dict[Expression, Type],
    graph: Graph,
    errors: Errors,
    mapper: Mapper,
    pbv: PreBuildVisitor,
    visitor: IRVisitor,
    options: CompilerOptions,
    singledispatch_impls: dict[FuncDef, list[RegisterImplInfo]],
) -&gt; None:
    self.builder = LowLevelIRBuilder(current_module, errors, mapper, options)
    self.builders = [self.builder]
    self.symtables: list[dict[SymbolNode, SymbolTarget]] = [{}]
    self.runtime_args: list[list[RuntimeArg]] = [[]]
    self.function_name_stack: list[str] = []
    self.class_ir_stack: list[ClassIR] = []
    # Keep track of whether the next statement in a block is reachable
    # or not, separately for each block nesting level
    self.block_reachable_stack: list[bool] = [True]

    self.current_module = current_module
    self.mapper = mapper
    self.types = types
    self.graph = graph
    self.ret_types: list[RType] = []
    self.functions: list[FuncIR] = []
    self.function_names: set[tuple[str | None, str]] = set()
    self.classes: list[ClassIR] = []
    self.final_names: list[tuple[str, RType]] = []
    self.callable_class_names: set[str] = set()
    self.options = options

    # These variables keep track of the number of lambdas, implicit indices, and implicit
    # iterators instantiated so we avoid name conflicts. The indices and iterators are
    # instantiated from for-loops.
    self.lambda_counter = 0
    self.temp_counter = 0

    # These variables are populated from the first-pass PreBuildVisitor.
    self.free_variables = pbv.free_variables
    self.prop_setters = pbv.prop_setters
    self.encapsulating_funcs = pbv.encapsulating_funcs
    self.nested_fitems = pbv.nested_funcs.keys()
    self.fdefs_to_decorators = pbv.funcs_to_decorators
    self.module_import_groups = pbv.module_import_groups

    self.singledispatch_impls = singledispatch_impls

    self.visitor = visitor

    # This list operates similarly to a function call stack for nested functions. Whenever a
    # function definition begins to be generated, a FuncInfo instance is added to the stack,
    # and information about that function (e.g. whether it is nested, its environment class to
    # be generated) is stored in that FuncInfo instance. When the function is done being
    # generated, its corresponding FuncInfo is popped off the stack.
    self.fn_info = FuncInfo(INVALID_FUNC_DEF, "", "")
    self.fn_infos: list[FuncInfo] = [self.fn_info]

    # This list operates as a stack of constructs that modify the
    # behavior of nonlocal control flow constructs.
    self.nonlocal_control: list[NonlocalControl] = []

    self.errors = errors
    # Notionally a list of all of the modules imported by the
    # module being compiled, but stored as an OrderedDict so we
    # can also do quick lookups.
    self.imports: dict[str, None] = {}

    self.can_borrow = False
</t>
<t tx="ekr.20240308084832.1082"># High-level control

def set_module(self, module_name: str, module_path: str) -&gt; None:
    """Set the name and path of the current module.

    This must be called before transforming any AST nodes.
    """
    self.module_name = module_name
    self.module_path = module_path
    self.builder.set_module(module_name, module_path)
</t>
<t tx="ekr.20240308084832.1083">@overload
def accept(self, node: Expression, *, can_borrow: bool = False) -&gt; Value:
    ...
</t>
<t tx="ekr.20240308084832.1084">@overload
def accept(self, node: Statement) -&gt; None:
    ...
</t>
<t tx="ekr.20240308084832.1085">def accept(self, node: Statement | Expression, *, can_borrow: bool = False) -&gt; Value | None:
    """Transform an expression or a statement.

    If can_borrow is true, prefer to generate a borrowed reference.
    Borrowed references are faster since they don't require reference count
    manipulation, but they are only safe to use in specific contexts.
    """
    with self.catch_errors(node.line):
        if isinstance(node, Expression):
            old_can_borrow = self.can_borrow
            self.can_borrow = can_borrow
            try:
                res = node.accept(self.visitor)
                res = self.coerce(res, self.node_type(node), node.line)
            # If we hit an error during compilation, we want to
            # keep trying, so we can produce more error
            # messages. Generate a temp of the right type to keep
            # from causing more downstream trouble.
            except UnsupportedException:
                res = Register(self.node_type(node))
            self.can_borrow = old_can_borrow
            if not can_borrow:
                self.flush_keep_alives()
            return res
        else:
            try:
                node.accept(self.visitor)
            except UnsupportedException:
                pass
            return None
</t>
<t tx="ekr.20240308084832.1086">def flush_keep_alives(self) -&gt; None:
    self.builder.flush_keep_alives()
</t>
<t tx="ekr.20240308084832.1087"># Pass through methods for the most common low-level builder ops, for convenience.

def add(self, op: Op) -&gt; Value:
    return self.builder.add(op)
</t>
<t tx="ekr.20240308084832.1088">def goto(self, target: BasicBlock) -&gt; None:
    self.builder.goto(target)
</t>
<t tx="ekr.20240308084832.1089">def activate_block(self, block: BasicBlock) -&gt; None:
    self.builder.activate_block(block)
</t>
<t tx="ekr.20240308084832.109">def visit_branch(self, op: Branch) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1090">def goto_and_activate(self, block: BasicBlock) -&gt; None:
    self.builder.goto_and_activate(block)
</t>
<t tx="ekr.20240308084832.1091">def self(self) -&gt; Register:
    return self.builder.self()
</t>
<t tx="ekr.20240308084832.1092">def py_get_attr(self, obj: Value, attr: str, line: int) -&gt; Value:
    return self.builder.py_get_attr(obj, attr, line)
</t>
<t tx="ekr.20240308084832.1093">def load_str(self, value: str) -&gt; Value:
    return self.builder.load_str(value)
</t>
<t tx="ekr.20240308084832.1094">def load_bytes_from_str_literal(self, value: str) -&gt; Value:
    """Load bytes object from a string literal.

    The literal characters of BytesExpr (the characters inside b'')
    are stored in BytesExpr.value, whose type is 'str' not 'bytes'.
    Thus we perform a special conversion here.
    """
    return self.builder.load_bytes(bytes_from_str(value))
</t>
<t tx="ekr.20240308084832.1095">def load_int(self, value: int) -&gt; Value:
    return self.builder.load_int(value)
</t>
<t tx="ekr.20240308084832.1096">def load_float(self, value: float) -&gt; Value:
    return self.builder.load_float(value)
</t>
<t tx="ekr.20240308084832.1097">def unary_op(self, lreg: Value, expr_op: str, line: int) -&gt; Value:
    return self.builder.unary_op(lreg, expr_op, line)
</t>
<t tx="ekr.20240308084832.1098">def binary_op(self, lreg: Value, rreg: Value, expr_op: str, line: int) -&gt; Value:
    return self.builder.binary_op(lreg, rreg, expr_op, line)
</t>
<t tx="ekr.20240308084832.1099">def coerce(self, src: Value, target_type: RType, line: int, force: bool = False) -&gt; Value:
    return self.builder.coerce(src, target_type, line, force, can_borrow=self.can_borrow)
</t>
<t tx="ekr.20240308084832.11">def get_mypy_config(
    mypy_options: list[str],
    only_compile_paths: Iterable[str] | None,
    compiler_options: CompilerOptions,
    fscache: FileSystemCache | None,
) -&gt; tuple[list[BuildSource], list[BuildSource], Options]:
    """Construct mypy BuildSources and Options from file and options lists"""
    all_sources, options = process_options(mypy_options, fscache=fscache)
    if only_compile_paths is not None:
        paths_set = set(only_compile_paths)
        mypyc_sources = [s for s in all_sources if s.path in paths_set]
    else:
        mypyc_sources = all_sources

    if compiler_options.separate:
        mypyc_sources = [
            src for src in mypyc_sources if src.path and not src.path.endswith("__init__.py")
        ]

    if not mypyc_sources:
        return mypyc_sources, all_sources, options

    # Override whatever python_version is inferred from the .ini file,
    # and set the python_version to be the currently used version.
    options.python_version = sys.version_info[:2]

    if options.python_version[0] == 2:
        fail("Python 2 not supported")
    if not options.strict_optional:
        fail("Disabling strict optional checking not supported")
    options.show_traceback = True
    # Needed to get types for all AST nodes
    options.export_types = True
    # We use mypy incremental mode when doing separate/incremental mypyc compilation
    options.incremental = compiler_options.separate
    options.preserve_asts = True

    for source in mypyc_sources:
        options.per_module_options.setdefault(source.module, {})["mypyc"] = True

    return mypyc_sources, all_sources, options
</t>
<t tx="ekr.20240308084832.110">def visit_return(self, op: Return) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1100">def none_object(self) -&gt; Value:
    return self.builder.none_object()
</t>
<t tx="ekr.20240308084832.1101">def none(self) -&gt; Value:
    return self.builder.none()
</t>
<t tx="ekr.20240308084832.1102">def true(self) -&gt; Value:
    return self.builder.true()
</t>
<t tx="ekr.20240308084832.1103">def false(self) -&gt; Value:
    return self.builder.false()
</t>
<t tx="ekr.20240308084832.1104">def new_list_op(self, values: list[Value], line: int) -&gt; Value:
    return self.builder.new_list_op(values, line)
</t>
<t tx="ekr.20240308084832.1105">def new_set_op(self, values: list[Value], line: int) -&gt; Value:
    return self.builder.new_set_op(values, line)
</t>
<t tx="ekr.20240308084832.1106">def translate_is_op(self, lreg: Value, rreg: Value, expr_op: str, line: int) -&gt; Value:
    return self.builder.translate_is_op(lreg, rreg, expr_op, line)
</t>
<t tx="ekr.20240308084832.1107">def py_call(
    self,
    function: Value,
    arg_values: list[Value],
    line: int,
    arg_kinds: list[ArgKind] | None = None,
    arg_names: Sequence[str | None] | None = None,
) -&gt; Value:
    return self.builder.py_call(function, arg_values, line, arg_kinds, arg_names)
</t>
<t tx="ekr.20240308084832.1108">def add_bool_branch(self, value: Value, true: BasicBlock, false: BasicBlock) -&gt; None:
    self.builder.add_bool_branch(value, true, false)
</t>
<t tx="ekr.20240308084832.1109">def load_native_type_object(self, fullname: str) -&gt; Value:
    return self.builder.load_native_type_object(fullname)
</t>
<t tx="ekr.20240308084832.111">def visit_unreachable(self, op: Unreachable) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1110">def gen_method_call(
    self,
    base: Value,
    name: str,
    arg_values: list[Value],
    result_type: RType | None,
    line: int,
    arg_kinds: list[ArgKind] | None = None,
    arg_names: list[str | None] | None = None,
) -&gt; Value:
    return self.builder.gen_method_call(
        base, name, arg_values, result_type, line, arg_kinds, arg_names, self.can_borrow
    )
</t>
<t tx="ekr.20240308084832.1111">def load_module(self, name: str) -&gt; Value:
    return self.builder.load_module(name)
</t>
<t tx="ekr.20240308084832.1112">def call_c(self, desc: CFunctionDescription, args: list[Value], line: int) -&gt; Value:
    return self.builder.call_c(desc, args, line)
</t>
<t tx="ekr.20240308084832.1113">def int_op(self, type: RType, lhs: Value, rhs: Value, op: int, line: int) -&gt; Value:
    return self.builder.int_op(type, lhs, rhs, op, line)
</t>
<t tx="ekr.20240308084832.1114">def compare_tagged(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    return self.builder.compare_tagged(lhs, rhs, op, line)
</t>
<t tx="ekr.20240308084832.1115">def compare_tuples(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    return self.builder.compare_tuples(lhs, rhs, op, line)
</t>
<t tx="ekr.20240308084832.1116">def builtin_len(self, val: Value, line: int) -&gt; Value:
    return self.builder.builtin_len(val, line)
</t>
<t tx="ekr.20240308084832.1117">def new_tuple(self, items: list[Value], line: int) -&gt; Value:
    return self.builder.new_tuple(items, line)
</t>
<t tx="ekr.20240308084832.1118"># Helpers for IR building

def add_to_non_ext_dict(
    self, non_ext: NonExtClassInfo, key: str, val: Value, line: int
) -&gt; None:
    # Add an attribute entry into the class dict of a non-extension class.
    key_unicode = self.load_str(key)
    self.call_c(dict_set_item_op, [non_ext.dict, key_unicode, val], line)
</t>
<t tx="ekr.20240308084832.1119">def gen_import(self, id: str, line: int) -&gt; None:
    self.imports[id] = None

    needs_import, out = BasicBlock(), BasicBlock()
    self.check_if_module_loaded(id, line, needs_import, out)

    self.activate_block(needs_import)
    value = self.call_c(import_op, [self.load_str(id)], line)
    self.add(InitStatic(value, id, namespace=NAMESPACE_MODULE))
    self.goto_and_activate(out)
</t>
<t tx="ekr.20240308084832.112">def visit_register_op(self, op: RegisterOp) -&gt; tuple[set[str], set[str]]:
    if isinstance(op, SetAttr) and op.obj is self.self_reg:
        return set(), {op.attr}
    if isinstance(op, Call) and op.fn.class_name and op.fn.name == "__init__":
        return set(), attributes_initialized_by_init_call(op)
    return set(), set()
</t>
<t tx="ekr.20240308084832.1120">def check_if_module_loaded(
    self, id: str, line: int, needs_import: BasicBlock, out: BasicBlock
) -&gt; None:
    """Generate code that checks if the module `id` has been loaded yet.

    Arguments:
        id: name of module to check if imported
        line: line number that the import occurs on
        needs_import: the BasicBlock that is run if the module has not been loaded yet
        out: the BasicBlock that is run if the module has already been loaded"""
    first_load = self.load_module(id)
    comparison = self.translate_is_op(first_load, self.none_object(), "is not", line)
    self.add_bool_branch(comparison, out, needs_import)
</t>
<t tx="ekr.20240308084832.1121">def get_module(self, module: str, line: int) -&gt; Value:
    # Python 3.7 has a nice 'PyImport_GetModule' function that we can't use :(
    mod_dict = self.call_c(get_module_dict_op, [], line)
    # Get module object from modules dict.
    return self.call_c(dict_get_item_op, [mod_dict, self.load_str(module)], line)
</t>
<t tx="ekr.20240308084832.1122">def get_module_attr(self, module: str, attr: str, line: int) -&gt; Value:
    """Look up an attribute of a module without storing it in the local namespace.

    For example, get_module_attr('typing', 'TypedDict', line) results in
    the value of 'typing.TypedDict'.

    Import the module if needed.
    """
    self.gen_import(module, line)
    module_obj = self.get_module(module, line)
    return self.py_get_attr(module_obj, attr, line)
</t>
<t tx="ekr.20240308084832.1123">def assign_if_null(self, target: Register, get_val: Callable[[], Value], line: int) -&gt; None:
    """If target is NULL, assign value produced by get_val to it."""
    error_block, body_block = BasicBlock(), BasicBlock()
    self.add(Branch(target, error_block, body_block, Branch.IS_ERROR))
    self.activate_block(error_block)
    self.add(Assign(target, self.coerce(get_val(), target.type, line)))
    self.goto(body_block)
    self.activate_block(body_block)
</t>
<t tx="ekr.20240308084832.1124">def assign_if_bitmap_unset(
    self, target: Register, get_val: Callable[[], Value], index: int, line: int
) -&gt; None:
    error_block, body_block = BasicBlock(), BasicBlock()
    o = self.int_op(
        bitmap_rprimitive,
        self.builder.args[-1 - index // BITMAP_BITS],
        Integer(1 &lt;&lt; (index &amp; (BITMAP_BITS - 1)), bitmap_rprimitive),
        IntOp.AND,
        line,
    )
    b = self.add(ComparisonOp(o, Integer(0, bitmap_rprimitive), ComparisonOp.EQ))
    self.add(Branch(b, error_block, body_block, Branch.BOOL))
    self.activate_block(error_block)
    self.add(Assign(target, self.coerce(get_val(), target.type, line)))
    self.goto(body_block)
    self.activate_block(body_block)
</t>
<t tx="ekr.20240308084832.1125">def maybe_add_implicit_return(self) -&gt; None:
    if is_none_rprimitive(self.ret_types[-1]) or is_object_rprimitive(self.ret_types[-1]):
        self.add_implicit_return()
    else:
        self.add_implicit_unreachable()
</t>
<t tx="ekr.20240308084832.1126">def add_implicit_return(self) -&gt; None:
    block = self.builder.blocks[-1]
    if not block.terminated:
        retval = self.coerce(self.builder.none(), self.ret_types[-1], -1)
        self.nonlocal_control[-1].gen_return(self, retval, self.fn_info.fitem.line)
</t>
<t tx="ekr.20240308084832.1127">def add_implicit_unreachable(self) -&gt; None:
    block = self.builder.blocks[-1]
    if not block.terminated:
        self.add(Unreachable())
</t>
<t tx="ekr.20240308084832.1128">def disallow_class_assignments(self, lvalues: list[Lvalue], line: int) -&gt; None:
    # Some best-effort attempts to disallow assigning to class
    # variables that aren't marked ClassVar, since we blatantly
    # miscompile the interaction between instance and class
    # variables.
    for lvalue in lvalues:
        if (
            isinstance(lvalue, MemberExpr)
            and isinstance(lvalue.expr, RefExpr)
            and isinstance(lvalue.expr.node, TypeInfo)
        ):
            var = lvalue.expr.node[lvalue.name].node
            if isinstance(var, Var) and not var.is_classvar:
                self.error("Only class variables defined as ClassVar can be assigned to", line)
</t>
<t tx="ekr.20240308084832.1129">def non_function_scope(self) -&gt; bool:
    # Currently the stack always has at least two items: dummy and top-level.
    return len(self.fn_infos) &lt;= 2
</t>
<t tx="ekr.20240308084832.113">def visit_assign(self, op: Assign) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1130">def top_level_fn_info(self) -&gt; FuncInfo | None:
    if self.non_function_scope():
        return None
    return self.fn_infos[2]
</t>
<t tx="ekr.20240308084832.1131">def init_final_static(
    self,
    lvalue: Lvalue,
    rvalue_reg: Value,
    class_name: str | None = None,
    *,
    type_override: RType | None = None,
) -&gt; None:
    assert isinstance(lvalue, NameExpr)
    assert isinstance(lvalue.node, Var)
    if lvalue.node.final_value is None:
        if class_name is None:
            name = lvalue.name
        else:
            name = f"{class_name}.{lvalue.name}"
        assert name is not None, "Full name not set for variable"
        coerced = self.coerce(rvalue_reg, type_override or self.node_type(lvalue), lvalue.line)
        self.final_names.append((name, coerced.type))
        self.add(InitStatic(coerced, name, self.module_name))
</t>
<t tx="ekr.20240308084832.1132">def load_final_static(
    self, fullname: str, typ: RType, line: int, error_name: str | None = None
) -&gt; Value:
    split_name = split_target(self.graph, fullname)
    assert split_name is not None
    module, name = split_name
    return self.builder.load_static_checked(
        typ,
        name,
        module,
        line=line,
        error_msg=f'value for final name "{error_name}" was not set',
    )
</t>
<t tx="ekr.20240308084832.1133">def load_literal_value(self, val: int | str | bytes | float | complex | bool) -&gt; Value:
    """Load value of a final name, class-level attribute, or constant folded expression."""
    if isinstance(val, bool):
        if val:
            return self.true()
        else:
            return self.false()
    elif isinstance(val, int):
        return self.builder.load_int(val)
    elif isinstance(val, float):
        return self.builder.load_float(val)
    elif isinstance(val, str):
        return self.builder.load_str(val)
    elif isinstance(val, bytes):
        return self.builder.load_bytes(val)
    elif isinstance(val, complex):
        return self.builder.load_complex(val)
    else:
        assert False, "Unsupported literal value"
</t>
<t tx="ekr.20240308084832.1134">def get_assignment_target(
    self, lvalue: Lvalue, line: int = -1, *, for_read: bool = False
) -&gt; AssignmentTarget:
    if line == -1:
        line = lvalue.line
    if isinstance(lvalue, NameExpr):
        # If we are visiting a decorator, then the SymbolNode we really want to be looking at
        # is the function that is decorated, not the entire Decorator node itself.
        symbol = lvalue.node
        if isinstance(symbol, Decorator):
            symbol = symbol.func
        if symbol is None:
            # New semantic analyzer doesn't create ad-hoc Vars for special forms.
            assert lvalue.is_special_form
            symbol = Var(lvalue.name)
        if not for_read and isinstance(symbol, Var) and symbol.is_cls:
            self.error("Cannot assign to the first argument of classmethod", line)
        if lvalue.kind == LDEF:
            if symbol not in self.symtables[-1]:
                if isinstance(symbol, Var) and not isinstance(symbol.type, DeletedType):
                    reg_type = self.type_to_rtype(symbol.type)
                else:
                    reg_type = self.node_type(lvalue)
                # If the function is a generator function, then first define a new variable
                # in the current function's environment class. Next, define a target that
                # refers to the newly defined variable in that environment class. Add the
                # target to the table containing class environment variables, as well as the
                # current environment.
                if self.fn_info.is_generator:
                    return self.add_var_to_env_class(
                        symbol, reg_type, self.fn_info.generator_class, reassign=False
                    )

                # Otherwise define a new local variable.
                return self.add_local_reg(symbol, reg_type)
            else:
                # Assign to a previously defined variable.
                return self.lookup(symbol)
        elif lvalue.kind == GDEF:
            globals_dict = self.load_globals_dict()
            name = self.load_str(lvalue.name)
            return AssignmentTargetIndex(globals_dict, name)
        else:
            assert False, lvalue.kind
    elif isinstance(lvalue, IndexExpr):
        # Indexed assignment x[y] = e
        base = self.accept(lvalue.base)
        index = self.accept(lvalue.index)
        return AssignmentTargetIndex(base, index)
    elif isinstance(lvalue, MemberExpr):
        # Attribute assignment x.y = e
        can_borrow = self.is_native_attr_ref(lvalue)
        obj = self.accept(lvalue.expr, can_borrow=can_borrow)
        return AssignmentTargetAttr(obj, lvalue.name, can_borrow=can_borrow)
    elif isinstance(lvalue, TupleExpr):
        # Multiple assignment a, ..., b = e
        star_idx: int | None = None
        lvalues = []
        for idx, item in enumerate(lvalue.items):
            targ = self.get_assignment_target(item)
            lvalues.append(targ)
            if isinstance(item, StarExpr):
                if star_idx is not None:
                    self.error("Two starred expressions in assignment", line)
                star_idx = idx

        return AssignmentTargetTuple(lvalues, star_idx)

    elif isinstance(lvalue, StarExpr):
        return self.get_assignment_target(lvalue.expr)

    assert False, "Unsupported lvalue: %r" % lvalue
</t>
<t tx="ekr.20240308084832.1135">def read(
    self, target: Value | AssignmentTarget, line: int = -1, can_borrow: bool = False
) -&gt; Value:
    if isinstance(target, Value):
        return target
    if isinstance(target, AssignmentTargetRegister):
        return target.register
    if isinstance(target, AssignmentTargetIndex):
        reg = self.gen_method_call(
            target.base, "__getitem__", [target.index], target.type, line
        )
        if reg is not None:
            return reg
        assert False, target.base.type
    if isinstance(target, AssignmentTargetAttr):
        if isinstance(target.obj.type, RInstance) and target.obj.type.class_ir.is_ext_class:
            borrow = can_borrow and target.can_borrow
            return self.add(GetAttr(target.obj, target.attr, line, borrow=borrow))
        else:
            return self.py_get_attr(target.obj, target.attr, line)

    assert False, "Unsupported lvalue: %r" % target
</t>
<t tx="ekr.20240308084832.1136">def assign(self, target: Register | AssignmentTarget, rvalue_reg: Value, line: int) -&gt; None:
    if isinstance(target, Register):
        self.add(Assign(target, self.coerce_rvalue(rvalue_reg, target.type, line)))
    elif isinstance(target, AssignmentTargetRegister):
        rvalue_reg = self.coerce_rvalue(rvalue_reg, target.type, line)
        self.add(Assign(target.register, rvalue_reg))
    elif isinstance(target, AssignmentTargetAttr):
        if isinstance(target.obj_type, RInstance):
            rvalue_reg = self.coerce_rvalue(rvalue_reg, target.type, line)
            self.add(SetAttr(target.obj, target.attr, rvalue_reg, line))
        else:
            key = self.load_str(target.attr)
            boxed_reg = self.builder.box(rvalue_reg)
            self.call_c(py_setattr_op, [target.obj, key, boxed_reg], line)
    elif isinstance(target, AssignmentTargetIndex):
        target_reg2 = self.gen_method_call(
            target.base, "__setitem__", [target.index, rvalue_reg], None, line
        )
        assert target_reg2 is not None, target.base.type
    elif isinstance(target, AssignmentTargetTuple):
        if isinstance(rvalue_reg.type, RTuple) and target.star_idx is None:
            rtypes = rvalue_reg.type.types
            assert len(rtypes) == len(target.items)
            for i in range(len(rtypes)):
                item_value = self.add(TupleGet(rvalue_reg, i, line))
                self.assign(target.items[i], item_value, line)
        elif (
            is_list_rprimitive(rvalue_reg.type) or is_tuple_rprimitive(rvalue_reg.type)
        ) and target.star_idx is None:
            self.process_sequence_assignment(target, rvalue_reg, line)
        else:
            self.process_iterator_tuple_assignment(target, rvalue_reg, line)
    else:
        assert False, "Unsupported assignment target"
</t>
<t tx="ekr.20240308084832.1137">def coerce_rvalue(self, rvalue: Value, rtype: RType, line: int) -&gt; Value:
    if is_float_rprimitive(rtype) and is_tagged(rvalue.type):
        typename = rvalue.type.short_name()
        if typename == "short_int":
            typename = "int"
        self.error(
            "Incompatible value representations in assignment "
            + f'(expression has type "{typename}", variable has type "float")',
            line,
        )
    return self.coerce(rvalue, rtype, line)
</t>
<t tx="ekr.20240308084832.1138">def process_sequence_assignment(
    self, target: AssignmentTargetTuple, rvalue: Value, line: int
) -&gt; None:
    """Process assignment like 'x, y = s', where s is a variable-length list or tuple."""
    # Check the length of sequence.
    expected_len = Integer(len(target.items), c_pyssize_t_rprimitive)
    self.builder.call_c(check_unpack_count_op, [rvalue, expected_len], line)

    # Read sequence items.
    values = []
    for i in range(len(target.items)):
        item = target.items[i]
        index = self.builder.load_int(i)
        if is_list_rprimitive(rvalue.type):
            item_value = self.call_c(list_get_item_unsafe_op, [rvalue, index], line)
        else:
            item_value = self.builder.gen_method_call(
                rvalue, "__getitem__", [index], item.type, line
            )
        values.append(item_value)

    # Assign sequence items to the target lvalues.
    for lvalue, value in zip(target.items, values):
        self.assign(lvalue, value, line)
</t>
<t tx="ekr.20240308084832.1139">def process_iterator_tuple_assignment_helper(
    self, litem: AssignmentTarget, ritem: Value, line: int
) -&gt; None:
    error_block, ok_block = BasicBlock(), BasicBlock()
    self.add(Branch(ritem, error_block, ok_block, Branch.IS_ERROR))

    self.activate_block(error_block)
    self.add(
        RaiseStandardError(RaiseStandardError.VALUE_ERROR, "not enough values to unpack", line)
    )
    self.add(Unreachable())

    self.activate_block(ok_block)
    self.assign(litem, ritem, line)
</t>
<t tx="ekr.20240308084832.114">def visit_assign_multi(self, op: AssignMulti) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1140">def process_iterator_tuple_assignment(
    self, target: AssignmentTargetTuple, rvalue_reg: Value, line: int
) -&gt; None:
    iterator = self.call_c(iter_op, [rvalue_reg], line)

    # This may be the whole lvalue list if there is no starred value
    split_idx = target.star_idx if target.star_idx is not None else len(target.items)

    # Assign values before the first starred value
    for litem in target.items[:split_idx]:
        ritem = self.call_c(next_op, [iterator], line)
        error_block, ok_block = BasicBlock(), BasicBlock()
        self.add(Branch(ritem, error_block, ok_block, Branch.IS_ERROR))

        self.activate_block(error_block)
        self.add(
            RaiseStandardError(
                RaiseStandardError.VALUE_ERROR, "not enough values to unpack", line
            )
        )
        self.add(Unreachable())

        self.activate_block(ok_block)

        self.assign(litem, ritem, line)

    # Assign the starred value and all values after it
    if target.star_idx is not None:
        post_star_vals = target.items[split_idx + 1 :]
        iter_list = self.call_c(to_list, [iterator], line)
        iter_list_len = self.builtin_len(iter_list, line)
        post_star_len = Integer(len(post_star_vals))
        condition = self.binary_op(post_star_len, iter_list_len, "&lt;=", line)

        error_block, ok_block = BasicBlock(), BasicBlock()
        self.add(Branch(condition, ok_block, error_block, Branch.BOOL))

        self.activate_block(error_block)
        self.add(
            RaiseStandardError(
                RaiseStandardError.VALUE_ERROR, "not enough values to unpack", line
            )
        )
        self.add(Unreachable())

        self.activate_block(ok_block)

        for litem in reversed(post_star_vals):
            ritem = self.call_c(list_pop_last, [iter_list], line)
            self.assign(litem, ritem, line)

        # Assign the starred value
        self.assign(target.items[target.star_idx], iter_list, line)

    # There is no starred value, so check if there are extra values in rhs that
    # have not been assigned.
    else:
        extra = self.call_c(next_op, [iterator], line)
        error_block, ok_block = BasicBlock(), BasicBlock()
        self.add(Branch(extra, ok_block, error_block, Branch.IS_ERROR))

        self.activate_block(error_block)
        self.add(
            RaiseStandardError(
                RaiseStandardError.VALUE_ERROR, "too many values to unpack", line
            )
        )
        self.add(Unreachable())

        self.activate_block(ok_block)
</t>
<t tx="ekr.20240308084832.1141">def push_loop_stack(self, continue_block: BasicBlock, break_block: BasicBlock) -&gt; None:
    self.nonlocal_control.append(
        LoopNonlocalControl(self.nonlocal_control[-1], continue_block, break_block)
    )
</t>
<t tx="ekr.20240308084832.1142">def pop_loop_stack(self) -&gt; None:
    self.nonlocal_control.pop()
</t>
<t tx="ekr.20240308084832.1143">def make_spill_target(self, type: RType) -&gt; AssignmentTarget:
    """Moves a given Value instance into the generator class' environment class."""
    name = f"{TEMP_ATTR_NAME}{self.temp_counter}"
    self.temp_counter += 1
    target = self.add_var_to_env_class(Var(name), type, self.fn_info.generator_class)
    return target
</t>
<t tx="ekr.20240308084832.1144">def spill(self, value: Value) -&gt; AssignmentTarget:
    """Moves a given Value instance into the generator class' environment class."""
    target = self.make_spill_target(value.type)
    # Shouldn't be able to fail, so -1 for line
    self.assign(target, value, -1)
    return target
</t>
<t tx="ekr.20240308084832.1145">def maybe_spill(self, value: Value) -&gt; Value | AssignmentTarget:
    """
    Moves a given Value instance into the environment class for generator functions. For
    non-generator functions, leaves the Value instance as it is.

    Returns an AssignmentTarget associated with the Value for generator functions and the
    original Value itself for non-generator functions.
    """
    if self.fn_info.is_generator:
        return self.spill(value)
    return value
</t>
<t tx="ekr.20240308084832.1146">def maybe_spill_assignable(self, value: Value) -&gt; Register | AssignmentTarget:
    """
    Moves a given Value instance into the environment class for generator functions. For
    non-generator functions, allocate a temporary Register.

    Returns an AssignmentTarget associated with the Value for generator functions and an
    assignable Register for non-generator functions.
    """
    if self.fn_info.is_generator:
        return self.spill(value)

    if isinstance(value, Register):
        return value

    # Allocate a temporary register for the assignable value.
    reg = Register(value.type)
    self.assign(reg, value, -1)
    return reg
</t>
<t tx="ekr.20240308084832.1147">def extract_int(self, e: Expression) -&gt; int | None:
    if isinstance(e, IntExpr):
        return e.value
    elif isinstance(e, UnaryExpr) and e.op == "-" and isinstance(e.expr, IntExpr):
        return -e.expr.value
    else:
        return None
</t>
<t tx="ekr.20240308084832.1148">def get_sequence_type(self, expr: Expression) -&gt; RType:
    return self.get_sequence_type_from_type(self.types[expr])
</t>
<t tx="ekr.20240308084832.1149">def get_sequence_type_from_type(self, target_type: Type) -&gt; RType:
    target_type = get_proper_type(target_type)
    if isinstance(target_type, UnionType):
        return RUnion.make_simplified_union(
            [self.get_sequence_type_from_type(item) for item in target_type.items]
        )
    assert isinstance(target_type, Instance), target_type
    if target_type.type.fullname == "builtins.str":
        return str_rprimitive
    else:
        return self.type_to_rtype(target_type.args[0])
</t>
<t tx="ekr.20240308084832.115">def visit_set_mem(self, op: SetMem) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1150">def get_dict_base_type(self, expr: Expression) -&gt; list[Instance]:
    """Find dict type of a dict-like expression.

    This is useful for dict subclasses like SymbolTable.
    """
    target_type = get_proper_type(self.types[expr])
    if isinstance(target_type, UnionType):
        types = [get_proper_type(item) for item in target_type.items]
    else:
        types = [target_type]

    dict_types = []
    for t in types:
        if isinstance(t, TypedDictType):
            t = t.fallback
            dict_base = next(base for base in t.type.mro if base.fullname == "typing.Mapping")
        else:
            assert isinstance(t, Instance), t
            dict_base = next(base for base in t.type.mro if base.fullname == "builtins.dict")
        dict_types.append(map_instance_to_supertype(t, dict_base))
    return dict_types
</t>
<t tx="ekr.20240308084832.1151">def get_dict_key_type(self, expr: Expression) -&gt; RType:
    dict_base_types = self.get_dict_base_type(expr)
    if len(dict_base_types) == 1:
        return self.type_to_rtype(dict_base_types[0].args[0])
    else:
        rtypes = [self.type_to_rtype(t.args[0]) for t in dict_base_types]
        return RUnion.make_simplified_union(rtypes)
</t>
<t tx="ekr.20240308084832.1152">def get_dict_value_type(self, expr: Expression) -&gt; RType:
    dict_base_types = self.get_dict_base_type(expr)
    if len(dict_base_types) == 1:
        return self.type_to_rtype(dict_base_types[0].args[1])
    else:
        rtypes = [self.type_to_rtype(t.args[1]) for t in dict_base_types]
        return RUnion.make_simplified_union(rtypes)
</t>
<t tx="ekr.20240308084832.1153">def get_dict_item_type(self, expr: Expression) -&gt; RType:
    key_type = self.get_dict_key_type(expr)
    value_type = self.get_dict_value_type(expr)
    return RTuple([key_type, value_type])
</t>
<t tx="ekr.20240308084832.1154">def _analyze_iterable_item_type(self, expr: Expression) -&gt; Type:
    """Return the item type given by 'expr' in an iterable context."""
    # This logic is copied from mypy's TypeChecker.analyze_iterable_item_type.
    if expr not in self.types:
        # Mypy thinks this is unreachable.
        iterable: ProperType = AnyType(TypeOfAny.from_error)
    else:
        iterable = get_proper_type(self.types[expr])
    echk = self.graph[self.module_name].type_checker().expr_checker
    iterator = echk.check_method_call_by_name("__iter__", iterable, [], [], expr)[0]

    from mypy.join import join_types

    if isinstance(iterable, TupleType):
        joined: Type = UninhabitedType()
        for item in iterable.items:
            joined = join_types(joined, item)
        return joined
    else:
        # Non-tuple iterable.
        return echk.check_method_call_by_name("__next__", iterator, [], [], expr)[0]
</t>
<t tx="ekr.20240308084832.1155">def is_native_module(self, module: str) -&gt; bool:
    """Is the given module one compiled by mypyc?"""
    return module in self.mapper.group_map
</t>
<t tx="ekr.20240308084832.1156">def is_native_ref_expr(self, expr: RefExpr) -&gt; bool:
    if expr.node is None:
        return False
    if "." in expr.node.fullname:
        return self.is_native_module(expr.node.fullname.rpartition(".")[0])
    return True
</t>
<t tx="ekr.20240308084832.1157">def is_native_module_ref_expr(self, expr: RefExpr) -&gt; bool:
    return self.is_native_ref_expr(expr) and expr.kind == GDEF
</t>
<t tx="ekr.20240308084832.1158">def is_synthetic_type(self, typ: TypeInfo) -&gt; bool:
    """Is a type something other than just a class we've created?"""
    return typ.is_named_tuple or typ.is_newtype or typ.typeddict_type is not None
</t>
<t tx="ekr.20240308084832.1159">def get_final_ref(self, expr: MemberExpr) -&gt; tuple[str, Var, bool] | None:
    """Check if `expr` is a final attribute.

    This needs to be done differently for class and module attributes to
    correctly determine fully qualified name. Return a tuple that consists of
    the qualified name, the corresponding Var node, and a flag indicating whether
    the final name was defined in a compiled module. Return None if `expr` does not
    refer to a final attribute.
    """
    final_var = None
    if isinstance(expr.expr, RefExpr) and isinstance(expr.expr.node, TypeInfo):
        # a class attribute
        sym = expr.expr.node.get(expr.name)
        if sym and isinstance(sym.node, Var):
            # Enum attribute are treated as final since they are added to the global cache
            expr_fullname = expr.expr.node.bases[0].type.fullname
            is_final = sym.node.is_final or expr_fullname == "enum.Enum"
            if is_final:
                final_var = sym.node
                fullname = f"{sym.node.info.fullname}.{final_var.name}"
                native = self.is_native_module(expr.expr.node.module_name)
    elif self.is_module_member_expr(expr):
        # a module attribute
        if isinstance(expr.node, Var) and expr.node.is_final:
            final_var = expr.node
            fullname = expr.node.fullname
            native = self.is_native_ref_expr(expr)
    if final_var is not None:
        return fullname, final_var, native
    return None
</t>
<t tx="ekr.20240308084832.116">def analyze_maybe_undefined_attrs_in_init(
    blocks: list[BasicBlock], self_reg: Register, initial_undefined: set[str], cfg: CFG
) -&gt; AnalysisResult[str]:
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=AttributeMaybeUndefinedVisitor(self_reg),
        initial=initial_undefined,
        backward=False,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.1160">def emit_load_final(
    self, final_var: Var, fullname: str, name: str, native: bool, typ: Type, line: int
) -&gt; Value | None:
    """Emit code for loading value of a final name (if possible).

    Args:
        final_var: Var corresponding to the final name
        fullname: its qualified name
        name: shorter name to show in errors
        native: whether the name was defined in a compiled module
        typ: its type
        line: line number where loading occurs
    """
    if final_var.final_value is not None:  # this is safe even for non-native names
        return self.load_literal_value(final_var.final_value)
    elif native:
        return self.load_final_static(fullname, self.mapper.type_to_rtype(typ), line, name)
    else:
        return None
</t>
<t tx="ekr.20240308084832.1161">def is_module_member_expr(self, expr: MemberExpr) -&gt; bool:
    return isinstance(expr.expr, RefExpr) and isinstance(expr.expr.node, MypyFile)
</t>
<t tx="ekr.20240308084832.1162">def call_refexpr_with_args(
    self, expr: CallExpr, callee: RefExpr, arg_values: list[Value]
) -&gt; Value:
    # Handle data-driven special-cased primitive call ops.
    if callee.fullname and expr.arg_kinds == [ARG_POS] * len(arg_values):
        fullname = get_call_target_fullname(callee)
        call_c_ops_candidates = function_ops.get(fullname, [])
        target = self.builder.matching_call_c(
            call_c_ops_candidates, arg_values, expr.line, self.node_type(expr)
        )
        if target:
            return target

    # Standard native call if signature and fullname are good and all arguments are positional
    # or named.
    callee_node = callee.node
    if isinstance(callee_node, OverloadedFuncDef):
        callee_node = callee_node.impl
    # TODO: use native calls for any decorated functions which have all their decorators
    # removed, not just singledispatch functions (which we don't do now just in case those
    # decorated functions are callable classes or cannot be called without the python API for
    # some other reason)
    if (
        isinstance(callee_node, Decorator)
        and callee_node.func not in self.fdefs_to_decorators
        and callee_node.func in self.singledispatch_impls
    ):
        callee_node = callee_node.func
    if (
        callee_node is not None
        and callee.fullname
        and callee_node in self.mapper.func_to_decl
        and all(kind in (ARG_POS, ARG_NAMED) for kind in expr.arg_kinds)
    ):
        decl = self.mapper.func_to_decl[callee_node]
        return self.builder.call(decl, arg_values, expr.arg_kinds, expr.arg_names, expr.line)

    # Fall back to a Python call
    function = self.accept(callee)
    return self.py_call(
        function, arg_values, expr.line, arg_kinds=expr.arg_kinds, arg_names=expr.arg_names
    )
</t>
<t tx="ekr.20240308084832.1163">def shortcircuit_expr(self, expr: OpExpr) -&gt; Value:
    return self.builder.shortcircuit_helper(
        expr.op,
        self.node_type(expr),
        lambda: self.accept(expr.left),
        lambda: self.accept(expr.right),
        expr.line,
    )
</t>
<t tx="ekr.20240308084832.1164"># Basic helpers

def flatten_classes(self, arg: RefExpr | TupleExpr) -&gt; list[ClassIR] | None:
    """Flatten classes in isinstance(obj, (A, (B, C))).

    If at least one item is not a reference to a native class, return None.
    """
    if isinstance(arg, RefExpr):
        if isinstance(arg.node, TypeInfo) and self.is_native_module_ref_expr(arg):
            ir = self.mapper.type_to_ir.get(arg.node)
            if ir:
                return [ir]
        return None
    else:
        res: list[ClassIR] = []
        for item in arg.items:
            if isinstance(item, (RefExpr, TupleExpr)):
                item_part = self.flatten_classes(item)
                if item_part is None:
                    return None
                res.extend(item_part)
            else:
                return None
        return res
</t>
<t tx="ekr.20240308084832.1165">def enter(self, fn_info: FuncInfo | str = "") -&gt; None:
    if isinstance(fn_info, str):
        fn_info = FuncInfo(name=fn_info)
    self.builder = LowLevelIRBuilder(
        self.current_module, self.errors, self.mapper, self.options
    )
    self.builder.set_module(self.module_name, self.module_path)
    self.builders.append(self.builder)
    self.symtables.append({})
    self.runtime_args.append([])
    self.fn_info = fn_info
    self.fn_infos.append(self.fn_info)
    self.ret_types.append(none_rprimitive)
    if fn_info.is_generator:
        self.nonlocal_control.append(GeneratorNonlocalControl())
    else:
        self.nonlocal_control.append(BaseNonlocalControl())
    self.activate_block(BasicBlock())
</t>
<t tx="ekr.20240308084832.1166">def leave(self) -&gt; tuple[list[Register], list[RuntimeArg], list[BasicBlock], RType, FuncInfo]:
    builder = self.builders.pop()
    self.symtables.pop()
    runtime_args = self.runtime_args.pop()
    ret_type = self.ret_types.pop()
    fn_info = self.fn_infos.pop()
    self.nonlocal_control.pop()
    self.builder = self.builders[-1]
    self.fn_info = self.fn_infos[-1]
    return builder.args, runtime_args, builder.blocks, ret_type, fn_info
</t>
<t tx="ekr.20240308084832.1167">@contextmanager
def enter_method(
    self,
    class_ir: ClassIR,
    name: str,
    ret_type: RType,
    fn_info: FuncInfo | str = "",
    self_type: RType | None = None,
) -&gt; Iterator[None]:
    """Generate IR for a method.

    If the method takes arguments, you should immediately afterwards call
    add_argument() for each non-self argument (self is created implicitly).

    Args:
        class_ir: Add method to this class
        name: Short name of the method
        ret_type: Return type of the method
        fn_info: Optionally, additional information about the method
        self_type: If not None, override default type of the implicit 'self'
            argument (by default, derive type from class_ir)
    """
    self.enter(fn_info)
    self.function_name_stack.append(name)
    self.class_ir_stack.append(class_ir)
    self.ret_types[-1] = ret_type
    if self_type is None:
        self_type = RInstance(class_ir)
    self.add_argument(SELF_NAME, self_type)
    try:
        yield
    finally:
        arg_regs, args, blocks, ret_type, fn_info = self.leave()
        sig = FuncSignature(args, ret_type)
        name = self.function_name_stack.pop()
        class_ir = self.class_ir_stack.pop()
        decl = FuncDecl(name, class_ir.name, self.module_name, sig)
        ir = FuncIR(decl, arg_regs, blocks)
        class_ir.methods[name] = ir
        class_ir.method_decls[name] = ir.decl
        self.functions.append(ir)
</t>
<t tx="ekr.20240308084832.1168">def add_argument(self, var: str | Var, typ: RType, kind: ArgKind = ARG_POS) -&gt; Register:
    """Declare an argument in the current function.

    You should use this instead of directly calling add_local() in new code.
    """
    if isinstance(var, str):
        var = Var(var)
    reg = self.add_local(var, typ, is_arg=True)
    self.runtime_args[-1].append(RuntimeArg(var.name, typ, kind))
    return reg
</t>
<t tx="ekr.20240308084832.1169">def lookup(self, symbol: SymbolNode) -&gt; SymbolTarget:
    return self.symtables[-1][symbol]
</t>
<t tx="ekr.20240308084832.117">def update_always_defined_attrs_using_subclasses(cl: ClassIR, seen: set[ClassIR]) -&gt; None:
    """Remove attributes not defined in all subclasses from always defined attrs."""
    if cl in seen:
        return
    if cl.children is None:
        # Subclasses are unknown
        return
    removed = set()
    for attr in cl._always_initialized_attrs:
        for child in cl.children:
            update_always_defined_attrs_using_subclasses(child, seen)
            if attr not in child._always_initialized_attrs:
                removed.add(attr)
    cl._always_initialized_attrs -= removed
    seen.add(cl)
</t>
<t tx="ekr.20240308084832.1170">def add_local(self, symbol: SymbolNode, typ: RType, is_arg: bool = False) -&gt; Register:
    """Add register that represents a symbol to the symbol table.

    Args:
        is_arg: is this a function argument
    """
    assert isinstance(symbol, SymbolNode)
    reg = Register(
        typ, remangle_redefinition_name(symbol.name), is_arg=is_arg, line=symbol.line
    )
    self.symtables[-1][symbol] = AssignmentTargetRegister(reg)
    if is_arg:
        self.builder.args.append(reg)
    return reg
</t>
<t tx="ekr.20240308084832.1171">def add_local_reg(
    self, symbol: SymbolNode, typ: RType, is_arg: bool = False
) -&gt; AssignmentTargetRegister:
    """Like add_local, but return an assignment target instead of value."""
    self.add_local(symbol, typ, is_arg)
    target = self.symtables[-1][symbol]
    assert isinstance(target, AssignmentTargetRegister)
    return target
</t>
<t tx="ekr.20240308084832.1172">def add_self_to_env(self, cls: ClassIR) -&gt; AssignmentTargetRegister:
    """Low-level function that adds a 'self' argument.

    This is only useful if using enter() instead of enter_method().
    """
    return self.add_local_reg(Var(SELF_NAME), RInstance(cls), is_arg=True)
</t>
<t tx="ekr.20240308084832.1173">def add_target(self, symbol: SymbolNode, target: SymbolTarget) -&gt; SymbolTarget:
    self.symtables[-1][symbol] = target
    return target
</t>
<t tx="ekr.20240308084832.1174">def type_to_rtype(self, typ: Type | None) -&gt; RType:
    return self.mapper.type_to_rtype(typ)
</t>
<t tx="ekr.20240308084832.1175">def node_type(self, node: Expression) -&gt; RType:
    if isinstance(node, IntExpr):
        # TODO: Don't special case IntExpr
        return int_rprimitive
    if node not in self.types:
        return object_rprimitive
    mypy_type = self.types[node]
    return self.type_to_rtype(mypy_type)
</t>
<t tx="ekr.20240308084832.1176">def add_var_to_env_class(
    self, var: SymbolNode, rtype: RType, base: FuncInfo | ImplicitClass, reassign: bool = False
) -&gt; AssignmentTarget:
    # First, define the variable name as an attribute of the environment class, and then
    # construct a target for that attribute.
    self.fn_info.env_class.attributes[var.name] = rtype
    attr_target = AssignmentTargetAttr(base.curr_env_reg, var.name)

    if reassign:
        # Read the local definition of the variable, and set the corresponding attribute of
        # the environment class' variable to be that value.
        reg = self.read(self.lookup(var), self.fn_info.fitem.line)
        self.add(SetAttr(base.curr_env_reg, var.name, reg, self.fn_info.fitem.line))

    # Override the local definition of the variable to instead point at the variable in
    # the environment class.
    return self.add_target(var, attr_target)
</t>
<t tx="ekr.20240308084832.1177">def is_builtin_ref_expr(self, expr: RefExpr) -&gt; bool:
    assert expr.node, "RefExpr not resolved"
    return "." in expr.node.fullname and expr.node.fullname.split(".")[0] == "builtins"
</t>
<t tx="ekr.20240308084832.1178">def load_global(self, expr: NameExpr) -&gt; Value:
    """Loads a Python-level global.

    This takes a NameExpr and uses its name as a key to retrieve the corresponding PyObject *
    from the _globals dictionary in the C-generated code.
    """
    # If the global is from 'builtins', turn it into a module attr load instead
    if self.is_builtin_ref_expr(expr):
        assert expr.node, "RefExpr not resolved"
        return self.load_module_attr_by_fullname(expr.node.fullname, expr.line)
    if (
        self.is_native_module_ref_expr(expr)
        and isinstance(expr.node, TypeInfo)
        and not self.is_synthetic_type(expr.node)
    ):
        assert expr.fullname
        return self.load_native_type_object(expr.fullname)
    return self.load_global_str(expr.name, expr.line)
</t>
<t tx="ekr.20240308084832.1179">def load_global_str(self, name: str, line: int) -&gt; Value:
    _globals = self.load_globals_dict()
    reg = self.load_str(name)
    return self.call_c(dict_get_item_op, [_globals, reg], line)
</t>
<t tx="ekr.20240308084832.118">def detect_undefined_bitmap(cl: ClassIR, seen: set[ClassIR]) -&gt; None:
    if cl.is_trait:
        return

    if cl in seen:
        return
    seen.add(cl)
    for base in cl.base_mro[1:]:
        detect_undefined_bitmap(cl, seen)

    if len(cl.base_mro) &gt; 1:
        cl.bitmap_attrs.extend(cl.base_mro[1].bitmap_attrs)
    for n, t in cl.attributes.items():
        if t.error_overlap and not cl.is_always_defined(n):
            cl.bitmap_attrs.append(n)

    for base in cl.mro[1:]:
        if base.is_trait:
            for n, t in base.attributes.items():
                if t.error_overlap and not cl.is_always_defined(n) and n not in cl.bitmap_attrs:
                    cl.bitmap_attrs.append(n)
</t>
<t tx="ekr.20240308084832.1180">def load_globals_dict(self) -&gt; Value:
    return self.add(LoadStatic(dict_rprimitive, "globals", self.module_name))
</t>
<t tx="ekr.20240308084832.1181">def load_module_attr_by_fullname(self, fullname: str, line: int) -&gt; Value:
    module, _, name = fullname.rpartition(".")
    left = self.load_module(module)
    return self.py_get_attr(left, name, line)
</t>
<t tx="ekr.20240308084832.1182">def is_native_attr_ref(self, expr: MemberExpr) -&gt; bool:
    """Is expr a direct reference to a native (struct) attribute of an instance?"""
    obj_rtype = self.node_type(expr.expr)
    return (
        isinstance(obj_rtype, RInstance)
        and obj_rtype.class_ir.is_ext_class
        and obj_rtype.class_ir.has_attr(expr.name)
        and not obj_rtype.class_ir.get_method(expr.name)
    )
</t>
<t tx="ekr.20240308084832.1183">def mark_block_unreachable(self) -&gt; None:
    """Mark statements in the innermost block being processed as unreachable.

    This should be called after a statement that unconditionally leaves the
    block, such as 'break' or 'return'.
    """
    self.block_reachable_stack[-1] = False
</t>
<t tx="ekr.20240308084832.1184"># Lacks a good type because there wasn't a reasonable type in 3.5 :(
def catch_errors(self, line: int) -&gt; Any:
    return catch_errors(self.module_path, line)
</t>
<t tx="ekr.20240308084832.1185">def warning(self, msg: str, line: int) -&gt; None:
    self.errors.warning(msg, self.module_path, line)
</t>
<t tx="ekr.20240308084832.1186">def error(self, msg: str, line: int) -&gt; None:
    self.errors.error(msg, self.module_path, line)
</t>
<t tx="ekr.20240308084832.1187">def note(self, msg: str, line: int) -&gt; None:
    self.errors.note(msg, self.module_path, line)
</t>
<t tx="ekr.20240308084832.1188">def add_function(self, func_ir: FuncIR, line: int) -&gt; None:
    name = (func_ir.class_name, func_ir.name)
    if name in self.function_names:
        self.error(f'Duplicate definition of "{name[1]}" not supported by mypyc', line)
        return
    self.function_names.add(name)
    self.functions.append(func_ir)
</t>
<t tx="ekr.20240308084832.1189">def gen_arg_defaults(builder: IRBuilder) -&gt; None:
    """Generate blocks for arguments that have default values.

    If the passed value is an error value, then assign the default
    value to the argument.
    """
    fitem = builder.fn_info.fitem
    nb = 0
    for arg in fitem.arguments:
        if arg.initializer:
            target = builder.lookup(arg.variable)

            def get_default() -&gt; Value:
                assert arg.initializer is not None

                # If it is constant, don't bother storing it
                if is_constant(arg.initializer):
                    return builder.accept(arg.initializer)

                # Because gen_arg_defaults runs before calculate_arg_defaults, we
                # add the static/attribute to final_names/the class here.
                elif not builder.fn_info.is_nested:
                    name = fitem.fullname + "." + arg.variable.name
                    builder.final_names.append((name, target.type))
                    return builder.add(LoadStatic(target.type, name, builder.module_name))
                else:
                    name = arg.variable.name
                    builder.fn_info.callable_class.ir.attributes[name] = target.type
                    return builder.add(
                        GetAttr(builder.fn_info.callable_class.self_reg, name, arg.line)
                    )

            assert isinstance(target, AssignmentTargetRegister)
            reg = target.register
            if not reg.type.error_overlap:
                builder.assign_if_null(target.register, get_default, arg.initializer.line)
            else:
                builder.assign_if_bitmap_unset(
                    target.register, get_default, nb, arg.initializer.line
                )
                nb += 1
</t>
<t tx="ekr.20240308084832.119">"""Find basic blocks that are likely to be executed frequently.

For example, this would not include blocks that have exception handlers.

We can use different optimization heuristics for common and rare code. For
example, we can make IR fast to compile instead of fast to execute for rare
code.
"""

from __future__ import annotations

from mypyc.ir.ops import BasicBlock, Branch, Goto


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1190">def remangle_redefinition_name(name: str) -&gt; str:
    """Remangle names produced by mypy when allow-redefinition is used and a name
    is used with multiple types within a single block.

    We only need to do this for locals, because the name is used as the name of the register;
    for globals, the name itself is stored in a register for the purpose of doing dict
    lookups.
    """
    return name.replace("'", "__redef__")
</t>
<t tx="ekr.20240308084832.1191">def get_call_target_fullname(ref: RefExpr) -&gt; str:
    if isinstance(ref.node, TypeAlias):
        # Resolve simple type aliases. In calls they evaluate to the type they point to.
        target = get_proper_type(ref.node.target)
        if isinstance(target, Instance):
            return target.type.fullname
    return ref.fullname
</t>
<t tx="ekr.20240308084832.1192">"""Generate a class that represents a nested function.

The class defines __call__ for calling the function and allows access to
non-local variables defined in outer scopes.
"""

from __future__ import annotations

from mypyc.common import ENV_ATTR_NAME, SELF_NAME
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature, RuntimeArg
from mypyc.ir.ops import BasicBlock, Call, Register, Return, SetAttr, Value
from mypyc.ir.rtypes import RInstance, object_rprimitive
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.context import FuncInfo, ImplicitClass
from mypyc.primitives.misc_ops import method_new_op


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1193">def setup_callable_class(builder: IRBuilder) -&gt; None:
    """Generate an (incomplete) callable class representing a function.

    This can be a nested function or a function within a non-extension
    class.  Also set up the 'self' variable for that class.

    This takes the most recently visited function and returns a
    ClassIR to represent that function. Each callable class contains
    an environment attribute which points to another ClassIR
    representing the environment class where some of its variables can
    be accessed.

    Note that some methods, such as '__call__', are not yet
    created here. Use additional functions, such as
    add_call_to_callable_class(), to add them.

    Return a newly constructed ClassIR representing the callable
    class for the nested function.
    """
    # Check to see that the name has not already been taken. If so,
    # rename the class. We allow multiple uses of the same function
    # name because this is valid in if-else blocks. Example:
    #
    #     if True:
    #         def foo():          ----&gt;    foo_obj()
    #             return True
    #     else:
    #         def foo():          ----&gt;    foo_obj_0()
    #             return False
    name = base_name = f"{builder.fn_info.namespaced_name()}_obj"
    count = 0
    while name in builder.callable_class_names:
        name = base_name + "_" + str(count)
        count += 1
    builder.callable_class_names.add(name)

    # Define the actual callable class ClassIR, and set its
    # environment to point at the previously defined environment
    # class.
    callable_class_ir = ClassIR(name, builder.module_name, is_generated=True)

    # The functools @wraps decorator attempts to call setattr on
    # nested functions, so we create a dict for these nested
    # functions.
    # https://github.com/python/cpython/blob/3.7/Lib/functools.py#L58
    if builder.fn_info.is_nested:
        callable_class_ir.has_dict = True

    # If the enclosing class doesn't contain nested (which will happen if
    # this is a toplevel lambda), don't set up an environment.
    if builder.fn_infos[-2].contains_nested:
        callable_class_ir.attributes[ENV_ATTR_NAME] = RInstance(builder.fn_infos[-2].env_class)
    callable_class_ir.mro = [callable_class_ir]
    builder.fn_info.callable_class = ImplicitClass(callable_class_ir)
    builder.classes.append(callable_class_ir)

    # Add a 'self' variable to the environment of the callable class,
    # and store that variable in a register to be accessed later.
    self_target = builder.add_self_to_env(callable_class_ir)
    builder.fn_info.callable_class.self_reg = builder.read(self_target, builder.fn_info.fitem.line)
</t>
<t tx="ekr.20240308084832.1194">def add_call_to_callable_class(
    builder: IRBuilder,
    args: list[Register],
    blocks: list[BasicBlock],
    sig: FuncSignature,
    fn_info: FuncInfo,
) -&gt; FuncIR:
    """Generate a '__call__' method for a callable class representing a nested function.

    This takes the blocks and signature associated with a function
    definition and uses those to build the '__call__' method of a
    given callable class, used to represent that function.
    """
    # Since we create a method, we also add a 'self' parameter.
    nargs = len(sig.args) - sig.num_bitmap_args
    sig = FuncSignature(
        (RuntimeArg(SELF_NAME, object_rprimitive),) + sig.args[:nargs], sig.ret_type
    )
    call_fn_decl = FuncDecl("__call__", fn_info.callable_class.ir.name, builder.module_name, sig)
    call_fn_ir = FuncIR(
        call_fn_decl, args, blocks, fn_info.fitem.line, traceback_name=fn_info.fitem.name
    )
    fn_info.callable_class.ir.methods["__call__"] = call_fn_ir
    fn_info.callable_class.ir.method_decls["__call__"] = call_fn_decl
    return call_fn_ir
</t>
<t tx="ekr.20240308084832.1195">def add_get_to_callable_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; None:
    """Generate the '__get__' method for a callable class."""
    line = fn_info.fitem.line
    with builder.enter_method(
        fn_info.callable_class.ir,
        "__get__",
        object_rprimitive,
        fn_info,
        self_type=object_rprimitive,
    ):
        instance = builder.add_argument("instance", object_rprimitive)
        builder.add_argument("owner", object_rprimitive)

        # If accessed through the class, just return the callable
        # object. If accessed through an object, create a new bound
        # instance method object.
        instance_block, class_block = BasicBlock(), BasicBlock()
        comparison = builder.translate_is_op(
            builder.read(instance), builder.none_object(), "is", line
        )
        builder.add_bool_branch(comparison, class_block, instance_block)

        builder.activate_block(class_block)
        builder.add(Return(builder.self()))

        builder.activate_block(instance_block)
        builder.add(
            Return(builder.call_c(method_new_op, [builder.self(), builder.read(instance)], line))
        )
</t>
<t tx="ekr.20240308084832.1196">def instantiate_callable_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; Value:
    """Create an instance of a callable class for a function.

    Calls to the function will actually call this instance.

    Note that fn_info refers to the function being assigned, whereas
    builder.fn_info refers to the function encapsulating the function
    being turned into a callable class.
    """
    fitem = fn_info.fitem
    func_reg = builder.add(Call(fn_info.callable_class.ir.ctor, [], fitem.line))

    # Set the environment attribute of the callable class to point at
    # the environment class defined in the callable class' immediate
    # outer scope. Note that there are three possible environment
    # class registers we may use. This depends on what the encapsulating
    # (parent) function is:
    #
    # - A nested function: the callable class is instantiated
    #   from the current callable class' '__call__' function, and hence
    #   the callable class' environment register is used.
    # - A generator function: the callable class is instantiated
    #   from the '__next__' method of the generator class, and hence the
    #   environment of the generator class is used.
    # - Regular function: we use the environment of the original function.
    curr_env_reg = None
    if builder.fn_info.is_generator:
        curr_env_reg = builder.fn_info.generator_class.curr_env_reg
    elif builder.fn_info.is_nested:
        curr_env_reg = builder.fn_info.callable_class.curr_env_reg
    elif builder.fn_info.contains_nested:
        curr_env_reg = builder.fn_info.curr_env_reg
    if curr_env_reg:
        builder.add(SetAttr(func_reg, ENV_ATTR_NAME, curr_env_reg, fitem.line))
    return func_reg
</t>
<t tx="ekr.20240308084832.1197">"""Transform class definitions from the mypy AST form to IR."""

from __future__ import annotations

import typing_extensions
from abc import abstractmethod
from typing import Callable, Final

from mypy.nodes import (
    AssignmentStmt,
    CallExpr,
    ClassDef,
    Decorator,
    ExpressionStmt,
    FuncDef,
    Lvalue,
    MemberExpr,
    NameExpr,
    OverloadedFuncDef,
    PassStmt,
    RefExpr,
    StrExpr,
    TempNode,
    TypeInfo,
    is_class_var,
)
from mypy.types import ENUM_REMOVED_PROPS, Instance, UnboundType, get_proper_type
from mypyc.common import PROPSET_PREFIX
from mypyc.ir.class_ir import ClassIR, NonExtClassInfo
from mypyc.ir.func_ir import FuncDecl, FuncSignature
from mypyc.ir.ops import (
    NAMESPACE_TYPE,
    BasicBlock,
    Branch,
    Call,
    InitStatic,
    LoadAddress,
    LoadErrorValue,
    LoadStatic,
    MethodCall,
    Register,
    Return,
    SetAttr,
    TupleSet,
    Value,
)
from mypyc.ir.rtypes import (
    RType,
    bool_rprimitive,
    dict_rprimitive,
    is_none_rprimitive,
    is_object_rprimitive,
    is_optional_type,
    object_rprimitive,
)
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.function import (
    gen_property_getter_ir,
    gen_property_setter_ir,
    handle_ext_method,
    handle_non_ext_method,
    load_type,
)
from mypyc.irbuild.util import dataclass_type, get_func_def, is_constant, is_dataclass_decorator
from mypyc.primitives.dict_ops import dict_new_op, dict_set_item_op
from mypyc.primitives.generic_ops import py_hasattr_op, py_setattr_op
from mypyc.primitives.misc_ops import (
    dataclass_sleight_of_hand,
    not_implemented_op,
    py_calc_meta_op,
    pytype_from_template_op,
    type_object_op,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1198">def transform_class_def(builder: IRBuilder, cdef: ClassDef) -&gt; None:
    """Create IR for a class definition.

    This can generate both extension (native) and non-extension
    classes.  These are generated in very different ways. In the
    latter case we construct a Python type object at runtime by doing
    the equivalent of "type(name, bases, dict)" in IR. Extension
    classes are defined via C structs that are generated later in
    mypyc.codegen.emitclass.

    This is the main entry point to this module.
    """
    ir = builder.mapper.type_to_ir[cdef.info]

    # We do this check here because the base field of parent
    # classes aren't necessarily populated yet at
    # prepare_class_def time.
    if any(ir.base_mro[i].base != ir.base_mro[i + 1] for i in range(len(ir.base_mro) - 1)):
        builder.error("Multiple inheritance is not supported (except for traits)", cdef.line)

    if ir.allow_interpreted_subclasses:
        for parent in ir.mro:
            if not parent.allow_interpreted_subclasses:
                builder.error(
                    'Base class "{}" does not allow interpreted subclasses'.format(
                        parent.fullname
                    ),
                    cdef.line,
                )

    # Currently, we only create non-extension classes for classes that are
    # decorated or inherit from Enum. Classes decorated with @trait do not
    # apply here, and are handled in a different way.
    if ir.is_ext_class:
        cls_type = dataclass_type(cdef)
        if cls_type is None:
            cls_builder: ClassBuilder = ExtClassBuilder(builder, cdef)
        elif cls_type in ["dataclasses", "attr-auto"]:
            cls_builder = DataClassBuilder(builder, cdef)
        elif cls_type == "attr":
            cls_builder = AttrsClassBuilder(builder, cdef)
        else:
            raise ValueError(cls_type)
    else:
        cls_builder = NonExtClassBuilder(builder, cdef)

    for stmt in cdef.defs.body:
        if isinstance(stmt, OverloadedFuncDef) and stmt.is_property:
            if isinstance(cls_builder, NonExtClassBuilder):
                # properties with both getters and setters in non_extension
                # classes not supported
                builder.error("Property setters not supported in non-extension classes", stmt.line)
            for item in stmt.items:
                with builder.catch_errors(stmt.line):
                    cls_builder.add_method(get_func_def(item))
        elif isinstance(stmt, (FuncDef, Decorator, OverloadedFuncDef)):
            # Ignore plugin generated methods (since they have no
            # bodies to compile and will need to have the bodies
            # provided by some other mechanism.)
            if cdef.info.names[stmt.name].plugin_generated:
                continue
            with builder.catch_errors(stmt.line):
                cls_builder.add_method(get_func_def(stmt))
        elif isinstance(stmt, PassStmt):
            continue
        elif isinstance(stmt, AssignmentStmt):
            if len(stmt.lvalues) != 1:
                builder.error("Multiple assignment in class bodies not supported", stmt.line)
                continue
            lvalue = stmt.lvalues[0]
            if not isinstance(lvalue, NameExpr):
                builder.error(
                    "Only assignment to variables is supported in class bodies", stmt.line
                )
                continue
            # We want to collect class variables in a dictionary for both real
            # non-extension classes and fake dataclass ones.
            cls_builder.add_attr(lvalue, stmt)

        elif isinstance(stmt, ExpressionStmt) and isinstance(stmt.expr, StrExpr):
            # Docstring. Ignore
            pass
        else:
            builder.error("Unsupported statement in class body", stmt.line)

    # Generate implicit property setters/getters
    for name, decl in ir.method_decls.items():
        if decl.implicit and decl.is_prop_getter:
            getter_ir = gen_property_getter_ir(builder, decl, cdef, ir.is_trait)
            builder.functions.append(getter_ir)
            ir.methods[getter_ir.decl.name] = getter_ir

            setter_ir = None
            setter_name = PROPSET_PREFIX + name
            if setter_name in ir.method_decls:
                setter_ir = gen_property_setter_ir(
                    builder, ir.method_decls[setter_name], cdef, ir.is_trait
                )
                builder.functions.append(setter_ir)
                ir.methods[setter_name] = setter_ir

            ir.properties[name] = (getter_ir, setter_ir)
            # TODO: Generate glue method if needed?
            # TODO: Do we need interpreted glue methods? Maybe not?

    cls_builder.finalize(ir)
</t>
<t tx="ekr.20240308084832.1199">class ClassBuilder:
    """Create IR for a class definition.
    
    This is an abstract base class.
    """
    @others
</t>
<t tx="ekr.20240308084832.12">def generate_c_extension_shim(
    full_module_name: str, module_name: str, dir_name: str, group_name: str
) -&gt; str:
    """Create a C extension shim with a passthrough PyInit function.

    Arguments:
        full_module_name: the dotted full module name
        module_name: the final component of the module name
        dir_name: the directory to place source code
        group_name: the name of the group
    """
    cname = "%s.c" % full_module_name.replace(".", os.sep)
    cpath = os.path.join(dir_name, cname)

    # We load the C extension shim template from a file.
    # (So that the file could be reused as a bazel template also.)
    with open(os.path.join(include_dir(), "module_shim.tmpl")) as f:
        shim_template = f.read()

    write_file(
        cpath,
        shim_template.format(
            modname=module_name,
            libname=shared_lib_name(group_name),
            full_modname=exported_name(full_module_name),
        ),
    )

    return cpath
</t>
<t tx="ekr.20240308084832.120">def frequently_executed_blocks(entry_point: BasicBlock) -&gt; set[BasicBlock]:
    result: set[BasicBlock] = set()
    worklist = [entry_point]
    while worklist:
        block = worklist.pop()
        if block in result:
            continue
        result.add(block)
        t = block.terminator
        if isinstance(t, Goto):
            worklist.append(t.label)
        elif isinstance(t, Branch):
            if t.rare or t.traceback_entry is not None:
                worklist.append(t.false)
            else:
                worklist.append(t.true)
                worklist.append(t.false)
    return result
</t>
<t tx="ekr.20240308084832.1200">def __init__(self, builder: IRBuilder, cdef: ClassDef) -&gt; None:
    self.builder = builder
    self.cdef = cdef
    self.attrs_to_cache: list[tuple[Lvalue, RType]] = []
</t>
<t tx="ekr.20240308084832.1201">@abstractmethod
def add_method(self, fdef: FuncDef) -&gt; None:
    """Add a method to the class IR"""
</t>
<t tx="ekr.20240308084832.1202">@abstractmethod
def add_attr(self, lvalue: NameExpr, stmt: AssignmentStmt) -&gt; None:
    """Add an attribute to the class IR"""
</t>
<t tx="ekr.20240308084832.1203">@abstractmethod
def finalize(self, ir: ClassIR) -&gt; None:
    """Perform any final operations to complete the class IR"""
</t>
<t tx="ekr.20240308084832.1204">class NonExtClassBuilder(ClassBuilder):
    @others
</t>
<t tx="ekr.20240308084832.1205">def __init__(self, builder: IRBuilder, cdef: ClassDef) -&gt; None:
    super().__init__(builder, cdef)
    self.non_ext = self.create_non_ext_info()
</t>
<t tx="ekr.20240308084832.1206">def create_non_ext_info(self) -&gt; NonExtClassInfo:
    non_ext_bases = populate_non_ext_bases(self.builder, self.cdef)
    non_ext_metaclass = find_non_ext_metaclass(self.builder, self.cdef, non_ext_bases)
    non_ext_dict = setup_non_ext_dict(
        self.builder, self.cdef, non_ext_metaclass, non_ext_bases
    )
    # We populate __annotations__ for non-extension classes
    # because dataclasses uses it to determine which attributes to compute on.
    # TODO: Maybe generate more precise types for annotations
    non_ext_anns = self.builder.call_c(dict_new_op, [], self.cdef.line)
    return NonExtClassInfo(non_ext_dict, non_ext_bases, non_ext_anns, non_ext_metaclass)
</t>
<t tx="ekr.20240308084832.1207">def add_method(self, fdef: FuncDef) -&gt; None:
    handle_non_ext_method(self.builder, self.non_ext, self.cdef, fdef)
</t>
<t tx="ekr.20240308084832.1208">def add_attr(self, lvalue: NameExpr, stmt: AssignmentStmt) -&gt; None:
    add_non_ext_class_attr_ann(self.builder, self.non_ext, lvalue, stmt)
    add_non_ext_class_attr(
        self.builder, self.non_ext, lvalue, stmt, self.cdef, self.attrs_to_cache
    )
</t>
<t tx="ekr.20240308084832.1209">def finalize(self, ir: ClassIR) -&gt; None:
    # Dynamically create the class via the type constructor
    non_ext_class = load_non_ext_class(self.builder, ir, self.non_ext, self.cdef.line)
    non_ext_class = load_decorated_class(self.builder, self.cdef, non_ext_class)

    # Save the decorated class
    self.builder.add(
        InitStatic(non_ext_class, self.cdef.name, self.builder.module_name, NAMESPACE_TYPE)
    )

    # Add the non-extension class to the dict
    self.builder.call_c(
        dict_set_item_op,
        [
            self.builder.load_globals_dict(),
            self.builder.load_str(self.cdef.name),
            non_ext_class,
        ],
        self.cdef.line,
    )

    # Cache any cacheable class attributes
    cache_class_attrs(self.builder, self.attrs_to_cache, self.cdef)
</t>
<t tx="ekr.20240308084832.121">"""Data-flow analyses."""

from __future__ import annotations

from abc import abstractmethod
from typing import Dict, Generic, Iterable, Iterator, Set, Tuple, TypeVar

from mypyc.ir.func_ir import all_values
from mypyc.ir.ops import (
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    ControlOp,
    Extend,
    Float,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    InitStatic,
    Integer,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadGlobal,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    Op,
    OpVisitor,
    RaiseStandardError,
    RegisterOp,
    Return,
    SetAttr,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unborrow,
    Unbox,
    Unreachable,
    Value,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1210">class ExtClassBuilder(ClassBuilder):
    @others
</t>
<t tx="ekr.20240308084832.1211">def __init__(self, builder: IRBuilder, cdef: ClassDef) -&gt; None:
    super().__init__(builder, cdef)
    # If the class is not decorated, generate an extension class for it.
    self.type_obj: Value | None = allocate_class(builder, cdef)
</t>
<t tx="ekr.20240308084832.1212">def skip_attr_default(self, name: str, stmt: AssignmentStmt) -&gt; bool:
    """Controls whether to skip generating a default for an attribute."""
    return False
</t>
<t tx="ekr.20240308084832.1213">def add_method(self, fdef: FuncDef) -&gt; None:
    handle_ext_method(self.builder, self.cdef, fdef)
</t>
<t tx="ekr.20240308084832.1214">def add_attr(self, lvalue: NameExpr, stmt: AssignmentStmt) -&gt; None:
    # Variable declaration with no body
    if isinstance(stmt.rvalue, TempNode):
        return
    # Only treat marked class variables as class variables.
    if not (is_class_var(lvalue) or stmt.is_final_def):
        return
    typ = self.builder.load_native_type_object(self.cdef.fullname)
    value = self.builder.accept(stmt.rvalue)
    self.builder.call_c(
        py_setattr_op, [typ, self.builder.load_str(lvalue.name), value], stmt.line
    )
    if self.builder.non_function_scope() and stmt.is_final_def:
        self.builder.init_final_static(lvalue, value, self.cdef.name)
</t>
<t tx="ekr.20240308084832.1215">def finalize(self, ir: ClassIR) -&gt; None:
    attrs_with_defaults, default_assignments = find_attr_initializers(
        self.builder, self.cdef, self.skip_attr_default
    )
    ir.attrs_with_defaults.update(attrs_with_defaults)
    generate_attr_defaults_init(self.builder, self.cdef, default_assignments)
    create_ne_from_eq(self.builder, self.cdef)
</t>
<t tx="ekr.20240308084832.1216">class DataClassBuilder(ExtClassBuilder):
    @others
</t>
<t tx="ekr.20240308084832.1217"># controls whether an __annotations__ attribute should be added to the class
# __dict__.  This is not desirable for attrs classes where auto_attribs is
# disabled, as attrs will reject it.
add_annotations_to_dict = True

def __init__(self, builder: IRBuilder, cdef: ClassDef) -&gt; None:
    super().__init__(builder, cdef)
    self.non_ext = self.create_non_ext_info()
</t>
<t tx="ekr.20240308084832.1218">def create_non_ext_info(self) -&gt; NonExtClassInfo:
    """Set up a NonExtClassInfo to track dataclass attributes.

    In addition to setting up a normal extension class for dataclasses,
    we also collect its class attributes like a non-extension class so
    that we can hand them to the dataclass decorator.
    """
    return NonExtClassInfo(
        self.builder.call_c(dict_new_op, [], self.cdef.line),
        self.builder.add(TupleSet([], self.cdef.line)),
        self.builder.call_c(dict_new_op, [], self.cdef.line),
        self.builder.add(LoadAddress(type_object_op.type, type_object_op.src, self.cdef.line)),
    )
</t>
<t tx="ekr.20240308084832.1219">def skip_attr_default(self, name: str, stmt: AssignmentStmt) -&gt; bool:
    return stmt.type is not None
</t>
<t tx="ekr.20240308084832.122">class CFG:
    """Control-flow graph.
    
    Node 0 is always assumed to be the entry point. There must be a
    non-empty set of exits.
    """
    @others
</t>
<t tx="ekr.20240308084832.1220">def get_type_annotation(self, stmt: AssignmentStmt) -&gt; TypeInfo | None:
    # We populate __annotations__ because dataclasses uses it to determine
    # which attributes to compute on.
    ann_type = get_proper_type(stmt.type)
    if isinstance(ann_type, Instance):
        return ann_type.type
    return None
</t>
<t tx="ekr.20240308084832.1221">def add_attr(self, lvalue: NameExpr, stmt: AssignmentStmt) -&gt; None:
    add_non_ext_class_attr_ann(
        self.builder, self.non_ext, lvalue, stmt, self.get_type_annotation
    )
    add_non_ext_class_attr(
        self.builder, self.non_ext, lvalue, stmt, self.cdef, self.attrs_to_cache
    )
    super().add_attr(lvalue, stmt)
</t>
<t tx="ekr.20240308084832.1222">def finalize(self, ir: ClassIR) -&gt; None:
    """Generate code to finish instantiating a dataclass.

    This works by replacing all of the attributes on the class
    (which will be descriptors) with whatever they would be in a
    non-extension class, calling dataclass, then switching them back.

    The resulting class is an extension class and instances of it do not
    have a __dict__ (unless something else requires it).
    All methods written explicitly in the source are compiled and
    may be called through the vtable while the methods generated
    by dataclasses are interpreted and may not be.

    (If we just called dataclass without doing this, it would think that all
    of the descriptors for our attributes are default values and generate an
    incorrect constructor. We need to do the switch so that dataclass gets the
    appropriate defaults.)
    """
    super().finalize(ir)
    assert self.type_obj
    add_dunders_to_non_ext_dict(
        self.builder, self.non_ext, self.cdef.line, self.add_annotations_to_dict
    )
    dec = self.builder.accept(
        next(d for d in self.cdef.decorators if is_dataclass_decorator(d))
    )
    self.builder.call_c(
        dataclass_sleight_of_hand,
        [dec, self.type_obj, self.non_ext.dict, self.non_ext.anns],
        self.cdef.line,
    )
</t>
<t tx="ekr.20240308084832.1223">class AttrsClassBuilder(DataClassBuilder):
    """Create IR for an attrs class where auto_attribs=False (the default).
    
    When auto_attribs is enabled, attrs classes behave similarly to dataclasses
    (i.e. types are stored as annotations on the class) and are thus handled
    by DataClassBuilder, but when auto_attribs is disabled the types are
    provided via attr.ib(type=...)
    """
    @others
</t>
<t tx="ekr.20240308084832.1224">add_annotations_to_dict = False

def skip_attr_default(self, name: str, stmt: AssignmentStmt) -&gt; bool:
    return True
</t>
<t tx="ekr.20240308084832.1225">def get_type_annotation(self, stmt: AssignmentStmt) -&gt; TypeInfo | None:
    if isinstance(stmt.rvalue, CallExpr):
        # find the type arg in `attr.ib(type=str)`
        callee = stmt.rvalue.callee
        if (
            isinstance(callee, MemberExpr)
            and callee.fullname in ["attr.ib", "attr.attr"]
            and "type" in stmt.rvalue.arg_names
        ):
            index = stmt.rvalue.arg_names.index("type")
            type_name = stmt.rvalue.args[index]
            if isinstance(type_name, NameExpr) and isinstance(type_name.node, TypeInfo):
                lvalue = stmt.lvalues[0]
                assert isinstance(lvalue, NameExpr)
                return type_name.node
    return None
</t>
<t tx="ekr.20240308084832.1226">def allocate_class(builder: IRBuilder, cdef: ClassDef) -&gt; Value:
    # OK AND NOW THE FUN PART
    base_exprs = cdef.base_type_exprs + cdef.removed_base_type_exprs
    if base_exprs:
        bases = [builder.accept(x) for x in base_exprs]
        tp_bases = builder.new_tuple(bases, cdef.line)
    else:
        tp_bases = builder.add(LoadErrorValue(object_rprimitive, is_borrowed=True))
    modname = builder.load_str(builder.module_name)
    template = builder.add(
        LoadStatic(object_rprimitive, cdef.name + "_template", builder.module_name, NAMESPACE_TYPE)
    )
    # Create the class
    tp = builder.call_c(pytype_from_template_op, [template, tp_bases, modname], cdef.line)
    # Immediately fix up the trait vtables, before doing anything with the class.
    ir = builder.mapper.type_to_ir[cdef.info]
    if not ir.is_trait and not ir.builtin_base:
        builder.add(
            Call(
                FuncDecl(
                    cdef.name + "_trait_vtable_setup",
                    None,
                    builder.module_name,
                    FuncSignature([], bool_rprimitive),
                ),
                [],
                -1,
            )
        )
    # Populate a '__mypyc_attrs__' field containing the list of attrs
    builder.call_c(
        py_setattr_op,
        [
            tp,
            builder.load_str("__mypyc_attrs__"),
            create_mypyc_attrs_tuple(builder, builder.mapper.type_to_ir[cdef.info], cdef.line),
        ],
        cdef.line,
    )

    # Save the class
    builder.add(InitStatic(tp, cdef.name, builder.module_name, NAMESPACE_TYPE))

    # Add it to the dict
    builder.call_c(
        dict_set_item_op, [builder.load_globals_dict(), builder.load_str(cdef.name), tp], cdef.line
    )

    return tp
</t>
<t tx="ekr.20240308084832.1227"># Mypy uses these internally as base classes of TypedDict classes. These are
# lies and don't have any runtime equivalent.
MAGIC_TYPED_DICT_CLASSES: Final[tuple[str, ...]] = (
    "typing._TypedDict",
    "typing_extensions._TypedDict",
)


def populate_non_ext_bases(builder: IRBuilder, cdef: ClassDef) -&gt; Value:
    """Create base class tuple of a non-extension class.

    The tuple is passed to the metaclass constructor.
    """
    is_named_tuple = cdef.info.is_named_tuple
    ir = builder.mapper.type_to_ir[cdef.info]
    bases = []
    for cls in cdef.info.mro[1:]:
        if cls.fullname == "builtins.object":
            continue
        if is_named_tuple and cls.fullname in (
            "typing.Sequence",
            "typing.Iterable",
            "typing.Collection",
            "typing.Reversible",
            "typing.Container",
            "typing.Sized",
        ):
            # HAX: Synthesized base classes added by mypy don't exist at runtime, so skip them.
            #      This could break if they were added explicitly, though...
            continue
        # Add the current class to the base classes list of concrete subclasses
        if cls in builder.mapper.type_to_ir:
            base_ir = builder.mapper.type_to_ir[cls]
            if base_ir.children is not None:
                base_ir.children.append(ir)

        if cls.fullname in MAGIC_TYPED_DICT_CLASSES:
            # HAX: Mypy internally represents TypedDict classes differently from what
            #      should happen at runtime. Replace with something that works.
            module = "typing"
            if builder.options.capi_version &lt; (3, 9):
                name = "TypedDict"
                if builder.options.capi_version &lt; (3, 8):
                    # TypedDict was added to typing in Python 3.8.
                    module = "typing_extensions"
                    # TypedDict is not a real type on typing_extensions 4.7.0+
                    name = "_TypedDict"
                    if isinstance(typing_extensions.TypedDict, type):
                        raise RuntimeError(
                            "It looks like you may have an old version "
                            "of typing_extensions installed. "
                            "typing_extensions&gt;=4.7.0 is required on Python 3.7."
                        )
            else:
                # In Python 3.9 TypedDict is not a real type.
                name = "_TypedDict"
            base = builder.get_module_attr(module, name, cdef.line)
        elif is_named_tuple and cls.fullname == "builtins.tuple":
            if builder.options.capi_version &lt; (3, 9):
                name = "NamedTuple"
            else:
                # This was changed in Python 3.9.
                name = "_NamedTuple"
            base = builder.get_module_attr("typing", name, cdef.line)
        else:
            cls_module = cls.fullname.rsplit(".", 1)[0]
            if cls_module == builder.current_module:
                base = builder.load_global_str(cls.name, cdef.line)
            else:
                base = builder.load_module_attr_by_fullname(cls.fullname, cdef.line)
        bases.append(base)
        if cls.fullname in MAGIC_TYPED_DICT_CLASSES:
            # The remaining base classes are synthesized by mypy and should be ignored.
            break
    return builder.new_tuple(bases, cdef.line)
</t>
<t tx="ekr.20240308084832.1228">def find_non_ext_metaclass(builder: IRBuilder, cdef: ClassDef, bases: Value) -&gt; Value:
    """Find the metaclass of a class from its defs and bases."""
    if cdef.metaclass:
        declared_metaclass = builder.accept(cdef.metaclass)
    else:
        if cdef.info.typeddict_type is not None and builder.options.capi_version &gt;= (3, 9):
            # In Python 3.9, the metaclass for class-based TypedDict is typing._TypedDictMeta.
            # We can't easily calculate it generically, so special case it.
            return builder.get_module_attr("typing", "_TypedDictMeta", cdef.line)
        elif cdef.info.is_named_tuple and builder.options.capi_version &gt;= (3, 9):
            # In Python 3.9, the metaclass for class-based NamedTuple is typing.NamedTupleMeta.
            # We can't easily calculate it generically, so special case it.
            return builder.get_module_attr("typing", "NamedTupleMeta", cdef.line)

        declared_metaclass = builder.add(
            LoadAddress(type_object_op.type, type_object_op.src, cdef.line)
        )

    return builder.call_c(py_calc_meta_op, [declared_metaclass, bases], cdef.line)
</t>
<t tx="ekr.20240308084832.1229">def setup_non_ext_dict(
    builder: IRBuilder, cdef: ClassDef, metaclass: Value, bases: Value
) -&gt; Value:
    """Initialize the class dictionary for a non-extension class.

    This class dictionary is passed to the metaclass constructor.
    """
    # Check if the metaclass defines a __prepare__ method, and if so, call it.
    has_prepare = builder.call_c(
        py_hasattr_op, [metaclass, builder.load_str("__prepare__")], cdef.line
    )

    non_ext_dict = Register(dict_rprimitive)

    true_block, false_block, exit_block = BasicBlock(), BasicBlock(), BasicBlock()
    builder.add_bool_branch(has_prepare, true_block, false_block)

    builder.activate_block(true_block)
    cls_name = builder.load_str(cdef.name)
    prepare_meth = builder.py_get_attr(metaclass, "__prepare__", cdef.line)
    prepare_dict = builder.py_call(prepare_meth, [cls_name, bases], cdef.line)
    builder.assign(non_ext_dict, prepare_dict, cdef.line)
    builder.goto(exit_block)

    builder.activate_block(false_block)
    builder.assign(non_ext_dict, builder.call_c(dict_new_op, [], cdef.line), cdef.line)
    builder.goto(exit_block)
    builder.activate_block(exit_block)

    return non_ext_dict
</t>
<t tx="ekr.20240308084832.123">def __init__(
    self,
    succ: dict[BasicBlock, list[BasicBlock]],
    pred: dict[BasicBlock, list[BasicBlock]],
    exits: set[BasicBlock],
) -&gt; None:
    assert exits
    self.succ = succ
    self.pred = pred
    self.exits = exits
</t>
<t tx="ekr.20240308084832.1230">def add_non_ext_class_attr_ann(
    builder: IRBuilder,
    non_ext: NonExtClassInfo,
    lvalue: NameExpr,
    stmt: AssignmentStmt,
    get_type_info: Callable[[AssignmentStmt], TypeInfo | None] | None = None,
) -&gt; None:
    """Add a class attribute to __annotations__ of a non-extension class."""
    # FIXME: try to better preserve the special forms and type parameters of generics.
    typ: Value | None = None
    if get_type_info is not None:
        type_info = get_type_info(stmt)
        if type_info:
            typ = load_type(builder, type_info, stmt.line)

    if typ is None:
        # FIXME: if get_type_info is not provided, don't fall back to stmt.type?
        ann_type = get_proper_type(stmt.type)
        if (
            isinstance(stmt.unanalyzed_type, UnboundType)
            and stmt.unanalyzed_type.original_str_expr is not None
        ):
            # Annotation is a forward reference, so don't attempt to load the actual
            # type and load the string instead.
            #
            # TODO: is it possible to determine whether a non-string annotation is
            # actually a forward reference due to the __annotations__ future?
            typ = builder.load_str(stmt.unanalyzed_type.original_str_expr)
        elif isinstance(ann_type, Instance):
            typ = load_type(builder, ann_type.type, stmt.line)
        else:
            typ = builder.add(LoadAddress(type_object_op.type, type_object_op.src, stmt.line))

    key = builder.load_str(lvalue.name)
    builder.call_c(dict_set_item_op, [non_ext.anns, key, typ], stmt.line)
</t>
<t tx="ekr.20240308084832.1231">def add_non_ext_class_attr(
    builder: IRBuilder,
    non_ext: NonExtClassInfo,
    lvalue: NameExpr,
    stmt: AssignmentStmt,
    cdef: ClassDef,
    attr_to_cache: list[tuple[Lvalue, RType]],
) -&gt; None:
    """Add a class attribute to __dict__ of a non-extension class."""
    # Only add the attribute to the __dict__ if the assignment is of the form:
    # x: type = value (don't add attributes of the form 'x: type' to the __dict__).
    if not isinstance(stmt.rvalue, TempNode):
        rvalue = builder.accept(stmt.rvalue)
        builder.add_to_non_ext_dict(non_ext, lvalue.name, rvalue, stmt.line)
        # We cache enum attributes to speed up enum attribute lookup since they
        # are final.
        if (
            cdef.info.bases
            and cdef.info.bases[0].type.fullname == "enum.Enum"
            # Skip these since Enum will remove it
            and lvalue.name not in ENUM_REMOVED_PROPS
        ):
            # Enum values are always boxed, so use object_rprimitive.
            attr_to_cache.append((lvalue, object_rprimitive))
</t>
<t tx="ekr.20240308084832.1232">def find_attr_initializers(
    builder: IRBuilder, cdef: ClassDef, skip: Callable[[str, AssignmentStmt], bool] | None = None
) -&gt; tuple[set[str], list[AssignmentStmt]]:
    """Find initializers of attributes in a class body.

    If provided, the skip arg should be a callable which will return whether
    to skip generating a default for an attribute.  It will be passed the name of
    the attribute and the corresponding AssignmentStmt.
    """
    cls = builder.mapper.type_to_ir[cdef.info]
    if cls.builtin_base:
        return set(), []

    attrs_with_defaults = set()

    # Pull out all assignments in classes in the mro so we can initialize them
    # TODO: Support nested statements
    default_assignments = []
    for info in reversed(cdef.info.mro):
        if info not in builder.mapper.type_to_ir:
            continue
        for stmt in info.defn.defs.body:
            if (
                isinstance(stmt, AssignmentStmt)
                and isinstance(stmt.lvalues[0], NameExpr)
                and not is_class_var(stmt.lvalues[0])
                and not isinstance(stmt.rvalue, TempNode)
            ):
                name = stmt.lvalues[0].name
                if name == "__slots__":
                    continue

                if name == "__deletable__":
                    check_deletable_declaration(builder, cls, stmt.line)
                    continue

                if skip is not None and skip(name, stmt):
                    continue

                attr_type = cls.attr_type(name)

                # If the attribute is initialized to None and type isn't optional,
                # doesn't initialize it to anything (special case for "# type:" comments).
                if isinstance(stmt.rvalue, RefExpr) and stmt.rvalue.fullname == "builtins.None":
                    if (
                        not is_optional_type(attr_type)
                        and not is_object_rprimitive(attr_type)
                        and not is_none_rprimitive(attr_type)
                    ):
                        continue

                attrs_with_defaults.add(name)
                default_assignments.append(stmt)

    return attrs_with_defaults, default_assignments
</t>
<t tx="ekr.20240308084832.1233">def generate_attr_defaults_init(
    builder: IRBuilder, cdef: ClassDef, default_assignments: list[AssignmentStmt]
) -&gt; None:
    """Generate an initialization method for default attr values (from class vars)."""
    if not default_assignments:
        return
    cls = builder.mapper.type_to_ir[cdef.info]
    if cls.builtin_base:
        return

    with builder.enter_method(cls, "__mypyc_defaults_setup", bool_rprimitive):
        self_var = builder.self()
        for stmt in default_assignments:
            lvalue = stmt.lvalues[0]
            assert isinstance(lvalue, NameExpr)
            if not stmt.is_final_def and not is_constant(stmt.rvalue):
                builder.warning("Unsupported default attribute value", stmt.rvalue.line)

            attr_type = cls.attr_type(lvalue.name)
            val = builder.coerce(builder.accept(stmt.rvalue), attr_type, stmt.line)
            init = SetAttr(self_var, lvalue.name, val, -1)
            init.mark_as_initializer()
            builder.add(init)

        builder.add(Return(builder.true()))
</t>
<t tx="ekr.20240308084832.1234">def check_deletable_declaration(builder: IRBuilder, cl: ClassIR, line: int) -&gt; None:
    for attr in cl.deletable:
        if attr not in cl.attributes:
            if not cl.has_attr(attr):
                builder.error(f'Attribute "{attr}" not defined', line)
                continue
            for base in cl.mro:
                if attr in base.property_types:
                    builder.error(f'Cannot make property "{attr}" deletable', line)
                    break
            else:
                _, base = cl.attr_details(attr)
                builder.error(
                    ('Attribute "{}" not defined in "{}" ' + '(defined in "{}")').format(
                        attr, cl.name, base.name
                    ),
                    line,
                )
</t>
<t tx="ekr.20240308084832.1235">def create_ne_from_eq(builder: IRBuilder, cdef: ClassDef) -&gt; None:
    """Create a "__ne__" method from a "__eq__" method (if only latter exists)."""
    cls = builder.mapper.type_to_ir[cdef.info]
    if cls.has_method("__eq__") and not cls.has_method("__ne__"):
        gen_glue_ne_method(builder, cls, cdef.line)
</t>
<t tx="ekr.20240308084832.1236">def gen_glue_ne_method(builder: IRBuilder, cls: ClassIR, line: int) -&gt; None:
    """Generate a "__ne__" method from a "__eq__" method."""
    with builder.enter_method(cls, "__ne__", object_rprimitive):
        rhs_arg = builder.add_argument("rhs", object_rprimitive)

        # If __eq__ returns NotImplemented, then __ne__ should also
        not_implemented_block, regular_block = BasicBlock(), BasicBlock()
        eqval = builder.add(MethodCall(builder.self(), "__eq__", [rhs_arg], line))
        not_implemented = builder.add(
            LoadAddress(not_implemented_op.type, not_implemented_op.src, line)
        )
        builder.add(
            Branch(
                builder.translate_is_op(eqval, not_implemented, "is", line),
                not_implemented_block,
                regular_block,
                Branch.BOOL,
            )
        )

        builder.activate_block(regular_block)
        retval = builder.coerce(builder.unary_op(eqval, "not", line), object_rprimitive, line)
        builder.add(Return(retval))

        builder.activate_block(not_implemented_block)
        builder.add(Return(not_implemented))
</t>
<t tx="ekr.20240308084832.1237">def load_non_ext_class(
    builder: IRBuilder, ir: ClassIR, non_ext: NonExtClassInfo, line: int
) -&gt; Value:
    cls_name = builder.load_str(ir.name)

    add_dunders_to_non_ext_dict(builder, non_ext, line)

    class_type_obj = builder.py_call(
        non_ext.metaclass, [cls_name, non_ext.bases, non_ext.dict], line
    )
    return class_type_obj
</t>
<t tx="ekr.20240308084832.1238">def load_decorated_class(builder: IRBuilder, cdef: ClassDef, type_obj: Value) -&gt; Value:
    """Apply class decorators to create a decorated (non-extension) class object.

    Given a decorated ClassDef and a register containing a
    non-extension representation of the ClassDef created via the type
    constructor, applies the corresponding decorator functions on that
    decorated ClassDef and returns a register containing the decorated
    ClassDef.
    """
    decorators = cdef.decorators
    dec_class = type_obj
    for d in reversed(decorators):
        decorator = d.accept(builder.visitor)
        assert isinstance(decorator, Value)
        dec_class = builder.py_call(decorator, [dec_class], dec_class.line)
    return dec_class
</t>
<t tx="ekr.20240308084832.1239">def cache_class_attrs(
    builder: IRBuilder, attrs_to_cache: list[tuple[Lvalue, RType]], cdef: ClassDef
) -&gt; None:
    """Add class attributes to be cached to the global cache."""
    typ = builder.load_native_type_object(cdef.info.fullname)
    for lval, rtype in attrs_to_cache:
        assert isinstance(lval, NameExpr)
        rval = builder.py_get_attr(typ, lval.name, cdef.line)
        builder.init_final_static(lval, rval, cdef.name, type_override=rtype)
</t>
<t tx="ekr.20240308084832.124">def __str__(self) -&gt; str:
    exits = sorted(self.exits, key=lambda e: int(e.label))
    return f"exits: {exits}\nsucc: {self.succ}\npred: {self.pred}"
</t>
<t tx="ekr.20240308084832.1240">def create_mypyc_attrs_tuple(builder: IRBuilder, ir: ClassIR, line: int) -&gt; Value:
    attrs = [name for ancestor in ir.mro for name in ancestor.attributes]
    if ir.inherits_python:
        attrs.append("__dict__")
    items = [builder.load_str(attr) for attr in attrs]
    return builder.new_tuple(items, line)
</t>
<t tx="ekr.20240308084832.1241">def add_dunders_to_non_ext_dict(
    builder: IRBuilder, non_ext: NonExtClassInfo, line: int, add_annotations: bool = True
) -&gt; None:
    if add_annotations:
        # Add __annotations__ to the class dict.
        builder.add_to_non_ext_dict(non_ext, "__annotations__", non_ext.anns, line)

    # We add a __doc__ attribute so if the non-extension class is decorated with the
    # dataclass decorator, dataclass will not try to look for __text_signature__.
    # https://github.com/python/cpython/blob/3.7/Lib/dataclasses.py#L957
    filler_doc_str = "mypyc filler docstring"
    builder.add_to_non_ext_dict(non_ext, "__doc__", builder.load_str(filler_doc_str), line)
    builder.add_to_non_ext_dict(non_ext, "__module__", builder.load_str(builder.module_name), line)
</t>
<t tx="ekr.20240308084832.1242">"""Constant folding of IR values.

For example, 3 + 5 can be constant folded into 8.

This is mostly like mypy.constant_fold, but we can bind some additional
NameExpr and MemberExpr references here, since we have more knowledge
about which definitions can be trusted -- we constant fold only references
to other compiled modules in the same compilation unit.
"""

from __future__ import annotations

from typing import Final, Union

from mypy.constant_fold import constant_fold_binary_op, constant_fold_unary_op
from mypy.nodes import (
    BytesExpr,
    ComplexExpr,
    Expression,
    FloatExpr,
    IntExpr,
    MemberExpr,
    NameExpr,
    OpExpr,
    StrExpr,
    UnaryExpr,
    Var,
)
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.util import bytes_from_str

# All possible result types of constant folding
ConstantValue = Union[int, float, complex, str, bytes]
CONST_TYPES: Final = (int, float, complex, str, bytes)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1243">def constant_fold_expr(builder: IRBuilder, expr: Expression) -&gt; ConstantValue | None:
    """Return the constant value of an expression for supported operations.

    Return None otherwise.
    """
    if isinstance(expr, IntExpr):
        return expr.value
    if isinstance(expr, FloatExpr):
        return expr.value
    if isinstance(expr, StrExpr):
        return expr.value
    if isinstance(expr, BytesExpr):
        return bytes_from_str(expr.value)
    if isinstance(expr, ComplexExpr):
        return expr.value
    elif isinstance(expr, NameExpr):
        node = expr.node
        if isinstance(node, Var) and node.is_final:
            final_value = node.final_value
            if isinstance(final_value, (CONST_TYPES)):
                return final_value
    elif isinstance(expr, MemberExpr):
        final = builder.get_final_ref(expr)
        if final is not None:
            fn, final_var, native = final
            if final_var.is_final:
                final_value = final_var.final_value
                if isinstance(final_value, (CONST_TYPES)):
                    return final_value
    elif isinstance(expr, OpExpr):
        left = constant_fold_expr(builder, expr.left)
        right = constant_fold_expr(builder, expr.right)
        if left is not None and right is not None:
            return constant_fold_binary_op_extended(expr.op, left, right)
    elif isinstance(expr, UnaryExpr):
        value = constant_fold_expr(builder, expr.expr)
        if value is not None and not isinstance(value, bytes):
            return constant_fold_unary_op(expr.op, value)
    return None
</t>
<t tx="ekr.20240308084832.1244">def constant_fold_binary_op_extended(
    op: str, left: ConstantValue, right: ConstantValue
) -&gt; ConstantValue | None:
    """Like mypy's constant_fold_binary_op(), but includes bytes support.

    mypy cannot use constant folded bytes easily so it's simpler to only support them in mypyc.
    """
    if not isinstance(left, bytes) and not isinstance(right, bytes):
        return constant_fold_binary_op(op, left, right)

    if op == "+" and isinstance(left, bytes) and isinstance(right, bytes):
        return left + right
    elif op == "*" and isinstance(left, bytes) and isinstance(right, int):
        return left * right
    elif op == "*" and isinstance(left, int) and isinstance(right, bytes):
        return left * right

    return None
</t>
<t tx="ekr.20240308084832.1245">"""Helpers that store information about functions and the related classes."""

from __future__ import annotations

from mypy.nodes import FuncItem
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import INVALID_FUNC_DEF
from mypyc.ir.ops import BasicBlock, Value
from mypyc.irbuild.targets import AssignmentTarget


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1246">class FuncInfo:
    """Contains information about functions as they are generated."""
    @others
</t>
<t tx="ekr.20240308084832.1247">def __init__(
    self,
    fitem: FuncItem = INVALID_FUNC_DEF,
    name: str = "",
    class_name: str | None = None,
    namespace: str = "",
    is_nested: bool = False,
    contains_nested: bool = False,
    is_decorated: bool = False,
    in_non_ext: bool = False,
    add_nested_funcs_to_env: bool = False,
) -&gt; None:
    self.fitem = fitem
    self.name = name
    self.class_name = class_name
    self.ns = namespace
    # Callable classes implement the '__call__' method, and are used to represent functions
    # that are nested inside of other functions.
    self._callable_class: ImplicitClass | None = None
    # Environment classes are ClassIR instances that contain attributes representing the
    # variables in the environment of the function they correspond to. Environment classes are
    # generated for functions that contain nested functions.
    self._env_class: ClassIR | None = None
    # Generator classes implement the '__next__' method, and are used to represent generators
    # returned by generator functions.
    self._generator_class: GeneratorClass | None = None
    # Environment class registers are the local registers associated with instances of an
    # environment class, used for getting and setting attributes. curr_env_reg is the register
    # associated with the current environment.
    self._curr_env_reg: Value | None = None
    # These are flags denoting whether a given function is nested, contains a nested function,
    # is decorated, or is within a non-extension class.
    self.is_nested = is_nested
    self.contains_nested = contains_nested
    self.is_decorated = is_decorated
    self.in_non_ext = in_non_ext
    self.add_nested_funcs_to_env = add_nested_funcs_to_env
</t>
<t tx="ekr.20240308084832.1248">    # TODO: add field for ret_type: RType = none_rprimitive

def namespaced_name(self) -&gt; str:
    return "_".join(x for x in [self.name, self.class_name, self.ns] if x)
</t>
<t tx="ekr.20240308084832.1249">@property
def is_generator(self) -&gt; bool:
    return self.fitem.is_generator or self.fitem.is_coroutine
</t>
<t tx="ekr.20240308084832.125">def get_cfg(blocks: list[BasicBlock]) -&gt; CFG:
    """Calculate basic block control-flow graph.

    The result is a dictionary like this:

         basic block index -&gt; (successors blocks, predecesssor blocks)
    """
    succ_map = {}
    pred_map: dict[BasicBlock, list[BasicBlock]] = {}
    exits = set()
    for block in blocks:
        assert not any(
            isinstance(op, ControlOp) for op in block.ops[:-1]
        ), "Control-flow ops must be at the end of blocks"

        succ = list(block.terminator.targets())
        if not succ:
            exits.add(block)

        # Errors can occur anywhere inside a block, which means that
        # we can't assume that the entire block has executed before
        # jumping to the error handler. In our CFG construction, we
        # model this as saying that a block can jump to its error
        # handler or the error handlers of any of its normal
        # successors (to represent an error before that next block
        # completes). This works well for analyses like "must
        # defined", where it implies that registers assigned in a
        # block may be undefined in its error handler, but is in
        # general not a precise representation of reality; any
        # analyses that require more fidelity must wait until after
        # exception insertion.
        for error_point in [block] + succ:
            if error_point.error_handler:
                succ.append(error_point.error_handler)

        succ_map[block] = succ
        pred_map[block] = []
    for prev, nxt in succ_map.items():
        for label in nxt:
            pred_map[label].append(prev)
    return CFG(succ_map, pred_map, exits)
</t>
<t tx="ekr.20240308084832.1250">@property
def is_coroutine(self) -&gt; bool:
    return self.fitem.is_coroutine
</t>
<t tx="ekr.20240308084832.1251">@property
def callable_class(self) -&gt; ImplicitClass:
    assert self._callable_class is not None
    return self._callable_class
</t>
<t tx="ekr.20240308084832.1252">@callable_class.setter
def callable_class(self, cls: ImplicitClass) -&gt; None:
    self._callable_class = cls
</t>
<t tx="ekr.20240308084832.1253">@property
def env_class(self) -&gt; ClassIR:
    assert self._env_class is not None
    return self._env_class
</t>
<t tx="ekr.20240308084832.1254">@env_class.setter
def env_class(self, ir: ClassIR) -&gt; None:
    self._env_class = ir
</t>
<t tx="ekr.20240308084832.1255">@property
def generator_class(self) -&gt; GeneratorClass:
    assert self._generator_class is not None
    return self._generator_class
</t>
<t tx="ekr.20240308084832.1256">@generator_class.setter
def generator_class(self, cls: GeneratorClass) -&gt; None:
    self._generator_class = cls
</t>
<t tx="ekr.20240308084832.1257">@property
def curr_env_reg(self) -&gt; Value:
    assert self._curr_env_reg is not None
    return self._curr_env_reg
</t>
<t tx="ekr.20240308084832.1258">class ImplicitClass:
    """Contains information regarding implicitly generated classes.
    
    Implicit classes are generated for nested functions and generator
    functions. They are not explicitly defined in the source code.
    
    NOTE: This is both a concrete class and used as a base class.
    """
    @others
</t>
<t tx="ekr.20240308084832.1259">def __init__(self, ir: ClassIR) -&gt; None:
    # The ClassIR instance associated with this class.
    self.ir = ir
    # The register associated with the 'self' instance for this generator class.
    self._self_reg: Value | None = None
    # Environment class registers are the local registers associated with instances of an
    # environment class, used for getting and setting attributes. curr_env_reg is the register
    # associated with the current environment. prev_env_reg is the self.__mypyc_env__ field
    # associated with the previous environment.
    self._curr_env_reg: Value | None = None
    self._prev_env_reg: Value | None = None
</t>
<t tx="ekr.20240308084832.126">def get_real_target(label: BasicBlock) -&gt; BasicBlock:
    if len(label.ops) == 1 and isinstance(label.ops[-1], Goto):
        label = label.ops[-1].label
    return label
</t>
<t tx="ekr.20240308084832.1260">@property
def self_reg(self) -&gt; Value:
    assert self._self_reg is not None
    return self._self_reg
</t>
<t tx="ekr.20240308084832.1261">@self_reg.setter
def self_reg(self, reg: Value) -&gt; None:
    self._self_reg = reg
</t>
<t tx="ekr.20240308084832.1262">@property
def curr_env_reg(self) -&gt; Value:
    assert self._curr_env_reg is not None
    return self._curr_env_reg
</t>
<t tx="ekr.20240308084832.1263">@curr_env_reg.setter
def curr_env_reg(self, reg: Value) -&gt; None:
    self._curr_env_reg = reg
</t>
<t tx="ekr.20240308084832.1264">@property
def prev_env_reg(self) -&gt; Value:
    assert self._prev_env_reg is not None
    return self._prev_env_reg
</t>
<t tx="ekr.20240308084832.1265">@prev_env_reg.setter
def prev_env_reg(self, reg: Value) -&gt; None:
    self._prev_env_reg = reg
</t>
<t tx="ekr.20240308084832.1266">class GeneratorClass(ImplicitClass):
    """Contains information about implicit generator function classes."""
    @others
</t>
<t tx="ekr.20240308084832.1267">def __init__(self, ir: ClassIR) -&gt; None:
    super().__init__(ir)
    # This register holds the label number that the '__next__' function should go to the next
    # time it is called.
    self._next_label_reg: Value | None = None
    self._next_label_target: AssignmentTarget | None = None

    # These registers hold the error values for the generator object for the case that the
    # 'throw' function is called.
    self.exc_regs: tuple[Value, Value, Value] | None = None

    # Holds the arg passed to send
    self.send_arg_reg: Value | None = None

    # The switch block is used to decide which instruction to go using the value held in the
    # next-label register.
    self.switch_block = BasicBlock()
    self.continuation_blocks: list[BasicBlock] = []
</t>
<t tx="ekr.20240308084832.1268">@property
def next_label_reg(self) -&gt; Value:
    assert self._next_label_reg is not None
    return self._next_label_reg
</t>
<t tx="ekr.20240308084832.1269">@next_label_reg.setter
def next_label_reg(self, reg: Value) -&gt; None:
    self._next_label_reg = reg
</t>
<t tx="ekr.20240308084832.127">def cleanup_cfg(blocks: list[BasicBlock]) -&gt; None:
    """Cleanup the control flow graph.

    This eliminates obviously dead basic blocks and eliminates blocks that contain
    nothing but a single jump.

    There is a lot more that could be done.
    """
    changed = True
    while changed:
        # First collapse any jumps to basic block that only contain a goto
        for block in blocks:
            for i, tgt in enumerate(block.terminator.targets()):
                block.terminator.set_target(i, get_real_target(tgt))

        # Then delete any blocks that have no predecessors
        changed = False
        cfg = get_cfg(blocks)
        orig_blocks = blocks.copy()
        blocks.clear()
        for i, block in enumerate(orig_blocks):
            if i == 0 or cfg.pred[block]:
                blocks.append(block)
            else:
                changed = True
</t>
<t tx="ekr.20240308084832.1270">@property
def next_label_target(self) -&gt; AssignmentTarget:
    assert self._next_label_target is not None
    return self._next_label_target
</t>
<t tx="ekr.20240308084832.1271">@next_label_target.setter
def next_label_target(self, target: AssignmentTarget) -&gt; None:
    self._next_label_target = target
</t>
<t tx="ekr.20240308084832.1272">"""Generate classes representing function environments (+ related operations).

If we have a nested function that has non-local (free) variables, access to the
non-locals is via an instance of an environment class. Example:

    def f() -&gt; int:
        x = 0  # Make 'x' an attribute of an environment class instance

        def g() -&gt; int:
            # We have access to the environment class instance to
            # allow accessing 'x'
            return x + 2

        x = x + 1  # Modify the attribute
        return g()
"""

from __future__ import annotations

from mypy.nodes import Argument, FuncDef, SymbolNode, Var
from mypyc.common import BITMAP_BITS, ENV_ATTR_NAME, SELF_NAME, bitmap_name
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.ops import Call, GetAttr, SetAttr, Value
from mypyc.ir.rtypes import RInstance, bitmap_rprimitive, object_rprimitive
from mypyc.irbuild.builder import IRBuilder, SymbolTarget
from mypyc.irbuild.context import FuncInfo, GeneratorClass, ImplicitClass
from mypyc.irbuild.targets import AssignmentTargetAttr


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1273">def setup_env_class(builder: IRBuilder) -&gt; ClassIR:
    """Generate a class representing a function environment.

    Note that the variables in the function environment are not
    actually populated here. This is because when the environment
    class is generated, the function environment has not yet been
    visited. This behavior is allowed so that when the compiler visits
    nested functions, it can use the returned ClassIR instance to
    figure out free variables it needs to access.  The remaining
    attributes of the environment class are populated when the
    environment registers are loaded.

    Return a ClassIR representing an environment for a function
    containing a nested function.
    """
    env_class = ClassIR(
        f"{builder.fn_info.namespaced_name()}_env", builder.module_name, is_generated=True
    )
    env_class.attributes[SELF_NAME] = RInstance(env_class)
    if builder.fn_info.is_nested:
        # If the function is nested, its environment class must contain an environment
        # attribute pointing to its encapsulating functions' environment class.
        env_class.attributes[ENV_ATTR_NAME] = RInstance(builder.fn_infos[-2].env_class)
    env_class.mro = [env_class]
    builder.fn_info.env_class = env_class
    builder.classes.append(env_class)
    return env_class
</t>
<t tx="ekr.20240308084832.1274">def finalize_env_class(builder: IRBuilder) -&gt; None:
    """Generate, instantiate, and set up the environment of an environment class."""
    instantiate_env_class(builder)

    # Iterate through the function arguments and replace local definitions (using registers)
    # that were previously added to the environment with references to the function's
    # environment class.
    if builder.fn_info.is_nested:
        add_args_to_env(builder, local=False, base=builder.fn_info.callable_class)
    else:
        add_args_to_env(builder, local=False, base=builder.fn_info)
</t>
<t tx="ekr.20240308084832.1275">def instantiate_env_class(builder: IRBuilder) -&gt; Value:
    """Assign an environment class to a register named after the given function definition."""
    curr_env_reg = builder.add(
        Call(builder.fn_info.env_class.ctor, [], builder.fn_info.fitem.line)
    )

    if builder.fn_info.is_nested:
        builder.fn_info.callable_class._curr_env_reg = curr_env_reg
        builder.add(
            SetAttr(
                curr_env_reg,
                ENV_ATTR_NAME,
                builder.fn_info.callable_class.prev_env_reg,
                builder.fn_info.fitem.line,
            )
        )
    else:
        builder.fn_info._curr_env_reg = curr_env_reg

    return curr_env_reg
</t>
<t tx="ekr.20240308084832.1276">def load_env_registers(builder: IRBuilder) -&gt; None:
    """Load the registers for the current FuncItem being visited.

    Adds the arguments of the FuncItem to the environment. If the
    FuncItem is nested inside of another function, then this also
    loads all of the outer environments of the FuncItem into registers
    so that they can be used when accessing free variables.
    """
    add_args_to_env(builder, local=True)

    fn_info = builder.fn_info
    fitem = fn_info.fitem
    if fn_info.is_nested:
        load_outer_envs(builder, fn_info.callable_class)
        # If this is a FuncDef, then make sure to load the FuncDef into its own environment
        # class so that the function can be called recursively.
        if isinstance(fitem, FuncDef) and fn_info.add_nested_funcs_to_env:
            setup_func_for_recursive_call(builder, fitem, fn_info.callable_class)
</t>
<t tx="ekr.20240308084832.1277">def load_outer_env(
    builder: IRBuilder, base: Value, outer_env: dict[SymbolNode, SymbolTarget]
) -&gt; Value:
    """Load the environment class for a given base into a register.

    Additionally, iterates through all of the SymbolNode and
    AssignmentTarget instances of the environment at the given index's
    symtable, and adds those instances to the environment of the
    current environment. This is done so that the current environment
    can access outer environment variables without having to reload
    all of the environment registers.

    Returns the register where the environment class was loaded.
    """
    env = builder.add(GetAttr(base, ENV_ATTR_NAME, builder.fn_info.fitem.line))
    assert isinstance(env.type, RInstance), f"{env} must be of type RInstance"

    for symbol, target in outer_env.items():
        env.type.class_ir.attributes[symbol.name] = target.type
        symbol_target = AssignmentTargetAttr(env, symbol.name)
        builder.add_target(symbol, symbol_target)

    return env
</t>
<t tx="ekr.20240308084832.1278">def load_outer_envs(builder: IRBuilder, base: ImplicitClass) -&gt; None:
    index = len(builder.builders) - 2

    # Load the first outer environment. This one is special because it gets saved in the
    # FuncInfo instance's prev_env_reg field.
    if index &gt; 1:
        # outer_env = builder.fn_infos[index].environment
        outer_env = builder.symtables[index]
        if isinstance(base, GeneratorClass):
            base.prev_env_reg = load_outer_env(builder, base.curr_env_reg, outer_env)
        else:
            base.prev_env_reg = load_outer_env(builder, base.self_reg, outer_env)
        env_reg = base.prev_env_reg
        index -= 1

    # Load the remaining outer environments into registers.
    while index &gt; 1:
        # outer_env = builder.fn_infos[index].environment
        outer_env = builder.symtables[index]
        env_reg = load_outer_env(builder, env_reg, outer_env)
        index -= 1
</t>
<t tx="ekr.20240308084832.1279">def num_bitmap_args(builder: IRBuilder, args: list[Argument]) -&gt; int:
    n = 0
    for arg in args:
        t = builder.type_to_rtype(arg.variable.type)
        if t.error_overlap and arg.kind.is_optional():
            n += 1
    return (n + (BITMAP_BITS - 1)) // BITMAP_BITS
</t>
<t tx="ekr.20240308084832.128">T = TypeVar("T")

AnalysisDict = Dict[Tuple[BasicBlock, int], Set[T]]


class AnalysisResult(Generic[T]):
    @others
</t>
<t tx="ekr.20240308084832.1280">def add_args_to_env(
    builder: IRBuilder,
    local: bool = True,
    base: FuncInfo | ImplicitClass | None = None,
    reassign: bool = True,
) -&gt; None:
    fn_info = builder.fn_info
    args = fn_info.fitem.arguments
    nb = num_bitmap_args(builder, args)
    if local:
        for arg in args:
            rtype = builder.type_to_rtype(arg.variable.type)
            builder.add_local_reg(arg.variable, rtype, is_arg=True)
        for i in reversed(range(nb)):
            builder.add_local_reg(Var(bitmap_name(i)), bitmap_rprimitive, is_arg=True)
    else:
        for arg in args:
            if is_free_variable(builder, arg.variable) or fn_info.is_generator:
                rtype = builder.type_to_rtype(arg.variable.type)
                assert base is not None, "base cannot be None for adding nonlocal args"
                builder.add_var_to_env_class(arg.variable, rtype, base, reassign=reassign)
</t>
<t tx="ekr.20240308084832.1281">def setup_func_for_recursive_call(builder: IRBuilder, fdef: FuncDef, base: ImplicitClass) -&gt; None:
    """Enable calling a nested function (with a callable class) recursively.

    Adds the instance of the callable class representing the given
    FuncDef to a register in the environment so that the function can
    be called recursively. Note that this needs to be done only for
    nested functions.
    """
    # First, set the attribute of the environment class so that GetAttr can be called on it.
    prev_env = builder.fn_infos[-2].env_class
    prev_env.attributes[fdef.name] = builder.type_to_rtype(fdef.type)

    if isinstance(base, GeneratorClass):
        # If we are dealing with a generator class, then we need to first get the register
        # holding the current environment class, and load the previous environment class from
        # there.
        prev_env_reg = builder.add(GetAttr(base.curr_env_reg, ENV_ATTR_NAME, -1))
    else:
        prev_env_reg = base.prev_env_reg

    # Obtain the instance of the callable class representing the FuncDef, and add it to the
    # current environment.
    val = builder.add(GetAttr(prev_env_reg, fdef.name, -1))
    target = builder.add_local_reg(fdef, object_rprimitive)
    builder.assign(target, val, -1)
</t>
<t tx="ekr.20240308084832.1282">def is_free_variable(builder: IRBuilder, symbol: SymbolNode) -&gt; bool:
    fitem = builder.fn_info.fitem
    return fitem in builder.free_variables and symbol in builder.free_variables[fitem]
</t>
<t tx="ekr.20240308084832.1283">"""Transform mypy expression ASTs to mypyc IR (Intermediate Representation).

The top-level AST transformation logic is implemented in mypyc.irbuild.visitor
and mypyc.irbuild.builder.
"""

from __future__ import annotations

import math
from typing import Callable, Sequence

from mypy.nodes import (
    ARG_POS,
    LDEF,
    AssertTypeExpr,
    AssignmentExpr,
    BytesExpr,
    CallExpr,
    CastExpr,
    ComparisonExpr,
    ComplexExpr,
    ConditionalExpr,
    DictExpr,
    DictionaryComprehension,
    EllipsisExpr,
    Expression,
    FloatExpr,
    GeneratorExpr,
    IndexExpr,
    IntExpr,
    ListComprehension,
    ListExpr,
    MemberExpr,
    MypyFile,
    NameExpr,
    OpExpr,
    RefExpr,
    SetComprehension,
    SetExpr,
    SliceExpr,
    StarExpr,
    StrExpr,
    SuperExpr,
    TupleExpr,
    TypeApplication,
    TypeInfo,
    UnaryExpr,
    Var,
)
from mypy.types import Instance, ProperType, TupleType, TypeType, get_proper_type
from mypyc.common import MAX_SHORT_INT
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FUNC_CLASSMETHOD, FUNC_STATICMETHOD
from mypyc.ir.ops import (
    Assign,
    BasicBlock,
    ComparisonOp,
    Integer,
    LoadAddress,
    LoadLiteral,
    RaiseStandardError,
    Register,
    TupleGet,
    TupleSet,
    Value,
)
from mypyc.ir.rtypes import (
    RTuple,
    bool_rprimitive,
    int_rprimitive,
    is_fixed_width_rtype,
    is_int_rprimitive,
    is_list_rprimitive,
    is_none_rprimitive,
    object_rprimitive,
    set_rprimitive,
)
from mypyc.irbuild.ast_helpers import is_borrow_friendly_expr, process_conditional
from mypyc.irbuild.builder import IRBuilder, int_borrow_friendly_op
from mypyc.irbuild.constant_fold import constant_fold_expr
from mypyc.irbuild.for_helpers import (
    comprehension_helper,
    translate_list_comprehension,
    translate_set_comprehension,
)
from mypyc.irbuild.format_str_tokenizer import (
    convert_format_expr_to_bytes,
    convert_format_expr_to_str,
    join_formatted_bytes,
    join_formatted_strings,
    tokenizer_printf_style,
)
from mypyc.irbuild.specialize import apply_function_specialization, apply_method_specialization
from mypyc.primitives.bytes_ops import bytes_slice_op
from mypyc.primitives.dict_ops import dict_get_item_op, dict_new_op, dict_set_item_op
from mypyc.primitives.generic_ops import iter_op
from mypyc.primitives.int_ops import int_comparison_op_mapping
from mypyc.primitives.list_ops import list_append_op, list_extend_op, list_slice_op
from mypyc.primitives.misc_ops import ellipsis_op, get_module_dict_op, new_slice_op, type_op
from mypyc.primitives.registry import CFunctionDescription, builtin_names
from mypyc.primitives.set_ops import set_add_op, set_in_op, set_update_op
from mypyc.primitives.str_ops import str_slice_op
from mypyc.primitives.tuple_ops import list_tuple_op, tuple_slice_op

# Name and attribute references


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1284">def transform_name_expr(builder: IRBuilder, expr: NameExpr) -&gt; Value:
    if expr.node is None:
        builder.add(
            RaiseStandardError(
                RaiseStandardError.RUNTIME_ERROR,
                "mypyc internal error: should be unreachable",
                expr.line,
            )
        )
        return builder.none()
    fullname = expr.node.fullname
    if fullname in builtin_names:
        typ, src = builtin_names[fullname]
        return builder.add(LoadAddress(typ, src, expr.line))
    # special cases
    if fullname == "builtins.None":
        return builder.none()
    if fullname == "builtins.True":
        return builder.true()
    if fullname == "builtins.False":
        return builder.false()

    math_literal = transform_math_literal(builder, fullname)
    if math_literal is not None:
        return math_literal

    if isinstance(expr.node, Var) and expr.node.is_final:
        value = builder.emit_load_final(
            expr.node,
            fullname,
            expr.name,
            builder.is_native_ref_expr(expr),
            builder.types[expr],
            expr.line,
        )
        if value is not None:
            return value

    if isinstance(expr.node, MypyFile) and expr.node.fullname in builder.imports:
        return builder.load_module(expr.node.fullname)

    # If the expression is locally defined, then read the result from the corresponding
    # assignment target and return it. Otherwise if the expression is a global, load it from
    # the globals dictionary.
    # Except for imports, that currently always happens in the global namespace.
    if expr.kind == LDEF and not (isinstance(expr.node, Var) and expr.node.is_suppressed_import):
        # Try to detect and error when we hit the irritating mypy bug
        # where a local variable is cast to None. (#5423)
        if (
            isinstance(expr.node, Var)
            and is_none_rprimitive(builder.node_type(expr))
            and expr.node.is_inferred
        ):
            builder.error(
                'Local variable "{}" has inferred type None; add an annotation'.format(
                    expr.node.name
                ),
                expr.node.line,
            )

        # TODO: Behavior currently only defined for Var, FuncDef and MypyFile node types.
        if isinstance(expr.node, MypyFile):
            # Load reference to a module imported inside function from
            # the modules dictionary. It would be closer to Python
            # semantics to access modules imported inside functions
            # via local variables, but this is tricky since the mypy
            # AST doesn't include a Var node for the module. We
            # instead load the module separately on each access.
            mod_dict = builder.call_c(get_module_dict_op, [], expr.line)
            obj = builder.call_c(
                dict_get_item_op, [mod_dict, builder.load_str(expr.node.fullname)], expr.line
            )
            return obj
        else:
            return builder.read(builder.get_assignment_target(expr, for_read=True), expr.line)

    return builder.load_global(expr)
</t>
<t tx="ekr.20240308084832.1285">def transform_member_expr(builder: IRBuilder, expr: MemberExpr) -&gt; Value:
    # First check if this is maybe a final attribute.
    final = builder.get_final_ref(expr)
    if final is not None:
        fullname, final_var, native = final
        value = builder.emit_load_final(
            final_var, fullname, final_var.name, native, builder.types[expr], expr.line
        )
        if value is not None:
            return value

    math_literal = transform_math_literal(builder, expr.fullname)
    if math_literal is not None:
        return math_literal

    if isinstance(expr.node, MypyFile) and expr.node.fullname in builder.imports:
        return builder.load_module(expr.node.fullname)

    can_borrow = builder.is_native_attr_ref(expr)
    obj = builder.accept(expr.expr, can_borrow=can_borrow)
    rtype = builder.node_type(expr)

    # Special case: for named tuples transform attribute access to faster index access.
    typ = get_proper_type(builder.types.get(expr.expr))
    if isinstance(typ, TupleType) and typ.partial_fallback.type.is_named_tuple:
        fields = typ.partial_fallback.type.metadata["namedtuple"]["fields"]
        if expr.name in fields:
            index = builder.builder.load_int(fields.index(expr.name))
            return builder.gen_method_call(obj, "__getitem__", [index], rtype, expr.line)

    check_instance_attribute_access_through_class(builder, expr, typ)

    borrow = can_borrow and builder.can_borrow
    return builder.builder.get_attr(obj, expr.name, rtype, expr.line, borrow=borrow)
</t>
<t tx="ekr.20240308084832.1286">def check_instance_attribute_access_through_class(
    builder: IRBuilder, expr: MemberExpr, typ: ProperType | None
) -&gt; None:
    """Report error if accessing an instance attribute through class object."""
    if isinstance(expr.expr, RefExpr):
        node = expr.expr.node
        if isinstance(typ, TypeType) and isinstance(typ.item, Instance):
            # TODO: Handle other item types
            node = typ.item.type
        if isinstance(node, TypeInfo):
            class_ir = builder.mapper.type_to_ir.get(node)
            if class_ir is not None and class_ir.is_ext_class:
                sym = node.get(expr.name)
                if (
                    sym is not None
                    and isinstance(sym.node, Var)
                    and not sym.node.is_classvar
                    and not sym.node.is_final
                ):
                    builder.error(
                        'Cannot access instance attribute "{}" through class object'.format(
                            expr.name
                        ),
                        expr.line,
                    )
                    builder.note(
                        '(Hint: Use "x: Final = ..." or "x: ClassVar = ..." to define '
                        "a class attribute)",
                        expr.line,
                    )
</t>
<t tx="ekr.20240308084832.1287">def transform_super_expr(builder: IRBuilder, o: SuperExpr) -&gt; Value:
    # warning(builder, 'can not optimize super() expression', o.line)
    sup_val = builder.load_module_attr_by_fullname("builtins.super", o.line)
    if o.call.args:
        args = [builder.accept(arg) for arg in o.call.args]
    else:
        assert o.info is not None
        typ = builder.load_native_type_object(o.info.fullname)
        ir = builder.mapper.type_to_ir[o.info]
        iter_env = iter(builder.builder.args)
        # Grab first argument
        vself: Value = next(iter_env)
        if builder.fn_info.is_generator:
            # grab sixth argument (see comment in translate_super_method_call)
            self_targ = list(builder.symtables[-1].values())[6]
            vself = builder.read(self_targ, builder.fn_info.fitem.line)
        elif not ir.is_ext_class:
            vself = next(iter_env)  # second argument is self if non_extension class
        args = [typ, vself]
    res = builder.py_call(sup_val, args, o.line)
    return builder.py_get_attr(res, o.name, o.line)
</t>
<t tx="ekr.20240308084832.1288"># Calls


def transform_call_expr(builder: IRBuilder, expr: CallExpr) -&gt; Value:
    callee = expr.callee
    if isinstance(expr.analyzed, CastExpr):
        return translate_cast_expr(builder, expr.analyzed)
    elif isinstance(expr.analyzed, AssertTypeExpr):
        # Compile to a no-op.
        return builder.accept(expr.analyzed.expr)
    elif (
        isinstance(callee, (NameExpr, MemberExpr))
        and isinstance(callee.node, TypeInfo)
        and callee.node.is_newtype
    ):
        # A call to a NewType type is a no-op at runtime.
        return builder.accept(expr.args[0])

    if isinstance(callee, IndexExpr) and isinstance(callee.analyzed, TypeApplication):
        callee = callee.analyzed.expr  # Unwrap type application

    if isinstance(callee, MemberExpr):
        if isinstance(callee.expr, RefExpr) and isinstance(callee.expr.node, MypyFile):
            # Call a module-level function, not a method.
            return translate_call(builder, expr, callee)
        return apply_method_specialization(builder, expr, callee) or translate_method_call(
            builder, expr, callee
        )
    elif isinstance(callee, SuperExpr):
        return translate_super_method_call(builder, expr, callee)
    else:
        return translate_call(builder, expr, callee)
</t>
<t tx="ekr.20240308084832.1289">def translate_call(builder: IRBuilder, expr: CallExpr, callee: Expression) -&gt; Value:
    # The common case of calls is refexprs
    if isinstance(callee, RefExpr):
        return apply_function_specialization(builder, expr, callee) or translate_refexpr_call(
            builder, expr, callee
        )

    function = builder.accept(callee)
    args = [builder.accept(arg) for arg in expr.args]
    return builder.py_call(
        function, args, expr.line, arg_kinds=expr.arg_kinds, arg_names=expr.arg_names
    )
</t>
<t tx="ekr.20240308084832.129">def __init__(self, before: AnalysisDict[T], after: AnalysisDict[T]) -&gt; None:
    self.before = before
    self.after = after
</t>
<t tx="ekr.20240308084832.1290">def translate_refexpr_call(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value:
    """Translate a non-method call."""
    # Gen the argument values
    arg_values = [builder.accept(arg) for arg in expr.args]

    return builder.call_refexpr_with_args(expr, callee, arg_values)
</t>
<t tx="ekr.20240308084832.1291">def translate_method_call(builder: IRBuilder, expr: CallExpr, callee: MemberExpr) -&gt; Value:
    """Generate IR for an arbitrary call of form e.m(...).

    This can also deal with calls to module-level functions.
    """
    if builder.is_native_ref_expr(callee):
        # Call to module-level native function or such
        return translate_call(builder, expr, callee)
    elif (
        isinstance(callee.expr, RefExpr)
        and isinstance(callee.expr.node, TypeInfo)
        and callee.expr.node in builder.mapper.type_to_ir
        and builder.mapper.type_to_ir[callee.expr.node].has_method(callee.name)
    ):
        # Call a method via the *class*
        assert isinstance(callee.expr.node, TypeInfo)
        ir = builder.mapper.type_to_ir[callee.expr.node]
        return call_classmethod(builder, ir, expr, callee)
    elif builder.is_module_member_expr(callee):
        # Fall back to a PyCall for non-native module calls
        function = builder.accept(callee)
        args = [builder.accept(arg) for arg in expr.args]
        return builder.py_call(
            function, args, expr.line, arg_kinds=expr.arg_kinds, arg_names=expr.arg_names
        )
    else:
        if isinstance(callee.expr, RefExpr):
            node = callee.expr.node
            if isinstance(node, Var) and node.is_cls:
                typ = get_proper_type(node.type)
                if isinstance(typ, TypeType) and isinstance(typ.item, Instance):
                    class_ir = builder.mapper.type_to_ir.get(typ.item.type)
                    if class_ir and class_ir.is_ext_class and class_ir.has_no_subclasses():
                        # Call a native classmethod via cls that can be statically bound,
                        # since the class has no subclasses.
                        return call_classmethod(builder, class_ir, expr, callee)

        receiver_typ = builder.node_type(callee.expr)

        # If there is a specializer for this method name/type, try calling it.
        # We would return the first successful one.
        val = apply_method_specialization(builder, expr, callee, receiver_typ)
        if val is not None:
            return val

        obj = builder.accept(callee.expr)
        args = [builder.accept(arg) for arg in expr.args]
        return builder.gen_method_call(
            obj,
            callee.name,
            args,
            builder.node_type(expr),
            expr.line,
            expr.arg_kinds,
            expr.arg_names,
        )
</t>
<t tx="ekr.20240308084832.1292">def call_classmethod(builder: IRBuilder, ir: ClassIR, expr: CallExpr, callee: MemberExpr) -&gt; Value:
    decl = ir.method_decl(callee.name)
    args = []
    arg_kinds, arg_names = expr.arg_kinds.copy(), expr.arg_names.copy()
    # Add the class argument for class methods in extension classes
    if decl.kind == FUNC_CLASSMETHOD and ir.is_ext_class:
        args.append(builder.load_native_type_object(ir.fullname))
        arg_kinds.insert(0, ARG_POS)
        arg_names.insert(0, None)
    args += [builder.accept(arg) for arg in expr.args]

    if ir.is_ext_class:
        return builder.builder.call(decl, args, arg_kinds, arg_names, expr.line)
    else:
        obj = builder.accept(callee.expr)
        return builder.gen_method_call(
            obj,
            callee.name,
            args,
            builder.node_type(expr),
            expr.line,
            expr.arg_kinds,
            expr.arg_names,
        )
</t>
<t tx="ekr.20240308084832.1293">def translate_super_method_call(builder: IRBuilder, expr: CallExpr, callee: SuperExpr) -&gt; Value:
    if callee.info is None or (len(callee.call.args) != 0 and len(callee.call.args) != 2):
        return translate_call(builder, expr, callee)

    # We support two-argument super but only when it is super(CurrentClass, self)
    # TODO: We could support it when it is a parent class in many cases?
    if len(callee.call.args) == 2:
        self_arg = callee.call.args[1]
        if (
            not isinstance(self_arg, NameExpr)
            or not isinstance(self_arg.node, Var)
            or not self_arg.node.is_self
        ):
            return translate_call(builder, expr, callee)

        typ_arg = callee.call.args[0]
        if (
            not isinstance(typ_arg, NameExpr)
            or not isinstance(typ_arg.node, TypeInfo)
            or callee.info is not typ_arg.node
        ):
            return translate_call(builder, expr, callee)

    ir = builder.mapper.type_to_ir[callee.info]
    # Search for the method in the mro, skipping ourselves. We
    # determine targets of super calls to native methods statically.
    for base in ir.mro[1:]:
        if callee.name in base.method_decls:
            break
    else:
        if (
            ir.is_ext_class
            and ir.builtin_base is None
            and not ir.inherits_python
            and callee.name == "__init__"
            and len(expr.args) == 0
        ):
            # Call translates to object.__init__(self), which is a
            # no-op, so omit the call.
            return builder.none()
        return translate_call(builder, expr, callee)

    decl = base.method_decl(callee.name)
    arg_values = [builder.accept(arg) for arg in expr.args]
    arg_kinds, arg_names = expr.arg_kinds.copy(), expr.arg_names.copy()

    if decl.kind != FUNC_STATICMETHOD:
        # Grab first argument
        vself: Value = builder.self()
        if decl.kind == FUNC_CLASSMETHOD:
            vself = builder.call_c(type_op, [vself], expr.line)
        elif builder.fn_info.is_generator:
            # For generator classes, the self target is the 6th value
            # in the symbol table (which is an ordered dict). This is sort
            # of ugly, but we can't search by name since the 'self' parameter
            # could be named anything, and it doesn't get added to the
            # environment indexes.
            self_targ = list(builder.symtables[-1].values())[6]
            vself = builder.read(self_targ, builder.fn_info.fitem.line)
        arg_values.insert(0, vself)
        arg_kinds.insert(0, ARG_POS)
        arg_names.insert(0, None)

    return builder.builder.call(decl, arg_values, arg_kinds, arg_names, expr.line)
</t>
<t tx="ekr.20240308084832.1294">def translate_cast_expr(builder: IRBuilder, expr: CastExpr) -&gt; Value:
    src = builder.accept(expr.expr)
    target_type = builder.type_to_rtype(expr.type)
    return builder.coerce(src, target_type, expr.line)
</t>
<t tx="ekr.20240308084832.1295"># Operators


def transform_unary_expr(builder: IRBuilder, expr: UnaryExpr) -&gt; Value:
    folded = try_constant_fold(builder, expr)
    if folded:
        return folded

    return builder.unary_op(builder.accept(expr.expr), expr.op, expr.line)
</t>
<t tx="ekr.20240308084832.1296">def transform_op_expr(builder: IRBuilder, expr: OpExpr) -&gt; Value:
    if expr.op in ("and", "or"):
        return builder.shortcircuit_expr(expr)

    # Special case for string formatting
    if expr.op == "%" and isinstance(expr.left, (StrExpr, BytesExpr)):
        ret = translate_printf_style_formatting(builder, expr.left, expr.right)
        if ret is not None:
            return ret

    folded = try_constant_fold(builder, expr)
    if folded:
        return folded

    borrow_left = False
    borrow_right = False

    ltype = builder.node_type(expr.left)
    rtype = builder.node_type(expr.right)

    # Special case some int ops to allow borrowing operands.
    if is_int_rprimitive(ltype) and is_int_rprimitive(rtype):
        if expr.op == "//":
            expr = try_optimize_int_floor_divide(expr)
        if expr.op in int_borrow_friendly_op:
            borrow_left = is_borrow_friendly_expr(builder, expr.right)
            borrow_right = True
    elif is_fixed_width_rtype(ltype) and is_fixed_width_rtype(rtype):
        borrow_left = is_borrow_friendly_expr(builder, expr.right)
        borrow_right = True

    left = builder.accept(expr.left, can_borrow=borrow_left)
    right = builder.accept(expr.right, can_borrow=borrow_right)
    return builder.binary_op(left, right, expr.op, expr.line)
</t>
<t tx="ekr.20240308084832.1297">def try_optimize_int_floor_divide(expr: OpExpr) -&gt; OpExpr:
    """Replace // with a power of two with a right shift, if possible."""
    if not isinstance(expr.right, IntExpr):
        return expr
    divisor = expr.right.value
    shift = divisor.bit_length() - 1
    if 0 &lt; shift &lt; 28 and divisor == (1 &lt;&lt; shift):
        return OpExpr("&gt;&gt;", expr.left, IntExpr(shift))
    return expr
</t>
<t tx="ekr.20240308084832.1298">def transform_index_expr(builder: IRBuilder, expr: IndexExpr) -&gt; Value:
    index = expr.index
    base_type = builder.node_type(expr.base)
    is_list = is_list_rprimitive(base_type)
    can_borrow_base = is_list and is_borrow_friendly_expr(builder, index)

    base = builder.accept(expr.base, can_borrow=can_borrow_base)

    if isinstance(base.type, RTuple) and isinstance(index, IntExpr):
        return builder.add(TupleGet(base, index.value, expr.line))

    if isinstance(index, SliceExpr):
        value = try_gen_slice_op(builder, base, index)
        if value:
            return value

    index_reg = builder.accept(expr.index, can_borrow=is_list)
    return builder.gen_method_call(
        base, "__getitem__", [index_reg], builder.node_type(expr), expr.line
    )
</t>
<t tx="ekr.20240308084832.1299">def try_constant_fold(builder: IRBuilder, expr: Expression) -&gt; Value | None:
    """Return the constant value of an expression if possible.

    Return None otherwise.
    """
    value = constant_fold_expr(builder, expr)
    if value is not None:
        return builder.load_literal_value(value)
    return None
</t>
<t tx="ekr.20240308084832.13">def group_name(modules: list[str]) -&gt; str:
    """Produce a probably unique name for a group from a list of module names."""
    if len(modules) == 1:
        return modules[0]

    h = hashlib.sha1()
    h.update(",".join(modules).encode())
    return h.hexdigest()[:20]
</t>
<t tx="ekr.20240308084832.130">def __str__(self) -&gt; str:
    return f"before: {self.before}\nafter: {self.after}\n"
</t>
<t tx="ekr.20240308084832.1300">def try_gen_slice_op(builder: IRBuilder, base: Value, index: SliceExpr) -&gt; Value | None:
    """Generate specialized slice op for some index expressions.

    Return None if a specialized op isn't available.

    This supports obj[x:y], obj[:x], and obj[x:] for a few types.
    """
    if index.stride:
        # We can only handle the default stride of 1.
        return None

    if index.begin_index:
        begin_type = builder.node_type(index.begin_index)
    else:
        begin_type = int_rprimitive
    if index.end_index:
        end_type = builder.node_type(index.end_index)
    else:
        end_type = int_rprimitive

    # Both begin and end index must be int (or missing).
    if is_int_rprimitive(begin_type) and is_int_rprimitive(end_type):
        if index.begin_index:
            begin = builder.accept(index.begin_index)
        else:
            begin = builder.load_int(0)
        if index.end_index:
            end = builder.accept(index.end_index)
        else:
            # Replace missing end index with the largest short integer
            # (a sequence can't be longer).
            end = builder.load_int(MAX_SHORT_INT)
        candidates = [list_slice_op, tuple_slice_op, str_slice_op, bytes_slice_op]
        return builder.builder.matching_call_c(candidates, [base, begin, end], index.line)

    return None
</t>
<t tx="ekr.20240308084832.1301">def transform_conditional_expr(builder: IRBuilder, expr: ConditionalExpr) -&gt; Value:
    if_body, else_body, next_block = BasicBlock(), BasicBlock(), BasicBlock()

    process_conditional(builder, expr.cond, if_body, else_body)
    expr_type = builder.node_type(expr)
    # Having actual Phi nodes would be really nice here!
    target = Register(expr_type)

    builder.activate_block(if_body)
    true_value = builder.accept(expr.if_expr)
    true_value = builder.coerce(true_value, expr_type, expr.line)
    builder.add(Assign(target, true_value))
    builder.goto(next_block)

    builder.activate_block(else_body)
    false_value = builder.accept(expr.else_expr)
    false_value = builder.coerce(false_value, expr_type, expr.line)
    builder.add(Assign(target, false_value))
    builder.goto(next_block)

    builder.activate_block(next_block)

    return target
</t>
<t tx="ekr.20240308084832.1302">def set_literal_values(builder: IRBuilder, items: Sequence[Expression]) -&gt; list[object] | None:
    values: list[object] = []
    for item in items:
        const_value = constant_fold_expr(builder, item)
        if const_value is not None:
            values.append(const_value)
            continue

        if isinstance(item, RefExpr):
            if item.fullname == "builtins.None":
                values.append(None)
            elif item.fullname == "builtins.True":
                values.append(True)
            elif item.fullname == "builtins.False":
                values.append(False)
        elif isinstance(item, TupleExpr):
            tuple_values = set_literal_values(builder, item.items)
            if tuple_values is not None:
                values.append(tuple(tuple_values))

    if len(values) != len(items):
        # Bail if not all items can be converted into values.
        return None
    return values
</t>
<t tx="ekr.20240308084832.1303">def precompute_set_literal(builder: IRBuilder, s: SetExpr) -&gt; Value | None:
    """Try to pre-compute a frozenset literal during module initialization.

    Return None if it's not possible.

    Supported items:
     - Anything supported by irbuild.constant_fold.constant_fold_expr()
     - None, True, and False
     - Tuple literals with only items listed above
    """
    values = set_literal_values(builder, s.items)
    if values is not None:
        return builder.add(LoadLiteral(frozenset(values), set_rprimitive))

    return None
</t>
<t tx="ekr.20240308084832.1304">def transform_comparison_expr(builder: IRBuilder, e: ComparisonExpr) -&gt; Value:
    # x in (...)/[...]
    # x not in (...)/[...]
    first_op = e.operators[0]
    if (
        first_op in ["in", "not in"]
        and len(e.operators) == 1
        and isinstance(e.operands[1], (TupleExpr, ListExpr))
    ):
        items = e.operands[1].items
        n_items = len(items)
        # x in y -&gt; x == y[0] or ... or x == y[n]
        # x not in y -&gt; x != y[0] and ... and x != y[n]
        # 16 is arbitrarily chosen to limit code size
        if 1 &lt; n_items &lt; 16:
            if e.operators[0] == "in":
                bin_op = "or"
                cmp_op = "=="
            else:
                bin_op = "and"
                cmp_op = "!="
            lhs = e.operands[0]
            mypy_file = builder.graph["builtins"].tree
            assert mypy_file is not None
            info = mypy_file.names["bool"].node
            assert isinstance(info, TypeInfo)
            bool_type = Instance(info, [])
            exprs = []
            for item in items:
                expr = ComparisonExpr([cmp_op], [lhs, item])
                builder.types[expr] = bool_type
                exprs.append(expr)

            or_expr: Expression = exprs.pop(0)
            for expr in exprs:
                or_expr = OpExpr(bin_op, or_expr, expr)
                builder.types[or_expr] = bool_type
            return builder.accept(or_expr)
        # x in [y]/(y) -&gt; x == y
        # x not in [y]/(y) -&gt; x != y
        elif n_items == 1:
            if e.operators[0] == "in":
                cmp_op = "=="
            else:
                cmp_op = "!="
            e.operators = [cmp_op]
            e.operands[1] = items[0]
        # x in []/() -&gt; False
        # x not in []/() -&gt; True
        elif n_items == 0:
            if e.operators[0] == "in":
                return builder.false()
            else:
                return builder.true()

    # x in {...}
    # x not in {...}
    if (
        first_op in ("in", "not in")
        and len(e.operators) == 1
        and isinstance(e.operands[1], SetExpr)
    ):
        set_literal = precompute_set_literal(builder, e.operands[1])
        if set_literal is not None:
            lhs = e.operands[0]
            result = builder.builder.call_c(
                set_in_op, [builder.accept(lhs), set_literal], e.line, bool_rprimitive
            )
            if first_op == "not in":
                return builder.unary_op(result, "not", e.line)
            return result

    if len(e.operators) == 1:
        # Special some common simple cases
        if first_op in ("is", "is not"):
            right_expr = e.operands[1]
            if isinstance(right_expr, NameExpr) and right_expr.fullname == "builtins.None":
                # Special case 'is None' / 'is not None'.
                return translate_is_none(builder, e.operands[0], negated=first_op != "is")
        left_expr = e.operands[0]
        if is_int_rprimitive(builder.node_type(left_expr)):
            right_expr = e.operands[1]
            if is_int_rprimitive(builder.node_type(right_expr)):
                if first_op in int_borrow_friendly_op:
                    borrow_left = is_borrow_friendly_expr(builder, right_expr)
                    left = builder.accept(left_expr, can_borrow=borrow_left)
                    right = builder.accept(right_expr, can_borrow=True)
                    return builder.compare_tagged(left, right, first_op, e.line)

    # TODO: Don't produce an expression when used in conditional context
    # All of the trickiness here is due to support for chained conditionals
    # (`e1 &lt; e2 &gt; e3`, etc). `e1 &lt; e2 &gt; e3` is approximately equivalent to
    # `e1 &lt; e2 and e2 &gt; e3` except that `e2` is only evaluated once.
    expr_type = builder.node_type(e)

    # go(i, prev) generates code for `ei opi e{i+1} op{i+1} ... en`,
    # assuming that prev contains the value of `ei`.
    def go(i: int, prev: Value) -&gt; Value:
        if i == len(e.operators) - 1:
            return transform_basic_comparison(
                builder, e.operators[i], prev, builder.accept(e.operands[i + 1]), e.line
            )

        next = builder.accept(e.operands[i + 1])
        return builder.builder.shortcircuit_helper(
            "and",
            expr_type,
            lambda: transform_basic_comparison(builder, e.operators[i], prev, next, e.line),
            lambda: go(i + 1, next),
            e.line,
        )

    return go(0, builder.accept(e.operands[0]))
</t>
<t tx="ekr.20240308084832.1305">def translate_is_none(builder: IRBuilder, expr: Expression, negated: bool) -&gt; Value:
    v = builder.accept(expr, can_borrow=True)
    return builder.binary_op(v, builder.none_object(), "is not" if negated else "is", expr.line)
</t>
<t tx="ekr.20240308084832.1306">def transform_basic_comparison(
    builder: IRBuilder, op: str, left: Value, right: Value, line: int
) -&gt; Value:
    if (
        is_int_rprimitive(left.type)
        and is_int_rprimitive(right.type)
        and op in int_comparison_op_mapping
    ):
        return builder.compare_tagged(left, right, op, line)
    if is_fixed_width_rtype(left.type) and op in int_comparison_op_mapping:
        if right.type == left.type:
            if left.type.is_signed:
                op_id = ComparisonOp.signed_ops[op]
            else:
                op_id = ComparisonOp.unsigned_ops[op]
            return builder.builder.comparison_op(left, right, op_id, line)
        elif isinstance(right, Integer):
            if left.type.is_signed:
                op_id = ComparisonOp.signed_ops[op]
            else:
                op_id = ComparisonOp.unsigned_ops[op]
            return builder.builder.comparison_op(
                left, builder.coerce(right, left.type, line), op_id, line
            )
    elif (
        is_fixed_width_rtype(right.type)
        and op in int_comparison_op_mapping
        and isinstance(left, Integer)
    ):
        if right.type.is_signed:
            op_id = ComparisonOp.signed_ops[op]
        else:
            op_id = ComparisonOp.unsigned_ops[op]
        return builder.builder.comparison_op(
            builder.coerce(left, right.type, line), right, op_id, line
        )

    negate = False
    if op == "is not":
        op, negate = "is", True
    elif op == "not in":
        op, negate = "in", True

    target = builder.binary_op(left, right, op, line)

    if negate:
        target = builder.unary_op(target, "not", line)
    return target
</t>
<t tx="ekr.20240308084832.1307">def translate_printf_style_formatting(
    builder: IRBuilder, format_expr: StrExpr | BytesExpr, rhs: Expression
) -&gt; Value | None:
    tokens = tokenizer_printf_style(format_expr.value)
    if tokens is not None:
        literals, format_ops = tokens

        exprs = []
        if isinstance(rhs, TupleExpr):
            exprs = rhs.items
        elif isinstance(rhs, Expression):
            exprs.append(rhs)

        if isinstance(format_expr, BytesExpr):
            substitutions = convert_format_expr_to_bytes(
                builder, format_ops, exprs, format_expr.line
            )
            if substitutions is not None:
                return join_formatted_bytes(builder, literals, substitutions, format_expr.line)
        else:
            substitutions = convert_format_expr_to_str(
                builder, format_ops, exprs, format_expr.line
            )
            if substitutions is not None:
                return join_formatted_strings(builder, literals, substitutions, format_expr.line)

    return None
</t>
<t tx="ekr.20240308084832.1308"># Literals


def transform_int_expr(builder: IRBuilder, expr: IntExpr) -&gt; Value:
    return builder.builder.load_int(expr.value)
</t>
<t tx="ekr.20240308084832.1309">def transform_float_expr(builder: IRBuilder, expr: FloatExpr) -&gt; Value:
    return builder.builder.load_float(expr.value)
</t>
<t tx="ekr.20240308084832.131">GenAndKill = Tuple[Set[T], Set[T]]


class BaseAnalysisVisitor(OpVisitor[GenAndKill[T]]):
    @others
</t>
<t tx="ekr.20240308084832.1310">def transform_complex_expr(builder: IRBuilder, expr: ComplexExpr) -&gt; Value:
    return builder.builder.load_complex(expr.value)
</t>
<t tx="ekr.20240308084832.1311">def transform_str_expr(builder: IRBuilder, expr: StrExpr) -&gt; Value:
    return builder.load_str(expr.value)
</t>
<t tx="ekr.20240308084832.1312">def transform_bytes_expr(builder: IRBuilder, expr: BytesExpr) -&gt; Value:
    return builder.load_bytes_from_str_literal(expr.value)
</t>
<t tx="ekr.20240308084832.1313">def transform_ellipsis(builder: IRBuilder, o: EllipsisExpr) -&gt; Value:
    return builder.add(LoadAddress(ellipsis_op.type, ellipsis_op.src, o.line))
</t>
<t tx="ekr.20240308084832.1314"># Display expressions


def transform_list_expr(builder: IRBuilder, expr: ListExpr) -&gt; Value:
    return _visit_list_display(builder, expr.items, expr.line)
</t>
<t tx="ekr.20240308084832.1315">def _visit_list_display(builder: IRBuilder, items: list[Expression], line: int) -&gt; Value:
    return _visit_display(
        builder, items, builder.new_list_op, list_append_op, list_extend_op, line, True
    )
</t>
<t tx="ekr.20240308084832.1316">def transform_tuple_expr(builder: IRBuilder, expr: TupleExpr) -&gt; Value:
    if any(isinstance(item, StarExpr) for item in expr.items):
        # create a tuple of unknown length
        return _visit_tuple_display(builder, expr)

    # create a tuple of fixed length (RTuple)
    tuple_type = builder.node_type(expr)
    # When handling NamedTuple et. al we might not have proper type info,
    # so make some up if we need it.
    types = (
        tuple_type.types
        if isinstance(tuple_type, RTuple)
        else [object_rprimitive] * len(expr.items)
    )

    items = []
    for item_expr, item_type in zip(expr.items, types):
        reg = builder.accept(item_expr)
        items.append(builder.coerce(reg, item_type, item_expr.line))
    return builder.add(TupleSet(items, expr.line))
</t>
<t tx="ekr.20240308084832.1317">def _visit_tuple_display(builder: IRBuilder, expr: TupleExpr) -&gt; Value:
    """Create a list, then turn it into a tuple."""
    val_as_list = _visit_list_display(builder, expr.items, expr.line)
    return builder.call_c(list_tuple_op, [val_as_list], expr.line)
</t>
<t tx="ekr.20240308084832.1318">def transform_dict_expr(builder: IRBuilder, expr: DictExpr) -&gt; Value:
    """First accepts all keys and values, then makes a dict out of them."""
    key_value_pairs = []
    for key_expr, value_expr in expr.items:
        key = builder.accept(key_expr) if key_expr is not None else None
        value = builder.accept(value_expr)
        key_value_pairs.append((key, value))

    return builder.builder.make_dict(key_value_pairs, expr.line)
</t>
<t tx="ekr.20240308084832.1319">def transform_set_expr(builder: IRBuilder, expr: SetExpr) -&gt; Value:
    return _visit_display(
        builder, expr.items, builder.new_set_op, set_add_op, set_update_op, expr.line, False
    )
</t>
<t tx="ekr.20240308084832.132">def visit_goto(self, op: Goto) -&gt; GenAndKill[T]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1320">def _visit_display(
    builder: IRBuilder,
    items: list[Expression],
    constructor_op: Callable[[list[Value], int], Value],
    append_op: CFunctionDescription,
    extend_op: CFunctionDescription,
    line: int,
    is_list: bool,
) -&gt; Value:
    accepted_items = []
    for item in items:
        if isinstance(item, StarExpr):
            accepted_items.append((True, builder.accept(item.expr)))
        else:
            accepted_items.append((False, builder.accept(item)))

    result: Value | None = None
    initial_items = []
    for starred, value in accepted_items:
        if result is None and not starred and is_list:
            initial_items.append(value)
            continue

        if result is None:
            result = constructor_op(initial_items, line)

        builder.call_c(extend_op if starred else append_op, [result, value], line)

    if result is None:
        result = constructor_op(initial_items, line)

    return result
</t>
<t tx="ekr.20240308084832.1321"># Comprehensions


def transform_list_comprehension(builder: IRBuilder, o: ListComprehension) -&gt; Value:
    return translate_list_comprehension(builder, o.generator)
</t>
<t tx="ekr.20240308084832.1322">def transform_set_comprehension(builder: IRBuilder, o: SetComprehension) -&gt; Value:
    return translate_set_comprehension(builder, o.generator)
</t>
<t tx="ekr.20240308084832.1323">def transform_dictionary_comprehension(builder: IRBuilder, o: DictionaryComprehension) -&gt; Value:
    d = builder.maybe_spill(builder.call_c(dict_new_op, [], o.line))
    loop_params = list(zip(o.indices, o.sequences, o.condlists, o.is_async))

    def gen_inner_stmts() -&gt; None:
        k = builder.accept(o.key)
        v = builder.accept(o.value)
        builder.call_c(dict_set_item_op, [builder.read(d), k, v], o.line)

    comprehension_helper(builder, loop_params, gen_inner_stmts, o.line)
    return builder.read(d)
</t>
<t tx="ekr.20240308084832.1324"># Misc


def transform_slice_expr(builder: IRBuilder, expr: SliceExpr) -&gt; Value:
    def get_arg(arg: Expression | None) -&gt; Value:
        if arg is None:
            return builder.none_object()
        else:
            return builder.accept(arg)

    args = [get_arg(expr.begin_index), get_arg(expr.end_index), get_arg(expr.stride)]
    return builder.call_c(new_slice_op, args, expr.line)
</t>
<t tx="ekr.20240308084832.1325">def transform_generator_expr(builder: IRBuilder, o: GeneratorExpr) -&gt; Value:
    builder.warning("Treating generator comprehension as list", o.line)
    return builder.call_c(iter_op, [translate_list_comprehension(builder, o)], o.line)
</t>
<t tx="ekr.20240308084832.1326">def transform_assignment_expr(builder: IRBuilder, o: AssignmentExpr) -&gt; Value:
    value = builder.accept(o.value)
    target = builder.get_assignment_target(o.target)
    builder.assign(target, value, o.line)
    return value
</t>
<t tx="ekr.20240308084832.1327">def transform_math_literal(builder: IRBuilder, fullname: str) -&gt; Value | None:
    if fullname == "math.e":
        return builder.load_float(math.e)
    if fullname == "math.pi":
        return builder.load_float(math.pi)
    if fullname == "math.inf":
        return builder.load_float(math.inf)
    if fullname == "math.nan":
        return builder.load_float(math.nan)
    if fullname == "math.tau":
        return builder.load_float(math.tau)

    return None
</t>
<t tx="ekr.20240308084832.1328">"""Helpers for generating for loops and comprehensions.

We special case certain kinds for loops such as "for x in range(...)"
for better efficiency.  Each for loop generator class below deals one
such special case.
"""

from __future__ import annotations

from typing import Callable, ClassVar

from mypy.nodes import (
    ARG_POS,
    CallExpr,
    Expression,
    GeneratorExpr,
    Lvalue,
    MemberExpr,
    RefExpr,
    SetExpr,
    TupleExpr,
    TypeAlias,
)
from mypyc.ir.ops import (
    BasicBlock,
    Branch,
    Integer,
    IntOp,
    LoadAddress,
    LoadMem,
    Register,
    TupleGet,
    TupleSet,
    Value,
)
from mypyc.ir.rtypes import (
    RTuple,
    RType,
    bool_rprimitive,
    int_rprimitive,
    is_dict_rprimitive,
    is_fixed_width_rtype,
    is_list_rprimitive,
    is_sequence_rprimitive,
    is_short_int_rprimitive,
    is_str_rprimitive,
    is_tuple_rprimitive,
    pointer_rprimitive,
    short_int_rprimitive,
)
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.targets import AssignmentTarget, AssignmentTargetTuple
from mypyc.primitives.dict_ops import (
    dict_check_size_op,
    dict_item_iter_op,
    dict_key_iter_op,
    dict_next_item_op,
    dict_next_key_op,
    dict_next_value_op,
    dict_value_iter_op,
)
from mypyc.primitives.exc_ops import no_err_occurred_op
from mypyc.primitives.generic_ops import aiter_op, anext_op, iter_op, next_op
from mypyc.primitives.list_ops import list_append_op, list_get_item_unsafe_op, new_list_set_item_op
from mypyc.primitives.misc_ops import stop_async_iteration_op
from mypyc.primitives.registry import CFunctionDescription
from mypyc.primitives.set_ops import set_add_op

GenFunc = Callable[[], None]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1329">def for_loop_helper(
    builder: IRBuilder,
    index: Lvalue,
    expr: Expression,
    body_insts: GenFunc,
    else_insts: GenFunc | None,
    is_async: bool,
    line: int,
) -&gt; None:
    """Generate IR for a loop.

    Args:
        index: the loop index Lvalue
        expr: the expression to iterate over
        body_insts: a function that generates the body of the loop
        else_insts: a function that generates the else block instructions
    """
    # Body of the loop
    body_block = BasicBlock()
    # Block that steps to the next item
    step_block = BasicBlock()
    # Block for the else clause, if we need it
    else_block = BasicBlock()
    # Block executed after the loop
    exit_block = BasicBlock()

    # Determine where we want to exit, if our condition check fails.
    normal_loop_exit = else_block if else_insts is not None else exit_block

    for_gen = make_for_loop_generator(
        builder, index, expr, body_block, normal_loop_exit, line, is_async=is_async
    )

    builder.push_loop_stack(step_block, exit_block)
    condition_block = BasicBlock()
    builder.goto_and_activate(condition_block)

    # Add loop condition check.
    for_gen.gen_condition()

    # Generate loop body.
    builder.activate_block(body_block)
    for_gen.begin_body()
    body_insts()

    # We generate a separate step block (which might be empty).
    builder.goto_and_activate(step_block)
    for_gen.gen_step()
    # Go back to loop condition.
    builder.goto(condition_block)

    for_gen.add_cleanup(normal_loop_exit)
    builder.pop_loop_stack()

    if else_insts is not None:
        builder.activate_block(else_block)
        else_insts()
        builder.goto(exit_block)

    builder.activate_block(exit_block)
</t>
<t tx="ekr.20240308084832.133">@abstractmethod
def visit_register_op(self, op: RegisterOp) -&gt; GenAndKill[T]:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.1330">def for_loop_helper_with_index(
    builder: IRBuilder,
    index: Lvalue,
    expr: Expression,
    expr_reg: Value,
    body_insts: Callable[[Value], None],
    line: int,
) -&gt; None:
    """Generate IR for a sequence iteration.

    This function only works for sequence type. Compared to for_loop_helper,
    it would feed iteration index to body_insts.

    Args:
        index: the loop index Lvalue
        expr: the expression to iterate over
        body_insts: a function that generates the body of the loop.
                    It needs a index as parameter.
    """
    assert is_sequence_rprimitive(expr_reg.type)
    target_type = builder.get_sequence_type(expr)

    body_block = BasicBlock()
    step_block = BasicBlock()
    exit_block = BasicBlock()
    condition_block = BasicBlock()

    for_gen = ForSequence(builder, index, body_block, exit_block, line, False)
    for_gen.init(expr_reg, target_type, reverse=False)

    builder.push_loop_stack(step_block, exit_block)

    builder.goto_and_activate(condition_block)
    for_gen.gen_condition()

    builder.activate_block(body_block)
    for_gen.begin_body()
    body_insts(builder.read(for_gen.index_target))

    builder.goto_and_activate(step_block)
    for_gen.gen_step()
    builder.goto(condition_block)

    for_gen.add_cleanup(exit_block)
    builder.pop_loop_stack()

    builder.activate_block(exit_block)
</t>
<t tx="ekr.20240308084832.1331">def sequence_from_generator_preallocate_helper(
    builder: IRBuilder,
    gen: GeneratorExpr,
    empty_op_llbuilder: Callable[[Value, int], Value],
    set_item_op: CFunctionDescription,
) -&gt; Value | None:
    """Generate a new tuple or list from a simple generator expression.

    Currently we only optimize for simplest generator expression, which means that
    there is no condition list in the generator and only one original sequence with
    one index is allowed.

    e.g.  (1) tuple(f(x) for x in a_list/a_tuple)
          (2) list(f(x) for x in a_list/a_tuple)
          (3) [f(x) for x in a_list/a_tuple]
    RTuple as an original sequence is not supported yet.

    Args:
        empty_op_llbuilder: A function that can generate an empty sequence op when
            passed in length. See `new_list_op_with_length` and `new_tuple_op_with_length`
            for detailed implementation.
        set_item_op: A primitive that can modify an arbitrary position of a sequence.
            The op should have three arguments:
                - Self
                - Target position
                - New Value
            See `new_list_set_item_op` and `new_tuple_set_item_op` for detailed
            implementation.
    """
    if len(gen.sequences) == 1 and len(gen.indices) == 1 and len(gen.condlists[0]) == 0:
        rtype = builder.node_type(gen.sequences[0])
        if is_list_rprimitive(rtype) or is_tuple_rprimitive(rtype) or is_str_rprimitive(rtype):
            sequence = builder.accept(gen.sequences[0])
            length = builder.builder.builtin_len(sequence, gen.line, use_pyssize_t=True)
            target_op = empty_op_llbuilder(length, gen.line)

            def set_item(item_index: Value) -&gt; None:
                e = builder.accept(gen.left_expr)
                builder.call_c(set_item_op, [target_op, item_index, e], gen.line)

            for_loop_helper_with_index(
                builder, gen.indices[0], gen.sequences[0], sequence, set_item, gen.line
            )

            return target_op
    return None
</t>
<t tx="ekr.20240308084832.1332">def translate_list_comprehension(builder: IRBuilder, gen: GeneratorExpr) -&gt; Value:
    # Try simplest list comprehension, otherwise fall back to general one
    val = sequence_from_generator_preallocate_helper(
        builder,
        gen,
        empty_op_llbuilder=builder.builder.new_list_op_with_length,
        set_item_op=new_list_set_item_op,
    )
    if val is not None:
        return val

    list_ops = builder.maybe_spill(builder.new_list_op([], gen.line))

    loop_params = list(zip(gen.indices, gen.sequences, gen.condlists, gen.is_async))

    def gen_inner_stmts() -&gt; None:
        e = builder.accept(gen.left_expr)
        builder.call_c(list_append_op, [builder.read(list_ops), e], gen.line)

    comprehension_helper(builder, loop_params, gen_inner_stmts, gen.line)
    return builder.read(list_ops)
</t>
<t tx="ekr.20240308084832.1333">def translate_set_comprehension(builder: IRBuilder, gen: GeneratorExpr) -&gt; Value:
    set_ops = builder.maybe_spill(builder.new_set_op([], gen.line))
    loop_params = list(zip(gen.indices, gen.sequences, gen.condlists, gen.is_async))

    def gen_inner_stmts() -&gt; None:
        e = builder.accept(gen.left_expr)
        builder.call_c(set_add_op, [builder.read(set_ops), e], gen.line)

    comprehension_helper(builder, loop_params, gen_inner_stmts, gen.line)
    return builder.read(set_ops)
</t>
<t tx="ekr.20240308084832.1334">def comprehension_helper(
    builder: IRBuilder,
    loop_params: list[tuple[Lvalue, Expression, list[Expression], bool]],
    gen_inner_stmts: Callable[[], None],
    line: int,
) -&gt; None:
    """Helper function for list comprehensions.

    Args:
        loop_params: a list of (index, expr, [conditions]) tuples defining nested loops:
            - "index" is the Lvalue indexing that loop;
            - "expr" is the expression for the object to be iterated over;
            - "conditions" is a list of conditions, evaluated in order with short-circuiting,
                that must all be true for the loop body to be executed
        gen_inner_stmts: function to generate the IR for the body of the innermost loop
    """

    def handle_loop(loop_params: list[tuple[Lvalue, Expression, list[Expression], bool]]) -&gt; None:
        """Generate IR for a loop.

        Given a list of (index, expression, [conditions]) tuples, generate IR
        for the nested loops the list defines.
        """
        index, expr, conds, is_async = loop_params[0]
        for_loop_helper(
            builder,
            index,
            expr,
            lambda: loop_contents(conds, loop_params[1:]),
            None,
            is_async=is_async,
            line=line,
        )

    def loop_contents(
        conds: list[Expression],
        remaining_loop_params: list[tuple[Lvalue, Expression, list[Expression], bool]],
    ) -&gt; None:
        """Generate the body of the loop.

        Args:
            conds: a list of conditions to be evaluated (in order, with short circuiting)
                to gate the body of the loop
            remaining_loop_params: the parameters for any further nested loops; if it's empty
                we'll instead evaluate the "gen_inner_stmts" function
        """
        # Check conditions, in order, short circuiting them.
        for cond in conds:
            cond_val = builder.accept(cond)
            cont_block, rest_block = BasicBlock(), BasicBlock()
            # If the condition is true we'll skip the continue.
            builder.add_bool_branch(cond_val, rest_block, cont_block)
            builder.activate_block(cont_block)
            builder.nonlocal_control[-1].gen_continue(builder, cond.line)
            builder.goto_and_activate(rest_block)

        if remaining_loop_params:
            # There's another nested level, so the body of this loop is another loop.
            return handle_loop(remaining_loop_params)
        else:
            # We finally reached the actual body of the generator.
            # Generate the IR for the inner loop body.
            gen_inner_stmts()

    handle_loop(loop_params)
</t>
<t tx="ekr.20240308084832.1335">def is_range_ref(expr: RefExpr) -&gt; bool:
    return (
        expr.fullname == "builtins.range"
        or isinstance(expr.node, TypeAlias)
        and expr.fullname == "six.moves.xrange"
    )
</t>
<t tx="ekr.20240308084832.1336">def make_for_loop_generator(
    builder: IRBuilder,
    index: Lvalue,
    expr: Expression,
    body_block: BasicBlock,
    loop_exit: BasicBlock,
    line: int,
    is_async: bool = False,
    nested: bool = False,
) -&gt; ForGenerator:
    """Return helper object for generating a for loop over an iterable.

    If "nested" is True, this is a nested iterator such as "e" in "enumerate(e)".
    """

    # Do an async loop if needed. async is always generic
    if is_async:
        expr_reg = builder.accept(expr)
        async_obj = ForAsyncIterable(builder, index, body_block, loop_exit, line, nested)
        item_type = builder._analyze_iterable_item_type(expr)
        item_rtype = builder.type_to_rtype(item_type)
        async_obj.init(expr_reg, item_rtype)
        return async_obj

    rtyp = builder.node_type(expr)
    if is_sequence_rprimitive(rtyp):
        # Special case "for x in &lt;list&gt;".
        expr_reg = builder.accept(expr)
        target_type = builder.get_sequence_type(expr)

        for_list = ForSequence(builder, index, body_block, loop_exit, line, nested)
        for_list.init(expr_reg, target_type, reverse=False)
        return for_list

    if is_dict_rprimitive(rtyp):
        # Special case "for k in &lt;dict&gt;".
        expr_reg = builder.accept(expr)
        target_type = builder.get_dict_key_type(expr)

        for_dict = ForDictionaryKeys(builder, index, body_block, loop_exit, line, nested)
        for_dict.init(expr_reg, target_type)
        return for_dict

    if isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr):
        if (
            is_range_ref(expr.callee)
            and (
                len(expr.args) &lt;= 2
                or (len(expr.args) == 3 and builder.extract_int(expr.args[2]) is not None)
            )
            and set(expr.arg_kinds) == {ARG_POS}
        ):
            # Special case "for x in range(...)".
            # We support the 3 arg form but only for int literals, since it doesn't
            # seem worth the hassle of supporting dynamically determining which
            # direction of comparison to do.
            if len(expr.args) == 1:
                start_reg: Value = Integer(0)
                end_reg = builder.accept(expr.args[0])
            else:
                start_reg = builder.accept(expr.args[0])
                end_reg = builder.accept(expr.args[1])
            if len(expr.args) == 3:
                step = builder.extract_int(expr.args[2])
                assert step is not None
                if step == 0:
                    builder.error("range() step can't be zero", expr.args[2].line)
            else:
                step = 1

            for_range = ForRange(builder, index, body_block, loop_exit, line, nested)
            for_range.init(start_reg, end_reg, step)
            return for_range

        elif (
            expr.callee.fullname == "builtins.enumerate"
            and len(expr.args) == 1
            and expr.arg_kinds == [ARG_POS]
            and isinstance(index, TupleExpr)
            and len(index.items) == 2
        ):
            # Special case "for i, x in enumerate(y)".
            lvalue1 = index.items[0]
            lvalue2 = index.items[1]
            for_enumerate = ForEnumerate(builder, index, body_block, loop_exit, line, nested)
            for_enumerate.init(lvalue1, lvalue2, expr.args[0])
            return for_enumerate

        elif (
            expr.callee.fullname == "builtins.zip"
            and len(expr.args) &gt;= 2
            and set(expr.arg_kinds) == {ARG_POS}
            and isinstance(index, TupleExpr)
            and len(index.items) == len(expr.args)
        ):
            # Special case "for x, y in zip(a, b)".
            for_zip = ForZip(builder, index, body_block, loop_exit, line, nested)
            for_zip.init(index.items, expr.args)
            return for_zip

        if (
            expr.callee.fullname == "builtins.reversed"
            and len(expr.args) == 1
            and expr.arg_kinds == [ARG_POS]
            and is_sequence_rprimitive(builder.node_type(expr.args[0]))
        ):
            # Special case "for x in reversed(&lt;list&gt;)".
            expr_reg = builder.accept(expr.args[0])
            target_type = builder.get_sequence_type(expr)

            for_list = ForSequence(builder, index, body_block, loop_exit, line, nested)
            for_list.init(expr_reg, target_type, reverse=True)
            return for_list
    if isinstance(expr, CallExpr) and isinstance(expr.callee, MemberExpr) and not expr.args:
        # Special cases for dictionary iterator methods, like dict.items().
        rtype = builder.node_type(expr.callee.expr)
        if is_dict_rprimitive(rtype) and expr.callee.name in ("keys", "values", "items"):
            expr_reg = builder.accept(expr.callee.expr)
            for_dict_type: type[ForGenerator] | None = None
            if expr.callee.name == "keys":
                target_type = builder.get_dict_key_type(expr.callee.expr)
                for_dict_type = ForDictionaryKeys
            elif expr.callee.name == "values":
                target_type = builder.get_dict_value_type(expr.callee.expr)
                for_dict_type = ForDictionaryValues
            else:
                target_type = builder.get_dict_item_type(expr.callee.expr)
                for_dict_type = ForDictionaryItems
            for_dict_gen = for_dict_type(builder, index, body_block, loop_exit, line, nested)
            for_dict_gen.init(expr_reg, target_type)
            return for_dict_gen

    iterable_expr_reg: Value | None = None
    if isinstance(expr, SetExpr):
        # Special case "for x in &lt;set literal&gt;".
        from mypyc.irbuild.expression import precompute_set_literal

        set_literal = precompute_set_literal(builder, expr)
        if set_literal is not None:
            iterable_expr_reg = set_literal

    # Default to a generic for loop.
    if iterable_expr_reg is None:
        iterable_expr_reg = builder.accept(expr)
    for_obj = ForIterable(builder, index, body_block, loop_exit, line, nested)
    item_type = builder._analyze_iterable_item_type(expr)
    item_rtype = builder.type_to_rtype(item_type)
    for_obj.init(iterable_expr_reg, item_rtype)
    return for_obj
</t>
<t tx="ekr.20240308084832.1337">class ForGenerator:
    """Abstract base class for generating for loops."""
    @others
</t>
<t tx="ekr.20240308084832.1338">def __init__(
    self,
    builder: IRBuilder,
    index: Lvalue,
    body_block: BasicBlock,
    loop_exit: BasicBlock,
    line: int,
    nested: bool,
) -&gt; None:
    self.builder = builder
    self.index = index
    self.body_block = body_block
    self.line = line
    # Some for loops need a cleanup block that we execute at exit. We
    # create a cleanup block if needed. However, if we are generating a for
    # loop for a nested iterator, such as "e" in "enumerate(e)", the
    # outermost generator should generate the cleanup block -- we don't
    # need to do it here.
    if self.need_cleanup() and not nested:
        # Create a new block to handle cleanup after loop exit.
        self.loop_exit = BasicBlock()
    else:
        # Just use the existing loop exit block.
        self.loop_exit = loop_exit
</t>
<t tx="ekr.20240308084832.1339">def need_cleanup(self) -&gt; bool:
    """If this returns true, we need post-loop cleanup."""
    return False
</t>
<t tx="ekr.20240308084832.134">@abstractmethod
def visit_assign(self, op: Assign) -&gt; GenAndKill[T]:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.1340">def add_cleanup(self, exit_block: BasicBlock) -&gt; None:
    """Add post-loop cleanup, if needed."""
    if self.need_cleanup():
        self.builder.activate_block(self.loop_exit)
        self.gen_cleanup()
        self.builder.goto(exit_block)
</t>
<t tx="ekr.20240308084832.1341">def gen_condition(self) -&gt; None:
    """Generate check for loop exit (e.g. exhaustion of iteration)."""
</t>
<t tx="ekr.20240308084832.1342">def begin_body(self) -&gt; None:
    """Generate ops at the beginning of the body (if needed)."""
</t>
<t tx="ekr.20240308084832.1343">def gen_step(self) -&gt; None:
    """Generate stepping to the next item (if needed)."""
</t>
<t tx="ekr.20240308084832.1344">def gen_cleanup(self) -&gt; None:
    """Generate post-loop cleanup (if needed)."""
</t>
<t tx="ekr.20240308084832.1345">def load_len(self, expr: Value | AssignmentTarget) -&gt; Value:
    """A helper to get collection length, used by several subclasses."""
    return self.builder.builder.builtin_len(self.builder.read(expr, self.line), self.line)
</t>
<t tx="ekr.20240308084832.1346">class ForIterable(ForGenerator):
    """Generate IR for a for loop over an arbitrary iterable (the general case)."""
    @others
</t>
<t tx="ekr.20240308084832.1347">def need_cleanup(self) -&gt; bool:
    # Create a new cleanup block for when the loop is finished.
    return True
</t>
<t tx="ekr.20240308084832.1348">def init(self, expr_reg: Value, target_type: RType) -&gt; None:
    # Define targets to contain the expression, along with the iterator that will be used
    # for the for-loop. If we are inside of a generator function, spill these into the
    # environment class.
    builder = self.builder
    iter_reg = builder.call_c(iter_op, [expr_reg], self.line)
    builder.maybe_spill(expr_reg)
    self.iter_target = builder.maybe_spill(iter_reg)
    self.target_type = target_type
</t>
<t tx="ekr.20240308084832.1349">def gen_condition(self) -&gt; None:
    # We call __next__ on the iterator and check to see if the return value
    # is NULL, which signals either the end of the Iterable being traversed
    # or an exception being raised. Note that Branch.IS_ERROR checks only
    # for NULL (an exception does not necessarily have to be raised).
    builder = self.builder
    line = self.line
    self.next_reg = builder.call_c(next_op, [builder.read(self.iter_target, line)], line)
    builder.add(Branch(self.next_reg, self.loop_exit, self.body_block, Branch.IS_ERROR))
</t>
<t tx="ekr.20240308084832.135">@abstractmethod
def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill[T]:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.1350">def begin_body(self) -&gt; None:
    # Assign the value obtained from __next__ to the
    # lvalue so that it can be referenced by code in the body of the loop.
    builder = self.builder
    line = self.line
    # We unbox here so that iterating with tuple unpacking generates a tuple based
    # unpack instead of an iterator based one.
    next_reg = builder.coerce(self.next_reg, self.target_type, line)
    builder.assign(builder.get_assignment_target(self.index), next_reg, line)
</t>
<t tx="ekr.20240308084832.1351">def gen_step(self) -&gt; None:
    # Nothing to do here, since we get the next item as part of gen_condition().
    pass
</t>
<t tx="ekr.20240308084832.1352">def gen_cleanup(self) -&gt; None:
    # We set the branch to go here if the conditional evaluates to true. If
    # an exception was raised during the loop, then err_reg will be set to
    # True. If no_err_occurred_op returns False, then the exception will be
    # propagated using the ERR_FALSE flag.
    self.builder.call_c(no_err_occurred_op, [], self.line)
</t>
<t tx="ekr.20240308084832.1353">class ForAsyncIterable(ForGenerator):
    """Generate IR for an async for loop."""
    @others
</t>
<t tx="ekr.20240308084832.1354">def init(self, expr_reg: Value, target_type: RType) -&gt; None:
    # Define targets to contain the expression, along with the
    # iterator that will be used for the for-loop. We are inside
    # of a generator function, so we will spill these into
    # environment class.
    builder = self.builder
    iter_reg = builder.call_c(aiter_op, [expr_reg], self.line)
    builder.maybe_spill(expr_reg)
    self.iter_target = builder.maybe_spill(iter_reg)
    self.target_type = target_type
    self.stop_reg = Register(bool_rprimitive)
</t>
<t tx="ekr.20240308084832.1355">def gen_condition(self) -&gt; None:
    # This does the test and fetches the next value
    # try:
    #     TARGET = await type(iter).__anext__(iter)
    #     stop = False
    # except StopAsyncIteration:
    #     stop = True
    #
    # What a pain.
    # There are optimizations available here if we punch through some abstractions.

    from mypyc.irbuild.statement import emit_await, transform_try_except

    builder = self.builder
    line = self.line

    def except_match() -&gt; Value:
        addr = builder.add(LoadAddress(pointer_rprimitive, stop_async_iteration_op.src, line))
        return builder.add(LoadMem(stop_async_iteration_op.type, addr))

    def try_body() -&gt; None:
        awaitable = builder.call_c(anext_op, [builder.read(self.iter_target)], line)
        self.next_reg = emit_await(builder, awaitable, line)
        builder.assign(self.stop_reg, builder.false(), -1)

    def except_body() -&gt; None:
        builder.assign(self.stop_reg, builder.true(), line)

    transform_try_except(
        builder, try_body, [((except_match, line), None, except_body)], None, line
    )

    builder.add(Branch(self.stop_reg, self.loop_exit, self.body_block, Branch.BOOL))
</t>
<t tx="ekr.20240308084832.1356">def begin_body(self) -&gt; None:
    # Assign the value obtained from await __anext__ to the
    # lvalue so that it can be referenced by code in the body of the loop.
    builder = self.builder
    line = self.line
    # We unbox here so that iterating with tuple unpacking generates a tuple based
    # unpack instead of an iterator based one.
    next_reg = builder.coerce(self.next_reg, self.target_type, line)
    builder.assign(builder.get_assignment_target(self.index), next_reg, line)
</t>
<t tx="ekr.20240308084832.1357">def gen_step(self) -&gt; None:
    # Nothing to do here, since we get the next item as part of gen_condition().
    pass
</t>
<t tx="ekr.20240308084832.1358">def unsafe_index(builder: IRBuilder, target: Value, index: Value, line: int) -&gt; Value:
    """Emit a potentially unsafe index into a target."""
    # This doesn't really fit nicely into any of our data-driven frameworks
    # since we want to use __getitem__ if we don't have an unsafe version,
    # so we just check manually.
    if is_list_rprimitive(target.type):
        return builder.call_c(list_get_item_unsafe_op, [target, index], line)
    else:
        return builder.gen_method_call(target, "__getitem__", [index], None, line)
</t>
<t tx="ekr.20240308084832.1359">class ForSequence(ForGenerator):
    """Generate optimized IR for a for loop over a sequence.
    
    Supports iterating in both forward and reverse.
    """
    @others
</t>
<t tx="ekr.20240308084832.136">@abstractmethod
def visit_set_mem(self, op: SetMem) -&gt; GenAndKill[T]:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.1360">def init(self, expr_reg: Value, target_type: RType, reverse: bool) -&gt; None:
    builder = self.builder
    self.reverse = reverse
    # Define target to contain the expression, along with the index that will be used
    # for the for-loop. If we are inside of a generator function, spill these into the
    # environment class.
    self.expr_target = builder.maybe_spill(expr_reg)
    if not reverse:
        index_reg: Value = Integer(0)
    else:
        index_reg = builder.binary_op(
            self.load_len(self.expr_target), Integer(1), "-", self.line
        )
    self.index_target = builder.maybe_spill_assignable(index_reg)
    self.target_type = target_type
</t>
<t tx="ekr.20240308084832.1361">def gen_condition(self) -&gt; None:
    builder = self.builder
    line = self.line
    # TODO: Don't reload the length each time when iterating an immutable sequence?
    if self.reverse:
        # If we are iterating in reverse order, we obviously need
        # to check that the index is still positive. Somewhat less
        # obviously we still need to check against the length,
        # since it could shrink out from under us.
        comparison = builder.binary_op(
            builder.read(self.index_target, line), Integer(0), "&gt;=", line
        )
        second_check = BasicBlock()
        builder.add_bool_branch(comparison, second_check, self.loop_exit)
        builder.activate_block(second_check)
    # For compatibility with python semantics we recalculate the length
    # at every iteration.
    len_reg = self.load_len(self.expr_target)
    comparison = builder.binary_op(builder.read(self.index_target, line), len_reg, "&lt;", line)
    builder.add_bool_branch(comparison, self.body_block, self.loop_exit)
</t>
<t tx="ekr.20240308084832.1362">def begin_body(self) -&gt; None:
    builder = self.builder
    line = self.line
    # Read the next list item.
    value_box = unsafe_index(
        builder,
        builder.read(self.expr_target, line),
        builder.read(self.index_target, line),
        line,
    )
    assert value_box
    # We coerce to the type of list elements here so that
    # iterating with tuple unpacking generates a tuple based
    # unpack instead of an iterator based one.
    builder.assign(
        builder.get_assignment_target(self.index),
        builder.coerce(value_box, self.target_type, line),
        line,
    )
</t>
<t tx="ekr.20240308084832.1363">def gen_step(self) -&gt; None:
    # Step to the next item.
    builder = self.builder
    line = self.line
    step = 1 if not self.reverse else -1
    add = builder.int_op(
        short_int_rprimitive,
        builder.read(self.index_target, line),
        Integer(step),
        IntOp.ADD,
        line,
    )
    builder.assign(self.index_target, add, line)
</t>
<t tx="ekr.20240308084832.1364">class ForDictionaryCommon(ForGenerator):
    """Generate optimized IR for a for loop over dictionary keys/values.
    
    The logic is pretty straightforward, we use PyDict_Next() API wrapped in
    a tuple, so that we can modify only a single register. The layout of the tuple:
      * f0: are there more items (bool)
      * f1: current offset (int)
      * f2: next key (object)
      * f3: next value (object)
    For more info see https://docs.python.org/3/c-api/dict.html#c.PyDict_Next.
    
    Note that for subclasses we fall back to generic PyObject_GetIter() logic,
    since they may override some iteration methods in subtly incompatible manner.
    The fallback logic is implemented in CPy.h via dynamic type check.
    """
    @others
</t>
<t tx="ekr.20240308084832.1365">dict_next_op: ClassVar[CFunctionDescription]
dict_iter_op: ClassVar[CFunctionDescription]

def need_cleanup(self) -&gt; bool:
    # Technically, a dict subclass can raise an unrelated exception
    # in __next__(), so we need this.
    return True
</t>
<t tx="ekr.20240308084832.1366">def init(self, expr_reg: Value, target_type: RType) -&gt; None:
    builder = self.builder
    self.target_type = target_type

    # We add some variables to environment class, so they can be read across yield.
    self.expr_target = builder.maybe_spill(expr_reg)
    offset = Integer(0)
    self.offset_target = builder.maybe_spill_assignable(offset)
    self.size = builder.maybe_spill(self.load_len(self.expr_target))

    # For dict class (not a subclass) this is the dictionary itself.
    iter_reg = builder.call_c(self.dict_iter_op, [expr_reg], self.line)
    self.iter_target = builder.maybe_spill(iter_reg)
</t>
<t tx="ekr.20240308084832.1367">def gen_condition(self) -&gt; None:
    """Get next key/value pair, set new offset, and check if we should continue."""
    builder = self.builder
    line = self.line
    self.next_tuple = self.builder.call_c(
        self.dict_next_op,
        [builder.read(self.iter_target, line), builder.read(self.offset_target, line)],
        line,
    )

    # Do this here instead of in gen_step() to minimize variables in environment.
    new_offset = builder.add(TupleGet(self.next_tuple, 1, line))
    builder.assign(self.offset_target, new_offset, line)

    should_continue = builder.add(TupleGet(self.next_tuple, 0, line))
    builder.add(Branch(should_continue, self.body_block, self.loop_exit, Branch.BOOL))
</t>
<t tx="ekr.20240308084832.1368">def gen_step(self) -&gt; None:
    """Check that dictionary didn't change size during iteration.

    Raise RuntimeError if it is not the case to match CPython behavior.
    """
    builder = self.builder
    line = self.line
    # Technically, we don't need a new primitive for this, but it is simpler.
    builder.call_c(
        dict_check_size_op,
        [builder.read(self.expr_target, line), builder.read(self.size, line)],
        line,
    )
</t>
<t tx="ekr.20240308084832.1369">def gen_cleanup(self) -&gt; None:
    # Same as for generic ForIterable.
    self.builder.call_c(no_err_occurred_op, [], self.line)
</t>
<t tx="ekr.20240308084832.137">def visit_call(self, op: Call) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1370">class ForDictionaryKeys(ForDictionaryCommon):
    """Generate optimized IR for a for loop over dictionary keys."""
    @others
</t>
<t tx="ekr.20240308084832.1371">dict_next_op = dict_next_key_op
dict_iter_op = dict_key_iter_op

def begin_body(self) -&gt; None:
    builder = self.builder
    line = self.line

    # Key is stored at the third place in the tuple.
    key = builder.add(TupleGet(self.next_tuple, 2, line))
    builder.assign(
        builder.get_assignment_target(self.index),
        builder.coerce(key, self.target_type, line),
        line,
    )
</t>
<t tx="ekr.20240308084832.1372">class ForDictionaryValues(ForDictionaryCommon):
    """Generate optimized IR for a for loop over dictionary values."""
    @others
</t>
<t tx="ekr.20240308084832.1373">dict_next_op = dict_next_value_op
dict_iter_op = dict_value_iter_op

def begin_body(self) -&gt; None:
    builder = self.builder
    line = self.line

    # Value is stored at the third place in the tuple.
    value = builder.add(TupleGet(self.next_tuple, 2, line))
    builder.assign(
        builder.get_assignment_target(self.index),
        builder.coerce(value, self.target_type, line),
        line,
    )
</t>
<t tx="ekr.20240308084832.1374">class ForDictionaryItems(ForDictionaryCommon):
    """Generate optimized IR for a for loop over dictionary items."""
    @others
</t>
<t tx="ekr.20240308084832.1375">dict_next_op = dict_next_item_op
dict_iter_op = dict_item_iter_op

def begin_body(self) -&gt; None:
    builder = self.builder
    line = self.line

    key = builder.add(TupleGet(self.next_tuple, 2, line))
    value = builder.add(TupleGet(self.next_tuple, 3, line))

    # Coerce just in case e.g. key is itself a tuple to be unpacked.
    assert isinstance(self.target_type, RTuple)
    key = builder.coerce(key, self.target_type.types[0], line)
    value = builder.coerce(value, self.target_type.types[1], line)

    target = builder.get_assignment_target(self.index)
    if isinstance(target, AssignmentTargetTuple):
        # Simpler code for common case: for k, v in d.items().
        if len(target.items) != 2:
            builder.error("Expected a pair for dict item iteration", line)
        builder.assign(target.items[0], key, line)
        builder.assign(target.items[1], value, line)
    else:
        rvalue = builder.add(TupleSet([key, value], line))
        builder.assign(target, rvalue, line)
</t>
<t tx="ekr.20240308084832.1376">class ForRange(ForGenerator):
    """Generate optimized IR for a for loop over an integer range."""
    @others
</t>
<t tx="ekr.20240308084832.1377">def init(self, start_reg: Value, end_reg: Value, step: int) -&gt; None:
    builder = self.builder
    self.start_reg = start_reg
    self.end_reg = end_reg
    self.step = step
    self.end_target = builder.maybe_spill(end_reg)
    if is_short_int_rprimitive(start_reg.type) and is_short_int_rprimitive(end_reg.type):
        index_type: RType = short_int_rprimitive
    elif is_fixed_width_rtype(end_reg.type):
        index_type = end_reg.type
    else:
        index_type = int_rprimitive
    index_reg = Register(index_type)
    builder.assign(index_reg, start_reg, -1)
    self.index_reg = builder.maybe_spill_assignable(index_reg)
    # Initialize loop index to 0. Assert that the index target is assignable.
    self.index_target: Register | AssignmentTarget = builder.get_assignment_target(self.index)
    builder.assign(self.index_target, builder.read(self.index_reg, self.line), self.line)
</t>
<t tx="ekr.20240308084832.1378">def gen_condition(self) -&gt; None:
    builder = self.builder
    line = self.line
    # Add loop condition check.
    cmp = "&lt;" if self.step &gt; 0 else "&gt;"
    comparison = builder.binary_op(
        builder.read(self.index_reg, line), builder.read(self.end_target, line), cmp, line
    )
    builder.add_bool_branch(comparison, self.body_block, self.loop_exit)
</t>
<t tx="ekr.20240308084832.1379">def gen_step(self) -&gt; None:
    builder = self.builder
    line = self.line

    # Increment index register. If the range is known to fit in short ints, use
    # short ints.
    if is_short_int_rprimitive(self.start_reg.type) and is_short_int_rprimitive(
        self.end_reg.type
    ):
        new_val = builder.int_op(
            short_int_rprimitive,
            builder.read(self.index_reg, line),
            Integer(self.step),
            IntOp.ADD,
            line,
        )

    else:
        new_val = builder.binary_op(
            builder.read(self.index_reg, line), Integer(self.step), "+", line
        )
    builder.assign(self.index_reg, new_val, line)
    builder.assign(self.index_target, new_val, line)
</t>
<t tx="ekr.20240308084832.138">def visit_method_call(self, op: MethodCall) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1380">class ForInfiniteCounter(ForGenerator):
    """Generate optimized IR for a for loop counting from 0 to infinity."""
    @others
</t>
<t tx="ekr.20240308084832.1381">def init(self) -&gt; None:
    builder = self.builder
    # Create a register to store the state of the loop index and
    # initialize this register along with the loop index to 0.
    zero = Integer(0)
    self.index_reg = builder.maybe_spill_assignable(zero)
    self.index_target: Register | AssignmentTarget = builder.get_assignment_target(self.index)
    builder.assign(self.index_target, zero, self.line)
</t>
<t tx="ekr.20240308084832.1382">def gen_step(self) -&gt; None:
    builder = self.builder
    line = self.line
    # We can safely assume that the integer is short, since we are not going to wrap
    # around a 63-bit integer.
    # NOTE: This would be questionable if short ints could be 32 bits.
    new_val = builder.int_op(
        short_int_rprimitive, builder.read(self.index_reg, line), Integer(1), IntOp.ADD, line
    )
    builder.assign(self.index_reg, new_val, line)
    builder.assign(self.index_target, new_val, line)
</t>
<t tx="ekr.20240308084832.1383">class ForEnumerate(ForGenerator):
    """Generate optimized IR for a for loop of form "for i, x in enumerate(it)"."""
    @others
</t>
<t tx="ekr.20240308084832.1384">def need_cleanup(self) -&gt; bool:
    # The wrapped for loop might need cleanup. This might generate a
    # redundant cleanup block, but that's okay.
    return True
</t>
<t tx="ekr.20240308084832.1385">def init(self, index1: Lvalue, index2: Lvalue, expr: Expression) -&gt; None:
    # Count from 0 to infinity (for the index lvalue).
    self.index_gen = ForInfiniteCounter(
        self.builder, index1, self.body_block, self.loop_exit, self.line, nested=True
    )
    self.index_gen.init()
    # Iterate over the actual iterable.
    self.main_gen = make_for_loop_generator(
        self.builder, index2, expr, self.body_block, self.loop_exit, self.line, nested=True
    )
</t>
<t tx="ekr.20240308084832.1386">def gen_condition(self) -&gt; None:
    # No need for a check for the index generator, since it's unconditional.
    self.main_gen.gen_condition()
</t>
<t tx="ekr.20240308084832.1387">def begin_body(self) -&gt; None:
    self.index_gen.begin_body()
    self.main_gen.begin_body()
</t>
<t tx="ekr.20240308084832.1388">def gen_step(self) -&gt; None:
    self.index_gen.gen_step()
    self.main_gen.gen_step()
</t>
<t tx="ekr.20240308084832.1389">def gen_cleanup(self) -&gt; None:
    self.index_gen.gen_cleanup()
    self.main_gen.gen_cleanup()
</t>
<t tx="ekr.20240308084832.139">def visit_load_error_value(self, op: LoadErrorValue) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1390">class ForZip(ForGenerator):
    """Generate IR for a for loop of form `for x, ... in zip(a, ...)`."""
    @others
</t>
<t tx="ekr.20240308084832.1391">def need_cleanup(self) -&gt; bool:
    # The wrapped for loops might need cleanup. We might generate a
    # redundant cleanup block, but that's okay.
    return True
</t>
<t tx="ekr.20240308084832.1392">def init(self, indexes: list[Lvalue], exprs: list[Expression]) -&gt; None:
    assert len(indexes) == len(exprs)
    # Condition check will require multiple basic blocks, since there will be
    # multiple conditions to check.
    self.cond_blocks = [BasicBlock() for _ in range(len(indexes) - 1)] + [self.body_block]
    self.gens: list[ForGenerator] = []
    for index, expr, next_block in zip(indexes, exprs, self.cond_blocks):
        gen = make_for_loop_generator(
            self.builder, index, expr, next_block, self.loop_exit, self.line, nested=True
        )
        self.gens.append(gen)
</t>
<t tx="ekr.20240308084832.1393">def gen_condition(self) -&gt; None:
    for i, gen in enumerate(self.gens):
        gen.gen_condition()
        if i &lt; len(self.gens) - 1:
            self.builder.activate_block(self.cond_blocks[i])
</t>
<t tx="ekr.20240308084832.1394">def begin_body(self) -&gt; None:
    for gen in self.gens:
        gen.begin_body()
</t>
<t tx="ekr.20240308084832.1395">def gen_step(self) -&gt; None:
    for gen in self.gens:
        gen.gen_step()
</t>
<t tx="ekr.20240308084832.1396">def gen_cleanup(self) -&gt; None:
    for gen in self.gens:
        gen.gen_cleanup()
</t>
<t tx="ekr.20240308084832.1397">"""Tokenizers for three string formatting methods"""

from __future__ import annotations

from enum import Enum, unique
from typing import Final

from mypy.checkstrformat import (
    ConversionSpecifier,
    parse_conversion_specifiers,
    parse_format_value,
)
from mypy.errors import Errors
from mypy.messages import MessageBuilder
from mypy.nodes import Context, Expression
from mypy.options import Options
from mypyc.ir.ops import Integer, Value
from mypyc.ir.rtypes import (
    c_pyssize_t_rprimitive,
    is_bytes_rprimitive,
    is_int_rprimitive,
    is_short_int_rprimitive,
    is_str_rprimitive,
)
from mypyc.irbuild.builder import IRBuilder
from mypyc.primitives.bytes_ops import bytes_build_op
from mypyc.primitives.int_ops import int_to_str_op
from mypyc.primitives.str_ops import str_build_op, str_op


@unique
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1398">class FormatOp(Enum):
    """FormatOp represents conversion operations of string formatting during
    compile time.

    Compare to ConversionSpecifier, FormatOp has fewer attributes.
    For example, to mark a conversion from any object to string,
    ConversionSpecifier may have several representations, like '%s', '{}'
    or '{:{}}'. However, there would only exist one corresponding FormatOp.
    """

    STR = "s"
    INT = "d"
    BYTES = "b"
</t>
<t tx="ekr.20240308084832.1399">def generate_format_ops(specifiers: list[ConversionSpecifier]) -&gt; list[FormatOp] | None:
    """Convert ConversionSpecifier to FormatOp.

    Different ConversionSpecifiers may share a same FormatOp.
    """
    format_ops = []
    for spec in specifiers:
        # TODO: Match specifiers instead of using whole_seq
        if spec.whole_seq == "%s" or spec.whole_seq == "{:{}}":
            format_op = FormatOp.STR
        elif spec.whole_seq == "%d":
            format_op = FormatOp.INT
        elif spec.whole_seq == "%b":
            format_op = FormatOp.BYTES
        elif spec.whole_seq:
            return None
        else:
            format_op = FormatOp.STR
        format_ops.append(format_op)
    return format_ops
</t>
<t tx="ekr.20240308084832.14">def include_dir() -&gt; str:
    """Find the path of the lib-rt dir that needs to be included"""
    return os.path.join(os.path.abspath(os.path.dirname(__file__)), "lib-rt")
</t>
<t tx="ekr.20240308084832.140">def visit_load_literal(self, op: LoadLiteral) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1400">def tokenizer_printf_style(format_str: str) -&gt; tuple[list[str], list[FormatOp]] | None:
    """Tokenize a printf-style format string using regex.

    Return:
        A list of string literals and a list of FormatOps.
    """
    literals: list[str] = []
    specifiers: list[ConversionSpecifier] = parse_conversion_specifiers(format_str)
    format_ops = generate_format_ops(specifiers)
    if format_ops is None:
        return None

    last_end = 0
    for spec in specifiers:
        cur_start = spec.start_pos
        literals.append(format_str[last_end:cur_start])
        last_end = cur_start + len(spec.whole_seq)
    literals.append(format_str[last_end:])

    return literals, format_ops
</t>
<t tx="ekr.20240308084832.1401"># The empty Context as an argument for parse_format_value().
# It wouldn't be used since the code has passed the type-checking.
EMPTY_CONTEXT: Final = Context()


def tokenizer_format_call(format_str: str) -&gt; tuple[list[str], list[FormatOp]] | None:
    """Tokenize a str.format() format string.

    The core function parse_format_value() is shared with mypy.
    With these specifiers, we then parse the literal substrings
    of the original format string and convert `ConversionSpecifier`
    to `FormatOp`.

    Return:
        A list of string literals and a list of FormatOps. The literals
        are interleaved with FormatOps and the length of returned literals
        should be exactly one more than FormatOps.
        Return None if it cannot parse the string.
    """
    # Creates an empty MessageBuilder here.
    # It wouldn't be used since the code has passed the type-checking.
    specifiers = parse_format_value(
        format_str, EMPTY_CONTEXT, MessageBuilder(Errors(Options()), {})
    )
    if specifiers is None:
        return None
    format_ops = generate_format_ops(specifiers)
    if format_ops is None:
        return None

    literals: list[str] = []
    last_end = 0
    for spec in specifiers:
        # Skip { and }
        literals.append(format_str[last_end : spec.start_pos - 1])
        last_end = spec.start_pos + len(spec.whole_seq) + 1
    literals.append(format_str[last_end:])
    # Deal with escaped {{
    literals = [x.replace("{{", "{").replace("}}", "}") for x in literals]

    return literals, format_ops
</t>
<t tx="ekr.20240308084832.1402">def convert_format_expr_to_str(
    builder: IRBuilder, format_ops: list[FormatOp], exprs: list[Expression], line: int
) -&gt; list[Value] | None:
    """Convert expressions into string literal objects with the guidance
    of FormatOps. Return None when fails."""
    if len(format_ops) != len(exprs):
        return None

    converted = []
    for x, format_op in zip(exprs, format_ops):
        node_type = builder.node_type(x)
        if format_op == FormatOp.STR:
            if is_str_rprimitive(node_type):
                var_str = builder.accept(x)
            elif is_int_rprimitive(node_type) or is_short_int_rprimitive(node_type):
                var_str = builder.call_c(int_to_str_op, [builder.accept(x)], line)
            else:
                var_str = builder.call_c(str_op, [builder.accept(x)], line)
        elif format_op == FormatOp.INT:
            if is_int_rprimitive(node_type) or is_short_int_rprimitive(node_type):
                var_str = builder.call_c(int_to_str_op, [builder.accept(x)], line)
            else:
                return None
        else:
            return None
        converted.append(var_str)
    return converted
</t>
<t tx="ekr.20240308084832.1403">def join_formatted_strings(
    builder: IRBuilder, literals: list[str] | None, substitutions: list[Value], line: int
) -&gt; Value:
    """Merge the list of literals and the list of substitutions
    alternatively using 'str_build_op'.

    `substitutions` is the result value of formatting conversions.

    If the `literals` is set to None, we simply join the substitutions;
    Otherwise, the `literals` is the literal substrings of the original
    format string and its length should be exactly one more than
    substitutions.

    For example:
    (1)    'This is a %s and the value is %d'
        -&gt; literals: ['This is a ', ' and the value is', '']
    (2)    '{} and the value is {}'
        -&gt; literals: ['', ' and the value is', '']
    """
    # The first parameter for str_build_op is the total size of
    # the following PyObject*
    result_list: list[Value] = [Integer(0, c_pyssize_t_rprimitive)]

    if literals is not None:
        for a, b in zip(literals, substitutions):
            if a:
                result_list.append(builder.load_str(a))
            result_list.append(b)
        if literals[-1]:
            result_list.append(builder.load_str(literals[-1]))
    else:
        result_list.extend(substitutions)

    # Special case for empty string and literal string
    if len(result_list) == 1:
        return builder.load_str("")
    if not substitutions and len(result_list) == 2:
        return result_list[1]

    result_list[0] = Integer(len(result_list) - 1, c_pyssize_t_rprimitive)
    return builder.call_c(str_build_op, result_list, line)
</t>
<t tx="ekr.20240308084832.1404">def convert_format_expr_to_bytes(
    builder: IRBuilder, format_ops: list[FormatOp], exprs: list[Expression], line: int
) -&gt; list[Value] | None:
    """Convert expressions into bytes literal objects with the guidance
    of FormatOps. Return None when fails."""
    if len(format_ops) != len(exprs):
        return None

    converted = []
    for x, format_op in zip(exprs, format_ops):
        node_type = builder.node_type(x)
        # conversion type 's' is an alias of 'b' in bytes formatting
        if format_op == FormatOp.BYTES or format_op == FormatOp.STR:
            if is_bytes_rprimitive(node_type):
                var_bytes = builder.accept(x)
            else:
                return None
        else:
            return None
        converted.append(var_bytes)
    return converted
</t>
<t tx="ekr.20240308084832.1405">def join_formatted_bytes(
    builder: IRBuilder, literals: list[str], substitutions: list[Value], line: int
) -&gt; Value:
    """Merge the list of literals and the list of substitutions
    alternatively using 'bytes_build_op'."""
    result_list: list[Value] = [Integer(0, c_pyssize_t_rprimitive)]

    for a, b in zip(literals, substitutions):
        if a:
            result_list.append(builder.load_bytes_from_str_literal(a))
        result_list.append(b)
    if literals[-1]:
        result_list.append(builder.load_bytes_from_str_literal(literals[-1]))

    # Special case for empty bytes and literal
    if len(result_list) == 1:
        return builder.load_bytes_from_str_literal("")
    if not substitutions and len(result_list) == 2:
        return result_list[1]

    result_list[0] = Integer(len(result_list) - 1, c_pyssize_t_rprimitive)
    return builder.call_c(bytes_build_op, result_list, line)
</t>
<t tx="ekr.20240308084832.1406">"""Transform mypy AST functions to IR (and related things).

Normal functions are translated into a list of basic blocks
containing various IR ops (defined in mypyc.ir.ops).

This also deals with generators, async functions and nested
functions. All of these are transformed into callable classes. These
have a custom __call__ method that implements the call, and state, such
as an environment containing non-local variables, is stored in the
instance of the callable class.
"""

from __future__ import annotations

from collections import defaultdict
from typing import NamedTuple, Sequence

from mypy.nodes import (
    ArgKind,
    ClassDef,
    Decorator,
    FuncBase,
    FuncDef,
    FuncItem,
    LambdaExpr,
    OverloadedFuncDef,
    SymbolNode,
    TypeInfo,
    Var,
)
from mypy.types import CallableType, get_proper_type
from mypyc.common import LAMBDA_NAME, PROPSET_PREFIX, SELF_NAME
from mypyc.ir.class_ir import ClassIR, NonExtClassInfo
from mypyc.ir.func_ir import (
    FUNC_CLASSMETHOD,
    FUNC_NORMAL,
    FUNC_STATICMETHOD,
    FuncDecl,
    FuncIR,
    FuncSignature,
    RuntimeArg,
)
from mypyc.ir.ops import (
    BasicBlock,
    GetAttr,
    InitStatic,
    Integer,
    LoadAddress,
    LoadLiteral,
    Register,
    Return,
    SetAttr,
    Unbox,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import (
    RInstance,
    bool_rprimitive,
    dict_rprimitive,
    int_rprimitive,
    object_rprimitive,
)
from mypyc.irbuild.builder import IRBuilder, SymbolTarget, gen_arg_defaults
from mypyc.irbuild.callable_class import (
    add_call_to_callable_class,
    add_get_to_callable_class,
    instantiate_callable_class,
    setup_callable_class,
)
from mypyc.irbuild.context import FuncInfo, ImplicitClass
from mypyc.irbuild.env_class import (
    finalize_env_class,
    load_env_registers,
    load_outer_envs,
    setup_env_class,
    setup_func_for_recursive_call,
)
from mypyc.irbuild.generator import (
    add_methods_to_generator_class,
    add_raise_exception_blocks_to_generator_class,
    create_switch_for_generator_class,
    gen_generator_func,
    populate_switch_for_generator_class,
    setup_env_for_generator_class,
)
from mypyc.irbuild.targets import AssignmentTarget
from mypyc.irbuild.util import is_constant
from mypyc.primitives.dict_ops import dict_get_method_with_none, dict_new_op, dict_set_item_op
from mypyc.primitives.generic_ops import py_setattr_op
from mypyc.primitives.misc_ops import register_function
from mypyc.primitives.registry import builtin_names
from mypyc.sametype import is_same_method_signature, is_same_type

# Top-level transform functions


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1407">def transform_func_def(builder: IRBuilder, fdef: FuncDef) -&gt; None:
    func_ir, func_reg = gen_func_item(builder, fdef, fdef.name, builder.mapper.fdef_to_sig(fdef))

    # If the function that was visited was a nested function, then either look it up in our
    # current environment or define it if it was not already defined.
    if func_reg:
        builder.assign(get_func_target(builder, fdef), func_reg, fdef.line)
    maybe_insert_into_registry_dict(builder, fdef)
    builder.add_function(func_ir, fdef.line)
</t>
<t tx="ekr.20240308084832.1408">def transform_overloaded_func_def(builder: IRBuilder, o: OverloadedFuncDef) -&gt; None:
    # Handle regular overload case
    assert o.impl
    builder.accept(o.impl)
</t>
<t tx="ekr.20240308084832.1409">def transform_decorator(builder: IRBuilder, dec: Decorator) -&gt; None:
    func_ir, func_reg = gen_func_item(
        builder, dec.func, dec.func.name, builder.mapper.fdef_to_sig(dec.func)
    )
    decorated_func: Value | None = None
    if func_reg:
        decorated_func = load_decorated_func(builder, dec.func, func_reg)
        builder.assign(get_func_target(builder, dec.func), decorated_func, dec.func.line)
    # If the prebuild pass didn't put this function in the function to decorators map (for example
    # if this is a registered singledispatch implementation with no other decorators), we should
    # treat this function as a regular function, not a decorated function
    elif dec.func in builder.fdefs_to_decorators:
        # Obtain the function name in order to construct the name of the helper function.
        name = dec.func.fullname.split(".")[-1]

        # Load the callable object representing the non-decorated function, and decorate it.
        orig_func = builder.load_global_str(name, dec.line)
        decorated_func = load_decorated_func(builder, dec.func, orig_func)

    if decorated_func is not None:
        # Set the callable object representing the decorated function as a global.
        builder.call_c(
            dict_set_item_op,
            [builder.load_globals_dict(), builder.load_str(dec.func.name), decorated_func],
            decorated_func.line,
        )

    maybe_insert_into_registry_dict(builder, dec.func)

    builder.functions.append(func_ir)
</t>
<t tx="ekr.20240308084832.141">def visit_get_attr(self, op: GetAttr) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1410">def transform_lambda_expr(builder: IRBuilder, expr: LambdaExpr) -&gt; Value:
    typ = get_proper_type(builder.types[expr])
    assert isinstance(typ, CallableType)

    runtime_args = []
    for arg, arg_type in zip(expr.arguments, typ.arg_types):
        arg.variable.type = arg_type
        runtime_args.append(
            RuntimeArg(arg.variable.name, builder.type_to_rtype(arg_type), arg.kind)
        )
    ret_type = builder.type_to_rtype(typ.ret_type)

    fsig = FuncSignature(runtime_args, ret_type)

    fname = f"{LAMBDA_NAME}{builder.lambda_counter}"
    builder.lambda_counter += 1
    func_ir, func_reg = gen_func_item(builder, expr, fname, fsig)
    assert func_reg is not None

    builder.functions.append(func_ir)
    return func_reg
</t>
<t tx="ekr.20240308084832.1411"># Internal functions


def gen_func_item(
    builder: IRBuilder,
    fitem: FuncItem,
    name: str,
    sig: FuncSignature,
    cdef: ClassDef | None = None,
) -&gt; tuple[FuncIR, Value | None]:
    """Generate and return the FuncIR for a given FuncDef.

    If the given FuncItem is a nested function, then we generate a
    callable class representing the function and use that instead of
    the actual function. if the given FuncItem contains a nested
    function, then we generate an environment class so that inner
    nested functions can access the environment of the given FuncDef.

    Consider the following nested function:

        def a() -&gt; None:
            def b() -&gt; None:
                def c() -&gt; None:
                    return None
                return None
            return None

    The classes generated would look something like the following.

                has pointer to        +-------+
        +--------------------------&gt;  | a_env |
        |                             +-------+
        |                                 ^
        |                                 | has pointer to
    +-------+     associated with     +-------+
    | b_obj |   -------------------&gt;  | b_env |
    +-------+                         +-------+
                                          ^
                                          |
    +-------+         has pointer to      |
    | c_obj |   --------------------------+
    +-------+
    """

    # TODO: do something about abstract methods.

    func_reg: Value | None = None

    # We treat lambdas as always being nested because we always generate
    # a class for lambdas, no matter where they are. (It would probably also
    # work to special case toplevel lambdas and generate a non-class function.)
    is_nested = fitem in builder.nested_fitems or isinstance(fitem, LambdaExpr)
    contains_nested = fitem in builder.encapsulating_funcs.keys()
    is_decorated = fitem in builder.fdefs_to_decorators
    is_singledispatch = fitem in builder.singledispatch_impls
    in_non_ext = False
    add_nested_funcs_to_env = has_nested_func_self_reference(builder, fitem)
    class_name = None
    if cdef:
        ir = builder.mapper.type_to_ir[cdef.info]
        in_non_ext = not ir.is_ext_class
        class_name = cdef.name

    if is_singledispatch:
        func_name = singledispatch_main_func_name(name)
    else:
        func_name = name
    builder.enter(
        FuncInfo(
            fitem=fitem,
            name=func_name,
            class_name=class_name,
            namespace=gen_func_ns(builder),
            is_nested=is_nested,
            contains_nested=contains_nested,
            is_decorated=is_decorated,
            in_non_ext=in_non_ext,
            add_nested_funcs_to_env=add_nested_funcs_to_env,
        )
    )

    # Functions that contain nested functions need an environment class to store variables that
    # are free in their nested functions. Generator functions need an environment class to
    # store a variable denoting the next instruction to be executed when the __next__ function
    # is called, along with all the variables inside the function itself.
    if builder.fn_info.contains_nested or builder.fn_info.is_generator:
        setup_env_class(builder)

    if builder.fn_info.is_nested or builder.fn_info.in_non_ext:
        setup_callable_class(builder)

    if builder.fn_info.is_generator:
        # Do a first-pass and generate a function that just returns a generator object.
        gen_generator_func(builder)
        args, _, blocks, ret_type, fn_info = builder.leave()
        func_ir, func_reg = gen_func_ir(
            builder, args, blocks, sig, fn_info, cdef, is_singledispatch
        )

        # Re-enter the FuncItem and visit the body of the function this time.
        builder.enter(fn_info)
        setup_env_for_generator_class(builder)
        load_outer_envs(builder, builder.fn_info.generator_class)
        top_level = builder.top_level_fn_info()
        if (
            builder.fn_info.is_nested
            and isinstance(fitem, FuncDef)
            and top_level
            and top_level.add_nested_funcs_to_env
        ):
            setup_func_for_recursive_call(builder, fitem, builder.fn_info.generator_class)
        create_switch_for_generator_class(builder)
        add_raise_exception_blocks_to_generator_class(builder, fitem.line)
    else:
        load_env_registers(builder)
        gen_arg_defaults(builder)

    if builder.fn_info.contains_nested and not builder.fn_info.is_generator:
        finalize_env_class(builder)

    builder.ret_types[-1] = sig.ret_type

    # Add all variables and functions that are declared/defined within this
    # function and are referenced in functions nested within this one to this
    # function's environment class so the nested functions can reference
    # them even if they are declared after the nested function's definition.
    # Note that this is done before visiting the body of this function.

    env_for_func: FuncInfo | ImplicitClass = builder.fn_info
    if builder.fn_info.is_generator:
        env_for_func = builder.fn_info.generator_class
    elif builder.fn_info.is_nested or builder.fn_info.in_non_ext:
        env_for_func = builder.fn_info.callable_class

    if builder.fn_info.fitem in builder.free_variables:
        # Sort the variables to keep things deterministic
        for var in sorted(builder.free_variables[builder.fn_info.fitem], key=lambda x: x.name):
            if isinstance(var, Var):
                rtype = builder.type_to_rtype(var.type)
                builder.add_var_to_env_class(var, rtype, env_for_func, reassign=False)

    if builder.fn_info.fitem in builder.encapsulating_funcs:
        for nested_fn in builder.encapsulating_funcs[builder.fn_info.fitem]:
            if isinstance(nested_fn, FuncDef):
                # The return type is 'object' instead of an RInstance of the
                # callable class because differently defined functions with
                # the same name and signature across conditional blocks
                # will generate different callable classes, so the callable
                # class that gets instantiated must be generic.
                builder.add_var_to_env_class(
                    nested_fn, object_rprimitive, env_for_func, reassign=False
                )

    builder.accept(fitem.body)
    builder.maybe_add_implicit_return()

    if builder.fn_info.is_generator:
        populate_switch_for_generator_class(builder)

    # Hang on to the local symbol table for a while, since we use it
    # to calculate argument defaults below.
    symtable = builder.symtables[-1]

    args, _, blocks, ret_type, fn_info = builder.leave()

    if fn_info.is_generator:
        add_methods_to_generator_class(builder, fn_info, sig, args, blocks, fitem.is_coroutine)
    else:
        func_ir, func_reg = gen_func_ir(
            builder, args, blocks, sig, fn_info, cdef, is_singledispatch
        )

    # Evaluate argument defaults in the surrounding scope, since we
    # calculate them *once* when the function definition is evaluated.
    calculate_arg_defaults(builder, fn_info, func_reg, symtable)

    if is_singledispatch:
        # add the generated main singledispatch function
        builder.functions.append(func_ir)
        # create the dispatch function
        assert isinstance(fitem, FuncDef)
        return gen_dispatch_func_ir(builder, fitem, fn_info.name, name, sig)

    return func_ir, func_reg
</t>
<t tx="ekr.20240308084832.1412">def has_nested_func_self_reference(builder: IRBuilder, fitem: FuncItem) -&gt; bool:
    """Does a nested function contain a self-reference in its body?

    If a nested function only has references in the surrounding function,
    we don't need to add it to the environment.
    """
    if any(isinstance(sym, FuncBase) for sym in builder.free_variables.get(fitem, set())):
        return True
    return any(
        has_nested_func_self_reference(builder, nested)
        for nested in builder.encapsulating_funcs.get(fitem, [])
    )
</t>
<t tx="ekr.20240308084832.1413">def gen_func_ir(
    builder: IRBuilder,
    args: list[Register],
    blocks: list[BasicBlock],
    sig: FuncSignature,
    fn_info: FuncInfo,
    cdef: ClassDef | None,
    is_singledispatch_main_func: bool = False,
) -&gt; tuple[FuncIR, Value | None]:
    """Generate the FuncIR for a function.

    This takes the basic blocks and function info of a particular
    function and returns the IR. If the function is nested,
    also returns the register containing the instance of the
    corresponding callable class.
    """
    func_reg: Value | None = None
    if fn_info.is_nested or fn_info.in_non_ext:
        func_ir = add_call_to_callable_class(builder, args, blocks, sig, fn_info)
        add_get_to_callable_class(builder, fn_info)
        func_reg = instantiate_callable_class(builder, fn_info)
    else:
        assert isinstance(fn_info.fitem, FuncDef)
        func_decl = builder.mapper.func_to_decl[fn_info.fitem]
        if fn_info.is_decorated or is_singledispatch_main_func:
            class_name = None if cdef is None else cdef.name
            func_decl = FuncDecl(
                fn_info.name,
                class_name,
                builder.module_name,
                sig,
                func_decl.kind,
                func_decl.is_prop_getter,
                func_decl.is_prop_setter,
            )
            func_ir = FuncIR(
                func_decl, args, blocks, fn_info.fitem.line, traceback_name=fn_info.fitem.name
            )
        else:
            func_ir = FuncIR(
                func_decl, args, blocks, fn_info.fitem.line, traceback_name=fn_info.fitem.name
            )
    return (func_ir, func_reg)
</t>
<t tx="ekr.20240308084832.1414">def handle_ext_method(builder: IRBuilder, cdef: ClassDef, fdef: FuncDef) -&gt; None:
    # Perform the function of visit_method for methods inside extension classes.
    name = fdef.name
    class_ir = builder.mapper.type_to_ir[cdef.info]
    func_ir, func_reg = gen_func_item(builder, fdef, name, builder.mapper.fdef_to_sig(fdef), cdef)
    builder.functions.append(func_ir)

    if is_decorated(builder, fdef):
        # Obtain the function name in order to construct the name of the helper function.
        _, _, name = fdef.fullname.rpartition(".")
        # Read the PyTypeObject representing the class, get the callable object
        # representing the non-decorated method
        typ = builder.load_native_type_object(cdef.fullname)
        orig_func = builder.py_get_attr(typ, name, fdef.line)

        # Decorate the non-decorated method
        decorated_func = load_decorated_func(builder, fdef, orig_func)

        # Set the callable object representing the decorated method as an attribute of the
        # extension class.
        builder.call_c(py_setattr_op, [typ, builder.load_str(name), decorated_func], fdef.line)

    if fdef.is_property:
        # If there is a property setter, it will be processed after the getter,
        # We populate the optional setter field with none for now.
        assert name not in class_ir.properties
        class_ir.properties[name] = (func_ir, None)

    elif fdef in builder.prop_setters:
        # The respective property getter must have been processed already
        assert name in class_ir.properties
        getter_ir, _ = class_ir.properties[name]
        class_ir.properties[name] = (getter_ir, func_ir)

    class_ir.methods[func_ir.decl.name] = func_ir

    # If this overrides a parent class method with a different type, we need
    # to generate a glue method to mediate between them.
    for base in class_ir.mro[1:]:
        if (
            name in base.method_decls
            and name != "__init__"
            and not is_same_method_signature(
                class_ir.method_decls[name].sig, base.method_decls[name].sig
            )
        ):
            # TODO: Support contravariant subtyping in the input argument for
            # property setters. Need to make a special glue method for handling this,
            # similar to gen_glue_property.

            f = gen_glue(builder, base.method_decls[name].sig, func_ir, class_ir, base, fdef)
            class_ir.glue_methods[(base, name)] = f
            builder.functions.append(f)

    # If the class allows interpreted children, create glue
    # methods that dispatch via the Python API. These will go in a
    # "shadow vtable" that will be assigned to interpreted
    # children.
    if class_ir.allow_interpreted_subclasses:
        f = gen_glue(builder, func_ir.sig, func_ir, class_ir, class_ir, fdef, do_py_ops=True)
        class_ir.glue_methods[(class_ir, name)] = f
        builder.functions.append(f)
</t>
<t tx="ekr.20240308084832.1415">def handle_non_ext_method(
    builder: IRBuilder, non_ext: NonExtClassInfo, cdef: ClassDef, fdef: FuncDef
) -&gt; None:
    # Perform the function of visit_method for methods inside non-extension classes.
    name = fdef.name
    func_ir, func_reg = gen_func_item(builder, fdef, name, builder.mapper.fdef_to_sig(fdef), cdef)
    assert func_reg is not None
    builder.functions.append(func_ir)

    if is_decorated(builder, fdef):
        # The undecorated method is a generated callable class
        orig_func = func_reg
        func_reg = load_decorated_func(builder, fdef, orig_func)

    # TODO: Support property setters in non-extension classes
    if fdef.is_property:
        prop = builder.load_module_attr_by_fullname("builtins.property", fdef.line)
        func_reg = builder.py_call(prop, [func_reg], fdef.line)

    elif builder.mapper.func_to_decl[fdef].kind == FUNC_CLASSMETHOD:
        cls_meth = builder.load_module_attr_by_fullname("builtins.classmethod", fdef.line)
        func_reg = builder.py_call(cls_meth, [func_reg], fdef.line)

    elif builder.mapper.func_to_decl[fdef].kind == FUNC_STATICMETHOD:
        stat_meth = builder.load_module_attr_by_fullname("builtins.staticmethod", fdef.line)
        func_reg = builder.py_call(stat_meth, [func_reg], fdef.line)

    builder.add_to_non_ext_dict(non_ext, name, func_reg, fdef.line)
</t>
<t tx="ekr.20240308084832.1416">def calculate_arg_defaults(
    builder: IRBuilder,
    fn_info: FuncInfo,
    func_reg: Value | None,
    symtable: dict[SymbolNode, SymbolTarget],
) -&gt; None:
    """Calculate default argument values and store them.

    They are stored in statics for top level functions and in
    the function objects for nested functions (while constants are
    still stored computed on demand).
    """
    fitem = fn_info.fitem
    for arg in fitem.arguments:
        # Constant values don't get stored but just recomputed
        if arg.initializer and not is_constant(arg.initializer):
            value = builder.coerce(
                builder.accept(arg.initializer), symtable[arg.variable].type, arg.line
            )
            if not fn_info.is_nested:
                name = fitem.fullname + "." + arg.variable.name
                builder.add(InitStatic(value, name, builder.module_name))
            else:
                assert func_reg is not None
                builder.add(SetAttr(func_reg, arg.variable.name, value, arg.line))
</t>
<t tx="ekr.20240308084832.1417">def gen_func_ns(builder: IRBuilder) -&gt; str:
    """Generate a namespace for a nested function using its outer function names."""
    return "_".join(
        info.name + ("" if not info.class_name else "_" + info.class_name)
        for info in builder.fn_infos
        if info.name and info.name != "&lt;module&gt;"
    )
</t>
<t tx="ekr.20240308084832.1418">def load_decorated_func(builder: IRBuilder, fdef: FuncDef, orig_func_reg: Value) -&gt; Value:
    """Apply decorators to a function.

    Given a decorated FuncDef and an instance of the callable class
    representing that FuncDef, apply the corresponding decorator
    functions on that decorated FuncDef and return the decorated
    function.
    """
    if not is_decorated(builder, fdef):
        # If there are no decorators associated with the function, then just return the
        # original function.
        return orig_func_reg

    decorators = builder.fdefs_to_decorators[fdef]
    func_reg = orig_func_reg
    for d in reversed(decorators):
        decorator = d.accept(builder.visitor)
        assert isinstance(decorator, Value)
        func_reg = builder.py_call(decorator, [func_reg], func_reg.line)
    return func_reg
</t>
<t tx="ekr.20240308084832.1419">def is_decorated(builder: IRBuilder, fdef: FuncDef) -&gt; bool:
    return fdef in builder.fdefs_to_decorators
</t>
<t tx="ekr.20240308084832.142">def visit_set_attr(self, op: SetAttr) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1420">def gen_glue(
    builder: IRBuilder,
    base_sig: FuncSignature,
    target: FuncIR,
    cls: ClassIR,
    base: ClassIR,
    fdef: FuncItem,
    *,
    do_py_ops: bool = False,
) -&gt; FuncIR:
    """Generate glue methods that mediate between different method types in subclasses.

    Works on both properties and methods. See gen_glue_methods below
    for more details.

    If do_py_ops is True, then the glue methods should use generic
    C API operations instead of direct calls, to enable generating
    "shadow" glue methods that work with interpreted subclasses.
    """
    if fdef.is_property:
        return gen_glue_property(builder, base_sig, target, cls, base, fdef.line, do_py_ops)
    else:
        return gen_glue_method(builder, base_sig, target, cls, base, fdef.line, do_py_ops)
</t>
<t tx="ekr.20240308084832.1421">class ArgInfo(NamedTuple):
    args: list[Value]
    arg_names: list[str | None]
    arg_kinds: list[ArgKind]
</t>
<t tx="ekr.20240308084832.1422">def get_args(builder: IRBuilder, rt_args: Sequence[RuntimeArg], line: int) -&gt; ArgInfo:
    # The environment operates on Vars, so we make some up
    fake_vars = [(Var(arg.name), arg.type) for arg in rt_args]
    args = [
        builder.read(builder.add_local_reg(var, type, is_arg=True), line)
        for var, type in fake_vars
    ]
    arg_names = [
        arg.name if arg.kind.is_named() or (arg.kind.is_optional() and not arg.pos_only) else None
        for arg in rt_args
    ]
    arg_kinds = [arg.kind for arg in rt_args]
    return ArgInfo(args, arg_names, arg_kinds)
</t>
<t tx="ekr.20240308084832.1423">def gen_glue_method(
    builder: IRBuilder,
    base_sig: FuncSignature,
    target: FuncIR,
    cls: ClassIR,
    base: ClassIR,
    line: int,
    do_pycall: bool,
) -&gt; FuncIR:
    """Generate glue methods that mediate between different method types in subclasses.

    For example, if we have:

    class A:
        def f(builder: IRBuilder, x: int) -&gt; object: ...

    then it is totally permissible to have a subclass

    class B(A):
        def f(builder: IRBuilder, x: object) -&gt; int: ...

    since '(object) -&gt; int' is a subtype of '(int) -&gt; object' by the usual
    contra/co-variant function subtyping rules.

    The trickiness here is that int and object have different
    runtime representations in mypyc, so A.f and B.f have
    different signatures at the native C level. To deal with this,
    we need to generate glue methods that mediate between the
    different versions by coercing the arguments and return
    values.

    If do_pycall is True, then make the call using the C API
    instead of a native call.
    """
    check_native_override(builder, base_sig, target.decl.sig, line)

    builder.enter()
    builder.ret_types[-1] = base_sig.ret_type

    rt_args = list(base_sig.args)
    if target.decl.kind == FUNC_NORMAL:
        rt_args[0] = RuntimeArg(base_sig.args[0].name, RInstance(cls))

    arg_info = get_args(builder, rt_args, line)
    args, arg_kinds, arg_names = arg_info.args, arg_info.arg_kinds, arg_info.arg_names

    bitmap_args = None
    if base_sig.num_bitmap_args:
        args = args[: -base_sig.num_bitmap_args]
        arg_kinds = arg_kinds[: -base_sig.num_bitmap_args]
        arg_names = arg_names[: -base_sig.num_bitmap_args]
        bitmap_args = list(builder.builder.args[-base_sig.num_bitmap_args :])

    # We can do a passthrough *args/**kwargs with a native call, but if the
    # args need to get distributed out to arguments, we just let python handle it
    if any(kind.is_star() for kind in arg_kinds) and any(
        not arg.kind.is_star() for arg in target.decl.sig.args
    ):
        do_pycall = True

    if do_pycall:
        if target.decl.kind == FUNC_STATICMETHOD:
            # FIXME: this won't work if we can do interpreted subclasses
            first = builder.builder.get_native_type(cls)
            st = 0
        else:
            first = args[0]
            st = 1
        retval = builder.builder.py_method_call(
            first, target.name, args[st:], line, arg_kinds[st:], arg_names[st:]
        )
    else:
        retval = builder.builder.call(
            target.decl, args, arg_kinds, arg_names, line, bitmap_args=bitmap_args
        )
    retval = builder.coerce(retval, base_sig.ret_type, line)
    builder.add(Return(retval))

    arg_regs, _, blocks, ret_type, _ = builder.leave()
    if base_sig.num_bitmap_args:
        rt_args = rt_args[: -base_sig.num_bitmap_args]
    return FuncIR(
        FuncDecl(
            target.name + "__" + base.name + "_glue",
            cls.name,
            builder.module_name,
            FuncSignature(rt_args, ret_type),
            target.decl.kind,
        ),
        arg_regs,
        blocks,
    )
</t>
<t tx="ekr.20240308084832.1424">def check_native_override(
    builder: IRBuilder, base_sig: FuncSignature, sub_sig: FuncSignature, line: int
) -&gt; None:
    """Report an error if an override changes signature in unsupported ways.

    Glue methods can work around many signature changes but not all of them.
    """
    for base_arg, sub_arg in zip(base_sig.real_args(), sub_sig.real_args()):
        if base_arg.type.error_overlap:
            if not base_arg.optional and sub_arg.optional and base_sig.num_bitmap_args:
                # This would change the meanings of bits in the argument defaults
                # bitmap, which we don't support. We'd need to do tricky bit
                # manipulations to support this generally.
                builder.error(
                    "An argument with type "
                    + f'"{base_arg.type}" cannot be given a default value in a method override',
                    line,
                )
        if base_arg.type.error_overlap or sub_arg.type.error_overlap:
            if not is_same_type(base_arg.type, sub_arg.type):
                # This would change from signaling a default via an error value to
                # signaling a default via bitmap, which we don't support.
                builder.error(
                    "Incompatible argument type "
                    + f'"{sub_arg.type}" (base class has type "{base_arg.type}")',
                    line,
                )
</t>
<t tx="ekr.20240308084832.1425">def gen_glue_property(
    builder: IRBuilder,
    sig: FuncSignature,
    target: FuncIR,
    cls: ClassIR,
    base: ClassIR,
    line: int,
    do_pygetattr: bool,
) -&gt; FuncIR:
    """Generate glue methods for properties that mediate between different subclass types.

    Similarly to methods, properties of derived types can be covariantly subtyped. Thus,
    properties also require glue. However, this only requires the return type to change.
    Further, instead of a method call, an attribute get is performed.

    If do_pygetattr is True, then get the attribute using the Python C
    API instead of a native call.
    """
    builder.enter()

    rt_arg = RuntimeArg(SELF_NAME, RInstance(cls))
    self_target = builder.add_self_to_env(cls)
    arg = builder.read(self_target, line)
    builder.ret_types[-1] = sig.ret_type
    if do_pygetattr:
        retval = builder.py_get_attr(arg, target.name, line)
    else:
        retval = builder.add(GetAttr(arg, target.name, line))
    retbox = builder.coerce(retval, sig.ret_type, line)
    builder.add(Return(retbox))

    args, _, blocks, return_type, _ = builder.leave()
    return FuncIR(
        FuncDecl(
            target.name + "__" + base.name + "_glue",
            cls.name,
            builder.module_name,
            FuncSignature([rt_arg], return_type),
        ),
        args,
        blocks,
    )
</t>
<t tx="ekr.20240308084832.1426">def get_func_target(builder: IRBuilder, fdef: FuncDef) -&gt; AssignmentTarget:
    """Given a FuncDef, return the target for the instance of its callable class.

    If the function was not already defined somewhere, then define it
    and add it to the current environment.
    """
    if fdef.original_def:
        # Get the target associated with the previously defined FuncDef.
        return builder.lookup(fdef.original_def)

    if builder.fn_info.is_generator or builder.fn_info.add_nested_funcs_to_env:
        return builder.lookup(fdef)

    return builder.add_local_reg(fdef, object_rprimitive)
</t>
<t tx="ekr.20240308084832.1427">def load_type(builder: IRBuilder, typ: TypeInfo, line: int) -&gt; Value:
    if typ in builder.mapper.type_to_ir:
        class_ir = builder.mapper.type_to_ir[typ]
        class_obj = builder.builder.get_native_type(class_ir)
    elif typ.fullname in builtin_names:
        builtin_addr_type, src = builtin_names[typ.fullname]
        class_obj = builder.add(LoadAddress(builtin_addr_type, src, line))
    else:
        class_obj = builder.load_global_str(typ.name, line)

    return class_obj
</t>
<t tx="ekr.20240308084832.1428">def load_func(builder: IRBuilder, func_name: str, fullname: str | None, line: int) -&gt; Value:
    if fullname and not fullname.startswith(builder.current_module):
        # we're calling a function in a different module

        # We can't use load_module_attr_by_fullname here because we need to load the function using
        # func_name, not the name specified by fullname (which can be different for underscore
        # function)
        module = fullname.rsplit(".")[0]
        loaded_module = builder.load_module(module)

        func = builder.py_get_attr(loaded_module, func_name, line)
    else:
        func = builder.load_global_str(func_name, line)
    return func
</t>
<t tx="ekr.20240308084832.1429">def generate_singledispatch_dispatch_function(
    builder: IRBuilder, main_singledispatch_function_name: str, fitem: FuncDef
) -&gt; None:
    line = fitem.line
    current_func_decl = builder.mapper.func_to_decl[fitem]
    arg_info = get_args(builder, current_func_decl.sig.args, line)

    dispatch_func_obj = builder.self()

    arg_type = builder.builder.get_type_of_obj(arg_info.args[0], line)
    dispatch_cache = builder.builder.get_attr(
        dispatch_func_obj, "dispatch_cache", dict_rprimitive, line
    )
    call_find_impl, use_cache, call_func = BasicBlock(), BasicBlock(), BasicBlock()
    get_result = builder.call_c(dict_get_method_with_none, [dispatch_cache, arg_type], line)
    is_not_none = builder.translate_is_op(get_result, builder.none_object(), "is not", line)
    impl_to_use = Register(object_rprimitive)
    builder.add_bool_branch(is_not_none, use_cache, call_find_impl)

    builder.activate_block(use_cache)
    builder.assign(impl_to_use, get_result, line)
    builder.goto(call_func)

    builder.activate_block(call_find_impl)
    find_impl = builder.load_module_attr_by_fullname("functools._find_impl", line)
    registry = load_singledispatch_registry(builder, dispatch_func_obj, line)
    uncached_impl = builder.py_call(find_impl, [arg_type, registry], line)
    builder.call_c(dict_set_item_op, [dispatch_cache, arg_type, uncached_impl], line)
    builder.assign(impl_to_use, uncached_impl, line)
    builder.goto(call_func)

    builder.activate_block(call_func)
    gen_calls_to_correct_impl(builder, impl_to_use, arg_info, fitem, line)
</t>
<t tx="ekr.20240308084832.143">def visit_load_static(self, op: LoadStatic) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1430">def gen_calls_to_correct_impl(
    builder: IRBuilder, impl_to_use: Value, arg_info: ArgInfo, fitem: FuncDef, line: int
) -&gt; None:
    current_func_decl = builder.mapper.func_to_decl[fitem]

    def gen_native_func_call_and_return(fdef: FuncDef) -&gt; None:
        func_decl = builder.mapper.func_to_decl[fdef]
        ret_val = builder.builder.call(
            func_decl, arg_info.args, arg_info.arg_kinds, arg_info.arg_names, line
        )
        coerced = builder.coerce(ret_val, current_func_decl.sig.ret_type, line)
        builder.add(Return(coerced))

    typ, src = builtin_names["builtins.int"]
    int_type_obj = builder.add(LoadAddress(typ, src, line))
    is_int = builder.builder.type_is_op(impl_to_use, int_type_obj, line)

    native_call, non_native_call = BasicBlock(), BasicBlock()
    builder.add_bool_branch(is_int, native_call, non_native_call)
    builder.activate_block(native_call)

    passed_id = builder.add(Unbox(impl_to_use, int_rprimitive, line))

    native_ids = get_native_impl_ids(builder, fitem)
    for impl, i in native_ids.items():
        call_impl, next_impl = BasicBlock(), BasicBlock()

        current_id = builder.load_int(i)
        builder.builder.compare_tagged_condition(
            passed_id, current_id, "==", call_impl, next_impl, line
        )

        # Call the registered implementation
        builder.activate_block(call_impl)

        gen_native_func_call_and_return(impl)
        builder.activate_block(next_impl)

    # We've already handled all the possible integer IDs, so we should never get here
    builder.add(Unreachable())

    builder.activate_block(non_native_call)
    ret_val = builder.py_call(
        impl_to_use, arg_info.args, line, arg_info.arg_kinds, arg_info.arg_names
    )
    coerced = builder.coerce(ret_val, current_func_decl.sig.ret_type, line)
    builder.add(Return(coerced))
</t>
<t tx="ekr.20240308084832.1431">def gen_dispatch_func_ir(
    builder: IRBuilder, fitem: FuncDef, main_func_name: str, dispatch_name: str, sig: FuncSignature
) -&gt; tuple[FuncIR, Value]:
    """Create a dispatch function (a function that checks the first argument type and dispatches
    to the correct implementation)
    """
    builder.enter(FuncInfo(fitem, dispatch_name))
    setup_callable_class(builder)
    builder.fn_info.callable_class.ir.attributes["registry"] = dict_rprimitive
    builder.fn_info.callable_class.ir.attributes["dispatch_cache"] = dict_rprimitive
    builder.fn_info.callable_class.ir.has_dict = True
    builder.fn_info.callable_class.ir.needs_getseters = True
    generate_singledispatch_callable_class_ctor(builder)

    generate_singledispatch_dispatch_function(builder, main_func_name, fitem)
    args, _, blocks, _, fn_info = builder.leave()
    dispatch_callable_class = add_call_to_callable_class(builder, args, blocks, sig, fn_info)
    builder.functions.append(dispatch_callable_class)
    add_get_to_callable_class(builder, fn_info)
    add_register_method_to_callable_class(builder, fn_info)
    func_reg = instantiate_callable_class(builder, fn_info)
    dispatch_func_ir = generate_dispatch_glue_native_function(
        builder, fitem, dispatch_callable_class.decl, dispatch_name
    )

    return dispatch_func_ir, func_reg
</t>
<t tx="ekr.20240308084832.1432">def generate_dispatch_glue_native_function(
    builder: IRBuilder, fitem: FuncDef, callable_class_decl: FuncDecl, dispatch_name: str
) -&gt; FuncIR:
    line = fitem.line
    builder.enter()
    # We store the callable class in the globals dict for this function
    callable_class = builder.load_global_str(dispatch_name, line)
    decl = builder.mapper.func_to_decl[fitem]
    arg_info = get_args(builder, decl.sig.args, line)
    args = [callable_class] + arg_info.args
    arg_kinds = [ArgKind.ARG_POS] + arg_info.arg_kinds
    arg_names = arg_info.arg_names
    arg_names.insert(0, "self")
    ret_val = builder.builder.call(callable_class_decl, args, arg_kinds, arg_names, line)
    builder.add(Return(ret_val))
    arg_regs, _, blocks, _, fn_info = builder.leave()
    return FuncIR(decl, arg_regs, blocks)
</t>
<t tx="ekr.20240308084832.1433">def generate_singledispatch_callable_class_ctor(builder: IRBuilder) -&gt; None:
    """Create an __init__ that sets registry and dispatch_cache to empty dicts"""
    line = -1
    class_ir = builder.fn_info.callable_class.ir
    with builder.enter_method(class_ir, "__init__", bool_rprimitive):
        empty_dict = builder.call_c(dict_new_op, [], line)
        builder.add(SetAttr(builder.self(), "registry", empty_dict, line))
        cache_dict = builder.call_c(dict_new_op, [], line)
        dispatch_cache_str = builder.load_str("dispatch_cache")
        # use the py_setattr_op instead of SetAttr so that it also gets added to our __dict__
        builder.call_c(py_setattr_op, [builder.self(), dispatch_cache_str, cache_dict], line)
        # the generated C code seems to expect that __init__ returns a char, so just return 1
        builder.add(Return(Integer(1, bool_rprimitive, line), line))
</t>
<t tx="ekr.20240308084832.1434">def add_register_method_to_callable_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; None:
    line = -1
    with builder.enter_method(fn_info.callable_class.ir, "register", object_rprimitive):
        cls_arg = builder.add_argument("cls", object_rprimitive)
        func_arg = builder.add_argument("func", object_rprimitive, ArgKind.ARG_OPT)
        ret_val = builder.call_c(register_function, [builder.self(), cls_arg, func_arg], line)
        builder.add(Return(ret_val, line))
</t>
<t tx="ekr.20240308084832.1435">def load_singledispatch_registry(builder: IRBuilder, dispatch_func_obj: Value, line: int) -&gt; Value:
    return builder.builder.get_attr(dispatch_func_obj, "registry", dict_rprimitive, line)
</t>
<t tx="ekr.20240308084832.1436">def singledispatch_main_func_name(orig_name: str) -&gt; str:
    return f"__mypyc_singledispatch_main_function_{orig_name}__"
</t>
<t tx="ekr.20240308084832.1437">def get_registry_identifier(fitem: FuncDef) -&gt; str:
    return f"__mypyc_singledispatch_registry_{fitem.fullname}__"
</t>
<t tx="ekr.20240308084832.1438">def maybe_insert_into_registry_dict(builder: IRBuilder, fitem: FuncDef) -&gt; None:
    line = fitem.line
    is_singledispatch_main_func = fitem in builder.singledispatch_impls
    # dict of singledispatch_func to list of register_types (fitem is the function to register)
    to_register: defaultdict[FuncDef, list[TypeInfo]] = defaultdict(list)
    for main_func, impls in builder.singledispatch_impls.items():
        for dispatch_type, impl in impls:
            if fitem == impl:
                to_register[main_func].append(dispatch_type)

    if not to_register and not is_singledispatch_main_func:
        return

    if is_singledispatch_main_func:
        main_func_name = singledispatch_main_func_name(fitem.name)
        main_func_obj = load_func(builder, main_func_name, fitem.fullname, line)

        loaded_object_type = builder.load_module_attr_by_fullname("builtins.object", line)
        registry_dict = builder.builder.make_dict([(loaded_object_type, main_func_obj)], line)

        dispatch_func_obj = builder.load_global_str(fitem.name, line)
        builder.call_c(
            py_setattr_op, [dispatch_func_obj, builder.load_str("registry"), registry_dict], line
        )

    for singledispatch_func, types in to_register.items():
        # TODO: avoid recomputing the native IDs for all the functions every time we find a new
        # function
        native_ids = get_native_impl_ids(builder, singledispatch_func)
        if fitem not in native_ids:
            to_insert = load_func(builder, fitem.name, fitem.fullname, line)
        else:
            current_id = native_ids[fitem]
            load_literal = LoadLiteral(current_id, object_rprimitive)
            to_insert = builder.add(load_literal)
        # TODO: avoid reloading the registry here if we just created it
        dispatch_func_obj = load_func(
            builder, singledispatch_func.name, singledispatch_func.fullname, line
        )
        registry = load_singledispatch_registry(builder, dispatch_func_obj, line)
        for typ in types:
            loaded_type = load_type(builder, typ, line)
            builder.call_c(dict_set_item_op, [registry, loaded_type, to_insert], line)
        dispatch_cache = builder.builder.get_attr(
            dispatch_func_obj, "dispatch_cache", dict_rprimitive, line
        )
        builder.gen_method_call(dispatch_cache, "clear", [], None, line)
</t>
<t tx="ekr.20240308084832.1439">def get_native_impl_ids(builder: IRBuilder, singledispatch_func: FuncDef) -&gt; dict[FuncDef, int]:
    """Return a dict of registered implementation to native implementation ID for all
    implementations
    """
    impls = builder.singledispatch_impls[singledispatch_func]
    return {impl: i for i, (typ, impl) in enumerate(impls) if not is_decorated(builder, impl)}
</t>
<t tx="ekr.20240308084832.144">def visit_init_static(self, op: InitStatic) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1440">def gen_property_getter_ir(
    builder: IRBuilder, func_decl: FuncDecl, cdef: ClassDef, is_trait: bool
) -&gt; FuncIR:
    """Generate an implicit trivial property getter for an attribute.

    These are used if an attribute can also be accessed as a property.
    """
    name = func_decl.name
    builder.enter(name)
    self_reg = builder.add_argument("self", func_decl.sig.args[0].type)
    if not is_trait:
        value = builder.builder.get_attr(self_reg, name, func_decl.sig.ret_type, -1)
        builder.add(Return(value))
    else:
        builder.add(Unreachable())
    args, _, blocks, ret_type, fn_info = builder.leave()
    return FuncIR(func_decl, args, blocks)
</t>
<t tx="ekr.20240308084832.1441">def gen_property_setter_ir(
    builder: IRBuilder, func_decl: FuncDecl, cdef: ClassDef, is_trait: bool
) -&gt; FuncIR:
    """Generate an implicit trivial property setter for an attribute.

    These are used if an attribute can also be accessed as a property.
    """
    name = func_decl.name
    builder.enter(name)
    self_reg = builder.add_argument("self", func_decl.sig.args[0].type)
    value_reg = builder.add_argument("value", func_decl.sig.args[1].type)
    assert name.startswith(PROPSET_PREFIX)
    attr_name = name[len(PROPSET_PREFIX) :]
    if not is_trait:
        builder.add(SetAttr(self_reg, attr_name, value_reg, -1))
    builder.add(Return(builder.none()))
    args, _, blocks, ret_type, fn_info = builder.leave()
    return FuncIR(func_decl, args, blocks)
</t>
<t tx="ekr.20240308084832.1442">"""Generate IR for generator functions.

A generator function is represented by a class that implements the
generator protocol and keeps track of the generator state, including
local variables.

The top-level logic for dealing with generator functions is in
mypyc.irbuild.function.
"""

from __future__ import annotations

from mypy.nodes import ARG_OPT, Var
from mypyc.common import ENV_ATTR_NAME, NEXT_LABEL_ATTR_NAME, SELF_NAME
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature, RuntimeArg
from mypyc.ir.ops import (
    NO_TRACEBACK_LINE_NO,
    BasicBlock,
    Branch,
    Call,
    Goto,
    Integer,
    MethodCall,
    RaiseStandardError,
    Register,
    Return,
    SetAttr,
    TupleSet,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import RInstance, int_rprimitive, object_rprimitive
from mypyc.irbuild.builder import IRBuilder, gen_arg_defaults
from mypyc.irbuild.context import FuncInfo, GeneratorClass
from mypyc.irbuild.env_class import (
    add_args_to_env,
    finalize_env_class,
    load_env_registers,
    load_outer_env,
)
from mypyc.irbuild.nonlocalcontrol import ExceptNonlocalControl
from mypyc.primitives.exc_ops import (
    error_catch_op,
    exc_matches_op,
    raise_exception_with_tb_op,
    reraise_exception_op,
    restore_exc_info_op,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1443">def gen_generator_func(builder: IRBuilder) -&gt; None:
    setup_generator_class(builder)
    load_env_registers(builder)
    gen_arg_defaults(builder)
    finalize_env_class(builder)
    builder.add(Return(instantiate_generator_class(builder)))
</t>
<t tx="ekr.20240308084832.1444">def instantiate_generator_class(builder: IRBuilder) -&gt; Value:
    fitem = builder.fn_info.fitem
    generator_reg = builder.add(Call(builder.fn_info.generator_class.ir.ctor, [], fitem.line))

    # Get the current environment register. If the current function is nested, then the
    # generator class gets instantiated from the callable class' '__call__' method, and hence
    # we use the callable class' environment register. Otherwise, we use the original
    # function's environment register.
    if builder.fn_info.is_nested:
        curr_env_reg = builder.fn_info.callable_class.curr_env_reg
    else:
        curr_env_reg = builder.fn_info.curr_env_reg

    # Set the generator class' environment attribute to point at the environment class
    # defined in the current scope.
    builder.add(SetAttr(generator_reg, ENV_ATTR_NAME, curr_env_reg, fitem.line))

    # Set the generator class' environment class' NEXT_LABEL_ATTR_NAME attribute to 0.
    zero = Integer(0)
    builder.add(SetAttr(curr_env_reg, NEXT_LABEL_ATTR_NAME, zero, fitem.line))
    return generator_reg
</t>
<t tx="ekr.20240308084832.1445">def setup_generator_class(builder: IRBuilder) -&gt; ClassIR:
    name = f"{builder.fn_info.namespaced_name()}_gen"

    generator_class_ir = ClassIR(name, builder.module_name, is_generated=True)
    generator_class_ir.attributes[ENV_ATTR_NAME] = RInstance(builder.fn_info.env_class)
    generator_class_ir.mro = [generator_class_ir]

    builder.classes.append(generator_class_ir)
    builder.fn_info.generator_class = GeneratorClass(generator_class_ir)
    return generator_class_ir
</t>
<t tx="ekr.20240308084832.1446">def create_switch_for_generator_class(builder: IRBuilder) -&gt; None:
    builder.add(Goto(builder.fn_info.generator_class.switch_block))
    block = BasicBlock()
    builder.fn_info.generator_class.continuation_blocks.append(block)
    builder.activate_block(block)
</t>
<t tx="ekr.20240308084832.1447">def populate_switch_for_generator_class(builder: IRBuilder) -&gt; None:
    cls = builder.fn_info.generator_class
    line = builder.fn_info.fitem.line

    builder.activate_block(cls.switch_block)
    for label, true_block in enumerate(cls.continuation_blocks):
        false_block = BasicBlock()
        comparison = builder.binary_op(cls.next_label_reg, Integer(label), "==", line)
        builder.add_bool_branch(comparison, true_block, false_block)
        builder.activate_block(false_block)

    builder.add(RaiseStandardError(RaiseStandardError.STOP_ITERATION, None, line))
    builder.add(Unreachable())
</t>
<t tx="ekr.20240308084832.1448">def add_raise_exception_blocks_to_generator_class(builder: IRBuilder, line: int) -&gt; None:
    """Add error handling blocks to a generator class.

    Generates blocks to check if error flags are set while calling the
    helper method for generator functions, and raises an exception if
    those flags are set.
    """
    cls = builder.fn_info.generator_class
    assert cls.exc_regs is not None
    exc_type, exc_val, exc_tb = cls.exc_regs

    # Check to see if an exception was raised.
    error_block = BasicBlock()
    ok_block = BasicBlock()
    comparison = builder.translate_is_op(exc_type, builder.none_object(), "is not", line)
    builder.add_bool_branch(comparison, error_block, ok_block)

    builder.activate_block(error_block)
    builder.call_c(raise_exception_with_tb_op, [exc_type, exc_val, exc_tb], line)
    builder.add(Unreachable())
    builder.goto_and_activate(ok_block)
</t>
<t tx="ekr.20240308084832.1449">def add_methods_to_generator_class(
    builder: IRBuilder,
    fn_info: FuncInfo,
    sig: FuncSignature,
    arg_regs: list[Register],
    blocks: list[BasicBlock],
    is_coroutine: bool,
) -&gt; None:
    helper_fn_decl = add_helper_to_generator_class(builder, arg_regs, blocks, sig, fn_info)
    add_next_to_generator_class(builder, fn_info, helper_fn_decl, sig)
    add_send_to_generator_class(builder, fn_info, helper_fn_decl, sig)
    add_iter_to_generator_class(builder, fn_info)
    add_throw_to_generator_class(builder, fn_info, helper_fn_decl, sig)
    add_close_to_generator_class(builder, fn_info)
    if is_coroutine:
        add_await_to_generator_class(builder, fn_info)
</t>
<t tx="ekr.20240308084832.145">def visit_tuple_get(self, op: TupleGet) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1450">def add_helper_to_generator_class(
    builder: IRBuilder,
    arg_regs: list[Register],
    blocks: list[BasicBlock],
    sig: FuncSignature,
    fn_info: FuncInfo,
) -&gt; FuncDecl:
    """Generates a helper method for a generator class, called by '__next__' and 'throw'."""
    sig = FuncSignature(
        (
            RuntimeArg(SELF_NAME, object_rprimitive),
            RuntimeArg("type", object_rprimitive),
            RuntimeArg("value", object_rprimitive),
            RuntimeArg("traceback", object_rprimitive),
            RuntimeArg("arg", object_rprimitive),
        ),
        sig.ret_type,
    )
    helper_fn_decl = FuncDecl(
        "__mypyc_generator_helper__", fn_info.generator_class.ir.name, builder.module_name, sig
    )
    helper_fn_ir = FuncIR(
        helper_fn_decl, arg_regs, blocks, fn_info.fitem.line, traceback_name=fn_info.fitem.name
    )
    fn_info.generator_class.ir.methods["__mypyc_generator_helper__"] = helper_fn_ir
    builder.functions.append(helper_fn_ir)
    return helper_fn_decl
</t>
<t tx="ekr.20240308084832.1451">def add_iter_to_generator_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; None:
    """Generates the '__iter__' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "__iter__", object_rprimitive, fn_info):
        builder.add(Return(builder.self()))
</t>
<t tx="ekr.20240308084832.1452">def add_next_to_generator_class(
    builder: IRBuilder, fn_info: FuncInfo, fn_decl: FuncDecl, sig: FuncSignature
) -&gt; None:
    """Generates the '__next__' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "__next__", object_rprimitive, fn_info):
        none_reg = builder.none_object()
        # Call the helper function with error flags set to Py_None, and return that result.
        result = builder.add(
            Call(
                fn_decl,
                [builder.self(), none_reg, none_reg, none_reg, none_reg],
                fn_info.fitem.line,
            )
        )
        builder.add(Return(result))
</t>
<t tx="ekr.20240308084832.1453">def add_send_to_generator_class(
    builder: IRBuilder, fn_info: FuncInfo, fn_decl: FuncDecl, sig: FuncSignature
) -&gt; None:
    """Generates the 'send' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "send", object_rprimitive, fn_info):
        arg = builder.add_argument("arg", object_rprimitive)
        none_reg = builder.none_object()
        # Call the helper function with error flags set to Py_None, and return that result.
        result = builder.add(
            Call(
                fn_decl,
                [builder.self(), none_reg, none_reg, none_reg, builder.read(arg)],
                fn_info.fitem.line,
            )
        )
        builder.add(Return(result))
</t>
<t tx="ekr.20240308084832.1454">def add_throw_to_generator_class(
    builder: IRBuilder, fn_info: FuncInfo, fn_decl: FuncDecl, sig: FuncSignature
) -&gt; None:
    """Generates the 'throw' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "throw", object_rprimitive, fn_info):
        typ = builder.add_argument("type", object_rprimitive)
        val = builder.add_argument("value", object_rprimitive, ARG_OPT)
        tb = builder.add_argument("traceback", object_rprimitive, ARG_OPT)

        # Because the value and traceback arguments are optional and hence
        # can be NULL if not passed in, we have to assign them Py_None if
        # they are not passed in.
        none_reg = builder.none_object()
        builder.assign_if_null(val, lambda: none_reg, builder.fn_info.fitem.line)
        builder.assign_if_null(tb, lambda: none_reg, builder.fn_info.fitem.line)

        # Call the helper function using the arguments passed in, and return that result.
        result = builder.add(
            Call(
                fn_decl,
                [builder.self(), builder.read(typ), builder.read(val), builder.read(tb), none_reg],
                fn_info.fitem.line,
            )
        )
        builder.add(Return(result))
</t>
<t tx="ekr.20240308084832.1455">def add_close_to_generator_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; None:
    """Generates the '__close__' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "close", object_rprimitive, fn_info):
        except_block, else_block = BasicBlock(), BasicBlock()
        builder.builder.push_error_handler(except_block)
        builder.goto_and_activate(BasicBlock())
        generator_exit = builder.load_module_attr_by_fullname(
            "builtins.GeneratorExit", fn_info.fitem.line
        )
        builder.add(
            MethodCall(
                builder.self(),
                "throw",
                [generator_exit, builder.none_object(), builder.none_object()],
            )
        )
        builder.goto(else_block)
        builder.builder.pop_error_handler()

        builder.activate_block(except_block)
        old_exc = builder.call_c(error_catch_op, [], fn_info.fitem.line)
        builder.nonlocal_control.append(
            ExceptNonlocalControl(builder.nonlocal_control[-1], old_exc)
        )
        stop_iteration = builder.load_module_attr_by_fullname(
            "builtins.StopIteration", fn_info.fitem.line
        )
        exceptions = builder.add(TupleSet([generator_exit, stop_iteration], fn_info.fitem.line))
        matches = builder.call_c(exc_matches_op, [exceptions], fn_info.fitem.line)

        match_block, non_match_block = BasicBlock(), BasicBlock()
        builder.add(Branch(matches, match_block, non_match_block, Branch.BOOL))

        builder.activate_block(match_block)
        builder.call_c(restore_exc_info_op, [builder.read(old_exc)], fn_info.fitem.line)
        builder.add(Return(builder.none_object()))

        builder.activate_block(non_match_block)
        builder.call_c(reraise_exception_op, [], NO_TRACEBACK_LINE_NO)
        builder.add(Unreachable())

        builder.nonlocal_control.pop()

        builder.activate_block(else_block)
        builder.add(
            RaiseStandardError(
                RaiseStandardError.RUNTIME_ERROR,
                "generator ignored GeneratorExit",
                fn_info.fitem.line,
            )
        )
        builder.add(Unreachable())
</t>
<t tx="ekr.20240308084832.1456">def add_await_to_generator_class(builder: IRBuilder, fn_info: FuncInfo) -&gt; None:
    """Generates the '__await__' method for a generator class."""
    with builder.enter_method(fn_info.generator_class.ir, "__await__", object_rprimitive, fn_info):
        builder.add(Return(builder.self()))
</t>
<t tx="ekr.20240308084832.1457">def setup_env_for_generator_class(builder: IRBuilder) -&gt; None:
    """Populates the environment for a generator class."""
    fitem = builder.fn_info.fitem
    cls = builder.fn_info.generator_class
    self_target = builder.add_self_to_env(cls.ir)

    # Add the type, value, and traceback variables to the environment.
    exc_type = builder.add_local(Var("type"), object_rprimitive, is_arg=True)
    exc_val = builder.add_local(Var("value"), object_rprimitive, is_arg=True)
    exc_tb = builder.add_local(Var("traceback"), object_rprimitive, is_arg=True)
    # TODO: Use the right type here instead of object?
    exc_arg = builder.add_local(Var("arg"), object_rprimitive, is_arg=True)

    cls.exc_regs = (exc_type, exc_val, exc_tb)
    cls.send_arg_reg = exc_arg

    cls.self_reg = builder.read(self_target, fitem.line)
    cls.curr_env_reg = load_outer_env(builder, cls.self_reg, builder.symtables[-1])

    # Define a variable representing the label to go to the next time
    # the '__next__' function of the generator is called, and add it
    # as an attribute to the environment class.
    cls.next_label_target = builder.add_var_to_env_class(
        Var(NEXT_LABEL_ATTR_NAME), int_rprimitive, cls, reassign=False
    )

    # Add arguments from the original generator function to the
    # environment of the generator class.
    add_args_to_env(builder, local=False, base=cls, reassign=False)

    # Set the next label register for the generator class.
    cls.next_label_reg = builder.read(cls.next_label_target, fitem.line)
</t>
<t tx="ekr.20240308084832.1458">"""A "low-level" IR builder class.

LowLevelIRBuilder provides core abstractions we use for constructing
IR as well as a number of higher-level ones (accessing attributes,
calling functions and methods, and coercing between types, for
example). The core principle of the low-level IR builder is that all
of its facilities operate solely on the IR level and not the AST
level---it has *no knowledge* of mypy types or expressions.
"""

from __future__ import annotations

from typing import Callable, Final, Optional, Sequence, Tuple

from mypy.argmap import map_actuals_to_formals
from mypy.nodes import ARG_POS, ARG_STAR, ARG_STAR2, ArgKind
from mypy.operators import op_methods
from mypy.types import AnyType, TypeOfAny
from mypyc.common import (
    BITMAP_BITS,
    FAST_ISINSTANCE_MAX_SUBCLASSES,
    MAX_LITERAL_SHORT_INT,
    MAX_SHORT_INT,
    MIN_LITERAL_SHORT_INT,
    MIN_SHORT_INT,
    PLATFORM_SIZE,
    use_method_vectorcall,
    use_vectorcall,
)
from mypyc.errors import Errors
from mypyc.ir.class_ir import ClassIR, all_concrete_classes
from mypyc.ir.func_ir import FuncDecl, FuncSignature
from mypyc.ir.ops import (
    ERR_FALSE,
    ERR_NEVER,
    NAMESPACE_MODULE,
    NAMESPACE_STATIC,
    NAMESPACE_TYPE,
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    Extend,
    Float,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    Integer,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    Op,
    RaiseStandardError,
    Register,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unbox,
    Unreachable,
    Value,
    float_comparison_op_to_id,
    float_op_to_id,
    int_op_to_id,
)
from mypyc.ir.rtypes import (
    PyListObject,
    PyObject,
    PySetObject,
    PyVarObject,
    RArray,
    RInstance,
    RPrimitive,
    RTuple,
    RType,
    RUnion,
    bit_rprimitive,
    bitmap_rprimitive,
    bool_rprimitive,
    bytes_rprimitive,
    c_int_rprimitive,
    c_pointer_rprimitive,
    c_pyssize_t_rprimitive,
    c_size_t_rprimitive,
    check_native_int_range,
    dict_rprimitive,
    float_rprimitive,
    int_rprimitive,
    is_bit_rprimitive,
    is_bool_rprimitive,
    is_bytes_rprimitive,
    is_dict_rprimitive,
    is_fixed_width_rtype,
    is_float_rprimitive,
    is_int16_rprimitive,
    is_int32_rprimitive,
    is_int64_rprimitive,
    is_int_rprimitive,
    is_list_rprimitive,
    is_none_rprimitive,
    is_set_rprimitive,
    is_short_int_rprimitive,
    is_str_rprimitive,
    is_tagged,
    is_tuple_rprimitive,
    is_uint8_rprimitive,
    list_rprimitive,
    none_rprimitive,
    object_pointer_rprimitive,
    object_rprimitive,
    optional_value_type,
    pointer_rprimitive,
    short_int_rprimitive,
    str_rprimitive,
)
from mypyc.irbuild.mapper import Mapper
from mypyc.irbuild.util import concrete_arg_kind
from mypyc.options import CompilerOptions
from mypyc.primitives.bytes_ops import bytes_compare
from mypyc.primitives.dict_ops import (
    dict_build_op,
    dict_new_op,
    dict_ssize_t_size_op,
    dict_update_in_display_op,
)
from mypyc.primitives.exc_ops import err_occurred_op, keep_propagating_op
from mypyc.primitives.float_ops import copysign_op, int_to_float_op
from mypyc.primitives.generic_ops import (
    generic_len_op,
    generic_ssize_t_len_op,
    py_call_op,
    py_call_with_kwargs_op,
    py_getattr_op,
    py_method_call_op,
    py_vectorcall_method_op,
    py_vectorcall_op,
)
from mypyc.primitives.int_ops import (
    int16_divide_op,
    int16_mod_op,
    int16_overflow,
    int32_divide_op,
    int32_mod_op,
    int32_overflow,
    int64_divide_op,
    int64_mod_op,
    int64_to_int_op,
    int_comparison_op_mapping,
    int_to_int32_op,
    int_to_int64_op,
    ssize_t_to_int_op,
    uint8_overflow,
)
from mypyc.primitives.list_ops import list_build_op, list_extend_op, new_list_op
from mypyc.primitives.misc_ops import bool_op, fast_isinstance_op, none_object_op
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    CFunctionDescription,
    binary_ops,
    method_call_ops,
    unary_ops,
)
from mypyc.primitives.set_ops import new_set_op
from mypyc.primitives.str_ops import str_check_if_true, str_ssize_t_size_op, unicode_compare
from mypyc.primitives.tuple_ops import list_tuple_op, new_tuple_op, new_tuple_with_length_op
from mypyc.rt_subtype import is_runtime_subtype
from mypyc.sametype import is_same_type
from mypyc.subtype import is_subtype

DictEntry = Tuple[Optional[Value], Value]

# If the number of items is less than the threshold when initializing
# a list, we would inline the generate IR using SetMem and expanded
# for-loop. Otherwise, we would call `list_build_op` for larger lists.
# TODO: The threshold is a randomly chosen number which needs further
#       study on real-world projects for a better balance.
LIST_BUILDING_EXPANSION_THRESHOLD = 10

# From CPython
PY_VECTORCALL_ARGUMENTS_OFFSET: Final = 1 &lt;&lt; (PLATFORM_SIZE * 8 - 1)

FIXED_WIDTH_INT_BINARY_OPS: Final = {
    "+",
    "-",
    "*",
    "//",
    "%",
    "&amp;",
    "|",
    "^",
    "&lt;&lt;",
    "&gt;&gt;",
    "+=",
    "-=",
    "*=",
    "//=",
    "%=",
    "&amp;=",
    "|=",
    "^=",
    "&lt;&lt;=",
    "&gt;&gt;=",
}

# Binary operations on bools that are specialized and don't just promote operands to int
BOOL_BINARY_OPS: Final = {"&amp;", "&amp;=", "|", "|=", "^", "^=", "==", "!=", "&lt;", "&lt;=", "&gt;", "&gt;="}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1459">class LowLevelIRBuilder:
    @others
</t>
<t tx="ekr.20240308084832.146">def visit_tuple_set(self, op: TupleSet) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1460">def __init__(
    self, current_module: str, errors: Errors, mapper: Mapper, options: CompilerOptions
) -&gt; None:
    self.current_module = current_module
    self.errors = errors
    self.mapper = mapper
    self.options = options
    self.args: list[Register] = []
    self.blocks: list[BasicBlock] = []
    # Stack of except handler entry blocks
    self.error_handlers: list[BasicBlock | None] = [None]
    # Values that we need to keep alive as long as we have borrowed
    # temporaries. Use flush_keep_alives() to mark the end of the live range.
    self.keep_alives: list[Value] = []
</t>
<t tx="ekr.20240308084832.1461">def set_module(self, module_name: str, module_path: str) -&gt; None:
    """Set the name and path of the current module."""
    self.module_name = module_name
    self.module_path = module_path
</t>
<t tx="ekr.20240308084832.1462"># Basic operations

def add(self, op: Op) -&gt; Value:
    """Add an op."""
    assert not self.blocks[-1].terminated, "Can't add to finished block"
    self.blocks[-1].ops.append(op)
    return op
</t>
<t tx="ekr.20240308084832.1463">def goto(self, target: BasicBlock) -&gt; None:
    """Add goto to a basic block."""
    if not self.blocks[-1].terminated:
        self.add(Goto(target))
</t>
<t tx="ekr.20240308084832.1464">def activate_block(self, block: BasicBlock) -&gt; None:
    """Add a basic block and make it the active one (target of adds)."""
    if self.blocks:
        assert self.blocks[-1].terminated

    block.error_handler = self.error_handlers[-1]
    self.blocks.append(block)
</t>
<t tx="ekr.20240308084832.1465">def goto_and_activate(self, block: BasicBlock) -&gt; None:
    """Add goto a block and make it the active block."""
    self.goto(block)
    self.activate_block(block)
</t>
<t tx="ekr.20240308084832.1466">def keep_alive(self, values: list[Value], *, steal: bool = False) -&gt; None:
    self.add(KeepAlive(values, steal=steal))
</t>
<t tx="ekr.20240308084832.1467">def push_error_handler(self, handler: BasicBlock | None) -&gt; None:
    self.error_handlers.append(handler)
</t>
<t tx="ekr.20240308084832.1468">def pop_error_handler(self) -&gt; BasicBlock | None:
    return self.error_handlers.pop()
</t>
<t tx="ekr.20240308084832.1469">def self(self) -&gt; Register:
    """Return reference to the 'self' argument.

    This only works in a method.
    """
    return self.args[0]
</t>
<t tx="ekr.20240308084832.147">def visit_box(self, op: Box) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1470">def flush_keep_alives(self) -&gt; None:
    if self.keep_alives:
        self.add(KeepAlive(self.keep_alives.copy()))
        self.keep_alives = []
</t>
<t tx="ekr.20240308084832.1471"># Type conversions

def box(self, src: Value) -&gt; Value:
    if src.type.is_unboxed:
        if isinstance(src, Integer) and is_tagged(src.type):
            return self.add(LoadLiteral(src.value &gt;&gt; 1, rtype=object_rprimitive))
        return self.add(Box(src))
    else:
        return src
</t>
<t tx="ekr.20240308084832.1472">def unbox_or_cast(
    self, src: Value, target_type: RType, line: int, *, can_borrow: bool = False
) -&gt; Value:
    if target_type.is_unboxed:
        return self.add(Unbox(src, target_type, line))
    else:
        if can_borrow:
            self.keep_alives.append(src)
        return self.add(Cast(src, target_type, line, borrow=can_borrow))
</t>
<t tx="ekr.20240308084832.1473">def coerce(
    self,
    src: Value,
    target_type: RType,
    line: int,
    force: bool = False,
    *,
    can_borrow: bool = False,
) -&gt; Value:
    """Generate a coercion/cast from one type to other (only if needed).

    For example, int -&gt; object boxes the source int; int -&gt; int emits nothing;
    object -&gt; int unboxes the object. All conversions preserve object value.

    If force is true, always generate an op (even if it is just an assignment) so
    that the result will have exactly target_type as the type.

    Returns the register with the converted value (may be same as src).
    """
    src_type = src.type
    if src_type.is_unboxed and not target_type.is_unboxed:
        # Unboxed -&gt; boxed
        return self.box(src)
    if (src_type.is_unboxed and target_type.is_unboxed) and not is_runtime_subtype(
        src_type, target_type
    ):
        if (
            isinstance(src, Integer)
            and is_short_int_rprimitive(src_type)
            and is_fixed_width_rtype(target_type)
        ):
            value = src.numeric_value()
            if not check_native_int_range(target_type, value):
                self.error(f'Value {value} is out of range for "{target_type}"', line)
            return Integer(src.value &gt;&gt; 1, target_type)
        elif is_int_rprimitive(src_type) and is_fixed_width_rtype(target_type):
            return self.coerce_int_to_fixed_width(src, target_type, line)
        elif is_fixed_width_rtype(src_type) and is_int_rprimitive(target_type):
            return self.coerce_fixed_width_to_int(src, line)
        elif is_short_int_rprimitive(src_type) and is_fixed_width_rtype(target_type):
            return self.coerce_short_int_to_fixed_width(src, target_type, line)
        elif (
            isinstance(src_type, RPrimitive)
            and isinstance(target_type, RPrimitive)
            and src_type.is_native_int
            and target_type.is_native_int
            and src_type.size == target_type.size
            and src_type.is_signed == target_type.is_signed
        ):
            # Equivalent types
            return src
        elif (is_bool_rprimitive(src_type) or is_bit_rprimitive(src_type)) and is_tagged(
            target_type
        ):
            shifted = self.int_op(
                bool_rprimitive, src, Integer(1, bool_rprimitive), IntOp.LEFT_SHIFT
            )
            return self.add(Extend(shifted, target_type, signed=False))
        elif (
            is_bool_rprimitive(src_type) or is_bit_rprimitive(src_type)
        ) and is_fixed_width_rtype(target_type):
            return self.add(Extend(src, target_type, signed=False))
        elif isinstance(src, Integer) and is_float_rprimitive(target_type):
            if is_tagged(src_type):
                return Float(float(src.value // 2))
            return Float(float(src.value))
        elif is_tagged(src_type) and is_float_rprimitive(target_type):
            return self.int_to_float(src, line)
        elif (
            isinstance(src_type, RTuple)
            and isinstance(target_type, RTuple)
            and len(src_type.types) == len(target_type.types)
        ):
            # Coerce between two tuple types by coercing each item separately
            values = []
            for i in range(len(src_type.types)):
                v = None
                if isinstance(src, TupleSet):
                    item = src.items[i]
                    # We can't reuse register values, since they can be modified.
                    if not isinstance(item, Register):
                        v = item
                if v is None:
                    v = TupleGet(src, i)
                    self.add(v)
                values.append(v)
            return self.add(
                TupleSet(
                    [self.coerce(v, t, line) for v, t in zip(values, target_type.types)], line
                )
            )
        # To go between any other unboxed types, we go through a boxed
        # in-between value, for simplicity.
        tmp = self.box(src)
        return self.unbox_or_cast(tmp, target_type, line)
    if (not src_type.is_unboxed and target_type.is_unboxed) or not is_subtype(
        src_type, target_type
    ):
        return self.unbox_or_cast(src, target_type, line, can_borrow=can_borrow)
    elif force:
        tmp = Register(target_type)
        self.add(Assign(tmp, src))
        return tmp
    return src
</t>
<t tx="ekr.20240308084832.1474">def coerce_int_to_fixed_width(self, src: Value, target_type: RType, line: int) -&gt; Value:
    assert is_fixed_width_rtype(target_type), target_type
    assert isinstance(target_type, RPrimitive)

    res = Register(target_type)

    fast, slow, end = BasicBlock(), BasicBlock(), BasicBlock()

    check = self.check_tagged_short_int(src, line)
    self.add(Branch(check, fast, slow, Branch.BOOL))

    self.activate_block(fast)

    size = target_type.size
    if size &lt; int_rprimitive.size:
        # Add a range check when the target type is smaller than the source tyoe
        fast2, fast3 = BasicBlock(), BasicBlock()
        upper_bound = 1 &lt;&lt; (size * 8 - 1)
        if not target_type.is_signed:
            upper_bound *= 2
        check2 = self.add(ComparisonOp(src, Integer(upper_bound, src.type), ComparisonOp.SLT))
        self.add(Branch(check2, fast2, slow, Branch.BOOL))
        self.activate_block(fast2)
        if target_type.is_signed:
            lower_bound = -upper_bound
        else:
            lower_bound = 0
        check3 = self.add(ComparisonOp(src, Integer(lower_bound, src.type), ComparisonOp.SGE))
        self.add(Branch(check3, fast3, slow, Branch.BOOL))
        self.activate_block(fast3)
        tmp = self.int_op(
            c_pyssize_t_rprimitive,
            src,
            Integer(1, c_pyssize_t_rprimitive),
            IntOp.RIGHT_SHIFT,
            line,
        )
        tmp = self.add(Truncate(tmp, target_type))
    else:
        if size &gt; int_rprimitive.size:
            tmp = self.add(Extend(src, target_type, signed=True))
        else:
            tmp = src
        tmp = self.int_op(target_type, tmp, Integer(1, target_type), IntOp.RIGHT_SHIFT, line)

    self.add(Assign(res, tmp))
    self.goto(end)

    self.activate_block(slow)
    if is_int64_rprimitive(target_type) or (
        is_int32_rprimitive(target_type) and size == int_rprimitive.size
    ):
        # Slow path calls a library function that handles more complex logic
        ptr = self.int_op(
            pointer_rprimitive, src, Integer(1, pointer_rprimitive), IntOp.XOR, line
        )
        ptr2 = Register(c_pointer_rprimitive)
        self.add(Assign(ptr2, ptr))
        if is_int64_rprimitive(target_type):
            conv_op = int_to_int64_op
        else:
            conv_op = int_to_int32_op
        tmp = self.call_c(conv_op, [ptr2], line)
        self.add(Assign(res, tmp))
        self.add(KeepAlive([src]))
        self.goto(end)
    elif is_int32_rprimitive(target_type):
        # Slow path just always generates an OverflowError
        self.call_c(int32_overflow, [], line)
        self.add(Unreachable())
    elif is_int16_rprimitive(target_type):
        # Slow path just always generates an OverflowError
        self.call_c(int16_overflow, [], line)
        self.add(Unreachable())
    elif is_uint8_rprimitive(target_type):
        # Slow path just always generates an OverflowError
        self.call_c(uint8_overflow, [], line)
        self.add(Unreachable())
    else:
        assert False, target_type

    self.activate_block(end)
    return res
</t>
<t tx="ekr.20240308084832.1475">def coerce_short_int_to_fixed_width(self, src: Value, target_type: RType, line: int) -&gt; Value:
    if is_int64_rprimitive(target_type):
        return self.int_op(target_type, src, Integer(1, target_type), IntOp.RIGHT_SHIFT, line)
    # TODO: i32
    assert False, (src.type, target_type)
</t>
<t tx="ekr.20240308084832.1476">def coerce_fixed_width_to_int(self, src: Value, line: int) -&gt; Value:
    if (
        (is_int32_rprimitive(src.type) and PLATFORM_SIZE == 8)
        or is_int16_rprimitive(src.type)
        or is_uint8_rprimitive(src.type)
    ):
        # Simple case -- just sign extend and shift.
        extended = self.add(Extend(src, c_pyssize_t_rprimitive, signed=src.type.is_signed))
        return self.int_op(
            int_rprimitive,
            extended,
            Integer(1, c_pyssize_t_rprimitive),
            IntOp.LEFT_SHIFT,
            line,
        )

    assert is_fixed_width_rtype(src.type)
    assert isinstance(src.type, RPrimitive)
    src_type = src.type

    res = Register(int_rprimitive)

    fast, fast2, slow, end = BasicBlock(), BasicBlock(), BasicBlock(), BasicBlock()

    c1 = self.add(ComparisonOp(src, Integer(MAX_SHORT_INT, src_type), ComparisonOp.SLE))
    self.add(Branch(c1, fast, slow, Branch.BOOL))

    self.activate_block(fast)
    c2 = self.add(ComparisonOp(src, Integer(MIN_SHORT_INT, src_type), ComparisonOp.SGE))
    self.add(Branch(c2, fast2, slow, Branch.BOOL))

    self.activate_block(slow)
    if is_int64_rprimitive(src_type):
        conv_op = int64_to_int_op
    elif is_int32_rprimitive(src_type):
        assert PLATFORM_SIZE == 4
        conv_op = ssize_t_to_int_op
    else:
        assert False, src_type
    x = self.call_c(conv_op, [src], line)
    self.add(Assign(res, x))
    self.goto(end)

    self.activate_block(fast2)
    if int_rprimitive.size &lt; src_type.size:
        tmp = self.add(Truncate(src, c_pyssize_t_rprimitive))
    else:
        tmp = src
    s = self.int_op(int_rprimitive, tmp, Integer(1, tmp.type), IntOp.LEFT_SHIFT, line)
    self.add(Assign(res, s))
    self.goto(end)

    self.activate_block(end)
    return res
</t>
<t tx="ekr.20240308084832.1477">def coerce_nullable(self, src: Value, target_type: RType, line: int) -&gt; Value:
    """Generate a coercion from a potentially null value."""
    if src.type.is_unboxed == target_type.is_unboxed and (
        (target_type.is_unboxed and is_runtime_subtype(src.type, target_type))
        or (not target_type.is_unboxed and is_subtype(src.type, target_type))
    ):
        return src

    target = Register(target_type)

    valid, invalid, out = BasicBlock(), BasicBlock(), BasicBlock()
    self.add(Branch(src, invalid, valid, Branch.IS_ERROR))

    self.activate_block(valid)
    coerced = self.coerce(src, target_type, line)
    self.add(Assign(target, coerced, line))
    self.goto(out)

    self.activate_block(invalid)
    error = self.add(LoadErrorValue(target_type))
    self.add(Assign(target, error, line))

    self.goto_and_activate(out)
    return target
</t>
<t tx="ekr.20240308084832.1478"># Attribute access

def get_attr(
    self, obj: Value, attr: str, result_type: RType, line: int, *, borrow: bool = False
) -&gt; Value:
    """Get a native or Python attribute of an object."""
    if (
        isinstance(obj.type, RInstance)
        and obj.type.class_ir.is_ext_class
        and obj.type.class_ir.has_attr(attr)
    ):
        op = GetAttr(obj, attr, line, borrow=borrow)
        # For non-refcounted attribute types, the borrow might be
        # disabled even if requested, so don't check 'borrow'.
        if op.is_borrowed:
            self.keep_alives.append(obj)
        return self.add(op)
    elif isinstance(obj.type, RUnion):
        return self.union_get_attr(obj, obj.type, attr, result_type, line)
    else:
        return self.py_get_attr(obj, attr, line)
</t>
<t tx="ekr.20240308084832.1479">def union_get_attr(
    self, obj: Value, rtype: RUnion, attr: str, result_type: RType, line: int
) -&gt; Value:
    """Get an attribute of an object with a union type."""

    def get_item_attr(value: Value) -&gt; Value:
        return self.get_attr(value, attr, result_type, line)

    return self.decompose_union_helper(obj, rtype, result_type, get_item_attr, line)
</t>
<t tx="ekr.20240308084832.148">def visit_unbox(self, op: Unbox) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1480">def py_get_attr(self, obj: Value, attr: str, line: int) -&gt; Value:
    """Get a Python attribute (slow).

    Prefer get_attr() which generates optimized code for native classes.
    """
    key = self.load_str(attr)
    return self.call_c(py_getattr_op, [obj, key], line)
</t>
<t tx="ekr.20240308084832.1481"># isinstance() checks

def isinstance_helper(self, obj: Value, class_irs: list[ClassIR], line: int) -&gt; Value:
    """Fast path for isinstance() that checks against a list of native classes."""
    if not class_irs:
        return self.false()
    ret = self.isinstance_native(obj, class_irs[0], line)
    for class_ir in class_irs[1:]:

        def other() -&gt; Value:
            return self.isinstance_native(obj, class_ir, line)

        ret = self.shortcircuit_helper("or", bool_rprimitive, lambda: ret, other, line)
    return ret
</t>
<t tx="ekr.20240308084832.1482">def get_type_of_obj(self, obj: Value, line: int) -&gt; Value:
    ob_type_address = self.add(GetElementPtr(obj, PyObject, "ob_type", line))
    ob_type = self.add(LoadMem(object_rprimitive, ob_type_address))
    self.add(KeepAlive([obj]))
    return ob_type
</t>
<t tx="ekr.20240308084832.1483">def type_is_op(self, obj: Value, type_obj: Value, line: int) -&gt; Value:
    typ = self.get_type_of_obj(obj, line)
    return self.add(ComparisonOp(typ, type_obj, ComparisonOp.EQ, line))
</t>
<t tx="ekr.20240308084832.1484">def isinstance_native(self, obj: Value, class_ir: ClassIR, line: int) -&gt; Value:
    """Fast isinstance() check for a native class.

    If there are three or fewer concrete (non-trait) classes among the class
    and all its children, use even faster type comparison checks `type(obj)
    is typ`.
    """
    concrete = all_concrete_classes(class_ir)
    if concrete is None or len(concrete) &gt; FAST_ISINSTANCE_MAX_SUBCLASSES + 1:
        return self.call_c(fast_isinstance_op, [obj, self.get_native_type(class_ir)], line)
    if not concrete:
        # There can't be any concrete instance that matches this.
        return self.false()
    type_obj = self.get_native_type(concrete[0])
    ret = self.type_is_op(obj, type_obj, line)
    for c in concrete[1:]:

        def other() -&gt; Value:
            return self.type_is_op(obj, self.get_native_type(c), line)

        ret = self.shortcircuit_helper("or", bool_rprimitive, lambda: ret, other, line)
    return ret
</t>
<t tx="ekr.20240308084832.1485"># Calls

def _construct_varargs(
    self,
    args: Sequence[tuple[Value, ArgKind, str | None]],
    line: int,
    *,
    has_star: bool,
    has_star2: bool,
) -&gt; tuple[Value | None, Value | None]:
    """Construct *args and **kwargs from a collection of arguments

    This is pretty complicated, and almost all of the complication here stems from
    one of two things (but mostly the second):
      * The handling of ARG_STAR/ARG_STAR2. We want to create as much of the args/kwargs
        values in one go as we can, so we collect values until our hand is forced, and
        then we emit creation of the list/tuple, and expand it from there if needed.

      * Support potentially nullable argument values. This has very narrow applicability,
        as this will never be done by our compiled Python code, but is critically used
        by gen_glue_method when generating glue methods to mediate between the function
        signature of a parent class and its subclasses.

        For named-only arguments, this is quite simple: if it is
        null, don't put it in the dict.

        For positional-or-named arguments, things are much more complicated.
          * First, anything that was passed as a positional arg
            must be forwarded along as a positional arg. It *must
            not* be converted to a named arg. This is because mypy
            does not enforce that positional-or-named arguments
            have the same name in subclasses, and it is not
            uncommon for code to have different names in
            subclasses (a bunch of mypy's visitors do this, for
            example!). This is arguably a bug in both mypy and code doing
            this, and they ought to be using positional-only arguments, but
            positional-only arguments are new and ugly.

          * On the flip side, we're willing to accept the
            infelicity of sometimes turning an argument that was
            passed by keyword into a positional argument. It's wrong,
            but it's very marginal, and avoiding it would require passing
            a bitmask of which arguments were named with every function call,
            or something similar.
            (See some discussion of this in testComplicatedArgs)

        Thus, our strategy for positional-or-named arguments is to
        always pass them as positional, except in the one
        situation where we can not, and where we can be absolutely
        sure they were passed by name: when an *earlier*
        positional argument was missing its value.

        This means that if we have a method `f(self, x: int=..., y: object=...)`:
          * x and y present:      args=(x, y), kwargs={}
          * x present, y missing: args=(x,),   kwargs={}
          * x missing, y present: args=(),     kwargs={'y': y}

        To implement this, when we have multiple optional
        positional arguments, we maintain a flag in a register
        that tracks whether an argument has been missing, and for
        each such optional argument (except the first), we check
        the flag to determine whether to append the argument to
        the *args list or add it to the **kwargs dict. What a
        mess!

        This is what really makes everything here such a tangle;
        otherwise the *args and **kwargs code could be separated.

    The arguments has_star and has_star2 indicate whether the target function
    takes an ARG_STAR and ARG_STAR2 argument, respectively.
    (These will always be true when making a pycall, and be based
    on the actual target signature for a native call.)
    """

    star_result: Value | None = None
    star2_result: Value | None = None
    # We aggregate values that need to go into *args and **kwargs
    # in these lists. Once all arguments are processed (in the
    # happiest case), or we encounter an ARG_STAR/ARG_STAR2 or a
    # nullable arg, then we create the list and/or dict.
    star_values: list[Value] = []
    star2_keys: list[Value] = []
    star2_values: list[Value] = []

    seen_empty_reg: Register | None = None

    for value, kind, name in args:
        if kind == ARG_STAR:
            if star_result is None:
                star_result = self.new_list_op(star_values, line)
            self.call_c(list_extend_op, [star_result, value], line)
        elif kind == ARG_STAR2:
            if star2_result is None:
                star2_result = self._create_dict(star2_keys, star2_values, line)

            self.call_c(dict_update_in_display_op, [star2_result, value], line=line)
        else:
            nullable = kind.is_optional()
            maybe_pos = kind.is_positional() and has_star
            maybe_named = kind.is_named() or (kind.is_optional() and name and has_star2)

            # If the argument is nullable, we need to create the
            # relevant args/kwargs objects so that we can
            # conditionally modify them.
            if nullable:
                if maybe_pos and star_result is None:
                    star_result = self.new_list_op(star_values, line)
                if maybe_named and star2_result is None:
                    star2_result = self._create_dict(star2_keys, star2_values, line)

            # Easy cases: just collect the argument.
            if maybe_pos and star_result is None:
                star_values.append(value)
                continue

            if maybe_named and star2_result is None:
                assert name is not None
                key = self.load_str(name)
                star2_keys.append(key)
                star2_values.append(value)
                continue

            # OK, anything that is nullable or *after* a nullable arg needs to be here
            # TODO: We could try harder to avoid creating basic blocks in the common case
            new_seen_empty_reg = seen_empty_reg

            out = BasicBlock()
            if nullable:
                # If this is the first nullable positional arg we've seen, create
                # a register to track whether anything has been null.
                # (We won't *check* the register until the next argument, though.)
                if maybe_pos and not seen_empty_reg:
                    new_seen_empty_reg = Register(bool_rprimitive)
                    self.add(Assign(new_seen_empty_reg, self.false(), line))

                skip = BasicBlock() if maybe_pos else out
                keep = BasicBlock()
                self.add(Branch(value, skip, keep, Branch.IS_ERROR))
                self.activate_block(keep)

            # If this could be positional or named and we /might/ have seen a missing
            # positional arg, then we need to compile *both* a positional and named
            # version! What a pain!
            if maybe_pos and maybe_named and seen_empty_reg:
                pos_block, named_block = BasicBlock(), BasicBlock()
                self.add(Branch(seen_empty_reg, named_block, pos_block, Branch.BOOL))
            else:
                pos_block = named_block = BasicBlock()
                self.goto(pos_block)

            if maybe_pos:
                self.activate_block(pos_block)
                assert star_result
                self.translate_special_method_call(
                    star_result, "append", [value], result_type=None, line=line
                )
                self.goto(out)

            if maybe_named and (not maybe_pos or seen_empty_reg):
                self.activate_block(named_block)
                assert name is not None
                key = self.load_str(name)
                assert star2_result
                self.translate_special_method_call(
                    star2_result, "__setitem__", [key, value], result_type=None, line=line
                )
                self.goto(out)

            if nullable and maybe_pos and new_seen_empty_reg:
                assert skip is not out
                self.activate_block(skip)
                self.add(Assign(new_seen_empty_reg, self.true(), line))
                self.goto(out)

            self.activate_block(out)

            seen_empty_reg = new_seen_empty_reg

    assert not (star_result or star_values) or has_star
    assert not (star2_result or star2_values) or has_star2
    if has_star:
        # If we managed to make it this far without creating a
        # *args list, then we can directly create a
        # tuple. Otherwise create the tuple from the list.
        if star_result is None:
            star_result = self.new_tuple(star_values, line)
        else:
            star_result = self.call_c(list_tuple_op, [star_result], line)
    if has_star2 and star2_result is None:
        star2_result = self._create_dict(star2_keys, star2_values, line)

    return star_result, star2_result
</t>
<t tx="ekr.20240308084832.1486">def py_call(
    self,
    function: Value,
    arg_values: list[Value],
    line: int,
    arg_kinds: list[ArgKind] | None = None,
    arg_names: Sequence[str | None] | None = None,
) -&gt; Value:
    """Call a Python function (non-native and slow).

    Use py_call_op or py_call_with_kwargs_op for Python function call.
    """
    if use_vectorcall(self.options.capi_version):
        # More recent Python versions support faster vectorcalls.
        result = self._py_vector_call(function, arg_values, line, arg_kinds, arg_names)
        if result is not None:
            return result

    # If all arguments are positional, we can use py_call_op.
    if arg_kinds is None or all(kind == ARG_POS for kind in arg_kinds):
        return self.call_c(py_call_op, [function] + arg_values, line)

    # Otherwise fallback to py_call_with_kwargs_op.
    assert arg_names is not None

    pos_args_tuple, kw_args_dict = self._construct_varargs(
        list(zip(arg_values, arg_kinds, arg_names)), line, has_star=True, has_star2=True
    )
    assert pos_args_tuple and kw_args_dict

    return self.call_c(py_call_with_kwargs_op, [function, pos_args_tuple, kw_args_dict], line)
</t>
<t tx="ekr.20240308084832.1487">def _py_vector_call(
    self,
    function: Value,
    arg_values: list[Value],
    line: int,
    arg_kinds: list[ArgKind] | None = None,
    arg_names: Sequence[str | None] | None = None,
) -&gt; Value | None:
    """Call function using the vectorcall API if possible.

    Return the return value if successful. Return None if a non-vectorcall
    API should be used instead.
    """
    # We can do this if all args are positional or named (no *args or **kwargs, not optional).
    if arg_kinds is None or all(
        not kind.is_star() and not kind.is_optional() for kind in arg_kinds
    ):
        if arg_values:
            # Create a C array containing all arguments as boxed values.
            coerced_args = [self.coerce(arg, object_rprimitive, line) for arg in arg_values]
            arg_ptr = self.setup_rarray(object_rprimitive, coerced_args, object_ptr=True)
        else:
            arg_ptr = Integer(0, object_pointer_rprimitive)
        num_pos = num_positional_args(arg_values, arg_kinds)
        keywords = self._vectorcall_keywords(arg_names)
        value = self.call_c(
            py_vectorcall_op,
            [function, arg_ptr, Integer(num_pos, c_size_t_rprimitive), keywords],
            line,
        )
        if arg_values:
            # Make sure arguments won't be freed until after the call.
            # We need this because RArray doesn't support automatic
            # memory management.
            self.add(KeepAlive(coerced_args))
        return value
    return None
</t>
<t tx="ekr.20240308084832.1488">def _vectorcall_keywords(self, arg_names: Sequence[str | None] | None) -&gt; Value:
    """Return a reference to a tuple literal with keyword argument names.

    Return null pointer if there are no keyword arguments.
    """
    if arg_names:
        kw_list = [name for name in arg_names if name is not None]
        if kw_list:
            return self.add(LoadLiteral(tuple(kw_list), object_rprimitive))
    return Integer(0, object_rprimitive)
</t>
<t tx="ekr.20240308084832.1489">def py_method_call(
    self,
    obj: Value,
    method_name: str,
    arg_values: list[Value],
    line: int,
    arg_kinds: list[ArgKind] | None,
    arg_names: Sequence[str | None] | None,
) -&gt; Value:
    """Call a Python method (non-native and slow)."""
    if use_method_vectorcall(self.options.capi_version):
        # More recent Python versions support faster vectorcalls.
        result = self._py_vector_method_call(
            obj, method_name, arg_values, line, arg_kinds, arg_names
        )
        if result is not None:
            return result

    if arg_kinds is None or all(kind == ARG_POS for kind in arg_kinds):
        # Use legacy method call API
        method_name_reg = self.load_str(method_name)
        return self.call_c(py_method_call_op, [obj, method_name_reg] + arg_values, line)
    else:
        # Use py_call since it supports keyword arguments (and vectorcalls).
        method = self.py_get_attr(obj, method_name, line)
        return self.py_call(method, arg_values, line, arg_kinds=arg_kinds, arg_names=arg_names)
</t>
<t tx="ekr.20240308084832.149">def visit_cast(self, op: Cast) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1490">def _py_vector_method_call(
    self,
    obj: Value,
    method_name: str,
    arg_values: list[Value],
    line: int,
    arg_kinds: list[ArgKind] | None,
    arg_names: Sequence[str | None] | None,
) -&gt; Value | None:
    """Call method using the vectorcall API if possible.

    Return the return value if successful. Return None if a non-vectorcall
    API should be used instead.
    """
    if arg_kinds is None or all(
        not kind.is_star() and not kind.is_optional() for kind in arg_kinds
    ):
        method_name_reg = self.load_str(method_name)
        coerced_args = [
            self.coerce(arg, object_rprimitive, line) for arg in [obj] + arg_values
        ]
        arg_ptr = self.setup_rarray(object_rprimitive, coerced_args, object_ptr=True)
        num_pos = num_positional_args(arg_values, arg_kinds)
        keywords = self._vectorcall_keywords(arg_names)
        value = self.call_c(
            py_vectorcall_method_op,
            [
                method_name_reg,
                arg_ptr,
                Integer((num_pos + 1) | PY_VECTORCALL_ARGUMENTS_OFFSET, c_size_t_rprimitive),
                keywords,
            ],
            line,
        )
        # Make sure arguments won't be freed until after the call.
        # We need this because RArray doesn't support automatic
        # memory management.
        self.add(KeepAlive(coerced_args))
        return value
    return None
</t>
<t tx="ekr.20240308084832.1491">def call(
    self,
    decl: FuncDecl,
    args: Sequence[Value],
    arg_kinds: list[ArgKind],
    arg_names: Sequence[str | None],
    line: int,
    *,
    bitmap_args: list[Register] | None = None,
) -&gt; Value:
    """Call a native function.

    If bitmap_args is given, they override the values of (some) of the bitmap
    arguments used to track the presence of values for certain arguments. By
    default, the values of the bitmap arguments are inferred from args.
    """
    # Normalize args to positionals.
    args = self.native_args_to_positional(
        args, arg_kinds, arg_names, decl.sig, line, bitmap_args=bitmap_args
    )
    return self.add(Call(decl, args, line))
</t>
<t tx="ekr.20240308084832.1492">def native_args_to_positional(
    self,
    args: Sequence[Value],
    arg_kinds: list[ArgKind],
    arg_names: Sequence[str | None],
    sig: FuncSignature,
    line: int,
    *,
    bitmap_args: list[Register] | None = None,
) -&gt; list[Value]:
    """Prepare arguments for a native call.

    Given args/kinds/names and a target signature for a native call, map
    keyword arguments to their appropriate place in the argument list,
    fill in error values for unspecified default arguments,
    package arguments that will go into *args/**kwargs into a tuple/dict,
    and coerce arguments to the appropriate type.
    """

    sig_args = sig.args
    n = sig.num_bitmap_args
    if n:
        sig_args = sig_args[:-n]

    sig_arg_kinds = [arg.kind for arg in sig_args]
    sig_arg_names = [arg.name for arg in sig_args]

    concrete_kinds = [concrete_arg_kind(arg_kind) for arg_kind in arg_kinds]
    formal_to_actual = map_actuals_to_formals(
        concrete_kinds,
        arg_names,
        sig_arg_kinds,
        sig_arg_names,
        lambda n: AnyType(TypeOfAny.special_form),
    )

    # First scan for */** and construct those
    has_star = has_star2 = False
    star_arg_entries = []
    for lst, arg in zip(formal_to_actual, sig_args):
        if arg.kind.is_star():
            star_arg_entries.extend([(args[i], arg_kinds[i], arg_names[i]) for i in lst])
        has_star = has_star or arg.kind == ARG_STAR
        has_star2 = has_star2 or arg.kind == ARG_STAR2

    star_arg, star2_arg = self._construct_varargs(
        star_arg_entries, line, has_star=has_star, has_star2=has_star2
    )

    # Flatten out the arguments, loading error values for default
    # arguments, constructing tuples/dicts for star args, and
    # coercing everything to the expected type.
    output_args: list[Value] = []
    for lst, arg in zip(formal_to_actual, sig_args):
        if arg.kind == ARG_STAR:
            assert star_arg
            output_arg = star_arg
        elif arg.kind == ARG_STAR2:
            assert star2_arg
            output_arg = star2_arg
        elif not lst:
            if is_fixed_width_rtype(arg.type):
                output_arg = Integer(0, arg.type)
            elif is_float_rprimitive(arg.type):
                output_arg = Float(0.0)
            else:
                output_arg = self.add(LoadErrorValue(arg.type, is_borrowed=True))
        else:
            base_arg = args[lst[0]]

            if arg_kinds[lst[0]].is_optional():
                output_arg = self.coerce_nullable(base_arg, arg.type, line)
            else:
                output_arg = self.coerce(base_arg, arg.type, line)

        output_args.append(output_arg)

    for i in reversed(range(n)):
        if bitmap_args and i &lt; len(bitmap_args):
            # Use override provided by caller
            output_args.append(bitmap_args[i])
            continue
        # Infer values of bitmap args
        bitmap = 0
        c = 0
        for lst, arg in zip(formal_to_actual, sig_args):
            if arg.kind.is_optional() and arg.type.error_overlap:
                if i * BITMAP_BITS &lt;= c &lt; (i + 1) * BITMAP_BITS:
                    if lst:
                        bitmap |= 1 &lt;&lt; (c &amp; (BITMAP_BITS - 1))
                c += 1
        output_args.append(Integer(bitmap, bitmap_rprimitive))

    return output_args
</t>
<t tx="ekr.20240308084832.1493">def gen_method_call(
    self,
    base: Value,
    name: str,
    arg_values: list[Value],
    result_type: RType | None,
    line: int,
    arg_kinds: list[ArgKind] | None = None,
    arg_names: list[str | None] | None = None,
    can_borrow: bool = False,
) -&gt; Value:
    """Generate either a native or Python method call."""
    # If we have *args, then fallback to Python method call.
    if arg_kinds is not None and any(kind.is_star() for kind in arg_kinds):
        return self.py_method_call(base, name, arg_values, base.line, arg_kinds, arg_names)

    # If the base type is one of ours, do a MethodCall
    if (
        isinstance(base.type, RInstance)
        and base.type.class_ir.is_ext_class
        and not base.type.class_ir.builtin_base
    ):
        if base.type.class_ir.has_method(name):
            decl = base.type.class_ir.method_decl(name)
            if arg_kinds is None:
                assert arg_names is None, "arg_kinds not present but arg_names is"
                arg_kinds = [ARG_POS for _ in arg_values]
                arg_names = [None for _ in arg_values]
            else:
                assert arg_names is not None, "arg_kinds present but arg_names is not"

            # Normalize args to positionals.
            assert decl.bound_sig
            arg_values = self.native_args_to_positional(
                arg_values, arg_kinds, arg_names, decl.bound_sig, line
            )
            return self.add(MethodCall(base, name, arg_values, line))
        elif base.type.class_ir.has_attr(name):
            function = self.add(GetAttr(base, name, line))
            return self.py_call(
                function, arg_values, line, arg_kinds=arg_kinds, arg_names=arg_names
            )

    elif isinstance(base.type, RUnion):
        return self.union_method_call(
            base, base.type, name, arg_values, result_type, line, arg_kinds, arg_names
        )

    # Try to do a special-cased method call
    if not arg_kinds or arg_kinds == [ARG_POS] * len(arg_values):
        target = self.translate_special_method_call(
            base, name, arg_values, result_type, line, can_borrow=can_borrow
        )
        if target:
            return target

    # Fall back to Python method call
    return self.py_method_call(base, name, arg_values, line, arg_kinds, arg_names)
</t>
<t tx="ekr.20240308084832.1494">def union_method_call(
    self,
    base: Value,
    obj_type: RUnion,
    name: str,
    arg_values: list[Value],
    return_rtype: RType | None,
    line: int,
    arg_kinds: list[ArgKind] | None,
    arg_names: list[str | None] | None,
) -&gt; Value:
    """Generate a method call with a union type for the object."""
    # Union method call needs a return_rtype for the type of the output register.
    # If we don't have one, use object_rprimitive.
    return_rtype = return_rtype or object_rprimitive

    def call_union_item(value: Value) -&gt; Value:
        return self.gen_method_call(
            value, name, arg_values, return_rtype, line, arg_kinds, arg_names
        )

    return self.decompose_union_helper(base, obj_type, return_rtype, call_union_item, line)
</t>
<t tx="ekr.20240308084832.1495"># Loading various values

def none(self) -&gt; Value:
    """Load unboxed None value (type: none_rprimitive)."""
    return Integer(1, none_rprimitive)
</t>
<t tx="ekr.20240308084832.1496">def true(self) -&gt; Value:
    """Load unboxed True value (type: bool_rprimitive)."""
    return Integer(1, bool_rprimitive)
</t>
<t tx="ekr.20240308084832.1497">def false(self) -&gt; Value:
    """Load unboxed False value (type: bool_rprimitive)."""
    return Integer(0, bool_rprimitive)
</t>
<t tx="ekr.20240308084832.1498">def none_object(self) -&gt; Value:
    """Load Python None value (type: object_rprimitive)."""
    return self.add(LoadAddress(none_object_op.type, none_object_op.src, line=-1))
</t>
<t tx="ekr.20240308084832.1499">def load_int(self, value: int) -&gt; Value:
    """Load a tagged (Python) integer literal value."""
    if value &gt; MAX_LITERAL_SHORT_INT or value &lt; MIN_LITERAL_SHORT_INT:
        return self.add(LoadLiteral(value, int_rprimitive))
    else:
        return Integer(value)
</t>
<t tx="ekr.20240308084832.15">def generate_c(
    sources: list[BuildSource],
    options: Options,
    groups: emitmodule.Groups,
    fscache: FileSystemCache,
    compiler_options: CompilerOptions,
) -&gt; tuple[list[list[tuple[str, str]]], str]:
    """Drive the actual core compilation step.

    The groups argument describes how modules are assigned to C
    extension modules. See the comments on the Groups type in
    mypyc.emitmodule for details.

    Returns the C source code and (for debugging) the pretty printed IR.
    """
    t0 = time.time()

    try:
        result = emitmodule.parse_and_typecheck(
            sources, options, compiler_options, groups, fscache
        )
    except CompileError as e:
        emit_messages(options, e.messages, time.time() - t0, serious=(not e.use_stdout))
        sys.exit(1)

    t1 = time.time()
    if result.errors:
        emit_messages(options, result.errors, t1 - t0)
        sys.exit(1)

    if compiler_options.verbose:
        print(f"Parsed and typechecked in {t1 - t0:.3f}s")

    errors = Errors(options)
    modules, ctext = emitmodule.compile_modules_to_c(
        result, compiler_options=compiler_options, errors=errors, groups=groups
    )
    t2 = time.time()
    emit_messages(options, errors.new_messages(), t2 - t1)
    if errors.num_errors:
        # No need to stop the build if only warnings were emitted.
        sys.exit(1)

    if compiler_options.verbose:
        print(f"Compiled to C in {t2 - t1:.3f}s")

    return ctext, "\n".join(format_modules(modules))
</t>
<t tx="ekr.20240308084832.150">def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1500">def load_float(self, value: float) -&gt; Value:
    """Load a float literal value."""
    return Float(value)
</t>
<t tx="ekr.20240308084832.1501">def load_str(self, value: str) -&gt; Value:
    """Load a str literal value.

    This is useful for more than just str literals; for example, method calls
    also require a PyObject * form for the name of the method.
    """
    return self.add(LoadLiteral(value, str_rprimitive))
</t>
<t tx="ekr.20240308084832.1502">def load_bytes(self, value: bytes) -&gt; Value:
    """Load a bytes literal value."""
    return self.add(LoadLiteral(value, bytes_rprimitive))
</t>
<t tx="ekr.20240308084832.1503">def load_complex(self, value: complex) -&gt; Value:
    """Load a complex literal value."""
    return self.add(LoadLiteral(value, object_rprimitive))
</t>
<t tx="ekr.20240308084832.1504">def load_static_checked(
    self,
    typ: RType,
    identifier: str,
    module_name: str | None = None,
    namespace: str = NAMESPACE_STATIC,
    line: int = -1,
    error_msg: str | None = None,
) -&gt; Value:
    if error_msg is None:
        error_msg = f'name "{identifier}" is not defined'
    ok_block, error_block = BasicBlock(), BasicBlock()
    value = self.add(LoadStatic(typ, identifier, module_name, namespace, line=line))
    self.add(Branch(value, error_block, ok_block, Branch.IS_ERROR, rare=True))
    self.activate_block(error_block)
    self.add(RaiseStandardError(RaiseStandardError.NAME_ERROR, error_msg, line))
    self.add(Unreachable())
    self.activate_block(ok_block)
    return value
</t>
<t tx="ekr.20240308084832.1505">def load_module(self, name: str) -&gt; Value:
    return self.add(LoadStatic(object_rprimitive, name, namespace=NAMESPACE_MODULE))
</t>
<t tx="ekr.20240308084832.1506">def get_native_type(self, cls: ClassIR) -&gt; Value:
    """Load native type object."""
    fullname = f"{cls.module_name}.{cls.name}"
    return self.load_native_type_object(fullname)
</t>
<t tx="ekr.20240308084832.1507">def load_native_type_object(self, fullname: str) -&gt; Value:
    module, name = fullname.rsplit(".", 1)
    return self.add(LoadStatic(object_rprimitive, name, module, NAMESPACE_TYPE))
</t>
<t tx="ekr.20240308084832.1508"># Other primitive operations

def binary_op(self, lreg: Value, rreg: Value, op: str, line: int) -&gt; Value:
    """Perform a binary operation.

    Generate specialized operations based on operand types, with a fallback
    to generic operations.
    """
    ltype = lreg.type
    rtype = rreg.type

    # Special case tuple comparison here so that nested tuples can be supported
    if isinstance(ltype, RTuple) and isinstance(rtype, RTuple) and op in ("==", "!="):
        return self.compare_tuples(lreg, rreg, op, line)

    # Special case == and != when we can resolve the method call statically
    if op in ("==", "!="):
        value = self.translate_eq_cmp(lreg, rreg, op, line)
        if value is not None:
            return value

    # Special case various ops
    if op in ("is", "is not"):
        return self.translate_is_op(lreg, rreg, op, line)
    # TODO: modify 'str' to use same interface as 'compare_bytes' as it avoids
    # call to PyErr_Occurred()
    if is_str_rprimitive(ltype) and is_str_rprimitive(rtype) and op in ("==", "!="):
        return self.compare_strings(lreg, rreg, op, line)
    if is_bytes_rprimitive(ltype) and is_bytes_rprimitive(rtype) and op in ("==", "!="):
        return self.compare_bytes(lreg, rreg, op, line)
    if is_tagged(ltype) and is_tagged(rtype) and op in int_comparison_op_mapping:
        return self.compare_tagged(lreg, rreg, op, line)
    if is_bool_rprimitive(ltype) and is_bool_rprimitive(rtype) and op in BOOL_BINARY_OPS:
        if op in ComparisonOp.signed_ops:
            return self.bool_comparison_op(lreg, rreg, op, line)
        else:
            return self.bool_bitwise_op(lreg, rreg, op[0], line)
    if isinstance(rtype, RInstance) and op in ("in", "not in"):
        return self.translate_instance_contains(rreg, lreg, op, line)
    if is_fixed_width_rtype(ltype):
        if op in FIXED_WIDTH_INT_BINARY_OPS:
            if op.endswith("="):
                op = op[:-1]
            if op != "//":
                op_id = int_op_to_id[op]
            else:
                op_id = IntOp.DIV
            if is_bool_rprimitive(rtype) or is_bit_rprimitive(rtype):
                rreg = self.coerce(rreg, ltype, line)
                rtype = ltype
            if is_fixed_width_rtype(rtype) or is_tagged(rtype):
                return self.fixed_width_int_op(ltype, lreg, rreg, op_id, line)
            if isinstance(rreg, Integer):
                return self.fixed_width_int_op(
                    ltype, lreg, self.coerce(rreg, ltype, line), op_id, line
                )
        elif op in ComparisonOp.signed_ops:
            if is_int_rprimitive(rtype):
                rreg = self.coerce_int_to_fixed_width(rreg, ltype, line)
            elif is_bool_rprimitive(rtype) or is_bit_rprimitive(rtype):
                rreg = self.coerce(rreg, ltype, line)
            op_id = ComparisonOp.signed_ops[op]
            if is_fixed_width_rtype(rreg.type):
                return self.comparison_op(lreg, rreg, op_id, line)
            if isinstance(rreg, Integer):
                return self.comparison_op(lreg, self.coerce(rreg, ltype, line), op_id, line)
    elif is_fixed_width_rtype(rtype):
        if op in FIXED_WIDTH_INT_BINARY_OPS:
            if op.endswith("="):
                op = op[:-1]
            if op != "//":
                op_id = int_op_to_id[op]
            else:
                op_id = IntOp.DIV
            if isinstance(lreg, Integer):
                return self.fixed_width_int_op(
                    rtype, self.coerce(lreg, rtype, line), rreg, op_id, line
                )
            if is_tagged(ltype):
                return self.fixed_width_int_op(rtype, lreg, rreg, op_id, line)
            if is_bool_rprimitive(ltype) or is_bit_rprimitive(ltype):
                lreg = self.coerce(lreg, rtype, line)
                return self.fixed_width_int_op(rtype, lreg, rreg, op_id, line)
        elif op in ComparisonOp.signed_ops:
            if is_int_rprimitive(ltype):
                lreg = self.coerce_int_to_fixed_width(lreg, rtype, line)
            elif is_bool_rprimitive(ltype) or is_bit_rprimitive(ltype):
                lreg = self.coerce(lreg, rtype, line)
            op_id = ComparisonOp.signed_ops[op]
            if isinstance(lreg, Integer):
                return self.comparison_op(self.coerce(lreg, rtype, line), rreg, op_id, line)
            if is_fixed_width_rtype(lreg.type):
                return self.comparison_op(lreg, rreg, op_id, line)

    # Mixed int comparisons
    if op in ("==", "!="):
        op_id = ComparisonOp.signed_ops[op]
        if is_tagged(ltype) and is_subtype(rtype, ltype):
            rreg = self.coerce(rreg, int_rprimitive, line)
            return self.comparison_op(lreg, rreg, op_id, line)
        if is_tagged(rtype) and is_subtype(ltype, rtype):
            lreg = self.coerce(lreg, int_rprimitive, line)
            return self.comparison_op(lreg, rreg, op_id, line)
    elif op in op in int_comparison_op_mapping:
        if is_tagged(ltype) and is_subtype(rtype, ltype):
            rreg = self.coerce(rreg, short_int_rprimitive, line)
            return self.compare_tagged(lreg, rreg, op, line)
        if is_tagged(rtype) and is_subtype(ltype, rtype):
            lreg = self.coerce(lreg, short_int_rprimitive, line)
            return self.compare_tagged(lreg, rreg, op, line)
    if is_float_rprimitive(ltype) or is_float_rprimitive(rtype):
        if isinstance(lreg, Integer):
            lreg = Float(float(lreg.numeric_value()))
        elif isinstance(rreg, Integer):
            rreg = Float(float(rreg.numeric_value()))
        elif is_int_rprimitive(lreg.type):
            lreg = self.int_to_float(lreg, line)
        elif is_int_rprimitive(rreg.type):
            rreg = self.int_to_float(rreg, line)
        if is_float_rprimitive(lreg.type) and is_float_rprimitive(rreg.type):
            if op in float_comparison_op_to_id:
                return self.compare_floats(lreg, rreg, float_comparison_op_to_id[op], line)
            if op.endswith("="):
                base_op = op[:-1]
            else:
                base_op = op
            if base_op in float_op_to_id:
                return self.float_op(lreg, rreg, base_op, line)

    call_c_ops_candidates = binary_ops.get(op, [])
    target = self.matching_call_c(call_c_ops_candidates, [lreg, rreg], line)
    assert target, "Unsupported binary operation: %s" % op
    return target
</t>
<t tx="ekr.20240308084832.1509">def check_tagged_short_int(self, val: Value, line: int, negated: bool = False) -&gt; Value:
    """Check if a tagged integer is a short integer.

    Return the result of the check (value of type 'bit').
    """
    int_tag = Integer(1, c_pyssize_t_rprimitive, line)
    bitwise_and = self.int_op(c_pyssize_t_rprimitive, val, int_tag, IntOp.AND, line)
    zero = Integer(0, c_pyssize_t_rprimitive, line)
    op = ComparisonOp.NEQ if negated else ComparisonOp.EQ
    check = self.comparison_op(bitwise_and, zero, op, line)
    return check
</t>
<t tx="ekr.20240308084832.151">def visit_call_c(self, op: CallC) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1510">def compare_tagged(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    """Compare two tagged integers using given operator (value context)."""
    # generate fast binary logic ops on short ints
    if is_short_int_rprimitive(lhs.type) and is_short_int_rprimitive(rhs.type):
        return self.comparison_op(lhs, rhs, int_comparison_op_mapping[op][0], line)
    op_type, c_func_desc, negate_result, swap_op = int_comparison_op_mapping[op]
    result = Register(bool_rprimitive)
    short_int_block, int_block, out = BasicBlock(), BasicBlock(), BasicBlock()
    check_lhs = self.check_tagged_short_int(lhs, line)
    if op in ("==", "!="):
        check = check_lhs
    else:
        # for non-equality logical ops (less/greater than, etc.), need to check both sides
        check_rhs = self.check_tagged_short_int(rhs, line)
        check = self.int_op(bit_rprimitive, check_lhs, check_rhs, IntOp.AND, line)
    self.add(Branch(check, short_int_block, int_block, Branch.BOOL))
    self.activate_block(short_int_block)
    eq = self.comparison_op(lhs, rhs, op_type, line)
    self.add(Assign(result, eq, line))
    self.goto(out)
    self.activate_block(int_block)
    if swap_op:
        args = [rhs, lhs]
    else:
        args = [lhs, rhs]
    call = self.call_c(c_func_desc, args, line)
    if negate_result:
        # TODO: introduce UnaryIntOp?
        call_result = self.unary_op(call, "not", line)
    else:
        call_result = call
    self.add(Assign(result, call_result, line))
    self.goto_and_activate(out)
    return result
</t>
<t tx="ekr.20240308084832.1511">def compare_tagged_condition(
    self, lhs: Value, rhs: Value, op: str, true: BasicBlock, false: BasicBlock, line: int
) -&gt; None:
    """Compare two tagged integers using given operator (conditional context).

    Assume lhs and rhs are tagged integers.

    Args:
        lhs: Left operand
        rhs: Right operand
        op: Operation, one of '==', '!=', '&lt;', '&lt;=', '&gt;', '&lt;='
        true: Branch target if comparison is true
        false: Branch target if comparison is false
    """
    is_eq = op in ("==", "!=")
    if (is_short_int_rprimitive(lhs.type) and is_short_int_rprimitive(rhs.type)) or (
        is_eq and (is_short_int_rprimitive(lhs.type) or is_short_int_rprimitive(rhs.type))
    ):
        # We can skip the tag check
        check = self.comparison_op(lhs, rhs, int_comparison_op_mapping[op][0], line)
        self.flush_keep_alives()
        self.add(Branch(check, true, false, Branch.BOOL))
        return
    op_type, c_func_desc, negate_result, swap_op = int_comparison_op_mapping[op]
    int_block, short_int_block = BasicBlock(), BasicBlock()
    check_lhs = self.check_tagged_short_int(lhs, line, negated=True)
    if is_eq or is_short_int_rprimitive(rhs.type):
        self.flush_keep_alives()
        self.add(Branch(check_lhs, int_block, short_int_block, Branch.BOOL))
    else:
        # For non-equality logical ops (less/greater than, etc.), need to check both sides
        rhs_block = BasicBlock()
        self.add(Branch(check_lhs, int_block, rhs_block, Branch.BOOL))
        self.activate_block(rhs_block)
        check_rhs = self.check_tagged_short_int(rhs, line, negated=True)
        self.flush_keep_alives()
        self.add(Branch(check_rhs, int_block, short_int_block, Branch.BOOL))
    # Arbitrary integers (slow path)
    self.activate_block(int_block)
    if swap_op:
        args = [rhs, lhs]
    else:
        args = [lhs, rhs]
    call = self.call_c(c_func_desc, args, line)
    if negate_result:
        self.add(Branch(call, false, true, Branch.BOOL))
    else:
        self.flush_keep_alives()
        self.add(Branch(call, true, false, Branch.BOOL))
    # Short integers (fast path)
    self.activate_block(short_int_block)
    eq = self.comparison_op(lhs, rhs, op_type, line)
    self.add(Branch(eq, true, false, Branch.BOOL))
</t>
<t tx="ekr.20240308084832.1512">def compare_strings(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    """Compare two strings"""
    compare_result = self.call_c(unicode_compare, [lhs, rhs], line)
    error_constant = Integer(-1, c_int_rprimitive, line)
    compare_error_check = self.add(
        ComparisonOp(compare_result, error_constant, ComparisonOp.EQ, line)
    )
    exception_check, propagate, final_compare = BasicBlock(), BasicBlock(), BasicBlock()
    branch = Branch(compare_error_check, exception_check, final_compare, Branch.BOOL)
    branch.negated = False
    self.add(branch)
    self.activate_block(exception_check)
    check_error_result = self.call_c(err_occurred_op, [], line)
    null = Integer(0, pointer_rprimitive, line)
    compare_error_check = self.add(
        ComparisonOp(check_error_result, null, ComparisonOp.NEQ, line)
    )
    branch = Branch(compare_error_check, propagate, final_compare, Branch.BOOL)
    branch.negated = False
    self.add(branch)
    self.activate_block(propagate)
    self.call_c(keep_propagating_op, [], line)
    self.goto(final_compare)
    self.activate_block(final_compare)
    op_type = ComparisonOp.EQ if op == "==" else ComparisonOp.NEQ
    return self.add(ComparisonOp(compare_result, Integer(0, c_int_rprimitive), op_type, line))
</t>
<t tx="ekr.20240308084832.1513">def compare_bytes(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    compare_result = self.call_c(bytes_compare, [lhs, rhs], line)
    op_type = ComparisonOp.EQ if op == "==" else ComparisonOp.NEQ
    return self.add(ComparisonOp(compare_result, Integer(1, c_int_rprimitive), op_type, line))
</t>
<t tx="ekr.20240308084832.1514">def compare_tuples(self, lhs: Value, rhs: Value, op: str, line: int = -1) -&gt; Value:
    """Compare two tuples item by item"""
    # type cast to pass mypy check
    assert isinstance(lhs.type, RTuple) and isinstance(rhs.type, RTuple)
    equal = True if op == "==" else False
    result = Register(bool_rprimitive)
    # empty tuples
    if len(lhs.type.types) == 0 and len(rhs.type.types) == 0:
        self.add(Assign(result, self.true() if equal else self.false(), line))
        return result
    length = len(lhs.type.types)
    false_assign, true_assign, out = BasicBlock(), BasicBlock(), BasicBlock()
    check_blocks = [BasicBlock() for _ in range(length)]
    lhs_items = [self.add(TupleGet(lhs, i, line)) for i in range(length)]
    rhs_items = [self.add(TupleGet(rhs, i, line)) for i in range(length)]

    if equal:
        early_stop, final = false_assign, true_assign
    else:
        early_stop, final = true_assign, false_assign

    for i in range(len(lhs.type.types)):
        if i != 0:
            self.activate_block(check_blocks[i])
        lhs_item = lhs_items[i]
        rhs_item = rhs_items[i]
        compare = self.binary_op(lhs_item, rhs_item, op, line)
        # Cast to bool if necessary since most types uses comparison returning a object type
        # See generic_ops.py for more information
        if not is_bool_rprimitive(compare.type):
            compare = self.call_c(bool_op, [compare], line)
        if i &lt; len(lhs.type.types) - 1:
            branch = Branch(compare, early_stop, check_blocks[i + 1], Branch.BOOL)
        else:
            branch = Branch(compare, early_stop, final, Branch.BOOL)
        # if op is ==, we branch on false, else branch on true
        branch.negated = equal
        self.add(branch)
    self.activate_block(false_assign)
    self.add(Assign(result, self.false(), line))
    self.goto(out)
    self.activate_block(true_assign)
    self.add(Assign(result, self.true(), line))
    self.goto_and_activate(out)
    return result
</t>
<t tx="ekr.20240308084832.1515">def translate_instance_contains(self, inst: Value, item: Value, op: str, line: int) -&gt; Value:
    res = self.gen_method_call(inst, "__contains__", [item], None, line)
    if not is_bool_rprimitive(res.type):
        res = self.call_c(bool_op, [res], line)
    if op == "not in":
        res = self.bool_bitwise_op(res, Integer(1, rtype=bool_rprimitive), "^", line)
    return res
</t>
<t tx="ekr.20240308084832.1516">def bool_bitwise_op(self, lreg: Value, rreg: Value, op: str, line: int) -&gt; Value:
    if op == "&amp;":
        code = IntOp.AND
    elif op == "|":
        code = IntOp.OR
    elif op == "^":
        code = IntOp.XOR
    else:
        assert False, op
    return self.add(IntOp(bool_rprimitive, lreg, rreg, code, line))
</t>
<t tx="ekr.20240308084832.1517">def bool_comparison_op(self, lreg: Value, rreg: Value, op: str, line: int) -&gt; Value:
    op_id = ComparisonOp.signed_ops[op]
    return self.comparison_op(lreg, rreg, op_id, line)
</t>
<t tx="ekr.20240308084832.1518">def unary_not(self, value: Value, line: int) -&gt; Value:
    mask = Integer(1, value.type, line)
    return self.int_op(value.type, value, mask, IntOp.XOR, line)
</t>
<t tx="ekr.20240308084832.1519">def unary_op(self, value: Value, expr_op: str, line: int) -&gt; Value:
    typ = value.type
    if is_bool_rprimitive(typ) or is_bit_rprimitive(typ):
        if expr_op == "not":
            return self.unary_not(value, line)
        if expr_op == "+":
            return value
    if is_fixed_width_rtype(typ):
        if expr_op == "-":
            # Translate to '0 - x'
            return self.int_op(typ, Integer(0, typ), value, IntOp.SUB, line)
        elif expr_op == "~":
            if typ.is_signed:
                # Translate to 'x ^ -1'
                return self.int_op(typ, value, Integer(-1, typ), IntOp.XOR, line)
            else:
                # Translate to 'x ^ 0xff...'
                mask = (1 &lt;&lt; (typ.size * 8)) - 1
                return self.int_op(typ, value, Integer(mask, typ), IntOp.XOR, line)
        elif expr_op == "+":
            return value
    if is_float_rprimitive(typ):
        if expr_op == "-":
            return self.add(FloatNeg(value, line))
        elif expr_op == "+":
            return value

    if isinstance(value, Integer):
        # TODO: Overflow? Unsigned?
        num = value.value
        if is_short_int_rprimitive(typ):
            num &gt;&gt;= 1
        return Integer(-num, typ, value.line)
    if is_tagged(typ) and expr_op == "+":
        return value
    if isinstance(value, Float):
        return Float(-value.value, value.line)
    if isinstance(typ, RInstance):
        if expr_op == "-":
            method = "__neg__"
        elif expr_op == "+":
            method = "__pos__"
        elif expr_op == "~":
            method = "__invert__"
        else:
            method = ""
        if method and typ.class_ir.has_method(method):
            return self.gen_method_call(value, method, [], None, line)
    call_c_ops_candidates = unary_ops.get(expr_op, [])
    target = self.matching_call_c(call_c_ops_candidates, [value], line)
    assert target, "Unsupported unary operation: %s" % expr_op
    return target
</t>
<t tx="ekr.20240308084832.152">def visit_truncate(self, op: Truncate) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1520">def make_dict(self, key_value_pairs: Sequence[DictEntry], line: int) -&gt; Value:
    result: Value | None = None
    keys: list[Value] = []
    values: list[Value] = []
    for key, value in key_value_pairs:
        if key is not None:
            # key:value
            if result is None:
                keys.append(key)
                values.append(value)
                continue

            self.translate_special_method_call(
                result, "__setitem__", [key, value], result_type=None, line=line
            )
        else:
            # **value
            if result is None:
                result = self._create_dict(keys, values, line)

            self.call_c(dict_update_in_display_op, [result, value], line=line)

    if result is None:
        result = self._create_dict(keys, values, line)

    return result
</t>
<t tx="ekr.20240308084832.1521">def new_list_op_with_length(self, length: Value, line: int) -&gt; Value:
    """This function returns an uninitialized list.

    If the length is non-zero, the caller must initialize the list, before
    it can be made visible to user code -- otherwise the list object is broken.
    You might need further initialization with `new_list_set_item_op` op.

    Args:
        length: desired length of the new list. The rtype should be
                c_pyssize_t_rprimitive
        line: line number
    """
    return self.call_c(new_list_op, [length], line)
</t>
<t tx="ekr.20240308084832.1522">def new_list_op(self, values: list[Value], line: int) -&gt; Value:
    length: list[Value] = [Integer(len(values), c_pyssize_t_rprimitive, line)]
    if len(values) &gt;= LIST_BUILDING_EXPANSION_THRESHOLD:
        return self.call_c(list_build_op, length + values, line)

    # If the length of the list is less than the threshold,
    # LIST_BUILDING_EXPANSION_THRESHOLD, we directly expand the
    # for-loop and inline the SetMem operation, which is faster
    # than list_build_op, however generates more code.
    result_list = self.call_c(new_list_op, length, line)
    if not values:
        return result_list
    args = [self.coerce(item, object_rprimitive, line) for item in values]
    ob_item_ptr = self.add(GetElementPtr(result_list, PyListObject, "ob_item", line))
    ob_item_base = self.add(LoadMem(pointer_rprimitive, ob_item_ptr, line))
    for i in range(len(values)):
        if i == 0:
            item_address = ob_item_base
        else:
            offset = Integer(PLATFORM_SIZE * i, c_pyssize_t_rprimitive, line)
            item_address = self.add(
                IntOp(pointer_rprimitive, ob_item_base, offset, IntOp.ADD, line)
            )
        self.add(SetMem(object_rprimitive, item_address, args[i], line))
    self.add(KeepAlive([result_list]))
    return result_list
</t>
<t tx="ekr.20240308084832.1523">def new_set_op(self, values: list[Value], line: int) -&gt; Value:
    return self.call_c(new_set_op, values, line)
</t>
<t tx="ekr.20240308084832.1524">def setup_rarray(
    self, item_type: RType, values: Sequence[Value], *, object_ptr: bool = False
) -&gt; Value:
    """Declare and initialize a new RArray, returning its address."""
    array = Register(RArray(item_type, len(values)))
    self.add(AssignMulti(array, list(values)))
    return self.add(
        LoadAddress(object_pointer_rprimitive if object_ptr else c_pointer_rprimitive, array)
    )
</t>
<t tx="ekr.20240308084832.1525">def shortcircuit_helper(
    self,
    op: str,
    expr_type: RType,
    left: Callable[[], Value],
    right: Callable[[], Value],
    line: int,
) -&gt; Value:
    # Having actual Phi nodes would be really nice here!
    target = Register(expr_type)
    # left_body takes the value of the left side, right_body the right
    left_body, right_body, next_block = BasicBlock(), BasicBlock(), BasicBlock()
    # true_body is taken if the left is true, false_body if it is false.
    # For 'and' the value is the right side if the left is true, and for 'or'
    # it is the right side if the left is false.
    true_body, false_body = (right_body, left_body) if op == "and" else (left_body, right_body)

    left_value = left()
    self.add_bool_branch(left_value, true_body, false_body)

    self.activate_block(left_body)
    left_coerced = self.coerce(left_value, expr_type, line)
    self.add(Assign(target, left_coerced))
    self.goto(next_block)

    self.activate_block(right_body)
    right_value = right()
    right_coerced = self.coerce(right_value, expr_type, line)
    self.add(Assign(target, right_coerced))
    self.goto(next_block)

    self.activate_block(next_block)
    return target
</t>
<t tx="ekr.20240308084832.1526">def bool_value(self, value: Value) -&gt; Value:
    """Return bool(value).

    The result type can be bit_rprimitive or bool_rprimitive.
    """
    if is_bool_rprimitive(value.type) or is_bit_rprimitive(value.type):
        result = value
    elif is_runtime_subtype(value.type, int_rprimitive):
        zero = Integer(0, short_int_rprimitive)
        result = self.comparison_op(value, zero, ComparisonOp.NEQ, value.line)
    elif is_fixed_width_rtype(value.type):
        zero = Integer(0, value.type)
        result = self.add(ComparisonOp(value, zero, ComparisonOp.NEQ))
    elif is_same_type(value.type, str_rprimitive):
        result = self.call_c(str_check_if_true, [value], value.line)
    elif is_same_type(value.type, list_rprimitive) or is_same_type(
        value.type, dict_rprimitive
    ):
        length = self.builtin_len(value, value.line)
        zero = Integer(0)
        result = self.binary_op(length, zero, "!=", value.line)
    elif (
        isinstance(value.type, RInstance)
        and value.type.class_ir.is_ext_class
        and value.type.class_ir.has_method("__bool__")
    ):
        # Directly call the __bool__ method on classes that have it.
        result = self.gen_method_call(value, "__bool__", [], bool_rprimitive, value.line)
    elif is_float_rprimitive(value.type):
        result = self.compare_floats(value, Float(0.0), FloatComparisonOp.NEQ, value.line)
    else:
        value_type = optional_value_type(value.type)
        if value_type is not None:
            not_none = self.translate_is_op(value, self.none_object(), "is not", value.line)
            always_truthy = False
            if isinstance(value_type, RInstance):
                # check whether X.__bool__ is always just the default (object.__bool__)
                if not value_type.class_ir.has_method(
                    "__bool__"
                ) and value_type.class_ir.is_method_final("__bool__"):
                    always_truthy = True

            if always_truthy:
                result = not_none
            else:
                # "X | None" where X may be falsey and requires a check
                result = Register(bit_rprimitive)
                true, false, end = BasicBlock(), BasicBlock(), BasicBlock()
                branch = Branch(not_none, true, false, Branch.BOOL)
                self.add(branch)
                self.activate_block(true)
                # unbox_or_cast instead of coerce because we want the
                # type to change even if it is a subtype.
                remaining = self.unbox_or_cast(value, value_type, value.line)
                as_bool = self.bool_value(remaining)
                self.add(Assign(result, as_bool))
                self.goto(end)
                self.activate_block(false)
                self.add(Assign(result, Integer(0, bit_rprimitive)))
                self.goto(end)
                self.activate_block(end)
        else:
            result = self.call_c(bool_op, [value], value.line)
    return result
</t>
<t tx="ekr.20240308084832.1527">def add_bool_branch(self, value: Value, true: BasicBlock, false: BasicBlock) -&gt; None:
    opt_value_type = optional_value_type(value.type)
    if opt_value_type is None:
        bool_value = self.bool_value(value)
        self.add(Branch(bool_value, true, false, Branch.BOOL))
    else:
        # Special-case optional types
        is_none = self.translate_is_op(value, self.none_object(), "is not", value.line)
        branch = Branch(is_none, true, false, Branch.BOOL)
        self.add(branch)
        always_truthy = False
        if isinstance(opt_value_type, RInstance):
            # check whether X.__bool__ is always just the default (object.__bool__)
            if not opt_value_type.class_ir.has_method(
                "__bool__"
            ) and opt_value_type.class_ir.is_method_final("__bool__"):
                always_truthy = True

        if not always_truthy:
            # Optional[X] where X may be falsey and requires a check
            branch.true = BasicBlock()
            self.activate_block(branch.true)
            # unbox_or_cast instead of coerce because we want the
            # type to change even if it is a subtype.
            remaining = self.unbox_or_cast(value, opt_value_type, value.line)
            self.add_bool_branch(remaining, true, false)
</t>
<t tx="ekr.20240308084832.1528">def call_c(
    self,
    desc: CFunctionDescription,
    args: list[Value],
    line: int,
    result_type: RType | None = None,
) -&gt; Value:
    """Call function using C/native calling convention (not a Python callable)."""
    # Handle void function via singleton RVoid instance
    coerced = []
    # Coerce fixed number arguments
    for i in range(min(len(args), len(desc.arg_types))):
        formal_type = desc.arg_types[i]
        arg = args[i]
        arg = self.coerce(arg, formal_type, line)
        coerced.append(arg)
    # Reorder args if necessary
    if desc.ordering is not None:
        assert desc.var_arg_type is None
        coerced = [coerced[i] for i in desc.ordering]
    # Coerce any var_arg
    var_arg_idx = -1
    if desc.var_arg_type is not None:
        var_arg_idx = len(desc.arg_types)
        for i in range(len(desc.arg_types), len(args)):
            arg = args[i]
            arg = self.coerce(arg, desc.var_arg_type, line)
            coerced.append(arg)
    # Add extra integer constant if any
    for item in desc.extra_int_constants:
        val, typ = item
        extra_int_constant = Integer(val, typ, line)
        coerced.append(extra_int_constant)
    error_kind = desc.error_kind
    if error_kind == ERR_NEG_INT:
        # Handled with an explicit comparison
        error_kind = ERR_NEVER
    target = self.add(
        CallC(
            desc.c_function_name,
            coerced,
            desc.return_type,
            desc.steals,
            desc.is_borrowed,
            error_kind,
            line,
            var_arg_idx,
        )
    )
    if desc.is_borrowed:
        # If the result is borrowed, force the arguments to be
        # kept alive afterwards, as otherwise the result might be
        # immediately freed, at the risk of a dangling pointer.
        for arg in coerced:
            if not isinstance(arg, (Integer, LoadLiteral)):
                self.keep_alives.append(arg)
    if desc.error_kind == ERR_NEG_INT:
        comp = ComparisonOp(target, Integer(0, desc.return_type, line), ComparisonOp.SGE, line)
        comp.error_kind = ERR_FALSE
        self.add(comp)

    if desc.truncated_type is None:
        result = target
    else:
        truncate = self.add(Truncate(target, desc.truncated_type))
        result = truncate
    if result_type and not is_runtime_subtype(result.type, result_type):
        if is_none_rprimitive(result_type):
            # Special case None return. The actual result may actually be a bool
            # and so we can't just coerce it.
            result = self.none()
        else:
            result = self.coerce(target, result_type, line, can_borrow=desc.is_borrowed)
    return result
</t>
<t tx="ekr.20240308084832.1529">def matching_call_c(
    self,
    candidates: list[CFunctionDescription],
    args: list[Value],
    line: int,
    result_type: RType | None = None,
    can_borrow: bool = False,
) -&gt; Value | None:
    matching: CFunctionDescription | None = None
    for desc in candidates:
        if len(desc.arg_types) != len(args):
            continue
        if all(
            is_subtype(actual.type, formal) for actual, formal in zip(args, desc.arg_types)
        ) and (not desc.is_borrowed or can_borrow):
            if matching:
                assert matching.priority != desc.priority, "Ambiguous:\n1) {}\n2) {}".format(
                    matching, desc
                )
                if desc.priority &gt; matching.priority:
                    matching = desc
            else:
                matching = desc
    if matching:
        target = self.call_c(matching, args, line, result_type)
        return target
    return None
</t>
<t tx="ekr.20240308084832.153">def visit_extend(self, op: Extend) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1530">def int_op(self, type: RType, lhs: Value, rhs: Value, op: int, line: int = -1) -&gt; Value:
    """Generate a native integer binary op.

    Use native/C semantics, which sometimes differ from Python
    semantics.

    Args:
        type: Either int64_rprimitive or int32_rprimitive
        op: IntOp.* constant (e.g. IntOp.ADD)
    """
    return self.add(IntOp(type, lhs, rhs, op, line))
</t>
<t tx="ekr.20240308084832.1531">def float_op(self, lhs: Value, rhs: Value, op: str, line: int) -&gt; Value:
    """Generate a native float binary arithmetic operation.

    This follows Python semantics (e.g. raise exception on division by zero).
    Add a FloatOp directly if you want low-level semantics.

    Args:
        op: Binary operator (e.g. '+' or '*')
    """
    op_id = float_op_to_id[op]
    if op_id in (FloatOp.DIV, FloatOp.MOD):
        if not (isinstance(rhs, Float) and rhs.value != 0.0):
            c = self.compare_floats(rhs, Float(0.0), FloatComparisonOp.EQ, line)
            err, ok = BasicBlock(), BasicBlock()
            self.add(Branch(c, err, ok, Branch.BOOL, rare=True))
            self.activate_block(err)
            if op_id == FloatOp.DIV:
                msg = "float division by zero"
            else:
                msg = "float modulo"
            self.add(RaiseStandardError(RaiseStandardError.ZERO_DIVISION_ERROR, msg, line))
            self.add(Unreachable())
            self.activate_block(ok)
    if op_id == FloatOp.MOD:
        # Adjust the result to match Python semantics (FloatOp follows C semantics).
        return self.float_mod(lhs, rhs, line)
    else:
        return self.add(FloatOp(lhs, rhs, op_id, line))
</t>
<t tx="ekr.20240308084832.1532">def float_mod(self, lhs: Value, rhs: Value, line: int) -&gt; Value:
    """Perform x % y on floats using Python semantics."""
    mod = self.add(FloatOp(lhs, rhs, FloatOp.MOD, line))
    res = Register(float_rprimitive)
    self.add(Assign(res, mod))
    tricky, adjust, copysign, done = BasicBlock(), BasicBlock(), BasicBlock(), BasicBlock()
    is_zero = self.add(FloatComparisonOp(res, Float(0.0), FloatComparisonOp.EQ, line))
    self.add(Branch(is_zero, copysign, tricky, Branch.BOOL))
    self.activate_block(tricky)
    same_signs = self.is_same_float_signs(lhs, rhs, line)
    self.add(Branch(same_signs, done, adjust, Branch.BOOL))
    self.activate_block(adjust)
    adj = self.float_op(res, rhs, "+", line)
    self.add(Assign(res, adj))
    self.add(Goto(done))
    self.activate_block(copysign)
    # If the remainder is zero, CPython ensures the result has the
    # same sign as the denominator.
    adj = self.call_c(copysign_op, [Float(0.0), rhs], line)
    self.add(Assign(res, adj))
    self.add(Goto(done))
    self.activate_block(done)
    return res
</t>
<t tx="ekr.20240308084832.1533">def compare_floats(self, lhs: Value, rhs: Value, op: int, line: int) -&gt; Value:
    return self.add(FloatComparisonOp(lhs, rhs, op, line))
</t>
<t tx="ekr.20240308084832.1534">def fixed_width_int_op(
    self, type: RPrimitive, lhs: Value, rhs: Value, op: int, line: int
) -&gt; Value:
    """Generate a binary op using Python fixed-width integer semantics.

    These may differ in overflow/rounding behavior from native/C ops.

    Args:
        type: Either int64_rprimitive or int32_rprimitive
        op: IntOp.* constant (e.g. IntOp.ADD)
    """
    lhs = self.coerce(lhs, type, line)
    rhs = self.coerce(rhs, type, line)
    if op == IntOp.DIV:
        if isinstance(rhs, Integer) and rhs.value not in (-1, 0):
            if not type.is_signed:
                return self.int_op(type, lhs, rhs, IntOp.DIV, line)
            else:
                # Inline simple division by a constant, so that C
                # compilers can optimize more
                return self.inline_fixed_width_divide(type, lhs, rhs, line)
        if is_int64_rprimitive(type):
            prim = int64_divide_op
        elif is_int32_rprimitive(type):
            prim = int32_divide_op
        elif is_int16_rprimitive(type):
            prim = int16_divide_op
        elif is_uint8_rprimitive(type):
            self.check_for_zero_division(rhs, type, line)
            return self.int_op(type, lhs, rhs, op, line)
        else:
            assert False, type
        return self.call_c(prim, [lhs, rhs], line)
    if op == IntOp.MOD:
        if isinstance(rhs, Integer) and rhs.value not in (-1, 0):
            if not type.is_signed:
                return self.int_op(type, lhs, rhs, IntOp.MOD, line)
            else:
                # Inline simple % by a constant, so that C
                # compilers can optimize more
                return self.inline_fixed_width_mod(type, lhs, rhs, line)
        if is_int64_rprimitive(type):
            prim = int64_mod_op
        elif is_int32_rprimitive(type):
            prim = int32_mod_op
        elif is_int16_rprimitive(type):
            prim = int16_mod_op
        elif is_uint8_rprimitive(type):
            self.check_for_zero_division(rhs, type, line)
            return self.int_op(type, lhs, rhs, op, line)
        else:
            assert False, type
        return self.call_c(prim, [lhs, rhs], line)
    return self.int_op(type, lhs, rhs, op, line)
</t>
<t tx="ekr.20240308084832.1535">def check_for_zero_division(self, rhs: Value, type: RType, line: int) -&gt; None:
    err, ok = BasicBlock(), BasicBlock()
    is_zero = self.binary_op(rhs, Integer(0, type), "==", line)
    self.add(Branch(is_zero, err, ok, Branch.BOOL))
    self.activate_block(err)
    self.add(
        RaiseStandardError(
            RaiseStandardError.ZERO_DIVISION_ERROR, "integer division or modulo by zero", line
        )
    )
    self.add(Unreachable())
    self.activate_block(ok)
</t>
<t tx="ekr.20240308084832.1536">def inline_fixed_width_divide(self, type: RType, lhs: Value, rhs: Value, line: int) -&gt; Value:
    # Perform floor division (native division truncates)
    res = Register(type)
    div = self.int_op(type, lhs, rhs, IntOp.DIV, line)
    self.add(Assign(res, div))
    same_signs = self.is_same_native_int_signs(type, lhs, rhs, line)
    tricky, adjust, done = BasicBlock(), BasicBlock(), BasicBlock()
    self.add(Branch(same_signs, done, tricky, Branch.BOOL))
    self.activate_block(tricky)
    mul = self.int_op(type, res, rhs, IntOp.MUL, line)
    mul_eq = self.add(ComparisonOp(mul, lhs, ComparisonOp.EQ, line))
    self.add(Branch(mul_eq, done, adjust, Branch.BOOL))
    self.activate_block(adjust)
    adj = self.int_op(type, res, Integer(1, type), IntOp.SUB, line)
    self.add(Assign(res, adj))
    self.add(Goto(done))
    self.activate_block(done)
    return res
</t>
<t tx="ekr.20240308084832.1537">def inline_fixed_width_mod(self, type: RType, lhs: Value, rhs: Value, line: int) -&gt; Value:
    # Perform floor modulus
    res = Register(type)
    mod = self.int_op(type, lhs, rhs, IntOp.MOD, line)
    self.add(Assign(res, mod))
    same_signs = self.is_same_native_int_signs(type, lhs, rhs, line)
    tricky, adjust, done = BasicBlock(), BasicBlock(), BasicBlock()
    self.add(Branch(same_signs, done, tricky, Branch.BOOL))
    self.activate_block(tricky)
    is_zero = self.add(ComparisonOp(res, Integer(0, type), ComparisonOp.EQ, line))
    self.add(Branch(is_zero, done, adjust, Branch.BOOL))
    self.activate_block(adjust)
    adj = self.int_op(type, res, rhs, IntOp.ADD, line)
    self.add(Assign(res, adj))
    self.add(Goto(done))
    self.activate_block(done)
    return res
</t>
<t tx="ekr.20240308084832.1538">def is_same_native_int_signs(self, type: RType, a: Value, b: Value, line: int) -&gt; Value:
    neg1 = self.add(ComparisonOp(a, Integer(0, type), ComparisonOp.SLT, line))
    neg2 = self.add(ComparisonOp(b, Integer(0, type), ComparisonOp.SLT, line))
    return self.add(ComparisonOp(neg1, neg2, ComparisonOp.EQ, line))
</t>
<t tx="ekr.20240308084832.1539">def is_same_float_signs(self, a: Value, b: Value, line: int) -&gt; Value:
    neg1 = self.add(FloatComparisonOp(a, Float(0.0), FloatComparisonOp.LT, line))
    neg2 = self.add(FloatComparisonOp(b, Float(0.0), FloatComparisonOp.LT, line))
    return self.add(ComparisonOp(neg1, neg2, ComparisonOp.EQ, line))
</t>
<t tx="ekr.20240308084832.154">def visit_load_global(self, op: LoadGlobal) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1540">def comparison_op(self, lhs: Value, rhs: Value, op: int, line: int) -&gt; Value:
    return self.add(ComparisonOp(lhs, rhs, op, line))
</t>
<t tx="ekr.20240308084832.1541">def builtin_len(self, val: Value, line: int, use_pyssize_t: bool = False) -&gt; Value:
    """Generate len(val).

    Return short_int_rprimitive by default.
    Return c_pyssize_t if use_pyssize_t is true (unshifted).
    """
    typ = val.type
    size_value = None
    if is_list_rprimitive(typ) or is_tuple_rprimitive(typ) or is_bytes_rprimitive(typ):
        elem_address = self.add(GetElementPtr(val, PyVarObject, "ob_size"))
        size_value = self.add(LoadMem(c_pyssize_t_rprimitive, elem_address))
        self.add(KeepAlive([val]))
    elif is_set_rprimitive(typ):
        elem_address = self.add(GetElementPtr(val, PySetObject, "used"))
        size_value = self.add(LoadMem(c_pyssize_t_rprimitive, elem_address))
        self.add(KeepAlive([val]))
    elif is_dict_rprimitive(typ):
        size_value = self.call_c(dict_ssize_t_size_op, [val], line)
    elif is_str_rprimitive(typ):
        size_value = self.call_c(str_ssize_t_size_op, [val], line)

    if size_value is not None:
        if use_pyssize_t:
            return size_value
        offset = Integer(1, c_pyssize_t_rprimitive, line)
        return self.int_op(short_int_rprimitive, size_value, offset, IntOp.LEFT_SHIFT, line)

    if isinstance(typ, RInstance):
        # TODO: Support use_pyssize_t
        assert not use_pyssize_t
        length = self.gen_method_call(val, "__len__", [], int_rprimitive, line)
        length = self.coerce(length, int_rprimitive, line)
        ok, fail = BasicBlock(), BasicBlock()
        self.compare_tagged_condition(length, Integer(0), "&gt;=", ok, fail, line)
        self.activate_block(fail)
        self.add(
            RaiseStandardError(
                RaiseStandardError.VALUE_ERROR, "__len__() should return &gt;= 0", line
            )
        )
        self.add(Unreachable())
        self.activate_block(ok)
        return length

    # generic case
    if use_pyssize_t:
        return self.call_c(generic_ssize_t_len_op, [val], line)
    else:
        return self.call_c(generic_len_op, [val], line)
</t>
<t tx="ekr.20240308084832.1542">def new_tuple(self, items: list[Value], line: int) -&gt; Value:
    size: Value = Integer(len(items), c_pyssize_t_rprimitive)
    return self.call_c(new_tuple_op, [size] + items, line)
</t>
<t tx="ekr.20240308084832.1543">def new_tuple_with_length(self, length: Value, line: int) -&gt; Value:
    """This function returns an uninitialized tuple.

    If the length is non-zero, the caller must initialize the tuple, before
    it can be made visible to user code -- otherwise the tuple object is broken.
    You might need further initialization with `new_tuple_set_item_op` op.

    Args:
        length: desired length of the new tuple. The rtype should be
                c_pyssize_t_rprimitive
        line: line number
    """
    return self.call_c(new_tuple_with_length_op, [length], line)
</t>
<t tx="ekr.20240308084832.1544">def int_to_float(self, n: Value, line: int) -&gt; Value:
    return self.call_c(int_to_float_op, [n], line)
</t>
<t tx="ekr.20240308084832.1545"># Internal helpers

def decompose_union_helper(
    self,
    obj: Value,
    rtype: RUnion,
    result_type: RType,
    process_item: Callable[[Value], Value],
    line: int,
) -&gt; Value:
    """Generate isinstance() + specialized operations for union items.

    Say, for Union[A, B] generate ops resembling this (pseudocode):

        if isinstance(obj, A):
            result = &lt;result of process_item(cast(A, obj)&gt;
        else:
            result = &lt;result of process_item(cast(B, obj)&gt;

    Args:
        obj: value with a union type
        rtype: the union type
        result_type: result of the operation
        process_item: callback to generate op for a single union item (arg is coerced
            to union item type)
        line: line number
    """
    # TODO: Optimize cases where a single operation can handle multiple union items
    #     (say a method is implemented in a common base class)
    fast_items = []
    rest_items = []
    for item in rtype.items:
        if isinstance(item, RInstance):
            fast_items.append(item)
        else:
            # For everything but RInstance we fall back to C API
            rest_items.append(item)
    exit_block = BasicBlock()
    result = Register(result_type)
    for i, item in enumerate(fast_items):
        more_types = i &lt; len(fast_items) - 1 or rest_items
        if more_types:
            # We are not at the final item so we need one more branch
            op = self.isinstance_native(obj, item.class_ir, line)
            true_block, false_block = BasicBlock(), BasicBlock()
            self.add_bool_branch(op, true_block, false_block)
            self.activate_block(true_block)
        coerced = self.coerce(obj, item, line)
        temp = process_item(coerced)
        temp2 = self.coerce(temp, result_type, line)
        self.add(Assign(result, temp2))
        self.goto(exit_block)
        if more_types:
            self.activate_block(false_block)
    if rest_items:
        # For everything else we use generic operation. Use force=True to drop the
        # union type.
        coerced = self.coerce(obj, object_rprimitive, line, force=True)
        temp = process_item(coerced)
        temp2 = self.coerce(temp, result_type, line)
        self.add(Assign(result, temp2))
        self.goto(exit_block)
    self.activate_block(exit_block)
    return result
</t>
<t tx="ekr.20240308084832.1546">def translate_special_method_call(
    self,
    base_reg: Value,
    name: str,
    args: list[Value],
    result_type: RType | None,
    line: int,
    can_borrow: bool = False,
) -&gt; Value | None:
    """Translate a method call which is handled nongenerically.

    These are special in the sense that we have code generated specifically for them.
    They tend to be method calls which have equivalents in C that are more direct
    than calling with the PyObject api.

    Return None if no translation found; otherwise return the target register.
    """
    call_c_ops_candidates = method_call_ops.get(name, [])
    call_c_op = self.matching_call_c(
        call_c_ops_candidates, [base_reg] + args, line, result_type, can_borrow=can_borrow
    )
    return call_c_op
</t>
<t tx="ekr.20240308084832.1547">def translate_eq_cmp(self, lreg: Value, rreg: Value, expr_op: str, line: int) -&gt; Value | None:
    """Add a equality comparison operation.

    Args:
        expr_op: either '==' or '!='
    """
    ltype = lreg.type
    rtype = rreg.type
    if not (isinstance(ltype, RInstance) and ltype == rtype):
        return None

    class_ir = ltype.class_ir
    # Check whether any subclasses of the operand redefines __eq__
    # or it might be redefined in a Python parent class or by
    # dataclasses
    cmp_varies_at_runtime = (
        not class_ir.is_method_final("__eq__")
        or not class_ir.is_method_final("__ne__")
        or class_ir.inherits_python
        or class_ir.is_augmented
    )

    if cmp_varies_at_runtime:
        # We might need to call left.__eq__(right) or right.__eq__(left)
        # depending on which is the more specific type.
        return None

    if not class_ir.has_method("__eq__"):
        # There's no __eq__ defined, so just use object identity.
        identity_ref_op = "is" if expr_op == "==" else "is not"
        return self.translate_is_op(lreg, rreg, identity_ref_op, line)

    return self.gen_method_call(lreg, op_methods[expr_op], [rreg], ltype, line)
</t>
<t tx="ekr.20240308084832.1548">def translate_is_op(self, lreg: Value, rreg: Value, expr_op: str, line: int) -&gt; Value:
    """Create equality comparison operation between object identities

    Args:
        expr_op: either 'is' or 'is not'
    """
    op = ComparisonOp.EQ if expr_op == "is" else ComparisonOp.NEQ
    lhs = self.coerce(lreg, object_rprimitive, line)
    rhs = self.coerce(rreg, object_rprimitive, line)
    return self.add(ComparisonOp(lhs, rhs, op, line))
</t>
<t tx="ekr.20240308084832.1549">def _create_dict(self, keys: list[Value], values: list[Value], line: int) -&gt; Value:
    """Create a dictionary(possibly empty) using keys and values"""
    # keys and values should have the same number of items
    size = len(keys)
    if size &gt; 0:
        size_value: Value = Integer(size, c_pyssize_t_rprimitive)
        # merge keys and values
        items = [i for t in list(zip(keys, values)) for i in t]
        return self.call_c(dict_build_op, [size_value] + items, line)
    else:
        return self.call_c(dict_new_op, [], line)
</t>
<t tx="ekr.20240308084832.155">def visit_int_op(self, op: IntOp) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1550">def error(self, msg: str, line: int) -&gt; None:
    self.errors.error(msg, self.module_path, line)
</t>
<t tx="ekr.20240308084832.1551">def num_positional_args(arg_values: list[Value], arg_kinds: list[ArgKind] | None) -&gt; int:
    if arg_kinds is None:
        return len(arg_values)
    num_pos = 0
    for kind in arg_kinds:
        if kind == ARG_POS:
            num_pos += 1
    return num_pos
</t>
<t tx="ekr.20240308084832.1552">"""Transform a mypy AST to the IR form (Intermediate Representation).

For example, consider a function like this:

   def f(x: int) -&gt; int:
       return x * 2 + 1

It would be translated to something that conceptually looks like this:

   r0 = 2
   r1 = 1
   r2 = x * r0 :: int
   r3 = r2 + r1 :: int
   return r3

This module deals with the module-level IR transformation logic and
putting it all together. The actual IR is implemented in mypyc.ir.

For the core of the IR transform implementation, look at build_ir()
below, mypyc.irbuild.builder, and mypyc.irbuild.visitor.
"""

from __future__ import annotations

from typing import Any, Callable, TypeVar, cast

from mypy.build import Graph
from mypy.nodes import ClassDef, Expression, MypyFile
from mypy.state import state
from mypy.types import Type
from mypyc.analysis.attrdefined import analyze_always_defined_attrs
from mypyc.common import TOP_LEVEL_NAME
from mypyc.errors import Errors
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature
from mypyc.ir.module_ir import ModuleIR, ModuleIRs
from mypyc.ir.rtypes import none_rprimitive
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.mapper import Mapper
from mypyc.irbuild.prebuildvisitor import PreBuildVisitor
from mypyc.irbuild.prepare import build_type_map, find_singledispatch_register_impls
from mypyc.irbuild.visitor import IRBuilderVisitor
from mypyc.irbuild.vtable import compute_vtable
from mypyc.options import CompilerOptions

# The stubs for callable contextmanagers are busted so cast it to the
# right type...
F = TypeVar("F", bound=Callable[..., Any])
strict_optional_dec = cast(Callable[[F], F], state.strict_optional_set(True))


@strict_optional_dec  # Turn on strict optional for any type manipulations we do
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1553">def build_ir(
    modules: list[MypyFile],
    graph: Graph,
    types: dict[Expression, Type],
    mapper: Mapper,
    options: CompilerOptions,
    errors: Errors,
) -&gt; ModuleIRs:
    """Build basic IR for a set of modules that have been type-checked by mypy.

    The returned IR is not complete and requires additional
    transformations, such as the insertion of refcount handling.
    """

    build_type_map(mapper, modules, graph, types, options, errors)
    singledispatch_info = find_singledispatch_register_impls(modules, errors)

    result: ModuleIRs = {}

    # Generate IR for all modules.
    class_irs = []

    for module in modules:
        # First pass to determine free symbols.
        pbv = PreBuildVisitor(errors, module, singledispatch_info.decorators_to_remove)
        module.accept(pbv)

        # Construct and configure builder objects (cyclic runtime dependency).
        visitor = IRBuilderVisitor()
        builder = IRBuilder(
            module.fullname,
            types,
            graph,
            errors,
            mapper,
            pbv,
            visitor,
            options,
            singledispatch_info.singledispatch_impls,
        )
        visitor.builder = builder

        # Second pass does the bulk of the work.
        transform_mypy_file(builder, module)
        module_ir = ModuleIR(
            module.fullname,
            list(builder.imports),
            builder.functions,
            builder.classes,
            builder.final_names,
        )
        result[module.fullname] = module_ir
        class_irs.extend(builder.classes)

    analyze_always_defined_attrs(class_irs)

    # Compute vtables.
    for cir in class_irs:
        if cir.is_ext_class:
            compute_vtable(cir)

    return result
</t>
<t tx="ekr.20240308084832.1554">def transform_mypy_file(builder: IRBuilder, mypyfile: MypyFile) -&gt; None:
    """Generate IR for a single module."""

    if mypyfile.fullname in ("typing", "abc"):
        # These module are special; their contents are currently all
        # built-in primitives.
        return

    builder.set_module(mypyfile.fullname, mypyfile.path)

    classes = [node for node in mypyfile.defs if isinstance(node, ClassDef)]

    # Collect all classes.
    for cls in classes:
        ir = builder.mapper.type_to_ir[cls.info]
        builder.classes.append(ir)

    builder.enter("&lt;module&gt;")

    # Make sure we have a builtins import
    builder.gen_import("builtins", -1)

    # Generate ops.
    for node in mypyfile.defs:
        builder.accept(node)

    builder.maybe_add_implicit_return()

    # Generate special function representing module top level.
    args, _, blocks, ret_type, _ = builder.leave()
    sig = FuncSignature([], none_rprimitive)
    func_ir = FuncIR(
        FuncDecl(TOP_LEVEL_NAME, None, builder.module_name, sig),
        args,
        blocks,
        traceback_name="&lt;module&gt;",
    )
    builder.functions.append(func_ir)
</t>
<t tx="ekr.20240308084832.1555">"""Maintain a mapping from mypy concepts to IR/compiled concepts."""

from __future__ import annotations

from mypy.nodes import ARG_STAR, ARG_STAR2, GDEF, ArgKind, FuncDef, RefExpr, SymbolNode, TypeInfo
from mypy.types import (
    AnyType,
    CallableType,
    Instance,
    LiteralType,
    NoneTyp,
    Overloaded,
    PartialType,
    TupleType,
    Type,
    TypedDictType,
    TypeType,
    TypeVarType,
    UnboundType,
    UninhabitedType,
    UnionType,
    find_unpack_in_list,
    get_proper_type,
)
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncSignature, RuntimeArg
from mypyc.ir.rtypes import (
    RInstance,
    RTuple,
    RType,
    RUnion,
    bool_rprimitive,
    bytes_rprimitive,
    dict_rprimitive,
    float_rprimitive,
    int16_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    list_rprimitive,
    none_rprimitive,
    object_rprimitive,
    range_rprimitive,
    set_rprimitive,
    str_rprimitive,
    tuple_rprimitive,
    uint8_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1556">class Mapper:
    """Keep track of mappings from mypy concepts to IR concepts.
    
    For example, we keep track of how the mypy TypeInfos of compiled
    classes map to class IR objects.
    
    This state is shared across all modules being compiled in all
    compilation groups.
    """
    @others
</t>
<t tx="ekr.20240308084832.1557">def __init__(self, group_map: dict[str, str | None]) -&gt; None:
    self.group_map = group_map
    self.type_to_ir: dict[TypeInfo, ClassIR] = {}
    self.func_to_decl: dict[SymbolNode, FuncDecl] = {}
</t>
<t tx="ekr.20240308084832.1558">def type_to_rtype(self, typ: Type | None) -&gt; RType:
    if typ is None:
        return object_rprimitive

    typ = get_proper_type(typ)
    if isinstance(typ, Instance):
        if typ.type.fullname == "builtins.int":
            return int_rprimitive
        elif typ.type.fullname == "builtins.float":
            return float_rprimitive
        elif typ.type.fullname == "builtins.bool":
            return bool_rprimitive
        elif typ.type.fullname == "builtins.str":
            return str_rprimitive
        elif typ.type.fullname == "builtins.bytes":
            return bytes_rprimitive
        elif typ.type.fullname == "builtins.list":
            return list_rprimitive
        # Dict subclasses are at least somewhat common and we
        # specifically support them, so make sure that dict operations
        # get optimized on them.
        elif any(cls.fullname == "builtins.dict" for cls in typ.type.mro):
            return dict_rprimitive
        elif typ.type.fullname == "builtins.set":
            return set_rprimitive
        elif typ.type.fullname == "builtins.tuple":
            return tuple_rprimitive  # Varying-length tuple
        elif typ.type.fullname == "builtins.range":
            return range_rprimitive
        elif typ.type in self.type_to_ir:
            inst = RInstance(self.type_to_ir[typ.type])
            # Treat protocols as Union[protocol, object], so that we can do fast
            # method calls in the cases where the protocol is explicitly inherited from
            # and fall back to generic operations when it isn't.
            if typ.type.is_protocol:
                return RUnion([inst, object_rprimitive])
            else:
                return inst
        elif typ.type.fullname == "mypy_extensions.i64":
            return int64_rprimitive
        elif typ.type.fullname == "mypy_extensions.i32":
            return int32_rprimitive
        elif typ.type.fullname == "mypy_extensions.i16":
            return int16_rprimitive
        elif typ.type.fullname == "mypy_extensions.u8":
            return uint8_rprimitive
        else:
            return object_rprimitive
    elif isinstance(typ, TupleType):
        # Use our unboxed tuples for raw tuples but fall back to
        # being boxed for NamedTuple or for variadic tuples.
        if (
            typ.partial_fallback.type.fullname == "builtins.tuple"
            and find_unpack_in_list(typ.items) is None
        ):
            return RTuple([self.type_to_rtype(t) for t in typ.items])
        else:
            return tuple_rprimitive
    elif isinstance(typ, CallableType):
        return object_rprimitive
    elif isinstance(typ, NoneTyp):
        return none_rprimitive
    elif isinstance(typ, UnionType):
        return RUnion.make_simplified_union([self.type_to_rtype(item) for item in typ.items])
    elif isinstance(typ, AnyType):
        return object_rprimitive
    elif isinstance(typ, TypeType):
        return object_rprimitive
    elif isinstance(typ, TypeVarType):
        # Erase type variable to upper bound.
        # TODO: Erase to union if object has value restriction?
        return self.type_to_rtype(typ.upper_bound)
    elif isinstance(typ, PartialType):
        assert typ.var.type is not None
        return self.type_to_rtype(typ.var.type)
    elif isinstance(typ, Overloaded):
        return object_rprimitive
    elif isinstance(typ, TypedDictType):
        return dict_rprimitive
    elif isinstance(typ, LiteralType):
        return self.type_to_rtype(typ.fallback)
    elif isinstance(typ, (UninhabitedType, UnboundType)):
        # Sure, whatever!
        return object_rprimitive

    # I think we've covered everything that is supposed to
    # actually show up, so anything else is a bug somewhere.
    assert False, "unexpected type %s" % type(typ)
</t>
<t tx="ekr.20240308084832.1559">def get_arg_rtype(self, typ: Type, kind: ArgKind) -&gt; RType:
    if kind == ARG_STAR:
        return tuple_rprimitive
    elif kind == ARG_STAR2:
        return dict_rprimitive
    else:
        return self.type_to_rtype(typ)
</t>
<t tx="ekr.20240308084832.156">def visit_float_op(self, op: FloatOp) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1560">def fdef_to_sig(self, fdef: FuncDef) -&gt; FuncSignature:
    if isinstance(fdef.type, CallableType):
        arg_types = [
            self.get_arg_rtype(typ, kind)
            for typ, kind in zip(fdef.type.arg_types, fdef.type.arg_kinds)
        ]
        arg_pos_onlys = [name is None for name in fdef.type.arg_names]
        ret = self.type_to_rtype(fdef.type.ret_type)
    else:
        # Handle unannotated functions
        arg_types = [object_rprimitive for _ in fdef.arguments]
        arg_pos_onlys = [arg.pos_only for arg in fdef.arguments]
        # We at least know the return type for __init__ methods will be None.
        is_init_method = fdef.name == "__init__" and bool(fdef.info)
        if is_init_method:
            ret = none_rprimitive
        else:
            ret = object_rprimitive

    # mypyc FuncSignatures (unlike mypy types) want to have a name
    # present even when the argument is position only, since it is
    # the sole way that FuncDecl arguments are tracked. This is
    # generally fine except in some cases (like for computing
    # init_sig) we need to produce FuncSignatures from a
    # deserialized FuncDef that lacks arguments. We won't ever
    # need to use those inside of a FuncIR, so we just make up
    # some crap.
    if hasattr(fdef, "arguments"):
        arg_names = [arg.variable.name for arg in fdef.arguments]
    else:
        arg_names = [name or "" for name in fdef.arg_names]

    args = [
        RuntimeArg(arg_name, arg_type, arg_kind, arg_pos_only)
        for arg_name, arg_kind, arg_type, arg_pos_only in zip(
            arg_names, fdef.arg_kinds, arg_types, arg_pos_onlys
        )
    ]

    # We force certain dunder methods to return objects to support letting them
    # return NotImplemented. It also avoids some pointless boxing and unboxing,
    # since tp_richcompare needs an object anyways.
    if fdef.name in ("__eq__", "__ne__", "__lt__", "__gt__", "__le__", "__ge__"):
        ret = object_rprimitive
    return FuncSignature(args, ret)
</t>
<t tx="ekr.20240308084832.1561">def is_native_module(self, module: str) -&gt; bool:
    """Is the given module one compiled by mypyc?"""
    return module in self.group_map
</t>
<t tx="ekr.20240308084832.1562">def is_native_ref_expr(self, expr: RefExpr) -&gt; bool:
    if expr.node is None:
        return False
    if "." in expr.node.fullname:
        return self.is_native_module(expr.node.fullname.rpartition(".")[0])
    return True
</t>
<t tx="ekr.20240308084832.1563">def is_native_module_ref_expr(self, expr: RefExpr) -&gt; bool:
    return self.is_native_ref_expr(expr) and expr.kind == GDEF
</t>
<t tx="ekr.20240308084832.1564">from contextlib import contextmanager
from typing import Generator, List, Optional, Tuple

from mypy.nodes import MatchStmt, NameExpr, TypeInfo
from mypy.patterns import (
    AsPattern,
    ClassPattern,
    MappingPattern,
    OrPattern,
    Pattern,
    SequencePattern,
    SingletonPattern,
    StarredPattern,
    ValuePattern,
)
from mypy.traverser import TraverserVisitor
from mypy.types import Instance, TupleType, get_proper_type
from mypyc.ir.ops import BasicBlock, Value
from mypyc.ir.rtypes import object_rprimitive
from mypyc.irbuild.builder import IRBuilder
from mypyc.primitives.dict_ops import (
    dict_copy,
    dict_del_item,
    mapping_has_key,
    supports_mapping_protocol,
)
from mypyc.primitives.generic_ops import generic_ssize_t_len_op
from mypyc.primitives.list_ops import (
    sequence_get_item,
    sequence_get_slice,
    supports_sequence_protocol,
)
from mypyc.primitives.misc_ops import fast_isinstance_op, slow_isinstance_op

# From: https://peps.python.org/pep-0634/#class-patterns
MATCHABLE_BUILTINS = {
    "builtins.bool",
    "builtins.bytearray",
    "builtins.bytes",
    "builtins.dict",
    "builtins.float",
    "builtins.frozenset",
    "builtins.int",
    "builtins.list",
    "builtins.set",
    "builtins.str",
    "builtins.tuple",
}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1565">class MatchVisitor(TraverserVisitor):
    @others
</t>
<t tx="ekr.20240308084832.1566">builder: IRBuilder
code_block: BasicBlock
next_block: BasicBlock
final_block: BasicBlock
subject: Value
match: MatchStmt

as_pattern: Optional[AsPattern] = None

def __init__(self, builder: IRBuilder, match_node: MatchStmt) -&gt; None:
    self.builder = builder

    self.code_block = BasicBlock()
    self.next_block = BasicBlock()
    self.final_block = BasicBlock()

    self.match = match_node
    self.subject = builder.accept(match_node.subject)
</t>
<t tx="ekr.20240308084832.1567">def build_match_body(self, index: int) -&gt; None:
    self.builder.activate_block(self.code_block)

    guard = self.match.guards[index]

    if guard:
        self.code_block = BasicBlock()

        cond = self.builder.accept(guard)
        self.builder.add_bool_branch(cond, self.code_block, self.next_block)

        self.builder.activate_block(self.code_block)

    self.builder.accept(self.match.bodies[index])
    self.builder.goto(self.final_block)
</t>
<t tx="ekr.20240308084832.1568">def visit_match_stmt(self, m: MatchStmt) -&gt; None:
    for i, pattern in enumerate(m.patterns):
        self.code_block = BasicBlock()
        self.next_block = BasicBlock()

        pattern.accept(self)

        self.build_match_body(i)
        self.builder.activate_block(self.next_block)

    self.builder.goto_and_activate(self.final_block)
</t>
<t tx="ekr.20240308084832.1569">def visit_value_pattern(self, pattern: ValuePattern) -&gt; None:
    value = self.builder.accept(pattern.expr)

    cond = self.builder.binary_op(self.subject, value, "==", pattern.expr.line)

    self.bind_as_pattern(value)

    self.builder.add_bool_branch(cond, self.code_block, self.next_block)
</t>
<t tx="ekr.20240308084832.157">def visit_float_neg(self, op: FloatNeg) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1570">def visit_or_pattern(self, pattern: OrPattern) -&gt; None:
    backup_block = self.next_block
    self.next_block = BasicBlock()

    for p in pattern.patterns:
        # Hack to ensure the as pattern is bound to each pattern in the
        # "or" pattern, but not every subpattern
        backup = self.as_pattern
        p.accept(self)
        self.as_pattern = backup

        self.builder.activate_block(self.next_block)
        self.next_block = BasicBlock()

    self.next_block = backup_block
    self.builder.goto(self.next_block)
</t>
<t tx="ekr.20240308084832.1571">def visit_class_pattern(self, pattern: ClassPattern) -&gt; None:
    # TODO: use faster instance check for native classes (while still
    # making sure to account for inheritence)
    isinstance_op = (
        fast_isinstance_op
        if self.builder.is_builtin_ref_expr(pattern.class_ref)
        else slow_isinstance_op
    )

    cond = self.builder.call_c(
        isinstance_op, [self.subject, self.builder.accept(pattern.class_ref)], pattern.line
    )

    self.builder.add_bool_branch(cond, self.code_block, self.next_block)

    self.bind_as_pattern(self.subject, new_block=True)

    if pattern.positionals:
        if pattern.class_ref.fullname in MATCHABLE_BUILTINS:
            self.builder.activate_block(self.code_block)
            self.code_block = BasicBlock()

            pattern.positionals[0].accept(self)

            return

        node = pattern.class_ref.node
        assert isinstance(node, TypeInfo)

        ty = node.names.get("__match_args__")
        assert ty

        match_args_type = get_proper_type(ty.type)
        assert isinstance(match_args_type, TupleType)

        match_args: List[str] = []

        for item in match_args_type.items:
            proper_item = get_proper_type(item)
            assert isinstance(proper_item, Instance) and proper_item.last_known_value

            match_arg = proper_item.last_known_value.value
            assert isinstance(match_arg, str)

            match_args.append(match_arg)

        for i, expr in enumerate(pattern.positionals):
            self.builder.activate_block(self.code_block)
            self.code_block = BasicBlock()

            # TODO: use faster "get_attr" method instead when calling on native or
            # builtin objects
            positional = self.builder.py_get_attr(self.subject, match_args[i], expr.line)

            with self.enter_subpattern(positional):
                expr.accept(self)

    for key, value in zip(pattern.keyword_keys, pattern.keyword_values):
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        # TODO: same as above "get_attr" comment
        attr = self.builder.py_get_attr(self.subject, key, value.line)

        with self.enter_subpattern(attr):
            value.accept(self)
</t>
<t tx="ekr.20240308084832.1572">def visit_as_pattern(self, pattern: AsPattern) -&gt; None:
    if pattern.pattern:
        old_pattern = self.as_pattern
        self.as_pattern = pattern
        pattern.pattern.accept(self)
        self.as_pattern = old_pattern

    elif pattern.name:
        target = self.builder.get_assignment_target(pattern.name)

        self.builder.assign(target, self.subject, pattern.line)

    self.builder.goto(self.code_block)
</t>
<t tx="ekr.20240308084832.1573">def visit_singleton_pattern(self, pattern: SingletonPattern) -&gt; None:
    if pattern.value is None:
        obj = self.builder.none_object()
    elif pattern.value is True:
        obj = self.builder.true()
    else:
        obj = self.builder.false()

    cond = self.builder.binary_op(self.subject, obj, "is", pattern.line)

    self.builder.add_bool_branch(cond, self.code_block, self.next_block)
</t>
<t tx="ekr.20240308084832.1574">def visit_mapping_pattern(self, pattern: MappingPattern) -&gt; None:
    is_dict = self.builder.call_c(supports_mapping_protocol, [self.subject], pattern.line)

    self.builder.add_bool_branch(is_dict, self.code_block, self.next_block)

    keys: List[Value] = []

    for key, value in zip(pattern.keys, pattern.values):
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        key_value = self.builder.accept(key)
        keys.append(key_value)

        exists = self.builder.call_c(mapping_has_key, [self.subject, key_value], pattern.line)

        self.builder.add_bool_branch(exists, self.code_block, self.next_block)
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        item = self.builder.gen_method_call(
            self.subject, "__getitem__", [key_value], object_rprimitive, pattern.line
        )

        with self.enter_subpattern(item):
            value.accept(self)

    if pattern.rest:
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        rest = self.builder.call_c(dict_copy, [self.subject], pattern.rest.line)

        target = self.builder.get_assignment_target(pattern.rest)

        self.builder.assign(target, rest, pattern.rest.line)

        for i, key_name in enumerate(keys):
            self.builder.call_c(dict_del_item, [rest, key_name], pattern.keys[i].line)

        self.builder.goto(self.code_block)
</t>
<t tx="ekr.20240308084832.1575">def visit_sequence_pattern(self, seq_pattern: SequencePattern) -&gt; None:
    star_index, capture, patterns = prep_sequence_pattern(seq_pattern)

    is_list = self.builder.call_c(supports_sequence_protocol, [self.subject], seq_pattern.line)

    self.builder.add_bool_branch(is_list, self.code_block, self.next_block)

    self.builder.activate_block(self.code_block)
    self.code_block = BasicBlock()

    actual_len = self.builder.call_c(generic_ssize_t_len_op, [self.subject], seq_pattern.line)
    min_len = len(patterns)

    is_long_enough = self.builder.binary_op(
        actual_len,
        self.builder.load_int(min_len),
        "==" if star_index is None else "&gt;=",
        seq_pattern.line,
    )

    self.builder.add_bool_branch(is_long_enough, self.code_block, self.next_block)

    for i, pattern in enumerate(patterns):
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        if star_index is not None and i &gt;= star_index:
            current = self.builder.binary_op(
                actual_len, self.builder.load_int(min_len - i), "-", pattern.line
            )

        else:
            current = self.builder.load_int(i)

        item = self.builder.call_c(sequence_get_item, [self.subject, current], pattern.line)

        with self.enter_subpattern(item):
            pattern.accept(self)

    if capture and star_index is not None:
        self.builder.activate_block(self.code_block)
        self.code_block = BasicBlock()

        capture_end = self.builder.binary_op(
            actual_len, self.builder.load_int(min_len - star_index), "-", capture.line
        )

        rest = self.builder.call_c(
            sequence_get_slice,
            [self.subject, self.builder.load_int(star_index), capture_end],
            capture.line,
        )

        target = self.builder.get_assignment_target(capture)
        self.builder.assign(target, rest, capture.line)

        self.builder.goto(self.code_block)
</t>
<t tx="ekr.20240308084832.1576">def bind_as_pattern(self, value: Value, new_block: bool = False) -&gt; None:
    if self.as_pattern and self.as_pattern.pattern and self.as_pattern.name:
        if new_block:
            self.builder.activate_block(self.code_block)
            self.code_block = BasicBlock()

        target = self.builder.get_assignment_target(self.as_pattern.name)
        self.builder.assign(target, value, self.as_pattern.pattern.line)

        self.as_pattern = None

        if new_block:
            self.builder.goto(self.code_block)
</t>
<t tx="ekr.20240308084832.1577">@contextmanager
def enter_subpattern(self, subject: Value) -&gt; Generator[None, None, None]:
    old_subject = self.subject
    self.subject = subject
    yield
    self.subject = old_subject
</t>
<t tx="ekr.20240308084832.1578">def prep_sequence_pattern(
    seq_pattern: SequencePattern,
) -&gt; Tuple[Optional[int], Optional[NameExpr], List[Pattern]]:
    star_index: Optional[int] = None
    capture: Optional[NameExpr] = None
    patterns: List[Pattern] = []

    for i, pattern in enumerate(seq_pattern.patterns):
        if isinstance(pattern, StarredPattern):
            star_index = i
            capture = pattern.capture

        else:
            patterns.append(pattern)

    return star_index, capture, patterns
</t>
<t tx="ekr.20240308084832.1579">"""Helpers for dealing with nonlocal control such as 'break' and 'return'.

Model how these behave differently in different contexts.
"""

from __future__ import annotations

from abc import abstractmethod
from typing import TYPE_CHECKING

from mypyc.ir.ops import (
    NO_TRACEBACK_LINE_NO,
    BasicBlock,
    Branch,
    Goto,
    Integer,
    Register,
    Return,
    Unreachable,
    Value,
)
from mypyc.irbuild.targets import AssignmentTarget
from mypyc.primitives.exc_ops import restore_exc_info_op, set_stop_iteration_value

if TYPE_CHECKING:
    from mypyc.irbuild.builder import IRBuilder


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.158">def visit_comparison_op(self, op: ComparisonOp) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1580">class NonlocalControl:
    """ABC representing a stack frame of constructs that modify nonlocal control flow.
    
    The nonlocal control flow constructs are break, continue, and
    return, and their behavior is modified by a number of other
    constructs.  The most obvious is loop, which override where break
    and continue jump to, but also `except` (which needs to clear
    exc_info when left) and (eventually) finally blocks (which need to
    ensure that the finally block is always executed when leaving the
    try/except blocks).
    """
    @others
</t>
<t tx="ekr.20240308084832.1581">@abstractmethod
def gen_break(self, builder: IRBuilder, line: int) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.1582">@abstractmethod
def gen_continue(self, builder: IRBuilder, line: int) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.1583">@abstractmethod
def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.1584">class BaseNonlocalControl(NonlocalControl):
    """Default nonlocal control outside any statements that affect it."""
    @others
</t>
<t tx="ekr.20240308084832.1585">def gen_break(self, builder: IRBuilder, line: int) -&gt; None:
    assert False, "break outside of loop"
</t>
<t tx="ekr.20240308084832.1586">def gen_continue(self, builder: IRBuilder, line: int) -&gt; None:
    assert False, "continue outside of loop"
</t>
<t tx="ekr.20240308084832.1587">def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    builder.add(Return(value))
</t>
<t tx="ekr.20240308084832.1588">class LoopNonlocalControl(NonlocalControl):
    """Nonlocal control within a loop."""
    @others
</t>
<t tx="ekr.20240308084832.1589">def __init__(
    self, outer: NonlocalControl, continue_block: BasicBlock, break_block: BasicBlock
) -&gt; None:
    self.outer = outer
    self.continue_block = continue_block
    self.break_block = break_block
</t>
<t tx="ekr.20240308084832.159">def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1590">def gen_break(self, builder: IRBuilder, line: int) -&gt; None:
    builder.add(Goto(self.break_block))
</t>
<t tx="ekr.20240308084832.1591">def gen_continue(self, builder: IRBuilder, line: int) -&gt; None:
    builder.add(Goto(self.continue_block))
</t>
<t tx="ekr.20240308084832.1592">def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    self.outer.gen_return(builder, value, line)
</t>
<t tx="ekr.20240308084832.1593">class GeneratorNonlocalControl(BaseNonlocalControl):
    """Default nonlocal control in a generator function outside statements."""
    @others
</t>
<t tx="ekr.20240308084832.1594">def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    # Assign an invalid next label number so that the next time
    # __next__ is called, we jump to the case in which
    # StopIteration is raised.
    builder.assign(builder.fn_info.generator_class.next_label_target, Integer(-1), line)

    # Raise a StopIteration containing a field for the value that
    # should be returned. Before doing so, create a new block
    # without an error handler set so that the implicitly thrown
    # StopIteration isn't caught by except blocks inside of the
    # generator function.
    builder.builder.push_error_handler(None)
    builder.goto_and_activate(BasicBlock())

    # Skip creating a traceback frame when we raise here, because
    # we don't care about the traceback frame and it is kind of
    # expensive since raising StopIteration is an extremely common
    # case.  Also we call a special internal function to set
    # StopIteration instead of using RaiseStandardError because
    # the obvious thing doesn't work if the value is a tuple
    # (???).
    builder.call_c(set_stop_iteration_value, [value], NO_TRACEBACK_LINE_NO)
    builder.add(Unreachable())
    builder.builder.pop_error_handler()
</t>
<t tx="ekr.20240308084832.1595">class CleanupNonlocalControl(NonlocalControl):
    """Abstract nonlocal control that runs some cleanup code."""
    @others
</t>
<t tx="ekr.20240308084832.1596">def __init__(self, outer: NonlocalControl) -&gt; None:
    self.outer = outer
</t>
<t tx="ekr.20240308084832.1597">@abstractmethod
def gen_cleanup(self, builder: IRBuilder, line: int) -&gt; None:
    ...
</t>
<t tx="ekr.20240308084832.1598">def gen_break(self, builder: IRBuilder, line: int) -&gt; None:
    self.gen_cleanup(builder, line)
    self.outer.gen_break(builder, line)
</t>
<t tx="ekr.20240308084832.1599">def gen_continue(self, builder: IRBuilder, line: int) -&gt; None:
    self.gen_cleanup(builder, line)
    self.outer.gen_continue(builder, line)
</t>
<t tx="ekr.20240308084832.16">def build_using_shared_lib(
    sources: list[BuildSource],
    group_name: str,
    cfiles: list[str],
    deps: list[str],
    build_dir: str,
    extra_compile_args: list[str],
) -&gt; list[Extension]:
    """Produce the list of extension modules when a shared library is needed.

    This creates one shared library extension module that all of the
    others import and then one shim extension module for each
    module in the build, that simply calls an initialization function
    in the shared library.

    The shared library (which lib_name is the name of) is a python
    extension module that exports the real initialization functions in
    Capsules stored in module attributes.
    """
    extensions = [
        get_extension()(
            shared_lib_name(group_name),
            sources=cfiles,
            include_dirs=[include_dir(), build_dir],
            depends=deps,
            extra_compile_args=extra_compile_args,
        )
    ]

    for source in sources:
        module_name = source.module.split(".")[-1]
        shim_file = generate_c_extension_shim(source.module, module_name, build_dir, group_name)

        # We include the __init__ in the "module name" we stick in the Extension,
        # since this seems to be needed for it to end up in the right place.
        full_module_name = source.module
        assert source.path
        if os.path.split(source.path)[1] == "__init__.py":
            full_module_name += ".__init__"
        extensions.append(
            get_extension()(
                full_module_name, sources=[shim_file], extra_compile_args=extra_compile_args
            )
        )

    return extensions
</t>
<t tx="ekr.20240308084832.160">def visit_load_mem(self, op: LoadMem) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1600">def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    self.gen_cleanup(builder, line)
    self.outer.gen_return(builder, value, line)
</t>
<t tx="ekr.20240308084832.1601">class TryFinallyNonlocalControl(NonlocalControl):
    """Nonlocal control within try/finally."""
    @others
</t>
<t tx="ekr.20240308084832.1602">def __init__(self, target: BasicBlock) -&gt; None:
    self.target = target
    self.ret_reg: None | Register | AssignmentTarget = None
</t>
<t tx="ekr.20240308084832.1603">def gen_break(self, builder: IRBuilder, line: int) -&gt; None:
    builder.error("break inside try/finally block is unimplemented", line)
</t>
<t tx="ekr.20240308084832.1604">def gen_continue(self, builder: IRBuilder, line: int) -&gt; None:
    builder.error("continue inside try/finally block is unimplemented", line)
</t>
<t tx="ekr.20240308084832.1605">def gen_return(self, builder: IRBuilder, value: Value, line: int) -&gt; None:
    if self.ret_reg is None:
        if builder.fn_info.is_generator:
            self.ret_reg = builder.make_spill_target(builder.ret_types[-1])
        else:
            self.ret_reg = Register(builder.ret_types[-1])
    # assert needed because of apparent mypy bug... it loses track of the union
    # and infers the type as object
    assert isinstance(self.ret_reg, (Register, AssignmentTarget))
    builder.assign(self.ret_reg, value, line)

    builder.add(Goto(self.target))
</t>
<t tx="ekr.20240308084832.1606">class ExceptNonlocalControl(CleanupNonlocalControl):
    """Nonlocal control for except blocks.
    
    Just makes sure that sys.exc_info always gets restored when we leave.
    This is super annoying.
    """
    @others
</t>
<t tx="ekr.20240308084832.1607">def __init__(self, outer: NonlocalControl, saved: Value | AssignmentTarget) -&gt; None:
    super().__init__(outer)
    self.saved = saved
</t>
<t tx="ekr.20240308084832.1608">def gen_cleanup(self, builder: IRBuilder, line: int) -&gt; None:
    builder.call_c(restore_exc_info_op, [builder.read(self.saved)], line)
</t>
<t tx="ekr.20240308084832.1609">class FinallyNonlocalControl(CleanupNonlocalControl):
    """Nonlocal control for finally blocks.
    
    Just makes sure that sys.exc_info always gets restored when we
    leave and the return register is decrefed if it isn't null.
    """
    @others
</t>
<t tx="ekr.20240308084832.161">def visit_get_element_ptr(self, op: GetElementPtr) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1610">def __init__(self, outer: NonlocalControl, saved: Value) -&gt; None:
    super().__init__(outer)
    self.saved = saved
</t>
<t tx="ekr.20240308084832.1611">def gen_cleanup(self, builder: IRBuilder, line: int) -&gt; None:
    # Restore the old exc_info
    target, cleanup = BasicBlock(), BasicBlock()
    builder.add(Branch(self.saved, target, cleanup, Branch.IS_ERROR))
    builder.activate_block(cleanup)
    builder.call_c(restore_exc_info_op, [self.saved], line)
    builder.goto_and_activate(target)
</t>
<t tx="ekr.20240308084832.1612">from __future__ import annotations

from mypy.nodes import (
    Block,
    Decorator,
    Expression,
    FuncDef,
    FuncItem,
    Import,
    LambdaExpr,
    MemberExpr,
    MypyFile,
    NameExpr,
    Node,
    SymbolNode,
    Var,
)
from mypy.traverser import ExtendedTraverserVisitor
from mypyc.errors import Errors


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1613">class PreBuildVisitor(ExtendedTraverserVisitor):
    """Mypy file AST visitor run before building the IR.
    
    This collects various things, including:
    
    * Determine relationships between nested functions and functions that
      contain nested functions
    * Find non-local variables (free variables)
    * Find property setters
    * Find decorators of functions
    * Find module import groups
    
    The main IR build pass uses this information.
    """
    @others
</t>
<t tx="ekr.20240308084832.1614">def __init__(
    self,
    errors: Errors,
    current_file: MypyFile,
    decorators_to_remove: dict[FuncDef, list[int]],
) -&gt; None:
    super().__init__()
    # Dict from a function to symbols defined directly in the
    # function that are used as non-local (free) variables within a
    # nested function.
    self.free_variables: dict[FuncItem, set[SymbolNode]] = {}

    # Intermediate data structure used to find the function where
    # a SymbolNode is declared. Initially this may point to a
    # function nested inside the function with the declaration,
    # but we'll eventually update this to refer to the function
    # with the declaration.
    self.symbols_to_funcs: dict[SymbolNode, FuncItem] = {}

    # Stack representing current function nesting.
    self.funcs: list[FuncItem] = []

    # All property setters encountered so far.
    self.prop_setters: set[FuncDef] = set()

    # A map from any function that contains nested functions to
    # a set of all the functions that are nested within it.
    self.encapsulating_funcs: dict[FuncItem, list[FuncItem]] = {}

    # Map nested function to its parent/encapsulating function.
    self.nested_funcs: dict[FuncItem, FuncItem] = {}

    # Map function to its non-special decorators.
    self.funcs_to_decorators: dict[FuncDef, list[Expression]] = {}

    # Map function to indices of decorators to remove
    self.decorators_to_remove: dict[FuncDef, list[int]] = decorators_to_remove

    # A mapping of import groups (a series of Import nodes with
    # nothing inbetween) where each group is keyed by its first
    # import node.
    self.module_import_groups: dict[Import, list[Import]] = {}
    self._current_import_group: Import | None = None

    self.errors: Errors = errors

    self.current_file: MypyFile = current_file
</t>
<t tx="ekr.20240308084832.1615">def visit(self, o: Node) -&gt; bool:
    if not isinstance(o, Import):
        self._current_import_group = None
    return True
</t>
<t tx="ekr.20240308084832.1616">def visit_block(self, block: Block) -&gt; None:
    self._current_import_group = None
    super().visit_block(block)
    self._current_import_group = None
</t>
<t tx="ekr.20240308084832.1617">def visit_decorator(self, dec: Decorator) -&gt; None:
    if dec.decorators:
        # Only add the function being decorated if there exist
        # (ordinary) decorators in the decorator list. Certain
        # decorators (such as @property, @abstractmethod) are
        # special cased and removed from this list by
        # mypy. Functions decorated only by special decorators
        # (and property setters) are not treated as decorated
        # functions by the IR builder.
        if isinstance(dec.decorators[0], MemberExpr) and dec.decorators[0].name == "setter":
            # Property setters are not treated as decorated methods.
            self.prop_setters.add(dec.func)
        else:
            decorators_to_store = dec.decorators.copy()
            if dec.func in self.decorators_to_remove:
                to_remove = self.decorators_to_remove[dec.func]

                for i in reversed(to_remove):
                    del decorators_to_store[i]
                # if all of the decorators are removed, we shouldn't treat this as a decorated
                # function because there aren't any decorators to apply
                if not decorators_to_store:
                    return

            self.funcs_to_decorators[dec.func] = decorators_to_store
    super().visit_decorator(dec)
</t>
<t tx="ekr.20240308084832.1618">def visit_func_def(self, fdef: FuncDef) -&gt; None:
    # TODO: What about overloaded functions?
    self.visit_func(fdef)
    self.visit_symbol_node(fdef)
</t>
<t tx="ekr.20240308084832.1619">def visit_lambda_expr(self, expr: LambdaExpr) -&gt; None:
    self.visit_func(expr)
</t>
<t tx="ekr.20240308084832.162">def visit_load_address(self, op: LoadAddress) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1620">def visit_func(self, func: FuncItem) -&gt; None:
    # If there were already functions or lambda expressions
    # defined in the function stack, then note the previous
    # FuncItem as containing a nested function and the current
    # FuncItem as being a nested function.
    if self.funcs:
        # Add the new func to the set of nested funcs within the
        # func at top of the func stack.
        self.encapsulating_funcs.setdefault(self.funcs[-1], []).append(func)
        # Add the func at top of the func stack as the parent of
        # new func.
        self.nested_funcs[func] = self.funcs[-1]

    self.funcs.append(func)
    super().visit_func(func)
    self.funcs.pop()
</t>
<t tx="ekr.20240308084832.1621">def visit_import(self, imp: Import) -&gt; None:
    if self._current_import_group is not None:
        self.module_import_groups[self._current_import_group].append(imp)
    else:
        self.module_import_groups[imp] = [imp]
        self._current_import_group = imp
    super().visit_import(imp)
</t>
<t tx="ekr.20240308084832.1622">def visit_name_expr(self, expr: NameExpr) -&gt; None:
    if isinstance(expr.node, (Var, FuncDef)):
        self.visit_symbol_node(expr.node)
</t>
<t tx="ekr.20240308084832.1623">def visit_var(self, var: Var) -&gt; None:
    self.visit_symbol_node(var)
</t>
<t tx="ekr.20240308084832.1624">def visit_symbol_node(self, symbol: SymbolNode) -&gt; None:
    if not self.funcs:
        # We are not inside a function and hence do not need to do
        # anything regarding free variables.
        return

    if symbol in self.symbols_to_funcs:
        orig_func = self.symbols_to_funcs[symbol]
        if self.is_parent(self.funcs[-1], orig_func):
            # The function in which the symbol was previously seen is
            # nested within the function currently being visited. Thus
            # the current function is a better candidate to contain the
            # declaration.
            self.symbols_to_funcs[symbol] = self.funcs[-1]
            # TODO: Remove from the orig_func free_variables set?
            self.free_variables.setdefault(self.funcs[-1], set()).add(symbol)

        elif self.is_parent(orig_func, self.funcs[-1]):
            # The SymbolNode instance has already been visited
            # before in a parent function, thus it's a non-local
            # symbol.
            self.add_free_variable(symbol)

    else:
        # This is the first time the SymbolNode is being
        # visited. We map the SymbolNode to the current FuncDef
        # being visited to note where it was first visited.
        self.symbols_to_funcs[symbol] = self.funcs[-1]
</t>
<t tx="ekr.20240308084832.1625">def is_parent(self, fitem: FuncItem, child: FuncItem) -&gt; bool:
    # Check if child is nested within fdef (possibly indirectly
    # within multiple nested functions).
    if child not in self.nested_funcs:
        return False
    parent = self.nested_funcs[child]
    return parent == fitem or self.is_parent(fitem, parent)
</t>
<t tx="ekr.20240308084832.1626">def add_free_variable(self, symbol: SymbolNode) -&gt; None:
    # Find the function where the symbol was (likely) first declared,
    # and mark is as a non-local symbol within that function.
    func = self.symbols_to_funcs[symbol]
    self.free_variables.setdefault(func, set()).add(symbol)
</t>
<t tx="ekr.20240308084832.1627">"""Prepare for IR transform.

This needs to run after type checking and before generating IR.

For example, construct partially initialized FuncIR and ClassIR
objects for all functions and classes. This allows us to bind
references to functions and classes before we've generated full IR for
functions or classes.  The actual IR transform will then populate all
the missing bits, such as function bodies (basic blocks).

Also build a mapping from mypy TypeInfos to ClassIR objects.
"""

from __future__ import annotations

from collections import defaultdict
from typing import Iterable, NamedTuple, Tuple

from mypy.build import Graph
from mypy.nodes import (
    ARG_STAR,
    ARG_STAR2,
    CallExpr,
    ClassDef,
    Decorator,
    Expression,
    FuncDef,
    MemberExpr,
    MypyFile,
    NameExpr,
    OverloadedFuncDef,
    RefExpr,
    SymbolNode,
    TypeInfo,
    Var,
)
from mypy.semanal import refers_to_fullname
from mypy.traverser import TraverserVisitor
from mypy.types import Instance, Type, get_proper_type
from mypyc.common import PROPSET_PREFIX, get_id_from_name
from mypyc.crash import catch_errors
from mypyc.errors import Errors
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import (
    FUNC_CLASSMETHOD,
    FUNC_NORMAL,
    FUNC_STATICMETHOD,
    FuncDecl,
    FuncSignature,
    RuntimeArg,
)
from mypyc.ir.ops import DeserMaps
from mypyc.ir.rtypes import RInstance, RType, dict_rprimitive, none_rprimitive, tuple_rprimitive
from mypyc.irbuild.mapper import Mapper
from mypyc.irbuild.util import (
    get_func_def,
    get_mypyc_attrs,
    is_dataclass,
    is_extension_class,
    is_trait,
)
from mypyc.options import CompilerOptions
from mypyc.sametype import is_same_type


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1628">def build_type_map(
    mapper: Mapper,
    modules: list[MypyFile],
    graph: Graph,
    types: dict[Expression, Type],
    options: CompilerOptions,
    errors: Errors,
) -&gt; None:
    # Collect all classes defined in everything we are compiling
    classes = []
    for module in modules:
        module_classes = [node for node in module.defs if isinstance(node, ClassDef)]
        classes.extend([(module, cdef) for cdef in module_classes])

    # Collect all class mappings so that we can bind arbitrary class name
    # references even if there are import cycles.
    for module, cdef in classes:
        class_ir = ClassIR(
            cdef.name, module.fullname, is_trait(cdef), is_abstract=cdef.info.is_abstract
        )
        class_ir.is_ext_class = is_extension_class(cdef)
        if class_ir.is_ext_class:
            class_ir.deletable = cdef.info.deletable_attributes.copy()
        # If global optimizations are disabled, turn of tracking of class children
        if not options.global_opts:
            class_ir.children = None
        mapper.type_to_ir[cdef.info] = class_ir

    # Populate structural information in class IR for extension classes.
    for module, cdef in classes:
        with catch_errors(module.path, cdef.line):
            if mapper.type_to_ir[cdef.info].is_ext_class:
                prepare_class_def(module.path, module.fullname, cdef, errors, mapper)
            else:
                prepare_non_ext_class_def(module.path, module.fullname, cdef, errors, mapper)

    # Prepare implicit attribute accessors as needed if an attribute overrides a property.
    for module, cdef in classes:
        class_ir = mapper.type_to_ir[cdef.info]
        if class_ir.is_ext_class:
            prepare_implicit_property_accessors(cdef.info, class_ir, module.fullname, mapper)

    # Collect all the functions also. We collect from the symbol table
    # so that we can easily pick out the right copy of a function that
    # is conditionally defined.
    for module in modules:
        for func in get_module_func_defs(module):
            prepare_func_def(module.fullname, None, func, mapper)
            # TODO: what else?

    # Check for incompatible attribute definitions that were not
    # flagged by mypy but can't be supported when compiling.
    for module, cdef in classes:
        class_ir = mapper.type_to_ir[cdef.info]
        for attr in class_ir.attributes:
            for base_ir in class_ir.mro[1:]:
                if attr in base_ir.attributes:
                    if not is_same_type(class_ir.attributes[attr], base_ir.attributes[attr]):
                        node = cdef.info.names[attr].node
                        assert node is not None
                        kind = "trait" if base_ir.is_trait else "class"
                        errors.error(
                            f'Type of "{attr}" is incompatible with '
                            f'definition in {kind} "{base_ir.name}"',
                            module.path,
                            node.line,
                        )
</t>
<t tx="ekr.20240308084832.1629">def is_from_module(node: SymbolNode, module: MypyFile) -&gt; bool:
    return node.fullname == module.fullname + "." + node.name
</t>
<t tx="ekr.20240308084832.163">def visit_keep_alive(self, op: KeepAlive) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1630">def load_type_map(mapper: Mapper, modules: list[MypyFile], deser_ctx: DeserMaps) -&gt; None:
    """Populate a Mapper with deserialized IR from a list of modules."""
    for module in modules:
        for name, node in module.names.items():
            if isinstance(node.node, TypeInfo) and is_from_module(node.node, module):
                ir = deser_ctx.classes[node.node.fullname]
                mapper.type_to_ir[node.node] = ir
                mapper.func_to_decl[node.node] = ir.ctor

    for module in modules:
        for func in get_module_func_defs(module):
            func_id = get_id_from_name(func.name, func.fullname, func.line)
            mapper.func_to_decl[func] = deser_ctx.functions[func_id].decl
</t>
<t tx="ekr.20240308084832.1631">def get_module_func_defs(module: MypyFile) -&gt; Iterable[FuncDef]:
    """Collect all of the (non-method) functions declared in a module."""
    for name, node in module.names.items():
        # We need to filter out functions that are imported or
        # aliases.  The best way to do this seems to be by
        # checking that the fullname matches.
        if isinstance(node.node, (FuncDef, Decorator, OverloadedFuncDef)) and is_from_module(
            node.node, module
        ):
            yield get_func_def(node.node)
</t>
<t tx="ekr.20240308084832.1632">def prepare_func_def(
    module_name: str, class_name: str | None, fdef: FuncDef, mapper: Mapper
) -&gt; FuncDecl:
    kind = (
        FUNC_STATICMETHOD
        if fdef.is_static
        else (FUNC_CLASSMETHOD if fdef.is_class else FUNC_NORMAL)
    )
    decl = FuncDecl(fdef.name, class_name, module_name, mapper.fdef_to_sig(fdef), kind)
    mapper.func_to_decl[fdef] = decl
    return decl
</t>
<t tx="ekr.20240308084832.1633">def prepare_method_def(
    ir: ClassIR, module_name: str, cdef: ClassDef, mapper: Mapper, node: FuncDef | Decorator
) -&gt; None:
    if isinstance(node, FuncDef):
        ir.method_decls[node.name] = prepare_func_def(module_name, cdef.name, node, mapper)
    elif isinstance(node, Decorator):
        # TODO: do something about abstract methods here. Currently, they are handled just like
        # normal methods.
        decl = prepare_func_def(module_name, cdef.name, node.func, mapper)
        if not node.decorators:
            ir.method_decls[node.name] = decl
        elif isinstance(node.decorators[0], MemberExpr) and node.decorators[0].name == "setter":
            # Make property setter name different than getter name so there are no
            # name clashes when generating C code, and property lookup at the IR level
            # works correctly.
            decl.name = PROPSET_PREFIX + decl.name
            decl.is_prop_setter = True
            # Making the argument implicitly positional-only avoids unnecessary glue methods
            decl.sig.args[1].pos_only = True
            ir.method_decls[PROPSET_PREFIX + node.name] = decl

        if node.func.is_property:
            assert node.func.type, f"Expected return type annotation for property '{node.name}'"
            decl.is_prop_getter = True
            ir.property_types[node.name] = decl.sig.ret_type
</t>
<t tx="ekr.20240308084832.1634">def is_valid_multipart_property_def(prop: OverloadedFuncDef) -&gt; bool:
    # Checks to ensure supported property decorator semantics
    if len(prop.items) != 2:
        return False

    getter = prop.items[0]
    setter = prop.items[1]

    return (
        isinstance(getter, Decorator)
        and isinstance(setter, Decorator)
        and getter.func.is_property
        and len(setter.decorators) == 1
        and isinstance(setter.decorators[0], MemberExpr)
        and setter.decorators[0].name == "setter"
    )
</t>
<t tx="ekr.20240308084832.1635">def can_subclass_builtin(builtin_base: str) -&gt; bool:
    # BaseException and dict are special cased.
    return builtin_base in (
        (
            "builtins.Exception",
            "builtins.LookupError",
            "builtins.IndexError",
            "builtins.Warning",
            "builtins.UserWarning",
            "builtins.ValueError",
            "builtins.object",
        )
    )
</t>
<t tx="ekr.20240308084832.1636">def prepare_class_def(
    path: str, module_name: str, cdef: ClassDef, errors: Errors, mapper: Mapper
) -&gt; None:
    """Populate the interface-level information in a class IR.

    This includes attribute and method declarations, and the MRO, among other things, but
    method bodies are generated in a later pass.
    """

    ir = mapper.type_to_ir[cdef.info]
    info = cdef.info

    attrs = get_mypyc_attrs(cdef)
    if attrs.get("allow_interpreted_subclasses") is True:
        ir.allow_interpreted_subclasses = True
    if attrs.get("serializable") is True:
        # Supports copy.copy and pickle (including subclasses)
        ir._serializable = True

    # Check for subclassing from builtin types
    for cls in info.mro:
        # Special case exceptions and dicts
        # XXX: How do we handle *other* things??
        if cls.fullname == "builtins.BaseException":
            ir.builtin_base = "PyBaseExceptionObject"
        elif cls.fullname == "builtins.dict":
            ir.builtin_base = "PyDictObject"
        elif cls.fullname.startswith("builtins."):
            if not can_subclass_builtin(cls.fullname):
                # Note that if we try to subclass a C extension class that
                # isn't in builtins, bad things will happen and we won't
                # catch it here! But this should catch a lot of the most
                # common pitfalls.
                errors.error(
                    "Inheriting from most builtin types is unimplemented", path, cdef.line
                )

    # Set up the parent class
    bases = [mapper.type_to_ir[base.type] for base in info.bases if base.type in mapper.type_to_ir]
    if len(bases) &gt; 1 and any(not c.is_trait for c in bases) and bases[0].is_trait:
        # If the first base is a non-trait, don't ever error here. While it is correct
        # to error if a trait comes before the next non-trait base (e.g. non-trait, trait,
        # non-trait), it's pointless, confusing noise from the bigger issue: multiple
        # inheritance is *not* supported.
        errors.error("Non-trait base must appear first in parent list", path, cdef.line)
    ir.traits = [c for c in bases if c.is_trait]

    mro = []  # All mypyc base classes
    base_mro = []  # Non-trait mypyc base classes
    for cls in info.mro:
        if cls not in mapper.type_to_ir:
            if cls.fullname != "builtins.object":
                ir.inherits_python = True
            continue
        base_ir = mapper.type_to_ir[cls]
        if not base_ir.is_trait:
            base_mro.append(base_ir)
        mro.append(base_ir)

        if cls.defn.removed_base_type_exprs or not base_ir.is_ext_class:
            ir.inherits_python = True

    base_idx = 1 if not ir.is_trait else 0
    if len(base_mro) &gt; base_idx:
        ir.base = base_mro[base_idx]
    ir.mro = mro
    ir.base_mro = base_mro

    prepare_methods_and_attributes(cdef, ir, path, module_name, errors, mapper)
    prepare_init_method(cdef, ir, module_name, mapper)

    for base in bases:
        if base.children is not None:
            base.children.append(ir)

    if is_dataclass(cdef):
        ir.is_augmented = True
</t>
<t tx="ekr.20240308084832.1637">def prepare_methods_and_attributes(
    cdef: ClassDef, ir: ClassIR, path: str, module_name: str, errors: Errors, mapper: Mapper
) -&gt; None:
    """Populate attribute and method declarations."""
    info = cdef.info
    for name, node in info.names.items():
        # Currently all plugin generated methods are dummies and not included.
        if node.plugin_generated:
            continue

        if isinstance(node.node, Var):
            assert node.node.type, "Class member %s missing type" % name
            if not node.node.is_classvar and name not in ("__slots__", "__deletable__"):
                attr_rtype = mapper.type_to_rtype(node.node.type)
                if ir.is_trait and attr_rtype.error_overlap:
                    # Traits don't have attribute definedness bitmaps, so use
                    # property accessor methods to access attributes that need them.
                    # We will generate accessor implementations that use the class bitmap
                    # for any concrete subclasses.
                    add_getter_declaration(ir, name, attr_rtype, module_name)
                    add_setter_declaration(ir, name, attr_rtype, module_name)
                ir.attributes[name] = attr_rtype
        elif isinstance(node.node, (FuncDef, Decorator)):
            prepare_method_def(ir, module_name, cdef, mapper, node.node)
        elif isinstance(node.node, OverloadedFuncDef):
            # Handle case for property with both a getter and a setter
            if node.node.is_property:
                if is_valid_multipart_property_def(node.node):
                    for item in node.node.items:
                        prepare_method_def(ir, module_name, cdef, mapper, item)
                else:
                    errors.error("Unsupported property decorator semantics", path, cdef.line)

            # Handle case for regular function overload
            else:
                assert node.node.impl
                prepare_method_def(ir, module_name, cdef, mapper, node.node.impl)

    if ir.builtin_base:
        ir.attributes.clear()
</t>
<t tx="ekr.20240308084832.1638">def prepare_implicit_property_accessors(
    info: TypeInfo, ir: ClassIR, module_name: str, mapper: Mapper
) -&gt; None:
    concrete_attributes = set()
    for base in ir.base_mro:
        for name, attr_rtype in base.attributes.items():
            concrete_attributes.add(name)
            add_property_methods_for_attribute_if_needed(
                info, ir, name, attr_rtype, module_name, mapper
            )
    for base in ir.mro[1:]:
        if base.is_trait:
            for name, attr_rtype in base.attributes.items():
                if name not in concrete_attributes:
                    add_property_methods_for_attribute_if_needed(
                        info, ir, name, attr_rtype, module_name, mapper
                    )
</t>
<t tx="ekr.20240308084832.1639">def add_property_methods_for_attribute_if_needed(
    info: TypeInfo,
    ir: ClassIR,
    attr_name: str,
    attr_rtype: RType,
    module_name: str,
    mapper: Mapper,
) -&gt; None:
    """Add getter and/or setter for attribute if defined as property in a base class.

    Only add declarations. The body IR will be synthesized later during irbuild.
    """
    for base in info.mro[1:]:
        if base in mapper.type_to_ir:
            base_ir = mapper.type_to_ir[base]
            n = base.names.get(attr_name)
            if n is None:
                continue
            node = n.node
            if isinstance(node, Decorator) and node.name not in ir.method_decls:
                # Defined as a read-only property in base class/trait
                add_getter_declaration(ir, attr_name, attr_rtype, module_name)
            elif isinstance(node, OverloadedFuncDef) and is_valid_multipart_property_def(node):
                # Defined as a read-write property in base class/trait
                add_getter_declaration(ir, attr_name, attr_rtype, module_name)
                add_setter_declaration(ir, attr_name, attr_rtype, module_name)
            elif base_ir.is_trait and attr_rtype.error_overlap:
                add_getter_declaration(ir, attr_name, attr_rtype, module_name)
                add_setter_declaration(ir, attr_name, attr_rtype, module_name)
</t>
<t tx="ekr.20240308084832.164">def visit_unborrow(self, op: Unborrow) -&gt; GenAndKill[T]:
    return self.visit_register_op(op)
</t>
<t tx="ekr.20240308084832.1640">def add_getter_declaration(
    ir: ClassIR, attr_name: str, attr_rtype: RType, module_name: str
) -&gt; None:
    self_arg = RuntimeArg("self", RInstance(ir), pos_only=True)
    sig = FuncSignature([self_arg], attr_rtype)
    decl = FuncDecl(attr_name, ir.name, module_name, sig, FUNC_NORMAL)
    decl.is_prop_getter = True
    decl.implicit = True  # Triggers synthesization
    ir.method_decls[attr_name] = decl
    ir.property_types[attr_name] = attr_rtype  # TODO: Needed??
</t>
<t tx="ekr.20240308084832.1641">def add_setter_declaration(
    ir: ClassIR, attr_name: str, attr_rtype: RType, module_name: str
) -&gt; None:
    self_arg = RuntimeArg("self", RInstance(ir), pos_only=True)
    value_arg = RuntimeArg("value", attr_rtype, pos_only=True)
    sig = FuncSignature([self_arg, value_arg], none_rprimitive)
    setter_name = PROPSET_PREFIX + attr_name
    decl = FuncDecl(setter_name, ir.name, module_name, sig, FUNC_NORMAL)
    decl.is_prop_setter = True
    decl.implicit = True  # Triggers synthesization
    ir.method_decls[setter_name] = decl
</t>
<t tx="ekr.20240308084832.1642">def prepare_init_method(cdef: ClassDef, ir: ClassIR, module_name: str, mapper: Mapper) -&gt; None:
    # Set up a constructor decl
    init_node = cdef.info["__init__"].node
    if not ir.is_trait and not ir.builtin_base and isinstance(init_node, FuncDef):
        init_sig = mapper.fdef_to_sig(init_node)

        defining_ir = mapper.type_to_ir.get(init_node.info)
        # If there is a nontrivial __init__ that wasn't defined in an
        # extension class, we need to make the constructor take *args,
        # **kwargs so it can call tp_init.
        if (
            defining_ir is None
            or not defining_ir.is_ext_class
            or cdef.info["__init__"].plugin_generated
        ) and init_node.info.fullname != "builtins.object":
            init_sig = FuncSignature(
                [
                    init_sig.args[0],
                    RuntimeArg("args", tuple_rprimitive, ARG_STAR),
                    RuntimeArg("kwargs", dict_rprimitive, ARG_STAR2),
                ],
                init_sig.ret_type,
            )

        last_arg = len(init_sig.args) - init_sig.num_bitmap_args
        ctor_sig = FuncSignature(init_sig.args[1:last_arg], RInstance(ir))
        ir.ctor = FuncDecl(cdef.name, None, module_name, ctor_sig)
        mapper.func_to_decl[cdef.info] = ir.ctor
</t>
<t tx="ekr.20240308084832.1643">def prepare_non_ext_class_def(
    path: str, module_name: str, cdef: ClassDef, errors: Errors, mapper: Mapper
) -&gt; None:
    ir = mapper.type_to_ir[cdef.info]
    info = cdef.info

    for name, node in info.names.items():
        if isinstance(node.node, (FuncDef, Decorator)):
            prepare_method_def(ir, module_name, cdef, mapper, node.node)
        elif isinstance(node.node, OverloadedFuncDef):
            # Handle case for property with both a getter and a setter
            if node.node.is_property:
                if not is_valid_multipart_property_def(node.node):
                    errors.error("Unsupported property decorator semantics", path, cdef.line)
                for item in node.node.items:
                    prepare_method_def(ir, module_name, cdef, mapper, item)
            # Handle case for regular function overload
            else:
                prepare_method_def(ir, module_name, cdef, mapper, get_func_def(node.node))

    if any(cls in mapper.type_to_ir and mapper.type_to_ir[cls].is_ext_class for cls in info.mro):
        errors.error(
            "Non-extension classes may not inherit from extension classes", path, cdef.line
        )
</t>
<t tx="ekr.20240308084832.1644">RegisterImplInfo = Tuple[TypeInfo, FuncDef]


class SingledispatchInfo(NamedTuple):
    singledispatch_impls: dict[FuncDef, list[RegisterImplInfo]]
    decorators_to_remove: dict[FuncDef, list[int]]
</t>
<t tx="ekr.20240308084832.1645">def find_singledispatch_register_impls(
    modules: list[MypyFile], errors: Errors
) -&gt; SingledispatchInfo:
    visitor = SingledispatchVisitor(errors)
    for module in modules:
        visitor.current_path = module.path
        module.accept(visitor)
    return SingledispatchInfo(visitor.singledispatch_impls, visitor.decorators_to_remove)
</t>
<t tx="ekr.20240308084832.1646">class SingledispatchVisitor(TraverserVisitor):
    @others
</t>
<t tx="ekr.20240308084832.1647">current_path: str

def __init__(self, errors: Errors) -&gt; None:
    super().__init__()

    # Map of main singledispatch function to list of registered implementations
    self.singledispatch_impls: defaultdict[FuncDef, list[RegisterImplInfo]] = defaultdict(list)

    # Map of decorated function to the indices of any decorators to remove
    self.decorators_to_remove: dict[FuncDef, list[int]] = {}

    self.errors: Errors = errors
</t>
<t tx="ekr.20240308084832.1648">def visit_decorator(self, dec: Decorator) -&gt; None:
    if dec.decorators:
        decorators_to_store = dec.decorators.copy()
        decorators_to_remove: list[int] = []
        # the index of the last non-register decorator before finding a register decorator
        # when going through decorators from top to bottom
        last_non_register: int | None = None
        for i, d in enumerate(decorators_to_store):
            impl = get_singledispatch_register_call_info(d, dec.func)
            if impl is not None:
                self.singledispatch_impls[impl.singledispatch_func].append(
                    (impl.dispatch_type, dec.func)
                )
                decorators_to_remove.append(i)
                if last_non_register is not None:
                    # found a register decorator after a non-register decorator, which we
                    # don't support because we'd have to make a copy of the function before
                    # calling the decorator so that we can call it later, which complicates
                    # the implementation for something that is probably not commonly used
                    self.errors.error(
                        "Calling decorator after registering function not supported",
                        self.current_path,
                        decorators_to_store[last_non_register].line,
                    )
            else:
                if refers_to_fullname(d, "functools.singledispatch"):
                    decorators_to_remove.append(i)
                    # make sure that we still treat the function as a singledispatch function
                    # even if we don't find any registered implementations (which might happen
                    # if all registered implementations are registered dynamically)
                    self.singledispatch_impls.setdefault(dec.func, [])
                last_non_register = i

        if decorators_to_remove:
            # calling register on a function that tries to dispatch based on type annotations
            # raises a TypeError because compiled functions don't have an __annotations__
            # attribute
            self.decorators_to_remove[dec.func] = decorators_to_remove

    super().visit_decorator(dec)
</t>
<t tx="ekr.20240308084832.1649">class RegisteredImpl(NamedTuple):
    singledispatch_func: FuncDef
    dispatch_type: TypeInfo
</t>
<t tx="ekr.20240308084832.165">class DefinedVisitor(BaseAnalysisVisitor[Value]):
    """Visitor for finding defined registers.
    
    Note that this only deals with registers and not temporaries, on
    the assumption that we never access temporaries when they might be
    undefined.
    
    If strict_errors is True, then we regard any use of LoadErrorValue
    as making a register undefined. Otherwise we only do if
    `undefines` is set on the error value.
    
    This lets us only consider the things we care about during
    uninitialized variable checking while capturing all possibly
    undefined things for refcounting.
    """
    @others
</t>
<t tx="ekr.20240308084832.1650">def get_singledispatch_register_call_info(
    decorator: Expression, func: FuncDef
) -&gt; RegisteredImpl | None:
    # @fun.register(complex)
    # def g(arg): ...
    if (
        isinstance(decorator, CallExpr)
        and len(decorator.args) == 1
        and isinstance(decorator.args[0], RefExpr)
    ):
        callee = decorator.callee
        dispatch_type = decorator.args[0].node
        if not isinstance(dispatch_type, TypeInfo):
            return None

        if isinstance(callee, MemberExpr):
            return registered_impl_from_possible_register_call(callee, dispatch_type)
    # @fun.register
    # def g(arg: int): ...
    elif isinstance(decorator, MemberExpr):
        # we don't know if this is a register call yet, so we can't be sure that the function
        # actually has arguments
        if not func.arguments:
            return None
        arg_type = get_proper_type(func.arguments[0].variable.type)
        if not isinstance(arg_type, Instance):
            return None
        info = arg_type.type
        return registered_impl_from_possible_register_call(decorator, info)
    return None
</t>
<t tx="ekr.20240308084832.1651">def registered_impl_from_possible_register_call(
    expr: MemberExpr, dispatch_type: TypeInfo
) -&gt; RegisteredImpl | None:
    if expr.name == "register" and isinstance(expr.expr, NameExpr):
        node = expr.expr.node
        if isinstance(node, Decorator):
            return RegisteredImpl(node.func, dispatch_type)
    return None
</t>
<t tx="ekr.20240308084832.1652">"""Special case IR generation of calls to specific builtin functions.

Most special cases should be handled using the data driven "primitive
ops" system, but certain operations require special handling that has
access to the AST/IR directly and can make decisions/optimizations
based on it. These special cases can be implemented here.

For example, we use specializers to statically emit the length of a
fixed length tuple and to emit optimized code for any()/all() calls with
generator comprehensions as the argument.

See comment below for more documentation.
"""

from __future__ import annotations

from typing import Callable, Optional

from mypy.nodes import (
    ARG_NAMED,
    ARG_POS,
    CallExpr,
    DictExpr,
    Expression,
    GeneratorExpr,
    IntExpr,
    ListExpr,
    MemberExpr,
    NameExpr,
    RefExpr,
    StrExpr,
    TupleExpr,
)
from mypy.types import AnyType, TypeOfAny
from mypyc.ir.ops import (
    BasicBlock,
    Extend,
    Integer,
    RaiseStandardError,
    Register,
    Truncate,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import (
    RInstance,
    RPrimitive,
    RTuple,
    RType,
    bool_rprimitive,
    c_int_rprimitive,
    dict_rprimitive,
    int16_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    is_bool_rprimitive,
    is_dict_rprimitive,
    is_fixed_width_rtype,
    is_float_rprimitive,
    is_int16_rprimitive,
    is_int32_rprimitive,
    is_int64_rprimitive,
    is_int_rprimitive,
    is_list_rprimitive,
    is_uint8_rprimitive,
    list_rprimitive,
    set_rprimitive,
    str_rprimitive,
    uint8_rprimitive,
)
from mypyc.irbuild.builder import IRBuilder
from mypyc.irbuild.for_helpers import (
    comprehension_helper,
    sequence_from_generator_preallocate_helper,
    translate_list_comprehension,
    translate_set_comprehension,
)
from mypyc.irbuild.format_str_tokenizer import (
    FormatOp,
    convert_format_expr_to_str,
    join_formatted_strings,
    tokenizer_format_call,
)
from mypyc.primitives.dict_ops import (
    dict_items_op,
    dict_keys_op,
    dict_setdefault_spec_init_op,
    dict_values_op,
)
from mypyc.primitives.list_ops import new_list_set_item_op
from mypyc.primitives.tuple_ops import new_tuple_set_item_op

# Specializers are attempted before compiling the arguments to the
# function.  Specializers can return None to indicate that they failed
# and the call should be compiled normally. Otherwise they should emit
# code for the call and return a Value containing the result.
#
# Specializers take three arguments: the IRBuilder, the CallExpr being
# compiled, and the RefExpr that is the left hand side of the call.
Specializer = Callable[["IRBuilder", CallExpr, RefExpr], Optional[Value]]

# Dictionary containing all configured specializers.
#
# Specializers can operate on methods as well, and are keyed on the
# name and RType in that case.
specializers: dict[tuple[str, RType | None], list[Specializer]] = {}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1653">def _apply_specialization(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr, name: str | None, typ: RType | None = None
) -&gt; Value | None:
    # TODO: Allow special cases to have default args or named args. Currently they don't since
    #       they check that everything in arg_kinds is ARG_POS.

    # If there is a specializer for this function, try calling it.
    # Return the first successful one.
    if name and (name, typ) in specializers:
        for specializer in specializers[name, typ]:
            val = specializer(builder, expr, callee)
            if val is not None:
                return val
    return None
</t>
<t tx="ekr.20240308084832.1654">def apply_function_specialization(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Invoke the Specializer callback for a function if one has been registered"""
    return _apply_specialization(builder, expr, callee, callee.fullname)
</t>
<t tx="ekr.20240308084832.1655">def apply_method_specialization(
    builder: IRBuilder, expr: CallExpr, callee: MemberExpr, typ: RType | None = None
) -&gt; Value | None:
    """Invoke the Specializer callback for a method if one has been registered"""
    name = callee.fullname if typ is None else callee.name
    return _apply_specialization(builder, expr, callee, name, typ)
</t>
<t tx="ekr.20240308084832.1656">def specialize_function(
    name: str, typ: RType | None = None
) -&gt; Callable[[Specializer], Specializer]:
    """Decorator to register a function as being a specializer.

    There may exist multiple specializers for one function. When
    translating method calls, the earlier appended specializer has
    higher priority.
    """

    def wrapper(f: Specializer) -&gt; Specializer:
        specializers.setdefault((name, typ), []).append(f)
        return f

    return wrapper
</t>
<t tx="ekr.20240308084832.1657">@specialize_function("builtins.globals")
def translate_globals(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) == 0:
        return builder.load_globals_dict()
    return None
</t>
<t tx="ekr.20240308084832.1658">@specialize_function("builtins.abs")
@specialize_function("builtins.int")
@specialize_function("builtins.float")
@specialize_function("builtins.complex")
@specialize_function("mypy_extensions.i64")
@specialize_function("mypy_extensions.i32")
@specialize_function("mypy_extensions.i16")
@specialize_function("mypy_extensions.u8")
def translate_builtins_with_unary_dunder(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Specialize calls on native classes that implement the associated dunder.

    E.g. i64(x) gets specialized to x.__int__() if x is a native instance.
    """
    if len(expr.args) == 1 and expr.arg_kinds == [ARG_POS] and isinstance(callee, NameExpr):
        arg = expr.args[0]
        arg_typ = builder.node_type(arg)
        shortname = callee.fullname.split(".")[1]
        if shortname in ("i64", "i32", "i16", "u8"):
            method = "__int__"
        else:
            method = f"__{shortname}__"
        if isinstance(arg_typ, RInstance) and arg_typ.class_ir.has_method(method):
            obj = builder.accept(arg)
            return builder.gen_method_call(obj, method, [], None, expr.line)

    return None
</t>
<t tx="ekr.20240308084832.1659">@specialize_function("builtins.len")
def translate_len(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) == 1 and expr.arg_kinds == [ARG_POS]:
        arg = expr.args[0]
        expr_rtype = builder.node_type(arg)
        if isinstance(expr_rtype, RTuple):
            # len() of fixed-length tuple can be trivially determined
            # statically, though we still need to evaluate it.
            builder.accept(arg)
            return Integer(len(expr_rtype.types))
        else:
            if is_list_rprimitive(builder.node_type(arg)):
                borrow = True
            else:
                borrow = False
            obj = builder.accept(arg, can_borrow=borrow)
            return builder.builtin_len(obj, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.166">def __init__(self, strict_errors: bool = False) -&gt; None:
    self.strict_errors = strict_errors
</t>
<t tx="ekr.20240308084832.1660">@specialize_function("builtins.list")
def dict_methods_fast_path(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    """Specialize a common case when list() is called on a dictionary
    view method call.

    For example:
        foo = list(bar.keys())
    """
    if not (len(expr.args) == 1 and expr.arg_kinds == [ARG_POS]):
        return None
    arg = expr.args[0]
    if not (isinstance(arg, CallExpr) and not arg.args and isinstance(arg.callee, MemberExpr)):
        return None
    base = arg.callee.expr
    attr = arg.callee.name
    rtype = builder.node_type(base)
    if not (is_dict_rprimitive(rtype) and attr in ("keys", "values", "items")):
        return None

    obj = builder.accept(base)
    # Note that it is not safe to use fast methods on dict subclasses,
    # so the corresponding helpers in CPy.h fallback to (inlined)
    # generic logic.
    if attr == "keys":
        return builder.call_c(dict_keys_op, [obj], expr.line)
    elif attr == "values":
        return builder.call_c(dict_values_op, [obj], expr.line)
    else:
        return builder.call_c(dict_items_op, [obj], expr.line)
</t>
<t tx="ekr.20240308084832.1661">@specialize_function("builtins.list")
def translate_list_from_generator_call(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Special case for simplest list comprehension.

    For example:
        list(f(x) for x in some_list/some_tuple/some_str)
    'translate_list_comprehension()' would take care of other cases
    if this fails.
    """
    if (
        len(expr.args) == 1
        and expr.arg_kinds[0] == ARG_POS
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return sequence_from_generator_preallocate_helper(
            builder,
            expr.args[0],
            empty_op_llbuilder=builder.builder.new_list_op_with_length,
            set_item_op=new_list_set_item_op,
        )
    return None
</t>
<t tx="ekr.20240308084832.1662">@specialize_function("builtins.tuple")
def translate_tuple_from_generator_call(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Special case for simplest tuple creation from a generator.

    For example:
        tuple(f(x) for x in some_list/some_tuple/some_str)
    'translate_safe_generator_call()' would take care of other cases
    if this fails.
    """
    if (
        len(expr.args) == 1
        and expr.arg_kinds[0] == ARG_POS
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return sequence_from_generator_preallocate_helper(
            builder,
            expr.args[0],
            empty_op_llbuilder=builder.builder.new_tuple_with_length,
            set_item_op=new_tuple_set_item_op,
        )
    return None
</t>
<t tx="ekr.20240308084832.1663">@specialize_function("builtins.set")
def translate_set_from_generator_call(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Special case for set creation from a generator.

    For example:
        set(f(...) for ... in iterator/nested_generators...)
    """
    if (
        len(expr.args) == 1
        and expr.arg_kinds[0] == ARG_POS
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return translate_set_comprehension(builder, expr.args[0])
    return None
</t>
<t tx="ekr.20240308084832.1664">@specialize_function("builtins.min")
@specialize_function("builtins.max")
def faster_min_max(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if expr.arg_kinds == [ARG_POS, ARG_POS]:
        x, y = builder.accept(expr.args[0]), builder.accept(expr.args[1])
        result = Register(builder.node_type(expr))
        # CPython evaluates arguments reversely when calling min(...) or max(...)
        if callee.fullname == "builtins.min":
            comparison = builder.binary_op(y, x, "&lt;", expr.line)
        else:
            comparison = builder.binary_op(y, x, "&gt;", expr.line)

        true_block, false_block, next_block = BasicBlock(), BasicBlock(), BasicBlock()
        builder.add_bool_branch(comparison, true_block, false_block)

        builder.activate_block(true_block)
        builder.assign(result, builder.coerce(y, result.type, expr.line), expr.line)
        builder.goto(next_block)

        builder.activate_block(false_block)
        builder.assign(result, builder.coerce(x, result.type, expr.line), expr.line)
        builder.goto(next_block)

        builder.activate_block(next_block)
        return result
    return None
</t>
<t tx="ekr.20240308084832.1665">@specialize_function("builtins.tuple")
@specialize_function("builtins.frozenset")
@specialize_function("builtins.dict")
@specialize_function("builtins.min")
@specialize_function("builtins.max")
@specialize_function("builtins.sorted")
@specialize_function("collections.OrderedDict")
@specialize_function("join", str_rprimitive)
@specialize_function("extend", list_rprimitive)
@specialize_function("update", dict_rprimitive)
@specialize_function("update", set_rprimitive)
def translate_safe_generator_call(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Special cases for things that consume iterators where we know we
    can safely compile a generator into a list.
    """
    if (
        len(expr.args) &gt; 0
        and expr.arg_kinds[0] == ARG_POS
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        if isinstance(callee, MemberExpr):
            return builder.gen_method_call(
                builder.accept(callee.expr),
                callee.name,
                (
                    [translate_list_comprehension(builder, expr.args[0])]
                    + [builder.accept(arg) for arg in expr.args[1:]]
                ),
                builder.node_type(expr),
                expr.line,
                expr.arg_kinds,
                expr.arg_names,
            )
        else:
            return builder.call_refexpr_with_args(
                expr,
                callee,
                (
                    [translate_list_comprehension(builder, expr.args[0])]
                    + [builder.accept(arg) for arg in expr.args[1:]]
                ),
            )
    return None
</t>
<t tx="ekr.20240308084832.1666">@specialize_function("builtins.any")
def translate_any_call(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if (
        len(expr.args) == 1
        and expr.arg_kinds == [ARG_POS]
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return any_all_helper(builder, expr.args[0], builder.false, lambda x: x, builder.true)
    return None
</t>
<t tx="ekr.20240308084832.1667">@specialize_function("builtins.all")
def translate_all_call(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if (
        len(expr.args) == 1
        and expr.arg_kinds == [ARG_POS]
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return any_all_helper(
            builder,
            expr.args[0],
            builder.true,
            lambda x: builder.unary_op(x, "not", expr.line),
            builder.false,
        )
    return None
</t>
<t tx="ekr.20240308084832.1668">def any_all_helper(
    builder: IRBuilder,
    gen: GeneratorExpr,
    initial_value: Callable[[], Value],
    modify: Callable[[Value], Value],
    new_value: Callable[[], Value],
) -&gt; Value:
    retval = Register(bool_rprimitive)
    builder.assign(retval, initial_value(), -1)
    loop_params = list(zip(gen.indices, gen.sequences, gen.condlists, gen.is_async))
    true_block, false_block, exit_block = BasicBlock(), BasicBlock(), BasicBlock()

    def gen_inner_stmts() -&gt; None:
        comparison = modify(builder.accept(gen.left_expr))
        builder.add_bool_branch(comparison, true_block, false_block)
        builder.activate_block(true_block)
        builder.assign(retval, new_value(), -1)
        builder.goto(exit_block)
        builder.activate_block(false_block)

    comprehension_helper(builder, loop_params, gen_inner_stmts, gen.line)
    builder.goto_and_activate(exit_block)

    return retval
</t>
<t tx="ekr.20240308084832.1669">@specialize_function("builtins.sum")
def translate_sum_call(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    # specialized implementation is used if:
    # - only one or two arguments given (if not, sum() has been given invalid arguments)
    # - first argument is a Generator (there is no benefit to optimizing the performance of eg.
    #   sum([1, 2, 3]), so non-Generator Iterables are not handled)
    if not (
        len(expr.args) in (1, 2)
        and expr.arg_kinds[0] == ARG_POS
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return None

    # handle 'start' argument, if given
    if len(expr.args) == 2:
        # ensure call to sum() was properly constructed
        if expr.arg_kinds[1] not in (ARG_POS, ARG_NAMED):
            return None
        start_expr = expr.args[1]
    else:
        start_expr = IntExpr(0)

    gen_expr = expr.args[0]
    target_type = builder.node_type(expr)
    retval = Register(target_type)
    builder.assign(retval, builder.coerce(builder.accept(start_expr), target_type, -1), -1)

    def gen_inner_stmts() -&gt; None:
        call_expr = builder.accept(gen_expr.left_expr)
        builder.assign(retval, builder.binary_op(retval, call_expr, "+", -1), -1)

    loop_params = list(
        zip(gen_expr.indices, gen_expr.sequences, gen_expr.condlists, gen_expr.is_async)
    )
    comprehension_helper(builder, loop_params, gen_inner_stmts, gen_expr.line)

    return retval
</t>
<t tx="ekr.20240308084832.167">def visit_branch(self, op: Branch) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1670">@specialize_function("dataclasses.field")
@specialize_function("attr.ib")
@specialize_function("attr.attrib")
@specialize_function("attr.Factory")
def translate_dataclasses_field_call(
    builder: IRBuilder, expr: CallExpr, callee: RefExpr
) -&gt; Value | None:
    """Special case for 'dataclasses.field', 'attr.attrib', and 'attr.Factory'
    function calls because the results of such calls are type-checked
    by mypy using the types of the arguments to their respective
    functions, resulting in attempted coercions by mypyc that throw a
    runtime error.
    """
    builder.types[expr] = AnyType(TypeOfAny.from_error)
    return None
</t>
<t tx="ekr.20240308084832.1671">@specialize_function("builtins.next")
def translate_next_call(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    """Special case for calling next() on a generator expression, an
    idiom that shows up some in mypy.

    For example, next(x for x in l if x.id == 12, None) will
    generate code that searches l for an element where x.id == 12
    and produce the first such object, or None if no such element
    exists.
    """
    if not (
        expr.arg_kinds in ([ARG_POS], [ARG_POS, ARG_POS])
        and isinstance(expr.args[0], GeneratorExpr)
    ):
        return None

    gen = expr.args[0]
    retval = Register(builder.node_type(expr))
    default_val = builder.accept(expr.args[1]) if len(expr.args) &gt; 1 else None
    exit_block = BasicBlock()

    def gen_inner_stmts() -&gt; None:
        # next takes the first element of the generator, so if
        # something gets produced, we are done.
        builder.assign(retval, builder.accept(gen.left_expr), gen.left_expr.line)
        builder.goto(exit_block)

    loop_params = list(zip(gen.indices, gen.sequences, gen.condlists, gen.is_async))
    comprehension_helper(builder, loop_params, gen_inner_stmts, gen.line)

    # Now we need the case for when nothing got hit. If there was
    # a default value, we produce it, and otherwise we raise
    # StopIteration.
    if default_val:
        builder.assign(retval, default_val, gen.left_expr.line)
        builder.goto(exit_block)
    else:
        builder.add(RaiseStandardError(RaiseStandardError.STOP_ITERATION, None, expr.line))
        builder.add(Unreachable())

    builder.activate_block(exit_block)
    return retval
</t>
<t tx="ekr.20240308084832.1672">@specialize_function("builtins.isinstance")
def translate_isinstance(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    """Special case for builtins.isinstance.

    Prevent coercions on the thing we are checking the instance of -
    there is no need to coerce something to a new type before checking
    what type it is, and the coercion could lead to bugs.
    """
    if (
        len(expr.args) == 2
        and expr.arg_kinds == [ARG_POS, ARG_POS]
        and isinstance(expr.args[1], (RefExpr, TupleExpr))
    ):
        builder.types[expr.args[0]] = AnyType(TypeOfAny.from_error)

        irs = builder.flatten_classes(expr.args[1])
        if irs is not None:
            can_borrow = all(
                ir.is_ext_class and not ir.inherits_python and not ir.allow_interpreted_subclasses
                for ir in irs
            )
            obj = builder.accept(expr.args[0], can_borrow=can_borrow)
            return builder.builder.isinstance_helper(obj, irs, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1673">@specialize_function("setdefault", dict_rprimitive)
def translate_dict_setdefault(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    """Special case for 'dict.setdefault' which would only construct
    default empty collection when needed.

    The dict_setdefault_spec_init_op checks whether the dict contains
    the key and would construct the empty collection only once.

    For example, this specializer works for the following cases:
         d.setdefault(key, set()).add(value)
         d.setdefault(key, []).append(value)
         d.setdefault(key, {})[inner_key] = inner_val
    """
    if (
        len(expr.args) == 2
        and expr.arg_kinds == [ARG_POS, ARG_POS]
        and isinstance(callee, MemberExpr)
    ):
        arg = expr.args[1]
        if isinstance(arg, ListExpr):
            if len(arg.items):
                return None
            data_type = Integer(1, c_int_rprimitive, expr.line)
        elif isinstance(arg, DictExpr):
            if len(arg.items):
                return None
            data_type = Integer(2, c_int_rprimitive, expr.line)
        elif (
            isinstance(arg, CallExpr)
            and isinstance(arg.callee, NameExpr)
            and arg.callee.fullname == "builtins.set"
        ):
            if len(arg.args):
                return None
            data_type = Integer(3, c_int_rprimitive, expr.line)
        else:
            return None

        callee_dict = builder.accept(callee.expr)
        key_val = builder.accept(expr.args[0])
        return builder.call_c(
            dict_setdefault_spec_init_op, [callee_dict, key_val, data_type], expr.line
        )
    return None
</t>
<t tx="ekr.20240308084832.1674">@specialize_function("format", str_rprimitive)
def translate_str_format(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if (
        isinstance(callee, MemberExpr)
        and isinstance(callee.expr, StrExpr)
        and expr.arg_kinds.count(ARG_POS) == len(expr.arg_kinds)
    ):
        format_str = callee.expr.value
        tokens = tokenizer_format_call(format_str)
        if tokens is None:
            return None
        literals, format_ops = tokens
        # Convert variables to strings
        substitutions = convert_format_expr_to_str(builder, format_ops, expr.args, expr.line)
        if substitutions is None:
            return None
        return join_formatted_strings(builder, literals, substitutions, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1675">@specialize_function("join", str_rprimitive)
def translate_fstring(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    """Special case for f-string, which is translated into str.join()
    in mypy AST.

    This specializer optimizes simplest f-strings which don't contain
    any format operation.
    """
    if (
        isinstance(callee, MemberExpr)
        and isinstance(callee.expr, StrExpr)
        and callee.expr.value == ""
        and expr.arg_kinds == [ARG_POS]
        and isinstance(expr.args[0], ListExpr)
    ):
        for item in expr.args[0].items:
            if isinstance(item, StrExpr):
                continue
            elif isinstance(item, CallExpr):
                if not isinstance(item.callee, MemberExpr) or item.callee.name != "format":
                    return None
                elif (
                    not isinstance(item.callee.expr, StrExpr) or item.callee.expr.value != "{:{}}"
                ):
                    return None

                if not isinstance(item.args[1], StrExpr) or item.args[1].value != "":
                    return None
            else:
                return None

        format_ops = []
        exprs: list[Expression] = []

        for item in expr.args[0].items:
            if isinstance(item, StrExpr) and item.value != "":
                format_ops.append(FormatOp.STR)
                exprs.append(item)
            elif isinstance(item, CallExpr):
                format_ops.append(FormatOp.STR)
                exprs.append(item.args[0])

        substitutions = convert_format_expr_to_str(builder, format_ops, exprs, expr.line)
        if substitutions is None:
            return None

        return join_formatted_strings(builder, None, substitutions, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1676">@specialize_function("mypy_extensions.i64")
def translate_i64(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if is_int64_rprimitive(arg_type):
        return builder.accept(arg)
    elif is_int32_rprimitive(arg_type) or is_int16_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Extend(val, int64_rprimitive, signed=True, line=expr.line))
    elif is_uint8_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Extend(val, int64_rprimitive, signed=False, line=expr.line))
    elif is_int_rprimitive(arg_type) or is_bool_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.coerce(val, int64_rprimitive, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1677">@specialize_function("mypy_extensions.i32")
def translate_i32(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if is_int32_rprimitive(arg_type):
        return builder.accept(arg)
    elif is_int64_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Truncate(val, int32_rprimitive, line=expr.line))
    elif is_int16_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Extend(val, int32_rprimitive, signed=True, line=expr.line))
    elif is_uint8_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Extend(val, int32_rprimitive, signed=False, line=expr.line))
    elif is_int_rprimitive(arg_type) or is_bool_rprimitive(arg_type):
        val = builder.accept(arg)
        val = truncate_literal(val, int32_rprimitive)
        return builder.coerce(val, int32_rprimitive, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1678">@specialize_function("mypy_extensions.i16")
def translate_i16(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if is_int16_rprimitive(arg_type):
        return builder.accept(arg)
    elif is_int32_rprimitive(arg_type) or is_int64_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Truncate(val, int16_rprimitive, line=expr.line))
    elif is_uint8_rprimitive(arg_type):
        val = builder.accept(arg)
        return builder.add(Extend(val, int16_rprimitive, signed=False, line=expr.line))
    elif is_int_rprimitive(arg_type) or is_bool_rprimitive(arg_type):
        val = builder.accept(arg)
        val = truncate_literal(val, int16_rprimitive)
        return builder.coerce(val, int16_rprimitive, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1679">@specialize_function("mypy_extensions.u8")
def translate_u8(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if is_uint8_rprimitive(arg_type):
        return builder.accept(arg)
    elif (
        is_int16_rprimitive(arg_type)
        or is_int32_rprimitive(arg_type)
        or is_int64_rprimitive(arg_type)
    ):
        val = builder.accept(arg)
        return builder.add(Truncate(val, uint8_rprimitive, line=expr.line))
    elif is_int_rprimitive(arg_type) or is_bool_rprimitive(arg_type):
        val = builder.accept(arg)
        val = truncate_literal(val, uint8_rprimitive)
        return builder.coerce(val, uint8_rprimitive, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.168">def visit_return(self, op: Return) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1680">def truncate_literal(value: Value, rtype: RPrimitive) -&gt; Value:
    """If value is an integer literal value, truncate it to given native int rtype.

    For example, truncate 256 into 0 if rtype is u8.
    """
    if not isinstance(value, Integer):
        return value  # Not a literal, nothing to do
    x = value.numeric_value()
    max_unsigned = (1 &lt;&lt; (rtype.size * 8)) - 1
    x = x &amp; max_unsigned
    if rtype.is_signed and x &gt;= (max_unsigned + 1) // 2:
        # Adjust to make it a negative value
        x -= max_unsigned + 1
    return Integer(x, rtype)
</t>
<t tx="ekr.20240308084832.1681">@specialize_function("builtins.int")
def translate_int(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if (
        is_bool_rprimitive(arg_type)
        or is_int_rprimitive(arg_type)
        or is_fixed_width_rtype(arg_type)
    ):
        src = builder.accept(arg)
        return builder.coerce(src, int_rprimitive, expr.line)
    return None
</t>
<t tx="ekr.20240308084832.1682">@specialize_function("builtins.bool")
def translate_bool(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    src = builder.accept(arg)
    return builder.builder.bool_value(src)
</t>
<t tx="ekr.20240308084832.1683">@specialize_function("builtins.float")
def translate_float(builder: IRBuilder, expr: CallExpr, callee: RefExpr) -&gt; Value | None:
    if len(expr.args) != 1 or expr.arg_kinds[0] != ARG_POS:
        return None
    arg = expr.args[0]
    arg_type = builder.node_type(arg)
    if is_float_rprimitive(arg_type):
        # No-op float conversion.
        return builder.accept(arg)
    return None
</t>
<t tx="ekr.20240308084832.1684">"""Transform mypy statement ASTs to mypyc IR (Intermediate Representation).

The top-level AST transformation logic is implemented in mypyc.irbuild.visitor
and mypyc.irbuild.builder.

A few statements are transformed in mypyc.irbuild.function (yield, for example).
"""

from __future__ import annotations

import importlib.util
from typing import Callable, Sequence

from mypy.nodes import (
    AssertStmt,
    AssignmentStmt,
    AwaitExpr,
    Block,
    BreakStmt,
    ContinueStmt,
    DelStmt,
    Expression,
    ExpressionStmt,
    ForStmt,
    IfStmt,
    Import,
    ImportAll,
    ImportFrom,
    ListExpr,
    Lvalue,
    MatchStmt,
    OperatorAssignmentStmt,
    RaiseStmt,
    ReturnStmt,
    StarExpr,
    StrExpr,
    TempNode,
    TryStmt,
    TupleExpr,
    WhileStmt,
    WithStmt,
    YieldExpr,
    YieldFromExpr,
)
from mypyc.ir.ops import (
    NAMESPACE_MODULE,
    NO_TRACEBACK_LINE_NO,
    Assign,
    BasicBlock,
    Branch,
    InitStatic,
    Integer,
    LoadAddress,
    LoadErrorValue,
    LoadLiteral,
    LoadStatic,
    MethodCall,
    RaiseStandardError,
    Register,
    Return,
    TupleGet,
    Unborrow,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import (
    RInstance,
    RTuple,
    c_pyssize_t_rprimitive,
    exc_rtuple,
    is_tagged,
    none_rprimitive,
    object_pointer_rprimitive,
    object_rprimitive,
)
from mypyc.irbuild.ast_helpers import is_borrow_friendly_expr, process_conditional
from mypyc.irbuild.builder import IRBuilder, int_borrow_friendly_op
from mypyc.irbuild.for_helpers import for_loop_helper
from mypyc.irbuild.generator import add_raise_exception_blocks_to_generator_class
from mypyc.irbuild.nonlocalcontrol import (
    ExceptNonlocalControl,
    FinallyNonlocalControl,
    TryFinallyNonlocalControl,
)
from mypyc.irbuild.targets import (
    AssignmentTarget,
    AssignmentTargetAttr,
    AssignmentTargetIndex,
    AssignmentTargetRegister,
    AssignmentTargetTuple,
)
from mypyc.primitives.exc_ops import (
    error_catch_op,
    exc_matches_op,
    get_exc_info_op,
    get_exc_value_op,
    keep_propagating_op,
    raise_exception_op,
    reraise_exception_op,
    restore_exc_info_op,
)
from mypyc.primitives.generic_ops import iter_op, next_raw_op, py_delattr_op
from mypyc.primitives.misc_ops import (
    check_stop_op,
    coro_op,
    import_from_many_op,
    import_many_op,
    send_op,
    type_op,
    yield_from_except_op,
)

from .match import MatchVisitor

GenFunc = Callable[[], None]
ValueGenFunc = Callable[[], Value]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1685">def transform_block(builder: IRBuilder, block: Block) -&gt; None:
    if not block.is_unreachable:
        builder.block_reachable_stack.append(True)
        for stmt in block.body:
            builder.accept(stmt)
            if not builder.block_reachable_stack[-1]:
                # The rest of the block is unreachable, so skip it
                break
        builder.block_reachable_stack.pop()
    # Raise a RuntimeError if we hit a non-empty unreachable block.
    # Don't complain about empty unreachable blocks, since mypy inserts
    # those after `if MYPY`.
    elif block.body:
        builder.add(
            RaiseStandardError(
                RaiseStandardError.RUNTIME_ERROR, "Reached allegedly unreachable code!", block.line
            )
        )
        builder.add(Unreachable())
</t>
<t tx="ekr.20240308084832.1686">def transform_expression_stmt(builder: IRBuilder, stmt: ExpressionStmt) -&gt; None:
    if isinstance(stmt.expr, StrExpr):
        # Docstring. Ignore
        return
    # ExpressionStmts do not need to be coerced like other Expressions, so we shouldn't
    # call builder.accept here.
    stmt.expr.accept(builder.visitor)
    builder.flush_keep_alives()
</t>
<t tx="ekr.20240308084832.1687">def transform_return_stmt(builder: IRBuilder, stmt: ReturnStmt) -&gt; None:
    if stmt.expr:
        retval = builder.accept(stmt.expr)
    else:
        retval = builder.builder.none()
    retval = builder.coerce(retval, builder.ret_types[-1], stmt.line)
    builder.nonlocal_control[-1].gen_return(builder, retval, stmt.line)
</t>
<t tx="ekr.20240308084832.1688">def transform_assignment_stmt(builder: IRBuilder, stmt: AssignmentStmt) -&gt; None:
    lvalues = stmt.lvalues
    assert lvalues
    builder.disallow_class_assignments(lvalues, stmt.line)
    first_lvalue = lvalues[0]
    if stmt.type and isinstance(stmt.rvalue, TempNode):
        # This is actually a variable annotation without initializer. Don't generate
        # an assignment but we need to call get_assignment_target since it adds a
        # name binding as a side effect.
        builder.get_assignment_target(first_lvalue, stmt.line)
        return

    # Special case multiple assignments like 'x, y = e1, e2'.
    if (
        isinstance(first_lvalue, (TupleExpr, ListExpr))
        and isinstance(stmt.rvalue, (TupleExpr, ListExpr))
        and len(first_lvalue.items) == len(stmt.rvalue.items)
        and all(is_simple_lvalue(item) for item in first_lvalue.items)
        and len(lvalues) == 1
    ):
        temps = []
        for right in stmt.rvalue.items:
            rvalue_reg = builder.accept(right)
            temp = Register(rvalue_reg.type)
            builder.assign(temp, rvalue_reg, stmt.line)
            temps.append(temp)
        for left, temp in zip(first_lvalue.items, temps):
            assignment_target = builder.get_assignment_target(left)
            builder.assign(assignment_target, temp, stmt.line)
        builder.flush_keep_alives()
        return

    line = stmt.rvalue.line
    rvalue_reg = builder.accept(stmt.rvalue)

    if builder.non_function_scope() and stmt.is_final_def:
        builder.init_final_static(first_lvalue, rvalue_reg)

    # Special-case multiple assignments like 'x, y = expr' to reduce refcount ops.
    if (
        isinstance(first_lvalue, (TupleExpr, ListExpr))
        and isinstance(rvalue_reg.type, RTuple)
        and len(rvalue_reg.type.types) == len(first_lvalue.items)
        and len(lvalues) == 1
        and all(is_simple_lvalue(item) for item in first_lvalue.items)
        and any(t.is_refcounted for t in rvalue_reg.type.types)
    ):
        n = len(first_lvalue.items)
        for i in range(n):
            target = builder.get_assignment_target(first_lvalue.items[i])
            rvalue_item = builder.add(TupleGet(rvalue_reg, i, borrow=True))
            rvalue_item = builder.add(Unborrow(rvalue_item))
            builder.assign(target, rvalue_item, line)
        builder.builder.keep_alive([rvalue_reg], steal=True)
        builder.flush_keep_alives()
        return

    for lvalue in lvalues:
        target = builder.get_assignment_target(lvalue)
        builder.assign(target, rvalue_reg, line)
        builder.flush_keep_alives()
</t>
<t tx="ekr.20240308084832.1689">def is_simple_lvalue(expr: Expression) -&gt; bool:
    return not isinstance(expr, (StarExpr, ListExpr, TupleExpr))
</t>
<t tx="ekr.20240308084832.169">def visit_unreachable(self, op: Unreachable) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1690">def transform_operator_assignment_stmt(builder: IRBuilder, stmt: OperatorAssignmentStmt) -&gt; None:
    """Operator assignment statement such as x += 1"""
    builder.disallow_class_assignments([stmt.lvalue], stmt.line)
    if (
        is_tagged(builder.node_type(stmt.lvalue))
        and is_tagged(builder.node_type(stmt.rvalue))
        and stmt.op in int_borrow_friendly_op
    ):
        can_borrow = is_borrow_friendly_expr(builder, stmt.rvalue) and is_borrow_friendly_expr(
            builder, stmt.lvalue
        )
    else:
        can_borrow = False
    target = builder.get_assignment_target(stmt.lvalue)
    target_value = builder.read(target, stmt.line, can_borrow=can_borrow)
    rreg = builder.accept(stmt.rvalue, can_borrow=can_borrow)
    # the Python parser strips the '=' from operator assignment statements, so re-add it
    op = stmt.op + "="
    res = builder.binary_op(target_value, rreg, op, stmt.line)
    # usually operator assignments are done in-place
    # but when target doesn't support that we need to manually assign
    builder.assign(target, res, res.line)
    builder.flush_keep_alives()
</t>
<t tx="ekr.20240308084832.1691">def import_globals_id_and_name(module_id: str, as_name: str | None) -&gt; tuple[str, str]:
    """Compute names for updating the globals dict with the appropriate module.

    * For 'import foo.bar as baz' we add 'foo.bar' with the name 'baz'
    * For 'import foo.bar' we add 'foo' with the name 'foo'

    Typically we then ignore these entries and access things directly
    via the module static, but we will use the globals version for
    modules that mypy couldn't find, since it doesn't analyze module
    references from those properly."""
    if as_name:
        globals_id = module_id
        globals_name = as_name
    else:
        globals_id = globals_name = module_id.split(".")[0]

    return globals_id, globals_name
</t>
<t tx="ekr.20240308084832.1692">def transform_import(builder: IRBuilder, node: Import) -&gt; None:
    if node.is_mypy_only:
        return

    # Imports (not from imports!) are processed in an odd way so they can be
    # table-driven and compact. Here's how it works:
    #
    # Import nodes are divided in groups (in the prebuild visitor). Each group
    # consists of consecutive Import nodes:
    #
    #   import mod         &lt;| group #1
    #   import mod2         |
    #
    #   def foo() -&gt; None:
    #       import mod3    &lt;- group #2 (*)
    #
    #   import mod4        &lt;| group #3
    #   import mod5         |
    #
    # Every time we encounter the first import of a group, build IR to call a
    # helper function that will perform all of the group's imports in one go.
    if not node.is_top_level:
        # (*) Unless the import is within a function. In that case, prioritize
        # speed over codesize when generating IR.
        globals = builder.load_globals_dict()
        for mod_id, as_name in node.ids:
            builder.gen_import(mod_id, node.line)
            globals_id, globals_name = import_globals_id_and_name(mod_id, as_name)
            builder.gen_method_call(
                globals,
                "__setitem__",
                [builder.load_str(globals_name), builder.get_module(globals_id, node.line)],
                result_type=None,
                line=node.line,
            )
        return

    if node not in builder.module_import_groups:
        return

    modules = []
    static_ptrs = []
    # To show the right line number on failure, we have to add the traceback
    # entry within the helper function (which is admittedly ugly). To drive
    # this, we need the line number corresponding to each module.
    mod_lines = []
    for import_node in builder.module_import_groups[node]:
        for mod_id, as_name in import_node.ids:
            builder.imports[mod_id] = None
            modules.append((mod_id, *import_globals_id_and_name(mod_id, as_name)))
            mod_static = LoadStatic(object_rprimitive, mod_id, namespace=NAMESPACE_MODULE)
            static_ptrs.append(builder.add(LoadAddress(object_pointer_rprimitive, mod_static)))
            mod_lines.append(Integer(import_node.line, c_pyssize_t_rprimitive))

    static_array_ptr = builder.builder.setup_rarray(object_pointer_rprimitive, static_ptrs)
    import_line_ptr = builder.builder.setup_rarray(c_pyssize_t_rprimitive, mod_lines)
    builder.call_c(
        import_many_op,
        [
            builder.add(LoadLiteral(tuple(modules), object_rprimitive)),
            static_array_ptr,
            builder.load_globals_dict(),
            builder.load_str(builder.module_path),
            builder.load_str(builder.fn_info.name),
            import_line_ptr,
        ],
        NO_TRACEBACK_LINE_NO,
    )
</t>
<t tx="ekr.20240308084832.1693">def transform_import_from(builder: IRBuilder, node: ImportFrom) -&gt; None:
    if node.is_mypy_only:
        return

    module_state = builder.graph[builder.module_name]
    if module_state.ancestors is not None and module_state.ancestors:
        module_package = module_state.ancestors[0]
    elif builder.module_path.endswith("__init__.py"):
        module_package = builder.module_name
    else:
        module_package = ""

    id = importlib.util.resolve_name("." * node.relative + node.id, module_package)
    builder.imports[id] = None

    names = [name for name, _ in node.names]
    as_names = [as_name or name for name, as_name in node.names]
    names_literal = builder.add(LoadLiteral(tuple(names), object_rprimitive))
    if as_names == names:
        # Reuse names tuple to reduce verbosity.
        as_names_literal = names_literal
    else:
        as_names_literal = builder.add(LoadLiteral(tuple(as_names), object_rprimitive))
    # Note that we miscompile import from inside of functions here,
    # since that case *shouldn't* load everything into the globals dict.
    # This probably doesn't matter much and the code runs basically right.
    module = builder.call_c(
        import_from_many_op,
        [builder.load_str(id), names_literal, as_names_literal, builder.load_globals_dict()],
        node.line,
    )
    builder.add(InitStatic(module, id, namespace=NAMESPACE_MODULE))
</t>
<t tx="ekr.20240308084832.1694">def transform_import_all(builder: IRBuilder, node: ImportAll) -&gt; None:
    if node.is_mypy_only:
        return
    builder.gen_import(node.id, node.line)
</t>
<t tx="ekr.20240308084832.1695">def transform_if_stmt(builder: IRBuilder, stmt: IfStmt) -&gt; None:
    if_body, next = BasicBlock(), BasicBlock()
    else_body = BasicBlock() if stmt.else_body else next

    # If statements are normalized
    assert len(stmt.expr) == 1

    process_conditional(builder, stmt.expr[0], if_body, else_body)
    builder.activate_block(if_body)
    builder.accept(stmt.body[0])
    builder.goto(next)
    if stmt.else_body:
        builder.activate_block(else_body)
        builder.accept(stmt.else_body)
        builder.goto(next)
    builder.activate_block(next)
</t>
<t tx="ekr.20240308084832.1696">def transform_while_stmt(builder: IRBuilder, s: WhileStmt) -&gt; None:
    body, next, top, else_block = BasicBlock(), BasicBlock(), BasicBlock(), BasicBlock()
    normal_loop_exit = else_block if s.else_body is not None else next

    builder.push_loop_stack(top, next)

    # Split block so that we get a handle to the top of the loop.
    builder.goto_and_activate(top)
    process_conditional(builder, s.expr, body, normal_loop_exit)

    builder.activate_block(body)
    builder.accept(s.body)
    # Add branch to the top at the end of the body.
    builder.goto(top)

    builder.pop_loop_stack()

    if s.else_body is not None:
        builder.activate_block(else_block)
        builder.accept(s.else_body)
        builder.goto(next)

    builder.activate_block(next)
</t>
<t tx="ekr.20240308084832.1697">def transform_for_stmt(builder: IRBuilder, s: ForStmt) -&gt; None:
    def body() -&gt; None:
        builder.accept(s.body)

    def else_block() -&gt; None:
        assert s.else_body is not None
        builder.accept(s.else_body)

    for_loop_helper(
        builder, s.index, s.expr, body, else_block if s.else_body else None, s.is_async, s.line
    )
</t>
<t tx="ekr.20240308084832.1698">def transform_break_stmt(builder: IRBuilder, node: BreakStmt) -&gt; None:
    builder.nonlocal_control[-1].gen_break(builder, node.line)
</t>
<t tx="ekr.20240308084832.1699">def transform_continue_stmt(builder: IRBuilder, node: ContinueStmt) -&gt; None:
    builder.nonlocal_control[-1].gen_continue(builder, node.line)
</t>
<t tx="ekr.20240308084832.17">def build_single_module(
    sources: list[BuildSource], cfiles: list[str], extra_compile_args: list[str]
) -&gt; list[Extension]:
    """Produce the list of extension modules for a standalone extension.

    This contains just one module, since there is no need for a shared module.
    """
    return [
        get_extension()(
            sources[0].module,
            sources=cfiles,
            include_dirs=[include_dir()],
            extra_compile_args=extra_compile_args,
        )
    ]
</t>
<t tx="ekr.20240308084832.170">def visit_register_op(self, op: RegisterOp) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1700">def transform_raise_stmt(builder: IRBuilder, s: RaiseStmt) -&gt; None:
    if s.expr is None:
        builder.call_c(reraise_exception_op, [], NO_TRACEBACK_LINE_NO)
        builder.add(Unreachable())
        return

    exc = builder.accept(s.expr)
    builder.call_c(raise_exception_op, [exc], s.line)
    builder.add(Unreachable())
</t>
<t tx="ekr.20240308084832.1701">def transform_try_except(
    builder: IRBuilder,
    body: GenFunc,
    handlers: Sequence[tuple[tuple[ValueGenFunc, int] | None, Expression | None, GenFunc]],
    else_body: GenFunc | None,
    line: int,
) -&gt; None:
    """Generalized try/except/else handling that takes functions to gen the bodies.

    The point of this is to also be able to support with."""
    assert handlers, "try needs except"

    except_entry, exit_block, cleanup_block = BasicBlock(), BasicBlock(), BasicBlock()
    double_except_block = BasicBlock()
    # If there is an else block, jump there after the try, otherwise just leave
    else_block = BasicBlock() if else_body else exit_block

    # Compile the try block with an error handler
    builder.builder.push_error_handler(except_entry)
    builder.goto_and_activate(BasicBlock())
    body()
    builder.goto(else_block)
    builder.builder.pop_error_handler()

    # The error handler catches the error and then checks it
    # against the except clauses. We compile the error handler
    # itself with an error handler so that it can properly restore
    # the *old* exc_info if an exception occurs.
    # The exception chaining will be done automatically when the
    # exception is raised, based on the exception in exc_info.
    builder.builder.push_error_handler(double_except_block)
    builder.activate_block(except_entry)
    old_exc = builder.maybe_spill(builder.call_c(error_catch_op, [], line))
    # Compile the except blocks with the nonlocal control flow overridden to clear exc_info
    builder.nonlocal_control.append(ExceptNonlocalControl(builder.nonlocal_control[-1], old_exc))

    # Process the bodies
    for type, var, handler_body in handlers:
        next_block = None
        if type:
            type_f, type_line = type
            next_block, body_block = BasicBlock(), BasicBlock()
            matches = builder.call_c(exc_matches_op, [type_f()], type_line)
            builder.add(Branch(matches, body_block, next_block, Branch.BOOL))
            builder.activate_block(body_block)
        if var:
            target = builder.get_assignment_target(var)
            builder.assign(target, builder.call_c(get_exc_value_op, [], var.line), var.line)
        handler_body()
        builder.goto(cleanup_block)
        if next_block:
            builder.activate_block(next_block)

    # Reraise the exception if needed
    if next_block:
        builder.call_c(reraise_exception_op, [], NO_TRACEBACK_LINE_NO)
        builder.add(Unreachable())

    builder.nonlocal_control.pop()
    builder.builder.pop_error_handler()

    # Cleanup for if we leave except through normal control flow:
    # restore the saved exc_info information and continue propagating
    # the exception if it exists.
    builder.activate_block(cleanup_block)
    builder.call_c(restore_exc_info_op, [builder.read(old_exc)], line)
    builder.goto(exit_block)

    # Cleanup for if we leave except through a raised exception:
    # restore the saved exc_info information and continue propagating
    # the exception.
    builder.activate_block(double_except_block)
    builder.call_c(restore_exc_info_op, [builder.read(old_exc)], line)
    builder.call_c(keep_propagating_op, [], NO_TRACEBACK_LINE_NO)
    builder.add(Unreachable())

    # If present, compile the else body in the obvious way
    if else_body:
        builder.activate_block(else_block)
        else_body()
        builder.goto(exit_block)

    builder.activate_block(exit_block)
</t>
<t tx="ekr.20240308084832.1702">def transform_try_except_stmt(builder: IRBuilder, t: TryStmt) -&gt; None:
    def body() -&gt; None:
        builder.accept(t.body)

    # Work around scoping woes
    def make_handler(body: Block) -&gt; GenFunc:
        return lambda: builder.accept(body)

    def make_entry(type: Expression) -&gt; tuple[ValueGenFunc, int]:
        return (lambda: builder.accept(type), type.line)

    handlers = [
        (make_entry(type) if type else None, var, make_handler(body))
        for type, var, body in zip(t.types, t.vars, t.handlers)
    ]
    else_body = (lambda: builder.accept(t.else_body)) if t.else_body else None
    transform_try_except(builder, body, handlers, else_body, t.line)
</t>
<t tx="ekr.20240308084832.1703">def try_finally_try(
    builder: IRBuilder,
    err_handler: BasicBlock,
    return_entry: BasicBlock,
    main_entry: BasicBlock,
    try_body: GenFunc,
) -&gt; Register | AssignmentTarget | None:
    # Compile the try block with an error handler
    control = TryFinallyNonlocalControl(return_entry)
    builder.builder.push_error_handler(err_handler)

    builder.nonlocal_control.append(control)
    builder.goto_and_activate(BasicBlock())
    try_body()
    builder.goto(main_entry)
    builder.nonlocal_control.pop()
    builder.builder.pop_error_handler()

    return control.ret_reg
</t>
<t tx="ekr.20240308084832.1704">def try_finally_entry_blocks(
    builder: IRBuilder,
    err_handler: BasicBlock,
    return_entry: BasicBlock,
    main_entry: BasicBlock,
    finally_block: BasicBlock,
    ret_reg: Register | AssignmentTarget | None,
) -&gt; Value:
    old_exc = Register(exc_rtuple)

    # Entry block for non-exceptional flow
    builder.activate_block(main_entry)
    if ret_reg:
        builder.assign(ret_reg, builder.add(LoadErrorValue(builder.ret_types[-1])), -1)
    builder.goto(return_entry)

    builder.activate_block(return_entry)
    builder.add(Assign(old_exc, builder.add(LoadErrorValue(exc_rtuple))))
    builder.goto(finally_block)

    # Entry block for errors
    builder.activate_block(err_handler)
    if ret_reg:
        builder.assign(ret_reg, builder.add(LoadErrorValue(builder.ret_types[-1])), -1)
    builder.add(Assign(old_exc, builder.call_c(error_catch_op, [], -1)))
    builder.goto(finally_block)

    return old_exc
</t>
<t tx="ekr.20240308084832.1705">def try_finally_body(
    builder: IRBuilder, finally_block: BasicBlock, finally_body: GenFunc, old_exc: Value
) -&gt; tuple[BasicBlock, FinallyNonlocalControl]:
    cleanup_block = BasicBlock()
    # Compile the finally block with the nonlocal control flow overridden to restore exc_info
    builder.builder.push_error_handler(cleanup_block)
    finally_control = FinallyNonlocalControl(builder.nonlocal_control[-1], old_exc)
    builder.nonlocal_control.append(finally_control)
    builder.activate_block(finally_block)
    finally_body()
    builder.nonlocal_control.pop()

    return cleanup_block, finally_control
</t>
<t tx="ekr.20240308084832.1706">def try_finally_resolve_control(
    builder: IRBuilder,
    cleanup_block: BasicBlock,
    finally_control: FinallyNonlocalControl,
    old_exc: Value,
    ret_reg: Register | AssignmentTarget | None,
) -&gt; BasicBlock:
    """Resolve the control flow out of a finally block.

    This means returning if there was a return, propagating
    exceptions, break/continue (soon), or just continuing on.
    """
    reraise, rest = BasicBlock(), BasicBlock()
    builder.add(Branch(old_exc, rest, reraise, Branch.IS_ERROR))

    # Reraise the exception if there was one
    builder.activate_block(reraise)
    builder.call_c(reraise_exception_op, [], NO_TRACEBACK_LINE_NO)
    builder.add(Unreachable())
    builder.builder.pop_error_handler()

    # If there was a return, keep returning
    if ret_reg:
        builder.activate_block(rest)
        return_block, rest = BasicBlock(), BasicBlock()
        builder.add(Branch(builder.read(ret_reg), rest, return_block, Branch.IS_ERROR))

        builder.activate_block(return_block)
        builder.nonlocal_control[-1].gen_return(builder, builder.read(ret_reg), -1)

    # TODO: handle break/continue
    builder.activate_block(rest)
    out_block = BasicBlock()
    builder.goto(out_block)

    # If there was an exception, restore again
    builder.activate_block(cleanup_block)
    finally_control.gen_cleanup(builder, -1)
    builder.call_c(keep_propagating_op, [], NO_TRACEBACK_LINE_NO)
    builder.add(Unreachable())

    return out_block
</t>
<t tx="ekr.20240308084832.1707">def transform_try_finally_stmt(
    builder: IRBuilder, try_body: GenFunc, finally_body: GenFunc
) -&gt; None:
    """Generalized try/finally handling that takes functions to gen the bodies.

    The point of this is to also be able to support with."""
    # Finally is a big pain, because there are so many ways that
    # exits can occur. We emit 10+ basic blocks for every finally!

    err_handler, main_entry, return_entry, finally_block = (
        BasicBlock(),
        BasicBlock(),
        BasicBlock(),
        BasicBlock(),
    )

    # Compile the body of the try
    ret_reg = try_finally_try(builder, err_handler, return_entry, main_entry, try_body)

    # Set up the entry blocks for the finally statement
    old_exc = try_finally_entry_blocks(
        builder, err_handler, return_entry, main_entry, finally_block, ret_reg
    )

    # Compile the body of the finally
    cleanup_block, finally_control = try_finally_body(
        builder, finally_block, finally_body, old_exc
    )

    # Resolve the control flow out of the finally block
    out_block = try_finally_resolve_control(
        builder, cleanup_block, finally_control, old_exc, ret_reg
    )

    builder.activate_block(out_block)
</t>
<t tx="ekr.20240308084832.1708">def transform_try_stmt(builder: IRBuilder, t: TryStmt) -&gt; None:
    # Our compilation strategy for try/except/else/finally is to
    # treat try/except/else and try/finally as separate language
    # constructs that we compile separately. When we have a
    # try/except/else/finally, we treat the try/except/else as the
    # body of a try/finally block.
    if t.is_star:
        builder.error("Exception groups and except* cannot be compiled yet", t.line)
    if t.finally_body:

        def transform_try_body() -&gt; None:
            if t.handlers:
                transform_try_except_stmt(builder, t)
            else:
                builder.accept(t.body)

        body = t.finally_body

        transform_try_finally_stmt(builder, transform_try_body, lambda: builder.accept(body))
    else:
        transform_try_except_stmt(builder, t)
</t>
<t tx="ekr.20240308084832.1709">def get_sys_exc_info(builder: IRBuilder) -&gt; list[Value]:
    exc_info = builder.call_c(get_exc_info_op, [], -1)
    return [builder.add(TupleGet(exc_info, i, -1)) for i in range(3)]
</t>
<t tx="ekr.20240308084832.171">def visit_assign(self, op: Assign) -&gt; GenAndKill[Value]:
    # Loading an error value may undefine the register.
    if isinstance(op.src, LoadErrorValue) and (op.src.undefines or self.strict_errors):
        return set(), {op.dest}
    else:
        return {op.dest}, set()
</t>
<t tx="ekr.20240308084832.1710">def transform_with(
    builder: IRBuilder,
    expr: Expression,
    target: Lvalue | None,
    body: GenFunc,
    is_async: bool,
    line: int,
) -&gt; None:
    # This is basically a straight transcription of the Python code in PEP 343.
    # I don't actually understand why a bunch of it is the way it is.
    # We could probably optimize the case where the manager is compiled by us,
    # but that is not our common case at all, so.

    al = "a" if is_async else ""

    mgr_v = builder.accept(expr)
    is_native = isinstance(mgr_v.type, RInstance)
    if is_native:
        value = builder.add(MethodCall(mgr_v, f"__{al}enter__", args=[], line=line))
        exit_ = None
    else:
        typ = builder.call_c(type_op, [mgr_v], line)
        exit_ = builder.maybe_spill(builder.py_get_attr(typ, f"__{al}exit__", line))
        value = builder.py_call(builder.py_get_attr(typ, f"__{al}enter__", line), [mgr_v], line)

    mgr = builder.maybe_spill(mgr_v)
    exc = builder.maybe_spill_assignable(builder.true())
    if is_async:
        value = emit_await(builder, value, line)

    def maybe_natively_call_exit(exc_info: bool) -&gt; Value:
        if exc_info:
            args = get_sys_exc_info(builder)
        else:
            none = builder.none_object()
            args = [none, none, none]

        if is_native:
            assert isinstance(mgr_v.type, RInstance)
            exit_val = builder.gen_method_call(
                builder.read(mgr),
                f"__{al}exit__",
                arg_values=args,
                line=line,
                result_type=none_rprimitive,
            )
        else:
            assert exit_ is not None
            exit_val = builder.py_call(builder.read(exit_), [builder.read(mgr)] + args, line)

        if is_async:
            return emit_await(builder, exit_val, line)
        else:
            return exit_val

    def try_body() -&gt; None:
        if target:
            builder.assign(builder.get_assignment_target(target), value, line)
        body()

    def except_body() -&gt; None:
        builder.assign(exc, builder.false(), line)
        out_block, reraise_block = BasicBlock(), BasicBlock()
        builder.add_bool_branch(maybe_natively_call_exit(exc_info=True), out_block, reraise_block)
        builder.activate_block(reraise_block)
        builder.call_c(reraise_exception_op, [], NO_TRACEBACK_LINE_NO)
        builder.add(Unreachable())
        builder.activate_block(out_block)

    def finally_body() -&gt; None:
        out_block, exit_block = BasicBlock(), BasicBlock()
        builder.add(Branch(builder.read(exc), exit_block, out_block, Branch.BOOL))
        builder.activate_block(exit_block)

        maybe_natively_call_exit(exc_info=False)
        builder.goto_and_activate(out_block)

    transform_try_finally_stmt(
        builder,
        lambda: transform_try_except(builder, try_body, [(None, None, except_body)], None, line),
        finally_body,
    )
</t>
<t tx="ekr.20240308084832.1711">def transform_with_stmt(builder: IRBuilder, o: WithStmt) -&gt; None:
    # Generate separate logic for each expr in it, left to right
    def generate(i: int) -&gt; None:
        if i &gt;= len(o.expr):
            builder.accept(o.body)
        else:
            transform_with(
                builder, o.expr[i], o.target[i], lambda: generate(i + 1), o.is_async, o.line
            )

    generate(0)
</t>
<t tx="ekr.20240308084832.1712">def transform_assert_stmt(builder: IRBuilder, a: AssertStmt) -&gt; None:
    if builder.options.strip_asserts:
        return
    cond = builder.accept(a.expr)
    ok_block, error_block = BasicBlock(), BasicBlock()
    builder.add_bool_branch(cond, ok_block, error_block)
    builder.activate_block(error_block)
    if a.msg is None:
        # Special case (for simpler generated code)
        builder.add(RaiseStandardError(RaiseStandardError.ASSERTION_ERROR, None, a.line))
    elif isinstance(a.msg, StrExpr):
        # Another special case
        builder.add(RaiseStandardError(RaiseStandardError.ASSERTION_ERROR, a.msg.value, a.line))
    else:
        # The general case -- explicitly construct an exception instance
        message = builder.accept(a.msg)
        exc_type = builder.load_module_attr_by_fullname("builtins.AssertionError", a.line)
        exc = builder.py_call(exc_type, [message], a.line)
        builder.call_c(raise_exception_op, [exc], a.line)
    builder.add(Unreachable())
    builder.activate_block(ok_block)
</t>
<t tx="ekr.20240308084832.1713">def transform_del_stmt(builder: IRBuilder, o: DelStmt) -&gt; None:
    transform_del_item(builder, builder.get_assignment_target(o.expr), o.line)
</t>
<t tx="ekr.20240308084832.1714">def transform_del_item(builder: IRBuilder, target: AssignmentTarget, line: int) -&gt; None:
    if isinstance(target, AssignmentTargetIndex):
        builder.gen_method_call(
            target.base, "__delitem__", [target.index], result_type=None, line=line
        )
    elif isinstance(target, AssignmentTargetAttr):
        if isinstance(target.obj_type, RInstance):
            cl = target.obj_type.class_ir
            if not cl.is_deletable(target.attr):
                builder.error(f'"{target.attr}" cannot be deleted', line)
                builder.note(
                    'Using "__deletable__ = '
                    + '[\'&lt;attr&gt;\']" in the class body enables "del obj.&lt;attr&gt;"',
                    line,
                )
        key = builder.load_str(target.attr)
        builder.call_c(py_delattr_op, [target.obj, key], line)
    elif isinstance(target, AssignmentTargetRegister):
        # Delete a local by assigning an error value to it, which will
        # prompt the insertion of uninit checks.
        builder.add(
            Assign(target.register, builder.add(LoadErrorValue(target.type, undefines=True)))
        )
    elif isinstance(target, AssignmentTargetTuple):
        for subtarget in target.items:
            transform_del_item(builder, subtarget, line)
</t>
<t tx="ekr.20240308084832.1715"># yield/yield from/await

# These are really expressions, not statements... but they depend on try/except/finally


def emit_yield(builder: IRBuilder, val: Value, line: int) -&gt; Value:
    retval = builder.coerce(val, builder.ret_types[-1], line)

    cls = builder.fn_info.generator_class
    # Create a new block for the instructions immediately following the yield expression, and
    # set the next label so that the next time '__next__' is called on the generator object,
    # the function continues at the new block.
    next_block = BasicBlock()
    next_label = len(cls.continuation_blocks)
    cls.continuation_blocks.append(next_block)
    builder.assign(cls.next_label_target, Integer(next_label), line)
    builder.add(Return(retval))
    builder.activate_block(next_block)

    add_raise_exception_blocks_to_generator_class(builder, line)

    assert cls.send_arg_reg is not None
    return cls.send_arg_reg
</t>
<t tx="ekr.20240308084832.1716">def emit_yield_from_or_await(
    builder: IRBuilder, val: Value, line: int, *, is_await: bool
) -&gt; Value:
    # This is basically an implementation of the code in PEP 380.

    # TODO: do we want to use the right types here?
    result = Register(object_rprimitive)
    to_yield_reg = Register(object_rprimitive)
    received_reg = Register(object_rprimitive)

    get_op = coro_op if is_await else iter_op
    iter_val = builder.call_c(get_op, [val], line)

    iter_reg = builder.maybe_spill_assignable(iter_val)

    stop_block, main_block, done_block = BasicBlock(), BasicBlock(), BasicBlock()
    _y_init = builder.call_c(next_raw_op, [builder.read(iter_reg)], line)
    builder.add(Branch(_y_init, stop_block, main_block, Branch.IS_ERROR))

    # Try extracting a return value from a StopIteration and return it.
    # If it wasn't, this reraises the exception.
    builder.activate_block(stop_block)
    builder.assign(result, builder.call_c(check_stop_op, [], line), line)
    builder.goto(done_block)

    builder.activate_block(main_block)
    builder.assign(to_yield_reg, _y_init, line)

    # OK Now the main loop!
    loop_block = BasicBlock()
    builder.goto_and_activate(loop_block)

    def try_body() -&gt; None:
        builder.assign(received_reg, emit_yield(builder, builder.read(to_yield_reg), line), line)

    def except_body() -&gt; None:
        # The body of the except is all implemented in a C function to
        # reduce how much code we need to generate. It returns a value
        # indicating whether to break or yield (or raise an exception).
        val = Register(object_rprimitive)
        val_address = builder.add(LoadAddress(object_pointer_rprimitive, val))
        to_stop = builder.call_c(yield_from_except_op, [builder.read(iter_reg), val_address], line)

        ok, stop = BasicBlock(), BasicBlock()
        builder.add(Branch(to_stop, stop, ok, Branch.BOOL))

        # The exception got swallowed. Continue, yielding the returned value
        builder.activate_block(ok)
        builder.assign(to_yield_reg, val, line)
        builder.nonlocal_control[-1].gen_continue(builder, line)

        # The exception was a StopIteration. Stop iterating.
        builder.activate_block(stop)
        builder.assign(result, val, line)
        builder.nonlocal_control[-1].gen_break(builder, line)

    def else_body() -&gt; None:
        # Do a next() or a .send(). It will return NULL on exception
        # but it won't automatically propagate.
        _y = builder.call_c(send_op, [builder.read(iter_reg), builder.read(received_reg)], line)
        ok, stop = BasicBlock(), BasicBlock()
        builder.add(Branch(_y, stop, ok, Branch.IS_ERROR))

        # Everything's fine. Yield it.
        builder.activate_block(ok)
        builder.assign(to_yield_reg, _y, line)
        builder.nonlocal_control[-1].gen_continue(builder, line)

        # Try extracting a return value from a StopIteration and return it.
        # If it wasn't, this rereaises the exception.
        builder.activate_block(stop)
        builder.assign(result, builder.call_c(check_stop_op, [], line), line)
        builder.nonlocal_control[-1].gen_break(builder, line)

    builder.push_loop_stack(loop_block, done_block)
    transform_try_except(builder, try_body, [(None, None, except_body)], else_body, line)
    builder.pop_loop_stack()

    builder.goto_and_activate(done_block)
    return builder.read(result)
</t>
<t tx="ekr.20240308084832.1717">def emit_await(builder: IRBuilder, val: Value, line: int) -&gt; Value:
    return emit_yield_from_or_await(builder, val, line, is_await=True)
</t>
<t tx="ekr.20240308084832.1718">def transform_yield_expr(builder: IRBuilder, expr: YieldExpr) -&gt; Value:
    if builder.fn_info.is_coroutine:
        builder.error("async generators are unimplemented", expr.line)

    if expr.expr:
        retval = builder.accept(expr.expr)
    else:
        retval = builder.builder.none()
    return emit_yield(builder, retval, expr.line)
</t>
<t tx="ekr.20240308084832.1719">def transform_yield_from_expr(builder: IRBuilder, o: YieldFromExpr) -&gt; Value:
    return emit_yield_from_or_await(builder, builder.accept(o.expr), o.line, is_await=False)
</t>
<t tx="ekr.20240308084832.172">def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill[Value]:
    # Array registers are special and we don't track the definedness of them.
    return set(), set()
</t>
<t tx="ekr.20240308084832.1720">def transform_await_expr(builder: IRBuilder, o: AwaitExpr) -&gt; Value:
    return emit_yield_from_or_await(builder, builder.accept(o.expr), o.line, is_await=True)
</t>
<t tx="ekr.20240308084832.1721">def transform_match_stmt(builder: IRBuilder, m: MatchStmt) -&gt; None:
    m.accept(MatchVisitor(builder, m))
</t>
<t tx="ekr.20240308084832.1722">from __future__ import annotations

from mypyc.ir.ops import Register, Value
from mypyc.ir.rtypes import RInstance, RType, object_rprimitive


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1723">class AssignmentTarget:
    """Abstract base class for assignment targets during IR building."""

    type: RType = object_rprimitive
</t>
<t tx="ekr.20240308084832.1724">class AssignmentTargetRegister(AssignmentTarget):
    """Register as an assignment target.
    
    This is used for local variables and some temporaries.
    """
    @others
</t>
<t tx="ekr.20240308084832.1725">def __init__(self, register: Register) -&gt; None:
    self.register = register
    self.type = register.type
</t>
<t tx="ekr.20240308084832.1726">class AssignmentTargetIndex(AssignmentTarget):
    """base[index] as assignment target"""
    @others
</t>
<t tx="ekr.20240308084832.1727">def __init__(self, base: Value, index: Value) -&gt; None:
    self.base = base
    self.index = index
    # TODO: object_rprimitive won't be right for user-defined classes. Store the
    #       lvalue type in mypy and use a better type to avoid unneeded boxing.
    self.type = object_rprimitive
</t>
<t tx="ekr.20240308084832.1728">class AssignmentTargetAttr(AssignmentTarget):
    """obj.attr as assignment target"""
    @others
</t>
<t tx="ekr.20240308084832.1729">def __init__(self, obj: Value, attr: str, can_borrow: bool = False) -&gt; None:
    self.obj = obj
    self.attr = attr
    self.can_borrow = can_borrow
    if isinstance(obj.type, RInstance) and obj.type.class_ir.has_attr(attr):
        # Native attribute reference
        self.obj_type: RType = obj.type
        self.type = obj.type.attr_type(attr)
    else:
        # Python attribute reference
        self.obj_type = object_rprimitive
        self.type = object_rprimitive
</t>
<t tx="ekr.20240308084832.173">def visit_set_mem(self, op: SetMem) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1730">class AssignmentTargetTuple(AssignmentTarget):
    """x, ..., y as assignment target"""
    @others
</t>
<t tx="ekr.20240308084832.1731">def __init__(self, items: list[AssignmentTarget], star_idx: int | None = None) -&gt; None:
    self.items = items
    self.star_idx = star_idx
</t>
<t tx="ekr.20240308084832.1732">"""Various utilities that don't depend on other modules in mypyc.irbuild."""

from __future__ import annotations

from typing import Any

from mypy.nodes import (
    ARG_NAMED,
    ARG_NAMED_OPT,
    ARG_OPT,
    ARG_POS,
    GDEF,
    ArgKind,
    BytesExpr,
    CallExpr,
    ClassDef,
    Decorator,
    Expression,
    FloatExpr,
    FuncDef,
    IntExpr,
    NameExpr,
    OverloadedFuncDef,
    RefExpr,
    StrExpr,
    TupleExpr,
    UnaryExpr,
    Var,
)

DATACLASS_DECORATORS = {"dataclasses.dataclass", "attr.s", "attr.attrs"}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1733">def is_trait_decorator(d: Expression) -&gt; bool:
    return isinstance(d, RefExpr) and d.fullname == "mypy_extensions.trait"
</t>
<t tx="ekr.20240308084832.1734">def is_trait(cdef: ClassDef) -&gt; bool:
    return any(is_trait_decorator(d) for d in cdef.decorators) or cdef.info.is_protocol
</t>
<t tx="ekr.20240308084832.1735">def dataclass_decorator_type(d: Expression) -&gt; str | None:
    if isinstance(d, RefExpr) and d.fullname in DATACLASS_DECORATORS:
        return d.fullname.split(".")[0]
    elif (
        isinstance(d, CallExpr)
        and isinstance(d.callee, RefExpr)
        and d.callee.fullname in DATACLASS_DECORATORS
    ):
        name = d.callee.fullname.split(".")[0]
        if name == "attr" and "auto_attribs" in d.arg_names:
            # Note: the mypy attrs plugin checks that the value of auto_attribs is
            # not computed at runtime, so we don't need to perform that check here
            auto = d.args[d.arg_names.index("auto_attribs")]
            if isinstance(auto, NameExpr) and auto.name == "True":
                return "attr-auto"
        return name
    else:
        return None
</t>
<t tx="ekr.20240308084832.1736">def is_dataclass_decorator(d: Expression) -&gt; bool:
    return dataclass_decorator_type(d) is not None
</t>
<t tx="ekr.20240308084832.1737">def is_dataclass(cdef: ClassDef) -&gt; bool:
    return any(is_dataclass_decorator(d) for d in cdef.decorators)
</t>
<t tx="ekr.20240308084832.1738">def dataclass_type(cdef: ClassDef) -&gt; str | None:
    for d in cdef.decorators:
        typ = dataclass_decorator_type(d)
        if typ is not None:
            return typ
    return None
</t>
<t tx="ekr.20240308084832.1739">def get_mypyc_attr_literal(e: Expression) -&gt; Any:
    """Convert an expression from a mypyc_attr decorator to a value.

    Supports a pretty limited range."""
    if isinstance(e, (StrExpr, IntExpr, FloatExpr)):
        return e.value
    elif isinstance(e, RefExpr) and e.fullname == "builtins.True":
        return True
    elif isinstance(e, RefExpr) and e.fullname == "builtins.False":
        return False
    elif isinstance(e, RefExpr) and e.fullname == "builtins.None":
        return None
    return NotImplemented
</t>
<t tx="ekr.20240308084832.174">def analyze_maybe_defined_regs(
    blocks: list[BasicBlock], cfg: CFG, initial_defined: set[Value]
) -&gt; AnalysisResult[Value]:
    """Calculate potentially defined registers at each CFG location.

    A register is defined if it has a value along some path from the initial location.
    """
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=DefinedVisitor(),
        initial=initial_defined,
        backward=False,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.1740">def get_mypyc_attr_call(d: Expression) -&gt; CallExpr | None:
    """Check if an expression is a call to mypyc_attr and return it if so."""
    if (
        isinstance(d, CallExpr)
        and isinstance(d.callee, RefExpr)
        and d.callee.fullname == "mypy_extensions.mypyc_attr"
    ):
        return d
    return None
</t>
<t tx="ekr.20240308084832.1741">def get_mypyc_attrs(stmt: ClassDef | Decorator) -&gt; dict[str, Any]:
    """Collect all the mypyc_attr attributes on a class definition or a function."""
    attrs: dict[str, Any] = {}
    for dec in stmt.decorators:
        d = get_mypyc_attr_call(dec)
        if d:
            for name, arg in zip(d.arg_names, d.args):
                if name is None:
                    if isinstance(arg, StrExpr):
                        attrs[arg.value] = True
                else:
                    attrs[name] = get_mypyc_attr_literal(arg)

    return attrs
</t>
<t tx="ekr.20240308084832.1742">def is_extension_class(cdef: ClassDef) -&gt; bool:
    if any(
        not is_trait_decorator(d) and not is_dataclass_decorator(d) and not get_mypyc_attr_call(d)
        for d in cdef.decorators
    ):
        return False
    if cdef.info.typeddict_type:
        return False
    if cdef.info.is_named_tuple:
        return False
    if cdef.info.metaclass_type and cdef.info.metaclass_type.type.fullname not in (
        "abc.ABCMeta",
        "typing.TypingMeta",
        "typing.GenericMeta",
    ):
        return False
    return True
</t>
<t tx="ekr.20240308084832.1743">def get_func_def(op: FuncDef | Decorator | OverloadedFuncDef) -&gt; FuncDef:
    if isinstance(op, OverloadedFuncDef):
        assert op.impl
        op = op.impl
    if isinstance(op, Decorator):
        op = op.func
    return op
</t>
<t tx="ekr.20240308084832.1744">def concrete_arg_kind(kind: ArgKind) -&gt; ArgKind:
    """Find the concrete version of an arg kind that is being passed."""
    if kind == ARG_OPT:
        return ARG_POS
    elif kind == ARG_NAMED_OPT:
        return ARG_NAMED
    else:
        return kind
</t>
<t tx="ekr.20240308084832.1745">def is_constant(e: Expression) -&gt; bool:
    """Check whether we allow an expression to appear as a default value.

    We don't currently properly support storing the evaluated
    values for default arguments and default attribute values, so
    we restrict what expressions we allow.  We allow literals of
    primitives types, None, and references to Final global
    variables.
    """
    return (
        isinstance(e, (StrExpr, BytesExpr, IntExpr, FloatExpr))
        or (isinstance(e, UnaryExpr) and e.op == "-" and isinstance(e.expr, (IntExpr, FloatExpr)))
        or (isinstance(e, TupleExpr) and all(is_constant(e) for e in e.items))
        or (
            isinstance(e, RefExpr)
            and e.kind == GDEF
            and (
                e.fullname in ("builtins.True", "builtins.False", "builtins.None")
                or (isinstance(e.node, Var) and e.node.is_final)
            )
        )
    )
</t>
<t tx="ekr.20240308084832.1746">def bytes_from_str(value: str) -&gt; bytes:
    """Convert a string representing bytes into actual bytes.

    This is needed because the literal characters of BytesExpr (the
    characters inside b'') are stored in BytesExpr.value, whose type is
    'str' not 'bytes'.
    """
    return bytes(value, "utf8").decode("unicode-escape").encode("raw-unicode-escape")
</t>
<t tx="ekr.20240308084832.1747">"""Dispatcher used when transforming a mypy AST to the IR form.

mypyc.irbuild.builder and mypyc.irbuild.main are closely related.
"""

from __future__ import annotations

from typing import NoReturn

from mypy.nodes import (
    AssertStmt,
    AssertTypeExpr,
    AssignmentExpr,
    AssignmentStmt,
    AwaitExpr,
    Block,
    BreakStmt,
    BytesExpr,
    CallExpr,
    CastExpr,
    ClassDef,
    ComparisonExpr,
    ComplexExpr,
    ConditionalExpr,
    ContinueStmt,
    Decorator,
    DelStmt,
    DictExpr,
    DictionaryComprehension,
    EllipsisExpr,
    EnumCallExpr,
    ExpressionStmt,
    FloatExpr,
    ForStmt,
    FuncDef,
    GeneratorExpr,
    GlobalDecl,
    IfStmt,
    Import,
    ImportAll,
    ImportFrom,
    IndexExpr,
    IntExpr,
    LambdaExpr,
    ListComprehension,
    ListExpr,
    MatchStmt,
    MemberExpr,
    MypyFile,
    NamedTupleExpr,
    NameExpr,
    NewTypeExpr,
    NonlocalDecl,
    OperatorAssignmentStmt,
    OpExpr,
    OverloadedFuncDef,
    ParamSpecExpr,
    PassStmt,
    PromoteExpr,
    RaiseStmt,
    ReturnStmt,
    RevealExpr,
    SetComprehension,
    SetExpr,
    SliceExpr,
    StarExpr,
    StrExpr,
    SuperExpr,
    TempNode,
    TryStmt,
    TupleExpr,
    TypeAliasExpr,
    TypeApplication,
    TypedDictExpr,
    TypeVarExpr,
    TypeVarTupleExpr,
    UnaryExpr,
    Var,
    WhileStmt,
    WithStmt,
    YieldExpr,
    YieldFromExpr,
)
from mypyc.ir.ops import Value
from mypyc.irbuild.builder import IRBuilder, IRVisitor, UnsupportedException
from mypyc.irbuild.classdef import transform_class_def
from mypyc.irbuild.expression import (
    transform_assignment_expr,
    transform_bytes_expr,
    transform_call_expr,
    transform_comparison_expr,
    transform_complex_expr,
    transform_conditional_expr,
    transform_dict_expr,
    transform_dictionary_comprehension,
    transform_ellipsis,
    transform_float_expr,
    transform_generator_expr,
    transform_index_expr,
    transform_int_expr,
    transform_list_comprehension,
    transform_list_expr,
    transform_member_expr,
    transform_name_expr,
    transform_op_expr,
    transform_set_comprehension,
    transform_set_expr,
    transform_slice_expr,
    transform_str_expr,
    transform_super_expr,
    transform_tuple_expr,
    transform_unary_expr,
)
from mypyc.irbuild.function import (
    transform_decorator,
    transform_func_def,
    transform_lambda_expr,
    transform_overloaded_func_def,
)
from mypyc.irbuild.statement import (
    transform_assert_stmt,
    transform_assignment_stmt,
    transform_await_expr,
    transform_block,
    transform_break_stmt,
    transform_continue_stmt,
    transform_del_stmt,
    transform_expression_stmt,
    transform_for_stmt,
    transform_if_stmt,
    transform_import,
    transform_import_all,
    transform_import_from,
    transform_match_stmt,
    transform_operator_assignment_stmt,
    transform_raise_stmt,
    transform_return_stmt,
    transform_try_stmt,
    transform_while_stmt,
    transform_with_stmt,
    transform_yield_expr,
    transform_yield_from_expr,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1748">class IRBuilderVisitor(IRVisitor):
    """Mypy node visitor that dispatches to node transform implementations.
    
    This class should have no non-trivial logic.
    
    This visitor is separated from the rest of code to improve modularity and
    to avoid import cycles.
    
    This is based on the visitor pattern
    (https://en.wikipedia.org/wiki/Visitor_pattern).
    """
    @others
</t>
<t tx="ekr.20240308084832.1749"># This gets passed to all the implementations and contains all the
# state and many helpers. The attribute is initialized outside
# this class since this class and IRBuilder form a reference loop.
builder: IRBuilder

def visit_mypy_file(self, mypyfile: MypyFile) -&gt; None:
    assert False, "use transform_mypy_file instead"
</t>
<t tx="ekr.20240308084832.175">def analyze_must_defined_regs(
    blocks: list[BasicBlock],
    cfg: CFG,
    initial_defined: set[Value],
    regs: Iterable[Value],
    strict_errors: bool = False,
) -&gt; AnalysisResult[Value]:
    """Calculate always defined registers at each CFG location.

    This analysis can work before exception insertion, since it is a
    sound assumption that registers defined in a block might not be
    initialized in its error handler.

    A register is defined if it has a value along all paths from the
    initial location.
    """
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=DefinedVisitor(strict_errors=strict_errors),
        initial=initial_defined,
        backward=False,
        kind=MUST_ANALYSIS,
        universe=set(regs),
    )
</t>
<t tx="ekr.20240308084832.1750">def visit_class_def(self, cdef: ClassDef) -&gt; None:
    transform_class_def(self.builder, cdef)
</t>
<t tx="ekr.20240308084832.1751">def visit_import(self, node: Import) -&gt; None:
    transform_import(self.builder, node)
</t>
<t tx="ekr.20240308084832.1752">def visit_import_from(self, node: ImportFrom) -&gt; None:
    transform_import_from(self.builder, node)
</t>
<t tx="ekr.20240308084832.1753">def visit_import_all(self, node: ImportAll) -&gt; None:
    transform_import_all(self.builder, node)
</t>
<t tx="ekr.20240308084832.1754">def visit_func_def(self, fdef: FuncDef) -&gt; None:
    transform_func_def(self.builder, fdef)
</t>
<t tx="ekr.20240308084832.1755">def visit_overloaded_func_def(self, o: OverloadedFuncDef) -&gt; None:
    transform_overloaded_func_def(self.builder, o)
</t>
<t tx="ekr.20240308084832.1756">def visit_decorator(self, dec: Decorator) -&gt; None:
    transform_decorator(self.builder, dec)
</t>
<t tx="ekr.20240308084832.1757">def visit_block(self, block: Block) -&gt; None:
    transform_block(self.builder, block)
</t>
<t tx="ekr.20240308084832.1758"># Statements

def visit_expression_stmt(self, stmt: ExpressionStmt) -&gt; None:
    transform_expression_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1759">def visit_return_stmt(self, stmt: ReturnStmt) -&gt; None:
    transform_return_stmt(self.builder, stmt)
    self.builder.mark_block_unreachable()
</t>
<t tx="ekr.20240308084832.176">class BorrowedArgumentsVisitor(BaseAnalysisVisitor[Value]):
    @others
</t>
<t tx="ekr.20240308084832.1760">def visit_assignment_stmt(self, stmt: AssignmentStmt) -&gt; None:
    transform_assignment_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1761">def visit_operator_assignment_stmt(self, stmt: OperatorAssignmentStmt) -&gt; None:
    transform_operator_assignment_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1762">def visit_if_stmt(self, stmt: IfStmt) -&gt; None:
    transform_if_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1763">def visit_while_stmt(self, stmt: WhileStmt) -&gt; None:
    transform_while_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1764">def visit_for_stmt(self, stmt: ForStmt) -&gt; None:
    transform_for_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1765">def visit_break_stmt(self, stmt: BreakStmt) -&gt; None:
    transform_break_stmt(self.builder, stmt)
    self.builder.mark_block_unreachable()
</t>
<t tx="ekr.20240308084832.1766">def visit_continue_stmt(self, stmt: ContinueStmt) -&gt; None:
    transform_continue_stmt(self.builder, stmt)
    self.builder.mark_block_unreachable()
</t>
<t tx="ekr.20240308084832.1767">def visit_raise_stmt(self, stmt: RaiseStmt) -&gt; None:
    transform_raise_stmt(self.builder, stmt)
    self.builder.mark_block_unreachable()
</t>
<t tx="ekr.20240308084832.1768">def visit_try_stmt(self, stmt: TryStmt) -&gt; None:
    transform_try_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1769">def visit_with_stmt(self, stmt: WithStmt) -&gt; None:
    transform_with_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.177">def __init__(self, args: set[Value]) -&gt; None:
    self.args = args
</t>
<t tx="ekr.20240308084832.1770">def visit_pass_stmt(self, stmt: PassStmt) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.1771">def visit_assert_stmt(self, stmt: AssertStmt) -&gt; None:
    transform_assert_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1772">def visit_del_stmt(self, stmt: DelStmt) -&gt; None:
    transform_del_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1773">def visit_global_decl(self, stmt: GlobalDecl) -&gt; None:
    # Pure declaration -- no runtime effect
    pass
</t>
<t tx="ekr.20240308084832.1774">def visit_nonlocal_decl(self, stmt: NonlocalDecl) -&gt; None:
    # Pure declaration -- no runtime effect
    pass
</t>
<t tx="ekr.20240308084832.1775">def visit_match_stmt(self, stmt: MatchStmt) -&gt; None:
    transform_match_stmt(self.builder, stmt)
</t>
<t tx="ekr.20240308084832.1776"># Expressions

def visit_name_expr(self, expr: NameExpr) -&gt; Value:
    return transform_name_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1777">def visit_member_expr(self, expr: MemberExpr) -&gt; Value:
    return transform_member_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1778">def visit_super_expr(self, expr: SuperExpr) -&gt; Value:
    return transform_super_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1779">def visit_call_expr(self, expr: CallExpr) -&gt; Value:
    return transform_call_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.178">def visit_branch(self, op: Branch) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1780">def visit_unary_expr(self, expr: UnaryExpr) -&gt; Value:
    return transform_unary_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1781">def visit_op_expr(self, expr: OpExpr) -&gt; Value:
    return transform_op_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1782">def visit_index_expr(self, expr: IndexExpr) -&gt; Value:
    return transform_index_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1783">def visit_conditional_expr(self, expr: ConditionalExpr) -&gt; Value:
    return transform_conditional_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1784">def visit_comparison_expr(self, expr: ComparisonExpr) -&gt; Value:
    return transform_comparison_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1785">def visit_int_expr(self, expr: IntExpr) -&gt; Value:
    return transform_int_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1786">def visit_float_expr(self, expr: FloatExpr) -&gt; Value:
    return transform_float_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1787">def visit_complex_expr(self, expr: ComplexExpr) -&gt; Value:
    return transform_complex_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1788">def visit_str_expr(self, expr: StrExpr) -&gt; Value:
    return transform_str_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1789">def visit_bytes_expr(self, expr: BytesExpr) -&gt; Value:
    return transform_bytes_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.179">def visit_return(self, op: Return) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1790">def visit_ellipsis(self, expr: EllipsisExpr) -&gt; Value:
    return transform_ellipsis(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1791">def visit_list_expr(self, expr: ListExpr) -&gt; Value:
    return transform_list_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1792">def visit_tuple_expr(self, expr: TupleExpr) -&gt; Value:
    return transform_tuple_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1793">def visit_dict_expr(self, expr: DictExpr) -&gt; Value:
    return transform_dict_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1794">def visit_set_expr(self, expr: SetExpr) -&gt; Value:
    return transform_set_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1795">def visit_list_comprehension(self, expr: ListComprehension) -&gt; Value:
    return transform_list_comprehension(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1796">def visit_set_comprehension(self, expr: SetComprehension) -&gt; Value:
    return transform_set_comprehension(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1797">def visit_dictionary_comprehension(self, expr: DictionaryComprehension) -&gt; Value:
    return transform_dictionary_comprehension(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1798">def visit_slice_expr(self, expr: SliceExpr) -&gt; Value:
    return transform_slice_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1799">def visit_generator_expr(self, expr: GeneratorExpr) -&gt; Value:
    return transform_generator_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.18">def write_file(path: str, contents: str) -&gt; None:
    """Write data into a file.

    If the file already exists and has the same contents we
    want to write, skip writing so as to preserve the mtime
    and avoid triggering recompilation.
    """
    # We encode it ourselves and open the files as binary to avoid windows
    # newline translation
    encoded_contents = contents.encode("utf-8")
    try:
        with open(path, "rb") as f:
            old_contents: bytes | None = f.read()
    except OSError:
        old_contents = None
    if old_contents != encoded_contents:
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "wb") as g:
            g.write(encoded_contents)

        # Fudge the mtime forward because otherwise when two builds happen close
        # together (like in a test) setuptools might not realize the source is newer
        # than the new artifact.
        # XXX: This is bad though.
        new_mtime = os.stat(path).st_mtime + 1
        os.utime(path, times=(new_mtime, new_mtime))
</t>
<t tx="ekr.20240308084832.180">def visit_unreachable(self, op: Unreachable) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1800">def visit_lambda_expr(self, expr: LambdaExpr) -&gt; Value:
    return transform_lambda_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1801">def visit_yield_expr(self, expr: YieldExpr) -&gt; Value:
    return transform_yield_expr(self.builder, expr)
</t>
<t tx="ekr.20240308084832.1802">def visit_yield_from_expr(self, o: YieldFromExpr) -&gt; Value:
    return transform_yield_from_expr(self.builder, o)
</t>
<t tx="ekr.20240308084832.1803">def visit_await_expr(self, o: AwaitExpr) -&gt; Value:
    return transform_await_expr(self.builder, o)
</t>
<t tx="ekr.20240308084832.1804">def visit_assignment_expr(self, o: AssignmentExpr) -&gt; Value:
    return transform_assignment_expr(self.builder, o)
</t>
<t tx="ekr.20240308084832.1805"># Constructs that shouldn't ever show up

def visit_enum_call_expr(self, o: EnumCallExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1806">def visit__promote_expr(self, o: PromoteExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1807">def visit_namedtuple_expr(self, o: NamedTupleExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1808">def visit_newtype_expr(self, o: NewTypeExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1809">def visit_temp_node(self, o: TempNode) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.181">def visit_register_op(self, op: RegisterOp) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1810">def visit_type_alias_expr(self, o: TypeAliasExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1811">def visit_type_application(self, o: TypeApplication) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1812">def visit_type_var_expr(self, o: TypeVarExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1813">def visit_paramspec_expr(self, o: ParamSpecExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1814">def visit_type_var_tuple_expr(self, o: TypeVarTupleExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1815">def visit_typeddict_expr(self, o: TypedDictExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1816">def visit_reveal_expr(self, o: RevealExpr) -&gt; Value:
    assert False, "can't compile analysis-only expressions"
</t>
<t tx="ekr.20240308084832.1817">def visit_var(self, o: Var) -&gt; None:
    assert False, "can't compile Var; should have been handled already?"
</t>
<t tx="ekr.20240308084832.1818">def visit_cast_expr(self, o: CastExpr) -&gt; Value:
    assert False, "CastExpr should have been handled in CallExpr"
</t>
<t tx="ekr.20240308084832.1819">def visit_assert_type_expr(self, o: AssertTypeExpr) -&gt; Value:
    assert False, "AssertTypeExpr should have been handled in CallExpr"
</t>
<t tx="ekr.20240308084832.182">def visit_assign(self, op: Assign) -&gt; GenAndKill[Value]:
    if op.dest in self.args:
        return set(), {op.dest}
    return set(), set()
</t>
<t tx="ekr.20240308084832.1820">def visit_star_expr(self, o: StarExpr) -&gt; Value:
    assert False, "should have been handled in Tuple/List/Set/DictExpr or CallExpr"
</t>
<t tx="ekr.20240308084832.1821"># Helpers

def bail(self, msg: str, line: int) -&gt; NoReturn:
    """Reports an error and aborts compilation up until the last accept() call

    (accept() catches the UnsupportedException and keeps on
    processing. This allows errors to be non-blocking without always
    needing to write handling for them.
    """
    self.builder.error(msg, line)
    raise UnsupportedException()
</t>
<t tx="ekr.20240308084832.1822">"""Compute vtables of native (extension) classes."""

from __future__ import annotations

import itertools

from mypyc.ir.class_ir import ClassIR, VTableEntries, VTableMethod
from mypyc.sametype import is_same_method_signature


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1823">def compute_vtable(cls: ClassIR) -&gt; None:
    """Compute the vtable structure for a class."""
    if cls.vtable is not None:
        return

    if not cls.is_generated:
        cls.has_dict = any(x.inherits_python for x in cls.mro)

    for t in cls.mro[1:]:
        # Make sure all ancestors are processed first
        compute_vtable(t)
        # Merge attributes from traits into the class
        if not t.is_trait:
            continue
        for name, typ in t.attributes.items():
            if not cls.is_trait and not any(name in b.attributes for b in cls.base_mro):
                cls.attributes[name] = typ

    cls.vtable = {}
    if cls.base:
        assert cls.base.vtable is not None
        cls.vtable.update(cls.base.vtable)
        cls.vtable_entries = specialize_parent_vtable(cls, cls.base)

    # Include the vtable from the parent classes, but handle method overrides.
    entries = cls.vtable_entries

    all_traits = [t for t in cls.mro if t.is_trait]

    for t in [cls] + cls.traits:
        for fn in itertools.chain(t.methods.values()):
            # TODO: don't generate a new entry when we overload without changing the type
            if fn == cls.get_method(fn.name, prefer_method=True):
                cls.vtable[fn.name] = len(entries)
                # If the class contains a glue method referring to itself, that is a
                # shadow glue method to support interpreted subclasses.
                shadow = cls.glue_methods.get((cls, fn.name))
                entries.append(VTableMethod(t, fn.name, fn, shadow))

    # Compute vtables for all of the traits that the class implements
    if not cls.is_trait:
        for trait in all_traits:
            compute_vtable(trait)
            cls.trait_vtables[trait] = specialize_parent_vtable(cls, trait)
</t>
<t tx="ekr.20240308084832.1824">def specialize_parent_vtable(cls: ClassIR, parent: ClassIR) -&gt; VTableEntries:
    """Generate the part of a vtable corresponding to a parent class or trait"""
    updated = []
    for entry in parent.vtable_entries:
        # Find the original method corresponding to this vtable entry.
        # (This may not be the method in the entry, if it was overridden.)
        orig_parent_method = entry.cls.get_method(entry.name, prefer_method=True)
        assert orig_parent_method
        method_cls = cls.get_method_and_class(entry.name, prefer_method=True)
        if method_cls:
            child_method, defining_cls = method_cls
            # TODO: emit a wrapper for __init__ that raises or something
            if (
                is_same_method_signature(orig_parent_method.sig, child_method.sig)
                or orig_parent_method.name == "__init__"
            ):
                entry = VTableMethod(entry.cls, entry.name, child_method, entry.shadow_method)
            else:
                entry = VTableMethod(
                    entry.cls,
                    entry.name,
                    defining_cls.glue_methods[(entry.cls, entry.name)],
                    entry.shadow_method,
                )
        updated.append(entry)
    return updated
</t>
<t tx="ekr.20240308084832.1825"></t>
<t tx="ekr.20240308084832.1826">"""Build script for mypyc C runtime library unit tests.

The tests are written in C++ and use the Google Test framework.
"""

from __future__ import annotations

import os
import subprocess
import sys
from distutils.command.build_ext import build_ext
from distutils.core import Extension, setup
from typing import Any

kwargs: dict[str, Any]
if sys.platform == "darwin":
    kwargs = {"language": "c++"}
    compile_args = []
else:
    kwargs = {}
    compile_args = ["--std=c++11"]


@others
setup(
    name="test_capi",
    version="0.1",
    ext_modules=[
        Extension(
            "test_capi",
            [
                "test_capi.cc",
                "init.c",
                "int_ops.c",
                "float_ops.c",
                "list_ops.c",
                "exc_ops.c",
                "generic_ops.c",
            ],
            depends=["CPy.h", "mypyc_util.h", "pythonsupport.h"],
            extra_compile_args=["-Wno-unused-function", "-Wno-sign-compare"] + compile_args,
            libraries=["gtest"],
            include_dirs=["../external/googletest", "../external/googletest/include"],
            **kwargs,
        )
    ],
    cmdclass={"build_ext": build_ext_custom},
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1827">class build_ext_custom(build_ext):
    @others
</t>
<t tx="ekr.20240308084832.1828">def get_library_names(self):
    return ["gtest"]
</t>
<t tx="ekr.20240308084832.1829">def run(self):
    gtest_dir = os.path.abspath(
        os.path.join(os.path.dirname(__file__), "..", "external", "googletest")
    )

    os.makedirs(self.build_temp, exist_ok=True)

    # Build Google Test, the C++ framework we use for testing C code.
    # The source code for Google Test is copied to this repository.
    subprocess.check_call(
        ["make", "-f", os.path.join(gtest_dir, "make", "Makefile"), f"GTEST_DIR={gtest_dir}"],
        cwd=self.build_temp,
    )

    self.library_dirs = [self.build_temp]

    return build_ext.run(self)
</t>
<t tx="ekr.20240308084832.183">def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1830"></t>
<t tx="ekr.20240308084832.1831">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1832">"""Primitive bytes ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_MAGIC
from mypyc.ir.rtypes import (
    RUnion,
    bytes_rprimitive,
    c_int_rprimitive,
    c_pyssize_t_rprimitive,
    dict_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
    str_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    custom_op,
    function_op,
    load_address_op,
    method_op,
)

# Get the 'bytes' type object.
load_address_op(name="builtins.bytes", type=object_rprimitive, src="PyBytes_Type")

# bytes(obj)
function_op(
    name="builtins.bytes",
    arg_types=[RUnion([list_rprimitive, dict_rprimitive, str_rprimitive])],
    return_type=bytes_rprimitive,
    c_function_name="PyBytes_FromObject",
    error_kind=ERR_MAGIC,
)

# bytearray(obj)
function_op(
    name="builtins.bytearray",
    arg_types=[object_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="PyByteArray_FromObject",
    error_kind=ERR_MAGIC,
)

# bytes ==/!= (return -1/0/1)
bytes_compare = custom_op(
    arg_types=[bytes_rprimitive, bytes_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyBytes_Compare",
    error_kind=ERR_NEG_INT,
)

# bytes + bytes
# bytearray + bytearray
binary_op(
    name="+",
    arg_types=[bytes_rprimitive, bytes_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPyBytes_Concat",
    error_kind=ERR_MAGIC,
    steals=[True, False],
)

# bytes[begin:end]
bytes_slice_op = custom_op(
    arg_types=[bytes_rprimitive, int_rprimitive, int_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPyBytes_GetSlice",
    error_kind=ERR_MAGIC,
)

# bytes[index]
# bytearray[index]
method_op(
    name="__getitem__",
    arg_types=[bytes_rprimitive, int_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyBytes_GetItem",
    error_kind=ERR_MAGIC,
)

# bytes.join(obj)
method_op(
    name="join",
    arg_types=[bytes_rprimitive, object_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPyBytes_Join",
    error_kind=ERR_MAGIC,
)

# Join bytes objects and return a new bytes.
# The first argument is the total number of the following bytes.
bytes_build_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPyBytes_Build",
    error_kind=ERR_MAGIC,
    var_arg_type=bytes_rprimitive,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1833">"""Primitive dict ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_FALSE, ERR_MAGIC, ERR_NEVER
from mypyc.ir.rtypes import (
    bit_rprimitive,
    bool_rprimitive,
    c_int_rprimitive,
    c_pyssize_t_rprimitive,
    dict_next_rtuple_pair,
    dict_next_rtuple_single,
    dict_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    custom_op,
    function_op,
    load_address_op,
    method_op,
)

# Get the 'dict' type object.
load_address_op(name="builtins.dict", type=object_rprimitive, src="PyDict_Type")

# Construct an empty dictionary via dict().
function_op(
    name="builtins.dict",
    arg_types=[],
    return_type=dict_rprimitive,
    c_function_name="PyDict_New",
    error_kind=ERR_MAGIC,
)

# Construct an empty dictionary.
dict_new_op = custom_op(
    arg_types=[], return_type=dict_rprimitive, c_function_name="PyDict_New", error_kind=ERR_MAGIC
)

# Construct a dictionary from keys and values.
# Positional argument is the number of key-value pairs
# Variable arguments are (key1, value1, ..., keyN, valueN).
dict_build_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=dict_rprimitive,
    c_function_name="CPyDict_Build",
    error_kind=ERR_MAGIC,
    var_arg_type=object_rprimitive,
)

# Construct a dictionary from another dictionary.
function_op(
    name="builtins.dict",
    arg_types=[dict_rprimitive],
    return_type=dict_rprimitive,
    c_function_name="PyDict_Copy",
    error_kind=ERR_MAGIC,
    priority=2,
)

# Generic one-argument dict constructor: dict(obj)
dict_copy = function_op(
    name="builtins.dict",
    arg_types=[object_rprimitive],
    return_type=dict_rprimitive,
    c_function_name="CPyDict_FromAny",
    error_kind=ERR_MAGIC,
)

# dict[key]
dict_get_item_op = method_op(
    name="__getitem__",
    arg_types=[dict_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_GetItem",
    error_kind=ERR_MAGIC,
)

# dict[key] = value
dict_set_item_op = method_op(
    name="__setitem__",
    arg_types=[dict_rprimitive, object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyDict_SetItem",
    error_kind=ERR_NEG_INT,
)

# key in dict
binary_op(
    name="in",
    arg_types=[object_rprimitive, dict_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyDict_Contains",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
    ordering=[1, 0],
)

# dict1.update(dict2)
dict_update_op = method_op(
    name="update",
    arg_types=[dict_rprimitive, dict_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyDict_Update",
    error_kind=ERR_NEG_INT,
    priority=2,
)

# Operation used for **value in dict displays.
# This is mostly like dict.update(obj), but has customized error handling.
dict_update_in_display_op = custom_op(
    arg_types=[dict_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyDict_UpdateInDisplay",
    error_kind=ERR_NEG_INT,
)

# dict.update(obj)
method_op(
    name="update",
    arg_types=[dict_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyDict_UpdateFromAny",
    error_kind=ERR_NEG_INT,
)

# dict.get(key, default)
method_op(
    name="get",
    arg_types=[dict_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_Get",
    error_kind=ERR_MAGIC,
)

# dict.get(key)
dict_get_method_with_none = method_op(
    name="get",
    arg_types=[dict_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_GetWithNone",
    error_kind=ERR_MAGIC,
)

# dict.setdefault(key, default)
dict_setdefault_op = method_op(
    name="setdefault",
    arg_types=[dict_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_SetDefault",
    error_kind=ERR_MAGIC,
)

# dict.setdefault(key)
method_op(
    name="setdefault",
    arg_types=[dict_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_SetDefaultWithNone",
    error_kind=ERR_MAGIC,
)

# dict.setdefault(key, empty tuple/list/set)
# The third argument marks the data type of the second argument.
#     1: list    2: dict    3: set
# Other number would lead to an error.
dict_setdefault_spec_init_op = custom_op(
    arg_types=[dict_rprimitive, object_rprimitive, c_int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_SetDefaultWithEmptyDatatype",
    error_kind=ERR_MAGIC,
)

# dict.keys()
method_op(
    name="keys",
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_KeysView",
    error_kind=ERR_MAGIC,
)

# dict.values()
method_op(
    name="values",
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_ValuesView",
    error_kind=ERR_MAGIC,
)

# dict.items()
method_op(
    name="items",
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_ItemsView",
    error_kind=ERR_MAGIC,
)

# dict.clear()
method_op(
    name="clear",
    arg_types=[dict_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyDict_Clear",
    error_kind=ERR_FALSE,
)

# dict.copy()
method_op(
    name="copy",
    arg_types=[dict_rprimitive],
    return_type=dict_rprimitive,
    c_function_name="CPyDict_Copy",
    error_kind=ERR_MAGIC,
)

# list(dict.keys())
dict_keys_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPyDict_Keys",
    error_kind=ERR_MAGIC,
)

# list(dict.values())
dict_values_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPyDict_Values",
    error_kind=ERR_MAGIC,
)

# list(dict.items())
dict_items_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPyDict_Items",
    error_kind=ERR_MAGIC,
)

# PyDict_Next() fast iteration
dict_key_iter_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_GetKeysIter",
    error_kind=ERR_MAGIC,
)

dict_value_iter_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_GetValuesIter",
    error_kind=ERR_MAGIC,
)

dict_item_iter_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyDict_GetItemsIter",
    error_kind=ERR_MAGIC,
)

dict_next_key_op = custom_op(
    arg_types=[object_rprimitive, int_rprimitive],
    return_type=dict_next_rtuple_single,
    c_function_name="CPyDict_NextKey",
    error_kind=ERR_NEVER,
)

dict_next_value_op = custom_op(
    arg_types=[object_rprimitive, int_rprimitive],
    return_type=dict_next_rtuple_single,
    c_function_name="CPyDict_NextValue",
    error_kind=ERR_NEVER,
)

dict_next_item_op = custom_op(
    arg_types=[object_rprimitive, int_rprimitive],
    return_type=dict_next_rtuple_pair,
    c_function_name="CPyDict_NextItem",
    error_kind=ERR_NEVER,
)

# check that len(dict) == const during iteration
dict_check_size_op = custom_op(
    arg_types=[dict_rprimitive, int_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyDict_CheckSize",
    error_kind=ERR_FALSE,
)

dict_ssize_t_size_op = custom_op(
    arg_types=[dict_rprimitive],
    return_type=c_pyssize_t_rprimitive,
    c_function_name="PyDict_Size",
    error_kind=ERR_NEVER,
)

# Delete an item from a dict
dict_del_item = custom_op(
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyDict_DelItem",
    error_kind=ERR_NEG_INT,
)

supports_mapping_protocol = custom_op(
    arg_types=[object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyMapping_Check",
    error_kind=ERR_NEVER,
)

mapping_has_key = custom_op(
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyMapping_HasKey",
    error_kind=ERR_NEVER,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1834">"""Exception-related primitive ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_ALWAYS, ERR_FALSE, ERR_NEVER
from mypyc.ir.rtypes import bit_rprimitive, exc_rtuple, object_rprimitive, void_rtype
from mypyc.primitives.registry import custom_op

# If the argument is a class, raise an instance of the class. Otherwise, assume
# that the argument is an exception object, and raise it.
raise_exception_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=void_rtype,
    c_function_name="CPy_Raise",
    error_kind=ERR_ALWAYS,
)

# Raise StopIteration exception with the specified value (which can be NULL).
set_stop_iteration_value = custom_op(
    arg_types=[object_rprimitive],
    return_type=void_rtype,
    c_function_name="CPyGen_SetStopIterationValue",
    error_kind=ERR_ALWAYS,
)

# Raise exception with traceback.
# Arguments are (exception type, exception value, traceback).
raise_exception_with_tb_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=void_rtype,
    c_function_name="CPyErr_SetObjectAndTraceback",
    error_kind=ERR_ALWAYS,
)

# Reraise the currently raised exception.
reraise_exception_op = custom_op(
    arg_types=[], return_type=void_rtype, c_function_name="CPy_Reraise", error_kind=ERR_ALWAYS
)

# Propagate exception if the CPython error indicator is set (an exception was raised).
no_err_occurred_op = custom_op(
    arg_types=[],
    return_type=bit_rprimitive,
    c_function_name="CPy_NoErrOccured",
    error_kind=ERR_FALSE,
)

err_occurred_op = custom_op(
    arg_types=[],
    return_type=object_rprimitive,
    c_function_name="PyErr_Occurred",
    error_kind=ERR_NEVER,
    is_borrowed=True,
)

# Keep propagating a raised exception by unconditionally giving an error value.
# This doesn't actually raise an exception.
keep_propagating_op = custom_op(
    arg_types=[],
    return_type=bit_rprimitive,
    c_function_name="CPy_KeepPropagating",
    error_kind=ERR_FALSE,
)

# Catches a propagating exception and makes it the "currently
# handled exception" (by sticking it into sys.exc_info()). Returns the
# exception that was previously being handled, which must be restored
# later.
error_catch_op = custom_op(
    arg_types=[], return_type=exc_rtuple, c_function_name="CPy_CatchError", error_kind=ERR_NEVER
)

# Restore an old "currently handled exception" returned from.
# error_catch (by sticking it into sys.exc_info())
restore_exc_info_op = custom_op(
    arg_types=[exc_rtuple],
    return_type=void_rtype,
    c_function_name="CPy_RestoreExcInfo",
    error_kind=ERR_NEVER,
)

# Checks whether the exception currently being handled matches a particular type.
exc_matches_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPy_ExceptionMatches",
    error_kind=ERR_NEVER,
)

# Get the value of the exception currently being handled.
get_exc_value_op = custom_op(
    arg_types=[],
    return_type=object_rprimitive,
    c_function_name="CPy_GetExcValue",
    error_kind=ERR_NEVER,
)

# Get exception info (exception type, exception instance, traceback object).
get_exc_info_op = custom_op(
    arg_types=[], return_type=exc_rtuple, c_function_name="CPy_GetExcInfo", error_kind=ERR_NEVER
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1835">"""Primitive float ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_MAGIC, ERR_MAGIC_OVERLAPPING, ERR_NEVER
from mypyc.ir.rtypes import (
    bool_rprimitive,
    float_rprimitive,
    int_rprimitive,
    object_rprimitive,
    str_rprimitive,
)
from mypyc.primitives.registry import binary_op, function_op, load_address_op

# Get the 'builtins.float' type object.
load_address_op(name="builtins.float", type=object_rprimitive, src="PyFloat_Type")

binary_op(
    name="//",
    arg_types=[float_rprimitive, float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_FloorDivide",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# float(int)
int_to_float_op = function_op(
    name="builtins.float",
    arg_types=[int_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_FromTagged",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# float(str)
function_op(
    name="builtins.float",
    arg_types=[str_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyFloat_FromString",
    error_kind=ERR_MAGIC,
)

# abs(float)
function_op(
    name="builtins.abs",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="fabs",
    error_kind=ERR_NEVER,
)

# math.sin(float)
function_op(
    name="math.sin",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Sin",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.cos(float)
function_op(
    name="math.cos",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Cos",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.tan(float)
function_op(
    name="math.tan",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Tan",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.sqrt(float)
function_op(
    name="math.sqrt",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Sqrt",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.exp(float)
function_op(
    name="math.exp",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Exp",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.log(float)
function_op(
    name="math.log",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Log",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.floor(float)
function_op(
    name="math.floor",
    arg_types=[float_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyFloat_Floor",
    error_kind=ERR_MAGIC,
)

# math.ceil(float)
function_op(
    name="math.ceil",
    arg_types=[float_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyFloat_Ceil",
    error_kind=ERR_MAGIC,
)

# math.fabs(float)
function_op(
    name="math.fabs",
    arg_types=[float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="fabs",
    error_kind=ERR_NEVER,
)

# math.pow(float, float)
pow_op = function_op(
    name="math.pow",
    arg_types=[float_rprimitive, float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="CPyFloat_Pow",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# math.copysign(float, float)
copysign_op = function_op(
    name="math.copysign",
    arg_types=[float_rprimitive, float_rprimitive],
    return_type=float_rprimitive,
    c_function_name="copysign",
    error_kind=ERR_NEVER,
)

# math.isinf(float)
function_op(
    name="math.isinf",
    arg_types=[float_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPyFloat_IsInf",
    error_kind=ERR_NEVER,
)

# math.isnan(float)
function_op(
    name="math.isnan",
    arg_types=[float_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPyFloat_IsNaN",
    error_kind=ERR_NEVER,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1836">"""Fallback primitive operations that operate on 'object' operands.

These just call the relevant Python C API function or a thin wrapper
around an API function. Most of these also have faster, specialized
ops that operate on some more specific types.

Many of these ops are given a low priority (0) so that specialized ops
will take precedence. If your specialized op doesn't seem to be used,
check that the priorities are configured properly.
"""

from __future__ import annotations

from mypyc.ir.ops import ERR_MAGIC, ERR_NEVER
from mypyc.ir.rtypes import (
    bool_rprimitive,
    c_int_rprimitive,
    c_pyssize_t_rprimitive,
    c_size_t_rprimitive,
    int_rprimitive,
    object_pointer_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    custom_op,
    function_op,
    method_op,
    unary_op,
)

# Binary operations

for op, opid in [
    ("==", 2),  # PY_EQ
    ("!=", 3),  # PY_NE
    ("&lt;", 0),  # PY_LT
    ("&lt;=", 1),  # PY_LE
    ("&gt;", 4),  # PY_GT
    ("&gt;=", 5),
]:  # PY_GE
    # The result type is 'object' since that's what PyObject_RichCompare returns.
    binary_op(
        name=op,
        arg_types=[object_rprimitive, object_rprimitive],
        return_type=object_rprimitive,
        c_function_name="PyObject_RichCompare",
        error_kind=ERR_MAGIC,
        extra_int_constants=[(opid, c_int_rprimitive)],
        priority=0,
    )

for op, funcname in [
    ("+", "PyNumber_Add"),
    ("-", "PyNumber_Subtract"),
    ("*", "PyNumber_Multiply"),
    ("//", "PyNumber_FloorDivide"),
    ("/", "PyNumber_TrueDivide"),
    ("%", "PyNumber_Remainder"),
    ("&lt;&lt;", "PyNumber_Lshift"),
    ("&gt;&gt;", "PyNumber_Rshift"),
    ("&amp;", "PyNumber_And"),
    ("^", "PyNumber_Xor"),
    ("|", "PyNumber_Or"),
    ("@", "PyNumber_MatrixMultiply"),
]:
    binary_op(
        name=op,
        arg_types=[object_rprimitive, object_rprimitive],
        return_type=object_rprimitive,
        c_function_name=funcname,
        error_kind=ERR_MAGIC,
        priority=0,
    )


function_op(
    name="builtins.divmod",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyNumber_Divmod",
    error_kind=ERR_MAGIC,
    priority=0,
)


for op, funcname in [
    ("+=", "PyNumber_InPlaceAdd"),
    ("-=", "PyNumber_InPlaceSubtract"),
    ("*=", "PyNumber_InPlaceMultiply"),
    ("@=", "PyNumber_InPlaceMatrixMultiply"),
    ("//=", "PyNumber_InPlaceFloorDivide"),
    ("/=", "PyNumber_InPlaceTrueDivide"),
    ("%=", "PyNumber_InPlaceRemainder"),
    ("&lt;&lt;=", "PyNumber_InPlaceLshift"),
    ("&gt;&gt;=", "PyNumber_InPlaceRshift"),
    ("&amp;=", "PyNumber_InPlaceAnd"),
    ("^=", "PyNumber_InPlaceXor"),
    ("|=", "PyNumber_InPlaceOr"),
]:
    binary_op(
        name=op,
        arg_types=[object_rprimitive, object_rprimitive],
        return_type=object_rprimitive,
        c_function_name=funcname,
        error_kind=ERR_MAGIC,
        priority=0,
    )

for op, c_function in (("**", "CPyNumber_Power"), ("**=", "CPyNumber_InPlacePower")):
    binary_op(
        name=op,
        arg_types=[object_rprimitive, object_rprimitive],
        return_type=object_rprimitive,
        error_kind=ERR_MAGIC,
        c_function_name=c_function,
        priority=0,
    )

for arg_count, c_function in ((2, "CPyNumber_Power"), (3, "PyNumber_Power")):
    function_op(
        name="builtins.pow",
        arg_types=[object_rprimitive] * arg_count,
        return_type=object_rprimitive,
        error_kind=ERR_MAGIC,
        c_function_name=c_function,
        priority=0,
    )

binary_op(
    name="in",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PySequence_Contains",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
    ordering=[1, 0],
    priority=0,
)


# Unary operations

for op, funcname in [
    ("-", "PyNumber_Negative"),
    ("+", "PyNumber_Positive"),
    ("~", "PyNumber_Invert"),
]:
    unary_op(
        name=op,
        arg_type=object_rprimitive,
        return_type=object_rprimitive,
        c_function_name=funcname,
        error_kind=ERR_MAGIC,
        priority=0,
    )

unary_op(
    name="not",
    arg_type=object_rprimitive,
    return_type=c_int_rprimitive,
    c_function_name="PyObject_Not",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
    priority=0,
)

# abs(obj)
function_op(
    name="builtins.abs",
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyNumber_Absolute",
    error_kind=ERR_MAGIC,
    priority=0,
)

# obj1[obj2]
method_op(
    name="__getitem__",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyObject_GetItem",
    error_kind=ERR_MAGIC,
    priority=0,
)

# obj1[obj2] = obj3
method_op(
    name="__setitem__",
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_SetItem",
    error_kind=ERR_NEG_INT,
    priority=0,
)

# del obj1[obj2]
method_op(
    name="__delitem__",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_DelItem",
    error_kind=ERR_NEG_INT,
    priority=0,
)

# hash(obj)
function_op(
    name="builtins.hash",
    arg_types=[object_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyObject_Hash",
    error_kind=ERR_MAGIC,
)

# getattr(obj, attr)
py_getattr_op = function_op(
    name="builtins.getattr",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyObject_GetAttr",
    error_kind=ERR_MAGIC,
)

# getattr(obj, attr, default)
function_op(
    name="builtins.getattr",
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyObject_GetAttr3",
    error_kind=ERR_MAGIC,
)

# setattr(obj, attr, value)
py_setattr_op = function_op(
    name="builtins.setattr",
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_SetAttr",
    error_kind=ERR_NEG_INT,
)

# hasattr(obj, attr)
py_hasattr_op = function_op(
    name="builtins.hasattr",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="PyObject_HasAttr",
    error_kind=ERR_NEVER,
)

# del obj.attr
py_delattr_op = function_op(
    name="builtins.delattr",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_DelAttr",
    error_kind=ERR_NEG_INT,
)

# Call callable object with N positional arguments: func(arg1, ..., argN)
# Arguments are (func, arg1, ..., argN).
py_call_op = custom_op(
    arg_types=[],
    return_type=object_rprimitive,
    c_function_name="PyObject_CallFunctionObjArgs",
    error_kind=ERR_MAGIC,
    var_arg_type=object_rprimitive,
    extra_int_constants=[(0, pointer_rprimitive)],
)

# Call callable object using positional and/or keyword arguments (Python 3.8+)
py_vectorcall_op = custom_op(
    arg_types=[
        object_rprimitive,  # Callable
        object_pointer_rprimitive,  # Args (PyObject **)
        c_size_t_rprimitive,  # Number of positional args
        object_rprimitive,
    ],  # Keyword arg names tuple (or NULL)
    return_type=object_rprimitive,
    c_function_name="_PyObject_Vectorcall",
    error_kind=ERR_MAGIC,
)

# Call method using positional and/or keyword arguments (Python 3.9+)
py_vectorcall_method_op = custom_op(
    arg_types=[
        object_rprimitive,  # Method name
        object_pointer_rprimitive,  # Args, including self (PyObject **)
        c_size_t_rprimitive,  # Number of positional args, including self
        object_rprimitive,
    ],  # Keyword arg names tuple (or NULL)
    return_type=object_rprimitive,
    c_function_name="PyObject_VectorcallMethod",
    error_kind=ERR_MAGIC,
)

# Call callable object with positional + keyword args: func(*args, **kwargs)
# Arguments are (func, *args tuple, **kwargs dict).
py_call_with_kwargs_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyObject_Call",
    error_kind=ERR_MAGIC,
)

# Call method with positional arguments: obj.method(arg1, ...)
# Arguments are (object, attribute name, arg1, ...).
py_method_call_op = custom_op(
    arg_types=[],
    return_type=object_rprimitive,
    c_function_name="CPyObject_CallMethodObjArgs",
    error_kind=ERR_MAGIC,
    var_arg_type=object_rprimitive,
    extra_int_constants=[(0, pointer_rprimitive)],
)

# len(obj)
generic_len_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyObject_Size",
    error_kind=ERR_MAGIC,
)

# len(obj)
# same as generic_len_op, however return py_ssize_t
generic_ssize_t_len_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=c_pyssize_t_rprimitive,
    c_function_name="PyObject_Size",
    error_kind=ERR_NEG_INT,
)

# iter(obj)
iter_op = function_op(
    name="builtins.iter",
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyObject_GetIter",
    error_kind=ERR_MAGIC,
)
# next(iterator)
#
# Although the error_kind is set to be ERR_NEVER, this can actually
# return NULL, and thus it must be checked using Branch.IS_ERROR.
next_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyIter_Next",
    error_kind=ERR_NEVER,
)
# next(iterator)
#
# Do a next, don't swallow StopIteration, but also don't propagate an
# error. (N.B: This can still return NULL without an error to
# represent an implicit StopIteration, but if StopIteration is
# *explicitly* raised this will not swallow it.)
# Can return NULL: see next_op.
next_raw_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyIter_Next",
    error_kind=ERR_NEVER,
)

# this would be aiter(obj) if it existed
aiter_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPy_GetAIter",
    error_kind=ERR_MAGIC,
)

# this would be anext(obj) if it existed
anext_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPy_GetANext",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1837">"""Arbitrary-precision integer primitive ops.

These mostly operate on (usually) unboxed integers that use a tagged pointer
representation (CPyTagged) and correspond to the Python 'int' type.

See also the documentation for mypyc.rtypes.int_rprimitive.

Use mypyc.ir.ops.IntOp for operations on fixed-width/C integers.
"""

from __future__ import annotations

from typing import NamedTuple

from mypyc.ir.ops import ERR_ALWAYS, ERR_MAGIC, ERR_MAGIC_OVERLAPPING, ERR_NEVER, ComparisonOp
from mypyc.ir.rtypes import (
    RType,
    bit_rprimitive,
    bool_rprimitive,
    c_pyssize_t_rprimitive,
    float_rprimitive,
    int16_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    object_rprimitive,
    str_rprimitive,
    void_rtype,
)
from mypyc.primitives.registry import (
    CFunctionDescription,
    binary_op,
    custom_op,
    function_op,
    load_address_op,
    unary_op,
)

# Constructors for builtins.int and native int types have the same behavior. In
# interpreted mode, native int types are just aliases to 'int'.
for int_name in (
    "builtins.int",
    "mypy_extensions.i64",
    "mypy_extensions.i32",
    "mypy_extensions.i16",
    "mypy_extensions.u8",
):
    # These int constructors produce object_rprimitives that then need to be unboxed
    # I guess unboxing ourselves would save a check and branch though?

    # Get the type object for 'builtins.int' or a native int type.
    # For ordinary calls to int() we use a load_address to the type.
    # Native ints don't have a separate type object -- we just use 'builtins.int'.
    load_address_op(name=int_name, type=object_rprimitive, src="PyLong_Type")

    # int(float). We could do a bit better directly.
    function_op(
        name=int_name,
        arg_types=[float_rprimitive],
        return_type=int_rprimitive,
        c_function_name="CPyTagged_FromFloat",
        error_kind=ERR_MAGIC,
    )

    # int(string)
    function_op(
        name=int_name,
        arg_types=[str_rprimitive],
        return_type=object_rprimitive,
        c_function_name="CPyLong_FromStr",
        error_kind=ERR_MAGIC,
    )

    # int(string, base)
    function_op(
        name=int_name,
        arg_types=[str_rprimitive, int_rprimitive],
        return_type=object_rprimitive,
        c_function_name="CPyLong_FromStrWithBase",
        error_kind=ERR_MAGIC,
    )

# str(int)
int_to_str_op = function_op(
    name="builtins.str",
    arg_types=[int_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyTagged_Str",
    error_kind=ERR_MAGIC,
    priority=2,
)

# We need a specialization for str on bools also since the int one is wrong...
function_op(
    name="builtins.str",
    arg_types=[bool_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyBool_Str",
    error_kind=ERR_MAGIC,
    priority=3,
)


@others
# Equals operation on two boxed tagged integers
int_equal_ = custom_op(
    arg_types=[int_rprimitive, int_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyTagged_IsEq_",
    error_kind=ERR_NEVER,
)

# Less than operation on two boxed tagged integers
int_less_than_ = custom_op(
    arg_types=[int_rprimitive, int_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyTagged_IsLt_",
    error_kind=ERR_NEVER,
)

# Provide mapping from textual op to short int's op variant and boxed int's description.
# Note that these are not complete implementations and require extra IR.
int_comparison_op_mapping: dict[str, IntComparisonOpDescription] = {
    "==": IntComparisonOpDescription(ComparisonOp.EQ, int_equal_, False, False),
    "!=": IntComparisonOpDescription(ComparisonOp.NEQ, int_equal_, True, False),
    "&lt;": IntComparisonOpDescription(ComparisonOp.SLT, int_less_than_, False, False),
    "&lt;=": IntComparisonOpDescription(ComparisonOp.SLE, int_less_than_, True, True),
    "&gt;": IntComparisonOpDescription(ComparisonOp.SGT, int_less_than_, False, True),
    "&gt;=": IntComparisonOpDescription(ComparisonOp.SGE, int_less_than_, True, False),
}

int64_divide_op = custom_op(
    arg_types=[int64_rprimitive, int64_rprimitive],
    return_type=int64_rprimitive,
    c_function_name="CPyInt64_Divide",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int64_mod_op = custom_op(
    arg_types=[int64_rprimitive, int64_rprimitive],
    return_type=int64_rprimitive,
    c_function_name="CPyInt64_Remainder",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int32_divide_op = custom_op(
    arg_types=[int32_rprimitive, int32_rprimitive],
    return_type=int32_rprimitive,
    c_function_name="CPyInt32_Divide",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int32_mod_op = custom_op(
    arg_types=[int32_rprimitive, int32_rprimitive],
    return_type=int32_rprimitive,
    c_function_name="CPyInt32_Remainder",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int16_divide_op = custom_op(
    arg_types=[int16_rprimitive, int16_rprimitive],
    return_type=int16_rprimitive,
    c_function_name="CPyInt16_Divide",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int16_mod_op = custom_op(
    arg_types=[int16_rprimitive, int16_rprimitive],
    return_type=int16_rprimitive,
    c_function_name="CPyInt16_Remainder",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

# Convert tagged int (as PyObject *) to i64
int_to_int64_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=int64_rprimitive,
    c_function_name="CPyLong_AsInt64",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

ssize_t_to_int_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyTagged_FromSsize_t",
    error_kind=ERR_MAGIC,
)

int64_to_int_op = custom_op(
    arg_types=[int64_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyTagged_FromInt64",
    error_kind=ERR_MAGIC,
)

# Convert tagged int (as PyObject *) to i32
int_to_int32_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=int32_rprimitive,
    c_function_name="CPyLong_AsInt32",
    error_kind=ERR_MAGIC_OVERLAPPING,
)

int32_overflow = custom_op(
    arg_types=[],
    return_type=void_rtype,
    c_function_name="CPyInt32_Overflow",
    error_kind=ERR_ALWAYS,
)

int16_overflow = custom_op(
    arg_types=[],
    return_type=void_rtype,
    c_function_name="CPyInt16_Overflow",
    error_kind=ERR_ALWAYS,
)

uint8_overflow = custom_op(
    arg_types=[],
    return_type=void_rtype,
    c_function_name="CPyUInt8_Overflow",
    error_kind=ERR_ALWAYS,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1838">def int_binary_op(
    name: str,
    c_function_name: str,
    return_type: RType = int_rprimitive,
    error_kind: int = ERR_NEVER,
) -&gt; None:
    binary_op(
        name=name,
        arg_types=[int_rprimitive, int_rprimitive],
        return_type=return_type,
        c_function_name=c_function_name,
        error_kind=error_kind,
    )
</t>
<t tx="ekr.20240308084832.1839"># Binary, unary and augmented assignment operations that operate on CPyTagged ints
# are implemented as C functions.

int_binary_op("+", "CPyTagged_Add")
int_binary_op("-", "CPyTagged_Subtract")
int_binary_op("*", "CPyTagged_Multiply")
int_binary_op("&amp;", "CPyTagged_And")
int_binary_op("|", "CPyTagged_Or")
int_binary_op("^", "CPyTagged_Xor")
# Divide and remainder we honestly propagate errors from because they
# can raise ZeroDivisionError
int_binary_op("//", "CPyTagged_FloorDivide", error_kind=ERR_MAGIC)
int_binary_op("%", "CPyTagged_Remainder", error_kind=ERR_MAGIC)
# Negative shift counts raise an exception
int_binary_op("&gt;&gt;", "CPyTagged_Rshift", error_kind=ERR_MAGIC)
int_binary_op("&lt;&lt;", "CPyTagged_Lshift", error_kind=ERR_MAGIC)

int_binary_op(
    "/", "CPyTagged_TrueDivide", return_type=float_rprimitive, error_kind=ERR_MAGIC_OVERLAPPING
)

# This should work because assignment operators are parsed differently
# and the code in irbuild that handles it does the assignment
# regardless of whether or not the operator works in place anyway.
int_binary_op("+=", "CPyTagged_Add")
int_binary_op("-=", "CPyTagged_Subtract")
int_binary_op("*=", "CPyTagged_Multiply")
int_binary_op("&amp;=", "CPyTagged_And")
int_binary_op("|=", "CPyTagged_Or")
int_binary_op("^=", "CPyTagged_Xor")
int_binary_op("//=", "CPyTagged_FloorDivide", error_kind=ERR_MAGIC)
int_binary_op("%=", "CPyTagged_Remainder", error_kind=ERR_MAGIC)
int_binary_op("&gt;&gt;=", "CPyTagged_Rshift", error_kind=ERR_MAGIC)
int_binary_op("&lt;&lt;=", "CPyTagged_Lshift", error_kind=ERR_MAGIC)


def int_unary_op(name: str, c_function_name: str) -&gt; CFunctionDescription:
    return unary_op(
        name=name,
        arg_type=int_rprimitive,
        return_type=int_rprimitive,
        c_function_name=c_function_name,
        error_kind=ERR_NEVER,
    )
</t>
<t tx="ekr.20240308084832.184">def visit_set_mem(self, op: SetMem) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1840">int_neg_op = int_unary_op("-", "CPyTagged_Negate")
int_invert_op = int_unary_op("~", "CPyTagged_Invert")


# Primitives related to integer comparison operations:


# Description for building int comparison ops
#
# Fields:
#   binary_op_variant: identify which IntOp to use when operands are short integers
#   c_func_description: the C function to call when operands are tagged integers
#   c_func_negated: whether to negate the C function call's result
#   c_func_swap_operands: whether to swap lhs and rhs when call the function
class IntComparisonOpDescription(NamedTuple):
    binary_op_variant: int
    c_func_description: CFunctionDescription
    c_func_negated: bool
    c_func_swap_operands: bool
</t>
<t tx="ekr.20240308084832.1841">"""List primitive ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_FALSE, ERR_MAGIC, ERR_NEVER
from mypyc.ir.rtypes import (
    bit_rprimitive,
    c_int_rprimitive,
    c_pyssize_t_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
    short_int_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    custom_op,
    function_op,
    load_address_op,
    method_op,
)

# Get the 'builtins.list' type object.
load_address_op(name="builtins.list", type=object_rprimitive, src="PyList_Type")

# list(obj)
to_list = function_op(
    name="builtins.list",
    arg_types=[object_rprimitive],
    return_type=list_rprimitive,
    c_function_name="PySequence_List",
    error_kind=ERR_MAGIC,
)

# Construct an empty list via list().
function_op(
    name="builtins.list",
    arg_types=[],
    return_type=list_rprimitive,
    c_function_name="PyList_New",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, int_rprimitive)],
)

new_list_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=list_rprimitive,
    c_function_name="PyList_New",
    error_kind=ERR_MAGIC,
)

list_build_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPyList_Build",
    error_kind=ERR_MAGIC,
    var_arg_type=object_rprimitive,
    steals=True,
)

# list[index] (for an integer index)
list_get_item_op = method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItem",
    error_kind=ERR_MAGIC,
)

# list[index] version with no int tag check for when it is known to be short
method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, short_int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemShort",
    error_kind=ERR_MAGIC,
    priority=2,
)

# list[index] that produces a borrowed result
method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemBorrow",
    error_kind=ERR_MAGIC,
    is_borrowed=True,
    priority=3,
)

# list[index] that produces a borrowed result and index is known to be short
method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, short_int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemShortBorrow",
    error_kind=ERR_MAGIC,
    is_borrowed=True,
    priority=4,
)

# Version with native int index
method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, int64_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemInt64",
    error_kind=ERR_MAGIC,
    priority=5,
)

# Version with native int index
method_op(
    name="__getitem__",
    arg_types=[list_rprimitive, int64_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemInt64Borrow",
    is_borrowed=True,
    error_kind=ERR_MAGIC,
    priority=6,
)

# This is unsafe because it assumes that the index is a non-negative short integer
# that is in-bounds for the list.
list_get_item_unsafe_op = custom_op(
    arg_types=[list_rprimitive, short_int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetItemUnsafe",
    error_kind=ERR_NEVER,
)

# list[index] = obj
list_set_item_op = method_op(
    name="__setitem__",
    arg_types=[list_rprimitive, int_rprimitive, object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyList_SetItem",
    error_kind=ERR_FALSE,
    steals=[False, False, True],
)

# list[index_i64] = obj
method_op(
    name="__setitem__",
    arg_types=[list_rprimitive, int64_rprimitive, object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyList_SetItemInt64",
    error_kind=ERR_FALSE,
    steals=[False, False, True],
    priority=2,
)

# PyList_SET_ITEM does no error checking,
# and should only be used to fill in brand new lists.
new_list_set_item_op = custom_op(
    arg_types=[list_rprimitive, int_rprimitive, object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyList_SetItemUnsafe",
    error_kind=ERR_FALSE,
    steals=[False, False, True],
)

# list.append(obj)
list_append_op = method_op(
    name="append",
    arg_types=[list_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyList_Append",
    error_kind=ERR_NEG_INT,
)

# list.extend(obj)
list_extend_op = method_op(
    name="extend",
    arg_types=[list_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_Extend",
    error_kind=ERR_MAGIC,
)

# list.pop()
list_pop_last = method_op(
    name="pop",
    arg_types=[list_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_PopLast",
    error_kind=ERR_MAGIC,
)

# list.pop(index)
list_pop = method_op(
    name="pop",
    arg_types=[list_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_Pop",
    error_kind=ERR_MAGIC,
)

# list.count(obj)
method_op(
    name="count",
    arg_types=[list_rprimitive, object_rprimitive],
    return_type=short_int_rprimitive,
    c_function_name="CPyList_Count",
    error_kind=ERR_MAGIC,
)

# list.insert(index, obj)
method_op(
    name="insert",
    arg_types=[list_rprimitive, int_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyList_Insert",
    error_kind=ERR_NEG_INT,
)

# list.sort()
method_op(
    name="sort",
    arg_types=[list_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyList_Sort",
    error_kind=ERR_NEG_INT,
)

# list.reverse()
method_op(
    name="reverse",
    arg_types=[list_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyList_Reverse",
    error_kind=ERR_NEG_INT,
)

# list.remove(obj)
method_op(
    name="remove",
    arg_types=[list_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPyList_Remove",
    error_kind=ERR_NEG_INT,
)

# list.index(obj)
method_op(
    name="index",
    arg_types=[list_rprimitive, object_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyList_Index",
    error_kind=ERR_MAGIC,
)

# list * int
binary_op(
    name="*",
    arg_types=[list_rprimitive, int_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPySequence_Multiply",
    error_kind=ERR_MAGIC,
)

# int * list
binary_op(
    name="*",
    arg_types=[int_rprimitive, list_rprimitive],
    return_type=list_rprimitive,
    c_function_name="CPySequence_RMultiply",
    error_kind=ERR_MAGIC,
)

# list[begin:end]
list_slice_op = custom_op(
    arg_types=[list_rprimitive, int_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyList_GetSlice",
    error_kind=ERR_MAGIC,
)

supports_sequence_protocol = custom_op(
    arg_types=[object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPySequence_Check",
    error_kind=ERR_NEVER,
)

sequence_get_item = custom_op(
    arg_types=[object_rprimitive, c_pyssize_t_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PySequence_GetItem",
    error_kind=ERR_NEVER,
)

sequence_get_slice = custom_op(
    arg_types=[object_rprimitive, c_pyssize_t_rprimitive, c_pyssize_t_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PySequence_GetSlice",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1842">"""Miscellaneous primitive ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_FALSE, ERR_MAGIC, ERR_NEVER
from mypyc.ir.rtypes import (
    bit_rprimitive,
    bool_rprimitive,
    c_int_rprimitive,
    c_pointer_rprimitive,
    c_pyssize_t_rprimitive,
    dict_rprimitive,
    int_rprimitive,
    object_pointer_rprimitive,
    object_rprimitive,
    str_rprimitive,
)
from mypyc.primitives.registry import ERR_NEG_INT, custom_op, function_op, load_address_op

# Get the 'bool' type object.
load_address_op(name="builtins.bool", type=object_rprimitive, src="PyBool_Type")

# Get the 'range' type object.
load_address_op(name="builtins.range", type=object_rprimitive, src="PyRange_Type")

# Get the boxed Python 'None' object
none_object_op = load_address_op(name="Py_None", type=object_rprimitive, src="_Py_NoneStruct")

# Get the boxed object '...'
ellipsis_op = load_address_op(name="...", type=object_rprimitive, src="_Py_EllipsisObject")

# Get the boxed NotImplemented object
not_implemented_op = load_address_op(
    name="builtins.NotImplemented", type=object_rprimitive, src="_Py_NotImplementedStruct"
)

# Get the boxed StopAsyncIteration object
stop_async_iteration_op = load_address_op(
    name="builtins.StopAsyncIteration", type=object_rprimitive, src="PyExc_StopAsyncIteration"
)

# id(obj)
function_op(
    name="builtins.id",
    arg_types=[object_rprimitive],
    return_type=int_rprimitive,
    c_function_name="CPyTagged_Id",
    error_kind=ERR_NEVER,
)

# Return the result of obj.__await()__ or obj.__iter__() (if no __await__ exists)
coro_op = custom_op(
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPy_GetCoro",
    error_kind=ERR_MAGIC,
)

# Do obj.send(value), or a next(obj) if second arg is None.
# (This behavior is to match the PEP 380 spec for yield from.)
# Like next_raw_op, don't swallow StopIteration,
# but also don't propagate an error.
# Can return NULL: see next_op.
send_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyIter_Send",
    error_kind=ERR_NEVER,
)

# This is sort of unfortunate but oh well: yield_from_except performs most of the
# error handling logic in `yield from` operations. It returns a bool and passes
# a value by address.
# If the bool is true, then a StopIteration was received and we should return.
# If the bool is false, then the value should be yielded.
# The normal case is probably that it signals an exception, which gets
# propagated.
# Op used for "yield from" error handling.
# See comment in CPy_YieldFromErrorHandle for more information.
yield_from_except_op = custom_op(
    arg_types=[object_rprimitive, object_pointer_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPy_YieldFromErrorHandle",
    error_kind=ERR_MAGIC,
)

# Create method object from a callable object and self.
method_new_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyMethod_New",
    error_kind=ERR_MAGIC,
)

# Check if the current exception is a StopIteration and return its value if so.
# Treats "no exception" as StopIteration with a None value.
# If it is a different exception, re-reraise it.
check_stop_op = custom_op(
    arg_types=[],
    return_type=object_rprimitive,
    c_function_name="CPy_FetchStopIterationValue",
    error_kind=ERR_MAGIC,
)

# Determine the most derived metaclass and check for metaclass conflicts.
# Arguments are (metaclass, bases).
py_calc_meta_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPy_CalculateMetaclass",
    error_kind=ERR_MAGIC,
    is_borrowed=True,
)

# Import a module (plain)
import_op = custom_op(
    arg_types=[str_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyImport_Import",
    error_kind=ERR_MAGIC,
)

# Table-driven import op.
import_many_op = custom_op(
    arg_types=[
        object_rprimitive,
        c_pointer_rprimitive,
        object_rprimitive,
        object_rprimitive,
        object_rprimitive,
        c_pointer_rprimitive,
    ],
    return_type=bit_rprimitive,
    c_function_name="CPyImport_ImportMany",
    error_kind=ERR_FALSE,
)

# From import helper op
import_from_many_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyImport_ImportFromMany",
    error_kind=ERR_MAGIC,
)

# Get the sys.modules dictionary
get_module_dict_op = custom_op(
    arg_types=[],
    return_type=dict_rprimitive,
    c_function_name="PyImport_GetModuleDict",
    error_kind=ERR_NEVER,
    is_borrowed=True,
)

# isinstance(obj, cls)
slow_isinstance_op = function_op(
    name="builtins.isinstance",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_IsInstance",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
)

# Faster isinstance(obj, cls) that only works with native classes and doesn't perform
# type checking of the type argument.
fast_isinstance_op = function_op(
    "builtins.isinstance",
    arg_types=[object_rprimitive, object_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPy_TypeCheck",
    error_kind=ERR_NEVER,
    priority=0,
)

# bool(obj) with unboxed result
bool_op = function_op(
    name="builtins.bool",
    arg_types=[object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyObject_IsTrue",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
)

# slice(start, stop, step)
new_slice_op = function_op(
    name="builtins.slice",
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    c_function_name="PySlice_New",
    return_type=object_rprimitive,
    error_kind=ERR_MAGIC,
)

# type(obj)
type_op = function_op(
    name="builtins.type",
    arg_types=[object_rprimitive],
    c_function_name="PyObject_Type",
    return_type=object_rprimitive,
    error_kind=ERR_NEVER,
)

# Get 'builtins.type' (base class of all classes)
type_object_op = load_address_op(name="builtins.type", type=object_rprimitive, src="PyType_Type")

# Create a heap type based on a template non-heap type.
# See CPyType_FromTemplate for more docs.
pytype_from_template_op = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, str_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyType_FromTemplate",
    error_kind=ERR_MAGIC,
)

# Create a dataclass from an extension class. See
# CPyDataclass_SleightOfHand for more docs.
dataclass_sleight_of_hand = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, dict_rprimitive, dict_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyDataclass_SleightOfHand",
    error_kind=ERR_FALSE,
)

# Raise ValueError if length of first argument is not equal to the second argument.
# The first argument must be a list or a variable-length tuple.
check_unpack_count_op = custom_op(
    arg_types=[object_rprimitive, c_pyssize_t_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="CPySequence_CheckUnpackCount",
    error_kind=ERR_NEG_INT,
)


# register an implementation for a singledispatch function
register_function = custom_op(
    arg_types=[object_rprimitive, object_rprimitive, object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPySingledispatch_RegisterFunction",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1843">"""Utilities for defining primitive ops.

Most of the ops can be automatically generated by matching against AST
nodes and types. For example, a func_op is automatically generated when
a specific function is called with the specific positional argument
count and argument types.

Example op definition:

list_len_op = func_op(name='builtins.len',
                      arg_types=[list_rprimitive],
                      result_type=short_int_rprimitive,
                      error_kind=ERR_NEVER,
                      emit=emit_len)

This op is automatically generated for calls to len() with a single
list argument. The result type is short_int_rprimitive, and this
never raises an exception (ERR_NEVER). The function emit_len is used
to generate C for this op.  The op can also be manually generated using
"list_len_op". Ops that are only generated automatically don't need to
be assigned to a module attribute.

Ops defined with custom_op are only explicitly generated in
mypyc.irbuild and won't be generated automatically. They are always
assigned to a module attribute, as otherwise they won't be accessible.

The actual ops are defined in other submodules of this package, grouped
by category.

Most operations have fallback implementations that apply to all possible
arguments and types. For example, there are generic implementations of
arbitrary function and method calls, and binary operators. These generic
implementations are typically slower than specialized ones, but we tend
to rely on them for infrequently used ops. It's impractical to have
optimized implementations of all ops.
"""

from __future__ import annotations

from typing import Final, NamedTuple

from mypyc.ir.ops import StealsDescription
from mypyc.ir.rtypes import RType

# Error kind for functions that return negative integer on exception. This
# is only used for primitives. We translate it away during IR building.
ERR_NEG_INT: Final = 10


@others
import mypyc.primitives.bytes_ops
import mypyc.primitives.dict_ops
import mypyc.primitives.float_ops

# Import various modules that set up global state.
import mypyc.primitives.int_ops
import mypyc.primitives.list_ops
import mypyc.primitives.misc_ops
import mypyc.primitives.str_ops
import mypyc.primitives.tuple_ops  # noqa: F401
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1844">class CFunctionDescription(NamedTuple):
    name: str
    arg_types: list[RType]
    return_type: RType
    var_arg_type: RType | None
    truncated_type: RType | None
    c_function_name: str
    error_kind: int
    steals: StealsDescription
    is_borrowed: bool
    ordering: list[int] | None
    extra_int_constants: list[tuple[int, RType]]
    priority: int
</t>
<t tx="ekr.20240308084832.1845"># A description for C load operations including LoadGlobal and LoadAddress
class LoadAddressDescription(NamedTuple):
    name: str
    type: RType
    src: str  # name of the target to load
</t>
<t tx="ekr.20240308084832.1846"># CallC op for method call(such as 'str.join')
method_call_ops: dict[str, list[CFunctionDescription]] = {}

# CallC op for top level function call(such as 'builtins.list')
function_ops: dict[str, list[CFunctionDescription]] = {}

# CallC op for binary ops
binary_ops: dict[str, list[CFunctionDescription]] = {}

# CallC op for unary ops
unary_ops: dict[str, list[CFunctionDescription]] = {}

builtin_names: dict[str, tuple[RType, str]] = {}


def method_op(
    name: str,
    arg_types: list[RType],
    return_type: RType,
    c_function_name: str,
    error_kind: int,
    var_arg_type: RType | None = None,
    truncated_type: RType | None = None,
    ordering: list[int] | None = None,
    extra_int_constants: list[tuple[int, RType]] = [],
    steals: StealsDescription = False,
    is_borrowed: bool = False,
    priority: int = 1,
) -&gt; CFunctionDescription:
    """Define a c function call op that replaces a method call.

    This will be automatically generated by matching against the AST.

    Args:
        name: short name of the method (for example, 'append')
        arg_types: argument types; the receiver is always the first argument
        return_type: type of the return value. Use void_rtype to represent void.
        c_function_name: name of the C function to call
        error_kind: how errors are represented in the result (one of ERR_*)
        var_arg_type: type of all variable arguments
        truncated_type: type to truncated to(See Truncate for info)
                        if it's defined both return_type and it should be non-referenced
                        integer types or bool type
        ordering: optional ordering of the arguments, if defined,
                  reorders the arguments accordingly.
                  should never be used together with var_arg_type.
                  all the other arguments(such as arg_types) are in the order
                  accepted by the python syntax(before reordering)
        extra_int_constants: optional extra integer constants as the last arguments to a C call
        steals: description of arguments that this steals (ref count wise)
        is_borrowed: if True, returned value is borrowed (no need to decrease refcount)
        priority: if multiple ops match, the one with the highest priority is picked
    """
    ops = method_call_ops.setdefault(name, [])
    desc = CFunctionDescription(
        name,
        arg_types,
        return_type,
        var_arg_type,
        truncated_type,
        c_function_name,
        error_kind,
        steals,
        is_borrowed,
        ordering,
        extra_int_constants,
        priority,
    )
    ops.append(desc)
    return desc
</t>
<t tx="ekr.20240308084832.1847">def function_op(
    name: str,
    arg_types: list[RType],
    return_type: RType,
    c_function_name: str,
    error_kind: int,
    var_arg_type: RType | None = None,
    truncated_type: RType | None = None,
    ordering: list[int] | None = None,
    extra_int_constants: list[tuple[int, RType]] = [],
    steals: StealsDescription = False,
    is_borrowed: bool = False,
    priority: int = 1,
) -&gt; CFunctionDescription:
    """Define a c function call op that replaces a function call.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op().

    Args:
        name: full name of the function
        arg_types: positional argument types for which this applies
    """
    ops = function_ops.setdefault(name, [])
    desc = CFunctionDescription(
        name,
        arg_types,
        return_type,
        var_arg_type,
        truncated_type,
        c_function_name,
        error_kind,
        steals,
        is_borrowed,
        ordering,
        extra_int_constants,
        priority,
    )
    ops.append(desc)
    return desc
</t>
<t tx="ekr.20240308084832.1848">def binary_op(
    name: str,
    arg_types: list[RType],
    return_type: RType,
    c_function_name: str,
    error_kind: int,
    var_arg_type: RType | None = None,
    truncated_type: RType | None = None,
    ordering: list[int] | None = None,
    extra_int_constants: list[tuple[int, RType]] = [],
    steals: StealsDescription = False,
    is_borrowed: bool = False,
    priority: int = 1,
) -&gt; CFunctionDescription:
    """Define a c function call op for a binary operation.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op(), but exactly two argument types
    are expected.
    """
    ops = binary_ops.setdefault(name, [])
    desc = CFunctionDescription(
        name,
        arg_types,
        return_type,
        var_arg_type,
        truncated_type,
        c_function_name,
        error_kind,
        steals,
        is_borrowed,
        ordering,
        extra_int_constants,
        priority,
    )
    ops.append(desc)
    return desc
</t>
<t tx="ekr.20240308084832.1849">def custom_op(
    arg_types: list[RType],
    return_type: RType,
    c_function_name: str,
    error_kind: int,
    var_arg_type: RType | None = None,
    truncated_type: RType | None = None,
    ordering: list[int] | None = None,
    extra_int_constants: list[tuple[int, RType]] = [],
    steals: StealsDescription = False,
    is_borrowed: bool = False,
) -&gt; CFunctionDescription:
    """Create a one-off CallC op that can't be automatically generated from the AST.

    Most arguments are similar to method_op().
    """
    return CFunctionDescription(
        "&lt;custom&gt;",
        arg_types,
        return_type,
        var_arg_type,
        truncated_type,
        c_function_name,
        error_kind,
        steals,
        is_borrowed,
        ordering,
        extra_int_constants,
        0,
    )
</t>
<t tx="ekr.20240308084832.185">def analyze_borrowed_arguments(
    blocks: list[BasicBlock], cfg: CFG, borrowed: set[Value]
) -&gt; AnalysisResult[Value]:
    """Calculate arguments that can use references borrowed from the caller.

    When assigning to an argument, it no longer is borrowed.
    """
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=BorrowedArgumentsVisitor(borrowed),
        initial=borrowed,
        backward=False,
        kind=MUST_ANALYSIS,
        universe=borrowed,
    )
</t>
<t tx="ekr.20240308084832.1850">def unary_op(
    name: str,
    arg_type: RType,
    return_type: RType,
    c_function_name: str,
    error_kind: int,
    truncated_type: RType | None = None,
    ordering: list[int] | None = None,
    extra_int_constants: list[tuple[int, RType]] = [],
    steals: StealsDescription = False,
    is_borrowed: bool = False,
    priority: int = 1,
) -&gt; CFunctionDescription:
    """Define a c function call op for an unary operation.

    This will be automatically generated by matching against the AST.

    Most arguments are similar to method_op(), but exactly one argument type
    is expected.
    """
    ops = unary_ops.setdefault(name, [])
    desc = CFunctionDescription(
        name,
        [arg_type],
        return_type,
        None,
        truncated_type,
        c_function_name,
        error_kind,
        steals,
        is_borrowed,
        ordering,
        extra_int_constants,
        priority,
    )
    ops.append(desc)
    return desc
</t>
<t tx="ekr.20240308084832.1851">def load_address_op(name: str, type: RType, src: str) -&gt; LoadAddressDescription:
    assert name not in builtin_names, "already defined: %s" % name
    builtin_names[name] = (type, src)
    return LoadAddressDescription(name, type, src)
</t>
<t tx="ekr.20240308084832.1852">"""Primitive set (and frozenset) ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_FALSE, ERR_MAGIC
from mypyc.ir.rtypes import (
    bit_rprimitive,
    bool_rprimitive,
    c_int_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
    set_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    function_op,
    load_address_op,
    method_op,
)

# Get the 'builtins.set' type object.
load_address_op(name="builtins.set", type=object_rprimitive, src="PySet_Type")

# Get the 'builtins.frozenset' tyoe object.
load_address_op(name="builtins.frozenset", type=object_rprimitive, src="PyFrozenSet_Type")

# Construct an empty set.
new_set_op = function_op(
    name="builtins.set",
    arg_types=[],
    return_type=set_rprimitive,
    c_function_name="PySet_New",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, pointer_rprimitive)],
)

# set(obj)
function_op(
    name="builtins.set",
    arg_types=[object_rprimitive],
    return_type=set_rprimitive,
    c_function_name="PySet_New",
    error_kind=ERR_MAGIC,
)

# frozenset(obj)
function_op(
    name="builtins.frozenset",
    arg_types=[object_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PyFrozenSet_New",
    error_kind=ERR_MAGIC,
)

# item in set
set_in_op = binary_op(
    name="in",
    arg_types=[object_rprimitive, set_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PySet_Contains",
    error_kind=ERR_NEG_INT,
    truncated_type=bool_rprimitive,
    ordering=[1, 0],
)

# set.remove(obj)
method_op(
    name="remove",
    arg_types=[set_rprimitive, object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPySet_Remove",
    error_kind=ERR_FALSE,
)

# set.discard(obj)
method_op(
    name="discard",
    arg_types=[set_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PySet_Discard",
    error_kind=ERR_NEG_INT,
)

# set.add(obj)
set_add_op = method_op(
    name="add",
    arg_types=[set_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PySet_Add",
    error_kind=ERR_NEG_INT,
)

# set.update(obj)
#
# This is not a public API but looks like it should be fine.
set_update_op = method_op(
    name="update",
    arg_types=[set_rprimitive, object_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="_PySet_Update",
    error_kind=ERR_NEG_INT,
)

# set.clear()
method_op(
    name="clear",
    arg_types=[set_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PySet_Clear",
    error_kind=ERR_NEG_INT,
)

# set.pop()
method_op(
    name="pop",
    arg_types=[set_rprimitive],
    return_type=object_rprimitive,
    c_function_name="PySet_Pop",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1853">"""Primitive str ops."""

from __future__ import annotations

from mypyc.ir.ops import ERR_MAGIC, ERR_NEVER
from mypyc.ir.rtypes import (
    RType,
    bit_rprimitive,
    bool_rprimitive,
    bytes_rprimitive,
    c_int_rprimitive,
    c_pyssize_t_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
    str_rprimitive,
)
from mypyc.primitives.registry import (
    ERR_NEG_INT,
    binary_op,
    custom_op,
    function_op,
    load_address_op,
    method_op,
)

# Get the 'str' type object.
load_address_op(name="builtins.str", type=object_rprimitive, src="PyUnicode_Type")

# str(obj)
str_op = function_op(
    name="builtins.str",
    arg_types=[object_rprimitive],
    return_type=str_rprimitive,
    c_function_name="PyObject_Str",
    error_kind=ERR_MAGIC,
)

# str1 + str2
binary_op(
    name="+",
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=str_rprimitive,
    c_function_name="PyUnicode_Concat",
    error_kind=ERR_MAGIC,
)

# str1 += str2
#
# PyUnicode_Append makes an effort to reuse the LHS when the refcount
# is 1. This is super dodgy but oh well, the interpreter does it.
binary_op(
    name="+=",
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyStr_Append",
    error_kind=ERR_MAGIC,
    steals=[True, False],
)

unicode_compare = custom_op(
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=c_int_rprimitive,
    c_function_name="PyUnicode_Compare",
    error_kind=ERR_NEVER,
)

# str[index] (for an int index)
method_op(
    name="__getitem__",
    arg_types=[str_rprimitive, int_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyStr_GetItem",
    error_kind=ERR_MAGIC,
)

# str[begin:end]
str_slice_op = custom_op(
    arg_types=[str_rprimitive, int_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPyStr_GetSlice",
    error_kind=ERR_MAGIC,
)

# str.join(obj)
method_op(
    name="join",
    arg_types=[str_rprimitive, object_rprimitive],
    return_type=str_rprimitive,
    c_function_name="PyUnicode_Join",
    error_kind=ERR_MAGIC,
)

str_build_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyStr_Build",
    error_kind=ERR_MAGIC,
    var_arg_type=str_rprimitive,
)

# str.startswith(str)
method_op(
    name="startswith",
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPyStr_Startswith",
    error_kind=ERR_NEVER,
)

# str.endswith(str)
method_op(
    name="endswith",
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=bool_rprimitive,
    c_function_name="CPyStr_Endswith",
    error_kind=ERR_NEVER,
)

# str.split(...)
str_split_types: list[RType] = [str_rprimitive, str_rprimitive, int_rprimitive]
str_split_functions = ["PyUnicode_Split", "PyUnicode_Split", "CPyStr_Split"]
str_split_constants: list[list[tuple[int, RType]]] = [
    [(0, pointer_rprimitive), (-1, c_int_rprimitive)],
    [(-1, c_int_rprimitive)],
    [],
]
for i in range(len(str_split_types)):
    method_op(
        name="split",
        arg_types=str_split_types[0 : i + 1],
        return_type=list_rprimitive,
        c_function_name=str_split_functions[i],
        extra_int_constants=str_split_constants[i],
        error_kind=ERR_MAGIC,
    )

# str.replace(old, new)
method_op(
    name="replace",
    arg_types=[str_rprimitive, str_rprimitive, str_rprimitive],
    return_type=str_rprimitive,
    c_function_name="PyUnicode_Replace",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(-1, c_int_rprimitive)],
)

# str.replace(old, new, count)
method_op(
    name="replace",
    arg_types=[str_rprimitive, str_rprimitive, str_rprimitive, int_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPyStr_Replace",
    error_kind=ERR_MAGIC,
)

# check if a string is true (isn't an empty string)
str_check_if_true = custom_op(
    arg_types=[str_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPyStr_IsTrue",
    error_kind=ERR_NEVER,
)

str_ssize_t_size_op = custom_op(
    arg_types=[str_rprimitive],
    return_type=c_pyssize_t_rprimitive,
    c_function_name="CPyStr_Size_size_t",
    error_kind=ERR_NEG_INT,
)

# obj.decode()
method_op(
    name="decode",
    arg_types=[bytes_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPy_Decode",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, pointer_rprimitive), (0, pointer_rprimitive)],
)

# obj.decode(encoding)
method_op(
    name="decode",
    arg_types=[bytes_rprimitive, str_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPy_Decode",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, pointer_rprimitive)],
)

# obj.decode(encoding, errors)
method_op(
    name="decode",
    arg_types=[bytes_rprimitive, str_rprimitive, str_rprimitive],
    return_type=str_rprimitive,
    c_function_name="CPy_Decode",
    error_kind=ERR_MAGIC,
)

# str.encode()
method_op(
    name="encode",
    arg_types=[str_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPy_Encode",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, pointer_rprimitive), (0, pointer_rprimitive)],
)

# str.encode(encoding)
method_op(
    name="encode",
    arg_types=[str_rprimitive, str_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPy_Encode",
    error_kind=ERR_MAGIC,
    extra_int_constants=[(0, pointer_rprimitive)],
)

# str.encode(encoding, errors)
method_op(
    name="encode",
    arg_types=[str_rprimitive, str_rprimitive, str_rprimitive],
    return_type=bytes_rprimitive,
    c_function_name="CPy_Encode",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1854">"""Primitive tuple ops for *variable-length* tuples.

Note: Varying-length tuples are represented as boxed Python tuple
objects, i.e. tuple_rprimitive (RPrimitive), not RTuple.
"""

from __future__ import annotations

from mypyc.ir.ops import ERR_FALSE, ERR_MAGIC
from mypyc.ir.rtypes import (
    bit_rprimitive,
    c_pyssize_t_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
    tuple_rprimitive,
)
from mypyc.primitives.registry import custom_op, function_op, load_address_op, method_op

# Get the 'builtins.tuple' type object.
load_address_op(name="builtins.tuple", type=object_rprimitive, src="PyTuple_Type")

# tuple[index] (for an int index)
tuple_get_item_op = method_op(
    name="__getitem__",
    arg_types=[tuple_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPySequenceTuple_GetItem",
    error_kind=ERR_MAGIC,
)

# Construct a boxed tuple from items: (item1, item2, ...)
new_tuple_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=tuple_rprimitive,
    c_function_name="PyTuple_Pack",
    error_kind=ERR_MAGIC,
    var_arg_type=object_rprimitive,
)

new_tuple_with_length_op = custom_op(
    arg_types=[c_pyssize_t_rprimitive],
    return_type=tuple_rprimitive,
    c_function_name="PyTuple_New",
    error_kind=ERR_MAGIC,
)

# PyTuple_SET_ITEM does no error checking,
# and should only be used to fill in brand new tuples.
new_tuple_set_item_op = custom_op(
    arg_types=[tuple_rprimitive, int_rprimitive, object_rprimitive],
    return_type=bit_rprimitive,
    c_function_name="CPySequenceTuple_SetItemUnsafe",
    error_kind=ERR_FALSE,
    steals=[False, False, True],
)

# Construct tuple from a list.
list_tuple_op = function_op(
    name="builtins.tuple",
    arg_types=[list_rprimitive],
    return_type=tuple_rprimitive,
    c_function_name="PyList_AsTuple",
    error_kind=ERR_MAGIC,
    priority=2,
)

# Construct tuple from an arbitrary (iterable) object.
function_op(
    name="builtins.tuple",
    arg_types=[object_rprimitive],
    return_type=tuple_rprimitive,
    c_function_name="PySequence_Tuple",
    error_kind=ERR_MAGIC,
)

# tuple[begin:end]
tuple_slice_op = custom_op(
    arg_types=[tuple_rprimitive, int_rprimitive, int_rprimitive],
    return_type=object_rprimitive,
    c_function_name="CPySequenceTuple_GetSlice",
    error_kind=ERR_MAGIC,
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1855"></t>
<t tx="ekr.20240308084832.1856">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1857">from __future__ import annotations

import os

provided_prefix = os.getenv("MYPY_TEST_PREFIX", None)
if provided_prefix:
    PREFIX = provided_prefix
else:
    this_file_dir = os.path.dirname(os.path.realpath(__file__))
    PREFIX = os.path.dirname(os.path.dirname(this_file_dir))

# Location of test data files such as test case descriptions.
test_data_prefix = os.path.join(PREFIX, "mypyc", "test-data")
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1858">"""Test cases for inferring always defined attributes in classes."""

from __future__ import annotations

import os.path

from mypy.errors import CompileError
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    MypycDataSuite,
    assert_test_output,
    build_ir_for_single_file2,
    infer_ir_build_options_from_test_name,
    use_custom_builtins,
)

files = ["alwaysdefined.test"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1859">class TestAlwaysDefined(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.186">class UndefinedVisitor(BaseAnalysisVisitor[Value]):
    @others
</t>
<t tx="ekr.20240308084832.1860">files = files
base_path = test_temp_dir

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    """Perform a runtime checking transformation test case."""
    options = infer_ir_build_options_from_test_name(testcase.name)
    if options is None:
        # Skipped test case
        return
    with use_custom_builtins(os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase):
        try:
            ir = build_ir_for_single_file2(testcase.input, options)
        except CompileError as e:
            actual = e.messages
        else:
            actual = []
            for cl in ir.classes:
                if cl.name.startswith("_"):
                    continue
                actual.append(
                    "{}: [{}]".format(cl.name, ", ".join(sorted(cl._always_initialized_attrs)))
                )

        assert_test_output(testcase, actual, "Invalid test output", testcase.output)
</t>
<t tx="ekr.20240308084832.1861">"""Test runner for data-flow analysis test cases."""

from __future__ import annotations

import os.path

from mypy.errors import CompileError
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypyc.analysis import dataflow
from mypyc.common import TOP_LEVEL_NAME
from mypyc.ir.func_ir import all_values
from mypyc.ir.ops import Value
from mypyc.ir.pprint import format_func, generate_names_for_ir
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    MypycDataSuite,
    assert_test_output,
    build_ir_for_single_file,
    use_custom_builtins,
)
from mypyc.transform import exceptions

files = ["analysis.test"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1862">class TestAnalysis(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.1863">files = files
base_path = test_temp_dir
optional_out = True

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    """Perform a data-flow analysis test case."""

    with use_custom_builtins(os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase):
        try:
            ir = build_ir_for_single_file(testcase.input)
        except CompileError as e:
            actual = e.messages
        else:
            actual = []
            for fn in ir:
                if fn.name == TOP_LEVEL_NAME and not testcase.name.endswith("_toplevel"):
                    continue
                exceptions.insert_exception_handling(fn)
                actual.extend(format_func(fn))
                cfg = dataflow.get_cfg(fn.blocks)
                args: set[Value] = set(fn.arg_regs)
                name = testcase.name
                if name.endswith("_MaybeDefined"):
                    # Forward, maybe
                    analysis_result = dataflow.analyze_maybe_defined_regs(fn.blocks, cfg, args)
                elif name.endswith("_Liveness"):
                    # Backward, maybe
                    analysis_result = dataflow.analyze_live_regs(fn.blocks, cfg)
                elif name.endswith("_MustDefined"):
                    # Forward, must
                    analysis_result = dataflow.analyze_must_defined_regs(
                        fn.blocks, cfg, args, regs=all_values(fn.arg_regs, fn.blocks)
                    )
                elif name.endswith("_BorrowedArgument"):
                    # Forward, must
                    analysis_result = dataflow.analyze_borrowed_arguments(fn.blocks, cfg, args)
                else:
                    assert False, "No recognized _AnalysisName suffix in test case"

                names = generate_names_for_ir(fn.arg_regs, fn.blocks)

                for key in sorted(
                    analysis_result.before.keys(), key=lambda x: (x[0].label, x[1])
                ):
                    pre = ", ".join(sorted(names[reg] for reg in analysis_result.before[key]))
                    post = ", ".join(sorted(names[reg] for reg in analysis_result.after[key]))
                    actual.append(
                        "%-8s %-23s %s" % ((key[0].label, key[1]), "{%s}" % pre, "{%s}" % post)
                    )
        assert_test_output(testcase, actual, "Invalid source code output")
</t>
<t tx="ekr.20240308084832.1864">"""Test that C functions used in primitives are declared in a header such as CPy.h."""

from __future__ import annotations

import glob
import os
import re
import unittest

from mypyc.primitives import registry
from mypyc.primitives.registry import CFunctionDescription


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1865">class TestHeaderInclusion(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1866">def test_primitives_included_in_header(self) -&gt; None:
    base_dir = os.path.join(os.path.dirname(__file__), "..", "lib-rt")
    with open(os.path.join(base_dir, "CPy.h")) as f:
        header = f.read()
    with open(os.path.join(base_dir, "pythonsupport.h")) as f:
        header += f.read()

    def check_name(name: str) -&gt; None:
        if name.startswith("CPy"):
            assert re.search(
                rf"\b{name}\b", header
            ), f'"{name}" is used in mypyc.primitives but not declared in CPy.h'

    for values in [
        registry.method_call_ops.values(),
        registry.function_ops.values(),
        registry.binary_ops.values(),
        registry.unary_ops.values(),
    ]:
        for ops in values:
            if isinstance(ops, CFunctionDescription):
                ops = [ops]
            for op in ops:
                check_name(op.c_function_name)

    primitives_path = os.path.join(os.path.dirname(__file__), "..", "primitives")
    for fnam in glob.glob(f"{primitives_path}/*.py"):
        with open(fnam) as f:
            content = f.read()
        for name in re.findall(r'c_function_name=["\'](CPy[A-Z_a-z0-9]+)', content):
            check_name(name)
</t>
<t tx="ekr.20240308084832.1867">"""Test cases for invoking mypyc on the command line.

These are slow -- do not add test cases unless you have a very good reason to do so.
"""

from __future__ import annotations

import glob
import os
import os.path
import re
import subprocess
import sys

from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypy.test.helpers import normalize_error_messages
from mypyc.test.testutil import MypycDataSuite, assert_test_output

files = ["commandline.test"]


base_path = os.path.join(os.path.dirname(__file__), "..", "..")

python3_path = sys.executable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1868">class TestCommandLine(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.1869">files = files
base_path = test_temp_dir
optional_out = True

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    # Parse options from test case description (arguments must not have spaces)
    text = "\n".join(testcase.input)
    m = re.search(r"# *cmd: *(.*)", text)
    assert m is not None, 'Test case missing "# cmd: &lt;files&gt;" section'
    args = m.group(1).split()

    # Write main program to run (not compiled)
    program = "_%s.py" % testcase.name
    program_path = os.path.join(test_temp_dir, program)
    with open(program_path, "w") as f:
        f.write(text)

    env = os.environ.copy()
    env["PYTHONPATH"] = base_path

    out = b""
    try:
        # Compile program
        cmd = subprocess.run(
            [sys.executable, "-m", "mypyc", *args],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            cwd="tmp",
            env=env,
        )
        if "ErrorOutput" in testcase.name or cmd.returncode != 0:
            out += cmd.stdout
        elif "WarningOutput" in testcase.name:
            # Strip out setuptools build related output since we're only
            # interested in the messages emitted during compilation.
            messages, _, _ = cmd.stdout.partition(b"running build_ext")
            out += messages

        if cmd.returncode == 0:
            # Run main program
            out += subprocess.check_output([python3_path, program], cwd="tmp")
    finally:
        suffix = "pyd" if sys.platform == "win32" else "so"
        so_paths = glob.glob(f"tmp/**/*.{suffix}", recursive=True)
        for path in so_paths:
            os.remove(path)

    # Strip out 'tmp/' from error message paths in the testcase output,
    # due to a mismatch between this test and mypy's test suite.
    expected = [x.replace("tmp/", "") for x in testcase.output]

    # Verify output
    actual = normalize_error_messages(out.decode().splitlines())
    assert_test_output(testcase, actual, "Invalid output", expected=expected)
</t>
<t tx="ekr.20240308084832.187">def visit_branch(self, op: Branch) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1870">from __future__ import annotations

import unittest

from mypyc.codegen.emit import Emitter, EmitterContext
from mypyc.ir.ops import BasicBlock, Register, Value
from mypyc.ir.rtypes import RTuple, bool_rprimitive, int_rprimitive, str_rprimitive
from mypyc.namegen import NameGenerator


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1871">class TestEmitter(unittest.TestCase):
@others
</t>
<t tx="ekr.20240308084832.1872">    def setUp(self) -&gt; None:
        self.n = Register(int_rprimitive, "n")
        self.context = EmitterContext(NameGenerator([["mod"]]))
</t>
<t tx="ekr.20240308084832.1873">    def test_label(self) -&gt; None:
        emitter = Emitter(self.context, {})
        assert emitter.label(BasicBlock(4)) == "CPyL4"
</t>
<t tx="ekr.20240308084832.1874">    def test_reg(self) -&gt; None:
        names: dict[Value, str] = {self.n: "n"}
        emitter = Emitter(self.context, names)
        assert emitter.reg(self.n) == "cpy_r_n"
</t>
<t tx="ekr.20240308084832.1875">    def test_object_annotation(self) -&gt; None:
        emitter = Emitter(self.context, {})
        assert emitter.object_annotation("hello, world", "line;") == " /* 'hello, world' */"
        assert (
            emitter.object_annotation(list(range(30)), "line;")
            == """\
 /* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
         23, 24, 25, 26, 27, 28, 29] */"""
        )
</t>
<t tx="ekr.20240308084832.1876">    def test_emit_line(self) -&gt; None:
        emitter = Emitter(self.context, {})
        emitter.emit_line("line;")
        emitter.emit_line("a {")
        emitter.emit_line("f();")
        emitter.emit_line("}")
        assert emitter.fragments == ["line;\n", "a {\n", "    f();\n", "}\n"]
        emitter = Emitter(self.context, {})
        emitter.emit_line("CPyStatics[0];", ann="hello, world")
        emitter.emit_line("CPyStatics[1];", ann=list(range(30)))
        assert emitter.fragments[0] == "CPyStatics[0]; /* 'hello, world' */\n"
        assert (
            emitter.fragments[1]
            == """\
CPyStatics[1]; /* [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
                  21, 22, 23, 24, 25, 26, 27, 28, 29] */\n"""
        )
</t>
<t tx="ekr.20240308084832.1877">    def test_emit_undefined_value_for_simple_type(self) -&gt; None:
        emitter = Emitter(self.context, {})
        assert emitter.c_undefined_value(int_rprimitive) == "CPY_INT_TAG"
        assert emitter.c_undefined_value(str_rprimitive) == "NULL"
        assert emitter.c_undefined_value(bool_rprimitive) == "2"
</t>
<t tx="ekr.20240308084832.1878">    def test_emit_undefined_value_for_tuple(self) -&gt; None:
        emitter = Emitter(self.context, {})
        assert (
            emitter.c_undefined_value(RTuple([str_rprimitive, int_rprimitive, bool_rprimitive]))
            == "(tuple_T3OIC) { NULL, CPY_INT_TAG, 2 }"
        )
        assert emitter.c_undefined_value(RTuple([str_rprimitive])) == "(tuple_T1O) { NULL }"
        assert (
            emitter.c_undefined_value(RTuple([RTuple([str_rprimitive]), bool_rprimitive]))
            == "(tuple_T2T1OC) { { NULL }, 2 }"
        )
</t>
<t tx="ekr.20240308084832.1879">from __future__ import annotations

import unittest

from mypyc.codegen.emitclass import getter_name, setter_name, slot_key
from mypyc.ir.class_ir import ClassIR
from mypyc.namegen import NameGenerator


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.188">def visit_return(self, op: Return) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1880">class TestEmitClass(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1881">def test_slot_key(self) -&gt; None:
    attrs = ["__add__", "__radd__", "__rshift__", "__rrshift__", "__setitem__", "__delitem__"]
    s = sorted(attrs, key=lambda x: slot_key(x))
    # __delitem__ and reverse methods should come last.
    assert s == [
        "__add__",
        "__rshift__",
        "__setitem__",
        "__delitem__",
        "__radd__",
        "__rrshift__",
    ]
</t>
<t tx="ekr.20240308084832.1882">def test_setter_name(self) -&gt; None:
    cls = ClassIR(module_name="testing", name="SomeClass")
    generator = NameGenerator([["mod"]])

    # This should never be `setup`, as it will conflict with the class `setup`
    assert setter_name(cls, "up", generator) == "testing___SomeClass_set_up"
</t>
<t tx="ekr.20240308084832.1883">def test_getter_name(self) -&gt; None:
    cls = ClassIR(module_name="testing", name="SomeClass")
    generator = NameGenerator([["mod"]])

    assert getter_name(cls, "down", generator) == "testing___SomeClass_get_down"
</t>
<t tx="ekr.20240308084832.1884">from __future__ import annotations

import unittest

from mypy.test.helpers import assert_string_arrays_equal
from mypyc.codegen.emit import Emitter, EmitterContext
from mypyc.codegen.emitfunc import FunctionEmitterVisitor, generate_native_function
from mypyc.common import PLATFORM_SIZE
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature, RuntimeArg
from mypyc.ir.ops import (
    ERR_NEVER,
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    DecRef,
    Extend,
    GetAttr,
    GetElementPtr,
    Goto,
    IncRef,
    Integer,
    IntOp,
    LoadAddress,
    LoadMem,
    Op,
    Register,
    Return,
    SetAttr,
    SetMem,
    TupleGet,
    Unbox,
    Unreachable,
    Value,
)
from mypyc.ir.pprint import generate_names_for_ir
from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RStruct,
    RTuple,
    RType,
    bool_rprimitive,
    c_int_rprimitive,
    dict_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
    short_int_rprimitive,
)
from mypyc.irbuild.vtable import compute_vtable
from mypyc.namegen import NameGenerator
from mypyc.primitives.dict_ops import (
    dict_get_item_op,
    dict_new_op,
    dict_set_item_op,
    dict_update_op,
)
from mypyc.primitives.int_ops import int_neg_op
from mypyc.primitives.list_ops import list_append_op, list_get_item_op, list_set_item_op
from mypyc.primitives.misc_ops import none_object_op
from mypyc.primitives.registry import binary_ops
from mypyc.subtype import is_subtype


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1885">class TestFunctionEmitterVisitor(unittest.TestCase):
    """Test generation of fragments of C from individual IR ops."""
    @others
</t>
<t tx="ekr.20240308084832.1886">def setUp(self) -&gt; None:
    self.registers: list[Register] = []

    def add_local(name: str, rtype: RType) -&gt; Register:
        reg = Register(rtype, name)
        self.registers.append(reg)
        return reg

    self.n = add_local("n", int_rprimitive)
    self.m = add_local("m", int_rprimitive)
    self.k = add_local("k", int_rprimitive)
    self.l = add_local("l", list_rprimitive)
    self.ll = add_local("ll", list_rprimitive)
    self.o = add_local("o", object_rprimitive)
    self.o2 = add_local("o2", object_rprimitive)
    self.d = add_local("d", dict_rprimitive)
    self.b = add_local("b", bool_rprimitive)
    self.s1 = add_local("s1", short_int_rprimitive)
    self.s2 = add_local("s2", short_int_rprimitive)
    self.i32 = add_local("i32", int32_rprimitive)
    self.i32_1 = add_local("i32_1", int32_rprimitive)
    self.i64 = add_local("i64", int64_rprimitive)
    self.i64_1 = add_local("i64_1", int64_rprimitive)
    self.ptr = add_local("ptr", pointer_rprimitive)
    self.t = add_local("t", RTuple([int_rprimitive, bool_rprimitive]))
    self.tt = add_local(
        "tt", RTuple([RTuple([int_rprimitive, bool_rprimitive]), bool_rprimitive])
    )
    ir = ClassIR("A", "mod")
    ir.attributes = {
        "x": bool_rprimitive,
        "y": int_rprimitive,
        "i1": int64_rprimitive,
        "i2": int32_rprimitive,
    }
    ir.bitmap_attrs = ["i1", "i2"]
    compute_vtable(ir)
    ir.mro = [ir]
    self.r = add_local("r", RInstance(ir))

    self.context = EmitterContext(NameGenerator([["mod"]]))
</t>
<t tx="ekr.20240308084832.1887">def test_goto(self) -&gt; None:
    self.assert_emit(Goto(BasicBlock(2)), "goto CPyL2;")
</t>
<t tx="ekr.20240308084832.1888">def test_goto_next_block(self) -&gt; None:
    next_block = BasicBlock(2)
    self.assert_emit(Goto(next_block), "", next_block=next_block)
</t>
<t tx="ekr.20240308084832.1889">def test_return(self) -&gt; None:
    self.assert_emit(Return(self.m), "return cpy_r_m;")
</t>
<t tx="ekr.20240308084832.189">def visit_unreachable(self, op: Unreachable) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1890">def test_integer(self) -&gt; None:
    self.assert_emit(Assign(self.n, Integer(5)), "cpy_r_n = 10;")
    self.assert_emit(Assign(self.i32, Integer(5, c_int_rprimitive)), "cpy_r_i32 = 5;")
</t>
<t tx="ekr.20240308084832.1891">def test_tuple_get(self) -&gt; None:
    self.assert_emit(TupleGet(self.t, 1, 0), "cpy_r_r0 = cpy_r_t.f1;")
</t>
<t tx="ekr.20240308084832.1892">def test_load_None(self) -&gt; None:
    self.assert_emit(
        LoadAddress(none_object_op.type, none_object_op.src, 0),
        "cpy_r_r0 = (PyObject *)&amp;_Py_NoneStruct;",
    )
</t>
<t tx="ekr.20240308084832.1893">def test_assign_int(self) -&gt; None:
    self.assert_emit(Assign(self.m, self.n), "cpy_r_m = cpy_r_n;")
</t>
<t tx="ekr.20240308084832.1894">def test_int_add(self) -&gt; None:
    self.assert_emit_binary_op(
        "+", self.n, self.m, self.k, "cpy_r_r0 = CPyTagged_Add(cpy_r_m, cpy_r_k);"
    )
</t>
<t tx="ekr.20240308084832.1895">def test_int_sub(self) -&gt; None:
    self.assert_emit_binary_op(
        "-", self.n, self.m, self.k, "cpy_r_r0 = CPyTagged_Subtract(cpy_r_m, cpy_r_k);"
    )
</t>
<t tx="ekr.20240308084832.1896">def test_int_neg(self) -&gt; None:
    self.assert_emit(
        CallC(
            int_neg_op.c_function_name,
            [self.m],
            int_neg_op.return_type,
            int_neg_op.steals,
            int_neg_op.is_borrowed,
            int_neg_op.is_borrowed,
            int_neg_op.error_kind,
            55,
        ),
        "cpy_r_r0 = CPyTagged_Negate(cpy_r_m);",
    )
</t>
<t tx="ekr.20240308084832.1897">def test_branch(self) -&gt; None:
    self.assert_emit(
        Branch(self.b, BasicBlock(8), BasicBlock(9), Branch.BOOL),
        """if (cpy_r_b) {
                            goto CPyL8;
                        } else
                            goto CPyL9;
</t>
<t tx="ekr.20240308084832.1898">                         """,
        )
        b = Branch(self.b, BasicBlock(8), BasicBlock(9), Branch.BOOL)
        b.negated = True
        self.assert_emit(
            b,
            """if (!cpy_r_b) {
                                goto CPyL8;
                            } else
                                goto CPyL9;
                         """,
        )

    def test_branch_no_else(self) -&gt; None:
        next_block = BasicBlock(9)
        b = Branch(self.b, BasicBlock(8), next_block, Branch.BOOL)
        self.assert_emit(b, """if (cpy_r_b) goto CPyL8;""", next_block=next_block)
        next_block = BasicBlock(9)
        b = Branch(self.b, BasicBlock(8), next_block, Branch.BOOL)
        b.negated = True
        self.assert_emit(b, """if (!cpy_r_b) goto CPyL8;""", next_block=next_block)
</t>
<t tx="ekr.20240308084832.1899">    def test_branch_no_else_negated(self) -&gt; None:
        next_block = BasicBlock(1)
        b = Branch(self.b, next_block, BasicBlock(2), Branch.BOOL)
        self.assert_emit(b, """if (!cpy_r_b) goto CPyL2;""", next_block=next_block)
        next_block = BasicBlock(1)
        b = Branch(self.b, next_block, BasicBlock(2), Branch.BOOL)
        b.negated = True
        self.assert_emit(b, """if (cpy_r_b) goto CPyL2;""", next_block=next_block)
</t>
<t tx="ekr.20240308084832.19">def construct_groups(
    sources: list[BuildSource],
    separate: bool | list[tuple[list[str], str | None]],
    use_shared_lib: bool,
) -&gt; emitmodule.Groups:
    """Compute Groups given the input source list and separate configs.

    separate is the user-specified configuration for how to assign
    modules to compilation groups (see mypycify docstring for details).

    This takes that and expands it into our internal representation of
    group configuration, documented in mypyc.emitmodule's definition
    of Group.
    """

    if separate is True:
        groups: emitmodule.Groups = [([source], None) for source in sources]
    elif isinstance(separate, list):
        groups = []
        used_sources = set()
        for files, name in separate:
            group_sources = [src for src in sources if src.path in files]
            groups.append((group_sources, name))
            used_sources.update(group_sources)
        unused_sources = [src for src in sources if src not in used_sources]
        if unused_sources:
            groups.extend([([source], None) for source in unused_sources])
    else:
        groups = [(sources, None)]

    # Generate missing names
    for i, (group, name) in enumerate(groups):
        if use_shared_lib and not name:
            name = group_name([source.module for source in group])
        groups[i] = (group, name)

    return groups
</t>
<t tx="ekr.20240308084832.190">def visit_register_op(self, op: RegisterOp) -&gt; GenAndKill[Value]:
    return set(), {op} if not op.is_void else set()
</t>
<t tx="ekr.20240308084832.1900">    def test_branch_is_error(self) -&gt; None:
        b = Branch(self.b, BasicBlock(8), BasicBlock(9), Branch.IS_ERROR)
        self.assert_emit(
            b,
            """if (cpy_r_b == 2) {
                                goto CPyL8;
                            } else
                                goto CPyL9;
</t>
<t tx="ekr.20240308084832.1901">                         """,
        )
        b = Branch(self.b, BasicBlock(8), BasicBlock(9), Branch.IS_ERROR)
        b.negated = True
        self.assert_emit(
            b,
            """if (cpy_r_b != 2) {
                                goto CPyL8;
                            } else
                                goto CPyL9;
                         """,
        )

    def test_branch_is_error_next_block(self) -&gt; None:
        next_block = BasicBlock(8)
        b = Branch(self.b, next_block, BasicBlock(9), Branch.IS_ERROR)
        self.assert_emit(b, """if (cpy_r_b != 2) goto CPyL9;""", next_block=next_block)
        b = Branch(self.b, next_block, BasicBlock(9), Branch.IS_ERROR)
        b.negated = True
        self.assert_emit(b, """if (cpy_r_b == 2) goto CPyL9;""", next_block=next_block)
</t>
<t tx="ekr.20240308084832.1902">    def test_branch_rare(self) -&gt; None:
        self.assert_emit(
            Branch(self.b, BasicBlock(8), BasicBlock(9), Branch.BOOL, rare=True),
            """if (unlikely(cpy_r_b)) {
                                goto CPyL8;
                            } else
                                goto CPyL9;
</t>
<t tx="ekr.20240308084832.1903">                         """,
        )
        next_block = BasicBlock(9)
        self.assert_emit(
            Branch(self.b, BasicBlock(8), next_block, Branch.BOOL, rare=True),
            """if (unlikely(cpy_r_b)) goto CPyL8;""",
            next_block=next_block,
        )
        next_block = BasicBlock(8)
        b = Branch(self.b, next_block, BasicBlock(9), Branch.BOOL, rare=True)
        self.assert_emit(b, """if (likely(!cpy_r_b)) goto CPyL9;""", next_block=next_block)
        next_block = BasicBlock(8)
        b = Branch(self.b, next_block, BasicBlock(9), Branch.BOOL, rare=True)
        b.negated = True
        self.assert_emit(b, """if (likely(cpy_r_b)) goto CPyL9;""", next_block=next_block)

    def test_call(self) -&gt; None:
        decl = FuncDecl(
            "myfn", None, "mod", FuncSignature([RuntimeArg("m", int_rprimitive)], int_rprimitive)
        )
        self.assert_emit(Call(decl, [self.m], 55), "cpy_r_r0 = CPyDef_myfn(cpy_r_m);")
</t>
<t tx="ekr.20240308084832.1904">    def test_call_two_args(self) -&gt; None:
        decl = FuncDecl(
            "myfn",
            None,
            "mod",
            FuncSignature(
                [RuntimeArg("m", int_rprimitive), RuntimeArg("n", int_rprimitive)], int_rprimitive
            ),
        )
        self.assert_emit(
            Call(decl, [self.m, self.k], 55), "cpy_r_r0 = CPyDef_myfn(cpy_r_m, cpy_r_k);"
        )
</t>
<t tx="ekr.20240308084832.1905">    def test_inc_ref(self) -&gt; None:
        self.assert_emit(IncRef(self.o), "CPy_INCREF(cpy_r_o);")
        self.assert_emit(IncRef(self.o), "CPy_INCREF(cpy_r_o);", rare=True)
</t>
<t tx="ekr.20240308084832.1906">    def test_dec_ref(self) -&gt; None:
        self.assert_emit(DecRef(self.o), "CPy_DECREF(cpy_r_o);")
        self.assert_emit(DecRef(self.o), "CPy_DecRef(cpy_r_o);", rare=True)
</t>
<t tx="ekr.20240308084832.1907">    def test_inc_ref_int(self) -&gt; None:
        self.assert_emit(IncRef(self.m), "CPyTagged_INCREF(cpy_r_m);")
        self.assert_emit(IncRef(self.m), "CPyTagged_IncRef(cpy_r_m);", rare=True)
</t>
<t tx="ekr.20240308084832.1908">    def test_dec_ref_int(self) -&gt; None:
        self.assert_emit(DecRef(self.m), "CPyTagged_DECREF(cpy_r_m);")
        self.assert_emit(DecRef(self.m), "CPyTagged_DecRef(cpy_r_m);", rare=True)
</t>
<t tx="ekr.20240308084832.1909">    def test_dec_ref_tuple(self) -&gt; None:
        self.assert_emit(DecRef(self.t), "CPyTagged_DECREF(cpy_r_t.f0);")
</t>
<t tx="ekr.20240308084832.191">def visit_assign(self, op: Assign) -&gt; GenAndKill[Value]:
    return set(), {op.dest}
</t>
<t tx="ekr.20240308084832.1910">    def test_dec_ref_tuple_nested(self) -&gt; None:
        self.assert_emit(DecRef(self.tt), "CPyTagged_DECREF(cpy_r_tt.f0.f0);")
</t>
<t tx="ekr.20240308084832.1911">    def test_list_get_item(self) -&gt; None:
        self.assert_emit(
            CallC(
                list_get_item_op.c_function_name,
                [self.m, self.k],
                list_get_item_op.return_type,
                list_get_item_op.steals,
                list_get_item_op.is_borrowed,
                list_get_item_op.error_kind,
                55,
            ),
            """cpy_r_r0 = CPyList_GetItem(cpy_r_m, cpy_r_k);""",
        )
</t>
<t tx="ekr.20240308084832.1912">    def test_list_set_item(self) -&gt; None:
        self.assert_emit(
            CallC(
                list_set_item_op.c_function_name,
                [self.l, self.n, self.o],
                list_set_item_op.return_type,
                list_set_item_op.steals,
                list_set_item_op.is_borrowed,
                list_set_item_op.error_kind,
                55,
            ),
            """cpy_r_r0 = CPyList_SetItem(cpy_r_l, cpy_r_n, cpy_r_o);""",
        )
</t>
<t tx="ekr.20240308084832.1913">    def test_box_int(self) -&gt; None:
        self.assert_emit(Box(self.n), """cpy_r_r0 = CPyTagged_StealAsObject(cpy_r_n);""")
</t>
<t tx="ekr.20240308084832.1914">    def test_unbox_int(self) -&gt; None:
        self.assert_emit(
            Unbox(self.m, int_rprimitive, 55),
            """if (likely(PyLong_Check(cpy_r_m)))
                                cpy_r_r0 = CPyTagged_FromObject(cpy_r_m);
                            else {
                                CPy_TypeError("int", cpy_r_m); cpy_r_r0 = CPY_INT_TAG;
                            }
</t>
<t tx="ekr.20240308084832.1915">                         """,
        )

    def test_box_i64(self) -&gt; None:
        self.assert_emit(Box(self.i64), """cpy_r_r0 = PyLong_FromLongLong(cpy_r_i64);""")
</t>
<t tx="ekr.20240308084832.1916">    def test_unbox_i64(self) -&gt; None:
        self.assert_emit(
            Unbox(self.o, int64_rprimitive, 55), """cpy_r_r0 = CPyLong_AsInt64(cpy_r_o);"""
        )
</t>
<t tx="ekr.20240308084832.1917">    def test_list_append(self) -&gt; None:
        self.assert_emit(
            CallC(
                list_append_op.c_function_name,
                [self.l, self.o],
                list_append_op.return_type,
                list_append_op.steals,
                list_append_op.is_borrowed,
                list_append_op.error_kind,
                1,
            ),
            """cpy_r_r0 = PyList_Append(cpy_r_l, cpy_r_o);""",
        )
</t>
<t tx="ekr.20240308084832.1918">    def test_get_attr(self) -&gt; None:
        self.assert_emit(
            GetAttr(self.r, "y", 1),
            """cpy_r_r0 = ((mod___AObject *)cpy_r_r)-&gt;_y;
               if (unlikely(cpy_r_r0 == CPY_INT_TAG)) {
                   PyErr_SetString(PyExc_AttributeError, "attribute 'y' of 'A' undefined");
               } else {
                   CPyTagged_INCREF(cpy_r_r0);
               }
</t>
<t tx="ekr.20240308084832.1919">            """,
        )

    def test_get_attr_non_refcounted(self) -&gt; None:
        self.assert_emit(
            GetAttr(self.r, "x", 1),
            """cpy_r_r0 = ((mod___AObject *)cpy_r_r)-&gt;_x;
               if (unlikely(cpy_r_r0 == 2)) {
                   PyErr_SetString(PyExc_AttributeError, "attribute 'x' of 'A' undefined");
               }
</t>
<t tx="ekr.20240308084832.192">def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill[Value]:
    return set(), {op.dest}
</t>
<t tx="ekr.20240308084832.1920">            """,
        )

    def test_get_attr_merged(self) -&gt; None:
        op = GetAttr(self.r, "y", 1)
        branch = Branch(op, BasicBlock(8), BasicBlock(9), Branch.IS_ERROR)
        branch.traceback_entry = ("foobar", 123)
        self.assert_emit(
            op,
            """\
            cpy_r_r0 = ((mod___AObject *)cpy_r_r)-&gt;_y;
            if (unlikely(cpy_r_r0 == CPY_INT_TAG)) {
                CPy_AttributeError("prog.py", "foobar", "A", "y", 123, CPyStatic_prog___globals);
                goto CPyL8;
            }
            CPyTagged_INCREF(cpy_r_r0);
            goto CPyL9;
</t>
<t tx="ekr.20240308084832.1921">            """,
            next_branch=branch,
            skip_next=True,
        )

    def test_get_attr_with_bitmap(self) -&gt; None:
        self.assert_emit(
            GetAttr(self.r, "i1", 1),
            """cpy_r_r0 = ((mod___AObject *)cpy_r_r)-&gt;_i1;
               if (unlikely(cpy_r_r0 == -113) &amp;&amp; !(((mod___AObject *)cpy_r_r)-&gt;bitmap &amp; 1)) {
                   PyErr_SetString(PyExc_AttributeError, "attribute 'i1' of 'A' undefined");
               }
</t>
<t tx="ekr.20240308084832.1922">            """,
        )

    def test_set_attr(self) -&gt; None:
        self.assert_emit(
            SetAttr(self.r, "y", self.m, 1),
            """if (((mod___AObject *)cpy_r_r)-&gt;_y != CPY_INT_TAG) {
                   CPyTagged_DECREF(((mod___AObject *)cpy_r_r)-&gt;_y);
               }
               ((mod___AObject *)cpy_r_r)-&gt;_y = cpy_r_m;
               cpy_r_r0 = 1;
</t>
<t tx="ekr.20240308084832.1923">            """,
        )

    def test_set_attr_non_refcounted(self) -&gt; None:
        self.assert_emit(
            SetAttr(self.r, "x", self.b, 1),
            """((mod___AObject *)cpy_r_r)-&gt;_x = cpy_r_b;
               cpy_r_r0 = 1;
</t>
<t tx="ekr.20240308084832.1924">            """,
        )

    def test_set_attr_no_error(self) -&gt; None:
        op = SetAttr(self.r, "y", self.m, 1)
        op.error_kind = ERR_NEVER
        self.assert_emit(
            op,
            """if (((mod___AObject *)cpy_r_r)-&gt;_y != CPY_INT_TAG) {
                   CPyTagged_DECREF(((mod___AObject *)cpy_r_r)-&gt;_y);
               }
               ((mod___AObject *)cpy_r_r)-&gt;_y = cpy_r_m;
</t>
<t tx="ekr.20240308084832.1925">            """,
        )

    def test_set_attr_non_refcounted_no_error(self) -&gt; None:
        op = SetAttr(self.r, "x", self.b, 1)
        op.error_kind = ERR_NEVER
        self.assert_emit(
            op,
            """((mod___AObject *)cpy_r_r)-&gt;_x = cpy_r_b;
</t>
<t tx="ekr.20240308084832.1926">            """,
        )

    def test_set_attr_with_bitmap(self) -&gt; None:
        # For some rtypes the error value overlaps a valid value, so we need
        # to use a separate bitmap to track defined attributes.
        self.assert_emit(
            SetAttr(self.r, "i1", self.i64, 1),
            """if (unlikely(cpy_r_i64 == -113)) {
                   ((mod___AObject *)cpy_r_r)-&gt;bitmap |= 1;
               }
               ((mod___AObject *)cpy_r_r)-&gt;_i1 = cpy_r_i64;
               cpy_r_r0 = 1;
</t>
<t tx="ekr.20240308084832.1927">            """,
        )
        self.assert_emit(
            SetAttr(self.r, "i2", self.i32, 1),
            """if (unlikely(cpy_r_i32 == -113)) {
                   ((mod___AObject *)cpy_r_r)-&gt;bitmap |= 2;
               }
               ((mod___AObject *)cpy_r_r)-&gt;_i2 = cpy_r_i32;
               cpy_r_r0 = 1;
            """,
        )

    def test_set_attr_init_with_bitmap(self) -&gt; None:
        op = SetAttr(self.r, "i1", self.i64, 1)
        op.is_init = True
        self.assert_emit(
            op,
            """if (unlikely(cpy_r_i64 == -113)) {
                   ((mod___AObject *)cpy_r_r)-&gt;bitmap |= 1;
               }
               ((mod___AObject *)cpy_r_r)-&gt;_i1 = cpy_r_i64;
               cpy_r_r0 = 1;
</t>
<t tx="ekr.20240308084832.1928">            """,
        )

    def test_dict_get_item(self) -&gt; None:
        self.assert_emit(
            CallC(
                dict_get_item_op.c_function_name,
                [self.d, self.o2],
                dict_get_item_op.return_type,
                dict_get_item_op.steals,
                dict_get_item_op.is_borrowed,
                dict_get_item_op.error_kind,
                1,
            ),
            """cpy_r_r0 = CPyDict_GetItem(cpy_r_d, cpy_r_o2);""",
        )
</t>
<t tx="ekr.20240308084832.1929">    def test_dict_set_item(self) -&gt; None:
        self.assert_emit(
            CallC(
                dict_set_item_op.c_function_name,
                [self.d, self.o, self.o2],
                dict_set_item_op.return_type,
                dict_set_item_op.steals,
                dict_set_item_op.is_borrowed,
                dict_set_item_op.error_kind,
                1,
            ),
            """cpy_r_r0 = CPyDict_SetItem(cpy_r_d, cpy_r_o, cpy_r_o2);""",
        )
</t>
<t tx="ekr.20240308084832.193">def visit_set_mem(self, op: SetMem) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1930">    def test_dict_update(self) -&gt; None:
        self.assert_emit(
            CallC(
                dict_update_op.c_function_name,
                [self.d, self.o],
                dict_update_op.return_type,
                dict_update_op.steals,
                dict_update_op.is_borrowed,
                dict_update_op.error_kind,
                1,
            ),
            """cpy_r_r0 = CPyDict_Update(cpy_r_d, cpy_r_o);""",
        )
</t>
<t tx="ekr.20240308084832.1931">    def test_new_dict(self) -&gt; None:
        self.assert_emit(
            CallC(
                dict_new_op.c_function_name,
                [],
                dict_new_op.return_type,
                dict_new_op.steals,
                dict_new_op.is_borrowed,
                dict_new_op.error_kind,
                1,
            ),
            """cpy_r_r0 = PyDict_New();""",
        )
</t>
<t tx="ekr.20240308084832.1932">    def test_dict_contains(self) -&gt; None:
        self.assert_emit_binary_op(
            "in", self.b, self.o, self.d, """cpy_r_r0 = PyDict_Contains(cpy_r_d, cpy_r_o);"""
        )
</t>
<t tx="ekr.20240308084832.1933">    def test_int_op(self) -&gt; None:
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.ADD, 1),
            """cpy_r_r0 = cpy_r_s1 + cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.SUB, 1),
            """cpy_r_r0 = cpy_r_s1 - cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.MUL, 1),
            """cpy_r_r0 = cpy_r_s1 * cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.DIV, 1),
            """cpy_r_r0 = cpy_r_s1 / cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.MOD, 1),
            """cpy_r_r0 = cpy_r_s1 % cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.AND, 1),
            """cpy_r_r0 = cpy_r_s1 &amp; cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.OR, 1),
            """cpy_r_r0 = cpy_r_s1 | cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.XOR, 1),
            """cpy_r_r0 = cpy_r_s1 ^ cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.LEFT_SHIFT, 1),
            """cpy_r_r0 = cpy_r_s1 &lt;&lt; cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.s1, self.s2, IntOp.RIGHT_SHIFT, 1),
            """cpy_r_r0 = (Py_ssize_t)cpy_r_s1 &gt;&gt; (Py_ssize_t)cpy_r_s2;""",
        )
        self.assert_emit(
            IntOp(short_int_rprimitive, self.i64, self.i64_1, IntOp.RIGHT_SHIFT, 1),
            """cpy_r_r0 = cpy_r_i64 &gt;&gt; cpy_r_i64_1;""",
        )
</t>
<t tx="ekr.20240308084832.1934">    def test_comparison_op(self) -&gt; None:
        # signed
        self.assert_emit(
            ComparisonOp(self.s1, self.s2, ComparisonOp.SLT, 1),
            """cpy_r_r0 = (Py_ssize_t)cpy_r_s1 &lt; (Py_ssize_t)cpy_r_s2;""",
        )
        self.assert_emit(
            ComparisonOp(self.i32, self.i32_1, ComparisonOp.SLT, 1),
            """cpy_r_r0 = cpy_r_i32 &lt; cpy_r_i32_1;""",
        )
        self.assert_emit(
            ComparisonOp(self.i64, self.i64_1, ComparisonOp.SLT, 1),
            """cpy_r_r0 = cpy_r_i64 &lt; cpy_r_i64_1;""",
        )
        # unsigned
        self.assert_emit(
            ComparisonOp(self.s1, self.s2, ComparisonOp.ULT, 1),
            """cpy_r_r0 = cpy_r_s1 &lt; cpy_r_s2;""",
        )
        self.assert_emit(
            ComparisonOp(self.i32, self.i32_1, ComparisonOp.ULT, 1),
            """cpy_r_r0 = (uint32_t)cpy_r_i32 &lt; (uint32_t)cpy_r_i32_1;""",
        )
        self.assert_emit(
            ComparisonOp(self.i64, self.i64_1, ComparisonOp.ULT, 1),
            """cpy_r_r0 = (uint64_t)cpy_r_i64 &lt; (uint64_t)cpy_r_i64_1;""",
        )

        # object type
        self.assert_emit(
            ComparisonOp(self.o, self.o2, ComparisonOp.EQ, 1),
            """cpy_r_r0 = cpy_r_o == cpy_r_o2;""",
        )
        self.assert_emit(
            ComparisonOp(self.o, self.o2, ComparisonOp.NEQ, 1),
            """cpy_r_r0 = cpy_r_o != cpy_r_o2;""",
        )
</t>
<t tx="ekr.20240308084832.1935">    def test_load_mem(self) -&gt; None:
        self.assert_emit(LoadMem(bool_rprimitive, self.ptr), """cpy_r_r0 = *(char *)cpy_r_ptr;""")
</t>
<t tx="ekr.20240308084832.1936">    def test_set_mem(self) -&gt; None:
        self.assert_emit(
            SetMem(bool_rprimitive, self.ptr, self.b), """*(char *)cpy_r_ptr = cpy_r_b;"""
        )
</t>
<t tx="ekr.20240308084832.1937">    def test_get_element_ptr(self) -&gt; None:
        r = RStruct(
            "Foo", ["b", "i32", "i64"], [bool_rprimitive, int32_rprimitive, int64_rprimitive]
        )
        self.assert_emit(
            GetElementPtr(self.o, r, "b"), """cpy_r_r0 = (CPyPtr)&amp;((Foo *)cpy_r_o)-&gt;b;"""
        )
        self.assert_emit(
            GetElementPtr(self.o, r, "i32"), """cpy_r_r0 = (CPyPtr)&amp;((Foo *)cpy_r_o)-&gt;i32;"""
        )
        self.assert_emit(
            GetElementPtr(self.o, r, "i64"), """cpy_r_r0 = (CPyPtr)&amp;((Foo *)cpy_r_o)-&gt;i64;"""
        )
</t>
<t tx="ekr.20240308084832.1938">    def test_load_address(self) -&gt; None:
        self.assert_emit(
            LoadAddress(object_rprimitive, "PyDict_Type"),
            """cpy_r_r0 = (PyObject *)&amp;PyDict_Type;""",
        )
</t>
<t tx="ekr.20240308084832.1939">    def test_assign_multi(self) -&gt; None:
        t = RArray(object_rprimitive, 2)
        a = Register(t, "a")
        self.registers.append(a)
        self.assert_emit(
            AssignMulti(a, [self.o, self.o2]), """PyObject *cpy_r_a[2] = {cpy_r_o, cpy_r_o2};"""
        )
</t>
<t tx="ekr.20240308084832.194">def analyze_undefined_regs(
    blocks: list[BasicBlock], cfg: CFG, initial_defined: set[Value]
) -&gt; AnalysisResult[Value]:
    """Calculate potentially undefined registers at each CFG location.

    A register is undefined if there is some path from initial block
    where it has an undefined value.

    Function arguments are assumed to be always defined.
    """
    initial_undefined = set(all_values([], blocks)) - initial_defined
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=UndefinedVisitor(),
        initial=initial_undefined,
        backward=False,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.1940">    def test_long_unsigned(self) -&gt; None:
        a = Register(int64_rprimitive, "a")
        self.assert_emit(
            Assign(a, Integer(1 &lt;&lt; 31, int64_rprimitive)), """cpy_r_a = 2147483648LL;"""
        )
        self.assert_emit(
            Assign(a, Integer((1 &lt;&lt; 31) - 1, int64_rprimitive)), """cpy_r_a = 2147483647;"""
        )
</t>
<t tx="ekr.20240308084832.1941">    def test_long_signed(self) -&gt; None:
        a = Register(int64_rprimitive, "a")
        self.assert_emit(
            Assign(a, Integer(-(1 &lt;&lt; 31) + 1, int64_rprimitive)), """cpy_r_a = -2147483647;"""
        )
        self.assert_emit(
            Assign(a, Integer(-(1 &lt;&lt; 31), int64_rprimitive)), """cpy_r_a = -2147483648LL;"""
        )
</t>
<t tx="ekr.20240308084832.1942">    def test_cast_and_branch_merge(self) -&gt; None:
        op = Cast(self.r, dict_rprimitive, 1)
        next_block = BasicBlock(9)
        branch = Branch(op, BasicBlock(8), next_block, Branch.IS_ERROR)
        branch.traceback_entry = ("foobar", 123)
        self.assert_emit(
            op,
            """\
if (likely(PyDict_Check(cpy_r_r)))
    cpy_r_r0 = cpy_r_r;
else {
    CPy_TypeErrorTraceback("prog.py", "foobar", 123, CPyStatic_prog___globals, "dict", cpy_r_r);
    goto CPyL8;
}
</t>
<t tx="ekr.20240308084832.1943">""",
            next_block=next_block,
            next_branch=branch,
            skip_next=True,
        )

    def test_cast_and_branch_no_merge_1(self) -&gt; None:
        op = Cast(self.r, dict_rprimitive, 1)
        branch = Branch(op, BasicBlock(8), BasicBlock(9), Branch.IS_ERROR)
        branch.traceback_entry = ("foobar", 123)
        self.assert_emit(
            op,
            """\
            if (likely(PyDict_Check(cpy_r_r)))
                cpy_r_r0 = cpy_r_r;
            else {
                CPy_TypeError("dict", cpy_r_r);
                cpy_r_r0 = NULL;
            }
</t>
<t tx="ekr.20240308084832.1944">            """,
            next_block=BasicBlock(10),
            next_branch=branch,
            skip_next=False,
        )

    def test_cast_and_branch_no_merge_2(self) -&gt; None:
        op = Cast(self.r, dict_rprimitive, 1)
        next_block = BasicBlock(9)
        branch = Branch(op, BasicBlock(8), next_block, Branch.IS_ERROR)
        branch.negated = True
        branch.traceback_entry = ("foobar", 123)
        self.assert_emit(
            op,
            """\
            if (likely(PyDict_Check(cpy_r_r)))
                cpy_r_r0 = cpy_r_r;
            else {
                CPy_TypeError("dict", cpy_r_r);
                cpy_r_r0 = NULL;
            }
</t>
<t tx="ekr.20240308084832.1945">            """,
            next_block=next_block,
            next_branch=branch,
        )

    def test_cast_and_branch_no_merge_3(self) -&gt; None:
        op = Cast(self.r, dict_rprimitive, 1)
        next_block = BasicBlock(9)
        branch = Branch(op, BasicBlock(8), next_block, Branch.BOOL)
        branch.traceback_entry = ("foobar", 123)
        self.assert_emit(
            op,
            """\
            if (likely(PyDict_Check(cpy_r_r)))
                cpy_r_r0 = cpy_r_r;
            else {
                CPy_TypeError("dict", cpy_r_r);
                cpy_r_r0 = NULL;
            }
</t>
<t tx="ekr.20240308084832.1946">            """,
            next_block=next_block,
            next_branch=branch,
        )

    def test_cast_and_branch_no_merge_4(self) -&gt; None:
        op = Cast(self.r, dict_rprimitive, 1)
        next_block = BasicBlock(9)
        branch = Branch(op, BasicBlock(8), next_block, Branch.IS_ERROR)
        self.assert_emit(
            op,
            """\
            if (likely(PyDict_Check(cpy_r_r)))
                cpy_r_r0 = cpy_r_r;
            else {
                CPy_TypeError("dict", cpy_r_r);
                cpy_r_r0 = NULL;
            }
</t>
<t tx="ekr.20240308084832.1947">            """,
            next_block=next_block,
            next_branch=branch,
        )

    def test_extend(self) -&gt; None:
        a = Register(int32_rprimitive, "a")
        self.assert_emit(Extend(a, int64_rprimitive, signed=True), """cpy_r_r0 = cpy_r_a;""")
        self.assert_emit(
            Extend(a, int64_rprimitive, signed=False), """cpy_r_r0 = (uint32_t)cpy_r_a;"""
        )
        if PLATFORM_SIZE == 4:
            self.assert_emit(
                Extend(self.n, int64_rprimitive, signed=True),
                """cpy_r_r0 = (Py_ssize_t)cpy_r_n;""",
            )
            self.assert_emit(
                Extend(self.n, int64_rprimitive, signed=False), """cpy_r_r0 = cpy_r_n;"""
            )
        if PLATFORM_SIZE == 8:
            self.assert_emit(Extend(a, int_rprimitive, signed=True), """cpy_r_r0 = cpy_r_a;""")
            self.assert_emit(
                Extend(a, int_rprimitive, signed=False), """cpy_r_r0 = (uint32_t)cpy_r_a;"""
            )
</t>
<t tx="ekr.20240308084832.1948">    def assert_emit(
        self,
        op: Op,
        expected: str,
        next_block: BasicBlock | None = None,
        *,
        rare: bool = False,
        next_branch: Branch | None = None,
        skip_next: bool = False,
    ) -&gt; None:
        block = BasicBlock(0)
        block.ops.append(op)
        value_names = generate_names_for_ir(self.registers, [block])
        emitter = Emitter(self.context, value_names)
        declarations = Emitter(self.context, value_names)
        emitter.fragments = []
        declarations.fragments = []

        visitor = FunctionEmitterVisitor(emitter, declarations, "prog.py", "prog")
        visitor.next_block = next_block
        visitor.rare = rare
        if next_branch:
            visitor.ops = [op, next_branch]
        else:
            visitor.ops = [op]
        visitor.op_index = 0

        op.accept(visitor)
        frags = declarations.fragments + emitter.fragments
        actual_lines = [line.strip(" ") for line in frags]
        assert all(line.endswith("\n") for line in actual_lines)
        actual_lines = [line.rstrip("\n") for line in actual_lines]
        if not expected.strip():
            expected_lines = []
        else:
            expected_lines = expected.rstrip().split("\n")
        expected_lines = [line.strip(" ") for line in expected_lines]
        assert_string_arrays_equal(expected_lines, actual_lines, msg="Generated code unexpected")
        if skip_next:
            assert visitor.op_index == 1
        else:
            assert visitor.op_index == 0
</t>
<t tx="ekr.20240308084832.1949">    def assert_emit_binary_op(
        self, op: str, dest: Value, left: Value, right: Value, expected: str
    ) -&gt; None:
        if op in binary_ops:
            ops = binary_ops[op]
            for desc in ops:
                if is_subtype(left.type, desc.arg_types[0]) and is_subtype(
                    right.type, desc.arg_types[1]
                ):
                    args = [left, right]
                    if desc.ordering is not None:
                        args = [args[i] for i in desc.ordering]
                    self.assert_emit(
                        CallC(
                            desc.c_function_name,
                            args,
                            desc.return_type,
                            desc.steals,
                            desc.is_borrowed,
                            desc.error_kind,
                            55,
                        ),
                        expected,
                    )
                    return
        else:
            assert False, "Could not find matching op"
</t>
<t tx="ekr.20240308084832.195">def non_trivial_sources(op: Op) -&gt; set[Value]:
    result = set()
    for source in op.sources():
        if not isinstance(source, (Integer, Float)):
            result.add(source)
    return result
</t>
<t tx="ekr.20240308084832.1950">class TestGenerateFunction(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1951">def setUp(self) -&gt; None:
    self.arg = RuntimeArg("arg", int_rprimitive)
    self.reg = Register(int_rprimitive, "arg")
    self.block = BasicBlock(0)
</t>
<t tx="ekr.20240308084832.1952">def test_simple(self) -&gt; None:
    self.block.ops.append(Return(self.reg))
    fn = FuncIR(
        FuncDecl("myfunc", None, "mod", FuncSignature([self.arg], int_rprimitive)),
        [self.reg],
        [self.block],
    )
    value_names = generate_names_for_ir(fn.arg_regs, fn.blocks)
    emitter = Emitter(EmitterContext(NameGenerator([["mod"]])), value_names)
    generate_native_function(fn, emitter, "prog.py", "prog")
    result = emitter.fragments
    assert_string_arrays_equal(
        ["CPyTagged CPyDef_myfunc(CPyTagged cpy_r_arg) {\n", "    return cpy_r_arg;\n", "}\n"],
        result,
        msg="Generated code invalid",
    )
</t>
<t tx="ekr.20240308084832.1953">def test_register(self) -&gt; None:
    reg = Register(int_rprimitive)
    op = Assign(reg, Integer(5))
    self.block.ops.append(op)
    self.block.ops.append(Unreachable())
    fn = FuncIR(
        FuncDecl("myfunc", None, "mod", FuncSignature([self.arg], list_rprimitive)),
        [self.reg],
        [self.block],
    )
    value_names = generate_names_for_ir(fn.arg_regs, fn.blocks)
    emitter = Emitter(EmitterContext(NameGenerator([["mod"]])), value_names)
    generate_native_function(fn, emitter, "prog.py", "prog")
    result = emitter.fragments
    assert_string_arrays_equal(
        [
            "PyObject *CPyDef_myfunc(CPyTagged cpy_r_arg) {\n",
            "    CPyTagged cpy_r_r0;\n",
            "    cpy_r_r0 = 10;\n",
            "    CPy_Unreachable();\n",
            "}\n",
        ],
        result,
        msg="Generated code invalid",
    )
</t>
<t tx="ekr.20240308084832.1954">from __future__ import annotations

import unittest

from mypy.test.helpers import assert_string_arrays_equal
from mypyc.codegen.emit import Emitter, EmitterContext, ReturnHandler
from mypyc.codegen.emitwrapper import generate_arg_check
from mypyc.ir.rtypes import int_rprimitive, list_rprimitive
from mypyc.namegen import NameGenerator


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1955">class TestArgCheck(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1956">def setUp(self) -&gt; None:
    self.context = EmitterContext(NameGenerator([["mod"]]))
</t>
<t tx="ekr.20240308084832.1957">def test_check_list(self) -&gt; None:
    emitter = Emitter(self.context)
    generate_arg_check("x", list_rprimitive, emitter, ReturnHandler("NULL"))
    lines = emitter.fragments
    self.assert_lines(
        [
            "PyObject *arg_x;",
            "if (likely(PyList_Check(obj_x)))",
            "    arg_x = obj_x;",
            "else {",
            '    CPy_TypeError("list", obj_x);',
            "    return NULL;",
            "}",
        ],
        lines,
    )
</t>
<t tx="ekr.20240308084832.1958">def test_check_int(self) -&gt; None:
    emitter = Emitter(self.context)
    generate_arg_check("x", int_rprimitive, emitter, ReturnHandler("NULL"))
    generate_arg_check("y", int_rprimitive, emitter, ReturnHandler("NULL"), optional=True)
    lines = emitter.fragments
    self.assert_lines(
        [
            "CPyTagged arg_x;",
            "if (likely(PyLong_Check(obj_x)))",
            "    arg_x = CPyTagged_BorrowFromObject(obj_x);",
            "else {",
            '    CPy_TypeError("int", obj_x); return NULL;',
            "}",
            "CPyTagged arg_y;",
            "if (obj_y == NULL) {",
            "    arg_y = CPY_INT_TAG;",
            "} else if (likely(PyLong_Check(obj_y)))",
            "    arg_y = CPyTagged_BorrowFromObject(obj_y);",
            "else {",
            '    CPy_TypeError("int", obj_y); return NULL;',
            "}",
        ],
        lines,
    )
</t>
<t tx="ekr.20240308084832.1959">def assert_lines(self, expected: list[str], actual: list[str]) -&gt; None:
    actual = [line.rstrip("\n") for line in actual]
    assert_string_arrays_equal(expected, actual, "Invalid output")
</t>
<t tx="ekr.20240308084832.196">class LivenessVisitor(BaseAnalysisVisitor[Value]):
    @others
</t>
<t tx="ekr.20240308084832.1960">"""Test runner for exception handling transform test cases.

The transform inserts exception handling branch operations to IR.
"""

from __future__ import annotations

import os.path

from mypy.errors import CompileError
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypyc.analysis.blockfreq import frequently_executed_blocks
from mypyc.common import TOP_LEVEL_NAME
from mypyc.ir.pprint import format_func
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    MypycDataSuite,
    assert_test_output,
    build_ir_for_single_file,
    remove_comment_lines,
    use_custom_builtins,
)
from mypyc.transform.exceptions import insert_exception_handling
from mypyc.transform.refcount import insert_ref_count_opcodes
from mypyc.transform.uninit import insert_uninit_checks

files = ["exceptions.test", "exceptions-freq.test"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1961">class TestExceptionTransform(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.1962">files = files
base_path = test_temp_dir

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    """Perform a runtime checking transformation test case."""
    with use_custom_builtins(os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase):
        expected_output = remove_comment_lines(testcase.output)
        try:
            ir = build_ir_for_single_file(testcase.input)
        except CompileError as e:
            actual = e.messages
        else:
            actual = []
            for fn in ir:
                if fn.name == TOP_LEVEL_NAME and not testcase.name.endswith("_toplevel"):
                    continue
                insert_uninit_checks(fn)
                insert_exception_handling(fn)
                insert_ref_count_opcodes(fn)
                actual.extend(format_func(fn))
                if testcase.name.endswith("_freq"):
                    common = frequently_executed_blocks(fn.blocks[0])
                    actual.append("hot blocks: %s" % sorted(b.label for b in common))

        assert_test_output(testcase, actual, "Invalid source code output", expected_output)
</t>
<t tx="ekr.20240308084832.1963">"""Test cases that run tests as subprocesses."""

from __future__ import annotations

import os
import subprocess
import sys
import tempfile
import unittest

base_dir = os.path.join(os.path.dirname(__file__), "..", "..")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1964">class TestExternal(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1965"># TODO: Get this to work on Windows.
# (Or don't. It is probably not a good use of time.)
@unittest.skipIf(sys.platform.startswith("win"), "rt tests don't work on windows")
def test_c_unit_test(self) -&gt; None:
    """Run C unit tests in a subprocess."""
    cppflags: list[str] = []
    env = os.environ.copy()
    if sys.platform == "darwin":
        cppflags += ["-mmacosx-version-min=10.10", "-stdlib=libc++"]
    env["CPPFLAGS"] = " ".join(cppflags)
    # Build Python wrapper for C unit tests.

    with tempfile.TemporaryDirectory() as tmpdir:
        status = subprocess.check_call(
            [
                sys.executable,
                "setup.py",
                "build_ext",
                f"--build-lib={tmpdir}",
                f"--build-temp={tmpdir}",
            ],
            env=env,
            cwd=os.path.join(base_dir, "mypyc", "lib-rt"),
        )
        # Run C unit tests.
        env = os.environ.copy()
        if "GTEST_COLOR" not in os.environ:
            env["GTEST_COLOR"] = "yes"  # Use fancy colors
        status = subprocess.call(
            [sys.executable, "-c", "import sys, test_capi; sys.exit(test_capi.run_tests())"],
            env=env,
            cwd=tmpdir,
        )
        if status != 0:
            raise AssertionError("make test: C unit test failure")
</t>
<t tx="ekr.20240308084832.1966">"""Test cases for IR generation."""

from __future__ import annotations

import os.path
import sys

from mypy.errors import CompileError
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypyc.common import TOP_LEVEL_NAME
from mypyc.ir.pprint import format_func
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    MypycDataSuite,
    assert_test_output,
    build_ir_for_single_file,
    infer_ir_build_options_from_test_name,
    remove_comment_lines,
    replace_word_size,
    use_custom_builtins,
)

files = [
    "irbuild-basic.test",
    "irbuild-int.test",
    "irbuild-bool.test",
    "irbuild-lists.test",
    "irbuild-tuple.test",
    "irbuild-dict.test",
    "irbuild-set.test",
    "irbuild-str.test",
    "irbuild-bytes.test",
    "irbuild-float.test",
    "irbuild-statements.test",
    "irbuild-nested.test",
    "irbuild-classes.test",
    "irbuild-optional.test",
    "irbuild-any.test",
    "irbuild-generics.test",
    "irbuild-try.test",
    "irbuild-strip-asserts.test",
    "irbuild-i64.test",
    "irbuild-i32.test",
    "irbuild-i16.test",
    "irbuild-u8.test",
    "irbuild-vectorcall.test",
    "irbuild-unreachable.test",
    "irbuild-isinstance.test",
    "irbuild-dunders.test",
    "irbuild-singledispatch.test",
    "irbuild-constant-fold.test",
    "irbuild-glue-methods.test",
    "irbuild-math.test",
]

if sys.version_info &gt;= (3, 10):
    files.append("irbuild-match.test")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1967">class TestGenOps(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.1968">files = files
base_path = test_temp_dir
optional_out = True

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    """Perform a runtime checking transformation test case."""
    options = infer_ir_build_options_from_test_name(testcase.name)
    if options is None:
        # Skipped test case
        return
    with use_custom_builtins(os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase):
        expected_output = remove_comment_lines(testcase.output)
        expected_output = replace_word_size(expected_output)
        name = testcase.name
        try:
            ir = build_ir_for_single_file(testcase.input, options)
        except CompileError as e:
            actual = e.messages
        else:
            actual = []
            for fn in ir:
                if fn.name == TOP_LEVEL_NAME and not name.endswith("_toplevel"):
                    continue
                actual.extend(format_func(fn))

        assert_test_output(testcase, actual, "Invalid source code output", expected_output)
</t>
<t tx="ekr.20240308084832.1969">from __future__ import annotations

import unittest

from mypyc.analysis.ircheck import FnError, can_coerce_to, check_func_ir
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature
from mypyc.ir.ops import (
    Assign,
    BasicBlock,
    Goto,
    Integer,
    LoadAddress,
    LoadLiteral,
    Op,
    Register,
    Return,
)
from mypyc.ir.pprint import format_func
from mypyc.ir.rtypes import (
    RInstance,
    RType,
    RUnion,
    bytes_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    none_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
    str_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.197">def visit_branch(self, op: Branch) -&gt; GenAndKill[Value]:
    return non_trivial_sources(op), set()
</t>
<t tx="ekr.20240308084832.1970">def assert_has_error(fn: FuncIR, error: FnError) -&gt; None:
    errors = check_func_ir(fn)
    assert errors == [error]
</t>
<t tx="ekr.20240308084832.1971">def assert_no_errors(fn: FuncIR) -&gt; None:
    assert not check_func_ir(fn)
</t>
<t tx="ekr.20240308084832.1972">NONE_VALUE = Integer(0, rtype=none_rprimitive)


class TestIrcheck(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1973">def setUp(self) -&gt; None:
    self.label = 0
</t>
<t tx="ekr.20240308084832.1974">def basic_block(self, ops: list[Op]) -&gt; BasicBlock:
    self.label += 1
    block = BasicBlock(self.label)
    block.ops = ops
    return block
</t>
<t tx="ekr.20240308084832.1975">def func_decl(self, name: str, ret_type: RType | None = None) -&gt; FuncDecl:
    if ret_type is None:
        ret_type = none_rprimitive
    return FuncDecl(
        name=name,
        class_name=None,
        module_name="module",
        sig=FuncSignature(args=[], ret_type=ret_type),
    )
</t>
<t tx="ekr.20240308084832.1976">def test_valid_fn(self) -&gt; None:
    assert_no_errors(
        FuncIR(
            decl=self.func_decl(name="func_1"),
            arg_regs=[],
            blocks=[self.basic_block(ops=[Return(value=NONE_VALUE)])],
        )
    )
</t>
<t tx="ekr.20240308084832.1977">def test_block_not_terminated_empty_block(self) -&gt; None:
    block = self.basic_block([])
    fn = FuncIR(decl=self.func_decl(name="func_1"), arg_regs=[], blocks=[block])
    assert_has_error(fn, FnError(source=block, desc="Block not terminated"))
</t>
<t tx="ekr.20240308084832.1978">def test_valid_goto(self) -&gt; None:
    block_1 = self.basic_block([Return(value=NONE_VALUE)])
    block_2 = self.basic_block([Goto(label=block_1)])
    fn = FuncIR(decl=self.func_decl(name="func_1"), arg_regs=[], blocks=[block_1, block_2])
    assert_no_errors(fn)
</t>
<t tx="ekr.20240308084832.1979">def test_invalid_goto(self) -&gt; None:
    block_1 = self.basic_block([Return(value=NONE_VALUE)])
    goto = Goto(label=block_1)
    block_2 = self.basic_block([goto])
    fn = FuncIR(
        decl=self.func_decl(name="func_1"),
        arg_regs=[],
        # block_1 omitted
        blocks=[block_2],
    )
    assert_has_error(fn, FnError(source=goto, desc="Invalid control operation target: 1"))
</t>
<t tx="ekr.20240308084832.198">def visit_return(self, op: Return) -&gt; GenAndKill[Value]:
    if not isinstance(op.value, (Integer, Float)):
        return {op.value}, set()
    else:
        return set(), set()
</t>
<t tx="ekr.20240308084832.1980">def test_invalid_register_source(self) -&gt; None:
    ret = Return(value=Register(type=none_rprimitive, name="r1"))
    block = self.basic_block([ret])
    fn = FuncIR(decl=self.func_decl(name="func_1"), arg_regs=[], blocks=[block])
    assert_has_error(fn, FnError(source=ret, desc="Invalid op reference to register 'r1'"))
</t>
<t tx="ekr.20240308084832.1981">def test_invalid_op_source(self) -&gt; None:
    ret = Return(value=LoadLiteral(value="foo", rtype=str_rprimitive))
    block = self.basic_block([ret])
    fn = FuncIR(decl=self.func_decl(name="func_1"), arg_regs=[], blocks=[block])
    assert_has_error(
        fn, FnError(source=ret, desc="Invalid op reference to op of type LoadLiteral")
    )
</t>
<t tx="ekr.20240308084832.1982">def test_invalid_return_type(self) -&gt; None:
    ret = Return(value=Integer(value=5, rtype=int32_rprimitive))
    fn = FuncIR(
        decl=self.func_decl(name="func_1", ret_type=int64_rprimitive),
        arg_regs=[],
        blocks=[self.basic_block([ret])],
    )
    assert_has_error(
        fn, FnError(source=ret, desc="Cannot coerce source type i32 to dest type i64")
    )
</t>
<t tx="ekr.20240308084832.1983">def test_invalid_assign(self) -&gt; None:
    arg_reg = Register(type=int64_rprimitive, name="r1")
    assign = Assign(dest=arg_reg, src=Integer(value=5, rtype=int32_rprimitive))
    ret = Return(value=NONE_VALUE)
    fn = FuncIR(
        decl=self.func_decl(name="func_1"),
        arg_regs=[arg_reg],
        blocks=[self.basic_block([assign, ret])],
    )
    assert_has_error(
        fn, FnError(source=assign, desc="Cannot coerce source type i32 to dest type i64")
    )
</t>
<t tx="ekr.20240308084832.1984">def test_can_coerce_to(self) -&gt; None:
    cls = ClassIR(name="Cls", module_name="cls")
    valid_cases = [
        (int64_rprimitive, int64_rprimitive),
        (str_rprimitive, str_rprimitive),
        (str_rprimitive, object_rprimitive),
        (object_rprimitive, str_rprimitive),
        (RUnion([bytes_rprimitive, str_rprimitive]), str_rprimitive),
        (str_rprimitive, RUnion([bytes_rprimitive, str_rprimitive])),
        (RInstance(cls), object_rprimitive),
    ]

    invalid_cases = [
        (int64_rprimitive, int32_rprimitive),
        (RInstance(cls), str_rprimitive),
        (str_rprimitive, bytes_rprimitive),
    ]

    for src, dest in valid_cases:
        assert can_coerce_to(src, dest)
    for src, dest in invalid_cases:
        assert not can_coerce_to(src, dest)
</t>
<t tx="ekr.20240308084832.1985">def test_duplicate_op(self) -&gt; None:
    arg_reg = Register(type=int32_rprimitive, name="r1")
    assign = Assign(dest=arg_reg, src=Integer(value=5, rtype=int32_rprimitive))
    block = self.basic_block([assign, assign, Return(value=NONE_VALUE)])
    fn = FuncIR(decl=self.func_decl(name="func_1"), arg_regs=[], blocks=[block])
    assert_has_error(fn, FnError(source=assign, desc="Func has a duplicate op"))
</t>
<t tx="ekr.20240308084832.1986">def test_pprint(self) -&gt; None:
    block_1 = self.basic_block([Return(value=NONE_VALUE)])
    goto = Goto(label=block_1)
    block_2 = self.basic_block([goto])
    fn = FuncIR(
        decl=self.func_decl(name="func_1"),
        arg_regs=[],
        # block_1 omitted
        blocks=[block_2],
    )
    errors = [(goto, "Invalid control operation target: 1")]
    formatted = format_func(fn, errors)
    assert formatted == [
        "def func_1():",
        "L0:",
        "    goto L1",
        "  ERR: Invalid control operation target: 1",
    ]
</t>
<t tx="ekr.20240308084832.1987">def test_load_address_declares_register(self) -&gt; None:
    rx = Register(str_rprimitive, "x")
    ry = Register(pointer_rprimitive, "y")
    load_addr = LoadAddress(pointer_rprimitive, rx)
    assert_no_errors(
        FuncIR(
            decl=self.func_decl(name="func_1"),
            arg_regs=[],
            blocks=[
                self.basic_block(
                    ops=[load_addr, Assign(ry, load_addr), Return(value=NONE_VALUE)]
                )
            ],
        )
    )
</t>
<t tx="ekr.20240308084832.1988">"""Test code geneneration for literals."""

from __future__ import annotations

import unittest

from mypyc.codegen.literals import (
    Literals,
    _encode_bytes_values,
    _encode_int_values,
    _encode_str_values,
    format_str_literal,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1989">class TestLiterals(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.199">def visit_unreachable(self, op: Unreachable) -&gt; GenAndKill[Value]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.1990">def test_format_str_literal(self) -&gt; None:
    assert format_str_literal("") == b"\x00"
    assert format_str_literal("xyz") == b"\x03xyz"
    assert format_str_literal("x" * 127) == b"\x7f" + b"x" * 127
    assert format_str_literal("x" * 128) == b"\x81\x00" + b"x" * 128
    assert format_str_literal("x" * 131) == b"\x81\x03" + b"x" * 131
</t>
<t tx="ekr.20240308084832.1991">def test_encode_str_values(self) -&gt; None:
    assert _encode_str_values({}) == [b""]
    assert _encode_str_values({"foo": 0}) == [b"\x01\x03foo", b""]
    assert _encode_str_values({"foo": 0, "b": 1}) == [b"\x02\x03foo\x01b", b""]
    assert _encode_str_values({"foo": 0, "x" * 70: 1}) == [
        b"\x01\x03foo",
        bytes([1, 70]) + b"x" * 70,
        b"",
    ]
    assert _encode_str_values({"y" * 100: 0}) == [bytes([1, 100]) + b"y" * 100, b""]
</t>
<t tx="ekr.20240308084832.1992">def test_encode_bytes_values(self) -&gt; None:
    assert _encode_bytes_values({}) == [b""]
    assert _encode_bytes_values({b"foo": 0}) == [b"\x01\x03foo", b""]
    assert _encode_bytes_values({b"foo": 0, b"b": 1}) == [b"\x02\x03foo\x01b", b""]
    assert _encode_bytes_values({b"foo": 0, b"x" * 70: 1}) == [
        b"\x01\x03foo",
        bytes([1, 70]) + b"x" * 70,
        b"",
    ]
    assert _encode_bytes_values({b"y" * 100: 0}) == [bytes([1, 100]) + b"y" * 100, b""]
</t>
<t tx="ekr.20240308084832.1993">def test_encode_int_values(self) -&gt; None:
    assert _encode_int_values({}) == [b""]
    assert _encode_int_values({123: 0}) == [b"\x01123", b""]
    assert _encode_int_values({123: 0, 9: 1}) == [b"\x02123\x009", b""]
    assert _encode_int_values({123: 0, 45: 1, 5 * 10**70: 2}) == [
        b"\x02123\x0045",
        b"\x015" + b"0" * 70,
        b"",
    ]
    assert _encode_int_values({6 * 10**100: 0}) == [b"\x016" + b"0" * 100, b""]
</t>
<t tx="ekr.20240308084832.1994">def test_simple_literal_index(self) -&gt; None:
    lit = Literals()
    lit.record_literal(1)
    lit.record_literal("y")
    lit.record_literal(True)
    lit.record_literal(None)
    lit.record_literal(False)
    assert lit.literal_index(None) == 0
    assert lit.literal_index(False) == 1
    assert lit.literal_index(True) == 2
    assert lit.literal_index("y") == 3
    assert lit.literal_index(1) == 4
</t>
<t tx="ekr.20240308084832.1995">def test_tuple_literal(self) -&gt; None:
    lit = Literals()
    lit.record_literal((1, "y", None, (b"a", "b")))
    lit.record_literal((b"a", "b"))
    lit.record_literal(())
    assert lit.literal_index((b"a", "b")) == 7
    assert lit.literal_index((1, "y", None, (b"a", "b"))) == 8
    assert lit.literal_index(()) == 9
    print(lit.encoded_tuple_values())
    assert lit.encoded_tuple_values() == [
        "3",  # Number of tuples
        "2",
        "5",
        "4",  # First tuple (length=2)
        "4",
        "6",
        "3",
        "0",
        "7",  # Second tuple (length=4)
        "0",  # Third tuple (length=0)
    ]
</t>
<t tx="ekr.20240308084832.1996">from __future__ import annotations

import unittest

from mypyc.namegen import (
    NameGenerator,
    candidate_suffixes,
    exported_name,
    make_module_translation_map,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.1997">class TestNameGen(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.1998">def test_candidate_suffixes(self) -&gt; None:
    assert candidate_suffixes("foo") == ["", "foo."]
    assert candidate_suffixes("foo.bar") == ["", "bar.", "foo.bar."]
</t>
<t tx="ekr.20240308084832.1999">def test_exported_name(self) -&gt; None:
    assert exported_name("foo") == "foo"
    assert exported_name("foo.bar") == "foo___bar"
</t>
<t tx="ekr.20240308084832.20">def get_header_deps(cfiles: list[tuple[str, str]]) -&gt; list[str]:
    """Find all the headers used by a group of cfiles.

    We do this by just regexping the source, which is a bit simpler than
    properly plumbing the data through.

    Arguments:
        cfiles: A list of (file name, file contents) pairs.
    """
    headers: set[str] = set()
    for _, contents in cfiles:
        headers.update(re.findall(r'#include "(.*)"', contents))

    return sorted(headers)
</t>
<t tx="ekr.20240308084832.200">def visit_register_op(self, op: RegisterOp) -&gt; GenAndKill[Value]:
    gen = non_trivial_sources(op)
    if not op.is_void:
        return gen, {op}
    else:
        return gen, set()
</t>
<t tx="ekr.20240308084832.2000">def test_make_module_translation_map(self) -&gt; None:
    assert make_module_translation_map(["foo", "bar"]) == {"foo": "foo.", "bar": "bar."}
    assert make_module_translation_map(["foo.bar", "foo.baz"]) == {
        "foo.bar": "bar.",
        "foo.baz": "baz.",
    }
    assert make_module_translation_map(["zar", "foo.bar", "foo.baz"]) == {
        "foo.bar": "bar.",
        "foo.baz": "baz.",
        "zar": "zar.",
    }
    assert make_module_translation_map(["foo.bar", "fu.bar", "foo.baz"]) == {
        "foo.bar": "foo.bar.",
        "fu.bar": "fu.bar.",
        "foo.baz": "baz.",
    }
</t>
<t tx="ekr.20240308084832.2001">def test_name_generator(self) -&gt; None:
    g = NameGenerator([["foo", "foo.zar"]])
    assert g.private_name("foo", "f") == "foo___f"
    assert g.private_name("foo", "C.x.y") == "foo___C___x___y"
    assert g.private_name("foo", "C.x.y") == "foo___C___x___y"
    assert g.private_name("foo.zar", "C.x.y") == "zar___C___x___y"
    assert g.private_name("foo", "C.x_y") == "foo___C___x_y"
    assert g.private_name("foo", "C_x_y") == "foo___C_x_y"
    assert g.private_name("foo", "C_x_y") == "foo___C_x_y"
    assert g.private_name("foo", "___") == "foo______3_"
</t>
<t tx="ekr.20240308084832.2002">from __future__ import annotations

import unittest

from mypyc.ir.ops import Assign, BasicBlock, Integer, IntOp, Op, Register, Unreachable
from mypyc.ir.pprint import generate_names_for_ir
from mypyc.ir.rtypes import int_rprimitive


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2003">def register(name: str) -&gt; Register:
    return Register(int_rprimitive, "foo", is_arg=True)
</t>
<t tx="ekr.20240308084832.2004">def make_block(ops: list[Op]) -&gt; BasicBlock:
    block = BasicBlock()
    block.ops.extend(ops)
    return block
</t>
<t tx="ekr.20240308084832.2005">class TestGenerateNames(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.2006">def test_empty(self) -&gt; None:
    assert generate_names_for_ir([], []) == {}
</t>
<t tx="ekr.20240308084832.2007">def test_arg(self) -&gt; None:
    reg = register("foo")
    assert generate_names_for_ir([reg], []) == {reg: "foo"}
</t>
<t tx="ekr.20240308084832.2008">def test_int_op(self) -&gt; None:
    n1 = Integer(2)
    n2 = Integer(4)
    op1 = IntOp(int_rprimitive, n1, n2, IntOp.ADD)
    op2 = IntOp(int_rprimitive, op1, n2, IntOp.ADD)
    block = make_block([op1, op2, Unreachable()])
    assert generate_names_for_ir([], [block]) == {op1: "r0", op2: "r1"}
</t>
<t tx="ekr.20240308084832.2009">def test_assign(self) -&gt; None:
    reg = register("foo")
    n = Integer(2)
    op1 = Assign(reg, n)
    op2 = Assign(reg, n)
    block = make_block([op1, op2])
    assert generate_names_for_ir([reg], [block]) == {reg: "foo"}
</t>
<t tx="ekr.20240308084832.201">def visit_assign(self, op: Assign) -&gt; GenAndKill[Value]:
    return non_trivial_sources(op), {op.dest}
</t>
<t tx="ekr.20240308084832.2010">"""Unit tests for RArray types."""

from __future__ import annotations

import unittest

from mypyc.common import PLATFORM_SIZE
from mypyc.ir.rtypes import (
    RArray,
    bool_rprimitive,
    compute_rtype_alignment,
    compute_rtype_size,
    int_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2011">class TestRArray(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.2012">def test_basics(self) -&gt; None:
    a = RArray(int_rprimitive, 10)
    assert a.item_type == int_rprimitive
    assert a.length == 10
</t>
<t tx="ekr.20240308084832.2013">def test_str_conversion(self) -&gt; None:
    a = RArray(int_rprimitive, 10)
    assert str(a) == "int[10]"
    assert repr(a) == "&lt;RArray &lt;RPrimitive builtins.int&gt;[10]&gt;"
</t>
<t tx="ekr.20240308084832.2014">def test_eq(self) -&gt; None:
    a = RArray(int_rprimitive, 10)
    assert a == RArray(int_rprimitive, 10)
    assert a != RArray(bool_rprimitive, 10)
    assert a != RArray(int_rprimitive, 9)
</t>
<t tx="ekr.20240308084832.2015">def test_hash(self) -&gt; None:
    assert hash(RArray(int_rprimitive, 10)) == hash(RArray(int_rprimitive, 10))
    assert hash(RArray(bool_rprimitive, 5)) == hash(RArray(bool_rprimitive, 5))
</t>
<t tx="ekr.20240308084832.2016">def test_alignment(self) -&gt; None:
    a = RArray(int_rprimitive, 10)
    assert compute_rtype_alignment(a) == PLATFORM_SIZE
    b = RArray(bool_rprimitive, 55)
    assert compute_rtype_alignment(b) == 1
</t>
<t tx="ekr.20240308084832.2017">def test_size(self) -&gt; None:
    a = RArray(int_rprimitive, 9)
    assert compute_rtype_size(a) == 9 * PLATFORM_SIZE
    b = RArray(bool_rprimitive, 3)
    assert compute_rtype_size(b) == 3
</t>
<t tx="ekr.20240308084832.2018">"""Test runner for reference count opcode insertion transform test cases.

The transform inserts needed reference count increment/decrement
operations to IR.
"""

from __future__ import annotations

import os.path

from mypy.errors import CompileError
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypyc.common import TOP_LEVEL_NAME
from mypyc.ir.pprint import format_func
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    MypycDataSuite,
    assert_test_output,
    build_ir_for_single_file,
    infer_ir_build_options_from_test_name,
    remove_comment_lines,
    replace_word_size,
    use_custom_builtins,
)
from mypyc.transform.refcount import insert_ref_count_opcodes
from mypyc.transform.uninit import insert_uninit_checks

files = ["refcount.test"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2019">class TestRefCountTransform(MypycDataSuite):
    @others
</t>
<t tx="ekr.20240308084832.202">def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill[Value]:
    return non_trivial_sources(op), {op.dest}
</t>
<t tx="ekr.20240308084832.2020">files = files
base_path = test_temp_dir
optional_out = True

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    """Perform a runtime checking transformation test case."""
    options = infer_ir_build_options_from_test_name(testcase.name)
    if options is None:
        # Skipped test case
        return
    with use_custom_builtins(os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase):
        expected_output = remove_comment_lines(testcase.output)
        expected_output = replace_word_size(expected_output)
        try:
            ir = build_ir_for_single_file(testcase.input, options)
        except CompileError as e:
            actual = e.messages
        else:
            actual = []
            for fn in ir:
                if fn.name == TOP_LEVEL_NAME and not testcase.name.endswith("_toplevel"):
                    continue
                insert_uninit_checks(fn)
                insert_ref_count_opcodes(fn)
                actual.extend(format_func(fn))

        assert_test_output(testcase, actual, "Invalid source code output", expected_output)
</t>
<t tx="ekr.20240308084832.2021">"""Test cases for building an C extension and running it."""

from __future__ import annotations

import ast
import contextlib
import glob
import os.path
import re
import shutil
import subprocess
import sys
import time
from typing import Any, Iterator

from mypy import build
from mypy.errors import CompileError
from mypy.options import TYPE_VAR_TUPLE, UNPACK, Options
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase
from mypy.test.helpers import assert_module_equivalence, perform_file_operations
from mypyc.build import construct_groups
from mypyc.codegen import emitmodule
from mypyc.errors import Errors
from mypyc.options import CompilerOptions
from mypyc.test.test_serialization import check_serialization_roundtrip
from mypyc.test.testutil import (
    ICODE_GEN_BUILTINS,
    TESTUTIL_PATH,
    MypycDataSuite,
    assert_test_output,
    fudge_dir_mtimes,
    show_c,
    use_custom_builtins,
)

files = [
    "run-async.test",
    "run-misc.test",
    "run-functions.test",
    "run-integers.test",
    "run-i64.test",
    "run-i32.test",
    "run-i16.test",
    "run-u8.test",
    "run-floats.test",
    "run-math.test",
    "run-bools.test",
    "run-strings.test",
    "run-bytes.test",
    "run-tuples.test",
    "run-lists.test",
    "run-dicts.test",
    "run-sets.test",
    "run-primitives.test",
    "run-loops.test",
    "run-exceptions.test",
    "run-imports.test",
    "run-classes.test",
    "run-traits.test",
    "run-generators.test",
    "run-multimodule.test",
    "run-bench.test",
    "run-mypy-sim.test",
    "run-dunders.test",
    "run-singledispatch.test",
    "run-attrs.test",
    "run-python37.test",
    "run-python38.test",
]

if sys.version_info &gt;= (3, 10):
    files.append("run-match.test")

setup_format = """\
from setuptools import setup
from mypyc.build import mypycify

setup(name='test_run_output',
      ext_modules=mypycify({}, separate={}, skip_cgen_input={!r}, strip_asserts=False,
                           multi_file={}, opt_level='{}'),
)
"""

WORKDIR = "build"


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2022">def run_setup(script_name: str, script_args: list[str]) -&gt; bool:
    """Run a setup script in a somewhat controlled environment.

    This is adapted from code in distutils and our goal here is that is
    faster to not need to spin up a python interpreter to run it.

    We had to fork it because the real run_setup swallows errors
    and KeyboardInterrupt with no way to recover them (!).
    The real version has some extra features that we removed since
    we weren't using them.

    Returns whether the setup succeeded.
    """
    save_argv = sys.argv.copy()
    g = {"__file__": script_name}
    try:
        try:
            sys.argv[0] = script_name
            sys.argv[1:] = script_args
            with open(script_name, "rb") as f:
                exec(f.read(), g)
        finally:
            sys.argv = save_argv
    except SystemExit as e:
        # distutils converts KeyboardInterrupt into a SystemExit with
        # "interrupted" as the argument. Convert it back so that
        # pytest will exit instead of just failing the test.
        if e.code == "interrupted":
            raise KeyboardInterrupt from e

        return e.code == 0 or e.code is None

    return True
</t>
<t tx="ekr.20240308084832.2023">@contextlib.contextmanager
def chdir_manager(target: str) -&gt; Iterator[None]:
    dir = os.getcwd()
    os.chdir(target)
    try:
        yield
    finally:
        os.chdir(dir)
</t>
<t tx="ekr.20240308084832.2024">class TestRun(MypycDataSuite):
    """Test cases that build a C extension and run code."""
    @others
</t>
<t tx="ekr.20240308084832.2025">files = files
base_path = test_temp_dir
optional_out = True
multi_file = False
separate = False  # If True, using separate (incremental) compilation

def run_case(self, testcase: DataDrivenTestCase) -&gt; None:
    # setup.py wants to be run from the root directory of the package, which we accommodate
    # by chdiring into tmp/
    with use_custom_builtins(
        os.path.join(self.data_prefix, ICODE_GEN_BUILTINS), testcase
    ), chdir_manager("tmp"):
        self.run_case_inner(testcase)
</t>
<t tx="ekr.20240308084832.2026">def run_case_inner(self, testcase: DataDrivenTestCase) -&gt; None:
    if not os.path.isdir(WORKDIR):  # (one test puts something in build...)
        os.mkdir(WORKDIR)

    text = "\n".join(testcase.input)

    with open("native.py", "w", encoding="utf-8") as f:
        f.write(text)
    with open("interpreted.py", "w", encoding="utf-8") as f:
        f.write(text)

    shutil.copyfile(TESTUTIL_PATH, "testutil.py")

    step = 1
    self.run_case_step(testcase, step)

    steps = testcase.find_steps()
    if steps == [[]]:
        steps = []

    for operations in steps:
        # To make sure that any new changes get picked up as being
        # new by distutils, shift the mtime of all of the
        # generated artifacts back by a second.
        fudge_dir_mtimes(WORKDIR, -1)
        # On some OS, changing the mtime doesn't work reliably. As
        # a workaround, sleep.
        # TODO: Figure out a better approach, since this slows down tests.
        time.sleep(1.0)

        step += 1
        with chdir_manager(".."):
            perform_file_operations(operations)
        self.run_case_step(testcase, step)
</t>
<t tx="ekr.20240308084832.2027">def run_case_step(self, testcase: DataDrivenTestCase, incremental_step: int) -&gt; None:
    bench = testcase.config.getoption("--bench", False) and "Benchmark" in testcase.name

    options = Options()
    options.use_builtins_fixtures = True
    options.show_traceback = True
    options.strict_optional = True
    options.python_version = sys.version_info[:2]
    options.export_types = True
    options.preserve_asts = True
    options.allow_empty_bodies = True
    options.incremental = self.separate
    options.enable_incomplete_feature = [TYPE_VAR_TUPLE, UNPACK]

    # Avoid checking modules/packages named 'unchecked', to provide a way
    # to test interacting with code we don't have types for.
    options.per_module_options["unchecked.*"] = {"follow_imports": "error"}

    source = build.BuildSource("native.py", "native", None)
    sources = [source]
    module_names = ["native"]
    module_paths = ["native.py"]

    # Hard code another module name to compile in the same compilation unit.
    to_delete = []
    for fn, text in testcase.files:
        fn = os.path.relpath(fn, test_temp_dir)

        if os.path.basename(fn).startswith("other") and fn.endswith(".py"):
            name = fn.split(".")[0].replace(os.sep, ".")
            module_names.append(name)
            sources.append(build.BuildSource(fn, name, None))
            to_delete.append(fn)
            module_paths.append(fn)

            shutil.copyfile(fn, os.path.join(os.path.dirname(fn), name + "_interpreted.py"))

    for source in sources:
        options.per_module_options.setdefault(source.module, {})["mypyc"] = True

    separate = (
        self.get_separate("\n".join(testcase.input), incremental_step)
        if self.separate
        else False
    )

    groups = construct_groups(sources, separate, len(module_names) &gt; 1)

    try:
        compiler_options = CompilerOptions(multi_file=self.multi_file, separate=self.separate)
        result = emitmodule.parse_and_typecheck(
            sources=sources,
            options=options,
            compiler_options=compiler_options,
            groups=groups,
            alt_lib_path=".",
        )
        errors = Errors(options)
        ir, cfiles = emitmodule.compile_modules_to_c(
            result, compiler_options=compiler_options, errors=errors, groups=groups
        )
        if errors.num_errors:
            errors.flush_errors()
            assert False, "Compile error"
    except CompileError as e:
        for line in e.messages:
            print(fix_native_line_number(line, testcase.file, testcase.line))
        assert False, "Compile error"

    # Check that serialization works on this IR. (Only on the first
    # step because the returned ir only includes updated code.)
    if incremental_step == 1:
        check_serialization_roundtrip(ir)

    opt_level = int(os.environ.get("MYPYC_OPT_LEVEL", 0))
    debug_level = int(os.environ.get("MYPYC_DEBUG_LEVEL", 0))

    setup_file = os.path.abspath(os.path.join(WORKDIR, "setup.py"))
    # We pass the C file information to the build script via setup.py unfortunately
    with open(setup_file, "w", encoding="utf-8") as f:
        f.write(
            setup_format.format(
                module_paths, separate, cfiles, self.multi_file, opt_level, debug_level
            )
        )

    if not run_setup(setup_file, ["build_ext", "--inplace"]):
        if testcase.config.getoption("--mypyc-showc"):
            show_c(cfiles)
        assert False, "Compilation failed"

    # Assert that an output file got created
    suffix = "pyd" if sys.platform == "win32" else "so"
    assert glob.glob(f"native.*.{suffix}") or glob.glob(f"native.{suffix}")

    driver_path = "driver.py"
    if not os.path.isfile(driver_path):
        # No driver.py provided by test case. Use the default one
        # (test-data/driver/driver.py) that calls each
        # function named test_*.
        default_driver = os.path.join(
            os.path.dirname(__file__), "..", "test-data", "driver", "driver.py"
        )
        shutil.copy(default_driver, driver_path)
    env = os.environ.copy()
    env["MYPYC_RUN_BENCH"] = "1" if bench else "0"

    debugger = testcase.config.getoption("debugger")
    if debugger:
        if debugger == "lldb":
            subprocess.check_call(["lldb", "--", sys.executable, driver_path], env=env)
        elif debugger == "gdb":
            subprocess.check_call(["gdb", "--args", sys.executable, driver_path], env=env)
        else:
            assert False, "Unsupported debugger"
        # TODO: find a way to automatically disable capturing
        # stdin/stdout when in debugging mode
        assert False, (
            "Test can't pass in debugging mode. "
            "(Make sure to pass -s to pytest to interact with the debugger)"
        )
    proc = subprocess.Popen(
        [sys.executable, driver_path],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        env=env,
    )
    if sys.version_info &gt;= (3, 12):
        # TODO: testDecorators1 hangs on 3.12, remove this once fixed
        proc.wait(timeout=30)
    output = proc.communicate()[0].decode("utf8")
    outlines = output.splitlines()

    if testcase.config.getoption("--mypyc-showc"):
        show_c(cfiles)
    if proc.returncode != 0:
        print()
        print("*** Exit status: %d" % proc.returncode)

    # Verify output.
    if bench:
        print("Test output:")
        print(output)
    else:
        if incremental_step == 1:
            msg = "Invalid output"
            expected = testcase.output
        else:
            msg = f"Invalid output (step {incremental_step})"
            expected = testcase.output2.get(incremental_step, [])

        if not expected:
            # Tweak some line numbers, but only if the expected output is empty,
            # as tweaked output might not match expected output.
            outlines = [
                fix_native_line_number(line, testcase.file, testcase.line) for line in outlines
            ]
        assert_test_output(testcase, outlines, msg, expected)

    if incremental_step &gt; 1 and options.incremental:
        suffix = "" if incremental_step == 2 else str(incremental_step - 1)
        expected_rechecked = testcase.expected_rechecked_modules.get(incremental_step - 1)
        if expected_rechecked is not None:
            assert_module_equivalence(
                "rechecked" + suffix, expected_rechecked, result.manager.rechecked_modules
            )
        expected_stale = testcase.expected_stale_modules.get(incremental_step - 1)
        if expected_stale is not None:
            assert_module_equivalence(
                "stale" + suffix, expected_stale, result.manager.stale_modules
            )

    assert proc.returncode == 0
</t>
<t tx="ekr.20240308084832.2028">def get_separate(self, program_text: str, incremental_step: int) -&gt; Any:
    template = r"# separate{}: (\[.*\])$"
    m = re.search(template.format(incremental_step), program_text, flags=re.MULTILINE)
    if not m:
        m = re.search(template.format(""), program_text, flags=re.MULTILINE)
    if m:
        return ast.literal_eval(m.group(1))
    else:
        return True
</t>
<t tx="ekr.20240308084832.2029">class TestRunMultiFile(TestRun):
    """Run the main multi-module tests in multi-file compilation mode.

    In multi-file mode each module gets compiled into a separate C file,
    but all modules (C files) are compiled together.
    """

    multi_file = True
    test_name_suffix = "_multi"
    files = ["run-multimodule.test", "run-mypy-sim.test"]
</t>
<t tx="ekr.20240308084832.203">def visit_set_mem(self, op: SetMem) -&gt; GenAndKill[Value]:
    return non_trivial_sources(op), set()
</t>
<t tx="ekr.20240308084832.2030">class TestRunSeparate(TestRun):
    """Run the main multi-module tests in separate compilation mode.

    In this mode there are multiple compilation groups, which are compiled
    incrementally. Each group is compiled to a separate C file, and these C
    files are compiled separately.

    Each compiled module is placed into a separate compilation group, unless
    overridden by a special comment. Consider this example:

      # separate: [(["other.py", "other_b.py"], "stuff")]

    This puts other.py and other_b.py into a compilation group named "stuff".
    Any files not mentioned in the comment will get single-file groups.
    """

    separate = True
    test_name_suffix = "_separate"
    files = ["run-multimodule.test", "run-mypy-sim.test"]
</t>
<t tx="ekr.20240308084832.2031">def fix_native_line_number(message: str, fnam: str, delta: int) -&gt; str:
    """Update code locations in test case output to point to the .test file.

    The description of the test case is written to native.py, and line numbers
    in test case output often are relative to native.py. This translates the
    line numbers to be relative to the .test file that contains the test case
    description, and also updates the file name to the .test file name.

    Args:
        message: message to update
        fnam: path of the .test file
        delta: line number of the beginning of the test case in the .test file

    Returns updated message (or original message if we couldn't find anything).
    """
    fnam = os.path.basename(fnam)
    message = re.sub(
        r"native\.py:([0-9]+):", lambda m: "%s:%d:" % (fnam, int(m.group(1)) + delta), message
    )
    message = re.sub(
        r'"native.py", line ([0-9]+),',
        lambda m: '"%s", line %d,' % (fnam, int(m.group(1)) + delta),
        message,
    )
    return message
</t>
<t tx="ekr.20240308084832.2032">"""Functions to check that serialization round-tripped properly."""

# This file is named test_serialization.py even though it doesn't
# contain its own tests so that pytest will rewrite the asserts...

from __future__ import annotations

from collections.abc import Iterable
from typing import Any

from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature
from mypyc.ir.module_ir import ModuleIR, deserialize_modules
from mypyc.ir.ops import DeserMaps
from mypyc.ir.rtypes import RType
from mypyc.sametype import is_same_signature, is_same_type


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2033">def get_dict(x: Any) -&gt; dict[str, Any]:
    if hasattr(x, "__mypyc_attrs__"):
        return {k: getattr(x, k) for k in x.__mypyc_attrs__ if hasattr(x, k)}
    else:
        return dict(x.__dict__)
</t>
<t tx="ekr.20240308084832.2034">def get_function_dict(x: FuncIR) -&gt; dict[str, Any]:
    """Get a dict of function attributes safe to compare across serialization"""
    d = get_dict(x)
    d.pop("blocks", None)
    d.pop("env", None)
    return d
</t>
<t tx="ekr.20240308084832.2035">def assert_blobs_same(x: Any, y: Any, trail: tuple[Any, ...]) -&gt; None:
    """Compare two blobs of IR as best we can.

    FuncDecls, FuncIRs, and ClassIRs are compared by fullname to avoid
    infinite recursion.
    (More detailed comparisons should be done manually.)

    Types and signatures are compared using mypyc.sametype.

    Containers are compared recursively.

    Anything else is compared with ==.

    The `trail` argument is used in error messages.
    """

    assert type(x) is type(y), (f"Type mismatch at {trail}", type(x), type(y))
    if isinstance(x, (FuncDecl, FuncIR, ClassIR)):
        assert x.fullname == y.fullname, f"Name mismatch at {trail}"
    elif isinstance(x, dict):
        assert len(x.keys()) == len(y.keys()), f"Keys mismatch at {trail}"
        for (xk, xv), (yk, yv) in zip(x.items(), y.items()):
            assert_blobs_same(xk, yk, trail + ("keys",))
            assert_blobs_same(xv, yv, trail + (xk,))
    elif isinstance(x, dict):
        assert x.keys() == y.keys(), f"Keys mismatch at {trail}"
        for k in x.keys():
            assert_blobs_same(x[k], y[k], trail + (k,))
    elif isinstance(x, Iterable) and not isinstance(x, (str, set)):
        # Special case iterables to generate better assert error messages.
        # We can't use this for sets since the ordering is unpredictable,
        # and strings should be treated as atomic values.
        for i, (xv, yv) in enumerate(zip(x, y)):
            assert_blobs_same(xv, yv, trail + (i,))
    elif isinstance(x, RType):
        assert is_same_type(x, y), f"RType mismatch at {trail}"
    elif isinstance(x, FuncSignature):
        assert is_same_signature(x, y), f"Signature mismatch at {trail}"
    else:
        assert x == y, f"Value mismatch at {trail}"
</t>
<t tx="ekr.20240308084832.2036">def assert_modules_same(ir1: ModuleIR, ir2: ModuleIR) -&gt; None:
    """Assert that two module IRs are the same (*).

    * Or rather, as much as we care about preserving across
    serialization.  We drop the actual IR bodies of functions but try
    to preserve everything else.
    """
    assert ir1.fullname == ir2.fullname

    assert ir1.imports == ir2.imports

    for cls1, cls2 in zip(ir1.classes, ir2.classes):
        assert_blobs_same(get_dict(cls1), get_dict(cls2), (ir1.fullname, cls1.fullname))

    for fn1, fn2 in zip(ir1.functions, ir2.functions):
        assert_blobs_same(
            get_function_dict(fn1), get_function_dict(fn2), (ir1.fullname, fn1.fullname)
        )
        assert_blobs_same(get_dict(fn1.decl), get_dict(fn2.decl), (ir1.fullname, fn1.fullname))

    assert_blobs_same(ir1.final_names, ir2.final_names, (ir1.fullname, "final_names"))
</t>
<t tx="ekr.20240308084832.2037">def check_serialization_roundtrip(irs: dict[str, ModuleIR]) -&gt; None:
    """Check that we can serialize modules out and deserialize them to the same thing."""
    serialized = {k: ir.serialize() for k, ir in irs.items()}

    ctx = DeserMaps({}, {})
    irs2 = deserialize_modules(serialized, ctx)
    assert irs.keys() == irs2.keys()

    for k in irs:
        assert_modules_same(irs[k], irs2[k])
</t>
<t tx="ekr.20240308084832.2038">from __future__ import annotations

import unittest

from mypyc.ir.rtypes import (
    RStruct,
    bool_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    object_rprimitive,
)
from mypyc.rt_subtype import is_runtime_subtype


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2039">class TestStruct(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.204">def analyze_live_regs(blocks: list[BasicBlock], cfg: CFG) -&gt; AnalysisResult[Value]:
    """Calculate live registers at each CFG location.

    A register is live at a location if it can be read along some CFG path starting
    from the location.
    """
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=LivenessVisitor(),
        initial=set(),
        backward=True,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.2040">def test_struct_offsets(self) -&gt; None:
    # test per-member alignment
    r = RStruct("", [], [bool_rprimitive, int32_rprimitive, int64_rprimitive])
    assert r.size == 16
    assert r.offsets == [0, 4, 8]

    # test final alignment
    r1 = RStruct("", [], [bool_rprimitive, bool_rprimitive])
    assert r1.size == 2
    assert r1.offsets == [0, 1]
    r2 = RStruct("", [], [int32_rprimitive, bool_rprimitive])
    r3 = RStruct("", [], [int64_rprimitive, bool_rprimitive])
    assert r2.offsets == [0, 4]
    assert r3.offsets == [0, 8]
    assert r2.size == 8
    assert r3.size == 16

    r4 = RStruct("", [], [bool_rprimitive, bool_rprimitive, bool_rprimitive, int32_rprimitive])
    assert r4.size == 8
    assert r4.offsets == [0, 1, 2, 4]

    # test nested struct
    r5 = RStruct("", [], [bool_rprimitive, r])
    assert r5.offsets == [0, 8]
    assert r5.size == 24
    r6 = RStruct("", [], [int32_rprimitive, r5])
    assert r6.offsets == [0, 8]
    assert r6.size == 32
    # test nested struct with alignment less than 8
    r7 = RStruct("", [], [bool_rprimitive, r4])
    assert r7.offsets == [0, 4]
    assert r7.size == 12
</t>
<t tx="ekr.20240308084832.2041">def test_struct_str(self) -&gt; None:
    r = RStruct("Foo", ["a", "b"], [bool_rprimitive, object_rprimitive])
    assert str(r) == "Foo{a:bool, b:object}"
    assert (
        repr(r) == "&lt;RStruct Foo{a:&lt;RPrimitive builtins.bool&gt;, "
        "b:&lt;RPrimitive builtins.object&gt;}&gt;"
    )
    r1 = RStruct("Bar", ["c"], [int32_rprimitive])
    assert str(r1) == "Bar{c:i32}"
    assert repr(r1) == "&lt;RStruct Bar{c:&lt;RPrimitive i32&gt;}&gt;"
    r2 = RStruct("Baz", [], [])
    assert str(r2) == "Baz{}"
    assert repr(r2) == "&lt;RStruct Baz{}&gt;"
</t>
<t tx="ekr.20240308084832.2042">def test_runtime_subtype(self) -&gt; None:
    # right type to check with
    r = RStruct("Foo", ["a", "b"], [bool_rprimitive, int_rprimitive])

    # using the exact same fields
    r1 = RStruct("Foo", ["a", "b"], [bool_rprimitive, int_rprimitive])

    # names different
    r2 = RStruct("Bar", ["c", "b"], [bool_rprimitive, int_rprimitive])

    # name different
    r3 = RStruct("Baz", ["a", "b"], [bool_rprimitive, int_rprimitive])

    # type different
    r4 = RStruct("FooBar", ["a", "b"], [bool_rprimitive, int32_rprimitive])

    # number of types different
    r5 = RStruct(
        "FooBarBaz", ["a", "b", "c"], [bool_rprimitive, int_rprimitive, bool_rprimitive]
    )

    assert is_runtime_subtype(r1, r) is True
    assert is_runtime_subtype(r2, r) is False
    assert is_runtime_subtype(r3, r) is False
    assert is_runtime_subtype(r4, r) is False
    assert is_runtime_subtype(r5, r) is False
</t>
<t tx="ekr.20240308084832.2043">def test_eq_and_hash(self) -&gt; None:
    r = RStruct("Foo", ["a", "b"], [bool_rprimitive, int_rprimitive])

    # using the exact same fields
    r1 = RStruct("Foo", ["a", "b"], [bool_rprimitive, int_rprimitive])
    assert hash(r) == hash(r1)
    assert r == r1

    # different name
    r2 = RStruct("Foq", ["a", "b"], [bool_rprimitive, int_rprimitive])
    assert hash(r) != hash(r2)
    assert r != r2

    # different names
    r3 = RStruct("Foo", ["a", "c"], [bool_rprimitive, int_rprimitive])
    assert hash(r) != hash(r3)
    assert r != r3

    # different type
    r4 = RStruct("Foo", ["a", "b"], [bool_rprimitive, int_rprimitive, bool_rprimitive])
    assert hash(r) != hash(r4)
    assert r != r4
</t>
<t tx="ekr.20240308084832.2044">from __future__ import annotations

import unittest

from mypyc.ir.class_ir import ClassIR
from mypyc.ir.rtypes import (
    RInstance,
    RTuple,
    RUnion,
    bool_rprimitive,
    int_rprimitive,
    list_rprimitive,
    object_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2045">class TestTupleNames(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.2046">def setUp(self) -&gt; None:
    self.inst_a = RInstance(ClassIR("A", "__main__"))
    self.inst_b = RInstance(ClassIR("B", "__main__"))
</t>
<t tx="ekr.20240308084832.2047">def test_names(self) -&gt; None:
    assert RTuple([int_rprimitive, int_rprimitive]).unique_id == "T2II"
    assert RTuple([list_rprimitive, object_rprimitive, self.inst_a]).unique_id == "T3OOO"
    assert RTuple([list_rprimitive, object_rprimitive, self.inst_b]).unique_id == "T3OOO"
    assert RTuple([]).unique_id == "T0"
    assert (
        RTuple([RTuple([]), RTuple([int_rprimitive, int_rprimitive])]).unique_id == "T2T0T2II"
    )
    assert (
        RTuple([bool_rprimitive, RUnion([bool_rprimitive, int_rprimitive])]).unique_id
        == "T2CO"
    )
</t>
<t tx="ekr.20240308084832.2048">"""Test cases for various RType operations."""

from __future__ import annotations

import unittest

from mypyc.ir.rtypes import (
    RUnion,
    bit_rprimitive,
    bool_rprimitive,
    int16_rprimitive,
    int32_rprimitive,
    int64_rprimitive,
    int_rprimitive,
    object_rprimitive,
    short_int_rprimitive,
    str_rprimitive,
)
from mypyc.rt_subtype import is_runtime_subtype
from mypyc.subtype import is_subtype

native_int_types = [int64_rprimitive, int32_rprimitive, int16_rprimitive]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2049">class TestSubtype(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.205"># Analysis kinds
MUST_ANALYSIS = 0
MAYBE_ANALYSIS = 1


def run_analysis(
    blocks: list[BasicBlock],
    cfg: CFG,
    gen_and_kill: OpVisitor[GenAndKill[T]],
    initial: set[T],
    kind: int,
    backward: bool,
    universe: set[T] | None = None,
) -&gt; AnalysisResult[T]:
    """Run a general set-based data flow analysis.

    Args:
        blocks: All basic blocks
        cfg: Control-flow graph for the code
        gen_and_kill: Implementation of gen and kill functions for each op
        initial: Value of analysis for the entry points (for a forward analysis) or the
            exit points (for a backward analysis)
        kind: MUST_ANALYSIS or MAYBE_ANALYSIS
        backward: If False, the analysis is a forward analysis; it's backward otherwise
        universe: For a must analysis, the set of all possible values. This is the starting
            value for the work list algorithm, which will narrow this down until reaching a
            fixed point. For a maybe analysis the iteration always starts from an empty set
            and this argument is ignored.

    Return analysis results: (before, after)
    """
    block_gen = {}
    block_kill = {}

    # Calculate kill and gen sets for entire basic blocks.
    for block in blocks:
        gen: set[T] = set()
        kill: set[T] = set()
        ops = block.ops
        if backward:
            ops = list(reversed(ops))
        for op in ops:
            opgen, opkill = op.accept(gen_and_kill)
            gen = (gen - opkill) | opgen
            kill = (kill - opgen) | opkill
        block_gen[block] = gen
        block_kill[block] = kill

    # Set up initial state for worklist algorithm.
    worklist = list(blocks)
    if not backward:
        worklist = worklist[::-1]  # Reverse for a small performance improvement
    workset = set(worklist)
    before: dict[BasicBlock, set[T]] = {}
    after: dict[BasicBlock, set[T]] = {}
    for block in blocks:
        if kind == MAYBE_ANALYSIS:
            before[block] = set()
            after[block] = set()
        else:
            assert universe is not None, "Universe must be defined for a must analysis"
            before[block] = set(universe)
            after[block] = set(universe)

    if backward:
        pred_map = cfg.succ
        succ_map = cfg.pred
    else:
        pred_map = cfg.pred
        succ_map = cfg.succ

    # Run work list algorithm to generate in and out sets for each basic block.
    while worklist:
        label = worklist.pop()
        workset.remove(label)
        if pred_map[label]:
            new_before: set[T] | None = None
            for pred in pred_map[label]:
                if new_before is None:
                    new_before = set(after[pred])
                elif kind == MAYBE_ANALYSIS:
                    new_before |= after[pred]
                else:
                    new_before &amp;= after[pred]
            assert new_before is not None
        else:
            new_before = set(initial)
        before[label] = new_before
        new_after = (new_before - block_kill[label]) | block_gen[label]
        if new_after != after[label]:
            for succ in succ_map[label]:
                if succ not in workset:
                    worklist.append(succ)
                    workset.add(succ)
        after[label] = new_after

    # Run algorithm for each basic block to generate opcode-level sets.
    op_before: dict[tuple[BasicBlock, int], set[T]] = {}
    op_after: dict[tuple[BasicBlock, int], set[T]] = {}
    for block in blocks:
        label = block
        cur = before[label]
        ops_enum: Iterator[tuple[int, Op]] = enumerate(block.ops)
        if backward:
            ops_enum = reversed(list(ops_enum))
        for idx, op in ops_enum:
            op_before[label, idx] = cur
            opgen, opkill = op.accept(gen_and_kill)
            cur = (cur - opkill) | opgen
            op_after[label, idx] = cur
    if backward:
        op_after, op_before = op_before, op_after

    return AnalysisResult(op_before, op_after)
</t>
<t tx="ekr.20240308084832.2050">def test_bit(self) -&gt; None:
    assert is_subtype(bit_rprimitive, bool_rprimitive)
    assert is_subtype(bit_rprimitive, int_rprimitive)
    assert is_subtype(bit_rprimitive, short_int_rprimitive)
    for rt in native_int_types:
        assert is_subtype(bit_rprimitive, rt)
</t>
<t tx="ekr.20240308084832.2051">def test_bool(self) -&gt; None:
    assert not is_subtype(bool_rprimitive, bit_rprimitive)
    assert is_subtype(bool_rprimitive, int_rprimitive)
    assert is_subtype(bool_rprimitive, short_int_rprimitive)
    for rt in native_int_types:
        assert is_subtype(bool_rprimitive, rt)
</t>
<t tx="ekr.20240308084832.2052">def test_int64(self) -&gt; None:
    assert is_subtype(int64_rprimitive, int64_rprimitive)
    assert is_subtype(int64_rprimitive, int_rprimitive)
    assert not is_subtype(int64_rprimitive, short_int_rprimitive)
    assert not is_subtype(int64_rprimitive, int32_rprimitive)
    assert not is_subtype(int64_rprimitive, int16_rprimitive)
</t>
<t tx="ekr.20240308084832.2053">def test_int32(self) -&gt; None:
    assert is_subtype(int32_rprimitive, int32_rprimitive)
    assert is_subtype(int32_rprimitive, int_rprimitive)
    assert not is_subtype(int32_rprimitive, short_int_rprimitive)
    assert not is_subtype(int32_rprimitive, int64_rprimitive)
    assert not is_subtype(int32_rprimitive, int16_rprimitive)
</t>
<t tx="ekr.20240308084832.2054">def test_int16(self) -&gt; None:
    assert is_subtype(int16_rprimitive, int16_rprimitive)
    assert is_subtype(int16_rprimitive, int_rprimitive)
    assert not is_subtype(int16_rprimitive, short_int_rprimitive)
    assert not is_subtype(int16_rprimitive, int64_rprimitive)
    assert not is_subtype(int16_rprimitive, int32_rprimitive)
</t>
<t tx="ekr.20240308084832.2055">class TestRuntimeSubtype(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.2056">def test_bit(self) -&gt; None:
    assert is_runtime_subtype(bit_rprimitive, bool_rprimitive)
    assert not is_runtime_subtype(bit_rprimitive, int_rprimitive)
</t>
<t tx="ekr.20240308084832.2057">def test_bool(self) -&gt; None:
    assert not is_runtime_subtype(bool_rprimitive, bit_rprimitive)
    assert not is_runtime_subtype(bool_rprimitive, int_rprimitive)
</t>
<t tx="ekr.20240308084832.2058">def test_union(self) -&gt; None:
    bool_int_mix = RUnion([bool_rprimitive, int_rprimitive])
    assert not is_runtime_subtype(bool_int_mix, short_int_rprimitive)
    assert not is_runtime_subtype(bool_int_mix, int_rprimitive)
    assert not is_runtime_subtype(short_int_rprimitive, bool_int_mix)
    assert not is_runtime_subtype(int_rprimitive, bool_int_mix)
</t>
<t tx="ekr.20240308084832.2059">class TestUnionSimplification(unittest.TestCase):
    @others
</t>
<t tx="ekr.20240308084832.206">"""Utilities for checking that internal ir is valid and consistent."""
from __future__ import annotations

from mypyc.ir.func_ir import FUNC_STATICMETHOD, FuncIR
from mypyc.ir.ops import (
    Assign,
    AssignMulti,
    BaseAssign,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    ControlOp,
    DecRef,
    Extend,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    IncRef,
    InitStatic,
    Integer,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadGlobal,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    Op,
    OpVisitor,
    RaiseStandardError,
    Register,
    Return,
    SetAttr,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unborrow,
    Unbox,
    Unreachable,
    Value,
)
from mypyc.ir.pprint import format_func
from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RPrimitive,
    RType,
    RUnion,
    bytes_rprimitive,
    dict_rprimitive,
    int_rprimitive,
    is_float_rprimitive,
    is_object_rprimitive,
    list_rprimitive,
    range_rprimitive,
    set_rprimitive,
    str_rprimitive,
    tuple_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2060">def test_simple_type_result(self) -&gt; None:
    assert RUnion.make_simplified_union([int_rprimitive]) == int_rprimitive
</t>
<t tx="ekr.20240308084832.2061">def test_remove_duplicate(self) -&gt; None:
    assert RUnion.make_simplified_union([int_rprimitive, int_rprimitive]) == int_rprimitive
</t>
<t tx="ekr.20240308084832.2062">def test_cannot_simplify(self) -&gt; None:
    assert RUnion.make_simplified_union(
        [int_rprimitive, str_rprimitive, object_rprimitive]
    ) == RUnion([int_rprimitive, str_rprimitive, object_rprimitive])
</t>
<t tx="ekr.20240308084832.2063">def test_nested(self) -&gt; None:
    assert RUnion.make_simplified_union(
        [int_rprimitive, RUnion([str_rprimitive, int_rprimitive])]
    ) == RUnion([int_rprimitive, str_rprimitive])
    assert RUnion.make_simplified_union(
        [int_rprimitive, RUnion([str_rprimitive, RUnion([int_rprimitive])])]
    ) == RUnion([int_rprimitive, str_rprimitive])
</t>
<t tx="ekr.20240308084832.2064">"""Helpers for writing tests"""

from __future__ import annotations

import contextlib
import os
import os.path
import re
import shutil
from typing import Callable, Iterator

from mypy import build
from mypy.errors import CompileError
from mypy.options import Options
from mypy.test.config import test_temp_dir
from mypy.test.data import DataDrivenTestCase, DataSuite
from mypy.test.helpers import assert_string_arrays_equal
from mypyc.analysis.ircheck import assert_func_ir_valid
from mypyc.common import IS_32_BIT_PLATFORM, PLATFORM_SIZE
from mypyc.errors import Errors
from mypyc.ir.func_ir import FuncIR
from mypyc.ir.module_ir import ModuleIR
from mypyc.irbuild.main import build_ir
from mypyc.irbuild.mapper import Mapper
from mypyc.options import CompilerOptions
from mypyc.test.config import test_data_prefix

# The builtins stub used during icode generation test cases.
ICODE_GEN_BUILTINS = os.path.join(test_data_prefix, "fixtures/ir.py")
# The testutil support library
TESTUTIL_PATH = os.path.join(test_data_prefix, "fixtures/testutil.py")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2065">class MypycDataSuite(DataSuite):
    # Need to list no files, since this will be picked up as a suite of tests
    files: list[str] = []
    data_prefix = test_data_prefix
</t>
<t tx="ekr.20240308084832.2066">def builtins_wrapper(
    func: Callable[[DataDrivenTestCase], None], path: str
) -&gt; Callable[[DataDrivenTestCase], None]:
    """Decorate a function that implements a data-driven test case to copy an
    alternative builtins module implementation in place before performing the
    test case. Clean up after executing the test case.
    """
    return lambda testcase: perform_test(func, path, testcase)
</t>
<t tx="ekr.20240308084832.2067">@contextlib.contextmanager
def use_custom_builtins(builtins_path: str, testcase: DataDrivenTestCase) -&gt; Iterator[None]:
    for path, _ in testcase.files:
        if os.path.basename(path) == "builtins.pyi":
            default_builtins = False
            break
    else:
        # Use default builtins.
        builtins = os.path.abspath(os.path.join(test_temp_dir, "builtins.pyi"))
        shutil.copyfile(builtins_path, builtins)
        default_builtins = True

    # Actually perform the test case.
    try:
        yield None
    finally:
        if default_builtins:
            # Clean up.
            os.remove(builtins)
</t>
<t tx="ekr.20240308084832.2068">def perform_test(
    func: Callable[[DataDrivenTestCase], None], builtins_path: str, testcase: DataDrivenTestCase
) -&gt; None:
    for path, _ in testcase.files:
        if os.path.basename(path) == "builtins.py":
            default_builtins = False
            break
    else:
        # Use default builtins.
        builtins = os.path.join(test_temp_dir, "builtins.py")
        shutil.copyfile(builtins_path, builtins)
        default_builtins = True

    # Actually perform the test case.
    func(testcase)

    if default_builtins:
        # Clean up.
        os.remove(builtins)
</t>
<t tx="ekr.20240308084832.2069">def build_ir_for_single_file(
    input_lines: list[str], compiler_options: CompilerOptions | None = None
) -&gt; list[FuncIR]:
    return build_ir_for_single_file2(input_lines, compiler_options).functions
</t>
<t tx="ekr.20240308084832.207">class FnError:
    @others
</t>
<t tx="ekr.20240308084832.2070">def build_ir_for_single_file2(
    input_lines: list[str], compiler_options: CompilerOptions | None = None
) -&gt; ModuleIR:
    program_text = "\n".join(input_lines)

    # By default generate IR compatible with the earliest supported Python C API.
    # If a test needs more recent API features, this should be overridden.
    compiler_options = compiler_options or CompilerOptions(capi_version=(3, 7))
    options = Options()
    options.show_traceback = True
    options.hide_error_codes = True
    options.use_builtins_fixtures = True
    options.strict_optional = True
    options.python_version = compiler_options.python_version or (3, 6)
    options.export_types = True
    options.preserve_asts = True
    options.allow_empty_bodies = True
    options.per_module_options["__main__"] = {"mypyc": True}

    source = build.BuildSource("main", "__main__", program_text)
    # Construct input as a single single.
    # Parse and type check the input program.
    result = build.build(sources=[source], options=options, alt_lib_path=test_temp_dir)
    if result.errors:
        raise CompileError(result.errors)

    errors = Errors(options)
    modules = build_ir(
        [result.files["__main__"]],
        result.graph,
        result.types,
        Mapper({"__main__": None}),
        compiler_options,
        errors,
    )
    if errors.num_errors:
        raise CompileError(errors.new_messages())

    module = list(modules.values())[0]
    for fn in module.functions:
        assert_func_ir_valid(fn)
    return module
</t>
<t tx="ekr.20240308084832.2071">def update_testcase_output(testcase: DataDrivenTestCase, output: list[str]) -&gt; None:
    # TODO: backport this to mypy
    assert testcase.old_cwd is not None, "test was not properly set up"
    testcase_path = os.path.join(testcase.old_cwd, testcase.file)
    with open(testcase_path) as f:
        data_lines = f.read().splitlines()

    # We can't rely on the test line numbers to *find* the test, since
    # we might fix multiple tests in a run. So find it by the case
    # header. Give up if there are multiple tests with the same name.
    test_slug = f"[case {testcase.name}]"
    if data_lines.count(test_slug) != 1:
        return
    start_idx = data_lines.index(test_slug)
    stop_idx = start_idx + 11
    while stop_idx &lt; len(data_lines) and not data_lines[stop_idx].startswith("[case "):
        stop_idx += 1

    test = data_lines[start_idx:stop_idx]
    out_start = test.index("[out]")
    test[out_start + 1 :] = output
    data_lines[start_idx:stop_idx] = test + [""]
    data = "\n".join(data_lines)

    with open(testcase_path, "w") as f:
        print(data, file=f)
</t>
<t tx="ekr.20240308084832.2072">def assert_test_output(
    testcase: DataDrivenTestCase,
    actual: list[str],
    message: str,
    expected: list[str] | None = None,
    formatted: list[str] | None = None,
) -&gt; None:
    __tracebackhide__ = True

    expected_output = expected if expected is not None else testcase.output
    if expected_output != actual and testcase.config.getoption("--update-data", False):
        update_testcase_output(testcase, actual)

    assert_string_arrays_equal(
        expected_output, actual, f"{message} ({testcase.file}, line {testcase.line})"
    )
</t>
<t tx="ekr.20240308084832.2073">def get_func_names(expected: list[str]) -&gt; list[str]:
    res = []
    for s in expected:
        m = re.match(r"def ([_a-zA-Z0-9.*$]+)\(", s)
        if m:
            res.append(m.group(1))
    return res
</t>
<t tx="ekr.20240308084832.2074">def remove_comment_lines(a: list[str]) -&gt; list[str]:
    """Return a copy of array with comments removed.

    Lines starting with '--' (but not with '---') are removed.
    """
    r = []
    for s in a:
        if s.strip().startswith("--") and not s.strip().startswith("---"):
            pass
        else:
            r.append(s)
    return r
</t>
<t tx="ekr.20240308084832.2075">def print_with_line_numbers(s: str) -&gt; None:
    lines = s.splitlines()
    for i, line in enumerate(lines):
        print("%-4d %s" % (i + 1, line))
</t>
<t tx="ekr.20240308084832.2076">def heading(text: str) -&gt; None:
    print("=" * 20 + " " + text + " " + "=" * 20)
</t>
<t tx="ekr.20240308084832.2077">def show_c(cfiles: list[list[tuple[str, str]]]) -&gt; None:
    heading("Generated C")
    for group in cfiles:
        for cfile, ctext in group:
            print(f"== {cfile} ==")
            print_with_line_numbers(ctext)
    heading("End C")
</t>
<t tx="ekr.20240308084832.2078">def fudge_dir_mtimes(dir: str, delta: int) -&gt; None:
    for dirpath, _, filenames in os.walk(dir):
        for name in filenames:
            path = os.path.join(dirpath, name)
            new_mtime = os.stat(path).st_mtime + delta
            os.utime(path, times=(new_mtime, new_mtime))
</t>
<t tx="ekr.20240308084832.2079">def replace_word_size(text: list[str]) -&gt; list[str]:
    """Replace WORDSIZE with platform specific word sizes"""
    result = []
    for line in text:
        index = line.find("WORD_SIZE")
        if index != -1:
            # get 'WORDSIZE*n' token
            word_size_token = line[index:].split()[0]
            n = int(word_size_token[10:])
            replace_str = str(PLATFORM_SIZE * n)
            result.append(line.replace(word_size_token, replace_str))
        else:
            result.append(line)
    return result
</t>
<t tx="ekr.20240308084832.208">def __init__(self, source: Op | BasicBlock, desc: str) -&gt; None:
    self.source = source
    self.desc = desc
</t>
<t tx="ekr.20240308084832.2080">def infer_ir_build_options_from_test_name(name: str) -&gt; CompilerOptions | None:
    """Look for magic substrings in test case name to set compiler options.

    Return None if the test case should be skipped (always pass).

    Supported naming conventions:

      *_64bit*:
          Run test case only on 64-bit platforms
      *_32bit*:
          Run test caseonly on 32-bit platforms
      *_python3_8* (or for any Python version):
          Use Python 3.8+ C API features (default: lowest supported version)
      *StripAssert*:
          Don't generate code for assert statements
    """
    # If this is specific to some bit width, always pass if platform doesn't match.
    if "_64bit" in name and IS_32_BIT_PLATFORM:
        return None
    if "_32bit" in name and not IS_32_BIT_PLATFORM:
        return None
    options = CompilerOptions(strip_asserts="StripAssert" in name, capi_version=(3, 7))
    # A suffix like _python3.8 is used to set the target C API version.
    m = re.search(r"_python([3-9]+)_([0-9]+)(_|\b)", name)
    if m:
        options.capi_version = (int(m.group(1)), int(m.group(2)))
        options.python_version = options.capi_version
    elif "_py" in name or "_Python" in name:
        assert False, f"Invalid _py* suffix (should be _pythonX_Y): {name}"
    return options
</t>
<t tx="ekr.20240308084832.2081"></t>
<t tx="ekr.20240308084832.2082"></t>
<t tx="ekr.20240308084832.2083">"""Default driver for run tests (run-*.test).

This imports the 'native' module (containing the compiled test cases)
and calls each function starting with test_, and reports any
exceptions as failures.

Test cases can provide a custom driver.py that overrides this file.
"""

import sys
import native

failures = []

for name in dir(native):
    if name.startswith('test_'):
        test_func = getattr(native, name)
        try:
            test_func()
        except Exception as e:
            failures.append((name, sys.exc_info()))

if failures:
    from traceback import print_exception, format_tb
    import re

@others
    # Sort failures by line number of test function.
    failures = sorted(failures, key=lambda e: extract_line(e[1][2]))

    # If there are multiple failures, print stack traces of all but the final failure.
    for name, e in failures[:-1]:
        print(f'&lt;&lt; {name} &gt;&gt;')
        sys.stdout.flush()
        print_exception(*e)
        print()
        sys.stdout.flush()

    # Raise exception for the last failure. Test runner will show the traceback.
    print(f'&lt;&lt; {failures[-1][0]} &gt;&gt;')
    sys.stdout.flush()
    raise failures[-1][1][1]
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2084">    def extract_line(tb):
        formatted = '\n'.join(format_tb(tb))
        m = re.search('File "(native|driver).py", line ([0-9]+), in (test_|&lt;module&gt;)', formatted)
        if m is None:
            return "0"
        return m.group(1)
</t>
<t tx="ekr.20240308084832.2085"></t>
<t tx="ekr.20240308084832.2086"># These builtins stubs are used implicitly in AST to IR generation
# test cases.

import _typeshed
from typing import (
    TypeVar, Generic, List, Iterator, Iterable, Dict, Optional, Tuple, Any, Set,
    overload, Mapping, Union, Callable, Sequence, FrozenSet, Protocol
)

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
T_contra = TypeVar('T_contra', contravariant=True)
S = TypeVar('S')
K = TypeVar('K') # for keys in mapping
V = TypeVar('V') # for values in mapping

@others
NotImplemented: Any = ...
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2087">class __SupportsAbs(Protocol[T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2088">def __abs__(self) -&gt; T_co: pass
</t>
<t tx="ekr.20240308084832.2089">class __SupportsDivMod(Protocol[T_contra, T_co]):
    @others
</t>
<t tx="ekr.20240308084832.209">def __eq__(self, other: object) -&gt; bool:
    return (
        isinstance(other, FnError) and self.source == other.source and self.desc == other.desc
    )
</t>
<t tx="ekr.20240308084832.2090">def __divmod__(self, other: T_contra) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2091">class __SupportsRDivMod(Protocol[T_contra, T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2092">def __rdivmod__(self, other: T_contra) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2093">_M = TypeVar("_M", contravariant=True)

class __SupportsPow2(Protocol[T_contra, T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2094">def __pow__(self, other: T_contra) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2095">class __SupportsPow3NoneOnly(Protocol[T_contra, T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2096">def __pow__(self, other: T_contra, modulo: None = ...) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2097">class __SupportsPow3(Protocol[T_contra, _M, T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2098">def __pow__(self, other: T_contra, modulo: _M) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2099">__SupportsSomeKindOfPow = Union[
    __SupportsPow2[Any, Any], __SupportsPow3NoneOnly[Any, Any] | __SupportsPow3[Any, Any, Any]
]

class object:
    @others
</t>
<t tx="ekr.20240308084832.21">def mypyc_build(
    paths: list[str],
    compiler_options: CompilerOptions,
    *,
    separate: bool | list[tuple[list[str], str | None]] = False,
    only_compile_paths: Iterable[str] | None = None,
    skip_cgen_input: Any | None = None,
    always_use_shared_lib: bool = False,
) -&gt; tuple[emitmodule.Groups, list[tuple[list[str], list[str]]]]:
    """Do the front and middle end of mypyc building, producing and writing out C source."""
    fscache = FileSystemCache()
    mypyc_sources, all_sources, options = get_mypy_config(
        paths, only_compile_paths, compiler_options, fscache
    )

    # We generate a shared lib if there are multiple modules or if any
    # of the modules are in package. (Because I didn't want to fuss
    # around with making the single module code handle packages.)
    use_shared_lib = (
        len(mypyc_sources) &gt; 1
        or any("." in x.module for x in mypyc_sources)
        or always_use_shared_lib
    )

    groups = construct_groups(mypyc_sources, separate, use_shared_lib)

    # We let the test harness just pass in the c file contents instead
    # so that it can do a corner-cutting version without full stubs.
    if not skip_cgen_input:
        group_cfiles, ops_text = generate_c(
            all_sources, options, groups, fscache, compiler_options=compiler_options
        )
        # TODO: unique names?
        write_file(os.path.join(compiler_options.target_dir, "ops.txt"), ops_text)
    else:
        group_cfiles = skip_cgen_input

    # Write out the generated C and collect the files for each group
    # Should this be here??
    group_cfilenames: list[tuple[list[str], list[str]]] = []
    for cfiles in group_cfiles:
        cfilenames = []
        for cfile, ctext in cfiles:
            cfile = os.path.join(compiler_options.target_dir, cfile)
            write_file(cfile, ctext)
            if os.path.splitext(cfile)[1] == ".c":
                cfilenames.append(cfile)

        deps = [os.path.join(compiler_options.target_dir, dep) for dep in get_header_deps(cfiles)]
        group_cfilenames.append((cfilenames, deps))

    return groups, group_cfilenames
</t>
<t tx="ekr.20240308084832.210">def __repr__(self) -&gt; str:
    return f"FnError(source={self.source}, desc={self.desc})"
</t>
<t tx="ekr.20240308084832.2100">def __init__(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2101">def __eq__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2102">def __ne__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2103">class type:
    @others
    __name__ : str
    __annotations__: Dict[str, Any]
</t>
<t tx="ekr.20240308084832.2104">def __init__(self, o: object) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2105">class ellipsis: pass

# Primitive types are special in generated code.
</t>
<t tx="ekr.20240308084832.2106">class int:
    @others
</t>
<t tx="ekr.20240308084832.2107">@overload
def __init__(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2108">@overload
def __init__(self, x: object, base: int = 10) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2109">def __add__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.211">def check_func_ir(fn: FuncIR) -&gt; list[FnError]:
    """Applies validations to a given function ir and returns a list of errors found."""
    errors = []

    op_set = set()

    for block in fn.blocks:
        if not block.terminated:
            errors.append(
                FnError(source=block.ops[-1] if block.ops else block, desc="Block not terminated")
            )
        for op in block.ops[:-1]:
            if isinstance(op, ControlOp):
                errors.append(FnError(source=op, desc="Block has operations after control op"))

            if op in op_set:
                errors.append(FnError(source=op, desc="Func has a duplicate op"))
            op_set.add(op)

    errors.extend(check_op_sources_valid(fn))
    if errors:
        return errors

    op_checker = OpChecker(fn)
    for block in fn.blocks:
        for op in block.ops:
            op.accept(op_checker)

    return op_checker.errors
</t>
<t tx="ekr.20240308084832.2110">def __sub__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2111">def __mul__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2112">def __pow__(self, n: int, modulo: Optional[int] = None) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2113">def __floordiv__(self, x: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2114">def __truediv__(self, x: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2115">def __mod__(self, x: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2116">def __divmod__(self, x: float) -&gt; Tuple[float, float]: pass
</t>
<t tx="ekr.20240308084832.2117">def __neg__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2118">def __pos__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2119">def __abs__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.212">class IrCheckException(Exception):
    pass
</t>
<t tx="ekr.20240308084832.2120">def __invert__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2121">def __and__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2122">def __or__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2123">def __xor__(self, n: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2124">def __lshift__(self, x: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2125">def __rshift__(self, x: int) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2126">def __eq__(self, n: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2127">def __ne__(self, n: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2128">def __lt__(self, n: int) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2129">def __gt__(self, n: int) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.213">def assert_func_ir_valid(fn: FuncIR) -&gt; None:
    errors = check_func_ir(fn)
    if errors:
        raise IrCheckException(
            "Internal error: Generated invalid IR: \n"
            + "\n".join(format_func(fn, [(e.source, e.desc) for e in errors]))
        )
</t>
<t tx="ekr.20240308084832.2130">def __le__(self, n: int) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2131">def __ge__(self, n: int) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2132">class str:
    @others
</t>
<t tx="ekr.20240308084832.2133">@overload
def __init__(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2134">@overload
def __init__(self, x: object) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2135">def __add__(self, x: str) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2136">def __mul__(self, x: int) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2137">def __rmul__(self, x: int) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2138">def __eq__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2139">def __ne__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.214">def check_op_sources_valid(fn: FuncIR) -&gt; list[FnError]:
    errors = []
    valid_ops: set[Op] = set()
    valid_registers: set[Register] = set()

    for block in fn.blocks:
        valid_ops.update(block.ops)

        for op in block.ops:
            if isinstance(op, BaseAssign):
                valid_registers.add(op.dest)
            elif isinstance(op, LoadAddress) and isinstance(op.src, Register):
                valid_registers.add(op.src)

    valid_registers.update(fn.arg_regs)

    for block in fn.blocks:
        for op in block.ops:
            for source in op.sources():
                if isinstance(source, Integer):
                    pass
                elif isinstance(source, Op):
                    if source not in valid_ops:
                        errors.append(
                            FnError(
                                source=op,
                                desc=f"Invalid op reference to op of type {type(source).__name__}",
                            )
                        )
                elif isinstance(source, Register):
                    if source not in valid_registers:
                        errors.append(
                            FnError(
                                source=op, desc=f"Invalid op reference to register {source.name!r}"
                            )
                        )

    return errors
</t>
<t tx="ekr.20240308084832.2140">def __lt__(self, x: str) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2141">def __le__(self, x: str) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2142">def __gt__(self, x: str) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2143">def __ge__(self, x: str) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2144">@overload
def __getitem__(self, i: int) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2145">@overload
def __getitem__(self, i: slice) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2146">def __contains__(self, item: str) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2147">def __iter__(self) -&gt; Iterator[str]: ...
</t>
<t tx="ekr.20240308084832.2148">def split(self, sep: Optional[str] = None, max: Optional[int] = None) -&gt; List[str]: pass
</t>
<t tx="ekr.20240308084832.2149">def strip (self, item: str) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.215">disjoint_types = {
    int_rprimitive.name,
    bytes_rprimitive.name,
    str_rprimitive.name,
    dict_rprimitive.name,
    list_rprimitive.name,
    set_rprimitive.name,
    tuple_rprimitive.name,
    range_rprimitive.name,
}


def can_coerce_to(src: RType, dest: RType) -&gt; bool:
    """Check if src can be assigned to dest_rtype.

    Currently okay to have false positives.
    """
    if isinstance(dest, RUnion):
        return any(can_coerce_to(src, d) for d in dest.items)

    if isinstance(dest, RPrimitive):
        if isinstance(src, RPrimitive):
            # If either src or dest is a disjoint type, then they must both be.
            if src.name in disjoint_types and dest.name in disjoint_types:
                return src.name == dest.name
            return src.size == dest.size
        if isinstance(src, RInstance):
            return is_object_rprimitive(dest)
        if isinstance(src, RUnion):
            # IR doesn't have the ability to narrow unions based on
            # control flow, so cannot be a strict all() here.
            return any(can_coerce_to(s, dest) for s in src.items)
        return False

    return True
</t>
<t tx="ekr.20240308084832.2150">def join(self, x: Iterable[str]) -&gt; str: pass
</t>
<t tx="ekr.20240308084832.2151">def format(self, *args: Any, **kwargs: Any) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2152">def upper(self) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2153">def startswith(self, x: str, start: int=..., end: int=...) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2154">def endswith(self, x: str, start: int=..., end: int=...) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2155">def replace(self, old: str, new: str, maxcount: int=...) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2156">def encode(self, x: str=..., y: str=...) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2157">class float:
    @others
</t>
<t tx="ekr.20240308084832.2158">def __init__(self, x: object) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2159">def __add__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.216">class OpChecker(OpVisitor[None]):
    @others
</t>
<t tx="ekr.20240308084832.2160">def __radd__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2161">def __sub__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2162">def __rsub__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2163">def __mul__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2164">def __truediv__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2165">def __floordiv__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2166">def __mod__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2167">def __pow__(self, n: float) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2168">def __neg__(self) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2169">def __pos__(self) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.217">def __init__(self, parent_fn: FuncIR) -&gt; None:
    self.parent_fn = parent_fn
    self.errors: list[FnError] = []
</t>
<t tx="ekr.20240308084832.2170">def __abs__(self) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2171">def __invert__(self) -&gt; float: pass
</t>
<t tx="ekr.20240308084832.2172">def __eq__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2173">def __ne__(self, x: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2174">def __lt__(self, x: float) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2175">def __le__(self, x: float) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2176">def __gt__(self, x: float) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2177">def __ge__(self, x: float) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2178">class complex:
    @others
</t>
<t tx="ekr.20240308084832.2179">def __init__(self, x: object, y: object = None) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.218">def fail(self, source: Op, desc: str) -&gt; None:
    self.errors.append(FnError(source=source, desc=desc))
</t>
<t tx="ekr.20240308084832.2180">def __add__(self, n: complex) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2181">def __radd__(self, n: float) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2182">def __sub__(self, n: complex) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2183">def __rsub__(self, n: float) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2184">def __mul__(self, n: complex) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2185">def __truediv__(self, n: complex) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2186">def __neg__(self) -&gt; complex: pass
</t>
<t tx="ekr.20240308084832.2187">class bytes:
    @others
</t>
<t tx="ekr.20240308084832.2188">@overload
def __init__(self) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2189">@overload
def __init__(self, x: object) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.219">def check_control_op_targets(self, op: ControlOp) -&gt; None:
    for target in op.targets():
        if target not in self.parent_fn.blocks:
            self.fail(source=op, desc=f"Invalid control operation target: {target.label}")
</t>
<t tx="ekr.20240308084832.2190">def __add__(self, x: bytes) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2191">def __mul__(self, x: int) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2192">def __rmul__(self, x: int) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2193">def __eq__(self, x: object) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2194">def __ne__(self, x: object) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2195">@overload
def __getitem__(self, i: int) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2196">@overload
def __getitem__(self, i: slice) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2197">def join(self, x: Iterable[object]) -&gt; bytes: ...
</t>
<t tx="ekr.20240308084832.2198">def decode(self, x: str=..., y: str=...) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2199">class bytearray:
    @others
</t>
<t tx="ekr.20240308084832.22">def mypycify(
    paths: list[str],
    *,
    only_compile_paths: Iterable[str] | None = None,
    verbose: bool = False,
    opt_level: str = "3",
    debug_level: str = "1",
    strip_asserts: bool = False,
    multi_file: bool = False,
    separate: bool | list[tuple[list[str], str | None]] = False,
    skip_cgen_input: Any | None = None,
    target_dir: str | None = None,
    include_runtime_files: bool | None = None,
) -&gt; list[Extension]:
    """Main entry point to building using mypyc.

    This produces a list of Extension objects that should be passed as the
    ext_modules parameter to setup.

    Arguments:
        paths: A list of file paths to build. It may also contain mypy options.
        only_compile_paths: If not None, an iterable of paths that are to be
                            the only modules compiled, even if other modules
                            appear in the mypy command line given to paths.
                            (These modules must still be passed to paths.)

        verbose: Should mypyc be more verbose. Defaults to false.

        opt_level: The optimization level, as a string. Defaults to '3' (meaning '-O3').
        debug_level: The debug level, as a string. Defaults to '1' (meaning '-g1').
        strip_asserts: Should asserts be stripped from the generated code.

        multi_file: Should each Python module be compiled into its own C source file.
                    This can reduce compile time and memory requirements at the likely
                    cost of runtime performance of compiled code. Defaults to false.
        separate: Should compiled modules be placed in separate extension modules.
                  If False, all modules are placed in a single shared library.
                  If True, every module is placed in its own library.
                  Otherwise separate should be a list of
                  (file name list, optional shared library name) pairs specifying
                  groups of files that should be placed in the same shared library
                  (while all other modules will be placed in its own library).

                  Each group can be compiled independently, which can
                  speed up compilation, but calls between groups can
                  be slower than calls within a group and can't be
                  inlined.
        target_dir: The directory to write C output files. Defaults to 'build'.
        include_runtime_files: If not None, whether the mypyc runtime library
                               should be directly #include'd instead of linked
                               separately in order to reduce compiler invocations.
                               Defaults to False in multi_file mode, True otherwise.
    """

    # Figure out our configuration
    compiler_options = CompilerOptions(
        strip_asserts=strip_asserts,
        multi_file=multi_file,
        verbose=verbose,
        separate=separate is not False,
        target_dir=target_dir,
        include_runtime_files=include_runtime_files,
    )

    # Generate all the actual important C code
    groups, group_cfilenames = mypyc_build(
        paths,
        only_compile_paths=only_compile_paths,
        compiler_options=compiler_options,
        separate=separate,
        skip_cgen_input=skip_cgen_input,
    )

    # Mess around with setuptools and actually get the thing built
    setup_mypycify_vars()

    # Create a compiler object so we can make decisions based on what
    # compiler is being used. typeshed is missing some attributes on the
    # compiler object so we give it type Any
    compiler: Any = ccompiler.new_compiler()
    sysconfig.customize_compiler(compiler)

    build_dir = compiler_options.target_dir

    cflags: list[str] = []
    if compiler.compiler_type == "unix":
        cflags += [
            f"-O{opt_level}",
            f"-g{debug_level}",
            "-Werror",
            "-Wno-unused-function",
            "-Wno-unused-label",
            "-Wno-unreachable-code",
            "-Wno-unused-variable",
            "-Wno-unused-command-line-argument",
            "-Wno-unknown-warning-option",
            "-Wno-unused-but-set-variable",
            "-Wno-ignored-optimization-argument",
            # Disables C Preprocessor (cpp) warnings
            # See https://github.com/issues/956
            "-Wno-cpp",
        ]
    elif compiler.compiler_type == "msvc":
        # msvc doesn't have levels, '/O2' is full and '/Od' is disable
        if opt_level == "0":
            opt_level = "d"
        elif opt_level in ("1", "2", "3"):
            opt_level = "2"
        if debug_level == "0":
            debug_level = "NONE"
        elif debug_level == "1":
            debug_level = "FASTLINK"
        elif debug_level in ("2", "3"):
            debug_level = "FULL"
        cflags += [
            f"/O{opt_level}",
            f"/DEBUG:{debug_level}",
            "/wd4102",  # unreferenced label
            "/wd4101",  # unreferenced local variable
            "/wd4146",  # negating unsigned int
        ]
        if multi_file:
            # Disable whole program optimization in multi-file mode so
            # that we actually get the compilation speed and memory
            # use wins that multi-file mode is intended for.
            cflags += ["/GL-", "/wd9025"]  # warning about overriding /GL

    # If configured to (defaults to yes in multi-file mode), copy the
    # runtime library in. Otherwise it just gets #included to save on
    # compiler invocations.
    shared_cfilenames = []
    if not compiler_options.include_runtime_files:
        for name in RUNTIME_C_FILES:
            rt_file = os.path.join(build_dir, name)
            with open(os.path.join(include_dir(), name), encoding="utf-8") as f:
                write_file(rt_file, f.read())
            shared_cfilenames.append(rt_file)

    extensions = []
    for (group_sources, lib_name), (cfilenames, deps) in zip(groups, group_cfilenames):
        if lib_name:
            extensions.extend(
                build_using_shared_lib(
                    group_sources,
                    lib_name,
                    cfilenames + shared_cfilenames,
                    deps,
                    build_dir,
                    cflags,
                )
            )
        else:
            extensions.extend(
                build_single_module(group_sources, cfilenames + shared_cfilenames, cflags)
            )

    return extensions
</t>
<t tx="ekr.20240308084832.220">def check_type_coercion(self, op: Op, src: RType, dest: RType) -&gt; None:
    if not can_coerce_to(src, dest):
        self.fail(
            source=op, desc=f"Cannot coerce source type {src.name} to dest type {dest.name}"
        )
</t>
<t tx="ekr.20240308084832.2200">@overload
def __init__(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2201">@overload
def __init__(self, x: object) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2202">@overload
def __init__(self, string: str, encoding: str, err: str = ...) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2203">def __add__(self, s: bytes) -&gt; bytearray: ...
</t>
<t tx="ekr.20240308084832.2204">def __setitem__(self, i: int, o: int) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2205">def __getitem__(self, i: int) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2206">def decode(self, x: str = ..., y: str = ...) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2207">class bool(int):
    @others
</t>
<t tx="ekr.20240308084832.2208">def __init__(self, o: object = ...) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2209">@overload
def __and__(self, n: bool) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.221">def check_compatibility(self, op: Op, t: RType, s: RType) -&gt; None:
    if not can_coerce_to(t, s) or not can_coerce_to(s, t):
        self.fail(source=op, desc=f"{t.name} and {s.name} are not compatible")
</t>
<t tx="ekr.20240308084832.2210">@overload
def __and__(self, n: int) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2211">@overload
def __or__(self, n: bool) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2212">@overload
def __or__(self, n: int) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2213">@overload
def __xor__(self, n: bool) -&gt; bool: ...
</t>
<t tx="ekr.20240308084832.2214">@overload
def __xor__(self, n: int) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2215">class tuple(Generic[T_co], Sequence[T_co], Iterable[T_co]):
    @others
</t>
<t tx="ekr.20240308084832.2216">def __init__(self, i: Iterable[T_co]) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2217">@overload
def __getitem__(self, i: int) -&gt; T_co: pass
</t>
<t tx="ekr.20240308084832.2218">@overload
def __getitem__(self, i: slice) -&gt; Tuple[T_co, ...]: pass
</t>
<t tx="ekr.20240308084832.2219">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.222">def expect_float(self, op: Op, v: Value) -&gt; None:
    if not is_float_rprimitive(v.type):
        self.fail(op, f"Float expected (actual type is {v.type})")
</t>
<t tx="ekr.20240308084832.2220">def __iter__(self) -&gt; Iterator[T_co]: ...
</t>
<t tx="ekr.20240308084832.2221">def __contains__(self, item: object) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2222">class function: pass
</t>
<t tx="ekr.20240308084832.2223">class list(Generic[T], Sequence[T], Iterable[T]):
    @others
</t>
<t tx="ekr.20240308084832.2224">def __init__(self, i: Optional[Iterable[T]] = None) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2225">@overload
def __getitem__(self, i: int) -&gt; T: ...
</t>
<t tx="ekr.20240308084832.2226">@overload
def __getitem__(self, s: slice) -&gt; List[T]: ...
</t>
<t tx="ekr.20240308084832.2227">def __setitem__(self, i: int, o: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2228">def __delitem__(self, i: int) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2229">def __mul__(self, i: int) -&gt; List[T]: pass
</t>
<t tx="ekr.20240308084832.223">def expect_non_float(self, op: Op, v: Value) -&gt; None:
    if is_float_rprimitive(v.type):
        self.fail(op, "Float not expected")
</t>
<t tx="ekr.20240308084832.2230">def __rmul__(self, i: int) -&gt; List[T]: pass
</t>
<t tx="ekr.20240308084832.2231">def __iter__(self) -&gt; Iterator[T]: pass
</t>
<t tx="ekr.20240308084832.2232">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2233">def __contains__(self, item: object) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2234">def __add__(self, x: List[T]) -&gt; List[T]: ...
</t>
<t tx="ekr.20240308084832.2235">def append(self, x: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2236">def pop(self, i: int = -1) -&gt; T: pass
</t>
<t tx="ekr.20240308084832.2237">def count(self, T) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2238">def extend(self, l: Iterable[T]) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2239">def insert(self, i: int, x: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.224">def visit_goto(self, op: Goto) -&gt; None:
    self.check_control_op_targets(op)
</t>
<t tx="ekr.20240308084832.2240">def sort(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2241">def reverse(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2242">def remove(self, o: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2243">def index(self, o: T) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2244">class dict(Mapping[K, V]):
    @others
</t>
<t tx="ekr.20240308084832.2245">@overload
def __init__(self, **kwargs: K) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2246">@overload
def __init__(self, map: Mapping[K, V], **kwargs: V) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2247">@overload
def __init__(self, iterable: Iterable[Tuple[K, V]], **kwargs: V) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2248">def __getitem__(self, key: K) -&gt; V: pass
</t>
<t tx="ekr.20240308084832.2249">def __setitem__(self, k: K, v: V) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.225">def visit_branch(self, op: Branch) -&gt; None:
    self.check_control_op_targets(op)
</t>
<t tx="ekr.20240308084832.2250">def __delitem__(self, k: K) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2251">def __contains__(self, item: object) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2252">def __iter__(self) -&gt; Iterator[K]: pass
</t>
<t tx="ekr.20240308084832.2253">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2254">@overload
def update(self, __m: Mapping[K, V], **kwargs: V) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2255">@overload
def update(self, __m: Iterable[Tuple[K, V]], **kwargs: V) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2256">@overload
def update(self, **kwargs: V) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2257">def pop(self, x: int) -&gt; K: pass
</t>
<t tx="ekr.20240308084832.2258">def keys(self) -&gt; Iterable[K]: pass
</t>
<t tx="ekr.20240308084832.2259">def values(self) -&gt; Iterable[V]: pass
</t>
<t tx="ekr.20240308084832.226">def visit_return(self, op: Return) -&gt; None:
    self.check_type_coercion(op, op.value.type, self.parent_fn.decl.sig.ret_type)
</t>
<t tx="ekr.20240308084832.2260">def items(self) -&gt; Iterable[Tuple[K, V]]: pass
</t>
<t tx="ekr.20240308084832.2261">def clear(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2262">def copy(self) -&gt; Dict[K, V]: pass
</t>
<t tx="ekr.20240308084832.2263">def setdefault(self, key: K, val: V = ...) -&gt; V: pass
</t>
<t tx="ekr.20240308084832.2264">class set(Generic[T]):
    @others
</t>
<t tx="ekr.20240308084832.2265">def __init__(self, i: Optional[Iterable[T]] = None) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2266">def __iter__(self) -&gt; Iterator[T]: pass
</t>
<t tx="ekr.20240308084832.2267">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2268">def add(self, x: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2269">def remove(self, x: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.227">def visit_unreachable(self, op: Unreachable) -&gt; None:
    # Unreachables are checked at a higher level since validation
    # requires access to the entire basic block.
    pass
</t>
<t tx="ekr.20240308084832.2270">def discard(self, x: T) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2271">def clear(self) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2272">def pop(self) -&gt; T: pass
</t>
<t tx="ekr.20240308084832.2273">def update(self, x: Iterable[S]) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2274">def __or__(self, s: Union[Set[S], FrozenSet[S]]) -&gt; Set[Union[T, S]]: ...
</t>
<t tx="ekr.20240308084832.2275">def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -&gt; Set[Union[T, S]]: ...
</t>
<t tx="ekr.20240308084832.2276">class frozenset(Generic[T]):
    @others
</t>
<t tx="ekr.20240308084832.2277">def __init__(self, i: Optional[Iterable[T]] = None) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2278">def __iter__(self) -&gt; Iterator[T]: pass
</t>
<t tx="ekr.20240308084832.2279">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.228">def visit_assign(self, op: Assign) -&gt; None:
    self.check_type_coercion(op, op.src.type, op.dest.type)
</t>
<t tx="ekr.20240308084832.2280">def __or__(self, s: Union[Set[S], FrozenSet[S]]) -&gt; FrozenSet[Union[T, S]]: ...
</t>
<t tx="ekr.20240308084832.2281">def __xor__(self, s: Union[Set[S], FrozenSet[S]]) -&gt; FrozenSet[Union[T, S]]: ...
</t>
<t tx="ekr.20240308084832.2282">class slice: pass
</t>
<t tx="ekr.20240308084832.2283">class range(Iterable[int]):
    @others
</t>
<t tx="ekr.20240308084832.2284">def __init__(self, x: int, y: int = ..., z: int = ...) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2285">def __iter__(self) -&gt; Iterator[int]: pass
</t>
<t tx="ekr.20240308084832.2286">def __len__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2287">def __next__(self) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2288">class property:
    @others
</t>
<t tx="ekr.20240308084832.2289">def __init__(self, fget: Optional[Callable[[Any], Any]] = ...,
             fset: Optional[Callable[[Any, Any], None]] = ...,
             fdel: Optional[Callable[[Any], None]] = ...,
             doc: Optional[str] = ...) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.229">def visit_assign_multi(self, op: AssignMulti) -&gt; None:
    for src in op.src:
        assert isinstance(op.dest.type, RArray)
        self.check_type_coercion(op, src.type, op.dest.type.item_type)
</t>
<t tx="ekr.20240308084832.2290">def getter(self, fget: Callable[[Any], Any]) -&gt; property: ...
</t>
<t tx="ekr.20240308084832.2291">def setter(self, fset: Callable[[Any, Any], None]) -&gt; property: ...
</t>
<t tx="ekr.20240308084832.2292">def deleter(self, fdel: Callable[[Any], None]) -&gt; property: ...
</t>
<t tx="ekr.20240308084832.2293">def __get__(self, obj: Any, type: Optional[type] = ...) -&gt; Any: ...
</t>
<t tx="ekr.20240308084832.2294">def __set__(self, obj: Any, value: Any) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2295">def __delete__(self, obj: Any) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2296">def fget(self) -&gt; Any: ...
</t>
<t tx="ekr.20240308084832.2297">def fset(self, value: Any) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2298">def fdel(self) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2299">class BaseException: pass
</t>
<t tx="ekr.20240308084832.23">from __future__ import annotations

import sys
import sysconfig
from typing import Any, Dict, Final

from mypy.util import unnamed_function

PREFIX: Final = "CPyPy_"  # Python wrappers
NATIVE_PREFIX: Final = "CPyDef_"  # Native functions etc.
DUNDER_PREFIX: Final = "CPyDunder_"  # Wrappers for exposing dunder methods to the API
REG_PREFIX: Final = "cpy_r_"  # Registers
STATIC_PREFIX: Final = "CPyStatic_"  # Static variables (for literals etc.)
TYPE_PREFIX: Final = "CPyType_"  # Type object struct
MODULE_PREFIX: Final = "CPyModule_"  # Cached modules
ATTR_PREFIX: Final = "_"  # Attributes

ENV_ATTR_NAME: Final = "__mypyc_env__"
NEXT_LABEL_ATTR_NAME: Final = "__mypyc_next_label__"
TEMP_ATTR_NAME: Final = "__mypyc_temp__"
LAMBDA_NAME: Final = "__mypyc_lambda__"
PROPSET_PREFIX: Final = "__mypyc_setter__"
SELF_NAME: Final = "__mypyc_self__"

# Max short int we accept as a literal is based on 32-bit platforms,
# so that we can just always emit the same code.

TOP_LEVEL_NAME: Final = "__top_level__"  # Special function representing module top level

# Maximal number of subclasses for a class to trigger fast path in isinstance() checks.
FAST_ISINSTANCE_MAX_SUBCLASSES: Final = 2

# Size of size_t, if configured.
SIZEOF_SIZE_T_SYSCONFIG: Final = sysconfig.get_config_var("SIZEOF_SIZE_T")

SIZEOF_SIZE_T: Final = (
    int(SIZEOF_SIZE_T_SYSCONFIG)
    if SIZEOF_SIZE_T_SYSCONFIG is not None
    else (sys.maxsize + 1).bit_length() // 8
)

IS_32_BIT_PLATFORM: Final = int(SIZEOF_SIZE_T) == 4

PLATFORM_SIZE = 4 if IS_32_BIT_PLATFORM else 8

# Maximum value for a short tagged integer.
MAX_SHORT_INT: Final = 2 ** (8 * int(SIZEOF_SIZE_T) - 2) - 1

# Minimum value for a short tagged integer.
MIN_SHORT_INT: Final = -(MAX_SHORT_INT) - 1

# Maximum value for a short tagged integer represented as a C integer literal.
#
# Note: Assume that the compiled code uses the same bit width as mypyc
MAX_LITERAL_SHORT_INT: Final = MAX_SHORT_INT
MIN_LITERAL_SHORT_INT: Final = -MAX_LITERAL_SHORT_INT - 1

# Description of the C type used to track the definedness of attributes and
# the presence of argument default values that have types with overlapping
# error values. Each tracked attribute/argument has a dedicated bit in the
# relevant bitmap.
BITMAP_TYPE: Final = "uint32_t"
BITMAP_BITS: Final = 32

# Runtime C library files
RUNTIME_C_FILES: Final = [
    "init.c",
    "getargs.c",
    "getargsfast.c",
    "int_ops.c",
    "float_ops.c",
    "str_ops.c",
    "bytes_ops.c",
    "list_ops.c",
    "dict_ops.c",
    "set_ops.c",
    "tuple_ops.c",
    "exc_ops.c",
    "misc_ops.c",
    "generic_ops.c",
]


JsonDict = Dict[str, Any]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.230">def visit_load_error_value(self, op: LoadErrorValue) -&gt; None:
    # Currently it is assumed that all types have an error value.
    # Once this is fixed we can validate that the rtype here actually
    # has an error value.
    pass
</t>
<t tx="ekr.20240308084832.2300">class Exception(BaseException):
    @others
</t>
<t tx="ekr.20240308084832.2301">def __init__(self, message: Optional[str] = None) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2302">class Warning(Exception): pass
</t>
<t tx="ekr.20240308084832.2303">class UserWarning(Warning): pass
</t>
<t tx="ekr.20240308084832.2304">class TypeError(Exception): pass
</t>
<t tx="ekr.20240308084832.2305">class ValueError(Exception): pass
</t>
<t tx="ekr.20240308084832.2306">class AttributeError(Exception): pass
</t>
<t tx="ekr.20240308084832.2307">class ImportError(Exception): pass
</t>
<t tx="ekr.20240308084832.2308">class NameError(Exception): pass
</t>
<t tx="ekr.20240308084832.2309">class UnboundLocalError(NameError): pass
</t>
<t tx="ekr.20240308084832.231">def check_tuple_items_valid_literals(self, op: LoadLiteral, t: tuple[object, ...]) -&gt; None:
    for x in t:
        if x is not None and not isinstance(x, (str, bytes, bool, int, float, complex, tuple)):
            self.fail(op, f"Invalid type for item of tuple literal: {type(x)})")
        if isinstance(x, tuple):
            self.check_tuple_items_valid_literals(op, x)
</t>
<t tx="ekr.20240308084832.2310">class LookupError(Exception): pass
</t>
<t tx="ekr.20240308084832.2311">class KeyError(LookupError): pass
</t>
<t tx="ekr.20240308084832.2312">class IndexError(LookupError): pass
</t>
<t tx="ekr.20240308084832.2313">class RuntimeError(Exception): pass
</t>
<t tx="ekr.20240308084832.2314">class UnicodeEncodeError(RuntimeError): pass
</t>
<t tx="ekr.20240308084832.2315">class UnicodeDecodeError(RuntimeError): pass
</t>
<t tx="ekr.20240308084832.2316">class NotImplementedError(RuntimeError): pass
</t>
<t tx="ekr.20240308084832.2317">class StopIteration(Exception):
    value: Any
</t>
<t tx="ekr.20240308084832.2318">class ArithmeticError(Exception): pass
</t>
<t tx="ekr.20240308084832.2319">class ZeroDivisionError(ArithmeticError): pass
</t>
<t tx="ekr.20240308084832.232">def check_frozenset_items_valid_literals(self, op: LoadLiteral, s: frozenset[object]) -&gt; None:
    for x in s:
        if x is None or isinstance(x, (str, bytes, bool, int, float, complex)):
            pass
        elif isinstance(x, tuple):
            self.check_tuple_items_valid_literals(op, x)
        else:
            self.fail(op, f"Invalid type for item of frozenset literal: {type(x)})")
</t>
<t tx="ekr.20240308084832.2320">class OverflowError(ArithmeticError): pass
</t>
<t tx="ekr.20240308084832.2321">class GeneratorExit(BaseException): pass
</t>
<t tx="ekr.20240308084832.2322">def any(i: Iterable[T]) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2323">def all(i: Iterable[T]) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.2324">def sum(i: Iterable[T]) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2325">def reversed(object: Sequence[T]) -&gt; Iterator[T]: ...
</t>
<t tx="ekr.20240308084832.2326">def id(o: object) -&gt; int: pass
# This type is obviously wrong but the test stubs don't have Sized anymore
</t>
<t tx="ekr.20240308084832.2327">def len(o: object) -&gt; int: pass
</t>
<t tx="ekr.20240308084832.2328">def print(*object) -&gt; None: pass
</t>
<t tx="ekr.20240308084832.2329">def isinstance(x: object, t: object) -&gt; bool: pass
</t>
<t tx="ekr.20240308084832.233">def visit_load_literal(self, op: LoadLiteral) -&gt; None:
    expected_type = None
    if op.value is None:
        expected_type = "builtins.object"
    elif isinstance(op.value, int):
        expected_type = "builtins.int"
    elif isinstance(op.value, str):
        expected_type = "builtins.str"
    elif isinstance(op.value, bytes):
        expected_type = "builtins.bytes"
    elif isinstance(op.value, bool):
        expected_type = "builtins.object"
    elif isinstance(op.value, float):
        expected_type = "builtins.float"
    elif isinstance(op.value, complex):
        expected_type = "builtins.object"
    elif isinstance(op.value, tuple):
        expected_type = "builtins.tuple"
        self.check_tuple_items_valid_literals(op, op.value)
    elif isinstance(op.value, frozenset):
        # There's no frozenset_rprimitive type since it'd be pretty useless so we just pretend
        # it's a set (when it's really a frozenset).
        expected_type = "builtins.set"
        self.check_frozenset_items_valid_literals(op, op.value)

    assert expected_type is not None, "Missed a case for LoadLiteral check"

    if op.type.name not in [expected_type, "builtins.object"]:
        self.fail(
            op,
            f"Invalid literal value for type: value has "
            f"type {expected_type}, but op has type {op.type.name}",
        )
</t>
<t tx="ekr.20240308084832.2330">def iter(i: Iterable[T]) -&gt; Iterator[T]: pass
</t>
<t tx="ekr.20240308084832.2331">@overload
def next(i: Iterator[T]) -&gt; T: pass
</t>
<t tx="ekr.20240308084832.2332">@overload
def next(i: Iterator[T], default: T) -&gt; T: pass
</t>
<t tx="ekr.20240308084832.2333">def hash(o: object) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2334">def globals() -&gt; Dict[str, Any]: ...
</t>
<t tx="ekr.20240308084832.2335">def getattr(obj: object, name: str, default: Any = None) -&gt; Any: ...
</t>
<t tx="ekr.20240308084832.2336">def setattr(obj: object, name: str, value: Any) -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2337">def enumerate(x: Iterable[T]) -&gt; Iterator[Tuple[int, T]]: ...
</t>
<t tx="ekr.20240308084832.2338">@overload
def zip(x: Iterable[T], y: Iterable[S]) -&gt; Iterator[Tuple[T, S]]: ...
</t>
<t tx="ekr.20240308084832.2339">@overload
def zip(x: Iterable[T], y: Iterable[S], z: Iterable[V]) -&gt; Iterator[Tuple[T, S, V]]: ...
</t>
<t tx="ekr.20240308084832.234">def visit_get_attr(self, op: GetAttr) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.2340">def eval(e: str) -&gt; Any: ...
</t>
<t tx="ekr.20240308084832.2341">def abs(x: __SupportsAbs[T]) -&gt; T: ...
</t>
<t tx="ekr.20240308084832.2342">@overload
def divmod(x: __SupportsDivMod[T_contra, T_co], y: T_contra) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2343">@overload
def divmod(x: T_contra, y: __SupportsRDivMod[T_contra, T_co]) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2344">@overload
def pow(base: __SupportsPow2[T_contra, T_co], exp: T_contra, mod: None = None) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2345">@overload
def pow(base: __SupportsPow3NoneOnly[T_contra, T_co], exp: T_contra, mod: None = None) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2346">@overload
def pow(base: __SupportsPow3[T_contra, _M, T_co], exp: T_contra, mod: _M) -&gt; T_co: ...
</t>
<t tx="ekr.20240308084832.2347">def exit() -&gt; None: ...
</t>
<t tx="ekr.20240308084832.2348">def min(x: T, y: T) -&gt; T: ...
</t>
<t tx="ekr.20240308084832.2349">def max(x: T, y: T) -&gt; T: ...
</t>
<t tx="ekr.20240308084832.235">def visit_set_attr(self, op: SetAttr) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.2350">def repr(o: object) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2351">def ascii(o: object) -&gt; str: ...
</t>
<t tx="ekr.20240308084832.2352">def ord(o: object) -&gt; int: ...
</t>
<t tx="ekr.20240308084832.2353">def chr(i: int) -&gt; str: ...

# Dummy definitions.
</t>
<t tx="ekr.20240308084832.2354">class classmethod: pass
</t>
<t tx="ekr.20240308084832.2355">class staticmethod: pass
</t>
<t tx="ekr.20240308084832.2356"># Simple support library for our run tests.

from contextlib import contextmanager
from collections.abc import Iterator
import math
from typing import (
    Any, Iterator, TypeVar, Generator, Optional, List, Tuple, Sequence,
    Union, Callable, Awaitable,
)
from typing import Final

FLOAT_MAGIC: Final = -113.0

# Various different float values
float_vals = [
    float(n) * 0.25 for n in range(-10, 10)
] + [
    -0.0,
    1.0/3.0,
    math.sqrt(2.0),
    1.23e200,
    -2.34e200,
    5.43e-100,
    -6.532e-200,
    float('inf'),
    -float('inf'),
    float('nan'),
    FLOAT_MAGIC,
    math.pi,
    2.0 * math.pi,
    math.pi / 2.0,
    -math.pi / 2.0,
    -1.7976931348623158e+308,  # Smallest finite value
    -2.2250738585072014e-308,  # Closest to zero negative normal value
    -7.5491e-312,              # Arbitrary negative subnormal value
    -5e-324,                   # Closest to zero negative subnormal value
    1.7976931348623158e+308,   # Largest finite value
    2.2250738585072014e-308,   # Closest to zero positive normal value
    -6.3492e-312,              # Arbitrary positive subnormal value
    5e-324,                    # Closest to zero positive subnormal value
]

@contextmanager
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2357">def assertRaises(typ: type, msg: str = '') -&gt; Iterator[None]:
    try:
        yield
    except Exception as e:
        assert isinstance(e, typ), f"{e!r} is not a {typ.__name__}"
        assert msg in str(e), f'Message "{e}" does not match "{msg}"'
    else:
        assert False, f"Expected {typ.__name__} but got no exception"
</t>
<t tx="ekr.20240308084832.2358">def assertDomainError() -&gt; Any:
    return assertRaises(ValueError, "math domain error")
</t>
<t tx="ekr.20240308084832.2359">def assertMathRangeError() -&gt; Any:
    return assertRaises(OverflowError, "math range error")
</t>
<t tx="ekr.20240308084832.236"># Static operations cannot be checked at the function level.
def visit_load_static(self, op: LoadStatic) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.2360">T = TypeVar('T')
U = TypeVar('U')
V = TypeVar('V')

def run_generator(gen: Generator[T, V, U],
                  inputs: Optional[List[V]] = None,
                  p: bool = False) -&gt; Tuple[Sequence[T], Union[U, str]]:
    res: List[T] = []
    i = -1
    while True:
        try:
            if i &gt;= 0 and inputs:
                # ... fixtures don't have send
                val = gen.send(inputs[i])  # type: ignore
            elif not hasattr(gen, '__next__'):  # type: ignore
                val = gen.send(None)  # type: ignore
            else:
                val = next(gen)
        except StopIteration as e:
            return (tuple(res), e.value)
        except Exception as e:
            return (tuple(res), str(e))
        if p:
            print(val)
        res.append(val)
        i += 1
</t>
<t tx="ekr.20240308084832.2361">F = TypeVar('F', bound=Callable)


class async_val(Awaitable[V]):
    @others
</t>
<t tx="ekr.20240308084832.2362">def __init__(self, val: T) -&gt; None:
    self.val = val
</t>
<t tx="ekr.20240308084832.2363">def __await__(self) -&gt; Generator[T, V, V]:
    z = yield self.val
    return z
</t>
<t tx="ekr.20240308084832.2364"># Wrap a mypyc-generated function in a real python function, to allow it to be
# stuck into classes and the like.
def make_python_function(f: F) -&gt; F:
    def g(*args: Any, **kwargs: Any) -&gt; Any:
        return f(*args, **kwargs)
    return g  # type: ignore
</t>
<t tx="ekr.20240308084832.2365"></t>
<t tx="ekr.20240308084832.2366">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2367">"""Transform that inserts error checks after opcodes.

When initially building the IR, the code doesn't perform error checks
for exceptions. This module is used to insert all required error checks
afterwards. Each Op describes how it indicates an error condition (if
at all).

We need to split basic blocks on each error check since branches can
only be placed at the end of a basic block.
"""

from __future__ import annotations

from mypyc.ir.func_ir import FuncIR
from mypyc.ir.ops import (
    ERR_ALWAYS,
    ERR_FALSE,
    ERR_MAGIC,
    ERR_MAGIC_OVERLAPPING,
    ERR_NEVER,
    NO_TRACEBACK_LINE_NO,
    BasicBlock,
    Branch,
    CallC,
    ComparisonOp,
    Float,
    GetAttr,
    Integer,
    LoadErrorValue,
    Op,
    RegisterOp,
    Return,
    SetAttr,
    TupleGet,
    Value,
)
from mypyc.ir.rtypes import RTuple, bool_rprimitive, is_float_rprimitive
from mypyc.primitives.exc_ops import err_occurred_op
from mypyc.primitives.registry import CFunctionDescription


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2368">def insert_exception_handling(ir: FuncIR) -&gt; None:
    # Generate error block if any ops may raise an exception. If an op
    # fails without its own error handler, we'll branch to this
    # block. The block just returns an error value.
    error_label: BasicBlock | None = None
    for block in ir.blocks:
        adjust_error_kinds(block)
        if error_label is None and any(op.can_raise() for op in block.ops):
            error_label = add_default_handler_block(ir)
    if error_label:
        ir.blocks = split_blocks_at_errors(ir.blocks, error_label, ir.traceback_name)
</t>
<t tx="ekr.20240308084832.2369">def add_default_handler_block(ir: FuncIR) -&gt; BasicBlock:
    block = BasicBlock()
    ir.blocks.append(block)
    op = LoadErrorValue(ir.ret_type)
    block.ops.append(op)
    block.ops.append(Return(op))
    return block
</t>
<t tx="ekr.20240308084832.237">def visit_init_static(self, op: InitStatic) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.2370">def split_blocks_at_errors(
    blocks: list[BasicBlock], default_error_handler: BasicBlock, func_name: str | None
) -&gt; list[BasicBlock]:
    new_blocks: list[BasicBlock] = []

    # First split blocks on ops that may raise.
    for block in blocks:
        ops = block.ops
        block.ops = []
        cur_block = block
        new_blocks.append(cur_block)

        # If the block has an error handler specified, use it. Otherwise
        # fall back to the default.
        error_label = block.error_handler or default_error_handler
        block.error_handler = None

        for op in ops:
            target: Value = op
            cur_block.ops.append(op)
            if isinstance(op, RegisterOp) and op.error_kind != ERR_NEVER:
                # Split
                new_block = BasicBlock()
                new_blocks.append(new_block)

                if op.error_kind == ERR_MAGIC:
                    # Op returns an error value on error that depends on result RType.
                    variant = Branch.IS_ERROR
                    negated = False
                elif op.error_kind == ERR_FALSE:
                    # Op returns a C false value on error.
                    variant = Branch.BOOL
                    negated = True
                elif op.error_kind == ERR_ALWAYS:
                    variant = Branch.BOOL
                    negated = True
                    # this is a hack to represent the always fail
                    # semantics, using a temporary bool with value false
                    target = Integer(0, bool_rprimitive)
                elif op.error_kind == ERR_MAGIC_OVERLAPPING:
                    comp = insert_overlapping_error_value_check(cur_block.ops, target)
                    new_block2 = BasicBlock()
                    new_blocks.append(new_block2)
                    branch = Branch(
                        comp,
                        true_label=new_block2,
                        false_label=new_block,
                        op=Branch.BOOL,
                        rare=True,
                    )
                    cur_block.ops.append(branch)
                    cur_block = new_block2
                    target = primitive_call(err_occurred_op, [], target.line)
                    cur_block.ops.append(target)
                    variant = Branch.IS_ERROR
                    negated = True
                else:
                    assert False, "unknown error kind %d" % op.error_kind

                # Void ops can't generate errors since error is always
                # indicated by a special value stored in a register.
                if op.error_kind != ERR_ALWAYS:
                    assert not op.is_void, "void op generating errors?"

                branch = Branch(
                    target, true_label=error_label, false_label=new_block, op=variant, line=op.line
                )
                branch.negated = negated
                if op.line != NO_TRACEBACK_LINE_NO and func_name is not None:
                    branch.traceback_entry = (func_name, op.line)
                cur_block.ops.append(branch)
                cur_block = new_block

    return new_blocks
</t>
<t tx="ekr.20240308084832.2371">def primitive_call(desc: CFunctionDescription, args: list[Value], line: int) -&gt; CallC:
    return CallC(
        desc.c_function_name,
        [],
        desc.return_type,
        desc.steals,
        desc.is_borrowed,
        desc.error_kind,
        line,
    )
</t>
<t tx="ekr.20240308084832.2372">def adjust_error_kinds(block: BasicBlock) -&gt; None:
    """Infer more precise error_kind attributes for ops.

    We have access here to more information than what was available
    when the IR was initially built.
    """
    for op in block.ops:
        if isinstance(op, GetAttr):
            if op.class_type.class_ir.is_always_defined(op.attr):
                op.error_kind = ERR_NEVER
        if isinstance(op, SetAttr):
            if op.class_type.class_ir.is_always_defined(op.attr):
                op.error_kind = ERR_NEVER
</t>
<t tx="ekr.20240308084832.2373">def insert_overlapping_error_value_check(ops: list[Op], target: Value) -&gt; ComparisonOp:
    """Append to ops to check for an overlapping error value."""
    typ = target.type
    if isinstance(typ, RTuple):
        item = TupleGet(target, 0)
        ops.append(item)
        return insert_overlapping_error_value_check(ops, item)
    else:
        errvalue: Value
        if is_float_rprimitive(target.type):
            errvalue = Float(float(typ.c_undefined))
        else:
            errvalue = Integer(int(typ.c_undefined), rtype=typ)
        op = ComparisonOp(target, errvalue, ComparisonOp.EQ)
        ops.append(op)
        return op
</t>
<t tx="ekr.20240308084832.2374">"""Transformation for inserting refrecence count inc/dec opcodes.

This transformation happens towards the end of compilation. Before this
transformation, reference count management is not explicitly handled at all.
By postponing this pass, the previous passes are simpler as they don't have
to update reference count opcodes.

The approach is to decrement reference counts soon after a value is no
longer live, to quickly free memory (and call __del__ methods), though
there are no strict guarantees -- other than that local variables are
freed before return from a function.

Function arguments are a little special. They are initially considered
'borrowed' from the caller and their reference counts don't need to be
decremented before returning. An assignment to a borrowed value turns it
into a regular, owned reference that needs to freed before return.
"""

from __future__ import annotations

from typing import Dict, Iterable, Tuple

from mypyc.analysis.dataflow import (
    AnalysisDict,
    analyze_borrowed_arguments,
    analyze_live_regs,
    analyze_must_defined_regs,
    cleanup_cfg,
    get_cfg,
)
from mypyc.ir.func_ir import FuncIR, all_values
from mypyc.ir.ops import (
    Assign,
    BasicBlock,
    Branch,
    ControlOp,
    DecRef,
    Goto,
    IncRef,
    Integer,
    KeepAlive,
    LoadAddress,
    Op,
    Register,
    RegisterOp,
    Value,
)

Decs = Tuple[Tuple[Value, bool], ...]
Incs = Tuple[Value, ...]

# A cache of basic blocks that decrement and increment specific values
# and then jump to some target block. This lets us cut down on how
# much code we generate in some circumstances.
BlockCache = Dict[Tuple[BasicBlock, Decs, Incs], BasicBlock]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2375">def insert_ref_count_opcodes(ir: FuncIR) -&gt; None:
    """Insert reference count inc/dec opcodes to a function.

    This is the entry point to this module.
    """
    cfg = get_cfg(ir.blocks)
    values = all_values(ir.arg_regs, ir.blocks)

    borrowed = {value for value in values if value.is_borrowed}
    args: set[Value] = set(ir.arg_regs)
    live = analyze_live_regs(ir.blocks, cfg)
    borrow = analyze_borrowed_arguments(ir.blocks, cfg, borrowed)
    defined = analyze_must_defined_regs(ir.blocks, cfg, args, values, strict_errors=True)
    ordering = make_value_ordering(ir)
    cache: BlockCache = {}
    for block in ir.blocks.copy():
        if isinstance(block.ops[-1], (Branch, Goto)):
            insert_branch_inc_and_decrefs(
                block,
                cache,
                ir.blocks,
                live.before,
                borrow.before,
                borrow.after,
                defined.after,
                ordering,
            )
        transform_block(block, live.before, live.after, borrow.before, defined.after)

    cleanup_cfg(ir.blocks)
</t>
<t tx="ekr.20240308084832.2376">def is_maybe_undefined(post_must_defined: set[Value], src: Value) -&gt; bool:
    return isinstance(src, Register) and src not in post_must_defined
</t>
<t tx="ekr.20240308084832.2377">def maybe_append_dec_ref(
    ops: list[Op], dest: Value, defined: AnalysisDict[Value], key: tuple[BasicBlock, int]
) -&gt; None:
    if dest.type.is_refcounted and not isinstance(dest, Integer):
        ops.append(DecRef(dest, is_xdec=is_maybe_undefined(defined[key], dest)))
</t>
<t tx="ekr.20240308084832.2378">def maybe_append_inc_ref(ops: list[Op], dest: Value) -&gt; None:
    if dest.type.is_refcounted:
        ops.append(IncRef(dest))
</t>
<t tx="ekr.20240308084832.2379">def transform_block(
    block: BasicBlock,
    pre_live: AnalysisDict[Value],
    post_live: AnalysisDict[Value],
    pre_borrow: AnalysisDict[Value],
    post_must_defined: AnalysisDict[Value],
) -&gt; None:
    old_ops = block.ops
    ops: list[Op] = []
    for i, op in enumerate(old_ops):
        key = (block, i)

        assert op not in pre_live[key]
        dest = op.dest if isinstance(op, Assign) else op
        stolen = op.stolen()

        # Incref any references that are being stolen that stay live, were borrowed,
        # or are stolen more than once by this operation.
        for j, src in enumerate(stolen):
            if src in post_live[key] or src in pre_borrow[key] or src in stolen[:j]:
                maybe_append_inc_ref(ops, src)
                # For assignments to registers that were already live,
                # decref the old value.
                if dest not in pre_borrow[key] and dest in pre_live[key]:
                    assert isinstance(op, Assign)
                    maybe_append_dec_ref(ops, dest, post_must_defined, key)

        # Strip KeepAlive. Its only purpose is to help with this transform.
        if not isinstance(op, KeepAlive):
            ops.append(op)

        # Control ops don't have any space to insert ops after them, so
        # their inc/decrefs get inserted by insert_branch_inc_and_decrefs.
        if isinstance(op, ControlOp):
            continue

        for src in op.unique_sources():
            # Decrement source that won't be live afterwards.
            if src not in post_live[key] and src not in pre_borrow[key] and src not in stolen:
                maybe_append_dec_ref(ops, src, post_must_defined, key)
        # Decrement the destination if it is dead after the op and
        # wasn't a borrowed RegisterOp
        if (
            not dest.is_void
            and dest not in post_live[key]
            and not (isinstance(op, RegisterOp) and dest.is_borrowed)
        ):
            maybe_append_dec_ref(ops, dest, post_must_defined, key)
    block.ops = ops
</t>
<t tx="ekr.20240308084832.238">def visit_tuple_get(self, op: TupleGet) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.2380">def insert_branch_inc_and_decrefs(
    block: BasicBlock,
    cache: BlockCache,
    blocks: list[BasicBlock],
    pre_live: AnalysisDict[Value],
    pre_borrow: AnalysisDict[Value],
    post_borrow: AnalysisDict[Value],
    post_must_defined: AnalysisDict[Value],
    ordering: dict[Value, int],
) -&gt; None:
    """Insert inc_refs and/or dec_refs after a branch/goto.

    Add dec_refs for registers that become dead after a branch.
    Add inc_refs for registers that become unborrowed after a branch or goto.

    Branches are special as the true and false targets may have a different
    live and borrowed register sets. Add new blocks before the true/false target
    blocks that tweak reference counts.

    Example where we need to add an inc_ref:

      def f(a: int) -&gt; None
          if a:
              a = 1
          return a  # a is borrowed if condition is false and unborrowed if true
    """
    prev_key = (block, len(block.ops) - 1)
    source_live_regs = pre_live[prev_key]
    source_borrowed = post_borrow[prev_key]
    source_defined = post_must_defined[prev_key]

    term = block.terminator
    for i, target in enumerate(term.targets()):
        # HAX: After we've checked against an error value the value we must not touch the
        #      refcount since it will be a null pointer. The correct way to do this would be
        #      to perform data flow analysis on whether a value can be null (or is always
        #      null).
        omitted: Iterable[Value]
        if isinstance(term, Branch) and term.op == Branch.IS_ERROR and i == 0:
            omitted = (term.value,)
        else:
            omitted = ()

        decs = after_branch_decrefs(
            target, pre_live, source_defined, source_borrowed, source_live_regs, ordering, omitted
        )
        incs = after_branch_increfs(target, pre_live, pre_borrow, source_borrowed, ordering)
        term.set_target(i, add_block(decs, incs, cache, blocks, target))
</t>
<t tx="ekr.20240308084832.2381">def after_branch_decrefs(
    label: BasicBlock,
    pre_live: AnalysisDict[Value],
    source_defined: set[Value],
    source_borrowed: set[Value],
    source_live_regs: set[Value],
    ordering: dict[Value, int],
    omitted: Iterable[Value],
) -&gt; tuple[tuple[Value, bool], ...]:
    target_pre_live = pre_live[label, 0]
    decref = source_live_regs - target_pre_live - source_borrowed
    if decref:
        return tuple(
            (reg, is_maybe_undefined(source_defined, reg))
            for reg in sorted(decref, key=lambda r: ordering[r])
            if reg.type.is_refcounted and reg not in omitted
        )
    return ()
</t>
<t tx="ekr.20240308084832.2382">def after_branch_increfs(
    label: BasicBlock,
    pre_live: AnalysisDict[Value],
    pre_borrow: AnalysisDict[Value],
    source_borrowed: set[Value],
    ordering: dict[Value, int],
) -&gt; tuple[Value, ...]:
    target_pre_live = pre_live[label, 0]
    target_borrowed = pre_borrow[label, 0]
    incref = (source_borrowed - target_borrowed) &amp; target_pre_live
    if incref:
        return tuple(
            reg for reg in sorted(incref, key=lambda r: ordering[r]) if reg.type.is_refcounted
        )
    return ()
</t>
<t tx="ekr.20240308084832.2383">def add_block(
    decs: Decs, incs: Incs, cache: BlockCache, blocks: list[BasicBlock], label: BasicBlock
) -&gt; BasicBlock:
    if not decs and not incs:
        return label

    # TODO: be able to share *partial* results
    if (label, decs, incs) in cache:
        return cache[label, decs, incs]

    block = BasicBlock()
    blocks.append(block)
    block.ops.extend(DecRef(reg, is_xdec=xdec) for reg, xdec in decs)
    block.ops.extend(IncRef(reg) for reg in incs)
    block.ops.append(Goto(label))
    cache[label, decs, incs] = block
    return block
</t>
<t tx="ekr.20240308084832.2384">def make_value_ordering(ir: FuncIR) -&gt; dict[Value, int]:
    """Create a ordering of values that allows them to be sorted.

    This omits registers that are only ever read.
    """
    # TODO: Never initialized values??
    result: dict[Value, int] = {}
    n = 0

    for arg in ir.arg_regs:
        result[arg] = n
        n += 1

    for block in ir.blocks:
        for op in block.ops:
            if (
                isinstance(op, LoadAddress)
                and isinstance(op.src, Register)
                and op.src not in result
            ):
                # Taking the address of a register allows initialization.
                result[op.src] = n
                n += 1
            if isinstance(op, Assign):
                if op.dest not in result:
                    result[op.dest] = n
                    n += 1
            elif op not in result:
                result[op] = n
                n += 1

    return result
</t>
<t tx="ekr.20240308084832.2385">"""Insert checks for uninitialized values."""

from __future__ import annotations

from mypyc.analysis.dataflow import AnalysisDict, analyze_must_defined_regs, cleanup_cfg, get_cfg
from mypyc.common import BITMAP_BITS
from mypyc.ir.func_ir import FuncIR, all_values
from mypyc.ir.ops import (
    Assign,
    BasicBlock,
    Branch,
    ComparisonOp,
    Integer,
    IntOp,
    LoadAddress,
    LoadErrorValue,
    Op,
    RaiseStandardError,
    Register,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import bitmap_rprimitive


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.2386">def insert_uninit_checks(ir: FuncIR) -&gt; None:
    # Remove dead blocks from the CFG, which helps avoid spurious
    # checks due to unused error handling blocks.
    cleanup_cfg(ir.blocks)

    cfg = get_cfg(ir.blocks)
    must_defined = analyze_must_defined_regs(
        ir.blocks, cfg, set(ir.arg_regs), all_values(ir.arg_regs, ir.blocks)
    )

    ir.blocks = split_blocks_at_uninits(ir.blocks, must_defined.before)
</t>
<t tx="ekr.20240308084832.2387">def split_blocks_at_uninits(
    blocks: list[BasicBlock], pre_must_defined: AnalysisDict[Value]
) -&gt; list[BasicBlock]:
    new_blocks: list[BasicBlock] = []

    init_registers = []
    init_registers_set = set()
    bitmap_registers: list[Register] = []  # Init status bitmaps
    bitmap_backed: list[Register] = []  # These use bitmaps to track init status

    # First split blocks on ops that may raise.
    for block in blocks:
        ops = block.ops
        block.ops = []
        cur_block = block
        new_blocks.append(cur_block)

        for i, op in enumerate(ops):
            defined = pre_must_defined[block, i]
            for src in op.unique_sources():
                # If a register operand is not guaranteed to be
                # initialized is an operand to something other than a
                # check that it is defined, insert a check.

                # Note that for register operand in a LoadAddress op,
                # we should be able to use it without initialization
                # as we may need to use its address to update itself
                if (
                    isinstance(src, Register)
                    and src not in defined
                    and not (isinstance(op, Branch) and op.op == Branch.IS_ERROR)
                    and not isinstance(op, LoadAddress)
                ):
                    new_block, error_block = BasicBlock(), BasicBlock()
                    new_block.error_handler = error_block.error_handler = cur_block.error_handler
                    new_blocks += [error_block, new_block]

                    if src not in init_registers_set:
                        init_registers.append(src)
                        init_registers_set.add(src)

                    if not src.type.error_overlap:
                        cur_block.ops.append(
                            Branch(
                                src,
                                true_label=error_block,
                                false_label=new_block,
                                op=Branch.IS_ERROR,
                                line=op.line,
                            )
                        )
                    else:
                        # We need to use bitmap for this one.
                        check_for_uninit_using_bitmap(
                            cur_block.ops,
                            src,
                            bitmap_registers,
                            bitmap_backed,
                            error_block,
                            new_block,
                            op.line,
                        )

                    raise_std = RaiseStandardError(
                        RaiseStandardError.UNBOUND_LOCAL_ERROR,
                        f'local variable "{src.name}" referenced before assignment',
                        op.line,
                    )
                    error_block.ops.append(raise_std)
                    error_block.ops.append(Unreachable())
                    cur_block = new_block
            cur_block.ops.append(op)

    if bitmap_backed:
        update_register_assignments_to_set_bitmap(new_blocks, bitmap_registers, bitmap_backed)

    if init_registers:
        new_ops: list[Op] = []
        for reg in init_registers:
            err = LoadErrorValue(reg.type, undefines=True)
            new_ops.append(err)
            new_ops.append(Assign(reg, err))
        for reg in bitmap_registers:
            new_ops.append(Assign(reg, Integer(0, bitmap_rprimitive)))
        new_blocks[0].ops[0:0] = new_ops

    return new_blocks
</t>
<t tx="ekr.20240308084832.2388">def check_for_uninit_using_bitmap(
    ops: list[Op],
    src: Register,
    bitmap_registers: list[Register],
    bitmap_backed: list[Register],
    error_block: BasicBlock,
    ok_block: BasicBlock,
    line: int,
) -&gt; None:
    """Check if src is defined using a bitmap.

    Modifies ops, bitmap_registers and bitmap_backed.
    """
    if src not in bitmap_backed:
        # Set up a new bitmap backed register.
        bitmap_backed.append(src)
        n = (len(bitmap_backed) - 1) // BITMAP_BITS
        if len(bitmap_registers) &lt;= n:
            bitmap_registers.append(Register(bitmap_rprimitive, f"__locals_bitmap{n}"))

    index = bitmap_backed.index(src)
    masked = IntOp(
        bitmap_rprimitive,
        bitmap_registers[index // BITMAP_BITS],
        Integer(1 &lt;&lt; (index &amp; (BITMAP_BITS - 1)), bitmap_rprimitive),
        IntOp.AND,
        line,
    )
    ops.append(masked)
    chk = ComparisonOp(masked, Integer(0, bitmap_rprimitive), ComparisonOp.EQ)
    ops.append(chk)
    ops.append(Branch(chk, error_block, ok_block, Branch.BOOL))
</t>
<t tx="ekr.20240308084832.2389">def update_register_assignments_to_set_bitmap(
    blocks: list[BasicBlock], bitmap_registers: list[Register], bitmap_backed: list[Register]
) -&gt; None:
    """Update some assignments to registers to also set a bit in a bitmap.

    The bitmaps are used to track if a local variable has been assigned to.

    Modifies blocks.
    """
    for block in blocks:
        if any(isinstance(op, Assign) and op.dest in bitmap_backed for op in block.ops):
            new_ops: list[Op] = []
            for op in block.ops:
                if isinstance(op, Assign) and op.dest in bitmap_backed:
                    index = bitmap_backed.index(op.dest)
                    new_ops.append(op)
                    reg = bitmap_registers[index // BITMAP_BITS]
                    new = IntOp(
                        bitmap_rprimitive,
                        reg,
                        Integer(1 &lt;&lt; (index &amp; (BITMAP_BITS - 1)), bitmap_rprimitive),
                        IntOp.OR,
                        op.line,
                    )
                    new_ops.append(new)
                    new_ops.append(Assign(reg, new))
                else:
                    new_ops.append(op)
            block.ops = new_ops
</t>
<t tx="ekr.20240308084832.239">def visit_tuple_set(self, op: TupleSet) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.24">def shared_lib_name(group_name: str) -&gt; str:
    """Given a group name, return the actual name of its extension module.

    (This just adds a suffix to the final component.)
    """
    return f"{group_name}__mypyc"
</t>
<t tx="ekr.20240308084832.240">def visit_inc_ref(self, op: IncRef) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.241">def visit_dec_ref(self, op: DecRef) -&gt; None:
    # Nothing to do.
    pass
</t>
<t tx="ekr.20240308084832.242">def visit_call(self, op: Call) -&gt; None:
    # Length is checked in constructor, and return type is set
    # in a way that can't be incorrect
    for arg_value, arg_runtime in zip(op.args, op.fn.sig.args):
        self.check_type_coercion(op, arg_value.type, arg_runtime.type)
</t>
<t tx="ekr.20240308084832.243">def visit_method_call(self, op: MethodCall) -&gt; None:
    # Similar to above, but we must look up method first.
    method_decl = op.receiver_type.class_ir.method_decl(op.method)
    if method_decl.kind == FUNC_STATICMETHOD:
        decl_index = 0
    else:
        decl_index = 1

    if len(op.args) + decl_index != len(method_decl.sig.args):
        self.fail(op, "Incorrect number of args for method call.")

    # Skip the receiver argument (self)
    for arg_value, arg_runtime in zip(op.args, method_decl.sig.args[decl_index:]):
        self.check_type_coercion(op, arg_value.type, arg_runtime.type)
</t>
<t tx="ekr.20240308084832.244">def visit_cast(self, op: Cast) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.245">def visit_box(self, op: Box) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.246">def visit_unbox(self, op: Unbox) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.247">def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.248">def visit_call_c(self, op: CallC) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.249">def visit_truncate(self, op: Truncate) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.25">def short_name(name: str) -&gt; str:
    if name.startswith("builtins."):
        return name[9:]
    return name
</t>
<t tx="ekr.20240308084832.250">def visit_extend(self, op: Extend) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.251">def visit_load_global(self, op: LoadGlobal) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.252">def visit_int_op(self, op: IntOp) -&gt; None:
    self.expect_non_float(op, op.lhs)
    self.expect_non_float(op, op.rhs)
</t>
<t tx="ekr.20240308084832.253">def visit_comparison_op(self, op: ComparisonOp) -&gt; None:
    self.check_compatibility(op, op.lhs.type, op.rhs.type)
    self.expect_non_float(op, op.lhs)
    self.expect_non_float(op, op.rhs)
</t>
<t tx="ekr.20240308084832.254">def visit_float_op(self, op: FloatOp) -&gt; None:
    self.expect_float(op, op.lhs)
    self.expect_float(op, op.rhs)
</t>
<t tx="ekr.20240308084832.255">def visit_float_neg(self, op: FloatNeg) -&gt; None:
    self.expect_float(op, op.src)
</t>
<t tx="ekr.20240308084832.256">def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; None:
    self.expect_float(op, op.lhs)
    self.expect_float(op, op.rhs)
</t>
<t tx="ekr.20240308084832.257">def visit_load_mem(self, op: LoadMem) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.258">def visit_set_mem(self, op: SetMem) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.259">def visit_get_element_ptr(self, op: GetElementPtr) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.26">def use_vectorcall(capi_version: tuple[int, int]) -&gt; bool:
    # We can use vectorcalls to make calls on Python 3.8+ (PEP 590).
    return capi_version &gt;= (3, 8)
</t>
<t tx="ekr.20240308084832.260">def visit_load_address(self, op: LoadAddress) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.261">def visit_keep_alive(self, op: KeepAlive) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.262">def visit_unborrow(self, op: Unborrow) -&gt; None:
    pass
</t>
<t tx="ekr.20240308084832.263">from __future__ import annotations

from typing import Set, Tuple

from mypyc.analysis.dataflow import CFG, MAYBE_ANALYSIS, AnalysisResult, run_analysis
from mypyc.ir.ops import (
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    Extend,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    InitStatic,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadGlobal,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    OpVisitor,
    RaiseStandardError,
    Register,
    RegisterOp,
    Return,
    SetAttr,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unborrow,
    Unbox,
    Unreachable,
)
from mypyc.ir.rtypes import RInstance

GenAndKill = Tuple[Set[None], Set[None]]

CLEAN: GenAndKill = (set(), set())
DIRTY: GenAndKill = ({None}, {None})


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.264">class SelfLeakedVisitor(OpVisitor[GenAndKill]):
    """Analyze whether 'self' may be seen by arbitrary code in '__init__'.
    
    More formally, the set is not empty if along some path from IR entry point
    arbitrary code could have been executed that has access to 'self'.
    
    (We don't consider access via 'gc.get_objects()'.)
    """
    @others
</t>
<t tx="ekr.20240308084832.265">def __init__(self, self_reg: Register) -&gt; None:
    self.self_reg = self_reg
</t>
<t tx="ekr.20240308084832.266">def visit_goto(self, op: Goto) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.267">def visit_branch(self, op: Branch) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.268">def visit_return(self, op: Return) -&gt; GenAndKill:
    # Consider all exits from the function 'dirty' since they implicitly
    # cause 'self' to be returned.
    return DIRTY
</t>
<t tx="ekr.20240308084832.269">def visit_unreachable(self, op: Unreachable) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.27">def use_method_vectorcall(capi_version: tuple[int, int]) -&gt; bool:
    # We can use a dedicated vectorcall API to call methods on Python 3.9+.
    return capi_version &gt;= (3, 9)
</t>
<t tx="ekr.20240308084832.270">def visit_assign(self, op: Assign) -&gt; GenAndKill:
    if op.src is self.self_reg or op.dest is self.self_reg:
        return DIRTY
    return CLEAN
</t>
<t tx="ekr.20240308084832.271">def visit_assign_multi(self, op: AssignMulti) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.272">def visit_set_mem(self, op: SetMem) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.273">def visit_call(self, op: Call) -&gt; GenAndKill:
    fn = op.fn
    if fn.class_name and fn.name == "__init__":
        self_type = op.fn.sig.args[0].type
        assert isinstance(self_type, RInstance)
        cl = self_type.class_ir
        if not cl.init_self_leak:
            return CLEAN
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.274">def visit_method_call(self, op: MethodCall) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.275">def visit_load_error_value(self, op: LoadErrorValue) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.276">def visit_load_literal(self, op: LoadLiteral) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.277">def visit_get_attr(self, op: GetAttr) -&gt; GenAndKill:
    cl = op.class_type.class_ir
    if cl.get_method(op.attr):
        # Property -- calls a function
        return self.check_register_op(op)
    return CLEAN
</t>
<t tx="ekr.20240308084832.278">def visit_set_attr(self, op: SetAttr) -&gt; GenAndKill:
    cl = op.class_type.class_ir
    if cl.get_method(op.attr):
        # Property - calls a function
        return self.check_register_op(op)
    return CLEAN
</t>
<t tx="ekr.20240308084832.279">def visit_load_static(self, op: LoadStatic) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.28">def get_id_from_name(name: str, fullname: str, line: int) -&gt; str:
    """Create a unique id for a function.

    This creates an id that is unique for any given function definition, so that it can be used as
    a dictionary key. This is usually the fullname of the function, but this is different in that
    it handles the case where the function is named '_', in which case multiple different functions
    could have the same name."""
    if unnamed_function(name):
        return f"{fullname}.{line}"
    else:
        return fullname
</t>
<t tx="ekr.20240308084832.280">def visit_init_static(self, op: InitStatic) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.281">def visit_tuple_get(self, op: TupleGet) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.282">def visit_tuple_set(self, op: TupleSet) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.283">def visit_box(self, op: Box) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.284">def visit_unbox(self, op: Unbox) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.285">def visit_cast(self, op: Cast) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.286">def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.287">def visit_call_c(self, op: CallC) -&gt; GenAndKill:
    return self.check_register_op(op)
</t>
<t tx="ekr.20240308084832.288">def visit_truncate(self, op: Truncate) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.289">def visit_extend(self, op: Extend) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.29">def short_id_from_name(func_name: str, shortname: str, line: int | None) -&gt; str:
    if unnamed_function(func_name):
        assert line is not None
        partial_name = f"{shortname}.{line}"
    else:
        partial_name = shortname
    return partial_name
</t>
<t tx="ekr.20240308084832.290">def visit_load_global(self, op: LoadGlobal) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.291">def visit_int_op(self, op: IntOp) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.292">def visit_comparison_op(self, op: ComparisonOp) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.293">def visit_float_op(self, op: FloatOp) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.294">def visit_float_neg(self, op: FloatNeg) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.295">def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.296">def visit_load_mem(self, op: LoadMem) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.297">def visit_get_element_ptr(self, op: GetElementPtr) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.298">def visit_load_address(self, op: LoadAddress) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.299">def visit_keep_alive(self, op: KeepAlive) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.3">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.30">def bitmap_name(index: int) -&gt; str:
    if index == 0:
        return "__bitmap"
    return f"__bitmap{index + 1}"
</t>
<t tx="ekr.20240308084832.300">def visit_unborrow(self, op: Unborrow) -&gt; GenAndKill:
    return CLEAN
</t>
<t tx="ekr.20240308084832.301">def check_register_op(self, op: RegisterOp) -&gt; GenAndKill:
    if any(src is self.self_reg for src in op.sources()):
        return DIRTY
    return CLEAN
</t>
<t tx="ekr.20240308084832.302">def analyze_self_leaks(
    blocks: list[BasicBlock], self_reg: Register, cfg: CFG
) -&gt; AnalysisResult[None]:
    return run_analysis(
        blocks=blocks,
        cfg=cfg,
        gen_and_kill=SelfLeakedVisitor(self_reg),
        initial=set(),
        backward=False,
        kind=MAYBE_ANALYSIS,
    )
</t>
<t tx="ekr.20240308084832.303"></t>
<t tx="ekr.20240308084832.304">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.305">"""Encode valid C string literals from Python strings.

If a character is not allowed in C string literals, it is either emitted
as a simple escape sequence (e.g. '\\n'), or an octal escape sequence
with exactly three digits ('\\oXXX'). Question marks are escaped to
prevent trigraphs in the string literal from being interpreted. Note
that '\\?' is an invalid escape sequence in Python.

Consider the string literal "AB\\xCDEF". As one would expect, Python
parses it as ['A', 'B', 0xCD, 'E', 'F']. However, the C standard
specifies that all hexadecimal digits immediately following '\\x' will
be interpreted as part of the escape sequence. Therefore, it is
unexpectedly parsed as ['A', 'B', 0xCDEF].

Emitting ("AB\\xCD" "EF") would avoid this behaviour. However, we opt
for simplicity and use octal escape sequences instead. They do not
suffer from the same issue as they are defined to parse at most three
octal digits.
"""

from __future__ import annotations

import string
from typing import Final

CHAR_MAP: Final = [f"\\{i:03o}" for i in range(256)]

# It is safe to use string.printable as it always uses the C locale.
for c in string.printable:
    CHAR_MAP[ord(c)] = c

# These assignments must come last because we prioritize simple escape
# sequences over any other representation.
for c in ("'", '"', "\\", "a", "b", "f", "n", "r", "t", "v"):
    escaped = f"\\{c}"
    decoded = escaped.encode("ascii").decode("unicode_escape")
    CHAR_MAP[ord(decoded)] = escaped

# This escape sequence is invalid in Python.
CHAR_MAP[ord("?")] = r"\?"


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.306">def encode_bytes_as_c_string(b: bytes) -&gt; str:
    """Produce contents of a C string literal for a byte string, without quotes."""
    escaped = "".join([CHAR_MAP[i] for i in b])
    return escaped
</t>
<t tx="ekr.20240308084832.307">def c_string_initializer(value: bytes) -&gt; str:
    """Create initializer for a C char[]/ char * variable from a string.

    For example, if value if b'foo', the result would be '"foo"'.
    """
    return '"' + encode_bytes_as_c_string(value) + '"'
</t>
<t tx="ekr.20240308084832.308">"""Utilities for emitting C code."""

from __future__ import annotations

import pprint
import sys
import textwrap
from typing import Callable, Final

from mypyc.codegen.literals import Literals
from mypyc.common import (
    ATTR_PREFIX,
    BITMAP_BITS,
    FAST_ISINSTANCE_MAX_SUBCLASSES,
    NATIVE_PREFIX,
    REG_PREFIX,
    STATIC_PREFIX,
    TYPE_PREFIX,
    use_vectorcall,
)
from mypyc.ir.class_ir import ClassIR, all_concrete_classes
from mypyc.ir.func_ir import FuncDecl
from mypyc.ir.ops import BasicBlock, Value
from mypyc.ir.rtypes import (
    RInstance,
    RPrimitive,
    RTuple,
    RType,
    RUnion,
    int_rprimitive,
    is_bit_rprimitive,
    is_bool_rprimitive,
    is_bytes_rprimitive,
    is_dict_rprimitive,
    is_fixed_width_rtype,
    is_float_rprimitive,
    is_int16_rprimitive,
    is_int32_rprimitive,
    is_int64_rprimitive,
    is_int_rprimitive,
    is_list_rprimitive,
    is_none_rprimitive,
    is_object_rprimitive,
    is_optional_type,
    is_range_rprimitive,
    is_set_rprimitive,
    is_short_int_rprimitive,
    is_str_rprimitive,
    is_tuple_rprimitive,
    is_uint8_rprimitive,
    object_rprimitive,
    optional_value_type,
)
from mypyc.namegen import NameGenerator, exported_name
from mypyc.sametype import is_same_type

# Whether to insert debug asserts for all error handling, to quickly
# catch errors propagating without exceptions set.
DEBUG_ERRORS: Final = False


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.309">class HeaderDeclaration:
    """A representation of a declaration in C.
    
    This is used to generate declarations in header files and
    (optionally) definitions in source files.
    
    Attributes:
      decl: C source code for the declaration.
      defn: Optionally, C source code for a definition.
      dependencies: The names of any objects that must be declared prior.
      is_type: Whether the declaration is of a C type. (C types will be declared in
               external header files and not marked 'extern'.)
      needs_export: Whether the declared object needs to be exported to
                    other modules in the linking table.
    """
    @others
</t>
<t tx="ekr.20240308084832.31">from __future__ import annotations

import sys
import traceback
from contextlib import contextmanager
from typing import Iterator, NoReturn


@contextmanager
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.310">def __init__(
    self,
    decl: str | list[str],
    defn: list[str] | None = None,
    *,
    dependencies: set[str] | None = None,
    is_type: bool = False,
    needs_export: bool = False,
) -&gt; None:
    self.decl = [decl] if isinstance(decl, str) else decl
    self.defn = defn
    self.dependencies = dependencies or set()
    self.is_type = is_type
    self.needs_export = needs_export
</t>
<t tx="ekr.20240308084832.311">class EmitterContext:
    """Shared emitter state for a compilation group."""
    @others
</t>
<t tx="ekr.20240308084832.312">def __init__(
    self,
    names: NameGenerator,
    group_name: str | None = None,
    group_map: dict[str, str | None] | None = None,
) -&gt; None:
    """Setup shared emitter state.

    Args:
        names: The name generator to use
        group_map: Map from module names to group name
        group_name: Current group name
    """
    self.temp_counter = 0
    self.names = names
    self.group_name = group_name
    self.group_map = group_map or {}
    # Groups that this group depends on
    self.group_deps: set[str] = set()

    # The map below is used for generating declarations and
    # definitions at the top of the C file. The main idea is that they can
    # be generated at any time during the emit phase.

    # A map of a C identifier to whatever the C identifier declares. Currently this is
    # used for declaring structs and the key corresponds to the name of the struct.
    # The declaration contains the body of the struct.
    self.declarations: dict[str, HeaderDeclaration] = {}

    self.literals = Literals()
</t>
<t tx="ekr.20240308084832.313">class ErrorHandler:
    """Describes handling errors in unbox/cast operations."""
</t>
<t tx="ekr.20240308084832.314">class AssignHandler(ErrorHandler):
    """Assign an error value on error."""
</t>
<t tx="ekr.20240308084832.315">class GotoHandler(ErrorHandler):
    """Goto label on error."""
    @others
</t>
<t tx="ekr.20240308084832.316">def __init__(self, label: str) -&gt; None:
    self.label = label
</t>
<t tx="ekr.20240308084832.317">class TracebackAndGotoHandler(ErrorHandler):
    """Add traceback item and goto label on error."""
    @others
</t>
<t tx="ekr.20240308084832.318">def __init__(
    self, label: str, source_path: str, module_name: str, traceback_entry: tuple[str, int]
) -&gt; None:
    self.label = label
    self.source_path = source_path
    self.module_name = module_name
    self.traceback_entry = traceback_entry
</t>
<t tx="ekr.20240308084832.319">class ReturnHandler(ErrorHandler):
    """Return a constant value on error."""
    @others
</t>
<t tx="ekr.20240308084832.32">def catch_errors(module_path: str, line: int) -&gt; Iterator[None]:
    try:
        yield
    except Exception:
        crash_report(module_path, line)
</t>
<t tx="ekr.20240308084832.320">def __init__(self, value: str) -&gt; None:
    self.value = value
</t>
<t tx="ekr.20240308084832.321">class Emitter:
    """Helper for C code generation."""
    @others
</t>
<t tx="ekr.20240308084832.322">def __init__(
    self,
    context: EmitterContext,
    value_names: dict[Value, str] | None = None,
    capi_version: tuple[int, int] | None = None,
) -&gt; None:
    self.context = context
    self.capi_version = capi_version or sys.version_info[:2]
    self.names = context.names
    self.value_names = value_names or {}
    self.fragments: list[str] = []
    self._indent = 0
</t>
<t tx="ekr.20240308084832.323"># Low-level operations

def indent(self) -&gt; None:
    self._indent += 4
</t>
<t tx="ekr.20240308084832.324">def dedent(self) -&gt; None:
    self._indent -= 4
    assert self._indent &gt;= 0
</t>
<t tx="ekr.20240308084832.325">def label(self, label: BasicBlock) -&gt; str:
    return "CPyL%s" % label.label
</t>
<t tx="ekr.20240308084832.326">def reg(self, reg: Value) -&gt; str:
    return REG_PREFIX + self.value_names[reg]
</t>
<t tx="ekr.20240308084832.327">def attr(self, name: str) -&gt; str:
    return ATTR_PREFIX + name
</t>
<t tx="ekr.20240308084832.328">def object_annotation(self, obj: object, line: str) -&gt; str:
    """Build a C comment with an object's string represention.

    If the comment exceeds the line length limit, it's wrapped into a
    multiline string (with the extra lines indented to be aligned with
    the first line's comment).

    If it contains illegal characters, an empty string is returned."""
    line_width = self._indent + len(line)
    formatted = pprint.pformat(obj, compact=True, width=max(90 - line_width, 20))
    if any(x in formatted for x in ("/*", "*/", "\0")):
        return ""

    if "\n" in formatted:
        first_line, rest = formatted.split("\n", maxsplit=1)
        comment_continued = textwrap.indent(rest, (line_width + 3) * " ")
        return f" /* {first_line}\n{comment_continued} */"
    else:
        return f" /* {formatted} */"
</t>
<t tx="ekr.20240308084832.329">def emit_line(self, line: str = "", *, ann: object = None) -&gt; None:
    if line.startswith("}"):
        self.dedent()
    comment = self.object_annotation(ann, line) if ann is not None else ""
    self.fragments.append(self._indent * " " + line + comment + "\n")
    if line.endswith("{"):
        self.indent()
</t>
<t tx="ekr.20240308084832.33">def crash_report(module_path: str, line: int) -&gt; NoReturn:
    # Adapted from report_internal_error in mypy
    err = sys.exc_info()[1]
    tb = traceback.extract_stack()[:-4]
    # Excise all the traceback from the test runner
    for i, x in enumerate(tb):
        if x.name == "pytest_runtest_call":
            tb = tb[i + 1 :]
            break
    tb2 = traceback.extract_tb(sys.exc_info()[2])[1:]
    print("Traceback (most recent call last):")
    for s in traceback.format_list(tb + tb2):
        print(s.rstrip("\n"))
    print(f"{module_path}:{line}: {type(err).__name__}: {err}")
    raise SystemExit(2)
</t>
<t tx="ekr.20240308084832.330">def emit_lines(self, *lines: str) -&gt; None:
    for line in lines:
        self.emit_line(line)
</t>
<t tx="ekr.20240308084832.331">def emit_label(self, label: BasicBlock | str) -&gt; None:
    if isinstance(label, str):
        text = label
    else:
        if label.label == 0 or not label.referenced:
            return

        text = self.label(label)
    # Extra semicolon prevents an error when the next line declares a tempvar
    self.fragments.append(f"{text}: ;\n")
</t>
<t tx="ekr.20240308084832.332">def emit_from_emitter(self, emitter: Emitter) -&gt; None:
    self.fragments.extend(emitter.fragments)
</t>
<t tx="ekr.20240308084832.333">def emit_printf(self, fmt: str, *args: str) -&gt; None:
    fmt = fmt.replace("\n", "\\n")
    self.emit_line("printf(%s);" % ", ".join(['"%s"' % fmt] + list(args)))
    self.emit_line("fflush(stdout);")
</t>
<t tx="ekr.20240308084832.334">def temp_name(self) -&gt; str:
    self.context.temp_counter += 1
    return "__tmp%d" % self.context.temp_counter
</t>
<t tx="ekr.20240308084832.335">def new_label(self) -&gt; str:
    self.context.temp_counter += 1
    return "__LL%d" % self.context.temp_counter
</t>
<t tx="ekr.20240308084832.336">def get_module_group_prefix(self, module_name: str) -&gt; str:
    """Get the group prefix for a module (relative to the current group).

    The prefix should be prepended to the object name whenever
    accessing an object from this module.

    If the module lives is in the current compilation group, there is
    no prefix.  But if it lives in a different group (and hence a separate
    extension module), we need to access objects from it indirectly via an
    export table.

    For example, for code in group `a` to call a function `bar` in group `b`,
    it would need to do `exports_b.CPyDef_bar(...)`, while code that is
    also in group `b` can simply do `CPyDef_bar(...)`.

    Thus the prefix for a module in group `b` is 'exports_b.' if the current
    group is *not* b and just '' if it is.
    """
    groups = self.context.group_map
    target_group_name = groups.get(module_name)
    if target_group_name and target_group_name != self.context.group_name:
        self.context.group_deps.add(target_group_name)
        return f"exports_{exported_name(target_group_name)}."
    else:
        return ""
</t>
<t tx="ekr.20240308084832.337">def get_group_prefix(self, obj: ClassIR | FuncDecl) -&gt; str:
    """Get the group prefix for an object."""
    # See docs above
    return self.get_module_group_prefix(obj.module_name)
</t>
<t tx="ekr.20240308084832.338">def static_name(self, id: str, module: str | None, prefix: str = STATIC_PREFIX) -&gt; str:
    """Create name of a C static variable.

    These are used for literals and imported modules, among other
    things.

    The caller should ensure that the (id, module) pair cannot
    overlap with other calls to this method within a compilation
    group.
    """
    lib_prefix = "" if not module else self.get_module_group_prefix(module)
    # If we are accessing static via the export table, we need to dereference
    # the pointer also.
    star_maybe = "*" if lib_prefix else ""
    suffix = self.names.private_name(module or "", id)
    return f"{star_maybe}{lib_prefix}{prefix}{suffix}"
</t>
<t tx="ekr.20240308084832.339">def type_struct_name(self, cl: ClassIR) -&gt; str:
    return self.static_name(cl.name, cl.module_name, prefix=TYPE_PREFIX)
</t>
<t tx="ekr.20240308084832.34">from __future__ import annotations

import mypy.errors
from mypy.options import Options


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.340">def ctype(self, rtype: RType) -&gt; str:
    return rtype._ctype
</t>
<t tx="ekr.20240308084832.341">def ctype_spaced(self, rtype: RType) -&gt; str:
    """Adds a space after ctype for non-pointers."""
    ctype = self.ctype(rtype)
    if ctype[-1] == "*":
        return ctype
    else:
        return ctype + " "
</t>
<t tx="ekr.20240308084832.342">def c_undefined_value(self, rtype: RType) -&gt; str:
    if not rtype.is_unboxed:
        return "NULL"
    elif isinstance(rtype, RPrimitive):
        return rtype.c_undefined
    elif isinstance(rtype, RTuple):
        return self.tuple_undefined_value(rtype)
    assert False, rtype
</t>
<t tx="ekr.20240308084832.343">def c_error_value(self, rtype: RType) -&gt; str:
    return self.c_undefined_value(rtype)
</t>
<t tx="ekr.20240308084832.344">def native_function_name(self, fn: FuncDecl) -&gt; str:
    return f"{NATIVE_PREFIX}{fn.cname(self.names)}"
</t>
<t tx="ekr.20240308084832.345">def tuple_c_declaration(self, rtuple: RTuple) -&gt; list[str]:
    result = [
        f"#ifndef MYPYC_DECLARED_{rtuple.struct_name}",
        f"#define MYPYC_DECLARED_{rtuple.struct_name}",
        f"typedef struct {rtuple.struct_name} {{",
    ]
    if len(rtuple.types) == 0:  # empty tuple
        # Empty tuples contain a flag so that they can still indicate
        # error values.
        result.append("int empty_struct_error_flag;")
    else:
        i = 0
        for typ in rtuple.types:
            result.append(f"{self.ctype_spaced(typ)}f{i};")
            i += 1
    result.append(f"}} {rtuple.struct_name};")
    result.append("#endif")
    result.append("")

    return result
</t>
<t tx="ekr.20240308084832.346">def bitmap_field(self, index: int) -&gt; str:
    """Return C field name used for attribute bitmap."""
    n = index // BITMAP_BITS
    if n == 0:
        return "bitmap"
    return f"bitmap{n + 1}"
</t>
<t tx="ekr.20240308084832.347">def attr_bitmap_expr(self, obj: str, cl: ClassIR, index: int) -&gt; str:
    """Return reference to the attribute definedness bitmap."""
    cast = f"({cl.struct_name(self.names)} *)"
    attr = self.bitmap_field(index)
    return f"({cast}{obj})-&gt;{attr}"
</t>
<t tx="ekr.20240308084832.348">def emit_attr_bitmap_set(
    self, value: str, obj: str, rtype: RType, cl: ClassIR, attr: str
) -&gt; None:
    """Mark an attribute as defined in the attribute bitmap.

    Assumes that the attribute is tracked in the bitmap (only some attributes
    use the bitmap). If 'value' is not equal to the error value, do nothing.
    """
    self._emit_attr_bitmap_update(value, obj, rtype, cl, attr, clear=False)
</t>
<t tx="ekr.20240308084832.349">def emit_attr_bitmap_clear(self, obj: str, rtype: RType, cl: ClassIR, attr: str) -&gt; None:
    """Mark an attribute as undefined in the attribute bitmap.

    Unlike emit_attr_bitmap_set, clear unconditionally.
    """
    self._emit_attr_bitmap_update("", obj, rtype, cl, attr, clear=True)
</t>
<t tx="ekr.20240308084832.35">class Errors:
    @others
</t>
<t tx="ekr.20240308084832.350">def _emit_attr_bitmap_update(
    self, value: str, obj: str, rtype: RType, cl: ClassIR, attr: str, clear: bool
) -&gt; None:
    if value:
        check = self.error_value_check(rtype, value, "==")
        self.emit_line(f"if (unlikely({check})) {{")
    index = cl.bitmap_attrs.index(attr)
    mask = 1 &lt;&lt; (index &amp; (BITMAP_BITS - 1))
    bitmap = self.attr_bitmap_expr(obj, cl, index)
    if clear:
        self.emit_line(f"{bitmap} &amp;= ~{mask};")
    else:
        self.emit_line(f"{bitmap} |= {mask};")
    if value:
        self.emit_line("}")
</t>
<t tx="ekr.20240308084832.351">def use_vectorcall(self) -&gt; bool:
    return use_vectorcall(self.capi_version)
</t>
<t tx="ekr.20240308084832.352">def emit_undefined_attr_check(
    self,
    rtype: RType,
    attr_expr: str,
    compare: str,
    obj: str,
    attr: str,
    cl: ClassIR,
    *,
    unlikely: bool = False,
) -&gt; None:
    check = self.error_value_check(rtype, attr_expr, compare)
    if unlikely:
        check = f"unlikely({check})"
    if rtype.error_overlap:
        index = cl.bitmap_attrs.index(attr)
        bit = 1 &lt;&lt; (index &amp; (BITMAP_BITS - 1))
        attr = self.bitmap_field(index)
        obj_expr = f"({cl.struct_name(self.names)} *){obj}"
        check = f"{check} &amp;&amp; !(({obj_expr})-&gt;{attr} &amp; {bit})"
    self.emit_line(f"if ({check}) {{")
</t>
<t tx="ekr.20240308084832.353">def error_value_check(self, rtype: RType, value: str, compare: str) -&gt; str:
    if isinstance(rtype, RTuple):
        return self.tuple_undefined_check_cond(
            rtype, value, self.c_error_value, compare, check_exception=False
        )
    else:
        return f"{value} {compare} {self.c_error_value(rtype)}"
</t>
<t tx="ekr.20240308084832.354">def tuple_undefined_check_cond(
    self,
    rtuple: RTuple,
    tuple_expr_in_c: str,
    c_type_compare_val: Callable[[RType], str],
    compare: str,
    *,
    check_exception: bool = True,
) -&gt; str:
    if len(rtuple.types) == 0:
        # empty tuple
        return "{}.empty_struct_error_flag {} {}".format(
            tuple_expr_in_c, compare, c_type_compare_val(int_rprimitive)
        )
    if rtuple.error_overlap:
        i = 0
        item_type = rtuple.types[0]
    else:
        for i, typ in enumerate(rtuple.types):
            if not typ.error_overlap:
                item_type = rtuple.types[i]
                break
        else:
            assert False, "not expecting tuple with error overlap"
    if isinstance(item_type, RTuple):
        return self.tuple_undefined_check_cond(
            item_type, tuple_expr_in_c + f".f{i}", c_type_compare_val, compare
        )
    else:
        check = f"{tuple_expr_in_c}.f{i} {compare} {c_type_compare_val(item_type)}"
        if rtuple.error_overlap and check_exception:
            check += " &amp;&amp; PyErr_Occurred()"
        return check
</t>
<t tx="ekr.20240308084832.355">def tuple_undefined_value(self, rtuple: RTuple) -&gt; str:
    """Undefined tuple value suitable in an expression."""
    return f"({rtuple.struct_name}) {self.c_initializer_undefined_value(rtuple)}"
</t>
<t tx="ekr.20240308084832.356">def c_initializer_undefined_value(self, rtype: RType) -&gt; str:
    """Undefined value represented in a form suitable for variable initialization."""
    if isinstance(rtype, RTuple):
        if not rtype.types:
            # Empty tuples contain a flag so that they can still indicate
            # error values.
            return f"{{ {int_rprimitive.c_undefined} }}"
        items = ", ".join([self.c_initializer_undefined_value(t) for t in rtype.types])
        return f"{{ {items} }}"
    else:
        return self.c_undefined_value(rtype)
</t>
<t tx="ekr.20240308084832.357"># Higher-level operations

def declare_tuple_struct(self, tuple_type: RTuple) -&gt; None:
    if tuple_type.struct_name not in self.context.declarations:
        dependencies = set()
        for typ in tuple_type.types:
            # XXX other types might eventually need similar behavior
            if isinstance(typ, RTuple):
                dependencies.add(typ.struct_name)

        self.context.declarations[tuple_type.struct_name] = HeaderDeclaration(
            self.tuple_c_declaration(tuple_type), dependencies=dependencies, is_type=True
        )
</t>
<t tx="ekr.20240308084832.358">def emit_inc_ref(self, dest: str, rtype: RType, *, rare: bool = False) -&gt; None:
    """Increment reference count of C expression `dest`.

    For composite unboxed structures (e.g. tuples) recursively
    increment reference counts for each component.

    If rare is True, optimize for code size and compilation speed.
    """
    if is_int_rprimitive(rtype):
        if rare:
            self.emit_line("CPyTagged_IncRef(%s);" % dest)
        else:
            self.emit_line("CPyTagged_INCREF(%s);" % dest)
    elif isinstance(rtype, RTuple):
        for i, item_type in enumerate(rtype.types):
            self.emit_inc_ref(f"{dest}.f{i}", item_type)
    elif not rtype.is_unboxed:
        # Always inline, since this is a simple op
        self.emit_line("CPy_INCREF(%s);" % dest)
</t>
<t tx="ekr.20240308084832.359">    # Otherwise assume it's an unboxed, pointerless value and do nothing.

def emit_dec_ref(
    self, dest: str, rtype: RType, *, is_xdec: bool = False, rare: bool = False
) -&gt; None:
    """Decrement reference count of C expression `dest`.

    For composite unboxed structures (e.g. tuples) recursively
    decrement reference counts for each component.

    If rare is True, optimize for code size and compilation speed.
    """
    x = "X" if is_xdec else ""
    if is_int_rprimitive(rtype):
        if rare:
            self.emit_line(f"CPyTagged_{x}DecRef({dest});")
        else:
            # Inlined
            self.emit_line(f"CPyTagged_{x}DECREF({dest});")
    elif isinstance(rtype, RTuple):
        for i, item_type in enumerate(rtype.types):
            self.emit_dec_ref(f"{dest}.f{i}", item_type, is_xdec=is_xdec, rare=rare)
    elif not rtype.is_unboxed:
        if rare:
            self.emit_line(f"CPy_{x}DecRef({dest});")
        else:
            # Inlined
            self.emit_line(f"CPy_{x}DECREF({dest});")
</t>
<t tx="ekr.20240308084832.36">def __init__(self, options: Options) -&gt; None:
    self.num_errors = 0
    self.num_warnings = 0
    self._errors = mypy.errors.Errors(options, hide_error_codes=True)
</t>
<t tx="ekr.20240308084832.360">    # Otherwise assume it's an unboxed, pointerless value and do nothing.

def pretty_name(self, typ: RType) -&gt; str:
    value_type = optional_value_type(typ)
    if value_type is not None:
        return "%s or None" % self.pretty_name(value_type)
    return str(typ)
</t>
<t tx="ekr.20240308084832.361">def emit_cast(
    self,
    src: str,
    dest: str,
    typ: RType,
    *,
    declare_dest: bool = False,
    error: ErrorHandler | None = None,
    raise_exception: bool = True,
    optional: bool = False,
    src_type: RType | None = None,
    likely: bool = True,
) -&gt; None:
    """Emit code for casting a value of given type.

    Somewhat strangely, this supports unboxed types but only
    operates on boxed versions.  This is necessary to properly
    handle types such as Optional[int] in compatibility glue.

    By default, assign NULL (error value) to dest if the value has
    an incompatible type and raise TypeError. These can be customized
    using 'error' and 'raise_exception'.

    Always copy/steal the reference in 'src'.

    Args:
        src: Name of source C variable
        dest: Name of target C variable
        typ: Type of value
        declare_dest: If True, also declare the variable 'dest'
        error: What happens on error
        raise_exception: If True, also raise TypeError on failure
        likely: If the cast is likely to succeed (can be False for unions)
    """
    error = error or AssignHandler()

    # Special case casting *from* optional
    if src_type and is_optional_type(src_type) and not is_object_rprimitive(typ):
        value_type = optional_value_type(src_type)
        assert value_type is not None
        if is_same_type(value_type, typ):
            if declare_dest:
                self.emit_line(f"PyObject *{dest};")
            check = "({} != Py_None)"
            if likely:
                check = f"(likely{check})"
            self.emit_arg_check(src, dest, typ, check.format(src), optional)
            self.emit_lines(f"    {dest} = {src};", "else {")
            self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
            self.emit_line("}")
            return

    # TODO: Verify refcount handling.
    if (
        is_list_rprimitive(typ)
        or is_dict_rprimitive(typ)
        or is_set_rprimitive(typ)
        or is_str_rprimitive(typ)
        or is_range_rprimitive(typ)
        or is_float_rprimitive(typ)
        or is_int_rprimitive(typ)
        or is_bool_rprimitive(typ)
        or is_bit_rprimitive(typ)
        or is_fixed_width_rtype(typ)
    ):
        if declare_dest:
            self.emit_line(f"PyObject *{dest};")
        if is_list_rprimitive(typ):
            prefix = "PyList"
        elif is_dict_rprimitive(typ):
            prefix = "PyDict"
        elif is_set_rprimitive(typ):
            prefix = "PySet"
        elif is_str_rprimitive(typ):
            prefix = "PyUnicode"
        elif is_range_rprimitive(typ):
            prefix = "PyRange"
        elif is_float_rprimitive(typ):
            prefix = "CPyFloat"
        elif is_int_rprimitive(typ) or is_fixed_width_rtype(typ):
            # TODO: Range check for fixed-width types?
            prefix = "PyLong"
        elif is_bool_rprimitive(typ) or is_bit_rprimitive(typ):
            prefix = "PyBool"
        else:
            assert False, f"unexpected primitive type: {typ}"
        check = "({}_Check({}))"
        if likely:
            check = f"(likely{check})"
        self.emit_arg_check(src, dest, typ, check.format(prefix, src), optional)
        self.emit_lines(f"    {dest} = {src};", "else {")
        self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
        self.emit_line("}")
    elif is_bytes_rprimitive(typ):
        if declare_dest:
            self.emit_line(f"PyObject *{dest};")
        check = "(PyBytes_Check({}) || PyByteArray_Check({}))"
        if likely:
            check = f"(likely{check})"
        self.emit_arg_check(src, dest, typ, check.format(src, src), optional)
        self.emit_lines(f"    {dest} = {src};", "else {")
        self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
        self.emit_line("}")
    elif is_tuple_rprimitive(typ):
        if declare_dest:
            self.emit_line(f"{self.ctype(typ)} {dest};")
        check = "(PyTuple_Check({}))"
        if likely:
            check = f"(likely{check})"
        self.emit_arg_check(src, dest, typ, check.format(src), optional)
        self.emit_lines(f"    {dest} = {src};", "else {")
        self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
        self.emit_line("}")
    elif isinstance(typ, RInstance):
        if declare_dest:
            self.emit_line(f"PyObject *{dest};")
        concrete = all_concrete_classes(typ.class_ir)
        # If there are too many concrete subclasses or we can't find any
        # (meaning the code ought to be dead or we aren't doing global opts),
        # fall back to a normal typecheck.
        # Otherwise check all the subclasses.
        if not concrete or len(concrete) &gt; FAST_ISINSTANCE_MAX_SUBCLASSES + 1:
            check = "(PyObject_TypeCheck({}, {}))".format(
                src, self.type_struct_name(typ.class_ir)
            )
        else:
            full_str = "(Py_TYPE({src}) == {targets[0]})"
            for i in range(1, len(concrete)):
                full_str += " || (Py_TYPE({src}) == {targets[%d]})" % i
            if len(concrete) &gt; 1:
                full_str = "(%s)" % full_str
            check = full_str.format(
                src=src, targets=[self.type_struct_name(ir) for ir in concrete]
            )
        if likely:
            check = f"(likely{check})"
        self.emit_arg_check(src, dest, typ, check, optional)
        self.emit_lines(f"    {dest} = {src};", "else {")
        self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
        self.emit_line("}")
    elif is_none_rprimitive(typ):
        if declare_dest:
            self.emit_line(f"PyObject *{dest};")
        check = "({} == Py_None)"
        if likely:
            check = f"(likely{check})"
        self.emit_arg_check(src, dest, typ, check.format(src), optional)
        self.emit_lines(f"    {dest} = {src};", "else {")
        self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
        self.emit_line("}")
    elif is_object_rprimitive(typ):
        if declare_dest:
            self.emit_line(f"PyObject *{dest};")
        self.emit_arg_check(src, dest, typ, "", optional)
        self.emit_line(f"{dest} = {src};")
        if optional:
            self.emit_line("}")
    elif isinstance(typ, RUnion):
        self.emit_union_cast(
            src, dest, typ, declare_dest, error, optional, src_type, raise_exception
        )
    elif isinstance(typ, RTuple):
        assert not optional
        self.emit_tuple_cast(src, dest, typ, declare_dest, error, src_type)
    else:
        assert False, "Cast not implemented: %s" % typ
</t>
<t tx="ekr.20240308084832.362">def emit_cast_error_handler(
    self, error: ErrorHandler, src: str, dest: str, typ: RType, raise_exception: bool
) -&gt; None:
    if raise_exception:
        if isinstance(error, TracebackAndGotoHandler):
            # Merge raising and emitting traceback entry into a single call.
            self.emit_type_error_traceback(
                error.source_path, error.module_name, error.traceback_entry, typ=typ, src=src
            )
            self.emit_line("goto %s;" % error.label)
            return
        self.emit_line(f'CPy_TypeError("{self.pretty_name(typ)}", {src}); ')
    if isinstance(error, AssignHandler):
        self.emit_line("%s = NULL;" % dest)
    elif isinstance(error, GotoHandler):
        self.emit_line("goto %s;" % error.label)
    elif isinstance(error, TracebackAndGotoHandler):
        self.emit_line("%s = NULL;" % dest)
        self.emit_traceback(error.source_path, error.module_name, error.traceback_entry)
        self.emit_line("goto %s;" % error.label)
    else:
        assert isinstance(error, ReturnHandler)
        self.emit_line("return %s;" % error.value)
</t>
<t tx="ekr.20240308084832.363">def emit_union_cast(
    self,
    src: str,
    dest: str,
    typ: RUnion,
    declare_dest: bool,
    error: ErrorHandler,
    optional: bool,
    src_type: RType | None,
    raise_exception: bool,
) -&gt; None:
    """Emit cast to a union type.

    The arguments are similar to emit_cast.
    """
    if declare_dest:
        self.emit_line(f"PyObject *{dest};")
    good_label = self.new_label()
    if optional:
        self.emit_line(f"if ({src} == NULL) {{")
        self.emit_line(f"{dest} = {self.c_error_value(typ)};")
        self.emit_line(f"goto {good_label};")
        self.emit_line("}")
    for item in typ.items:
        self.emit_cast(
            src,
            dest,
            item,
            declare_dest=False,
            raise_exception=False,
            optional=False,
            likely=False,
        )
        self.emit_line(f"if ({dest} != NULL) goto {good_label};")
    # Handle cast failure.
    self.emit_cast_error_handler(error, src, dest, typ, raise_exception)
    self.emit_label(good_label)
</t>
<t tx="ekr.20240308084832.364">def emit_tuple_cast(
    self,
    src: str,
    dest: str,
    typ: RTuple,
    declare_dest: bool,
    error: ErrorHandler,
    src_type: RType | None,
) -&gt; None:
    """Emit cast to a tuple type.

    The arguments are similar to emit_cast.
    """
    if declare_dest:
        self.emit_line(f"PyObject *{dest};")
    # This reuse of the variable is super dodgy. We don't even
    # care about the values except to check whether they are
    # invalid.
    out_label = self.new_label()
    self.emit_lines(
        "if (unlikely(!(PyTuple_Check({r}) &amp;&amp; PyTuple_GET_SIZE({r}) == {size}))) {{".format(
            r=src, size=len(typ.types)
        ),
        f"{dest} = NULL;",
        f"goto {out_label};",
        "}",
    )
    for i, item in enumerate(typ.types):
        # Since we did the checks above this should never fail
        self.emit_cast(
            f"PyTuple_GET_ITEM({src}, {i})",
            dest,
            item,
            declare_dest=False,
            raise_exception=False,
            optional=False,
        )
        self.emit_line(f"if ({dest} == NULL) goto {out_label};")

    self.emit_line(f"{dest} = {src};")
    self.emit_label(out_label)
</t>
<t tx="ekr.20240308084832.365">def emit_arg_check(self, src: str, dest: str, typ: RType, check: str, optional: bool) -&gt; None:
    if optional:
        self.emit_line(f"if ({src} == NULL) {{")
        self.emit_line(f"{dest} = {self.c_error_value(typ)};")
    if check != "":
        self.emit_line("{}if {}".format("} else " if optional else "", check))
    elif optional:
        self.emit_line("else {")
</t>
<t tx="ekr.20240308084832.366">def emit_unbox(
    self,
    src: str,
    dest: str,
    typ: RType,
    *,
    declare_dest: bool = False,
    error: ErrorHandler | None = None,
    raise_exception: bool = True,
    optional: bool = False,
    borrow: bool = False,
) -&gt; None:
    """Emit code for unboxing a value of given type (from PyObject *).

    By default, assign error value to dest if the value has an
    incompatible type and raise TypeError. These can be customized
    using 'error' and 'raise_exception'.

    Generate a new reference unless 'borrow' is True.

    Args:
        src: Name of source C variable
        dest: Name of target C variable
        typ: Type of value
        declare_dest: If True, also declare the variable 'dest'
        error: What happens on error
        raise_exception: If True, also raise TypeError on failure
        borrow: If True, create a borrowed reference

    """
    error = error or AssignHandler()
    # TODO: Verify refcount handling.
    if isinstance(error, AssignHandler):
        failure = f"{dest} = {self.c_error_value(typ)};"
    elif isinstance(error, GotoHandler):
        failure = "goto %s;" % error.label
    else:
        assert isinstance(error, ReturnHandler)
        failure = "return %s;" % error.value
    if raise_exception:
        raise_exc = f'CPy_TypeError("{self.pretty_name(typ)}", {src}); '
        failure = raise_exc + failure
    if is_int_rprimitive(typ) or is_short_int_rprimitive(typ):
        if declare_dest:
            self.emit_line(f"CPyTagged {dest};")
        self.emit_arg_check(src, dest, typ, f"(likely(PyLong_Check({src})))", optional)
        if borrow:
            self.emit_line(f"    {dest} = CPyTagged_BorrowFromObject({src});")
        else:
            self.emit_line(f"    {dest} = CPyTagged_FromObject({src});")
        self.emit_line("else {")
        self.emit_line(failure)
        self.emit_line("}")
    elif is_bool_rprimitive(typ) or is_bit_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        if declare_dest:
            self.emit_line(f"char {dest};")
        self.emit_arg_check(src, dest, typ, f"(unlikely(!PyBool_Check({src}))) {{", optional)
        self.emit_line(failure)
        self.emit_line("} else")
        conversion = f"{src} == Py_True"
        self.emit_line(f"    {dest} = {conversion};")
    elif is_none_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        if declare_dest:
            self.emit_line(f"char {dest};")
        self.emit_arg_check(src, dest, typ, f"(unlikely({src} != Py_None)) {{", optional)
        self.emit_line(failure)
        self.emit_line("} else")
        self.emit_line(f"    {dest} = 1;")
    elif is_int64_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        assert not optional  # Not supported for overlapping error values
        if declare_dest:
            self.emit_line(f"int64_t {dest};")
        self.emit_line(f"{dest} = CPyLong_AsInt64({src});")
        if not isinstance(error, AssignHandler):
            self.emit_unbox_failure_with_overlapping_error_value(dest, typ, failure)
    elif is_int32_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        assert not optional  # Not supported for overlapping error values
        if declare_dest:
            self.emit_line(f"int32_t {dest};")
        self.emit_line(f"{dest} = CPyLong_AsInt32({src});")
        if not isinstance(error, AssignHandler):
            self.emit_unbox_failure_with_overlapping_error_value(dest, typ, failure)
    elif is_int16_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        assert not optional  # Not supported for overlapping error values
        if declare_dest:
            self.emit_line(f"int16_t {dest};")
        self.emit_line(f"{dest} = CPyLong_AsInt16({src});")
        if not isinstance(error, AssignHandler):
            self.emit_unbox_failure_with_overlapping_error_value(dest, typ, failure)
    elif is_uint8_rprimitive(typ):
        # Whether we are borrowing or not makes no difference.
        assert not optional  # Not supported for overlapping error values
        if declare_dest:
            self.emit_line(f"uint8_t {dest};")
        self.emit_line(f"{dest} = CPyLong_AsUInt8({src});")
        if not isinstance(error, AssignHandler):
            self.emit_unbox_failure_with_overlapping_error_value(dest, typ, failure)
    elif is_float_rprimitive(typ):
        assert not optional  # Not supported for overlapping error values
        if declare_dest:
            self.emit_line(f"double {dest};")
        # TODO: Don't use __float__ and __index__
        self.emit_line(f"{dest} = PyFloat_AsDouble({src});")
        self.emit_lines(f"if ({dest} == -1.0 &amp;&amp; PyErr_Occurred()) {{", failure, "}")
    elif isinstance(typ, RTuple):
        self.declare_tuple_struct(typ)
        if declare_dest:
            self.emit_line(f"{self.ctype(typ)} {dest};")
        # HACK: The error handling for unboxing tuples is busted
        # and instead of fixing it I am just wrapping it in the
        # cast code which I think is right. This is not good.
        if optional:
            self.emit_line(f"if ({src} == NULL) {{")
            self.emit_line(f"{dest} = {self.c_error_value(typ)};")
            self.emit_line("} else {")

        cast_temp = self.temp_name()
        self.emit_tuple_cast(
            src, cast_temp, typ, declare_dest=True, error=error, src_type=None
        )
        self.emit_line(f"if (unlikely({cast_temp} == NULL)) {{")

        # self.emit_arg_check(src, dest, typ,
        #     '(!PyTuple_Check({}) || PyTuple_Size({}) != {}) {{'.format(
        #         src, src, len(typ.types)), optional)
        self.emit_line(failure)  # TODO: Decrease refcount?
        self.emit_line("} else {")
        if not typ.types:
            self.emit_line(f"{dest}.empty_struct_error_flag = 0;")
        for i, item_type in enumerate(typ.types):
            temp = self.temp_name()
            # emit_tuple_cast above checks the size, so this should not fail
            self.emit_line(f"PyObject *{temp} = PyTuple_GET_ITEM({src}, {i});")
            temp2 = self.temp_name()
            # Unbox or check the item.
            if item_type.is_unboxed:
                self.emit_unbox(
                    temp,
                    temp2,
                    item_type,
                    raise_exception=raise_exception,
                    error=error,
                    declare_dest=True,
                    borrow=borrow,
                )
            else:
                if not borrow:
                    self.emit_inc_ref(temp, object_rprimitive)
                self.emit_cast(temp, temp2, item_type, declare_dest=True)
            self.emit_line(f"{dest}.f{i} = {temp2};")
        self.emit_line("}")
        if optional:
            self.emit_line("}")

    else:
        assert False, "Unboxing not implemented: %s" % typ
</t>
<t tx="ekr.20240308084832.367">def emit_box(
    self, src: str, dest: str, typ: RType, declare_dest: bool = False, can_borrow: bool = False
) -&gt; None:
    """Emit code for boxing a value of given type.

    Generate a simple assignment if no boxing is needed.

    The source reference count is stolen for the result (no need to decref afterwards).
    """
    # TODO: Always generate a new reference (if a reference type)
    if declare_dest:
        declaration = "PyObject *"
    else:
        declaration = ""
    if is_int_rprimitive(typ) or is_short_int_rprimitive(typ):
        # Steal the existing reference if it exists.
        self.emit_line(f"{declaration}{dest} = CPyTagged_StealAsObject({src});")
    elif is_bool_rprimitive(typ) or is_bit_rprimitive(typ):
        # N.B: bool is special cased to produce a borrowed value
        # after boxing, so we don't need to increment the refcount
        # when this comes directly from a Box op.
        self.emit_lines(f"{declaration}{dest} = {src} ? Py_True : Py_False;")
        if not can_borrow:
            self.emit_inc_ref(dest, object_rprimitive)
    elif is_none_rprimitive(typ):
        # N.B: None is special cased to produce a borrowed value
        # after boxing, so we don't need to increment the refcount
        # when this comes directly from a Box op.
        self.emit_lines(f"{declaration}{dest} = Py_None;")
        if not can_borrow:
            self.emit_inc_ref(dest, object_rprimitive)
    elif is_int32_rprimitive(typ) or is_int16_rprimitive(typ) or is_uint8_rprimitive(typ):
        self.emit_line(f"{declaration}{dest} = PyLong_FromLong({src});")
    elif is_int64_rprimitive(typ):
        self.emit_line(f"{declaration}{dest} = PyLong_FromLongLong({src});")
    elif is_float_rprimitive(typ):
        self.emit_line(f"{declaration}{dest} = PyFloat_FromDouble({src});")
    elif isinstance(typ, RTuple):
        self.declare_tuple_struct(typ)
        self.emit_line(f"{declaration}{dest} = PyTuple_New({len(typ.types)});")
        self.emit_line(f"if (unlikely({dest} == NULL))")
        self.emit_line("    CPyError_OutOfMemory();")
        # TODO: Fail if dest is None
        for i in range(0, len(typ.types)):
            if not typ.is_unboxed:
                self.emit_line(f"PyTuple_SET_ITEM({dest}, {i}, {src}.f{i}")
            else:
                inner_name = self.temp_name()
                self.emit_box(f"{src}.f{i}", inner_name, typ.types[i], declare_dest=True)
                self.emit_line(f"PyTuple_SET_ITEM({dest}, {i}, {inner_name});")
    else:
        assert not typ.is_unboxed
        # Type is boxed -- trivially just assign.
        self.emit_line(f"{declaration}{dest} = {src};")
</t>
<t tx="ekr.20240308084832.368">def emit_error_check(self, value: str, rtype: RType, failure: str) -&gt; None:
    """Emit code for checking a native function return value for uncaught exception."""
    if isinstance(rtype, RTuple):
        if len(rtype.types) == 0:
            return  # empty tuples can't fail.
        else:
            cond = self.tuple_undefined_check_cond(rtype, value, self.c_error_value, "==")
            self.emit_line(f"if ({cond}) {{")
    elif rtype.error_overlap:
        # The error value is also valid as a normal value, so we need to also check
        # for a raised exception.
        self.emit_line(f"if ({value} == {self.c_error_value(rtype)} &amp;&amp; PyErr_Occurred()) {{")
    else:
        self.emit_line(f"if ({value} == {self.c_error_value(rtype)}) {{")
    self.emit_lines(failure, "}")
</t>
<t tx="ekr.20240308084832.369">def emit_gc_visit(self, target: str, rtype: RType) -&gt; None:
    """Emit code for GC visiting a C variable reference.

    Assume that 'target' represents a C expression that refers to a
    struct member, such as 'self-&gt;x'.
    """
    if not rtype.is_refcounted:
        # Not refcounted -&gt; no pointers -&gt; no GC interaction.
        return
    elif isinstance(rtype, RPrimitive) and rtype.name == "builtins.int":
        self.emit_line(f"if (CPyTagged_CheckLong({target})) {{")
        self.emit_line(f"Py_VISIT(CPyTagged_LongAsObject({target}));")
        self.emit_line("}")
    elif isinstance(rtype, RTuple):
        for i, item_type in enumerate(rtype.types):
            self.emit_gc_visit(f"{target}.f{i}", item_type)
    elif self.ctype(rtype) == "PyObject *":
        # The simplest case.
        self.emit_line(f"Py_VISIT({target});")
    else:
        assert False, "emit_gc_visit() not implemented for %s" % repr(rtype)
</t>
<t tx="ekr.20240308084832.37">def error(self, msg: str, path: str, line: int) -&gt; None:
    self._errors.report(line, None, msg, severity="error", file=path)
    self.num_errors += 1
</t>
<t tx="ekr.20240308084832.370">def emit_gc_clear(self, target: str, rtype: RType) -&gt; None:
    """Emit code for clearing a C attribute reference for GC.

    Assume that 'target' represents a C expression that refers to a
    struct member, such as 'self-&gt;x'.
    """
    if not rtype.is_refcounted:
        # Not refcounted -&gt; no pointers -&gt; no GC interaction.
        return
    elif isinstance(rtype, RPrimitive) and rtype.name == "builtins.int":
        self.emit_line(f"if (CPyTagged_CheckLong({target})) {{")
        self.emit_line(f"CPyTagged __tmp = {target};")
        self.emit_line(f"{target} = {self.c_undefined_value(rtype)};")
        self.emit_line("Py_XDECREF(CPyTagged_LongAsObject(__tmp));")
        self.emit_line("}")
    elif isinstance(rtype, RTuple):
        for i, item_type in enumerate(rtype.types):
            self.emit_gc_clear(f"{target}.f{i}", item_type)
    elif self.ctype(rtype) == "PyObject *" and self.c_undefined_value(rtype) == "NULL":
        # The simplest case.
        self.emit_line(f"Py_CLEAR({target});")
    else:
        assert False, "emit_gc_clear() not implemented for %s" % repr(rtype)
</t>
<t tx="ekr.20240308084832.371">def emit_traceback(
    self, source_path: str, module_name: str, traceback_entry: tuple[str, int]
) -&gt; None:
    return self._emit_traceback("CPy_AddTraceback", source_path, module_name, traceback_entry)
</t>
<t tx="ekr.20240308084832.372">def emit_type_error_traceback(
    self,
    source_path: str,
    module_name: str,
    traceback_entry: tuple[str, int],
    *,
    typ: RType,
    src: str,
) -&gt; None:
    func = "CPy_TypeErrorTraceback"
    type_str = f'"{self.pretty_name(typ)}"'
    return self._emit_traceback(
        func, source_path, module_name, traceback_entry, type_str=type_str, src=src
    )
</t>
<t tx="ekr.20240308084832.373">def _emit_traceback(
    self,
    func: str,
    source_path: str,
    module_name: str,
    traceback_entry: tuple[str, int],
    type_str: str = "",
    src: str = "",
) -&gt; None:
    globals_static = self.static_name("globals", module_name)
    line = '%s("%s", "%s", %d, %s' % (
        func,
        source_path.replace("\\", "\\\\"),
        traceback_entry[0],
        traceback_entry[1],
        globals_static,
    )
    if type_str:
        assert src
        line += f", {type_str}, {src}"
    line += ");"
    self.emit_line(line)
    if DEBUG_ERRORS:
        self.emit_line('assert(PyErr_Occurred() != NULL &amp;&amp; "failure w/o err!");')
</t>
<t tx="ekr.20240308084832.374">def emit_unbox_failure_with_overlapping_error_value(
    self, dest: str, typ: RType, failure: str
) -&gt; None:
    self.emit_line(f"if ({dest} == {self.c_error_value(typ)} &amp;&amp; PyErr_Occurred()) {{")
    self.emit_line(failure)
    self.emit_line("}")
</t>
<t tx="ekr.20240308084832.375">def c_array_initializer(components: list[str], *, indented: bool = False) -&gt; str:
    """Construct an initializer for a C array variable.

    Components are C expressions valid in an initializer.

    For example, if components are ["1", "2"], the result
    would be "{1, 2}", which can be used like this:

        int a[] = {1, 2};

    If the result is long, split it into multiple lines.
    """
    indent = " " * 4 if indented else ""
    res = []
    current: list[str] = []
    cur_len = 0
    for c in components:
        if not current or cur_len + 2 + len(indent) + len(c) &lt; 70:
            current.append(c)
            cur_len += len(c) + 2
        else:
            res.append(indent + ", ".join(current))
            current = [c]
            cur_len = len(c)
    if not res:
        # Result fits on a single line
        return "{%s}" % ", ".join(current)
    # Multi-line result
    res.append(indent + ", ".join(current))
    return "{\n    " + ",\n    ".join(res) + "\n" + indent + "}"
</t>
<t tx="ekr.20240308084832.376">"""Code generation for native classes and related wrappers."""

from __future__ import annotations

from typing import Callable, Mapping, Tuple

from mypyc.codegen.emit import Emitter, HeaderDeclaration, ReturnHandler
from mypyc.codegen.emitfunc import native_function_header
from mypyc.codegen.emitwrapper import (
    generate_bin_op_wrapper,
    generate_bool_wrapper,
    generate_contains_wrapper,
    generate_dunder_wrapper,
    generate_get_wrapper,
    generate_hash_wrapper,
    generate_ipow_wrapper,
    generate_len_wrapper,
    generate_richcompare_wrapper,
    generate_set_del_item_wrapper,
)
from mypyc.common import BITMAP_BITS, BITMAP_TYPE, NATIVE_PREFIX, PREFIX, REG_PREFIX
from mypyc.ir.class_ir import ClassIR, VTableEntries
from mypyc.ir.func_ir import FUNC_CLASSMETHOD, FUNC_STATICMETHOD, FuncDecl, FuncIR
from mypyc.ir.rtypes import RTuple, RType, object_rprimitive
from mypyc.namegen import NameGenerator
from mypyc.sametype import is_same_type


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.377">def native_slot(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    return f"{NATIVE_PREFIX}{fn.cname(emitter.names)}"
</t>
<t tx="ekr.20240308084832.378">def wrapper_slot(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    return f"{PREFIX}{fn.cname(emitter.names)}"
</t>
<t tx="ekr.20240308084832.379"># We maintain a table from dunder function names to struct slots they
# correspond to and functions that generate a wrapper (if necessary)
# and return the function name to stick in the slot.
# TODO: Add remaining dunder methods
SlotGenerator = Callable[[ClassIR, FuncIR, Emitter], str]
SlotTable = Mapping[str, Tuple[str, SlotGenerator]]

SLOT_DEFS: SlotTable = {
    "__init__": ("tp_init", lambda c, t, e: generate_init_for_class(c, t, e)),
    "__call__": ("tp_call", lambda c, t, e: generate_call_wrapper(c, t, e)),
    "__str__": ("tp_str", native_slot),
    "__repr__": ("tp_repr", native_slot),
    "__next__": ("tp_iternext", native_slot),
    "__iter__": ("tp_iter", native_slot),
    "__hash__": ("tp_hash", generate_hash_wrapper),
    "__get__": ("tp_descr_get", generate_get_wrapper),
}

AS_MAPPING_SLOT_DEFS: SlotTable = {
    "__getitem__": ("mp_subscript", generate_dunder_wrapper),
    "__setitem__": ("mp_ass_subscript", generate_set_del_item_wrapper),
    "__delitem__": ("mp_ass_subscript", generate_set_del_item_wrapper),
    "__len__": ("mp_length", generate_len_wrapper),
}

AS_SEQUENCE_SLOT_DEFS: SlotTable = {"__contains__": ("sq_contains", generate_contains_wrapper)}

AS_NUMBER_SLOT_DEFS: SlotTable = {
    # Unary operations.
    "__bool__": ("nb_bool", generate_bool_wrapper),
    "__int__": ("nb_int", generate_dunder_wrapper),
    "__float__": ("nb_float", generate_dunder_wrapper),
    "__neg__": ("nb_negative", generate_dunder_wrapper),
    "__pos__": ("nb_positive", generate_dunder_wrapper),
    "__abs__": ("nb_absolute", generate_dunder_wrapper),
    "__invert__": ("nb_invert", generate_dunder_wrapper),
    # Binary operations.
    "__add__": ("nb_add", generate_bin_op_wrapper),
    "__radd__": ("nb_add", generate_bin_op_wrapper),
    "__sub__": ("nb_subtract", generate_bin_op_wrapper),
    "__rsub__": ("nb_subtract", generate_bin_op_wrapper),
    "__mul__": ("nb_multiply", generate_bin_op_wrapper),
    "__rmul__": ("nb_multiply", generate_bin_op_wrapper),
    "__mod__": ("nb_remainder", generate_bin_op_wrapper),
    "__rmod__": ("nb_remainder", generate_bin_op_wrapper),
    "__truediv__": ("nb_true_divide", generate_bin_op_wrapper),
    "__rtruediv__": ("nb_true_divide", generate_bin_op_wrapper),
    "__floordiv__": ("nb_floor_divide", generate_bin_op_wrapper),
    "__rfloordiv__": ("nb_floor_divide", generate_bin_op_wrapper),
    "__divmod__": ("nb_divmod", generate_bin_op_wrapper),
    "__rdivmod__": ("nb_divmod", generate_bin_op_wrapper),
    "__lshift__": ("nb_lshift", generate_bin_op_wrapper),
    "__rlshift__": ("nb_lshift", generate_bin_op_wrapper),
    "__rshift__": ("nb_rshift", generate_bin_op_wrapper),
    "__rrshift__": ("nb_rshift", generate_bin_op_wrapper),
    "__and__": ("nb_and", generate_bin_op_wrapper),
    "__rand__": ("nb_and", generate_bin_op_wrapper),
    "__or__": ("nb_or", generate_bin_op_wrapper),
    "__ror__": ("nb_or", generate_bin_op_wrapper),
    "__xor__": ("nb_xor", generate_bin_op_wrapper),
    "__rxor__": ("nb_xor", generate_bin_op_wrapper),
    "__matmul__": ("nb_matrix_multiply", generate_bin_op_wrapper),
    "__rmatmul__": ("nb_matrix_multiply", generate_bin_op_wrapper),
    # In-place binary operations.
    "__iadd__": ("nb_inplace_add", generate_dunder_wrapper),
    "__isub__": ("nb_inplace_subtract", generate_dunder_wrapper),
    "__imul__": ("nb_inplace_multiply", generate_dunder_wrapper),
    "__imod__": ("nb_inplace_remainder", generate_dunder_wrapper),
    "__itruediv__": ("nb_inplace_true_divide", generate_dunder_wrapper),
    "__ifloordiv__": ("nb_inplace_floor_divide", generate_dunder_wrapper),
    "__ilshift__": ("nb_inplace_lshift", generate_dunder_wrapper),
    "__irshift__": ("nb_inplace_rshift", generate_dunder_wrapper),
    "__iand__": ("nb_inplace_and", generate_dunder_wrapper),
    "__ior__": ("nb_inplace_or", generate_dunder_wrapper),
    "__ixor__": ("nb_inplace_xor", generate_dunder_wrapper),
    "__imatmul__": ("nb_inplace_matrix_multiply", generate_dunder_wrapper),
    # Ternary operations. (yes, really)
    # These are special cased in generate_bin_op_wrapper().
    "__pow__": ("nb_power", generate_bin_op_wrapper),
    "__rpow__": ("nb_power", generate_bin_op_wrapper),
    "__ipow__": ("nb_inplace_power", generate_ipow_wrapper),
}

AS_ASYNC_SLOT_DEFS: SlotTable = {
    "__await__": ("am_await", native_slot),
    "__aiter__": ("am_aiter", native_slot),
    "__anext__": ("am_anext", native_slot),
}

SIDE_TABLES = [
    ("as_mapping", "PyMappingMethods", AS_MAPPING_SLOT_DEFS),
    ("as_sequence", "PySequenceMethods", AS_SEQUENCE_SLOT_DEFS),
    ("as_number", "PyNumberMethods", AS_NUMBER_SLOT_DEFS),
    ("as_async", "PyAsyncMethods", AS_ASYNC_SLOT_DEFS),
]

# Slots that need to always be filled in because they don't get
# inherited right.
ALWAYS_FILL = {"__hash__"}


def generate_call_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    if emitter.use_vectorcall():
        # Use vectorcall wrapper if supported (PEP 590).
        return "PyVectorcall_Call"
    else:
        # On older Pythons use the legacy wrapper.
        return wrapper_slot(cl, fn, emitter)
</t>
<t tx="ekr.20240308084832.38">def note(self, msg: str, path: str, line: int) -&gt; None:
    self._errors.report(line, None, msg, severity="note", file=path)
</t>
<t tx="ekr.20240308084832.380">def slot_key(attr: str) -&gt; str:
    """Map dunder method name to sort key.

    Sort reverse operator methods and __delitem__ after others ('x' &gt; '_').
    """
    if (attr.startswith("__r") and attr != "__rshift__") or attr == "__delitem__":
        return "x" + attr
    return attr
</t>
<t tx="ekr.20240308084832.381">def generate_slots(cl: ClassIR, table: SlotTable, emitter: Emitter) -&gt; dict[str, str]:
    fields: dict[str, str] = {}
    generated: dict[str, str] = {}
    # Sort for determinism on Python 3.5
    for name, (slot, generator) in sorted(table.items(), key=lambda x: slot_key(x[0])):
        method_cls = cl.get_method_and_class(name)
        if method_cls and (method_cls[1] == cl or name in ALWAYS_FILL):
            if slot in generated:
                # Reuse previously generated wrapper.
                fields[slot] = generated[slot]
            else:
                # Generate new wrapper.
                name = generator(cl, method_cls[0], emitter)
                fields[slot] = name
                generated[slot] = name

    return fields
</t>
<t tx="ekr.20240308084832.382">def generate_class_type_decl(
    cl: ClassIR, c_emitter: Emitter, external_emitter: Emitter, emitter: Emitter
) -&gt; None:
    context = c_emitter.context
    name = emitter.type_struct_name(cl)
    context.declarations[name] = HeaderDeclaration(
        f"PyTypeObject *{emitter.type_struct_name(cl)};", needs_export=True
    )

    # If this is a non-extension class, all we want is the type object decl.
    if not cl.is_ext_class:
        return

    generate_object_struct(cl, external_emitter)
    generate_full = not cl.is_trait and not cl.builtin_base
    if generate_full:
        context.declarations[emitter.native_function_name(cl.ctor)] = HeaderDeclaration(
            f"{native_function_header(cl.ctor, emitter)};", needs_export=True
        )
</t>
<t tx="ekr.20240308084832.383">def generate_class(cl: ClassIR, module: str, emitter: Emitter) -&gt; None:
    """Generate C code for a class.

    This is the main entry point to the module.
    """
    name = cl.name
    name_prefix = cl.name_prefix(emitter.names)

    setup_name = f"{name_prefix}_setup"
    new_name = f"{name_prefix}_new"
    members_name = f"{name_prefix}_members"
    getseters_name = f"{name_prefix}_getseters"
    vtable_name = f"{name_prefix}_vtable"
    traverse_name = f"{name_prefix}_traverse"
    clear_name = f"{name_prefix}_clear"
    dealloc_name = f"{name_prefix}_dealloc"
    methods_name = f"{name_prefix}_methods"
    vtable_setup_name = f"{name_prefix}_trait_vtable_setup"

    fields: dict[str, str] = {}
    fields["tp_name"] = f'"{name}"'

    generate_full = not cl.is_trait and not cl.builtin_base
    needs_getseters = cl.needs_getseters or not cl.is_generated or cl.has_dict

    if not cl.builtin_base:
        fields["tp_new"] = new_name

    if generate_full:
        fields["tp_dealloc"] = f"(destructor){name_prefix}_dealloc"
        fields["tp_traverse"] = f"(traverseproc){name_prefix}_traverse"
        fields["tp_clear"] = f"(inquiry){name_prefix}_clear"
    if needs_getseters:
        fields["tp_getset"] = getseters_name
    fields["tp_methods"] = methods_name

    def emit_line() -&gt; None:
        emitter.emit_line()

    emit_line()

    # If the class has a method to initialize default attribute
    # values, we need to call it during initialization.
    defaults_fn = cl.get_method("__mypyc_defaults_setup")

    # If there is a __init__ method, we'll use it in the native constructor.
    init_fn = cl.get_method("__init__")

    # Fill out slots in the type object from dunder methods.
    fields.update(generate_slots(cl, SLOT_DEFS, emitter))

    # Fill out dunder methods that live in tables hanging off the side.
    for table_name, type, slot_defs in SIDE_TABLES:
        slots = generate_slots(cl, slot_defs, emitter)
        if slots:
            table_struct_name = generate_side_table_for_class(cl, table_name, type, slots, emitter)
            fields[f"tp_{table_name}"] = f"&amp;{table_struct_name}"

    richcompare_name = generate_richcompare_wrapper(cl, emitter)
    if richcompare_name:
        fields["tp_richcompare"] = richcompare_name

    # If the class inherits from python, make space for a __dict__
    struct_name = cl.struct_name(emitter.names)
    if cl.builtin_base:
        base_size = f"sizeof({cl.builtin_base})"
    elif cl.is_trait:
        base_size = "sizeof(PyObject)"
    else:
        base_size = f"sizeof({struct_name})"
    # Since our types aren't allocated using type() we need to
    # populate these fields ourselves if we want them to have correct
    # values. PyType_Ready will inherit the offsets from tp_base but
    # that isn't what we want.

    # XXX: there is no reason for the __weakref__ stuff to be mixed up with __dict__
    if cl.has_dict and not has_managed_dict(cl, emitter):
        # __dict__ lives right after the struct and __weakref__ lives right after that
        # TODO: They should get members in the struct instead of doing this nonsense.
        weak_offset = f"{base_size} + sizeof(PyObject *)"
        emitter.emit_lines(
            f"PyMemberDef {members_name}[] = {{",
            f'{{"__dict__", T_OBJECT_EX, {base_size}, 0, NULL}},',
            f'{{"__weakref__", T_OBJECT_EX, {weak_offset}, 0, NULL}},',
            "{0}",
            "};",
        )

        fields["tp_members"] = members_name
        fields["tp_basicsize"] = f"{base_size} + 2*sizeof(PyObject *)"
        if emitter.capi_version &lt; (3, 12):
            fields["tp_dictoffset"] = base_size
            fields["tp_weaklistoffset"] = weak_offset
    else:
        fields["tp_basicsize"] = base_size

    if generate_full:
        # Declare setup method that allocates and initializes an object. type is the
        # type of the class being initialized, which could be another class if there
        # is an interpreted subclass.
        emitter.emit_line(f"static PyObject *{setup_name}(PyTypeObject *type);")
        assert cl.ctor is not None
        emitter.emit_line(native_function_header(cl.ctor, emitter) + ";")

        emit_line()
        init_fn = cl.get_method("__init__")
        generate_new_for_class(cl, new_name, vtable_name, setup_name, init_fn, emitter)
        emit_line()
        generate_traverse_for_class(cl, traverse_name, emitter)
        emit_line()
        generate_clear_for_class(cl, clear_name, emitter)
        emit_line()
        generate_dealloc_for_class(cl, dealloc_name, clear_name, emitter)
        emit_line()

        if cl.allow_interpreted_subclasses:
            shadow_vtable_name: str | None = generate_vtables(
                cl, vtable_setup_name + "_shadow", vtable_name + "_shadow", emitter, shadow=True
            )
            emit_line()
        else:
            shadow_vtable_name = None
        vtable_name = generate_vtables(cl, vtable_setup_name, vtable_name, emitter, shadow=False)
        emit_line()
    if needs_getseters:
        generate_getseter_declarations(cl, emitter)
        emit_line()
        generate_getseters_table(cl, getseters_name, emitter)
        emit_line()

    if cl.is_trait:
        generate_new_for_trait(cl, new_name, emitter)

    generate_methods_table(cl, methods_name, emitter)
    emit_line()

    flags = ["Py_TPFLAGS_DEFAULT", "Py_TPFLAGS_HEAPTYPE", "Py_TPFLAGS_BASETYPE"]
    if generate_full:
        flags.append("Py_TPFLAGS_HAVE_GC")
    if cl.has_method("__call__") and emitter.use_vectorcall():
        fields["tp_vectorcall_offset"] = "offsetof({}, vectorcall)".format(
            cl.struct_name(emitter.names)
        )
        flags.append("_Py_TPFLAGS_HAVE_VECTORCALL")
        if not fields.get("tp_vectorcall"):
            # This is just a placeholder to please CPython. It will be
            # overridden during setup.
            fields["tp_call"] = "PyVectorcall_Call"
    if has_managed_dict(cl, emitter):
        flags.append("Py_TPFLAGS_MANAGED_DICT")
    fields["tp_flags"] = " | ".join(flags)

    emitter.emit_line(f"static PyTypeObject {emitter.type_struct_name(cl)}_template_ = {{")
    emitter.emit_line("PyVarObject_HEAD_INIT(NULL, 0)")
    for field, value in fields.items():
        emitter.emit_line(f".{field} = {value},")
    emitter.emit_line("};")
    emitter.emit_line(
        "static PyTypeObject *{t}_template = &amp;{t}_template_;".format(
            t=emitter.type_struct_name(cl)
        )
    )

    emitter.emit_line()
    if generate_full:
        generate_setup_for_class(
            cl, setup_name, defaults_fn, vtable_name, shadow_vtable_name, emitter
        )
        emitter.emit_line()
        generate_constructor_for_class(cl, cl.ctor, init_fn, setup_name, vtable_name, emitter)
        emitter.emit_line()
    if needs_getseters:
        generate_getseters(cl, emitter)
</t>
<t tx="ekr.20240308084832.384">def getter_name(cl: ClassIR, attribute: str, names: NameGenerator) -&gt; str:
    return names.private_name(cl.module_name, f"{cl.name}_get_{attribute}")
</t>
<t tx="ekr.20240308084832.385">def setter_name(cl: ClassIR, attribute: str, names: NameGenerator) -&gt; str:
    return names.private_name(cl.module_name, f"{cl.name}_set_{attribute}")
</t>
<t tx="ekr.20240308084832.386">def generate_object_struct(cl: ClassIR, emitter: Emitter) -&gt; None:
    seen_attrs: set[tuple[str, RType]] = set()
    lines: list[str] = []
    lines += ["typedef struct {", "PyObject_HEAD", "CPyVTableItem *vtable;"]
    if cl.has_method("__call__") and emitter.use_vectorcall():
        lines.append("vectorcallfunc vectorcall;")
    bitmap_attrs = []
    for base in reversed(cl.base_mro):
        if not base.is_trait:
            if base.bitmap_attrs:
                # Do we need another attribute bitmap field?
                if emitter.bitmap_field(len(base.bitmap_attrs) - 1) not in bitmap_attrs:
                    for i in range(0, len(base.bitmap_attrs), BITMAP_BITS):
                        attr = emitter.bitmap_field(i)
                        if attr not in bitmap_attrs:
                            lines.append(f"{BITMAP_TYPE} {attr};")
                            bitmap_attrs.append(attr)
            for attr, rtype in base.attributes.items():
                if (attr, rtype) not in seen_attrs:
                    lines.append(f"{emitter.ctype_spaced(rtype)}{emitter.attr(attr)};")
                    seen_attrs.add((attr, rtype))

                    if isinstance(rtype, RTuple):
                        emitter.declare_tuple_struct(rtype)

    lines.append(f"}} {cl.struct_name(emitter.names)};")
    lines.append("")
    emitter.context.declarations[cl.struct_name(emitter.names)] = HeaderDeclaration(
        lines, is_type=True
    )
</t>
<t tx="ekr.20240308084832.387">def generate_vtables(
    base: ClassIR, vtable_setup_name: str, vtable_name: str, emitter: Emitter, shadow: bool
) -&gt; str:
    """Emit the vtables and vtable setup functions for a class.

    This includes both the primary vtable and any trait implementation vtables.
    The trait vtables go before the main vtable, and have the following layout:
        {
            CPyType_T1,         // pointer to type object
            C_T1_trait_vtable,  // pointer to array of method pointers
            C_T1_offset_table,  // pointer to array of attribute offsets
            CPyType_T2,
            C_T2_trait_vtable,
            C_T2_offset_table,
            ...
        }
    The method implementations are calculated at the end of IR pass, attribute
    offsets are {offsetof(native__C, _x1), offsetof(native__C, _y1), ...}.

    To account for both dynamic loading and dynamic class creation,
    vtables are populated dynamically at class creation time, so we
    emit empty array definitions to store the vtables and a function to
    populate them.

    If shadow is True, generate "shadow vtables" that point to the
    shadow glue methods (which should dispatch via the Python C-API).

    Returns the expression to use to refer to the vtable, which might be
    different than the name, if there are trait vtables.
    """

    def trait_vtable_name(trait: ClassIR) -&gt; str:
        return "{}_{}_trait_vtable{}".format(
            base.name_prefix(emitter.names),
            trait.name_prefix(emitter.names),
            "_shadow" if shadow else "",
        )

    def trait_offset_table_name(trait: ClassIR) -&gt; str:
        return "{}_{}_offset_table".format(
            base.name_prefix(emitter.names), trait.name_prefix(emitter.names)
        )

    # Emit array definitions with enough space for all the entries
    emitter.emit_line(
        "static CPyVTableItem {}[{}];".format(
            vtable_name, max(1, len(base.vtable_entries) + 3 * len(base.trait_vtables))
        )
    )

    for trait, vtable in base.trait_vtables.items():
        # Trait methods entry (vtable index -&gt; method implementation).
        emitter.emit_line(
            f"static CPyVTableItem {trait_vtable_name(trait)}[{max(1, len(vtable))}];"
        )
        # Trait attributes entry (attribute number in trait -&gt; offset in actual struct).
        emitter.emit_line(
            "static size_t {}[{}];".format(
                trait_offset_table_name(trait), max(1, len(trait.attributes))
            )
        )

    # Emit vtable setup function
    emitter.emit_line("static bool")
    emitter.emit_line(f"{NATIVE_PREFIX}{vtable_setup_name}(void)")
    emitter.emit_line("{")

    if base.allow_interpreted_subclasses and not shadow:
        emitter.emit_line(f"{NATIVE_PREFIX}{vtable_setup_name}_shadow();")

    subtables = []
    for trait, vtable in base.trait_vtables.items():
        name = trait_vtable_name(trait)
        offset_name = trait_offset_table_name(trait)
        generate_vtable(vtable, name, emitter, [], shadow)
        generate_offset_table(offset_name, emitter, trait, base)
        subtables.append((trait, name, offset_name))

    generate_vtable(base.vtable_entries, vtable_name, emitter, subtables, shadow)

    emitter.emit_line("return 1;")
    emitter.emit_line("}")

    return vtable_name if not subtables else f"{vtable_name} + {len(subtables) * 3}"
</t>
<t tx="ekr.20240308084832.388">def generate_offset_table(
    trait_offset_table_name: str, emitter: Emitter, trait: ClassIR, cl: ClassIR
) -&gt; None:
    """Generate attribute offset row of a trait vtable."""
    emitter.emit_line(f"size_t {trait_offset_table_name}_scratch[] = {{")
    for attr in trait.attributes:
        emitter.emit_line(f"offsetof({cl.struct_name(emitter.names)}, {emitter.attr(attr)}),")
    if not trait.attributes:
        # This is for msvc.
        emitter.emit_line("0")
    emitter.emit_line("};")
    emitter.emit_line(
        "memcpy({name}, {name}_scratch, sizeof({name}));".format(name=trait_offset_table_name)
    )
</t>
<t tx="ekr.20240308084832.389">def generate_vtable(
    entries: VTableEntries,
    vtable_name: str,
    emitter: Emitter,
    subtables: list[tuple[ClassIR, str, str]],
    shadow: bool,
) -&gt; None:
    emitter.emit_line(f"CPyVTableItem {vtable_name}_scratch[] = {{")
    if subtables:
        emitter.emit_line("/* Array of trait vtables */")
        for trait, table, offset_table in subtables:
            emitter.emit_line(
                "(CPyVTableItem){}, (CPyVTableItem){}, (CPyVTableItem){},".format(
                    emitter.type_struct_name(trait), table, offset_table
                )
            )
        emitter.emit_line("/* Start of real vtable */")

    for entry in entries:
        method = entry.shadow_method if shadow and entry.shadow_method else entry.method
        emitter.emit_line(
            "(CPyVTableItem){}{}{},".format(
                emitter.get_group_prefix(entry.method.decl),
                NATIVE_PREFIX,
                method.cname(emitter.names),
            )
        )

    # msvc doesn't allow empty arrays; maybe allowing them at all is an extension?
    if not entries:
        emitter.emit_line("NULL")
    emitter.emit_line("};")
    emitter.emit_line("memcpy({name}, {name}_scratch, sizeof({name}));".format(name=vtable_name))
</t>
<t tx="ekr.20240308084832.39">def warning(self, msg: str, path: str, line: int) -&gt; None:
    self._errors.report(line, None, msg, severity="warning", file=path)
    self.num_warnings += 1
</t>
<t tx="ekr.20240308084832.390">def generate_setup_for_class(
    cl: ClassIR,
    func_name: str,
    defaults_fn: FuncIR | None,
    vtable_name: str,
    shadow_vtable_name: str | None,
    emitter: Emitter,
) -&gt; None:
    """Generate a native function that allocates an instance of a class."""
    emitter.emit_line("static PyObject *")
    emitter.emit_line(f"{func_name}(PyTypeObject *type)")
    emitter.emit_line("{")
    emitter.emit_line(f"{cl.struct_name(emitter.names)} *self;")
    emitter.emit_line(f"self = ({cl.struct_name(emitter.names)} *)type-&gt;tp_alloc(type, 0);")
    emitter.emit_line("if (self == NULL)")
    emitter.emit_line("    return NULL;")

    if shadow_vtable_name:
        emitter.emit_line(f"if (type != {emitter.type_struct_name(cl)}) {{")
        emitter.emit_line(f"self-&gt;vtable = {shadow_vtable_name};")
        emitter.emit_line("} else {")
        emitter.emit_line(f"self-&gt;vtable = {vtable_name};")
        emitter.emit_line("}")
    else:
        emitter.emit_line(f"self-&gt;vtable = {vtable_name};")
    for i in range(0, len(cl.bitmap_attrs), BITMAP_BITS):
        field = emitter.bitmap_field(i)
        emitter.emit_line(f"self-&gt;{field} = 0;")

    if cl.has_method("__call__") and emitter.use_vectorcall():
        name = cl.method_decl("__call__").cname(emitter.names)
        emitter.emit_line(f"self-&gt;vectorcall = {PREFIX}{name};")

    for base in reversed(cl.base_mro):
        for attr, rtype in base.attributes.items():
            value = emitter.c_undefined_value(rtype)

            # We don't need to set this field to NULL since tp_alloc() already
            # zero-initializes `self`.
            if value != "NULL":
                emitter.emit_line(rf"self-&gt;{emitter.attr(attr)} = {value};")

    # Initialize attributes to default values, if necessary
    if defaults_fn is not None:
        emitter.emit_lines(
            "if ({}{}((PyObject *)self) == 0) {{".format(
                NATIVE_PREFIX, defaults_fn.cname(emitter.names)
            ),
            "Py_DECREF(self);",
            "return NULL;",
            "}",
        )

    emitter.emit_line("return (PyObject *)self;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.391">def generate_constructor_for_class(
    cl: ClassIR,
    fn: FuncDecl,
    init_fn: FuncIR | None,
    setup_name: str,
    vtable_name: str,
    emitter: Emitter,
) -&gt; None:
    """Generate a native function that allocates and initializes an instance of a class."""
    emitter.emit_line(f"{native_function_header(fn, emitter)}")
    emitter.emit_line("{")
    emitter.emit_line(f"PyObject *self = {setup_name}({emitter.type_struct_name(cl)});")
    emitter.emit_line("if (self == NULL)")
    emitter.emit_line("    return NULL;")
    args = ", ".join(["self"] + [REG_PREFIX + arg.name for arg in fn.sig.args])
    if init_fn is not None:
        emitter.emit_line(
            "char res = {}{}{}({});".format(
                emitter.get_group_prefix(init_fn.decl),
                NATIVE_PREFIX,
                init_fn.cname(emitter.names),
                args,
            )
        )
        emitter.emit_line("if (res == 2) {")
        emitter.emit_line("Py_DECREF(self);")
        emitter.emit_line("return NULL;")
        emitter.emit_line("}")

    # If there is a nontrivial ctor that we didn't define, invoke it via tp_init
    elif len(fn.sig.args) &gt; 1:
        emitter.emit_line(f"int res = {emitter.type_struct_name(cl)}-&gt;tp_init({args});")

        emitter.emit_line("if (res &lt; 0) {")
        emitter.emit_line("Py_DECREF(self);")
        emitter.emit_line("return NULL;")
        emitter.emit_line("}")

    emitter.emit_line("return self;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.392">def generate_init_for_class(cl: ClassIR, init_fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generate an init function suitable for use as tp_init.

    tp_init needs to be a function that returns an int, and our
    __init__ methods return a PyObject. Translate NULL to -1,
    everything else to 0.
    """
    func_name = f"{cl.name_prefix(emitter.names)}_init"

    emitter.emit_line("static int")
    emitter.emit_line(f"{func_name}(PyObject *self, PyObject *args, PyObject *kwds)")
    emitter.emit_line("{")
    if cl.allow_interpreted_subclasses or cl.builtin_base:
        emitter.emit_line(
            "return {}{}(self, args, kwds) != NULL ? 0 : -1;".format(
                PREFIX, init_fn.cname(emitter.names)
            )
        )
    else:
        emitter.emit_line("return 0;")
    emitter.emit_line("}")

    return func_name
</t>
<t tx="ekr.20240308084832.393">def generate_new_for_class(
    cl: ClassIR,
    func_name: str,
    vtable_name: str,
    setup_name: str,
    init_fn: FuncIR | None,
    emitter: Emitter,
) -&gt; None:
    emitter.emit_line("static PyObject *")
    emitter.emit_line(f"{func_name}(PyTypeObject *type, PyObject *args, PyObject *kwds)")
    emitter.emit_line("{")
    # TODO: Check and unbox arguments
    if not cl.allow_interpreted_subclasses:
        emitter.emit_line(f"if (type != {emitter.type_struct_name(cl)}) {{")
        emitter.emit_line(
            'PyErr_SetString(PyExc_TypeError, "interpreted classes cannot inherit from compiled");'
        )
        emitter.emit_line("return NULL;")
        emitter.emit_line("}")

    if not init_fn or cl.allow_interpreted_subclasses or cl.builtin_base or cl.is_serializable():
        # Match Python semantics -- __new__ doesn't call __init__.
        emitter.emit_line(f"return {setup_name}(type);")
    else:
        # __new__ of a native class implicitly calls __init__ so that we
        # can enforce that instances are always properly initialized. This
        # is needed to support always defined attributes.
        emitter.emit_line(f"PyObject *self = {setup_name}(type);")
        emitter.emit_lines("if (self == NULL)", "    return NULL;")
        emitter.emit_line(
            f"PyObject *ret = {PREFIX}{init_fn.cname(emitter.names)}(self, args, kwds);"
        )
        emitter.emit_lines("if (ret == NULL)", "    return NULL;")
        emitter.emit_line("return self;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.394">def generate_new_for_trait(cl: ClassIR, func_name: str, emitter: Emitter) -&gt; None:
    emitter.emit_line("static PyObject *")
    emitter.emit_line(f"{func_name}(PyTypeObject *type, PyObject *args, PyObject *kwds)")
    emitter.emit_line("{")
    emitter.emit_line(f"if (type != {emitter.type_struct_name(cl)}) {{")
    emitter.emit_line(
        "PyErr_SetString(PyExc_TypeError, "
        '"interpreted classes cannot inherit from compiled traits");'
    )
    emitter.emit_line("} else {")
    emitter.emit_line('PyErr_SetString(PyExc_TypeError, "traits may not be directly created");')
    emitter.emit_line("}")
    emitter.emit_line("return NULL;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.395">def generate_traverse_for_class(cl: ClassIR, func_name: str, emitter: Emitter) -&gt; None:
    """Emit function that performs cycle GC traversal of an instance."""
    emitter.emit_line("static int")
    emitter.emit_line(
        f"{func_name}({cl.struct_name(emitter.names)} *self, visitproc visit, void *arg)"
    )
    emitter.emit_line("{")
    for base in reversed(cl.base_mro):
        for attr, rtype in base.attributes.items():
            emitter.emit_gc_visit(f"self-&gt;{emitter.attr(attr)}", rtype)
    if has_managed_dict(cl, emitter):
        emitter.emit_line("_PyObject_VisitManagedDict((PyObject *)self, visit, arg);")
    elif cl.has_dict:
        struct_name = cl.struct_name(emitter.names)
        # __dict__ lives right after the struct and __weakref__ lives right after that
        emitter.emit_gc_visit(
            f"*((PyObject **)((char *)self + sizeof({struct_name})))", object_rprimitive
        )
        emitter.emit_gc_visit(
            f"*((PyObject **)((char *)self + sizeof(PyObject *) + sizeof({struct_name})))",
            object_rprimitive,
        )
    emitter.emit_line("return 0;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.396">def generate_clear_for_class(cl: ClassIR, func_name: str, emitter: Emitter) -&gt; None:
    emitter.emit_line("static int")
    emitter.emit_line(f"{func_name}({cl.struct_name(emitter.names)} *self)")
    emitter.emit_line("{")
    for base in reversed(cl.base_mro):
        for attr, rtype in base.attributes.items():
            emitter.emit_gc_clear(f"self-&gt;{emitter.attr(attr)}", rtype)
    if has_managed_dict(cl, emitter):
        emitter.emit_line("_PyObject_ClearManagedDict((PyObject *)self);")
    elif cl.has_dict:
        struct_name = cl.struct_name(emitter.names)
        # __dict__ lives right after the struct and __weakref__ lives right after that
        emitter.emit_gc_clear(
            f"*((PyObject **)((char *)self + sizeof({struct_name})))", object_rprimitive
        )
        emitter.emit_gc_clear(
            f"*((PyObject **)((char *)self + sizeof(PyObject *) + sizeof({struct_name})))",
            object_rprimitive,
        )
    emitter.emit_line("return 0;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.397">def generate_dealloc_for_class(
    cl: ClassIR, dealloc_func_name: str, clear_func_name: str, emitter: Emitter
) -&gt; None:
    emitter.emit_line("static void")
    emitter.emit_line(f"{dealloc_func_name}({cl.struct_name(emitter.names)} *self)")
    emitter.emit_line("{")
    emitter.emit_line("PyObject_GC_UnTrack(self);")
    # The trashcan is needed to handle deep recursive deallocations
    emitter.emit_line(f"CPy_TRASHCAN_BEGIN(self, {dealloc_func_name})")
    emitter.emit_line(f"{clear_func_name}(self);")
    emitter.emit_line("Py_TYPE(self)-&gt;tp_free((PyObject *)self);")
    emitter.emit_line("CPy_TRASHCAN_END(self)")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.398">def generate_methods_table(cl: ClassIR, name: str, emitter: Emitter) -&gt; None:
    emitter.emit_line(f"static PyMethodDef {name}[] = {{")
    for fn in cl.methods.values():
        if fn.decl.is_prop_setter or fn.decl.is_prop_getter:
            continue
        emitter.emit_line(f'{{"{fn.name}",')
        emitter.emit_line(f" (PyCFunction){PREFIX}{fn.cname(emitter.names)},")
        flags = ["METH_FASTCALL", "METH_KEYWORDS"]
        if fn.decl.kind == FUNC_STATICMETHOD:
            flags.append("METH_STATIC")
        elif fn.decl.kind == FUNC_CLASSMETHOD:
            flags.append("METH_CLASS")

        emitter.emit_line(" {}, NULL}},".format(" | ".join(flags)))

    # Provide a default __getstate__ and __setstate__
    if not cl.has_method("__setstate__") and not cl.has_method("__getstate__"):
        emitter.emit_lines(
            '{"__setstate__", (PyCFunction)CPyPickle_SetState, METH_O, NULL},',
            '{"__getstate__", (PyCFunction)CPyPickle_GetState, METH_NOARGS, NULL},',
        )

    emitter.emit_line("{NULL}  /* Sentinel */")
    emitter.emit_line("};")
</t>
<t tx="ekr.20240308084832.399">def generate_side_table_for_class(
    cl: ClassIR, name: str, type: str, slots: dict[str, str], emitter: Emitter
) -&gt; str | None:
    name = f"{cl.name_prefix(emitter.names)}_{name}"
    emitter.emit_line(f"static {type} {name} = {{")
    for field, value in slots.items():
        emitter.emit_line(f".{field} = {value},")
    emitter.emit_line("};")
    return name
</t>
<t tx="ekr.20240308084832.4">"""Mypyc command-line tool.

Usage:

    $ mypyc foo.py [...]
    $ python3 -c 'import foo'  # Uses compiled 'foo'


This is just a thin wrapper that generates a setup.py file that uses
mypycify, suitable for prototyping and testing.
"""

from __future__ import annotations

import os
import os.path
import subprocess
import sys

base_path = os.path.join(os.path.dirname(__file__), "..")

setup_format = """\
from setuptools import setup
from mypyc.build import mypycify

setup(name='mypyc_output',
      ext_modules=mypycify({}, opt_level="{}", debug_level="{}"),
)
"""


@others
if __name__ == "__main__":
    main()
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.40">def new_messages(self) -&gt; list[str]:
    return self._errors.new_messages()
</t>
<t tx="ekr.20240308084832.400">def generate_getseter_declarations(cl: ClassIR, emitter: Emitter) -&gt; None:
    if not cl.is_trait:
        for attr in cl.attributes:
            emitter.emit_line("static PyObject *")
            emitter.emit_line(
                "{}({} *self, void *closure);".format(
                    getter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
                )
            )
            emitter.emit_line("static int")
            emitter.emit_line(
                "{}({} *self, PyObject *value, void *closure);".format(
                    setter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
                )
            )

    for prop, (getter, setter) in cl.properties.items():
        if getter.decl.implicit:
            continue

        # Generate getter declaration
        emitter.emit_line("static PyObject *")
        emitter.emit_line(
            "{}({} *self, void *closure);".format(
                getter_name(cl, prop, emitter.names), cl.struct_name(emitter.names)
            )
        )

        # Generate property setter declaration if a setter exists
        if setter:
            emitter.emit_line("static int")
            emitter.emit_line(
                "{}({} *self, PyObject *value, void *closure);".format(
                    setter_name(cl, prop, emitter.names), cl.struct_name(emitter.names)
                )
            )
</t>
<t tx="ekr.20240308084832.401">def generate_getseters_table(cl: ClassIR, name: str, emitter: Emitter) -&gt; None:
    emitter.emit_line(f"static PyGetSetDef {name}[] = {{")
    if not cl.is_trait:
        for attr in cl.attributes:
            emitter.emit_line(f'{{"{attr}",')
            emitter.emit_line(
                " (getter){}, (setter){},".format(
                    getter_name(cl, attr, emitter.names), setter_name(cl, attr, emitter.names)
                )
            )
            emitter.emit_line(" NULL, NULL},")
    for prop, (getter, setter) in cl.properties.items():
        if getter.decl.implicit:
            continue

        emitter.emit_line(f'{{"{prop}",')
        emitter.emit_line(f" (getter){getter_name(cl, prop, emitter.names)},")

        if setter:
            emitter.emit_line(f" (setter){setter_name(cl, prop, emitter.names)},")
            emitter.emit_line("NULL, NULL},")
        else:
            emitter.emit_line("NULL, NULL, NULL},")

    if cl.has_dict:
        emitter.emit_line('{"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},')

    emitter.emit_line("{NULL}  /* Sentinel */")
    emitter.emit_line("};")
</t>
<t tx="ekr.20240308084832.402">def generate_getseters(cl: ClassIR, emitter: Emitter) -&gt; None:
    if not cl.is_trait:
        for i, (attr, rtype) in enumerate(cl.attributes.items()):
            generate_getter(cl, attr, rtype, emitter)
            emitter.emit_line("")
            generate_setter(cl, attr, rtype, emitter)
            if i &lt; len(cl.attributes) - 1:
                emitter.emit_line("")
    for prop, (getter, setter) in cl.properties.items():
        if getter.decl.implicit:
            continue

        rtype = getter.sig.ret_type
        emitter.emit_line("")
        generate_readonly_getter(cl, prop, rtype, getter, emitter)
        if setter:
            arg_type = setter.sig.args[1].type
            emitter.emit_line("")
            generate_property_setter(cl, prop, arg_type, setter, emitter)
</t>
<t tx="ekr.20240308084832.403">def generate_getter(cl: ClassIR, attr: str, rtype: RType, emitter: Emitter) -&gt; None:
    attr_field = emitter.attr(attr)
    emitter.emit_line("static PyObject *")
    emitter.emit_line(
        "{}({} *self, void *closure)".format(
            getter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
        )
    )
    emitter.emit_line("{")
    attr_expr = f"self-&gt;{attr_field}"

    # HACK: Don't consider refcounted values as always defined, since it's possible to
    #       access uninitialized values via 'gc.get_objects()'. Accessing non-refcounted
    #       values is benign.
    always_defined = cl.is_always_defined(attr) and not rtype.is_refcounted

    if not always_defined:
        emitter.emit_undefined_attr_check(rtype, attr_expr, "==", "self", attr, cl, unlikely=True)
        emitter.emit_line("PyErr_SetString(PyExc_AttributeError,")
        emitter.emit_line(f'    "attribute {repr(attr)} of {repr(cl.name)} undefined");')
        emitter.emit_line("return NULL;")
        emitter.emit_line("}")
    emitter.emit_inc_ref(f"self-&gt;{attr_field}", rtype)
    emitter.emit_box(f"self-&gt;{attr_field}", "retval", rtype, declare_dest=True)
    emitter.emit_line("return retval;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.404">def generate_setter(cl: ClassIR, attr: str, rtype: RType, emitter: Emitter) -&gt; None:
    attr_field = emitter.attr(attr)
    emitter.emit_line("static int")
    emitter.emit_line(
        "{}({} *self, PyObject *value, void *closure)".format(
            setter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
        )
    )
    emitter.emit_line("{")

    deletable = cl.is_deletable(attr)
    if not deletable:
        emitter.emit_line("if (value == NULL) {")
        emitter.emit_line("PyErr_SetString(PyExc_AttributeError,")
        emitter.emit_line(
            f'    "{repr(cl.name)} object attribute {repr(attr)} cannot be deleted");'
        )
        emitter.emit_line("return -1;")
        emitter.emit_line("}")

    # HACK: Don't consider refcounted values as always defined, since it's possible to
    #       access uninitialized values via 'gc.get_objects()'. Accessing non-refcounted
    #       values is benign.
    always_defined = cl.is_always_defined(attr) and not rtype.is_refcounted

    if rtype.is_refcounted:
        attr_expr = f"self-&gt;{attr_field}"
        if not always_defined:
            emitter.emit_undefined_attr_check(rtype, attr_expr, "!=", "self", attr, cl)
        emitter.emit_dec_ref(f"self-&gt;{attr_field}", rtype)
        if not always_defined:
            emitter.emit_line("}")

    if deletable:
        emitter.emit_line("if (value != NULL) {")

    if rtype.is_unboxed:
        emitter.emit_unbox("value", "tmp", rtype, error=ReturnHandler("-1"), declare_dest=True)
    elif is_same_type(rtype, object_rprimitive):
        emitter.emit_line("PyObject *tmp = value;")
    else:
        emitter.emit_cast("value", "tmp", rtype, declare_dest=True)
        emitter.emit_lines("if (!tmp)", "    return -1;")
    emitter.emit_inc_ref("tmp", rtype)
    emitter.emit_line(f"self-&gt;{attr_field} = tmp;")
    if rtype.error_overlap and not always_defined:
        emitter.emit_attr_bitmap_set("tmp", "self", rtype, cl, attr)

    if deletable:
        emitter.emit_line("} else")
        emitter.emit_line(f"    self-&gt;{attr_field} = {emitter.c_undefined_value(rtype)};")
        if rtype.error_overlap:
            emitter.emit_attr_bitmap_clear("self", rtype, cl, attr)
    emitter.emit_line("return 0;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.405">def generate_readonly_getter(
    cl: ClassIR, attr: str, rtype: RType, func_ir: FuncIR, emitter: Emitter
) -&gt; None:
    emitter.emit_line("static PyObject *")
    emitter.emit_line(
        "{}({} *self, void *closure)".format(
            getter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
        )
    )
    emitter.emit_line("{")
    if rtype.is_unboxed:
        emitter.emit_line(
            "{}retval = {}{}((PyObject *) self);".format(
                emitter.ctype_spaced(rtype), NATIVE_PREFIX, func_ir.cname(emitter.names)
            )
        )
        emitter.emit_error_check("retval", rtype, "return NULL;")
        emitter.emit_box("retval", "retbox", rtype, declare_dest=True)
        emitter.emit_line("return retbox;")
    else:
        emitter.emit_line(
            f"return {NATIVE_PREFIX}{func_ir.cname(emitter.names)}((PyObject *) self);"
        )
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.406">def generate_property_setter(
    cl: ClassIR, attr: str, arg_type: RType, func_ir: FuncIR, emitter: Emitter
) -&gt; None:
    emitter.emit_line("static int")
    emitter.emit_line(
        "{}({} *self, PyObject *value, void *closure)".format(
            setter_name(cl, attr, emitter.names), cl.struct_name(emitter.names)
        )
    )
    emitter.emit_line("{")
    if arg_type.is_unboxed:
        emitter.emit_unbox("value", "tmp", arg_type, error=ReturnHandler("-1"), declare_dest=True)
        emitter.emit_line(
            f"{NATIVE_PREFIX}{func_ir.cname(emitter.names)}((PyObject *) self, tmp);"
        )
    else:
        emitter.emit_line(
            f"{NATIVE_PREFIX}{func_ir.cname(emitter.names)}((PyObject *) self, value);"
        )
    emitter.emit_line("return 0;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.407">def has_managed_dict(cl: ClassIR, emitter: Emitter) -&gt; bool:
    """Should the class get the Py_TPFLAGS_MANAGED_DICT flag?"""
    # On 3.11 and earlier the flag doesn't exist and we use
    # tp_dictoffset instead.  If a class inherits from Exception, the
    # flag conflicts with tp_dictoffset set in the base class.
    return (
        emitter.capi_version &gt;= (3, 12)
        and cl.has_dict
        and cl.builtin_base != "PyBaseExceptionObject"
    )
</t>
<t tx="ekr.20240308084832.408">"""Code generation for native function bodies."""

from __future__ import annotations

from typing import Final

from mypyc.analysis.blockfreq import frequently_executed_blocks
from mypyc.codegen.emit import DEBUG_ERRORS, Emitter, TracebackAndGotoHandler, c_array_initializer
from mypyc.common import MODULE_PREFIX, NATIVE_PREFIX, REG_PREFIX, STATIC_PREFIX, TYPE_PREFIX
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FUNC_CLASSMETHOD, FUNC_STATICMETHOD, FuncDecl, FuncIR, all_values
from mypyc.ir.ops import (
    ERR_FALSE,
    NAMESPACE_MODULE,
    NAMESPACE_STATIC,
    NAMESPACE_TYPE,
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    ControlOp,
    DecRef,
    Extend,
    Float,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    IncRef,
    InitStatic,
    Integer,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadGlobal,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    Op,
    OpVisitor,
    RaiseStandardError,
    Register,
    Return,
    SetAttr,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unborrow,
    Unbox,
    Unreachable,
    Value,
)
from mypyc.ir.pprint import generate_names_for_ir
from mypyc.ir.rtypes import (
    RArray,
    RStruct,
    RTuple,
    RType,
    is_int32_rprimitive,
    is_int64_rprimitive,
    is_int_rprimitive,
    is_pointer_rprimitive,
    is_tagged,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.409">def native_function_type(fn: FuncIR, emitter: Emitter) -&gt; str:
    args = ", ".join(emitter.ctype(arg.type) for arg in fn.args) or "void"
    ret = emitter.ctype(fn.ret_type)
    return f"{ret} (*)({args})"
</t>
<t tx="ekr.20240308084832.41">def flush_errors(self) -&gt; None:
    for error in self.new_messages():
        print(error)
</t>
<t tx="ekr.20240308084832.410">def native_function_header(fn: FuncDecl, emitter: Emitter) -&gt; str:
    args = []
    for arg in fn.sig.args:
        args.append(f"{emitter.ctype_spaced(arg.type)}{REG_PREFIX}{arg.name}")

    return "{ret_type}{name}({args})".format(
        ret_type=emitter.ctype_spaced(fn.sig.ret_type),
        name=emitter.native_function_name(fn),
        args=", ".join(args) or "void",
    )
</t>
<t tx="ekr.20240308084832.411">def generate_native_function(
    fn: FuncIR, emitter: Emitter, source_path: str, module_name: str
) -&gt; None:
    declarations = Emitter(emitter.context)
    names = generate_names_for_ir(fn.arg_regs, fn.blocks)
    body = Emitter(emitter.context, names)
    visitor = FunctionEmitterVisitor(body, declarations, source_path, module_name)

    declarations.emit_line(f"{native_function_header(fn.decl, emitter)} {{")
    body.indent()

    for r in all_values(fn.arg_regs, fn.blocks):
        if isinstance(r.type, RTuple):
            emitter.declare_tuple_struct(r.type)
        if isinstance(r.type, RArray):
            continue  # Special: declared on first assignment

        if r in fn.arg_regs:
            continue  # Skip the arguments

        ctype = emitter.ctype_spaced(r.type)
        init = ""
        declarations.emit_line(
            "{ctype}{prefix}{name}{init};".format(
                ctype=ctype, prefix=REG_PREFIX, name=names[r], init=init
            )
        )

    # Before we emit the blocks, give them all labels
    blocks = fn.blocks
    for i, block in enumerate(blocks):
        block.label = i

    # Find blocks that are never jumped to or are only jumped to from the
    # block directly above it. This allows for more labels and gotos to be
    # eliminated during code generation.
    for block in fn.blocks:
        terminator = block.terminator
        assert isinstance(terminator, ControlOp)

        for target in terminator.targets():
            is_next_block = target.label == block.label + 1

            # Always emit labels for GetAttr error checks since the emit code that
            # generates them will add instructions between the branch and the
            # next label, causing the label to be wrongly removed. A better
            # solution would be to change the IR so that it adds a basic block
            # inbetween the calls.
            is_problematic_op = isinstance(terminator, Branch) and any(
                isinstance(s, GetAttr) for s in terminator.sources()
            )

            if not is_next_block or is_problematic_op:
                fn.blocks[target.label].referenced = True

    common = frequently_executed_blocks(fn.blocks[0])

    for i in range(len(blocks)):
        block = blocks[i]
        visitor.rare = block not in common
        next_block = None
        if i + 1 &lt; len(blocks):
            next_block = blocks[i + 1]
        body.emit_label(block)
        visitor.next_block = next_block

        ops = block.ops
        visitor.ops = ops
        visitor.op_index = 0
        while visitor.op_index &lt; len(ops):
            ops[visitor.op_index].accept(visitor)
            visitor.op_index += 1

    body.emit_line("}")

    emitter.emit_from_emitter(declarations)
    emitter.emit_from_emitter(body)
</t>
<t tx="ekr.20240308084832.412">class FunctionEmitterVisitor(OpVisitor[None]):
    @others
</t>
<t tx="ekr.20240308084832.413">def __init__(
    self, emitter: Emitter, declarations: Emitter, source_path: str, module_name: str
) -&gt; None:
    self.emitter = emitter
    self.names = emitter.names
    self.declarations = declarations
    self.source_path = source_path
    self.module_name = module_name
    self.literals = emitter.context.literals
    self.rare = False
    # Next basic block to be processed after the current one (if any), set by caller
    self.next_block: BasicBlock | None = None
    # Ops in the basic block currently being processed, set by caller
    self.ops: list[Op] = []
    # Current index within ops; visit methods can increment this to skip/merge ops
    self.op_index = 0
</t>
<t tx="ekr.20240308084832.414">def temp_name(self) -&gt; str:
    return self.emitter.temp_name()
</t>
<t tx="ekr.20240308084832.415">def visit_goto(self, op: Goto) -&gt; None:
    if op.label is not self.next_block:
        self.emit_line("goto %s;" % self.label(op.label))
</t>
<t tx="ekr.20240308084832.416">def visit_branch(self, op: Branch) -&gt; None:
    true, false = op.true, op.false
    negated = op.negated
    negated_rare = False
    if true is self.next_block and op.traceback_entry is None:
        # Switch true/false since it avoids an else block.
        true, false = false, true
        negated = not negated
        negated_rare = True

    neg = "!" if negated else ""
    cond = ""
    if op.op == Branch.BOOL:
        expr_result = self.reg(op.value)
        cond = f"{neg}{expr_result}"
    elif op.op == Branch.IS_ERROR:
        typ = op.value.type
        compare = "!=" if negated else "=="
        if isinstance(typ, RTuple):
            # TODO: What about empty tuple?
            cond = self.emitter.tuple_undefined_check_cond(
                typ, self.reg(op.value), self.c_error_value, compare
            )
        else:
            cond = f"{self.reg(op.value)} {compare} {self.c_error_value(typ)}"
    else:
        assert False, "Invalid branch"

    # For error checks, tell the compiler the branch is unlikely
    if op.traceback_entry is not None or op.rare:
        if not negated_rare:
            cond = f"unlikely({cond})"
        else:
            cond = f"likely({cond})"

    if false is self.next_block:
        if op.traceback_entry is None:
            if true is not self.next_block:
                self.emit_line(f"if ({cond}) goto {self.label(true)};")
        else:
            self.emit_line(f"if ({cond}) {{")
            self.emit_traceback(op)
            self.emit_lines("goto %s;" % self.label(true), "}")
    else:
        self.emit_line(f"if ({cond}) {{")
        self.emit_traceback(op)

        if true is not self.next_block:
            self.emit_line("goto %s;" % self.label(true))

        self.emit_lines("} else", "    goto %s;" % self.label(false))
</t>
<t tx="ekr.20240308084832.417">def visit_return(self, op: Return) -&gt; None:
    value_str = self.reg(op.value)
    self.emit_line("return %s;" % value_str)
</t>
<t tx="ekr.20240308084832.418">def visit_tuple_set(self, op: TupleSet) -&gt; None:
    dest = self.reg(op)
    tuple_type = op.tuple_type
    self.emitter.declare_tuple_struct(tuple_type)
    if len(op.items) == 0:  # empty tuple
        self.emit_line(f"{dest}.empty_struct_error_flag = 0;")
    else:
        for i, item in enumerate(op.items):
            self.emit_line(f"{dest}.f{i} = {self.reg(item)};")
</t>
<t tx="ekr.20240308084832.419">def visit_assign(self, op: Assign) -&gt; None:
    dest = self.reg(op.dest)
    src = self.reg(op.src)
    # clang whines about self assignment (which we might generate
    # for some casts), so don't emit it.
    if dest != src:
        # We sometimes assign from an integer prepresentation of a pointer
        # to a real pointer, and C compilers insist on a cast.
        if op.src.type.is_unboxed and not op.dest.type.is_unboxed:
            src = f"(void *){src}"
        self.emit_line(f"{dest} = {src};")
</t>
<t tx="ekr.20240308084832.42">from __future__ import annotations

from typing import Iterable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.420">def visit_assign_multi(self, op: AssignMulti) -&gt; None:
    typ = op.dest.type
    assert isinstance(typ, RArray)
    dest = self.reg(op.dest)
    # RArray values can only be assigned to once, so we can always
    # declare them on initialization.
    self.emit_line(
        "%s%s[%d] = %s;"
        % (
            self.emitter.ctype_spaced(typ.item_type),
            dest,
            len(op.src),
            c_array_initializer([self.reg(s) for s in op.src], indented=True),
        )
    )
</t>
<t tx="ekr.20240308084832.421">def visit_load_error_value(self, op: LoadErrorValue) -&gt; None:
    if isinstance(op.type, RTuple):
        values = [self.c_undefined_value(item) for item in op.type.types]
        tmp = self.temp_name()
        self.emit_line("{} {} = {{ {} }};".format(self.ctype(op.type), tmp, ", ".join(values)))
        self.emit_line(f"{self.reg(op)} = {tmp};")
    else:
        self.emit_line(f"{self.reg(op)} = {self.c_error_value(op.type)};")
</t>
<t tx="ekr.20240308084832.422">def visit_load_literal(self, op: LoadLiteral) -&gt; None:
    index = self.literals.literal_index(op.value)
    if not is_int_rprimitive(op.type):
        self.emit_line("%s = CPyStatics[%d];" % (self.reg(op), index), ann=op.value)
    else:
        self.emit_line(
            "%s = (CPyTagged)CPyStatics[%d] | 1;" % (self.reg(op), index), ann=op.value
        )
</t>
<t tx="ekr.20240308084832.423">def get_attr_expr(self, obj: str, op: GetAttr | SetAttr, decl_cl: ClassIR) -&gt; str:
    """Generate attribute accessor for normal (non-property) access.

    This either has a form like obj-&gt;attr_name for attributes defined in non-trait
    classes, and *(obj + attr_offset) for attributes defined by traits. We also
    insert all necessary C casts here.
    """
    cast = f"({op.class_type.struct_name(self.emitter.names)} *)"
    if decl_cl.is_trait and op.class_type.class_ir.is_trait:
        # For pure trait access find the offset first, offsets
        # are ordered by attribute position in the cl.attributes dict.
        # TODO: pre-calculate the mapping to make this faster.
        trait_attr_index = list(decl_cl.attributes).index(op.attr)
        # TODO: reuse these names somehow?
        offset = self.emitter.temp_name()
        self.declarations.emit_line(f"size_t {offset};")
        self.emitter.emit_line(
            "{} = {};".format(
                offset,
                "CPy_FindAttrOffset({}, {}, {})".format(
                    self.emitter.type_struct_name(decl_cl),
                    f"({cast}{obj})-&gt;vtable",
                    trait_attr_index,
                ),
            )
        )
        attr_cast = f"({self.ctype(op.class_type.attr_type(op.attr))} *)"
        return f"*{attr_cast}((char *){obj} + {offset})"
    else:
        # Cast to something non-trait. Note: for this to work, all struct
        # members for non-trait classes must obey monotonic linear growth.
        if op.class_type.class_ir.is_trait:
            assert not decl_cl.is_trait
            cast = f"({decl_cl.struct_name(self.emitter.names)} *)"
        return f"({cast}{obj})-&gt;{self.emitter.attr(op.attr)}"
</t>
<t tx="ekr.20240308084832.424">def visit_get_attr(self, op: GetAttr) -&gt; None:
    dest = self.reg(op)
    obj = self.reg(op.obj)
    rtype = op.class_type
    cl = rtype.class_ir
    attr_rtype, decl_cl = cl.attr_details(op.attr)
    prefer_method = cl.is_trait and attr_rtype.error_overlap
    if cl.get_method(op.attr, prefer_method=prefer_method):
        # Properties are essentially methods, so use vtable access for them.
        version = "_TRAIT" if cl.is_trait else ""
        self.emit_line(
            "%s = CPY_GET_ATTR%s(%s, %s, %d, %s, %s); /* %s */"
            % (
                dest,
                version,
                obj,
                self.emitter.type_struct_name(rtype.class_ir),
                rtype.getter_index(op.attr),
                rtype.struct_name(self.names),
                self.ctype(rtype.attr_type(op.attr)),
                op.attr,
            )
        )
    else:
        # Otherwise, use direct or offset struct access.
        attr_expr = self.get_attr_expr(obj, op, decl_cl)
        self.emitter.emit_line(f"{dest} = {attr_expr};")
        always_defined = cl.is_always_defined(op.attr)
        merged_branch = None
        if not always_defined:
            self.emitter.emit_undefined_attr_check(
                attr_rtype, dest, "==", obj, op.attr, cl, unlikely=True
            )
            branch = self.next_branch()
            if branch is not None:
                if (
                    branch.value is op
                    and branch.op == Branch.IS_ERROR
                    and branch.traceback_entry is not None
                    and not branch.negated
                ):
                    # Generate code for the following branch here to avoid
                    # redundant branches in the generated code.
                    self.emit_attribute_error(branch, cl.name, op.attr)
                    self.emit_line("goto %s;" % self.label(branch.true))
                    merged_branch = branch
                    self.emitter.emit_line("}")
            if not merged_branch:
                exc_class = "PyExc_AttributeError"
                self.emitter.emit_line(
                    'PyErr_SetString({}, "attribute {} of {} undefined");'.format(
                        exc_class, repr(op.attr), repr(cl.name)
                    )
                )

        if attr_rtype.is_refcounted and not op.is_borrowed:
            if not merged_branch and not always_defined:
                self.emitter.emit_line("} else {")
            self.emitter.emit_inc_ref(dest, attr_rtype)
        if merged_branch:
            if merged_branch.false is not self.next_block:
                self.emit_line("goto %s;" % self.label(merged_branch.false))
            self.op_index += 1
        elif not always_defined:
            self.emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.425">def next_branch(self) -&gt; Branch | None:
    if self.op_index + 1 &lt; len(self.ops):
        next_op = self.ops[self.op_index + 1]
        if isinstance(next_op, Branch):
            return next_op
    return None
</t>
<t tx="ekr.20240308084832.426">def visit_set_attr(self, op: SetAttr) -&gt; None:
    if op.error_kind == ERR_FALSE:
        dest = self.reg(op)
    obj = self.reg(op.obj)
    src = self.reg(op.src)
    rtype = op.class_type
    cl = rtype.class_ir
    attr_rtype, decl_cl = cl.attr_details(op.attr)
    if cl.get_method(op.attr):
        # Again, use vtable access for properties...
        assert not op.is_init and op.error_kind == ERR_FALSE, "%s %d %d %s" % (
            op.attr,
            op.is_init,
            op.error_kind,
            rtype,
        )
        version = "_TRAIT" if cl.is_trait else ""
        self.emit_line(
            "%s = CPY_SET_ATTR%s(%s, %s, %d, %s, %s, %s); /* %s */"
            % (
                dest,
                version,
                obj,
                self.emitter.type_struct_name(rtype.class_ir),
                rtype.setter_index(op.attr),
                src,
                rtype.struct_name(self.names),
                self.ctype(rtype.attr_type(op.attr)),
                op.attr,
            )
        )
    else:
        # ...and struct access for normal attributes.
        attr_expr = self.get_attr_expr(obj, op, decl_cl)
        if not op.is_init and attr_rtype.is_refcounted:
            # This is not an initialization (where we know that the attribute was
            # previously undefined), so decref the old value.
            always_defined = cl.is_always_defined(op.attr)
            if not always_defined:
                self.emitter.emit_undefined_attr_check(
                    attr_rtype, attr_expr, "!=", obj, op.attr, cl
                )
            self.emitter.emit_dec_ref(attr_expr, attr_rtype)
            if not always_defined:
                self.emitter.emit_line("}")
        elif attr_rtype.error_overlap and not cl.is_always_defined(op.attr):
            # If there is overlap with the error value, update bitmap to mark
            # attribute as defined.
            self.emitter.emit_attr_bitmap_set(src, obj, attr_rtype, cl, op.attr)

        # This steals the reference to src, so we don't need to increment the arg
        self.emitter.emit_line(f"{attr_expr} = {src};")
        if op.error_kind == ERR_FALSE:
            self.emitter.emit_line(f"{dest} = 1;")
</t>
<t tx="ekr.20240308084832.427">PREFIX_MAP: Final = {
    NAMESPACE_STATIC: STATIC_PREFIX,
    NAMESPACE_TYPE: TYPE_PREFIX,
    NAMESPACE_MODULE: MODULE_PREFIX,
}

def visit_load_static(self, op: LoadStatic) -&gt; None:
    dest = self.reg(op)
    prefix = self.PREFIX_MAP[op.namespace]
    name = self.emitter.static_name(op.identifier, op.module_name, prefix)
    if op.namespace == NAMESPACE_TYPE:
        name = "(PyObject *)%s" % name
    self.emit_line(f"{dest} = {name};", ann=op.ann)
</t>
<t tx="ekr.20240308084832.428">def visit_init_static(self, op: InitStatic) -&gt; None:
    value = self.reg(op.value)
    prefix = self.PREFIX_MAP[op.namespace]
    name = self.emitter.static_name(op.identifier, op.module_name, prefix)
    if op.namespace == NAMESPACE_TYPE:
        value = "(PyTypeObject *)%s" % value
    self.emit_line(f"{name} = {value};")
    self.emit_inc_ref(name, op.value.type)
</t>
<t tx="ekr.20240308084832.429">def visit_tuple_get(self, op: TupleGet) -&gt; None:
    dest = self.reg(op)
    src = self.reg(op.src)
    self.emit_line(f"{dest} = {src}.f{op.index};")
    if not op.is_borrowed:
        self.emit_inc_ref(dest, op.type)
</t>
<t tx="ekr.20240308084832.43">class NameGenerator:
    """Utility for generating distinct C names from Python names.
    
    Since C names can't use '.' (or unicode), some care is required to
    make C names generated from Python names unique. Also, we want to
    avoid generating overly long C names since they make the generated
    code harder to read.
    
    Note that we don't restrict ourselves to a 32-character distinguishing
    prefix guaranteed by the C standard since all the compilers we care
    about at the moment support longer names without issues.
    
    For names that are exported in a shared library (not static) use
    exported_name() instead.
    
    Summary of the approach:
    
    * Generate a unique name prefix from suffix of fully-qualified
      module name used for static names. If only compiling a single
      module, this can be empty. For example, if the modules are
      'foo.bar' and 'foo.baz', the prefixes can be 'bar_' and 'baz_',
      respectively. If the modules are 'bar.foo' and 'baz.foo', the
      prefixes will be 'bar_foo_' and 'baz_foo_'.
    
    * Replace '.' in the Python name with '___' in the C name. (And
      replace the unlikely but possible '___' with '___3_'. This
      collides '___' with '.3_', but this is OK because names
      may not start with a digit.)
    
    The generated should be internal to a build and thus the mapping is
    arbitrary. Just generating names '1', '2', ... would be correct,
    though not very usable.
    """
    @others
</t>
<t tx="ekr.20240308084832.430">def get_dest_assign(self, dest: Value) -&gt; str:
    if not dest.is_void:
        return self.reg(dest) + " = "
    else:
        return ""
</t>
<t tx="ekr.20240308084832.431">def visit_call(self, op: Call) -&gt; None:
    """Call native function."""
    dest = self.get_dest_assign(op)
    args = ", ".join(self.reg(arg) for arg in op.args)
    lib = self.emitter.get_group_prefix(op.fn)
    cname = op.fn.cname(self.names)
    self.emit_line(f"{dest}{lib}{NATIVE_PREFIX}{cname}({args});")
</t>
<t tx="ekr.20240308084832.432">def visit_method_call(self, op: MethodCall) -&gt; None:
    """Call native method."""
    dest = self.get_dest_assign(op)
    obj = self.reg(op.obj)

    rtype = op.receiver_type
    class_ir = rtype.class_ir
    name = op.method
    method = rtype.class_ir.get_method(name)
    assert method is not None

    # Can we call the method directly, bypassing vtable?
    is_direct = class_ir.is_method_final(name)

    # The first argument gets omitted for static methods and
    # turned into the class for class methods
    obj_args = (
        []
        if method.decl.kind == FUNC_STATICMETHOD
        else [f"(PyObject *)Py_TYPE({obj})"]
        if method.decl.kind == FUNC_CLASSMETHOD
        else [obj]
    )
    args = ", ".join(obj_args + [self.reg(arg) for arg in op.args])
    mtype = native_function_type(method, self.emitter)
    version = "_TRAIT" if rtype.class_ir.is_trait else ""
    if is_direct:
        # Directly call method, without going through the vtable.
        lib = self.emitter.get_group_prefix(method.decl)
        self.emit_line(f"{dest}{lib}{NATIVE_PREFIX}{method.cname(self.names)}({args});")
    else:
        # Call using vtable.
        method_idx = rtype.method_index(name)
        self.emit_line(
            "{}CPY_GET_METHOD{}({}, {}, {}, {}, {})({}); /* {} */".format(
                dest,
                version,
                obj,
                self.emitter.type_struct_name(rtype.class_ir),
                method_idx,
                rtype.struct_name(self.names),
                mtype,
                args,
                op.method,
            )
        )
</t>
<t tx="ekr.20240308084832.433">def visit_inc_ref(self, op: IncRef) -&gt; None:
    src = self.reg(op.src)
    self.emit_inc_ref(src, op.src.type)
</t>
<t tx="ekr.20240308084832.434">def visit_dec_ref(self, op: DecRef) -&gt; None:
    src = self.reg(op.src)
    self.emit_dec_ref(src, op.src.type, is_xdec=op.is_xdec)
</t>
<t tx="ekr.20240308084832.435">def visit_box(self, op: Box) -&gt; None:
    self.emitter.emit_box(self.reg(op.src), self.reg(op), op.src.type, can_borrow=True)
</t>
<t tx="ekr.20240308084832.436">def visit_cast(self, op: Cast) -&gt; None:
    branch = self.next_branch()
    handler = None
    if branch is not None:
        if (
            branch.value is op
            and branch.op == Branch.IS_ERROR
            and branch.traceback_entry is not None
            and not branch.negated
            and branch.false is self.next_block
        ):
            # Generate code also for the following branch here to avoid
            # redundant branches in the generated code.
            handler = TracebackAndGotoHandler(
                self.label(branch.true),
                self.source_path,
                self.module_name,
                branch.traceback_entry,
            )
            self.op_index += 1

    self.emitter.emit_cast(
        self.reg(op.src), self.reg(op), op.type, src_type=op.src.type, error=handler
    )
</t>
<t tx="ekr.20240308084832.437">def visit_unbox(self, op: Unbox) -&gt; None:
    self.emitter.emit_unbox(self.reg(op.src), self.reg(op), op.type)
</t>
<t tx="ekr.20240308084832.438">def visit_unreachable(self, op: Unreachable) -&gt; None:
    self.emitter.emit_line("CPy_Unreachable();")
</t>
<t tx="ekr.20240308084832.439">def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; None:
    # TODO: Better escaping of backspaces and such
    if op.value is not None:
        if isinstance(op.value, str):
            message = op.value.replace('"', '\\"')
            self.emitter.emit_line(f'PyErr_SetString(PyExc_{op.class_name}, "{message}");')
        elif isinstance(op.value, Value):
            self.emitter.emit_line(
                "PyErr_SetObject(PyExc_{}, {});".format(
                    op.class_name, self.emitter.reg(op.value)
                )
            )
        else:
            assert False, "op value type must be either str or Value"
    else:
        self.emitter.emit_line(f"PyErr_SetNone(PyExc_{op.class_name});")
    self.emitter.emit_line(f"{self.reg(op)} = 0;")
</t>
<t tx="ekr.20240308084832.44">def __init__(self, groups: Iterable[list[str]]) -&gt; None:
    """Initialize with a list of modules in each compilation group.

    The names of modules are used to shorten names referring to
    modules, for convenience. Arbitrary module
    names are supported for generated names, but uncompiled modules
    will use long names.
    """
    self.module_map: dict[str, str] = {}
    for names in groups:
        self.module_map.update(make_module_translation_map(names))
    self.translations: dict[tuple[str, str], str] = {}
    self.used_names: set[str] = set()
</t>
<t tx="ekr.20240308084832.440">def visit_call_c(self, op: CallC) -&gt; None:
    if op.is_void:
        dest = ""
    else:
        dest = self.get_dest_assign(op)
    args = ", ".join(self.reg(arg) for arg in op.args)
    self.emitter.emit_line(f"{dest}{op.function_name}({args});")
</t>
<t tx="ekr.20240308084832.441">def visit_truncate(self, op: Truncate) -&gt; None:
    dest = self.reg(op)
    value = self.reg(op.src)
    # for C backend the generated code are straight assignments
    self.emit_line(f"{dest} = {value};")
</t>
<t tx="ekr.20240308084832.442">def visit_extend(self, op: Extend) -&gt; None:
    dest = self.reg(op)
    value = self.reg(op.src)
    if op.signed:
        src_cast = self.emit_signed_int_cast(op.src.type)
    else:
        src_cast = self.emit_unsigned_int_cast(op.src.type)
    self.emit_line(f"{dest} = {src_cast}{value};")
</t>
<t tx="ekr.20240308084832.443">def visit_load_global(self, op: LoadGlobal) -&gt; None:
    dest = self.reg(op)
    self.emit_line(f"{dest} = {op.identifier};", ann=op.ann)
</t>
<t tx="ekr.20240308084832.444">def visit_int_op(self, op: IntOp) -&gt; None:
    dest = self.reg(op)
    lhs = self.reg(op.lhs)
    rhs = self.reg(op.rhs)
    if op.op == IntOp.RIGHT_SHIFT:
        # Signed right shift
        lhs = self.emit_signed_int_cast(op.lhs.type) + lhs
        rhs = self.emit_signed_int_cast(op.rhs.type) + rhs
    self.emit_line(f"{dest} = {lhs} {op.op_str[op.op]} {rhs};")
</t>
<t tx="ekr.20240308084832.445">def visit_comparison_op(self, op: ComparisonOp) -&gt; None:
    dest = self.reg(op)
    lhs = self.reg(op.lhs)
    rhs = self.reg(op.rhs)
    lhs_cast = ""
    rhs_cast = ""
    if op.op in (ComparisonOp.SLT, ComparisonOp.SGT, ComparisonOp.SLE, ComparisonOp.SGE):
        # Always signed comparison op
        lhs_cast = self.emit_signed_int_cast(op.lhs.type)
        rhs_cast = self.emit_signed_int_cast(op.rhs.type)
    elif op.op in (ComparisonOp.ULT, ComparisonOp.UGT, ComparisonOp.ULE, ComparisonOp.UGE):
        # Always unsigned comparison op
        lhs_cast = self.emit_unsigned_int_cast(op.lhs.type)
        rhs_cast = self.emit_unsigned_int_cast(op.rhs.type)
    elif isinstance(op.lhs, Integer) and op.lhs.value &lt; 0:
        # Force signed ==/!= with negative operand
        rhs_cast = self.emit_signed_int_cast(op.rhs.type)
    elif isinstance(op.rhs, Integer) and op.rhs.value &lt; 0:
        # Force signed ==/!= with negative operand
        lhs_cast = self.emit_signed_int_cast(op.lhs.type)
    self.emit_line(f"{dest} = {lhs_cast}{lhs} {op.op_str[op.op]} {rhs_cast}{rhs};")
</t>
<t tx="ekr.20240308084832.446">def visit_float_op(self, op: FloatOp) -&gt; None:
    dest = self.reg(op)
    lhs = self.reg(op.lhs)
    rhs = self.reg(op.rhs)
    if op.op != FloatOp.MOD:
        self.emit_line(f"{dest} = {lhs} {op.op_str[op.op]} {rhs};")
    else:
        # TODO: This may set errno as a side effect, that is a little sketchy.
        self.emit_line(f"{dest} = fmod({lhs}, {rhs});")
</t>
<t tx="ekr.20240308084832.447">def visit_float_neg(self, op: FloatNeg) -&gt; None:
    dest = self.reg(op)
    src = self.reg(op.src)
    self.emit_line(f"{dest} = -{src};")
</t>
<t tx="ekr.20240308084832.448">def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; None:
    dest = self.reg(op)
    lhs = self.reg(op.lhs)
    rhs = self.reg(op.rhs)
    self.emit_line(f"{dest} = {lhs} {op.op_str[op.op]} {rhs};")
</t>
<t tx="ekr.20240308084832.449">def visit_load_mem(self, op: LoadMem) -&gt; None:
    dest = self.reg(op)
    src = self.reg(op.src)
    # TODO: we shouldn't dereference to type that are pointer type so far
    type = self.ctype(op.type)
    self.emit_line(f"{dest} = *({type} *){src};")
</t>
<t tx="ekr.20240308084832.45">def private_name(self, module: str, partial_name: str | None = None) -&gt; str:
    """Return a C name usable for a static definition.

    Return a distinct result for each (module, partial_name) pair.

    The caller should add a suitable prefix to the name to avoid
    conflicts with other C names. Only ensure that the results of
    this function are unique, not that they aren't overlapping with
    arbitrary names.

    If a name is not specific to any module, the module argument can
    be an empty string.
    """
    # TODO: Support unicode
    if partial_name is None:
        return exported_name(self.module_map[module].rstrip("."))
    if (module, partial_name) in self.translations:
        return self.translations[module, partial_name]
    if module in self.module_map:
        module_prefix = self.module_map[module]
    elif module:
        module_prefix = module + "."
    else:
        module_prefix = ""
    actual = exported_name(f"{module_prefix}{partial_name}")
    self.translations[module, partial_name] = actual
    return actual
</t>
<t tx="ekr.20240308084832.450">def visit_set_mem(self, op: SetMem) -&gt; None:
    dest = self.reg(op.dest)
    src = self.reg(op.src)
    dest_type = self.ctype(op.dest_type)
    # clang whines about self assignment (which we might generate
    # for some casts), so don't emit it.
    if dest != src:
        self.emit_line(f"*({dest_type} *){dest} = {src};")
</t>
<t tx="ekr.20240308084832.451">def visit_get_element_ptr(self, op: GetElementPtr) -&gt; None:
    dest = self.reg(op)
    src = self.reg(op.src)
    # TODO: support tuple type
    assert isinstance(op.src_type, RStruct)
    assert op.field in op.src_type.names, "Invalid field name."
    self.emit_line(
        "{} = ({})&amp;(({} *){})-&gt;{};".format(
            dest, op.type._ctype, op.src_type.name, src, op.field
        )
    )
</t>
<t tx="ekr.20240308084832.452">def visit_load_address(self, op: LoadAddress) -&gt; None:
    typ = op.type
    dest = self.reg(op)
    if isinstance(op.src, Register):
        src = self.reg(op.src)
    elif isinstance(op.src, LoadStatic):
        prefix = self.PREFIX_MAP[op.src.namespace]
        src = self.emitter.static_name(op.src.identifier, op.src.module_name, prefix)
    else:
        src = op.src
    self.emit_line(f"{dest} = ({typ._ctype})&amp;{src};")
</t>
<t tx="ekr.20240308084832.453">def visit_keep_alive(self, op: KeepAlive) -&gt; None:
    # This is a no-op.
    pass
</t>
<t tx="ekr.20240308084832.454">def visit_unborrow(self, op: Unborrow) -&gt; None:
    # This is a no-op that propagates the source value.
    dest = self.reg(op)
    src = self.reg(op.src)
    self.emit_line(f"{dest} = {src};")
</t>
<t tx="ekr.20240308084832.455"># Helpers

def label(self, label: BasicBlock) -&gt; str:
    return self.emitter.label(label)
</t>
<t tx="ekr.20240308084832.456">def reg(self, reg: Value) -&gt; str:
    if isinstance(reg, Integer):
        val = reg.value
        if val == 0 and is_pointer_rprimitive(reg.type):
            return "NULL"
        s = str(val)
        if val &gt;= (1 &lt;&lt; 31):
            # Avoid overflowing signed 32-bit int
            if val &gt;= (1 &lt;&lt; 63):
                s += "ULL"
            else:
                s += "LL"
        elif val == -(1 &lt;&lt; 63):
            # Avoid overflowing C integer literal
            s = "(-9223372036854775807LL - 1)"
        elif val &lt;= -(1 &lt;&lt; 31):
            s += "LL"
        return s
    elif isinstance(reg, Float):
        r = repr(reg.value)
        if r == "inf":
            return "INFINITY"
        elif r == "-inf":
            return "-INFINITY"
        elif r == "nan":
            return "NAN"
        return r
    else:
        return self.emitter.reg(reg)
</t>
<t tx="ekr.20240308084832.457">def ctype(self, rtype: RType) -&gt; str:
    return self.emitter.ctype(rtype)
</t>
<t tx="ekr.20240308084832.458">def c_error_value(self, rtype: RType) -&gt; str:
    return self.emitter.c_error_value(rtype)
</t>
<t tx="ekr.20240308084832.459">def c_undefined_value(self, rtype: RType) -&gt; str:
    return self.emitter.c_undefined_value(rtype)
</t>
<t tx="ekr.20240308084832.46">def exported_name(fullname: str) -&gt; str:
    """Return a C name usable for an exported definition.

    This is like private_name(), but the output only depends on the
    'fullname' argument, so the names are distinct across multiple
    builds.
    """
    # TODO: Support unicode
    return fullname.replace("___", "___3_").replace(".", "___")
</t>
<t tx="ekr.20240308084832.460">def emit_line(self, line: str, *, ann: object = None) -&gt; None:
    self.emitter.emit_line(line, ann=ann)
</t>
<t tx="ekr.20240308084832.461">def emit_lines(self, *lines: str) -&gt; None:
    self.emitter.emit_lines(*lines)
</t>
<t tx="ekr.20240308084832.462">def emit_inc_ref(self, dest: str, rtype: RType) -&gt; None:
    self.emitter.emit_inc_ref(dest, rtype, rare=self.rare)
</t>
<t tx="ekr.20240308084832.463">def emit_dec_ref(self, dest: str, rtype: RType, is_xdec: bool) -&gt; None:
    self.emitter.emit_dec_ref(dest, rtype, is_xdec=is_xdec, rare=self.rare)
</t>
<t tx="ekr.20240308084832.464">def emit_declaration(self, line: str) -&gt; None:
    self.declarations.emit_line(line)
</t>
<t tx="ekr.20240308084832.465">def emit_traceback(self, op: Branch) -&gt; None:
    if op.traceback_entry is not None:
        self.emitter.emit_traceback(self.source_path, self.module_name, op.traceback_entry)
</t>
<t tx="ekr.20240308084832.466">def emit_attribute_error(self, op: Branch, class_name: str, attr: str) -&gt; None:
    assert op.traceback_entry is not None
    globals_static = self.emitter.static_name("globals", self.module_name)
    self.emit_line(
        'CPy_AttributeError("%s", "%s", "%s", "%s", %d, %s);'
        % (
            self.source_path.replace("\\", "\\\\"),
            op.traceback_entry[0],
            class_name,
            attr,
            op.traceback_entry[1],
            globals_static,
        )
    )
    if DEBUG_ERRORS:
        self.emit_line('assert(PyErr_Occurred() != NULL &amp;&amp; "failure w/o err!");')
</t>
<t tx="ekr.20240308084832.467">def emit_signed_int_cast(self, type: RType) -&gt; str:
    if is_tagged(type):
        return "(Py_ssize_t)"
    else:
        return ""
</t>
<t tx="ekr.20240308084832.468">def emit_unsigned_int_cast(self, type: RType) -&gt; str:
    if is_int32_rprimitive(type):
        return "(uint32_t)"
    elif is_int64_rprimitive(type):
        return "(uint64_t)"
    else:
        return ""
</t>
<t tx="ekr.20240308084832.469">"""Generate C code for a Python C extension module from Python source code."""

# FIXME: Basically nothing in this file operates on the level of a
# single module and it should be renamed.

from __future__ import annotations

import json
import os
from typing import Iterable, List, Optional, Tuple, TypeVar

from mypy.build import (
    BuildResult,
    BuildSource,
    State,
    build,
    compute_hash,
    create_metastore,
    get_cache_names,
    sorted_components,
)
from mypy.errors import CompileError
from mypy.fscache import FileSystemCache
from mypy.nodes import MypyFile
from mypy.options import Options
from mypy.plugin import Plugin, ReportConfigContext
from mypy.util import hash_digest
from mypyc.codegen.cstring import c_string_initializer
from mypyc.codegen.emit import Emitter, EmitterContext, HeaderDeclaration, c_array_initializer
from mypyc.codegen.emitclass import generate_class, generate_class_type_decl
from mypyc.codegen.emitfunc import generate_native_function, native_function_header
from mypyc.codegen.emitwrapper import (
    generate_legacy_wrapper_function,
    generate_wrapper_function,
    legacy_wrapper_function_header,
    wrapper_function_header,
)
from mypyc.codegen.literals import Literals
from mypyc.common import (
    MODULE_PREFIX,
    PREFIX,
    RUNTIME_C_FILES,
    TOP_LEVEL_NAME,
    shared_lib_name,
    short_id_from_name,
    use_vectorcall,
)
from mypyc.errors import Errors
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncIR
from mypyc.ir.module_ir import ModuleIR, ModuleIRs, deserialize_modules
from mypyc.ir.ops import DeserMaps, LoadLiteral
from mypyc.ir.rtypes import RType
from mypyc.irbuild.main import build_ir
from mypyc.irbuild.mapper import Mapper
from mypyc.irbuild.prepare import load_type_map
from mypyc.namegen import NameGenerator, exported_name
from mypyc.options import CompilerOptions
from mypyc.transform.exceptions import insert_exception_handling
from mypyc.transform.refcount import insert_ref_count_opcodes
from mypyc.transform.uninit import insert_uninit_checks

# All of the modules being compiled are divided into "groups". A group
# is a set of modules that are placed into the same shared library.
# Two common configurations are that every module is placed in a group
# by itself (fully separate compilation) and that every module is
# placed in the same group (fully whole-program compilation), but we
# support finer-grained control of the group as well.
#
# In fully whole-program compilation, we will generate N+1 extension
# modules: one shim per module and one shared library containing all
# the actual code.
# In fully separate compilation, we (unfortunately) will generate 2*N
# extension modules: one shim per module and also one library containing
# each module's actual code. (This might be fixable in the future,
# but allows a clean separation between setup of the export tables
# (see generate_export_table) and running module top levels.)
#
# A group is represented as a list of BuildSources containing all of
# its modules along with the name of the group. (Which can be None
# only if we are compiling only a single group with a single file in it
# and not using shared libraries).
Group = Tuple[List[BuildSource], Optional[str]]
Groups = List[Group]

# A list of (file name, file contents) pairs.
FileContents = List[Tuple[str, str]]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.47">def make_module_translation_map(names: list[str]) -&gt; dict[str, str]:
    num_instances: dict[str, int] = {}
    for name in names:
        for suffix in candidate_suffixes(name):
            num_instances[suffix] = num_instances.get(suffix, 0) + 1
    result = {}
    for name in names:
        for suffix in candidate_suffixes(name):
            if num_instances[suffix] == 1:
                result[name] = suffix
                break
        else:
            assert False, names
    return result
</t>
<t tx="ekr.20240308084832.470">class MarkedDeclaration:
    """Add a mark, useful for topological sort."""
    @others
</t>
<t tx="ekr.20240308084832.471">def __init__(self, declaration: HeaderDeclaration, mark: bool) -&gt; None:
    self.declaration = declaration
    self.mark = False
</t>
<t tx="ekr.20240308084832.472">class MypycPlugin(Plugin):
    """Plugin for making mypyc interoperate properly with mypy incremental mode.
    
    Basically the point of this plugin is to force mypy to recheck things
    based on the demands of mypyc in a couple situations:
      * Any modules in the same group must be compiled together, so we
        tell mypy that modules depend on all their groupmates.
      * If the IR metadata is missing or stale or any of the generated
        C source files associated missing or stale, then we need to
        recompile the module so we mark it as stale.
    """
    @others
</t>
<t tx="ekr.20240308084832.473">def __init__(
    self, options: Options, compiler_options: CompilerOptions, groups: Groups
) -&gt; None:
    super().__init__(options)
    self.group_map: dict[str, tuple[str | None, list[str]]] = {}
    for sources, name in groups:
        modules = sorted(source.module for source in sources)
        for id in modules:
            self.group_map[id] = (name, modules)

    self.compiler_options = compiler_options
    self.metastore = create_metastore(options)
</t>
<t tx="ekr.20240308084832.474">def report_config_data(self, ctx: ReportConfigContext) -&gt; tuple[str | None, list[str]] | None:
    # The config data we report is the group map entry for the module.
    # If the data is being used to check validity, we do additional checks
    # that the IR cache exists and matches the metadata cache and all
    # output source files exist and are up to date.

    id, path, is_check = ctx.id, ctx.path, ctx.is_check

    if id not in self.group_map:
        return None

    # If we aren't doing validity checks, just return the cache data
    if not is_check:
        return self.group_map[id]

    # Load the metadata and IR cache
    meta_path, _, _ = get_cache_names(id, path, self.options)
    ir_path = get_ir_cache_name(id, path, self.options)
    try:
        meta_json = self.metastore.read(meta_path)
        ir_json = self.metastore.read(ir_path)
    except FileNotFoundError:
        # This could happen if mypyc failed after mypy succeeded
        # in the previous run or if some cache files got
        # deleted. No big deal, just fail to load the cache.
        return None

    ir_data = json.loads(ir_json)

    # Check that the IR cache matches the metadata cache
    if compute_hash(meta_json) != ir_data["meta_hash"]:
        return None

    # Check that all of the source files are present and as
    # expected. The main situation where this would come up is the
    # user deleting the build directory without deleting
    # .mypy_cache, which we should handle gracefully.
    for path, hash in ir_data["src_hashes"].items():
        try:
            with open(os.path.join(self.compiler_options.target_dir, path), "rb") as f:
                contents = f.read()
        except FileNotFoundError:
            return None
        real_hash = hash_digest(contents)
        if hash != real_hash:
            return None

    return self.group_map[id]
</t>
<t tx="ekr.20240308084832.475">def get_additional_deps(self, file: MypyFile) -&gt; list[tuple[int, str, int]]:
    # Report dependency on modules in the module's group
    return [(10, id, -1) for id in self.group_map.get(file.fullname, (None, []))[1]]
</t>
<t tx="ekr.20240308084832.476">def parse_and_typecheck(
    sources: list[BuildSource],
    options: Options,
    compiler_options: CompilerOptions,
    groups: Groups,
    fscache: FileSystemCache | None = None,
    alt_lib_path: str | None = None,
) -&gt; BuildResult:
    assert options.strict_optional, "strict_optional must be turned on"
    result = build(
        sources=sources,
        options=options,
        alt_lib_path=alt_lib_path,
        fscache=fscache,
        extra_plugins=[MypycPlugin(options, compiler_options, groups)],
    )
    if result.errors:
        raise CompileError(result.errors)
    return result
</t>
<t tx="ekr.20240308084832.477">def compile_scc_to_ir(
    scc: list[MypyFile],
    result: BuildResult,
    mapper: Mapper,
    compiler_options: CompilerOptions,
    errors: Errors,
) -&gt; ModuleIRs:
    """Compile an SCC into ModuleIRs.

    Any modules that this SCC depends on must have either compiled or
    loaded from a cache into mapper.

    Arguments:
        scc: The list of MypyFiles to compile
        result: The BuildResult from the mypy front-end
        mapper: The Mapper object mapping mypy ASTs to class and func IRs
        compiler_options: The compilation options
        errors: Where to report any errors encountered

    Returns the IR of the modules.
    """

    if compiler_options.verbose:
        print("Compiling {}".format(", ".join(x.name for x in scc)))

    # Generate basic IR, with missing exception and refcount handling.
    modules = build_ir(scc, result.graph, result.types, mapper, compiler_options, errors)
    if errors.num_errors &gt; 0:
        return modules

    # Insert uninit checks.
    for module in modules.values():
        for fn in module.functions:
            insert_uninit_checks(fn)
    # Insert exception handling.
    for module in modules.values():
        for fn in module.functions:
            insert_exception_handling(fn)
    # Insert refcount handling.
    for module in modules.values():
        for fn in module.functions:
            insert_ref_count_opcodes(fn)

    return modules
</t>
<t tx="ekr.20240308084832.478">def compile_modules_to_ir(
    result: BuildResult, mapper: Mapper, compiler_options: CompilerOptions, errors: Errors
) -&gt; ModuleIRs:
    """Compile a collection of modules into ModuleIRs.

    The modules to compile are specified as part of mapper's group_map.

    Returns the IR of the modules.
    """
    deser_ctx = DeserMaps({}, {})
    modules = {}

    # Process the graph by SCC in topological order, like we do in mypy.build
    for scc in sorted_components(result.graph):
        scc_states = [result.graph[id] for id in scc]
        trees = [st.tree for st in scc_states if st.id in mapper.group_map and st.tree]

        if not trees:
            continue

        fresh = all(id not in result.manager.rechecked_modules for id in scc)
        if fresh:
            load_scc_from_cache(trees, result, mapper, deser_ctx)
        else:
            scc_ir = compile_scc_to_ir(trees, result, mapper, compiler_options, errors)
            modules.update(scc_ir)

    return modules
</t>
<t tx="ekr.20240308084832.479">def compile_ir_to_c(
    groups: Groups,
    modules: ModuleIRs,
    result: BuildResult,
    mapper: Mapper,
    compiler_options: CompilerOptions,
) -&gt; dict[str | None, list[tuple[str, str]]]:
    """Compile a collection of ModuleIRs to C source text.

    Returns a dictionary mapping group names to a list of (file name,
    file text) pairs.
    """
    source_paths = {
        source.module: result.graph[source.module].xpath
        for sources, _ in groups
        for source in sources
    }

    names = NameGenerator([[source.module for source in sources] for sources, _ in groups])

    # Generate C code for each compilation group. Each group will be
    # compiled into a separate extension module.
    ctext: dict[str | None, list[tuple[str, str]]] = {}
    for group_sources, group_name in groups:
        group_modules = {
            source.module: modules[source.module]
            for source in group_sources
            if source.module in modules
        }
        if not group_modules:
            ctext[group_name] = []
            continue
        generator = GroupGenerator(
            group_modules, source_paths, group_name, mapper.group_map, names, compiler_options
        )
        ctext[group_name] = generator.generate_c_for_modules()

    return ctext
</t>
<t tx="ekr.20240308084832.48">def candidate_suffixes(fullname: str) -&gt; list[str]:
    components = fullname.split(".")
    result = [""]
    for i in range(len(components)):
        result.append(".".join(components[-i - 1 :]) + ".")
    return result
</t>
<t tx="ekr.20240308084832.480">def get_ir_cache_name(id: str, path: str, options: Options) -&gt; str:
    meta_path, _, _ = get_cache_names(id, path, options)
    return meta_path.replace(".meta.json", ".ir.json")
</t>
<t tx="ekr.20240308084832.481">def get_state_ir_cache_name(state: State) -&gt; str:
    return get_ir_cache_name(state.id, state.xpath, state.options)
</t>
<t tx="ekr.20240308084832.482">def write_cache(
    modules: ModuleIRs,
    result: BuildResult,
    group_map: dict[str, str | None],
    ctext: dict[str | None, list[tuple[str, str]]],
) -&gt; None:
    """Write out the cache information for modules.

    Each module has the following cache information written (which is
    in addition to the cache information written by mypy itself):
      * A serialized version of its mypyc IR, minus the bodies of
        functions. This allows code that depends on it to use
        these serialized data structures when compiling against it
        instead of needing to recompile it. (Compiling against a
        module requires access to both its mypy and mypyc data
        structures.)
      * The hash of the mypy metadata cache file for the module.
        This is used to ensure that the mypyc cache and the mypy
        cache are in sync and refer to the same version of the code.
        This is particularly important if mypyc crashes/errors/is
        stopped after mypy has written its cache but before mypyc has.
      * The hashes of all of the source file outputs for the group
        the module is in. This is so that the module will be
        recompiled if the source outputs are missing.
    """

    hashes = {}
    for name, files in ctext.items():
        hashes[name] = {file: compute_hash(data) for file, data in files}

    # Write out cache data
    for id, module in modules.items():
        st = result.graph[id]

        meta_path, _, _ = get_cache_names(id, st.xpath, result.manager.options)
        # If the metadata isn't there, skip writing the cache.
        try:
            meta_data = result.manager.metastore.read(meta_path)
        except OSError:
            continue

        newpath = get_state_ir_cache_name(st)
        ir_data = {
            "ir": module.serialize(),
            "meta_hash": compute_hash(meta_data),
            "src_hashes": hashes[group_map[id]],
        }

        result.manager.metastore.write(newpath, json.dumps(ir_data, separators=(",", ":")))

    result.manager.metastore.commit()
</t>
<t tx="ekr.20240308084832.483">def load_scc_from_cache(
    scc: list[MypyFile], result: BuildResult, mapper: Mapper, ctx: DeserMaps
) -&gt; ModuleIRs:
    """Load IR for an SCC of modules from the cache.

    Arguments and return are as compile_scc_to_ir.
    """
    cache_data = {
        k.fullname: json.loads(
            result.manager.metastore.read(get_state_ir_cache_name(result.graph[k.fullname]))
        )["ir"]
        for k in scc
    }
    modules = deserialize_modules(cache_data, ctx)
    load_type_map(mapper, scc, ctx)
    return modules
</t>
<t tx="ekr.20240308084832.484">def compile_modules_to_c(
    result: BuildResult, compiler_options: CompilerOptions, errors: Errors, groups: Groups
) -&gt; tuple[ModuleIRs, list[FileContents]]:
    """Compile Python module(s) to the source of Python C extension modules.

    This generates the source code for the "shared library" module
    for each group. The shim modules are generated in mypyc.build.
    Each shared library module provides, for each module in its group,
    a PyCapsule containing an initialization function.
    Additionally, it provides a capsule containing an export table of
    pointers to all of the group's functions and static variables.

    Arguments:
        result: The BuildResult from the mypy front-end
        compiler_options: The compilation options
        errors: Where to report any errors encountered
        groups: The groups that we are compiling. See documentation of Groups type above.

    Returns the IR of the modules and a list containing the generated files for each group.
    """
    # Construct a map from modules to what group they belong to
    group_map = {source.module: lib_name for group, lib_name in groups for source in group}
    mapper = Mapper(group_map)

    # Sometimes when we call back into mypy, there might be errors.
    # We don't want to crash when that happens.
    result.manager.errors.set_file(
        "&lt;mypyc&gt;", module=None, scope=None, options=result.manager.options
    )

    modules = compile_modules_to_ir(result, mapper, compiler_options, errors)
    ctext = compile_ir_to_c(groups, modules, result, mapper, compiler_options)

    if errors.num_errors == 0:
        write_cache(modules, result, group_map, ctext)

    return modules, [ctext[name] for _, name in groups]
</t>
<t tx="ekr.20240308084832.485">def generate_function_declaration(fn: FuncIR, emitter: Emitter) -&gt; None:
    emitter.context.declarations[emitter.native_function_name(fn.decl)] = HeaderDeclaration(
        f"{native_function_header(fn.decl, emitter)};", needs_export=True
    )
    if fn.name != TOP_LEVEL_NAME:
        if is_fastcall_supported(fn, emitter.capi_version):
            emitter.context.declarations[PREFIX + fn.cname(emitter.names)] = HeaderDeclaration(
                f"{wrapper_function_header(fn, emitter.names)};"
            )
        else:
            emitter.context.declarations[PREFIX + fn.cname(emitter.names)] = HeaderDeclaration(
                f"{legacy_wrapper_function_header(fn, emitter.names)};"
            )
</t>
<t tx="ekr.20240308084832.486">def pointerize(decl: str, name: str) -&gt; str:
    """Given a C decl and its name, modify it to be a declaration to a pointer."""
    # This doesn't work in general but does work for all our types...
    if "(" in decl:
        # Function pointer. Stick an * in front of the name and wrap it in parens.
        return decl.replace(name, f"(*{name})")
    else:
        # Non-function pointer. Just stick an * in front of the name.
        return decl.replace(name, f"*{name}")
</t>
<t tx="ekr.20240308084832.487">def group_dir(group_name: str) -&gt; str:
    """Given a group name, return the relative directory path for it."""
    return os.sep.join(group_name.split(".")[:-1])
</t>
<t tx="ekr.20240308084832.488">class GroupGenerator:
    @others
</t>
<t tx="ekr.20240308084832.489">def __init__(
    self,
    modules: dict[str, ModuleIR],
    source_paths: dict[str, str],
    group_name: str | None,
    group_map: dict[str, str | None],
    names: NameGenerator,
    compiler_options: CompilerOptions,
) -&gt; None:
    """Generator for C source for a compilation group.

    The code for a compilation group contains an internal and an
    external .h file, and then one .c if not in multi_file mode or
    one .c file per module if in multi_file mode.)

    Arguments:
        modules: (name, ir) pairs for each module in the group
        source_paths: Map from module names to source file paths
        group_name: The name of the group (or None if this is single-module compilation)
        group_map: A map of modules to their group names
        names: The name generator for the compilation
        multi_file: Whether to put each module in its own source file regardless
                    of group structure.
    """
    self.modules = modules
    self.source_paths = source_paths
    self.context = EmitterContext(names, group_name, group_map)
    self.names = names
    # Initializations of globals to simple values that we can't
    # do statically because the windows loader is bad.
    self.simple_inits: list[tuple[str, str]] = []
    self.group_name = group_name
    self.use_shared_lib = group_name is not None
    self.compiler_options = compiler_options
    self.multi_file = compiler_options.multi_file
</t>
<t tx="ekr.20240308084832.49">from __future__ import annotations

import sys


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.490">@property
def group_suffix(self) -&gt; str:
    return "_" + exported_name(self.group_name) if self.group_name else ""
</t>
<t tx="ekr.20240308084832.491">@property
def short_group_suffix(self) -&gt; str:
    return "_" + exported_name(self.group_name.split(".")[-1]) if self.group_name else ""
</t>
<t tx="ekr.20240308084832.492">def generate_c_for_modules(self) -&gt; list[tuple[str, str]]:
    file_contents = []
    multi_file = self.use_shared_lib and self.multi_file

    # Collect all literal refs in IR.
    for module in self.modules.values():
        for fn in module.functions:
            collect_literals(fn, self.context.literals)

    base_emitter = Emitter(self.context)
    # Optionally just include the runtime library c files to
    # reduce the number of compiler invocations needed
    if self.compiler_options.include_runtime_files:
        for name in RUNTIME_C_FILES:
            base_emitter.emit_line(f'#include "{name}"')
    base_emitter.emit_line(f'#include "__native{self.short_group_suffix}.h"')
    base_emitter.emit_line(f'#include "__native_internal{self.short_group_suffix}.h"')
    emitter = base_emitter

    self.generate_literal_tables()

    for module_name, module in self.modules.items():
        if multi_file:
            emitter = Emitter(self.context)
            emitter.emit_line(f'#include "__native{self.short_group_suffix}.h"')
            emitter.emit_line(f'#include "__native_internal{self.short_group_suffix}.h"')

        self.declare_module(module_name, emitter)
        self.declare_internal_globals(module_name, emitter)
        self.declare_imports(module.imports, emitter)

        for cl in module.classes:
            if cl.is_ext_class:
                generate_class(cl, module_name, emitter)

        # Generate Python extension module definitions and module initialization functions.
        self.generate_module_def(emitter, module_name, module)

        for fn in module.functions:
            emitter.emit_line()
            generate_native_function(fn, emitter, self.source_paths[module_name], module_name)
            if fn.name != TOP_LEVEL_NAME:
                emitter.emit_line()
                if is_fastcall_supported(fn, emitter.capi_version):
                    generate_wrapper_function(
                        fn, emitter, self.source_paths[module_name], module_name
                    )
                else:
                    generate_legacy_wrapper_function(
                        fn, emitter, self.source_paths[module_name], module_name
                    )
        if multi_file:
            name = f"__native_{emitter.names.private_name(module_name)}.c"
            file_contents.append((name, "".join(emitter.fragments)))

    # The external header file contains type declarations while
    # the internal contains declarations of functions and objects
    # (which are shared between shared libraries via dynamic
    # exports tables and not accessed directly.)
    ext_declarations = Emitter(self.context)
    ext_declarations.emit_line(f"#ifndef MYPYC_NATIVE{self.group_suffix}_H")
    ext_declarations.emit_line(f"#define MYPYC_NATIVE{self.group_suffix}_H")
    ext_declarations.emit_line("#include &lt;Python.h&gt;")
    ext_declarations.emit_line("#include &lt;CPy.h&gt;")

    declarations = Emitter(self.context)
    declarations.emit_line(f"#ifndef MYPYC_NATIVE_INTERNAL{self.group_suffix}_H")
    declarations.emit_line(f"#define MYPYC_NATIVE_INTERNAL{self.group_suffix}_H")
    declarations.emit_line("#include &lt;Python.h&gt;")
    declarations.emit_line("#include &lt;CPy.h&gt;")
    declarations.emit_line(f'#include "__native{self.short_group_suffix}.h"')
    declarations.emit_line()
    declarations.emit_line("int CPyGlobalsInit(void);")
    declarations.emit_line()

    for module_name, module in self.modules.items():
        self.declare_finals(module_name, module.final_names, declarations)
        for cl in module.classes:
            generate_class_type_decl(cl, emitter, ext_declarations, declarations)
        for fn in module.functions:
            generate_function_declaration(fn, declarations)

    for lib in sorted(self.context.group_deps):
        elib = exported_name(lib)
        short_lib = exported_name(lib.split(".")[-1])
        declarations.emit_lines(
            "#include &lt;{}&gt;".format(os.path.join(group_dir(lib), f"__native_{short_lib}.h")),
            f"struct export_table_{elib} exports_{elib};",
        )

    sorted_decls = self.toposort_declarations()

    emitter = base_emitter
    self.generate_globals_init(emitter)

    emitter.emit_line()

    for declaration in sorted_decls:
        decls = ext_declarations if declaration.is_type else declarations
        if not declaration.is_type:
            decls.emit_lines(f"extern {declaration.decl[0]}", *declaration.decl[1:])
            # If there is a definition, emit it. Otherwise repeat the declaration
            # (without an extern).
            if declaration.defn:
                emitter.emit_lines(*declaration.defn)
            else:
                emitter.emit_lines(*declaration.decl)
        else:
            decls.emit_lines(*declaration.decl)

    if self.group_name:
        self.generate_export_table(ext_declarations, emitter)

        self.generate_shared_lib_init(emitter)

    ext_declarations.emit_line("#endif")
    declarations.emit_line("#endif")

    output_dir = group_dir(self.group_name) if self.group_name else ""
    return file_contents + [
        (
            os.path.join(output_dir, f"__native{self.short_group_suffix}.c"),
            "".join(emitter.fragments),
        ),
        (
            os.path.join(output_dir, f"__native_internal{self.short_group_suffix}.h"),
            "".join(declarations.fragments),
        ),
        (
            os.path.join(output_dir, f"__native{self.short_group_suffix}.h"),
            "".join(ext_declarations.fragments),
        ),
    ]
</t>
<t tx="ekr.20240308084832.493">def generate_literal_tables(self) -&gt; None:
    """Generate tables containing descriptions of Python literals to construct.

    We will store the constructed literals in a single array that contains
    literals of all types. This way we can refer to an arbitrary literal by
    its index.
    """
    literals = self.context.literals
    # During module initialization we store all the constructed objects here
    self.declare_global("PyObject *[%d]" % literals.num_literals(), "CPyStatics")
    # Descriptions of str literals
    init_str = c_string_array_initializer(literals.encoded_str_values())
    self.declare_global("const char * const []", "CPyLit_Str", initializer=init_str)
    # Descriptions of bytes literals
    init_bytes = c_string_array_initializer(literals.encoded_bytes_values())
    self.declare_global("const char * const []", "CPyLit_Bytes", initializer=init_bytes)
    # Descriptions of int literals
    init_int = c_string_array_initializer(literals.encoded_int_values())
    self.declare_global("const char * const []", "CPyLit_Int", initializer=init_int)
    # Descriptions of float literals
    init_floats = c_array_initializer(literals.encoded_float_values())
    self.declare_global("const double []", "CPyLit_Float", initializer=init_floats)
    # Descriptions of complex literals
    init_complex = c_array_initializer(literals.encoded_complex_values())
    self.declare_global("const double []", "CPyLit_Complex", initializer=init_complex)
    # Descriptions of tuple literals
    init_tuple = c_array_initializer(literals.encoded_tuple_values())
    self.declare_global("const int []", "CPyLit_Tuple", initializer=init_tuple)
    # Descriptions of frozenset literals
    init_frozenset = c_array_initializer(literals.encoded_frozenset_values())
    self.declare_global("const int []", "CPyLit_FrozenSet", initializer=init_frozenset)
</t>
<t tx="ekr.20240308084832.494">def generate_export_table(self, decl_emitter: Emitter, code_emitter: Emitter) -&gt; None:
    """Generate the declaration and definition of the group's export struct.

    To avoid needing to deal with deeply platform specific issues
    involving dynamic library linking (and some possibly
    insurmountable issues involving cyclic dependencies), compiled
    code accesses functions and data in other compilation groups
    via an explicit "export struct".

    Each group declares a struct type that contains a pointer to
    every function and static variable it exports. It then
    populates this struct and stores a pointer to it in a capsule
    stored as an attribute named 'exports' on the group's shared
    library's python module.

    On load, a group's init function will import all of its
    dependencies' exports tables using the capsule mechanism and
    copy the contents into a local copy of the table (to eliminate
    the need for a pointer indirection when accessing it).

    Then, all calls to functions in another group and accesses to statics
    from another group are done indirectly via the export table.

    For example, a group containing a module b, where b contains a class B
    and a function bar, would declare an export table like:
        struct export_table_b {
            PyTypeObject **CPyType_B;
            PyObject *(*CPyDef_B)(CPyTagged cpy_r_x);
            CPyTagged (*CPyDef_B___foo)(PyObject *cpy_r_self, CPyTagged cpy_r_y);
            tuple_T2OI (*CPyDef_bar)(PyObject *cpy_r_x);
            char (*CPyDef___top_level__)(void);
        };
    that would be initialized with:
        static struct export_table_b exports = {
            &amp;CPyType_B,
            &amp;CPyDef_B,
            &amp;CPyDef_B___foo,
            &amp;CPyDef_bar,
            &amp;CPyDef___top_level__,
        };
    To call `b.foo`, then, a function in another group would do
    `exports_b.CPyDef_bar(...)`.
    """

    decls = decl_emitter.context.declarations

    decl_emitter.emit_lines("", f"struct export_table{self.group_suffix} {{")
    for name, decl in decls.items():
        if decl.needs_export:
            decl_emitter.emit_line(pointerize("\n".join(decl.decl), name))

    decl_emitter.emit_line("};")

    code_emitter.emit_lines("", f"static struct export_table{self.group_suffix} exports = {{")
    for name, decl in decls.items():
        if decl.needs_export:
            code_emitter.emit_line(f"&amp;{name},")

    code_emitter.emit_line("};")
</t>
<t tx="ekr.20240308084832.495">def generate_shared_lib_init(self, emitter: Emitter) -&gt; None:
    """Generate the init function for a shared library.

    A shared library contains all of the actual code for a
    compilation group.

    The init function is responsible for creating Capsules that
    wrap pointers to the initialization function of all the real
    init functions for modules in this shared library as well as
    the export table containing all of the exported functions and
    values from all the modules.

    These capsules are stored in attributes of the shared library.
    """
    assert self.group_name is not None

    emitter.emit_line()
    emitter.emit_lines(
        "PyMODINIT_FUNC PyInit_{}(void)".format(
            shared_lib_name(self.group_name).split(".")[-1]
        ),
        "{",
        (
            'static PyModuleDef def = {{ PyModuleDef_HEAD_INIT, "{}", NULL, -1, NULL, NULL }};'.format(
                shared_lib_name(self.group_name)
            )
        ),
        "int res;",
        "PyObject *capsule;",
        "PyObject *tmp;",
        "static PyObject *module;",
        "if (module) {",
        "Py_INCREF(module);",
        "return module;",
        "}",
        "module = PyModule_Create(&amp;def);",
        "if (!module) {",
        "goto fail;",
        "}",
        "",
    )

    emitter.emit_lines(
        'capsule = PyCapsule_New(&amp;exports, "{}.exports", NULL);'.format(
            shared_lib_name(self.group_name)
        ),
        "if (!capsule) {",
        "goto fail;",
        "}",
        'res = PyObject_SetAttrString(module, "exports", capsule);',
        "Py_DECREF(capsule);",
        "if (res &lt; 0) {",
        "goto fail;",
        "}",
        "",
    )

    for mod in self.modules:
        name = exported_name(mod)
        emitter.emit_lines(
            f"extern PyObject *CPyInit_{name}(void);",
            'capsule = PyCapsule_New((void *)CPyInit_{}, "{}.init_{}", NULL);'.format(
                name, shared_lib_name(self.group_name), name
            ),
            "if (!capsule) {",
            "goto fail;",
            "}",
            f'res = PyObject_SetAttrString(module, "init_{name}", capsule);',
            "Py_DECREF(capsule);",
            "if (res &lt; 0) {",
            "goto fail;",
            "}",
            "",
        )

    for group in sorted(self.context.group_deps):
        egroup = exported_name(group)
        emitter.emit_lines(
            'tmp = PyImport_ImportModule("{}"); if (!tmp) goto fail; Py_DECREF(tmp);'.format(
                shared_lib_name(group)
            ),
            'struct export_table_{} *pexports_{} = PyCapsule_Import("{}.exports", 0);'.format(
                egroup, egroup, shared_lib_name(group)
            ),
            f"if (!pexports_{egroup}) {{",
            "goto fail;",
            "}",
            "memcpy(&amp;exports_{group}, pexports_{group}, sizeof(exports_{group}));".format(
                group=egroup
            ),
            "",
        )

    emitter.emit_lines("return module;", "fail:", "Py_XDECREF(module);", "return NULL;", "}")
</t>
<t tx="ekr.20240308084832.496">def generate_globals_init(self, emitter: Emitter) -&gt; None:
    emitter.emit_lines(
        "",
        "int CPyGlobalsInit(void)",
        "{",
        "static int is_initialized = 0;",
        "if (is_initialized) return 0;",
        "",
    )

    emitter.emit_line("CPy_Init();")
    for symbol, fixup in self.simple_inits:
        emitter.emit_line(f"{symbol} = {fixup};")

    values = "CPyLit_Str, CPyLit_Bytes, CPyLit_Int, CPyLit_Float, CPyLit_Complex, CPyLit_Tuple, CPyLit_FrozenSet"
    emitter.emit_lines(
        f"if (CPyStatics_Initialize(CPyStatics, {values}) &lt; 0) {{", "return -1;", "}"
    )

    emitter.emit_lines("is_initialized = 1;", "return 0;", "}")
</t>
<t tx="ekr.20240308084832.497">def generate_module_def(self, emitter: Emitter, module_name: str, module: ModuleIR) -&gt; None:
    """Emit the PyModuleDef struct for a module and the module init function."""
    # Emit module methods
    module_prefix = emitter.names.private_name(module_name)
    emitter.emit_line(f"static PyMethodDef {module_prefix}module_methods[] = {{")
    for fn in module.functions:
        if fn.class_name is not None or fn.name == TOP_LEVEL_NAME:
            continue
        name = short_id_from_name(fn.name, fn.decl.shortname, fn.line)
        if is_fastcall_supported(fn, emitter.capi_version):
            flag = "METH_FASTCALL"
        else:
            flag = "METH_VARARGS"
        emitter.emit_line(
            (
                '{{"{name}", (PyCFunction){prefix}{cname}, {flag} | METH_KEYWORDS, '
                "NULL /* docstring */}},"
            ).format(name=name, cname=fn.cname(emitter.names), prefix=PREFIX, flag=flag)
        )
    emitter.emit_line("{NULL, NULL, 0, NULL}")
    emitter.emit_line("};")
    emitter.emit_line()

    # Emit module definition struct
    emitter.emit_lines(
        f"static struct PyModuleDef {module_prefix}module = {{",
        "PyModuleDef_HEAD_INIT,",
        f'"{module_name}",',
        "NULL, /* docstring */",
        "-1,       /* size of per-interpreter state of the module,",
        "             or -1 if the module keeps state in global variables. */",
        f"{module_prefix}module_methods",
        "};",
    )
    emitter.emit_line()
    # Emit module init function. If we are compiling just one module, this
    # will be the C API init function. If we are compiling 2+ modules, we
    # generate a shared library for the modules and shims that call into
    # the shared library, and in this case we use an internal module
    # initialized function that will be called by the shim.
    if not self.use_shared_lib:
        declaration = f"PyMODINIT_FUNC PyInit_{module_name}(void)"
    else:
        declaration = f"PyObject *CPyInit_{exported_name(module_name)}(void)"
    emitter.emit_lines(declaration, "{")
    emitter.emit_line("PyObject* modname = NULL;")
    # Store the module reference in a static and return it when necessary.
    # This is separate from the *global* reference to the module that will
    # be populated when it is imported by a compiled module. We want that
    # reference to only be populated when the module has been successfully
    # imported, whereas this we want to have to stop a circular import.
    module_static = self.module_internal_static_name(module_name, emitter)

    emitter.emit_lines(
        f"if ({module_static}) {{",
        f"Py_INCREF({module_static});",
        f"return {module_static};",
        "}",
    )

    emitter.emit_lines(
        f"{module_static} = PyModule_Create(&amp;{module_prefix}module);",
        f"if (unlikely({module_static} == NULL))",
        "    goto fail;",
    )
    emitter.emit_line(
        f'modname = PyObject_GetAttrString((PyObject *){module_static}, "__name__");'
    )

    module_globals = emitter.static_name("globals", module_name)
    emitter.emit_lines(
        f"{module_globals} = PyModule_GetDict({module_static});",
        f"if (unlikely({module_globals} == NULL))",
        "    goto fail;",
    )

    # HACK: Manually instantiate generated classes here
    type_structs: list[str] = []
    for cl in module.classes:
        type_struct = emitter.type_struct_name(cl)
        type_structs.append(type_struct)
        if cl.is_generated:
            emitter.emit_lines(
                "{t} = (PyTypeObject *)CPyType_FromTemplate("
                "(PyObject *){t}_template, NULL, modname);".format(t=type_struct)
            )
            emitter.emit_lines(f"if (unlikely(!{type_struct}))", "    goto fail;")

    emitter.emit_lines("if (CPyGlobalsInit() &lt; 0)", "    goto fail;")

    self.generate_top_level_call(module, emitter)

    emitter.emit_lines("Py_DECREF(modname);")

    emitter.emit_line(f"return {module_static};")
    emitter.emit_lines("fail:", f"Py_CLEAR({module_static});", "Py_CLEAR(modname);")
    for name, typ in module.final_names:
        static_name = emitter.static_name(name, module_name)
        emitter.emit_dec_ref(static_name, typ, is_xdec=True)
        undef = emitter.c_undefined_value(typ)
        emitter.emit_line(f"{static_name} = {undef};")
    # the type objects returned from CPyType_FromTemplate are all new references
    # so we have to decref them
    for t in type_structs:
        emitter.emit_line(f"Py_CLEAR({t});")
    emitter.emit_line("return NULL;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.498">def generate_top_level_call(self, module: ModuleIR, emitter: Emitter) -&gt; None:
    """Generate call to function representing module top level."""
    # Optimization: we tend to put the top level last, so reverse iterate
    for fn in reversed(module.functions):
        if fn.name == TOP_LEVEL_NAME:
            emitter.emit_lines(
                f"char result = {emitter.native_function_name(fn.decl)}();",
                "if (result == 2)",
                "    goto fail;",
            )
            break
</t>
<t tx="ekr.20240308084832.499">def toposort_declarations(self) -&gt; list[HeaderDeclaration]:
    """Topologically sort the declaration dict by dependencies.

    Declarations can require other declarations to come prior in C (such as declaring structs).
    In order to guarantee that the C output will compile the declarations will thus need to
    be properly ordered. This simple DFS guarantees that we have a proper ordering.

    This runs in O(V + E).
    """
    result = []
    marked_declarations: dict[str, MarkedDeclaration] = {}
    for k, v in self.context.declarations.items():
        marked_declarations[k] = MarkedDeclaration(v, False)

    def _toposort_visit(name: str) -&gt; None:
        decl = marked_declarations[name]
        if decl.mark:
            return

        for child in decl.declaration.dependencies:
            _toposort_visit(child)

        result.append(decl.declaration)
        decl.mark = True

    for name, marked_declaration in marked_declarations.items():
        _toposort_visit(name)

    return result
</t>
<t tx="ekr.20240308084832.5">def main() -&gt; None:
    build_dir = "build"  # can this be overridden??
    try:
        os.mkdir(build_dir)
    except FileExistsError:
        pass

    opt_level = os.getenv("MYPYC_OPT_LEVEL", "3")
    debug_level = os.getenv("MYPYC_DEBUG_LEVEL", "1")

    setup_file = os.path.join(build_dir, "setup.py")
    with open(setup_file, "w") as f:
        f.write(setup_format.format(sys.argv[1:], opt_level, debug_level))

    # We don't use run_setup (like we do in the test suite) because it throws
    # away the error code from distutils, and we don't care about the slight
    # performance loss here.
    env = os.environ.copy()
    base_path = os.path.join(os.path.dirname(__file__), "..")
    env["PYTHONPATH"] = base_path + os.pathsep + env.get("PYTHONPATH", "")
    cmd = subprocess.run([sys.executable, setup_file, "build_ext", "--inplace"], env=env)
    sys.exit(cmd.returncode)
</t>
<t tx="ekr.20240308084832.50">class CompilerOptions:
    @others
</t>
<t tx="ekr.20240308084832.500">def declare_global(
    self, type_spaced: str, name: str, *, initializer: str | None = None
) -&gt; None:
    if "[" not in type_spaced:
        base = f"{type_spaced}{name}"
    else:
        a, b = type_spaced.split("[", 1)
        base = f"{a}{name}[{b}"

    if not initializer:
        defn = None
    else:
        defn = [f"{base} = {initializer};"]
    if name not in self.context.declarations:
        self.context.declarations[name] = HeaderDeclaration(f"{base};", defn=defn)
</t>
<t tx="ekr.20240308084832.501">def declare_internal_globals(self, module_name: str, emitter: Emitter) -&gt; None:
    static_name = emitter.static_name("globals", module_name)
    self.declare_global("PyObject *", static_name)
</t>
<t tx="ekr.20240308084832.502">def module_internal_static_name(self, module_name: str, emitter: Emitter) -&gt; str:
    return emitter.static_name(module_name + "_internal", None, prefix=MODULE_PREFIX)
</t>
<t tx="ekr.20240308084832.503">def declare_module(self, module_name: str, emitter: Emitter) -&gt; None:
    # We declare two globals for each compiled module:
    # one used internally in the implementation of module init to cache results
    # and prevent infinite recursion in import cycles, and one used
    # by other modules to refer to it.
    if module_name in self.modules:
        internal_static_name = self.module_internal_static_name(module_name, emitter)
        self.declare_global("CPyModule *", internal_static_name, initializer="NULL")
    static_name = emitter.static_name(module_name, None, prefix=MODULE_PREFIX)
    self.declare_global("CPyModule *", static_name)
    self.simple_inits.append((static_name, "Py_None"))
</t>
<t tx="ekr.20240308084832.504">def declare_imports(self, imps: Iterable[str], emitter: Emitter) -&gt; None:
    for imp in imps:
        self.declare_module(imp, emitter)
</t>
<t tx="ekr.20240308084832.505">def declare_finals(
    self, module: str, final_names: Iterable[tuple[str, RType]], emitter: Emitter
) -&gt; None:
    for name, typ in final_names:
        static_name = emitter.static_name(name, module)
        emitter.context.declarations[static_name] = HeaderDeclaration(
            f"{emitter.ctype_spaced(typ)}{static_name};",
            [self.final_definition(module, name, typ, emitter)],
            needs_export=True,
        )
</t>
<t tx="ekr.20240308084832.506">def final_definition(self, module: str, name: str, typ: RType, emitter: Emitter) -&gt; str:
    static_name = emitter.static_name(name, module)
    # Here we rely on the fact that undefined value and error value are always the same
    undefined = emitter.c_initializer_undefined_value(typ)
    return f"{emitter.ctype_spaced(typ)}{static_name} = {undefined};"
</t>
<t tx="ekr.20240308084832.507">def declare_static_pyobject(self, identifier: str, emitter: Emitter) -&gt; None:
    symbol = emitter.static_name(identifier, None)
    self.declare_global("PyObject *", symbol)
</t>
<t tx="ekr.20240308084832.508">def sort_classes(classes: list[tuple[str, ClassIR]]) -&gt; list[tuple[str, ClassIR]]:
    mod_name = {ir: name for name, ir in classes}
    irs = [ir for _, ir in classes]
    deps: dict[ClassIR, set[ClassIR]] = {}
    for ir in irs:
        if ir not in deps:
            deps[ir] = set()
        if ir.base:
            deps[ir].add(ir.base)
        deps[ir].update(ir.traits)
    sorted_irs = toposort(deps)
    return [(mod_name[ir], ir) for ir in sorted_irs]
</t>
<t tx="ekr.20240308084832.509">T = TypeVar("T")


def toposort(deps: dict[T, set[T]]) -&gt; list[T]:
    """Topologically sort a dict from item to dependencies.

    This runs in O(V + E).
    """
    result = []
    visited: set[T] = set()

    def visit(item: T) -&gt; None:
        if item in visited:
            return

        for child in deps[item]:
            visit(child)

        result.append(item)
        visited.add(item)

    for item in deps:
        visit(item)

    return result
</t>
<t tx="ekr.20240308084832.51">def __init__(
    self,
    strip_asserts: bool = False,
    multi_file: bool = False,
    verbose: bool = False,
    separate: bool = False,
    target_dir: str | None = None,
    include_runtime_files: bool | None = None,
    capi_version: tuple[int, int] | None = None,
    python_version: tuple[int, int] | None = None,
) -&gt; None:
    self.strip_asserts = strip_asserts
    self.multi_file = multi_file
    self.verbose = verbose
    self.separate = separate
    self.global_opts = not separate
    self.target_dir = target_dir or "build"
    self.include_runtime_files = (
        include_runtime_files if include_runtime_files is not None else not multi_file
    )
    # The target Python C API version. Overriding this is mostly
    # useful in IR tests, since there's no guarantee that
    # binaries are backward compatible even if no recent API
    # features are used.
    self.capi_version = capi_version or sys.version_info[:2]
    self.python_version = python_version
</t>
<t tx="ekr.20240308084832.510">def is_fastcall_supported(fn: FuncIR, capi_version: tuple[int, int]) -&gt; bool:
    if fn.class_name is not None:
        if fn.name == "__call__":
            # We can use vectorcalls (PEP 590) when supported
            return use_vectorcall(capi_version)
        # TODO: Support fastcall for __init__.
        return fn.name != "__init__"
    return True
</t>
<t tx="ekr.20240308084832.511">def collect_literals(fn: FuncIR, literals: Literals) -&gt; None:
    """Store all Python literal object refs in fn.

    Collecting literals must happen only after we have the final IR.
    This way we won't include literals that have been optimized away.
    """
    for block in fn.blocks:
        for op in block.ops:
            if isinstance(op, LoadLiteral):
                literals.record_literal(op.value)
</t>
<t tx="ekr.20240308084832.512">def c_string_array_initializer(components: list[bytes]) -&gt; str:
    result = []
    result.append("{\n")
    for s in components:
        result.append("    " + c_string_initializer(s) + ",\n")
    result.append("}")
    return "".join(result)
</t>
<t tx="ekr.20240308084832.513">"""Generate CPython API wrapper functions for native functions.

The wrapper functions are used by the CPython runtime when calling
native functions from interpreted code, and when the called function
can't be determined statically in compiled code. They validate, match,
unbox and type check function arguments, and box return values as
needed. All wrappers accept and return 'PyObject *' (boxed) values.

The wrappers aren't used for most calls between two native functions
or methods in a single compilation unit.
"""

from __future__ import annotations

from typing import Sequence

from mypy.nodes import ARG_NAMED, ARG_NAMED_OPT, ARG_OPT, ARG_POS, ARG_STAR, ARG_STAR2, ArgKind
from mypy.operators import op_methods_to_symbols, reverse_op_method_names, reverse_op_methods
from mypyc.codegen.emit import AssignHandler, Emitter, ErrorHandler, GotoHandler, ReturnHandler
from mypyc.common import (
    BITMAP_BITS,
    BITMAP_TYPE,
    DUNDER_PREFIX,
    NATIVE_PREFIX,
    PREFIX,
    bitmap_name,
    use_vectorcall,
)
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FUNC_STATICMETHOD, FuncIR, RuntimeArg
from mypyc.ir.rtypes import (
    RInstance,
    RType,
    is_bool_rprimitive,
    is_int_rprimitive,
    is_object_rprimitive,
    object_rprimitive,
)
from mypyc.namegen import NameGenerator

# Generic vectorcall wrapper functions (Python 3.7+)
#
# A wrapper function has a signature like this:
#
# PyObject *fn(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
#
# The function takes a self object, pointer to an array of arguments,
# the number of positional arguments, and a tuple of keyword argument
# names (that are stored starting in args[nargs]).
#
# It returns the returned object, or NULL on an exception.
#
# These are more efficient than legacy wrapper functions, since
# usually no tuple or dict objects need to be created for the
# arguments. Vectorcalls also use pre-constructed str objects for
# keyword argument names and other pre-computed information, instead
# of processing the argument format string on each call.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.514">def wrapper_function_header(fn: FuncIR, names: NameGenerator) -&gt; str:
    """Return header of a vectorcall wrapper function.

    See comment above for a summary of the arguments.
    """
    return (
        "PyObject *{prefix}{name}("
        "PyObject *self, PyObject *const *args, size_t nargs, PyObject *kwnames)"
    ).format(prefix=PREFIX, name=fn.cname(names))
</t>
<t tx="ekr.20240308084832.515">def generate_traceback_code(
    fn: FuncIR, emitter: Emitter, source_path: str, module_name: str
) -&gt; str:
    # If we hit an error while processing arguments, then we emit a
    # traceback frame to make it possible to debug where it happened.
    # Unlike traceback frames added for exceptions seen in IR, we do this
    # even if there is no `traceback_name`. This is because the error will
    # have originated here and so we need it in the traceback.
    globals_static = emitter.static_name("globals", module_name)
    traceback_code = 'CPy_AddTraceback("%s", "%s", %d, %s);' % (
        source_path.replace("\\", "\\\\"),
        fn.traceback_name or fn.name,
        fn.line,
        globals_static,
    )
    return traceback_code
</t>
<t tx="ekr.20240308084832.516">def make_arg_groups(args: list[RuntimeArg]) -&gt; dict[ArgKind, list[RuntimeArg]]:
    """Group arguments by kind."""
    return {k: [arg for arg in args if arg.kind == k] for k in ArgKind}
</t>
<t tx="ekr.20240308084832.517">def reorder_arg_groups(groups: dict[ArgKind, list[RuntimeArg]]) -&gt; list[RuntimeArg]:
    """Reorder argument groups to match their order in a format string."""
    return groups[ARG_POS] + groups[ARG_OPT] + groups[ARG_NAMED_OPT] + groups[ARG_NAMED]
</t>
<t tx="ekr.20240308084832.518">def make_static_kwlist(args: list[RuntimeArg]) -&gt; str:
    arg_names = "".join(f'"{arg.name}", ' for arg in args)
    return f"static const char * const kwlist[] = {{{arg_names}0}};"
</t>
<t tx="ekr.20240308084832.519">def make_format_string(func_name: str | None, groups: dict[ArgKind, list[RuntimeArg]]) -&gt; str:
    """Return a format string that specifies the accepted arguments.

    The format string is an extended subset of what is supported by
    PyArg_ParseTupleAndKeywords(). Only the type 'O' is used, and we
    also support some extensions:

    - Required keyword-only arguments are introduced after '@'
    - If the function receives *args or **kwargs, we add a '%' prefix

    Each group requires the previous groups' delimiters to be present
    first.

    These are used by both vectorcall and legacy wrapper functions.
    """
    format = ""
    if groups[ARG_STAR] or groups[ARG_STAR2]:
        format += "%"
    format += "O" * len(groups[ARG_POS])
    if groups[ARG_OPT] or groups[ARG_NAMED_OPT] or groups[ARG_NAMED]:
        format += "|" + "O" * len(groups[ARG_OPT])
    if groups[ARG_NAMED_OPT] or groups[ARG_NAMED]:
        format += "$" + "O" * len(groups[ARG_NAMED_OPT])
    if groups[ARG_NAMED]:
        format += "@" + "O" * len(groups[ARG_NAMED])
    if func_name is not None:
        format += f":{func_name}"
    return format
</t>
<t tx="ekr.20240308084832.52">"""'Runtime subtype' check for RTypes.

A type S is a runtime subtype of T if a value of type S can be used at runtime
when a value of type T is expected without requiring any runtime conversions.

For boxed types, runtime subtyping is the same as regular subtyping.
Unboxed subtypes, on the other hand, are not runtime subtypes of object
(since they require boxing to be used as an object), but short ints
are runtime subtypes of int.

Subtyping is used to determine whether an object can be in a
particular place and runtime subtyping is used to determine whether a
coercion is necessary first.
"""

from __future__ import annotations

from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RPrimitive,
    RStruct,
    RTuple,
    RType,
    RTypeVisitor,
    RUnion,
    RVoid,
    is_bit_rprimitive,
    is_bool_rprimitive,
    is_int_rprimitive,
    is_short_int_rprimitive,
)
from mypyc.subtype import is_subtype


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.520">def generate_wrapper_function(
    fn: FuncIR, emitter: Emitter, source_path: str, module_name: str
) -&gt; None:
    """Generate a CPython-compatible vectorcall wrapper for a native function.

    In particular, this handles unboxing the arguments, calling the native function, and
    then boxing the return value.
    """
    emitter.emit_line(f"{wrapper_function_header(fn, emitter.names)} {{")

    # If fn is a method, then the first argument is a self param
    real_args = list(fn.args)
    if fn.sig.num_bitmap_args:
        real_args = real_args[: -fn.sig.num_bitmap_args]
    if fn.class_name and not fn.decl.kind == FUNC_STATICMETHOD:
        arg = real_args.pop(0)
        emitter.emit_line(f"PyObject *obj_{arg.name} = self;")

    # Need to order args as: required, optional, kwonly optional, kwonly required
    # This is because CPyArg_ParseStackAndKeywords format string requires
    # them grouped in that way.
    groups = make_arg_groups(real_args)
    reordered_args = reorder_arg_groups(groups)

    emitter.emit_line(make_static_kwlist(reordered_args))
    fmt = make_format_string(fn.name, groups)
    # Define the arguments the function accepts (but no types yet)
    emitter.emit_line(f'static CPyArg_Parser parser = {{"{fmt}", kwlist, 0}};')

    for arg in real_args:
        emitter.emit_line(
            "PyObject *obj_{}{};".format(arg.name, " = NULL" if arg.optional else "")
        )

    cleanups = [f"CPy_DECREF(obj_{arg.name});" for arg in groups[ARG_STAR] + groups[ARG_STAR2]]

    arg_ptrs: list[str] = []
    if groups[ARG_STAR] or groups[ARG_STAR2]:
        arg_ptrs += [f"&amp;obj_{groups[ARG_STAR][0].name}" if groups[ARG_STAR] else "NULL"]
        arg_ptrs += [f"&amp;obj_{groups[ARG_STAR2][0].name}" if groups[ARG_STAR2] else "NULL"]
    arg_ptrs += [f"&amp;obj_{arg.name}" for arg in reordered_args]

    if fn.name == "__call__" and use_vectorcall(emitter.capi_version):
        nargs = "PyVectorcall_NARGS(nargs)"
    else:
        nargs = "nargs"
    parse_fn = "CPyArg_ParseStackAndKeywords"
    # Special case some common signatures
    if not real_args:
        # No args
        parse_fn = "CPyArg_ParseStackAndKeywordsNoArgs"
    elif len(real_args) == 1 and len(groups[ARG_POS]) == 1:
        # Single positional arg
        parse_fn = "CPyArg_ParseStackAndKeywordsOneArg"
    elif len(real_args) == len(groups[ARG_POS]) + len(groups[ARG_OPT]):
        # No keyword-only args, *args or **kwargs
        parse_fn = "CPyArg_ParseStackAndKeywordsSimple"
    emitter.emit_lines(
        "if (!{}(args, {}, kwnames, &amp;parser{})) {{".format(
            parse_fn, nargs, "".join(", " + n for n in arg_ptrs)
        ),
        "return NULL;",
        "}",
    )
    for i in range(fn.sig.num_bitmap_args):
        name = bitmap_name(i)
        emitter.emit_line(f"{BITMAP_TYPE} {name} = 0;")
    traceback_code = generate_traceback_code(fn, emitter, source_path, module_name)
    generate_wrapper_core(
        fn,
        emitter,
        groups[ARG_OPT] + groups[ARG_NAMED_OPT],
        cleanups=cleanups,
        traceback_code=traceback_code,
    )

    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.521"># Legacy generic wrapper functions
#
# These take a self object, a Python tuple of positional arguments,
# and a dict of keyword arguments. These are a lot slower than
# vectorcall wrappers, especially in calls involving keyword
# arguments.


def legacy_wrapper_function_header(fn: FuncIR, names: NameGenerator) -&gt; str:
    return "PyObject *{prefix}{name}(PyObject *self, PyObject *args, PyObject *kw)".format(
        prefix=PREFIX, name=fn.cname(names)
    )
</t>
<t tx="ekr.20240308084832.522">def generate_legacy_wrapper_function(
    fn: FuncIR, emitter: Emitter, source_path: str, module_name: str
) -&gt; None:
    """Generates a CPython-compatible legacy wrapper for a native function.

    In particular, this handles unboxing the arguments, calling the native function, and
    then boxing the return value.
    """
    emitter.emit_line(f"{legacy_wrapper_function_header(fn, emitter.names)} {{")

    # If fn is a method, then the first argument is a self param
    real_args = list(fn.args)
    if fn.sig.num_bitmap_args:
        real_args = real_args[: -fn.sig.num_bitmap_args]
    if fn.class_name and not fn.decl.kind == FUNC_STATICMETHOD:
        arg = real_args.pop(0)
        emitter.emit_line(f"PyObject *obj_{arg.name} = self;")

    # Need to order args as: required, optional, kwonly optional, kwonly required
    # This is because CPyArg_ParseTupleAndKeywords format string requires
    # them grouped in that way.
    groups = make_arg_groups(real_args)
    reordered_args = reorder_arg_groups(groups)

    emitter.emit_line(make_static_kwlist(reordered_args))
    for arg in real_args:
        emitter.emit_line(
            "PyObject *obj_{}{};".format(arg.name, " = NULL" if arg.optional else "")
        )

    cleanups = [f"CPy_DECREF(obj_{arg.name});" for arg in groups[ARG_STAR] + groups[ARG_STAR2]]

    arg_ptrs: list[str] = []
    if groups[ARG_STAR] or groups[ARG_STAR2]:
        arg_ptrs += [f"&amp;obj_{groups[ARG_STAR][0].name}" if groups[ARG_STAR] else "NULL"]
        arg_ptrs += [f"&amp;obj_{groups[ARG_STAR2][0].name}" if groups[ARG_STAR2] else "NULL"]
    arg_ptrs += [f"&amp;obj_{arg.name}" for arg in reordered_args]

    emitter.emit_lines(
        'if (!CPyArg_ParseTupleAndKeywords(args, kw, "{}", "{}", kwlist{})) {{'.format(
            make_format_string(None, groups), fn.name, "".join(", " + n for n in arg_ptrs)
        ),
        "return NULL;",
        "}",
    )
    for i in range(fn.sig.num_bitmap_args):
        name = bitmap_name(i)
        emitter.emit_line(f"{BITMAP_TYPE} {name} = 0;")
    traceback_code = generate_traceback_code(fn, emitter, source_path, module_name)
    generate_wrapper_core(
        fn,
        emitter,
        groups[ARG_OPT] + groups[ARG_NAMED_OPT],
        cleanups=cleanups,
        traceback_code=traceback_code,
    )

    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.523"># Specialized wrapper functions


def generate_dunder_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __dunder__ methods to be able to fit into the mapping
    protocol slot. This specifically means that the arguments are taken as *PyObjects and returned
    as *PyObjects.
    """
    gen = WrapperGenerator(cl, emitter)
    gen.set_target(fn)
    gen.emit_header()
    gen.emit_arg_processing()
    gen.emit_call()
    gen.finish()
    return gen.wrapper_name()
</t>
<t tx="ekr.20240308084832.524">def generate_ipow_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generate a wrapper for native __ipow__.

    Since __ipow__ fills a ternary slot, but almost no one defines __ipow__ to take three
    arguments, the wrapper needs to tweaked to force it to accept three arguments.
    """
    gen = WrapperGenerator(cl, emitter)
    gen.set_target(fn)
    assert len(fn.args) in (2, 3), "__ipow__ should only take 2 or 3 arguments"
    gen.arg_names = ["self", "exp", "mod"]
    gen.emit_header()
    gen.emit_arg_processing()
    handle_third_pow_argument(
        fn,
        emitter,
        gen,
        if_unsupported=[
            'PyErr_SetString(PyExc_TypeError, "__ipow__ takes 2 positional arguments but 3 were given");',
            "return NULL;",
        ],
    )
    gen.emit_call()
    gen.finish()
    return gen.wrapper_name()
</t>
<t tx="ekr.20240308084832.525">def generate_bin_op_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for a native binary dunder method.

    The same wrapper that handles the forward method (e.g. __add__) also handles
    the corresponding reverse method (e.g. __radd__), if defined.

    Both arguments and the return value are PyObject *.
    """
    gen = WrapperGenerator(cl, emitter)
    gen.set_target(fn)
    if fn.name in ("__pow__", "__rpow__"):
        gen.arg_names = ["left", "right", "mod"]
    else:
        gen.arg_names = ["left", "right"]
    wrapper_name = gen.wrapper_name()

    gen.emit_header()
    if fn.name not in reverse_op_methods and fn.name in reverse_op_method_names:
        # There's only a reverse operator method.
        generate_bin_op_reverse_only_wrapper(fn, emitter, gen)
    else:
        rmethod = reverse_op_methods[fn.name]
        fn_rev = cl.get_method(rmethod)
        if fn_rev is None:
            # There's only a forward operator method.
            generate_bin_op_forward_only_wrapper(fn, emitter, gen)
        else:
            # There's both a forward and a reverse operator method.
            generate_bin_op_both_wrappers(cl, fn, fn_rev, emitter, gen)
    return wrapper_name
</t>
<t tx="ekr.20240308084832.526">def generate_bin_op_forward_only_wrapper(
    fn: FuncIR, emitter: Emitter, gen: WrapperGenerator
) -&gt; None:
    gen.emit_arg_processing(error=GotoHandler("typefail"), raise_exception=False)
    handle_third_pow_argument(fn, emitter, gen, if_unsupported=["goto typefail;"])
    gen.emit_call(not_implemented_handler="goto typefail;")
    gen.emit_error_handling()
    emitter.emit_label("typefail")
    # If some argument has an incompatible type, treat this the same as
    # returning NotImplemented, and try to call the reverse operator method.
    #
    # Note that in normal Python you'd instead of an explicit
    # return of NotImplemented, but it doesn't generally work here
    # the body won't be executed at all if there is an argument
    # type check failure.
    #
    # The recommended way is to still use a type check in the
    # body. This will only be used in interpreted mode:
    #
    #    def __add__(self, other: int) -&gt; Foo:
    #        if not isinstance(other, int):
    #            return NotImplemented
    #        ...
    generate_bin_op_reverse_dunder_call(fn, emitter, reverse_op_methods[fn.name])
    gen.finish()
</t>
<t tx="ekr.20240308084832.527">def generate_bin_op_reverse_only_wrapper(
    fn: FuncIR, emitter: Emitter, gen: WrapperGenerator
) -&gt; None:
    gen.arg_names = ["right", "left"]
    gen.emit_arg_processing(error=GotoHandler("typefail"), raise_exception=False)
    handle_third_pow_argument(fn, emitter, gen, if_unsupported=["goto typefail;"])
    gen.emit_call()
    gen.emit_error_handling()
    emitter.emit_label("typefail")
    emitter.emit_line("Py_INCREF(Py_NotImplemented);")
    emitter.emit_line("return Py_NotImplemented;")
    gen.finish()
</t>
<t tx="ekr.20240308084832.528">def generate_bin_op_both_wrappers(
    cl: ClassIR, fn: FuncIR, fn_rev: FuncIR, emitter: Emitter, gen: WrapperGenerator
) -&gt; None:
    # There's both a forward and a reverse operator method. First
    # check if we should try calling the forward one. If the
    # argument type check fails, fall back to the reverse method.
    #
    # Similar to above, we can't perfectly match Python semantics.
    # In regular Python code you'd return NotImplemented if the
    # operand has the wrong type, but in compiled code we'll never
    # get to execute the type check.
    emitter.emit_line(
        "if (PyObject_IsInstance(obj_left, (PyObject *){})) {{".format(
            emitter.type_struct_name(cl)
        )
    )
    gen.emit_arg_processing(error=GotoHandler("typefail"), raise_exception=False)
    handle_third_pow_argument(fn, emitter, gen, if_unsupported=["goto typefail2;"])
    # Ternary __rpow__ calls aren't a thing so immediately bail
    # if ternary __pow__ returns NotImplemented.
    if fn.name == "__pow__" and len(fn.args) == 3:
        fwd_not_implemented_handler = "goto typefail2;"
    else:
        fwd_not_implemented_handler = "goto typefail;"
    gen.emit_call(not_implemented_handler=fwd_not_implemented_handler)
    gen.emit_error_handling()
    emitter.emit_line("}")
    emitter.emit_label("typefail")
    emitter.emit_line(
        "if (PyObject_IsInstance(obj_right, (PyObject *){})) {{".format(
            emitter.type_struct_name(cl)
        )
    )
    gen.set_target(fn_rev)
    gen.arg_names = ["right", "left"]
    gen.emit_arg_processing(error=GotoHandler("typefail2"), raise_exception=False)
    handle_third_pow_argument(fn_rev, emitter, gen, if_unsupported=["goto typefail2;"])
    gen.emit_call()
    gen.emit_error_handling()
    emitter.emit_line("} else {")
    generate_bin_op_reverse_dunder_call(fn, emitter, fn_rev.name)
    emitter.emit_line("}")
    emitter.emit_label("typefail2")
    emitter.emit_line("Py_INCREF(Py_NotImplemented);")
    emitter.emit_line("return Py_NotImplemented;")
    gen.finish()
</t>
<t tx="ekr.20240308084832.529">def generate_bin_op_reverse_dunder_call(fn: FuncIR, emitter: Emitter, rmethod: str) -&gt; None:
    if fn.name in ("__pow__", "__rpow__"):
        # Ternary pow() will never call the reverse dunder.
        emitter.emit_line("if (obj_mod == Py_None) {")
    emitter.emit_line(f"_Py_IDENTIFIER({rmethod});")
    emitter.emit_line(
        'return CPy_CallReverseOpMethod(obj_left, obj_right, "{}", &amp;PyId_{});'.format(
            op_methods_to_symbols[fn.name], rmethod
        )
    )
    if fn.name in ("__pow__", "__rpow__"):
        emitter.emit_line("} else {")
        emitter.emit_line("Py_INCREF(Py_NotImplemented);")
        emitter.emit_line("return Py_NotImplemented;")
        emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.53">def is_runtime_subtype(left: RType, right: RType) -&gt; bool:
    return left.accept(RTSubtypeVisitor(right))
</t>
<t tx="ekr.20240308084832.530">def handle_third_pow_argument(
    fn: FuncIR, emitter: Emitter, gen: WrapperGenerator, *, if_unsupported: list[str]
) -&gt; None:
    if fn.name not in ("__pow__", "__rpow__", "__ipow__"):
        return

    if (fn.name in ("__pow__", "__ipow__") and len(fn.args) == 2) or fn.name == "__rpow__":
        # If the power dunder only supports two arguments and the third
        # argument (AKA mod) is set to a non-default value, simply bail.
        #
        # Importantly, this prevents any ternary __rpow__ calls from
        # happening (as per the language specification).
        emitter.emit_line("if (obj_mod != Py_None) {")
        for line in if_unsupported:
            emitter.emit_line(line)
        emitter.emit_line("}")
        # The slot wrapper will receive three arguments, but the call only
        # supports two so make sure that the third argument isn't passed
        # along. This is needed as two-argument __(i)pow__ is allowed and
        # rather common.
        if len(gen.arg_names) == 3:
            gen.arg_names.pop()
</t>
<t tx="ekr.20240308084832.531">RICHCOMPARE_OPS = {
    "__lt__": "Py_LT",
    "__gt__": "Py_GT",
    "__le__": "Py_LE",
    "__ge__": "Py_GE",
    "__eq__": "Py_EQ",
    "__ne__": "Py_NE",
}


def generate_richcompare_wrapper(cl: ClassIR, emitter: Emitter) -&gt; str | None:
    """Generates a wrapper for richcompare dunder methods."""
    # Sort for determinism on Python 3.5
    matches = sorted(name for name in RICHCOMPARE_OPS if cl.has_method(name))
    if not matches:
        return None

    name = f"{DUNDER_PREFIX}_RichCompare_{cl.name_prefix(emitter.names)}"
    emitter.emit_line(
        "static PyObject *{name}(PyObject *obj_lhs, PyObject *obj_rhs, int op) {{".format(
            name=name
        )
    )
    emitter.emit_line("switch (op) {")
    for func in matches:
        emitter.emit_line(f"case {RICHCOMPARE_OPS[func]}: {{")
        method = cl.get_method(func)
        assert method is not None
        generate_wrapper_core(method, emitter, arg_names=["lhs", "rhs"])
        emitter.emit_line("}")
    emitter.emit_line("}")

    emitter.emit_line("Py_INCREF(Py_NotImplemented);")
    emitter.emit_line("return Py_NotImplemented;")

    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.532">def generate_get_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __get__ methods."""
    name = f"{DUNDER_PREFIX}{fn.name}{cl.name_prefix(emitter.names)}"
    emitter.emit_line(
        "static PyObject *{name}(PyObject *self, PyObject *instance, PyObject *owner) {{".format(
            name=name
        )
    )
    emitter.emit_line("instance = instance ? instance : Py_None;")
    emitter.emit_line(f"return {NATIVE_PREFIX}{fn.cname(emitter.names)}(self, instance, owner);")
    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.533">def generate_hash_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __hash__ methods."""
    name = f"{DUNDER_PREFIX}{fn.name}{cl.name_prefix(emitter.names)}"
    emitter.emit_line(f"static Py_ssize_t {name}(PyObject *self) {{")
    emitter.emit_line(
        "{}retval = {}{}{}(self);".format(
            emitter.ctype_spaced(fn.ret_type),
            emitter.get_group_prefix(fn.decl),
            NATIVE_PREFIX,
            fn.cname(emitter.names),
        )
    )
    emitter.emit_error_check("retval", fn.ret_type, "return -1;")
    if is_int_rprimitive(fn.ret_type):
        emitter.emit_line("Py_ssize_t val = CPyTagged_AsSsize_t(retval);")
    else:
        emitter.emit_line("Py_ssize_t val = PyLong_AsSsize_t(retval);")
    emitter.emit_dec_ref("retval", fn.ret_type)
    emitter.emit_line("if (PyErr_Occurred()) return -1;")
    # We can't return -1 from a hash function..
    emitter.emit_line("if (val == -1) return -2;")
    emitter.emit_line("return val;")
    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.534">def generate_len_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __len__ methods."""
    name = f"{DUNDER_PREFIX}{fn.name}{cl.name_prefix(emitter.names)}"
    emitter.emit_line(f"static Py_ssize_t {name}(PyObject *self) {{")
    emitter.emit_line(
        "{}retval = {}{}{}(self);".format(
            emitter.ctype_spaced(fn.ret_type),
            emitter.get_group_prefix(fn.decl),
            NATIVE_PREFIX,
            fn.cname(emitter.names),
        )
    )
    emitter.emit_error_check("retval", fn.ret_type, "return -1;")
    if is_int_rprimitive(fn.ret_type):
        emitter.emit_line("Py_ssize_t val = CPyTagged_AsSsize_t(retval);")
    else:
        emitter.emit_line("Py_ssize_t val = PyLong_AsSsize_t(retval);")
    emitter.emit_dec_ref("retval", fn.ret_type)
    emitter.emit_line("if (PyErr_Occurred()) return -1;")
    emitter.emit_line("return val;")
    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.535">def generate_bool_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __bool__ methods."""
    name = f"{DUNDER_PREFIX}{fn.name}{cl.name_prefix(emitter.names)}"
    emitter.emit_line(f"static int {name}(PyObject *self) {{")
    emitter.emit_line(
        "{}val = {}{}(self);".format(
            emitter.ctype_spaced(fn.ret_type), NATIVE_PREFIX, fn.cname(emitter.names)
        )
    )
    emitter.emit_error_check("val", fn.ret_type, "return -1;")
    # This wouldn't be that hard to fix but it seems unimportant and
    # getting error handling and unboxing right would be fiddly. (And
    # way easier to do in IR!)
    assert is_bool_rprimitive(fn.ret_type), "Only bool return supported for __bool__"
    emitter.emit_line("return val;")
    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.536">def generate_del_item_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __delitem__.

    This is only called from a combined __delitem__/__setitem__ wrapper.
    """
    name = "{}{}{}".format(DUNDER_PREFIX, "__delitem__", cl.name_prefix(emitter.names))
    input_args = ", ".join(f"PyObject *obj_{arg.name}" for arg in fn.args)
    emitter.emit_line(f"static int {name}({input_args}) {{")
    generate_set_del_item_wrapper_inner(fn, emitter, fn.args)
    return name
</t>
<t tx="ekr.20240308084832.537">def generate_set_del_item_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for native __setitem__ method (also works for __delitem__).

    This is used with the mapping protocol slot. Arguments are taken as *PyObjects and we
    return a negative C int on error.

    Create a separate wrapper function for __delitem__ as needed and have the
    __setitem__ wrapper call it if the value is NULL. Return the name
    of the outer (__setitem__) wrapper.
    """
    method_cls = cl.get_method_and_class("__delitem__")
    del_name = None
    if method_cls and method_cls[1] == cl:
        # Generate a separate wrapper for __delitem__
        del_name = generate_del_item_wrapper(cl, method_cls[0], emitter)

    args = fn.args
    if fn.name == "__delitem__":
        # Add an extra argument for value that we expect to be NULL.
        args = list(args) + [RuntimeArg("___value", object_rprimitive, ARG_POS)]

    name = "{}{}{}".format(DUNDER_PREFIX, "__setitem__", cl.name_prefix(emitter.names))
    input_args = ", ".join(f"PyObject *obj_{arg.name}" for arg in args)
    emitter.emit_line(f"static int {name}({input_args}) {{")

    # First check if this is __delitem__
    emitter.emit_line(f"if (obj_{args[2].name} == NULL) {{")
    if del_name is not None:
        # We have a native implementation, so call it
        emitter.emit_line(f"return {del_name}(obj_{args[0].name}, obj_{args[1].name});")
    else:
        # Try to call superclass method instead
        emitter.emit_line(f"PyObject *super = CPy_Super(CPyModule_builtins, obj_{args[0].name});")
        emitter.emit_line("if (super == NULL) return -1;")
        emitter.emit_line(
            'PyObject *result = PyObject_CallMethod(super, "__delitem__", "O", obj_{});'.format(
                args[1].name
            )
        )
        emitter.emit_line("Py_DECREF(super);")
        emitter.emit_line("Py_XDECREF(result);")
        emitter.emit_line("return result == NULL ? -1 : 0;")
    emitter.emit_line("}")

    method_cls = cl.get_method_and_class("__setitem__")
    if method_cls and method_cls[1] == cl:
        generate_set_del_item_wrapper_inner(fn, emitter, args)
    else:
        emitter.emit_line(f"PyObject *super = CPy_Super(CPyModule_builtins, obj_{args[0].name});")
        emitter.emit_line("if (super == NULL) return -1;")
        emitter.emit_line("PyObject *result;")

        if method_cls is None and cl.builtin_base is None:
            msg = f"'{cl.name}' object does not support item assignment"
            emitter.emit_line(f'PyErr_SetString(PyExc_TypeError, "{msg}");')
            emitter.emit_line("result = NULL;")
        else:
            # A base class may have __setitem__
            emitter.emit_line(
                'result = PyObject_CallMethod(super, "__setitem__", "OO", obj_{}, obj_{});'.format(
                    args[1].name, args[2].name
                )
            )
        emitter.emit_line("Py_DECREF(super);")
        emitter.emit_line("Py_XDECREF(result);")
        emitter.emit_line("return result == NULL ? -1 : 0;")
        emitter.emit_line("}")
    return name
</t>
<t tx="ekr.20240308084832.538">def generate_set_del_item_wrapper_inner(
    fn: FuncIR, emitter: Emitter, args: Sequence[RuntimeArg]
) -&gt; None:
    for arg in args:
        generate_arg_check(arg.name, arg.type, emitter, GotoHandler("fail"))
    native_args = ", ".join(f"arg_{arg.name}" for arg in args)
    emitter.emit_line(
        "{}val = {}{}({});".format(
            emitter.ctype_spaced(fn.ret_type), NATIVE_PREFIX, fn.cname(emitter.names), native_args
        )
    )
    emitter.emit_error_check("val", fn.ret_type, "goto fail;")
    emitter.emit_dec_ref("val", fn.ret_type)
    emitter.emit_line("return 0;")
    emitter.emit_label("fail")
    emitter.emit_line("return -1;")
    emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.539">def generate_contains_wrapper(cl: ClassIR, fn: FuncIR, emitter: Emitter) -&gt; str:
    """Generates a wrapper for a native __contains__ method."""
    name = f"{DUNDER_PREFIX}{fn.name}{cl.name_prefix(emitter.names)}"
    emitter.emit_line(f"static int {name}(PyObject *self, PyObject *obj_item) {{")
    generate_arg_check("item", fn.args[1].type, emitter, ReturnHandler("-1"))
    emitter.emit_line(
        "{}val = {}{}(self, arg_item);".format(
            emitter.ctype_spaced(fn.ret_type), NATIVE_PREFIX, fn.cname(emitter.names)
        )
    )
    emitter.emit_error_check("val", fn.ret_type, "return -1;")
    if is_bool_rprimitive(fn.ret_type):
        emitter.emit_line("return val;")
    else:
        emitter.emit_line("int boolval = PyObject_IsTrue(val);")
        emitter.emit_dec_ref("val", fn.ret_type)
        emitter.emit_line("return boolval;")
    emitter.emit_line("}")

    return name
</t>
<t tx="ekr.20240308084832.54">class RTSubtypeVisitor(RTypeVisitor[bool]):
    """Is left a runtime subtype of right?
    
    A few special cases such as right being 'object' are handled in
    is_runtime_subtype and don't need to be covered here.
    """
    @others
</t>
<t tx="ekr.20240308084832.540"># Helpers


def generate_wrapper_core(
    fn: FuncIR,
    emitter: Emitter,
    optional_args: list[RuntimeArg] | None = None,
    arg_names: list[str] | None = None,
    cleanups: list[str] | None = None,
    traceback_code: str | None = None,
) -&gt; None:
    """Generates the core part of a wrapper function for a native function.

    This expects each argument as a PyObject * named obj_{arg} as a precondition.
    It converts the PyObject *s to the necessary types, checking and unboxing if necessary,
    makes the call, then boxes the result if necessary and returns it.
    """
    gen = WrapperGenerator(None, emitter)
    gen.set_target(fn)
    if arg_names:
        gen.arg_names = arg_names
    gen.cleanups = cleanups or []
    gen.optional_args = optional_args or []
    gen.traceback_code = traceback_code or ""

    error = ReturnHandler("NULL") if not gen.use_goto() else GotoHandler("fail")
    gen.emit_arg_processing(error=error)
    gen.emit_call()
    gen.emit_error_handling()
</t>
<t tx="ekr.20240308084832.541">def generate_arg_check(
    name: str,
    typ: RType,
    emitter: Emitter,
    error: ErrorHandler | None = None,
    *,
    optional: bool = False,
    raise_exception: bool = True,
    bitmap_arg_index: int = 0,
) -&gt; None:
    """Insert a runtime check for argument and unbox if necessary.

    The object is named PyObject *obj_{}. This is expected to generate
    a value of name arg_{} (unboxed if necessary). For each primitive a runtime
    check ensures the correct type.
    """
    error = error or AssignHandler()
    if typ.is_unboxed:
        if typ.error_overlap and optional:
            # Update bitmap is value is provided.
            init = emitter.c_undefined_value(typ)
            emitter.emit_line(f"{emitter.ctype(typ)} arg_{name} = {init};")
            emitter.emit_line(f"if (obj_{name} != NULL) {{")
            bitmap = bitmap_name(bitmap_arg_index // BITMAP_BITS)
            emitter.emit_line(f"{bitmap} |= 1 &lt;&lt; {bitmap_arg_index &amp; (BITMAP_BITS - 1)};")
            emitter.emit_unbox(
                f"obj_{name}",
                f"arg_{name}",
                typ,
                declare_dest=False,
                raise_exception=raise_exception,
                error=error,
                borrow=True,
            )
            emitter.emit_line("}")
        else:
            # Borrow when unboxing to avoid reference count manipulation.
            emitter.emit_unbox(
                f"obj_{name}",
                f"arg_{name}",
                typ,
                declare_dest=True,
                raise_exception=raise_exception,
                error=error,
                borrow=True,
                optional=optional,
            )
    elif is_object_rprimitive(typ):
        # Object is trivial since any object is valid
        if optional:
            emitter.emit_line(f"PyObject *arg_{name};")
            emitter.emit_line(f"if (obj_{name} == NULL) {{")
            emitter.emit_line(f"arg_{name} = {emitter.c_error_value(typ)};")
            emitter.emit_lines("} else {", f"arg_{name} = obj_{name}; ", "}")
        else:
            emitter.emit_line(f"PyObject *arg_{name} = obj_{name};")
    else:
        emitter.emit_cast(
            f"obj_{name}",
            f"arg_{name}",
            typ,
            declare_dest=True,
            raise_exception=raise_exception,
            error=error,
            optional=optional,
        )
</t>
<t tx="ekr.20240308084832.542">class WrapperGenerator:
    """Helper that simplifies the generation of wrapper functions."""
    @others
</t>
<t tx="ekr.20240308084832.543"># TODO: Use this for more wrappers

def __init__(self, cl: ClassIR | None, emitter: Emitter) -&gt; None:
    self.cl = cl
    self.emitter = emitter
    self.cleanups: list[str] = []
    self.optional_args: list[RuntimeArg] = []
    self.traceback_code = ""
</t>
<t tx="ekr.20240308084832.544">def set_target(self, fn: FuncIR) -&gt; None:
    """Set the wrapped function.

    It's fine to modify the attributes initialized here later to customize
    the wrapper function.
    """
    self.target_name = fn.name
    self.target_cname = fn.cname(self.emitter.names)
    self.num_bitmap_args = fn.sig.num_bitmap_args
    if self.num_bitmap_args:
        self.args = fn.args[: -self.num_bitmap_args]
    else:
        self.args = fn.args
    self.arg_names = [arg.name for arg in self.args]
    self.ret_type = fn.ret_type
</t>
<t tx="ekr.20240308084832.545">def wrapper_name(self) -&gt; str:
    """Return the name of the wrapper function."""
    return "{}{}{}".format(
        DUNDER_PREFIX,
        self.target_name,
        self.cl.name_prefix(self.emitter.names) if self.cl else "",
    )
</t>
<t tx="ekr.20240308084832.546">def use_goto(self) -&gt; bool:
    """Do we use a goto for error handling (instead of straight return)?"""
    return bool(self.cleanups or self.traceback_code)
</t>
<t tx="ekr.20240308084832.547">def emit_header(self) -&gt; None:
    """Emit the function header of the wrapper implementation."""
    input_args = ", ".join(f"PyObject *obj_{arg}" for arg in self.arg_names)
    self.emitter.emit_line(
        "static PyObject *{name}({input_args}) {{".format(
            name=self.wrapper_name(), input_args=input_args
        )
    )
</t>
<t tx="ekr.20240308084832.548">def emit_arg_processing(
    self, error: ErrorHandler | None = None, raise_exception: bool = True
) -&gt; None:
    """Emit validation and unboxing of arguments."""
    error = error or self.error()
    bitmap_arg_index = 0
    for arg_name, arg in zip(self.arg_names, self.args):
        # Suppress the argument check for *args/**kwargs, since we know it must be right.
        typ = arg.type if arg.kind not in (ARG_STAR, ARG_STAR2) else object_rprimitive
        optional = arg in self.optional_args
        generate_arg_check(
            arg_name,
            typ,
            self.emitter,
            error,
            raise_exception=raise_exception,
            optional=optional,
            bitmap_arg_index=bitmap_arg_index,
        )
        if optional and typ.error_overlap:
            bitmap_arg_index += 1
</t>
<t tx="ekr.20240308084832.549">def emit_call(self, not_implemented_handler: str = "") -&gt; None:
    """Emit call to the wrapper function.

    If not_implemented_handler is non-empty, use this C code to handle
    a NotImplemented return value (if it's possible based on the return type).
    """
    native_args = ", ".join(f"arg_{arg}" for arg in self.arg_names)
    if self.num_bitmap_args:
        bitmap_args = ", ".join(
            [bitmap_name(i) for i in reversed(range(self.num_bitmap_args))]
        )
        native_args = f"{native_args}, {bitmap_args}"

    ret_type = self.ret_type
    emitter = self.emitter
    if ret_type.is_unboxed or self.use_goto():
        # TODO: The Py_RETURN macros return the correct PyObject * with reference count
        #       handling. Are they relevant?
        emitter.emit_line(
            "{}retval = {}{}({});".format(
                emitter.ctype_spaced(ret_type), NATIVE_PREFIX, self.target_cname, native_args
            )
        )
        emitter.emit_lines(*self.cleanups)
        if ret_type.is_unboxed:
            emitter.emit_error_check("retval", ret_type, "return NULL;")
            emitter.emit_box("retval", "retbox", ret_type, declare_dest=True)

        emitter.emit_line("return {};".format("retbox" if ret_type.is_unboxed else "retval"))
    else:
        if not_implemented_handler and not isinstance(ret_type, RInstance):
            # The return value type may overlap with NotImplemented.
            emitter.emit_line(
                "PyObject *retbox = {}{}({});".format(
                    NATIVE_PREFIX, self.target_cname, native_args
                )
            )
            emitter.emit_lines(
                "if (retbox == Py_NotImplemented) {",
                not_implemented_handler,
                "}",
                "return retbox;",
            )
        else:
            emitter.emit_line(f"return {NATIVE_PREFIX}{self.target_cname}({native_args});")
</t>
<t tx="ekr.20240308084832.55">def __init__(self, right: RType) -&gt; None:
    self.right = right
</t>
<t tx="ekr.20240308084832.550">        # TODO: Tracebacks?

def error(self) -&gt; ErrorHandler:
    """Figure out how to deal with errors in the wrapper."""
    if self.cleanups or self.traceback_code:
        # We'll have a label at the end with error handling code.
        return GotoHandler("fail")
    else:
        # Nothing special needs to done to handle errors, so just return.
        return ReturnHandler("NULL")
</t>
<t tx="ekr.20240308084832.551">def emit_error_handling(self) -&gt; None:
    """Emit error handling block at the end of the wrapper, if needed."""
    emitter = self.emitter
    if self.use_goto():
        emitter.emit_label("fail")
        emitter.emit_lines(*self.cleanups)
        if self.traceback_code:
            emitter.emit_line(self.traceback_code)
        emitter.emit_line("return NULL;")
</t>
<t tx="ekr.20240308084832.552">def finish(self) -&gt; None:
    self.emitter.emit_line("}")
</t>
<t tx="ekr.20240308084832.553">from __future__ import annotations

from typing import Final, FrozenSet, Tuple, Union
from typing_extensions import TypeGuard

# Supported Python literal types. All tuple / frozenset items must have supported
# literal types as well, but we can't represent the type precisely.
LiteralValue = Union[
    str, bytes, int, bool, float, complex, Tuple[object, ...], FrozenSet[object], None
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.554">def _is_literal_value(obj: object) -&gt; TypeGuard[LiteralValue]:
    return isinstance(obj, (str, bytes, int, float, complex, tuple, frozenset, type(None)))
</t>
<t tx="ekr.20240308084832.555"># Some literals are singletons and handled specially (None, False and True)
NUM_SINGLETONS: Final = 3


class Literals:
    """Collection of literal values used in a compilation group and related helpers."""
    @others
</t>
<t tx="ekr.20240308084832.556">def __init__(self) -&gt; None:
    # Each dict maps value to literal index (0, 1, ...)
    self.str_literals: dict[str, int] = {}
    self.bytes_literals: dict[bytes, int] = {}
    self.int_literals: dict[int, int] = {}
    self.float_literals: dict[float, int] = {}
    self.complex_literals: dict[complex, int] = {}
    self.tuple_literals: dict[tuple[object, ...], int] = {}
    self.frozenset_literals: dict[frozenset[object], int] = {}
</t>
<t tx="ekr.20240308084832.557">def record_literal(self, value: LiteralValue) -&gt; None:
    """Ensure that the literal value is available in generated code."""
    if value is None or value is True or value is False:
        # These are special cased and always present
        return
    if isinstance(value, str):
        str_literals = self.str_literals
        if value not in str_literals:
            str_literals[value] = len(str_literals)
    elif isinstance(value, bytes):
        bytes_literals = self.bytes_literals
        if value not in bytes_literals:
            bytes_literals[value] = len(bytes_literals)
    elif isinstance(value, int):
        int_literals = self.int_literals
        if value not in int_literals:
            int_literals[value] = len(int_literals)
    elif isinstance(value, float):
        float_literals = self.float_literals
        if value not in float_literals:
            float_literals[value] = len(float_literals)
    elif isinstance(value, complex):
        complex_literals = self.complex_literals
        if value not in complex_literals:
            complex_literals[value] = len(complex_literals)
    elif isinstance(value, tuple):
        tuple_literals = self.tuple_literals
        if value not in tuple_literals:
            for item in value:
                assert _is_literal_value(item)
                self.record_literal(item)
            tuple_literals[value] = len(tuple_literals)
    elif isinstance(value, frozenset):
        frozenset_literals = self.frozenset_literals
        if value not in frozenset_literals:
            for item in value:
                assert _is_literal_value(item)
                self.record_literal(item)
            frozenset_literals[value] = len(frozenset_literals)
    else:
        assert False, "invalid literal: %r" % value
</t>
<t tx="ekr.20240308084832.558">def literal_index(self, value: LiteralValue) -&gt; int:
    """Return the index to the literals array for given value."""
    # The array contains first None and booleans, followed by all str values,
    # followed by bytes values, etc.
    if value is None:
        return 0
    elif value is False:
        return 1
    elif value is True:
        return 2
    n = NUM_SINGLETONS
    if isinstance(value, str):
        return n + self.str_literals[value]
    n += len(self.str_literals)
    if isinstance(value, bytes):
        return n + self.bytes_literals[value]
    n += len(self.bytes_literals)
    if isinstance(value, int):
        return n + self.int_literals[value]
    n += len(self.int_literals)
    if isinstance(value, float):
        return n + self.float_literals[value]
    n += len(self.float_literals)
    if isinstance(value, complex):
        return n + self.complex_literals[value]
    n += len(self.complex_literals)
    if isinstance(value, tuple):
        return n + self.tuple_literals[value]
    n += len(self.tuple_literals)
    if isinstance(value, frozenset):
        return n + self.frozenset_literals[value]
    assert False, "invalid literal: %r" % value
</t>
<t tx="ekr.20240308084832.559">def num_literals(self) -&gt; int:
    # The first three are for None, True and False
    return (
        NUM_SINGLETONS
        + len(self.str_literals)
        + len(self.bytes_literals)
        + len(self.int_literals)
        + len(self.float_literals)
        + len(self.complex_literals)
        + len(self.tuple_literals)
        + len(self.frozenset_literals)
    )
</t>
<t tx="ekr.20240308084832.56">def visit_rinstance(self, left: RInstance) -&gt; bool:
    return is_subtype(left, self.right)
</t>
<t tx="ekr.20240308084832.560"># The following methods return the C encodings of literal values
# of different types

def encoded_str_values(self) -&gt; list[bytes]:
    return _encode_str_values(self.str_literals)
</t>
<t tx="ekr.20240308084832.561">def encoded_int_values(self) -&gt; list[bytes]:
    return _encode_int_values(self.int_literals)
</t>
<t tx="ekr.20240308084832.562">def encoded_bytes_values(self) -&gt; list[bytes]:
    return _encode_bytes_values(self.bytes_literals)
</t>
<t tx="ekr.20240308084832.563">def encoded_float_values(self) -&gt; list[str]:
    return _encode_float_values(self.float_literals)
</t>
<t tx="ekr.20240308084832.564">def encoded_complex_values(self) -&gt; list[str]:
    return _encode_complex_values(self.complex_literals)
</t>
<t tx="ekr.20240308084832.565">def encoded_tuple_values(self) -&gt; list[str]:
    return self._encode_collection_values(self.tuple_literals)
</t>
<t tx="ekr.20240308084832.566">def encoded_frozenset_values(self) -&gt; list[str]:
    return self._encode_collection_values(self.frozenset_literals)
</t>
<t tx="ekr.20240308084832.567">def _encode_collection_values(
    self, values: dict[tuple[object, ...], int] | dict[frozenset[object], int]
) -&gt; list[str]:
    """Encode tuple/frozenset values into a C array.

    The format of the result is like this:

       &lt;number of collections&gt;
       &lt;length of the first collection&gt;
       &lt;literal index of first item&gt;
       ...
       &lt;literal index of last item&gt;
       &lt;length of the second collection&gt;
       ...
    """
    value_by_index = {index: value for value, index in values.items()}
    result = []
    count = len(values)
    result.append(str(count))
    for i in range(count):
        value = value_by_index[i]
        result.append(str(len(value)))
        for item in value:
            assert _is_literal_value(item)
            index = self.literal_index(item)
            result.append(str(index))
    return result
</t>
<t tx="ekr.20240308084832.568">def _encode_str_values(values: dict[str, int]) -&gt; list[bytes]:
    value_by_index = {index: value for value, index in values.items()}
    result = []
    line: list[bytes] = []
    line_len = 0
    for i in range(len(values)):
        value = value_by_index[i]
        c_literal = format_str_literal(value)
        c_len = len(c_literal)
        if line_len &gt; 0 and line_len + c_len &gt; 70:
            result.append(format_int(len(line)) + b"".join(line))
            line = []
            line_len = 0
        line.append(c_literal)
        line_len += c_len
    if line:
        result.append(format_int(len(line)) + b"".join(line))
    result.append(b"")
    return result
</t>
<t tx="ekr.20240308084832.569">def _encode_bytes_values(values: dict[bytes, int]) -&gt; list[bytes]:
    value_by_index = {index: value for value, index in values.items()}
    result = []
    line: list[bytes] = []
    line_len = 0
    for i in range(len(values)):
        value = value_by_index[i]
        c_init = format_int(len(value))
        c_len = len(c_init) + len(value)
        if line_len &gt; 0 and line_len + c_len &gt; 70:
            result.append(format_int(len(line)) + b"".join(line))
            line = []
            line_len = 0
        line.append(c_init + value)
        line_len += c_len
    if line:
        result.append(format_int(len(line)) + b"".join(line))
    result.append(b"")
    return result
</t>
<t tx="ekr.20240308084832.57">def visit_runion(self, left: RUnion) -&gt; bool:
    return not self.right.is_unboxed and is_subtype(left, self.right)
</t>
<t tx="ekr.20240308084832.570">def format_int(n: int) -&gt; bytes:
    """Format an integer using a variable-length binary encoding."""
    if n &lt; 128:
        a = [n]
    else:
        a = []
        while n &gt; 0:
            a.insert(0, n &amp; 0x7F)
            n &gt;&gt;= 7
        for i in range(len(a) - 1):
            # If the highest bit is set, more 7-bit digits follow
            a[i] |= 0x80
    return bytes(a)
</t>
<t tx="ekr.20240308084832.571">def format_str_literal(s: str) -&gt; bytes:
    utf8 = s.encode("utf-8")
    return format_int(len(utf8)) + utf8
</t>
<t tx="ekr.20240308084832.572">def _encode_int_values(values: dict[int, int]) -&gt; list[bytes]:
    """Encode int values into C strings.

    Values are stored in base 10 and separated by 0 bytes.
    """
    value_by_index = {index: value for value, index in values.items()}
    result = []
    line: list[bytes] = []
    line_len = 0
    for i in range(len(values)):
        value = value_by_index[i]
        encoded = b"%d" % value
        if line_len &gt; 0 and line_len + len(encoded) &gt; 70:
            result.append(format_int(len(line)) + b"\0".join(line))
            line = []
            line_len = 0
        line.append(encoded)
        line_len += len(encoded)
    if line:
        result.append(format_int(len(line)) + b"\0".join(line))
    result.append(b"")
    return result
</t>
<t tx="ekr.20240308084832.573">def float_to_c(x: float) -&gt; str:
    """Return C literal representation of a float value."""
    s = str(x)
    if s == "inf":
        return "INFINITY"
    elif s == "-inf":
        return "-INFINITY"
    elif s == "nan":
        return "NAN"
    return s
</t>
<t tx="ekr.20240308084832.574">def _encode_float_values(values: dict[float, int]) -&gt; list[str]:
    """Encode float values into a C array values.

    The result contains the number of values followed by individual values.
    """
    value_by_index = {index: value for value, index in values.items()}
    result = []
    num = len(values)
    result.append(str(num))
    for i in range(num):
        value = value_by_index[i]
        result.append(float_to_c(value))
    return result
</t>
<t tx="ekr.20240308084832.575">def _encode_complex_values(values: dict[complex, int]) -&gt; list[str]:
    """Encode float values into a C array values.

    The result contains the number of values followed by pairs of doubles
    representing complex numbers.
    """
    value_by_index = {index: value for value, index in values.items()}
    result = []
    num = len(values)
    result.append(str(num))
    for i in range(num):
        value = value_by_index[i]
        result.append(float_to_c(value.real))
        result.append(float_to_c(value.imag))
    return result
</t>
<t tx="ekr.20240308084832.576"></t>
<t tx="ekr.20240308084832.577"># Configuration file for the Sphinx documentation builder.
#
# This file only contains a selection of the most common options. For a full
# list see the documentation:
# https://www.sphinx-doc.org/en/master/usage/configuration.html

from __future__ import annotations

import os
import sys

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath("../.."))

from mypy.version import __version__ as mypy_version

# -- Project information -----------------------------------------------------

project = "mypyc"
copyright = "2020-2022, mypyc team"
author = "mypyc team"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = mypy_version.split("-")[0]
# The full version, including alpha/beta/rc tags.
release = mypy_version

# -- General configuration ---------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = []  # type: ignore[var-annotated]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This pattern also affects html_static_path and html_extra_path.
exclude_patterns = ["_build", "Thumbs.db", ".DS_Store"]


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "furo"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.578"></t>
<t tx="ekr.20240308084832.579"></t>
<t tx="ekr.20240308084832.58">def visit_rprimitive(self, left: RPrimitive) -&gt; bool:
    if is_short_int_rprimitive(left) and is_int_rprimitive(self.right):
        return True
    if is_bit_rprimitive(left) and is_bool_rprimitive(self.right):
        return True
    return left is self.right
</t>
<t tx="ekr.20240308084832.580"></t>
<t tx="ekr.20240308084832.581"></t>
<t tx="ekr.20240308084832.582"></t>
<t tx="ekr.20240308084832.583">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.584">"""Intermediate representation of classes."""

from __future__ import annotations

from typing import List, NamedTuple

from mypyc.common import PROPSET_PREFIX, JsonDict
from mypyc.ir.func_ir import FuncDecl, FuncIR, FuncSignature
from mypyc.ir.ops import DeserMaps, Value
from mypyc.ir.rtypes import RInstance, RType, deserialize_type
from mypyc.namegen import NameGenerator, exported_name

# Some notes on the vtable layout: Each concrete class has a vtable
# that contains function pointers for its methods. So that subclasses
# may be efficiently used when their parent class is expected, the
# layout of child vtables must be an extension of their base class's
# vtable.
#
# This makes multiple inheritance tricky, since obviously we cannot be
# an extension of multiple parent classes. We solve this by requiring
# all but one parent to be "traits", which we can operate on in a
# somewhat less efficient way. For each trait implemented by a class,
# we generate a separate vtable for the methods in that trait.
# We then store an array of (trait type, trait vtable) pointers alongside
# a class's main vtable. When we want to call a trait method, we
# (at runtime!) search the array of trait vtables to find the correct one,
# then call through it.
# Trait vtables additionally need entries for attribute getters and setters,
# since they can't always be in the same location.
#
# To keep down the number of indirections necessary, we store the
# array of trait vtables in the memory *before* the class vtable, and
# search it backwards.  (This is a trick we can only do once---there
# are only two directions to store data in---but I don't think we'll
# need it again.)
# There are some tricks we could try in the future to store the trait
# vtables inline in the trait table (which would cut down one indirection),
# but this seems good enough for now.
#
# As an example:
# Imagine that we have a class B that inherits from a concrete class A
# and traits T1 and T2, and that A has methods foo() and
# bar() and B overrides bar() with a more specific type.
# Then B's vtable will look something like:
#
#      T1 type object
#      ptr to B's T1 trait vtable
#      T2 type object
#      ptr to B's T2 trait vtable
# -&gt; | A.foo
#    | Glue function that converts between A.bar's type and B.bar
#      B.bar
#      B.baz
#
# The arrow points to the "start" of the vtable (what vtable pointers
# point to) and the bars indicate which parts correspond to the parent
# class A's vtable layout.
#
# Classes that allow interpreted code to subclass them also have a
# "shadow vtable" that contains implementations that delegate to
# making a pycall, so that overridden methods in interpreted children
# will be called. (A better strategy could dynamically generate these
# vtables based on which methods are overridden in the children.)

# Descriptions of method and attribute entries in class vtables.
# The 'cls' field is the class that the method/attr was defined in,
# which might be a parent class.
# The 'shadow_method', if present, contains the method that should be
# placed in the class's shadow vtable (if it has one).


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.585">class VTableMethod(NamedTuple):
    cls: "ClassIR"  # noqa: UP037
    name: str
    method: FuncIR
    shadow_method: FuncIR | None
</t>
<t tx="ekr.20240308084832.586">VTableEntries = List[VTableMethod]


class ClassIR:
    """Intermediate representation of a class.
    
    This also describes the runtime structure of native instances.
    """
    @others
</t>
<t tx="ekr.20240308084832.587">def __init__(
    self,
    name: str,
    module_name: str,
    is_trait: bool = False,
    is_generated: bool = False,
    is_abstract: bool = False,
    is_ext_class: bool = True,
) -&gt; None:
    self.name = name
    self.module_name = module_name
    self.is_trait = is_trait
    self.is_generated = is_generated
    self.is_abstract = is_abstract
    self.is_ext_class = is_ext_class
    # An augmented class has additional methods separate from what mypyc generates.
    # Right now the only one is dataclasses.
    self.is_augmented = False
    # Does this inherit from a Python class?
    self.inherits_python = False
    # Do instances of this class have __dict__?
    self.has_dict = False
    # Do we allow interpreted subclasses? Derived from a mypyc_attr.
    self.allow_interpreted_subclasses = False
    # Does this class need getseters to be generated for its attributes? (getseters are also
    # added if is_generated is False)
    self.needs_getseters = False
    # Is this class declared as serializable (supports copy.copy
    # and pickle) using @mypyc_attr(serializable=True)?
    #
    # Additionally, any class with this attribute False but with
    # an __init__ that can be called without any arguments is
    # *implicitly serializable*. In this case __init__ will be
    # called during deserialization without arguments. If this is
    # True, we match Python semantics and __init__ won't be called
    # during deserialization.
    #
    # This impacts also all subclasses. Use is_serializable() to
    # also consider base classes.
    self._serializable = False
    # If this a subclass of some built-in python class, the name
    # of the object for that class. We currently only support this
    # in a few ad-hoc cases.
    self.builtin_base: str | None = None
    # Default empty constructor
    self.ctor = FuncDecl(name, None, module_name, FuncSignature([], RInstance(self)))
    # Attributes defined in the class (not inherited)
    self.attributes: dict[str, RType] = {}
    # Deletable attributes
    self.deletable: list[str] = []
    # We populate method_types with the signatures of every method before
    # we generate methods, and we rely on this information being present.
    self.method_decls: dict[str, FuncDecl] = {}
    # Map of methods that are actually present in an extension class
    self.methods: dict[str, FuncIR] = {}
    # Glue methods for boxing/unboxing when a class changes the type
    # while overriding a method. Maps from (parent class overridden, method)
    # to IR of glue method.
    self.glue_methods: dict[tuple[ClassIR, str], FuncIR] = {}

    # Properties are accessed like attributes, but have behavior like method calls.
    # They don't belong in the methods dictionary, since we don't want to expose them to
    # Python's method API. But we want to put them into our own vtable as methods, so that
    # they are properly handled and overridden. The property dictionary values are a tuple
    # containing a property getter and an optional property setter.
    self.properties: dict[str, tuple[FuncIR, FuncIR | None]] = {}
    # We generate these in prepare_class_def so that we have access to them when generating
    # other methods and properties that rely on these types.
    self.property_types: dict[str, RType] = {}

    self.vtable: dict[str, int] | None = None
    self.vtable_entries: VTableEntries = []
    self.trait_vtables: dict[ClassIR, VTableEntries] = {}
    # N.B: base might not actually quite be the direct base.
    # It is the nearest concrete base, but we allow a trait in between.
    self.base: ClassIR | None = None
    self.traits: list[ClassIR] = []
    # Supply a working mro for most generated classes. Real classes will need to
    # fix it up.
    self.mro: list[ClassIR] = [self]
    # base_mro is the chain of concrete (non-trait) ancestors
    self.base_mro: list[ClassIR] = [self]

    # Direct subclasses of this class (use subclasses() to also include non-direct ones)
    # None if separate compilation prevents this from working.
    #
    # Often it's better to use has_no_subclasses() or subclasses() instead.
    self.children: list[ClassIR] | None = []

    # Instance attributes that are initialized in the class body.
    self.attrs_with_defaults: set[str] = set()

    # Attributes that are always initialized in __init__ or class body
    # (inferred in mypyc.analysis.attrdefined using interprocedural analysis)
    self._always_initialized_attrs: set[str] = set()

    # Attributes that are sometimes initialized in __init__
    self._sometimes_initialized_attrs: set[str] = set()

    # If True, __init__ can make 'self' visible to unanalyzed/arbitrary code
    self.init_self_leak = False

    # Definedness of these attributes is backed by a bitmap. Index in the list
    # indicates the bit number. Includes inherited attributes. We need the
    # bitmap for types such as native ints that can't have a dedicated error
    # value that doesn't overlap a valid value. The bitmap is used if the
    # value of an attribute is the same as the error value.
    self.bitmap_attrs: list[str] = []
</t>
<t tx="ekr.20240308084832.588">def __repr__(self) -&gt; str:
    return (
        "ClassIR("
        "name={self.name}, module_name={self.module_name}, "
        "is_trait={self.is_trait}, is_generated={self.is_generated}, "
        "is_abstract={self.is_abstract}, is_ext_class={self.is_ext_class}"
        ")".format(self=self)
    )
</t>
<t tx="ekr.20240308084832.589">@property
def fullname(self) -&gt; str:
    return f"{self.module_name}.{self.name}"
</t>
<t tx="ekr.20240308084832.59">def visit_rtuple(self, left: RTuple) -&gt; bool:
    if isinstance(self.right, RTuple):
        return len(self.right.types) == len(left.types) and all(
            is_runtime_subtype(t1, t2) for t1, t2 in zip(left.types, self.right.types)
        )
    return False
</t>
<t tx="ekr.20240308084832.590">def real_base(self) -&gt; ClassIR | None:
    """Return the actual concrete base class, if there is one."""
    if len(self.mro) &gt; 1 and not self.mro[1].is_trait:
        return self.mro[1]
    return None
</t>
<t tx="ekr.20240308084832.591">def vtable_entry(self, name: str) -&gt; int:
    assert self.vtable is not None, "vtable not computed yet"
    assert name in self.vtable, f"{self.name!r} has no attribute {name!r}"
    return self.vtable[name]
</t>
<t tx="ekr.20240308084832.592">def attr_details(self, name: str) -&gt; tuple[RType, ClassIR]:
    for ir in self.mro:
        if name in ir.attributes:
            return ir.attributes[name], ir
        if name in ir.property_types:
            return ir.property_types[name], ir
    raise KeyError(f"{self.name!r} has no attribute {name!r}")
</t>
<t tx="ekr.20240308084832.593">def attr_type(self, name: str) -&gt; RType:
    return self.attr_details(name)[0]
</t>
<t tx="ekr.20240308084832.594">def method_decl(self, name: str) -&gt; FuncDecl:
    for ir in self.mro:
        if name in ir.method_decls:
            return ir.method_decls[name]
    raise KeyError(f"{self.name!r} has no attribute {name!r}")
</t>
<t tx="ekr.20240308084832.595">def method_sig(self, name: str) -&gt; FuncSignature:
    return self.method_decl(name).sig
</t>
<t tx="ekr.20240308084832.596">def has_method(self, name: str) -&gt; bool:
    try:
        self.method_decl(name)
    except KeyError:
        return False
    return True
</t>
<t tx="ekr.20240308084832.597">def is_method_final(self, name: str) -&gt; bool:
    subs = self.subclasses()
    if subs is None:
        # TODO: Look at the final attribute!
        return False

    if self.has_method(name):
        method_decl = self.method_decl(name)
        for subc in subs:
            if subc.method_decl(name) != method_decl:
                return False
        return True
    else:
        return not any(subc.has_method(name) for subc in subs)
</t>
<t tx="ekr.20240308084832.598">def has_attr(self, name: str) -&gt; bool:
    try:
        self.attr_type(name)
    except KeyError:
        return False
    return True
</t>
<t tx="ekr.20240308084832.599">def is_deletable(self, name: str) -&gt; bool:
    return any(name in ir.deletable for ir in self.mro)
</t>
<t tx="ekr.20240308084832.6">"""Support for building extensions using mypyc with distutils or setuptools

The main entry point is mypycify, which produces a list of extension
modules to be passed to setup. A trivial setup.py for a mypyc built
project, then, looks like:

    from setuptools import setup
    from mypyc.build import mypycify

    setup(name='test_module',
          ext_modules=mypycify(['foo.py']),
    )

See the mypycify docs for additional arguments.

mypycify can integrate with either distutils or setuptools, but needs
to know at import-time whether it is using distutils or setuputils. We
hackily decide based on whether setuptools has been imported already.
"""

from __future__ import annotations

import hashlib
import os.path
import re
import sys
import time
from typing import TYPE_CHECKING, Any, Dict, Iterable, NoReturn, Union, cast

from mypy.build import BuildSource
from mypy.errors import CompileError
from mypy.fscache import FileSystemCache
from mypy.main import process_options
from mypy.options import Options
from mypy.util import write_junit_xml
from mypyc.codegen import emitmodule
from mypyc.common import RUNTIME_C_FILES, shared_lib_name
from mypyc.errors import Errors
from mypyc.ir.pprint import format_modules
from mypyc.namegen import exported_name
from mypyc.options import CompilerOptions

try:
    # Import setuptools so that it monkey-patch overrides distutils
    import setuptools
except ImportError:
    pass

if TYPE_CHECKING:
    if sys.version_info &gt;= (3, 12):
        from setuptools import Extension
    else:
        from distutils.core import Extension as _distutils_Extension
        from typing_extensions import TypeAlias

        from setuptools import Extension as _setuptools_Extension

        Extension: TypeAlias = Union[_setuptools_Extension, _distutils_Extension]

if sys.version_info &gt;= (3, 12):
    # From setuptools' monkeypatch
    from distutils import ccompiler, sysconfig  # type: ignore[import-not-found]
else:
    from distutils import ccompiler, sysconfig


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.60">def visit_rstruct(self, left: RStruct) -&gt; bool:
    return isinstance(self.right, RStruct) and self.right.name == left.name
</t>
<t tx="ekr.20240308084832.600">def is_always_defined(self, name: str) -&gt; bool:
    if self.is_deletable(name):
        return False
    return name in self._always_initialized_attrs
</t>
<t tx="ekr.20240308084832.601">def name_prefix(self, names: NameGenerator) -&gt; str:
    return names.private_name(self.module_name, self.name)
</t>
<t tx="ekr.20240308084832.602">def struct_name(self, names: NameGenerator) -&gt; str:
    return f"{exported_name(self.fullname)}Object"
</t>
<t tx="ekr.20240308084832.603">def get_method_and_class(
    self, name: str, *, prefer_method: bool = False
) -&gt; tuple[FuncIR, ClassIR] | None:
    for ir in self.mro:
        if name in ir.methods:
            func_ir = ir.methods[name]
            if not prefer_method and func_ir.decl.implicit:
                # This is an implicit accessor, so there is also an attribute definition
                # which the caller prefers. This happens if an attribute overrides a
                # property.
                return None
            return func_ir, ir

    return None
</t>
<t tx="ekr.20240308084832.604">def get_method(self, name: str, *, prefer_method: bool = False) -&gt; FuncIR | None:
    res = self.get_method_and_class(name, prefer_method=prefer_method)
    return res[0] if res else None
</t>
<t tx="ekr.20240308084832.605">def has_method_decl(self, name: str) -&gt; bool:
    return any(name in ir.method_decls for ir in self.mro)
</t>
<t tx="ekr.20240308084832.606">def has_no_subclasses(self) -&gt; bool:
    return self.children == [] and not self.allow_interpreted_subclasses
</t>
<t tx="ekr.20240308084832.607">def subclasses(self) -&gt; set[ClassIR] | None:
    """Return all subclasses of this class, both direct and indirect.

    Return None if it is impossible to identify all subclasses, for example
    because we are performing separate compilation.
    """
    if self.children is None or self.allow_interpreted_subclasses:
        return None
    result = set(self.children)
    for child in self.children:
        if child.children:
            child_subs = child.subclasses()
            if child_subs is None:
                return None
            result.update(child_subs)
    return result
</t>
<t tx="ekr.20240308084832.608">def concrete_subclasses(self) -&gt; list[ClassIR] | None:
    """Return all concrete (i.e. non-trait and non-abstract) subclasses.

    Include both direct and indirect subclasses. Place classes with no children first.
    """
    subs = self.subclasses()
    if subs is None:
        return None
    concrete = {c for c in subs if not (c.is_trait or c.is_abstract)}
    # We place classes with no children first because they are more likely
    # to appear in various isinstance() checks. We then sort leaves by name
    # to get stable order.
    return sorted(concrete, key=lambda c: (len(c.children or []), c.name))
</t>
<t tx="ekr.20240308084832.609">def is_serializable(self) -&gt; bool:
    return any(ci._serializable for ci in self.mro)
</t>
<t tx="ekr.20240308084832.61">def visit_rarray(self, left: RArray) -&gt; bool:
    return left == self.right
</t>
<t tx="ekr.20240308084832.610">def serialize(self) -&gt; JsonDict:
    return {
        "name": self.name,
        "module_name": self.module_name,
        "is_trait": self.is_trait,
        "is_ext_class": self.is_ext_class,
        "is_abstract": self.is_abstract,
        "is_generated": self.is_generated,
        "is_augmented": self.is_augmented,
        "inherits_python": self.inherits_python,
        "has_dict": self.has_dict,
        "allow_interpreted_subclasses": self.allow_interpreted_subclasses,
        "needs_getseters": self.needs_getseters,
        "_serializable": self._serializable,
        "builtin_base": self.builtin_base,
        "ctor": self.ctor.serialize(),
        # We serialize dicts as lists to ensure order is preserved
        "attributes": [(k, t.serialize()) for k, t in self.attributes.items()],
        # We try to serialize a name reference, but if the decl isn't in methods
        # then we can't be sure that will work so we serialize the whole decl.
        "method_decls": [
            (k, d.id if k in self.methods else d.serialize())
            for k, d in self.method_decls.items()
        ],
        # We serialize method fullnames out and put methods in a separate dict
        "methods": [(k, m.id) for k, m in self.methods.items()],
        "glue_methods": [
            ((cir.fullname, k), m.id) for (cir, k), m in self.glue_methods.items()
        ],
        # We serialize properties and property_types separately out of an
        # abundance of caution about preserving dict ordering...
        "property_types": [(k, t.serialize()) for k, t in self.property_types.items()],
        "properties": list(self.properties),
        "vtable": self.vtable,
        "vtable_entries": serialize_vtable(self.vtable_entries),
        "trait_vtables": [
            (cir.fullname, serialize_vtable(v)) for cir, v in self.trait_vtables.items()
        ],
        # References to class IRs are all just names
        "base": self.base.fullname if self.base else None,
        "traits": [cir.fullname for cir in self.traits],
        "mro": [cir.fullname for cir in self.mro],
        "base_mro": [cir.fullname for cir in self.base_mro],
        "children": [cir.fullname for cir in self.children]
        if self.children is not None
        else None,
        "deletable": self.deletable,
        "attrs_with_defaults": sorted(self.attrs_with_defaults),
        "_always_initialized_attrs": sorted(self._always_initialized_attrs),
        "_sometimes_initialized_attrs": sorted(self._sometimes_initialized_attrs),
        "init_self_leak": self.init_self_leak,
    }
</t>
<t tx="ekr.20240308084832.611">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; ClassIR:
    fullname = data["module_name"] + "." + data["name"]
    assert fullname in ctx.classes, "Class %s not in deser class map" % fullname
    ir = ctx.classes[fullname]

    ir.is_trait = data["is_trait"]
    ir.is_generated = data["is_generated"]
    ir.is_abstract = data["is_abstract"]
    ir.is_ext_class = data["is_ext_class"]
    ir.is_augmented = data["is_augmented"]
    ir.inherits_python = data["inherits_python"]
    ir.has_dict = data["has_dict"]
    ir.allow_interpreted_subclasses = data["allow_interpreted_subclasses"]
    ir.needs_getseters = data["needs_getseters"]
    ir._serializable = data["_serializable"]
    ir.builtin_base = data["builtin_base"]
    ir.ctor = FuncDecl.deserialize(data["ctor"], ctx)
    ir.attributes = {k: deserialize_type(t, ctx) for k, t in data["attributes"]}
    ir.method_decls = {
        k: ctx.functions[v].decl if isinstance(v, str) else FuncDecl.deserialize(v, ctx)
        for k, v in data["method_decls"]
    }
    ir.methods = {k: ctx.functions[v] for k, v in data["methods"]}
    ir.glue_methods = {
        (ctx.classes[c], k): ctx.functions[v] for (c, k), v in data["glue_methods"]
    }
    ir.property_types = {k: deserialize_type(t, ctx) for k, t in data["property_types"]}
    ir.properties = {
        k: (ir.methods[k], ir.methods.get(PROPSET_PREFIX + k)) for k in data["properties"]
    }

    ir.vtable = data["vtable"]
    ir.vtable_entries = deserialize_vtable(data["vtable_entries"], ctx)
    ir.trait_vtables = {
        ctx.classes[k]: deserialize_vtable(v, ctx) for k, v in data["trait_vtables"]
    }

    base = data["base"]
    ir.base = ctx.classes[base] if base else None
    ir.traits = [ctx.classes[s] for s in data["traits"]]
    ir.mro = [ctx.classes[s] for s in data["mro"]]
    ir.base_mro = [ctx.classes[s] for s in data["base_mro"]]
    ir.children = data["children"] and [ctx.classes[s] for s in data["children"]]
    ir.deletable = data["deletable"]
    ir.attrs_with_defaults = set(data["attrs_with_defaults"])
    ir._always_initialized_attrs = set(data["_always_initialized_attrs"])
    ir._sometimes_initialized_attrs = set(data["_sometimes_initialized_attrs"])
    ir.init_self_leak = data["init_self_leak"]

    return ir
</t>
<t tx="ekr.20240308084832.612">class NonExtClassInfo:
    """Information needed to construct a non-extension class (Python class).
    
    Includes the class dictionary, a tuple of base classes,
    the class annotations dictionary, and the metaclass.
    """
    @others
</t>
<t tx="ekr.20240308084832.613">def __init__(self, dict: Value, bases: Value, anns: Value, metaclass: Value) -&gt; None:
    self.dict = dict
    self.bases = bases
    self.anns = anns
    self.metaclass = metaclass
</t>
<t tx="ekr.20240308084832.614">def serialize_vtable_entry(entry: VTableMethod) -&gt; JsonDict:
    return {
        ".class": "VTableMethod",
        "cls": entry.cls.fullname,
        "name": entry.name,
        "method": entry.method.decl.id,
        "shadow_method": entry.shadow_method.decl.id if entry.shadow_method else None,
    }
</t>
<t tx="ekr.20240308084832.615">def serialize_vtable(vtable: VTableEntries) -&gt; list[JsonDict]:
    return [serialize_vtable_entry(v) for v in vtable]
</t>
<t tx="ekr.20240308084832.616">def deserialize_vtable_entry(data: JsonDict, ctx: DeserMaps) -&gt; VTableMethod:
    if data[".class"] == "VTableMethod":
        return VTableMethod(
            ctx.classes[data["cls"]],
            data["name"],
            ctx.functions[data["method"]],
            ctx.functions[data["shadow_method"]] if data["shadow_method"] else None,
        )
    assert False, "Bogus vtable .class: %s" % data[".class"]
</t>
<t tx="ekr.20240308084832.617">def deserialize_vtable(data: list[JsonDict], ctx: DeserMaps) -&gt; VTableEntries:
    return [deserialize_vtable_entry(x, ctx) for x in data]
</t>
<t tx="ekr.20240308084832.618">def all_concrete_classes(class_ir: ClassIR) -&gt; list[ClassIR] | None:
    """Return all concrete classes among the class itself and its subclasses."""
    concrete = class_ir.concrete_subclasses()
    if concrete is None:
        return None
    if not (class_ir.is_abstract or class_ir.is_trait):
        concrete.append(class_ir)
    return concrete
</t>
<t tx="ekr.20240308084832.619">"""Intermediate representation of functions."""

from __future__ import annotations

from typing import Final, Sequence

from mypy.nodes import ARG_POS, ArgKind, Block, FuncDef
from mypyc.common import BITMAP_BITS, JsonDict, bitmap_name, get_id_from_name, short_id_from_name
from mypyc.ir.ops import (
    Assign,
    AssignMulti,
    BasicBlock,
    ControlOp,
    DeserMaps,
    LoadAddress,
    Register,
    Value,
)
from mypyc.ir.rtypes import RType, bitmap_rprimitive, deserialize_type
from mypyc.namegen import NameGenerator


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.62">def visit_rvoid(self, left: RVoid) -&gt; bool:
    return isinstance(self.right, RVoid)
</t>
<t tx="ekr.20240308084832.620">class RuntimeArg:
    """Description of a function argument in IR.
    
    Argument kind is one of ARG_* constants defined in mypy.nodes.
    """
    @others
</t>
<t tx="ekr.20240308084832.621">def __init__(
    self, name: str, typ: RType, kind: ArgKind = ARG_POS, pos_only: bool = False
) -&gt; None:
    self.name = name
    self.type = typ
    self.kind = kind
    self.pos_only = pos_only
</t>
<t tx="ekr.20240308084832.622">@property
def optional(self) -&gt; bool:
    return self.kind.is_optional()
</t>
<t tx="ekr.20240308084832.623">def __repr__(self) -&gt; str:
    return "RuntimeArg(name={}, type={}, optional={!r}, pos_only={!r})".format(
        self.name, self.type, self.optional, self.pos_only
    )
</t>
<t tx="ekr.20240308084832.624">def serialize(self) -&gt; JsonDict:
    return {
        "name": self.name,
        "type": self.type.serialize(),
        "kind": int(self.kind.value),
        "pos_only": self.pos_only,
    }
</t>
<t tx="ekr.20240308084832.625">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; RuntimeArg:
    return RuntimeArg(
        data["name"],
        deserialize_type(data["type"], ctx),
        ArgKind(data["kind"]),
        data["pos_only"],
    )
</t>
<t tx="ekr.20240308084832.626">class FuncSignature:
    """Signature of a function in IR."""
    @others
</t>
<t tx="ekr.20240308084832.627"># TODO: Track if method?

def __init__(self, args: Sequence[RuntimeArg], ret_type: RType) -&gt; None:
    self.args = tuple(args)
    self.ret_type = ret_type
    # Bitmap arguments are use to mark default values for arguments that
    # have types with overlapping error values.
    self.num_bitmap_args = num_bitmap_args(self.args)
    if self.num_bitmap_args:
        extra = [
            RuntimeArg(bitmap_name(i), bitmap_rprimitive, pos_only=True)
            for i in range(self.num_bitmap_args)
        ]
        self.args = self.args + tuple(reversed(extra))
</t>
<t tx="ekr.20240308084832.628">def real_args(self) -&gt; tuple[RuntimeArg, ...]:
    """Return arguments without any synthetic bitmap arguments."""
    if self.num_bitmap_args:
        return self.args[: -self.num_bitmap_args]
    return self.args
</t>
<t tx="ekr.20240308084832.629">def bound_sig(self) -&gt; FuncSignature:
    if self.num_bitmap_args:
        return FuncSignature(self.args[1 : -self.num_bitmap_args], self.ret_type)
    else:
        return FuncSignature(self.args[1:], self.ret_type)
</t>
<t tx="ekr.20240308084832.63">"""Same type check for RTypes."""

from __future__ import annotations

from mypyc.ir.func_ir import FuncSignature
from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RPrimitive,
    RStruct,
    RTuple,
    RType,
    RTypeVisitor,
    RUnion,
    RVoid,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.630">def __repr__(self) -&gt; str:
    return f"FuncSignature(args={self.args!r}, ret={self.ret_type!r})"
</t>
<t tx="ekr.20240308084832.631">def serialize(self) -&gt; JsonDict:
    if self.num_bitmap_args:
        args = self.args[: -self.num_bitmap_args]
    else:
        args = self.args
    return {"args": [t.serialize() for t in args], "ret_type": self.ret_type.serialize()}
</t>
<t tx="ekr.20240308084832.632">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; FuncSignature:
    return FuncSignature(
        [RuntimeArg.deserialize(arg, ctx) for arg in data["args"]],
        deserialize_type(data["ret_type"], ctx),
    )
</t>
<t tx="ekr.20240308084832.633">def num_bitmap_args(args: tuple[RuntimeArg, ...]) -&gt; int:
    n = 0
    for arg in args:
        if arg.type.error_overlap and arg.kind.is_optional():
            n += 1
    return (n + (BITMAP_BITS - 1)) // BITMAP_BITS
</t>
<t tx="ekr.20240308084832.634">FUNC_NORMAL: Final = 0
FUNC_STATICMETHOD: Final = 1
FUNC_CLASSMETHOD: Final = 2


class FuncDecl:
    """Declaration of a function in IR (without body or implementation).
    
    A function can be a regular module-level function, a method, a
    static method, a class method, or a property getter/setter.
    """
    @others
</t>
<t tx="ekr.20240308084832.635">def __init__(
    self,
    name: str,
    class_name: str | None,
    module_name: str,
    sig: FuncSignature,
    kind: int = FUNC_NORMAL,
    is_prop_setter: bool = False,
    is_prop_getter: bool = False,
    implicit: bool = False,
) -&gt; None:
    self.name = name
    self.class_name = class_name
    self.module_name = module_name
    self.sig = sig
    self.kind = kind
    self.is_prop_setter = is_prop_setter
    self.is_prop_getter = is_prop_getter
    if class_name is None:
        self.bound_sig: FuncSignature | None = None
    else:
        if kind == FUNC_STATICMETHOD:
            self.bound_sig = sig
        else:
            self.bound_sig = sig.bound_sig()

    # If True, not present in the mypy AST and must be synthesized during irbuild
    # Currently only supported for property getters/setters
    self.implicit = implicit

    # This is optional because this will be set to the line number when the corresponding
    # FuncIR is created
    self._line: int | None = None
</t>
<t tx="ekr.20240308084832.636">@property
def line(self) -&gt; int:
    assert self._line is not None
    return self._line
</t>
<t tx="ekr.20240308084832.637">@line.setter
def line(self, line: int) -&gt; None:
    self._line = line
</t>
<t tx="ekr.20240308084832.638">@property
def id(self) -&gt; str:
    assert self.line is not None
    return get_id_from_name(self.name, self.fullname, self.line)
</t>
<t tx="ekr.20240308084832.639">@staticmethod
def compute_shortname(class_name: str | None, name: str) -&gt; str:
    return class_name + "." + name if class_name else name
</t>
<t tx="ekr.20240308084832.64">def is_same_type(a: RType, b: RType) -&gt; bool:
    return a.accept(SameTypeVisitor(b))
</t>
<t tx="ekr.20240308084832.640">@property
def shortname(self) -&gt; str:
    return FuncDecl.compute_shortname(self.class_name, self.name)
</t>
<t tx="ekr.20240308084832.641">@property
def fullname(self) -&gt; str:
    return self.module_name + "." + self.shortname
</t>
<t tx="ekr.20240308084832.642">def cname(self, names: NameGenerator) -&gt; str:
    partial_name = short_id_from_name(self.name, self.shortname, self._line)
    return names.private_name(self.module_name, partial_name)
</t>
<t tx="ekr.20240308084832.643">def serialize(self) -&gt; JsonDict:
    return {
        "name": self.name,
        "class_name": self.class_name,
        "module_name": self.module_name,
        "sig": self.sig.serialize(),
        "kind": self.kind,
        "is_prop_setter": self.is_prop_setter,
        "is_prop_getter": self.is_prop_getter,
        "implicit": self.implicit,
    }
</t>
<t tx="ekr.20240308084832.644"># TODO: move this to FuncIR?
@staticmethod
def get_id_from_json(func_ir: JsonDict) -&gt; str:
    """Get the id from the serialized FuncIR associated with this FuncDecl"""
    decl = func_ir["decl"]
    shortname = FuncDecl.compute_shortname(decl["class_name"], decl["name"])
    fullname = decl["module_name"] + "." + shortname
    return get_id_from_name(decl["name"], fullname, func_ir["line"])
</t>
<t tx="ekr.20240308084832.645">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; FuncDecl:
    return FuncDecl(
        data["name"],
        data["class_name"],
        data["module_name"],
        FuncSignature.deserialize(data["sig"], ctx),
        data["kind"],
        data["is_prop_setter"],
        data["is_prop_getter"],
        data["implicit"],
    )
</t>
<t tx="ekr.20240308084832.646">class FuncIR:
    """Intermediate representation of a function with contextual information.
    
    Unlike FuncDecl, this includes the IR of the body (basic blocks).
    """
    @others
</t>
<t tx="ekr.20240308084832.647">def __init__(
    self,
    decl: FuncDecl,
    arg_regs: list[Register],
    blocks: list[BasicBlock],
    line: int = -1,
    traceback_name: str | None = None,
) -&gt; None:
    # Declaration of the function, including the signature
    self.decl = decl
    # Registers for all the arguments to the function
    self.arg_regs = arg_regs
    # Body of the function
    self.blocks = blocks
    self.decl.line = line
    # The name that should be displayed for tracebacks that
    # include this function. Function will be omitted from
    # tracebacks if None.
    self.traceback_name = traceback_name
</t>
<t tx="ekr.20240308084832.648">@property
def line(self) -&gt; int:
    return self.decl.line
</t>
<t tx="ekr.20240308084832.649">@property
def args(self) -&gt; Sequence[RuntimeArg]:
    return self.decl.sig.args
</t>
<t tx="ekr.20240308084832.65">def is_same_signature(a: FuncSignature, b: FuncSignature) -&gt; bool:
    return (
        len(a.args) == len(b.args)
        and is_same_type(a.ret_type, b.ret_type)
        and all(
            is_same_type(t1.type, t2.type) and t1.name == t2.name for t1, t2 in zip(a.args, b.args)
        )
    )
</t>
<t tx="ekr.20240308084832.650">@property
def ret_type(self) -&gt; RType:
    return self.decl.sig.ret_type
</t>
<t tx="ekr.20240308084832.651">@property
def class_name(self) -&gt; str | None:
    return self.decl.class_name
</t>
<t tx="ekr.20240308084832.652">@property
def sig(self) -&gt; FuncSignature:
    return self.decl.sig
</t>
<t tx="ekr.20240308084832.653">@property
def name(self) -&gt; str:
    return self.decl.name
</t>
<t tx="ekr.20240308084832.654">@property
def fullname(self) -&gt; str:
    return self.decl.fullname
</t>
<t tx="ekr.20240308084832.655">@property
def id(self) -&gt; str:
    return self.decl.id
</t>
<t tx="ekr.20240308084832.656">def cname(self, names: NameGenerator) -&gt; str:
    return self.decl.cname(names)
</t>
<t tx="ekr.20240308084832.657">def __repr__(self) -&gt; str:
    if self.class_name:
        return f"&lt;FuncIR {self.class_name}.{self.name}&gt;"
    else:
        return f"&lt;FuncIR {self.name}&gt;"
</t>
<t tx="ekr.20240308084832.658">def serialize(self) -&gt; JsonDict:
    # We don't include blocks in the serialized version
    return {
        "decl": self.decl.serialize(),
        "line": self.line,
        "traceback_name": self.traceback_name,
    }
</t>
<t tx="ekr.20240308084832.659">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; FuncIR:
    return FuncIR(
        FuncDecl.deserialize(data["decl"], ctx), [], [], data["line"], data["traceback_name"]
    )
</t>
<t tx="ekr.20240308084832.66">def is_same_method_signature(a: FuncSignature, b: FuncSignature) -&gt; bool:
    return (
        len(a.args) == len(b.args)
        and is_same_type(a.ret_type, b.ret_type)
        and all(
            is_same_type(t1.type, t2.type)
            and ((t1.pos_only and t2.pos_only) or t1.name == t2.name)
            and t1.optional == t2.optional
            for t1, t2 in zip(a.args[1:], b.args[1:])
        )
    )
</t>
<t tx="ekr.20240308084832.660">INVALID_FUNC_DEF: Final = FuncDef("&lt;INVALID_FUNC_DEF&gt;", [], Block([]))


def all_values(args: list[Register], blocks: list[BasicBlock]) -&gt; list[Value]:
    """Return the set of all values that may be initialized in the blocks.

    This omits registers that are only read.
    """
    values: list[Value] = list(args)
    seen_registers = set(args)

    for block in blocks:
        for op in block.ops:
            if not isinstance(op, ControlOp):
                if isinstance(op, (Assign, AssignMulti)):
                    if op.dest not in seen_registers:
                        values.append(op.dest)
                        seen_registers.add(op.dest)
                elif op.is_void:
                    continue
                else:
                    # If we take the address of a register, it might get initialized.
                    if (
                        isinstance(op, LoadAddress)
                        and isinstance(op.src, Register)
                        and op.src not in seen_registers
                    ):
                        values.append(op.src)
                        seen_registers.add(op.src)
                    values.append(op)

    return values
</t>
<t tx="ekr.20240308084832.661">def all_values_full(args: list[Register], blocks: list[BasicBlock]) -&gt; list[Value]:
    """Return set of all values that are initialized or accessed."""
    values: list[Value] = list(args)
    seen_registers = set(args)

    for block in blocks:
        for op in block.ops:
            for source in op.sources():
                # Look for uninitialized registers that are accessed. Ignore
                # non-registers since we don't allow ops outside basic blocks.
                if isinstance(source, Register) and source not in seen_registers:
                    values.append(source)
                    seen_registers.add(source)
            if not isinstance(op, ControlOp):
                if isinstance(op, (Assign, AssignMulti)):
                    if op.dest not in seen_registers:
                        values.append(op.dest)
                        seen_registers.add(op.dest)
                elif op.is_void:
                    continue
                else:
                    values.append(op)

    return values
</t>
<t tx="ekr.20240308084832.662">"""Intermediate representation of modules."""

from __future__ import annotations

from typing import Dict

from mypyc.common import JsonDict
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.func_ir import FuncDecl, FuncIR
from mypyc.ir.ops import DeserMaps
from mypyc.ir.rtypes import RType, deserialize_type


@others
# ModulesIRs should also always be an *OrderedDict*, but if we
# declared it that way we would need to put it in quotes everywhere...
ModuleIRs = Dict[str, ModuleIR]
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.663">class ModuleIR:
    """Intermediate representation of a module."""
    @others
</t>
<t tx="ekr.20240308084832.664">def __init__(
    self,
    fullname: str,
    imports: list[str],
    functions: list[FuncIR],
    classes: list[ClassIR],
    final_names: list[tuple[str, RType]],
) -&gt; None:
    self.fullname = fullname
    self.imports = imports.copy()
    self.functions = functions
    self.classes = classes
    self.final_names = final_names
</t>
<t tx="ekr.20240308084832.665">def serialize(self) -&gt; JsonDict:
    return {
        "fullname": self.fullname,
        "imports": self.imports,
        "functions": [f.serialize() for f in self.functions],
        "classes": [c.serialize() for c in self.classes],
        "final_names": [(k, t.serialize()) for k, t in self.final_names],
    }
</t>
<t tx="ekr.20240308084832.666">@classmethod
def deserialize(cls, data: JsonDict, ctx: DeserMaps) -&gt; ModuleIR:
    return ModuleIR(
        data["fullname"],
        data["imports"],
        [ctx.functions[FuncDecl.get_id_from_json(f)] for f in data["functions"]],
        [ClassIR.deserialize(c, ctx) for c in data["classes"]],
        [(k, deserialize_type(t, ctx)) for k, t in data["final_names"]],
    )
</t>
<t tx="ekr.20240308084832.667">def deserialize_modules(data: dict[str, JsonDict], ctx: DeserMaps) -&gt; dict[str, ModuleIR]:
    """Deserialize a collection of modules.

    The modules can contain dependencies on each other.

    Arguments:
        data: A dict containing the modules to deserialize.
        ctx: The deserialization maps to use and to populate.
             They are populated with information from the deserialized
             modules and as a precondition must have been populated by
             deserializing any dependencies of the modules being deserialized
             (outside of dependencies between the modules themselves).

    Returns a map containing the deserialized modules.
    """
    for mod in data.values():
        # First create ClassIRs for every class so that we can construct types and whatnot
        for cls in mod["classes"]:
            ir = ClassIR(cls["name"], cls["module_name"])
            assert ir.fullname not in ctx.classes, "Class %s already in map" % ir.fullname
            ctx.classes[ir.fullname] = ir

    for mod in data.values():
        # Then deserialize all of the functions so that methods are available
        # to the class deserialization.
        for method in mod["functions"]:
            func = FuncIR.deserialize(method, ctx)
            assert func.decl.id not in ctx.functions, (
                "Method %s already in map" % func.decl.fullname
            )
            ctx.functions[func.decl.id] = func

    return {k: ModuleIR.deserialize(v, ctx) for k, v in data.items()}
</t>
<t tx="ekr.20240308084832.668">"""Low-level opcodes for compiler intermediate representation (IR).

Opcodes operate on abstract values (Value) in a register machine. Each
value has a type (RType). A value can hold various things, such as:

- local variables (Register)
- intermediate values of expressions (RegisterOp subclasses)
- condition flags (true/false)
- literals (integer literals, True, False, etc.)
"""

from __future__ import annotations

from abc import abstractmethod
from typing import TYPE_CHECKING, Final, Generic, List, NamedTuple, Sequence, TypeVar, Union

from mypy_extensions import trait

from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RTuple,
    RType,
    RVoid,
    bit_rprimitive,
    bool_rprimitive,
    float_rprimitive,
    int_rprimitive,
    is_bit_rprimitive,
    is_bool_rprimitive,
    is_int_rprimitive,
    is_none_rprimitive,
    is_pointer_rprimitive,
    is_short_int_rprimitive,
    object_rprimitive,
    pointer_rprimitive,
    short_int_rprimitive,
    void_rtype,
)

if TYPE_CHECKING:
    from mypyc.codegen.literals import LiteralValue
    from mypyc.ir.class_ir import ClassIR
    from mypyc.ir.func_ir import FuncDecl, FuncIR

T = TypeVar("T")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.669">class BasicBlock:
    """IR basic block.
    
    Contains a sequence of Ops and ends with a ControlOp (Goto,
    Branch, Return or Unreachable). Only the last op can be a
    ControlOp.
    
    All generated Ops live in basic blocks. Basic blocks determine the
    order of evaluation and control flow within a function. A basic
    block is always associated with a single function/method (FuncIR).
    
    When building the IR, ops that raise exceptions can be included in
    the middle of a basic block, but the exceptions aren't checked.
    Afterwards we perform a transform that inserts explicit checks for
    all error conditions and splits basic blocks accordingly to preserve
    the invariant that a jump, branch or return can only ever appear
    as the final op in a block. Manually inserting error checking ops
    would be boring and error-prone.
    
    BasicBlocks have an error_handler attribute that determines where
    to jump if an error occurs. If none is specified, an error will
    propagate up out of the function. This is compiled away by the
    `exceptions` module.
    
    Block labels are used for pretty printing and emitting C code, and
    get filled in by those passes.
    
    Ops that may terminate the program aren't treated as exits.
    """
    @others
</t>
<t tx="ekr.20240308084832.67">class SameTypeVisitor(RTypeVisitor[bool]):
    @others
</t>
<t tx="ekr.20240308084832.670">def __init__(self, label: int = -1) -&gt; None:
    self.label = label
    self.ops: list[Op] = []
    self.error_handler: BasicBlock | None = None
    self.referenced = False
</t>
<t tx="ekr.20240308084832.671">@property
def terminated(self) -&gt; bool:
    """Does the block end with a jump, branch or return?

    This should always be true after the basic block has been fully built, but
    this is false during construction.
    """
    return bool(self.ops) and isinstance(self.ops[-1], ControlOp)
</t>
<t tx="ekr.20240308084832.672">@property
def terminator(self) -&gt; ControlOp:
    """The terminator operation of the block."""
    assert bool(self.ops) and isinstance(self.ops[-1], ControlOp)
    return self.ops[-1]
</t>
<t tx="ekr.20240308084832.673"># Never generates an exception
ERR_NEVER: Final = 0
# Generates magic value (c_error_value) based on target RType on exception
ERR_MAGIC: Final = 1
# Generates false (bool) on exception
ERR_FALSE: Final = 2
# Always fails
ERR_ALWAYS: Final = 3
# Like ERR_MAGIC, but the magic return overlaps with a possible return value, and
# an extra PyErr_Occurred() check is also required
ERR_MAGIC_OVERLAPPING: Final = 4

# Hack: using this line number for an op will suppress it in tracebacks
NO_TRACEBACK_LINE_NO = -10000


class Value:
    """Abstract base class for all IR values.
    
    These include references to registers, literals, and all
    operations (Ops), such as assignments, calls and branches.
    
    Values are often used as inputs of Ops. Register can be used as an
    assignment target.
    
    A Value is part of the IR being compiled if it's included in a BasicBlock
    that is reachable from a FuncIR (i.e., is part of a function).
    
    See also: Op is a subclass of Value that is the base class of all
    operations.
    """
    @others
</t>
<t tx="ekr.20240308084832.674"># Source line number (-1 for no/unknown line)
line = -1
# Type of the value or the result of the operation
type: RType = void_rtype
is_borrowed = False

@property
def is_void(self) -&gt; bool:
    return isinstance(self.type, RVoid)
</t>
<t tx="ekr.20240308084832.675">class Register(Value):
    """A Register holds a value of a specific type, and it can be read and mutated.
    
    A Register is always local to a function. Each local variable maps
    to a Register, and they are also used for some (but not all)
    temporary values.
    
    Note that the term 'register' is overloaded and is sometimes used
    to refer to arbitrary Values (for example, in RegisterOp).
    """
    @others
</t>
<t tx="ekr.20240308084832.676">def __init__(self, type: RType, name: str = "", is_arg: bool = False, line: int = -1) -&gt; None:
    self.type = type
    self.name = name
    self.is_arg = is_arg
    self.is_borrowed = is_arg
    self.line = line
</t>
<t tx="ekr.20240308084832.677">@property
def is_void(self) -&gt; bool:
    return False
</t>
<t tx="ekr.20240308084832.678">def __repr__(self) -&gt; str:
    return f"&lt;Register {self.name!r} at {hex(id(self))}&gt;"
</t>
<t tx="ekr.20240308084832.679">class Integer(Value):
    """Short integer literal.
    
    Integer literals are treated as constant values and are generally
    not included in data flow analyses and such, unlike Register and
    Op subclasses.
    
    Integer can represent multiple types:
    
     * Short tagged integers (short_int_primitive type; the tag bit is clear)
     * Ordinary fixed-width integers (e.g., int32_rprimitive)
     * Values of other unboxed primitive types that are represented as integers
       (none_rprimitive, bool_rprimitive)
     * Null pointers (value 0) of various types, including object_rprimitive
    """
    @others
</t>
<t tx="ekr.20240308084832.68">def __init__(self, right: RType) -&gt; None:
    self.right = right
</t>
<t tx="ekr.20240308084832.680">def __init__(self, value: int, rtype: RType = short_int_rprimitive, line: int = -1) -&gt; None:
    if is_short_int_rprimitive(rtype) or is_int_rprimitive(rtype):
        self.value = value * 2
    else:
        self.value = value
    self.type = rtype
    self.line = line
</t>
<t tx="ekr.20240308084832.681">def numeric_value(self) -&gt; int:
    if is_short_int_rprimitive(self.type) or is_int_rprimitive(self.type):
        return self.value // 2
    return self.value
</t>
<t tx="ekr.20240308084832.682">class Float(Value):
    """Float literal.
    
    Floating point literals are treated as constant values and are generally
    not included in data flow analyses and such, unlike Register and
    Op subclasses.
    """
    @others
</t>
<t tx="ekr.20240308084832.683">def __init__(self, value: float, line: int = -1) -&gt; None:
    self.value = value
    self.type = float_rprimitive
    self.line = line
</t>
<t tx="ekr.20240308084832.684">class Op(Value):
    """Abstract base class for all IR operations.
    
    Each operation must be stored in a BasicBlock (in 'ops') to be
    active in the IR. This is different from non-Op values, including
    Register and Integer, where a reference from an active Op is
    sufficient to be considered active.
    
    In well-formed IR an active Op has no references to inactive ops
    or ops used in another function.
    """
    @others
</t>
<t tx="ekr.20240308084832.685">def __init__(self, line: int) -&gt; None:
    self.line = line
</t>
<t tx="ekr.20240308084832.686">def can_raise(self) -&gt; bool:
    # Override this is if Op may raise an exception. Note that currently the fact that
    # only RegisterOps may raise an exception in hard coded in some places.
    return False
</t>
<t tx="ekr.20240308084832.687">@abstractmethod
def sources(self) -&gt; list[Value]:
    """All the values the op may read."""
</t>
<t tx="ekr.20240308084832.688">def stolen(self) -&gt; list[Value]:
    """Return arguments that have a reference count stolen by this op"""
    return []
</t>
<t tx="ekr.20240308084832.689">def unique_sources(self) -&gt; list[Value]:
    result: list[Value] = []
    for reg in self.sources():
        if reg not in result:
            result.append(reg)
    return result
</t>
<t tx="ekr.20240308084832.69">def visit_rinstance(self, left: RInstance) -&gt; bool:
    return isinstance(self.right, RInstance) and left.name == self.right.name
</t>
<t tx="ekr.20240308084832.690">@abstractmethod
def accept(self, visitor: OpVisitor[T]) -&gt; T:
    pass
</t>
<t tx="ekr.20240308084832.691">class BaseAssign(Op):
    """Base class for ops that assign to a register."""
    @others
</t>
<t tx="ekr.20240308084832.692">def __init__(self, dest: Register, line: int = -1) -&gt; None:
    super().__init__(line)
    self.dest = dest
</t>
<t tx="ekr.20240308084832.693">class Assign(BaseAssign):
    """Assign a value to a Register (dest = src)."""
    @others
</t>
<t tx="ekr.20240308084832.694">error_kind = ERR_NEVER

def __init__(self, dest: Register, src: Value, line: int = -1) -&gt; None:
    super().__init__(dest, line)
    self.src = src
</t>
<t tx="ekr.20240308084832.695">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.696">def stolen(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.697">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_assign(self)
</t>
<t tx="ekr.20240308084832.698">class AssignMulti(BaseAssign):
    """Assign multiple values to a Register (dest = src1, src2, ...).
    
    This is used to initialize RArray values. It's provided to avoid
    very verbose IR for common vectorcall operations.
    
    Note that this interacts atypically with reference counting. We
    assume that each RArray register is initialized exactly once
    with this op.
    """
    @others
</t>
<t tx="ekr.20240308084832.699">error_kind = ERR_NEVER

def __init__(self, dest: Register, src: list[Value], line: int = -1) -&gt; None:
    super().__init__(dest, line)
    assert src
    assert isinstance(dest.type, RArray)
    assert dest.type.length == len(src)
    self.src = src
</t>
<t tx="ekr.20240308084832.7">def get_extension() -&gt; type[Extension]:
    # We can work with either setuptools or distutils, and pick setuptools
    # if it has been imported.
    use_setuptools = "setuptools" in sys.modules
    extension_class: type[Extension]

    if sys.version_info &lt; (3, 12) and not use_setuptools:
        import distutils.core

        extension_class = distutils.core.Extension
    else:
        if not use_setuptools:
            sys.exit("error: setuptools not installed")
        extension_class = setuptools.Extension

    return extension_class
</t>
<t tx="ekr.20240308084832.70">def visit_runion(self, left: RUnion) -&gt; bool:
    if isinstance(self.right, RUnion):
        items = list(self.right.items)
        for left_item in left.items:
            for j, right_item in enumerate(items):
                if is_same_type(left_item, right_item):
                    del items[j]
                    break
            else:
                return False
        return not items
    return False
</t>
<t tx="ekr.20240308084832.700">def sources(self) -&gt; list[Value]:
    return self.src.copy()
</t>
<t tx="ekr.20240308084832.701">def stolen(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.702">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_assign_multi(self)
</t>
<t tx="ekr.20240308084832.703">class ControlOp(Op):
    """Control flow operation."""
    @others
</t>
<t tx="ekr.20240308084832.704">def targets(self) -&gt; Sequence[BasicBlock]:
    """Get all basic block targets of the control operation."""
    return ()
</t>
<t tx="ekr.20240308084832.705">def set_target(self, i: int, new: BasicBlock) -&gt; None:
    """Update a basic block target."""
    raise AssertionError(f"Invalid set_target({self}, {i})")
</t>
<t tx="ekr.20240308084832.706">class Goto(ControlOp):
    """Unconditional jump."""
    @others
</t>
<t tx="ekr.20240308084832.707">error_kind = ERR_NEVER

def __init__(self, label: BasicBlock, line: int = -1) -&gt; None:
    super().__init__(line)
    self.label = label
</t>
<t tx="ekr.20240308084832.708">def targets(self) -&gt; Sequence[BasicBlock]:
    return (self.label,)
</t>
<t tx="ekr.20240308084832.709">def set_target(self, i: int, new: BasicBlock) -&gt; None:
    assert i == 0
    self.label = new
</t>
<t tx="ekr.20240308084832.71">def visit_rprimitive(self, left: RPrimitive) -&gt; bool:
    return left is self.right
</t>
<t tx="ekr.20240308084832.710">def __repr__(self) -&gt; str:
    return "&lt;Goto %s&gt;" % self.label.label
</t>
<t tx="ekr.20240308084832.711">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.712">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_goto(self)
</t>
<t tx="ekr.20240308084832.713">class Branch(ControlOp):
    """Branch based on a value.
    
    If op is BOOL, branch based on a bit/bool value:
       if [not] r1 goto L1 else goto L2
    
    If op is IS_ERROR, branch based on whether there is an error value:
       if [not] is_error(r1) goto L1 else goto L2
    """
    @others
</t>
<t tx="ekr.20240308084832.714"># Branch ops never raise an exception.
error_kind = ERR_NEVER

BOOL: Final = 100
IS_ERROR: Final = 101

def __init__(
    self,
    value: Value,
    true_label: BasicBlock,
    false_label: BasicBlock,
    op: int,
    line: int = -1,
    *,
    rare: bool = False,
) -&gt; None:
    super().__init__(line)
    # Target value being checked
    self.value = value
    # Branch here if the condition is true
    self.true = true_label
    # Branch here if the condition is false
    self.false = false_label
    # Branch.BOOL (boolean check) or Branch.IS_ERROR (error value check)
    self.op = op
    # If True, the condition is negated
    self.negated = False
    # If not None, the true label should generate a traceback entry (func name, line number)
    self.traceback_entry: tuple[str, int] | None = None
    # If True, we expect to usually take the false branch (for optimization purposes);
    # this is implicitly treated as true if there is a traceback entry
    self.rare = rare
</t>
<t tx="ekr.20240308084832.715">def targets(self) -&gt; Sequence[BasicBlock]:
    return (self.true, self.false)
</t>
<t tx="ekr.20240308084832.716">def set_target(self, i: int, new: BasicBlock) -&gt; None:
    assert i == 0 or i == 1
    if i == 0:
        self.true = new
    else:
        self.false = new
</t>
<t tx="ekr.20240308084832.717">def sources(self) -&gt; list[Value]:
    return [self.value]
</t>
<t tx="ekr.20240308084832.718">def invert(self) -&gt; None:
    self.negated = not self.negated
</t>
<t tx="ekr.20240308084832.719">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_branch(self)
</t>
<t tx="ekr.20240308084832.72">def visit_rtuple(self, left: RTuple) -&gt; bool:
    return (
        isinstance(self.right, RTuple)
        and len(self.right.types) == len(left.types)
        and all(is_same_type(t1, t2) for t1, t2 in zip(left.types, self.right.types))
    )
</t>
<t tx="ekr.20240308084832.720">class Return(ControlOp):
    """Return a value from a function."""
    @others
</t>
<t tx="ekr.20240308084832.721">error_kind = ERR_NEVER

def __init__(self, value: Value, line: int = -1) -&gt; None:
    super().__init__(line)
    self.value = value
</t>
<t tx="ekr.20240308084832.722">def sources(self) -&gt; list[Value]:
    return [self.value]
</t>
<t tx="ekr.20240308084832.723">def stolen(self) -&gt; list[Value]:
    return [self.value]
</t>
<t tx="ekr.20240308084832.724">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_return(self)
</t>
<t tx="ekr.20240308084832.725">class Unreachable(ControlOp):
    """Mark the end of basic block as unreachable.
    
    This is sometimes necessary when the end of a basic block is never
    reached. This can also be explicitly added to the end of non-None
    returning functions (in None-returning function we can just return
    None).
    
    Mypy statically guarantees that the end of the function is not
    unreachable if there is not a return statement.
    
    This prevents the block formatter from being confused due to lack
    of a leave and also leaves a nifty note in the IR. It is not
    generally processed by visitors.
    """
    @others
</t>
<t tx="ekr.20240308084832.726">error_kind = ERR_NEVER

def __init__(self, line: int = -1) -&gt; None:
    super().__init__(line)
</t>
<t tx="ekr.20240308084832.727">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.728">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_unreachable(self)
</t>
<t tx="ekr.20240308084832.729">class RegisterOp(Op):
    """Abstract base class for operations that can be written as r1 = f(r2, ..., rn).
    
    Takes some values, performs an operation, and generates an output
    (unless the 'type' attribute is void_rtype, which is the default).
    Other ops can refer to the result of the Op by referring to the Op
    instance. This doesn't do any explicit control flow, but can raise an
    error.
    
    Note that the operands can be arbitrary Values, not just Register
    instances, even though the naming may suggest otherwise.
    """
    @others
</t>
<t tx="ekr.20240308084832.73">def visit_rstruct(self, left: RStruct) -&gt; bool:
    return isinstance(self.right, RStruct) and self.right.name == left.name
</t>
<t tx="ekr.20240308084832.730">error_kind = -1  # Can this raise exception and how is it signalled; one of ERR_*

_type: RType | None = None

def __init__(self, line: int) -&gt; None:
    super().__init__(line)
    assert self.error_kind != -1, "error_kind not defined"
</t>
<t tx="ekr.20240308084832.731">def can_raise(self) -&gt; bool:
    return self.error_kind != ERR_NEVER
</t>
<t tx="ekr.20240308084832.732">class IncRef(RegisterOp):
    """Increase reference count (inc_ref src)."""
    @others
</t>
<t tx="ekr.20240308084832.733">error_kind = ERR_NEVER

def __init__(self, src: Value, line: int = -1) -&gt; None:
    assert src.type.is_refcounted
    super().__init__(line)
    self.src = src
</t>
<t tx="ekr.20240308084832.734">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.735">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_inc_ref(self)
</t>
<t tx="ekr.20240308084832.736">class DecRef(RegisterOp):
    """Decrease reference count and free object if zero (dec_ref src).
    
    The is_xdec flag says to use an XDECREF, which checks if the
    pointer is NULL first.
    """
    @others
</t>
<t tx="ekr.20240308084832.737">error_kind = ERR_NEVER

def __init__(self, src: Value, is_xdec: bool = False, line: int = -1) -&gt; None:
    assert src.type.is_refcounted
    super().__init__(line)
    self.src = src
    self.is_xdec = is_xdec
</t>
<t tx="ekr.20240308084832.738">def __repr__(self) -&gt; str:
    return "&lt;{}DecRef {!r}&gt;".format("X" if self.is_xdec else "", self.src)
</t>
<t tx="ekr.20240308084832.739">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.74">def visit_rarray(self, left: RArray) -&gt; bool:
    return left == self.right
</t>
<t tx="ekr.20240308084832.740">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_dec_ref(self)
</t>
<t tx="ekr.20240308084832.741">class Call(RegisterOp):
    """Native call f(arg, ...).
    
    The call target can be a module-level function or a class.
    """
    @others
</t>
<t tx="ekr.20240308084832.742">def __init__(self, fn: FuncDecl, args: Sequence[Value], line: int) -&gt; None:
    self.fn = fn
    self.args = list(args)
    assert len(self.args) == len(fn.sig.args)
    self.type = fn.sig.ret_type
    ret_type = fn.sig.ret_type
    if not ret_type.error_overlap:
        self.error_kind = ERR_MAGIC
    else:
        self.error_kind = ERR_MAGIC_OVERLAPPING
    super().__init__(line)
</t>
<t tx="ekr.20240308084832.743">def sources(self) -&gt; list[Value]:
    return list(self.args.copy())
</t>
<t tx="ekr.20240308084832.744">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_call(self)
</t>
<t tx="ekr.20240308084832.745">class MethodCall(RegisterOp):
    """Native method call obj.method(arg, ...)"""
    @others
</t>
<t tx="ekr.20240308084832.746">def __init__(self, obj: Value, method: str, args: list[Value], line: int = -1) -&gt; None:
    self.obj = obj
    self.method = method
    self.args = args
    assert isinstance(obj.type, RInstance), "Methods can only be called on instances"
    self.receiver_type = obj.type
    method_ir = self.receiver_type.class_ir.method_sig(method)
    assert method_ir is not None, "{} doesn't have method {}".format(
        self.receiver_type.name, method
    )
    ret_type = method_ir.ret_type
    self.type = ret_type
    if not ret_type.error_overlap:
        self.error_kind = ERR_MAGIC
    else:
        self.error_kind = ERR_MAGIC_OVERLAPPING
    super().__init__(line)
</t>
<t tx="ekr.20240308084832.747">def sources(self) -&gt; list[Value]:
    return self.args.copy() + [self.obj]
</t>
<t tx="ekr.20240308084832.748">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_method_call(self)
</t>
<t tx="ekr.20240308084832.749">class LoadErrorValue(RegisterOp):
    """Load an error value.
    
    Each type has one reserved value that signals an error (exception). This
    loads the error value for a specific type.
    """
    @others
</t>
<t tx="ekr.20240308084832.75">def visit_rvoid(self, left: RVoid) -&gt; bool:
    return isinstance(self.right, RVoid)
</t>
<t tx="ekr.20240308084832.750">error_kind = ERR_NEVER

def __init__(
    self, rtype: RType, line: int = -1, is_borrowed: bool = False, undefines: bool = False
) -&gt; None:
    super().__init__(line)
    self.type = rtype
    self.is_borrowed = is_borrowed
    # Undefines is true if this should viewed by the definedness
    # analysis pass as making the register it is assigned to
    # undefined (and thus checks should be added on uses).
    self.undefines = undefines
</t>
<t tx="ekr.20240308084832.751">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.752">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_error_value(self)
</t>
<t tx="ekr.20240308084832.753">class LoadLiteral(RegisterOp):
    """Load a Python literal object (dest = 'foo' / b'foo' / ...).
    
    This is used to load a static PyObject * value corresponding to
    a literal of one of the supported types.
    
    Tuple / frozenset literals must contain only valid literal values as items.
    
    NOTE: You can use this to load boxed (Python) int objects. Use
          Integer to load unboxed, tagged integers or fixed-width,
          low-level integers.
    
          For int literals, both int_rprimitive (CPyTagged) and
          object_primitive (PyObject *) are supported as rtype. However,
          when using int_rprimitive, the value must *not* be small enough
          to fit in an unboxed integer.
    """
    @others
</t>
<t tx="ekr.20240308084832.754">error_kind = ERR_NEVER
is_borrowed = True

def __init__(self, value: LiteralValue, rtype: RType) -&gt; None:
    self.value = value
    self.type = rtype
</t>
<t tx="ekr.20240308084832.755">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.756">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_literal(self)
</t>
<t tx="ekr.20240308084832.757">class GetAttr(RegisterOp):
    """obj.attr (for a native object)"""
    @others
</t>
<t tx="ekr.20240308084832.758">error_kind = ERR_MAGIC

def __init__(self, obj: Value, attr: str, line: int, *, borrow: bool = False) -&gt; None:
    super().__init__(line)
    self.obj = obj
    self.attr = attr
    assert isinstance(obj.type, RInstance), "Attribute access not supported: %s" % obj.type
    self.class_type = obj.type
    attr_type = obj.type.attr_type(attr)
    self.type = attr_type
    if attr_type.error_overlap:
        self.error_kind = ERR_MAGIC_OVERLAPPING
    self.is_borrowed = borrow and attr_type.is_refcounted
</t>
<t tx="ekr.20240308084832.759">def sources(self) -&gt; list[Value]:
    return [self.obj]
</t>
<t tx="ekr.20240308084832.76">"""Subtype check for RTypes."""

from __future__ import annotations

from mypyc.ir.rtypes import (
    RArray,
    RInstance,
    RPrimitive,
    RStruct,
    RTuple,
    RType,
    RTypeVisitor,
    RUnion,
    RVoid,
    is_bit_rprimitive,
    is_bool_rprimitive,
    is_fixed_width_rtype,
    is_int_rprimitive,
    is_object_rprimitive,
    is_short_int_rprimitive,
    is_tagged,
    is_tuple_rprimitive,
)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.760">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_get_attr(self)
</t>
<t tx="ekr.20240308084832.761">class SetAttr(RegisterOp):
    """obj.attr = src (for a native object)
    
    Steals the reference to src.
    """
    @others
</t>
<t tx="ekr.20240308084832.762">error_kind = ERR_FALSE

def __init__(self, obj: Value, attr: str, src: Value, line: int) -&gt; None:
    super().__init__(line)
    self.obj = obj
    self.attr = attr
    self.src = src
    assert isinstance(obj.type, RInstance), "Attribute access not supported: %s" % obj.type
    self.class_type = obj.type
    self.type = bool_rprimitive
    # If True, we can safely assume that the attribute is previously undefined
    # and we don't use a setter
    self.is_init = False
</t>
<t tx="ekr.20240308084832.763">def mark_as_initializer(self) -&gt; None:
    self.is_init = True
    self.error_kind = ERR_NEVER
    self.type = void_rtype
</t>
<t tx="ekr.20240308084832.764">def sources(self) -&gt; list[Value]:
    return [self.obj, self.src]
</t>
<t tx="ekr.20240308084832.765">def stolen(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.766">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_set_attr(self)
</t>
<t tx="ekr.20240308084832.767"># Default name space for statics, variables
NAMESPACE_STATIC: Final = "static"

# Static namespace for pointers to native type objects
NAMESPACE_TYPE: Final = "type"

# Namespace for modules
NAMESPACE_MODULE: Final = "module"


class LoadStatic(RegisterOp):
    """Load a static name (name :: static).
    
    Load a C static variable/pointer. The namespace for statics is shared
    for the entire compilation group. You can optionally provide a module
    name and a sub-namespace identifier for additional namespacing to avoid
    name conflicts. The static namespace does not overlap with other C names,
    since the final C name will get a prefix, so conflicts only must be
    avoided with other statics.
    """
    @others
</t>
<t tx="ekr.20240308084832.768">error_kind = ERR_NEVER
is_borrowed = True

def __init__(
    self,
    type: RType,
    identifier: str,
    module_name: str | None = None,
    namespace: str = NAMESPACE_STATIC,
    line: int = -1,
    ann: object = None,
) -&gt; None:
    super().__init__(line)
    self.identifier = identifier
    self.module_name = module_name
    self.namespace = namespace
    self.type = type
    self.ann = ann  # An object to pretty print with the load
</t>
<t tx="ekr.20240308084832.769">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.77">def is_subtype(left: RType, right: RType) -&gt; bool:
    if is_object_rprimitive(right):
        return True
    elif isinstance(right, RUnion):
        if isinstance(left, RUnion):
            for left_item in left.items:
                if not any(is_subtype(left_item, right_item) for right_item in right.items):
                    return False
            return True
        else:
            return any(is_subtype(left, item) for item in right.items)
    return left.accept(SubtypeVisitor(right))
</t>
<t tx="ekr.20240308084832.770">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_static(self)
</t>
<t tx="ekr.20240308084832.771">class InitStatic(RegisterOp):
    """static = value :: static
    
    Initialize a C static variable/pointer. See everything in LoadStatic.
    """
    @others
</t>
<t tx="ekr.20240308084832.772">error_kind = ERR_NEVER

def __init__(
    self,
    value: Value,
    identifier: str,
    module_name: str | None = None,
    namespace: str = NAMESPACE_STATIC,
    line: int = -1,
) -&gt; None:
    super().__init__(line)
    self.identifier = identifier
    self.module_name = module_name
    self.namespace = namespace
    self.value = value
</t>
<t tx="ekr.20240308084832.773">def sources(self) -&gt; list[Value]:
    return [self.value]
</t>
<t tx="ekr.20240308084832.774">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_init_static(self)
</t>
<t tx="ekr.20240308084832.775">class TupleSet(RegisterOp):
    """dest = (reg, ...) (for fixed-length tuple)"""
    @others
</t>
<t tx="ekr.20240308084832.776">error_kind = ERR_NEVER

def __init__(self, items: list[Value], line: int) -&gt; None:
    super().__init__(line)
    self.items = items
    # Don't keep track of the fact that an int is short after it
    # is put into a tuple, since we don't properly implement
    # runtime subtyping for tuples.
    self.tuple_type = RTuple(
        [
            arg.type if not is_short_int_rprimitive(arg.type) else int_rprimitive
            for arg in items
        ]
    )
    self.type = self.tuple_type
</t>
<t tx="ekr.20240308084832.777">def sources(self) -&gt; list[Value]:
    return self.items.copy()
</t>
<t tx="ekr.20240308084832.778">def stolen(self) -&gt; list[Value]:
    return self.items.copy()
</t>
<t tx="ekr.20240308084832.779">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_tuple_set(self)
</t>
<t tx="ekr.20240308084832.78">class SubtypeVisitor(RTypeVisitor[bool]):
    """Is left a subtype of right?
    
    A few special cases such as right being 'object' are handled in
    is_subtype and don't need to be covered here.
    """
    @others
</t>
<t tx="ekr.20240308084832.780">class TupleGet(RegisterOp):
    """Get item of a fixed-length tuple (src[index])."""
    @others
</t>
<t tx="ekr.20240308084832.781">error_kind = ERR_NEVER

def __init__(self, src: Value, index: int, line: int = -1, *, borrow: bool = False) -&gt; None:
    super().__init__(line)
    self.src = src
    self.index = index
    assert isinstance(src.type, RTuple), "TupleGet only operates on tuples"
    assert index &gt;= 0
    self.type = src.type.types[index]
    self.is_borrowed = borrow
</t>
<t tx="ekr.20240308084832.782">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.783">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_tuple_get(self)
</t>
<t tx="ekr.20240308084832.784">class Cast(RegisterOp):
    """cast(type, src)
    
    Perform a runtime type check (no representation or value conversion).
    
    DO NOT increment reference counts.
    """
    @others
</t>
<t tx="ekr.20240308084832.785">error_kind = ERR_MAGIC

def __init__(self, src: Value, typ: RType, line: int, *, borrow: bool = False) -&gt; None:
    super().__init__(line)
    self.src = src
    self.type = typ
    self.is_borrowed = borrow
</t>
<t tx="ekr.20240308084832.786">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.787">def stolen(self) -&gt; list[Value]:
    if self.is_borrowed:
        return []
    return [self.src]
</t>
<t tx="ekr.20240308084832.788">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_cast(self)
</t>
<t tx="ekr.20240308084832.789">class Box(RegisterOp):
    """box(type, src)
    
    This converts from a potentially unboxed representation to a straight Python object.
    Only supported for types with an unboxed representation.
    """
    @others
</t>
<t tx="ekr.20240308084832.79">def __init__(self, right: RType) -&gt; None:
    self.right = right
</t>
<t tx="ekr.20240308084832.790">error_kind = ERR_NEVER

def __init__(self, src: Value, line: int = -1) -&gt; None:
    super().__init__(line)
    self.src = src
    self.type = object_rprimitive
    # When we box None and bool values, we produce a borrowed result
    if (
        is_none_rprimitive(self.src.type)
        or is_bool_rprimitive(self.src.type)
        or is_bit_rprimitive(self.src.type)
    ):
        self.is_borrowed = True
</t>
<t tx="ekr.20240308084832.791">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.792">def stolen(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.793">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_box(self)
</t>
<t tx="ekr.20240308084832.794">class Unbox(RegisterOp):
    """unbox(type, src)
    
    This is similar to a cast, but it also changes to a (potentially) unboxed runtime
    representation. Only supported for types with an unboxed representation.
    """
    @others
</t>
<t tx="ekr.20240308084832.795">def __init__(self, src: Value, typ: RType, line: int) -&gt; None:
    self.src = src
    self.type = typ
    if not typ.error_overlap:
        self.error_kind = ERR_MAGIC
    else:
        self.error_kind = ERR_MAGIC_OVERLAPPING
    super().__init__(line)
</t>
<t tx="ekr.20240308084832.796">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.797">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_unbox(self)
</t>
<t tx="ekr.20240308084832.798">class RaiseStandardError(RegisterOp):
    """Raise built-in exception with an optional error string.
    
    We have a separate opcode for this for convenience and to
    generate smaller, more idiomatic C code.
    """
    @others
</t>
<t tx="ekr.20240308084832.799"># TODO: Make it more explicit at IR level that this always raises

error_kind = ERR_FALSE

VALUE_ERROR: Final = "ValueError"
ASSERTION_ERROR: Final = "AssertionError"
STOP_ITERATION: Final = "StopIteration"
UNBOUND_LOCAL_ERROR: Final = "UnboundLocalError"
RUNTIME_ERROR: Final = "RuntimeError"
NAME_ERROR: Final = "NameError"
ZERO_DIVISION_ERROR: Final = "ZeroDivisionError"

def __init__(self, class_name: str, value: str | Value | None, line: int) -&gt; None:
    super().__init__(line)
    self.class_name = class_name
    self.value = value
    self.type = bool_rprimitive
</t>
<t tx="ekr.20240308084832.8">def setup_mypycify_vars() -&gt; None:
    """Rewrite a bunch of config vars in pretty dubious ways."""
    # There has to be a better approach to this.

    # The vars can contain ints but we only work with str ones
    vars = cast(Dict[str, str], sysconfig.get_config_vars())
    if sys.platform == "darwin":
        # Disable building 32-bit binaries, since we generate too much code
        # for a 32-bit Mach-O object. There has to be a better way to do this.
        vars["LDSHARED"] = vars["LDSHARED"].replace("-arch i386", "")
        vars["LDFLAGS"] = vars["LDFLAGS"].replace("-arch i386", "")
        vars["CFLAGS"] = vars["CFLAGS"].replace("-arch i386", "")
</t>
<t tx="ekr.20240308084832.80">def visit_rinstance(self, left: RInstance) -&gt; bool:
    return isinstance(self.right, RInstance) and self.right.class_ir in left.class_ir.mro
</t>
<t tx="ekr.20240308084832.800">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.801">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_raise_standard_error(self)
</t>
<t tx="ekr.20240308084832.802"># True steals all arguments, False steals none, a list steals those in matching positions
StealsDescription = Union[bool, List[bool]]


class CallC(RegisterOp):
    """result = function(arg0, arg1, ...)
    
    Call a C function that is not a compiled/native function (for
    example, a Python C API function). Use Call to call native
    functions.
    """
    @others
</t>
<t tx="ekr.20240308084832.803">def __init__(
    self,
    function_name: str,
    args: list[Value],
    ret_type: RType,
    steals: StealsDescription,
    is_borrowed: bool,
    error_kind: int,
    line: int,
    var_arg_idx: int = -1,
) -&gt; None:
    self.error_kind = error_kind
    super().__init__(line)
    self.function_name = function_name
    self.args = args
    self.type = ret_type
    self.steals = steals
    self.is_borrowed = is_borrowed
    # The position of the first variable argument in args (if &gt;= 0)
    self.var_arg_idx = var_arg_idx
</t>
<t tx="ekr.20240308084832.804">def sources(self) -&gt; list[Value]:
    return self.args
</t>
<t tx="ekr.20240308084832.805">def stolen(self) -&gt; list[Value]:
    if isinstance(self.steals, list):
        assert len(self.steals) == len(self.args)
        return [arg for arg, steal in zip(self.args, self.steals) if steal]
    else:
        return [] if not self.steals else self.sources()
</t>
<t tx="ekr.20240308084832.806">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_call_c(self)
</t>
<t tx="ekr.20240308084832.807">class Truncate(RegisterOp):
    """result = truncate src from src_type to dst_type
    
    Truncate a value from type with more bits to type with less bits.
    
    dst_type and src_type can be native integer types, bools or tagged
    integers. Tagged integers should have the tag bit unset.
    """
    @others
</t>
<t tx="ekr.20240308084832.808">error_kind = ERR_NEVER

def __init__(self, src: Value, dst_type: RType, line: int = -1) -&gt; None:
    super().__init__(line)
    self.src = src
    self.type = dst_type
    self.src_type = src.type
</t>
<t tx="ekr.20240308084832.809">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.81">def visit_runion(self, left: RUnion) -&gt; bool:
    return all(is_subtype(item, self.right) for item in left.items)
</t>
<t tx="ekr.20240308084832.810">def stolen(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.811">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_truncate(self)
</t>
<t tx="ekr.20240308084832.812">class Extend(RegisterOp):
    """result = extend src from src_type to dst_type
    
    Extend a value from a type with fewer bits to a type with more bits.
    
    dst_type and src_type can be native integer types, bools or tagged
    integers. Tagged integers should have the tag bit unset.
    
    If 'signed' is true, perform sign extension. Otherwise, the result will be
    zero extended.
    """
    @others
</t>
<t tx="ekr.20240308084832.813">error_kind = ERR_NEVER

def __init__(self, src: Value, dst_type: RType, signed: bool, line: int = -1) -&gt; None:
    super().__init__(line)
    self.src = src
    self.type = dst_type
    self.src_type = src.type
    self.signed = signed
</t>
<t tx="ekr.20240308084832.814">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.815">def stolen(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.816">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_extend(self)
</t>
<t tx="ekr.20240308084832.817">class LoadGlobal(RegisterOp):
    """Load a low-level global variable/pointer.
    
    Note that can't be used to directly load Python module-level
    global variable, since they are stored in a globals dictionary
    and accessed using dictionary operations.
    """
    @others
</t>
<t tx="ekr.20240308084832.818">error_kind = ERR_NEVER
is_borrowed = True

def __init__(self, type: RType, identifier: str, line: int = -1, ann: object = None) -&gt; None:
    super().__init__(line)
    self.identifier = identifier
    self.type = type
    self.ann = ann  # An object to pretty print with the load
</t>
<t tx="ekr.20240308084832.819">def sources(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.82">def visit_rprimitive(self, left: RPrimitive) -&gt; bool:
    right = self.right
    if is_bool_rprimitive(left):
        if is_tagged(right) or is_fixed_width_rtype(right):
            return True
    elif is_bit_rprimitive(left):
        if is_bool_rprimitive(right) or is_tagged(right) or is_fixed_width_rtype(right):
            return True
    elif is_short_int_rprimitive(left):
        if is_int_rprimitive(right):
            return True
    elif is_fixed_width_rtype(left):
        if is_int_rprimitive(right):
            return True
    return left is right
</t>
<t tx="ekr.20240308084832.820">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_global(self)
</t>
<t tx="ekr.20240308084832.821">class IntOp(RegisterOp):
    """Binary arithmetic or bitwise op on integer operands (e.g., r1 = r2 + r3).
    
    These ops are low-level and are similar to the corresponding C
    operations.
    
    The left and right values must have low-level integer types with
    compatible representations. Fixed-width integers, short_int_rprimitive,
    bool_rprimitive and bit_rprimitive are supported.
    
    For tagged (arbitrary-precision) integer ops look at mypyc.primitives.int_ops.
    """
    @others
</t>
<t tx="ekr.20240308084832.822">error_kind = ERR_NEVER

# Arithmetic ops
ADD: Final = 0
SUB: Final = 1
MUL: Final = 2
DIV: Final = 3
MOD: Final = 4

# Bitwise ops
AND: Final = 200
OR: Final = 201
XOR: Final = 202
LEFT_SHIFT: Final = 203
RIGHT_SHIFT: Final = 204

op_str: Final = {
    ADD: "+",
    SUB: "-",
    MUL: "*",
    DIV: "/",
    MOD: "%",
    AND: "&amp;",
    OR: "|",
    XOR: "^",
    LEFT_SHIFT: "&lt;&lt;",
    RIGHT_SHIFT: "&gt;&gt;",
}

def __init__(self, type: RType, lhs: Value, rhs: Value, op: int, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = type
    self.lhs = lhs
    self.rhs = rhs
    self.op = op
</t>
<t tx="ekr.20240308084832.823">def sources(self) -&gt; list[Value]:
    return [self.lhs, self.rhs]
</t>
<t tx="ekr.20240308084832.824">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_int_op(self)
</t>
<t tx="ekr.20240308084832.825"># We can't have this in the IntOp class body, because of
# https://github.com/issues/932.
int_op_to_id: Final = {op: op_id for op_id, op in IntOp.op_str.items()}


class ComparisonOp(RegisterOp):
    """Low-level comparison op for integers and pointers.
    
    Both unsigned and signed comparisons are supported. Supports
    comparisons between fixed-width integer types and pointer types.
    The operands should have matching sizes.
    
    The result is always a bit (representing a boolean).
    
    Python semantics, such as calling __eq__, are not supported.
    """
    @others
</t>
<t tx="ekr.20240308084832.826"># Must be ERR_NEVER or ERR_FALSE. ERR_FALSE means that a false result
# indicates that an exception has been raised and should be propagated.
error_kind = ERR_NEVER

# S for signed and U for unsigned
EQ: Final = 100
NEQ: Final = 101
SLT: Final = 102
SGT: Final = 103
SLE: Final = 104
SGE: Final = 105
ULT: Final = 106
UGT: Final = 107
ULE: Final = 108
UGE: Final = 109

op_str: Final = {
    EQ: "==",
    NEQ: "!=",
    SLT: "&lt;",
    SGT: "&gt;",
    SLE: "&lt;=",
    SGE: "&gt;=",
    ULT: "&lt;",
    UGT: "&gt;",
    ULE: "&lt;=",
    UGE: "&gt;=",
}

signed_ops: Final = {"==": EQ, "!=": NEQ, "&lt;": SLT, "&gt;": SGT, "&lt;=": SLE, "&gt;=": SGE}
unsigned_ops: Final = {"==": EQ, "!=": NEQ, "&lt;": ULT, "&gt;": UGT, "&lt;=": ULE, "&gt;=": UGE}

def __init__(self, lhs: Value, rhs: Value, op: int, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = bit_rprimitive
    self.lhs = lhs
    self.rhs = rhs
    self.op = op
</t>
<t tx="ekr.20240308084832.827">def sources(self) -&gt; list[Value]:
    return [self.lhs, self.rhs]
</t>
<t tx="ekr.20240308084832.828">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_comparison_op(self)
</t>
<t tx="ekr.20240308084832.829">class FloatOp(RegisterOp):
    """Binary float arithmetic op (e.g., r1 = r2 + r3).
    
    These ops are low-level and are similar to the corresponding C
    operations (and somewhat different from Python operations).
    
    The left and right values must be floats.
    """
    @others
</t>
<t tx="ekr.20240308084832.83">def visit_rtuple(self, left: RTuple) -&gt; bool:
    if is_tuple_rprimitive(self.right):
        return True
    if isinstance(self.right, RTuple):
        return len(self.right.types) == len(left.types) and all(
            is_subtype(t1, t2) for t1, t2 in zip(left.types, self.right.types)
        )
    return False
</t>
<t tx="ekr.20240308084832.830">error_kind = ERR_NEVER

ADD: Final = 0
SUB: Final = 1
MUL: Final = 2
DIV: Final = 3
MOD: Final = 4

op_str: Final = {ADD: "+", SUB: "-", MUL: "*", DIV: "/", MOD: "%"}

def __init__(self, lhs: Value, rhs: Value, op: int, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = float_rprimitive
    self.lhs = lhs
    self.rhs = rhs
    self.op = op
</t>
<t tx="ekr.20240308084832.831">def sources(self) -&gt; list[Value]:
    return [self.lhs, self.rhs]
</t>
<t tx="ekr.20240308084832.832">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_float_op(self)
</t>
<t tx="ekr.20240308084832.833"># We can't have this in the FloatOp class body, because of
# https://github.com/issues/932.
float_op_to_id: Final = {op: op_id for op_id, op in FloatOp.op_str.items()}


class FloatNeg(RegisterOp):
    """Float negation op (r1 = -r2)."""
    @others
</t>
<t tx="ekr.20240308084832.834">error_kind = ERR_NEVER

def __init__(self, src: Value, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = float_rprimitive
    self.src = src
</t>
<t tx="ekr.20240308084832.835">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.836">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_float_neg(self)
</t>
<t tx="ekr.20240308084832.837">class FloatComparisonOp(RegisterOp):
    """Low-level comparison op for floats."""
    @others
</t>
<t tx="ekr.20240308084832.838">error_kind = ERR_NEVER

EQ: Final = 200
NEQ: Final = 201
LT: Final = 202
GT: Final = 203
LE: Final = 204
GE: Final = 205

op_str: Final = {EQ: "==", NEQ: "!=", LT: "&lt;", GT: "&gt;", LE: "&lt;=", GE: "&gt;="}

def __init__(self, lhs: Value, rhs: Value, op: int, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = bit_rprimitive
    self.lhs = lhs
    self.rhs = rhs
    self.op = op
</t>
<t tx="ekr.20240308084832.839">def sources(self) -&gt; list[Value]:
    return [self.lhs, self.rhs]
</t>
<t tx="ekr.20240308084832.84">def visit_rstruct(self, left: RStruct) -&gt; bool:
    return isinstance(self.right, RStruct) and self.right.name == left.name
</t>
<t tx="ekr.20240308084832.840">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_float_comparison_op(self)
</t>
<t tx="ekr.20240308084832.841"># We can't have this in the FloatOp class body, because of
# https://github.com/issues/932.
float_comparison_op_to_id: Final = {op: op_id for op_id, op in FloatComparisonOp.op_str.items()}


class LoadMem(RegisterOp):
    """Read a memory location: result = *(type *)src.
    
    Attributes:
      type: Type of the read value
      src: Pointer to memory to read
    """
    @others
</t>
<t tx="ekr.20240308084832.842">error_kind = ERR_NEVER

def __init__(self, type: RType, src: Value, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = type
    # TODO: for now we enforce that the src memory address should be Py_ssize_t
    #       later we should also support same width unsigned int
    assert is_pointer_rprimitive(src.type)
    self.src = src
    self.is_borrowed = True
</t>
<t tx="ekr.20240308084832.843">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.844">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_mem(self)
</t>
<t tx="ekr.20240308084832.845">class SetMem(Op):
    """Write to a memory location: *(type *)dest = src
    
    Attributes:
      type: Type of the written value
      dest: Pointer to memory to write
      src: Source value
    """
    @others
</t>
<t tx="ekr.20240308084832.846">error_kind = ERR_NEVER

def __init__(self, type: RType, dest: Value, src: Value, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = void_rtype
    self.dest_type = type
    self.src = src
    self.dest = dest
</t>
<t tx="ekr.20240308084832.847">def sources(self) -&gt; list[Value]:
    return [self.src, self.dest]
</t>
<t tx="ekr.20240308084832.848">def stolen(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.849">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_set_mem(self)
</t>
<t tx="ekr.20240308084832.85">def visit_rarray(self, left: RArray) -&gt; bool:
    return left == self.right
</t>
<t tx="ekr.20240308084832.850">class GetElementPtr(RegisterOp):
    """Get the address of a struct element.
    
    Note that you may need to use KeepAlive to avoid the struct
    being freed, if it's reference counted, such as PyObject *.
    """
    @others
</t>
<t tx="ekr.20240308084832.851">error_kind = ERR_NEVER

def __init__(self, src: Value, src_type: RType, field: str, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = pointer_rprimitive
    self.src = src
    self.src_type = src_type
    self.field = field
</t>
<t tx="ekr.20240308084832.852">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.853">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_get_element_ptr(self)
</t>
<t tx="ekr.20240308084832.854">class LoadAddress(RegisterOp):
    """Get the address of a value: result = (type)&amp;src
    
    Attributes:
      type: Type of the loaded address(e.g. ptr/object_ptr)
      src: Source value (str for globals like 'PyList_Type',
           Register for temporary values or locals, LoadStatic
           for statics.)
    """
    @others
</t>
<t tx="ekr.20240308084832.855">error_kind = ERR_NEVER
is_borrowed = True

def __init__(self, type: RType, src: str | Register | LoadStatic, line: int = -1) -&gt; None:
    super().__init__(line)
    self.type = type
    self.src = src
</t>
<t tx="ekr.20240308084832.856">def sources(self) -&gt; list[Value]:
    if isinstance(self.src, Register):
        return [self.src]
    else:
        return []
</t>
<t tx="ekr.20240308084832.857">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_load_address(self)
</t>
<t tx="ekr.20240308084832.858">class KeepAlive(RegisterOp):
    """A no-op operation that ensures source values aren't freed.
    
    This is sometimes useful to avoid decref when a reference is still
    being held but not seen by the compiler.
    
    A typical use case is like this (C-like pseudocode):
    
      ptr = &amp;x.item
      r = *ptr
      keep_alive x  # x must not be freed here
      # x may be freed here
    
    If we didn't have "keep_alive x", x could be freed immediately
    after taking the address of 'item', resulting in a read after free
    on the second line.
    
    If 'steal' is true, the value is considered to be stolen at
    this op, i.e. it won't be decref'd. You need to ensure that
    the value is freed otherwise, perhaps by using borrowing
    followed by Unborrow.
    
    Be careful with steal=True -- this can cause memory leaks.
    """
    @others
</t>
<t tx="ekr.20240308084832.859">error_kind = ERR_NEVER

def __init__(self, src: list[Value], *, steal: bool = False) -&gt; None:
    assert src
    self.src = src
    self.steal = steal
</t>
<t tx="ekr.20240308084832.86">def visit_rvoid(self, left: RVoid) -&gt; bool:
    return isinstance(self.right, RVoid)
</t>
<t tx="ekr.20240308084832.860">def sources(self) -&gt; list[Value]:
    return self.src.copy()
</t>
<t tx="ekr.20240308084832.861">def stolen(self) -&gt; list[Value]:
    if self.steal:
        return self.src.copy()
    return []
</t>
<t tx="ekr.20240308084832.862">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_keep_alive(self)
</t>
<t tx="ekr.20240308084832.863">class Unborrow(RegisterOp):
    """A no-op op to create a regular reference from a borrowed one.
    
    Borrowed references can only be used temporarily and the reference
    counts won't be managed. This value will be refcounted normally.
    
    This is mainly useful if you split an aggregate value, such as
    a tuple, into components using borrowed values (to avoid increfs),
    and want to treat the components as sharing the original managed
    reference. You'll also need to use KeepAlive with steal=True to
    "consume" the original tuple reference:
    
      # t is a 2-tuple
      r0 = borrow t[0]
      r1 = borrow t[1]
      r2 = unborrow r0
      r3 = unborrow r1
      # now (r2, r3) represent the tuple as separate items, and the
      # original tuple can be considered dead and available to be
      # stolen
      keep_alive steal t
    
    Be careful with this -- this can easily cause double freeing.
    """
    @others
</t>
<t tx="ekr.20240308084832.864">error_kind = ERR_NEVER

def __init__(self, src: Value) -&gt; None:
    assert src.is_borrowed
    self.src = src
    self.type = src.type
</t>
<t tx="ekr.20240308084832.865">def sources(self) -&gt; list[Value]:
    return [self.src]
</t>
<t tx="ekr.20240308084832.866">def stolen(self) -&gt; list[Value]:
    return []
</t>
<t tx="ekr.20240308084832.867">def accept(self, visitor: OpVisitor[T]) -&gt; T:
    return visitor.visit_unborrow(self)
</t>
<t tx="ekr.20240308084832.868">@trait
class OpVisitor(Generic[T]):
    """Generic visitor over ops (uses the visitor design pattern)."""
    @others
</t>
<t tx="ekr.20240308084832.869">@abstractmethod
def visit_goto(self, op: Goto) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.87"></t>
<t tx="ekr.20240308084832.870">@abstractmethod
def visit_branch(self, op: Branch) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.871">@abstractmethod
def visit_return(self, op: Return) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.872">@abstractmethod
def visit_unreachable(self, op: Unreachable) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.873">@abstractmethod
def visit_assign(self, op: Assign) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.874">@abstractmethod
def visit_assign_multi(self, op: AssignMulti) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.875">@abstractmethod
def visit_load_error_value(self, op: LoadErrorValue) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.876">@abstractmethod
def visit_load_literal(self, op: LoadLiteral) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.877">@abstractmethod
def visit_get_attr(self, op: GetAttr) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.878">@abstractmethod
def visit_set_attr(self, op: SetAttr) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.879">@abstractmethod
def visit_load_static(self, op: LoadStatic) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.88">@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.880">@abstractmethod
def visit_init_static(self, op: InitStatic) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.881">@abstractmethod
def visit_tuple_get(self, op: TupleGet) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.882">@abstractmethod
def visit_tuple_set(self, op: TupleSet) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.883">def visit_inc_ref(self, op: IncRef) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.884">def visit_dec_ref(self, op: DecRef) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.885">@abstractmethod
def visit_call(self, op: Call) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.886">@abstractmethod
def visit_method_call(self, op: MethodCall) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.887">@abstractmethod
def visit_cast(self, op: Cast) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.888">@abstractmethod
def visit_box(self, op: Box) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.889">@abstractmethod
def visit_unbox(self, op: Unbox) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.89">"""Always defined attribute analysis.

An always defined attribute has some statements in __init__ or the
class body that cause the attribute to be always initialized when an
instance is constructed. It must also not be possible to read the
attribute before initialization, and it can't be deletable.

We can assume that the value is always defined when reading an always
defined attribute. Otherwise we'll need to raise AttributeError if the
value is undefined (i.e. has the error value).

We use data flow analysis to figure out attributes that are always
defined. Example:

  class C:
      def __init__(self) -&gt; None:
          self.x = 0
          if func():
              self.y = 1
          else:
              self.y = 2
              self.z = 3

In this example, the attributes 'x' and 'y' are always defined, but 'z'
is not. The analysis assumes that we know that there won't be any subclasses.

The analysis also works if there is a known, closed set of subclasses.
An attribute defined in a base class can only be always defined if it's
also always defined in all subclasses.

As soon as __init__ contains an op that can 'leak' self to another
function, we will stop inferring always defined attributes, since the
analysis is mostly intra-procedural and only looks at __init__ methods.
The called code could read an uninitialized attribute. Example:

  class C:
      def __init__(self) -&gt; None:
          self.x = self.foo()

      def foo(self) -&gt; int:
          ...

Now we won't infer 'x' as always defined, since 'foo' might read 'x'
before initialization.

As an exception to the above limitation, we perform inter-procedural
analysis of super().__init__ calls, since these are very common.

Our analysis is somewhat optimistic. We assume that nobody calls a
method of a partially uninitialized object through gc.get_objects(), in
particular. Code like this could potentially cause a segfault with a null
pointer dereference. This seems very unlikely to be an issue in practice,
however.

Accessing an attribute via getattr always checks for undefined attributes
and thus works if the object is partially uninitialized. This can be used
as a workaround if somebody ever needs to inspect partially uninitialized
objects via gc.get_objects().

The analysis runs after IR building as a separate pass. Since we only
run this on __init__ methods, this analysis pass will be fairly quick.
"""

from __future__ import annotations

from typing import Final, Set, Tuple

from mypyc.analysis.dataflow import (
    CFG,
    MAYBE_ANALYSIS,
    AnalysisResult,
    BaseAnalysisVisitor,
    get_cfg,
    run_analysis,
)
from mypyc.analysis.selfleaks import analyze_self_leaks
from mypyc.ir.class_ir import ClassIR
from mypyc.ir.ops import (
    Assign,
    AssignMulti,
    BasicBlock,
    Branch,
    Call,
    ControlOp,
    GetAttr,
    Register,
    RegisterOp,
    Return,
    SetAttr,
    SetMem,
    Unreachable,
)
from mypyc.ir.rtypes import RInstance

# If True, print out all always-defined attributes of native classes (to aid
# debugging and testing)
dump_always_defined: Final = False


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.890">@abstractmethod
def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.891">@abstractmethod
def visit_call_c(self, op: CallC) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.892">@abstractmethod
def visit_truncate(self, op: Truncate) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.893">@abstractmethod
def visit_extend(self, op: Extend) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.894">@abstractmethod
def visit_load_global(self, op: LoadGlobal) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.895">@abstractmethod
def visit_int_op(self, op: IntOp) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.896">@abstractmethod
def visit_comparison_op(self, op: ComparisonOp) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.897">@abstractmethod
def visit_float_op(self, op: FloatOp) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.898">@abstractmethod
def visit_float_neg(self, op: FloatNeg) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.899">@abstractmethod
def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.9">def fail(message: str) -&gt; NoReturn:
    # TODO: Is there something else we should do to fail?
    sys.exit(message)
</t>
<t tx="ekr.20240308084832.90">def analyze_always_defined_attrs(class_irs: list[ClassIR]) -&gt; None:
    """Find always defined attributes all classes of a compilation unit.

    Also tag attribute initialization ops to not decref the previous
    value (as this would read a NULL pointer and segfault).

    Update the _always_initialized_attrs, _sometimes_initialized_attrs
    and init_self_leak attributes in ClassIR instances.

    This is the main entry point.
    """
    seen: set[ClassIR] = set()

    # First pass: only look at target class and classes in MRO
    for cl in class_irs:
        analyze_always_defined_attrs_in_class(cl, seen)

    # Second pass: look at all derived class
    seen = set()
    for cl in class_irs:
        update_always_defined_attrs_using_subclasses(cl, seen)

    # Final pass: detect attributes that need to use a bitmap to track definedness
    seen = set()
    for cl in class_irs:
        detect_undefined_bitmap(cl, seen)
</t>
<t tx="ekr.20240308084832.900">@abstractmethod
def visit_load_mem(self, op: LoadMem) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.901">@abstractmethod
def visit_set_mem(self, op: SetMem) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.902">@abstractmethod
def visit_get_element_ptr(self, op: GetElementPtr) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.903">@abstractmethod
def visit_load_address(self, op: LoadAddress) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.904">@abstractmethod
def visit_keep_alive(self, op: KeepAlive) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.905">@abstractmethod
def visit_unborrow(self, op: Unborrow) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.906"># TODO: Should the following definition live somewhere else?


# We do a three-pass deserialization scheme in order to resolve name
# references.
#  1. Create an empty ClassIR for each class in an SCC.
#  2. Deserialize all of the functions, which can contain references
#     to ClassIRs in their types
#  3. Deserialize all of the classes, which contain lots of references
#     to the functions they contain. (And to other classes.)
#
# Note that this approach differs from how we deserialize ASTs in mypy itself,
# where everything is deserialized in one pass then a second pass cleans up
# 'cross_refs'. We don't follow that approach here because it seems to be more
# code for not a lot of gain since it is easy in mypyc to identify all the objects
# we might need to reference.
#
# Because of these references, we need to maintain maps from class
# names to ClassIRs and func IDs to FuncIRs.
#
# These are tracked in a DeserMaps which is passed to every
# deserialization function.
#
# (Serialization and deserialization *will* be used for incremental
# compilation but so far it is not hooked up to anything.)
class DeserMaps(NamedTuple):
    classes: dict[str, ClassIR]
    functions: dict[str, FuncIR]
</t>
<t tx="ekr.20240308084832.907">"""Utilities for pretty-printing IR in a human-readable form."""

from __future__ import annotations

from collections import defaultdict
from typing import Any, Final, Sequence, Union

from mypyc.common import short_name
from mypyc.ir.func_ir import FuncIR, all_values_full
from mypyc.ir.module_ir import ModuleIRs
from mypyc.ir.ops import (
    ERR_NEVER,
    Assign,
    AssignMulti,
    BasicBlock,
    Box,
    Branch,
    Call,
    CallC,
    Cast,
    ComparisonOp,
    ControlOp,
    DecRef,
    Extend,
    Float,
    FloatComparisonOp,
    FloatNeg,
    FloatOp,
    GetAttr,
    GetElementPtr,
    Goto,
    IncRef,
    InitStatic,
    Integer,
    IntOp,
    KeepAlive,
    LoadAddress,
    LoadErrorValue,
    LoadGlobal,
    LoadLiteral,
    LoadMem,
    LoadStatic,
    MethodCall,
    Op,
    OpVisitor,
    RaiseStandardError,
    Register,
    Return,
    SetAttr,
    SetMem,
    Truncate,
    TupleGet,
    TupleSet,
    Unborrow,
    Unbox,
    Unreachable,
    Value,
)
from mypyc.ir.rtypes import RType, is_bool_rprimitive, is_int_rprimitive

ErrorSource = Union[BasicBlock, Op]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.908">class IRPrettyPrintVisitor(OpVisitor[str]):
    """Internal visitor that pretty-prints ops."""
    @others
</t>
<t tx="ekr.20240308084832.909">def __init__(self, names: dict[Value, str]) -&gt; None:
    # This should contain a name for all values that are shown as
    # registers in the output. This is not just for Register
    # instances -- all Ops that produce values need (generated) names.
    self.names = names
</t>
<t tx="ekr.20240308084832.91">def analyze_always_defined_attrs_in_class(cl: ClassIR, seen: set[ClassIR]) -&gt; None:
    if cl in seen:
        return

    seen.add(cl)

    if (
        cl.is_trait
        or cl.inherits_python
        or cl.allow_interpreted_subclasses
        or cl.builtin_base is not None
        or cl.children is None
        or cl.is_serializable()
    ):
        # Give up -- we can't enforce that attributes are always defined.
        return

    # First analyze all base classes. Track seen classes to avoid duplicate work.
    for base in cl.mro[1:]:
        analyze_always_defined_attrs_in_class(base, seen)

    m = cl.get_method("__init__")
    if m is None:
        cl._always_initialized_attrs = cl.attrs_with_defaults.copy()
        cl._sometimes_initialized_attrs = cl.attrs_with_defaults.copy()
        return
    self_reg = m.arg_regs[0]
    cfg = get_cfg(m.blocks)
    dirty = analyze_self_leaks(m.blocks, self_reg, cfg)
    maybe_defined = analyze_maybe_defined_attrs_in_init(
        m.blocks, self_reg, cl.attrs_with_defaults, cfg
    )
    all_attrs: set[str] = set()
    for base in cl.mro:
        all_attrs.update(base.attributes)
    maybe_undefined = analyze_maybe_undefined_attrs_in_init(
        m.blocks, self_reg, initial_undefined=all_attrs - cl.attrs_with_defaults, cfg=cfg
    )

    always_defined = find_always_defined_attributes(
        m.blocks, self_reg, all_attrs, maybe_defined, maybe_undefined, dirty
    )
    always_defined = {a for a in always_defined if not cl.is_deletable(a)}

    cl._always_initialized_attrs = always_defined
    if dump_always_defined:
        print(cl.name, sorted(always_defined))
    cl._sometimes_initialized_attrs = find_sometimes_defined_attributes(
        m.blocks, self_reg, maybe_defined, dirty
    )

    mark_attr_initialiation_ops(m.blocks, self_reg, maybe_defined, dirty)

    # Check if __init__ can run unpredictable code (leak 'self').
    any_dirty = False
    for b in m.blocks:
        for i, op in enumerate(b.ops):
            if dirty.after[b, i] and not isinstance(op, Return):
                any_dirty = True
                break
    cl.init_self_leak = any_dirty
</t>
<t tx="ekr.20240308084832.910">def visit_goto(self, op: Goto) -&gt; str:
    return self.format("goto %l", op.label)
</t>
<t tx="ekr.20240308084832.911">branch_op_names: Final = {Branch.BOOL: ("%r", "bool"), Branch.IS_ERROR: ("is_error(%r)", "")}

def visit_branch(self, op: Branch) -&gt; str:
    fmt, typ = self.branch_op_names[op.op]
    if op.negated:
        fmt = f"not {fmt}"

    cond = self.format(fmt, op.value)
    tb = ""
    if op.traceback_entry:
        tb = " (error at %s:%d)" % op.traceback_entry
    fmt = f"if {cond} goto %l{tb} else goto %l"
    if typ:
        fmt += f" :: {typ}"
    return self.format(fmt, op.true, op.false)
</t>
<t tx="ekr.20240308084832.912">def visit_return(self, op: Return) -&gt; str:
    return self.format("return %r", op.value)
</t>
<t tx="ekr.20240308084832.913">def visit_unreachable(self, op: Unreachable) -&gt; str:
    return "unreachable"
</t>
<t tx="ekr.20240308084832.914">def visit_assign(self, op: Assign) -&gt; str:
    return self.format("%r = %r", op.dest, op.src)
</t>
<t tx="ekr.20240308084832.915">def visit_assign_multi(self, op: AssignMulti) -&gt; str:
    return self.format("%r = [%s]", op.dest, ", ".join(self.format("%r", v) for v in op.src))
</t>
<t tx="ekr.20240308084832.916">def visit_load_error_value(self, op: LoadErrorValue) -&gt; str:
    return self.format("%r = &lt;error&gt; :: %s", op, op.type)
</t>
<t tx="ekr.20240308084832.917">def visit_load_literal(self, op: LoadLiteral) -&gt; str:
    prefix = ""
    # For values that have a potential unboxed representation, make
    # it explicit that this is a Python object.
    if isinstance(op.value, int):
        prefix = "object "

    rvalue = repr(op.value)
    if isinstance(op.value, frozenset):
        # We need to generate a string representation that won't vary
        # run-to-run because sets are unordered, otherwise we may get
        # spurious irbuild test failures.
        #
        # Sorting by the item's string representation is a bit of a
        # hack, but it's stable and won't cause TypeErrors.
        formatted_items = [repr(i) for i in sorted(op.value, key=str)]
        rvalue = "frozenset({" + ", ".join(formatted_items) + "})"
    return self.format("%r = %s%s", op, prefix, rvalue)
</t>
<t tx="ekr.20240308084832.918">def visit_get_attr(self, op: GetAttr) -&gt; str:
    return self.format("%r = %s%r.%s", op, self.borrow_prefix(op), op.obj, op.attr)
</t>
<t tx="ekr.20240308084832.919">def borrow_prefix(self, op: Op) -&gt; str:
    if op.is_borrowed:
        return "borrow "
    return ""
</t>
<t tx="ekr.20240308084832.92">def find_always_defined_attributes(
    blocks: list[BasicBlock],
    self_reg: Register,
    all_attrs: set[str],
    maybe_defined: AnalysisResult[str],
    maybe_undefined: AnalysisResult[str],
    dirty: AnalysisResult[None],
) -&gt; set[str]:
    """Find attributes that are always initialized in some basic blocks.

    The analysis results are expected to be up-to-date for the blocks.

    Return a set of always defined attributes.
    """
    attrs = all_attrs.copy()
    for block in blocks:
        for i, op in enumerate(block.ops):
            # If an attribute we *read* may be undefined, it isn't always defined.
            if isinstance(op, GetAttr) and op.obj is self_reg:
                if op.attr in maybe_undefined.before[block, i]:
                    attrs.discard(op.attr)
            # If an attribute we *set* may be sometimes undefined and
            # sometimes defined, don't consider it always defined. Unlike
            # the get case, it's fine for the attribute to be undefined.
            # The set operation will then be treated as initialization.
            if isinstance(op, SetAttr) and op.obj is self_reg:
                if (
                    op.attr in maybe_undefined.before[block, i]
                    and op.attr in maybe_defined.before[block, i]
                ):
                    attrs.discard(op.attr)
            # Treat an op that might run arbitrary code as an "exit"
            # in terms of the analysis -- we can't do any inference
            # afterwards reliably.
            if dirty.after[block, i]:
                if not dirty.before[block, i]:
                    attrs = attrs &amp; (
                        maybe_defined.after[block, i] - maybe_undefined.after[block, i]
                    )
                break
            if isinstance(op, ControlOp):
                for target in op.targets():
                    # Gotos/branches can also be "exits".
                    if not dirty.after[block, i] and dirty.before[target, 0]:
                        attrs = attrs &amp; (
                            maybe_defined.after[target, 0] - maybe_undefined.after[target, 0]
                        )
    return attrs
</t>
<t tx="ekr.20240308084832.920">def visit_set_attr(self, op: SetAttr) -&gt; str:
    if op.is_init:
        assert op.error_kind == ERR_NEVER
    if op.error_kind == ERR_NEVER:
        # Initialization and direct struct access can never fail
        return self.format("%r.%s = %r", op.obj, op.attr, op.src)
    else:
        return self.format("%r.%s = %r; %r = is_error", op.obj, op.attr, op.src, op)
</t>
<t tx="ekr.20240308084832.921">def visit_load_static(self, op: LoadStatic) -&gt; str:
    ann = f"  ({repr(op.ann)})" if op.ann else ""
    name = op.identifier
    if op.module_name is not None:
        name = f"{op.module_name}.{name}"
    return self.format("%r = %s :: %s%s", op, name, op.namespace, ann)
</t>
<t tx="ekr.20240308084832.922">def visit_init_static(self, op: InitStatic) -&gt; str:
    name = op.identifier
    if op.module_name is not None:
        name = f"{op.module_name}.{name}"
    return self.format("%s = %r :: %s", name, op.value, op.namespace)
</t>
<t tx="ekr.20240308084832.923">def visit_tuple_get(self, op: TupleGet) -&gt; str:
    return self.format("%r = %s%r[%d]", op, self.borrow_prefix(op), op.src, op.index)
</t>
<t tx="ekr.20240308084832.924">def visit_tuple_set(self, op: TupleSet) -&gt; str:
    item_str = ", ".join(self.format("%r", item) for item in op.items)
    return self.format("%r = (%s)", op, item_str)
</t>
<t tx="ekr.20240308084832.925">def visit_inc_ref(self, op: IncRef) -&gt; str:
    s = self.format("inc_ref %r", op.src)
    # TODO: Remove bool check (it's unboxed)
    if is_bool_rprimitive(op.src.type) or is_int_rprimitive(op.src.type):
        s += f" :: {short_name(op.src.type.name)}"
    return s
</t>
<t tx="ekr.20240308084832.926">def visit_dec_ref(self, op: DecRef) -&gt; str:
    s = self.format("%sdec_ref %r", "x" if op.is_xdec else "", op.src)
    # TODO: Remove bool check (it's unboxed)
    if is_bool_rprimitive(op.src.type) or is_int_rprimitive(op.src.type):
        s += f" :: {short_name(op.src.type.name)}"
    return s
</t>
<t tx="ekr.20240308084832.927">def visit_call(self, op: Call) -&gt; str:
    args = ", ".join(self.format("%r", arg) for arg in op.args)
    # TODO: Display long name?
    short_name = op.fn.shortname
    s = f"{short_name}({args})"
    if not op.is_void:
        s = self.format("%r = ", op) + s
    return s
</t>
<t tx="ekr.20240308084832.928">def visit_method_call(self, op: MethodCall) -&gt; str:
    args = ", ".join(self.format("%r", arg) for arg in op.args)
    s = self.format("%r.%s(%s)", op.obj, op.method, args)
    if not op.is_void:
        s = self.format("%r = ", op) + s
    return s
</t>
<t tx="ekr.20240308084832.929">def visit_cast(self, op: Cast) -&gt; str:
    return self.format("%r = %scast(%s, %r)", op, self.borrow_prefix(op), op.type, op.src)
</t>
<t tx="ekr.20240308084832.93">def find_sometimes_defined_attributes(
    blocks: list[BasicBlock],
    self_reg: Register,
    maybe_defined: AnalysisResult[str],
    dirty: AnalysisResult[None],
) -&gt; set[str]:
    """Find attributes that are sometimes initialized in some basic blocks."""
    attrs: set[str] = set()
    for block in blocks:
        for i, op in enumerate(block.ops):
            # Only look at possibly defined attributes at exits.
            if dirty.after[block, i]:
                if not dirty.before[block, i]:
                    attrs = attrs | maybe_defined.after[block, i]
                break
            if isinstance(op, ControlOp):
                for target in op.targets():
                    if not dirty.after[block, i] and dirty.before[target, 0]:
                        attrs = attrs | maybe_defined.after[target, 0]
    return attrs
</t>
<t tx="ekr.20240308084832.930">def visit_box(self, op: Box) -&gt; str:
    return self.format("%r = box(%s, %r)", op, op.src.type, op.src)
</t>
<t tx="ekr.20240308084832.931">def visit_unbox(self, op: Unbox) -&gt; str:
    return self.format("%r = unbox(%s, %r)", op, op.type, op.src)
</t>
<t tx="ekr.20240308084832.932">def visit_raise_standard_error(self, op: RaiseStandardError) -&gt; str:
    if op.value is not None:
        if isinstance(op.value, str):
            return self.format("%r = raise %s(%s)", op, op.class_name, repr(op.value))
        elif isinstance(op.value, Value):
            return self.format("%r = raise %s(%r)", op, op.class_name, op.value)
        else:
            assert False, "value type must be either str or Value"
    else:
        return self.format("%r = raise %s", op, op.class_name)
</t>
<t tx="ekr.20240308084832.933">def visit_call_c(self, op: CallC) -&gt; str:
    args_str = ", ".join(self.format("%r", arg) for arg in op.args)
    if op.is_void:
        return self.format("%s(%s)", op.function_name, args_str)
    else:
        return self.format("%r = %s(%s)", op, op.function_name, args_str)
</t>
<t tx="ekr.20240308084832.934">def visit_truncate(self, op: Truncate) -&gt; str:
    return self.format("%r = truncate %r: %t to %t", op, op.src, op.src_type, op.type)
</t>
<t tx="ekr.20240308084832.935">def visit_extend(self, op: Extend) -&gt; str:
    if op.signed:
        extra = " signed"
    else:
        extra = ""
    return self.format("%r = extend%s %r: %t to %t", op, extra, op.src, op.src_type, op.type)
</t>
<t tx="ekr.20240308084832.936">def visit_load_global(self, op: LoadGlobal) -&gt; str:
    ann = f"  ({repr(op.ann)})" if op.ann else ""
    return self.format("%r = load_global %s :: static%s", op, op.identifier, ann)
</t>
<t tx="ekr.20240308084832.937">def visit_int_op(self, op: IntOp) -&gt; str:
    return self.format("%r = %r %s %r", op, op.lhs, IntOp.op_str[op.op], op.rhs)
</t>
<t tx="ekr.20240308084832.938">def visit_comparison_op(self, op: ComparisonOp) -&gt; str:
    if op.op in (ComparisonOp.SLT, ComparisonOp.SGT, ComparisonOp.SLE, ComparisonOp.SGE):
        sign_format = " :: signed"
    elif op.op in (ComparisonOp.ULT, ComparisonOp.UGT, ComparisonOp.ULE, ComparisonOp.UGE):
        sign_format = " :: unsigned"
    else:
        sign_format = ""
    return self.format(
        "%r = %r %s %r%s", op, op.lhs, ComparisonOp.op_str[op.op], op.rhs, sign_format
    )
</t>
<t tx="ekr.20240308084832.939">def visit_float_op(self, op: FloatOp) -&gt; str:
    return self.format("%r = %r %s %r", op, op.lhs, FloatOp.op_str[op.op], op.rhs)
</t>
<t tx="ekr.20240308084832.94">def mark_attr_initialiation_ops(
    blocks: list[BasicBlock],
    self_reg: Register,
    maybe_defined: AnalysisResult[str],
    dirty: AnalysisResult[None],
) -&gt; None:
    """Tag all SetAttr ops in the basic blocks that initialize attributes.

    Initialization ops assume that the previous attribute value is the error value,
    so there's no need to decref or check for definedness.
    """
    for block in blocks:
        for i, op in enumerate(block.ops):
            if isinstance(op, SetAttr) and op.obj is self_reg:
                attr = op.attr
                if attr not in maybe_defined.before[block, i] and not dirty.after[block, i]:
                    op.mark_as_initializer()
</t>
<t tx="ekr.20240308084832.940">def visit_float_neg(self, op: FloatNeg) -&gt; str:
    return self.format("%r = -%r", op, op.src)
</t>
<t tx="ekr.20240308084832.941">def visit_float_comparison_op(self, op: FloatComparisonOp) -&gt; str:
    return self.format("%r = %r %s %r", op, op.lhs, op.op_str[op.op], op.rhs)
</t>
<t tx="ekr.20240308084832.942">def visit_load_mem(self, op: LoadMem) -&gt; str:
    return self.format("%r = load_mem %r :: %t*", op, op.src, op.type)
</t>
<t tx="ekr.20240308084832.943">def visit_set_mem(self, op: SetMem) -&gt; str:
    return self.format("set_mem %r, %r :: %t*", op.dest, op.src, op.dest_type)
</t>
<t tx="ekr.20240308084832.944">def visit_get_element_ptr(self, op: GetElementPtr) -&gt; str:
    return self.format("%r = get_element_ptr %r %s :: %t", op, op.src, op.field, op.src_type)
</t>
<t tx="ekr.20240308084832.945">def visit_load_address(self, op: LoadAddress) -&gt; str:
    if isinstance(op.src, Register):
        return self.format("%r = load_address %r", op, op.src)
    elif isinstance(op.src, LoadStatic):
        name = op.src.identifier
        if op.src.module_name is not None:
            name = f"{op.src.module_name}.{name}"
        return self.format("%r = load_address %s :: %s", op, name, op.src.namespace)
    else:
        return self.format("%r = load_address %s", op, op.src)
</t>
<t tx="ekr.20240308084832.946">def visit_keep_alive(self, op: KeepAlive) -&gt; str:
    if op.steal:
        steal = "steal "
    else:
        steal = ""
    return self.format(
        "keep_alive {}{}".format(steal, ", ".join(self.format("%r", v) for v in op.src))
    )
</t>
<t tx="ekr.20240308084832.947">def visit_unborrow(self, op: Unborrow) -&gt; str:
    return self.format("%r = unborrow %r", op, op.src)
</t>
<t tx="ekr.20240308084832.948"># Helpers

def format(self, fmt: str, *args: Any) -&gt; str:
    """Helper for formatting strings.

    These format sequences are supported in fmt:

      %s: arbitrary object converted to string using str()
      %r: name of IR value/register
      %d: int
      %f: float
      %l: BasicBlock (formatted as label 'Ln')
      %t: RType
    """
    result = []
    i = 0
    arglist = list(args)
    while i &lt; len(fmt):
        n = fmt.find("%", i)
        if n &lt; 0:
            n = len(fmt)
        result.append(fmt[i:n])
        if n &lt; len(fmt):
            typespec = fmt[n + 1]
            arg = arglist.pop(0)
            if typespec == "r":
                # Register/value
                assert isinstance(arg, Value)
                if isinstance(arg, Integer):
                    result.append(str(arg.value))
                elif isinstance(arg, Float):
                    result.append(repr(arg.value))
                else:
                    result.append(self.names[arg])
            elif typespec == "d":
                # Integer
                result.append("%d" % arg)
            elif typespec == "f":
                # Float
                result.append("%f" % arg)
            elif typespec == "l":
                # Basic block (label)
                assert isinstance(arg, BasicBlock)
                result.append("L%s" % arg.label)
            elif typespec == "t":
                # RType
                assert isinstance(arg, RType)
                result.append(arg.name)
            elif typespec == "s":
                # String
                result.append(str(arg))
            else:
                raise ValueError(f"Invalid format sequence %{typespec}")
            i = n + 2
        else:
            i = n
    return "".join(result)
</t>
<t tx="ekr.20240308084832.949">def format_registers(func_ir: FuncIR, names: dict[Value, str]) -&gt; list[str]:
    result = []
    i = 0
    regs = all_values_full(func_ir.arg_regs, func_ir.blocks)
    while i &lt; len(regs):
        i0 = i
        group = [names[regs[i0]]]
        while i + 1 &lt; len(regs) and regs[i + 1].type == regs[i0].type:
            i += 1
            group.append(names[regs[i]])
        i += 1
        result.append("{} :: {}".format(", ".join(group), regs[i0].type))
    return result
</t>
<t tx="ekr.20240308084832.95">GenAndKill = Tuple[Set[str], Set[str]]


def attributes_initialized_by_init_call(op: Call) -&gt; set[str]:
    """Calculate attributes that are always initialized by a super().__init__ call."""
    self_type = op.fn.sig.args[0].type
    assert isinstance(self_type, RInstance)
    cl = self_type.class_ir
    return {a for base in cl.mro for a in base.attributes if base.is_always_defined(a)}
</t>
<t tx="ekr.20240308084832.950">def format_blocks(
    blocks: list[BasicBlock],
    names: dict[Value, str],
    source_to_error: dict[ErrorSource, list[str]],
) -&gt; list[str]:
    """Format a list of IR basic blocks into a human-readable form."""
    # First label all of the blocks
    for i, block in enumerate(blocks):
        block.label = i

    handler_map: dict[BasicBlock, list[BasicBlock]] = {}
    for b in blocks:
        if b.error_handler:
            handler_map.setdefault(b.error_handler, []).append(b)

    visitor = IRPrettyPrintVisitor(names)

    lines = []
    for i, block in enumerate(blocks):
        handler_msg = ""
        if block in handler_map:
            labels = sorted("L%d" % b.label for b in handler_map[block])
            handler_msg = " (handler for {})".format(", ".join(labels))

        lines.append("L%d:%s" % (block.label, handler_msg))
        if block in source_to_error:
            for error in source_to_error[block]:
                lines.append(f"  ERR: {error}")
        ops = block.ops
        if (
            isinstance(ops[-1], Goto)
            and i + 1 &lt; len(blocks)
            and ops[-1].label == blocks[i + 1]
            and not source_to_error.get(ops[-1], [])
        ):
            # Hide the last goto if it just goes to the next basic block,
            # and there are no assocatiated errors with the op.
            ops = ops[:-1]
        for op in ops:
            line = "    " + op.accept(visitor)
            lines.append(line)
            if op in source_to_error:
                for error in source_to_error[op]:
                    lines.append(f"  ERR: {error}")

        if not isinstance(block.ops[-1], (Goto, Branch, Return, Unreachable)):
            # Each basic block needs to exit somewhere.
            lines.append("    [MISSING BLOCK EXIT OPCODE]")
    return lines
</t>
<t tx="ekr.20240308084832.951">def format_func(fn: FuncIR, errors: Sequence[tuple[ErrorSource, str]] = ()) -&gt; list[str]:
    lines = []
    cls_prefix = fn.class_name + "." if fn.class_name else ""
    lines.append(
        "def {}{}({}):".format(cls_prefix, fn.name, ", ".join(arg.name for arg in fn.args))
    )
    names = generate_names_for_ir(fn.arg_regs, fn.blocks)
    for line in format_registers(fn, names):
        lines.append("    " + line)

    source_to_error = defaultdict(list)
    for source, error in errors:
        source_to_error[source].append(error)

    code = format_blocks(fn.blocks, names, source_to_error)
    lines.extend(code)
    return lines
</t>
<t tx="ekr.20240308084832.952">def format_modules(modules: ModuleIRs) -&gt; list[str]:
    ops = []
    for module in modules.values():
        for fn in module.functions:
            ops.extend(format_func(fn))
            ops.append("")
    return ops
</t>
<t tx="ekr.20240308084832.953">def generate_names_for_ir(args: list[Register], blocks: list[BasicBlock]) -&gt; dict[Value, str]:
    """Generate unique names for IR values.

    Give names such as 'r5' to temp values in IR which are useful when
    pretty-printing or generating C. Ensure generated names are unique.
    """
    names: dict[Value, str] = {}
    used_names = set()

    temp_index = 0

    for arg in args:
        names[arg] = arg.name
        used_names.add(arg.name)

    for block in blocks:
        for op in block.ops:
            values = []

            for source in op.sources():
                if source not in names:
                    values.append(source)

            if isinstance(op, (Assign, AssignMulti)):
                values.append(op.dest)
            elif isinstance(op, ControlOp) or op.is_void:
                continue
            elif op not in names:
                values.append(op)

            for value in values:
                if value in names:
                    continue
                if isinstance(value, Register) and value.name:
                    name = value.name
                elif isinstance(value, (Integer, Float)):
                    continue
                else:
                    name = "r%d" % temp_index
                    temp_index += 1

                # Append _2, _3, ... if needed to make the name unique.
                if name in used_names:
                    n = 2
                    while True:
                        candidate = "%s_%d" % (name, n)
                        if candidate not in used_names:
                            name = candidate
                            break
                        n += 1

                names[value] = name
                used_names.add(name)

    return names
</t>
<t tx="ekr.20240308084832.954">"""Types used in the intermediate representation.

These are runtime types (RTypes), as opposed to mypy Type objects.
The latter are only used during type checking and not directly used at
runtime.  Runtime types are derived from mypy types, but there's no
simple one-to-one correspondence. (Here 'runtime' means 'runtime
checked'.)

The generated IR ensures some runtime type safety properties based on
RTypes. Compiled code can assume that the runtime value matches the
static RType of a value. If the RType of a register is 'builtins.str'
(str_rprimitive), for example, the generated IR will ensure that the
register will have a 'str' object.

RTypes are simpler and less expressive than mypy (or PEP 484)
types. For example, all mypy types of form 'list[T]' (for arbitrary T)
are erased to the single RType 'builtins.list' (list_rprimitive).

mypyc.irbuild.mapper.Mapper.type_to_rtype converts mypy Types to mypyc
RTypes.
"""

from __future__ import annotations

from abc import abstractmethod
from typing import TYPE_CHECKING, ClassVar, Final, Generic, TypeVar
from typing_extensions import TypeGuard

from mypyc.common import IS_32_BIT_PLATFORM, PLATFORM_SIZE, JsonDict, short_name
from mypyc.namegen import NameGenerator

if TYPE_CHECKING:
    from mypyc.ir.class_ir import ClassIR
    from mypyc.ir.ops import DeserMaps

T = TypeVar("T")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20240308084832.955">class RType:
    """Abstract base class for runtime types (erased, only concrete; no generics)."""
    @others
</t>
<t tx="ekr.20240308084832.956">name: str
# If True, the type has a special unboxed representation. If False, the
# type is represented as PyObject *. Even if True, the representation
# may contain pointers.
is_unboxed = False
# This is the C undefined value for this type. It's used for initialization
# if there's no value yet, and for function return value on error/exception.
#
# TODO: This shouldn't be specific to C or a string
c_undefined: str
# If unboxed: does the unboxed version use reference counting?
is_refcounted = True
# C type; use Emitter.ctype() to access
_ctype: str
# If True, error/undefined value overlaps with a valid value. To
# detect an exception, PyErr_Occurred() must be used in addition
# to checking for error value as the return value of a function.
#
# For example, no i64 value can be reserved for error value, so we
# pick an arbitrary value (e.g. -113) to signal error, but this is
# also a valid non-error value.
error_overlap = False

@abstractmethod
def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.957">def short_name(self) -&gt; str:
    return short_name(self.name)
</t>
<t tx="ekr.20240308084832.958">def __str__(self) -&gt; str:
    return short_name(self.name)
</t>
<t tx="ekr.20240308084832.959">def __repr__(self) -&gt; str:
    return "&lt;%s&gt;" % self.__class__.__name__
</t>
<t tx="ekr.20240308084832.96">def attributes_maybe_initialized_by_init_call(op: Call) -&gt; set[str]:
    """Calculate attributes that may be initialized by a super().__init__ call."""
    self_type = op.fn.sig.args[0].type
    assert isinstance(self_type, RInstance)
    cl = self_type.class_ir
    return attributes_initialized_by_init_call(op) | cl._sometimes_initialized_attrs
</t>
<t tx="ekr.20240308084832.960">def serialize(self) -&gt; JsonDict | str:
    raise NotImplementedError(f"Cannot serialize {self.__class__.__name__} instance")
</t>
<t tx="ekr.20240308084832.961">def deserialize_type(data: JsonDict | str, ctx: DeserMaps) -&gt; RType:
    """Deserialize a JSON-serialized RType.

    Arguments:
        data: The decoded JSON of the serialized type
        ctx: The deserialization maps to use
    """
    # Since there are so few types, we just case on them directly.  If
    # more get added we should switch to a system like mypy.types
    # uses.
    if isinstance(data, str):
        if data in ctx.classes:
            return RInstance(ctx.classes[data])
        elif data in RPrimitive.primitive_map:
            return RPrimitive.primitive_map[data]
        elif data == "void":
            return RVoid()
        else:
            assert False, f"Can't find class {data}"
    elif data[".class"] == "RTuple":
        return RTuple.deserialize(data, ctx)
    elif data[".class"] == "RUnion":
        return RUnion.deserialize(data, ctx)
    raise NotImplementedError("unexpected .class {}".format(data[".class"]))
</t>
<t tx="ekr.20240308084832.962">class RTypeVisitor(Generic[T]):
    """Generic visitor over RTypes (uses the visitor design pattern)."""
    @others
</t>
<t tx="ekr.20240308084832.963">@abstractmethod
def visit_rprimitive(self, typ: RPrimitive) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.964">@abstractmethod
def visit_rinstance(self, typ: RInstance) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.965">@abstractmethod
def visit_runion(self, typ: RUnion) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.966">@abstractmethod
def visit_rtuple(self, typ: RTuple) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.967">@abstractmethod
def visit_rstruct(self, typ: RStruct) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.968">@abstractmethod
def visit_rarray(self, typ: RArray) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.969">@abstractmethod
def visit_rvoid(self, typ: RVoid) -&gt; T:
    raise NotImplementedError
</t>
<t tx="ekr.20240308084832.97">class AttributeMaybeDefinedVisitor(BaseAnalysisVisitor[str]):
    """Find attributes that may have been defined via some code path.
    
    Consider initializations in class body and assignments to 'self.x'
    and calls to base class '__init__'.
    """
    @others
</t>
<t tx="ekr.20240308084832.970">class RVoid(RType):
    """The void type (no value).
    
    This is a singleton -- use void_rtype (below) to refer to this instead of
    constructing a new instance.
    """
    @others
</t>
<t tx="ekr.20240308084832.971">is_unboxed = False
name = "void"
ctype = "void"

def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rvoid(self)
</t>
<t tx="ekr.20240308084832.972">def serialize(self) -&gt; str:
    return "void"
</t>
<t tx="ekr.20240308084832.973">def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, RVoid)
</t>
<t tx="ekr.20240308084832.974">def __hash__(self) -&gt; int:
    return hash(RVoid)
</t>
<t tx="ekr.20240308084832.975"># Singleton instance of RVoid
void_rtype: Final = RVoid()


class RPrimitive(RType):
    """Primitive type such as 'object' or 'int'.
    
    These often have custom ops associated with them. The 'object'
    primitive type can be used to hold arbitrary Python objects.
    
    Different primitive types have different representations, and
    primitives may be unboxed or boxed. Primitive types don't need to
    directly correspond to Python types, but most do.
    
    NOTE: All supported primitive types are defined below
    (e.g. object_rprimitive).
    """
    @others
</t>
<t tx="ekr.20240308084832.976"># Map from primitive names to primitive types and is used by deserialization
primitive_map: ClassVar[dict[str, RPrimitive]] = {}

def __init__(
    self,
    name: str,
    *,
    is_unboxed: bool,
    is_refcounted: bool,
    is_native_int: bool = False,
    is_signed: bool = False,
    ctype: str = "PyObject *",
    size: int = PLATFORM_SIZE,
    error_overlap: bool = False,
) -&gt; None:
    RPrimitive.primitive_map[name] = self

    self.name = name
    self.is_unboxed = is_unboxed
    self.is_refcounted = is_refcounted
    self.is_native_int = is_native_int
    self.is_signed = is_signed
    self._ctype = ctype
    self.size = size
    self.error_overlap = error_overlap
    if ctype == "CPyTagged":
        self.c_undefined = "CPY_INT_TAG"
    elif ctype in ("int16_t", "int32_t", "int64_t"):
        # This is basically an arbitrary value that is pretty
        # unlikely to overlap with a real value.
        self.c_undefined = "-113"
    elif ctype == "CPyPtr":
        # TODO: Invent an overlapping error value?
        self.c_undefined = "0"
    elif ctype == "PyObject *":
        # Boxed types use the null pointer as the error value.
        self.c_undefined = "NULL"
    elif ctype == "char":
        self.c_undefined = "2"
    elif ctype in ("PyObject **", "void *"):
        self.c_undefined = "NULL"
    elif ctype == "double":
        self.c_undefined = "-113.0"
    elif ctype in ("uint8_t", "uint16_t", "uint32_t", "uint64_t"):
        self.c_undefined = "239"  # An arbitrary number
    else:
        assert False, "Unrecognized ctype: %r" % ctype
</t>
<t tx="ekr.20240308084832.977">def accept(self, visitor: RTypeVisitor[T]) -&gt; T:
    return visitor.visit_rprimitive(self)
</t>
<t tx="ekr.20240308084832.978">def serialize(self) -&gt; str:
    return self.name
</t>
<t tx="ekr.20240308084832.979">def __repr__(self) -&gt; str:
    return "&lt;RPrimitive %s&gt;" % self.name
</t>
<t tx="ekr.20240308084832.98">def __init__(self, self_reg: Register) -&gt; None:
    self.self_reg = self_reg
</t>
<t tx="ekr.20240308084832.980">def __eq__(self, other: object) -&gt; bool:
    return isinstance(other, RPrimitive) and other.name == self.name
</t>
<t tx="ekr.20240308084832.981">def __hash__(self) -&gt; int:
    return hash(self.name)
</t>
<t tx="ekr.20240308084832.982"># NOTE: All the supported instances of RPrimitive are defined
# below. Use these instead of creating new instances.

# Used to represent arbitrary objects and dynamically typed (Any)
# values. There are various ops that let you perform generic, runtime
# checked operations on these (that match Python semantics). See the
# ops in mypyc.primitives.misc_ops, including py_getattr_op,
# py_call_op, and many others.
#
# If there is no more specific RType available for some value, we fall
# back to using this type.
#
# NOTE: Even though this is very flexible, this type should be used as
# little as possible, as generic ops are typically slow. Other types,
# including other primitive types and RInstance, are usually much
# faster.
object_rprimitive: Final = RPrimitive("builtins.object", is_unboxed=False, is_refcounted=True)

# represents a low level pointer of an object
object_pointer_rprimitive: Final = RPrimitive(
    "object_ptr", is_unboxed=False, is_refcounted=False, ctype="PyObject **"
)

# Arbitrary-precision integer (corresponds to Python 'int'). Small
# enough values are stored unboxed, while large integers are
# represented as a tagged pointer to a Python 'int' PyObject. The
# lowest bit is used as the tag to decide whether it is a signed
# unboxed value (shifted left by one) or a PyObject * pointing to an
# 'int' object. Pointers have the least significant bit set.
#
# The undefined/error value is the null pointer (1 -- only the least
# significant bit is set)).
#
# This cannot represent a subclass of int. An instance of a subclass
# of int is coerced to the corresponding 'int' value.
int_rprimitive: Final = RPrimitive(
    "builtins.int", is_unboxed=True, is_refcounted=True, ctype="CPyTagged"
)

# An unboxed integer. The representation is the same as for unboxed
# int_rprimitive (shifted left by one). These can be used when an
# integer is known to be small enough to fit size_t (CPyTagged).
short_int_rprimitive: Final = RPrimitive(
    "short_int", is_unboxed=True, is_refcounted=False, ctype="CPyTagged"
)

# Low level integer types (correspond to C integer types)

int16_rprimitive: Final = RPrimitive(
    "i16",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=True,
    ctype="int16_t",
    size=2,
    error_overlap=True,
)
int32_rprimitive: Final = RPrimitive(
    "i32",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=True,
    ctype="int32_t",
    size=4,
    error_overlap=True,
)
int64_rprimitive: Final = RPrimitive(
    "i64",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=True,
    ctype="int64_t",
    size=8,
    error_overlap=True,
)
uint8_rprimitive: Final = RPrimitive(
    "u8",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=False,
    ctype="uint8_t",
    size=1,
    error_overlap=True,
)

# The following unsigned native int types (u16, u32, u64) are not
# exposed to the user. They are for internal use within mypyc only.

u16_rprimitive: Final = RPrimitive(
    "u16",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=False,
    ctype="uint16_t",
    size=2,
    error_overlap=True,
)
uint32_rprimitive: Final = RPrimitive(
    "u32",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=False,
    ctype="uint32_t",
    size=4,
    error_overlap=True,
)
uint64_rprimitive: Final = RPrimitive(
    "u64",
    is_unboxed=True,
    is_refcounted=False,
    is_native_int=True,
    is_signed=False,
    ctype="uint64_t",
    size=8,
    error_overlap=True,
)

# The C 'int' type
c_int_rprimitive = int32_rprimitive

if IS_32_BIT_PLATFORM:
    c_size_t_rprimitive = uint32_rprimitive
    c_pyssize_t_rprimitive = RPrimitive(
        "native_int",
        is_unboxed=True,
        is_refcounted=False,
        is_native_int=True,
        is_signed=True,
        ctype="int32_t",
        size=4,
    )
else:
    c_size_t_rprimitive = uint64_rprimitive
    c_pyssize_t_rprimitive = RPrimitive(
        "native_int",
        is_unboxed=True,
        is_refcounted=False,
        is_native_int=True,
        is_signed=True,
        ctype="int64_t",
        size=8,
    )

# Untyped pointer, represented as integer in the C backend
pointer_rprimitive: Final = RPrimitive("ptr", is_unboxed=True, is_refcounted=False, ctype="CPyPtr")

# Untyped pointer, represented as void * in the C backend
c_pointer_rprimitive: Final = RPrimitive(
    "c_ptr", is_unboxed=False, is_refcounted=False, ctype="void *"
)

# The type corresponding to mypyc.common.BITMAP_TYPE
bitmap_rprimitive: Final = uint32_rprimitive

# Floats are represent as 'float' PyObject * values. (In the future
# we'll likely switch to a more efficient, unboxed representation.)
float_rprimitive: Final = RPrimitive(
    "builtins.float",
    is_unboxed=True,
    is_refcounted=False,
    ctype="double",
    size=8,
    error_overlap=True,
)

# An unboxed Python bool value. This actually has three possible values
# (0 -&gt; False, 1 -&gt; True, 2 -&gt; error). If you only need True/False, use
# bit_rprimitive instead.
bool_rprimitive: Final = RPrimitive(
    "builtins.bool", is_unboxed=True, is_refcounted=False, ctype="char", size=1
)

# A low-level boolean value with two possible values: 0 and 1. Any
# other value results in undefined behavior. Undefined or error values
# are not supported.
bit_rprimitive: Final = RPrimitive(
    "bit", is_unboxed=True, is_refcounted=False, ctype="char", size=1
)

# The 'None' value. The possible values are 0 -&gt; None and 2 -&gt; error.
none_rprimitive: Final = RPrimitive(
    "builtins.None", is_unboxed=True, is_refcounted=False, ctype="char", size=1
)

# Python list object (or an instance of a subclass of list).
list_rprimitive: Final = RPrimitive("builtins.list", is_unboxed=False, is_refcounted=True)

# Python dict object (or an instance of a subclass of dict).
dict_rprimitive: Final = RPrimitive("builtins.dict", is_unboxed=False, is_refcounted=True)

# Python set object (or an instance of a subclass of set).
set_rprimitive: Final = RPrimitive("builtins.set", is_unboxed=False, is_refcounted=True)

# Python str object. At the C layer, str is referred to as unicode
# (PyUnicode).
str_rprimitive: Final = RPrimitive("builtins.str", is_unboxed=False, is_refcounted=True)

# Python bytes object.
bytes_rprimitive: Final = RPrimitive("builtins.bytes", is_unboxed=False, is_refcounted=True)

# Tuple of an arbitrary length (corresponds to Tuple[t, ...], with
# explicit '...').
tuple_rprimitive: Final = RPrimitive("builtins.tuple", is_unboxed=False, is_refcounted=True)

# Python range object.
range_rprimitive: Final = RPrimitive("builtins.range", is_unboxed=False, is_refcounted=True)


def is_tagged(rtype: RType) -&gt; bool:
    return rtype is int_rprimitive or rtype is short_int_rprimitive
</t>
<t tx="ekr.20240308084832.983">def is_int_rprimitive(rtype: RType) -&gt; bool:
    return rtype is int_rprimitive
</t>
<t tx="ekr.20240308084832.984">def is_short_int_rprimitive(rtype: RType) -&gt; bool:
    return rtype is short_int_rprimitive
</t>
<t tx="ekr.20240308084832.985">def is_int16_rprimitive(rtype: RType) -&gt; TypeGuard[RPrimitive]:
    return rtype is int16_rprimitive
</t>
<t tx="ekr.20240308084832.986">def is_int32_rprimitive(rtype: RType) -&gt; TypeGuard[RPrimitive]:
    return rtype is int32_rprimitive or (
        rtype is c_pyssize_t_rprimitive and rtype._ctype == "int32_t"
    )
</t>
<t tx="ekr.20240308084832.987">def is_int64_rprimitive(rtype: RType) -&gt; bool:
    return rtype is int64_rprimitive or (
        rtype is c_pyssize_t_rprimitive and rtype._ctype == "int64_t"
    )
</t>
<t tx="ekr.20240308084832.988">def is_fixed_width_rtype(rtype: RType) -&gt; TypeGuard[RPrimitive]:
    return (
        is_int64_rprimitive(rtype)
        or is_int32_rprimitive(rtype)
        or is_int16_rprimitive(rtype)
        or is_uint8_rprimitive(rtype)
    )
</t>
<t tx="ekr.20240308084832.989">def is_uint8_rprimitive(rtype: RType) -&gt; TypeGuard[RPrimitive]:
    return rtype is uint8_rprimitive
</t>
<t tx="ekr.20240308084832.99">def visit_branch(self, op: Branch) -&gt; tuple[set[str], set[str]]:
    return set(), set()
</t>
<t tx="ekr.20240308084832.990">def is_uint32_rprimitive(rtype: RType) -&gt; bool:
    return rtype is uint32_rprimitive
</t>
<t tx="ekr.20240308084832.991">def is_uint64_rprimitive(rtype: RType) -&gt; bool:
    return rtype is uint64_rprimitive
</t>
<t tx="ekr.20240308084832.992">def is_c_py_ssize_t_rprimitive(rtype: RType) -&gt; bool:
    return rtype is c_pyssize_t_rprimitive
</t>
<t tx="ekr.20240308084832.993">def is_pointer_rprimitive(rtype: RType) -&gt; bool:
    return rtype is pointer_rprimitive
</t>
<t tx="ekr.20240308084832.994">def is_float_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.float"
</t>
<t tx="ekr.20240308084832.995">def is_bool_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.bool"
</t>
<t tx="ekr.20240308084832.996">def is_bit_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "bit"
</t>
<t tx="ekr.20240308084832.997">def is_object_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.object"
</t>
<t tx="ekr.20240308084832.998">def is_none_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.None"
</t>
<t tx="ekr.20240308084832.999">def is_list_rprimitive(rtype: RType) -&gt; bool:
    return isinstance(rtype, RPrimitive) and rtype.name == "builtins.list"
</t>
<t tx="ekr.20240308084847.1">@language python
"""Recursively import all python files in a directory and clean the result."""
@tabwidth -4 # For a better match.
g.cls()
&lt;&lt; rust dir_list &gt;&gt;

dir_ = r'C:\Python\Python3.12\Lib\site-packages\coverage'
dir_ = r'C:\Python\Python3.12\Lib\site-packages\mypyc'

c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    # '.html', '.js', '.json', '.py', '.rs', '.svg', '.ts', '.tsx']
    # '.codon', '.cpp', '.cc', '.el', '.scm',
    theTypes = ['.py'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20240308084847.2">dir_list = (
    r'C:\Repos\RustPython\common\src',
    r'C:\Repos\RustPython\compiler\codegen\src',
    r'C:\Repos\RustPython\compiler\core\src',
    r'C:\Repos\RustPython\compiler\src',
    r'C:\Repos\RustPython\compiler\codegen\src',  # compile.rs: AST to bytecode.
    r'C:\Repos\RustPython\compiler\core\src', # bytecode.rs: implements bytecodes.
    
    r'C:\Repos\RustPython\derive\src',
    r'C:\Repos\RustPython\derive-impl\src',
    r'C:\Repos\RustPython\pylib\src',
    r'C:\Repos\RustPython\src',
    r'C:\Repos\RustPython\stdlib\src',
    r'C:\Repos\RustPython\vm\src', # compiler.rs.
    r'C:\Repos\RustPython\vm\src\stdlib', # *****ast.rs  Also, many .rs versions of stdlib.
    r'C:\Repos\RustPython\vm\src\vm',  # compile.rs.
    r'C:\Repos\RustPython\vm\src\stdlib\ast', # gen.rs automatically generated by ast/asdl_rs.py.
)
</t>
<t tx="ekr.20240308085046.1"></t>
</tnodes>
</leo_file>
